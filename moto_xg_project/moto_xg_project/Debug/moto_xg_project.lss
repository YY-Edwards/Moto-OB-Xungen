
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ae7c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d000  8000d000  0000d400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001230  8000d200  8000d200  0000d600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a48  00000004  8000e430  0000ec04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a4c  8000ee78  0000f64c  2**0
                  ALLOC
  7 .bss          00004748  00000a50  8000ee78  0000f650  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f64c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000014a8  00000000  00000000  0000f680  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000304a  00000000  00000000  00010b28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002af3c  00000000  00000000  00013b72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000700a  00000000  00000000  0003eaae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000cefb  00000000  00000000  00045ab8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003860  00000000  00000000  000529b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007a6b  00000000  00000000  00056214  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000eb52  00000000  00000000  0005dc7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001570  00000000  00000000  0006c7d8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c1 b4 	sub	pc,pc,-15948

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d ec       	ld.ub	r12,r6[0x6]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3c f8       	mov	r8,-49
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 18       	sub	r8,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f8       	sub	r8,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d2 00       	acall	0x20
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6d 8c       	ld.w	r12,r6[0x60]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 5c       	eor	r12,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;
extern volatile DateTime_t Current_time;
static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000209c:	49 77       	lddpc	r7,800020f8 <app_cfg+0x68>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000209e:	30 62       	mov	r2,6
800020a0:	30 13       	mov	r3,1
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a2:	30 11       	mov	r1,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020a4:	30 c0       	mov	r0,12
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 95       	mov	r5,r8
800020a8:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c0 a1       	brne	800020c8 <app_cfg+0x38>
800020b6:	0f 88       	ld.ub	r8,r7[0x0]
800020b8:	58 08       	cp.w	r8,0
800020ba:	c0 71       	brne	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
800020bc:	ae 81       	st.b	r7[0x0],r1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020be:	00 9b       	mov	r11,r0
800020c0:	06 9c       	mov	r12,r3
800020c2:	f0 1f 00 0f 	mcall	800020fc <app_cfg+0x6c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c6:	c0 d8       	rjmp	800020e0 <app_cfg+0x50>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800020c8:	0f 88       	ld.ub	r8,r7[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 30       	breq	800020d2 <app_cfg+0x42>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
800020ce:	d7 03       	nop
800020d0:	c0 88       	rjmp	800020e0 <app_cfg+0x50>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			nop();
800020d6:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800020d8:	04 9b       	mov	r11,r2
800020da:	06 9c       	mov	r12,r3
800020dc:	f0 1f 00 08 	mcall	800020fc <app_cfg+0x6c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e0:	08 9b       	mov	r11,r4
800020e2:	0a 9c       	mov	r12,r5
800020e4:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020e8:	ce 2b       	rjmp	800020ac <app_cfg+0x1c>
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	6a 7c       	ld.w	r12,r5[0x1c]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 54       	eor	r4,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d ec       	ld.ub	r12,r6[0x6]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 64       	and	r4,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	3e 84       	mov	r4,-24
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	6c 2c       	ld.w	r12,r6[0x8]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	d2 08       	*unknown*
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	71 50       	ld.w	r0,r8[0x54]

80002118 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002118:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000211a:	48 99       	lddpc	r9,8000213c <app_payload_rx_proc+0x24>
8000211c:	13 88       	ld.ub	r8,r9[0x0]
8000211e:	2f f8       	sub	r8,-1
80002120:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002122:	30 39       	mov	r9,3
80002124:	f2 08 18 00 	cp.b	r8,r9
80002128:	c0 71       	brne	80002136 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000212a:	30 09       	mov	r9,0
8000212c:	48 48       	lddpc	r8,8000213c <app_payload_rx_proc+0x24>
8000212e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002130:	48 4c       	lddpc	r12,80002140 <app_payload_rx_proc+0x28>
80002132:	f0 1f 00 05 	mcall	80002144 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002136:	48 58       	lddpc	r8,80002148 <app_payload_rx_proc+0x30>
80002138:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000213a:	d8 02       	popm	pc
8000213c:	00 00       	add	r0,r0
8000213e:	0a 61       	and	r1,r5
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	d2 0c       	*unknown*
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	71 50       	ld.w	r0,r8[0x54]
80002148:	00 00       	add	r0,r0
8000214a:	0a 60       	and	r0,r5

8000214c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_brdcst_func+0x10>
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	d2 18       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	71 50       	ld.w	r0,r8[0x54]

80002160 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_reply_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_reply_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	d2 38       	*unknown*
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	71 50       	ld.w	r0,r8[0x54]

80002174 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <FD_request_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <FD_request_func+0x10>
	
	
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d2 54       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	71 50       	ld.w	r0,r8[0x54]

80002188 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002188:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000218a:	48 3c       	lddpc	r12,80002194 <EnOB_brdcst_func+0xc>
8000218c:	f0 1f 00 03 	mcall	80002198 <EnOB_brdcst_func+0x10>
}
80002190:	d8 02       	popm	pc
80002192:	00 00       	add	r0,r0
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d2 70       	acall	0x27
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	71 50       	ld.w	r0,r8[0x54]

8000219c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000219c:	eb cd 40 80 	pushm	r7,lr
800021a0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800021a2:	19 a9       	ld.ub	r9,r12[0x2]
800021a4:	30 08       	mov	r8,0
800021a6:	f0 09 18 00 	cp.b	r9,r8
800021aa:	c1 91       	brne	800021dc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021ac:	19 b8       	ld.ub	r8,r12[0x3]
800021ae:	30 19       	mov	r9,1
800021b0:	f2 08 18 00 	cp.b	r8,r9
800021b4:	c0 61       	brne	800021c0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021b6:	49 0c       	lddpc	r12,800021f4 <EnOB_reply_func+0x58>
800021b8:	f0 1f 00 10 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021c0:	58 08       	cp.w	r8,0
800021c2:	c0 61       	brne	800021ce <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021c4:	48 ec       	lddpc	r12,800021fc <EnOB_reply_func+0x60>
800021c6:	f0 1f 00 0d 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	48 cc       	lddpc	r12,80002200 <EnOB_reply_func+0x64>
800021d2:	f0 1f 00 0a 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021d6:	2f fd       	sub	sp,-4
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021dc:	48 ac       	lddpc	r12,80002204 <EnOB_reply_func+0x68>
800021de:	f0 1f 00 07 	mcall	800021f8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 9c       	lddpc	r12,80002208 <EnOB_reply_func+0x6c>
800021e8:	f0 1f 00 04 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	d2 88       	*unknown*
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	71 50       	ld.w	r0,r8[0x54]
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	d2 a0       	acall	0x2a
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	d2 b4       	*unknown*
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	d2 cc       	*unknown*
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	d2 e8       	*unknown*

8000220c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000220e:	19 a9       	ld.ub	r9,r12[0x2]
80002210:	31 18       	mov	r8,17
80002212:	f0 09 18 00 	cp.b	r9,r8
80002216:	c0 41       	brne	8000221e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002218:	48 2c       	lddpc	r12,80002220 <SingleDetection_brdcst_func+0x14>
8000221a:	f0 1f 00 03 	mcall	80002224 <SingleDetection_brdcst_func+0x18>
8000221e:	d8 02       	popm	pc
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	d3 00       	acall	0x30
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	71 50       	ld.w	r0,r8[0x54]

80002228 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002228:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000222a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000222e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002230:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xb4>
80002232:	f0 1f 00 2c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002236:	0f 88       	ld.ub	r8,r7[0x0]
80002238:	1a d8       	st.w	--sp,r8
8000223a:	4a bc       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xbc>
8000223c:	f0 1f 00 29 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002240:	1a d5       	st.w	--sp,r5
80002242:	4a ac       	lddpc	r12,800022e8 <ButtonConfig_brdcst_func+0xc0>
80002244:	f0 1f 00 27 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002248:	0f a8       	ld.ub	r8,r7[0x2]
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	4a 8c       	lddpc	r12,800022ec <ButtonConfig_brdcst_func+0xc4>
8000224e:	f0 1f 00 25 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002252:	2f dd       	sub	sp,-12
80002254:	58 05       	cp.w	r5,0
80002256:	c4 10       	breq	800022d8 <ButtonConfig_brdcst_func+0xb0>
80002258:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225a:	4a 64       	lddpc	r4,800022f0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225c:	4a 63       	lddpc	r3,800022f4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000225e:	4a 72       	lddpc	r2,800022f8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	4a 71       	lddpc	r1,800022fc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002262:	4a 80       	lddpc	r0,80002300 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002264:	0f b9       	ld.ub	r9,r7[0x3]
80002266:	0f c8       	ld.ub	r8,r7[0x4]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	08 9c       	mov	r12,r4
80002272:	f0 1f 00 1c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002276:	0f d9       	ld.ub	r9,r7[0x5]
80002278:	0f e8       	ld.ub	r8,r7[0x6]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	06 9c       	mov	r12,r3
80002284:	f0 1f 00 17 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002288:	0f f9       	ld.ub	r9,r7[0x7]
8000228a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000228e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002292:	1a d8       	st.w	--sp,r8
80002294:	1a d6       	st.w	--sp,r6
80002296:	04 9c       	mov	r12,r2
80002298:	f0 1f 00 12 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000229c:	ef 39 00 09 	ld.ub	r9,r7[9]
800022a0:	ef 38 00 0a 	ld.ub	r8,r7[10]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	02 9c       	mov	r12,r1
800022ae:	f0 1f 00 0d 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022b2:	2f 8d       	sub	sp,-32
800022b4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022bc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022c0:	1a d8       	st.w	--sp,r8
800022c2:	1a d6       	st.w	--sp,r6
800022c4:	00 9c       	mov	r12,r0
800022c6:	f0 1f 00 07 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
800022ca:	2f f6       	sub	r6,-1
800022cc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ce:	2f ed       	sub	sp,-8
800022d0:	ec 05 18 00 	cp.b	r5,r6
800022d4:	fe 9b ff c8 	brhi	80002264 <ButtonConfig_brdcst_func+0x3c>
800022d8:	d8 32       	popm	r0-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	d3 14       	*unknown*
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	71 50       	ld.w	r0,r8[0x54]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	d3 34       	*unknown*
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	d3 48       	*unknown*
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	d3 60       	acall	0x36
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d3 80       	acall	0x38
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d3 a8       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	d3 d0       	acall	0x3d
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d3 f4       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d4 1c       	*unknown*

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d4 40       	acall	0x44
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	71 50       	ld.w	r0,r8[0x54]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d3 34       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d4 58       	*unknown*

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	4a 7c       	lddpc	r12,800023f4 <DataSession_brdcst_func+0xac>
8000235a:	f0 1f 00 28 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	4a 4c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
8000236e:	f0 1f 00 23 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	4a 2c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
8000237a:	f0 1f 00 20 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c3 70       	breq	800023f0 <DataSession_brdcst_func+0xa8>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	4a 04       	lddpc	r4,80002404 <DataSession_brdcst_func+0xbc>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 19 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	49 8c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
800023ac:	f0 1f 00 13 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800023b0:	0d 88       	ld.ub	r8,r6[0x0]
800023b2:	2f fd       	sub	sp,-4
800023b4:	30 39       	mov	r9,3
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c0 51       	brne	800023c4 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
800023bc:	49 4c       	lddpc	r12,8000240c <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 0f 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023c2:	c0 88       	rjmp	800023d2 <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800023c4:	30 49       	mov	r9,4
800023c6:	f2 08 18 00 	cp.b	r8,r9
800023ca:	c0 41       	brne	800023d2 <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
800023cc:	49 1c       	lddpc	r12,80002410 <DataSession_brdcst_func+0xc8>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023d2:	0d a7       	ld.ub	r7,r6[0x2]
800023d4:	0d b8       	ld.ub	r8,r6[0x3]
800023d6:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
800023da:	0d 98       	ld.ub	r8,r6[0x1]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	48 8c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
800023e0:	f0 1f 00 06 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023e4:	5c 77       	castu.h	r7
800023e6:	1a d7       	st.w	--sp,r7
800023e8:	48 6c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
800023ea:	f0 1f 00 04 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023ee:	2f ed       	sub	sp,-8
800023f0:	d8 22       	popm	r4-r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d4 74       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	71 50       	ld.w	r0,r8[0x54]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d4 88       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d4 a0       	acall	0x4a
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d4 bc       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d4 d4       	*unknown*
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	d4 e0       	acall	0x4e
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d4 f8       	*unknown*

80002414 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
80002418:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000241a:	19 a9       	ld.ub	r9,r12[0x2]
8000241c:	30 08       	mov	r8,0
8000241e:	f0 09 18 00 	cp.b	r9,r8
80002422:	c1 11       	brne	80002444 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002424:	49 3c       	lddpc	r12,80002470 <DataSession_reply_func+0x5c>
80002426:	f0 1f 00 14 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000242a:	0f b8       	ld.ub	r8,r7[0x3]
8000242c:	1a d8       	st.w	--sp,r8
8000242e:	49 3c       	lddpc	r12,80002478 <DataSession_reply_func+0x64>
80002430:	f0 1f 00 11 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002434:	0f c8       	ld.ub	r8,r7[0x4]
80002436:	1a d8       	st.w	--sp,r8
80002438:	49 1c       	lddpc	r12,8000247c <DataSession_reply_func+0x68>
8000243a:	f0 1f 00 0f 	mcall	80002474 <DataSession_reply_func+0x60>
8000243e:	2f ed       	sub	sp,-8
80002440:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002444:	48 fc       	lddpc	r12,80002480 <DataSession_reply_func+0x6c>
80002446:	f0 1f 00 0c 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000244a:	0f a8       	ld.ub	r8,r7[0x2]
8000244c:	1a d8       	st.w	--sp,r8
8000244e:	48 ec       	lddpc	r12,80002484 <DataSession_reply_func+0x70>
80002450:	f0 1f 00 09 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002454:	0f b8       	ld.ub	r8,r7[0x3]
80002456:	1a d8       	st.w	--sp,r8
80002458:	48 cc       	lddpc	r12,80002488 <DataSession_reply_func+0x74>
8000245a:	f0 1f 00 07 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000245e:	0f c8       	ld.ub	r8,r7[0x4]
80002460:	1a d8       	st.w	--sp,r8
80002462:	48 bc       	lddpc	r12,8000248c <DataSession_reply_func+0x78>
80002464:	f0 1f 00 04 	mcall	80002474 <DataSession_reply_func+0x60>
80002468:	2f dd       	sub	sp,-12
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d5 10       	acall	0x51
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	71 50       	ld.w	r0,r8[0x54]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	d5 20       	acall	0x52
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	d5 2c       	*unknown*
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d5 38       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d5 48       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d5 58       	*unknown*
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	d5 64       	*unknown*

80002490 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002498:	0f 98       	ld.ub	r8,r7[0x1]
8000249a:	1a d8       	st.w	--sp,r8
8000249c:	48 bc       	lddpc	r12,800024c8 <CallControl_brdcst_func+0x38>
8000249e:	f0 1f 00 0c 	mcall	800024cc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024a2:	2f fd       	sub	sp,-4
800024a4:	0f 99       	ld.ub	r9,r7[0x1]
800024a6:	30 38       	mov	r8,3
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c0 41       	brne	800024b4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 88       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024b2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 48       	mov	r8,4
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 41       	brne	800024c4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d5 70       	acall	0x57
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	71 50       	ld.w	r0,r8[0x54]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 62       	and	r2,r5

800024d4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024d4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024d8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024dc:	0f 99       	ld.ub	r9,r7[0x1]
800024de:	30 08       	mov	r8,0
800024e0:	f0 09 18 00 	cp.b	r9,r8
800024e4:	c0 71       	brne	800024f2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024e6:	48 ac       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x38>
800024e8:	f0 1f 00 0a 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024ec:	30 09       	mov	r9,0
800024ee:	48 a8       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
800024f0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024f2:	0f 99       	ld.ub	r9,r7[0x1]
800024f4:	30 18       	mov	r8,1
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 71       	brne	80002508 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024fc:	48 7c       	lddpc	r12,80002518 <TransmitControl_brdcst_func+0x44>
800024fe:	f0 1f 00 05 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002502:	30 19       	mov	r9,1
80002504:	48 48       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
80002506:	b0 89       	st.b	r8[0x0],r9
80002508:	e3 cd 80 80 	ldm	sp++,r7,pc
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	d5 88       	*unknown*
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	71 50       	ld.w	r0,r8[0x54]
80002514:	00 00       	add	r0,r0
80002516:	0a 58       	eor	r8,r5
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d5 a0       	acall	0x5a

8000251c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 61       	brne	80002558 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000252e:	48 ec       	lddpc	r12,80002564 <TransmitControl_reply_func+0x48>
80002530:	f0 1f 00 0e 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002534:	0f 98       	ld.ub	r8,r7[0x1]
80002536:	1a d8       	st.w	--sp,r8
80002538:	48 dc       	lddpc	r12,8000256c <TransmitControl_reply_func+0x50>
8000253a:	f0 1f 00 0c 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000253e:	0f a8       	ld.ub	r8,r7[0x2]
80002540:	1a d8       	st.w	--sp,r8
80002542:	48 cc       	lddpc	r12,80002570 <TransmitControl_reply_func+0x54>
80002544:	f0 1f 00 09 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002548:	0f b8       	ld.ub	r8,r7[0x3]
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	48 ac       	lddpc	r12,80002574 <TransmitControl_reply_func+0x58>
8000254e:	f0 1f 00 07 	mcall	80002568 <TransmitControl_reply_func+0x4c>
80002552:	2f dd       	sub	sp,-12
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002558:	48 8c       	lddpc	r12,80002578 <TransmitControl_reply_func+0x5c>
8000255a:	f0 1f 00 04 	mcall	80002568 <TransmitControl_reply_func+0x4c>
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d5 b4       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	71 50       	ld.w	r0,r8[0x54]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d5 d0       	acall	0x5d
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d5 e4       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d6 00       	acall	0x60
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d6 10       	acall	0x61

8000257c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 51       	brne	80002590 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002588:	48 4c       	lddpc	r12,80002598 <AudioRoutingControl_reply_func+0x1c>
8000258a:	f0 1f 00 05 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
8000258e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002590:	48 4c       	lddpc	r12,800025a0 <AudioRoutingControl_reply_func+0x24>
80002592:	f0 1f 00 03 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
80002596:	d8 02       	popm	pc
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d6 28       	*unknown*
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	71 50       	ld.w	r0,r8[0x54]
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	d6 38       	*unknown*

800025a4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025ac:	0f 89       	ld.ub	r9,r7[0x0]
800025ae:	30 08       	mov	r8,0
800025b0:	f0 09 18 00 	cp.b	r9,r8
800025b4:	c1 b1       	brne	800025ea <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b6:	0f b8       	ld.ub	r8,r7[0x3]
800025b8:	31 09       	mov	r9,16
800025ba:	f2 08 18 00 	cp.b	r8,r9
800025be:	c0 f1       	brne	800025dc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025c0:	48 dc       	lddpc	r12,800025f4 <Volume_reply_func+0x50>
800025c2:	f0 1f 00 0e 	mcall	800025f8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c6:	0f 99       	ld.ub	r9,r7[0x1]
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ce:	1a d8       	st.w	--sp,r8
800025d0:	48 bc       	lddpc	r12,800025fc <Volume_reply_func+0x58>
800025d2:	f0 1f 00 0a 	mcall	800025f8 <Volume_reply_func+0x54>
800025d6:	2f fd       	sub	sp,-4
800025d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025dc:	1a d8       	st.w	--sp,r8
800025de:	48 9c       	lddpc	r12,80002600 <Volume_reply_func+0x5c>
800025e0:	f0 1f 00 06 	mcall	800025f8 <Volume_reply_func+0x54>
800025e4:	2f fd       	sub	sp,-4
800025e6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ea:	48 7c       	lddpc	r12,80002604 <Volume_reply_func+0x60>
800025ec:	f0 1f 00 03 	mcall	800025f8 <Volume_reply_func+0x54>
800025f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d6 4c       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	71 50       	ld.w	r0,r8[0x54]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d6 60       	acall	0x66
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	d6 7c       	*unknown*
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	d6 94       	*unknown*

80002608 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002608:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000260a:	19 d9       	ld.ub	r9,r12[0x5]
8000260c:	30 08       	mov	r8,0
8000260e:	f0 09 18 00 	cp.b	r9,r8
80002612:	c0 81       	brne	80002622 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002614:	10 99       	mov	r9,r8
80002616:	48 78       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002618:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000261a:	48 7c       	lddpc	r12,80002634 <spk_brdcst_func+0x2c>
8000261c:	f0 1f 00 07 	mcall	80002638 <spk_brdcst_func+0x30>
80002620:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002622:	30 19       	mov	r9,1
80002624:	48 38       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002626:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002628:	48 5c       	lddpc	r12,8000263c <spk_brdcst_func+0x34>
8000262a:	f0 1f 00 04 	mcall	80002638 <spk_brdcst_func+0x30>
8000262e:	d8 02       	popm	pc
80002630:	00 00       	add	r0,r0
80002632:	0a 50       	eor	r0,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d6 ac       	*unknown*
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	71 50       	ld.w	r0,r8[0x54]
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	d6 bc       	*unknown*

80002640 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002640:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002642:	19 a9       	ld.ub	r9,r12[0x2]
80002644:	30 08       	mov	r8,0
80002646:	f0 09 18 00 	cp.b	r9,r8
8000264a:	c0 f1       	brne	80002668 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000264c:	19 e9       	ld.ub	r9,r12[0x6]
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c0 40       	breq	8000265a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002654:	30 19       	mov	r9,1
80002656:	48 98       	lddpc	r8,80002678 <spk_reply_func+0x38>
80002658:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000265a:	19 e8       	ld.ub	r8,r12[0x6]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 8c       	lddpc	r12,8000267c <spk_reply_func+0x3c>
80002660:	f0 1f 00 08 	mcall	80002680 <spk_reply_func+0x40>
80002664:	2f fd       	sub	sp,-4
80002666:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002668:	30 09       	mov	r9,0
8000266a:	48 48       	lddpc	r8,80002678 <spk_reply_func+0x38>
8000266c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266e:	48 6c       	lddpc	r12,80002684 <spk_reply_func+0x44>
80002670:	f0 1f 00 04 	mcall	80002680 <spk_reply_func+0x40>
80002674:	d8 02       	popm	pc
80002676:	00 00       	add	r0,r0
80002678:	00 00       	add	r0,r0
8000267a:	0a 50       	eor	r0,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	d6 c8       	*unknown*
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	71 50       	ld.w	r0,r8[0x54]
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	d6 d8       	*unknown*

80002688 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000268c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002690:	0f a9       	ld.ub	r9,r7[0x2]
80002692:	30 08       	mov	r8,0
80002694:	f0 09 18 00 	cp.b	r9,r8
80002698:	c0 71       	brne	800026a6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000269a:	48 dc       	lddpc	r12,800026cc <mic_brdcst_func+0x44>
8000269c:	f0 1f 00 0d 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026a0:	30 09       	mov	r9,0
800026a2:	48 d8       	lddpc	r8,800026d4 <mic_brdcst_func+0x4c>
800026a4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a6:	0f a9       	ld.ub	r9,r7[0x2]
800026a8:	31 18       	mov	r8,17
800026aa:	f0 09 18 00 	cp.b	r9,r8
800026ae:	c0 d1       	brne	800026c8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026b0:	48 ac       	lddpc	r12,800026d8 <mic_brdcst_func+0x50>
800026b2:	f0 1f 00 08 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b6:	48 89       	lddpc	r9,800026d4 <mic_brdcst_func+0x4c>
800026b8:	30 18       	mov	r8,1
800026ba:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026bc:	13 89       	ld.ub	r9,r9[0x0]
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c0 31       	brne	800026c8 <mic_brdcst_func+0x40>
800026c4:	48 68       	lddpc	r8,800026dc <mic_brdcst_func+0x54>
800026c6:	11 88       	ld.ub	r8,r8[0x0]
800026c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d6 e4       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	71 50       	ld.w	r0,r8[0x54]
800026d4:	00 00       	add	r0,r0
800026d6:	0a 65       	and	r5,r5
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d6 f8       	*unknown*
800026dc:	00 00       	add	r0,r0
800026de:	0a 62       	and	r2,r5

800026e0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e8:	49 ac       	lddpc	r12,80002750 <mic_reply_func+0x70>
800026ea:	f0 1f 00 1b 	mcall	80002754 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ee:	0f 89       	ld.ub	r9,r7[0x0]
800026f0:	30 08       	mov	r8,0
800026f2:	f0 09 18 00 	cp.b	r9,r8
800026f6:	c2 71       	brne	80002744 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f8:	0f 98       	ld.ub	r8,r7[0x1]
800026fa:	30 29       	mov	r9,2
800026fc:	f2 08 18 00 	cp.b	r8,r9
80002700:	c1 b1       	brne	80002736 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002702:	49 6c       	lddpc	r12,80002758 <mic_reply_func+0x78>
80002704:	f0 1f 00 14 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002708:	0f a8       	ld.ub	r8,r7[0x2]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	49 4c       	lddpc	r12,8000275c <mic_reply_func+0x7c>
8000270e:	f0 1f 00 12 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002712:	0f b8       	ld.ub	r8,r7[0x3]
80002714:	1a d8       	st.w	--sp,r8
80002716:	49 3c       	lddpc	r12,80002760 <mic_reply_func+0x80>
80002718:	f0 1f 00 0f 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000271c:	0f c8       	ld.ub	r8,r7[0x4]
8000271e:	1a d8       	st.w	--sp,r8
80002720:	49 1c       	lddpc	r12,80002764 <mic_reply_func+0x84>
80002722:	f0 1f 00 0d 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002726:	0f d8       	ld.ub	r8,r7[0x5]
80002728:	1a d8       	st.w	--sp,r8
8000272a:	49 0c       	lddpc	r12,80002768 <mic_reply_func+0x88>
8000272c:	f0 1f 00 0a 	mcall	80002754 <mic_reply_func+0x74>
80002730:	2f cd       	sub	sp,-16
80002732:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002736:	1a d8       	st.w	--sp,r8
80002738:	48 dc       	lddpc	r12,8000276c <mic_reply_func+0x8c>
8000273a:	f0 1f 00 07 	mcall	80002754 <mic_reply_func+0x74>
8000273e:	2f fd       	sub	sp,-4
80002740:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002744:	48 bc       	lddpc	r12,80002770 <mic_reply_func+0x90>
80002746:	f0 1f 00 04 	mcall	80002754 <mic_reply_func+0x74>
8000274a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274e:	00 00       	add	r0,r0
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	d7 0c       	*unknown*
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	71 50       	ld.w	r0,r8[0x54]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	d7 1c       	*unknown*
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	d7 30       	acall	0x73
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	d7 44       	*unknown*
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	d7 60       	acall	0x76
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d7 78       	*unknown*
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	d7 90       	acall	0x79
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	d7 a8       	*unknown*

80002774 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002774:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002778:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000277c:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x34>
8000277e:	f0 1f 00 0c 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002782:	0f 88       	ld.ub	r8,r7[0x0]
80002784:	1a d8       	st.w	--sp,r8
80002786:	48 bc       	lddpc	r12,800027b0 <dcm_brdcst_func+0x3c>
80002788:	f0 1f 00 09 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000278c:	0f a8       	ld.ub	r8,r7[0x2]
8000278e:	1a d8       	st.w	--sp,r8
80002790:	48 9c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x40>
80002792:	f0 1f 00 07 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002796:	0f 98       	ld.ub	r8,r7[0x1]
80002798:	1a d8       	st.w	--sp,r8
8000279a:	48 8c       	lddpc	r12,800027b8 <dcm_brdcst_func+0x44>
8000279c:	f0 1f 00 04 	mcall	800027ac <dcm_brdcst_func+0x38>
800027a0:	2f dd       	sub	sp,-12
	
	
}
800027a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a6:	00 00       	add	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	d7 b8       	*unknown*
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	71 50       	ld.w	r0,r8[0x54]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d7 cc       	*unknown*
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d7 e0       	acall	0x7e
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d7 f8       	*unknown*

800027bc <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027bc:	eb cd 40 80 	pushm	r7,lr
800027c0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027c2:	19 a9       	ld.ub	r9,r12[0x2]
800027c4:	30 08       	mov	r8,0
800027c6:	f0 09 18 00 	cp.b	r9,r8
800027ca:	c1 b1       	brne	80002800 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027cc:	19 b8       	ld.ub	r8,r12[0x3]
800027ce:	30 19       	mov	r9,1
800027d0:	f2 08 18 00 	cp.b	r8,r9
800027d4:	c0 51       	brne	800027de <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d6:	48 ec       	lddpc	r12,8000280c <dcm_reply_func+0x50>
800027d8:	f0 1f 00 0e 	mcall	80002810 <dcm_reply_func+0x54>
800027dc:	c0 a8       	rjmp	800027f0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027de:	58 08       	cp.w	r8,0
800027e0:	c0 51       	brne	800027ea <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027e2:	48 dc       	lddpc	r12,80002814 <dcm_reply_func+0x58>
800027e4:	f0 1f 00 0b 	mcall	80002810 <dcm_reply_func+0x54>
800027e8:	c0 48       	rjmp	800027f0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ea:	48 cc       	lddpc	r12,80002818 <dcm_reply_func+0x5c>
800027ec:	f0 1f 00 09 	mcall	80002810 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027f0:	0f d8       	ld.ub	r8,r7[0x5]
800027f2:	1a d8       	st.w	--sp,r8
800027f4:	48 ac       	lddpc	r12,8000281c <dcm_reply_func+0x60>
800027f6:	f0 1f 00 07 	mcall	80002810 <dcm_reply_func+0x54>
800027fa:	2f fd       	sub	sp,-4
800027fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002800:	48 8c       	lddpc	r12,80002820 <dcm_reply_func+0x64>
80002802:	f0 1f 00 04 	mcall	80002810 <dcm_reply_func+0x54>
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	d8 14       	*unknown*
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	71 50       	ld.w	r0,r8[0x54]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	d8 28       	*unknown*
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d8 3c       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	d8 50       	acall	0x85
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	d8 5c       	*unknown*

80002824 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002824:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002826:	19 a9       	ld.ub	r9,r12[0x2]
80002828:	30 08       	mov	r8,0
8000282a:	f0 09 18 00 	cp.b	r9,r8
8000282e:	c0 51       	brne	80002838 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x1c>
80002832:	f0 1f 00 05 	mcall	80002844 <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002838:	48 4c       	lddpc	r12,80002848 <ToneControl_reply_func+0x24>
8000283a:	f0 1f 00 03 	mcall	80002844 <ToneControl_reply_func+0x20>
8000283e:	d8 02       	popm	pc
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	d8 68       	*unknown*
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	71 50       	ld.w	r0,r8[0x54]
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	d8 74       	*unknown*

8000284c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000284c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002850:	19 c7       	ld.ub	r7,r12[0x4]
80002852:	19 d8       	ld.ub	r8,r12[0x5]
80002854:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002858:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000285a:	48 dc       	lddpc	r12,8000288c <Phyuserinput_brdcst_func+0x40>
8000285c:	f0 1f 00 0d 	mcall	80002890 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002860:	36 08       	mov	r8,96
80002862:	f0 07 19 00 	cp.h	r7,r8
80002866:	c1 11       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
80002868:	48 b8       	lddpc	r8,80002894 <Phyuserinput_brdcst_func+0x48>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 18       	mov	r8,1
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 b1       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002874:	31 4b       	mov	r11,20
80002876:	30 1c       	mov	r12,1
80002878:	f0 1f 00 08 	mcall	80002898 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
8000287c:	e0 6c 03 20 	mov	r12,800
80002880:	f0 1f 00 07 	mcall	8000289c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002884:	f0 1f 00 07 	mcall	800028a0 <Phyuserinput_brdcst_func+0x54>
80002888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d8 80       	acall	0x88
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	71 50       	ld.w	r0,r8[0x54]
80002894:	00 00       	add	r0,r0
80002896:	0a 64       	and	r4,r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	3e 84       	mov	r4,-24
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	6b e4       	ld.w	r4,r5[0x78]
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	4e 58       	lddpc	r8,80002a34 <phy_tx+0x44>

800028a4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028a6:	19 e8       	ld.ub	r8,r12[0x6]
800028a8:	30 19       	mov	r9,1
800028aa:	f2 08 18 00 	cp.b	r8,r9
800028ae:	c0 61       	brne	800028ba <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b0:	48 98       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b2:	70 09       	ld.w	r9,r8[0x0]
800028b4:	a1 a9       	sbr	r9,0x0
800028b6:	91 09       	st.w	r8[0x0],r9
800028b8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ba:	30 29       	mov	r9,2
800028bc:	f2 08 18 00 	cp.b	r8,r9
800028c0:	c0 80       	breq	800028d0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028c2:	48 58       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c4:	70 09       	ld.w	r9,r8[0x0]
800028c6:	e0 19 ff fc 	andl	r9,0xfffc
800028ca:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028cc:	f0 1f 00 03 	mcall	800028d8 <DeviceInitializationStatus_brdcst_func+0x34>
800028d0:	d8 02       	popm	pc
800028d2:	00 00       	add	r0,r0
800028d4:	00 00       	add	r0,r0
800028d6:	0d ec       	ld.ub	r12,r6[0x6]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	3d d8       	mov	r8,-35

800028dc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028dc:	20 1c       	sub	r12,1
800028de:	5c 5c       	castu.b	r12
800028e0:	31 18       	mov	r8,17
800028e2:	f0 0c 18 00 	cp.b	r12,r8
800028e6:	e0 88 00 03 	brls	800028ec <CalculateBurst+0x10>
800028ea:	5e fd       	retal	0
800028ec:	48 28       	lddpc	r8,800028f4 <CalculateBurst+0x18>
800028ee:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028f2:	5e fc       	retal	r12
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d8 a0       	acall	0x8a

800028f8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028f8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028fa:	48 98       	lddpc	r8,8000291c <payload_init+0x24>
800028fc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028fe:	48 98       	lddpc	r8,80002920 <payload_init+0x28>
80002900:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002902:	30 09       	mov	r9,0
80002904:	1a d9       	st.w	--sp,r9
80002906:	1a d9       	st.w	--sp,r9
80002908:	1a d9       	st.w	--sp,r9
8000290a:	30 28       	mov	r8,2
8000290c:	e0 6a 04 00 	mov	r10,1024
80002910:	48 5b       	lddpc	r11,80002924 <payload_init+0x2c>
80002912:	48 6c       	lddpc	r12,80002928 <payload_init+0x30>
80002914:	f0 1f 00 06 	mcall	8000292c <payload_init+0x34>
80002918:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000291a:	d8 02       	popm	pc
8000291c:	00 00       	add	r0,r0
8000291e:	0a 6c       	and	r12,r5
80002920:	00 00       	add	r0,r0
80002922:	0a 70       	tst	r0,r5
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	d8 e8       	*unknown*
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	29 30       	sub	r0,-109
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	6d 8c       	ld.w	r12,r6[0x60]

80002930 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002930:	eb cd 40 f8 	pushm	r3-r7,lr
80002934:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002936:	48 e8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002938:	70 08       	ld.w	r8,r8[0x0]
8000293a:	58 08       	cp.w	r8,0
8000293c:	c0 71       	brne	8000294a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000293e:	30 4b       	mov	r11,4
80002940:	30 5c       	mov	r12,5
80002942:	f0 1f 00 0c 	mcall	80002970 <payload_rx_process+0x40>
80002946:	48 a8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002948:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000294a:	48 96       	lddpc	r6,8000296c <payload_rx_process+0x3c>
8000294c:	30 05       	mov	r5,0
8000294e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002950:	48 93       	lddpc	r3,80002974 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002952:	6c 0c       	ld.w	r12,r6[0x0]
80002954:	0a 99       	mov	r9,r5
80002956:	08 9a       	mov	r10,r4
80002958:	1a 9b       	mov	r11,sp
8000295a:	f0 1f 00 08 	mcall	80002978 <payload_rx_process+0x48>
8000295e:	58 1c       	cp.w	r12,1
80002960:	cf 91       	brne	80002952 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002962:	66 08       	ld.w	r8,r3[0x0]
80002964:	40 0c       	lddsp	r12,sp[0x0]
80002966:	5d 18       	icall	r8
80002968:	cf 5b       	rjmp	80002952 <payload_rx_process+0x22>
8000296a:	00 00       	add	r0,r0
8000296c:	00 00       	add	r0,r0
8000296e:	0a a0       	st.w	r5++,r0
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	66 70       	ld.w	r0,r3[0x1c]
80002974:	00 00       	add	r0,r0
80002976:	0a 6c       	and	r12,r5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	63 64       	ld.w	r4,r1[0x58]

8000297c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000297c:	d4 01       	pushm	lr
8000297e:	20 2d       	sub	sp,8
80002980:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002982:	30 09       	mov	r9,0
80002984:	fa ca ff f8 	sub	r10,sp,-8
80002988:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000298a:	1a 9b       	mov	r11,sp
8000298c:	f0 1f 00 02 	mcall	80002994 <set_idle_store_isr+0x18>
}
80002990:	2f ed       	sub	sp,-8
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	65 20       	ld.w	r0,r2[0x48]

80002998 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002998:	d4 01       	pushm	lr
8000299a:	20 2d       	sub	sp,8
8000299c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000299e:	58 0c       	cp.w	r12,0
800029a0:	c1 10       	breq	800029c2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029a2:	30 08       	mov	r8,0
800029a4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029a6:	98 88       	ld.uh	r8,r12[0x0]
800029a8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ac:	e0 48 40 00 	cp.w	r8,16384
800029b0:	c0 91       	brne	800029c2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029b2:	48 68       	lddpc	r8,800029c8 <phy_rx+0x30>
800029b4:	70 0c       	ld.w	r12,r8[0x0]
800029b6:	30 09       	mov	r9,0
800029b8:	fa ca ff fc 	sub	r10,sp,-4
800029bc:	1a 9b       	mov	r11,sp
800029be:	f0 1f 00 04 	mcall	800029cc <phy_rx+0x34>
		}	

    }
		
 
}
800029c2:	2f ed       	sub	sp,-8
800029c4:	d8 02       	popm	pc
800029c6:	00 00       	add	r0,r0
800029c8:	00 00       	add	r0,r0
800029ca:	0a b8       	st.h	r5++,r8
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	65 20       	ld.w	r0,r2[0x48]

800029d0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029d0:	eb cd 40 80 	pushm	r7,lr
800029d4:	20 1d       	sub	sp,4
800029d6:	fa c7 ff fc 	sub	r7,sp,-4
800029da:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029dc:	30 09       	mov	r9,0
800029de:	12 9a       	mov	r10,r9
800029e0:	1a 9b       	mov	r11,sp
800029e2:	f0 1f 00 03 	mcall	800029ec <set_idle_store+0x1c>
}
800029e6:	2f fd       	sub	sp,-4
800029e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	65 70       	ld.w	r0,r2[0x5c]

800029f0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029f0:	d4 01       	pushm	lr
800029f2:	20 1d       	sub	sp,4
800029f4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029f6:	98 88       	ld.uh	r8,r12[0x0]
800029f8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029fc:	e0 48 40 00 	cp.w	r8,16384
80002a00:	c0 d1       	brne	80002a1a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a02:	49 08       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	58 08       	cp.w	r8,0
80002a08:	c1 a0       	breq	80002a3c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a0a:	48 e8       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a0c:	70 0c       	ld.w	r12,r8[0x0]
80002a0e:	30 09       	mov	r9,0
80002a10:	12 9a       	mov	r10,r9
80002a12:	1a 9b       	mov	r11,sp
80002a14:	f0 1f 00 0c 	mcall	80002a44 <phy_tx+0x54>
80002a18:	c1 28       	rjmp	80002a3c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a1a:	e0 48 10 00 	cp.w	r8,4096
80002a1e:	5f 0a       	sreq	r10
80002a20:	e0 48 20 00 	cp.w	r8,8192
80002a24:	5f 09       	sreq	r9
80002a26:	f5 e9 10 09 	or	r9,r10,r9
80002a2a:	c0 71       	brne	80002a38 <phy_tx+0x48>
80002a2c:	e0 48 50 00 	cp.w	r8,20480
80002a30:	c0 40       	breq	80002a38 <phy_tx+0x48>
80002a32:	e0 48 60 00 	cp.w	r8,24576
80002a36:	c0 31       	brne	80002a3c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a38:	48 48       	lddpc	r8,80002a48 <phy_tx+0x58>
80002a3a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a3c:	2f fd       	sub	sp,-4
80002a3e:	d8 02       	popm	pc
80002a40:	00 00       	add	r0,r0
80002a42:	0a dc       	st.w	--r5,r12
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	65 70       	ld.w	r0,r2[0x5c]
80002a48:	00 00       	add	r0,r0
80002a4a:	0a cc       	st.b	r5++,r12

80002a4c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a4c:	d4 01       	pushm	lr
80002a4e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a50:	30 08       	mov	r8,0
80002a52:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a54:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a56:	1a 9a       	mov	r10,sp
80002a58:	fa cb ff fc 	sub	r11,sp,-4
80002a5c:	f0 1f 00 05 	mcall	80002a70 <get_idle_store_isr+0x24>
80002a60:	58 1c       	cp.w	r12,1
80002a62:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a66:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a6a:	2f ed       	sub	sp,-8
80002a6c:	d8 02       	popm	pc
80002a6e:	00 00       	add	r0,r0
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	62 74       	ld.w	r4,r1[0x1c]

80002a74 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a74:	eb cd 40 c0 	pushm	r6-r7,lr
80002a78:	20 1d       	sub	sp,4
80002a7a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a7c:	4b a8       	lddpc	r8,80002b64 <phy_tx_func+0xf0>
80002a7e:	70 08       	ld.w	r8,r8[0x0]
80002a80:	58 08       	cp.w	r8,0
80002a82:	c6 60       	breq	80002b4e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a84:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a86:	30 08       	mov	r8,0
80002a88:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a8a:	4b 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002a8c:	70 08       	ld.w	r8,r8[0x0]
80002a8e:	58 18       	cp.w	r8,1
80002a90:	c2 60       	breq	80002adc <phy_tx_func+0x68>
80002a92:	c0 43       	brcs	80002a9a <phy_tx_func+0x26>
80002a94:	58 28       	cp.w	r8,2
80002a96:	c5 c1       	brne	80002b4e <phy_tx_func+0xda>
80002a98:	c5 58       	rjmp	80002b42 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a9a:	4b 38       	lddpc	r8,80002b64 <phy_tx_func+0xf0>
80002a9c:	70 0c       	ld.w	r12,r8[0x0]
80002a9e:	1a 9a       	mov	r10,sp
80002aa0:	4b 3b       	lddpc	r11,80002b6c <phy_tx_func+0xf8>
80002aa2:	f0 1f 00 34 	mcall	80002b70 <phy_tx_func+0xfc>
80002aa6:	58 1c       	cp.w	r12,1
80002aa8:	c1 41       	brne	80002ad0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aaa:	4b 18       	lddpc	r8,80002b6c <phy_tx_func+0xf8>
80002aac:	70 08       	ld.w	r8,r8[0x0]
80002aae:	90 08       	ld.sh	r8,r8[0x0]
80002ab0:	10 9a       	mov	r10,r8
80002ab2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002ab6:	4b 09       	lddpc	r9,80002b74 <phy_tx_func+0x100>
80002ab8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002aba:	5c 78       	castu.h	r8
80002abc:	ea 18 ab cd 	orh	r8,0xabcd
80002ac0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ac2:	30 19       	mov	r9,1
80002ac4:	4a d8       	lddpc	r8,80002b78 <phy_tx_func+0x104>
80002ac6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac8:	30 19       	mov	r9,1
80002aca:	4a 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002acc:	91 09       	st.w	r8[0x0],r9
80002ace:	c4 08       	rjmp	80002b4e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ad0:	e0 68 5a 5a 	mov	r8,23130
80002ad4:	ea 18 ab cd 	orh	r8,0xabcd
80002ad8:	8f 18       	st.w	r7[0x4],r8
80002ada:	c3 a8       	rjmp	80002b4e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002adc:	4a 7a       	lddpc	r10,80002b78 <phy_tx_func+0x104>
80002ade:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ae0:	4a 39       	lddpc	r9,80002b6c <phy_tx_func+0xf8>
80002ae2:	72 09       	ld.w	r9,r9[0x0]
80002ae4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ae8:	b1 69       	lsl	r9,0x10
80002aea:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aec:	2f f8       	sub	r8,-1
80002aee:	5c 58       	castu.b	r8
80002af0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002af2:	4a 1b       	lddpc	r11,80002b74 <phy_tx_func+0x100>
80002af4:	96 0c       	ld.sh	r12,r11[0x0]
80002af6:	20 2c       	sub	r12,2
80002af8:	5c 8c       	casts.h	r12
80002afa:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002afe:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b00:	30 0b       	mov	r11,0
80002b02:	f6 0a 19 00 	cp.h	r10,r11
80002b06:	e0 89 00 09 	brgt	80002b18 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b0a:	e8 19 00 ba 	orl	r9,0xba
80002b0e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b10:	30 09       	mov	r9,0
80002b12:	49 68       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b14:	91 09       	st.w	r8[0x0],r9
80002b16:	c1 c8       	rjmp	80002b4e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b18:	49 5a       	lddpc	r10,80002b6c <phy_tx_func+0xf8>
80002b1a:	74 0a       	ld.w	r10,r10[0x0]
80002b1c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b20:	14 49       	or	r9,r10
80002b22:	8f 19       	st.w	r7[0x4],r9
80002b24:	2f f8       	sub	r8,-1
80002b26:	49 59       	lddpc	r9,80002b78 <phy_tx_func+0x104>
80002b28:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b2a:	20 2c       	sub	r12,2
80002b2c:	49 28       	lddpc	r8,80002b74 <phy_tx_func+0x100>
80002b2e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b30:	30 08       	mov	r8,0
80002b32:	f0 0c 19 00 	cp.h	r12,r8
80002b36:	e0 89 00 0c 	brgt	80002b4e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b3a:	30 29       	mov	r9,2
80002b3c:	48 b8       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b3e:	91 09       	st.w	r8[0x0],r9
80002b40:	c0 78       	rjmp	80002b4e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b42:	fc 18 00 ba 	movh	r8,0xba
80002b46:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b48:	30 09       	mov	r9,0
80002b4a:	48 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b4c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b4e:	e0 68 5a 5a 	mov	r8,23130
80002b52:	ea 18 ab cd 	orh	r8,0xabcd
80002b56:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b58:	30 08       	mov	r8,0
80002b5a:	8f 38       	st.w	r7[0xc],r8
}
80002b5c:	2f fd       	sub	sp,-4
80002b5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0a dc       	st.w	--r5,r12
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 94       	mov	r4,r5
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a e8       	st.h	--r5,r8
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	62 74       	ld.w	r4,r1[0x1c]
80002b74:	00 00       	add	r0,r0
80002b76:	0a bc       	st.h	r5++,r12
80002b78:	00 00       	add	r0,r0
80002b7a:	0a 78       	tst	r8,r5

80002b7c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b7c:	d4 01       	pushm	lr
80002b7e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b80:	30 0a       	mov	r10,0
80002b82:	fa cb ff fc 	sub	r11,sp,-4
80002b86:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b88:	14 99       	mov	r9,r10
80002b8a:	1a 9b       	mov	r11,sp
80002b8c:	f0 1f 00 05 	mcall	80002ba0 <get_idle_store+0x24>
80002b90:	58 1c       	cp.w	r12,1
80002b92:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b96:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002b9a:	2f fd       	sub	sp,-4
80002b9c:	d8 02       	popm	pc
80002b9e:	00 00       	add	r0,r0
80002ba0:	80 00       	ld.sh	r0,r0[0x0]
80002ba2:	63 64       	ld.w	r4,r1[0x58]

80002ba4 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002ba4:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002ba6:	48 5b       	lddpc	r11,80002bb8 <phy_init+0x14>
80002ba8:	48 5c       	lddpc	r12,80002bbc <phy_init+0x18>
80002baa:	f0 1f 00 06 	mcall	80002bc0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002bae:	f0 1f 00 06 	mcall	80002bc4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002bb2:	f0 1f 00 06 	mcall	80002bc8 <phy_init+0x24>
	
}
80002bb6:	d8 02       	popm	pc
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	2a 74       	sub	r4,-89
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	2c 2c       	sub	r12,-62
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	3c 74       	mov	r4,-57
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	3c 88       	mov	r8,-56
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	46 30       	lddsp	r0,sp[0x18c]

80002bcc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bcc:	d4 01       	pushm	lr
80002bce:	20 2d       	sub	sp,8
80002bd0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bd2:	30 08       	mov	r8,0
80002bd4:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002bd6:	48 f8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002bd8:	70 08       	ld.w	r8,r8[0x0]
80002bda:	58 08       	cp.w	r8,0
80002bdc:	c0 71       	brne	80002bea <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bde:	30 4b       	mov	r11,4
80002be0:	30 5c       	mov	r12,5
80002be2:	f0 1f 00 0d 	mcall	80002c14 <payload_rx+0x48>
80002be6:	48 b8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002be8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002bea:	48 a8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002bec:	70 0c       	ld.w	r12,r8[0x0]
80002bee:	30 09       	mov	r9,0
80002bf0:	fa ca ff fc 	sub	r10,sp,-4
80002bf4:	1a 9b       	mov	r11,sp
80002bf6:	f0 1f 00 09 	mcall	80002c18 <payload_rx+0x4c>
80002bfa:	c0 91       	brne	80002c0c <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002bfc:	48 88       	lddpc	r8,80002c1c <payload_rx+0x50>
80002bfe:	70 0c       	ld.w	r12,r8[0x0]
80002c00:	40 0b       	lddsp	r11,sp[0x0]
80002c02:	f0 1f 00 08 	mcall	80002c20 <payload_rx+0x54>
		logFromISR("mm");
80002c06:	48 8c       	lddpc	r12,80002c24 <payload_rx+0x58>
80002c08:	f0 1f 00 08 	mcall	80002c28 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002c0c:	2f ed       	sub	sp,-8
80002c0e:	d8 02       	popm	pc
80002c10:	00 00       	add	r0,r0
80002c12:	0a a0       	st.w	r5++,r0
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	66 70       	ld.w	r0,r3[0x1c]
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	65 20       	ld.w	r0,r2[0x48]
80002c1c:	00 00       	add	r0,r0
80002c1e:	0a ac       	st.w	r5++,r12
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	29 7c       	sub	r12,-105
80002c24:	80 00       	ld.sh	r0,r0[0x0]
80002c26:	d8 f4       	*unknown*
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	72 dc       	ld.w	r12,r9[0x34]

80002c2c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c2c:	eb cd 40 e0 	pushm	r5-r7,lr
80002c30:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c32:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c36:	70 08       	ld.w	r8,r8[0x0]
80002c38:	58 08       	cp.w	r8,0
80002c3a:	e0 80 01 08 	breq	80002e4a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c3e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c40:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c44:	70 09       	ld.w	r9,r8[0x0]
80002c46:	2f f9       	sub	r9,-1
80002c48:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c4a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c4e:	70 08       	ld.w	r8,r8[0x0]
80002c50:	58 18       	cp.w	r8,1
80002c52:	e0 80 00 85 	breq	80002d5c <phy_rx_func+0x130>
80002c56:	c0 73       	brcs	80002c64 <phy_rx_func+0x38>
80002c58:	58 28       	cp.w	r8,2
80002c5a:	c5 c0       	breq	80002d12 <phy_rx_func+0xe6>
80002c5c:	58 38       	cp.w	r8,3
80002c5e:	e0 81 00 f6 	brne	80002e4a <phy_rx_func+0x21e>
80002c62:	cd 58       	rjmp	80002e0c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c64:	e0 6a 5a 5a 	mov	r10,23130
80002c68:	ea 1a ab cd 	orh	r10,0xabcd
80002c6c:	14 36       	cp.w	r6,r10
80002c6e:	e0 80 00 ee 	breq	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c72:	ec 08 16 10 	lsr	r8,r6,0x10
80002c76:	e0 48 ab cd 	cp.w	r8,43981
80002c7a:	e0 81 00 e8 	brne	80002e4a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c7e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c82:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c86:	20 28       	sub	r8,2
80002c88:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c8c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c8e:	30 09       	mov	r9,0
80002c90:	f2 08 19 00 	cp.h	r8,r9
80002c94:	e0 8a 00 db 	brle	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002c98:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002c9c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002c9e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002ca2:	70 0c       	ld.w	r12,r8[0x0]
80002ca4:	f0 1f 03 88 	mcall	80003ac4 <phy_rx_func+0xe98>
80002ca8:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002cac:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002cae:	58 0c       	cp.w	r12,0
80002cb0:	e0 80 00 cd 	breq	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002cb4:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cb8:	90 09       	ld.sh	r9,r8[0x0]
80002cba:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cbe:	2f f9       	sub	r9,-1
80002cc0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cc2:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cc6:	74 0a       	ld.w	r10,r10[0x0]
80002cc8:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ccc:	76 0b       	ld.w	r11,r11[0x0]
80002cce:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cd2:	2f f9       	sub	r9,-1
80002cd4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002cd6:	e2 16 0f 00 	andl	r6,0xf00,COH
80002cda:	e0 46 01 00 	cp.w	r6,256
80002cde:	c0 c0       	breq	80002cf6 <phy_rx_func+0xca>
80002ce0:	e0 8b 00 05 	brhi	80002cea <phy_rx_func+0xbe>
80002ce4:	58 06       	cp.w	r6,0
80002ce6:	c0 80       	breq	80002cf6 <phy_rx_func+0xca>
80002ce8:	c0 c8       	rjmp	80002d00 <phy_rx_func+0xd4>
80002cea:	e0 46 02 00 	cp.w	r6,512
80002cee:	c0 40       	breq	80002cf6 <phy_rx_func+0xca>
80002cf0:	e0 46 03 00 	cp.w	r6,768
80002cf4:	c0 61       	brne	80002d00 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002cf6:	30 29       	mov	r9,2
80002cf8:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002cfc:	91 09       	st.w	r8[0x0],r9
80002cfe:	ca 68       	rjmp	80002e4a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002d00:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002d04:	70 0c       	ld.w	r12,r8[0x0]
80002d06:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d0a:	70 0b       	ld.w	r11,r8[0x0]
80002d0c:	f0 1f 03 70 	mcall	80003acc <phy_rx_func+0xea0>
80002d10:	c9 d8       	rjmp	80002e4a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d12:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d16:	b1 86       	lsr	r6,0x10
80002d18:	14 06       	add	r6,r10
80002d1a:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d1e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d20:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d24:	90 09       	ld.sh	r9,r8[0x0]
80002d26:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d2a:	76 0b       	ld.w	r11,r11[0x0]
80002d2c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d30:	2f f9       	sub	r9,-1
80002d32:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d34:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d38:	92 08       	ld.sh	r8,r9[0x0]
80002d3a:	20 28       	sub	r8,2
80002d3c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d3e:	30 09       	mov	r9,0
80002d40:	f2 08 19 00 	cp.h	r8,r9
80002d44:	e0 8a 00 07 	brle	80002d52 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d48:	30 19       	mov	r9,1
80002d4a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d4e:	91 09       	st.w	r8[0x0],r9
80002d50:	c7 d8       	rjmp	80002e4a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d52:	30 39       	mov	r9,3
80002d54:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d58:	91 09       	st.w	r8[0x0],r9
80002d5a:	c7 88       	rjmp	80002e4a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d5c:	ec 0a 14 10 	asr	r10,r6,0x10
80002d60:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d64:	90 09       	ld.sh	r9,r8[0x0]
80002d66:	14 09       	add	r9,r10
80002d68:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d6a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d6e:	92 08       	ld.sh	r8,r9[0x0]
80002d70:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d74:	76 0b       	ld.w	r11,r11[0x0]
80002d76:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d7a:	2f f8       	sub	r8,-1
80002d7c:	5c 88       	casts.h	r8
80002d7e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d80:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d84:	94 09       	ld.sh	r9,r10[0x0]
80002d86:	20 29       	sub	r9,2
80002d88:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d8a:	30 0a       	mov	r10,0
80002d8c:	f4 09 19 00 	cp.h	r9,r10
80002d90:	e0 89 00 20 	brgt	80002dd0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002d94:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002d98:	e0 46 00 ba 	cp.w	r6,186
80002d9c:	c0 d1       	brne	80002db6 <phy_rx_func+0x18a>
80002d9e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002da2:	90 09       	ld.sh	r9,r8[0x0]
80002da4:	f4 09 19 00 	cp.h	r9,r10
80002da8:	c0 71       	brne	80002db6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002daa:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002dae:	70 0c       	ld.w	r12,r8[0x0]
80002db0:	f0 1f 03 49 	mcall	80003ad4 <phy_rx_func+0xea8>
80002db4:	c0 98       	rjmp	80002dc6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002db6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002dba:	70 0c       	ld.w	r12,r8[0x0]
80002dbc:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002dc0:	70 0b       	ld.w	r11,r8[0x0]
80002dc2:	f0 1f 03 43 	mcall	80003acc <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dc6:	30 09       	mov	r9,0
80002dc8:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dcc:	91 09       	st.w	r8[0x0],r9
80002dce:	c3 e8       	rjmp	80002e4a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002dd0:	5c 86       	casts.h	r6
80002dd2:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002dd6:	92 0a       	ld.sh	r10,r9[0x0]
80002dd8:	0c 0a       	add	r10,r6
80002dda:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ddc:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002de0:	72 09       	ld.w	r9,r9[0x0]
80002de2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002de6:	2f f8       	sub	r8,-1
80002de8:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002dec:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002dee:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002df2:	92 08       	ld.sh	r8,r9[0x0]
80002df4:	20 28       	sub	r8,2
80002df6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002df8:	30 09       	mov	r9,0
80002dfa:	f2 08 19 00 	cp.h	r8,r9
80002dfe:	e0 89 00 26 	brgt	80002e4a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002e02:	30 39       	mov	r9,3
80002e04:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e08:	91 09       	st.w	r8[0x0],r9
80002e0a:	c2 08       	rjmp	80002e4a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e0c:	e6 16 00 ff 	andh	r6,0xff,COH
80002e10:	fc 19 00 ba 	movh	r9,0xba
80002e14:	12 36       	cp.w	r6,r9
80002e16:	c0 e1       	brne	80002e32 <phy_rx_func+0x206>
80002e18:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e1c:	90 09       	ld.sh	r9,r8[0x0]
80002e1e:	30 08       	mov	r8,0
80002e20:	f0 09 19 00 	cp.h	r9,r8
80002e24:	c0 71       	brne	80002e32 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e26:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e2a:	70 0c       	ld.w	r12,r8[0x0]
80002e2c:	f0 1f 03 2a 	mcall	80003ad4 <phy_rx_func+0xea8>
80002e30:	c0 98       	rjmp	80002e42 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e32:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e36:	70 0c       	ld.w	r12,r8[0x0]
80002e38:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e3c:	70 0b       	ld.w	r11,r8[0x0]
80002e3e:	f0 1f 03 24 	mcall	80003acc <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e42:	30 09       	mov	r9,0
80002e44:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e48:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e4a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e4e:	11 89       	ld.ub	r9,r8[0x0]
80002e50:	30 08       	mov	r8,0
80002e52:	f0 09 18 00 	cp.b	r9,r8
80002e56:	c1 31       	brne	80002e7c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e58:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e5c:	6c 0c       	ld.w	r12,r6[0x0]
80002e5e:	f0 1f 03 1a 	mcall	80003ac4 <phy_rx_func+0xe98>
80002e62:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e66:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e68:	6c 0c       	ld.w	r12,r6[0x0]
80002e6a:	f0 1f 03 17 	mcall	80003ac4 <phy_rx_func+0xe98>
80002e6e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e72:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e74:	30 19       	mov	r9,1
80002e76:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e7a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e7c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e80:	70 08       	ld.w	r8,r8[0x0]
80002e82:	58 28       	cp.w	r8,2
80002e84:	e0 80 01 98 	breq	800031b4 <phy_rx_func+0x588>
80002e88:	e0 8b 00 06 	brhi	80002e94 <phy_rx_func+0x268>
80002e8c:	58 08       	cp.w	r8,0
80002e8e:	c0 b0       	breq	80002ea4 <phy_rx_func+0x278>
80002e90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e94:	58 38       	cp.w	r8,3
80002e96:	e0 80 05 c5 	breq	80003a20 <phy_rx_func+0xdf4>
80002e9a:	58 48       	cp.w	r8,4
80002e9c:	e0 81 06 05 	brne	80003aa6 <phy_rx_func+0xe7a>
80002ea0:	e0 8f 02 4b 	bral	80003336 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002ea4:	6e 28       	ld.w	r8,r7[0x8]
80002ea6:	e0 6a 5a 5a 	mov	r10,23130
80002eaa:	ea 1a ab cd 	orh	r10,0xabcd
80002eae:	14 38       	cp.w	r8,r10
80002eb0:	c0 71       	brne	80002ebe <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002eb2:	30 09       	mov	r9,0
80002eb4:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002eb8:	91 09       	st.w	r8[0x0],r9
80002eba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002ebe:	10 99       	mov	r9,r8
80002ec0:	e0 19 00 00 	andl	r9,0x0
80002ec4:	fc 1a ab cd 	movh	r10,0xabcd
80002ec8:	14 39       	cp.w	r9,r10
80002eca:	e0 81 05 ee 	brne	80003aa6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002ece:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ed2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ed6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ed8:	6e 29       	ld.w	r9,r7[0x8]
80002eda:	e2 19 f0 00 	andl	r9,0xf000,COH
80002ede:	e0 49 c0 00 	cp.w	r9,49152
80002ee2:	e0 81 00 ce 	brne	8000307e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ee6:	30 1a       	mov	r10,1
80002ee8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002eec:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002eee:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002ef2:	72 09       	ld.w	r9,r9[0x0]
80002ef4:	58 09       	cp.w	r9,0
80002ef6:	c0 71       	brne	80002f04 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002ef8:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002efc:	f0 1f 03 00 	mcall	80003afc <phy_rx_func+0xed0>
80002f00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002f04:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f08:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f0c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f0e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f12:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f16:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f1a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f1c:	13 89       	ld.ub	r9,r9[0x0]
80002f1e:	37 fa       	mov	r10,127
80002f20:	f4 09 18 00 	cp.b	r9,r10
80002f24:	c6 d0       	breq	80002ffe <phy_rx_func+0x3d2>
80002f26:	e0 8b 00 0c 	brhi	80002f3e <phy_rx_func+0x312>
80002f2a:	31 2a       	mov	r10,18
80002f2c:	f4 09 18 00 	cp.b	r9,r10
80002f30:	c4 20       	breq	80002fb4 <phy_rx_func+0x388>
80002f32:	31 3a       	mov	r10,19
80002f34:	f4 09 18 00 	cp.b	r9,r10
80002f38:	e0 81 00 83 	brne	8000303e <phy_rx_func+0x412>
80002f3c:	c5 b8       	rjmp	80002ff2 <phy_rx_func+0x3c6>
80002f3e:	2f 09       	sub	r9,-16
80002f40:	30 1a       	mov	r10,1
80002f42:	f4 09 18 00 	cp.b	r9,r10
80002f46:	e0 8b 00 7c 	brhi	8000303e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f4a:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f4e:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f52:	59 08       	cp.w	r8,16
80002f54:	c0 71       	brne	80002f62 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f56:	30 19       	mov	r9,1
80002f58:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f5c:	91 09       	st.w	r8[0x0],r9
80002f5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f62:	e0 48 00 20 	cp.w	r8,32
80002f66:	c2 11       	brne	80002fa8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f68:	30 a9       	mov	r9,10
80002f6a:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f6e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f70:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f74:	6c 08       	ld.w	r8,r6[0x0]
80002f76:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f7a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f7e:	2f f8       	sub	r8,-1
80002f80:	6e 0c       	ld.w	r12,r7[0x0]
80002f82:	f4 ca fe 00 	sub	r10,r10,-512
80002f86:	30 0b       	mov	r11,0
80002f88:	10 0c       	add	r12,r8
80002f8a:	f0 1f 02 e1 	mcall	80003b0c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f8e:	30 08       	mov	r8,0
80002f90:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f92:	6e 0c       	ld.w	r12,r7[0x0]
80002f94:	f0 1f 02 df 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002f98:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002f9c:	70 0c       	ld.w	r12,r8[0x0]
80002f9e:	f0 1f 02 ca 	mcall	80003ac4 <phy_rx_func+0xe98>
80002fa2:	8f 0c       	st.w	r7[0x0],r12
80002fa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fa8:	30 09       	mov	r9,0
80002faa:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fae:	91 09       	st.w	r8[0x0],r9
80002fb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fb4:	20 48       	sub	r8,4
80002fb6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fba:	93 08       	st.w	r9[0x0],r8
80002fbc:	58 08       	cp.w	r8,0
80002fbe:	e0 80 05 74 	breq	80003aa6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fc2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fc6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fca:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fce:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fd0:	8e 69       	ld.sh	r9,r7[0xc]
80002fd2:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fd6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fd8:	8e 79       	ld.sh	r9,r7[0xe]
80002fda:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fdc:	f0 1f 02 d0 	mcall	80003b1c <phy_rx_func+0xef0>
80002fe0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002fe4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002fe6:	30 49       	mov	r9,4
80002fe8:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002fec:	91 09       	st.w	r8[0x0],r9
80002fee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002ff2:	30 09       	mov	r9,0
80002ff4:	fe f8 0a f8 	ld.w	r8,pc[2808]
80002ff8:	91 09       	st.w	r8[0x0],r9
80002ffa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002ffe:	20 48       	sub	r8,4
80003000:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003004:	93 08       	st.w	r9[0x0],r8
80003006:	58 08       	cp.w	r8,0
80003008:	e0 80 05 4f 	breq	80003aa6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000300c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003010:	70 09       	ld.w	r9,r8[0x0]
80003012:	8e 7b       	ld.sh	r11,r7[0xe]
80003014:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003018:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000301c:	2f f9       	sub	r9,-1
8000301e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003020:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003024:	70 09       	ld.w	r9,r8[0x0]
80003026:	20 29       	sub	r9,2
80003028:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000302a:	30 29       	mov	r9,2
8000302c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003030:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003032:	30 39       	mov	r9,3
80003034:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003038:	91 09       	st.w	r8[0x0],r9
8000303a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000303e:	30 3a       	mov	r10,3
80003040:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003044:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003046:	6e 2a       	ld.w	r10,r7[0x8]
80003048:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000304c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000304e:	6e 3a       	ld.w	r10,r7[0xc]
80003050:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003052:	59 48       	cp.w	r8,20
80003054:	c0 61       	brne	80003060 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003056:	31 89       	mov	r9,24
80003058:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000305c:	91 09       	st.w	r8[0x0],r9
8000305e:	c0 a8       	rjmp	80003072 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003060:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003064:	70 08       	ld.w	r8,r8[0x0]
80003066:	59 08       	cp.w	r8,16
80003068:	c0 51       	brne	80003072 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000306a:	31 09       	mov	r9,16
8000306c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003070:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003072:	30 49       	mov	r9,4
80003074:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003078:	91 09       	st.w	r8[0x0],r9
8000307a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000307e:	e0 49 10 00 	cp.w	r9,4096
80003082:	5f 1a       	srne	r10
80003084:	e0 49 20 00 	cp.w	r9,8192
80003088:	5f 19       	srne	r9
8000308a:	f5 e9 00 09 	and	r9,r10,r9
8000308e:	e0 81 05 0c 	brne	80003aa6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003092:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003096:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003098:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000309c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000309e:	fe fa 0a 62 	ld.w	r10,pc[2658]
800030a2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800030a4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030a8:	72 09       	ld.w	r9,r9[0x0]
800030aa:	58 09       	cp.w	r9,0
800030ac:	c0 71       	brne	800030ba <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030ae:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030b2:	f0 1f 02 93 	mcall	80003afc <phy_rx_func+0xed0>
800030b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030ba:	6e 2a       	ld.w	r10,r7[0x8]
800030bc:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030c0:	58 1a       	cp.w	r10,1
800030c2:	e0 8b 00 4d 	brhi	8000315c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030c6:	20 48       	sub	r8,4
800030c8:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030cc:	93 08       	st.w	r9[0x0],r8
800030ce:	58 08       	cp.w	r8,0
800030d0:	e0 80 04 eb 	breq	80003aa6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030d4:	8e 68       	ld.sh	r8,r7[0xc]
800030d6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030da:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030de:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030e0:	30 09       	mov	r9,0
800030e2:	f2 08 19 00 	cp.h	r8,r9
800030e6:	c0 70       	breq	800030f4 <phy_rx_func+0x4c8>
800030e8:	30 19       	mov	r9,1
800030ea:	f2 08 19 00 	cp.h	r8,r9
800030ee:	e0 81 04 dc 	brne	80003aa6 <phy_rx_func+0xe7a>
800030f2:	c2 68       	rjmp	8000313e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800030f4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800030f8:	70 0a       	ld.w	r10,r8[0x0]
800030fa:	fe f9 09 e6 	ld.w	r9,pc[2534]
800030fe:	72 09       	ld.w	r9,r9[0x0]
80003100:	8e 7b       	ld.sh	r11,r7[0xe]
80003102:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003106:	70 09       	ld.w	r9,r8[0x0]
80003108:	2f f9       	sub	r9,-1
8000310a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000310c:	e0 49 00 ff 	cp.w	r9,255
80003110:	e0 88 00 11 	brls	80003132 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003114:	30 09       	mov	r9,0
80003116:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003118:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000311c:	6e 0c       	ld.w	r12,r7[0x0]
8000311e:	f0 1f 02 7d 	mcall	80003b10 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003122:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003126:	70 0c       	ld.w	r12,r8[0x0]
80003128:	f0 1f 02 67 	mcall	80003ac4 <phy_rx_func+0xe98>
8000312c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000312e:	e0 80 04 bc 	breq	80003aa6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003132:	30 29       	mov	r9,2
80003134:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003138:	91 09       	st.w	r8[0x0],r9
8000313a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000313e:	8e 79       	ld.sh	r9,r7[0xe]
80003140:	30 38       	mov	r8,3
80003142:	f0 09 19 00 	cp.h	r9,r8
80003146:	c0 51       	brne	80003150 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003148:	30 19       	mov	r9,1
8000314a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000314e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003150:	30 29       	mov	r9,2
80003152:	fe f8 09 96 	ld.w	r8,pc[2454]
80003156:	91 09       	st.w	r8[0x0],r9
80003158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000315c:	58 18       	cp.w	r8,1
8000315e:	e0 88 04 a4 	brls	80003aa6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003162:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003166:	70 0a       	ld.w	r10,r8[0x0]
80003168:	6e 3b       	ld.w	r11,r7[0xc]
8000316a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000316e:	70 09       	ld.w	r9,r8[0x0]
80003170:	2f f9       	sub	r9,-1
80003172:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003174:	e0 49 00 ff 	cp.w	r9,255
80003178:	e0 88 00 11 	brls	8000319a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000317c:	30 09       	mov	r9,0
8000317e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003180:	fe f7 09 60 	ld.w	r7,pc[2400]
80003184:	6e 0c       	ld.w	r12,r7[0x0]
80003186:	f0 1f 02 63 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000318a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000318e:	70 0c       	ld.w	r12,r8[0x0]
80003190:	f0 1f 02 4d 	mcall	80003ac4 <phy_rx_func+0xe98>
80003194:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003196:	e0 80 04 88 	breq	80003aa6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000319a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000319e:	72 08       	ld.w	r8,r9[0x0]
800031a0:	20 28       	sub	r8,2
800031a2:	93 08       	st.w	r9[0x0],r8
800031a4:	e0 80 04 81 	breq	80003aa6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031a8:	30 29       	mov	r9,2
800031aa:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031ae:	91 09       	st.w	r8[0x0],r9
800031b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031b4:	fe f8 09 84 	ld.w	r8,pc[2436]
800031b8:	70 0a       	ld.w	r10,r8[0x0]
800031ba:	fe f9 09 26 	ld.w	r9,pc[2342]
800031be:	72 09       	ld.w	r9,r9[0x0]
800031c0:	8e 4b       	ld.sh	r11,r7[0x8]
800031c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031c6:	70 09       	ld.w	r9,r8[0x0]
800031c8:	2f f9       	sub	r9,-1
800031ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031cc:	e0 49 00 ff 	cp.w	r9,255
800031d0:	e0 88 00 16 	brls	800031fc <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031d4:	30 09       	mov	r9,0
800031d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031d8:	fe f6 09 08 	ld.w	r6,pc[2312]
800031dc:	6c 0c       	ld.w	r12,r6[0x0]
800031de:	f0 1f 02 4d 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031e2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031e6:	70 0c       	ld.w	r12,r8[0x0]
800031e8:	f0 1f 02 37 	mcall	80003ac4 <phy_rx_func+0xe98>
800031ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031ee:	c0 71       	brne	800031fc <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031f0:	30 09       	mov	r9,0
800031f2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800031f6:	91 09       	st.w	r8[0x0],r9
800031f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800031fc:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003200:	72 08       	ld.w	r8,r9[0x0]
80003202:	20 28       	sub	r8,2
80003204:	93 08       	st.w	r9[0x0],r8
80003206:	c0 71       	brne	80003214 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003208:	30 09       	mov	r9,0
8000320a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000320e:	91 09       	st.w	r8[0x0],r9
80003210:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003214:	fe f8 09 24 	ld.w	r8,pc[2340]
80003218:	70 0a       	ld.w	r10,r8[0x0]
8000321a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000321e:	72 09       	ld.w	r9,r9[0x0]
80003220:	8e 5b       	ld.sh	r11,r7[0xa]
80003222:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003226:	70 09       	ld.w	r9,r8[0x0]
80003228:	2f f9       	sub	r9,-1
8000322a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000322c:	e0 49 00 ff 	cp.w	r9,255
80003230:	e0 88 00 16 	brls	8000325c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003234:	30 09       	mov	r9,0
80003236:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003238:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000323c:	6c 0c       	ld.w	r12,r6[0x0]
8000323e:	f0 1f 02 35 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003242:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003246:	70 0c       	ld.w	r12,r8[0x0]
80003248:	f0 1f 02 1f 	mcall	80003ac4 <phy_rx_func+0xe98>
8000324c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000324e:	c0 71       	brne	8000325c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003250:	30 09       	mov	r9,0
80003252:	fe f8 08 96 	ld.w	r8,pc[2198]
80003256:	91 09       	st.w	r8[0x0],r9
80003258:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000325c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003260:	72 08       	ld.w	r8,r9[0x0]
80003262:	20 28       	sub	r8,2
80003264:	93 08       	st.w	r9[0x0],r8
80003266:	c0 71       	brne	80003274 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003268:	30 09       	mov	r9,0
8000326a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000326e:	91 09       	st.w	r8[0x0],r9
80003270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003274:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003278:	70 0a       	ld.w	r10,r8[0x0]
8000327a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000327e:	72 09       	ld.w	r9,r9[0x0]
80003280:	8e 6b       	ld.sh	r11,r7[0xc]
80003282:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003286:	70 09       	ld.w	r9,r8[0x0]
80003288:	2f f9       	sub	r9,-1
8000328a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000328c:	e0 49 00 ff 	cp.w	r9,255
80003290:	e0 88 00 16 	brls	800032bc <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003294:	30 09       	mov	r9,0
80003296:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003298:	fe f6 08 48 	ld.w	r6,pc[2120]
8000329c:	6c 0c       	ld.w	r12,r6[0x0]
8000329e:	f0 1f 02 1d 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032a2:	fe f8 08 3a 	ld.w	r8,pc[2106]
800032a6:	70 0c       	ld.w	r12,r8[0x0]
800032a8:	f0 1f 02 07 	mcall	80003ac4 <phy_rx_func+0xe98>
800032ac:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032ae:	c0 71       	brne	800032bc <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032b0:	30 09       	mov	r9,0
800032b2:	fe f8 08 36 	ld.w	r8,pc[2102]
800032b6:	91 09       	st.w	r8[0x0],r9
800032b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032bc:	fe f9 08 34 	ld.w	r9,pc[2100]
800032c0:	72 08       	ld.w	r8,r9[0x0]
800032c2:	20 28       	sub	r8,2
800032c4:	93 08       	st.w	r9[0x0],r8
800032c6:	c0 71       	brne	800032d4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032c8:	30 09       	mov	r9,0
800032ca:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032ce:	91 09       	st.w	r8[0x0],r9
800032d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032d4:	fe f8 08 64 	ld.w	r8,pc[2148]
800032d8:	70 0a       	ld.w	r10,r8[0x0]
800032da:	fe f9 08 06 	ld.w	r9,pc[2054]
800032de:	72 09       	ld.w	r9,r9[0x0]
800032e0:	8e 7b       	ld.sh	r11,r7[0xe]
800032e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032e6:	70 09       	ld.w	r9,r8[0x0]
800032e8:	2f f9       	sub	r9,-1
800032ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032ec:	e0 49 00 ff 	cp.w	r9,255
800032f0:	e0 88 00 16 	brls	8000331c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800032f4:	30 09       	mov	r9,0
800032f6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032f8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800032fc:	6e 0c       	ld.w	r12,r7[0x0]
800032fe:	f0 1f 02 05 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003302:	fe f8 07 da 	ld.w	r8,pc[2010]
80003306:	70 0c       	ld.w	r12,r8[0x0]
80003308:	f0 1f 01 ef 	mcall	80003ac4 <phy_rx_func+0xe98>
8000330c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000330e:	c0 71       	brne	8000331c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003310:	30 09       	mov	r9,0
80003312:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003316:	91 09       	st.w	r8[0x0],r9
80003318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000331c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003320:	72 08       	ld.w	r8,r9[0x0]
80003322:	20 28       	sub	r8,2
80003324:	93 08       	st.w	r9[0x0],r8
80003326:	e0 81 03 c0 	brne	80003aa6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000332a:	30 09       	mov	r9,0
8000332c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003330:	91 09       	st.w	r8[0x0],r9
80003332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003336:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000333a:	11 89       	ld.ub	r9,r8[0x0]
8000333c:	31 28       	mov	r8,18
8000333e:	f0 09 18 00 	cp.b	r9,r8
80003342:	e0 81 01 4c 	brne	800035da <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003346:	ef 39 00 09 	ld.ub	r9,r7[9]
8000334a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000334e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003350:	11 89       	ld.ub	r9,r8[0x0]
80003352:	3f 28       	mov	r8,-14
80003354:	f0 09 18 00 	cp.b	r9,r8
80003358:	e0 81 01 3b 	brne	800035ce <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000335c:	30 19       	mov	r9,1
8000335e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003362:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003364:	6e 29       	ld.w	r9,r7[0x8]
80003366:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000336a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000336e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003370:	8e 59       	ld.sh	r9,r7[0xa]
80003372:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003376:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003378:	8e 69       	ld.sh	r9,r7[0xc]
8000337a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000337c:	8e 79       	ld.sh	r9,r7[0xe]
8000337e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003380:	fe f8 07 88 	ld.w	r8,pc[1928]
80003384:	fe f9 07 60 	ld.w	r9,pc[1888]
80003388:	72 0a       	ld.w	r10,r9[0x0]
8000338a:	70 09       	ld.w	r9,r8[0x0]
8000338c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003390:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003394:	70 09       	ld.w	r9,r8[0x0]
80003396:	2f f9       	sub	r9,-1
80003398:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000339a:	e0 49 01 ff 	cp.w	r9,511
8000339e:	e0 88 00 16 	brls	800033ca <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800033a2:	30 09       	mov	r9,0
800033a4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033a6:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033aa:	6c 0c       	ld.w	r12,r6[0x0]
800033ac:	f0 1f 01 d9 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033b0:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033b4:	70 0c       	ld.w	r12,r8[0x0]
800033b6:	f0 1f 01 c4 	mcall	80003ac4 <phy_rx_func+0xe98>
800033ba:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033bc:	c0 71       	brne	800033ca <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033be:	30 09       	mov	r9,0
800033c0:	fe f8 07 28 	ld.w	r8,pc[1832]
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033ca:	fe f9 07 26 	ld.w	r9,pc[1830]
800033ce:	72 08       	ld.w	r8,r9[0x0]
800033d0:	20 18       	sub	r8,1
800033d2:	93 08       	st.w	r9[0x0],r8
800033d4:	c0 71       	brne	800033e2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033d6:	30 09       	mov	r9,0
800033d8:	fe f8 07 10 	ld.w	r8,pc[1808]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033e2:	fe f8 07 26 	ld.w	r8,pc[1830]
800033e6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033ea:	72 0a       	ld.w	r10,r9[0x0]
800033ec:	70 09       	ld.w	r9,r8[0x0]
800033ee:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033f2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033f6:	70 09       	ld.w	r9,r8[0x0]
800033f8:	2f f9       	sub	r9,-1
800033fa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033fc:	e0 49 01 ff 	cp.w	r9,511
80003400:	e0 88 00 16 	brls	8000342c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003404:	30 09       	mov	r9,0
80003406:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003408:	fe f6 06 dc 	ld.w	r6,pc[1756]
8000340c:	6c 0c       	ld.w	r12,r6[0x0]
8000340e:	f0 1f 01 c1 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003412:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003416:	70 0c       	ld.w	r12,r8[0x0]
80003418:	f0 1f 01 ab 	mcall	80003ac4 <phy_rx_func+0xe98>
8000341c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000341e:	c0 71       	brne	8000342c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003420:	30 09       	mov	r9,0
80003422:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003426:	91 09       	st.w	r8[0x0],r9
80003428:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000342c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003430:	72 08       	ld.w	r8,r9[0x0]
80003432:	20 18       	sub	r8,1
80003434:	93 08       	st.w	r9[0x0],r8
80003436:	c0 71       	brne	80003444 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003438:	30 09       	mov	r9,0
8000343a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003444:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003448:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000344c:	72 0a       	ld.w	r10,r9[0x0]
8000344e:	70 09       	ld.w	r9,r8[0x0]
80003450:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003454:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003458:	70 09       	ld.w	r9,r8[0x0]
8000345a:	2f f9       	sub	r9,-1
8000345c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000345e:	e0 49 01 ff 	cp.w	r9,511
80003462:	e0 88 00 16 	brls	8000348e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003466:	30 09       	mov	r9,0
80003468:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000346a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000346e:	6c 0c       	ld.w	r12,r6[0x0]
80003470:	f0 1f 01 a8 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003474:	fe f8 06 68 	ld.w	r8,pc[1640]
80003478:	70 0c       	ld.w	r12,r8[0x0]
8000347a:	f0 1f 01 93 	mcall	80003ac4 <phy_rx_func+0xe98>
8000347e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003480:	c0 71       	brne	8000348e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003482:	30 09       	mov	r9,0
80003484:	fe f8 06 64 	ld.w	r8,pc[1636]
80003488:	91 09       	st.w	r8[0x0],r9
8000348a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000348e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003492:	72 08       	ld.w	r8,r9[0x0]
80003494:	20 18       	sub	r8,1
80003496:	93 08       	st.w	r9[0x0],r8
80003498:	c0 71       	brne	800034a6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000349a:	30 09       	mov	r9,0
8000349c:	fe f8 06 4c 	ld.w	r8,pc[1612]
800034a0:	91 09       	st.w	r8[0x0],r9
800034a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800034a6:	fe f8 06 62 	ld.w	r8,pc[1634]
800034aa:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034ae:	72 0a       	ld.w	r10,r9[0x0]
800034b0:	70 09       	ld.w	r9,r8[0x0]
800034b2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034b6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ba:	70 09       	ld.w	r9,r8[0x0]
800034bc:	2f f9       	sub	r9,-1
800034be:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034c0:	e0 49 01 ff 	cp.w	r9,511
800034c4:	e0 88 00 16 	brls	800034f0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034c8:	30 09       	mov	r9,0
800034ca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034cc:	fe f6 06 18 	ld.w	r6,pc[1560]
800034d0:	6c 0c       	ld.w	r12,r6[0x0]
800034d2:	f0 1f 01 90 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034d6:	fe f8 06 06 	ld.w	r8,pc[1542]
800034da:	70 0c       	ld.w	r12,r8[0x0]
800034dc:	f0 1f 01 7a 	mcall	80003ac4 <phy_rx_func+0xe98>
800034e0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 06 02 	ld.w	r8,pc[1538]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034f0:	fe f9 06 00 	ld.w	r9,pc[1536]
800034f4:	72 08       	ld.w	r8,r9[0x0]
800034f6:	20 18       	sub	r8,1
800034f8:	93 08       	st.w	r9[0x0],r8
800034fa:	c0 71       	brne	80003508 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003502:	91 09       	st.w	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003508:	fe f8 06 00 	ld.w	r8,pc[1536]
8000350c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003510:	72 0a       	ld.w	r10,r9[0x0]
80003512:	70 09       	ld.w	r9,r8[0x0]
80003514:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003518:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000351c:	70 09       	ld.w	r9,r8[0x0]
8000351e:	2f f9       	sub	r9,-1
80003520:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003522:	e0 49 01 ff 	cp.w	r9,511
80003526:	e0 88 00 16 	brls	80003552 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000352a:	30 09       	mov	r9,0
8000352c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000352e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003532:	6c 0c       	ld.w	r12,r6[0x0]
80003534:	f0 1f 01 77 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003538:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000353c:	70 0c       	ld.w	r12,r8[0x0]
8000353e:	f0 1f 01 62 	mcall	80003ac4 <phy_rx_func+0xe98>
80003542:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003544:	c0 71       	brne	80003552 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003546:	30 09       	mov	r9,0
80003548:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000354c:	91 09       	st.w	r8[0x0],r9
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003552:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003556:	72 08       	ld.w	r8,r9[0x0]
80003558:	20 18       	sub	r8,1
8000355a:	93 08       	st.w	r9[0x0],r8
8000355c:	c0 71       	brne	8000356a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000355e:	30 09       	mov	r9,0
80003560:	fe f8 05 88 	ld.w	r8,pc[1416]
80003564:	91 09       	st.w	r8[0x0],r9
80003566:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000356a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000356e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003572:	72 0a       	ld.w	r10,r9[0x0]
80003574:	70 09       	ld.w	r9,r8[0x0]
80003576:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000357a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000357e:	70 09       	ld.w	r9,r8[0x0]
80003580:	2f f9       	sub	r9,-1
80003582:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003584:	e0 49 01 ff 	cp.w	r9,511
80003588:	e0 88 00 16 	brls	800035b4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000358c:	30 09       	mov	r9,0
8000358e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003590:	fe f7 05 54 	ld.w	r7,pc[1364]
80003594:	6e 0c       	ld.w	r12,r7[0x0]
80003596:	f0 1f 01 5f 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000359a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000359e:	70 0c       	ld.w	r12,r8[0x0]
800035a0:	f0 1f 01 49 	mcall	80003ac4 <phy_rx_func+0xe98>
800035a4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035a6:	c0 71       	brne	800035b4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035b4:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035b8:	72 08       	ld.w	r8,r9[0x0]
800035ba:	20 18       	sub	r8,1
800035bc:	93 08       	st.w	r9[0x0],r8
800035be:	e0 81 02 74 	brne	80003aa6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035c2:	30 09       	mov	r9,0
800035c4:	fe f8 05 24 	ld.w	r8,pc[1316]
800035c8:	91 09       	st.w	r8[0x0],r9
800035ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035ce:	30 09       	mov	r9,0
800035d0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035d4:	91 09       	st.w	r8[0x0],r9
800035d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035da:	fe f8 05 26 	ld.w	r8,pc[1318]
800035de:	11 89       	ld.ub	r9,r8[0x0]
800035e0:	3f 28       	mov	r8,-14
800035e2:	f0 09 18 00 	cp.b	r9,r8
800035e6:	c4 31       	brne	8000366c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035e8:	8e 49       	ld.sh	r9,r7[0x8]
800035ea:	fe f8 05 56 	ld.w	r8,pc[1366]
800035ee:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035f0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035f4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800035f8:	72 0a       	ld.w	r10,r9[0x0]
800035fa:	70 09       	ld.w	r9,r8[0x0]
800035fc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003600:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003604:	70 09       	ld.w	r9,r8[0x0]
80003606:	2f f9       	sub	r9,-1
80003608:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000360a:	e0 49 01 ff 	cp.w	r9,511
8000360e:	e0 88 00 16 	brls	8000363a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003612:	30 09       	mov	r9,0
80003614:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003616:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000361a:	6e 0c       	ld.w	r12,r7[0x0]
8000361c:	f0 1f 01 3d 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003620:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003624:	70 0c       	ld.w	r12,r8[0x0]
80003626:	f0 1f 01 28 	mcall	80003ac4 <phy_rx_func+0xe98>
8000362a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000362c:	c0 71       	brne	8000363a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000362e:	30 09       	mov	r9,0
80003630:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003634:	91 09       	st.w	r8[0x0],r9
80003636:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000363a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000363e:	72 08       	ld.w	r8,r9[0x0]
80003640:	20 18       	sub	r8,1
80003642:	93 08       	st.w	r9[0x0],r8
80003644:	c0 71       	brne	80003652 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003646:	30 09       	mov	r9,0
80003648:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000364c:	91 09       	st.w	r8[0x0],r9
8000364e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003652:	20 18       	sub	r8,1
80003654:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003658:	93 08       	st.w	r9[0x0],r8
8000365a:	58 08       	cp.w	r8,0
8000365c:	e0 81 02 25 	brne	80003aa6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003660:	30 09       	mov	r9,0
80003662:	fe f8 04 86 	ld.w	r8,pc[1158]
80003666:	91 09       	st.w	r8[0x0],r9
80003668:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000366c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003670:	11 89       	ld.ub	r9,r8[0x0]
80003672:	3f 38       	mov	r8,-13
80003674:	f0 09 18 00 	cp.b	r9,r8
80003678:	e0 81 01 0c 	brne	80003890 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000367c:	8e 49       	ld.sh	r9,r7[0x8]
8000367e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003682:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003684:	8e 59       	ld.sh	r9,r7[0xa]
80003686:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003688:	8e 69       	ld.sh	r9,r7[0xc]
8000368a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000368c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003690:	fe f9 04 54 	ld.w	r9,pc[1108]
80003694:	72 0a       	ld.w	r10,r9[0x0]
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000369c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036a0:	70 09       	ld.w	r9,r8[0x0]
800036a2:	2f f9       	sub	r9,-1
800036a4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036a6:	e0 49 01 ff 	cp.w	r9,511
800036aa:	e0 88 00 16 	brls	800036d6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036ae:	30 09       	mov	r9,0
800036b0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036b2:	fe f6 04 32 	ld.w	r6,pc[1074]
800036b6:	6c 0c       	ld.w	r12,r6[0x0]
800036b8:	f0 1f 01 16 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036bc:	fe f8 04 20 	ld.w	r8,pc[1056]
800036c0:	70 0c       	ld.w	r12,r8[0x0]
800036c2:	f0 1f 01 01 	mcall	80003ac4 <phy_rx_func+0xe98>
800036c6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036c8:	c0 71       	brne	800036d6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036ca:	30 09       	mov	r9,0
800036cc:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036d0:	91 09       	st.w	r8[0x0],r9
800036d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036d6:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036da:	72 08       	ld.w	r8,r9[0x0]
800036dc:	20 18       	sub	r8,1
800036de:	93 08       	st.w	r9[0x0],r8
800036e0:	c0 71       	brne	800036ee <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036e2:	30 09       	mov	r9,0
800036e4:	fe f8 04 04 	ld.w	r8,pc[1028]
800036e8:	91 09       	st.w	r8[0x0],r9
800036ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036ee:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036f2:	fe f9 03 f2 	ld.w	r9,pc[1010]
800036f6:	72 0a       	ld.w	r10,r9[0x0]
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	ef 3b 00 09 	ld.ub	r11,r7[9]
800036fe:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003702:	70 09       	ld.w	r9,r8[0x0]
80003704:	2f f9       	sub	r9,-1
80003706:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003708:	e0 49 01 ff 	cp.w	r9,511
8000370c:	e0 88 00 16 	brls	80003738 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003710:	30 09       	mov	r9,0
80003712:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003714:	fe f6 03 d0 	ld.w	r6,pc[976]
80003718:	6c 0c       	ld.w	r12,r6[0x0]
8000371a:	f0 1f 00 fe 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000371e:	fe f8 03 be 	ld.w	r8,pc[958]
80003722:	70 0c       	ld.w	r12,r8[0x0]
80003724:	f0 1f 00 e8 	mcall	80003ac4 <phy_rx_func+0xe98>
80003728:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000372a:	c0 71       	brne	80003738 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000372c:	30 09       	mov	r9,0
8000372e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003732:	91 09       	st.w	r8[0x0],r9
80003734:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003738:	fe f9 03 b8 	ld.w	r9,pc[952]
8000373c:	72 08       	ld.w	r8,r9[0x0]
8000373e:	20 18       	sub	r8,1
80003740:	93 08       	st.w	r9[0x0],r8
80003742:	c0 71       	brne	80003750 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003744:	30 09       	mov	r9,0
80003746:	fe f8 03 a2 	ld.w	r8,pc[930]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003750:	fe f8 03 b8 	ld.w	r8,pc[952]
80003754:	fe f9 03 90 	ld.w	r9,pc[912]
80003758:	72 0a       	ld.w	r10,r9[0x0]
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003760:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003764:	70 09       	ld.w	r9,r8[0x0]
80003766:	2f f9       	sub	r9,-1
80003768:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000376a:	e0 49 01 ff 	cp.w	r9,511
8000376e:	e0 88 00 16 	brls	8000379a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003772:	30 09       	mov	r9,0
80003774:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003776:	fe f6 03 6e 	ld.w	r6,pc[878]
8000377a:	6c 0c       	ld.w	r12,r6[0x0]
8000377c:	f0 1f 00 e5 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003780:	fe f8 03 5c 	ld.w	r8,pc[860]
80003784:	70 0c       	ld.w	r12,r8[0x0]
80003786:	f0 1f 00 d0 	mcall	80003ac4 <phy_rx_func+0xe98>
8000378a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000378c:	c0 71       	brne	8000379a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000378e:	30 09       	mov	r9,0
80003790:	fe f8 03 58 	ld.w	r8,pc[856]
80003794:	91 09       	st.w	r8[0x0],r9
80003796:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000379a:	fe f9 03 56 	ld.w	r9,pc[854]
8000379e:	72 08       	ld.w	r8,r9[0x0]
800037a0:	20 18       	sub	r8,1
800037a2:	93 08       	st.w	r9[0x0],r8
800037a4:	c0 71       	brne	800037b2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800037a6:	30 09       	mov	r9,0
800037a8:	fe f8 03 40 	ld.w	r8,pc[832]
800037ac:	91 09       	st.w	r8[0x0],r9
800037ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037b2:	fe f8 03 56 	ld.w	r8,pc[854]
800037b6:	fe f9 03 2e 	ld.w	r9,pc[814]
800037ba:	72 0a       	ld.w	r10,r9[0x0]
800037bc:	70 09       	ld.w	r9,r8[0x0]
800037be:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037c2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037c6:	70 09       	ld.w	r9,r8[0x0]
800037c8:	2f f9       	sub	r9,-1
800037ca:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037cc:	e0 49 01 ff 	cp.w	r9,511
800037d0:	e0 88 00 16 	brls	800037fc <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037d4:	30 09       	mov	r9,0
800037d6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037d8:	fe f6 03 0c 	ld.w	r6,pc[780]
800037dc:	6c 0c       	ld.w	r12,r6[0x0]
800037de:	f0 1f 00 cd 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037e2:	fe f8 02 fa 	ld.w	r8,pc[762]
800037e6:	70 0c       	ld.w	r12,r8[0x0]
800037e8:	f0 1f 00 b7 	mcall	80003ac4 <phy_rx_func+0xe98>
800037ec:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 02 f6 	ld.w	r8,pc[758]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037fc:	fe f9 02 f4 	ld.w	r9,pc[756]
80003800:	72 08       	ld.w	r8,r9[0x0]
80003802:	20 18       	sub	r8,1
80003804:	93 08       	st.w	r9[0x0],r8
80003806:	c0 71       	brne	80003814 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003808:	30 09       	mov	r9,0
8000380a:	fe f8 02 de 	ld.w	r8,pc[734]
8000380e:	91 09       	st.w	r8[0x0],r9
80003810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003814:	fe f8 02 f4 	ld.w	r8,pc[756]
80003818:	fe f9 02 cc 	ld.w	r9,pc[716]
8000381c:	72 0a       	ld.w	r10,r9[0x0]
8000381e:	70 09       	ld.w	r9,r8[0x0]
80003820:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003824:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003828:	70 09       	ld.w	r9,r8[0x0]
8000382a:	2f f9       	sub	r9,-1
8000382c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000382e:	e0 49 01 ff 	cp.w	r9,511
80003832:	e0 88 00 16 	brls	8000385e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003836:	30 09       	mov	r9,0
80003838:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000383a:	fe f7 02 aa 	ld.w	r7,pc[682]
8000383e:	6e 0c       	ld.w	r12,r7[0x0]
80003840:	f0 1f 00 b4 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003844:	fe f8 02 98 	ld.w	r8,pc[664]
80003848:	70 0c       	ld.w	r12,r8[0x0]
8000384a:	f0 1f 00 9f 	mcall	80003ac4 <phy_rx_func+0xe98>
8000384e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003850:	c0 71       	brne	8000385e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 02 94 	ld.w	r8,pc[660]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000385e:	fe f9 02 92 	ld.w	r9,pc[658]
80003862:	72 08       	ld.w	r8,r9[0x0]
80003864:	20 18       	sub	r8,1
80003866:	93 08       	st.w	r9[0x0],r8
80003868:	c0 71       	brne	80003876 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000386a:	30 09       	mov	r9,0
8000386c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003870:	91 09       	st.w	r8[0x0],r9
80003872:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003876:	20 18       	sub	r8,1
80003878:	fe f9 02 78 	ld.w	r9,pc[632]
8000387c:	93 08       	st.w	r9[0x0],r8
8000387e:	58 08       	cp.w	r8,0
80003880:	e0 81 01 13 	brne	80003aa6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003884:	30 09       	mov	r9,0
80003886:	fe f8 02 62 	ld.w	r8,pc[610]
8000388a:	91 09       	st.w	r8[0x0],r9
8000388c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003890:	fe f8 02 70 	ld.w	r8,pc[624]
80003894:	11 89       	ld.ub	r9,r8[0x0]
80003896:	30 48       	mov	r8,4
80003898:	f0 09 18 00 	cp.b	r9,r8
8000389c:	c0 80       	breq	800038ac <phy_rx_func+0xc80>
8000389e:	fe f8 02 62 	ld.w	r8,pc[610]
800038a2:	11 89       	ld.ub	r9,r8[0x0]
800038a4:	30 38       	mov	r8,3
800038a6:	f0 09 18 00 	cp.b	r9,r8
800038aa:	c1 41       	brne	800038d2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038ac:	6e 29       	ld.w	r9,r7[0x8]
800038ae:	fe f8 02 7a 	ld.w	r8,pc[634]
800038b2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038b4:	6e 39       	ld.w	r9,r7[0xc]
800038b6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038b8:	fe f9 02 38 	ld.w	r9,pc[568]
800038bc:	72 08       	ld.w	r8,r9[0x0]
800038be:	20 88       	sub	r8,8
800038c0:	93 08       	st.w	r9[0x0],r8
800038c2:	e0 81 00 f2 	brne	80003aa6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038c6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038c8:	fe f9 02 20 	ld.w	r9,pc[544]
800038cc:	93 08       	st.w	r9[0x0],r8
800038ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038d2:	fe f8 02 2e 	ld.w	r8,pc[558]
800038d6:	11 89       	ld.ub	r9,r8[0x0]
800038d8:	31 38       	mov	r8,19
800038da:	f0 09 18 00 	cp.b	r9,r8
800038de:	e0 81 00 9c 	brne	80003a16 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038e2:	fe f8 02 62 	ld.w	r8,pc[610]
800038e6:	11 88       	ld.ub	r8,r8[0x0]
800038e8:	30 c9       	mov	r9,12
800038ea:	f2 08 18 00 	cp.b	r8,r9
800038ee:	e0 81 00 7b 	brne	800039e4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038f2:	8e 49       	ld.sh	r9,r7[0x8]
800038f4:	fe f8 02 54 	ld.w	r8,pc[596]
800038f8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	fe f8 02 46 	ld.w	r8,pc[582]
80003902:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003904:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003908:	3f 38       	mov	r8,-13
8000390a:	f0 09 18 00 	cp.b	r9,r8
8000390e:	c6 61       	brne	800039da <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003910:	10 99       	mov	r9,r8
80003912:	4f c8       	lddpc	r8,80003b00 <phy_rx_func+0xed4>
80003914:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003916:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000391a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000391e:	4f 58       	lddpc	r8,80003af0 <phy_rx_func+0xec4>
80003920:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003922:	30 19       	mov	r9,1
80003924:	fe f8 02 0c 	ld.w	r8,pc[524]
80003928:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000392a:	8e 79       	ld.sh	r9,r7[0xe]
8000392c:	fe f8 02 14 	ld.w	r8,pc[532]
80003930:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003932:	4f 68       	lddpc	r8,80003b08 <phy_rx_func+0xedc>
80003934:	4e c9       	lddpc	r9,80003ae4 <phy_rx_func+0xeb8>
80003936:	72 0a       	ld.w	r10,r9[0x0]
80003938:	70 09       	ld.w	r9,r8[0x0]
8000393a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000393e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003942:	70 09       	ld.w	r9,r8[0x0]
80003944:	2f f9       	sub	r9,-1
80003946:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003948:	e0 49 01 ff 	cp.w	r9,511
8000394c:	e0 88 00 13 	brls	80003972 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003950:	30 09       	mov	r9,0
80003952:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003954:	4e 46       	lddpc	r6,80003ae4 <phy_rx_func+0xeb8>
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 00 6e 	mcall	80003b10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	4e 08       	lddpc	r8,80003adc <phy_rx_func+0xeb0>
8000395e:	70 0c       	ld.w	r12,r8[0x0]
80003960:	f0 1f 00 59 	mcall	80003ac4 <phy_rx_func+0xe98>
80003964:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003966:	c0 61       	brne	80003972 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003968:	30 09       	mov	r9,0
8000396a:	4e 08       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
8000396c:	91 09       	st.w	r8[0x0],r9
8000396e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003972:	4e 09       	lddpc	r9,80003af0 <phy_rx_func+0xec4>
80003974:	72 08       	ld.w	r8,r9[0x0]
80003976:	20 18       	sub	r8,1
80003978:	93 08       	st.w	r9[0x0],r8
8000397a:	c0 61       	brne	80003986 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
8000397c:	30 09       	mov	r9,0
8000397e:	4d b8       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003986:	4e 18       	lddpc	r8,80003b08 <phy_rx_func+0xedc>
80003988:	4d 79       	lddpc	r9,80003ae4 <phy_rx_func+0xeb8>
8000398a:	72 0a       	ld.w	r10,r9[0x0]
8000398c:	70 09       	ld.w	r9,r8[0x0]
8000398e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003992:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003996:	70 09       	ld.w	r9,r8[0x0]
80003998:	2f f9       	sub	r9,-1
8000399a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399c:	e0 49 01 ff 	cp.w	r9,511
800039a0:	e0 88 00 13 	brls	800039c6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800039a4:	30 09       	mov	r9,0
800039a6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039a8:	4c f7       	lddpc	r7,80003ae4 <phy_rx_func+0xeb8>
800039aa:	6e 0c       	ld.w	r12,r7[0x0]
800039ac:	f0 1f 00 59 	mcall	80003b10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039b0:	4c b8       	lddpc	r8,80003adc <phy_rx_func+0xeb0>
800039b2:	70 0c       	ld.w	r12,r8[0x0]
800039b4:	f0 1f 00 44 	mcall	80003ac4 <phy_rx_func+0xe98>
800039b8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039ba:	c0 61       	brne	800039c6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039bc:	30 09       	mov	r9,0
800039be:	4c b8       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039c0:	91 09       	st.w	r8[0x0],r9
800039c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039c6:	4c b9       	lddpc	r9,80003af0 <phy_rx_func+0xec4>
800039c8:	72 08       	ld.w	r8,r9[0x0]
800039ca:	20 18       	sub	r8,1
800039cc:	93 08       	st.w	r9[0x0],r8
800039ce:	c6 c1       	brne	80003aa6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039d0:	30 09       	mov	r9,0
800039d2:	4c 68       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039d4:	91 09       	st.w	r8[0x0],r9
800039d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	4c 38       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039de:	91 09       	st.w	r8[0x0],r9
800039e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039e4:	8e 4a       	ld.sh	r10,r7[0x8]
800039e6:	4d 99       	lddpc	r9,80003b48 <phy_rx_func+0xf1c>
800039e8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039ec:	4d 6a       	lddpc	r10,80003b44 <phy_rx_func+0xf18>
800039ee:	15 88       	ld.ub	r8,r10[0x0]
800039f0:	f0 cb ff ff 	sub	r11,r8,-1
800039f4:	8e 5c       	ld.sh	r12,r7[0xa]
800039f6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800039fa:	f0 cb ff fe 	sub	r11,r8,-2
800039fe:	8e 6c       	ld.sh	r12,r7[0xc]
80003a00:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003a04:	f0 cb ff fd 	sub	r11,r8,-3
80003a08:	8e 7c       	ld.sh	r12,r7[0xe]
80003a0a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a0e:	2f c8       	sub	r8,-4
80003a10:	b4 88       	st.b	r10[0x0],r8
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a16:	30 09       	mov	r9,0
80003a18:	4b 48       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a1a:	91 09       	st.w	r8[0x0],r9
80003a1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a20:	4c 08       	lddpc	r8,80003b20 <phy_rx_func+0xef4>
80003a22:	70 09       	ld.w	r9,r8[0x0]
80003a24:	8e 4b       	ld.sh	r11,r7[0x8]
80003a26:	4c 0a       	lddpc	r10,80003b24 <phy_rx_func+0xef8>
80003a28:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a2c:	2f f9       	sub	r9,-1
80003a2e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a30:	4b 58       	lddpc	r8,80003b04 <phy_rx_func+0xed8>
80003a32:	70 09       	ld.w	r9,r8[0x0]
80003a34:	20 29       	sub	r9,2
80003a36:	91 09       	st.w	r8[0x0],r9
80003a38:	70 08       	ld.w	r8,r8[0x0]
80003a3a:	58 08       	cp.w	r8,0
80003a3c:	c2 f1       	brne	80003a9a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a3e:	30 09       	mov	r9,0
80003a40:	4b 88       	lddpc	r8,80003b20 <phy_rx_func+0xef4>
80003a42:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a44:	8e 59       	ld.sh	r9,r7[0xa]
80003a46:	fe 78 82 12 	mov	r8,-32238
80003a4a:	f0 09 19 00 	cp.h	r9,r8
80003a4e:	c2 11       	brne	80003a90 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a50:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a54:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a58:	4a f8       	lddpc	r8,80003b14 <phy_rx_func+0xee8>
80003a5a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a5c:	8e 59       	ld.sh	r9,r7[0xa]
80003a5e:	4a f8       	lddpc	r8,80003b18 <phy_rx_func+0xeec>
80003a60:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a62:	8e 69       	ld.sh	r9,r7[0xc]
80003a64:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a66:	f0 1f 00 2e 	mcall	80003b1c <phy_rx_func+0xef0>
80003a6a:	4a 18       	lddpc	r8,80003aec <phy_rx_func+0xec0>
80003a6c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a6e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a72:	31 38       	mov	r8,19
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	c0 71       	brne	80003a86 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a7a:	10 99       	mov	r9,r8
80003a7c:	4a 18       	lddpc	r8,80003b00 <phy_rx_func+0xed4>
80003a7e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a80:	30 09       	mov	r9,0
80003a82:	49 c8       	lddpc	r8,80003af0 <phy_rx_func+0xec4>
80003a84:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a86:	30 49       	mov	r9,4
80003a88:	49 88       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a90:	30 09       	mov	r9,0
80003a92:	49 68       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a94:	91 09       	st.w	r8[0x0],r9
80003a96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003a9a:	4a dc       	lddpc	r12,80003b4c <phy_rx_func+0xf20>
80003a9c:	f0 1f 00 18 	mcall	80003afc <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003aa0:	30 09       	mov	r9,0
80003aa2:	49 28       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003aa4:	91 09       	st.w	r8[0x0],r9
80003aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003aaa:	00 00       	add	r0,r0
80003aac:	00 00       	add	r0,r0
80003aae:	0a b8       	st.h	r5++,r8
80003ab0:	00 00       	add	r0,r0
80003ab2:	0a d4       	st.w	--r5,r4
80003ab4:	00 00       	add	r0,r0
80003ab6:	0a b0       	st.h	r5++,r0
80003ab8:	00 00       	add	r0,r0
80003aba:	0a 90       	mov	r0,r5
80003abc:	00 00       	add	r0,r0
80003abe:	0a 80       	andn	r0,r5
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a a4       	st.w	r5++,r4
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	2a 4c       	sub	r12,-92
80003ac8:	00 00       	add	r0,r0
80003aca:	0a d8       	st.w	--r5,r8
80003acc:	80 00       	ld.sh	r0,r0[0x0]
80003ace:	29 7c       	sub	r12,-105
80003ad0:	00 00       	add	r0,r0
80003ad2:	0a b4       	st.h	r5++,r4
80003ad4:	80 00       	ld.sh	r0,r0[0x0]
80003ad6:	29 98       	sub	r8,-103
80003ad8:	00 00       	add	r0,r0
80003ada:	0a e4       	st.h	--r5,r4
80003adc:	00 00       	add	r0,r0
80003ade:	0a ac       	st.w	r5++,r12
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a c8       	st.b	r5++,r8
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 9c       	mov	r12,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	0a ec       	st.h	--r5,r12
80003aec:	00 00       	add	r0,r0
80003aee:	0a c4       	st.b	r5++,r4
80003af0:	00 00       	add	r0,r0
80003af2:	0a 8c       	andn	r12,r5
80003af4:	00 00       	add	r0,r0
80003af6:	0a 63       	and	r3,r5
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	d8 f8       	*unknown*
80003afc:	80 00       	ld.sh	r0,r0[0x0]
80003afe:	72 dc       	ld.w	r12,r9[0x34]
80003b00:	00 00       	add	r0,r0
80003b02:	0a 98       	mov	r8,r5
80003b04:	00 00       	add	r0,r0
80003b06:	0a 7c       	tst	r12,r5
80003b08:	00 00       	add	r0,r0
80003b0a:	0a e0       	st.h	--r5,r0
80003b0c:	80 00       	ld.sh	r0,r0[0x0]
80003b0e:	7b 3e       	ld.w	lr,sp[0x4c]
80003b10:	80 00       	ld.sh	r0,r0[0x0]
80003b12:	2b cc       	sub	r12,-68
80003b14:	00 00       	add	r0,r0
80003b16:	0a 66       	and	r6,r5
80003b18:	00 00       	add	r0,r0
80003b1a:	1f 00       	ld.w	r0,pc++
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	28 dc       	sub	r12,-115
80003b20:	00 00       	add	r0,r0
80003b22:	0a c0       	st.b	r5++,r0
80003b24:	00 00       	add	r0,r0
80003b26:	1e 04       	add	r4,pc
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 84       	andn	r4,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a 60       	and	r0,r5
80003b30:	00 00       	add	r0,r0
80003b32:	0a 51       	eor	r1,r5
80003b34:	00 00       	add	r0,r0
80003b36:	0a 74       	tst	r4,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	0a a8       	st.w	r5++,r8
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a 67       	and	r7,r5
80003b40:	00 00       	add	r0,r0
80003b42:	1d fc       	ld.ub	r12,lr[0x7]
80003b44:	00 00       	add	r0,r0
80003b46:	0a d0       	st.w	--r5,r0
80003b48:	00 00       	add	r0,r0
80003b4a:	1f 04       	ld.w	r4,pc++
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	d9 10       	acall	0x91

80003b50 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b50:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b52:	49 88       	lddpc	r8,80003bb0 <pdca_int_handler+0x60>
80003b54:	11 89       	ld.ub	r9,r8[0x0]
80003b56:	ec 19 00 01 	eorl	r9,0x1
80003b5a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b5c:	11 89       	ld.ub	r9,r8[0x0]
80003b5e:	a5 69       	lsl	r9,0x4
80003b60:	2f c9       	sub	r9,-4
80003b62:	49 5a       	lddpc	r10,80003bb4 <pdca_int_handler+0x64>
80003b64:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b66:	fe 7a 00 40 	mov	r10,-65472
80003b6a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b6c:	30 39       	mov	r9,3
80003b6e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b70:	11 8a       	ld.ub	r10,r8[0x0]
80003b72:	a5 6a       	lsl	r10,0x4
80003b74:	2f ca       	sub	r10,-4
80003b76:	49 18       	lddpc	r8,80003bb8 <pdca_int_handler+0x68>
80003b78:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b7a:	fe 78 00 00 	mov	r8,-65536
80003b7e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b80:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b82:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b84:	48 e8       	lddpc	r8,80003bbc <pdca_int_handler+0x6c>
80003b86:	70 08       	ld.w	r8,r8[0x0]
80003b88:	58 08       	cp.w	r8,0
80003b8a:	c0 70       	breq	80003b98 <pdca_int_handler+0x48>
80003b8c:	48 99       	lddpc	r9,80003bb0 <pdca_int_handler+0x60>
80003b8e:	13 89       	ld.ub	r9,r9[0x0]
80003b90:	a5 69       	lsl	r9,0x4
80003b92:	48 ac       	lddpc	r12,80003bb8 <pdca_int_handler+0x68>
80003b94:	12 0c       	add	r12,r9
80003b96:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003b98:	48 a8       	lddpc	r8,80003bc0 <pdca_int_handler+0x70>
80003b9a:	70 08       	ld.w	r8,r8[0x0]
80003b9c:	58 08       	cp.w	r8,0
80003b9e:	c0 70       	breq	80003bac <pdca_int_handler+0x5c>
80003ba0:	48 49       	lddpc	r9,80003bb0 <pdca_int_handler+0x60>
80003ba2:	13 89       	ld.ub	r9,r9[0x0]
80003ba4:	a5 69       	lsl	r9,0x4
80003ba6:	48 4c       	lddpc	r12,80003bb4 <pdca_int_handler+0x64>
80003ba8:	12 0c       	add	r12,r9
80003baa:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003bac:	d4 02       	popm	lr
80003bae:	d6 03       	rete
80003bb0:	00 00       	add	r0,r0
80003bb2:	51 24       	stdsp	sp[0x48],r4
80003bb4:	00 00       	add	r0,r0
80003bb6:	51 4c       	stdsp	sp[0x50],r12
80003bb8:	00 00       	add	r0,r0
80003bba:	51 2c       	stdsp	sp[0x48],r12
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a f0       	st.b	--r5,r0
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a f4       	st.b	--r5,r4

80003bc4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bc4:	fe 78 10 00 	mov	r8,-61440
80003bc8:	e0 69 0d c0 	mov	r9,3520
80003bcc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bd0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bd4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bd8:	fe 78 34 00 	mov	r8,-52224
80003bdc:	e0 69 80 00 	mov	r9,32768
80003be0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003be2:	30 09       	mov	r9,0
80003be4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003be6:	e0 69 04 21 	mov	r9,1057
80003bea:	ea 19 3f 20 	orh	r9,0x3f20
80003bee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003bf0:	e0 69 02 9f 	mov	r9,671
80003bf4:	ea 19 01 00 	orh	r9,0x100
80003bf8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003bfa:	e0 6a 04 02 	mov	r10,1026
80003bfe:	ea 1a 3f 20 	orh	r10,0x3f20
80003c02:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003c04:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003c06:	5e fc       	retal	r12

80003c08 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c08:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c0a:	30 19       	mov	r9,1
80003c0c:	49 78       	lddpc	r8,80003c68 <local_start_PDC+0x60>
80003c0e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c10:	fe 78 00 00 	mov	r8,-65536
80003c14:	30 7b       	mov	r11,7
80003c16:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c18:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c1a:	49 59       	lddpc	r9,80003c6c <local_start_PDC+0x64>
80003c1c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c20:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c22:	30 3a       	mov	r10,3
80003c24:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c26:	30 1c       	mov	r12,1
80003c28:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c2a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c2c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c2e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c30:	30 2c       	mov	r12,2
80003c32:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c34:	48 f9       	lddpc	r9,80003c70 <local_start_PDC+0x68>
80003c36:	e0 68 5a 5a 	mov	r8,23130
80003c3a:	ea 18 ab cd 	orh	r8,0xabcd
80003c3e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c40:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c42:	30 0e       	mov	lr,0
80003c44:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c46:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c48:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c4a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c4c:	fe 78 00 40 	mov	r8,-65472
80003c50:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c52:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c54:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c58:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c5a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c5c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c5e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c60:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c62:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c64:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c66:	d8 02       	popm	pc
80003c68:	00 00       	add	r0,r0
80003c6a:	51 24       	stdsp	sp[0x48],r4
80003c6c:	00 00       	add	r0,r0
80003c6e:	51 2c       	stdsp	sp[0x48],r12
80003c70:	00 00       	add	r0,r0
80003c72:	51 4c       	stdsp	sp[0x50],r12

80003c74 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c74:	48 38       	lddpc	r8,80003c80 <register_rx_tx_func+0xc>
80003c76:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c78:	48 38       	lddpc	r8,80003c84 <register_rx_tx_func+0x10>
80003c7a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c7c:	5e fc       	retal	r12
80003c7e:	00 00       	add	r0,r0
80003c80:	00 00       	add	r0,r0
80003c82:	0a f0       	st.b	--r5,r0
80003c84:	00 00       	add	r0,r0
80003c86:	0a f4       	st.b	--r5,r4

80003c88 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c88:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c8a:	fe 78 10 00 	mov	r8,-61440
80003c8e:	30 29       	mov	r9,2
80003c90:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c94:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003c98:	30 3a       	mov	r10,3
80003c9a:	36 0b       	mov	r11,96
80003c9c:	49 3c       	lddpc	r12,80003ce8 <ssc_init+0x60>
80003c9e:	f0 1f 00 14 	mcall	80003cec <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003ca2:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003ca4:	fe 79 10 00 	mov	r9,-61440
80003ca8:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cac:	e2 18 00 02 	andl	r8,0x2,COH
80003cb0:	cf c0       	breq	80003ca8 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003cb2:	fe 79 10 00 	mov	r9,-61440
80003cb6:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cba:	e2 18 00 02 	andl	r8,0x2,COH
80003cbe:	cf c1       	brne	80003cb6 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003cc0:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003cc2:	f0 1f 00 0c 	mcall	80003cf0 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003cc6:	f0 1f 00 0c 	mcall	80003cf4 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cca:	fe 79 00 00 	mov	r9,-65536
80003cce:	30 18       	mov	r8,1
80003cd0:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cd2:	fe 7a 00 40 	mov	r10,-65472
80003cd6:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cd8:	e0 6b 01 01 	mov	r11,257
80003cdc:	fe 7a 34 00 	mov	r10,-52224
80003ce0:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ce2:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ce4:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ce6:	d8 02       	popm	pc
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	3b 50       	mov	r0,-75
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	58 d0       	cp.w	r0,13
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	3b c4       	mov	r4,-68
80003cf4:	80 00       	ld.sh	r0,r0[0x0]
80003cf6:	3c 08       	mov	r8,-64

80003cf8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003cf8:	48 28       	lddpc	r8,80003d00 <xcmp_register_app_list+0x8>
80003cfa:	91 0c       	st.w	r8[0x0],r12
}
80003cfc:	5e fc       	retal	r12
80003cfe:	00 00       	add	r0,r0
80003d00:	00 00       	add	r0,r0
80003d02:	51 6c       	stdsp	sp[0x58],r12

80003d04 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d04:	eb cd 40 80 	pushm	r7,lr
80003d08:	fa cd 01 00 	sub	sp,sp,256
80003d0c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d0e:	16 98       	mov	r8,r11
80003d10:	2f 08       	sub	r8,-16
80003d12:	af a8       	sbr	r8,0xe
80003d14:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d16:	3f f8       	mov	r8,-1
80003d18:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d1a:	30 b9       	mov	r9,11
80003d1c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d1e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d20:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d22:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d24:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d26:	f6 ca ff fe 	sub	r10,r11,-2
80003d2a:	18 9b       	mov	r11,r12
80003d2c:	fa cc ff f0 	sub	r12,sp,-16
80003d30:	f0 1f 00 05 	mcall	80003d44 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d34:	2f e7       	sub	r7,-2
80003d36:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d38:	1a 9c       	mov	r12,sp
80003d3a:	f0 1f 00 04 	mcall	80003d48 <xcmp_tx+0x44>
}
80003d3e:	2c 0d       	sub	sp,-256
80003d40:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	79 f6       	ld.w	r6,r12[0x7c]
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	43 10       	lddsp	r0,sp[0xc4]

80003d4c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d4c:	d4 21       	pushm	r4-r7,lr
80003d4e:	fa cd 00 d0 	sub	sp,sp,208
80003d52:	18 94       	mov	r4,r12
80003d54:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d56:	e0 68 01 00 	mov	r8,256
80003d5a:	f0 0b 19 00 	cp.h	r11,r8
80003d5e:	e0 8b 00 36 	brhi	80003dca <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d62:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d66:	e0 68 04 1d 	mov	r8,1053
80003d6a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003d6c:	30 18       	mov	r8,1
80003d6e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003d70:	32 08       	mov	r8,32
80003d72:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003d74:	30 28       	mov	r8,2
80003d76:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003d78:	30 48       	mov	r8,4
80003d7a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003d7c:	ea 1a 0c 00 	orh	r10,0xc00
80003d80:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003d82:	30 4a       	mov	r10,4
80003d84:	1a 9b       	mov	r11,sp
80003d86:	fa cc ff f4 	sub	r12,sp,-12
80003d8a:	f0 1f 00 12 	mcall	80003dd0 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003d8e:	30 f8       	mov	r8,15
80003d90:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003d94:	3a 78       	mov	r8,-89
80003d96:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003d9a:	30 08       	mov	r8,0
80003d9c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003da0:	0e 9a       	mov	r10,r7
80003da2:	5c 7a       	castu.h	r10
80003da4:	f4 08 16 08 	lsr	r8,r10,0x8
80003da8:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003dac:	0e 96       	mov	r6,r7
80003dae:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003db2:	08 9b       	mov	r11,r4
80003db4:	fa cc ff eb 	sub	r12,sp,-21
80003db8:	f0 1f 00 06 	mcall	80003dd0 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003dbc:	ee cb ff f3 	sub	r11,r7,-13
80003dc0:	5c 5b       	castu.b	r11
80003dc2:	fa cc ff fa 	sub	r12,sp,-6
80003dc6:	f0 1f 00 04 	mcall	80003dd4 <xcmp_data_session_req+0x88>
}
80003dca:	2c cd       	sub	sp,-208
80003dcc:	d8 22       	popm	r4-r7,pc
80003dce:	00 00       	add	r0,r0
80003dd0:	80 00       	ld.sh	r0,r0[0x0]
80003dd2:	79 f6       	ld.w	r6,r12[0x7c]
80003dd4:	80 00       	ld.sh	r0,r0[0x0]
80003dd6:	3d 04       	mov	r4,-48

80003dd8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003dd8:	d4 01       	pushm	lr
80003dda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dde:	fe 78 b4 00 	mov	r8,-19456
80003de2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003de4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003de8:	30 89       	mov	r9,8
80003dea:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003dec:	30 19       	mov	r9,1
80003dee:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003df0:	30 09       	mov	r9,0
80003df2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003df4:	30 5a       	mov	r10,5
80003df6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003df8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003dfa:	30 7a       	mov	r10,7
80003dfc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003dfe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e00:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e02:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e06:	30 9b       	mov	r11,9
80003e08:	fa cc ff fe 	sub	r12,sp,-2
80003e0c:	f0 1f 00 02 	mcall	80003e14 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e10:	2c dd       	sub	sp,-204
80003e12:	d8 02       	popm	pc
80003e14:	80 00       	ld.sh	r0,r0[0x0]
80003e16:	3d 04       	mov	r4,-48

80003e18 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e18:	d4 01       	pushm	lr
80003e1a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e1e:	fe 78 80 00 	mov	r8,-32768
80003e22:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e24:	30 38       	mov	r8,3
80003e26:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e28:	30 1b       	mov	r11,1
80003e2a:	fa cc ff fe 	sub	r12,sp,-2
80003e2e:	f0 1f 00 03 	mcall	80003e38 <xcmp_opcode_not_supported+0x20>
}
80003e32:	2c dd       	sub	sp,-204
80003e34:	d8 02       	popm	pc
80003e36:	00 00       	add	r0,r0
80003e38:	80 00       	ld.sh	r0,r0[0x0]
80003e3a:	3d 04       	mov	r4,-48

80003e3c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e3c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e3e:	96 88       	ld.uh	r8,r11[0x0]
80003e40:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e44:	e0 48 80 00 	cp.w	r8,32768
80003e48:	c0 f0       	breq	80003e66 <xcmp_exec_func+0x2a>
80003e4a:	e0 48 b0 00 	cp.w	r8,45056
80003e4e:	c1 20       	breq	80003e72 <xcmp_exec_func+0x36>
80003e50:	58 08       	cp.w	r8,0
80003e52:	c1 51       	brne	80003e7c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e54:	78 08       	ld.w	r8,r12[0x0]
80003e56:	58 08       	cp.w	r8,0
80003e58:	c0 40       	breq	80003e60 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e5a:	16 9c       	mov	r12,r11
80003e5c:	5d 18       	icall	r8
80003e5e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e60:	f0 1f 00 08 	mcall	80003e80 <xcmp_exec_func+0x44>
80003e64:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e66:	78 18       	ld.w	r8,r12[0x4]
80003e68:	58 08       	cp.w	r8,0
80003e6a:	c0 90       	breq	80003e7c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e6c:	16 9c       	mov	r12,r11
80003e6e:	5d 18       	icall	r8
80003e70:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e72:	78 28       	ld.w	r8,r12[0x8]
80003e74:	58 08       	cp.w	r8,0
80003e76:	c0 30       	breq	80003e7c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e78:	16 9c       	mov	r12,r11
80003e7a:	5d 18       	icall	r8
80003e7c:	d8 02       	popm	pc
80003e7e:	00 00       	add	r0,r0
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	3e 18       	mov	r8,-31

80003e84 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003e84:	d4 01       	pushm	lr
80003e86:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003e8a:	e0 68 04 09 	mov	r8,1033
80003e8e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003e90:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003e94:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003e96:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003e9a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003e9c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003e9e:	30 09       	mov	r9,0
80003ea0:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003ea2:	fb 69 00 08 	st.b	sp[8],r9
80003ea6:	fa c8 ff f7 	sub	r8,sp,-9
80003eaa:	b0 89       	st.b	r8[0x0],r9
80003eac:	fa c8 ff f6 	sub	r8,sp,-10
80003eb0:	b0 89       	st.b	r8[0x0],r9
80003eb2:	fa c8 ff f5 	sub	r8,sp,-11
80003eb6:	b0 89       	st.b	r8[0x0],r9
80003eb8:	fa c8 ff f4 	sub	r8,sp,-12
80003ebc:	b0 89       	st.b	r8[0x0],r9
80003ebe:	fa c8 ff f3 	sub	r8,sp,-13
80003ec2:	b0 89       	st.b	r8[0x0],r9
80003ec4:	fa c8 ff f2 	sub	r8,sp,-14
80003ec8:	b0 89       	st.b	r8[0x0],r9
80003eca:	fa c8 ff f1 	sub	r8,sp,-15
80003ece:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003ed0:	30 cb       	mov	r11,12
80003ed2:	fa cc ff fe 	sub	r12,sp,-2
80003ed6:	f0 1f 00 03 	mcall	80003ee0 <xcmp_IdleTestTone+0x5c>
}
80003eda:	2c dd       	sub	sp,-204
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3d 04       	mov	r4,-48

80003ee4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ee4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ee6:	48 dc       	lddpc	r12,80003f18 <xcmp_init+0x34>
80003ee8:	f0 1f 00 0d 	mcall	80003f1c <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003eec:	30 4b       	mov	r11,4
80003eee:	31 4c       	mov	r12,20
80003ef0:	f0 1f 00 0c 	mcall	80003f20 <xcmp_init+0x3c>
80003ef4:	48 c8       	lddpc	r8,80003f24 <xcmp_init+0x40>
80003ef6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ef8:	30 09       	mov	r9,0
80003efa:	1a d9       	st.w	--sp,r9
80003efc:	1a d9       	st.w	--sp,r9
80003efe:	1a d9       	st.w	--sp,r9
80003f00:	30 38       	mov	r8,3
80003f02:	e0 6a 01 80 	mov	r10,384
80003f06:	48 9b       	lddpc	r11,80003f28 <xcmp_init+0x44>
80003f08:	48 9c       	lddpc	r12,80003f2c <xcmp_init+0x48>
80003f0a:	f0 1f 00 0a 	mcall	80003f30 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003f0e:	f0 1f 00 0a 	mcall	80003f34 <xcmp_init+0x50>
80003f12:	2f dd       	sub	sp,-12
	
}
80003f14:	d8 02       	popm	pc
80003f16:	00 00       	add	r0,r0
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	40 34       	lddsp	r4,sp[0xc]
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	40 80       	lddsp	r0,sp[0x20]
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	66 70       	ld.w	r0,r3[0x1c]
80003f24:	00 00       	add	r0,r0
80003f26:	0b 10       	ld.sh	r0,r5++
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	d9 3c       	*unknown*
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	3f 38       	mov	r8,-13
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	6d 8c       	ld.w	r12,r6[0x60]
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	40 b8       	lddsp	r8,sp[0x2c]

80003f38 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f38:	d4 31       	pushm	r0-r7,lr
80003f3a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f3c:	4b 16       	lddpc	r6,80004000 <xcmp_rx_process+0xc8>
80003f3e:	30 05       	mov	r5,0
80003f40:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f42:	4b 13       	lddpc	r3,80004004 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f44:	4b 12       	lddpc	r2,80004008 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f46:	4b 21       	lddpc	r1,8000400c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f48:	4b 20       	lddpc	r0,80004010 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f4a:	6c 0c       	ld.w	r12,r6[0x0]
80003f4c:	0a 99       	mov	r9,r5
80003f4e:	08 9a       	mov	r10,r4
80003f50:	1a 9b       	mov	r11,sp
80003f52:	f0 1f 00 31 	mcall	80004014 <xcmp_rx_process+0xdc>
80003f56:	58 1c       	cp.w	r12,1
80003f58:	cf 91       	brne	80003f4a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f5a:	40 0b       	lddsp	r11,sp[0x0]
80003f5c:	58 0b       	cp.w	r11,0
80003f5e:	cf 60       	breq	80003f4a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f60:	96 0a       	ld.sh	r10,r11[0x0]
80003f62:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f66:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f6a:	59 c8       	cp.w	r8,28
80003f6c:	c1 e0       	breq	80003fa8 <xcmp_rx_process+0x70>
80003f6e:	e0 89 00 07 	brgt	80003f7c <xcmp_rx_process+0x44>
80003f72:	58 e8       	cp.w	r8,14
80003f74:	c0 e0       	breq	80003f90 <xcmp_rx_process+0x58>
80003f76:	58 f8       	cp.w	r8,15
80003f78:	c2 41       	brne	80003fc0 <xcmp_rx_process+0x88>
80003f7a:	c0 f8       	rjmp	80003f98 <xcmp_rx_process+0x60>
80003f7c:	e0 48 01 09 	cp.w	r8,265
80003f80:	c1 80       	breq	80003fb0 <xcmp_rx_process+0x78>
80003f82:	e0 48 01 0a 	cp.w	r8,266
80003f86:	c1 90       	breq	80003fb8 <xcmp_rx_process+0x80>
80003f88:	e0 48 00 2c 	cp.w	r8,44
80003f8c:	c1 a1       	brne	80003fc0 <xcmp_rx_process+0x88>
80003f8e:	c0 98       	rjmp	80003fa0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003f90:	4a 2c       	lddpc	r12,80004018 <xcmp_rx_process+0xe0>
80003f92:	f0 1f 00 23 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003f96:	c2 f8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003f98:	4a 2c       	lddpc	r12,80004020 <xcmp_rx_process+0xe8>
80003f9a:	f0 1f 00 21 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003f9e:	c2 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003fa0:	4a 1c       	lddpc	r12,80004024 <xcmp_rx_process+0xec>
80003fa2:	f0 1f 00 1f 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fa6:	c2 78       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fa8:	04 9c       	mov	r12,r2
80003faa:	f0 1f 00 1d 	mcall	8000401c <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003fae:	c2 38       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fb0:	02 9c       	mov	r12,r1
80003fb2:	f0 1f 00 1b 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fb6:	c1 f8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fb8:	00 9c       	mov	r12,r0
80003fba:	f0 1f 00 19 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fbe:	c1 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fc0:	12 98       	mov	r8,r9
80003fc2:	e2 18 04 00 	andl	r8,0x400,COH
80003fc6:	c0 70       	breq	80003fd4 <xcmp_rx_process+0x9c>
80003fc8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fcc:	e0 48 00 68 	cp.w	r8,104
80003fd0:	e0 8a 00 08 	brle	80003fe0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003fd4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003fd8:	c0 e1       	brne	80003ff4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003fda:	f0 1f 00 14 	mcall	80004028 <xcmp_rx_process+0xf0>
80003fde:	c0 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003fe0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003fe4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003fe8:	49 19       	lddpc	r9,8000402c <xcmp_rx_process+0xf4>
80003fea:	72 08       	ld.w	r8,r9[0x0]
80003fec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003ff0:	f0 1f 00 0b 	mcall	8000401c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ff4:	66 0c       	ld.w	r12,r3[0x0]
80003ff6:	40 0b       	lddsp	r11,sp[0x0]
80003ff8:	f0 1f 00 0e 	mcall	80004030 <xcmp_rx_process+0xf8>
80003ffc:	ca 7b       	rjmp	80003f4a <xcmp_rx_process+0x12>
80003ffe:	00 00       	add	r0,r0
80004000:	00 00       	add	r0,r0
80004002:	0b 10       	ld.sh	r0,r5++
80004004:	00 00       	add	r0,r0
80004006:	0a a4       	st.w	r5++,r4
80004008:	00 00       	add	r0,r0
8000400a:	0b 20       	ld.uh	r0,r5++
8000400c:	00 00       	add	r0,r0
8000400e:	0b 14       	ld.sh	r4,r5++
80004010:	00 00       	add	r0,r0
80004012:	0b 04       	ld.w	r4,r5++
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	63 64       	ld.w	r4,r1[0x58]
80004018:	00 00       	add	r0,r0
8000401a:	0b 38       	ld.ub	r8,r5++
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	3e 3c       	mov	r12,-29
80004020:	00 00       	add	r0,r0
80004022:	0a f8       	st.b	--r5,r8
80004024:	00 00       	add	r0,r0
80004026:	0b 2c       	ld.uh	r12,r5++
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3e 18       	mov	r8,-31
8000402c:	00 00       	add	r0,r0
8000402e:	51 6c       	stdsp	sp[0x58],r12
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	29 d0       	sub	r0,-99

80004034 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004034:	eb cd 40 90 	pushm	r4,r7,lr
80004038:	20 1d       	sub	sp,4
8000403a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000403e:	48 c8       	lddpc	r8,8000406c <xcmp_rx+0x38>
80004040:	70 0c       	ld.w	r12,r8[0x0]
80004042:	f0 1f 00 0c 	mcall	80004070 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004046:	c1 00       	breq	80004066 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004048:	fa c7 ff fc 	sub	r7,sp,-4
8000404c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000404e:	e0 6a 00 ca 	mov	r10,202
80004052:	08 9b       	mov	r11,r4
80004054:	f0 1f 00 08 	mcall	80004074 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004058:	48 88       	lddpc	r8,80004078 <xcmp_rx+0x44>
8000405a:	70 0c       	ld.w	r12,r8[0x0]
8000405c:	30 09       	mov	r9,0
8000405e:	12 9a       	mov	r10,r9
80004060:	1a 9b       	mov	r11,sp
80004062:	f0 1f 00 07 	mcall	8000407c <xcmp_rx+0x48>
	}	
}
80004066:	2f fd       	sub	sp,-4
80004068:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000406c:	00 00       	add	r0,r0
8000406e:	0a a4       	st.w	r5++,r4
80004070:	80 00       	ld.sh	r0,r0[0x0]
80004072:	2b 7c       	sub	r12,-73
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	79 f6       	ld.w	r6,r12[0x7c]
80004078:	00 00       	add	r0,r0
8000407a:	0b 10       	ld.sh	r0,r5++
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	65 70       	ld.w	r0,r2[0x5c]

80004080 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004080:	48 28       	lddpc	r8,80004088 <xnl_register_xcmp_func+0x8>
80004082:	91 0c       	st.w	r8[0x0],r12
}
80004084:	5e fc       	retal	r12
80004086:	00 00       	add	r0,r0
80004088:	00 00       	add	r0,r0
8000408a:	0b 64       	ld.uh	r4,--r5

8000408c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000408c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000408e:	48 88       	lddpc	r8,800040ac <xnl_get_msg_ack_func+0x20>
80004090:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004092:	98 49       	ld.sh	r9,r12[0x8]
80004094:	f0 09 19 00 	cp.h	r9,r8
80004098:	c0 81       	brne	800040a8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000409a:	48 68       	lddpc	r8,800040b0 <xnl_get_msg_ack_func+0x24>
8000409c:	70 0c       	ld.w	r12,r8[0x0]
8000409e:	30 09       	mov	r9,0
800040a0:	12 9a       	mov	r10,r9
800040a2:	12 9b       	mov	r11,r9
800040a4:	f0 1f 00 04 	mcall	800040b4 <xnl_get_msg_ack_func+0x28>
800040a8:	d8 02       	popm	pc
800040aa:	00 00       	add	r0,r0
800040ac:	00 00       	add	r0,r0
800040ae:	0b 4a       	ld.w	r10,--r5
800040b0:	00 00       	add	r0,r0
800040b2:	0b 44       	ld.w	r4,--r5
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	65 70       	ld.w	r0,r2[0x5c]

800040b8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040b8:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040bc:	30 09       	mov	r9,0
800040be:	4b 78       	lddpc	r8,80004198 <xnl_init+0xe0>
800040c0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040c2:	30 0b       	mov	r11,0
800040c4:	30 1c       	mov	r12,1
800040c6:	f0 1f 00 36 	mcall	8000419c <xnl_init+0xe4>
800040ca:	4b 68       	lddpc	r8,800041a0 <xnl_init+0xe8>
800040cc:	91 0c       	st.w	r8[0x0],r12
800040ce:	70 08       	ld.w	r8,r8[0x0]
800040d0:	58 08       	cp.w	r8,0
800040d2:	c0 80       	breq	800040e2 <xnl_init+0x2a>
800040d4:	4b 38       	lddpc	r8,800041a0 <xnl_init+0xe8>
800040d6:	70 0c       	ld.w	r12,r8[0x0]
800040d8:	30 09       	mov	r9,0
800040da:	12 9a       	mov	r10,r9
800040dc:	12 9b       	mov	r11,r9
800040de:	f0 1f 00 32 	mcall	800041a4 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800040e2:	30 4b       	mov	r11,4
800040e4:	31 4c       	mov	r12,20
800040e6:	f0 1f 00 2e 	mcall	8000419c <xnl_init+0xe4>
800040ea:	4b 08       	lddpc	r8,800041a8 <xnl_init+0xf0>
800040ec:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040ee:	30 4b       	mov	r11,4
800040f0:	31 ec       	mov	r12,30
800040f2:	f0 1f 00 2b 	mcall	8000419c <xnl_init+0xe4>
800040f6:	4a e8       	lddpc	r8,800041ac <xnl_init+0xf4>
800040f8:	91 0c       	st.w	r8[0x0],r12
800040fa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040fc:	10 96       	mov	r6,r8
800040fe:	4a d5       	lddpc	r5,800041b0 <xnl_init+0xf8>
80004100:	6c 0c       	ld.w	r12,r6[0x0]
80004102:	ea 07 00 0b 	add	r11,r5,r7
80004106:	f0 1f 00 2c 	mcall	800041b4 <xnl_init+0xfc>
8000410a:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000410e:	e0 47 1e 00 	cp.w	r7,7680
80004112:	cf 71       	brne	80004100 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004114:	30 4b       	mov	r11,4
80004116:	31 4c       	mov	r12,20
80004118:	f0 1f 00 21 	mcall	8000419c <xnl_init+0xe4>
8000411c:	4a 78       	lddpc	r8,800041b8 <xnl_init+0x100>
8000411e:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004120:	30 4b       	mov	r11,4
80004122:	30 ac       	mov	r12,10
80004124:	f0 1f 00 1e 	mcall	8000419c <xnl_init+0xe4>
80004128:	4a 58       	lddpc	r8,800041bc <xnl_init+0x104>
8000412a:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000412c:	30 4b       	mov	r11,4
8000412e:	30 ac       	mov	r12,10
80004130:	f0 1f 00 1b 	mcall	8000419c <xnl_init+0xe4>
80004134:	4a 38       	lddpc	r8,800041c0 <xnl_init+0x108>
80004136:	91 0c       	st.w	r8[0x0],r12
80004138:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000413a:	10 96       	mov	r6,r8
8000413c:	4a 25       	lddpc	r5,800041c4 <xnl_init+0x10c>
8000413e:	6c 0c       	ld.w	r12,r6[0x0]
80004140:	ea 07 00 0b 	add	r11,r5,r7
80004144:	f0 1f 00 1c 	mcall	800041b4 <xnl_init+0xfc>
80004148:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000414c:	e0 47 14 00 	cp.w	r7,5120
80004150:	cf 71       	brne	8000413e <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004152:	30 4b       	mov	r11,4
80004154:	30 5c       	mov	r12,5
80004156:	f0 1f 00 12 	mcall	8000419c <xnl_init+0xe4>
8000415a:	49 c8       	lddpc	r8,800041c8 <xnl_init+0x110>
8000415c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000415e:	30 07       	mov	r7,0
80004160:	1a d7       	st.w	--sp,r7
80004162:	1a d7       	st.w	--sp,r7
80004164:	1a d7       	st.w	--sp,r7
80004166:	30 38       	mov	r8,3
80004168:	0e 99       	mov	r9,r7
8000416a:	e0 6a 02 00 	mov	r10,512
8000416e:	49 8b       	lddpc	r11,800041cc <xnl_init+0x114>
80004170:	49 8c       	lddpc	r12,800041d0 <xnl_init+0x118>
80004172:	f0 1f 00 19 	mcall	800041d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004176:	1a d7       	st.w	--sp,r7
80004178:	1a d7       	st.w	--sp,r7
8000417a:	1a d7       	st.w	--sp,r7
8000417c:	30 38       	mov	r8,3
8000417e:	0e 99       	mov	r9,r7
80004180:	e0 6a 03 20 	mov	r10,800
80004184:	49 5b       	lddpc	r11,800041d8 <xnl_init+0x120>
80004186:	49 6c       	lddpc	r12,800041dc <xnl_init+0x124>
80004188:	f0 1f 00 13 	mcall	800041d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000418c:	f0 1f 00 15 	mcall	800041e0 <xnl_init+0x128>
80004190:	2f ad       	sub	sp,-24
}
80004192:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004196:	00 00       	add	r0,r0
80004198:	00 00       	add	r0,r0
8000419a:	0b 4a       	ld.w	r10,--r5
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	66 70       	ld.w	r0,r3[0x1c]
800041a0:	00 00       	add	r0,r0
800041a2:	0b 44       	ld.w	r4,--r5
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	65 70       	ld.w	r0,r2[0x5c]
800041a8:	00 00       	add	r0,r0
800041aa:	0b 58       	ld.sh	r8,--r5
800041ac:	00 00       	add	r0,r0
800041ae:	0a a4       	st.w	r5++,r4
800041b0:	00 00       	add	r0,r0
800041b2:	33 1e       	mov	lr,49
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	29 d0       	sub	r0,-99
800041b8:	00 00       	add	r0,r0
800041ba:	0a dc       	st.w	--r5,r12
800041bc:	00 00       	add	r0,r0
800041be:	0a b8       	st.h	r5++,r8
800041c0:	00 00       	add	r0,r0
800041c2:	0a ac       	st.w	r5++,r12
800041c4:	00 00       	add	r0,r0
800041c6:	1f 1e       	ld.sh	lr,pc++
800041c8:	00 00       	add	r0,r0
800041ca:	0a a0       	st.w	r5++,r0
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	d9 44       	*unknown*
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	41 e4       	lddsp	r4,sp[0x78]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	6d 8c       	ld.w	r12,r6[0x60]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	d2 00       	acall	0x20
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	42 44       	lddsp	r4,sp[0x90]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	2b a4       	sub	r4,-70

800041e4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041e4:	eb cd 40 fe 	pushm	r1-r7,lr
800041e8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041ea:	49 26       	lddpc	r6,80004230 <xnl_rx_process+0x4c>
800041ec:	30 05       	mov	r5,0
800041ee:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041f0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041f2:	49 11       	lddpc	r1,80004234 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041f4:	49 12       	lddpc	r2,80004238 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041f6:	6c 0c       	ld.w	r12,r6[0x0]
800041f8:	0a 99       	mov	r9,r5
800041fa:	08 9a       	mov	r10,r4
800041fc:	1a 9b       	mov	r11,sp
800041fe:	f0 1f 00 10 	mcall	8000423c <xnl_rx_process+0x58>
80004202:	58 1c       	cp.w	r12,1
80004204:	cf 91       	brne	800041f6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004206:	40 0c       	lddsp	r12,sp[0x0]
80004208:	58 0c       	cp.w	r12,0
8000420a:	cf 60       	breq	800041f6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000420c:	98 28       	ld.sh	r8,r12[0x4]
8000420e:	e6 08 19 00 	cp.h	r8,r3
80004212:	e0 8b 00 0a 	brhi	80004226 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004216:	5c 78       	castu.h	r8
80004218:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000421c:	58 09       	cp.w	r9,0
8000421e:	c0 40       	breq	80004226 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004220:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004224:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004226:	62 0c       	ld.w	r12,r1[0x0]
80004228:	40 0b       	lddsp	r11,sp[0x0]
8000422a:	f0 1f 00 06 	mcall	80004240 <xnl_rx_process+0x5c>
8000422e:	ce 4b       	rjmp	800041f6 <xnl_rx_process+0x12>
80004230:	00 00       	add	r0,r0
80004232:	0a b8       	st.h	r5++,r8
80004234:	00 00       	add	r0,r0
80004236:	0a a4       	st.w	r5++,r4
80004238:	00 00       	add	r0,r0
8000423a:	04 f0       	st.b	--r2,r0
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	63 64       	ld.w	r4,r1[0x58]
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	29 d0       	sub	r0,-99

80004244 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004244:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004246:	4a a6       	lddpc	r6,800042ec <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004248:	4a a2       	lddpc	r2,800042f0 <xnl_tx_process+0xac>
8000424a:	4a b4       	lddpc	r4,800042f4 <xnl_tx_process+0xb0>
8000424c:	30 07       	mov	r7,0
8000424e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004250:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004252:	4a a5       	lddpc	r5,800042f8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004254:	4a a3       	lddpc	r3,800042fc <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004256:	6c 08       	ld.w	r8,r6[0x0]
80004258:	58 08       	cp.w	r8,0
8000425a:	c0 40       	breq	80004262 <xnl_tx_process+0x1e>
8000425c:	58 18       	cp.w	r8,1
8000425e:	cf d1       	brne	80004258 <xnl_tx_process+0x14>
80004260:	c2 48       	rjmp	800042a8 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004262:	64 0c       	ld.w	r12,r2[0x0]
80004264:	0e 99       	mov	r9,r7
80004266:	02 9a       	mov	r10,r1
80004268:	08 9b       	mov	r11,r4
8000426a:	f0 1f 00 26 	mcall	80004300 <xnl_tx_process+0xbc>
8000426e:	58 1c       	cp.w	r12,1
80004270:	cf 31       	brne	80004256 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004272:	68 0b       	ld.w	r11,r4[0x0]
80004274:	58 0b       	cp.w	r11,0
80004276:	cf 00       	breq	80004256 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004278:	96 28       	ld.sh	r8,r11[0x4]
8000427a:	e0 08 19 00 	cp.h	r8,r0
8000427e:	c0 71       	brne	8000428c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004280:	4a 18       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
80004282:	70 08       	ld.w	r8,r8[0x0]
80004284:	10 9c       	mov	r12,r8
80004286:	f0 1f 00 21 	mcall	80004308 <xnl_tx_process+0xc4>
						break;
8000428a:	ce 6b       	rjmp	80004256 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000428c:	16 9c       	mov	r12,r11
8000428e:	f0 1f 00 20 	mcall	8000430c <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004292:	30 18       	mov	r8,1
80004294:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004296:	66 0c       	ld.w	r12,r3[0x0]
80004298:	0e 99       	mov	r9,r7
8000429a:	0e 9a       	mov	r10,r7
8000429c:	0e 9b       	mov	r11,r7
8000429e:	f0 1f 00 19 	mcall	80004300 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800042a2:	30 18       	mov	r8,1
800042a4:	8d 08       	st.w	r6[0x0],r8
800042a6:	cd 8b       	rjmp	80004256 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042a8:	66 0c       	ld.w	r12,r3[0x0]
800042aa:	0e 99       	mov	r9,r7
800042ac:	36 4a       	mov	r10,100
800042ae:	0e 9b       	mov	r11,r7
800042b0:	f0 1f 00 14 	mcall	80004300 <xnl_tx_process+0xbc>
800042b4:	58 1c       	cp.w	r12,1
800042b6:	c0 81       	brne	800042c6 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042b8:	49 38       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
800042ba:	70 0c       	ld.w	r12,r8[0x0]
800042bc:	68 0b       	ld.w	r11,r4[0x0]
800042be:	f0 1f 00 13 	mcall	80004308 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042c2:	8d 07       	st.w	r6[0x0],r7
800042c4:	cc 9b       	rjmp	80004256 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042c6:	6a 08       	ld.w	r8,r5[0x0]
800042c8:	58 38       	cp.w	r8,3
800042ca:	e0 89 00 09 	brgt	800042dc <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042ce:	68 0c       	ld.w	r12,r4[0x0]
800042d0:	f0 1f 00 0f 	mcall	8000430c <xnl_tx_process+0xc8>
						xnl_send_times++;
800042d4:	6a 08       	ld.w	r8,r5[0x0]
800042d6:	2f f8       	sub	r8,-1
800042d8:	8b 08       	st.w	r5[0x0],r8
800042da:	cb eb       	rjmp	80004256 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042dc:	48 a8       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
800042de:	70 0c       	ld.w	r12,r8[0x0]
800042e0:	68 0b       	ld.w	r11,r4[0x0]
800042e2:	f0 1f 00 0a 	mcall	80004308 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042e6:	8d 07       	st.w	r6[0x0],r7
800042e8:	cb 7b       	rjmp	80004256 <xnl_tx_process+0x12>
800042ea:	00 00       	add	r0,r0
800042ec:	00 00       	add	r0,r0
800042ee:	0b 54       	ld.sh	r4,--r5
800042f0:	00 00       	add	r0,r0
800042f2:	0b 58       	ld.sh	r8,--r5
800042f4:	00 00       	add	r0,r0
800042f6:	0b 60       	ld.uh	r0,--r5
800042f8:	00 00       	add	r0,r0
800042fa:	0b 5c       	ld.sh	r12,--r5
800042fc:	00 00       	add	r0,r0
800042fe:	0b 44       	ld.w	r4,--r5
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	63 64       	ld.w	r4,r1[0x58]
80004304:	00 00       	add	r0,r0
80004306:	0a a4       	st.w	r5++,r4
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	29 d0       	sub	r0,-99
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	29 f0       	sub	r0,-97

80004310 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004310:	eb cd 40 c0 	pushm	r6-r7,lr
80004314:	20 1d       	sub	sp,4
80004316:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004318:	98 39       	ld.sh	r9,r12[0x6]
8000431a:	3f f8       	mov	r8,-1
8000431c:	f0 09 19 00 	cp.h	r9,r8
80004320:	c0 a1       	brne	80004334 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004322:	4a e9       	lddpc	r9,800043d8 <xnl_tx+0xc8>
80004324:	13 88       	ld.ub	r8,r9[0x0]
80004326:	2f f8       	sub	r8,-1
80004328:	5c 58       	castu.b	r8
8000432a:	b2 88       	st.b	r9[0x0],r8
8000432c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004330:	a9 a8       	sbr	r8,0x8
80004332:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004334:	8c 49       	ld.sh	r9,r6[0x8]
80004336:	3f f8       	mov	r8,-1
80004338:	f0 09 19 00 	cp.h	r9,r8
8000433c:	c0 41       	brne	80004344 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000433e:	4a 88       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004340:	90 18       	ld.sh	r8,r8[0x2]
80004342:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004344:	8c 59       	ld.sh	r9,r6[0xa]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 41       	brne	80004354 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000434e:	4a 48       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004350:	90 28       	ld.sh	r8,r8[0x4]
80004352:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004354:	8c 69       	ld.sh	r9,r6[0xc]
80004356:	3f f8       	mov	r8,-1
80004358:	f0 09 19 00 	cp.h	r9,r8
8000435c:	c0 e1       	brne	80004378 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000435e:	4a 08       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004360:	90 49       	ld.sh	r9,r8[0x8]
80004362:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004364:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004366:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004368:	90 49       	ld.sh	r9,r8[0x8]
8000436a:	e0 19 ff 00 	andl	r9,0xff00
8000436e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004372:	f3 e8 10 08 	or	r8,r9,r8
80004376:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004378:	0d 98       	ld.ub	r8,r6[0x1]
8000437a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000437c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004380:	10 0c       	add	r12,r8
80004382:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004384:	58 0c       	cp.w	r12,0
80004386:	e0 89 00 04 	brgt	8000438e <xnl_tx+0x7e>
8000438a:	30 09       	mov	r9,0
8000438c:	c0 d8       	rjmp	800043a6 <xnl_tx+0x96>
8000438e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004392:	2f ec       	sub	r12,-2
80004394:	30 09       	mov	r9,0
80004396:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004398:	15 1b       	ld.sh	r11,r10++
8000439a:	f6 09 00 09 	add	r9,r11,r9
8000439e:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043a0:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043a2:	18 38       	cp.w	r8,r12
800043a4:	cf a1       	brne	80004398 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043a6:	5c 39       	neg	r9
800043a8:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043aa:	48 e8       	lddpc	r8,800043e0 <xnl_tx+0xd0>
800043ac:	70 0c       	ld.w	r12,r8[0x0]
800043ae:	f0 1f 00 0e 	mcall	800043e4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043b2:	c1 00       	breq	800043d2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043b4:	fa c7 ff fc 	sub	r7,sp,-4
800043b8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043ba:	e0 6a 01 00 	mov	r10,256
800043be:	0c 9b       	mov	r11,r6
800043c0:	f0 1f 00 0a 	mcall	800043e8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043c4:	48 a8       	lddpc	r8,800043ec <xnl_tx+0xdc>
800043c6:	70 0c       	ld.w	r12,r8[0x0]
800043c8:	30 09       	mov	r9,0
800043ca:	12 9a       	mov	r10,r9
800043cc:	1a 9b       	mov	r11,sp
800043ce:	f0 1f 00 09 	mcall	800043f0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043d2:	2f fd       	sub	sp,-4
800043d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043d8:	00 00       	add	r0,r0
800043da:	0b 48       	ld.w	r8,--r5
800043dc:	00 00       	add	r0,r0
800043de:	0b 4a       	ld.w	r10,--r5
800043e0:	00 00       	add	r0,r0
800043e2:	0a a4       	st.w	r5++,r4
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	2b 7c       	sub	r12,-73
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	79 f6       	ld.w	r6,r12[0x7c]
800043ec:	00 00       	add	r0,r0
800043ee:	0b 58       	ld.sh	r8,--r5
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	65 70       	ld.w	r0,r2[0x5c]

800043f4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800043f4:	eb cd 40 80 	pushm	r7,lr
800043f8:	fa cd 01 00 	sub	sp,sp,256
800043fc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800043fe:	e0 68 40 0e 	mov	r8,16398
80004402:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004404:	3f f8       	mov	r8,-1
80004406:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004408:	30 c8       	mov	r8,12
8000440a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000440c:	98 38       	ld.sh	r8,r12[0x6]
8000440e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004410:	98 58       	ld.sh	r8,r12[0xa]
80004412:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004414:	98 48       	ld.sh	r8,r12[0x8]
80004416:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004418:	98 68       	ld.sh	r8,r12[0xc]
8000441a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000441c:	30 08       	mov	r8,0
8000441e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004420:	1a 9c       	mov	r12,sp
80004422:	f0 1f 00 0a 	mcall	80004448 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004426:	fa cd 00 cc 	sub	sp,sp,204
8000442a:	e0 6a 00 ca 	mov	r10,202
8000442e:	ee cb ff f0 	sub	r11,r7,-16
80004432:	1a 9c       	mov	r12,sp
80004434:	f0 1f 00 06 	mcall	8000444c <xnl_data_msg_func+0x58>
80004438:	48 68       	lddpc	r8,80004450 <xnl_data_msg_func+0x5c>
8000443a:	70 08       	ld.w	r8,r8[0x0]
8000443c:	5d 18       	icall	r8
8000443e:	fa cd ff 34 	sub	sp,sp,-204
}
80004442:	2c 0d       	sub	sp,-256
80004444:	e3 cd 80 80 	ldm	sp++,r7,pc
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	43 10       	lddsp	r0,sp[0xc4]
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	79 f6       	ld.w	r6,r12[0x7c]
80004450:	00 00       	add	r0,r0
80004452:	0b 64       	ld.uh	r4,--r5

80004454 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004454:	d4 21       	pushm	r4-r7,lr
80004456:	fa cd 01 00 	sub	sp,sp,256
8000445a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000445c:	4c 28       	lddpc	r8,80004564 <xnl_device_auth_reply_func+0x110>
8000445e:	11 88       	ld.ub	r8,r8[0x0]
80004460:	58 08       	cp.w	r8,0
80004462:	e0 81 00 7f 	brne	80004560 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004466:	4c 18       	lddpc	r8,80004568 <xnl_device_auth_reply_func+0x114>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	30 09       	mov	r9,0
8000446c:	12 9a       	mov	r10,r9
8000446e:	12 9b       	mov	r11,r9
80004470:	f0 1f 00 3f 	mcall	8000456c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004474:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004478:	4b b8       	lddpc	r8,80004564 <xnl_device_auth_reply_func+0x110>
8000447a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000447c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004480:	ef 38 00 13 	ld.ub	r8,r7[19]
80004484:	b1 68       	lsl	r8,0x10
80004486:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000448a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000448e:	f3 e8 10 08 	or	r8,r9,r8
80004492:	ef 39 00 14 	ld.ub	r9,r7[20]
80004496:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000449a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000449e:	ef 38 00 17 	ld.ub	r8,r7[23]
800044a2:	b1 68       	lsl	r8,0x10
800044a4:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800044a8:	ef 38 00 19 	ld.ub	r8,r7[25]
800044ac:	f5 e8 10 08 	or	r8,r10,r8
800044b0:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044b4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044b8:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044ba:	e0 64 79 b9 	mov	r4,31161
800044be:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044c2:	e0 65 45 07 	mov	r5,17671
800044c6:	ea 15 8a bd 	orh	r5,0x8abd
800044ca:	e0 66 f9 3d 	mov	r6,63805
800044ce:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044d2:	e0 6e b8 cf 	mov	lr,47311
800044d6:	ea 1e 36 83 	orh	lr,0x3683
800044da:	e0 67 aa 1c 	mov	r7,43548
800044de:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044e2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044e4:	f4 08 00 0c 	add	r12,r10,r8
800044e8:	f0 0b 15 04 	lsl	r11,r8,0x4
800044ec:	0a 0b       	add	r11,r5
800044ee:	f9 eb 20 0b 	eor	r11,r12,r11
800044f2:	f0 0c 16 05 	lsr	r12,r8,0x5
800044f6:	0c 0c       	add	r12,r6
800044f8:	18 5b       	eor	r11,r12
800044fa:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044fc:	f2 0c 15 04 	lsl	r12,r9,0x4
80004500:	1c 0c       	add	r12,lr
80004502:	f2 0b 16 05 	lsr	r11,r9,0x5
80004506:	0e 0b       	add	r11,r7
80004508:	f9 eb 20 0b 	eor	r11,r12,r11
8000450c:	f2 0a 00 0c 	add	r12,r9,r10
80004510:	18 5b       	eor	r11,r12
80004512:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004514:	e0 6b 37 20 	mov	r11,14112
80004518:	ea 1b c6 ef 	orh	r11,0xc6ef
8000451c:	16 3a       	cp.w	r10,r11
8000451e:	ce 21       	brne	800044e2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004520:	e0 6a 40 1a 	mov	r10,16410
80004524:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004526:	3f fa       	mov	r10,-1
80004528:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000452a:	30 6b       	mov	r11,6
8000452c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000452e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004530:	48 db       	lddpc	r11,80004564 <xnl_device_auth_reply_func+0x110>
80004532:	96 1c       	ld.sh	r12,r11[0x2]
80004534:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004536:	96 2b       	ld.sh	r11,r11[0x4]
80004538:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000453a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000453c:	30 ca       	mov	r10,12
8000453e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004540:	30 0a       	mov	r10,0
80004542:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004546:	30 7a       	mov	r10,7
80004548:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000454c:	30 2a       	mov	r10,2
8000454e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004552:	fa ca ff ec 	sub	r10,sp,-20
80004556:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004558:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000455a:	1a 9c       	mov	r12,sp
8000455c:	f0 1f 00 05 	mcall	80004570 <xnl_device_auth_reply_func+0x11c>
}
80004560:	2c 0d       	sub	sp,-256
80004562:	d8 22       	popm	r4-r7,pc
80004564:	00 00       	add	r0,r0
80004566:	0b 4a       	ld.w	r10,--r5
80004568:	00 00       	add	r0,r0
8000456a:	0b 44       	ld.w	r4,--r5
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	65 70       	ld.w	r0,r2[0x5c]
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	43 10       	lddsp	r0,sp[0xc4]

80004574 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004574:	eb cd 40 80 	pushm	r7,lr
80004578:	fa cd 01 00 	sub	sp,sp,256
8000457c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000457e:	49 28       	lddpc	r8,800045c4 <xnl_master_status_brdcst_func+0x50>
80004580:	11 88       	ld.ub	r8,r8[0x0]
80004582:	58 08       	cp.w	r8,0
80004584:	c1 c1       	brne	800045bc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004586:	49 18       	lddpc	r8,800045c8 <xnl_master_status_brdcst_func+0x54>
80004588:	70 0c       	ld.w	r12,r8[0x0]
8000458a:	30 09       	mov	r9,0
8000458c:	12 9a       	mov	r10,r9
8000458e:	12 9b       	mov	r11,r9
80004590:	f0 1f 00 0f 	mcall	800045cc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004594:	8e 58       	ld.sh	r8,r7[0xa]
80004596:	48 c9       	lddpc	r9,800045c4 <xnl_master_status_brdcst_func+0x50>
80004598:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000459a:	e0 68 40 0e 	mov	r8,16398
8000459e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045a0:	3f f8       	mov	r8,-1
800045a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800045a4:	30 4a       	mov	r10,4
800045a6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045a8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045aa:	92 19       	ld.sh	r9,r9[0x2]
800045ac:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800045ae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045b0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045b2:	30 08       	mov	r8,0
800045b4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045b6:	1a 9c       	mov	r12,sp
800045b8:	f0 1f 00 06 	mcall	800045d0 <xnl_master_status_brdcst_func+0x5c>
}
800045bc:	2c 0d       	sub	sp,-256
800045be:	e3 cd 80 80 	ldm	sp++,r7,pc
800045c2:	00 00       	add	r0,r0
800045c4:	00 00       	add	r0,r0
800045c6:	0b 4a       	ld.w	r10,--r5
800045c8:	00 00       	add	r0,r0
800045ca:	0b 44       	ld.w	r4,--r5
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	65 70       	ld.w	r0,r2[0x5c]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	43 10       	lddsp	r0,sp[0xc4]

800045d4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800045d4:	eb cd 40 80 	pushm	r7,lr
800045d8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800045da:	49 28       	lddpc	r8,80004620 <xnl_device_conn_reply_func+0x4c>
800045dc:	70 0c       	ld.w	r12,r8[0x0]
800045de:	30 09       	mov	r9,0
800045e0:	12 9a       	mov	r10,r9
800045e2:	12 9b       	mov	r11,r9
800045e4:	f0 1f 00 10 	mcall	80004624 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045e8:	ef 18 00 10 	ld.uh	r8,r7[16]
800045ec:	10 99       	mov	r9,r8
800045ee:	e2 19 ff 00 	andl	r9,0xff00,COH
800045f2:	e0 49 01 00 	cp.w	r9,256
800045f6:	c0 60       	breq	80004602 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800045f8:	0e 9c       	mov	r12,r7
800045fa:	f0 1f 00 0c 	mcall	80004628 <xnl_device_conn_reply_func+0x54>
800045fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004602:	a9 68       	lsl	r8,0x8
80004604:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004608:	48 98       	lddpc	r8,8000462c <xnl_device_conn_reply_func+0x58>
8000460a:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000460c:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004610:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004612:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004616:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004618:	30 19       	mov	r9,1
8000461a:	b0 89       	st.b	r8[0x0],r9
8000461c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004620:	00 00       	add	r0,r0
80004622:	0b 44       	ld.w	r4,--r5
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	65 70       	ld.w	r0,r2[0x5c]
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	45 74       	lddsp	r4,sp[0x15c]
8000462c:	00 00       	add	r0,r0
8000462e:	0b 4a       	ld.w	r10,--r5

80004630 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004630:	d4 01       	pushm	lr
80004632:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004636:	e0 68 40 0e 	mov	r8,16398
8000463a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000463c:	3f f8       	mov	r8,-1
8000463e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004640:	30 38       	mov	r8,3
80004642:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004644:	30 08       	mov	r8,0
80004646:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004648:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000464a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000464c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000464e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004650:	1a 9c       	mov	r12,sp
80004652:	f0 1f 00 03 	mcall	8000465c <xnl_send_device_master_query+0x2c>
}
80004656:	2c 0d       	sub	sp,-256
80004658:	d8 02       	popm	pc
8000465a:	00 00       	add	r0,r0
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	43 10       	lddsp	r0,sp[0xc4]

80004660 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004660:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004662:	48 78       	lddpc	r8,8000467c <RC522_SPI_SetSpeed+0x1c>
80004664:	70 09       	ld.w	r9,r8[0x0]
80004666:	72 ca       	ld.w	r10,r9[0x30]
80004668:	5c 7c       	castu.h	r12
8000466a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000466e:	f9 ea 10 0a 	or	r10,r12,r10
80004672:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004674:	70 0c       	ld.w	r12,r8[0x0]
80004676:	f0 1f 00 03 	mcall	80004680 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000467a:	d8 02       	popm	pc
8000467c:	00 00       	add	r0,r0
8000467e:	1d f8       	ld.ub	r8,lr[0x7]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	5a 60       	cp.w	r0,-26

80004684 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004684:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004686:	e0 6c 04 00 	mov	r12,1024
8000468a:	f0 1f 00 02 	mcall	80004690 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000468e:	d8 02       	popm	pc
80004690:	80 00       	ld.sh	r0,r0[0x0]
80004692:	46 60       	lddsp	r0,sp[0x198]

80004694 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004694:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004698:	48 b7       	lddpc	r7,800046c4 <RC522_ReadByte+0x30>
8000469a:	30 0b       	mov	r11,0
8000469c:	6e 0c       	ld.w	r12,r7[0x0]
8000469e:	f0 1f 00 0b 	mcall	800046c8 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046a2:	e0 6b 00 ff 	mov	r11,255
800046a6:	6e 0c       	ld.w	r12,r7[0x0]
800046a8:	f0 1f 00 09 	mcall	800046cc <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800046ac:	30 06       	mov	r6,0
800046ae:	0c 9b       	mov	r11,r6
800046b0:	6e 0c       	ld.w	r12,r7[0x0]
800046b2:	f0 1f 00 08 	mcall	800046d0 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046b6:	0c 9b       	mov	r11,r6
800046b8:	6e 0c       	ld.w	r12,r7[0x0]
800046ba:	f0 1f 00 07 	mcall	800046d4 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
800046be:	0d 9c       	ld.ub	r12,r6[0x1]
800046c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046c4:	00 00       	add	r0,r0
800046c6:	1d f8       	ld.ub	r8,lr[0x7]
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	5b cc       	cp.w	r12,-4
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	5a 66       	cp.w	r6,-26
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	5a 82       	cp.w	r2,-24
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	5b 8c       	cp.w	r12,-8

800046d8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800046d8:	eb cd 40 c0 	pushm	r6-r7,lr
800046dc:	20 1d       	sub	sp,4
800046de:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800046e0:	48 c7       	lddpc	r7,80004710 <RC522_WriteByte+0x38>
800046e2:	30 0b       	mov	r11,0
800046e4:	6e 0c       	ld.w	r12,r7[0x0]
800046e6:	f0 1f 00 0c 	mcall	80004714 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800046ea:	1b 8b       	ld.ub	r11,sp[0x0]
800046ec:	6e 0c       	ld.w	r12,r7[0x0]
800046ee:	f0 1f 00 0b 	mcall	80004718 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800046f2:	1a 9b       	mov	r11,sp
800046f4:	6e 0c       	ld.w	r12,r7[0x0]
800046f6:	f0 1f 00 0a 	mcall	8000471c <RC522_WriteByte+0x44>
800046fa:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046fc:	30 0b       	mov	r11,0
800046fe:	6e 0c       	ld.w	r12,r7[0x0]
80004700:	f0 1f 00 08 	mcall	80004720 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004704:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004708:	2f fd       	sub	sp,-4
8000470a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000470e:	00 00       	add	r0,r0
80004710:	00 00       	add	r0,r0
80004712:	1d f8       	ld.ub	r8,lr[0x7]
80004714:	80 00       	ld.sh	r0,r0[0x0]
80004716:	5b cc       	cp.w	r12,-4
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	5a 66       	cp.w	r6,-26
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	5a 82       	cp.w	r2,-24
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	5b 8c       	cp.w	r12,-8

80004724 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004724:	eb cd 40 c0 	pushm	r6-r7,lr
80004728:	18 96       	mov	r6,r12
8000472a:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
8000472c:	31 8c       	mov	r12,24
8000472e:	f0 1f 00 09 	mcall	80004750 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004732:	ec 0c 15 01 	lsl	r12,r6,0x1
80004736:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000473a:	f0 1f 00 07 	mcall	80004754 <WriteRawRC+0x30>
	RC522_WriteByte(value);
8000473e:	0e 9c       	mov	r12,r7
80004740:	f0 1f 00 05 	mcall	80004754 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004744:	31 8c       	mov	r12,24
80004746:	f0 1f 00 05 	mcall	80004758 <WriteRawRC+0x34>

}
8000474a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000474e:	00 00       	add	r0,r0
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	58 b0       	cp.w	r0,11
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	46 d8       	lddsp	r8,sp[0x1b4]
80004758:	80 00       	ld.sh	r0,r0[0x0]
8000475a:	58 94       	cp.w	r4,9

8000475c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000475c:	d4 01       	pushm	lr

	SET_RC522RST;
8000475e:	31 9c       	mov	r12,25
80004760:	f0 1f 00 1b 	mcall	800047cc <PcdReset+0x70>
	delay_ns(10);
80004764:	30 ac       	mov	r12,10
80004766:	f0 1f 00 1b 	mcall	800047d0 <PcdReset+0x74>

	CLR_RC522RST;
8000476a:	31 9c       	mov	r12,25
8000476c:	f0 1f 00 1a 	mcall	800047d4 <PcdReset+0x78>
	delay_ns(10);
80004770:	30 ac       	mov	r12,10
80004772:	f0 1f 00 18 	mcall	800047d0 <PcdReset+0x74>

	SET_RC522RST;
80004776:	31 9c       	mov	r12,25
80004778:	f0 1f 00 15 	mcall	800047cc <PcdReset+0x70>
	delay_ns(10);
8000477c:	30 ac       	mov	r12,10
8000477e:	f0 1f 00 15 	mcall	800047d0 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004782:	30 fb       	mov	r11,15
80004784:	30 1c       	mov	r12,1
80004786:	f0 1f 00 15 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000478a:	30 fb       	mov	r11,15
8000478c:	30 1c       	mov	r12,1
8000478e:	f0 1f 00 13 	mcall	800047d8 <PcdReset+0x7c>
	delay_ns(10);
80004792:	30 ac       	mov	r12,10
80004794:	f0 1f 00 0f 	mcall	800047d0 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004798:	33 db       	mov	r11,61
8000479a:	31 1c       	mov	r12,17
8000479c:	f0 1f 00 0f 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047a0:	31 eb       	mov	r11,30
800047a2:	32 dc       	mov	r12,45
800047a4:	f0 1f 00 0d 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800047a8:	30 0b       	mov	r11,0
800047aa:	32 cc       	mov	r12,44
800047ac:	f0 1f 00 0b 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800047b0:	e0 6b 00 8d 	mov	r11,141
800047b4:	32 ac       	mov	r12,42
800047b6:	f0 1f 00 09 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800047ba:	33 eb       	mov	r11,62
800047bc:	32 bc       	mov	r12,43
800047be:	f0 1f 00 07 	mcall	800047d8 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800047c2:	34 0b       	mov	r11,64
800047c4:	31 5c       	mov	r12,21
800047c6:	f0 1f 00 05 	mcall	800047d8 <PcdReset+0x7c>
	
	return MI_OK;
}
800047ca:	d8 0a       	popm	pc,r12=0
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	58 94       	cp.w	r4,9
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	50 1c       	stdsp	sp[0x4],r12
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	58 b0       	cp.w	r0,11
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	47 24       	lddsp	r4,sp[0x1c8]

800047dc <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800047dc:	eb cd 40 80 	pushm	r7,lr
800047e0:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800047e2:	31 8c       	mov	r12,24
800047e4:	f0 1f 00 0a 	mcall	8000480c <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800047e8:	ee 08 15 01 	lsl	r8,r7,0x1
800047ec:	10 9c       	mov	r12,r8
800047ee:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047f2:	a7 bc       	sbr	r12,0x7
800047f4:	f0 1f 00 07 	mcall	80004810 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800047f8:	f0 1f 00 07 	mcall	80004814 <ReadRawRC+0x38>
800047fc:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800047fe:	31 8c       	mov	r12,24
80004800:	f0 1f 00 06 	mcall	80004818 <ReadRawRC+0x3c>
	return ucResult;
}
80004804:	0e 9c       	mov	r12,r7
80004806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000480a:	00 00       	add	r0,r0
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	58 b0       	cp.w	r0,11
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	46 d8       	lddsp	r8,sp[0x1b4]
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	46 94       	lddsp	r4,sp[0x1a4]
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	58 94       	cp.w	r4,9

8000481c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000481c:	eb cd 40 c0 	pushm	r6-r7,lr
80004820:	18 97       	mov	r7,r12
80004822:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004824:	f0 1f 00 05 	mcall	80004838 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004828:	f9 e6 10 0b 	or	r11,r12,r6
8000482c:	5c 5b       	castu.b	r11
8000482e:	0e 9c       	mov	r12,r7
80004830:	f0 1f 00 03 	mcall	8000483c <SetBitMask+0x20>
}
80004834:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	47 dc       	lddsp	r12,sp[0x1f4]
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	47 24       	lddsp	r4,sp[0x1c8]

80004840 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004840:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004842:	31 4c       	mov	r12,20
80004844:	f0 1f 00 05 	mcall	80004858 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004848:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000484c:	c0 51       	brne	80004856 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000484e:	30 3b       	mov	r11,3
80004850:	31 4c       	mov	r12,20
80004852:	f0 1f 00 03 	mcall	8000485c <PcdAntennaOn+0x1c>
80004856:	d8 02       	popm	pc
80004858:	80 00       	ld.sh	r0,r0[0x0]
8000485a:	47 dc       	lddsp	r12,sp[0x1f4]
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	48 1c       	lddpc	r12,80004860 <ClearBitMask>

80004860 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004860:	eb cd 40 c0 	pushm	r6-r7,lr
80004864:	18 97       	mov	r7,r12
80004866:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004868:	f0 1f 00 06 	mcall	80004880 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
8000486c:	5c d6       	com	r6
8000486e:	f9 e6 00 06 	and	r6,r12,r6
80004872:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004876:	0e 9c       	mov	r12,r7
80004878:	f0 1f 00 03 	mcall	80004884 <ClearBitMask+0x24>
	
}
8000487c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	47 dc       	lddsp	r12,sp[0x1f4]
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	47 24       	lddsp	r4,sp[0x1c8]

80004888 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004888:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000488a:	30 3b       	mov	r11,3
8000488c:	31 4c       	mov	r12,20
8000488e:	f0 1f 00 02 	mcall	80004894 <PcdAntennaOff+0xc>
}
80004892:	d8 02       	popm	pc
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	48 60       	lddpc	r0,800048ac <M500PcdConfigISOType+0x14>

80004898 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004898:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000489a:	34 18       	mov	r8,65
8000489c:	f0 0c 18 00 	cp.b	r12,r8
800048a0:	c0 20       	breq	800048a4 <M500PcdConfigISOType+0xc>
800048a2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048a4:	30 8b       	mov	r11,8
800048a6:	16 9c       	mov	r12,r11
800048a8:	f0 1f 00 14 	mcall	800048f8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800048ac:	33 db       	mov	r11,61
800048ae:	31 1c       	mov	r12,17
800048b0:	f0 1f 00 13 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800048b4:	e0 6b 00 86 	mov	r11,134
800048b8:	31 7c       	mov	r12,23
800048ba:	f0 1f 00 11 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800048be:	37 fb       	mov	r11,127
800048c0:	32 6c       	mov	r12,38
800048c2:	f0 1f 00 0f 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800048c6:	31 eb       	mov	r11,30
800048c8:	32 dc       	mov	r12,45
800048ca:	f0 1f 00 0d 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800048ce:	30 0b       	mov	r11,0
800048d0:	32 cc       	mov	r12,44
800048d2:	f0 1f 00 0b 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800048d6:	e0 6b 00 8d 	mov	r11,141
800048da:	32 ac       	mov	r12,42
800048dc:	f0 1f 00 08 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800048e0:	33 eb       	mov	r11,62
800048e2:	32 bc       	mov	r12,43
800048e4:	f0 1f 00 06 	mcall	800048fc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800048e8:	e0 6c 03 e8 	mov	r12,1000
800048ec:	f0 1f 00 05 	mcall	80004900 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800048f0:	f0 1f 00 05 	mcall	80004904 <M500PcdConfigISOType+0x6c>
800048f4:	d8 0a       	popm	pc,r12=0
800048f6:	00 00       	add	r0,r0
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	48 60       	lddpc	r0,80004910 <rc522_init+0x8>
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	47 24       	lddsp	r4,sp[0x1c8]
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	50 1c       	stdsp	sp[0x4],r12
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	48 40       	lddpc	r0,80004914 <rc522_init+0xc>

80004908 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004908:	eb cd 40 c0 	pushm	r6-r7,lr
8000490c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000490e:	4a 28       	lddpc	r8,80004994 <rc522_init+0x8c>
80004910:	1a 96       	mov	r6,sp
80004912:	f0 ea 00 00 	ld.d	r10,r8[0]
80004916:	fa eb 00 00 	st.d	sp[0],r10
8000491a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000491e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004922:	30 4b       	mov	r11,4
80004924:	49 dc       	lddpc	r12,80004998 <rc522_init+0x90>
80004926:	f0 1f 00 1e 	mcall	8000499c <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000492a:	31 9c       	mov	r12,25
8000492c:	f0 1f 00 1d 	mcall	800049a0 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004930:	31 9c       	mov	r12,25
80004932:	f0 1f 00 1d 	mcall	800049a4 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004936:	49 d7       	lddpc	r7,800049a8 <rc522_init+0xa0>
80004938:	fe 7c 24 00 	mov	r12,-56320
8000493c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000493e:	1a 9b       	mov	r11,sp
80004940:	f0 1f 00 1b 	mcall	800049ac <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004944:	30 09       	mov	r9,0
80004946:	12 9a       	mov	r10,r9
80004948:	12 9b       	mov	r11,r9
8000494a:	6e 0c       	ld.w	r12,r7[0x0]
8000494c:	f0 1f 00 19 	mcall	800049b0 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004950:	6e 0c       	ld.w	r12,r7[0x0]
80004952:	f0 1f 00 19 	mcall	800049b4 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004956:	e0 6a 36 00 	mov	r10,13824
8000495a:	ea 1a 01 6e 	orh	r10,0x16e
8000495e:	1a 9b       	mov	r11,sp
80004960:	6e 0c       	ld.w	r12,r7[0x0]
80004962:	f0 1f 00 16 	mcall	800049b8 <rc522_init+0xb0>
80004966:	c0 50       	breq	80004970 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004968:	30 29       	mov	r9,2
8000496a:	49 58       	lddpc	r8,800049bc <rc522_init+0xb4>
8000496c:	b0 89       	st.b	r8[0x0],r9
8000496e:	c0 38       	rjmp	80004974 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004970:	f0 1f 00 14 	mcall	800049c0 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004974:	f0 1f 00 14 	mcall	800049c4 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004978:	f0 1f 00 14 	mcall	800049c8 <rc522_init+0xc0>
	
	delay_ms(2); 
8000497c:	30 2c       	mov	r12,2
8000497e:	f0 1f 00 14 	mcall	800049cc <rc522_init+0xc4>
	
	PcdAntennaOn();
80004982:	f0 1f 00 14 	mcall	800049d0 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004986:	34 1c       	mov	r12,65
80004988:	f0 1f 00 13 	mcall	800049d4 <rc522_init+0xcc>
	

8000498c:	2f cd       	sub	sp,-16
8000498e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004992:	00 00       	add	r0,r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	d9 74       	*unknown*
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	d9 4c       	*unknown*
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	58 4c       	cp.w	r12,4
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	58 7c       	cp.w	r12,7
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	58 94       	cp.w	r4,9
800049a8:	00 00       	add	r0,r0
800049aa:	1d f8       	ld.ub	r8,lr[0x7]
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	59 fc       	cp.w	r12,31
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	5a 34       	cp.w	r4,-29
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	5a 60       	cp.w	r0,-26
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	5a a4       	cp.w	r4,-22
800049bc:	00 00       	add	r0,r0
800049be:	0b 68       	ld.uh	r8,--r5
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	46 84       	lddsp	r4,sp[0x1a0]
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	47 5c       	lddsp	r12,sp[0x1d4]
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	48 88       	lddpc	r8,800049e8 <PcdComMF522+0x10>
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	50 5c       	stdsp	sp[0x14],r12
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	48 40       	lddpc	r0,800049e0 <PcdComMF522+0x8>
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 98       	lddpc	r8,800049f8 <PcdComMF522+0x20>

800049d8 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
800049d8:	d4 31       	pushm	r0-r7,lr
800049da:	20 1d       	sub	sp,4
800049dc:	18 92       	mov	r2,r12
800049de:	16 95       	mov	r5,r11
800049e0:	14 96       	mov	r6,r10
800049e2:	50 09       	stdsp	sp[0x0],r9
800049e4:	10 90       	mov	r0,r8
800049e6:	f8 c8 00 0c 	sub	r8,r12,12
800049ea:	5c 58       	castu.b	r8
800049ec:	30 29       	mov	r9,2
800049ee:	f2 08 18 00 	cp.b	r8,r9
800049f2:	e0 88 00 05 	brls	800049fc <PcdComMF522+0x24>
800049f6:	30 03       	mov	r3,0
800049f8:	06 91       	mov	r1,r3
800049fa:	c0 78       	rjmp	80004a08 <PcdComMF522+0x30>
800049fc:	4c f9       	lddpc	r9,80004b38 <PcdComMF522+0x160>
800049fe:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a02:	4c f9       	lddpc	r9,80004b3c <PcdComMF522+0x164>
80004a04:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a08:	02 9b       	mov	r11,r1
80004a0a:	a7 bb       	sbr	r11,0x7
80004a0c:	30 2c       	mov	r12,2
80004a0e:	f0 1f 00 4d 	mcall	80004b40 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a12:	e0 6b 00 80 	mov	r11,128
80004a16:	30 4c       	mov	r12,4
80004a18:	f0 1f 00 4b 	mcall	80004b44 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a1c:	30 0b       	mov	r11,0
80004a1e:	30 1c       	mov	r12,1
80004a20:	f0 1f 00 48 	mcall	80004b40 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a24:	e0 6b 00 80 	mov	r11,128
80004a28:	30 ac       	mov	r12,10
80004a2a:	f0 1f 00 48 	mcall	80004b48 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a2e:	58 06       	cp.w	r6,0
80004a30:	c0 c0       	breq	80004a48 <PcdComMF522+0x70>
80004a32:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a34:	30 94       	mov	r4,9
80004a36:	0f 3b       	ld.ub	r11,r7++
80004a38:	08 9c       	mov	r12,r4
80004a3a:	f0 1f 00 42 	mcall	80004b40 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a3e:	0e 98       	mov	r8,r7
80004a40:	0a 18       	sub	r8,r5
80004a42:	ec 08 19 00 	cp.h	r8,r6
80004a46:	cf 83       	brcs	80004a36 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004a48:	04 9b       	mov	r11,r2
80004a4a:	30 1c       	mov	r12,1
80004a4c:	f0 1f 00 3d 	mcall	80004b40 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004a50:	30 c8       	mov	r8,12
80004a52:	f0 02 18 00 	cp.b	r2,r8
80004a56:	c0 61       	brne	80004a62 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004a58:	e0 6b 00 80 	mov	r11,128
80004a5c:	30 dc       	mov	r12,13
80004a5e:	f0 1f 00 3b 	mcall	80004b48 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a62:	30 4c       	mov	r12,4
80004a64:	f0 1f 00 3a 	mcall	80004b4c <PcdComMF522+0x174>
80004a68:	18 97       	mov	r7,r12
80004a6a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a6e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a70:	30 44       	mov	r4,4
80004a72:	c0 88       	rjmp	80004a82 <PcdComMF522+0xaa>
80004a74:	08 9c       	mov	r12,r4
80004a76:	f0 1f 00 36 	mcall	80004b4c <PcdComMF522+0x174>
80004a7a:	18 97       	mov	r7,r12
		i--;
80004a7c:	20 16       	sub	r6,1
80004a7e:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a80:	c0 a0       	breq	80004a94 <PcdComMF522+0xbc>
80004a82:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004a86:	c4 c1       	brne	80004b1e <PcdComMF522+0x146>
80004a88:	ef e3 00 08 	and	r8,r7,r3
80004a8c:	ea 08 18 00 	cp.b	r8,r5
80004a90:	cf 20       	breq	80004a74 <PcdComMF522+0x9c>
80004a92:	c4 68       	rjmp	80004b1e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004a94:	e0 6b 00 80 	mov	r11,128
80004a98:	30 dc       	mov	r12,13
80004a9a:	f0 1f 00 2b 	mcall	80004b44 <PcdComMF522+0x16c>
80004a9e:	30 27       	mov	r7,2
80004aa0:	c3 38       	rjmp	80004b06 <PcdComMF522+0x12e>
80004aa2:	02 67       	and	r7,r1
80004aa4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004aa8:	30 c8       	mov	r8,12
80004aaa:	f0 02 18 00 	cp.b	r2,r8
80004aae:	c2 c1       	brne	80004b06 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ab0:	30 ac       	mov	r12,10
80004ab2:	f0 1f 00 27 	mcall	80004b4c <PcdComMF522+0x174>
80004ab6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004ab8:	30 cc       	mov	r12,12
80004aba:	f0 1f 00 25 	mcall	80004b4c <PcdComMF522+0x174>
80004abe:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004ac2:	c0 70       	breq	80004ad0 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004ac4:	08 98       	mov	r8,r4
80004ac6:	20 18       	sub	r8,1
80004ac8:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004acc:	a0 8c       	st.b	r0[0x0],r12
80004ace:	c0 48       	rjmp	80004ad6 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004ad0:	e8 08 15 03 	lsl	r8,r4,0x3
80004ad4:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004ad6:	58 04       	cp.w	r4,0
80004ad8:	c0 61       	brne	80004ae4 <PcdComMF522+0x10c>
80004ada:	30 14       	mov	r4,1
80004adc:	40 05       	lddsp	r5,sp[0x0]
80004ade:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ae0:	30 93       	mov	r3,9
80004ae2:	c0 98       	rjmp	80004af4 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ae4:	31 28       	mov	r8,18
80004ae6:	f0 04 18 00 	cp.b	r4,r8
80004aea:	f9 b4 0b 12 	movhi	r4,18
80004aee:	58 04       	cp.w	r4,0
80004af0:	cf 61       	brne	80004adc <PcdComMF522+0x104>
80004af2:	c0 a8       	rjmp	80004b06 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004af4:	06 9c       	mov	r12,r3
80004af6:	f0 1f 00 16 	mcall	80004b4c <PcdComMF522+0x174>
80004afa:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004afc:	ec 05 01 08 	sub	r8,r6,r5
80004b00:	e8 08 19 00 	cp.h	r8,r4
80004b04:	cf 83       	brcs	80004af4 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b06:	e0 6b 00 80 	mov	r11,128
80004b0a:	30 cc       	mov	r12,12
80004b0c:	f0 1f 00 0f 	mcall	80004b48 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b10:	30 0b       	mov	r11,0
80004b12:	30 1c       	mov	r12,1
80004b14:	f0 1f 00 0b 	mcall	80004b40 <PcdComMF522+0x168>
	return status;
}
80004b18:	0e 9c       	mov	r12,r7
80004b1a:	2f fd       	sub	sp,-4
80004b1c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b1e:	e0 6b 00 80 	mov	r11,128
80004b22:	30 dc       	mov	r12,13
80004b24:	f0 1f 00 08 	mcall	80004b44 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b28:	30 6c       	mov	r12,6
80004b2a:	f0 1f 00 09 	mcall	80004b4c <PcdComMF522+0x174>
80004b2e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b32:	cb 80       	breq	80004aa2 <PcdComMF522+0xca>
80004b34:	30 27       	mov	r7,2
80004b36:	ce 8b       	rjmp	80004b06 <PcdComMF522+0x12e>
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	d9 6c       	*unknown*
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	d9 70       	acall	0x97
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	47 24       	lddsp	r4,sp[0x1c8]
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	48 60       	lddpc	r0,80004b5c <PcdAnticoll+0xc>
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	48 1c       	lddpc	r12,80004b4c <PcdComMF522+0x174>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	47 dc       	lddsp	r12,sp[0x1f4]

80004b50 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004b50:	eb cd 40 c0 	pushm	r6-r7,lr
80004b54:	20 5d       	sub	sp,20
80004b56:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004b58:	30 8b       	mov	r11,8
80004b5a:	16 9c       	mov	r12,r11
80004b5c:	f0 1f 00 1a 	mcall	80004bc4 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004b60:	30 0b       	mov	r11,0
80004b62:	30 dc       	mov	r12,13
80004b64:	f0 1f 00 19 	mcall	80004bc8 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004b68:	e0 6b 00 80 	mov	r11,128
80004b6c:	30 ec       	mov	r12,14
80004b6e:	f0 1f 00 16 	mcall	80004bc4 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004b72:	39 38       	mov	r8,-109
80004b74:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004b76:	32 08       	mov	r8,32
80004b78:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004b7a:	1a 9b       	mov	r11,sp
80004b7c:	fa c8 ff ed 	sub	r8,sp,-19
80004b80:	1a 99       	mov	r9,sp
80004b82:	30 2a       	mov	r10,2
80004b84:	30 cc       	mov	r12,12
80004b86:	f0 1f 00 12 	mcall	80004bcc <PcdAnticoll+0x7c>
80004b8a:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004b8c:	c1 21       	brne	80004bb0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004b8e:	1b 89       	ld.ub	r9,sp[0x0]
80004b90:	ac 89       	st.b	r6[0x0],r9
80004b92:	1b 98       	ld.ub	r8,sp[0x1]
80004b94:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004b96:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004b98:	1b a8       	ld.ub	r8,sp[0x2]
80004b9a:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004b9c:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ba0:	1b b9       	ld.ub	r9,sp[0x3]
80004ba2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ba4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004ba6:	1b c9       	ld.ub	r9,sp[0x4]
80004ba8:	f0 09 18 00 	cp.b	r9,r8
80004bac:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004bb0:	e0 6b 00 80 	mov	r11,128
80004bb4:	30 ec       	mov	r12,14
80004bb6:	f0 1f 00 07 	mcall	80004bd0 <PcdAnticoll+0x80>
	return status;
}
80004bba:	0e 9c       	mov	r12,r7
80004bbc:	2f bd       	sub	sp,-20
80004bbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bc2:	00 00       	add	r0,r0
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	48 60       	lddpc	r0,80004bdc <PcdRequest+0x8>
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	47 24       	lddsp	r4,sp[0x1c8]
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	49 d8       	lddpc	r8,80004c40 <CalulateCRC+0x8>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	48 1c       	lddpc	r12,80004bd4 <PcdRequest>

80004bd4 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004bd4:	eb cd 40 c0 	pushm	r6-r7,lr
80004bd8:	20 5d       	sub	sp,20
80004bda:	18 97       	mov	r7,r12
80004bdc:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004bde:	30 8b       	mov	r11,8
80004be0:	16 9c       	mov	r12,r11
80004be2:	f0 1f 00 12 	mcall	80004c28 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004be6:	30 7b       	mov	r11,7
80004be8:	30 dc       	mov	r12,13
80004bea:	f0 1f 00 11 	mcall	80004c2c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004bee:	30 3b       	mov	r11,3
80004bf0:	31 4c       	mov	r12,20
80004bf2:	f0 1f 00 10 	mcall	80004c30 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004bf6:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004bf8:	1a 9b       	mov	r11,sp
80004bfa:	fa c8 ff ed 	sub	r8,sp,-19
80004bfe:	1a 99       	mov	r9,sp
80004c00:	30 1a       	mov	r10,1
80004c02:	30 cc       	mov	r12,12
80004c04:	f0 1f 00 0c 	mcall	80004c34 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c08:	c0 c1       	brne	80004c20 <PcdRequest+0x4c>
80004c0a:	31 08       	mov	r8,16
80004c0c:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c10:	f0 09 18 00 	cp.b	r9,r8
80004c14:	c0 61       	brne	80004c20 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c16:	1b 88       	ld.ub	r8,sp[0x0]
80004c18:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c1a:	1b 98       	ld.ub	r8,sp[0x1]
80004c1c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c1e:	c0 28       	rjmp	80004c22 <PcdRequest+0x4e>
80004c20:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c22:	2f bd       	sub	sp,-20
80004c24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	48 60       	lddpc	r0,80004c40 <CalulateCRC+0x8>
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	47 24       	lddsp	r4,sp[0x1c8]
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	48 1c       	lddpc	r12,80004c34 <PcdRequest+0x60>
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	49 d8       	lddpc	r8,80004ca8 <CalulateCRC+0x70>

80004c38 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c38:	eb cd 40 f8 	pushm	r3-r7,lr
80004c3c:	18 95       	mov	r5,r12
80004c3e:	16 96       	mov	r6,r11
80004c40:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c42:	30 4b       	mov	r11,4
80004c44:	30 5c       	mov	r12,5
80004c46:	f0 1f 00 1c 	mcall	80004cb4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c4a:	30 0b       	mov	r11,0
80004c4c:	30 1c       	mov	r12,1
80004c4e:	f0 1f 00 1b 	mcall	80004cb8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004c52:	e0 6b 00 80 	mov	r11,128
80004c56:	30 ac       	mov	r12,10
80004c58:	f0 1f 00 19 	mcall	80004cbc <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004c5c:	58 06       	cp.w	r6,0
80004c5e:	c0 c0       	breq	80004c76 <CalulateCRC+0x3e>
80004c60:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004c62:	30 94       	mov	r4,9
80004c64:	0f 3b       	ld.ub	r11,r7++
80004c66:	08 9c       	mov	r12,r4
80004c68:	f0 1f 00 14 	mcall	80004cb8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004c6c:	0e 98       	mov	r8,r7
80004c6e:	0a 18       	sub	r8,r5
80004c70:	ec 08 18 00 	cp.b	r8,r6
80004c74:	cf 83       	brcs	80004c64 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004c76:	30 3b       	mov	r11,3
80004c78:	30 1c       	mov	r12,1
80004c7a:	f0 1f 00 10 	mcall	80004cb8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004c7e:	30 5c       	mov	r12,5
80004c80:	f0 1f 00 10 	mcall	80004cc0 <CalulateCRC+0x88>
80004c84:	e0 67 00 fe 	mov	r7,254
80004c88:	30 56       	mov	r6,5
80004c8a:	c0 78       	rjmp	80004c98 <CalulateCRC+0x60>
80004c8c:	0c 9c       	mov	r12,r6
80004c8e:	f0 1f 00 0d 	mcall	80004cc0 <CalulateCRC+0x88>
		i--;
80004c92:	20 17       	sub	r7,1
80004c94:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004c96:	c0 40       	breq	80004c9e <CalulateCRC+0x66>
80004c98:	e2 1c 00 04 	andl	r12,0x4,COH
80004c9c:	cf 80       	breq	80004c8c <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004c9e:	32 2c       	mov	r12,34
80004ca0:	f0 1f 00 08 	mcall	80004cc0 <CalulateCRC+0x88>
80004ca4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ca6:	32 1c       	mov	r12,33
80004ca8:	f0 1f 00 06 	mcall	80004cc0 <CalulateCRC+0x88>
80004cac:	a6 9c       	st.b	r3[0x1],r12
}
80004cae:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004cb2:	00 00       	add	r0,r0
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	48 60       	lddpc	r0,80004ccc <PcdSelect+0x8>
80004cb8:	80 00       	ld.sh	r0,r0[0x0]
80004cba:	47 24       	lddsp	r4,sp[0x1c8]
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	48 1c       	lddpc	r12,80004cc0 <CalulateCRC+0x88>
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	47 dc       	lddsp	r12,sp[0x1f4]

80004cc4 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004cc4:	eb cd 40 80 	pushm	r7,lr
80004cc8:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cca:	39 38       	mov	r8,-109
80004ccc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004cce:	37 08       	mov	r8,112
80004cd0:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004cd2:	30 08       	mov	r8,0
80004cd4:	ba e8       	st.b	sp[0x6],r8
80004cd6:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004cda:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004cde:	19 89       	ld.ub	r9,r12[0x0]
80004ce0:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004ce2:	19 3a       	ld.ub	r10,r12++
80004ce4:	1b e9       	ld.ub	r9,sp[0x6]
80004ce6:	f5 e9 20 09 	eor	r9,r10,r9
80004cea:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004cec:	16 38       	cp.w	r8,r11
80004cee:	cf 81       	brne	80004cde <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004cf0:	1a 97       	mov	r7,sp
80004cf2:	fa ca ff f9 	sub	r10,sp,-7
80004cf6:	30 7b       	mov	r11,7
80004cf8:	1a 9c       	mov	r12,sp
80004cfa:	f0 1f 00 0d 	mcall	80004d2c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004cfe:	30 8b       	mov	r11,8
80004d00:	16 9c       	mov	r12,r11
80004d02:	f0 1f 00 0c 	mcall	80004d30 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d06:	fa c8 ff ed 	sub	r8,sp,-19
80004d0a:	1a 99       	mov	r9,sp
80004d0c:	30 9a       	mov	r10,9
80004d0e:	1a 9b       	mov	r11,sp
80004d10:	30 cc       	mov	r12,12
80004d12:	f0 1f 00 09 	mcall	80004d34 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d16:	c0 71       	brne	80004d24 <PcdSelect+0x60>
80004d18:	31 88       	mov	r8,24
80004d1a:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d1e:	f0 09 18 00 	cp.b	r9,r8
80004d22:	c0 20       	breq	80004d26 <PcdSelect+0x62>
80004d24:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d26:	2f bd       	sub	sp,-20
80004d28:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	4c 38       	lddpc	r8,80004e38 <rfid_auto_reader+0x100>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	48 60       	lddpc	r0,80004d48 <rfid_auto_reader+0x10>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	49 d8       	lddpc	r8,80004da8 <rfid_auto_reader+0x70>

80004d38 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d38:	eb cd 40 c0 	pushm	r6-r7,lr
80004d3c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d3e:	f0 1f 00 37 	mcall	80004e18 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d42:	4b 7b       	lddpc	r11,80004e1c <rfid_auto_reader+0xe4>
80004d44:	35 2c       	mov	r12,82
80004d46:	f0 1f 00 37 	mcall	80004e20 <rfid_auto_reader+0xe8>
80004d4a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004d4c:	c6 31       	brne	80004e12 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d4e:	4b 48       	lddpc	r8,80004e1c <rfid_auto_reader+0xe4>
80004d50:	11 88       	ld.ub	r8,r8[0x0]
80004d52:	30 49       	mov	r9,4
80004d54:	f2 08 18 00 	cp.b	r8,r9
80004d58:	c0 b1       	brne	80004d6e <rfid_auto_reader+0x36>
80004d5a:	4b 19       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d5c:	13 9a       	ld.ub	r10,r9[0x1]
80004d5e:	30 09       	mov	r9,0
80004d60:	f2 0a 18 00 	cp.b	r10,r9
80004d64:	c0 51       	brne	80004d6e <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004d66:	4b 0c       	lddpc	r12,80004e24 <rfid_auto_reader+0xec>
80004d68:	f0 1f 00 30 	mcall	80004e28 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d6c:	c3 c8       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d6e:	30 29       	mov	r9,2
80004d70:	f2 08 18 00 	cp.b	r8,r9
80004d74:	c0 b1       	brne	80004d8a <rfid_auto_reader+0x52>
80004d76:	4a a9       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d78:	13 9a       	ld.ub	r10,r9[0x1]
80004d7a:	30 09       	mov	r9,0
80004d7c:	f2 0a 18 00 	cp.b	r10,r9
80004d80:	c0 51       	brne	80004d8a <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004d82:	4a bc       	lddpc	r12,80004e2c <rfid_auto_reader+0xf4>
80004d84:	f0 1f 00 29 	mcall	80004e28 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d88:	c2 e8       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004d8a:	34 49       	mov	r9,68
80004d8c:	f2 08 18 00 	cp.b	r8,r9
80004d90:	c0 b1       	brne	80004da6 <rfid_auto_reader+0x6e>
80004d92:	4a 39       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d94:	13 9a       	ld.ub	r10,r9[0x1]
80004d96:	30 09       	mov	r9,0
80004d98:	f2 0a 18 00 	cp.b	r10,r9
80004d9c:	c0 51       	brne	80004da6 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004d9e:	4a 5c       	lddpc	r12,80004e30 <rfid_auto_reader+0xf8>
80004da0:	f0 1f 00 22 	mcall	80004e28 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004da4:	c2 08       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004da6:	30 89       	mov	r9,8
80004da8:	f2 08 18 00 	cp.b	r8,r9
80004dac:	c0 b1       	brne	80004dc2 <rfid_auto_reader+0x8a>
80004dae:	49 c9       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004db0:	13 9a       	ld.ub	r10,r9[0x1]
80004db2:	30 09       	mov	r9,0
80004db4:	f2 0a 18 00 	cp.b	r10,r9
80004db8:	c0 51       	brne	80004dc2 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004dba:	49 fc       	lddpc	r12,80004e34 <rfid_auto_reader+0xfc>
80004dbc:	f0 1f 00 1b 	mcall	80004e28 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dc0:	c1 28       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004dc2:	34 49       	mov	r9,68
80004dc4:	f2 08 18 00 	cp.b	r8,r9
80004dc8:	c0 b1       	brne	80004dde <rfid_auto_reader+0xa6>
80004dca:	49 58       	lddpc	r8,80004e1c <rfid_auto_reader+0xe4>
80004dcc:	11 99       	ld.ub	r9,r8[0x1]
80004dce:	30 38       	mov	r8,3
80004dd0:	f0 09 18 00 	cp.b	r9,r8
80004dd4:	c0 51       	brne	80004dde <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004dd6:	49 9c       	lddpc	r12,80004e38 <rfid_auto_reader+0x100>
80004dd8:	f0 1f 00 14 	mcall	80004e28 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ddc:	c0 48       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004dde:	49 8c       	lddpc	r12,80004e3c <rfid_auto_reader+0x104>
80004de0:	f0 1f 00 12 	mcall	80004e28 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004de4:	49 7c       	lddpc	r12,80004e40 <rfid_auto_reader+0x108>
80004de6:	f0 1f 00 18 	mcall	80004e44 <rfid_auto_reader+0x10c>
80004dea:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004dec:	c0 60       	breq	80004df8 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004dee:	37 8b       	mov	r11,120
80004df0:	30 1c       	mov	r12,1
80004df2:	f0 1f 00 16 	mcall	80004e48 <rfid_auto_reader+0x110>
		return status;
80004df6:	c0 e8       	rjmp	80004e12 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004df8:	49 2c       	lddpc	r12,80004e40 <rfid_auto_reader+0x108>
80004dfa:	f0 1f 00 15 	mcall	80004e4c <rfid_auto_reader+0x114>
80004dfe:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004e00:	c0 91       	brne	80004e12 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e02:	30 4a       	mov	r10,4
80004e04:	48 fb       	lddpc	r11,80004e40 <rfid_auto_reader+0x108>
80004e06:	0c 9c       	mov	r12,r6
80004e08:	f0 1f 00 12 	mcall	80004e50 <rfid_auto_reader+0x118>
		log("select okay\n");
80004e0c:	49 2c       	lddpc	r12,80004e54 <rfid_auto_reader+0x11c>
80004e0e:	f0 1f 00 07 	mcall	80004e28 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004e12:	0e 9c       	mov	r12,r7
80004e14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	47 5c       	lddsp	r12,sp[0x1d4]
80004e1c:	00 00       	add	r0,r0
80004e1e:	51 80       	stdsp	sp[0x60],r0
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4b d4       	lddpc	r4,80004f14 <rfid_sendID_message+0xbc>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	d9 84       	*unknown*
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	71 50       	ld.w	r0,r8[0x54]
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	d9 90       	acall	0x99
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	d9 9c       	*unknown*
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	d9 ac       	*unknown*
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	d9 b4       	*unknown*
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	d9 c0       	acall	0x9c
80004e40:	00 00       	add	r0,r0
80004e42:	51 84       	stdsp	sp[0x60],r4
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	4b 50       	lddpc	r0,80004f18 <rfid_sendID_message+0xc0>
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	3e 84       	mov	r4,-24
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4c c4       	lddpc	r4,80004f7c <rfid_sendID_message+0x124>
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	79 f6       	ld.w	r6,r12[0x7c]
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	d9 cc       	*unknown*

80004e58 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80004e58:	eb cd 40 e0 	pushm	r5-r7,lr
80004e5c:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004e5e:	fa ca ff a4 	sub	r10,sp,-92
80004e62:	30 08       	mov	r8,0
80004e64:	30 09       	mov	r9,0
80004e66:	f4 e9 00 00 	st.d	r10[0],r8
80004e6a:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80004e6e:	fa cc ff 94 	sub	r12,sp,-108
80004e72:	f8 e9 00 00 	st.d	r12[0],r8
80004e76:	30 0a       	mov	r10,0
80004e78:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004e7a:	fa e9 00 0c 	st.d	sp[12],r8
80004e7e:	fa e9 00 14 	st.d	sp[20],r8
80004e82:	fa e9 00 1c 	st.d	sp[28],r8
80004e86:	fa e9 00 24 	st.d	sp[36],r8
80004e8a:	fa e9 00 2c 	st.d	sp[44],r8
80004e8e:	fa e9 00 34 	st.d	sp[52],r8
80004e92:	fa e9 00 3c 	st.d	sp[60],r8
80004e96:	fa e9 00 44 	st.d	sp[68],r8
80004e9a:	fa e9 00 4c 	st.d	sp[76],r8
80004e9e:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
80004ea2:	f0 1f 00 3f 	mcall	80004f9c <rfid_sendID_message+0x144>
80004ea6:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ea8:	c6 e1       	brne	80004f84 <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004eaa:	fb 38 00 6f 	ld.ub	r8,sp[111]
80004eae:	1a d8       	st.w	--sp,r8
80004eb0:	fb 38 00 72 	ld.ub	r8,sp[114]
80004eb4:	1a d8       	st.w	--sp,r8
80004eb6:	fb 38 00 75 	ld.ub	r8,sp[117]
80004eba:	1a d8       	st.w	--sp,r8
80004ebc:	fb 38 00 78 	ld.ub	r8,sp[120]
80004ec0:	1a d8       	st.w	--sp,r8
80004ec2:	4b 8c       	lddpc	r12,80004fa0 <rfid_sendID_message+0x148>
80004ec4:	f0 1f 00 38 	mcall	80004fa4 <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80004ec8:	37 7b       	mov	r11,119
80004eca:	30 1c       	mov	r12,1
80004ecc:	f0 1f 00 37 	mcall	80004fa8 <rfid_sendID_message+0x150>
80004ed0:	fa c9 ff 84 	sub	r9,sp,-124
80004ed4:	fa c8 ff 94 	sub	r8,sp,-108
80004ed8:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80004edc:	fa c5 ff 80 	sub	r5,sp,-128
80004ee0:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004ee2:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80004ee4:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004ee6:	13 8b       	ld.ub	r11,r9[0x0]
80004ee8:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004eec:	fc 0c 18 00 	cp.b	r12,lr
80004ef0:	f7 bc 08 d0 	subls	r12,-48
80004ef4:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80004ef8:	f7 bc 0b a9 	subhi	r12,-87
80004efc:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
80004f00:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f02:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80004f06:	fc 0b 18 00 	cp.b	r11,lr
80004f0a:	f7 bb 08 d0 	subls	r11,-48
80004f0e:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80004f12:	f7 bb 0b a9 	subhi	r11,-87
80004f16:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80004f1a:	b0 b6       	st.b	r8[0x3],r6
80004f1c:	2f f9       	sub	r9,-1
80004f1e:	2f c8       	sub	r8,-4
80004f20:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f22:	0a 39       	cp.w	r9,r5
80004f24:	ce 11       	brne	80004ee6 <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f26:	4a 28       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f28:	11 89       	ld.ub	r9,r8[0x0]
80004f2a:	39 f8       	mov	r8,-97
80004f2c:	f0 09 18 00 	cp.b	r9,r8
80004f30:	e0 88 00 05 	brls	80004f3a <rfid_sendID_message+0xe2>
80004f34:	38 09       	mov	r9,-128
80004f36:	49 e8       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f38:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f3a:	49 d8       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f3c:	11 86       	ld.ub	r6,r8[0x0]
80004f3e:	2f f6       	sub	r6,-1
80004f40:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f42:	30 5a       	mov	r10,5
80004f44:	49 bb       	lddpc	r11,80004fb0 <rfid_sendID_message+0x158>
80004f46:	fa cc ff f9 	sub	r12,sp,-7
80004f4a:	f0 1f 00 1b 	mcall	80004fb4 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f4e:	31 88       	mov	r8,24
80004f50:	ba 18       	st.h	sp[0x2],r8
80004f52:	ba e6       	st.b	sp[0x6],r6
80004f54:	fe 78 e0 00 	mov	r8,-8192
80004f58:	ba 28       	st.h	sp[0x4],r8
80004f5a:	fa c6 ff f4 	sub	r6,sp,-12
80004f5e:	30 aa       	mov	r10,10
80004f60:	fa cb ff fe 	sub	r11,sp,-2
80004f64:	0c 9c       	mov	r12,r6
80004f66:	f0 1f 00 14 	mcall	80004fb4 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80004f6a:	31 0a       	mov	r10,16
80004f6c:	fa cb ff a4 	sub	r11,sp,-92
80004f70:	fa cc ff ea 	sub	r12,sp,-22
80004f74:	f0 1f 00 10 	mcall	80004fb4 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80004f78:	30 9a       	mov	r10,9
80004f7a:	31 ab       	mov	r11,26
80004f7c:	0c 9c       	mov	r12,r6
80004f7e:	f0 1f 00 0f 	mcall	80004fb8 <rfid_sendID_message+0x160>
80004f82:	c0 88       	rjmp	80004f92 <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80004f84:	37 8b       	mov	r11,120
80004f86:	30 1c       	mov	r12,1
80004f88:	f0 1f 00 08 	mcall	80004fa8 <rfid_sendID_message+0x150>
		log("no card find...\n");
80004f8c:	48 cc       	lddpc	r12,80004fbc <rfid_sendID_message+0x164>
80004f8e:	f0 1f 00 06 	mcall	80004fa4 <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
80004f92:	0e 9c       	mov	r12,r7
80004f94:	2e 2d       	sub	sp,-120
80004f96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004f9a:	00 00       	add	r0,r0
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	4d 38       	lddpc	r8,800050e8 <xg_flashc_init+0x38>
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	d9 dc       	*unknown*
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	71 50       	ld.w	r0,r8[0x54]
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	3e 84       	mov	r4,-24
80004fac:	00 00       	add	r0,r0
80004fae:	05 2c       	ld.uh	r12,r2++
80004fb0:	00 00       	add	r0,r0
80004fb2:	05 24       	ld.uh	r4,r2++
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	79 f6       	ld.w	r6,r12[0x7c]
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	3d 4c       	mov	r12,-44
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	d9 f8       	*unknown*

80004fc0 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004fc0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004fc2:	f0 1f 00 02 	mcall	80004fc8 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80004fc6:	d8 02       	popm	pc
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	49 08       	lddpc	r8,80005008 <local_start_pll0+0x3c>

80004fcc <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004fcc:	fe 78 0c 00 	mov	r8,-62464
80004fd0:	e0 69 03 07 	mov	r9,775
80004fd4:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004fd6:	30 49       	mov	r9,4
80004fd8:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004fda:	71 59       	ld.w	r9,r8[0x54]
80004fdc:	e2 19 00 80 	andl	r9,0x80,COH
80004fe0:	cf d0       	breq	80004fda <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004fe2:	fe 78 0c 00 	mov	r8,-62464
80004fe6:	30 59       	mov	r9,5
80004fe8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004fea:	e0 69 01 0d 	mov	r9,269
80004fee:	ea 19 10 07 	orh	r9,0x1007
80004ff2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004ff4:	71 59       	ld.w	r9,r8[0x54]
80004ff6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004ffa:	cf d0       	breq	80004ff4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004ffc:	fe 78 0c 00 	mov	r8,-62464
80005000:	fc 19 00 80 	movh	r9,0x80
80005004:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005006:	34 0a       	mov	r10,64
80005008:	fe 69 14 00 	mov	r9,-125952
8000500c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000500e:	30 69       	mov	r9,6
80005010:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005012:	30 19       	mov	r9,1
80005014:	fe 68 10 00 	mov	r8,-126976
80005018:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
8000501a:	5e fc       	retal	r12

8000501c <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000501c:	58 0c       	cp.w	r12,0
8000501e:	5e 0c       	reteq	r12
80005020:	30 08       	mov	r8,0
	{
		nop();
80005022:	d7 03       	nop
		nop();
80005024:	d7 03       	nop
		nop();
80005026:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005028:	2f f8       	sub	r8,-1
8000502a:	10 3c       	cp.w	r12,r8
8000502c:	fe 9b ff fb 	brhi	80005022 <delay_ns+0x6>
80005030:	5e fc       	retal	r12
80005032:	d7 03       	nop

80005034 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005034:	eb cd 40 e0 	pushm	r5-r7,lr
80005038:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000503a:	58 0c       	cp.w	r12,0
8000503c:	c0 b0       	breq	80005052 <delay_us+0x1e>
8000503e:	30 07       	mov	r7,0
		delay_ns(1000);
80005040:	e0 65 03 e8 	mov	r5,1000
80005044:	0a 9c       	mov	r12,r5
80005046:	f0 1f 00 05 	mcall	80005058 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000504a:	2f f7       	sub	r7,-1
8000504c:	0e 36       	cp.w	r6,r7
8000504e:	fe 9b ff fb 	brhi	80005044 <delay_us+0x10>
80005052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005056:	00 00       	add	r0,r0
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	50 1c       	stdsp	sp[0x4],r12

8000505c <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
8000505c:	eb cd 40 e0 	pushm	r5-r7,lr
80005060:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005062:	58 0c       	cp.w	r12,0
80005064:	c0 b0       	breq	8000507a <delay_ms+0x1e>
80005066:	30 07       	mov	r7,0
		delay_us(1000);
80005068:	e0 65 03 e8 	mov	r5,1000
8000506c:	0a 9c       	mov	r12,r5
8000506e:	f0 1f 00 05 	mcall	80005080 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005072:	2f f7       	sub	r7,-1
80005074:	0e 36       	cp.w	r6,r7
80005076:	fe 9b ff fb 	brhi	8000506c <delay_ms+0x10>
8000507a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000507e:	00 00       	add	r0,r0
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	50 34       	stdsp	sp[0xc],r4

80005084 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005084:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005086:	30 3b       	mov	r11,3
80005088:	48 8c       	lddpc	r12,800050a8 <local_start_timer+0x24>
8000508a:	f0 1f 00 09 	mcall	800050ac <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000508e:	fe 78 38 00 	mov	r8,-51200
80005092:	e0 69 91 0d 	mov	r9,37133
80005096:	ea 19 00 52 	orh	r9,0x52
8000509a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000509c:	32 09       	mov	r9,32
8000509e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050a0:	30 59       	mov	r9,5
800050a2:	91 09       	st.w	r8[0x0],r9
}
800050a4:	d8 02       	popm	pc
800050a6:	00 00       	add	r0,r0
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	da 0c       	*unknown*
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	58 4c       	cp.w	r12,4

800050b0 <xg_flashc_init>:



U8 Current_total_message_counter[2] = {0};
void xg_flashc_init(void)
{
800050b0:	d4 31       	pushm	r0-r7,lr
800050b2:	20 1d       	sub	sp,4
	
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
800050b4:	30 0a       	mov	r10,0
800050b6:	30 0b       	mov	r11,0
800050b8:	fe f8 02 28 	ld.w	r8,pc[552]
800050bc:	b1 2a       	st.d	r8++,r10
800050be:	b1 2a       	st.d	r8++,r10
800050c0:	b1 2a       	st.d	r8++,r10
800050c2:	b1 2a       	st.d	r8++,r10
800050c4:	b1 2a       	st.d	r8++,r10
800050c6:	b1 2a       	st.d	r8++,r10
800050c8:	b1 2a       	st.d	r8++,r10
800050ca:	b1 2a       	st.d	r8++,r10
800050cc:	b1 2a       	st.d	r8++,r10
800050ce:	f0 eb 00 00 	st.d	r8[0],r10
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
800050d2:	fe f7 02 0e 	ld.w	r7,pc[526]
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					memset(str, 0x00, sizeof(str));	
800050d6:	ee c6 ff f8 	sub	r6,r7,-8
800050da:	ec c5 ff f8 	sub	r5,r6,-8
800050de:	ea c4 ff f8 	sub	r4,r5,-8
800050e2:	e8 c3 ff f8 	sub	r3,r4,-8
800050e6:	e6 c2 ff f8 	sub	r2,r3,-8
800050ea:	e4 c1 ff f8 	sub	r1,r2,-8
800050ee:	e2 c0 ff f8 	sub	r0,r1,-8
800050f2:	e0 c9 ff f8 	sub	r9,r0,-8
800050f6:	50 09       	stdsp	sp[0x0],r9
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
800050f8:	30 19       	mov	r9,1
800050fa:	30 7a       	mov	r10,7
800050fc:	e0 6b b0 00 	mov	r11,45056
80005100:	ea 1b 80 04 	orh	r11,0x8004
80005104:	0e 9c       	mov	r12,r7
80005106:	f0 1f 00 78 	mcall	800052e4 <xg_flashc_init+0x234>
	flashc_memcpy((void *)LABEL_ADDRESS, (void *)LABEL_ADDRESS, LABEL_LENGTH,  false);//为了获取当前页号码
8000510a:	30 09       	mov	r9,0
8000510c:	30 7a       	mov	r10,7
8000510e:	e0 6b b0 00 	mov	r11,45056
80005112:	ea 1b 80 04 	orh	r11,0x8004
80005116:	16 9c       	mov	r12,r11
80005118:	f0 1f 00 73 	mcall	800052e4 <xg_flashc_init+0x234>
	current_page_number = flashc_get_page_number();
8000511c:	f0 1f 00 73 	mcall	800052e8 <xg_flashc_init+0x238>
80005120:	4f 38       	lddpc	r8,800052ec <xg_flashc_init+0x23c>
80005122:	91 0c       	st.w	r8[0x0],r12
	if (flashc_is_lock_error() || flashc_is_programming_error())
80005124:	f0 1f 00 73 	mcall	800052f0 <xg_flashc_init+0x240>
80005128:	e0 81 00 d2 	brne	800052cc <xg_flashc_init+0x21c>
8000512c:	f0 1f 00 72 	mcall	800052f4 <xg_flashc_init+0x244>
80005130:	e0 81 00 ce 	brne	800052cc <xg_flashc_init+0x21c>
	{
		return false;
	}
	else
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005134:	30 7a       	mov	r10,7
80005136:	0e 9b       	mov	r11,r7
80005138:	4f 0c       	lddpc	r12,800052f8 <xg_flashc_init+0x248>
8000513a:	f0 1f 00 71 	mcall	800052fc <xg_flashc_init+0x24c>
8000513e:	c3 b0       	breq	800051b4 <xg_flashc_init+0x104>
80005140:	cb 88       	rjmp	800052b0 <xg_flashc_init+0x200>
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
80005142:	6c 0c       	ld.w	r12,r6[0x0]
80005144:	ee 0c 00 0c 	add	r12,r7,r12
80005148:	8d 0c       	st.w	r6[0x0],r12
				flashc_erase_page(current_page_number, true);
8000514a:	0a 9b       	mov	r11,r5
8000514c:	f0 1f 00 6d 	mcall	80005300 <xg_flashc_init+0x250>
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
80005150:	2f f7       	sub	r7,-1
80005152:	59 97       	cp.w	r7,25
80005154:	cf 71       	brne	80005142 <xg_flashc_init+0x92>
			{
				current_page_number+=i;
				flashc_erase_page(current_page_number, true);
			}
			//set label
			flashc_memcpy((void *)LABEL_ADDRESS, (void *)XGFlashLabel, LABEL_LENGTH,  true);
80005156:	30 19       	mov	r9,1
80005158:	30 7a       	mov	r10,7
8000515a:	4e 8b       	lddpc	r11,800052f8 <xg_flashc_init+0x248>
8000515c:	e0 6c b0 00 	mov	r12,45056
80005160:	ea 1c 80 04 	orh	r12,0x8004
80005164:	f0 1f 00 60 	mcall	800052e4 <xg_flashc_init+0x234>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005168:	4d eb       	lddpc	r11,800052e0 <xg_flashc_init+0x230>
8000516a:	30 06       	mov	r6,0
8000516c:	30 07       	mov	r7,0
8000516e:	16 98       	mov	r8,r11
80005170:	b1 26       	st.d	r8++,r6
80005172:	b1 26       	st.d	r8++,r6
80005174:	b1 26       	st.d	r8++,r6
80005176:	b1 26       	st.d	r8++,r6
80005178:	b1 26       	st.d	r8++,r6
8000517a:	b1 26       	st.d	r8++,r6
8000517c:	b1 26       	st.d	r8++,r6
8000517e:	b1 26       	st.d	r8++,r6
80005180:	b1 26       	st.d	r8++,r6
80005182:	f0 e7 00 00 	st.d	r8[0],r6
			
			flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)str, MESSAGE_NUMBERS_LENGTH,  true);
80005186:	30 19       	mov	r9,1
80005188:	30 2a       	mov	r10,2
8000518a:	e0 6c b0 07 	mov	r12,45063
8000518e:	ea 1c 80 04 	orh	r12,0x8004
80005192:	f0 1f 00 55 	mcall	800052e4 <xg_flashc_init+0x234>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005196:	f0 1f 00 57 	mcall	800052f0 <xg_flashc_init+0x240>
8000519a:	e0 81 00 99 	brne	800052cc <xg_flashc_init+0x21c>
8000519e:	f0 1f 00 56 	mcall	800052f4 <xg_flashc_init+0x244>
800051a2:	e0 81 00 95 	brne	800052cc <xg_flashc_init+0x21c>
			{
				return false;
			}
			current_message_index = 0;
800051a6:	30 09       	mov	r9,0
800051a8:	4d 78       	lddpc	r8,80005304 <xg_flashc_init+0x254>
800051aa:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
800051ac:	4d 7c       	lddpc	r12,80005308 <xg_flashc_init+0x258>
800051ae:	f0 1f 00 58 	mcall	8000530c <xg_flashc_init+0x25c>
800051b2:	c8 68       	rjmp	800052be <xg_flashc_init+0x20e>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
800051b4:	1a d7       	st.w	--sp,r7
800051b6:	4d 7c       	lddpc	r12,80005310 <xg_flashc_init+0x260>
800051b8:	f0 1f 00 55 	mcall	8000530c <xg_flashc_init+0x25c>
			//Get the current voice index		
			flashc_memcpy((void *)&current_message_index, (void *)MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH,  false);
800051bc:	30 09       	mov	r9,0
800051be:	30 2a       	mov	r10,2
800051c0:	e0 6b b0 07 	mov	r11,45063
800051c4:	ea 1b 80 04 	orh	r11,0x8004
800051c8:	4c fc       	lddpc	r12,80005304 <xg_flashc_init+0x254>
800051ca:	f0 1f 00 47 	mcall	800052e4 <xg_flashc_init+0x234>
			if (flashc_is_lock_error() || flashc_is_programming_error())
800051ce:	f0 1f 00 49 	mcall	800052f0 <xg_flashc_init+0x240>
800051d2:	2f fd       	sub	sp,-4
800051d4:	58 0c       	cp.w	r12,0
800051d6:	e0 81 00 7b 	brne	800052cc <xg_flashc_init+0x21c>
800051da:	f0 1f 00 47 	mcall	800052f4 <xg_flashc_init+0x244>
800051de:	c7 71       	brne	800052cc <xg_flashc_init+0x21c>
				return false;
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
800051e0:	4c 98       	lddpc	r8,80005304 <xg_flashc_init+0x254>
800051e2:	90 09       	ld.sh	r9,r8[0x0]
800051e4:	30 08       	mov	r8,0
800051e6:	f0 09 19 00 	cp.h	r9,r8
800051ea:	c6 70       	breq	800052b8 <xg_flashc_init+0x208>
					memset(str, 0x00, sizeof(str));	
800051ec:	30 08       	mov	r8,0
800051ee:	30 09       	mov	r9,0
800051f0:	ee e9 00 00 	st.d	r7[0],r8
800051f4:	ec e9 00 00 	st.d	r6[0],r8
800051f8:	ea e9 00 00 	st.d	r5[0],r8
800051fc:	e8 e9 00 00 	st.d	r4[0],r8
80005200:	e6 e9 00 00 	st.d	r3[0],r8
80005204:	e4 e9 00 00 	st.d	r2[0],r8
80005208:	e2 e9 00 00 	st.d	r1[0],r8
8000520c:	e0 e9 00 00 	st.d	r0[0],r8
80005210:	40 0a       	lddsp	r10,sp[0x0]
80005212:	b5 28       	st.d	r10++,r8
80005214:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
					flashc_memcpy((void *)str, (void *)address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
80005218:	4b b8       	lddpc	r8,80005304 <xg_flashc_init+0x254>
8000521a:	90 8b       	ld.uh	r11,r8[0x0]
8000521c:	20 1b       	sub	r11,1
8000521e:	30 09       	mov	r9,0
80005220:	30 8a       	mov	r10,8
80005222:	e0 68 b0 09 	mov	r8,45065
80005226:	ea 18 80 04 	orh	r8,0x8004
8000522a:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
8000522e:	0e 9c       	mov	r12,r7
80005230:	f0 1f 00 2d 	mcall	800052e4 <xg_flashc_init+0x234>
					if (flashc_is_lock_error() || flashc_is_programming_error())
80005234:	f0 1f 00 2f 	mcall	800052f0 <xg_flashc_init+0x240>
80005238:	c0 41       	brne	80005240 <xg_flashc_init+0x190>
8000523a:	f0 1f 00 2f 	mcall	800052f4 <xg_flashc_init+0x244>
8000523e:	c0 50       	breq	80005248 <xg_flashc_init+0x198>
					{
						log("\r\n----voice storage is err!!!----\r\n");
80005240:	4b 5c       	lddpc	r12,80005314 <xg_flashc_init+0x264>
80005242:	f0 1f 00 33 	mcall	8000530c <xg_flashc_init+0x25c>
80005246:	c3 58       	rjmp	800052b0 <xg_flashc_init+0x200>
						goto ERASE;
					}
					else
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005248:	0f 89       	ld.ub	r9,r7[0x0]
8000524a:	0f 98       	ld.ub	r8,r7[0x1]
8000524c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005250:	4a d9       	lddpc	r9,80005304 <xg_flashc_init+0x254>
80005252:	92 09       	ld.sh	r9,r9[0x0]
80005254:	f0 09 19 00 	cp.h	r9,r8
80005258:	c2 91       	brne	800052aa <xg_flashc_init+0x1fa>
						{
							current_save_message_offset = ptr->address + ptr->offset;
8000525a:	0f e9       	ld.ub	r9,r7[0x6]
8000525c:	0f f8       	ld.ub	r8,r7[0x7]
8000525e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005262:	0f aa       	ld.ub	r10,r7[0x2]
80005264:	0f b8       	ld.ub	r8,r7[0x3]
80005266:	b1 68       	lsl	r8,0x10
80005268:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000526c:	0f ca       	ld.ub	r10,r7[0x4]
8000526e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005272:	0f da       	ld.ub	r10,r7[0x5]
80005274:	f5 e8 10 08 	or	r8,r10,r8
80005278:	f2 08 00 08 	add	r8,r9,r8
8000527c:	4a 79       	lddpc	r9,80005318 <xg_flashc_init+0x268>
8000527e:	93 08       	st.w	r9[0x0],r8
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005280:	e0 69 f0 00 	mov	r9,61440
80005284:	ea 19 80 05 	orh	r9,0x8005
80005288:	12 38       	cp.w	r8,r9
8000528a:	e0 88 00 17 	brls	800052b8 <xg_flashc_init+0x208>
										
								log("\r\n----voice storage is full!!!----\r\n");
8000528e:	4a 4c       	lddpc	r12,8000531c <xg_flashc_init+0x26c>
80005290:	f0 1f 00 1f 	mcall	8000530c <xg_flashc_init+0x25c>
								//xgflash erase
								
								flashc_memset64((void *)LABEL_ADDRESS, (void *)0x00, LABEL_LENGTH,  true);
80005294:	30 18       	mov	r8,1
80005296:	30 79       	mov	r9,7
80005298:	30 0a       	mov	r10,0
8000529a:	30 0b       	mov	r11,0
8000529c:	e0 6c b0 00 	mov	r12,45056
800052a0:	ea 1c 80 04 	orh	r12,0x8004
800052a4:	f0 1f 00 1f 	mcall	80005320 <xg_flashc_init+0x270>
800052a8:	c2 8b       	rjmp	800050f8 <xg_flashc_init+0x48>

							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
800052aa:	49 bc       	lddpc	r12,80005314 <xg_flashc_init+0x264>
800052ac:	f0 1f 00 18 	mcall	8000530c <xg_flashc_init+0x25c>
800052b0:	30 07       	mov	r7,0
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
800052b2:	48 f6       	lddpc	r6,800052ec <xg_flashc_init+0x23c>
				flashc_erase_page(current_page_number, true);
800052b4:	30 15       	mov	r5,1
800052b6:	c4 6b       	rjmp	80005142 <xg_flashc_init+0x92>
							log("\r\n----voice storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read voice info okay!----\r\n");
800052b8:	49 bc       	lddpc	r12,80005324 <xg_flashc_init+0x274>
800052ba:	f0 1f 00 15 	mcall	8000530c <xg_flashc_init+0x25c>
			}
		}
				
		memcpy(xg_message_count_ptr, &current_message_index, sizeof(current_message_index));
800052be:	49 28       	lddpc	r8,80005304 <xg_flashc_init+0x254>
800052c0:	90 09       	ld.sh	r9,r8[0x0]
800052c2:	49 a8       	lddpc	r8,80005328 <xg_flashc_init+0x278>
800052c4:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
800052c6:	30 19       	mov	r9,1
800052c8:	49 98       	lddpc	r8,8000532c <xg_flashc_init+0x27c>
800052ca:	b0 89       	st.b	r8[0x0],r9
{
	
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init(Current_total_message_counter);
	log("xgflash message counter : %d\n", (Current_total_message_counter[0]&0xFF00) + Current_total_message_counter[1]);
800052cc:	49 78       	lddpc	r8,80005328 <xg_flashc_init+0x278>
800052ce:	11 98       	ld.ub	r8,r8[0x1]
800052d0:	1a d8       	st.w	--sp,r8
800052d2:	49 8c       	lddpc	r12,80005330 <xg_flashc_init+0x280>
800052d4:	f0 1f 00 0e 	mcall	8000530c <xg_flashc_init+0x25c>
800052d8:	2f fd       	sub	sp,-4
	//flashc_memcpy((void *)0x80021007,  &write_data, 8,  true);
	//
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
}
800052da:	2f fd       	sub	sp,-4
800052dc:	d8 32       	popm	r0-r7,pc
800052de:	00 00       	add	r0,r0
800052e0:	00 00       	add	r0,r0
800052e2:	0b 70       	ld.ub	r0,--r5
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	56 fc       	stdsp	sp[0x1bc],r12
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	53 a4       	stdsp	sp[0xe8],r4
800052ec:	00 00       	add	r0,r0
800052ee:	0b 6c       	ld.uh	r12,--r5
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	53 84       	stdsp	sp[0xe0],r4
800052f4:	80 00       	ld.sh	r0,r0[0x0]
800052f6:	53 94       	stdsp	sp[0xe4],r4
800052f8:	00 00       	add	r0,r0
800052fa:	05 30       	ld.ub	r0,r2++
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	79 d0       	ld.w	r0,r12[0x74]
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	54 2c       	stdsp	sp[0x108],r12
80005304:	00 00       	add	r0,r0
80005306:	0b c0       	ld.ub	r0,r5[0x4]
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	da 24       	*unknown*
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	71 50       	ld.w	r0,r8[0x54]
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	da 50       	acall	0xa5
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	da 5c       	*unknown*
80005318:	00 00       	add	r0,r0
8000531a:	05 38       	ld.ub	r8,r2++
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	da 80       	acall	0xa8
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	54 c4       	stdsp	sp[0x130],r4
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	da a8       	*unknown*
80005328:	00 00       	add	r0,r0
8000532a:	0b c4       	ld.ub	r4,r5[0x4]
8000532c:	00 00       	add	r0,r0
8000532e:	0b 69       	ld.uh	r9,--r5
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	da d0       	acall	0xad

80005334 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80005334:	d4 01       	pushm	lr
80005336:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80005338:	31 0a       	mov	r10,16
8000533a:	48 ab       	lddpc	r11,80005360 <flashc_get_flash_size+0x2c>
8000533c:	1a 9c       	mov	r12,sp
8000533e:	f0 1f 00 0a 	mcall	80005364 <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
80005342:	fe 68 14 00 	mov	r8,-125952
80005346:	70 28       	ld.w	r8,r8[0x8]
80005348:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
8000534c:	fa c9 ff f0 	sub	r9,sp,-16
80005350:	f2 08 00 18 	add	r8,r9,r8<<0x1
80005354:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
80005358:	ab 6c       	lsl	r12,0xa
8000535a:	2f cd       	sub	sp,-16
8000535c:	d8 02       	popm	pc
8000535e:	00 00       	add	r0,r0
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	da ee       	*unknown*
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	79 f6       	ld.w	r6,r12[0x7c]

80005368 <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80005368:	fe 68 14 00 	mov	r8,-125952
8000536c:	70 2c       	ld.w	r12,r8[0x8]
}
8000536e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005372:	5e fc       	retal	r12

80005374 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80005374:	d4 01       	pushm	lr
	while (!flashc_is_ready());
80005376:	f0 1f 00 03 	mcall	80005380 <flashc_default_wait_until_ready+0xc>
8000537a:	cf e0       	breq	80005376 <flashc_default_wait_until_ready+0x2>
}
8000537c:	d8 02       	popm	pc
8000537e:	00 00       	add	r0,r0
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	53 68       	stdsp	sp[0xd8],r8

80005384 <flashc_is_lock_error>:
//! by a function.
static unsigned int flashc_error_status = 0;


bool flashc_is_lock_error(void)
{
80005384:	48 38       	lddpc	r8,80005390 <flashc_is_lock_error+0xc>
80005386:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
}
80005388:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
8000538c:	5e fc       	retal	r12
8000538e:	00 00       	add	r0,r0
80005390:	00 00       	add	r0,r0
80005392:	0b c8       	ld.ub	r8,r5[0x4]

80005394 <flashc_is_programming_error>:


bool flashc_is_programming_error(void)
{
80005394:	48 38       	lddpc	r8,800053a0 <flashc_is_programming_error+0xc>
80005396:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_PROGE_MASK) != 0);
}
80005398:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
8000539c:	5e fc       	retal	r12
8000539e:	00 00       	add	r0,r0
800053a0:	00 00       	add	r0,r0
800053a2:	0b c8       	ld.ub	r8,r5[0x4]

800053a4 <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
800053a4:	fe 68 14 00 	mov	r8,-125952
800053a8:	70 1c       	ld.w	r12,r8[0x4]
}
800053aa:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
800053ae:	5e fc       	retal	r12

800053b0 <flashc_issue_command>:


void flashc_issue_command(unsigned int command, int page_number)
{
800053b0:	eb cd 40 c0 	pushm	r6-r7,lr
800053b4:	18 96       	mov	r6,r12
800053b6:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
800053b8:	48 e8       	lddpc	r8,800053f0 <flashc_issue_command+0x40>
800053ba:	70 08       	ld.w	r8,r8[0x0]
800053bc:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
800053be:	fe 68 14 00 	mov	r8,-125952
800053c2:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800053c4:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
800053c8:	58 07       	cp.w	r7,0
800053ca:	c0 35       	brlt	800053d0 <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800053cc:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800053d0:	3a 59       	mov	r9,-91
800053d2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800053d6:	fe 69 14 00 	mov	r9,-125952
800053da:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800053dc:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800053de:	e2 19 00 0c 	andl	r9,0xc,COH
800053e2:	48 58       	lddpc	r8,800053f4 <flashc_issue_command+0x44>
800053e4:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800053e6:	48 38       	lddpc	r8,800053f0 <flashc_issue_command+0x40>
800053e8:	70 08       	ld.w	r8,r8[0x0]
800053ea:	5d 18       	icall	r8
}
800053ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053f0:	00 00       	add	r0,r0
800053f2:	05 3c       	ld.ub	r12,r2++
800053f4:	00 00       	add	r0,r0
800053f6:	0b c8       	ld.ub	r8,r5[0x4]

800053f8 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
800053f8:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
800053fa:	3f fb       	mov	r11,-1
800053fc:	30 3c       	mov	r12,3
800053fe:	f0 1f 00 02 	mcall	80005404 <flashc_clear_page_buffer+0xc>
}
80005402:	d8 02       	popm	pc
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	53 b0       	stdsp	sp[0xec],r0

80005408 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80005408:	fe 68 14 00 	mov	r8,-125952
8000540c:	70 2c       	ld.w	r12,r8[0x8]
}
8000540e:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80005412:	5e fc       	retal	r12

80005414 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80005414:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80005416:	18 9b       	mov	r11,r12
80005418:	30 cc       	mov	r12,12
8000541a:	f0 1f 00 03 	mcall	80005424 <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
8000541e:	f0 1f 00 03 	mcall	80005428 <flashc_quick_page_read+0x14>
}
80005422:	d8 02       	popm	pc
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	53 b0       	stdsp	sp[0xec],r0
80005428:	80 00       	ld.sh	r0,r0[0x0]
8000542a:	54 08       	stdsp	sp[0x100],r8

8000542c <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
8000542c:	eb cd 40 c0 	pushm	r6-r7,lr
80005430:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80005432:	18 9b       	mov	r11,r12
80005434:	30 2c       	mov	r12,2
80005436:	f0 1f 00 09 	mcall	80005458 <flashc_erase_page+0x2c>
	if (check) {
8000543a:	58 07       	cp.w	r7,0
8000543c:	c0 31       	brne	80005442 <flashc_erase_page+0x16>
8000543e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
80005442:	48 77       	lddpc	r7,8000545c <flashc_erase_page+0x30>
80005444:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
80005446:	3f fc       	mov	r12,-1
80005448:	f0 1f 00 06 	mcall	80005460 <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
8000544c:	6e 08       	ld.w	r8,r7[0x0]
8000544e:	f1 e6 10 06 	or	r6,r8,r6
80005452:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
80005454:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	53 b0       	stdsp	sp[0xec],r0
8000545c:	00 00       	add	r0,r0
8000545e:	0b c8       	ld.ub	r8,r5[0x4]
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	54 14       	stdsp	sp[0x104],r4

80005464 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80005464:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
80005466:	18 9b       	mov	r11,r12
80005468:	30 1c       	mov	r12,1
8000546a:	f0 1f 00 02 	mcall	80005470 <flashc_write_page+0xc>
}
8000546e:	d8 02       	popm	pc
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	53 b0       	stdsp	sp[0xec],r0

80005474 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
80005474:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80005476:	3f fb       	mov	r11,-1
80005478:	30 fc       	mov	r12,15
8000547a:	f0 1f 00 03 	mcall	80005484 <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
8000547e:	f0 1f 00 03 	mcall	80005488 <flashc_quick_user_page_read+0x14>
}
80005482:	d8 02       	popm	pc
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	53 b0       	stdsp	sp[0xec],r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	54 08       	stdsp	sp[0x100],r8

8000548c <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
8000548c:	eb cd 40 80 	pushm	r7,lr
80005490:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
80005492:	3f fb       	mov	r11,-1
80005494:	30 ec       	mov	r12,14
80005496:	f0 1f 00 06 	mcall	800054ac <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
8000549a:	58 07       	cp.w	r7,0
8000549c:	c0 31       	brne	800054a2 <flashc_erase_user_page+0x16>
8000549e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800054a2:	f0 1f 00 04 	mcall	800054b0 <flashc_erase_user_page+0x24>
}
800054a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800054aa:	00 00       	add	r0,r0
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	53 b0       	stdsp	sp[0xec],r0
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	54 74       	stdsp	sp[0x11c],r4

800054b4 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
800054b4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
800054b6:	3f fb       	mov	r11,-1
800054b8:	30 dc       	mov	r12,13
800054ba:	f0 1f 00 02 	mcall	800054c0 <flashc_write_user_page+0xc>
}
800054be:	d8 02       	popm	pc
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	53 b0       	stdsp	sp[0xec],r0

800054c4 <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800054c4:	d4 31       	pushm	r0-r7,lr
800054c6:	20 cd       	sub	sp,48
800054c8:	50 6c       	stdsp	sp[0x18],r12
800054ca:	14 94       	mov	r4,r10
800054cc:	16 95       	mov	r5,r11
800054ce:	12 96       	mov	r6,r9
800054d0:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800054d2:	30 08       	mov	r8,0
800054d4:	30 09       	mov	r9,0
800054d6:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800054da:	f0 1f 00 82 	mcall	800056e0 <flashc_memset64+0x21c>
800054de:	fc 18 80 00 	movh	r8,0x8000
800054e2:	f8 08 00 08 	add	r8,r12,r8
800054e6:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
800054e8:	40 6b       	lddsp	r11,sp[0x18]
800054ea:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800054ec:	58 04       	cp.w	r4,0
800054ee:	5c 25       	cpc	r5
800054f0:	c1 80       	breq	80005520 <flashc_memset64+0x5c>
800054f2:	f6 c8 ff f9 	sub	r8,r11,-7
800054f6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800054fa:	fa c9 ff d0 	sub	r9,sp,-48
800054fe:	10 09       	add	r9,r8
80005500:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
80005504:	e8 0c 16 08 	lsr	r12,r4,0x8
80005508:	ea 0a 16 08 	lsr	r10,r5,0x8
8000550c:	f9 e5 11 89 	or	r9,r12,r5<<0x18
80005510:	14 95       	mov	r5,r10
80005512:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80005514:	20 18       	sub	r8,1
80005516:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000551a:	58 04       	cp.w	r4,0
8000551c:	5c 25       	cpc	r5
8000551e:	ce e1       	brne	800054fa <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80005520:	f6 06 00 06 	add	r6,r11,r6
80005524:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80005526:	e0 6a ff ff 	mov	r10,65535
8000552a:	ea 1a 7f ff 	orh	r10,0x7fff
8000552e:	14 3b       	cp.w	r11,r10
80005530:	e0 8b 00 05 	brhi	8000553a <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
80005534:	fc 17 80 00 	movh	r7,0x8000
80005538:	c0 e8       	rjmp	80005554 <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
8000553a:	40 29       	lddsp	r9,sp[0x8]
8000553c:	16 39       	cp.w	r9,r11
8000553e:	e0 8b 00 0b 	brhi	80005554 <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80005542:	fc 18 80 80 	movh	r8,0x8080
80005546:	e0 6a ff ff 	mov	r10,65535
8000554a:	ea 1a 80 7f 	orh	r10,0x807f
8000554e:	14 3b       	cp.w	r11,r10
80005550:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
80005554:	40 09       	lddsp	r9,sp[0x0]
80005556:	e0 68 02 00 	mov	r8,512
8000555a:	ea 18 80 80 	orh	r8,0x8080
8000555e:	10 39       	cp.w	r9,r8
80005560:	e0 88 00 04 	brls	80005568 <flashc_memset64+0xa4>
80005564:	50 08       	stdsp	sp[0x0],r8
80005566:	c0 c8       	rjmp	8000557e <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80005568:	40 0a       	lddsp	r10,sp[0x0]
8000556a:	fc 19 80 80 	movh	r9,0x8080
8000556e:	12 3a       	cp.w	r10,r9
80005570:	e0 8b 00 07 	brhi	8000557e <flashc_memset64+0xba>
80005574:	40 28       	lddsp	r8,sp[0x8]
80005576:	10 3a       	cp.w	r10,r8
80005578:	f0 0a 17 b0 	movhi	r10,r8
8000557c:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
8000557e:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
80005580:	10 9b       	mov	r11,r8
80005582:	e0 1b ff f8 	andl	r11,0xfff8
80005586:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80005588:	fa e4 00 28 	ld.d	r4,sp[40]
8000558c:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8000558e:	4d 66       	lddpc	r6,800056e4 <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80005590:	10 9a       	mov	r10,r8
80005592:	e0 1a fe 00 	andl	r10,0xfe00
80005596:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005598:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000559c:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000559e:	40 08       	lddsp	r8,sp[0x0]
800055a0:	40 59       	lddsp	r9,sp[0x14]
800055a2:	12 18       	sub	r8,r9
800055a4:	2f 88       	sub	r8,-8
800055a6:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800055a8:	c9 18       	rjmp	800056ca <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800055aa:	f0 1f 00 50 	mcall	800056e8 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
800055ae:	6c 08       	ld.w	r8,r6[0x0]
800055b0:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800055b2:	04 9c       	mov	r12,r2
800055b4:	e0 1c fe 00 	andl	r12,0xfe00
800055b8:	f8 ce fe 00 	sub	lr,r12,-512
800055bc:	40 18       	lddsp	r8,sp[0x4]
800055be:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800055c2:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800055c6:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
800055ca:	c2 f0       	breq	80005628 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055cc:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800055ce:	18 90       	mov	r0,r12
800055d0:	04 91       	mov	r1,r2
800055d2:	e0 11 ff f8 	andl	r1,0xfff8
800055d6:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055d8:	18 31       	cp.w	r1,r12
800055da:	e0 88 00 10 	brls	800055fa <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800055de:	f0 ea 00 00 	ld.d	r10,r8[0]
800055e2:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055e4:	10 39       	cp.w	r9,r8
800055e6:	fe 9b ff fc 	brhi	800055de <flashc_memset64+0x11a>
800055ea:	e0 08 11 ff 	rsub	r8,r0,-1
800055ee:	02 08       	add	r8,r1
800055f0:	e0 18 ff f8 	andl	r8,0xfff8
800055f4:	2f 88       	sub	r8,-8
800055f6:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800055fa:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
800055fe:	c1 50       	breq	80005628 <flashc_memset64+0x164>
80005600:	30 0a       	mov	r10,0
80005602:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
80005606:	17 8b       	ld.ub	r11,r11[0x0]
80005608:	fa c7 ff e0 	sub	r7,sp,-32
8000560c:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80005610:	2f fa       	sub	r10,-1
80005612:	04 3a       	cp.w	r10,r2
80005614:	cf 71       	brne	80005602 <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80005616:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
80005618:	40 1b       	lddsp	r11,sp[0x4]
8000561a:	16 39       	cp.w	r9,r11
8000561c:	c0 62       	brcc	80005628 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
8000561e:	fa e8 00 20 	ld.d	r8,sp[32]
80005622:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
80005624:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005628:	0e 99       	mov	r9,r7
8000562a:	0e 1e       	sub	lr,r7
8000562c:	a3 5e       	asr	lr,0x3
8000562e:	c0 80       	breq	8000563e <flashc_memset64+0x17a>
80005630:	0e 9a       	mov	r10,r7
80005632:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
80005634:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005636:	20 18       	sub	r8,1
80005638:	cf e1       	brne	80005634 <flashc_memset64+0x170>
8000563a:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
8000563e:	40 4a       	lddsp	r10,sp[0x10]
80005640:	14 3c       	cp.w	r12,r10
80005642:	c1 d3       	brcs	8000567c <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80005644:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005646:	40 59       	lddsp	r9,sp[0x14]
80005648:	58 09       	cp.w	r9,0
8000564a:	c1 00       	breq	8000566a <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000564c:	10 99       	mov	r9,r8
8000564e:	fa c8 ff e0 	sub	r8,sp,-32
80005652:	40 5b       	lddsp	r11,sp[0x14]
80005654:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
80005656:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
8000565a:	13 3a       	ld.ub	r10,r9++
8000565c:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000565e:	16 38       	cp.w	r8,r11
80005660:	cf d1       	brne	8000565a <flashc_memset64+0x196>
80005662:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80005664:	fa ea 00 20 	ld.d	r10,sp[32]
80005668:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
8000566a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000566e:	c0 70       	breq	8000567c <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
80005670:	f0 ea 00 00 	ld.d	r10,r8[0]
80005674:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005676:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000567a:	cf b1       	brne	80005670 <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
8000567c:	0e 92       	mov	r2,r7
8000567e:	fc 1a 80 80 	movh	r10,0x8080
80005682:	14 37       	cp.w	r7,r10
80005684:	e0 8b 00 17 	brhi	800056b2 <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80005688:	40 39       	lddsp	r9,sp[0xc]
8000568a:	58 09       	cp.w	r9,0
8000568c:	c0 70       	breq	8000569a <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
8000568e:	30 0b       	mov	r11,0
80005690:	3f fc       	mov	r12,-1
80005692:	f0 1f 00 17 	mcall	800056ec <flashc_memset64+0x228>
				error_status |= flashc_error_status;
80005696:	6c 08       	ld.w	r8,r6[0x0]
80005698:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
8000569a:	3f fc       	mov	r12,-1
8000569c:	f0 1f 00 15 	mcall	800056f0 <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
800056a0:	6c 08       	ld.w	r8,r6[0x0]
800056a2:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800056a4:	fc 18 80 80 	movh	r8,0x8080
800056a8:	40 2b       	lddsp	r11,sp[0x8]
800056aa:	04 3b       	cp.w	r11,r2
800056ac:	f0 07 17 80 	movls	r7,r8
800056b0:	c0 d8       	rjmp	800056ca <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
800056b2:	40 3a       	lddsp	r10,sp[0xc]
800056b4:	58 0a       	cp.w	r10,0
800056b6:	c0 60       	breq	800056c2 <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
800056b8:	30 0c       	mov	r12,0
800056ba:	f0 1f 00 0f 	mcall	800056f4 <flashc_memset64+0x230>
				error_status |= flashc_error_status;
800056be:	6c 08       	ld.w	r8,r6[0x0]
800056c0:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
800056c2:	f0 1f 00 0e 	mcall	800056f8 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
800056c6:	6c 08       	ld.w	r8,r6[0x0]
800056c8:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800056ca:	0e 92       	mov	r2,r7
800056cc:	40 09       	lddsp	r9,sp[0x0]
800056ce:	12 37       	cp.w	r7,r9
800056d0:	fe 93 ff 6d 	brlo	800055aa <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800056d4:	48 48       	lddpc	r8,800056e4 <flashc_memset64+0x220>
800056d6:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800056d8:	40 6c       	lddsp	r12,sp[0x18]
800056da:	2f 4d       	sub	sp,-48
800056dc:	d8 32       	popm	r0-r7,pc
800056de:	00 00       	add	r0,r0
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	53 34       	stdsp	sp[0xcc],r4
800056e4:	00 00       	add	r0,r0
800056e6:	0b c8       	ld.ub	r8,r5[0x4]
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	53 f8       	stdsp	sp[0xfc],r8
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	54 2c       	stdsp	sp[0x108],r12
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	54 64       	stdsp	sp[0x118],r4
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	54 8c       	stdsp	sp[0x120],r12
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	54 b4       	stdsp	sp[0x12c],r4

800056fc <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
800056fc:	d4 31       	pushm	r0-r7,lr
800056fe:	20 7d       	sub	sp,28
80005700:	50 1c       	stdsp	sp[0x4],r12
80005702:	14 97       	mov	r7,r10
80005704:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
80005706:	e0 69 ff ff 	mov	r9,65535
8000570a:	ea 19 80 7f 	orh	r9,0x807f
8000570e:	12 3c       	cp.w	r12,r9
80005710:	5f b8       	srhi	r8
80005712:	50 28       	stdsp	sp[0x8],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80005714:	58 0a       	cp.w	r10,0
80005716:	c0 41       	brne	8000571e <flashc_memcpy+0x22>
80005718:	30 09       	mov	r9,0
8000571a:	50 09       	stdsp	sp[0x0],r9
8000571c:	c5 b8       	rjmp	800057d2 <flashc_memcpy+0xd6>
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
8000571e:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
80005720:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
80005722:	0c 90       	mov	r0,r6
80005724:	e0 10 fe 00 	andl	r0,0xfe00
80005728:	30 08       	mov	r8,0
8000572a:	50 08       	stdsp	sp[0x0],r8

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8000572c:	4a d1       	lddpc	r1,800057e0 <flashc_memcpy+0xe4>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8000572e:	30 05       	mov	r5,0
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005730:	fa c3 ff ec 	sub	r3,sp,-20
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005734:	10 92       	mov	r2,r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
80005736:	f0 1f 00 2c 	mcall	800057e4 <flashc_memcpy+0xe8>
		error_status |= flashc_error_status;
8000573a:	62 08       	ld.w	r8,r1[0x0]
8000573c:	40 09       	lddsp	r9,sp[0x0]
8000573e:	10 49       	or	r9,r8
80005740:	50 09       	stdsp	sp[0x0],r9
80005742:	00 9b       	mov	r11,r0
80005744:	e0 ce fe 00 	sub	lr,r0,-512
80005748:	16 9c       	mov	r12,r11

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
8000574a:	f6 e8 00 00 	ld.d	r8,r11[0]
8000574e:	fa e9 00 14 	st.d	sp[20],r8
80005752:	04 98       	mov	r8,r2

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80005754:	58 07       	cp.w	r7,0
80005756:	5f 1a       	srne	r10
80005758:	f0 0b 00 09 	add	r9,r8,r11
8000575c:	12 36       	cp.w	r6,r9
8000575e:	5f 09       	sreq	r9
80005760:	f5 e9 00 09 	and	r9,r10,r9
80005764:	ea 09 18 00 	cp.b	r9,r5
80005768:	c0 60       	breq	80005774 <flashc_memcpy+0x78>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8000576a:	09 39       	ld.ub	r9,r4++
8000576c:	e6 08 0b 09 	st.b	r3[r8],r9
					dest_add++;
80005770:	2f f6       	sub	r6,-1
					nbytes--;
80005772:	20 17       	sub	r7,1
80005774:	2f f8       	sub	r8,-1
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80005776:	58 88       	cp.w	r8,8
80005778:	ce e1       	brne	80005754 <flashc_memcpy+0x58>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
8000577a:	fa e8 00 14 	ld.d	r8,sp[20]
8000577e:	f8 e9 00 00 	st.d	r12[0],r8
80005782:	2f 8b       	sub	r11,-8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80005784:	1c 3b       	cp.w	r11,lr
80005786:	ce 11       	brne	80005748 <flashc_memcpy+0x4c>
80005788:	50 37       	stdsp	sp[0xc],r7
8000578a:	e0 c0 fe 00 	sub	r0,r0,-512
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
8000578e:	40 48       	lddsp	r8,sp[0x10]
80005790:	58 08       	cp.w	r8,0
80005792:	c1 00       	breq	800057b2 <flashc_memcpy+0xb6>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
80005794:	40 29       	lddsp	r9,sp[0x8]
80005796:	58 09       	cp.w	r9,0
80005798:	c0 50       	breq	800057a2 <flashc_memcpy+0xa6>
8000579a:	30 0c       	mov	r12,0
8000579c:	f0 1f 00 13 	mcall	800057e8 <flashc_memcpy+0xec>
800057a0:	c0 58       	rjmp	800057aa <flashc_memcpy+0xae>
800057a2:	30 0b       	mov	r11,0
800057a4:	3f fc       	mov	r12,-1
800057a6:	f0 1f 00 12 	mcall	800057ec <flashc_memcpy+0xf0>
			error_status |= flashc_error_status;
800057aa:	62 08       	ld.w	r8,r1[0x0]
800057ac:	40 09       	lddsp	r9,sp[0x0]
800057ae:	10 49       	or	r9,r8
800057b0:	50 09       	stdsp	sp[0x0],r9
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
800057b2:	40 28       	lddsp	r8,sp[0x8]
800057b4:	58 08       	cp.w	r8,0
800057b6:	c0 40       	breq	800057be <flashc_memcpy+0xc2>
800057b8:	f0 1f 00 0e 	mcall	800057f0 <flashc_memcpy+0xf4>
800057bc:	c0 48       	rjmp	800057c4 <flashc_memcpy+0xc8>
800057be:	3f fc       	mov	r12,-1
800057c0:	f0 1f 00 0d 	mcall	800057f4 <flashc_memcpy+0xf8>
		error_status |= flashc_error_status;
800057c4:	62 08       	ld.w	r8,r1[0x0]
800057c6:	40 09       	lddsp	r9,sp[0x0]
800057c8:	10 49       	or	r9,r8
800057ca:	50 09       	stdsp	sp[0x0],r9

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
800057cc:	40 38       	lddsp	r8,sp[0xc]
800057ce:	58 08       	cp.w	r8,0
800057d0:	cb 31       	brne	80005736 <flashc_memcpy+0x3a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
800057d2:	48 48       	lddpc	r8,800057e0 <flashc_memcpy+0xe4>
800057d4:	40 09       	lddsp	r9,sp[0x0]
800057d6:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
800057d8:	40 1c       	lddsp	r12,sp[0x4]
800057da:	2f 9d       	sub	sp,-28
800057dc:	d8 32       	popm	r0-r7,pc
800057de:	00 00       	add	r0,r0
800057e0:	00 00       	add	r0,r0
800057e2:	0b c8       	ld.ub	r8,r5[0x4]
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	53 f8       	stdsp	sp[0xfc],r8
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	54 8c       	stdsp	sp[0x120],r12
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	54 2c       	stdsp	sp[0x108],r12
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	54 b4       	stdsp	sp[0x12c],r4
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	54 64       	stdsp	sp[0x118],r4

800057f8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800057f8:	f8 08 16 05 	lsr	r8,r12,0x5
800057fc:	a9 68       	lsl	r8,0x8
800057fe:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005802:	58 1b       	cp.w	r11,1
80005804:	c0 d0       	breq	8000581e <gpio_enable_module_pin+0x26>
80005806:	c0 63       	brcs	80005812 <gpio_enable_module_pin+0x1a>
80005808:	58 2b       	cp.w	r11,2
8000580a:	c1 00       	breq	8000582a <gpio_enable_module_pin+0x32>
8000580c:	58 3b       	cp.w	r11,3
8000580e:	c1 40       	breq	80005836 <gpio_enable_module_pin+0x3e>
80005810:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005812:	30 19       	mov	r9,1
80005814:	f2 0c 09 49 	lsl	r9,r9,r12
80005818:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000581a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000581c:	c1 28       	rjmp	80005840 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000581e:	30 19       	mov	r9,1
80005820:	f2 0c 09 49 	lsl	r9,r9,r12
80005824:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005826:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005828:	c0 c8       	rjmp	80005840 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000582a:	30 19       	mov	r9,1
8000582c:	f2 0c 09 49 	lsl	r9,r9,r12
80005830:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005832:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005834:	c0 68       	rjmp	80005840 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005836:	30 19       	mov	r9,1
80005838:	f2 0c 09 49 	lsl	r9,r9,r12
8000583c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000583e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005840:	30 19       	mov	r9,1
80005842:	f2 0c 09 4c 	lsl	r12,r9,r12
80005846:	91 2c       	st.w	r8[0x8],r12
80005848:	5e fd       	retal	0
8000584a:	d7 03       	nop

8000584c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000584c:	d4 21       	pushm	r4-r7,lr
8000584e:	18 97       	mov	r7,r12
80005850:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005852:	58 0b       	cp.w	r11,0
80005854:	c0 31       	brne	8000585a <gpio_enable_module+0xe>
80005856:	30 05       	mov	r5,0
80005858:	c0 d8       	rjmp	80005872 <gpio_enable_module+0x26>
8000585a:	30 06       	mov	r6,0
8000585c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000585e:	6e 1b       	ld.w	r11,r7[0x4]
80005860:	6e 0c       	ld.w	r12,r7[0x0]
80005862:	f0 1f 00 06 	mcall	80005878 <gpio_enable_module+0x2c>
80005866:	18 45       	or	r5,r12
		gpiomap++;
80005868:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000586a:	2f f6       	sub	r6,-1
8000586c:	0c 34       	cp.w	r4,r6
8000586e:	fe 9b ff f8 	brhi	8000585e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005872:	0a 9c       	mov	r12,r5
80005874:	d8 22       	popm	r4-r7,pc
80005876:	00 00       	add	r0,r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	57 f8       	stdsp	sp[0x1fc],r8

8000587c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000587c:	f8 08 16 05 	lsr	r8,r12,0x5
80005880:	a9 68       	lsl	r8,0x8
80005882:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005886:	30 19       	mov	r9,1
80005888:	f2 0c 09 4c 	lsl	r12,r9,r12
8000588c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005890:	91 1c       	st.w	r8[0x4],r12
}
80005892:	5e fc       	retal	r12

80005894 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005894:	f8 08 16 05 	lsr	r8,r12,0x5
80005898:	a9 68       	lsl	r8,0x8
8000589a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000589e:	30 19       	mov	r9,1
800058a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800058a4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800058a8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800058ac:	91 1c       	st.w	r8[0x4],r12
}
800058ae:	5e fc       	retal	r12

800058b0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800058b0:	f8 08 16 05 	lsr	r8,r12,0x5
800058b4:	a9 68       	lsl	r8,0x8
800058b6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800058ba:	30 19       	mov	r9,1
800058bc:	f2 0c 09 4c 	lsl	r12,r9,r12
800058c0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800058c4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800058c8:	91 1c       	st.w	r8[0x4],r12
}
800058ca:	5e fc       	retal	r12

800058cc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800058cc:	c0 08       	rjmp	800058cc <_unhandled_interrupt>
800058ce:	d7 03       	nop

800058d0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800058d0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800058d4:	49 99       	lddpc	r9,80005938 <INTC_register_interrupt+0x68>
800058d6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800058da:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800058de:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800058e0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800058e4:	58 0a       	cp.w	r10,0
800058e6:	c0 91       	brne	800058f8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800058e8:	49 59       	lddpc	r9,8000593c <INTC_register_interrupt+0x6c>
800058ea:	49 6a       	lddpc	r10,80005940 <INTC_register_interrupt+0x70>
800058ec:	12 1a       	sub	r10,r9
800058ee:	fe 79 08 00 	mov	r9,-63488
800058f2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058f6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800058f8:	58 1a       	cp.w	r10,1
800058fa:	c0 a1       	brne	8000590e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800058fc:	49 09       	lddpc	r9,8000593c <INTC_register_interrupt+0x6c>
800058fe:	49 2a       	lddpc	r10,80005944 <INTC_register_interrupt+0x74>
80005900:	12 1a       	sub	r10,r9
80005902:	bf aa       	sbr	r10,0x1e
80005904:	fe 79 08 00 	mov	r9,-63488
80005908:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000590c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000590e:	58 2a       	cp.w	r10,2
80005910:	c0 a1       	brne	80005924 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005912:	48 b9       	lddpc	r9,8000593c <INTC_register_interrupt+0x6c>
80005914:	48 da       	lddpc	r10,80005948 <INTC_register_interrupt+0x78>
80005916:	12 1a       	sub	r10,r9
80005918:	bf ba       	sbr	r10,0x1f
8000591a:	fe 79 08 00 	mov	r9,-63488
8000591e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005922:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005924:	48 69       	lddpc	r9,8000593c <INTC_register_interrupt+0x6c>
80005926:	48 aa       	lddpc	r10,8000594c <INTC_register_interrupt+0x7c>
80005928:	12 1a       	sub	r10,r9
8000592a:	ea 1a c0 00 	orh	r10,0xc000
8000592e:	fe 79 08 00 	mov	r9,-63488
80005932:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005936:	5e fc       	retal	r12
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	db 00       	acall	0xb0
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	d0 00       	acall	0x0
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	d1 04       	*unknown*
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	d1 12       	popm	r0-r3,r11
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	d1 20       	acall	0x12
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	d1 2e       	*unknown*

80005950 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005950:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005952:	49 18       	lddpc	r8,80005994 <INTC_init_interrupts+0x44>
80005954:	e3 b8 00 01 	mtsr	0x4,r8
80005958:	49 0e       	lddpc	lr,80005998 <INTC_init_interrupts+0x48>
8000595a:	30 07       	mov	r7,0
8000595c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000595e:	49 0c       	lddpc	r12,8000599c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005960:	49 05       	lddpc	r5,800059a0 <INTC_init_interrupts+0x50>
80005962:	10 15       	sub	r5,r8
80005964:	fe 76 08 00 	mov	r6,-63488
80005968:	c1 08       	rjmp	80005988 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000596a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000596c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000596e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005970:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005974:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005976:	10 3a       	cp.w	r10,r8
80005978:	fe 9b ff fc 	brhi	80005970 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000597c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005980:	2f f7       	sub	r7,-1
80005982:	2f 8e       	sub	lr,-8
80005984:	59 37       	cp.w	r7,19
80005986:	c0 50       	breq	80005990 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005988:	7c 08       	ld.w	r8,lr[0x0]
8000598a:	58 08       	cp.w	r8,0
8000598c:	ce f1       	brne	8000596a <INTC_init_interrupts+0x1a>
8000598e:	cf 7b       	rjmp	8000597c <INTC_init_interrupts+0x2c>
80005990:	d8 22       	popm	r4-r7,pc
80005992:	00 00       	add	r0,r0
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	d0 00       	acall	0x0
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	db 00       	acall	0xb0
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	58 cc       	cp.w	r12,12
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	d1 04       	*unknown*

800059a4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800059a4:	fe 78 08 00 	mov	r8,-63488
800059a8:	e0 69 00 83 	mov	r9,131
800059ac:	f2 0c 01 0c 	sub	r12,r9,r12
800059b0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800059b4:	f2 ca ff c0 	sub	r10,r9,-64
800059b8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800059bc:	58 08       	cp.w	r8,0
800059be:	c0 21       	brne	800059c2 <_get_interrupt_handler+0x1e>
800059c0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800059c2:	f0 08 12 00 	clz	r8,r8
800059c6:	48 5a       	lddpc	r10,800059d8 <_get_interrupt_handler+0x34>
800059c8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800059cc:	f0 08 11 1f 	rsub	r8,r8,31
800059d0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800059d2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800059d6:	5e fc       	retal	r12
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	db 00       	acall	0xb0

800059dc <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800059dc:	f8 c8 00 01 	sub	r8,r12,1
800059e0:	f0 0b 00 0b 	add	r11,r8,r11
800059e4:	f6 0c 0d 0a 	divu	r10,r11,r12
800059e8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800059ea:	f4 c8 00 01 	sub	r8,r10,1
800059ee:	e0 48 00 fe 	cp.w	r8,254
800059f2:	e0 88 00 03 	brls	800059f8 <getBaudDiv+0x1c>
800059f6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800059f8:	5c 8c       	casts.h	r12
}
800059fa:	5e fc       	retal	r12

800059fc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800059fc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005a00:	30 18       	mov	r8,1
80005a02:	f0 09 18 00 	cp.b	r9,r8
80005a06:	e0 88 00 04 	brls	80005a0e <spi_initMaster+0x12>
80005a0a:	30 2c       	mov	r12,2
80005a0c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005a0e:	e0 68 00 80 	mov	r8,128
80005a12:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005a14:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005a16:	30 19       	mov	r9,1
80005a18:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005a1c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005a20:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005a24:	30 09       	mov	r9,0
80005a26:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005a2a:	30 fa       	mov	r10,15
80005a2c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005a30:	99 18       	st.w	r12[0x4],r8
80005a32:	5e f9       	retal	r9

80005a34 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005a34:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005a36:	30 18       	mov	r8,1
80005a38:	f0 0b 18 00 	cp.b	r11,r8
80005a3c:	5f be       	srhi	lr
80005a3e:	f0 0a 18 00 	cp.b	r10,r8
80005a42:	5f b8       	srhi	r8
80005a44:	fd e8 10 08 	or	r8,lr,r8
80005a48:	c0 30       	breq	80005a4e <spi_selectionMode+0x1a>
80005a4a:	30 2c       	mov	r12,2
80005a4c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005a4e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005a50:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005a54:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005a58:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005a5c:	99 18       	st.w	r12[0x4],r8
80005a5e:	d8 0a       	popm	pc,r12=0

80005a60 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005a60:	30 18       	mov	r8,1
80005a62:	99 08       	st.w	r12[0x0],r8
}
80005a64:	5e fc       	retal	r12

80005a66 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005a66:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005a6a:	c0 58       	rjmp	80005a74 <spi_write+0xe>
		if (!timeout--) {
80005a6c:	58 08       	cp.w	r8,0
80005a6e:	c0 21       	brne	80005a72 <spi_write+0xc>
80005a70:	5e ff       	retal	1
80005a72:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005a74:	78 49       	ld.w	r9,r12[0x10]
80005a76:	e2 19 00 02 	andl	r9,0x2,COH
80005a7a:	cf 90       	breq	80005a6c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005a7c:	5c 7b       	castu.h	r11
80005a7e:	99 3b       	st.w	r12[0xc],r11
80005a80:	5e fd       	retal	0

80005a82 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005a82:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005a86:	c0 58       	rjmp	80005a90 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005a88:	58 08       	cp.w	r8,0
80005a8a:	c0 21       	brne	80005a8e <spi_read+0xc>
80005a8c:	5e ff       	retal	1
80005a8e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005a90:	78 49       	ld.w	r9,r12[0x10]
80005a92:	e2 19 02 01 	andl	r9,0x201,COH
80005a96:	e0 49 02 01 	cp.w	r9,513
80005a9a:	cf 71       	brne	80005a88 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005a9c:	78 28       	ld.w	r8,r12[0x8]
80005a9e:	b6 08       	st.h	r11[0x0],r8
80005aa0:	5e fd       	retal	0
80005aa2:	d7 03       	nop

80005aa4 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005aa4:	eb cd 40 f8 	pushm	r3-r7,lr
80005aa8:	18 95       	mov	r5,r12
80005aaa:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005aac:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005ab0:	30 38       	mov	r8,3
80005ab2:	f0 06 18 00 	cp.b	r6,r8
80005ab6:	e0 8b 00 5e 	brhi	80005b72 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005aba:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005abe:	30 18       	mov	r8,1
80005ac0:	f0 04 18 00 	cp.b	r4,r8
80005ac4:	e0 8b 00 57 	brhi	80005b72 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005ac8:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005acc:	30 78       	mov	r8,7
80005ace:	f0 03 18 00 	cp.b	r3,r8
80005ad2:	e0 88 00 50 	brls	80005b72 <spi_setupChipReg+0xce>
80005ad6:	31 08       	mov	r8,16
80005ad8:	f0 03 18 00 	cp.b	r3,r8
80005adc:	e0 8b 00 4b 	brhi	80005b72 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005ae0:	14 9b       	mov	r11,r10
80005ae2:	6e 1c       	ld.w	r12,r7[0x4]
80005ae4:	f0 1f 00 26 	mcall	80005b7c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005ae8:	c4 55       	brlt	80005b72 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005aea:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005aec:	ec 09 16 01 	lsr	r9,r6,0x1
80005af0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005af4:	ec 16 00 01 	eorl	r6,0x1
80005af8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005afc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005b00:	20 83       	sub	r3,8
80005b02:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005b06:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005b0a:	ef 39 00 09 	ld.ub	r9,r7[9]
80005b0e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005b12:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005b16:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005b1a:	0f 89       	ld.ub	r9,r7[0x0]
80005b1c:	30 1a       	mov	r10,1
80005b1e:	f4 09 18 00 	cp.b	r9,r10
80005b22:	c0 d0       	breq	80005b3c <spi_setupChipReg+0x98>
80005b24:	c0 a3       	brcs	80005b38 <spi_setupChipReg+0x94>
80005b26:	30 2a       	mov	r10,2
80005b28:	f4 09 18 00 	cp.b	r9,r10
80005b2c:	c0 a0       	breq	80005b40 <spi_setupChipReg+0x9c>
80005b2e:	30 3a       	mov	r10,3
80005b30:	f4 09 18 00 	cp.b	r9,r10
80005b34:	c1 f1       	brne	80005b72 <spi_setupChipReg+0xce>
80005b36:	c0 78       	rjmp	80005b44 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005b38:	8b c8       	st.w	r5[0x30],r8
		break;
80005b3a:	c0 68       	rjmp	80005b46 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005b3c:	8b d8       	st.w	r5[0x34],r8
		break;
80005b3e:	c0 48       	rjmp	80005b46 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005b40:	8b e8       	st.w	r5[0x38],r8
		break;
80005b42:	c0 28       	rjmp	80005b46 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005b44:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005b46:	48 f8       	lddpc	r8,80005b80 <spi_setupChipReg+0xdc>
80005b48:	70 08       	ld.w	r8,r8[0x0]
80005b4a:	58 08       	cp.w	r8,0
80005b4c:	c1 61       	brne	80005b78 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005b4e:	30 0b       	mov	r11,0
80005b50:	30 1c       	mov	r12,1
80005b52:	f0 1f 00 0d 	mcall	80005b84 <spi_setupChipReg+0xe0>
80005b56:	48 b8       	lddpc	r8,80005b80 <spi_setupChipReg+0xdc>
80005b58:	91 0c       	st.w	r8[0x0],r12
80005b5a:	58 0c       	cp.w	r12,0
80005b5c:	c0 a0       	breq	80005b70 <spi_setupChipReg+0xcc>
80005b5e:	30 09       	mov	r9,0
80005b60:	12 9a       	mov	r10,r9
80005b62:	12 9b       	mov	r11,r9
80005b64:	f0 1f 00 09 	mcall	80005b88 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005b68:	48 68       	lddpc	r8,80005b80 <spi_setupChipReg+0xdc>
80005b6a:	70 08       	ld.w	r8,r8[0x0]
80005b6c:	58 08       	cp.w	r8,0
80005b6e:	c0 51       	brne	80005b78 <spi_setupChipReg+0xd4>
80005b70:	c0 08       	rjmp	80005b70 <spi_setupChipReg+0xcc>
80005b72:	30 2c       	mov	r12,2
80005b74:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005b78:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005b7c:	80 00       	ld.sh	r0,r0[0x0]
80005b7e:	59 dc       	cp.w	r12,29
80005b80:	00 00       	add	r0,r0
80005b82:	51 88       	stdsp	sp[0x60],r8
80005b84:	80 00       	ld.sh	r0,r0[0x0]
80005b86:	66 70       	ld.w	r0,r3[0x1c]
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	65 70       	ld.w	r0,r2[0x5c]

80005b8c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005b8c:	d4 01       	pushm	lr
80005b8e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b92:	c0 58       	rjmp	80005b9c <spi_unselectChip+0x10>
		if (!timeout--) {
80005b94:	58 08       	cp.w	r8,0
80005b96:	c0 21       	brne	80005b9a <spi_unselectChip+0xe>
80005b98:	da 0a       	popm	pc,r12=1
80005b9a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b9c:	78 49       	ld.w	r9,r12[0x10]
80005b9e:	e2 19 02 00 	andl	r9,0x200,COH
80005ba2:	cf 90       	breq	80005b94 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005ba4:	78 18       	ld.w	r8,r12[0x4]
80005ba6:	ea 18 00 0f 	orh	r8,0xf
80005baa:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005bac:	fc 18 01 00 	movh	r8,0x100
80005bb0:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005bb2:	30 09       	mov	r9,0
80005bb4:	12 9a       	mov	r10,r9
80005bb6:	12 9b       	mov	r11,r9
80005bb8:	48 38       	lddpc	r8,80005bc4 <spi_unselectChip+0x38>
80005bba:	70 0c       	ld.w	r12,r8[0x0]
80005bbc:	f0 1f 00 03 	mcall	80005bc8 <spi_unselectChip+0x3c>
80005bc0:	d8 0a       	popm	pc,r12=0
80005bc2:	00 00       	add	r0,r0
80005bc4:	00 00       	add	r0,r0
80005bc6:	51 88       	stdsp	sp[0x60],r8
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	65 70       	ld.w	r0,r2[0x5c]

80005bcc <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005bcc:	eb cd 40 f8 	pushm	r3-r7,lr
80005bd0:	18 94       	mov	r4,r12
80005bd2:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005bd4:	49 a6       	lddpc	r6,80005c3c <spi_selectChip+0x70>
80005bd6:	30 07       	mov	r7,0
80005bd8:	31 45       	mov	r5,20
80005bda:	0e 99       	mov	r9,r7
80005bdc:	0a 9a       	mov	r10,r5
80005bde:	0e 9b       	mov	r11,r7
80005be0:	6c 0c       	ld.w	r12,r6[0x0]
80005be2:	f0 1f 00 18 	mcall	80005c40 <spi_selectChip+0x74>
80005be6:	cf a0       	breq	80005bda <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005be8:	68 18       	ld.w	r8,r4[0x4]
80005bea:	ea 18 00 0f 	orh	r8,0xf
80005bee:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005bf0:	68 18       	ld.w	r8,r4[0x4]
80005bf2:	e2 18 00 04 	andl	r8,0x4,COH
80005bf6:	c1 10       	breq	80005c18 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005bf8:	30 e8       	mov	r8,14
80005bfa:	f0 03 18 00 	cp.b	r3,r8
80005bfe:	e0 8b 00 1c 	brhi	80005c36 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005c02:	68 19       	ld.w	r9,r4[0x4]
80005c04:	e6 08 15 10 	lsl	r8,r3,0x10
80005c08:	ea 18 ff f0 	orh	r8,0xfff0
80005c0c:	e8 18 ff ff 	orl	r8,0xffff
80005c10:	12 68       	and	r8,r9
80005c12:	89 18       	st.w	r4[0x4],r8
80005c14:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005c18:	30 38       	mov	r8,3
80005c1a:	f0 03 18 00 	cp.b	r3,r8
80005c1e:	e0 8b 00 0c 	brhi	80005c36 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005c22:	68 19       	ld.w	r9,r4[0x4]
80005c24:	2f 03       	sub	r3,-16
80005c26:	30 18       	mov	r8,1
80005c28:	f0 03 09 48 	lsl	r8,r8,r3
80005c2c:	5c d8       	com	r8
80005c2e:	12 68       	and	r8,r9
80005c30:	89 18       	st.w	r4[0x4],r8
80005c32:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005c36:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005c38:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005c3c:	00 00       	add	r0,r0
80005c3e:	51 88       	stdsp	sp[0x60],r8
80005c40:	80 00       	ld.sh	r0,r0[0x0]
80005c42:	63 64       	ld.w	r4,r1[0x58]

80005c44 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005c44:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005c46:	f6 08 15 04 	lsl	r8,r11,0x4
80005c4a:	14 38       	cp.w	r8,r10
80005c4c:	f9 b8 08 10 	movls	r8,16
80005c50:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005c54:	f0 0b 02 4b 	mul	r11,r8,r11
80005c58:	f6 09 16 01 	lsr	r9,r11,0x1
80005c5c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005c60:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005c64:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005c68:	f2 cb 00 01 	sub	r11,r9,1
80005c6c:	e0 4b ff fe 	cp.w	r11,65534
80005c70:	e0 88 00 03 	brls	80005c76 <usart_set_async_baudrate+0x32>
80005c74:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005c76:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005c78:	e8 6e 00 00 	mov	lr,524288
80005c7c:	59 08       	cp.w	r8,16
80005c7e:	fc 08 17 10 	movne	r8,lr
80005c82:	f9 b8 00 00 	moveq	r8,0
80005c86:	e4 1b ff f7 	andh	r11,0xfff7
80005c8a:	e0 1b fe cf 	andl	r11,0xfecf
80005c8e:	16 48       	or	r8,r11
80005c90:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005c92:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005c96:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005c9a:	99 89       	st.w	r12[0x20],r9
80005c9c:	d8 0a       	popm	pc,r12=0

80005c9e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005c9e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005ca0:	e2 18 00 02 	andl	r8,0x2,COH
80005ca4:	c0 31       	brne	80005caa <usart_write_char+0xc>
80005ca6:	30 2c       	mov	r12,2
80005ca8:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005caa:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005cae:	99 7b       	st.w	r12[0x1c],r11
80005cb0:	5e fd       	retal	0
80005cb2:	d7 03       	nop

80005cb4 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005cb4:	eb cd 40 e0 	pushm	r5-r7,lr
80005cb8:	18 96       	mov	r6,r12
80005cba:	16 95       	mov	r5,r11
80005cbc:	e0 67 27 0f 	mov	r7,9999
80005cc0:	c0 68       	rjmp	80005ccc <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005cc2:	58 07       	cp.w	r7,0
80005cc4:	c0 31       	brne	80005cca <usart_putchar+0x16>
80005cc6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005cca:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005ccc:	0a 9b       	mov	r11,r5
80005cce:	0c 9c       	mov	r12,r6
80005cd0:	f0 1f 00 03 	mcall	80005cdc <usart_putchar+0x28>
80005cd4:	cf 71       	brne	80005cc2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005cd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005cda:	00 00       	add	r0,r0
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	5c 9e       	brev	lr

80005ce0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005ce0:	78 58       	ld.w	r8,r12[0x14]
80005ce2:	e2 18 00 e0 	andl	r8,0xe0,COH
80005ce6:	c0 30       	breq	80005cec <usart_read_char+0xc>
80005ce8:	30 4c       	mov	r12,4
80005cea:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005cec:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005cee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005cf2:	c0 31       	brne	80005cf8 <usart_read_char+0x18>
80005cf4:	30 3c       	mov	r12,3
80005cf6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005cf8:	78 68       	ld.w	r8,r12[0x18]
80005cfa:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005cfe:	97 08       	st.w	r11[0x0],r8
80005d00:	5e fd       	retal	0
80005d02:	d7 03       	nop

80005d04 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005d04:	eb cd 40 c0 	pushm	r6-r7,lr
80005d08:	20 1d       	sub	sp,4
80005d0a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005d0c:	1a 97       	mov	r7,sp
80005d0e:	1a 9b       	mov	r11,sp
80005d10:	0c 9c       	mov	r12,r6
80005d12:	f0 1f 00 07 	mcall	80005d2c <usart_getchar+0x28>
80005d16:	58 3c       	cp.w	r12,3
80005d18:	cf b0       	breq	80005d0e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005d1a:	58 4c       	cp.w	r12,4
80005d1c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005d20:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005d24:	2f fd       	sub	sp,-4
80005d26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d2a:	00 00       	add	r0,r0
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	5c e0       	tnbz	r0

80005d30 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005d30:	eb cd 40 c0 	pushm	r6-r7,lr
80005d34:	18 96       	mov	r6,r12
80005d36:	16 97       	mov	r7,r11
  while (*string != '\0')
80005d38:	17 8b       	ld.ub	r11,r11[0x0]
80005d3a:	58 0b       	cp.w	r11,0
80005d3c:	c0 80       	breq	80005d4c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005d3e:	2f f7       	sub	r7,-1
80005d40:	0c 9c       	mov	r12,r6
80005d42:	f0 1f 00 04 	mcall	80005d50 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005d46:	0f 8b       	ld.ub	r11,r7[0x0]
80005d48:	58 0b       	cp.w	r11,0
80005d4a:	cf a1       	brne	80005d3e <usart_write_line+0xe>
80005d4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	5c b4       	swap.b	r4

80005d54 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005d54:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005d58:	e6 18 00 01 	andh	r8,0x1,COH
80005d5c:	c0 71       	brne	80005d6a <usart_reset+0x16>
80005d5e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005d60:	3f f8       	mov	r8,-1
80005d62:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005d64:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005d66:	d5 03       	csrf	0x10
80005d68:	c0 48       	rjmp	80005d70 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005d6a:	3f f8       	mov	r8,-1
80005d6c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005d6e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005d70:	30 08       	mov	r8,0
80005d72:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005d74:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005d76:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005d78:	ea 68 61 0c 	mov	r8,680204
80005d7c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005d7e:	5e fc       	retal	r12

80005d80 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005d80:	eb cd 40 e0 	pushm	r5-r7,lr
80005d84:	18 96       	mov	r6,r12
80005d86:	16 97       	mov	r7,r11
80005d88:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005d8a:	f0 1f 00 2f 	mcall	80005e44 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005d8e:	58 07       	cp.w	r7,0
80005d90:	c5 80       	breq	80005e40 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005d92:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005d94:	30 49       	mov	r9,4
80005d96:	f2 08 18 00 	cp.b	r8,r9
80005d9a:	e0 88 00 53 	brls	80005e40 <usart_init_rs232+0xc0>
80005d9e:	30 99       	mov	r9,9
80005da0:	f2 08 18 00 	cp.b	r8,r9
80005da4:	e0 8b 00 4e 	brhi	80005e40 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005da8:	0f d9       	ld.ub	r9,r7[0x5]
80005daa:	30 78       	mov	r8,7
80005dac:	f0 09 18 00 	cp.b	r9,r8
80005db0:	e0 8b 00 48 	brhi	80005e40 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005db4:	8e 39       	ld.sh	r9,r7[0x6]
80005db6:	e0 68 01 01 	mov	r8,257
80005dba:	f0 09 19 00 	cp.h	r9,r8
80005dbe:	e0 8b 00 41 	brhi	80005e40 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005dc2:	ef 39 00 08 	ld.ub	r9,r7[8]
80005dc6:	30 38       	mov	r8,3
80005dc8:	f0 09 18 00 	cp.b	r9,r8
80005dcc:	e0 8b 00 3a 	brhi	80005e40 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005dd0:	0a 9a       	mov	r10,r5
80005dd2:	6e 0b       	ld.w	r11,r7[0x0]
80005dd4:	0c 9c       	mov	r12,r6
80005dd6:	f0 1f 00 1d 	mcall	80005e48 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005dda:	58 1c       	cp.w	r12,1
80005ddc:	c3 20       	breq	80005e40 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005dde:	0f c8       	ld.ub	r8,r7[0x4]
80005de0:	30 99       	mov	r9,9
80005de2:	f2 08 18 00 	cp.b	r8,r9
80005de6:	c0 51       	brne	80005df0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005de8:	6c 18       	ld.w	r8,r6[0x4]
80005dea:	b1 b8       	sbr	r8,0x11
80005dec:	8d 18       	st.w	r6[0x4],r8
80005dee:	c0 68       	rjmp	80005dfa <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005df0:	6c 19       	ld.w	r9,r6[0x4]
80005df2:	20 58       	sub	r8,5
80005df4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005df8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005dfa:	6c 19       	ld.w	r9,r6[0x4]
80005dfc:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005e00:	0f d8       	ld.ub	r8,r7[0x5]
80005e02:	a9 78       	lsl	r8,0x9
80005e04:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005e08:	12 48       	or	r8,r9
80005e0a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005e0c:	8e 38       	ld.sh	r8,r7[0x6]
80005e0e:	30 29       	mov	r9,2
80005e10:	f2 08 19 00 	cp.h	r8,r9
80005e14:	e0 88 00 09 	brls	80005e26 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005e18:	6c 18       	ld.w	r8,r6[0x4]
80005e1a:	ad b8       	sbr	r8,0xd
80005e1c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005e1e:	8e b8       	ld.uh	r8,r7[0x6]
80005e20:	20 28       	sub	r8,2
80005e22:	8d a8       	st.w	r6[0x28],r8
80005e24:	c0 68       	rjmp	80005e30 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005e26:	6c 19       	ld.w	r9,r6[0x4]
80005e28:	5c 78       	castu.h	r8
80005e2a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005e2e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005e30:	6c 18       	ld.w	r8,r6[0x4]
80005e32:	e0 18 ff f0 	andl	r8,0xfff0
80005e36:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005e38:	35 08       	mov	r8,80
80005e3a:	8d 08       	st.w	r6[0x0],r8
80005e3c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005e40:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	5d 54       	*unknown*
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	5c 44       	abs	r4

80005e4c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005e4c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005e50:	fe c0 8e 50 	sub	r0,pc,-29104

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005e54:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005e58:	d5 53       	csrf	0x15
  cp      r0, r1
80005e5a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005e5c:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005e60:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005e62:	c0 62       	brcc	80005e6e <idata_load_loop_end>
  cp      r0, r1
80005e64:	48 92       	lddpc	r2,80005e88 <udata_clear_loop_end+0x4>

80005e66 <idata_load_loop>:
  brlo    idata_load_loop
80005e66:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005e68:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005e6a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005e6c:	cf d3       	brcs	80005e66 <idata_load_loop>

80005e6e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005e6e:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
80005e72:	e0 61 51 98 	mov	r1,20888
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005e76:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005e78:	c0 62       	brcc	80005e84 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005e7a:	30 02       	mov	r2,0
80005e7c:	30 03       	mov	r3,0

80005e7e <udata_clear_loop>:
80005e7e:	a1 22       	st.d	r0++,r2
80005e80:	02 30       	cp.w	r0,r1
80005e82:	cf e3       	brcs	80005e7e <udata_clear_loop>

80005e84 <udata_clear_loop_end>:
80005e84:	fe cf e9 7c 	sub	pc,pc,-5764
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	e4 30 f8 c8 	sub	r0,391368

80005e8c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005e8c:	f8 c8 ff f8 	sub	r8,r12,-8
80005e90:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005e92:	3f f9       	mov	r9,-1
80005e94:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005e96:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005e98:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005e9a:	30 08       	mov	r8,0
80005e9c:	99 08       	st.w	r12[0x0],r8
}
80005e9e:	5e fc       	retal	r12

80005ea0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005ea0:	30 08       	mov	r8,0
80005ea2:	99 48       	st.w	r12[0x10],r8
}
80005ea4:	5e fc       	retal	r12

80005ea6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005ea6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005ea8:	70 19       	ld.w	r9,r8[0x4]
80005eaa:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005eac:	78 19       	ld.w	r9,r12[0x4]
80005eae:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005eb0:	70 19       	ld.w	r9,r8[0x4]
80005eb2:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005eb4:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005eb6:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005eb8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005eba:	78 08       	ld.w	r8,r12[0x0]
80005ebc:	2f f8       	sub	r8,-1
80005ebe:	99 08       	st.w	r12[0x0],r8
}
80005ec0:	5e fc       	retal	r12

80005ec2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005ec2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005ec4:	5b fa       	cp.w	r10,-1
80005ec6:	c0 31       	brne	80005ecc <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ec8:	78 48       	ld.w	r8,r12[0x10]
80005eca:	c0 c8       	rjmp	80005ee2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ecc:	f8 c8 ff f8 	sub	r8,r12,-8
80005ed0:	70 19       	ld.w	r9,r8[0x4]
80005ed2:	72 09       	ld.w	r9,r9[0x0]
80005ed4:	12 3a       	cp.w	r10,r9
80005ed6:	c0 63       	brcs	80005ee2 <vListInsert+0x20>
80005ed8:	70 18       	ld.w	r8,r8[0x4]
80005eda:	70 19       	ld.w	r9,r8[0x4]
80005edc:	72 09       	ld.w	r9,r9[0x0]
80005ede:	12 3a       	cp.w	r10,r9
80005ee0:	cf c2       	brcc	80005ed8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005ee2:	70 19       	ld.w	r9,r8[0x4]
80005ee4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ee6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005ee8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005eea:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005eec:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005eee:	78 08       	ld.w	r8,r12[0x0]
80005ef0:	2f f8       	sub	r8,-1
80005ef2:	99 08       	st.w	r12[0x0],r8
}
80005ef4:	5e fc       	retal	r12

80005ef6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ef6:	78 18       	ld.w	r8,r12[0x4]
80005ef8:	78 29       	ld.w	r9,r12[0x8]
80005efa:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005efc:	78 28       	ld.w	r8,r12[0x8]
80005efe:	78 19       	ld.w	r9,r12[0x4]
80005f00:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005f02:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005f04:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005f06:	18 39       	cp.w	r9,r12
80005f08:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005f0c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005f10:	30 09       	mov	r9,0
80005f12:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005f14:	70 09       	ld.w	r9,r8[0x0]
80005f16:	20 19       	sub	r9,1
80005f18:	91 09       	st.w	r8[0x0],r9
}
80005f1a:	5e fc       	retal	r12

80005f1c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005f1c:	e0 68 08 08 	mov	r8,2056
80005f20:	ea 18 08 08 	orh	r8,0x808
80005f24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005f26:	e0 68 09 09 	mov	r8,2313
80005f2a:	ea 18 09 09 	orh	r8,0x909
80005f2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005f30:	e0 68 0a 0a 	mov	r8,2570
80005f34:	ea 18 0a 0a 	orh	r8,0xa0a
80005f38:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005f3a:	e0 68 0b 0b 	mov	r8,2827
80005f3e:	ea 18 0b 0b 	orh	r8,0xb0b
80005f42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005f44:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005f46:	e0 68 be ef 	mov	r8,48879
80005f4a:	ea 18 de ad 	orh	r8,0xdead
80005f4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005f50:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005f52:	fc 18 00 40 	movh	r8,0x40
80005f56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005f58:	e0 68 00 ff 	mov	r8,255
80005f5c:	ea 18 ff 00 	orh	r8,0xff00
80005f60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005f62:	e0 68 01 01 	mov	r8,257
80005f66:	ea 18 01 01 	orh	r8,0x101
80005f6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005f6c:	e0 68 02 02 	mov	r8,514
80005f70:	ea 18 02 02 	orh	r8,0x202
80005f74:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005f76:	e0 68 03 03 	mov	r8,771
80005f7a:	ea 18 03 03 	orh	r8,0x303
80005f7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005f80:	e0 68 04 04 	mov	r8,1028
80005f84:	ea 18 04 04 	orh	r8,0x404
80005f88:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005f8a:	e0 68 05 05 	mov	r8,1285
80005f8e:	ea 18 05 05 	orh	r8,0x505
80005f92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005f94:	e0 68 06 06 	mov	r8,1542
80005f98:	ea 18 06 06 	orh	r8,0x606
80005f9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005f9e:	e0 68 07 07 	mov	r8,1799
80005fa2:	ea 18 07 07 	orh	r8,0x707
80005fa6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005fa8:	30 08       	mov	r8,0
80005faa:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005fac:	5e fc       	retal	r12
80005fae:	d7 03       	nop

80005fb0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005fb0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005fb2:	48 38       	lddpc	r8,80005fbc <vPortEnterCritical+0xc>
80005fb4:	70 09       	ld.w	r9,r8[0x0]
80005fb6:	2f f9       	sub	r9,-1
80005fb8:	91 09       	st.w	r8[0x0],r9
}
80005fba:	5e fc       	retal	r12
80005fbc:	00 00       	add	r0,r0
80005fbe:	05 40       	ld.w	r0,--r2

80005fc0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005fc0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005fc2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005fc4:	30 0a       	mov	r10,0
80005fc6:	14 9b       	mov	r11,r10
80005fc8:	49 2c       	lddpc	r12,80006010 <xPortStartScheduler+0x50>
80005fca:	f0 1f 00 13 	mcall	80006014 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005fce:	e0 68 5d c0 	mov	r8,24000
80005fd2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005fd6:	30 08       	mov	r8,0
80005fd8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005fdc:	e0 68 0d 44 	mov	r8,3396
80005fe0:	ea 18 00 00 	orh	r8,0x0
80005fe4:	70 00       	ld.w	r0,r8[0x0]
80005fe6:	60 0d       	ld.w	sp,r0[0x0]
80005fe8:	1b 00       	ld.w	r0,sp++
80005fea:	e0 68 05 40 	mov	r8,1344
80005fee:	ea 18 00 00 	orh	r8,0x0
80005ff2:	91 00       	st.w	r8[0x0],r0
80005ff4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ff8:	2f ed       	sub	sp,-8
80005ffa:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005ffe:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006002:	e3 b0 00 00 	mtsr	0x0,r0
80006006:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000600a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000600e:	d8 0a       	popm	pc,r12=0
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	60 dc       	ld.w	r12,r0[0x34]
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	58 d0       	cp.w	r0,13

80006018 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006018:	20 6d       	sub	sp,24
8000601a:	eb cd 00 ff 	pushm	r0-r7
8000601e:	fa c7 ff c0 	sub	r7,sp,-64
80006022:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006026:	ef 40 ff e0 	st.w	r7[-32],r0
8000602a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000602e:	ef 40 ff e4 	st.w	r7[-28],r0
80006032:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006036:	e0 68 05 40 	mov	r8,1344
8000603a:	ea 18 00 00 	orh	r8,0x0
8000603e:	70 00       	ld.w	r0,r8[0x0]
80006040:	1a d0       	st.w	--sp,r0
80006042:	f0 1f 00 1a 	mcall	800060a8 <LABEL_RET_SCALL_263+0x14>
80006046:	e0 68 0d 44 	mov	r8,3396
8000604a:	ea 18 00 00 	orh	r8,0x0
8000604e:	70 00       	ld.w	r0,r8[0x0]
80006050:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006052:	f0 1f 00 17 	mcall	800060ac <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006056:	e0 68 0d 44 	mov	r8,3396
8000605a:	ea 18 00 00 	orh	r8,0x0
8000605e:	70 00       	ld.w	r0,r8[0x0]
80006060:	60 0d       	ld.w	sp,r0[0x0]
80006062:	1b 00       	ld.w	r0,sp++
80006064:	e0 68 05 40 	mov	r8,1344
80006068:	ea 18 00 00 	orh	r8,0x0
8000606c:	91 00       	st.w	r8[0x0],r0
8000606e:	fa c7 ff d8 	sub	r7,sp,-40
80006072:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006076:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000607a:	e0 61 05 40 	mov	r1,1344
8000607e:	ea 11 00 00 	orh	r1,0x0
80006082:	62 02       	ld.w	r2,r1[0x0]
80006084:	58 02       	cp.w	r2,0
80006086:	c0 70       	breq	80006094 <LABEL_RET_SCALL_263>
80006088:	e4 c2 00 01 	sub	r2,r2,1
8000608c:	83 02       	st.w	r1[0x0],r2
8000608e:	58 02       	cp.w	r2,0
80006090:	c0 21       	brne	80006094 <LABEL_RET_SCALL_263>
80006092:	b1 c0       	cbr	r0,0x10

80006094 <LABEL_RET_SCALL_263>:
80006094:	ef 40 ff f8 	st.w	r7[-8],r0
80006098:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000609c:	ef 40 ff fc 	st.w	r7[-4],r0
800060a0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800060a4:	2f ad       	sub	sp,-24
800060a6:	d6 13       	rets
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	5f b0       	srhi	r0
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	66 f4       	ld.w	r4,r3[0x3c]

800060b0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800060b0:	e1 b8 00 43 	mfsr	r8,0x10c
800060b4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800060b8:	5e fc       	retal	r12
800060ba:	d7 03       	nop

800060bc <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800060bc:	48 78       	lddpc	r8,800060d8 <vPortExitCritical+0x1c>
800060be:	70 08       	ld.w	r8,r8[0x0]
800060c0:	58 08       	cp.w	r8,0
800060c2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800060c4:	48 58       	lddpc	r8,800060d8 <vPortExitCritical+0x1c>
800060c6:	70 09       	ld.w	r9,r8[0x0]
800060c8:	20 19       	sub	r9,1
800060ca:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800060cc:	70 08       	ld.w	r8,r8[0x0]
800060ce:	58 08       	cp.w	r8,0
800060d0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800060d2:	d5 03       	csrf	0x10
800060d4:	5e fc       	retal	r12
800060d6:	00 00       	add	r0,r0
800060d8:	00 00       	add	r0,r0
800060da:	05 40       	ld.w	r0,--r2

800060dc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800060dc:	eb cd 00 ff 	pushm	r0-r7
800060e0:	e0 68 05 40 	mov	r8,1344
800060e4:	ea 18 00 00 	orh	r8,0x0
800060e8:	70 00       	ld.w	r0,r8[0x0]
800060ea:	1a d0       	st.w	--sp,r0
800060ec:	7a 90       	ld.w	r0,sp[0x24]
800060ee:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800060f2:	58 10       	cp.w	r0,1
800060f4:	e0 8b 00 08 	brhi	80006104 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800060f8:	e0 68 0d 44 	mov	r8,3396
800060fc:	ea 18 00 00 	orh	r8,0x0
80006100:	70 00       	ld.w	r0,r8[0x0]
80006102:	81 0d       	st.w	r0[0x0],sp

80006104 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006104:	f0 1f 00 12 	mcall	8000614c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006108:	f0 1f 00 12 	mcall	80006150 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000610c:	f0 1f 00 12 	mcall	80006154 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006110:	f0 1f 00 12 	mcall	80006158 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006114:	7a 90       	ld.w	r0,sp[0x24]
80006116:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000611a:	58 10       	cp.w	r0,1
8000611c:	e0 8b 00 0e 	brhi	80006138 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006120:	f0 1f 00 0c 	mcall	80006150 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006124:	f0 1f 00 0e 	mcall	8000615c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006128:	f0 1f 00 0c 	mcall	80006158 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000612c:	e0 68 0d 44 	mov	r8,3396
80006130:	ea 18 00 00 	orh	r8,0x0
80006134:	70 00       	ld.w	r0,r8[0x0]
80006136:	60 0d       	ld.w	sp,r0[0x0]

80006138 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006138:	1b 00       	ld.w	r0,sp++
8000613a:	e0 68 05 40 	mov	r8,1344
8000613e:	ea 18 00 00 	orh	r8,0x0
80006142:	91 00       	st.w	r8[0x0],r0
80006144:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006148:	d6 03       	rete
8000614a:	00 00       	add	r0,r0
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	60 b0       	ld.w	r0,r0[0x2c]
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	5f b0       	srhi	r0
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	68 f8       	ld.w	r8,r4[0x3c]
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	60 bc       	ld.w	r12,r0[0x2c]
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	66 f4       	ld.w	r4,r3[0x3c]

80006160 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006160:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006162:	f0 1f 00 02 	mcall	80006168 <__malloc_lock+0x8>
}
80006166:	d8 02       	popm	pc
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	66 e4       	ld.w	r4,r3[0x38]

8000616c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000616c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000616e:	f0 1f 00 02 	mcall	80006174 <__malloc_unlock+0x8>
}
80006172:	d8 02       	popm	pc
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	6a a0       	ld.w	r0,r5[0x28]

80006178 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006178:	d4 21       	pushm	r4-r7,lr
8000617a:	16 95       	mov	r5,r11
8000617c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000617e:	58 0c       	cp.w	r12,0
80006180:	c0 30       	breq	80006186 <_read+0xe>
80006182:	3f f7       	mov	r7,-1
80006184:	c1 48       	rjmp	800061ac <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006186:	58 0a       	cp.w	r10,0
80006188:	e0 89 00 04 	brgt	80006190 <_read+0x18>
8000618c:	30 07       	mov	r7,0
8000618e:	c0 f8       	rjmp	800061ac <_read+0x34>
80006190:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006192:	48 84       	lddpc	r4,800061b0 <_read+0x38>
80006194:	68 0c       	ld.w	r12,r4[0x0]
80006196:	f0 1f 00 08 	mcall	800061b4 <_read+0x3c>
    if (c < 0)
8000619a:	c0 95       	brlt	800061ac <_read+0x34>
      break;

    *ptr++ = c;
8000619c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800061a0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800061a2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800061a6:	58 08       	cp.w	r8,0
800061a8:	fe 99 ff f6 	brgt	80006194 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800061ac:	0e 9c       	mov	r12,r7
800061ae:	d8 22       	popm	r4-r7,pc
800061b0:	00 00       	add	r0,r0
800061b2:	51 8c       	stdsp	sp[0x60],r12
800061b4:	80 00       	ld.sh	r0,r0[0x0]
800061b6:	5d 04       	ror	r4

800061b8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800061b8:	d4 21       	pushm	r4-r7,lr
800061ba:	16 95       	mov	r5,r11
800061bc:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800061be:	20 1c       	sub	r12,1
800061c0:	58 2c       	cp.w	r12,2
800061c2:	e0 8b 00 12 	brhi	800061e6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800061c6:	58 0a       	cp.w	r10,0
800061c8:	c0 31       	brne	800061ce <_write+0x16>
800061ca:	30 07       	mov	r7,0
800061cc:	c0 e8       	rjmp	800061e8 <_write+0x30>
800061ce:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800061d0:	48 74       	lddpc	r4,800061ec <_write+0x34>
800061d2:	68 0c       	ld.w	r12,r4[0x0]
800061d4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800061d8:	f0 1f 00 06 	mcall	800061f0 <_write+0x38>
800061dc:	c0 55       	brlt	800061e6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800061de:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800061e0:	0e 36       	cp.w	r6,r7
800061e2:	cf 81       	brne	800061d2 <_write+0x1a>
800061e4:	c0 28       	rjmp	800061e8 <_write+0x30>
800061e6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800061e8:	0e 9c       	mov	r12,r7
800061ea:	d8 22       	popm	r4-r7,pc
800061ec:	00 00       	add	r0,r0
800061ee:	51 8c       	stdsp	sp[0x60],r12
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	5c b4       	swap.b	r4

800061f4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800061f4:	eb cd 40 80 	pushm	r7,lr
800061f8:	18 97       	mov	r7,r12
	if( pv )
800061fa:	58 0c       	cp.w	r12,0
800061fc:	c0 80       	breq	8000620c <vPortFree+0x18>
	{
		vTaskSuspendAll();
800061fe:	f0 1f 00 05 	mcall	80006210 <vPortFree+0x1c>
		{
			free( pv );
80006202:	0e 9c       	mov	r12,r7
80006204:	f0 1f 00 04 	mcall	80006214 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006208:	f0 1f 00 04 	mcall	80006218 <vPortFree+0x24>
8000620c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	66 e4       	ld.w	r4,r3[0x38]
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	75 78       	ld.w	r8,r10[0x5c]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	6a a0       	ld.w	r0,r5[0x28]

8000621c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000621c:	eb cd 40 80 	pushm	r7,lr
80006220:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006222:	f0 1f 00 06 	mcall	80006238 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006226:	0e 9c       	mov	r12,r7
80006228:	f0 1f 00 05 	mcall	8000623c <pvPortMalloc+0x20>
8000622c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000622e:	f0 1f 00 05 	mcall	80006240 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006232:	0e 9c       	mov	r12,r7
80006234:	e3 cd 80 80 	ldm	sp++,r7,pc
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	66 e4       	ld.w	r4,r3[0x38]
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	75 88       	ld.w	r8,r10[0x60]
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	6a a0       	ld.w	r0,r5[0x28]

80006244 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006244:	d4 01       	pushm	lr
80006246:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006248:	78 09       	ld.w	r9,r12[0x0]
8000624a:	58 09       	cp.w	r9,0
8000624c:	c1 10       	breq	8000626e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000624e:	78 3a       	ld.w	r10,r12[0xc]
80006250:	79 09       	ld.w	r9,r12[0x40]
80006252:	f4 09 00 09 	add	r9,r10,r9
80006256:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006258:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000625a:	14 39       	cp.w	r9,r10
8000625c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006260:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006264:	79 0a       	ld.w	r10,r12[0x40]
80006266:	78 3b       	ld.w	r11,r12[0xc]
80006268:	10 9c       	mov	r12,r8
8000626a:	f0 1f 00 02 	mcall	80006270 <prvCopyDataFromQueue+0x2c>
8000626e:	d8 02       	popm	pc
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	79 f6       	ld.w	r6,r12[0x7c]

80006274 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006274:	eb cd 40 c0 	pushm	r6-r7,lr
80006278:	18 97       	mov	r7,r12
8000627a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000627c:	78 e8       	ld.w	r8,r12[0x38]
8000627e:	58 08       	cp.w	r8,0
80006280:	c0 31       	brne	80006286 <xQueueReceiveFromISR+0x12>
80006282:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006286:	f0 1f 00 0e 	mcall	800062bc <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000628a:	6e e8       	ld.w	r8,r7[0x38]
8000628c:	20 18       	sub	r8,1
8000628e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006290:	6f 18       	ld.w	r8,r7[0x44]
80006292:	5b f8       	cp.w	r8,-1
80006294:	c0 d1       	brne	800062ae <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006296:	6e 48       	ld.w	r8,r7[0x10]
80006298:	58 08       	cp.w	r8,0
8000629a:	c0 f0       	breq	800062b8 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000629c:	ee cc ff f0 	sub	r12,r7,-16
800062a0:	f0 1f 00 08 	mcall	800062c0 <xQueueReceiveFromISR+0x4c>
800062a4:	c0 a0       	breq	800062b8 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800062a6:	30 1c       	mov	r12,1
800062a8:	8d 0c       	st.w	r6[0x0],r12
800062aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800062ae:	2f f8       	sub	r8,-1
800062b0:	ef 48 00 44 	st.w	r7[68],r8
800062b4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800062b8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	62 44       	ld.w	r4,r1[0x10]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	68 7c       	ld.w	r12,r4[0x1c]

800062c4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800062c4:	eb cd 40 c0 	pushm	r6-r7,lr
800062c8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800062ca:	f0 1f 00 23 	mcall	80006354 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800062ce:	6f 28       	ld.w	r8,r7[0x48]
800062d0:	58 08       	cp.w	r8,0
800062d2:	e0 8a 00 18 	brle	80006302 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062d6:	6e 98       	ld.w	r8,r7[0x24]
800062d8:	58 08       	cp.w	r8,0
800062da:	c1 40       	breq	80006302 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800062dc:	ee c6 ff dc 	sub	r6,r7,-36
800062e0:	c0 48       	rjmp	800062e8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062e2:	6e 98       	ld.w	r8,r7[0x24]
800062e4:	58 08       	cp.w	r8,0
800062e6:	c0 e0       	breq	80006302 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800062e8:	0c 9c       	mov	r12,r6
800062ea:	f0 1f 00 1c 	mcall	80006358 <prvUnlockQueue+0x94>
800062ee:	c0 30       	breq	800062f4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800062f0:	f0 1f 00 1b 	mcall	8000635c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800062f4:	6f 28       	ld.w	r8,r7[0x48]
800062f6:	20 18       	sub	r8,1
800062f8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800062fc:	58 08       	cp.w	r8,0
800062fe:	fe 99 ff f2 	brgt	800062e2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006302:	3f f8       	mov	r8,-1
80006304:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006308:	f0 1f 00 16 	mcall	80006360 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000630c:	f0 1f 00 12 	mcall	80006354 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006310:	6f 18       	ld.w	r8,r7[0x44]
80006312:	58 08       	cp.w	r8,0
80006314:	e0 8a 00 18 	brle	80006344 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006318:	6e 48       	ld.w	r8,r7[0x10]
8000631a:	58 08       	cp.w	r8,0
8000631c:	c1 40       	breq	80006344 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000631e:	ee c6 ff f0 	sub	r6,r7,-16
80006322:	c0 48       	rjmp	8000632a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006324:	6e 48       	ld.w	r8,r7[0x10]
80006326:	58 08       	cp.w	r8,0
80006328:	c0 e0       	breq	80006344 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000632a:	0c 9c       	mov	r12,r6
8000632c:	f0 1f 00 0b 	mcall	80006358 <prvUnlockQueue+0x94>
80006330:	c0 30       	breq	80006336 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006332:	f0 1f 00 0b 	mcall	8000635c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006336:	6f 18       	ld.w	r8,r7[0x44]
80006338:	20 18       	sub	r8,1
8000633a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000633e:	58 08       	cp.w	r8,0
80006340:	fe 99 ff f2 	brgt	80006324 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006344:	3f f8       	mov	r8,-1
80006346:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000634a:	f0 1f 00 06 	mcall	80006360 <prvUnlockQueue+0x9c>
}
8000634e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006352:	00 00       	add	r0,r0
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	5f b0       	srhi	r0
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	68 7c       	ld.w	r12,r4[0x1c]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	67 88       	ld.w	r8,r3[0x60]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	60 bc       	ld.w	r12,r0[0x2c]

80006364 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006364:	d4 31       	pushm	r0-r7,lr
80006366:	20 5d       	sub	sp,20
80006368:	18 97       	mov	r7,r12
8000636a:	50 0b       	stdsp	sp[0x0],r11
8000636c:	50 2a       	stdsp	sp[0x8],r10
8000636e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006370:	f8 c2 ff dc 	sub	r2,r12,-36
80006374:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006376:	fa c4 ff f4 	sub	r4,sp,-12
8000637a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000637c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000637e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006382:	f0 1f 00 3e 	mcall	80006478 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006386:	6e e8       	ld.w	r8,r7[0x38]
80006388:	58 08       	cp.w	r8,0
8000638a:	c2 a0       	breq	800063de <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000638c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000638e:	40 0b       	lddsp	r11,sp[0x0]
80006390:	0e 9c       	mov	r12,r7
80006392:	f0 1f 00 3b 	mcall	8000647c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006396:	40 18       	lddsp	r8,sp[0x4]
80006398:	58 08       	cp.w	r8,0
8000639a:	c1 51       	brne	800063c4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000639c:	6e e8       	ld.w	r8,r7[0x38]
8000639e:	20 18       	sub	r8,1
800063a0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800063a2:	6e 08       	ld.w	r8,r7[0x0]
800063a4:	58 08       	cp.w	r8,0
800063a6:	c0 41       	brne	800063ae <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800063a8:	f0 1f 00 36 	mcall	80006480 <xQueueGenericReceive+0x11c>
800063ac:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800063ae:	6e 48       	ld.w	r8,r7[0x10]
800063b0:	58 08       	cp.w	r8,0
800063b2:	c1 20       	breq	800063d6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800063b4:	ee cc ff f0 	sub	r12,r7,-16
800063b8:	f0 1f 00 33 	mcall	80006484 <xQueueGenericReceive+0x120>
800063bc:	58 1c       	cp.w	r12,1
800063be:	c0 c1       	brne	800063d6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800063c0:	d7 33       	scall
800063c2:	c0 a8       	rjmp	800063d6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800063c4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063c6:	6e 98       	ld.w	r8,r7[0x24]
800063c8:	58 08       	cp.w	r8,0
800063ca:	c0 60       	breq	800063d6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800063cc:	04 9c       	mov	r12,r2
800063ce:	f0 1f 00 2e 	mcall	80006484 <xQueueGenericReceive+0x120>
800063d2:	c0 20       	breq	800063d6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800063d4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800063d6:	f0 1f 00 2d 	mcall	80006488 <xQueueGenericReceive+0x124>
800063da:	30 1c       	mov	r12,1
				return pdPASS;
800063dc:	c4 c8       	rjmp	80006474 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063de:	40 28       	lddsp	r8,sp[0x8]
800063e0:	58 08       	cp.w	r8,0
800063e2:	c0 51       	brne	800063ec <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800063e4:	f0 1f 00 29 	mcall	80006488 <xQueueGenericReceive+0x124>
800063e8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800063ea:	c4 58       	rjmp	80006474 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800063ec:	58 05       	cp.w	r5,0
800063ee:	c0 51       	brne	800063f8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063f0:	08 9c       	mov	r12,r4
800063f2:	f0 1f 00 27 	mcall	8000648c <xQueueGenericReceive+0x128>
800063f6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800063f8:	f0 1f 00 24 	mcall	80006488 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800063fc:	f0 1f 00 25 	mcall	80006490 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006400:	f0 1f 00 1e 	mcall	80006478 <xQueueGenericReceive+0x114>
80006404:	6f 18       	ld.w	r8,r7[0x44]
80006406:	5b f8       	cp.w	r8,-1
80006408:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000640c:	6f 28       	ld.w	r8,r7[0x48]
8000640e:	5b f8       	cp.w	r8,-1
80006410:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006414:	f0 1f 00 1d 	mcall	80006488 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006418:	06 9b       	mov	r11,r3
8000641a:	08 9c       	mov	r12,r4
8000641c:	f0 1f 00 1e 	mcall	80006494 <xQueueGenericReceive+0x130>
80006420:	c2 41       	brne	80006468 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006422:	f0 1f 00 16 	mcall	80006478 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006426:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006428:	f0 1f 00 18 	mcall	80006488 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000642c:	58 06       	cp.w	r6,0
8000642e:	c1 71       	brne	8000645c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006430:	6e 08       	ld.w	r8,r7[0x0]
80006432:	58 08       	cp.w	r8,0
80006434:	c0 81       	brne	80006444 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006436:	f0 1f 00 11 	mcall	80006478 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000643a:	6e 1c       	ld.w	r12,r7[0x4]
8000643c:	f0 1f 00 17 	mcall	80006498 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006440:	f0 1f 00 12 	mcall	80006488 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006444:	40 2b       	lddsp	r11,sp[0x8]
80006446:	04 9c       	mov	r12,r2
80006448:	f0 1f 00 15 	mcall	8000649c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000644c:	0e 9c       	mov	r12,r7
8000644e:	f0 1f 00 15 	mcall	800064a0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006452:	f0 1f 00 15 	mcall	800064a4 <xQueueGenericReceive+0x140>
80006456:	c9 61       	brne	80006382 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006458:	d7 33       	scall
8000645a:	c9 4b       	rjmp	80006382 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000645c:	0e 9c       	mov	r12,r7
8000645e:	f0 1f 00 11 	mcall	800064a0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006462:	f0 1f 00 11 	mcall	800064a4 <xQueueGenericReceive+0x140>
80006466:	c8 eb       	rjmp	80006382 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006468:	0e 9c       	mov	r12,r7
8000646a:	f0 1f 00 0e 	mcall	800064a0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000646e:	f0 1f 00 0e 	mcall	800064a4 <xQueueGenericReceive+0x140>
80006472:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006474:	2f bd       	sub	sp,-20
80006476:	d8 32       	popm	r0-r7,pc
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	5f b0       	srhi	r0
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	62 44       	ld.w	r4,r1[0x10]
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	67 94       	ld.w	r4,r3[0x64]
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	68 7c       	ld.w	r12,r4[0x1c]
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	60 bc       	ld.w	r12,r0[0x2c]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	67 70       	ld.w	r0,r3[0x5c]
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	66 e4       	ld.w	r4,r3[0x38]
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	6a 0c       	ld.w	r12,r5[0x0]
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	67 f8       	ld.w	r8,r3[0x7c]
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	6c ac       	ld.w	r12,r6[0x28]
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	62 c4       	ld.w	r4,r1[0x30]
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	6a a0       	ld.w	r0,r5[0x28]

800064a8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800064a8:	eb cd 40 80 	pushm	r7,lr
800064ac:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800064ae:	79 08       	ld.w	r8,r12[0x40]
800064b0:	58 08       	cp.w	r8,0
800064b2:	c0 a1       	brne	800064c6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800064b4:	78 08       	ld.w	r8,r12[0x0]
800064b6:	58 08       	cp.w	r8,0
800064b8:	c2 b1       	brne	8000650e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800064ba:	78 1c       	ld.w	r12,r12[0x4]
800064bc:	f0 1f 00 17 	mcall	80006518 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800064c0:	30 08       	mov	r8,0
800064c2:	8f 18       	st.w	r7[0x4],r8
800064c4:	c2 58       	rjmp	8000650e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800064c6:	58 0a       	cp.w	r10,0
800064c8:	c1 01       	brne	800064e8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800064ca:	10 9a       	mov	r10,r8
800064cc:	78 2c       	ld.w	r12,r12[0x8]
800064ce:	f0 1f 00 14 	mcall	8000651c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800064d2:	6e 29       	ld.w	r9,r7[0x8]
800064d4:	6f 08       	ld.w	r8,r7[0x40]
800064d6:	f2 08 00 08 	add	r8,r9,r8
800064da:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800064dc:	6e 19       	ld.w	r9,r7[0x4]
800064de:	12 38       	cp.w	r8,r9
800064e0:	c1 73       	brcs	8000650e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800064e2:	6e 08       	ld.w	r8,r7[0x0]
800064e4:	8f 28       	st.w	r7[0x8],r8
800064e6:	c1 48       	rjmp	8000650e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800064e8:	10 9a       	mov	r10,r8
800064ea:	78 3c       	ld.w	r12,r12[0xc]
800064ec:	f0 1f 00 0c 	mcall	8000651c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800064f0:	6f 08       	ld.w	r8,r7[0x40]
800064f2:	6e 39       	ld.w	r9,r7[0xc]
800064f4:	f2 08 01 08 	sub	r8,r9,r8
800064f8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800064fa:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800064fc:	12 38       	cp.w	r8,r9
800064fe:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006502:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006506:	f3 d8 e3 19 	subcs	r9,r9,r8
8000650a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000650e:	6e e8       	ld.w	r8,r7[0x38]
80006510:	2f f8       	sub	r8,-1
80006512:	8f e8       	st.w	r7[0x38],r8
}
80006514:	e3 cd 80 80 	ldm	sp++,r7,pc
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	67 a0       	ld.w	r0,r3[0x68]
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	79 f6       	ld.w	r6,r12[0x7c]

80006520 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006520:	eb cd 40 c0 	pushm	r6-r7,lr
80006524:	18 97       	mov	r7,r12
80006526:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006528:	78 ec       	ld.w	r12,r12[0x38]
8000652a:	6e f8       	ld.w	r8,r7[0x3c]
8000652c:	10 3c       	cp.w	r12,r8
8000652e:	c0 33       	brcs	80006534 <xQueueGenericSendFromISR+0x14>
80006530:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006534:	12 9a       	mov	r10,r9
80006536:	0e 9c       	mov	r12,r7
80006538:	f0 1f 00 0c 	mcall	80006568 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000653c:	6f 28       	ld.w	r8,r7[0x48]
8000653e:	5b f8       	cp.w	r8,-1
80006540:	c0 d1       	brne	8000655a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006542:	6e 98       	ld.w	r8,r7[0x24]
80006544:	58 08       	cp.w	r8,0
80006546:	c0 f0       	breq	80006564 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006548:	ee cc ff dc 	sub	r12,r7,-36
8000654c:	f0 1f 00 08 	mcall	8000656c <xQueueGenericSendFromISR+0x4c>
80006550:	c0 a0       	breq	80006564 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006552:	30 1c       	mov	r12,1
80006554:	8d 0c       	st.w	r6[0x0],r12
80006556:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000655a:	2f f8       	sub	r8,-1
8000655c:	ef 48 00 48 	st.w	r7[72],r8
80006560:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006564:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	64 a8       	ld.w	r8,r2[0x28]
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	68 7c       	ld.w	r12,r4[0x1c]

80006570 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006570:	d4 31       	pushm	r0-r7,lr
80006572:	20 5d       	sub	sp,20
80006574:	18 97       	mov	r7,r12
80006576:	50 0b       	stdsp	sp[0x0],r11
80006578:	50 2a       	stdsp	sp[0x8],r10
8000657a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000657c:	f8 c0 ff f0 	sub	r0,r12,-16
80006580:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006582:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006586:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006588:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000658c:	f0 1f 00 2f 	mcall	80006648 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006590:	6e e9       	ld.w	r9,r7[0x38]
80006592:	6e f8       	ld.w	r8,r7[0x3c]
80006594:	10 39       	cp.w	r9,r8
80006596:	c1 42       	brcc	800065be <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006598:	40 1a       	lddsp	r10,sp[0x4]
8000659a:	40 0b       	lddsp	r11,sp[0x0]
8000659c:	0e 9c       	mov	r12,r7
8000659e:	f0 1f 00 2c 	mcall	8000664c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800065a2:	6e 98       	ld.w	r8,r7[0x24]
800065a4:	58 08       	cp.w	r8,0
800065a6:	c0 80       	breq	800065b6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800065a8:	ee cc ff dc 	sub	r12,r7,-36
800065ac:	f0 1f 00 29 	mcall	80006650 <xQueueGenericSend+0xe0>
800065b0:	58 1c       	cp.w	r12,1
800065b2:	c0 21       	brne	800065b6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800065b4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800065b6:	f0 1f 00 28 	mcall	80006654 <xQueueGenericSend+0xe4>
800065ba:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800065bc:	c4 38       	rjmp	80006642 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800065be:	40 28       	lddsp	r8,sp[0x8]
800065c0:	58 08       	cp.w	r8,0
800065c2:	c0 51       	brne	800065cc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800065c4:	f0 1f 00 24 	mcall	80006654 <xQueueGenericSend+0xe4>
800065c8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800065ca:	c3 c8       	rjmp	80006642 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800065cc:	58 04       	cp.w	r4,0
800065ce:	c0 51       	brne	800065d8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800065d0:	06 9c       	mov	r12,r3
800065d2:	f0 1f 00 22 	mcall	80006658 <xQueueGenericSend+0xe8>
800065d6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800065d8:	f0 1f 00 1f 	mcall	80006654 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800065dc:	f0 1f 00 20 	mcall	8000665c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800065e0:	f0 1f 00 1a 	mcall	80006648 <xQueueGenericSend+0xd8>
800065e4:	6f 18       	ld.w	r8,r7[0x44]
800065e6:	5b f8       	cp.w	r8,-1
800065e8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800065ec:	6f 28       	ld.w	r8,r7[0x48]
800065ee:	5b f8       	cp.w	r8,-1
800065f0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800065f4:	f0 1f 00 18 	mcall	80006654 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800065f8:	04 9b       	mov	r11,r2
800065fa:	06 9c       	mov	r12,r3
800065fc:	f0 1f 00 19 	mcall	80006660 <xQueueGenericSend+0xf0>
80006600:	c1 b1       	brne	80006636 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006602:	f0 1f 00 12 	mcall	80006648 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006606:	6e e5       	ld.w	r5,r7[0x38]
80006608:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000660a:	f0 1f 00 13 	mcall	80006654 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000660e:	0c 35       	cp.w	r5,r6
80006610:	c0 d1       	brne	8000662a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006612:	40 2b       	lddsp	r11,sp[0x8]
80006614:	00 9c       	mov	r12,r0
80006616:	f0 1f 00 14 	mcall	80006664 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000661a:	0e 9c       	mov	r12,r7
8000661c:	f0 1f 00 13 	mcall	80006668 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006620:	f0 1f 00 13 	mcall	8000666c <xQueueGenericSend+0xfc>
80006624:	cb 41       	brne	8000658c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006626:	d7 33       	scall
80006628:	cb 2b       	rjmp	8000658c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000662a:	0e 9c       	mov	r12,r7
8000662c:	f0 1f 00 0f 	mcall	80006668 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006630:	f0 1f 00 0f 	mcall	8000666c <xQueueGenericSend+0xfc>
80006634:	ca cb       	rjmp	8000658c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006636:	0e 9c       	mov	r12,r7
80006638:	f0 1f 00 0c 	mcall	80006668 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000663c:	f0 1f 00 0c 	mcall	8000666c <xQueueGenericSend+0xfc>
80006640:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006642:	2f bd       	sub	sp,-20
80006644:	d8 32       	popm	r0-r7,pc
80006646:	00 00       	add	r0,r0
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	5f b0       	srhi	r0
8000664c:	80 00       	ld.sh	r0,r0[0x0]
8000664e:	64 a8       	ld.w	r8,r2[0x28]
80006650:	80 00       	ld.sh	r0,r0[0x0]
80006652:	68 7c       	ld.w	r12,r4[0x1c]
80006654:	80 00       	ld.sh	r0,r0[0x0]
80006656:	60 bc       	ld.w	r12,r0[0x2c]
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	67 70       	ld.w	r0,r3[0x5c]
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	66 e4       	ld.w	r4,r3[0x38]
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	6a 0c       	ld.w	r12,r5[0x0]
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	6c ac       	ld.w	r12,r6[0x28]
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	62 c4       	ld.w	r4,r1[0x30]
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	6a a0       	ld.w	r0,r5[0x28]

80006670 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006670:	d4 21       	pushm	r4-r7,lr
80006672:	18 97       	mov	r7,r12
80006674:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006676:	58 0c       	cp.w	r12,0
80006678:	c2 f0       	breq	800066d6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000667a:	34 cc       	mov	r12,76
8000667c:	f0 1f 00 17 	mcall	800066d8 <xQueueCreate+0x68>
80006680:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006682:	c2 a0       	breq	800066d6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006684:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006688:	e8 cc ff ff 	sub	r12,r4,-1
8000668c:	f0 1f 00 13 	mcall	800066d8 <xQueueCreate+0x68>
80006690:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006692:	c1 e0       	breq	800066ce <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006694:	f8 04 00 04 	add	r4,r12,r4
80006698:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000669a:	30 08       	mov	r8,0
8000669c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000669e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800066a0:	ee c8 00 01 	sub	r8,r7,1
800066a4:	ad 38       	mul	r8,r6
800066a6:	10 0c       	add	r12,r8
800066a8:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800066aa:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800066ac:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800066b0:	3f f8       	mov	r8,-1
800066b2:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800066b6:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800066ba:	ea cc ff f0 	sub	r12,r5,-16
800066be:	f0 1f 00 08 	mcall	800066dc <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800066c2:	ea cc ff dc 	sub	r12,r5,-36
800066c6:	f0 1f 00 06 	mcall	800066dc <xQueueCreate+0x6c>
800066ca:	0a 9c       	mov	r12,r5
800066cc:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800066ce:	0a 9c       	mov	r12,r5
800066d0:	f0 1f 00 04 	mcall	800066e0 <xQueueCreate+0x70>
800066d4:	d8 2a       	popm	r4-r7,pc,r12=0
800066d6:	d8 2a       	popm	r4-r7,pc,r12=0
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	62 1c       	ld.w	r12,r1[0x4]
800066dc:	80 00       	ld.sh	r0,r0[0x0]
800066de:	5e 8c       	retls	r12
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	61 f4       	ld.w	r4,r0[0x7c]

800066e4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800066e4:	48 38       	lddpc	r8,800066f0 <vTaskSuspendAll+0xc>
800066e6:	70 09       	ld.w	r9,r8[0x0]
800066e8:	2f f9       	sub	r9,-1
800066ea:	91 09       	st.w	r8[0x0],r9
}
800066ec:	5e fc       	retal	r12
800066ee:	00 00       	add	r0,r0
800066f0:	00 00       	add	r0,r0
800066f2:	0d 74       	ld.ub	r4,--r6

800066f4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800066f4:	49 a8       	lddpc	r8,8000675c <vTaskSwitchContext+0x68>
800066f6:	70 08       	ld.w	r8,r8[0x0]
800066f8:	58 08       	cp.w	r8,0
800066fa:	c0 b1       	brne	80006710 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066fc:	49 98       	lddpc	r8,80006760 <vTaskSwitchContext+0x6c>
800066fe:	70 08       	ld.w	r8,r8[0x0]
80006700:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006704:	49 89       	lddpc	r9,80006764 <vTaskSwitchContext+0x70>
80006706:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000670a:	58 08       	cp.w	r8,0
8000670c:	c0 60       	breq	80006718 <vTaskSwitchContext+0x24>
8000670e:	c1 18       	rjmp	80006730 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006710:	30 19       	mov	r9,1
80006712:	49 68       	lddpc	r8,80006768 <vTaskSwitchContext+0x74>
80006714:	91 09       	st.w	r8[0x0],r9
80006716:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006718:	49 28       	lddpc	r8,80006760 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000671a:	49 3a       	lddpc	r10,80006764 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000671c:	70 09       	ld.w	r9,r8[0x0]
8000671e:	20 19       	sub	r9,1
80006720:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006722:	70 09       	ld.w	r9,r8[0x0]
80006724:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006728:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000672c:	58 09       	cp.w	r9,0
8000672e:	cf 70       	breq	8000671c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006730:	48 c8       	lddpc	r8,80006760 <vTaskSwitchContext+0x6c>
80006732:	70 08       	ld.w	r8,r8[0x0]
80006734:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006738:	48 b9       	lddpc	r9,80006764 <vTaskSwitchContext+0x70>
8000673a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000673e:	70 19       	ld.w	r9,r8[0x4]
80006740:	72 19       	ld.w	r9,r9[0x4]
80006742:	91 19       	st.w	r8[0x4],r9
80006744:	f0 ca ff f8 	sub	r10,r8,-8
80006748:	14 39       	cp.w	r9,r10
8000674a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000674e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006752:	70 18       	ld.w	r8,r8[0x4]
80006754:	70 39       	ld.w	r9,r8[0xc]
80006756:	48 68       	lddpc	r8,8000676c <vTaskSwitchContext+0x78>
80006758:	91 09       	st.w	r8[0x0],r9
8000675a:	5e fc       	retal	r12
8000675c:	00 00       	add	r0,r0
8000675e:	0d 74       	ld.ub	r4,--r6
80006760:	00 00       	add	r0,r0
80006762:	0d ac       	ld.ub	r12,r6[0x2]
80006764:	00 00       	add	r0,r0
80006766:	0c 90       	mov	r0,r6
80006768:	00 00       	add	r0,r0
8000676a:	0d 94       	ld.ub	r4,r6[0x1]
8000676c:	00 00       	add	r0,r0
8000676e:	0d 44       	ld.w	r4,--r6

80006770 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006770:	48 48       	lddpc	r8,80006780 <vTaskSetTimeOutState+0x10>
80006772:	70 08       	ld.w	r8,r8[0x0]
80006774:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006776:	48 48       	lddpc	r8,80006784 <vTaskSetTimeOutState+0x14>
80006778:	70 08       	ld.w	r8,r8[0x0]
8000677a:	99 18       	st.w	r12[0x4],r8
}
8000677c:	5e fc       	retal	r12
8000677e:	00 00       	add	r0,r0
80006780:	00 00       	add	r0,r0
80006782:	0c 88       	andn	r8,r6
80006784:	00 00       	add	r0,r0
80006786:	0d 70       	ld.ub	r0,--r6

80006788 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006788:	30 19       	mov	r9,1
8000678a:	48 28       	lddpc	r8,80006790 <vTaskMissedYield+0x8>
8000678c:	91 09       	st.w	r8[0x0],r9
}
8000678e:	5e fc       	retal	r12
80006790:	00 00       	add	r0,r0
80006792:	0d 94       	ld.ub	r4,r6[0x1]

80006794 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006794:	48 28       	lddpc	r8,8000679c <xTaskGetCurrentTaskHandle+0x8>
80006796:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006798:	5e fc       	retal	r12
8000679a:	00 00       	add	r0,r0
8000679c:	00 00       	add	r0,r0
8000679e:	0d 44       	ld.w	r4,--r6

800067a0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800067a0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800067a4:	58 0c       	cp.w	r12,0
800067a6:	c1 f0       	breq	800067e4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800067a8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800067aa:	78 b9       	ld.w	r9,r12[0x2c]
800067ac:	79 18       	ld.w	r8,r12[0x44]
800067ae:	10 39       	cp.w	r9,r8
800067b0:	c1 a0       	breq	800067e4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800067b2:	f8 c6 ff fc 	sub	r6,r12,-4
800067b6:	0c 9c       	mov	r12,r6
800067b8:	f0 1f 00 0c 	mcall	800067e8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800067bc:	6f 1c       	ld.w	r12,r7[0x44]
800067be:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800067c0:	f8 08 11 08 	rsub	r8,r12,8
800067c4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800067c6:	48 a8       	lddpc	r8,800067ec <vTaskPriorityDisinherit+0x4c>
800067c8:	70 08       	ld.w	r8,r8[0x0]
800067ca:	10 3c       	cp.w	r12,r8
800067cc:	e0 88 00 04 	brls	800067d4 <vTaskPriorityDisinherit+0x34>
800067d0:	48 78       	lddpc	r8,800067ec <vTaskPriorityDisinherit+0x4c>
800067d2:	91 0c       	st.w	r8[0x0],r12
800067d4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067d8:	0c 9b       	mov	r11,r6
800067da:	48 68       	lddpc	r8,800067f0 <vTaskPriorityDisinherit+0x50>
800067dc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067e0:	f0 1f 00 05 	mcall	800067f4 <vTaskPriorityDisinherit+0x54>
800067e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	5e f6       	retal	r6
800067ec:	00 00       	add	r0,r0
800067ee:	0d ac       	ld.ub	r12,r6[0x2]
800067f0:	00 00       	add	r0,r0
800067f2:	0c 90       	mov	r0,r6
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	5e a6       	retle	r6

800067f8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800067f8:	eb cd 40 c0 	pushm	r6-r7,lr
800067fc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800067fe:	49 b8       	lddpc	r8,80006868 <vTaskPriorityInherit+0x70>
80006800:	70 08       	ld.w	r8,r8[0x0]
80006802:	78 b9       	ld.w	r9,r12[0x2c]
80006804:	70 b8       	ld.w	r8,r8[0x2c]
80006806:	10 39       	cp.w	r9,r8
80006808:	c2 d2       	brcc	80006862 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000680a:	49 88       	lddpc	r8,80006868 <vTaskPriorityInherit+0x70>
8000680c:	70 08       	ld.w	r8,r8[0x0]
8000680e:	70 b8       	ld.w	r8,r8[0x2c]
80006810:	f0 08 11 08 	rsub	r8,r8,8
80006814:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006816:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000681a:	49 59       	lddpc	r9,8000686c <vTaskPriorityInherit+0x74>
8000681c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006820:	78 59       	ld.w	r9,r12[0x14]
80006822:	10 39       	cp.w	r9,r8
80006824:	c1 b1       	brne	8000685a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006826:	f8 c6 ff fc 	sub	r6,r12,-4
8000682a:	0c 9c       	mov	r12,r6
8000682c:	f0 1f 00 11 	mcall	80006870 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006830:	48 e8       	lddpc	r8,80006868 <vTaskPriorityInherit+0x70>
80006832:	70 08       	ld.w	r8,r8[0x0]
80006834:	70 bc       	ld.w	r12,r8[0x2c]
80006836:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006838:	48 f8       	lddpc	r8,80006874 <vTaskPriorityInherit+0x7c>
8000683a:	70 08       	ld.w	r8,r8[0x0]
8000683c:	10 3c       	cp.w	r12,r8
8000683e:	e0 88 00 04 	brls	80006846 <vTaskPriorityInherit+0x4e>
80006842:	48 d8       	lddpc	r8,80006874 <vTaskPriorityInherit+0x7c>
80006844:	91 0c       	st.w	r8[0x0],r12
80006846:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000684a:	0c 9b       	mov	r11,r6
8000684c:	48 88       	lddpc	r8,8000686c <vTaskPriorityInherit+0x74>
8000684e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006852:	f0 1f 00 0a 	mcall	80006878 <vTaskPriorityInherit+0x80>
80006856:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000685a:	48 48       	lddpc	r8,80006868 <vTaskPriorityInherit+0x70>
8000685c:	70 08       	ld.w	r8,r8[0x0]
8000685e:	70 b8       	ld.w	r8,r8[0x2c]
80006860:	99 b8       	st.w	r12[0x2c],r8
80006862:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006866:	00 00       	add	r0,r0
80006868:	00 00       	add	r0,r0
8000686a:	0d 44       	ld.w	r4,--r6
8000686c:	00 00       	add	r0,r0
8000686e:	0c 90       	mov	r0,r6
80006870:	80 00       	ld.sh	r0,r0[0x0]
80006872:	5e f6       	retal	r6
80006874:	00 00       	add	r0,r0
80006876:	0d ac       	ld.ub	r12,r6[0x2]
80006878:	80 00       	ld.sh	r0,r0[0x0]
8000687a:	5e a6       	retle	r6

8000687c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000687c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006880:	78 38       	ld.w	r8,r12[0xc]
80006882:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006884:	ee c6 ff e8 	sub	r6,r7,-24
80006888:	0c 9c       	mov	r12,r6
8000688a:	f0 1f 00 15 	mcall	800068dc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000688e:	49 58       	lddpc	r8,800068e0 <xTaskRemoveFromEventList+0x64>
80006890:	70 08       	ld.w	r8,r8[0x0]
80006892:	58 08       	cp.w	r8,0
80006894:	c1 71       	brne	800068c2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006896:	ee c6 ff fc 	sub	r6,r7,-4
8000689a:	0c 9c       	mov	r12,r6
8000689c:	f0 1f 00 10 	mcall	800068dc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800068a0:	6e bc       	ld.w	r12,r7[0x2c]
800068a2:	49 18       	lddpc	r8,800068e4 <xTaskRemoveFromEventList+0x68>
800068a4:	70 08       	ld.w	r8,r8[0x0]
800068a6:	10 3c       	cp.w	r12,r8
800068a8:	e0 88 00 04 	brls	800068b0 <xTaskRemoveFromEventList+0x34>
800068ac:	48 e8       	lddpc	r8,800068e4 <xTaskRemoveFromEventList+0x68>
800068ae:	91 0c       	st.w	r8[0x0],r12
800068b0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800068b4:	0c 9b       	mov	r11,r6
800068b6:	48 d8       	lddpc	r8,800068e8 <xTaskRemoveFromEventList+0x6c>
800068b8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800068bc:	f0 1f 00 0c 	mcall	800068ec <xTaskRemoveFromEventList+0x70>
800068c0:	c0 58       	rjmp	800068ca <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800068c2:	0c 9b       	mov	r11,r6
800068c4:	48 bc       	lddpc	r12,800068f0 <xTaskRemoveFromEventList+0x74>
800068c6:	f0 1f 00 0a 	mcall	800068ec <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068ca:	48 b8       	lddpc	r8,800068f4 <xTaskRemoveFromEventList+0x78>
800068cc:	70 08       	ld.w	r8,r8[0x0]
800068ce:	6e b9       	ld.w	r9,r7[0x2c]
800068d0:	70 b8       	ld.w	r8,r8[0x2c]
800068d2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800068d4:	5f 2c       	srhs	r12
800068d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068da:	00 00       	add	r0,r0
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	5e f6       	retal	r6
800068e0:	00 00       	add	r0,r0
800068e2:	0d 74       	ld.ub	r4,--r6
800068e4:	00 00       	add	r0,r0
800068e6:	0d ac       	ld.ub	r12,r6[0x2]
800068e8:	00 00       	add	r0,r0
800068ea:	0c 90       	mov	r0,r6
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	5e a6       	retle	r6
800068f0:	00 00       	add	r0,r0
800068f2:	0d 48       	ld.w	r8,--r6
800068f4:	00 00       	add	r0,r0
800068f6:	0d 44       	ld.w	r4,--r6

800068f8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800068f8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800068fc:	4b 98       	lddpc	r8,800069e0 <vTaskIncrementTick+0xe8>
800068fe:	70 08       	ld.w	r8,r8[0x0]
80006900:	58 08       	cp.w	r8,0
80006902:	c6 91       	brne	800069d4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006904:	4b 88       	lddpc	r8,800069e4 <vTaskIncrementTick+0xec>
80006906:	70 09       	ld.w	r9,r8[0x0]
80006908:	2f f9       	sub	r9,-1
8000690a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000690c:	70 08       	ld.w	r8,r8[0x0]
8000690e:	58 08       	cp.w	r8,0
80006910:	c1 a1       	brne	80006944 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006912:	4b 68       	lddpc	r8,800069e8 <vTaskIncrementTick+0xf0>
80006914:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006916:	4b 69       	lddpc	r9,800069ec <vTaskIncrementTick+0xf4>
80006918:	72 0b       	ld.w	r11,r9[0x0]
8000691a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000691c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000691e:	4b 59       	lddpc	r9,800069f0 <vTaskIncrementTick+0xf8>
80006920:	72 0a       	ld.w	r10,r9[0x0]
80006922:	2f fa       	sub	r10,-1
80006924:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006926:	70 08       	ld.w	r8,r8[0x0]
80006928:	70 08       	ld.w	r8,r8[0x0]
8000692a:	58 08       	cp.w	r8,0
8000692c:	c0 51       	brne	80006936 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000692e:	3f f9       	mov	r9,-1
80006930:	4b 18       	lddpc	r8,800069f4 <vTaskIncrementTick+0xfc>
80006932:	91 09       	st.w	r8[0x0],r9
80006934:	c0 88       	rjmp	80006944 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006936:	4a d8       	lddpc	r8,800069e8 <vTaskIncrementTick+0xf0>
80006938:	70 08       	ld.w	r8,r8[0x0]
8000693a:	70 38       	ld.w	r8,r8[0xc]
8000693c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000693e:	70 19       	ld.w	r9,r8[0x4]
80006940:	4a d8       	lddpc	r8,800069f4 <vTaskIncrementTick+0xfc>
80006942:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006944:	4a 88       	lddpc	r8,800069e4 <vTaskIncrementTick+0xec>
80006946:	70 09       	ld.w	r9,r8[0x0]
80006948:	4a b8       	lddpc	r8,800069f4 <vTaskIncrementTick+0xfc>
8000694a:	70 08       	ld.w	r8,r8[0x0]
8000694c:	10 39       	cp.w	r9,r8
8000694e:	c4 73       	brcs	800069dc <vTaskIncrementTick+0xe4>
80006950:	4a 68       	lddpc	r8,800069e8 <vTaskIncrementTick+0xf0>
80006952:	70 08       	ld.w	r8,r8[0x0]
80006954:	70 08       	ld.w	r8,r8[0x0]
80006956:	58 08       	cp.w	r8,0
80006958:	c0 c0       	breq	80006970 <vTaskIncrementTick+0x78>
8000695a:	4a 48       	lddpc	r8,800069e8 <vTaskIncrementTick+0xf0>
8000695c:	70 08       	ld.w	r8,r8[0x0]
8000695e:	70 38       	ld.w	r8,r8[0xc]
80006960:	70 37       	ld.w	r7,r8[0xc]
80006962:	6e 18       	ld.w	r8,r7[0x4]
80006964:	4a 09       	lddpc	r9,800069e4 <vTaskIncrementTick+0xec>
80006966:	72 09       	ld.w	r9,r9[0x0]
80006968:	12 38       	cp.w	r8,r9
8000696a:	e0 88 00 14 	brls	80006992 <vTaskIncrementTick+0x9a>
8000696e:	c0 e8       	rjmp	8000698a <vTaskIncrementTick+0x92>
80006970:	3f f9       	mov	r9,-1
80006972:	4a 18       	lddpc	r8,800069f4 <vTaskIncrementTick+0xfc>
80006974:	91 09       	st.w	r8[0x0],r9
80006976:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000697a:	6a 08       	ld.w	r8,r5[0x0]
8000697c:	70 38       	ld.w	r8,r8[0xc]
8000697e:	70 37       	ld.w	r7,r8[0xc]
80006980:	6e 18       	ld.w	r8,r7[0x4]
80006982:	64 09       	ld.w	r9,r2[0x0]
80006984:	12 38       	cp.w	r8,r9
80006986:	e0 88 00 0a 	brls	8000699a <vTaskIncrementTick+0xa2>
8000698a:	49 b9       	lddpc	r9,800069f4 <vTaskIncrementTick+0xfc>
8000698c:	93 08       	st.w	r9[0x0],r8
8000698e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006992:	49 a4       	lddpc	r4,800069f8 <vTaskIncrementTick+0x100>
80006994:	49 a3       	lddpc	r3,800069fc <vTaskIncrementTick+0x104>
80006996:	49 55       	lddpc	r5,800069e8 <vTaskIncrementTick+0xf0>
80006998:	49 32       	lddpc	r2,800069e4 <vTaskIncrementTick+0xec>
8000699a:	ee c6 ff fc 	sub	r6,r7,-4
8000699e:	0c 9c       	mov	r12,r6
800069a0:	f0 1f 00 18 	mcall	80006a00 <vTaskIncrementTick+0x108>
800069a4:	6e a8       	ld.w	r8,r7[0x28]
800069a6:	58 08       	cp.w	r8,0
800069a8:	c0 50       	breq	800069b2 <vTaskIncrementTick+0xba>
800069aa:	ee cc ff e8 	sub	r12,r7,-24
800069ae:	f0 1f 00 15 	mcall	80006a00 <vTaskIncrementTick+0x108>
800069b2:	6e bc       	ld.w	r12,r7[0x2c]
800069b4:	68 08       	ld.w	r8,r4[0x0]
800069b6:	10 3c       	cp.w	r12,r8
800069b8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800069bc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069c0:	0c 9b       	mov	r11,r6
800069c2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800069c6:	f0 1f 00 10 	mcall	80006a04 <vTaskIncrementTick+0x10c>
800069ca:	6a 08       	ld.w	r8,r5[0x0]
800069cc:	70 08       	ld.w	r8,r8[0x0]
800069ce:	58 08       	cp.w	r8,0
800069d0:	cd 51       	brne	8000697a <vTaskIncrementTick+0x82>
800069d2:	cc fb       	rjmp	80006970 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800069d4:	48 d8       	lddpc	r8,80006a08 <vTaskIncrementTick+0x110>
800069d6:	70 09       	ld.w	r9,r8[0x0]
800069d8:	2f f9       	sub	r9,-1
800069da:	91 09       	st.w	r8[0x0],r9
800069dc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800069e0:	00 00       	add	r0,r0
800069e2:	0d 74       	ld.ub	r4,--r6
800069e4:	00 00       	add	r0,r0
800069e6:	0d 70       	ld.ub	r0,--r6
800069e8:	00 00       	add	r0,r0
800069ea:	0c 7c       	tst	r12,r6
800069ec:	00 00       	add	r0,r0
800069ee:	0c 8c       	andn	r12,r6
800069f0:	00 00       	add	r0,r0
800069f2:	0c 88       	andn	r8,r6
800069f4:	00 00       	add	r0,r0
800069f6:	05 44       	ld.w	r4,--r2
800069f8:	00 00       	add	r0,r0
800069fa:	0d ac       	ld.ub	r12,r6[0x2]
800069fc:	00 00       	add	r0,r0
800069fe:	0c 90       	mov	r0,r6
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	5e f6       	retal	r6
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	5e a6       	retle	r6
80006a08:	00 00       	add	r0,r0
80006a0a:	0c 74       	tst	r4,r6

80006a0c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006a0c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a10:	18 97       	mov	r7,r12
80006a12:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006a14:	f0 1f 00 15 	mcall	80006a68 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006a18:	6c 08       	ld.w	r8,r6[0x0]
80006a1a:	5b f8       	cp.w	r8,-1
80006a1c:	c0 31       	brne	80006a22 <xTaskCheckForTimeOut+0x16>
80006a1e:	30 07       	mov	r7,0
80006a20:	c1 f8       	rjmp	80006a5e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006a22:	49 39       	lddpc	r9,80006a6c <xTaskCheckForTimeOut+0x60>
80006a24:	72 09       	ld.w	r9,r9[0x0]
80006a26:	6e 0a       	ld.w	r10,r7[0x0]
80006a28:	12 3a       	cp.w	r10,r9
80006a2a:	c0 70       	breq	80006a38 <xTaskCheckForTimeOut+0x2c>
80006a2c:	49 19       	lddpc	r9,80006a70 <xTaskCheckForTimeOut+0x64>
80006a2e:	72 09       	ld.w	r9,r9[0x0]
80006a30:	6e 1a       	ld.w	r10,r7[0x4]
80006a32:	12 3a       	cp.w	r10,r9
80006a34:	e0 88 00 14 	brls	80006a5c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006a38:	48 e9       	lddpc	r9,80006a70 <xTaskCheckForTimeOut+0x64>
80006a3a:	72 0a       	ld.w	r10,r9[0x0]
80006a3c:	6e 19       	ld.w	r9,r7[0x4]
80006a3e:	12 1a       	sub	r10,r9
80006a40:	14 38       	cp.w	r8,r10
80006a42:	e0 88 00 0d 	brls	80006a5c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006a46:	48 ba       	lddpc	r10,80006a70 <xTaskCheckForTimeOut+0x64>
80006a48:	74 0a       	ld.w	r10,r10[0x0]
80006a4a:	14 19       	sub	r9,r10
80006a4c:	f2 08 00 08 	add	r8,r9,r8
80006a50:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006a52:	0e 9c       	mov	r12,r7
80006a54:	f0 1f 00 08 	mcall	80006a74 <xTaskCheckForTimeOut+0x68>
80006a58:	30 07       	mov	r7,0
80006a5a:	c0 28       	rjmp	80006a5e <xTaskCheckForTimeOut+0x52>
80006a5c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006a5e:	f0 1f 00 07 	mcall	80006a78 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006a62:	0e 9c       	mov	r12,r7
80006a64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	5f b0       	srhi	r0
80006a6c:	00 00       	add	r0,r0
80006a6e:	0c 88       	andn	r8,r6
80006a70:	00 00       	add	r0,r0
80006a72:	0d 70       	ld.ub	r0,--r6
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	67 70       	ld.w	r0,r3[0x5c]
80006a78:	80 00       	ld.sh	r0,r0[0x0]
80006a7a:	60 bc       	ld.w	r12,r0[0x2c]

80006a7c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006a7c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006a80:	f0 1f 00 05 	mcall	80006a94 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006a84:	48 58       	lddpc	r8,80006a98 <xTaskGetTickCount+0x1c>
80006a86:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006a88:	f0 1f 00 05 	mcall	80006a9c <xTaskGetTickCount+0x20>

	return xTicks;
}
80006a8c:	0e 9c       	mov	r12,r7
80006a8e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a92:	00 00       	add	r0,r0
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	5f b0       	srhi	r0
80006a98:	00 00       	add	r0,r0
80006a9a:	0d 70       	ld.ub	r0,--r6
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	60 bc       	ld.w	r12,r0[0x2c]

80006aa0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006aa0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006aa4:	f0 1f 00 2c 	mcall	80006b54 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006aa8:	4a c8       	lddpc	r8,80006b58 <xTaskResumeAll+0xb8>
80006aaa:	70 09       	ld.w	r9,r8[0x0]
80006aac:	20 19       	sub	r9,1
80006aae:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006ab0:	70 08       	ld.w	r8,r8[0x0]
80006ab2:	58 08       	cp.w	r8,0
80006ab4:	c4 91       	brne	80006b46 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006ab6:	4a a8       	lddpc	r8,80006b5c <xTaskResumeAll+0xbc>
80006ab8:	70 08       	ld.w	r8,r8[0x0]
80006aba:	58 08       	cp.w	r8,0
80006abc:	c4 50       	breq	80006b46 <xTaskResumeAll+0xa6>
80006abe:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006ac0:	4a 85       	lddpc	r5,80006b60 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006ac2:	4a 93       	lddpc	r3,80006b64 <xTaskResumeAll+0xc4>
80006ac4:	4a 92       	lddpc	r2,80006b68 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ac6:	4a a1       	lddpc	r1,80006b6c <xTaskResumeAll+0xcc>
80006ac8:	c1 e8       	rjmp	80006b04 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006aca:	6a 38       	ld.w	r8,r5[0xc]
80006acc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006ace:	ee cc ff e8 	sub	r12,r7,-24
80006ad2:	f0 1f 00 28 	mcall	80006b70 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006ad6:	ee c6 ff fc 	sub	r6,r7,-4
80006ada:	0c 9c       	mov	r12,r6
80006adc:	f0 1f 00 25 	mcall	80006b70 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006ae0:	6e bc       	ld.w	r12,r7[0x2c]
80006ae2:	66 08       	ld.w	r8,r3[0x0]
80006ae4:	10 3c       	cp.w	r12,r8
80006ae6:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006aea:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006aee:	0c 9b       	mov	r11,r6
80006af0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006af4:	f0 1f 00 20 	mcall	80006b74 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006af8:	62 08       	ld.w	r8,r1[0x0]
80006afa:	6e b9       	ld.w	r9,r7[0x2c]
80006afc:	70 b8       	ld.w	r8,r8[0x2c]
80006afe:	10 39       	cp.w	r9,r8
80006b00:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006b04:	6a 08       	ld.w	r8,r5[0x0]
80006b06:	58 08       	cp.w	r8,0
80006b08:	ce 11       	brne	80006aca <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006b0a:	49 c8       	lddpc	r8,80006b78 <xTaskResumeAll+0xd8>
80006b0c:	70 08       	ld.w	r8,r8[0x0]
80006b0e:	58 08       	cp.w	r8,0
80006b10:	c0 f0       	breq	80006b2e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006b12:	49 a8       	lddpc	r8,80006b78 <xTaskResumeAll+0xd8>
80006b14:	70 08       	ld.w	r8,r8[0x0]
80006b16:	58 08       	cp.w	r8,0
80006b18:	c1 10       	breq	80006b3a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006b1a:	49 87       	lddpc	r7,80006b78 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006b1c:	f0 1f 00 18 	mcall	80006b7c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006b20:	6e 08       	ld.w	r8,r7[0x0]
80006b22:	20 18       	sub	r8,1
80006b24:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006b26:	6e 08       	ld.w	r8,r7[0x0]
80006b28:	58 08       	cp.w	r8,0
80006b2a:	cf 91       	brne	80006b1c <xTaskResumeAll+0x7c>
80006b2c:	c0 78       	rjmp	80006b3a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006b2e:	58 14       	cp.w	r4,1
80006b30:	c0 50       	breq	80006b3a <xTaskResumeAll+0x9a>
80006b32:	49 48       	lddpc	r8,80006b80 <xTaskResumeAll+0xe0>
80006b34:	70 08       	ld.w	r8,r8[0x0]
80006b36:	58 18       	cp.w	r8,1
80006b38:	c0 71       	brne	80006b46 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006b3a:	30 09       	mov	r9,0
80006b3c:	49 18       	lddpc	r8,80006b80 <xTaskResumeAll+0xe0>
80006b3e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006b40:	d7 33       	scall
80006b42:	30 17       	mov	r7,1
80006b44:	c0 28       	rjmp	80006b48 <xTaskResumeAll+0xa8>
80006b46:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006b48:	f0 1f 00 0f 	mcall	80006b84 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006b4c:	0e 9c       	mov	r12,r7
80006b4e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006b52:	00 00       	add	r0,r0
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	5f b0       	srhi	r0
80006b58:	00 00       	add	r0,r0
80006b5a:	0d 74       	ld.ub	r4,--r6
80006b5c:	00 00       	add	r0,r0
80006b5e:	0d 90       	ld.ub	r0,r6[0x1]
80006b60:	00 00       	add	r0,r0
80006b62:	0d 48       	ld.w	r8,--r6
80006b64:	00 00       	add	r0,r0
80006b66:	0d ac       	ld.ub	r12,r6[0x2]
80006b68:	00 00       	add	r0,r0
80006b6a:	0c 90       	mov	r0,r6
80006b6c:	00 00       	add	r0,r0
80006b6e:	0d 44       	ld.w	r4,--r6
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	5e f6       	retal	r6
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	5e a6       	retle	r6
80006b78:	00 00       	add	r0,r0
80006b7a:	0c 74       	tst	r4,r6
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	68 f8       	ld.w	r8,r4[0x3c]
80006b80:	00 00       	add	r0,r0
80006b82:	0d 94       	ld.ub	r4,r6[0x1]
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	60 bc       	ld.w	r12,r0[0x2c]

80006b88 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006b88:	eb cd 40 80 	pushm	r7,lr
80006b8c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006b8e:	49 08       	lddpc	r8,80006bcc <prvAddCurrentTaskToDelayedList+0x44>
80006b90:	70 08       	ld.w	r8,r8[0x0]
80006b92:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006b94:	48 f8       	lddpc	r8,80006bd0 <prvAddCurrentTaskToDelayedList+0x48>
80006b96:	70 08       	ld.w	r8,r8[0x0]
80006b98:	10 3c       	cp.w	r12,r8
80006b9a:	c0 a2       	brcc	80006bae <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b9c:	48 c8       	lddpc	r8,80006bcc <prvAddCurrentTaskToDelayedList+0x44>
80006b9e:	70 0b       	ld.w	r11,r8[0x0]
80006ba0:	48 d8       	lddpc	r8,80006bd4 <prvAddCurrentTaskToDelayedList+0x4c>
80006ba2:	70 0c       	ld.w	r12,r8[0x0]
80006ba4:	2f cb       	sub	r11,-4
80006ba6:	f0 1f 00 0d 	mcall	80006bd8 <prvAddCurrentTaskToDelayedList+0x50>
80006baa:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bae:	48 88       	lddpc	r8,80006bcc <prvAddCurrentTaskToDelayedList+0x44>
80006bb0:	70 0b       	ld.w	r11,r8[0x0]
80006bb2:	48 b8       	lddpc	r8,80006bdc <prvAddCurrentTaskToDelayedList+0x54>
80006bb4:	70 0c       	ld.w	r12,r8[0x0]
80006bb6:	2f cb       	sub	r11,-4
80006bb8:	f0 1f 00 08 	mcall	80006bd8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006bbc:	48 98       	lddpc	r8,80006be0 <prvAddCurrentTaskToDelayedList+0x58>
80006bbe:	70 08       	ld.w	r8,r8[0x0]
80006bc0:	10 37       	cp.w	r7,r8
80006bc2:	c0 32       	brcc	80006bc8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006bc4:	48 78       	lddpc	r8,80006be0 <prvAddCurrentTaskToDelayedList+0x58>
80006bc6:	91 07       	st.w	r8[0x0],r7
80006bc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bcc:	00 00       	add	r0,r0
80006bce:	0d 44       	ld.w	r4,--r6
80006bd0:	00 00       	add	r0,r0
80006bd2:	0d 70       	ld.ub	r0,--r6
80006bd4:	00 00       	add	r0,r0
80006bd6:	0c 8c       	andn	r12,r6
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	5e c2       	retvs	r2
80006bdc:	00 00       	add	r0,r0
80006bde:	0c 7c       	tst	r12,r6
80006be0:	00 00       	add	r0,r0
80006be2:	05 44       	ld.w	r4,--r2

80006be4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006be4:	eb cd 40 c0 	pushm	r6-r7,lr
80006be8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006bea:	58 0c       	cp.w	r12,0
80006bec:	c1 10       	breq	80006c0e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006bee:	f0 1f 00 0a 	mcall	80006c14 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006bf2:	48 a8       	lddpc	r8,80006c18 <vTaskDelay+0x34>
80006bf4:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bf6:	48 a8       	lddpc	r8,80006c1c <vTaskDelay+0x38>
80006bf8:	70 0c       	ld.w	r12,r8[0x0]
80006bfa:	2f cc       	sub	r12,-4
80006bfc:	f0 1f 00 09 	mcall	80006c20 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006c00:	ee 06 00 0c 	add	r12,r7,r6
80006c04:	f0 1f 00 08 	mcall	80006c24 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006c08:	f0 1f 00 08 	mcall	80006c28 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006c0c:	c0 21       	brne	80006c10 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006c0e:	d7 33       	scall
80006c10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	66 e4       	ld.w	r4,r3[0x38]
80006c18:	00 00       	add	r0,r0
80006c1a:	0d 70       	ld.ub	r0,--r6
80006c1c:	00 00       	add	r0,r0
80006c1e:	0d 44       	ld.w	r4,--r6
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	5e f6       	retal	r6
80006c24:	80 00       	ld.sh	r0,r0[0x0]
80006c26:	6b 88       	ld.w	r8,r5[0x60]
80006c28:	80 00       	ld.sh	r0,r0[0x0]
80006c2a:	6a a0       	ld.w	r0,r5[0x28]

80006c2c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006c2c:	eb cd 40 c0 	pushm	r6-r7,lr
80006c30:	18 96       	mov	r6,r12
80006c32:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006c34:	f0 1f 00 18 	mcall	80006c94 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006c38:	6c 08       	ld.w	r8,r6[0x0]
80006c3a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006c3c:	49 79       	lddpc	r9,80006c98 <vTaskDelayUntil+0x6c>
80006c3e:	72 09       	ld.w	r9,r9[0x0]
80006c40:	12 38       	cp.w	r8,r9
80006c42:	e0 88 00 0c 	brls	80006c5a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006c46:	0e 38       	cp.w	r8,r7
80006c48:	e0 88 00 22 	brls	80006c8c <vTaskDelayUntil+0x60>
80006c4c:	49 38       	lddpc	r8,80006c98 <vTaskDelayUntil+0x6c>
80006c4e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c50:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006c52:	10 37       	cp.w	r7,r8
80006c54:	e0 88 00 14 	brls	80006c7c <vTaskDelayUntil+0x50>
80006c58:	c0 a8       	rjmp	80006c6c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006c5a:	0e 38       	cp.w	r8,r7
80006c5c:	e0 8b 00 16 	brhi	80006c88 <vTaskDelayUntil+0x5c>
80006c60:	48 e8       	lddpc	r8,80006c98 <vTaskDelayUntil+0x6c>
80006c62:	70 08       	ld.w	r8,r8[0x0]
80006c64:	10 37       	cp.w	r7,r8
80006c66:	e0 8b 00 11 	brhi	80006c88 <vTaskDelayUntil+0x5c>
80006c6a:	c1 18       	rjmp	80006c8c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c6c:	48 c8       	lddpc	r8,80006c9c <vTaskDelayUntil+0x70>
80006c6e:	70 0c       	ld.w	r12,r8[0x0]
80006c70:	2f cc       	sub	r12,-4
80006c72:	f0 1f 00 0c 	mcall	80006ca0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006c76:	0e 9c       	mov	r12,r7
80006c78:	f0 1f 00 0b 	mcall	80006ca4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006c7c:	f0 1f 00 0b 	mcall	80006ca8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006c80:	c0 81       	brne	80006c90 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006c82:	d7 33       	scall
80006c84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c88:	8d 07       	st.w	r6[0x0],r7
80006c8a:	cf 1b       	rjmp	80006c6c <vTaskDelayUntil+0x40>
80006c8c:	8d 07       	st.w	r6[0x0],r7
80006c8e:	cf 7b       	rjmp	80006c7c <vTaskDelayUntil+0x50>
80006c90:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	66 e4       	ld.w	r4,r3[0x38]
80006c98:	00 00       	add	r0,r0
80006c9a:	0d 70       	ld.ub	r0,--r6
80006c9c:	00 00       	add	r0,r0
80006c9e:	0d 44       	ld.w	r4,--r6
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	5e f6       	retal	r6
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	6b 88       	ld.w	r8,r5[0x60]
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	6a a0       	ld.w	r0,r5[0x28]

80006cac <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006cac:	eb cd 40 c0 	pushm	r6-r7,lr
80006cb0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006cb2:	48 e7       	lddpc	r7,80006ce8 <vTaskPlaceOnEventList+0x3c>
80006cb4:	6e 0b       	ld.w	r11,r7[0x0]
80006cb6:	2e 8b       	sub	r11,-24
80006cb8:	f0 1f 00 0d 	mcall	80006cec <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006cbc:	6e 0c       	ld.w	r12,r7[0x0]
80006cbe:	2f cc       	sub	r12,-4
80006cc0:	f0 1f 00 0c 	mcall	80006cf0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006cc4:	5b f6       	cp.w	r6,-1
80006cc6:	c0 81       	brne	80006cd6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006cc8:	6e 0b       	ld.w	r11,r7[0x0]
80006cca:	2f cb       	sub	r11,-4
80006ccc:	48 ac       	lddpc	r12,80006cf4 <vTaskPlaceOnEventList+0x48>
80006cce:	f0 1f 00 0b 	mcall	80006cf8 <vTaskPlaceOnEventList+0x4c>
80006cd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006cd6:	48 a8       	lddpc	r8,80006cfc <vTaskPlaceOnEventList+0x50>
80006cd8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006cda:	ec 0c 00 0c 	add	r12,r6,r12
80006cde:	f0 1f 00 09 	mcall	80006d00 <vTaskPlaceOnEventList+0x54>
80006ce2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ce6:	00 00       	add	r0,r0
80006ce8:	00 00       	add	r0,r0
80006cea:	0d 44       	ld.w	r4,--r6
80006cec:	80 00       	ld.sh	r0,r0[0x0]
80006cee:	5e c2       	retvs	r2
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	5e f6       	retal	r6
80006cf4:	00 00       	add	r0,r0
80006cf6:	0d 98       	ld.ub	r8,r6[0x1]
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	5e a6       	retle	r6
80006cfc:	00 00       	add	r0,r0
80006cfe:	0d 70       	ld.ub	r0,--r6
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	6b 88       	ld.w	r8,r5[0x60]

80006d04 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006d04:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006d08:	49 67       	lddpc	r7,80006d60 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006d0a:	49 74       	lddpc	r4,80006d64 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006d0c:	49 73       	lddpc	r3,80006d68 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006d0e:	49 85       	lddpc	r5,80006d6c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006d10:	6e 08       	ld.w	r8,r7[0x0]
80006d12:	58 08       	cp.w	r8,0
80006d14:	c1 e0       	breq	80006d50 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006d16:	f0 1f 00 17 	mcall	80006d70 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006d1a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006d1c:	f0 1f 00 16 	mcall	80006d74 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006d20:	58 06       	cp.w	r6,0
80006d22:	c1 70       	breq	80006d50 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006d24:	f0 1f 00 15 	mcall	80006d78 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006d28:	68 38       	ld.w	r8,r4[0xc]
80006d2a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006d2c:	ec cc ff fc 	sub	r12,r6,-4
80006d30:	f0 1f 00 13 	mcall	80006d7c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006d34:	66 08       	ld.w	r8,r3[0x0]
80006d36:	20 18       	sub	r8,1
80006d38:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006d3a:	6e 08       	ld.w	r8,r7[0x0]
80006d3c:	20 18       	sub	r8,1
80006d3e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006d40:	f0 1f 00 10 	mcall	80006d80 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006d44:	6c cc       	ld.w	r12,r6[0x30]
80006d46:	f0 1f 00 10 	mcall	80006d84 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006d4a:	0c 9c       	mov	r12,r6
80006d4c:	f0 1f 00 0e 	mcall	80006d84 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006d50:	6a 08       	ld.w	r8,r5[0x0]
80006d52:	58 18       	cp.w	r8,1
80006d54:	e0 88 00 03 	brls	80006d5a <prvIdleTask+0x56>
			{
				taskYIELD();
80006d58:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006d5a:	f0 1f 00 0c 	mcall	80006d88 <prvIdleTask+0x84>
		}
		#endif
	}
80006d5e:	cd 9b       	rjmp	80006d10 <prvIdleTask+0xc>
80006d60:	00 00       	add	r0,r0
80006d62:	0c 84       	andn	r4,r6
80006d64:	00 00       	add	r0,r0
80006d66:	0d 30       	ld.ub	r0,r6++
80006d68:	00 00       	add	r0,r0
80006d6a:	0d 90       	ld.ub	r0,r6[0x1]
80006d6c:	00 00       	add	r0,r0
80006d6e:	0c 90       	mov	r0,r6
80006d70:	80 00       	ld.sh	r0,r0[0x0]
80006d72:	66 e4       	ld.w	r4,r3[0x38]
80006d74:	80 00       	ld.sh	r0,r0[0x0]
80006d76:	6a a0       	ld.w	r0,r5[0x28]
80006d78:	80 00       	ld.sh	r0,r0[0x0]
80006d7a:	5f b0       	srhi	r0
80006d7c:	80 00       	ld.sh	r0,r0[0x0]
80006d7e:	5e f6       	retal	r6
80006d80:	80 00       	ld.sh	r0,r0[0x0]
80006d82:	60 bc       	ld.w	r12,r0[0x2c]
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	61 f4       	ld.w	r4,r0[0x7c]
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	20 2c       	sub	r12,2

80006d8c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006d8c:	d4 31       	pushm	r0-r7,lr
80006d8e:	20 1d       	sub	sp,4
80006d90:	fa c4 ff d8 	sub	r4,sp,-40
80006d94:	50 0c       	stdsp	sp[0x0],r12
80006d96:	16 91       	mov	r1,r11
80006d98:	14 97       	mov	r7,r10
80006d9a:	12 90       	mov	r0,r9
80006d9c:	10 93       	mov	r3,r8
80006d9e:	68 02       	ld.w	r2,r4[0x0]
80006da0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006da2:	34 8c       	mov	r12,72
80006da4:	f0 1f 00 5c 	mcall	80006f14 <xTaskGenericCreate+0x188>
80006da8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006daa:	c0 31       	brne	80006db0 <xTaskGenericCreate+0x24>
80006dac:	3f fc       	mov	r12,-1
80006dae:	ca f8       	rjmp	80006f0c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006db0:	58 06       	cp.w	r6,0
80006db2:	e0 81 00 af 	brne	80006f10 <xTaskGenericCreate+0x184>
80006db6:	0e 9c       	mov	r12,r7
80006db8:	5c 7c       	castu.h	r12
80006dba:	a3 6c       	lsl	r12,0x2
80006dbc:	f0 1f 00 56 	mcall	80006f14 <xTaskGenericCreate+0x188>
80006dc0:	18 96       	mov	r6,r12
80006dc2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006dc4:	c0 61       	brne	80006dd0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006dc6:	0a 9c       	mov	r12,r5
80006dc8:	f0 1f 00 54 	mcall	80006f18 <xTaskGenericCreate+0x18c>
80006dcc:	3f fc       	mov	r12,-1
80006dce:	c9 f8       	rjmp	80006f0c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006dd0:	5c 77       	castu.h	r7
80006dd2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006dd6:	e0 6b 00 a5 	mov	r11,165
80006dda:	0c 9c       	mov	r12,r6
80006ddc:	f0 1f 00 50 	mcall	80006f1c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006de0:	ee c6 00 01 	sub	r6,r7,1
80006de4:	6a c8       	ld.w	r8,r5[0x30]
80006de6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006dea:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006dee:	31 0a       	mov	r10,16
80006df0:	02 9b       	mov	r11,r1
80006df2:	ea cc ff cc 	sub	r12,r5,-52
80006df6:	f0 1f 00 4b 	mcall	80006f20 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006dfa:	30 08       	mov	r8,0
80006dfc:	eb 68 00 43 	st.b	r5[67],r8
80006e00:	58 73       	cp.w	r3,7
80006e02:	e6 07 17 80 	movls	r7,r3
80006e06:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006e0a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006e0c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006e10:	ea c4 ff fc 	sub	r4,r5,-4
80006e14:	08 9c       	mov	r12,r4
80006e16:	f0 1f 00 44 	mcall	80006f24 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006e1a:	ea cc ff e8 	sub	r12,r5,-24
80006e1e:	f0 1f 00 42 	mcall	80006f24 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006e22:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006e24:	ee 07 11 08 	rsub	r7,r7,8
80006e28:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006e2a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006e2c:	00 9a       	mov	r10,r0
80006e2e:	40 0b       	lddsp	r11,sp[0x0]
80006e30:	0c 9c       	mov	r12,r6
80006e32:	f0 1f 00 3e 	mcall	80006f28 <xTaskGenericCreate+0x19c>
80006e36:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006e38:	58 02       	cp.w	r2,0
80006e3a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006e3e:	f0 1f 00 3c 	mcall	80006f2c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006e42:	4b c8       	lddpc	r8,80006f30 <xTaskGenericCreate+0x1a4>
80006e44:	70 09       	ld.w	r9,r8[0x0]
80006e46:	2f f9       	sub	r9,-1
80006e48:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006e4a:	4b b8       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1a8>
80006e4c:	70 08       	ld.w	r8,r8[0x0]
80006e4e:	58 08       	cp.w	r8,0
80006e50:	c2 61       	brne	80006e9c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006e52:	4b 98       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1a8>
80006e54:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006e56:	4b 78       	lddpc	r8,80006f30 <xTaskGenericCreate+0x1a4>
80006e58:	70 08       	ld.w	r8,r8[0x0]
80006e5a:	58 18       	cp.w	r8,1
80006e5c:	c2 b1       	brne	80006eb2 <xTaskGenericCreate+0x126>
80006e5e:	4b 77       	lddpc	r7,80006f38 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006e60:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006e64:	0e 9c       	mov	r12,r7
80006e66:	f0 1f 00 36 	mcall	80006f3c <xTaskGenericCreate+0x1b0>
80006e6a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006e6c:	0c 37       	cp.w	r7,r6
80006e6e:	cf b1       	brne	80006e64 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006e70:	4b 47       	lddpc	r7,80006f40 <xTaskGenericCreate+0x1b4>
80006e72:	0e 9c       	mov	r12,r7
80006e74:	f0 1f 00 32 	mcall	80006f3c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006e78:	4b 36       	lddpc	r6,80006f44 <xTaskGenericCreate+0x1b8>
80006e7a:	0c 9c       	mov	r12,r6
80006e7c:	f0 1f 00 30 	mcall	80006f3c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006e80:	4b 2c       	lddpc	r12,80006f48 <xTaskGenericCreate+0x1bc>
80006e82:	f0 1f 00 2f 	mcall	80006f3c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006e86:	4b 2c       	lddpc	r12,80006f4c <xTaskGenericCreate+0x1c0>
80006e88:	f0 1f 00 2d 	mcall	80006f3c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006e8c:	4b 1c       	lddpc	r12,80006f50 <xTaskGenericCreate+0x1c4>
80006e8e:	f0 1f 00 2c 	mcall	80006f3c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006e92:	4b 18       	lddpc	r8,80006f54 <xTaskGenericCreate+0x1c8>
80006e94:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006e96:	4b 18       	lddpc	r8,80006f58 <xTaskGenericCreate+0x1cc>
80006e98:	91 06       	st.w	r8[0x0],r6
80006e9a:	c0 c8       	rjmp	80006eb2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006e9c:	4b 08       	lddpc	r8,80006f5c <xTaskGenericCreate+0x1d0>
80006e9e:	70 08       	ld.w	r8,r8[0x0]
80006ea0:	58 08       	cp.w	r8,0
80006ea2:	c0 81       	brne	80006eb2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006ea4:	4a 48       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1a8>
80006ea6:	70 08       	ld.w	r8,r8[0x0]
80006ea8:	70 b8       	ld.w	r8,r8[0x2c]
80006eaa:	10 33       	cp.w	r3,r8
80006eac:	c0 33       	brcs	80006eb2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006eae:	4a 28       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1a8>
80006eb0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006eb2:	6a b8       	ld.w	r8,r5[0x2c]
80006eb4:	4a b9       	lddpc	r9,80006f60 <xTaskGenericCreate+0x1d4>
80006eb6:	72 09       	ld.w	r9,r9[0x0]
80006eb8:	12 38       	cp.w	r8,r9
80006eba:	e0 88 00 04 	brls	80006ec2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006ebe:	4a 99       	lddpc	r9,80006f60 <xTaskGenericCreate+0x1d4>
80006ec0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006ec2:	4a 98       	lddpc	r8,80006f64 <xTaskGenericCreate+0x1d8>
80006ec4:	70 09       	ld.w	r9,r8[0x0]
80006ec6:	2f f9       	sub	r9,-1
80006ec8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006eca:	6a b8       	ld.w	r8,r5[0x2c]
80006ecc:	4a 79       	lddpc	r9,80006f68 <xTaskGenericCreate+0x1dc>
80006ece:	72 09       	ld.w	r9,r9[0x0]
80006ed0:	12 38       	cp.w	r8,r9
80006ed2:	e0 88 00 04 	brls	80006eda <xTaskGenericCreate+0x14e>
80006ed6:	4a 59       	lddpc	r9,80006f68 <xTaskGenericCreate+0x1dc>
80006ed8:	93 08       	st.w	r9[0x0],r8
80006eda:	6a bc       	ld.w	r12,r5[0x2c]
80006edc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ee0:	08 9b       	mov	r11,r4
80006ee2:	49 68       	lddpc	r8,80006f38 <xTaskGenericCreate+0x1ac>
80006ee4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ee8:	f0 1f 00 21 	mcall	80006f6c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006eec:	f0 1f 00 21 	mcall	80006f70 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006ef0:	49 b8       	lddpc	r8,80006f5c <xTaskGenericCreate+0x1d0>
80006ef2:	70 08       	ld.w	r8,r8[0x0]
80006ef4:	58 08       	cp.w	r8,0
80006ef6:	c0 a0       	breq	80006f0a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ef8:	48 f8       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1a8>
80006efa:	70 08       	ld.w	r8,r8[0x0]
80006efc:	70 b8       	ld.w	r8,r8[0x2c]
80006efe:	10 33       	cp.w	r3,r8
80006f00:	e0 88 00 05 	brls	80006f0a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006f04:	d7 33       	scall
80006f06:	30 1c       	mov	r12,1
80006f08:	c0 28       	rjmp	80006f0c <xTaskGenericCreate+0x180>
80006f0a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006f0c:	2f fd       	sub	sp,-4
80006f0e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006f10:	99 c6       	st.w	r12[0x30],r6
80006f12:	c5 fb       	rjmp	80006dd0 <xTaskGenericCreate+0x44>
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	62 1c       	ld.w	r12,r1[0x4]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	61 f4       	ld.w	r4,r0[0x7c]
80006f1c:	80 00       	ld.sh	r0,r0[0x0]
80006f1e:	7b 3e       	ld.w	lr,sp[0x4c]
80006f20:	80 00       	ld.sh	r0,r0[0x0]
80006f22:	7e 68       	ld.w	r8,pc[0x18]
80006f24:	80 00       	ld.sh	r0,r0[0x0]
80006f26:	5e a0       	retle	r0
80006f28:	80 00       	ld.sh	r0,r0[0x0]
80006f2a:	5f 1c       	srne	r12
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	5f b0       	srhi	r0
80006f30:	00 00       	add	r0,r0
80006f32:	0d 90       	ld.ub	r0,r6[0x1]
80006f34:	00 00       	add	r0,r0
80006f36:	0d 44       	ld.w	r4,--r6
80006f38:	00 00       	add	r0,r0
80006f3a:	0c 90       	mov	r0,r6
80006f3c:	80 00       	ld.sh	r0,r0[0x0]
80006f3e:	5e 8c       	retls	r12
80006f40:	00 00       	add	r0,r0
80006f42:	0d 5c       	ld.sh	r12,--r6
80006f44:	00 00       	add	r0,r0
80006f46:	0d 78       	ld.ub	r8,--r6
80006f48:	00 00       	add	r0,r0
80006f4a:	0d 48       	ld.w	r8,--r6
80006f4c:	00 00       	add	r0,r0
80006f4e:	0d 30       	ld.ub	r0,r6++
80006f50:	00 00       	add	r0,r0
80006f52:	0d 98       	ld.ub	r8,r6[0x1]
80006f54:	00 00       	add	r0,r0
80006f56:	0c 7c       	tst	r12,r6
80006f58:	00 00       	add	r0,r0
80006f5a:	0c 8c       	andn	r12,r6
80006f5c:	00 00       	add	r0,r0
80006f5e:	0c 80       	andn	r0,r6
80006f60:	00 00       	add	r0,r0
80006f62:	0c 78       	tst	r8,r6
80006f64:	00 00       	add	r0,r0
80006f66:	0d 8c       	ld.ub	r12,r6[0x0]
80006f68:	00 00       	add	r0,r0
80006f6a:	0d ac       	ld.ub	r12,r6[0x2]
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	5e a6       	retle	r6
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	60 bc       	ld.w	r12,r0[0x2c]

80006f74 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006f74:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006f76:	30 09       	mov	r9,0
80006f78:	1a d9       	st.w	--sp,r9
80006f7a:	1a d9       	st.w	--sp,r9
80006f7c:	1a d9       	st.w	--sp,r9
80006f7e:	12 98       	mov	r8,r9
80006f80:	e0 6a 01 00 	mov	r10,256
80006f84:	48 9b       	lddpc	r11,80006fa8 <vTaskStartScheduler+0x34>
80006f86:	48 ac       	lddpc	r12,80006fac <vTaskStartScheduler+0x38>
80006f88:	f0 1f 00 0a 	mcall	80006fb0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006f8c:	2f dd       	sub	sp,-12
80006f8e:	58 1c       	cp.w	r12,1
80006f90:	c0 a1       	brne	80006fa4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006f92:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006f94:	30 19       	mov	r9,1
80006f96:	48 88       	lddpc	r8,80006fb4 <vTaskStartScheduler+0x40>
80006f98:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006f9a:	30 09       	mov	r9,0
80006f9c:	48 78       	lddpc	r8,80006fb8 <vTaskStartScheduler+0x44>
80006f9e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006fa0:	f0 1f 00 07 	mcall	80006fbc <vTaskStartScheduler+0x48>
80006fa4:	d8 02       	popm	pc
80006fa6:	00 00       	add	r0,r0
80006fa8:	80 00       	ld.sh	r0,r0[0x0]
80006faa:	db 98       	*unknown*
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	6d 04       	ld.w	r4,r6[0x40]
80006fb0:	80 00       	ld.sh	r0,r0[0x0]
80006fb2:	6d 8c       	ld.w	r12,r6[0x60]
80006fb4:	00 00       	add	r0,r0
80006fb6:	0c 80       	andn	r0,r6
80006fb8:	00 00       	add	r0,r0
80006fba:	0d 70       	ld.ub	r0,--r6
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	5f c0       	srvs	r0

80006fc0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006fc0:	16 cc       	st.b	r11++,r12
	return str;
}
80006fc2:	5e fb       	retal	r11

80006fc4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006fc4:	eb cd 40 c0 	pushm	r6-r7,lr
80006fc8:	20 3d       	sub	sp,12
80006fca:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006fcc:	30 06       	mov	r6,0
80006fce:	30 07       	mov	r7,0
80006fd0:	fa e7 00 00 	st.d	sp[0],r6
80006fd4:	30 0c       	mov	r12,0
80006fd6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006fd8:	58 08       	cp.w	r8,0
80006fda:	c1 30       	breq	80007000 <PrintHex+0x3c>
80006fdc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006fde:	1a 9c       	mov	r12,sp
80006fe0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006fe4:	58 9e       	cp.w	lr,9
80006fe6:	e0 8a 00 04 	brle	80006fee <PrintHex+0x2a>
80006fea:	2c 9e       	sub	lr,-55
80006fec:	c0 48       	rjmp	80006ff4 <PrintHex+0x30>
80006fee:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006ff2:	2d 0e       	sub	lr,-48
80006ff4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006ff8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006ffa:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006ffc:	cf 21       	brne	80006fe0 <PrintHex+0x1c>
80006ffe:	c0 48       	rjmp	80007006 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007000:	33 08       	mov	r8,48
80007002:	ba 88       	st.b	sp[0x0],r8
80007004:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007006:	f6 09 01 08 	sub	r8,r11,r9
8000700a:	58 08       	cp.w	r8,0
8000700c:	e0 8a 00 13 	brle	80007032 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007010:	12 1b       	sub	r11,r9
80007012:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007016:	18 9e       	mov	lr,r12
80007018:	58 0c       	cp.w	r12,0
8000701a:	e0 8a 00 0c 	brle	80007032 <PrintHex+0x6e>
8000701e:	1a 9b       	mov	r11,sp
80007020:	12 0b       	add	r11,r9
80007022:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007024:	33 07       	mov	r7,48
80007026:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007028:	2f f8       	sub	r8,-1
8000702a:	1c 38       	cp.w	r8,lr
8000702c:	cf d5       	brlt	80007026 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000702e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007032:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007036:	f0 cb ff ff 	sub	r11,r8,-1
8000703a:	58 0b       	cp.w	r11,0
8000703c:	e0 8a 00 19 	brle	8000706e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007040:	fa cb ff f4 	sub	r11,sp,-12
80007044:	f6 09 00 09 	add	r9,r11,r9
80007048:	37 8b       	mov	r11,120
8000704a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000704e:	fa c9 ff f4 	sub	r9,sp,-12
80007052:	10 09       	add	r9,r8
80007054:	33 0b       	mov	r11,48
80007056:	f3 6b ff f4 	st.b	r9[-12],r11
8000705a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000705e:	fa ce 00 01 	sub	lr,sp,1
80007062:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007064:	11 8b       	ld.ub	r11,r8[0x0]
80007066:	12 cb       	st.b	r9++,r11
80007068:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000706a:	1c 38       	cp.w	r8,lr
8000706c:	cf c1       	brne	80007064 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000706e:	14 9c       	mov	r12,r10
80007070:	2f dd       	sub	sp,-12
80007072:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007076 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007076:	d4 21       	pushm	r4-r7,lr
80007078:	20 3d       	sub	sp,12
8000707a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000707c:	30 06       	mov	r6,0
8000707e:	30 07       	mov	r7,0
80007080:	fa e7 00 00 	st.d	sp[0],r6
80007084:	30 0c       	mov	r12,0
80007086:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007088:	58 08       	cp.w	r8,0
8000708a:	c0 35       	brlt	80007090 <PrintDec+0x1a>
8000708c:	14 97       	mov	r7,r10
8000708e:	c0 58       	rjmp	80007098 <PrintDec+0x22>
	{
		*p++ = '-';
80007090:	14 97       	mov	r7,r10
80007092:	32 d9       	mov	r9,45
80007094:	0e c9       	st.b	r7++,r9
		i = -i;
80007096:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007098:	58 08       	cp.w	r8,0
8000709a:	c0 51       	brne	800070a4 <PrintDec+0x2e>
8000709c:	33 08       	mov	r8,48
8000709e:	ba 88       	st.b	sp[0x0],r8
800070a0:	30 1e       	mov	lr,1
800070a2:	c2 f8       	rjmp	80007100 <PrintDec+0x8a>
	
	int ten = i%10;
800070a4:	e0 65 66 67 	mov	r5,26215
800070a8:	ea 15 66 66 	orh	r5,0x6666
800070ac:	f0 05 04 44 	muls.d	r4,r8,r5
800070b0:	ea 0c 14 02 	asr	r12,r5,0x2
800070b4:	f0 09 14 1f 	asr	r9,r8,0x1f
800070b8:	f8 09 01 09 	sub	r9,r12,r9
800070bc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800070c0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800070c4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800070c6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800070c8:	e0 66 66 67 	mov	r6,26215
800070cc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800070d0:	2d 09       	sub	r9,-48
800070d2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800070d6:	2f fe       	sub	lr,-1
		i /= 10;
800070d8:	f0 06 04 44 	muls.d	r4,r8,r6
800070dc:	ea 09 14 02 	asr	r9,r5,0x2
800070e0:	bf 58       	asr	r8,0x1f
800070e2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800070e6:	f0 06 04 44 	muls.d	r4,r8,r6
800070ea:	ea 09 14 02 	asr	r9,r5,0x2
800070ee:	f0 05 14 1f 	asr	r5,r8,0x1f
800070f2:	0a 19       	sub	r9,r5
800070f4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800070f8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800070fc:	58 08       	cp.w	r8,0
800070fe:	ce 91       	brne	800070d0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007100:	f6 0e 01 08 	sub	r8,r11,lr
80007104:	58 08       	cp.w	r8,0
80007106:	e0 89 00 06 	brgt	80007112 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000710a:	58 0e       	cp.w	lr,0
8000710c:	e0 89 00 14 	brgt	80007134 <PrintDec+0xbe>
80007110:	c1 d8       	rjmp	8000714a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007112:	1c 1b       	sub	r11,lr
80007114:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007116:	16 9c       	mov	r12,r11
80007118:	58 0b       	cp.w	r11,0
8000711a:	fe 9a ff f8 	brle	8000710a <PrintDec+0x94>
8000711e:	1a 99       	mov	r9,sp
80007120:	1c 09       	add	r9,lr
80007122:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007124:	33 06       	mov	r6,48
80007126:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007128:	2f f8       	sub	r8,-1
8000712a:	18 38       	cp.w	r8,r12
8000712c:	cf d5       	brlt	80007126 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000712e:	f6 0e 00 0e 	add	lr,r11,lr
80007132:	ce cb       	rjmp	8000710a <PrintDec+0x94>
80007134:	fa c8 ff f4 	sub	r8,sp,-12
80007138:	1c 08       	add	r8,lr
8000713a:	20 d8       	sub	r8,13
8000713c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007140:	11 89       	ld.ub	r9,r8[0x0]
80007142:	0e c9       	st.b	r7++,r9
80007144:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007146:	16 38       	cp.w	r8,r11
80007148:	cf c1       	brne	80007140 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000714a:	14 9c       	mov	r12,r10
8000714c:	2f dd       	sub	sp,-12
8000714e:	d8 22       	popm	r4-r7,pc

80007150 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007150:	d4 31       	pushm	r0-r7,lr
80007152:	fa cd 02 08 	sub	sp,sp,520
80007156:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007158:	e0 6a 01 00 	mov	r10,256
8000715c:	30 0b       	mov	r11,0
8000715e:	fa cc fe f8 	sub	r12,sp,-264
80007162:	f0 1f 00 4e 	mcall	80007298 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007166:	fa c4 fd d4 	sub	r4,sp,-556
8000716a:	30 0a       	mov	r10,0
8000716c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000716e:	fa c3 ff fc 	sub	r3,sp,-4
80007172:	e0 61 01 00 	mov	r1,256
80007176:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007178:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000717a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000717e:	02 9a       	mov	r10,r1
80007180:	00 9b       	mov	r11,r0
80007182:	06 9c       	mov	r12,r3
80007184:	f0 1f 00 45 	mcall	80007298 <log+0x148>
			
					if(*str == '%')
80007188:	0f 88       	ld.ub	r8,r7[0x0]
8000718a:	e4 08 18 00 	cp.b	r8,r2
8000718e:	c5 71       	brne	8000723c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007190:	ee c8 ff ff 	sub	r8,r7,-1
80007194:	11 89       	ld.ub	r9,r8[0x0]
80007196:	4c 2a       	lddpc	r10,8000729c <log+0x14c>
80007198:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000719a:	23 09       	sub	r9,48
8000719c:	30 9a       	mov	r10,9
8000719e:	f4 09 18 00 	cp.b	r9,r10
800071a2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800071a6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071aa:	f7 b9 08 30 	subls	r9,48
800071ae:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800071b2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800071b6:	0f 88       	ld.ub	r8,r7[0x0]
800071b8:	22 58       	sub	r8,37
800071ba:	e0 48 00 53 	cp.w	r8,83
800071be:	e0 8b 00 31 	brhi	80007220 <log+0xd0>
800071c2:	4b 89       	lddpc	r9,800072a0 <log+0x150>
800071c4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800071c8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800071cc:	06 9a       	mov	r10,r3
800071ce:	40 0b       	lddsp	r11,sp[0x0]
800071d0:	5c 5b       	castu.b	r11
800071d2:	68 0c       	ld.w	r12,r4[0x0]
800071d4:	f0 1f 00 34 	mcall	800072a4 <log+0x154>
							break;
800071d8:	c2 98       	rjmp	8000722a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800071da:	4b 4c       	lddpc	r12,800072a8 <log+0x158>
800071dc:	f0 1f 00 34 	mcall	800072ac <log+0x15c>
800071e0:	08 95       	mov	r5,r4
800071e2:	06 9c       	mov	r12,r3
							break;
800071e4:	c2 38       	rjmp	8000722a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800071e6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800071ea:	06 9a       	mov	r10,r3
800071ec:	40 0b       	lddsp	r11,sp[0x0]
800071ee:	5c 5b       	castu.b	r11
800071f0:	68 0c       	ld.w	r12,r4[0x0]
800071f2:	f0 1f 00 30 	mcall	800072b0 <log+0x160>
800071f6:	06 9c       	mov	r12,r3
							break;
800071f8:	c1 98       	rjmp	8000722a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800071fa:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800071fe:	06 9b       	mov	r11,r3
80007200:	09 bc       	ld.ub	r12,r4[0x3]
80007202:	f0 1f 00 2d 	mcall	800072b4 <log+0x164>
80007206:	06 9c       	mov	r12,r3
							break;
80007208:	c1 18       	rjmp	8000722a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000720a:	e8 c5 ff fc 	sub	r5,r4,-4
8000720e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007210:	c0 d8       	rjmp	8000722a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007212:	06 9b       	mov	r11,r3
80007214:	32 5c       	mov	r12,37
80007216:	f0 1f 00 28 	mcall	800072b4 <log+0x164>
8000721a:	08 95       	mov	r5,r4
8000721c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000721e:	c0 68       	rjmp	8000722a <log+0xda>
							
							default:
							log("I need relax.");
80007220:	4a 6c       	lddpc	r12,800072b8 <log+0x168>
80007222:	f0 1f 00 23 	mcall	800072ac <log+0x15c>
80007226:	08 95       	mov	r5,r4
80007228:	06 9c       	mov	r12,r3
						}
						str++;
8000722a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000722c:	1a dc       	st.w	--sp,r12
8000722e:	1a d6       	st.w	--sp,r6
80007230:	4a 3b       	lddpc	r11,800072bc <log+0x16c>
80007232:	0c 9c       	mov	r12,r6
80007234:	f0 1f 00 23 	mcall	800072c0 <log+0x170>
80007238:	2f ed       	sub	sp,-8
8000723a:	c0 a8       	rjmp	8000724e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000723c:	2f f7       	sub	r7,-1
8000723e:	1a d8       	st.w	--sp,r8
80007240:	1a d6       	st.w	--sp,r6
80007242:	4a 1b       	lddpc	r11,800072c4 <log+0x174>
80007244:	0c 9c       	mov	r12,r6
80007246:	f0 1f 00 1f 	mcall	800072c0 <log+0x170>
8000724a:	08 95       	mov	r5,r4
8000724c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000724e:	0f 89       	ld.ub	r9,r7[0x0]
80007250:	30 08       	mov	r8,0
80007252:	f0 09 18 00 	cp.b	r9,r8
80007256:	c0 30       	breq	8000725c <log+0x10c>
80007258:	0a 94       	mov	r4,r5
8000725a:	c9 2b       	rjmp	8000717e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000725c:	fa c7 fe f8 	sub	r7,sp,-264
80007260:	1a d7       	st.w	--sp,r7
80007262:	49 ab       	lddpc	r11,800072c8 <log+0x178>
80007264:	0e 9c       	mov	r12,r7
80007266:	f0 1f 00 17 	mcall	800072c0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000726a:	5c 5c       	castu.b	r12
8000726c:	f8 c6 ff ff 	sub	r6,r12,-1
80007270:	0c 9c       	mov	r12,r6
80007272:	f0 1f 00 17 	mcall	800072cc <log+0x17c>
80007276:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007278:	0c 9a       	mov	r10,r6
8000727a:	0e 9b       	mov	r11,r7
8000727c:	f0 1f 00 15 	mcall	800072d0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007280:	30 09       	mov	r9,0
80007282:	30 5a       	mov	r10,5
80007284:	fa cb fe f8 	sub	r11,sp,-264
80007288:	49 38       	lddpc	r8,800072d4 <log+0x184>
8000728a:	70 0c       	ld.w	r12,r8[0x0]
8000728c:	f0 1f 00 13 	mcall	800072d8 <log+0x188>
80007290:	2f fd       	sub	sp,-4
	
	
}
80007292:	fe 3d fd f8 	sub	sp,-520
80007296:	d8 32       	popm	r0-r7,pc
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	7b 3e       	ld.w	lr,sp[0x4c]
8000729c:	00 00       	add	r0,r0
8000729e:	0d b0       	ld.ub	r0,r6[0x3]
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	db a0       	acall	0xba
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	70 76       	ld.w	r6,r8[0x1c]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	de 4c       	*unknown*
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	71 50       	ld.w	r0,r8[0x54]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	6f c4       	ld.w	r4,r7[0x70]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	6f c0       	ld.w	r0,r7[0x70]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	de 5c       	*unknown*
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	de 6c       	*unknown*
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	7e 2c       	ld.w	r12,pc[0x8]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	de 74       	*unknown*
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	de 7c       	*unknown*
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	62 1c       	ld.w	r12,r1[0x4]
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	79 f6       	ld.w	r6,r12[0x7c]
800072d4:	00 00       	add	r0,r0
800072d6:	51 90       	stdsp	sp[0x64],r0
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	65 70       	ld.w	r0,r2[0x5c]

800072dc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800072dc:	d4 31       	pushm	r0-r7,lr
800072de:	fa cd 02 0c 	sub	sp,sp,524
800072e2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800072e4:	e0 6a 01 00 	mov	r10,256
800072e8:	30 0b       	mov	r11,0
800072ea:	fa cc fe f4 	sub	r12,sp,-268
800072ee:	f0 1f 00 4c 	mcall	8000741c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800072f2:	fa c4 fd d0 	sub	r4,sp,-560
800072f6:	30 0a       	mov	r10,0
800072f8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072fa:	fa c3 ff fc 	sub	r3,sp,-4
800072fe:	e0 61 01 00 	mov	r1,256
80007302:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007304:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007306:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000730a:	02 9a       	mov	r10,r1
8000730c:	00 9b       	mov	r11,r0
8000730e:	06 9c       	mov	r12,r3
80007310:	f0 1f 00 43 	mcall	8000741c <logFromISR+0x140>
			
			if(*str == '%')
80007314:	0f 88       	ld.ub	r8,r7[0x0]
80007316:	e4 08 18 00 	cp.b	r8,r2
8000731a:	c5 11       	brne	800073bc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000731c:	ee c8 ff ff 	sub	r8,r7,-1
80007320:	11 89       	ld.ub	r9,r8[0x0]
80007322:	4c 0a       	lddpc	r10,80007420 <logFromISR+0x144>
80007324:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007326:	23 09       	sub	r9,48
80007328:	30 9a       	mov	r10,9
8000732a:	f4 09 18 00 	cp.b	r9,r10
8000732e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007332:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007336:	f7 b9 08 30 	subls	r9,48
8000733a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000733e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007342:	0f 88       	ld.ub	r8,r7[0x0]
80007344:	22 58       	sub	r8,37
80007346:	e0 48 00 53 	cp.w	r8,83
8000734a:	e0 8b 00 2b 	brhi	800073a0 <logFromISR+0xc4>
8000734e:	4b 69       	lddpc	r9,80007424 <logFromISR+0x148>
80007350:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007354:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007358:	06 9a       	mov	r10,r3
8000735a:	40 0b       	lddsp	r11,sp[0x0]
8000735c:	5c 5b       	castu.b	r11
8000735e:	68 0c       	ld.w	r12,r4[0x0]
80007360:	f0 1f 00 32 	mcall	80007428 <logFromISR+0x14c>
					break;
80007364:	c2 38       	rjmp	800073aa <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007366:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000736a:	06 9a       	mov	r10,r3
8000736c:	40 0b       	lddsp	r11,sp[0x0]
8000736e:	5c 5b       	castu.b	r11
80007370:	68 0c       	ld.w	r12,r4[0x0]
80007372:	f0 1f 00 2f 	mcall	8000742c <logFromISR+0x150>
80007376:	06 9c       	mov	r12,r3
					break;
80007378:	c1 98       	rjmp	800073aa <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000737a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000737e:	06 9b       	mov	r11,r3
80007380:	09 bc       	ld.ub	r12,r4[0x3]
80007382:	f0 1f 00 2c 	mcall	80007430 <logFromISR+0x154>
80007386:	06 9c       	mov	r12,r3
					break;
80007388:	c1 18       	rjmp	800073aa <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000738a:	e8 c5 ff fc 	sub	r5,r4,-4
8000738e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007390:	c0 d8       	rjmp	800073aa <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007392:	06 9b       	mov	r11,r3
80007394:	32 5c       	mov	r12,37
80007396:	f0 1f 00 27 	mcall	80007430 <logFromISR+0x154>
8000739a:	08 95       	mov	r5,r4
8000739c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000739e:	c0 68       	rjmp	800073aa <logFromISR+0xce>
					default:
					log("I need relax.");
800073a0:	4a 5c       	lddpc	r12,80007434 <logFromISR+0x158>
800073a2:	f0 1f 00 26 	mcall	80007438 <logFromISR+0x15c>
800073a6:	08 95       	mov	r5,r4
800073a8:	06 9c       	mov	r12,r3
				}
				str++;
800073aa:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800073ac:	1a dc       	st.w	--sp,r12
800073ae:	1a d6       	st.w	--sp,r6
800073b0:	4a 3b       	lddpc	r11,8000743c <logFromISR+0x160>
800073b2:	0c 9c       	mov	r12,r6
800073b4:	f0 1f 00 23 	mcall	80007440 <logFromISR+0x164>
800073b8:	2f ed       	sub	sp,-8
800073ba:	c0 a8       	rjmp	800073ce <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800073bc:	2f f7       	sub	r7,-1
800073be:	1a d8       	st.w	--sp,r8
800073c0:	1a d6       	st.w	--sp,r6
800073c2:	4a 1b       	lddpc	r11,80007444 <logFromISR+0x168>
800073c4:	0c 9c       	mov	r12,r6
800073c6:	f0 1f 00 1f 	mcall	80007440 <logFromISR+0x164>
800073ca:	08 95       	mov	r5,r4
800073cc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800073ce:	0f 89       	ld.ub	r9,r7[0x0]
800073d0:	30 08       	mov	r8,0
800073d2:	f0 09 18 00 	cp.b	r9,r8
800073d6:	c0 30       	breq	800073dc <logFromISR+0x100>
800073d8:	0a 94       	mov	r4,r5
800073da:	c9 8b       	rjmp	8000730a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800073dc:	fa c7 fe f4 	sub	r7,sp,-268
800073e0:	1a d7       	st.w	--sp,r7
800073e2:	49 ab       	lddpc	r11,80007448 <logFromISR+0x16c>
800073e4:	0e 9c       	mov	r12,r7
800073e6:	f0 1f 00 17 	mcall	80007440 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800073ea:	5c 5c       	castu.b	r12
800073ec:	f8 c6 ff ff 	sub	r6,r12,-1
800073f0:	0c 9c       	mov	r12,r6
800073f2:	f0 1f 00 17 	mcall	8000744c <logFromISR+0x170>
800073f6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800073f8:	0c 9a       	mov	r10,r6
800073fa:	0e 9b       	mov	r11,r7
800073fc:	f0 1f 00 15 	mcall	80007450 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007400:	30 09       	mov	r9,0
80007402:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007404:	fa ca fe f8 	sub	r10,sp,-264
80007408:	fa cb fe f4 	sub	r11,sp,-268
8000740c:	49 28       	lddpc	r8,80007454 <logFromISR+0x178>
8000740e:	70 0c       	ld.w	r12,r8[0x0]
80007410:	f0 1f 00 12 	mcall	80007458 <logFromISR+0x17c>
80007414:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007416:	fe 3d fd f4 	sub	sp,-524
8000741a:	d8 32       	popm	r0-r7,pc
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	7b 3e       	ld.w	lr,sp[0x4c]
80007420:	00 00       	add	r0,r0
80007422:	0d b1       	ld.ub	r1,r6[0x3]
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	dc f0       	acall	0xcf
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	70 76       	ld.w	r6,r8[0x1c]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	6f c4       	ld.w	r4,r7[0x70]
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	6f c0       	ld.w	r0,r7[0x70]
80007434:	80 00       	ld.sh	r0,r0[0x0]
80007436:	de 5c       	*unknown*
80007438:	80 00       	ld.sh	r0,r0[0x0]
8000743a:	71 50       	ld.w	r0,r8[0x54]
8000743c:	80 00       	ld.sh	r0,r0[0x0]
8000743e:	de 6c       	*unknown*
80007440:	80 00       	ld.sh	r0,r0[0x0]
80007442:	7e 2c       	ld.w	r12,pc[0x8]
80007444:	80 00       	ld.sh	r0,r0[0x0]
80007446:	de 74       	*unknown*
80007448:	80 00       	ld.sh	r0,r0[0x0]
8000744a:	de 7c       	*unknown*
8000744c:	80 00       	ld.sh	r0,r0[0x0]
8000744e:	62 1c       	ld.w	r12,r1[0x4]
80007450:	80 00       	ld.sh	r0,r0[0x0]
80007452:	79 f6       	ld.w	r6,r12[0x7c]
80007454:	00 00       	add	r0,r0
80007456:	51 90       	stdsp	sp[0x64],r0
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	65 20       	ld.w	r0,r2[0x48]

8000745c <log_init>:
		
	return str;
}

void log_init(void)
{
8000745c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000745e:	30 2b       	mov	r11,2
80007460:	49 0c       	lddpc	r12,800074a0 <log_init+0x44>
80007462:	f0 1f 00 11 	mcall	800074a4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007466:	e0 6a 36 00 	mov	r10,13824
8000746a:	ea 1a 01 6e 	orh	r10,0x16e
8000746e:	48 fb       	lddpc	r11,800074a8 <log_init+0x4c>
80007470:	fe 7c 18 00 	mov	r12,-59392
80007474:	f0 1f 00 0e 	mcall	800074ac <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007478:	30 4b       	mov	r11,4
8000747a:	33 2c       	mov	r12,50
8000747c:	f0 1f 00 0d 	mcall	800074b0 <log_init+0x54>
80007480:	48 d8       	lddpc	r8,800074b4 <log_init+0x58>
80007482:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007484:	30 09       	mov	r9,0
80007486:	1a d9       	st.w	--sp,r9
80007488:	1a d9       	st.w	--sp,r9
8000748a:	1a d9       	st.w	--sp,r9
8000748c:	30 28       	mov	r8,2
8000748e:	e0 6a 01 80 	mov	r10,384
80007492:	48 ab       	lddpc	r11,800074b8 <log_init+0x5c>
80007494:	48 ac       	lddpc	r12,800074bc <log_init+0x60>
80007496:	f0 1f 00 0b 	mcall	800074c0 <log_init+0x64>
8000749a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000749c:	d8 02       	popm	pc
8000749e:	00 00       	add	r0,r0
800074a0:	80 00       	ld.sh	r0,r0[0x0]
800074a2:	de 88       	*unknown*
800074a4:	80 00       	ld.sh	r0,r0[0x0]
800074a6:	58 4c       	cp.w	r12,4
800074a8:	80 00       	ld.sh	r0,r0[0x0]
800074aa:	de 40       	acall	0xe4
800074ac:	80 00       	ld.sh	r0,r0[0x0]
800074ae:	5d 80       	*unknown*
800074b0:	80 00       	ld.sh	r0,r0[0x0]
800074b2:	66 70       	ld.w	r0,r3[0x1c]
800074b4:	00 00       	add	r0,r0
800074b6:	51 90       	stdsp	sp[0x64],r0
800074b8:	80 00       	ld.sh	r0,r0[0x0]
800074ba:	de 84       	*unknown*
800074bc:	80 00       	ld.sh	r0,r0[0x0]
800074be:	74 c4       	ld.w	r4,r10[0x30]
800074c0:	80 00       	ld.sh	r0,r0[0x0]
800074c2:	6d 8c       	ld.w	r12,r6[0x60]

800074c4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800074c4:	eb cd 40 f8 	pushm	r3-r7,lr
800074c8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800074ca:	48 c7       	lddpc	r7,800074f8 <task_log+0x34>
800074cc:	30 05       	mov	r5,0
800074ce:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800074d0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800074d4:	0a 99       	mov	r9,r5
800074d6:	08 9a       	mov	r10,r4
800074d8:	1a 9b       	mov	r11,sp
800074da:	6e 0c       	ld.w	r12,r7[0x0]
800074dc:	f0 1f 00 08 	mcall	800074fc <task_log+0x38>
800074e0:	58 1c       	cp.w	r12,1
800074e2:	cf 91       	brne	800074d4 <task_log+0x10>
		{
			if( NULL != str)
800074e4:	40 0b       	lddsp	r11,sp[0x0]
800074e6:	58 0b       	cp.w	r11,0
800074e8:	cf 60       	breq	800074d4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800074ea:	06 9c       	mov	r12,r3
800074ec:	f0 1f 00 05 	mcall	80007500 <task_log+0x3c>
				vPortFree(str);
800074f0:	40 0c       	lddsp	r12,sp[0x0]
800074f2:	f0 1f 00 05 	mcall	80007504 <task_log+0x40>
800074f6:	ce fb       	rjmp	800074d4 <task_log+0x10>
800074f8:	00 00       	add	r0,r0
800074fa:	51 90       	stdsp	sp[0x64],r0
800074fc:	80 00       	ld.sh	r0,r0[0x0]
800074fe:	63 64       	ld.w	r4,r1[0x58]
80007500:	80 00       	ld.sh	r0,r0[0x0]
80007502:	5d 30       	musfr	r0
80007504:	80 00       	ld.sh	r0,r0[0x0]
80007506:	61 f4       	ld.w	r4,r0[0x7c]

80007508 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007508:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000750a:	fe 78 10 00 	mov	r8,-61440
8000750e:	30 19       	mov	r9,1
80007510:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007514:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007518:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000751c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000751e:	f0 1f 00 0c 	mcall	8000754c <main+0x44>
		
	INTC_init_interrupts();
80007522:	f0 1f 00 0c 	mcall	80007550 <main+0x48>
		
	log_init();
80007526:	f0 1f 00 0c 	mcall	80007554 <main+0x4c>
	log("----start debug----");
8000752a:	48 cc       	lddpc	r12,80007558 <main+0x50>
8000752c:	f0 1f 00 0c 	mcall	8000755c <main+0x54>
	
	xg_flashc_init();
80007530:	f0 1f 00 0c 	mcall	80007560 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007534:	f0 1f 00 0c 	mcall	80007564 <main+0x5c>
		
	app_init();
80007538:	f0 1f 00 0c 	mcall	80007568 <main+0x60>
		
	xcmp_init();
8000753c:	f0 1f 00 0c 	mcall	8000756c <main+0x64>

	local_start_timer();
80007540:	f0 1f 00 0c 	mcall	80007570 <main+0x68>
	
	//xg_rtc_init();
		
	vTaskStartScheduler();
80007544:	f0 1f 00 0c 	mcall	80007574 <main+0x6c>
	return 0;
	
}
80007548:	d8 0a       	popm	pc,r12=0
8000754a:	00 00       	add	r0,r0
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	4f cc       	lddpc	r12,8000773c <_malloc_r+0x1a4>
80007550:	80 00       	ld.sh	r0,r0[0x0]
80007552:	59 50       	cp.w	r0,21
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	74 5c       	ld.w	r12,r10[0x14]
80007558:	80 00       	ld.sh	r0,r0[0x0]
8000755a:	de 98       	*unknown*
8000755c:	80 00       	ld.sh	r0,r0[0x0]
8000755e:	71 50       	ld.w	r0,r8[0x54]
80007560:	80 00       	ld.sh	r0,r0[0x0]
80007562:	50 b0       	stdsp	sp[0x2c],r0
80007564:	80 00       	ld.sh	r0,r0[0x0]
80007566:	4f c0       	lddpc	r0,80007754 <_malloc_r+0x1bc>
80007568:	80 00       	ld.sh	r0,r0[0x0]
8000756a:	20 3c       	sub	r12,3
8000756c:	80 00       	ld.sh	r0,r0[0x0]
8000756e:	3e e4       	mov	r4,-18
80007570:	80 00       	ld.sh	r0,r0[0x0]
80007572:	50 84       	stdsp	sp[0x20],r4
80007574:	80 00       	ld.sh	r0,r0[0x0]
80007576:	6f 74       	ld.w	r4,r7[0x5c]

80007578 <free>:
80007578:	d4 01       	pushm	lr
8000757a:	e0 68 0a 48 	mov	r8,2632
8000757e:	18 9b       	mov	r11,r12
80007580:	70 0c       	ld.w	r12,r8[0x0]
80007582:	e0 a0 1e 73 	rcall	8000b268 <_free_r>
80007586:	d8 02       	popm	pc

80007588 <malloc>:
80007588:	d4 01       	pushm	lr
8000758a:	e0 68 0a 48 	mov	r8,2632
8000758e:	18 9b       	mov	r11,r12
80007590:	70 0c       	ld.w	r12,r8[0x0]
80007592:	c0 3c       	rcall	80007598 <_malloc_r>
80007594:	d8 02       	popm	pc
80007596:	d7 03       	nop

80007598 <_malloc_r>:
80007598:	d4 31       	pushm	r0-r7,lr
8000759a:	f6 c8 ff f5 	sub	r8,r11,-11
8000759e:	18 95       	mov	r5,r12
800075a0:	10 97       	mov	r7,r8
800075a2:	e0 17 ff f8 	andl	r7,0xfff8
800075a6:	59 68       	cp.w	r8,22
800075a8:	f9 b7 08 10 	movls	r7,16
800075ac:	16 37       	cp.w	r7,r11
800075ae:	5f 38       	srlo	r8
800075b0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800075b4:	c0 50       	breq	800075be <_malloc_r+0x26>
800075b6:	30 c8       	mov	r8,12
800075b8:	99 38       	st.w	r12[0xc],r8
800075ba:	e0 8f 01 fa 	bral	800079ae <_malloc_r+0x416>
800075be:	fe b0 f5 d1 	rcall	80006160 <__malloc_lock>
800075c2:	e0 47 01 f7 	cp.w	r7,503
800075c6:	e0 8b 00 1d 	brhi	80007600 <_malloc_r+0x68>
800075ca:	ee 03 16 03 	lsr	r3,r7,0x3
800075ce:	e0 68 05 48 	mov	r8,1352
800075d2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800075d6:	70 36       	ld.w	r6,r8[0xc]
800075d8:	10 36       	cp.w	r6,r8
800075da:	c0 61       	brne	800075e6 <_malloc_r+0x4e>
800075dc:	ec c8 ff f8 	sub	r8,r6,-8
800075e0:	70 36       	ld.w	r6,r8[0xc]
800075e2:	10 36       	cp.w	r6,r8
800075e4:	c0 c0       	breq	800075fc <_malloc_r+0x64>
800075e6:	6c 18       	ld.w	r8,r6[0x4]
800075e8:	e0 18 ff fc 	andl	r8,0xfffc
800075ec:	6c 3a       	ld.w	r10,r6[0xc]
800075ee:	ec 08 00 09 	add	r9,r6,r8
800075f2:	0a 9c       	mov	r12,r5
800075f4:	6c 28       	ld.w	r8,r6[0x8]
800075f6:	95 28       	st.w	r10[0x8],r8
800075f8:	91 3a       	st.w	r8[0xc],r10
800075fa:	c4 78       	rjmp	80007688 <_malloc_r+0xf0>
800075fc:	2f e3       	sub	r3,-2
800075fe:	c4 d8       	rjmp	80007698 <_malloc_r+0x100>
80007600:	ee 03 16 09 	lsr	r3,r7,0x9
80007604:	c0 41       	brne	8000760c <_malloc_r+0x74>
80007606:	ee 03 16 03 	lsr	r3,r7,0x3
8000760a:	c2 68       	rjmp	80007656 <_malloc_r+0xbe>
8000760c:	58 43       	cp.w	r3,4
8000760e:	e0 8b 00 06 	brhi	8000761a <_malloc_r+0x82>
80007612:	ee 03 16 06 	lsr	r3,r7,0x6
80007616:	2c 83       	sub	r3,-56
80007618:	c1 f8       	rjmp	80007656 <_malloc_r+0xbe>
8000761a:	59 43       	cp.w	r3,20
8000761c:	e0 8b 00 04 	brhi	80007624 <_malloc_r+0x8c>
80007620:	2a 53       	sub	r3,-91
80007622:	c1 a8       	rjmp	80007656 <_malloc_r+0xbe>
80007624:	e0 43 00 54 	cp.w	r3,84
80007628:	e0 8b 00 06 	brhi	80007634 <_malloc_r+0x9c>
8000762c:	ee 03 16 0c 	lsr	r3,r7,0xc
80007630:	29 23       	sub	r3,-110
80007632:	c1 28       	rjmp	80007656 <_malloc_r+0xbe>
80007634:	e0 43 01 54 	cp.w	r3,340
80007638:	e0 8b 00 06 	brhi	80007644 <_malloc_r+0xac>
8000763c:	ee 03 16 0f 	lsr	r3,r7,0xf
80007640:	28 93       	sub	r3,-119
80007642:	c0 a8       	rjmp	80007656 <_malloc_r+0xbe>
80007644:	e0 43 05 54 	cp.w	r3,1364
80007648:	e0 88 00 04 	brls	80007650 <_malloc_r+0xb8>
8000764c:	37 e3       	mov	r3,126
8000764e:	c0 48       	rjmp	80007656 <_malloc_r+0xbe>
80007650:	ee 03 16 12 	lsr	r3,r7,0x12
80007654:	28 43       	sub	r3,-124
80007656:	e0 6a 05 48 	mov	r10,1352
8000765a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000765e:	74 36       	ld.w	r6,r10[0xc]
80007660:	c1 98       	rjmp	80007692 <_malloc_r+0xfa>
80007662:	6c 19       	ld.w	r9,r6[0x4]
80007664:	e0 19 ff fc 	andl	r9,0xfffc
80007668:	f2 07 01 0b 	sub	r11,r9,r7
8000766c:	58 fb       	cp.w	r11,15
8000766e:	e0 8a 00 04 	brle	80007676 <_malloc_r+0xde>
80007672:	20 13       	sub	r3,1
80007674:	c1 18       	rjmp	80007696 <_malloc_r+0xfe>
80007676:	6c 38       	ld.w	r8,r6[0xc]
80007678:	58 0b       	cp.w	r11,0
8000767a:	c0 b5       	brlt	80007690 <_malloc_r+0xf8>
8000767c:	6c 2a       	ld.w	r10,r6[0x8]
8000767e:	ec 09 00 09 	add	r9,r6,r9
80007682:	0a 9c       	mov	r12,r5
80007684:	91 2a       	st.w	r8[0x8],r10
80007686:	95 38       	st.w	r10[0xc],r8
80007688:	72 18       	ld.w	r8,r9[0x4]
8000768a:	a1 a8       	sbr	r8,0x0
8000768c:	93 18       	st.w	r9[0x4],r8
8000768e:	cb c8       	rjmp	80007806 <_malloc_r+0x26e>
80007690:	10 96       	mov	r6,r8
80007692:	14 36       	cp.w	r6,r10
80007694:	ce 71       	brne	80007662 <_malloc_r+0xca>
80007696:	2f f3       	sub	r3,-1
80007698:	e0 6a 05 48 	mov	r10,1352
8000769c:	f4 cc ff f8 	sub	r12,r10,-8
800076a0:	78 26       	ld.w	r6,r12[0x8]
800076a2:	18 36       	cp.w	r6,r12
800076a4:	c6 c0       	breq	8000777c <_malloc_r+0x1e4>
800076a6:	6c 19       	ld.w	r9,r6[0x4]
800076a8:	e0 19 ff fc 	andl	r9,0xfffc
800076ac:	f2 07 01 08 	sub	r8,r9,r7
800076b0:	58 f8       	cp.w	r8,15
800076b2:	e0 89 00 8f 	brgt	800077d0 <_malloc_r+0x238>
800076b6:	99 3c       	st.w	r12[0xc],r12
800076b8:	99 2c       	st.w	r12[0x8],r12
800076ba:	58 08       	cp.w	r8,0
800076bc:	c0 55       	brlt	800076c6 <_malloc_r+0x12e>
800076be:	ec 09 00 09 	add	r9,r6,r9
800076c2:	0a 9c       	mov	r12,r5
800076c4:	ce 2b       	rjmp	80007688 <_malloc_r+0xf0>
800076c6:	e0 49 01 ff 	cp.w	r9,511
800076ca:	e0 8b 00 13 	brhi	800076f0 <_malloc_r+0x158>
800076ce:	a3 99       	lsr	r9,0x3
800076d0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800076d4:	70 2b       	ld.w	r11,r8[0x8]
800076d6:	8d 38       	st.w	r6[0xc],r8
800076d8:	8d 2b       	st.w	r6[0x8],r11
800076da:	97 36       	st.w	r11[0xc],r6
800076dc:	91 26       	st.w	r8[0x8],r6
800076de:	a3 49       	asr	r9,0x2
800076e0:	74 18       	ld.w	r8,r10[0x4]
800076e2:	30 1b       	mov	r11,1
800076e4:	f6 09 09 49 	lsl	r9,r11,r9
800076e8:	f1 e9 10 09 	or	r9,r8,r9
800076ec:	95 19       	st.w	r10[0x4],r9
800076ee:	c4 78       	rjmp	8000777c <_malloc_r+0x1e4>
800076f0:	f2 0a 16 09 	lsr	r10,r9,0x9
800076f4:	58 4a       	cp.w	r10,4
800076f6:	e0 8b 00 07 	brhi	80007704 <_malloc_r+0x16c>
800076fa:	f2 0a 16 06 	lsr	r10,r9,0x6
800076fe:	2c 8a       	sub	r10,-56
80007700:	c2 08       	rjmp	80007740 <_malloc_r+0x1a8>
80007702:	d7 03       	nop
80007704:	59 4a       	cp.w	r10,20
80007706:	e0 8b 00 04 	brhi	8000770e <_malloc_r+0x176>
8000770a:	2a 5a       	sub	r10,-91
8000770c:	c1 a8       	rjmp	80007740 <_malloc_r+0x1a8>
8000770e:	e0 4a 00 54 	cp.w	r10,84
80007712:	e0 8b 00 06 	brhi	8000771e <_malloc_r+0x186>
80007716:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000771a:	29 2a       	sub	r10,-110
8000771c:	c1 28       	rjmp	80007740 <_malloc_r+0x1a8>
8000771e:	e0 4a 01 54 	cp.w	r10,340
80007722:	e0 8b 00 06 	brhi	8000772e <_malloc_r+0x196>
80007726:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000772a:	28 9a       	sub	r10,-119
8000772c:	c0 a8       	rjmp	80007740 <_malloc_r+0x1a8>
8000772e:	e0 4a 05 54 	cp.w	r10,1364
80007732:	e0 88 00 04 	brls	8000773a <_malloc_r+0x1a2>
80007736:	37 ea       	mov	r10,126
80007738:	c0 48       	rjmp	80007740 <_malloc_r+0x1a8>
8000773a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000773e:	28 4a       	sub	r10,-124
80007740:	e0 6b 05 48 	mov	r11,1352
80007744:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007748:	68 28       	ld.w	r8,r4[0x8]
8000774a:	08 38       	cp.w	r8,r4
8000774c:	c0 e1       	brne	80007768 <_malloc_r+0x1d0>
8000774e:	76 19       	ld.w	r9,r11[0x4]
80007750:	a3 4a       	asr	r10,0x2
80007752:	30 1e       	mov	lr,1
80007754:	fc 0a 09 4a 	lsl	r10,lr,r10
80007758:	f3 ea 10 0a 	or	r10,r9,r10
8000775c:	10 99       	mov	r9,r8
8000775e:	97 1a       	st.w	r11[0x4],r10
80007760:	c0 a8       	rjmp	80007774 <_malloc_r+0x1dc>
80007762:	70 28       	ld.w	r8,r8[0x8]
80007764:	08 38       	cp.w	r8,r4
80007766:	c0 60       	breq	80007772 <_malloc_r+0x1da>
80007768:	70 1a       	ld.w	r10,r8[0x4]
8000776a:	e0 1a ff fc 	andl	r10,0xfffc
8000776e:	14 39       	cp.w	r9,r10
80007770:	cf 93       	brcs	80007762 <_malloc_r+0x1ca>
80007772:	70 39       	ld.w	r9,r8[0xc]
80007774:	8d 39       	st.w	r6[0xc],r9
80007776:	8d 28       	st.w	r6[0x8],r8
80007778:	91 36       	st.w	r8[0xc],r6
8000777a:	93 26       	st.w	r9[0x8],r6
8000777c:	e6 08 14 02 	asr	r8,r3,0x2
80007780:	30 1b       	mov	r11,1
80007782:	e0 64 05 48 	mov	r4,1352
80007786:	f6 08 09 4b 	lsl	r11,r11,r8
8000778a:	68 18       	ld.w	r8,r4[0x4]
8000778c:	10 3b       	cp.w	r11,r8
8000778e:	e0 8b 00 6b 	brhi	80007864 <_malloc_r+0x2cc>
80007792:	f7 e8 00 09 	and	r9,r11,r8
80007796:	c0 b1       	brne	800077ac <_malloc_r+0x214>
80007798:	e0 13 ff fc 	andl	r3,0xfffc
8000779c:	a1 7b       	lsl	r11,0x1
8000779e:	2f c3       	sub	r3,-4
800077a0:	c0 38       	rjmp	800077a6 <_malloc_r+0x20e>
800077a2:	2f c3       	sub	r3,-4
800077a4:	a1 7b       	lsl	r11,0x1
800077a6:	f7 e8 00 09 	and	r9,r11,r8
800077aa:	cf c0       	breq	800077a2 <_malloc_r+0x20a>
800077ac:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800077b0:	06 92       	mov	r2,r3
800077b2:	1c 91       	mov	r1,lr
800077b4:	62 36       	ld.w	r6,r1[0xc]
800077b6:	c2 e8       	rjmp	80007812 <_malloc_r+0x27a>
800077b8:	6c 1a       	ld.w	r10,r6[0x4]
800077ba:	e0 1a ff fc 	andl	r10,0xfffc
800077be:	f4 07 01 08 	sub	r8,r10,r7
800077c2:	58 f8       	cp.w	r8,15
800077c4:	e0 8a 00 15 	brle	800077ee <_malloc_r+0x256>
800077c8:	6c 3a       	ld.w	r10,r6[0xc]
800077ca:	6c 29       	ld.w	r9,r6[0x8]
800077cc:	95 29       	st.w	r10[0x8],r9
800077ce:	93 3a       	st.w	r9[0xc],r10
800077d0:	0e 99       	mov	r9,r7
800077d2:	ec 07 00 07 	add	r7,r6,r7
800077d6:	a1 a9       	sbr	r9,0x0
800077d8:	99 37       	st.w	r12[0xc],r7
800077da:	99 27       	st.w	r12[0x8],r7
800077dc:	8d 19       	st.w	r6[0x4],r9
800077de:	ee 08 09 08 	st.w	r7[r8],r8
800077e2:	8f 2c       	st.w	r7[0x8],r12
800077e4:	8f 3c       	st.w	r7[0xc],r12
800077e6:	a1 a8       	sbr	r8,0x0
800077e8:	0a 9c       	mov	r12,r5
800077ea:	8f 18       	st.w	r7[0x4],r8
800077ec:	c0 d8       	rjmp	80007806 <_malloc_r+0x26e>
800077ee:	6c 39       	ld.w	r9,r6[0xc]
800077f0:	58 08       	cp.w	r8,0
800077f2:	c0 f5       	brlt	80007810 <_malloc_r+0x278>
800077f4:	ec 0a 00 0a 	add	r10,r6,r10
800077f8:	74 18       	ld.w	r8,r10[0x4]
800077fa:	a1 a8       	sbr	r8,0x0
800077fc:	0a 9c       	mov	r12,r5
800077fe:	95 18       	st.w	r10[0x4],r8
80007800:	6c 28       	ld.w	r8,r6[0x8]
80007802:	93 28       	st.w	r9[0x8],r8
80007804:	91 39       	st.w	r8[0xc],r9
80007806:	fe b0 f4 b3 	rcall	8000616c <__malloc_unlock>
8000780a:	ec cc ff f8 	sub	r12,r6,-8
8000780e:	d8 32       	popm	r0-r7,pc
80007810:	12 96       	mov	r6,r9
80007812:	02 36       	cp.w	r6,r1
80007814:	cd 21       	brne	800077b8 <_malloc_r+0x220>
80007816:	2f f2       	sub	r2,-1
80007818:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000781c:	c0 30       	breq	80007822 <_malloc_r+0x28a>
8000781e:	2f 81       	sub	r1,-8
80007820:	cc ab       	rjmp	800077b4 <_malloc_r+0x21c>
80007822:	1c 98       	mov	r8,lr
80007824:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007828:	c0 81       	brne	80007838 <_malloc_r+0x2a0>
8000782a:	68 19       	ld.w	r9,r4[0x4]
8000782c:	f6 08 11 ff 	rsub	r8,r11,-1
80007830:	f3 e8 00 08 	and	r8,r9,r8
80007834:	89 18       	st.w	r4[0x4],r8
80007836:	c0 78       	rjmp	80007844 <_malloc_r+0x2ac>
80007838:	f0 c9 00 08 	sub	r9,r8,8
8000783c:	20 13       	sub	r3,1
8000783e:	70 08       	ld.w	r8,r8[0x0]
80007840:	12 38       	cp.w	r8,r9
80007842:	cf 10       	breq	80007824 <_malloc_r+0x28c>
80007844:	a1 7b       	lsl	r11,0x1
80007846:	68 18       	ld.w	r8,r4[0x4]
80007848:	10 3b       	cp.w	r11,r8
8000784a:	e0 8b 00 0d 	brhi	80007864 <_malloc_r+0x2cc>
8000784e:	58 0b       	cp.w	r11,0
80007850:	c0 a0       	breq	80007864 <_malloc_r+0x2cc>
80007852:	04 93       	mov	r3,r2
80007854:	c0 38       	rjmp	8000785a <_malloc_r+0x2c2>
80007856:	2f c3       	sub	r3,-4
80007858:	a1 7b       	lsl	r11,0x1
8000785a:	f7 e8 00 09 	and	r9,r11,r8
8000785e:	ca 71       	brne	800077ac <_malloc_r+0x214>
80007860:	cf bb       	rjmp	80007856 <_malloc_r+0x2be>
80007862:	d7 03       	nop
80007864:	68 23       	ld.w	r3,r4[0x8]
80007866:	66 12       	ld.w	r2,r3[0x4]
80007868:	e0 12 ff fc 	andl	r2,0xfffc
8000786c:	0e 32       	cp.w	r2,r7
8000786e:	5f 39       	srlo	r9
80007870:	e4 07 01 08 	sub	r8,r2,r7
80007874:	58 f8       	cp.w	r8,15
80007876:	5f aa       	srle	r10
80007878:	f5 e9 10 09 	or	r9,r10,r9
8000787c:	e0 80 00 9a 	breq	800079b0 <_malloc_r+0x418>
80007880:	e0 68 0d bc 	mov	r8,3516
80007884:	70 01       	ld.w	r1,r8[0x0]
80007886:	e0 68 09 54 	mov	r8,2388
8000788a:	2f 01       	sub	r1,-16
8000788c:	70 08       	ld.w	r8,r8[0x0]
8000788e:	0e 01       	add	r1,r7
80007890:	5b f8       	cp.w	r8,-1
80007892:	c0 40       	breq	8000789a <_malloc_r+0x302>
80007894:	28 11       	sub	r1,-127
80007896:	e0 11 ff 80 	andl	r1,0xff80
8000789a:	02 9b       	mov	r11,r1
8000789c:	0a 9c       	mov	r12,r5
8000789e:	e0 a0 02 b7 	rcall	80007e0c <_sbrk_r>
800078a2:	18 96       	mov	r6,r12
800078a4:	5b fc       	cp.w	r12,-1
800078a6:	c7 50       	breq	80007990 <_malloc_r+0x3f8>
800078a8:	e6 02 00 08 	add	r8,r3,r2
800078ac:	10 3c       	cp.w	r12,r8
800078ae:	c0 32       	brcc	800078b4 <_malloc_r+0x31c>
800078b0:	08 33       	cp.w	r3,r4
800078b2:	c6 f1       	brne	80007990 <_malloc_r+0x3f8>
800078b4:	e0 6a 0d c0 	mov	r10,3520
800078b8:	74 09       	ld.w	r9,r10[0x0]
800078ba:	e2 09 00 09 	add	r9,r1,r9
800078be:	95 09       	st.w	r10[0x0],r9
800078c0:	10 36       	cp.w	r6,r8
800078c2:	c0 a1       	brne	800078d6 <_malloc_r+0x33e>
800078c4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800078c8:	c0 71       	brne	800078d6 <_malloc_r+0x33e>
800078ca:	e2 02 00 02 	add	r2,r1,r2
800078ce:	68 28       	ld.w	r8,r4[0x8]
800078d0:	a1 a2       	sbr	r2,0x0
800078d2:	91 12       	st.w	r8[0x4],r2
800078d4:	c4 f8       	rjmp	80007972 <_malloc_r+0x3da>
800078d6:	e0 6a 09 54 	mov	r10,2388
800078da:	74 0b       	ld.w	r11,r10[0x0]
800078dc:	5b fb       	cp.w	r11,-1
800078de:	c0 31       	brne	800078e4 <_malloc_r+0x34c>
800078e0:	95 06       	st.w	r10[0x0],r6
800078e2:	c0 78       	rjmp	800078f0 <_malloc_r+0x358>
800078e4:	ec 09 00 09 	add	r9,r6,r9
800078e8:	e0 6a 0d c0 	mov	r10,3520
800078ec:	10 19       	sub	r9,r8
800078ee:	95 09       	st.w	r10[0x0],r9
800078f0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800078f4:	f0 09 11 08 	rsub	r9,r8,8
800078f8:	58 08       	cp.w	r8,0
800078fa:	f2 08 17 10 	movne	r8,r9
800078fe:	ed d8 e1 06 	addne	r6,r6,r8
80007902:	28 08       	sub	r8,-128
80007904:	ec 01 00 01 	add	r1,r6,r1
80007908:	0a 9c       	mov	r12,r5
8000790a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000790e:	f0 01 01 01 	sub	r1,r8,r1
80007912:	02 9b       	mov	r11,r1
80007914:	e0 a0 02 7c 	rcall	80007e0c <_sbrk_r>
80007918:	e0 68 0d c0 	mov	r8,3520
8000791c:	5b fc       	cp.w	r12,-1
8000791e:	ec 0c 17 00 	moveq	r12,r6
80007922:	f9 b1 00 00 	moveq	r1,0
80007926:	70 09       	ld.w	r9,r8[0x0]
80007928:	0c 1c       	sub	r12,r6
8000792a:	89 26       	st.w	r4[0x8],r6
8000792c:	02 0c       	add	r12,r1
8000792e:	12 01       	add	r1,r9
80007930:	a1 ac       	sbr	r12,0x0
80007932:	91 01       	st.w	r8[0x0],r1
80007934:	8d 1c       	st.w	r6[0x4],r12
80007936:	08 33       	cp.w	r3,r4
80007938:	c1 d0       	breq	80007972 <_malloc_r+0x3da>
8000793a:	58 f2       	cp.w	r2,15
8000793c:	e0 8b 00 05 	brhi	80007946 <_malloc_r+0x3ae>
80007940:	30 18       	mov	r8,1
80007942:	8d 18       	st.w	r6[0x4],r8
80007944:	c2 68       	rjmp	80007990 <_malloc_r+0x3f8>
80007946:	30 59       	mov	r9,5
80007948:	20 c2       	sub	r2,12
8000794a:	e0 12 ff f8 	andl	r2,0xfff8
8000794e:	e6 02 00 08 	add	r8,r3,r2
80007952:	91 29       	st.w	r8[0x8],r9
80007954:	91 19       	st.w	r8[0x4],r9
80007956:	66 18       	ld.w	r8,r3[0x4]
80007958:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000795c:	e5 e8 10 08 	or	r8,r2,r8
80007960:	87 18       	st.w	r3[0x4],r8
80007962:	58 f2       	cp.w	r2,15
80007964:	e0 88 00 07 	brls	80007972 <_malloc_r+0x3da>
80007968:	e6 cb ff f8 	sub	r11,r3,-8
8000796c:	0a 9c       	mov	r12,r5
8000796e:	e0 a0 1c 7d 	rcall	8000b268 <_free_r>
80007972:	e0 69 0d b8 	mov	r9,3512
80007976:	72 0a       	ld.w	r10,r9[0x0]
80007978:	e0 68 0d c0 	mov	r8,3520
8000797c:	70 08       	ld.w	r8,r8[0x0]
8000797e:	14 38       	cp.w	r8,r10
80007980:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007984:	e0 69 0d b4 	mov	r9,3508
80007988:	72 0a       	ld.w	r10,r9[0x0]
8000798a:	14 38       	cp.w	r8,r10
8000798c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007990:	68 28       	ld.w	r8,r4[0x8]
80007992:	70 18       	ld.w	r8,r8[0x4]
80007994:	e0 18 ff fc 	andl	r8,0xfffc
80007998:	0e 38       	cp.w	r8,r7
8000799a:	5f 39       	srlo	r9
8000799c:	0e 18       	sub	r8,r7
8000799e:	58 f8       	cp.w	r8,15
800079a0:	5f aa       	srle	r10
800079a2:	f5 e9 10 09 	or	r9,r10,r9
800079a6:	c0 50       	breq	800079b0 <_malloc_r+0x418>
800079a8:	0a 9c       	mov	r12,r5
800079aa:	fe b0 f3 e1 	rcall	8000616c <__malloc_unlock>
800079ae:	d8 3a       	popm	r0-r7,pc,r12=0
800079b0:	68 26       	ld.w	r6,r4[0x8]
800079b2:	a1 a8       	sbr	r8,0x0
800079b4:	0e 99       	mov	r9,r7
800079b6:	a1 a9       	sbr	r9,0x0
800079b8:	8d 19       	st.w	r6[0x4],r9
800079ba:	ec 07 00 07 	add	r7,r6,r7
800079be:	0a 9c       	mov	r12,r5
800079c0:	89 27       	st.w	r4[0x8],r7
800079c2:	8f 18       	st.w	r7[0x4],r8
800079c4:	fe b0 f3 d4 	rcall	8000616c <__malloc_unlock>
800079c8:	ec cc ff f8 	sub	r12,r6,-8
800079cc:	d8 32       	popm	r0-r7,pc
800079ce:	d7 03       	nop

800079d0 <memcmp>:
800079d0:	d4 01       	pushm	lr
800079d2:	30 08       	mov	r8,0
800079d4:	c0 d8       	rjmp	800079ee <memcmp+0x1e>
800079d6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800079da:	f6 08 07 09 	ld.ub	r9,r11[r8]
800079de:	20 1a       	sub	r10,1
800079e0:	2f f8       	sub	r8,-1
800079e2:	f2 0e 18 00 	cp.b	lr,r9
800079e6:	c0 40       	breq	800079ee <memcmp+0x1e>
800079e8:	fc 09 01 0c 	sub	r12,lr,r9
800079ec:	d8 02       	popm	pc
800079ee:	58 0a       	cp.w	r10,0
800079f0:	cf 31       	brne	800079d6 <memcmp+0x6>
800079f2:	14 9c       	mov	r12,r10
800079f4:	d8 02       	popm	pc

800079f6 <memcpy>:
800079f6:	58 8a       	cp.w	r10,8
800079f8:	c2 f5       	brlt	80007a56 <memcpy+0x60>
800079fa:	f9 eb 10 09 	or	r9,r12,r11
800079fe:	e2 19 00 03 	andl	r9,0x3,COH
80007a02:	e0 81 00 97 	brne	80007b30 <memcpy+0x13a>
80007a06:	e0 4a 00 20 	cp.w	r10,32
80007a0a:	c3 b4       	brge	80007a80 <memcpy+0x8a>
80007a0c:	f4 08 14 02 	asr	r8,r10,0x2
80007a10:	f0 09 11 08 	rsub	r9,r8,8
80007a14:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007a18:	76 69       	ld.w	r9,r11[0x18]
80007a1a:	99 69       	st.w	r12[0x18],r9
80007a1c:	76 59       	ld.w	r9,r11[0x14]
80007a1e:	99 59       	st.w	r12[0x14],r9
80007a20:	76 49       	ld.w	r9,r11[0x10]
80007a22:	99 49       	st.w	r12[0x10],r9
80007a24:	76 39       	ld.w	r9,r11[0xc]
80007a26:	99 39       	st.w	r12[0xc],r9
80007a28:	76 29       	ld.w	r9,r11[0x8]
80007a2a:	99 29       	st.w	r12[0x8],r9
80007a2c:	76 19       	ld.w	r9,r11[0x4]
80007a2e:	99 19       	st.w	r12[0x4],r9
80007a30:	76 09       	ld.w	r9,r11[0x0]
80007a32:	99 09       	st.w	r12[0x0],r9
80007a34:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007a38:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007a3c:	e0 1a 00 03 	andl	r10,0x3
80007a40:	f4 0a 11 04 	rsub	r10,r10,4
80007a44:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007a48:	17 a9       	ld.ub	r9,r11[0x2]
80007a4a:	b0 a9       	st.b	r8[0x2],r9
80007a4c:	17 99       	ld.ub	r9,r11[0x1]
80007a4e:	b0 99       	st.b	r8[0x1],r9
80007a50:	17 89       	ld.ub	r9,r11[0x0]
80007a52:	b0 89       	st.b	r8[0x0],r9
80007a54:	5e fc       	retal	r12
80007a56:	f4 0a 11 09 	rsub	r10,r10,9
80007a5a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007a5e:	17 f9       	ld.ub	r9,r11[0x7]
80007a60:	b8 f9       	st.b	r12[0x7],r9
80007a62:	17 e9       	ld.ub	r9,r11[0x6]
80007a64:	b8 e9       	st.b	r12[0x6],r9
80007a66:	17 d9       	ld.ub	r9,r11[0x5]
80007a68:	b8 d9       	st.b	r12[0x5],r9
80007a6a:	17 c9       	ld.ub	r9,r11[0x4]
80007a6c:	b8 c9       	st.b	r12[0x4],r9
80007a6e:	17 b9       	ld.ub	r9,r11[0x3]
80007a70:	b8 b9       	st.b	r12[0x3],r9
80007a72:	17 a9       	ld.ub	r9,r11[0x2]
80007a74:	b8 a9       	st.b	r12[0x2],r9
80007a76:	17 99       	ld.ub	r9,r11[0x1]
80007a78:	b8 99       	st.b	r12[0x1],r9
80007a7a:	17 89       	ld.ub	r9,r11[0x0]
80007a7c:	b8 89       	st.b	r12[0x0],r9
80007a7e:	5e fc       	retal	r12
80007a80:	eb cd 40 c0 	pushm	r6-r7,lr
80007a84:	18 99       	mov	r9,r12
80007a86:	22 0a       	sub	r10,32
80007a88:	b7 07       	ld.d	r6,r11++
80007a8a:	b3 26       	st.d	r9++,r6
80007a8c:	b7 07       	ld.d	r6,r11++
80007a8e:	b3 26       	st.d	r9++,r6
80007a90:	b7 07       	ld.d	r6,r11++
80007a92:	b3 26       	st.d	r9++,r6
80007a94:	b7 07       	ld.d	r6,r11++
80007a96:	b3 26       	st.d	r9++,r6
80007a98:	22 0a       	sub	r10,32
80007a9a:	cf 74       	brge	80007a88 <memcpy+0x92>
80007a9c:	2f 0a       	sub	r10,-16
80007a9e:	c0 65       	brlt	80007aaa <memcpy+0xb4>
80007aa0:	b7 07       	ld.d	r6,r11++
80007aa2:	b3 26       	st.d	r9++,r6
80007aa4:	b7 07       	ld.d	r6,r11++
80007aa6:	b3 26       	st.d	r9++,r6
80007aa8:	21 0a       	sub	r10,16
80007aaa:	5c 3a       	neg	r10
80007aac:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007ab0:	d7 03       	nop
80007ab2:	d7 03       	nop
80007ab4:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007ab8:	f3 66 00 0e 	st.b	r9[14],r6
80007abc:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007ac0:	f3 66 00 0d 	st.b	r9[13],r6
80007ac4:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007ac8:	f3 66 00 0c 	st.b	r9[12],r6
80007acc:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007ad0:	f3 66 00 0b 	st.b	r9[11],r6
80007ad4:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007ad8:	f3 66 00 0a 	st.b	r9[10],r6
80007adc:	f7 36 00 09 	ld.ub	r6,r11[9]
80007ae0:	f3 66 00 09 	st.b	r9[9],r6
80007ae4:	f7 36 00 08 	ld.ub	r6,r11[8]
80007ae8:	f3 66 00 08 	st.b	r9[8],r6
80007aec:	f7 36 00 07 	ld.ub	r6,r11[7]
80007af0:	f3 66 00 07 	st.b	r9[7],r6
80007af4:	f7 36 00 06 	ld.ub	r6,r11[6]
80007af8:	f3 66 00 06 	st.b	r9[6],r6
80007afc:	f7 36 00 05 	ld.ub	r6,r11[5]
80007b00:	f3 66 00 05 	st.b	r9[5],r6
80007b04:	f7 36 00 04 	ld.ub	r6,r11[4]
80007b08:	f3 66 00 04 	st.b	r9[4],r6
80007b0c:	f7 36 00 03 	ld.ub	r6,r11[3]
80007b10:	f3 66 00 03 	st.b	r9[3],r6
80007b14:	f7 36 00 02 	ld.ub	r6,r11[2]
80007b18:	f3 66 00 02 	st.b	r9[2],r6
80007b1c:	f7 36 00 01 	ld.ub	r6,r11[1]
80007b20:	f3 66 00 01 	st.b	r9[1],r6
80007b24:	f7 36 00 00 	ld.ub	r6,r11[0]
80007b28:	f3 66 00 00 	st.b	r9[0],r6
80007b2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b30:	20 1a       	sub	r10,1
80007b32:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007b36:	f8 0a 0b 09 	st.b	r12[r10],r9
80007b3a:	cf b1       	brne	80007b30 <memcpy+0x13a>
80007b3c:	5e fc       	retal	r12

80007b3e <memset>:
80007b3e:	18 98       	mov	r8,r12
80007b40:	c0 38       	rjmp	80007b46 <memset+0x8>
80007b42:	10 cb       	st.b	r8++,r11
80007b44:	20 1a       	sub	r10,1
80007b46:	58 0a       	cp.w	r10,0
80007b48:	cf d1       	brne	80007b42 <memset+0x4>
80007b4a:	5e fc       	retal	r12

80007b4c <_realloc_r>:
80007b4c:	d4 31       	pushm	r0-r7,lr
80007b4e:	20 1d       	sub	sp,4
80007b50:	16 94       	mov	r4,r11
80007b52:	18 92       	mov	r2,r12
80007b54:	14 9b       	mov	r11,r10
80007b56:	58 04       	cp.w	r4,0
80007b58:	c0 51       	brne	80007b62 <_realloc_r+0x16>
80007b5a:	fe b0 fd 1f 	rcall	80007598 <_malloc_r>
80007b5e:	18 95       	mov	r5,r12
80007b60:	c5 39       	rjmp	80007e06 <_realloc_r+0x2ba>
80007b62:	50 0a       	stdsp	sp[0x0],r10
80007b64:	fe b0 f2 fe 	rcall	80006160 <__malloc_lock>
80007b68:	40 0b       	lddsp	r11,sp[0x0]
80007b6a:	f6 c8 ff f5 	sub	r8,r11,-11
80007b6e:	e8 c1 00 08 	sub	r1,r4,8
80007b72:	10 96       	mov	r6,r8
80007b74:	62 1c       	ld.w	r12,r1[0x4]
80007b76:	e0 16 ff f8 	andl	r6,0xfff8
80007b7a:	59 68       	cp.w	r8,22
80007b7c:	f9 b6 08 10 	movls	r6,16
80007b80:	16 36       	cp.w	r6,r11
80007b82:	5f 38       	srlo	r8
80007b84:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007b88:	c0 50       	breq	80007b92 <_realloc_r+0x46>
80007b8a:	30 c8       	mov	r8,12
80007b8c:	30 05       	mov	r5,0
80007b8e:	85 38       	st.w	r2[0xc],r8
80007b90:	c3 b9       	rjmp	80007e06 <_realloc_r+0x2ba>
80007b92:	18 90       	mov	r0,r12
80007b94:	e0 10 ff fc 	andl	r0,0xfffc
80007b98:	0c 30       	cp.w	r0,r6
80007b9a:	e0 84 01 0b 	brge	80007db0 <_realloc_r+0x264>
80007b9e:	e0 68 05 48 	mov	r8,1352
80007ba2:	e2 00 00 09 	add	r9,r1,r0
80007ba6:	70 25       	ld.w	r5,r8[0x8]
80007ba8:	0a 39       	cp.w	r9,r5
80007baa:	c0 90       	breq	80007bbc <_realloc_r+0x70>
80007bac:	72 1a       	ld.w	r10,r9[0x4]
80007bae:	a1 ca       	cbr	r10,0x0
80007bb0:	f2 0a 00 0a 	add	r10,r9,r10
80007bb4:	74 1a       	ld.w	r10,r10[0x4]
80007bb6:	ed ba 00 00 	bld	r10,0x0
80007bba:	c2 20       	breq	80007bfe <_realloc_r+0xb2>
80007bbc:	72 1a       	ld.w	r10,r9[0x4]
80007bbe:	e0 1a ff fc 	andl	r10,0xfffc
80007bc2:	f4 00 00 03 	add	r3,r10,r0
80007bc6:	0a 39       	cp.w	r9,r5
80007bc8:	c1 31       	brne	80007bee <_realloc_r+0xa2>
80007bca:	ec c7 ff f0 	sub	r7,r6,-16
80007bce:	0e 33       	cp.w	r3,r7
80007bd0:	c1 95       	brlt	80007c02 <_realloc_r+0xb6>
80007bd2:	e2 06 00 09 	add	r9,r1,r6
80007bd6:	0c 13       	sub	r3,r6
80007bd8:	a1 a3       	sbr	r3,0x0
80007bda:	93 13       	st.w	r9[0x4],r3
80007bdc:	91 29       	st.w	r8[0x8],r9
80007bde:	04 9c       	mov	r12,r2
80007be0:	62 18       	ld.w	r8,r1[0x4]
80007be2:	08 95       	mov	r5,r4
80007be4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007be8:	10 46       	or	r6,r8
80007bea:	83 16       	st.w	r1[0x4],r6
80007bec:	c0 b9       	rjmp	80007e02 <_realloc_r+0x2b6>
80007bee:	0c 33       	cp.w	r3,r6
80007bf0:	c0 95       	brlt	80007c02 <_realloc_r+0xb6>
80007bf2:	72 28       	ld.w	r8,r9[0x8]
80007bf4:	02 97       	mov	r7,r1
80007bf6:	72 39       	ld.w	r9,r9[0xc]
80007bf8:	93 28       	st.w	r9[0x8],r8
80007bfa:	91 39       	st.w	r8[0xc],r9
80007bfc:	cd c8       	rjmp	80007db4 <_realloc_r+0x268>
80007bfe:	30 0a       	mov	r10,0
80007c00:	14 99       	mov	r9,r10
80007c02:	ed bc 00 00 	bld	r12,0x0
80007c06:	e0 80 00 95 	breq	80007d30 <_realloc_r+0x1e4>
80007c0a:	62 07       	ld.w	r7,r1[0x0]
80007c0c:	e2 07 01 07 	sub	r7,r1,r7
80007c10:	6e 1c       	ld.w	r12,r7[0x4]
80007c12:	e0 1c ff fc 	andl	r12,0xfffc
80007c16:	58 09       	cp.w	r9,0
80007c18:	c5 60       	breq	80007cc4 <_realloc_r+0x178>
80007c1a:	f8 00 00 03 	add	r3,r12,r0
80007c1e:	0a 39       	cp.w	r9,r5
80007c20:	c4 81       	brne	80007cb0 <_realloc_r+0x164>
80007c22:	14 03       	add	r3,r10
80007c24:	ec c9 ff f0 	sub	r9,r6,-16
80007c28:	12 33       	cp.w	r3,r9
80007c2a:	c4 d5       	brlt	80007cc4 <_realloc_r+0x178>
80007c2c:	6e 3a       	ld.w	r10,r7[0xc]
80007c2e:	6e 29       	ld.w	r9,r7[0x8]
80007c30:	95 29       	st.w	r10[0x8],r9
80007c32:	93 3a       	st.w	r9[0xc],r10
80007c34:	ee c5 ff f8 	sub	r5,r7,-8
80007c38:	e0 ca 00 04 	sub	r10,r0,4
80007c3c:	e0 4a 00 24 	cp.w	r10,36
80007c40:	e0 8b 00 25 	brhi	80007c8a <_realloc_r+0x13e>
80007c44:	0a 99       	mov	r9,r5
80007c46:	59 3a       	cp.w	r10,19
80007c48:	e0 88 00 1a 	brls	80007c7c <_realloc_r+0x130>
80007c4c:	09 09       	ld.w	r9,r4++
80007c4e:	8b 09       	st.w	r5[0x0],r9
80007c50:	09 09       	ld.w	r9,r4++
80007c52:	8f 39       	st.w	r7[0xc],r9
80007c54:	ee c9 ff f0 	sub	r9,r7,-16
80007c58:	59 ba       	cp.w	r10,27
80007c5a:	e0 88 00 11 	brls	80007c7c <_realloc_r+0x130>
80007c5e:	09 0b       	ld.w	r11,r4++
80007c60:	93 0b       	st.w	r9[0x0],r11
80007c62:	09 09       	ld.w	r9,r4++
80007c64:	8f 59       	st.w	r7[0x14],r9
80007c66:	ee c9 ff e8 	sub	r9,r7,-24
80007c6a:	e0 4a 00 24 	cp.w	r10,36
80007c6e:	c0 71       	brne	80007c7c <_realloc_r+0x130>
80007c70:	09 0a       	ld.w	r10,r4++
80007c72:	93 0a       	st.w	r9[0x0],r10
80007c74:	ee c9 ff e0 	sub	r9,r7,-32
80007c78:	09 0a       	ld.w	r10,r4++
80007c7a:	8f 7a       	st.w	r7[0x1c],r10
80007c7c:	09 0a       	ld.w	r10,r4++
80007c7e:	12 aa       	st.w	r9++,r10
80007c80:	68 0a       	ld.w	r10,r4[0x0]
80007c82:	93 0a       	st.w	r9[0x0],r10
80007c84:	68 1a       	ld.w	r10,r4[0x4]
80007c86:	93 1a       	st.w	r9[0x4],r10
80007c88:	c0 78       	rjmp	80007c96 <_realloc_r+0x14a>
80007c8a:	50 08       	stdsp	sp[0x0],r8
80007c8c:	08 9b       	mov	r11,r4
80007c8e:	0a 9c       	mov	r12,r5
80007c90:	e0 a0 1d 8f 	rcall	8000b7ae <memmove>
80007c94:	40 08       	lddsp	r8,sp[0x0]
80007c96:	ee 06 00 09 	add	r9,r7,r6
80007c9a:	0c 13       	sub	r3,r6
80007c9c:	a1 a3       	sbr	r3,0x0
80007c9e:	93 13       	st.w	r9[0x4],r3
80007ca0:	91 29       	st.w	r8[0x8],r9
80007ca2:	04 9c       	mov	r12,r2
80007ca4:	6e 18       	ld.w	r8,r7[0x4]
80007ca6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007caa:	10 46       	or	r6,r8
80007cac:	8f 16       	st.w	r7[0x4],r6
80007cae:	ca a8       	rjmp	80007e02 <_realloc_r+0x2b6>
80007cb0:	14 03       	add	r3,r10
80007cb2:	0c 33       	cp.w	r3,r6
80007cb4:	c0 85       	brlt	80007cc4 <_realloc_r+0x178>
80007cb6:	72 28       	ld.w	r8,r9[0x8]
80007cb8:	72 39       	ld.w	r9,r9[0xc]
80007cba:	93 28       	st.w	r9[0x8],r8
80007cbc:	91 39       	st.w	r8[0xc],r9
80007cbe:	6e 28       	ld.w	r8,r7[0x8]
80007cc0:	6e 39       	ld.w	r9,r7[0xc]
80007cc2:	c0 78       	rjmp	80007cd0 <_realloc_r+0x184>
80007cc4:	f8 00 00 03 	add	r3,r12,r0
80007cc8:	0c 33       	cp.w	r3,r6
80007cca:	c3 35       	brlt	80007d30 <_realloc_r+0x1e4>
80007ccc:	6e 39       	ld.w	r9,r7[0xc]
80007cce:	6e 28       	ld.w	r8,r7[0x8]
80007cd0:	93 28       	st.w	r9[0x8],r8
80007cd2:	91 39       	st.w	r8[0xc],r9
80007cd4:	e0 ca 00 04 	sub	r10,r0,4
80007cd8:	ee cc ff f8 	sub	r12,r7,-8
80007cdc:	e0 4a 00 24 	cp.w	r10,36
80007ce0:	e0 8b 00 24 	brhi	80007d28 <_realloc_r+0x1dc>
80007ce4:	59 3a       	cp.w	r10,19
80007ce6:	e0 88 00 1a 	brls	80007d1a <_realloc_r+0x1ce>
80007cea:	09 08       	ld.w	r8,r4++
80007cec:	99 08       	st.w	r12[0x0],r8
80007cee:	09 08       	ld.w	r8,r4++
80007cf0:	8f 38       	st.w	r7[0xc],r8
80007cf2:	ee cc ff f0 	sub	r12,r7,-16
80007cf6:	59 ba       	cp.w	r10,27
80007cf8:	e0 88 00 11 	brls	80007d1a <_realloc_r+0x1ce>
80007cfc:	09 08       	ld.w	r8,r4++
80007cfe:	99 08       	st.w	r12[0x0],r8
80007d00:	09 08       	ld.w	r8,r4++
80007d02:	8f 58       	st.w	r7[0x14],r8
80007d04:	ee cc ff e8 	sub	r12,r7,-24
80007d08:	e0 4a 00 24 	cp.w	r10,36
80007d0c:	c0 71       	brne	80007d1a <_realloc_r+0x1ce>
80007d0e:	09 08       	ld.w	r8,r4++
80007d10:	99 08       	st.w	r12[0x0],r8
80007d12:	ee cc ff e0 	sub	r12,r7,-32
80007d16:	09 08       	ld.w	r8,r4++
80007d18:	8f 78       	st.w	r7[0x1c],r8
80007d1a:	09 08       	ld.w	r8,r4++
80007d1c:	18 a8       	st.w	r12++,r8
80007d1e:	68 08       	ld.w	r8,r4[0x0]
80007d20:	99 08       	st.w	r12[0x0],r8
80007d22:	68 18       	ld.w	r8,r4[0x4]
80007d24:	99 18       	st.w	r12[0x4],r8
80007d26:	c4 78       	rjmp	80007db4 <_realloc_r+0x268>
80007d28:	08 9b       	mov	r11,r4
80007d2a:	e0 a0 1d 42 	rcall	8000b7ae <memmove>
80007d2e:	c4 38       	rjmp	80007db4 <_realloc_r+0x268>
80007d30:	04 9c       	mov	r12,r2
80007d32:	fe b0 fc 33 	rcall	80007598 <_malloc_r>
80007d36:	18 95       	mov	r5,r12
80007d38:	c3 a0       	breq	80007dac <_realloc_r+0x260>
80007d3a:	62 18       	ld.w	r8,r1[0x4]
80007d3c:	f8 c9 00 08 	sub	r9,r12,8
80007d40:	a1 c8       	cbr	r8,0x0
80007d42:	e2 08 00 08 	add	r8,r1,r8
80007d46:	10 39       	cp.w	r9,r8
80007d48:	c0 71       	brne	80007d56 <_realloc_r+0x20a>
80007d4a:	72 13       	ld.w	r3,r9[0x4]
80007d4c:	02 97       	mov	r7,r1
80007d4e:	e0 13 ff fc 	andl	r3,0xfffc
80007d52:	00 03       	add	r3,r0
80007d54:	c3 08       	rjmp	80007db4 <_realloc_r+0x268>
80007d56:	e0 ca 00 04 	sub	r10,r0,4
80007d5a:	e0 4a 00 24 	cp.w	r10,36
80007d5e:	e0 8b 00 20 	brhi	80007d9e <_realloc_r+0x252>
80007d62:	08 99       	mov	r9,r4
80007d64:	18 98       	mov	r8,r12
80007d66:	59 3a       	cp.w	r10,19
80007d68:	e0 88 00 14 	brls	80007d90 <_realloc_r+0x244>
80007d6c:	13 0b       	ld.w	r11,r9++
80007d6e:	10 ab       	st.w	r8++,r11
80007d70:	13 0b       	ld.w	r11,r9++
80007d72:	10 ab       	st.w	r8++,r11
80007d74:	59 ba       	cp.w	r10,27
80007d76:	e0 88 00 0d 	brls	80007d90 <_realloc_r+0x244>
80007d7a:	13 0b       	ld.w	r11,r9++
80007d7c:	10 ab       	st.w	r8++,r11
80007d7e:	13 0b       	ld.w	r11,r9++
80007d80:	10 ab       	st.w	r8++,r11
80007d82:	e0 4a 00 24 	cp.w	r10,36
80007d86:	c0 51       	brne	80007d90 <_realloc_r+0x244>
80007d88:	13 0a       	ld.w	r10,r9++
80007d8a:	10 aa       	st.w	r8++,r10
80007d8c:	13 0a       	ld.w	r10,r9++
80007d8e:	10 aa       	st.w	r8++,r10
80007d90:	13 0a       	ld.w	r10,r9++
80007d92:	10 aa       	st.w	r8++,r10
80007d94:	72 0a       	ld.w	r10,r9[0x0]
80007d96:	91 0a       	st.w	r8[0x0],r10
80007d98:	72 19       	ld.w	r9,r9[0x4]
80007d9a:	91 19       	st.w	r8[0x4],r9
80007d9c:	c0 48       	rjmp	80007da4 <_realloc_r+0x258>
80007d9e:	08 9b       	mov	r11,r4
80007da0:	e0 a0 1d 07 	rcall	8000b7ae <memmove>
80007da4:	08 9b       	mov	r11,r4
80007da6:	04 9c       	mov	r12,r2
80007da8:	e0 a0 1a 60 	rcall	8000b268 <_free_r>
80007dac:	04 9c       	mov	r12,r2
80007dae:	c2 a8       	rjmp	80007e02 <_realloc_r+0x2b6>
80007db0:	00 93       	mov	r3,r0
80007db2:	02 97       	mov	r7,r1
80007db4:	e6 06 01 09 	sub	r9,r3,r6
80007db8:	6e 18       	ld.w	r8,r7[0x4]
80007dba:	58 f9       	cp.w	r9,15
80007dbc:	e0 88 00 16 	brls	80007de8 <_realloc_r+0x29c>
80007dc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007dc4:	ed e8 10 08 	or	r8,r6,r8
80007dc8:	8f 18       	st.w	r7[0x4],r8
80007dca:	12 98       	mov	r8,r9
80007dcc:	a1 a8       	sbr	r8,0x0
80007dce:	ee 06 00 0b 	add	r11,r7,r6
80007dd2:	f6 09 00 09 	add	r9,r11,r9
80007dd6:	97 18       	st.w	r11[0x4],r8
80007dd8:	72 18       	ld.w	r8,r9[0x4]
80007dda:	a1 a8       	sbr	r8,0x0
80007ddc:	2f 8b       	sub	r11,-8
80007dde:	93 18       	st.w	r9[0x4],r8
80007de0:	04 9c       	mov	r12,r2
80007de2:	e0 a0 1a 43 	rcall	8000b268 <_free_r>
80007de6:	c0 b8       	rjmp	80007dfc <_realloc_r+0x2b0>
80007de8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007dec:	e7 e8 10 08 	or	r8,r3,r8
80007df0:	8f 18       	st.w	r7[0x4],r8
80007df2:	ee 03 00 03 	add	r3,r7,r3
80007df6:	66 18       	ld.w	r8,r3[0x4]
80007df8:	a1 a8       	sbr	r8,0x0
80007dfa:	87 18       	st.w	r3[0x4],r8
80007dfc:	04 9c       	mov	r12,r2
80007dfe:	ee c5 ff f8 	sub	r5,r7,-8
80007e02:	fe b0 f1 b5 	rcall	8000616c <__malloc_unlock>
80007e06:	0a 9c       	mov	r12,r5
80007e08:	2f fd       	sub	sp,-4
80007e0a:	d8 32       	popm	r0-r7,pc

80007e0c <_sbrk_r>:
80007e0c:	d4 21       	pushm	r4-r7,lr
80007e0e:	30 08       	mov	r8,0
80007e10:	18 97       	mov	r7,r12
80007e12:	e0 66 51 94 	mov	r6,20884
80007e16:	16 9c       	mov	r12,r11
80007e18:	8d 08       	st.w	r6[0x0],r8
80007e1a:	c8 5c       	rcall	80007f24 <_sbrk>
80007e1c:	5b fc       	cp.w	r12,-1
80007e1e:	c0 51       	brne	80007e28 <_sbrk_r+0x1c>
80007e20:	6c 08       	ld.w	r8,r6[0x0]
80007e22:	58 08       	cp.w	r8,0
80007e24:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007e28:	d8 22       	popm	r4-r7,pc
80007e2a:	d7 03       	nop

80007e2c <sprintf>:
80007e2c:	d4 01       	pushm	lr
80007e2e:	21 7d       	sub	sp,92
80007e30:	e0 68 ff ff 	mov	r8,65535
80007e34:	ea 18 7f ff 	orh	r8,0x7fff
80007e38:	50 58       	stdsp	sp[0x14],r8
80007e3a:	50 28       	stdsp	sp[0x8],r8
80007e3c:	e0 68 02 08 	mov	r8,520
80007e40:	ba 68       	st.h	sp[0xc],r8
80007e42:	3f f8       	mov	r8,-1
80007e44:	ba 78       	st.h	sp[0xe],r8
80007e46:	e0 68 0a 48 	mov	r8,2632
80007e4a:	50 4c       	stdsp	sp[0x10],r12
80007e4c:	16 9a       	mov	r10,r11
80007e4e:	50 0c       	stdsp	sp[0x0],r12
80007e50:	fa c9 ff a0 	sub	r9,sp,-96
80007e54:	70 0c       	ld.w	r12,r8[0x0]
80007e56:	1a 9b       	mov	r11,sp
80007e58:	e0 a0 02 1a 	rcall	8000828c <_vfprintf_r>
80007e5c:	30 09       	mov	r9,0
80007e5e:	40 08       	lddsp	r8,sp[0x0]
80007e60:	b0 89       	st.b	r8[0x0],r9
80007e62:	2e 9d       	sub	sp,-92
80007e64:	d8 02       	popm	pc
80007e66:	d7 03       	nop

80007e68 <strncpy>:
80007e68:	30 08       	mov	r8,0
80007e6a:	10 3a       	cp.w	r10,r8
80007e6c:	5e 0c       	reteq	r12
80007e6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007e72:	f8 08 0b 09 	st.b	r12[r8],r9
80007e76:	2f f8       	sub	r8,-1
80007e78:	58 09       	cp.w	r9,0
80007e7a:	cf 81       	brne	80007e6a <strncpy+0x2>
80007e7c:	10 3a       	cp.w	r10,r8
80007e7e:	5e 0c       	reteq	r12
80007e80:	f8 08 0b 09 	st.b	r12[r8],r9
80007e84:	2f f8       	sub	r8,-1
80007e86:	cf bb       	rjmp	80007e7c <strncpy+0x14>

80007e88 <_close>:
80007e88:	30 28       	mov	r8,2
80007e8a:	d6 73       	breakpoint
80007e8c:	3f fc       	mov	r12,-1
80007e8e:	35 8b       	mov	r11,88
80007e90:	58 0c       	cp.w	r12,0
80007e92:	5e 4c       	retge	r12
80007e94:	e0 6a 51 94 	mov	r10,20884
80007e98:	95 0b       	st.w	r10[0x0],r11
80007e9a:	5e fc       	retal	r12

80007e9c <_lseek>:
80007e9c:	30 58       	mov	r8,5
80007e9e:	d6 73       	breakpoint
80007ea0:	3f fc       	mov	r12,-1
80007ea2:	35 8b       	mov	r11,88
80007ea4:	58 0c       	cp.w	r12,0
80007ea6:	5e 4c       	retge	r12
80007ea8:	e0 6a 51 94 	mov	r10,20884
80007eac:	95 0b       	st.w	r10[0x0],r11
80007eae:	5e fc       	retal	r12

80007eb0 <isatty>:
80007eb0:	30 b8       	mov	r8,11
80007eb2:	d6 73       	breakpoint
80007eb4:	3f fc       	mov	r12,-1
80007eb6:	35 8b       	mov	r11,88
80007eb8:	58 0c       	cp.w	r12,0
80007eba:	5e 4c       	retge	r12
80007ebc:	e0 6a 51 94 	mov	r10,20884
80007ec0:	95 0b       	st.w	r10[0x0],r11
80007ec2:	5e fc       	retal	r12

80007ec4 <_fstat_host>:
80007ec4:	30 98       	mov	r8,9
80007ec6:	d6 73       	breakpoint
80007ec8:	3f fc       	mov	r12,-1
80007eca:	35 8b       	mov	r11,88
80007ecc:	58 0c       	cp.w	r12,0
80007ece:	5e 4c       	retge	r12
80007ed0:	e0 6a 51 94 	mov	r10,20884
80007ed4:	95 0b       	st.w	r10[0x0],r11
80007ed6:	5e fc       	retal	r12

80007ed8 <_fstat>:
80007ed8:	d4 21       	pushm	r4-r7,lr
80007eda:	21 0d       	sub	sp,64
80007edc:	16 97       	mov	r7,r11
80007ede:	1a 9b       	mov	r11,sp
80007ee0:	cf 2f       	rcall	80007ec4 <_fstat_host>
80007ee2:	c0 34       	brge	80007ee8 <_fstat+0x10>
80007ee4:	3f fc       	mov	r12,-1
80007ee6:	c1 c8       	rjmp	80007f1e <_fstat+0x46>
80007ee8:	40 08       	lddsp	r8,sp[0x0]
80007eea:	ae 08       	st.h	r7[0x0],r8
80007eec:	40 18       	lddsp	r8,sp[0x4]
80007eee:	ae 18       	st.h	r7[0x2],r8
80007ef0:	40 28       	lddsp	r8,sp[0x8]
80007ef2:	8f 18       	st.w	r7[0x4],r8
80007ef4:	40 38       	lddsp	r8,sp[0xc]
80007ef6:	ae 48       	st.h	r7[0x8],r8
80007ef8:	40 48       	lddsp	r8,sp[0x10]
80007efa:	ae 58       	st.h	r7[0xa],r8
80007efc:	40 58       	lddsp	r8,sp[0x14]
80007efe:	ae 68       	st.h	r7[0xc],r8
80007f00:	40 68       	lddsp	r8,sp[0x18]
80007f02:	ae 78       	st.h	r7[0xe],r8
80007f04:	40 88       	lddsp	r8,sp[0x20]
80007f06:	8f 48       	st.w	r7[0x10],r8
80007f08:	40 a8       	lddsp	r8,sp[0x28]
80007f0a:	8f b8       	st.w	r7[0x2c],r8
80007f0c:	40 c8       	lddsp	r8,sp[0x30]
80007f0e:	8f c8       	st.w	r7[0x30],r8
80007f10:	40 d8       	lddsp	r8,sp[0x34]
80007f12:	8f 58       	st.w	r7[0x14],r8
80007f14:	40 e8       	lddsp	r8,sp[0x38]
80007f16:	30 0c       	mov	r12,0
80007f18:	8f 78       	st.w	r7[0x1c],r8
80007f1a:	40 f8       	lddsp	r8,sp[0x3c]
80007f1c:	8f 98       	st.w	r7[0x24],r8
80007f1e:	2f 0d       	sub	sp,-64
80007f20:	d8 22       	popm	r4-r7,pc
80007f22:	d7 03       	nop

80007f24 <_sbrk>:
80007f24:	d4 01       	pushm	lr
80007f26:	e0 68 0d e8 	mov	r8,3560
80007f2a:	70 09       	ld.w	r9,r8[0x0]
80007f2c:	58 09       	cp.w	r9,0
80007f2e:	c0 41       	brne	80007f36 <_sbrk+0x12>
80007f30:	e0 69 51 98 	mov	r9,20888
80007f34:	91 09       	st.w	r8[0x0],r9
80007f36:	e0 69 0d e8 	mov	r9,3560
80007f3a:	e0 7a 70 00 	mov	r10,94208
80007f3e:	72 08       	ld.w	r8,r9[0x0]
80007f40:	f0 0c 00 0c 	add	r12,r8,r12
80007f44:	14 3c       	cp.w	r12,r10
80007f46:	e0 8b 00 04 	brhi	80007f4e <_sbrk+0x2a>
80007f4a:	93 0c       	st.w	r9[0x0],r12
80007f4c:	c0 68       	rjmp	80007f58 <_sbrk+0x34>
80007f4e:	e0 a0 18 15 	rcall	8000af78 <__errno>
80007f52:	30 c8       	mov	r8,12
80007f54:	99 08       	st.w	r12[0x0],r8
80007f56:	3f f8       	mov	r8,-1
80007f58:	10 9c       	mov	r12,r8
80007f5a:	d8 02       	popm	pc

80007f5c <get_arg>:
80007f5c:	d4 31       	pushm	r0-r7,lr
80007f5e:	20 8d       	sub	sp,32
80007f60:	fa c4 ff bc 	sub	r4,sp,-68
80007f64:	50 4b       	stdsp	sp[0x10],r11
80007f66:	68 2e       	ld.w	lr,r4[0x8]
80007f68:	50 58       	stdsp	sp[0x14],r8
80007f6a:	12 96       	mov	r6,r9
80007f6c:	7c 0b       	ld.w	r11,lr[0x0]
80007f6e:	70 05       	ld.w	r5,r8[0x0]
80007f70:	50 6e       	stdsp	sp[0x18],lr
80007f72:	58 0b       	cp.w	r11,0
80007f74:	f4 0b 17 00 	moveq	r11,r10
80007f78:	68 03       	ld.w	r3,r4[0x0]
80007f7a:	68 11       	ld.w	r1,r4[0x4]
80007f7c:	40 49       	lddsp	r9,sp[0x10]
80007f7e:	30 08       	mov	r8,0
80007f80:	c2 89       	rjmp	800081d0 <get_arg+0x274>
80007f82:	2f fb       	sub	r11,-1
80007f84:	32 5c       	mov	r12,37
80007f86:	17 8a       	ld.ub	r10,r11[0x0]
80007f88:	f8 0a 18 00 	cp.b	r10,r12
80007f8c:	5f 1e       	srne	lr
80007f8e:	f0 0a 18 00 	cp.b	r10,r8
80007f92:	5f 1c       	srne	r12
80007f94:	fd ec 00 0c 	and	r12,lr,r12
80007f98:	f0 0c 18 00 	cp.b	r12,r8
80007f9c:	cf 31       	brne	80007f82 <get_arg+0x26>
80007f9e:	58 0a       	cp.w	r10,0
80007fa0:	e0 80 01 25 	breq	800081ea <get_arg+0x28e>
80007fa4:	30 0c       	mov	r12,0
80007fa6:	3f fa       	mov	r10,-1
80007fa8:	18 90       	mov	r0,r12
80007faa:	50 3a       	stdsp	sp[0xc],r10
80007fac:	18 94       	mov	r4,r12
80007fae:	18 92       	mov	r2,r12
80007fb0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007fb4:	16 97       	mov	r7,r11
80007fb6:	50 7c       	stdsp	sp[0x1c],r12
80007fb8:	fe cc 9e 38 	sub	r12,pc,-25032
80007fbc:	0f 3a       	ld.ub	r10,r7++
80007fbe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007fc2:	40 7c       	lddsp	r12,sp[0x1c]
80007fc4:	1c 0c       	add	r12,lr
80007fc6:	fe ce 9f 0e 	sub	lr,pc,-24818
80007fca:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007fce:	20 1e       	sub	lr,1
80007fd0:	50 0e       	stdsp	sp[0x0],lr
80007fd2:	fe ce 9f 86 	sub	lr,pc,-24698
80007fd6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007fda:	50 7c       	stdsp	sp[0x1c],r12
80007fdc:	40 0c       	lddsp	r12,sp[0x0]
80007fde:	58 7c       	cp.w	r12,7
80007fe0:	e0 8b 00 f1 	brhi	800081c2 <get_arg+0x266>
80007fe4:	fe ce a1 38 	sub	lr,pc,-24264
80007fe8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007fec:	36 8b       	mov	r11,104
80007fee:	f6 0a 18 00 	cp.b	r10,r11
80007ff2:	e0 80 00 e8 	breq	800081c2 <get_arg+0x266>
80007ff6:	37 1b       	mov	r11,113
80007ff8:	f6 0a 18 00 	cp.b	r10,r11
80007ffc:	c0 70       	breq	8000800a <get_arg+0xae>
80007ffe:	34 cb       	mov	r11,76
80008000:	f6 0a 18 00 	cp.b	r10,r11
80008004:	c0 51       	brne	8000800e <get_arg+0xb2>
80008006:	a3 b4       	sbr	r4,0x3
80008008:	cd d8       	rjmp	800081c2 <get_arg+0x266>
8000800a:	a5 b4       	sbr	r4,0x5
8000800c:	cd b8       	rjmp	800081c2 <get_arg+0x266>
8000800e:	08 9a       	mov	r10,r4
80008010:	0e 9b       	mov	r11,r7
80008012:	a5 aa       	sbr	r10,0x4
80008014:	17 3c       	ld.ub	r12,r11++
80008016:	a5 b4       	sbr	r4,0x5
80008018:	36 ce       	mov	lr,108
8000801a:	fc 0c 18 00 	cp.b	r12,lr
8000801e:	e0 80 00 d3 	breq	800081c4 <get_arg+0x268>
80008022:	14 94       	mov	r4,r10
80008024:	cc f8       	rjmp	800081c2 <get_arg+0x266>
80008026:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000802a:	36 7c       	mov	r12,103
8000802c:	f8 0a 18 00 	cp.b	r10,r12
80008030:	e0 8b 00 27 	brhi	8000807e <get_arg+0x122>
80008034:	36 5b       	mov	r11,101
80008036:	f6 0a 18 00 	cp.b	r10,r11
8000803a:	c4 82       	brcc	800080ca <get_arg+0x16e>
8000803c:	34 fb       	mov	r11,79
8000803e:	f6 0a 18 00 	cp.b	r10,r11
80008042:	c4 80       	breq	800080d2 <get_arg+0x176>
80008044:	e0 8b 00 0c 	brhi	8000805c <get_arg+0x100>
80008048:	34 5b       	mov	r11,69
8000804a:	f6 0a 18 00 	cp.b	r10,r11
8000804e:	c3 e0       	breq	800080ca <get_arg+0x16e>
80008050:	34 7b       	mov	r11,71
80008052:	f6 0a 18 00 	cp.b	r10,r11
80008056:	c3 a0       	breq	800080ca <get_arg+0x16e>
80008058:	34 4b       	mov	r11,68
8000805a:	c0 88       	rjmp	8000806a <get_arg+0x10e>
8000805c:	35 8b       	mov	r11,88
8000805e:	f6 0a 18 00 	cp.b	r10,r11
80008062:	c2 c0       	breq	800080ba <get_arg+0x15e>
80008064:	e0 8b 00 07 	brhi	80008072 <get_arg+0x116>
80008068:	35 5b       	mov	r11,85
8000806a:	f6 0a 18 00 	cp.b	r10,r11
8000806e:	c3 51       	brne	800080d8 <get_arg+0x17c>
80008070:	c3 18       	rjmp	800080d2 <get_arg+0x176>
80008072:	36 3b       	mov	r11,99
80008074:	f6 0a 18 00 	cp.b	r10,r11
80008078:	c2 f0       	breq	800080d6 <get_arg+0x17a>
8000807a:	36 4b       	mov	r11,100
8000807c:	c0 e8       	rjmp	80008098 <get_arg+0x13c>
8000807e:	37 0b       	mov	r11,112
80008080:	f6 0a 18 00 	cp.b	r10,r11
80008084:	c2 50       	breq	800080ce <get_arg+0x172>
80008086:	e0 8b 00 0d 	brhi	800080a0 <get_arg+0x144>
8000808a:	36 eb       	mov	r11,110
8000808c:	f6 0a 18 00 	cp.b	r10,r11
80008090:	c1 f0       	breq	800080ce <get_arg+0x172>
80008092:	e0 8b 00 14 	brhi	800080ba <get_arg+0x15e>
80008096:	36 9b       	mov	r11,105
80008098:	f6 0a 18 00 	cp.b	r10,r11
8000809c:	c1 e1       	brne	800080d8 <get_arg+0x17c>
8000809e:	c0 e8       	rjmp	800080ba <get_arg+0x15e>
800080a0:	37 5b       	mov	r11,117
800080a2:	f6 0a 18 00 	cp.b	r10,r11
800080a6:	c0 a0       	breq	800080ba <get_arg+0x15e>
800080a8:	37 8b       	mov	r11,120
800080aa:	f6 0a 18 00 	cp.b	r10,r11
800080ae:	c0 60       	breq	800080ba <get_arg+0x15e>
800080b0:	37 3b       	mov	r11,115
800080b2:	f6 0a 18 00 	cp.b	r10,r11
800080b6:	c1 11       	brne	800080d8 <get_arg+0x17c>
800080b8:	c0 b8       	rjmp	800080ce <get_arg+0x172>
800080ba:	ed b4 00 04 	bld	r4,0x4
800080be:	c0 a0       	breq	800080d2 <get_arg+0x176>
800080c0:	ed b4 00 05 	bld	r4,0x5
800080c4:	c0 91       	brne	800080d6 <get_arg+0x17a>
800080c6:	30 20       	mov	r0,2
800080c8:	c0 88       	rjmp	800080d8 <get_arg+0x17c>
800080ca:	30 40       	mov	r0,4
800080cc:	c0 68       	rjmp	800080d8 <get_arg+0x17c>
800080ce:	30 30       	mov	r0,3
800080d0:	c0 48       	rjmp	800080d8 <get_arg+0x17c>
800080d2:	30 10       	mov	r0,1
800080d4:	c0 28       	rjmp	800080d8 <get_arg+0x17c>
800080d6:	30 00       	mov	r0,0
800080d8:	40 3b       	lddsp	r11,sp[0xc]
800080da:	5b fb       	cp.w	r11,-1
800080dc:	c0 40       	breq	800080e4 <get_arg+0x188>
800080de:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800080e2:	c7 08       	rjmp	800081c2 <get_arg+0x266>
800080e4:	58 60       	cp.w	r0,6
800080e6:	e0 8b 00 6e 	brhi	800081c2 <get_arg+0x266>
800080ea:	6c 0a       	ld.w	r10,r6[0x0]
800080ec:	ea cc ff ff 	sub	r12,r5,-1
800080f0:	fe ce a2 24 	sub	lr,pc,-24028
800080f4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800080f8:	f4 cb ff f8 	sub	r11,r10,-8
800080fc:	8d 0b       	st.w	r6[0x0],r11
800080fe:	f4 ea 00 00 	ld.d	r10,r10[0]
80008102:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008106:	c0 f8       	rjmp	80008124 <get_arg+0x1c8>
80008108:	f4 cb ff fc 	sub	r11,r10,-4
8000810c:	8d 0b       	st.w	r6[0x0],r11
8000810e:	74 0a       	ld.w	r10,r10[0x0]
80008110:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008114:	c0 88       	rjmp	80008124 <get_arg+0x1c8>
80008116:	f4 cb ff f8 	sub	r11,r10,-8
8000811a:	8d 0b       	st.w	r6[0x0],r11
8000811c:	f4 ea 00 00 	ld.d	r10,r10[0]
80008120:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008124:	0e 9b       	mov	r11,r7
80008126:	18 95       	mov	r5,r12
80008128:	c4 e8       	rjmp	800081c4 <get_arg+0x268>
8000812a:	62 0a       	ld.w	r10,r1[0x0]
8000812c:	5b fa       	cp.w	r10,-1
8000812e:	c0 b1       	brne	80008144 <get_arg+0x1e8>
80008130:	50 19       	stdsp	sp[0x4],r9
80008132:	50 28       	stdsp	sp[0x8],r8
80008134:	e0 6a 00 80 	mov	r10,128
80008138:	30 0b       	mov	r11,0
8000813a:	02 9c       	mov	r12,r1
8000813c:	fe b0 fd 01 	rcall	80007b3e <memset>
80008140:	40 28       	lddsp	r8,sp[0x8]
80008142:	40 19       	lddsp	r9,sp[0x4]
80008144:	e4 cc 00 01 	sub	r12,r2,1
80008148:	0e 9b       	mov	r11,r7
8000814a:	50 3c       	stdsp	sp[0xc],r12
8000814c:	f2 0c 0c 49 	max	r9,r9,r12
80008150:	c3 a8       	rjmp	800081c4 <get_arg+0x268>
80008152:	62 0a       	ld.w	r10,r1[0x0]
80008154:	5b fa       	cp.w	r10,-1
80008156:	c0 b1       	brne	8000816c <get_arg+0x210>
80008158:	50 19       	stdsp	sp[0x4],r9
8000815a:	50 28       	stdsp	sp[0x8],r8
8000815c:	e0 6a 00 80 	mov	r10,128
80008160:	30 0b       	mov	r11,0
80008162:	02 9c       	mov	r12,r1
80008164:	fe b0 fc ed 	rcall	80007b3e <memset>
80008168:	40 28       	lddsp	r8,sp[0x8]
8000816a:	40 19       	lddsp	r9,sp[0x4]
8000816c:	20 12       	sub	r2,1
8000816e:	30 0a       	mov	r10,0
80008170:	0e 9b       	mov	r11,r7
80008172:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008176:	f2 02 0c 49 	max	r9,r9,r2
8000817a:	c2 58       	rjmp	800081c4 <get_arg+0x268>
8000817c:	16 97       	mov	r7,r11
8000817e:	6c 0a       	ld.w	r10,r6[0x0]
80008180:	f4 cb ff fc 	sub	r11,r10,-4
80008184:	8d 0b       	st.w	r6[0x0],r11
80008186:	74 0a       	ld.w	r10,r10[0x0]
80008188:	0e 9b       	mov	r11,r7
8000818a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000818e:	2f f5       	sub	r5,-1
80008190:	c1 a8       	rjmp	800081c4 <get_arg+0x268>
80008192:	f4 c2 00 30 	sub	r2,r10,48
80008196:	c0 68       	rjmp	800081a2 <get_arg+0x246>
80008198:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000819c:	2f f7       	sub	r7,-1
8000819e:	f4 02 00 12 	add	r2,r10,r2<<0x1
800081a2:	0f 8a       	ld.ub	r10,r7[0x0]
800081a4:	58 0a       	cp.w	r10,0
800081a6:	c0 e0       	breq	800081c2 <get_arg+0x266>
800081a8:	23 0a       	sub	r10,48
800081aa:	58 9a       	cp.w	r10,9
800081ac:	fe 98 ff f6 	brls	80008198 <get_arg+0x23c>
800081b0:	c0 98       	rjmp	800081c2 <get_arg+0x266>
800081b2:	2f f7       	sub	r7,-1
800081b4:	0f 8a       	ld.ub	r10,r7[0x0]
800081b6:	58 0a       	cp.w	r10,0
800081b8:	c0 50       	breq	800081c2 <get_arg+0x266>
800081ba:	23 0a       	sub	r10,48
800081bc:	58 9a       	cp.w	r10,9
800081be:	fe 98 ff fa 	brls	800081b2 <get_arg+0x256>
800081c2:	0e 9b       	mov	r11,r7
800081c4:	40 7c       	lddsp	r12,sp[0x1c]
800081c6:	30 ba       	mov	r10,11
800081c8:	f4 0c 18 00 	cp.b	r12,r10
800081cc:	fe 91 fe f2 	brne	80007fb0 <get_arg+0x54>
800081d0:	40 42       	lddsp	r2,sp[0x10]
800081d2:	17 8c       	ld.ub	r12,r11[0x0]
800081d4:	0a 32       	cp.w	r2,r5
800081d6:	5f 4a       	srge	r10
800081d8:	f0 0c 18 00 	cp.b	r12,r8
800081dc:	5f 1c       	srne	r12
800081de:	f9 ea 00 0a 	and	r10,r12,r10
800081e2:	f0 0a 18 00 	cp.b	r10,r8
800081e6:	fe 91 fe cf 	brne	80007f84 <get_arg+0x28>
800081ea:	30 08       	mov	r8,0
800081ec:	40 4e       	lddsp	lr,sp[0x10]
800081ee:	17 8a       	ld.ub	r10,r11[0x0]
800081f0:	e2 05 00 21 	add	r1,r1,r5<<0x2
800081f4:	f0 0a 18 00 	cp.b	r10,r8
800081f8:	fc 09 17 10 	movne	r9,lr
800081fc:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008200:	06 9e       	mov	lr,r3
80008202:	c2 a8       	rjmp	80008256 <get_arg+0x2fa>
80008204:	62 0a       	ld.w	r10,r1[0x0]
80008206:	58 3a       	cp.w	r10,3
80008208:	c1 e0       	breq	80008244 <get_arg+0x2e8>
8000820a:	e0 89 00 07 	brgt	80008218 <get_arg+0x2bc>
8000820e:	58 1a       	cp.w	r10,1
80008210:	c1 a0       	breq	80008244 <get_arg+0x2e8>
80008212:	58 2a       	cp.w	r10,2
80008214:	c1 81       	brne	80008244 <get_arg+0x2e8>
80008216:	c0 58       	rjmp	80008220 <get_arg+0x2c4>
80008218:	58 5a       	cp.w	r10,5
8000821a:	c0 c0       	breq	80008232 <get_arg+0x2d6>
8000821c:	c0 b5       	brlt	80008232 <get_arg+0x2d6>
8000821e:	c1 38       	rjmp	80008244 <get_arg+0x2e8>
80008220:	6c 0a       	ld.w	r10,r6[0x0]
80008222:	f4 cc ff f8 	sub	r12,r10,-8
80008226:	8d 0c       	st.w	r6[0x0],r12
80008228:	f4 e2 00 00 	ld.d	r2,r10[0]
8000822c:	f0 e3 00 00 	st.d	r8[0],r2
80008230:	c1 08       	rjmp	80008250 <get_arg+0x2f4>
80008232:	6c 0a       	ld.w	r10,r6[0x0]
80008234:	f4 cc ff f8 	sub	r12,r10,-8
80008238:	8d 0c       	st.w	r6[0x0],r12
8000823a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000823e:	f0 e3 00 00 	st.d	r8[0],r2
80008242:	c0 78       	rjmp	80008250 <get_arg+0x2f4>
80008244:	6c 0a       	ld.w	r10,r6[0x0]
80008246:	f4 cc ff fc 	sub	r12,r10,-4
8000824a:	8d 0c       	st.w	r6[0x0],r12
8000824c:	74 0a       	ld.w	r10,r10[0x0]
8000824e:	91 0a       	st.w	r8[0x0],r10
80008250:	2f f5       	sub	r5,-1
80008252:	2f 88       	sub	r8,-8
80008254:	2f c1       	sub	r1,-4
80008256:	12 35       	cp.w	r5,r9
80008258:	fe 9a ff d6 	brle	80008204 <get_arg+0x2a8>
8000825c:	1c 93       	mov	r3,lr
8000825e:	40 52       	lddsp	r2,sp[0x14]
80008260:	40 6e       	lddsp	lr,sp[0x18]
80008262:	85 05       	st.w	r2[0x0],r5
80008264:	9d 0b       	st.w	lr[0x0],r11
80008266:	40 4b       	lddsp	r11,sp[0x10]
80008268:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000826c:	2f 8d       	sub	sp,-32
8000826e:	d8 32       	popm	r0-r7,pc

80008270 <__sprint_r>:
80008270:	d4 21       	pushm	r4-r7,lr
80008272:	14 97       	mov	r7,r10
80008274:	74 28       	ld.w	r8,r10[0x8]
80008276:	58 08       	cp.w	r8,0
80008278:	c0 41       	brne	80008280 <__sprint_r+0x10>
8000827a:	95 18       	st.w	r10[0x4],r8
8000827c:	10 9c       	mov	r12,r8
8000827e:	d8 22       	popm	r4-r7,pc
80008280:	e0 a0 18 ba 	rcall	8000b3f4 <__sfvwrite_r>
80008284:	30 08       	mov	r8,0
80008286:	8f 18       	st.w	r7[0x4],r8
80008288:	8f 28       	st.w	r7[0x8],r8
8000828a:	d8 22       	popm	r4-r7,pc

8000828c <_vfprintf_r>:
8000828c:	d4 31       	pushm	r0-r7,lr
8000828e:	fa cd 06 bc 	sub	sp,sp,1724
80008292:	51 09       	stdsp	sp[0x40],r9
80008294:	16 91       	mov	r1,r11
80008296:	14 97       	mov	r7,r10
80008298:	18 95       	mov	r5,r12
8000829a:	e0 a0 1a 1d 	rcall	8000b6d4 <_localeconv_r>
8000829e:	78 0c       	ld.w	r12,r12[0x0]
800082a0:	50 cc       	stdsp	sp[0x30],r12
800082a2:	58 05       	cp.w	r5,0
800082a4:	c0 70       	breq	800082b2 <_vfprintf_r+0x26>
800082a6:	6a 68       	ld.w	r8,r5[0x18]
800082a8:	58 08       	cp.w	r8,0
800082aa:	c0 41       	brne	800082b2 <_vfprintf_r+0x26>
800082ac:	0a 9c       	mov	r12,r5
800082ae:	e0 a0 17 43 	rcall	8000b134 <__sinit>
800082b2:	fe c8 a0 22 	sub	r8,pc,-24542
800082b6:	10 31       	cp.w	r1,r8
800082b8:	c0 31       	brne	800082be <_vfprintf_r+0x32>
800082ba:	6a 01       	ld.w	r1,r5[0x0]
800082bc:	c0 c8       	rjmp	800082d4 <_vfprintf_r+0x48>
800082be:	fe c8 a0 0e 	sub	r8,pc,-24562
800082c2:	10 31       	cp.w	r1,r8
800082c4:	c0 31       	brne	800082ca <_vfprintf_r+0x3e>
800082c6:	6a 11       	ld.w	r1,r5[0x4]
800082c8:	c0 68       	rjmp	800082d4 <_vfprintf_r+0x48>
800082ca:	fe c8 9f fa 	sub	r8,pc,-24582
800082ce:	10 31       	cp.w	r1,r8
800082d0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800082d4:	82 68       	ld.sh	r8,r1[0xc]
800082d6:	ed b8 00 03 	bld	r8,0x3
800082da:	c0 41       	brne	800082e2 <_vfprintf_r+0x56>
800082dc:	62 48       	ld.w	r8,r1[0x10]
800082de:	58 08       	cp.w	r8,0
800082e0:	c0 71       	brne	800082ee <_vfprintf_r+0x62>
800082e2:	02 9b       	mov	r11,r1
800082e4:	0a 9c       	mov	r12,r5
800082e6:	e0 a0 0f 5d 	rcall	8000a1a0 <__swsetup_r>
800082ea:	e0 81 0f 54 	brne	8000a192 <_vfprintf_r+0x1f06>
800082ee:	82 68       	ld.sh	r8,r1[0xc]
800082f0:	10 99       	mov	r9,r8
800082f2:	e2 19 00 1a 	andl	r9,0x1a,COH
800082f6:	58 a9       	cp.w	r9,10
800082f8:	c3 c1       	brne	80008370 <_vfprintf_r+0xe4>
800082fa:	82 79       	ld.sh	r9,r1[0xe]
800082fc:	30 0a       	mov	r10,0
800082fe:	f4 09 19 00 	cp.h	r9,r10
80008302:	c3 75       	brlt	80008370 <_vfprintf_r+0xe4>
80008304:	a1 d8       	cbr	r8,0x1
80008306:	fb 58 05 d0 	st.h	sp[1488],r8
8000830a:	62 88       	ld.w	r8,r1[0x20]
8000830c:	fb 48 05 e4 	st.w	sp[1508],r8
80008310:	62 a8       	ld.w	r8,r1[0x28]
80008312:	fb 48 05 ec 	st.w	sp[1516],r8
80008316:	fa c8 ff bc 	sub	r8,sp,-68
8000831a:	fb 48 05 d4 	st.w	sp[1492],r8
8000831e:	fb 48 05 c4 	st.w	sp[1476],r8
80008322:	e0 68 04 00 	mov	r8,1024
80008326:	fb 48 05 d8 	st.w	sp[1496],r8
8000832a:	fb 48 05 cc 	st.w	sp[1484],r8
8000832e:	30 08       	mov	r8,0
80008330:	fb 59 05 d2 	st.h	sp[1490],r9
80008334:	0e 9a       	mov	r10,r7
80008336:	41 09       	lddsp	r9,sp[0x40]
80008338:	fa c7 fa 3c 	sub	r7,sp,-1476
8000833c:	fb 48 05 dc 	st.w	sp[1500],r8
80008340:	0a 9c       	mov	r12,r5
80008342:	0e 9b       	mov	r11,r7
80008344:	ca 4f       	rcall	8000828c <_vfprintf_r>
80008346:	50 bc       	stdsp	sp[0x2c],r12
80008348:	c0 95       	brlt	8000835a <_vfprintf_r+0xce>
8000834a:	0e 9b       	mov	r11,r7
8000834c:	0a 9c       	mov	r12,r5
8000834e:	e0 a0 16 1b 	rcall	8000af84 <_fflush_r>
80008352:	40 be       	lddsp	lr,sp[0x2c]
80008354:	f9 be 01 ff 	movne	lr,-1
80008358:	50 be       	stdsp	sp[0x2c],lr
8000835a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000835e:	ed b8 00 06 	bld	r8,0x6
80008362:	e0 81 0f 1a 	brne	8000a196 <_vfprintf_r+0x1f0a>
80008366:	82 68       	ld.sh	r8,r1[0xc]
80008368:	a7 a8       	sbr	r8,0x6
8000836a:	a2 68       	st.h	r1[0xc],r8
8000836c:	e0 8f 0f 15 	bral	8000a196 <_vfprintf_r+0x1f0a>
80008370:	30 08       	mov	r8,0
80008372:	fb 48 06 b4 	st.w	sp[1716],r8
80008376:	fb 48 06 90 	st.w	sp[1680],r8
8000837a:	fb 48 06 8c 	st.w	sp[1676],r8
8000837e:	fb 48 06 b0 	st.w	sp[1712],r8
80008382:	30 08       	mov	r8,0
80008384:	30 09       	mov	r9,0
80008386:	50 a7       	stdsp	sp[0x28],r7
80008388:	50 78       	stdsp	sp[0x1c],r8
8000838a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000838e:	3f f8       	mov	r8,-1
80008390:	50 59       	stdsp	sp[0x14],r9
80008392:	fb 43 06 88 	st.w	sp[1672],r3
80008396:	fb 48 05 44 	st.w	sp[1348],r8
8000839a:	12 9c       	mov	r12,r9
8000839c:	50 69       	stdsp	sp[0x18],r9
8000839e:	50 d9       	stdsp	sp[0x34],r9
800083a0:	50 e9       	stdsp	sp[0x38],r9
800083a2:	50 b9       	stdsp	sp[0x2c],r9
800083a4:	12 97       	mov	r7,r9
800083a6:	0a 94       	mov	r4,r5
800083a8:	40 a2       	lddsp	r2,sp[0x28]
800083aa:	32 5a       	mov	r10,37
800083ac:	30 08       	mov	r8,0
800083ae:	c0 28       	rjmp	800083b2 <_vfprintf_r+0x126>
800083b0:	2f f2       	sub	r2,-1
800083b2:	05 89       	ld.ub	r9,r2[0x0]
800083b4:	f0 09 18 00 	cp.b	r9,r8
800083b8:	5f 1b       	srne	r11
800083ba:	f4 09 18 00 	cp.b	r9,r10
800083be:	5f 19       	srne	r9
800083c0:	f3 eb 00 0b 	and	r11,r9,r11
800083c4:	f0 0b 18 00 	cp.b	r11,r8
800083c8:	cf 41       	brne	800083b0 <_vfprintf_r+0x124>
800083ca:	40 ab       	lddsp	r11,sp[0x28]
800083cc:	e4 0b 01 06 	sub	r6,r2,r11
800083d0:	c1 e0       	breq	8000840c <_vfprintf_r+0x180>
800083d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800083d6:	0c 08       	add	r8,r6
800083d8:	87 0b       	st.w	r3[0x0],r11
800083da:	fb 48 06 90 	st.w	sp[1680],r8
800083de:	87 16       	st.w	r3[0x4],r6
800083e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800083e4:	2f f8       	sub	r8,-1
800083e6:	fb 48 06 8c 	st.w	sp[1676],r8
800083ea:	58 78       	cp.w	r8,7
800083ec:	e0 89 00 04 	brgt	800083f4 <_vfprintf_r+0x168>
800083f0:	2f 83       	sub	r3,-8
800083f2:	c0 a8       	rjmp	80008406 <_vfprintf_r+0x17a>
800083f4:	fa ca f9 78 	sub	r10,sp,-1672
800083f8:	02 9b       	mov	r11,r1
800083fa:	08 9c       	mov	r12,r4
800083fc:	c3 af       	rcall	80008270 <__sprint_r>
800083fe:	e0 81 0e c6 	brne	8000a18a <_vfprintf_r+0x1efe>
80008402:	fa c3 f9 e0 	sub	r3,sp,-1568
80008406:	40 ba       	lddsp	r10,sp[0x2c]
80008408:	0c 0a       	add	r10,r6
8000840a:	50 ba       	stdsp	sp[0x2c],r10
8000840c:	05 89       	ld.ub	r9,r2[0x0]
8000840e:	30 08       	mov	r8,0
80008410:	f0 09 18 00 	cp.b	r9,r8
80008414:	e0 80 0e aa 	breq	8000a168 <_vfprintf_r+0x1edc>
80008418:	30 09       	mov	r9,0
8000841a:	fb 68 06 bb 	st.b	sp[1723],r8
8000841e:	0e 96       	mov	r6,r7
80008420:	e4 c8 ff ff 	sub	r8,r2,-1
80008424:	3f fe       	mov	lr,-1
80008426:	50 93       	stdsp	sp[0x24],r3
80008428:	50 41       	stdsp	sp[0x10],r1
8000842a:	0e 93       	mov	r3,r7
8000842c:	04 91       	mov	r1,r2
8000842e:	50 89       	stdsp	sp[0x20],r9
80008430:	50 a8       	stdsp	sp[0x28],r8
80008432:	50 2e       	stdsp	sp[0x8],lr
80008434:	50 39       	stdsp	sp[0xc],r9
80008436:	12 95       	mov	r5,r9
80008438:	12 90       	mov	r0,r9
8000843a:	10 97       	mov	r7,r8
8000843c:	08 92       	mov	r2,r4
8000843e:	c0 78       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008440:	3f fc       	mov	r12,-1
80008442:	08 97       	mov	r7,r4
80008444:	50 2c       	stdsp	sp[0x8],r12
80008446:	c0 38       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008448:	30 0b       	mov	r11,0
8000844a:	50 3b       	stdsp	sp[0xc],r11
8000844c:	0f 38       	ld.ub	r8,r7++
8000844e:	c0 28       	rjmp	80008452 <_vfprintf_r+0x1c6>
80008450:	12 90       	mov	r0,r9
80008452:	f0 c9 00 20 	sub	r9,r8,32
80008456:	e0 49 00 58 	cp.w	r9,88
8000845a:	e0 8b 0a 30 	brhi	800098ba <_vfprintf_r+0x162e>
8000845e:	fe ca a5 76 	sub	r10,pc,-23178
80008462:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008466:	50 a7       	stdsp	sp[0x28],r7
80008468:	50 80       	stdsp	sp[0x20],r0
8000846a:	0c 97       	mov	r7,r6
8000846c:	04 94       	mov	r4,r2
8000846e:	06 96       	mov	r6,r3
80008470:	02 92       	mov	r2,r1
80008472:	fe c9 a3 4e 	sub	r9,pc,-23730
80008476:	40 93       	lddsp	r3,sp[0x24]
80008478:	10 90       	mov	r0,r8
8000847a:	40 41       	lddsp	r1,sp[0x10]
8000847c:	50 d9       	stdsp	sp[0x34],r9
8000847e:	e0 8f 08 8e 	bral	8000959a <_vfprintf_r+0x130e>
80008482:	30 08       	mov	r8,0
80008484:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008488:	f0 09 18 00 	cp.b	r9,r8
8000848c:	ce 01       	brne	8000844c <_vfprintf_r+0x1c0>
8000848e:	32 08       	mov	r8,32
80008490:	c6 e8       	rjmp	8000856c <_vfprintf_r+0x2e0>
80008492:	a1 a5       	sbr	r5,0x0
80008494:	cd cb       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008496:	0f 89       	ld.ub	r9,r7[0x0]
80008498:	f2 c8 00 30 	sub	r8,r9,48
8000849c:	58 98       	cp.w	r8,9
8000849e:	e0 8b 00 1d 	brhi	800084d8 <_vfprintf_r+0x24c>
800084a2:	ee c8 ff ff 	sub	r8,r7,-1
800084a6:	30 0b       	mov	r11,0
800084a8:	23 09       	sub	r9,48
800084aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800084ae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800084b2:	11 39       	ld.ub	r9,r8++
800084b4:	f2 ca 00 30 	sub	r10,r9,48
800084b8:	58 9a       	cp.w	r10,9
800084ba:	fe 98 ff f7 	brls	800084a8 <_vfprintf_r+0x21c>
800084be:	e0 49 00 24 	cp.w	r9,36
800084c2:	cc 31       	brne	80008448 <_vfprintf_r+0x1bc>
800084c4:	e0 4b 00 20 	cp.w	r11,32
800084c8:	e0 89 0e 60 	brgt	8000a188 <_vfprintf_r+0x1efc>
800084cc:	20 1b       	sub	r11,1
800084ce:	fa f9 06 b4 	ld.w	r9,sp[1716]
800084d2:	12 3b       	cp.w	r11,r9
800084d4:	c0 95       	brlt	800084e6 <_vfprintf_r+0x25a>
800084d6:	c1 08       	rjmp	800084f6 <_vfprintf_r+0x26a>
800084d8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800084dc:	ec ca ff ff 	sub	r10,r6,-1
800084e0:	12 36       	cp.w	r6,r9
800084e2:	c1 f5       	brlt	80008520 <_vfprintf_r+0x294>
800084e4:	c2 68       	rjmp	80008530 <_vfprintf_r+0x2a4>
800084e6:	fa ce f9 44 	sub	lr,sp,-1724
800084ea:	10 97       	mov	r7,r8
800084ec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800084f0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800084f4:	c3 58       	rjmp	8000855e <_vfprintf_r+0x2d2>
800084f6:	10 97       	mov	r7,r8
800084f8:	fa c8 f9 50 	sub	r8,sp,-1712
800084fc:	1a d8       	st.w	--sp,r8
800084fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008502:	1a d8       	st.w	--sp,r8
80008504:	fa c8 fb b4 	sub	r8,sp,-1100
80008508:	02 9a       	mov	r10,r1
8000850a:	1a d8       	st.w	--sp,r8
8000850c:	04 9c       	mov	r12,r2
8000850e:	fa c8 f9 40 	sub	r8,sp,-1728
80008512:	fa c9 ff b4 	sub	r9,sp,-76
80008516:	fe b0 fd 23 	rcall	80007f5c <get_arg>
8000851a:	2f dd       	sub	sp,-12
8000851c:	78 00       	ld.w	r0,r12[0x0]
8000851e:	c2 08       	rjmp	8000855e <_vfprintf_r+0x2d2>
80008520:	fa cc f9 44 	sub	r12,sp,-1724
80008524:	14 96       	mov	r6,r10
80008526:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000852a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000852e:	c1 88       	rjmp	8000855e <_vfprintf_r+0x2d2>
80008530:	41 08       	lddsp	r8,sp[0x40]
80008532:	59 f9       	cp.w	r9,31
80008534:	e0 89 00 11 	brgt	80008556 <_vfprintf_r+0x2ca>
80008538:	f0 cb ff fc 	sub	r11,r8,-4
8000853c:	51 0b       	stdsp	sp[0x40],r11
8000853e:	70 00       	ld.w	r0,r8[0x0]
80008540:	fa cb f9 44 	sub	r11,sp,-1724
80008544:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008548:	f1 40 fd 88 	st.w	r8[-632],r0
8000854c:	2f f9       	sub	r9,-1
8000854e:	14 96       	mov	r6,r10
80008550:	fb 49 06 b4 	st.w	sp[1716],r9
80008554:	c0 58       	rjmp	8000855e <_vfprintf_r+0x2d2>
80008556:	70 00       	ld.w	r0,r8[0x0]
80008558:	14 96       	mov	r6,r10
8000855a:	2f c8       	sub	r8,-4
8000855c:	51 08       	stdsp	sp[0x40],r8
8000855e:	58 00       	cp.w	r0,0
80008560:	fe 94 ff 76 	brge	8000844c <_vfprintf_r+0x1c0>
80008564:	5c 30       	neg	r0
80008566:	a3 a5       	sbr	r5,0x2
80008568:	c7 2b       	rjmp	8000844c <_vfprintf_r+0x1c0>
8000856a:	32 b8       	mov	r8,43
8000856c:	fb 68 06 bb 	st.b	sp[1723],r8
80008570:	c6 eb       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008572:	0f 38       	ld.ub	r8,r7++
80008574:	e0 48 00 2a 	cp.w	r8,42
80008578:	c0 30       	breq	8000857e <_vfprintf_r+0x2f2>
8000857a:	30 09       	mov	r9,0
8000857c:	c7 98       	rjmp	8000866e <_vfprintf_r+0x3e2>
8000857e:	0f 88       	ld.ub	r8,r7[0x0]
80008580:	f0 c9 00 30 	sub	r9,r8,48
80008584:	58 99       	cp.w	r9,9
80008586:	e0 8b 00 1f 	brhi	800085c4 <_vfprintf_r+0x338>
8000858a:	ee c4 ff ff 	sub	r4,r7,-1
8000858e:	30 0b       	mov	r11,0
80008590:	23 08       	sub	r8,48
80008592:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008596:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000859a:	09 38       	ld.ub	r8,r4++
8000859c:	f0 c9 00 30 	sub	r9,r8,48
800085a0:	58 99       	cp.w	r9,9
800085a2:	fe 98 ff f7 	brls	80008590 <_vfprintf_r+0x304>
800085a6:	e0 48 00 24 	cp.w	r8,36
800085aa:	fe 91 ff 4f 	brne	80008448 <_vfprintf_r+0x1bc>
800085ae:	e0 4b 00 20 	cp.w	r11,32
800085b2:	e0 89 0d eb 	brgt	8000a188 <_vfprintf_r+0x1efc>
800085b6:	20 1b       	sub	r11,1
800085b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085bc:	10 3b       	cp.w	r11,r8
800085be:	c0 a5       	brlt	800085d2 <_vfprintf_r+0x346>
800085c0:	c1 18       	rjmp	800085e2 <_vfprintf_r+0x356>
800085c2:	d7 03       	nop
800085c4:	fa fa 06 b4 	ld.w	r10,sp[1716]
800085c8:	ec c9 ff ff 	sub	r9,r6,-1
800085cc:	14 36       	cp.w	r6,r10
800085ce:	c1 f5       	brlt	8000860c <_vfprintf_r+0x380>
800085d0:	c2 88       	rjmp	80008620 <_vfprintf_r+0x394>
800085d2:	fa ca f9 44 	sub	r10,sp,-1724
800085d6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800085da:	f6 fb fd 88 	ld.w	r11,r11[-632]
800085de:	50 2b       	stdsp	sp[0x8],r11
800085e0:	c3 c8       	rjmp	80008658 <_vfprintf_r+0x3cc>
800085e2:	fa c8 f9 50 	sub	r8,sp,-1712
800085e6:	1a d8       	st.w	--sp,r8
800085e8:	fa c8 fa b8 	sub	r8,sp,-1352
800085ec:	1a d8       	st.w	--sp,r8
800085ee:	fa c8 fb b4 	sub	r8,sp,-1100
800085f2:	02 9a       	mov	r10,r1
800085f4:	1a d8       	st.w	--sp,r8
800085f6:	04 9c       	mov	r12,r2
800085f8:	fa c8 f9 40 	sub	r8,sp,-1728
800085fc:	fa c9 ff b4 	sub	r9,sp,-76
80008600:	fe b0 fc ae 	rcall	80007f5c <get_arg>
80008604:	2f dd       	sub	sp,-12
80008606:	78 0c       	ld.w	r12,r12[0x0]
80008608:	50 2c       	stdsp	sp[0x8],r12
8000860a:	c2 78       	rjmp	80008658 <_vfprintf_r+0x3cc>
8000860c:	12 96       	mov	r6,r9
8000860e:	0e 94       	mov	r4,r7
80008610:	fa c9 f9 44 	sub	r9,sp,-1724
80008614:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008618:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000861c:	50 28       	stdsp	sp[0x8],r8
8000861e:	c1 d8       	rjmp	80008658 <_vfprintf_r+0x3cc>
80008620:	41 08       	lddsp	r8,sp[0x40]
80008622:	59 fa       	cp.w	r10,31
80008624:	e0 89 00 14 	brgt	8000864c <_vfprintf_r+0x3c0>
80008628:	f0 cb ff fc 	sub	r11,r8,-4
8000862c:	70 08       	ld.w	r8,r8[0x0]
8000862e:	51 0b       	stdsp	sp[0x40],r11
80008630:	50 28       	stdsp	sp[0x8],r8
80008632:	fa c6 f9 44 	sub	r6,sp,-1724
80008636:	40 2e       	lddsp	lr,sp[0x8]
80008638:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000863c:	f1 4e fd 88 	st.w	r8[-632],lr
80008640:	2f fa       	sub	r10,-1
80008642:	0e 94       	mov	r4,r7
80008644:	fb 4a 06 b4 	st.w	sp[1716],r10
80008648:	12 96       	mov	r6,r9
8000864a:	c0 78       	rjmp	80008658 <_vfprintf_r+0x3cc>
8000864c:	70 0c       	ld.w	r12,r8[0x0]
8000864e:	0e 94       	mov	r4,r7
80008650:	2f c8       	sub	r8,-4
80008652:	50 2c       	stdsp	sp[0x8],r12
80008654:	12 96       	mov	r6,r9
80008656:	51 08       	stdsp	sp[0x40],r8
80008658:	40 2b       	lddsp	r11,sp[0x8]
8000865a:	58 0b       	cp.w	r11,0
8000865c:	fe 95 fe f2 	brlt	80008440 <_vfprintf_r+0x1b4>
80008660:	08 97       	mov	r7,r4
80008662:	cf 5a       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008664:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008668:	0f 38       	ld.ub	r8,r7++
8000866a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000866e:	f0 ca 00 30 	sub	r10,r8,48
80008672:	58 9a       	cp.w	r10,9
80008674:	fe 98 ff f8 	brls	80008664 <_vfprintf_r+0x3d8>
80008678:	3f fa       	mov	r10,-1
8000867a:	f2 0a 0c 49 	max	r9,r9,r10
8000867e:	50 29       	stdsp	sp[0x8],r9
80008680:	ce 9a       	rjmp	80008452 <_vfprintf_r+0x1c6>
80008682:	a7 b5       	sbr	r5,0x7
80008684:	ce 4a       	rjmp	8000844c <_vfprintf_r+0x1c0>
80008686:	30 09       	mov	r9,0
80008688:	23 08       	sub	r8,48
8000868a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000868e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008692:	0f 38       	ld.ub	r8,r7++
80008694:	f0 ca 00 30 	sub	r10,r8,48
80008698:	58 9a       	cp.w	r10,9
8000869a:	fe 98 ff f7 	brls	80008688 <_vfprintf_r+0x3fc>
8000869e:	e0 48 00 24 	cp.w	r8,36
800086a2:	fe 91 fe d7 	brne	80008450 <_vfprintf_r+0x1c4>
800086a6:	e0 49 00 20 	cp.w	r9,32
800086aa:	e0 89 0d 6f 	brgt	8000a188 <_vfprintf_r+0x1efc>
800086ae:	f2 c3 00 01 	sub	r3,r9,1
800086b2:	30 19       	mov	r9,1
800086b4:	50 39       	stdsp	sp[0xc],r9
800086b6:	cc ba       	rjmp	8000844c <_vfprintf_r+0x1c0>
800086b8:	a3 b5       	sbr	r5,0x3
800086ba:	cc 9a       	rjmp	8000844c <_vfprintf_r+0x1c0>
800086bc:	a7 a5       	sbr	r5,0x6
800086be:	cc 7a       	rjmp	8000844c <_vfprintf_r+0x1c0>
800086c0:	0a 98       	mov	r8,r5
800086c2:	a5 b5       	sbr	r5,0x5
800086c4:	a5 a8       	sbr	r8,0x4
800086c6:	0f 89       	ld.ub	r9,r7[0x0]
800086c8:	36 ce       	mov	lr,108
800086ca:	fc 09 18 00 	cp.b	r9,lr
800086ce:	f7 b7 00 ff 	subeq	r7,-1
800086d2:	f0 05 17 10 	movne	r5,r8
800086d6:	cb ba       	rjmp	8000844c <_vfprintf_r+0x1c0>
800086d8:	a5 b5       	sbr	r5,0x5
800086da:	cb 9a       	rjmp	8000844c <_vfprintf_r+0x1c0>
800086dc:	50 a7       	stdsp	sp[0x28],r7
800086de:	50 80       	stdsp	sp[0x20],r0
800086e0:	0c 97       	mov	r7,r6
800086e2:	10 90       	mov	r0,r8
800086e4:	06 96       	mov	r6,r3
800086e6:	04 94       	mov	r4,r2
800086e8:	40 93       	lddsp	r3,sp[0x24]
800086ea:	02 92       	mov	r2,r1
800086ec:	0e 99       	mov	r9,r7
800086ee:	40 41       	lddsp	r1,sp[0x10]
800086f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f4:	40 3c       	lddsp	r12,sp[0xc]
800086f6:	58 0c       	cp.w	r12,0
800086f8:	c1 d0       	breq	80008732 <_vfprintf_r+0x4a6>
800086fa:	10 36       	cp.w	r6,r8
800086fc:	c0 64       	brge	80008708 <_vfprintf_r+0x47c>
800086fe:	fa cb f9 44 	sub	r11,sp,-1724
80008702:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008706:	c1 d8       	rjmp	80008740 <_vfprintf_r+0x4b4>
80008708:	fa c8 f9 50 	sub	r8,sp,-1712
8000870c:	1a d8       	st.w	--sp,r8
8000870e:	fa c8 fa b8 	sub	r8,sp,-1352
80008712:	1a d8       	st.w	--sp,r8
80008714:	fa c8 fb b4 	sub	r8,sp,-1100
80008718:	1a d8       	st.w	--sp,r8
8000871a:	fa c8 f9 40 	sub	r8,sp,-1728
8000871e:	fa c9 ff b4 	sub	r9,sp,-76
80008722:	04 9a       	mov	r10,r2
80008724:	0c 9b       	mov	r11,r6
80008726:	08 9c       	mov	r12,r4
80008728:	fe b0 fc 1a 	rcall	80007f5c <get_arg>
8000872c:	2f dd       	sub	sp,-12
8000872e:	19 b8       	ld.ub	r8,r12[0x3]
80008730:	c2 28       	rjmp	80008774 <_vfprintf_r+0x4e8>
80008732:	2f f7       	sub	r7,-1
80008734:	10 39       	cp.w	r9,r8
80008736:	c0 84       	brge	80008746 <_vfprintf_r+0x4ba>
80008738:	fa ca f9 44 	sub	r10,sp,-1724
8000873c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008740:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008744:	c1 88       	rjmp	80008774 <_vfprintf_r+0x4e8>
80008746:	41 09       	lddsp	r9,sp[0x40]
80008748:	59 f8       	cp.w	r8,31
8000874a:	e0 89 00 12 	brgt	8000876e <_vfprintf_r+0x4e2>
8000874e:	f2 ca ff fc 	sub	r10,r9,-4
80008752:	51 0a       	stdsp	sp[0x40],r10
80008754:	72 09       	ld.w	r9,r9[0x0]
80008756:	fa c6 f9 44 	sub	r6,sp,-1724
8000875a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000875e:	2f f8       	sub	r8,-1
80008760:	f5 49 fd 88 	st.w	r10[-632],r9
80008764:	fb 48 06 b4 	st.w	sp[1716],r8
80008768:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000876c:	c0 48       	rjmp	80008774 <_vfprintf_r+0x4e8>
8000876e:	13 b8       	ld.ub	r8,r9[0x3]
80008770:	2f c9       	sub	r9,-4
80008772:	51 09       	stdsp	sp[0x40],r9
80008774:	fb 68 06 60 	st.b	sp[1632],r8
80008778:	30 0e       	mov	lr,0
8000877a:	30 08       	mov	r8,0
8000877c:	30 12       	mov	r2,1
8000877e:	fb 68 06 bb 	st.b	sp[1723],r8
80008782:	50 2e       	stdsp	sp[0x8],lr
80008784:	e0 8f 08 ad 	bral	800098de <_vfprintf_r+0x1652>
80008788:	50 a7       	stdsp	sp[0x28],r7
8000878a:	50 80       	stdsp	sp[0x20],r0
8000878c:	0c 97       	mov	r7,r6
8000878e:	04 94       	mov	r4,r2
80008790:	06 96       	mov	r6,r3
80008792:	02 92       	mov	r2,r1
80008794:	40 93       	lddsp	r3,sp[0x24]
80008796:	10 90       	mov	r0,r8
80008798:	40 41       	lddsp	r1,sp[0x10]
8000879a:	a5 a5       	sbr	r5,0x4
8000879c:	c0 a8       	rjmp	800087b0 <_vfprintf_r+0x524>
8000879e:	50 a7       	stdsp	sp[0x28],r7
800087a0:	50 80       	stdsp	sp[0x20],r0
800087a2:	0c 97       	mov	r7,r6
800087a4:	04 94       	mov	r4,r2
800087a6:	06 96       	mov	r6,r3
800087a8:	02 92       	mov	r2,r1
800087aa:	40 93       	lddsp	r3,sp[0x24]
800087ac:	10 90       	mov	r0,r8
800087ae:	40 41       	lddsp	r1,sp[0x10]
800087b0:	ed b5 00 05 	bld	r5,0x5
800087b4:	c5 11       	brne	80008856 <_vfprintf_r+0x5ca>
800087b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087ba:	40 3c       	lddsp	r12,sp[0xc]
800087bc:	58 0c       	cp.w	r12,0
800087be:	c1 e0       	breq	800087fa <_vfprintf_r+0x56e>
800087c0:	10 36       	cp.w	r6,r8
800087c2:	c0 64       	brge	800087ce <_vfprintf_r+0x542>
800087c4:	fa cb f9 44 	sub	r11,sp,-1724
800087c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087cc:	c2 08       	rjmp	8000880c <_vfprintf_r+0x580>
800087ce:	fa c8 f9 50 	sub	r8,sp,-1712
800087d2:	1a d8       	st.w	--sp,r8
800087d4:	fa c8 fa b8 	sub	r8,sp,-1352
800087d8:	0c 9b       	mov	r11,r6
800087da:	1a d8       	st.w	--sp,r8
800087dc:	fa c8 fb b4 	sub	r8,sp,-1100
800087e0:	1a d8       	st.w	--sp,r8
800087e2:	fa c9 ff b4 	sub	r9,sp,-76
800087e6:	fa c8 f9 40 	sub	r8,sp,-1728
800087ea:	04 9a       	mov	r10,r2
800087ec:	08 9c       	mov	r12,r4
800087ee:	fe b0 fb b7 	rcall	80007f5c <get_arg>
800087f2:	2f dd       	sub	sp,-12
800087f4:	78 1b       	ld.w	r11,r12[0x4]
800087f6:	78 09       	ld.w	r9,r12[0x0]
800087f8:	c2 b8       	rjmp	8000884e <_vfprintf_r+0x5c2>
800087fa:	ee ca ff ff 	sub	r10,r7,-1
800087fe:	10 37       	cp.w	r7,r8
80008800:	c0 b4       	brge	80008816 <_vfprintf_r+0x58a>
80008802:	fa c9 f9 44 	sub	r9,sp,-1724
80008806:	14 97       	mov	r7,r10
80008808:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000880c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008810:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008814:	c1 d8       	rjmp	8000884e <_vfprintf_r+0x5c2>
80008816:	41 09       	lddsp	r9,sp[0x40]
80008818:	59 f8       	cp.w	r8,31
8000881a:	e0 89 00 14 	brgt	80008842 <_vfprintf_r+0x5b6>
8000881e:	f2 cb ff f8 	sub	r11,r9,-8
80008822:	51 0b       	stdsp	sp[0x40],r11
80008824:	fa c6 f9 44 	sub	r6,sp,-1724
80008828:	72 1b       	ld.w	r11,r9[0x4]
8000882a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000882e:	72 09       	ld.w	r9,r9[0x0]
80008830:	f9 4b fd 8c 	st.w	r12[-628],r11
80008834:	f9 49 fd 88 	st.w	r12[-632],r9
80008838:	2f f8       	sub	r8,-1
8000883a:	14 97       	mov	r7,r10
8000883c:	fb 48 06 b4 	st.w	sp[1716],r8
80008840:	c0 78       	rjmp	8000884e <_vfprintf_r+0x5c2>
80008842:	f2 c8 ff f8 	sub	r8,r9,-8
80008846:	72 1b       	ld.w	r11,r9[0x4]
80008848:	14 97       	mov	r7,r10
8000884a:	51 08       	stdsp	sp[0x40],r8
8000884c:	72 09       	ld.w	r9,r9[0x0]
8000884e:	16 98       	mov	r8,r11
80008850:	fa e9 00 00 	st.d	sp[0],r8
80008854:	ca e8       	rjmp	800089b0 <_vfprintf_r+0x724>
80008856:	ed b5 00 04 	bld	r5,0x4
8000885a:	c1 71       	brne	80008888 <_vfprintf_r+0x5fc>
8000885c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008860:	40 3e       	lddsp	lr,sp[0xc]
80008862:	58 0e       	cp.w	lr,0
80008864:	c0 80       	breq	80008874 <_vfprintf_r+0x5e8>
80008866:	10 36       	cp.w	r6,r8
80008868:	c6 94       	brge	8000893a <_vfprintf_r+0x6ae>
8000886a:	fa cc f9 44 	sub	r12,sp,-1724
8000886e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008872:	c8 28       	rjmp	80008976 <_vfprintf_r+0x6ea>
80008874:	ee ca ff ff 	sub	r10,r7,-1
80008878:	10 37       	cp.w	r7,r8
8000887a:	e0 84 00 81 	brge	8000897c <_vfprintf_r+0x6f0>
8000887e:	fa cb f9 44 	sub	r11,sp,-1724
80008882:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008886:	c7 78       	rjmp	80008974 <_vfprintf_r+0x6e8>
80008888:	ed b5 00 06 	bld	r5,0x6
8000888c:	c4 b1       	brne	80008922 <_vfprintf_r+0x696>
8000888e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008892:	40 3c       	lddsp	r12,sp[0xc]
80008894:	58 0c       	cp.w	r12,0
80008896:	c1 d0       	breq	800088d0 <_vfprintf_r+0x644>
80008898:	10 36       	cp.w	r6,r8
8000889a:	c0 64       	brge	800088a6 <_vfprintf_r+0x61a>
8000889c:	fa cb f9 44 	sub	r11,sp,-1724
800088a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088a4:	c1 f8       	rjmp	800088e2 <_vfprintf_r+0x656>
800088a6:	fa c8 f9 50 	sub	r8,sp,-1712
800088aa:	1a d8       	st.w	--sp,r8
800088ac:	fa c8 fa b8 	sub	r8,sp,-1352
800088b0:	1a d8       	st.w	--sp,r8
800088b2:	fa c8 fb b4 	sub	r8,sp,-1100
800088b6:	1a d8       	st.w	--sp,r8
800088b8:	fa c8 f9 40 	sub	r8,sp,-1728
800088bc:	fa c9 ff b4 	sub	r9,sp,-76
800088c0:	04 9a       	mov	r10,r2
800088c2:	0c 9b       	mov	r11,r6
800088c4:	08 9c       	mov	r12,r4
800088c6:	fe b0 fb 4b 	rcall	80007f5c <get_arg>
800088ca:	2f dd       	sub	sp,-12
800088cc:	98 18       	ld.sh	r8,r12[0x2]
800088ce:	c2 68       	rjmp	8000891a <_vfprintf_r+0x68e>
800088d0:	ee ca ff ff 	sub	r10,r7,-1
800088d4:	10 37       	cp.w	r7,r8
800088d6:	c0 94       	brge	800088e8 <_vfprintf_r+0x65c>
800088d8:	fa c9 f9 44 	sub	r9,sp,-1724
800088dc:	14 97       	mov	r7,r10
800088de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088e2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088e6:	c1 a8       	rjmp	8000891a <_vfprintf_r+0x68e>
800088e8:	41 09       	lddsp	r9,sp[0x40]
800088ea:	59 f8       	cp.w	r8,31
800088ec:	e0 89 00 13 	brgt	80008912 <_vfprintf_r+0x686>
800088f0:	f2 cb ff fc 	sub	r11,r9,-4
800088f4:	51 0b       	stdsp	sp[0x40],r11
800088f6:	72 09       	ld.w	r9,r9[0x0]
800088f8:	fa c6 f9 44 	sub	r6,sp,-1724
800088fc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008900:	2f f8       	sub	r8,-1
80008902:	f7 49 fd 88 	st.w	r11[-632],r9
80008906:	fb 48 06 b4 	st.w	sp[1716],r8
8000890a:	14 97       	mov	r7,r10
8000890c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008910:	c0 58       	rjmp	8000891a <_vfprintf_r+0x68e>
80008912:	92 18       	ld.sh	r8,r9[0x2]
80008914:	14 97       	mov	r7,r10
80008916:	2f c9       	sub	r9,-4
80008918:	51 09       	stdsp	sp[0x40],r9
8000891a:	50 18       	stdsp	sp[0x4],r8
8000891c:	bf 58       	asr	r8,0x1f
8000891e:	50 08       	stdsp	sp[0x0],r8
80008920:	c4 88       	rjmp	800089b0 <_vfprintf_r+0x724>
80008922:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008926:	40 3c       	lddsp	r12,sp[0xc]
80008928:	58 0c       	cp.w	r12,0
8000892a:	c1 d0       	breq	80008964 <_vfprintf_r+0x6d8>
8000892c:	10 36       	cp.w	r6,r8
8000892e:	c0 64       	brge	8000893a <_vfprintf_r+0x6ae>
80008930:	fa cb f9 44 	sub	r11,sp,-1724
80008934:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008938:	c1 f8       	rjmp	80008976 <_vfprintf_r+0x6ea>
8000893a:	fa c8 f9 50 	sub	r8,sp,-1712
8000893e:	1a d8       	st.w	--sp,r8
80008940:	fa c8 fa b8 	sub	r8,sp,-1352
80008944:	0c 9b       	mov	r11,r6
80008946:	1a d8       	st.w	--sp,r8
80008948:	fa c8 fb b4 	sub	r8,sp,-1100
8000894c:	04 9a       	mov	r10,r2
8000894e:	1a d8       	st.w	--sp,r8
80008950:	08 9c       	mov	r12,r4
80008952:	fa c8 f9 40 	sub	r8,sp,-1728
80008956:	fa c9 ff b4 	sub	r9,sp,-76
8000895a:	fe b0 fb 01 	rcall	80007f5c <get_arg>
8000895e:	2f dd       	sub	sp,-12
80008960:	78 0b       	ld.w	r11,r12[0x0]
80008962:	c2 48       	rjmp	800089aa <_vfprintf_r+0x71e>
80008964:	ee ca ff ff 	sub	r10,r7,-1
80008968:	10 37       	cp.w	r7,r8
8000896a:	c0 94       	brge	8000897c <_vfprintf_r+0x6f0>
8000896c:	fa c9 f9 44 	sub	r9,sp,-1724
80008970:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008974:	14 97       	mov	r7,r10
80008976:	ec fb fd 88 	ld.w	r11,r6[-632]
8000897a:	c1 88       	rjmp	800089aa <_vfprintf_r+0x71e>
8000897c:	41 09       	lddsp	r9,sp[0x40]
8000897e:	59 f8       	cp.w	r8,31
80008980:	e0 89 00 11 	brgt	800089a2 <_vfprintf_r+0x716>
80008984:	f2 cb ff fc 	sub	r11,r9,-4
80008988:	51 0b       	stdsp	sp[0x40],r11
8000898a:	fa c6 f9 44 	sub	r6,sp,-1724
8000898e:	72 0b       	ld.w	r11,r9[0x0]
80008990:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008994:	f3 4b fd 88 	st.w	r9[-632],r11
80008998:	2f f8       	sub	r8,-1
8000899a:	14 97       	mov	r7,r10
8000899c:	fb 48 06 b4 	st.w	sp[1716],r8
800089a0:	c0 58       	rjmp	800089aa <_vfprintf_r+0x71e>
800089a2:	72 0b       	ld.w	r11,r9[0x0]
800089a4:	14 97       	mov	r7,r10
800089a6:	2f c9       	sub	r9,-4
800089a8:	51 09       	stdsp	sp[0x40],r9
800089aa:	50 1b       	stdsp	sp[0x4],r11
800089ac:	bf 5b       	asr	r11,0x1f
800089ae:	50 0b       	stdsp	sp[0x0],r11
800089b0:	fa ea 00 00 	ld.d	r10,sp[0]
800089b4:	58 0a       	cp.w	r10,0
800089b6:	5c 2b       	cpc	r11
800089b8:	c0 e4       	brge	800089d4 <_vfprintf_r+0x748>
800089ba:	30 08       	mov	r8,0
800089bc:	fa ea 00 00 	ld.d	r10,sp[0]
800089c0:	30 09       	mov	r9,0
800089c2:	f0 0a 01 0a 	sub	r10,r8,r10
800089c6:	f2 0b 01 4b 	sbc	r11,r9,r11
800089ca:	32 d8       	mov	r8,45
800089cc:	fa eb 00 00 	st.d	sp[0],r10
800089d0:	fb 68 06 bb 	st.b	sp[1723],r8
800089d4:	30 18       	mov	r8,1
800089d6:	e0 8f 06 fa 	bral	800097ca <_vfprintf_r+0x153e>
800089da:	50 a7       	stdsp	sp[0x28],r7
800089dc:	50 80       	stdsp	sp[0x20],r0
800089de:	0c 97       	mov	r7,r6
800089e0:	04 94       	mov	r4,r2
800089e2:	06 96       	mov	r6,r3
800089e4:	02 92       	mov	r2,r1
800089e6:	40 93       	lddsp	r3,sp[0x24]
800089e8:	10 90       	mov	r0,r8
800089ea:	40 41       	lddsp	r1,sp[0x10]
800089ec:	0e 99       	mov	r9,r7
800089ee:	ed b5 00 03 	bld	r5,0x3
800089f2:	c4 11       	brne	80008a74 <_vfprintf_r+0x7e8>
800089f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089f8:	40 3a       	lddsp	r10,sp[0xc]
800089fa:	58 0a       	cp.w	r10,0
800089fc:	c1 90       	breq	80008a2e <_vfprintf_r+0x7a2>
800089fe:	10 36       	cp.w	r6,r8
80008a00:	c6 45       	brlt	80008ac8 <_vfprintf_r+0x83c>
80008a02:	fa c8 f9 50 	sub	r8,sp,-1712
80008a06:	1a d8       	st.w	--sp,r8
80008a08:	fa c8 fa b8 	sub	r8,sp,-1352
80008a0c:	1a d8       	st.w	--sp,r8
80008a0e:	fa c8 fb b4 	sub	r8,sp,-1100
80008a12:	0c 9b       	mov	r11,r6
80008a14:	1a d8       	st.w	--sp,r8
80008a16:	04 9a       	mov	r10,r2
80008a18:	fa c8 f9 40 	sub	r8,sp,-1728
80008a1c:	fa c9 ff b4 	sub	r9,sp,-76
80008a20:	08 9c       	mov	r12,r4
80008a22:	fe b0 fa 9d 	rcall	80007f5c <get_arg>
80008a26:	2f dd       	sub	sp,-12
80008a28:	78 16       	ld.w	r6,r12[0x4]
80008a2a:	50 76       	stdsp	sp[0x1c],r6
80008a2c:	c4 88       	rjmp	80008abc <_vfprintf_r+0x830>
80008a2e:	2f f7       	sub	r7,-1
80008a30:	10 39       	cp.w	r9,r8
80008a32:	c0 c4       	brge	80008a4a <_vfprintf_r+0x7be>
80008a34:	fa ce f9 44 	sub	lr,sp,-1724
80008a38:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008a3c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008a40:	50 7c       	stdsp	sp[0x1c],r12
80008a42:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008a46:	50 56       	stdsp	sp[0x14],r6
80008a48:	c6 68       	rjmp	80008b14 <_vfprintf_r+0x888>
80008a4a:	41 09       	lddsp	r9,sp[0x40]
80008a4c:	59 f8       	cp.w	r8,31
80008a4e:	e0 89 00 10 	brgt	80008a6e <_vfprintf_r+0x7e2>
80008a52:	f2 ca ff f8 	sub	r10,r9,-8
80008a56:	72 1b       	ld.w	r11,r9[0x4]
80008a58:	51 0a       	stdsp	sp[0x40],r10
80008a5a:	72 09       	ld.w	r9,r9[0x0]
80008a5c:	fa ca f9 44 	sub	r10,sp,-1724
80008a60:	50 7b       	stdsp	sp[0x1c],r11
80008a62:	50 59       	stdsp	sp[0x14],r9
80008a64:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008a68:	40 5b       	lddsp	r11,sp[0x14]
80008a6a:	40 7a       	lddsp	r10,sp[0x1c]
80008a6c:	c4 78       	rjmp	80008afa <_vfprintf_r+0x86e>
80008a6e:	72 18       	ld.w	r8,r9[0x4]
80008a70:	50 78       	stdsp	sp[0x1c],r8
80008a72:	c4 c8       	rjmp	80008b0a <_vfprintf_r+0x87e>
80008a74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a78:	40 3e       	lddsp	lr,sp[0xc]
80008a7a:	58 0e       	cp.w	lr,0
80008a7c:	c2 30       	breq	80008ac2 <_vfprintf_r+0x836>
80008a7e:	10 36       	cp.w	r6,r8
80008a80:	c0 94       	brge	80008a92 <_vfprintf_r+0x806>
80008a82:	fa cc f9 44 	sub	r12,sp,-1724
80008a86:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a8a:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008a8e:	50 7b       	stdsp	sp[0x1c],r11
80008a90:	cd 9b       	rjmp	80008a42 <_vfprintf_r+0x7b6>
80008a92:	fa c8 f9 50 	sub	r8,sp,-1712
80008a96:	1a d8       	st.w	--sp,r8
80008a98:	fa c8 fa b8 	sub	r8,sp,-1352
80008a9c:	04 9a       	mov	r10,r2
80008a9e:	1a d8       	st.w	--sp,r8
80008aa0:	fa c8 fb b4 	sub	r8,sp,-1100
80008aa4:	0c 9b       	mov	r11,r6
80008aa6:	1a d8       	st.w	--sp,r8
80008aa8:	08 9c       	mov	r12,r4
80008aaa:	fa c8 f9 40 	sub	r8,sp,-1728
80008aae:	fa c9 ff b4 	sub	r9,sp,-76
80008ab2:	fe b0 fa 55 	rcall	80007f5c <get_arg>
80008ab6:	2f dd       	sub	sp,-12
80008ab8:	78 1a       	ld.w	r10,r12[0x4]
80008aba:	50 7a       	stdsp	sp[0x1c],r10
80008abc:	78 0c       	ld.w	r12,r12[0x0]
80008abe:	50 5c       	stdsp	sp[0x14],r12
80008ac0:	c2 a8       	rjmp	80008b14 <_vfprintf_r+0x888>
80008ac2:	2f f7       	sub	r7,-1
80008ac4:	10 39       	cp.w	r9,r8
80008ac6:	c0 94       	brge	80008ad8 <_vfprintf_r+0x84c>
80008ac8:	fa c9 f9 44 	sub	r9,sp,-1724
80008acc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ad0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008ad4:	50 78       	stdsp	sp[0x1c],r8
80008ad6:	cb 6b       	rjmp	80008a42 <_vfprintf_r+0x7b6>
80008ad8:	41 09       	lddsp	r9,sp[0x40]
80008ada:	59 f8       	cp.w	r8,31
80008adc:	e0 89 00 15 	brgt	80008b06 <_vfprintf_r+0x87a>
80008ae0:	f2 ca ff f8 	sub	r10,r9,-8
80008ae4:	72 16       	ld.w	r6,r9[0x4]
80008ae6:	72 09       	ld.w	r9,r9[0x0]
80008ae8:	51 0a       	stdsp	sp[0x40],r10
80008aea:	50 59       	stdsp	sp[0x14],r9
80008aec:	fa ce f9 44 	sub	lr,sp,-1724
80008af0:	50 76       	stdsp	sp[0x1c],r6
80008af2:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008af6:	40 5b       	lddsp	r11,sp[0x14]
80008af8:	0c 9a       	mov	r10,r6
80008afa:	f2 eb fd 88 	st.d	r9[-632],r10
80008afe:	2f f8       	sub	r8,-1
80008b00:	fb 48 06 b4 	st.w	sp[1716],r8
80008b04:	c0 88       	rjmp	80008b14 <_vfprintf_r+0x888>
80008b06:	72 1c       	ld.w	r12,r9[0x4]
80008b08:	50 7c       	stdsp	sp[0x1c],r12
80008b0a:	f2 c8 ff f8 	sub	r8,r9,-8
80008b0e:	51 08       	stdsp	sp[0x40],r8
80008b10:	72 09       	ld.w	r9,r9[0x0]
80008b12:	50 59       	stdsp	sp[0x14],r9
80008b14:	40 5b       	lddsp	r11,sp[0x14]
80008b16:	40 7a       	lddsp	r10,sp[0x1c]
80008b18:	e0 a0 19 54 	rcall	8000bdc0 <__isinfd>
80008b1c:	18 96       	mov	r6,r12
80008b1e:	c1 70       	breq	80008b4c <_vfprintf_r+0x8c0>
80008b20:	30 08       	mov	r8,0
80008b22:	30 09       	mov	r9,0
80008b24:	40 5b       	lddsp	r11,sp[0x14]
80008b26:	40 7a       	lddsp	r10,sp[0x1c]
80008b28:	e0 a0 1d b4 	rcall	8000c690 <__avr32_f64_cmp_lt>
80008b2c:	c0 40       	breq	80008b34 <_vfprintf_r+0x8a8>
80008b2e:	32 d8       	mov	r8,45
80008b30:	fb 68 06 bb 	st.b	sp[1723],r8
80008b34:	fe c8 a9 fc 	sub	r8,pc,-22020
80008b38:	fe c6 a9 fc 	sub	r6,pc,-22020
80008b3c:	a7 d5       	cbr	r5,0x7
80008b3e:	e0 40 00 47 	cp.w	r0,71
80008b42:	f0 06 17 a0 	movle	r6,r8
80008b46:	30 32       	mov	r2,3
80008b48:	e0 8f 06 ce 	bral	800098e4 <_vfprintf_r+0x1658>
80008b4c:	40 5b       	lddsp	r11,sp[0x14]
80008b4e:	40 7a       	lddsp	r10,sp[0x1c]
80008b50:	e0 a0 19 4d 	rcall	8000bdea <__isnand>
80008b54:	c0 e0       	breq	80008b70 <_vfprintf_r+0x8e4>
80008b56:	50 26       	stdsp	sp[0x8],r6
80008b58:	fe c8 aa 18 	sub	r8,pc,-21992
80008b5c:	fe c6 aa 18 	sub	r6,pc,-21992
80008b60:	a7 d5       	cbr	r5,0x7
80008b62:	e0 40 00 47 	cp.w	r0,71
80008b66:	f0 06 17 a0 	movle	r6,r8
80008b6a:	30 32       	mov	r2,3
80008b6c:	e0 8f 06 c2 	bral	800098f0 <_vfprintf_r+0x1664>
80008b70:	40 2a       	lddsp	r10,sp[0x8]
80008b72:	5b fa       	cp.w	r10,-1
80008b74:	c0 41       	brne	80008b7c <_vfprintf_r+0x8f0>
80008b76:	30 69       	mov	r9,6
80008b78:	50 29       	stdsp	sp[0x8],r9
80008b7a:	c1 18       	rjmp	80008b9c <_vfprintf_r+0x910>
80008b7c:	e0 40 00 47 	cp.w	r0,71
80008b80:	5f 09       	sreq	r9
80008b82:	e0 40 00 67 	cp.w	r0,103
80008b86:	5f 08       	sreq	r8
80008b88:	f3 e8 10 08 	or	r8,r9,r8
80008b8c:	f8 08 18 00 	cp.b	r8,r12
80008b90:	c0 60       	breq	80008b9c <_vfprintf_r+0x910>
80008b92:	40 28       	lddsp	r8,sp[0x8]
80008b94:	58 08       	cp.w	r8,0
80008b96:	f9 b8 00 01 	moveq	r8,1
80008b9a:	50 28       	stdsp	sp[0x8],r8
80008b9c:	40 78       	lddsp	r8,sp[0x1c]
80008b9e:	40 59       	lddsp	r9,sp[0x14]
80008ba0:	fa e9 06 94 	st.d	sp[1684],r8
80008ba4:	a9 a5       	sbr	r5,0x8
80008ba6:	fa f8 06 94 	ld.w	r8,sp[1684]
80008baa:	58 08       	cp.w	r8,0
80008bac:	c0 65       	brlt	80008bb8 <_vfprintf_r+0x92c>
80008bae:	40 5e       	lddsp	lr,sp[0x14]
80008bb0:	30 0c       	mov	r12,0
80008bb2:	50 6e       	stdsp	sp[0x18],lr
80008bb4:	50 9c       	stdsp	sp[0x24],r12
80008bb6:	c0 78       	rjmp	80008bc4 <_vfprintf_r+0x938>
80008bb8:	40 5b       	lddsp	r11,sp[0x14]
80008bba:	32 da       	mov	r10,45
80008bbc:	ee 1b 80 00 	eorh	r11,0x8000
80008bc0:	50 9a       	stdsp	sp[0x24],r10
80008bc2:	50 6b       	stdsp	sp[0x18],r11
80008bc4:	e0 40 00 46 	cp.w	r0,70
80008bc8:	5f 09       	sreq	r9
80008bca:	e0 40 00 66 	cp.w	r0,102
80008bce:	5f 08       	sreq	r8
80008bd0:	f3 e8 10 08 	or	r8,r9,r8
80008bd4:	50 48       	stdsp	sp[0x10],r8
80008bd6:	c0 40       	breq	80008bde <_vfprintf_r+0x952>
80008bd8:	40 22       	lddsp	r2,sp[0x8]
80008bda:	30 39       	mov	r9,3
80008bdc:	c1 08       	rjmp	80008bfc <_vfprintf_r+0x970>
80008bde:	e0 40 00 45 	cp.w	r0,69
80008be2:	5f 09       	sreq	r9
80008be4:	e0 40 00 65 	cp.w	r0,101
80008be8:	5f 08       	sreq	r8
80008bea:	40 22       	lddsp	r2,sp[0x8]
80008bec:	10 49       	or	r9,r8
80008bee:	2f f2       	sub	r2,-1
80008bf0:	40 46       	lddsp	r6,sp[0x10]
80008bf2:	ec 09 18 00 	cp.b	r9,r6
80008bf6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008bfa:	30 29       	mov	r9,2
80008bfc:	fa c8 f9 5c 	sub	r8,sp,-1700
80008c00:	1a d8       	st.w	--sp,r8
80008c02:	fa c8 f9 54 	sub	r8,sp,-1708
80008c06:	1a d8       	st.w	--sp,r8
80008c08:	fa c8 f9 4c 	sub	r8,sp,-1716
80008c0c:	08 9c       	mov	r12,r4
80008c0e:	1a d8       	st.w	--sp,r8
80008c10:	04 98       	mov	r8,r2
80008c12:	40 9b       	lddsp	r11,sp[0x24]
80008c14:	40 aa       	lddsp	r10,sp[0x28]
80008c16:	e0 a0 0b c3 	rcall	8000a39c <_dtoa_r>
80008c1a:	e0 40 00 47 	cp.w	r0,71
80008c1e:	5f 19       	srne	r9
80008c20:	e0 40 00 67 	cp.w	r0,103
80008c24:	5f 18       	srne	r8
80008c26:	18 96       	mov	r6,r12
80008c28:	2f dd       	sub	sp,-12
80008c2a:	f3 e8 00 08 	and	r8,r9,r8
80008c2e:	c0 41       	brne	80008c36 <_vfprintf_r+0x9aa>
80008c30:	ed b5 00 00 	bld	r5,0x0
80008c34:	c3 01       	brne	80008c94 <_vfprintf_r+0xa08>
80008c36:	ec 02 00 0e 	add	lr,r6,r2
80008c3a:	50 3e       	stdsp	sp[0xc],lr
80008c3c:	40 4c       	lddsp	r12,sp[0x10]
80008c3e:	58 0c       	cp.w	r12,0
80008c40:	c1 50       	breq	80008c6a <_vfprintf_r+0x9de>
80008c42:	0d 89       	ld.ub	r9,r6[0x0]
80008c44:	33 08       	mov	r8,48
80008c46:	f0 09 18 00 	cp.b	r9,r8
80008c4a:	c0 b1       	brne	80008c60 <_vfprintf_r+0x9d4>
80008c4c:	30 08       	mov	r8,0
80008c4e:	30 09       	mov	r9,0
80008c50:	40 6b       	lddsp	r11,sp[0x18]
80008c52:	40 7a       	lddsp	r10,sp[0x1c]
80008c54:	e0 a0 1c d7 	rcall	8000c602 <__avr32_f64_cmp_eq>
80008c58:	fb b2 00 01 	rsubeq	r2,1
80008c5c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008c60:	40 3b       	lddsp	r11,sp[0xc]
80008c62:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c66:	10 0b       	add	r11,r8
80008c68:	50 3b       	stdsp	sp[0xc],r11
80008c6a:	40 6b       	lddsp	r11,sp[0x18]
80008c6c:	30 08       	mov	r8,0
80008c6e:	30 09       	mov	r9,0
80008c70:	40 7a       	lddsp	r10,sp[0x1c]
80008c72:	e0 a0 1c c8 	rcall	8000c602 <__avr32_f64_cmp_eq>
80008c76:	c0 90       	breq	80008c88 <_vfprintf_r+0x9fc>
80008c78:	40 3a       	lddsp	r10,sp[0xc]
80008c7a:	fb 4a 06 a4 	st.w	sp[1700],r10
80008c7e:	c0 58       	rjmp	80008c88 <_vfprintf_r+0x9fc>
80008c80:	10 c9       	st.b	r8++,r9
80008c82:	fb 48 06 a4 	st.w	sp[1700],r8
80008c86:	c0 28       	rjmp	80008c8a <_vfprintf_r+0x9fe>
80008c88:	33 09       	mov	r9,48
80008c8a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008c8e:	40 3e       	lddsp	lr,sp[0xc]
80008c90:	1c 38       	cp.w	r8,lr
80008c92:	cf 73       	brcs	80008c80 <_vfprintf_r+0x9f4>
80008c94:	e0 40 00 47 	cp.w	r0,71
80008c98:	5f 09       	sreq	r9
80008c9a:	e0 40 00 67 	cp.w	r0,103
80008c9e:	5f 08       	sreq	r8
80008ca0:	f3 e8 10 08 	or	r8,r9,r8
80008ca4:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008ca8:	0c 19       	sub	r9,r6
80008caa:	50 69       	stdsp	sp[0x18],r9
80008cac:	58 08       	cp.w	r8,0
80008cae:	c0 b0       	breq	80008cc4 <_vfprintf_r+0xa38>
80008cb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008cb4:	5b d8       	cp.w	r8,-3
80008cb6:	c0 55       	brlt	80008cc0 <_vfprintf_r+0xa34>
80008cb8:	40 2c       	lddsp	r12,sp[0x8]
80008cba:	18 38       	cp.w	r8,r12
80008cbc:	e0 8a 00 6a 	brle	80008d90 <_vfprintf_r+0xb04>
80008cc0:	20 20       	sub	r0,2
80008cc2:	c0 58       	rjmp	80008ccc <_vfprintf_r+0xa40>
80008cc4:	e0 40 00 65 	cp.w	r0,101
80008cc8:	e0 89 00 46 	brgt	80008d54 <_vfprintf_r+0xac8>
80008ccc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008cd0:	fb 60 06 9c 	st.b	sp[1692],r0
80008cd4:	20 1b       	sub	r11,1
80008cd6:	fb 4b 06 ac 	st.w	sp[1708],r11
80008cda:	c0 47       	brpl	80008ce2 <_vfprintf_r+0xa56>
80008cdc:	5c 3b       	neg	r11
80008cde:	32 d8       	mov	r8,45
80008ce0:	c0 28       	rjmp	80008ce4 <_vfprintf_r+0xa58>
80008ce2:	32 b8       	mov	r8,43
80008ce4:	fb 68 06 9d 	st.b	sp[1693],r8
80008ce8:	58 9b       	cp.w	r11,9
80008cea:	e0 8a 00 1d 	brle	80008d24 <_vfprintf_r+0xa98>
80008cee:	fa c9 fa 35 	sub	r9,sp,-1483
80008cf2:	30 aa       	mov	r10,10
80008cf4:	12 98       	mov	r8,r9
80008cf6:	0e 9c       	mov	r12,r7
80008cf8:	0c 92       	mov	r2,r6
80008cfa:	f6 0a 0c 06 	divs	r6,r11,r10
80008cfe:	0e 9b       	mov	r11,r7
80008d00:	2d 0b       	sub	r11,-48
80008d02:	10 fb       	st.b	--r8,r11
80008d04:	0c 9b       	mov	r11,r6
80008d06:	58 96       	cp.w	r6,9
80008d08:	fe 99 ff f9 	brgt	80008cfa <_vfprintf_r+0xa6e>
80008d0c:	2d 0b       	sub	r11,-48
80008d0e:	18 97       	mov	r7,r12
80008d10:	04 96       	mov	r6,r2
80008d12:	10 fb       	st.b	--r8,r11
80008d14:	fa ca f9 62 	sub	r10,sp,-1694
80008d18:	c0 38       	rjmp	80008d1e <_vfprintf_r+0xa92>
80008d1a:	11 3b       	ld.ub	r11,r8++
80008d1c:	14 cb       	st.b	r10++,r11
80008d1e:	12 38       	cp.w	r8,r9
80008d20:	cf d3       	brcs	80008d1a <_vfprintf_r+0xa8e>
80008d22:	c0 98       	rjmp	80008d34 <_vfprintf_r+0xaa8>
80008d24:	2d 0b       	sub	r11,-48
80008d26:	33 08       	mov	r8,48
80008d28:	fb 6b 06 9f 	st.b	sp[1695],r11
80008d2c:	fb 68 06 9e 	st.b	sp[1694],r8
80008d30:	fa ca f9 60 	sub	r10,sp,-1696
80008d34:	fa c8 f9 64 	sub	r8,sp,-1692
80008d38:	f4 08 01 08 	sub	r8,r10,r8
80008d3c:	50 e8       	stdsp	sp[0x38],r8
80008d3e:	10 92       	mov	r2,r8
80008d40:	40 6b       	lddsp	r11,sp[0x18]
80008d42:	16 02       	add	r2,r11
80008d44:	58 1b       	cp.w	r11,1
80008d46:	e0 89 00 05 	brgt	80008d50 <_vfprintf_r+0xac4>
80008d4a:	ed b5 00 00 	bld	r5,0x0
80008d4e:	c3 51       	brne	80008db8 <_vfprintf_r+0xb2c>
80008d50:	2f f2       	sub	r2,-1
80008d52:	c3 38       	rjmp	80008db8 <_vfprintf_r+0xb2c>
80008d54:	e0 40 00 66 	cp.w	r0,102
80008d58:	c1 c1       	brne	80008d90 <_vfprintf_r+0xb04>
80008d5a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d5e:	58 02       	cp.w	r2,0
80008d60:	e0 8a 00 0c 	brle	80008d78 <_vfprintf_r+0xaec>
80008d64:	40 2a       	lddsp	r10,sp[0x8]
80008d66:	58 0a       	cp.w	r10,0
80008d68:	c0 41       	brne	80008d70 <_vfprintf_r+0xae4>
80008d6a:	ed b5 00 00 	bld	r5,0x0
80008d6e:	c2 51       	brne	80008db8 <_vfprintf_r+0xb2c>
80008d70:	2f f2       	sub	r2,-1
80008d72:	40 29       	lddsp	r9,sp[0x8]
80008d74:	12 02       	add	r2,r9
80008d76:	c0 b8       	rjmp	80008d8c <_vfprintf_r+0xb00>
80008d78:	40 28       	lddsp	r8,sp[0x8]
80008d7a:	58 08       	cp.w	r8,0
80008d7c:	c0 61       	brne	80008d88 <_vfprintf_r+0xafc>
80008d7e:	ed b5 00 00 	bld	r5,0x0
80008d82:	c0 30       	breq	80008d88 <_vfprintf_r+0xafc>
80008d84:	30 12       	mov	r2,1
80008d86:	c1 98       	rjmp	80008db8 <_vfprintf_r+0xb2c>
80008d88:	40 22       	lddsp	r2,sp[0x8]
80008d8a:	2f e2       	sub	r2,-2
80008d8c:	36 60       	mov	r0,102
80008d8e:	c1 58       	rjmp	80008db8 <_vfprintf_r+0xb2c>
80008d90:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d94:	40 6e       	lddsp	lr,sp[0x18]
80008d96:	1c 32       	cp.w	r2,lr
80008d98:	c0 65       	brlt	80008da4 <_vfprintf_r+0xb18>
80008d9a:	ed b5 00 00 	bld	r5,0x0
80008d9e:	f7 b2 00 ff 	subeq	r2,-1
80008da2:	c0 a8       	rjmp	80008db6 <_vfprintf_r+0xb2a>
80008da4:	e4 08 11 02 	rsub	r8,r2,2
80008da8:	40 6c       	lddsp	r12,sp[0x18]
80008daa:	58 02       	cp.w	r2,0
80008dac:	f0 02 17 a0 	movle	r2,r8
80008db0:	f9 b2 09 01 	movgt	r2,1
80008db4:	18 02       	add	r2,r12
80008db6:	36 70       	mov	r0,103
80008db8:	40 9b       	lddsp	r11,sp[0x24]
80008dba:	58 0b       	cp.w	r11,0
80008dbc:	e0 80 05 94 	breq	800098e4 <_vfprintf_r+0x1658>
80008dc0:	32 d8       	mov	r8,45
80008dc2:	fb 68 06 bb 	st.b	sp[1723],r8
80008dc6:	e0 8f 05 93 	bral	800098ec <_vfprintf_r+0x1660>
80008dca:	50 a7       	stdsp	sp[0x28],r7
80008dcc:	04 94       	mov	r4,r2
80008dce:	0c 97       	mov	r7,r6
80008dd0:	02 92       	mov	r2,r1
80008dd2:	06 96       	mov	r6,r3
80008dd4:	40 41       	lddsp	r1,sp[0x10]
80008dd6:	40 93       	lddsp	r3,sp[0x24]
80008dd8:	0e 99       	mov	r9,r7
80008dda:	ed b5 00 05 	bld	r5,0x5
80008dde:	c4 81       	brne	80008e6e <_vfprintf_r+0xbe2>
80008de0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008de4:	40 3e       	lddsp	lr,sp[0xc]
80008de6:	58 0e       	cp.w	lr,0
80008de8:	c1 d0       	breq	80008e22 <_vfprintf_r+0xb96>
80008dea:	10 36       	cp.w	r6,r8
80008dec:	c0 64       	brge	80008df8 <_vfprintf_r+0xb6c>
80008dee:	fa cc f9 44 	sub	r12,sp,-1724
80008df2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008df6:	c1 d8       	rjmp	80008e30 <_vfprintf_r+0xba4>
80008df8:	fa c8 f9 50 	sub	r8,sp,-1712
80008dfc:	1a d8       	st.w	--sp,r8
80008dfe:	fa c8 fa b8 	sub	r8,sp,-1352
80008e02:	04 9a       	mov	r10,r2
80008e04:	1a d8       	st.w	--sp,r8
80008e06:	fa c8 fb b4 	sub	r8,sp,-1100
80008e0a:	0c 9b       	mov	r11,r6
80008e0c:	1a d8       	st.w	--sp,r8
80008e0e:	08 9c       	mov	r12,r4
80008e10:	fa c8 f9 40 	sub	r8,sp,-1728
80008e14:	fa c9 ff b4 	sub	r9,sp,-76
80008e18:	fe b0 f8 a2 	rcall	80007f5c <get_arg>
80008e1c:	2f dd       	sub	sp,-12
80008e1e:	78 0a       	ld.w	r10,r12[0x0]
80008e20:	c2 08       	rjmp	80008e60 <_vfprintf_r+0xbd4>
80008e22:	2f f7       	sub	r7,-1
80008e24:	10 39       	cp.w	r9,r8
80008e26:	c0 84       	brge	80008e36 <_vfprintf_r+0xbaa>
80008e28:	fa cb f9 44 	sub	r11,sp,-1724
80008e2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e30:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e34:	c1 68       	rjmp	80008e60 <_vfprintf_r+0xbd4>
80008e36:	41 09       	lddsp	r9,sp[0x40]
80008e38:	59 f8       	cp.w	r8,31
80008e3a:	e0 89 00 10 	brgt	80008e5a <_vfprintf_r+0xbce>
80008e3e:	f2 ca ff fc 	sub	r10,r9,-4
80008e42:	51 0a       	stdsp	sp[0x40],r10
80008e44:	fa c6 f9 44 	sub	r6,sp,-1724
80008e48:	72 0a       	ld.w	r10,r9[0x0]
80008e4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e4e:	f3 4a fd 88 	st.w	r9[-632],r10
80008e52:	2f f8       	sub	r8,-1
80008e54:	fb 48 06 b4 	st.w	sp[1716],r8
80008e58:	c0 48       	rjmp	80008e60 <_vfprintf_r+0xbd4>
80008e5a:	72 0a       	ld.w	r10,r9[0x0]
80008e5c:	2f c9       	sub	r9,-4
80008e5e:	51 09       	stdsp	sp[0x40],r9
80008e60:	40 be       	lddsp	lr,sp[0x2c]
80008e62:	1c 98       	mov	r8,lr
80008e64:	95 1e       	st.w	r10[0x4],lr
80008e66:	bf 58       	asr	r8,0x1f
80008e68:	95 08       	st.w	r10[0x0],r8
80008e6a:	fe 9f fa 9f 	bral	800083a8 <_vfprintf_r+0x11c>
80008e6e:	ed b5 00 04 	bld	r5,0x4
80008e72:	c4 80       	breq	80008f02 <_vfprintf_r+0xc76>
80008e74:	e2 15 00 40 	andl	r5,0x40,COH
80008e78:	c4 50       	breq	80008f02 <_vfprintf_r+0xc76>
80008e7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e7e:	40 3c       	lddsp	r12,sp[0xc]
80008e80:	58 0c       	cp.w	r12,0
80008e82:	c1 d0       	breq	80008ebc <_vfprintf_r+0xc30>
80008e84:	10 36       	cp.w	r6,r8
80008e86:	c0 64       	brge	80008e92 <_vfprintf_r+0xc06>
80008e88:	fa cb f9 44 	sub	r11,sp,-1724
80008e8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e90:	c1 d8       	rjmp	80008eca <_vfprintf_r+0xc3e>
80008e92:	fa c8 f9 50 	sub	r8,sp,-1712
80008e96:	1a d8       	st.w	--sp,r8
80008e98:	fa c8 fa b8 	sub	r8,sp,-1352
80008e9c:	04 9a       	mov	r10,r2
80008e9e:	1a d8       	st.w	--sp,r8
80008ea0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ea4:	0c 9b       	mov	r11,r6
80008ea6:	1a d8       	st.w	--sp,r8
80008ea8:	08 9c       	mov	r12,r4
80008eaa:	fa c8 f9 40 	sub	r8,sp,-1728
80008eae:	fa c9 ff b4 	sub	r9,sp,-76
80008eb2:	fe b0 f8 55 	rcall	80007f5c <get_arg>
80008eb6:	2f dd       	sub	sp,-12
80008eb8:	78 0a       	ld.w	r10,r12[0x0]
80008eba:	c2 08       	rjmp	80008efa <_vfprintf_r+0xc6e>
80008ebc:	2f f7       	sub	r7,-1
80008ebe:	10 39       	cp.w	r9,r8
80008ec0:	c0 84       	brge	80008ed0 <_vfprintf_r+0xc44>
80008ec2:	fa ca f9 44 	sub	r10,sp,-1724
80008ec6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008eca:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ece:	c1 68       	rjmp	80008efa <_vfprintf_r+0xc6e>
80008ed0:	41 09       	lddsp	r9,sp[0x40]
80008ed2:	59 f8       	cp.w	r8,31
80008ed4:	e0 89 00 10 	brgt	80008ef4 <_vfprintf_r+0xc68>
80008ed8:	f2 ca ff fc 	sub	r10,r9,-4
80008edc:	51 0a       	stdsp	sp[0x40],r10
80008ede:	fa c6 f9 44 	sub	r6,sp,-1724
80008ee2:	72 0a       	ld.w	r10,r9[0x0]
80008ee4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ee8:	f3 4a fd 88 	st.w	r9[-632],r10
80008eec:	2f f8       	sub	r8,-1
80008eee:	fb 48 06 b4 	st.w	sp[1716],r8
80008ef2:	c0 48       	rjmp	80008efa <_vfprintf_r+0xc6e>
80008ef4:	72 0a       	ld.w	r10,r9[0x0]
80008ef6:	2f c9       	sub	r9,-4
80008ef8:	51 09       	stdsp	sp[0x40],r9
80008efa:	40 be       	lddsp	lr,sp[0x2c]
80008efc:	b4 0e       	st.h	r10[0x0],lr
80008efe:	fe 9f fa 55 	bral	800083a8 <_vfprintf_r+0x11c>
80008f02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f06:	40 3c       	lddsp	r12,sp[0xc]
80008f08:	58 0c       	cp.w	r12,0
80008f0a:	c1 d0       	breq	80008f44 <_vfprintf_r+0xcb8>
80008f0c:	10 36       	cp.w	r6,r8
80008f0e:	c0 64       	brge	80008f1a <_vfprintf_r+0xc8e>
80008f10:	fa cb f9 44 	sub	r11,sp,-1724
80008f14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f18:	c1 d8       	rjmp	80008f52 <_vfprintf_r+0xcc6>
80008f1a:	fa c8 f9 50 	sub	r8,sp,-1712
80008f1e:	1a d8       	st.w	--sp,r8
80008f20:	fa c8 fa b8 	sub	r8,sp,-1352
80008f24:	04 9a       	mov	r10,r2
80008f26:	1a d8       	st.w	--sp,r8
80008f28:	fa c8 fb b4 	sub	r8,sp,-1100
80008f2c:	0c 9b       	mov	r11,r6
80008f2e:	1a d8       	st.w	--sp,r8
80008f30:	08 9c       	mov	r12,r4
80008f32:	fa c8 f9 40 	sub	r8,sp,-1728
80008f36:	fa c9 ff b4 	sub	r9,sp,-76
80008f3a:	fe b0 f8 11 	rcall	80007f5c <get_arg>
80008f3e:	2f dd       	sub	sp,-12
80008f40:	78 0a       	ld.w	r10,r12[0x0]
80008f42:	c2 08       	rjmp	80008f82 <_vfprintf_r+0xcf6>
80008f44:	2f f7       	sub	r7,-1
80008f46:	10 39       	cp.w	r9,r8
80008f48:	c0 84       	brge	80008f58 <_vfprintf_r+0xccc>
80008f4a:	fa ca f9 44 	sub	r10,sp,-1724
80008f4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f52:	ec fa fd 88 	ld.w	r10,r6[-632]
80008f56:	c1 68       	rjmp	80008f82 <_vfprintf_r+0xcf6>
80008f58:	41 09       	lddsp	r9,sp[0x40]
80008f5a:	59 f8       	cp.w	r8,31
80008f5c:	e0 89 00 10 	brgt	80008f7c <_vfprintf_r+0xcf0>
80008f60:	f2 ca ff fc 	sub	r10,r9,-4
80008f64:	51 0a       	stdsp	sp[0x40],r10
80008f66:	fa c6 f9 44 	sub	r6,sp,-1724
80008f6a:	72 0a       	ld.w	r10,r9[0x0]
80008f6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f70:	f3 4a fd 88 	st.w	r9[-632],r10
80008f74:	2f f8       	sub	r8,-1
80008f76:	fb 48 06 b4 	st.w	sp[1716],r8
80008f7a:	c0 48       	rjmp	80008f82 <_vfprintf_r+0xcf6>
80008f7c:	72 0a       	ld.w	r10,r9[0x0]
80008f7e:	2f c9       	sub	r9,-4
80008f80:	51 09       	stdsp	sp[0x40],r9
80008f82:	40 be       	lddsp	lr,sp[0x2c]
80008f84:	95 0e       	st.w	r10[0x0],lr
80008f86:	fe 9f fa 11 	bral	800083a8 <_vfprintf_r+0x11c>
80008f8a:	50 a7       	stdsp	sp[0x28],r7
80008f8c:	50 80       	stdsp	sp[0x20],r0
80008f8e:	0c 97       	mov	r7,r6
80008f90:	04 94       	mov	r4,r2
80008f92:	06 96       	mov	r6,r3
80008f94:	02 92       	mov	r2,r1
80008f96:	40 93       	lddsp	r3,sp[0x24]
80008f98:	10 90       	mov	r0,r8
80008f9a:	40 41       	lddsp	r1,sp[0x10]
80008f9c:	a5 a5       	sbr	r5,0x4
80008f9e:	c0 a8       	rjmp	80008fb2 <_vfprintf_r+0xd26>
80008fa0:	50 a7       	stdsp	sp[0x28],r7
80008fa2:	50 80       	stdsp	sp[0x20],r0
80008fa4:	0c 97       	mov	r7,r6
80008fa6:	04 94       	mov	r4,r2
80008fa8:	06 96       	mov	r6,r3
80008faa:	02 92       	mov	r2,r1
80008fac:	40 93       	lddsp	r3,sp[0x24]
80008fae:	10 90       	mov	r0,r8
80008fb0:	40 41       	lddsp	r1,sp[0x10]
80008fb2:	ed b5 00 05 	bld	r5,0x5
80008fb6:	c5 d1       	brne	80009070 <_vfprintf_r+0xde4>
80008fb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fbc:	40 3c       	lddsp	r12,sp[0xc]
80008fbe:	58 0c       	cp.w	r12,0
80008fc0:	c2 60       	breq	8000900c <_vfprintf_r+0xd80>
80008fc2:	10 36       	cp.w	r6,r8
80008fc4:	c0 a4       	brge	80008fd8 <_vfprintf_r+0xd4c>
80008fc6:	fa cb f9 44 	sub	r11,sp,-1724
80008fca:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fce:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008fd2:	fa e9 00 00 	st.d	sp[0],r8
80008fd6:	c1 88       	rjmp	80009006 <_vfprintf_r+0xd7a>
80008fd8:	fa c8 f9 50 	sub	r8,sp,-1712
80008fdc:	1a d8       	st.w	--sp,r8
80008fde:	fa c8 fa b8 	sub	r8,sp,-1352
80008fe2:	04 9a       	mov	r10,r2
80008fe4:	1a d8       	st.w	--sp,r8
80008fe6:	0c 9b       	mov	r11,r6
80008fe8:	fa c8 fb b4 	sub	r8,sp,-1100
80008fec:	08 9c       	mov	r12,r4
80008fee:	1a d8       	st.w	--sp,r8
80008ff0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ff4:	fa c9 ff b4 	sub	r9,sp,-76
80008ff8:	fe b0 f7 b2 	rcall	80007f5c <get_arg>
80008ffc:	2f dd       	sub	sp,-12
80008ffe:	f8 ea 00 00 	ld.d	r10,r12[0]
80009002:	fa eb 00 00 	st.d	sp[0],r10
80009006:	30 08       	mov	r8,0
80009008:	e0 8f 03 de 	bral	800097c4 <_vfprintf_r+0x1538>
8000900c:	ee ca ff ff 	sub	r10,r7,-1
80009010:	10 37       	cp.w	r7,r8
80009012:	c0 b4       	brge	80009028 <_vfprintf_r+0xd9c>
80009014:	fa c9 f9 44 	sub	r9,sp,-1724
80009018:	14 97       	mov	r7,r10
8000901a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000901e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009022:	fa eb 00 00 	st.d	sp[0],r10
80009026:	c1 88       	rjmp	80009056 <_vfprintf_r+0xdca>
80009028:	41 09       	lddsp	r9,sp[0x40]
8000902a:	59 f8       	cp.w	r8,31
8000902c:	e0 89 00 18 	brgt	8000905c <_vfprintf_r+0xdd0>
80009030:	f2 e6 00 00 	ld.d	r6,r9[0]
80009034:	f2 cb ff f8 	sub	r11,r9,-8
80009038:	fa e7 00 00 	st.d	sp[0],r6
8000903c:	51 0b       	stdsp	sp[0x40],r11
8000903e:	fa c6 f9 44 	sub	r6,sp,-1724
80009042:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009046:	fa e6 00 00 	ld.d	r6,sp[0]
8000904a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000904e:	2f f8       	sub	r8,-1
80009050:	14 97       	mov	r7,r10
80009052:	fb 48 06 b4 	st.w	sp[1716],r8
80009056:	40 38       	lddsp	r8,sp[0xc]
80009058:	e0 8f 03 b6 	bral	800097c4 <_vfprintf_r+0x1538>
8000905c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009060:	40 38       	lddsp	r8,sp[0xc]
80009062:	fa e7 00 00 	st.d	sp[0],r6
80009066:	2f 89       	sub	r9,-8
80009068:	14 97       	mov	r7,r10
8000906a:	51 09       	stdsp	sp[0x40],r9
8000906c:	e0 8f 03 ac 	bral	800097c4 <_vfprintf_r+0x1538>
80009070:	ed b5 00 04 	bld	r5,0x4
80009074:	c1 61       	brne	800090a0 <_vfprintf_r+0xe14>
80009076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000907a:	40 3e       	lddsp	lr,sp[0xc]
8000907c:	58 0e       	cp.w	lr,0
8000907e:	c0 80       	breq	8000908e <_vfprintf_r+0xe02>
80009080:	10 36       	cp.w	r6,r8
80009082:	c6 74       	brge	80009150 <_vfprintf_r+0xec4>
80009084:	fa cc f9 44 	sub	r12,sp,-1724
80009088:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000908c:	c8 08       	rjmp	8000918c <_vfprintf_r+0xf00>
8000908e:	ee ca ff ff 	sub	r10,r7,-1
80009092:	10 37       	cp.w	r7,r8
80009094:	c7 f4       	brge	80009192 <_vfprintf_r+0xf06>
80009096:	fa cb f9 44 	sub	r11,sp,-1724
8000909a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000909e:	c7 68       	rjmp	8000918a <_vfprintf_r+0xefe>
800090a0:	ed b5 00 06 	bld	r5,0x6
800090a4:	c4 a1       	brne	80009138 <_vfprintf_r+0xeac>
800090a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090aa:	40 3c       	lddsp	r12,sp[0xc]
800090ac:	58 0c       	cp.w	r12,0
800090ae:	c1 d0       	breq	800090e8 <_vfprintf_r+0xe5c>
800090b0:	10 36       	cp.w	r6,r8
800090b2:	c0 64       	brge	800090be <_vfprintf_r+0xe32>
800090b4:	fa cb f9 44 	sub	r11,sp,-1724
800090b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090bc:	c1 f8       	rjmp	800090fa <_vfprintf_r+0xe6e>
800090be:	fa c8 f9 50 	sub	r8,sp,-1712
800090c2:	1a d8       	st.w	--sp,r8
800090c4:	fa c8 fa b8 	sub	r8,sp,-1352
800090c8:	1a d8       	st.w	--sp,r8
800090ca:	fa c8 fb b4 	sub	r8,sp,-1100
800090ce:	1a d8       	st.w	--sp,r8
800090d0:	fa c8 f9 40 	sub	r8,sp,-1728
800090d4:	fa c9 ff b4 	sub	r9,sp,-76
800090d8:	04 9a       	mov	r10,r2
800090da:	0c 9b       	mov	r11,r6
800090dc:	08 9c       	mov	r12,r4
800090de:	fe b0 f7 3f 	rcall	80007f5c <get_arg>
800090e2:	2f dd       	sub	sp,-12
800090e4:	98 18       	ld.sh	r8,r12[0x2]
800090e6:	c2 68       	rjmp	80009132 <_vfprintf_r+0xea6>
800090e8:	ee ca ff ff 	sub	r10,r7,-1
800090ec:	10 37       	cp.w	r7,r8
800090ee:	c0 94       	brge	80009100 <_vfprintf_r+0xe74>
800090f0:	fa c9 f9 44 	sub	r9,sp,-1724
800090f4:	14 97       	mov	r7,r10
800090f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800090fe:	c1 a8       	rjmp	80009132 <_vfprintf_r+0xea6>
80009100:	41 09       	lddsp	r9,sp[0x40]
80009102:	59 f8       	cp.w	r8,31
80009104:	e0 89 00 13 	brgt	8000912a <_vfprintf_r+0xe9e>
80009108:	f2 cb ff fc 	sub	r11,r9,-4
8000910c:	51 0b       	stdsp	sp[0x40],r11
8000910e:	72 09       	ld.w	r9,r9[0x0]
80009110:	fa c6 f9 44 	sub	r6,sp,-1724
80009114:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009118:	2f f8       	sub	r8,-1
8000911a:	f7 49 fd 88 	st.w	r11[-632],r9
8000911e:	fb 48 06 b4 	st.w	sp[1716],r8
80009122:	14 97       	mov	r7,r10
80009124:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009128:	c0 58       	rjmp	80009132 <_vfprintf_r+0xea6>
8000912a:	92 18       	ld.sh	r8,r9[0x2]
8000912c:	14 97       	mov	r7,r10
8000912e:	2f c9       	sub	r9,-4
80009130:	51 09       	stdsp	sp[0x40],r9
80009132:	5c 78       	castu.h	r8
80009134:	50 18       	stdsp	sp[0x4],r8
80009136:	c4 68       	rjmp	800091c2 <_vfprintf_r+0xf36>
80009138:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000913c:	40 3c       	lddsp	r12,sp[0xc]
8000913e:	58 0c       	cp.w	r12,0
80009140:	c1 d0       	breq	8000917a <_vfprintf_r+0xeee>
80009142:	10 36       	cp.w	r6,r8
80009144:	c0 64       	brge	80009150 <_vfprintf_r+0xec4>
80009146:	fa cb f9 44 	sub	r11,sp,-1724
8000914a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000914e:	c1 f8       	rjmp	8000918c <_vfprintf_r+0xf00>
80009150:	fa c8 f9 50 	sub	r8,sp,-1712
80009154:	1a d8       	st.w	--sp,r8
80009156:	fa c8 fa b8 	sub	r8,sp,-1352
8000915a:	0c 9b       	mov	r11,r6
8000915c:	1a d8       	st.w	--sp,r8
8000915e:	fa c8 fb b4 	sub	r8,sp,-1100
80009162:	04 9a       	mov	r10,r2
80009164:	1a d8       	st.w	--sp,r8
80009166:	08 9c       	mov	r12,r4
80009168:	fa c8 f9 40 	sub	r8,sp,-1728
8000916c:	fa c9 ff b4 	sub	r9,sp,-76
80009170:	fe b0 f6 f6 	rcall	80007f5c <get_arg>
80009174:	2f dd       	sub	sp,-12
80009176:	78 0b       	ld.w	r11,r12[0x0]
80009178:	c2 48       	rjmp	800091c0 <_vfprintf_r+0xf34>
8000917a:	ee ca ff ff 	sub	r10,r7,-1
8000917e:	10 37       	cp.w	r7,r8
80009180:	c0 94       	brge	80009192 <_vfprintf_r+0xf06>
80009182:	fa c9 f9 44 	sub	r9,sp,-1724
80009186:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000918a:	14 97       	mov	r7,r10
8000918c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009190:	c1 88       	rjmp	800091c0 <_vfprintf_r+0xf34>
80009192:	41 09       	lddsp	r9,sp[0x40]
80009194:	59 f8       	cp.w	r8,31
80009196:	e0 89 00 11 	brgt	800091b8 <_vfprintf_r+0xf2c>
8000919a:	f2 cb ff fc 	sub	r11,r9,-4
8000919e:	51 0b       	stdsp	sp[0x40],r11
800091a0:	fa c6 f9 44 	sub	r6,sp,-1724
800091a4:	72 0b       	ld.w	r11,r9[0x0]
800091a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091aa:	f3 4b fd 88 	st.w	r9[-632],r11
800091ae:	2f f8       	sub	r8,-1
800091b0:	14 97       	mov	r7,r10
800091b2:	fb 48 06 b4 	st.w	sp[1716],r8
800091b6:	c0 58       	rjmp	800091c0 <_vfprintf_r+0xf34>
800091b8:	72 0b       	ld.w	r11,r9[0x0]
800091ba:	14 97       	mov	r7,r10
800091bc:	2f c9       	sub	r9,-4
800091be:	51 09       	stdsp	sp[0x40],r9
800091c0:	50 1b       	stdsp	sp[0x4],r11
800091c2:	30 0e       	mov	lr,0
800091c4:	50 0e       	stdsp	sp[0x0],lr
800091c6:	1c 98       	mov	r8,lr
800091c8:	e0 8f 02 fe 	bral	800097c4 <_vfprintf_r+0x1538>
800091cc:	50 a7       	stdsp	sp[0x28],r7
800091ce:	50 80       	stdsp	sp[0x20],r0
800091d0:	0c 97       	mov	r7,r6
800091d2:	04 94       	mov	r4,r2
800091d4:	06 96       	mov	r6,r3
800091d6:	02 92       	mov	r2,r1
800091d8:	40 93       	lddsp	r3,sp[0x24]
800091da:	40 41       	lddsp	r1,sp[0x10]
800091dc:	0e 99       	mov	r9,r7
800091de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091e2:	40 3c       	lddsp	r12,sp[0xc]
800091e4:	58 0c       	cp.w	r12,0
800091e6:	c1 d0       	breq	80009220 <_vfprintf_r+0xf94>
800091e8:	10 36       	cp.w	r6,r8
800091ea:	c0 64       	brge	800091f6 <_vfprintf_r+0xf6a>
800091ec:	fa cb f9 44 	sub	r11,sp,-1724
800091f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091f4:	c1 d8       	rjmp	8000922e <_vfprintf_r+0xfa2>
800091f6:	fa c8 f9 50 	sub	r8,sp,-1712
800091fa:	1a d8       	st.w	--sp,r8
800091fc:	fa c8 fa b8 	sub	r8,sp,-1352
80009200:	1a d8       	st.w	--sp,r8
80009202:	fa c8 fb b4 	sub	r8,sp,-1100
80009206:	1a d8       	st.w	--sp,r8
80009208:	fa c9 ff b4 	sub	r9,sp,-76
8000920c:	fa c8 f9 40 	sub	r8,sp,-1728
80009210:	04 9a       	mov	r10,r2
80009212:	0c 9b       	mov	r11,r6
80009214:	08 9c       	mov	r12,r4
80009216:	fe b0 f6 a3 	rcall	80007f5c <get_arg>
8000921a:	2f dd       	sub	sp,-12
8000921c:	78 09       	ld.w	r9,r12[0x0]
8000921e:	c2 18       	rjmp	80009260 <_vfprintf_r+0xfd4>
80009220:	2f f7       	sub	r7,-1
80009222:	10 39       	cp.w	r9,r8
80009224:	c0 84       	brge	80009234 <_vfprintf_r+0xfa8>
80009226:	fa ca f9 44 	sub	r10,sp,-1724
8000922a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000922e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009232:	c1 78       	rjmp	80009260 <_vfprintf_r+0xfd4>
80009234:	41 09       	lddsp	r9,sp[0x40]
80009236:	59 f8       	cp.w	r8,31
80009238:	e0 89 00 10 	brgt	80009258 <_vfprintf_r+0xfcc>
8000923c:	f2 ca ff fc 	sub	r10,r9,-4
80009240:	51 0a       	stdsp	sp[0x40],r10
80009242:	fa c6 f9 44 	sub	r6,sp,-1724
80009246:	72 09       	ld.w	r9,r9[0x0]
80009248:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000924c:	f5 49 fd 88 	st.w	r10[-632],r9
80009250:	2f f8       	sub	r8,-1
80009252:	fb 48 06 b4 	st.w	sp[1716],r8
80009256:	c0 58       	rjmp	80009260 <_vfprintf_r+0xfd4>
80009258:	f2 c8 ff fc 	sub	r8,r9,-4
8000925c:	51 08       	stdsp	sp[0x40],r8
8000925e:	72 09       	ld.w	r9,r9[0x0]
80009260:	33 08       	mov	r8,48
80009262:	fb 68 06 b8 	st.b	sp[1720],r8
80009266:	37 88       	mov	r8,120
80009268:	30 0e       	mov	lr,0
8000926a:	fb 68 06 b9 	st.b	sp[1721],r8
8000926e:	fe cc b1 26 	sub	r12,pc,-20186
80009272:	50 19       	stdsp	sp[0x4],r9
80009274:	a1 b5       	sbr	r5,0x1
80009276:	50 0e       	stdsp	sp[0x0],lr
80009278:	50 dc       	stdsp	sp[0x34],r12
8000927a:	30 28       	mov	r8,2
8000927c:	37 80       	mov	r0,120
8000927e:	e0 8f 02 a3 	bral	800097c4 <_vfprintf_r+0x1538>
80009282:	50 a7       	stdsp	sp[0x28],r7
80009284:	50 80       	stdsp	sp[0x20],r0
80009286:	10 90       	mov	r0,r8
80009288:	30 08       	mov	r8,0
8000928a:	fb 68 06 bb 	st.b	sp[1723],r8
8000928e:	0c 97       	mov	r7,r6
80009290:	04 94       	mov	r4,r2
80009292:	06 96       	mov	r6,r3
80009294:	02 92       	mov	r2,r1
80009296:	40 93       	lddsp	r3,sp[0x24]
80009298:	40 41       	lddsp	r1,sp[0x10]
8000929a:	0e 99       	mov	r9,r7
8000929c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092a0:	40 3b       	lddsp	r11,sp[0xc]
800092a2:	58 0b       	cp.w	r11,0
800092a4:	c1 d0       	breq	800092de <_vfprintf_r+0x1052>
800092a6:	10 36       	cp.w	r6,r8
800092a8:	c0 64       	brge	800092b4 <_vfprintf_r+0x1028>
800092aa:	fa ca f9 44 	sub	r10,sp,-1724
800092ae:	f4 06 00 36 	add	r6,r10,r6<<0x3
800092b2:	c1 d8       	rjmp	800092ec <_vfprintf_r+0x1060>
800092b4:	fa c8 f9 50 	sub	r8,sp,-1712
800092b8:	1a d8       	st.w	--sp,r8
800092ba:	fa c8 fa b8 	sub	r8,sp,-1352
800092be:	1a d8       	st.w	--sp,r8
800092c0:	fa c8 fb b4 	sub	r8,sp,-1100
800092c4:	0c 9b       	mov	r11,r6
800092c6:	1a d8       	st.w	--sp,r8
800092c8:	04 9a       	mov	r10,r2
800092ca:	fa c8 f9 40 	sub	r8,sp,-1728
800092ce:	fa c9 ff b4 	sub	r9,sp,-76
800092d2:	08 9c       	mov	r12,r4
800092d4:	fe b0 f6 44 	rcall	80007f5c <get_arg>
800092d8:	2f dd       	sub	sp,-12
800092da:	78 06       	ld.w	r6,r12[0x0]
800092dc:	c2 08       	rjmp	8000931c <_vfprintf_r+0x1090>
800092de:	2f f7       	sub	r7,-1
800092e0:	10 39       	cp.w	r9,r8
800092e2:	c0 84       	brge	800092f2 <_vfprintf_r+0x1066>
800092e4:	fa c9 f9 44 	sub	r9,sp,-1724
800092e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092ec:	ec f6 fd 88 	ld.w	r6,r6[-632]
800092f0:	c1 68       	rjmp	8000931c <_vfprintf_r+0x1090>
800092f2:	41 09       	lddsp	r9,sp[0x40]
800092f4:	59 f8       	cp.w	r8,31
800092f6:	e0 89 00 10 	brgt	80009316 <_vfprintf_r+0x108a>
800092fa:	f2 ca ff fc 	sub	r10,r9,-4
800092fe:	51 0a       	stdsp	sp[0x40],r10
80009300:	72 06       	ld.w	r6,r9[0x0]
80009302:	fa ce f9 44 	sub	lr,sp,-1724
80009306:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000930a:	f3 46 fd 88 	st.w	r9[-632],r6
8000930e:	2f f8       	sub	r8,-1
80009310:	fb 48 06 b4 	st.w	sp[1716],r8
80009314:	c0 48       	rjmp	8000931c <_vfprintf_r+0x1090>
80009316:	72 06       	ld.w	r6,r9[0x0]
80009318:	2f c9       	sub	r9,-4
8000931a:	51 09       	stdsp	sp[0x40],r9
8000931c:	40 2c       	lddsp	r12,sp[0x8]
8000931e:	58 0c       	cp.w	r12,0
80009320:	c1 05       	brlt	80009340 <_vfprintf_r+0x10b4>
80009322:	18 9a       	mov	r10,r12
80009324:	30 0b       	mov	r11,0
80009326:	0c 9c       	mov	r12,r6
80009328:	e0 a0 12 38 	rcall	8000b798 <memchr>
8000932c:	e0 80 02 df 	breq	800098ea <_vfprintf_r+0x165e>
80009330:	f8 06 01 02 	sub	r2,r12,r6
80009334:	40 2b       	lddsp	r11,sp[0x8]
80009336:	16 32       	cp.w	r2,r11
80009338:	e0 89 02 d9 	brgt	800098ea <_vfprintf_r+0x165e>
8000933c:	e0 8f 02 d4 	bral	800098e4 <_vfprintf_r+0x1658>
80009340:	30 0a       	mov	r10,0
80009342:	0c 9c       	mov	r12,r6
80009344:	50 2a       	stdsp	sp[0x8],r10
80009346:	e0 a0 15 99 	rcall	8000be78 <strlen>
8000934a:	18 92       	mov	r2,r12
8000934c:	e0 8f 02 d2 	bral	800098f0 <_vfprintf_r+0x1664>
80009350:	50 a7       	stdsp	sp[0x28],r7
80009352:	50 80       	stdsp	sp[0x20],r0
80009354:	0c 97       	mov	r7,r6
80009356:	04 94       	mov	r4,r2
80009358:	06 96       	mov	r6,r3
8000935a:	02 92       	mov	r2,r1
8000935c:	40 93       	lddsp	r3,sp[0x24]
8000935e:	10 90       	mov	r0,r8
80009360:	40 41       	lddsp	r1,sp[0x10]
80009362:	a5 a5       	sbr	r5,0x4
80009364:	c0 a8       	rjmp	80009378 <_vfprintf_r+0x10ec>
80009366:	50 a7       	stdsp	sp[0x28],r7
80009368:	50 80       	stdsp	sp[0x20],r0
8000936a:	0c 97       	mov	r7,r6
8000936c:	04 94       	mov	r4,r2
8000936e:	06 96       	mov	r6,r3
80009370:	02 92       	mov	r2,r1
80009372:	40 93       	lddsp	r3,sp[0x24]
80009374:	10 90       	mov	r0,r8
80009376:	40 41       	lddsp	r1,sp[0x10]
80009378:	ed b5 00 05 	bld	r5,0x5
8000937c:	c5 61       	brne	80009428 <_vfprintf_r+0x119c>
8000937e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009382:	40 39       	lddsp	r9,sp[0xc]
80009384:	58 09       	cp.w	r9,0
80009386:	c2 10       	breq	800093c8 <_vfprintf_r+0x113c>
80009388:	10 36       	cp.w	r6,r8
8000938a:	c0 74       	brge	80009398 <_vfprintf_r+0x110c>
8000938c:	fa c8 f9 44 	sub	r8,sp,-1724
80009390:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009394:	c2 38       	rjmp	800093da <_vfprintf_r+0x114e>
80009396:	d7 03       	nop
80009398:	fa c8 f9 50 	sub	r8,sp,-1712
8000939c:	1a d8       	st.w	--sp,r8
8000939e:	fa c8 fa b8 	sub	r8,sp,-1352
800093a2:	1a d8       	st.w	--sp,r8
800093a4:	fa c8 fb b4 	sub	r8,sp,-1100
800093a8:	1a d8       	st.w	--sp,r8
800093aa:	fa c8 f9 40 	sub	r8,sp,-1728
800093ae:	fa c9 ff b4 	sub	r9,sp,-76
800093b2:	04 9a       	mov	r10,r2
800093b4:	0c 9b       	mov	r11,r6
800093b6:	08 9c       	mov	r12,r4
800093b8:	fe b0 f5 d2 	rcall	80007f5c <get_arg>
800093bc:	2f dd       	sub	sp,-12
800093be:	f8 e8 00 00 	ld.d	r8,r12[0]
800093c2:	fa e9 00 00 	st.d	sp[0],r8
800093c6:	c2 e8       	rjmp	80009422 <_vfprintf_r+0x1196>
800093c8:	ee ca ff ff 	sub	r10,r7,-1
800093cc:	10 37       	cp.w	r7,r8
800093ce:	c0 b4       	brge	800093e4 <_vfprintf_r+0x1158>
800093d0:	fa c8 f9 44 	sub	r8,sp,-1724
800093d4:	14 97       	mov	r7,r10
800093d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800093da:	ec ea fd 88 	ld.d	r10,r6[-632]
800093de:	fa eb 00 00 	st.d	sp[0],r10
800093e2:	c2 08       	rjmp	80009422 <_vfprintf_r+0x1196>
800093e4:	41 09       	lddsp	r9,sp[0x40]
800093e6:	59 f8       	cp.w	r8,31
800093e8:	e0 89 00 16 	brgt	80009414 <_vfprintf_r+0x1188>
800093ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800093f0:	f2 cb ff f8 	sub	r11,r9,-8
800093f4:	fa e7 00 00 	st.d	sp[0],r6
800093f8:	51 0b       	stdsp	sp[0x40],r11
800093fa:	fa c6 f9 44 	sub	r6,sp,-1724
800093fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009402:	fa e6 00 00 	ld.d	r6,sp[0]
80009406:	f2 e7 fd 88 	st.d	r9[-632],r6
8000940a:	2f f8       	sub	r8,-1
8000940c:	14 97       	mov	r7,r10
8000940e:	fb 48 06 b4 	st.w	sp[1716],r8
80009412:	c0 88       	rjmp	80009422 <_vfprintf_r+0x1196>
80009414:	f2 e6 00 00 	ld.d	r6,r9[0]
80009418:	2f 89       	sub	r9,-8
8000941a:	fa e7 00 00 	st.d	sp[0],r6
8000941e:	51 09       	stdsp	sp[0x40],r9
80009420:	14 97       	mov	r7,r10
80009422:	30 18       	mov	r8,1
80009424:	e0 8f 01 d0 	bral	800097c4 <_vfprintf_r+0x1538>
80009428:	ed b5 00 04 	bld	r5,0x4
8000942c:	c1 61       	brne	80009458 <_vfprintf_r+0x11cc>
8000942e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009432:	40 3e       	lddsp	lr,sp[0xc]
80009434:	58 0e       	cp.w	lr,0
80009436:	c0 80       	breq	80009446 <_vfprintf_r+0x11ba>
80009438:	10 36       	cp.w	r6,r8
8000943a:	c6 74       	brge	80009508 <_vfprintf_r+0x127c>
8000943c:	fa cc f9 44 	sub	r12,sp,-1724
80009440:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009444:	c8 08       	rjmp	80009544 <_vfprintf_r+0x12b8>
80009446:	ee ca ff ff 	sub	r10,r7,-1
8000944a:	10 37       	cp.w	r7,r8
8000944c:	c7 f4       	brge	8000954a <_vfprintf_r+0x12be>
8000944e:	fa cb f9 44 	sub	r11,sp,-1724
80009452:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009456:	c7 68       	rjmp	80009542 <_vfprintf_r+0x12b6>
80009458:	ed b5 00 06 	bld	r5,0x6
8000945c:	c4 a1       	brne	800094f0 <_vfprintf_r+0x1264>
8000945e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009462:	40 3c       	lddsp	r12,sp[0xc]
80009464:	58 0c       	cp.w	r12,0
80009466:	c1 d0       	breq	800094a0 <_vfprintf_r+0x1214>
80009468:	10 36       	cp.w	r6,r8
8000946a:	c0 64       	brge	80009476 <_vfprintf_r+0x11ea>
8000946c:	fa cb f9 44 	sub	r11,sp,-1724
80009470:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009474:	c1 f8       	rjmp	800094b2 <_vfprintf_r+0x1226>
80009476:	fa c8 f9 50 	sub	r8,sp,-1712
8000947a:	1a d8       	st.w	--sp,r8
8000947c:	fa c8 fa b8 	sub	r8,sp,-1352
80009480:	1a d8       	st.w	--sp,r8
80009482:	fa c8 fb b4 	sub	r8,sp,-1100
80009486:	1a d8       	st.w	--sp,r8
80009488:	fa c8 f9 40 	sub	r8,sp,-1728
8000948c:	fa c9 ff b4 	sub	r9,sp,-76
80009490:	04 9a       	mov	r10,r2
80009492:	0c 9b       	mov	r11,r6
80009494:	08 9c       	mov	r12,r4
80009496:	fe b0 f5 63 	rcall	80007f5c <get_arg>
8000949a:	2f dd       	sub	sp,-12
8000949c:	98 18       	ld.sh	r8,r12[0x2]
8000949e:	c2 68       	rjmp	800094ea <_vfprintf_r+0x125e>
800094a0:	ee ca ff ff 	sub	r10,r7,-1
800094a4:	10 37       	cp.w	r7,r8
800094a6:	c0 94       	brge	800094b8 <_vfprintf_r+0x122c>
800094a8:	fa c9 f9 44 	sub	r9,sp,-1724
800094ac:	14 97       	mov	r7,r10
800094ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800094b6:	c1 a8       	rjmp	800094ea <_vfprintf_r+0x125e>
800094b8:	41 09       	lddsp	r9,sp[0x40]
800094ba:	59 f8       	cp.w	r8,31
800094bc:	e0 89 00 13 	brgt	800094e2 <_vfprintf_r+0x1256>
800094c0:	f2 cb ff fc 	sub	r11,r9,-4
800094c4:	51 0b       	stdsp	sp[0x40],r11
800094c6:	72 09       	ld.w	r9,r9[0x0]
800094c8:	fa c6 f9 44 	sub	r6,sp,-1724
800094cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800094d0:	2f f8       	sub	r8,-1
800094d2:	f7 49 fd 88 	st.w	r11[-632],r9
800094d6:	fb 48 06 b4 	st.w	sp[1716],r8
800094da:	14 97       	mov	r7,r10
800094dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800094e0:	c0 58       	rjmp	800094ea <_vfprintf_r+0x125e>
800094e2:	92 18       	ld.sh	r8,r9[0x2]
800094e4:	14 97       	mov	r7,r10
800094e6:	2f c9       	sub	r9,-4
800094e8:	51 09       	stdsp	sp[0x40],r9
800094ea:	5c 78       	castu.h	r8
800094ec:	50 18       	stdsp	sp[0x4],r8
800094ee:	c4 68       	rjmp	8000957a <_vfprintf_r+0x12ee>
800094f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094f4:	40 3c       	lddsp	r12,sp[0xc]
800094f6:	58 0c       	cp.w	r12,0
800094f8:	c1 d0       	breq	80009532 <_vfprintf_r+0x12a6>
800094fa:	10 36       	cp.w	r6,r8
800094fc:	c0 64       	brge	80009508 <_vfprintf_r+0x127c>
800094fe:	fa cb f9 44 	sub	r11,sp,-1724
80009502:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009506:	c1 f8       	rjmp	80009544 <_vfprintf_r+0x12b8>
80009508:	fa c8 f9 50 	sub	r8,sp,-1712
8000950c:	1a d8       	st.w	--sp,r8
8000950e:	fa c8 fa b8 	sub	r8,sp,-1352
80009512:	0c 9b       	mov	r11,r6
80009514:	1a d8       	st.w	--sp,r8
80009516:	fa c8 fb b4 	sub	r8,sp,-1100
8000951a:	04 9a       	mov	r10,r2
8000951c:	1a d8       	st.w	--sp,r8
8000951e:	08 9c       	mov	r12,r4
80009520:	fa c8 f9 40 	sub	r8,sp,-1728
80009524:	fa c9 ff b4 	sub	r9,sp,-76
80009528:	fe b0 f5 1a 	rcall	80007f5c <get_arg>
8000952c:	2f dd       	sub	sp,-12
8000952e:	78 0b       	ld.w	r11,r12[0x0]
80009530:	c2 48       	rjmp	80009578 <_vfprintf_r+0x12ec>
80009532:	ee ca ff ff 	sub	r10,r7,-1
80009536:	10 37       	cp.w	r7,r8
80009538:	c0 94       	brge	8000954a <_vfprintf_r+0x12be>
8000953a:	fa c9 f9 44 	sub	r9,sp,-1724
8000953e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009542:	14 97       	mov	r7,r10
80009544:	ec fb fd 88 	ld.w	r11,r6[-632]
80009548:	c1 88       	rjmp	80009578 <_vfprintf_r+0x12ec>
8000954a:	41 09       	lddsp	r9,sp[0x40]
8000954c:	59 f8       	cp.w	r8,31
8000954e:	e0 89 00 11 	brgt	80009570 <_vfprintf_r+0x12e4>
80009552:	f2 cb ff fc 	sub	r11,r9,-4
80009556:	51 0b       	stdsp	sp[0x40],r11
80009558:	fa c6 f9 44 	sub	r6,sp,-1724
8000955c:	72 0b       	ld.w	r11,r9[0x0]
8000955e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009562:	f3 4b fd 88 	st.w	r9[-632],r11
80009566:	2f f8       	sub	r8,-1
80009568:	14 97       	mov	r7,r10
8000956a:	fb 48 06 b4 	st.w	sp[1716],r8
8000956e:	c0 58       	rjmp	80009578 <_vfprintf_r+0x12ec>
80009570:	72 0b       	ld.w	r11,r9[0x0]
80009572:	14 97       	mov	r7,r10
80009574:	2f c9       	sub	r9,-4
80009576:	51 09       	stdsp	sp[0x40],r9
80009578:	50 1b       	stdsp	sp[0x4],r11
8000957a:	30 0e       	mov	lr,0
8000957c:	30 18       	mov	r8,1
8000957e:	50 0e       	stdsp	sp[0x0],lr
80009580:	c2 29       	rjmp	800097c4 <_vfprintf_r+0x1538>
80009582:	50 a7       	stdsp	sp[0x28],r7
80009584:	50 80       	stdsp	sp[0x20],r0
80009586:	0c 97       	mov	r7,r6
80009588:	04 94       	mov	r4,r2
8000958a:	06 96       	mov	r6,r3
8000958c:	02 92       	mov	r2,r1
8000958e:	fe cc b4 46 	sub	r12,pc,-19386
80009592:	40 93       	lddsp	r3,sp[0x24]
80009594:	10 90       	mov	r0,r8
80009596:	40 41       	lddsp	r1,sp[0x10]
80009598:	50 dc       	stdsp	sp[0x34],r12
8000959a:	ed b5 00 05 	bld	r5,0x5
8000959e:	c5 51       	brne	80009648 <_vfprintf_r+0x13bc>
800095a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095a4:	40 3b       	lddsp	r11,sp[0xc]
800095a6:	58 0b       	cp.w	r11,0
800095a8:	c2 20       	breq	800095ec <_vfprintf_r+0x1360>
800095aa:	10 36       	cp.w	r6,r8
800095ac:	c0 a4       	brge	800095c0 <_vfprintf_r+0x1334>
800095ae:	fa ca f9 44 	sub	r10,sp,-1724
800095b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800095b6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800095ba:	fa e9 00 00 	st.d	sp[0],r8
800095be:	cf 28       	rjmp	800097a2 <_vfprintf_r+0x1516>
800095c0:	fa c8 f9 50 	sub	r8,sp,-1712
800095c4:	1a d8       	st.w	--sp,r8
800095c6:	fa c8 fa b8 	sub	r8,sp,-1352
800095ca:	04 9a       	mov	r10,r2
800095cc:	1a d8       	st.w	--sp,r8
800095ce:	0c 9b       	mov	r11,r6
800095d0:	fa c8 fb b4 	sub	r8,sp,-1100
800095d4:	08 9c       	mov	r12,r4
800095d6:	1a d8       	st.w	--sp,r8
800095d8:	fa c8 f9 40 	sub	r8,sp,-1728
800095dc:	fa c9 ff b4 	sub	r9,sp,-76
800095e0:	fe b0 f4 be 	rcall	80007f5c <get_arg>
800095e4:	2f dd       	sub	sp,-12
800095e6:	f8 ea 00 00 	ld.d	r10,r12[0]
800095ea:	c0 c8       	rjmp	80009602 <_vfprintf_r+0x1376>
800095ec:	ee ca ff ff 	sub	r10,r7,-1
800095f0:	10 37       	cp.w	r7,r8
800095f2:	c0 b4       	brge	80009608 <_vfprintf_r+0x137c>
800095f4:	fa c9 f9 44 	sub	r9,sp,-1724
800095f8:	14 97       	mov	r7,r10
800095fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80009602:	fa eb 00 00 	st.d	sp[0],r10
80009606:	cc e8       	rjmp	800097a2 <_vfprintf_r+0x1516>
80009608:	41 09       	lddsp	r9,sp[0x40]
8000960a:	59 f8       	cp.w	r8,31
8000960c:	e0 89 00 16 	brgt	80009638 <_vfprintf_r+0x13ac>
80009610:	f2 e6 00 00 	ld.d	r6,r9[0]
80009614:	f2 cb ff f8 	sub	r11,r9,-8
80009618:	fa e7 00 00 	st.d	sp[0],r6
8000961c:	51 0b       	stdsp	sp[0x40],r11
8000961e:	fa c6 f9 44 	sub	r6,sp,-1724
80009622:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009626:	fa e6 00 00 	ld.d	r6,sp[0]
8000962a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000962e:	2f f8       	sub	r8,-1
80009630:	14 97       	mov	r7,r10
80009632:	fb 48 06 b4 	st.w	sp[1716],r8
80009636:	cb 68       	rjmp	800097a2 <_vfprintf_r+0x1516>
80009638:	f2 e6 00 00 	ld.d	r6,r9[0]
8000963c:	2f 89       	sub	r9,-8
8000963e:	fa e7 00 00 	st.d	sp[0],r6
80009642:	51 09       	stdsp	sp[0x40],r9
80009644:	14 97       	mov	r7,r10
80009646:	ca e8       	rjmp	800097a2 <_vfprintf_r+0x1516>
80009648:	ed b5 00 04 	bld	r5,0x4
8000964c:	c1 71       	brne	8000967a <_vfprintf_r+0x13ee>
8000964e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009652:	40 3e       	lddsp	lr,sp[0xc]
80009654:	58 0e       	cp.w	lr,0
80009656:	c0 80       	breq	80009666 <_vfprintf_r+0x13da>
80009658:	10 36       	cp.w	r6,r8
8000965a:	c6 94       	brge	8000972c <_vfprintf_r+0x14a0>
8000965c:	fa cc f9 44 	sub	r12,sp,-1724
80009660:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009664:	c8 28       	rjmp	80009768 <_vfprintf_r+0x14dc>
80009666:	ee ca ff ff 	sub	r10,r7,-1
8000966a:	10 37       	cp.w	r7,r8
8000966c:	e0 84 00 81 	brge	8000976e <_vfprintf_r+0x14e2>
80009670:	fa cb f9 44 	sub	r11,sp,-1724
80009674:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009678:	c7 78       	rjmp	80009766 <_vfprintf_r+0x14da>
8000967a:	ed b5 00 06 	bld	r5,0x6
8000967e:	c4 b1       	brne	80009714 <_vfprintf_r+0x1488>
80009680:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009684:	40 3c       	lddsp	r12,sp[0xc]
80009686:	58 0c       	cp.w	r12,0
80009688:	c1 d0       	breq	800096c2 <_vfprintf_r+0x1436>
8000968a:	10 36       	cp.w	r6,r8
8000968c:	c0 64       	brge	80009698 <_vfprintf_r+0x140c>
8000968e:	fa cb f9 44 	sub	r11,sp,-1724
80009692:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009696:	c1 f8       	rjmp	800096d4 <_vfprintf_r+0x1448>
80009698:	fa c8 f9 50 	sub	r8,sp,-1712
8000969c:	1a d8       	st.w	--sp,r8
8000969e:	fa c8 fa b8 	sub	r8,sp,-1352
800096a2:	1a d8       	st.w	--sp,r8
800096a4:	fa c8 fb b4 	sub	r8,sp,-1100
800096a8:	1a d8       	st.w	--sp,r8
800096aa:	fa c8 f9 40 	sub	r8,sp,-1728
800096ae:	fa c9 ff b4 	sub	r9,sp,-76
800096b2:	04 9a       	mov	r10,r2
800096b4:	0c 9b       	mov	r11,r6
800096b6:	08 9c       	mov	r12,r4
800096b8:	fe b0 f4 52 	rcall	80007f5c <get_arg>
800096bc:	2f dd       	sub	sp,-12
800096be:	98 18       	ld.sh	r8,r12[0x2]
800096c0:	c2 78       	rjmp	8000970e <_vfprintf_r+0x1482>
800096c2:	ee ca ff ff 	sub	r10,r7,-1
800096c6:	10 37       	cp.w	r7,r8
800096c8:	c0 a4       	brge	800096dc <_vfprintf_r+0x1450>
800096ca:	fa c9 f9 44 	sub	r9,sp,-1724
800096ce:	14 97       	mov	r7,r10
800096d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096d4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800096d8:	c1 b8       	rjmp	8000970e <_vfprintf_r+0x1482>
800096da:	d7 03       	nop
800096dc:	41 09       	lddsp	r9,sp[0x40]
800096de:	59 f8       	cp.w	r8,31
800096e0:	e0 89 00 13 	brgt	80009706 <_vfprintf_r+0x147a>
800096e4:	f2 cb ff fc 	sub	r11,r9,-4
800096e8:	51 0b       	stdsp	sp[0x40],r11
800096ea:	72 09       	ld.w	r9,r9[0x0]
800096ec:	fa c6 f9 44 	sub	r6,sp,-1724
800096f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800096f4:	2f f8       	sub	r8,-1
800096f6:	f7 49 fd 88 	st.w	r11[-632],r9
800096fa:	fb 48 06 b4 	st.w	sp[1716],r8
800096fe:	14 97       	mov	r7,r10
80009700:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009704:	c0 58       	rjmp	8000970e <_vfprintf_r+0x1482>
80009706:	92 18       	ld.sh	r8,r9[0x2]
80009708:	14 97       	mov	r7,r10
8000970a:	2f c9       	sub	r9,-4
8000970c:	51 09       	stdsp	sp[0x40],r9
8000970e:	5c 78       	castu.h	r8
80009710:	50 18       	stdsp	sp[0x4],r8
80009712:	c4 68       	rjmp	8000979e <_vfprintf_r+0x1512>
80009714:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009718:	40 3c       	lddsp	r12,sp[0xc]
8000971a:	58 0c       	cp.w	r12,0
8000971c:	c1 d0       	breq	80009756 <_vfprintf_r+0x14ca>
8000971e:	10 36       	cp.w	r6,r8
80009720:	c0 64       	brge	8000972c <_vfprintf_r+0x14a0>
80009722:	fa cb f9 44 	sub	r11,sp,-1724
80009726:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000972a:	c1 f8       	rjmp	80009768 <_vfprintf_r+0x14dc>
8000972c:	fa c8 f9 50 	sub	r8,sp,-1712
80009730:	1a d8       	st.w	--sp,r8
80009732:	fa c8 fa b8 	sub	r8,sp,-1352
80009736:	0c 9b       	mov	r11,r6
80009738:	1a d8       	st.w	--sp,r8
8000973a:	fa c8 fb b4 	sub	r8,sp,-1100
8000973e:	04 9a       	mov	r10,r2
80009740:	1a d8       	st.w	--sp,r8
80009742:	08 9c       	mov	r12,r4
80009744:	fa c8 f9 40 	sub	r8,sp,-1728
80009748:	fa c9 ff b4 	sub	r9,sp,-76
8000974c:	fe b0 f4 08 	rcall	80007f5c <get_arg>
80009750:	2f dd       	sub	sp,-12
80009752:	78 0b       	ld.w	r11,r12[0x0]
80009754:	c2 48       	rjmp	8000979c <_vfprintf_r+0x1510>
80009756:	ee ca ff ff 	sub	r10,r7,-1
8000975a:	10 37       	cp.w	r7,r8
8000975c:	c0 94       	brge	8000976e <_vfprintf_r+0x14e2>
8000975e:	fa c9 f9 44 	sub	r9,sp,-1724
80009762:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009766:	14 97       	mov	r7,r10
80009768:	ec fb fd 88 	ld.w	r11,r6[-632]
8000976c:	c1 88       	rjmp	8000979c <_vfprintf_r+0x1510>
8000976e:	41 09       	lddsp	r9,sp[0x40]
80009770:	59 f8       	cp.w	r8,31
80009772:	e0 89 00 11 	brgt	80009794 <_vfprintf_r+0x1508>
80009776:	f2 cb ff fc 	sub	r11,r9,-4
8000977a:	51 0b       	stdsp	sp[0x40],r11
8000977c:	fa c6 f9 44 	sub	r6,sp,-1724
80009780:	72 0b       	ld.w	r11,r9[0x0]
80009782:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009786:	f3 4b fd 88 	st.w	r9[-632],r11
8000978a:	2f f8       	sub	r8,-1
8000978c:	14 97       	mov	r7,r10
8000978e:	fb 48 06 b4 	st.w	sp[1716],r8
80009792:	c0 58       	rjmp	8000979c <_vfprintf_r+0x1510>
80009794:	72 0b       	ld.w	r11,r9[0x0]
80009796:	14 97       	mov	r7,r10
80009798:	2f c9       	sub	r9,-4
8000979a:	51 09       	stdsp	sp[0x40],r9
8000979c:	50 1b       	stdsp	sp[0x4],r11
8000979e:	30 0e       	mov	lr,0
800097a0:	50 0e       	stdsp	sp[0x0],lr
800097a2:	40 08       	lddsp	r8,sp[0x0]
800097a4:	40 1c       	lddsp	r12,sp[0x4]
800097a6:	18 48       	or	r8,r12
800097a8:	5f 19       	srne	r9
800097aa:	0a 98       	mov	r8,r5
800097ac:	eb e9 00 09 	and	r9,r5,r9
800097b0:	a1 b8       	sbr	r8,0x1
800097b2:	58 09       	cp.w	r9,0
800097b4:	c0 70       	breq	800097c2 <_vfprintf_r+0x1536>
800097b6:	10 95       	mov	r5,r8
800097b8:	fb 60 06 b9 	st.b	sp[1721],r0
800097bc:	33 08       	mov	r8,48
800097be:	fb 68 06 b8 	st.b	sp[1720],r8
800097c2:	30 28       	mov	r8,2
800097c4:	30 09       	mov	r9,0
800097c6:	fb 69 06 bb 	st.b	sp[1723],r9
800097ca:	0a 99       	mov	r9,r5
800097cc:	a7 d9       	cbr	r9,0x7
800097ce:	40 2b       	lddsp	r11,sp[0x8]
800097d0:	40 16       	lddsp	r6,sp[0x4]
800097d2:	58 0b       	cp.w	r11,0
800097d4:	5f 1a       	srne	r10
800097d6:	f2 05 17 40 	movge	r5,r9
800097da:	fa c2 f9 78 	sub	r2,sp,-1672
800097de:	40 09       	lddsp	r9,sp[0x0]
800097e0:	0c 49       	or	r9,r6
800097e2:	5f 19       	srne	r9
800097e4:	f5 e9 10 09 	or	r9,r10,r9
800097e8:	c5 c0       	breq	800098a0 <_vfprintf_r+0x1614>
800097ea:	30 19       	mov	r9,1
800097ec:	f2 08 18 00 	cp.b	r8,r9
800097f0:	c0 60       	breq	800097fc <_vfprintf_r+0x1570>
800097f2:	30 29       	mov	r9,2
800097f4:	f2 08 18 00 	cp.b	r8,r9
800097f8:	c0 41       	brne	80009800 <_vfprintf_r+0x1574>
800097fa:	c3 c8       	rjmp	80009872 <_vfprintf_r+0x15e6>
800097fc:	04 96       	mov	r6,r2
800097fe:	c3 08       	rjmp	8000985e <_vfprintf_r+0x15d2>
80009800:	04 96       	mov	r6,r2
80009802:	fa e8 00 00 	ld.d	r8,sp[0]
80009806:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000980a:	2d 0a       	sub	r10,-48
8000980c:	0c fa       	st.b	--r6,r10
8000980e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009812:	f2 0c 16 03 	lsr	r12,r9,0x3
80009816:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000981a:	18 99       	mov	r9,r12
8000981c:	16 98       	mov	r8,r11
8000981e:	58 08       	cp.w	r8,0
80009820:	5c 29       	cpc	r9
80009822:	cf 21       	brne	80009806 <_vfprintf_r+0x157a>
80009824:	fa e9 00 00 	st.d	sp[0],r8
80009828:	ed b5 00 00 	bld	r5,0x0
8000982c:	c4 51       	brne	800098b6 <_vfprintf_r+0x162a>
8000982e:	33 09       	mov	r9,48
80009830:	f2 0a 18 00 	cp.b	r10,r9
80009834:	c4 10       	breq	800098b6 <_vfprintf_r+0x162a>
80009836:	0c f9       	st.b	--r6,r9
80009838:	c3 f8       	rjmp	800098b6 <_vfprintf_r+0x162a>
8000983a:	fa ea 00 00 	ld.d	r10,sp[0]
8000983e:	30 a8       	mov	r8,10
80009840:	30 09       	mov	r9,0
80009842:	e0 a0 1a 19 	rcall	8000cc74 <__avr32_umod64>
80009846:	30 a8       	mov	r8,10
80009848:	2d 0a       	sub	r10,-48
8000984a:	30 09       	mov	r9,0
8000984c:	ac 8a       	st.b	r6[0x0],r10
8000984e:	fa ea 00 00 	ld.d	r10,sp[0]
80009852:	e0 a0 18 df 	rcall	8000ca10 <__avr32_udiv64>
80009856:	16 99       	mov	r9,r11
80009858:	14 98       	mov	r8,r10
8000985a:	fa e9 00 00 	st.d	sp[0],r8
8000985e:	20 16       	sub	r6,1
80009860:	fa ea 00 00 	ld.d	r10,sp[0]
80009864:	58 9a       	cp.w	r10,9
80009866:	5c 2b       	cpc	r11
80009868:	fe 9b ff e9 	brhi	8000983a <_vfprintf_r+0x15ae>
8000986c:	1b f8       	ld.ub	r8,sp[0x7]
8000986e:	2d 08       	sub	r8,-48
80009870:	c2 08       	rjmp	800098b0 <_vfprintf_r+0x1624>
80009872:	04 96       	mov	r6,r2
80009874:	fa e8 00 00 	ld.d	r8,sp[0]
80009878:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000987c:	40 de       	lddsp	lr,sp[0x34]
8000987e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009882:	0c fa       	st.b	--r6,r10
80009884:	f2 0b 16 04 	lsr	r11,r9,0x4
80009888:	f0 0a 16 04 	lsr	r10,r8,0x4
8000988c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009890:	16 99       	mov	r9,r11
80009892:	14 98       	mov	r8,r10
80009894:	58 08       	cp.w	r8,0
80009896:	5c 29       	cpc	r9
80009898:	cf 01       	brne	80009878 <_vfprintf_r+0x15ec>
8000989a:	fa e9 00 00 	st.d	sp[0],r8
8000989e:	c0 c8       	rjmp	800098b6 <_vfprintf_r+0x162a>
800098a0:	58 08       	cp.w	r8,0
800098a2:	c0 91       	brne	800098b4 <_vfprintf_r+0x1628>
800098a4:	ed b5 00 00 	bld	r5,0x0
800098a8:	c0 61       	brne	800098b4 <_vfprintf_r+0x1628>
800098aa:	fa c6 f9 79 	sub	r6,sp,-1671
800098ae:	33 08       	mov	r8,48
800098b0:	ac 88       	st.b	r6[0x0],r8
800098b2:	c0 28       	rjmp	800098b6 <_vfprintf_r+0x162a>
800098b4:	04 96       	mov	r6,r2
800098b6:	0c 12       	sub	r2,r6
800098b8:	c1 c8       	rjmp	800098f0 <_vfprintf_r+0x1664>
800098ba:	50 a7       	stdsp	sp[0x28],r7
800098bc:	50 80       	stdsp	sp[0x20],r0
800098be:	40 93       	lddsp	r3,sp[0x24]
800098c0:	0c 97       	mov	r7,r6
800098c2:	10 90       	mov	r0,r8
800098c4:	04 94       	mov	r4,r2
800098c6:	40 41       	lddsp	r1,sp[0x10]
800098c8:	58 08       	cp.w	r8,0
800098ca:	e0 80 04 4f 	breq	8000a168 <_vfprintf_r+0x1edc>
800098ce:	fb 68 06 60 	st.b	sp[1632],r8
800098d2:	30 0c       	mov	r12,0
800098d4:	30 08       	mov	r8,0
800098d6:	30 12       	mov	r2,1
800098d8:	fb 68 06 bb 	st.b	sp[1723],r8
800098dc:	50 2c       	stdsp	sp[0x8],r12
800098de:	fa c6 f9 a0 	sub	r6,sp,-1632
800098e2:	c0 78       	rjmp	800098f0 <_vfprintf_r+0x1664>
800098e4:	30 0b       	mov	r11,0
800098e6:	50 2b       	stdsp	sp[0x8],r11
800098e8:	c0 48       	rjmp	800098f0 <_vfprintf_r+0x1664>
800098ea:	40 22       	lddsp	r2,sp[0x8]
800098ec:	30 0a       	mov	r10,0
800098ee:	50 2a       	stdsp	sp[0x8],r10
800098f0:	40 29       	lddsp	r9,sp[0x8]
800098f2:	e4 09 0c 49 	max	r9,r2,r9
800098f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800098fa:	50 39       	stdsp	sp[0xc],r9
800098fc:	0a 9e       	mov	lr,r5
800098fe:	30 09       	mov	r9,0
80009900:	e2 1e 00 02 	andl	lr,0x2,COH
80009904:	f2 08 18 00 	cp.b	r8,r9
80009908:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000990c:	f7 b8 01 ff 	subne	r8,-1
80009910:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009914:	0a 9b       	mov	r11,r5
80009916:	58 0e       	cp.w	lr,0
80009918:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000991c:	f7 bc 01 fe 	subne	r12,-2
80009920:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009924:	e2 1b 00 84 	andl	r11,0x84,COH
80009928:	50 fe       	stdsp	sp[0x3c],lr
8000992a:	50 9b       	stdsp	sp[0x24],r11
8000992c:	c4 71       	brne	800099ba <_vfprintf_r+0x172e>
8000992e:	40 8a       	lddsp	r10,sp[0x20]
80009930:	40 39       	lddsp	r9,sp[0xc]
80009932:	12 1a       	sub	r10,r9
80009934:	50 4a       	stdsp	sp[0x10],r10
80009936:	58 0a       	cp.w	r10,0
80009938:	e0 89 00 20 	brgt	80009978 <_vfprintf_r+0x16ec>
8000993c:	c3 f8       	rjmp	800099ba <_vfprintf_r+0x172e>
8000993e:	2f 09       	sub	r9,-16
80009940:	2f f8       	sub	r8,-1
80009942:	fe ce b7 e2 	sub	lr,pc,-18462
80009946:	31 0c       	mov	r12,16
80009948:	fb 49 06 90 	st.w	sp[1680],r9
8000994c:	87 0e       	st.w	r3[0x0],lr
8000994e:	87 1c       	st.w	r3[0x4],r12
80009950:	fb 48 06 8c 	st.w	sp[1676],r8
80009954:	58 78       	cp.w	r8,7
80009956:	e0 89 00 04 	brgt	8000995e <_vfprintf_r+0x16d2>
8000995a:	2f 83       	sub	r3,-8
8000995c:	c0 b8       	rjmp	80009972 <_vfprintf_r+0x16e6>
8000995e:	fa ca f9 78 	sub	r10,sp,-1672
80009962:	02 9b       	mov	r11,r1
80009964:	08 9c       	mov	r12,r4
80009966:	fe b0 f4 85 	rcall	80008270 <__sprint_r>
8000996a:	e0 81 04 10 	brne	8000a18a <_vfprintf_r+0x1efe>
8000996e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009972:	40 4b       	lddsp	r11,sp[0x10]
80009974:	21 0b       	sub	r11,16
80009976:	50 4b       	stdsp	sp[0x10],r11
80009978:	fa f9 06 90 	ld.w	r9,sp[1680]
8000997c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009980:	fe ca b8 20 	sub	r10,pc,-18400
80009984:	40 4e       	lddsp	lr,sp[0x10]
80009986:	59 0e       	cp.w	lr,16
80009988:	fe 99 ff db 	brgt	8000993e <_vfprintf_r+0x16b2>
8000998c:	1c 09       	add	r9,lr
8000998e:	2f f8       	sub	r8,-1
80009990:	87 0a       	st.w	r3[0x0],r10
80009992:	fb 49 06 90 	st.w	sp[1680],r9
80009996:	87 1e       	st.w	r3[0x4],lr
80009998:	fb 48 06 8c 	st.w	sp[1676],r8
8000999c:	58 78       	cp.w	r8,7
8000999e:	e0 89 00 04 	brgt	800099a6 <_vfprintf_r+0x171a>
800099a2:	2f 83       	sub	r3,-8
800099a4:	c0 b8       	rjmp	800099ba <_vfprintf_r+0x172e>
800099a6:	fa ca f9 78 	sub	r10,sp,-1672
800099aa:	02 9b       	mov	r11,r1
800099ac:	08 9c       	mov	r12,r4
800099ae:	fe b0 f4 61 	rcall	80008270 <__sprint_r>
800099b2:	e0 81 03 ec 	brne	8000a18a <_vfprintf_r+0x1efe>
800099b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ba:	30 09       	mov	r9,0
800099bc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800099c0:	f2 08 18 00 	cp.b	r8,r9
800099c4:	c1 f0       	breq	80009a02 <_vfprintf_r+0x1776>
800099c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800099ca:	fa c9 f9 45 	sub	r9,sp,-1723
800099ce:	2f f8       	sub	r8,-1
800099d0:	87 09       	st.w	r3[0x0],r9
800099d2:	fb 48 06 90 	st.w	sp[1680],r8
800099d6:	30 19       	mov	r9,1
800099d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099dc:	87 19       	st.w	r3[0x4],r9
800099de:	2f f8       	sub	r8,-1
800099e0:	fb 48 06 8c 	st.w	sp[1676],r8
800099e4:	58 78       	cp.w	r8,7
800099e6:	e0 89 00 04 	brgt	800099ee <_vfprintf_r+0x1762>
800099ea:	2f 83       	sub	r3,-8
800099ec:	c0 b8       	rjmp	80009a02 <_vfprintf_r+0x1776>
800099ee:	fa ca f9 78 	sub	r10,sp,-1672
800099f2:	02 9b       	mov	r11,r1
800099f4:	08 9c       	mov	r12,r4
800099f6:	fe b0 f4 3d 	rcall	80008270 <__sprint_r>
800099fa:	e0 81 03 c8 	brne	8000a18a <_vfprintf_r+0x1efe>
800099fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a02:	40 fc       	lddsp	r12,sp[0x3c]
80009a04:	58 0c       	cp.w	r12,0
80009a06:	c1 f0       	breq	80009a44 <_vfprintf_r+0x17b8>
80009a08:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a0c:	fa c9 f9 48 	sub	r9,sp,-1720
80009a10:	2f e8       	sub	r8,-2
80009a12:	87 09       	st.w	r3[0x0],r9
80009a14:	fb 48 06 90 	st.w	sp[1680],r8
80009a18:	30 29       	mov	r9,2
80009a1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a1e:	87 19       	st.w	r3[0x4],r9
80009a20:	2f f8       	sub	r8,-1
80009a22:	fb 48 06 8c 	st.w	sp[1676],r8
80009a26:	58 78       	cp.w	r8,7
80009a28:	e0 89 00 04 	brgt	80009a30 <_vfprintf_r+0x17a4>
80009a2c:	2f 83       	sub	r3,-8
80009a2e:	c0 b8       	rjmp	80009a44 <_vfprintf_r+0x17b8>
80009a30:	fa ca f9 78 	sub	r10,sp,-1672
80009a34:	02 9b       	mov	r11,r1
80009a36:	08 9c       	mov	r12,r4
80009a38:	fe b0 f4 1c 	rcall	80008270 <__sprint_r>
80009a3c:	e0 81 03 a7 	brne	8000a18a <_vfprintf_r+0x1efe>
80009a40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a44:	40 9b       	lddsp	r11,sp[0x24]
80009a46:	e0 4b 00 80 	cp.w	r11,128
80009a4a:	c4 71       	brne	80009ad8 <_vfprintf_r+0x184c>
80009a4c:	40 8a       	lddsp	r10,sp[0x20]
80009a4e:	40 39       	lddsp	r9,sp[0xc]
80009a50:	12 1a       	sub	r10,r9
80009a52:	50 4a       	stdsp	sp[0x10],r10
80009a54:	58 0a       	cp.w	r10,0
80009a56:	e0 89 00 20 	brgt	80009a96 <_vfprintf_r+0x180a>
80009a5a:	c3 f8       	rjmp	80009ad8 <_vfprintf_r+0x184c>
80009a5c:	2f 09       	sub	r9,-16
80009a5e:	2f f8       	sub	r8,-1
80009a60:	fe ce b8 f0 	sub	lr,pc,-18192
80009a64:	31 0c       	mov	r12,16
80009a66:	fb 49 06 90 	st.w	sp[1680],r9
80009a6a:	87 0e       	st.w	r3[0x0],lr
80009a6c:	87 1c       	st.w	r3[0x4],r12
80009a6e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a72:	58 78       	cp.w	r8,7
80009a74:	e0 89 00 04 	brgt	80009a7c <_vfprintf_r+0x17f0>
80009a78:	2f 83       	sub	r3,-8
80009a7a:	c0 b8       	rjmp	80009a90 <_vfprintf_r+0x1804>
80009a7c:	fa ca f9 78 	sub	r10,sp,-1672
80009a80:	02 9b       	mov	r11,r1
80009a82:	08 9c       	mov	r12,r4
80009a84:	fe b0 f3 f6 	rcall	80008270 <__sprint_r>
80009a88:	e0 81 03 81 	brne	8000a18a <_vfprintf_r+0x1efe>
80009a8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a90:	40 4b       	lddsp	r11,sp[0x10]
80009a92:	21 0b       	sub	r11,16
80009a94:	50 4b       	stdsp	sp[0x10],r11
80009a96:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a9e:	fe ca b9 2e 	sub	r10,pc,-18130
80009aa2:	40 4e       	lddsp	lr,sp[0x10]
80009aa4:	59 0e       	cp.w	lr,16
80009aa6:	fe 99 ff db 	brgt	80009a5c <_vfprintf_r+0x17d0>
80009aaa:	1c 09       	add	r9,lr
80009aac:	2f f8       	sub	r8,-1
80009aae:	87 0a       	st.w	r3[0x0],r10
80009ab0:	fb 49 06 90 	st.w	sp[1680],r9
80009ab4:	87 1e       	st.w	r3[0x4],lr
80009ab6:	fb 48 06 8c 	st.w	sp[1676],r8
80009aba:	58 78       	cp.w	r8,7
80009abc:	e0 89 00 04 	brgt	80009ac4 <_vfprintf_r+0x1838>
80009ac0:	2f 83       	sub	r3,-8
80009ac2:	c0 b8       	rjmp	80009ad8 <_vfprintf_r+0x184c>
80009ac4:	fa ca f9 78 	sub	r10,sp,-1672
80009ac8:	02 9b       	mov	r11,r1
80009aca:	08 9c       	mov	r12,r4
80009acc:	fe b0 f3 d2 	rcall	80008270 <__sprint_r>
80009ad0:	e0 81 03 5d 	brne	8000a18a <_vfprintf_r+0x1efe>
80009ad4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ad8:	40 2c       	lddsp	r12,sp[0x8]
80009ada:	04 1c       	sub	r12,r2
80009adc:	50 2c       	stdsp	sp[0x8],r12
80009ade:	58 0c       	cp.w	r12,0
80009ae0:	e0 89 00 20 	brgt	80009b20 <_vfprintf_r+0x1894>
80009ae4:	c3 f8       	rjmp	80009b62 <_vfprintf_r+0x18d6>
80009ae6:	2f 09       	sub	r9,-16
80009ae8:	2f f8       	sub	r8,-1
80009aea:	fe cb b9 7a 	sub	r11,pc,-18054
80009aee:	31 0a       	mov	r10,16
80009af0:	fb 49 06 90 	st.w	sp[1680],r9
80009af4:	87 0b       	st.w	r3[0x0],r11
80009af6:	87 1a       	st.w	r3[0x4],r10
80009af8:	fb 48 06 8c 	st.w	sp[1676],r8
80009afc:	58 78       	cp.w	r8,7
80009afe:	e0 89 00 04 	brgt	80009b06 <_vfprintf_r+0x187a>
80009b02:	2f 83       	sub	r3,-8
80009b04:	c0 b8       	rjmp	80009b1a <_vfprintf_r+0x188e>
80009b06:	fa ca f9 78 	sub	r10,sp,-1672
80009b0a:	02 9b       	mov	r11,r1
80009b0c:	08 9c       	mov	r12,r4
80009b0e:	fe b0 f3 b1 	rcall	80008270 <__sprint_r>
80009b12:	e0 81 03 3c 	brne	8000a18a <_vfprintf_r+0x1efe>
80009b16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b1a:	40 29       	lddsp	r9,sp[0x8]
80009b1c:	21 09       	sub	r9,16
80009b1e:	50 29       	stdsp	sp[0x8],r9
80009b20:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b28:	fe ca b9 b8 	sub	r10,pc,-17992
80009b2c:	40 2e       	lddsp	lr,sp[0x8]
80009b2e:	59 0e       	cp.w	lr,16
80009b30:	fe 99 ff db 	brgt	80009ae6 <_vfprintf_r+0x185a>
80009b34:	1c 09       	add	r9,lr
80009b36:	2f f8       	sub	r8,-1
80009b38:	87 0a       	st.w	r3[0x0],r10
80009b3a:	fb 49 06 90 	st.w	sp[1680],r9
80009b3e:	87 1e       	st.w	r3[0x4],lr
80009b40:	fb 48 06 8c 	st.w	sp[1676],r8
80009b44:	58 78       	cp.w	r8,7
80009b46:	e0 89 00 04 	brgt	80009b4e <_vfprintf_r+0x18c2>
80009b4a:	2f 83       	sub	r3,-8
80009b4c:	c0 b8       	rjmp	80009b62 <_vfprintf_r+0x18d6>
80009b4e:	fa ca f9 78 	sub	r10,sp,-1672
80009b52:	02 9b       	mov	r11,r1
80009b54:	08 9c       	mov	r12,r4
80009b56:	fe b0 f3 8d 	rcall	80008270 <__sprint_r>
80009b5a:	e0 81 03 18 	brne	8000a18a <_vfprintf_r+0x1efe>
80009b5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b62:	ed b5 00 08 	bld	r5,0x8
80009b66:	c0 b0       	breq	80009b7c <_vfprintf_r+0x18f0>
80009b68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b6c:	87 12       	st.w	r3[0x4],r2
80009b6e:	87 06       	st.w	r3[0x0],r6
80009b70:	f0 02 00 02 	add	r2,r8,r2
80009b74:	fb 42 06 90 	st.w	sp[1680],r2
80009b78:	e0 8f 01 d4 	bral	80009f20 <_vfprintf_r+0x1c94>
80009b7c:	e0 40 00 65 	cp.w	r0,101
80009b80:	e0 8a 01 d6 	brle	80009f2c <_vfprintf_r+0x1ca0>
80009b84:	30 08       	mov	r8,0
80009b86:	30 09       	mov	r9,0
80009b88:	40 5b       	lddsp	r11,sp[0x14]
80009b8a:	40 7a       	lddsp	r10,sp[0x1c]
80009b8c:	e0 a0 15 3b 	rcall	8000c602 <__avr32_f64_cmp_eq>
80009b90:	c7 90       	breq	80009c82 <_vfprintf_r+0x19f6>
80009b92:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b96:	fe c9 ba 3a 	sub	r9,pc,-17862
80009b9a:	2f f8       	sub	r8,-1
80009b9c:	87 09       	st.w	r3[0x0],r9
80009b9e:	fb 48 06 90 	st.w	sp[1680],r8
80009ba2:	30 19       	mov	r9,1
80009ba4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ba8:	87 19       	st.w	r3[0x4],r9
80009baa:	2f f8       	sub	r8,-1
80009bac:	fb 48 06 8c 	st.w	sp[1676],r8
80009bb0:	58 78       	cp.w	r8,7
80009bb2:	e0 89 00 05 	brgt	80009bbc <_vfprintf_r+0x1930>
80009bb6:	2f 83       	sub	r3,-8
80009bb8:	c0 c8       	rjmp	80009bd0 <_vfprintf_r+0x1944>
80009bba:	d7 03       	nop
80009bbc:	fa ca f9 78 	sub	r10,sp,-1672
80009bc0:	02 9b       	mov	r11,r1
80009bc2:	08 9c       	mov	r12,r4
80009bc4:	fe b0 f3 56 	rcall	80008270 <__sprint_r>
80009bc8:	e0 81 02 e1 	brne	8000a18a <_vfprintf_r+0x1efe>
80009bcc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bd0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bd4:	40 6c       	lddsp	r12,sp[0x18]
80009bd6:	18 38       	cp.w	r8,r12
80009bd8:	c0 55       	brlt	80009be2 <_vfprintf_r+0x1956>
80009bda:	ed b5 00 00 	bld	r5,0x0
80009bde:	e0 81 02 6b 	brne	8000a0b4 <_vfprintf_r+0x1e28>
80009be2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009be6:	2f f8       	sub	r8,-1
80009be8:	40 cb       	lddsp	r11,sp[0x30]
80009bea:	fb 48 06 90 	st.w	sp[1680],r8
80009bee:	30 19       	mov	r9,1
80009bf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bf4:	87 0b       	st.w	r3[0x0],r11
80009bf6:	2f f8       	sub	r8,-1
80009bf8:	87 19       	st.w	r3[0x4],r9
80009bfa:	fb 48 06 8c 	st.w	sp[1676],r8
80009bfe:	58 78       	cp.w	r8,7
80009c00:	e0 89 00 04 	brgt	80009c08 <_vfprintf_r+0x197c>
80009c04:	2f 83       	sub	r3,-8
80009c06:	c0 b8       	rjmp	80009c1c <_vfprintf_r+0x1990>
80009c08:	fa ca f9 78 	sub	r10,sp,-1672
80009c0c:	02 9b       	mov	r11,r1
80009c0e:	08 9c       	mov	r12,r4
80009c10:	fe b0 f3 30 	rcall	80008270 <__sprint_r>
80009c14:	e0 81 02 bb 	brne	8000a18a <_vfprintf_r+0x1efe>
80009c18:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c1c:	40 66       	lddsp	r6,sp[0x18]
80009c1e:	20 16       	sub	r6,1
80009c20:	58 06       	cp.w	r6,0
80009c22:	e0 89 00 1d 	brgt	80009c5c <_vfprintf_r+0x19d0>
80009c26:	e0 8f 02 47 	bral	8000a0b4 <_vfprintf_r+0x1e28>
80009c2a:	2f 09       	sub	r9,-16
80009c2c:	2f f8       	sub	r8,-1
80009c2e:	fb 49 06 90 	st.w	sp[1680],r9
80009c32:	87 02       	st.w	r3[0x0],r2
80009c34:	87 10       	st.w	r3[0x4],r0
80009c36:	fb 48 06 8c 	st.w	sp[1676],r8
80009c3a:	58 78       	cp.w	r8,7
80009c3c:	e0 89 00 04 	brgt	80009c44 <_vfprintf_r+0x19b8>
80009c40:	2f 83       	sub	r3,-8
80009c42:	c0 b8       	rjmp	80009c58 <_vfprintf_r+0x19cc>
80009c44:	fa ca f9 78 	sub	r10,sp,-1672
80009c48:	02 9b       	mov	r11,r1
80009c4a:	08 9c       	mov	r12,r4
80009c4c:	fe b0 f3 12 	rcall	80008270 <__sprint_r>
80009c50:	e0 81 02 9d 	brne	8000a18a <_vfprintf_r+0x1efe>
80009c54:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c58:	21 06       	sub	r6,16
80009c5a:	c0 48       	rjmp	80009c62 <_vfprintf_r+0x19d6>
80009c5c:	fe c2 ba ec 	sub	r2,pc,-17684
80009c60:	31 00       	mov	r0,16
80009c62:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c66:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c6a:	fe ca ba fa 	sub	r10,pc,-17670
80009c6e:	59 06       	cp.w	r6,16
80009c70:	fe 99 ff dd 	brgt	80009c2a <_vfprintf_r+0x199e>
80009c74:	0c 09       	add	r9,r6
80009c76:	87 0a       	st.w	r3[0x0],r10
80009c78:	fb 49 06 90 	st.w	sp[1680],r9
80009c7c:	2f f8       	sub	r8,-1
80009c7e:	87 16       	st.w	r3[0x4],r6
80009c80:	c5 39       	rjmp	80009f26 <_vfprintf_r+0x1c9a>
80009c82:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009c86:	58 0a       	cp.w	r10,0
80009c88:	e0 89 00 92 	brgt	80009dac <_vfprintf_r+0x1b20>
80009c8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c90:	fe c9 bb 34 	sub	r9,pc,-17612
80009c94:	2f f8       	sub	r8,-1
80009c96:	87 09       	st.w	r3[0x0],r9
80009c98:	fb 48 06 90 	st.w	sp[1680],r8
80009c9c:	30 19       	mov	r9,1
80009c9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ca2:	87 19       	st.w	r3[0x4],r9
80009ca4:	2f f8       	sub	r8,-1
80009ca6:	fb 48 06 8c 	st.w	sp[1676],r8
80009caa:	58 78       	cp.w	r8,7
80009cac:	e0 89 00 04 	brgt	80009cb4 <_vfprintf_r+0x1a28>
80009cb0:	2f 83       	sub	r3,-8
80009cb2:	c0 b8       	rjmp	80009cc8 <_vfprintf_r+0x1a3c>
80009cb4:	fa ca f9 78 	sub	r10,sp,-1672
80009cb8:	02 9b       	mov	r11,r1
80009cba:	08 9c       	mov	r12,r4
80009cbc:	fe b0 f2 da 	rcall	80008270 <__sprint_r>
80009cc0:	e0 81 02 65 	brne	8000a18a <_vfprintf_r+0x1efe>
80009cc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ccc:	58 08       	cp.w	r8,0
80009cce:	c0 81       	brne	80009cde <_vfprintf_r+0x1a52>
80009cd0:	40 6a       	lddsp	r10,sp[0x18]
80009cd2:	58 0a       	cp.w	r10,0
80009cd4:	c0 51       	brne	80009cde <_vfprintf_r+0x1a52>
80009cd6:	ed b5 00 00 	bld	r5,0x0
80009cda:	e0 81 01 ed 	brne	8000a0b4 <_vfprintf_r+0x1e28>
80009cde:	40 c9       	lddsp	r9,sp[0x30]
80009ce0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ce4:	2f f8       	sub	r8,-1
80009ce6:	87 09       	st.w	r3[0x0],r9
80009ce8:	fb 48 06 90 	st.w	sp[1680],r8
80009cec:	30 19       	mov	r9,1
80009cee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cf2:	87 19       	st.w	r3[0x4],r9
80009cf4:	2f f8       	sub	r8,-1
80009cf6:	fb 48 06 8c 	st.w	sp[1676],r8
80009cfa:	58 78       	cp.w	r8,7
80009cfc:	e0 89 00 04 	brgt	80009d04 <_vfprintf_r+0x1a78>
80009d00:	2f 83       	sub	r3,-8
80009d02:	c0 b8       	rjmp	80009d18 <_vfprintf_r+0x1a8c>
80009d04:	fa ca f9 78 	sub	r10,sp,-1672
80009d08:	02 9b       	mov	r11,r1
80009d0a:	08 9c       	mov	r12,r4
80009d0c:	fe b0 f2 b2 	rcall	80008270 <__sprint_r>
80009d10:	e0 81 02 3d 	brne	8000a18a <_vfprintf_r+0x1efe>
80009d14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d18:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d1c:	5c 32       	neg	r2
80009d1e:	58 02       	cp.w	r2,0
80009d20:	e0 89 00 1d 	brgt	80009d5a <_vfprintf_r+0x1ace>
80009d24:	c3 d8       	rjmp	80009d9e <_vfprintf_r+0x1b12>
80009d26:	2f 09       	sub	r9,-16
80009d28:	2f f8       	sub	r8,-1
80009d2a:	31 0e       	mov	lr,16
80009d2c:	fb 49 06 90 	st.w	sp[1680],r9
80009d30:	87 00       	st.w	r3[0x0],r0
80009d32:	87 1e       	st.w	r3[0x4],lr
80009d34:	fb 48 06 8c 	st.w	sp[1676],r8
80009d38:	58 78       	cp.w	r8,7
80009d3a:	e0 89 00 04 	brgt	80009d42 <_vfprintf_r+0x1ab6>
80009d3e:	2f 83       	sub	r3,-8
80009d40:	c0 b8       	rjmp	80009d56 <_vfprintf_r+0x1aca>
80009d42:	fa ca f9 78 	sub	r10,sp,-1672
80009d46:	02 9b       	mov	r11,r1
80009d48:	08 9c       	mov	r12,r4
80009d4a:	fe b0 f2 93 	rcall	80008270 <__sprint_r>
80009d4e:	e0 81 02 1e 	brne	8000a18a <_vfprintf_r+0x1efe>
80009d52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d56:	21 02       	sub	r2,16
80009d58:	c0 38       	rjmp	80009d5e <_vfprintf_r+0x1ad2>
80009d5a:	fe c0 bb ea 	sub	r0,pc,-17430
80009d5e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d66:	fe ca bb f6 	sub	r10,pc,-17418
80009d6a:	59 02       	cp.w	r2,16
80009d6c:	fe 99 ff dd 	brgt	80009d26 <_vfprintf_r+0x1a9a>
80009d70:	04 09       	add	r9,r2
80009d72:	2f f8       	sub	r8,-1
80009d74:	87 0a       	st.w	r3[0x0],r10
80009d76:	fb 49 06 90 	st.w	sp[1680],r9
80009d7a:	87 12       	st.w	r3[0x4],r2
80009d7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d80:	58 78       	cp.w	r8,7
80009d82:	e0 89 00 04 	brgt	80009d8a <_vfprintf_r+0x1afe>
80009d86:	2f 83       	sub	r3,-8
80009d88:	c0 b8       	rjmp	80009d9e <_vfprintf_r+0x1b12>
80009d8a:	fa ca f9 78 	sub	r10,sp,-1672
80009d8e:	02 9b       	mov	r11,r1
80009d90:	08 9c       	mov	r12,r4
80009d92:	fe b0 f2 6f 	rcall	80008270 <__sprint_r>
80009d96:	e0 81 01 fa 	brne	8000a18a <_vfprintf_r+0x1efe>
80009d9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d9e:	40 6c       	lddsp	r12,sp[0x18]
80009da0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009da4:	87 06       	st.w	r3[0x0],r6
80009da6:	87 1c       	st.w	r3[0x4],r12
80009da8:	18 08       	add	r8,r12
80009daa:	cb 98       	rjmp	80009f1c <_vfprintf_r+0x1c90>
80009dac:	fa f9 06 90 	ld.w	r9,sp[1680]
80009db0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009db4:	40 6b       	lddsp	r11,sp[0x18]
80009db6:	16 3a       	cp.w	r10,r11
80009db8:	c6 f5       	brlt	80009e96 <_vfprintf_r+0x1c0a>
80009dba:	16 09       	add	r9,r11
80009dbc:	2f f8       	sub	r8,-1
80009dbe:	87 06       	st.w	r3[0x0],r6
80009dc0:	fb 49 06 90 	st.w	sp[1680],r9
80009dc4:	87 1b       	st.w	r3[0x4],r11
80009dc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dca:	58 78       	cp.w	r8,7
80009dcc:	e0 89 00 04 	brgt	80009dd4 <_vfprintf_r+0x1b48>
80009dd0:	2f 83       	sub	r3,-8
80009dd2:	c0 b8       	rjmp	80009de8 <_vfprintf_r+0x1b5c>
80009dd4:	fa ca f9 78 	sub	r10,sp,-1672
80009dd8:	02 9b       	mov	r11,r1
80009dda:	08 9c       	mov	r12,r4
80009ddc:	fe b0 f2 4a 	rcall	80008270 <__sprint_r>
80009de0:	e0 81 01 d5 	brne	8000a18a <_vfprintf_r+0x1efe>
80009de4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009de8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009dec:	40 6a       	lddsp	r10,sp[0x18]
80009dee:	14 16       	sub	r6,r10
80009df0:	58 06       	cp.w	r6,0
80009df2:	e0 89 00 1c 	brgt	80009e2a <_vfprintf_r+0x1b9e>
80009df6:	c3 d8       	rjmp	80009e70 <_vfprintf_r+0x1be4>
80009df8:	2f 09       	sub	r9,-16
80009dfa:	2f f8       	sub	r8,-1
80009dfc:	fb 49 06 90 	st.w	sp[1680],r9
80009e00:	87 02       	st.w	r3[0x0],r2
80009e02:	87 10       	st.w	r3[0x4],r0
80009e04:	fb 48 06 8c 	st.w	sp[1676],r8
80009e08:	58 78       	cp.w	r8,7
80009e0a:	e0 89 00 04 	brgt	80009e12 <_vfprintf_r+0x1b86>
80009e0e:	2f 83       	sub	r3,-8
80009e10:	c0 b8       	rjmp	80009e26 <_vfprintf_r+0x1b9a>
80009e12:	fa ca f9 78 	sub	r10,sp,-1672
80009e16:	02 9b       	mov	r11,r1
80009e18:	08 9c       	mov	r12,r4
80009e1a:	fe b0 f2 2b 	rcall	80008270 <__sprint_r>
80009e1e:	e0 81 01 b6 	brne	8000a18a <_vfprintf_r+0x1efe>
80009e22:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e26:	21 06       	sub	r6,16
80009e28:	c0 48       	rjmp	80009e30 <_vfprintf_r+0x1ba4>
80009e2a:	fe c2 bc ba 	sub	r2,pc,-17222
80009e2e:	31 00       	mov	r0,16
80009e30:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e38:	fe ca bc c8 	sub	r10,pc,-17208
80009e3c:	59 06       	cp.w	r6,16
80009e3e:	fe 99 ff dd 	brgt	80009df8 <_vfprintf_r+0x1b6c>
80009e42:	0c 09       	add	r9,r6
80009e44:	2f f8       	sub	r8,-1
80009e46:	87 0a       	st.w	r3[0x0],r10
80009e48:	fb 49 06 90 	st.w	sp[1680],r9
80009e4c:	87 16       	st.w	r3[0x4],r6
80009e4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e52:	58 78       	cp.w	r8,7
80009e54:	e0 89 00 04 	brgt	80009e5c <_vfprintf_r+0x1bd0>
80009e58:	2f 83       	sub	r3,-8
80009e5a:	c0 b8       	rjmp	80009e70 <_vfprintf_r+0x1be4>
80009e5c:	fa ca f9 78 	sub	r10,sp,-1672
80009e60:	02 9b       	mov	r11,r1
80009e62:	08 9c       	mov	r12,r4
80009e64:	fe b0 f2 06 	rcall	80008270 <__sprint_r>
80009e68:	e0 81 01 91 	brne	8000a18a <_vfprintf_r+0x1efe>
80009e6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e70:	ed b5 00 00 	bld	r5,0x0
80009e74:	e0 81 01 20 	brne	8000a0b4 <_vfprintf_r+0x1e28>
80009e78:	40 c9       	lddsp	r9,sp[0x30]
80009e7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e7e:	2f f8       	sub	r8,-1
80009e80:	87 09       	st.w	r3[0x0],r9
80009e82:	fb 48 06 90 	st.w	sp[1680],r8
80009e86:	30 19       	mov	r9,1
80009e88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e8c:	87 19       	st.w	r3[0x4],r9
80009e8e:	2f f8       	sub	r8,-1
80009e90:	fb 48 06 8c 	st.w	sp[1676],r8
80009e94:	c0 29       	rjmp	8000a098 <_vfprintf_r+0x1e0c>
80009e96:	14 09       	add	r9,r10
80009e98:	2f f8       	sub	r8,-1
80009e9a:	fb 49 06 90 	st.w	sp[1680],r9
80009e9e:	87 06       	st.w	r3[0x0],r6
80009ea0:	87 1a       	st.w	r3[0x4],r10
80009ea2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ea6:	58 78       	cp.w	r8,7
80009ea8:	e0 89 00 04 	brgt	80009eb0 <_vfprintf_r+0x1c24>
80009eac:	2f 83       	sub	r3,-8
80009eae:	c0 b8       	rjmp	80009ec4 <_vfprintf_r+0x1c38>
80009eb0:	fa ca f9 78 	sub	r10,sp,-1672
80009eb4:	02 9b       	mov	r11,r1
80009eb6:	08 9c       	mov	r12,r4
80009eb8:	fe b0 f1 dc 	rcall	80008270 <__sprint_r>
80009ebc:	e0 81 01 67 	brne	8000a18a <_vfprintf_r+0x1efe>
80009ec0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ec4:	40 c8       	lddsp	r8,sp[0x30]
80009ec6:	87 08       	st.w	r3[0x0],r8
80009ec8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ecc:	2f f8       	sub	r8,-1
80009ece:	30 19       	mov	r9,1
80009ed0:	fb 48 06 90 	st.w	sp[1680],r8
80009ed4:	87 19       	st.w	r3[0x4],r9
80009ed6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eda:	2f f8       	sub	r8,-1
80009edc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ee0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009ee4:	58 78       	cp.w	r8,7
80009ee6:	e0 89 00 04 	brgt	80009eee <_vfprintf_r+0x1c62>
80009eea:	2f 83       	sub	r3,-8
80009eec:	c0 b8       	rjmp	80009f02 <_vfprintf_r+0x1c76>
80009eee:	fa ca f9 78 	sub	r10,sp,-1672
80009ef2:	02 9b       	mov	r11,r1
80009ef4:	08 9c       	mov	r12,r4
80009ef6:	fe b0 f1 bd 	rcall	80008270 <__sprint_r>
80009efa:	e0 81 01 48 	brne	8000a18a <_vfprintf_r+0x1efe>
80009efe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f02:	04 06       	add	r6,r2
80009f04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009f08:	87 06       	st.w	r3[0x0],r6
80009f0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f0e:	40 66       	lddsp	r6,sp[0x18]
80009f10:	40 6e       	lddsp	lr,sp[0x18]
80009f12:	10 16       	sub	r6,r8
80009f14:	f2 08 01 08 	sub	r8,r9,r8
80009f18:	87 16       	st.w	r3[0x4],r6
80009f1a:	1c 08       	add	r8,lr
80009f1c:	fb 48 06 90 	st.w	sp[1680],r8
80009f20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f24:	2f f8       	sub	r8,-1
80009f26:	fb 48 06 8c 	st.w	sp[1676],r8
80009f2a:	cb 78       	rjmp	8000a098 <_vfprintf_r+0x1e0c>
80009f2c:	40 6c       	lddsp	r12,sp[0x18]
80009f2e:	58 1c       	cp.w	r12,1
80009f30:	e0 89 00 06 	brgt	80009f3c <_vfprintf_r+0x1cb0>
80009f34:	ed b5 00 00 	bld	r5,0x0
80009f38:	e0 81 00 85 	brne	8000a042 <_vfprintf_r+0x1db6>
80009f3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f40:	2f f8       	sub	r8,-1
80009f42:	30 19       	mov	r9,1
80009f44:	fb 48 06 90 	st.w	sp[1680],r8
80009f48:	87 06       	st.w	r3[0x0],r6
80009f4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f4e:	87 19       	st.w	r3[0x4],r9
80009f50:	2f f8       	sub	r8,-1
80009f52:	fb 48 06 8c 	st.w	sp[1676],r8
80009f56:	58 78       	cp.w	r8,7
80009f58:	e0 89 00 04 	brgt	80009f60 <_vfprintf_r+0x1cd4>
80009f5c:	2f 83       	sub	r3,-8
80009f5e:	c0 b8       	rjmp	80009f74 <_vfprintf_r+0x1ce8>
80009f60:	fa ca f9 78 	sub	r10,sp,-1672
80009f64:	02 9b       	mov	r11,r1
80009f66:	08 9c       	mov	r12,r4
80009f68:	fe b0 f1 84 	rcall	80008270 <__sprint_r>
80009f6c:	e0 81 01 0f 	brne	8000a18a <_vfprintf_r+0x1efe>
80009f70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f74:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f78:	2f f8       	sub	r8,-1
80009f7a:	40 cb       	lddsp	r11,sp[0x30]
80009f7c:	fb 48 06 90 	st.w	sp[1680],r8
80009f80:	30 19       	mov	r9,1
80009f82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f86:	87 0b       	st.w	r3[0x0],r11
80009f88:	2f f8       	sub	r8,-1
80009f8a:	87 19       	st.w	r3[0x4],r9
80009f8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f90:	58 78       	cp.w	r8,7
80009f92:	e0 89 00 05 	brgt	80009f9c <_vfprintf_r+0x1d10>
80009f96:	2f 83       	sub	r3,-8
80009f98:	c0 c8       	rjmp	80009fb0 <_vfprintf_r+0x1d24>
80009f9a:	d7 03       	nop
80009f9c:	fa ca f9 78 	sub	r10,sp,-1672
80009fa0:	02 9b       	mov	r11,r1
80009fa2:	08 9c       	mov	r12,r4
80009fa4:	fe b0 f1 66 	rcall	80008270 <__sprint_r>
80009fa8:	e0 81 00 f1 	brne	8000a18a <_vfprintf_r+0x1efe>
80009fac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fb0:	30 08       	mov	r8,0
80009fb2:	30 09       	mov	r9,0
80009fb4:	40 5b       	lddsp	r11,sp[0x14]
80009fb6:	40 7a       	lddsp	r10,sp[0x1c]
80009fb8:	e0 a0 13 25 	rcall	8000c602 <__avr32_f64_cmp_eq>
80009fbc:	40 68       	lddsp	r8,sp[0x18]
80009fbe:	20 18       	sub	r8,1
80009fc0:	58 0c       	cp.w	r12,0
80009fc2:	c0 d1       	brne	80009fdc <_vfprintf_r+0x1d50>
80009fc4:	2f f6       	sub	r6,-1
80009fc6:	87 18       	st.w	r3[0x4],r8
80009fc8:	87 06       	st.w	r3[0x0],r6
80009fca:	fa f6 06 90 	ld.w	r6,sp[1680]
80009fce:	10 06       	add	r6,r8
80009fd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fd4:	fb 46 06 90 	st.w	sp[1680],r6
80009fd8:	2f f8       	sub	r8,-1
80009fda:	c3 18       	rjmp	8000a03c <_vfprintf_r+0x1db0>
80009fdc:	10 96       	mov	r6,r8
80009fde:	58 08       	cp.w	r8,0
80009fe0:	e0 89 00 1c 	brgt	8000a018 <_vfprintf_r+0x1d8c>
80009fe4:	c4 b8       	rjmp	8000a07a <_vfprintf_r+0x1dee>
80009fe6:	2f 09       	sub	r9,-16
80009fe8:	2f f8       	sub	r8,-1
80009fea:	fb 49 06 90 	st.w	sp[1680],r9
80009fee:	87 02       	st.w	r3[0x0],r2
80009ff0:	87 10       	st.w	r3[0x4],r0
80009ff2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ff6:	58 78       	cp.w	r8,7
80009ff8:	e0 89 00 04 	brgt	8000a000 <_vfprintf_r+0x1d74>
80009ffc:	2f 83       	sub	r3,-8
80009ffe:	c0 b8       	rjmp	8000a014 <_vfprintf_r+0x1d88>
8000a000:	fa ca f9 78 	sub	r10,sp,-1672
8000a004:	02 9b       	mov	r11,r1
8000a006:	08 9c       	mov	r12,r4
8000a008:	fe b0 f1 34 	rcall	80008270 <__sprint_r>
8000a00c:	e0 81 00 bf 	brne	8000a18a <_vfprintf_r+0x1efe>
8000a010:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a014:	21 06       	sub	r6,16
8000a016:	c0 48       	rjmp	8000a01e <_vfprintf_r+0x1d92>
8000a018:	fe c2 be a8 	sub	r2,pc,-16728
8000a01c:	31 00       	mov	r0,16
8000a01e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a022:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a026:	fe ca be b6 	sub	r10,pc,-16714
8000a02a:	59 06       	cp.w	r6,16
8000a02c:	fe 99 ff dd 	brgt	80009fe6 <_vfprintf_r+0x1d5a>
8000a030:	0c 09       	add	r9,r6
8000a032:	87 0a       	st.w	r3[0x0],r10
8000a034:	fb 49 06 90 	st.w	sp[1680],r9
8000a038:	2f f8       	sub	r8,-1
8000a03a:	87 16       	st.w	r3[0x4],r6
8000a03c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a040:	c0 e8       	rjmp	8000a05c <_vfprintf_r+0x1dd0>
8000a042:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a046:	2f f8       	sub	r8,-1
8000a048:	30 19       	mov	r9,1
8000a04a:	fb 48 06 90 	st.w	sp[1680],r8
8000a04e:	87 06       	st.w	r3[0x0],r6
8000a050:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a054:	87 19       	st.w	r3[0x4],r9
8000a056:	2f f8       	sub	r8,-1
8000a058:	fb 48 06 8c 	st.w	sp[1676],r8
8000a05c:	58 78       	cp.w	r8,7
8000a05e:	e0 89 00 04 	brgt	8000a066 <_vfprintf_r+0x1dda>
8000a062:	2f 83       	sub	r3,-8
8000a064:	c0 b8       	rjmp	8000a07a <_vfprintf_r+0x1dee>
8000a066:	fa ca f9 78 	sub	r10,sp,-1672
8000a06a:	02 9b       	mov	r11,r1
8000a06c:	08 9c       	mov	r12,r4
8000a06e:	fe b0 f1 01 	rcall	80008270 <__sprint_r>
8000a072:	e0 81 00 8c 	brne	8000a18a <_vfprintf_r+0x1efe>
8000a076:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a07a:	40 ea       	lddsp	r10,sp[0x38]
8000a07c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a080:	14 08       	add	r8,r10
8000a082:	fa c9 f9 64 	sub	r9,sp,-1692
8000a086:	fb 48 06 90 	st.w	sp[1680],r8
8000a08a:	87 1a       	st.w	r3[0x4],r10
8000a08c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a090:	87 09       	st.w	r3[0x0],r9
8000a092:	2f f8       	sub	r8,-1
8000a094:	fb 48 06 8c 	st.w	sp[1676],r8
8000a098:	58 78       	cp.w	r8,7
8000a09a:	e0 89 00 04 	brgt	8000a0a2 <_vfprintf_r+0x1e16>
8000a09e:	2f 83       	sub	r3,-8
8000a0a0:	c0 a8       	rjmp	8000a0b4 <_vfprintf_r+0x1e28>
8000a0a2:	fa ca f9 78 	sub	r10,sp,-1672
8000a0a6:	02 9b       	mov	r11,r1
8000a0a8:	08 9c       	mov	r12,r4
8000a0aa:	fe b0 f0 e3 	rcall	80008270 <__sprint_r>
8000a0ae:	c6 e1       	brne	8000a18a <_vfprintf_r+0x1efe>
8000a0b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0b4:	e2 15 00 04 	andl	r5,0x4,COH
8000a0b8:	c3 f0       	breq	8000a136 <_vfprintf_r+0x1eaa>
8000a0ba:	40 86       	lddsp	r6,sp[0x20]
8000a0bc:	40 39       	lddsp	r9,sp[0xc]
8000a0be:	12 16       	sub	r6,r9
8000a0c0:	58 06       	cp.w	r6,0
8000a0c2:	e0 89 00 1a 	brgt	8000a0f6 <_vfprintf_r+0x1e6a>
8000a0c6:	c3 88       	rjmp	8000a136 <_vfprintf_r+0x1eaa>
8000a0c8:	2f 09       	sub	r9,-16
8000a0ca:	2f f8       	sub	r8,-1
8000a0cc:	fb 49 06 90 	st.w	sp[1680],r9
8000a0d0:	87 05       	st.w	r3[0x0],r5
8000a0d2:	87 12       	st.w	r3[0x4],r2
8000a0d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0d8:	58 78       	cp.w	r8,7
8000a0da:	e0 89 00 04 	brgt	8000a0e2 <_vfprintf_r+0x1e56>
8000a0de:	2f 83       	sub	r3,-8
8000a0e0:	c0 98       	rjmp	8000a0f2 <_vfprintf_r+0x1e66>
8000a0e2:	00 9a       	mov	r10,r0
8000a0e4:	02 9b       	mov	r11,r1
8000a0e6:	08 9c       	mov	r12,r4
8000a0e8:	fe b0 f0 c4 	rcall	80008270 <__sprint_r>
8000a0ec:	c4 f1       	brne	8000a18a <_vfprintf_r+0x1efe>
8000a0ee:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0f2:	21 06       	sub	r6,16
8000a0f4:	c0 68       	rjmp	8000a100 <_vfprintf_r+0x1e74>
8000a0f6:	fe c5 bf 96 	sub	r5,pc,-16490
8000a0fa:	31 02       	mov	r2,16
8000a0fc:	fa c0 f9 78 	sub	r0,sp,-1672
8000a100:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a104:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a108:	fe ca bf a8 	sub	r10,pc,-16472
8000a10c:	59 06       	cp.w	r6,16
8000a10e:	fe 99 ff dd 	brgt	8000a0c8 <_vfprintf_r+0x1e3c>
8000a112:	0c 09       	add	r9,r6
8000a114:	2f f8       	sub	r8,-1
8000a116:	87 0a       	st.w	r3[0x0],r10
8000a118:	87 16       	st.w	r3[0x4],r6
8000a11a:	fb 49 06 90 	st.w	sp[1680],r9
8000a11e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a122:	58 78       	cp.w	r8,7
8000a124:	e0 8a 00 09 	brle	8000a136 <_vfprintf_r+0x1eaa>
8000a128:	fa ca f9 78 	sub	r10,sp,-1672
8000a12c:	02 9b       	mov	r11,r1
8000a12e:	08 9c       	mov	r12,r4
8000a130:	fe b0 f0 a0 	rcall	80008270 <__sprint_r>
8000a134:	c2 b1       	brne	8000a18a <_vfprintf_r+0x1efe>
8000a136:	40 bc       	lddsp	r12,sp[0x2c]
8000a138:	40 36       	lddsp	r6,sp[0xc]
8000a13a:	40 8e       	lddsp	lr,sp[0x20]
8000a13c:	ec 0e 0c 48 	max	r8,r6,lr
8000a140:	10 0c       	add	r12,r8
8000a142:	50 bc       	stdsp	sp[0x2c],r12
8000a144:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a148:	58 08       	cp.w	r8,0
8000a14a:	c0 80       	breq	8000a15a <_vfprintf_r+0x1ece>
8000a14c:	fa ca f9 78 	sub	r10,sp,-1672
8000a150:	02 9b       	mov	r11,r1
8000a152:	08 9c       	mov	r12,r4
8000a154:	fe b0 f0 8e 	rcall	80008270 <__sprint_r>
8000a158:	c1 91       	brne	8000a18a <_vfprintf_r+0x1efe>
8000a15a:	30 0b       	mov	r11,0
8000a15c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a160:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a164:	fe 9f f1 22 	bral	800083a8 <_vfprintf_r+0x11c>
8000a168:	08 95       	mov	r5,r4
8000a16a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a16e:	58 08       	cp.w	r8,0
8000a170:	c0 80       	breq	8000a180 <_vfprintf_r+0x1ef4>
8000a172:	08 9c       	mov	r12,r4
8000a174:	fa ca f9 78 	sub	r10,sp,-1672
8000a178:	02 9b       	mov	r11,r1
8000a17a:	fe b0 f0 7b 	rcall	80008270 <__sprint_r>
8000a17e:	c0 61       	brne	8000a18a <_vfprintf_r+0x1efe>
8000a180:	30 08       	mov	r8,0
8000a182:	fb 48 06 8c 	st.w	sp[1676],r8
8000a186:	c0 28       	rjmp	8000a18a <_vfprintf_r+0x1efe>
8000a188:	40 41       	lddsp	r1,sp[0x10]
8000a18a:	82 68       	ld.sh	r8,r1[0xc]
8000a18c:	ed b8 00 06 	bld	r8,0x6
8000a190:	c0 31       	brne	8000a196 <_vfprintf_r+0x1f0a>
8000a192:	3f fa       	mov	r10,-1
8000a194:	50 ba       	stdsp	sp[0x2c],r10
8000a196:	40 bc       	lddsp	r12,sp[0x2c]
8000a198:	fe 3d f9 44 	sub	sp,-1724
8000a19c:	d8 32       	popm	r0-r7,pc
8000a19e:	d7 03       	nop

8000a1a0 <__swsetup_r>:
8000a1a0:	d4 21       	pushm	r4-r7,lr
8000a1a2:	e0 68 0a 48 	mov	r8,2632
8000a1a6:	18 96       	mov	r6,r12
8000a1a8:	16 97       	mov	r7,r11
8000a1aa:	70 0c       	ld.w	r12,r8[0x0]
8000a1ac:	58 0c       	cp.w	r12,0
8000a1ae:	c0 60       	breq	8000a1ba <__swsetup_r+0x1a>
8000a1b0:	78 68       	ld.w	r8,r12[0x18]
8000a1b2:	58 08       	cp.w	r8,0
8000a1b4:	c0 31       	brne	8000a1ba <__swsetup_r+0x1a>
8000a1b6:	e0 a0 07 bf 	rcall	8000b134 <__sinit>
8000a1ba:	fe c8 bf 2a 	sub	r8,pc,-16598
8000a1be:	10 37       	cp.w	r7,r8
8000a1c0:	c0 61       	brne	8000a1cc <__swsetup_r+0x2c>
8000a1c2:	e0 68 0a 48 	mov	r8,2632
8000a1c6:	70 08       	ld.w	r8,r8[0x0]
8000a1c8:	70 07       	ld.w	r7,r8[0x0]
8000a1ca:	c1 28       	rjmp	8000a1ee <__swsetup_r+0x4e>
8000a1cc:	fe c8 bf 1c 	sub	r8,pc,-16612
8000a1d0:	10 37       	cp.w	r7,r8
8000a1d2:	c0 61       	brne	8000a1de <__swsetup_r+0x3e>
8000a1d4:	e0 68 0a 48 	mov	r8,2632
8000a1d8:	70 08       	ld.w	r8,r8[0x0]
8000a1da:	70 17       	ld.w	r7,r8[0x4]
8000a1dc:	c0 98       	rjmp	8000a1ee <__swsetup_r+0x4e>
8000a1de:	fe c8 bf 0e 	sub	r8,pc,-16626
8000a1e2:	10 37       	cp.w	r7,r8
8000a1e4:	c0 51       	brne	8000a1ee <__swsetup_r+0x4e>
8000a1e6:	e0 68 0a 48 	mov	r8,2632
8000a1ea:	70 08       	ld.w	r8,r8[0x0]
8000a1ec:	70 27       	ld.w	r7,r8[0x8]
8000a1ee:	8e 68       	ld.sh	r8,r7[0xc]
8000a1f0:	ed b8 00 03 	bld	r8,0x3
8000a1f4:	c1 e0       	breq	8000a230 <__swsetup_r+0x90>
8000a1f6:	ed b8 00 04 	bld	r8,0x4
8000a1fa:	c3 e1       	brne	8000a276 <__swsetup_r+0xd6>
8000a1fc:	ed b8 00 02 	bld	r8,0x2
8000a200:	c1 51       	brne	8000a22a <__swsetup_r+0x8a>
8000a202:	6e db       	ld.w	r11,r7[0x34]
8000a204:	58 0b       	cp.w	r11,0
8000a206:	c0 a0       	breq	8000a21a <__swsetup_r+0x7a>
8000a208:	ee c8 ff bc 	sub	r8,r7,-68
8000a20c:	10 3b       	cp.w	r11,r8
8000a20e:	c0 40       	breq	8000a216 <__swsetup_r+0x76>
8000a210:	0c 9c       	mov	r12,r6
8000a212:	e0 a0 08 2b 	rcall	8000b268 <_free_r>
8000a216:	30 08       	mov	r8,0
8000a218:	8f d8       	st.w	r7[0x34],r8
8000a21a:	8e 68       	ld.sh	r8,r7[0xc]
8000a21c:	e0 18 ff db 	andl	r8,0xffdb
8000a220:	ae 68       	st.h	r7[0xc],r8
8000a222:	30 08       	mov	r8,0
8000a224:	8f 18       	st.w	r7[0x4],r8
8000a226:	6e 48       	ld.w	r8,r7[0x10]
8000a228:	8f 08       	st.w	r7[0x0],r8
8000a22a:	8e 68       	ld.sh	r8,r7[0xc]
8000a22c:	a3 b8       	sbr	r8,0x3
8000a22e:	ae 68       	st.h	r7[0xc],r8
8000a230:	6e 48       	ld.w	r8,r7[0x10]
8000a232:	58 08       	cp.w	r8,0
8000a234:	c0 b1       	brne	8000a24a <__swsetup_r+0xaa>
8000a236:	8e 68       	ld.sh	r8,r7[0xc]
8000a238:	e2 18 02 80 	andl	r8,0x280,COH
8000a23c:	e0 48 02 00 	cp.w	r8,512
8000a240:	c0 50       	breq	8000a24a <__swsetup_r+0xaa>
8000a242:	0c 9c       	mov	r12,r6
8000a244:	0e 9b       	mov	r11,r7
8000a246:	e0 a0 0a 4b 	rcall	8000b6dc <__smakebuf_r>
8000a24a:	8e 69       	ld.sh	r9,r7[0xc]
8000a24c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a250:	c0 70       	breq	8000a25e <__swsetup_r+0xbe>
8000a252:	30 08       	mov	r8,0
8000a254:	8f 28       	st.w	r7[0x8],r8
8000a256:	6e 58       	ld.w	r8,r7[0x14]
8000a258:	5c 38       	neg	r8
8000a25a:	8f 68       	st.w	r7[0x18],r8
8000a25c:	c0 68       	rjmp	8000a268 <__swsetup_r+0xc8>
8000a25e:	ed b9 00 01 	bld	r9,0x1
8000a262:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a266:	8f 28       	st.w	r7[0x8],r8
8000a268:	6e 48       	ld.w	r8,r7[0x10]
8000a26a:	58 08       	cp.w	r8,0
8000a26c:	c0 61       	brne	8000a278 <__swsetup_r+0xd8>
8000a26e:	8e 68       	ld.sh	r8,r7[0xc]
8000a270:	ed b8 00 07 	bld	r8,0x7
8000a274:	c0 21       	brne	8000a278 <__swsetup_r+0xd8>
8000a276:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a278:	d8 2a       	popm	r4-r7,pc,r12=0
8000a27a:	d7 03       	nop

8000a27c <quorem>:
8000a27c:	d4 31       	pushm	r0-r7,lr
8000a27e:	20 2d       	sub	sp,8
8000a280:	18 97       	mov	r7,r12
8000a282:	78 48       	ld.w	r8,r12[0x10]
8000a284:	76 46       	ld.w	r6,r11[0x10]
8000a286:	0c 38       	cp.w	r8,r6
8000a288:	c0 34       	brge	8000a28e <quorem+0x12>
8000a28a:	30 0c       	mov	r12,0
8000a28c:	c8 58       	rjmp	8000a396 <quorem+0x11a>
8000a28e:	ec c2 ff fc 	sub	r2,r6,-4
8000a292:	f6 c3 ff ec 	sub	r3,r11,-20
8000a296:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a29a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a29e:	2f f9       	sub	r9,-1
8000a2a0:	20 16       	sub	r6,1
8000a2a2:	f8 09 0d 08 	divu	r8,r12,r9
8000a2a6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a2aa:	ee c4 ff ec 	sub	r4,r7,-20
8000a2ae:	10 95       	mov	r5,r8
8000a2b0:	58 08       	cp.w	r8,0
8000a2b2:	c4 10       	breq	8000a334 <quorem+0xb8>
8000a2b4:	30 09       	mov	r9,0
8000a2b6:	06 9a       	mov	r10,r3
8000a2b8:	08 98       	mov	r8,r4
8000a2ba:	12 91       	mov	r1,r9
8000a2bc:	50 0b       	stdsp	sp[0x0],r11
8000a2be:	70 0e       	ld.w	lr,r8[0x0]
8000a2c0:	b1 8e       	lsr	lr,0x10
8000a2c2:	50 1e       	stdsp	sp[0x4],lr
8000a2c4:	15 0e       	ld.w	lr,r10++
8000a2c6:	fc 00 16 10 	lsr	r0,lr,0x10
8000a2ca:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a2ce:	ea 0e 03 41 	mac	r1,r5,lr
8000a2d2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a2d6:	b1 81       	lsr	r1,0x10
8000a2d8:	40 1b       	lddsp	r11,sp[0x4]
8000a2da:	ea 00 02 40 	mul	r0,r5,r0
8000a2de:	e2 00 00 00 	add	r0,r1,r0
8000a2e2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a2e6:	02 1b       	sub	r11,r1
8000a2e8:	50 1b       	stdsp	sp[0x4],r11
8000a2ea:	70 0b       	ld.w	r11,r8[0x0]
8000a2ec:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a2f0:	02 09       	add	r9,r1
8000a2f2:	f2 0e 01 0e 	sub	lr,r9,lr
8000a2f6:	b0 1e       	st.h	r8[0x2],lr
8000a2f8:	fc 09 14 10 	asr	r9,lr,0x10
8000a2fc:	40 1e       	lddsp	lr,sp[0x4]
8000a2fe:	fc 09 00 09 	add	r9,lr,r9
8000a302:	b0 09       	st.h	r8[0x0],r9
8000a304:	e0 01 16 10 	lsr	r1,r0,0x10
8000a308:	2f c8       	sub	r8,-4
8000a30a:	b1 49       	asr	r9,0x10
8000a30c:	04 3a       	cp.w	r10,r2
8000a30e:	fe 98 ff d8 	brls	8000a2be <quorem+0x42>
8000a312:	40 0b       	lddsp	r11,sp[0x0]
8000a314:	58 0c       	cp.w	r12,0
8000a316:	c0 f1       	brne	8000a334 <quorem+0xb8>
8000a318:	ec c8 ff fb 	sub	r8,r6,-5
8000a31c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a320:	c0 28       	rjmp	8000a324 <quorem+0xa8>
8000a322:	20 16       	sub	r6,1
8000a324:	20 48       	sub	r8,4
8000a326:	08 38       	cp.w	r8,r4
8000a328:	e0 88 00 05 	brls	8000a332 <quorem+0xb6>
8000a32c:	70 09       	ld.w	r9,r8[0x0]
8000a32e:	58 09       	cp.w	r9,0
8000a330:	cf 90       	breq	8000a322 <quorem+0xa6>
8000a332:	8f 46       	st.w	r7[0x10],r6
8000a334:	0e 9c       	mov	r12,r7
8000a336:	e0 a0 0a d2 	rcall	8000b8da <__mcmp>
8000a33a:	c2 d5       	brlt	8000a394 <quorem+0x118>
8000a33c:	2f f5       	sub	r5,-1
8000a33e:	08 98       	mov	r8,r4
8000a340:	30 09       	mov	r9,0
8000a342:	07 0b       	ld.w	r11,r3++
8000a344:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a348:	70 0c       	ld.w	r12,r8[0x0]
8000a34a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a34e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a352:	14 1e       	sub	lr,r10
8000a354:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a358:	16 1a       	sub	r10,r11
8000a35a:	12 0a       	add	r10,r9
8000a35c:	b0 1a       	st.h	r8[0x2],r10
8000a35e:	b1 4a       	asr	r10,0x10
8000a360:	fc 0a 00 09 	add	r9,lr,r10
8000a364:	b0 09       	st.h	r8[0x0],r9
8000a366:	2f c8       	sub	r8,-4
8000a368:	b1 49       	asr	r9,0x10
8000a36a:	04 33       	cp.w	r3,r2
8000a36c:	fe 98 ff eb 	brls	8000a342 <quorem+0xc6>
8000a370:	ec c8 ff fb 	sub	r8,r6,-5
8000a374:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a378:	58 09       	cp.w	r9,0
8000a37a:	c0 d1       	brne	8000a394 <quorem+0x118>
8000a37c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a380:	c0 28       	rjmp	8000a384 <quorem+0x108>
8000a382:	20 16       	sub	r6,1
8000a384:	20 48       	sub	r8,4
8000a386:	08 38       	cp.w	r8,r4
8000a388:	e0 88 00 05 	brls	8000a392 <quorem+0x116>
8000a38c:	70 09       	ld.w	r9,r8[0x0]
8000a38e:	58 09       	cp.w	r9,0
8000a390:	cf 90       	breq	8000a382 <quorem+0x106>
8000a392:	8f 46       	st.w	r7[0x10],r6
8000a394:	0a 9c       	mov	r12,r5
8000a396:	2f ed       	sub	sp,-8
8000a398:	d8 32       	popm	r0-r7,pc
8000a39a:	d7 03       	nop

8000a39c <_dtoa_r>:
8000a39c:	d4 31       	pushm	r0-r7,lr
8000a39e:	21 ad       	sub	sp,104
8000a3a0:	fa c4 ff 74 	sub	r4,sp,-140
8000a3a4:	18 97       	mov	r7,r12
8000a3a6:	16 95       	mov	r5,r11
8000a3a8:	68 2c       	ld.w	r12,r4[0x8]
8000a3aa:	50 c9       	stdsp	sp[0x30],r9
8000a3ac:	68 16       	ld.w	r6,r4[0x4]
8000a3ae:	68 09       	ld.w	r9,r4[0x0]
8000a3b0:	50 e8       	stdsp	sp[0x38],r8
8000a3b2:	14 94       	mov	r4,r10
8000a3b4:	51 2c       	stdsp	sp[0x48],r12
8000a3b6:	fa e5 00 08 	st.d	sp[8],r4
8000a3ba:	51 59       	stdsp	sp[0x54],r9
8000a3bc:	6e 95       	ld.w	r5,r7[0x24]
8000a3be:	58 05       	cp.w	r5,0
8000a3c0:	c0 91       	brne	8000a3d2 <_dtoa_r+0x36>
8000a3c2:	31 0c       	mov	r12,16
8000a3c4:	fe b0 e8 e2 	rcall	80007588 <malloc>
8000a3c8:	99 35       	st.w	r12[0xc],r5
8000a3ca:	8f 9c       	st.w	r7[0x24],r12
8000a3cc:	99 15       	st.w	r12[0x4],r5
8000a3ce:	99 25       	st.w	r12[0x8],r5
8000a3d0:	99 05       	st.w	r12[0x0],r5
8000a3d2:	6e 99       	ld.w	r9,r7[0x24]
8000a3d4:	72 08       	ld.w	r8,r9[0x0]
8000a3d6:	58 08       	cp.w	r8,0
8000a3d8:	c0 f0       	breq	8000a3f6 <_dtoa_r+0x5a>
8000a3da:	72 1a       	ld.w	r10,r9[0x4]
8000a3dc:	91 1a       	st.w	r8[0x4],r10
8000a3de:	30 1a       	mov	r10,1
8000a3e0:	72 19       	ld.w	r9,r9[0x4]
8000a3e2:	f4 09 09 49 	lsl	r9,r10,r9
8000a3e6:	10 9b       	mov	r11,r8
8000a3e8:	91 29       	st.w	r8[0x8],r9
8000a3ea:	0e 9c       	mov	r12,r7
8000a3ec:	e0 a0 0a 90 	rcall	8000b90c <_Bfree>
8000a3f0:	6e 98       	ld.w	r8,r7[0x24]
8000a3f2:	30 09       	mov	r9,0
8000a3f4:	91 09       	st.w	r8[0x0],r9
8000a3f6:	40 28       	lddsp	r8,sp[0x8]
8000a3f8:	10 94       	mov	r4,r8
8000a3fa:	58 08       	cp.w	r8,0
8000a3fc:	c0 64       	brge	8000a408 <_dtoa_r+0x6c>
8000a3fe:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a402:	50 28       	stdsp	sp[0x8],r8
8000a404:	30 18       	mov	r8,1
8000a406:	c0 28       	rjmp	8000a40a <_dtoa_r+0x6e>
8000a408:	30 08       	mov	r8,0
8000a40a:	8d 08       	st.w	r6[0x0],r8
8000a40c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a410:	40 26       	lddsp	r6,sp[0x8]
8000a412:	0c 98       	mov	r8,r6
8000a414:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a418:	18 38       	cp.w	r8,r12
8000a41a:	c2 01       	brne	8000a45a <_dtoa_r+0xbe>
8000a41c:	e0 68 27 0f 	mov	r8,9999
8000a420:	41 5b       	lddsp	r11,sp[0x54]
8000a422:	97 08       	st.w	r11[0x0],r8
8000a424:	40 3a       	lddsp	r10,sp[0xc]
8000a426:	58 0a       	cp.w	r10,0
8000a428:	c0 71       	brne	8000a436 <_dtoa_r+0x9a>
8000a42a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a42e:	c0 41       	brne	8000a436 <_dtoa_r+0x9a>
8000a430:	fe cc c1 b0 	sub	r12,pc,-15952
8000a434:	c0 38       	rjmp	8000a43a <_dtoa_r+0x9e>
8000a436:	fe cc c1 aa 	sub	r12,pc,-15958
8000a43a:	41 29       	lddsp	r9,sp[0x48]
8000a43c:	58 09       	cp.w	r9,0
8000a43e:	e0 80 05 9a 	breq	8000af72 <_dtoa_r+0xbd6>
8000a442:	f8 c8 ff fd 	sub	r8,r12,-3
8000a446:	f8 c9 ff f8 	sub	r9,r12,-8
8000a44a:	11 8b       	ld.ub	r11,r8[0x0]
8000a44c:	30 0a       	mov	r10,0
8000a44e:	41 25       	lddsp	r5,sp[0x48]
8000a450:	f4 0b 18 00 	cp.b	r11,r10
8000a454:	f2 08 17 10 	movne	r8,r9
8000a458:	c1 68       	rjmp	8000a484 <_dtoa_r+0xe8>
8000a45a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a45e:	30 08       	mov	r8,0
8000a460:	fa eb 00 3c 	st.d	sp[60],r10
8000a464:	30 09       	mov	r9,0
8000a466:	e0 a0 10 ce 	rcall	8000c602 <__avr32_f64_cmp_eq>
8000a46a:	c1 00       	breq	8000a48a <_dtoa_r+0xee>
8000a46c:	30 18       	mov	r8,1
8000a46e:	41 5a       	lddsp	r10,sp[0x54]
8000a470:	95 08       	st.w	r10[0x0],r8
8000a472:	fe cc c3 16 	sub	r12,pc,-15594
8000a476:	41 29       	lddsp	r9,sp[0x48]
8000a478:	f8 08 00 08 	add	r8,r12,r8
8000a47c:	58 09       	cp.w	r9,0
8000a47e:	e0 80 05 7a 	breq	8000af72 <_dtoa_r+0xbd6>
8000a482:	12 95       	mov	r5,r9
8000a484:	8b 08       	st.w	r5[0x0],r8
8000a486:	e0 8f 05 76 	bral	8000af72 <_dtoa_r+0xbd6>
8000a48a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a48e:	fa c9 ff a0 	sub	r9,sp,-96
8000a492:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a496:	0e 9c       	mov	r12,r7
8000a498:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a49c:	e0 a0 0a 8a 	rcall	8000b9b0 <__d2b>
8000a4a0:	18 93       	mov	r3,r12
8000a4a2:	58 05       	cp.w	r5,0
8000a4a4:	c0 d0       	breq	8000a4be <_dtoa_r+0x122>
8000a4a6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4aa:	30 04       	mov	r4,0
8000a4ac:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a4b0:	ea c5 03 ff 	sub	r5,r5,1023
8000a4b4:	10 9b       	mov	r11,r8
8000a4b6:	51 74       	stdsp	sp[0x5c],r4
8000a4b8:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a4bc:	c2 58       	rjmp	8000a506 <_dtoa_r+0x16a>
8000a4be:	41 88       	lddsp	r8,sp[0x60]
8000a4c0:	41 9c       	lddsp	r12,sp[0x64]
8000a4c2:	10 0c       	add	r12,r8
8000a4c4:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a4c8:	e0 45 00 20 	cp.w	r5,32
8000a4cc:	e0 8a 00 0e 	brle	8000a4e8 <_dtoa_r+0x14c>
8000a4d0:	f8 cc fb ee 	sub	r12,r12,-1042
8000a4d4:	40 3b       	lddsp	r11,sp[0xc]
8000a4d6:	ea 08 11 40 	rsub	r8,r5,64
8000a4da:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a4de:	ec 08 09 46 	lsl	r6,r6,r8
8000a4e2:	0c 4c       	or	r12,r6
8000a4e4:	c0 78       	rjmp	8000a4f2 <_dtoa_r+0x156>
8000a4e6:	d7 03       	nop
8000a4e8:	ea 0c 11 20 	rsub	r12,r5,32
8000a4ec:	40 3a       	lddsp	r10,sp[0xc]
8000a4ee:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a4f2:	e0 a0 10 14 	rcall	8000c51a <__avr32_u32_to_f64>
8000a4f6:	fc 18 fe 10 	movh	r8,0xfe10
8000a4fa:	30 19       	mov	r9,1
8000a4fc:	ea c5 04 33 	sub	r5,r5,1075
8000a500:	f0 0b 00 0b 	add	r11,r8,r11
8000a504:	51 79       	stdsp	sp[0x5c],r9
8000a506:	30 08       	mov	r8,0
8000a508:	fc 19 3f f8 	movh	r9,0x3ff8
8000a50c:	e0 a0 0e 9c 	rcall	8000c244 <__avr32_f64_sub>
8000a510:	e0 68 43 61 	mov	r8,17249
8000a514:	ea 18 63 6f 	orh	r8,0x636f
8000a518:	e0 69 87 a7 	mov	r9,34727
8000a51c:	ea 19 3f d2 	orh	r9,0x3fd2
8000a520:	e0 a0 0d a6 	rcall	8000c06c <__avr32_f64_mul>
8000a524:	e0 68 c8 b3 	mov	r8,51379
8000a528:	ea 18 8b 60 	orh	r8,0x8b60
8000a52c:	e0 69 8a 28 	mov	r9,35368
8000a530:	ea 19 3f c6 	orh	r9,0x3fc6
8000a534:	e0 a0 0f 56 	rcall	8000c3e0 <__avr32_f64_add>
8000a538:	0a 9c       	mov	r12,r5
8000a53a:	14 90       	mov	r0,r10
8000a53c:	16 91       	mov	r1,r11
8000a53e:	e0 a0 0f f2 	rcall	8000c522 <__avr32_s32_to_f64>
8000a542:	e0 68 79 fb 	mov	r8,31227
8000a546:	ea 18 50 9f 	orh	r8,0x509f
8000a54a:	e0 69 44 13 	mov	r9,17427
8000a54e:	ea 19 3f d3 	orh	r9,0x3fd3
8000a552:	e0 a0 0d 8d 	rcall	8000c06c <__avr32_f64_mul>
8000a556:	14 98       	mov	r8,r10
8000a558:	16 99       	mov	r9,r11
8000a55a:	00 9a       	mov	r10,r0
8000a55c:	02 9b       	mov	r11,r1
8000a55e:	e0 a0 0f 41 	rcall	8000c3e0 <__avr32_f64_add>
8000a562:	14 90       	mov	r0,r10
8000a564:	16 91       	mov	r1,r11
8000a566:	e0 a0 0f c7 	rcall	8000c4f4 <__avr32_f64_to_s32>
8000a56a:	30 08       	mov	r8,0
8000a56c:	18 96       	mov	r6,r12
8000a56e:	30 09       	mov	r9,0
8000a570:	00 9a       	mov	r10,r0
8000a572:	02 9b       	mov	r11,r1
8000a574:	e0 a0 10 8e 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a578:	c0 c0       	breq	8000a590 <_dtoa_r+0x1f4>
8000a57a:	0c 9c       	mov	r12,r6
8000a57c:	e0 a0 0f d3 	rcall	8000c522 <__avr32_s32_to_f64>
8000a580:	14 98       	mov	r8,r10
8000a582:	16 99       	mov	r9,r11
8000a584:	00 9a       	mov	r10,r0
8000a586:	02 9b       	mov	r11,r1
8000a588:	e0 a0 10 3d 	rcall	8000c602 <__avr32_f64_cmp_eq>
8000a58c:	f7 b6 00 01 	subeq	r6,1
8000a590:	59 66       	cp.w	r6,22
8000a592:	e0 88 00 05 	brls	8000a59c <_dtoa_r+0x200>
8000a596:	30 18       	mov	r8,1
8000a598:	51 48       	stdsp	sp[0x50],r8
8000a59a:	c1 38       	rjmp	8000a5c0 <_dtoa_r+0x224>
8000a59c:	fe c8 c2 5c 	sub	r8,pc,-15780
8000a5a0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5a4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a5a8:	e0 a0 10 74 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a5ac:	f9 b4 00 00 	moveq	r4,0
8000a5b0:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a5b4:	f7 b6 01 01 	subne	r6,1
8000a5b8:	f9 bc 01 00 	movne	r12,0
8000a5bc:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a5c0:	41 90       	lddsp	r0,sp[0x64]
8000a5c2:	20 10       	sub	r0,1
8000a5c4:	0a 10       	sub	r0,r5
8000a5c6:	c0 46       	brmi	8000a5ce <_dtoa_r+0x232>
8000a5c8:	50 40       	stdsp	sp[0x10],r0
8000a5ca:	30 00       	mov	r0,0
8000a5cc:	c0 48       	rjmp	8000a5d4 <_dtoa_r+0x238>
8000a5ce:	30 0b       	mov	r11,0
8000a5d0:	5c 30       	neg	r0
8000a5d2:	50 4b       	stdsp	sp[0x10],r11
8000a5d4:	ec 02 11 00 	rsub	r2,r6,0
8000a5d8:	58 06       	cp.w	r6,0
8000a5da:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a5de:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a5e2:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a5e6:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a5ea:	f9 b2 04 00 	movge	r2,0
8000a5ee:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a5f2:	f9 b9 05 00 	movlt	r9,0
8000a5f6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a5fa:	40 c8       	lddsp	r8,sp[0x30]
8000a5fc:	58 98       	cp.w	r8,9
8000a5fe:	e0 8b 00 20 	brhi	8000a63e <_dtoa_r+0x2a2>
8000a602:	58 58       	cp.w	r8,5
8000a604:	f9 b4 0a 01 	movle	r4,1
8000a608:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a60c:	f7 b5 09 04 	subgt	r5,4
8000a610:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a614:	f9 b4 09 00 	movgt	r4,0
8000a618:	40 cc       	lddsp	r12,sp[0x30]
8000a61a:	58 3c       	cp.w	r12,3
8000a61c:	c2 d0       	breq	8000a676 <_dtoa_r+0x2da>
8000a61e:	e0 89 00 05 	brgt	8000a628 <_dtoa_r+0x28c>
8000a622:	58 2c       	cp.w	r12,2
8000a624:	c1 01       	brne	8000a644 <_dtoa_r+0x2a8>
8000a626:	c1 88       	rjmp	8000a656 <_dtoa_r+0x2ba>
8000a628:	40 cb       	lddsp	r11,sp[0x30]
8000a62a:	58 4b       	cp.w	r11,4
8000a62c:	c0 60       	breq	8000a638 <_dtoa_r+0x29c>
8000a62e:	58 5b       	cp.w	r11,5
8000a630:	c0 a1       	brne	8000a644 <_dtoa_r+0x2a8>
8000a632:	30 1a       	mov	r10,1
8000a634:	50 da       	stdsp	sp[0x34],r10
8000a636:	c2 28       	rjmp	8000a67a <_dtoa_r+0x2de>
8000a638:	30 19       	mov	r9,1
8000a63a:	50 d9       	stdsp	sp[0x34],r9
8000a63c:	c0 f8       	rjmp	8000a65a <_dtoa_r+0x2be>
8000a63e:	30 08       	mov	r8,0
8000a640:	30 14       	mov	r4,1
8000a642:	50 c8       	stdsp	sp[0x30],r8
8000a644:	3f f5       	mov	r5,-1
8000a646:	30 1c       	mov	r12,1
8000a648:	30 0b       	mov	r11,0
8000a64a:	50 95       	stdsp	sp[0x24],r5
8000a64c:	50 dc       	stdsp	sp[0x34],r12
8000a64e:	0a 91       	mov	r1,r5
8000a650:	31 28       	mov	r8,18
8000a652:	50 eb       	stdsp	sp[0x38],r11
8000a654:	c2 08       	rjmp	8000a694 <_dtoa_r+0x2f8>
8000a656:	30 0a       	mov	r10,0
8000a658:	50 da       	stdsp	sp[0x34],r10
8000a65a:	40 e9       	lddsp	r9,sp[0x38]
8000a65c:	58 09       	cp.w	r9,0
8000a65e:	e0 89 00 07 	brgt	8000a66c <_dtoa_r+0x2d0>
8000a662:	30 18       	mov	r8,1
8000a664:	50 98       	stdsp	sp[0x24],r8
8000a666:	10 91       	mov	r1,r8
8000a668:	50 e8       	stdsp	sp[0x38],r8
8000a66a:	c1 58       	rjmp	8000a694 <_dtoa_r+0x2f8>
8000a66c:	40 e5       	lddsp	r5,sp[0x38]
8000a66e:	50 95       	stdsp	sp[0x24],r5
8000a670:	0a 91       	mov	r1,r5
8000a672:	0a 98       	mov	r8,r5
8000a674:	c1 08       	rjmp	8000a694 <_dtoa_r+0x2f8>
8000a676:	30 0c       	mov	r12,0
8000a678:	50 dc       	stdsp	sp[0x34],r12
8000a67a:	40 eb       	lddsp	r11,sp[0x38]
8000a67c:	ec 0b 00 0b 	add	r11,r6,r11
8000a680:	50 9b       	stdsp	sp[0x24],r11
8000a682:	16 98       	mov	r8,r11
8000a684:	2f f8       	sub	r8,-1
8000a686:	58 08       	cp.w	r8,0
8000a688:	e0 89 00 05 	brgt	8000a692 <_dtoa_r+0x2f6>
8000a68c:	10 91       	mov	r1,r8
8000a68e:	30 18       	mov	r8,1
8000a690:	c0 28       	rjmp	8000a694 <_dtoa_r+0x2f8>
8000a692:	10 91       	mov	r1,r8
8000a694:	30 09       	mov	r9,0
8000a696:	6e 9a       	ld.w	r10,r7[0x24]
8000a698:	95 19       	st.w	r10[0x4],r9
8000a69a:	30 49       	mov	r9,4
8000a69c:	c0 68       	rjmp	8000a6a8 <_dtoa_r+0x30c>
8000a69e:	d7 03       	nop
8000a6a0:	6a 1a       	ld.w	r10,r5[0x4]
8000a6a2:	a1 79       	lsl	r9,0x1
8000a6a4:	2f fa       	sub	r10,-1
8000a6a6:	8b 1a       	st.w	r5[0x4],r10
8000a6a8:	6e 95       	ld.w	r5,r7[0x24]
8000a6aa:	f2 ca ff ec 	sub	r10,r9,-20
8000a6ae:	10 3a       	cp.w	r10,r8
8000a6b0:	fe 98 ff f8 	brls	8000a6a0 <_dtoa_r+0x304>
8000a6b4:	6a 1b       	ld.w	r11,r5[0x4]
8000a6b6:	0e 9c       	mov	r12,r7
8000a6b8:	e0 a0 09 44 	rcall	8000b940 <_Balloc>
8000a6bc:	58 e1       	cp.w	r1,14
8000a6be:	5f 88       	srls	r8
8000a6c0:	8b 0c       	st.w	r5[0x0],r12
8000a6c2:	f1 e4 00 04 	and	r4,r8,r4
8000a6c6:	6e 98       	ld.w	r8,r7[0x24]
8000a6c8:	70 08       	ld.w	r8,r8[0x0]
8000a6ca:	50 88       	stdsp	sp[0x20],r8
8000a6cc:	e0 80 01 82 	breq	8000a9d0 <_dtoa_r+0x634>
8000a6d0:	58 06       	cp.w	r6,0
8000a6d2:	e0 8a 00 43 	brle	8000a758 <_dtoa_r+0x3bc>
8000a6d6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a6da:	fe c8 c3 9a 	sub	r8,pc,-15462
8000a6de:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a6e2:	fa e5 00 18 	st.d	sp[24],r4
8000a6e6:	ec 04 14 04 	asr	r4,r6,0x4
8000a6ea:	ed b4 00 04 	bld	r4,0x4
8000a6ee:	c0 30       	breq	8000a6f4 <_dtoa_r+0x358>
8000a6f0:	30 25       	mov	r5,2
8000a6f2:	c1 08       	rjmp	8000a712 <_dtoa_r+0x376>
8000a6f4:	fe c8 c2 ec 	sub	r8,pc,-15636
8000a6f8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a6fc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a700:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a704:	e0 a0 0f fa 	rcall	8000c6f8 <__avr32_f64_div>
8000a708:	30 35       	mov	r5,3
8000a70a:	14 98       	mov	r8,r10
8000a70c:	16 99       	mov	r9,r11
8000a70e:	fa e9 00 08 	st.d	sp[8],r8
8000a712:	fe cc c3 0a 	sub	r12,pc,-15606
8000a716:	50 a3       	stdsp	sp[0x28],r3
8000a718:	0c 93       	mov	r3,r6
8000a71a:	18 96       	mov	r6,r12
8000a71c:	c0 f8       	rjmp	8000a73a <_dtoa_r+0x39e>
8000a71e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a722:	ed b4 00 00 	bld	r4,0x0
8000a726:	c0 81       	brne	8000a736 <_dtoa_r+0x39a>
8000a728:	ec e8 00 00 	ld.d	r8,r6[0]
8000a72c:	2f f5       	sub	r5,-1
8000a72e:	e0 a0 0c 9f 	rcall	8000c06c <__avr32_f64_mul>
8000a732:	fa eb 00 18 	st.d	sp[24],r10
8000a736:	a1 54       	asr	r4,0x1
8000a738:	2f 86       	sub	r6,-8
8000a73a:	58 04       	cp.w	r4,0
8000a73c:	cf 11       	brne	8000a71e <_dtoa_r+0x382>
8000a73e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a742:	fa ea 00 08 	ld.d	r10,sp[8]
8000a746:	06 96       	mov	r6,r3
8000a748:	e0 a0 0f d8 	rcall	8000c6f8 <__avr32_f64_div>
8000a74c:	40 a3       	lddsp	r3,sp[0x28]
8000a74e:	14 98       	mov	r8,r10
8000a750:	16 99       	mov	r9,r11
8000a752:	fa e9 00 08 	st.d	sp[8],r8
8000a756:	c2 f8       	rjmp	8000a7b4 <_dtoa_r+0x418>
8000a758:	ec 08 11 00 	rsub	r8,r6,0
8000a75c:	c0 31       	brne	8000a762 <_dtoa_r+0x3c6>
8000a75e:	30 25       	mov	r5,2
8000a760:	c2 a8       	rjmp	8000a7b4 <_dtoa_r+0x418>
8000a762:	fe cc c3 5a 	sub	r12,pc,-15526
8000a766:	f0 04 14 04 	asr	r4,r8,0x4
8000a76a:	50 1c       	stdsp	sp[0x4],r12
8000a76c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a770:	fe c9 c4 30 	sub	r9,pc,-15312
8000a774:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a778:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a77c:	e0 a0 0c 78 	rcall	8000c06c <__avr32_f64_mul>
8000a780:	40 1c       	lddsp	r12,sp[0x4]
8000a782:	50 63       	stdsp	sp[0x18],r3
8000a784:	30 25       	mov	r5,2
8000a786:	0c 93       	mov	r3,r6
8000a788:	fa eb 00 08 	st.d	sp[8],r10
8000a78c:	18 96       	mov	r6,r12
8000a78e:	c0 f8       	rjmp	8000a7ac <_dtoa_r+0x410>
8000a790:	fa ea 00 08 	ld.d	r10,sp[8]
8000a794:	ed b4 00 00 	bld	r4,0x0
8000a798:	c0 81       	brne	8000a7a8 <_dtoa_r+0x40c>
8000a79a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a79e:	2f f5       	sub	r5,-1
8000a7a0:	e0 a0 0c 66 	rcall	8000c06c <__avr32_f64_mul>
8000a7a4:	fa eb 00 08 	st.d	sp[8],r10
8000a7a8:	a1 54       	asr	r4,0x1
8000a7aa:	2f 86       	sub	r6,-8
8000a7ac:	58 04       	cp.w	r4,0
8000a7ae:	cf 11       	brne	8000a790 <_dtoa_r+0x3f4>
8000a7b0:	06 96       	mov	r6,r3
8000a7b2:	40 63       	lddsp	r3,sp[0x18]
8000a7b4:	41 4a       	lddsp	r10,sp[0x50]
8000a7b6:	58 0a       	cp.w	r10,0
8000a7b8:	c2 a0       	breq	8000a80c <_dtoa_r+0x470>
8000a7ba:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7be:	58 01       	cp.w	r1,0
8000a7c0:	5f 94       	srgt	r4
8000a7c2:	fa e9 00 18 	st.d	sp[24],r8
8000a7c6:	30 08       	mov	r8,0
8000a7c8:	fc 19 3f f0 	movh	r9,0x3ff0
8000a7cc:	fa ea 00 18 	ld.d	r10,sp[24]
8000a7d0:	e0 a0 0f 60 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a7d4:	f9 bc 00 00 	moveq	r12,0
8000a7d8:	f9 bc 01 01 	movne	r12,1
8000a7dc:	e9 ec 00 0c 	and	r12,r4,r12
8000a7e0:	c1 60       	breq	8000a80c <_dtoa_r+0x470>
8000a7e2:	40 98       	lddsp	r8,sp[0x24]
8000a7e4:	58 08       	cp.w	r8,0
8000a7e6:	e0 8a 00 f1 	brle	8000a9c8 <_dtoa_r+0x62c>
8000a7ea:	30 08       	mov	r8,0
8000a7ec:	fc 19 40 24 	movh	r9,0x4024
8000a7f0:	ec c4 00 01 	sub	r4,r6,1
8000a7f4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a7f8:	2f f5       	sub	r5,-1
8000a7fa:	50 64       	stdsp	sp[0x18],r4
8000a7fc:	e0 a0 0c 38 	rcall	8000c06c <__avr32_f64_mul>
8000a800:	40 94       	lddsp	r4,sp[0x24]
8000a802:	14 98       	mov	r8,r10
8000a804:	16 99       	mov	r9,r11
8000a806:	fa e9 00 08 	st.d	sp[8],r8
8000a80a:	c0 38       	rjmp	8000a810 <_dtoa_r+0x474>
8000a80c:	50 66       	stdsp	sp[0x18],r6
8000a80e:	02 94       	mov	r4,r1
8000a810:	0a 9c       	mov	r12,r5
8000a812:	e0 a0 0e 88 	rcall	8000c522 <__avr32_s32_to_f64>
8000a816:	fa e8 00 08 	ld.d	r8,sp[8]
8000a81a:	e0 a0 0c 29 	rcall	8000c06c <__avr32_f64_mul>
8000a81e:	30 08       	mov	r8,0
8000a820:	fc 19 40 1c 	movh	r9,0x401c
8000a824:	e0 a0 0d de 	rcall	8000c3e0 <__avr32_f64_add>
8000a828:	14 98       	mov	r8,r10
8000a82a:	16 99       	mov	r9,r11
8000a82c:	fa e9 00 28 	st.d	sp[40],r8
8000a830:	fc 18 fc c0 	movh	r8,0xfcc0
8000a834:	40 a5       	lddsp	r5,sp[0x28]
8000a836:	10 05       	add	r5,r8
8000a838:	50 a5       	stdsp	sp[0x28],r5
8000a83a:	58 04       	cp.w	r4,0
8000a83c:	c2 11       	brne	8000a87e <_dtoa_r+0x4e2>
8000a83e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a842:	30 08       	mov	r8,0
8000a844:	fc 19 40 14 	movh	r9,0x4014
8000a848:	e0 a0 0c fe 	rcall	8000c244 <__avr32_f64_sub>
8000a84c:	40 bc       	lddsp	r12,sp[0x2c]
8000a84e:	fa eb 00 08 	st.d	sp[8],r10
8000a852:	14 98       	mov	r8,r10
8000a854:	16 99       	mov	r9,r11
8000a856:	18 9a       	mov	r10,r12
8000a858:	0a 9b       	mov	r11,r5
8000a85a:	e0 a0 0f 1b 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a85e:	e0 81 02 54 	brne	8000ad06 <_dtoa_r+0x96a>
8000a862:	0a 98       	mov	r8,r5
8000a864:	40 b9       	lddsp	r9,sp[0x2c]
8000a866:	ee 18 80 00 	eorh	r8,0x8000
8000a86a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a86e:	10 95       	mov	r5,r8
8000a870:	12 98       	mov	r8,r9
8000a872:	0a 99       	mov	r9,r5
8000a874:	e0 a0 0f 0e 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a878:	e0 81 02 3e 	brne	8000acf4 <_dtoa_r+0x958>
8000a87c:	ca 68       	rjmp	8000a9c8 <_dtoa_r+0x62c>
8000a87e:	fe c9 c5 3e 	sub	r9,pc,-15042
8000a882:	e8 c8 00 01 	sub	r8,r4,1
8000a886:	40 d5       	lddsp	r5,sp[0x34]
8000a888:	58 05       	cp.w	r5,0
8000a88a:	c4 f0       	breq	8000a928 <_dtoa_r+0x58c>
8000a88c:	30 0c       	mov	r12,0
8000a88e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a892:	51 3c       	stdsp	sp[0x4c],r12
8000a894:	30 0a       	mov	r10,0
8000a896:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a89a:	e0 a0 0f 2f 	rcall	8000c6f8 <__avr32_f64_div>
8000a89e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8a2:	40 85       	lddsp	r5,sp[0x20]
8000a8a4:	e0 a0 0c d0 	rcall	8000c244 <__avr32_f64_sub>
8000a8a8:	fa eb 00 28 	st.d	sp[40],r10
8000a8ac:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8b0:	e0 a0 0e 22 	rcall	8000c4f4 <__avr32_f64_to_s32>
8000a8b4:	51 6c       	stdsp	sp[0x58],r12
8000a8b6:	e0 a0 0e 36 	rcall	8000c522 <__avr32_s32_to_f64>
8000a8ba:	14 98       	mov	r8,r10
8000a8bc:	16 99       	mov	r9,r11
8000a8be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8c2:	e0 a0 0c c1 	rcall	8000c244 <__avr32_f64_sub>
8000a8c6:	fa eb 00 08 	st.d	sp[8],r10
8000a8ca:	41 68       	lddsp	r8,sp[0x58]
8000a8cc:	2d 08       	sub	r8,-48
8000a8ce:	0a c8       	st.b	r5++,r8
8000a8d0:	41 39       	lddsp	r9,sp[0x4c]
8000a8d2:	2f f9       	sub	r9,-1
8000a8d4:	51 39       	stdsp	sp[0x4c],r9
8000a8d6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8da:	e0 a0 0e db 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a8de:	e0 81 03 39 	brne	8000af50 <_dtoa_r+0xbb4>
8000a8e2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8e6:	30 0a       	mov	r10,0
8000a8e8:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a8ec:	e0 a0 0c ac 	rcall	8000c244 <__avr32_f64_sub>
8000a8f0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8f4:	e0 a0 0e ce 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a8f8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a8fc:	30 08       	mov	r8,0
8000a8fe:	fc 19 40 24 	movh	r9,0x4024
8000a902:	e0 81 00 da 	brne	8000aab6 <_dtoa_r+0x71a>
8000a906:	41 3c       	lddsp	r12,sp[0x4c]
8000a908:	08 3c       	cp.w	r12,r4
8000a90a:	c5 f4       	brge	8000a9c8 <_dtoa_r+0x62c>
8000a90c:	e0 a0 0b b0 	rcall	8000c06c <__avr32_f64_mul>
8000a910:	30 08       	mov	r8,0
8000a912:	fa eb 00 28 	st.d	sp[40],r10
8000a916:	fc 19 40 24 	movh	r9,0x4024
8000a91a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a91e:	e0 a0 0b a7 	rcall	8000c06c <__avr32_f64_mul>
8000a922:	fa eb 00 08 	st.d	sp[8],r10
8000a926:	cc 3b       	rjmp	8000a8ac <_dtoa_r+0x510>
8000a928:	40 85       	lddsp	r5,sp[0x20]
8000a92a:	08 05       	add	r5,r4
8000a92c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a930:	51 35       	stdsp	sp[0x4c],r5
8000a932:	fa e8 00 28 	ld.d	r8,sp[40]
8000a936:	40 85       	lddsp	r5,sp[0x20]
8000a938:	e0 a0 0b 9a 	rcall	8000c06c <__avr32_f64_mul>
8000a93c:	fa eb 00 28 	st.d	sp[40],r10
8000a940:	fa ea 00 08 	ld.d	r10,sp[8]
8000a944:	e0 a0 0d d8 	rcall	8000c4f4 <__avr32_f64_to_s32>
8000a948:	51 6c       	stdsp	sp[0x58],r12
8000a94a:	e0 a0 0d ec 	rcall	8000c522 <__avr32_s32_to_f64>
8000a94e:	14 98       	mov	r8,r10
8000a950:	16 99       	mov	r9,r11
8000a952:	fa ea 00 08 	ld.d	r10,sp[8]
8000a956:	e0 a0 0c 77 	rcall	8000c244 <__avr32_f64_sub>
8000a95a:	fa eb 00 08 	st.d	sp[8],r10
8000a95e:	41 68       	lddsp	r8,sp[0x58]
8000a960:	2d 08       	sub	r8,-48
8000a962:	0a c8       	st.b	r5++,r8
8000a964:	41 3c       	lddsp	r12,sp[0x4c]
8000a966:	18 35       	cp.w	r5,r12
8000a968:	c2 81       	brne	8000a9b8 <_dtoa_r+0x61c>
8000a96a:	30 08       	mov	r8,0
8000a96c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a970:	fa ea 00 28 	ld.d	r10,sp[40]
8000a974:	e0 a0 0d 36 	rcall	8000c3e0 <__avr32_f64_add>
8000a978:	40 85       	lddsp	r5,sp[0x20]
8000a97a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a97e:	08 05       	add	r5,r4
8000a980:	e0 a0 0e 88 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a984:	e0 81 00 99 	brne	8000aab6 <_dtoa_r+0x71a>
8000a988:	fa e8 00 28 	ld.d	r8,sp[40]
8000a98c:	30 0a       	mov	r10,0
8000a98e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a992:	e0 a0 0c 59 	rcall	8000c244 <__avr32_f64_sub>
8000a996:	14 98       	mov	r8,r10
8000a998:	16 99       	mov	r9,r11
8000a99a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a99e:	e0 a0 0e 79 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000a9a2:	c1 30       	breq	8000a9c8 <_dtoa_r+0x62c>
8000a9a4:	33 09       	mov	r9,48
8000a9a6:	0a 98       	mov	r8,r5
8000a9a8:	11 7a       	ld.ub	r10,--r8
8000a9aa:	f2 0a 18 00 	cp.b	r10,r9
8000a9ae:	e0 81 02 d1 	brne	8000af50 <_dtoa_r+0xbb4>
8000a9b2:	10 95       	mov	r5,r8
8000a9b4:	cf 9b       	rjmp	8000a9a6 <_dtoa_r+0x60a>
8000a9b6:	d7 03       	nop
8000a9b8:	30 08       	mov	r8,0
8000a9ba:	fc 19 40 24 	movh	r9,0x4024
8000a9be:	e0 a0 0b 57 	rcall	8000c06c <__avr32_f64_mul>
8000a9c2:	fa eb 00 08 	st.d	sp[8],r10
8000a9c6:	cb db       	rjmp	8000a940 <_dtoa_r+0x5a4>
8000a9c8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a9cc:	fa eb 00 08 	st.d	sp[8],r10
8000a9d0:	58 e6       	cp.w	r6,14
8000a9d2:	5f ab       	srle	r11
8000a9d4:	41 8a       	lddsp	r10,sp[0x60]
8000a9d6:	30 08       	mov	r8,0
8000a9d8:	f4 09 11 ff 	rsub	r9,r10,-1
8000a9dc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a9e0:	f0 09 18 00 	cp.b	r9,r8
8000a9e4:	e0 80 00 82 	breq	8000aae8 <_dtoa_r+0x74c>
8000a9e8:	40 ea       	lddsp	r10,sp[0x38]
8000a9ea:	58 01       	cp.w	r1,0
8000a9ec:	5f a9       	srle	r9
8000a9ee:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a9f2:	fe ca c6 b2 	sub	r10,pc,-14670
8000a9f6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a9fa:	fa e5 00 10 	st.d	sp[16],r4
8000a9fe:	f0 09 18 00 	cp.b	r9,r8
8000aa02:	c1 40       	breq	8000aa2a <_dtoa_r+0x68e>
8000aa04:	58 01       	cp.w	r1,0
8000aa06:	e0 81 01 77 	brne	8000acf4 <_dtoa_r+0x958>
8000aa0a:	30 08       	mov	r8,0
8000aa0c:	fc 19 40 14 	movh	r9,0x4014
8000aa10:	08 9a       	mov	r10,r4
8000aa12:	0a 9b       	mov	r11,r5
8000aa14:	e0 a0 0b 2c 	rcall	8000c06c <__avr32_f64_mul>
8000aa18:	fa e8 00 08 	ld.d	r8,sp[8]
8000aa1c:	e0 a0 0e 06 	rcall	8000c628 <__avr32_f64_cmp_ge>
8000aa20:	e0 81 01 6a 	brne	8000acf4 <_dtoa_r+0x958>
8000aa24:	02 92       	mov	r2,r1
8000aa26:	e0 8f 01 72 	bral	8000ad0a <_dtoa_r+0x96e>
8000aa2a:	40 85       	lddsp	r5,sp[0x20]
8000aa2c:	30 14       	mov	r4,1
8000aa2e:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa32:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa36:	e0 a0 0e 61 	rcall	8000c6f8 <__avr32_f64_div>
8000aa3a:	e0 a0 0d 5d 	rcall	8000c4f4 <__avr32_f64_to_s32>
8000aa3e:	18 92       	mov	r2,r12
8000aa40:	e0 a0 0d 71 	rcall	8000c522 <__avr32_s32_to_f64>
8000aa44:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa48:	e0 a0 0b 12 	rcall	8000c06c <__avr32_f64_mul>
8000aa4c:	14 98       	mov	r8,r10
8000aa4e:	16 99       	mov	r9,r11
8000aa50:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa54:	e0 a0 0b f8 	rcall	8000c244 <__avr32_f64_sub>
8000aa58:	fa eb 00 08 	st.d	sp[8],r10
8000aa5c:	e4 c8 ff d0 	sub	r8,r2,-48
8000aa60:	0a c8       	st.b	r5++,r8
8000aa62:	fc 19 40 24 	movh	r9,0x4024
8000aa66:	30 08       	mov	r8,0
8000aa68:	02 34       	cp.w	r4,r1
8000aa6a:	c3 31       	brne	8000aad0 <_dtoa_r+0x734>
8000aa6c:	fa e8 00 08 	ld.d	r8,sp[8]
8000aa70:	e0 a0 0c b8 	rcall	8000c3e0 <__avr32_f64_add>
8000aa74:	16 91       	mov	r1,r11
8000aa76:	14 90       	mov	r0,r10
8000aa78:	14 98       	mov	r8,r10
8000aa7a:	02 99       	mov	r9,r1
8000aa7c:	fa ea 00 10 	ld.d	r10,sp[16]
8000aa80:	e0 a0 0e 08 	rcall	8000c690 <__avr32_f64_cmp_lt>
8000aa84:	c1 a1       	brne	8000aab8 <_dtoa_r+0x71c>
8000aa86:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa8a:	00 9a       	mov	r10,r0
8000aa8c:	02 9b       	mov	r11,r1
8000aa8e:	e0 a0 0d ba 	rcall	8000c602 <__avr32_f64_cmp_eq>
8000aa92:	e0 80 02 5e 	breq	8000af4e <_dtoa_r+0xbb2>
8000aa96:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000aa9a:	c0 f1       	brne	8000aab8 <_dtoa_r+0x71c>
8000aa9c:	e0 8f 02 59 	bral	8000af4e <_dtoa_r+0xbb2>
8000aaa0:	40 8a       	lddsp	r10,sp[0x20]
8000aaa2:	14 38       	cp.w	r8,r10
8000aaa4:	c0 30       	breq	8000aaaa <_dtoa_r+0x70e>
8000aaa6:	10 95       	mov	r5,r8
8000aaa8:	c0 98       	rjmp	8000aaba <_dtoa_r+0x71e>
8000aaaa:	33 08       	mov	r8,48
8000aaac:	40 89       	lddsp	r9,sp[0x20]
8000aaae:	2f f6       	sub	r6,-1
8000aab0:	b2 88       	st.b	r9[0x0],r8
8000aab2:	40 88       	lddsp	r8,sp[0x20]
8000aab4:	c0 88       	rjmp	8000aac4 <_dtoa_r+0x728>
8000aab6:	40 66       	lddsp	r6,sp[0x18]
8000aab8:	33 99       	mov	r9,57
8000aaba:	0a 98       	mov	r8,r5
8000aabc:	11 7a       	ld.ub	r10,--r8
8000aabe:	f2 0a 18 00 	cp.b	r10,r9
8000aac2:	ce f0       	breq	8000aaa0 <_dtoa_r+0x704>
8000aac4:	50 66       	stdsp	sp[0x18],r6
8000aac6:	11 89       	ld.ub	r9,r8[0x0]
8000aac8:	2f f9       	sub	r9,-1
8000aaca:	b0 89       	st.b	r8[0x0],r9
8000aacc:	e0 8f 02 42 	bral	8000af50 <_dtoa_r+0xbb4>
8000aad0:	e0 a0 0a ce 	rcall	8000c06c <__avr32_f64_mul>
8000aad4:	2f f4       	sub	r4,-1
8000aad6:	fa eb 00 08 	st.d	sp[8],r10
8000aada:	30 08       	mov	r8,0
8000aadc:	30 09       	mov	r9,0
8000aade:	e0 a0 0d 92 	rcall	8000c602 <__avr32_f64_cmp_eq>
8000aae2:	ca 60       	breq	8000aa2e <_dtoa_r+0x692>
8000aae4:	e0 8f 02 35 	bral	8000af4e <_dtoa_r+0xbb2>
8000aae8:	40 d8       	lddsp	r8,sp[0x34]
8000aaea:	58 08       	cp.w	r8,0
8000aaec:	c0 51       	brne	8000aaf6 <_dtoa_r+0x75a>
8000aaee:	04 98       	mov	r8,r2
8000aaf0:	00 95       	mov	r5,r0
8000aaf2:	40 d4       	lddsp	r4,sp[0x34]
8000aaf4:	c3 78       	rjmp	8000ab62 <_dtoa_r+0x7c6>
8000aaf6:	40 c5       	lddsp	r5,sp[0x30]
8000aaf8:	58 15       	cp.w	r5,1
8000aafa:	e0 89 00 0f 	brgt	8000ab18 <_dtoa_r+0x77c>
8000aafe:	41 74       	lddsp	r4,sp[0x5c]
8000ab00:	58 04       	cp.w	r4,0
8000ab02:	c0 40       	breq	8000ab0a <_dtoa_r+0x76e>
8000ab04:	f4 c9 fb cd 	sub	r9,r10,-1075
8000ab08:	c0 48       	rjmp	8000ab10 <_dtoa_r+0x774>
8000ab0a:	41 99       	lddsp	r9,sp[0x64]
8000ab0c:	f2 09 11 36 	rsub	r9,r9,54
8000ab10:	04 98       	mov	r8,r2
8000ab12:	00 95       	mov	r5,r0
8000ab14:	c1 c8       	rjmp	8000ab4c <_dtoa_r+0x7b0>
8000ab16:	d7 03       	nop
8000ab18:	e2 c8 00 01 	sub	r8,r1,1
8000ab1c:	58 01       	cp.w	r1,0
8000ab1e:	e0 05 17 40 	movge	r5,r0
8000ab22:	e2 09 17 40 	movge	r9,r1
8000ab26:	e1 d1 e5 15 	sublt	r5,r0,r1
8000ab2a:	f9 b9 05 00 	movlt	r9,0
8000ab2e:	10 32       	cp.w	r2,r8
8000ab30:	e5 d8 e4 18 	subge	r8,r2,r8
8000ab34:	f1 d2 e5 18 	sublt	r8,r8,r2
8000ab38:	e5 d8 e5 02 	addlt	r2,r2,r8
8000ab3c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000ab40:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000ab44:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000ab48:	f9 b8 05 00 	movlt	r8,0
8000ab4c:	40 4b       	lddsp	r11,sp[0x10]
8000ab4e:	12 0b       	add	r11,r9
8000ab50:	50 08       	stdsp	sp[0x0],r8
8000ab52:	50 4b       	stdsp	sp[0x10],r11
8000ab54:	12 00       	add	r0,r9
8000ab56:	30 1b       	mov	r11,1
8000ab58:	0e 9c       	mov	r12,r7
8000ab5a:	e0 a0 08 a7 	rcall	8000bca8 <__i2b>
8000ab5e:	40 08       	lddsp	r8,sp[0x0]
8000ab60:	18 94       	mov	r4,r12
8000ab62:	40 4a       	lddsp	r10,sp[0x10]
8000ab64:	58 05       	cp.w	r5,0
8000ab66:	5f 99       	srgt	r9
8000ab68:	58 0a       	cp.w	r10,0
8000ab6a:	5f 9a       	srgt	r10
8000ab6c:	f5 e9 00 09 	and	r9,r10,r9
8000ab70:	c0 80       	breq	8000ab80 <_dtoa_r+0x7e4>
8000ab72:	40 4c       	lddsp	r12,sp[0x10]
8000ab74:	f8 05 0d 49 	min	r9,r12,r5
8000ab78:	12 1c       	sub	r12,r9
8000ab7a:	12 10       	sub	r0,r9
8000ab7c:	50 4c       	stdsp	sp[0x10],r12
8000ab7e:	12 15       	sub	r5,r9
8000ab80:	58 02       	cp.w	r2,0
8000ab82:	e0 8a 00 27 	brle	8000abd0 <_dtoa_r+0x834>
8000ab86:	40 db       	lddsp	r11,sp[0x34]
8000ab88:	58 0b       	cp.w	r11,0
8000ab8a:	c1 d0       	breq	8000abc4 <_dtoa_r+0x828>
8000ab8c:	58 08       	cp.w	r8,0
8000ab8e:	e0 8a 00 17 	brle	8000abbc <_dtoa_r+0x820>
8000ab92:	10 9a       	mov	r10,r8
8000ab94:	50 08       	stdsp	sp[0x0],r8
8000ab96:	08 9b       	mov	r11,r4
8000ab98:	0e 9c       	mov	r12,r7
8000ab9a:	e0 a0 08 cd 	rcall	8000bd34 <__pow5mult>
8000ab9e:	06 9a       	mov	r10,r3
8000aba0:	18 9b       	mov	r11,r12
8000aba2:	18 94       	mov	r4,r12
8000aba4:	0e 9c       	mov	r12,r7
8000aba6:	e0 a0 08 01 	rcall	8000bba8 <__multiply>
8000abaa:	18 99       	mov	r9,r12
8000abac:	06 9b       	mov	r11,r3
8000abae:	50 19       	stdsp	sp[0x4],r9
8000abb0:	0e 9c       	mov	r12,r7
8000abb2:	e0 a0 06 ad 	rcall	8000b90c <_Bfree>
8000abb6:	40 19       	lddsp	r9,sp[0x4]
8000abb8:	40 08       	lddsp	r8,sp[0x0]
8000abba:	12 93       	mov	r3,r9
8000abbc:	e4 08 01 0a 	sub	r10,r2,r8
8000abc0:	c0 80       	breq	8000abd0 <_dtoa_r+0x834>
8000abc2:	c0 28       	rjmp	8000abc6 <_dtoa_r+0x82a>
8000abc4:	04 9a       	mov	r10,r2
8000abc6:	06 9b       	mov	r11,r3
8000abc8:	0e 9c       	mov	r12,r7
8000abca:	e0 a0 08 b5 	rcall	8000bd34 <__pow5mult>
8000abce:	18 93       	mov	r3,r12
8000abd0:	30 1b       	mov	r11,1
8000abd2:	0e 9c       	mov	r12,r7
8000abd4:	e0 a0 08 6a 	rcall	8000bca8 <__i2b>
8000abd8:	41 1a       	lddsp	r10,sp[0x44]
8000abda:	18 92       	mov	r2,r12
8000abdc:	58 0a       	cp.w	r10,0
8000abde:	e0 8a 00 07 	brle	8000abec <_dtoa_r+0x850>
8000abe2:	18 9b       	mov	r11,r12
8000abe4:	0e 9c       	mov	r12,r7
8000abe6:	e0 a0 08 a7 	rcall	8000bd34 <__pow5mult>
8000abea:	18 92       	mov	r2,r12
8000abec:	40 c9       	lddsp	r9,sp[0x30]
8000abee:	58 19       	cp.w	r9,1
8000abf0:	e0 89 00 14 	brgt	8000ac18 <_dtoa_r+0x87c>
8000abf4:	40 38       	lddsp	r8,sp[0xc]
8000abf6:	58 08       	cp.w	r8,0
8000abf8:	c1 01       	brne	8000ac18 <_dtoa_r+0x87c>
8000abfa:	40 29       	lddsp	r9,sp[0x8]
8000abfc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ac00:	c0 c1       	brne	8000ac18 <_dtoa_r+0x87c>
8000ac02:	12 98       	mov	r8,r9
8000ac04:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ac08:	c0 80       	breq	8000ac18 <_dtoa_r+0x87c>
8000ac0a:	40 4c       	lddsp	r12,sp[0x10]
8000ac0c:	30 1b       	mov	r11,1
8000ac0e:	2f fc       	sub	r12,-1
8000ac10:	2f f0       	sub	r0,-1
8000ac12:	50 4c       	stdsp	sp[0x10],r12
8000ac14:	50 6b       	stdsp	sp[0x18],r11
8000ac16:	c0 38       	rjmp	8000ac1c <_dtoa_r+0x880>
8000ac18:	30 0a       	mov	r10,0
8000ac1a:	50 6a       	stdsp	sp[0x18],r10
8000ac1c:	41 19       	lddsp	r9,sp[0x44]
8000ac1e:	58 09       	cp.w	r9,0
8000ac20:	c0 31       	brne	8000ac26 <_dtoa_r+0x88a>
8000ac22:	30 1c       	mov	r12,1
8000ac24:	c0 98       	rjmp	8000ac36 <_dtoa_r+0x89a>
8000ac26:	64 48       	ld.w	r8,r2[0x10]
8000ac28:	2f c8       	sub	r8,-4
8000ac2a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ac2e:	e0 a0 05 df 	rcall	8000b7ec <__hi0bits>
8000ac32:	f8 0c 11 20 	rsub	r12,r12,32
8000ac36:	40 4b       	lddsp	r11,sp[0x10]
8000ac38:	f8 0b 00 08 	add	r8,r12,r11
8000ac3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ac40:	c0 c0       	breq	8000ac58 <_dtoa_r+0x8bc>
8000ac42:	f0 08 11 20 	rsub	r8,r8,32
8000ac46:	58 48       	cp.w	r8,4
8000ac48:	e0 8a 00 06 	brle	8000ac54 <_dtoa_r+0x8b8>
8000ac4c:	20 48       	sub	r8,4
8000ac4e:	10 0b       	add	r11,r8
8000ac50:	50 4b       	stdsp	sp[0x10],r11
8000ac52:	c0 78       	rjmp	8000ac60 <_dtoa_r+0x8c4>
8000ac54:	58 48       	cp.w	r8,4
8000ac56:	c0 70       	breq	8000ac64 <_dtoa_r+0x8c8>
8000ac58:	40 4a       	lddsp	r10,sp[0x10]
8000ac5a:	2e 48       	sub	r8,-28
8000ac5c:	10 0a       	add	r10,r8
8000ac5e:	50 4a       	stdsp	sp[0x10],r10
8000ac60:	10 00       	add	r0,r8
8000ac62:	10 05       	add	r5,r8
8000ac64:	58 00       	cp.w	r0,0
8000ac66:	e0 8a 00 08 	brle	8000ac76 <_dtoa_r+0x8da>
8000ac6a:	06 9b       	mov	r11,r3
8000ac6c:	00 9a       	mov	r10,r0
8000ac6e:	0e 9c       	mov	r12,r7
8000ac70:	e0 a0 07 58 	rcall	8000bb20 <__lshift>
8000ac74:	18 93       	mov	r3,r12
8000ac76:	40 49       	lddsp	r9,sp[0x10]
8000ac78:	58 09       	cp.w	r9,0
8000ac7a:	e0 8a 00 08 	brle	8000ac8a <_dtoa_r+0x8ee>
8000ac7e:	04 9b       	mov	r11,r2
8000ac80:	12 9a       	mov	r10,r9
8000ac82:	0e 9c       	mov	r12,r7
8000ac84:	e0 a0 07 4e 	rcall	8000bb20 <__lshift>
8000ac88:	18 92       	mov	r2,r12
8000ac8a:	41 48       	lddsp	r8,sp[0x50]
8000ac8c:	58 08       	cp.w	r8,0
8000ac8e:	c1 b0       	breq	8000acc4 <_dtoa_r+0x928>
8000ac90:	04 9b       	mov	r11,r2
8000ac92:	06 9c       	mov	r12,r3
8000ac94:	e0 a0 06 23 	rcall	8000b8da <__mcmp>
8000ac98:	c1 64       	brge	8000acc4 <_dtoa_r+0x928>
8000ac9a:	06 9b       	mov	r11,r3
8000ac9c:	30 09       	mov	r9,0
8000ac9e:	30 aa       	mov	r10,10
8000aca0:	0e 9c       	mov	r12,r7
8000aca2:	e0 a0 08 0b 	rcall	8000bcb8 <__multadd>
8000aca6:	20 16       	sub	r6,1
8000aca8:	18 93       	mov	r3,r12
8000acaa:	40 dc       	lddsp	r12,sp[0x34]
8000acac:	58 0c       	cp.w	r12,0
8000acae:	c0 31       	brne	8000acb4 <_dtoa_r+0x918>
8000acb0:	40 91       	lddsp	r1,sp[0x24]
8000acb2:	c0 98       	rjmp	8000acc4 <_dtoa_r+0x928>
8000acb4:	08 9b       	mov	r11,r4
8000acb6:	40 91       	lddsp	r1,sp[0x24]
8000acb8:	30 09       	mov	r9,0
8000acba:	30 aa       	mov	r10,10
8000acbc:	0e 9c       	mov	r12,r7
8000acbe:	e0 a0 07 fd 	rcall	8000bcb8 <__multadd>
8000acc2:	18 94       	mov	r4,r12
8000acc4:	58 01       	cp.w	r1,0
8000acc6:	5f a9       	srle	r9
8000acc8:	40 cb       	lddsp	r11,sp[0x30]
8000acca:	58 2b       	cp.w	r11,2
8000accc:	5f 98       	srgt	r8
8000acce:	f3 e8 00 08 	and	r8,r9,r8
8000acd2:	c2 50       	breq	8000ad1c <_dtoa_r+0x980>
8000acd4:	58 01       	cp.w	r1,0
8000acd6:	c1 11       	brne	8000acf8 <_dtoa_r+0x95c>
8000acd8:	04 9b       	mov	r11,r2
8000acda:	02 99       	mov	r9,r1
8000acdc:	30 5a       	mov	r10,5
8000acde:	0e 9c       	mov	r12,r7
8000ace0:	e0 a0 07 ec 	rcall	8000bcb8 <__multadd>
8000ace4:	18 92       	mov	r2,r12
8000ace6:	18 9b       	mov	r11,r12
8000ace8:	06 9c       	mov	r12,r3
8000acea:	e0 a0 05 f8 	rcall	8000b8da <__mcmp>
8000acee:	e0 89 00 0f 	brgt	8000ad0c <_dtoa_r+0x970>
8000acf2:	c0 38       	rjmp	8000acf8 <_dtoa_r+0x95c>
8000acf4:	30 02       	mov	r2,0
8000acf6:	04 94       	mov	r4,r2
8000acf8:	40 ea       	lddsp	r10,sp[0x38]
8000acfa:	30 09       	mov	r9,0
8000acfc:	5c da       	com	r10
8000acfe:	40 85       	lddsp	r5,sp[0x20]
8000ad00:	50 6a       	stdsp	sp[0x18],r10
8000ad02:	50 49       	stdsp	sp[0x10],r9
8000ad04:	c0 f9       	rjmp	8000af22 <_dtoa_r+0xb86>
8000ad06:	08 92       	mov	r2,r4
8000ad08:	40 66       	lddsp	r6,sp[0x18]
8000ad0a:	04 94       	mov	r4,r2
8000ad0c:	2f f6       	sub	r6,-1
8000ad0e:	50 66       	stdsp	sp[0x18],r6
8000ad10:	33 18       	mov	r8,49
8000ad12:	40 85       	lddsp	r5,sp[0x20]
8000ad14:	0a c8       	st.b	r5++,r8
8000ad16:	30 08       	mov	r8,0
8000ad18:	50 48       	stdsp	sp[0x10],r8
8000ad1a:	c0 49       	rjmp	8000af22 <_dtoa_r+0xb86>
8000ad1c:	40 dc       	lddsp	r12,sp[0x34]
8000ad1e:	58 0c       	cp.w	r12,0
8000ad20:	e0 80 00 b5 	breq	8000ae8a <_dtoa_r+0xaee>
8000ad24:	58 05       	cp.w	r5,0
8000ad26:	e0 8a 00 08 	brle	8000ad36 <_dtoa_r+0x99a>
8000ad2a:	08 9b       	mov	r11,r4
8000ad2c:	0a 9a       	mov	r10,r5
8000ad2e:	0e 9c       	mov	r12,r7
8000ad30:	e0 a0 06 f8 	rcall	8000bb20 <__lshift>
8000ad34:	18 94       	mov	r4,r12
8000ad36:	40 6b       	lddsp	r11,sp[0x18]
8000ad38:	58 0b       	cp.w	r11,0
8000ad3a:	c0 31       	brne	8000ad40 <_dtoa_r+0x9a4>
8000ad3c:	08 9c       	mov	r12,r4
8000ad3e:	c1 38       	rjmp	8000ad64 <_dtoa_r+0x9c8>
8000ad40:	68 1b       	ld.w	r11,r4[0x4]
8000ad42:	0e 9c       	mov	r12,r7
8000ad44:	e0 a0 05 fe 	rcall	8000b940 <_Balloc>
8000ad48:	68 4a       	ld.w	r10,r4[0x10]
8000ad4a:	18 95       	mov	r5,r12
8000ad4c:	e8 cb ff f4 	sub	r11,r4,-12
8000ad50:	2f ea       	sub	r10,-2
8000ad52:	2f 4c       	sub	r12,-12
8000ad54:	a3 6a       	lsl	r10,0x2
8000ad56:	fe b0 e6 50 	rcall	800079f6 <memcpy>
8000ad5a:	0a 9b       	mov	r11,r5
8000ad5c:	30 1a       	mov	r10,1
8000ad5e:	0e 9c       	mov	r12,r7
8000ad60:	e0 a0 06 e0 	rcall	8000bb20 <__lshift>
8000ad64:	50 44       	stdsp	sp[0x10],r4
8000ad66:	40 3a       	lddsp	r10,sp[0xc]
8000ad68:	30 19       	mov	r9,1
8000ad6a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ad6e:	18 94       	mov	r4,r12
8000ad70:	50 da       	stdsp	sp[0x34],r10
8000ad72:	40 85       	lddsp	r5,sp[0x20]
8000ad74:	50 99       	stdsp	sp[0x24],r9
8000ad76:	50 26       	stdsp	sp[0x8],r6
8000ad78:	50 e1       	stdsp	sp[0x38],r1
8000ad7a:	04 9b       	mov	r11,r2
8000ad7c:	06 9c       	mov	r12,r3
8000ad7e:	fe b0 fa 7f 	rcall	8000a27c <quorem>
8000ad82:	40 4b       	lddsp	r11,sp[0x10]
8000ad84:	f8 c0 ff d0 	sub	r0,r12,-48
8000ad88:	06 9c       	mov	r12,r3
8000ad8a:	e0 a0 05 a8 	rcall	8000b8da <__mcmp>
8000ad8e:	08 9a       	mov	r10,r4
8000ad90:	50 6c       	stdsp	sp[0x18],r12
8000ad92:	04 9b       	mov	r11,r2
8000ad94:	0e 9c       	mov	r12,r7
8000ad96:	e0 a0 06 5d 	rcall	8000ba50 <__mdiff>
8000ad9a:	18 91       	mov	r1,r12
8000ad9c:	78 38       	ld.w	r8,r12[0xc]
8000ad9e:	58 08       	cp.w	r8,0
8000ada0:	c0 30       	breq	8000ada6 <_dtoa_r+0xa0a>
8000ada2:	30 16       	mov	r6,1
8000ada4:	c0 68       	rjmp	8000adb0 <_dtoa_r+0xa14>
8000ada6:	18 9b       	mov	r11,r12
8000ada8:	06 9c       	mov	r12,r3
8000adaa:	e0 a0 05 98 	rcall	8000b8da <__mcmp>
8000adae:	18 96       	mov	r6,r12
8000adb0:	0e 9c       	mov	r12,r7
8000adb2:	02 9b       	mov	r11,r1
8000adb4:	e0 a0 05 ac 	rcall	8000b90c <_Bfree>
8000adb8:	40 cc       	lddsp	r12,sp[0x30]
8000adba:	ed ec 10 08 	or	r8,r6,r12
8000adbe:	c0 d1       	brne	8000add8 <_dtoa_r+0xa3c>
8000adc0:	40 db       	lddsp	r11,sp[0x34]
8000adc2:	58 0b       	cp.w	r11,0
8000adc4:	c0 a1       	brne	8000add8 <_dtoa_r+0xa3c>
8000adc6:	40 26       	lddsp	r6,sp[0x8]
8000adc8:	e0 40 00 39 	cp.w	r0,57
8000adcc:	c3 00       	breq	8000ae2c <_dtoa_r+0xa90>
8000adce:	40 6a       	lddsp	r10,sp[0x18]
8000add0:	58 0a       	cp.w	r10,0
8000add2:	e0 89 00 24 	brgt	8000ae1a <_dtoa_r+0xa7e>
8000add6:	c2 f8       	rjmp	8000ae34 <_dtoa_r+0xa98>
8000add8:	40 69       	lddsp	r9,sp[0x18]
8000adda:	58 09       	cp.w	r9,0
8000addc:	c0 85       	brlt	8000adec <_dtoa_r+0xa50>
8000adde:	12 98       	mov	r8,r9
8000ade0:	40 cc       	lddsp	r12,sp[0x30]
8000ade2:	18 48       	or	r8,r12
8000ade4:	c1 d1       	brne	8000ae1e <_dtoa_r+0xa82>
8000ade6:	40 db       	lddsp	r11,sp[0x34]
8000ade8:	58 0b       	cp.w	r11,0
8000adea:	c1 a1       	brne	8000ae1e <_dtoa_r+0xa82>
8000adec:	0c 99       	mov	r9,r6
8000adee:	40 26       	lddsp	r6,sp[0x8]
8000adf0:	58 09       	cp.w	r9,0
8000adf2:	e0 8a 00 21 	brle	8000ae34 <_dtoa_r+0xa98>
8000adf6:	06 9b       	mov	r11,r3
8000adf8:	30 1a       	mov	r10,1
8000adfa:	0e 9c       	mov	r12,r7
8000adfc:	e0 a0 06 92 	rcall	8000bb20 <__lshift>
8000ae00:	04 9b       	mov	r11,r2
8000ae02:	18 93       	mov	r3,r12
8000ae04:	e0 a0 05 6b 	rcall	8000b8da <__mcmp>
8000ae08:	e0 89 00 06 	brgt	8000ae14 <_dtoa_r+0xa78>
8000ae0c:	c1 41       	brne	8000ae34 <_dtoa_r+0xa98>
8000ae0e:	ed b0 00 00 	bld	r0,0x0
8000ae12:	c1 11       	brne	8000ae34 <_dtoa_r+0xa98>
8000ae14:	e0 40 00 39 	cp.w	r0,57
8000ae18:	c0 a0       	breq	8000ae2c <_dtoa_r+0xa90>
8000ae1a:	2f f0       	sub	r0,-1
8000ae1c:	c0 c8       	rjmp	8000ae34 <_dtoa_r+0xa98>
8000ae1e:	58 06       	cp.w	r6,0
8000ae20:	e0 8a 00 0c 	brle	8000ae38 <_dtoa_r+0xa9c>
8000ae24:	40 26       	lddsp	r6,sp[0x8]
8000ae26:	e0 40 00 39 	cp.w	r0,57
8000ae2a:	c0 41       	brne	8000ae32 <_dtoa_r+0xa96>
8000ae2c:	33 98       	mov	r8,57
8000ae2e:	0a c8       	st.b	r5++,r8
8000ae30:	c6 78       	rjmp	8000aefe <_dtoa_r+0xb62>
8000ae32:	2f f0       	sub	r0,-1
8000ae34:	0a c0       	st.b	r5++,r0
8000ae36:	c7 58       	rjmp	8000af20 <_dtoa_r+0xb84>
8000ae38:	0a c0       	st.b	r5++,r0
8000ae3a:	40 9a       	lddsp	r10,sp[0x24]
8000ae3c:	40 e9       	lddsp	r9,sp[0x38]
8000ae3e:	12 3a       	cp.w	r10,r9
8000ae40:	c4 30       	breq	8000aec6 <_dtoa_r+0xb2a>
8000ae42:	06 9b       	mov	r11,r3
8000ae44:	30 09       	mov	r9,0
8000ae46:	30 aa       	mov	r10,10
8000ae48:	0e 9c       	mov	r12,r7
8000ae4a:	e0 a0 07 37 	rcall	8000bcb8 <__multadd>
8000ae4e:	40 48       	lddsp	r8,sp[0x10]
8000ae50:	18 93       	mov	r3,r12
8000ae52:	08 38       	cp.w	r8,r4
8000ae54:	c0 91       	brne	8000ae66 <_dtoa_r+0xaca>
8000ae56:	10 9b       	mov	r11,r8
8000ae58:	30 09       	mov	r9,0
8000ae5a:	30 aa       	mov	r10,10
8000ae5c:	0e 9c       	mov	r12,r7
8000ae5e:	e0 a0 07 2d 	rcall	8000bcb8 <__multadd>
8000ae62:	50 4c       	stdsp	sp[0x10],r12
8000ae64:	c0 e8       	rjmp	8000ae80 <_dtoa_r+0xae4>
8000ae66:	40 4b       	lddsp	r11,sp[0x10]
8000ae68:	30 09       	mov	r9,0
8000ae6a:	30 aa       	mov	r10,10
8000ae6c:	0e 9c       	mov	r12,r7
8000ae6e:	e0 a0 07 25 	rcall	8000bcb8 <__multadd>
8000ae72:	08 9b       	mov	r11,r4
8000ae74:	50 4c       	stdsp	sp[0x10],r12
8000ae76:	30 09       	mov	r9,0
8000ae78:	30 aa       	mov	r10,10
8000ae7a:	0e 9c       	mov	r12,r7
8000ae7c:	e0 a0 07 1e 	rcall	8000bcb8 <__multadd>
8000ae80:	18 94       	mov	r4,r12
8000ae82:	40 9c       	lddsp	r12,sp[0x24]
8000ae84:	2f fc       	sub	r12,-1
8000ae86:	50 9c       	stdsp	sp[0x24],r12
8000ae88:	c7 9b       	rjmp	8000ad7a <_dtoa_r+0x9de>
8000ae8a:	30 18       	mov	r8,1
8000ae8c:	06 90       	mov	r0,r3
8000ae8e:	40 85       	lddsp	r5,sp[0x20]
8000ae90:	08 93       	mov	r3,r4
8000ae92:	0c 94       	mov	r4,r6
8000ae94:	10 96       	mov	r6,r8
8000ae96:	04 9b       	mov	r11,r2
8000ae98:	00 9c       	mov	r12,r0
8000ae9a:	fe b0 f9 f1 	rcall	8000a27c <quorem>
8000ae9e:	2d 0c       	sub	r12,-48
8000aea0:	0a cc       	st.b	r5++,r12
8000aea2:	02 36       	cp.w	r6,r1
8000aea4:	c0 a4       	brge	8000aeb8 <_dtoa_r+0xb1c>
8000aea6:	00 9b       	mov	r11,r0
8000aea8:	30 09       	mov	r9,0
8000aeaa:	30 aa       	mov	r10,10
8000aeac:	0e 9c       	mov	r12,r7
8000aeae:	2f f6       	sub	r6,-1
8000aeb0:	e0 a0 07 04 	rcall	8000bcb8 <__multadd>
8000aeb4:	18 90       	mov	r0,r12
8000aeb6:	cf 0b       	rjmp	8000ae96 <_dtoa_r+0xafa>
8000aeb8:	08 96       	mov	r6,r4
8000aeba:	30 0b       	mov	r11,0
8000aebc:	06 94       	mov	r4,r3
8000aebe:	50 4b       	stdsp	sp[0x10],r11
8000aec0:	00 93       	mov	r3,r0
8000aec2:	18 90       	mov	r0,r12
8000aec4:	c0 28       	rjmp	8000aec8 <_dtoa_r+0xb2c>
8000aec6:	40 26       	lddsp	r6,sp[0x8]
8000aec8:	06 9b       	mov	r11,r3
8000aeca:	30 1a       	mov	r10,1
8000aecc:	0e 9c       	mov	r12,r7
8000aece:	e0 a0 06 29 	rcall	8000bb20 <__lshift>
8000aed2:	04 9b       	mov	r11,r2
8000aed4:	18 93       	mov	r3,r12
8000aed6:	e0 a0 05 02 	rcall	8000b8da <__mcmp>
8000aeda:	e0 89 00 12 	brgt	8000aefe <_dtoa_r+0xb62>
8000aede:	c1 b1       	brne	8000af14 <_dtoa_r+0xb78>
8000aee0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aee4:	c0 d1       	brne	8000aefe <_dtoa_r+0xb62>
8000aee6:	c1 78       	rjmp	8000af14 <_dtoa_r+0xb78>
8000aee8:	40 89       	lddsp	r9,sp[0x20]
8000aeea:	12 38       	cp.w	r8,r9
8000aeec:	c0 30       	breq	8000aef2 <_dtoa_r+0xb56>
8000aeee:	10 95       	mov	r5,r8
8000aef0:	c0 88       	rjmp	8000af00 <_dtoa_r+0xb64>
8000aef2:	2f f6       	sub	r6,-1
8000aef4:	50 66       	stdsp	sp[0x18],r6
8000aef6:	33 18       	mov	r8,49
8000aef8:	40 8c       	lddsp	r12,sp[0x20]
8000aefa:	b8 88       	st.b	r12[0x0],r8
8000aefc:	c1 38       	rjmp	8000af22 <_dtoa_r+0xb86>
8000aefe:	33 9a       	mov	r10,57
8000af00:	0a 98       	mov	r8,r5
8000af02:	11 79       	ld.ub	r9,--r8
8000af04:	f4 09 18 00 	cp.b	r9,r10
8000af08:	cf 00       	breq	8000aee8 <_dtoa_r+0xb4c>
8000af0a:	2f f9       	sub	r9,-1
8000af0c:	b0 89       	st.b	r8[0x0],r9
8000af0e:	c0 98       	rjmp	8000af20 <_dtoa_r+0xb84>
8000af10:	10 95       	mov	r5,r8
8000af12:	c0 28       	rjmp	8000af16 <_dtoa_r+0xb7a>
8000af14:	33 09       	mov	r9,48
8000af16:	0a 98       	mov	r8,r5
8000af18:	11 7a       	ld.ub	r10,--r8
8000af1a:	f2 0a 18 00 	cp.b	r10,r9
8000af1e:	cf 90       	breq	8000af10 <_dtoa_r+0xb74>
8000af20:	50 66       	stdsp	sp[0x18],r6
8000af22:	04 9b       	mov	r11,r2
8000af24:	0e 9c       	mov	r12,r7
8000af26:	e0 a0 04 f3 	rcall	8000b90c <_Bfree>
8000af2a:	58 04       	cp.w	r4,0
8000af2c:	c1 20       	breq	8000af50 <_dtoa_r+0xbb4>
8000af2e:	40 4b       	lddsp	r11,sp[0x10]
8000af30:	08 3b       	cp.w	r11,r4
8000af32:	5f 19       	srne	r9
8000af34:	58 0b       	cp.w	r11,0
8000af36:	5f 18       	srne	r8
8000af38:	f3 e8 00 08 	and	r8,r9,r8
8000af3c:	c0 40       	breq	8000af44 <_dtoa_r+0xba8>
8000af3e:	0e 9c       	mov	r12,r7
8000af40:	e0 a0 04 e6 	rcall	8000b90c <_Bfree>
8000af44:	08 9b       	mov	r11,r4
8000af46:	0e 9c       	mov	r12,r7
8000af48:	e0 a0 04 e2 	rcall	8000b90c <_Bfree>
8000af4c:	c0 28       	rjmp	8000af50 <_dtoa_r+0xbb4>
8000af4e:	50 66       	stdsp	sp[0x18],r6
8000af50:	0e 9c       	mov	r12,r7
8000af52:	06 9b       	mov	r11,r3
8000af54:	e0 a0 04 dc 	rcall	8000b90c <_Bfree>
8000af58:	30 08       	mov	r8,0
8000af5a:	aa 88       	st.b	r5[0x0],r8
8000af5c:	40 68       	lddsp	r8,sp[0x18]
8000af5e:	41 5a       	lddsp	r10,sp[0x54]
8000af60:	2f f8       	sub	r8,-1
8000af62:	41 29       	lddsp	r9,sp[0x48]
8000af64:	95 08       	st.w	r10[0x0],r8
8000af66:	40 8c       	lddsp	r12,sp[0x20]
8000af68:	58 09       	cp.w	r9,0
8000af6a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000af6e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000af72:	2e 6d       	sub	sp,-104
8000af74:	d8 32       	popm	r0-r7,pc
8000af76:	d7 03       	nop

8000af78 <__errno>:
8000af78:	e0 68 0a 48 	mov	r8,2632
8000af7c:	70 0c       	ld.w	r12,r8[0x0]
8000af7e:	2f 4c       	sub	r12,-12
8000af80:	5e fc       	retal	r12
8000af82:	d7 03       	nop

8000af84 <_fflush_r>:
8000af84:	d4 21       	pushm	r4-r7,lr
8000af86:	16 97       	mov	r7,r11
8000af88:	18 96       	mov	r6,r12
8000af8a:	76 48       	ld.w	r8,r11[0x10]
8000af8c:	58 08       	cp.w	r8,0
8000af8e:	c7 f0       	breq	8000b08c <_fflush_r+0x108>
8000af90:	58 0c       	cp.w	r12,0
8000af92:	c0 50       	breq	8000af9c <_fflush_r+0x18>
8000af94:	78 68       	ld.w	r8,r12[0x18]
8000af96:	58 08       	cp.w	r8,0
8000af98:	c0 21       	brne	8000af9c <_fflush_r+0x18>
8000af9a:	cc dc       	rcall	8000b134 <__sinit>
8000af9c:	fe c8 cd 0c 	sub	r8,pc,-13044
8000afa0:	10 37       	cp.w	r7,r8
8000afa2:	c0 31       	brne	8000afa8 <_fflush_r+0x24>
8000afa4:	6c 07       	ld.w	r7,r6[0x0]
8000afa6:	c0 c8       	rjmp	8000afbe <_fflush_r+0x3a>
8000afa8:	fe c8 cc f8 	sub	r8,pc,-13064
8000afac:	10 37       	cp.w	r7,r8
8000afae:	c0 31       	brne	8000afb4 <_fflush_r+0x30>
8000afb0:	6c 17       	ld.w	r7,r6[0x4]
8000afb2:	c0 68       	rjmp	8000afbe <_fflush_r+0x3a>
8000afb4:	fe c8 cc e4 	sub	r8,pc,-13084
8000afb8:	10 37       	cp.w	r7,r8
8000afba:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000afbe:	8e 6a       	ld.sh	r10,r7[0xc]
8000afc0:	14 98       	mov	r8,r10
8000afc2:	ed ba 00 03 	bld	r10,0x3
8000afc6:	c4 20       	breq	8000b04a <_fflush_r+0xc6>
8000afc8:	ab ba       	sbr	r10,0xb
8000afca:	ae 6a       	st.h	r7[0xc],r10
8000afcc:	6e 18       	ld.w	r8,r7[0x4]
8000afce:	58 08       	cp.w	r8,0
8000afd0:	e0 89 00 06 	brgt	8000afdc <_fflush_r+0x58>
8000afd4:	6f 08       	ld.w	r8,r7[0x40]
8000afd6:	58 08       	cp.w	r8,0
8000afd8:	e0 8a 00 5a 	brle	8000b08c <_fflush_r+0x108>
8000afdc:	6e b8       	ld.w	r8,r7[0x2c]
8000afde:	58 08       	cp.w	r8,0
8000afe0:	c5 60       	breq	8000b08c <_fflush_r+0x108>
8000afe2:	e2 1a 10 00 	andl	r10,0x1000,COH
8000afe6:	c0 30       	breq	8000afec <_fflush_r+0x68>
8000afe8:	6f 55       	ld.w	r5,r7[0x54]
8000afea:	c0 f8       	rjmp	8000b008 <_fflush_r+0x84>
8000afec:	30 19       	mov	r9,1
8000afee:	6e 8b       	ld.w	r11,r7[0x20]
8000aff0:	0c 9c       	mov	r12,r6
8000aff2:	5d 18       	icall	r8
8000aff4:	18 95       	mov	r5,r12
8000aff6:	5b fc       	cp.w	r12,-1
8000aff8:	c0 81       	brne	8000b008 <_fflush_r+0x84>
8000affa:	6c 38       	ld.w	r8,r6[0xc]
8000affc:	59 d8       	cp.w	r8,29
8000affe:	c4 70       	breq	8000b08c <_fflush_r+0x108>
8000b000:	8e 68       	ld.sh	r8,r7[0xc]
8000b002:	a7 a8       	sbr	r8,0x6
8000b004:	ae 68       	st.h	r7[0xc],r8
8000b006:	d8 22       	popm	r4-r7,pc
8000b008:	8e 68       	ld.sh	r8,r7[0xc]
8000b00a:	ed b8 00 02 	bld	r8,0x2
8000b00e:	c0 91       	brne	8000b020 <_fflush_r+0x9c>
8000b010:	6e 18       	ld.w	r8,r7[0x4]
8000b012:	10 15       	sub	r5,r8
8000b014:	6e d8       	ld.w	r8,r7[0x34]
8000b016:	58 08       	cp.w	r8,0
8000b018:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b01c:	eb d8 e1 15 	subne	r5,r5,r8
8000b020:	6e b8       	ld.w	r8,r7[0x2c]
8000b022:	0c 9c       	mov	r12,r6
8000b024:	30 09       	mov	r9,0
8000b026:	0a 9a       	mov	r10,r5
8000b028:	6e 8b       	ld.w	r11,r7[0x20]
8000b02a:	5d 18       	icall	r8
8000b02c:	8e 68       	ld.sh	r8,r7[0xc]
8000b02e:	0a 3c       	cp.w	r12,r5
8000b030:	c2 61       	brne	8000b07c <_fflush_r+0xf8>
8000b032:	ab d8       	cbr	r8,0xb
8000b034:	30 0c       	mov	r12,0
8000b036:	6e 49       	ld.w	r9,r7[0x10]
8000b038:	ae 68       	st.h	r7[0xc],r8
8000b03a:	8f 1c       	st.w	r7[0x4],r12
8000b03c:	8f 09       	st.w	r7[0x0],r9
8000b03e:	ed b8 00 0c 	bld	r8,0xc
8000b042:	c2 51       	brne	8000b08c <_fflush_r+0x108>
8000b044:	ef 45 00 54 	st.w	r7[84],r5
8000b048:	d8 22       	popm	r4-r7,pc
8000b04a:	6e 45       	ld.w	r5,r7[0x10]
8000b04c:	58 05       	cp.w	r5,0
8000b04e:	c1 f0       	breq	8000b08c <_fflush_r+0x108>
8000b050:	6e 04       	ld.w	r4,r7[0x0]
8000b052:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b056:	8f 05       	st.w	r7[0x0],r5
8000b058:	f9 b8 01 00 	movne	r8,0
8000b05c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b060:	0a 14       	sub	r4,r5
8000b062:	8f 28       	st.w	r7[0x8],r8
8000b064:	c1 18       	rjmp	8000b086 <_fflush_r+0x102>
8000b066:	08 99       	mov	r9,r4
8000b068:	0a 9a       	mov	r10,r5
8000b06a:	6e a8       	ld.w	r8,r7[0x28]
8000b06c:	6e 8b       	ld.w	r11,r7[0x20]
8000b06e:	0c 9c       	mov	r12,r6
8000b070:	5d 18       	icall	r8
8000b072:	18 14       	sub	r4,r12
8000b074:	58 0c       	cp.w	r12,0
8000b076:	e0 89 00 07 	brgt	8000b084 <_fflush_r+0x100>
8000b07a:	8e 68       	ld.sh	r8,r7[0xc]
8000b07c:	a7 a8       	sbr	r8,0x6
8000b07e:	3f fc       	mov	r12,-1
8000b080:	ae 68       	st.h	r7[0xc],r8
8000b082:	d8 22       	popm	r4-r7,pc
8000b084:	18 05       	add	r5,r12
8000b086:	58 04       	cp.w	r4,0
8000b088:	fe 99 ff ef 	brgt	8000b066 <_fflush_r+0xe2>
8000b08c:	d8 2a       	popm	r4-r7,pc,r12=0
8000b08e:	d7 03       	nop

8000b090 <__sfp_lock_acquire>:
8000b090:	5e fc       	retal	r12

8000b092 <__sfp_lock_release>:
8000b092:	5e fc       	retal	r12

8000b094 <_cleanup_r>:
8000b094:	d4 01       	pushm	lr
8000b096:	fe cb f0 ae 	sub	r11,pc,-3922
8000b09a:	e0 a0 02 f7 	rcall	8000b688 <_fwalk>
8000b09e:	d8 02       	popm	pc

8000b0a0 <__sfmoreglue>:
8000b0a0:	d4 21       	pushm	r4-r7,lr
8000b0a2:	16 95       	mov	r5,r11
8000b0a4:	f6 06 10 5c 	mul	r6,r11,92
8000b0a8:	ec cb ff f4 	sub	r11,r6,-12
8000b0ac:	fe b0 e2 76 	rcall	80007598 <_malloc_r>
8000b0b0:	18 97       	mov	r7,r12
8000b0b2:	c0 90       	breq	8000b0c4 <__sfmoreglue+0x24>
8000b0b4:	99 15       	st.w	r12[0x4],r5
8000b0b6:	30 0b       	mov	r11,0
8000b0b8:	2f 4c       	sub	r12,-12
8000b0ba:	0c 9a       	mov	r10,r6
8000b0bc:	8f 2c       	st.w	r7[0x8],r12
8000b0be:	8f 0b       	st.w	r7[0x0],r11
8000b0c0:	fe b0 e5 3f 	rcall	80007b3e <memset>
8000b0c4:	0e 9c       	mov	r12,r7
8000b0c6:	d8 22       	popm	r4-r7,pc

8000b0c8 <__sfp>:
8000b0c8:	d4 21       	pushm	r4-r7,lr
8000b0ca:	fe c8 cd d6 	sub	r8,pc,-12842
8000b0ce:	18 96       	mov	r6,r12
8000b0d0:	70 07       	ld.w	r7,r8[0x0]
8000b0d2:	6e 68       	ld.w	r8,r7[0x18]
8000b0d4:	58 08       	cp.w	r8,0
8000b0d6:	c0 31       	brne	8000b0dc <__sfp+0x14>
8000b0d8:	0e 9c       	mov	r12,r7
8000b0da:	c2 dc       	rcall	8000b134 <__sinit>
8000b0dc:	ee c7 ff 28 	sub	r7,r7,-216
8000b0e0:	30 05       	mov	r5,0
8000b0e2:	6e 2c       	ld.w	r12,r7[0x8]
8000b0e4:	6e 18       	ld.w	r8,r7[0x4]
8000b0e6:	c0 68       	rjmp	8000b0f2 <__sfp+0x2a>
8000b0e8:	98 69       	ld.sh	r9,r12[0xc]
8000b0ea:	ea 09 19 00 	cp.h	r9,r5
8000b0ee:	c1 10       	breq	8000b110 <__sfp+0x48>
8000b0f0:	2a 4c       	sub	r12,-92
8000b0f2:	20 18       	sub	r8,1
8000b0f4:	cf a7       	brpl	8000b0e8 <__sfp+0x20>
8000b0f6:	6e 08       	ld.w	r8,r7[0x0]
8000b0f8:	58 08       	cp.w	r8,0
8000b0fa:	c0 61       	brne	8000b106 <__sfp+0x3e>
8000b0fc:	30 4b       	mov	r11,4
8000b0fe:	0c 9c       	mov	r12,r6
8000b100:	cd 0f       	rcall	8000b0a0 <__sfmoreglue>
8000b102:	8f 0c       	st.w	r7[0x0],r12
8000b104:	c0 30       	breq	8000b10a <__sfp+0x42>
8000b106:	6e 07       	ld.w	r7,r7[0x0]
8000b108:	ce db       	rjmp	8000b0e2 <__sfp+0x1a>
8000b10a:	30 c8       	mov	r8,12
8000b10c:	8d 38       	st.w	r6[0xc],r8
8000b10e:	d8 22       	popm	r4-r7,pc
8000b110:	30 08       	mov	r8,0
8000b112:	f9 48 00 4c 	st.w	r12[76],r8
8000b116:	99 08       	st.w	r12[0x0],r8
8000b118:	99 28       	st.w	r12[0x8],r8
8000b11a:	99 18       	st.w	r12[0x4],r8
8000b11c:	99 48       	st.w	r12[0x10],r8
8000b11e:	99 58       	st.w	r12[0x14],r8
8000b120:	99 68       	st.w	r12[0x18],r8
8000b122:	99 d8       	st.w	r12[0x34],r8
8000b124:	99 e8       	st.w	r12[0x38],r8
8000b126:	f9 48 00 48 	st.w	r12[72],r8
8000b12a:	3f f8       	mov	r8,-1
8000b12c:	b8 78       	st.h	r12[0xe],r8
8000b12e:	30 18       	mov	r8,1
8000b130:	b8 68       	st.h	r12[0xc],r8
8000b132:	d8 22       	popm	r4-r7,pc

8000b134 <__sinit>:
8000b134:	d4 21       	pushm	r4-r7,lr
8000b136:	18 96       	mov	r6,r12
8000b138:	78 67       	ld.w	r7,r12[0x18]
8000b13a:	58 07       	cp.w	r7,0
8000b13c:	c4 91       	brne	8000b1ce <__sinit+0x9a>
8000b13e:	fe c8 00 aa 	sub	r8,pc,170
8000b142:	30 15       	mov	r5,1
8000b144:	99 a8       	st.w	r12[0x28],r8
8000b146:	f9 47 00 d8 	st.w	r12[216],r7
8000b14a:	f9 47 00 dc 	st.w	r12[220],r7
8000b14e:	f9 47 00 e0 	st.w	r12[224],r7
8000b152:	99 65       	st.w	r12[0x18],r5
8000b154:	cb af       	rcall	8000b0c8 <__sfp>
8000b156:	8d 0c       	st.w	r6[0x0],r12
8000b158:	0c 9c       	mov	r12,r6
8000b15a:	cb 7f       	rcall	8000b0c8 <__sfp>
8000b15c:	8d 1c       	st.w	r6[0x4],r12
8000b15e:	0c 9c       	mov	r12,r6
8000b160:	cb 4f       	rcall	8000b0c8 <__sfp>
8000b162:	6c 09       	ld.w	r9,r6[0x0]
8000b164:	30 48       	mov	r8,4
8000b166:	93 07       	st.w	r9[0x0],r7
8000b168:	b2 68       	st.h	r9[0xc],r8
8000b16a:	93 17       	st.w	r9[0x4],r7
8000b16c:	93 27       	st.w	r9[0x8],r7
8000b16e:	6c 18       	ld.w	r8,r6[0x4]
8000b170:	b2 77       	st.h	r9[0xe],r7
8000b172:	93 47       	st.w	r9[0x10],r7
8000b174:	93 57       	st.w	r9[0x14],r7
8000b176:	93 67       	st.w	r9[0x18],r7
8000b178:	93 89       	st.w	r9[0x20],r9
8000b17a:	91 07       	st.w	r8[0x0],r7
8000b17c:	91 17       	st.w	r8[0x4],r7
8000b17e:	91 27       	st.w	r8[0x8],r7
8000b180:	fe ce f3 24 	sub	lr,pc,-3292
8000b184:	fe cb f3 54 	sub	r11,pc,-3244
8000b188:	93 9e       	st.w	r9[0x24],lr
8000b18a:	93 ab       	st.w	r9[0x28],r11
8000b18c:	fe ca f3 7c 	sub	r10,pc,-3204
8000b190:	fe c4 f3 88 	sub	r4,pc,-3192
8000b194:	93 ba       	st.w	r9[0x2c],r10
8000b196:	93 c4       	st.w	r9[0x30],r4
8000b198:	30 99       	mov	r9,9
8000b19a:	b0 69       	st.h	r8[0xc],r9
8000b19c:	b0 75       	st.h	r8[0xe],r5
8000b19e:	91 c4       	st.w	r8[0x30],r4
8000b1a0:	91 47       	st.w	r8[0x10],r7
8000b1a2:	91 57       	st.w	r8[0x14],r7
8000b1a4:	91 67       	st.w	r8[0x18],r7
8000b1a6:	91 88       	st.w	r8[0x20],r8
8000b1a8:	91 9e       	st.w	r8[0x24],lr
8000b1aa:	91 ab       	st.w	r8[0x28],r11
8000b1ac:	91 ba       	st.w	r8[0x2c],r10
8000b1ae:	8d 2c       	st.w	r6[0x8],r12
8000b1b0:	31 28       	mov	r8,18
8000b1b2:	99 07       	st.w	r12[0x0],r7
8000b1b4:	b8 68       	st.h	r12[0xc],r8
8000b1b6:	99 17       	st.w	r12[0x4],r7
8000b1b8:	99 27       	st.w	r12[0x8],r7
8000b1ba:	30 28       	mov	r8,2
8000b1bc:	b8 78       	st.h	r12[0xe],r8
8000b1be:	99 c4       	st.w	r12[0x30],r4
8000b1c0:	99 67       	st.w	r12[0x18],r7
8000b1c2:	99 9e       	st.w	r12[0x24],lr
8000b1c4:	99 ab       	st.w	r12[0x28],r11
8000b1c6:	99 ba       	st.w	r12[0x2c],r10
8000b1c8:	99 47       	st.w	r12[0x10],r7
8000b1ca:	99 57       	st.w	r12[0x14],r7
8000b1cc:	99 8c       	st.w	r12[0x20],r12
8000b1ce:	d8 22       	popm	r4-r7,pc

8000b1d0 <_malloc_trim_r>:
8000b1d0:	d4 21       	pushm	r4-r7,lr
8000b1d2:	16 95       	mov	r5,r11
8000b1d4:	18 97       	mov	r7,r12
8000b1d6:	fe b0 d7 c5 	rcall	80006160 <__malloc_lock>
8000b1da:	e0 64 05 48 	mov	r4,1352
8000b1de:	68 28       	ld.w	r8,r4[0x8]
8000b1e0:	70 16       	ld.w	r6,r8[0x4]
8000b1e2:	e0 16 ff fc 	andl	r6,0xfffc
8000b1e6:	ec c8 ff 91 	sub	r8,r6,-111
8000b1ea:	f0 05 01 05 	sub	r5,r8,r5
8000b1ee:	e0 15 ff 80 	andl	r5,0xff80
8000b1f2:	ea c5 00 80 	sub	r5,r5,128
8000b1f6:	e0 45 00 7f 	cp.w	r5,127
8000b1fa:	e0 8a 00 25 	brle	8000b244 <_malloc_trim_r+0x74>
8000b1fe:	30 0b       	mov	r11,0
8000b200:	0e 9c       	mov	r12,r7
8000b202:	fe b0 e6 05 	rcall	80007e0c <_sbrk_r>
8000b206:	68 28       	ld.w	r8,r4[0x8]
8000b208:	0c 08       	add	r8,r6
8000b20a:	10 3c       	cp.w	r12,r8
8000b20c:	c1 c1       	brne	8000b244 <_malloc_trim_r+0x74>
8000b20e:	ea 0b 11 00 	rsub	r11,r5,0
8000b212:	0e 9c       	mov	r12,r7
8000b214:	fe b0 e5 fc 	rcall	80007e0c <_sbrk_r>
8000b218:	5b fc       	cp.w	r12,-1
8000b21a:	c1 91       	brne	8000b24c <_malloc_trim_r+0x7c>
8000b21c:	30 0b       	mov	r11,0
8000b21e:	0e 9c       	mov	r12,r7
8000b220:	fe b0 e5 f6 	rcall	80007e0c <_sbrk_r>
8000b224:	68 28       	ld.w	r8,r4[0x8]
8000b226:	f8 08 01 09 	sub	r9,r12,r8
8000b22a:	58 f9       	cp.w	r9,15
8000b22c:	e0 8a 00 0c 	brle	8000b244 <_malloc_trim_r+0x74>
8000b230:	a1 a9       	sbr	r9,0x0
8000b232:	91 19       	st.w	r8[0x4],r9
8000b234:	e0 68 09 54 	mov	r8,2388
8000b238:	70 09       	ld.w	r9,r8[0x0]
8000b23a:	e0 68 0d c0 	mov	r8,3520
8000b23e:	f8 09 01 09 	sub	r9,r12,r9
8000b242:	91 09       	st.w	r8[0x0],r9
8000b244:	0e 9c       	mov	r12,r7
8000b246:	fe b0 d7 93 	rcall	8000616c <__malloc_unlock>
8000b24a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b24c:	68 28       	ld.w	r8,r4[0x8]
8000b24e:	0a 16       	sub	r6,r5
8000b250:	a1 a6       	sbr	r6,0x0
8000b252:	91 16       	st.w	r8[0x4],r6
8000b254:	e0 68 0d c0 	mov	r8,3520
8000b258:	70 09       	ld.w	r9,r8[0x0]
8000b25a:	0a 19       	sub	r9,r5
8000b25c:	0e 9c       	mov	r12,r7
8000b25e:	91 09       	st.w	r8[0x0],r9
8000b260:	fe b0 d7 86 	rcall	8000616c <__malloc_unlock>
8000b264:	da 2a       	popm	r4-r7,pc,r12=1
8000b266:	d7 03       	nop

8000b268 <_free_r>:
8000b268:	d4 21       	pushm	r4-r7,lr
8000b26a:	16 96       	mov	r6,r11
8000b26c:	18 97       	mov	r7,r12
8000b26e:	58 0b       	cp.w	r11,0
8000b270:	e0 80 00 c0 	breq	8000b3f0 <_free_r+0x188>
8000b274:	fe b0 d7 76 	rcall	80006160 <__malloc_lock>
8000b278:	20 86       	sub	r6,8
8000b27a:	e0 6a 05 48 	mov	r10,1352
8000b27e:	6c 18       	ld.w	r8,r6[0x4]
8000b280:	74 2e       	ld.w	lr,r10[0x8]
8000b282:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b286:	a1 c8       	cbr	r8,0x0
8000b288:	ec 08 00 09 	add	r9,r6,r8
8000b28c:	72 1b       	ld.w	r11,r9[0x4]
8000b28e:	e0 1b ff fc 	andl	r11,0xfffc
8000b292:	1c 39       	cp.w	r9,lr
8000b294:	c1 e1       	brne	8000b2d0 <_free_r+0x68>
8000b296:	f6 08 00 08 	add	r8,r11,r8
8000b29a:	58 0c       	cp.w	r12,0
8000b29c:	c0 81       	brne	8000b2ac <_free_r+0x44>
8000b29e:	6c 09       	ld.w	r9,r6[0x0]
8000b2a0:	12 16       	sub	r6,r9
8000b2a2:	12 08       	add	r8,r9
8000b2a4:	6c 3b       	ld.w	r11,r6[0xc]
8000b2a6:	6c 29       	ld.w	r9,r6[0x8]
8000b2a8:	97 29       	st.w	r11[0x8],r9
8000b2aa:	93 3b       	st.w	r9[0xc],r11
8000b2ac:	10 99       	mov	r9,r8
8000b2ae:	95 26       	st.w	r10[0x8],r6
8000b2b0:	a1 a9       	sbr	r9,0x0
8000b2b2:	8d 19       	st.w	r6[0x4],r9
8000b2b4:	e0 69 09 50 	mov	r9,2384
8000b2b8:	72 09       	ld.w	r9,r9[0x0]
8000b2ba:	12 38       	cp.w	r8,r9
8000b2bc:	c0 63       	brcs	8000b2c8 <_free_r+0x60>
8000b2be:	e0 68 0d bc 	mov	r8,3516
8000b2c2:	0e 9c       	mov	r12,r7
8000b2c4:	70 0b       	ld.w	r11,r8[0x0]
8000b2c6:	c8 5f       	rcall	8000b1d0 <_malloc_trim_r>
8000b2c8:	0e 9c       	mov	r12,r7
8000b2ca:	fe b0 d7 51 	rcall	8000616c <__malloc_unlock>
8000b2ce:	d8 22       	popm	r4-r7,pc
8000b2d0:	93 1b       	st.w	r9[0x4],r11
8000b2d2:	58 0c       	cp.w	r12,0
8000b2d4:	c0 30       	breq	8000b2da <_free_r+0x72>
8000b2d6:	30 0c       	mov	r12,0
8000b2d8:	c1 08       	rjmp	8000b2f8 <_free_r+0x90>
8000b2da:	6c 0e       	ld.w	lr,r6[0x0]
8000b2dc:	f4 c5 ff f8 	sub	r5,r10,-8
8000b2e0:	1c 16       	sub	r6,lr
8000b2e2:	1c 08       	add	r8,lr
8000b2e4:	6c 2e       	ld.w	lr,r6[0x8]
8000b2e6:	0a 3e       	cp.w	lr,r5
8000b2e8:	f9 bc 00 01 	moveq	r12,1
8000b2ec:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b2f0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b2f4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b2f8:	f2 0b 00 0e 	add	lr,r9,r11
8000b2fc:	7c 1e       	ld.w	lr,lr[0x4]
8000b2fe:	ed be 00 00 	bld	lr,0x0
8000b302:	c1 40       	breq	8000b32a <_free_r+0xc2>
8000b304:	16 08       	add	r8,r11
8000b306:	58 0c       	cp.w	r12,0
8000b308:	c0 d1       	brne	8000b322 <_free_r+0xba>
8000b30a:	e0 6e 05 48 	mov	lr,1352
8000b30e:	72 2b       	ld.w	r11,r9[0x8]
8000b310:	2f 8e       	sub	lr,-8
8000b312:	1c 3b       	cp.w	r11,lr
8000b314:	c0 71       	brne	8000b322 <_free_r+0xba>
8000b316:	97 36       	st.w	r11[0xc],r6
8000b318:	97 26       	st.w	r11[0x8],r6
8000b31a:	8d 2b       	st.w	r6[0x8],r11
8000b31c:	8d 3b       	st.w	r6[0xc],r11
8000b31e:	30 1c       	mov	r12,1
8000b320:	c0 58       	rjmp	8000b32a <_free_r+0xc2>
8000b322:	72 2b       	ld.w	r11,r9[0x8]
8000b324:	72 39       	ld.w	r9,r9[0xc]
8000b326:	93 2b       	st.w	r9[0x8],r11
8000b328:	97 39       	st.w	r11[0xc],r9
8000b32a:	10 99       	mov	r9,r8
8000b32c:	ec 08 09 08 	st.w	r6[r8],r8
8000b330:	a1 a9       	sbr	r9,0x0
8000b332:	8d 19       	st.w	r6[0x4],r9
8000b334:	58 0c       	cp.w	r12,0
8000b336:	c5 a1       	brne	8000b3ea <_free_r+0x182>
8000b338:	e0 48 01 ff 	cp.w	r8,511
8000b33c:	e0 8b 00 13 	brhi	8000b362 <_free_r+0xfa>
8000b340:	a3 98       	lsr	r8,0x3
8000b342:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b346:	72 2b       	ld.w	r11,r9[0x8]
8000b348:	8d 39       	st.w	r6[0xc],r9
8000b34a:	8d 2b       	st.w	r6[0x8],r11
8000b34c:	97 36       	st.w	r11[0xc],r6
8000b34e:	93 26       	st.w	r9[0x8],r6
8000b350:	a3 48       	asr	r8,0x2
8000b352:	74 19       	ld.w	r9,r10[0x4]
8000b354:	30 1b       	mov	r11,1
8000b356:	f6 08 09 48 	lsl	r8,r11,r8
8000b35a:	f3 e8 10 08 	or	r8,r9,r8
8000b35e:	95 18       	st.w	r10[0x4],r8
8000b360:	c4 58       	rjmp	8000b3ea <_free_r+0x182>
8000b362:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b366:	58 4b       	cp.w	r11,4
8000b368:	e0 8b 00 06 	brhi	8000b374 <_free_r+0x10c>
8000b36c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b370:	2c 8b       	sub	r11,-56
8000b372:	c2 08       	rjmp	8000b3b2 <_free_r+0x14a>
8000b374:	59 4b       	cp.w	r11,20
8000b376:	e0 8b 00 04 	brhi	8000b37e <_free_r+0x116>
8000b37a:	2a 5b       	sub	r11,-91
8000b37c:	c1 b8       	rjmp	8000b3b2 <_free_r+0x14a>
8000b37e:	e0 4b 00 54 	cp.w	r11,84
8000b382:	e0 8b 00 06 	brhi	8000b38e <_free_r+0x126>
8000b386:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b38a:	29 2b       	sub	r11,-110
8000b38c:	c1 38       	rjmp	8000b3b2 <_free_r+0x14a>
8000b38e:	e0 4b 01 54 	cp.w	r11,340
8000b392:	e0 8b 00 06 	brhi	8000b39e <_free_r+0x136>
8000b396:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b39a:	28 9b       	sub	r11,-119
8000b39c:	c0 b8       	rjmp	8000b3b2 <_free_r+0x14a>
8000b39e:	e0 4b 05 54 	cp.w	r11,1364
8000b3a2:	e0 88 00 05 	brls	8000b3ac <_free_r+0x144>
8000b3a6:	37 eb       	mov	r11,126
8000b3a8:	c0 58       	rjmp	8000b3b2 <_free_r+0x14a>
8000b3aa:	d7 03       	nop
8000b3ac:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b3b0:	28 4b       	sub	r11,-124
8000b3b2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b3b6:	78 29       	ld.w	r9,r12[0x8]
8000b3b8:	18 39       	cp.w	r9,r12
8000b3ba:	c0 e1       	brne	8000b3d6 <_free_r+0x16e>
8000b3bc:	74 18       	ld.w	r8,r10[0x4]
8000b3be:	a3 4b       	asr	r11,0x2
8000b3c0:	30 1c       	mov	r12,1
8000b3c2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b3c6:	f1 eb 10 0b 	or	r11,r8,r11
8000b3ca:	12 98       	mov	r8,r9
8000b3cc:	95 1b       	st.w	r10[0x4],r11
8000b3ce:	c0 a8       	rjmp	8000b3e2 <_free_r+0x17a>
8000b3d0:	72 29       	ld.w	r9,r9[0x8]
8000b3d2:	18 39       	cp.w	r9,r12
8000b3d4:	c0 60       	breq	8000b3e0 <_free_r+0x178>
8000b3d6:	72 1a       	ld.w	r10,r9[0x4]
8000b3d8:	e0 1a ff fc 	andl	r10,0xfffc
8000b3dc:	14 38       	cp.w	r8,r10
8000b3de:	cf 93       	brcs	8000b3d0 <_free_r+0x168>
8000b3e0:	72 38       	ld.w	r8,r9[0xc]
8000b3e2:	8d 38       	st.w	r6[0xc],r8
8000b3e4:	8d 29       	st.w	r6[0x8],r9
8000b3e6:	93 36       	st.w	r9[0xc],r6
8000b3e8:	91 26       	st.w	r8[0x8],r6
8000b3ea:	0e 9c       	mov	r12,r7
8000b3ec:	fe b0 d6 c0 	rcall	8000616c <__malloc_unlock>
8000b3f0:	d8 22       	popm	r4-r7,pc
8000b3f2:	d7 03       	nop

8000b3f4 <__sfvwrite_r>:
8000b3f4:	d4 31       	pushm	r0-r7,lr
8000b3f6:	20 3d       	sub	sp,12
8000b3f8:	14 94       	mov	r4,r10
8000b3fa:	18 95       	mov	r5,r12
8000b3fc:	16 97       	mov	r7,r11
8000b3fe:	74 28       	ld.w	r8,r10[0x8]
8000b400:	58 08       	cp.w	r8,0
8000b402:	e0 80 01 40 	breq	8000b682 <__sfvwrite_r+0x28e>
8000b406:	96 68       	ld.sh	r8,r11[0xc]
8000b408:	ed b8 00 03 	bld	r8,0x3
8000b40c:	c0 41       	brne	8000b414 <__sfvwrite_r+0x20>
8000b40e:	76 48       	ld.w	r8,r11[0x10]
8000b410:	58 08       	cp.w	r8,0
8000b412:	c0 c1       	brne	8000b42a <__sfvwrite_r+0x36>
8000b414:	0e 9b       	mov	r11,r7
8000b416:	0a 9c       	mov	r12,r5
8000b418:	fe b0 f6 c4 	rcall	8000a1a0 <__swsetup_r>
8000b41c:	c0 70       	breq	8000b42a <__sfvwrite_r+0x36>
8000b41e:	8e 68       	ld.sh	r8,r7[0xc]
8000b420:	a7 a8       	sbr	r8,0x6
8000b422:	ae 68       	st.h	r7[0xc],r8
8000b424:	30 98       	mov	r8,9
8000b426:	8b 38       	st.w	r5[0xc],r8
8000b428:	c2 b9       	rjmp	8000b67e <__sfvwrite_r+0x28a>
8000b42a:	8e 63       	ld.sh	r3,r7[0xc]
8000b42c:	68 00       	ld.w	r0,r4[0x0]
8000b42e:	06 96       	mov	r6,r3
8000b430:	e2 16 00 02 	andl	r6,0x2,COH
8000b434:	c2 10       	breq	8000b476 <__sfvwrite_r+0x82>
8000b436:	30 03       	mov	r3,0
8000b438:	e0 62 04 00 	mov	r2,1024
8000b43c:	06 96       	mov	r6,r3
8000b43e:	c0 48       	rjmp	8000b446 <__sfvwrite_r+0x52>
8000b440:	60 03       	ld.w	r3,r0[0x0]
8000b442:	60 16       	ld.w	r6,r0[0x4]
8000b444:	2f 80       	sub	r0,-8
8000b446:	58 06       	cp.w	r6,0
8000b448:	cf c0       	breq	8000b440 <__sfvwrite_r+0x4c>
8000b44a:	e0 46 04 00 	cp.w	r6,1024
8000b44e:	ec 09 17 80 	movls	r9,r6
8000b452:	e4 09 17 b0 	movhi	r9,r2
8000b456:	06 9a       	mov	r10,r3
8000b458:	6e a8       	ld.w	r8,r7[0x28]
8000b45a:	6e 8b       	ld.w	r11,r7[0x20]
8000b45c:	0a 9c       	mov	r12,r5
8000b45e:	5d 18       	icall	r8
8000b460:	18 16       	sub	r6,r12
8000b462:	58 0c       	cp.w	r12,0
8000b464:	e0 8a 01 0a 	brle	8000b678 <__sfvwrite_r+0x284>
8000b468:	68 28       	ld.w	r8,r4[0x8]
8000b46a:	18 18       	sub	r8,r12
8000b46c:	89 28       	st.w	r4[0x8],r8
8000b46e:	e0 80 01 0a 	breq	8000b682 <__sfvwrite_r+0x28e>
8000b472:	18 03       	add	r3,r12
8000b474:	ce 9b       	rjmp	8000b446 <__sfvwrite_r+0x52>
8000b476:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b47a:	c0 70       	breq	8000b488 <__sfvwrite_r+0x94>
8000b47c:	50 06       	stdsp	sp[0x0],r6
8000b47e:	0c 93       	mov	r3,r6
8000b480:	0c 91       	mov	r1,r6
8000b482:	50 15       	stdsp	sp[0x4],r5
8000b484:	08 92       	mov	r2,r4
8000b486:	c9 c8       	rjmp	8000b5be <__sfvwrite_r+0x1ca>
8000b488:	06 96       	mov	r6,r3
8000b48a:	08 91       	mov	r1,r4
8000b48c:	c0 48       	rjmp	8000b494 <__sfvwrite_r+0xa0>
8000b48e:	60 03       	ld.w	r3,r0[0x0]
8000b490:	60 16       	ld.w	r6,r0[0x4]
8000b492:	2f 80       	sub	r0,-8
8000b494:	58 06       	cp.w	r6,0
8000b496:	cf c0       	breq	8000b48e <__sfvwrite_r+0x9a>
8000b498:	8e 68       	ld.sh	r8,r7[0xc]
8000b49a:	6e 24       	ld.w	r4,r7[0x8]
8000b49c:	10 99       	mov	r9,r8
8000b49e:	e2 19 02 00 	andl	r9,0x200,COH
8000b4a2:	c5 50       	breq	8000b54c <__sfvwrite_r+0x158>
8000b4a4:	08 36       	cp.w	r6,r4
8000b4a6:	c4 43       	brcs	8000b52e <__sfvwrite_r+0x13a>
8000b4a8:	10 99       	mov	r9,r8
8000b4aa:	e2 19 04 80 	andl	r9,0x480,COH
8000b4ae:	c4 00       	breq	8000b52e <__sfvwrite_r+0x13a>
8000b4b0:	6e 4b       	ld.w	r11,r7[0x10]
8000b4b2:	6e 09       	ld.w	r9,r7[0x0]
8000b4b4:	16 19       	sub	r9,r11
8000b4b6:	50 09       	stdsp	sp[0x0],r9
8000b4b8:	6e 59       	ld.w	r9,r7[0x14]
8000b4ba:	10 9c       	mov	r12,r8
8000b4bc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b4c0:	30 28       	mov	r8,2
8000b4c2:	f4 08 0c 08 	divs	r8,r10,r8
8000b4c6:	fa e9 00 04 	st.d	sp[4],r8
8000b4ca:	10 94       	mov	r4,r8
8000b4cc:	40 09       	lddsp	r9,sp[0x0]
8000b4ce:	e2 1c 04 00 	andl	r12,0x400,COH
8000b4d2:	2f f9       	sub	r9,-1
8000b4d4:	0c 09       	add	r9,r6
8000b4d6:	12 38       	cp.w	r8,r9
8000b4d8:	f2 04 17 30 	movlo	r4,r9
8000b4dc:	58 0c       	cp.w	r12,0
8000b4de:	c1 10       	breq	8000b500 <__sfvwrite_r+0x10c>
8000b4e0:	08 9b       	mov	r11,r4
8000b4e2:	0a 9c       	mov	r12,r5
8000b4e4:	fe b0 e0 5a 	rcall	80007598 <_malloc_r>
8000b4e8:	18 92       	mov	r2,r12
8000b4ea:	c1 40       	breq	8000b512 <__sfvwrite_r+0x11e>
8000b4ec:	40 0a       	lddsp	r10,sp[0x0]
8000b4ee:	6e 4b       	ld.w	r11,r7[0x10]
8000b4f0:	fe b0 e2 83 	rcall	800079f6 <memcpy>
8000b4f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b4f6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b4fa:	a7 b8       	sbr	r8,0x7
8000b4fc:	ae 68       	st.h	r7[0xc],r8
8000b4fe:	c0 d8       	rjmp	8000b518 <__sfvwrite_r+0x124>
8000b500:	08 9a       	mov	r10,r4
8000b502:	0a 9c       	mov	r12,r5
8000b504:	fe b0 e3 24 	rcall	80007b4c <_realloc_r>
8000b508:	18 92       	mov	r2,r12
8000b50a:	c0 71       	brne	8000b518 <__sfvwrite_r+0x124>
8000b50c:	6e 4b       	ld.w	r11,r7[0x10]
8000b50e:	0a 9c       	mov	r12,r5
8000b510:	ca ce       	rcall	8000b268 <_free_r>
8000b512:	30 c8       	mov	r8,12
8000b514:	8b 38       	st.w	r5[0xc],r8
8000b516:	cb 18       	rjmp	8000b678 <__sfvwrite_r+0x284>
8000b518:	40 0a       	lddsp	r10,sp[0x0]
8000b51a:	40 09       	lddsp	r9,sp[0x0]
8000b51c:	e8 0a 01 0a 	sub	r10,r4,r10
8000b520:	e4 09 00 08 	add	r8,r2,r9
8000b524:	8f 54       	st.w	r7[0x14],r4
8000b526:	8f 2a       	st.w	r7[0x8],r10
8000b528:	8f 08       	st.w	r7[0x0],r8
8000b52a:	8f 42       	st.w	r7[0x10],r2
8000b52c:	0c 94       	mov	r4,r6
8000b52e:	08 36       	cp.w	r6,r4
8000b530:	ec 04 17 30 	movlo	r4,r6
8000b534:	06 9b       	mov	r11,r3
8000b536:	08 9a       	mov	r10,r4
8000b538:	6e 0c       	ld.w	r12,r7[0x0]
8000b53a:	c3 ad       	rcall	8000b7ae <memmove>
8000b53c:	6e 08       	ld.w	r8,r7[0x0]
8000b53e:	08 08       	add	r8,r4
8000b540:	8f 08       	st.w	r7[0x0],r8
8000b542:	6e 28       	ld.w	r8,r7[0x8]
8000b544:	08 18       	sub	r8,r4
8000b546:	0c 94       	mov	r4,r6
8000b548:	8f 28       	st.w	r7[0x8],r8
8000b54a:	c2 e8       	rjmp	8000b5a6 <__sfvwrite_r+0x1b2>
8000b54c:	08 36       	cp.w	r6,r4
8000b54e:	5f ba       	srhi	r10
8000b550:	6e 0c       	ld.w	r12,r7[0x0]
8000b552:	6e 48       	ld.w	r8,r7[0x10]
8000b554:	10 3c       	cp.w	r12,r8
8000b556:	5f b8       	srhi	r8
8000b558:	f5 e8 00 08 	and	r8,r10,r8
8000b55c:	f2 08 18 00 	cp.b	r8,r9
8000b560:	c0 d0       	breq	8000b57a <__sfvwrite_r+0x186>
8000b562:	06 9b       	mov	r11,r3
8000b564:	08 9a       	mov	r10,r4
8000b566:	c2 4d       	rcall	8000b7ae <memmove>
8000b568:	6e 08       	ld.w	r8,r7[0x0]
8000b56a:	08 08       	add	r8,r4
8000b56c:	0e 9b       	mov	r11,r7
8000b56e:	8f 08       	st.w	r7[0x0],r8
8000b570:	0a 9c       	mov	r12,r5
8000b572:	fe b0 fd 09 	rcall	8000af84 <_fflush_r>
8000b576:	c1 80       	breq	8000b5a6 <__sfvwrite_r+0x1b2>
8000b578:	c8 08       	rjmp	8000b678 <__sfvwrite_r+0x284>
8000b57a:	6e 59       	ld.w	r9,r7[0x14]
8000b57c:	12 36       	cp.w	r6,r9
8000b57e:	c0 a3       	brcs	8000b592 <__sfvwrite_r+0x19e>
8000b580:	6e a8       	ld.w	r8,r7[0x28]
8000b582:	06 9a       	mov	r10,r3
8000b584:	6e 8b       	ld.w	r11,r7[0x20]
8000b586:	0a 9c       	mov	r12,r5
8000b588:	5d 18       	icall	r8
8000b58a:	18 94       	mov	r4,r12
8000b58c:	e0 89 00 0d 	brgt	8000b5a6 <__sfvwrite_r+0x1b2>
8000b590:	c7 48       	rjmp	8000b678 <__sfvwrite_r+0x284>
8000b592:	0c 9a       	mov	r10,r6
8000b594:	06 9b       	mov	r11,r3
8000b596:	c0 cd       	rcall	8000b7ae <memmove>
8000b598:	6e 08       	ld.w	r8,r7[0x0]
8000b59a:	0c 08       	add	r8,r6
8000b59c:	0c 94       	mov	r4,r6
8000b59e:	8f 08       	st.w	r7[0x0],r8
8000b5a0:	6e 28       	ld.w	r8,r7[0x8]
8000b5a2:	0c 18       	sub	r8,r6
8000b5a4:	8f 28       	st.w	r7[0x8],r8
8000b5a6:	62 28       	ld.w	r8,r1[0x8]
8000b5a8:	08 18       	sub	r8,r4
8000b5aa:	83 28       	st.w	r1[0x8],r8
8000b5ac:	c6 b0       	breq	8000b682 <__sfvwrite_r+0x28e>
8000b5ae:	08 16       	sub	r6,r4
8000b5b0:	08 03       	add	r3,r4
8000b5b2:	c7 1b       	rjmp	8000b494 <__sfvwrite_r+0xa0>
8000b5b4:	60 03       	ld.w	r3,r0[0x0]
8000b5b6:	60 11       	ld.w	r1,r0[0x4]
8000b5b8:	30 08       	mov	r8,0
8000b5ba:	2f 80       	sub	r0,-8
8000b5bc:	50 08       	stdsp	sp[0x0],r8
8000b5be:	58 01       	cp.w	r1,0
8000b5c0:	cf a0       	breq	8000b5b4 <__sfvwrite_r+0x1c0>
8000b5c2:	40 0a       	lddsp	r10,sp[0x0]
8000b5c4:	58 0a       	cp.w	r10,0
8000b5c6:	c1 41       	brne	8000b5ee <__sfvwrite_r+0x1fa>
8000b5c8:	e2 c6 ff ff 	sub	r6,r1,-1
8000b5cc:	02 9a       	mov	r10,r1
8000b5ce:	30 ab       	mov	r11,10
8000b5d0:	06 9c       	mov	r12,r3
8000b5d2:	ce 3c       	rcall	8000b798 <memchr>
8000b5d4:	f8 c8 ff ff 	sub	r8,r12,-1
8000b5d8:	58 0c       	cp.w	r12,0
8000b5da:	f1 d3 e1 16 	subne	r6,r8,r3
8000b5de:	f9 b9 01 01 	movne	r9,1
8000b5e2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b5e6:	f9 b8 00 01 	moveq	r8,1
8000b5ea:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b5ee:	02 36       	cp.w	r6,r1
8000b5f0:	ec 04 17 80 	movls	r4,r6
8000b5f4:	e2 04 17 b0 	movhi	r4,r1
8000b5f8:	6e 59       	ld.w	r9,r7[0x14]
8000b5fa:	6e 25       	ld.w	r5,r7[0x8]
8000b5fc:	f2 05 00 05 	add	r5,r9,r5
8000b600:	0a 34       	cp.w	r4,r5
8000b602:	5f 9a       	srgt	r10
8000b604:	6e 0c       	ld.w	r12,r7[0x0]
8000b606:	6e 48       	ld.w	r8,r7[0x10]
8000b608:	10 3c       	cp.w	r12,r8
8000b60a:	5f b8       	srhi	r8
8000b60c:	f5 e8 00 08 	and	r8,r10,r8
8000b610:	30 0a       	mov	r10,0
8000b612:	f4 08 18 00 	cp.b	r8,r10
8000b616:	c0 d0       	breq	8000b630 <__sfvwrite_r+0x23c>
8000b618:	06 9b       	mov	r11,r3
8000b61a:	0a 9a       	mov	r10,r5
8000b61c:	cc 9c       	rcall	8000b7ae <memmove>
8000b61e:	6e 08       	ld.w	r8,r7[0x0]
8000b620:	0a 08       	add	r8,r5
8000b622:	0e 9b       	mov	r11,r7
8000b624:	8f 08       	st.w	r7[0x0],r8
8000b626:	40 1c       	lddsp	r12,sp[0x4]
8000b628:	fe b0 fc ae 	rcall	8000af84 <_fflush_r>
8000b62c:	c1 70       	breq	8000b65a <__sfvwrite_r+0x266>
8000b62e:	c2 58       	rjmp	8000b678 <__sfvwrite_r+0x284>
8000b630:	12 34       	cp.w	r4,r9
8000b632:	c0 a5       	brlt	8000b646 <__sfvwrite_r+0x252>
8000b634:	6e a8       	ld.w	r8,r7[0x28]
8000b636:	06 9a       	mov	r10,r3
8000b638:	6e 8b       	ld.w	r11,r7[0x20]
8000b63a:	40 1c       	lddsp	r12,sp[0x4]
8000b63c:	5d 18       	icall	r8
8000b63e:	18 95       	mov	r5,r12
8000b640:	e0 89 00 0d 	brgt	8000b65a <__sfvwrite_r+0x266>
8000b644:	c1 a8       	rjmp	8000b678 <__sfvwrite_r+0x284>
8000b646:	08 9a       	mov	r10,r4
8000b648:	06 9b       	mov	r11,r3
8000b64a:	cb 2c       	rcall	8000b7ae <memmove>
8000b64c:	6e 08       	ld.w	r8,r7[0x0]
8000b64e:	08 08       	add	r8,r4
8000b650:	08 95       	mov	r5,r4
8000b652:	8f 08       	st.w	r7[0x0],r8
8000b654:	6e 28       	ld.w	r8,r7[0x8]
8000b656:	08 18       	sub	r8,r4
8000b658:	8f 28       	st.w	r7[0x8],r8
8000b65a:	0a 16       	sub	r6,r5
8000b65c:	c0 71       	brne	8000b66a <__sfvwrite_r+0x276>
8000b65e:	0e 9b       	mov	r11,r7
8000b660:	40 1c       	lddsp	r12,sp[0x4]
8000b662:	fe b0 fc 91 	rcall	8000af84 <_fflush_r>
8000b666:	c0 91       	brne	8000b678 <__sfvwrite_r+0x284>
8000b668:	50 06       	stdsp	sp[0x0],r6
8000b66a:	64 28       	ld.w	r8,r2[0x8]
8000b66c:	0a 18       	sub	r8,r5
8000b66e:	85 28       	st.w	r2[0x8],r8
8000b670:	c0 90       	breq	8000b682 <__sfvwrite_r+0x28e>
8000b672:	0a 11       	sub	r1,r5
8000b674:	0a 03       	add	r3,r5
8000b676:	ca 4b       	rjmp	8000b5be <__sfvwrite_r+0x1ca>
8000b678:	8e 68       	ld.sh	r8,r7[0xc]
8000b67a:	a7 a8       	sbr	r8,0x6
8000b67c:	ae 68       	st.h	r7[0xc],r8
8000b67e:	3f fc       	mov	r12,-1
8000b680:	c0 28       	rjmp	8000b684 <__sfvwrite_r+0x290>
8000b682:	30 0c       	mov	r12,0
8000b684:	2f dd       	sub	sp,-12
8000b686:	d8 32       	popm	r0-r7,pc

8000b688 <_fwalk>:
8000b688:	d4 31       	pushm	r0-r7,lr
8000b68a:	30 05       	mov	r5,0
8000b68c:	16 91       	mov	r1,r11
8000b68e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b692:	0a 92       	mov	r2,r5
8000b694:	fe b0 fc fe 	rcall	8000b090 <__sfp_lock_acquire>
8000b698:	3f f3       	mov	r3,-1
8000b69a:	c1 68       	rjmp	8000b6c6 <_fwalk+0x3e>
8000b69c:	6e 26       	ld.w	r6,r7[0x8]
8000b69e:	6e 14       	ld.w	r4,r7[0x4]
8000b6a0:	2f 46       	sub	r6,-12
8000b6a2:	c0 c8       	rjmp	8000b6ba <_fwalk+0x32>
8000b6a4:	8c 08       	ld.sh	r8,r6[0x0]
8000b6a6:	e4 08 19 00 	cp.h	r8,r2
8000b6aa:	c0 70       	breq	8000b6b8 <_fwalk+0x30>
8000b6ac:	8c 18       	ld.sh	r8,r6[0x2]
8000b6ae:	e6 08 19 00 	cp.h	r8,r3
8000b6b2:	c0 30       	breq	8000b6b8 <_fwalk+0x30>
8000b6b4:	5d 11       	icall	r1
8000b6b6:	18 45       	or	r5,r12
8000b6b8:	2a 46       	sub	r6,-92
8000b6ba:	20 14       	sub	r4,1
8000b6bc:	ec cc 00 0c 	sub	r12,r6,12
8000b6c0:	58 04       	cp.w	r4,0
8000b6c2:	cf 14       	brge	8000b6a4 <_fwalk+0x1c>
8000b6c4:	6e 07       	ld.w	r7,r7[0x0]
8000b6c6:	58 07       	cp.w	r7,0
8000b6c8:	ce a1       	brne	8000b69c <_fwalk+0x14>
8000b6ca:	fe b0 fc e4 	rcall	8000b092 <__sfp_lock_release>
8000b6ce:	0a 9c       	mov	r12,r5
8000b6d0:	d8 32       	popm	r0-r7,pc
8000b6d2:	d7 03       	nop

8000b6d4 <_localeconv_r>:
8000b6d4:	fe cc d3 dc 	sub	r12,pc,-11300
8000b6d8:	5e fc       	retal	r12
8000b6da:	d7 03       	nop

8000b6dc <__smakebuf_r>:
8000b6dc:	d4 21       	pushm	r4-r7,lr
8000b6de:	20 fd       	sub	sp,60
8000b6e0:	96 68       	ld.sh	r8,r11[0xc]
8000b6e2:	16 97       	mov	r7,r11
8000b6e4:	18 96       	mov	r6,r12
8000b6e6:	e2 18 00 02 	andl	r8,0x2,COH
8000b6ea:	c3 d1       	brne	8000b764 <__smakebuf_r+0x88>
8000b6ec:	96 7b       	ld.sh	r11,r11[0xe]
8000b6ee:	f0 0b 19 00 	cp.h	r11,r8
8000b6f2:	c0 55       	brlt	8000b6fc <__smakebuf_r+0x20>
8000b6f4:	1a 9a       	mov	r10,sp
8000b6f6:	e0 a0 04 81 	rcall	8000bff8 <_fstat_r>
8000b6fa:	c0 f4       	brge	8000b718 <__smakebuf_r+0x3c>
8000b6fc:	8e 65       	ld.sh	r5,r7[0xc]
8000b6fe:	0a 98       	mov	r8,r5
8000b700:	ab b8       	sbr	r8,0xb
8000b702:	e2 15 00 80 	andl	r5,0x80,COH
8000b706:	ae 68       	st.h	r7[0xc],r8
8000b708:	30 04       	mov	r4,0
8000b70a:	e0 68 04 00 	mov	r8,1024
8000b70e:	f9 b5 01 40 	movne	r5,64
8000b712:	f0 05 17 00 	moveq	r5,r8
8000b716:	c1 c8       	rjmp	8000b74e <__smakebuf_r+0x72>
8000b718:	40 18       	lddsp	r8,sp[0x4]
8000b71a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b71e:	e0 48 20 00 	cp.w	r8,8192
8000b722:	5f 04       	sreq	r4
8000b724:	e0 48 80 00 	cp.w	r8,32768
8000b728:	c0 e1       	brne	8000b744 <__smakebuf_r+0x68>
8000b72a:	6e b9       	ld.w	r9,r7[0x2c]
8000b72c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b730:	10 39       	cp.w	r9,r8
8000b732:	c0 91       	brne	8000b744 <__smakebuf_r+0x68>
8000b734:	8e 68       	ld.sh	r8,r7[0xc]
8000b736:	e0 65 04 00 	mov	r5,1024
8000b73a:	ab a8       	sbr	r8,0xa
8000b73c:	ef 45 00 50 	st.w	r7[80],r5
8000b740:	ae 68       	st.h	r7[0xc],r8
8000b742:	c0 68       	rjmp	8000b74e <__smakebuf_r+0x72>
8000b744:	8e 68       	ld.sh	r8,r7[0xc]
8000b746:	e0 65 04 00 	mov	r5,1024
8000b74a:	ab b8       	sbr	r8,0xb
8000b74c:	ae 68       	st.h	r7[0xc],r8
8000b74e:	0a 9b       	mov	r11,r5
8000b750:	0c 9c       	mov	r12,r6
8000b752:	fe b0 df 23 	rcall	80007598 <_malloc_r>
8000b756:	8e 68       	ld.sh	r8,r7[0xc]
8000b758:	c0 d1       	brne	8000b772 <__smakebuf_r+0x96>
8000b75a:	ed b8 00 09 	bld	r8,0x9
8000b75e:	c1 b0       	breq	8000b794 <__smakebuf_r+0xb8>
8000b760:	a1 b8       	sbr	r8,0x1
8000b762:	ae 68       	st.h	r7[0xc],r8
8000b764:	ee c8 ff b9 	sub	r8,r7,-71
8000b768:	8f 48       	st.w	r7[0x10],r8
8000b76a:	8f 08       	st.w	r7[0x0],r8
8000b76c:	30 18       	mov	r8,1
8000b76e:	8f 58       	st.w	r7[0x14],r8
8000b770:	c1 28       	rjmp	8000b794 <__smakebuf_r+0xb8>
8000b772:	a7 b8       	sbr	r8,0x7
8000b774:	8f 4c       	st.w	r7[0x10],r12
8000b776:	ae 68       	st.h	r7[0xc],r8
8000b778:	8f 55       	st.w	r7[0x14],r5
8000b77a:	fe c8 06 e6 	sub	r8,pc,1766
8000b77e:	8f 0c       	st.w	r7[0x0],r12
8000b780:	8d a8       	st.w	r6[0x28],r8
8000b782:	58 04       	cp.w	r4,0
8000b784:	c0 80       	breq	8000b794 <__smakebuf_r+0xb8>
8000b786:	8e 7c       	ld.sh	r12,r7[0xe]
8000b788:	fe b0 e3 94 	rcall	80007eb0 <isatty>
8000b78c:	c0 40       	breq	8000b794 <__smakebuf_r+0xb8>
8000b78e:	8e 68       	ld.sh	r8,r7[0xc]
8000b790:	a1 a8       	sbr	r8,0x0
8000b792:	ae 68       	st.h	r7[0xc],r8
8000b794:	2f 1d       	sub	sp,-60
8000b796:	d8 22       	popm	r4-r7,pc

8000b798 <memchr>:
8000b798:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b79c:	c0 68       	rjmp	8000b7a8 <memchr+0x10>
8000b79e:	20 1a       	sub	r10,1
8000b7a0:	19 88       	ld.ub	r8,r12[0x0]
8000b7a2:	16 38       	cp.w	r8,r11
8000b7a4:	5e 0c       	reteq	r12
8000b7a6:	2f fc       	sub	r12,-1
8000b7a8:	58 0a       	cp.w	r10,0
8000b7aa:	cf a1       	brne	8000b79e <memchr+0x6>
8000b7ac:	5e fa       	retal	r10

8000b7ae <memmove>:
8000b7ae:	d4 01       	pushm	lr
8000b7b0:	18 3b       	cp.w	r11,r12
8000b7b2:	c1 92       	brcc	8000b7e4 <memmove+0x36>
8000b7b4:	f6 0a 00 09 	add	r9,r11,r10
8000b7b8:	12 3c       	cp.w	r12,r9
8000b7ba:	c1 52       	brcc	8000b7e4 <memmove+0x36>
8000b7bc:	f8 0a 00 0b 	add	r11,r12,r10
8000b7c0:	30 08       	mov	r8,0
8000b7c2:	c0 68       	rjmp	8000b7ce <memmove+0x20>
8000b7c4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b7c8:	20 1a       	sub	r10,1
8000b7ca:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b7ce:	20 18       	sub	r8,1
8000b7d0:	58 0a       	cp.w	r10,0
8000b7d2:	cf 91       	brne	8000b7c4 <memmove+0x16>
8000b7d4:	d8 02       	popm	pc
8000b7d6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b7da:	20 1a       	sub	r10,1
8000b7dc:	f8 08 0b 09 	st.b	r12[r8],r9
8000b7e0:	2f f8       	sub	r8,-1
8000b7e2:	c0 28       	rjmp	8000b7e6 <memmove+0x38>
8000b7e4:	30 08       	mov	r8,0
8000b7e6:	58 0a       	cp.w	r10,0
8000b7e8:	cf 71       	brne	8000b7d6 <memmove+0x28>
8000b7ea:	d8 02       	popm	pc

8000b7ec <__hi0bits>:
8000b7ec:	18 98       	mov	r8,r12
8000b7ee:	e0 1c 00 00 	andl	r12,0x0
8000b7f2:	f0 09 15 10 	lsl	r9,r8,0x10
8000b7f6:	58 0c       	cp.w	r12,0
8000b7f8:	f2 08 17 00 	moveq	r8,r9
8000b7fc:	f9 bc 00 10 	moveq	r12,16
8000b800:	f9 bc 01 00 	movne	r12,0
8000b804:	10 9a       	mov	r10,r8
8000b806:	f0 09 15 08 	lsl	r9,r8,0x8
8000b80a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b80e:	f7 bc 00 f8 	subeq	r12,-8
8000b812:	f2 08 17 00 	moveq	r8,r9
8000b816:	10 9a       	mov	r10,r8
8000b818:	f0 09 15 04 	lsl	r9,r8,0x4
8000b81c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b820:	f7 bc 00 fc 	subeq	r12,-4
8000b824:	f2 08 17 00 	moveq	r8,r9
8000b828:	10 9a       	mov	r10,r8
8000b82a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b82e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b832:	f7 bc 00 fe 	subeq	r12,-2
8000b836:	f2 08 17 00 	moveq	r8,r9
8000b83a:	58 08       	cp.w	r8,0
8000b83c:	5e 5c       	retlt	r12
8000b83e:	ed b8 00 1e 	bld	r8,0x1e
8000b842:	f9 bc 01 20 	movne	r12,32
8000b846:	f7 bc 00 ff 	subeq	r12,-1
8000b84a:	5e fc       	retal	r12

8000b84c <__lo0bits>:
8000b84c:	18 99       	mov	r9,r12
8000b84e:	78 08       	ld.w	r8,r12[0x0]
8000b850:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b854:	c1 50       	breq	8000b87e <__lo0bits+0x32>
8000b856:	ed b8 00 00 	bld	r8,0x0
8000b85a:	c0 21       	brne	8000b85e <__lo0bits+0x12>
8000b85c:	5e fd       	retal	0
8000b85e:	10 9b       	mov	r11,r8
8000b860:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b864:	e2 1b 00 02 	andl	r11,0x2,COH
8000b868:	a3 88       	lsr	r8,0x2
8000b86a:	58 0b       	cp.w	r11,0
8000b86c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b870:	f9 bc 01 01 	movne	r12,1
8000b874:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b878:	f9 bc 00 02 	moveq	r12,2
8000b87c:	5e fc       	retal	r12
8000b87e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b882:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b886:	58 0a       	cp.w	r10,0
8000b888:	f6 08 17 00 	moveq	r8,r11
8000b88c:	f9 bc 00 10 	moveq	r12,16
8000b890:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b894:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b898:	58 0b       	cp.w	r11,0
8000b89a:	f7 bc 00 f8 	subeq	r12,-8
8000b89e:	f4 08 17 00 	moveq	r8,r10
8000b8a2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b8a6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b8aa:	58 0b       	cp.w	r11,0
8000b8ac:	f7 bc 00 fc 	subeq	r12,-4
8000b8b0:	f4 08 17 00 	moveq	r8,r10
8000b8b4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b8b8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b8bc:	58 0b       	cp.w	r11,0
8000b8be:	f7 bc 00 fe 	subeq	r12,-2
8000b8c2:	f4 08 17 00 	moveq	r8,r10
8000b8c6:	ed b8 00 00 	bld	r8,0x0
8000b8ca:	c0 60       	breq	8000b8d6 <__lo0bits+0x8a>
8000b8cc:	a1 98       	lsr	r8,0x1
8000b8ce:	c0 31       	brne	8000b8d4 <__lo0bits+0x88>
8000b8d0:	32 0c       	mov	r12,32
8000b8d2:	5e fc       	retal	r12
8000b8d4:	2f fc       	sub	r12,-1
8000b8d6:	93 08       	st.w	r9[0x0],r8
8000b8d8:	5e fc       	retal	r12

8000b8da <__mcmp>:
8000b8da:	d4 01       	pushm	lr
8000b8dc:	18 98       	mov	r8,r12
8000b8de:	76 49       	ld.w	r9,r11[0x10]
8000b8e0:	78 4c       	ld.w	r12,r12[0x10]
8000b8e2:	12 1c       	sub	r12,r9
8000b8e4:	c1 31       	brne	8000b90a <__mcmp+0x30>
8000b8e6:	2f b9       	sub	r9,-5
8000b8e8:	a3 69       	lsl	r9,0x2
8000b8ea:	12 0b       	add	r11,r9
8000b8ec:	f0 09 00 09 	add	r9,r8,r9
8000b8f0:	2e c8       	sub	r8,-20
8000b8f2:	13 4e       	ld.w	lr,--r9
8000b8f4:	17 4a       	ld.w	r10,--r11
8000b8f6:	14 3e       	cp.w	lr,r10
8000b8f8:	c0 60       	breq	8000b904 <__mcmp+0x2a>
8000b8fa:	f9 bc 03 ff 	movlo	r12,-1
8000b8fe:	f9 bc 02 01 	movhs	r12,1
8000b902:	d8 02       	popm	pc
8000b904:	10 39       	cp.w	r9,r8
8000b906:	fe 9b ff f6 	brhi	8000b8f2 <__mcmp+0x18>
8000b90a:	d8 02       	popm	pc

8000b90c <_Bfree>:
8000b90c:	d4 21       	pushm	r4-r7,lr
8000b90e:	18 97       	mov	r7,r12
8000b910:	16 95       	mov	r5,r11
8000b912:	78 96       	ld.w	r6,r12[0x24]
8000b914:	58 06       	cp.w	r6,0
8000b916:	c0 91       	brne	8000b928 <_Bfree+0x1c>
8000b918:	31 0c       	mov	r12,16
8000b91a:	fe b0 de 37 	rcall	80007588 <malloc>
8000b91e:	99 36       	st.w	r12[0xc],r6
8000b920:	8f 9c       	st.w	r7[0x24],r12
8000b922:	99 16       	st.w	r12[0x4],r6
8000b924:	99 26       	st.w	r12[0x8],r6
8000b926:	99 06       	st.w	r12[0x0],r6
8000b928:	58 05       	cp.w	r5,0
8000b92a:	c0 90       	breq	8000b93c <_Bfree+0x30>
8000b92c:	6a 19       	ld.w	r9,r5[0x4]
8000b92e:	6e 98       	ld.w	r8,r7[0x24]
8000b930:	70 38       	ld.w	r8,r8[0xc]
8000b932:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b936:	8b 0a       	st.w	r5[0x0],r10
8000b938:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b93c:	d8 22       	popm	r4-r7,pc
8000b93e:	d7 03       	nop

8000b940 <_Balloc>:
8000b940:	d4 21       	pushm	r4-r7,lr
8000b942:	18 97       	mov	r7,r12
8000b944:	16 96       	mov	r6,r11
8000b946:	78 95       	ld.w	r5,r12[0x24]
8000b948:	58 05       	cp.w	r5,0
8000b94a:	c0 91       	brne	8000b95c <_Balloc+0x1c>
8000b94c:	31 0c       	mov	r12,16
8000b94e:	fe b0 de 1d 	rcall	80007588 <malloc>
8000b952:	99 35       	st.w	r12[0xc],r5
8000b954:	8f 9c       	st.w	r7[0x24],r12
8000b956:	99 15       	st.w	r12[0x4],r5
8000b958:	99 25       	st.w	r12[0x8],r5
8000b95a:	99 05       	st.w	r12[0x0],r5
8000b95c:	6e 95       	ld.w	r5,r7[0x24]
8000b95e:	6a 38       	ld.w	r8,r5[0xc]
8000b960:	58 08       	cp.w	r8,0
8000b962:	c0 b1       	brne	8000b978 <_Balloc+0x38>
8000b964:	31 0a       	mov	r10,16
8000b966:	30 4b       	mov	r11,4
8000b968:	0e 9c       	mov	r12,r7
8000b96a:	e0 a0 02 a7 	rcall	8000beb8 <_calloc_r>
8000b96e:	8b 3c       	st.w	r5[0xc],r12
8000b970:	6e 98       	ld.w	r8,r7[0x24]
8000b972:	70 3c       	ld.w	r12,r8[0xc]
8000b974:	58 0c       	cp.w	r12,0
8000b976:	c1 b0       	breq	8000b9ac <_Balloc+0x6c>
8000b978:	6e 98       	ld.w	r8,r7[0x24]
8000b97a:	70 38       	ld.w	r8,r8[0xc]
8000b97c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b980:	70 0c       	ld.w	r12,r8[0x0]
8000b982:	58 0c       	cp.w	r12,0
8000b984:	c0 40       	breq	8000b98c <_Balloc+0x4c>
8000b986:	78 09       	ld.w	r9,r12[0x0]
8000b988:	91 09       	st.w	r8[0x0],r9
8000b98a:	c0 e8       	rjmp	8000b9a6 <_Balloc+0x66>
8000b98c:	0e 9c       	mov	r12,r7
8000b98e:	30 17       	mov	r7,1
8000b990:	0e 9b       	mov	r11,r7
8000b992:	ee 06 09 47 	lsl	r7,r7,r6
8000b996:	ee ca ff fb 	sub	r10,r7,-5
8000b99a:	a3 6a       	lsl	r10,0x2
8000b99c:	e0 a0 02 8e 	rcall	8000beb8 <_calloc_r>
8000b9a0:	c0 60       	breq	8000b9ac <_Balloc+0x6c>
8000b9a2:	99 16       	st.w	r12[0x4],r6
8000b9a4:	99 27       	st.w	r12[0x8],r7
8000b9a6:	30 08       	mov	r8,0
8000b9a8:	99 38       	st.w	r12[0xc],r8
8000b9aa:	99 48       	st.w	r12[0x10],r8
8000b9ac:	d8 22       	popm	r4-r7,pc
8000b9ae:	d7 03       	nop

8000b9b0 <__d2b>:
8000b9b0:	d4 31       	pushm	r0-r7,lr
8000b9b2:	20 2d       	sub	sp,8
8000b9b4:	16 93       	mov	r3,r11
8000b9b6:	12 96       	mov	r6,r9
8000b9b8:	10 95       	mov	r5,r8
8000b9ba:	14 92       	mov	r2,r10
8000b9bc:	30 1b       	mov	r11,1
8000b9be:	cc 1f       	rcall	8000b940 <_Balloc>
8000b9c0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b9c4:	50 09       	stdsp	sp[0x0],r9
8000b9c6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b9ca:	b5 a9       	sbr	r9,0x14
8000b9cc:	f0 01 16 14 	lsr	r1,r8,0x14
8000b9d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b9d4:	18 94       	mov	r4,r12
8000b9d6:	58 02       	cp.w	r2,0
8000b9d8:	c1 d0       	breq	8000ba12 <__d2b+0x62>
8000b9da:	fa cc ff f8 	sub	r12,sp,-8
8000b9de:	18 d2       	st.w	--r12,r2
8000b9e0:	c3 6f       	rcall	8000b84c <__lo0bits>
8000b9e2:	40 18       	lddsp	r8,sp[0x4]
8000b9e4:	c0 d0       	breq	8000b9fe <__d2b+0x4e>
8000b9e6:	40 09       	lddsp	r9,sp[0x0]
8000b9e8:	f8 0a 11 20 	rsub	r10,r12,32
8000b9ec:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b9f0:	f5 e8 10 08 	or	r8,r10,r8
8000b9f4:	89 58       	st.w	r4[0x14],r8
8000b9f6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b9fa:	50 09       	stdsp	sp[0x0],r9
8000b9fc:	c0 28       	rjmp	8000ba00 <__d2b+0x50>
8000b9fe:	89 58       	st.w	r4[0x14],r8
8000ba00:	40 08       	lddsp	r8,sp[0x0]
8000ba02:	58 08       	cp.w	r8,0
8000ba04:	f9 b3 01 02 	movne	r3,2
8000ba08:	f9 b3 00 01 	moveq	r3,1
8000ba0c:	89 68       	st.w	r4[0x18],r8
8000ba0e:	89 43       	st.w	r4[0x10],r3
8000ba10:	c0 88       	rjmp	8000ba20 <__d2b+0x70>
8000ba12:	1a 9c       	mov	r12,sp
8000ba14:	c1 cf       	rcall	8000b84c <__lo0bits>
8000ba16:	30 13       	mov	r3,1
8000ba18:	40 08       	lddsp	r8,sp[0x0]
8000ba1a:	2e 0c       	sub	r12,-32
8000ba1c:	89 43       	st.w	r4[0x10],r3
8000ba1e:	89 58       	st.w	r4[0x14],r8
8000ba20:	58 01       	cp.w	r1,0
8000ba22:	c0 90       	breq	8000ba34 <__d2b+0x84>
8000ba24:	e2 c1 04 33 	sub	r1,r1,1075
8000ba28:	18 01       	add	r1,r12
8000ba2a:	8d 01       	st.w	r6[0x0],r1
8000ba2c:	f8 0c 11 35 	rsub	r12,r12,53
8000ba30:	8b 0c       	st.w	r5[0x0],r12
8000ba32:	c0 c8       	rjmp	8000ba4a <__d2b+0x9a>
8000ba34:	e6 c8 ff fc 	sub	r8,r3,-4
8000ba38:	f8 cc 04 32 	sub	r12,r12,1074
8000ba3c:	a5 73       	lsl	r3,0x5
8000ba3e:	8d 0c       	st.w	r6[0x0],r12
8000ba40:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ba44:	cd 4e       	rcall	8000b7ec <__hi0bits>
8000ba46:	18 13       	sub	r3,r12
8000ba48:	8b 03       	st.w	r5[0x0],r3
8000ba4a:	08 9c       	mov	r12,r4
8000ba4c:	2f ed       	sub	sp,-8
8000ba4e:	d8 32       	popm	r0-r7,pc

8000ba50 <__mdiff>:
8000ba50:	d4 31       	pushm	r0-r7,lr
8000ba52:	74 48       	ld.w	r8,r10[0x10]
8000ba54:	76 45       	ld.w	r5,r11[0x10]
8000ba56:	16 97       	mov	r7,r11
8000ba58:	14 96       	mov	r6,r10
8000ba5a:	10 15       	sub	r5,r8
8000ba5c:	c1 31       	brne	8000ba82 <__mdiff+0x32>
8000ba5e:	2f b8       	sub	r8,-5
8000ba60:	ee ce ff ec 	sub	lr,r7,-20
8000ba64:	a3 68       	lsl	r8,0x2
8000ba66:	f4 08 00 0b 	add	r11,r10,r8
8000ba6a:	ee 08 00 08 	add	r8,r7,r8
8000ba6e:	11 4a       	ld.w	r10,--r8
8000ba70:	17 49       	ld.w	r9,--r11
8000ba72:	12 3a       	cp.w	r10,r9
8000ba74:	c0 30       	breq	8000ba7a <__mdiff+0x2a>
8000ba76:	c0 e2       	brcc	8000ba92 <__mdiff+0x42>
8000ba78:	c0 78       	rjmp	8000ba86 <__mdiff+0x36>
8000ba7a:	1c 38       	cp.w	r8,lr
8000ba7c:	fe 9b ff f9 	brhi	8000ba6e <__mdiff+0x1e>
8000ba80:	c4 98       	rjmp	8000bb12 <__mdiff+0xc2>
8000ba82:	58 05       	cp.w	r5,0
8000ba84:	c0 64       	brge	8000ba90 <__mdiff+0x40>
8000ba86:	0e 98       	mov	r8,r7
8000ba88:	30 15       	mov	r5,1
8000ba8a:	0c 97       	mov	r7,r6
8000ba8c:	10 96       	mov	r6,r8
8000ba8e:	c0 28       	rjmp	8000ba92 <__mdiff+0x42>
8000ba90:	30 05       	mov	r5,0
8000ba92:	6e 1b       	ld.w	r11,r7[0x4]
8000ba94:	c5 6f       	rcall	8000b940 <_Balloc>
8000ba96:	6e 49       	ld.w	r9,r7[0x10]
8000ba98:	6c 44       	ld.w	r4,r6[0x10]
8000ba9a:	99 35       	st.w	r12[0xc],r5
8000ba9c:	2f b4       	sub	r4,-5
8000ba9e:	f2 c5 ff fb 	sub	r5,r9,-5
8000baa2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000baa6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000baaa:	2e c6       	sub	r6,-20
8000baac:	2e c7       	sub	r7,-20
8000baae:	f8 c8 ff ec 	sub	r8,r12,-20
8000bab2:	30 0a       	mov	r10,0
8000bab4:	0f 0e       	ld.w	lr,r7++
8000bab6:	0d 0b       	ld.w	r11,r6++
8000bab8:	fc 02 16 10 	lsr	r2,lr,0x10
8000babc:	f6 03 16 10 	lsr	r3,r11,0x10
8000bac0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bac4:	e4 03 01 03 	sub	r3,r2,r3
8000bac8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bacc:	fc 0b 01 0b 	sub	r11,lr,r11
8000bad0:	f6 0a 00 0a 	add	r10,r11,r10
8000bad4:	b0 1a       	st.h	r8[0x2],r10
8000bad6:	b1 4a       	asr	r10,0x10
8000bad8:	e6 0a 00 0a 	add	r10,r3,r10
8000badc:	b0 0a       	st.h	r8[0x0],r10
8000bade:	2f c8       	sub	r8,-4
8000bae0:	b1 4a       	asr	r10,0x10
8000bae2:	08 36       	cp.w	r6,r4
8000bae4:	ce 83       	brcs	8000bab4 <__mdiff+0x64>
8000bae6:	c0 d8       	rjmp	8000bb00 <__mdiff+0xb0>
8000bae8:	0f 0b       	ld.w	r11,r7++
8000baea:	f6 0e 16 10 	lsr	lr,r11,0x10
8000baee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000baf2:	16 0a       	add	r10,r11
8000baf4:	b0 1a       	st.h	r8[0x2],r10
8000baf6:	b1 4a       	asr	r10,0x10
8000baf8:	1c 0a       	add	r10,lr
8000bafa:	b0 0a       	st.h	r8[0x0],r10
8000bafc:	2f c8       	sub	r8,-4
8000bafe:	b1 4a       	asr	r10,0x10
8000bb00:	0a 37       	cp.w	r7,r5
8000bb02:	cf 33       	brcs	8000bae8 <__mdiff+0x98>
8000bb04:	c0 28       	rjmp	8000bb08 <__mdiff+0xb8>
8000bb06:	20 19       	sub	r9,1
8000bb08:	11 4a       	ld.w	r10,--r8
8000bb0a:	58 0a       	cp.w	r10,0
8000bb0c:	cf d0       	breq	8000bb06 <__mdiff+0xb6>
8000bb0e:	99 49       	st.w	r12[0x10],r9
8000bb10:	d8 32       	popm	r0-r7,pc
8000bb12:	30 0b       	mov	r11,0
8000bb14:	c1 6f       	rcall	8000b940 <_Balloc>
8000bb16:	30 18       	mov	r8,1
8000bb18:	99 48       	st.w	r12[0x10],r8
8000bb1a:	30 08       	mov	r8,0
8000bb1c:	99 58       	st.w	r12[0x14],r8
8000bb1e:	d8 32       	popm	r0-r7,pc

8000bb20 <__lshift>:
8000bb20:	d4 31       	pushm	r0-r7,lr
8000bb22:	16 97       	mov	r7,r11
8000bb24:	76 46       	ld.w	r6,r11[0x10]
8000bb26:	f4 02 14 05 	asr	r2,r10,0x5
8000bb2a:	2f f6       	sub	r6,-1
8000bb2c:	14 93       	mov	r3,r10
8000bb2e:	18 94       	mov	r4,r12
8000bb30:	04 06       	add	r6,r2
8000bb32:	76 1b       	ld.w	r11,r11[0x4]
8000bb34:	6e 28       	ld.w	r8,r7[0x8]
8000bb36:	c0 38       	rjmp	8000bb3c <__lshift+0x1c>
8000bb38:	2f fb       	sub	r11,-1
8000bb3a:	a1 78       	lsl	r8,0x1
8000bb3c:	10 36       	cp.w	r6,r8
8000bb3e:	fe 99 ff fd 	brgt	8000bb38 <__lshift+0x18>
8000bb42:	08 9c       	mov	r12,r4
8000bb44:	cf ee       	rcall	8000b940 <_Balloc>
8000bb46:	30 09       	mov	r9,0
8000bb48:	18 95       	mov	r5,r12
8000bb4a:	f8 c8 ff ec 	sub	r8,r12,-20
8000bb4e:	12 9a       	mov	r10,r9
8000bb50:	c0 38       	rjmp	8000bb56 <__lshift+0x36>
8000bb52:	10 aa       	st.w	r8++,r10
8000bb54:	2f f9       	sub	r9,-1
8000bb56:	04 39       	cp.w	r9,r2
8000bb58:	cf d5       	brlt	8000bb52 <__lshift+0x32>
8000bb5a:	6e 4b       	ld.w	r11,r7[0x10]
8000bb5c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000bb60:	2f bb       	sub	r11,-5
8000bb62:	ee c9 ff ec 	sub	r9,r7,-20
8000bb66:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000bb6a:	58 03       	cp.w	r3,0
8000bb6c:	c1 30       	breq	8000bb92 <__lshift+0x72>
8000bb6e:	e6 0c 11 20 	rsub	r12,r3,32
8000bb72:	30 0a       	mov	r10,0
8000bb74:	72 02       	ld.w	r2,r9[0x0]
8000bb76:	e4 03 09 42 	lsl	r2,r2,r3
8000bb7a:	04 4a       	or	r10,r2
8000bb7c:	10 aa       	st.w	r8++,r10
8000bb7e:	13 0a       	ld.w	r10,r9++
8000bb80:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb84:	16 39       	cp.w	r9,r11
8000bb86:	cf 73       	brcs	8000bb74 <__lshift+0x54>
8000bb88:	91 0a       	st.w	r8[0x0],r10
8000bb8a:	58 0a       	cp.w	r10,0
8000bb8c:	c0 70       	breq	8000bb9a <__lshift+0x7a>
8000bb8e:	2f f6       	sub	r6,-1
8000bb90:	c0 58       	rjmp	8000bb9a <__lshift+0x7a>
8000bb92:	13 0a       	ld.w	r10,r9++
8000bb94:	10 aa       	st.w	r8++,r10
8000bb96:	16 39       	cp.w	r9,r11
8000bb98:	cf d3       	brcs	8000bb92 <__lshift+0x72>
8000bb9a:	08 9c       	mov	r12,r4
8000bb9c:	20 16       	sub	r6,1
8000bb9e:	0e 9b       	mov	r11,r7
8000bba0:	8b 46       	st.w	r5[0x10],r6
8000bba2:	cb 5e       	rcall	8000b90c <_Bfree>
8000bba4:	0a 9c       	mov	r12,r5
8000bba6:	d8 32       	popm	r0-r7,pc

8000bba8 <__multiply>:
8000bba8:	d4 31       	pushm	r0-r7,lr
8000bbaa:	20 2d       	sub	sp,8
8000bbac:	76 49       	ld.w	r9,r11[0x10]
8000bbae:	74 48       	ld.w	r8,r10[0x10]
8000bbb0:	16 96       	mov	r6,r11
8000bbb2:	14 95       	mov	r5,r10
8000bbb4:	10 39       	cp.w	r9,r8
8000bbb6:	ec 08 17 50 	movlt	r8,r6
8000bbba:	ea 06 17 50 	movlt	r6,r5
8000bbbe:	f0 05 17 50 	movlt	r5,r8
8000bbc2:	6c 28       	ld.w	r8,r6[0x8]
8000bbc4:	76 43       	ld.w	r3,r11[0x10]
8000bbc6:	74 42       	ld.w	r2,r10[0x10]
8000bbc8:	76 1b       	ld.w	r11,r11[0x4]
8000bbca:	e4 03 00 07 	add	r7,r2,r3
8000bbce:	10 37       	cp.w	r7,r8
8000bbd0:	f7 bb 09 ff 	subgt	r11,-1
8000bbd4:	cb 6e       	rcall	8000b940 <_Balloc>
8000bbd6:	ee c4 ff fb 	sub	r4,r7,-5
8000bbda:	f8 c9 ff ec 	sub	r9,r12,-20
8000bbde:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bbe2:	30 0a       	mov	r10,0
8000bbe4:	12 98       	mov	r8,r9
8000bbe6:	c0 28       	rjmp	8000bbea <__multiply+0x42>
8000bbe8:	10 aa       	st.w	r8++,r10
8000bbea:	08 38       	cp.w	r8,r4
8000bbec:	cf e3       	brcs	8000bbe8 <__multiply+0x40>
8000bbee:	2f b3       	sub	r3,-5
8000bbf0:	2f b2       	sub	r2,-5
8000bbf2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bbf6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bbfa:	ec cb ff ec 	sub	r11,r6,-20
8000bbfe:	50 12       	stdsp	sp[0x4],r2
8000bc00:	ea ca ff ec 	sub	r10,r5,-20
8000bc04:	c4 48       	rjmp	8000bc8c <__multiply+0xe4>
8000bc06:	94 95       	ld.uh	r5,r10[0x2]
8000bc08:	58 05       	cp.w	r5,0
8000bc0a:	c2 00       	breq	8000bc4a <__multiply+0xa2>
8000bc0c:	12 98       	mov	r8,r9
8000bc0e:	16 96       	mov	r6,r11
8000bc10:	30 0e       	mov	lr,0
8000bc12:	50 09       	stdsp	sp[0x0],r9
8000bc14:	0d 02       	ld.w	r2,r6++
8000bc16:	e4 00 16 10 	lsr	r0,r2,0x10
8000bc1a:	70 01       	ld.w	r1,r8[0x0]
8000bc1c:	70 09       	ld.w	r9,r8[0x0]
8000bc1e:	b1 81       	lsr	r1,0x10
8000bc20:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bc24:	e0 05 03 41 	mac	r1,r0,r5
8000bc28:	ab 32       	mul	r2,r5
8000bc2a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bc2e:	00 02       	add	r2,r0
8000bc30:	e4 0e 00 0e 	add	lr,r2,lr
8000bc34:	b0 1e       	st.h	r8[0x2],lr
8000bc36:	b1 8e       	lsr	lr,0x10
8000bc38:	1c 01       	add	r1,lr
8000bc3a:	b0 01       	st.h	r8[0x0],r1
8000bc3c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bc40:	2f c8       	sub	r8,-4
8000bc42:	06 36       	cp.w	r6,r3
8000bc44:	ce 83       	brcs	8000bc14 <__multiply+0x6c>
8000bc46:	40 09       	lddsp	r9,sp[0x0]
8000bc48:	91 0e       	st.w	r8[0x0],lr
8000bc4a:	94 86       	ld.uh	r6,r10[0x0]
8000bc4c:	58 06       	cp.w	r6,0
8000bc4e:	c1 d0       	breq	8000bc88 <__multiply+0xe0>
8000bc50:	72 02       	ld.w	r2,r9[0x0]
8000bc52:	12 98       	mov	r8,r9
8000bc54:	16 9e       	mov	lr,r11
8000bc56:	30 05       	mov	r5,0
8000bc58:	b0 12       	st.h	r8[0x2],r2
8000bc5a:	1d 01       	ld.w	r1,lr++
8000bc5c:	90 82       	ld.uh	r2,r8[0x0]
8000bc5e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bc62:	ad 30       	mul	r0,r6
8000bc64:	e0 02 00 02 	add	r2,r0,r2
8000bc68:	e4 05 00 05 	add	r5,r2,r5
8000bc6c:	b0 05       	st.h	r8[0x0],r5
8000bc6e:	b1 85       	lsr	r5,0x10
8000bc70:	b1 81       	lsr	r1,0x10
8000bc72:	2f c8       	sub	r8,-4
8000bc74:	ad 31       	mul	r1,r6
8000bc76:	90 92       	ld.uh	r2,r8[0x2]
8000bc78:	e2 02 00 02 	add	r2,r1,r2
8000bc7c:	0a 02       	add	r2,r5
8000bc7e:	e4 05 16 10 	lsr	r5,r2,0x10
8000bc82:	06 3e       	cp.w	lr,r3
8000bc84:	ce a3       	brcs	8000bc58 <__multiply+0xb0>
8000bc86:	91 02       	st.w	r8[0x0],r2
8000bc88:	2f ca       	sub	r10,-4
8000bc8a:	2f c9       	sub	r9,-4
8000bc8c:	40 18       	lddsp	r8,sp[0x4]
8000bc8e:	10 3a       	cp.w	r10,r8
8000bc90:	cb b3       	brcs	8000bc06 <__multiply+0x5e>
8000bc92:	c0 28       	rjmp	8000bc96 <__multiply+0xee>
8000bc94:	20 17       	sub	r7,1
8000bc96:	58 07       	cp.w	r7,0
8000bc98:	e0 8a 00 05 	brle	8000bca2 <__multiply+0xfa>
8000bc9c:	09 48       	ld.w	r8,--r4
8000bc9e:	58 08       	cp.w	r8,0
8000bca0:	cf a0       	breq	8000bc94 <__multiply+0xec>
8000bca2:	99 47       	st.w	r12[0x10],r7
8000bca4:	2f ed       	sub	sp,-8
8000bca6:	d8 32       	popm	r0-r7,pc

8000bca8 <__i2b>:
8000bca8:	d4 21       	pushm	r4-r7,lr
8000bcaa:	16 97       	mov	r7,r11
8000bcac:	30 1b       	mov	r11,1
8000bcae:	c4 9e       	rcall	8000b940 <_Balloc>
8000bcb0:	30 19       	mov	r9,1
8000bcb2:	99 57       	st.w	r12[0x14],r7
8000bcb4:	99 49       	st.w	r12[0x10],r9
8000bcb6:	d8 22       	popm	r4-r7,pc

8000bcb8 <__multadd>:
8000bcb8:	d4 31       	pushm	r0-r7,lr
8000bcba:	30 08       	mov	r8,0
8000bcbc:	12 95       	mov	r5,r9
8000bcbe:	16 97       	mov	r7,r11
8000bcc0:	18 96       	mov	r6,r12
8000bcc2:	76 44       	ld.w	r4,r11[0x10]
8000bcc4:	f6 c9 ff ec 	sub	r9,r11,-20
8000bcc8:	72 0b       	ld.w	r11,r9[0x0]
8000bcca:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bcce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bcd2:	f4 0c 02 4c 	mul	r12,r10,r12
8000bcd6:	f4 0b 03 45 	mac	r5,r10,r11
8000bcda:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bcde:	b1 85       	lsr	r5,0x10
8000bce0:	18 05       	add	r5,r12
8000bce2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bce6:	f8 0b 00 0b 	add	r11,r12,r11
8000bcea:	12 ab       	st.w	r9++,r11
8000bcec:	2f f8       	sub	r8,-1
8000bcee:	b1 85       	lsr	r5,0x10
8000bcf0:	08 38       	cp.w	r8,r4
8000bcf2:	ce b5       	brlt	8000bcc8 <__multadd+0x10>
8000bcf4:	58 05       	cp.w	r5,0
8000bcf6:	c1 c0       	breq	8000bd2e <__multadd+0x76>
8000bcf8:	6e 28       	ld.w	r8,r7[0x8]
8000bcfa:	10 34       	cp.w	r4,r8
8000bcfc:	c1 35       	brlt	8000bd22 <__multadd+0x6a>
8000bcfe:	6e 1b       	ld.w	r11,r7[0x4]
8000bd00:	0c 9c       	mov	r12,r6
8000bd02:	2f fb       	sub	r11,-1
8000bd04:	c1 ee       	rcall	8000b940 <_Balloc>
8000bd06:	6e 4a       	ld.w	r10,r7[0x10]
8000bd08:	ee cb ff f4 	sub	r11,r7,-12
8000bd0c:	18 93       	mov	r3,r12
8000bd0e:	2f ea       	sub	r10,-2
8000bd10:	2f 4c       	sub	r12,-12
8000bd12:	a3 6a       	lsl	r10,0x2
8000bd14:	fe b0 de 71 	rcall	800079f6 <memcpy>
8000bd18:	0e 9b       	mov	r11,r7
8000bd1a:	0c 9c       	mov	r12,r6
8000bd1c:	fe b0 fd f8 	rcall	8000b90c <_Bfree>
8000bd20:	06 97       	mov	r7,r3
8000bd22:	e8 c8 ff ff 	sub	r8,r4,-1
8000bd26:	2f b4       	sub	r4,-5
8000bd28:	8f 48       	st.w	r7[0x10],r8
8000bd2a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bd2e:	0e 9c       	mov	r12,r7
8000bd30:	d8 32       	popm	r0-r7,pc
8000bd32:	d7 03       	nop

8000bd34 <__pow5mult>:
8000bd34:	d4 31       	pushm	r0-r7,lr
8000bd36:	14 96       	mov	r6,r10
8000bd38:	18 97       	mov	r7,r12
8000bd3a:	16 94       	mov	r4,r11
8000bd3c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bd40:	c0 90       	breq	8000bd52 <__pow5mult+0x1e>
8000bd42:	20 18       	sub	r8,1
8000bd44:	fe c9 da 10 	sub	r9,pc,-9712
8000bd48:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bd4c:	30 09       	mov	r9,0
8000bd4e:	cb 5f       	rcall	8000bcb8 <__multadd>
8000bd50:	18 94       	mov	r4,r12
8000bd52:	a3 46       	asr	r6,0x2
8000bd54:	c3 40       	breq	8000bdbc <__pow5mult+0x88>
8000bd56:	6e 95       	ld.w	r5,r7[0x24]
8000bd58:	58 05       	cp.w	r5,0
8000bd5a:	c0 91       	brne	8000bd6c <__pow5mult+0x38>
8000bd5c:	31 0c       	mov	r12,16
8000bd5e:	fe b0 dc 15 	rcall	80007588 <malloc>
8000bd62:	99 35       	st.w	r12[0xc],r5
8000bd64:	8f 9c       	st.w	r7[0x24],r12
8000bd66:	99 15       	st.w	r12[0x4],r5
8000bd68:	99 25       	st.w	r12[0x8],r5
8000bd6a:	99 05       	st.w	r12[0x0],r5
8000bd6c:	6e 93       	ld.w	r3,r7[0x24]
8000bd6e:	66 25       	ld.w	r5,r3[0x8]
8000bd70:	58 05       	cp.w	r5,0
8000bd72:	c0 c1       	brne	8000bd8a <__pow5mult+0x56>
8000bd74:	e0 6b 02 71 	mov	r11,625
8000bd78:	0e 9c       	mov	r12,r7
8000bd7a:	c9 7f       	rcall	8000bca8 <__i2b>
8000bd7c:	87 2c       	st.w	r3[0x8],r12
8000bd7e:	30 08       	mov	r8,0
8000bd80:	18 95       	mov	r5,r12
8000bd82:	99 08       	st.w	r12[0x0],r8
8000bd84:	c0 38       	rjmp	8000bd8a <__pow5mult+0x56>
8000bd86:	06 9c       	mov	r12,r3
8000bd88:	18 95       	mov	r5,r12
8000bd8a:	ed b6 00 00 	bld	r6,0x0
8000bd8e:	c0 b1       	brne	8000bda4 <__pow5mult+0x70>
8000bd90:	08 9b       	mov	r11,r4
8000bd92:	0a 9a       	mov	r10,r5
8000bd94:	0e 9c       	mov	r12,r7
8000bd96:	c0 9f       	rcall	8000bba8 <__multiply>
8000bd98:	08 9b       	mov	r11,r4
8000bd9a:	18 93       	mov	r3,r12
8000bd9c:	0e 9c       	mov	r12,r7
8000bd9e:	06 94       	mov	r4,r3
8000bda0:	fe b0 fd b6 	rcall	8000b90c <_Bfree>
8000bda4:	a1 56       	asr	r6,0x1
8000bda6:	c0 b0       	breq	8000bdbc <__pow5mult+0x88>
8000bda8:	6a 03       	ld.w	r3,r5[0x0]
8000bdaa:	58 03       	cp.w	r3,0
8000bdac:	ce d1       	brne	8000bd86 <__pow5mult+0x52>
8000bdae:	0a 9a       	mov	r10,r5
8000bdb0:	0a 9b       	mov	r11,r5
8000bdb2:	0e 9c       	mov	r12,r7
8000bdb4:	cf ae       	rcall	8000bba8 <__multiply>
8000bdb6:	8b 0c       	st.w	r5[0x0],r12
8000bdb8:	99 03       	st.w	r12[0x0],r3
8000bdba:	ce 7b       	rjmp	8000bd88 <__pow5mult+0x54>
8000bdbc:	08 9c       	mov	r12,r4
8000bdbe:	d8 32       	popm	r0-r7,pc

8000bdc0 <__isinfd>:
8000bdc0:	14 98       	mov	r8,r10
8000bdc2:	fc 19 7f f0 	movh	r9,0x7ff0
8000bdc6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bdca:	f0 0b 11 00 	rsub	r11,r8,0
8000bdce:	f7 e8 10 08 	or	r8,r11,r8
8000bdd2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bdd6:	f2 08 01 08 	sub	r8,r9,r8
8000bdda:	f0 0c 11 00 	rsub	r12,r8,0
8000bdde:	f9 e8 10 08 	or	r8,r12,r8
8000bde2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bde6:	2f fc       	sub	r12,-1
8000bde8:	5e fc       	retal	r12

8000bdea <__isnand>:
8000bdea:	14 98       	mov	r8,r10
8000bdec:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bdf0:	f0 0c 11 00 	rsub	r12,r8,0
8000bdf4:	10 4c       	or	r12,r8
8000bdf6:	fc 18 7f f0 	movh	r8,0x7ff0
8000bdfa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bdfe:	f0 0c 01 0c 	sub	r12,r8,r12
8000be02:	bf 9c       	lsr	r12,0x1f
8000be04:	5e fc       	retal	r12
8000be06:	d7 03       	nop

8000be08 <__sclose>:
8000be08:	d4 01       	pushm	lr
8000be0a:	96 7b       	ld.sh	r11,r11[0xe]
8000be0c:	c8 2c       	rcall	8000bf10 <_close_r>
8000be0e:	d8 02       	popm	pc

8000be10 <__sseek>:
8000be10:	d4 21       	pushm	r4-r7,lr
8000be12:	16 97       	mov	r7,r11
8000be14:	96 7b       	ld.sh	r11,r11[0xe]
8000be16:	c0 3d       	rcall	8000c01c <_lseek_r>
8000be18:	8e 68       	ld.sh	r8,r7[0xc]
8000be1a:	10 99       	mov	r9,r8
8000be1c:	ad c8       	cbr	r8,0xc
8000be1e:	ad a9       	sbr	r9,0xc
8000be20:	5b fc       	cp.w	r12,-1
8000be22:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000be26:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000be2a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000be2e:	d8 22       	popm	r4-r7,pc

8000be30 <__swrite>:
8000be30:	d4 21       	pushm	r4-r7,lr
8000be32:	96 68       	ld.sh	r8,r11[0xc]
8000be34:	16 97       	mov	r7,r11
8000be36:	14 95       	mov	r5,r10
8000be38:	12 94       	mov	r4,r9
8000be3a:	e2 18 01 00 	andl	r8,0x100,COH
8000be3e:	18 96       	mov	r6,r12
8000be40:	c0 50       	breq	8000be4a <__swrite+0x1a>
8000be42:	30 29       	mov	r9,2
8000be44:	30 0a       	mov	r10,0
8000be46:	96 7b       	ld.sh	r11,r11[0xe]
8000be48:	ce ac       	rcall	8000c01c <_lseek_r>
8000be4a:	8e 68       	ld.sh	r8,r7[0xc]
8000be4c:	ad c8       	cbr	r8,0xc
8000be4e:	08 99       	mov	r9,r4
8000be50:	0a 9a       	mov	r10,r5
8000be52:	8e 7b       	ld.sh	r11,r7[0xe]
8000be54:	0c 9c       	mov	r12,r6
8000be56:	ae 68       	st.h	r7[0xc],r8
8000be58:	c1 cc       	rcall	8000be90 <_write_r>
8000be5a:	d8 22       	popm	r4-r7,pc

8000be5c <__sread>:
8000be5c:	d4 21       	pushm	r4-r7,lr
8000be5e:	16 97       	mov	r7,r11
8000be60:	96 7b       	ld.sh	r11,r11[0xe]
8000be62:	cf 1c       	rcall	8000c044 <_read_r>
8000be64:	c0 65       	brlt	8000be70 <__sread+0x14>
8000be66:	6f 58       	ld.w	r8,r7[0x54]
8000be68:	18 08       	add	r8,r12
8000be6a:	ef 48 00 54 	st.w	r7[84],r8
8000be6e:	d8 22       	popm	r4-r7,pc
8000be70:	8e 68       	ld.sh	r8,r7[0xc]
8000be72:	ad c8       	cbr	r8,0xc
8000be74:	ae 68       	st.h	r7[0xc],r8
8000be76:	d8 22       	popm	r4-r7,pc

8000be78 <strlen>:
8000be78:	30 09       	mov	r9,0
8000be7a:	18 98       	mov	r8,r12
8000be7c:	c0 28       	rjmp	8000be80 <strlen+0x8>
8000be7e:	2f f8       	sub	r8,-1
8000be80:	11 8a       	ld.ub	r10,r8[0x0]
8000be82:	f2 0a 18 00 	cp.b	r10,r9
8000be86:	cf c1       	brne	8000be7e <strlen+0x6>
8000be88:	f0 0c 01 0c 	sub	r12,r8,r12
8000be8c:	5e fc       	retal	r12
8000be8e:	d7 03       	nop

8000be90 <_write_r>:
8000be90:	d4 21       	pushm	r4-r7,lr
8000be92:	16 98       	mov	r8,r11
8000be94:	18 97       	mov	r7,r12
8000be96:	10 9c       	mov	r12,r8
8000be98:	30 08       	mov	r8,0
8000be9a:	14 9b       	mov	r11,r10
8000be9c:	e0 66 51 94 	mov	r6,20884
8000bea0:	12 9a       	mov	r10,r9
8000bea2:	8d 08       	st.w	r6[0x0],r8
8000bea4:	fe b0 d1 8a 	rcall	800061b8 <_write>
8000bea8:	5b fc       	cp.w	r12,-1
8000beaa:	c0 51       	brne	8000beb4 <_write_r+0x24>
8000beac:	6c 08       	ld.w	r8,r6[0x0]
8000beae:	58 08       	cp.w	r8,0
8000beb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beb4:	d8 22       	popm	r4-r7,pc
8000beb6:	d7 03       	nop

8000beb8 <_calloc_r>:
8000beb8:	d4 21       	pushm	r4-r7,lr
8000beba:	f4 0b 02 4b 	mul	r11,r10,r11
8000bebe:	fe b0 db 6d 	rcall	80007598 <_malloc_r>
8000bec2:	18 97       	mov	r7,r12
8000bec4:	c2 30       	breq	8000bf0a <_calloc_r+0x52>
8000bec6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000beca:	e0 1a ff fc 	andl	r10,0xfffc
8000bece:	20 4a       	sub	r10,4
8000bed0:	e0 4a 00 24 	cp.w	r10,36
8000bed4:	e0 8b 00 18 	brhi	8000bf04 <_calloc_r+0x4c>
8000bed8:	18 98       	mov	r8,r12
8000beda:	59 3a       	cp.w	r10,19
8000bedc:	e0 88 00 0f 	brls	8000befa <_calloc_r+0x42>
8000bee0:	30 09       	mov	r9,0
8000bee2:	10 a9       	st.w	r8++,r9
8000bee4:	10 a9       	st.w	r8++,r9
8000bee6:	59 ba       	cp.w	r10,27
8000bee8:	e0 88 00 09 	brls	8000befa <_calloc_r+0x42>
8000beec:	10 a9       	st.w	r8++,r9
8000beee:	10 a9       	st.w	r8++,r9
8000bef0:	e0 4a 00 24 	cp.w	r10,36
8000bef4:	c0 31       	brne	8000befa <_calloc_r+0x42>
8000bef6:	10 a9       	st.w	r8++,r9
8000bef8:	10 a9       	st.w	r8++,r9
8000befa:	30 09       	mov	r9,0
8000befc:	10 a9       	st.w	r8++,r9
8000befe:	91 19       	st.w	r8[0x4],r9
8000bf00:	91 09       	st.w	r8[0x0],r9
8000bf02:	c0 48       	rjmp	8000bf0a <_calloc_r+0x52>
8000bf04:	30 0b       	mov	r11,0
8000bf06:	fe b0 de 1c 	rcall	80007b3e <memset>
8000bf0a:	0e 9c       	mov	r12,r7
8000bf0c:	d8 22       	popm	r4-r7,pc
8000bf0e:	d7 03       	nop

8000bf10 <_close_r>:
8000bf10:	d4 21       	pushm	r4-r7,lr
8000bf12:	30 08       	mov	r8,0
8000bf14:	18 97       	mov	r7,r12
8000bf16:	e0 66 51 94 	mov	r6,20884
8000bf1a:	16 9c       	mov	r12,r11
8000bf1c:	8d 08       	st.w	r6[0x0],r8
8000bf1e:	fe b0 df b5 	rcall	80007e88 <_close>
8000bf22:	5b fc       	cp.w	r12,-1
8000bf24:	c0 51       	brne	8000bf2e <_close_r+0x1e>
8000bf26:	6c 08       	ld.w	r8,r6[0x0]
8000bf28:	58 08       	cp.w	r8,0
8000bf2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf2e:	d8 22       	popm	r4-r7,pc

8000bf30 <_fclose_r>:
8000bf30:	d4 21       	pushm	r4-r7,lr
8000bf32:	18 96       	mov	r6,r12
8000bf34:	16 97       	mov	r7,r11
8000bf36:	58 0b       	cp.w	r11,0
8000bf38:	c0 31       	brne	8000bf3e <_fclose_r+0xe>
8000bf3a:	16 95       	mov	r5,r11
8000bf3c:	c5 38       	rjmp	8000bfe2 <_fclose_r+0xb2>
8000bf3e:	fe b0 f8 a9 	rcall	8000b090 <__sfp_lock_acquire>
8000bf42:	58 06       	cp.w	r6,0
8000bf44:	c0 70       	breq	8000bf52 <_fclose_r+0x22>
8000bf46:	6c 68       	ld.w	r8,r6[0x18]
8000bf48:	58 08       	cp.w	r8,0
8000bf4a:	c0 41       	brne	8000bf52 <_fclose_r+0x22>
8000bf4c:	0c 9c       	mov	r12,r6
8000bf4e:	fe b0 f8 f3 	rcall	8000b134 <__sinit>
8000bf52:	fe c8 dc c2 	sub	r8,pc,-9022
8000bf56:	10 37       	cp.w	r7,r8
8000bf58:	c0 31       	brne	8000bf5e <_fclose_r+0x2e>
8000bf5a:	6c 07       	ld.w	r7,r6[0x0]
8000bf5c:	c0 c8       	rjmp	8000bf74 <_fclose_r+0x44>
8000bf5e:	fe c8 dc ae 	sub	r8,pc,-9042
8000bf62:	10 37       	cp.w	r7,r8
8000bf64:	c0 31       	brne	8000bf6a <_fclose_r+0x3a>
8000bf66:	6c 17       	ld.w	r7,r6[0x4]
8000bf68:	c0 68       	rjmp	8000bf74 <_fclose_r+0x44>
8000bf6a:	fe c8 dc 9a 	sub	r8,pc,-9062
8000bf6e:	10 37       	cp.w	r7,r8
8000bf70:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bf74:	8e 69       	ld.sh	r9,r7[0xc]
8000bf76:	30 08       	mov	r8,0
8000bf78:	f0 09 19 00 	cp.h	r9,r8
8000bf7c:	c0 51       	brne	8000bf86 <_fclose_r+0x56>
8000bf7e:	fe b0 f8 8a 	rcall	8000b092 <__sfp_lock_release>
8000bf82:	30 05       	mov	r5,0
8000bf84:	c2 f8       	rjmp	8000bfe2 <_fclose_r+0xb2>
8000bf86:	0e 9b       	mov	r11,r7
8000bf88:	0c 9c       	mov	r12,r6
8000bf8a:	fe b0 f7 fd 	rcall	8000af84 <_fflush_r>
8000bf8e:	6e c8       	ld.w	r8,r7[0x30]
8000bf90:	18 95       	mov	r5,r12
8000bf92:	58 08       	cp.w	r8,0
8000bf94:	c0 60       	breq	8000bfa0 <_fclose_r+0x70>
8000bf96:	6e 8b       	ld.w	r11,r7[0x20]
8000bf98:	0c 9c       	mov	r12,r6
8000bf9a:	5d 18       	icall	r8
8000bf9c:	f9 b5 05 ff 	movlt	r5,-1
8000bfa0:	8e 68       	ld.sh	r8,r7[0xc]
8000bfa2:	ed b8 00 07 	bld	r8,0x7
8000bfa6:	c0 51       	brne	8000bfb0 <_fclose_r+0x80>
8000bfa8:	6e 4b       	ld.w	r11,r7[0x10]
8000bfaa:	0c 9c       	mov	r12,r6
8000bfac:	fe b0 f9 5e 	rcall	8000b268 <_free_r>
8000bfb0:	6e db       	ld.w	r11,r7[0x34]
8000bfb2:	58 0b       	cp.w	r11,0
8000bfb4:	c0 a0       	breq	8000bfc8 <_fclose_r+0x98>
8000bfb6:	ee c8 ff bc 	sub	r8,r7,-68
8000bfba:	10 3b       	cp.w	r11,r8
8000bfbc:	c0 40       	breq	8000bfc4 <_fclose_r+0x94>
8000bfbe:	0c 9c       	mov	r12,r6
8000bfc0:	fe b0 f9 54 	rcall	8000b268 <_free_r>
8000bfc4:	30 08       	mov	r8,0
8000bfc6:	8f d8       	st.w	r7[0x34],r8
8000bfc8:	6f 2b       	ld.w	r11,r7[0x48]
8000bfca:	58 0b       	cp.w	r11,0
8000bfcc:	c0 70       	breq	8000bfda <_fclose_r+0xaa>
8000bfce:	0c 9c       	mov	r12,r6
8000bfd0:	fe b0 f9 4c 	rcall	8000b268 <_free_r>
8000bfd4:	30 08       	mov	r8,0
8000bfd6:	ef 48 00 48 	st.w	r7[72],r8
8000bfda:	30 08       	mov	r8,0
8000bfdc:	ae 68       	st.h	r7[0xc],r8
8000bfde:	fe b0 f8 5a 	rcall	8000b092 <__sfp_lock_release>
8000bfe2:	0a 9c       	mov	r12,r5
8000bfe4:	d8 22       	popm	r4-r7,pc
8000bfe6:	d7 03       	nop

8000bfe8 <fclose>:
8000bfe8:	d4 01       	pushm	lr
8000bfea:	e0 68 0a 48 	mov	r8,2632
8000bfee:	18 9b       	mov	r11,r12
8000bff0:	70 0c       	ld.w	r12,r8[0x0]
8000bff2:	c9 ff       	rcall	8000bf30 <_fclose_r>
8000bff4:	d8 02       	popm	pc
8000bff6:	d7 03       	nop

8000bff8 <_fstat_r>:
8000bff8:	d4 21       	pushm	r4-r7,lr
8000bffa:	16 98       	mov	r8,r11
8000bffc:	18 97       	mov	r7,r12
8000bffe:	10 9c       	mov	r12,r8
8000c000:	30 08       	mov	r8,0
8000c002:	e0 66 51 94 	mov	r6,20884
8000c006:	14 9b       	mov	r11,r10
8000c008:	8d 08       	st.w	r6[0x0],r8
8000c00a:	fe b0 df 67 	rcall	80007ed8 <_fstat>
8000c00e:	5b fc       	cp.w	r12,-1
8000c010:	c0 51       	brne	8000c01a <_fstat_r+0x22>
8000c012:	6c 08       	ld.w	r8,r6[0x0]
8000c014:	58 08       	cp.w	r8,0
8000c016:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c01a:	d8 22       	popm	r4-r7,pc

8000c01c <_lseek_r>:
8000c01c:	d4 21       	pushm	r4-r7,lr
8000c01e:	16 98       	mov	r8,r11
8000c020:	18 97       	mov	r7,r12
8000c022:	10 9c       	mov	r12,r8
8000c024:	30 08       	mov	r8,0
8000c026:	14 9b       	mov	r11,r10
8000c028:	e0 66 51 94 	mov	r6,20884
8000c02c:	12 9a       	mov	r10,r9
8000c02e:	8d 08       	st.w	r6[0x0],r8
8000c030:	fe b0 df 36 	rcall	80007e9c <_lseek>
8000c034:	5b fc       	cp.w	r12,-1
8000c036:	c0 51       	brne	8000c040 <_lseek_r+0x24>
8000c038:	6c 08       	ld.w	r8,r6[0x0]
8000c03a:	58 08       	cp.w	r8,0
8000c03c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c040:	d8 22       	popm	r4-r7,pc
8000c042:	d7 03       	nop

8000c044 <_read_r>:
8000c044:	d4 21       	pushm	r4-r7,lr
8000c046:	16 98       	mov	r8,r11
8000c048:	18 97       	mov	r7,r12
8000c04a:	10 9c       	mov	r12,r8
8000c04c:	30 08       	mov	r8,0
8000c04e:	14 9b       	mov	r11,r10
8000c050:	e0 66 51 94 	mov	r6,20884
8000c054:	12 9a       	mov	r10,r9
8000c056:	8d 08       	st.w	r6[0x0],r8
8000c058:	fe b0 d0 90 	rcall	80006178 <_read>
8000c05c:	5b fc       	cp.w	r12,-1
8000c05e:	c0 51       	brne	8000c068 <_read_r+0x24>
8000c060:	6c 08       	ld.w	r8,r6[0x0]
8000c062:	58 08       	cp.w	r8,0
8000c064:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c068:	d8 22       	popm	r4-r7,pc
8000c06a:	d7 03       	nop

8000c06c <__avr32_f64_mul>:
8000c06c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c070:	e0 80 00 dc 	breq	8000c228 <__avr32_f64_mul_op1_zero>
8000c074:	d4 21       	pushm	r4-r7,lr
8000c076:	f7 e9 20 0e 	eor	lr,r11,r9
8000c07a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c07e:	30 15       	mov	r5,1
8000c080:	c4 30       	breq	8000c106 <__avr32_f64_mul_op1_subnormal>
8000c082:	ab 6b       	lsl	r11,0xa
8000c084:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c088:	ab 6a       	lsl	r10,0xa
8000c08a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c08e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c092:	c5 c0       	breq	8000c14a <__avr32_f64_mul_op2_subnormal>
8000c094:	a1 78       	lsl	r8,0x1
8000c096:	5c f9       	rol	r9
8000c098:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c09c:	e0 47 07 ff 	cp.w	r7,2047
8000c0a0:	c7 70       	breq	8000c18e <__avr32_f64_mul_op_nan_or_inf>
8000c0a2:	e0 46 07 ff 	cp.w	r6,2047
8000c0a6:	c7 40       	breq	8000c18e <__avr32_f64_mul_op_nan_or_inf>
8000c0a8:	ee 06 00 0c 	add	r12,r7,r6
8000c0ac:	e0 2c 03 fe 	sub	r12,1022
8000c0b0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c0b4:	f4 09 07 44 	macu.d	r4,r10,r9
8000c0b8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c0bc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c0c0:	08 07       	add	r7,r4
8000c0c2:	f4 05 00 4a 	adc	r10,r10,r5
8000c0c6:	5c 0b       	acr	r11
8000c0c8:	ed bb 00 14 	bld	r11,0x14
8000c0cc:	c0 50       	breq	8000c0d6 <__avr32_f64_mul+0x6a>
8000c0ce:	a1 77       	lsl	r7,0x1
8000c0d0:	5c fa       	rol	r10
8000c0d2:	5c fb       	rol	r11
8000c0d4:	20 1c       	sub	r12,1
8000c0d6:	58 0c       	cp.w	r12,0
8000c0d8:	e0 8a 00 6f 	brle	8000c1b6 <__avr32_f64_mul_res_subnormal>
8000c0dc:	e0 4c 07 ff 	cp.w	r12,2047
8000c0e0:	e0 84 00 9c 	brge	8000c218 <__avr32_f64_mul_res_inf>
8000c0e4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c0e8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c0ec:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c0f0:	ee 17 80 00 	eorh	r7,0x8000
8000c0f4:	f1 b7 04 20 	satu	r7,0x1
8000c0f8:	0e 0a       	add	r10,r7
8000c0fa:	5c 0b       	acr	r11
8000c0fc:	ed be 00 1f 	bld	lr,0x1f
8000c100:	ef bb 00 1f 	bst	r11,0x1f
8000c104:	d8 22       	popm	r4-r7,pc

8000c106 <__avr32_f64_mul_op1_subnormal>:
8000c106:	e4 1b 00 0f 	andh	r11,0xf
8000c10a:	f4 0c 12 00 	clz	r12,r10
8000c10e:	f6 06 12 00 	clz	r6,r11
8000c112:	f7 bc 03 e1 	sublo	r12,-31
8000c116:	f8 06 17 30 	movlo	r6,r12
8000c11a:	f7 b6 02 01 	subhs	r6,1
8000c11e:	e0 46 00 20 	cp.w	r6,32
8000c122:	c0 d4       	brge	8000c13c <__avr32_f64_mul_op1_subnormal+0x36>
8000c124:	ec 0c 11 20 	rsub	r12,r6,32
8000c128:	f6 06 09 4b 	lsl	r11,r11,r6
8000c12c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c130:	18 4b       	or	r11,r12
8000c132:	f4 06 09 4a 	lsl	r10,r10,r6
8000c136:	20 b6       	sub	r6,11
8000c138:	0c 17       	sub	r7,r6
8000c13a:	ca ab       	rjmp	8000c08e <__avr32_f64_mul+0x22>
8000c13c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c140:	c6 40       	breq	8000c208 <__avr32_f64_mul_res_zero>
8000c142:	30 0a       	mov	r10,0
8000c144:	20 b6       	sub	r6,11
8000c146:	0c 17       	sub	r7,r6
8000c148:	ca 3b       	rjmp	8000c08e <__avr32_f64_mul+0x22>

8000c14a <__avr32_f64_mul_op2_subnormal>:
8000c14a:	e4 19 00 0f 	andh	r9,0xf
8000c14e:	f0 0c 12 00 	clz	r12,r8
8000c152:	f2 05 12 00 	clz	r5,r9
8000c156:	f7 bc 03 ea 	sublo	r12,-22
8000c15a:	f8 05 17 30 	movlo	r5,r12
8000c15e:	f7 b5 02 0a 	subhs	r5,10
8000c162:	e0 45 00 20 	cp.w	r5,32
8000c166:	c0 d4       	brge	8000c180 <__avr32_f64_mul_op2_subnormal+0x36>
8000c168:	ea 0c 11 20 	rsub	r12,r5,32
8000c16c:	f2 05 09 49 	lsl	r9,r9,r5
8000c170:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c174:	18 49       	or	r9,r12
8000c176:	f0 05 09 48 	lsl	r8,r8,r5
8000c17a:	20 25       	sub	r5,2
8000c17c:	0a 16       	sub	r6,r5
8000c17e:	c8 fb       	rjmp	8000c09c <__avr32_f64_mul+0x30>
8000c180:	f0 05 09 49 	lsl	r9,r8,r5
8000c184:	c4 20       	breq	8000c208 <__avr32_f64_mul_res_zero>
8000c186:	30 08       	mov	r8,0
8000c188:	20 25       	sub	r5,2
8000c18a:	0a 16       	sub	r6,r5
8000c18c:	c8 8b       	rjmp	8000c09c <__avr32_f64_mul+0x30>

8000c18e <__avr32_f64_mul_op_nan_or_inf>:
8000c18e:	e4 19 00 0f 	andh	r9,0xf
8000c192:	e4 1b 00 0f 	andh	r11,0xf
8000c196:	14 4b       	or	r11,r10
8000c198:	10 49       	or	r9,r8
8000c19a:	e0 47 07 ff 	cp.w	r7,2047
8000c19e:	c0 91       	brne	8000c1b0 <__avr32_f64_mul_op1_not_naninf>
8000c1a0:	58 0b       	cp.w	r11,0
8000c1a2:	c3 81       	brne	8000c212 <__avr32_f64_mul_res_nan>
8000c1a4:	e0 46 07 ff 	cp.w	r6,2047
8000c1a8:	c3 81       	brne	8000c218 <__avr32_f64_mul_res_inf>
8000c1aa:	58 09       	cp.w	r9,0
8000c1ac:	c3 60       	breq	8000c218 <__avr32_f64_mul_res_inf>
8000c1ae:	c3 28       	rjmp	8000c212 <__avr32_f64_mul_res_nan>

8000c1b0 <__avr32_f64_mul_op1_not_naninf>:
8000c1b0:	58 09       	cp.w	r9,0
8000c1b2:	c3 30       	breq	8000c218 <__avr32_f64_mul_res_inf>
8000c1b4:	c2 f8       	rjmp	8000c212 <__avr32_f64_mul_res_nan>

8000c1b6 <__avr32_f64_mul_res_subnormal>:
8000c1b6:	5c 3c       	neg	r12
8000c1b8:	2f fc       	sub	r12,-1
8000c1ba:	f1 bc 04 c0 	satu	r12,0x6
8000c1be:	e0 4c 00 20 	cp.w	r12,32
8000c1c2:	c1 14       	brge	8000c1e4 <__avr32_f64_mul_res_subnormal+0x2e>
8000c1c4:	f8 08 11 20 	rsub	r8,r12,32
8000c1c8:	0e 46       	or	r6,r7
8000c1ca:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c1ce:	f4 08 09 49 	lsl	r9,r10,r8
8000c1d2:	12 47       	or	r7,r9
8000c1d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1d8:	f6 08 09 49 	lsl	r9,r11,r8
8000c1dc:	12 4a       	or	r10,r9
8000c1de:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c1e2:	c8 3b       	rjmp	8000c0e8 <__avr32_f64_mul+0x7c>
8000c1e4:	f8 08 11 20 	rsub	r8,r12,32
8000c1e8:	f9 b9 00 00 	moveq	r9,0
8000c1ec:	c0 30       	breq	8000c1f2 <__avr32_f64_mul_res_subnormal+0x3c>
8000c1ee:	f6 08 09 49 	lsl	r9,r11,r8
8000c1f2:	0e 46       	or	r6,r7
8000c1f4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c1f8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1fc:	f3 ea 10 07 	or	r7,r9,r10
8000c200:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c204:	30 0b       	mov	r11,0
8000c206:	c7 1b       	rjmp	8000c0e8 <__avr32_f64_mul+0x7c>

8000c208 <__avr32_f64_mul_res_zero>:
8000c208:	1c 9b       	mov	r11,lr
8000c20a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c20e:	30 0a       	mov	r10,0
8000c210:	d8 22       	popm	r4-r7,pc

8000c212 <__avr32_f64_mul_res_nan>:
8000c212:	3f fb       	mov	r11,-1
8000c214:	3f fa       	mov	r10,-1
8000c216:	d8 22       	popm	r4-r7,pc

8000c218 <__avr32_f64_mul_res_inf>:
8000c218:	f0 6b 00 00 	mov	r11,-1048576
8000c21c:	ed be 00 1f 	bld	lr,0x1f
8000c220:	ef bb 00 1f 	bst	r11,0x1f
8000c224:	30 0a       	mov	r10,0
8000c226:	d8 22       	popm	r4-r7,pc

8000c228 <__avr32_f64_mul_op1_zero>:
8000c228:	f7 e9 20 0b 	eor	r11,r11,r9
8000c22c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c230:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c234:	e0 4c 07 ff 	cp.w	r12,2047
8000c238:	5e 1c       	retne	r12
8000c23a:	3f fa       	mov	r10,-1
8000c23c:	3f fb       	mov	r11,-1
8000c23e:	5e fc       	retal	r12

8000c240 <__avr32_f64_sub_from_add>:
8000c240:	ee 19 80 00 	eorh	r9,0x8000

8000c244 <__avr32_f64_sub>:
8000c244:	f7 e9 20 0c 	eor	r12,r11,r9
8000c248:	e0 86 00 ca 	brmi	8000c3dc <__avr32_f64_add_from_sub>
8000c24c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c250:	16 9c       	mov	r12,r11
8000c252:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c256:	bf db       	cbr	r11,0x1f
8000c258:	bf d9       	cbr	r9,0x1f
8000c25a:	10 3a       	cp.w	r10,r8
8000c25c:	f2 0b 13 00 	cpc	r11,r9
8000c260:	c0 92       	brcc	8000c272 <__avr32_f64_sub+0x2e>
8000c262:	16 97       	mov	r7,r11
8000c264:	12 9b       	mov	r11,r9
8000c266:	0e 99       	mov	r9,r7
8000c268:	14 97       	mov	r7,r10
8000c26a:	10 9a       	mov	r10,r8
8000c26c:	0e 98       	mov	r8,r7
8000c26e:	ee 1c 80 00 	eorh	r12,0x8000
8000c272:	f6 07 16 14 	lsr	r7,r11,0x14
8000c276:	ab 7b       	lsl	r11,0xb
8000c278:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c27c:	ab 7a       	lsl	r10,0xb
8000c27e:	bf bb       	sbr	r11,0x1f
8000c280:	f2 06 16 14 	lsr	r6,r9,0x14
8000c284:	c4 40       	breq	8000c30c <__avr32_f64_sub_opL_subnormal>
8000c286:	ab 79       	lsl	r9,0xb
8000c288:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c28c:	ab 78       	lsl	r8,0xb
8000c28e:	bf b9       	sbr	r9,0x1f

8000c290 <__avr32_f64_sub_opL_subnormal_done>:
8000c290:	e0 47 07 ff 	cp.w	r7,2047
8000c294:	c4 f0       	breq	8000c332 <__avr32_f64_sub_opH_nan_or_inf>
8000c296:	0e 26       	rsub	r6,r7
8000c298:	c1 20       	breq	8000c2bc <__avr32_f64_sub_shift_done>
8000c29a:	ec 05 11 20 	rsub	r5,r6,32
8000c29e:	e0 46 00 20 	cp.w	r6,32
8000c2a2:	c7 c2       	brcc	8000c39a <__avr32_f64_sub_longshift>
8000c2a4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c2a8:	f2 05 09 45 	lsl	r5,r9,r5
8000c2ac:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2b0:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2b4:	0a 48       	or	r8,r5
8000c2b6:	58 0e       	cp.w	lr,0
8000c2b8:	5f 1e       	srne	lr
8000c2ba:	1c 48       	or	r8,lr

8000c2bc <__avr32_f64_sub_shift_done>:
8000c2bc:	10 1a       	sub	r10,r8
8000c2be:	f6 09 01 4b 	sbc	r11,r11,r9
8000c2c2:	f6 06 12 00 	clz	r6,r11
8000c2c6:	c0 e0       	breq	8000c2e2 <__avr32_f64_sub_longnormalize_done>
8000c2c8:	c7 83       	brcs	8000c3b8 <__avr32_f64_sub_longnormalize>
8000c2ca:	ec 0e 11 20 	rsub	lr,r6,32
8000c2ce:	f6 06 09 4b 	lsl	r11,r11,r6
8000c2d2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c2d6:	1c 4b       	or	r11,lr
8000c2d8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c2dc:	0c 17       	sub	r7,r6
8000c2de:	e0 8a 00 39 	brle	8000c350 <__avr32_f64_sub_subnormal_result>

8000c2e2 <__avr32_f64_sub_longnormalize_done>:
8000c2e2:	f4 09 15 15 	lsl	r9,r10,0x15
8000c2e6:	ab 9a       	lsr	r10,0xb
8000c2e8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c2ec:	ab 9b       	lsr	r11,0xb
8000c2ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2f2:	18 4b       	or	r11,r12

8000c2f4 <__avr32_f64_sub_round>:
8000c2f4:	fc 17 80 00 	movh	r7,0x8000
8000c2f8:	ed ba 00 00 	bld	r10,0x0
8000c2fc:	f7 b7 01 ff 	subne	r7,-1
8000c300:	0e 39       	cp.w	r9,r7
8000c302:	5f 29       	srhs	r9
8000c304:	12 0a       	add	r10,r9
8000c306:	5c 0b       	acr	r11
8000c308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c30c <__avr32_f64_sub_opL_subnormal>:
8000c30c:	ab 79       	lsl	r9,0xb
8000c30e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c312:	ab 78       	lsl	r8,0xb
8000c314:	f3 e8 10 0e 	or	lr,r9,r8
8000c318:	f9 b6 01 01 	movne	r6,1
8000c31c:	ee 0e 11 00 	rsub	lr,r7,0
8000c320:	f9 b7 00 01 	moveq	r7,1
8000c324:	ef bb 00 1f 	bst	r11,0x1f
8000c328:	f7 ea 10 0e 	or	lr,r11,r10
8000c32c:	f9 b7 00 00 	moveq	r7,0
8000c330:	cb 0b       	rjmp	8000c290 <__avr32_f64_sub_opL_subnormal_done>

8000c332 <__avr32_f64_sub_opH_nan_or_inf>:
8000c332:	bf db       	cbr	r11,0x1f
8000c334:	f7 ea 10 0e 	or	lr,r11,r10
8000c338:	c0 81       	brne	8000c348 <__avr32_f64_sub_return_nan>
8000c33a:	e0 46 07 ff 	cp.w	r6,2047
8000c33e:	c0 50       	breq	8000c348 <__avr32_f64_sub_return_nan>
8000c340:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c344:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c348 <__avr32_f64_sub_return_nan>:
8000c348:	3f fa       	mov	r10,-1
8000c34a:	3f fb       	mov	r11,-1
8000c34c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c350 <__avr32_f64_sub_subnormal_result>:
8000c350:	5c 37       	neg	r7
8000c352:	2f f7       	sub	r7,-1
8000c354:	f1 b7 04 c0 	satu	r7,0x6
8000c358:	e0 47 00 20 	cp.w	r7,32
8000c35c:	c1 14       	brge	8000c37e <__avr32_f64_sub_subnormal_result+0x2e>
8000c35e:	ee 08 11 20 	rsub	r8,r7,32
8000c362:	f4 08 09 49 	lsl	r9,r10,r8
8000c366:	5f 16       	srne	r6
8000c368:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c36c:	0c 4a       	or	r10,r6
8000c36e:	f6 08 09 49 	lsl	r9,r11,r8
8000c372:	f5 e9 10 0a 	or	r10,r10,r9
8000c376:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c37a:	30 07       	mov	r7,0
8000c37c:	cb 3b       	rjmp	8000c2e2 <__avr32_f64_sub_longnormalize_done>
8000c37e:	ee 08 11 40 	rsub	r8,r7,64
8000c382:	f6 08 09 49 	lsl	r9,r11,r8
8000c386:	14 49       	or	r9,r10
8000c388:	5f 16       	srne	r6
8000c38a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c38e:	0c 4a       	or	r10,r6
8000c390:	30 0b       	mov	r11,0
8000c392:	30 07       	mov	r7,0
8000c394:	ca 7b       	rjmp	8000c2e2 <__avr32_f64_sub_longnormalize_done>
8000c396:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c39a <__avr32_f64_sub_longshift>:
8000c39a:	f1 b6 04 c0 	satu	r6,0x6
8000c39e:	f0 0e 17 00 	moveq	lr,r8
8000c3a2:	c0 40       	breq	8000c3aa <__avr32_f64_sub_longshift+0x10>
8000c3a4:	f2 05 09 4e 	lsl	lr,r9,r5
8000c3a8:	10 4e       	or	lr,r8
8000c3aa:	f2 06 0a 48 	lsr	r8,r9,r6
8000c3ae:	30 09       	mov	r9,0
8000c3b0:	58 0e       	cp.w	lr,0
8000c3b2:	5f 1e       	srne	lr
8000c3b4:	1c 48       	or	r8,lr
8000c3b6:	c8 3b       	rjmp	8000c2bc <__avr32_f64_sub_shift_done>

8000c3b8 <__avr32_f64_sub_longnormalize>:
8000c3b8:	f4 06 12 00 	clz	r6,r10
8000c3bc:	f9 b7 03 00 	movlo	r7,0
8000c3c0:	f9 b6 03 00 	movlo	r6,0
8000c3c4:	f9 bc 03 00 	movlo	r12,0
8000c3c8:	f7 b6 02 e0 	subhs	r6,-32
8000c3cc:	f4 06 09 4b 	lsl	r11,r10,r6
8000c3d0:	30 0a       	mov	r10,0
8000c3d2:	0c 17       	sub	r7,r6
8000c3d4:	fe 9a ff be 	brle	8000c350 <__avr32_f64_sub_subnormal_result>
8000c3d8:	c8 5b       	rjmp	8000c2e2 <__avr32_f64_sub_longnormalize_done>
8000c3da:	d7 03       	nop

8000c3dc <__avr32_f64_add_from_sub>:
8000c3dc:	ee 19 80 00 	eorh	r9,0x8000

8000c3e0 <__avr32_f64_add>:
8000c3e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000c3e4:	fe 96 ff 2e 	brmi	8000c240 <__avr32_f64_sub_from_add>
8000c3e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000c3ec:	16 9c       	mov	r12,r11
8000c3ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c3f2:	bf db       	cbr	r11,0x1f
8000c3f4:	bf d9       	cbr	r9,0x1f
8000c3f6:	12 3b       	cp.w	r11,r9
8000c3f8:	c0 72       	brcc	8000c406 <__avr32_f64_add+0x26>
8000c3fa:	16 97       	mov	r7,r11
8000c3fc:	12 9b       	mov	r11,r9
8000c3fe:	0e 99       	mov	r9,r7
8000c400:	14 97       	mov	r7,r10
8000c402:	10 9a       	mov	r10,r8
8000c404:	0e 98       	mov	r8,r7
8000c406:	30 0e       	mov	lr,0
8000c408:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c40c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c410:	b5 ab       	sbr	r11,0x14
8000c412:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c416:	c6 20       	breq	8000c4da <__avr32_f64_add_op2_subnormal>
8000c418:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c41c:	b5 a9       	sbr	r9,0x14
8000c41e:	e0 47 07 ff 	cp.w	r7,2047
8000c422:	c2 80       	breq	8000c472 <__avr32_f64_add_opH_nan_or_inf>
8000c424:	0e 26       	rsub	r6,r7
8000c426:	c1 20       	breq	8000c44a <__avr32_f64_add_shift_done>
8000c428:	e0 46 00 36 	cp.w	r6,54
8000c42c:	c1 52       	brcc	8000c456 <__avr32_f64_add_res_of_done>
8000c42e:	ec 05 11 20 	rsub	r5,r6,32
8000c432:	e0 46 00 20 	cp.w	r6,32
8000c436:	c3 52       	brcc	8000c4a0 <__avr32_f64_add_longshift>
8000c438:	f0 05 09 4e 	lsl	lr,r8,r5
8000c43c:	f2 05 09 45 	lsl	r5,r9,r5
8000c440:	f0 06 0a 48 	lsr	r8,r8,r6
8000c444:	f2 06 0a 49 	lsr	r9,r9,r6
8000c448:	0a 48       	or	r8,r5

8000c44a <__avr32_f64_add_shift_done>:
8000c44a:	10 0a       	add	r10,r8
8000c44c:	f6 09 00 4b 	adc	r11,r11,r9
8000c450:	ed bb 00 15 	bld	r11,0x15
8000c454:	c3 40       	breq	8000c4bc <__avr32_f64_add_res_of>

8000c456 <__avr32_f64_add_res_of_done>:
8000c456:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c45a:	18 4b       	or	r11,r12

8000c45c <__avr32_f64_add_round>:
8000c45c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c460:	18 4e       	or	lr,r12
8000c462:	ee 1e 80 00 	eorh	lr,0x8000
8000c466:	f1 be 04 20 	satu	lr,0x1
8000c46a:	1c 0a       	add	r10,lr
8000c46c:	5c 0b       	acr	r11
8000c46e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c472 <__avr32_f64_add_opH_nan_or_inf>:
8000c472:	b5 cb       	cbr	r11,0x14
8000c474:	f7 ea 10 0e 	or	lr,r11,r10
8000c478:	c1 01       	brne	8000c498 <__avr32_f64_add_return_nan>
8000c47a:	e0 46 07 ff 	cp.w	r6,2047
8000c47e:	c0 30       	breq	8000c484 <__avr32_f64_add_opL_nan_or_inf>
8000c480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c484 <__avr32_f64_add_opL_nan_or_inf>:
8000c484:	b5 c9       	cbr	r9,0x14
8000c486:	f3 e8 10 0e 	or	lr,r9,r8
8000c48a:	c0 71       	brne	8000c498 <__avr32_f64_add_return_nan>
8000c48c:	30 0a       	mov	r10,0
8000c48e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c492:	18 4b       	or	r11,r12
8000c494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c498 <__avr32_f64_add_return_nan>:
8000c498:	3f fa       	mov	r10,-1
8000c49a:	3f fb       	mov	r11,-1
8000c49c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c4a0 <__avr32_f64_add_longshift>:
8000c4a0:	f1 b6 04 c0 	satu	r6,0x6
8000c4a4:	f0 0e 17 00 	moveq	lr,r8
8000c4a8:	c0 60       	breq	8000c4b4 <__avr32_f64_add_longshift+0x14>
8000c4aa:	f2 05 09 4e 	lsl	lr,r9,r5
8000c4ae:	58 08       	cp.w	r8,0
8000c4b0:	5f 18       	srne	r8
8000c4b2:	10 4e       	or	lr,r8
8000c4b4:	f2 06 0a 48 	lsr	r8,r9,r6
8000c4b8:	30 09       	mov	r9,0
8000c4ba:	cc 8b       	rjmp	8000c44a <__avr32_f64_add_shift_done>

8000c4bc <__avr32_f64_add_res_of>:
8000c4bc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c4c0:	a1 9b       	lsr	r11,0x1
8000c4c2:	5d 0a       	ror	r10
8000c4c4:	5d 0e       	ror	lr
8000c4c6:	2f f7       	sub	r7,-1
8000c4c8:	e0 47 07 ff 	cp.w	r7,2047
8000c4cc:	f9 ba 00 00 	moveq	r10,0
8000c4d0:	f9 bb 00 00 	moveq	r11,0
8000c4d4:	f9 be 00 00 	moveq	lr,0
8000c4d8:	cb fb       	rjmp	8000c456 <__avr32_f64_add_res_of_done>

8000c4da <__avr32_f64_add_op2_subnormal>:
8000c4da:	30 16       	mov	r6,1
8000c4dc:	58 07       	cp.w	r7,0
8000c4de:	ca 01       	brne	8000c41e <__avr32_f64_add+0x3e>
8000c4e0:	b5 cb       	cbr	r11,0x14
8000c4e2:	10 0a       	add	r10,r8
8000c4e4:	f6 09 00 4b 	adc	r11,r11,r9
8000c4e8:	18 4b       	or	r11,r12
8000c4ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c4ee:	d7 03       	nop

8000c4f0 <__avr32_f64_to_u32>:
8000c4f0:	58 0b       	cp.w	r11,0
8000c4f2:	5e 6d       	retmi	0

8000c4f4 <__avr32_f64_to_s32>:
8000c4f4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c4f8:	b5 9c       	lsr	r12,0x15
8000c4fa:	e0 2c 03 ff 	sub	r12,1023
8000c4fe:	5e 3d       	retlo	0
8000c500:	f8 0c 11 1f 	rsub	r12,r12,31
8000c504:	16 99       	mov	r9,r11
8000c506:	ab 7b       	lsl	r11,0xb
8000c508:	bf bb       	sbr	r11,0x1f
8000c50a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c50e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c512:	a1 79       	lsl	r9,0x1
8000c514:	5e 2b       	reths	r11
8000c516:	5c 3b       	neg	r11
8000c518:	5e fb       	retal	r11

8000c51a <__avr32_u32_to_f64>:
8000c51a:	f8 cb 00 00 	sub	r11,r12,0
8000c51e:	30 0c       	mov	r12,0
8000c520:	c0 38       	rjmp	8000c526 <__avr32_s32_to_f64+0x4>

8000c522 <__avr32_s32_to_f64>:
8000c522:	18 9b       	mov	r11,r12
8000c524:	5c 4b       	abs	r11
8000c526:	30 0a       	mov	r10,0
8000c528:	5e 0b       	reteq	r11
8000c52a:	d4 01       	pushm	lr
8000c52c:	e0 69 04 1e 	mov	r9,1054
8000c530:	f6 08 12 00 	clz	r8,r11
8000c534:	c1 70       	breq	8000c562 <__avr32_s32_to_f64+0x40>
8000c536:	c0 c3       	brcs	8000c54e <__avr32_s32_to_f64+0x2c>
8000c538:	f0 0e 11 20 	rsub	lr,r8,32
8000c53c:	f6 08 09 4b 	lsl	r11,r11,r8
8000c540:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c544:	1c 4b       	or	r11,lr
8000c546:	f4 08 09 4a 	lsl	r10,r10,r8
8000c54a:	10 19       	sub	r9,r8
8000c54c:	c0 b8       	rjmp	8000c562 <__avr32_s32_to_f64+0x40>
8000c54e:	f4 08 12 00 	clz	r8,r10
8000c552:	f9 b8 03 00 	movlo	r8,0
8000c556:	f7 b8 02 e0 	subhs	r8,-32
8000c55a:	f4 08 09 4b 	lsl	r11,r10,r8
8000c55e:	30 0a       	mov	r10,0
8000c560:	10 19       	sub	r9,r8
8000c562:	58 09       	cp.w	r9,0
8000c564:	e0 89 00 30 	brgt	8000c5c4 <__avr32_s32_to_f64+0xa2>
8000c568:	5c 39       	neg	r9
8000c56a:	2f f9       	sub	r9,-1
8000c56c:	e0 49 00 36 	cp.w	r9,54
8000c570:	c0 43       	brcs	8000c578 <__avr32_s32_to_f64+0x56>
8000c572:	30 0b       	mov	r11,0
8000c574:	30 0a       	mov	r10,0
8000c576:	c2 68       	rjmp	8000c5c2 <__avr32_s32_to_f64+0xa0>
8000c578:	2f 69       	sub	r9,-10
8000c57a:	f2 08 11 20 	rsub	r8,r9,32
8000c57e:	e0 49 00 20 	cp.w	r9,32
8000c582:	c0 b2       	brcc	8000c598 <__avr32_s32_to_f64+0x76>
8000c584:	f4 08 09 4e 	lsl	lr,r10,r8
8000c588:	f6 08 09 48 	lsl	r8,r11,r8
8000c58c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c590:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c594:	10 4b       	or	r11,r8
8000c596:	c0 88       	rjmp	8000c5a6 <__avr32_s32_to_f64+0x84>
8000c598:	f6 08 09 4e 	lsl	lr,r11,r8
8000c59c:	14 4e       	or	lr,r10
8000c59e:	16 9a       	mov	r10,r11
8000c5a0:	30 0b       	mov	r11,0
8000c5a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c5a6:	ed ba 00 00 	bld	r10,0x0
8000c5aa:	c0 92       	brcc	8000c5bc <__avr32_s32_to_f64+0x9a>
8000c5ac:	1c 7e       	tst	lr,lr
8000c5ae:	c0 41       	brne	8000c5b6 <__avr32_s32_to_f64+0x94>
8000c5b0:	ed ba 00 01 	bld	r10,0x1
8000c5b4:	c0 42       	brcc	8000c5bc <__avr32_s32_to_f64+0x9a>
8000c5b6:	2f fa       	sub	r10,-1
8000c5b8:	f7 bb 02 ff 	subhs	r11,-1
8000c5bc:	5c fc       	rol	r12
8000c5be:	5d 0b       	ror	r11
8000c5c0:	5d 0a       	ror	r10
8000c5c2:	d8 02       	popm	pc
8000c5c4:	e0 68 03 ff 	mov	r8,1023
8000c5c8:	ed ba 00 0b 	bld	r10,0xb
8000c5cc:	f7 b8 00 ff 	subeq	r8,-1
8000c5d0:	10 0a       	add	r10,r8
8000c5d2:	5c 0b       	acr	r11
8000c5d4:	f7 b9 03 fe 	sublo	r9,-2
8000c5d8:	e0 49 07 ff 	cp.w	r9,2047
8000c5dc:	c0 55       	brlt	8000c5e6 <__avr32_s32_to_f64+0xc4>
8000c5de:	30 0a       	mov	r10,0
8000c5e0:	fc 1b ff e0 	movh	r11,0xffe0
8000c5e4:	c0 c8       	rjmp	8000c5fc <__floatsidf_return_op1>
8000c5e6:	ed bb 00 1f 	bld	r11,0x1f
8000c5ea:	f7 b9 01 01 	subne	r9,1
8000c5ee:	ab 9a       	lsr	r10,0xb
8000c5f0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c5f4:	a1 7b       	lsl	r11,0x1
8000c5f6:	ab 9b       	lsr	r11,0xb
8000c5f8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c5fc <__floatsidf_return_op1>:
8000c5fc:	a1 7c       	lsl	r12,0x1
8000c5fe:	5d 0b       	ror	r11
8000c600:	d8 02       	popm	pc

8000c602 <__avr32_f64_cmp_eq>:
8000c602:	10 3a       	cp.w	r10,r8
8000c604:	f2 0b 13 00 	cpc	r11,r9
8000c608:	c0 80       	breq	8000c618 <__avr32_f64_cmp_eq+0x16>
8000c60a:	a1 7b       	lsl	r11,0x1
8000c60c:	a1 79       	lsl	r9,0x1
8000c60e:	14 4b       	or	r11,r10
8000c610:	12 4b       	or	r11,r9
8000c612:	10 4b       	or	r11,r8
8000c614:	5e 0f       	reteq	1
8000c616:	5e fd       	retal	0
8000c618:	a1 7b       	lsl	r11,0x1
8000c61a:	fc 1c ff e0 	movh	r12,0xffe0
8000c61e:	58 0a       	cp.w	r10,0
8000c620:	f8 0b 13 00 	cpc	r11,r12
8000c624:	5e 8f       	retls	1
8000c626:	5e fd       	retal	0

8000c628 <__avr32_f64_cmp_ge>:
8000c628:	1a de       	st.w	--sp,lr
8000c62a:	1a d7       	st.w	--sp,r7
8000c62c:	a1 7b       	lsl	r11,0x1
8000c62e:	5f 3c       	srlo	r12
8000c630:	a1 79       	lsl	r9,0x1
8000c632:	5f 37       	srlo	r7
8000c634:	5c fc       	rol	r12
8000c636:	fc 1e ff e0 	movh	lr,0xffe0
8000c63a:	58 0a       	cp.w	r10,0
8000c63c:	fc 0b 13 00 	cpc	r11,lr
8000c640:	e0 8b 00 1d 	brhi	8000c67a <__avr32_f64_cmp_ge+0x52>
8000c644:	58 08       	cp.w	r8,0
8000c646:	fc 09 13 00 	cpc	r9,lr
8000c64a:	e0 8b 00 18 	brhi	8000c67a <__avr32_f64_cmp_ge+0x52>
8000c64e:	58 0b       	cp.w	r11,0
8000c650:	f5 ba 00 00 	subfeq	r10,0
8000c654:	c1 50       	breq	8000c67e <__avr32_f64_cmp_ge+0x56>
8000c656:	1b 07       	ld.w	r7,sp++
8000c658:	1b 0e       	ld.w	lr,sp++
8000c65a:	58 3c       	cp.w	r12,3
8000c65c:	c0 a0       	breq	8000c670 <__avr32_f64_cmp_ge+0x48>
8000c65e:	58 1c       	cp.w	r12,1
8000c660:	c0 33       	brcs	8000c666 <__avr32_f64_cmp_ge+0x3e>
8000c662:	5e 0f       	reteq	1
8000c664:	5e 1d       	retne	0
8000c666:	10 3a       	cp.w	r10,r8
8000c668:	f2 0b 13 00 	cpc	r11,r9
8000c66c:	5e 2f       	reths	1
8000c66e:	5e 3d       	retlo	0
8000c670:	14 38       	cp.w	r8,r10
8000c672:	f6 09 13 00 	cpc	r9,r11
8000c676:	5e 2f       	reths	1
8000c678:	5e 3d       	retlo	0
8000c67a:	1b 07       	ld.w	r7,sp++
8000c67c:	d8 0a       	popm	pc,r12=0
8000c67e:	58 17       	cp.w	r7,1
8000c680:	5f 0c       	sreq	r12
8000c682:	58 09       	cp.w	r9,0
8000c684:	f5 b8 00 00 	subfeq	r8,0
8000c688:	1b 07       	ld.w	r7,sp++
8000c68a:	1b 0e       	ld.w	lr,sp++
8000c68c:	5e 0f       	reteq	1
8000c68e:	5e fc       	retal	r12

8000c690 <__avr32_f64_cmp_lt>:
8000c690:	1a de       	st.w	--sp,lr
8000c692:	1a d7       	st.w	--sp,r7
8000c694:	a1 7b       	lsl	r11,0x1
8000c696:	5f 3c       	srlo	r12
8000c698:	a1 79       	lsl	r9,0x1
8000c69a:	5f 37       	srlo	r7
8000c69c:	5c fc       	rol	r12
8000c69e:	fc 1e ff e0 	movh	lr,0xffe0
8000c6a2:	58 0a       	cp.w	r10,0
8000c6a4:	fc 0b 13 00 	cpc	r11,lr
8000c6a8:	e0 8b 00 1d 	brhi	8000c6e2 <__avr32_f64_cmp_lt+0x52>
8000c6ac:	58 08       	cp.w	r8,0
8000c6ae:	fc 09 13 00 	cpc	r9,lr
8000c6b2:	e0 8b 00 18 	brhi	8000c6e2 <__avr32_f64_cmp_lt+0x52>
8000c6b6:	58 0b       	cp.w	r11,0
8000c6b8:	f5 ba 00 00 	subfeq	r10,0
8000c6bc:	c1 50       	breq	8000c6e6 <__avr32_f64_cmp_lt+0x56>
8000c6be:	1b 07       	ld.w	r7,sp++
8000c6c0:	1b 0e       	ld.w	lr,sp++
8000c6c2:	58 3c       	cp.w	r12,3
8000c6c4:	c0 a0       	breq	8000c6d8 <__avr32_f64_cmp_lt+0x48>
8000c6c6:	58 1c       	cp.w	r12,1
8000c6c8:	c0 33       	brcs	8000c6ce <__avr32_f64_cmp_lt+0x3e>
8000c6ca:	5e 0d       	reteq	0
8000c6cc:	5e 1f       	retne	1
8000c6ce:	10 3a       	cp.w	r10,r8
8000c6d0:	f2 0b 13 00 	cpc	r11,r9
8000c6d4:	5e 2d       	reths	0
8000c6d6:	5e 3f       	retlo	1
8000c6d8:	14 38       	cp.w	r8,r10
8000c6da:	f6 09 13 00 	cpc	r9,r11
8000c6de:	5e 2d       	reths	0
8000c6e0:	5e 3f       	retlo	1
8000c6e2:	1b 07       	ld.w	r7,sp++
8000c6e4:	d8 0a       	popm	pc,r12=0
8000c6e6:	58 17       	cp.w	r7,1
8000c6e8:	5f 1c       	srne	r12
8000c6ea:	58 09       	cp.w	r9,0
8000c6ec:	f5 b8 00 00 	subfeq	r8,0
8000c6f0:	1b 07       	ld.w	r7,sp++
8000c6f2:	1b 0e       	ld.w	lr,sp++
8000c6f4:	5e 0d       	reteq	0
8000c6f6:	5e fc       	retal	r12

8000c6f8 <__avr32_f64_div>:
8000c6f8:	eb cd 40 ff 	pushm	r0-r7,lr
8000c6fc:	f7 e9 20 0e 	eor	lr,r11,r9
8000c700:	f6 07 16 14 	lsr	r7,r11,0x14
8000c704:	a9 7b       	lsl	r11,0x9
8000c706:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c70a:	a9 7a       	lsl	r10,0x9
8000c70c:	bd bb       	sbr	r11,0x1d
8000c70e:	e4 1b 3f ff 	andh	r11,0x3fff
8000c712:	ab d7       	cbr	r7,0xb
8000c714:	e0 80 00 cc 	breq	8000c8ac <__avr32_f64_div_round_subnormal+0x54>
8000c718:	e0 47 07 ff 	cp.w	r7,2047
8000c71c:	e0 84 00 b5 	brge	8000c886 <__avr32_f64_div_round_subnormal+0x2e>
8000c720:	f2 06 16 14 	lsr	r6,r9,0x14
8000c724:	a9 79       	lsl	r9,0x9
8000c726:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c72a:	a9 78       	lsl	r8,0x9
8000c72c:	bd b9       	sbr	r9,0x1d
8000c72e:	e4 19 3f ff 	andh	r9,0x3fff
8000c732:	ab d6       	cbr	r6,0xb
8000c734:	e0 80 00 e2 	breq	8000c8f8 <__avr32_f64_div_round_subnormal+0xa0>
8000c738:	e0 46 07 ff 	cp.w	r6,2047
8000c73c:	e0 84 00 b2 	brge	8000c8a0 <__avr32_f64_div_round_subnormal+0x48>
8000c740:	0c 17       	sub	r7,r6
8000c742:	fe 37 fc 01 	sub	r7,-1023
8000c746:	fc 1c 80 00 	movh	r12,0x8000
8000c74a:	f8 03 16 01 	lsr	r3,r12,0x1
8000c74e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c752:	5c d4       	com	r4
8000c754:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c758:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c75c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c760:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c764:	ea 03 15 02 	lsl	r3,r5,0x2
8000c768:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c76c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c770:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c774:	ea 03 15 02 	lsl	r3,r5,0x2
8000c778:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c77c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c780:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c784:	ea 03 15 02 	lsl	r3,r5,0x2
8000c788:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c78c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c790:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c794:	02 04       	add	r4,r1
8000c796:	5c 05       	acr	r5
8000c798:	a3 65       	lsl	r5,0x2
8000c79a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c79e:	a3 64       	lsl	r4,0x2
8000c7a0:	5c 34       	neg	r4
8000c7a2:	f8 05 01 45 	sbc	r5,r12,r5
8000c7a6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c7aa:	e4 05 07 40 	macu.d	r0,r2,r5
8000c7ae:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c7b2:	02 04       	add	r4,r1
8000c7b4:	5c 05       	acr	r5
8000c7b6:	ea 03 15 02 	lsl	r3,r5,0x2
8000c7ba:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c7be:	e8 02 15 02 	lsl	r2,r4,0x2
8000c7c2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c7c6:	e4 09 07 40 	macu.d	r0,r2,r9
8000c7ca:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c7ce:	02 04       	add	r4,r1
8000c7d0:	5c 05       	acr	r5
8000c7d2:	a3 65       	lsl	r5,0x2
8000c7d4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c7d8:	a3 64       	lsl	r4,0x2
8000c7da:	5c 34       	neg	r4
8000c7dc:	f8 05 01 45 	sbc	r5,r12,r5
8000c7e0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c7e4:	e4 05 07 40 	macu.d	r0,r2,r5
8000c7e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c7ec:	02 04       	add	r4,r1
8000c7ee:	5c 05       	acr	r5
8000c7f0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c7f4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c7f8:	e8 02 15 02 	lsl	r2,r4,0x2
8000c7fc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c800:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c804:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c808:	02 02       	add	r2,r1
8000c80a:	5c 03       	acr	r3
8000c80c:	ed b3 00 1c 	bld	r3,0x1c
8000c810:	c0 90       	breq	8000c822 <__avr32_f64_div+0x12a>
8000c812:	a1 72       	lsl	r2,0x1
8000c814:	5c f3       	rol	r3
8000c816:	20 17       	sub	r7,1
8000c818:	a3 9a       	lsr	r10,0x3
8000c81a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c81e:	a3 9b       	lsr	r11,0x3
8000c820:	c0 58       	rjmp	8000c82a <__avr32_f64_div+0x132>
8000c822:	a5 8a       	lsr	r10,0x4
8000c824:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c828:	a5 8b       	lsr	r11,0x4
8000c82a:	58 07       	cp.w	r7,0
8000c82c:	e0 8a 00 8b 	brle	8000c942 <__avr32_f64_div_res_subnormal>
8000c830:	e0 12 ff 00 	andl	r2,0xff00
8000c834:	e8 12 00 80 	orl	r2,0x80
8000c838:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c83c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c840:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c844:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c848:	00 05       	add	r5,r0
8000c84a:	f0 01 00 48 	adc	r8,r8,r1
8000c84e:	5c 09       	acr	r9
8000c850:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c854:	58 04       	cp.w	r4,0
8000c856:	5c 25       	cpc	r5

8000c858 <__avr32_f64_div_round_subnormal>:
8000c858:	f4 08 13 00 	cpc	r8,r10
8000c85c:	f6 09 13 00 	cpc	r9,r11
8000c860:	5f 36       	srlo	r6
8000c862:	f8 06 17 00 	moveq	r6,r12
8000c866:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c86a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c86e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c872:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c876:	ed be 00 1f 	bld	lr,0x1f
8000c87a:	ef bb 00 1f 	bst	r11,0x1f
8000c87e:	0c 0a       	add	r10,r6
8000c880:	5c 0b       	acr	r11
8000c882:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c886:	e4 1b 00 0f 	andh	r11,0xf
8000c88a:	14 4b       	or	r11,r10
8000c88c:	e0 81 00 a7 	brne	8000c9da <__avr32_f64_div_res_subnormal+0x98>
8000c890:	f2 06 16 14 	lsr	r6,r9,0x14
8000c894:	ab d6       	cbr	r6,0xb
8000c896:	e0 46 07 ff 	cp.w	r6,2047
8000c89a:	e0 81 00 a4 	brne	8000c9e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c89e:	c9 e8       	rjmp	8000c9da <__avr32_f64_div_res_subnormal+0x98>
8000c8a0:	e4 19 00 0f 	andh	r9,0xf
8000c8a4:	10 49       	or	r9,r8
8000c8a6:	e0 81 00 9a 	brne	8000c9da <__avr32_f64_div_res_subnormal+0x98>
8000c8aa:	c9 28       	rjmp	8000c9ce <__avr32_f64_div_res_subnormal+0x8c>
8000c8ac:	a3 7b       	lsl	r11,0x3
8000c8ae:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c8b2:	a3 7a       	lsl	r10,0x3
8000c8b4:	f5 eb 10 04 	or	r4,r10,r11
8000c8b8:	e0 80 00 a0 	breq	8000c9f8 <__avr32_f64_div_op1_zero>
8000c8bc:	f6 04 12 00 	clz	r4,r11
8000c8c0:	c1 70       	breq	8000c8ee <__avr32_f64_div_round_subnormal+0x96>
8000c8c2:	c0 c3       	brcs	8000c8da <__avr32_f64_div_round_subnormal+0x82>
8000c8c4:	e8 05 11 20 	rsub	r5,r4,32
8000c8c8:	f6 04 09 4b 	lsl	r11,r11,r4
8000c8cc:	f4 05 0a 45 	lsr	r5,r10,r5
8000c8d0:	0a 4b       	or	r11,r5
8000c8d2:	f4 04 09 4a 	lsl	r10,r10,r4
8000c8d6:	08 17       	sub	r7,r4
8000c8d8:	c0 b8       	rjmp	8000c8ee <__avr32_f64_div_round_subnormal+0x96>
8000c8da:	f4 04 12 00 	clz	r4,r10
8000c8de:	f9 b4 03 00 	movlo	r4,0
8000c8e2:	f7 b4 02 e0 	subhs	r4,-32
8000c8e6:	f4 04 09 4b 	lsl	r11,r10,r4
8000c8ea:	30 0a       	mov	r10,0
8000c8ec:	08 17       	sub	r7,r4
8000c8ee:	a3 8a       	lsr	r10,0x2
8000c8f0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c8f4:	a3 8b       	lsr	r11,0x2
8000c8f6:	c1 1b       	rjmp	8000c718 <__avr32_f64_div+0x20>
8000c8f8:	a3 79       	lsl	r9,0x3
8000c8fa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c8fe:	a3 78       	lsl	r8,0x3
8000c900:	f3 e8 10 04 	or	r4,r9,r8
8000c904:	c6 f0       	breq	8000c9e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c906:	f2 04 12 00 	clz	r4,r9
8000c90a:	c1 70       	breq	8000c938 <__avr32_f64_div_round_subnormal+0xe0>
8000c90c:	c0 c3       	brcs	8000c924 <__avr32_f64_div_round_subnormal+0xcc>
8000c90e:	e8 05 11 20 	rsub	r5,r4,32
8000c912:	f2 04 09 49 	lsl	r9,r9,r4
8000c916:	f0 05 0a 45 	lsr	r5,r8,r5
8000c91a:	0a 49       	or	r9,r5
8000c91c:	f0 04 09 48 	lsl	r8,r8,r4
8000c920:	08 16       	sub	r6,r4
8000c922:	c0 b8       	rjmp	8000c938 <__avr32_f64_div_round_subnormal+0xe0>
8000c924:	f0 04 12 00 	clz	r4,r8
8000c928:	f9 b4 03 00 	movlo	r4,0
8000c92c:	f7 b4 02 e0 	subhs	r4,-32
8000c930:	f0 04 09 49 	lsl	r9,r8,r4
8000c934:	30 08       	mov	r8,0
8000c936:	08 16       	sub	r6,r4
8000c938:	a3 88       	lsr	r8,0x2
8000c93a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c93e:	a3 89       	lsr	r9,0x2
8000c940:	cf ca       	rjmp	8000c738 <__avr32_f64_div+0x40>

8000c942 <__avr32_f64_div_res_subnormal>:
8000c942:	5c 37       	neg	r7
8000c944:	2f f7       	sub	r7,-1
8000c946:	f1 b7 04 c0 	satu	r7,0x6
8000c94a:	e0 47 00 20 	cp.w	r7,32
8000c94e:	c1 54       	brge	8000c978 <__avr32_f64_div_res_subnormal+0x36>
8000c950:	ee 06 11 20 	rsub	r6,r7,32
8000c954:	e4 07 0a 42 	lsr	r2,r2,r7
8000c958:	e6 06 09 4c 	lsl	r12,r3,r6
8000c95c:	18 42       	or	r2,r12
8000c95e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c962:	f4 06 09 41 	lsl	r1,r10,r6
8000c966:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c96a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c96e:	18 4a       	or	r10,r12
8000c970:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c974:	30 00       	mov	r0,0
8000c976:	c1 58       	rjmp	8000c9a0 <__avr32_f64_div_res_subnormal+0x5e>
8000c978:	ee 06 11 20 	rsub	r6,r7,32
8000c97c:	f9 b0 00 00 	moveq	r0,0
8000c980:	f9 bc 00 00 	moveq	r12,0
8000c984:	c0 50       	breq	8000c98e <__avr32_f64_div_res_subnormal+0x4c>
8000c986:	f4 06 09 40 	lsl	r0,r10,r6
8000c98a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c98e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c992:	30 03       	mov	r3,0
8000c994:	f4 07 0a 41 	lsr	r1,r10,r7
8000c998:	18 41       	or	r1,r12
8000c99a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c99e:	30 0b       	mov	r11,0
8000c9a0:	e0 12 ff 00 	andl	r2,0xff00
8000c9a4:	e8 12 00 80 	orl	r2,0x80
8000c9a8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c9ac:	e4 09 07 46 	macu.d	r6,r2,r9
8000c9b0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c9b4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c9b8:	0c 05       	add	r5,r6
8000c9ba:	f0 07 00 48 	adc	r8,r8,r7
8000c9be:	5c 09       	acr	r9
8000c9c0:	30 07       	mov	r7,0
8000c9c2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c9c6:	00 34       	cp.w	r4,r0
8000c9c8:	e2 05 13 00 	cpc	r5,r1
8000c9cc:	c4 6b       	rjmp	8000c858 <__avr32_f64_div_round_subnormal>
8000c9ce:	1c 9b       	mov	r11,lr
8000c9d0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c9d4:	30 0a       	mov	r10,0
8000c9d6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c9da:	3f fb       	mov	r11,-1
8000c9dc:	30 0a       	mov	r10,0
8000c9de:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c9e2:	f5 eb 10 04 	or	r4,r10,r11
8000c9e6:	c0 90       	breq	8000c9f8 <__avr32_f64_div_op1_zero>
8000c9e8:	1c 9b       	mov	r11,lr
8000c9ea:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c9ee:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c9f2:	30 0a       	mov	r10,0
8000c9f4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c9f8 <__avr32_f64_div_op1_zero>:
8000c9f8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c9fc:	ce f0       	breq	8000c9da <__avr32_f64_div_res_subnormal+0x98>
8000c9fe:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000ca02:	e0 44 07 ff 	cp.w	r4,2047
8000ca06:	ce 41       	brne	8000c9ce <__avr32_f64_div_res_subnormal+0x8c>
8000ca08:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000ca0c:	ce 10       	breq	8000c9ce <__avr32_f64_div_res_subnormal+0x8c>
8000ca0e:	ce 6b       	rjmp	8000c9da <__avr32_f64_div_res_subnormal+0x98>

8000ca10 <__avr32_udiv64>:
8000ca10:	d4 31       	pushm	r0-r7,lr
8000ca12:	1a 97       	mov	r7,sp
8000ca14:	20 3d       	sub	sp,12
8000ca16:	10 9c       	mov	r12,r8
8000ca18:	12 9e       	mov	lr,r9
8000ca1a:	14 93       	mov	r3,r10
8000ca1c:	58 09       	cp.w	r9,0
8000ca1e:	e0 81 00 bd 	brne	8000cb98 <__avr32_udiv64+0x188>
8000ca22:	16 38       	cp.w	r8,r11
8000ca24:	e0 88 00 40 	brls	8000caa4 <__avr32_udiv64+0x94>
8000ca28:	f0 08 12 00 	clz	r8,r8
8000ca2c:	c0 d0       	breq	8000ca46 <__avr32_udiv64+0x36>
8000ca2e:	f6 08 09 4b 	lsl	r11,r11,r8
8000ca32:	f0 09 11 20 	rsub	r9,r8,32
8000ca36:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca3a:	f4 09 0a 49 	lsr	r9,r10,r9
8000ca3e:	f4 08 09 43 	lsl	r3,r10,r8
8000ca42:	f3 eb 10 0b 	or	r11,r9,r11
8000ca46:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ca4a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000ca4e:	f6 0e 0d 00 	divu	r0,r11,lr
8000ca52:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca56:	00 99       	mov	r9,r0
8000ca58:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca5c:	e0 0a 02 48 	mul	r8,r0,r10
8000ca60:	10 3b       	cp.w	r11,r8
8000ca62:	c0 a2       	brcc	8000ca76 <__avr32_udiv64+0x66>
8000ca64:	20 19       	sub	r9,1
8000ca66:	18 0b       	add	r11,r12
8000ca68:	18 3b       	cp.w	r11,r12
8000ca6a:	c0 63       	brcs	8000ca76 <__avr32_udiv64+0x66>
8000ca6c:	10 3b       	cp.w	r11,r8
8000ca6e:	f7 b9 03 01 	sublo	r9,1
8000ca72:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca76:	f6 08 01 01 	sub	r1,r11,r8
8000ca7a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca7e:	e2 0e 0d 00 	divu	r0,r1,lr
8000ca82:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca86:	00 98       	mov	r8,r0
8000ca88:	e0 0a 02 4a 	mul	r10,r0,r10
8000ca8c:	14 33       	cp.w	r3,r10
8000ca8e:	c0 82       	brcc	8000ca9e <__avr32_udiv64+0x8e>
8000ca90:	20 18       	sub	r8,1
8000ca92:	18 03       	add	r3,r12
8000ca94:	18 33       	cp.w	r3,r12
8000ca96:	c0 43       	brcs	8000ca9e <__avr32_udiv64+0x8e>
8000ca98:	14 33       	cp.w	r3,r10
8000ca9a:	f7 b8 03 01 	sublo	r8,1
8000ca9e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000caa2:	cd f8       	rjmp	8000cc60 <__avr32_udiv64+0x250>
8000caa4:	58 08       	cp.w	r8,0
8000caa6:	c0 51       	brne	8000cab0 <__avr32_udiv64+0xa0>
8000caa8:	30 19       	mov	r9,1
8000caaa:	f2 08 0d 08 	divu	r8,r9,r8
8000caae:	10 9c       	mov	r12,r8
8000cab0:	f8 06 12 00 	clz	r6,r12
8000cab4:	c0 41       	brne	8000cabc <__avr32_udiv64+0xac>
8000cab6:	18 1b       	sub	r11,r12
8000cab8:	30 19       	mov	r9,1
8000caba:	c4 08       	rjmp	8000cb3a <__avr32_udiv64+0x12a>
8000cabc:	ec 01 11 20 	rsub	r1,r6,32
8000cac0:	f4 01 0a 49 	lsr	r9,r10,r1
8000cac4:	f8 06 09 4c 	lsl	r12,r12,r6
8000cac8:	f6 06 09 48 	lsl	r8,r11,r6
8000cacc:	f6 01 0a 41 	lsr	r1,r11,r1
8000cad0:	f3 e8 10 08 	or	r8,r9,r8
8000cad4:	f8 03 16 10 	lsr	r3,r12,0x10
8000cad8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cadc:	e2 03 0d 00 	divu	r0,r1,r3
8000cae0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cae4:	00 9e       	mov	lr,r0
8000cae6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000caea:	e0 05 02 49 	mul	r9,r0,r5
8000caee:	12 3b       	cp.w	r11,r9
8000caf0:	c0 a2       	brcc	8000cb04 <__avr32_udiv64+0xf4>
8000caf2:	20 1e       	sub	lr,1
8000caf4:	18 0b       	add	r11,r12
8000caf6:	18 3b       	cp.w	r11,r12
8000caf8:	c0 63       	brcs	8000cb04 <__avr32_udiv64+0xf4>
8000cafa:	12 3b       	cp.w	r11,r9
8000cafc:	f7 be 03 01 	sublo	lr,1
8000cb00:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb04:	12 1b       	sub	r11,r9
8000cb06:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000cb0a:	f6 03 0d 02 	divu	r2,r11,r3
8000cb0e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000cb12:	04 99       	mov	r9,r2
8000cb14:	e4 05 02 4b 	mul	r11,r2,r5
8000cb18:	16 38       	cp.w	r8,r11
8000cb1a:	c0 a2       	brcc	8000cb2e <__avr32_udiv64+0x11e>
8000cb1c:	20 19       	sub	r9,1
8000cb1e:	18 08       	add	r8,r12
8000cb20:	18 38       	cp.w	r8,r12
8000cb22:	c0 63       	brcs	8000cb2e <__avr32_udiv64+0x11e>
8000cb24:	16 38       	cp.w	r8,r11
8000cb26:	f7 b9 03 01 	sublo	r9,1
8000cb2a:	f1 dc e3 08 	addcs	r8,r8,r12
8000cb2e:	f4 06 09 43 	lsl	r3,r10,r6
8000cb32:	f0 0b 01 0b 	sub	r11,r8,r11
8000cb36:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000cb3a:	f8 06 16 10 	lsr	r6,r12,0x10
8000cb3e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000cb42:	f6 06 0d 00 	divu	r0,r11,r6
8000cb46:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cb4a:	00 9a       	mov	r10,r0
8000cb4c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb50:	e0 0e 02 48 	mul	r8,r0,lr
8000cb54:	10 3b       	cp.w	r11,r8
8000cb56:	c0 a2       	brcc	8000cb6a <__avr32_udiv64+0x15a>
8000cb58:	20 1a       	sub	r10,1
8000cb5a:	18 0b       	add	r11,r12
8000cb5c:	18 3b       	cp.w	r11,r12
8000cb5e:	c0 63       	brcs	8000cb6a <__avr32_udiv64+0x15a>
8000cb60:	10 3b       	cp.w	r11,r8
8000cb62:	f7 ba 03 01 	sublo	r10,1
8000cb66:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb6a:	f6 08 01 01 	sub	r1,r11,r8
8000cb6e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cb72:	e2 06 0d 00 	divu	r0,r1,r6
8000cb76:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cb7a:	00 98       	mov	r8,r0
8000cb7c:	e0 0e 02 4b 	mul	r11,r0,lr
8000cb80:	16 33       	cp.w	r3,r11
8000cb82:	c0 82       	brcc	8000cb92 <__avr32_udiv64+0x182>
8000cb84:	20 18       	sub	r8,1
8000cb86:	18 03       	add	r3,r12
8000cb88:	18 33       	cp.w	r3,r12
8000cb8a:	c0 43       	brcs	8000cb92 <__avr32_udiv64+0x182>
8000cb8c:	16 33       	cp.w	r3,r11
8000cb8e:	f7 b8 03 01 	sublo	r8,1
8000cb92:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000cb96:	c6 98       	rjmp	8000cc68 <__avr32_udiv64+0x258>
8000cb98:	16 39       	cp.w	r9,r11
8000cb9a:	e0 8b 00 65 	brhi	8000cc64 <__avr32_udiv64+0x254>
8000cb9e:	f2 09 12 00 	clz	r9,r9
8000cba2:	c0 b1       	brne	8000cbb8 <__avr32_udiv64+0x1a8>
8000cba4:	10 3a       	cp.w	r10,r8
8000cba6:	5f 2a       	srhs	r10
8000cba8:	1c 3b       	cp.w	r11,lr
8000cbaa:	5f b8       	srhi	r8
8000cbac:	10 4a       	or	r10,r8
8000cbae:	f2 0a 18 00 	cp.b	r10,r9
8000cbb2:	c5 90       	breq	8000cc64 <__avr32_udiv64+0x254>
8000cbb4:	30 18       	mov	r8,1
8000cbb6:	c5 98       	rjmp	8000cc68 <__avr32_udiv64+0x258>
8000cbb8:	f0 09 09 46 	lsl	r6,r8,r9
8000cbbc:	f2 03 11 20 	rsub	r3,r9,32
8000cbc0:	fc 09 09 4e 	lsl	lr,lr,r9
8000cbc4:	f0 03 0a 48 	lsr	r8,r8,r3
8000cbc8:	f6 09 09 4c 	lsl	r12,r11,r9
8000cbcc:	f4 03 0a 42 	lsr	r2,r10,r3
8000cbd0:	ef 46 ff f4 	st.w	r7[-12],r6
8000cbd4:	f6 03 0a 43 	lsr	r3,r11,r3
8000cbd8:	18 42       	or	r2,r12
8000cbda:	f1 ee 10 0c 	or	r12,r8,lr
8000cbde:	f8 01 16 10 	lsr	r1,r12,0x10
8000cbe2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cbe6:	e6 01 0d 04 	divu	r4,r3,r1
8000cbea:	e4 03 16 10 	lsr	r3,r2,0x10
8000cbee:	08 9e       	mov	lr,r4
8000cbf0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cbf4:	e8 06 02 48 	mul	r8,r4,r6
8000cbf8:	10 33       	cp.w	r3,r8
8000cbfa:	c0 a2       	brcc	8000cc0e <__avr32_udiv64+0x1fe>
8000cbfc:	20 1e       	sub	lr,1
8000cbfe:	18 03       	add	r3,r12
8000cc00:	18 33       	cp.w	r3,r12
8000cc02:	c0 63       	brcs	8000cc0e <__avr32_udiv64+0x1fe>
8000cc04:	10 33       	cp.w	r3,r8
8000cc06:	f7 be 03 01 	sublo	lr,1
8000cc0a:	e7 dc e3 03 	addcs	r3,r3,r12
8000cc0e:	10 13       	sub	r3,r8
8000cc10:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cc14:	e6 01 0d 00 	divu	r0,r3,r1
8000cc18:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cc1c:	00 98       	mov	r8,r0
8000cc1e:	e0 06 02 46 	mul	r6,r0,r6
8000cc22:	0c 3b       	cp.w	r11,r6
8000cc24:	c0 a2       	brcc	8000cc38 <__avr32_udiv64+0x228>
8000cc26:	20 18       	sub	r8,1
8000cc28:	18 0b       	add	r11,r12
8000cc2a:	18 3b       	cp.w	r11,r12
8000cc2c:	c0 63       	brcs	8000cc38 <__avr32_udiv64+0x228>
8000cc2e:	0c 3b       	cp.w	r11,r6
8000cc30:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cc34:	f7 b8 03 01 	sublo	r8,1
8000cc38:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cc3c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cc40:	0c 1b       	sub	r11,r6
8000cc42:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cc46:	06 95       	mov	r5,r3
8000cc48:	16 35       	cp.w	r5,r11
8000cc4a:	e0 8b 00 0a 	brhi	8000cc5e <__avr32_udiv64+0x24e>
8000cc4e:	5f 0b       	sreq	r11
8000cc50:	f4 09 09 49 	lsl	r9,r10,r9
8000cc54:	12 32       	cp.w	r2,r9
8000cc56:	5f b9       	srhi	r9
8000cc58:	f7 e9 00 09 	and	r9,r11,r9
8000cc5c:	c0 60       	breq	8000cc68 <__avr32_udiv64+0x258>
8000cc5e:	20 18       	sub	r8,1
8000cc60:	30 09       	mov	r9,0
8000cc62:	c0 38       	rjmp	8000cc68 <__avr32_udiv64+0x258>
8000cc64:	30 09       	mov	r9,0
8000cc66:	12 98       	mov	r8,r9
8000cc68:	10 9a       	mov	r10,r8
8000cc6a:	12 93       	mov	r3,r9
8000cc6c:	10 92       	mov	r2,r8
8000cc6e:	12 9b       	mov	r11,r9
8000cc70:	2f dd       	sub	sp,-12
8000cc72:	d8 32       	popm	r0-r7,pc

8000cc74 <__avr32_umod64>:
8000cc74:	d4 31       	pushm	r0-r7,lr
8000cc76:	1a 97       	mov	r7,sp
8000cc78:	20 3d       	sub	sp,12
8000cc7a:	10 9c       	mov	r12,r8
8000cc7c:	12 95       	mov	r5,r9
8000cc7e:	14 9e       	mov	lr,r10
8000cc80:	16 91       	mov	r1,r11
8000cc82:	16 96       	mov	r6,r11
8000cc84:	58 09       	cp.w	r9,0
8000cc86:	e0 81 00 81 	brne	8000cd88 <__avr32_umod64+0x114>
8000cc8a:	16 38       	cp.w	r8,r11
8000cc8c:	e0 88 00 12 	brls	8000ccb0 <__avr32_umod64+0x3c>
8000cc90:	f0 08 12 00 	clz	r8,r8
8000cc94:	c4 e0       	breq	8000cd30 <__avr32_umod64+0xbc>
8000cc96:	f6 08 09 46 	lsl	r6,r11,r8
8000cc9a:	f8 08 09 4c 	lsl	r12,r12,r8
8000cc9e:	f0 0b 11 20 	rsub	r11,r8,32
8000cca2:	f4 08 09 4e 	lsl	lr,r10,r8
8000cca6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ccaa:	f7 e6 10 06 	or	r6,r11,r6
8000ccae:	c4 18       	rjmp	8000cd30 <__avr32_umod64+0xbc>
8000ccb0:	58 08       	cp.w	r8,0
8000ccb2:	c0 51       	brne	8000ccbc <__avr32_umod64+0x48>
8000ccb4:	30 19       	mov	r9,1
8000ccb6:	f2 08 0d 08 	divu	r8,r9,r8
8000ccba:	10 9c       	mov	r12,r8
8000ccbc:	f8 08 12 00 	clz	r8,r12
8000ccc0:	c0 31       	brne	8000ccc6 <__avr32_umod64+0x52>
8000ccc2:	18 16       	sub	r6,r12
8000ccc4:	c3 68       	rjmp	8000cd30 <__avr32_umod64+0xbc>
8000ccc6:	f0 03 11 20 	rsub	r3,r8,32
8000ccca:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ccce:	f8 08 09 4c 	lsl	r12,r12,r8
8000ccd2:	ec 08 09 49 	lsl	r9,r6,r8
8000ccd6:	ec 03 0a 43 	lsr	r3,r6,r3
8000ccda:	f7 e9 10 09 	or	r9,r11,r9
8000ccde:	f8 05 16 10 	lsr	r5,r12,0x10
8000cce2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cce6:	e6 05 0d 02 	divu	r2,r3,r5
8000ccea:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ccee:	ec 02 02 4b 	mul	r11,r6,r2
8000ccf2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ccf6:	16 3e       	cp.w	lr,r11
8000ccf8:	c0 72       	brcc	8000cd06 <__avr32_umod64+0x92>
8000ccfa:	18 0e       	add	lr,r12
8000ccfc:	18 3e       	cp.w	lr,r12
8000ccfe:	c0 43       	brcs	8000cd06 <__avr32_umod64+0x92>
8000cd00:	16 3e       	cp.w	lr,r11
8000cd02:	fd dc e3 0e 	addcs	lr,lr,r12
8000cd06:	fc 0b 01 03 	sub	r3,lr,r11
8000cd0a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cd0e:	e6 05 0d 02 	divu	r2,r3,r5
8000cd12:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cd16:	a5 36       	mul	r6,r2
8000cd18:	0c 39       	cp.w	r9,r6
8000cd1a:	c0 72       	brcc	8000cd28 <__avr32_umod64+0xb4>
8000cd1c:	18 09       	add	r9,r12
8000cd1e:	18 39       	cp.w	r9,r12
8000cd20:	c0 43       	brcs	8000cd28 <__avr32_umod64+0xb4>
8000cd22:	0c 39       	cp.w	r9,r6
8000cd24:	f3 dc e3 09 	addcs	r9,r9,r12
8000cd28:	f2 06 01 06 	sub	r6,r9,r6
8000cd2c:	f4 08 09 4e 	lsl	lr,r10,r8
8000cd30:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cd34:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cd38:	ec 0a 0d 02 	divu	r2,r6,r10
8000cd3c:	fc 09 16 10 	lsr	r9,lr,0x10
8000cd40:	ea 02 02 4b 	mul	r11,r5,r2
8000cd44:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cd48:	16 39       	cp.w	r9,r11
8000cd4a:	c0 72       	brcc	8000cd58 <__avr32_umod64+0xe4>
8000cd4c:	18 09       	add	r9,r12
8000cd4e:	18 39       	cp.w	r9,r12
8000cd50:	c0 43       	brcs	8000cd58 <__avr32_umod64+0xe4>
8000cd52:	16 39       	cp.w	r9,r11
8000cd54:	f3 dc e3 09 	addcs	r9,r9,r12
8000cd58:	f2 0b 01 0b 	sub	r11,r9,r11
8000cd5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cd60:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cd64:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cd68:	ea 0a 02 4a 	mul	r10,r5,r10
8000cd6c:	14 3e       	cp.w	lr,r10
8000cd6e:	c0 72       	brcc	8000cd7c <__avr32_umod64+0x108>
8000cd70:	18 0e       	add	lr,r12
8000cd72:	18 3e       	cp.w	lr,r12
8000cd74:	c0 43       	brcs	8000cd7c <__avr32_umod64+0x108>
8000cd76:	14 3e       	cp.w	lr,r10
8000cd78:	fd dc e3 0e 	addcs	lr,lr,r12
8000cd7c:	fc 0a 01 0a 	sub	r10,lr,r10
8000cd80:	30 0b       	mov	r11,0
8000cd82:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cd86:	c7 b8       	rjmp	8000ce7c <__avr32_umod64+0x208>
8000cd88:	16 39       	cp.w	r9,r11
8000cd8a:	e0 8b 00 79 	brhi	8000ce7c <__avr32_umod64+0x208>
8000cd8e:	f2 09 12 00 	clz	r9,r9
8000cd92:	c1 21       	brne	8000cdb6 <__avr32_umod64+0x142>
8000cd94:	10 3a       	cp.w	r10,r8
8000cd96:	5f 2b       	srhs	r11
8000cd98:	0a 31       	cp.w	r1,r5
8000cd9a:	5f ba       	srhi	r10
8000cd9c:	f7 ea 10 0a 	or	r10,r11,r10
8000cda0:	f2 0a 18 00 	cp.b	r10,r9
8000cda4:	c0 60       	breq	8000cdb0 <__avr32_umod64+0x13c>
8000cda6:	fc 08 01 0c 	sub	r12,lr,r8
8000cdaa:	e2 05 01 46 	sbc	r6,r1,r5
8000cdae:	18 9e       	mov	lr,r12
8000cdb0:	0c 9b       	mov	r11,r6
8000cdb2:	1c 9a       	mov	r10,lr
8000cdb4:	c6 48       	rjmp	8000ce7c <__avr32_umod64+0x208>
8000cdb6:	ea 09 09 4c 	lsl	r12,r5,r9
8000cdba:	f2 06 11 20 	rsub	r6,r9,32
8000cdbe:	f6 09 09 4b 	lsl	r11,r11,r9
8000cdc2:	f0 09 09 42 	lsl	r2,r8,r9
8000cdc6:	ef 46 ff f4 	st.w	r7[-12],r6
8000cdca:	f0 06 0a 48 	lsr	r8,r8,r6
8000cdce:	18 48       	or	r8,r12
8000cdd0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cdd4:	f4 09 09 43 	lsl	r3,r10,r9
8000cdd8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cddc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cde0:	16 4a       	or	r10,r11
8000cde2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cde6:	f8 0b 0d 04 	divu	r4,r12,r11
8000cdea:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cdee:	08 91       	mov	r1,r4
8000cdf0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cdf4:	e8 0e 02 46 	mul	r6,r4,lr
8000cdf8:	0c 3c       	cp.w	r12,r6
8000cdfa:	c0 a2       	brcc	8000ce0e <__avr32_umod64+0x19a>
8000cdfc:	20 11       	sub	r1,1
8000cdfe:	10 0c       	add	r12,r8
8000ce00:	10 3c       	cp.w	r12,r8
8000ce02:	c0 63       	brcs	8000ce0e <__avr32_umod64+0x19a>
8000ce04:	0c 3c       	cp.w	r12,r6
8000ce06:	f7 b1 03 01 	sublo	r1,1
8000ce0a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ce0e:	0c 1c       	sub	r12,r6
8000ce10:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ce14:	f8 0b 0d 04 	divu	r4,r12,r11
8000ce18:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ce1c:	08 96       	mov	r6,r4
8000ce1e:	e8 0e 02 4e 	mul	lr,r4,lr
8000ce22:	1c 3b       	cp.w	r11,lr
8000ce24:	c0 a2       	brcc	8000ce38 <__avr32_umod64+0x1c4>
8000ce26:	20 16       	sub	r6,1
8000ce28:	10 0b       	add	r11,r8
8000ce2a:	10 3b       	cp.w	r11,r8
8000ce2c:	c0 63       	brcs	8000ce38 <__avr32_umod64+0x1c4>
8000ce2e:	1c 3b       	cp.w	r11,lr
8000ce30:	f7 b6 03 01 	sublo	r6,1
8000ce34:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ce38:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ce3c:	1c 1b       	sub	r11,lr
8000ce3e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ce42:	00 9e       	mov	lr,r0
8000ce44:	02 9c       	mov	r12,r1
8000ce46:	16 3c       	cp.w	r12,r11
8000ce48:	e0 8b 00 08 	brhi	8000ce58 <__avr32_umod64+0x1e4>
8000ce4c:	5f 06       	sreq	r6
8000ce4e:	06 30       	cp.w	r0,r3
8000ce50:	5f ba       	srhi	r10
8000ce52:	ed ea 00 0a 	and	r10,r6,r10
8000ce56:	c0 60       	breq	8000ce62 <__avr32_umod64+0x1ee>
8000ce58:	fc 02 01 04 	sub	r4,lr,r2
8000ce5c:	f8 08 01 4c 	sbc	r12,r12,r8
8000ce60:	08 9e       	mov	lr,r4
8000ce62:	e6 0e 01 0a 	sub	r10,r3,lr
8000ce66:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ce6a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ce6e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ce72:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ce76:	f8 01 09 4c 	lsl	r12,r12,r1
8000ce7a:	18 4a       	or	r10,r12
8000ce7c:	2f dd       	sub	sp,-12
8000ce7e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d000:	c0 08       	rjmp	8000d000 <_evba>
	...

8000d004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d004:	c0 08       	rjmp	8000d004 <_handle_TLB_Multiple_Hit>
	...

8000d008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d008:	c0 08       	rjmp	8000d008 <_handle_Bus_Error_Data_Fetch>
	...

8000d00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d00c:	c0 08       	rjmp	8000d00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d010:	c0 08       	rjmp	8000d010 <_handle_NMI>
	...

8000d014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d014:	c0 08       	rjmp	8000d014 <_handle_Instruction_Address>
	...

8000d018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d018:	c0 08       	rjmp	8000d018 <_handle_ITLB_Protection>
	...

8000d01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d01c:	c0 08       	rjmp	8000d01c <_handle_Breakpoint>
	...

8000d020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d020:	c0 08       	rjmp	8000d020 <_handle_Illegal_Opcode>
	...

8000d024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d024:	c0 08       	rjmp	8000d024 <_handle_Unimplemented_Instruction>
	...

8000d028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d028:	c0 08       	rjmp	8000d028 <_handle_Privilege_Violation>
	...

8000d02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d02c:	c0 08       	rjmp	8000d02c <_handle_Floating_Point>
	...

8000d030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d030:	c0 08       	rjmp	8000d030 <_handle_Coprocessor_Absent>
	...

8000d034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d034:	c0 08       	rjmp	8000d034 <_handle_Data_Address_Read>
	...

8000d038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d038:	c0 08       	rjmp	8000d038 <_handle_Data_Address_Write>
	...

8000d03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d03c:	c0 08       	rjmp	8000d03c <_handle_DTLB_Protection_Read>
	...

8000d040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d040:	c0 08       	rjmp	8000d040 <_handle_DTLB_Protection_Write>
	...

8000d044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d044:	c0 08       	rjmp	8000d044 <_handle_DTLB_Modified>
	...

8000d050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d050:	c0 08       	rjmp	8000d050 <_handle_ITLB_Miss>
	...

8000d060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d060:	c0 08       	rjmp	8000d060 <_handle_DTLB_Miss_Read>
	...

8000d070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d070:	c0 08       	rjmp	8000d070 <_handle_DTLB_Miss_Write>
	...

8000d100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d100:	fe cf 70 e8 	sub	pc,pc,28904

8000d104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d104:	30 0c       	mov	r12,0
8000d106:	fe b0 c4 4f 	rcall	800059a4 <_get_interrupt_handler>
8000d10a:	58 0c       	cp.w	r12,0
8000d10c:	f8 0f 17 10 	movne	pc,r12
8000d110:	d6 03       	rete

8000d112 <_int1>:
8000d112:	30 1c       	mov	r12,1
8000d114:	fe b0 c4 48 	rcall	800059a4 <_get_interrupt_handler>
8000d118:	58 0c       	cp.w	r12,0
8000d11a:	f8 0f 17 10 	movne	pc,r12
8000d11e:	d6 03       	rete

8000d120 <_int2>:
8000d120:	30 2c       	mov	r12,2
8000d122:	fe b0 c4 41 	rcall	800059a4 <_get_interrupt_handler>
8000d126:	58 0c       	cp.w	r12,0
8000d128:	f8 0f 17 10 	movne	pc,r12
8000d12c:	d6 03       	rete

8000d12e <_int3>:
8000d12e:	30 3c       	mov	r12,3
8000d130:	fe b0 c4 3a 	rcall	800059a4 <_get_interrupt_handler>
8000d134:	58 0c       	cp.w	r12,0
8000d136:	f8 0f 17 10 	movne	pc,r12
8000d13a:	d6 03       	rete

8000d13c <ipr_val>:
8000d13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1fc:	d7 03 d7 03                                         ....
