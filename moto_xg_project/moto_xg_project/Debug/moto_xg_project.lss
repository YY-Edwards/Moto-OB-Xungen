
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ad1c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b0  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2b0  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000b5c0  00000a40  8000ecec  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003666  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c678  00000000  00000000  00013f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000072ac  00000000  00000000  000405d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d45a  00000000  00000000  00047882  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d28  00000000  00000000  00054cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00008006  00000000  00000000  00058a04  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f3c9  00000000  00000000  00060a0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006fdd8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 44 	sub	pc,pc,-15548

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 24       	st.w	r11[0x8],r4
80002040:	00 00       	add	r0,r0
80002042:	0d a0       	ld.ub	r0,r6[0x2]

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 6c       	and	r12,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	d0 00       	acall	0x0
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	70 18       	ld.w	r8,r8[0x4]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 4b       	or	r11,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	d0 04       	*unknown*
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	70 18       	ld.w	r8,r8[0x4]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 4a       	or	r10,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	d0 10       	acall	0x1
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	70 18       	ld.w	r8,r8[0x4]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	d0 30       	acall	0x3
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	70 18       	ld.w	r8,r8[0x4]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	d0 4c       	*unknown*
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	70 18       	ld.w	r8,r8[0x4]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	d0 68       	*unknown*
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	70 18       	ld.w	r8,r8[0x4]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	d0 80       	acall	0x8
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	70 18       	ld.w	r8,r8[0x4]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	d0 98       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	d0 ac       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	d0 c4       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	d0 e0       	acall	0xe

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	d0 f8       	*unknown*
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	70 18       	ld.w	r8,r8[0x4]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	d1 0c       	*unknown*
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	d1 1c       	*unknown*

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 30       	acall	0x13
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	70 18       	ld.w	r8,r8[0x4]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d1 50       	acall	0x15
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	d1 64       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d1 7c       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d1 9c       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d1 c4       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d1 ec       	*unknown*
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d2 10       	acall	0x21
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d2 38       	*unknown*

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 5c       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	70 18       	ld.w	r8,r8[0x4]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d1 50       	acall	0x15
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d2 74       	*unknown*

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d2 90       	acall	0x29
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	70 18       	ld.w	r8,r8[0x4]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 41       	or	r1,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	d2 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	70 18       	ld.w	r8,r8[0x4]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	d2 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c8       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	70 18       	ld.w	r8,r8[0x4]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 d8       	*unknown*
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 e8       	*unknown*
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d2 f8       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	d3 04       	*unknown*

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	d3 10       	acall	0x31
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	70 18       	ld.w	r8,r8[0x4]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 4c       	or	r12,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d3 28       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	70 18       	ld.w	r8,r8[0x4]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 49       	or	r9,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d3 40       	acall	0x34

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 54       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	70 18       	ld.w	r8,r8[0x4]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 70       	acall	0x37
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	d3 a0       	acall	0x3a
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d3 b0       	acall	0x3b

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c8       	*unknown*
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	70 18       	ld.w	r8,r8[0x4]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d3 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 ec       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	70 18       	ld.w	r8,r8[0x4]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 00       	acall	0x40
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d4 1c       	*unknown*
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d4 34       	*unknown*

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 40       	or	r0,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 4c       	*unknown*
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	70 18       	ld.w	r8,r8[0x4]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d4 5c       	*unknown*

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 40       	or	r0,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 68       	*unknown*
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	70 18       	ld.w	r8,r8[0x4]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d4 78       	*unknown*

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	d4 84       	*unknown*
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	70 18       	ld.w	r8,r8[0x4]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 5d       	eor	sp,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	d4 98       	*unknown*
800025d4:	00 00       	add	r0,r0
800025d6:	0a 4c       	or	r12,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	70 18       	ld.w	r8,r8[0x4]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 d0       	acall	0x4d
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d4 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 00       	acall	0x50
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 18       	*unknown*
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d5 30       	acall	0x53
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d5 48       	*unknown*

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 58       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	70 18       	ld.w	r8,r8[0x4]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 6c       	*unknown*
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d5 80       	acall	0x58
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	d5 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	70 18       	ld.w	r8,r8[0x4]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 c8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 dc       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d5 f0       	acall	0x5f
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d5 fc       	*unknown*

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d6 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	70 18       	ld.w	r8,r8[0x4]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d6 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3f 54       	mov	r4,-11
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2b fc       	sub	r12,-65
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	64 e0       	ld.w	r0,r2[0x38]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 60       	and	r0,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d6 20       	acall	0x62
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	70 18       	ld.w	r8,r8[0x4]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d6 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6c 54       	ld.w	r4,r6[0x14]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 50       	eor	r0,r5

800027bc <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 ac       	mov	r12,26
800027c2:	f0 1f 00 60 	mcall	80002940 <app_cfg+0x184>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 60 	mcall	80002944 <app_cfg+0x188>
800027ca:	4e 08       	lddpc	r8,80002948 <app_cfg+0x18c>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027ce:	4e 08       	lddpc	r8,8000294c <app_cfg+0x190>
800027d0:	70 0c       	ld.w	r12,r8[0x0]
800027d2:	30 09       	mov	r9,0
800027d4:	3f fa       	mov	r10,-1
800027d6:	12 9b       	mov	r11,r9
800027d8:	f0 1f 00 5e 	mcall	80002950 <app_cfg+0x194>
		
	for(;;)
	{
		switch(OB_State)
800027dc:	4d e7       	lddpc	r7,80002954 <app_cfg+0x198>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027de:	4d f6       	lddpc	r6,80002958 <app_cfg+0x19c>
				else
				{
					nop();
					nop();
					nop();
					log("connecting...\n");
800027e0:	4d f5       	lddpc	r5,8000295c <app_cfg+0x1a0>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e2:	4e 03       	lddpc	r3,80002960 <app_cfg+0x1a4>
				{
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027e4:	30 c0       	mov	r0,12
800027e6:	30 11       	mov	r1,1
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027e8:	6e 08       	ld.w	r8,r7[0x0]
800027ea:	58 08       	cp.w	r8,0
800027ec:	c0 50       	breq	800027f6 <app_cfg+0x3a>
800027ee:	58 38       	cp.w	r8,3
800027f0:	e0 81 00 a1 	brne	80002932 <app_cfg+0x176>
800027f4:	c2 d8       	rjmp	8000284e <app_cfg+0x92>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f6:	6c 08       	ld.w	r8,r6[0x0]
800027f8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027fc:	58 38       	cp.w	r8,3
800027fe:	c2 11       	brne	80002840 <app_cfg+0x84>
80002800:	07 88       	ld.ub	r8,r3[0x0]
80002802:	58 08       	cp.w	r8,0
80002804:	c1 e1       	brne	80002840 <app_cfg+0x84>
				{
					connect_flag=1;
80002806:	30 18       	mov	r8,1
80002808:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000280a:	00 9b       	mov	r11,r0
8000280c:	02 9c       	mov	r12,r1
8000280e:	f0 1f 00 56 	mcall	80002964 <app_cfg+0x1a8>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002812:	00 9b       	mov	r11,r0
80002814:	02 9c       	mov	r12,r1
80002816:	f0 1f 00 54 	mcall	80002964 <app_cfg+0x1a8>
					OB_State = OB_WAITINGAPPTASK;
8000281a:	30 38       	mov	r8,3
8000281c:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
8000281e:	4d 3c       	lddpc	r12,80002968 <app_cfg+0x1ac>
80002820:	f0 1f 00 53 	mcall	8000296c <app_cfg+0x1b0>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002824:	4d 38       	lddpc	r8,80002970 <app_cfg+0x1b4>
80002826:	11 bb       	ld.ub	r11,r8[0x3]
80002828:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
8000282a:	11 99       	ld.ub	r9,r8[0x1]
8000282c:	11 88       	ld.ub	r8,r8[0x0]
8000282e:	1a db       	st.w	--sp,r11
80002830:	1a da       	st.w	--sp,r10
80002832:	1a d9       	st.w	--sp,r9
80002834:	1a d8       	st.w	--sp,r8
80002836:	4d 0c       	lddpc	r12,80002974 <app_cfg+0x1b8>
80002838:	f0 1f 00 4d 	mcall	8000296c <app_cfg+0x1b0>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000283c:	2f cd       	sub	sp,-16
8000283e:	c7 a8       	rjmp	80002932 <app_cfg+0x176>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
				}
				else
				{
					nop();
80002840:	d7 03       	nop
					nop();
80002842:	d7 03       	nop
					nop();
80002844:	d7 03       	nop
					log("connecting...\n");
80002846:	0a 9c       	mov	r12,r5
80002848:	f0 1f 00 49 	mcall	8000296c <app_cfg+0x1b0>
8000284c:	c7 38       	rjmp	80002932 <app_cfg+0x176>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (1000*2) / portTICK_RATE_MS))
8000284e:	4c b8       	lddpc	r8,80002978 <app_cfg+0x1bc>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	30 09       	mov	r9,0
80002854:	e0 6a 07 d0 	mov	r10,2000
80002858:	1a 9b       	mov	r11,sp
8000285a:	f0 1f 00 3e 	mcall	80002950 <app_cfg+0x194>
8000285e:	58 1c       	cp.w	r12,1
80002860:	c6 51       	brne	8000292a <app_cfg+0x16e>
						{
							if(data_ptr!=NULL){//resend message
80002862:	40 08       	lddsp	r8,sp[0x0]
80002864:	58 08       	cp.w	r8,0
80002866:	c6 20       	breq	8000292a <app_cfg+0x16e>
							
								log("receive Okay!\n");	
80002868:	4c 5c       	lddpc	r12,8000297c <app_cfg+0x1c0>
8000286a:	f0 1f 00 41 	mcall	8000296c <app_cfg+0x1b0>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
8000286e:	4c 52       	lddpc	r2,80002980 <app_cfg+0x1c4>
80002870:	64 0c       	ld.w	r12,r2[0x0]
80002872:	30 09       	mov	r9,0
80002874:	3f fa       	mov	r10,-1
80002876:	12 9b       	mov	r11,r9
80002878:	f0 1f 00 36 	mcall	80002950 <app_cfg+0x194>
								global_count--;
8000287c:	4c 24       	lddpc	r4,80002984 <app_cfg+0x1c8>
8000287e:	68 08       	ld.w	r8,r4[0x0]
80002880:	20 18       	sub	r8,1
80002882:	89 08       	st.w	r4[0x0],r8
								xSemaphoreGive(count_mutex);
80002884:	64 0c       	ld.w	r12,r2[0x0]
80002886:	30 09       	mov	r9,0
80002888:	12 9a       	mov	r10,r9
8000288a:	12 9b       	mov	r11,r9
8000288c:	f0 1f 00 3f 	mcall	80002988 <app_cfg+0x1cc>
								log("global_count:%d\n", global_count);	
80002890:	68 08       	ld.w	r8,r4[0x0]
80002892:	1a d8       	st.w	--sp,r8
80002894:	4b ec       	lddpc	r12,8000298c <app_cfg+0x1d0>
80002896:	f0 1f 00 36 	mcall	8000296c <app_cfg+0x1b0>
																			
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);	
8000289a:	36 4a       	mov	r10,100
8000289c:	31 ab       	mov	r11,26
8000289e:	40 1c       	lddsp	r12,sp[0x4]
800028a0:	f0 1f 00 3c 	mcall	80002990 <app_cfg+0x1d4>
								if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) ==pdFALSE)
800028a4:	4a a8       	lddpc	r8,8000294c <app_cfg+0x190>
800028a6:	70 0c       	ld.w	r12,r8[0x0]
800028a8:	30 09       	mov	r9,0
800028aa:	e0 6a 9c 40 	mov	r10,40000
800028ae:	12 9b       	mov	r11,r9
800028b0:	f0 1f 00 28 	mcall	80002950 <app_cfg+0x194>
800028b4:	2f fd       	sub	sp,-4
800028b6:	58 0c       	cp.w	r12,0
800028b8:	c3 11       	brne	8000291a <app_cfg+0x15e>
								{
									
									if (xQueueSend(xg_resend_queue, &data_ptr, 0) != pdPASS)
800028ba:	4b 08       	lddpc	r8,80002978 <app_cfg+0x1bc>
800028bc:	70 0c       	ld.w	r12,r8[0x0]
800028be:	30 09       	mov	r9,0
800028c0:	12 9a       	mov	r10,r9
800028c2:	1a 9b       	mov	r11,sp
800028c4:	f0 1f 00 31 	mcall	80002988 <app_cfg+0x1cc>
800028c8:	58 1c       	cp.w	r12,1
800028ca:	c1 10       	breq	800028ec <app_cfg+0x130>
									{
										log("xg_resend_queue: full\n" );
800028cc:	4b 2c       	lddpc	r12,80002994 <app_cfg+0x1d8>
800028ce:	f0 1f 00 28 	mcall	8000296c <app_cfg+0x1b0>
										xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800028d2:	32 3b       	mov	r11,35
800028d4:	02 9c       	mov	r12,r1
800028d6:	f0 1f 00 24 	mcall	80002964 <app_cfg+0x1a8>
										vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
800028da:	e0 6c 17 70 	mov	r12,6000
800028de:	f0 1f 00 2f 	mcall	80002998 <app_cfg+0x1dc>
										xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800028e2:	32 3b       	mov	r11,35
800028e4:	30 0c       	mov	r12,0
800028e6:	f0 1f 00 20 	mcall	80002964 <app_cfg+0x1a8>
800028ea:	c2 08       	rjmp	8000292a <app_cfg+0x16e>
									}
									else{
											
										xSemaphoreTake(count_mutex, portMAX_DELAY);
800028ec:	4a 54       	lddpc	r4,80002980 <app_cfg+0x1c4>
800028ee:	68 0c       	ld.w	r12,r4[0x0]
800028f0:	30 09       	mov	r9,0
800028f2:	3f fa       	mov	r10,-1
800028f4:	12 9b       	mov	r11,r9
800028f6:	f0 1f 00 17 	mcall	80002950 <app_cfg+0x194>
										global_count++;
800028fa:	4a 38       	lddpc	r8,80002984 <app_cfg+0x1c8>
800028fc:	70 09       	ld.w	r9,r8[0x0]
800028fe:	2f f9       	sub	r9,-1
80002900:	91 09       	st.w	r8[0x0],r9
										xSemaphoreGive(count_mutex);
80002902:	68 0c       	ld.w	r12,r4[0x0]
80002904:	30 09       	mov	r9,0
80002906:	12 9a       	mov	r10,r9
80002908:	12 9b       	mov	r11,r9
8000290a:	f0 1f 00 20 	mcall	80002988 <app_cfg+0x1cc>
										xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
8000290e:	e0 6b 00 b7 	mov	r11,183
80002912:	02 9c       	mov	r12,r1
80002914:	f0 1f 00 14 	mcall	80002964 <app_cfg+0x1a8>
80002918:	c0 98       	rjmp	8000292a <app_cfg+0x16e>
									}
				
								}	
								else
								{
									set_message_store(data_ptr);
8000291a:	4a 18       	lddpc	r8,8000299c <app_cfg+0x1e0>
8000291c:	70 0c       	ld.w	r12,r8[0x0]
8000291e:	40 0b       	lddsp	r11,sp[0x0]
80002920:	f0 1f 00 20 	mcall	800029a0 <app_cfg+0x1e4>
									log("send message\n");
80002924:	4a 0c       	lddpc	r12,800029a4 <app_cfg+0x1e8>
80002926:	f0 1f 00 12 	mcall	8000296c <app_cfg+0x1b0>
							}
						
						}
					}
										
					nop();
8000292a:	d7 03       	nop
					log("app task run!\n");
8000292c:	49 fc       	lddpc	r12,800029a8 <app_cfg+0x1ec>
8000292e:	f0 1f 00 10 	mcall	8000296c <app_cfg+0x1b0>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002932:	e0 6b 07 d0 	mov	r11,2000
80002936:	48 5c       	lddpc	r12,80002948 <app_cfg+0x18c>
80002938:	f0 1f 00 1d 	mcall	800029ac <app_cfg+0x1f0>
	}
8000293c:	c5 6b       	rjmp	800027e8 <app_cfg+0x2c>
8000293e:	00 00       	add	r0,r0
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	60 8c       	ld.w	r12,r0[0x20]
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	69 44       	ld.w	r4,r4[0x50]
80002948:	00 00       	add	r0,r0
8000294a:	0a 64       	and	r4,r5
8000294c:	00 00       	add	r0,r0
8000294e:	0b 78       	ld.ub	r8,--r5
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	61 d4       	ld.w	r4,r0[0x74]
80002954:	00 00       	add	r0,r0
80002956:	0a 44       	or	r4,r5
80002958:	00 00       	add	r0,r0
8000295a:	0d a0       	ld.ub	r0,r6[0x2]
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	d6 84       	*unknown*
80002960:	00 00       	add	r0,r0
80002962:	0a 5c       	eor	r12,r5
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	40 ec       	lddsp	r12,sp[0x38]
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	d6 54       	*unknown*
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	70 18       	ld.w	r8,r8[0x4]
80002970:	00 00       	add	r0,r0
80002972:	0d 9c       	ld.ub	r12,r6[0x1]
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d6 68       	*unknown*
80002978:	00 00       	add	r0,r0
8000297a:	0b 70       	ld.ub	r0,--r5
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	d6 94       	*unknown*
80002980:	00 00       	add	r0,r0
80002982:	0a 60       	and	r0,r5
80002984:	00 00       	add	r0,r0
80002986:	0a 58       	eor	r8,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	63 e0       	ld.w	r0,r1[0x78]
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d6 a4       	*unknown*
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	3f a8       	mov	r8,-6
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d6 b8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	6a ac       	ld.w	r12,r5[0x28]
8000299c:	00 00       	add	r0,r0
8000299e:	0b 74       	ld.ub	r4,--r5
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	2c 7c       	sub	r12,-57
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d6 d0       	acall	0x6d
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	d6 e0       	acall	0x6e
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	6a f4       	ld.w	r4,r5[0x3c]

800029b0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800029b0:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800029b4:	19 c7       	ld.ub	r7,r12[0x4]
800029b6:	19 d8       	ld.ub	r8,r12[0x5]
800029b8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029bc:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029be:	48 dc       	lddpc	r12,800029f0 <Phyuserinput_brdcst_func+0x40>
800029c0:	f0 1f 00 0d 	mcall	800029f4 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029c4:	36 08       	mov	r8,96
800029c6:	f0 07 19 00 	cp.h	r7,r8
800029ca:	c1 11       	brne	800029ec <Phyuserinput_brdcst_func+0x3c>
800029cc:	48 b8       	lddpc	r8,800029f8 <Phyuserinput_brdcst_func+0x48>
800029ce:	11 89       	ld.ub	r9,r8[0x0]
800029d0:	30 18       	mov	r8,1
800029d2:	f0 09 18 00 	cp.b	r9,r8
800029d6:	c0 b1       	brne	800029ec <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
800029d8:	34 5b       	mov	r11,69
800029da:	30 1c       	mov	r12,1
800029dc:	f0 1f 00 08 	mcall	800029fc <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
800029e0:	e0 6c 07 d0 	mov	r12,2000
800029e4:	f0 1f 00 07 	mcall	80002a00 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
800029e8:	f0 1f 00 07 	mcall	80002a04 <Phyuserinput_brdcst_func+0x54>
800029ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	d6 f0       	acall	0x6f
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	70 18       	ld.w	r8,r8[0x4]
800029f8:	00 00       	add	r0,r0
800029fa:	0a 5c       	eor	r12,r5
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	40 ec       	lddsp	r12,sp[0x38]
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	6a ac       	ld.w	r12,r5[0x28]
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	51 50       	stdsp	sp[0x54],r0

80002a08 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a08:	d4 21       	pushm	r4-r7,lr
80002a0a:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002a0c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002a10:	0d 88       	ld.ub	r8,r6[0x0]
80002a12:	32 49       	mov	r9,36
80002a14:	f2 08 18 00 	cp.b	r8,r9
80002a18:	c2 a1       	brne	80002a6c <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002a1a:	4c ac       	lddpc	r12,80002b40 <DataSession_brdcst_func+0x138>
80002a1c:	f0 1f 00 4a 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002a20:	0d a5       	ld.ub	r5,r6[0x2]
80002a22:	0d b8       	ld.ub	r8,r6[0x3]
80002a24:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002a28:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002a2a:	0d 98       	ld.ub	r8,r6[0x1]
80002a2c:	1a d8       	st.w	--sp,r8
80002a2e:	4c 7c       	lddpc	r12,80002b48 <DataSession_brdcst_func+0x140>
80002a30:	f0 1f 00 45 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a34:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a38:	1a d8       	st.w	--sp,r8
80002a3a:	4c 5c       	lddpc	r12,80002b4c <DataSession_brdcst_func+0x144>
80002a3c:	f0 1f 00 42 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
80002a40:	2f ed       	sub	sp,-8
80002a42:	58 05       	cp.w	r5,0
80002a44:	e0 80 00 7b 	breq	80002b3a <DataSession_brdcst_func+0x132>
80002a48:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a4a:	4c 24       	lddpc	r4,80002b50 <DataSession_brdcst_func+0x148>
80002a4c:	ec 07 00 08 	add	r8,r6,r7
80002a50:	11 c8       	ld.ub	r8,r8[0x4]
80002a52:	1a d8       	st.w	--sp,r8
80002a54:	1a d7       	st.w	--sp,r7
80002a56:	08 9c       	mov	r12,r4
80002a58:	f0 1f 00 3b 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002a5c:	2f f7       	sub	r7,-1
80002a5e:	5c 57       	castu.b	r7
80002a60:	2f ed       	sub	sp,-8
80002a62:	ee 05 19 00 	cp.h	r5,r7
80002a66:	fe 9b ff f3 	brhi	80002a4c <DataSession_brdcst_func+0x44>
80002a6a:	c6 88       	rjmp	80002b3a <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002a6c:	1a d8       	st.w	--sp,r8
80002a6e:	4b ac       	lddpc	r12,80002b54 <DataSession_brdcst_func+0x14c>
80002a70:	f0 1f 00 35 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002a74:	0d 88       	ld.ub	r8,r6[0x0]
80002a76:	2f fd       	sub	sp,-4
80002a78:	30 39       	mov	r9,3
80002a7a:	f2 08 18 00 	cp.b	r8,r9
80002a7e:	c0 d1       	brne	80002a98 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002a80:	4b 6c       	lddpc	r12,80002b58 <DataSession_brdcst_func+0x150>
80002a82:	f0 1f 00 31 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a86:	e0 6c 07 d0 	mov	r12,2000
80002a8a:	f0 1f 00 35 	mcall	80002b5c <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002a8e:	37 7b       	mov	r11,119
80002a90:	30 1c       	mov	r12,1
80002a92:	f0 1f 00 34 	mcall	80002b60 <DataSession_brdcst_func+0x158>
80002a96:	c4 b8       	rjmp	80002b2c <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a98:	30 49       	mov	r9,4
80002a9a:	f2 08 18 00 	cp.b	r8,r9
80002a9e:	c4 71       	brne	80002b2c <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002aa0:	31 aa       	mov	r10,26
80002aa2:	ec cb ff fc 	sub	r11,r6,-4
80002aa6:	fa cc ff fe 	sub	r12,sp,-2
80002aaa:	f0 1f 00 2f 	mcall	80002b64 <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002aae:	4a f8       	lddpc	r8,80002b68 <DataSession_brdcst_func+0x160>
80002ab0:	70 0c       	ld.w	r12,r8[0x0]
80002ab2:	f0 1f 00 2f 	mcall	80002b6c <DataSession_brdcst_func+0x164>
80002ab6:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002ab8:	c3 20       	breq	80002b1c <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002aba:	31 aa       	mov	r10,26
80002abc:	fa cb ff fe 	sub	r11,sp,-2
80002ac0:	f0 1f 00 29 	mcall	80002b64 <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002ac4:	4a b8       	lddpc	r8,80002b70 <DataSession_brdcst_func+0x168>
80002ac6:	70 0c       	ld.w	r12,r8[0x0]
80002ac8:	30 09       	mov	r9,0
80002aca:	12 9a       	mov	r10,r9
80002acc:	fa cb ff e4 	sub	r11,sp,-28
80002ad0:	f0 1f 00 29 	mcall	80002b74 <DataSession_brdcst_func+0x16c>
80002ad4:	58 1c       	cp.w	r12,1
80002ad6:	c1 10       	breq	80002af8 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002ad8:	4a 8c       	lddpc	r12,80002b78 <DataSession_brdcst_func+0x170>
80002ada:	f0 1f 00 1b 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002ade:	32 3b       	mov	r11,35
80002ae0:	30 1c       	mov	r12,1
80002ae2:	f0 1f 00 20 	mcall	80002b60 <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002ae6:	e0 6c 17 70 	mov	r12,6000
80002aea:	f0 1f 00 1d 	mcall	80002b5c <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002aee:	32 3b       	mov	r11,35
80002af0:	30 0c       	mov	r12,0
80002af2:	f0 1f 00 1c 	mcall	80002b60 <DataSession_brdcst_func+0x158>
80002af6:	c1 68       	rjmp	80002b22 <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002af8:	4a 17       	lddpc	r7,80002b7c <DataSession_brdcst_func+0x174>
80002afa:	6e 0c       	ld.w	r12,r7[0x0]
80002afc:	30 09       	mov	r9,0
80002afe:	3f fa       	mov	r10,-1
80002b00:	12 9b       	mov	r11,r9
80002b02:	f0 1f 00 20 	mcall	80002b80 <DataSession_brdcst_func+0x178>
					global_count++;
80002b06:	4a 08       	lddpc	r8,80002b84 <DataSession_brdcst_func+0x17c>
80002b08:	70 09       	ld.w	r9,r8[0x0]
80002b0a:	2f f9       	sub	r9,-1
80002b0c:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002b0e:	6e 0c       	ld.w	r12,r7[0x0]
80002b10:	30 09       	mov	r9,0
80002b12:	12 9a       	mov	r10,r9
80002b14:	12 9b       	mov	r11,r9
80002b16:	f0 1f 00 18 	mcall	80002b74 <DataSession_brdcst_func+0x16c>
80002b1a:	c0 48       	rjmp	80002b22 <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002b1c:	49 bc       	lddpc	r12,80002b88 <DataSession_brdcst_func+0x180>
80002b1e:	f0 1f 00 0a 	mcall	80002b44 <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002b22:	e0 6b 00 b7 	mov	r11,183
80002b26:	30 1c       	mov	r12,1
80002b28:	f0 1f 00 0e 	mcall	80002b60 <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002b2c:	49 88       	lddpc	r8,80002b8c <DataSession_brdcst_func+0x184>
80002b2e:	70 0c       	ld.w	r12,r8[0x0]
80002b30:	30 09       	mov	r9,0
80002b32:	12 9a       	mov	r10,r9
80002b34:	12 9b       	mov	r11,r9
80002b36:	f0 1f 00 10 	mcall	80002b74 <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002b3a:	2f 8d       	sub	sp,-32
80002b3c:	d8 22       	popm	r4-r7,pc
80002b3e:	00 00       	add	r0,r0
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	d7 10       	acall	0x71
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	70 18       	ld.w	r8,r8[0x4]
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	d7 24       	*unknown*
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	d7 3c       	*unknown*
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	d7 58       	*unknown*
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	d7 70       	acall	0x77
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	d7 7c       	*unknown*
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	6a ac       	ld.w	r12,r5[0x28]
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	40 ec       	lddsp	r12,sp[0x38]
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	78 94       	ld.w	r4,r12[0x24]
80002b68:	00 00       	add	r0,r0
80002b6a:	0b 74       	ld.ub	r4,--r5
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	2e 28       	sub	r8,-30
80002b70:	00 00       	add	r0,r0
80002b72:	0b 70       	ld.ub	r0,--r5
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	63 e0       	ld.w	r0,r1[0x78]
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	d6 b8       	*unknown*
80002b7c:	00 00       	add	r0,r0
80002b7e:	0a 60       	and	r0,r5
80002b80:	80 00       	ld.sh	r0,r0[0x0]
80002b82:	61 d4       	ld.w	r4,r0[0x74]
80002b84:	00 00       	add	r0,r0
80002b86:	0a 58       	eor	r8,r5
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	d7 94       	*unknown*
80002b8c:	00 00       	add	r0,r0
80002b8e:	0b 78       	ld.ub	r8,--r5

80002b90 <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b90:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
80002b94:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002b98:	30 4a       	mov	r10,4
80002b9a:	0e 9b       	mov	r11,r7
80002b9c:	48 dc       	lddpc	r12,80002bd0 <DeviceInitializationStatus_brdcst_func+0x40>
80002b9e:	f0 1f 00 0e 	mcall	80002bd4 <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
80002ba2:	0f c8       	ld.ub	r8,r7[0x4]
80002ba4:	30 19       	mov	r9,1
80002ba6:	f2 08 18 00 	cp.b	r8,r9
80002baa:	c0 71       	brne	80002bb8 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002bac:	48 b8       	lddpc	r8,80002bd8 <DeviceInitializationStatus_brdcst_func+0x48>
80002bae:	70 09       	ld.w	r9,r8[0x0]
80002bb0:	a1 a9       	sbr	r9,0x0
80002bb2:	91 09       	st.w	r8[0x0],r9
80002bb4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002bb8:	58 08       	cp.w	r8,0
80002bba:	c0 81       	brne	80002bca <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002bbc:	48 78       	lddpc	r8,80002bd8 <DeviceInitializationStatus_brdcst_func+0x48>
80002bbe:	70 09       	ld.w	r9,r8[0x0]
80002bc0:	e0 19 ff fc 	andl	r9,0xfffc
80002bc4:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002bc6:	f0 1f 00 06 	mcall	80002bdc <DeviceInitializationStatus_brdcst_func+0x4c>
80002bca:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bce:	00 00       	add	r0,r0
80002bd0:	00 00       	add	r0,r0
80002bd2:	0d 9c       	ld.ub	r12,r6[0x1]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	78 94       	ld.w	r4,r12[0x24]
80002bd8:	00 00       	add	r0,r0
80002bda:	0d a0       	ld.ub	r0,r6[0x2]
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	40 38       	lddsp	r8,sp[0xc]

80002be0 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002be0:	20 1c       	sub	r12,1
80002be2:	5c 5c       	castu.b	r12
80002be4:	31 18       	mov	r8,17
80002be6:	f0 0c 18 00 	cp.b	r12,r8
80002bea:	e0 88 00 03 	brls	80002bf0 <CalculateBurst+0x10>
80002bee:	5e fd       	retal	0
80002bf0:	48 28       	lddpc	r8,80002bf8 <CalculateBurst+0x18>
80002bf2:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002bf6:	5e fc       	retal	r12
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	d7 a4       	*unknown*

80002bfc <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002bfc:	48 38       	lddpc	r8,80002c08 <payload_init+0xc>
80002bfe:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002c00:	48 38       	lddpc	r8,80002c0c <payload_init+0x10>
80002c02:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002c04:	5e fc       	retal	r12
80002c06:	00 00       	add	r0,r0
80002c08:	00 00       	add	r0,r0
80002c0a:	0a 70       	tst	r0,r5
80002c0c:	00 00       	add	r0,r0
80002c0e:	0a 74       	tst	r4,r5

80002c10 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002c10:	d4 01       	pushm	lr
80002c12:	20 2d       	sub	sp,8
80002c14:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c16:	30 09       	mov	r9,0
80002c18:	fa ca ff f8 	sub	r10,sp,-8
80002c1c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002c1e:	1a 9b       	mov	r11,sp
80002c20:	f0 1f 00 02 	mcall	80002c28 <set_idle_store_isr+0x18>
}
80002c24:	2f ed       	sub	sp,-8
80002c26:	d8 02       	popm	pc
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	63 90       	ld.w	r0,r1[0x64]

80002c2c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002c2c:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002c2e:	48 48       	lddpc	r8,80002c3c <payload_rx+0x10>
80002c30:	70 08       	ld.w	r8,r8[0x0]
80002c32:	18 9b       	mov	r11,r12
80002c34:	10 9c       	mov	r12,r8
80002c36:	f0 1f 00 03 	mcall	80002c40 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002c3a:	d8 02       	popm	pc
80002c3c:	00 00       	add	r0,r0
80002c3e:	0a ac       	st.w	r5++,r12
80002c40:	80 00       	ld.sh	r0,r0[0x0]
80002c42:	2c 10       	sub	r0,-63

80002c44 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002c44:	d4 01       	pushm	lr
80002c46:	20 2d       	sub	sp,8
80002c48:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002c4a:	58 0c       	cp.w	r12,0
80002c4c:	c1 10       	breq	80002c6e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c4e:	30 08       	mov	r8,0
80002c50:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002c52:	98 88       	ld.uh	r8,r12[0x0]
80002c54:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c58:	e0 48 40 00 	cp.w	r8,16384
80002c5c:	c0 91       	brne	80002c6e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002c5e:	48 68       	lddpc	r8,80002c74 <phy_rx+0x30>
80002c60:	70 0c       	ld.w	r12,r8[0x0]
80002c62:	30 09       	mov	r9,0
80002c64:	fa ca ff fc 	sub	r10,sp,-4
80002c68:	1a 9b       	mov	r11,sp
80002c6a:	f0 1f 00 04 	mcall	80002c78 <phy_rx+0x34>
		}	

    }
		
 
}
80002c6e:	2f ed       	sub	sp,-8
80002c70:	d8 02       	popm	pc
80002c72:	00 00       	add	r0,r0
80002c74:	00 00       	add	r0,r0
80002c76:	0a b8       	st.h	r5++,r8
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	63 90       	ld.w	r0,r1[0x64]

80002c7c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c7c:	eb cd 40 80 	pushm	r7,lr
80002c80:	20 1d       	sub	sp,4
80002c82:	fa c7 ff fc 	sub	r7,sp,-4
80002c86:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c88:	30 09       	mov	r9,0
80002c8a:	12 9a       	mov	r10,r9
80002c8c:	1a 9b       	mov	r11,sp
80002c8e:	f0 1f 00 03 	mcall	80002c98 <set_idle_store+0x1c>
}
80002c92:	2f fd       	sub	sp,-4
80002c94:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	63 e0       	ld.w	r0,r1[0x78]

80002c9c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c9c:	d4 01       	pushm	lr
80002c9e:	20 1d       	sub	sp,4
80002ca0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002ca2:	98 88       	ld.uh	r8,r12[0x0]
80002ca4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ca8:	e0 48 40 00 	cp.w	r8,16384
80002cac:	c0 d1       	brne	80002cc6 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002cae:	49 08       	lddpc	r8,80002cec <phy_tx+0x50>
80002cb0:	70 08       	ld.w	r8,r8[0x0]
80002cb2:	58 08       	cp.w	r8,0
80002cb4:	c1 a0       	breq	80002ce8 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002cb6:	48 e8       	lddpc	r8,80002cec <phy_tx+0x50>
80002cb8:	70 0c       	ld.w	r12,r8[0x0]
80002cba:	30 09       	mov	r9,0
80002cbc:	12 9a       	mov	r10,r9
80002cbe:	1a 9b       	mov	r11,sp
80002cc0:	f0 1f 00 0c 	mcall	80002cf0 <phy_tx+0x54>
80002cc4:	c1 28       	rjmp	80002ce8 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002cc6:	e0 48 10 00 	cp.w	r8,4096
80002cca:	5f 0a       	sreq	r10
80002ccc:	e0 48 20 00 	cp.w	r8,8192
80002cd0:	5f 09       	sreq	r9
80002cd2:	f5 e9 10 09 	or	r9,r10,r9
80002cd6:	c0 71       	brne	80002ce4 <phy_tx+0x48>
80002cd8:	e0 48 50 00 	cp.w	r8,20480
80002cdc:	c0 40       	breq	80002ce4 <phy_tx+0x48>
80002cde:	e0 48 60 00 	cp.w	r8,24576
80002ce2:	c0 31       	brne	80002ce8 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002ce4:	48 48       	lddpc	r8,80002cf4 <phy_tx+0x58>
80002ce6:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002ce8:	2f fd       	sub	sp,-4
80002cea:	d8 02       	popm	pc
80002cec:	00 00       	add	r0,r0
80002cee:	0a d8       	st.w	--r5,r8
80002cf0:	80 00       	ld.sh	r0,r0[0x0]
80002cf2:	63 e0       	ld.w	r0,r1[0x78]
80002cf4:	00 00       	add	r0,r0
80002cf6:	0a cc       	st.b	r5++,r12

80002cf8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002cf8:	d4 01       	pushm	lr
80002cfa:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002cfc:	30 08       	mov	r8,0
80002cfe:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d00:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002d02:	1a 9a       	mov	r10,sp
80002d04:	fa cb ff fc 	sub	r11,sp,-4
80002d08:	f0 1f 00 05 	mcall	80002d1c <get_idle_store_isr+0x24>
80002d0c:	58 1c       	cp.w	r12,1
80002d0e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d12:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002d16:	2f ed       	sub	sp,-8
80002d18:	d8 02       	popm	pc
80002d1a:	00 00       	add	r0,r0
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	60 e4       	ld.w	r4,r0[0x38]

80002d20 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002d20:	eb cd 40 c0 	pushm	r6-r7,lr
80002d24:	20 1d       	sub	sp,4
80002d26:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002d28:	4b a8       	lddpc	r8,80002e10 <phy_tx_func+0xf0>
80002d2a:	70 08       	ld.w	r8,r8[0x0]
80002d2c:	58 08       	cp.w	r8,0
80002d2e:	c6 60       	breq	80002dfa <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002d30:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d32:	30 08       	mov	r8,0
80002d34:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002d36:	4b 88       	lddpc	r8,80002e14 <phy_tx_func+0xf4>
80002d38:	70 08       	ld.w	r8,r8[0x0]
80002d3a:	58 18       	cp.w	r8,1
80002d3c:	c2 60       	breq	80002d88 <phy_tx_func+0x68>
80002d3e:	c0 43       	brcs	80002d46 <phy_tx_func+0x26>
80002d40:	58 28       	cp.w	r8,2
80002d42:	c5 c1       	brne	80002dfa <phy_tx_func+0xda>
80002d44:	c5 58       	rjmp	80002dee <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002d46:	4b 38       	lddpc	r8,80002e10 <phy_tx_func+0xf0>
80002d48:	70 0c       	ld.w	r12,r8[0x0]
80002d4a:	1a 9a       	mov	r10,sp
80002d4c:	4b 3b       	lddpc	r11,80002e18 <phy_tx_func+0xf8>
80002d4e:	f0 1f 00 34 	mcall	80002e1c <phy_tx_func+0xfc>
80002d52:	58 1c       	cp.w	r12,1
80002d54:	c1 41       	brne	80002d7c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002d56:	4b 18       	lddpc	r8,80002e18 <phy_tx_func+0xf8>
80002d58:	70 08       	ld.w	r8,r8[0x0]
80002d5a:	90 08       	ld.sh	r8,r8[0x0]
80002d5c:	10 9a       	mov	r10,r8
80002d5e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d62:	4b 09       	lddpc	r9,80002e20 <phy_tx_func+0x100>
80002d64:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d66:	5c 78       	castu.h	r8
80002d68:	ea 18 ab cd 	orh	r8,0xabcd
80002d6c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002d6e:	30 19       	mov	r9,1
80002d70:	4a d8       	lddpc	r8,80002e24 <phy_tx_func+0x104>
80002d72:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d74:	30 19       	mov	r9,1
80002d76:	4a 88       	lddpc	r8,80002e14 <phy_tx_func+0xf4>
80002d78:	91 09       	st.w	r8[0x0],r9
80002d7a:	c4 08       	rjmp	80002dfa <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d7c:	e0 68 5a 5a 	mov	r8,23130
80002d80:	ea 18 ab cd 	orh	r8,0xabcd
80002d84:	8f 18       	st.w	r7[0x4],r8
80002d86:	c3 a8       	rjmp	80002dfa <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d88:	4a 7a       	lddpc	r10,80002e24 <phy_tx_func+0x104>
80002d8a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d8c:	4a 39       	lddpc	r9,80002e18 <phy_tx_func+0xf8>
80002d8e:	72 09       	ld.w	r9,r9[0x0]
80002d90:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d94:	b1 69       	lsl	r9,0x10
80002d96:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d98:	2f f8       	sub	r8,-1
80002d9a:	5c 58       	castu.b	r8
80002d9c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d9e:	4a 1b       	lddpc	r11,80002e20 <phy_tx_func+0x100>
80002da0:	96 0c       	ld.sh	r12,r11[0x0]
80002da2:	20 2c       	sub	r12,2
80002da4:	5c 8c       	casts.h	r12
80002da6:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002daa:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002dac:	30 0b       	mov	r11,0
80002dae:	f6 0a 19 00 	cp.h	r10,r11
80002db2:	e0 89 00 09 	brgt	80002dc4 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002db6:	e8 19 00 ba 	orl	r9,0xba
80002dba:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002dbc:	30 09       	mov	r9,0
80002dbe:	49 68       	lddpc	r8,80002e14 <phy_tx_func+0xf4>
80002dc0:	91 09       	st.w	r8[0x0],r9
80002dc2:	c1 c8       	rjmp	80002dfa <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002dc4:	49 5a       	lddpc	r10,80002e18 <phy_tx_func+0xf8>
80002dc6:	74 0a       	ld.w	r10,r10[0x0]
80002dc8:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002dcc:	14 49       	or	r9,r10
80002dce:	8f 19       	st.w	r7[0x4],r9
80002dd0:	2f f8       	sub	r8,-1
80002dd2:	49 59       	lddpc	r9,80002e24 <phy_tx_func+0x104>
80002dd4:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002dd6:	20 2c       	sub	r12,2
80002dd8:	49 28       	lddpc	r8,80002e20 <phy_tx_func+0x100>
80002dda:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002ddc:	30 08       	mov	r8,0
80002dde:	f0 0c 19 00 	cp.h	r12,r8
80002de2:	e0 89 00 0c 	brgt	80002dfa <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002de6:	30 29       	mov	r9,2
80002de8:	48 b8       	lddpc	r8,80002e14 <phy_tx_func+0xf4>
80002dea:	91 09       	st.w	r8[0x0],r9
80002dec:	c0 78       	rjmp	80002dfa <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002dee:	fc 18 00 ba 	movh	r8,0xba
80002df2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002df4:	30 09       	mov	r9,0
80002df6:	48 88       	lddpc	r8,80002e14 <phy_tx_func+0xf4>
80002df8:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002dfa:	e0 68 5a 5a 	mov	r8,23130
80002dfe:	ea 18 ab cd 	orh	r8,0xabcd
80002e02:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002e04:	30 08       	mov	r8,0
80002e06:	8f 38       	st.w	r7[0xc],r8
}
80002e08:	2f fd       	sub	sp,-4
80002e0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e0e:	00 00       	add	r0,r0
80002e10:	00 00       	add	r0,r0
80002e12:	0a d8       	st.w	--r5,r8
80002e14:	00 00       	add	r0,r0
80002e16:	0a 98       	mov	r8,r5
80002e18:	00 00       	add	r0,r0
80002e1a:	0a a4       	st.w	r5++,r4
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	60 e4       	ld.w	r4,r0[0x38]
80002e20:	00 00       	add	r0,r0
80002e22:	0a c0       	st.b	r5++,r0
80002e24:	00 00       	add	r0,r0
80002e26:	0a 78       	tst	r8,r5

80002e28 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002e28:	d4 01       	pushm	lr
80002e2a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002e2c:	30 0a       	mov	r10,0
80002e2e:	fa cb ff fc 	sub	r11,sp,-4
80002e32:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002e34:	14 99       	mov	r9,r10
80002e36:	1a 9b       	mov	r11,sp
80002e38:	f0 1f 00 05 	mcall	80002e4c <get_idle_store+0x24>
80002e3c:	58 1c       	cp.w	r12,1
80002e3e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002e42:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002e46:	2f fd       	sub	sp,-4
80002e48:	d8 02       	popm	pc
80002e4a:	00 00       	add	r0,r0
80002e4c:	80 00       	ld.sh	r0,r0[0x0]
80002e4e:	61 d4       	ld.w	r4,r0[0x74]

80002e50 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002e50:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002e52:	48 5b       	lddpc	r11,80002e64 <phy_init+0x14>
80002e54:	48 5c       	lddpc	r12,80002e68 <phy_init+0x18>
80002e56:	f0 1f 00 06 	mcall	80002e6c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002e5a:	f0 1f 00 06 	mcall	80002e70 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002e5e:	f0 1f 00 06 	mcall	80002e74 <phy_init+0x24>
	
}
80002e62:	d8 02       	popm	pc
80002e64:	80 00       	ld.sh	r0,r0[0x0]
80002e66:	2d 20       	sub	r0,-46
80002e68:	80 00       	ld.sh	r0,r0[0x0]
80002e6a:	2e 78       	sub	r8,-25
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	3e cc       	mov	r12,-20
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	3e e0       	mov	r0,-18
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	48 98       	lddpc	r8,80002e98 <phy_rx_func+0x20>

80002e78 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e78:	eb cd 40 e0 	pushm	r5-r7,lr
80002e7c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e7e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e82:	70 08       	ld.w	r8,r8[0x0]
80002e84:	58 08       	cp.w	r8,0
80002e86:	e0 80 01 08 	breq	80003096 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e8a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e8c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e90:	70 09       	ld.w	r9,r8[0x0]
80002e92:	2f f9       	sub	r9,-1
80002e94:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e96:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e9a:	70 08       	ld.w	r8,r8[0x0]
80002e9c:	58 18       	cp.w	r8,1
80002e9e:	e0 80 00 85 	breq	80002fa8 <phy_rx_func+0x130>
80002ea2:	c0 73       	brcs	80002eb0 <phy_rx_func+0x38>
80002ea4:	58 28       	cp.w	r8,2
80002ea6:	c5 c0       	breq	80002f5e <phy_rx_func+0xe6>
80002ea8:	58 38       	cp.w	r8,3
80002eaa:	e0 81 00 f6 	brne	80003096 <phy_rx_func+0x21e>
80002eae:	cd 58       	rjmp	80003058 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002eb0:	e0 6a 5a 5a 	mov	r10,23130
80002eb4:	ea 1a ab cd 	orh	r10,0xabcd
80002eb8:	14 36       	cp.w	r6,r10
80002eba:	e0 80 00 ee 	breq	80003096 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002ebe:	ec 08 16 10 	lsr	r8,r6,0x10
80002ec2:	e0 48 ab cd 	cp.w	r8,43981
80002ec6:	e0 81 00 e8 	brne	80003096 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002eca:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002ece:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002ed2:	20 28       	sub	r8,2
80002ed4:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002ed8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002eda:	30 09       	mov	r9,0
80002edc:	f2 08 19 00 	cp.h	r8,r9
80002ee0:	e0 8a 00 db 	brle	80003096 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ee4:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002ee8:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002eea:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002eee:	70 0c       	ld.w	r12,r8[0x0]
80002ef0:	f0 1f 03 88 	mcall	80003d10 <phy_rx_func+0xe98>
80002ef4:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002ef8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002efa:	58 0c       	cp.w	r12,0
80002efc:	e0 80 00 cd 	breq	80003096 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f00:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002f04:	90 09       	ld.sh	r9,r8[0x0]
80002f06:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f0a:	2f f9       	sub	r9,-1
80002f0c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f0e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002f12:	74 0a       	ld.w	r10,r10[0x0]
80002f14:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002f18:	76 0b       	ld.w	r11,r11[0x0]
80002f1a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f1e:	2f f9       	sub	r9,-1
80002f20:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f22:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f26:	e0 46 01 00 	cp.w	r6,256
80002f2a:	c0 c0       	breq	80002f42 <phy_rx_func+0xca>
80002f2c:	e0 8b 00 05 	brhi	80002f36 <phy_rx_func+0xbe>
80002f30:	58 06       	cp.w	r6,0
80002f32:	c0 80       	breq	80002f42 <phy_rx_func+0xca>
80002f34:	c0 c8       	rjmp	80002f4c <phy_rx_func+0xd4>
80002f36:	e0 46 02 00 	cp.w	r6,512
80002f3a:	c0 40       	breq	80002f42 <phy_rx_func+0xca>
80002f3c:	e0 46 03 00 	cp.w	r6,768
80002f40:	c0 61       	brne	80002f4c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f42:	30 29       	mov	r9,2
80002f44:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002f48:	91 09       	st.w	r8[0x0],r9
80002f4a:	ca 68       	rjmp	80003096 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f4c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f50:	70 0c       	ld.w	r12,r8[0x0]
80002f52:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f56:	70 0b       	ld.w	r11,r8[0x0]
80002f58:	f0 1f 03 70 	mcall	80003d18 <phy_rx_func+0xea0>
80002f5c:	c9 d8       	rjmp	80003096 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f5e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f62:	b1 86       	lsr	r6,0x10
80002f64:	14 06       	add	r6,r10
80002f66:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002f6a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f6c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f70:	90 09       	ld.sh	r9,r8[0x0]
80002f72:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f76:	76 0b       	ld.w	r11,r11[0x0]
80002f78:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f7c:	2f f9       	sub	r9,-1
80002f7e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f80:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f84:	92 08       	ld.sh	r8,r9[0x0]
80002f86:	20 28       	sub	r8,2
80002f88:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f8a:	30 09       	mov	r9,0
80002f8c:	f2 08 19 00 	cp.h	r8,r9
80002f90:	e0 8a 00 07 	brle	80002f9e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f94:	30 19       	mov	r9,1
80002f96:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f9a:	91 09       	st.w	r8[0x0],r9
80002f9c:	c7 d8       	rjmp	80003096 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f9e:	30 39       	mov	r9,3
80002fa0:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002fa4:	91 09       	st.w	r8[0x0],r9
80002fa6:	c7 88       	rjmp	80003096 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002fa8:	ec 0a 14 10 	asr	r10,r6,0x10
80002fac:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002fb0:	90 09       	ld.sh	r9,r8[0x0]
80002fb2:	14 09       	add	r9,r10
80002fb4:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002fb6:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002fba:	92 08       	ld.sh	r8,r9[0x0]
80002fbc:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002fc0:	76 0b       	ld.w	r11,r11[0x0]
80002fc2:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002fc6:	2f f8       	sub	r8,-1
80002fc8:	5c 88       	casts.h	r8
80002fca:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002fcc:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002fd0:	94 09       	ld.sh	r9,r10[0x0]
80002fd2:	20 29       	sub	r9,2
80002fd4:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002fd6:	30 0a       	mov	r10,0
80002fd8:	f4 09 19 00 	cp.h	r9,r10
80002fdc:	e0 89 00 20 	brgt	8000301c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002fe0:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002fe4:	e0 46 00 ba 	cp.w	r6,186
80002fe8:	c0 d1       	brne	80003002 <phy_rx_func+0x18a>
80002fea:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002fee:	90 09       	ld.sh	r9,r8[0x0]
80002ff0:	f4 09 19 00 	cp.h	r9,r10
80002ff4:	c0 71       	brne	80003002 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002ff6:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002ffa:	70 0c       	ld.w	r12,r8[0x0]
80002ffc:	f0 1f 03 49 	mcall	80003d20 <phy_rx_func+0xea8>
80003000:	c0 98       	rjmp	80003012 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003002:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003006:	70 0c       	ld.w	r12,r8[0x0]
80003008:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000300c:	70 0b       	ld.w	r11,r8[0x0]
8000300e:	f0 1f 03 43 	mcall	80003d18 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003012:	30 09       	mov	r9,0
80003014:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003018:	91 09       	st.w	r8[0x0],r9
8000301a:	c3 e8       	rjmp	80003096 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000301c:	5c 86       	casts.h	r6
8000301e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003022:	92 0a       	ld.sh	r10,r9[0x0]
80003024:	0c 0a       	add	r10,r6
80003026:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003028:	fe f9 0c ec 	ld.w	r9,pc[3308]
8000302c:	72 09       	ld.w	r9,r9[0x0]
8000302e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003032:	2f f8       	sub	r8,-1
80003034:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003038:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000303a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000303e:	92 08       	ld.sh	r8,r9[0x0]
80003040:	20 28       	sub	r8,2
80003042:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003044:	30 09       	mov	r9,0
80003046:	f2 08 19 00 	cp.h	r8,r9
8000304a:	e0 89 00 26 	brgt	80003096 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000304e:	30 39       	mov	r9,3
80003050:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003054:	91 09       	st.w	r8[0x0],r9
80003056:	c2 08       	rjmp	80003096 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003058:	e6 16 00 ff 	andh	r6,0xff,COH
8000305c:	fc 19 00 ba 	movh	r9,0xba
80003060:	12 36       	cp.w	r6,r9
80003062:	c0 e1       	brne	8000307e <phy_rx_func+0x206>
80003064:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003068:	90 09       	ld.sh	r9,r8[0x0]
8000306a:	30 08       	mov	r8,0
8000306c:	f0 09 19 00 	cp.h	r9,r8
80003070:	c0 71       	brne	8000307e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003072:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003076:	70 0c       	ld.w	r12,r8[0x0]
80003078:	f0 1f 03 2a 	mcall	80003d20 <phy_rx_func+0xea8>
8000307c:	c0 98       	rjmp	8000308e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000307e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003082:	70 0c       	ld.w	r12,r8[0x0]
80003084:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003088:	70 0b       	ld.w	r11,r8[0x0]
8000308a:	f0 1f 03 24 	mcall	80003d18 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000308e:	30 09       	mov	r9,0
80003090:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003094:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003096:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000309a:	11 89       	ld.ub	r9,r8[0x0]
8000309c:	30 08       	mov	r8,0
8000309e:	f0 09 18 00 	cp.b	r9,r8
800030a2:	c1 31       	brne	800030c8 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800030a4:	fe f6 0c 84 	ld.w	r6,pc[3204]
800030a8:	6c 0c       	ld.w	r12,r6[0x0]
800030aa:	f0 1f 03 1a 	mcall	80003d10 <phy_rx_func+0xe98>
800030ae:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800030b2:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800030b4:	6c 0c       	ld.w	r12,r6[0x0]
800030b6:	f0 1f 03 17 	mcall	80003d10 <phy_rx_func+0xe98>
800030ba:	fe f8 0c 76 	ld.w	r8,pc[3190]
800030be:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800030c0:	30 19       	mov	r9,1
800030c2:	fe f8 0c 62 	ld.w	r8,pc[3170]
800030c6:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800030c8:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800030cc:	70 08       	ld.w	r8,r8[0x0]
800030ce:	58 28       	cp.w	r8,2
800030d0:	e0 80 01 98 	breq	80003400 <phy_rx_func+0x588>
800030d4:	e0 8b 00 06 	brhi	800030e0 <phy_rx_func+0x268>
800030d8:	58 08       	cp.w	r8,0
800030da:	c0 b0       	breq	800030f0 <phy_rx_func+0x278>
800030dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030e0:	58 38       	cp.w	r8,3
800030e2:	e0 80 05 c5 	breq	80003c6c <phy_rx_func+0xdf4>
800030e6:	58 48       	cp.w	r8,4
800030e8:	e0 81 06 05 	brne	80003cf2 <phy_rx_func+0xe7a>
800030ec:	e0 8f 02 4b 	bral	80003582 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800030f0:	6e 28       	ld.w	r8,r7[0x8]
800030f2:	e0 6a 5a 5a 	mov	r10,23130
800030f6:	ea 1a ab cd 	orh	r10,0xabcd
800030fa:	14 38       	cp.w	r8,r10
800030fc:	c0 71       	brne	8000310a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800030fe:	30 09       	mov	r9,0
80003100:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003104:	91 09       	st.w	r8[0x0],r9
80003106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000310a:	10 99       	mov	r9,r8
8000310c:	e0 19 00 00 	andl	r9,0x0
80003110:	fc 1a ab cd 	movh	r10,0xabcd
80003114:	14 39       	cp.w	r9,r10
80003116:	e0 81 05 ee 	brne	80003cf2 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000311a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000311e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003122:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003124:	6e 29       	ld.w	r9,r7[0x8]
80003126:	e2 19 f0 00 	andl	r9,0xf000,COH
8000312a:	e0 49 c0 00 	cp.w	r9,49152
8000312e:	e0 81 00 ce 	brne	800032ca <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003132:	30 1a       	mov	r10,1
80003134:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003138:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000313a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000313e:	72 09       	ld.w	r9,r9[0x0]
80003140:	58 09       	cp.w	r9,0
80003142:	c0 71       	brne	80003150 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003144:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003148:	f0 1f 03 00 	mcall	80003d48 <phy_rx_func+0xed0>
8000314c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003150:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003154:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003158:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000315a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000315e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003162:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003166:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003168:	13 89       	ld.ub	r9,r9[0x0]
8000316a:	37 fa       	mov	r10,127
8000316c:	f4 09 18 00 	cp.b	r9,r10
80003170:	c6 d0       	breq	8000324a <phy_rx_func+0x3d2>
80003172:	e0 8b 00 0c 	brhi	8000318a <phy_rx_func+0x312>
80003176:	31 2a       	mov	r10,18
80003178:	f4 09 18 00 	cp.b	r9,r10
8000317c:	c4 20       	breq	80003200 <phy_rx_func+0x388>
8000317e:	31 3a       	mov	r10,19
80003180:	f4 09 18 00 	cp.b	r9,r10
80003184:	e0 81 00 83 	brne	8000328a <phy_rx_func+0x412>
80003188:	c5 b8       	rjmp	8000323e <phy_rx_func+0x3c6>
8000318a:	2f 09       	sub	r9,-16
8000318c:	30 1a       	mov	r10,1
8000318e:	f4 09 18 00 	cp.b	r9,r10
80003192:	e0 8b 00 7c 	brhi	8000328a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003196:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000319a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000319e:	59 08       	cp.w	r8,16
800031a0:	c0 71       	brne	800031ae <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800031a2:	30 19       	mov	r9,1
800031a4:	fe f8 0b 94 	ld.w	r8,pc[2964]
800031a8:	91 09       	st.w	r8[0x0],r9
800031aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800031ae:	e0 48 00 20 	cp.w	r8,32
800031b2:	c2 11       	brne	800031f4 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800031b4:	30 a9       	mov	r9,10
800031b6:	fe f8 0b 82 	ld.w	r8,pc[2946]
800031ba:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800031bc:	fe f6 0b 98 	ld.w	r6,pc[2968]
800031c0:	6c 08       	ld.w	r8,r6[0x0]
800031c2:	f0 0a 11 ff 	rsub	r10,r8,-1
800031c6:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800031ca:	2f f8       	sub	r8,-1
800031cc:	6e 0c       	ld.w	r12,r7[0x0]
800031ce:	f4 ca fe 00 	sub	r10,r10,-512
800031d2:	30 0b       	mov	r11,0
800031d4:	10 0c       	add	r12,r8
800031d6:	f0 1f 02 e1 	mcall	80003d58 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
800031da:	30 08       	mov	r8,0
800031dc:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800031de:	6e 0c       	ld.w	r12,r7[0x0]
800031e0:	f0 1f 02 df 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800031e4:	fe f8 0b 44 	ld.w	r8,pc[2884]
800031e8:	70 0c       	ld.w	r12,r8[0x0]
800031ea:	f0 1f 02 ca 	mcall	80003d10 <phy_rx_func+0xe98>
800031ee:	8f 0c       	st.w	r7[0x0],r12
800031f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800031f4:	30 09       	mov	r9,0
800031f6:	fe f8 0b 42 	ld.w	r8,pc[2882]
800031fa:	91 09       	st.w	r8[0x0],r9
800031fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003200:	20 48       	sub	r8,4
80003202:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003206:	93 08       	st.w	r9[0x0],r8
80003208:	58 08       	cp.w	r8,0
8000320a:	e0 80 05 74 	breq	80003cf2 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000320e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003212:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003216:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000321a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000321c:	8e 69       	ld.sh	r9,r7[0xc]
8000321e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003222:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003224:	8e 79       	ld.sh	r9,r7[0xe]
80003226:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003228:	f0 1f 02 d0 	mcall	80003d68 <phy_rx_func+0xef0>
8000322c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003230:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003232:	30 49       	mov	r9,4
80003234:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000323e:	30 09       	mov	r9,0
80003240:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003244:	91 09       	st.w	r8[0x0],r9
80003246:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000324a:	20 48       	sub	r8,4
8000324c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003250:	93 08       	st.w	r9[0x0],r8
80003252:	58 08       	cp.w	r8,0
80003254:	e0 80 05 4f 	breq	80003cf2 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003258:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000325c:	70 09       	ld.w	r9,r8[0x0]
8000325e:	8e 7b       	ld.sh	r11,r7[0xe]
80003260:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003264:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003268:	2f f9       	sub	r9,-1
8000326a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000326c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003270:	70 09       	ld.w	r9,r8[0x0]
80003272:	20 29       	sub	r9,2
80003274:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003276:	30 29       	mov	r9,2
80003278:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000327c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000327e:	30 39       	mov	r9,3
80003280:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003284:	91 09       	st.w	r8[0x0],r9
80003286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000328a:	30 3a       	mov	r10,3
8000328c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003290:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003292:	6e 2a       	ld.w	r10,r7[0x8]
80003294:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003298:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000329a:	6e 3a       	ld.w	r10,r7[0xc]
8000329c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000329e:	59 48       	cp.w	r8,20
800032a0:	c0 61       	brne	800032ac <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800032a2:	31 89       	mov	r9,24
800032a4:	fe f8 0a 98 	ld.w	r8,pc[2712]
800032a8:	91 09       	st.w	r8[0x0],r9
800032aa:	c0 a8       	rjmp	800032be <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800032ac:	fe f8 0a 90 	ld.w	r8,pc[2704]
800032b0:	70 08       	ld.w	r8,r8[0x0]
800032b2:	59 08       	cp.w	r8,16
800032b4:	c0 51       	brne	800032be <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800032b6:	31 09       	mov	r9,16
800032b8:	fe f8 0a 84 	ld.w	r8,pc[2692]
800032bc:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800032be:	30 49       	mov	r9,4
800032c0:	fe f8 0a 74 	ld.w	r8,pc[2676]
800032c4:	91 09       	st.w	r8[0x0],r9
800032c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800032ca:	e0 49 10 00 	cp.w	r9,4096
800032ce:	5f 1a       	srne	r10
800032d0:	e0 49 20 00 	cp.w	r9,8192
800032d4:	5f 19       	srne	r9
800032d6:	f5 e9 00 09 	and	r9,r10,r9
800032da:	e0 81 05 0c 	brne	80003cf2 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800032de:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800032e2:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800032e4:	fe fa 0a 98 	ld.w	r10,pc[2712]
800032e8:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800032ea:	fe fa 0a 62 	ld.w	r10,pc[2658]
800032ee:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800032f0:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800032f4:	72 09       	ld.w	r9,r9[0x0]
800032f6:	58 09       	cp.w	r9,0
800032f8:	c0 71       	brne	80003306 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032fa:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800032fe:	f0 1f 02 93 	mcall	80003d48 <phy_rx_func+0xed0>
80003302:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003306:	6e 2a       	ld.w	r10,r7[0x8]
80003308:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000330c:	58 1a       	cp.w	r10,1
8000330e:	e0 8b 00 4d 	brhi	800033a8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003312:	20 48       	sub	r8,4
80003314:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003318:	93 08       	st.w	r9[0x0],r8
8000331a:	58 08       	cp.w	r8,0
8000331c:	e0 80 04 eb 	breq	80003cf2 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003320:	8e 68       	ld.sh	r8,r7[0xc]
80003322:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003326:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000332a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000332c:	30 09       	mov	r9,0
8000332e:	f2 08 19 00 	cp.h	r8,r9
80003332:	c0 70       	breq	80003340 <phy_rx_func+0x4c8>
80003334:	30 19       	mov	r9,1
80003336:	f2 08 19 00 	cp.h	r8,r9
8000333a:	e0 81 04 dc 	brne	80003cf2 <phy_rx_func+0xe7a>
8000333e:	c2 68       	rjmp	8000338a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003340:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003344:	70 0a       	ld.w	r10,r8[0x0]
80003346:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000334a:	72 09       	ld.w	r9,r9[0x0]
8000334c:	8e 7b       	ld.sh	r11,r7[0xe]
8000334e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003352:	70 09       	ld.w	r9,r8[0x0]
80003354:	2f f9       	sub	r9,-1
80003356:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003358:	e0 49 00 ff 	cp.w	r9,255
8000335c:	e0 88 00 11 	brls	8000337e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003360:	30 09       	mov	r9,0
80003362:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003364:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003368:	6e 0c       	ld.w	r12,r7[0x0]
8000336a:	f0 1f 02 7d 	mcall	80003d5c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000336e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003372:	70 0c       	ld.w	r12,r8[0x0]
80003374:	f0 1f 02 67 	mcall	80003d10 <phy_rx_func+0xe98>
80003378:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000337a:	e0 80 04 bc 	breq	80003cf2 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000337e:	30 29       	mov	r9,2
80003380:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003384:	91 09       	st.w	r8[0x0],r9
80003386:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000338a:	8e 79       	ld.sh	r9,r7[0xe]
8000338c:	30 38       	mov	r8,3
8000338e:	f0 09 19 00 	cp.h	r9,r8
80003392:	c0 51       	brne	8000339c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003394:	30 19       	mov	r9,1
80003396:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000339a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000339c:	30 29       	mov	r9,2
8000339e:	fe f8 09 96 	ld.w	r8,pc[2454]
800033a2:	91 09       	st.w	r8[0x0],r9
800033a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800033a8:	58 18       	cp.w	r8,1
800033aa:	e0 88 04 a4 	brls	80003cf2 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800033ae:	fe f8 09 d6 	ld.w	r8,pc[2518]
800033b2:	70 0a       	ld.w	r10,r8[0x0]
800033b4:	6e 3b       	ld.w	r11,r7[0xc]
800033b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033ba:	70 09       	ld.w	r9,r8[0x0]
800033bc:	2f f9       	sub	r9,-1
800033be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033c0:	e0 49 00 ff 	cp.w	r9,255
800033c4:	e0 88 00 11 	brls	800033e6 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800033c8:	30 09       	mov	r9,0
800033ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033cc:	fe f7 09 60 	ld.w	r7,pc[2400]
800033d0:	6e 0c       	ld.w	r12,r7[0x0]
800033d2:	f0 1f 02 63 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033d6:	fe f8 09 52 	ld.w	r8,pc[2386]
800033da:	70 0c       	ld.w	r12,r8[0x0]
800033dc:	f0 1f 02 4d 	mcall	80003d10 <phy_rx_func+0xe98>
800033e0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033e2:	e0 80 04 88 	breq	80003cf2 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800033e6:	fe f9 09 56 	ld.w	r9,pc[2390]
800033ea:	72 08       	ld.w	r8,r9[0x0]
800033ec:	20 28       	sub	r8,2
800033ee:	93 08       	st.w	r9[0x0],r8
800033f0:	e0 80 04 81 	breq	80003cf2 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800033f4:	30 29       	mov	r9,2
800033f6:	fe f8 09 3e 	ld.w	r8,pc[2366]
800033fa:	91 09       	st.w	r8[0x0],r9
800033fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003400:	fe f8 09 84 	ld.w	r8,pc[2436]
80003404:	70 0a       	ld.w	r10,r8[0x0]
80003406:	fe f9 09 26 	ld.w	r9,pc[2342]
8000340a:	72 09       	ld.w	r9,r9[0x0]
8000340c:	8e 4b       	ld.sh	r11,r7[0x8]
8000340e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003412:	70 09       	ld.w	r9,r8[0x0]
80003414:	2f f9       	sub	r9,-1
80003416:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003418:	e0 49 00 ff 	cp.w	r9,255
8000341c:	e0 88 00 16 	brls	80003448 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003420:	30 09       	mov	r9,0
80003422:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003424:	fe f6 09 08 	ld.w	r6,pc[2312]
80003428:	6c 0c       	ld.w	r12,r6[0x0]
8000342a:	f0 1f 02 4d 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000342e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003432:	70 0c       	ld.w	r12,r8[0x0]
80003434:	f0 1f 02 37 	mcall	80003d10 <phy_rx_func+0xe98>
80003438:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000343a:	c0 71       	brne	80003448 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000343c:	30 09       	mov	r9,0
8000343e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003442:	91 09       	st.w	r8[0x0],r9
80003444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003448:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000344c:	72 08       	ld.w	r8,r9[0x0]
8000344e:	20 28       	sub	r8,2
80003450:	93 08       	st.w	r9[0x0],r8
80003452:	c0 71       	brne	80003460 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003454:	30 09       	mov	r9,0
80003456:	fe f8 08 de 	ld.w	r8,pc[2270]
8000345a:	91 09       	st.w	r8[0x0],r9
8000345c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003460:	fe f8 09 24 	ld.w	r8,pc[2340]
80003464:	70 0a       	ld.w	r10,r8[0x0]
80003466:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000346a:	72 09       	ld.w	r9,r9[0x0]
8000346c:	8e 5b       	ld.sh	r11,r7[0xa]
8000346e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003472:	70 09       	ld.w	r9,r8[0x0]
80003474:	2f f9       	sub	r9,-1
80003476:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003478:	e0 49 00 ff 	cp.w	r9,255
8000347c:	e0 88 00 16 	brls	800034a8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003480:	30 09       	mov	r9,0
80003482:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003484:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003488:	6c 0c       	ld.w	r12,r6[0x0]
8000348a:	f0 1f 02 35 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000348e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003492:	70 0c       	ld.w	r12,r8[0x0]
80003494:	f0 1f 02 1f 	mcall	80003d10 <phy_rx_func+0xe98>
80003498:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000349a:	c0 71       	brne	800034a8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000349c:	30 09       	mov	r9,0
8000349e:	fe f8 08 96 	ld.w	r8,pc[2198]
800034a2:	91 09       	st.w	r8[0x0],r9
800034a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034a8:	fe f9 08 94 	ld.w	r9,pc[2196]
800034ac:	72 08       	ld.w	r8,r9[0x0]
800034ae:	20 28       	sub	r8,2
800034b0:	93 08       	st.w	r9[0x0],r8
800034b2:	c0 71       	brne	800034c0 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800034b4:	30 09       	mov	r9,0
800034b6:	fe f8 08 7e 	ld.w	r8,pc[2174]
800034ba:	91 09       	st.w	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800034c0:	fe f8 08 c4 	ld.w	r8,pc[2244]
800034c4:	70 0a       	ld.w	r10,r8[0x0]
800034c6:	fe f9 08 66 	ld.w	r9,pc[2150]
800034ca:	72 09       	ld.w	r9,r9[0x0]
800034cc:	8e 6b       	ld.sh	r11,r7[0xc]
800034ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034d2:	70 09       	ld.w	r9,r8[0x0]
800034d4:	2f f9       	sub	r9,-1
800034d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034d8:	e0 49 00 ff 	cp.w	r9,255
800034dc:	e0 88 00 16 	brls	80003508 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800034e0:	30 09       	mov	r9,0
800034e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034e4:	fe f6 08 48 	ld.w	r6,pc[2120]
800034e8:	6c 0c       	ld.w	r12,r6[0x0]
800034ea:	f0 1f 02 1d 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034ee:	fe f8 08 3a 	ld.w	r8,pc[2106]
800034f2:	70 0c       	ld.w	r12,r8[0x0]
800034f4:	f0 1f 02 07 	mcall	80003d10 <phy_rx_func+0xe98>
800034f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034fa:	c0 71       	brne	80003508 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 08 36 	ld.w	r8,pc[2102]
80003502:	91 09       	st.w	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003508:	fe f9 08 34 	ld.w	r9,pc[2100]
8000350c:	72 08       	ld.w	r8,r9[0x0]
8000350e:	20 28       	sub	r8,2
80003510:	93 08       	st.w	r9[0x0],r8
80003512:	c0 71       	brne	80003520 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003514:	30 09       	mov	r9,0
80003516:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000351a:	91 09       	st.w	r8[0x0],r9
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003520:	fe f8 08 64 	ld.w	r8,pc[2148]
80003524:	70 0a       	ld.w	r10,r8[0x0]
80003526:	fe f9 08 06 	ld.w	r9,pc[2054]
8000352a:	72 09       	ld.w	r9,r9[0x0]
8000352c:	8e 7b       	ld.sh	r11,r7[0xe]
8000352e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003532:	70 09       	ld.w	r9,r8[0x0]
80003534:	2f f9       	sub	r9,-1
80003536:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003538:	e0 49 00 ff 	cp.w	r9,255
8000353c:	e0 88 00 16 	brls	80003568 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003540:	30 09       	mov	r9,0
80003542:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003544:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003548:	6e 0c       	ld.w	r12,r7[0x0]
8000354a:	f0 1f 02 05 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000354e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003552:	70 0c       	ld.w	r12,r8[0x0]
80003554:	f0 1f 01 ef 	mcall	80003d10 <phy_rx_func+0xe98>
80003558:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000355a:	c0 71       	brne	80003568 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000355c:	30 09       	mov	r9,0
8000355e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003562:	91 09       	st.w	r8[0x0],r9
80003564:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003568:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000356c:	72 08       	ld.w	r8,r9[0x0]
8000356e:	20 28       	sub	r8,2
80003570:	93 08       	st.w	r9[0x0],r8
80003572:	e0 81 03 c0 	brne	80003cf2 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003576:	30 09       	mov	r9,0
80003578:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000357c:	91 09       	st.w	r8[0x0],r9
8000357e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003582:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003586:	11 89       	ld.ub	r9,r8[0x0]
80003588:	31 28       	mov	r8,18
8000358a:	f0 09 18 00 	cp.b	r9,r8
8000358e:	e0 81 01 4c 	brne	80003826 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003592:	ef 39 00 09 	ld.ub	r9,r7[9]
80003596:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000359a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000359c:	11 89       	ld.ub	r9,r8[0x0]
8000359e:	3f 28       	mov	r8,-14
800035a0:	f0 09 18 00 	cp.b	r9,r8
800035a4:	e0 81 01 3b 	brne	8000381a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800035a8:	30 19       	mov	r9,1
800035aa:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035ae:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800035b0:	6e 29       	ld.w	r9,r7[0x8]
800035b2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800035b6:	fe f8 07 86 	ld.w	r8,pc[1926]
800035ba:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800035bc:	8e 59       	ld.sh	r9,r7[0xa]
800035be:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035c2:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800035c4:	8e 69       	ld.sh	r9,r7[0xc]
800035c6:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800035c8:	8e 79       	ld.sh	r9,r7[0xe]
800035ca:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800035cc:	fe f8 07 88 	ld.w	r8,pc[1928]
800035d0:	fe f9 07 60 	ld.w	r9,pc[1888]
800035d4:	72 0a       	ld.w	r10,r9[0x0]
800035d6:	70 09       	ld.w	r9,r8[0x0]
800035d8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800035dc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035e0:	70 09       	ld.w	r9,r8[0x0]
800035e2:	2f f9       	sub	r9,-1
800035e4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035e6:	e0 49 01 ff 	cp.w	r9,511
800035ea:	e0 88 00 16 	brls	80003616 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ee:	30 09       	mov	r9,0
800035f0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035f2:	fe f6 07 3e 	ld.w	r6,pc[1854]
800035f6:	6c 0c       	ld.w	r12,r6[0x0]
800035f8:	f0 1f 01 d9 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035fc:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003600:	70 0c       	ld.w	r12,r8[0x0]
80003602:	f0 1f 01 c4 	mcall	80003d10 <phy_rx_func+0xe98>
80003606:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003608:	c0 71       	brne	80003616 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000360a:	30 09       	mov	r9,0
8000360c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003610:	91 09       	st.w	r8[0x0],r9
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003616:	fe f9 07 26 	ld.w	r9,pc[1830]
8000361a:	72 08       	ld.w	r8,r9[0x0]
8000361c:	20 18       	sub	r8,1
8000361e:	93 08       	st.w	r9[0x0],r8
80003620:	c0 71       	brne	8000362e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003622:	30 09       	mov	r9,0
80003624:	fe f8 07 10 	ld.w	r8,pc[1808]
80003628:	91 09       	st.w	r8[0x0],r9
8000362a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000362e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003632:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003636:	72 0a       	ld.w	r10,r9[0x0]
80003638:	70 09       	ld.w	r9,r8[0x0]
8000363a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000363e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003642:	70 09       	ld.w	r9,r8[0x0]
80003644:	2f f9       	sub	r9,-1
80003646:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003648:	e0 49 01 ff 	cp.w	r9,511
8000364c:	e0 88 00 16 	brls	80003678 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003650:	30 09       	mov	r9,0
80003652:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003654:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003658:	6c 0c       	ld.w	r12,r6[0x0]
8000365a:	f0 1f 01 c1 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000365e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003662:	70 0c       	ld.w	r12,r8[0x0]
80003664:	f0 1f 01 ab 	mcall	80003d10 <phy_rx_func+0xe98>
80003668:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000366a:	c0 71       	brne	80003678 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
8000366c:	30 09       	mov	r9,0
8000366e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003678:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000367c:	72 08       	ld.w	r8,r9[0x0]
8000367e:	20 18       	sub	r8,1
80003680:	93 08       	st.w	r9[0x0],r8
80003682:	c0 71       	brne	80003690 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003684:	30 09       	mov	r9,0
80003686:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000368a:	91 09       	st.w	r8[0x0],r9
8000368c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003690:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003694:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003698:	72 0a       	ld.w	r10,r9[0x0]
8000369a:	70 09       	ld.w	r9,r8[0x0]
8000369c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800036a0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036a4:	70 09       	ld.w	r9,r8[0x0]
800036a6:	2f f9       	sub	r9,-1
800036a8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036aa:	e0 49 01 ff 	cp.w	r9,511
800036ae:	e0 88 00 16 	brls	800036da <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800036b2:	30 09       	mov	r9,0
800036b4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036b6:	fe f6 06 7a 	ld.w	r6,pc[1658]
800036ba:	6c 0c       	ld.w	r12,r6[0x0]
800036bc:	f0 1f 01 a8 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036c0:	fe f8 06 68 	ld.w	r8,pc[1640]
800036c4:	70 0c       	ld.w	r12,r8[0x0]
800036c6:	f0 1f 01 93 	mcall	80003d10 <phy_rx_func+0xe98>
800036ca:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036cc:	c0 71       	brne	800036da <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800036ce:	30 09       	mov	r9,0
800036d0:	fe f8 06 64 	ld.w	r8,pc[1636]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036da:	fe f9 06 62 	ld.w	r9,pc[1634]
800036de:	72 08       	ld.w	r8,r9[0x0]
800036e0:	20 18       	sub	r8,1
800036e2:	93 08       	st.w	r9[0x0],r8
800036e4:	c0 71       	brne	800036f2 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800036e6:	30 09       	mov	r9,0
800036e8:	fe f8 06 4c 	ld.w	r8,pc[1612]
800036ec:	91 09       	st.w	r8[0x0],r9
800036ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800036f2:	fe f8 06 62 	ld.w	r8,pc[1634]
800036f6:	fe f9 06 3a 	ld.w	r9,pc[1594]
800036fa:	72 0a       	ld.w	r10,r9[0x0]
800036fc:	70 09       	ld.w	r9,r8[0x0]
800036fe:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003702:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003706:	70 09       	ld.w	r9,r8[0x0]
80003708:	2f f9       	sub	r9,-1
8000370a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000370c:	e0 49 01 ff 	cp.w	r9,511
80003710:	e0 88 00 16 	brls	8000373c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003714:	30 09       	mov	r9,0
80003716:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003718:	fe f6 06 18 	ld.w	r6,pc[1560]
8000371c:	6c 0c       	ld.w	r12,r6[0x0]
8000371e:	f0 1f 01 90 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003722:	fe f8 06 06 	ld.w	r8,pc[1542]
80003726:	70 0c       	ld.w	r12,r8[0x0]
80003728:	f0 1f 01 7a 	mcall	80003d10 <phy_rx_func+0xe98>
8000372c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000372e:	c0 71       	brne	8000373c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003730:	30 09       	mov	r9,0
80003732:	fe f8 06 02 	ld.w	r8,pc[1538]
80003736:	91 09       	st.w	r8[0x0],r9
80003738:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000373c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003740:	72 08       	ld.w	r8,r9[0x0]
80003742:	20 18       	sub	r8,1
80003744:	93 08       	st.w	r9[0x0],r8
80003746:	c0 71       	brne	80003754 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003748:	30 09       	mov	r9,0
8000374a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000374e:	91 09       	st.w	r8[0x0],r9
80003750:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003754:	fe f8 06 00 	ld.w	r8,pc[1536]
80003758:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000375c:	72 0a       	ld.w	r10,r9[0x0]
8000375e:	70 09       	ld.w	r9,r8[0x0]
80003760:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003764:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003768:	70 09       	ld.w	r9,r8[0x0]
8000376a:	2f f9       	sub	r9,-1
8000376c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000376e:	e0 49 01 ff 	cp.w	r9,511
80003772:	e0 88 00 16 	brls	8000379e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003776:	30 09       	mov	r9,0
80003778:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000377a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000377e:	6c 0c       	ld.w	r12,r6[0x0]
80003780:	f0 1f 01 77 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003784:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003788:	70 0c       	ld.w	r12,r8[0x0]
8000378a:	f0 1f 01 62 	mcall	80003d10 <phy_rx_func+0xe98>
8000378e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003790:	c0 71       	brne	8000379e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003792:	30 09       	mov	r9,0
80003794:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003798:	91 09       	st.w	r8[0x0],r9
8000379a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000379e:	fe f9 05 9e 	ld.w	r9,pc[1438]
800037a2:	72 08       	ld.w	r8,r9[0x0]
800037a4:	20 18       	sub	r8,1
800037a6:	93 08       	st.w	r9[0x0],r8
800037a8:	c0 71       	brne	800037b6 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800037aa:	30 09       	mov	r9,0
800037ac:	fe f8 05 88 	ld.w	r8,pc[1416]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800037b6:	fe f8 05 9e 	ld.w	r8,pc[1438]
800037ba:	fe f9 05 76 	ld.w	r9,pc[1398]
800037be:	72 0a       	ld.w	r10,r9[0x0]
800037c0:	70 09       	ld.w	r9,r8[0x0]
800037c2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800037c6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037ca:	70 09       	ld.w	r9,r8[0x0]
800037cc:	2f f9       	sub	r9,-1
800037ce:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037d0:	e0 49 01 ff 	cp.w	r9,511
800037d4:	e0 88 00 16 	brls	80003800 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800037d8:	30 09       	mov	r9,0
800037da:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037dc:	fe f7 05 54 	ld.w	r7,pc[1364]
800037e0:	6e 0c       	ld.w	r12,r7[0x0]
800037e2:	f0 1f 01 5f 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037e6:	fe f8 05 42 	ld.w	r8,pc[1346]
800037ea:	70 0c       	ld.w	r12,r8[0x0]
800037ec:	f0 1f 01 49 	mcall	80003d10 <phy_rx_func+0xe98>
800037f0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f2:	c0 71       	brne	80003800 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800037f4:	30 09       	mov	r9,0
800037f6:	fe f8 05 3e 	ld.w	r8,pc[1342]
800037fa:	91 09       	st.w	r8[0x0],r9
800037fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003800:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003804:	72 08       	ld.w	r8,r9[0x0]
80003806:	20 18       	sub	r8,1
80003808:	93 08       	st.w	r9[0x0],r8
8000380a:	e0 81 02 74 	brne	80003cf2 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000380e:	30 09       	mov	r9,0
80003810:	fe f8 05 24 	ld.w	r8,pc[1316]
80003814:	91 09       	st.w	r8[0x0],r9
80003816:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000381a:	30 09       	mov	r9,0
8000381c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003820:	91 09       	st.w	r8[0x0],r9
80003822:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003826:	fe f8 05 26 	ld.w	r8,pc[1318]
8000382a:	11 89       	ld.ub	r9,r8[0x0]
8000382c:	3f 28       	mov	r8,-14
8000382e:	f0 09 18 00 	cp.b	r9,r8
80003832:	c4 31       	brne	800038b8 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003834:	8e 49       	ld.sh	r9,r7[0x8]
80003836:	fe f8 05 56 	ld.w	r8,pc[1366]
8000383a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000383c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003840:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003844:	72 0a       	ld.w	r10,r9[0x0]
80003846:	70 09       	ld.w	r9,r8[0x0]
80003848:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000384c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003850:	70 09       	ld.w	r9,r8[0x0]
80003852:	2f f9       	sub	r9,-1
80003854:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003856:	e0 49 01 ff 	cp.w	r9,511
8000385a:	e0 88 00 16 	brls	80003886 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000385e:	30 09       	mov	r9,0
80003860:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003862:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003866:	6e 0c       	ld.w	r12,r7[0x0]
80003868:	f0 1f 01 3d 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000386c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003870:	70 0c       	ld.w	r12,r8[0x0]
80003872:	f0 1f 01 28 	mcall	80003d10 <phy_rx_func+0xe98>
80003876:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003878:	c0 71       	brne	80003886 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000387a:	30 09       	mov	r9,0
8000387c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003880:	91 09       	st.w	r8[0x0],r9
80003882:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003886:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000388a:	72 08       	ld.w	r8,r9[0x0]
8000388c:	20 18       	sub	r8,1
8000388e:	93 08       	st.w	r9[0x0],r8
80003890:	c0 71       	brne	8000389e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003892:	30 09       	mov	r9,0
80003894:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003898:	91 09       	st.w	r8[0x0],r9
8000389a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000389e:	20 18       	sub	r8,1
800038a0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800038a4:	93 08       	st.w	r9[0x0],r8
800038a6:	58 08       	cp.w	r8,0
800038a8:	e0 81 02 25 	brne	80003cf2 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800038ac:	30 09       	mov	r9,0
800038ae:	fe f8 04 86 	ld.w	r8,pc[1158]
800038b2:	91 09       	st.w	r8[0x0],r9
800038b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800038b8:	fe f8 04 94 	ld.w	r8,pc[1172]
800038bc:	11 89       	ld.ub	r9,r8[0x0]
800038be:	3f 38       	mov	r8,-13
800038c0:	f0 09 18 00 	cp.b	r9,r8
800038c4:	e0 81 01 0c 	brne	80003adc <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800038c8:	8e 49       	ld.sh	r9,r7[0x8]
800038ca:	fe f8 04 c2 	ld.w	r8,pc[1218]
800038ce:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800038d0:	8e 59       	ld.sh	r9,r7[0xa]
800038d2:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800038d4:	8e 69       	ld.sh	r9,r7[0xc]
800038d6:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800038d8:	fe f8 04 7c 	ld.w	r8,pc[1148]
800038dc:	fe f9 04 54 	ld.w	r9,pc[1108]
800038e0:	72 0a       	ld.w	r10,r9[0x0]
800038e2:	70 09       	ld.w	r9,r8[0x0]
800038e4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800038e8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ec:	70 09       	ld.w	r9,r8[0x0]
800038ee:	2f f9       	sub	r9,-1
800038f0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f2:	e0 49 01 ff 	cp.w	r9,511
800038f6:	e0 88 00 16 	brls	80003922 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800038fa:	30 09       	mov	r9,0
800038fc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038fe:	fe f6 04 32 	ld.w	r6,pc[1074]
80003902:	6c 0c       	ld.w	r12,r6[0x0]
80003904:	f0 1f 01 16 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003908:	fe f8 04 20 	ld.w	r8,pc[1056]
8000390c:	70 0c       	ld.w	r12,r8[0x0]
8000390e:	f0 1f 01 01 	mcall	80003d10 <phy_rx_func+0xe98>
80003912:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003914:	c0 71       	brne	80003922 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003922:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003926:	72 08       	ld.w	r8,r9[0x0]
80003928:	20 18       	sub	r8,1
8000392a:	93 08       	st.w	r9[0x0],r8
8000392c:	c0 71       	brne	8000393a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000392e:	30 09       	mov	r9,0
80003930:	fe f8 04 04 	ld.w	r8,pc[1028]
80003934:	91 09       	st.w	r8[0x0],r9
80003936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000393a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000393e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003942:	72 0a       	ld.w	r10,r9[0x0]
80003944:	70 09       	ld.w	r9,r8[0x0]
80003946:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000394a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000394e:	70 09       	ld.w	r9,r8[0x0]
80003950:	2f f9       	sub	r9,-1
80003952:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003954:	e0 49 01 ff 	cp.w	r9,511
80003958:	e0 88 00 16 	brls	80003984 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000395c:	30 09       	mov	r9,0
8000395e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003960:	fe f6 03 d0 	ld.w	r6,pc[976]
80003964:	6c 0c       	ld.w	r12,r6[0x0]
80003966:	f0 1f 00 fe 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000396a:	fe f8 03 be 	ld.w	r8,pc[958]
8000396e:	70 0c       	ld.w	r12,r8[0x0]
80003970:	f0 1f 00 e8 	mcall	80003d10 <phy_rx_func+0xe98>
80003974:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003976:	c0 71       	brne	80003984 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003984:	fe f9 03 b8 	ld.w	r9,pc[952]
80003988:	72 08       	ld.w	r8,r9[0x0]
8000398a:	20 18       	sub	r8,1
8000398c:	93 08       	st.w	r9[0x0],r8
8000398e:	c0 71       	brne	8000399c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003990:	30 09       	mov	r9,0
80003992:	fe f8 03 a2 	ld.w	r8,pc[930]
80003996:	91 09       	st.w	r8[0x0],r9
80003998:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000399c:	fe f8 03 b8 	ld.w	r8,pc[952]
800039a0:	fe f9 03 90 	ld.w	r9,pc[912]
800039a4:	72 0a       	ld.w	r10,r9[0x0]
800039a6:	70 09       	ld.w	r9,r8[0x0]
800039a8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039ac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039b0:	70 09       	ld.w	r9,r8[0x0]
800039b2:	2f f9       	sub	r9,-1
800039b4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b6:	e0 49 01 ff 	cp.w	r9,511
800039ba:	e0 88 00 16 	brls	800039e6 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039be:	30 09       	mov	r9,0
800039c0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039c2:	fe f6 03 6e 	ld.w	r6,pc[878]
800039c6:	6c 0c       	ld.w	r12,r6[0x0]
800039c8:	f0 1f 00 e5 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039cc:	fe f8 03 5c 	ld.w	r8,pc[860]
800039d0:	70 0c       	ld.w	r12,r8[0x0]
800039d2:	f0 1f 00 d0 	mcall	80003d10 <phy_rx_func+0xe98>
800039d6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039d8:	c0 71       	brne	800039e6 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	fe f8 03 58 	ld.w	r8,pc[856]
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039e6:	fe f9 03 56 	ld.w	r9,pc[854]
800039ea:	72 08       	ld.w	r8,r9[0x0]
800039ec:	20 18       	sub	r8,1
800039ee:	93 08       	st.w	r9[0x0],r8
800039f0:	c0 71       	brne	800039fe <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800039f2:	30 09       	mov	r9,0
800039f4:	fe f8 03 40 	ld.w	r8,pc[832]
800039f8:	91 09       	st.w	r8[0x0],r9
800039fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800039fe:	fe f8 03 56 	ld.w	r8,pc[854]
80003a02:	fe f9 03 2e 	ld.w	r9,pc[814]
80003a06:	72 0a       	ld.w	r10,r9[0x0]
80003a08:	70 09       	ld.w	r9,r8[0x0]
80003a0a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a0e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	2f f9       	sub	r9,-1
80003a16:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a18:	e0 49 01 ff 	cp.w	r9,511
80003a1c:	e0 88 00 16 	brls	80003a48 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a20:	30 09       	mov	r9,0
80003a22:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a24:	fe f6 03 0c 	ld.w	r6,pc[780]
80003a28:	6c 0c       	ld.w	r12,r6[0x0]
80003a2a:	f0 1f 00 cd 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a2e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003a32:	70 0c       	ld.w	r12,r8[0x0]
80003a34:	f0 1f 00 b7 	mcall	80003d10 <phy_rx_func+0xe98>
80003a38:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a3a:	c0 71       	brne	80003a48 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003a3c:	30 09       	mov	r9,0
80003a3e:	fe f8 02 f6 	ld.w	r8,pc[758]
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a48:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a4c:	72 08       	ld.w	r8,r9[0x0]
80003a4e:	20 18       	sub	r8,1
80003a50:	93 08       	st.w	r9[0x0],r8
80003a52:	c0 71       	brne	80003a60 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a54:	30 09       	mov	r9,0
80003a56:	fe f8 02 de 	ld.w	r8,pc[734]
80003a5a:	91 09       	st.w	r8[0x0],r9
80003a5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003a60:	fe f8 02 f4 	ld.w	r8,pc[756]
80003a64:	fe f9 02 cc 	ld.w	r9,pc[716]
80003a68:	72 0a       	ld.w	r10,r9[0x0]
80003a6a:	70 09       	ld.w	r9,r8[0x0]
80003a6c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a70:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a74:	70 09       	ld.w	r9,r8[0x0]
80003a76:	2f f9       	sub	r9,-1
80003a78:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a7a:	e0 49 01 ff 	cp.w	r9,511
80003a7e:	e0 88 00 16 	brls	80003aaa <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a82:	30 09       	mov	r9,0
80003a84:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a86:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a8a:	6e 0c       	ld.w	r12,r7[0x0]
80003a8c:	f0 1f 00 b4 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a90:	fe f8 02 98 	ld.w	r8,pc[664]
80003a94:	70 0c       	ld.w	r12,r8[0x0]
80003a96:	f0 1f 00 9f 	mcall	80003d10 <phy_rx_func+0xe98>
80003a9a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a9c:	c0 71       	brne	80003aaa <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a9e:	30 09       	mov	r9,0
80003aa0:	fe f8 02 94 	ld.w	r8,pc[660]
80003aa4:	91 09       	st.w	r8[0x0],r9
80003aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aaa:	fe f9 02 92 	ld.w	r9,pc[658]
80003aae:	72 08       	ld.w	r8,r9[0x0]
80003ab0:	20 18       	sub	r8,1
80003ab2:	93 08       	st.w	r9[0x0],r8
80003ab4:	c0 71       	brne	80003ac2 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	fe f8 02 7c 	ld.w	r8,pc[636]
80003abc:	91 09       	st.w	r8[0x0],r9
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003ac2:	20 18       	sub	r8,1
80003ac4:	fe f9 02 78 	ld.w	r9,pc[632]
80003ac8:	93 08       	st.w	r9[0x0],r8
80003aca:	58 08       	cp.w	r8,0
80003acc:	e0 81 01 13 	brne	80003cf2 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003ad0:	30 09       	mov	r9,0
80003ad2:	fe f8 02 62 	ld.w	r8,pc[610]
80003ad6:	91 09       	st.w	r8[0x0],r9
80003ad8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003adc:	fe f8 02 70 	ld.w	r8,pc[624]
80003ae0:	11 89       	ld.ub	r9,r8[0x0]
80003ae2:	30 48       	mov	r8,4
80003ae4:	f0 09 18 00 	cp.b	r9,r8
80003ae8:	c0 80       	breq	80003af8 <phy_rx_func+0xc80>
80003aea:	fe f8 02 62 	ld.w	r8,pc[610]
80003aee:	11 89       	ld.ub	r9,r8[0x0]
80003af0:	30 38       	mov	r8,3
80003af2:	f0 09 18 00 	cp.b	r9,r8
80003af6:	c1 41       	brne	80003b1e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003af8:	6e 29       	ld.w	r9,r7[0x8]
80003afa:	fe f8 02 7a 	ld.w	r8,pc[634]
80003afe:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b00:	6e 39       	ld.w	r9,r7[0xc]
80003b02:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b04:	fe f9 02 38 	ld.w	r9,pc[568]
80003b08:	72 08       	ld.w	r8,r9[0x0]
80003b0a:	20 88       	sub	r8,8
80003b0c:	93 08       	st.w	r9[0x0],r8
80003b0e:	e0 81 00 f2 	brne	80003cf2 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003b12:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b14:	fe f9 02 20 	ld.w	r9,pc[544]
80003b18:	93 08       	st.w	r9[0x0],r8
80003b1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003b1e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003b22:	11 89       	ld.ub	r9,r8[0x0]
80003b24:	31 38       	mov	r8,19
80003b26:	f0 09 18 00 	cp.b	r9,r8
80003b2a:	e0 81 00 9c 	brne	80003c62 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003b2e:	fe f8 02 62 	ld.w	r8,pc[610]
80003b32:	11 88       	ld.ub	r8,r8[0x0]
80003b34:	30 c9       	mov	r9,12
80003b36:	f2 08 18 00 	cp.b	r8,r9
80003b3a:	e0 81 00 7b 	brne	80003c30 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003b3e:	8e 49       	ld.sh	r9,r7[0x8]
80003b40:	fe f8 02 54 	ld.w	r8,pc[596]
80003b44:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003b48:	30 09       	mov	r9,0
80003b4a:	fe f8 02 46 	ld.w	r8,pc[582]
80003b4e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b50:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b54:	3f 38       	mov	r8,-13
80003b56:	f0 09 18 00 	cp.b	r9,r8
80003b5a:	c6 61       	brne	80003c26 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003b5c:	10 99       	mov	r9,r8
80003b5e:	4f c8       	lddpc	r8,80003d4c <phy_rx_func+0xed4>
80003b60:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003b62:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003b66:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003b6a:	4f 58       	lddpc	r8,80003d3c <phy_rx_func+0xec4>
80003b6c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b6e:	30 19       	mov	r9,1
80003b70:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b74:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b76:	8e 79       	ld.sh	r9,r7[0xe]
80003b78:	fe f8 02 14 	ld.w	r8,pc[532]
80003b7c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b7e:	4f 68       	lddpc	r8,80003d54 <phy_rx_func+0xedc>
80003b80:	4e c9       	lddpc	r9,80003d30 <phy_rx_func+0xeb8>
80003b82:	72 0a       	ld.w	r10,r9[0x0]
80003b84:	70 09       	ld.w	r9,r8[0x0]
80003b86:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b8a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b8e:	70 09       	ld.w	r9,r8[0x0]
80003b90:	2f f9       	sub	r9,-1
80003b92:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b94:	e0 49 01 ff 	cp.w	r9,511
80003b98:	e0 88 00 13 	brls	80003bbe <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b9c:	30 09       	mov	r9,0
80003b9e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ba0:	4e 46       	lddpc	r6,80003d30 <phy_rx_func+0xeb8>
80003ba2:	6c 0c       	ld.w	r12,r6[0x0]
80003ba4:	f0 1f 00 6e 	mcall	80003d5c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ba8:	4e 08       	lddpc	r8,80003d28 <phy_rx_func+0xeb0>
80003baa:	70 0c       	ld.w	r12,r8[0x0]
80003bac:	f0 1f 00 59 	mcall	80003d10 <phy_rx_func+0xe98>
80003bb0:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003bb2:	c0 61       	brne	80003bbe <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003bb4:	30 09       	mov	r9,0
80003bb6:	4e 08       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003bb8:	91 09       	st.w	r8[0x0],r9
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003bbe:	4e 09       	lddpc	r9,80003d3c <phy_rx_func+0xec4>
80003bc0:	72 08       	ld.w	r8,r9[0x0]
80003bc2:	20 18       	sub	r8,1
80003bc4:	93 08       	st.w	r9[0x0],r8
80003bc6:	c0 61       	brne	80003bd2 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003bc8:	30 09       	mov	r9,0
80003bca:	4d b8       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003bcc:	91 09       	st.w	r8[0x0],r9
80003bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003bd2:	4e 18       	lddpc	r8,80003d54 <phy_rx_func+0xedc>
80003bd4:	4d 79       	lddpc	r9,80003d30 <phy_rx_func+0xeb8>
80003bd6:	72 0a       	ld.w	r10,r9[0x0]
80003bd8:	70 09       	ld.w	r9,r8[0x0]
80003bda:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003bde:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003be2:	70 09       	ld.w	r9,r8[0x0]
80003be4:	2f f9       	sub	r9,-1
80003be6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003be8:	e0 49 01 ff 	cp.w	r9,511
80003bec:	e0 88 00 13 	brls	80003c12 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003bf0:	30 09       	mov	r9,0
80003bf2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003bf4:	4c f7       	lddpc	r7,80003d30 <phy_rx_func+0xeb8>
80003bf6:	6e 0c       	ld.w	r12,r7[0x0]
80003bf8:	f0 1f 00 59 	mcall	80003d5c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bfc:	4c b8       	lddpc	r8,80003d28 <phy_rx_func+0xeb0>
80003bfe:	70 0c       	ld.w	r12,r8[0x0]
80003c00:	f0 1f 00 44 	mcall	80003d10 <phy_rx_func+0xe98>
80003c04:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c06:	c0 61       	brne	80003c12 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003c08:	30 09       	mov	r9,0
80003c0a:	4c b8       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c0c:	91 09       	st.w	r8[0x0],r9
80003c0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c12:	4c b9       	lddpc	r9,80003d3c <phy_rx_func+0xec4>
80003c14:	72 08       	ld.w	r8,r9[0x0]
80003c16:	20 18       	sub	r8,1
80003c18:	93 08       	st.w	r9[0x0],r8
80003c1a:	c6 c1       	brne	80003cf2 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003c1c:	30 09       	mov	r9,0
80003c1e:	4c 68       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c20:	91 09       	st.w	r8[0x0],r9
80003c22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003c26:	30 09       	mov	r9,0
80003c28:	4c 38       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003c30:	8e 4a       	ld.sh	r10,r7[0x8]
80003c32:	4d 99       	lddpc	r9,80003d94 <phy_rx_func+0xf1c>
80003c34:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003c38:	4d 6a       	lddpc	r10,80003d90 <phy_rx_func+0xf18>
80003c3a:	15 88       	ld.ub	r8,r10[0x0]
80003c3c:	f0 cb ff ff 	sub	r11,r8,-1
80003c40:	8e 5c       	ld.sh	r12,r7[0xa]
80003c42:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003c46:	f0 cb ff fe 	sub	r11,r8,-2
80003c4a:	8e 6c       	ld.sh	r12,r7[0xc]
80003c4c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c50:	f0 cb ff fd 	sub	r11,r8,-3
80003c54:	8e 7c       	ld.sh	r12,r7[0xe]
80003c56:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003c5a:	2f c8       	sub	r8,-4
80003c5c:	b4 88       	st.b	r10[0x0],r8
80003c5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003c62:	30 09       	mov	r9,0
80003c64:	4b 48       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003c6c:	4c 08       	lddpc	r8,80003d6c <phy_rx_func+0xef4>
80003c6e:	70 09       	ld.w	r9,r8[0x0]
80003c70:	8e 4b       	ld.sh	r11,r7[0x8]
80003c72:	4c 0a       	lddpc	r10,80003d70 <phy_rx_func+0xef8>
80003c74:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c78:	2f f9       	sub	r9,-1
80003c7a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c7c:	4b 58       	lddpc	r8,80003d50 <phy_rx_func+0xed8>
80003c7e:	70 09       	ld.w	r9,r8[0x0]
80003c80:	20 29       	sub	r9,2
80003c82:	91 09       	st.w	r8[0x0],r9
80003c84:	70 08       	ld.w	r8,r8[0x0]
80003c86:	58 08       	cp.w	r8,0
80003c88:	c2 f1       	brne	80003ce6 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c8a:	30 09       	mov	r9,0
80003c8c:	4b 88       	lddpc	r8,80003d6c <phy_rx_func+0xef4>
80003c8e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c90:	8e 59       	ld.sh	r9,r7[0xa]
80003c92:	fe 78 82 12 	mov	r8,-32238
80003c96:	f0 09 19 00 	cp.h	r9,r8
80003c9a:	c2 11       	brne	80003cdc <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c9c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003ca0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003ca4:	4a f8       	lddpc	r8,80003d60 <phy_rx_func+0xee8>
80003ca6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003ca8:	8e 59       	ld.sh	r9,r7[0xa]
80003caa:	4a f8       	lddpc	r8,80003d64 <phy_rx_func+0xeec>
80003cac:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003cae:	8e 69       	ld.sh	r9,r7[0xc]
80003cb0:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003cb2:	f0 1f 00 2e 	mcall	80003d68 <phy_rx_func+0xef0>
80003cb6:	4a 18       	lddpc	r8,80003d38 <phy_rx_func+0xec0>
80003cb8:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cba:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003cbe:	31 38       	mov	r8,19
80003cc0:	f0 09 18 00 	cp.b	r9,r8
80003cc4:	c0 71       	brne	80003cd2 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003cc6:	10 99       	mov	r9,r8
80003cc8:	4a 18       	lddpc	r8,80003d4c <phy_rx_func+0xed4>
80003cca:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003ccc:	30 09       	mov	r9,0
80003cce:	49 c8       	lddpc	r8,80003d3c <phy_rx_func+0xec4>
80003cd0:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003cd2:	30 49       	mov	r9,4
80003cd4:	49 88       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003cd6:	91 09       	st.w	r8[0x0],r9
80003cd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003cdc:	30 09       	mov	r9,0
80003cde:	49 68       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003ce0:	91 09       	st.w	r8[0x0],r9
80003ce2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ce6:	4a dc       	lddpc	r12,80003d98 <phy_rx_func+0xf20>
80003ce8:	f0 1f 00 18 	mcall	80003d48 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003cec:	30 09       	mov	r9,0
80003cee:	49 28       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003cf0:	91 09       	st.w	r8[0x0],r9
80003cf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003cf6:	00 00       	add	r0,r0
80003cf8:	00 00       	add	r0,r0
80003cfa:	0a b8       	st.h	r5++,r8
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a d0       	st.w	--r5,r0
80003d00:	00 00       	add	r0,r0
80003d02:	0a b0       	st.h	r5++,r0
80003d04:	00 00       	add	r0,r0
80003d06:	0a 92       	mov	r2,r5
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 80       	andn	r0,r5
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a a8       	st.w	r5++,r8
80003d10:	80 00       	ld.sh	r0,r0[0x0]
80003d12:	2c f8       	sub	r8,-49
80003d14:	00 00       	add	r0,r0
80003d16:	0a a0       	st.w	r5++,r0
80003d18:	80 00       	ld.sh	r0,r0[0x0]
80003d1a:	2c 10       	sub	r0,-63
80003d1c:	00 00       	add	r0,r0
80003d1e:	0a b4       	st.h	r5++,r4
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	2c 44       	sub	r4,-60
80003d24:	00 00       	add	r0,r0
80003d26:	0a 91       	mov	r1,r5
80003d28:	00 00       	add	r0,r0
80003d2a:	0a ac       	st.w	r5++,r12
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a bc       	st.h	r5++,r12
80003d30:	00 00       	add	r0,r0
80003d32:	0a 94       	mov	r4,r5
80003d34:	00 00       	add	r0,r0
80003d36:	0a dc       	st.w	--r5,r12
80003d38:	00 00       	add	r0,r0
80003d3a:	0a c4       	st.b	r5++,r4
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a 7c       	tst	r12,r5
80003d40:	00 00       	add	r0,r0
80003d42:	0a 54       	eor	r4,r5
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	d7 ec       	*unknown*
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	71 a4       	ld.w	r4,r8[0x68]
80003d4c:	00 00       	add	r0,r0
80003d4e:	0a 90       	mov	r0,r5
80003d50:	00 00       	add	r0,r0
80003d52:	0a e8       	st.h	--r5,r8
80003d54:	00 00       	add	r0,r0
80003d56:	0a c8       	st.b	r5++,r8
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	79 dc       	ld.w	r12,r12[0x74]
80003d5c:	80 00       	ld.sh	r0,r0[0x0]
80003d5e:	2c 2c       	sub	r12,-62
80003d60:	00 00       	add	r0,r0
80003d62:	0a 5e       	eor	lr,r5
80003d64:	00 00       	add	r0,r0
80003d66:	1e b4       	st.h	pc++,r4
80003d68:	80 00       	ld.sh	r0,r0[0x0]
80003d6a:	2b e0       	sub	r0,-66
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a 84       	andn	r4,r5
80003d70:	00 00       	add	r0,r0
80003d72:	1d b8       	ld.ub	r8,lr[0x3]
80003d74:	00 00       	add	r0,r0
80003d76:	0a 88       	andn	r8,r5
80003d78:	00 00       	add	r0,r0
80003d7a:	0a 4a       	or	r10,r5
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a 48       	or	r8,r5
80003d80:	00 00       	add	r0,r0
80003d82:	0a e0       	st.h	--r5,r0
80003d84:	00 00       	add	r0,r0
80003d86:	0a 9c       	mov	r12,r5
80003d88:	00 00       	add	r0,r0
80003d8a:	0a 68       	and	r8,r5
80003d8c:	00 00       	add	r0,r0
80003d8e:	1d b0       	ld.ub	r0,lr[0x3]
80003d90:	00 00       	add	r0,r0
80003d92:	0a d4       	st.w	--r5,r4
80003d94:	00 00       	add	r0,r0
80003d96:	1e b8       	st.h	pc++,r8
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	d8 04       	*unknown*

80003d9c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d9c:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d9e:	49 a8       	lddpc	r8,80003e04 <pdca_int_handler+0x68>
80003da0:	70 09       	ld.w	r9,r8[0x0]
80003da2:	2f f9       	sub	r9,-1
80003da4:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003da6:	49 98       	lddpc	r8,80003e08 <pdca_int_handler+0x6c>
80003da8:	11 89       	ld.ub	r9,r8[0x0]
80003daa:	ec 19 00 01 	eorl	r9,0x1
80003dae:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003db0:	11 89       	ld.ub	r9,r8[0x0]
80003db2:	a5 69       	lsl	r9,0x4
80003db4:	2f c9       	sub	r9,-4
80003db6:	49 6a       	lddpc	r10,80003e0c <pdca_int_handler+0x70>
80003db8:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003dba:	fe 7a 00 40 	mov	r10,-65472
80003dbe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dc0:	30 39       	mov	r9,3
80003dc2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003dc4:	11 8a       	ld.ub	r10,r8[0x0]
80003dc6:	a5 6a       	lsl	r10,0x4
80003dc8:	2f ca       	sub	r10,-4
80003dca:	49 28       	lddpc	r8,80003e10 <pdca_int_handler+0x74>
80003dcc:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003dce:	fe 78 00 00 	mov	r8,-65536
80003dd2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dd4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003dd6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003dd8:	48 f8       	lddpc	r8,80003e14 <pdca_int_handler+0x78>
80003dda:	70 08       	ld.w	r8,r8[0x0]
80003ddc:	58 08       	cp.w	r8,0
80003dde:	c0 70       	breq	80003dec <pdca_int_handler+0x50>
80003de0:	48 a9       	lddpc	r9,80003e08 <pdca_int_handler+0x6c>
80003de2:	13 89       	ld.ub	r9,r9[0x0]
80003de4:	a5 69       	lsl	r9,0x4
80003de6:	48 bc       	lddpc	r12,80003e10 <pdca_int_handler+0x74>
80003de8:	12 0c       	add	r12,r9
80003dea:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003dec:	48 b8       	lddpc	r8,80003e18 <pdca_int_handler+0x7c>
80003dee:	70 08       	ld.w	r8,r8[0x0]
80003df0:	58 08       	cp.w	r8,0
80003df2:	c0 70       	breq	80003e00 <pdca_int_handler+0x64>
80003df4:	48 59       	lddpc	r9,80003e08 <pdca_int_handler+0x6c>
80003df6:	13 89       	ld.ub	r9,r9[0x0]
80003df8:	a5 69       	lsl	r9,0x4
80003dfa:	48 5c       	lddpc	r12,80003e0c <pdca_int_handler+0x70>
80003dfc:	12 0c       	add	r12,r9
80003dfe:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003e00:	d4 02       	popm	lr
80003e02:	d6 03       	rete
80003e04:	00 00       	add	r0,r0
80003e06:	0a f0       	st.b	--r5,r0
80003e08:	00 00       	add	r0,r0
80003e0a:	96 d8       	ld.uh	r8,r11[0xa]
80003e0c:	00 00       	add	r0,r0
80003e0e:	97 00       	st.w	r11[0x0],r0
80003e10:	00 00       	add	r0,r0
80003e12:	96 e0       	ld.uh	r0,r11[0xc]
80003e14:	00 00       	add	r0,r0
80003e16:	0a ec       	st.h	--r5,r12
80003e18:	00 00       	add	r0,r0
80003e1a:	0a f4       	st.b	--r5,r4

80003e1c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003e1c:	fe 78 10 00 	mov	r8,-61440
80003e20:	e0 69 0d c0 	mov	r9,3520
80003e24:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003e28:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003e2c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003e30:	fe 78 34 00 	mov	r8,-52224
80003e34:	e0 69 80 00 	mov	r9,32768
80003e38:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003e3a:	30 09       	mov	r9,0
80003e3c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003e3e:	e0 69 04 21 	mov	r9,1057
80003e42:	ea 19 3f 20 	orh	r9,0x3f20
80003e46:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003e48:	e0 69 02 9f 	mov	r9,671
80003e4c:	ea 19 01 00 	orh	r9,0x100
80003e50:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e52:	e0 6a 04 02 	mov	r10,1026
80003e56:	ea 1a 3f 20 	orh	r10,0x3f20
80003e5a:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003e5c:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003e5e:	5e fc       	retal	r12

80003e60 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003e60:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003e62:	30 19       	mov	r9,1
80003e64:	49 78       	lddpc	r8,80003ec0 <local_start_PDC+0x60>
80003e66:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e68:	fe 78 00 00 	mov	r8,-65536
80003e6c:	30 7b       	mov	r11,7
80003e6e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e70:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e72:	49 59       	lddpc	r9,80003ec4 <local_start_PDC+0x64>
80003e74:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e78:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e7a:	30 3a       	mov	r10,3
80003e7c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e7e:	30 1c       	mov	r12,1
80003e80:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e82:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e84:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e86:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e88:	30 2c       	mov	r12,2
80003e8a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e8c:	48 f9       	lddpc	r9,80003ec8 <local_start_PDC+0x68>
80003e8e:	e0 68 5a 5a 	mov	r8,23130
80003e92:	ea 18 ab cd 	orh	r8,0xabcd
80003e96:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e98:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e9a:	30 0e       	mov	lr,0
80003e9c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e9e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003ea0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003ea2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003ea4:	fe 78 00 40 	mov	r8,-65472
80003ea8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003eaa:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003eac:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003eb0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003eb2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003eb4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003eb6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003eb8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003eba:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ebc:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003ebe:	d8 02       	popm	pc
80003ec0:	00 00       	add	r0,r0
80003ec2:	96 d8       	ld.uh	r8,r11[0xa]
80003ec4:	00 00       	add	r0,r0
80003ec6:	96 e0       	ld.uh	r0,r11[0xc]
80003ec8:	00 00       	add	r0,r0
80003eca:	97 00       	st.w	r11[0x0],r0

80003ecc <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003ecc:	48 38       	lddpc	r8,80003ed8 <register_rx_tx_func+0xc>
80003ece:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003ed0:	48 38       	lddpc	r8,80003edc <register_rx_tx_func+0x10>
80003ed2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003ed4:	5e fc       	retal	r12
80003ed6:	00 00       	add	r0,r0
80003ed8:	00 00       	add	r0,r0
80003eda:	0a ec       	st.h	--r5,r12
80003edc:	00 00       	add	r0,r0
80003ede:	0a f4       	st.b	--r5,r4

80003ee0 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003ee0:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003ee2:	fe 78 10 00 	mov	r8,-61440
80003ee6:	30 29       	mov	r9,2
80003ee8:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003eec:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003ef0:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003ef2:	30 3a       	mov	r10,3
80003ef4:	36 0b       	mov	r11,96
80003ef6:	49 4c       	lddpc	r12,80003f44 <ssc_init+0x64>
80003ef8:	f0 1f 00 14 	mcall	80003f48 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003efc:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003efe:	fe 79 10 00 	mov	r9,-61440
80003f02:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f06:	e2 18 00 02 	andl	r8,0x2,COH
80003f0a:	cf c0       	breq	80003f02 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003f0c:	fe 79 10 00 	mov	r9,-61440
80003f10:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f14:	e2 18 00 02 	andl	r8,0x2,COH
80003f18:	cf c1       	brne	80003f10 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003f1a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003f1c:	f0 1f 00 0c 	mcall	80003f4c <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003f20:	f0 1f 00 0c 	mcall	80003f50 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f24:	fe 79 00 00 	mov	r9,-65536
80003f28:	30 18       	mov	r8,1
80003f2a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f2c:	fe 7a 00 40 	mov	r10,-65472
80003f30:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003f32:	e0 6b 01 01 	mov	r11,257
80003f36:	fe 7a 34 00 	mov	r10,-52224
80003f3a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003f3c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003f3e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f40:	d8 02       	popm	pc
80003f42:	00 00       	add	r0,r0
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	3d 9c       	mov	r12,-39
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	55 f0       	stdsp	sp[0x17c],r0
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	3e 1c       	mov	r12,-31
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	3e 60       	mov	r0,-26

80003f54 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f54:	48 28       	lddpc	r8,80003f5c <xcmp_register_app_list+0x8>
80003f56:	91 0c       	st.w	r8[0x0],r12
}
80003f58:	5e fc       	retal	r12
80003f5a:	00 00       	add	r0,r0
80003f5c:	00 00       	add	r0,r0
80003f5e:	97 20       	st.w	r11[0x8],r0

80003f60 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003f60:	eb cd 40 80 	pushm	r7,lr
80003f64:	fa cd 01 00 	sub	sp,sp,256
80003f68:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f6a:	16 98       	mov	r8,r11
80003f6c:	2f 08       	sub	r8,-16
80003f6e:	af a8       	sbr	r8,0xe
80003f70:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f72:	3f f8       	mov	r8,-1
80003f74:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f76:	30 b9       	mov	r9,11
80003f78:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f7a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f7c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f7e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f80:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f82:	f6 ca ff fe 	sub	r10,r11,-2
80003f86:	18 9b       	mov	r11,r12
80003f88:	fa cc ff f0 	sub	r12,sp,-16
80003f8c:	f0 1f 00 05 	mcall	80003fa0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f90:	2f e7       	sub	r7,-2
80003f92:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f94:	1a 9c       	mov	r12,sp
80003f96:	f0 1f 00 04 	mcall	80003fa4 <xcmp_tx+0x44>
}
80003f9a:	2c 0d       	sub	sp,-256
80003f9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	78 94       	ld.w	r4,r12[0x24]
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	45 78       	lddsp	r8,sp[0x15c]

80003fa8 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003fa8:	d4 21       	pushm	r4-r7,lr
80003faa:	fa cd 00 d0 	sub	sp,sp,208
80003fae:	18 94       	mov	r4,r12
80003fb0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003fb2:	e0 68 01 00 	mov	r8,256
80003fb6:	f0 0b 19 00 	cp.h	r11,r8
80003fba:	e0 8b 00 38 	brhi	8000402a <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003fbe:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003fc2:	e0 68 04 1d 	mov	r8,1053
80003fc6:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003fc8:	30 18       	mov	r8,1
80003fca:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003fcc:	32 08       	mov	r8,32
80003fce:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003fd0:	30 28       	mov	r8,2
80003fd2:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003fd4:	30 48       	mov	r8,4
80003fd6:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003fd8:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003fdc:	ea 1a 0c 00 	orh	r10,0xc00
80003fe0:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003fe2:	30 4a       	mov	r10,4
80003fe4:	1a 9b       	mov	r11,sp
80003fe6:	fa cc ff f4 	sub	r12,sp,-12
80003fea:	f0 1f 00 12 	mcall	80004030 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003fee:	30 f8       	mov	r8,15
80003ff0:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003ff4:	3a 78       	mov	r8,-89
80003ff6:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003ffa:	30 08       	mov	r8,0
80003ffc:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004000:	0e 9a       	mov	r10,r7
80004002:	5c 7a       	castu.h	r10
80004004:	f4 08 16 08 	lsr	r8,r10,0x8
80004008:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
8000400c:	0e 96       	mov	r6,r7
8000400e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004012:	08 9b       	mov	r11,r4
80004014:	fa cc ff eb 	sub	r12,sp,-21
80004018:	f0 1f 00 06 	mcall	80004030 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
8000401c:	ee cb ff f3 	sub	r11,r7,-13
80004020:	5c 5b       	castu.b	r11
80004022:	fa cc ff fa 	sub	r12,sp,-6
80004026:	f0 1f 00 04 	mcall	80004034 <xcmp_data_session_req+0x8c>
}
8000402a:	2c cd       	sub	sp,-208
8000402c:	d8 22       	popm	r4-r7,pc
8000402e:	00 00       	add	r0,r0
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	78 94       	ld.w	r4,r12[0x24]
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	3f 60       	mov	r0,-10

80004038 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004038:	d4 01       	pushm	lr
8000403a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000403e:	fe 78 b4 00 	mov	r8,-19456
80004042:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004044:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80004048:	48 c9       	lddpc	r9,80004078 <xcmp_DeviceInitializationStatus_request+0x40>
8000404a:	13 8a       	ld.ub	r10,r9[0x0]
8000404c:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
8000404e:	13 9a       	ld.ub	r10,r9[0x1]
80004050:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80004052:	13 aa       	ld.ub	r10,r9[0x2]
80004054:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80004056:	13 b9       	ld.ub	r9,r9[0x3]
80004058:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000405a:	30 09       	mov	r9,0
8000405c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000405e:	30 7a       	mov	r10,7
80004060:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004062:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004064:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004066:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000406a:	30 9b       	mov	r11,9
8000406c:	fa cc ff fe 	sub	r12,sp,-2
80004070:	f0 1f 00 03 	mcall	8000407c <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004074:	2c dd       	sub	sp,-204
80004076:	d8 02       	popm	pc
80004078:	00 00       	add	r0,r0
8000407a:	0d 9c       	ld.ub	r12,r6[0x1]
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	3f 60       	mov	r0,-10

80004080 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004080:	d4 01       	pushm	lr
80004082:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004086:	fe 78 80 00 	mov	r8,-32768
8000408a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000408c:	30 38       	mov	r8,3
8000408e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004090:	30 1b       	mov	r11,1
80004092:	fa cc ff fe 	sub	r12,sp,-2
80004096:	f0 1f 00 03 	mcall	800040a0 <xcmp_opcode_not_supported+0x20>
}
8000409a:	2c dd       	sub	sp,-204
8000409c:	d8 02       	popm	pc
8000409e:	00 00       	add	r0,r0
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3f 60       	mov	r0,-10

800040a4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800040a4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800040a6:	96 88       	ld.uh	r8,r11[0x0]
800040a8:	e2 18 f0 00 	andl	r8,0xf000,COH
800040ac:	e0 48 80 00 	cp.w	r8,32768
800040b0:	c0 f0       	breq	800040ce <xcmp_exec_func+0x2a>
800040b2:	e0 48 b0 00 	cp.w	r8,45056
800040b6:	c1 20       	breq	800040da <xcmp_exec_func+0x36>
800040b8:	58 08       	cp.w	r8,0
800040ba:	c1 51       	brne	800040e4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800040bc:	78 08       	ld.w	r8,r12[0x0]
800040be:	58 08       	cp.w	r8,0
800040c0:	c0 40       	breq	800040c8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800040c2:	16 9c       	mov	r12,r11
800040c4:	5d 18       	icall	r8
800040c6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800040c8:	f0 1f 00 08 	mcall	800040e8 <xcmp_exec_func+0x44>
800040cc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800040ce:	78 18       	ld.w	r8,r12[0x4]
800040d0:	58 08       	cp.w	r8,0
800040d2:	c0 90       	breq	800040e4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800040d4:	16 9c       	mov	r12,r11
800040d6:	5d 18       	icall	r8
800040d8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800040da:	78 28       	ld.w	r8,r12[0x8]
800040dc:	58 08       	cp.w	r8,0
800040de:	c0 30       	breq	800040e4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800040e0:	16 9c       	mov	r12,r11
800040e2:	5d 18       	icall	r8
800040e4:	d8 02       	popm	pc
800040e6:	00 00       	add	r0,r0
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	40 80       	lddsp	r0,sp[0x20]

800040ec <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800040ec:	d4 01       	pushm	lr
800040ee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800040f2:	e0 68 04 09 	mov	r8,1033
800040f6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800040f8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800040fc:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800040fe:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004102:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004104:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004106:	30 09       	mov	r9,0
80004108:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000410a:	fb 69 00 08 	st.b	sp[8],r9
8000410e:	fa c8 ff f7 	sub	r8,sp,-9
80004112:	b0 89       	st.b	r8[0x0],r9
80004114:	fa c8 ff f6 	sub	r8,sp,-10
80004118:	b0 89       	st.b	r8[0x0],r9
8000411a:	fa c8 ff f5 	sub	r8,sp,-11
8000411e:	b0 89       	st.b	r8[0x0],r9
80004120:	fa c8 ff f4 	sub	r8,sp,-12
80004124:	b0 89       	st.b	r8[0x0],r9
80004126:	fa c8 ff f3 	sub	r8,sp,-13
8000412a:	b0 89       	st.b	r8[0x0],r9
8000412c:	fa c8 ff f2 	sub	r8,sp,-14
80004130:	b0 89       	st.b	r8[0x0],r9
80004132:	fa c8 ff f1 	sub	r8,sp,-15
80004136:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004138:	30 cb       	mov	r11,12
8000413a:	fa cc ff fe 	sub	r12,sp,-2
8000413e:	f0 1f 00 03 	mcall	80004148 <xcmp_IdleTestTone+0x5c>
}
80004142:	2c dd       	sub	sp,-204
80004144:	d8 02       	popm	pc
80004146:	00 00       	add	r0,r0
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	3f 60       	mov	r0,-10

8000414c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000414c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000414e:	48 dc       	lddpc	r12,80004180 <xcmp_init+0x34>
80004150:	f0 1f 00 0d 	mcall	80004184 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004154:	30 4b       	mov	r11,4
80004156:	31 4c       	mov	r12,20
80004158:	f0 1f 00 0c 	mcall	80004188 <xcmp_init+0x3c>
8000415c:	48 c8       	lddpc	r8,8000418c <xcmp_init+0x40>
8000415e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004160:	30 09       	mov	r9,0
80004162:	1a d9       	st.w	--sp,r9
80004164:	1a d9       	st.w	--sp,r9
80004166:	1a d9       	st.w	--sp,r9
80004168:	30 38       	mov	r8,3
8000416a:	e0 6a 04 00 	mov	r10,1024
8000416e:	48 9b       	lddpc	r11,80004190 <xcmp_init+0x44>
80004170:	48 9c       	lddpc	r12,80004194 <xcmp_init+0x48>
80004172:	f0 1f 00 0a 	mcall	80004198 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004176:	f0 1f 00 0a 	mcall	8000419c <xcmp_init+0x50>
8000417a:	2f dd       	sub	sp,-12
	
}
8000417c:	d8 02       	popm	pc
8000417e:	00 00       	add	r0,r0
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	42 9c       	lddsp	r12,sp[0xa4]
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	42 e8       	lddsp	r8,sp[0xb8]
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	65 38       	ld.w	r8,r2[0x4c]
8000418c:	00 00       	add	r0,r0
8000418e:	0b 10       	ld.sh	r0,r5++
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	d8 30       	acall	0x83
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	41 a0       	lddsp	r0,sp[0x68]
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	6c 54       	ld.w	r4,r6[0x14]
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	43 20       	lddsp	r0,sp[0xc8]

800041a0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800041a0:	d4 31       	pushm	r0-r7,lr
800041a2:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041a4:	4b 16       	lddpc	r6,80004268 <xcmp_rx_process+0xc8>
800041a6:	30 05       	mov	r5,0
800041a8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041aa:	4b 13       	lddpc	r3,8000426c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041ac:	4b 12       	lddpc	r2,80004270 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041ae:	4b 21       	lddpc	r1,80004274 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041b0:	4b 20       	lddpc	r0,80004278 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041b2:	6c 0c       	ld.w	r12,r6[0x0]
800041b4:	0a 99       	mov	r9,r5
800041b6:	08 9a       	mov	r10,r4
800041b8:	1a 9b       	mov	r11,sp
800041ba:	f0 1f 00 31 	mcall	8000427c <xcmp_rx_process+0xdc>
800041be:	58 1c       	cp.w	r12,1
800041c0:	cf 91       	brne	800041b2 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800041c2:	40 0b       	lddsp	r11,sp[0x0]
800041c4:	58 0b       	cp.w	r11,0
800041c6:	cf 60       	breq	800041b2 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
800041c8:	96 0a       	ld.sh	r10,r11[0x0]
800041ca:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800041ce:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800041d2:	59 c8       	cp.w	r8,28
800041d4:	c1 e0       	breq	80004210 <xcmp_rx_process+0x70>
800041d6:	e0 89 00 07 	brgt	800041e4 <xcmp_rx_process+0x44>
800041da:	58 e8       	cp.w	r8,14
800041dc:	c0 e0       	breq	800041f8 <xcmp_rx_process+0x58>
800041de:	58 f8       	cp.w	r8,15
800041e0:	c2 41       	brne	80004228 <xcmp_rx_process+0x88>
800041e2:	c0 f8       	rjmp	80004200 <xcmp_rx_process+0x60>
800041e4:	e0 48 01 09 	cp.w	r8,265
800041e8:	c1 80       	breq	80004218 <xcmp_rx_process+0x78>
800041ea:	e0 48 01 0a 	cp.w	r8,266
800041ee:	c1 90       	breq	80004220 <xcmp_rx_process+0x80>
800041f0:	e0 48 00 2c 	cp.w	r8,44
800041f4:	c1 a1       	brne	80004228 <xcmp_rx_process+0x88>
800041f6:	c0 98       	rjmp	80004208 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800041f8:	4a 2c       	lddpc	r12,80004280 <xcmp_rx_process+0xe0>
800041fa:	f0 1f 00 23 	mcall	80004284 <xcmp_rx_process+0xe4>
					break;
800041fe:	c2 f8       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004200:	4a 2c       	lddpc	r12,80004288 <xcmp_rx_process+0xe8>
80004202:	f0 1f 00 21 	mcall	80004284 <xcmp_rx_process+0xe4>
					break;
80004206:	c2 b8       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004208:	4a 1c       	lddpc	r12,8000428c <xcmp_rx_process+0xec>
8000420a:	f0 1f 00 1f 	mcall	80004284 <xcmp_rx_process+0xe4>
					break;
8000420e:	c2 78       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004210:	04 9c       	mov	r12,r2
80004212:	f0 1f 00 1d 	mcall	80004284 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004216:	c2 38       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004218:	02 9c       	mov	r12,r1
8000421a:	f0 1f 00 1b 	mcall	80004284 <xcmp_rx_process+0xe4>
					break;
8000421e:	c1 f8       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004220:	00 9c       	mov	r12,r0
80004222:	f0 1f 00 19 	mcall	80004284 <xcmp_rx_process+0xe4>
					break;
80004226:	c1 b8       	rjmp	8000425c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004228:	12 98       	mov	r8,r9
8000422a:	e2 18 04 00 	andl	r8,0x400,COH
8000422e:	c0 70       	breq	8000423c <xcmp_rx_process+0x9c>
80004230:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004234:	e0 48 00 68 	cp.w	r8,104
80004238:	e0 8a 00 08 	brle	80004248 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000423c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004240:	c0 e1       	brne	8000425c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004242:	f0 1f 00 14 	mcall	80004290 <xcmp_rx_process+0xf0>
80004246:	c0 b8       	rjmp	8000425c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004248:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000424c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004250:	49 19       	lddpc	r9,80004294 <xcmp_rx_process+0xf4>
80004252:	72 08       	ld.w	r8,r9[0x0]
80004254:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004258:	f0 1f 00 0b 	mcall	80004284 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000425c:	66 0c       	ld.w	r12,r3[0x0]
8000425e:	40 0b       	lddsp	r11,sp[0x0]
80004260:	f0 1f 00 0e 	mcall	80004298 <xcmp_rx_process+0xf8>
80004264:	ca 7b       	rjmp	800041b2 <xcmp_rx_process+0x12>
80004266:	00 00       	add	r0,r0
80004268:	00 00       	add	r0,r0
8000426a:	0b 10       	ld.sh	r0,r5++
8000426c:	00 00       	add	r0,r0
8000426e:	0a a8       	st.w	r5++,r8
80004270:	00 00       	add	r0,r0
80004272:	0b 20       	ld.uh	r0,r5++
80004274:	00 00       	add	r0,r0
80004276:	0b 14       	ld.sh	r4,r5++
80004278:	00 00       	add	r0,r0
8000427a:	0b 04       	ld.w	r4,r5++
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	61 d4       	ld.w	r4,r0[0x74]
80004280:	00 00       	add	r0,r0
80004282:	0b 38       	ld.ub	r8,r5++
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	40 a4       	lddsp	r4,sp[0x28]
80004288:	00 00       	add	r0,r0
8000428a:	0a f8       	st.b	--r5,r8
8000428c:	00 00       	add	r0,r0
8000428e:	0b 2c       	ld.uh	r12,r5++
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	40 80       	lddsp	r0,sp[0x20]
80004294:	00 00       	add	r0,r0
80004296:	97 20       	st.w	r11[0x8],r0
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	2c 7c       	sub	r12,-57

8000429c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000429c:	eb cd 40 90 	pushm	r4,r7,lr
800042a0:	20 1d       	sub	sp,4
800042a2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042a6:	48 c8       	lddpc	r8,800042d4 <xcmp_rx+0x38>
800042a8:	70 0c       	ld.w	r12,r8[0x0]
800042aa:	f0 1f 00 0c 	mcall	800042d8 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800042ae:	c1 00       	breq	800042ce <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042b0:	fa c7 ff fc 	sub	r7,sp,-4
800042b4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800042b6:	e0 6a 00 ca 	mov	r10,202
800042ba:	08 9b       	mov	r11,r4
800042bc:	f0 1f 00 08 	mcall	800042dc <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800042c0:	48 88       	lddpc	r8,800042e0 <xcmp_rx+0x44>
800042c2:	70 0c       	ld.w	r12,r8[0x0]
800042c4:	30 09       	mov	r9,0
800042c6:	12 9a       	mov	r10,r9
800042c8:	1a 9b       	mov	r11,sp
800042ca:	f0 1f 00 07 	mcall	800042e4 <xcmp_rx+0x48>
	}	
}
800042ce:	2f fd       	sub	sp,-4
800042d0:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800042d4:	00 00       	add	r0,r0
800042d6:	0a a8       	st.w	r5++,r8
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	2e 28       	sub	r8,-30
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	78 94       	ld.w	r4,r12[0x24]
800042e0:	00 00       	add	r0,r0
800042e2:	0b 10       	ld.sh	r0,r5++
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	63 e0       	ld.w	r0,r1[0x78]

800042e8 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800042e8:	48 28       	lddpc	r8,800042f0 <xnl_register_xcmp_func+0x8>
800042ea:	91 0c       	st.w	r8[0x0],r12
}
800042ec:	5e fc       	retal	r12
800042ee:	00 00       	add	r0,r0
800042f0:	00 00       	add	r0,r0
800042f2:	0b 5c       	ld.sh	r12,--r5

800042f4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800042f4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800042f6:	48 88       	lddpc	r8,80004314 <xnl_get_msg_ack_func+0x20>
800042f8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800042fa:	98 49       	ld.sh	r9,r12[0x8]
800042fc:	f0 09 19 00 	cp.h	r9,r8
80004300:	c0 81       	brne	80004310 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004302:	48 68       	lddpc	r8,80004318 <xnl_get_msg_ack_func+0x24>
80004304:	70 0c       	ld.w	r12,r8[0x0]
80004306:	30 09       	mov	r9,0
80004308:	12 9a       	mov	r10,r9
8000430a:	12 9b       	mov	r11,r9
8000430c:	f0 1f 00 04 	mcall	8000431c <xnl_get_msg_ack_func+0x28>
80004310:	d8 02       	popm	pc
80004312:	00 00       	add	r0,r0
80004314:	00 00       	add	r0,r0
80004316:	97 24       	st.w	r11[0x8],r4
80004318:	00 00       	add	r0,r0
8000431a:	0b 44       	ld.w	r4,--r5
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	63 e0       	ld.w	r0,r1[0x78]

80004320 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004320:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004324:	30 09       	mov	r9,0
80004326:	4b 78       	lddpc	r8,80004400 <xnl_init+0xe0>
80004328:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000432a:	30 0b       	mov	r11,0
8000432c:	30 1c       	mov	r12,1
8000432e:	f0 1f 00 36 	mcall	80004404 <xnl_init+0xe4>
80004332:	4b 68       	lddpc	r8,80004408 <xnl_init+0xe8>
80004334:	91 0c       	st.w	r8[0x0],r12
80004336:	70 08       	ld.w	r8,r8[0x0]
80004338:	58 08       	cp.w	r8,0
8000433a:	c0 80       	breq	8000434a <xnl_init+0x2a>
8000433c:	4b 38       	lddpc	r8,80004408 <xnl_init+0xe8>
8000433e:	70 0c       	ld.w	r12,r8[0x0]
80004340:	30 09       	mov	r9,0
80004342:	12 9a       	mov	r10,r9
80004344:	12 9b       	mov	r11,r9
80004346:	f0 1f 00 32 	mcall	8000440c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000434a:	30 4b       	mov	r11,4
8000434c:	33 2c       	mov	r12,50
8000434e:	f0 1f 00 2e 	mcall	80004404 <xnl_init+0xe4>
80004352:	4b 08       	lddpc	r8,80004410 <xnl_init+0xf0>
80004354:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004356:	30 4b       	mov	r11,4
80004358:	36 4c       	mov	r12,100
8000435a:	f0 1f 00 2b 	mcall	80004404 <xnl_init+0xe4>
8000435e:	4a e8       	lddpc	r8,80004414 <xnl_init+0xf4>
80004360:	91 0c       	st.w	r8[0x0],r12
80004362:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004364:	10 96       	mov	r6,r8
80004366:	4a d5       	lddpc	r5,80004418 <xnl_init+0xf8>
80004368:	6c 0c       	ld.w	r12,r6[0x0]
8000436a:	ea 07 00 0b 	add	r11,r5,r7
8000436e:	f0 1f 00 2c 	mcall	8000441c <xnl_init+0xfc>
80004372:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004376:	e0 47 64 00 	cp.w	r7,25600
8000437a:	cf 71       	brne	80004368 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000437c:	30 4b       	mov	r11,4
8000437e:	31 4c       	mov	r12,20
80004380:	f0 1f 00 21 	mcall	80004404 <xnl_init+0xe4>
80004384:	4a 78       	lddpc	r8,80004420 <xnl_init+0x100>
80004386:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004388:	30 4b       	mov	r11,4
8000438a:	31 4c       	mov	r12,20
8000438c:	f0 1f 00 1e 	mcall	80004404 <xnl_init+0xe4>
80004390:	4a 58       	lddpc	r8,80004424 <xnl_init+0x104>
80004392:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004394:	30 4b       	mov	r11,4
80004396:	30 ac       	mov	r12,10
80004398:	f0 1f 00 1b 	mcall	80004404 <xnl_init+0xe4>
8000439c:	4a 38       	lddpc	r8,80004428 <xnl_init+0x108>
8000439e:	91 0c       	st.w	r8[0x0],r12
800043a0:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800043a2:	10 96       	mov	r6,r8
800043a4:	4a 25       	lddpc	r5,8000442c <xnl_init+0x10c>
800043a6:	6c 0c       	ld.w	r12,r6[0x0]
800043a8:	ea 07 00 0b 	add	r11,r5,r7
800043ac:	f0 1f 00 1c 	mcall	8000441c <xnl_init+0xfc>
800043b0:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800043b4:	e0 47 14 00 	cp.w	r7,5120
800043b8:	cf 71       	brne	800043a6 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043ba:	30 4b       	mov	r11,4
800043bc:	30 5c       	mov	r12,5
800043be:	f0 1f 00 12 	mcall	80004404 <xnl_init+0xe4>
800043c2:	49 c8       	lddpc	r8,80004430 <xnl_init+0x110>
800043c4:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800043c6:	30 07       	mov	r7,0
800043c8:	1a d7       	st.w	--sp,r7
800043ca:	1a d7       	st.w	--sp,r7
800043cc:	1a d7       	st.w	--sp,r7
800043ce:	30 38       	mov	r8,3
800043d0:	0e 99       	mov	r9,r7
800043d2:	e0 6a 02 00 	mov	r10,512
800043d6:	49 8b       	lddpc	r11,80004434 <xnl_init+0x114>
800043d8:	49 8c       	lddpc	r12,80004438 <xnl_init+0x118>
800043da:	f0 1f 00 19 	mcall	8000443c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800043de:	1a d7       	st.w	--sp,r7
800043e0:	1a d7       	st.w	--sp,r7
800043e2:	1a d7       	st.w	--sp,r7
800043e4:	30 38       	mov	r8,3
800043e6:	0e 99       	mov	r9,r7
800043e8:	e0 6a 00 82 	mov	r10,130
800043ec:	49 5b       	lddpc	r11,80004440 <xnl_init+0x120>
800043ee:	49 6c       	lddpc	r12,80004444 <xnl_init+0x124>
800043f0:	f0 1f 00 13 	mcall	8000443c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800043f4:	f0 1f 00 15 	mcall	80004448 <xnl_init+0x128>
800043f8:	2f ad       	sub	sp,-24
}
800043fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043fe:	00 00       	add	r0,r0
80004400:	00 00       	add	r0,r0
80004402:	97 24       	st.w	r11[0x8],r4
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	65 38       	ld.w	r8,r2[0x4c]
80004408:	00 00       	add	r0,r0
8000440a:	0b 44       	ld.w	r4,--r5
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	63 e0       	ld.w	r0,r1[0x78]
80004410:	00 00       	add	r0,r0
80004412:	0b 50       	ld.sh	r0,--r5
80004414:	00 00       	add	r0,r0
80004416:	0a a8       	st.w	r5++,r8
80004418:	00 00       	add	r0,r0
8000441a:	32 d2       	mov	r2,45
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	2c 7c       	sub	r12,-57
80004420:	00 00       	add	r0,r0
80004422:	0a d8       	st.w	--r5,r8
80004424:	00 00       	add	r0,r0
80004426:	0a b8       	st.h	r5++,r8
80004428:	00 00       	add	r0,r0
8000442a:	0a ac       	st.w	r5++,r12
8000442c:	00 00       	add	r0,r0
8000442e:	1e d2       	st.w	--pc,r2
80004430:	00 00       	add	r0,r0
80004432:	0a e4       	st.h	--r5,r4
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	d8 38       	*unknown*
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	44 4c       	lddsp	r12,sp[0x110]
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	6c 54       	ld.w	r4,r6[0x14]
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	d8 40       	acall	0x84
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	44 ac       	lddsp	r12,sp[0x128]
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	2e 50       	sub	r0,-27

8000444c <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
8000444c:	eb cd 40 fe 	pushm	r1-r7,lr
80004450:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004452:	49 26       	lddpc	r6,80004498 <xnl_rx_process+0x4c>
80004454:	30 05       	mov	r5,0
80004456:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004458:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000445a:	49 11       	lddpc	r1,8000449c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000445c:	49 12       	lddpc	r2,800044a0 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000445e:	6c 0c       	ld.w	r12,r6[0x0]
80004460:	0a 99       	mov	r9,r5
80004462:	08 9a       	mov	r10,r4
80004464:	1a 9b       	mov	r11,sp
80004466:	f0 1f 00 10 	mcall	800044a4 <xnl_rx_process+0x58>
8000446a:	58 1c       	cp.w	r12,1
8000446c:	cf 91       	brne	8000445e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000446e:	40 0c       	lddsp	r12,sp[0x0]
80004470:	58 0c       	cp.w	r12,0
80004472:	cf 60       	breq	8000445e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004474:	98 28       	ld.sh	r8,r12[0x4]
80004476:	e6 08 19 00 	cp.h	r8,r3
8000447a:	e0 8b 00 0a 	brhi	8000448e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000447e:	5c 78       	castu.h	r8
80004480:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004484:	58 09       	cp.w	r9,0
80004486:	c0 40       	breq	8000448e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004488:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000448c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000448e:	62 0c       	ld.w	r12,r1[0x0]
80004490:	40 0b       	lddsp	r11,sp[0x0]
80004492:	f0 1f 00 06 	mcall	800044a8 <xnl_rx_process+0x5c>
80004496:	ce 4b       	rjmp	8000445e <xnl_rx_process+0x12>
80004498:	00 00       	add	r0,r0
8000449a:	0a b8       	st.h	r5++,r8
8000449c:	00 00       	add	r0,r0
8000449e:	0a a8       	st.w	r5++,r8
800044a0:	00 00       	add	r0,r0
800044a2:	04 f4       	st.b	--r2,r4
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	61 d4       	ld.w	r4,r0[0x74]
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	2c 7c       	sub	r12,-57

800044ac <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
800044ac:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800044ae:	4a a6       	lddpc	r6,80004554 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044b0:	4a a2       	lddpc	r2,80004558 <xnl_tx_process+0xac>
800044b2:	4a b4       	lddpc	r4,8000455c <xnl_tx_process+0xb0>
800044b4:	30 07       	mov	r7,0
800044b6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044b8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044ba:	4a a5       	lddpc	r5,80004560 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044bc:	4a a3       	lddpc	r3,80004564 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800044be:	6c 08       	ld.w	r8,r6[0x0]
800044c0:	58 08       	cp.w	r8,0
800044c2:	c0 40       	breq	800044ca <xnl_tx_process+0x1e>
800044c4:	58 18       	cp.w	r8,1
800044c6:	cf d1       	brne	800044c0 <xnl_tx_process+0x14>
800044c8:	c2 48       	rjmp	80004510 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044ca:	64 0c       	ld.w	r12,r2[0x0]
800044cc:	0e 99       	mov	r9,r7
800044ce:	02 9a       	mov	r10,r1
800044d0:	08 9b       	mov	r11,r4
800044d2:	f0 1f 00 26 	mcall	80004568 <xnl_tx_process+0xbc>
800044d6:	58 1c       	cp.w	r12,1
800044d8:	cf 31       	brne	800044be <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800044da:	68 0b       	ld.w	r11,r4[0x0]
800044dc:	58 0b       	cp.w	r11,0
800044de:	cf 00       	breq	800044be <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044e0:	96 28       	ld.sh	r8,r11[0x4]
800044e2:	e0 08 19 00 	cp.h	r8,r0
800044e6:	c0 71       	brne	800044f4 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800044e8:	4a 18       	lddpc	r8,8000456c <xnl_tx_process+0xc0>
800044ea:	70 08       	ld.w	r8,r8[0x0]
800044ec:	10 9c       	mov	r12,r8
800044ee:	f0 1f 00 21 	mcall	80004570 <xnl_tx_process+0xc4>
						break;
800044f2:	ce 6b       	rjmp	800044be <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800044f4:	16 9c       	mov	r12,r11
800044f6:	f0 1f 00 20 	mcall	80004574 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044fa:	30 18       	mov	r8,1
800044fc:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044fe:	66 0c       	ld.w	r12,r3[0x0]
80004500:	0e 99       	mov	r9,r7
80004502:	0e 9a       	mov	r10,r7
80004504:	0e 9b       	mov	r11,r7
80004506:	f0 1f 00 19 	mcall	80004568 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000450a:	30 18       	mov	r8,1
8000450c:	8d 08       	st.w	r6[0x0],r8
8000450e:	cd 8b       	rjmp	800044be <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004510:	66 0c       	ld.w	r12,r3[0x0]
80004512:	0e 99       	mov	r9,r7
80004514:	36 4a       	mov	r10,100
80004516:	0e 9b       	mov	r11,r7
80004518:	f0 1f 00 14 	mcall	80004568 <xnl_tx_process+0xbc>
8000451c:	58 1c       	cp.w	r12,1
8000451e:	c0 81       	brne	8000452e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004520:	49 38       	lddpc	r8,8000456c <xnl_tx_process+0xc0>
80004522:	70 0c       	ld.w	r12,r8[0x0]
80004524:	68 0b       	ld.w	r11,r4[0x0]
80004526:	f0 1f 00 13 	mcall	80004570 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000452a:	8d 07       	st.w	r6[0x0],r7
8000452c:	cc 9b       	rjmp	800044be <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000452e:	6a 08       	ld.w	r8,r5[0x0]
80004530:	58 38       	cp.w	r8,3
80004532:	e0 89 00 09 	brgt	80004544 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004536:	68 0c       	ld.w	r12,r4[0x0]
80004538:	f0 1f 00 0f 	mcall	80004574 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000453c:	6a 08       	ld.w	r8,r5[0x0]
8000453e:	2f f8       	sub	r8,-1
80004540:	8b 08       	st.w	r5[0x0],r8
80004542:	cb eb       	rjmp	800044be <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004544:	48 a8       	lddpc	r8,8000456c <xnl_tx_process+0xc0>
80004546:	70 0c       	ld.w	r12,r8[0x0]
80004548:	68 0b       	ld.w	r11,r4[0x0]
8000454a:	f0 1f 00 0a 	mcall	80004570 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000454e:	8d 07       	st.w	r6[0x0],r7
80004550:	cb 7b       	rjmp	800044be <xnl_tx_process+0x12>
80004552:	00 00       	add	r0,r0
80004554:	00 00       	add	r0,r0
80004556:	0b 4c       	ld.w	r12,--r5
80004558:	00 00       	add	r0,r0
8000455a:	0b 50       	ld.sh	r0,--r5
8000455c:	00 00       	add	r0,r0
8000455e:	0b 58       	ld.sh	r8,--r5
80004560:	00 00       	add	r0,r0
80004562:	0b 54       	ld.sh	r4,--r5
80004564:	00 00       	add	r0,r0
80004566:	0b 44       	ld.w	r4,--r5
80004568:	80 00       	ld.sh	r0,r0[0x0]
8000456a:	61 d4       	ld.w	r4,r0[0x74]
8000456c:	00 00       	add	r0,r0
8000456e:	0a a8       	st.w	r5++,r8
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	2c 7c       	sub	r12,-57
80004574:	80 00       	ld.sh	r0,r0[0x0]
80004576:	2c 9c       	sub	r12,-55

80004578 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004578:	eb cd 40 c0 	pushm	r6-r7,lr
8000457c:	20 1d       	sub	sp,4
8000457e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004580:	98 39       	ld.sh	r9,r12[0x6]
80004582:	3f f8       	mov	r8,-1
80004584:	f0 09 19 00 	cp.h	r9,r8
80004588:	c0 a1       	brne	8000459c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000458a:	4a e9       	lddpc	r9,80004640 <xnl_tx+0xc8>
8000458c:	13 88       	ld.ub	r8,r9[0x0]
8000458e:	2f f8       	sub	r8,-1
80004590:	5c 58       	castu.b	r8
80004592:	b2 88       	st.b	r9[0x0],r8
80004594:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004598:	a9 a8       	sbr	r8,0x8
8000459a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000459c:	8c 49       	ld.sh	r9,r6[0x8]
8000459e:	3f f8       	mov	r8,-1
800045a0:	f0 09 19 00 	cp.h	r9,r8
800045a4:	c0 41       	brne	800045ac <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800045a6:	4a 88       	lddpc	r8,80004644 <xnl_tx+0xcc>
800045a8:	90 18       	ld.sh	r8,r8[0x2]
800045aa:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800045ac:	8c 59       	ld.sh	r9,r6[0xa]
800045ae:	3f f8       	mov	r8,-1
800045b0:	f0 09 19 00 	cp.h	r9,r8
800045b4:	c0 41       	brne	800045bc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800045b6:	4a 48       	lddpc	r8,80004644 <xnl_tx+0xcc>
800045b8:	90 28       	ld.sh	r8,r8[0x4]
800045ba:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800045bc:	8c 69       	ld.sh	r9,r6[0xc]
800045be:	3f f8       	mov	r8,-1
800045c0:	f0 09 19 00 	cp.h	r9,r8
800045c4:	c0 e1       	brne	800045e0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800045c6:	4a 08       	lddpc	r8,80004644 <xnl_tx+0xcc>
800045c8:	90 49       	ld.sh	r9,r8[0x8]
800045ca:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800045cc:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800045ce:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800045d0:	90 49       	ld.sh	r9,r8[0x8]
800045d2:	e0 19 ff 00 	andl	r9,0xff00
800045d6:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800045da:	f3 e8 10 08 	or	r8,r9,r8
800045de:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800045e0:	0d 98       	ld.ub	r8,r6[0x1]
800045e2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800045e4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800045e8:	10 0c       	add	r12,r8
800045ea:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045ec:	58 0c       	cp.w	r12,0
800045ee:	e0 89 00 04 	brgt	800045f6 <xnl_tx+0x7e>
800045f2:	30 09       	mov	r9,0
800045f4:	c0 d8       	rjmp	8000460e <xnl_tx+0x96>
800045f6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800045fa:	2f ec       	sub	r12,-2
800045fc:	30 09       	mov	r9,0
800045fe:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004600:	15 1b       	ld.sh	r11,r10++
80004602:	f6 09 00 09 	add	r9,r11,r9
80004606:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004608:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000460a:	18 38       	cp.w	r8,r12
8000460c:	cf a1       	brne	80004600 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000460e:	5c 39       	neg	r9
80004610:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004612:	48 e8       	lddpc	r8,80004648 <xnl_tx+0xd0>
80004614:	70 0c       	ld.w	r12,r8[0x0]
80004616:	f0 1f 00 0e 	mcall	8000464c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000461a:	c1 00       	breq	8000463a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000461c:	fa c7 ff fc 	sub	r7,sp,-4
80004620:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004622:	e0 6a 01 00 	mov	r10,256
80004626:	0c 9b       	mov	r11,r6
80004628:	f0 1f 00 0a 	mcall	80004650 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000462c:	48 a8       	lddpc	r8,80004654 <xnl_tx+0xdc>
8000462e:	70 0c       	ld.w	r12,r8[0x0]
80004630:	30 09       	mov	r9,0
80004632:	12 9a       	mov	r10,r9
80004634:	1a 9b       	mov	r11,sp
80004636:	f0 1f 00 09 	mcall	80004658 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000463a:	2f fd       	sub	sp,-4
8000463c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004640:	00 00       	add	r0,r0
80004642:	0b 48       	ld.w	r8,--r5
80004644:	00 00       	add	r0,r0
80004646:	97 24       	st.w	r11[0x8],r4
80004648:	00 00       	add	r0,r0
8000464a:	0a a8       	st.w	r5++,r8
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	2e 28       	sub	r8,-30
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	78 94       	ld.w	r4,r12[0x24]
80004654:	00 00       	add	r0,r0
80004656:	0b 50       	ld.sh	r0,--r5
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	63 e0       	ld.w	r0,r1[0x78]

8000465c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000465c:	eb cd 40 80 	pushm	r7,lr
80004660:	fa cd 01 00 	sub	sp,sp,256
80004664:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004666:	e0 68 40 0e 	mov	r8,16398
8000466a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000466c:	3f f8       	mov	r8,-1
8000466e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004670:	30 c8       	mov	r8,12
80004672:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004674:	98 38       	ld.sh	r8,r12[0x6]
80004676:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004678:	98 58       	ld.sh	r8,r12[0xa]
8000467a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000467c:	98 48       	ld.sh	r8,r12[0x8]
8000467e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004680:	98 68       	ld.sh	r8,r12[0xc]
80004682:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004684:	30 08       	mov	r8,0
80004686:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004688:	1a 9c       	mov	r12,sp
8000468a:	f0 1f 00 0a 	mcall	800046b0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000468e:	fa cd 00 cc 	sub	sp,sp,204
80004692:	e0 6a 00 ca 	mov	r10,202
80004696:	ee cb ff f0 	sub	r11,r7,-16
8000469a:	1a 9c       	mov	r12,sp
8000469c:	f0 1f 00 06 	mcall	800046b4 <xnl_data_msg_func+0x58>
800046a0:	48 68       	lddpc	r8,800046b8 <xnl_data_msg_func+0x5c>
800046a2:	70 08       	ld.w	r8,r8[0x0]
800046a4:	5d 18       	icall	r8
800046a6:	fa cd ff 34 	sub	sp,sp,-204
}
800046aa:	2c 0d       	sub	sp,-256
800046ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	45 78       	lddsp	r8,sp[0x15c]
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	78 94       	ld.w	r4,r12[0x24]
800046b8:	00 00       	add	r0,r0
800046ba:	0b 5c       	ld.sh	r12,--r5

800046bc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800046bc:	d4 21       	pushm	r4-r7,lr
800046be:	fa cd 01 00 	sub	sp,sp,256
800046c2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800046c4:	4c 28       	lddpc	r8,800047cc <xnl_device_auth_reply_func+0x110>
800046c6:	11 88       	ld.ub	r8,r8[0x0]
800046c8:	58 08       	cp.w	r8,0
800046ca:	e0 81 00 7f 	brne	800047c8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800046ce:	4c 18       	lddpc	r8,800047d0 <xnl_device_auth_reply_func+0x114>
800046d0:	70 0c       	ld.w	r12,r8[0x0]
800046d2:	30 09       	mov	r9,0
800046d4:	12 9a       	mov	r10,r9
800046d6:	12 9b       	mov	r11,r9
800046d8:	f0 1f 00 3f 	mcall	800047d4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800046dc:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800046e0:	4b b8       	lddpc	r8,800047cc <xnl_device_auth_reply_func+0x110>
800046e2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800046e4:	ef 39 00 12 	ld.ub	r9,r7[18]
800046e8:	ef 38 00 13 	ld.ub	r8,r7[19]
800046ec:	b1 68       	lsl	r8,0x10
800046ee:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800046f2:	ef 38 00 15 	ld.ub	r8,r7[21]
800046f6:	f3 e8 10 08 	or	r8,r9,r8
800046fa:	ef 39 00 14 	ld.ub	r9,r7[20]
800046fe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004702:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004706:	ef 38 00 17 	ld.ub	r8,r7[23]
8000470a:	b1 68       	lsl	r8,0x10
8000470c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004710:	ef 38 00 19 	ld.ub	r8,r7[25]
80004714:	f5 e8 10 08 	or	r8,r10,r8
80004718:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000471c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004720:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004722:	e0 64 79 b9 	mov	r4,31161
80004726:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000472a:	e0 65 45 07 	mov	r5,17671
8000472e:	ea 15 8a bd 	orh	r5,0x8abd
80004732:	e0 66 f9 3d 	mov	r6,63805
80004736:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000473a:	e0 6e b8 cf 	mov	lr,47311
8000473e:	ea 1e 36 83 	orh	lr,0x3683
80004742:	e0 67 aa 1c 	mov	r7,43548
80004746:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000474a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000474c:	f4 08 00 0c 	add	r12,r10,r8
80004750:	f0 0b 15 04 	lsl	r11,r8,0x4
80004754:	0a 0b       	add	r11,r5
80004756:	f9 eb 20 0b 	eor	r11,r12,r11
8000475a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000475e:	0c 0c       	add	r12,r6
80004760:	18 5b       	eor	r11,r12
80004762:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004764:	f2 0c 15 04 	lsl	r12,r9,0x4
80004768:	1c 0c       	add	r12,lr
8000476a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000476e:	0e 0b       	add	r11,r7
80004770:	f9 eb 20 0b 	eor	r11,r12,r11
80004774:	f2 0a 00 0c 	add	r12,r9,r10
80004778:	18 5b       	eor	r11,r12
8000477a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000477c:	e0 6b 37 20 	mov	r11,14112
80004780:	ea 1b c6 ef 	orh	r11,0xc6ef
80004784:	16 3a       	cp.w	r10,r11
80004786:	ce 21       	brne	8000474a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004788:	e0 6a 40 1a 	mov	r10,16410
8000478c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000478e:	3f fa       	mov	r10,-1
80004790:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004792:	30 6b       	mov	r11,6
80004794:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004796:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004798:	48 db       	lddpc	r11,800047cc <xnl_device_auth_reply_func+0x110>
8000479a:	96 1c       	ld.sh	r12,r11[0x2]
8000479c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000479e:	96 2b       	ld.sh	r11,r11[0x4]
800047a0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047a2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800047a4:	30 ca       	mov	r10,12
800047a6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800047a8:	30 0a       	mov	r10,0
800047aa:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800047ae:	30 7a       	mov	r10,7
800047b0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800047b4:	30 2a       	mov	r10,2
800047b6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800047ba:	fa ca ff ec 	sub	r10,sp,-20
800047be:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800047c0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047c2:	1a 9c       	mov	r12,sp
800047c4:	f0 1f 00 05 	mcall	800047d8 <xnl_device_auth_reply_func+0x11c>
}
800047c8:	2c 0d       	sub	sp,-256
800047ca:	d8 22       	popm	r4-r7,pc
800047cc:	00 00       	add	r0,r0
800047ce:	97 24       	st.w	r11[0x8],r4
800047d0:	00 00       	add	r0,r0
800047d2:	0b 44       	ld.w	r4,--r5
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	63 e0       	ld.w	r0,r1[0x78]
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	45 78       	lddsp	r8,sp[0x15c]

800047dc <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800047dc:	eb cd 40 80 	pushm	r7,lr
800047e0:	fa cd 01 00 	sub	sp,sp,256
800047e4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800047e6:	49 28       	lddpc	r8,8000482c <xnl_master_status_brdcst_func+0x50>
800047e8:	11 88       	ld.ub	r8,r8[0x0]
800047ea:	58 08       	cp.w	r8,0
800047ec:	c1 c1       	brne	80004824 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800047ee:	49 18       	lddpc	r8,80004830 <xnl_master_status_brdcst_func+0x54>
800047f0:	70 0c       	ld.w	r12,r8[0x0]
800047f2:	30 09       	mov	r9,0
800047f4:	12 9a       	mov	r10,r9
800047f6:	12 9b       	mov	r11,r9
800047f8:	f0 1f 00 0f 	mcall	80004834 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800047fc:	8e 58       	ld.sh	r8,r7[0xa]
800047fe:	48 c9       	lddpc	r9,8000482c <xnl_master_status_brdcst_func+0x50>
80004800:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004802:	e0 68 40 0e 	mov	r8,16398
80004806:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004808:	3f f8       	mov	r8,-1
8000480a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000480c:	30 4a       	mov	r10,4
8000480e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004810:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004812:	92 19       	ld.sh	r9,r9[0x2]
80004814:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004816:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004818:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000481a:	30 08       	mov	r8,0
8000481c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000481e:	1a 9c       	mov	r12,sp
80004820:	f0 1f 00 06 	mcall	80004838 <xnl_master_status_brdcst_func+0x5c>
}
80004824:	2c 0d       	sub	sp,-256
80004826:	e3 cd 80 80 	ldm	sp++,r7,pc
8000482a:	00 00       	add	r0,r0
8000482c:	00 00       	add	r0,r0
8000482e:	97 24       	st.w	r11[0x8],r4
80004830:	00 00       	add	r0,r0
80004832:	0b 44       	ld.w	r4,--r5
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	63 e0       	ld.w	r0,r1[0x78]
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	45 78       	lddsp	r8,sp[0x15c]

8000483c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000483c:	eb cd 40 80 	pushm	r7,lr
80004840:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004842:	49 28       	lddpc	r8,80004888 <xnl_device_conn_reply_func+0x4c>
80004844:	70 0c       	ld.w	r12,r8[0x0]
80004846:	30 09       	mov	r9,0
80004848:	12 9a       	mov	r10,r9
8000484a:	12 9b       	mov	r11,r9
8000484c:	f0 1f 00 10 	mcall	8000488c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004850:	ef 18 00 10 	ld.uh	r8,r7[16]
80004854:	10 99       	mov	r9,r8
80004856:	e2 19 ff 00 	andl	r9,0xff00,COH
8000485a:	e0 49 01 00 	cp.w	r9,256
8000485e:	c0 60       	breq	8000486a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004860:	0e 9c       	mov	r12,r7
80004862:	f0 1f 00 0c 	mcall	80004890 <xnl_device_conn_reply_func+0x54>
80004866:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000486a:	a9 68       	lsl	r8,0x8
8000486c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004870:	48 98       	lddpc	r8,80004894 <xnl_device_conn_reply_func+0x58>
80004872:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004874:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004878:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000487a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000487e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004880:	30 19       	mov	r9,1
80004882:	b0 89       	st.b	r8[0x0],r9
80004884:	e3 cd 80 80 	ldm	sp++,r7,pc
80004888:	00 00       	add	r0,r0
8000488a:	0b 44       	ld.w	r4,--r5
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	63 e0       	ld.w	r0,r1[0x78]
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	47 dc       	lddsp	r12,sp[0x1f4]
80004894:	00 00       	add	r0,r0
80004896:	97 24       	st.w	r11[0x8],r4

80004898 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004898:	d4 01       	pushm	lr
8000489a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000489e:	e0 68 40 0e 	mov	r8,16398
800048a2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048a4:	3f f8       	mov	r8,-1
800048a6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800048a8:	30 38       	mov	r8,3
800048aa:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800048ac:	30 08       	mov	r8,0
800048ae:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800048b0:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800048b2:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800048b4:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800048b6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800048b8:	1a 9c       	mov	r12,sp
800048ba:	f0 1f 00 03 	mcall	800048c4 <xnl_send_device_master_query+0x2c>
}
800048be:	2c 0d       	sub	sp,-256
800048c0:	d8 02       	popm	pc
800048c2:	00 00       	add	r0,r0
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	45 78       	lddsp	r8,sp[0x15c]

800048c8 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800048c8:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800048ca:	48 78       	lddpc	r8,800048e4 <RC522_SPI_SetSpeed+0x1c>
800048cc:	70 09       	ld.w	r9,r8[0x0]
800048ce:	72 ca       	ld.w	r10,r9[0x30]
800048d0:	5c 7c       	castu.h	r12
800048d2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800048d6:	f9 ea 10 0a 	or	r10,r12,r10
800048da:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800048dc:	70 0c       	ld.w	r12,r8[0x0]
800048de:	f0 1f 00 03 	mcall	800048e8 <RC522_SPI_SetSpeed+0x20>
		
	
}
800048e2:	d8 02       	popm	pc
800048e4:	00 00       	add	r0,r0
800048e6:	1d ac       	ld.ub	r12,lr[0x2]
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	58 d0       	cp.w	r0,13

800048ec <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800048ec:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800048ee:	e0 6c 0a 00 	mov	r12,2560
800048f2:	f0 1f 00 02 	mcall	800048f8 <RC522_SPI_SetSpeedLow+0xc>
	
}
800048f6:	d8 02       	popm	pc
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	48 c8       	lddpc	r8,80004928 <RC522_WriteByte>

800048fc <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800048fc:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004900:	48 76       	lddpc	r6,8000491c <RC522_ReadByte+0x20>
80004902:	e0 6b 00 ff 	mov	r11,255
80004906:	6c 0c       	ld.w	r12,r6[0x0]
80004908:	f0 1f 00 06 	mcall	80004920 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000490c:	30 07       	mov	r7,0
8000490e:	0e 9b       	mov	r11,r7
80004910:	6c 0c       	ld.w	r12,r6[0x0]
80004912:	f0 1f 00 05 	mcall	80004924 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004916:	0f 9c       	ld.ub	r12,r7[0x1]
80004918:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000491c:	00 00       	add	r0,r0
8000491e:	1d ac       	ld.ub	r12,lr[0x2]
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	58 d6       	cp.w	r6,13
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	58 f2       	cp.w	r2,15

80004928 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004928:	eb cd 40 80 	pushm	r7,lr
8000492c:	20 1d       	sub	sp,4
8000492e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004930:	48 77       	lddpc	r7,8000494c <RC522_WriteByte+0x24>
80004932:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004936:	6e 0c       	ld.w	r12,r7[0x0]
80004938:	f0 1f 00 06 	mcall	80004950 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000493c:	1a 9b       	mov	r11,sp
8000493e:	6e 0c       	ld.w	r12,r7[0x0]
80004940:	f0 1f 00 05 	mcall	80004954 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004944:	5c 5c       	castu.b	r12
80004946:	2f fd       	sub	sp,-4
80004948:	e3 cd 80 80 	ldm	sp++,r7,pc
8000494c:	00 00       	add	r0,r0
8000494e:	1d ac       	ld.ub	r12,lr[0x2]
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	58 d6       	cp.w	r6,13
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	58 f2       	cp.w	r2,15

80004958 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004958:	eb cd 40 e0 	pushm	r5-r7,lr
8000495c:	18 96       	mov	r6,r12
8000495e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004960:	48 a7       	lddpc	r7,80004988 <WriteRawRC+0x30>
80004962:	30 0b       	mov	r11,0
80004964:	6e 0c       	ld.w	r12,r7[0x0]
80004966:	f0 1f 00 0a 	mcall	8000498c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000496a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000496e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004972:	f0 1f 00 08 	mcall	80004990 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004976:	0a 9c       	mov	r12,r5
80004978:	f0 1f 00 06 	mcall	80004990 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000497c:	30 0b       	mov	r11,0
8000497e:	6e 0c       	ld.w	r12,r7[0x0]
80004980:	f0 1f 00 05 	mcall	80004994 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004984:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004988:	00 00       	add	r0,r0
8000498a:	1d ac       	ld.ub	r12,lr[0x2]
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	5a 3c       	cp.w	r12,-29
80004990:	80 00       	ld.sh	r0,r0[0x0]
80004992:	49 28       	lddpc	r8,800049d8 <PcdReset+0x40>
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	59 fc       	cp.w	r12,31

80004998 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004998:	d4 01       	pushm	lr

	SET_RC522RST;
8000499a:	31 9c       	mov	r12,25
8000499c:	f0 1f 00 1b 	mcall	80004a08 <PcdReset+0x70>
	delay_ns(10);
800049a0:	30 ac       	mov	r12,10
800049a2:	f0 1f 00 1b 	mcall	80004a0c <PcdReset+0x74>

	CLR_RC522RST;
800049a6:	31 9c       	mov	r12,25
800049a8:	f0 1f 00 1a 	mcall	80004a10 <PcdReset+0x78>
	delay_ns(10);
800049ac:	30 ac       	mov	r12,10
800049ae:	f0 1f 00 18 	mcall	80004a0c <PcdReset+0x74>

	SET_RC522RST;
800049b2:	31 9c       	mov	r12,25
800049b4:	f0 1f 00 15 	mcall	80004a08 <PcdReset+0x70>
	delay_ns(10);
800049b8:	30 ac       	mov	r12,10
800049ba:	f0 1f 00 15 	mcall	80004a0c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049be:	30 fb       	mov	r11,15
800049c0:	30 1c       	mov	r12,1
800049c2:	f0 1f 00 15 	mcall	80004a14 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049c6:	30 fb       	mov	r11,15
800049c8:	30 1c       	mov	r12,1
800049ca:	f0 1f 00 13 	mcall	80004a14 <PcdReset+0x7c>
	delay_ns(10);
800049ce:	30 ac       	mov	r12,10
800049d0:	f0 1f 00 0f 	mcall	80004a0c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800049d4:	33 db       	mov	r11,61
800049d6:	31 1c       	mov	r12,17
800049d8:	f0 1f 00 0f 	mcall	80004a14 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800049dc:	31 eb       	mov	r11,30
800049de:	32 dc       	mov	r12,45
800049e0:	f0 1f 00 0d 	mcall	80004a14 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800049e4:	30 0b       	mov	r11,0
800049e6:	32 cc       	mov	r12,44
800049e8:	f0 1f 00 0b 	mcall	80004a14 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800049ec:	e0 6b 00 8d 	mov	r11,141
800049f0:	32 ac       	mov	r12,42
800049f2:	f0 1f 00 09 	mcall	80004a14 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800049f6:	33 eb       	mov	r11,62
800049f8:	32 bc       	mov	r12,43
800049fa:	f0 1f 00 07 	mcall	80004a14 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800049fe:	34 0b       	mov	r11,64
80004a00:	31 5c       	mov	r12,21
80004a02:	f0 1f 00 05 	mcall	80004a14 <PcdReset+0x7c>
	
	return MI_OK;
}
80004a06:	d8 0a       	popm	pc,r12=0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	55 b4       	stdsp	sp[0x16c],r4
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	53 54       	stdsp	sp[0xd4],r4
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	55 d0       	stdsp	sp[0x174],r0
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	49 58       	lddpc	r8,80004a68 <Wait_Wakeup_RC522+0x8>

80004a18 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004a18:	eb cd 40 c0 	pushm	r6-r7,lr
80004a1c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004a1e:	48 c7       	lddpc	r7,80004a4c <ReadRawRC+0x34>
80004a20:	30 0b       	mov	r11,0
80004a22:	6e 0c       	ld.w	r12,r7[0x0]
80004a24:	f0 1f 00 0b 	mcall	80004a50 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004a28:	a1 76       	lsl	r6,0x1
80004a2a:	0c 9c       	mov	r12,r6
80004a2c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004a30:	a7 bc       	sbr	r12,0x7
80004a32:	f0 1f 00 09 	mcall	80004a54 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004a36:	f0 1f 00 09 	mcall	80004a58 <ReadRawRC+0x40>
80004a3a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004a3c:	30 0b       	mov	r11,0
80004a3e:	6e 0c       	ld.w	r12,r7[0x0]
80004a40:	f0 1f 00 07 	mcall	80004a5c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004a44:	0c 9c       	mov	r12,r6
80004a46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a4a:	00 00       	add	r0,r0
80004a4c:	00 00       	add	r0,r0
80004a4e:	1d ac       	ld.ub	r12,lr[0x2]
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	5a 3c       	cp.w	r12,-29
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	49 28       	lddpc	r8,80004a9c <Powerdown_RC522+0x2c>
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	48 fc       	lddpc	r12,80004a94 <Powerdown_RC522+0x24>
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	59 fc       	cp.w	r12,31

80004a60 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004a60:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004a62:	30 1c       	mov	r12,1
80004a64:	f0 1f 00 02 	mcall	80004a6c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004a68:	d8 02       	popm	pc
80004a6a:	00 00       	add	r0,r0
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	4a 18       	lddpc	r8,80004af0 <PcdAntennaOn+0x10>

80004a70 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004a70:	eb cd 40 80 	pushm	r7,lr
80004a74:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004a76:	30 1c       	mov	r12,1
80004a78:	f0 1f 00 0d 	mcall	80004aac <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004a7c:	30 18       	mov	r8,1
80004a7e:	f0 07 18 00 	cp.b	r7,r8
80004a82:	c0 91       	brne	80004a94 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004a84:	18 9b       	mov	r11,r12
80004a86:	a5 ab       	sbr	r11,0x4
80004a88:	5c 5b       	castu.b	r11
80004a8a:	30 1c       	mov	r12,1
80004a8c:	f0 1f 00 09 	mcall	80004ab0 <Powerdown_RC522+0x40>
80004a90:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004a94:	18 9b       	mov	r11,r12
80004a96:	30 1c       	mov	r12,1
80004a98:	f0 1f 00 06 	mcall	80004ab0 <Powerdown_RC522+0x40>
		delay_ns(2);
80004a9c:	30 2c       	mov	r12,2
80004a9e:	f0 1f 00 06 	mcall	80004ab4 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004aa2:	f0 1f 00 06 	mcall	80004ab8 <Powerdown_RC522+0x48>
80004aa6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004aaa:	00 00       	add	r0,r0
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	4a 18       	lddpc	r8,80004b30 <PcdAntennaOff+0x8>
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	49 58       	lddpc	r8,80004b04 <ClearBitMask+0x4>
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	53 54       	stdsp	sp[0xd4],r4
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	4a 60       	lddpc	r0,80004b50 <M500PcdConfigISOType+0x18>

80004abc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004abc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ac0:	18 97       	mov	r7,r12
80004ac2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004ac4:	f0 1f 00 05 	mcall	80004ad8 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004ac8:	f9 e6 10 0b 	or	r11,r12,r6
80004acc:	5c 5b       	castu.b	r11
80004ace:	0e 9c       	mov	r12,r7
80004ad0:	f0 1f 00 03 	mcall	80004adc <SetBitMask+0x20>
}
80004ad4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	4a 18       	lddpc	r8,80004b5c <M500PcdConfigISOType+0x24>
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	49 58       	lddpc	r8,80004b30 <PcdAntennaOff+0x8>

80004ae0 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004ae0:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004ae2:	31 4c       	mov	r12,20
80004ae4:	f0 1f 00 05 	mcall	80004af8 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004ae8:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004aec:	c0 51       	brne	80004af6 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004aee:	30 3b       	mov	r11,3
80004af0:	31 4c       	mov	r12,20
80004af2:	f0 1f 00 03 	mcall	80004afc <PcdAntennaOn+0x1c>
80004af6:	d8 02       	popm	pc
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	4a 18       	lddpc	r8,80004b7c <M500PcdConfigISOType+0x44>
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	4a bc       	lddpc	r12,80004ba8 <rc522_init>

80004b00 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004b00:	eb cd 40 c0 	pushm	r6-r7,lr
80004b04:	18 97       	mov	r7,r12
80004b06:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004b08:	f0 1f 00 06 	mcall	80004b20 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004b0c:	5c d6       	com	r6
80004b0e:	f9 e6 00 06 	and	r6,r12,r6
80004b12:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004b16:	0e 9c       	mov	r12,r7
80004b18:	f0 1f 00 03 	mcall	80004b24 <ClearBitMask+0x24>
	
}
80004b1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	4a 18       	lddpc	r8,80004ba4 <M500PcdConfigISOType+0x6c>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	49 58       	lddpc	r8,80004b78 <M500PcdConfigISOType+0x40>

80004b28 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004b28:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004b2a:	30 3b       	mov	r11,3
80004b2c:	31 4c       	mov	r12,20
80004b2e:	f0 1f 00 02 	mcall	80004b34 <PcdAntennaOff+0xc>
}
80004b32:	d8 02       	popm	pc
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4b 00       	lddpc	r0,80004bf4 <rc522_init+0x4c>

80004b38 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004b38:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004b3a:	34 18       	mov	r8,65
80004b3c:	f0 0c 18 00 	cp.b	r12,r8
80004b40:	c0 20       	breq	80004b44 <M500PcdConfigISOType+0xc>
80004b42:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004b44:	30 8b       	mov	r11,8
80004b46:	16 9c       	mov	r12,r11
80004b48:	f0 1f 00 14 	mcall	80004b98 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004b4c:	33 db       	mov	r11,61
80004b4e:	31 1c       	mov	r12,17
80004b50:	f0 1f 00 13 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b54:	e0 6b 00 86 	mov	r11,134
80004b58:	31 7c       	mov	r12,23
80004b5a:	f0 1f 00 11 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b5e:	37 fb       	mov	r11,127
80004b60:	32 6c       	mov	r12,38
80004b62:	f0 1f 00 0f 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b66:	31 eb       	mov	r11,30
80004b68:	32 dc       	mov	r12,45
80004b6a:	f0 1f 00 0d 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b6e:	30 0b       	mov	r11,0
80004b70:	32 cc       	mov	r12,44
80004b72:	f0 1f 00 0b 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b76:	e0 6b 00 8d 	mov	r11,141
80004b7a:	32 ac       	mov	r12,42
80004b7c:	f0 1f 00 08 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b80:	33 eb       	mov	r11,62
80004b82:	32 bc       	mov	r12,43
80004b84:	f0 1f 00 06 	mcall	80004b9c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004b88:	e0 6c 03 e8 	mov	r12,1000
80004b8c:	f0 1f 00 05 	mcall	80004ba0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004b90:	f0 1f 00 05 	mcall	80004ba4 <M500PcdConfigISOType+0x6c>
80004b94:	d8 0a       	popm	pc,r12=0
80004b96:	00 00       	add	r0,r0
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	4b 00       	lddpc	r0,80004c58 <rc522_init+0xb0>
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	49 58       	lddpc	r8,80004bf0 <rc522_init+0x48>
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	53 54       	stdsp	sp[0xd4],r4
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	4a e0       	lddpc	r0,80004c5c <rc522_init+0xb4>

80004ba8 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bac:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004bae:	4a 38       	lddpc	r8,80004c38 <rc522_init+0x90>
80004bb0:	1a 96       	mov	r6,sp
80004bb2:	f0 ea 00 00 	ld.d	r10,r8[0]
80004bb6:	fa eb 00 00 	st.d	sp[0],r10
80004bba:	f0 e8 00 08 	ld.d	r8,r8[8]
80004bbe:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004bc2:	30 4b       	mov	r11,4
80004bc4:	49 ec       	lddpc	r12,80004c3c <rc522_init+0x94>
80004bc6:	f0 1f 00 1f 	mcall	80004c40 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004bca:	31 9c       	mov	r12,25
80004bcc:	f0 1f 00 1e 	mcall	80004c44 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004bd0:	31 9c       	mov	r12,25
80004bd2:	f0 1f 00 1e 	mcall	80004c48 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004bd6:	49 e7       	lddpc	r7,80004c4c <rc522_init+0xa4>
80004bd8:	fe 7c 24 00 	mov	r12,-56320
80004bdc:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004bde:	1a 9b       	mov	r11,sp
80004be0:	f0 1f 00 1c 	mcall	80004c50 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004be4:	30 09       	mov	r9,0
80004be6:	12 9a       	mov	r10,r9
80004be8:	12 9b       	mov	r11,r9
80004bea:	6e 0c       	ld.w	r12,r7[0x0]
80004bec:	f0 1f 00 1a 	mcall	80004c54 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004bf0:	6e 0c       	ld.w	r12,r7[0x0]
80004bf2:	f0 1f 00 1a 	mcall	80004c58 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004bf6:	e0 6a 36 00 	mov	r10,13824
80004bfa:	ea 1a 01 6e 	orh	r10,0x16e
80004bfe:	1a 9b       	mov	r11,sp
80004c00:	6e 0c       	ld.w	r12,r7[0x0]
80004c02:	f0 1f 00 17 	mcall	80004c5c <rc522_init+0xb4>
80004c06:	c0 50       	breq	80004c10 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004c08:	30 29       	mov	r9,2
80004c0a:	49 68       	lddpc	r8,80004c60 <rc522_init+0xb8>
80004c0c:	b0 89       	st.b	r8[0x0],r9
80004c0e:	c0 38       	rjmp	80004c14 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004c10:	f0 1f 00 15 	mcall	80004c64 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004c14:	f0 1f 00 15 	mcall	80004c68 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004c18:	f0 1f 00 15 	mcall	80004c6c <rc522_init+0xc4>
	
	delay_ms(2); 
80004c1c:	30 2c       	mov	r12,2
80004c1e:	f0 1f 00 15 	mcall	80004c70 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004c22:	f0 1f 00 15 	mcall	80004c74 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004c26:	34 1c       	mov	r12,65
80004c28:	f0 1f 00 14 	mcall	80004c78 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004c2c:	30 1c       	mov	r12,1
80004c2e:	f0 1f 00 14 	mcall	80004c7c <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004c32:	2f cd       	sub	sp,-16
80004c34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	d8 70       	acall	0x87
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	d8 50       	acall	0x85
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	55 6c       	stdsp	sp[0x158],r12
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	55 9c       	stdsp	sp[0x164],r12
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	55 b4       	stdsp	sp[0x16c],r4
80004c4c:	00 00       	add	r0,r0
80004c4e:	1d ac       	ld.ub	r12,lr[0x2]
80004c50:	80 00       	ld.sh	r0,r0[0x0]
80004c52:	58 6c       	cp.w	r12,6
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	58 a4       	cp.w	r4,10
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	58 d0       	cp.w	r0,13
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	59 14       	cp.w	r4,17
80004c60:	00 00       	add	r0,r0
80004c62:	0b 60       	ld.uh	r0,--r5
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	48 ec       	lddpc	r12,80004c9c <PcdComMF522+0x1c>
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	49 98       	lddpc	r8,80004ccc <PcdComMF522+0x4c>
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	4b 28       	lddpc	r8,80004d34 <PcdComMF522+0xb4>
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	53 94       	stdsp	sp[0xe4],r4
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	4a e0       	lddpc	r0,80004d2c <PcdComMF522+0xac>
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	4b 38       	lddpc	r8,80004d44 <PcdComMF522+0xc4>
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	4a 70       	lddpc	r0,80004d18 <PcdComMF522+0x98>

80004c80 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c80:	d4 31       	pushm	r0-r7,lr
80004c82:	20 1d       	sub	sp,4
80004c84:	18 92       	mov	r2,r12
80004c86:	16 95       	mov	r5,r11
80004c88:	14 96       	mov	r6,r10
80004c8a:	50 09       	stdsp	sp[0x0],r9
80004c8c:	10 90       	mov	r0,r8
80004c8e:	f8 c8 00 0c 	sub	r8,r12,12
80004c92:	5c 58       	castu.b	r8
80004c94:	30 29       	mov	r9,2
80004c96:	f2 08 18 00 	cp.b	r8,r9
80004c9a:	e0 88 00 05 	brls	80004ca4 <PcdComMF522+0x24>
80004c9e:	30 03       	mov	r3,0
80004ca0:	06 91       	mov	r1,r3
80004ca2:	c0 78       	rjmp	80004cb0 <PcdComMF522+0x30>
80004ca4:	4c f9       	lddpc	r9,80004de0 <PcdComMF522+0x160>
80004ca6:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004caa:	4c f9       	lddpc	r9,80004de4 <PcdComMF522+0x164>
80004cac:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004cb0:	02 9b       	mov	r11,r1
80004cb2:	a7 bb       	sbr	r11,0x7
80004cb4:	30 2c       	mov	r12,2
80004cb6:	f0 1f 00 4d 	mcall	80004de8 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004cba:	e0 6b 00 80 	mov	r11,128
80004cbe:	30 4c       	mov	r12,4
80004cc0:	f0 1f 00 4b 	mcall	80004dec <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cc4:	30 0b       	mov	r11,0
80004cc6:	30 1c       	mov	r12,1
80004cc8:	f0 1f 00 48 	mcall	80004de8 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004ccc:	e0 6b 00 80 	mov	r11,128
80004cd0:	30 ac       	mov	r12,10
80004cd2:	f0 1f 00 48 	mcall	80004df0 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004cd6:	58 06       	cp.w	r6,0
80004cd8:	c0 c0       	breq	80004cf0 <PcdComMF522+0x70>
80004cda:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004cdc:	30 94       	mov	r4,9
80004cde:	0f 3b       	ld.ub	r11,r7++
80004ce0:	08 9c       	mov	r12,r4
80004ce2:	f0 1f 00 42 	mcall	80004de8 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004ce6:	0e 98       	mov	r8,r7
80004ce8:	0a 18       	sub	r8,r5
80004cea:	ec 08 19 00 	cp.h	r8,r6
80004cee:	cf 83       	brcs	80004cde <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004cf0:	04 9b       	mov	r11,r2
80004cf2:	30 1c       	mov	r12,1
80004cf4:	f0 1f 00 3d 	mcall	80004de8 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004cf8:	30 c8       	mov	r8,12
80004cfa:	f0 02 18 00 	cp.b	r2,r8
80004cfe:	c0 61       	brne	80004d0a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004d00:	e0 6b 00 80 	mov	r11,128
80004d04:	30 dc       	mov	r12,13
80004d06:	f0 1f 00 3b 	mcall	80004df0 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d0a:	30 4c       	mov	r12,4
80004d0c:	f0 1f 00 3a 	mcall	80004df4 <PcdComMF522+0x174>
80004d10:	18 97       	mov	r7,r12
80004d12:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d16:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d18:	30 44       	mov	r4,4
80004d1a:	c0 88       	rjmp	80004d2a <PcdComMF522+0xaa>
80004d1c:	08 9c       	mov	r12,r4
80004d1e:	f0 1f 00 36 	mcall	80004df4 <PcdComMF522+0x174>
80004d22:	18 97       	mov	r7,r12
		i--;
80004d24:	20 16       	sub	r6,1
80004d26:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d28:	c0 a0       	breq	80004d3c <PcdComMF522+0xbc>
80004d2a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004d2e:	c4 c1       	brne	80004dc6 <PcdComMF522+0x146>
80004d30:	ef e3 00 08 	and	r8,r7,r3
80004d34:	ea 08 18 00 	cp.b	r8,r5
80004d38:	cf 20       	breq	80004d1c <PcdComMF522+0x9c>
80004d3a:	c4 68       	rjmp	80004dc6 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004d3c:	e0 6b 00 80 	mov	r11,128
80004d40:	30 dc       	mov	r12,13
80004d42:	f0 1f 00 2b 	mcall	80004dec <PcdComMF522+0x16c>
80004d46:	30 27       	mov	r7,2
80004d48:	c3 38       	rjmp	80004dae <PcdComMF522+0x12e>
80004d4a:	02 67       	and	r7,r1
80004d4c:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004d50:	30 c8       	mov	r8,12
80004d52:	f0 02 18 00 	cp.b	r2,r8
80004d56:	c2 c1       	brne	80004dae <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004d58:	30 ac       	mov	r12,10
80004d5a:	f0 1f 00 27 	mcall	80004df4 <PcdComMF522+0x174>
80004d5e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004d60:	30 cc       	mov	r12,12
80004d62:	f0 1f 00 25 	mcall	80004df4 <PcdComMF522+0x174>
80004d66:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004d6a:	c0 70       	breq	80004d78 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004d6c:	08 98       	mov	r8,r4
80004d6e:	20 18       	sub	r8,1
80004d70:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d74:	a0 8c       	st.b	r0[0x0],r12
80004d76:	c0 48       	rjmp	80004d7e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d78:	e8 08 15 03 	lsl	r8,r4,0x3
80004d7c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d7e:	58 04       	cp.w	r4,0
80004d80:	c0 61       	brne	80004d8c <PcdComMF522+0x10c>
80004d82:	30 14       	mov	r4,1
80004d84:	40 05       	lddsp	r5,sp[0x0]
80004d86:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d88:	30 93       	mov	r3,9
80004d8a:	c0 98       	rjmp	80004d9c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d8c:	31 28       	mov	r8,18
80004d8e:	f0 04 18 00 	cp.b	r4,r8
80004d92:	f9 b4 0b 12 	movhi	r4,18
80004d96:	58 04       	cp.w	r4,0
80004d98:	cf 61       	brne	80004d84 <PcdComMF522+0x104>
80004d9a:	c0 a8       	rjmp	80004dae <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d9c:	06 9c       	mov	r12,r3
80004d9e:	f0 1f 00 16 	mcall	80004df4 <PcdComMF522+0x174>
80004da2:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004da4:	ec 05 01 08 	sub	r8,r6,r5
80004da8:	e8 08 19 00 	cp.h	r8,r4
80004dac:	cf 83       	brcs	80004d9c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004dae:	e0 6b 00 80 	mov	r11,128
80004db2:	30 cc       	mov	r12,12
80004db4:	f0 1f 00 0f 	mcall	80004df0 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004db8:	30 0b       	mov	r11,0
80004dba:	30 1c       	mov	r12,1
80004dbc:	f0 1f 00 0b 	mcall	80004de8 <PcdComMF522+0x168>
	return status;
}
80004dc0:	0e 9c       	mov	r12,r7
80004dc2:	2f fd       	sub	sp,-4
80004dc4:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004dc6:	e0 6b 00 80 	mov	r11,128
80004dca:	30 dc       	mov	r12,13
80004dcc:	f0 1f 00 08 	mcall	80004dec <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004dd0:	30 6c       	mov	r12,6
80004dd2:	f0 1f 00 09 	mcall	80004df4 <PcdComMF522+0x174>
80004dd6:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004dda:	cb 80       	breq	80004d4a <PcdComMF522+0xca>
80004ddc:	30 27       	mov	r7,2
80004dde:	ce 8b       	rjmp	80004dae <PcdComMF522+0x12e>
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	d8 48       	*unknown*
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	d8 4c       	*unknown*
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	49 58       	lddpc	r8,80004e3c <PcdAnticoll+0x44>
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	4b 00       	lddpc	r0,80004eac <PcdRequest+0x30>
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4a bc       	lddpc	r12,80004e9c <PcdRequest+0x20>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4a 18       	lddpc	r8,80004e78 <PcdAnticoll+0x80>

80004df8 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004df8:	eb cd 40 c0 	pushm	r6-r7,lr
80004dfc:	20 5d       	sub	sp,20
80004dfe:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004e00:	30 8b       	mov	r11,8
80004e02:	16 9c       	mov	r12,r11
80004e04:	f0 1f 00 1a 	mcall	80004e6c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004e08:	30 0b       	mov	r11,0
80004e0a:	30 dc       	mov	r12,13
80004e0c:	f0 1f 00 19 	mcall	80004e70 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004e10:	e0 6b 00 80 	mov	r11,128
80004e14:	30 ec       	mov	r12,14
80004e16:	f0 1f 00 16 	mcall	80004e6c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e1a:	39 38       	mov	r8,-109
80004e1c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004e1e:	32 08       	mov	r8,32
80004e20:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004e22:	1a 9b       	mov	r11,sp
80004e24:	fa c8 ff ed 	sub	r8,sp,-19
80004e28:	1a 99       	mov	r9,sp
80004e2a:	30 2a       	mov	r10,2
80004e2c:	30 cc       	mov	r12,12
80004e2e:	f0 1f 00 12 	mcall	80004e74 <PcdAnticoll+0x7c>
80004e32:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004e34:	c1 21       	brne	80004e58 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e36:	1b 89       	ld.ub	r9,sp[0x0]
80004e38:	ac 89       	st.b	r6[0x0],r9
80004e3a:	1b 98       	ld.ub	r8,sp[0x1]
80004e3c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004e3e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e40:	1b a8       	ld.ub	r8,sp[0x2]
80004e42:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004e44:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e48:	1b b9       	ld.ub	r9,sp[0x3]
80004e4a:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004e4c:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004e4e:	1b c9       	ld.ub	r9,sp[0x4]
80004e50:	f0 09 18 00 	cp.b	r9,r8
80004e54:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004e58:	e0 6b 00 80 	mov	r11,128
80004e5c:	30 ec       	mov	r12,14
80004e5e:	f0 1f 00 07 	mcall	80004e78 <PcdAnticoll+0x80>
	return status;
}
80004e62:	0e 9c       	mov	r12,r7
80004e64:	2f bd       	sub	sp,-20
80004e66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e6a:	00 00       	add	r0,r0
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4b 00       	lddpc	r0,80004f2c <CalulateCRC+0x4c>
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	49 58       	lddpc	r8,80004ec4 <PcdRequest+0x48>
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	4c 80       	lddpc	r0,80004f94 <PcdSelect+0x28>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	4a bc       	lddpc	r12,80004f24 <CalulateCRC+0x44>

80004e7c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e80:	20 5d       	sub	sp,20
80004e82:	18 97       	mov	r7,r12
80004e84:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e86:	30 8b       	mov	r11,8
80004e88:	16 9c       	mov	r12,r11
80004e8a:	f0 1f 00 12 	mcall	80004ed0 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e8e:	30 7b       	mov	r11,7
80004e90:	30 dc       	mov	r12,13
80004e92:	f0 1f 00 11 	mcall	80004ed4 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004e96:	30 3b       	mov	r11,3
80004e98:	31 4c       	mov	r12,20
80004e9a:	f0 1f 00 10 	mcall	80004ed8 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004e9e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004ea0:	1a 9b       	mov	r11,sp
80004ea2:	fa c8 ff ed 	sub	r8,sp,-19
80004ea6:	1a 99       	mov	r9,sp
80004ea8:	30 1a       	mov	r10,1
80004eaa:	30 cc       	mov	r12,12
80004eac:	f0 1f 00 0c 	mcall	80004edc <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004eb0:	c0 c1       	brne	80004ec8 <PcdRequest+0x4c>
80004eb2:	31 08       	mov	r8,16
80004eb4:	fb 39 00 13 	ld.ub	r9,sp[19]
80004eb8:	f0 09 18 00 	cp.b	r9,r8
80004ebc:	c0 61       	brne	80004ec8 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004ebe:	1b 88       	ld.ub	r8,sp[0x0]
80004ec0:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004ec2:	1b 98       	ld.ub	r8,sp[0x1]
80004ec4:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004ec6:	c0 28       	rjmp	80004eca <PcdRequest+0x4e>
80004ec8:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004eca:	2f bd       	sub	sp,-20
80004ecc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	4b 00       	lddpc	r0,80004f90 <PcdSelect+0x24>
80004ed4:	80 00       	ld.sh	r0,r0[0x0]
80004ed6:	49 58       	lddpc	r8,80004f28 <CalulateCRC+0x48>
80004ed8:	80 00       	ld.sh	r0,r0[0x0]
80004eda:	4a bc       	lddpc	r12,80004f84 <PcdSelect+0x18>
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	4c 80       	lddpc	r0,80004ffc <rfid_auto_reader+0x1c>

80004ee0 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004ee0:	eb cd 40 f8 	pushm	r3-r7,lr
80004ee4:	18 95       	mov	r5,r12
80004ee6:	16 96       	mov	r6,r11
80004ee8:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004eea:	30 4b       	mov	r11,4
80004eec:	30 5c       	mov	r12,5
80004eee:	f0 1f 00 1c 	mcall	80004f5c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ef2:	30 0b       	mov	r11,0
80004ef4:	30 1c       	mov	r12,1
80004ef6:	f0 1f 00 1b 	mcall	80004f60 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004efa:	e0 6b 00 80 	mov	r11,128
80004efe:	30 ac       	mov	r12,10
80004f00:	f0 1f 00 19 	mcall	80004f64 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004f04:	58 06       	cp.w	r6,0
80004f06:	c0 c0       	breq	80004f1e <CalulateCRC+0x3e>
80004f08:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004f0a:	30 94       	mov	r4,9
80004f0c:	0f 3b       	ld.ub	r11,r7++
80004f0e:	08 9c       	mov	r12,r4
80004f10:	f0 1f 00 14 	mcall	80004f60 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004f14:	0e 98       	mov	r8,r7
80004f16:	0a 18       	sub	r8,r5
80004f18:	ec 08 18 00 	cp.b	r8,r6
80004f1c:	cf 83       	brcs	80004f0c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004f1e:	30 3b       	mov	r11,3
80004f20:	30 1c       	mov	r12,1
80004f22:	f0 1f 00 10 	mcall	80004f60 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004f26:	30 5c       	mov	r12,5
80004f28:	f0 1f 00 10 	mcall	80004f68 <CalulateCRC+0x88>
80004f2c:	e0 67 00 fe 	mov	r7,254
80004f30:	30 56       	mov	r6,5
80004f32:	c0 78       	rjmp	80004f40 <CalulateCRC+0x60>
80004f34:	0c 9c       	mov	r12,r6
80004f36:	f0 1f 00 0d 	mcall	80004f68 <CalulateCRC+0x88>
		i--;
80004f3a:	20 17       	sub	r7,1
80004f3c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004f3e:	c0 40       	breq	80004f46 <CalulateCRC+0x66>
80004f40:	e2 1c 00 04 	andl	r12,0x4,COH
80004f44:	cf 80       	breq	80004f34 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004f46:	32 2c       	mov	r12,34
80004f48:	f0 1f 00 08 	mcall	80004f68 <CalulateCRC+0x88>
80004f4c:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004f4e:	32 1c       	mov	r12,33
80004f50:	f0 1f 00 06 	mcall	80004f68 <CalulateCRC+0x88>
80004f54:	a6 9c       	st.b	r3[0x1],r12
}
80004f56:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004f5a:	00 00       	add	r0,r0
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	4b 00       	lddpc	r0,8000501c <rfid_auto_reader+0x3c>
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	49 58       	lddpc	r8,80004fb4 <PcdSelect+0x48>
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4a bc       	lddpc	r12,80005010 <rfid_auto_reader+0x30>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	4a 18       	lddpc	r8,80004fec <rfid_auto_reader+0xc>

80004f6c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004f6c:	eb cd 40 80 	pushm	r7,lr
80004f70:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f72:	39 38       	mov	r8,-109
80004f74:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f76:	37 08       	mov	r8,112
80004f78:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f7a:	30 08       	mov	r8,0
80004f7c:	ba e8       	st.b	sp[0x6],r8
80004f7e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f82:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f86:	19 89       	ld.ub	r9,r12[0x0]
80004f88:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f8a:	19 3a       	ld.ub	r10,r12++
80004f8c:	1b e9       	ld.ub	r9,sp[0x6]
80004f8e:	f5 e9 20 09 	eor	r9,r10,r9
80004f92:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004f94:	16 38       	cp.w	r8,r11
80004f96:	cf 81       	brne	80004f86 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004f98:	1a 97       	mov	r7,sp
80004f9a:	fa ca ff f9 	sub	r10,sp,-7
80004f9e:	30 7b       	mov	r11,7
80004fa0:	1a 9c       	mov	r12,sp
80004fa2:	f0 1f 00 0d 	mcall	80004fd4 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004fa6:	30 8b       	mov	r11,8
80004fa8:	16 9c       	mov	r12,r11
80004faa:	f0 1f 00 0c 	mcall	80004fd8 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004fae:	fa c8 ff ed 	sub	r8,sp,-19
80004fb2:	1a 99       	mov	r9,sp
80004fb4:	30 9a       	mov	r10,9
80004fb6:	1a 9b       	mov	r11,sp
80004fb8:	30 cc       	mov	r12,12
80004fba:	f0 1f 00 09 	mcall	80004fdc <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004fbe:	c0 71       	brne	80004fcc <PcdSelect+0x60>
80004fc0:	31 88       	mov	r8,24
80004fc2:	fb 39 00 13 	ld.ub	r9,sp[19]
80004fc6:	f0 09 18 00 	cp.b	r9,r8
80004fca:	c0 20       	breq	80004fce <PcdSelect+0x62>
80004fcc:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004fce:	2f bd       	sub	sp,-20
80004fd0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	4e e0       	lddpc	r0,8000518c <scan_rfid_save_message+0x3c>
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	4b 00       	lddpc	r0,80005098 <rfid_auto_reader+0xb8>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	4c 80       	lddpc	r0,800050fc <rfid_auto_reader+0x11c>

80004fe0 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004fe0:	eb cd 40 c0 	pushm	r6-r7,lr
80004fe4:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004fe6:	f0 1f 00 37 	mcall	800050c0 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004fea:	4b 7b       	lddpc	r11,800050c4 <rfid_auto_reader+0xe4>
80004fec:	35 2c       	mov	r12,82
80004fee:	f0 1f 00 37 	mcall	800050c8 <rfid_auto_reader+0xe8>
80004ff2:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004ff4:	c6 31       	brne	800050ba <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004ff6:	4b 48       	lddpc	r8,800050c4 <rfid_auto_reader+0xe4>
80004ff8:	11 88       	ld.ub	r8,r8[0x0]
80004ffa:	30 49       	mov	r9,4
80004ffc:	f2 08 18 00 	cp.b	r8,r9
80005000:	c0 b1       	brne	80005016 <rfid_auto_reader+0x36>
80005002:	4b 19       	lddpc	r9,800050c4 <rfid_auto_reader+0xe4>
80005004:	13 9a       	ld.ub	r10,r9[0x1]
80005006:	30 09       	mov	r9,0
80005008:	f2 0a 18 00 	cp.b	r10,r9
8000500c:	c0 51       	brne	80005016 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000500e:	4b 0c       	lddpc	r12,800050cc <rfid_auto_reader+0xec>
80005010:	f0 1f 00 30 	mcall	800050d0 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005014:	c3 c8       	rjmp	8000508c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005016:	30 29       	mov	r9,2
80005018:	f2 08 18 00 	cp.b	r8,r9
8000501c:	c0 b1       	brne	80005032 <rfid_auto_reader+0x52>
8000501e:	4a a9       	lddpc	r9,800050c4 <rfid_auto_reader+0xe4>
80005020:	13 9a       	ld.ub	r10,r9[0x1]
80005022:	30 09       	mov	r9,0
80005024:	f2 0a 18 00 	cp.b	r10,r9
80005028:	c0 51       	brne	80005032 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
8000502a:	4a bc       	lddpc	r12,800050d4 <rfid_auto_reader+0xf4>
8000502c:	f0 1f 00 29 	mcall	800050d0 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005030:	c2 e8       	rjmp	8000508c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005032:	34 49       	mov	r9,68
80005034:	f2 08 18 00 	cp.b	r8,r9
80005038:	c0 b1       	brne	8000504e <rfid_auto_reader+0x6e>
8000503a:	4a 39       	lddpc	r9,800050c4 <rfid_auto_reader+0xe4>
8000503c:	13 9a       	ld.ub	r10,r9[0x1]
8000503e:	30 09       	mov	r9,0
80005040:	f2 0a 18 00 	cp.b	r10,r9
80005044:	c0 51       	brne	8000504e <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005046:	4a 5c       	lddpc	r12,800050d8 <rfid_auto_reader+0xf8>
80005048:	f0 1f 00 22 	mcall	800050d0 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000504c:	c2 08       	rjmp	8000508c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000504e:	30 89       	mov	r9,8
80005050:	f2 08 18 00 	cp.b	r8,r9
80005054:	c0 b1       	brne	8000506a <rfid_auto_reader+0x8a>
80005056:	49 c9       	lddpc	r9,800050c4 <rfid_auto_reader+0xe4>
80005058:	13 9a       	ld.ub	r10,r9[0x1]
8000505a:	30 09       	mov	r9,0
8000505c:	f2 0a 18 00 	cp.b	r10,r9
80005060:	c0 51       	brne	8000506a <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005062:	49 fc       	lddpc	r12,800050dc <rfid_auto_reader+0xfc>
80005064:	f0 1f 00 1b 	mcall	800050d0 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005068:	c1 28       	rjmp	8000508c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000506a:	34 49       	mov	r9,68
8000506c:	f2 08 18 00 	cp.b	r8,r9
80005070:	c0 b1       	brne	80005086 <rfid_auto_reader+0xa6>
80005072:	49 58       	lddpc	r8,800050c4 <rfid_auto_reader+0xe4>
80005074:	11 99       	ld.ub	r9,r8[0x1]
80005076:	30 38       	mov	r8,3
80005078:	f0 09 18 00 	cp.b	r9,r8
8000507c:	c0 51       	brne	80005086 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000507e:	49 9c       	lddpc	r12,800050e0 <rfid_auto_reader+0x100>
80005080:	f0 1f 00 14 	mcall	800050d0 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005084:	c0 48       	rjmp	8000508c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005086:	49 8c       	lddpc	r12,800050e4 <rfid_auto_reader+0x104>
80005088:	f0 1f 00 12 	mcall	800050d0 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000508c:	49 7c       	lddpc	r12,800050e8 <rfid_auto_reader+0x108>
8000508e:	f0 1f 00 18 	mcall	800050ec <rfid_auto_reader+0x10c>
80005092:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005094:	c0 60       	breq	800050a0 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80005096:	34 fb       	mov	r11,79
80005098:	30 1c       	mov	r12,1
8000509a:	f0 1f 00 16 	mcall	800050f0 <rfid_auto_reader+0x110>
		return status;
8000509e:	c0 e8       	rjmp	800050ba <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800050a0:	49 2c       	lddpc	r12,800050e8 <rfid_auto_reader+0x108>
800050a2:	f0 1f 00 15 	mcall	800050f4 <rfid_auto_reader+0x114>
800050a6:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800050a8:	c0 91       	brne	800050ba <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800050aa:	30 4a       	mov	r10,4
800050ac:	48 fb       	lddpc	r11,800050e8 <rfid_auto_reader+0x108>
800050ae:	0c 9c       	mov	r12,r6
800050b0:	f0 1f 00 12 	mcall	800050f8 <rfid_auto_reader+0x118>
		log("select okay\n");
800050b4:	49 2c       	lddpc	r12,800050fc <rfid_auto_reader+0x11c>
800050b6:	f0 1f 00 07 	mcall	800050d0 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800050ba:	0e 9c       	mov	r12,r7
800050bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	49 98       	lddpc	r8,80005124 <scan_patrol+0x24>
800050c4:	00 00       	add	r0,r0
800050c6:	97 40       	st.w	r11[0x10],r0
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	4e 7c       	lddpc	r12,80005264 <scan_rfid_save_message+0x114>
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	d8 80       	acall	0x88
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	70 18       	ld.w	r8,r8[0x4]
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	d8 8c       	*unknown*
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	d8 98       	*unknown*
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	d8 a8       	*unknown*
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	d8 b0       	acall	0x8b
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	d8 bc       	*unknown*
800050e8:	00 00       	add	r0,r0
800050ea:	97 44       	st.w	r11[0x10],r4
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4d f8       	lddpc	r8,80005268 <scan_rfid_save_message+0x118>
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	40 ec       	lddsp	r12,sp[0x38]
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	4f 6c       	lddpc	r12,800052cc <scan_rfid_save_message+0x17c>
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	78 94       	ld.w	r4,r12[0x24]
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	d8 c8       	*unknown*

80005100 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005100:	eb cd 40 80 	pushm	r7,lr
80005104:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005106:	f0 1f 00 0d 	mcall	80005138 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
8000510a:	30 0c       	mov	r12,0
8000510c:	f0 1f 00 0c 	mcall	8000513c <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005110:	0e 9c       	mov	r12,r7
80005112:	f0 1f 00 0c 	mcall	80005140 <scan_patrol+0x40>
80005116:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005118:	30 1c       	mov	r12,1
8000511a:	f0 1f 00 09 	mcall	8000513c <scan_patrol+0x3c>
	if(return_err == 0)
8000511e:	58 07       	cp.w	r7,0
80005120:	c0 51       	brne	8000512a <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80005122:	48 9c       	lddpc	r12,80005144 <scan_patrol+0x44>
80005124:	f0 1f 00 09 	mcall	80005148 <scan_patrol+0x48>
80005128:	c0 48       	rjmp	80005130 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
8000512a:	48 9c       	lddpc	r12,8000514c <scan_patrol+0x4c>
8000512c:	f0 1f 00 07 	mcall	80005148 <scan_patrol+0x48>
		
	return return_err;

}
80005130:	0e 9c       	mov	r12,r7
80005132:	e3 cd 80 80 	ldm	sp++,r7,pc
80005136:	00 00       	add	r0,r0
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	49 98       	lddpc	r8,8000519c <scan_rfid_save_message+0x4c>
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	4a 70       	lddpc	r0,800051d8 <scan_rfid_save_message+0x88>
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	4f e0       	lddpc	r0,80005338 <scan_rfid_save_message+0x1e8>
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	d8 d8       	*unknown*
80005148:	80 00       	ld.sh	r0,r0[0x0]
8000514a:	70 18       	ld.w	r8,r8[0x4]
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	d8 ec       	*unknown*

80005150 <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
80005150:	eb cd 40 e0 	pushm	r5-r7,lr
80005154:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80005158:	4e 9c       	lddpc	r12,800052fc <scan_rfid_save_message+0x1ac>
8000515a:	30 08       	mov	r8,0
8000515c:	30 09       	mov	r9,0
8000515e:	f8 e9 00 00 	st.d	r12[0],r8
80005162:	30 0a       	mov	r10,0
80005164:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005166:	fa e9 00 3c 	st.d	sp[60],r8
8000516a:	fa e9 00 44 	st.d	sp[68],r8
8000516e:	fa e9 00 4c 	st.d	sp[76],r8
80005172:	fa e9 00 54 	st.d	sp[84],r8
80005176:	fa e9 00 5c 	st.d	sp[92],r8
8000517a:	fa e9 00 64 	st.d	sp[100],r8
8000517e:	fa e9 00 6c 	st.d	sp[108],r8
80005182:	fa e9 00 74 	st.d	sp[116],r8
80005186:	fa e9 00 7c 	st.d	sp[124],r8
8000518a:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
8000518e:	f0 1f 00 5d 	mcall	80005300 <scan_rfid_save_message+0x1b0>
80005192:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005194:	e0 81 00 a8 	brne	800052e4 <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005198:	4d 96       	lddpc	r6,800052fc <scan_rfid_save_message+0x1ac>
8000519a:	0d b8       	ld.ub	r8,r6[0x3]
8000519c:	1a d8       	st.w	--sp,r8
8000519e:	0d a8       	ld.ub	r8,r6[0x2]
800051a0:	1a d8       	st.w	--sp,r8
800051a2:	0d 98       	ld.ub	r8,r6[0x1]
800051a4:	1a d8       	st.w	--sp,r8
800051a6:	0d 88       	ld.ub	r8,r6[0x0]
800051a8:	1a d8       	st.w	--sp,r8
800051aa:	4d 7c       	lddpc	r12,80005304 <scan_rfid_save_message+0x1b4>
800051ac:	f0 1f 00 57 	mcall	80005308 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
800051b0:	34 4b       	mov	r11,68
800051b2:	30 1c       	mov	r12,1
800051b4:	f0 1f 00 56 	mcall	8000530c <scan_rfid_save_message+0x1bc>
800051b8:	fa c8 ff ce 	sub	r8,sp,-50
800051bc:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
800051c0:	ec c5 ff fc 	sub	r5,r6,-4
800051c4:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800051c6:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800051c8:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800051ca:	0d 8a       	ld.ub	r10,r6[0x0]
800051cc:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800051d0:	fc 0b 18 00 	cp.b	r11,lr
800051d4:	f7 bb 08 d0 	subls	r11,-48
800051d8:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800051dc:	f7 bb 0b a9 	subhi	r11,-87
800051e0:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800051e4:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
800051e6:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800051ea:	fc 0a 18 00 	cp.b	r10,lr
800051ee:	f7 ba 08 d0 	subls	r10,-48
800051f2:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800051f6:	f7 ba 0b a9 	subhi	r10,-87
800051fa:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
800051fe:	b0 bc       	st.b	r8[0x3],r12
80005200:	2f f6       	sub	r6,-1
80005202:	2f c8       	sub	r8,-4
80005204:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005206:	0a 36       	cp.w	r6,r5
80005208:	ce 11       	brne	800051ca <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
8000520a:	4c 28       	lddpc	r8,80005310 <scan_rfid_save_message+0x1c0>
8000520c:	11 89       	ld.ub	r9,r8[0x0]
8000520e:	39 f8       	mov	r8,-97
80005210:	f0 09 18 00 	cp.b	r9,r8
80005214:	e0 88 00 05 	brls	8000521e <scan_rfid_save_message+0xce>
80005218:	38 09       	mov	r9,-128
8000521a:	4b e8       	lddpc	r8,80005310 <scan_rfid_save_message+0x1c0>
8000521c:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
8000521e:	4b d8       	lddpc	r8,80005310 <scan_rfid_save_message+0x1c0>
80005220:	11 86       	ld.ub	r6,r8[0x0]
80005222:	2f f6       	sub	r6,-1
80005224:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005226:	30 5a       	mov	r10,5
80005228:	4b bb       	lddpc	r11,80005314 <scan_rfid_save_message+0x1c4>
8000522a:	fa cc ff c9 	sub	r12,sp,-55
8000522e:	f0 1f 00 3b 	mcall	80005318 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005232:	31 88       	mov	r8,24
80005234:	fb 58 00 32 	st.h	sp[50],r8
80005238:	fb 66 00 36 	st.b	sp[54],r6
8000523c:	fe 78 e0 00 	mov	r8,-8192
80005240:	fb 58 00 34 	st.h	sp[52],r8
80005244:	fa c6 ff c4 	sub	r6,sp,-60
80005248:	30 aa       	mov	r10,10
8000524a:	fa cb ff ce 	sub	r11,sp,-50
8000524e:	0c 9c       	mov	r12,r6
80005250:	f0 1f 00 32 	mcall	80005318 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005254:	31 0a       	mov	r10,16
80005256:	fa cb ff de 	sub	r11,sp,-34
8000525a:	fa cc ff ba 	sub	r12,sp,-70
8000525e:	f0 1f 00 2f 	mcall	80005318 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
80005262:	31 aa       	mov	r10,26
80005264:	0c 9b       	mov	r11,r6
80005266:	fa cc ff fe 	sub	r12,sp,-2
8000526a:	f0 1f 00 2c 	mcall	80005318 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
8000526e:	4a c8       	lddpc	r8,8000531c <scan_rfid_save_message+0x1cc>
80005270:	70 0c       	ld.w	r12,r8[0x0]
80005272:	f0 1f 00 2c 	mcall	80005320 <scan_rfid_save_message+0x1d0>
80005276:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
80005278:	c3 20       	breq	800052dc <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
8000527a:	31 aa       	mov	r10,26
8000527c:	fa cb ff fe 	sub	r11,sp,-2
80005280:	f0 1f 00 26 	mcall	80005318 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005284:	4a 88       	lddpc	r8,80005324 <scan_rfid_save_message+0x1d4>
80005286:	70 0c       	ld.w	r12,r8[0x0]
80005288:	30 09       	mov	r9,0
8000528a:	12 9a       	mov	r10,r9
8000528c:	fa cb ff e4 	sub	r11,sp,-28
80005290:	f0 1f 00 26 	mcall	80005328 <scan_rfid_save_message+0x1d8>
80005294:	58 1c       	cp.w	r12,1
80005296:	c1 10       	breq	800052b8 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
80005298:	4a 5c       	lddpc	r12,8000532c <scan_rfid_save_message+0x1dc>
8000529a:	f0 1f 00 1c 	mcall	80005308 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
8000529e:	32 3b       	mov	r11,35
800052a0:	30 1c       	mov	r12,1
800052a2:	f0 1f 00 1b 	mcall	8000530c <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
800052a6:	e0 6c 17 70 	mov	r12,6000
800052aa:	f0 1f 00 22 	mcall	80005330 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800052ae:	32 3b       	mov	r11,35
800052b0:	30 0c       	mov	r12,0
800052b2:	f0 1f 00 17 	mcall	8000530c <scan_rfid_save_message+0x1bc>
800052b6:	c1 e8       	rjmp	800052f2 <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
800052b8:	49 f6       	lddpc	r6,80005334 <scan_rfid_save_message+0x1e4>
800052ba:	6c 0c       	ld.w	r12,r6[0x0]
800052bc:	30 09       	mov	r9,0
800052be:	3f fa       	mov	r10,-1
800052c0:	12 9b       	mov	r11,r9
800052c2:	f0 1f 00 1e 	mcall	80005338 <scan_rfid_save_message+0x1e8>
				global_count++;
800052c6:	49 e8       	lddpc	r8,8000533c <scan_rfid_save_message+0x1ec>
800052c8:	70 09       	ld.w	r9,r8[0x0]
800052ca:	2f f9       	sub	r9,-1
800052cc:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
800052ce:	6c 0c       	ld.w	r12,r6[0x0]
800052d0:	30 09       	mov	r9,0
800052d2:	12 9a       	mov	r10,r9
800052d4:	12 9b       	mov	r11,r9
800052d6:	f0 1f 00 15 	mcall	80005328 <scan_rfid_save_message+0x1d8>
800052da:	c0 c8       	rjmp	800052f2 <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
800052dc:	49 9c       	lddpc	r12,80005340 <scan_rfid_save_message+0x1f0>
800052de:	f0 1f 00 0b 	mcall	80005308 <scan_rfid_save_message+0x1b8>
800052e2:	c0 88       	rjmp	800052f2 <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
800052e4:	34 fb       	mov	r11,79
800052e6:	30 1c       	mov	r12,1
800052e8:	f0 1f 00 09 	mcall	8000530c <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
800052ec:	49 6c       	lddpc	r12,80005344 <scan_rfid_save_message+0x1f4>
800052ee:	f0 1f 00 07 	mcall	80005308 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
800052f2:	0e 9c       	mov	r12,r7
800052f4:	2d dd       	sub	sp,-140
800052f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052fa:	00 00       	add	r0,r0
800052fc:	00 00       	add	r0,r0
800052fe:	0b 64       	ld.uh	r4,--r5
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	51 00       	stdsp	sp[0x40],r0
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	d9 00       	acall	0x90
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	70 18       	ld.w	r8,r8[0x4]
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	40 ec       	lddsp	r12,sp[0x38]
80005310:	00 00       	add	r0,r0
80005312:	05 28       	ld.uh	r8,r2++
80005314:	00 00       	add	r0,r0
80005316:	05 2c       	ld.uh	r12,r2++
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	78 94       	ld.w	r4,r12[0x24]
8000531c:	00 00       	add	r0,r0
8000531e:	0b 74       	ld.ub	r4,--r5
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	2e 28       	sub	r8,-30
80005324:	00 00       	add	r0,r0
80005326:	0b 70       	ld.ub	r0,--r5
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	63 e0       	ld.w	r0,r1[0x78]
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	d6 b8       	*unknown*
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	6a ac       	ld.w	r12,r5[0x28]
80005334:	00 00       	add	r0,r0
80005336:	0a 60       	and	r0,r5
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	61 d4       	ld.w	r4,r0[0x74]
8000533c:	00 00       	add	r0,r0
8000533e:	0a 58       	eor	r8,r5
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	d7 94       	*unknown*
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	d9 1c       	*unknown*

80005348 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005348:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000534a:	f0 1f 00 02 	mcall	80005350 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000534e:	d8 02       	popm	pc
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	4b a8       	lddpc	r8,80005438 <local_start_pll0+0x50>

80005354 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005354:	58 0c       	cp.w	r12,0
80005356:	5e 0c       	reteq	r12
80005358:	30 08       	mov	r8,0
	{
		nop();
8000535a:	d7 03       	nop
		nop();
8000535c:	d7 03       	nop
		nop();
8000535e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005360:	2f f8       	sub	r8,-1
80005362:	10 3c       	cp.w	r12,r8
80005364:	fe 9b ff fb 	brhi	8000535a <delay_ns+0x6>
80005368:	5e fc       	retal	r12
8000536a:	d7 03       	nop

8000536c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000536c:	eb cd 40 e0 	pushm	r5-r7,lr
80005370:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005372:	58 0c       	cp.w	r12,0
80005374:	c0 b0       	breq	8000538a <delay_us+0x1e>
80005376:	30 07       	mov	r7,0
		delay_ns(1000);
80005378:	e0 65 03 e8 	mov	r5,1000
8000537c:	0a 9c       	mov	r12,r5
8000537e:	f0 1f 00 05 	mcall	80005390 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005382:	2f f7       	sub	r7,-1
80005384:	0e 36       	cp.w	r6,r7
80005386:	fe 9b ff fb 	brhi	8000537c <delay_us+0x10>
8000538a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000538e:	00 00       	add	r0,r0
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	53 54       	stdsp	sp[0xd4],r4

80005394 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005394:	eb cd 40 e0 	pushm	r5-r7,lr
80005398:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000539a:	58 0c       	cp.w	r12,0
8000539c:	c0 b0       	breq	800053b2 <delay_ms+0x1e>
8000539e:	30 07       	mov	r7,0
		delay_us(1000);
800053a0:	e0 65 03 e8 	mov	r5,1000
800053a4:	0a 9c       	mov	r12,r5
800053a6:	f0 1f 00 05 	mcall	800053b8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800053aa:	2f f7       	sub	r7,-1
800053ac:	0e 36       	cp.w	r6,r7
800053ae:	fe 9b ff fb 	brhi	800053a4 <delay_ms+0x10>
800053b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053b6:	00 00       	add	r0,r0
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	53 6c       	stdsp	sp[0xd8],r12

800053bc <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800053bc:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800053be:	30 3b       	mov	r11,3
800053c0:	48 8c       	lddpc	r12,800053e0 <local_start_timer+0x24>
800053c2:	f0 1f 00 09 	mcall	800053e4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800053c6:	fe 78 38 00 	mov	r8,-51200
800053ca:	e0 69 91 0d 	mov	r9,37133
800053ce:	ea 19 00 52 	orh	r9,0x52
800053d2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800053d4:	32 09       	mov	r9,32
800053d6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800053d8:	30 59       	mov	r9,5
800053da:	91 09       	st.w	r8[0x0],r9
}
800053dc:	d8 02       	popm	pc
800053de:	00 00       	add	r0,r0
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	d9 30       	acall	0x93
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	55 6c       	stdsp	sp[0x158],r12

800053e8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800053e8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800053ea:	30 3a       	mov	r10,3
800053ec:	e0 6b 1b 00 	mov	r11,6912
800053f0:	ea 1b 00 b7 	orh	r11,0xb7
800053f4:	fe 7c 0c 00 	mov	r12,-62464
800053f8:	f0 1f 00 19 	mcall	8000545c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800053fc:	31 08       	mov	r8,16
800053fe:	1a d8       	st.w	--sp,r8
80005400:	30 08       	mov	r8,0
80005402:	30 19       	mov	r9,1
80005404:	30 7a       	mov	r10,7
80005406:	10 9b       	mov	r11,r8
80005408:	fe 7c 0c 00 	mov	r12,-62464
8000540c:	f0 1f 00 15 	mcall	80005460 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005410:	30 08       	mov	r8,0
80005412:	30 19       	mov	r9,1
80005414:	12 9a       	mov	r10,r9
80005416:	10 9b       	mov	r11,r8
80005418:	fe 7c 0c 00 	mov	r12,-62464
8000541c:	f0 1f 00 12 	mcall	80005464 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005420:	30 0b       	mov	r11,0
80005422:	fe 7c 0c 00 	mov	r12,-62464
80005426:	f0 1f 00 11 	mcall	80005468 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000542a:	fe 7c 0c 00 	mov	r12,-62464
8000542e:	f0 1f 00 10 	mcall	8000546c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005432:	30 0a       	mov	r10,0
80005434:	1a da       	st.w	--sp,r10
80005436:	1a da       	st.w	--sp,r10
80005438:	14 98       	mov	r8,r10
8000543a:	14 99       	mov	r9,r10
8000543c:	30 1b       	mov	r11,1
8000543e:	fe 7c 0c 00 	mov	r12,-62464
80005442:	f0 1f 00 0c 	mcall	80005470 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005446:	30 1c       	mov	r12,1
80005448:	f0 1f 00 0b 	mcall	80005474 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000544c:	30 2b       	mov	r11,2
8000544e:	fe 7c 0c 00 	mov	r12,-62464
80005452:	f0 1f 00 0a 	mcall	80005478 <local_start_pll0+0x90>
80005456:	2f dd       	sub	sp,-12
/****/
}
80005458:	d8 02       	popm	pc
8000545a:	00 00       	add	r0,r0
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	58 20       	cp.w	r0,2
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	57 c2       	stdsp	sp[0x1f0],r2
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	57 e4       	stdsp	sp[0x1f8],r4
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	57 fe       	stdsp	sp[0x1fc],lr
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	58 0c       	cp.w	r12,0
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	57 7c       	stdsp	sp[0x1dc],r12
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	55 0c       	stdsp	sp[0x140],r12
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	58 16       	cp.w	r6,1

8000547c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
8000547c:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005480:	30 0b       	mov	r11,0
80005482:	30 1c       	mov	r12,1
80005484:	f0 1f 00 19 	mcall	800054e8 <xg_flashc_init+0x6c>
80005488:	49 98       	lddpc	r8,800054ec <xg_flashc_init+0x70>
8000548a:	91 0c       	st.w	r8[0x0],r12
8000548c:	70 08       	ld.w	r8,r8[0x0]
8000548e:	58 08       	cp.w	r8,0
80005490:	c0 80       	breq	800054a0 <xg_flashc_init+0x24>
80005492:	49 78       	lddpc	r8,800054ec <xg_flashc_init+0x70>
80005494:	70 0c       	ld.w	r12,r8[0x0]
80005496:	30 09       	mov	r9,0
80005498:	12 9a       	mov	r10,r9
8000549a:	12 9b       	mov	r11,r9
8000549c:	f0 1f 00 15 	mcall	800054f0 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
800054a0:	49 38       	lddpc	r8,800054ec <xg_flashc_init+0x70>
800054a2:	70 08       	ld.w	r8,r8[0x0]
800054a4:	58 08       	cp.w	r8,0
800054a6:	c0 41       	brne	800054ae <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
800054a8:	49 3c       	lddpc	r12,800054f4 <xg_flashc_init+0x78>
800054aa:	f0 1f 00 14 	mcall	800054f8 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
800054ae:	30 4b       	mov	r11,4
800054b0:	e0 6c 01 2c 	mov	r12,300
800054b4:	f0 1f 00 0d 	mcall	800054e8 <xg_flashc_init+0x6c>
800054b8:	49 18       	lddpc	r8,800054fc <xg_flashc_init+0x80>
800054ba:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
800054bc:	30 4b       	mov	r11,4
800054be:	e0 6c 01 90 	mov	r12,400
800054c2:	f0 1f 00 0a 	mcall	800054e8 <xg_flashc_init+0x6c>
800054c6:	48 f8       	lddpc	r8,80005500 <xg_flashc_init+0x84>
800054c8:	91 0c       	st.w	r8[0x0],r12
800054ca:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800054cc:	10 96       	mov	r6,r8
800054ce:	48 e5       	lddpc	r5,80005504 <xg_flashc_init+0x88>
800054d0:	6c 0c       	ld.w	r12,r6[0x0]
800054d2:	ea 07 00 0b 	add	r11,r5,r7
800054d6:	f0 1f 00 0d 	mcall	80005508 <xg_flashc_init+0x8c>
800054da:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
800054dc:	e0 47 28 a0 	cp.w	r7,10400
800054e0:	cf 81       	brne	800054d0 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
800054e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800054e6:	00 00       	add	r0,r0
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	65 38       	ld.w	r8,r2[0x4c]
800054ec:	00 00       	add	r0,r0
800054ee:	0b 78       	ld.ub	r8,--r5
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	63 e0       	ld.w	r0,r1[0x78]
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	d9 48       	*unknown*
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	70 18       	ld.w	r8,r8[0x4]
800054fc:	00 00       	add	r0,r0
800054fe:	0b 70       	ld.ub	r0,--r5
80005500:	00 00       	add	r0,r0
80005502:	0b 74       	ld.ub	r4,--r5
80005504:	00 00       	add	r0,r0
80005506:	97 48       	st.w	r11[0x10],r8
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	2c 7c       	sub	r12,-57

8000550c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000550c:	fe 68 14 00 	mov	r8,-125952
80005510:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005512:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005516:	91 09       	st.w	r8[0x0],r9
}
80005518:	5e fc       	retal	r12

8000551a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000551a:	f8 08 16 05 	lsr	r8,r12,0x5
8000551e:	a9 68       	lsl	r8,0x8
80005520:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005524:	58 1b       	cp.w	r11,1
80005526:	c0 d0       	breq	80005540 <gpio_enable_module_pin+0x26>
80005528:	c0 63       	brcs	80005534 <gpio_enable_module_pin+0x1a>
8000552a:	58 2b       	cp.w	r11,2
8000552c:	c1 00       	breq	8000554c <gpio_enable_module_pin+0x32>
8000552e:	58 3b       	cp.w	r11,3
80005530:	c1 40       	breq	80005558 <gpio_enable_module_pin+0x3e>
80005532:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005534:	30 19       	mov	r9,1
80005536:	f2 0c 09 49 	lsl	r9,r9,r12
8000553a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000553c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000553e:	c1 28       	rjmp	80005562 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005540:	30 19       	mov	r9,1
80005542:	f2 0c 09 49 	lsl	r9,r9,r12
80005546:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005548:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000554a:	c0 c8       	rjmp	80005562 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000554c:	30 19       	mov	r9,1
8000554e:	f2 0c 09 49 	lsl	r9,r9,r12
80005552:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005554:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005556:	c0 68       	rjmp	80005562 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005558:	30 19       	mov	r9,1
8000555a:	f2 0c 09 49 	lsl	r9,r9,r12
8000555e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005560:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005562:	30 19       	mov	r9,1
80005564:	f2 0c 09 4c 	lsl	r12,r9,r12
80005568:	91 2c       	st.w	r8[0x8],r12
8000556a:	5e fd       	retal	0

8000556c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000556c:	d4 21       	pushm	r4-r7,lr
8000556e:	18 97       	mov	r7,r12
80005570:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005572:	58 0b       	cp.w	r11,0
80005574:	c0 31       	brne	8000557a <gpio_enable_module+0xe>
80005576:	30 05       	mov	r5,0
80005578:	c0 d8       	rjmp	80005592 <gpio_enable_module+0x26>
8000557a:	30 06       	mov	r6,0
8000557c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000557e:	6e 1b       	ld.w	r11,r7[0x4]
80005580:	6e 0c       	ld.w	r12,r7[0x0]
80005582:	f0 1f 00 06 	mcall	80005598 <gpio_enable_module+0x2c>
80005586:	18 45       	or	r5,r12
		gpiomap++;
80005588:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000558a:	2f f6       	sub	r6,-1
8000558c:	0c 34       	cp.w	r4,r6
8000558e:	fe 9b ff f8 	brhi	8000557e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005592:	0a 9c       	mov	r12,r5
80005594:	d8 22       	popm	r4-r7,pc
80005596:	00 00       	add	r0,r0
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	55 1a       	stdsp	sp[0x144],r10

8000559c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000559c:	f8 08 16 05 	lsr	r8,r12,0x5
800055a0:	a9 68       	lsl	r8,0x8
800055a2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800055a6:	30 19       	mov	r9,1
800055a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800055ac:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800055b0:	91 1c       	st.w	r8[0x4],r12
}
800055b2:	5e fc       	retal	r12

800055b4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055b4:	f8 08 16 05 	lsr	r8,r12,0x5
800055b8:	a9 68       	lsl	r8,0x8
800055ba:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800055be:	30 19       	mov	r9,1
800055c0:	f2 0c 09 4c 	lsl	r12,r9,r12
800055c4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800055c8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800055cc:	91 1c       	st.w	r8[0x4],r12
}
800055ce:	5e fc       	retal	r12

800055d0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055d0:	f8 08 16 05 	lsr	r8,r12,0x5
800055d4:	a9 68       	lsl	r8,0x8
800055d6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800055da:	30 19       	mov	r9,1
800055dc:	f2 0c 09 4c 	lsl	r12,r9,r12
800055e0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800055e4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800055e8:	91 1c       	st.w	r8[0x4],r12
}
800055ea:	5e fc       	retal	r12

800055ec <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800055ec:	c0 08       	rjmp	800055ec <_unhandled_interrupt>
800055ee:	d7 03       	nop

800055f0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800055f0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800055f4:	49 99       	lddpc	r9,80005658 <INTC_register_interrupt+0x68>
800055f6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800055fa:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800055fe:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005600:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005604:	58 0a       	cp.w	r10,0
80005606:	c0 91       	brne	80005618 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005608:	49 59       	lddpc	r9,8000565c <INTC_register_interrupt+0x6c>
8000560a:	49 6a       	lddpc	r10,80005660 <INTC_register_interrupt+0x70>
8000560c:	12 1a       	sub	r10,r9
8000560e:	fe 79 08 00 	mov	r9,-63488
80005612:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005616:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005618:	58 1a       	cp.w	r10,1
8000561a:	c0 a1       	brne	8000562e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000561c:	49 09       	lddpc	r9,8000565c <INTC_register_interrupt+0x6c>
8000561e:	49 2a       	lddpc	r10,80005664 <INTC_register_interrupt+0x74>
80005620:	12 1a       	sub	r10,r9
80005622:	bf aa       	sbr	r10,0x1e
80005624:	fe 79 08 00 	mov	r9,-63488
80005628:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000562c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000562e:	58 2a       	cp.w	r10,2
80005630:	c0 a1       	brne	80005644 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005632:	48 b9       	lddpc	r9,8000565c <INTC_register_interrupt+0x6c>
80005634:	48 da       	lddpc	r10,80005668 <INTC_register_interrupt+0x78>
80005636:	12 1a       	sub	r10,r9
80005638:	bf ba       	sbr	r10,0x1f
8000563a:	fe 79 08 00 	mov	r9,-63488
8000563e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005642:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005644:	48 69       	lddpc	r9,8000565c <INTC_register_interrupt+0x6c>
80005646:	48 aa       	lddpc	r10,8000566c <INTC_register_interrupt+0x7c>
80005648:	12 1a       	sub	r10,r9
8000564a:	ea 1a c0 00 	orh	r10,0xc000
8000564e:	fe 79 08 00 	mov	r9,-63488
80005652:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005656:	5e fc       	retal	r12
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	d9 80       	acall	0x98
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	ce 00       	breq	8000561e <INTC_register_interrupt+0x2e>
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	cf 04       	brge	80005642 <INTC_register_interrupt+0x52>
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	cf 12       	brcc	80005648 <INTC_register_interrupt+0x58>
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	cf 20       	breq	8000564e <INTC_register_interrupt+0x5e>
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	cf 2e       	rcall	80005452 <local_start_pll0+0x6a>

80005670 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005670:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005672:	49 18       	lddpc	r8,800056b4 <INTC_init_interrupts+0x44>
80005674:	e3 b8 00 01 	mtsr	0x4,r8
80005678:	49 0e       	lddpc	lr,800056b8 <INTC_init_interrupts+0x48>
8000567a:	30 07       	mov	r7,0
8000567c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000567e:	49 0c       	lddpc	r12,800056bc <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005680:	49 05       	lddpc	r5,800056c0 <INTC_init_interrupts+0x50>
80005682:	10 15       	sub	r5,r8
80005684:	fe 76 08 00 	mov	r6,-63488
80005688:	c1 08       	rjmp	800056a8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000568a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000568c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000568e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005690:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005694:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005696:	10 3a       	cp.w	r10,r8
80005698:	fe 9b ff fc 	brhi	80005690 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000569c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800056a0:	2f f7       	sub	r7,-1
800056a2:	2f 8e       	sub	lr,-8
800056a4:	59 37       	cp.w	r7,19
800056a6:	c0 50       	breq	800056b0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056a8:	7c 08       	ld.w	r8,lr[0x0]
800056aa:	58 08       	cp.w	r8,0
800056ac:	ce f1       	brne	8000568a <INTC_init_interrupts+0x1a>
800056ae:	cf 7b       	rjmp	8000569c <INTC_init_interrupts+0x2c>
800056b0:	d8 22       	popm	r4-r7,pc
800056b2:	00 00       	add	r0,r0
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	ce 00       	breq	80005676 <INTC_init_interrupts+0x6>
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	d9 80       	acall	0x98
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	55 ec       	stdsp	sp[0x178],r12
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	cf 04       	brge	800056a2 <INTC_init_interrupts+0x32>

800056c4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800056c4:	fe 78 08 00 	mov	r8,-63488
800056c8:	e0 69 00 83 	mov	r9,131
800056cc:	f2 0c 01 0c 	sub	r12,r9,r12
800056d0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800056d4:	f2 ca ff c0 	sub	r10,r9,-64
800056d8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800056dc:	58 08       	cp.w	r8,0
800056de:	c0 21       	brne	800056e2 <_get_interrupt_handler+0x1e>
800056e0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800056e2:	f0 08 12 00 	clz	r8,r8
800056e6:	48 5a       	lddpc	r10,800056f8 <_get_interrupt_handler+0x34>
800056e8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800056ec:	f0 08 11 1f 	rsub	r8,r8,31
800056f0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800056f2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800056f6:	5e fc       	retal	r12
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	d9 80       	acall	0x98

800056fc <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800056fc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800056fe:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005702:	99 a8       	st.w	r12[0x28],r8
}
80005704:	5e fc       	retal	r12
80005706:	d7 03       	nop

80005708 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005708:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000570a:	ec 5b bb 9f 	cp.w	r11,899999
8000570e:	e0 8b 00 04 	brhi	80005716 <pm_enable_osc0_crystal+0xe>
80005712:	30 4b       	mov	r11,4
80005714:	c1 38       	rjmp	8000573a <pm_enable_osc0_crystal+0x32>
80005716:	e0 68 c6 bf 	mov	r8,50879
8000571a:	ea 18 00 2d 	orh	r8,0x2d
8000571e:	10 3b       	cp.w	r11,r8
80005720:	e0 8b 00 04 	brhi	80005728 <pm_enable_osc0_crystal+0x20>
80005724:	30 5b       	mov	r11,5
80005726:	c0 a8       	rjmp	8000573a <pm_enable_osc0_crystal+0x32>
80005728:	e0 68 12 00 	mov	r8,4608
8000572c:	ea 18 00 7a 	orh	r8,0x7a
80005730:	10 3b       	cp.w	r11,r8
80005732:	f9 bb 03 06 	movlo	r11,6
80005736:	f9 bb 02 07 	movhs	r11,7
8000573a:	f0 1f 00 02 	mcall	80005740 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000573e:	d8 02       	popm	pc
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	56 fc       	stdsp	sp[0x1bc],r12

80005744 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005744:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005746:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000574a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000574c:	78 08       	ld.w	r8,r12[0x0]
8000574e:	a3 a8       	sbr	r8,0x2
80005750:	99 08       	st.w	r12[0x0],r8
}
80005752:	5e fc       	retal	r12

80005754 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005754:	79 58       	ld.w	r8,r12[0x54]
80005756:	e2 18 00 80 	andl	r8,0x80,COH
8000575a:	cf d0       	breq	80005754 <pm_wait_for_clk0_ready>
}
8000575c:	5e fc       	retal	r12
8000575e:	d7 03       	nop

80005760 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005760:	eb cd 40 80 	pushm	r7,lr
80005764:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005766:	f0 1f 00 04 	mcall	80005774 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000576a:	0e 9c       	mov	r12,r7
8000576c:	f0 1f 00 03 	mcall	80005778 <pm_enable_clk0+0x18>
}
80005770:	e3 cd 80 80 	ldm	sp++,r7,pc
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	57 44       	stdsp	sp[0x1d0],r4
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	57 54       	stdsp	sp[0x1d4],r4

8000577c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000577c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005780:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005784:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005786:	09 f7       	ld.ub	r7,r4[0x7]
80005788:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000578c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005790:	09 b4       	ld.ub	r4,r4[0x3]
80005792:	08 96       	mov	r6,r4
80005794:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005798:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000579c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800057a0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800057a4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800057a8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800057ac:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800057b0:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800057b4:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800057b6:	79 58       	ld.w	r8,r12[0x54]
800057b8:	e2 18 00 20 	andl	r8,0x20,COH
800057bc:	cf d0       	breq	800057b6 <pm_cksel+0x3a>
}
800057be:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800057c2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800057c2:	eb cd 40 80 	pushm	r7,lr
800057c6:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800057c8:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800057ca:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800057ce:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800057d2:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800057d6:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800057da:	2f 8b       	sub	r11,-8
800057dc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800057e0:	e3 cd 80 80 	ldm	sp++,r7,pc

800057e4 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800057e4:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800057e6:	2f 8b       	sub	r11,-8
800057e8:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800057ec:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800057f0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800057f4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800057f8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800057fc:	d8 02       	popm	pc

800057fe <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800057fe:	2f 8b       	sub	r11,-8
80005800:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005804:	a1 a8       	sbr	r8,0x0
80005806:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000580a:	5e fc       	retal	r12

8000580c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000580c:	79 58       	ld.w	r8,r12[0x54]
8000580e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005812:	cf d0       	breq	8000580c <pm_wait_for_pll0_locked>
}
80005814:	5e fc       	retal	r12

80005816 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005816:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005818:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000581c:	99 08       	st.w	r12[0x0],r8
}
8000581e:	5e fc       	retal	r12

80005820 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005820:	eb cd 40 c0 	pushm	r6-r7,lr
80005824:	18 97       	mov	r7,r12
80005826:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005828:	f0 1f 00 06 	mcall	80005840 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000582c:	0c 9b       	mov	r11,r6
8000582e:	0e 9c       	mov	r12,r7
80005830:	f0 1f 00 05 	mcall	80005844 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005834:	30 1b       	mov	r11,1
80005836:	0e 9c       	mov	r12,r7
80005838:	f0 1f 00 04 	mcall	80005848 <pm_switch_to_osc0+0x28>
}
8000583c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	57 08       	stdsp	sp[0x1c0],r8
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	57 60       	stdsp	sp[0x1d8],r0
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	58 16       	cp.w	r6,1

8000584c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000584c:	f8 c8 00 01 	sub	r8,r12,1
80005850:	f0 0b 00 0b 	add	r11,r8,r11
80005854:	f6 0c 0d 0a 	divu	r10,r11,r12
80005858:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000585a:	f4 c8 00 01 	sub	r8,r10,1
8000585e:	e0 48 00 fe 	cp.w	r8,254
80005862:	e0 88 00 03 	brls	80005868 <getBaudDiv+0x1c>
80005866:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005868:	5c 8c       	casts.h	r12
}
8000586a:	5e fc       	retal	r12

8000586c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000586c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005870:	30 18       	mov	r8,1
80005872:	f0 09 18 00 	cp.b	r9,r8
80005876:	e0 88 00 04 	brls	8000587e <spi_initMaster+0x12>
8000587a:	30 2c       	mov	r12,2
8000587c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000587e:	e0 68 00 80 	mov	r8,128
80005882:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005884:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005886:	30 19       	mov	r9,1
80005888:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000588c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005890:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005894:	30 09       	mov	r9,0
80005896:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000589a:	30 fa       	mov	r10,15
8000589c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800058a0:	99 18       	st.w	r12[0x4],r8
800058a2:	5e f9       	retal	r9

800058a4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800058a4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800058a6:	30 18       	mov	r8,1
800058a8:	f0 0b 18 00 	cp.b	r11,r8
800058ac:	5f be       	srhi	lr
800058ae:	f0 0a 18 00 	cp.b	r10,r8
800058b2:	5f b8       	srhi	r8
800058b4:	fd e8 10 08 	or	r8,lr,r8
800058b8:	c0 30       	breq	800058be <spi_selectionMode+0x1a>
800058ba:	30 2c       	mov	r12,2
800058bc:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800058be:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800058c0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800058c4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800058c8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800058cc:	99 18       	st.w	r12[0x4],r8
800058ce:	d8 0a       	popm	pc,r12=0

800058d0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800058d0:	30 18       	mov	r8,1
800058d2:	99 08       	st.w	r12[0x0],r8
}
800058d4:	5e fc       	retal	r12

800058d6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800058d6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058da:	c0 58       	rjmp	800058e4 <spi_write+0xe>
		if (!timeout--) {
800058dc:	58 08       	cp.w	r8,0
800058de:	c0 21       	brne	800058e2 <spi_write+0xc>
800058e0:	5e ff       	retal	1
800058e2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058e4:	78 49       	ld.w	r9,r12[0x10]
800058e6:	e2 19 00 02 	andl	r9,0x2,COH
800058ea:	cf 90       	breq	800058dc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800058ec:	5c 7b       	castu.h	r11
800058ee:	99 3b       	st.w	r12[0xc],r11
800058f0:	5e fd       	retal	0

800058f2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800058f2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058f6:	c0 58       	rjmp	80005900 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058f8:	58 08       	cp.w	r8,0
800058fa:	c0 21       	brne	800058fe <spi_read+0xc>
800058fc:	5e ff       	retal	1
800058fe:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005900:	78 49       	ld.w	r9,r12[0x10]
80005902:	e2 19 02 01 	andl	r9,0x201,COH
80005906:	e0 49 02 01 	cp.w	r9,513
8000590a:	cf 71       	brne	800058f8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000590c:	78 28       	ld.w	r8,r12[0x8]
8000590e:	b6 08       	st.h	r11[0x0],r8
80005910:	5e fd       	retal	0
80005912:	d7 03       	nop

80005914 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005914:	eb cd 40 f8 	pushm	r3-r7,lr
80005918:	18 95       	mov	r5,r12
8000591a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000591c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005920:	30 38       	mov	r8,3
80005922:	f0 06 18 00 	cp.b	r6,r8
80005926:	e0 8b 00 5e 	brhi	800059e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000592a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000592e:	30 18       	mov	r8,1
80005930:	f0 04 18 00 	cp.b	r4,r8
80005934:	e0 8b 00 57 	brhi	800059e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005938:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000593c:	30 78       	mov	r8,7
8000593e:	f0 03 18 00 	cp.b	r3,r8
80005942:	e0 88 00 50 	brls	800059e2 <spi_setupChipReg+0xce>
80005946:	31 08       	mov	r8,16
80005948:	f0 03 18 00 	cp.b	r3,r8
8000594c:	e0 8b 00 4b 	brhi	800059e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005950:	14 9b       	mov	r11,r10
80005952:	6e 1c       	ld.w	r12,r7[0x4]
80005954:	f0 1f 00 26 	mcall	800059ec <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005958:	c4 55       	brlt	800059e2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000595a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000595c:	ec 09 16 01 	lsr	r9,r6,0x1
80005960:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005964:	ec 16 00 01 	eorl	r6,0x1
80005968:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000596c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005970:	20 83       	sub	r3,8
80005972:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005976:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000597a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000597e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005982:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005986:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000598a:	0f 89       	ld.ub	r9,r7[0x0]
8000598c:	30 1a       	mov	r10,1
8000598e:	f4 09 18 00 	cp.b	r9,r10
80005992:	c0 d0       	breq	800059ac <spi_setupChipReg+0x98>
80005994:	c0 a3       	brcs	800059a8 <spi_setupChipReg+0x94>
80005996:	30 2a       	mov	r10,2
80005998:	f4 09 18 00 	cp.b	r9,r10
8000599c:	c0 a0       	breq	800059b0 <spi_setupChipReg+0x9c>
8000599e:	30 3a       	mov	r10,3
800059a0:	f4 09 18 00 	cp.b	r9,r10
800059a4:	c1 f1       	brne	800059e2 <spi_setupChipReg+0xce>
800059a6:	c0 78       	rjmp	800059b4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800059a8:	8b c8       	st.w	r5[0x30],r8
		break;
800059aa:	c0 68       	rjmp	800059b6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800059ac:	8b d8       	st.w	r5[0x34],r8
		break;
800059ae:	c0 48       	rjmp	800059b6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800059b0:	8b e8       	st.w	r5[0x38],r8
		break;
800059b2:	c0 28       	rjmp	800059b6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800059b4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800059b6:	48 f8       	lddpc	r8,800059f0 <spi_setupChipReg+0xdc>
800059b8:	70 08       	ld.w	r8,r8[0x0]
800059ba:	58 08       	cp.w	r8,0
800059bc:	c1 61       	brne	800059e8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800059be:	30 0b       	mov	r11,0
800059c0:	30 1c       	mov	r12,1
800059c2:	f0 1f 00 0d 	mcall	800059f4 <spi_setupChipReg+0xe0>
800059c6:	48 b8       	lddpc	r8,800059f0 <spi_setupChipReg+0xdc>
800059c8:	91 0c       	st.w	r8[0x0],r12
800059ca:	58 0c       	cp.w	r12,0
800059cc:	c0 a0       	breq	800059e0 <spi_setupChipReg+0xcc>
800059ce:	30 09       	mov	r9,0
800059d0:	12 9a       	mov	r10,r9
800059d2:	12 9b       	mov	r11,r9
800059d4:	f0 1f 00 09 	mcall	800059f8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800059d8:	48 68       	lddpc	r8,800059f0 <spi_setupChipReg+0xdc>
800059da:	70 08       	ld.w	r8,r8[0x0]
800059dc:	58 08       	cp.w	r8,0
800059de:	c0 51       	brne	800059e8 <spi_setupChipReg+0xd4>
800059e0:	c0 08       	rjmp	800059e0 <spi_setupChipReg+0xcc>
800059e2:	30 2c       	mov	r12,2
800059e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059e8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	58 4c       	cp.w	r12,4
800059f0:	00 00       	add	r0,r0
800059f2:	bf ec       	*unknown*
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	65 38       	ld.w	r8,r2[0x4c]
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	63 e0       	ld.w	r0,r1[0x78]

800059fc <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059fc:	d4 01       	pushm	lr
800059fe:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a02:	c0 58       	rjmp	80005a0c <spi_unselectChip+0x10>
		if (!timeout--) {
80005a04:	58 08       	cp.w	r8,0
80005a06:	c0 21       	brne	80005a0a <spi_unselectChip+0xe>
80005a08:	da 0a       	popm	pc,r12=1
80005a0a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a0c:	78 49       	ld.w	r9,r12[0x10]
80005a0e:	e2 19 02 00 	andl	r9,0x200,COH
80005a12:	cf 90       	breq	80005a04 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a14:	78 18       	ld.w	r8,r12[0x4]
80005a16:	ea 18 00 0f 	orh	r8,0xf
80005a1a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a1c:	fc 18 01 00 	movh	r8,0x100
80005a20:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005a22:	30 09       	mov	r9,0
80005a24:	12 9a       	mov	r10,r9
80005a26:	12 9b       	mov	r11,r9
80005a28:	48 38       	lddpc	r8,80005a34 <spi_unselectChip+0x38>
80005a2a:	70 0c       	ld.w	r12,r8[0x0]
80005a2c:	f0 1f 00 03 	mcall	80005a38 <spi_unselectChip+0x3c>
80005a30:	d8 0a       	popm	pc,r12=0
80005a32:	00 00       	add	r0,r0
80005a34:	00 00       	add	r0,r0
80005a36:	bf ec       	*unknown*
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	63 e0       	ld.w	r0,r1[0x78]

80005a3c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a3c:	eb cd 40 f8 	pushm	r3-r7,lr
80005a40:	18 94       	mov	r4,r12
80005a42:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a44:	49 a6       	lddpc	r6,80005aac <spi_selectChip+0x70>
80005a46:	30 07       	mov	r7,0
80005a48:	31 45       	mov	r5,20
80005a4a:	0e 99       	mov	r9,r7
80005a4c:	0a 9a       	mov	r10,r5
80005a4e:	0e 9b       	mov	r11,r7
80005a50:	6c 0c       	ld.w	r12,r6[0x0]
80005a52:	f0 1f 00 18 	mcall	80005ab0 <spi_selectChip+0x74>
80005a56:	cf a0       	breq	80005a4a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a58:	68 18       	ld.w	r8,r4[0x4]
80005a5a:	ea 18 00 0f 	orh	r8,0xf
80005a5e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a60:	68 18       	ld.w	r8,r4[0x4]
80005a62:	e2 18 00 04 	andl	r8,0x4,COH
80005a66:	c1 10       	breq	80005a88 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a68:	30 e8       	mov	r8,14
80005a6a:	f0 03 18 00 	cp.b	r3,r8
80005a6e:	e0 8b 00 1c 	brhi	80005aa6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a72:	68 19       	ld.w	r9,r4[0x4]
80005a74:	e6 08 15 10 	lsl	r8,r3,0x10
80005a78:	ea 18 ff f0 	orh	r8,0xfff0
80005a7c:	e8 18 ff ff 	orl	r8,0xffff
80005a80:	12 68       	and	r8,r9
80005a82:	89 18       	st.w	r4[0x4],r8
80005a84:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a88:	30 38       	mov	r8,3
80005a8a:	f0 03 18 00 	cp.b	r3,r8
80005a8e:	e0 8b 00 0c 	brhi	80005aa6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a92:	68 19       	ld.w	r9,r4[0x4]
80005a94:	2f 03       	sub	r3,-16
80005a96:	30 18       	mov	r8,1
80005a98:	f0 03 09 48 	lsl	r8,r8,r3
80005a9c:	5c d8       	com	r8
80005a9e:	12 68       	and	r8,r9
80005aa0:	89 18       	st.w	r4[0x4],r8
80005aa2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005aa6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005aa8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005aac:	00 00       	add	r0,r0
80005aae:	bf ec       	*unknown*
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	61 d4       	ld.w	r4,r0[0x74]

80005ab4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005ab4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005ab6:	f6 08 15 04 	lsl	r8,r11,0x4
80005aba:	14 38       	cp.w	r8,r10
80005abc:	f9 b8 08 10 	movls	r8,16
80005ac0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005ac4:	f0 0b 02 4b 	mul	r11,r8,r11
80005ac8:	f6 09 16 01 	lsr	r9,r11,0x1
80005acc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005ad0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005ad4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005ad8:	f2 cb 00 01 	sub	r11,r9,1
80005adc:	e0 4b ff fe 	cp.w	r11,65534
80005ae0:	e0 88 00 03 	brls	80005ae6 <usart_set_async_baudrate+0x32>
80005ae4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005ae6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005ae8:	e8 6e 00 00 	mov	lr,524288
80005aec:	59 08       	cp.w	r8,16
80005aee:	fc 08 17 10 	movne	r8,lr
80005af2:	f9 b8 00 00 	moveq	r8,0
80005af6:	e4 1b ff f7 	andh	r11,0xfff7
80005afa:	e0 1b fe cf 	andl	r11,0xfecf
80005afe:	16 48       	or	r8,r11
80005b00:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005b02:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005b06:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005b0a:	99 89       	st.w	r12[0x20],r9
80005b0c:	d8 0a       	popm	pc,r12=0

80005b0e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005b0e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005b10:	e2 18 00 02 	andl	r8,0x2,COH
80005b14:	c0 31       	brne	80005b1a <usart_write_char+0xc>
80005b16:	30 2c       	mov	r12,2
80005b18:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005b1a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005b1e:	99 7b       	st.w	r12[0x1c],r11
80005b20:	5e fd       	retal	0
80005b22:	d7 03       	nop

80005b24 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005b24:	eb cd 40 e0 	pushm	r5-r7,lr
80005b28:	18 96       	mov	r6,r12
80005b2a:	16 95       	mov	r5,r11
80005b2c:	e0 67 27 0f 	mov	r7,9999
80005b30:	c0 68       	rjmp	80005b3c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005b32:	58 07       	cp.w	r7,0
80005b34:	c0 31       	brne	80005b3a <usart_putchar+0x16>
80005b36:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b3a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b3c:	0a 9b       	mov	r11,r5
80005b3e:	0c 9c       	mov	r12,r6
80005b40:	f0 1f 00 03 	mcall	80005b4c <usart_putchar+0x28>
80005b44:	cf 71       	brne	80005b32 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b4a:	00 00       	add	r0,r0
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	5b 0e       	cp.w	lr,-16

80005b50 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b50:	78 58       	ld.w	r8,r12[0x14]
80005b52:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b56:	c0 30       	breq	80005b5c <usart_read_char+0xc>
80005b58:	30 4c       	mov	r12,4
80005b5a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b5c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b62:	c0 31       	brne	80005b68 <usart_read_char+0x18>
80005b64:	30 3c       	mov	r12,3
80005b66:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b68:	78 68       	ld.w	r8,r12[0x18]
80005b6a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b6e:	97 08       	st.w	r11[0x0],r8
80005b70:	5e fd       	retal	0
80005b72:	d7 03       	nop

80005b74 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b74:	eb cd 40 c0 	pushm	r6-r7,lr
80005b78:	20 1d       	sub	sp,4
80005b7a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b7c:	1a 97       	mov	r7,sp
80005b7e:	1a 9b       	mov	r11,sp
80005b80:	0c 9c       	mov	r12,r6
80005b82:	f0 1f 00 07 	mcall	80005b9c <usart_getchar+0x28>
80005b86:	58 3c       	cp.w	r12,3
80005b88:	cf b0       	breq	80005b7e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b8a:	58 4c       	cp.w	r12,4
80005b8c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b90:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b94:	2f fd       	sub	sp,-4
80005b96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b9a:	00 00       	add	r0,r0
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	5b 50       	cp.w	r0,-11

80005ba0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005ba0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ba4:	18 96       	mov	r6,r12
80005ba6:	16 97       	mov	r7,r11
  while (*string != '\0')
80005ba8:	17 8b       	ld.ub	r11,r11[0x0]
80005baa:	58 0b       	cp.w	r11,0
80005bac:	c0 80       	breq	80005bbc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005bae:	2f f7       	sub	r7,-1
80005bb0:	0c 9c       	mov	r12,r6
80005bb2:	f0 1f 00 04 	mcall	80005bc0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005bb6:	0f 8b       	ld.ub	r11,r7[0x0]
80005bb8:	58 0b       	cp.w	r11,0
80005bba:	cf a1       	brne	80005bae <usart_write_line+0xe>
80005bbc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bc0:	80 00       	ld.sh	r0,r0[0x0]
80005bc2:	5b 24       	cp.w	r4,-14

80005bc4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005bc4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005bc8:	e6 18 00 01 	andh	r8,0x1,COH
80005bcc:	c0 71       	brne	80005bda <usart_reset+0x16>
80005bce:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005bd0:	3f f8       	mov	r8,-1
80005bd2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005bd4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005bd6:	d5 03       	csrf	0x10
80005bd8:	c0 48       	rjmp	80005be0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005bda:	3f f8       	mov	r8,-1
80005bdc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005bde:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005be0:	30 08       	mov	r8,0
80005be2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005be4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005be6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005be8:	ea 68 61 0c 	mov	r8,680204
80005bec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005bee:	5e fc       	retal	r12

80005bf0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005bf0:	eb cd 40 e0 	pushm	r5-r7,lr
80005bf4:	18 96       	mov	r6,r12
80005bf6:	16 97       	mov	r7,r11
80005bf8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005bfa:	f0 1f 00 2f 	mcall	80005cb4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005bfe:	58 07       	cp.w	r7,0
80005c00:	c5 80       	breq	80005cb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005c02:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c04:	30 49       	mov	r9,4
80005c06:	f2 08 18 00 	cp.b	r8,r9
80005c0a:	e0 88 00 53 	brls	80005cb0 <usart_init_rs232+0xc0>
80005c0e:	30 99       	mov	r9,9
80005c10:	f2 08 18 00 	cp.b	r8,r9
80005c14:	e0 8b 00 4e 	brhi	80005cb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005c18:	0f d9       	ld.ub	r9,r7[0x5]
80005c1a:	30 78       	mov	r8,7
80005c1c:	f0 09 18 00 	cp.b	r9,r8
80005c20:	e0 8b 00 48 	brhi	80005cb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005c24:	8e 39       	ld.sh	r9,r7[0x6]
80005c26:	e0 68 01 01 	mov	r8,257
80005c2a:	f0 09 19 00 	cp.h	r9,r8
80005c2e:	e0 8b 00 41 	brhi	80005cb0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005c32:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c36:	30 38       	mov	r8,3
80005c38:	f0 09 18 00 	cp.b	r9,r8
80005c3c:	e0 8b 00 3a 	brhi	80005cb0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c40:	0a 9a       	mov	r10,r5
80005c42:	6e 0b       	ld.w	r11,r7[0x0]
80005c44:	0c 9c       	mov	r12,r6
80005c46:	f0 1f 00 1d 	mcall	80005cb8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c4a:	58 1c       	cp.w	r12,1
80005c4c:	c3 20       	breq	80005cb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c4e:	0f c8       	ld.ub	r8,r7[0x4]
80005c50:	30 99       	mov	r9,9
80005c52:	f2 08 18 00 	cp.b	r8,r9
80005c56:	c0 51       	brne	80005c60 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c58:	6c 18       	ld.w	r8,r6[0x4]
80005c5a:	b1 b8       	sbr	r8,0x11
80005c5c:	8d 18       	st.w	r6[0x4],r8
80005c5e:	c0 68       	rjmp	80005c6a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c60:	6c 19       	ld.w	r9,r6[0x4]
80005c62:	20 58       	sub	r8,5
80005c64:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c68:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c6a:	6c 19       	ld.w	r9,r6[0x4]
80005c6c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c70:	0f d8       	ld.ub	r8,r7[0x5]
80005c72:	a9 78       	lsl	r8,0x9
80005c74:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c78:	12 48       	or	r8,r9
80005c7a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c7c:	8e 38       	ld.sh	r8,r7[0x6]
80005c7e:	30 29       	mov	r9,2
80005c80:	f2 08 19 00 	cp.h	r8,r9
80005c84:	e0 88 00 09 	brls	80005c96 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c88:	6c 18       	ld.w	r8,r6[0x4]
80005c8a:	ad b8       	sbr	r8,0xd
80005c8c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c8e:	8e b8       	ld.uh	r8,r7[0x6]
80005c90:	20 28       	sub	r8,2
80005c92:	8d a8       	st.w	r6[0x28],r8
80005c94:	c0 68       	rjmp	80005ca0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c96:	6c 19       	ld.w	r9,r6[0x4]
80005c98:	5c 78       	castu.h	r8
80005c9a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c9e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005ca0:	6c 18       	ld.w	r8,r6[0x4]
80005ca2:	e0 18 ff f0 	andl	r8,0xfff0
80005ca6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005ca8:	35 08       	mov	r8,80
80005caa:	8d 08       	st.w	r6[0x0],r8
80005cac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005cb0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	5b c4       	cp.w	r4,-4
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	5a b4       	cp.w	r4,-21

80005cbc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005cbc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005cc0:	fe c0 8e c0 	sub	r0,pc,-28992

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005cc4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005cc8:	d5 53       	csrf	0x15
  cp      r0, r1
80005cca:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005ccc:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005cd0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005cd2:	c0 62       	brcc	80005cde <idata_load_loop_end>
  cp      r0, r1
80005cd4:	48 92       	lddpc	r2,80005cf8 <udata_clear_loop_end+0x4>

80005cd6 <idata_load_loop>:
  brlo    idata_load_loop
80005cd6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005cd8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005cda:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005cdc:	cf d3       	brcs	80005cd6 <idata_load_loop>

80005cde <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005cde:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005ce2:	e0 61 c0 00 	mov	r1,49152
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005ce6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005ce8:	c0 62       	brcc	80005cf4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005cea:	30 02       	mov	r2,0
80005cec:	30 03       	mov	r3,0

80005cee <udata_clear_loop>:
80005cee:	a1 22       	st.d	r0++,r2
80005cf0:	02 30       	cp.w	r0,r1
80005cf2:	cf e3       	brcs	80005cee <udata_clear_loop>

80005cf4 <udata_clear_loop_end>:
80005cf4:	fe cf e9 28 	sub	pc,pc,-5848
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	e2 b0 f8 c8 	rcall	80084e8a <_data_lma+0x76bda>

80005cfc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005cfc:	f8 c8 ff f8 	sub	r8,r12,-8
80005d00:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005d02:	3f f9       	mov	r9,-1
80005d04:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005d06:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005d08:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005d0a:	30 08       	mov	r8,0
80005d0c:	99 08       	st.w	r12[0x0],r8
}
80005d0e:	5e fc       	retal	r12

80005d10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005d10:	30 08       	mov	r8,0
80005d12:	99 48       	st.w	r12[0x10],r8
}
80005d14:	5e fc       	retal	r12

80005d16 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005d16:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005d18:	70 19       	ld.w	r9,r8[0x4]
80005d1a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005d1c:	78 19       	ld.w	r9,r12[0x4]
80005d1e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d20:	70 19       	ld.w	r9,r8[0x4]
80005d22:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d24:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005d26:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d28:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d2a:	78 08       	ld.w	r8,r12[0x0]
80005d2c:	2f f8       	sub	r8,-1
80005d2e:	99 08       	st.w	r12[0x0],r8
}
80005d30:	5e fc       	retal	r12

80005d32 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005d32:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d34:	5b fa       	cp.w	r10,-1
80005d36:	c0 31       	brne	80005d3c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d38:	78 48       	ld.w	r8,r12[0x10]
80005d3a:	c0 c8       	rjmp	80005d52 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d3c:	f8 c8 ff f8 	sub	r8,r12,-8
80005d40:	70 19       	ld.w	r9,r8[0x4]
80005d42:	72 09       	ld.w	r9,r9[0x0]
80005d44:	12 3a       	cp.w	r10,r9
80005d46:	c0 63       	brcs	80005d52 <vListInsert+0x20>
80005d48:	70 18       	ld.w	r8,r8[0x4]
80005d4a:	70 19       	ld.w	r9,r8[0x4]
80005d4c:	72 09       	ld.w	r9,r9[0x0]
80005d4e:	12 3a       	cp.w	r10,r9
80005d50:	cf c2       	brcc	80005d48 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d52:	70 19       	ld.w	r9,r8[0x4]
80005d54:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d56:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d58:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d5a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d5c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d5e:	78 08       	ld.w	r8,r12[0x0]
80005d60:	2f f8       	sub	r8,-1
80005d62:	99 08       	st.w	r12[0x0],r8
}
80005d64:	5e fc       	retal	r12

80005d66 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d66:	78 18       	ld.w	r8,r12[0x4]
80005d68:	78 29       	ld.w	r9,r12[0x8]
80005d6a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d6c:	78 28       	ld.w	r8,r12[0x8]
80005d6e:	78 19       	ld.w	r9,r12[0x4]
80005d70:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d72:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d74:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d76:	18 39       	cp.w	r9,r12
80005d78:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d7c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d80:	30 09       	mov	r9,0
80005d82:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d84:	70 09       	ld.w	r9,r8[0x0]
80005d86:	20 19       	sub	r9,1
80005d88:	91 09       	st.w	r8[0x0],r9
}
80005d8a:	5e fc       	retal	r12

80005d8c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d8c:	e0 68 08 08 	mov	r8,2056
80005d90:	ea 18 08 08 	orh	r8,0x808
80005d94:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d96:	e0 68 09 09 	mov	r8,2313
80005d9a:	ea 18 09 09 	orh	r8,0x909
80005d9e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005da0:	e0 68 0a 0a 	mov	r8,2570
80005da4:	ea 18 0a 0a 	orh	r8,0xa0a
80005da8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005daa:	e0 68 0b 0b 	mov	r8,2827
80005dae:	ea 18 0b 0b 	orh	r8,0xb0b
80005db2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005db4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005db6:	e0 68 be ef 	mov	r8,48879
80005dba:	ea 18 de ad 	orh	r8,0xdead
80005dbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005dc0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005dc2:	fc 18 00 40 	movh	r8,0x40
80005dc6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005dc8:	e0 68 00 ff 	mov	r8,255
80005dcc:	ea 18 ff 00 	orh	r8,0xff00
80005dd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005dd2:	e0 68 01 01 	mov	r8,257
80005dd6:	ea 18 01 01 	orh	r8,0x101
80005dda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005ddc:	e0 68 02 02 	mov	r8,514
80005de0:	ea 18 02 02 	orh	r8,0x202
80005de4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005de6:	e0 68 03 03 	mov	r8,771
80005dea:	ea 18 03 03 	orh	r8,0x303
80005dee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005df0:	e0 68 04 04 	mov	r8,1028
80005df4:	ea 18 04 04 	orh	r8,0x404
80005df8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005dfa:	e0 68 05 05 	mov	r8,1285
80005dfe:	ea 18 05 05 	orh	r8,0x505
80005e02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005e04:	e0 68 06 06 	mov	r8,1542
80005e08:	ea 18 06 06 	orh	r8,0x606
80005e0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005e0e:	e0 68 07 07 	mov	r8,1799
80005e12:	ea 18 07 07 	orh	r8,0x707
80005e16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005e18:	30 08       	mov	r8,0
80005e1a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005e1c:	5e fc       	retal	r12
80005e1e:	d7 03       	nop

80005e20 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005e20:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005e22:	48 38       	lddpc	r8,80005e2c <vPortEnterCritical+0xc>
80005e24:	70 09       	ld.w	r9,r8[0x0]
80005e26:	2f f9       	sub	r9,-1
80005e28:	91 09       	st.w	r8[0x0],r9
}
80005e2a:	5e fc       	retal	r12
80005e2c:	00 00       	add	r0,r0
80005e2e:	05 34       	ld.ub	r4,r2++

80005e30 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005e30:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005e32:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e34:	30 0a       	mov	r10,0
80005e36:	14 9b       	mov	r11,r10
80005e38:	49 2c       	lddpc	r12,80005e80 <xPortStartScheduler+0x50>
80005e3a:	f0 1f 00 13 	mcall	80005e84 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e3e:	e0 68 5d c0 	mov	r8,24000
80005e42:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e46:	30 08       	mov	r8,0
80005e48:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e4c:	e0 68 0c f4 	mov	r8,3316
80005e50:	ea 18 00 00 	orh	r8,0x0
80005e54:	70 00       	ld.w	r0,r8[0x0]
80005e56:	60 0d       	ld.w	sp,r0[0x0]
80005e58:	1b 00       	ld.w	r0,sp++
80005e5a:	e0 68 05 34 	mov	r8,1332
80005e5e:	ea 18 00 00 	orh	r8,0x0
80005e62:	91 00       	st.w	r8[0x0],r0
80005e64:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e68:	2f ed       	sub	sp,-8
80005e6a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e6e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e72:	e3 b0 00 00 	mtsr	0x0,r0
80005e76:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e7a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e7e:	d8 0a       	popm	pc,r12=0
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	5f 4c       	srge	r12
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	55 f0       	stdsp	sp[0x17c],r0

80005e88 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e88:	20 6d       	sub	sp,24
80005e8a:	eb cd 00 ff 	pushm	r0-r7
80005e8e:	fa c7 ff c0 	sub	r7,sp,-64
80005e92:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e96:	ef 40 ff e0 	st.w	r7[-32],r0
80005e9a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e9e:	ef 40 ff e4 	st.w	r7[-28],r0
80005ea2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005ea6:	e0 68 05 34 	mov	r8,1332
80005eaa:	ea 18 00 00 	orh	r8,0x0
80005eae:	70 00       	ld.w	r0,r8[0x0]
80005eb0:	1a d0       	st.w	--sp,r0
80005eb2:	f0 1f 00 1a 	mcall	80005f18 <LABEL_RET_SCALL_263+0x14>
80005eb6:	e0 68 0c f4 	mov	r8,3316
80005eba:	ea 18 00 00 	orh	r8,0x0
80005ebe:	70 00       	ld.w	r0,r8[0x0]
80005ec0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005ec2:	f0 1f 00 17 	mcall	80005f1c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005ec6:	e0 68 0c f4 	mov	r8,3316
80005eca:	ea 18 00 00 	orh	r8,0x0
80005ece:	70 00       	ld.w	r0,r8[0x0]
80005ed0:	60 0d       	ld.w	sp,r0[0x0]
80005ed2:	1b 00       	ld.w	r0,sp++
80005ed4:	e0 68 05 34 	mov	r8,1332
80005ed8:	ea 18 00 00 	orh	r8,0x0
80005edc:	91 00       	st.w	r8[0x0],r0
80005ede:	fa c7 ff d8 	sub	r7,sp,-40
80005ee2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005ee6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005eea:	e0 61 05 34 	mov	r1,1332
80005eee:	ea 11 00 00 	orh	r1,0x0
80005ef2:	62 02       	ld.w	r2,r1[0x0]
80005ef4:	58 02       	cp.w	r2,0
80005ef6:	c0 70       	breq	80005f04 <LABEL_RET_SCALL_263>
80005ef8:	e4 c2 00 01 	sub	r2,r2,1
80005efc:	83 02       	st.w	r1[0x0],r2
80005efe:	58 02       	cp.w	r2,0
80005f00:	c0 21       	brne	80005f04 <LABEL_RET_SCALL_263>
80005f02:	b1 c0       	cbr	r0,0x10

80005f04 <LABEL_RET_SCALL_263>:
80005f04:	ef 40 ff f8 	st.w	r7[-8],r0
80005f08:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005f0c:	ef 40 ff fc 	st.w	r7[-4],r0
80005f10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f14:	2f ad       	sub	sp,-24
80005f16:	d6 13       	rets
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	5e 20       	reths	r0
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	65 bc       	ld.w	r12,r2[0x6c]

80005f20 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005f20:	e1 b8 00 43 	mfsr	r8,0x10c
80005f24:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005f28:	5e fc       	retal	r12
80005f2a:	d7 03       	nop

80005f2c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005f2c:	48 78       	lddpc	r8,80005f48 <vPortExitCritical+0x1c>
80005f2e:	70 08       	ld.w	r8,r8[0x0]
80005f30:	58 08       	cp.w	r8,0
80005f32:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f34:	48 58       	lddpc	r8,80005f48 <vPortExitCritical+0x1c>
80005f36:	70 09       	ld.w	r9,r8[0x0]
80005f38:	20 19       	sub	r9,1
80005f3a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f3c:	70 08       	ld.w	r8,r8[0x0]
80005f3e:	58 08       	cp.w	r8,0
80005f40:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f42:	d5 03       	csrf	0x10
80005f44:	5e fc       	retal	r12
80005f46:	00 00       	add	r0,r0
80005f48:	00 00       	add	r0,r0
80005f4a:	05 34       	ld.ub	r4,r2++

80005f4c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f4c:	eb cd 00 ff 	pushm	r0-r7
80005f50:	e0 68 05 34 	mov	r8,1332
80005f54:	ea 18 00 00 	orh	r8,0x0
80005f58:	70 00       	ld.w	r0,r8[0x0]
80005f5a:	1a d0       	st.w	--sp,r0
80005f5c:	7a 90       	ld.w	r0,sp[0x24]
80005f5e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f62:	58 10       	cp.w	r0,1
80005f64:	e0 8b 00 08 	brhi	80005f74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f68:	e0 68 0c f4 	mov	r8,3316
80005f6c:	ea 18 00 00 	orh	r8,0x0
80005f70:	70 00       	ld.w	r0,r8[0x0]
80005f72:	81 0d       	st.w	r0[0x0],sp

80005f74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f74:	f0 1f 00 12 	mcall	80005fbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f78:	f0 1f 00 12 	mcall	80005fc0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f7c:	f0 1f 00 12 	mcall	80005fc4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f80:	f0 1f 00 12 	mcall	80005fc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f84:	7a 90       	ld.w	r0,sp[0x24]
80005f86:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f8a:	58 10       	cp.w	r0,1
80005f8c:	e0 8b 00 0e 	brhi	80005fa8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f90:	f0 1f 00 0c 	mcall	80005fc0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f94:	f0 1f 00 0e 	mcall	80005fcc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f98:	f0 1f 00 0c 	mcall	80005fc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f9c:	e0 68 0c f4 	mov	r8,3316
80005fa0:	ea 18 00 00 	orh	r8,0x0
80005fa4:	70 00       	ld.w	r0,r8[0x0]
80005fa6:	60 0d       	ld.w	sp,r0[0x0]

80005fa8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005fa8:	1b 00       	ld.w	r0,sp++
80005faa:	e0 68 05 34 	mov	r8,1332
80005fae:	ea 18 00 00 	orh	r8,0x0
80005fb2:	91 00       	st.w	r8[0x0],r0
80005fb4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005fb8:	d6 03       	rete
80005fba:	00 00       	add	r0,r0
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	5f 20       	srhs	r0
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5e 20       	reths	r0
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	67 c0       	ld.w	r0,r3[0x70]
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	5f 2c       	srhs	r12
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	65 bc       	ld.w	r12,r2[0x6c]

80005fd0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005fd0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005fd2:	f0 1f 00 02 	mcall	80005fd8 <__malloc_lock+0x8>
}
80005fd6:	d8 02       	popm	pc
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	65 ac       	ld.w	r12,r2[0x68]

80005fdc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005fdc:	d4 01       	pushm	lr
	xTaskResumeAll();
80005fde:	f0 1f 00 02 	mcall	80005fe4 <__malloc_unlock+0x8>
}
80005fe2:	d8 02       	popm	pc
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	69 68       	ld.w	r8,r4[0x58]

80005fe8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005fe8:	d4 21       	pushm	r4-r7,lr
80005fea:	16 95       	mov	r5,r11
80005fec:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005fee:	58 0c       	cp.w	r12,0
80005ff0:	c0 30       	breq	80005ff6 <_read+0xe>
80005ff2:	3f f7       	mov	r7,-1
80005ff4:	c1 48       	rjmp	8000601c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005ff6:	58 0a       	cp.w	r10,0
80005ff8:	e0 89 00 04 	brgt	80006000 <_read+0x18>
80005ffc:	30 07       	mov	r7,0
80005ffe:	c0 f8       	rjmp	8000601c <_read+0x34>
80006000:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006002:	48 84       	lddpc	r4,80006020 <_read+0x38>
80006004:	68 0c       	ld.w	r12,r4[0x0]
80006006:	f0 1f 00 08 	mcall	80006024 <_read+0x3c>
    if (c < 0)
8000600a:	c0 95       	brlt	8000601c <_read+0x34>
      break;

    *ptr++ = c;
8000600c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006010:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006012:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006016:	58 08       	cp.w	r8,0
80006018:	fe 99 ff f6 	brgt	80006004 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000601c:	0e 9c       	mov	r12,r7
8000601e:	d8 22       	popm	r4-r7,pc
80006020:	00 00       	add	r0,r0
80006022:	bf f0       	*unknown*
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	5b 74       	cp.w	r4,-9

80006028 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006028:	d4 21       	pushm	r4-r7,lr
8000602a:	16 95       	mov	r5,r11
8000602c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000602e:	20 1c       	sub	r12,1
80006030:	58 2c       	cp.w	r12,2
80006032:	e0 8b 00 12 	brhi	80006056 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006036:	58 0a       	cp.w	r10,0
80006038:	c0 31       	brne	8000603e <_write+0x16>
8000603a:	30 07       	mov	r7,0
8000603c:	c0 e8       	rjmp	80006058 <_write+0x30>
8000603e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006040:	48 74       	lddpc	r4,8000605c <_write+0x34>
80006042:	68 0c       	ld.w	r12,r4[0x0]
80006044:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006048:	f0 1f 00 06 	mcall	80006060 <_write+0x38>
8000604c:	c0 55       	brlt	80006056 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000604e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006050:	0e 36       	cp.w	r6,r7
80006052:	cf 81       	brne	80006042 <_write+0x1a>
80006054:	c0 28       	rjmp	80006058 <_write+0x30>
80006056:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006058:	0e 9c       	mov	r12,r7
8000605a:	d8 22       	popm	r4-r7,pc
8000605c:	00 00       	add	r0,r0
8000605e:	bf f0       	*unknown*
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	5b 24       	cp.w	r4,-14

80006064 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006064:	eb cd 40 80 	pushm	r7,lr
80006068:	18 97       	mov	r7,r12
	if( pv )
8000606a:	58 0c       	cp.w	r12,0
8000606c:	c0 80       	breq	8000607c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000606e:	f0 1f 00 05 	mcall	80006080 <vPortFree+0x1c>
		{
			free( pv );
80006072:	0e 9c       	mov	r12,r7
80006074:	f0 1f 00 04 	mcall	80006084 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006078:	f0 1f 00 04 	mcall	80006088 <vPortFree+0x24>
8000607c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	65 ac       	ld.w	r12,r2[0x68]
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	74 3c       	ld.w	r12,r10[0xc]
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	69 68       	ld.w	r8,r4[0x58]

8000608c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000608c:	eb cd 40 80 	pushm	r7,lr
80006090:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006092:	f0 1f 00 06 	mcall	800060a8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006096:	0e 9c       	mov	r12,r7
80006098:	f0 1f 00 05 	mcall	800060ac <pvPortMalloc+0x20>
8000609c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000609e:	f0 1f 00 05 	mcall	800060b0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800060a2:	0e 9c       	mov	r12,r7
800060a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	65 ac       	ld.w	r12,r2[0x68]
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	74 4c       	ld.w	r12,r10[0x10]
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	69 68       	ld.w	r8,r4[0x58]

800060b4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800060b4:	d4 01       	pushm	lr
800060b6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800060b8:	78 09       	ld.w	r9,r12[0x0]
800060ba:	58 09       	cp.w	r9,0
800060bc:	c1 10       	breq	800060de <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800060be:	78 3a       	ld.w	r10,r12[0xc]
800060c0:	79 09       	ld.w	r9,r12[0x40]
800060c2:	f4 09 00 09 	add	r9,r10,r9
800060c6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800060c8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800060ca:	14 39       	cp.w	r9,r10
800060cc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800060d0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800060d4:	79 0a       	ld.w	r10,r12[0x40]
800060d6:	78 3b       	ld.w	r11,r12[0xc]
800060d8:	10 9c       	mov	r12,r8
800060da:	f0 1f 00 02 	mcall	800060e0 <prvCopyDataFromQueue+0x2c>
800060de:	d8 02       	popm	pc
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	78 94       	ld.w	r4,r12[0x24]

800060e4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800060e4:	eb cd 40 c0 	pushm	r6-r7,lr
800060e8:	18 97       	mov	r7,r12
800060ea:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060ec:	78 e8       	ld.w	r8,r12[0x38]
800060ee:	58 08       	cp.w	r8,0
800060f0:	c0 31       	brne	800060f6 <xQueueReceiveFromISR+0x12>
800060f2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060f6:	f0 1f 00 0e 	mcall	8000612c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060fa:	6e e8       	ld.w	r8,r7[0x38]
800060fc:	20 18       	sub	r8,1
800060fe:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006100:	6f 18       	ld.w	r8,r7[0x44]
80006102:	5b f8       	cp.w	r8,-1
80006104:	c0 d1       	brne	8000611e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006106:	6e 48       	ld.w	r8,r7[0x10]
80006108:	58 08       	cp.w	r8,0
8000610a:	c0 f0       	breq	80006128 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000610c:	ee cc ff f0 	sub	r12,r7,-16
80006110:	f0 1f 00 08 	mcall	80006130 <xQueueReceiveFromISR+0x4c>
80006114:	c0 a0       	breq	80006128 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006116:	30 1c       	mov	r12,1
80006118:	8d 0c       	st.w	r6[0x0],r12
8000611a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000611e:	2f f8       	sub	r8,-1
80006120:	ef 48 00 44 	st.w	r7[68],r8
80006124:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006128:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	60 b4       	ld.w	r4,r0[0x2c]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	67 44       	ld.w	r4,r3[0x50]

80006134 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006134:	eb cd 40 c0 	pushm	r6-r7,lr
80006138:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000613a:	f0 1f 00 23 	mcall	800061c4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000613e:	6f 28       	ld.w	r8,r7[0x48]
80006140:	58 08       	cp.w	r8,0
80006142:	e0 8a 00 18 	brle	80006172 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006146:	6e 98       	ld.w	r8,r7[0x24]
80006148:	58 08       	cp.w	r8,0
8000614a:	c1 40       	breq	80006172 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000614c:	ee c6 ff dc 	sub	r6,r7,-36
80006150:	c0 48       	rjmp	80006158 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006152:	6e 98       	ld.w	r8,r7[0x24]
80006154:	58 08       	cp.w	r8,0
80006156:	c0 e0       	breq	80006172 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006158:	0c 9c       	mov	r12,r6
8000615a:	f0 1f 00 1c 	mcall	800061c8 <prvUnlockQueue+0x94>
8000615e:	c0 30       	breq	80006164 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006160:	f0 1f 00 1b 	mcall	800061cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006164:	6f 28       	ld.w	r8,r7[0x48]
80006166:	20 18       	sub	r8,1
80006168:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000616c:	58 08       	cp.w	r8,0
8000616e:	fe 99 ff f2 	brgt	80006152 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006172:	3f f8       	mov	r8,-1
80006174:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006178:	f0 1f 00 16 	mcall	800061d0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000617c:	f0 1f 00 12 	mcall	800061c4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006180:	6f 18       	ld.w	r8,r7[0x44]
80006182:	58 08       	cp.w	r8,0
80006184:	e0 8a 00 18 	brle	800061b4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006188:	6e 48       	ld.w	r8,r7[0x10]
8000618a:	58 08       	cp.w	r8,0
8000618c:	c1 40       	breq	800061b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000618e:	ee c6 ff f0 	sub	r6,r7,-16
80006192:	c0 48       	rjmp	8000619a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006194:	6e 48       	ld.w	r8,r7[0x10]
80006196:	58 08       	cp.w	r8,0
80006198:	c0 e0       	breq	800061b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000619a:	0c 9c       	mov	r12,r6
8000619c:	f0 1f 00 0b 	mcall	800061c8 <prvUnlockQueue+0x94>
800061a0:	c0 30       	breq	800061a6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800061a2:	f0 1f 00 0b 	mcall	800061cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800061a6:	6f 18       	ld.w	r8,r7[0x44]
800061a8:	20 18       	sub	r8,1
800061aa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061ae:	58 08       	cp.w	r8,0
800061b0:	fe 99 ff f2 	brgt	80006194 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800061b4:	3f f8       	mov	r8,-1
800061b6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800061ba:	f0 1f 00 06 	mcall	800061d0 <prvUnlockQueue+0x9c>
}
800061be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061c2:	00 00       	add	r0,r0
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	5e 20       	reths	r0
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	67 44       	ld.w	r4,r3[0x50]
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	66 50       	ld.w	r0,r3[0x14]
800061d0:	80 00       	ld.sh	r0,r0[0x0]
800061d2:	5f 2c       	srhs	r12

800061d4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800061d4:	d4 31       	pushm	r0-r7,lr
800061d6:	20 5d       	sub	sp,20
800061d8:	18 97       	mov	r7,r12
800061da:	50 0b       	stdsp	sp[0x0],r11
800061dc:	50 2a       	stdsp	sp[0x8],r10
800061de:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800061e0:	f8 c2 ff dc 	sub	r2,r12,-36
800061e4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061e6:	fa c4 ff f4 	sub	r4,sp,-12
800061ea:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061ec:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061ee:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800061f2:	f0 1f 00 3e 	mcall	800062e8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061f6:	6e e8       	ld.w	r8,r7[0x38]
800061f8:	58 08       	cp.w	r8,0
800061fa:	c2 a0       	breq	8000624e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061fc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061fe:	40 0b       	lddsp	r11,sp[0x0]
80006200:	0e 9c       	mov	r12,r7
80006202:	f0 1f 00 3b 	mcall	800062ec <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006206:	40 18       	lddsp	r8,sp[0x4]
80006208:	58 08       	cp.w	r8,0
8000620a:	c1 51       	brne	80006234 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000620c:	6e e8       	ld.w	r8,r7[0x38]
8000620e:	20 18       	sub	r8,1
80006210:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006212:	6e 08       	ld.w	r8,r7[0x0]
80006214:	58 08       	cp.w	r8,0
80006216:	c0 41       	brne	8000621e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006218:	f0 1f 00 36 	mcall	800062f0 <xQueueGenericReceive+0x11c>
8000621c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000621e:	6e 48       	ld.w	r8,r7[0x10]
80006220:	58 08       	cp.w	r8,0
80006222:	c1 20       	breq	80006246 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006224:	ee cc ff f0 	sub	r12,r7,-16
80006228:	f0 1f 00 33 	mcall	800062f4 <xQueueGenericReceive+0x120>
8000622c:	58 1c       	cp.w	r12,1
8000622e:	c0 c1       	brne	80006246 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006230:	d7 33       	scall
80006232:	c0 a8       	rjmp	80006246 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006234:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006236:	6e 98       	ld.w	r8,r7[0x24]
80006238:	58 08       	cp.w	r8,0
8000623a:	c0 60       	breq	80006246 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000623c:	04 9c       	mov	r12,r2
8000623e:	f0 1f 00 2e 	mcall	800062f4 <xQueueGenericReceive+0x120>
80006242:	c0 20       	breq	80006246 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006244:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006246:	f0 1f 00 2d 	mcall	800062f8 <xQueueGenericReceive+0x124>
8000624a:	30 1c       	mov	r12,1
				return pdPASS;
8000624c:	c4 c8       	rjmp	800062e4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000624e:	40 28       	lddsp	r8,sp[0x8]
80006250:	58 08       	cp.w	r8,0
80006252:	c0 51       	brne	8000625c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006254:	f0 1f 00 29 	mcall	800062f8 <xQueueGenericReceive+0x124>
80006258:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000625a:	c4 58       	rjmp	800062e4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000625c:	58 05       	cp.w	r5,0
8000625e:	c0 51       	brne	80006268 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006260:	08 9c       	mov	r12,r4
80006262:	f0 1f 00 27 	mcall	800062fc <xQueueGenericReceive+0x128>
80006266:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006268:	f0 1f 00 24 	mcall	800062f8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000626c:	f0 1f 00 25 	mcall	80006300 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006270:	f0 1f 00 1e 	mcall	800062e8 <xQueueGenericReceive+0x114>
80006274:	6f 18       	ld.w	r8,r7[0x44]
80006276:	5b f8       	cp.w	r8,-1
80006278:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000627c:	6f 28       	ld.w	r8,r7[0x48]
8000627e:	5b f8       	cp.w	r8,-1
80006280:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006284:	f0 1f 00 1d 	mcall	800062f8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006288:	06 9b       	mov	r11,r3
8000628a:	08 9c       	mov	r12,r4
8000628c:	f0 1f 00 1e 	mcall	80006304 <xQueueGenericReceive+0x130>
80006290:	c2 41       	brne	800062d8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006292:	f0 1f 00 16 	mcall	800062e8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006296:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006298:	f0 1f 00 18 	mcall	800062f8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000629c:	58 06       	cp.w	r6,0
8000629e:	c1 71       	brne	800062cc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062a0:	6e 08       	ld.w	r8,r7[0x0]
800062a2:	58 08       	cp.w	r8,0
800062a4:	c0 81       	brne	800062b4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800062a6:	f0 1f 00 11 	mcall	800062e8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800062aa:	6e 1c       	ld.w	r12,r7[0x4]
800062ac:	f0 1f 00 17 	mcall	80006308 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800062b0:	f0 1f 00 12 	mcall	800062f8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800062b4:	40 2b       	lddsp	r11,sp[0x8]
800062b6:	04 9c       	mov	r12,r2
800062b8:	f0 1f 00 15 	mcall	8000630c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800062bc:	0e 9c       	mov	r12,r7
800062be:	f0 1f 00 15 	mcall	80006310 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800062c2:	f0 1f 00 15 	mcall	80006314 <xQueueGenericReceive+0x140>
800062c6:	c9 61       	brne	800061f2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800062c8:	d7 33       	scall
800062ca:	c9 4b       	rjmp	800061f2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800062cc:	0e 9c       	mov	r12,r7
800062ce:	f0 1f 00 11 	mcall	80006310 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800062d2:	f0 1f 00 11 	mcall	80006314 <xQueueGenericReceive+0x140>
800062d6:	c8 eb       	rjmp	800061f2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800062d8:	0e 9c       	mov	r12,r7
800062da:	f0 1f 00 0e 	mcall	80006310 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800062de:	f0 1f 00 0e 	mcall	80006314 <xQueueGenericReceive+0x140>
800062e2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800062e4:	2f bd       	sub	sp,-20
800062e6:	d8 32       	popm	r0-r7,pc
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	5e 20       	reths	r0
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	60 b4       	ld.w	r4,r0[0x2c]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	66 5c       	ld.w	r12,r3[0x14]
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	67 44       	ld.w	r4,r3[0x50]
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	5f 2c       	srhs	r12
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	66 38       	ld.w	r8,r3[0xc]
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	65 ac       	ld.w	r12,r2[0x68]
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	68 d4       	ld.w	r4,r4[0x34]
80006308:	80 00       	ld.sh	r0,r0[0x0]
8000630a:	66 c0       	ld.w	r0,r3[0x30]
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	6b 74       	ld.w	r4,r5[0x5c]
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	61 34       	ld.w	r4,r0[0x4c]
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	69 68       	ld.w	r8,r4[0x58]

80006318 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006318:	eb cd 40 80 	pushm	r7,lr
8000631c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000631e:	79 08       	ld.w	r8,r12[0x40]
80006320:	58 08       	cp.w	r8,0
80006322:	c0 a1       	brne	80006336 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006324:	78 08       	ld.w	r8,r12[0x0]
80006326:	58 08       	cp.w	r8,0
80006328:	c2 b1       	brne	8000637e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000632a:	78 1c       	ld.w	r12,r12[0x4]
8000632c:	f0 1f 00 17 	mcall	80006388 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006330:	30 08       	mov	r8,0
80006332:	8f 18       	st.w	r7[0x4],r8
80006334:	c2 58       	rjmp	8000637e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006336:	58 0a       	cp.w	r10,0
80006338:	c1 01       	brne	80006358 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000633a:	10 9a       	mov	r10,r8
8000633c:	78 2c       	ld.w	r12,r12[0x8]
8000633e:	f0 1f 00 14 	mcall	8000638c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006342:	6e 29       	ld.w	r9,r7[0x8]
80006344:	6f 08       	ld.w	r8,r7[0x40]
80006346:	f2 08 00 08 	add	r8,r9,r8
8000634a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000634c:	6e 19       	ld.w	r9,r7[0x4]
8000634e:	12 38       	cp.w	r8,r9
80006350:	c1 73       	brcs	8000637e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006352:	6e 08       	ld.w	r8,r7[0x0]
80006354:	8f 28       	st.w	r7[0x8],r8
80006356:	c1 48       	rjmp	8000637e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006358:	10 9a       	mov	r10,r8
8000635a:	78 3c       	ld.w	r12,r12[0xc]
8000635c:	f0 1f 00 0c 	mcall	8000638c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006360:	6f 08       	ld.w	r8,r7[0x40]
80006362:	6e 39       	ld.w	r9,r7[0xc]
80006364:	f2 08 01 08 	sub	r8,r9,r8
80006368:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000636a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000636c:	12 38       	cp.w	r8,r9
8000636e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006372:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006376:	f3 d8 e3 19 	subcs	r9,r9,r8
8000637a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000637e:	6e e8       	ld.w	r8,r7[0x38]
80006380:	2f f8       	sub	r8,-1
80006382:	8f e8       	st.w	r7[0x38],r8
}
80006384:	e3 cd 80 80 	ldm	sp++,r7,pc
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	66 68       	ld.w	r8,r3[0x18]
8000638c:	80 00       	ld.sh	r0,r0[0x0]
8000638e:	78 94       	ld.w	r4,r12[0x24]

80006390 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006390:	eb cd 40 c0 	pushm	r6-r7,lr
80006394:	18 97       	mov	r7,r12
80006396:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006398:	78 ec       	ld.w	r12,r12[0x38]
8000639a:	6e f8       	ld.w	r8,r7[0x3c]
8000639c:	10 3c       	cp.w	r12,r8
8000639e:	c0 33       	brcs	800063a4 <xQueueGenericSendFromISR+0x14>
800063a0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063a4:	12 9a       	mov	r10,r9
800063a6:	0e 9c       	mov	r12,r7
800063a8:	f0 1f 00 0c 	mcall	800063d8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800063ac:	6f 28       	ld.w	r8,r7[0x48]
800063ae:	5b f8       	cp.w	r8,-1
800063b0:	c0 d1       	brne	800063ca <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063b2:	6e 98       	ld.w	r8,r7[0x24]
800063b4:	58 08       	cp.w	r8,0
800063b6:	c0 f0       	breq	800063d4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800063b8:	ee cc ff dc 	sub	r12,r7,-36
800063bc:	f0 1f 00 08 	mcall	800063dc <xQueueGenericSendFromISR+0x4c>
800063c0:	c0 a0       	breq	800063d4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800063c2:	30 1c       	mov	r12,1
800063c4:	8d 0c       	st.w	r6[0x0],r12
800063c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800063ca:	2f f8       	sub	r8,-1
800063cc:	ef 48 00 48 	st.w	r7[72],r8
800063d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063d4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	63 18       	ld.w	r8,r1[0x44]
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	67 44       	ld.w	r4,r3[0x50]

800063e0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800063e0:	d4 31       	pushm	r0-r7,lr
800063e2:	20 5d       	sub	sp,20
800063e4:	18 97       	mov	r7,r12
800063e6:	50 0b       	stdsp	sp[0x0],r11
800063e8:	50 2a       	stdsp	sp[0x8],r10
800063ea:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063ec:	f8 c0 ff f0 	sub	r0,r12,-16
800063f0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063f2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063f6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063f8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063fc:	f0 1f 00 2f 	mcall	800064b8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006400:	6e e9       	ld.w	r9,r7[0x38]
80006402:	6e f8       	ld.w	r8,r7[0x3c]
80006404:	10 39       	cp.w	r9,r8
80006406:	c1 42       	brcc	8000642e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006408:	40 1a       	lddsp	r10,sp[0x4]
8000640a:	40 0b       	lddsp	r11,sp[0x0]
8000640c:	0e 9c       	mov	r12,r7
8000640e:	f0 1f 00 2c 	mcall	800064bc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006412:	6e 98       	ld.w	r8,r7[0x24]
80006414:	58 08       	cp.w	r8,0
80006416:	c0 80       	breq	80006426 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006418:	ee cc ff dc 	sub	r12,r7,-36
8000641c:	f0 1f 00 29 	mcall	800064c0 <xQueueGenericSend+0xe0>
80006420:	58 1c       	cp.w	r12,1
80006422:	c0 21       	brne	80006426 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006424:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006426:	f0 1f 00 28 	mcall	800064c4 <xQueueGenericSend+0xe4>
8000642a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000642c:	c4 38       	rjmp	800064b2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000642e:	40 28       	lddsp	r8,sp[0x8]
80006430:	58 08       	cp.w	r8,0
80006432:	c0 51       	brne	8000643c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006434:	f0 1f 00 24 	mcall	800064c4 <xQueueGenericSend+0xe4>
80006438:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000643a:	c3 c8       	rjmp	800064b2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000643c:	58 04       	cp.w	r4,0
8000643e:	c0 51       	brne	80006448 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006440:	06 9c       	mov	r12,r3
80006442:	f0 1f 00 22 	mcall	800064c8 <xQueueGenericSend+0xe8>
80006446:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006448:	f0 1f 00 1f 	mcall	800064c4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000644c:	f0 1f 00 20 	mcall	800064cc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006450:	f0 1f 00 1a 	mcall	800064b8 <xQueueGenericSend+0xd8>
80006454:	6f 18       	ld.w	r8,r7[0x44]
80006456:	5b f8       	cp.w	r8,-1
80006458:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000645c:	6f 28       	ld.w	r8,r7[0x48]
8000645e:	5b f8       	cp.w	r8,-1
80006460:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006464:	f0 1f 00 18 	mcall	800064c4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006468:	04 9b       	mov	r11,r2
8000646a:	06 9c       	mov	r12,r3
8000646c:	f0 1f 00 19 	mcall	800064d0 <xQueueGenericSend+0xf0>
80006470:	c1 b1       	brne	800064a6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006472:	f0 1f 00 12 	mcall	800064b8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006476:	6e e5       	ld.w	r5,r7[0x38]
80006478:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000647a:	f0 1f 00 13 	mcall	800064c4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000647e:	0c 35       	cp.w	r5,r6
80006480:	c0 d1       	brne	8000649a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006482:	40 2b       	lddsp	r11,sp[0x8]
80006484:	00 9c       	mov	r12,r0
80006486:	f0 1f 00 14 	mcall	800064d4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000648a:	0e 9c       	mov	r12,r7
8000648c:	f0 1f 00 13 	mcall	800064d8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006490:	f0 1f 00 13 	mcall	800064dc <xQueueGenericSend+0xfc>
80006494:	cb 41       	brne	800063fc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006496:	d7 33       	scall
80006498:	cb 2b       	rjmp	800063fc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000649a:	0e 9c       	mov	r12,r7
8000649c:	f0 1f 00 0f 	mcall	800064d8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800064a0:	f0 1f 00 0f 	mcall	800064dc <xQueueGenericSend+0xfc>
800064a4:	ca cb       	rjmp	800063fc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800064a6:	0e 9c       	mov	r12,r7
800064a8:	f0 1f 00 0c 	mcall	800064d8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800064ac:	f0 1f 00 0c 	mcall	800064dc <xQueueGenericSend+0xfc>
800064b0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800064b2:	2f bd       	sub	sp,-20
800064b4:	d8 32       	popm	r0-r7,pc
800064b6:	00 00       	add	r0,r0
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	5e 20       	reths	r0
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	63 18       	ld.w	r8,r1[0x44]
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	67 44       	ld.w	r4,r3[0x50]
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	5f 2c       	srhs	r12
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	66 38       	ld.w	r8,r3[0xc]
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	65 ac       	ld.w	r12,r2[0x68]
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	68 d4       	ld.w	r4,r4[0x34]
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	6b 74       	ld.w	r4,r5[0x5c]
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	61 34       	ld.w	r4,r0[0x4c]
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	69 68       	ld.w	r8,r4[0x58]

800064e0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800064e0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064e4:	34 cc       	mov	r12,76
800064e6:	f0 1f 00 12 	mcall	8000652c <xQueueCreateMutex+0x4c>
800064ea:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800064ec:	c1 d0       	breq	80006526 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800064ee:	30 06       	mov	r6,0
800064f0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800064f2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064f4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064f6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064f8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064fa:	30 18       	mov	r8,1
800064fc:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064fe:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006502:	3f f8       	mov	r8,-1
80006504:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006508:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000650c:	2f 0c       	sub	r12,-16
8000650e:	f0 1f 00 09 	mcall	80006530 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006512:	ee cc ff dc 	sub	r12,r7,-36
80006516:	f0 1f 00 07 	mcall	80006530 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000651a:	0c 99       	mov	r9,r6
8000651c:	0c 9a       	mov	r10,r6
8000651e:	0c 9b       	mov	r11,r6
80006520:	0e 9c       	mov	r12,r7
80006522:	f0 1f 00 05 	mcall	80006534 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006526:	0e 9c       	mov	r12,r7
80006528:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	60 8c       	ld.w	r12,r0[0x20]
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	5c fc       	rol	r12
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	63 e0       	ld.w	r0,r1[0x78]

80006538 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006538:	d4 21       	pushm	r4-r7,lr
8000653a:	18 97       	mov	r7,r12
8000653c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000653e:	58 0c       	cp.w	r12,0
80006540:	c2 f0       	breq	8000659e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006542:	34 cc       	mov	r12,76
80006544:	f0 1f 00 17 	mcall	800065a0 <xQueueCreate+0x68>
80006548:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000654a:	c2 a0       	breq	8000659e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000654c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006550:	e8 cc ff ff 	sub	r12,r4,-1
80006554:	f0 1f 00 13 	mcall	800065a0 <xQueueCreate+0x68>
80006558:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000655a:	c1 e0       	breq	80006596 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000655c:	f8 04 00 04 	add	r4,r12,r4
80006560:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006562:	30 08       	mov	r8,0
80006564:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006566:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006568:	ee c8 00 01 	sub	r8,r7,1
8000656c:	ad 38       	mul	r8,r6
8000656e:	10 0c       	add	r12,r8
80006570:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006572:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006574:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006578:	3f f8       	mov	r8,-1
8000657a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000657e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006582:	ea cc ff f0 	sub	r12,r5,-16
80006586:	f0 1f 00 08 	mcall	800065a4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000658a:	ea cc ff dc 	sub	r12,r5,-36
8000658e:	f0 1f 00 06 	mcall	800065a4 <xQueueCreate+0x6c>
80006592:	0a 9c       	mov	r12,r5
80006594:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006596:	0a 9c       	mov	r12,r5
80006598:	f0 1f 00 04 	mcall	800065a8 <xQueueCreate+0x70>
8000659c:	d8 2a       	popm	r4-r7,pc,r12=0
8000659e:	d8 2a       	popm	r4-r7,pc,r12=0
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	60 8c       	ld.w	r12,r0[0x20]
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	5c fc       	rol	r12
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	60 64       	ld.w	r4,r0[0x18]

800065ac <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800065ac:	48 38       	lddpc	r8,800065b8 <vTaskSuspendAll+0xc>
800065ae:	70 09       	ld.w	r9,r8[0x0]
800065b0:	2f f9       	sub	r9,-1
800065b2:	91 09       	st.w	r8[0x0],r9
}
800065b4:	5e fc       	retal	r12
800065b6:	00 00       	add	r0,r0
800065b8:	00 00       	add	r0,r0
800065ba:	0d 24       	ld.uh	r4,r6++

800065bc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800065bc:	49 a8       	lddpc	r8,80006624 <vTaskSwitchContext+0x68>
800065be:	70 08       	ld.w	r8,r8[0x0]
800065c0:	58 08       	cp.w	r8,0
800065c2:	c0 b1       	brne	800065d8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065c4:	49 98       	lddpc	r8,80006628 <vTaskSwitchContext+0x6c>
800065c6:	70 08       	ld.w	r8,r8[0x0]
800065c8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065cc:	49 89       	lddpc	r9,8000662c <vTaskSwitchContext+0x70>
800065ce:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800065d2:	58 08       	cp.w	r8,0
800065d4:	c0 60       	breq	800065e0 <vTaskSwitchContext+0x24>
800065d6:	c1 18       	rjmp	800065f8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800065d8:	30 19       	mov	r9,1
800065da:	49 68       	lddpc	r8,80006630 <vTaskSwitchContext+0x74>
800065dc:	91 09       	st.w	r8[0x0],r9
800065de:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065e0:	49 28       	lddpc	r8,80006628 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065e2:	49 3a       	lddpc	r10,8000662c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065e4:	70 09       	ld.w	r9,r8[0x0]
800065e6:	20 19       	sub	r9,1
800065e8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065ea:	70 09       	ld.w	r9,r8[0x0]
800065ec:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065f0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065f4:	58 09       	cp.w	r9,0
800065f6:	cf 70       	breq	800065e4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065f8:	48 c8       	lddpc	r8,80006628 <vTaskSwitchContext+0x6c>
800065fa:	70 08       	ld.w	r8,r8[0x0]
800065fc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006600:	48 b9       	lddpc	r9,8000662c <vTaskSwitchContext+0x70>
80006602:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006606:	70 19       	ld.w	r9,r8[0x4]
80006608:	72 19       	ld.w	r9,r9[0x4]
8000660a:	91 19       	st.w	r8[0x4],r9
8000660c:	f0 ca ff f8 	sub	r10,r8,-8
80006610:	14 39       	cp.w	r9,r10
80006612:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006616:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000661a:	70 18       	ld.w	r8,r8[0x4]
8000661c:	70 39       	ld.w	r9,r8[0xc]
8000661e:	48 68       	lddpc	r8,80006634 <vTaskSwitchContext+0x78>
80006620:	91 09       	st.w	r8[0x0],r9
80006622:	5e fc       	retal	r12
80006624:	00 00       	add	r0,r0
80006626:	0d 24       	ld.uh	r4,r6++
80006628:	00 00       	add	r0,r0
8000662a:	0d 5c       	ld.sh	r12,--r6
8000662c:	00 00       	add	r0,r0
8000662e:	0c 40       	or	r0,r6
80006630:	00 00       	add	r0,r0
80006632:	0d 44       	ld.w	r4,--r6
80006634:	00 00       	add	r0,r0
80006636:	0c f4       	st.b	--r6,r4

80006638 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006638:	48 48       	lddpc	r8,80006648 <vTaskSetTimeOutState+0x10>
8000663a:	70 08       	ld.w	r8,r8[0x0]
8000663c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000663e:	48 48       	lddpc	r8,8000664c <vTaskSetTimeOutState+0x14>
80006640:	70 08       	ld.w	r8,r8[0x0]
80006642:	99 18       	st.w	r12[0x4],r8
}
80006644:	5e fc       	retal	r12
80006646:	00 00       	add	r0,r0
80006648:	00 00       	add	r0,r0
8000664a:	0c 38       	cp.w	r8,r6
8000664c:	00 00       	add	r0,r0
8000664e:	0d 20       	ld.uh	r0,r6++

80006650 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006650:	30 19       	mov	r9,1
80006652:	48 28       	lddpc	r8,80006658 <vTaskMissedYield+0x8>
80006654:	91 09       	st.w	r8[0x0],r9
}
80006656:	5e fc       	retal	r12
80006658:	00 00       	add	r0,r0
8000665a:	0d 44       	ld.w	r4,--r6

8000665c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000665c:	48 28       	lddpc	r8,80006664 <xTaskGetCurrentTaskHandle+0x8>
8000665e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006660:	5e fc       	retal	r12
80006662:	00 00       	add	r0,r0
80006664:	00 00       	add	r0,r0
80006666:	0c f4       	st.b	--r6,r4

80006668 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006668:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000666c:	58 0c       	cp.w	r12,0
8000666e:	c1 f0       	breq	800066ac <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006670:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006672:	78 b9       	ld.w	r9,r12[0x2c]
80006674:	79 18       	ld.w	r8,r12[0x44]
80006676:	10 39       	cp.w	r9,r8
80006678:	c1 a0       	breq	800066ac <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000667a:	f8 c6 ff fc 	sub	r6,r12,-4
8000667e:	0c 9c       	mov	r12,r6
80006680:	f0 1f 00 0c 	mcall	800066b0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006684:	6f 1c       	ld.w	r12,r7[0x44]
80006686:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006688:	f8 08 11 08 	rsub	r8,r12,8
8000668c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000668e:	48 a8       	lddpc	r8,800066b4 <vTaskPriorityDisinherit+0x4c>
80006690:	70 08       	ld.w	r8,r8[0x0]
80006692:	10 3c       	cp.w	r12,r8
80006694:	e0 88 00 04 	brls	8000669c <vTaskPriorityDisinherit+0x34>
80006698:	48 78       	lddpc	r8,800066b4 <vTaskPriorityDisinherit+0x4c>
8000669a:	91 0c       	st.w	r8[0x0],r12
8000669c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066a0:	0c 9b       	mov	r11,r6
800066a2:	48 68       	lddpc	r8,800066b8 <vTaskPriorityDisinherit+0x50>
800066a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066a8:	f0 1f 00 05 	mcall	800066bc <vTaskPriorityDisinherit+0x54>
800066ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	5d 66       	*unknown*
800066b4:	00 00       	add	r0,r0
800066b6:	0d 5c       	ld.sh	r12,--r6
800066b8:	00 00       	add	r0,r0
800066ba:	0c 40       	or	r0,r6
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	5d 16       	icall	r6

800066c0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800066c0:	eb cd 40 c0 	pushm	r6-r7,lr
800066c4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800066c6:	49 b8       	lddpc	r8,80006730 <vTaskPriorityInherit+0x70>
800066c8:	70 08       	ld.w	r8,r8[0x0]
800066ca:	78 b9       	ld.w	r9,r12[0x2c]
800066cc:	70 b8       	ld.w	r8,r8[0x2c]
800066ce:	10 39       	cp.w	r9,r8
800066d0:	c2 d2       	brcc	8000672a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800066d2:	49 88       	lddpc	r8,80006730 <vTaskPriorityInherit+0x70>
800066d4:	70 08       	ld.w	r8,r8[0x0]
800066d6:	70 b8       	ld.w	r8,r8[0x2c]
800066d8:	f0 08 11 08 	rsub	r8,r8,8
800066dc:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800066de:	f2 09 00 28 	add	r8,r9,r9<<0x2
800066e2:	49 59       	lddpc	r9,80006734 <vTaskPriorityInherit+0x74>
800066e4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066e8:	78 59       	ld.w	r9,r12[0x14]
800066ea:	10 39       	cp.w	r9,r8
800066ec:	c1 b1       	brne	80006722 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800066ee:	f8 c6 ff fc 	sub	r6,r12,-4
800066f2:	0c 9c       	mov	r12,r6
800066f4:	f0 1f 00 11 	mcall	80006738 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066f8:	48 e8       	lddpc	r8,80006730 <vTaskPriorityInherit+0x70>
800066fa:	70 08       	ld.w	r8,r8[0x0]
800066fc:	70 bc       	ld.w	r12,r8[0x2c]
800066fe:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006700:	48 f8       	lddpc	r8,8000673c <vTaskPriorityInherit+0x7c>
80006702:	70 08       	ld.w	r8,r8[0x0]
80006704:	10 3c       	cp.w	r12,r8
80006706:	e0 88 00 04 	brls	8000670e <vTaskPriorityInherit+0x4e>
8000670a:	48 d8       	lddpc	r8,8000673c <vTaskPriorityInherit+0x7c>
8000670c:	91 0c       	st.w	r8[0x0],r12
8000670e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006712:	0c 9b       	mov	r11,r6
80006714:	48 88       	lddpc	r8,80006734 <vTaskPriorityInherit+0x74>
80006716:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000671a:	f0 1f 00 0a 	mcall	80006740 <vTaskPriorityInherit+0x80>
8000671e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006722:	48 48       	lddpc	r8,80006730 <vTaskPriorityInherit+0x70>
80006724:	70 08       	ld.w	r8,r8[0x0]
80006726:	70 b8       	ld.w	r8,r8[0x2c]
80006728:	99 b8       	st.w	r12[0x2c],r8
8000672a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000672e:	00 00       	add	r0,r0
80006730:	00 00       	add	r0,r0
80006732:	0c f4       	st.b	--r6,r4
80006734:	00 00       	add	r0,r0
80006736:	0c 40       	or	r0,r6
80006738:	80 00       	ld.sh	r0,r0[0x0]
8000673a:	5d 66       	*unknown*
8000673c:	00 00       	add	r0,r0
8000673e:	0d 5c       	ld.sh	r12,--r6
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	5d 16       	icall	r6

80006744 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006744:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006748:	78 38       	ld.w	r8,r12[0xc]
8000674a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000674c:	ee c6 ff e8 	sub	r6,r7,-24
80006750:	0c 9c       	mov	r12,r6
80006752:	f0 1f 00 15 	mcall	800067a4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006756:	49 58       	lddpc	r8,800067a8 <xTaskRemoveFromEventList+0x64>
80006758:	70 08       	ld.w	r8,r8[0x0]
8000675a:	58 08       	cp.w	r8,0
8000675c:	c1 71       	brne	8000678a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000675e:	ee c6 ff fc 	sub	r6,r7,-4
80006762:	0c 9c       	mov	r12,r6
80006764:	f0 1f 00 10 	mcall	800067a4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006768:	6e bc       	ld.w	r12,r7[0x2c]
8000676a:	49 18       	lddpc	r8,800067ac <xTaskRemoveFromEventList+0x68>
8000676c:	70 08       	ld.w	r8,r8[0x0]
8000676e:	10 3c       	cp.w	r12,r8
80006770:	e0 88 00 04 	brls	80006778 <xTaskRemoveFromEventList+0x34>
80006774:	48 e8       	lddpc	r8,800067ac <xTaskRemoveFromEventList+0x68>
80006776:	91 0c       	st.w	r8[0x0],r12
80006778:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000677c:	0c 9b       	mov	r11,r6
8000677e:	48 d8       	lddpc	r8,800067b0 <xTaskRemoveFromEventList+0x6c>
80006780:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006784:	f0 1f 00 0c 	mcall	800067b4 <xTaskRemoveFromEventList+0x70>
80006788:	c0 58       	rjmp	80006792 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000678a:	0c 9b       	mov	r11,r6
8000678c:	48 bc       	lddpc	r12,800067b8 <xTaskRemoveFromEventList+0x74>
8000678e:	f0 1f 00 0a 	mcall	800067b4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006792:	48 b8       	lddpc	r8,800067bc <xTaskRemoveFromEventList+0x78>
80006794:	70 08       	ld.w	r8,r8[0x0]
80006796:	6e b9       	ld.w	r9,r7[0x2c]
80006798:	70 b8       	ld.w	r8,r8[0x2c]
8000679a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000679c:	5f 2c       	srhs	r12
8000679e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067a2:	00 00       	add	r0,r0
800067a4:	80 00       	ld.sh	r0,r0[0x0]
800067a6:	5d 66       	*unknown*
800067a8:	00 00       	add	r0,r0
800067aa:	0d 24       	ld.uh	r4,r6++
800067ac:	00 00       	add	r0,r0
800067ae:	0d 5c       	ld.sh	r12,--r6
800067b0:	00 00       	add	r0,r0
800067b2:	0c 40       	or	r0,r6
800067b4:	80 00       	ld.sh	r0,r0[0x0]
800067b6:	5d 16       	icall	r6
800067b8:	00 00       	add	r0,r0
800067ba:	0c f8       	st.b	--r6,r8
800067bc:	00 00       	add	r0,r0
800067be:	0c f4       	st.b	--r6,r4

800067c0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800067c0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800067c4:	4b 98       	lddpc	r8,800068a8 <vTaskIncrementTick+0xe8>
800067c6:	70 08       	ld.w	r8,r8[0x0]
800067c8:	58 08       	cp.w	r8,0
800067ca:	c6 91       	brne	8000689c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800067cc:	4b 88       	lddpc	r8,800068ac <vTaskIncrementTick+0xec>
800067ce:	70 09       	ld.w	r9,r8[0x0]
800067d0:	2f f9       	sub	r9,-1
800067d2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800067d4:	70 08       	ld.w	r8,r8[0x0]
800067d6:	58 08       	cp.w	r8,0
800067d8:	c1 a1       	brne	8000680c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800067da:	4b 68       	lddpc	r8,800068b0 <vTaskIncrementTick+0xf0>
800067dc:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800067de:	4b 69       	lddpc	r9,800068b4 <vTaskIncrementTick+0xf4>
800067e0:	72 0b       	ld.w	r11,r9[0x0]
800067e2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800067e4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800067e6:	4b 59       	lddpc	r9,800068b8 <vTaskIncrementTick+0xf8>
800067e8:	72 0a       	ld.w	r10,r9[0x0]
800067ea:	2f fa       	sub	r10,-1
800067ec:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800067ee:	70 08       	ld.w	r8,r8[0x0]
800067f0:	70 08       	ld.w	r8,r8[0x0]
800067f2:	58 08       	cp.w	r8,0
800067f4:	c0 51       	brne	800067fe <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067f6:	3f f9       	mov	r9,-1
800067f8:	4b 18       	lddpc	r8,800068bc <vTaskIncrementTick+0xfc>
800067fa:	91 09       	st.w	r8[0x0],r9
800067fc:	c0 88       	rjmp	8000680c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067fe:	4a d8       	lddpc	r8,800068b0 <vTaskIncrementTick+0xf0>
80006800:	70 08       	ld.w	r8,r8[0x0]
80006802:	70 38       	ld.w	r8,r8[0xc]
80006804:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006806:	70 19       	ld.w	r9,r8[0x4]
80006808:	4a d8       	lddpc	r8,800068bc <vTaskIncrementTick+0xfc>
8000680a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000680c:	4a 88       	lddpc	r8,800068ac <vTaskIncrementTick+0xec>
8000680e:	70 09       	ld.w	r9,r8[0x0]
80006810:	4a b8       	lddpc	r8,800068bc <vTaskIncrementTick+0xfc>
80006812:	70 08       	ld.w	r8,r8[0x0]
80006814:	10 39       	cp.w	r9,r8
80006816:	c4 73       	brcs	800068a4 <vTaskIncrementTick+0xe4>
80006818:	4a 68       	lddpc	r8,800068b0 <vTaskIncrementTick+0xf0>
8000681a:	70 08       	ld.w	r8,r8[0x0]
8000681c:	70 08       	ld.w	r8,r8[0x0]
8000681e:	58 08       	cp.w	r8,0
80006820:	c0 c0       	breq	80006838 <vTaskIncrementTick+0x78>
80006822:	4a 48       	lddpc	r8,800068b0 <vTaskIncrementTick+0xf0>
80006824:	70 08       	ld.w	r8,r8[0x0]
80006826:	70 38       	ld.w	r8,r8[0xc]
80006828:	70 37       	ld.w	r7,r8[0xc]
8000682a:	6e 18       	ld.w	r8,r7[0x4]
8000682c:	4a 09       	lddpc	r9,800068ac <vTaskIncrementTick+0xec>
8000682e:	72 09       	ld.w	r9,r9[0x0]
80006830:	12 38       	cp.w	r8,r9
80006832:	e0 88 00 14 	brls	8000685a <vTaskIncrementTick+0x9a>
80006836:	c0 e8       	rjmp	80006852 <vTaskIncrementTick+0x92>
80006838:	3f f9       	mov	r9,-1
8000683a:	4a 18       	lddpc	r8,800068bc <vTaskIncrementTick+0xfc>
8000683c:	91 09       	st.w	r8[0x0],r9
8000683e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006842:	6a 08       	ld.w	r8,r5[0x0]
80006844:	70 38       	ld.w	r8,r8[0xc]
80006846:	70 37       	ld.w	r7,r8[0xc]
80006848:	6e 18       	ld.w	r8,r7[0x4]
8000684a:	64 09       	ld.w	r9,r2[0x0]
8000684c:	12 38       	cp.w	r8,r9
8000684e:	e0 88 00 0a 	brls	80006862 <vTaskIncrementTick+0xa2>
80006852:	49 b9       	lddpc	r9,800068bc <vTaskIncrementTick+0xfc>
80006854:	93 08       	st.w	r9[0x0],r8
80006856:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000685a:	49 a4       	lddpc	r4,800068c0 <vTaskIncrementTick+0x100>
8000685c:	49 a3       	lddpc	r3,800068c4 <vTaskIncrementTick+0x104>
8000685e:	49 55       	lddpc	r5,800068b0 <vTaskIncrementTick+0xf0>
80006860:	49 32       	lddpc	r2,800068ac <vTaskIncrementTick+0xec>
80006862:	ee c6 ff fc 	sub	r6,r7,-4
80006866:	0c 9c       	mov	r12,r6
80006868:	f0 1f 00 18 	mcall	800068c8 <vTaskIncrementTick+0x108>
8000686c:	6e a8       	ld.w	r8,r7[0x28]
8000686e:	58 08       	cp.w	r8,0
80006870:	c0 50       	breq	8000687a <vTaskIncrementTick+0xba>
80006872:	ee cc ff e8 	sub	r12,r7,-24
80006876:	f0 1f 00 15 	mcall	800068c8 <vTaskIncrementTick+0x108>
8000687a:	6e bc       	ld.w	r12,r7[0x2c]
8000687c:	68 08       	ld.w	r8,r4[0x0]
8000687e:	10 3c       	cp.w	r12,r8
80006880:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006884:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006888:	0c 9b       	mov	r11,r6
8000688a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000688e:	f0 1f 00 10 	mcall	800068cc <vTaskIncrementTick+0x10c>
80006892:	6a 08       	ld.w	r8,r5[0x0]
80006894:	70 08       	ld.w	r8,r8[0x0]
80006896:	58 08       	cp.w	r8,0
80006898:	cd 51       	brne	80006842 <vTaskIncrementTick+0x82>
8000689a:	cc fb       	rjmp	80006838 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000689c:	48 d8       	lddpc	r8,800068d0 <vTaskIncrementTick+0x110>
8000689e:	70 09       	ld.w	r9,r8[0x0]
800068a0:	2f f9       	sub	r9,-1
800068a2:	91 09       	st.w	r8[0x0],r9
800068a4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800068a8:	00 00       	add	r0,r0
800068aa:	0d 24       	ld.uh	r4,r6++
800068ac:	00 00       	add	r0,r0
800068ae:	0d 20       	ld.uh	r0,r6++
800068b0:	00 00       	add	r0,r0
800068b2:	0c 2c       	rsub	r12,r6
800068b4:	00 00       	add	r0,r0
800068b6:	0c 3c       	cp.w	r12,r6
800068b8:	00 00       	add	r0,r0
800068ba:	0c 38       	cp.w	r8,r6
800068bc:	00 00       	add	r0,r0
800068be:	05 38       	ld.ub	r8,r2++
800068c0:	00 00       	add	r0,r0
800068c2:	0d 5c       	ld.sh	r12,--r6
800068c4:	00 00       	add	r0,r0
800068c6:	0c 40       	or	r0,r6
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	5d 66       	*unknown*
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	5d 16       	icall	r6
800068d0:	00 00       	add	r0,r0
800068d2:	0c 24       	rsub	r4,r6

800068d4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800068d4:	eb cd 40 c0 	pushm	r6-r7,lr
800068d8:	18 97       	mov	r7,r12
800068da:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800068dc:	f0 1f 00 15 	mcall	80006930 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800068e0:	6c 08       	ld.w	r8,r6[0x0]
800068e2:	5b f8       	cp.w	r8,-1
800068e4:	c0 31       	brne	800068ea <xTaskCheckForTimeOut+0x16>
800068e6:	30 07       	mov	r7,0
800068e8:	c1 f8       	rjmp	80006926 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800068ea:	49 39       	lddpc	r9,80006934 <xTaskCheckForTimeOut+0x60>
800068ec:	72 09       	ld.w	r9,r9[0x0]
800068ee:	6e 0a       	ld.w	r10,r7[0x0]
800068f0:	12 3a       	cp.w	r10,r9
800068f2:	c0 70       	breq	80006900 <xTaskCheckForTimeOut+0x2c>
800068f4:	49 19       	lddpc	r9,80006938 <xTaskCheckForTimeOut+0x64>
800068f6:	72 09       	ld.w	r9,r9[0x0]
800068f8:	6e 1a       	ld.w	r10,r7[0x4]
800068fa:	12 3a       	cp.w	r10,r9
800068fc:	e0 88 00 14 	brls	80006924 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006900:	48 e9       	lddpc	r9,80006938 <xTaskCheckForTimeOut+0x64>
80006902:	72 0a       	ld.w	r10,r9[0x0]
80006904:	6e 19       	ld.w	r9,r7[0x4]
80006906:	12 1a       	sub	r10,r9
80006908:	14 38       	cp.w	r8,r10
8000690a:	e0 88 00 0d 	brls	80006924 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000690e:	48 ba       	lddpc	r10,80006938 <xTaskCheckForTimeOut+0x64>
80006910:	74 0a       	ld.w	r10,r10[0x0]
80006912:	14 19       	sub	r9,r10
80006914:	f2 08 00 08 	add	r8,r9,r8
80006918:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000691a:	0e 9c       	mov	r12,r7
8000691c:	f0 1f 00 08 	mcall	8000693c <xTaskCheckForTimeOut+0x68>
80006920:	30 07       	mov	r7,0
80006922:	c0 28       	rjmp	80006926 <xTaskCheckForTimeOut+0x52>
80006924:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006926:	f0 1f 00 07 	mcall	80006940 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000692a:	0e 9c       	mov	r12,r7
8000692c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	5e 20       	reths	r0
80006934:	00 00       	add	r0,r0
80006936:	0c 38       	cp.w	r8,r6
80006938:	00 00       	add	r0,r0
8000693a:	0d 20       	ld.uh	r0,r6++
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	66 38       	ld.w	r8,r3[0xc]
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	5f 2c       	srhs	r12

80006944 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006944:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006948:	f0 1f 00 05 	mcall	8000695c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000694c:	48 58       	lddpc	r8,80006960 <xTaskGetTickCount+0x1c>
8000694e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006950:	f0 1f 00 05 	mcall	80006964 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006954:	0e 9c       	mov	r12,r7
80006956:	e3 cd 80 80 	ldm	sp++,r7,pc
8000695a:	00 00       	add	r0,r0
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	5e 20       	reths	r0
80006960:	00 00       	add	r0,r0
80006962:	0d 20       	ld.uh	r0,r6++
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	5f 2c       	srhs	r12

80006968 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006968:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000696c:	f0 1f 00 2c 	mcall	80006a1c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006970:	4a c8       	lddpc	r8,80006a20 <xTaskResumeAll+0xb8>
80006972:	70 09       	ld.w	r9,r8[0x0]
80006974:	20 19       	sub	r9,1
80006976:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006978:	70 08       	ld.w	r8,r8[0x0]
8000697a:	58 08       	cp.w	r8,0
8000697c:	c4 91       	brne	80006a0e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000697e:	4a a8       	lddpc	r8,80006a24 <xTaskResumeAll+0xbc>
80006980:	70 08       	ld.w	r8,r8[0x0]
80006982:	58 08       	cp.w	r8,0
80006984:	c4 50       	breq	80006a0e <xTaskResumeAll+0xa6>
80006986:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006988:	4a 85       	lddpc	r5,80006a28 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000698a:	4a 93       	lddpc	r3,80006a2c <xTaskResumeAll+0xc4>
8000698c:	4a 92       	lddpc	r2,80006a30 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000698e:	4a a1       	lddpc	r1,80006a34 <xTaskResumeAll+0xcc>
80006990:	c1 e8       	rjmp	800069cc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006992:	6a 38       	ld.w	r8,r5[0xc]
80006994:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006996:	ee cc ff e8 	sub	r12,r7,-24
8000699a:	f0 1f 00 28 	mcall	80006a38 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000699e:	ee c6 ff fc 	sub	r6,r7,-4
800069a2:	0c 9c       	mov	r12,r6
800069a4:	f0 1f 00 25 	mcall	80006a38 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800069a8:	6e bc       	ld.w	r12,r7[0x2c]
800069aa:	66 08       	ld.w	r8,r3[0x0]
800069ac:	10 3c       	cp.w	r12,r8
800069ae:	e7 fc ba 00 	st.whi	r3[0x0],r12
800069b2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069b6:	0c 9b       	mov	r11,r6
800069b8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800069bc:	f0 1f 00 20 	mcall	80006a3c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069c0:	62 08       	ld.w	r8,r1[0x0]
800069c2:	6e b9       	ld.w	r9,r7[0x2c]
800069c4:	70 b8       	ld.w	r8,r8[0x2c]
800069c6:	10 39       	cp.w	r9,r8
800069c8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069cc:	6a 08       	ld.w	r8,r5[0x0]
800069ce:	58 08       	cp.w	r8,0
800069d0:	ce 11       	brne	80006992 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069d2:	49 c8       	lddpc	r8,80006a40 <xTaskResumeAll+0xd8>
800069d4:	70 08       	ld.w	r8,r8[0x0]
800069d6:	58 08       	cp.w	r8,0
800069d8:	c0 f0       	breq	800069f6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069da:	49 a8       	lddpc	r8,80006a40 <xTaskResumeAll+0xd8>
800069dc:	70 08       	ld.w	r8,r8[0x0]
800069de:	58 08       	cp.w	r8,0
800069e0:	c1 10       	breq	80006a02 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800069e2:	49 87       	lddpc	r7,80006a40 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800069e4:	f0 1f 00 18 	mcall	80006a44 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800069e8:	6e 08       	ld.w	r8,r7[0x0]
800069ea:	20 18       	sub	r8,1
800069ec:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069ee:	6e 08       	ld.w	r8,r7[0x0]
800069f0:	58 08       	cp.w	r8,0
800069f2:	cf 91       	brne	800069e4 <xTaskResumeAll+0x7c>
800069f4:	c0 78       	rjmp	80006a02 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069f6:	58 14       	cp.w	r4,1
800069f8:	c0 50       	breq	80006a02 <xTaskResumeAll+0x9a>
800069fa:	49 48       	lddpc	r8,80006a48 <xTaskResumeAll+0xe0>
800069fc:	70 08       	ld.w	r8,r8[0x0]
800069fe:	58 18       	cp.w	r8,1
80006a00:	c0 71       	brne	80006a0e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006a02:	30 09       	mov	r9,0
80006a04:	49 18       	lddpc	r8,80006a48 <xTaskResumeAll+0xe0>
80006a06:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006a08:	d7 33       	scall
80006a0a:	30 17       	mov	r7,1
80006a0c:	c0 28       	rjmp	80006a10 <xTaskResumeAll+0xa8>
80006a0e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006a10:	f0 1f 00 0f 	mcall	80006a4c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006a14:	0e 9c       	mov	r12,r7
80006a16:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006a1a:	00 00       	add	r0,r0
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	5e 20       	reths	r0
80006a20:	00 00       	add	r0,r0
80006a22:	0d 24       	ld.uh	r4,r6++
80006a24:	00 00       	add	r0,r0
80006a26:	0d 40       	ld.w	r0,--r6
80006a28:	00 00       	add	r0,r0
80006a2a:	0c f8       	st.b	--r6,r8
80006a2c:	00 00       	add	r0,r0
80006a2e:	0d 5c       	ld.sh	r12,--r6
80006a30:	00 00       	add	r0,r0
80006a32:	0c 40       	or	r0,r6
80006a34:	00 00       	add	r0,r0
80006a36:	0c f4       	st.b	--r6,r4
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	5d 66       	*unknown*
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	5d 16       	icall	r6
80006a40:	00 00       	add	r0,r0
80006a42:	0c 24       	rsub	r4,r6
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	67 c0       	ld.w	r0,r3[0x70]
80006a48:	00 00       	add	r0,r0
80006a4a:	0d 44       	ld.w	r4,--r6
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	5f 2c       	srhs	r12

80006a50 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a50:	eb cd 40 80 	pushm	r7,lr
80006a54:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a56:	49 08       	lddpc	r8,80006a94 <prvAddCurrentTaskToDelayedList+0x44>
80006a58:	70 08       	ld.w	r8,r8[0x0]
80006a5a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a5c:	48 f8       	lddpc	r8,80006a98 <prvAddCurrentTaskToDelayedList+0x48>
80006a5e:	70 08       	ld.w	r8,r8[0x0]
80006a60:	10 3c       	cp.w	r12,r8
80006a62:	c0 a2       	brcc	80006a76 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a64:	48 c8       	lddpc	r8,80006a94 <prvAddCurrentTaskToDelayedList+0x44>
80006a66:	70 0b       	ld.w	r11,r8[0x0]
80006a68:	48 d8       	lddpc	r8,80006a9c <prvAddCurrentTaskToDelayedList+0x4c>
80006a6a:	70 0c       	ld.w	r12,r8[0x0]
80006a6c:	2f cb       	sub	r11,-4
80006a6e:	f0 1f 00 0d 	mcall	80006aa0 <prvAddCurrentTaskToDelayedList+0x50>
80006a72:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a76:	48 88       	lddpc	r8,80006a94 <prvAddCurrentTaskToDelayedList+0x44>
80006a78:	70 0b       	ld.w	r11,r8[0x0]
80006a7a:	48 b8       	lddpc	r8,80006aa4 <prvAddCurrentTaskToDelayedList+0x54>
80006a7c:	70 0c       	ld.w	r12,r8[0x0]
80006a7e:	2f cb       	sub	r11,-4
80006a80:	f0 1f 00 08 	mcall	80006aa0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a84:	48 98       	lddpc	r8,80006aa8 <prvAddCurrentTaskToDelayedList+0x58>
80006a86:	70 08       	ld.w	r8,r8[0x0]
80006a88:	10 37       	cp.w	r7,r8
80006a8a:	c0 32       	brcc	80006a90 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a8c:	48 78       	lddpc	r8,80006aa8 <prvAddCurrentTaskToDelayedList+0x58>
80006a8e:	91 07       	st.w	r8[0x0],r7
80006a90:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a94:	00 00       	add	r0,r0
80006a96:	0c f4       	st.b	--r6,r4
80006a98:	00 00       	add	r0,r0
80006a9a:	0d 20       	ld.uh	r0,r6++
80006a9c:	00 00       	add	r0,r0
80006a9e:	0c 3c       	cp.w	r12,r6
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	5d 32       	musfr	r2
80006aa4:	00 00       	add	r0,r0
80006aa6:	0c 2c       	rsub	r12,r6
80006aa8:	00 00       	add	r0,r0
80006aaa:	05 38       	ld.ub	r8,r2++

80006aac <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006aac:	eb cd 40 c0 	pushm	r6-r7,lr
80006ab0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006ab2:	58 0c       	cp.w	r12,0
80006ab4:	c1 10       	breq	80006ad6 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006ab6:	f0 1f 00 0a 	mcall	80006adc <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006aba:	48 a8       	lddpc	r8,80006ae0 <vTaskDelay+0x34>
80006abc:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006abe:	48 a8       	lddpc	r8,80006ae4 <vTaskDelay+0x38>
80006ac0:	70 0c       	ld.w	r12,r8[0x0]
80006ac2:	2f cc       	sub	r12,-4
80006ac4:	f0 1f 00 09 	mcall	80006ae8 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006ac8:	ee 06 00 0c 	add	r12,r7,r6
80006acc:	f0 1f 00 08 	mcall	80006aec <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006ad0:	f0 1f 00 08 	mcall	80006af0 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006ad4:	c0 21       	brne	80006ad8 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006ad6:	d7 33       	scall
80006ad8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	65 ac       	ld.w	r12,r2[0x68]
80006ae0:	00 00       	add	r0,r0
80006ae2:	0d 20       	ld.uh	r0,r6++
80006ae4:	00 00       	add	r0,r0
80006ae6:	0c f4       	st.b	--r6,r4
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	5d 66       	*unknown*
80006aec:	80 00       	ld.sh	r0,r0[0x0]
80006aee:	6a 50       	ld.w	r0,r5[0x14]
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	69 68       	ld.w	r8,r4[0x58]

80006af4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006af4:	eb cd 40 c0 	pushm	r6-r7,lr
80006af8:	18 96       	mov	r6,r12
80006afa:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006afc:	f0 1f 00 18 	mcall	80006b5c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006b00:	6c 08       	ld.w	r8,r6[0x0]
80006b02:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006b04:	49 79       	lddpc	r9,80006b60 <vTaskDelayUntil+0x6c>
80006b06:	72 09       	ld.w	r9,r9[0x0]
80006b08:	12 38       	cp.w	r8,r9
80006b0a:	e0 88 00 0c 	brls	80006b22 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006b0e:	0e 38       	cp.w	r8,r7
80006b10:	e0 88 00 22 	brls	80006b54 <vTaskDelayUntil+0x60>
80006b14:	49 38       	lddpc	r8,80006b60 <vTaskDelayUntil+0x6c>
80006b16:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b18:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006b1a:	10 37       	cp.w	r7,r8
80006b1c:	e0 88 00 14 	brls	80006b44 <vTaskDelayUntil+0x50>
80006b20:	c0 a8       	rjmp	80006b34 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006b22:	0e 38       	cp.w	r8,r7
80006b24:	e0 8b 00 16 	brhi	80006b50 <vTaskDelayUntil+0x5c>
80006b28:	48 e8       	lddpc	r8,80006b60 <vTaskDelayUntil+0x6c>
80006b2a:	70 08       	ld.w	r8,r8[0x0]
80006b2c:	10 37       	cp.w	r7,r8
80006b2e:	e0 8b 00 11 	brhi	80006b50 <vTaskDelayUntil+0x5c>
80006b32:	c1 18       	rjmp	80006b54 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b34:	48 c8       	lddpc	r8,80006b64 <vTaskDelayUntil+0x70>
80006b36:	70 0c       	ld.w	r12,r8[0x0]
80006b38:	2f cc       	sub	r12,-4
80006b3a:	f0 1f 00 0c 	mcall	80006b68 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b3e:	0e 9c       	mov	r12,r7
80006b40:	f0 1f 00 0b 	mcall	80006b6c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b44:	f0 1f 00 0b 	mcall	80006b70 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b48:	c0 81       	brne	80006b58 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b4a:	d7 33       	scall
80006b4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b50:	8d 07       	st.w	r6[0x0],r7
80006b52:	cf 1b       	rjmp	80006b34 <vTaskDelayUntil+0x40>
80006b54:	8d 07       	st.w	r6[0x0],r7
80006b56:	cf 7b       	rjmp	80006b44 <vTaskDelayUntil+0x50>
80006b58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	65 ac       	ld.w	r12,r2[0x68]
80006b60:	00 00       	add	r0,r0
80006b62:	0d 20       	ld.uh	r0,r6++
80006b64:	00 00       	add	r0,r0
80006b66:	0c f4       	st.b	--r6,r4
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	5d 66       	*unknown*
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	6a 50       	ld.w	r0,r5[0x14]
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	69 68       	ld.w	r8,r4[0x58]

80006b74 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b74:	eb cd 40 c0 	pushm	r6-r7,lr
80006b78:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b7a:	48 e7       	lddpc	r7,80006bb0 <vTaskPlaceOnEventList+0x3c>
80006b7c:	6e 0b       	ld.w	r11,r7[0x0]
80006b7e:	2e 8b       	sub	r11,-24
80006b80:	f0 1f 00 0d 	mcall	80006bb4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b84:	6e 0c       	ld.w	r12,r7[0x0]
80006b86:	2f cc       	sub	r12,-4
80006b88:	f0 1f 00 0c 	mcall	80006bb8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b8c:	5b f6       	cp.w	r6,-1
80006b8e:	c0 81       	brne	80006b9e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b90:	6e 0b       	ld.w	r11,r7[0x0]
80006b92:	2f cb       	sub	r11,-4
80006b94:	48 ac       	lddpc	r12,80006bbc <vTaskPlaceOnEventList+0x48>
80006b96:	f0 1f 00 0b 	mcall	80006bc0 <vTaskPlaceOnEventList+0x4c>
80006b9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b9e:	48 a8       	lddpc	r8,80006bc4 <vTaskPlaceOnEventList+0x50>
80006ba0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006ba2:	ec 0c 00 0c 	add	r12,r6,r12
80006ba6:	f0 1f 00 09 	mcall	80006bc8 <vTaskPlaceOnEventList+0x54>
80006baa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bae:	00 00       	add	r0,r0
80006bb0:	00 00       	add	r0,r0
80006bb2:	0c f4       	st.b	--r6,r4
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	5d 32       	musfr	r2
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	5d 66       	*unknown*
80006bbc:	00 00       	add	r0,r0
80006bbe:	0d 48       	ld.w	r8,--r6
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	5d 16       	icall	r6
80006bc4:	00 00       	add	r0,r0
80006bc6:	0d 20       	ld.uh	r0,r6++
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	6a 50       	ld.w	r0,r5[0x14]

80006bcc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006bcc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006bd0:	49 67       	lddpc	r7,80006c28 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006bd2:	49 74       	lddpc	r4,80006c2c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006bd4:	49 73       	lddpc	r3,80006c30 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006bd6:	49 85       	lddpc	r5,80006c34 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006bd8:	6e 08       	ld.w	r8,r7[0x0]
80006bda:	58 08       	cp.w	r8,0
80006bdc:	c1 e0       	breq	80006c18 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006bde:	f0 1f 00 17 	mcall	80006c38 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006be2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006be4:	f0 1f 00 16 	mcall	80006c3c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006be8:	58 06       	cp.w	r6,0
80006bea:	c1 70       	breq	80006c18 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006bec:	f0 1f 00 15 	mcall	80006c40 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006bf0:	68 38       	ld.w	r8,r4[0xc]
80006bf2:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006bf4:	ec cc ff fc 	sub	r12,r6,-4
80006bf8:	f0 1f 00 13 	mcall	80006c44 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006bfc:	66 08       	ld.w	r8,r3[0x0]
80006bfe:	20 18       	sub	r8,1
80006c00:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006c02:	6e 08       	ld.w	r8,r7[0x0]
80006c04:	20 18       	sub	r8,1
80006c06:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006c08:	f0 1f 00 10 	mcall	80006c48 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006c0c:	6c cc       	ld.w	r12,r6[0x30]
80006c0e:	f0 1f 00 10 	mcall	80006c4c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006c12:	0c 9c       	mov	r12,r6
80006c14:	f0 1f 00 0e 	mcall	80006c4c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c18:	6a 08       	ld.w	r8,r5[0x0]
80006c1a:	58 18       	cp.w	r8,1
80006c1c:	e0 88 00 03 	brls	80006c22 <prvIdleTask+0x56>
			{
				taskYIELD();
80006c20:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006c22:	f0 1f 00 0c 	mcall	80006c50 <prvIdleTask+0x84>
		}
		#endif
	}
80006c26:	cd 9b       	rjmp	80006bd8 <prvIdleTask+0xc>
80006c28:	00 00       	add	r0,r0
80006c2a:	0c 34       	cp.w	r4,r6
80006c2c:	00 00       	add	r0,r0
80006c2e:	0c e0       	st.h	--r6,r0
80006c30:	00 00       	add	r0,r0
80006c32:	0d 40       	ld.w	r0,--r6
80006c34:	00 00       	add	r0,r0
80006c36:	0c 40       	or	r0,r6
80006c38:	80 00       	ld.sh	r0,r0[0x0]
80006c3a:	65 ac       	ld.w	r12,r2[0x68]
80006c3c:	80 00       	ld.sh	r0,r0[0x0]
80006c3e:	69 68       	ld.w	r8,r4[0x58]
80006c40:	80 00       	ld.sh	r0,r0[0x0]
80006c42:	5e 20       	reths	r0
80006c44:	80 00       	ld.sh	r0,r0[0x0]
80006c46:	5d 66       	*unknown*
80006c48:	80 00       	ld.sh	r0,r0[0x0]
80006c4a:	5f 2c       	srhs	r12
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	60 64       	ld.w	r4,r0[0x18]
80006c50:	80 00       	ld.sh	r0,r0[0x0]
80006c52:	20 48       	sub	r8,4

80006c54 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c54:	d4 31       	pushm	r0-r7,lr
80006c56:	20 1d       	sub	sp,4
80006c58:	fa c4 ff d8 	sub	r4,sp,-40
80006c5c:	50 0c       	stdsp	sp[0x0],r12
80006c5e:	16 91       	mov	r1,r11
80006c60:	14 97       	mov	r7,r10
80006c62:	12 90       	mov	r0,r9
80006c64:	10 93       	mov	r3,r8
80006c66:	68 02       	ld.w	r2,r4[0x0]
80006c68:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c6a:	34 8c       	mov	r12,72
80006c6c:	f0 1f 00 5c 	mcall	80006ddc <xTaskGenericCreate+0x188>
80006c70:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c72:	c0 31       	brne	80006c78 <xTaskGenericCreate+0x24>
80006c74:	3f fc       	mov	r12,-1
80006c76:	ca f8       	rjmp	80006dd4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c78:	58 06       	cp.w	r6,0
80006c7a:	e0 81 00 af 	brne	80006dd8 <xTaskGenericCreate+0x184>
80006c7e:	0e 9c       	mov	r12,r7
80006c80:	5c 7c       	castu.h	r12
80006c82:	a3 6c       	lsl	r12,0x2
80006c84:	f0 1f 00 56 	mcall	80006ddc <xTaskGenericCreate+0x188>
80006c88:	18 96       	mov	r6,r12
80006c8a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c8c:	c0 61       	brne	80006c98 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c8e:	0a 9c       	mov	r12,r5
80006c90:	f0 1f 00 54 	mcall	80006de0 <xTaskGenericCreate+0x18c>
80006c94:	3f fc       	mov	r12,-1
80006c96:	c9 f8       	rjmp	80006dd4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c98:	5c 77       	castu.h	r7
80006c9a:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c9e:	e0 6b 00 a5 	mov	r11,165
80006ca2:	0c 9c       	mov	r12,r6
80006ca4:	f0 1f 00 50 	mcall	80006de4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006ca8:	ee c6 00 01 	sub	r6,r7,1
80006cac:	6a c8       	ld.w	r8,r5[0x30]
80006cae:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006cb2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006cb6:	31 0a       	mov	r10,16
80006cb8:	02 9b       	mov	r11,r1
80006cba:	ea cc ff cc 	sub	r12,r5,-52
80006cbe:	f0 1f 00 4b 	mcall	80006de8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006cc2:	30 08       	mov	r8,0
80006cc4:	eb 68 00 43 	st.b	r5[67],r8
80006cc8:	58 73       	cp.w	r3,7
80006cca:	e6 07 17 80 	movls	r7,r3
80006cce:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006cd2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006cd4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006cd8:	ea c4 ff fc 	sub	r4,r5,-4
80006cdc:	08 9c       	mov	r12,r4
80006cde:	f0 1f 00 44 	mcall	80006dec <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006ce2:	ea cc ff e8 	sub	r12,r5,-24
80006ce6:	f0 1f 00 42 	mcall	80006dec <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006cea:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006cec:	ee 07 11 08 	rsub	r7,r7,8
80006cf0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006cf2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006cf4:	00 9a       	mov	r10,r0
80006cf6:	40 0b       	lddsp	r11,sp[0x0]
80006cf8:	0c 9c       	mov	r12,r6
80006cfa:	f0 1f 00 3e 	mcall	80006df0 <xTaskGenericCreate+0x19c>
80006cfe:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006d00:	58 02       	cp.w	r2,0
80006d02:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006d06:	f0 1f 00 3c 	mcall	80006df4 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006d0a:	4b c8       	lddpc	r8,80006df8 <xTaskGenericCreate+0x1a4>
80006d0c:	70 09       	ld.w	r9,r8[0x0]
80006d0e:	2f f9       	sub	r9,-1
80006d10:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006d12:	4b b8       	lddpc	r8,80006dfc <xTaskGenericCreate+0x1a8>
80006d14:	70 08       	ld.w	r8,r8[0x0]
80006d16:	58 08       	cp.w	r8,0
80006d18:	c2 61       	brne	80006d64 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006d1a:	4b 98       	lddpc	r8,80006dfc <xTaskGenericCreate+0x1a8>
80006d1c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006d1e:	4b 78       	lddpc	r8,80006df8 <xTaskGenericCreate+0x1a4>
80006d20:	70 08       	ld.w	r8,r8[0x0]
80006d22:	58 18       	cp.w	r8,1
80006d24:	c2 b1       	brne	80006d7a <xTaskGenericCreate+0x126>
80006d26:	4b 77       	lddpc	r7,80006e00 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006d28:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006d2c:	0e 9c       	mov	r12,r7
80006d2e:	f0 1f 00 36 	mcall	80006e04 <xTaskGenericCreate+0x1b0>
80006d32:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d34:	0c 37       	cp.w	r7,r6
80006d36:	cf b1       	brne	80006d2c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d38:	4b 47       	lddpc	r7,80006e08 <xTaskGenericCreate+0x1b4>
80006d3a:	0e 9c       	mov	r12,r7
80006d3c:	f0 1f 00 32 	mcall	80006e04 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d40:	4b 36       	lddpc	r6,80006e0c <xTaskGenericCreate+0x1b8>
80006d42:	0c 9c       	mov	r12,r6
80006d44:	f0 1f 00 30 	mcall	80006e04 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d48:	4b 2c       	lddpc	r12,80006e10 <xTaskGenericCreate+0x1bc>
80006d4a:	f0 1f 00 2f 	mcall	80006e04 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d4e:	4b 2c       	lddpc	r12,80006e14 <xTaskGenericCreate+0x1c0>
80006d50:	f0 1f 00 2d 	mcall	80006e04 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d54:	4b 1c       	lddpc	r12,80006e18 <xTaskGenericCreate+0x1c4>
80006d56:	f0 1f 00 2c 	mcall	80006e04 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d5a:	4b 18       	lddpc	r8,80006e1c <xTaskGenericCreate+0x1c8>
80006d5c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d5e:	4b 18       	lddpc	r8,80006e20 <xTaskGenericCreate+0x1cc>
80006d60:	91 06       	st.w	r8[0x0],r6
80006d62:	c0 c8       	rjmp	80006d7a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d64:	4b 08       	lddpc	r8,80006e24 <xTaskGenericCreate+0x1d0>
80006d66:	70 08       	ld.w	r8,r8[0x0]
80006d68:	58 08       	cp.w	r8,0
80006d6a:	c0 81       	brne	80006d7a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d6c:	4a 48       	lddpc	r8,80006dfc <xTaskGenericCreate+0x1a8>
80006d6e:	70 08       	ld.w	r8,r8[0x0]
80006d70:	70 b8       	ld.w	r8,r8[0x2c]
80006d72:	10 33       	cp.w	r3,r8
80006d74:	c0 33       	brcs	80006d7a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d76:	4a 28       	lddpc	r8,80006dfc <xTaskGenericCreate+0x1a8>
80006d78:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d7a:	6a b8       	ld.w	r8,r5[0x2c]
80006d7c:	4a b9       	lddpc	r9,80006e28 <xTaskGenericCreate+0x1d4>
80006d7e:	72 09       	ld.w	r9,r9[0x0]
80006d80:	12 38       	cp.w	r8,r9
80006d82:	e0 88 00 04 	brls	80006d8a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d86:	4a 99       	lddpc	r9,80006e28 <xTaskGenericCreate+0x1d4>
80006d88:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d8a:	4a 98       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1d8>
80006d8c:	70 09       	ld.w	r9,r8[0x0]
80006d8e:	2f f9       	sub	r9,-1
80006d90:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d92:	6a b8       	ld.w	r8,r5[0x2c]
80006d94:	4a 79       	lddpc	r9,80006e30 <xTaskGenericCreate+0x1dc>
80006d96:	72 09       	ld.w	r9,r9[0x0]
80006d98:	12 38       	cp.w	r8,r9
80006d9a:	e0 88 00 04 	brls	80006da2 <xTaskGenericCreate+0x14e>
80006d9e:	4a 59       	lddpc	r9,80006e30 <xTaskGenericCreate+0x1dc>
80006da0:	93 08       	st.w	r9[0x0],r8
80006da2:	6a bc       	ld.w	r12,r5[0x2c]
80006da4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006da8:	08 9b       	mov	r11,r4
80006daa:	49 68       	lddpc	r8,80006e00 <xTaskGenericCreate+0x1ac>
80006dac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006db0:	f0 1f 00 21 	mcall	80006e34 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006db4:	f0 1f 00 21 	mcall	80006e38 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006db8:	49 b8       	lddpc	r8,80006e24 <xTaskGenericCreate+0x1d0>
80006dba:	70 08       	ld.w	r8,r8[0x0]
80006dbc:	58 08       	cp.w	r8,0
80006dbe:	c0 a0       	breq	80006dd2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006dc0:	48 f8       	lddpc	r8,80006dfc <xTaskGenericCreate+0x1a8>
80006dc2:	70 08       	ld.w	r8,r8[0x0]
80006dc4:	70 b8       	ld.w	r8,r8[0x2c]
80006dc6:	10 33       	cp.w	r3,r8
80006dc8:	e0 88 00 05 	brls	80006dd2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006dcc:	d7 33       	scall
80006dce:	30 1c       	mov	r12,1
80006dd0:	c0 28       	rjmp	80006dd4 <xTaskGenericCreate+0x180>
80006dd2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006dd4:	2f fd       	sub	sp,-4
80006dd6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006dd8:	99 c6       	st.w	r12[0x30],r6
80006dda:	c5 fb       	rjmp	80006c98 <xTaskGenericCreate+0x44>
80006ddc:	80 00       	ld.sh	r0,r0[0x0]
80006dde:	60 8c       	ld.w	r12,r0[0x20]
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	60 64       	ld.w	r4,r0[0x18]
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	79 dc       	ld.w	r12,r12[0x74]
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	7d 08       	ld.w	r8,lr[0x40]
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	5d 10       	icall	r0
80006df0:	80 00       	ld.sh	r0,r0[0x0]
80006df2:	5d 8c       	*unknown*
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	5e 20       	reths	r0
80006df8:	00 00       	add	r0,r0
80006dfa:	0d 40       	ld.w	r0,--r6
80006dfc:	00 00       	add	r0,r0
80006dfe:	0c f4       	st.b	--r6,r4
80006e00:	00 00       	add	r0,r0
80006e02:	0c 40       	or	r0,r6
80006e04:	80 00       	ld.sh	r0,r0[0x0]
80006e06:	5c fc       	rol	r12
80006e08:	00 00       	add	r0,r0
80006e0a:	0d 0c       	ld.w	r12,r6++
80006e0c:	00 00       	add	r0,r0
80006e0e:	0d 28       	ld.uh	r8,r6++
80006e10:	00 00       	add	r0,r0
80006e12:	0c f8       	st.b	--r6,r8
80006e14:	00 00       	add	r0,r0
80006e16:	0c e0       	st.h	--r6,r0
80006e18:	00 00       	add	r0,r0
80006e1a:	0d 48       	ld.w	r8,--r6
80006e1c:	00 00       	add	r0,r0
80006e1e:	0c 2c       	rsub	r12,r6
80006e20:	00 00       	add	r0,r0
80006e22:	0c 3c       	cp.w	r12,r6
80006e24:	00 00       	add	r0,r0
80006e26:	0c 30       	cp.w	r0,r6
80006e28:	00 00       	add	r0,r0
80006e2a:	0c 28       	rsub	r8,r6
80006e2c:	00 00       	add	r0,r0
80006e2e:	0d 3c       	ld.ub	r12,r6++
80006e30:	00 00       	add	r0,r0
80006e32:	0d 5c       	ld.sh	r12,--r6
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	5d 16       	icall	r6
80006e38:	80 00       	ld.sh	r0,r0[0x0]
80006e3a:	5f 2c       	srhs	r12

80006e3c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e3c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e3e:	30 09       	mov	r9,0
80006e40:	1a d9       	st.w	--sp,r9
80006e42:	1a d9       	st.w	--sp,r9
80006e44:	1a d9       	st.w	--sp,r9
80006e46:	12 98       	mov	r8,r9
80006e48:	e0 6a 01 00 	mov	r10,256
80006e4c:	48 9b       	lddpc	r11,80006e70 <vTaskStartScheduler+0x34>
80006e4e:	48 ac       	lddpc	r12,80006e74 <vTaskStartScheduler+0x38>
80006e50:	f0 1f 00 0a 	mcall	80006e78 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e54:	2f dd       	sub	sp,-12
80006e56:	58 1c       	cp.w	r12,1
80006e58:	c0 a1       	brne	80006e6c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e5a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e5c:	30 19       	mov	r9,1
80006e5e:	48 88       	lddpc	r8,80006e7c <vTaskStartScheduler+0x40>
80006e60:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e62:	30 09       	mov	r9,0
80006e64:	48 78       	lddpc	r8,80006e80 <vTaskStartScheduler+0x44>
80006e66:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e68:	f0 1f 00 07 	mcall	80006e84 <vTaskStartScheduler+0x48>
80006e6c:	d8 02       	popm	pc
80006e6e:	00 00       	add	r0,r0
80006e70:	80 00       	ld.sh	r0,r0[0x0]
80006e72:	da 18       	*unknown*
80006e74:	80 00       	ld.sh	r0,r0[0x0]
80006e76:	6b cc       	ld.w	r12,r5[0x70]
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	6c 54       	ld.w	r4,r6[0x14]
80006e7c:	00 00       	add	r0,r0
80006e7e:	0c 30       	cp.w	r0,r6
80006e80:	00 00       	add	r0,r0
80006e82:	0d 20       	ld.uh	r0,r6++
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	5e 30       	retlo	r0

80006e88 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e88:	16 cc       	st.b	r11++,r12
	return str;
}
80006e8a:	5e fb       	retal	r11

80006e8c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e8c:	eb cd 40 c0 	pushm	r6-r7,lr
80006e90:	20 3d       	sub	sp,12
80006e92:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e94:	30 06       	mov	r6,0
80006e96:	30 07       	mov	r7,0
80006e98:	fa e7 00 00 	st.d	sp[0],r6
80006e9c:	30 0c       	mov	r12,0
80006e9e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006ea0:	58 08       	cp.w	r8,0
80006ea2:	c1 30       	breq	80006ec8 <PrintHex+0x3c>
80006ea4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006ea6:	1a 9c       	mov	r12,sp
80006ea8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006eac:	58 9e       	cp.w	lr,9
80006eae:	e0 8a 00 04 	brle	80006eb6 <PrintHex+0x2a>
80006eb2:	2c 9e       	sub	lr,-55
80006eb4:	c0 48       	rjmp	80006ebc <PrintHex+0x30>
80006eb6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006eba:	2d 0e       	sub	lr,-48
80006ebc:	f8 09 0b 0e 	st.b	r12[r9],lr
80006ec0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006ec2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006ec4:	cf 21       	brne	80006ea8 <PrintHex+0x1c>
80006ec6:	c0 48       	rjmp	80006ece <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006ec8:	33 08       	mov	r8,48
80006eca:	ba 88       	st.b	sp[0x0],r8
80006ecc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006ece:	f6 09 01 08 	sub	r8,r11,r9
80006ed2:	58 08       	cp.w	r8,0
80006ed4:	e0 8a 00 13 	brle	80006efa <PrintHex+0x6e>
	{
		char num = len - cnt;
80006ed8:	12 1b       	sub	r11,r9
80006eda:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006ede:	18 9e       	mov	lr,r12
80006ee0:	58 0c       	cp.w	r12,0
80006ee2:	e0 8a 00 0c 	brle	80006efa <PrintHex+0x6e>
80006ee6:	1a 9b       	mov	r11,sp
80006ee8:	12 0b       	add	r11,r9
80006eea:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006eec:	33 07       	mov	r7,48
80006eee:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ef0:	2f f8       	sub	r8,-1
80006ef2:	1c 38       	cp.w	r8,lr
80006ef4:	cf d5       	brlt	80006eee <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ef6:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006efa:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006efe:	f0 cb ff ff 	sub	r11,r8,-1
80006f02:	58 0b       	cp.w	r11,0
80006f04:	e0 8a 00 19 	brle	80006f36 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f08:	fa cb ff f4 	sub	r11,sp,-12
80006f0c:	f6 09 00 09 	add	r9,r11,r9
80006f10:	37 8b       	mov	r11,120
80006f12:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006f16:	fa c9 ff f4 	sub	r9,sp,-12
80006f1a:	10 09       	add	r9,r8
80006f1c:	33 0b       	mov	r11,48
80006f1e:	f3 6b ff f4 	st.b	r9[-12],r11
80006f22:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f26:	fa ce 00 01 	sub	lr,sp,1
80006f2a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f2c:	11 8b       	ld.ub	r11,r8[0x0]
80006f2e:	12 cb       	st.b	r9++,r11
80006f30:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006f32:	1c 38       	cp.w	r8,lr
80006f34:	cf c1       	brne	80006f2c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f36:	14 9c       	mov	r12,r10
80006f38:	2f dd       	sub	sp,-12
80006f3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f3e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f3e:	d4 21       	pushm	r4-r7,lr
80006f40:	20 3d       	sub	sp,12
80006f42:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f44:	30 06       	mov	r6,0
80006f46:	30 07       	mov	r7,0
80006f48:	fa e7 00 00 	st.d	sp[0],r6
80006f4c:	30 0c       	mov	r12,0
80006f4e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f50:	58 08       	cp.w	r8,0
80006f52:	c0 35       	brlt	80006f58 <PrintDec+0x1a>
80006f54:	14 97       	mov	r7,r10
80006f56:	c0 58       	rjmp	80006f60 <PrintDec+0x22>
	{
		*p++ = '-';
80006f58:	14 97       	mov	r7,r10
80006f5a:	32 d9       	mov	r9,45
80006f5c:	0e c9       	st.b	r7++,r9
		i = -i;
80006f5e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f60:	58 08       	cp.w	r8,0
80006f62:	c0 51       	brne	80006f6c <PrintDec+0x2e>
80006f64:	33 08       	mov	r8,48
80006f66:	ba 88       	st.b	sp[0x0],r8
80006f68:	30 1e       	mov	lr,1
80006f6a:	c2 f8       	rjmp	80006fc8 <PrintDec+0x8a>
	
	int ten = i%10;
80006f6c:	e0 65 66 67 	mov	r5,26215
80006f70:	ea 15 66 66 	orh	r5,0x6666
80006f74:	f0 05 04 44 	muls.d	r4,r8,r5
80006f78:	ea 0c 14 02 	asr	r12,r5,0x2
80006f7c:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f80:	f8 09 01 09 	sub	r9,r12,r9
80006f84:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f88:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f8c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f8e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f90:	e0 66 66 67 	mov	r6,26215
80006f94:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f98:	2d 09       	sub	r9,-48
80006f9a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f9e:	2f fe       	sub	lr,-1
		i /= 10;
80006fa0:	f0 06 04 44 	muls.d	r4,r8,r6
80006fa4:	ea 09 14 02 	asr	r9,r5,0x2
80006fa8:	bf 58       	asr	r8,0x1f
80006faa:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006fae:	f0 06 04 44 	muls.d	r4,r8,r6
80006fb2:	ea 09 14 02 	asr	r9,r5,0x2
80006fb6:	f0 05 14 1f 	asr	r5,r8,0x1f
80006fba:	0a 19       	sub	r9,r5
80006fbc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fc0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006fc4:	58 08       	cp.w	r8,0
80006fc6:	ce 91       	brne	80006f98 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006fc8:	f6 0e 01 08 	sub	r8,r11,lr
80006fcc:	58 08       	cp.w	r8,0
80006fce:	e0 89 00 06 	brgt	80006fda <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fd2:	58 0e       	cp.w	lr,0
80006fd4:	e0 89 00 14 	brgt	80006ffc <PrintDec+0xbe>
80006fd8:	c1 d8       	rjmp	80007012 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006fda:	1c 1b       	sub	r11,lr
80006fdc:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006fde:	16 9c       	mov	r12,r11
80006fe0:	58 0b       	cp.w	r11,0
80006fe2:	fe 9a ff f8 	brle	80006fd2 <PrintDec+0x94>
80006fe6:	1a 99       	mov	r9,sp
80006fe8:	1c 09       	add	r9,lr
80006fea:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fec:	33 06       	mov	r6,48
80006fee:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ff0:	2f f8       	sub	r8,-1
80006ff2:	18 38       	cp.w	r8,r12
80006ff4:	cf d5       	brlt	80006fee <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006ff6:	f6 0e 00 0e 	add	lr,r11,lr
80006ffa:	ce cb       	rjmp	80006fd2 <PrintDec+0x94>
80006ffc:	fa c8 ff f4 	sub	r8,sp,-12
80007000:	1c 08       	add	r8,lr
80007002:	20 d8       	sub	r8,13
80007004:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007008:	11 89       	ld.ub	r9,r8[0x0]
8000700a:	0e c9       	st.b	r7++,r9
8000700c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000700e:	16 38       	cp.w	r8,r11
80007010:	cf c1       	brne	80007008 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007012:	14 9c       	mov	r12,r10
80007014:	2f dd       	sub	sp,-12
80007016:	d8 22       	popm	r4-r7,pc

80007018 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007018:	d4 31       	pushm	r0-r7,lr
8000701a:	fa cd 02 08 	sub	sp,sp,520
8000701e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007020:	e0 6a 01 00 	mov	r10,256
80007024:	30 0b       	mov	r11,0
80007026:	fa cc fe f8 	sub	r12,sp,-264
8000702a:	f0 1f 00 4e 	mcall	80007160 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000702e:	fa c4 fd d4 	sub	r4,sp,-556
80007032:	30 0a       	mov	r10,0
80007034:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007036:	fa c3 ff fc 	sub	r3,sp,-4
8000703a:	e0 61 01 00 	mov	r1,256
8000703e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007040:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007042:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007046:	02 9a       	mov	r10,r1
80007048:	00 9b       	mov	r11,r0
8000704a:	06 9c       	mov	r12,r3
8000704c:	f0 1f 00 45 	mcall	80007160 <log+0x148>
			
					if(*str == '%')
80007050:	0f 88       	ld.ub	r8,r7[0x0]
80007052:	e4 08 18 00 	cp.b	r8,r2
80007056:	c5 71       	brne	80007104 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007058:	ee c8 ff ff 	sub	r8,r7,-1
8000705c:	11 89       	ld.ub	r9,r8[0x0]
8000705e:	4c 2a       	lddpc	r10,80007164 <log+0x14c>
80007060:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007062:	23 09       	sub	r9,48
80007064:	30 9a       	mov	r10,9
80007066:	f4 09 18 00 	cp.b	r9,r10
8000706a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000706e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007072:	f7 b9 08 30 	subls	r9,48
80007076:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000707a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000707e:	0f 88       	ld.ub	r8,r7[0x0]
80007080:	22 58       	sub	r8,37
80007082:	e0 48 00 53 	cp.w	r8,83
80007086:	e0 8b 00 31 	brhi	800070e8 <log+0xd0>
8000708a:	4b 89       	lddpc	r9,80007168 <log+0x150>
8000708c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007090:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007094:	06 9a       	mov	r10,r3
80007096:	40 0b       	lddsp	r11,sp[0x0]
80007098:	5c 5b       	castu.b	r11
8000709a:	68 0c       	ld.w	r12,r4[0x0]
8000709c:	f0 1f 00 34 	mcall	8000716c <log+0x154>
							break;
800070a0:	c2 98       	rjmp	800070f2 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800070a2:	4b 4c       	lddpc	r12,80007170 <log+0x158>
800070a4:	f0 1f 00 34 	mcall	80007174 <log+0x15c>
800070a8:	08 95       	mov	r5,r4
800070aa:	06 9c       	mov	r12,r3
							break;
800070ac:	c2 38       	rjmp	800070f2 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800070ae:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800070b2:	06 9a       	mov	r10,r3
800070b4:	40 0b       	lddsp	r11,sp[0x0]
800070b6:	5c 5b       	castu.b	r11
800070b8:	68 0c       	ld.w	r12,r4[0x0]
800070ba:	f0 1f 00 30 	mcall	80007178 <log+0x160>
800070be:	06 9c       	mov	r12,r3
							break;
800070c0:	c1 98       	rjmp	800070f2 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800070c2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800070c6:	06 9b       	mov	r11,r3
800070c8:	09 bc       	ld.ub	r12,r4[0x3]
800070ca:	f0 1f 00 2d 	mcall	8000717c <log+0x164>
800070ce:	06 9c       	mov	r12,r3
							break;
800070d0:	c1 18       	rjmp	800070f2 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800070d2:	e8 c5 ff fc 	sub	r5,r4,-4
800070d6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800070d8:	c0 d8       	rjmp	800070f2 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800070da:	06 9b       	mov	r11,r3
800070dc:	32 5c       	mov	r12,37
800070de:	f0 1f 00 28 	mcall	8000717c <log+0x164>
800070e2:	08 95       	mov	r5,r4
800070e4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800070e6:	c0 68       	rjmp	800070f2 <log+0xda>
							
							default:
							log("I need relax.");
800070e8:	4a 6c       	lddpc	r12,80007180 <log+0x168>
800070ea:	f0 1f 00 23 	mcall	80007174 <log+0x15c>
800070ee:	08 95       	mov	r5,r4
800070f0:	06 9c       	mov	r12,r3
						}
						str++;
800070f2:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070f4:	1a dc       	st.w	--sp,r12
800070f6:	1a d6       	st.w	--sp,r6
800070f8:	4a 3b       	lddpc	r11,80007184 <log+0x16c>
800070fa:	0c 9c       	mov	r12,r6
800070fc:	f0 1f 00 23 	mcall	80007188 <log+0x170>
80007100:	2f ed       	sub	sp,-8
80007102:	c0 a8       	rjmp	80007116 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007104:	2f f7       	sub	r7,-1
80007106:	1a d8       	st.w	--sp,r8
80007108:	1a d6       	st.w	--sp,r6
8000710a:	4a 1b       	lddpc	r11,8000718c <log+0x174>
8000710c:	0c 9c       	mov	r12,r6
8000710e:	f0 1f 00 1f 	mcall	80007188 <log+0x170>
80007112:	08 95       	mov	r5,r4
80007114:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007116:	0f 89       	ld.ub	r9,r7[0x0]
80007118:	30 08       	mov	r8,0
8000711a:	f0 09 18 00 	cp.b	r9,r8
8000711e:	c0 30       	breq	80007124 <log+0x10c>
80007120:	0a 94       	mov	r4,r5
80007122:	c9 2b       	rjmp	80007046 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007124:	fa c7 fe f8 	sub	r7,sp,-264
80007128:	1a d7       	st.w	--sp,r7
8000712a:	49 ab       	lddpc	r11,80007190 <log+0x178>
8000712c:	0e 9c       	mov	r12,r7
8000712e:	f0 1f 00 17 	mcall	80007188 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007132:	5c 5c       	castu.b	r12
80007134:	f8 c6 ff ff 	sub	r6,r12,-1
80007138:	0c 9c       	mov	r12,r6
8000713a:	f0 1f 00 17 	mcall	80007194 <log+0x17c>
8000713e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007140:	0c 9a       	mov	r10,r6
80007142:	0e 9b       	mov	r11,r7
80007144:	f0 1f 00 15 	mcall	80007198 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007148:	30 09       	mov	r9,0
8000714a:	30 5a       	mov	r10,5
8000714c:	fa cb fe f8 	sub	r11,sp,-264
80007150:	49 38       	lddpc	r8,8000719c <log+0x184>
80007152:	70 0c       	ld.w	r12,r8[0x0]
80007154:	f0 1f 00 13 	mcall	800071a0 <log+0x188>
80007158:	2f fd       	sub	sp,-4
	
	
}
8000715a:	fe 3d fd f8 	sub	sp,-520
8000715e:	d8 32       	popm	r0-r7,pc
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	79 dc       	ld.w	r12,r12[0x74]
80007164:	00 00       	add	r0,r0
80007166:	0d 60       	ld.uh	r0,--r6
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	da 20       	acall	0xa2
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	6f 3e       	ld.w	lr,r7[0x4c]
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	dc cc       	*unknown*
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	70 18       	ld.w	r8,r8[0x4]
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	6e 8c       	ld.w	r12,r7[0x20]
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	6e 88       	ld.w	r8,r7[0x20]
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	dc dc       	*unknown*
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	dc ec       	*unknown*
80007188:	80 00       	ld.sh	r0,r0[0x0]
8000718a:	7c cc       	ld.w	r12,lr[0x30]
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	dc f4       	*unknown*
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	dc fc       	*unknown*
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	60 8c       	ld.w	r12,r0[0x20]
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	78 94       	ld.w	r4,r12[0x24]
8000719c:	00 00       	add	r0,r0
8000719e:	bf f4       	*unknown*
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	63 e0       	ld.w	r0,r1[0x78]

800071a4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800071a4:	d4 31       	pushm	r0-r7,lr
800071a6:	fa cd 02 0c 	sub	sp,sp,524
800071aa:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800071ac:	e0 6a 01 00 	mov	r10,256
800071b0:	30 0b       	mov	r11,0
800071b2:	fa cc fe f4 	sub	r12,sp,-268
800071b6:	f0 1f 00 4c 	mcall	800072e4 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800071ba:	fa c4 fd d0 	sub	r4,sp,-560
800071be:	30 0a       	mov	r10,0
800071c0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800071c2:	fa c3 ff fc 	sub	r3,sp,-4
800071c6:	e0 61 01 00 	mov	r1,256
800071ca:	14 90       	mov	r0,r10
			
			if(*str == '%')
800071cc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071ce:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800071d2:	02 9a       	mov	r10,r1
800071d4:	00 9b       	mov	r11,r0
800071d6:	06 9c       	mov	r12,r3
800071d8:	f0 1f 00 43 	mcall	800072e4 <logFromISR+0x140>
			
			if(*str == '%')
800071dc:	0f 88       	ld.ub	r8,r7[0x0]
800071de:	e4 08 18 00 	cp.b	r8,r2
800071e2:	c5 11       	brne	80007284 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800071e4:	ee c8 ff ff 	sub	r8,r7,-1
800071e8:	11 89       	ld.ub	r9,r8[0x0]
800071ea:	4c 0a       	lddpc	r10,800072e8 <logFromISR+0x144>
800071ec:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800071ee:	23 09       	sub	r9,48
800071f0:	30 9a       	mov	r10,9
800071f2:	f4 09 18 00 	cp.b	r9,r10
800071f6:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071fa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071fe:	f7 b9 08 30 	subls	r9,48
80007202:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007206:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000720a:	0f 88       	ld.ub	r8,r7[0x0]
8000720c:	22 58       	sub	r8,37
8000720e:	e0 48 00 53 	cp.w	r8,83
80007212:	e0 8b 00 2b 	brhi	80007268 <logFromISR+0xc4>
80007216:	4b 69       	lddpc	r9,800072ec <logFromISR+0x148>
80007218:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000721c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007220:	06 9a       	mov	r10,r3
80007222:	40 0b       	lddsp	r11,sp[0x0]
80007224:	5c 5b       	castu.b	r11
80007226:	68 0c       	ld.w	r12,r4[0x0]
80007228:	f0 1f 00 32 	mcall	800072f0 <logFromISR+0x14c>
					break;
8000722c:	c2 38       	rjmp	80007272 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000722e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007232:	06 9a       	mov	r10,r3
80007234:	40 0b       	lddsp	r11,sp[0x0]
80007236:	5c 5b       	castu.b	r11
80007238:	68 0c       	ld.w	r12,r4[0x0]
8000723a:	f0 1f 00 2f 	mcall	800072f4 <logFromISR+0x150>
8000723e:	06 9c       	mov	r12,r3
					break;
80007240:	c1 98       	rjmp	80007272 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007242:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007246:	06 9b       	mov	r11,r3
80007248:	09 bc       	ld.ub	r12,r4[0x3]
8000724a:	f0 1f 00 2c 	mcall	800072f8 <logFromISR+0x154>
8000724e:	06 9c       	mov	r12,r3
					break;
80007250:	c1 18       	rjmp	80007272 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007252:	e8 c5 ff fc 	sub	r5,r4,-4
80007256:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007258:	c0 d8       	rjmp	80007272 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000725a:	06 9b       	mov	r11,r3
8000725c:	32 5c       	mov	r12,37
8000725e:	f0 1f 00 27 	mcall	800072f8 <logFromISR+0x154>
80007262:	08 95       	mov	r5,r4
80007264:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007266:	c0 68       	rjmp	80007272 <logFromISR+0xce>
					default:
					log("I need relax.");
80007268:	4a 5c       	lddpc	r12,800072fc <logFromISR+0x158>
8000726a:	f0 1f 00 26 	mcall	80007300 <logFromISR+0x15c>
8000726e:	08 95       	mov	r5,r4
80007270:	06 9c       	mov	r12,r3
				}
				str++;
80007272:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007274:	1a dc       	st.w	--sp,r12
80007276:	1a d6       	st.w	--sp,r6
80007278:	4a 3b       	lddpc	r11,80007304 <logFromISR+0x160>
8000727a:	0c 9c       	mov	r12,r6
8000727c:	f0 1f 00 23 	mcall	80007308 <logFromISR+0x164>
80007280:	2f ed       	sub	sp,-8
80007282:	c0 a8       	rjmp	80007296 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007284:	2f f7       	sub	r7,-1
80007286:	1a d8       	st.w	--sp,r8
80007288:	1a d6       	st.w	--sp,r6
8000728a:	4a 1b       	lddpc	r11,8000730c <logFromISR+0x168>
8000728c:	0c 9c       	mov	r12,r6
8000728e:	f0 1f 00 1f 	mcall	80007308 <logFromISR+0x164>
80007292:	08 95       	mov	r5,r4
80007294:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007296:	0f 89       	ld.ub	r9,r7[0x0]
80007298:	30 08       	mov	r8,0
8000729a:	f0 09 18 00 	cp.b	r9,r8
8000729e:	c0 30       	breq	800072a4 <logFromISR+0x100>
800072a0:	0a 94       	mov	r4,r5
800072a2:	c9 8b       	rjmp	800071d2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800072a4:	fa c7 fe f4 	sub	r7,sp,-268
800072a8:	1a d7       	st.w	--sp,r7
800072aa:	49 ab       	lddpc	r11,80007310 <logFromISR+0x16c>
800072ac:	0e 9c       	mov	r12,r7
800072ae:	f0 1f 00 17 	mcall	80007308 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800072b2:	5c 5c       	castu.b	r12
800072b4:	f8 c6 ff ff 	sub	r6,r12,-1
800072b8:	0c 9c       	mov	r12,r6
800072ba:	f0 1f 00 17 	mcall	80007314 <logFromISR+0x170>
800072be:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800072c0:	0c 9a       	mov	r10,r6
800072c2:	0e 9b       	mov	r11,r7
800072c4:	f0 1f 00 15 	mcall	80007318 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800072c8:	30 09       	mov	r9,0
800072ca:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800072cc:	fa ca fe f8 	sub	r10,sp,-264
800072d0:	fa cb fe f4 	sub	r11,sp,-268
800072d4:	49 28       	lddpc	r8,8000731c <logFromISR+0x178>
800072d6:	70 0c       	ld.w	r12,r8[0x0]
800072d8:	f0 1f 00 12 	mcall	80007320 <logFromISR+0x17c>
800072dc:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800072de:	fe 3d fd f4 	sub	sp,-524
800072e2:	d8 32       	popm	r0-r7,pc
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	79 dc       	ld.w	r12,r12[0x74]
800072e8:	00 00       	add	r0,r0
800072ea:	0d 61       	ld.uh	r1,--r6
800072ec:	80 00       	ld.sh	r0,r0[0x0]
800072ee:	db 70       	acall	0xb7
800072f0:	80 00       	ld.sh	r0,r0[0x0]
800072f2:	6f 3e       	ld.w	lr,r7[0x4c]
800072f4:	80 00       	ld.sh	r0,r0[0x0]
800072f6:	6e 8c       	ld.w	r12,r7[0x20]
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	6e 88       	ld.w	r8,r7[0x20]
800072fc:	80 00       	ld.sh	r0,r0[0x0]
800072fe:	dc dc       	*unknown*
80007300:	80 00       	ld.sh	r0,r0[0x0]
80007302:	70 18       	ld.w	r8,r8[0x4]
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	dc ec       	*unknown*
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	7c cc       	ld.w	r12,lr[0x30]
8000730c:	80 00       	ld.sh	r0,r0[0x0]
8000730e:	dc f4       	*unknown*
80007310:	80 00       	ld.sh	r0,r0[0x0]
80007312:	dc fc       	*unknown*
80007314:	80 00       	ld.sh	r0,r0[0x0]
80007316:	60 8c       	ld.w	r12,r0[0x20]
80007318:	80 00       	ld.sh	r0,r0[0x0]
8000731a:	78 94       	ld.w	r4,r12[0x24]
8000731c:	00 00       	add	r0,r0
8000731e:	bf f4       	*unknown*
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	63 90       	ld.w	r0,r1[0x64]

80007324 <log_init>:
		
	return str;
}

void log_init(void)
{
80007324:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007326:	30 2b       	mov	r11,2
80007328:	48 fc       	lddpc	r12,80007364 <log_init+0x40>
8000732a:	f0 1f 00 10 	mcall	80007368 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000732e:	e0 6a 36 00 	mov	r10,13824
80007332:	ea 1a 01 6e 	orh	r10,0x16e
80007336:	48 eb       	lddpc	r11,8000736c <log_init+0x48>
80007338:	fe 7c 18 00 	mov	r12,-59392
8000733c:	f0 1f 00 0d 	mcall	80007370 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007340:	30 4b       	mov	r11,4
80007342:	33 2c       	mov	r12,50
80007344:	f0 1f 00 0c 	mcall	80007374 <log_init+0x50>
80007348:	48 c8       	lddpc	r8,80007378 <log_init+0x54>
8000734a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000734c:	30 09       	mov	r9,0
8000734e:	1a d9       	st.w	--sp,r9
80007350:	1a d9       	st.w	--sp,r9
80007352:	1a d9       	st.w	--sp,r9
80007354:	30 28       	mov	r8,2
80007356:	36 4a       	mov	r10,100
80007358:	48 9b       	lddpc	r11,8000737c <log_init+0x58>
8000735a:	48 ac       	lddpc	r12,80007380 <log_init+0x5c>
8000735c:	f0 1f 00 0a 	mcall	80007384 <log_init+0x60>
80007360:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007362:	d8 02       	popm	pc
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	dd 08       	*unknown*
80007368:	80 00       	ld.sh	r0,r0[0x0]
8000736a:	55 6c       	stdsp	sp[0x158],r12
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	dc c0       	acall	0xcc
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	5b f0       	cp.w	r0,-1
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	65 38       	ld.w	r8,r2[0x4c]
80007378:	00 00       	add	r0,r0
8000737a:	bf f4       	*unknown*
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	dd 04       	*unknown*
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	73 88       	ld.w	r8,r9[0x60]
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	6c 54       	ld.w	r4,r6[0x14]

80007388 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007388:	eb cd 40 f8 	pushm	r3-r7,lr
8000738c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000738e:	48 c7       	lddpc	r7,800073bc <task_log+0x34>
80007390:	30 05       	mov	r5,0
80007392:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007394:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007398:	0a 99       	mov	r9,r5
8000739a:	08 9a       	mov	r10,r4
8000739c:	1a 9b       	mov	r11,sp
8000739e:	6e 0c       	ld.w	r12,r7[0x0]
800073a0:	f0 1f 00 08 	mcall	800073c0 <task_log+0x38>
800073a4:	58 1c       	cp.w	r12,1
800073a6:	cf 91       	brne	80007398 <task_log+0x10>
		{
			if( NULL != str)
800073a8:	40 0b       	lddsp	r11,sp[0x0]
800073aa:	58 0b       	cp.w	r11,0
800073ac:	cf 60       	breq	80007398 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800073ae:	06 9c       	mov	r12,r3
800073b0:	f0 1f 00 05 	mcall	800073c4 <task_log+0x3c>
				vPortFree(str);
800073b4:	40 0c       	lddsp	r12,sp[0x0]
800073b6:	f0 1f 00 05 	mcall	800073c8 <task_log+0x40>
800073ba:	ce fb       	rjmp	80007398 <task_log+0x10>
800073bc:	00 00       	add	r0,r0
800073be:	bf f4       	*unknown*
800073c0:	80 00       	ld.sh	r0,r0[0x0]
800073c2:	61 d4       	ld.w	r4,r0[0x74]
800073c4:	80 00       	ld.sh	r0,r0[0x0]
800073c6:	5b a0       	cp.w	r0,-6
800073c8:	80 00       	ld.sh	r0,r0[0x0]
800073ca:	60 64       	ld.w	r4,r0[0x18]

800073cc <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800073cc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800073ce:	fe 78 10 00 	mov	r8,-61440
800073d2:	30 19       	mov	r9,1
800073d4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800073d8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800073dc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800073e0:	d3 03       	ssrf	0x10
	local_start_pll0();
800073e2:	f0 1f 00 0c 	mcall	80007410 <main+0x44>
		
	INTC_init_interrupts();
800073e6:	f0 1f 00 0c 	mcall	80007414 <main+0x48>
		
	log_init();
800073ea:	f0 1f 00 0c 	mcall	80007418 <main+0x4c>
	log("----start debug----");
800073ee:	48 cc       	lddpc	r12,8000741c <main+0x50>
800073f0:	f0 1f 00 0c 	mcall	80007420 <main+0x54>
	
	xg_flashc_init();
800073f4:	f0 1f 00 0c 	mcall	80007424 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073f8:	f0 1f 00 0c 	mcall	80007428 <main+0x5c>
		
	app_init();
800073fc:	f0 1f 00 0c 	mcall	8000742c <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007400:	f0 1f 00 0c 	mcall	80007430 <main+0x64>

	local_start_timer();
80007404:	f0 1f 00 0c 	mcall	80007434 <main+0x68>
		
	vTaskStartScheduler();
80007408:	f0 1f 00 0c 	mcall	80007438 <main+0x6c>
	return 0;
	
}
8000740c:	d8 0a       	popm	pc,r12=0
8000740e:	00 00       	add	r0,r0
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	53 e8       	stdsp	sp[0xf8],r8
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	56 70       	stdsp	sp[0x19c],r0
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	73 24       	ld.w	r4,r9[0x48]
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	dd 18       	*unknown*
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	70 18       	ld.w	r8,r8[0x4]
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	54 7c       	stdsp	sp[0x11c],r12
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	53 48       	stdsp	sp[0xd0],r8
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	27 44       	sub	r4,116
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	41 4c       	lddsp	r12,sp[0x50]
80007434:	80 00       	ld.sh	r0,r0[0x0]
80007436:	53 bc       	stdsp	sp[0xec],r12
80007438:	80 00       	ld.sh	r0,r0[0x0]
8000743a:	6e 3c       	ld.w	r12,r7[0xc]

8000743c <free>:
8000743c:	d4 01       	pushm	lr
8000743e:	e0 68 0a 3c 	mov	r8,2620
80007442:	18 9b       	mov	r11,r12
80007444:	70 0c       	ld.w	r12,r8[0x0]
80007446:	e0 a0 1e 61 	rcall	8000b108 <_free_r>
8000744a:	d8 02       	popm	pc

8000744c <malloc>:
8000744c:	d4 01       	pushm	lr
8000744e:	e0 68 0a 3c 	mov	r8,2620
80007452:	18 9b       	mov	r11,r12
80007454:	70 0c       	ld.w	r12,r8[0x0]
80007456:	c0 3c       	rcall	8000745c <_malloc_r>
80007458:	d8 02       	popm	pc
8000745a:	d7 03       	nop

8000745c <_malloc_r>:
8000745c:	d4 31       	pushm	r0-r7,lr
8000745e:	f6 c8 ff f5 	sub	r8,r11,-11
80007462:	18 95       	mov	r5,r12
80007464:	10 97       	mov	r7,r8
80007466:	e0 17 ff f8 	andl	r7,0xfff8
8000746a:	59 68       	cp.w	r8,22
8000746c:	f9 b7 08 10 	movls	r7,16
80007470:	16 37       	cp.w	r7,r11
80007472:	5f 38       	srlo	r8
80007474:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007478:	c0 50       	breq	80007482 <_malloc_r+0x26>
8000747a:	30 c8       	mov	r8,12
8000747c:	99 38       	st.w	r12[0xc],r8
8000747e:	e0 8f 01 fa 	bral	80007872 <_malloc_r+0x416>
80007482:	fe b0 f5 a7 	rcall	80005fd0 <__malloc_lock>
80007486:	e0 47 01 f7 	cp.w	r7,503
8000748a:	e0 8b 00 1d 	brhi	800074c4 <_malloc_r+0x68>
8000748e:	ee 03 16 03 	lsr	r3,r7,0x3
80007492:	e0 68 05 3c 	mov	r8,1340
80007496:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000749a:	70 36       	ld.w	r6,r8[0xc]
8000749c:	10 36       	cp.w	r6,r8
8000749e:	c0 61       	brne	800074aa <_malloc_r+0x4e>
800074a0:	ec c8 ff f8 	sub	r8,r6,-8
800074a4:	70 36       	ld.w	r6,r8[0xc]
800074a6:	10 36       	cp.w	r6,r8
800074a8:	c0 c0       	breq	800074c0 <_malloc_r+0x64>
800074aa:	6c 18       	ld.w	r8,r6[0x4]
800074ac:	e0 18 ff fc 	andl	r8,0xfffc
800074b0:	6c 3a       	ld.w	r10,r6[0xc]
800074b2:	ec 08 00 09 	add	r9,r6,r8
800074b6:	0a 9c       	mov	r12,r5
800074b8:	6c 28       	ld.w	r8,r6[0x8]
800074ba:	95 28       	st.w	r10[0x8],r8
800074bc:	91 3a       	st.w	r8[0xc],r10
800074be:	c4 78       	rjmp	8000754c <_malloc_r+0xf0>
800074c0:	2f e3       	sub	r3,-2
800074c2:	c4 d8       	rjmp	8000755c <_malloc_r+0x100>
800074c4:	ee 03 16 09 	lsr	r3,r7,0x9
800074c8:	c0 41       	brne	800074d0 <_malloc_r+0x74>
800074ca:	ee 03 16 03 	lsr	r3,r7,0x3
800074ce:	c2 68       	rjmp	8000751a <_malloc_r+0xbe>
800074d0:	58 43       	cp.w	r3,4
800074d2:	e0 8b 00 06 	brhi	800074de <_malloc_r+0x82>
800074d6:	ee 03 16 06 	lsr	r3,r7,0x6
800074da:	2c 83       	sub	r3,-56
800074dc:	c1 f8       	rjmp	8000751a <_malloc_r+0xbe>
800074de:	59 43       	cp.w	r3,20
800074e0:	e0 8b 00 04 	brhi	800074e8 <_malloc_r+0x8c>
800074e4:	2a 53       	sub	r3,-91
800074e6:	c1 a8       	rjmp	8000751a <_malloc_r+0xbe>
800074e8:	e0 43 00 54 	cp.w	r3,84
800074ec:	e0 8b 00 06 	brhi	800074f8 <_malloc_r+0x9c>
800074f0:	ee 03 16 0c 	lsr	r3,r7,0xc
800074f4:	29 23       	sub	r3,-110
800074f6:	c1 28       	rjmp	8000751a <_malloc_r+0xbe>
800074f8:	e0 43 01 54 	cp.w	r3,340
800074fc:	e0 8b 00 06 	brhi	80007508 <_malloc_r+0xac>
80007500:	ee 03 16 0f 	lsr	r3,r7,0xf
80007504:	28 93       	sub	r3,-119
80007506:	c0 a8       	rjmp	8000751a <_malloc_r+0xbe>
80007508:	e0 43 05 54 	cp.w	r3,1364
8000750c:	e0 88 00 04 	brls	80007514 <_malloc_r+0xb8>
80007510:	37 e3       	mov	r3,126
80007512:	c0 48       	rjmp	8000751a <_malloc_r+0xbe>
80007514:	ee 03 16 12 	lsr	r3,r7,0x12
80007518:	28 43       	sub	r3,-124
8000751a:	e0 6a 05 3c 	mov	r10,1340
8000751e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007522:	74 36       	ld.w	r6,r10[0xc]
80007524:	c1 98       	rjmp	80007556 <_malloc_r+0xfa>
80007526:	6c 19       	ld.w	r9,r6[0x4]
80007528:	e0 19 ff fc 	andl	r9,0xfffc
8000752c:	f2 07 01 0b 	sub	r11,r9,r7
80007530:	58 fb       	cp.w	r11,15
80007532:	e0 8a 00 04 	brle	8000753a <_malloc_r+0xde>
80007536:	20 13       	sub	r3,1
80007538:	c1 18       	rjmp	8000755a <_malloc_r+0xfe>
8000753a:	6c 38       	ld.w	r8,r6[0xc]
8000753c:	58 0b       	cp.w	r11,0
8000753e:	c0 b5       	brlt	80007554 <_malloc_r+0xf8>
80007540:	6c 2a       	ld.w	r10,r6[0x8]
80007542:	ec 09 00 09 	add	r9,r6,r9
80007546:	0a 9c       	mov	r12,r5
80007548:	91 2a       	st.w	r8[0x8],r10
8000754a:	95 38       	st.w	r10[0xc],r8
8000754c:	72 18       	ld.w	r8,r9[0x4]
8000754e:	a1 a8       	sbr	r8,0x0
80007550:	93 18       	st.w	r9[0x4],r8
80007552:	cb c8       	rjmp	800076ca <_malloc_r+0x26e>
80007554:	10 96       	mov	r6,r8
80007556:	14 36       	cp.w	r6,r10
80007558:	ce 71       	brne	80007526 <_malloc_r+0xca>
8000755a:	2f f3       	sub	r3,-1
8000755c:	e0 6a 05 3c 	mov	r10,1340
80007560:	f4 cc ff f8 	sub	r12,r10,-8
80007564:	78 26       	ld.w	r6,r12[0x8]
80007566:	18 36       	cp.w	r6,r12
80007568:	c6 c0       	breq	80007640 <_malloc_r+0x1e4>
8000756a:	6c 19       	ld.w	r9,r6[0x4]
8000756c:	e0 19 ff fc 	andl	r9,0xfffc
80007570:	f2 07 01 08 	sub	r8,r9,r7
80007574:	58 f8       	cp.w	r8,15
80007576:	e0 89 00 8f 	brgt	80007694 <_malloc_r+0x238>
8000757a:	99 3c       	st.w	r12[0xc],r12
8000757c:	99 2c       	st.w	r12[0x8],r12
8000757e:	58 08       	cp.w	r8,0
80007580:	c0 55       	brlt	8000758a <_malloc_r+0x12e>
80007582:	ec 09 00 09 	add	r9,r6,r9
80007586:	0a 9c       	mov	r12,r5
80007588:	ce 2b       	rjmp	8000754c <_malloc_r+0xf0>
8000758a:	e0 49 01 ff 	cp.w	r9,511
8000758e:	e0 8b 00 13 	brhi	800075b4 <_malloc_r+0x158>
80007592:	a3 99       	lsr	r9,0x3
80007594:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007598:	70 2b       	ld.w	r11,r8[0x8]
8000759a:	8d 38       	st.w	r6[0xc],r8
8000759c:	8d 2b       	st.w	r6[0x8],r11
8000759e:	97 36       	st.w	r11[0xc],r6
800075a0:	91 26       	st.w	r8[0x8],r6
800075a2:	a3 49       	asr	r9,0x2
800075a4:	74 18       	ld.w	r8,r10[0x4]
800075a6:	30 1b       	mov	r11,1
800075a8:	f6 09 09 49 	lsl	r9,r11,r9
800075ac:	f1 e9 10 09 	or	r9,r8,r9
800075b0:	95 19       	st.w	r10[0x4],r9
800075b2:	c4 78       	rjmp	80007640 <_malloc_r+0x1e4>
800075b4:	f2 0a 16 09 	lsr	r10,r9,0x9
800075b8:	58 4a       	cp.w	r10,4
800075ba:	e0 8b 00 07 	brhi	800075c8 <_malloc_r+0x16c>
800075be:	f2 0a 16 06 	lsr	r10,r9,0x6
800075c2:	2c 8a       	sub	r10,-56
800075c4:	c2 08       	rjmp	80007604 <_malloc_r+0x1a8>
800075c6:	d7 03       	nop
800075c8:	59 4a       	cp.w	r10,20
800075ca:	e0 8b 00 04 	brhi	800075d2 <_malloc_r+0x176>
800075ce:	2a 5a       	sub	r10,-91
800075d0:	c1 a8       	rjmp	80007604 <_malloc_r+0x1a8>
800075d2:	e0 4a 00 54 	cp.w	r10,84
800075d6:	e0 8b 00 06 	brhi	800075e2 <_malloc_r+0x186>
800075da:	f2 0a 16 0c 	lsr	r10,r9,0xc
800075de:	29 2a       	sub	r10,-110
800075e0:	c1 28       	rjmp	80007604 <_malloc_r+0x1a8>
800075e2:	e0 4a 01 54 	cp.w	r10,340
800075e6:	e0 8b 00 06 	brhi	800075f2 <_malloc_r+0x196>
800075ea:	f2 0a 16 0f 	lsr	r10,r9,0xf
800075ee:	28 9a       	sub	r10,-119
800075f0:	c0 a8       	rjmp	80007604 <_malloc_r+0x1a8>
800075f2:	e0 4a 05 54 	cp.w	r10,1364
800075f6:	e0 88 00 04 	brls	800075fe <_malloc_r+0x1a2>
800075fa:	37 ea       	mov	r10,126
800075fc:	c0 48       	rjmp	80007604 <_malloc_r+0x1a8>
800075fe:	f2 0a 16 12 	lsr	r10,r9,0x12
80007602:	28 4a       	sub	r10,-124
80007604:	e0 6b 05 3c 	mov	r11,1340
80007608:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000760c:	68 28       	ld.w	r8,r4[0x8]
8000760e:	08 38       	cp.w	r8,r4
80007610:	c0 e1       	brne	8000762c <_malloc_r+0x1d0>
80007612:	76 19       	ld.w	r9,r11[0x4]
80007614:	a3 4a       	asr	r10,0x2
80007616:	30 1e       	mov	lr,1
80007618:	fc 0a 09 4a 	lsl	r10,lr,r10
8000761c:	f3 ea 10 0a 	or	r10,r9,r10
80007620:	10 99       	mov	r9,r8
80007622:	97 1a       	st.w	r11[0x4],r10
80007624:	c0 a8       	rjmp	80007638 <_malloc_r+0x1dc>
80007626:	70 28       	ld.w	r8,r8[0x8]
80007628:	08 38       	cp.w	r8,r4
8000762a:	c0 60       	breq	80007636 <_malloc_r+0x1da>
8000762c:	70 1a       	ld.w	r10,r8[0x4]
8000762e:	e0 1a ff fc 	andl	r10,0xfffc
80007632:	14 39       	cp.w	r9,r10
80007634:	cf 93       	brcs	80007626 <_malloc_r+0x1ca>
80007636:	70 39       	ld.w	r9,r8[0xc]
80007638:	8d 39       	st.w	r6[0xc],r9
8000763a:	8d 28       	st.w	r6[0x8],r8
8000763c:	91 36       	st.w	r8[0xc],r6
8000763e:	93 26       	st.w	r9[0x8],r6
80007640:	e6 08 14 02 	asr	r8,r3,0x2
80007644:	30 1b       	mov	r11,1
80007646:	e0 64 05 3c 	mov	r4,1340
8000764a:	f6 08 09 4b 	lsl	r11,r11,r8
8000764e:	68 18       	ld.w	r8,r4[0x4]
80007650:	10 3b       	cp.w	r11,r8
80007652:	e0 8b 00 6b 	brhi	80007728 <_malloc_r+0x2cc>
80007656:	f7 e8 00 09 	and	r9,r11,r8
8000765a:	c0 b1       	brne	80007670 <_malloc_r+0x214>
8000765c:	e0 13 ff fc 	andl	r3,0xfffc
80007660:	a1 7b       	lsl	r11,0x1
80007662:	2f c3       	sub	r3,-4
80007664:	c0 38       	rjmp	8000766a <_malloc_r+0x20e>
80007666:	2f c3       	sub	r3,-4
80007668:	a1 7b       	lsl	r11,0x1
8000766a:	f7 e8 00 09 	and	r9,r11,r8
8000766e:	cf c0       	breq	80007666 <_malloc_r+0x20a>
80007670:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007674:	06 92       	mov	r2,r3
80007676:	1c 91       	mov	r1,lr
80007678:	62 36       	ld.w	r6,r1[0xc]
8000767a:	c2 e8       	rjmp	800076d6 <_malloc_r+0x27a>
8000767c:	6c 1a       	ld.w	r10,r6[0x4]
8000767e:	e0 1a ff fc 	andl	r10,0xfffc
80007682:	f4 07 01 08 	sub	r8,r10,r7
80007686:	58 f8       	cp.w	r8,15
80007688:	e0 8a 00 15 	brle	800076b2 <_malloc_r+0x256>
8000768c:	6c 3a       	ld.w	r10,r6[0xc]
8000768e:	6c 29       	ld.w	r9,r6[0x8]
80007690:	95 29       	st.w	r10[0x8],r9
80007692:	93 3a       	st.w	r9[0xc],r10
80007694:	0e 99       	mov	r9,r7
80007696:	ec 07 00 07 	add	r7,r6,r7
8000769a:	a1 a9       	sbr	r9,0x0
8000769c:	99 37       	st.w	r12[0xc],r7
8000769e:	99 27       	st.w	r12[0x8],r7
800076a0:	8d 19       	st.w	r6[0x4],r9
800076a2:	ee 08 09 08 	st.w	r7[r8],r8
800076a6:	8f 2c       	st.w	r7[0x8],r12
800076a8:	8f 3c       	st.w	r7[0xc],r12
800076aa:	a1 a8       	sbr	r8,0x0
800076ac:	0a 9c       	mov	r12,r5
800076ae:	8f 18       	st.w	r7[0x4],r8
800076b0:	c0 d8       	rjmp	800076ca <_malloc_r+0x26e>
800076b2:	6c 39       	ld.w	r9,r6[0xc]
800076b4:	58 08       	cp.w	r8,0
800076b6:	c0 f5       	brlt	800076d4 <_malloc_r+0x278>
800076b8:	ec 0a 00 0a 	add	r10,r6,r10
800076bc:	74 18       	ld.w	r8,r10[0x4]
800076be:	a1 a8       	sbr	r8,0x0
800076c0:	0a 9c       	mov	r12,r5
800076c2:	95 18       	st.w	r10[0x4],r8
800076c4:	6c 28       	ld.w	r8,r6[0x8]
800076c6:	93 28       	st.w	r9[0x8],r8
800076c8:	91 39       	st.w	r8[0xc],r9
800076ca:	fe b0 f4 89 	rcall	80005fdc <__malloc_unlock>
800076ce:	ec cc ff f8 	sub	r12,r6,-8
800076d2:	d8 32       	popm	r0-r7,pc
800076d4:	12 96       	mov	r6,r9
800076d6:	02 36       	cp.w	r6,r1
800076d8:	cd 21       	brne	8000767c <_malloc_r+0x220>
800076da:	2f f2       	sub	r2,-1
800076dc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800076e0:	c0 30       	breq	800076e6 <_malloc_r+0x28a>
800076e2:	2f 81       	sub	r1,-8
800076e4:	cc ab       	rjmp	80007678 <_malloc_r+0x21c>
800076e6:	1c 98       	mov	r8,lr
800076e8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800076ec:	c0 81       	brne	800076fc <_malloc_r+0x2a0>
800076ee:	68 19       	ld.w	r9,r4[0x4]
800076f0:	f6 08 11 ff 	rsub	r8,r11,-1
800076f4:	f3 e8 00 08 	and	r8,r9,r8
800076f8:	89 18       	st.w	r4[0x4],r8
800076fa:	c0 78       	rjmp	80007708 <_malloc_r+0x2ac>
800076fc:	f0 c9 00 08 	sub	r9,r8,8
80007700:	20 13       	sub	r3,1
80007702:	70 08       	ld.w	r8,r8[0x0]
80007704:	12 38       	cp.w	r8,r9
80007706:	cf 10       	breq	800076e8 <_malloc_r+0x28c>
80007708:	a1 7b       	lsl	r11,0x1
8000770a:	68 18       	ld.w	r8,r4[0x4]
8000770c:	10 3b       	cp.w	r11,r8
8000770e:	e0 8b 00 0d 	brhi	80007728 <_malloc_r+0x2cc>
80007712:	58 0b       	cp.w	r11,0
80007714:	c0 a0       	breq	80007728 <_malloc_r+0x2cc>
80007716:	04 93       	mov	r3,r2
80007718:	c0 38       	rjmp	8000771e <_malloc_r+0x2c2>
8000771a:	2f c3       	sub	r3,-4
8000771c:	a1 7b       	lsl	r11,0x1
8000771e:	f7 e8 00 09 	and	r9,r11,r8
80007722:	ca 71       	brne	80007670 <_malloc_r+0x214>
80007724:	cf bb       	rjmp	8000771a <_malloc_r+0x2be>
80007726:	d7 03       	nop
80007728:	68 23       	ld.w	r3,r4[0x8]
8000772a:	66 12       	ld.w	r2,r3[0x4]
8000772c:	e0 12 ff fc 	andl	r2,0xfffc
80007730:	0e 32       	cp.w	r2,r7
80007732:	5f 39       	srlo	r9
80007734:	e4 07 01 08 	sub	r8,r2,r7
80007738:	58 f8       	cp.w	r8,15
8000773a:	5f aa       	srle	r10
8000773c:	f5 e9 10 09 	or	r9,r10,r9
80007740:	e0 80 00 9a 	breq	80007874 <_malloc_r+0x418>
80007744:	e0 68 0d 6c 	mov	r8,3436
80007748:	70 01       	ld.w	r1,r8[0x0]
8000774a:	e0 68 09 48 	mov	r8,2376
8000774e:	2f 01       	sub	r1,-16
80007750:	70 08       	ld.w	r8,r8[0x0]
80007752:	0e 01       	add	r1,r7
80007754:	5b f8       	cp.w	r8,-1
80007756:	c0 40       	breq	8000775e <_malloc_r+0x302>
80007758:	28 11       	sub	r1,-127
8000775a:	e0 11 ff 80 	andl	r1,0xff80
8000775e:	02 9b       	mov	r11,r1
80007760:	0a 9c       	mov	r12,r5
80007762:	e0 a0 02 a5 	rcall	80007cac <_sbrk_r>
80007766:	18 96       	mov	r6,r12
80007768:	5b fc       	cp.w	r12,-1
8000776a:	c7 50       	breq	80007854 <_malloc_r+0x3f8>
8000776c:	e6 02 00 08 	add	r8,r3,r2
80007770:	10 3c       	cp.w	r12,r8
80007772:	c0 32       	brcc	80007778 <_malloc_r+0x31c>
80007774:	08 33       	cp.w	r3,r4
80007776:	c6 f1       	brne	80007854 <_malloc_r+0x3f8>
80007778:	e0 6a 0d 70 	mov	r10,3440
8000777c:	74 09       	ld.w	r9,r10[0x0]
8000777e:	e2 09 00 09 	add	r9,r1,r9
80007782:	95 09       	st.w	r10[0x0],r9
80007784:	10 36       	cp.w	r6,r8
80007786:	c0 a1       	brne	8000779a <_malloc_r+0x33e>
80007788:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000778c:	c0 71       	brne	8000779a <_malloc_r+0x33e>
8000778e:	e2 02 00 02 	add	r2,r1,r2
80007792:	68 28       	ld.w	r8,r4[0x8]
80007794:	a1 a2       	sbr	r2,0x0
80007796:	91 12       	st.w	r8[0x4],r2
80007798:	c4 f8       	rjmp	80007836 <_malloc_r+0x3da>
8000779a:	e0 6a 09 48 	mov	r10,2376
8000779e:	74 0b       	ld.w	r11,r10[0x0]
800077a0:	5b fb       	cp.w	r11,-1
800077a2:	c0 31       	brne	800077a8 <_malloc_r+0x34c>
800077a4:	95 06       	st.w	r10[0x0],r6
800077a6:	c0 78       	rjmp	800077b4 <_malloc_r+0x358>
800077a8:	ec 09 00 09 	add	r9,r6,r9
800077ac:	e0 6a 0d 70 	mov	r10,3440
800077b0:	10 19       	sub	r9,r8
800077b2:	95 09       	st.w	r10[0x0],r9
800077b4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800077b8:	f0 09 11 08 	rsub	r9,r8,8
800077bc:	58 08       	cp.w	r8,0
800077be:	f2 08 17 10 	movne	r8,r9
800077c2:	ed d8 e1 06 	addne	r6,r6,r8
800077c6:	28 08       	sub	r8,-128
800077c8:	ec 01 00 01 	add	r1,r6,r1
800077cc:	0a 9c       	mov	r12,r5
800077ce:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800077d2:	f0 01 01 01 	sub	r1,r8,r1
800077d6:	02 9b       	mov	r11,r1
800077d8:	e0 a0 02 6a 	rcall	80007cac <_sbrk_r>
800077dc:	e0 68 0d 70 	mov	r8,3440
800077e0:	5b fc       	cp.w	r12,-1
800077e2:	ec 0c 17 00 	moveq	r12,r6
800077e6:	f9 b1 00 00 	moveq	r1,0
800077ea:	70 09       	ld.w	r9,r8[0x0]
800077ec:	0c 1c       	sub	r12,r6
800077ee:	89 26       	st.w	r4[0x8],r6
800077f0:	02 0c       	add	r12,r1
800077f2:	12 01       	add	r1,r9
800077f4:	a1 ac       	sbr	r12,0x0
800077f6:	91 01       	st.w	r8[0x0],r1
800077f8:	8d 1c       	st.w	r6[0x4],r12
800077fa:	08 33       	cp.w	r3,r4
800077fc:	c1 d0       	breq	80007836 <_malloc_r+0x3da>
800077fe:	58 f2       	cp.w	r2,15
80007800:	e0 8b 00 05 	brhi	8000780a <_malloc_r+0x3ae>
80007804:	30 18       	mov	r8,1
80007806:	8d 18       	st.w	r6[0x4],r8
80007808:	c2 68       	rjmp	80007854 <_malloc_r+0x3f8>
8000780a:	30 59       	mov	r9,5
8000780c:	20 c2       	sub	r2,12
8000780e:	e0 12 ff f8 	andl	r2,0xfff8
80007812:	e6 02 00 08 	add	r8,r3,r2
80007816:	91 29       	st.w	r8[0x8],r9
80007818:	91 19       	st.w	r8[0x4],r9
8000781a:	66 18       	ld.w	r8,r3[0x4]
8000781c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007820:	e5 e8 10 08 	or	r8,r2,r8
80007824:	87 18       	st.w	r3[0x4],r8
80007826:	58 f2       	cp.w	r2,15
80007828:	e0 88 00 07 	brls	80007836 <_malloc_r+0x3da>
8000782c:	e6 cb ff f8 	sub	r11,r3,-8
80007830:	0a 9c       	mov	r12,r5
80007832:	e0 a0 1c 6b 	rcall	8000b108 <_free_r>
80007836:	e0 69 0d 68 	mov	r9,3432
8000783a:	72 0a       	ld.w	r10,r9[0x0]
8000783c:	e0 68 0d 70 	mov	r8,3440
80007840:	70 08       	ld.w	r8,r8[0x0]
80007842:	14 38       	cp.w	r8,r10
80007844:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007848:	e0 69 0d 64 	mov	r9,3428
8000784c:	72 0a       	ld.w	r10,r9[0x0]
8000784e:	14 38       	cp.w	r8,r10
80007850:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007854:	68 28       	ld.w	r8,r4[0x8]
80007856:	70 18       	ld.w	r8,r8[0x4]
80007858:	e0 18 ff fc 	andl	r8,0xfffc
8000785c:	0e 38       	cp.w	r8,r7
8000785e:	5f 39       	srlo	r9
80007860:	0e 18       	sub	r8,r7
80007862:	58 f8       	cp.w	r8,15
80007864:	5f aa       	srle	r10
80007866:	f5 e9 10 09 	or	r9,r10,r9
8000786a:	c0 50       	breq	80007874 <_malloc_r+0x418>
8000786c:	0a 9c       	mov	r12,r5
8000786e:	fe b0 f3 b7 	rcall	80005fdc <__malloc_unlock>
80007872:	d8 3a       	popm	r0-r7,pc,r12=0
80007874:	68 26       	ld.w	r6,r4[0x8]
80007876:	a1 a8       	sbr	r8,0x0
80007878:	0e 99       	mov	r9,r7
8000787a:	a1 a9       	sbr	r9,0x0
8000787c:	8d 19       	st.w	r6[0x4],r9
8000787e:	ec 07 00 07 	add	r7,r6,r7
80007882:	0a 9c       	mov	r12,r5
80007884:	89 27       	st.w	r4[0x8],r7
80007886:	8f 18       	st.w	r7[0x4],r8
80007888:	fe b0 f3 aa 	rcall	80005fdc <__malloc_unlock>
8000788c:	ec cc ff f8 	sub	r12,r6,-8
80007890:	d8 32       	popm	r0-r7,pc
80007892:	d7 03       	nop

80007894 <memcpy>:
80007894:	58 8a       	cp.w	r10,8
80007896:	c2 f5       	brlt	800078f4 <memcpy+0x60>
80007898:	f9 eb 10 09 	or	r9,r12,r11
8000789c:	e2 19 00 03 	andl	r9,0x3,COH
800078a0:	e0 81 00 97 	brne	800079ce <memcpy+0x13a>
800078a4:	e0 4a 00 20 	cp.w	r10,32
800078a8:	c3 b4       	brge	8000791e <memcpy+0x8a>
800078aa:	f4 08 14 02 	asr	r8,r10,0x2
800078ae:	f0 09 11 08 	rsub	r9,r8,8
800078b2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800078b6:	76 69       	ld.w	r9,r11[0x18]
800078b8:	99 69       	st.w	r12[0x18],r9
800078ba:	76 59       	ld.w	r9,r11[0x14]
800078bc:	99 59       	st.w	r12[0x14],r9
800078be:	76 49       	ld.w	r9,r11[0x10]
800078c0:	99 49       	st.w	r12[0x10],r9
800078c2:	76 39       	ld.w	r9,r11[0xc]
800078c4:	99 39       	st.w	r12[0xc],r9
800078c6:	76 29       	ld.w	r9,r11[0x8]
800078c8:	99 29       	st.w	r12[0x8],r9
800078ca:	76 19       	ld.w	r9,r11[0x4]
800078cc:	99 19       	st.w	r12[0x4],r9
800078ce:	76 09       	ld.w	r9,r11[0x0]
800078d0:	99 09       	st.w	r12[0x0],r9
800078d2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800078d6:	f8 08 00 28 	add	r8,r12,r8<<0x2
800078da:	e0 1a 00 03 	andl	r10,0x3
800078de:	f4 0a 11 04 	rsub	r10,r10,4
800078e2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078e6:	17 a9       	ld.ub	r9,r11[0x2]
800078e8:	b0 a9       	st.b	r8[0x2],r9
800078ea:	17 99       	ld.ub	r9,r11[0x1]
800078ec:	b0 99       	st.b	r8[0x1],r9
800078ee:	17 89       	ld.ub	r9,r11[0x0]
800078f0:	b0 89       	st.b	r8[0x0],r9
800078f2:	5e fc       	retal	r12
800078f4:	f4 0a 11 09 	rsub	r10,r10,9
800078f8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078fc:	17 f9       	ld.ub	r9,r11[0x7]
800078fe:	b8 f9       	st.b	r12[0x7],r9
80007900:	17 e9       	ld.ub	r9,r11[0x6]
80007902:	b8 e9       	st.b	r12[0x6],r9
80007904:	17 d9       	ld.ub	r9,r11[0x5]
80007906:	b8 d9       	st.b	r12[0x5],r9
80007908:	17 c9       	ld.ub	r9,r11[0x4]
8000790a:	b8 c9       	st.b	r12[0x4],r9
8000790c:	17 b9       	ld.ub	r9,r11[0x3]
8000790e:	b8 b9       	st.b	r12[0x3],r9
80007910:	17 a9       	ld.ub	r9,r11[0x2]
80007912:	b8 a9       	st.b	r12[0x2],r9
80007914:	17 99       	ld.ub	r9,r11[0x1]
80007916:	b8 99       	st.b	r12[0x1],r9
80007918:	17 89       	ld.ub	r9,r11[0x0]
8000791a:	b8 89       	st.b	r12[0x0],r9
8000791c:	5e fc       	retal	r12
8000791e:	eb cd 40 c0 	pushm	r6-r7,lr
80007922:	18 99       	mov	r9,r12
80007924:	22 0a       	sub	r10,32
80007926:	b7 07       	ld.d	r6,r11++
80007928:	b3 26       	st.d	r9++,r6
8000792a:	b7 07       	ld.d	r6,r11++
8000792c:	b3 26       	st.d	r9++,r6
8000792e:	b7 07       	ld.d	r6,r11++
80007930:	b3 26       	st.d	r9++,r6
80007932:	b7 07       	ld.d	r6,r11++
80007934:	b3 26       	st.d	r9++,r6
80007936:	22 0a       	sub	r10,32
80007938:	cf 74       	brge	80007926 <memcpy+0x92>
8000793a:	2f 0a       	sub	r10,-16
8000793c:	c0 65       	brlt	80007948 <memcpy+0xb4>
8000793e:	b7 07       	ld.d	r6,r11++
80007940:	b3 26       	st.d	r9++,r6
80007942:	b7 07       	ld.d	r6,r11++
80007944:	b3 26       	st.d	r9++,r6
80007946:	21 0a       	sub	r10,16
80007948:	5c 3a       	neg	r10
8000794a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000794e:	d7 03       	nop
80007950:	d7 03       	nop
80007952:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007956:	f3 66 00 0e 	st.b	r9[14],r6
8000795a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000795e:	f3 66 00 0d 	st.b	r9[13],r6
80007962:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007966:	f3 66 00 0c 	st.b	r9[12],r6
8000796a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000796e:	f3 66 00 0b 	st.b	r9[11],r6
80007972:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007976:	f3 66 00 0a 	st.b	r9[10],r6
8000797a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000797e:	f3 66 00 09 	st.b	r9[9],r6
80007982:	f7 36 00 08 	ld.ub	r6,r11[8]
80007986:	f3 66 00 08 	st.b	r9[8],r6
8000798a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000798e:	f3 66 00 07 	st.b	r9[7],r6
80007992:	f7 36 00 06 	ld.ub	r6,r11[6]
80007996:	f3 66 00 06 	st.b	r9[6],r6
8000799a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000799e:	f3 66 00 05 	st.b	r9[5],r6
800079a2:	f7 36 00 04 	ld.ub	r6,r11[4]
800079a6:	f3 66 00 04 	st.b	r9[4],r6
800079aa:	f7 36 00 03 	ld.ub	r6,r11[3]
800079ae:	f3 66 00 03 	st.b	r9[3],r6
800079b2:	f7 36 00 02 	ld.ub	r6,r11[2]
800079b6:	f3 66 00 02 	st.b	r9[2],r6
800079ba:	f7 36 00 01 	ld.ub	r6,r11[1]
800079be:	f3 66 00 01 	st.b	r9[1],r6
800079c2:	f7 36 00 00 	ld.ub	r6,r11[0]
800079c6:	f3 66 00 00 	st.b	r9[0],r6
800079ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800079ce:	20 1a       	sub	r10,1
800079d0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800079d4:	f8 0a 0b 09 	st.b	r12[r10],r9
800079d8:	cf b1       	brne	800079ce <memcpy+0x13a>
800079da:	5e fc       	retal	r12

800079dc <memset>:
800079dc:	18 98       	mov	r8,r12
800079de:	c0 38       	rjmp	800079e4 <memset+0x8>
800079e0:	10 cb       	st.b	r8++,r11
800079e2:	20 1a       	sub	r10,1
800079e4:	58 0a       	cp.w	r10,0
800079e6:	cf d1       	brne	800079e0 <memset+0x4>
800079e8:	5e fc       	retal	r12
800079ea:	d7 03       	nop

800079ec <_realloc_r>:
800079ec:	d4 31       	pushm	r0-r7,lr
800079ee:	20 1d       	sub	sp,4
800079f0:	16 94       	mov	r4,r11
800079f2:	18 92       	mov	r2,r12
800079f4:	14 9b       	mov	r11,r10
800079f6:	58 04       	cp.w	r4,0
800079f8:	c0 51       	brne	80007a02 <_realloc_r+0x16>
800079fa:	fe b0 fd 31 	rcall	8000745c <_malloc_r>
800079fe:	18 95       	mov	r5,r12
80007a00:	c5 39       	rjmp	80007ca6 <_realloc_r+0x2ba>
80007a02:	50 0a       	stdsp	sp[0x0],r10
80007a04:	fe b0 f2 e6 	rcall	80005fd0 <__malloc_lock>
80007a08:	40 0b       	lddsp	r11,sp[0x0]
80007a0a:	f6 c8 ff f5 	sub	r8,r11,-11
80007a0e:	e8 c1 00 08 	sub	r1,r4,8
80007a12:	10 96       	mov	r6,r8
80007a14:	62 1c       	ld.w	r12,r1[0x4]
80007a16:	e0 16 ff f8 	andl	r6,0xfff8
80007a1a:	59 68       	cp.w	r8,22
80007a1c:	f9 b6 08 10 	movls	r6,16
80007a20:	16 36       	cp.w	r6,r11
80007a22:	5f 38       	srlo	r8
80007a24:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007a28:	c0 50       	breq	80007a32 <_realloc_r+0x46>
80007a2a:	30 c8       	mov	r8,12
80007a2c:	30 05       	mov	r5,0
80007a2e:	85 38       	st.w	r2[0xc],r8
80007a30:	c3 b9       	rjmp	80007ca6 <_realloc_r+0x2ba>
80007a32:	18 90       	mov	r0,r12
80007a34:	e0 10 ff fc 	andl	r0,0xfffc
80007a38:	0c 30       	cp.w	r0,r6
80007a3a:	e0 84 01 0b 	brge	80007c50 <_realloc_r+0x264>
80007a3e:	e0 68 05 3c 	mov	r8,1340
80007a42:	e2 00 00 09 	add	r9,r1,r0
80007a46:	70 25       	ld.w	r5,r8[0x8]
80007a48:	0a 39       	cp.w	r9,r5
80007a4a:	c0 90       	breq	80007a5c <_realloc_r+0x70>
80007a4c:	72 1a       	ld.w	r10,r9[0x4]
80007a4e:	a1 ca       	cbr	r10,0x0
80007a50:	f2 0a 00 0a 	add	r10,r9,r10
80007a54:	74 1a       	ld.w	r10,r10[0x4]
80007a56:	ed ba 00 00 	bld	r10,0x0
80007a5a:	c2 20       	breq	80007a9e <_realloc_r+0xb2>
80007a5c:	72 1a       	ld.w	r10,r9[0x4]
80007a5e:	e0 1a ff fc 	andl	r10,0xfffc
80007a62:	f4 00 00 03 	add	r3,r10,r0
80007a66:	0a 39       	cp.w	r9,r5
80007a68:	c1 31       	brne	80007a8e <_realloc_r+0xa2>
80007a6a:	ec c7 ff f0 	sub	r7,r6,-16
80007a6e:	0e 33       	cp.w	r3,r7
80007a70:	c1 95       	brlt	80007aa2 <_realloc_r+0xb6>
80007a72:	e2 06 00 09 	add	r9,r1,r6
80007a76:	0c 13       	sub	r3,r6
80007a78:	a1 a3       	sbr	r3,0x0
80007a7a:	93 13       	st.w	r9[0x4],r3
80007a7c:	91 29       	st.w	r8[0x8],r9
80007a7e:	04 9c       	mov	r12,r2
80007a80:	62 18       	ld.w	r8,r1[0x4]
80007a82:	08 95       	mov	r5,r4
80007a84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a88:	10 46       	or	r6,r8
80007a8a:	83 16       	st.w	r1[0x4],r6
80007a8c:	c0 b9       	rjmp	80007ca2 <_realloc_r+0x2b6>
80007a8e:	0c 33       	cp.w	r3,r6
80007a90:	c0 95       	brlt	80007aa2 <_realloc_r+0xb6>
80007a92:	72 28       	ld.w	r8,r9[0x8]
80007a94:	02 97       	mov	r7,r1
80007a96:	72 39       	ld.w	r9,r9[0xc]
80007a98:	93 28       	st.w	r9[0x8],r8
80007a9a:	91 39       	st.w	r8[0xc],r9
80007a9c:	cd c8       	rjmp	80007c54 <_realloc_r+0x268>
80007a9e:	30 0a       	mov	r10,0
80007aa0:	14 99       	mov	r9,r10
80007aa2:	ed bc 00 00 	bld	r12,0x0
80007aa6:	e0 80 00 95 	breq	80007bd0 <_realloc_r+0x1e4>
80007aaa:	62 07       	ld.w	r7,r1[0x0]
80007aac:	e2 07 01 07 	sub	r7,r1,r7
80007ab0:	6e 1c       	ld.w	r12,r7[0x4]
80007ab2:	e0 1c ff fc 	andl	r12,0xfffc
80007ab6:	58 09       	cp.w	r9,0
80007ab8:	c5 60       	breq	80007b64 <_realloc_r+0x178>
80007aba:	f8 00 00 03 	add	r3,r12,r0
80007abe:	0a 39       	cp.w	r9,r5
80007ac0:	c4 81       	brne	80007b50 <_realloc_r+0x164>
80007ac2:	14 03       	add	r3,r10
80007ac4:	ec c9 ff f0 	sub	r9,r6,-16
80007ac8:	12 33       	cp.w	r3,r9
80007aca:	c4 d5       	brlt	80007b64 <_realloc_r+0x178>
80007acc:	6e 3a       	ld.w	r10,r7[0xc]
80007ace:	6e 29       	ld.w	r9,r7[0x8]
80007ad0:	95 29       	st.w	r10[0x8],r9
80007ad2:	93 3a       	st.w	r9[0xc],r10
80007ad4:	ee c5 ff f8 	sub	r5,r7,-8
80007ad8:	e0 ca 00 04 	sub	r10,r0,4
80007adc:	e0 4a 00 24 	cp.w	r10,36
80007ae0:	e0 8b 00 25 	brhi	80007b2a <_realloc_r+0x13e>
80007ae4:	0a 99       	mov	r9,r5
80007ae6:	59 3a       	cp.w	r10,19
80007ae8:	e0 88 00 1a 	brls	80007b1c <_realloc_r+0x130>
80007aec:	09 09       	ld.w	r9,r4++
80007aee:	8b 09       	st.w	r5[0x0],r9
80007af0:	09 09       	ld.w	r9,r4++
80007af2:	8f 39       	st.w	r7[0xc],r9
80007af4:	ee c9 ff f0 	sub	r9,r7,-16
80007af8:	59 ba       	cp.w	r10,27
80007afa:	e0 88 00 11 	brls	80007b1c <_realloc_r+0x130>
80007afe:	09 0b       	ld.w	r11,r4++
80007b00:	93 0b       	st.w	r9[0x0],r11
80007b02:	09 09       	ld.w	r9,r4++
80007b04:	8f 59       	st.w	r7[0x14],r9
80007b06:	ee c9 ff e8 	sub	r9,r7,-24
80007b0a:	e0 4a 00 24 	cp.w	r10,36
80007b0e:	c0 71       	brne	80007b1c <_realloc_r+0x130>
80007b10:	09 0a       	ld.w	r10,r4++
80007b12:	93 0a       	st.w	r9[0x0],r10
80007b14:	ee c9 ff e0 	sub	r9,r7,-32
80007b18:	09 0a       	ld.w	r10,r4++
80007b1a:	8f 7a       	st.w	r7[0x1c],r10
80007b1c:	09 0a       	ld.w	r10,r4++
80007b1e:	12 aa       	st.w	r9++,r10
80007b20:	68 0a       	ld.w	r10,r4[0x0]
80007b22:	93 0a       	st.w	r9[0x0],r10
80007b24:	68 1a       	ld.w	r10,r4[0x4]
80007b26:	93 1a       	st.w	r9[0x4],r10
80007b28:	c0 78       	rjmp	80007b36 <_realloc_r+0x14a>
80007b2a:	50 08       	stdsp	sp[0x0],r8
80007b2c:	08 9b       	mov	r11,r4
80007b2e:	0a 9c       	mov	r12,r5
80007b30:	e0 a0 1d 8f 	rcall	8000b64e <memmove>
80007b34:	40 08       	lddsp	r8,sp[0x0]
80007b36:	ee 06 00 09 	add	r9,r7,r6
80007b3a:	0c 13       	sub	r3,r6
80007b3c:	a1 a3       	sbr	r3,0x0
80007b3e:	93 13       	st.w	r9[0x4],r3
80007b40:	91 29       	st.w	r8[0x8],r9
80007b42:	04 9c       	mov	r12,r2
80007b44:	6e 18       	ld.w	r8,r7[0x4]
80007b46:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b4a:	10 46       	or	r6,r8
80007b4c:	8f 16       	st.w	r7[0x4],r6
80007b4e:	ca a8       	rjmp	80007ca2 <_realloc_r+0x2b6>
80007b50:	14 03       	add	r3,r10
80007b52:	0c 33       	cp.w	r3,r6
80007b54:	c0 85       	brlt	80007b64 <_realloc_r+0x178>
80007b56:	72 28       	ld.w	r8,r9[0x8]
80007b58:	72 39       	ld.w	r9,r9[0xc]
80007b5a:	93 28       	st.w	r9[0x8],r8
80007b5c:	91 39       	st.w	r8[0xc],r9
80007b5e:	6e 28       	ld.w	r8,r7[0x8]
80007b60:	6e 39       	ld.w	r9,r7[0xc]
80007b62:	c0 78       	rjmp	80007b70 <_realloc_r+0x184>
80007b64:	f8 00 00 03 	add	r3,r12,r0
80007b68:	0c 33       	cp.w	r3,r6
80007b6a:	c3 35       	brlt	80007bd0 <_realloc_r+0x1e4>
80007b6c:	6e 39       	ld.w	r9,r7[0xc]
80007b6e:	6e 28       	ld.w	r8,r7[0x8]
80007b70:	93 28       	st.w	r9[0x8],r8
80007b72:	91 39       	st.w	r8[0xc],r9
80007b74:	e0 ca 00 04 	sub	r10,r0,4
80007b78:	ee cc ff f8 	sub	r12,r7,-8
80007b7c:	e0 4a 00 24 	cp.w	r10,36
80007b80:	e0 8b 00 24 	brhi	80007bc8 <_realloc_r+0x1dc>
80007b84:	59 3a       	cp.w	r10,19
80007b86:	e0 88 00 1a 	brls	80007bba <_realloc_r+0x1ce>
80007b8a:	09 08       	ld.w	r8,r4++
80007b8c:	99 08       	st.w	r12[0x0],r8
80007b8e:	09 08       	ld.w	r8,r4++
80007b90:	8f 38       	st.w	r7[0xc],r8
80007b92:	ee cc ff f0 	sub	r12,r7,-16
80007b96:	59 ba       	cp.w	r10,27
80007b98:	e0 88 00 11 	brls	80007bba <_realloc_r+0x1ce>
80007b9c:	09 08       	ld.w	r8,r4++
80007b9e:	99 08       	st.w	r12[0x0],r8
80007ba0:	09 08       	ld.w	r8,r4++
80007ba2:	8f 58       	st.w	r7[0x14],r8
80007ba4:	ee cc ff e8 	sub	r12,r7,-24
80007ba8:	e0 4a 00 24 	cp.w	r10,36
80007bac:	c0 71       	brne	80007bba <_realloc_r+0x1ce>
80007bae:	09 08       	ld.w	r8,r4++
80007bb0:	99 08       	st.w	r12[0x0],r8
80007bb2:	ee cc ff e0 	sub	r12,r7,-32
80007bb6:	09 08       	ld.w	r8,r4++
80007bb8:	8f 78       	st.w	r7[0x1c],r8
80007bba:	09 08       	ld.w	r8,r4++
80007bbc:	18 a8       	st.w	r12++,r8
80007bbe:	68 08       	ld.w	r8,r4[0x0]
80007bc0:	99 08       	st.w	r12[0x0],r8
80007bc2:	68 18       	ld.w	r8,r4[0x4]
80007bc4:	99 18       	st.w	r12[0x4],r8
80007bc6:	c4 78       	rjmp	80007c54 <_realloc_r+0x268>
80007bc8:	08 9b       	mov	r11,r4
80007bca:	e0 a0 1d 42 	rcall	8000b64e <memmove>
80007bce:	c4 38       	rjmp	80007c54 <_realloc_r+0x268>
80007bd0:	04 9c       	mov	r12,r2
80007bd2:	fe b0 fc 45 	rcall	8000745c <_malloc_r>
80007bd6:	18 95       	mov	r5,r12
80007bd8:	c3 a0       	breq	80007c4c <_realloc_r+0x260>
80007bda:	62 18       	ld.w	r8,r1[0x4]
80007bdc:	f8 c9 00 08 	sub	r9,r12,8
80007be0:	a1 c8       	cbr	r8,0x0
80007be2:	e2 08 00 08 	add	r8,r1,r8
80007be6:	10 39       	cp.w	r9,r8
80007be8:	c0 71       	brne	80007bf6 <_realloc_r+0x20a>
80007bea:	72 13       	ld.w	r3,r9[0x4]
80007bec:	02 97       	mov	r7,r1
80007bee:	e0 13 ff fc 	andl	r3,0xfffc
80007bf2:	00 03       	add	r3,r0
80007bf4:	c3 08       	rjmp	80007c54 <_realloc_r+0x268>
80007bf6:	e0 ca 00 04 	sub	r10,r0,4
80007bfa:	e0 4a 00 24 	cp.w	r10,36
80007bfe:	e0 8b 00 20 	brhi	80007c3e <_realloc_r+0x252>
80007c02:	08 99       	mov	r9,r4
80007c04:	18 98       	mov	r8,r12
80007c06:	59 3a       	cp.w	r10,19
80007c08:	e0 88 00 14 	brls	80007c30 <_realloc_r+0x244>
80007c0c:	13 0b       	ld.w	r11,r9++
80007c0e:	10 ab       	st.w	r8++,r11
80007c10:	13 0b       	ld.w	r11,r9++
80007c12:	10 ab       	st.w	r8++,r11
80007c14:	59 ba       	cp.w	r10,27
80007c16:	e0 88 00 0d 	brls	80007c30 <_realloc_r+0x244>
80007c1a:	13 0b       	ld.w	r11,r9++
80007c1c:	10 ab       	st.w	r8++,r11
80007c1e:	13 0b       	ld.w	r11,r9++
80007c20:	10 ab       	st.w	r8++,r11
80007c22:	e0 4a 00 24 	cp.w	r10,36
80007c26:	c0 51       	brne	80007c30 <_realloc_r+0x244>
80007c28:	13 0a       	ld.w	r10,r9++
80007c2a:	10 aa       	st.w	r8++,r10
80007c2c:	13 0a       	ld.w	r10,r9++
80007c2e:	10 aa       	st.w	r8++,r10
80007c30:	13 0a       	ld.w	r10,r9++
80007c32:	10 aa       	st.w	r8++,r10
80007c34:	72 0a       	ld.w	r10,r9[0x0]
80007c36:	91 0a       	st.w	r8[0x0],r10
80007c38:	72 19       	ld.w	r9,r9[0x4]
80007c3a:	91 19       	st.w	r8[0x4],r9
80007c3c:	c0 48       	rjmp	80007c44 <_realloc_r+0x258>
80007c3e:	08 9b       	mov	r11,r4
80007c40:	e0 a0 1d 07 	rcall	8000b64e <memmove>
80007c44:	08 9b       	mov	r11,r4
80007c46:	04 9c       	mov	r12,r2
80007c48:	e0 a0 1a 60 	rcall	8000b108 <_free_r>
80007c4c:	04 9c       	mov	r12,r2
80007c4e:	c2 a8       	rjmp	80007ca2 <_realloc_r+0x2b6>
80007c50:	00 93       	mov	r3,r0
80007c52:	02 97       	mov	r7,r1
80007c54:	e6 06 01 09 	sub	r9,r3,r6
80007c58:	6e 18       	ld.w	r8,r7[0x4]
80007c5a:	58 f9       	cp.w	r9,15
80007c5c:	e0 88 00 16 	brls	80007c88 <_realloc_r+0x29c>
80007c60:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c64:	ed e8 10 08 	or	r8,r6,r8
80007c68:	8f 18       	st.w	r7[0x4],r8
80007c6a:	12 98       	mov	r8,r9
80007c6c:	a1 a8       	sbr	r8,0x0
80007c6e:	ee 06 00 0b 	add	r11,r7,r6
80007c72:	f6 09 00 09 	add	r9,r11,r9
80007c76:	97 18       	st.w	r11[0x4],r8
80007c78:	72 18       	ld.w	r8,r9[0x4]
80007c7a:	a1 a8       	sbr	r8,0x0
80007c7c:	2f 8b       	sub	r11,-8
80007c7e:	93 18       	st.w	r9[0x4],r8
80007c80:	04 9c       	mov	r12,r2
80007c82:	e0 a0 1a 43 	rcall	8000b108 <_free_r>
80007c86:	c0 b8       	rjmp	80007c9c <_realloc_r+0x2b0>
80007c88:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c8c:	e7 e8 10 08 	or	r8,r3,r8
80007c90:	8f 18       	st.w	r7[0x4],r8
80007c92:	ee 03 00 03 	add	r3,r7,r3
80007c96:	66 18       	ld.w	r8,r3[0x4]
80007c98:	a1 a8       	sbr	r8,0x0
80007c9a:	87 18       	st.w	r3[0x4],r8
80007c9c:	04 9c       	mov	r12,r2
80007c9e:	ee c5 ff f8 	sub	r5,r7,-8
80007ca2:	fe b0 f1 9d 	rcall	80005fdc <__malloc_unlock>
80007ca6:	0a 9c       	mov	r12,r5
80007ca8:	2f fd       	sub	sp,-4
80007caa:	d8 32       	popm	r0-r7,pc

80007cac <_sbrk_r>:
80007cac:	d4 21       	pushm	r4-r7,lr
80007cae:	30 08       	mov	r8,0
80007cb0:	18 97       	mov	r7,r12
80007cb2:	e0 66 bf f8 	mov	r6,49144
80007cb6:	16 9c       	mov	r12,r11
80007cb8:	8d 08       	st.w	r6[0x0],r8
80007cba:	c8 5c       	rcall	80007dc4 <_sbrk>
80007cbc:	5b fc       	cp.w	r12,-1
80007cbe:	c0 51       	brne	80007cc8 <_sbrk_r+0x1c>
80007cc0:	6c 08       	ld.w	r8,r6[0x0]
80007cc2:	58 08       	cp.w	r8,0
80007cc4:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007cc8:	d8 22       	popm	r4-r7,pc
80007cca:	d7 03       	nop

80007ccc <sprintf>:
80007ccc:	d4 01       	pushm	lr
80007cce:	21 7d       	sub	sp,92
80007cd0:	e0 68 ff ff 	mov	r8,65535
80007cd4:	ea 18 7f ff 	orh	r8,0x7fff
80007cd8:	50 58       	stdsp	sp[0x14],r8
80007cda:	50 28       	stdsp	sp[0x8],r8
80007cdc:	e0 68 02 08 	mov	r8,520
80007ce0:	ba 68       	st.h	sp[0xc],r8
80007ce2:	3f f8       	mov	r8,-1
80007ce4:	ba 78       	st.h	sp[0xe],r8
80007ce6:	e0 68 0a 3c 	mov	r8,2620
80007cea:	50 4c       	stdsp	sp[0x10],r12
80007cec:	16 9a       	mov	r10,r11
80007cee:	50 0c       	stdsp	sp[0x0],r12
80007cf0:	fa c9 ff a0 	sub	r9,sp,-96
80007cf4:	70 0c       	ld.w	r12,r8[0x0]
80007cf6:	1a 9b       	mov	r11,sp
80007cf8:	e0 a0 02 1a 	rcall	8000812c <_vfprintf_r>
80007cfc:	30 09       	mov	r9,0
80007cfe:	40 08       	lddsp	r8,sp[0x0]
80007d00:	b0 89       	st.b	r8[0x0],r9
80007d02:	2e 9d       	sub	sp,-92
80007d04:	d8 02       	popm	pc
80007d06:	d7 03       	nop

80007d08 <strncpy>:
80007d08:	30 08       	mov	r8,0
80007d0a:	10 3a       	cp.w	r10,r8
80007d0c:	5e 0c       	reteq	r12
80007d0e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007d12:	f8 08 0b 09 	st.b	r12[r8],r9
80007d16:	2f f8       	sub	r8,-1
80007d18:	58 09       	cp.w	r9,0
80007d1a:	cf 81       	brne	80007d0a <strncpy+0x2>
80007d1c:	10 3a       	cp.w	r10,r8
80007d1e:	5e 0c       	reteq	r12
80007d20:	f8 08 0b 09 	st.b	r12[r8],r9
80007d24:	2f f8       	sub	r8,-1
80007d26:	cf bb       	rjmp	80007d1c <strncpy+0x14>

80007d28 <_close>:
80007d28:	30 28       	mov	r8,2
80007d2a:	d6 73       	breakpoint
80007d2c:	3f fc       	mov	r12,-1
80007d2e:	35 8b       	mov	r11,88
80007d30:	58 0c       	cp.w	r12,0
80007d32:	5e 4c       	retge	r12
80007d34:	e0 6a bf f8 	mov	r10,49144
80007d38:	95 0b       	st.w	r10[0x0],r11
80007d3a:	5e fc       	retal	r12

80007d3c <_lseek>:
80007d3c:	30 58       	mov	r8,5
80007d3e:	d6 73       	breakpoint
80007d40:	3f fc       	mov	r12,-1
80007d42:	35 8b       	mov	r11,88
80007d44:	58 0c       	cp.w	r12,0
80007d46:	5e 4c       	retge	r12
80007d48:	e0 6a bf f8 	mov	r10,49144
80007d4c:	95 0b       	st.w	r10[0x0],r11
80007d4e:	5e fc       	retal	r12

80007d50 <isatty>:
80007d50:	30 b8       	mov	r8,11
80007d52:	d6 73       	breakpoint
80007d54:	3f fc       	mov	r12,-1
80007d56:	35 8b       	mov	r11,88
80007d58:	58 0c       	cp.w	r12,0
80007d5a:	5e 4c       	retge	r12
80007d5c:	e0 6a bf f8 	mov	r10,49144
80007d60:	95 0b       	st.w	r10[0x0],r11
80007d62:	5e fc       	retal	r12

80007d64 <_fstat_host>:
80007d64:	30 98       	mov	r8,9
80007d66:	d6 73       	breakpoint
80007d68:	3f fc       	mov	r12,-1
80007d6a:	35 8b       	mov	r11,88
80007d6c:	58 0c       	cp.w	r12,0
80007d6e:	5e 4c       	retge	r12
80007d70:	e0 6a bf f8 	mov	r10,49144
80007d74:	95 0b       	st.w	r10[0x0],r11
80007d76:	5e fc       	retal	r12

80007d78 <_fstat>:
80007d78:	d4 21       	pushm	r4-r7,lr
80007d7a:	21 0d       	sub	sp,64
80007d7c:	16 97       	mov	r7,r11
80007d7e:	1a 9b       	mov	r11,sp
80007d80:	cf 2f       	rcall	80007d64 <_fstat_host>
80007d82:	c0 34       	brge	80007d88 <_fstat+0x10>
80007d84:	3f fc       	mov	r12,-1
80007d86:	c1 c8       	rjmp	80007dbe <_fstat+0x46>
80007d88:	40 08       	lddsp	r8,sp[0x0]
80007d8a:	ae 08       	st.h	r7[0x0],r8
80007d8c:	40 18       	lddsp	r8,sp[0x4]
80007d8e:	ae 18       	st.h	r7[0x2],r8
80007d90:	40 28       	lddsp	r8,sp[0x8]
80007d92:	8f 18       	st.w	r7[0x4],r8
80007d94:	40 38       	lddsp	r8,sp[0xc]
80007d96:	ae 48       	st.h	r7[0x8],r8
80007d98:	40 48       	lddsp	r8,sp[0x10]
80007d9a:	ae 58       	st.h	r7[0xa],r8
80007d9c:	40 58       	lddsp	r8,sp[0x14]
80007d9e:	ae 68       	st.h	r7[0xc],r8
80007da0:	40 68       	lddsp	r8,sp[0x18]
80007da2:	ae 78       	st.h	r7[0xe],r8
80007da4:	40 88       	lddsp	r8,sp[0x20]
80007da6:	8f 48       	st.w	r7[0x10],r8
80007da8:	40 a8       	lddsp	r8,sp[0x28]
80007daa:	8f b8       	st.w	r7[0x2c],r8
80007dac:	40 c8       	lddsp	r8,sp[0x30]
80007dae:	8f c8       	st.w	r7[0x30],r8
80007db0:	40 d8       	lddsp	r8,sp[0x34]
80007db2:	8f 58       	st.w	r7[0x14],r8
80007db4:	40 e8       	lddsp	r8,sp[0x38]
80007db6:	30 0c       	mov	r12,0
80007db8:	8f 78       	st.w	r7[0x1c],r8
80007dba:	40 f8       	lddsp	r8,sp[0x3c]
80007dbc:	8f 98       	st.w	r7[0x24],r8
80007dbe:	2f 0d       	sub	sp,-64
80007dc0:	d8 22       	popm	r4-r7,pc
80007dc2:	d7 03       	nop

80007dc4 <_sbrk>:
80007dc4:	d4 01       	pushm	lr
80007dc6:	e0 68 0d 98 	mov	r8,3480
80007dca:	70 09       	ld.w	r9,r8[0x0]
80007dcc:	58 09       	cp.w	r9,0
80007dce:	c0 41       	brne	80007dd6 <_sbrk+0x12>
80007dd0:	e0 69 c0 00 	mov	r9,49152
80007dd4:	91 09       	st.w	r8[0x0],r9
80007dd6:	e0 69 0d 98 	mov	r9,3480
80007dda:	e0 7a 70 00 	mov	r10,94208
80007dde:	72 08       	ld.w	r8,r9[0x0]
80007de0:	f0 0c 00 0c 	add	r12,r8,r12
80007de4:	14 3c       	cp.w	r12,r10
80007de6:	e0 8b 00 04 	brhi	80007dee <_sbrk+0x2a>
80007dea:	93 0c       	st.w	r9[0x0],r12
80007dec:	c0 68       	rjmp	80007df8 <_sbrk+0x34>
80007dee:	e0 a0 18 15 	rcall	8000ae18 <__errno>
80007df2:	30 c8       	mov	r8,12
80007df4:	99 08       	st.w	r12[0x0],r8
80007df6:	3f f8       	mov	r8,-1
80007df8:	10 9c       	mov	r12,r8
80007dfa:	d8 02       	popm	pc

80007dfc <get_arg>:
80007dfc:	d4 31       	pushm	r0-r7,lr
80007dfe:	20 8d       	sub	sp,32
80007e00:	fa c4 ff bc 	sub	r4,sp,-68
80007e04:	50 4b       	stdsp	sp[0x10],r11
80007e06:	68 2e       	ld.w	lr,r4[0x8]
80007e08:	50 58       	stdsp	sp[0x14],r8
80007e0a:	12 96       	mov	r6,r9
80007e0c:	7c 0b       	ld.w	r11,lr[0x0]
80007e0e:	70 05       	ld.w	r5,r8[0x0]
80007e10:	50 6e       	stdsp	sp[0x18],lr
80007e12:	58 0b       	cp.w	r11,0
80007e14:	f4 0b 17 00 	moveq	r11,r10
80007e18:	68 03       	ld.w	r3,r4[0x0]
80007e1a:	68 11       	ld.w	r1,r4[0x4]
80007e1c:	40 49       	lddsp	r9,sp[0x10]
80007e1e:	30 08       	mov	r8,0
80007e20:	c2 89       	rjmp	80008070 <get_arg+0x274>
80007e22:	2f fb       	sub	r11,-1
80007e24:	32 5c       	mov	r12,37
80007e26:	17 8a       	ld.ub	r10,r11[0x0]
80007e28:	f8 0a 18 00 	cp.b	r10,r12
80007e2c:	5f 1e       	srne	lr
80007e2e:	f0 0a 18 00 	cp.b	r10,r8
80007e32:	5f 1c       	srne	r12
80007e34:	fd ec 00 0c 	and	r12,lr,r12
80007e38:	f0 0c 18 00 	cp.b	r12,r8
80007e3c:	cf 31       	brne	80007e22 <get_arg+0x26>
80007e3e:	58 0a       	cp.w	r10,0
80007e40:	e0 80 01 25 	breq	8000808a <get_arg+0x28e>
80007e44:	30 0c       	mov	r12,0
80007e46:	3f fa       	mov	r10,-1
80007e48:	18 90       	mov	r0,r12
80007e4a:	50 3a       	stdsp	sp[0xc],r10
80007e4c:	18 94       	mov	r4,r12
80007e4e:	18 92       	mov	r2,r12
80007e50:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e54:	16 97       	mov	r7,r11
80007e56:	50 7c       	stdsp	sp[0x1c],r12
80007e58:	fe cc 9e 58 	sub	r12,pc,-25000
80007e5c:	0f 3a       	ld.ub	r10,r7++
80007e5e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e62:	40 7c       	lddsp	r12,sp[0x1c]
80007e64:	1c 0c       	add	r12,lr
80007e66:	fe ce 9f 2e 	sub	lr,pc,-24786
80007e6a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e6e:	20 1e       	sub	lr,1
80007e70:	50 0e       	stdsp	sp[0x0],lr
80007e72:	fe ce 9f a6 	sub	lr,pc,-24666
80007e76:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e7a:	50 7c       	stdsp	sp[0x1c],r12
80007e7c:	40 0c       	lddsp	r12,sp[0x0]
80007e7e:	58 7c       	cp.w	r12,7
80007e80:	e0 8b 00 f1 	brhi	80008062 <get_arg+0x266>
80007e84:	fe ce a1 58 	sub	lr,pc,-24232
80007e88:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e8c:	36 8b       	mov	r11,104
80007e8e:	f6 0a 18 00 	cp.b	r10,r11
80007e92:	e0 80 00 e8 	breq	80008062 <get_arg+0x266>
80007e96:	37 1b       	mov	r11,113
80007e98:	f6 0a 18 00 	cp.b	r10,r11
80007e9c:	c0 70       	breq	80007eaa <get_arg+0xae>
80007e9e:	34 cb       	mov	r11,76
80007ea0:	f6 0a 18 00 	cp.b	r10,r11
80007ea4:	c0 51       	brne	80007eae <get_arg+0xb2>
80007ea6:	a3 b4       	sbr	r4,0x3
80007ea8:	cd d8       	rjmp	80008062 <get_arg+0x266>
80007eaa:	a5 b4       	sbr	r4,0x5
80007eac:	cd b8       	rjmp	80008062 <get_arg+0x266>
80007eae:	08 9a       	mov	r10,r4
80007eb0:	0e 9b       	mov	r11,r7
80007eb2:	a5 aa       	sbr	r10,0x4
80007eb4:	17 3c       	ld.ub	r12,r11++
80007eb6:	a5 b4       	sbr	r4,0x5
80007eb8:	36 ce       	mov	lr,108
80007eba:	fc 0c 18 00 	cp.b	r12,lr
80007ebe:	e0 80 00 d3 	breq	80008064 <get_arg+0x268>
80007ec2:	14 94       	mov	r4,r10
80007ec4:	cc f8       	rjmp	80008062 <get_arg+0x266>
80007ec6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007eca:	36 7c       	mov	r12,103
80007ecc:	f8 0a 18 00 	cp.b	r10,r12
80007ed0:	e0 8b 00 27 	brhi	80007f1e <get_arg+0x122>
80007ed4:	36 5b       	mov	r11,101
80007ed6:	f6 0a 18 00 	cp.b	r10,r11
80007eda:	c4 82       	brcc	80007f6a <get_arg+0x16e>
80007edc:	34 fb       	mov	r11,79
80007ede:	f6 0a 18 00 	cp.b	r10,r11
80007ee2:	c4 80       	breq	80007f72 <get_arg+0x176>
80007ee4:	e0 8b 00 0c 	brhi	80007efc <get_arg+0x100>
80007ee8:	34 5b       	mov	r11,69
80007eea:	f6 0a 18 00 	cp.b	r10,r11
80007eee:	c3 e0       	breq	80007f6a <get_arg+0x16e>
80007ef0:	34 7b       	mov	r11,71
80007ef2:	f6 0a 18 00 	cp.b	r10,r11
80007ef6:	c3 a0       	breq	80007f6a <get_arg+0x16e>
80007ef8:	34 4b       	mov	r11,68
80007efa:	c0 88       	rjmp	80007f0a <get_arg+0x10e>
80007efc:	35 8b       	mov	r11,88
80007efe:	f6 0a 18 00 	cp.b	r10,r11
80007f02:	c2 c0       	breq	80007f5a <get_arg+0x15e>
80007f04:	e0 8b 00 07 	brhi	80007f12 <get_arg+0x116>
80007f08:	35 5b       	mov	r11,85
80007f0a:	f6 0a 18 00 	cp.b	r10,r11
80007f0e:	c3 51       	brne	80007f78 <get_arg+0x17c>
80007f10:	c3 18       	rjmp	80007f72 <get_arg+0x176>
80007f12:	36 3b       	mov	r11,99
80007f14:	f6 0a 18 00 	cp.b	r10,r11
80007f18:	c2 f0       	breq	80007f76 <get_arg+0x17a>
80007f1a:	36 4b       	mov	r11,100
80007f1c:	c0 e8       	rjmp	80007f38 <get_arg+0x13c>
80007f1e:	37 0b       	mov	r11,112
80007f20:	f6 0a 18 00 	cp.b	r10,r11
80007f24:	c2 50       	breq	80007f6e <get_arg+0x172>
80007f26:	e0 8b 00 0d 	brhi	80007f40 <get_arg+0x144>
80007f2a:	36 eb       	mov	r11,110
80007f2c:	f6 0a 18 00 	cp.b	r10,r11
80007f30:	c1 f0       	breq	80007f6e <get_arg+0x172>
80007f32:	e0 8b 00 14 	brhi	80007f5a <get_arg+0x15e>
80007f36:	36 9b       	mov	r11,105
80007f38:	f6 0a 18 00 	cp.b	r10,r11
80007f3c:	c1 e1       	brne	80007f78 <get_arg+0x17c>
80007f3e:	c0 e8       	rjmp	80007f5a <get_arg+0x15e>
80007f40:	37 5b       	mov	r11,117
80007f42:	f6 0a 18 00 	cp.b	r10,r11
80007f46:	c0 a0       	breq	80007f5a <get_arg+0x15e>
80007f48:	37 8b       	mov	r11,120
80007f4a:	f6 0a 18 00 	cp.b	r10,r11
80007f4e:	c0 60       	breq	80007f5a <get_arg+0x15e>
80007f50:	37 3b       	mov	r11,115
80007f52:	f6 0a 18 00 	cp.b	r10,r11
80007f56:	c1 11       	brne	80007f78 <get_arg+0x17c>
80007f58:	c0 b8       	rjmp	80007f6e <get_arg+0x172>
80007f5a:	ed b4 00 04 	bld	r4,0x4
80007f5e:	c0 a0       	breq	80007f72 <get_arg+0x176>
80007f60:	ed b4 00 05 	bld	r4,0x5
80007f64:	c0 91       	brne	80007f76 <get_arg+0x17a>
80007f66:	30 20       	mov	r0,2
80007f68:	c0 88       	rjmp	80007f78 <get_arg+0x17c>
80007f6a:	30 40       	mov	r0,4
80007f6c:	c0 68       	rjmp	80007f78 <get_arg+0x17c>
80007f6e:	30 30       	mov	r0,3
80007f70:	c0 48       	rjmp	80007f78 <get_arg+0x17c>
80007f72:	30 10       	mov	r0,1
80007f74:	c0 28       	rjmp	80007f78 <get_arg+0x17c>
80007f76:	30 00       	mov	r0,0
80007f78:	40 3b       	lddsp	r11,sp[0xc]
80007f7a:	5b fb       	cp.w	r11,-1
80007f7c:	c0 40       	breq	80007f84 <get_arg+0x188>
80007f7e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f82:	c7 08       	rjmp	80008062 <get_arg+0x266>
80007f84:	58 60       	cp.w	r0,6
80007f86:	e0 8b 00 6e 	brhi	80008062 <get_arg+0x266>
80007f8a:	6c 0a       	ld.w	r10,r6[0x0]
80007f8c:	ea cc ff ff 	sub	r12,r5,-1
80007f90:	fe ce a2 44 	sub	lr,pc,-23996
80007f94:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f98:	f4 cb ff f8 	sub	r11,r10,-8
80007f9c:	8d 0b       	st.w	r6[0x0],r11
80007f9e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007fa2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007fa6:	c0 f8       	rjmp	80007fc4 <get_arg+0x1c8>
80007fa8:	f4 cb ff fc 	sub	r11,r10,-4
80007fac:	8d 0b       	st.w	r6[0x0],r11
80007fae:	74 0a       	ld.w	r10,r10[0x0]
80007fb0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007fb4:	c0 88       	rjmp	80007fc4 <get_arg+0x1c8>
80007fb6:	f4 cb ff f8 	sub	r11,r10,-8
80007fba:	8d 0b       	st.w	r6[0x0],r11
80007fbc:	f4 ea 00 00 	ld.d	r10,r10[0]
80007fc0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007fc4:	0e 9b       	mov	r11,r7
80007fc6:	18 95       	mov	r5,r12
80007fc8:	c4 e8       	rjmp	80008064 <get_arg+0x268>
80007fca:	62 0a       	ld.w	r10,r1[0x0]
80007fcc:	5b fa       	cp.w	r10,-1
80007fce:	c0 b1       	brne	80007fe4 <get_arg+0x1e8>
80007fd0:	50 19       	stdsp	sp[0x4],r9
80007fd2:	50 28       	stdsp	sp[0x8],r8
80007fd4:	e0 6a 00 80 	mov	r10,128
80007fd8:	30 0b       	mov	r11,0
80007fda:	02 9c       	mov	r12,r1
80007fdc:	fe b0 fd 00 	rcall	800079dc <memset>
80007fe0:	40 28       	lddsp	r8,sp[0x8]
80007fe2:	40 19       	lddsp	r9,sp[0x4]
80007fe4:	e4 cc 00 01 	sub	r12,r2,1
80007fe8:	0e 9b       	mov	r11,r7
80007fea:	50 3c       	stdsp	sp[0xc],r12
80007fec:	f2 0c 0c 49 	max	r9,r9,r12
80007ff0:	c3 a8       	rjmp	80008064 <get_arg+0x268>
80007ff2:	62 0a       	ld.w	r10,r1[0x0]
80007ff4:	5b fa       	cp.w	r10,-1
80007ff6:	c0 b1       	brne	8000800c <get_arg+0x210>
80007ff8:	50 19       	stdsp	sp[0x4],r9
80007ffa:	50 28       	stdsp	sp[0x8],r8
80007ffc:	e0 6a 00 80 	mov	r10,128
80008000:	30 0b       	mov	r11,0
80008002:	02 9c       	mov	r12,r1
80008004:	fe b0 fc ec 	rcall	800079dc <memset>
80008008:	40 28       	lddsp	r8,sp[0x8]
8000800a:	40 19       	lddsp	r9,sp[0x4]
8000800c:	20 12       	sub	r2,1
8000800e:	30 0a       	mov	r10,0
80008010:	0e 9b       	mov	r11,r7
80008012:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008016:	f2 02 0c 49 	max	r9,r9,r2
8000801a:	c2 58       	rjmp	80008064 <get_arg+0x268>
8000801c:	16 97       	mov	r7,r11
8000801e:	6c 0a       	ld.w	r10,r6[0x0]
80008020:	f4 cb ff fc 	sub	r11,r10,-4
80008024:	8d 0b       	st.w	r6[0x0],r11
80008026:	74 0a       	ld.w	r10,r10[0x0]
80008028:	0e 9b       	mov	r11,r7
8000802a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000802e:	2f f5       	sub	r5,-1
80008030:	c1 a8       	rjmp	80008064 <get_arg+0x268>
80008032:	f4 c2 00 30 	sub	r2,r10,48
80008036:	c0 68       	rjmp	80008042 <get_arg+0x246>
80008038:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000803c:	2f f7       	sub	r7,-1
8000803e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008042:	0f 8a       	ld.ub	r10,r7[0x0]
80008044:	58 0a       	cp.w	r10,0
80008046:	c0 e0       	breq	80008062 <get_arg+0x266>
80008048:	23 0a       	sub	r10,48
8000804a:	58 9a       	cp.w	r10,9
8000804c:	fe 98 ff f6 	brls	80008038 <get_arg+0x23c>
80008050:	c0 98       	rjmp	80008062 <get_arg+0x266>
80008052:	2f f7       	sub	r7,-1
80008054:	0f 8a       	ld.ub	r10,r7[0x0]
80008056:	58 0a       	cp.w	r10,0
80008058:	c0 50       	breq	80008062 <get_arg+0x266>
8000805a:	23 0a       	sub	r10,48
8000805c:	58 9a       	cp.w	r10,9
8000805e:	fe 98 ff fa 	brls	80008052 <get_arg+0x256>
80008062:	0e 9b       	mov	r11,r7
80008064:	40 7c       	lddsp	r12,sp[0x1c]
80008066:	30 ba       	mov	r10,11
80008068:	f4 0c 18 00 	cp.b	r12,r10
8000806c:	fe 91 fe f2 	brne	80007e50 <get_arg+0x54>
80008070:	40 42       	lddsp	r2,sp[0x10]
80008072:	17 8c       	ld.ub	r12,r11[0x0]
80008074:	0a 32       	cp.w	r2,r5
80008076:	5f 4a       	srge	r10
80008078:	f0 0c 18 00 	cp.b	r12,r8
8000807c:	5f 1c       	srne	r12
8000807e:	f9 ea 00 0a 	and	r10,r12,r10
80008082:	f0 0a 18 00 	cp.b	r10,r8
80008086:	fe 91 fe cf 	brne	80007e24 <get_arg+0x28>
8000808a:	30 08       	mov	r8,0
8000808c:	40 4e       	lddsp	lr,sp[0x10]
8000808e:	17 8a       	ld.ub	r10,r11[0x0]
80008090:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008094:	f0 0a 18 00 	cp.b	r10,r8
80008098:	fc 09 17 10 	movne	r9,lr
8000809c:	e6 05 00 38 	add	r8,r3,r5<<0x3
800080a0:	06 9e       	mov	lr,r3
800080a2:	c2 a8       	rjmp	800080f6 <get_arg+0x2fa>
800080a4:	62 0a       	ld.w	r10,r1[0x0]
800080a6:	58 3a       	cp.w	r10,3
800080a8:	c1 e0       	breq	800080e4 <get_arg+0x2e8>
800080aa:	e0 89 00 07 	brgt	800080b8 <get_arg+0x2bc>
800080ae:	58 1a       	cp.w	r10,1
800080b0:	c1 a0       	breq	800080e4 <get_arg+0x2e8>
800080b2:	58 2a       	cp.w	r10,2
800080b4:	c1 81       	brne	800080e4 <get_arg+0x2e8>
800080b6:	c0 58       	rjmp	800080c0 <get_arg+0x2c4>
800080b8:	58 5a       	cp.w	r10,5
800080ba:	c0 c0       	breq	800080d2 <get_arg+0x2d6>
800080bc:	c0 b5       	brlt	800080d2 <get_arg+0x2d6>
800080be:	c1 38       	rjmp	800080e4 <get_arg+0x2e8>
800080c0:	6c 0a       	ld.w	r10,r6[0x0]
800080c2:	f4 cc ff f8 	sub	r12,r10,-8
800080c6:	8d 0c       	st.w	r6[0x0],r12
800080c8:	f4 e2 00 00 	ld.d	r2,r10[0]
800080cc:	f0 e3 00 00 	st.d	r8[0],r2
800080d0:	c1 08       	rjmp	800080f0 <get_arg+0x2f4>
800080d2:	6c 0a       	ld.w	r10,r6[0x0]
800080d4:	f4 cc ff f8 	sub	r12,r10,-8
800080d8:	8d 0c       	st.w	r6[0x0],r12
800080da:	f4 e2 00 00 	ld.d	r2,r10[0]
800080de:	f0 e3 00 00 	st.d	r8[0],r2
800080e2:	c0 78       	rjmp	800080f0 <get_arg+0x2f4>
800080e4:	6c 0a       	ld.w	r10,r6[0x0]
800080e6:	f4 cc ff fc 	sub	r12,r10,-4
800080ea:	8d 0c       	st.w	r6[0x0],r12
800080ec:	74 0a       	ld.w	r10,r10[0x0]
800080ee:	91 0a       	st.w	r8[0x0],r10
800080f0:	2f f5       	sub	r5,-1
800080f2:	2f 88       	sub	r8,-8
800080f4:	2f c1       	sub	r1,-4
800080f6:	12 35       	cp.w	r5,r9
800080f8:	fe 9a ff d6 	brle	800080a4 <get_arg+0x2a8>
800080fc:	1c 93       	mov	r3,lr
800080fe:	40 52       	lddsp	r2,sp[0x14]
80008100:	40 6e       	lddsp	lr,sp[0x18]
80008102:	85 05       	st.w	r2[0x0],r5
80008104:	9d 0b       	st.w	lr[0x0],r11
80008106:	40 4b       	lddsp	r11,sp[0x10]
80008108:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000810c:	2f 8d       	sub	sp,-32
8000810e:	d8 32       	popm	r0-r7,pc

80008110 <__sprint_r>:
80008110:	d4 21       	pushm	r4-r7,lr
80008112:	14 97       	mov	r7,r10
80008114:	74 28       	ld.w	r8,r10[0x8]
80008116:	58 08       	cp.w	r8,0
80008118:	c0 41       	brne	80008120 <__sprint_r+0x10>
8000811a:	95 18       	st.w	r10[0x4],r8
8000811c:	10 9c       	mov	r12,r8
8000811e:	d8 22       	popm	r4-r7,pc
80008120:	e0 a0 18 ba 	rcall	8000b294 <__sfvwrite_r>
80008124:	30 08       	mov	r8,0
80008126:	8f 18       	st.w	r7[0x4],r8
80008128:	8f 28       	st.w	r7[0x8],r8
8000812a:	d8 22       	popm	r4-r7,pc

8000812c <_vfprintf_r>:
8000812c:	d4 31       	pushm	r0-r7,lr
8000812e:	fa cd 06 bc 	sub	sp,sp,1724
80008132:	51 09       	stdsp	sp[0x40],r9
80008134:	16 91       	mov	r1,r11
80008136:	14 97       	mov	r7,r10
80008138:	18 95       	mov	r5,r12
8000813a:	e0 a0 1a 1d 	rcall	8000b574 <_localeconv_r>
8000813e:	78 0c       	ld.w	r12,r12[0x0]
80008140:	50 cc       	stdsp	sp[0x30],r12
80008142:	58 05       	cp.w	r5,0
80008144:	c0 70       	breq	80008152 <_vfprintf_r+0x26>
80008146:	6a 68       	ld.w	r8,r5[0x18]
80008148:	58 08       	cp.w	r8,0
8000814a:	c0 41       	brne	80008152 <_vfprintf_r+0x26>
8000814c:	0a 9c       	mov	r12,r5
8000814e:	e0 a0 17 43 	rcall	8000afd4 <__sinit>
80008152:	fe c8 a0 42 	sub	r8,pc,-24510
80008156:	10 31       	cp.w	r1,r8
80008158:	c0 31       	brne	8000815e <_vfprintf_r+0x32>
8000815a:	6a 01       	ld.w	r1,r5[0x0]
8000815c:	c0 c8       	rjmp	80008174 <_vfprintf_r+0x48>
8000815e:	fe c8 a0 2e 	sub	r8,pc,-24530
80008162:	10 31       	cp.w	r1,r8
80008164:	c0 31       	brne	8000816a <_vfprintf_r+0x3e>
80008166:	6a 11       	ld.w	r1,r5[0x4]
80008168:	c0 68       	rjmp	80008174 <_vfprintf_r+0x48>
8000816a:	fe c8 a0 1a 	sub	r8,pc,-24550
8000816e:	10 31       	cp.w	r1,r8
80008170:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008174:	82 68       	ld.sh	r8,r1[0xc]
80008176:	ed b8 00 03 	bld	r8,0x3
8000817a:	c0 41       	brne	80008182 <_vfprintf_r+0x56>
8000817c:	62 48       	ld.w	r8,r1[0x10]
8000817e:	58 08       	cp.w	r8,0
80008180:	c0 71       	brne	8000818e <_vfprintf_r+0x62>
80008182:	02 9b       	mov	r11,r1
80008184:	0a 9c       	mov	r12,r5
80008186:	e0 a0 0f 5d 	rcall	8000a040 <__swsetup_r>
8000818a:	e0 81 0f 54 	brne	8000a032 <_vfprintf_r+0x1f06>
8000818e:	82 68       	ld.sh	r8,r1[0xc]
80008190:	10 99       	mov	r9,r8
80008192:	e2 19 00 1a 	andl	r9,0x1a,COH
80008196:	58 a9       	cp.w	r9,10
80008198:	c3 c1       	brne	80008210 <_vfprintf_r+0xe4>
8000819a:	82 79       	ld.sh	r9,r1[0xe]
8000819c:	30 0a       	mov	r10,0
8000819e:	f4 09 19 00 	cp.h	r9,r10
800081a2:	c3 75       	brlt	80008210 <_vfprintf_r+0xe4>
800081a4:	a1 d8       	cbr	r8,0x1
800081a6:	fb 58 05 d0 	st.h	sp[1488],r8
800081aa:	62 88       	ld.w	r8,r1[0x20]
800081ac:	fb 48 05 e4 	st.w	sp[1508],r8
800081b0:	62 a8       	ld.w	r8,r1[0x28]
800081b2:	fb 48 05 ec 	st.w	sp[1516],r8
800081b6:	fa c8 ff bc 	sub	r8,sp,-68
800081ba:	fb 48 05 d4 	st.w	sp[1492],r8
800081be:	fb 48 05 c4 	st.w	sp[1476],r8
800081c2:	e0 68 04 00 	mov	r8,1024
800081c6:	fb 48 05 d8 	st.w	sp[1496],r8
800081ca:	fb 48 05 cc 	st.w	sp[1484],r8
800081ce:	30 08       	mov	r8,0
800081d0:	fb 59 05 d2 	st.h	sp[1490],r9
800081d4:	0e 9a       	mov	r10,r7
800081d6:	41 09       	lddsp	r9,sp[0x40]
800081d8:	fa c7 fa 3c 	sub	r7,sp,-1476
800081dc:	fb 48 05 dc 	st.w	sp[1500],r8
800081e0:	0a 9c       	mov	r12,r5
800081e2:	0e 9b       	mov	r11,r7
800081e4:	ca 4f       	rcall	8000812c <_vfprintf_r>
800081e6:	50 bc       	stdsp	sp[0x2c],r12
800081e8:	c0 95       	brlt	800081fa <_vfprintf_r+0xce>
800081ea:	0e 9b       	mov	r11,r7
800081ec:	0a 9c       	mov	r12,r5
800081ee:	e0 a0 16 1b 	rcall	8000ae24 <_fflush_r>
800081f2:	40 be       	lddsp	lr,sp[0x2c]
800081f4:	f9 be 01 ff 	movne	lr,-1
800081f8:	50 be       	stdsp	sp[0x2c],lr
800081fa:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081fe:	ed b8 00 06 	bld	r8,0x6
80008202:	e0 81 0f 1a 	brne	8000a036 <_vfprintf_r+0x1f0a>
80008206:	82 68       	ld.sh	r8,r1[0xc]
80008208:	a7 a8       	sbr	r8,0x6
8000820a:	a2 68       	st.h	r1[0xc],r8
8000820c:	e0 8f 0f 15 	bral	8000a036 <_vfprintf_r+0x1f0a>
80008210:	30 08       	mov	r8,0
80008212:	fb 48 06 b4 	st.w	sp[1716],r8
80008216:	fb 48 06 90 	st.w	sp[1680],r8
8000821a:	fb 48 06 8c 	st.w	sp[1676],r8
8000821e:	fb 48 06 b0 	st.w	sp[1712],r8
80008222:	30 08       	mov	r8,0
80008224:	30 09       	mov	r9,0
80008226:	50 a7       	stdsp	sp[0x28],r7
80008228:	50 78       	stdsp	sp[0x1c],r8
8000822a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000822e:	3f f8       	mov	r8,-1
80008230:	50 59       	stdsp	sp[0x14],r9
80008232:	fb 43 06 88 	st.w	sp[1672],r3
80008236:	fb 48 05 44 	st.w	sp[1348],r8
8000823a:	12 9c       	mov	r12,r9
8000823c:	50 69       	stdsp	sp[0x18],r9
8000823e:	50 d9       	stdsp	sp[0x34],r9
80008240:	50 e9       	stdsp	sp[0x38],r9
80008242:	50 b9       	stdsp	sp[0x2c],r9
80008244:	12 97       	mov	r7,r9
80008246:	0a 94       	mov	r4,r5
80008248:	40 a2       	lddsp	r2,sp[0x28]
8000824a:	32 5a       	mov	r10,37
8000824c:	30 08       	mov	r8,0
8000824e:	c0 28       	rjmp	80008252 <_vfprintf_r+0x126>
80008250:	2f f2       	sub	r2,-1
80008252:	05 89       	ld.ub	r9,r2[0x0]
80008254:	f0 09 18 00 	cp.b	r9,r8
80008258:	5f 1b       	srne	r11
8000825a:	f4 09 18 00 	cp.b	r9,r10
8000825e:	5f 19       	srne	r9
80008260:	f3 eb 00 0b 	and	r11,r9,r11
80008264:	f0 0b 18 00 	cp.b	r11,r8
80008268:	cf 41       	brne	80008250 <_vfprintf_r+0x124>
8000826a:	40 ab       	lddsp	r11,sp[0x28]
8000826c:	e4 0b 01 06 	sub	r6,r2,r11
80008270:	c1 e0       	breq	800082ac <_vfprintf_r+0x180>
80008272:	fa f8 06 90 	ld.w	r8,sp[1680]
80008276:	0c 08       	add	r8,r6
80008278:	87 0b       	st.w	r3[0x0],r11
8000827a:	fb 48 06 90 	st.w	sp[1680],r8
8000827e:	87 16       	st.w	r3[0x4],r6
80008280:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008284:	2f f8       	sub	r8,-1
80008286:	fb 48 06 8c 	st.w	sp[1676],r8
8000828a:	58 78       	cp.w	r8,7
8000828c:	e0 89 00 04 	brgt	80008294 <_vfprintf_r+0x168>
80008290:	2f 83       	sub	r3,-8
80008292:	c0 a8       	rjmp	800082a6 <_vfprintf_r+0x17a>
80008294:	fa ca f9 78 	sub	r10,sp,-1672
80008298:	02 9b       	mov	r11,r1
8000829a:	08 9c       	mov	r12,r4
8000829c:	c3 af       	rcall	80008110 <__sprint_r>
8000829e:	e0 81 0e c6 	brne	8000a02a <_vfprintf_r+0x1efe>
800082a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800082a6:	40 ba       	lddsp	r10,sp[0x2c]
800082a8:	0c 0a       	add	r10,r6
800082aa:	50 ba       	stdsp	sp[0x2c],r10
800082ac:	05 89       	ld.ub	r9,r2[0x0]
800082ae:	30 08       	mov	r8,0
800082b0:	f0 09 18 00 	cp.b	r9,r8
800082b4:	e0 80 0e aa 	breq	8000a008 <_vfprintf_r+0x1edc>
800082b8:	30 09       	mov	r9,0
800082ba:	fb 68 06 bb 	st.b	sp[1723],r8
800082be:	0e 96       	mov	r6,r7
800082c0:	e4 c8 ff ff 	sub	r8,r2,-1
800082c4:	3f fe       	mov	lr,-1
800082c6:	50 93       	stdsp	sp[0x24],r3
800082c8:	50 41       	stdsp	sp[0x10],r1
800082ca:	0e 93       	mov	r3,r7
800082cc:	04 91       	mov	r1,r2
800082ce:	50 89       	stdsp	sp[0x20],r9
800082d0:	50 a8       	stdsp	sp[0x28],r8
800082d2:	50 2e       	stdsp	sp[0x8],lr
800082d4:	50 39       	stdsp	sp[0xc],r9
800082d6:	12 95       	mov	r5,r9
800082d8:	12 90       	mov	r0,r9
800082da:	10 97       	mov	r7,r8
800082dc:	08 92       	mov	r2,r4
800082de:	c0 78       	rjmp	800082ec <_vfprintf_r+0x1c0>
800082e0:	3f fc       	mov	r12,-1
800082e2:	08 97       	mov	r7,r4
800082e4:	50 2c       	stdsp	sp[0x8],r12
800082e6:	c0 38       	rjmp	800082ec <_vfprintf_r+0x1c0>
800082e8:	30 0b       	mov	r11,0
800082ea:	50 3b       	stdsp	sp[0xc],r11
800082ec:	0f 38       	ld.ub	r8,r7++
800082ee:	c0 28       	rjmp	800082f2 <_vfprintf_r+0x1c6>
800082f0:	12 90       	mov	r0,r9
800082f2:	f0 c9 00 20 	sub	r9,r8,32
800082f6:	e0 49 00 58 	cp.w	r9,88
800082fa:	e0 8b 0a 30 	brhi	8000975a <_vfprintf_r+0x162e>
800082fe:	fe ca a5 96 	sub	r10,pc,-23146
80008302:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008306:	50 a7       	stdsp	sp[0x28],r7
80008308:	50 80       	stdsp	sp[0x20],r0
8000830a:	0c 97       	mov	r7,r6
8000830c:	04 94       	mov	r4,r2
8000830e:	06 96       	mov	r6,r3
80008310:	02 92       	mov	r2,r1
80008312:	fe c9 a3 6e 	sub	r9,pc,-23698
80008316:	40 93       	lddsp	r3,sp[0x24]
80008318:	10 90       	mov	r0,r8
8000831a:	40 41       	lddsp	r1,sp[0x10]
8000831c:	50 d9       	stdsp	sp[0x34],r9
8000831e:	e0 8f 08 8e 	bral	8000943a <_vfprintf_r+0x130e>
80008322:	30 08       	mov	r8,0
80008324:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008328:	f0 09 18 00 	cp.b	r9,r8
8000832c:	ce 01       	brne	800082ec <_vfprintf_r+0x1c0>
8000832e:	32 08       	mov	r8,32
80008330:	c6 e8       	rjmp	8000840c <_vfprintf_r+0x2e0>
80008332:	a1 a5       	sbr	r5,0x0
80008334:	cd cb       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008336:	0f 89       	ld.ub	r9,r7[0x0]
80008338:	f2 c8 00 30 	sub	r8,r9,48
8000833c:	58 98       	cp.w	r8,9
8000833e:	e0 8b 00 1d 	brhi	80008378 <_vfprintf_r+0x24c>
80008342:	ee c8 ff ff 	sub	r8,r7,-1
80008346:	30 0b       	mov	r11,0
80008348:	23 09       	sub	r9,48
8000834a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000834e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008352:	11 39       	ld.ub	r9,r8++
80008354:	f2 ca 00 30 	sub	r10,r9,48
80008358:	58 9a       	cp.w	r10,9
8000835a:	fe 98 ff f7 	brls	80008348 <_vfprintf_r+0x21c>
8000835e:	e0 49 00 24 	cp.w	r9,36
80008362:	cc 31       	brne	800082e8 <_vfprintf_r+0x1bc>
80008364:	e0 4b 00 20 	cp.w	r11,32
80008368:	e0 89 0e 60 	brgt	8000a028 <_vfprintf_r+0x1efc>
8000836c:	20 1b       	sub	r11,1
8000836e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008372:	12 3b       	cp.w	r11,r9
80008374:	c0 95       	brlt	80008386 <_vfprintf_r+0x25a>
80008376:	c1 08       	rjmp	80008396 <_vfprintf_r+0x26a>
80008378:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000837c:	ec ca ff ff 	sub	r10,r6,-1
80008380:	12 36       	cp.w	r6,r9
80008382:	c1 f5       	brlt	800083c0 <_vfprintf_r+0x294>
80008384:	c2 68       	rjmp	800083d0 <_vfprintf_r+0x2a4>
80008386:	fa ce f9 44 	sub	lr,sp,-1724
8000838a:	10 97       	mov	r7,r8
8000838c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008390:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008394:	c3 58       	rjmp	800083fe <_vfprintf_r+0x2d2>
80008396:	10 97       	mov	r7,r8
80008398:	fa c8 f9 50 	sub	r8,sp,-1712
8000839c:	1a d8       	st.w	--sp,r8
8000839e:	fa c8 fa b8 	sub	r8,sp,-1352
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	fa c8 fb b4 	sub	r8,sp,-1100
800083a8:	02 9a       	mov	r10,r1
800083aa:	1a d8       	st.w	--sp,r8
800083ac:	04 9c       	mov	r12,r2
800083ae:	fa c8 f9 40 	sub	r8,sp,-1728
800083b2:	fa c9 ff b4 	sub	r9,sp,-76
800083b6:	fe b0 fd 23 	rcall	80007dfc <get_arg>
800083ba:	2f dd       	sub	sp,-12
800083bc:	78 00       	ld.w	r0,r12[0x0]
800083be:	c2 08       	rjmp	800083fe <_vfprintf_r+0x2d2>
800083c0:	fa cc f9 44 	sub	r12,sp,-1724
800083c4:	14 96       	mov	r6,r10
800083c6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800083ca:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800083ce:	c1 88       	rjmp	800083fe <_vfprintf_r+0x2d2>
800083d0:	41 08       	lddsp	r8,sp[0x40]
800083d2:	59 f9       	cp.w	r9,31
800083d4:	e0 89 00 11 	brgt	800083f6 <_vfprintf_r+0x2ca>
800083d8:	f0 cb ff fc 	sub	r11,r8,-4
800083dc:	51 0b       	stdsp	sp[0x40],r11
800083de:	70 00       	ld.w	r0,r8[0x0]
800083e0:	fa cb f9 44 	sub	r11,sp,-1724
800083e4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800083e8:	f1 40 fd 88 	st.w	r8[-632],r0
800083ec:	2f f9       	sub	r9,-1
800083ee:	14 96       	mov	r6,r10
800083f0:	fb 49 06 b4 	st.w	sp[1716],r9
800083f4:	c0 58       	rjmp	800083fe <_vfprintf_r+0x2d2>
800083f6:	70 00       	ld.w	r0,r8[0x0]
800083f8:	14 96       	mov	r6,r10
800083fa:	2f c8       	sub	r8,-4
800083fc:	51 08       	stdsp	sp[0x40],r8
800083fe:	58 00       	cp.w	r0,0
80008400:	fe 94 ff 76 	brge	800082ec <_vfprintf_r+0x1c0>
80008404:	5c 30       	neg	r0
80008406:	a3 a5       	sbr	r5,0x2
80008408:	c7 2b       	rjmp	800082ec <_vfprintf_r+0x1c0>
8000840a:	32 b8       	mov	r8,43
8000840c:	fb 68 06 bb 	st.b	sp[1723],r8
80008410:	c6 eb       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008412:	0f 38       	ld.ub	r8,r7++
80008414:	e0 48 00 2a 	cp.w	r8,42
80008418:	c0 30       	breq	8000841e <_vfprintf_r+0x2f2>
8000841a:	30 09       	mov	r9,0
8000841c:	c7 98       	rjmp	8000850e <_vfprintf_r+0x3e2>
8000841e:	0f 88       	ld.ub	r8,r7[0x0]
80008420:	f0 c9 00 30 	sub	r9,r8,48
80008424:	58 99       	cp.w	r9,9
80008426:	e0 8b 00 1f 	brhi	80008464 <_vfprintf_r+0x338>
8000842a:	ee c4 ff ff 	sub	r4,r7,-1
8000842e:	30 0b       	mov	r11,0
80008430:	23 08       	sub	r8,48
80008432:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008436:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000843a:	09 38       	ld.ub	r8,r4++
8000843c:	f0 c9 00 30 	sub	r9,r8,48
80008440:	58 99       	cp.w	r9,9
80008442:	fe 98 ff f7 	brls	80008430 <_vfprintf_r+0x304>
80008446:	e0 48 00 24 	cp.w	r8,36
8000844a:	fe 91 ff 4f 	brne	800082e8 <_vfprintf_r+0x1bc>
8000844e:	e0 4b 00 20 	cp.w	r11,32
80008452:	e0 89 0d eb 	brgt	8000a028 <_vfprintf_r+0x1efc>
80008456:	20 1b       	sub	r11,1
80008458:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000845c:	10 3b       	cp.w	r11,r8
8000845e:	c0 a5       	brlt	80008472 <_vfprintf_r+0x346>
80008460:	c1 18       	rjmp	80008482 <_vfprintf_r+0x356>
80008462:	d7 03       	nop
80008464:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008468:	ec c9 ff ff 	sub	r9,r6,-1
8000846c:	14 36       	cp.w	r6,r10
8000846e:	c1 f5       	brlt	800084ac <_vfprintf_r+0x380>
80008470:	c2 88       	rjmp	800084c0 <_vfprintf_r+0x394>
80008472:	fa ca f9 44 	sub	r10,sp,-1724
80008476:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000847a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000847e:	50 2b       	stdsp	sp[0x8],r11
80008480:	c3 c8       	rjmp	800084f8 <_vfprintf_r+0x3cc>
80008482:	fa c8 f9 50 	sub	r8,sp,-1712
80008486:	1a d8       	st.w	--sp,r8
80008488:	fa c8 fa b8 	sub	r8,sp,-1352
8000848c:	1a d8       	st.w	--sp,r8
8000848e:	fa c8 fb b4 	sub	r8,sp,-1100
80008492:	02 9a       	mov	r10,r1
80008494:	1a d8       	st.w	--sp,r8
80008496:	04 9c       	mov	r12,r2
80008498:	fa c8 f9 40 	sub	r8,sp,-1728
8000849c:	fa c9 ff b4 	sub	r9,sp,-76
800084a0:	fe b0 fc ae 	rcall	80007dfc <get_arg>
800084a4:	2f dd       	sub	sp,-12
800084a6:	78 0c       	ld.w	r12,r12[0x0]
800084a8:	50 2c       	stdsp	sp[0x8],r12
800084aa:	c2 78       	rjmp	800084f8 <_vfprintf_r+0x3cc>
800084ac:	12 96       	mov	r6,r9
800084ae:	0e 94       	mov	r4,r7
800084b0:	fa c9 f9 44 	sub	r9,sp,-1724
800084b4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800084b8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800084bc:	50 28       	stdsp	sp[0x8],r8
800084be:	c1 d8       	rjmp	800084f8 <_vfprintf_r+0x3cc>
800084c0:	41 08       	lddsp	r8,sp[0x40]
800084c2:	59 fa       	cp.w	r10,31
800084c4:	e0 89 00 14 	brgt	800084ec <_vfprintf_r+0x3c0>
800084c8:	f0 cb ff fc 	sub	r11,r8,-4
800084cc:	70 08       	ld.w	r8,r8[0x0]
800084ce:	51 0b       	stdsp	sp[0x40],r11
800084d0:	50 28       	stdsp	sp[0x8],r8
800084d2:	fa c6 f9 44 	sub	r6,sp,-1724
800084d6:	40 2e       	lddsp	lr,sp[0x8]
800084d8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800084dc:	f1 4e fd 88 	st.w	r8[-632],lr
800084e0:	2f fa       	sub	r10,-1
800084e2:	0e 94       	mov	r4,r7
800084e4:	fb 4a 06 b4 	st.w	sp[1716],r10
800084e8:	12 96       	mov	r6,r9
800084ea:	c0 78       	rjmp	800084f8 <_vfprintf_r+0x3cc>
800084ec:	70 0c       	ld.w	r12,r8[0x0]
800084ee:	0e 94       	mov	r4,r7
800084f0:	2f c8       	sub	r8,-4
800084f2:	50 2c       	stdsp	sp[0x8],r12
800084f4:	12 96       	mov	r6,r9
800084f6:	51 08       	stdsp	sp[0x40],r8
800084f8:	40 2b       	lddsp	r11,sp[0x8]
800084fa:	58 0b       	cp.w	r11,0
800084fc:	fe 95 fe f2 	brlt	800082e0 <_vfprintf_r+0x1b4>
80008500:	08 97       	mov	r7,r4
80008502:	cf 5a       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008504:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008508:	0f 38       	ld.ub	r8,r7++
8000850a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000850e:	f0 ca 00 30 	sub	r10,r8,48
80008512:	58 9a       	cp.w	r10,9
80008514:	fe 98 ff f8 	brls	80008504 <_vfprintf_r+0x3d8>
80008518:	3f fa       	mov	r10,-1
8000851a:	f2 0a 0c 49 	max	r9,r9,r10
8000851e:	50 29       	stdsp	sp[0x8],r9
80008520:	ce 9a       	rjmp	800082f2 <_vfprintf_r+0x1c6>
80008522:	a7 b5       	sbr	r5,0x7
80008524:	ce 4a       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008526:	30 09       	mov	r9,0
80008528:	23 08       	sub	r8,48
8000852a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000852e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008532:	0f 38       	ld.ub	r8,r7++
80008534:	f0 ca 00 30 	sub	r10,r8,48
80008538:	58 9a       	cp.w	r10,9
8000853a:	fe 98 ff f7 	brls	80008528 <_vfprintf_r+0x3fc>
8000853e:	e0 48 00 24 	cp.w	r8,36
80008542:	fe 91 fe d7 	brne	800082f0 <_vfprintf_r+0x1c4>
80008546:	e0 49 00 20 	cp.w	r9,32
8000854a:	e0 89 0d 6f 	brgt	8000a028 <_vfprintf_r+0x1efc>
8000854e:	f2 c3 00 01 	sub	r3,r9,1
80008552:	30 19       	mov	r9,1
80008554:	50 39       	stdsp	sp[0xc],r9
80008556:	cc ba       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008558:	a3 b5       	sbr	r5,0x3
8000855a:	cc 9a       	rjmp	800082ec <_vfprintf_r+0x1c0>
8000855c:	a7 a5       	sbr	r5,0x6
8000855e:	cc 7a       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008560:	0a 98       	mov	r8,r5
80008562:	a5 b5       	sbr	r5,0x5
80008564:	a5 a8       	sbr	r8,0x4
80008566:	0f 89       	ld.ub	r9,r7[0x0]
80008568:	36 ce       	mov	lr,108
8000856a:	fc 09 18 00 	cp.b	r9,lr
8000856e:	f7 b7 00 ff 	subeq	r7,-1
80008572:	f0 05 17 10 	movne	r5,r8
80008576:	cb ba       	rjmp	800082ec <_vfprintf_r+0x1c0>
80008578:	a5 b5       	sbr	r5,0x5
8000857a:	cb 9a       	rjmp	800082ec <_vfprintf_r+0x1c0>
8000857c:	50 a7       	stdsp	sp[0x28],r7
8000857e:	50 80       	stdsp	sp[0x20],r0
80008580:	0c 97       	mov	r7,r6
80008582:	10 90       	mov	r0,r8
80008584:	06 96       	mov	r6,r3
80008586:	04 94       	mov	r4,r2
80008588:	40 93       	lddsp	r3,sp[0x24]
8000858a:	02 92       	mov	r2,r1
8000858c:	0e 99       	mov	r9,r7
8000858e:	40 41       	lddsp	r1,sp[0x10]
80008590:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008594:	40 3c       	lddsp	r12,sp[0xc]
80008596:	58 0c       	cp.w	r12,0
80008598:	c1 d0       	breq	800085d2 <_vfprintf_r+0x4a6>
8000859a:	10 36       	cp.w	r6,r8
8000859c:	c0 64       	brge	800085a8 <_vfprintf_r+0x47c>
8000859e:	fa cb f9 44 	sub	r11,sp,-1724
800085a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085a6:	c1 d8       	rjmp	800085e0 <_vfprintf_r+0x4b4>
800085a8:	fa c8 f9 50 	sub	r8,sp,-1712
800085ac:	1a d8       	st.w	--sp,r8
800085ae:	fa c8 fa b8 	sub	r8,sp,-1352
800085b2:	1a d8       	st.w	--sp,r8
800085b4:	fa c8 fb b4 	sub	r8,sp,-1100
800085b8:	1a d8       	st.w	--sp,r8
800085ba:	fa c8 f9 40 	sub	r8,sp,-1728
800085be:	fa c9 ff b4 	sub	r9,sp,-76
800085c2:	04 9a       	mov	r10,r2
800085c4:	0c 9b       	mov	r11,r6
800085c6:	08 9c       	mov	r12,r4
800085c8:	fe b0 fc 1a 	rcall	80007dfc <get_arg>
800085cc:	2f dd       	sub	sp,-12
800085ce:	19 b8       	ld.ub	r8,r12[0x3]
800085d0:	c2 28       	rjmp	80008614 <_vfprintf_r+0x4e8>
800085d2:	2f f7       	sub	r7,-1
800085d4:	10 39       	cp.w	r9,r8
800085d6:	c0 84       	brge	800085e6 <_vfprintf_r+0x4ba>
800085d8:	fa ca f9 44 	sub	r10,sp,-1724
800085dc:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085e0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800085e4:	c1 88       	rjmp	80008614 <_vfprintf_r+0x4e8>
800085e6:	41 09       	lddsp	r9,sp[0x40]
800085e8:	59 f8       	cp.w	r8,31
800085ea:	e0 89 00 12 	brgt	8000860e <_vfprintf_r+0x4e2>
800085ee:	f2 ca ff fc 	sub	r10,r9,-4
800085f2:	51 0a       	stdsp	sp[0x40],r10
800085f4:	72 09       	ld.w	r9,r9[0x0]
800085f6:	fa c6 f9 44 	sub	r6,sp,-1724
800085fa:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085fe:	2f f8       	sub	r8,-1
80008600:	f5 49 fd 88 	st.w	r10[-632],r9
80008604:	fb 48 06 b4 	st.w	sp[1716],r8
80008608:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000860c:	c0 48       	rjmp	80008614 <_vfprintf_r+0x4e8>
8000860e:	13 b8       	ld.ub	r8,r9[0x3]
80008610:	2f c9       	sub	r9,-4
80008612:	51 09       	stdsp	sp[0x40],r9
80008614:	fb 68 06 60 	st.b	sp[1632],r8
80008618:	30 0e       	mov	lr,0
8000861a:	30 08       	mov	r8,0
8000861c:	30 12       	mov	r2,1
8000861e:	fb 68 06 bb 	st.b	sp[1723],r8
80008622:	50 2e       	stdsp	sp[0x8],lr
80008624:	e0 8f 08 ad 	bral	8000977e <_vfprintf_r+0x1652>
80008628:	50 a7       	stdsp	sp[0x28],r7
8000862a:	50 80       	stdsp	sp[0x20],r0
8000862c:	0c 97       	mov	r7,r6
8000862e:	04 94       	mov	r4,r2
80008630:	06 96       	mov	r6,r3
80008632:	02 92       	mov	r2,r1
80008634:	40 93       	lddsp	r3,sp[0x24]
80008636:	10 90       	mov	r0,r8
80008638:	40 41       	lddsp	r1,sp[0x10]
8000863a:	a5 a5       	sbr	r5,0x4
8000863c:	c0 a8       	rjmp	80008650 <_vfprintf_r+0x524>
8000863e:	50 a7       	stdsp	sp[0x28],r7
80008640:	50 80       	stdsp	sp[0x20],r0
80008642:	0c 97       	mov	r7,r6
80008644:	04 94       	mov	r4,r2
80008646:	06 96       	mov	r6,r3
80008648:	02 92       	mov	r2,r1
8000864a:	40 93       	lddsp	r3,sp[0x24]
8000864c:	10 90       	mov	r0,r8
8000864e:	40 41       	lddsp	r1,sp[0x10]
80008650:	ed b5 00 05 	bld	r5,0x5
80008654:	c5 11       	brne	800086f6 <_vfprintf_r+0x5ca>
80008656:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000865a:	40 3c       	lddsp	r12,sp[0xc]
8000865c:	58 0c       	cp.w	r12,0
8000865e:	c1 e0       	breq	8000869a <_vfprintf_r+0x56e>
80008660:	10 36       	cp.w	r6,r8
80008662:	c0 64       	brge	8000866e <_vfprintf_r+0x542>
80008664:	fa cb f9 44 	sub	r11,sp,-1724
80008668:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000866c:	c2 08       	rjmp	800086ac <_vfprintf_r+0x580>
8000866e:	fa c8 f9 50 	sub	r8,sp,-1712
80008672:	1a d8       	st.w	--sp,r8
80008674:	fa c8 fa b8 	sub	r8,sp,-1352
80008678:	0c 9b       	mov	r11,r6
8000867a:	1a d8       	st.w	--sp,r8
8000867c:	fa c8 fb b4 	sub	r8,sp,-1100
80008680:	1a d8       	st.w	--sp,r8
80008682:	fa c9 ff b4 	sub	r9,sp,-76
80008686:	fa c8 f9 40 	sub	r8,sp,-1728
8000868a:	04 9a       	mov	r10,r2
8000868c:	08 9c       	mov	r12,r4
8000868e:	fe b0 fb b7 	rcall	80007dfc <get_arg>
80008692:	2f dd       	sub	sp,-12
80008694:	78 1b       	ld.w	r11,r12[0x4]
80008696:	78 09       	ld.w	r9,r12[0x0]
80008698:	c2 b8       	rjmp	800086ee <_vfprintf_r+0x5c2>
8000869a:	ee ca ff ff 	sub	r10,r7,-1
8000869e:	10 37       	cp.w	r7,r8
800086a0:	c0 b4       	brge	800086b6 <_vfprintf_r+0x58a>
800086a2:	fa c9 f9 44 	sub	r9,sp,-1724
800086a6:	14 97       	mov	r7,r10
800086a8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086ac:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086b0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800086b4:	c1 d8       	rjmp	800086ee <_vfprintf_r+0x5c2>
800086b6:	41 09       	lddsp	r9,sp[0x40]
800086b8:	59 f8       	cp.w	r8,31
800086ba:	e0 89 00 14 	brgt	800086e2 <_vfprintf_r+0x5b6>
800086be:	f2 cb ff f8 	sub	r11,r9,-8
800086c2:	51 0b       	stdsp	sp[0x40],r11
800086c4:	fa c6 f9 44 	sub	r6,sp,-1724
800086c8:	72 1b       	ld.w	r11,r9[0x4]
800086ca:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800086ce:	72 09       	ld.w	r9,r9[0x0]
800086d0:	f9 4b fd 8c 	st.w	r12[-628],r11
800086d4:	f9 49 fd 88 	st.w	r12[-632],r9
800086d8:	2f f8       	sub	r8,-1
800086da:	14 97       	mov	r7,r10
800086dc:	fb 48 06 b4 	st.w	sp[1716],r8
800086e0:	c0 78       	rjmp	800086ee <_vfprintf_r+0x5c2>
800086e2:	f2 c8 ff f8 	sub	r8,r9,-8
800086e6:	72 1b       	ld.w	r11,r9[0x4]
800086e8:	14 97       	mov	r7,r10
800086ea:	51 08       	stdsp	sp[0x40],r8
800086ec:	72 09       	ld.w	r9,r9[0x0]
800086ee:	16 98       	mov	r8,r11
800086f0:	fa e9 00 00 	st.d	sp[0],r8
800086f4:	ca e8       	rjmp	80008850 <_vfprintf_r+0x724>
800086f6:	ed b5 00 04 	bld	r5,0x4
800086fa:	c1 71       	brne	80008728 <_vfprintf_r+0x5fc>
800086fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008700:	40 3e       	lddsp	lr,sp[0xc]
80008702:	58 0e       	cp.w	lr,0
80008704:	c0 80       	breq	80008714 <_vfprintf_r+0x5e8>
80008706:	10 36       	cp.w	r6,r8
80008708:	c6 94       	brge	800087da <_vfprintf_r+0x6ae>
8000870a:	fa cc f9 44 	sub	r12,sp,-1724
8000870e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008712:	c8 28       	rjmp	80008816 <_vfprintf_r+0x6ea>
80008714:	ee ca ff ff 	sub	r10,r7,-1
80008718:	10 37       	cp.w	r7,r8
8000871a:	e0 84 00 81 	brge	8000881c <_vfprintf_r+0x6f0>
8000871e:	fa cb f9 44 	sub	r11,sp,-1724
80008722:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008726:	c7 78       	rjmp	80008814 <_vfprintf_r+0x6e8>
80008728:	ed b5 00 06 	bld	r5,0x6
8000872c:	c4 b1       	brne	800087c2 <_vfprintf_r+0x696>
8000872e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008732:	40 3c       	lddsp	r12,sp[0xc]
80008734:	58 0c       	cp.w	r12,0
80008736:	c1 d0       	breq	80008770 <_vfprintf_r+0x644>
80008738:	10 36       	cp.w	r6,r8
8000873a:	c0 64       	brge	80008746 <_vfprintf_r+0x61a>
8000873c:	fa cb f9 44 	sub	r11,sp,-1724
80008740:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008744:	c1 f8       	rjmp	80008782 <_vfprintf_r+0x656>
80008746:	fa c8 f9 50 	sub	r8,sp,-1712
8000874a:	1a d8       	st.w	--sp,r8
8000874c:	fa c8 fa b8 	sub	r8,sp,-1352
80008750:	1a d8       	st.w	--sp,r8
80008752:	fa c8 fb b4 	sub	r8,sp,-1100
80008756:	1a d8       	st.w	--sp,r8
80008758:	fa c8 f9 40 	sub	r8,sp,-1728
8000875c:	fa c9 ff b4 	sub	r9,sp,-76
80008760:	04 9a       	mov	r10,r2
80008762:	0c 9b       	mov	r11,r6
80008764:	08 9c       	mov	r12,r4
80008766:	fe b0 fb 4b 	rcall	80007dfc <get_arg>
8000876a:	2f dd       	sub	sp,-12
8000876c:	98 18       	ld.sh	r8,r12[0x2]
8000876e:	c2 68       	rjmp	800087ba <_vfprintf_r+0x68e>
80008770:	ee ca ff ff 	sub	r10,r7,-1
80008774:	10 37       	cp.w	r7,r8
80008776:	c0 94       	brge	80008788 <_vfprintf_r+0x65c>
80008778:	fa c9 f9 44 	sub	r9,sp,-1724
8000877c:	14 97       	mov	r7,r10
8000877e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008782:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008786:	c1 a8       	rjmp	800087ba <_vfprintf_r+0x68e>
80008788:	41 09       	lddsp	r9,sp[0x40]
8000878a:	59 f8       	cp.w	r8,31
8000878c:	e0 89 00 13 	brgt	800087b2 <_vfprintf_r+0x686>
80008790:	f2 cb ff fc 	sub	r11,r9,-4
80008794:	51 0b       	stdsp	sp[0x40],r11
80008796:	72 09       	ld.w	r9,r9[0x0]
80008798:	fa c6 f9 44 	sub	r6,sp,-1724
8000879c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800087a0:	2f f8       	sub	r8,-1
800087a2:	f7 49 fd 88 	st.w	r11[-632],r9
800087a6:	fb 48 06 b4 	st.w	sp[1716],r8
800087aa:	14 97       	mov	r7,r10
800087ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800087b0:	c0 58       	rjmp	800087ba <_vfprintf_r+0x68e>
800087b2:	92 18       	ld.sh	r8,r9[0x2]
800087b4:	14 97       	mov	r7,r10
800087b6:	2f c9       	sub	r9,-4
800087b8:	51 09       	stdsp	sp[0x40],r9
800087ba:	50 18       	stdsp	sp[0x4],r8
800087bc:	bf 58       	asr	r8,0x1f
800087be:	50 08       	stdsp	sp[0x0],r8
800087c0:	c4 88       	rjmp	80008850 <_vfprintf_r+0x724>
800087c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087c6:	40 3c       	lddsp	r12,sp[0xc]
800087c8:	58 0c       	cp.w	r12,0
800087ca:	c1 d0       	breq	80008804 <_vfprintf_r+0x6d8>
800087cc:	10 36       	cp.w	r6,r8
800087ce:	c0 64       	brge	800087da <_vfprintf_r+0x6ae>
800087d0:	fa cb f9 44 	sub	r11,sp,-1724
800087d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087d8:	c1 f8       	rjmp	80008816 <_vfprintf_r+0x6ea>
800087da:	fa c8 f9 50 	sub	r8,sp,-1712
800087de:	1a d8       	st.w	--sp,r8
800087e0:	fa c8 fa b8 	sub	r8,sp,-1352
800087e4:	0c 9b       	mov	r11,r6
800087e6:	1a d8       	st.w	--sp,r8
800087e8:	fa c8 fb b4 	sub	r8,sp,-1100
800087ec:	04 9a       	mov	r10,r2
800087ee:	1a d8       	st.w	--sp,r8
800087f0:	08 9c       	mov	r12,r4
800087f2:	fa c8 f9 40 	sub	r8,sp,-1728
800087f6:	fa c9 ff b4 	sub	r9,sp,-76
800087fa:	fe b0 fb 01 	rcall	80007dfc <get_arg>
800087fe:	2f dd       	sub	sp,-12
80008800:	78 0b       	ld.w	r11,r12[0x0]
80008802:	c2 48       	rjmp	8000884a <_vfprintf_r+0x71e>
80008804:	ee ca ff ff 	sub	r10,r7,-1
80008808:	10 37       	cp.w	r7,r8
8000880a:	c0 94       	brge	8000881c <_vfprintf_r+0x6f0>
8000880c:	fa c9 f9 44 	sub	r9,sp,-1724
80008810:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008814:	14 97       	mov	r7,r10
80008816:	ec fb fd 88 	ld.w	r11,r6[-632]
8000881a:	c1 88       	rjmp	8000884a <_vfprintf_r+0x71e>
8000881c:	41 09       	lddsp	r9,sp[0x40]
8000881e:	59 f8       	cp.w	r8,31
80008820:	e0 89 00 11 	brgt	80008842 <_vfprintf_r+0x716>
80008824:	f2 cb ff fc 	sub	r11,r9,-4
80008828:	51 0b       	stdsp	sp[0x40],r11
8000882a:	fa c6 f9 44 	sub	r6,sp,-1724
8000882e:	72 0b       	ld.w	r11,r9[0x0]
80008830:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008834:	f3 4b fd 88 	st.w	r9[-632],r11
80008838:	2f f8       	sub	r8,-1
8000883a:	14 97       	mov	r7,r10
8000883c:	fb 48 06 b4 	st.w	sp[1716],r8
80008840:	c0 58       	rjmp	8000884a <_vfprintf_r+0x71e>
80008842:	72 0b       	ld.w	r11,r9[0x0]
80008844:	14 97       	mov	r7,r10
80008846:	2f c9       	sub	r9,-4
80008848:	51 09       	stdsp	sp[0x40],r9
8000884a:	50 1b       	stdsp	sp[0x4],r11
8000884c:	bf 5b       	asr	r11,0x1f
8000884e:	50 0b       	stdsp	sp[0x0],r11
80008850:	fa ea 00 00 	ld.d	r10,sp[0]
80008854:	58 0a       	cp.w	r10,0
80008856:	5c 2b       	cpc	r11
80008858:	c0 e4       	brge	80008874 <_vfprintf_r+0x748>
8000885a:	30 08       	mov	r8,0
8000885c:	fa ea 00 00 	ld.d	r10,sp[0]
80008860:	30 09       	mov	r9,0
80008862:	f0 0a 01 0a 	sub	r10,r8,r10
80008866:	f2 0b 01 4b 	sbc	r11,r9,r11
8000886a:	32 d8       	mov	r8,45
8000886c:	fa eb 00 00 	st.d	sp[0],r10
80008870:	fb 68 06 bb 	st.b	sp[1723],r8
80008874:	30 18       	mov	r8,1
80008876:	e0 8f 06 fa 	bral	8000966a <_vfprintf_r+0x153e>
8000887a:	50 a7       	stdsp	sp[0x28],r7
8000887c:	50 80       	stdsp	sp[0x20],r0
8000887e:	0c 97       	mov	r7,r6
80008880:	04 94       	mov	r4,r2
80008882:	06 96       	mov	r6,r3
80008884:	02 92       	mov	r2,r1
80008886:	40 93       	lddsp	r3,sp[0x24]
80008888:	10 90       	mov	r0,r8
8000888a:	40 41       	lddsp	r1,sp[0x10]
8000888c:	0e 99       	mov	r9,r7
8000888e:	ed b5 00 03 	bld	r5,0x3
80008892:	c4 11       	brne	80008914 <_vfprintf_r+0x7e8>
80008894:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008898:	40 3a       	lddsp	r10,sp[0xc]
8000889a:	58 0a       	cp.w	r10,0
8000889c:	c1 90       	breq	800088ce <_vfprintf_r+0x7a2>
8000889e:	10 36       	cp.w	r6,r8
800088a0:	c6 45       	brlt	80008968 <_vfprintf_r+0x83c>
800088a2:	fa c8 f9 50 	sub	r8,sp,-1712
800088a6:	1a d8       	st.w	--sp,r8
800088a8:	fa c8 fa b8 	sub	r8,sp,-1352
800088ac:	1a d8       	st.w	--sp,r8
800088ae:	fa c8 fb b4 	sub	r8,sp,-1100
800088b2:	0c 9b       	mov	r11,r6
800088b4:	1a d8       	st.w	--sp,r8
800088b6:	04 9a       	mov	r10,r2
800088b8:	fa c8 f9 40 	sub	r8,sp,-1728
800088bc:	fa c9 ff b4 	sub	r9,sp,-76
800088c0:	08 9c       	mov	r12,r4
800088c2:	fe b0 fa 9d 	rcall	80007dfc <get_arg>
800088c6:	2f dd       	sub	sp,-12
800088c8:	78 16       	ld.w	r6,r12[0x4]
800088ca:	50 76       	stdsp	sp[0x1c],r6
800088cc:	c4 88       	rjmp	8000895c <_vfprintf_r+0x830>
800088ce:	2f f7       	sub	r7,-1
800088d0:	10 39       	cp.w	r9,r8
800088d2:	c0 c4       	brge	800088ea <_vfprintf_r+0x7be>
800088d4:	fa ce f9 44 	sub	lr,sp,-1724
800088d8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800088dc:	ec fc fd 8c 	ld.w	r12,r6[-628]
800088e0:	50 7c       	stdsp	sp[0x1c],r12
800088e2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088e6:	50 56       	stdsp	sp[0x14],r6
800088e8:	c6 68       	rjmp	800089b4 <_vfprintf_r+0x888>
800088ea:	41 09       	lddsp	r9,sp[0x40]
800088ec:	59 f8       	cp.w	r8,31
800088ee:	e0 89 00 10 	brgt	8000890e <_vfprintf_r+0x7e2>
800088f2:	f2 ca ff f8 	sub	r10,r9,-8
800088f6:	72 1b       	ld.w	r11,r9[0x4]
800088f8:	51 0a       	stdsp	sp[0x40],r10
800088fa:	72 09       	ld.w	r9,r9[0x0]
800088fc:	fa ca f9 44 	sub	r10,sp,-1724
80008900:	50 7b       	stdsp	sp[0x1c],r11
80008902:	50 59       	stdsp	sp[0x14],r9
80008904:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008908:	40 5b       	lddsp	r11,sp[0x14]
8000890a:	40 7a       	lddsp	r10,sp[0x1c]
8000890c:	c4 78       	rjmp	8000899a <_vfprintf_r+0x86e>
8000890e:	72 18       	ld.w	r8,r9[0x4]
80008910:	50 78       	stdsp	sp[0x1c],r8
80008912:	c4 c8       	rjmp	800089aa <_vfprintf_r+0x87e>
80008914:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008918:	40 3e       	lddsp	lr,sp[0xc]
8000891a:	58 0e       	cp.w	lr,0
8000891c:	c2 30       	breq	80008962 <_vfprintf_r+0x836>
8000891e:	10 36       	cp.w	r6,r8
80008920:	c0 94       	brge	80008932 <_vfprintf_r+0x806>
80008922:	fa cc f9 44 	sub	r12,sp,-1724
80008926:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000892a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000892e:	50 7b       	stdsp	sp[0x1c],r11
80008930:	cd 9b       	rjmp	800088e2 <_vfprintf_r+0x7b6>
80008932:	fa c8 f9 50 	sub	r8,sp,-1712
80008936:	1a d8       	st.w	--sp,r8
80008938:	fa c8 fa b8 	sub	r8,sp,-1352
8000893c:	04 9a       	mov	r10,r2
8000893e:	1a d8       	st.w	--sp,r8
80008940:	fa c8 fb b4 	sub	r8,sp,-1100
80008944:	0c 9b       	mov	r11,r6
80008946:	1a d8       	st.w	--sp,r8
80008948:	08 9c       	mov	r12,r4
8000894a:	fa c8 f9 40 	sub	r8,sp,-1728
8000894e:	fa c9 ff b4 	sub	r9,sp,-76
80008952:	fe b0 fa 55 	rcall	80007dfc <get_arg>
80008956:	2f dd       	sub	sp,-12
80008958:	78 1a       	ld.w	r10,r12[0x4]
8000895a:	50 7a       	stdsp	sp[0x1c],r10
8000895c:	78 0c       	ld.w	r12,r12[0x0]
8000895e:	50 5c       	stdsp	sp[0x14],r12
80008960:	c2 a8       	rjmp	800089b4 <_vfprintf_r+0x888>
80008962:	2f f7       	sub	r7,-1
80008964:	10 39       	cp.w	r9,r8
80008966:	c0 94       	brge	80008978 <_vfprintf_r+0x84c>
80008968:	fa c9 f9 44 	sub	r9,sp,-1724
8000896c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008970:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008974:	50 78       	stdsp	sp[0x1c],r8
80008976:	cb 6b       	rjmp	800088e2 <_vfprintf_r+0x7b6>
80008978:	41 09       	lddsp	r9,sp[0x40]
8000897a:	59 f8       	cp.w	r8,31
8000897c:	e0 89 00 15 	brgt	800089a6 <_vfprintf_r+0x87a>
80008980:	f2 ca ff f8 	sub	r10,r9,-8
80008984:	72 16       	ld.w	r6,r9[0x4]
80008986:	72 09       	ld.w	r9,r9[0x0]
80008988:	51 0a       	stdsp	sp[0x40],r10
8000898a:	50 59       	stdsp	sp[0x14],r9
8000898c:	fa ce f9 44 	sub	lr,sp,-1724
80008990:	50 76       	stdsp	sp[0x1c],r6
80008992:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008996:	40 5b       	lddsp	r11,sp[0x14]
80008998:	0c 9a       	mov	r10,r6
8000899a:	f2 eb fd 88 	st.d	r9[-632],r10
8000899e:	2f f8       	sub	r8,-1
800089a0:	fb 48 06 b4 	st.w	sp[1716],r8
800089a4:	c0 88       	rjmp	800089b4 <_vfprintf_r+0x888>
800089a6:	72 1c       	ld.w	r12,r9[0x4]
800089a8:	50 7c       	stdsp	sp[0x1c],r12
800089aa:	f2 c8 ff f8 	sub	r8,r9,-8
800089ae:	51 08       	stdsp	sp[0x40],r8
800089b0:	72 09       	ld.w	r9,r9[0x0]
800089b2:	50 59       	stdsp	sp[0x14],r9
800089b4:	40 5b       	lddsp	r11,sp[0x14]
800089b6:	40 7a       	lddsp	r10,sp[0x1c]
800089b8:	e0 a0 19 54 	rcall	8000bc60 <__isinfd>
800089bc:	18 96       	mov	r6,r12
800089be:	c1 70       	breq	800089ec <_vfprintf_r+0x8c0>
800089c0:	30 08       	mov	r8,0
800089c2:	30 09       	mov	r9,0
800089c4:	40 5b       	lddsp	r11,sp[0x14]
800089c6:	40 7a       	lddsp	r10,sp[0x1c]
800089c8:	e0 a0 1d b4 	rcall	8000c530 <__avr32_f64_cmp_lt>
800089cc:	c0 40       	breq	800089d4 <_vfprintf_r+0x8a8>
800089ce:	32 d8       	mov	r8,45
800089d0:	fb 68 06 bb 	st.b	sp[1723],r8
800089d4:	fe c8 aa 1c 	sub	r8,pc,-21988
800089d8:	fe c6 aa 1c 	sub	r6,pc,-21988
800089dc:	a7 d5       	cbr	r5,0x7
800089de:	e0 40 00 47 	cp.w	r0,71
800089e2:	f0 06 17 a0 	movle	r6,r8
800089e6:	30 32       	mov	r2,3
800089e8:	e0 8f 06 ce 	bral	80009784 <_vfprintf_r+0x1658>
800089ec:	40 5b       	lddsp	r11,sp[0x14]
800089ee:	40 7a       	lddsp	r10,sp[0x1c]
800089f0:	e0 a0 19 4d 	rcall	8000bc8a <__isnand>
800089f4:	c0 e0       	breq	80008a10 <_vfprintf_r+0x8e4>
800089f6:	50 26       	stdsp	sp[0x8],r6
800089f8:	fe c8 aa 38 	sub	r8,pc,-21960
800089fc:	fe c6 aa 38 	sub	r6,pc,-21960
80008a00:	a7 d5       	cbr	r5,0x7
80008a02:	e0 40 00 47 	cp.w	r0,71
80008a06:	f0 06 17 a0 	movle	r6,r8
80008a0a:	30 32       	mov	r2,3
80008a0c:	e0 8f 06 c2 	bral	80009790 <_vfprintf_r+0x1664>
80008a10:	40 2a       	lddsp	r10,sp[0x8]
80008a12:	5b fa       	cp.w	r10,-1
80008a14:	c0 41       	brne	80008a1c <_vfprintf_r+0x8f0>
80008a16:	30 69       	mov	r9,6
80008a18:	50 29       	stdsp	sp[0x8],r9
80008a1a:	c1 18       	rjmp	80008a3c <_vfprintf_r+0x910>
80008a1c:	e0 40 00 47 	cp.w	r0,71
80008a20:	5f 09       	sreq	r9
80008a22:	e0 40 00 67 	cp.w	r0,103
80008a26:	5f 08       	sreq	r8
80008a28:	f3 e8 10 08 	or	r8,r9,r8
80008a2c:	f8 08 18 00 	cp.b	r8,r12
80008a30:	c0 60       	breq	80008a3c <_vfprintf_r+0x910>
80008a32:	40 28       	lddsp	r8,sp[0x8]
80008a34:	58 08       	cp.w	r8,0
80008a36:	f9 b8 00 01 	moveq	r8,1
80008a3a:	50 28       	stdsp	sp[0x8],r8
80008a3c:	40 78       	lddsp	r8,sp[0x1c]
80008a3e:	40 59       	lddsp	r9,sp[0x14]
80008a40:	fa e9 06 94 	st.d	sp[1684],r8
80008a44:	a9 a5       	sbr	r5,0x8
80008a46:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a4a:	58 08       	cp.w	r8,0
80008a4c:	c0 65       	brlt	80008a58 <_vfprintf_r+0x92c>
80008a4e:	40 5e       	lddsp	lr,sp[0x14]
80008a50:	30 0c       	mov	r12,0
80008a52:	50 6e       	stdsp	sp[0x18],lr
80008a54:	50 9c       	stdsp	sp[0x24],r12
80008a56:	c0 78       	rjmp	80008a64 <_vfprintf_r+0x938>
80008a58:	40 5b       	lddsp	r11,sp[0x14]
80008a5a:	32 da       	mov	r10,45
80008a5c:	ee 1b 80 00 	eorh	r11,0x8000
80008a60:	50 9a       	stdsp	sp[0x24],r10
80008a62:	50 6b       	stdsp	sp[0x18],r11
80008a64:	e0 40 00 46 	cp.w	r0,70
80008a68:	5f 09       	sreq	r9
80008a6a:	e0 40 00 66 	cp.w	r0,102
80008a6e:	5f 08       	sreq	r8
80008a70:	f3 e8 10 08 	or	r8,r9,r8
80008a74:	50 48       	stdsp	sp[0x10],r8
80008a76:	c0 40       	breq	80008a7e <_vfprintf_r+0x952>
80008a78:	40 22       	lddsp	r2,sp[0x8]
80008a7a:	30 39       	mov	r9,3
80008a7c:	c1 08       	rjmp	80008a9c <_vfprintf_r+0x970>
80008a7e:	e0 40 00 45 	cp.w	r0,69
80008a82:	5f 09       	sreq	r9
80008a84:	e0 40 00 65 	cp.w	r0,101
80008a88:	5f 08       	sreq	r8
80008a8a:	40 22       	lddsp	r2,sp[0x8]
80008a8c:	10 49       	or	r9,r8
80008a8e:	2f f2       	sub	r2,-1
80008a90:	40 46       	lddsp	r6,sp[0x10]
80008a92:	ec 09 18 00 	cp.b	r9,r6
80008a96:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a9a:	30 29       	mov	r9,2
80008a9c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008aa0:	1a d8       	st.w	--sp,r8
80008aa2:	fa c8 f9 54 	sub	r8,sp,-1708
80008aa6:	1a d8       	st.w	--sp,r8
80008aa8:	fa c8 f9 4c 	sub	r8,sp,-1716
80008aac:	08 9c       	mov	r12,r4
80008aae:	1a d8       	st.w	--sp,r8
80008ab0:	04 98       	mov	r8,r2
80008ab2:	40 9b       	lddsp	r11,sp[0x24]
80008ab4:	40 aa       	lddsp	r10,sp[0x28]
80008ab6:	e0 a0 0b c3 	rcall	8000a23c <_dtoa_r>
80008aba:	e0 40 00 47 	cp.w	r0,71
80008abe:	5f 19       	srne	r9
80008ac0:	e0 40 00 67 	cp.w	r0,103
80008ac4:	5f 18       	srne	r8
80008ac6:	18 96       	mov	r6,r12
80008ac8:	2f dd       	sub	sp,-12
80008aca:	f3 e8 00 08 	and	r8,r9,r8
80008ace:	c0 41       	brne	80008ad6 <_vfprintf_r+0x9aa>
80008ad0:	ed b5 00 00 	bld	r5,0x0
80008ad4:	c3 01       	brne	80008b34 <_vfprintf_r+0xa08>
80008ad6:	ec 02 00 0e 	add	lr,r6,r2
80008ada:	50 3e       	stdsp	sp[0xc],lr
80008adc:	40 4c       	lddsp	r12,sp[0x10]
80008ade:	58 0c       	cp.w	r12,0
80008ae0:	c1 50       	breq	80008b0a <_vfprintf_r+0x9de>
80008ae2:	0d 89       	ld.ub	r9,r6[0x0]
80008ae4:	33 08       	mov	r8,48
80008ae6:	f0 09 18 00 	cp.b	r9,r8
80008aea:	c0 b1       	brne	80008b00 <_vfprintf_r+0x9d4>
80008aec:	30 08       	mov	r8,0
80008aee:	30 09       	mov	r9,0
80008af0:	40 6b       	lddsp	r11,sp[0x18]
80008af2:	40 7a       	lddsp	r10,sp[0x1c]
80008af4:	e0 a0 1c d7 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
80008af8:	fb b2 00 01 	rsubeq	r2,1
80008afc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008b00:	40 3b       	lddsp	r11,sp[0xc]
80008b02:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b06:	10 0b       	add	r11,r8
80008b08:	50 3b       	stdsp	sp[0xc],r11
80008b0a:	40 6b       	lddsp	r11,sp[0x18]
80008b0c:	30 08       	mov	r8,0
80008b0e:	30 09       	mov	r9,0
80008b10:	40 7a       	lddsp	r10,sp[0x1c]
80008b12:	e0 a0 1c c8 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
80008b16:	c0 90       	breq	80008b28 <_vfprintf_r+0x9fc>
80008b18:	40 3a       	lddsp	r10,sp[0xc]
80008b1a:	fb 4a 06 a4 	st.w	sp[1700],r10
80008b1e:	c0 58       	rjmp	80008b28 <_vfprintf_r+0x9fc>
80008b20:	10 c9       	st.b	r8++,r9
80008b22:	fb 48 06 a4 	st.w	sp[1700],r8
80008b26:	c0 28       	rjmp	80008b2a <_vfprintf_r+0x9fe>
80008b28:	33 09       	mov	r9,48
80008b2a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b2e:	40 3e       	lddsp	lr,sp[0xc]
80008b30:	1c 38       	cp.w	r8,lr
80008b32:	cf 73       	brcs	80008b20 <_vfprintf_r+0x9f4>
80008b34:	e0 40 00 47 	cp.w	r0,71
80008b38:	5f 09       	sreq	r9
80008b3a:	e0 40 00 67 	cp.w	r0,103
80008b3e:	5f 08       	sreq	r8
80008b40:	f3 e8 10 08 	or	r8,r9,r8
80008b44:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b48:	0c 19       	sub	r9,r6
80008b4a:	50 69       	stdsp	sp[0x18],r9
80008b4c:	58 08       	cp.w	r8,0
80008b4e:	c0 b0       	breq	80008b64 <_vfprintf_r+0xa38>
80008b50:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b54:	5b d8       	cp.w	r8,-3
80008b56:	c0 55       	brlt	80008b60 <_vfprintf_r+0xa34>
80008b58:	40 2c       	lddsp	r12,sp[0x8]
80008b5a:	18 38       	cp.w	r8,r12
80008b5c:	e0 8a 00 6a 	brle	80008c30 <_vfprintf_r+0xb04>
80008b60:	20 20       	sub	r0,2
80008b62:	c0 58       	rjmp	80008b6c <_vfprintf_r+0xa40>
80008b64:	e0 40 00 65 	cp.w	r0,101
80008b68:	e0 89 00 46 	brgt	80008bf4 <_vfprintf_r+0xac8>
80008b6c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b70:	fb 60 06 9c 	st.b	sp[1692],r0
80008b74:	20 1b       	sub	r11,1
80008b76:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b7a:	c0 47       	brpl	80008b82 <_vfprintf_r+0xa56>
80008b7c:	5c 3b       	neg	r11
80008b7e:	32 d8       	mov	r8,45
80008b80:	c0 28       	rjmp	80008b84 <_vfprintf_r+0xa58>
80008b82:	32 b8       	mov	r8,43
80008b84:	fb 68 06 9d 	st.b	sp[1693],r8
80008b88:	58 9b       	cp.w	r11,9
80008b8a:	e0 8a 00 1d 	brle	80008bc4 <_vfprintf_r+0xa98>
80008b8e:	fa c9 fa 35 	sub	r9,sp,-1483
80008b92:	30 aa       	mov	r10,10
80008b94:	12 98       	mov	r8,r9
80008b96:	0e 9c       	mov	r12,r7
80008b98:	0c 92       	mov	r2,r6
80008b9a:	f6 0a 0c 06 	divs	r6,r11,r10
80008b9e:	0e 9b       	mov	r11,r7
80008ba0:	2d 0b       	sub	r11,-48
80008ba2:	10 fb       	st.b	--r8,r11
80008ba4:	0c 9b       	mov	r11,r6
80008ba6:	58 96       	cp.w	r6,9
80008ba8:	fe 99 ff f9 	brgt	80008b9a <_vfprintf_r+0xa6e>
80008bac:	2d 0b       	sub	r11,-48
80008bae:	18 97       	mov	r7,r12
80008bb0:	04 96       	mov	r6,r2
80008bb2:	10 fb       	st.b	--r8,r11
80008bb4:	fa ca f9 62 	sub	r10,sp,-1694
80008bb8:	c0 38       	rjmp	80008bbe <_vfprintf_r+0xa92>
80008bba:	11 3b       	ld.ub	r11,r8++
80008bbc:	14 cb       	st.b	r10++,r11
80008bbe:	12 38       	cp.w	r8,r9
80008bc0:	cf d3       	brcs	80008bba <_vfprintf_r+0xa8e>
80008bc2:	c0 98       	rjmp	80008bd4 <_vfprintf_r+0xaa8>
80008bc4:	2d 0b       	sub	r11,-48
80008bc6:	33 08       	mov	r8,48
80008bc8:	fb 6b 06 9f 	st.b	sp[1695],r11
80008bcc:	fb 68 06 9e 	st.b	sp[1694],r8
80008bd0:	fa ca f9 60 	sub	r10,sp,-1696
80008bd4:	fa c8 f9 64 	sub	r8,sp,-1692
80008bd8:	f4 08 01 08 	sub	r8,r10,r8
80008bdc:	50 e8       	stdsp	sp[0x38],r8
80008bde:	10 92       	mov	r2,r8
80008be0:	40 6b       	lddsp	r11,sp[0x18]
80008be2:	16 02       	add	r2,r11
80008be4:	58 1b       	cp.w	r11,1
80008be6:	e0 89 00 05 	brgt	80008bf0 <_vfprintf_r+0xac4>
80008bea:	ed b5 00 00 	bld	r5,0x0
80008bee:	c3 51       	brne	80008c58 <_vfprintf_r+0xb2c>
80008bf0:	2f f2       	sub	r2,-1
80008bf2:	c3 38       	rjmp	80008c58 <_vfprintf_r+0xb2c>
80008bf4:	e0 40 00 66 	cp.w	r0,102
80008bf8:	c1 c1       	brne	80008c30 <_vfprintf_r+0xb04>
80008bfa:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bfe:	58 02       	cp.w	r2,0
80008c00:	e0 8a 00 0c 	brle	80008c18 <_vfprintf_r+0xaec>
80008c04:	40 2a       	lddsp	r10,sp[0x8]
80008c06:	58 0a       	cp.w	r10,0
80008c08:	c0 41       	brne	80008c10 <_vfprintf_r+0xae4>
80008c0a:	ed b5 00 00 	bld	r5,0x0
80008c0e:	c2 51       	brne	80008c58 <_vfprintf_r+0xb2c>
80008c10:	2f f2       	sub	r2,-1
80008c12:	40 29       	lddsp	r9,sp[0x8]
80008c14:	12 02       	add	r2,r9
80008c16:	c0 b8       	rjmp	80008c2c <_vfprintf_r+0xb00>
80008c18:	40 28       	lddsp	r8,sp[0x8]
80008c1a:	58 08       	cp.w	r8,0
80008c1c:	c0 61       	brne	80008c28 <_vfprintf_r+0xafc>
80008c1e:	ed b5 00 00 	bld	r5,0x0
80008c22:	c0 30       	breq	80008c28 <_vfprintf_r+0xafc>
80008c24:	30 12       	mov	r2,1
80008c26:	c1 98       	rjmp	80008c58 <_vfprintf_r+0xb2c>
80008c28:	40 22       	lddsp	r2,sp[0x8]
80008c2a:	2f e2       	sub	r2,-2
80008c2c:	36 60       	mov	r0,102
80008c2e:	c1 58       	rjmp	80008c58 <_vfprintf_r+0xb2c>
80008c30:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c34:	40 6e       	lddsp	lr,sp[0x18]
80008c36:	1c 32       	cp.w	r2,lr
80008c38:	c0 65       	brlt	80008c44 <_vfprintf_r+0xb18>
80008c3a:	ed b5 00 00 	bld	r5,0x0
80008c3e:	f7 b2 00 ff 	subeq	r2,-1
80008c42:	c0 a8       	rjmp	80008c56 <_vfprintf_r+0xb2a>
80008c44:	e4 08 11 02 	rsub	r8,r2,2
80008c48:	40 6c       	lddsp	r12,sp[0x18]
80008c4a:	58 02       	cp.w	r2,0
80008c4c:	f0 02 17 a0 	movle	r2,r8
80008c50:	f9 b2 09 01 	movgt	r2,1
80008c54:	18 02       	add	r2,r12
80008c56:	36 70       	mov	r0,103
80008c58:	40 9b       	lddsp	r11,sp[0x24]
80008c5a:	58 0b       	cp.w	r11,0
80008c5c:	e0 80 05 94 	breq	80009784 <_vfprintf_r+0x1658>
80008c60:	32 d8       	mov	r8,45
80008c62:	fb 68 06 bb 	st.b	sp[1723],r8
80008c66:	e0 8f 05 93 	bral	8000978c <_vfprintf_r+0x1660>
80008c6a:	50 a7       	stdsp	sp[0x28],r7
80008c6c:	04 94       	mov	r4,r2
80008c6e:	0c 97       	mov	r7,r6
80008c70:	02 92       	mov	r2,r1
80008c72:	06 96       	mov	r6,r3
80008c74:	40 41       	lddsp	r1,sp[0x10]
80008c76:	40 93       	lddsp	r3,sp[0x24]
80008c78:	0e 99       	mov	r9,r7
80008c7a:	ed b5 00 05 	bld	r5,0x5
80008c7e:	c4 81       	brne	80008d0e <_vfprintf_r+0xbe2>
80008c80:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c84:	40 3e       	lddsp	lr,sp[0xc]
80008c86:	58 0e       	cp.w	lr,0
80008c88:	c1 d0       	breq	80008cc2 <_vfprintf_r+0xb96>
80008c8a:	10 36       	cp.w	r6,r8
80008c8c:	c0 64       	brge	80008c98 <_vfprintf_r+0xb6c>
80008c8e:	fa cc f9 44 	sub	r12,sp,-1724
80008c92:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c96:	c1 d8       	rjmp	80008cd0 <_vfprintf_r+0xba4>
80008c98:	fa c8 f9 50 	sub	r8,sp,-1712
80008c9c:	1a d8       	st.w	--sp,r8
80008c9e:	fa c8 fa b8 	sub	r8,sp,-1352
80008ca2:	04 9a       	mov	r10,r2
80008ca4:	1a d8       	st.w	--sp,r8
80008ca6:	fa c8 fb b4 	sub	r8,sp,-1100
80008caa:	0c 9b       	mov	r11,r6
80008cac:	1a d8       	st.w	--sp,r8
80008cae:	08 9c       	mov	r12,r4
80008cb0:	fa c8 f9 40 	sub	r8,sp,-1728
80008cb4:	fa c9 ff b4 	sub	r9,sp,-76
80008cb8:	fe b0 f8 a2 	rcall	80007dfc <get_arg>
80008cbc:	2f dd       	sub	sp,-12
80008cbe:	78 0a       	ld.w	r10,r12[0x0]
80008cc0:	c2 08       	rjmp	80008d00 <_vfprintf_r+0xbd4>
80008cc2:	2f f7       	sub	r7,-1
80008cc4:	10 39       	cp.w	r9,r8
80008cc6:	c0 84       	brge	80008cd6 <_vfprintf_r+0xbaa>
80008cc8:	fa cb f9 44 	sub	r11,sp,-1724
80008ccc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cd0:	ec fa fd 88 	ld.w	r10,r6[-632]
80008cd4:	c1 68       	rjmp	80008d00 <_vfprintf_r+0xbd4>
80008cd6:	41 09       	lddsp	r9,sp[0x40]
80008cd8:	59 f8       	cp.w	r8,31
80008cda:	e0 89 00 10 	brgt	80008cfa <_vfprintf_r+0xbce>
80008cde:	f2 ca ff fc 	sub	r10,r9,-4
80008ce2:	51 0a       	stdsp	sp[0x40],r10
80008ce4:	fa c6 f9 44 	sub	r6,sp,-1724
80008ce8:	72 0a       	ld.w	r10,r9[0x0]
80008cea:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cee:	f3 4a fd 88 	st.w	r9[-632],r10
80008cf2:	2f f8       	sub	r8,-1
80008cf4:	fb 48 06 b4 	st.w	sp[1716],r8
80008cf8:	c0 48       	rjmp	80008d00 <_vfprintf_r+0xbd4>
80008cfa:	72 0a       	ld.w	r10,r9[0x0]
80008cfc:	2f c9       	sub	r9,-4
80008cfe:	51 09       	stdsp	sp[0x40],r9
80008d00:	40 be       	lddsp	lr,sp[0x2c]
80008d02:	1c 98       	mov	r8,lr
80008d04:	95 1e       	st.w	r10[0x4],lr
80008d06:	bf 58       	asr	r8,0x1f
80008d08:	95 08       	st.w	r10[0x0],r8
80008d0a:	fe 9f fa 9f 	bral	80008248 <_vfprintf_r+0x11c>
80008d0e:	ed b5 00 04 	bld	r5,0x4
80008d12:	c4 80       	breq	80008da2 <_vfprintf_r+0xc76>
80008d14:	e2 15 00 40 	andl	r5,0x40,COH
80008d18:	c4 50       	breq	80008da2 <_vfprintf_r+0xc76>
80008d1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d1e:	40 3c       	lddsp	r12,sp[0xc]
80008d20:	58 0c       	cp.w	r12,0
80008d22:	c1 d0       	breq	80008d5c <_vfprintf_r+0xc30>
80008d24:	10 36       	cp.w	r6,r8
80008d26:	c0 64       	brge	80008d32 <_vfprintf_r+0xc06>
80008d28:	fa cb f9 44 	sub	r11,sp,-1724
80008d2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d30:	c1 d8       	rjmp	80008d6a <_vfprintf_r+0xc3e>
80008d32:	fa c8 f9 50 	sub	r8,sp,-1712
80008d36:	1a d8       	st.w	--sp,r8
80008d38:	fa c8 fa b8 	sub	r8,sp,-1352
80008d3c:	04 9a       	mov	r10,r2
80008d3e:	1a d8       	st.w	--sp,r8
80008d40:	fa c8 fb b4 	sub	r8,sp,-1100
80008d44:	0c 9b       	mov	r11,r6
80008d46:	1a d8       	st.w	--sp,r8
80008d48:	08 9c       	mov	r12,r4
80008d4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008d4e:	fa c9 ff b4 	sub	r9,sp,-76
80008d52:	fe b0 f8 55 	rcall	80007dfc <get_arg>
80008d56:	2f dd       	sub	sp,-12
80008d58:	78 0a       	ld.w	r10,r12[0x0]
80008d5a:	c2 08       	rjmp	80008d9a <_vfprintf_r+0xc6e>
80008d5c:	2f f7       	sub	r7,-1
80008d5e:	10 39       	cp.w	r9,r8
80008d60:	c0 84       	brge	80008d70 <_vfprintf_r+0xc44>
80008d62:	fa ca f9 44 	sub	r10,sp,-1724
80008d66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d6a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d6e:	c1 68       	rjmp	80008d9a <_vfprintf_r+0xc6e>
80008d70:	41 09       	lddsp	r9,sp[0x40]
80008d72:	59 f8       	cp.w	r8,31
80008d74:	e0 89 00 10 	brgt	80008d94 <_vfprintf_r+0xc68>
80008d78:	f2 ca ff fc 	sub	r10,r9,-4
80008d7c:	51 0a       	stdsp	sp[0x40],r10
80008d7e:	fa c6 f9 44 	sub	r6,sp,-1724
80008d82:	72 0a       	ld.w	r10,r9[0x0]
80008d84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d88:	f3 4a fd 88 	st.w	r9[-632],r10
80008d8c:	2f f8       	sub	r8,-1
80008d8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d92:	c0 48       	rjmp	80008d9a <_vfprintf_r+0xc6e>
80008d94:	72 0a       	ld.w	r10,r9[0x0]
80008d96:	2f c9       	sub	r9,-4
80008d98:	51 09       	stdsp	sp[0x40],r9
80008d9a:	40 be       	lddsp	lr,sp[0x2c]
80008d9c:	b4 0e       	st.h	r10[0x0],lr
80008d9e:	fe 9f fa 55 	bral	80008248 <_vfprintf_r+0x11c>
80008da2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008da6:	40 3c       	lddsp	r12,sp[0xc]
80008da8:	58 0c       	cp.w	r12,0
80008daa:	c1 d0       	breq	80008de4 <_vfprintf_r+0xcb8>
80008dac:	10 36       	cp.w	r6,r8
80008dae:	c0 64       	brge	80008dba <_vfprintf_r+0xc8e>
80008db0:	fa cb f9 44 	sub	r11,sp,-1724
80008db4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008db8:	c1 d8       	rjmp	80008df2 <_vfprintf_r+0xcc6>
80008dba:	fa c8 f9 50 	sub	r8,sp,-1712
80008dbe:	1a d8       	st.w	--sp,r8
80008dc0:	fa c8 fa b8 	sub	r8,sp,-1352
80008dc4:	04 9a       	mov	r10,r2
80008dc6:	1a d8       	st.w	--sp,r8
80008dc8:	fa c8 fb b4 	sub	r8,sp,-1100
80008dcc:	0c 9b       	mov	r11,r6
80008dce:	1a d8       	st.w	--sp,r8
80008dd0:	08 9c       	mov	r12,r4
80008dd2:	fa c8 f9 40 	sub	r8,sp,-1728
80008dd6:	fa c9 ff b4 	sub	r9,sp,-76
80008dda:	fe b0 f8 11 	rcall	80007dfc <get_arg>
80008dde:	2f dd       	sub	sp,-12
80008de0:	78 0a       	ld.w	r10,r12[0x0]
80008de2:	c2 08       	rjmp	80008e22 <_vfprintf_r+0xcf6>
80008de4:	2f f7       	sub	r7,-1
80008de6:	10 39       	cp.w	r9,r8
80008de8:	c0 84       	brge	80008df8 <_vfprintf_r+0xccc>
80008dea:	fa ca f9 44 	sub	r10,sp,-1724
80008dee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008df2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008df6:	c1 68       	rjmp	80008e22 <_vfprintf_r+0xcf6>
80008df8:	41 09       	lddsp	r9,sp[0x40]
80008dfa:	59 f8       	cp.w	r8,31
80008dfc:	e0 89 00 10 	brgt	80008e1c <_vfprintf_r+0xcf0>
80008e00:	f2 ca ff fc 	sub	r10,r9,-4
80008e04:	51 0a       	stdsp	sp[0x40],r10
80008e06:	fa c6 f9 44 	sub	r6,sp,-1724
80008e0a:	72 0a       	ld.w	r10,r9[0x0]
80008e0c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e10:	f3 4a fd 88 	st.w	r9[-632],r10
80008e14:	2f f8       	sub	r8,-1
80008e16:	fb 48 06 b4 	st.w	sp[1716],r8
80008e1a:	c0 48       	rjmp	80008e22 <_vfprintf_r+0xcf6>
80008e1c:	72 0a       	ld.w	r10,r9[0x0]
80008e1e:	2f c9       	sub	r9,-4
80008e20:	51 09       	stdsp	sp[0x40],r9
80008e22:	40 be       	lddsp	lr,sp[0x2c]
80008e24:	95 0e       	st.w	r10[0x0],lr
80008e26:	fe 9f fa 11 	bral	80008248 <_vfprintf_r+0x11c>
80008e2a:	50 a7       	stdsp	sp[0x28],r7
80008e2c:	50 80       	stdsp	sp[0x20],r0
80008e2e:	0c 97       	mov	r7,r6
80008e30:	04 94       	mov	r4,r2
80008e32:	06 96       	mov	r6,r3
80008e34:	02 92       	mov	r2,r1
80008e36:	40 93       	lddsp	r3,sp[0x24]
80008e38:	10 90       	mov	r0,r8
80008e3a:	40 41       	lddsp	r1,sp[0x10]
80008e3c:	a5 a5       	sbr	r5,0x4
80008e3e:	c0 a8       	rjmp	80008e52 <_vfprintf_r+0xd26>
80008e40:	50 a7       	stdsp	sp[0x28],r7
80008e42:	50 80       	stdsp	sp[0x20],r0
80008e44:	0c 97       	mov	r7,r6
80008e46:	04 94       	mov	r4,r2
80008e48:	06 96       	mov	r6,r3
80008e4a:	02 92       	mov	r2,r1
80008e4c:	40 93       	lddsp	r3,sp[0x24]
80008e4e:	10 90       	mov	r0,r8
80008e50:	40 41       	lddsp	r1,sp[0x10]
80008e52:	ed b5 00 05 	bld	r5,0x5
80008e56:	c5 d1       	brne	80008f10 <_vfprintf_r+0xde4>
80008e58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e5c:	40 3c       	lddsp	r12,sp[0xc]
80008e5e:	58 0c       	cp.w	r12,0
80008e60:	c2 60       	breq	80008eac <_vfprintf_r+0xd80>
80008e62:	10 36       	cp.w	r6,r8
80008e64:	c0 a4       	brge	80008e78 <_vfprintf_r+0xd4c>
80008e66:	fa cb f9 44 	sub	r11,sp,-1724
80008e6a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e6e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e72:	fa e9 00 00 	st.d	sp[0],r8
80008e76:	c1 88       	rjmp	80008ea6 <_vfprintf_r+0xd7a>
80008e78:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e82:	04 9a       	mov	r10,r2
80008e84:	1a d8       	st.w	--sp,r8
80008e86:	0c 9b       	mov	r11,r6
80008e88:	fa c8 fb b4 	sub	r8,sp,-1100
80008e8c:	08 9c       	mov	r12,r4
80008e8e:	1a d8       	st.w	--sp,r8
80008e90:	fa c8 f9 40 	sub	r8,sp,-1728
80008e94:	fa c9 ff b4 	sub	r9,sp,-76
80008e98:	fe b0 f7 b2 	rcall	80007dfc <get_arg>
80008e9c:	2f dd       	sub	sp,-12
80008e9e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ea2:	fa eb 00 00 	st.d	sp[0],r10
80008ea6:	30 08       	mov	r8,0
80008ea8:	e0 8f 03 de 	bral	80009664 <_vfprintf_r+0x1538>
80008eac:	ee ca ff ff 	sub	r10,r7,-1
80008eb0:	10 37       	cp.w	r7,r8
80008eb2:	c0 b4       	brge	80008ec8 <_vfprintf_r+0xd9c>
80008eb4:	fa c9 f9 44 	sub	r9,sp,-1724
80008eb8:	14 97       	mov	r7,r10
80008eba:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ebe:	ec ea fd 88 	ld.d	r10,r6[-632]
80008ec2:	fa eb 00 00 	st.d	sp[0],r10
80008ec6:	c1 88       	rjmp	80008ef6 <_vfprintf_r+0xdca>
80008ec8:	41 09       	lddsp	r9,sp[0x40]
80008eca:	59 f8       	cp.w	r8,31
80008ecc:	e0 89 00 18 	brgt	80008efc <_vfprintf_r+0xdd0>
80008ed0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ed4:	f2 cb ff f8 	sub	r11,r9,-8
80008ed8:	fa e7 00 00 	st.d	sp[0],r6
80008edc:	51 0b       	stdsp	sp[0x40],r11
80008ede:	fa c6 f9 44 	sub	r6,sp,-1724
80008ee2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ee6:	fa e6 00 00 	ld.d	r6,sp[0]
80008eea:	f2 e7 fd 88 	st.d	r9[-632],r6
80008eee:	2f f8       	sub	r8,-1
80008ef0:	14 97       	mov	r7,r10
80008ef2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ef6:	40 38       	lddsp	r8,sp[0xc]
80008ef8:	e0 8f 03 b6 	bral	80009664 <_vfprintf_r+0x1538>
80008efc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f00:	40 38       	lddsp	r8,sp[0xc]
80008f02:	fa e7 00 00 	st.d	sp[0],r6
80008f06:	2f 89       	sub	r9,-8
80008f08:	14 97       	mov	r7,r10
80008f0a:	51 09       	stdsp	sp[0x40],r9
80008f0c:	e0 8f 03 ac 	bral	80009664 <_vfprintf_r+0x1538>
80008f10:	ed b5 00 04 	bld	r5,0x4
80008f14:	c1 61       	brne	80008f40 <_vfprintf_r+0xe14>
80008f16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f1a:	40 3e       	lddsp	lr,sp[0xc]
80008f1c:	58 0e       	cp.w	lr,0
80008f1e:	c0 80       	breq	80008f2e <_vfprintf_r+0xe02>
80008f20:	10 36       	cp.w	r6,r8
80008f22:	c6 74       	brge	80008ff0 <_vfprintf_r+0xec4>
80008f24:	fa cc f9 44 	sub	r12,sp,-1724
80008f28:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f2c:	c8 08       	rjmp	8000902c <_vfprintf_r+0xf00>
80008f2e:	ee ca ff ff 	sub	r10,r7,-1
80008f32:	10 37       	cp.w	r7,r8
80008f34:	c7 f4       	brge	80009032 <_vfprintf_r+0xf06>
80008f36:	fa cb f9 44 	sub	r11,sp,-1724
80008f3a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f3e:	c7 68       	rjmp	8000902a <_vfprintf_r+0xefe>
80008f40:	ed b5 00 06 	bld	r5,0x6
80008f44:	c4 a1       	brne	80008fd8 <_vfprintf_r+0xeac>
80008f46:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f4a:	40 3c       	lddsp	r12,sp[0xc]
80008f4c:	58 0c       	cp.w	r12,0
80008f4e:	c1 d0       	breq	80008f88 <_vfprintf_r+0xe5c>
80008f50:	10 36       	cp.w	r6,r8
80008f52:	c0 64       	brge	80008f5e <_vfprintf_r+0xe32>
80008f54:	fa cb f9 44 	sub	r11,sp,-1724
80008f58:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f5c:	c1 f8       	rjmp	80008f9a <_vfprintf_r+0xe6e>
80008f5e:	fa c8 f9 50 	sub	r8,sp,-1712
80008f62:	1a d8       	st.w	--sp,r8
80008f64:	fa c8 fa b8 	sub	r8,sp,-1352
80008f68:	1a d8       	st.w	--sp,r8
80008f6a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f6e:	1a d8       	st.w	--sp,r8
80008f70:	fa c8 f9 40 	sub	r8,sp,-1728
80008f74:	fa c9 ff b4 	sub	r9,sp,-76
80008f78:	04 9a       	mov	r10,r2
80008f7a:	0c 9b       	mov	r11,r6
80008f7c:	08 9c       	mov	r12,r4
80008f7e:	fe b0 f7 3f 	rcall	80007dfc <get_arg>
80008f82:	2f dd       	sub	sp,-12
80008f84:	98 18       	ld.sh	r8,r12[0x2]
80008f86:	c2 68       	rjmp	80008fd2 <_vfprintf_r+0xea6>
80008f88:	ee ca ff ff 	sub	r10,r7,-1
80008f8c:	10 37       	cp.w	r7,r8
80008f8e:	c0 94       	brge	80008fa0 <_vfprintf_r+0xe74>
80008f90:	fa c9 f9 44 	sub	r9,sp,-1724
80008f94:	14 97       	mov	r7,r10
80008f96:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f9a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f9e:	c1 a8       	rjmp	80008fd2 <_vfprintf_r+0xea6>
80008fa0:	41 09       	lddsp	r9,sp[0x40]
80008fa2:	59 f8       	cp.w	r8,31
80008fa4:	e0 89 00 13 	brgt	80008fca <_vfprintf_r+0xe9e>
80008fa8:	f2 cb ff fc 	sub	r11,r9,-4
80008fac:	51 0b       	stdsp	sp[0x40],r11
80008fae:	72 09       	ld.w	r9,r9[0x0]
80008fb0:	fa c6 f9 44 	sub	r6,sp,-1724
80008fb4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fb8:	2f f8       	sub	r8,-1
80008fba:	f7 49 fd 88 	st.w	r11[-632],r9
80008fbe:	fb 48 06 b4 	st.w	sp[1716],r8
80008fc2:	14 97       	mov	r7,r10
80008fc4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fc8:	c0 58       	rjmp	80008fd2 <_vfprintf_r+0xea6>
80008fca:	92 18       	ld.sh	r8,r9[0x2]
80008fcc:	14 97       	mov	r7,r10
80008fce:	2f c9       	sub	r9,-4
80008fd0:	51 09       	stdsp	sp[0x40],r9
80008fd2:	5c 78       	castu.h	r8
80008fd4:	50 18       	stdsp	sp[0x4],r8
80008fd6:	c4 68       	rjmp	80009062 <_vfprintf_r+0xf36>
80008fd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fdc:	40 3c       	lddsp	r12,sp[0xc]
80008fde:	58 0c       	cp.w	r12,0
80008fe0:	c1 d0       	breq	8000901a <_vfprintf_r+0xeee>
80008fe2:	10 36       	cp.w	r6,r8
80008fe4:	c0 64       	brge	80008ff0 <_vfprintf_r+0xec4>
80008fe6:	fa cb f9 44 	sub	r11,sp,-1724
80008fea:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fee:	c1 f8       	rjmp	8000902c <_vfprintf_r+0xf00>
80008ff0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ff4:	1a d8       	st.w	--sp,r8
80008ff6:	fa c8 fa b8 	sub	r8,sp,-1352
80008ffa:	0c 9b       	mov	r11,r6
80008ffc:	1a d8       	st.w	--sp,r8
80008ffe:	fa c8 fb b4 	sub	r8,sp,-1100
80009002:	04 9a       	mov	r10,r2
80009004:	1a d8       	st.w	--sp,r8
80009006:	08 9c       	mov	r12,r4
80009008:	fa c8 f9 40 	sub	r8,sp,-1728
8000900c:	fa c9 ff b4 	sub	r9,sp,-76
80009010:	fe b0 f6 f6 	rcall	80007dfc <get_arg>
80009014:	2f dd       	sub	sp,-12
80009016:	78 0b       	ld.w	r11,r12[0x0]
80009018:	c2 48       	rjmp	80009060 <_vfprintf_r+0xf34>
8000901a:	ee ca ff ff 	sub	r10,r7,-1
8000901e:	10 37       	cp.w	r7,r8
80009020:	c0 94       	brge	80009032 <_vfprintf_r+0xf06>
80009022:	fa c9 f9 44 	sub	r9,sp,-1724
80009026:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000902a:	14 97       	mov	r7,r10
8000902c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009030:	c1 88       	rjmp	80009060 <_vfprintf_r+0xf34>
80009032:	41 09       	lddsp	r9,sp[0x40]
80009034:	59 f8       	cp.w	r8,31
80009036:	e0 89 00 11 	brgt	80009058 <_vfprintf_r+0xf2c>
8000903a:	f2 cb ff fc 	sub	r11,r9,-4
8000903e:	51 0b       	stdsp	sp[0x40],r11
80009040:	fa c6 f9 44 	sub	r6,sp,-1724
80009044:	72 0b       	ld.w	r11,r9[0x0]
80009046:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000904a:	f3 4b fd 88 	st.w	r9[-632],r11
8000904e:	2f f8       	sub	r8,-1
80009050:	14 97       	mov	r7,r10
80009052:	fb 48 06 b4 	st.w	sp[1716],r8
80009056:	c0 58       	rjmp	80009060 <_vfprintf_r+0xf34>
80009058:	72 0b       	ld.w	r11,r9[0x0]
8000905a:	14 97       	mov	r7,r10
8000905c:	2f c9       	sub	r9,-4
8000905e:	51 09       	stdsp	sp[0x40],r9
80009060:	50 1b       	stdsp	sp[0x4],r11
80009062:	30 0e       	mov	lr,0
80009064:	50 0e       	stdsp	sp[0x0],lr
80009066:	1c 98       	mov	r8,lr
80009068:	e0 8f 02 fe 	bral	80009664 <_vfprintf_r+0x1538>
8000906c:	50 a7       	stdsp	sp[0x28],r7
8000906e:	50 80       	stdsp	sp[0x20],r0
80009070:	0c 97       	mov	r7,r6
80009072:	04 94       	mov	r4,r2
80009074:	06 96       	mov	r6,r3
80009076:	02 92       	mov	r2,r1
80009078:	40 93       	lddsp	r3,sp[0x24]
8000907a:	40 41       	lddsp	r1,sp[0x10]
8000907c:	0e 99       	mov	r9,r7
8000907e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009082:	40 3c       	lddsp	r12,sp[0xc]
80009084:	58 0c       	cp.w	r12,0
80009086:	c1 d0       	breq	800090c0 <_vfprintf_r+0xf94>
80009088:	10 36       	cp.w	r6,r8
8000908a:	c0 64       	brge	80009096 <_vfprintf_r+0xf6a>
8000908c:	fa cb f9 44 	sub	r11,sp,-1724
80009090:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009094:	c1 d8       	rjmp	800090ce <_vfprintf_r+0xfa2>
80009096:	fa c8 f9 50 	sub	r8,sp,-1712
8000909a:	1a d8       	st.w	--sp,r8
8000909c:	fa c8 fa b8 	sub	r8,sp,-1352
800090a0:	1a d8       	st.w	--sp,r8
800090a2:	fa c8 fb b4 	sub	r8,sp,-1100
800090a6:	1a d8       	st.w	--sp,r8
800090a8:	fa c9 ff b4 	sub	r9,sp,-76
800090ac:	fa c8 f9 40 	sub	r8,sp,-1728
800090b0:	04 9a       	mov	r10,r2
800090b2:	0c 9b       	mov	r11,r6
800090b4:	08 9c       	mov	r12,r4
800090b6:	fe b0 f6 a3 	rcall	80007dfc <get_arg>
800090ba:	2f dd       	sub	sp,-12
800090bc:	78 09       	ld.w	r9,r12[0x0]
800090be:	c2 18       	rjmp	80009100 <_vfprintf_r+0xfd4>
800090c0:	2f f7       	sub	r7,-1
800090c2:	10 39       	cp.w	r9,r8
800090c4:	c0 84       	brge	800090d4 <_vfprintf_r+0xfa8>
800090c6:	fa ca f9 44 	sub	r10,sp,-1724
800090ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090ce:	ec f9 fd 88 	ld.w	r9,r6[-632]
800090d2:	c1 78       	rjmp	80009100 <_vfprintf_r+0xfd4>
800090d4:	41 09       	lddsp	r9,sp[0x40]
800090d6:	59 f8       	cp.w	r8,31
800090d8:	e0 89 00 10 	brgt	800090f8 <_vfprintf_r+0xfcc>
800090dc:	f2 ca ff fc 	sub	r10,r9,-4
800090e0:	51 0a       	stdsp	sp[0x40],r10
800090e2:	fa c6 f9 44 	sub	r6,sp,-1724
800090e6:	72 09       	ld.w	r9,r9[0x0]
800090e8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800090ec:	f5 49 fd 88 	st.w	r10[-632],r9
800090f0:	2f f8       	sub	r8,-1
800090f2:	fb 48 06 b4 	st.w	sp[1716],r8
800090f6:	c0 58       	rjmp	80009100 <_vfprintf_r+0xfd4>
800090f8:	f2 c8 ff fc 	sub	r8,r9,-4
800090fc:	51 08       	stdsp	sp[0x40],r8
800090fe:	72 09       	ld.w	r9,r9[0x0]
80009100:	33 08       	mov	r8,48
80009102:	fb 68 06 b8 	st.b	sp[1720],r8
80009106:	37 88       	mov	r8,120
80009108:	30 0e       	mov	lr,0
8000910a:	fb 68 06 b9 	st.b	sp[1721],r8
8000910e:	fe cc b1 46 	sub	r12,pc,-20154
80009112:	50 19       	stdsp	sp[0x4],r9
80009114:	a1 b5       	sbr	r5,0x1
80009116:	50 0e       	stdsp	sp[0x0],lr
80009118:	50 dc       	stdsp	sp[0x34],r12
8000911a:	30 28       	mov	r8,2
8000911c:	37 80       	mov	r0,120
8000911e:	e0 8f 02 a3 	bral	80009664 <_vfprintf_r+0x1538>
80009122:	50 a7       	stdsp	sp[0x28],r7
80009124:	50 80       	stdsp	sp[0x20],r0
80009126:	10 90       	mov	r0,r8
80009128:	30 08       	mov	r8,0
8000912a:	fb 68 06 bb 	st.b	sp[1723],r8
8000912e:	0c 97       	mov	r7,r6
80009130:	04 94       	mov	r4,r2
80009132:	06 96       	mov	r6,r3
80009134:	02 92       	mov	r2,r1
80009136:	40 93       	lddsp	r3,sp[0x24]
80009138:	40 41       	lddsp	r1,sp[0x10]
8000913a:	0e 99       	mov	r9,r7
8000913c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009140:	40 3b       	lddsp	r11,sp[0xc]
80009142:	58 0b       	cp.w	r11,0
80009144:	c1 d0       	breq	8000917e <_vfprintf_r+0x1052>
80009146:	10 36       	cp.w	r6,r8
80009148:	c0 64       	brge	80009154 <_vfprintf_r+0x1028>
8000914a:	fa ca f9 44 	sub	r10,sp,-1724
8000914e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009152:	c1 d8       	rjmp	8000918c <_vfprintf_r+0x1060>
80009154:	fa c8 f9 50 	sub	r8,sp,-1712
80009158:	1a d8       	st.w	--sp,r8
8000915a:	fa c8 fa b8 	sub	r8,sp,-1352
8000915e:	1a d8       	st.w	--sp,r8
80009160:	fa c8 fb b4 	sub	r8,sp,-1100
80009164:	0c 9b       	mov	r11,r6
80009166:	1a d8       	st.w	--sp,r8
80009168:	04 9a       	mov	r10,r2
8000916a:	fa c8 f9 40 	sub	r8,sp,-1728
8000916e:	fa c9 ff b4 	sub	r9,sp,-76
80009172:	08 9c       	mov	r12,r4
80009174:	fe b0 f6 44 	rcall	80007dfc <get_arg>
80009178:	2f dd       	sub	sp,-12
8000917a:	78 06       	ld.w	r6,r12[0x0]
8000917c:	c2 08       	rjmp	800091bc <_vfprintf_r+0x1090>
8000917e:	2f f7       	sub	r7,-1
80009180:	10 39       	cp.w	r9,r8
80009182:	c0 84       	brge	80009192 <_vfprintf_r+0x1066>
80009184:	fa c9 f9 44 	sub	r9,sp,-1724
80009188:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000918c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009190:	c1 68       	rjmp	800091bc <_vfprintf_r+0x1090>
80009192:	41 09       	lddsp	r9,sp[0x40]
80009194:	59 f8       	cp.w	r8,31
80009196:	e0 89 00 10 	brgt	800091b6 <_vfprintf_r+0x108a>
8000919a:	f2 ca ff fc 	sub	r10,r9,-4
8000919e:	51 0a       	stdsp	sp[0x40],r10
800091a0:	72 06       	ld.w	r6,r9[0x0]
800091a2:	fa ce f9 44 	sub	lr,sp,-1724
800091a6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800091aa:	f3 46 fd 88 	st.w	r9[-632],r6
800091ae:	2f f8       	sub	r8,-1
800091b0:	fb 48 06 b4 	st.w	sp[1716],r8
800091b4:	c0 48       	rjmp	800091bc <_vfprintf_r+0x1090>
800091b6:	72 06       	ld.w	r6,r9[0x0]
800091b8:	2f c9       	sub	r9,-4
800091ba:	51 09       	stdsp	sp[0x40],r9
800091bc:	40 2c       	lddsp	r12,sp[0x8]
800091be:	58 0c       	cp.w	r12,0
800091c0:	c1 05       	brlt	800091e0 <_vfprintf_r+0x10b4>
800091c2:	18 9a       	mov	r10,r12
800091c4:	30 0b       	mov	r11,0
800091c6:	0c 9c       	mov	r12,r6
800091c8:	e0 a0 12 38 	rcall	8000b638 <memchr>
800091cc:	e0 80 02 df 	breq	8000978a <_vfprintf_r+0x165e>
800091d0:	f8 06 01 02 	sub	r2,r12,r6
800091d4:	40 2b       	lddsp	r11,sp[0x8]
800091d6:	16 32       	cp.w	r2,r11
800091d8:	e0 89 02 d9 	brgt	8000978a <_vfprintf_r+0x165e>
800091dc:	e0 8f 02 d4 	bral	80009784 <_vfprintf_r+0x1658>
800091e0:	30 0a       	mov	r10,0
800091e2:	0c 9c       	mov	r12,r6
800091e4:	50 2a       	stdsp	sp[0x8],r10
800091e6:	e0 a0 15 99 	rcall	8000bd18 <strlen>
800091ea:	18 92       	mov	r2,r12
800091ec:	e0 8f 02 d2 	bral	80009790 <_vfprintf_r+0x1664>
800091f0:	50 a7       	stdsp	sp[0x28],r7
800091f2:	50 80       	stdsp	sp[0x20],r0
800091f4:	0c 97       	mov	r7,r6
800091f6:	04 94       	mov	r4,r2
800091f8:	06 96       	mov	r6,r3
800091fa:	02 92       	mov	r2,r1
800091fc:	40 93       	lddsp	r3,sp[0x24]
800091fe:	10 90       	mov	r0,r8
80009200:	40 41       	lddsp	r1,sp[0x10]
80009202:	a5 a5       	sbr	r5,0x4
80009204:	c0 a8       	rjmp	80009218 <_vfprintf_r+0x10ec>
80009206:	50 a7       	stdsp	sp[0x28],r7
80009208:	50 80       	stdsp	sp[0x20],r0
8000920a:	0c 97       	mov	r7,r6
8000920c:	04 94       	mov	r4,r2
8000920e:	06 96       	mov	r6,r3
80009210:	02 92       	mov	r2,r1
80009212:	40 93       	lddsp	r3,sp[0x24]
80009214:	10 90       	mov	r0,r8
80009216:	40 41       	lddsp	r1,sp[0x10]
80009218:	ed b5 00 05 	bld	r5,0x5
8000921c:	c5 61       	brne	800092c8 <_vfprintf_r+0x119c>
8000921e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009222:	40 39       	lddsp	r9,sp[0xc]
80009224:	58 09       	cp.w	r9,0
80009226:	c2 10       	breq	80009268 <_vfprintf_r+0x113c>
80009228:	10 36       	cp.w	r6,r8
8000922a:	c0 74       	brge	80009238 <_vfprintf_r+0x110c>
8000922c:	fa c8 f9 44 	sub	r8,sp,-1724
80009230:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009234:	c2 38       	rjmp	8000927a <_vfprintf_r+0x114e>
80009236:	d7 03       	nop
80009238:	fa c8 f9 50 	sub	r8,sp,-1712
8000923c:	1a d8       	st.w	--sp,r8
8000923e:	fa c8 fa b8 	sub	r8,sp,-1352
80009242:	1a d8       	st.w	--sp,r8
80009244:	fa c8 fb b4 	sub	r8,sp,-1100
80009248:	1a d8       	st.w	--sp,r8
8000924a:	fa c8 f9 40 	sub	r8,sp,-1728
8000924e:	fa c9 ff b4 	sub	r9,sp,-76
80009252:	04 9a       	mov	r10,r2
80009254:	0c 9b       	mov	r11,r6
80009256:	08 9c       	mov	r12,r4
80009258:	fe b0 f5 d2 	rcall	80007dfc <get_arg>
8000925c:	2f dd       	sub	sp,-12
8000925e:	f8 e8 00 00 	ld.d	r8,r12[0]
80009262:	fa e9 00 00 	st.d	sp[0],r8
80009266:	c2 e8       	rjmp	800092c2 <_vfprintf_r+0x1196>
80009268:	ee ca ff ff 	sub	r10,r7,-1
8000926c:	10 37       	cp.w	r7,r8
8000926e:	c0 b4       	brge	80009284 <_vfprintf_r+0x1158>
80009270:	fa c8 f9 44 	sub	r8,sp,-1724
80009274:	14 97       	mov	r7,r10
80009276:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000927a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000927e:	fa eb 00 00 	st.d	sp[0],r10
80009282:	c2 08       	rjmp	800092c2 <_vfprintf_r+0x1196>
80009284:	41 09       	lddsp	r9,sp[0x40]
80009286:	59 f8       	cp.w	r8,31
80009288:	e0 89 00 16 	brgt	800092b4 <_vfprintf_r+0x1188>
8000928c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009290:	f2 cb ff f8 	sub	r11,r9,-8
80009294:	fa e7 00 00 	st.d	sp[0],r6
80009298:	51 0b       	stdsp	sp[0x40],r11
8000929a:	fa c6 f9 44 	sub	r6,sp,-1724
8000929e:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092a2:	fa e6 00 00 	ld.d	r6,sp[0]
800092a6:	f2 e7 fd 88 	st.d	r9[-632],r6
800092aa:	2f f8       	sub	r8,-1
800092ac:	14 97       	mov	r7,r10
800092ae:	fb 48 06 b4 	st.w	sp[1716],r8
800092b2:	c0 88       	rjmp	800092c2 <_vfprintf_r+0x1196>
800092b4:	f2 e6 00 00 	ld.d	r6,r9[0]
800092b8:	2f 89       	sub	r9,-8
800092ba:	fa e7 00 00 	st.d	sp[0],r6
800092be:	51 09       	stdsp	sp[0x40],r9
800092c0:	14 97       	mov	r7,r10
800092c2:	30 18       	mov	r8,1
800092c4:	e0 8f 01 d0 	bral	80009664 <_vfprintf_r+0x1538>
800092c8:	ed b5 00 04 	bld	r5,0x4
800092cc:	c1 61       	brne	800092f8 <_vfprintf_r+0x11cc>
800092ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092d2:	40 3e       	lddsp	lr,sp[0xc]
800092d4:	58 0e       	cp.w	lr,0
800092d6:	c0 80       	breq	800092e6 <_vfprintf_r+0x11ba>
800092d8:	10 36       	cp.w	r6,r8
800092da:	c6 74       	brge	800093a8 <_vfprintf_r+0x127c>
800092dc:	fa cc f9 44 	sub	r12,sp,-1724
800092e0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092e4:	c8 08       	rjmp	800093e4 <_vfprintf_r+0x12b8>
800092e6:	ee ca ff ff 	sub	r10,r7,-1
800092ea:	10 37       	cp.w	r7,r8
800092ec:	c7 f4       	brge	800093ea <_vfprintf_r+0x12be>
800092ee:	fa cb f9 44 	sub	r11,sp,-1724
800092f2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092f6:	c7 68       	rjmp	800093e2 <_vfprintf_r+0x12b6>
800092f8:	ed b5 00 06 	bld	r5,0x6
800092fc:	c4 a1       	brne	80009390 <_vfprintf_r+0x1264>
800092fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009302:	40 3c       	lddsp	r12,sp[0xc]
80009304:	58 0c       	cp.w	r12,0
80009306:	c1 d0       	breq	80009340 <_vfprintf_r+0x1214>
80009308:	10 36       	cp.w	r6,r8
8000930a:	c0 64       	brge	80009316 <_vfprintf_r+0x11ea>
8000930c:	fa cb f9 44 	sub	r11,sp,-1724
80009310:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009314:	c1 f8       	rjmp	80009352 <_vfprintf_r+0x1226>
80009316:	fa c8 f9 50 	sub	r8,sp,-1712
8000931a:	1a d8       	st.w	--sp,r8
8000931c:	fa c8 fa b8 	sub	r8,sp,-1352
80009320:	1a d8       	st.w	--sp,r8
80009322:	fa c8 fb b4 	sub	r8,sp,-1100
80009326:	1a d8       	st.w	--sp,r8
80009328:	fa c8 f9 40 	sub	r8,sp,-1728
8000932c:	fa c9 ff b4 	sub	r9,sp,-76
80009330:	04 9a       	mov	r10,r2
80009332:	0c 9b       	mov	r11,r6
80009334:	08 9c       	mov	r12,r4
80009336:	fe b0 f5 63 	rcall	80007dfc <get_arg>
8000933a:	2f dd       	sub	sp,-12
8000933c:	98 18       	ld.sh	r8,r12[0x2]
8000933e:	c2 68       	rjmp	8000938a <_vfprintf_r+0x125e>
80009340:	ee ca ff ff 	sub	r10,r7,-1
80009344:	10 37       	cp.w	r7,r8
80009346:	c0 94       	brge	80009358 <_vfprintf_r+0x122c>
80009348:	fa c9 f9 44 	sub	r9,sp,-1724
8000934c:	14 97       	mov	r7,r10
8000934e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009352:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009356:	c1 a8       	rjmp	8000938a <_vfprintf_r+0x125e>
80009358:	41 09       	lddsp	r9,sp[0x40]
8000935a:	59 f8       	cp.w	r8,31
8000935c:	e0 89 00 13 	brgt	80009382 <_vfprintf_r+0x1256>
80009360:	f2 cb ff fc 	sub	r11,r9,-4
80009364:	51 0b       	stdsp	sp[0x40],r11
80009366:	72 09       	ld.w	r9,r9[0x0]
80009368:	fa c6 f9 44 	sub	r6,sp,-1724
8000936c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009370:	2f f8       	sub	r8,-1
80009372:	f7 49 fd 88 	st.w	r11[-632],r9
80009376:	fb 48 06 b4 	st.w	sp[1716],r8
8000937a:	14 97       	mov	r7,r10
8000937c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009380:	c0 58       	rjmp	8000938a <_vfprintf_r+0x125e>
80009382:	92 18       	ld.sh	r8,r9[0x2]
80009384:	14 97       	mov	r7,r10
80009386:	2f c9       	sub	r9,-4
80009388:	51 09       	stdsp	sp[0x40],r9
8000938a:	5c 78       	castu.h	r8
8000938c:	50 18       	stdsp	sp[0x4],r8
8000938e:	c4 68       	rjmp	8000941a <_vfprintf_r+0x12ee>
80009390:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009394:	40 3c       	lddsp	r12,sp[0xc]
80009396:	58 0c       	cp.w	r12,0
80009398:	c1 d0       	breq	800093d2 <_vfprintf_r+0x12a6>
8000939a:	10 36       	cp.w	r6,r8
8000939c:	c0 64       	brge	800093a8 <_vfprintf_r+0x127c>
8000939e:	fa cb f9 44 	sub	r11,sp,-1724
800093a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093a6:	c1 f8       	rjmp	800093e4 <_vfprintf_r+0x12b8>
800093a8:	fa c8 f9 50 	sub	r8,sp,-1712
800093ac:	1a d8       	st.w	--sp,r8
800093ae:	fa c8 fa b8 	sub	r8,sp,-1352
800093b2:	0c 9b       	mov	r11,r6
800093b4:	1a d8       	st.w	--sp,r8
800093b6:	fa c8 fb b4 	sub	r8,sp,-1100
800093ba:	04 9a       	mov	r10,r2
800093bc:	1a d8       	st.w	--sp,r8
800093be:	08 9c       	mov	r12,r4
800093c0:	fa c8 f9 40 	sub	r8,sp,-1728
800093c4:	fa c9 ff b4 	sub	r9,sp,-76
800093c8:	fe b0 f5 1a 	rcall	80007dfc <get_arg>
800093cc:	2f dd       	sub	sp,-12
800093ce:	78 0b       	ld.w	r11,r12[0x0]
800093d0:	c2 48       	rjmp	80009418 <_vfprintf_r+0x12ec>
800093d2:	ee ca ff ff 	sub	r10,r7,-1
800093d6:	10 37       	cp.w	r7,r8
800093d8:	c0 94       	brge	800093ea <_vfprintf_r+0x12be>
800093da:	fa c9 f9 44 	sub	r9,sp,-1724
800093de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093e2:	14 97       	mov	r7,r10
800093e4:	ec fb fd 88 	ld.w	r11,r6[-632]
800093e8:	c1 88       	rjmp	80009418 <_vfprintf_r+0x12ec>
800093ea:	41 09       	lddsp	r9,sp[0x40]
800093ec:	59 f8       	cp.w	r8,31
800093ee:	e0 89 00 11 	brgt	80009410 <_vfprintf_r+0x12e4>
800093f2:	f2 cb ff fc 	sub	r11,r9,-4
800093f6:	51 0b       	stdsp	sp[0x40],r11
800093f8:	fa c6 f9 44 	sub	r6,sp,-1724
800093fc:	72 0b       	ld.w	r11,r9[0x0]
800093fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009402:	f3 4b fd 88 	st.w	r9[-632],r11
80009406:	2f f8       	sub	r8,-1
80009408:	14 97       	mov	r7,r10
8000940a:	fb 48 06 b4 	st.w	sp[1716],r8
8000940e:	c0 58       	rjmp	80009418 <_vfprintf_r+0x12ec>
80009410:	72 0b       	ld.w	r11,r9[0x0]
80009412:	14 97       	mov	r7,r10
80009414:	2f c9       	sub	r9,-4
80009416:	51 09       	stdsp	sp[0x40],r9
80009418:	50 1b       	stdsp	sp[0x4],r11
8000941a:	30 0e       	mov	lr,0
8000941c:	30 18       	mov	r8,1
8000941e:	50 0e       	stdsp	sp[0x0],lr
80009420:	c2 29       	rjmp	80009664 <_vfprintf_r+0x1538>
80009422:	50 a7       	stdsp	sp[0x28],r7
80009424:	50 80       	stdsp	sp[0x20],r0
80009426:	0c 97       	mov	r7,r6
80009428:	04 94       	mov	r4,r2
8000942a:	06 96       	mov	r6,r3
8000942c:	02 92       	mov	r2,r1
8000942e:	fe cc b4 66 	sub	r12,pc,-19354
80009432:	40 93       	lddsp	r3,sp[0x24]
80009434:	10 90       	mov	r0,r8
80009436:	40 41       	lddsp	r1,sp[0x10]
80009438:	50 dc       	stdsp	sp[0x34],r12
8000943a:	ed b5 00 05 	bld	r5,0x5
8000943e:	c5 51       	brne	800094e8 <_vfprintf_r+0x13bc>
80009440:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009444:	40 3b       	lddsp	r11,sp[0xc]
80009446:	58 0b       	cp.w	r11,0
80009448:	c2 20       	breq	8000948c <_vfprintf_r+0x1360>
8000944a:	10 36       	cp.w	r6,r8
8000944c:	c0 a4       	brge	80009460 <_vfprintf_r+0x1334>
8000944e:	fa ca f9 44 	sub	r10,sp,-1724
80009452:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009456:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000945a:	fa e9 00 00 	st.d	sp[0],r8
8000945e:	cf 28       	rjmp	80009642 <_vfprintf_r+0x1516>
80009460:	fa c8 f9 50 	sub	r8,sp,-1712
80009464:	1a d8       	st.w	--sp,r8
80009466:	fa c8 fa b8 	sub	r8,sp,-1352
8000946a:	04 9a       	mov	r10,r2
8000946c:	1a d8       	st.w	--sp,r8
8000946e:	0c 9b       	mov	r11,r6
80009470:	fa c8 fb b4 	sub	r8,sp,-1100
80009474:	08 9c       	mov	r12,r4
80009476:	1a d8       	st.w	--sp,r8
80009478:	fa c8 f9 40 	sub	r8,sp,-1728
8000947c:	fa c9 ff b4 	sub	r9,sp,-76
80009480:	fe b0 f4 be 	rcall	80007dfc <get_arg>
80009484:	2f dd       	sub	sp,-12
80009486:	f8 ea 00 00 	ld.d	r10,r12[0]
8000948a:	c0 c8       	rjmp	800094a2 <_vfprintf_r+0x1376>
8000948c:	ee ca ff ff 	sub	r10,r7,-1
80009490:	10 37       	cp.w	r7,r8
80009492:	c0 b4       	brge	800094a8 <_vfprintf_r+0x137c>
80009494:	fa c9 f9 44 	sub	r9,sp,-1724
80009498:	14 97       	mov	r7,r10
8000949a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000949e:	ec ea fd 88 	ld.d	r10,r6[-632]
800094a2:	fa eb 00 00 	st.d	sp[0],r10
800094a6:	cc e8       	rjmp	80009642 <_vfprintf_r+0x1516>
800094a8:	41 09       	lddsp	r9,sp[0x40]
800094aa:	59 f8       	cp.w	r8,31
800094ac:	e0 89 00 16 	brgt	800094d8 <_vfprintf_r+0x13ac>
800094b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800094b4:	f2 cb ff f8 	sub	r11,r9,-8
800094b8:	fa e7 00 00 	st.d	sp[0],r6
800094bc:	51 0b       	stdsp	sp[0x40],r11
800094be:	fa c6 f9 44 	sub	r6,sp,-1724
800094c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094c6:	fa e6 00 00 	ld.d	r6,sp[0]
800094ca:	f2 e7 fd 88 	st.d	r9[-632],r6
800094ce:	2f f8       	sub	r8,-1
800094d0:	14 97       	mov	r7,r10
800094d2:	fb 48 06 b4 	st.w	sp[1716],r8
800094d6:	cb 68       	rjmp	80009642 <_vfprintf_r+0x1516>
800094d8:	f2 e6 00 00 	ld.d	r6,r9[0]
800094dc:	2f 89       	sub	r9,-8
800094de:	fa e7 00 00 	st.d	sp[0],r6
800094e2:	51 09       	stdsp	sp[0x40],r9
800094e4:	14 97       	mov	r7,r10
800094e6:	ca e8       	rjmp	80009642 <_vfprintf_r+0x1516>
800094e8:	ed b5 00 04 	bld	r5,0x4
800094ec:	c1 71       	brne	8000951a <_vfprintf_r+0x13ee>
800094ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094f2:	40 3e       	lddsp	lr,sp[0xc]
800094f4:	58 0e       	cp.w	lr,0
800094f6:	c0 80       	breq	80009506 <_vfprintf_r+0x13da>
800094f8:	10 36       	cp.w	r6,r8
800094fa:	c6 94       	brge	800095cc <_vfprintf_r+0x14a0>
800094fc:	fa cc f9 44 	sub	r12,sp,-1724
80009500:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009504:	c8 28       	rjmp	80009608 <_vfprintf_r+0x14dc>
80009506:	ee ca ff ff 	sub	r10,r7,-1
8000950a:	10 37       	cp.w	r7,r8
8000950c:	e0 84 00 81 	brge	8000960e <_vfprintf_r+0x14e2>
80009510:	fa cb f9 44 	sub	r11,sp,-1724
80009514:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009518:	c7 78       	rjmp	80009606 <_vfprintf_r+0x14da>
8000951a:	ed b5 00 06 	bld	r5,0x6
8000951e:	c4 b1       	brne	800095b4 <_vfprintf_r+0x1488>
80009520:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009524:	40 3c       	lddsp	r12,sp[0xc]
80009526:	58 0c       	cp.w	r12,0
80009528:	c1 d0       	breq	80009562 <_vfprintf_r+0x1436>
8000952a:	10 36       	cp.w	r6,r8
8000952c:	c0 64       	brge	80009538 <_vfprintf_r+0x140c>
8000952e:	fa cb f9 44 	sub	r11,sp,-1724
80009532:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009536:	c1 f8       	rjmp	80009574 <_vfprintf_r+0x1448>
80009538:	fa c8 f9 50 	sub	r8,sp,-1712
8000953c:	1a d8       	st.w	--sp,r8
8000953e:	fa c8 fa b8 	sub	r8,sp,-1352
80009542:	1a d8       	st.w	--sp,r8
80009544:	fa c8 fb b4 	sub	r8,sp,-1100
80009548:	1a d8       	st.w	--sp,r8
8000954a:	fa c8 f9 40 	sub	r8,sp,-1728
8000954e:	fa c9 ff b4 	sub	r9,sp,-76
80009552:	04 9a       	mov	r10,r2
80009554:	0c 9b       	mov	r11,r6
80009556:	08 9c       	mov	r12,r4
80009558:	fe b0 f4 52 	rcall	80007dfc <get_arg>
8000955c:	2f dd       	sub	sp,-12
8000955e:	98 18       	ld.sh	r8,r12[0x2]
80009560:	c2 78       	rjmp	800095ae <_vfprintf_r+0x1482>
80009562:	ee ca ff ff 	sub	r10,r7,-1
80009566:	10 37       	cp.w	r7,r8
80009568:	c0 a4       	brge	8000957c <_vfprintf_r+0x1450>
8000956a:	fa c9 f9 44 	sub	r9,sp,-1724
8000956e:	14 97       	mov	r7,r10
80009570:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009574:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009578:	c1 b8       	rjmp	800095ae <_vfprintf_r+0x1482>
8000957a:	d7 03       	nop
8000957c:	41 09       	lddsp	r9,sp[0x40]
8000957e:	59 f8       	cp.w	r8,31
80009580:	e0 89 00 13 	brgt	800095a6 <_vfprintf_r+0x147a>
80009584:	f2 cb ff fc 	sub	r11,r9,-4
80009588:	51 0b       	stdsp	sp[0x40],r11
8000958a:	72 09       	ld.w	r9,r9[0x0]
8000958c:	fa c6 f9 44 	sub	r6,sp,-1724
80009590:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009594:	2f f8       	sub	r8,-1
80009596:	f7 49 fd 88 	st.w	r11[-632],r9
8000959a:	fb 48 06 b4 	st.w	sp[1716],r8
8000959e:	14 97       	mov	r7,r10
800095a0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800095a4:	c0 58       	rjmp	800095ae <_vfprintf_r+0x1482>
800095a6:	92 18       	ld.sh	r8,r9[0x2]
800095a8:	14 97       	mov	r7,r10
800095aa:	2f c9       	sub	r9,-4
800095ac:	51 09       	stdsp	sp[0x40],r9
800095ae:	5c 78       	castu.h	r8
800095b0:	50 18       	stdsp	sp[0x4],r8
800095b2:	c4 68       	rjmp	8000963e <_vfprintf_r+0x1512>
800095b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095b8:	40 3c       	lddsp	r12,sp[0xc]
800095ba:	58 0c       	cp.w	r12,0
800095bc:	c1 d0       	breq	800095f6 <_vfprintf_r+0x14ca>
800095be:	10 36       	cp.w	r6,r8
800095c0:	c0 64       	brge	800095cc <_vfprintf_r+0x14a0>
800095c2:	fa cb f9 44 	sub	r11,sp,-1724
800095c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095ca:	c1 f8       	rjmp	80009608 <_vfprintf_r+0x14dc>
800095cc:	fa c8 f9 50 	sub	r8,sp,-1712
800095d0:	1a d8       	st.w	--sp,r8
800095d2:	fa c8 fa b8 	sub	r8,sp,-1352
800095d6:	0c 9b       	mov	r11,r6
800095d8:	1a d8       	st.w	--sp,r8
800095da:	fa c8 fb b4 	sub	r8,sp,-1100
800095de:	04 9a       	mov	r10,r2
800095e0:	1a d8       	st.w	--sp,r8
800095e2:	08 9c       	mov	r12,r4
800095e4:	fa c8 f9 40 	sub	r8,sp,-1728
800095e8:	fa c9 ff b4 	sub	r9,sp,-76
800095ec:	fe b0 f4 08 	rcall	80007dfc <get_arg>
800095f0:	2f dd       	sub	sp,-12
800095f2:	78 0b       	ld.w	r11,r12[0x0]
800095f4:	c2 48       	rjmp	8000963c <_vfprintf_r+0x1510>
800095f6:	ee ca ff ff 	sub	r10,r7,-1
800095fa:	10 37       	cp.w	r7,r8
800095fc:	c0 94       	brge	8000960e <_vfprintf_r+0x14e2>
800095fe:	fa c9 f9 44 	sub	r9,sp,-1724
80009602:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009606:	14 97       	mov	r7,r10
80009608:	ec fb fd 88 	ld.w	r11,r6[-632]
8000960c:	c1 88       	rjmp	8000963c <_vfprintf_r+0x1510>
8000960e:	41 09       	lddsp	r9,sp[0x40]
80009610:	59 f8       	cp.w	r8,31
80009612:	e0 89 00 11 	brgt	80009634 <_vfprintf_r+0x1508>
80009616:	f2 cb ff fc 	sub	r11,r9,-4
8000961a:	51 0b       	stdsp	sp[0x40],r11
8000961c:	fa c6 f9 44 	sub	r6,sp,-1724
80009620:	72 0b       	ld.w	r11,r9[0x0]
80009622:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009626:	f3 4b fd 88 	st.w	r9[-632],r11
8000962a:	2f f8       	sub	r8,-1
8000962c:	14 97       	mov	r7,r10
8000962e:	fb 48 06 b4 	st.w	sp[1716],r8
80009632:	c0 58       	rjmp	8000963c <_vfprintf_r+0x1510>
80009634:	72 0b       	ld.w	r11,r9[0x0]
80009636:	14 97       	mov	r7,r10
80009638:	2f c9       	sub	r9,-4
8000963a:	51 09       	stdsp	sp[0x40],r9
8000963c:	50 1b       	stdsp	sp[0x4],r11
8000963e:	30 0e       	mov	lr,0
80009640:	50 0e       	stdsp	sp[0x0],lr
80009642:	40 08       	lddsp	r8,sp[0x0]
80009644:	40 1c       	lddsp	r12,sp[0x4]
80009646:	18 48       	or	r8,r12
80009648:	5f 19       	srne	r9
8000964a:	0a 98       	mov	r8,r5
8000964c:	eb e9 00 09 	and	r9,r5,r9
80009650:	a1 b8       	sbr	r8,0x1
80009652:	58 09       	cp.w	r9,0
80009654:	c0 70       	breq	80009662 <_vfprintf_r+0x1536>
80009656:	10 95       	mov	r5,r8
80009658:	fb 60 06 b9 	st.b	sp[1721],r0
8000965c:	33 08       	mov	r8,48
8000965e:	fb 68 06 b8 	st.b	sp[1720],r8
80009662:	30 28       	mov	r8,2
80009664:	30 09       	mov	r9,0
80009666:	fb 69 06 bb 	st.b	sp[1723],r9
8000966a:	0a 99       	mov	r9,r5
8000966c:	a7 d9       	cbr	r9,0x7
8000966e:	40 2b       	lddsp	r11,sp[0x8]
80009670:	40 16       	lddsp	r6,sp[0x4]
80009672:	58 0b       	cp.w	r11,0
80009674:	5f 1a       	srne	r10
80009676:	f2 05 17 40 	movge	r5,r9
8000967a:	fa c2 f9 78 	sub	r2,sp,-1672
8000967e:	40 09       	lddsp	r9,sp[0x0]
80009680:	0c 49       	or	r9,r6
80009682:	5f 19       	srne	r9
80009684:	f5 e9 10 09 	or	r9,r10,r9
80009688:	c5 c0       	breq	80009740 <_vfprintf_r+0x1614>
8000968a:	30 19       	mov	r9,1
8000968c:	f2 08 18 00 	cp.b	r8,r9
80009690:	c0 60       	breq	8000969c <_vfprintf_r+0x1570>
80009692:	30 29       	mov	r9,2
80009694:	f2 08 18 00 	cp.b	r8,r9
80009698:	c0 41       	brne	800096a0 <_vfprintf_r+0x1574>
8000969a:	c3 c8       	rjmp	80009712 <_vfprintf_r+0x15e6>
8000969c:	04 96       	mov	r6,r2
8000969e:	c3 08       	rjmp	800096fe <_vfprintf_r+0x15d2>
800096a0:	04 96       	mov	r6,r2
800096a2:	fa e8 00 00 	ld.d	r8,sp[0]
800096a6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800096aa:	2d 0a       	sub	r10,-48
800096ac:	0c fa       	st.b	--r6,r10
800096ae:	f0 0b 16 03 	lsr	r11,r8,0x3
800096b2:	f2 0c 16 03 	lsr	r12,r9,0x3
800096b6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800096ba:	18 99       	mov	r9,r12
800096bc:	16 98       	mov	r8,r11
800096be:	58 08       	cp.w	r8,0
800096c0:	5c 29       	cpc	r9
800096c2:	cf 21       	brne	800096a6 <_vfprintf_r+0x157a>
800096c4:	fa e9 00 00 	st.d	sp[0],r8
800096c8:	ed b5 00 00 	bld	r5,0x0
800096cc:	c4 51       	brne	80009756 <_vfprintf_r+0x162a>
800096ce:	33 09       	mov	r9,48
800096d0:	f2 0a 18 00 	cp.b	r10,r9
800096d4:	c4 10       	breq	80009756 <_vfprintf_r+0x162a>
800096d6:	0c f9       	st.b	--r6,r9
800096d8:	c3 f8       	rjmp	80009756 <_vfprintf_r+0x162a>
800096da:	fa ea 00 00 	ld.d	r10,sp[0]
800096de:	30 a8       	mov	r8,10
800096e0:	30 09       	mov	r9,0
800096e2:	e0 a0 1a 19 	rcall	8000cb14 <__avr32_umod64>
800096e6:	30 a8       	mov	r8,10
800096e8:	2d 0a       	sub	r10,-48
800096ea:	30 09       	mov	r9,0
800096ec:	ac 8a       	st.b	r6[0x0],r10
800096ee:	fa ea 00 00 	ld.d	r10,sp[0]
800096f2:	e0 a0 18 df 	rcall	8000c8b0 <__avr32_udiv64>
800096f6:	16 99       	mov	r9,r11
800096f8:	14 98       	mov	r8,r10
800096fa:	fa e9 00 00 	st.d	sp[0],r8
800096fe:	20 16       	sub	r6,1
80009700:	fa ea 00 00 	ld.d	r10,sp[0]
80009704:	58 9a       	cp.w	r10,9
80009706:	5c 2b       	cpc	r11
80009708:	fe 9b ff e9 	brhi	800096da <_vfprintf_r+0x15ae>
8000970c:	1b f8       	ld.ub	r8,sp[0x7]
8000970e:	2d 08       	sub	r8,-48
80009710:	c2 08       	rjmp	80009750 <_vfprintf_r+0x1624>
80009712:	04 96       	mov	r6,r2
80009714:	fa e8 00 00 	ld.d	r8,sp[0]
80009718:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000971c:	40 de       	lddsp	lr,sp[0x34]
8000971e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009722:	0c fa       	st.b	--r6,r10
80009724:	f2 0b 16 04 	lsr	r11,r9,0x4
80009728:	f0 0a 16 04 	lsr	r10,r8,0x4
8000972c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009730:	16 99       	mov	r9,r11
80009732:	14 98       	mov	r8,r10
80009734:	58 08       	cp.w	r8,0
80009736:	5c 29       	cpc	r9
80009738:	cf 01       	brne	80009718 <_vfprintf_r+0x15ec>
8000973a:	fa e9 00 00 	st.d	sp[0],r8
8000973e:	c0 c8       	rjmp	80009756 <_vfprintf_r+0x162a>
80009740:	58 08       	cp.w	r8,0
80009742:	c0 91       	brne	80009754 <_vfprintf_r+0x1628>
80009744:	ed b5 00 00 	bld	r5,0x0
80009748:	c0 61       	brne	80009754 <_vfprintf_r+0x1628>
8000974a:	fa c6 f9 79 	sub	r6,sp,-1671
8000974e:	33 08       	mov	r8,48
80009750:	ac 88       	st.b	r6[0x0],r8
80009752:	c0 28       	rjmp	80009756 <_vfprintf_r+0x162a>
80009754:	04 96       	mov	r6,r2
80009756:	0c 12       	sub	r2,r6
80009758:	c1 c8       	rjmp	80009790 <_vfprintf_r+0x1664>
8000975a:	50 a7       	stdsp	sp[0x28],r7
8000975c:	50 80       	stdsp	sp[0x20],r0
8000975e:	40 93       	lddsp	r3,sp[0x24]
80009760:	0c 97       	mov	r7,r6
80009762:	10 90       	mov	r0,r8
80009764:	04 94       	mov	r4,r2
80009766:	40 41       	lddsp	r1,sp[0x10]
80009768:	58 08       	cp.w	r8,0
8000976a:	e0 80 04 4f 	breq	8000a008 <_vfprintf_r+0x1edc>
8000976e:	fb 68 06 60 	st.b	sp[1632],r8
80009772:	30 0c       	mov	r12,0
80009774:	30 08       	mov	r8,0
80009776:	30 12       	mov	r2,1
80009778:	fb 68 06 bb 	st.b	sp[1723],r8
8000977c:	50 2c       	stdsp	sp[0x8],r12
8000977e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009782:	c0 78       	rjmp	80009790 <_vfprintf_r+0x1664>
80009784:	30 0b       	mov	r11,0
80009786:	50 2b       	stdsp	sp[0x8],r11
80009788:	c0 48       	rjmp	80009790 <_vfprintf_r+0x1664>
8000978a:	40 22       	lddsp	r2,sp[0x8]
8000978c:	30 0a       	mov	r10,0
8000978e:	50 2a       	stdsp	sp[0x8],r10
80009790:	40 29       	lddsp	r9,sp[0x8]
80009792:	e4 09 0c 49 	max	r9,r2,r9
80009796:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000979a:	50 39       	stdsp	sp[0xc],r9
8000979c:	0a 9e       	mov	lr,r5
8000979e:	30 09       	mov	r9,0
800097a0:	e2 1e 00 02 	andl	lr,0x2,COH
800097a4:	f2 08 18 00 	cp.b	r8,r9
800097a8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800097ac:	f7 b8 01 ff 	subne	r8,-1
800097b0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800097b4:	0a 9b       	mov	r11,r5
800097b6:	58 0e       	cp.w	lr,0
800097b8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800097bc:	f7 bc 01 fe 	subne	r12,-2
800097c0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800097c4:	e2 1b 00 84 	andl	r11,0x84,COH
800097c8:	50 fe       	stdsp	sp[0x3c],lr
800097ca:	50 9b       	stdsp	sp[0x24],r11
800097cc:	c4 71       	brne	8000985a <_vfprintf_r+0x172e>
800097ce:	40 8a       	lddsp	r10,sp[0x20]
800097d0:	40 39       	lddsp	r9,sp[0xc]
800097d2:	12 1a       	sub	r10,r9
800097d4:	50 4a       	stdsp	sp[0x10],r10
800097d6:	58 0a       	cp.w	r10,0
800097d8:	e0 89 00 20 	brgt	80009818 <_vfprintf_r+0x16ec>
800097dc:	c3 f8       	rjmp	8000985a <_vfprintf_r+0x172e>
800097de:	2f 09       	sub	r9,-16
800097e0:	2f f8       	sub	r8,-1
800097e2:	fe ce b8 02 	sub	lr,pc,-18430
800097e6:	31 0c       	mov	r12,16
800097e8:	fb 49 06 90 	st.w	sp[1680],r9
800097ec:	87 0e       	st.w	r3[0x0],lr
800097ee:	87 1c       	st.w	r3[0x4],r12
800097f0:	fb 48 06 8c 	st.w	sp[1676],r8
800097f4:	58 78       	cp.w	r8,7
800097f6:	e0 89 00 04 	brgt	800097fe <_vfprintf_r+0x16d2>
800097fa:	2f 83       	sub	r3,-8
800097fc:	c0 b8       	rjmp	80009812 <_vfprintf_r+0x16e6>
800097fe:	fa ca f9 78 	sub	r10,sp,-1672
80009802:	02 9b       	mov	r11,r1
80009804:	08 9c       	mov	r12,r4
80009806:	fe b0 f4 85 	rcall	80008110 <__sprint_r>
8000980a:	e0 81 04 10 	brne	8000a02a <_vfprintf_r+0x1efe>
8000980e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009812:	40 4b       	lddsp	r11,sp[0x10]
80009814:	21 0b       	sub	r11,16
80009816:	50 4b       	stdsp	sp[0x10],r11
80009818:	fa f9 06 90 	ld.w	r9,sp[1680]
8000981c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009820:	fe ca b8 40 	sub	r10,pc,-18368
80009824:	40 4e       	lddsp	lr,sp[0x10]
80009826:	59 0e       	cp.w	lr,16
80009828:	fe 99 ff db 	brgt	800097de <_vfprintf_r+0x16b2>
8000982c:	1c 09       	add	r9,lr
8000982e:	2f f8       	sub	r8,-1
80009830:	87 0a       	st.w	r3[0x0],r10
80009832:	fb 49 06 90 	st.w	sp[1680],r9
80009836:	87 1e       	st.w	r3[0x4],lr
80009838:	fb 48 06 8c 	st.w	sp[1676],r8
8000983c:	58 78       	cp.w	r8,7
8000983e:	e0 89 00 04 	brgt	80009846 <_vfprintf_r+0x171a>
80009842:	2f 83       	sub	r3,-8
80009844:	c0 b8       	rjmp	8000985a <_vfprintf_r+0x172e>
80009846:	fa ca f9 78 	sub	r10,sp,-1672
8000984a:	02 9b       	mov	r11,r1
8000984c:	08 9c       	mov	r12,r4
8000984e:	fe b0 f4 61 	rcall	80008110 <__sprint_r>
80009852:	e0 81 03 ec 	brne	8000a02a <_vfprintf_r+0x1efe>
80009856:	fa c3 f9 e0 	sub	r3,sp,-1568
8000985a:	30 09       	mov	r9,0
8000985c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009860:	f2 08 18 00 	cp.b	r8,r9
80009864:	c1 f0       	breq	800098a2 <_vfprintf_r+0x1776>
80009866:	fa f8 06 90 	ld.w	r8,sp[1680]
8000986a:	fa c9 f9 45 	sub	r9,sp,-1723
8000986e:	2f f8       	sub	r8,-1
80009870:	87 09       	st.w	r3[0x0],r9
80009872:	fb 48 06 90 	st.w	sp[1680],r8
80009876:	30 19       	mov	r9,1
80009878:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000987c:	87 19       	st.w	r3[0x4],r9
8000987e:	2f f8       	sub	r8,-1
80009880:	fb 48 06 8c 	st.w	sp[1676],r8
80009884:	58 78       	cp.w	r8,7
80009886:	e0 89 00 04 	brgt	8000988e <_vfprintf_r+0x1762>
8000988a:	2f 83       	sub	r3,-8
8000988c:	c0 b8       	rjmp	800098a2 <_vfprintf_r+0x1776>
8000988e:	fa ca f9 78 	sub	r10,sp,-1672
80009892:	02 9b       	mov	r11,r1
80009894:	08 9c       	mov	r12,r4
80009896:	fe b0 f4 3d 	rcall	80008110 <__sprint_r>
8000989a:	e0 81 03 c8 	brne	8000a02a <_vfprintf_r+0x1efe>
8000989e:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a2:	40 fc       	lddsp	r12,sp[0x3c]
800098a4:	58 0c       	cp.w	r12,0
800098a6:	c1 f0       	breq	800098e4 <_vfprintf_r+0x17b8>
800098a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800098ac:	fa c9 f9 48 	sub	r9,sp,-1720
800098b0:	2f e8       	sub	r8,-2
800098b2:	87 09       	st.w	r3[0x0],r9
800098b4:	fb 48 06 90 	st.w	sp[1680],r8
800098b8:	30 29       	mov	r9,2
800098ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098be:	87 19       	st.w	r3[0x4],r9
800098c0:	2f f8       	sub	r8,-1
800098c2:	fb 48 06 8c 	st.w	sp[1676],r8
800098c6:	58 78       	cp.w	r8,7
800098c8:	e0 89 00 04 	brgt	800098d0 <_vfprintf_r+0x17a4>
800098cc:	2f 83       	sub	r3,-8
800098ce:	c0 b8       	rjmp	800098e4 <_vfprintf_r+0x17b8>
800098d0:	fa ca f9 78 	sub	r10,sp,-1672
800098d4:	02 9b       	mov	r11,r1
800098d6:	08 9c       	mov	r12,r4
800098d8:	fe b0 f4 1c 	rcall	80008110 <__sprint_r>
800098dc:	e0 81 03 a7 	brne	8000a02a <_vfprintf_r+0x1efe>
800098e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098e4:	40 9b       	lddsp	r11,sp[0x24]
800098e6:	e0 4b 00 80 	cp.w	r11,128
800098ea:	c4 71       	brne	80009978 <_vfprintf_r+0x184c>
800098ec:	40 8a       	lddsp	r10,sp[0x20]
800098ee:	40 39       	lddsp	r9,sp[0xc]
800098f0:	12 1a       	sub	r10,r9
800098f2:	50 4a       	stdsp	sp[0x10],r10
800098f4:	58 0a       	cp.w	r10,0
800098f6:	e0 89 00 20 	brgt	80009936 <_vfprintf_r+0x180a>
800098fa:	c3 f8       	rjmp	80009978 <_vfprintf_r+0x184c>
800098fc:	2f 09       	sub	r9,-16
800098fe:	2f f8       	sub	r8,-1
80009900:	fe ce b9 10 	sub	lr,pc,-18160
80009904:	31 0c       	mov	r12,16
80009906:	fb 49 06 90 	st.w	sp[1680],r9
8000990a:	87 0e       	st.w	r3[0x0],lr
8000990c:	87 1c       	st.w	r3[0x4],r12
8000990e:	fb 48 06 8c 	st.w	sp[1676],r8
80009912:	58 78       	cp.w	r8,7
80009914:	e0 89 00 04 	brgt	8000991c <_vfprintf_r+0x17f0>
80009918:	2f 83       	sub	r3,-8
8000991a:	c0 b8       	rjmp	80009930 <_vfprintf_r+0x1804>
8000991c:	fa ca f9 78 	sub	r10,sp,-1672
80009920:	02 9b       	mov	r11,r1
80009922:	08 9c       	mov	r12,r4
80009924:	fe b0 f3 f6 	rcall	80008110 <__sprint_r>
80009928:	e0 81 03 81 	brne	8000a02a <_vfprintf_r+0x1efe>
8000992c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009930:	40 4b       	lddsp	r11,sp[0x10]
80009932:	21 0b       	sub	r11,16
80009934:	50 4b       	stdsp	sp[0x10],r11
80009936:	fa f9 06 90 	ld.w	r9,sp[1680]
8000993a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000993e:	fe ca b9 4e 	sub	r10,pc,-18098
80009942:	40 4e       	lddsp	lr,sp[0x10]
80009944:	59 0e       	cp.w	lr,16
80009946:	fe 99 ff db 	brgt	800098fc <_vfprintf_r+0x17d0>
8000994a:	1c 09       	add	r9,lr
8000994c:	2f f8       	sub	r8,-1
8000994e:	87 0a       	st.w	r3[0x0],r10
80009950:	fb 49 06 90 	st.w	sp[1680],r9
80009954:	87 1e       	st.w	r3[0x4],lr
80009956:	fb 48 06 8c 	st.w	sp[1676],r8
8000995a:	58 78       	cp.w	r8,7
8000995c:	e0 89 00 04 	brgt	80009964 <_vfprintf_r+0x1838>
80009960:	2f 83       	sub	r3,-8
80009962:	c0 b8       	rjmp	80009978 <_vfprintf_r+0x184c>
80009964:	fa ca f9 78 	sub	r10,sp,-1672
80009968:	02 9b       	mov	r11,r1
8000996a:	08 9c       	mov	r12,r4
8000996c:	fe b0 f3 d2 	rcall	80008110 <__sprint_r>
80009970:	e0 81 03 5d 	brne	8000a02a <_vfprintf_r+0x1efe>
80009974:	fa c3 f9 e0 	sub	r3,sp,-1568
80009978:	40 2c       	lddsp	r12,sp[0x8]
8000997a:	04 1c       	sub	r12,r2
8000997c:	50 2c       	stdsp	sp[0x8],r12
8000997e:	58 0c       	cp.w	r12,0
80009980:	e0 89 00 20 	brgt	800099c0 <_vfprintf_r+0x1894>
80009984:	c3 f8       	rjmp	80009a02 <_vfprintf_r+0x18d6>
80009986:	2f 09       	sub	r9,-16
80009988:	2f f8       	sub	r8,-1
8000998a:	fe cb b9 9a 	sub	r11,pc,-18022
8000998e:	31 0a       	mov	r10,16
80009990:	fb 49 06 90 	st.w	sp[1680],r9
80009994:	87 0b       	st.w	r3[0x0],r11
80009996:	87 1a       	st.w	r3[0x4],r10
80009998:	fb 48 06 8c 	st.w	sp[1676],r8
8000999c:	58 78       	cp.w	r8,7
8000999e:	e0 89 00 04 	brgt	800099a6 <_vfprintf_r+0x187a>
800099a2:	2f 83       	sub	r3,-8
800099a4:	c0 b8       	rjmp	800099ba <_vfprintf_r+0x188e>
800099a6:	fa ca f9 78 	sub	r10,sp,-1672
800099aa:	02 9b       	mov	r11,r1
800099ac:	08 9c       	mov	r12,r4
800099ae:	fe b0 f3 b1 	rcall	80008110 <__sprint_r>
800099b2:	e0 81 03 3c 	brne	8000a02a <_vfprintf_r+0x1efe>
800099b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ba:	40 29       	lddsp	r9,sp[0x8]
800099bc:	21 09       	sub	r9,16
800099be:	50 29       	stdsp	sp[0x8],r9
800099c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800099c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099c8:	fe ca b9 d8 	sub	r10,pc,-17960
800099cc:	40 2e       	lddsp	lr,sp[0x8]
800099ce:	59 0e       	cp.w	lr,16
800099d0:	fe 99 ff db 	brgt	80009986 <_vfprintf_r+0x185a>
800099d4:	1c 09       	add	r9,lr
800099d6:	2f f8       	sub	r8,-1
800099d8:	87 0a       	st.w	r3[0x0],r10
800099da:	fb 49 06 90 	st.w	sp[1680],r9
800099de:	87 1e       	st.w	r3[0x4],lr
800099e0:	fb 48 06 8c 	st.w	sp[1676],r8
800099e4:	58 78       	cp.w	r8,7
800099e6:	e0 89 00 04 	brgt	800099ee <_vfprintf_r+0x18c2>
800099ea:	2f 83       	sub	r3,-8
800099ec:	c0 b8       	rjmp	80009a02 <_vfprintf_r+0x18d6>
800099ee:	fa ca f9 78 	sub	r10,sp,-1672
800099f2:	02 9b       	mov	r11,r1
800099f4:	08 9c       	mov	r12,r4
800099f6:	fe b0 f3 8d 	rcall	80008110 <__sprint_r>
800099fa:	e0 81 03 18 	brne	8000a02a <_vfprintf_r+0x1efe>
800099fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a02:	ed b5 00 08 	bld	r5,0x8
80009a06:	c0 b0       	breq	80009a1c <_vfprintf_r+0x18f0>
80009a08:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a0c:	87 12       	st.w	r3[0x4],r2
80009a0e:	87 06       	st.w	r3[0x0],r6
80009a10:	f0 02 00 02 	add	r2,r8,r2
80009a14:	fb 42 06 90 	st.w	sp[1680],r2
80009a18:	e0 8f 01 d4 	bral	80009dc0 <_vfprintf_r+0x1c94>
80009a1c:	e0 40 00 65 	cp.w	r0,101
80009a20:	e0 8a 01 d6 	brle	80009dcc <_vfprintf_r+0x1ca0>
80009a24:	30 08       	mov	r8,0
80009a26:	30 09       	mov	r9,0
80009a28:	40 5b       	lddsp	r11,sp[0x14]
80009a2a:	40 7a       	lddsp	r10,sp[0x1c]
80009a2c:	e0 a0 15 3b 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
80009a30:	c7 90       	breq	80009b22 <_vfprintf_r+0x19f6>
80009a32:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a36:	fe c9 ba 5a 	sub	r9,pc,-17830
80009a3a:	2f f8       	sub	r8,-1
80009a3c:	87 09       	st.w	r3[0x0],r9
80009a3e:	fb 48 06 90 	st.w	sp[1680],r8
80009a42:	30 19       	mov	r9,1
80009a44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a48:	87 19       	st.w	r3[0x4],r9
80009a4a:	2f f8       	sub	r8,-1
80009a4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a50:	58 78       	cp.w	r8,7
80009a52:	e0 89 00 05 	brgt	80009a5c <_vfprintf_r+0x1930>
80009a56:	2f 83       	sub	r3,-8
80009a58:	c0 c8       	rjmp	80009a70 <_vfprintf_r+0x1944>
80009a5a:	d7 03       	nop
80009a5c:	fa ca f9 78 	sub	r10,sp,-1672
80009a60:	02 9b       	mov	r11,r1
80009a62:	08 9c       	mov	r12,r4
80009a64:	fe b0 f3 56 	rcall	80008110 <__sprint_r>
80009a68:	e0 81 02 e1 	brne	8000a02a <_vfprintf_r+0x1efe>
80009a6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a70:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a74:	40 6c       	lddsp	r12,sp[0x18]
80009a76:	18 38       	cp.w	r8,r12
80009a78:	c0 55       	brlt	80009a82 <_vfprintf_r+0x1956>
80009a7a:	ed b5 00 00 	bld	r5,0x0
80009a7e:	e0 81 02 6b 	brne	80009f54 <_vfprintf_r+0x1e28>
80009a82:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a86:	2f f8       	sub	r8,-1
80009a88:	40 cb       	lddsp	r11,sp[0x30]
80009a8a:	fb 48 06 90 	st.w	sp[1680],r8
80009a8e:	30 19       	mov	r9,1
80009a90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a94:	87 0b       	st.w	r3[0x0],r11
80009a96:	2f f8       	sub	r8,-1
80009a98:	87 19       	st.w	r3[0x4],r9
80009a9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9e:	58 78       	cp.w	r8,7
80009aa0:	e0 89 00 04 	brgt	80009aa8 <_vfprintf_r+0x197c>
80009aa4:	2f 83       	sub	r3,-8
80009aa6:	c0 b8       	rjmp	80009abc <_vfprintf_r+0x1990>
80009aa8:	fa ca f9 78 	sub	r10,sp,-1672
80009aac:	02 9b       	mov	r11,r1
80009aae:	08 9c       	mov	r12,r4
80009ab0:	fe b0 f3 30 	rcall	80008110 <__sprint_r>
80009ab4:	e0 81 02 bb 	brne	8000a02a <_vfprintf_r+0x1efe>
80009ab8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009abc:	40 66       	lddsp	r6,sp[0x18]
80009abe:	20 16       	sub	r6,1
80009ac0:	58 06       	cp.w	r6,0
80009ac2:	e0 89 00 1d 	brgt	80009afc <_vfprintf_r+0x19d0>
80009ac6:	e0 8f 02 47 	bral	80009f54 <_vfprintf_r+0x1e28>
80009aca:	2f 09       	sub	r9,-16
80009acc:	2f f8       	sub	r8,-1
80009ace:	fb 49 06 90 	st.w	sp[1680],r9
80009ad2:	87 02       	st.w	r3[0x0],r2
80009ad4:	87 10       	st.w	r3[0x4],r0
80009ad6:	fb 48 06 8c 	st.w	sp[1676],r8
80009ada:	58 78       	cp.w	r8,7
80009adc:	e0 89 00 04 	brgt	80009ae4 <_vfprintf_r+0x19b8>
80009ae0:	2f 83       	sub	r3,-8
80009ae2:	c0 b8       	rjmp	80009af8 <_vfprintf_r+0x19cc>
80009ae4:	fa ca f9 78 	sub	r10,sp,-1672
80009ae8:	02 9b       	mov	r11,r1
80009aea:	08 9c       	mov	r12,r4
80009aec:	fe b0 f3 12 	rcall	80008110 <__sprint_r>
80009af0:	e0 81 02 9d 	brne	8000a02a <_vfprintf_r+0x1efe>
80009af4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009af8:	21 06       	sub	r6,16
80009afa:	c0 48       	rjmp	80009b02 <_vfprintf_r+0x19d6>
80009afc:	fe c2 bb 0c 	sub	r2,pc,-17652
80009b00:	31 00       	mov	r0,16
80009b02:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b06:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b0a:	fe ca bb 1a 	sub	r10,pc,-17638
80009b0e:	59 06       	cp.w	r6,16
80009b10:	fe 99 ff dd 	brgt	80009aca <_vfprintf_r+0x199e>
80009b14:	0c 09       	add	r9,r6
80009b16:	87 0a       	st.w	r3[0x0],r10
80009b18:	fb 49 06 90 	st.w	sp[1680],r9
80009b1c:	2f f8       	sub	r8,-1
80009b1e:	87 16       	st.w	r3[0x4],r6
80009b20:	c5 39       	rjmp	80009dc6 <_vfprintf_r+0x1c9a>
80009b22:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009b26:	58 0a       	cp.w	r10,0
80009b28:	e0 89 00 92 	brgt	80009c4c <_vfprintf_r+0x1b20>
80009b2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b30:	fe c9 bb 54 	sub	r9,pc,-17580
80009b34:	2f f8       	sub	r8,-1
80009b36:	87 09       	st.w	r3[0x0],r9
80009b38:	fb 48 06 90 	st.w	sp[1680],r8
80009b3c:	30 19       	mov	r9,1
80009b3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b42:	87 19       	st.w	r3[0x4],r9
80009b44:	2f f8       	sub	r8,-1
80009b46:	fb 48 06 8c 	st.w	sp[1676],r8
80009b4a:	58 78       	cp.w	r8,7
80009b4c:	e0 89 00 04 	brgt	80009b54 <_vfprintf_r+0x1a28>
80009b50:	2f 83       	sub	r3,-8
80009b52:	c0 b8       	rjmp	80009b68 <_vfprintf_r+0x1a3c>
80009b54:	fa ca f9 78 	sub	r10,sp,-1672
80009b58:	02 9b       	mov	r11,r1
80009b5a:	08 9c       	mov	r12,r4
80009b5c:	fe b0 f2 da 	rcall	80008110 <__sprint_r>
80009b60:	e0 81 02 65 	brne	8000a02a <_vfprintf_r+0x1efe>
80009b64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b68:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b6c:	58 08       	cp.w	r8,0
80009b6e:	c0 81       	brne	80009b7e <_vfprintf_r+0x1a52>
80009b70:	40 6a       	lddsp	r10,sp[0x18]
80009b72:	58 0a       	cp.w	r10,0
80009b74:	c0 51       	brne	80009b7e <_vfprintf_r+0x1a52>
80009b76:	ed b5 00 00 	bld	r5,0x0
80009b7a:	e0 81 01 ed 	brne	80009f54 <_vfprintf_r+0x1e28>
80009b7e:	40 c9       	lddsp	r9,sp[0x30]
80009b80:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b84:	2f f8       	sub	r8,-1
80009b86:	87 09       	st.w	r3[0x0],r9
80009b88:	fb 48 06 90 	st.w	sp[1680],r8
80009b8c:	30 19       	mov	r9,1
80009b8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b92:	87 19       	st.w	r3[0x4],r9
80009b94:	2f f8       	sub	r8,-1
80009b96:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9a:	58 78       	cp.w	r8,7
80009b9c:	e0 89 00 04 	brgt	80009ba4 <_vfprintf_r+0x1a78>
80009ba0:	2f 83       	sub	r3,-8
80009ba2:	c0 b8       	rjmp	80009bb8 <_vfprintf_r+0x1a8c>
80009ba4:	fa ca f9 78 	sub	r10,sp,-1672
80009ba8:	02 9b       	mov	r11,r1
80009baa:	08 9c       	mov	r12,r4
80009bac:	fe b0 f2 b2 	rcall	80008110 <__sprint_r>
80009bb0:	e0 81 02 3d 	brne	8000a02a <_vfprintf_r+0x1efe>
80009bb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bbc:	5c 32       	neg	r2
80009bbe:	58 02       	cp.w	r2,0
80009bc0:	e0 89 00 1d 	brgt	80009bfa <_vfprintf_r+0x1ace>
80009bc4:	c3 d8       	rjmp	80009c3e <_vfprintf_r+0x1b12>
80009bc6:	2f 09       	sub	r9,-16
80009bc8:	2f f8       	sub	r8,-1
80009bca:	31 0e       	mov	lr,16
80009bcc:	fb 49 06 90 	st.w	sp[1680],r9
80009bd0:	87 00       	st.w	r3[0x0],r0
80009bd2:	87 1e       	st.w	r3[0x4],lr
80009bd4:	fb 48 06 8c 	st.w	sp[1676],r8
80009bd8:	58 78       	cp.w	r8,7
80009bda:	e0 89 00 04 	brgt	80009be2 <_vfprintf_r+0x1ab6>
80009bde:	2f 83       	sub	r3,-8
80009be0:	c0 b8       	rjmp	80009bf6 <_vfprintf_r+0x1aca>
80009be2:	fa ca f9 78 	sub	r10,sp,-1672
80009be6:	02 9b       	mov	r11,r1
80009be8:	08 9c       	mov	r12,r4
80009bea:	fe b0 f2 93 	rcall	80008110 <__sprint_r>
80009bee:	e0 81 02 1e 	brne	8000a02a <_vfprintf_r+0x1efe>
80009bf2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bf6:	21 02       	sub	r2,16
80009bf8:	c0 38       	rjmp	80009bfe <_vfprintf_r+0x1ad2>
80009bfa:	fe c0 bc 0a 	sub	r0,pc,-17398
80009bfe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c06:	fe ca bc 16 	sub	r10,pc,-17386
80009c0a:	59 02       	cp.w	r2,16
80009c0c:	fe 99 ff dd 	brgt	80009bc6 <_vfprintf_r+0x1a9a>
80009c10:	04 09       	add	r9,r2
80009c12:	2f f8       	sub	r8,-1
80009c14:	87 0a       	st.w	r3[0x0],r10
80009c16:	fb 49 06 90 	st.w	sp[1680],r9
80009c1a:	87 12       	st.w	r3[0x4],r2
80009c1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c20:	58 78       	cp.w	r8,7
80009c22:	e0 89 00 04 	brgt	80009c2a <_vfprintf_r+0x1afe>
80009c26:	2f 83       	sub	r3,-8
80009c28:	c0 b8       	rjmp	80009c3e <_vfprintf_r+0x1b12>
80009c2a:	fa ca f9 78 	sub	r10,sp,-1672
80009c2e:	02 9b       	mov	r11,r1
80009c30:	08 9c       	mov	r12,r4
80009c32:	fe b0 f2 6f 	rcall	80008110 <__sprint_r>
80009c36:	e0 81 01 fa 	brne	8000a02a <_vfprintf_r+0x1efe>
80009c3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c3e:	40 6c       	lddsp	r12,sp[0x18]
80009c40:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c44:	87 06       	st.w	r3[0x0],r6
80009c46:	87 1c       	st.w	r3[0x4],r12
80009c48:	18 08       	add	r8,r12
80009c4a:	cb 98       	rjmp	80009dbc <_vfprintf_r+0x1c90>
80009c4c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c54:	40 6b       	lddsp	r11,sp[0x18]
80009c56:	16 3a       	cp.w	r10,r11
80009c58:	c6 f5       	brlt	80009d36 <_vfprintf_r+0x1c0a>
80009c5a:	16 09       	add	r9,r11
80009c5c:	2f f8       	sub	r8,-1
80009c5e:	87 06       	st.w	r3[0x0],r6
80009c60:	fb 49 06 90 	st.w	sp[1680],r9
80009c64:	87 1b       	st.w	r3[0x4],r11
80009c66:	fb 48 06 8c 	st.w	sp[1676],r8
80009c6a:	58 78       	cp.w	r8,7
80009c6c:	e0 89 00 04 	brgt	80009c74 <_vfprintf_r+0x1b48>
80009c70:	2f 83       	sub	r3,-8
80009c72:	c0 b8       	rjmp	80009c88 <_vfprintf_r+0x1b5c>
80009c74:	fa ca f9 78 	sub	r10,sp,-1672
80009c78:	02 9b       	mov	r11,r1
80009c7a:	08 9c       	mov	r12,r4
80009c7c:	fe b0 f2 4a 	rcall	80008110 <__sprint_r>
80009c80:	e0 81 01 d5 	brne	8000a02a <_vfprintf_r+0x1efe>
80009c84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c88:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c8c:	40 6a       	lddsp	r10,sp[0x18]
80009c8e:	14 16       	sub	r6,r10
80009c90:	58 06       	cp.w	r6,0
80009c92:	e0 89 00 1c 	brgt	80009cca <_vfprintf_r+0x1b9e>
80009c96:	c3 d8       	rjmp	80009d10 <_vfprintf_r+0x1be4>
80009c98:	2f 09       	sub	r9,-16
80009c9a:	2f f8       	sub	r8,-1
80009c9c:	fb 49 06 90 	st.w	sp[1680],r9
80009ca0:	87 02       	st.w	r3[0x0],r2
80009ca2:	87 10       	st.w	r3[0x4],r0
80009ca4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca8:	58 78       	cp.w	r8,7
80009caa:	e0 89 00 04 	brgt	80009cb2 <_vfprintf_r+0x1b86>
80009cae:	2f 83       	sub	r3,-8
80009cb0:	c0 b8       	rjmp	80009cc6 <_vfprintf_r+0x1b9a>
80009cb2:	fa ca f9 78 	sub	r10,sp,-1672
80009cb6:	02 9b       	mov	r11,r1
80009cb8:	08 9c       	mov	r12,r4
80009cba:	fe b0 f2 2b 	rcall	80008110 <__sprint_r>
80009cbe:	e0 81 01 b6 	brne	8000a02a <_vfprintf_r+0x1efe>
80009cc2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc6:	21 06       	sub	r6,16
80009cc8:	c0 48       	rjmp	80009cd0 <_vfprintf_r+0x1ba4>
80009cca:	fe c2 bc da 	sub	r2,pc,-17190
80009cce:	31 00       	mov	r0,16
80009cd0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd8:	fe ca bc e8 	sub	r10,pc,-17176
80009cdc:	59 06       	cp.w	r6,16
80009cde:	fe 99 ff dd 	brgt	80009c98 <_vfprintf_r+0x1b6c>
80009ce2:	0c 09       	add	r9,r6
80009ce4:	2f f8       	sub	r8,-1
80009ce6:	87 0a       	st.w	r3[0x0],r10
80009ce8:	fb 49 06 90 	st.w	sp[1680],r9
80009cec:	87 16       	st.w	r3[0x4],r6
80009cee:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf2:	58 78       	cp.w	r8,7
80009cf4:	e0 89 00 04 	brgt	80009cfc <_vfprintf_r+0x1bd0>
80009cf8:	2f 83       	sub	r3,-8
80009cfa:	c0 b8       	rjmp	80009d10 <_vfprintf_r+0x1be4>
80009cfc:	fa ca f9 78 	sub	r10,sp,-1672
80009d00:	02 9b       	mov	r11,r1
80009d02:	08 9c       	mov	r12,r4
80009d04:	fe b0 f2 06 	rcall	80008110 <__sprint_r>
80009d08:	e0 81 01 91 	brne	8000a02a <_vfprintf_r+0x1efe>
80009d0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d10:	ed b5 00 00 	bld	r5,0x0
80009d14:	e0 81 01 20 	brne	80009f54 <_vfprintf_r+0x1e28>
80009d18:	40 c9       	lddsp	r9,sp[0x30]
80009d1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d1e:	2f f8       	sub	r8,-1
80009d20:	87 09       	st.w	r3[0x0],r9
80009d22:	fb 48 06 90 	st.w	sp[1680],r8
80009d26:	30 19       	mov	r9,1
80009d28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d2c:	87 19       	st.w	r3[0x4],r9
80009d2e:	2f f8       	sub	r8,-1
80009d30:	fb 48 06 8c 	st.w	sp[1676],r8
80009d34:	c0 29       	rjmp	80009f38 <_vfprintf_r+0x1e0c>
80009d36:	14 09       	add	r9,r10
80009d38:	2f f8       	sub	r8,-1
80009d3a:	fb 49 06 90 	st.w	sp[1680],r9
80009d3e:	87 06       	st.w	r3[0x0],r6
80009d40:	87 1a       	st.w	r3[0x4],r10
80009d42:	fb 48 06 8c 	st.w	sp[1676],r8
80009d46:	58 78       	cp.w	r8,7
80009d48:	e0 89 00 04 	brgt	80009d50 <_vfprintf_r+0x1c24>
80009d4c:	2f 83       	sub	r3,-8
80009d4e:	c0 b8       	rjmp	80009d64 <_vfprintf_r+0x1c38>
80009d50:	fa ca f9 78 	sub	r10,sp,-1672
80009d54:	02 9b       	mov	r11,r1
80009d56:	08 9c       	mov	r12,r4
80009d58:	fe b0 f1 dc 	rcall	80008110 <__sprint_r>
80009d5c:	e0 81 01 67 	brne	8000a02a <_vfprintf_r+0x1efe>
80009d60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d64:	40 c8       	lddsp	r8,sp[0x30]
80009d66:	87 08       	st.w	r3[0x0],r8
80009d68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d6c:	2f f8       	sub	r8,-1
80009d6e:	30 19       	mov	r9,1
80009d70:	fb 48 06 90 	st.w	sp[1680],r8
80009d74:	87 19       	st.w	r3[0x4],r9
80009d76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d7a:	2f f8       	sub	r8,-1
80009d7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d80:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d84:	58 78       	cp.w	r8,7
80009d86:	e0 89 00 04 	brgt	80009d8e <_vfprintf_r+0x1c62>
80009d8a:	2f 83       	sub	r3,-8
80009d8c:	c0 b8       	rjmp	80009da2 <_vfprintf_r+0x1c76>
80009d8e:	fa ca f9 78 	sub	r10,sp,-1672
80009d92:	02 9b       	mov	r11,r1
80009d94:	08 9c       	mov	r12,r4
80009d96:	fe b0 f1 bd 	rcall	80008110 <__sprint_r>
80009d9a:	e0 81 01 48 	brne	8000a02a <_vfprintf_r+0x1efe>
80009d9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009da2:	04 06       	add	r6,r2
80009da4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009da8:	87 06       	st.w	r3[0x0],r6
80009daa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009dae:	40 66       	lddsp	r6,sp[0x18]
80009db0:	40 6e       	lddsp	lr,sp[0x18]
80009db2:	10 16       	sub	r6,r8
80009db4:	f2 08 01 08 	sub	r8,r9,r8
80009db8:	87 16       	st.w	r3[0x4],r6
80009dba:	1c 08       	add	r8,lr
80009dbc:	fb 48 06 90 	st.w	sp[1680],r8
80009dc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dc4:	2f f8       	sub	r8,-1
80009dc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dca:	cb 78       	rjmp	80009f38 <_vfprintf_r+0x1e0c>
80009dcc:	40 6c       	lddsp	r12,sp[0x18]
80009dce:	58 1c       	cp.w	r12,1
80009dd0:	e0 89 00 06 	brgt	80009ddc <_vfprintf_r+0x1cb0>
80009dd4:	ed b5 00 00 	bld	r5,0x0
80009dd8:	e0 81 00 85 	brne	80009ee2 <_vfprintf_r+0x1db6>
80009ddc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009de0:	2f f8       	sub	r8,-1
80009de2:	30 19       	mov	r9,1
80009de4:	fb 48 06 90 	st.w	sp[1680],r8
80009de8:	87 06       	st.w	r3[0x0],r6
80009dea:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dee:	87 19       	st.w	r3[0x4],r9
80009df0:	2f f8       	sub	r8,-1
80009df2:	fb 48 06 8c 	st.w	sp[1676],r8
80009df6:	58 78       	cp.w	r8,7
80009df8:	e0 89 00 04 	brgt	80009e00 <_vfprintf_r+0x1cd4>
80009dfc:	2f 83       	sub	r3,-8
80009dfe:	c0 b8       	rjmp	80009e14 <_vfprintf_r+0x1ce8>
80009e00:	fa ca f9 78 	sub	r10,sp,-1672
80009e04:	02 9b       	mov	r11,r1
80009e06:	08 9c       	mov	r12,r4
80009e08:	fe b0 f1 84 	rcall	80008110 <__sprint_r>
80009e0c:	e0 81 01 0f 	brne	8000a02a <_vfprintf_r+0x1efe>
80009e10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e18:	2f f8       	sub	r8,-1
80009e1a:	40 cb       	lddsp	r11,sp[0x30]
80009e1c:	fb 48 06 90 	st.w	sp[1680],r8
80009e20:	30 19       	mov	r9,1
80009e22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e26:	87 0b       	st.w	r3[0x0],r11
80009e28:	2f f8       	sub	r8,-1
80009e2a:	87 19       	st.w	r3[0x4],r9
80009e2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e30:	58 78       	cp.w	r8,7
80009e32:	e0 89 00 05 	brgt	80009e3c <_vfprintf_r+0x1d10>
80009e36:	2f 83       	sub	r3,-8
80009e38:	c0 c8       	rjmp	80009e50 <_vfprintf_r+0x1d24>
80009e3a:	d7 03       	nop
80009e3c:	fa ca f9 78 	sub	r10,sp,-1672
80009e40:	02 9b       	mov	r11,r1
80009e42:	08 9c       	mov	r12,r4
80009e44:	fe b0 f1 66 	rcall	80008110 <__sprint_r>
80009e48:	e0 81 00 f1 	brne	8000a02a <_vfprintf_r+0x1efe>
80009e4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e50:	30 08       	mov	r8,0
80009e52:	30 09       	mov	r9,0
80009e54:	40 5b       	lddsp	r11,sp[0x14]
80009e56:	40 7a       	lddsp	r10,sp[0x1c]
80009e58:	e0 a0 13 25 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
80009e5c:	40 68       	lddsp	r8,sp[0x18]
80009e5e:	20 18       	sub	r8,1
80009e60:	58 0c       	cp.w	r12,0
80009e62:	c0 d1       	brne	80009e7c <_vfprintf_r+0x1d50>
80009e64:	2f f6       	sub	r6,-1
80009e66:	87 18       	st.w	r3[0x4],r8
80009e68:	87 06       	st.w	r3[0x0],r6
80009e6a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e6e:	10 06       	add	r6,r8
80009e70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e74:	fb 46 06 90 	st.w	sp[1680],r6
80009e78:	2f f8       	sub	r8,-1
80009e7a:	c3 18       	rjmp	80009edc <_vfprintf_r+0x1db0>
80009e7c:	10 96       	mov	r6,r8
80009e7e:	58 08       	cp.w	r8,0
80009e80:	e0 89 00 1c 	brgt	80009eb8 <_vfprintf_r+0x1d8c>
80009e84:	c4 b8       	rjmp	80009f1a <_vfprintf_r+0x1dee>
80009e86:	2f 09       	sub	r9,-16
80009e88:	2f f8       	sub	r8,-1
80009e8a:	fb 49 06 90 	st.w	sp[1680],r9
80009e8e:	87 02       	st.w	r3[0x0],r2
80009e90:	87 10       	st.w	r3[0x4],r0
80009e92:	fb 48 06 8c 	st.w	sp[1676],r8
80009e96:	58 78       	cp.w	r8,7
80009e98:	e0 89 00 04 	brgt	80009ea0 <_vfprintf_r+0x1d74>
80009e9c:	2f 83       	sub	r3,-8
80009e9e:	c0 b8       	rjmp	80009eb4 <_vfprintf_r+0x1d88>
80009ea0:	fa ca f9 78 	sub	r10,sp,-1672
80009ea4:	02 9b       	mov	r11,r1
80009ea6:	08 9c       	mov	r12,r4
80009ea8:	fe b0 f1 34 	rcall	80008110 <__sprint_r>
80009eac:	e0 81 00 bf 	brne	8000a02a <_vfprintf_r+0x1efe>
80009eb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eb4:	21 06       	sub	r6,16
80009eb6:	c0 48       	rjmp	80009ebe <_vfprintf_r+0x1d92>
80009eb8:	fe c2 be c8 	sub	r2,pc,-16696
80009ebc:	31 00       	mov	r0,16
80009ebe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ec2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ec6:	fe ca be d6 	sub	r10,pc,-16682
80009eca:	59 06       	cp.w	r6,16
80009ecc:	fe 99 ff dd 	brgt	80009e86 <_vfprintf_r+0x1d5a>
80009ed0:	0c 09       	add	r9,r6
80009ed2:	87 0a       	st.w	r3[0x0],r10
80009ed4:	fb 49 06 90 	st.w	sp[1680],r9
80009ed8:	2f f8       	sub	r8,-1
80009eda:	87 16       	st.w	r3[0x4],r6
80009edc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ee0:	c0 e8       	rjmp	80009efc <_vfprintf_r+0x1dd0>
80009ee2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ee6:	2f f8       	sub	r8,-1
80009ee8:	30 19       	mov	r9,1
80009eea:	fb 48 06 90 	st.w	sp[1680],r8
80009eee:	87 06       	st.w	r3[0x0],r6
80009ef0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ef4:	87 19       	st.w	r3[0x4],r9
80009ef6:	2f f8       	sub	r8,-1
80009ef8:	fb 48 06 8c 	st.w	sp[1676],r8
80009efc:	58 78       	cp.w	r8,7
80009efe:	e0 89 00 04 	brgt	80009f06 <_vfprintf_r+0x1dda>
80009f02:	2f 83       	sub	r3,-8
80009f04:	c0 b8       	rjmp	80009f1a <_vfprintf_r+0x1dee>
80009f06:	fa ca f9 78 	sub	r10,sp,-1672
80009f0a:	02 9b       	mov	r11,r1
80009f0c:	08 9c       	mov	r12,r4
80009f0e:	fe b0 f1 01 	rcall	80008110 <__sprint_r>
80009f12:	e0 81 00 8c 	brne	8000a02a <_vfprintf_r+0x1efe>
80009f16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f1a:	40 ea       	lddsp	r10,sp[0x38]
80009f1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f20:	14 08       	add	r8,r10
80009f22:	fa c9 f9 64 	sub	r9,sp,-1692
80009f26:	fb 48 06 90 	st.w	sp[1680],r8
80009f2a:	87 1a       	st.w	r3[0x4],r10
80009f2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f30:	87 09       	st.w	r3[0x0],r9
80009f32:	2f f8       	sub	r8,-1
80009f34:	fb 48 06 8c 	st.w	sp[1676],r8
80009f38:	58 78       	cp.w	r8,7
80009f3a:	e0 89 00 04 	brgt	80009f42 <_vfprintf_r+0x1e16>
80009f3e:	2f 83       	sub	r3,-8
80009f40:	c0 a8       	rjmp	80009f54 <_vfprintf_r+0x1e28>
80009f42:	fa ca f9 78 	sub	r10,sp,-1672
80009f46:	02 9b       	mov	r11,r1
80009f48:	08 9c       	mov	r12,r4
80009f4a:	fe b0 f0 e3 	rcall	80008110 <__sprint_r>
80009f4e:	c6 e1       	brne	8000a02a <_vfprintf_r+0x1efe>
80009f50:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f54:	e2 15 00 04 	andl	r5,0x4,COH
80009f58:	c3 f0       	breq	80009fd6 <_vfprintf_r+0x1eaa>
80009f5a:	40 86       	lddsp	r6,sp[0x20]
80009f5c:	40 39       	lddsp	r9,sp[0xc]
80009f5e:	12 16       	sub	r6,r9
80009f60:	58 06       	cp.w	r6,0
80009f62:	e0 89 00 1a 	brgt	80009f96 <_vfprintf_r+0x1e6a>
80009f66:	c3 88       	rjmp	80009fd6 <_vfprintf_r+0x1eaa>
80009f68:	2f 09       	sub	r9,-16
80009f6a:	2f f8       	sub	r8,-1
80009f6c:	fb 49 06 90 	st.w	sp[1680],r9
80009f70:	87 05       	st.w	r3[0x0],r5
80009f72:	87 12       	st.w	r3[0x4],r2
80009f74:	fb 48 06 8c 	st.w	sp[1676],r8
80009f78:	58 78       	cp.w	r8,7
80009f7a:	e0 89 00 04 	brgt	80009f82 <_vfprintf_r+0x1e56>
80009f7e:	2f 83       	sub	r3,-8
80009f80:	c0 98       	rjmp	80009f92 <_vfprintf_r+0x1e66>
80009f82:	00 9a       	mov	r10,r0
80009f84:	02 9b       	mov	r11,r1
80009f86:	08 9c       	mov	r12,r4
80009f88:	fe b0 f0 c4 	rcall	80008110 <__sprint_r>
80009f8c:	c4 f1       	brne	8000a02a <_vfprintf_r+0x1efe>
80009f8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f92:	21 06       	sub	r6,16
80009f94:	c0 68       	rjmp	80009fa0 <_vfprintf_r+0x1e74>
80009f96:	fe c5 bf b6 	sub	r5,pc,-16458
80009f9a:	31 02       	mov	r2,16
80009f9c:	fa c0 f9 78 	sub	r0,sp,-1672
80009fa0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fa8:	fe ca bf c8 	sub	r10,pc,-16440
80009fac:	59 06       	cp.w	r6,16
80009fae:	fe 99 ff dd 	brgt	80009f68 <_vfprintf_r+0x1e3c>
80009fb2:	0c 09       	add	r9,r6
80009fb4:	2f f8       	sub	r8,-1
80009fb6:	87 0a       	st.w	r3[0x0],r10
80009fb8:	87 16       	st.w	r3[0x4],r6
80009fba:	fb 49 06 90 	st.w	sp[1680],r9
80009fbe:	fb 48 06 8c 	st.w	sp[1676],r8
80009fc2:	58 78       	cp.w	r8,7
80009fc4:	e0 8a 00 09 	brle	80009fd6 <_vfprintf_r+0x1eaa>
80009fc8:	fa ca f9 78 	sub	r10,sp,-1672
80009fcc:	02 9b       	mov	r11,r1
80009fce:	08 9c       	mov	r12,r4
80009fd0:	fe b0 f0 a0 	rcall	80008110 <__sprint_r>
80009fd4:	c2 b1       	brne	8000a02a <_vfprintf_r+0x1efe>
80009fd6:	40 bc       	lddsp	r12,sp[0x2c]
80009fd8:	40 36       	lddsp	r6,sp[0xc]
80009fda:	40 8e       	lddsp	lr,sp[0x20]
80009fdc:	ec 0e 0c 48 	max	r8,r6,lr
80009fe0:	10 0c       	add	r12,r8
80009fe2:	50 bc       	stdsp	sp[0x2c],r12
80009fe4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fe8:	58 08       	cp.w	r8,0
80009fea:	c0 80       	breq	80009ffa <_vfprintf_r+0x1ece>
80009fec:	fa ca f9 78 	sub	r10,sp,-1672
80009ff0:	02 9b       	mov	r11,r1
80009ff2:	08 9c       	mov	r12,r4
80009ff4:	fe b0 f0 8e 	rcall	80008110 <__sprint_r>
80009ff8:	c1 91       	brne	8000a02a <_vfprintf_r+0x1efe>
80009ffa:	30 0b       	mov	r11,0
80009ffc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a000:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a004:	fe 9f f1 22 	bral	80008248 <_vfprintf_r+0x11c>
8000a008:	08 95       	mov	r5,r4
8000a00a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a00e:	58 08       	cp.w	r8,0
8000a010:	c0 80       	breq	8000a020 <_vfprintf_r+0x1ef4>
8000a012:	08 9c       	mov	r12,r4
8000a014:	fa ca f9 78 	sub	r10,sp,-1672
8000a018:	02 9b       	mov	r11,r1
8000a01a:	fe b0 f0 7b 	rcall	80008110 <__sprint_r>
8000a01e:	c0 61       	brne	8000a02a <_vfprintf_r+0x1efe>
8000a020:	30 08       	mov	r8,0
8000a022:	fb 48 06 8c 	st.w	sp[1676],r8
8000a026:	c0 28       	rjmp	8000a02a <_vfprintf_r+0x1efe>
8000a028:	40 41       	lddsp	r1,sp[0x10]
8000a02a:	82 68       	ld.sh	r8,r1[0xc]
8000a02c:	ed b8 00 06 	bld	r8,0x6
8000a030:	c0 31       	brne	8000a036 <_vfprintf_r+0x1f0a>
8000a032:	3f fa       	mov	r10,-1
8000a034:	50 ba       	stdsp	sp[0x2c],r10
8000a036:	40 bc       	lddsp	r12,sp[0x2c]
8000a038:	fe 3d f9 44 	sub	sp,-1724
8000a03c:	d8 32       	popm	r0-r7,pc
8000a03e:	d7 03       	nop

8000a040 <__swsetup_r>:
8000a040:	d4 21       	pushm	r4-r7,lr
8000a042:	e0 68 0a 3c 	mov	r8,2620
8000a046:	18 96       	mov	r6,r12
8000a048:	16 97       	mov	r7,r11
8000a04a:	70 0c       	ld.w	r12,r8[0x0]
8000a04c:	58 0c       	cp.w	r12,0
8000a04e:	c0 60       	breq	8000a05a <__swsetup_r+0x1a>
8000a050:	78 68       	ld.w	r8,r12[0x18]
8000a052:	58 08       	cp.w	r8,0
8000a054:	c0 31       	brne	8000a05a <__swsetup_r+0x1a>
8000a056:	e0 a0 07 bf 	rcall	8000afd4 <__sinit>
8000a05a:	fe c8 bf 4a 	sub	r8,pc,-16566
8000a05e:	10 37       	cp.w	r7,r8
8000a060:	c0 61       	brne	8000a06c <__swsetup_r+0x2c>
8000a062:	e0 68 0a 3c 	mov	r8,2620
8000a066:	70 08       	ld.w	r8,r8[0x0]
8000a068:	70 07       	ld.w	r7,r8[0x0]
8000a06a:	c1 28       	rjmp	8000a08e <__swsetup_r+0x4e>
8000a06c:	fe c8 bf 3c 	sub	r8,pc,-16580
8000a070:	10 37       	cp.w	r7,r8
8000a072:	c0 61       	brne	8000a07e <__swsetup_r+0x3e>
8000a074:	e0 68 0a 3c 	mov	r8,2620
8000a078:	70 08       	ld.w	r8,r8[0x0]
8000a07a:	70 17       	ld.w	r7,r8[0x4]
8000a07c:	c0 98       	rjmp	8000a08e <__swsetup_r+0x4e>
8000a07e:	fe c8 bf 2e 	sub	r8,pc,-16594
8000a082:	10 37       	cp.w	r7,r8
8000a084:	c0 51       	brne	8000a08e <__swsetup_r+0x4e>
8000a086:	e0 68 0a 3c 	mov	r8,2620
8000a08a:	70 08       	ld.w	r8,r8[0x0]
8000a08c:	70 27       	ld.w	r7,r8[0x8]
8000a08e:	8e 68       	ld.sh	r8,r7[0xc]
8000a090:	ed b8 00 03 	bld	r8,0x3
8000a094:	c1 e0       	breq	8000a0d0 <__swsetup_r+0x90>
8000a096:	ed b8 00 04 	bld	r8,0x4
8000a09a:	c3 e1       	brne	8000a116 <__swsetup_r+0xd6>
8000a09c:	ed b8 00 02 	bld	r8,0x2
8000a0a0:	c1 51       	brne	8000a0ca <__swsetup_r+0x8a>
8000a0a2:	6e db       	ld.w	r11,r7[0x34]
8000a0a4:	58 0b       	cp.w	r11,0
8000a0a6:	c0 a0       	breq	8000a0ba <__swsetup_r+0x7a>
8000a0a8:	ee c8 ff bc 	sub	r8,r7,-68
8000a0ac:	10 3b       	cp.w	r11,r8
8000a0ae:	c0 40       	breq	8000a0b6 <__swsetup_r+0x76>
8000a0b0:	0c 9c       	mov	r12,r6
8000a0b2:	e0 a0 08 2b 	rcall	8000b108 <_free_r>
8000a0b6:	30 08       	mov	r8,0
8000a0b8:	8f d8       	st.w	r7[0x34],r8
8000a0ba:	8e 68       	ld.sh	r8,r7[0xc]
8000a0bc:	e0 18 ff db 	andl	r8,0xffdb
8000a0c0:	ae 68       	st.h	r7[0xc],r8
8000a0c2:	30 08       	mov	r8,0
8000a0c4:	8f 18       	st.w	r7[0x4],r8
8000a0c6:	6e 48       	ld.w	r8,r7[0x10]
8000a0c8:	8f 08       	st.w	r7[0x0],r8
8000a0ca:	8e 68       	ld.sh	r8,r7[0xc]
8000a0cc:	a3 b8       	sbr	r8,0x3
8000a0ce:	ae 68       	st.h	r7[0xc],r8
8000a0d0:	6e 48       	ld.w	r8,r7[0x10]
8000a0d2:	58 08       	cp.w	r8,0
8000a0d4:	c0 b1       	brne	8000a0ea <__swsetup_r+0xaa>
8000a0d6:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d8:	e2 18 02 80 	andl	r8,0x280,COH
8000a0dc:	e0 48 02 00 	cp.w	r8,512
8000a0e0:	c0 50       	breq	8000a0ea <__swsetup_r+0xaa>
8000a0e2:	0c 9c       	mov	r12,r6
8000a0e4:	0e 9b       	mov	r11,r7
8000a0e6:	e0 a0 0a 4b 	rcall	8000b57c <__smakebuf_r>
8000a0ea:	8e 69       	ld.sh	r9,r7[0xc]
8000a0ec:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a0f0:	c0 70       	breq	8000a0fe <__swsetup_r+0xbe>
8000a0f2:	30 08       	mov	r8,0
8000a0f4:	8f 28       	st.w	r7[0x8],r8
8000a0f6:	6e 58       	ld.w	r8,r7[0x14]
8000a0f8:	5c 38       	neg	r8
8000a0fa:	8f 68       	st.w	r7[0x18],r8
8000a0fc:	c0 68       	rjmp	8000a108 <__swsetup_r+0xc8>
8000a0fe:	ed b9 00 01 	bld	r9,0x1
8000a102:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a106:	8f 28       	st.w	r7[0x8],r8
8000a108:	6e 48       	ld.w	r8,r7[0x10]
8000a10a:	58 08       	cp.w	r8,0
8000a10c:	c0 61       	brne	8000a118 <__swsetup_r+0xd8>
8000a10e:	8e 68       	ld.sh	r8,r7[0xc]
8000a110:	ed b8 00 07 	bld	r8,0x7
8000a114:	c0 21       	brne	8000a118 <__swsetup_r+0xd8>
8000a116:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a118:	d8 2a       	popm	r4-r7,pc,r12=0
8000a11a:	d7 03       	nop

8000a11c <quorem>:
8000a11c:	d4 31       	pushm	r0-r7,lr
8000a11e:	20 2d       	sub	sp,8
8000a120:	18 97       	mov	r7,r12
8000a122:	78 48       	ld.w	r8,r12[0x10]
8000a124:	76 46       	ld.w	r6,r11[0x10]
8000a126:	0c 38       	cp.w	r8,r6
8000a128:	c0 34       	brge	8000a12e <quorem+0x12>
8000a12a:	30 0c       	mov	r12,0
8000a12c:	c8 58       	rjmp	8000a236 <quorem+0x11a>
8000a12e:	ec c2 ff fc 	sub	r2,r6,-4
8000a132:	f6 c3 ff ec 	sub	r3,r11,-20
8000a136:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a13a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a13e:	2f f9       	sub	r9,-1
8000a140:	20 16       	sub	r6,1
8000a142:	f8 09 0d 08 	divu	r8,r12,r9
8000a146:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a14a:	ee c4 ff ec 	sub	r4,r7,-20
8000a14e:	10 95       	mov	r5,r8
8000a150:	58 08       	cp.w	r8,0
8000a152:	c4 10       	breq	8000a1d4 <quorem+0xb8>
8000a154:	30 09       	mov	r9,0
8000a156:	06 9a       	mov	r10,r3
8000a158:	08 98       	mov	r8,r4
8000a15a:	12 91       	mov	r1,r9
8000a15c:	50 0b       	stdsp	sp[0x0],r11
8000a15e:	70 0e       	ld.w	lr,r8[0x0]
8000a160:	b1 8e       	lsr	lr,0x10
8000a162:	50 1e       	stdsp	sp[0x4],lr
8000a164:	15 0e       	ld.w	lr,r10++
8000a166:	fc 00 16 10 	lsr	r0,lr,0x10
8000a16a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a16e:	ea 0e 03 41 	mac	r1,r5,lr
8000a172:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a176:	b1 81       	lsr	r1,0x10
8000a178:	40 1b       	lddsp	r11,sp[0x4]
8000a17a:	ea 00 02 40 	mul	r0,r5,r0
8000a17e:	e2 00 00 00 	add	r0,r1,r0
8000a182:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a186:	02 1b       	sub	r11,r1
8000a188:	50 1b       	stdsp	sp[0x4],r11
8000a18a:	70 0b       	ld.w	r11,r8[0x0]
8000a18c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a190:	02 09       	add	r9,r1
8000a192:	f2 0e 01 0e 	sub	lr,r9,lr
8000a196:	b0 1e       	st.h	r8[0x2],lr
8000a198:	fc 09 14 10 	asr	r9,lr,0x10
8000a19c:	40 1e       	lddsp	lr,sp[0x4]
8000a19e:	fc 09 00 09 	add	r9,lr,r9
8000a1a2:	b0 09       	st.h	r8[0x0],r9
8000a1a4:	e0 01 16 10 	lsr	r1,r0,0x10
8000a1a8:	2f c8       	sub	r8,-4
8000a1aa:	b1 49       	asr	r9,0x10
8000a1ac:	04 3a       	cp.w	r10,r2
8000a1ae:	fe 98 ff d8 	brls	8000a15e <quorem+0x42>
8000a1b2:	40 0b       	lddsp	r11,sp[0x0]
8000a1b4:	58 0c       	cp.w	r12,0
8000a1b6:	c0 f1       	brne	8000a1d4 <quorem+0xb8>
8000a1b8:	ec c8 ff fb 	sub	r8,r6,-5
8000a1bc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1c0:	c0 28       	rjmp	8000a1c4 <quorem+0xa8>
8000a1c2:	20 16       	sub	r6,1
8000a1c4:	20 48       	sub	r8,4
8000a1c6:	08 38       	cp.w	r8,r4
8000a1c8:	e0 88 00 05 	brls	8000a1d2 <quorem+0xb6>
8000a1cc:	70 09       	ld.w	r9,r8[0x0]
8000a1ce:	58 09       	cp.w	r9,0
8000a1d0:	cf 90       	breq	8000a1c2 <quorem+0xa6>
8000a1d2:	8f 46       	st.w	r7[0x10],r6
8000a1d4:	0e 9c       	mov	r12,r7
8000a1d6:	e0 a0 0a d2 	rcall	8000b77a <__mcmp>
8000a1da:	c2 d5       	brlt	8000a234 <quorem+0x118>
8000a1dc:	2f f5       	sub	r5,-1
8000a1de:	08 98       	mov	r8,r4
8000a1e0:	30 09       	mov	r9,0
8000a1e2:	07 0b       	ld.w	r11,r3++
8000a1e4:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a1e8:	70 0c       	ld.w	r12,r8[0x0]
8000a1ea:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a1ee:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a1f2:	14 1e       	sub	lr,r10
8000a1f4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1f8:	16 1a       	sub	r10,r11
8000a1fa:	12 0a       	add	r10,r9
8000a1fc:	b0 1a       	st.h	r8[0x2],r10
8000a1fe:	b1 4a       	asr	r10,0x10
8000a200:	fc 0a 00 09 	add	r9,lr,r10
8000a204:	b0 09       	st.h	r8[0x0],r9
8000a206:	2f c8       	sub	r8,-4
8000a208:	b1 49       	asr	r9,0x10
8000a20a:	04 33       	cp.w	r3,r2
8000a20c:	fe 98 ff eb 	brls	8000a1e2 <quorem+0xc6>
8000a210:	ec c8 ff fb 	sub	r8,r6,-5
8000a214:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a218:	58 09       	cp.w	r9,0
8000a21a:	c0 d1       	brne	8000a234 <quorem+0x118>
8000a21c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a220:	c0 28       	rjmp	8000a224 <quorem+0x108>
8000a222:	20 16       	sub	r6,1
8000a224:	20 48       	sub	r8,4
8000a226:	08 38       	cp.w	r8,r4
8000a228:	e0 88 00 05 	brls	8000a232 <quorem+0x116>
8000a22c:	70 09       	ld.w	r9,r8[0x0]
8000a22e:	58 09       	cp.w	r9,0
8000a230:	cf 90       	breq	8000a222 <quorem+0x106>
8000a232:	8f 46       	st.w	r7[0x10],r6
8000a234:	0a 9c       	mov	r12,r5
8000a236:	2f ed       	sub	sp,-8
8000a238:	d8 32       	popm	r0-r7,pc
8000a23a:	d7 03       	nop

8000a23c <_dtoa_r>:
8000a23c:	d4 31       	pushm	r0-r7,lr
8000a23e:	21 ad       	sub	sp,104
8000a240:	fa c4 ff 74 	sub	r4,sp,-140
8000a244:	18 97       	mov	r7,r12
8000a246:	16 95       	mov	r5,r11
8000a248:	68 2c       	ld.w	r12,r4[0x8]
8000a24a:	50 c9       	stdsp	sp[0x30],r9
8000a24c:	68 16       	ld.w	r6,r4[0x4]
8000a24e:	68 09       	ld.w	r9,r4[0x0]
8000a250:	50 e8       	stdsp	sp[0x38],r8
8000a252:	14 94       	mov	r4,r10
8000a254:	51 2c       	stdsp	sp[0x48],r12
8000a256:	fa e5 00 08 	st.d	sp[8],r4
8000a25a:	51 59       	stdsp	sp[0x54],r9
8000a25c:	6e 95       	ld.w	r5,r7[0x24]
8000a25e:	58 05       	cp.w	r5,0
8000a260:	c0 91       	brne	8000a272 <_dtoa_r+0x36>
8000a262:	31 0c       	mov	r12,16
8000a264:	fe b0 e8 f4 	rcall	8000744c <malloc>
8000a268:	99 35       	st.w	r12[0xc],r5
8000a26a:	8f 9c       	st.w	r7[0x24],r12
8000a26c:	99 15       	st.w	r12[0x4],r5
8000a26e:	99 25       	st.w	r12[0x8],r5
8000a270:	99 05       	st.w	r12[0x0],r5
8000a272:	6e 99       	ld.w	r9,r7[0x24]
8000a274:	72 08       	ld.w	r8,r9[0x0]
8000a276:	58 08       	cp.w	r8,0
8000a278:	c0 f0       	breq	8000a296 <_dtoa_r+0x5a>
8000a27a:	72 1a       	ld.w	r10,r9[0x4]
8000a27c:	91 1a       	st.w	r8[0x4],r10
8000a27e:	30 1a       	mov	r10,1
8000a280:	72 19       	ld.w	r9,r9[0x4]
8000a282:	f4 09 09 49 	lsl	r9,r10,r9
8000a286:	10 9b       	mov	r11,r8
8000a288:	91 29       	st.w	r8[0x8],r9
8000a28a:	0e 9c       	mov	r12,r7
8000a28c:	e0 a0 0a 90 	rcall	8000b7ac <_Bfree>
8000a290:	6e 98       	ld.w	r8,r7[0x24]
8000a292:	30 09       	mov	r9,0
8000a294:	91 09       	st.w	r8[0x0],r9
8000a296:	40 28       	lddsp	r8,sp[0x8]
8000a298:	10 94       	mov	r4,r8
8000a29a:	58 08       	cp.w	r8,0
8000a29c:	c0 64       	brge	8000a2a8 <_dtoa_r+0x6c>
8000a29e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a2a2:	50 28       	stdsp	sp[0x8],r8
8000a2a4:	30 18       	mov	r8,1
8000a2a6:	c0 28       	rjmp	8000a2aa <_dtoa_r+0x6e>
8000a2a8:	30 08       	mov	r8,0
8000a2aa:	8d 08       	st.w	r6[0x0],r8
8000a2ac:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a2b0:	40 26       	lddsp	r6,sp[0x8]
8000a2b2:	0c 98       	mov	r8,r6
8000a2b4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a2b8:	18 38       	cp.w	r8,r12
8000a2ba:	c2 01       	brne	8000a2fa <_dtoa_r+0xbe>
8000a2bc:	e0 68 27 0f 	mov	r8,9999
8000a2c0:	41 5b       	lddsp	r11,sp[0x54]
8000a2c2:	97 08       	st.w	r11[0x0],r8
8000a2c4:	40 3a       	lddsp	r10,sp[0xc]
8000a2c6:	58 0a       	cp.w	r10,0
8000a2c8:	c0 71       	brne	8000a2d6 <_dtoa_r+0x9a>
8000a2ca:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a2ce:	c0 41       	brne	8000a2d6 <_dtoa_r+0x9a>
8000a2d0:	fe cc c1 d0 	sub	r12,pc,-15920
8000a2d4:	c0 38       	rjmp	8000a2da <_dtoa_r+0x9e>
8000a2d6:	fe cc c1 ca 	sub	r12,pc,-15926
8000a2da:	41 29       	lddsp	r9,sp[0x48]
8000a2dc:	58 09       	cp.w	r9,0
8000a2de:	e0 80 05 9a 	breq	8000ae12 <_dtoa_r+0xbd6>
8000a2e2:	f8 c8 ff fd 	sub	r8,r12,-3
8000a2e6:	f8 c9 ff f8 	sub	r9,r12,-8
8000a2ea:	11 8b       	ld.ub	r11,r8[0x0]
8000a2ec:	30 0a       	mov	r10,0
8000a2ee:	41 25       	lddsp	r5,sp[0x48]
8000a2f0:	f4 0b 18 00 	cp.b	r11,r10
8000a2f4:	f2 08 17 10 	movne	r8,r9
8000a2f8:	c1 68       	rjmp	8000a324 <_dtoa_r+0xe8>
8000a2fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2fe:	30 08       	mov	r8,0
8000a300:	fa eb 00 3c 	st.d	sp[60],r10
8000a304:	30 09       	mov	r9,0
8000a306:	e0 a0 10 ce 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
8000a30a:	c1 00       	breq	8000a32a <_dtoa_r+0xee>
8000a30c:	30 18       	mov	r8,1
8000a30e:	41 5a       	lddsp	r10,sp[0x54]
8000a310:	95 08       	st.w	r10[0x0],r8
8000a312:	fe cc c3 36 	sub	r12,pc,-15562
8000a316:	41 29       	lddsp	r9,sp[0x48]
8000a318:	f8 08 00 08 	add	r8,r12,r8
8000a31c:	58 09       	cp.w	r9,0
8000a31e:	e0 80 05 7a 	breq	8000ae12 <_dtoa_r+0xbd6>
8000a322:	12 95       	mov	r5,r9
8000a324:	8b 08       	st.w	r5[0x0],r8
8000a326:	e0 8f 05 76 	bral	8000ae12 <_dtoa_r+0xbd6>
8000a32a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a32e:	fa c9 ff a0 	sub	r9,sp,-96
8000a332:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a336:	0e 9c       	mov	r12,r7
8000a338:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a33c:	e0 a0 0a 8a 	rcall	8000b850 <__d2b>
8000a340:	18 93       	mov	r3,r12
8000a342:	58 05       	cp.w	r5,0
8000a344:	c0 d0       	breq	8000a35e <_dtoa_r+0x122>
8000a346:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a34a:	30 04       	mov	r4,0
8000a34c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a350:	ea c5 03 ff 	sub	r5,r5,1023
8000a354:	10 9b       	mov	r11,r8
8000a356:	51 74       	stdsp	sp[0x5c],r4
8000a358:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a35c:	c2 58       	rjmp	8000a3a6 <_dtoa_r+0x16a>
8000a35e:	41 88       	lddsp	r8,sp[0x60]
8000a360:	41 9c       	lddsp	r12,sp[0x64]
8000a362:	10 0c       	add	r12,r8
8000a364:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a368:	e0 45 00 20 	cp.w	r5,32
8000a36c:	e0 8a 00 0e 	brle	8000a388 <_dtoa_r+0x14c>
8000a370:	f8 cc fb ee 	sub	r12,r12,-1042
8000a374:	40 3b       	lddsp	r11,sp[0xc]
8000a376:	ea 08 11 40 	rsub	r8,r5,64
8000a37a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a37e:	ec 08 09 46 	lsl	r6,r6,r8
8000a382:	0c 4c       	or	r12,r6
8000a384:	c0 78       	rjmp	8000a392 <_dtoa_r+0x156>
8000a386:	d7 03       	nop
8000a388:	ea 0c 11 20 	rsub	r12,r5,32
8000a38c:	40 3a       	lddsp	r10,sp[0xc]
8000a38e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a392:	e0 a0 10 14 	rcall	8000c3ba <__avr32_u32_to_f64>
8000a396:	fc 18 fe 10 	movh	r8,0xfe10
8000a39a:	30 19       	mov	r9,1
8000a39c:	ea c5 04 33 	sub	r5,r5,1075
8000a3a0:	f0 0b 00 0b 	add	r11,r8,r11
8000a3a4:	51 79       	stdsp	sp[0x5c],r9
8000a3a6:	30 08       	mov	r8,0
8000a3a8:	fc 19 3f f8 	movh	r9,0x3ff8
8000a3ac:	e0 a0 0e 9c 	rcall	8000c0e4 <__avr32_f64_sub>
8000a3b0:	e0 68 43 61 	mov	r8,17249
8000a3b4:	ea 18 63 6f 	orh	r8,0x636f
8000a3b8:	e0 69 87 a7 	mov	r9,34727
8000a3bc:	ea 19 3f d2 	orh	r9,0x3fd2
8000a3c0:	e0 a0 0d a6 	rcall	8000bf0c <__avr32_f64_mul>
8000a3c4:	e0 68 c8 b3 	mov	r8,51379
8000a3c8:	ea 18 8b 60 	orh	r8,0x8b60
8000a3cc:	e0 69 8a 28 	mov	r9,35368
8000a3d0:	ea 19 3f c6 	orh	r9,0x3fc6
8000a3d4:	e0 a0 0f 56 	rcall	8000c280 <__avr32_f64_add>
8000a3d8:	0a 9c       	mov	r12,r5
8000a3da:	14 90       	mov	r0,r10
8000a3dc:	16 91       	mov	r1,r11
8000a3de:	e0 a0 0f f2 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a3e2:	e0 68 79 fb 	mov	r8,31227
8000a3e6:	ea 18 50 9f 	orh	r8,0x509f
8000a3ea:	e0 69 44 13 	mov	r9,17427
8000a3ee:	ea 19 3f d3 	orh	r9,0x3fd3
8000a3f2:	e0 a0 0d 8d 	rcall	8000bf0c <__avr32_f64_mul>
8000a3f6:	14 98       	mov	r8,r10
8000a3f8:	16 99       	mov	r9,r11
8000a3fa:	00 9a       	mov	r10,r0
8000a3fc:	02 9b       	mov	r11,r1
8000a3fe:	e0 a0 0f 41 	rcall	8000c280 <__avr32_f64_add>
8000a402:	14 90       	mov	r0,r10
8000a404:	16 91       	mov	r1,r11
8000a406:	e0 a0 0f c7 	rcall	8000c394 <__avr32_f64_to_s32>
8000a40a:	30 08       	mov	r8,0
8000a40c:	18 96       	mov	r6,r12
8000a40e:	30 09       	mov	r9,0
8000a410:	00 9a       	mov	r10,r0
8000a412:	02 9b       	mov	r11,r1
8000a414:	e0 a0 10 8e 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a418:	c0 c0       	breq	8000a430 <_dtoa_r+0x1f4>
8000a41a:	0c 9c       	mov	r12,r6
8000a41c:	e0 a0 0f d3 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a420:	14 98       	mov	r8,r10
8000a422:	16 99       	mov	r9,r11
8000a424:	00 9a       	mov	r10,r0
8000a426:	02 9b       	mov	r11,r1
8000a428:	e0 a0 10 3d 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
8000a42c:	f7 b6 00 01 	subeq	r6,1
8000a430:	59 66       	cp.w	r6,22
8000a432:	e0 88 00 05 	brls	8000a43c <_dtoa_r+0x200>
8000a436:	30 18       	mov	r8,1
8000a438:	51 48       	stdsp	sp[0x50],r8
8000a43a:	c1 38       	rjmp	8000a460 <_dtoa_r+0x224>
8000a43c:	fe c8 c2 7c 	sub	r8,pc,-15748
8000a440:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a444:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a448:	e0 a0 10 74 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a44c:	f9 b4 00 00 	moveq	r4,0
8000a450:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a454:	f7 b6 01 01 	subne	r6,1
8000a458:	f9 bc 01 00 	movne	r12,0
8000a45c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a460:	41 90       	lddsp	r0,sp[0x64]
8000a462:	20 10       	sub	r0,1
8000a464:	0a 10       	sub	r0,r5
8000a466:	c0 46       	brmi	8000a46e <_dtoa_r+0x232>
8000a468:	50 40       	stdsp	sp[0x10],r0
8000a46a:	30 00       	mov	r0,0
8000a46c:	c0 48       	rjmp	8000a474 <_dtoa_r+0x238>
8000a46e:	30 0b       	mov	r11,0
8000a470:	5c 30       	neg	r0
8000a472:	50 4b       	stdsp	sp[0x10],r11
8000a474:	ec 02 11 00 	rsub	r2,r6,0
8000a478:	58 06       	cp.w	r6,0
8000a47a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a47e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a482:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a486:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a48a:	f9 b2 04 00 	movge	r2,0
8000a48e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a492:	f9 b9 05 00 	movlt	r9,0
8000a496:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a49a:	40 c8       	lddsp	r8,sp[0x30]
8000a49c:	58 98       	cp.w	r8,9
8000a49e:	e0 8b 00 20 	brhi	8000a4de <_dtoa_r+0x2a2>
8000a4a2:	58 58       	cp.w	r8,5
8000a4a4:	f9 b4 0a 01 	movle	r4,1
8000a4a8:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a4ac:	f7 b5 09 04 	subgt	r5,4
8000a4b0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a4b4:	f9 b4 09 00 	movgt	r4,0
8000a4b8:	40 cc       	lddsp	r12,sp[0x30]
8000a4ba:	58 3c       	cp.w	r12,3
8000a4bc:	c2 d0       	breq	8000a516 <_dtoa_r+0x2da>
8000a4be:	e0 89 00 05 	brgt	8000a4c8 <_dtoa_r+0x28c>
8000a4c2:	58 2c       	cp.w	r12,2
8000a4c4:	c1 01       	brne	8000a4e4 <_dtoa_r+0x2a8>
8000a4c6:	c1 88       	rjmp	8000a4f6 <_dtoa_r+0x2ba>
8000a4c8:	40 cb       	lddsp	r11,sp[0x30]
8000a4ca:	58 4b       	cp.w	r11,4
8000a4cc:	c0 60       	breq	8000a4d8 <_dtoa_r+0x29c>
8000a4ce:	58 5b       	cp.w	r11,5
8000a4d0:	c0 a1       	brne	8000a4e4 <_dtoa_r+0x2a8>
8000a4d2:	30 1a       	mov	r10,1
8000a4d4:	50 da       	stdsp	sp[0x34],r10
8000a4d6:	c2 28       	rjmp	8000a51a <_dtoa_r+0x2de>
8000a4d8:	30 19       	mov	r9,1
8000a4da:	50 d9       	stdsp	sp[0x34],r9
8000a4dc:	c0 f8       	rjmp	8000a4fa <_dtoa_r+0x2be>
8000a4de:	30 08       	mov	r8,0
8000a4e0:	30 14       	mov	r4,1
8000a4e2:	50 c8       	stdsp	sp[0x30],r8
8000a4e4:	3f f5       	mov	r5,-1
8000a4e6:	30 1c       	mov	r12,1
8000a4e8:	30 0b       	mov	r11,0
8000a4ea:	50 95       	stdsp	sp[0x24],r5
8000a4ec:	50 dc       	stdsp	sp[0x34],r12
8000a4ee:	0a 91       	mov	r1,r5
8000a4f0:	31 28       	mov	r8,18
8000a4f2:	50 eb       	stdsp	sp[0x38],r11
8000a4f4:	c2 08       	rjmp	8000a534 <_dtoa_r+0x2f8>
8000a4f6:	30 0a       	mov	r10,0
8000a4f8:	50 da       	stdsp	sp[0x34],r10
8000a4fa:	40 e9       	lddsp	r9,sp[0x38]
8000a4fc:	58 09       	cp.w	r9,0
8000a4fe:	e0 89 00 07 	brgt	8000a50c <_dtoa_r+0x2d0>
8000a502:	30 18       	mov	r8,1
8000a504:	50 98       	stdsp	sp[0x24],r8
8000a506:	10 91       	mov	r1,r8
8000a508:	50 e8       	stdsp	sp[0x38],r8
8000a50a:	c1 58       	rjmp	8000a534 <_dtoa_r+0x2f8>
8000a50c:	40 e5       	lddsp	r5,sp[0x38]
8000a50e:	50 95       	stdsp	sp[0x24],r5
8000a510:	0a 91       	mov	r1,r5
8000a512:	0a 98       	mov	r8,r5
8000a514:	c1 08       	rjmp	8000a534 <_dtoa_r+0x2f8>
8000a516:	30 0c       	mov	r12,0
8000a518:	50 dc       	stdsp	sp[0x34],r12
8000a51a:	40 eb       	lddsp	r11,sp[0x38]
8000a51c:	ec 0b 00 0b 	add	r11,r6,r11
8000a520:	50 9b       	stdsp	sp[0x24],r11
8000a522:	16 98       	mov	r8,r11
8000a524:	2f f8       	sub	r8,-1
8000a526:	58 08       	cp.w	r8,0
8000a528:	e0 89 00 05 	brgt	8000a532 <_dtoa_r+0x2f6>
8000a52c:	10 91       	mov	r1,r8
8000a52e:	30 18       	mov	r8,1
8000a530:	c0 28       	rjmp	8000a534 <_dtoa_r+0x2f8>
8000a532:	10 91       	mov	r1,r8
8000a534:	30 09       	mov	r9,0
8000a536:	6e 9a       	ld.w	r10,r7[0x24]
8000a538:	95 19       	st.w	r10[0x4],r9
8000a53a:	30 49       	mov	r9,4
8000a53c:	c0 68       	rjmp	8000a548 <_dtoa_r+0x30c>
8000a53e:	d7 03       	nop
8000a540:	6a 1a       	ld.w	r10,r5[0x4]
8000a542:	a1 79       	lsl	r9,0x1
8000a544:	2f fa       	sub	r10,-1
8000a546:	8b 1a       	st.w	r5[0x4],r10
8000a548:	6e 95       	ld.w	r5,r7[0x24]
8000a54a:	f2 ca ff ec 	sub	r10,r9,-20
8000a54e:	10 3a       	cp.w	r10,r8
8000a550:	fe 98 ff f8 	brls	8000a540 <_dtoa_r+0x304>
8000a554:	6a 1b       	ld.w	r11,r5[0x4]
8000a556:	0e 9c       	mov	r12,r7
8000a558:	e0 a0 09 44 	rcall	8000b7e0 <_Balloc>
8000a55c:	58 e1       	cp.w	r1,14
8000a55e:	5f 88       	srls	r8
8000a560:	8b 0c       	st.w	r5[0x0],r12
8000a562:	f1 e4 00 04 	and	r4,r8,r4
8000a566:	6e 98       	ld.w	r8,r7[0x24]
8000a568:	70 08       	ld.w	r8,r8[0x0]
8000a56a:	50 88       	stdsp	sp[0x20],r8
8000a56c:	e0 80 01 82 	breq	8000a870 <_dtoa_r+0x634>
8000a570:	58 06       	cp.w	r6,0
8000a572:	e0 8a 00 43 	brle	8000a5f8 <_dtoa_r+0x3bc>
8000a576:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a57a:	fe c8 c3 ba 	sub	r8,pc,-15430
8000a57e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a582:	fa e5 00 18 	st.d	sp[24],r4
8000a586:	ec 04 14 04 	asr	r4,r6,0x4
8000a58a:	ed b4 00 04 	bld	r4,0x4
8000a58e:	c0 30       	breq	8000a594 <_dtoa_r+0x358>
8000a590:	30 25       	mov	r5,2
8000a592:	c1 08       	rjmp	8000a5b2 <_dtoa_r+0x376>
8000a594:	fe c8 c3 0c 	sub	r8,pc,-15604
8000a598:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a59c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5a0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a5a4:	e0 a0 0f fa 	rcall	8000c598 <__avr32_f64_div>
8000a5a8:	30 35       	mov	r5,3
8000a5aa:	14 98       	mov	r8,r10
8000a5ac:	16 99       	mov	r9,r11
8000a5ae:	fa e9 00 08 	st.d	sp[8],r8
8000a5b2:	fe cc c3 2a 	sub	r12,pc,-15574
8000a5b6:	50 a3       	stdsp	sp[0x28],r3
8000a5b8:	0c 93       	mov	r3,r6
8000a5ba:	18 96       	mov	r6,r12
8000a5bc:	c0 f8       	rjmp	8000a5da <_dtoa_r+0x39e>
8000a5be:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5c2:	ed b4 00 00 	bld	r4,0x0
8000a5c6:	c0 81       	brne	8000a5d6 <_dtoa_r+0x39a>
8000a5c8:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5cc:	2f f5       	sub	r5,-1
8000a5ce:	e0 a0 0c 9f 	rcall	8000bf0c <__avr32_f64_mul>
8000a5d2:	fa eb 00 18 	st.d	sp[24],r10
8000a5d6:	a1 54       	asr	r4,0x1
8000a5d8:	2f 86       	sub	r6,-8
8000a5da:	58 04       	cp.w	r4,0
8000a5dc:	cf 11       	brne	8000a5be <_dtoa_r+0x382>
8000a5de:	fa e8 00 18 	ld.d	r8,sp[24]
8000a5e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5e6:	06 96       	mov	r6,r3
8000a5e8:	e0 a0 0f d8 	rcall	8000c598 <__avr32_f64_div>
8000a5ec:	40 a3       	lddsp	r3,sp[0x28]
8000a5ee:	14 98       	mov	r8,r10
8000a5f0:	16 99       	mov	r9,r11
8000a5f2:	fa e9 00 08 	st.d	sp[8],r8
8000a5f6:	c2 f8       	rjmp	8000a654 <_dtoa_r+0x418>
8000a5f8:	ec 08 11 00 	rsub	r8,r6,0
8000a5fc:	c0 31       	brne	8000a602 <_dtoa_r+0x3c6>
8000a5fe:	30 25       	mov	r5,2
8000a600:	c2 a8       	rjmp	8000a654 <_dtoa_r+0x418>
8000a602:	fe cc c3 7a 	sub	r12,pc,-15494
8000a606:	f0 04 14 04 	asr	r4,r8,0x4
8000a60a:	50 1c       	stdsp	sp[0x4],r12
8000a60c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a610:	fe c9 c4 50 	sub	r9,pc,-15280
8000a614:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a618:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a61c:	e0 a0 0c 78 	rcall	8000bf0c <__avr32_f64_mul>
8000a620:	40 1c       	lddsp	r12,sp[0x4]
8000a622:	50 63       	stdsp	sp[0x18],r3
8000a624:	30 25       	mov	r5,2
8000a626:	0c 93       	mov	r3,r6
8000a628:	fa eb 00 08 	st.d	sp[8],r10
8000a62c:	18 96       	mov	r6,r12
8000a62e:	c0 f8       	rjmp	8000a64c <_dtoa_r+0x410>
8000a630:	fa ea 00 08 	ld.d	r10,sp[8]
8000a634:	ed b4 00 00 	bld	r4,0x0
8000a638:	c0 81       	brne	8000a648 <_dtoa_r+0x40c>
8000a63a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a63e:	2f f5       	sub	r5,-1
8000a640:	e0 a0 0c 66 	rcall	8000bf0c <__avr32_f64_mul>
8000a644:	fa eb 00 08 	st.d	sp[8],r10
8000a648:	a1 54       	asr	r4,0x1
8000a64a:	2f 86       	sub	r6,-8
8000a64c:	58 04       	cp.w	r4,0
8000a64e:	cf 11       	brne	8000a630 <_dtoa_r+0x3f4>
8000a650:	06 96       	mov	r6,r3
8000a652:	40 63       	lddsp	r3,sp[0x18]
8000a654:	41 4a       	lddsp	r10,sp[0x50]
8000a656:	58 0a       	cp.w	r10,0
8000a658:	c2 a0       	breq	8000a6ac <_dtoa_r+0x470>
8000a65a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a65e:	58 01       	cp.w	r1,0
8000a660:	5f 94       	srgt	r4
8000a662:	fa e9 00 18 	st.d	sp[24],r8
8000a666:	30 08       	mov	r8,0
8000a668:	fc 19 3f f0 	movh	r9,0x3ff0
8000a66c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a670:	e0 a0 0f 60 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a674:	f9 bc 00 00 	moveq	r12,0
8000a678:	f9 bc 01 01 	movne	r12,1
8000a67c:	e9 ec 00 0c 	and	r12,r4,r12
8000a680:	c1 60       	breq	8000a6ac <_dtoa_r+0x470>
8000a682:	40 98       	lddsp	r8,sp[0x24]
8000a684:	58 08       	cp.w	r8,0
8000a686:	e0 8a 00 f1 	brle	8000a868 <_dtoa_r+0x62c>
8000a68a:	30 08       	mov	r8,0
8000a68c:	fc 19 40 24 	movh	r9,0x4024
8000a690:	ec c4 00 01 	sub	r4,r6,1
8000a694:	fa ea 00 18 	ld.d	r10,sp[24]
8000a698:	2f f5       	sub	r5,-1
8000a69a:	50 64       	stdsp	sp[0x18],r4
8000a69c:	e0 a0 0c 38 	rcall	8000bf0c <__avr32_f64_mul>
8000a6a0:	40 94       	lddsp	r4,sp[0x24]
8000a6a2:	14 98       	mov	r8,r10
8000a6a4:	16 99       	mov	r9,r11
8000a6a6:	fa e9 00 08 	st.d	sp[8],r8
8000a6aa:	c0 38       	rjmp	8000a6b0 <_dtoa_r+0x474>
8000a6ac:	50 66       	stdsp	sp[0x18],r6
8000a6ae:	02 94       	mov	r4,r1
8000a6b0:	0a 9c       	mov	r12,r5
8000a6b2:	e0 a0 0e 88 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a6b6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6ba:	e0 a0 0c 29 	rcall	8000bf0c <__avr32_f64_mul>
8000a6be:	30 08       	mov	r8,0
8000a6c0:	fc 19 40 1c 	movh	r9,0x401c
8000a6c4:	e0 a0 0d de 	rcall	8000c280 <__avr32_f64_add>
8000a6c8:	14 98       	mov	r8,r10
8000a6ca:	16 99       	mov	r9,r11
8000a6cc:	fa e9 00 28 	st.d	sp[40],r8
8000a6d0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a6d4:	40 a5       	lddsp	r5,sp[0x28]
8000a6d6:	10 05       	add	r5,r8
8000a6d8:	50 a5       	stdsp	sp[0x28],r5
8000a6da:	58 04       	cp.w	r4,0
8000a6dc:	c2 11       	brne	8000a71e <_dtoa_r+0x4e2>
8000a6de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6e2:	30 08       	mov	r8,0
8000a6e4:	fc 19 40 14 	movh	r9,0x4014
8000a6e8:	e0 a0 0c fe 	rcall	8000c0e4 <__avr32_f64_sub>
8000a6ec:	40 bc       	lddsp	r12,sp[0x2c]
8000a6ee:	fa eb 00 08 	st.d	sp[8],r10
8000a6f2:	14 98       	mov	r8,r10
8000a6f4:	16 99       	mov	r9,r11
8000a6f6:	18 9a       	mov	r10,r12
8000a6f8:	0a 9b       	mov	r11,r5
8000a6fa:	e0 a0 0f 1b 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a6fe:	e0 81 02 54 	brne	8000aba6 <_dtoa_r+0x96a>
8000a702:	0a 98       	mov	r8,r5
8000a704:	40 b9       	lddsp	r9,sp[0x2c]
8000a706:	ee 18 80 00 	eorh	r8,0x8000
8000a70a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a70e:	10 95       	mov	r5,r8
8000a710:	12 98       	mov	r8,r9
8000a712:	0a 99       	mov	r9,r5
8000a714:	e0 a0 0f 0e 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a718:	e0 81 02 3e 	brne	8000ab94 <_dtoa_r+0x958>
8000a71c:	ca 68       	rjmp	8000a868 <_dtoa_r+0x62c>
8000a71e:	fe c9 c5 5e 	sub	r9,pc,-15010
8000a722:	e8 c8 00 01 	sub	r8,r4,1
8000a726:	40 d5       	lddsp	r5,sp[0x34]
8000a728:	58 05       	cp.w	r5,0
8000a72a:	c4 f0       	breq	8000a7c8 <_dtoa_r+0x58c>
8000a72c:	30 0c       	mov	r12,0
8000a72e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a732:	51 3c       	stdsp	sp[0x4c],r12
8000a734:	30 0a       	mov	r10,0
8000a736:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a73a:	e0 a0 0f 2f 	rcall	8000c598 <__avr32_f64_div>
8000a73e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a742:	40 85       	lddsp	r5,sp[0x20]
8000a744:	e0 a0 0c d0 	rcall	8000c0e4 <__avr32_f64_sub>
8000a748:	fa eb 00 28 	st.d	sp[40],r10
8000a74c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a750:	e0 a0 0e 22 	rcall	8000c394 <__avr32_f64_to_s32>
8000a754:	51 6c       	stdsp	sp[0x58],r12
8000a756:	e0 a0 0e 36 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a75a:	14 98       	mov	r8,r10
8000a75c:	16 99       	mov	r9,r11
8000a75e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a762:	e0 a0 0c c1 	rcall	8000c0e4 <__avr32_f64_sub>
8000a766:	fa eb 00 08 	st.d	sp[8],r10
8000a76a:	41 68       	lddsp	r8,sp[0x58]
8000a76c:	2d 08       	sub	r8,-48
8000a76e:	0a c8       	st.b	r5++,r8
8000a770:	41 39       	lddsp	r9,sp[0x4c]
8000a772:	2f f9       	sub	r9,-1
8000a774:	51 39       	stdsp	sp[0x4c],r9
8000a776:	fa e8 00 28 	ld.d	r8,sp[40]
8000a77a:	e0 a0 0e db 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a77e:	e0 81 03 39 	brne	8000adf0 <_dtoa_r+0xbb4>
8000a782:	fa e8 00 08 	ld.d	r8,sp[8]
8000a786:	30 0a       	mov	r10,0
8000a788:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a78c:	e0 a0 0c ac 	rcall	8000c0e4 <__avr32_f64_sub>
8000a790:	fa e8 00 28 	ld.d	r8,sp[40]
8000a794:	e0 a0 0e ce 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a798:	fa ea 00 28 	ld.d	r10,sp[40]
8000a79c:	30 08       	mov	r8,0
8000a79e:	fc 19 40 24 	movh	r9,0x4024
8000a7a2:	e0 81 00 da 	brne	8000a956 <_dtoa_r+0x71a>
8000a7a6:	41 3c       	lddsp	r12,sp[0x4c]
8000a7a8:	08 3c       	cp.w	r12,r4
8000a7aa:	c5 f4       	brge	8000a868 <_dtoa_r+0x62c>
8000a7ac:	e0 a0 0b b0 	rcall	8000bf0c <__avr32_f64_mul>
8000a7b0:	30 08       	mov	r8,0
8000a7b2:	fa eb 00 28 	st.d	sp[40],r10
8000a7b6:	fc 19 40 24 	movh	r9,0x4024
8000a7ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7be:	e0 a0 0b a7 	rcall	8000bf0c <__avr32_f64_mul>
8000a7c2:	fa eb 00 08 	st.d	sp[8],r10
8000a7c6:	cc 3b       	rjmp	8000a74c <_dtoa_r+0x510>
8000a7c8:	40 85       	lddsp	r5,sp[0x20]
8000a7ca:	08 05       	add	r5,r4
8000a7cc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a7d0:	51 35       	stdsp	sp[0x4c],r5
8000a7d2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7d6:	40 85       	lddsp	r5,sp[0x20]
8000a7d8:	e0 a0 0b 9a 	rcall	8000bf0c <__avr32_f64_mul>
8000a7dc:	fa eb 00 28 	st.d	sp[40],r10
8000a7e0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7e4:	e0 a0 0d d8 	rcall	8000c394 <__avr32_f64_to_s32>
8000a7e8:	51 6c       	stdsp	sp[0x58],r12
8000a7ea:	e0 a0 0d ec 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a7ee:	14 98       	mov	r8,r10
8000a7f0:	16 99       	mov	r9,r11
8000a7f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7f6:	e0 a0 0c 77 	rcall	8000c0e4 <__avr32_f64_sub>
8000a7fa:	fa eb 00 08 	st.d	sp[8],r10
8000a7fe:	41 68       	lddsp	r8,sp[0x58]
8000a800:	2d 08       	sub	r8,-48
8000a802:	0a c8       	st.b	r5++,r8
8000a804:	41 3c       	lddsp	r12,sp[0x4c]
8000a806:	18 35       	cp.w	r5,r12
8000a808:	c2 81       	brne	8000a858 <_dtoa_r+0x61c>
8000a80a:	30 08       	mov	r8,0
8000a80c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a810:	fa ea 00 28 	ld.d	r10,sp[40]
8000a814:	e0 a0 0d 36 	rcall	8000c280 <__avr32_f64_add>
8000a818:	40 85       	lddsp	r5,sp[0x20]
8000a81a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a81e:	08 05       	add	r5,r4
8000a820:	e0 a0 0e 88 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a824:	e0 81 00 99 	brne	8000a956 <_dtoa_r+0x71a>
8000a828:	fa e8 00 28 	ld.d	r8,sp[40]
8000a82c:	30 0a       	mov	r10,0
8000a82e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a832:	e0 a0 0c 59 	rcall	8000c0e4 <__avr32_f64_sub>
8000a836:	14 98       	mov	r8,r10
8000a838:	16 99       	mov	r9,r11
8000a83a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a83e:	e0 a0 0e 79 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a842:	c1 30       	breq	8000a868 <_dtoa_r+0x62c>
8000a844:	33 09       	mov	r9,48
8000a846:	0a 98       	mov	r8,r5
8000a848:	11 7a       	ld.ub	r10,--r8
8000a84a:	f2 0a 18 00 	cp.b	r10,r9
8000a84e:	e0 81 02 d1 	brne	8000adf0 <_dtoa_r+0xbb4>
8000a852:	10 95       	mov	r5,r8
8000a854:	cf 9b       	rjmp	8000a846 <_dtoa_r+0x60a>
8000a856:	d7 03       	nop
8000a858:	30 08       	mov	r8,0
8000a85a:	fc 19 40 24 	movh	r9,0x4024
8000a85e:	e0 a0 0b 57 	rcall	8000bf0c <__avr32_f64_mul>
8000a862:	fa eb 00 08 	st.d	sp[8],r10
8000a866:	cb db       	rjmp	8000a7e0 <_dtoa_r+0x5a4>
8000a868:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a86c:	fa eb 00 08 	st.d	sp[8],r10
8000a870:	58 e6       	cp.w	r6,14
8000a872:	5f ab       	srle	r11
8000a874:	41 8a       	lddsp	r10,sp[0x60]
8000a876:	30 08       	mov	r8,0
8000a878:	f4 09 11 ff 	rsub	r9,r10,-1
8000a87c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a880:	f0 09 18 00 	cp.b	r9,r8
8000a884:	e0 80 00 82 	breq	8000a988 <_dtoa_r+0x74c>
8000a888:	40 ea       	lddsp	r10,sp[0x38]
8000a88a:	58 01       	cp.w	r1,0
8000a88c:	5f a9       	srle	r9
8000a88e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a892:	fe ca c6 d2 	sub	r10,pc,-14638
8000a896:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a89a:	fa e5 00 10 	st.d	sp[16],r4
8000a89e:	f0 09 18 00 	cp.b	r9,r8
8000a8a2:	c1 40       	breq	8000a8ca <_dtoa_r+0x68e>
8000a8a4:	58 01       	cp.w	r1,0
8000a8a6:	e0 81 01 77 	brne	8000ab94 <_dtoa_r+0x958>
8000a8aa:	30 08       	mov	r8,0
8000a8ac:	fc 19 40 14 	movh	r9,0x4014
8000a8b0:	08 9a       	mov	r10,r4
8000a8b2:	0a 9b       	mov	r11,r5
8000a8b4:	e0 a0 0b 2c 	rcall	8000bf0c <__avr32_f64_mul>
8000a8b8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8bc:	e0 a0 0e 06 	rcall	8000c4c8 <__avr32_f64_cmp_ge>
8000a8c0:	e0 81 01 6a 	brne	8000ab94 <_dtoa_r+0x958>
8000a8c4:	02 92       	mov	r2,r1
8000a8c6:	e0 8f 01 72 	bral	8000abaa <_dtoa_r+0x96e>
8000a8ca:	40 85       	lddsp	r5,sp[0x20]
8000a8cc:	30 14       	mov	r4,1
8000a8ce:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8d6:	e0 a0 0e 61 	rcall	8000c598 <__avr32_f64_div>
8000a8da:	e0 a0 0d 5d 	rcall	8000c394 <__avr32_f64_to_s32>
8000a8de:	18 92       	mov	r2,r12
8000a8e0:	e0 a0 0d 71 	rcall	8000c3c2 <__avr32_s32_to_f64>
8000a8e4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8e8:	e0 a0 0b 12 	rcall	8000bf0c <__avr32_f64_mul>
8000a8ec:	14 98       	mov	r8,r10
8000a8ee:	16 99       	mov	r9,r11
8000a8f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8f4:	e0 a0 0b f8 	rcall	8000c0e4 <__avr32_f64_sub>
8000a8f8:	fa eb 00 08 	st.d	sp[8],r10
8000a8fc:	e4 c8 ff d0 	sub	r8,r2,-48
8000a900:	0a c8       	st.b	r5++,r8
8000a902:	fc 19 40 24 	movh	r9,0x4024
8000a906:	30 08       	mov	r8,0
8000a908:	02 34       	cp.w	r4,r1
8000a90a:	c3 31       	brne	8000a970 <_dtoa_r+0x734>
8000a90c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a910:	e0 a0 0c b8 	rcall	8000c280 <__avr32_f64_add>
8000a914:	16 91       	mov	r1,r11
8000a916:	14 90       	mov	r0,r10
8000a918:	14 98       	mov	r8,r10
8000a91a:	02 99       	mov	r9,r1
8000a91c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a920:	e0 a0 0e 08 	rcall	8000c530 <__avr32_f64_cmp_lt>
8000a924:	c1 a1       	brne	8000a958 <_dtoa_r+0x71c>
8000a926:	fa e8 00 10 	ld.d	r8,sp[16]
8000a92a:	00 9a       	mov	r10,r0
8000a92c:	02 9b       	mov	r11,r1
8000a92e:	e0 a0 0d ba 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
8000a932:	e0 80 02 5e 	breq	8000adee <_dtoa_r+0xbb2>
8000a936:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a93a:	c0 f1       	brne	8000a958 <_dtoa_r+0x71c>
8000a93c:	e0 8f 02 59 	bral	8000adee <_dtoa_r+0xbb2>
8000a940:	40 8a       	lddsp	r10,sp[0x20]
8000a942:	14 38       	cp.w	r8,r10
8000a944:	c0 30       	breq	8000a94a <_dtoa_r+0x70e>
8000a946:	10 95       	mov	r5,r8
8000a948:	c0 98       	rjmp	8000a95a <_dtoa_r+0x71e>
8000a94a:	33 08       	mov	r8,48
8000a94c:	40 89       	lddsp	r9,sp[0x20]
8000a94e:	2f f6       	sub	r6,-1
8000a950:	b2 88       	st.b	r9[0x0],r8
8000a952:	40 88       	lddsp	r8,sp[0x20]
8000a954:	c0 88       	rjmp	8000a964 <_dtoa_r+0x728>
8000a956:	40 66       	lddsp	r6,sp[0x18]
8000a958:	33 99       	mov	r9,57
8000a95a:	0a 98       	mov	r8,r5
8000a95c:	11 7a       	ld.ub	r10,--r8
8000a95e:	f2 0a 18 00 	cp.b	r10,r9
8000a962:	ce f0       	breq	8000a940 <_dtoa_r+0x704>
8000a964:	50 66       	stdsp	sp[0x18],r6
8000a966:	11 89       	ld.ub	r9,r8[0x0]
8000a968:	2f f9       	sub	r9,-1
8000a96a:	b0 89       	st.b	r8[0x0],r9
8000a96c:	e0 8f 02 42 	bral	8000adf0 <_dtoa_r+0xbb4>
8000a970:	e0 a0 0a ce 	rcall	8000bf0c <__avr32_f64_mul>
8000a974:	2f f4       	sub	r4,-1
8000a976:	fa eb 00 08 	st.d	sp[8],r10
8000a97a:	30 08       	mov	r8,0
8000a97c:	30 09       	mov	r9,0
8000a97e:	e0 a0 0d 92 	rcall	8000c4a2 <__avr32_f64_cmp_eq>
8000a982:	ca 60       	breq	8000a8ce <_dtoa_r+0x692>
8000a984:	e0 8f 02 35 	bral	8000adee <_dtoa_r+0xbb2>
8000a988:	40 d8       	lddsp	r8,sp[0x34]
8000a98a:	58 08       	cp.w	r8,0
8000a98c:	c0 51       	brne	8000a996 <_dtoa_r+0x75a>
8000a98e:	04 98       	mov	r8,r2
8000a990:	00 95       	mov	r5,r0
8000a992:	40 d4       	lddsp	r4,sp[0x34]
8000a994:	c3 78       	rjmp	8000aa02 <_dtoa_r+0x7c6>
8000a996:	40 c5       	lddsp	r5,sp[0x30]
8000a998:	58 15       	cp.w	r5,1
8000a99a:	e0 89 00 0f 	brgt	8000a9b8 <_dtoa_r+0x77c>
8000a99e:	41 74       	lddsp	r4,sp[0x5c]
8000a9a0:	58 04       	cp.w	r4,0
8000a9a2:	c0 40       	breq	8000a9aa <_dtoa_r+0x76e>
8000a9a4:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a9a8:	c0 48       	rjmp	8000a9b0 <_dtoa_r+0x774>
8000a9aa:	41 99       	lddsp	r9,sp[0x64]
8000a9ac:	f2 09 11 36 	rsub	r9,r9,54
8000a9b0:	04 98       	mov	r8,r2
8000a9b2:	00 95       	mov	r5,r0
8000a9b4:	c1 c8       	rjmp	8000a9ec <_dtoa_r+0x7b0>
8000a9b6:	d7 03       	nop
8000a9b8:	e2 c8 00 01 	sub	r8,r1,1
8000a9bc:	58 01       	cp.w	r1,0
8000a9be:	e0 05 17 40 	movge	r5,r0
8000a9c2:	e2 09 17 40 	movge	r9,r1
8000a9c6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a9ca:	f9 b9 05 00 	movlt	r9,0
8000a9ce:	10 32       	cp.w	r2,r8
8000a9d0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a9d4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a9d8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a9dc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a9e0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a9e4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a9e8:	f9 b8 05 00 	movlt	r8,0
8000a9ec:	40 4b       	lddsp	r11,sp[0x10]
8000a9ee:	12 0b       	add	r11,r9
8000a9f0:	50 08       	stdsp	sp[0x0],r8
8000a9f2:	50 4b       	stdsp	sp[0x10],r11
8000a9f4:	12 00       	add	r0,r9
8000a9f6:	30 1b       	mov	r11,1
8000a9f8:	0e 9c       	mov	r12,r7
8000a9fa:	e0 a0 08 a7 	rcall	8000bb48 <__i2b>
8000a9fe:	40 08       	lddsp	r8,sp[0x0]
8000aa00:	18 94       	mov	r4,r12
8000aa02:	40 4a       	lddsp	r10,sp[0x10]
8000aa04:	58 05       	cp.w	r5,0
8000aa06:	5f 99       	srgt	r9
8000aa08:	58 0a       	cp.w	r10,0
8000aa0a:	5f 9a       	srgt	r10
8000aa0c:	f5 e9 00 09 	and	r9,r10,r9
8000aa10:	c0 80       	breq	8000aa20 <_dtoa_r+0x7e4>
8000aa12:	40 4c       	lddsp	r12,sp[0x10]
8000aa14:	f8 05 0d 49 	min	r9,r12,r5
8000aa18:	12 1c       	sub	r12,r9
8000aa1a:	12 10       	sub	r0,r9
8000aa1c:	50 4c       	stdsp	sp[0x10],r12
8000aa1e:	12 15       	sub	r5,r9
8000aa20:	58 02       	cp.w	r2,0
8000aa22:	e0 8a 00 27 	brle	8000aa70 <_dtoa_r+0x834>
8000aa26:	40 db       	lddsp	r11,sp[0x34]
8000aa28:	58 0b       	cp.w	r11,0
8000aa2a:	c1 d0       	breq	8000aa64 <_dtoa_r+0x828>
8000aa2c:	58 08       	cp.w	r8,0
8000aa2e:	e0 8a 00 17 	brle	8000aa5c <_dtoa_r+0x820>
8000aa32:	10 9a       	mov	r10,r8
8000aa34:	50 08       	stdsp	sp[0x0],r8
8000aa36:	08 9b       	mov	r11,r4
8000aa38:	0e 9c       	mov	r12,r7
8000aa3a:	e0 a0 08 cd 	rcall	8000bbd4 <__pow5mult>
8000aa3e:	06 9a       	mov	r10,r3
8000aa40:	18 9b       	mov	r11,r12
8000aa42:	18 94       	mov	r4,r12
8000aa44:	0e 9c       	mov	r12,r7
8000aa46:	e0 a0 08 01 	rcall	8000ba48 <__multiply>
8000aa4a:	18 99       	mov	r9,r12
8000aa4c:	06 9b       	mov	r11,r3
8000aa4e:	50 19       	stdsp	sp[0x4],r9
8000aa50:	0e 9c       	mov	r12,r7
8000aa52:	e0 a0 06 ad 	rcall	8000b7ac <_Bfree>
8000aa56:	40 19       	lddsp	r9,sp[0x4]
8000aa58:	40 08       	lddsp	r8,sp[0x0]
8000aa5a:	12 93       	mov	r3,r9
8000aa5c:	e4 08 01 0a 	sub	r10,r2,r8
8000aa60:	c0 80       	breq	8000aa70 <_dtoa_r+0x834>
8000aa62:	c0 28       	rjmp	8000aa66 <_dtoa_r+0x82a>
8000aa64:	04 9a       	mov	r10,r2
8000aa66:	06 9b       	mov	r11,r3
8000aa68:	0e 9c       	mov	r12,r7
8000aa6a:	e0 a0 08 b5 	rcall	8000bbd4 <__pow5mult>
8000aa6e:	18 93       	mov	r3,r12
8000aa70:	30 1b       	mov	r11,1
8000aa72:	0e 9c       	mov	r12,r7
8000aa74:	e0 a0 08 6a 	rcall	8000bb48 <__i2b>
8000aa78:	41 1a       	lddsp	r10,sp[0x44]
8000aa7a:	18 92       	mov	r2,r12
8000aa7c:	58 0a       	cp.w	r10,0
8000aa7e:	e0 8a 00 07 	brle	8000aa8c <_dtoa_r+0x850>
8000aa82:	18 9b       	mov	r11,r12
8000aa84:	0e 9c       	mov	r12,r7
8000aa86:	e0 a0 08 a7 	rcall	8000bbd4 <__pow5mult>
8000aa8a:	18 92       	mov	r2,r12
8000aa8c:	40 c9       	lddsp	r9,sp[0x30]
8000aa8e:	58 19       	cp.w	r9,1
8000aa90:	e0 89 00 14 	brgt	8000aab8 <_dtoa_r+0x87c>
8000aa94:	40 38       	lddsp	r8,sp[0xc]
8000aa96:	58 08       	cp.w	r8,0
8000aa98:	c1 01       	brne	8000aab8 <_dtoa_r+0x87c>
8000aa9a:	40 29       	lddsp	r9,sp[0x8]
8000aa9c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aaa0:	c0 c1       	brne	8000aab8 <_dtoa_r+0x87c>
8000aaa2:	12 98       	mov	r8,r9
8000aaa4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aaa8:	c0 80       	breq	8000aab8 <_dtoa_r+0x87c>
8000aaaa:	40 4c       	lddsp	r12,sp[0x10]
8000aaac:	30 1b       	mov	r11,1
8000aaae:	2f fc       	sub	r12,-1
8000aab0:	2f f0       	sub	r0,-1
8000aab2:	50 4c       	stdsp	sp[0x10],r12
8000aab4:	50 6b       	stdsp	sp[0x18],r11
8000aab6:	c0 38       	rjmp	8000aabc <_dtoa_r+0x880>
8000aab8:	30 0a       	mov	r10,0
8000aaba:	50 6a       	stdsp	sp[0x18],r10
8000aabc:	41 19       	lddsp	r9,sp[0x44]
8000aabe:	58 09       	cp.w	r9,0
8000aac0:	c0 31       	brne	8000aac6 <_dtoa_r+0x88a>
8000aac2:	30 1c       	mov	r12,1
8000aac4:	c0 98       	rjmp	8000aad6 <_dtoa_r+0x89a>
8000aac6:	64 48       	ld.w	r8,r2[0x10]
8000aac8:	2f c8       	sub	r8,-4
8000aaca:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aace:	e0 a0 05 df 	rcall	8000b68c <__hi0bits>
8000aad2:	f8 0c 11 20 	rsub	r12,r12,32
8000aad6:	40 4b       	lddsp	r11,sp[0x10]
8000aad8:	f8 0b 00 08 	add	r8,r12,r11
8000aadc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aae0:	c0 c0       	breq	8000aaf8 <_dtoa_r+0x8bc>
8000aae2:	f0 08 11 20 	rsub	r8,r8,32
8000aae6:	58 48       	cp.w	r8,4
8000aae8:	e0 8a 00 06 	brle	8000aaf4 <_dtoa_r+0x8b8>
8000aaec:	20 48       	sub	r8,4
8000aaee:	10 0b       	add	r11,r8
8000aaf0:	50 4b       	stdsp	sp[0x10],r11
8000aaf2:	c0 78       	rjmp	8000ab00 <_dtoa_r+0x8c4>
8000aaf4:	58 48       	cp.w	r8,4
8000aaf6:	c0 70       	breq	8000ab04 <_dtoa_r+0x8c8>
8000aaf8:	40 4a       	lddsp	r10,sp[0x10]
8000aafa:	2e 48       	sub	r8,-28
8000aafc:	10 0a       	add	r10,r8
8000aafe:	50 4a       	stdsp	sp[0x10],r10
8000ab00:	10 00       	add	r0,r8
8000ab02:	10 05       	add	r5,r8
8000ab04:	58 00       	cp.w	r0,0
8000ab06:	e0 8a 00 08 	brle	8000ab16 <_dtoa_r+0x8da>
8000ab0a:	06 9b       	mov	r11,r3
8000ab0c:	00 9a       	mov	r10,r0
8000ab0e:	0e 9c       	mov	r12,r7
8000ab10:	e0 a0 07 58 	rcall	8000b9c0 <__lshift>
8000ab14:	18 93       	mov	r3,r12
8000ab16:	40 49       	lddsp	r9,sp[0x10]
8000ab18:	58 09       	cp.w	r9,0
8000ab1a:	e0 8a 00 08 	brle	8000ab2a <_dtoa_r+0x8ee>
8000ab1e:	04 9b       	mov	r11,r2
8000ab20:	12 9a       	mov	r10,r9
8000ab22:	0e 9c       	mov	r12,r7
8000ab24:	e0 a0 07 4e 	rcall	8000b9c0 <__lshift>
8000ab28:	18 92       	mov	r2,r12
8000ab2a:	41 48       	lddsp	r8,sp[0x50]
8000ab2c:	58 08       	cp.w	r8,0
8000ab2e:	c1 b0       	breq	8000ab64 <_dtoa_r+0x928>
8000ab30:	04 9b       	mov	r11,r2
8000ab32:	06 9c       	mov	r12,r3
8000ab34:	e0 a0 06 23 	rcall	8000b77a <__mcmp>
8000ab38:	c1 64       	brge	8000ab64 <_dtoa_r+0x928>
8000ab3a:	06 9b       	mov	r11,r3
8000ab3c:	30 09       	mov	r9,0
8000ab3e:	30 aa       	mov	r10,10
8000ab40:	0e 9c       	mov	r12,r7
8000ab42:	e0 a0 08 0b 	rcall	8000bb58 <__multadd>
8000ab46:	20 16       	sub	r6,1
8000ab48:	18 93       	mov	r3,r12
8000ab4a:	40 dc       	lddsp	r12,sp[0x34]
8000ab4c:	58 0c       	cp.w	r12,0
8000ab4e:	c0 31       	brne	8000ab54 <_dtoa_r+0x918>
8000ab50:	40 91       	lddsp	r1,sp[0x24]
8000ab52:	c0 98       	rjmp	8000ab64 <_dtoa_r+0x928>
8000ab54:	08 9b       	mov	r11,r4
8000ab56:	40 91       	lddsp	r1,sp[0x24]
8000ab58:	30 09       	mov	r9,0
8000ab5a:	30 aa       	mov	r10,10
8000ab5c:	0e 9c       	mov	r12,r7
8000ab5e:	e0 a0 07 fd 	rcall	8000bb58 <__multadd>
8000ab62:	18 94       	mov	r4,r12
8000ab64:	58 01       	cp.w	r1,0
8000ab66:	5f a9       	srle	r9
8000ab68:	40 cb       	lddsp	r11,sp[0x30]
8000ab6a:	58 2b       	cp.w	r11,2
8000ab6c:	5f 98       	srgt	r8
8000ab6e:	f3 e8 00 08 	and	r8,r9,r8
8000ab72:	c2 50       	breq	8000abbc <_dtoa_r+0x980>
8000ab74:	58 01       	cp.w	r1,0
8000ab76:	c1 11       	brne	8000ab98 <_dtoa_r+0x95c>
8000ab78:	04 9b       	mov	r11,r2
8000ab7a:	02 99       	mov	r9,r1
8000ab7c:	30 5a       	mov	r10,5
8000ab7e:	0e 9c       	mov	r12,r7
8000ab80:	e0 a0 07 ec 	rcall	8000bb58 <__multadd>
8000ab84:	18 92       	mov	r2,r12
8000ab86:	18 9b       	mov	r11,r12
8000ab88:	06 9c       	mov	r12,r3
8000ab8a:	e0 a0 05 f8 	rcall	8000b77a <__mcmp>
8000ab8e:	e0 89 00 0f 	brgt	8000abac <_dtoa_r+0x970>
8000ab92:	c0 38       	rjmp	8000ab98 <_dtoa_r+0x95c>
8000ab94:	30 02       	mov	r2,0
8000ab96:	04 94       	mov	r4,r2
8000ab98:	40 ea       	lddsp	r10,sp[0x38]
8000ab9a:	30 09       	mov	r9,0
8000ab9c:	5c da       	com	r10
8000ab9e:	40 85       	lddsp	r5,sp[0x20]
8000aba0:	50 6a       	stdsp	sp[0x18],r10
8000aba2:	50 49       	stdsp	sp[0x10],r9
8000aba4:	c0 f9       	rjmp	8000adc2 <_dtoa_r+0xb86>
8000aba6:	08 92       	mov	r2,r4
8000aba8:	40 66       	lddsp	r6,sp[0x18]
8000abaa:	04 94       	mov	r4,r2
8000abac:	2f f6       	sub	r6,-1
8000abae:	50 66       	stdsp	sp[0x18],r6
8000abb0:	33 18       	mov	r8,49
8000abb2:	40 85       	lddsp	r5,sp[0x20]
8000abb4:	0a c8       	st.b	r5++,r8
8000abb6:	30 08       	mov	r8,0
8000abb8:	50 48       	stdsp	sp[0x10],r8
8000abba:	c0 49       	rjmp	8000adc2 <_dtoa_r+0xb86>
8000abbc:	40 dc       	lddsp	r12,sp[0x34]
8000abbe:	58 0c       	cp.w	r12,0
8000abc0:	e0 80 00 b5 	breq	8000ad2a <_dtoa_r+0xaee>
8000abc4:	58 05       	cp.w	r5,0
8000abc6:	e0 8a 00 08 	brle	8000abd6 <_dtoa_r+0x99a>
8000abca:	08 9b       	mov	r11,r4
8000abcc:	0a 9a       	mov	r10,r5
8000abce:	0e 9c       	mov	r12,r7
8000abd0:	e0 a0 06 f8 	rcall	8000b9c0 <__lshift>
8000abd4:	18 94       	mov	r4,r12
8000abd6:	40 6b       	lddsp	r11,sp[0x18]
8000abd8:	58 0b       	cp.w	r11,0
8000abda:	c0 31       	brne	8000abe0 <_dtoa_r+0x9a4>
8000abdc:	08 9c       	mov	r12,r4
8000abde:	c1 38       	rjmp	8000ac04 <_dtoa_r+0x9c8>
8000abe0:	68 1b       	ld.w	r11,r4[0x4]
8000abe2:	0e 9c       	mov	r12,r7
8000abe4:	e0 a0 05 fe 	rcall	8000b7e0 <_Balloc>
8000abe8:	68 4a       	ld.w	r10,r4[0x10]
8000abea:	18 95       	mov	r5,r12
8000abec:	e8 cb ff f4 	sub	r11,r4,-12
8000abf0:	2f ea       	sub	r10,-2
8000abf2:	2f 4c       	sub	r12,-12
8000abf4:	a3 6a       	lsl	r10,0x2
8000abf6:	fe b0 e6 4f 	rcall	80007894 <memcpy>
8000abfa:	0a 9b       	mov	r11,r5
8000abfc:	30 1a       	mov	r10,1
8000abfe:	0e 9c       	mov	r12,r7
8000ac00:	e0 a0 06 e0 	rcall	8000b9c0 <__lshift>
8000ac04:	50 44       	stdsp	sp[0x10],r4
8000ac06:	40 3a       	lddsp	r10,sp[0xc]
8000ac08:	30 19       	mov	r9,1
8000ac0a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ac0e:	18 94       	mov	r4,r12
8000ac10:	50 da       	stdsp	sp[0x34],r10
8000ac12:	40 85       	lddsp	r5,sp[0x20]
8000ac14:	50 99       	stdsp	sp[0x24],r9
8000ac16:	50 26       	stdsp	sp[0x8],r6
8000ac18:	50 e1       	stdsp	sp[0x38],r1
8000ac1a:	04 9b       	mov	r11,r2
8000ac1c:	06 9c       	mov	r12,r3
8000ac1e:	fe b0 fa 7f 	rcall	8000a11c <quorem>
8000ac22:	40 4b       	lddsp	r11,sp[0x10]
8000ac24:	f8 c0 ff d0 	sub	r0,r12,-48
8000ac28:	06 9c       	mov	r12,r3
8000ac2a:	e0 a0 05 a8 	rcall	8000b77a <__mcmp>
8000ac2e:	08 9a       	mov	r10,r4
8000ac30:	50 6c       	stdsp	sp[0x18],r12
8000ac32:	04 9b       	mov	r11,r2
8000ac34:	0e 9c       	mov	r12,r7
8000ac36:	e0 a0 06 5d 	rcall	8000b8f0 <__mdiff>
8000ac3a:	18 91       	mov	r1,r12
8000ac3c:	78 38       	ld.w	r8,r12[0xc]
8000ac3e:	58 08       	cp.w	r8,0
8000ac40:	c0 30       	breq	8000ac46 <_dtoa_r+0xa0a>
8000ac42:	30 16       	mov	r6,1
8000ac44:	c0 68       	rjmp	8000ac50 <_dtoa_r+0xa14>
8000ac46:	18 9b       	mov	r11,r12
8000ac48:	06 9c       	mov	r12,r3
8000ac4a:	e0 a0 05 98 	rcall	8000b77a <__mcmp>
8000ac4e:	18 96       	mov	r6,r12
8000ac50:	0e 9c       	mov	r12,r7
8000ac52:	02 9b       	mov	r11,r1
8000ac54:	e0 a0 05 ac 	rcall	8000b7ac <_Bfree>
8000ac58:	40 cc       	lddsp	r12,sp[0x30]
8000ac5a:	ed ec 10 08 	or	r8,r6,r12
8000ac5e:	c0 d1       	brne	8000ac78 <_dtoa_r+0xa3c>
8000ac60:	40 db       	lddsp	r11,sp[0x34]
8000ac62:	58 0b       	cp.w	r11,0
8000ac64:	c0 a1       	brne	8000ac78 <_dtoa_r+0xa3c>
8000ac66:	40 26       	lddsp	r6,sp[0x8]
8000ac68:	e0 40 00 39 	cp.w	r0,57
8000ac6c:	c3 00       	breq	8000accc <_dtoa_r+0xa90>
8000ac6e:	40 6a       	lddsp	r10,sp[0x18]
8000ac70:	58 0a       	cp.w	r10,0
8000ac72:	e0 89 00 24 	brgt	8000acba <_dtoa_r+0xa7e>
8000ac76:	c2 f8       	rjmp	8000acd4 <_dtoa_r+0xa98>
8000ac78:	40 69       	lddsp	r9,sp[0x18]
8000ac7a:	58 09       	cp.w	r9,0
8000ac7c:	c0 85       	brlt	8000ac8c <_dtoa_r+0xa50>
8000ac7e:	12 98       	mov	r8,r9
8000ac80:	40 cc       	lddsp	r12,sp[0x30]
8000ac82:	18 48       	or	r8,r12
8000ac84:	c1 d1       	brne	8000acbe <_dtoa_r+0xa82>
8000ac86:	40 db       	lddsp	r11,sp[0x34]
8000ac88:	58 0b       	cp.w	r11,0
8000ac8a:	c1 a1       	brne	8000acbe <_dtoa_r+0xa82>
8000ac8c:	0c 99       	mov	r9,r6
8000ac8e:	40 26       	lddsp	r6,sp[0x8]
8000ac90:	58 09       	cp.w	r9,0
8000ac92:	e0 8a 00 21 	brle	8000acd4 <_dtoa_r+0xa98>
8000ac96:	06 9b       	mov	r11,r3
8000ac98:	30 1a       	mov	r10,1
8000ac9a:	0e 9c       	mov	r12,r7
8000ac9c:	e0 a0 06 92 	rcall	8000b9c0 <__lshift>
8000aca0:	04 9b       	mov	r11,r2
8000aca2:	18 93       	mov	r3,r12
8000aca4:	e0 a0 05 6b 	rcall	8000b77a <__mcmp>
8000aca8:	e0 89 00 06 	brgt	8000acb4 <_dtoa_r+0xa78>
8000acac:	c1 41       	brne	8000acd4 <_dtoa_r+0xa98>
8000acae:	ed b0 00 00 	bld	r0,0x0
8000acb2:	c1 11       	brne	8000acd4 <_dtoa_r+0xa98>
8000acb4:	e0 40 00 39 	cp.w	r0,57
8000acb8:	c0 a0       	breq	8000accc <_dtoa_r+0xa90>
8000acba:	2f f0       	sub	r0,-1
8000acbc:	c0 c8       	rjmp	8000acd4 <_dtoa_r+0xa98>
8000acbe:	58 06       	cp.w	r6,0
8000acc0:	e0 8a 00 0c 	brle	8000acd8 <_dtoa_r+0xa9c>
8000acc4:	40 26       	lddsp	r6,sp[0x8]
8000acc6:	e0 40 00 39 	cp.w	r0,57
8000acca:	c0 41       	brne	8000acd2 <_dtoa_r+0xa96>
8000accc:	33 98       	mov	r8,57
8000acce:	0a c8       	st.b	r5++,r8
8000acd0:	c6 78       	rjmp	8000ad9e <_dtoa_r+0xb62>
8000acd2:	2f f0       	sub	r0,-1
8000acd4:	0a c0       	st.b	r5++,r0
8000acd6:	c7 58       	rjmp	8000adc0 <_dtoa_r+0xb84>
8000acd8:	0a c0       	st.b	r5++,r0
8000acda:	40 9a       	lddsp	r10,sp[0x24]
8000acdc:	40 e9       	lddsp	r9,sp[0x38]
8000acde:	12 3a       	cp.w	r10,r9
8000ace0:	c4 30       	breq	8000ad66 <_dtoa_r+0xb2a>
8000ace2:	06 9b       	mov	r11,r3
8000ace4:	30 09       	mov	r9,0
8000ace6:	30 aa       	mov	r10,10
8000ace8:	0e 9c       	mov	r12,r7
8000acea:	e0 a0 07 37 	rcall	8000bb58 <__multadd>
8000acee:	40 48       	lddsp	r8,sp[0x10]
8000acf0:	18 93       	mov	r3,r12
8000acf2:	08 38       	cp.w	r8,r4
8000acf4:	c0 91       	brne	8000ad06 <_dtoa_r+0xaca>
8000acf6:	10 9b       	mov	r11,r8
8000acf8:	30 09       	mov	r9,0
8000acfa:	30 aa       	mov	r10,10
8000acfc:	0e 9c       	mov	r12,r7
8000acfe:	e0 a0 07 2d 	rcall	8000bb58 <__multadd>
8000ad02:	50 4c       	stdsp	sp[0x10],r12
8000ad04:	c0 e8       	rjmp	8000ad20 <_dtoa_r+0xae4>
8000ad06:	40 4b       	lddsp	r11,sp[0x10]
8000ad08:	30 09       	mov	r9,0
8000ad0a:	30 aa       	mov	r10,10
8000ad0c:	0e 9c       	mov	r12,r7
8000ad0e:	e0 a0 07 25 	rcall	8000bb58 <__multadd>
8000ad12:	08 9b       	mov	r11,r4
8000ad14:	50 4c       	stdsp	sp[0x10],r12
8000ad16:	30 09       	mov	r9,0
8000ad18:	30 aa       	mov	r10,10
8000ad1a:	0e 9c       	mov	r12,r7
8000ad1c:	e0 a0 07 1e 	rcall	8000bb58 <__multadd>
8000ad20:	18 94       	mov	r4,r12
8000ad22:	40 9c       	lddsp	r12,sp[0x24]
8000ad24:	2f fc       	sub	r12,-1
8000ad26:	50 9c       	stdsp	sp[0x24],r12
8000ad28:	c7 9b       	rjmp	8000ac1a <_dtoa_r+0x9de>
8000ad2a:	30 18       	mov	r8,1
8000ad2c:	06 90       	mov	r0,r3
8000ad2e:	40 85       	lddsp	r5,sp[0x20]
8000ad30:	08 93       	mov	r3,r4
8000ad32:	0c 94       	mov	r4,r6
8000ad34:	10 96       	mov	r6,r8
8000ad36:	04 9b       	mov	r11,r2
8000ad38:	00 9c       	mov	r12,r0
8000ad3a:	fe b0 f9 f1 	rcall	8000a11c <quorem>
8000ad3e:	2d 0c       	sub	r12,-48
8000ad40:	0a cc       	st.b	r5++,r12
8000ad42:	02 36       	cp.w	r6,r1
8000ad44:	c0 a4       	brge	8000ad58 <_dtoa_r+0xb1c>
8000ad46:	00 9b       	mov	r11,r0
8000ad48:	30 09       	mov	r9,0
8000ad4a:	30 aa       	mov	r10,10
8000ad4c:	0e 9c       	mov	r12,r7
8000ad4e:	2f f6       	sub	r6,-1
8000ad50:	e0 a0 07 04 	rcall	8000bb58 <__multadd>
8000ad54:	18 90       	mov	r0,r12
8000ad56:	cf 0b       	rjmp	8000ad36 <_dtoa_r+0xafa>
8000ad58:	08 96       	mov	r6,r4
8000ad5a:	30 0b       	mov	r11,0
8000ad5c:	06 94       	mov	r4,r3
8000ad5e:	50 4b       	stdsp	sp[0x10],r11
8000ad60:	00 93       	mov	r3,r0
8000ad62:	18 90       	mov	r0,r12
8000ad64:	c0 28       	rjmp	8000ad68 <_dtoa_r+0xb2c>
8000ad66:	40 26       	lddsp	r6,sp[0x8]
8000ad68:	06 9b       	mov	r11,r3
8000ad6a:	30 1a       	mov	r10,1
8000ad6c:	0e 9c       	mov	r12,r7
8000ad6e:	e0 a0 06 29 	rcall	8000b9c0 <__lshift>
8000ad72:	04 9b       	mov	r11,r2
8000ad74:	18 93       	mov	r3,r12
8000ad76:	e0 a0 05 02 	rcall	8000b77a <__mcmp>
8000ad7a:	e0 89 00 12 	brgt	8000ad9e <_dtoa_r+0xb62>
8000ad7e:	c1 b1       	brne	8000adb4 <_dtoa_r+0xb78>
8000ad80:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad84:	c0 d1       	brne	8000ad9e <_dtoa_r+0xb62>
8000ad86:	c1 78       	rjmp	8000adb4 <_dtoa_r+0xb78>
8000ad88:	40 89       	lddsp	r9,sp[0x20]
8000ad8a:	12 38       	cp.w	r8,r9
8000ad8c:	c0 30       	breq	8000ad92 <_dtoa_r+0xb56>
8000ad8e:	10 95       	mov	r5,r8
8000ad90:	c0 88       	rjmp	8000ada0 <_dtoa_r+0xb64>
8000ad92:	2f f6       	sub	r6,-1
8000ad94:	50 66       	stdsp	sp[0x18],r6
8000ad96:	33 18       	mov	r8,49
8000ad98:	40 8c       	lddsp	r12,sp[0x20]
8000ad9a:	b8 88       	st.b	r12[0x0],r8
8000ad9c:	c1 38       	rjmp	8000adc2 <_dtoa_r+0xb86>
8000ad9e:	33 9a       	mov	r10,57
8000ada0:	0a 98       	mov	r8,r5
8000ada2:	11 79       	ld.ub	r9,--r8
8000ada4:	f4 09 18 00 	cp.b	r9,r10
8000ada8:	cf 00       	breq	8000ad88 <_dtoa_r+0xb4c>
8000adaa:	2f f9       	sub	r9,-1
8000adac:	b0 89       	st.b	r8[0x0],r9
8000adae:	c0 98       	rjmp	8000adc0 <_dtoa_r+0xb84>
8000adb0:	10 95       	mov	r5,r8
8000adb2:	c0 28       	rjmp	8000adb6 <_dtoa_r+0xb7a>
8000adb4:	33 09       	mov	r9,48
8000adb6:	0a 98       	mov	r8,r5
8000adb8:	11 7a       	ld.ub	r10,--r8
8000adba:	f2 0a 18 00 	cp.b	r10,r9
8000adbe:	cf 90       	breq	8000adb0 <_dtoa_r+0xb74>
8000adc0:	50 66       	stdsp	sp[0x18],r6
8000adc2:	04 9b       	mov	r11,r2
8000adc4:	0e 9c       	mov	r12,r7
8000adc6:	e0 a0 04 f3 	rcall	8000b7ac <_Bfree>
8000adca:	58 04       	cp.w	r4,0
8000adcc:	c1 20       	breq	8000adf0 <_dtoa_r+0xbb4>
8000adce:	40 4b       	lddsp	r11,sp[0x10]
8000add0:	08 3b       	cp.w	r11,r4
8000add2:	5f 19       	srne	r9
8000add4:	58 0b       	cp.w	r11,0
8000add6:	5f 18       	srne	r8
8000add8:	f3 e8 00 08 	and	r8,r9,r8
8000addc:	c0 40       	breq	8000ade4 <_dtoa_r+0xba8>
8000adde:	0e 9c       	mov	r12,r7
8000ade0:	e0 a0 04 e6 	rcall	8000b7ac <_Bfree>
8000ade4:	08 9b       	mov	r11,r4
8000ade6:	0e 9c       	mov	r12,r7
8000ade8:	e0 a0 04 e2 	rcall	8000b7ac <_Bfree>
8000adec:	c0 28       	rjmp	8000adf0 <_dtoa_r+0xbb4>
8000adee:	50 66       	stdsp	sp[0x18],r6
8000adf0:	0e 9c       	mov	r12,r7
8000adf2:	06 9b       	mov	r11,r3
8000adf4:	e0 a0 04 dc 	rcall	8000b7ac <_Bfree>
8000adf8:	30 08       	mov	r8,0
8000adfa:	aa 88       	st.b	r5[0x0],r8
8000adfc:	40 68       	lddsp	r8,sp[0x18]
8000adfe:	41 5a       	lddsp	r10,sp[0x54]
8000ae00:	2f f8       	sub	r8,-1
8000ae02:	41 29       	lddsp	r9,sp[0x48]
8000ae04:	95 08       	st.w	r10[0x0],r8
8000ae06:	40 8c       	lddsp	r12,sp[0x20]
8000ae08:	58 09       	cp.w	r9,0
8000ae0a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ae0e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ae12:	2e 6d       	sub	sp,-104
8000ae14:	d8 32       	popm	r0-r7,pc
8000ae16:	d7 03       	nop

8000ae18 <__errno>:
8000ae18:	e0 68 0a 3c 	mov	r8,2620
8000ae1c:	70 0c       	ld.w	r12,r8[0x0]
8000ae1e:	2f 4c       	sub	r12,-12
8000ae20:	5e fc       	retal	r12
8000ae22:	d7 03       	nop

8000ae24 <_fflush_r>:
8000ae24:	d4 21       	pushm	r4-r7,lr
8000ae26:	16 97       	mov	r7,r11
8000ae28:	18 96       	mov	r6,r12
8000ae2a:	76 48       	ld.w	r8,r11[0x10]
8000ae2c:	58 08       	cp.w	r8,0
8000ae2e:	c7 f0       	breq	8000af2c <_fflush_r+0x108>
8000ae30:	58 0c       	cp.w	r12,0
8000ae32:	c0 50       	breq	8000ae3c <_fflush_r+0x18>
8000ae34:	78 68       	ld.w	r8,r12[0x18]
8000ae36:	58 08       	cp.w	r8,0
8000ae38:	c0 21       	brne	8000ae3c <_fflush_r+0x18>
8000ae3a:	cc dc       	rcall	8000afd4 <__sinit>
8000ae3c:	fe c8 cd 2c 	sub	r8,pc,-13012
8000ae40:	10 37       	cp.w	r7,r8
8000ae42:	c0 31       	brne	8000ae48 <_fflush_r+0x24>
8000ae44:	6c 07       	ld.w	r7,r6[0x0]
8000ae46:	c0 c8       	rjmp	8000ae5e <_fflush_r+0x3a>
8000ae48:	fe c8 cd 18 	sub	r8,pc,-13032
8000ae4c:	10 37       	cp.w	r7,r8
8000ae4e:	c0 31       	brne	8000ae54 <_fflush_r+0x30>
8000ae50:	6c 17       	ld.w	r7,r6[0x4]
8000ae52:	c0 68       	rjmp	8000ae5e <_fflush_r+0x3a>
8000ae54:	fe c8 cd 04 	sub	r8,pc,-13052
8000ae58:	10 37       	cp.w	r7,r8
8000ae5a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae5e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae60:	14 98       	mov	r8,r10
8000ae62:	ed ba 00 03 	bld	r10,0x3
8000ae66:	c4 20       	breq	8000aeea <_fflush_r+0xc6>
8000ae68:	ab ba       	sbr	r10,0xb
8000ae6a:	ae 6a       	st.h	r7[0xc],r10
8000ae6c:	6e 18       	ld.w	r8,r7[0x4]
8000ae6e:	58 08       	cp.w	r8,0
8000ae70:	e0 89 00 06 	brgt	8000ae7c <_fflush_r+0x58>
8000ae74:	6f 08       	ld.w	r8,r7[0x40]
8000ae76:	58 08       	cp.w	r8,0
8000ae78:	e0 8a 00 5a 	brle	8000af2c <_fflush_r+0x108>
8000ae7c:	6e b8       	ld.w	r8,r7[0x2c]
8000ae7e:	58 08       	cp.w	r8,0
8000ae80:	c5 60       	breq	8000af2c <_fflush_r+0x108>
8000ae82:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae86:	c0 30       	breq	8000ae8c <_fflush_r+0x68>
8000ae88:	6f 55       	ld.w	r5,r7[0x54]
8000ae8a:	c0 f8       	rjmp	8000aea8 <_fflush_r+0x84>
8000ae8c:	30 19       	mov	r9,1
8000ae8e:	6e 8b       	ld.w	r11,r7[0x20]
8000ae90:	0c 9c       	mov	r12,r6
8000ae92:	5d 18       	icall	r8
8000ae94:	18 95       	mov	r5,r12
8000ae96:	5b fc       	cp.w	r12,-1
8000ae98:	c0 81       	brne	8000aea8 <_fflush_r+0x84>
8000ae9a:	6c 38       	ld.w	r8,r6[0xc]
8000ae9c:	59 d8       	cp.w	r8,29
8000ae9e:	c4 70       	breq	8000af2c <_fflush_r+0x108>
8000aea0:	8e 68       	ld.sh	r8,r7[0xc]
8000aea2:	a7 a8       	sbr	r8,0x6
8000aea4:	ae 68       	st.h	r7[0xc],r8
8000aea6:	d8 22       	popm	r4-r7,pc
8000aea8:	8e 68       	ld.sh	r8,r7[0xc]
8000aeaa:	ed b8 00 02 	bld	r8,0x2
8000aeae:	c0 91       	brne	8000aec0 <_fflush_r+0x9c>
8000aeb0:	6e 18       	ld.w	r8,r7[0x4]
8000aeb2:	10 15       	sub	r5,r8
8000aeb4:	6e d8       	ld.w	r8,r7[0x34]
8000aeb6:	58 08       	cp.w	r8,0
8000aeb8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aebc:	eb d8 e1 15 	subne	r5,r5,r8
8000aec0:	6e b8       	ld.w	r8,r7[0x2c]
8000aec2:	0c 9c       	mov	r12,r6
8000aec4:	30 09       	mov	r9,0
8000aec6:	0a 9a       	mov	r10,r5
8000aec8:	6e 8b       	ld.w	r11,r7[0x20]
8000aeca:	5d 18       	icall	r8
8000aecc:	8e 68       	ld.sh	r8,r7[0xc]
8000aece:	0a 3c       	cp.w	r12,r5
8000aed0:	c2 61       	brne	8000af1c <_fflush_r+0xf8>
8000aed2:	ab d8       	cbr	r8,0xb
8000aed4:	30 0c       	mov	r12,0
8000aed6:	6e 49       	ld.w	r9,r7[0x10]
8000aed8:	ae 68       	st.h	r7[0xc],r8
8000aeda:	8f 1c       	st.w	r7[0x4],r12
8000aedc:	8f 09       	st.w	r7[0x0],r9
8000aede:	ed b8 00 0c 	bld	r8,0xc
8000aee2:	c2 51       	brne	8000af2c <_fflush_r+0x108>
8000aee4:	ef 45 00 54 	st.w	r7[84],r5
8000aee8:	d8 22       	popm	r4-r7,pc
8000aeea:	6e 45       	ld.w	r5,r7[0x10]
8000aeec:	58 05       	cp.w	r5,0
8000aeee:	c1 f0       	breq	8000af2c <_fflush_r+0x108>
8000aef0:	6e 04       	ld.w	r4,r7[0x0]
8000aef2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aef6:	8f 05       	st.w	r7[0x0],r5
8000aef8:	f9 b8 01 00 	movne	r8,0
8000aefc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000af00:	0a 14       	sub	r4,r5
8000af02:	8f 28       	st.w	r7[0x8],r8
8000af04:	c1 18       	rjmp	8000af26 <_fflush_r+0x102>
8000af06:	08 99       	mov	r9,r4
8000af08:	0a 9a       	mov	r10,r5
8000af0a:	6e a8       	ld.w	r8,r7[0x28]
8000af0c:	6e 8b       	ld.w	r11,r7[0x20]
8000af0e:	0c 9c       	mov	r12,r6
8000af10:	5d 18       	icall	r8
8000af12:	18 14       	sub	r4,r12
8000af14:	58 0c       	cp.w	r12,0
8000af16:	e0 89 00 07 	brgt	8000af24 <_fflush_r+0x100>
8000af1a:	8e 68       	ld.sh	r8,r7[0xc]
8000af1c:	a7 a8       	sbr	r8,0x6
8000af1e:	3f fc       	mov	r12,-1
8000af20:	ae 68       	st.h	r7[0xc],r8
8000af22:	d8 22       	popm	r4-r7,pc
8000af24:	18 05       	add	r5,r12
8000af26:	58 04       	cp.w	r4,0
8000af28:	fe 99 ff ef 	brgt	8000af06 <_fflush_r+0xe2>
8000af2c:	d8 2a       	popm	r4-r7,pc,r12=0
8000af2e:	d7 03       	nop

8000af30 <__sfp_lock_acquire>:
8000af30:	5e fc       	retal	r12

8000af32 <__sfp_lock_release>:
8000af32:	5e fc       	retal	r12

8000af34 <_cleanup_r>:
8000af34:	d4 01       	pushm	lr
8000af36:	fe cb f0 ae 	sub	r11,pc,-3922
8000af3a:	e0 a0 02 f7 	rcall	8000b528 <_fwalk>
8000af3e:	d8 02       	popm	pc

8000af40 <__sfmoreglue>:
8000af40:	d4 21       	pushm	r4-r7,lr
8000af42:	16 95       	mov	r5,r11
8000af44:	f6 06 10 5c 	mul	r6,r11,92
8000af48:	ec cb ff f4 	sub	r11,r6,-12
8000af4c:	fe b0 e2 88 	rcall	8000745c <_malloc_r>
8000af50:	18 97       	mov	r7,r12
8000af52:	c0 90       	breq	8000af64 <__sfmoreglue+0x24>
8000af54:	99 15       	st.w	r12[0x4],r5
8000af56:	30 0b       	mov	r11,0
8000af58:	2f 4c       	sub	r12,-12
8000af5a:	0c 9a       	mov	r10,r6
8000af5c:	8f 2c       	st.w	r7[0x8],r12
8000af5e:	8f 0b       	st.w	r7[0x0],r11
8000af60:	fe b0 e5 3e 	rcall	800079dc <memset>
8000af64:	0e 9c       	mov	r12,r7
8000af66:	d8 22       	popm	r4-r7,pc

8000af68 <__sfp>:
8000af68:	d4 21       	pushm	r4-r7,lr
8000af6a:	fe c8 cd f6 	sub	r8,pc,-12810
8000af6e:	18 96       	mov	r6,r12
8000af70:	70 07       	ld.w	r7,r8[0x0]
8000af72:	6e 68       	ld.w	r8,r7[0x18]
8000af74:	58 08       	cp.w	r8,0
8000af76:	c0 31       	brne	8000af7c <__sfp+0x14>
8000af78:	0e 9c       	mov	r12,r7
8000af7a:	c2 dc       	rcall	8000afd4 <__sinit>
8000af7c:	ee c7 ff 28 	sub	r7,r7,-216
8000af80:	30 05       	mov	r5,0
8000af82:	6e 2c       	ld.w	r12,r7[0x8]
8000af84:	6e 18       	ld.w	r8,r7[0x4]
8000af86:	c0 68       	rjmp	8000af92 <__sfp+0x2a>
8000af88:	98 69       	ld.sh	r9,r12[0xc]
8000af8a:	ea 09 19 00 	cp.h	r9,r5
8000af8e:	c1 10       	breq	8000afb0 <__sfp+0x48>
8000af90:	2a 4c       	sub	r12,-92
8000af92:	20 18       	sub	r8,1
8000af94:	cf a7       	brpl	8000af88 <__sfp+0x20>
8000af96:	6e 08       	ld.w	r8,r7[0x0]
8000af98:	58 08       	cp.w	r8,0
8000af9a:	c0 61       	brne	8000afa6 <__sfp+0x3e>
8000af9c:	30 4b       	mov	r11,4
8000af9e:	0c 9c       	mov	r12,r6
8000afa0:	cd 0f       	rcall	8000af40 <__sfmoreglue>
8000afa2:	8f 0c       	st.w	r7[0x0],r12
8000afa4:	c0 30       	breq	8000afaa <__sfp+0x42>
8000afa6:	6e 07       	ld.w	r7,r7[0x0]
8000afa8:	ce db       	rjmp	8000af82 <__sfp+0x1a>
8000afaa:	30 c8       	mov	r8,12
8000afac:	8d 38       	st.w	r6[0xc],r8
8000afae:	d8 22       	popm	r4-r7,pc
8000afb0:	30 08       	mov	r8,0
8000afb2:	f9 48 00 4c 	st.w	r12[76],r8
8000afb6:	99 08       	st.w	r12[0x0],r8
8000afb8:	99 28       	st.w	r12[0x8],r8
8000afba:	99 18       	st.w	r12[0x4],r8
8000afbc:	99 48       	st.w	r12[0x10],r8
8000afbe:	99 58       	st.w	r12[0x14],r8
8000afc0:	99 68       	st.w	r12[0x18],r8
8000afc2:	99 d8       	st.w	r12[0x34],r8
8000afc4:	99 e8       	st.w	r12[0x38],r8
8000afc6:	f9 48 00 48 	st.w	r12[72],r8
8000afca:	3f f8       	mov	r8,-1
8000afcc:	b8 78       	st.h	r12[0xe],r8
8000afce:	30 18       	mov	r8,1
8000afd0:	b8 68       	st.h	r12[0xc],r8
8000afd2:	d8 22       	popm	r4-r7,pc

8000afd4 <__sinit>:
8000afd4:	d4 21       	pushm	r4-r7,lr
8000afd6:	18 96       	mov	r6,r12
8000afd8:	78 67       	ld.w	r7,r12[0x18]
8000afda:	58 07       	cp.w	r7,0
8000afdc:	c4 91       	brne	8000b06e <__sinit+0x9a>
8000afde:	fe c8 00 aa 	sub	r8,pc,170
8000afe2:	30 15       	mov	r5,1
8000afe4:	99 a8       	st.w	r12[0x28],r8
8000afe6:	f9 47 00 d8 	st.w	r12[216],r7
8000afea:	f9 47 00 dc 	st.w	r12[220],r7
8000afee:	f9 47 00 e0 	st.w	r12[224],r7
8000aff2:	99 65       	st.w	r12[0x18],r5
8000aff4:	cb af       	rcall	8000af68 <__sfp>
8000aff6:	8d 0c       	st.w	r6[0x0],r12
8000aff8:	0c 9c       	mov	r12,r6
8000affa:	cb 7f       	rcall	8000af68 <__sfp>
8000affc:	8d 1c       	st.w	r6[0x4],r12
8000affe:	0c 9c       	mov	r12,r6
8000b000:	cb 4f       	rcall	8000af68 <__sfp>
8000b002:	6c 09       	ld.w	r9,r6[0x0]
8000b004:	30 48       	mov	r8,4
8000b006:	93 07       	st.w	r9[0x0],r7
8000b008:	b2 68       	st.h	r9[0xc],r8
8000b00a:	93 17       	st.w	r9[0x4],r7
8000b00c:	93 27       	st.w	r9[0x8],r7
8000b00e:	6c 18       	ld.w	r8,r6[0x4]
8000b010:	b2 77       	st.h	r9[0xe],r7
8000b012:	93 47       	st.w	r9[0x10],r7
8000b014:	93 57       	st.w	r9[0x14],r7
8000b016:	93 67       	st.w	r9[0x18],r7
8000b018:	93 89       	st.w	r9[0x20],r9
8000b01a:	91 07       	st.w	r8[0x0],r7
8000b01c:	91 17       	st.w	r8[0x4],r7
8000b01e:	91 27       	st.w	r8[0x8],r7
8000b020:	fe ce f3 24 	sub	lr,pc,-3292
8000b024:	fe cb f3 54 	sub	r11,pc,-3244
8000b028:	93 9e       	st.w	r9[0x24],lr
8000b02a:	93 ab       	st.w	r9[0x28],r11
8000b02c:	fe ca f3 7c 	sub	r10,pc,-3204
8000b030:	fe c4 f3 88 	sub	r4,pc,-3192
8000b034:	93 ba       	st.w	r9[0x2c],r10
8000b036:	93 c4       	st.w	r9[0x30],r4
8000b038:	30 99       	mov	r9,9
8000b03a:	b0 69       	st.h	r8[0xc],r9
8000b03c:	b0 75       	st.h	r8[0xe],r5
8000b03e:	91 c4       	st.w	r8[0x30],r4
8000b040:	91 47       	st.w	r8[0x10],r7
8000b042:	91 57       	st.w	r8[0x14],r7
8000b044:	91 67       	st.w	r8[0x18],r7
8000b046:	91 88       	st.w	r8[0x20],r8
8000b048:	91 9e       	st.w	r8[0x24],lr
8000b04a:	91 ab       	st.w	r8[0x28],r11
8000b04c:	91 ba       	st.w	r8[0x2c],r10
8000b04e:	8d 2c       	st.w	r6[0x8],r12
8000b050:	31 28       	mov	r8,18
8000b052:	99 07       	st.w	r12[0x0],r7
8000b054:	b8 68       	st.h	r12[0xc],r8
8000b056:	99 17       	st.w	r12[0x4],r7
8000b058:	99 27       	st.w	r12[0x8],r7
8000b05a:	30 28       	mov	r8,2
8000b05c:	b8 78       	st.h	r12[0xe],r8
8000b05e:	99 c4       	st.w	r12[0x30],r4
8000b060:	99 67       	st.w	r12[0x18],r7
8000b062:	99 9e       	st.w	r12[0x24],lr
8000b064:	99 ab       	st.w	r12[0x28],r11
8000b066:	99 ba       	st.w	r12[0x2c],r10
8000b068:	99 47       	st.w	r12[0x10],r7
8000b06a:	99 57       	st.w	r12[0x14],r7
8000b06c:	99 8c       	st.w	r12[0x20],r12
8000b06e:	d8 22       	popm	r4-r7,pc

8000b070 <_malloc_trim_r>:
8000b070:	d4 21       	pushm	r4-r7,lr
8000b072:	16 95       	mov	r5,r11
8000b074:	18 97       	mov	r7,r12
8000b076:	fe b0 d7 ad 	rcall	80005fd0 <__malloc_lock>
8000b07a:	e0 64 05 3c 	mov	r4,1340
8000b07e:	68 28       	ld.w	r8,r4[0x8]
8000b080:	70 16       	ld.w	r6,r8[0x4]
8000b082:	e0 16 ff fc 	andl	r6,0xfffc
8000b086:	ec c8 ff 91 	sub	r8,r6,-111
8000b08a:	f0 05 01 05 	sub	r5,r8,r5
8000b08e:	e0 15 ff 80 	andl	r5,0xff80
8000b092:	ea c5 00 80 	sub	r5,r5,128
8000b096:	e0 45 00 7f 	cp.w	r5,127
8000b09a:	e0 8a 00 25 	brle	8000b0e4 <_malloc_trim_r+0x74>
8000b09e:	30 0b       	mov	r11,0
8000b0a0:	0e 9c       	mov	r12,r7
8000b0a2:	fe b0 e6 05 	rcall	80007cac <_sbrk_r>
8000b0a6:	68 28       	ld.w	r8,r4[0x8]
8000b0a8:	0c 08       	add	r8,r6
8000b0aa:	10 3c       	cp.w	r12,r8
8000b0ac:	c1 c1       	brne	8000b0e4 <_malloc_trim_r+0x74>
8000b0ae:	ea 0b 11 00 	rsub	r11,r5,0
8000b0b2:	0e 9c       	mov	r12,r7
8000b0b4:	fe b0 e5 fc 	rcall	80007cac <_sbrk_r>
8000b0b8:	5b fc       	cp.w	r12,-1
8000b0ba:	c1 91       	brne	8000b0ec <_malloc_trim_r+0x7c>
8000b0bc:	30 0b       	mov	r11,0
8000b0be:	0e 9c       	mov	r12,r7
8000b0c0:	fe b0 e5 f6 	rcall	80007cac <_sbrk_r>
8000b0c4:	68 28       	ld.w	r8,r4[0x8]
8000b0c6:	f8 08 01 09 	sub	r9,r12,r8
8000b0ca:	58 f9       	cp.w	r9,15
8000b0cc:	e0 8a 00 0c 	brle	8000b0e4 <_malloc_trim_r+0x74>
8000b0d0:	a1 a9       	sbr	r9,0x0
8000b0d2:	91 19       	st.w	r8[0x4],r9
8000b0d4:	e0 68 09 48 	mov	r8,2376
8000b0d8:	70 09       	ld.w	r9,r8[0x0]
8000b0da:	e0 68 0d 70 	mov	r8,3440
8000b0de:	f8 09 01 09 	sub	r9,r12,r9
8000b0e2:	91 09       	st.w	r8[0x0],r9
8000b0e4:	0e 9c       	mov	r12,r7
8000b0e6:	fe b0 d7 7b 	rcall	80005fdc <__malloc_unlock>
8000b0ea:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0ec:	68 28       	ld.w	r8,r4[0x8]
8000b0ee:	0a 16       	sub	r6,r5
8000b0f0:	a1 a6       	sbr	r6,0x0
8000b0f2:	91 16       	st.w	r8[0x4],r6
8000b0f4:	e0 68 0d 70 	mov	r8,3440
8000b0f8:	70 09       	ld.w	r9,r8[0x0]
8000b0fa:	0a 19       	sub	r9,r5
8000b0fc:	0e 9c       	mov	r12,r7
8000b0fe:	91 09       	st.w	r8[0x0],r9
8000b100:	fe b0 d7 6e 	rcall	80005fdc <__malloc_unlock>
8000b104:	da 2a       	popm	r4-r7,pc,r12=1
8000b106:	d7 03       	nop

8000b108 <_free_r>:
8000b108:	d4 21       	pushm	r4-r7,lr
8000b10a:	16 96       	mov	r6,r11
8000b10c:	18 97       	mov	r7,r12
8000b10e:	58 0b       	cp.w	r11,0
8000b110:	e0 80 00 c0 	breq	8000b290 <_free_r+0x188>
8000b114:	fe b0 d7 5e 	rcall	80005fd0 <__malloc_lock>
8000b118:	20 86       	sub	r6,8
8000b11a:	e0 6a 05 3c 	mov	r10,1340
8000b11e:	6c 18       	ld.w	r8,r6[0x4]
8000b120:	74 2e       	ld.w	lr,r10[0x8]
8000b122:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b126:	a1 c8       	cbr	r8,0x0
8000b128:	ec 08 00 09 	add	r9,r6,r8
8000b12c:	72 1b       	ld.w	r11,r9[0x4]
8000b12e:	e0 1b ff fc 	andl	r11,0xfffc
8000b132:	1c 39       	cp.w	r9,lr
8000b134:	c1 e1       	brne	8000b170 <_free_r+0x68>
8000b136:	f6 08 00 08 	add	r8,r11,r8
8000b13a:	58 0c       	cp.w	r12,0
8000b13c:	c0 81       	brne	8000b14c <_free_r+0x44>
8000b13e:	6c 09       	ld.w	r9,r6[0x0]
8000b140:	12 16       	sub	r6,r9
8000b142:	12 08       	add	r8,r9
8000b144:	6c 3b       	ld.w	r11,r6[0xc]
8000b146:	6c 29       	ld.w	r9,r6[0x8]
8000b148:	97 29       	st.w	r11[0x8],r9
8000b14a:	93 3b       	st.w	r9[0xc],r11
8000b14c:	10 99       	mov	r9,r8
8000b14e:	95 26       	st.w	r10[0x8],r6
8000b150:	a1 a9       	sbr	r9,0x0
8000b152:	8d 19       	st.w	r6[0x4],r9
8000b154:	e0 69 09 44 	mov	r9,2372
8000b158:	72 09       	ld.w	r9,r9[0x0]
8000b15a:	12 38       	cp.w	r8,r9
8000b15c:	c0 63       	brcs	8000b168 <_free_r+0x60>
8000b15e:	e0 68 0d 6c 	mov	r8,3436
8000b162:	0e 9c       	mov	r12,r7
8000b164:	70 0b       	ld.w	r11,r8[0x0]
8000b166:	c8 5f       	rcall	8000b070 <_malloc_trim_r>
8000b168:	0e 9c       	mov	r12,r7
8000b16a:	fe b0 d7 39 	rcall	80005fdc <__malloc_unlock>
8000b16e:	d8 22       	popm	r4-r7,pc
8000b170:	93 1b       	st.w	r9[0x4],r11
8000b172:	58 0c       	cp.w	r12,0
8000b174:	c0 30       	breq	8000b17a <_free_r+0x72>
8000b176:	30 0c       	mov	r12,0
8000b178:	c1 08       	rjmp	8000b198 <_free_r+0x90>
8000b17a:	6c 0e       	ld.w	lr,r6[0x0]
8000b17c:	f4 c5 ff f8 	sub	r5,r10,-8
8000b180:	1c 16       	sub	r6,lr
8000b182:	1c 08       	add	r8,lr
8000b184:	6c 2e       	ld.w	lr,r6[0x8]
8000b186:	0a 3e       	cp.w	lr,r5
8000b188:	f9 bc 00 01 	moveq	r12,1
8000b18c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b190:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b194:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b198:	f2 0b 00 0e 	add	lr,r9,r11
8000b19c:	7c 1e       	ld.w	lr,lr[0x4]
8000b19e:	ed be 00 00 	bld	lr,0x0
8000b1a2:	c1 40       	breq	8000b1ca <_free_r+0xc2>
8000b1a4:	16 08       	add	r8,r11
8000b1a6:	58 0c       	cp.w	r12,0
8000b1a8:	c0 d1       	brne	8000b1c2 <_free_r+0xba>
8000b1aa:	e0 6e 05 3c 	mov	lr,1340
8000b1ae:	72 2b       	ld.w	r11,r9[0x8]
8000b1b0:	2f 8e       	sub	lr,-8
8000b1b2:	1c 3b       	cp.w	r11,lr
8000b1b4:	c0 71       	brne	8000b1c2 <_free_r+0xba>
8000b1b6:	97 36       	st.w	r11[0xc],r6
8000b1b8:	97 26       	st.w	r11[0x8],r6
8000b1ba:	8d 2b       	st.w	r6[0x8],r11
8000b1bc:	8d 3b       	st.w	r6[0xc],r11
8000b1be:	30 1c       	mov	r12,1
8000b1c0:	c0 58       	rjmp	8000b1ca <_free_r+0xc2>
8000b1c2:	72 2b       	ld.w	r11,r9[0x8]
8000b1c4:	72 39       	ld.w	r9,r9[0xc]
8000b1c6:	93 2b       	st.w	r9[0x8],r11
8000b1c8:	97 39       	st.w	r11[0xc],r9
8000b1ca:	10 99       	mov	r9,r8
8000b1cc:	ec 08 09 08 	st.w	r6[r8],r8
8000b1d0:	a1 a9       	sbr	r9,0x0
8000b1d2:	8d 19       	st.w	r6[0x4],r9
8000b1d4:	58 0c       	cp.w	r12,0
8000b1d6:	c5 a1       	brne	8000b28a <_free_r+0x182>
8000b1d8:	e0 48 01 ff 	cp.w	r8,511
8000b1dc:	e0 8b 00 13 	brhi	8000b202 <_free_r+0xfa>
8000b1e0:	a3 98       	lsr	r8,0x3
8000b1e2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b1e6:	72 2b       	ld.w	r11,r9[0x8]
8000b1e8:	8d 39       	st.w	r6[0xc],r9
8000b1ea:	8d 2b       	st.w	r6[0x8],r11
8000b1ec:	97 36       	st.w	r11[0xc],r6
8000b1ee:	93 26       	st.w	r9[0x8],r6
8000b1f0:	a3 48       	asr	r8,0x2
8000b1f2:	74 19       	ld.w	r9,r10[0x4]
8000b1f4:	30 1b       	mov	r11,1
8000b1f6:	f6 08 09 48 	lsl	r8,r11,r8
8000b1fa:	f3 e8 10 08 	or	r8,r9,r8
8000b1fe:	95 18       	st.w	r10[0x4],r8
8000b200:	c4 58       	rjmp	8000b28a <_free_r+0x182>
8000b202:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b206:	58 4b       	cp.w	r11,4
8000b208:	e0 8b 00 06 	brhi	8000b214 <_free_r+0x10c>
8000b20c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b210:	2c 8b       	sub	r11,-56
8000b212:	c2 08       	rjmp	8000b252 <_free_r+0x14a>
8000b214:	59 4b       	cp.w	r11,20
8000b216:	e0 8b 00 04 	brhi	8000b21e <_free_r+0x116>
8000b21a:	2a 5b       	sub	r11,-91
8000b21c:	c1 b8       	rjmp	8000b252 <_free_r+0x14a>
8000b21e:	e0 4b 00 54 	cp.w	r11,84
8000b222:	e0 8b 00 06 	brhi	8000b22e <_free_r+0x126>
8000b226:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b22a:	29 2b       	sub	r11,-110
8000b22c:	c1 38       	rjmp	8000b252 <_free_r+0x14a>
8000b22e:	e0 4b 01 54 	cp.w	r11,340
8000b232:	e0 8b 00 06 	brhi	8000b23e <_free_r+0x136>
8000b236:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b23a:	28 9b       	sub	r11,-119
8000b23c:	c0 b8       	rjmp	8000b252 <_free_r+0x14a>
8000b23e:	e0 4b 05 54 	cp.w	r11,1364
8000b242:	e0 88 00 05 	brls	8000b24c <_free_r+0x144>
8000b246:	37 eb       	mov	r11,126
8000b248:	c0 58       	rjmp	8000b252 <_free_r+0x14a>
8000b24a:	d7 03       	nop
8000b24c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b250:	28 4b       	sub	r11,-124
8000b252:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b256:	78 29       	ld.w	r9,r12[0x8]
8000b258:	18 39       	cp.w	r9,r12
8000b25a:	c0 e1       	brne	8000b276 <_free_r+0x16e>
8000b25c:	74 18       	ld.w	r8,r10[0x4]
8000b25e:	a3 4b       	asr	r11,0x2
8000b260:	30 1c       	mov	r12,1
8000b262:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b266:	f1 eb 10 0b 	or	r11,r8,r11
8000b26a:	12 98       	mov	r8,r9
8000b26c:	95 1b       	st.w	r10[0x4],r11
8000b26e:	c0 a8       	rjmp	8000b282 <_free_r+0x17a>
8000b270:	72 29       	ld.w	r9,r9[0x8]
8000b272:	18 39       	cp.w	r9,r12
8000b274:	c0 60       	breq	8000b280 <_free_r+0x178>
8000b276:	72 1a       	ld.w	r10,r9[0x4]
8000b278:	e0 1a ff fc 	andl	r10,0xfffc
8000b27c:	14 38       	cp.w	r8,r10
8000b27e:	cf 93       	brcs	8000b270 <_free_r+0x168>
8000b280:	72 38       	ld.w	r8,r9[0xc]
8000b282:	8d 38       	st.w	r6[0xc],r8
8000b284:	8d 29       	st.w	r6[0x8],r9
8000b286:	93 36       	st.w	r9[0xc],r6
8000b288:	91 26       	st.w	r8[0x8],r6
8000b28a:	0e 9c       	mov	r12,r7
8000b28c:	fe b0 d6 a8 	rcall	80005fdc <__malloc_unlock>
8000b290:	d8 22       	popm	r4-r7,pc
8000b292:	d7 03       	nop

8000b294 <__sfvwrite_r>:
8000b294:	d4 31       	pushm	r0-r7,lr
8000b296:	20 3d       	sub	sp,12
8000b298:	14 94       	mov	r4,r10
8000b29a:	18 95       	mov	r5,r12
8000b29c:	16 97       	mov	r7,r11
8000b29e:	74 28       	ld.w	r8,r10[0x8]
8000b2a0:	58 08       	cp.w	r8,0
8000b2a2:	e0 80 01 40 	breq	8000b522 <__sfvwrite_r+0x28e>
8000b2a6:	96 68       	ld.sh	r8,r11[0xc]
8000b2a8:	ed b8 00 03 	bld	r8,0x3
8000b2ac:	c0 41       	brne	8000b2b4 <__sfvwrite_r+0x20>
8000b2ae:	76 48       	ld.w	r8,r11[0x10]
8000b2b0:	58 08       	cp.w	r8,0
8000b2b2:	c0 c1       	brne	8000b2ca <__sfvwrite_r+0x36>
8000b2b4:	0e 9b       	mov	r11,r7
8000b2b6:	0a 9c       	mov	r12,r5
8000b2b8:	fe b0 f6 c4 	rcall	8000a040 <__swsetup_r>
8000b2bc:	c0 70       	breq	8000b2ca <__sfvwrite_r+0x36>
8000b2be:	8e 68       	ld.sh	r8,r7[0xc]
8000b2c0:	a7 a8       	sbr	r8,0x6
8000b2c2:	ae 68       	st.h	r7[0xc],r8
8000b2c4:	30 98       	mov	r8,9
8000b2c6:	8b 38       	st.w	r5[0xc],r8
8000b2c8:	c2 b9       	rjmp	8000b51e <__sfvwrite_r+0x28a>
8000b2ca:	8e 63       	ld.sh	r3,r7[0xc]
8000b2cc:	68 00       	ld.w	r0,r4[0x0]
8000b2ce:	06 96       	mov	r6,r3
8000b2d0:	e2 16 00 02 	andl	r6,0x2,COH
8000b2d4:	c2 10       	breq	8000b316 <__sfvwrite_r+0x82>
8000b2d6:	30 03       	mov	r3,0
8000b2d8:	e0 62 04 00 	mov	r2,1024
8000b2dc:	06 96       	mov	r6,r3
8000b2de:	c0 48       	rjmp	8000b2e6 <__sfvwrite_r+0x52>
8000b2e0:	60 03       	ld.w	r3,r0[0x0]
8000b2e2:	60 16       	ld.w	r6,r0[0x4]
8000b2e4:	2f 80       	sub	r0,-8
8000b2e6:	58 06       	cp.w	r6,0
8000b2e8:	cf c0       	breq	8000b2e0 <__sfvwrite_r+0x4c>
8000b2ea:	e0 46 04 00 	cp.w	r6,1024
8000b2ee:	ec 09 17 80 	movls	r9,r6
8000b2f2:	e4 09 17 b0 	movhi	r9,r2
8000b2f6:	06 9a       	mov	r10,r3
8000b2f8:	6e a8       	ld.w	r8,r7[0x28]
8000b2fa:	6e 8b       	ld.w	r11,r7[0x20]
8000b2fc:	0a 9c       	mov	r12,r5
8000b2fe:	5d 18       	icall	r8
8000b300:	18 16       	sub	r6,r12
8000b302:	58 0c       	cp.w	r12,0
8000b304:	e0 8a 01 0a 	brle	8000b518 <__sfvwrite_r+0x284>
8000b308:	68 28       	ld.w	r8,r4[0x8]
8000b30a:	18 18       	sub	r8,r12
8000b30c:	89 28       	st.w	r4[0x8],r8
8000b30e:	e0 80 01 0a 	breq	8000b522 <__sfvwrite_r+0x28e>
8000b312:	18 03       	add	r3,r12
8000b314:	ce 9b       	rjmp	8000b2e6 <__sfvwrite_r+0x52>
8000b316:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b31a:	c0 70       	breq	8000b328 <__sfvwrite_r+0x94>
8000b31c:	50 06       	stdsp	sp[0x0],r6
8000b31e:	0c 93       	mov	r3,r6
8000b320:	0c 91       	mov	r1,r6
8000b322:	50 15       	stdsp	sp[0x4],r5
8000b324:	08 92       	mov	r2,r4
8000b326:	c9 c8       	rjmp	8000b45e <__sfvwrite_r+0x1ca>
8000b328:	06 96       	mov	r6,r3
8000b32a:	08 91       	mov	r1,r4
8000b32c:	c0 48       	rjmp	8000b334 <__sfvwrite_r+0xa0>
8000b32e:	60 03       	ld.w	r3,r0[0x0]
8000b330:	60 16       	ld.w	r6,r0[0x4]
8000b332:	2f 80       	sub	r0,-8
8000b334:	58 06       	cp.w	r6,0
8000b336:	cf c0       	breq	8000b32e <__sfvwrite_r+0x9a>
8000b338:	8e 68       	ld.sh	r8,r7[0xc]
8000b33a:	6e 24       	ld.w	r4,r7[0x8]
8000b33c:	10 99       	mov	r9,r8
8000b33e:	e2 19 02 00 	andl	r9,0x200,COH
8000b342:	c5 50       	breq	8000b3ec <__sfvwrite_r+0x158>
8000b344:	08 36       	cp.w	r6,r4
8000b346:	c4 43       	brcs	8000b3ce <__sfvwrite_r+0x13a>
8000b348:	10 99       	mov	r9,r8
8000b34a:	e2 19 04 80 	andl	r9,0x480,COH
8000b34e:	c4 00       	breq	8000b3ce <__sfvwrite_r+0x13a>
8000b350:	6e 4b       	ld.w	r11,r7[0x10]
8000b352:	6e 09       	ld.w	r9,r7[0x0]
8000b354:	16 19       	sub	r9,r11
8000b356:	50 09       	stdsp	sp[0x0],r9
8000b358:	6e 59       	ld.w	r9,r7[0x14]
8000b35a:	10 9c       	mov	r12,r8
8000b35c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b360:	30 28       	mov	r8,2
8000b362:	f4 08 0c 08 	divs	r8,r10,r8
8000b366:	fa e9 00 04 	st.d	sp[4],r8
8000b36a:	10 94       	mov	r4,r8
8000b36c:	40 09       	lddsp	r9,sp[0x0]
8000b36e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b372:	2f f9       	sub	r9,-1
8000b374:	0c 09       	add	r9,r6
8000b376:	12 38       	cp.w	r8,r9
8000b378:	f2 04 17 30 	movlo	r4,r9
8000b37c:	58 0c       	cp.w	r12,0
8000b37e:	c1 10       	breq	8000b3a0 <__sfvwrite_r+0x10c>
8000b380:	08 9b       	mov	r11,r4
8000b382:	0a 9c       	mov	r12,r5
8000b384:	fe b0 e0 6c 	rcall	8000745c <_malloc_r>
8000b388:	18 92       	mov	r2,r12
8000b38a:	c1 40       	breq	8000b3b2 <__sfvwrite_r+0x11e>
8000b38c:	40 0a       	lddsp	r10,sp[0x0]
8000b38e:	6e 4b       	ld.w	r11,r7[0x10]
8000b390:	fe b0 e2 82 	rcall	80007894 <memcpy>
8000b394:	8e 68       	ld.sh	r8,r7[0xc]
8000b396:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b39a:	a7 b8       	sbr	r8,0x7
8000b39c:	ae 68       	st.h	r7[0xc],r8
8000b39e:	c0 d8       	rjmp	8000b3b8 <__sfvwrite_r+0x124>
8000b3a0:	08 9a       	mov	r10,r4
8000b3a2:	0a 9c       	mov	r12,r5
8000b3a4:	fe b0 e3 24 	rcall	800079ec <_realloc_r>
8000b3a8:	18 92       	mov	r2,r12
8000b3aa:	c0 71       	brne	8000b3b8 <__sfvwrite_r+0x124>
8000b3ac:	6e 4b       	ld.w	r11,r7[0x10]
8000b3ae:	0a 9c       	mov	r12,r5
8000b3b0:	ca ce       	rcall	8000b108 <_free_r>
8000b3b2:	30 c8       	mov	r8,12
8000b3b4:	8b 38       	st.w	r5[0xc],r8
8000b3b6:	cb 18       	rjmp	8000b518 <__sfvwrite_r+0x284>
8000b3b8:	40 0a       	lddsp	r10,sp[0x0]
8000b3ba:	40 09       	lddsp	r9,sp[0x0]
8000b3bc:	e8 0a 01 0a 	sub	r10,r4,r10
8000b3c0:	e4 09 00 08 	add	r8,r2,r9
8000b3c4:	8f 54       	st.w	r7[0x14],r4
8000b3c6:	8f 2a       	st.w	r7[0x8],r10
8000b3c8:	8f 08       	st.w	r7[0x0],r8
8000b3ca:	8f 42       	st.w	r7[0x10],r2
8000b3cc:	0c 94       	mov	r4,r6
8000b3ce:	08 36       	cp.w	r6,r4
8000b3d0:	ec 04 17 30 	movlo	r4,r6
8000b3d4:	06 9b       	mov	r11,r3
8000b3d6:	08 9a       	mov	r10,r4
8000b3d8:	6e 0c       	ld.w	r12,r7[0x0]
8000b3da:	c3 ad       	rcall	8000b64e <memmove>
8000b3dc:	6e 08       	ld.w	r8,r7[0x0]
8000b3de:	08 08       	add	r8,r4
8000b3e0:	8f 08       	st.w	r7[0x0],r8
8000b3e2:	6e 28       	ld.w	r8,r7[0x8]
8000b3e4:	08 18       	sub	r8,r4
8000b3e6:	0c 94       	mov	r4,r6
8000b3e8:	8f 28       	st.w	r7[0x8],r8
8000b3ea:	c2 e8       	rjmp	8000b446 <__sfvwrite_r+0x1b2>
8000b3ec:	08 36       	cp.w	r6,r4
8000b3ee:	5f ba       	srhi	r10
8000b3f0:	6e 0c       	ld.w	r12,r7[0x0]
8000b3f2:	6e 48       	ld.w	r8,r7[0x10]
8000b3f4:	10 3c       	cp.w	r12,r8
8000b3f6:	5f b8       	srhi	r8
8000b3f8:	f5 e8 00 08 	and	r8,r10,r8
8000b3fc:	f2 08 18 00 	cp.b	r8,r9
8000b400:	c0 d0       	breq	8000b41a <__sfvwrite_r+0x186>
8000b402:	06 9b       	mov	r11,r3
8000b404:	08 9a       	mov	r10,r4
8000b406:	c2 4d       	rcall	8000b64e <memmove>
8000b408:	6e 08       	ld.w	r8,r7[0x0]
8000b40a:	08 08       	add	r8,r4
8000b40c:	0e 9b       	mov	r11,r7
8000b40e:	8f 08       	st.w	r7[0x0],r8
8000b410:	0a 9c       	mov	r12,r5
8000b412:	fe b0 fd 09 	rcall	8000ae24 <_fflush_r>
8000b416:	c1 80       	breq	8000b446 <__sfvwrite_r+0x1b2>
8000b418:	c8 08       	rjmp	8000b518 <__sfvwrite_r+0x284>
8000b41a:	6e 59       	ld.w	r9,r7[0x14]
8000b41c:	12 36       	cp.w	r6,r9
8000b41e:	c0 a3       	brcs	8000b432 <__sfvwrite_r+0x19e>
8000b420:	6e a8       	ld.w	r8,r7[0x28]
8000b422:	06 9a       	mov	r10,r3
8000b424:	6e 8b       	ld.w	r11,r7[0x20]
8000b426:	0a 9c       	mov	r12,r5
8000b428:	5d 18       	icall	r8
8000b42a:	18 94       	mov	r4,r12
8000b42c:	e0 89 00 0d 	brgt	8000b446 <__sfvwrite_r+0x1b2>
8000b430:	c7 48       	rjmp	8000b518 <__sfvwrite_r+0x284>
8000b432:	0c 9a       	mov	r10,r6
8000b434:	06 9b       	mov	r11,r3
8000b436:	c0 cd       	rcall	8000b64e <memmove>
8000b438:	6e 08       	ld.w	r8,r7[0x0]
8000b43a:	0c 08       	add	r8,r6
8000b43c:	0c 94       	mov	r4,r6
8000b43e:	8f 08       	st.w	r7[0x0],r8
8000b440:	6e 28       	ld.w	r8,r7[0x8]
8000b442:	0c 18       	sub	r8,r6
8000b444:	8f 28       	st.w	r7[0x8],r8
8000b446:	62 28       	ld.w	r8,r1[0x8]
8000b448:	08 18       	sub	r8,r4
8000b44a:	83 28       	st.w	r1[0x8],r8
8000b44c:	c6 b0       	breq	8000b522 <__sfvwrite_r+0x28e>
8000b44e:	08 16       	sub	r6,r4
8000b450:	08 03       	add	r3,r4
8000b452:	c7 1b       	rjmp	8000b334 <__sfvwrite_r+0xa0>
8000b454:	60 03       	ld.w	r3,r0[0x0]
8000b456:	60 11       	ld.w	r1,r0[0x4]
8000b458:	30 08       	mov	r8,0
8000b45a:	2f 80       	sub	r0,-8
8000b45c:	50 08       	stdsp	sp[0x0],r8
8000b45e:	58 01       	cp.w	r1,0
8000b460:	cf a0       	breq	8000b454 <__sfvwrite_r+0x1c0>
8000b462:	40 0a       	lddsp	r10,sp[0x0]
8000b464:	58 0a       	cp.w	r10,0
8000b466:	c1 41       	brne	8000b48e <__sfvwrite_r+0x1fa>
8000b468:	e2 c6 ff ff 	sub	r6,r1,-1
8000b46c:	02 9a       	mov	r10,r1
8000b46e:	30 ab       	mov	r11,10
8000b470:	06 9c       	mov	r12,r3
8000b472:	ce 3c       	rcall	8000b638 <memchr>
8000b474:	f8 c8 ff ff 	sub	r8,r12,-1
8000b478:	58 0c       	cp.w	r12,0
8000b47a:	f1 d3 e1 16 	subne	r6,r8,r3
8000b47e:	f9 b9 01 01 	movne	r9,1
8000b482:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b486:	f9 b8 00 01 	moveq	r8,1
8000b48a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b48e:	02 36       	cp.w	r6,r1
8000b490:	ec 04 17 80 	movls	r4,r6
8000b494:	e2 04 17 b0 	movhi	r4,r1
8000b498:	6e 59       	ld.w	r9,r7[0x14]
8000b49a:	6e 25       	ld.w	r5,r7[0x8]
8000b49c:	f2 05 00 05 	add	r5,r9,r5
8000b4a0:	0a 34       	cp.w	r4,r5
8000b4a2:	5f 9a       	srgt	r10
8000b4a4:	6e 0c       	ld.w	r12,r7[0x0]
8000b4a6:	6e 48       	ld.w	r8,r7[0x10]
8000b4a8:	10 3c       	cp.w	r12,r8
8000b4aa:	5f b8       	srhi	r8
8000b4ac:	f5 e8 00 08 	and	r8,r10,r8
8000b4b0:	30 0a       	mov	r10,0
8000b4b2:	f4 08 18 00 	cp.b	r8,r10
8000b4b6:	c0 d0       	breq	8000b4d0 <__sfvwrite_r+0x23c>
8000b4b8:	06 9b       	mov	r11,r3
8000b4ba:	0a 9a       	mov	r10,r5
8000b4bc:	cc 9c       	rcall	8000b64e <memmove>
8000b4be:	6e 08       	ld.w	r8,r7[0x0]
8000b4c0:	0a 08       	add	r8,r5
8000b4c2:	0e 9b       	mov	r11,r7
8000b4c4:	8f 08       	st.w	r7[0x0],r8
8000b4c6:	40 1c       	lddsp	r12,sp[0x4]
8000b4c8:	fe b0 fc ae 	rcall	8000ae24 <_fflush_r>
8000b4cc:	c1 70       	breq	8000b4fa <__sfvwrite_r+0x266>
8000b4ce:	c2 58       	rjmp	8000b518 <__sfvwrite_r+0x284>
8000b4d0:	12 34       	cp.w	r4,r9
8000b4d2:	c0 a5       	brlt	8000b4e6 <__sfvwrite_r+0x252>
8000b4d4:	6e a8       	ld.w	r8,r7[0x28]
8000b4d6:	06 9a       	mov	r10,r3
8000b4d8:	6e 8b       	ld.w	r11,r7[0x20]
8000b4da:	40 1c       	lddsp	r12,sp[0x4]
8000b4dc:	5d 18       	icall	r8
8000b4de:	18 95       	mov	r5,r12
8000b4e0:	e0 89 00 0d 	brgt	8000b4fa <__sfvwrite_r+0x266>
8000b4e4:	c1 a8       	rjmp	8000b518 <__sfvwrite_r+0x284>
8000b4e6:	08 9a       	mov	r10,r4
8000b4e8:	06 9b       	mov	r11,r3
8000b4ea:	cb 2c       	rcall	8000b64e <memmove>
8000b4ec:	6e 08       	ld.w	r8,r7[0x0]
8000b4ee:	08 08       	add	r8,r4
8000b4f0:	08 95       	mov	r5,r4
8000b4f2:	8f 08       	st.w	r7[0x0],r8
8000b4f4:	6e 28       	ld.w	r8,r7[0x8]
8000b4f6:	08 18       	sub	r8,r4
8000b4f8:	8f 28       	st.w	r7[0x8],r8
8000b4fa:	0a 16       	sub	r6,r5
8000b4fc:	c0 71       	brne	8000b50a <__sfvwrite_r+0x276>
8000b4fe:	0e 9b       	mov	r11,r7
8000b500:	40 1c       	lddsp	r12,sp[0x4]
8000b502:	fe b0 fc 91 	rcall	8000ae24 <_fflush_r>
8000b506:	c0 91       	brne	8000b518 <__sfvwrite_r+0x284>
8000b508:	50 06       	stdsp	sp[0x0],r6
8000b50a:	64 28       	ld.w	r8,r2[0x8]
8000b50c:	0a 18       	sub	r8,r5
8000b50e:	85 28       	st.w	r2[0x8],r8
8000b510:	c0 90       	breq	8000b522 <__sfvwrite_r+0x28e>
8000b512:	0a 11       	sub	r1,r5
8000b514:	0a 03       	add	r3,r5
8000b516:	ca 4b       	rjmp	8000b45e <__sfvwrite_r+0x1ca>
8000b518:	8e 68       	ld.sh	r8,r7[0xc]
8000b51a:	a7 a8       	sbr	r8,0x6
8000b51c:	ae 68       	st.h	r7[0xc],r8
8000b51e:	3f fc       	mov	r12,-1
8000b520:	c0 28       	rjmp	8000b524 <__sfvwrite_r+0x290>
8000b522:	30 0c       	mov	r12,0
8000b524:	2f dd       	sub	sp,-12
8000b526:	d8 32       	popm	r0-r7,pc

8000b528 <_fwalk>:
8000b528:	d4 31       	pushm	r0-r7,lr
8000b52a:	30 05       	mov	r5,0
8000b52c:	16 91       	mov	r1,r11
8000b52e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b532:	0a 92       	mov	r2,r5
8000b534:	fe b0 fc fe 	rcall	8000af30 <__sfp_lock_acquire>
8000b538:	3f f3       	mov	r3,-1
8000b53a:	c1 68       	rjmp	8000b566 <_fwalk+0x3e>
8000b53c:	6e 26       	ld.w	r6,r7[0x8]
8000b53e:	6e 14       	ld.w	r4,r7[0x4]
8000b540:	2f 46       	sub	r6,-12
8000b542:	c0 c8       	rjmp	8000b55a <_fwalk+0x32>
8000b544:	8c 08       	ld.sh	r8,r6[0x0]
8000b546:	e4 08 19 00 	cp.h	r8,r2
8000b54a:	c0 70       	breq	8000b558 <_fwalk+0x30>
8000b54c:	8c 18       	ld.sh	r8,r6[0x2]
8000b54e:	e6 08 19 00 	cp.h	r8,r3
8000b552:	c0 30       	breq	8000b558 <_fwalk+0x30>
8000b554:	5d 11       	icall	r1
8000b556:	18 45       	or	r5,r12
8000b558:	2a 46       	sub	r6,-92
8000b55a:	20 14       	sub	r4,1
8000b55c:	ec cc 00 0c 	sub	r12,r6,12
8000b560:	58 04       	cp.w	r4,0
8000b562:	cf 14       	brge	8000b544 <_fwalk+0x1c>
8000b564:	6e 07       	ld.w	r7,r7[0x0]
8000b566:	58 07       	cp.w	r7,0
8000b568:	ce a1       	brne	8000b53c <_fwalk+0x14>
8000b56a:	fe b0 fc e4 	rcall	8000af32 <__sfp_lock_release>
8000b56e:	0a 9c       	mov	r12,r5
8000b570:	d8 32       	popm	r0-r7,pc
8000b572:	d7 03       	nop

8000b574 <_localeconv_r>:
8000b574:	fe cc d3 fc 	sub	r12,pc,-11268
8000b578:	5e fc       	retal	r12
8000b57a:	d7 03       	nop

8000b57c <__smakebuf_r>:
8000b57c:	d4 21       	pushm	r4-r7,lr
8000b57e:	20 fd       	sub	sp,60
8000b580:	96 68       	ld.sh	r8,r11[0xc]
8000b582:	16 97       	mov	r7,r11
8000b584:	18 96       	mov	r6,r12
8000b586:	e2 18 00 02 	andl	r8,0x2,COH
8000b58a:	c3 d1       	brne	8000b604 <__smakebuf_r+0x88>
8000b58c:	96 7b       	ld.sh	r11,r11[0xe]
8000b58e:	f0 0b 19 00 	cp.h	r11,r8
8000b592:	c0 55       	brlt	8000b59c <__smakebuf_r+0x20>
8000b594:	1a 9a       	mov	r10,sp
8000b596:	e0 a0 04 81 	rcall	8000be98 <_fstat_r>
8000b59a:	c0 f4       	brge	8000b5b8 <__smakebuf_r+0x3c>
8000b59c:	8e 65       	ld.sh	r5,r7[0xc]
8000b59e:	0a 98       	mov	r8,r5
8000b5a0:	ab b8       	sbr	r8,0xb
8000b5a2:	e2 15 00 80 	andl	r5,0x80,COH
8000b5a6:	ae 68       	st.h	r7[0xc],r8
8000b5a8:	30 04       	mov	r4,0
8000b5aa:	e0 68 04 00 	mov	r8,1024
8000b5ae:	f9 b5 01 40 	movne	r5,64
8000b5b2:	f0 05 17 00 	moveq	r5,r8
8000b5b6:	c1 c8       	rjmp	8000b5ee <__smakebuf_r+0x72>
8000b5b8:	40 18       	lddsp	r8,sp[0x4]
8000b5ba:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b5be:	e0 48 20 00 	cp.w	r8,8192
8000b5c2:	5f 04       	sreq	r4
8000b5c4:	e0 48 80 00 	cp.w	r8,32768
8000b5c8:	c0 e1       	brne	8000b5e4 <__smakebuf_r+0x68>
8000b5ca:	6e b9       	ld.w	r9,r7[0x2c]
8000b5cc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b5d0:	10 39       	cp.w	r9,r8
8000b5d2:	c0 91       	brne	8000b5e4 <__smakebuf_r+0x68>
8000b5d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b5d6:	e0 65 04 00 	mov	r5,1024
8000b5da:	ab a8       	sbr	r8,0xa
8000b5dc:	ef 45 00 50 	st.w	r7[80],r5
8000b5e0:	ae 68       	st.h	r7[0xc],r8
8000b5e2:	c0 68       	rjmp	8000b5ee <__smakebuf_r+0x72>
8000b5e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b5e6:	e0 65 04 00 	mov	r5,1024
8000b5ea:	ab b8       	sbr	r8,0xb
8000b5ec:	ae 68       	st.h	r7[0xc],r8
8000b5ee:	0a 9b       	mov	r11,r5
8000b5f0:	0c 9c       	mov	r12,r6
8000b5f2:	fe b0 df 35 	rcall	8000745c <_malloc_r>
8000b5f6:	8e 68       	ld.sh	r8,r7[0xc]
8000b5f8:	c0 d1       	brne	8000b612 <__smakebuf_r+0x96>
8000b5fa:	ed b8 00 09 	bld	r8,0x9
8000b5fe:	c1 b0       	breq	8000b634 <__smakebuf_r+0xb8>
8000b600:	a1 b8       	sbr	r8,0x1
8000b602:	ae 68       	st.h	r7[0xc],r8
8000b604:	ee c8 ff b9 	sub	r8,r7,-71
8000b608:	8f 48       	st.w	r7[0x10],r8
8000b60a:	8f 08       	st.w	r7[0x0],r8
8000b60c:	30 18       	mov	r8,1
8000b60e:	8f 58       	st.w	r7[0x14],r8
8000b610:	c1 28       	rjmp	8000b634 <__smakebuf_r+0xb8>
8000b612:	a7 b8       	sbr	r8,0x7
8000b614:	8f 4c       	st.w	r7[0x10],r12
8000b616:	ae 68       	st.h	r7[0xc],r8
8000b618:	8f 55       	st.w	r7[0x14],r5
8000b61a:	fe c8 06 e6 	sub	r8,pc,1766
8000b61e:	8f 0c       	st.w	r7[0x0],r12
8000b620:	8d a8       	st.w	r6[0x28],r8
8000b622:	58 04       	cp.w	r4,0
8000b624:	c0 80       	breq	8000b634 <__smakebuf_r+0xb8>
8000b626:	8e 7c       	ld.sh	r12,r7[0xe]
8000b628:	fe b0 e3 94 	rcall	80007d50 <isatty>
8000b62c:	c0 40       	breq	8000b634 <__smakebuf_r+0xb8>
8000b62e:	8e 68       	ld.sh	r8,r7[0xc]
8000b630:	a1 a8       	sbr	r8,0x0
8000b632:	ae 68       	st.h	r7[0xc],r8
8000b634:	2f 1d       	sub	sp,-60
8000b636:	d8 22       	popm	r4-r7,pc

8000b638 <memchr>:
8000b638:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b63c:	c0 68       	rjmp	8000b648 <memchr+0x10>
8000b63e:	20 1a       	sub	r10,1
8000b640:	19 88       	ld.ub	r8,r12[0x0]
8000b642:	16 38       	cp.w	r8,r11
8000b644:	5e 0c       	reteq	r12
8000b646:	2f fc       	sub	r12,-1
8000b648:	58 0a       	cp.w	r10,0
8000b64a:	cf a1       	brne	8000b63e <memchr+0x6>
8000b64c:	5e fa       	retal	r10

8000b64e <memmove>:
8000b64e:	d4 01       	pushm	lr
8000b650:	18 3b       	cp.w	r11,r12
8000b652:	c1 92       	brcc	8000b684 <memmove+0x36>
8000b654:	f6 0a 00 09 	add	r9,r11,r10
8000b658:	12 3c       	cp.w	r12,r9
8000b65a:	c1 52       	brcc	8000b684 <memmove+0x36>
8000b65c:	f8 0a 00 0b 	add	r11,r12,r10
8000b660:	30 08       	mov	r8,0
8000b662:	c0 68       	rjmp	8000b66e <memmove+0x20>
8000b664:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b668:	20 1a       	sub	r10,1
8000b66a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b66e:	20 18       	sub	r8,1
8000b670:	58 0a       	cp.w	r10,0
8000b672:	cf 91       	brne	8000b664 <memmove+0x16>
8000b674:	d8 02       	popm	pc
8000b676:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b67a:	20 1a       	sub	r10,1
8000b67c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b680:	2f f8       	sub	r8,-1
8000b682:	c0 28       	rjmp	8000b686 <memmove+0x38>
8000b684:	30 08       	mov	r8,0
8000b686:	58 0a       	cp.w	r10,0
8000b688:	cf 71       	brne	8000b676 <memmove+0x28>
8000b68a:	d8 02       	popm	pc

8000b68c <__hi0bits>:
8000b68c:	18 98       	mov	r8,r12
8000b68e:	e0 1c 00 00 	andl	r12,0x0
8000b692:	f0 09 15 10 	lsl	r9,r8,0x10
8000b696:	58 0c       	cp.w	r12,0
8000b698:	f2 08 17 00 	moveq	r8,r9
8000b69c:	f9 bc 00 10 	moveq	r12,16
8000b6a0:	f9 bc 01 00 	movne	r12,0
8000b6a4:	10 9a       	mov	r10,r8
8000b6a6:	f0 09 15 08 	lsl	r9,r8,0x8
8000b6aa:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b6ae:	f7 bc 00 f8 	subeq	r12,-8
8000b6b2:	f2 08 17 00 	moveq	r8,r9
8000b6b6:	10 9a       	mov	r10,r8
8000b6b8:	f0 09 15 04 	lsl	r9,r8,0x4
8000b6bc:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b6c0:	f7 bc 00 fc 	subeq	r12,-4
8000b6c4:	f2 08 17 00 	moveq	r8,r9
8000b6c8:	10 9a       	mov	r10,r8
8000b6ca:	f0 09 15 02 	lsl	r9,r8,0x2
8000b6ce:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b6d2:	f7 bc 00 fe 	subeq	r12,-2
8000b6d6:	f2 08 17 00 	moveq	r8,r9
8000b6da:	58 08       	cp.w	r8,0
8000b6dc:	5e 5c       	retlt	r12
8000b6de:	ed b8 00 1e 	bld	r8,0x1e
8000b6e2:	f9 bc 01 20 	movne	r12,32
8000b6e6:	f7 bc 00 ff 	subeq	r12,-1
8000b6ea:	5e fc       	retal	r12

8000b6ec <__lo0bits>:
8000b6ec:	18 99       	mov	r9,r12
8000b6ee:	78 08       	ld.w	r8,r12[0x0]
8000b6f0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6f4:	c1 50       	breq	8000b71e <__lo0bits+0x32>
8000b6f6:	ed b8 00 00 	bld	r8,0x0
8000b6fa:	c0 21       	brne	8000b6fe <__lo0bits+0x12>
8000b6fc:	5e fd       	retal	0
8000b6fe:	10 9b       	mov	r11,r8
8000b700:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b704:	e2 1b 00 02 	andl	r11,0x2,COH
8000b708:	a3 88       	lsr	r8,0x2
8000b70a:	58 0b       	cp.w	r11,0
8000b70c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b710:	f9 bc 01 01 	movne	r12,1
8000b714:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b718:	f9 bc 00 02 	moveq	r12,2
8000b71c:	5e fc       	retal	r12
8000b71e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b722:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b726:	58 0a       	cp.w	r10,0
8000b728:	f6 08 17 00 	moveq	r8,r11
8000b72c:	f9 bc 00 10 	moveq	r12,16
8000b730:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b734:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b738:	58 0b       	cp.w	r11,0
8000b73a:	f7 bc 00 f8 	subeq	r12,-8
8000b73e:	f4 08 17 00 	moveq	r8,r10
8000b742:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b746:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b74a:	58 0b       	cp.w	r11,0
8000b74c:	f7 bc 00 fc 	subeq	r12,-4
8000b750:	f4 08 17 00 	moveq	r8,r10
8000b754:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b758:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b75c:	58 0b       	cp.w	r11,0
8000b75e:	f7 bc 00 fe 	subeq	r12,-2
8000b762:	f4 08 17 00 	moveq	r8,r10
8000b766:	ed b8 00 00 	bld	r8,0x0
8000b76a:	c0 60       	breq	8000b776 <__lo0bits+0x8a>
8000b76c:	a1 98       	lsr	r8,0x1
8000b76e:	c0 31       	brne	8000b774 <__lo0bits+0x88>
8000b770:	32 0c       	mov	r12,32
8000b772:	5e fc       	retal	r12
8000b774:	2f fc       	sub	r12,-1
8000b776:	93 08       	st.w	r9[0x0],r8
8000b778:	5e fc       	retal	r12

8000b77a <__mcmp>:
8000b77a:	d4 01       	pushm	lr
8000b77c:	18 98       	mov	r8,r12
8000b77e:	76 49       	ld.w	r9,r11[0x10]
8000b780:	78 4c       	ld.w	r12,r12[0x10]
8000b782:	12 1c       	sub	r12,r9
8000b784:	c1 31       	brne	8000b7aa <__mcmp+0x30>
8000b786:	2f b9       	sub	r9,-5
8000b788:	a3 69       	lsl	r9,0x2
8000b78a:	12 0b       	add	r11,r9
8000b78c:	f0 09 00 09 	add	r9,r8,r9
8000b790:	2e c8       	sub	r8,-20
8000b792:	13 4e       	ld.w	lr,--r9
8000b794:	17 4a       	ld.w	r10,--r11
8000b796:	14 3e       	cp.w	lr,r10
8000b798:	c0 60       	breq	8000b7a4 <__mcmp+0x2a>
8000b79a:	f9 bc 03 ff 	movlo	r12,-1
8000b79e:	f9 bc 02 01 	movhs	r12,1
8000b7a2:	d8 02       	popm	pc
8000b7a4:	10 39       	cp.w	r9,r8
8000b7a6:	fe 9b ff f6 	brhi	8000b792 <__mcmp+0x18>
8000b7aa:	d8 02       	popm	pc

8000b7ac <_Bfree>:
8000b7ac:	d4 21       	pushm	r4-r7,lr
8000b7ae:	18 97       	mov	r7,r12
8000b7b0:	16 95       	mov	r5,r11
8000b7b2:	78 96       	ld.w	r6,r12[0x24]
8000b7b4:	58 06       	cp.w	r6,0
8000b7b6:	c0 91       	brne	8000b7c8 <_Bfree+0x1c>
8000b7b8:	31 0c       	mov	r12,16
8000b7ba:	fe b0 de 49 	rcall	8000744c <malloc>
8000b7be:	99 36       	st.w	r12[0xc],r6
8000b7c0:	8f 9c       	st.w	r7[0x24],r12
8000b7c2:	99 16       	st.w	r12[0x4],r6
8000b7c4:	99 26       	st.w	r12[0x8],r6
8000b7c6:	99 06       	st.w	r12[0x0],r6
8000b7c8:	58 05       	cp.w	r5,0
8000b7ca:	c0 90       	breq	8000b7dc <_Bfree+0x30>
8000b7cc:	6a 19       	ld.w	r9,r5[0x4]
8000b7ce:	6e 98       	ld.w	r8,r7[0x24]
8000b7d0:	70 38       	ld.w	r8,r8[0xc]
8000b7d2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b7d6:	8b 0a       	st.w	r5[0x0],r10
8000b7d8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b7dc:	d8 22       	popm	r4-r7,pc
8000b7de:	d7 03       	nop

8000b7e0 <_Balloc>:
8000b7e0:	d4 21       	pushm	r4-r7,lr
8000b7e2:	18 97       	mov	r7,r12
8000b7e4:	16 96       	mov	r6,r11
8000b7e6:	78 95       	ld.w	r5,r12[0x24]
8000b7e8:	58 05       	cp.w	r5,0
8000b7ea:	c0 91       	brne	8000b7fc <_Balloc+0x1c>
8000b7ec:	31 0c       	mov	r12,16
8000b7ee:	fe b0 de 2f 	rcall	8000744c <malloc>
8000b7f2:	99 35       	st.w	r12[0xc],r5
8000b7f4:	8f 9c       	st.w	r7[0x24],r12
8000b7f6:	99 15       	st.w	r12[0x4],r5
8000b7f8:	99 25       	st.w	r12[0x8],r5
8000b7fa:	99 05       	st.w	r12[0x0],r5
8000b7fc:	6e 95       	ld.w	r5,r7[0x24]
8000b7fe:	6a 38       	ld.w	r8,r5[0xc]
8000b800:	58 08       	cp.w	r8,0
8000b802:	c0 b1       	brne	8000b818 <_Balloc+0x38>
8000b804:	31 0a       	mov	r10,16
8000b806:	30 4b       	mov	r11,4
8000b808:	0e 9c       	mov	r12,r7
8000b80a:	e0 a0 02 a7 	rcall	8000bd58 <_calloc_r>
8000b80e:	8b 3c       	st.w	r5[0xc],r12
8000b810:	6e 98       	ld.w	r8,r7[0x24]
8000b812:	70 3c       	ld.w	r12,r8[0xc]
8000b814:	58 0c       	cp.w	r12,0
8000b816:	c1 b0       	breq	8000b84c <_Balloc+0x6c>
8000b818:	6e 98       	ld.w	r8,r7[0x24]
8000b81a:	70 38       	ld.w	r8,r8[0xc]
8000b81c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b820:	70 0c       	ld.w	r12,r8[0x0]
8000b822:	58 0c       	cp.w	r12,0
8000b824:	c0 40       	breq	8000b82c <_Balloc+0x4c>
8000b826:	78 09       	ld.w	r9,r12[0x0]
8000b828:	91 09       	st.w	r8[0x0],r9
8000b82a:	c0 e8       	rjmp	8000b846 <_Balloc+0x66>
8000b82c:	0e 9c       	mov	r12,r7
8000b82e:	30 17       	mov	r7,1
8000b830:	0e 9b       	mov	r11,r7
8000b832:	ee 06 09 47 	lsl	r7,r7,r6
8000b836:	ee ca ff fb 	sub	r10,r7,-5
8000b83a:	a3 6a       	lsl	r10,0x2
8000b83c:	e0 a0 02 8e 	rcall	8000bd58 <_calloc_r>
8000b840:	c0 60       	breq	8000b84c <_Balloc+0x6c>
8000b842:	99 16       	st.w	r12[0x4],r6
8000b844:	99 27       	st.w	r12[0x8],r7
8000b846:	30 08       	mov	r8,0
8000b848:	99 38       	st.w	r12[0xc],r8
8000b84a:	99 48       	st.w	r12[0x10],r8
8000b84c:	d8 22       	popm	r4-r7,pc
8000b84e:	d7 03       	nop

8000b850 <__d2b>:
8000b850:	d4 31       	pushm	r0-r7,lr
8000b852:	20 2d       	sub	sp,8
8000b854:	16 93       	mov	r3,r11
8000b856:	12 96       	mov	r6,r9
8000b858:	10 95       	mov	r5,r8
8000b85a:	14 92       	mov	r2,r10
8000b85c:	30 1b       	mov	r11,1
8000b85e:	cc 1f       	rcall	8000b7e0 <_Balloc>
8000b860:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b864:	50 09       	stdsp	sp[0x0],r9
8000b866:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b86a:	b5 a9       	sbr	r9,0x14
8000b86c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b870:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b874:	18 94       	mov	r4,r12
8000b876:	58 02       	cp.w	r2,0
8000b878:	c1 d0       	breq	8000b8b2 <__d2b+0x62>
8000b87a:	fa cc ff f8 	sub	r12,sp,-8
8000b87e:	18 d2       	st.w	--r12,r2
8000b880:	c3 6f       	rcall	8000b6ec <__lo0bits>
8000b882:	40 18       	lddsp	r8,sp[0x4]
8000b884:	c0 d0       	breq	8000b89e <__d2b+0x4e>
8000b886:	40 09       	lddsp	r9,sp[0x0]
8000b888:	f8 0a 11 20 	rsub	r10,r12,32
8000b88c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b890:	f5 e8 10 08 	or	r8,r10,r8
8000b894:	89 58       	st.w	r4[0x14],r8
8000b896:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b89a:	50 09       	stdsp	sp[0x0],r9
8000b89c:	c0 28       	rjmp	8000b8a0 <__d2b+0x50>
8000b89e:	89 58       	st.w	r4[0x14],r8
8000b8a0:	40 08       	lddsp	r8,sp[0x0]
8000b8a2:	58 08       	cp.w	r8,0
8000b8a4:	f9 b3 01 02 	movne	r3,2
8000b8a8:	f9 b3 00 01 	moveq	r3,1
8000b8ac:	89 68       	st.w	r4[0x18],r8
8000b8ae:	89 43       	st.w	r4[0x10],r3
8000b8b0:	c0 88       	rjmp	8000b8c0 <__d2b+0x70>
8000b8b2:	1a 9c       	mov	r12,sp
8000b8b4:	c1 cf       	rcall	8000b6ec <__lo0bits>
8000b8b6:	30 13       	mov	r3,1
8000b8b8:	40 08       	lddsp	r8,sp[0x0]
8000b8ba:	2e 0c       	sub	r12,-32
8000b8bc:	89 43       	st.w	r4[0x10],r3
8000b8be:	89 58       	st.w	r4[0x14],r8
8000b8c0:	58 01       	cp.w	r1,0
8000b8c2:	c0 90       	breq	8000b8d4 <__d2b+0x84>
8000b8c4:	e2 c1 04 33 	sub	r1,r1,1075
8000b8c8:	18 01       	add	r1,r12
8000b8ca:	8d 01       	st.w	r6[0x0],r1
8000b8cc:	f8 0c 11 35 	rsub	r12,r12,53
8000b8d0:	8b 0c       	st.w	r5[0x0],r12
8000b8d2:	c0 c8       	rjmp	8000b8ea <__d2b+0x9a>
8000b8d4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b8d8:	f8 cc 04 32 	sub	r12,r12,1074
8000b8dc:	a5 73       	lsl	r3,0x5
8000b8de:	8d 0c       	st.w	r6[0x0],r12
8000b8e0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b8e4:	cd 4e       	rcall	8000b68c <__hi0bits>
8000b8e6:	18 13       	sub	r3,r12
8000b8e8:	8b 03       	st.w	r5[0x0],r3
8000b8ea:	08 9c       	mov	r12,r4
8000b8ec:	2f ed       	sub	sp,-8
8000b8ee:	d8 32       	popm	r0-r7,pc

8000b8f0 <__mdiff>:
8000b8f0:	d4 31       	pushm	r0-r7,lr
8000b8f2:	74 48       	ld.w	r8,r10[0x10]
8000b8f4:	76 45       	ld.w	r5,r11[0x10]
8000b8f6:	16 97       	mov	r7,r11
8000b8f8:	14 96       	mov	r6,r10
8000b8fa:	10 15       	sub	r5,r8
8000b8fc:	c1 31       	brne	8000b922 <__mdiff+0x32>
8000b8fe:	2f b8       	sub	r8,-5
8000b900:	ee ce ff ec 	sub	lr,r7,-20
8000b904:	a3 68       	lsl	r8,0x2
8000b906:	f4 08 00 0b 	add	r11,r10,r8
8000b90a:	ee 08 00 08 	add	r8,r7,r8
8000b90e:	11 4a       	ld.w	r10,--r8
8000b910:	17 49       	ld.w	r9,--r11
8000b912:	12 3a       	cp.w	r10,r9
8000b914:	c0 30       	breq	8000b91a <__mdiff+0x2a>
8000b916:	c0 e2       	brcc	8000b932 <__mdiff+0x42>
8000b918:	c0 78       	rjmp	8000b926 <__mdiff+0x36>
8000b91a:	1c 38       	cp.w	r8,lr
8000b91c:	fe 9b ff f9 	brhi	8000b90e <__mdiff+0x1e>
8000b920:	c4 98       	rjmp	8000b9b2 <__mdiff+0xc2>
8000b922:	58 05       	cp.w	r5,0
8000b924:	c0 64       	brge	8000b930 <__mdiff+0x40>
8000b926:	0e 98       	mov	r8,r7
8000b928:	30 15       	mov	r5,1
8000b92a:	0c 97       	mov	r7,r6
8000b92c:	10 96       	mov	r6,r8
8000b92e:	c0 28       	rjmp	8000b932 <__mdiff+0x42>
8000b930:	30 05       	mov	r5,0
8000b932:	6e 1b       	ld.w	r11,r7[0x4]
8000b934:	c5 6f       	rcall	8000b7e0 <_Balloc>
8000b936:	6e 49       	ld.w	r9,r7[0x10]
8000b938:	6c 44       	ld.w	r4,r6[0x10]
8000b93a:	99 35       	st.w	r12[0xc],r5
8000b93c:	2f b4       	sub	r4,-5
8000b93e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b942:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b946:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b94a:	2e c6       	sub	r6,-20
8000b94c:	2e c7       	sub	r7,-20
8000b94e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b952:	30 0a       	mov	r10,0
8000b954:	0f 0e       	ld.w	lr,r7++
8000b956:	0d 0b       	ld.w	r11,r6++
8000b958:	fc 02 16 10 	lsr	r2,lr,0x10
8000b95c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b960:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b964:	e4 03 01 03 	sub	r3,r2,r3
8000b968:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b96c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b970:	f6 0a 00 0a 	add	r10,r11,r10
8000b974:	b0 1a       	st.h	r8[0x2],r10
8000b976:	b1 4a       	asr	r10,0x10
8000b978:	e6 0a 00 0a 	add	r10,r3,r10
8000b97c:	b0 0a       	st.h	r8[0x0],r10
8000b97e:	2f c8       	sub	r8,-4
8000b980:	b1 4a       	asr	r10,0x10
8000b982:	08 36       	cp.w	r6,r4
8000b984:	ce 83       	brcs	8000b954 <__mdiff+0x64>
8000b986:	c0 d8       	rjmp	8000b9a0 <__mdiff+0xb0>
8000b988:	0f 0b       	ld.w	r11,r7++
8000b98a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b98e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b992:	16 0a       	add	r10,r11
8000b994:	b0 1a       	st.h	r8[0x2],r10
8000b996:	b1 4a       	asr	r10,0x10
8000b998:	1c 0a       	add	r10,lr
8000b99a:	b0 0a       	st.h	r8[0x0],r10
8000b99c:	2f c8       	sub	r8,-4
8000b99e:	b1 4a       	asr	r10,0x10
8000b9a0:	0a 37       	cp.w	r7,r5
8000b9a2:	cf 33       	brcs	8000b988 <__mdiff+0x98>
8000b9a4:	c0 28       	rjmp	8000b9a8 <__mdiff+0xb8>
8000b9a6:	20 19       	sub	r9,1
8000b9a8:	11 4a       	ld.w	r10,--r8
8000b9aa:	58 0a       	cp.w	r10,0
8000b9ac:	cf d0       	breq	8000b9a6 <__mdiff+0xb6>
8000b9ae:	99 49       	st.w	r12[0x10],r9
8000b9b0:	d8 32       	popm	r0-r7,pc
8000b9b2:	30 0b       	mov	r11,0
8000b9b4:	c1 6f       	rcall	8000b7e0 <_Balloc>
8000b9b6:	30 18       	mov	r8,1
8000b9b8:	99 48       	st.w	r12[0x10],r8
8000b9ba:	30 08       	mov	r8,0
8000b9bc:	99 58       	st.w	r12[0x14],r8
8000b9be:	d8 32       	popm	r0-r7,pc

8000b9c0 <__lshift>:
8000b9c0:	d4 31       	pushm	r0-r7,lr
8000b9c2:	16 97       	mov	r7,r11
8000b9c4:	76 46       	ld.w	r6,r11[0x10]
8000b9c6:	f4 02 14 05 	asr	r2,r10,0x5
8000b9ca:	2f f6       	sub	r6,-1
8000b9cc:	14 93       	mov	r3,r10
8000b9ce:	18 94       	mov	r4,r12
8000b9d0:	04 06       	add	r6,r2
8000b9d2:	76 1b       	ld.w	r11,r11[0x4]
8000b9d4:	6e 28       	ld.w	r8,r7[0x8]
8000b9d6:	c0 38       	rjmp	8000b9dc <__lshift+0x1c>
8000b9d8:	2f fb       	sub	r11,-1
8000b9da:	a1 78       	lsl	r8,0x1
8000b9dc:	10 36       	cp.w	r6,r8
8000b9de:	fe 99 ff fd 	brgt	8000b9d8 <__lshift+0x18>
8000b9e2:	08 9c       	mov	r12,r4
8000b9e4:	cf ee       	rcall	8000b7e0 <_Balloc>
8000b9e6:	30 09       	mov	r9,0
8000b9e8:	18 95       	mov	r5,r12
8000b9ea:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9ee:	12 9a       	mov	r10,r9
8000b9f0:	c0 38       	rjmp	8000b9f6 <__lshift+0x36>
8000b9f2:	10 aa       	st.w	r8++,r10
8000b9f4:	2f f9       	sub	r9,-1
8000b9f6:	04 39       	cp.w	r9,r2
8000b9f8:	cf d5       	brlt	8000b9f2 <__lshift+0x32>
8000b9fa:	6e 4b       	ld.w	r11,r7[0x10]
8000b9fc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ba00:	2f bb       	sub	r11,-5
8000ba02:	ee c9 ff ec 	sub	r9,r7,-20
8000ba06:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ba0a:	58 03       	cp.w	r3,0
8000ba0c:	c1 30       	breq	8000ba32 <__lshift+0x72>
8000ba0e:	e6 0c 11 20 	rsub	r12,r3,32
8000ba12:	30 0a       	mov	r10,0
8000ba14:	72 02       	ld.w	r2,r9[0x0]
8000ba16:	e4 03 09 42 	lsl	r2,r2,r3
8000ba1a:	04 4a       	or	r10,r2
8000ba1c:	10 aa       	st.w	r8++,r10
8000ba1e:	13 0a       	ld.w	r10,r9++
8000ba20:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba24:	16 39       	cp.w	r9,r11
8000ba26:	cf 73       	brcs	8000ba14 <__lshift+0x54>
8000ba28:	91 0a       	st.w	r8[0x0],r10
8000ba2a:	58 0a       	cp.w	r10,0
8000ba2c:	c0 70       	breq	8000ba3a <__lshift+0x7a>
8000ba2e:	2f f6       	sub	r6,-1
8000ba30:	c0 58       	rjmp	8000ba3a <__lshift+0x7a>
8000ba32:	13 0a       	ld.w	r10,r9++
8000ba34:	10 aa       	st.w	r8++,r10
8000ba36:	16 39       	cp.w	r9,r11
8000ba38:	cf d3       	brcs	8000ba32 <__lshift+0x72>
8000ba3a:	08 9c       	mov	r12,r4
8000ba3c:	20 16       	sub	r6,1
8000ba3e:	0e 9b       	mov	r11,r7
8000ba40:	8b 46       	st.w	r5[0x10],r6
8000ba42:	cb 5e       	rcall	8000b7ac <_Bfree>
8000ba44:	0a 9c       	mov	r12,r5
8000ba46:	d8 32       	popm	r0-r7,pc

8000ba48 <__multiply>:
8000ba48:	d4 31       	pushm	r0-r7,lr
8000ba4a:	20 2d       	sub	sp,8
8000ba4c:	76 49       	ld.w	r9,r11[0x10]
8000ba4e:	74 48       	ld.w	r8,r10[0x10]
8000ba50:	16 96       	mov	r6,r11
8000ba52:	14 95       	mov	r5,r10
8000ba54:	10 39       	cp.w	r9,r8
8000ba56:	ec 08 17 50 	movlt	r8,r6
8000ba5a:	ea 06 17 50 	movlt	r6,r5
8000ba5e:	f0 05 17 50 	movlt	r5,r8
8000ba62:	6c 28       	ld.w	r8,r6[0x8]
8000ba64:	76 43       	ld.w	r3,r11[0x10]
8000ba66:	74 42       	ld.w	r2,r10[0x10]
8000ba68:	76 1b       	ld.w	r11,r11[0x4]
8000ba6a:	e4 03 00 07 	add	r7,r2,r3
8000ba6e:	10 37       	cp.w	r7,r8
8000ba70:	f7 bb 09 ff 	subgt	r11,-1
8000ba74:	cb 6e       	rcall	8000b7e0 <_Balloc>
8000ba76:	ee c4 ff fb 	sub	r4,r7,-5
8000ba7a:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba7e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba82:	30 0a       	mov	r10,0
8000ba84:	12 98       	mov	r8,r9
8000ba86:	c0 28       	rjmp	8000ba8a <__multiply+0x42>
8000ba88:	10 aa       	st.w	r8++,r10
8000ba8a:	08 38       	cp.w	r8,r4
8000ba8c:	cf e3       	brcs	8000ba88 <__multiply+0x40>
8000ba8e:	2f b3       	sub	r3,-5
8000ba90:	2f b2       	sub	r2,-5
8000ba92:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba96:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba9a:	ec cb ff ec 	sub	r11,r6,-20
8000ba9e:	50 12       	stdsp	sp[0x4],r2
8000baa0:	ea ca ff ec 	sub	r10,r5,-20
8000baa4:	c4 48       	rjmp	8000bb2c <__multiply+0xe4>
8000baa6:	94 95       	ld.uh	r5,r10[0x2]
8000baa8:	58 05       	cp.w	r5,0
8000baaa:	c2 00       	breq	8000baea <__multiply+0xa2>
8000baac:	12 98       	mov	r8,r9
8000baae:	16 96       	mov	r6,r11
8000bab0:	30 0e       	mov	lr,0
8000bab2:	50 09       	stdsp	sp[0x0],r9
8000bab4:	0d 02       	ld.w	r2,r6++
8000bab6:	e4 00 16 10 	lsr	r0,r2,0x10
8000baba:	70 01       	ld.w	r1,r8[0x0]
8000babc:	70 09       	ld.w	r9,r8[0x0]
8000babe:	b1 81       	lsr	r1,0x10
8000bac0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bac4:	e0 05 03 41 	mac	r1,r0,r5
8000bac8:	ab 32       	mul	r2,r5
8000baca:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bace:	00 02       	add	r2,r0
8000bad0:	e4 0e 00 0e 	add	lr,r2,lr
8000bad4:	b0 1e       	st.h	r8[0x2],lr
8000bad6:	b1 8e       	lsr	lr,0x10
8000bad8:	1c 01       	add	r1,lr
8000bada:	b0 01       	st.h	r8[0x0],r1
8000badc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bae0:	2f c8       	sub	r8,-4
8000bae2:	06 36       	cp.w	r6,r3
8000bae4:	ce 83       	brcs	8000bab4 <__multiply+0x6c>
8000bae6:	40 09       	lddsp	r9,sp[0x0]
8000bae8:	91 0e       	st.w	r8[0x0],lr
8000baea:	94 86       	ld.uh	r6,r10[0x0]
8000baec:	58 06       	cp.w	r6,0
8000baee:	c1 d0       	breq	8000bb28 <__multiply+0xe0>
8000baf0:	72 02       	ld.w	r2,r9[0x0]
8000baf2:	12 98       	mov	r8,r9
8000baf4:	16 9e       	mov	lr,r11
8000baf6:	30 05       	mov	r5,0
8000baf8:	b0 12       	st.h	r8[0x2],r2
8000bafa:	1d 01       	ld.w	r1,lr++
8000bafc:	90 82       	ld.uh	r2,r8[0x0]
8000bafe:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bb02:	ad 30       	mul	r0,r6
8000bb04:	e0 02 00 02 	add	r2,r0,r2
8000bb08:	e4 05 00 05 	add	r5,r2,r5
8000bb0c:	b0 05       	st.h	r8[0x0],r5
8000bb0e:	b1 85       	lsr	r5,0x10
8000bb10:	b1 81       	lsr	r1,0x10
8000bb12:	2f c8       	sub	r8,-4
8000bb14:	ad 31       	mul	r1,r6
8000bb16:	90 92       	ld.uh	r2,r8[0x2]
8000bb18:	e2 02 00 02 	add	r2,r1,r2
8000bb1c:	0a 02       	add	r2,r5
8000bb1e:	e4 05 16 10 	lsr	r5,r2,0x10
8000bb22:	06 3e       	cp.w	lr,r3
8000bb24:	ce a3       	brcs	8000baf8 <__multiply+0xb0>
8000bb26:	91 02       	st.w	r8[0x0],r2
8000bb28:	2f ca       	sub	r10,-4
8000bb2a:	2f c9       	sub	r9,-4
8000bb2c:	40 18       	lddsp	r8,sp[0x4]
8000bb2e:	10 3a       	cp.w	r10,r8
8000bb30:	cb b3       	brcs	8000baa6 <__multiply+0x5e>
8000bb32:	c0 28       	rjmp	8000bb36 <__multiply+0xee>
8000bb34:	20 17       	sub	r7,1
8000bb36:	58 07       	cp.w	r7,0
8000bb38:	e0 8a 00 05 	brle	8000bb42 <__multiply+0xfa>
8000bb3c:	09 48       	ld.w	r8,--r4
8000bb3e:	58 08       	cp.w	r8,0
8000bb40:	cf a0       	breq	8000bb34 <__multiply+0xec>
8000bb42:	99 47       	st.w	r12[0x10],r7
8000bb44:	2f ed       	sub	sp,-8
8000bb46:	d8 32       	popm	r0-r7,pc

8000bb48 <__i2b>:
8000bb48:	d4 21       	pushm	r4-r7,lr
8000bb4a:	16 97       	mov	r7,r11
8000bb4c:	30 1b       	mov	r11,1
8000bb4e:	c4 9e       	rcall	8000b7e0 <_Balloc>
8000bb50:	30 19       	mov	r9,1
8000bb52:	99 57       	st.w	r12[0x14],r7
8000bb54:	99 49       	st.w	r12[0x10],r9
8000bb56:	d8 22       	popm	r4-r7,pc

8000bb58 <__multadd>:
8000bb58:	d4 31       	pushm	r0-r7,lr
8000bb5a:	30 08       	mov	r8,0
8000bb5c:	12 95       	mov	r5,r9
8000bb5e:	16 97       	mov	r7,r11
8000bb60:	18 96       	mov	r6,r12
8000bb62:	76 44       	ld.w	r4,r11[0x10]
8000bb64:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb68:	72 0b       	ld.w	r11,r9[0x0]
8000bb6a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb6e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb72:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb76:	f4 0b 03 45 	mac	r5,r10,r11
8000bb7a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb7e:	b1 85       	lsr	r5,0x10
8000bb80:	18 05       	add	r5,r12
8000bb82:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb86:	f8 0b 00 0b 	add	r11,r12,r11
8000bb8a:	12 ab       	st.w	r9++,r11
8000bb8c:	2f f8       	sub	r8,-1
8000bb8e:	b1 85       	lsr	r5,0x10
8000bb90:	08 38       	cp.w	r8,r4
8000bb92:	ce b5       	brlt	8000bb68 <__multadd+0x10>
8000bb94:	58 05       	cp.w	r5,0
8000bb96:	c1 c0       	breq	8000bbce <__multadd+0x76>
8000bb98:	6e 28       	ld.w	r8,r7[0x8]
8000bb9a:	10 34       	cp.w	r4,r8
8000bb9c:	c1 35       	brlt	8000bbc2 <__multadd+0x6a>
8000bb9e:	6e 1b       	ld.w	r11,r7[0x4]
8000bba0:	0c 9c       	mov	r12,r6
8000bba2:	2f fb       	sub	r11,-1
8000bba4:	c1 ee       	rcall	8000b7e0 <_Balloc>
8000bba6:	6e 4a       	ld.w	r10,r7[0x10]
8000bba8:	ee cb ff f4 	sub	r11,r7,-12
8000bbac:	18 93       	mov	r3,r12
8000bbae:	2f ea       	sub	r10,-2
8000bbb0:	2f 4c       	sub	r12,-12
8000bbb2:	a3 6a       	lsl	r10,0x2
8000bbb4:	fe b0 de 70 	rcall	80007894 <memcpy>
8000bbb8:	0e 9b       	mov	r11,r7
8000bbba:	0c 9c       	mov	r12,r6
8000bbbc:	fe b0 fd f8 	rcall	8000b7ac <_Bfree>
8000bbc0:	06 97       	mov	r7,r3
8000bbc2:	e8 c8 ff ff 	sub	r8,r4,-1
8000bbc6:	2f b4       	sub	r4,-5
8000bbc8:	8f 48       	st.w	r7[0x10],r8
8000bbca:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bbce:	0e 9c       	mov	r12,r7
8000bbd0:	d8 32       	popm	r0-r7,pc
8000bbd2:	d7 03       	nop

8000bbd4 <__pow5mult>:
8000bbd4:	d4 31       	pushm	r0-r7,lr
8000bbd6:	14 96       	mov	r6,r10
8000bbd8:	18 97       	mov	r7,r12
8000bbda:	16 94       	mov	r4,r11
8000bbdc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bbe0:	c0 90       	breq	8000bbf2 <__pow5mult+0x1e>
8000bbe2:	20 18       	sub	r8,1
8000bbe4:	fe c9 da 30 	sub	r9,pc,-9680
8000bbe8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bbec:	30 09       	mov	r9,0
8000bbee:	cb 5f       	rcall	8000bb58 <__multadd>
8000bbf0:	18 94       	mov	r4,r12
8000bbf2:	a3 46       	asr	r6,0x2
8000bbf4:	c3 40       	breq	8000bc5c <__pow5mult+0x88>
8000bbf6:	6e 95       	ld.w	r5,r7[0x24]
8000bbf8:	58 05       	cp.w	r5,0
8000bbfa:	c0 91       	brne	8000bc0c <__pow5mult+0x38>
8000bbfc:	31 0c       	mov	r12,16
8000bbfe:	fe b0 dc 27 	rcall	8000744c <malloc>
8000bc02:	99 35       	st.w	r12[0xc],r5
8000bc04:	8f 9c       	st.w	r7[0x24],r12
8000bc06:	99 15       	st.w	r12[0x4],r5
8000bc08:	99 25       	st.w	r12[0x8],r5
8000bc0a:	99 05       	st.w	r12[0x0],r5
8000bc0c:	6e 93       	ld.w	r3,r7[0x24]
8000bc0e:	66 25       	ld.w	r5,r3[0x8]
8000bc10:	58 05       	cp.w	r5,0
8000bc12:	c0 c1       	brne	8000bc2a <__pow5mult+0x56>
8000bc14:	e0 6b 02 71 	mov	r11,625
8000bc18:	0e 9c       	mov	r12,r7
8000bc1a:	c9 7f       	rcall	8000bb48 <__i2b>
8000bc1c:	87 2c       	st.w	r3[0x8],r12
8000bc1e:	30 08       	mov	r8,0
8000bc20:	18 95       	mov	r5,r12
8000bc22:	99 08       	st.w	r12[0x0],r8
8000bc24:	c0 38       	rjmp	8000bc2a <__pow5mult+0x56>
8000bc26:	06 9c       	mov	r12,r3
8000bc28:	18 95       	mov	r5,r12
8000bc2a:	ed b6 00 00 	bld	r6,0x0
8000bc2e:	c0 b1       	brne	8000bc44 <__pow5mult+0x70>
8000bc30:	08 9b       	mov	r11,r4
8000bc32:	0a 9a       	mov	r10,r5
8000bc34:	0e 9c       	mov	r12,r7
8000bc36:	c0 9f       	rcall	8000ba48 <__multiply>
8000bc38:	08 9b       	mov	r11,r4
8000bc3a:	18 93       	mov	r3,r12
8000bc3c:	0e 9c       	mov	r12,r7
8000bc3e:	06 94       	mov	r4,r3
8000bc40:	fe b0 fd b6 	rcall	8000b7ac <_Bfree>
8000bc44:	a1 56       	asr	r6,0x1
8000bc46:	c0 b0       	breq	8000bc5c <__pow5mult+0x88>
8000bc48:	6a 03       	ld.w	r3,r5[0x0]
8000bc4a:	58 03       	cp.w	r3,0
8000bc4c:	ce d1       	brne	8000bc26 <__pow5mult+0x52>
8000bc4e:	0a 9a       	mov	r10,r5
8000bc50:	0a 9b       	mov	r11,r5
8000bc52:	0e 9c       	mov	r12,r7
8000bc54:	cf ae       	rcall	8000ba48 <__multiply>
8000bc56:	8b 0c       	st.w	r5[0x0],r12
8000bc58:	99 03       	st.w	r12[0x0],r3
8000bc5a:	ce 7b       	rjmp	8000bc28 <__pow5mult+0x54>
8000bc5c:	08 9c       	mov	r12,r4
8000bc5e:	d8 32       	popm	r0-r7,pc

8000bc60 <__isinfd>:
8000bc60:	14 98       	mov	r8,r10
8000bc62:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc66:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc6a:	f0 0b 11 00 	rsub	r11,r8,0
8000bc6e:	f7 e8 10 08 	or	r8,r11,r8
8000bc72:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc76:	f2 08 01 08 	sub	r8,r9,r8
8000bc7a:	f0 0c 11 00 	rsub	r12,r8,0
8000bc7e:	f9 e8 10 08 	or	r8,r12,r8
8000bc82:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc86:	2f fc       	sub	r12,-1
8000bc88:	5e fc       	retal	r12

8000bc8a <__isnand>:
8000bc8a:	14 98       	mov	r8,r10
8000bc8c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc90:	f0 0c 11 00 	rsub	r12,r8,0
8000bc94:	10 4c       	or	r12,r8
8000bc96:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc9a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc9e:	f0 0c 01 0c 	sub	r12,r8,r12
8000bca2:	bf 9c       	lsr	r12,0x1f
8000bca4:	5e fc       	retal	r12
8000bca6:	d7 03       	nop

8000bca8 <__sclose>:
8000bca8:	d4 01       	pushm	lr
8000bcaa:	96 7b       	ld.sh	r11,r11[0xe]
8000bcac:	c8 2c       	rcall	8000bdb0 <_close_r>
8000bcae:	d8 02       	popm	pc

8000bcb0 <__sseek>:
8000bcb0:	d4 21       	pushm	r4-r7,lr
8000bcb2:	16 97       	mov	r7,r11
8000bcb4:	96 7b       	ld.sh	r11,r11[0xe]
8000bcb6:	c0 3d       	rcall	8000bebc <_lseek_r>
8000bcb8:	8e 68       	ld.sh	r8,r7[0xc]
8000bcba:	10 99       	mov	r9,r8
8000bcbc:	ad c8       	cbr	r8,0xc
8000bcbe:	ad a9       	sbr	r9,0xc
8000bcc0:	5b fc       	cp.w	r12,-1
8000bcc2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bcc6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bcca:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bcce:	d8 22       	popm	r4-r7,pc

8000bcd0 <__swrite>:
8000bcd0:	d4 21       	pushm	r4-r7,lr
8000bcd2:	96 68       	ld.sh	r8,r11[0xc]
8000bcd4:	16 97       	mov	r7,r11
8000bcd6:	14 95       	mov	r5,r10
8000bcd8:	12 94       	mov	r4,r9
8000bcda:	e2 18 01 00 	andl	r8,0x100,COH
8000bcde:	18 96       	mov	r6,r12
8000bce0:	c0 50       	breq	8000bcea <__swrite+0x1a>
8000bce2:	30 29       	mov	r9,2
8000bce4:	30 0a       	mov	r10,0
8000bce6:	96 7b       	ld.sh	r11,r11[0xe]
8000bce8:	ce ac       	rcall	8000bebc <_lseek_r>
8000bcea:	8e 68       	ld.sh	r8,r7[0xc]
8000bcec:	ad c8       	cbr	r8,0xc
8000bcee:	08 99       	mov	r9,r4
8000bcf0:	0a 9a       	mov	r10,r5
8000bcf2:	8e 7b       	ld.sh	r11,r7[0xe]
8000bcf4:	0c 9c       	mov	r12,r6
8000bcf6:	ae 68       	st.h	r7[0xc],r8
8000bcf8:	c1 cc       	rcall	8000bd30 <_write_r>
8000bcfa:	d8 22       	popm	r4-r7,pc

8000bcfc <__sread>:
8000bcfc:	d4 21       	pushm	r4-r7,lr
8000bcfe:	16 97       	mov	r7,r11
8000bd00:	96 7b       	ld.sh	r11,r11[0xe]
8000bd02:	cf 1c       	rcall	8000bee4 <_read_r>
8000bd04:	c0 65       	brlt	8000bd10 <__sread+0x14>
8000bd06:	6f 58       	ld.w	r8,r7[0x54]
8000bd08:	18 08       	add	r8,r12
8000bd0a:	ef 48 00 54 	st.w	r7[84],r8
8000bd0e:	d8 22       	popm	r4-r7,pc
8000bd10:	8e 68       	ld.sh	r8,r7[0xc]
8000bd12:	ad c8       	cbr	r8,0xc
8000bd14:	ae 68       	st.h	r7[0xc],r8
8000bd16:	d8 22       	popm	r4-r7,pc

8000bd18 <strlen>:
8000bd18:	30 09       	mov	r9,0
8000bd1a:	18 98       	mov	r8,r12
8000bd1c:	c0 28       	rjmp	8000bd20 <strlen+0x8>
8000bd1e:	2f f8       	sub	r8,-1
8000bd20:	11 8a       	ld.ub	r10,r8[0x0]
8000bd22:	f2 0a 18 00 	cp.b	r10,r9
8000bd26:	cf c1       	brne	8000bd1e <strlen+0x6>
8000bd28:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd2c:	5e fc       	retal	r12
8000bd2e:	d7 03       	nop

8000bd30 <_write_r>:
8000bd30:	d4 21       	pushm	r4-r7,lr
8000bd32:	16 98       	mov	r8,r11
8000bd34:	18 97       	mov	r7,r12
8000bd36:	10 9c       	mov	r12,r8
8000bd38:	30 08       	mov	r8,0
8000bd3a:	14 9b       	mov	r11,r10
8000bd3c:	e0 66 bf f8 	mov	r6,49144
8000bd40:	12 9a       	mov	r10,r9
8000bd42:	8d 08       	st.w	r6[0x0],r8
8000bd44:	fe b0 d1 72 	rcall	80006028 <_write>
8000bd48:	5b fc       	cp.w	r12,-1
8000bd4a:	c0 51       	brne	8000bd54 <_write_r+0x24>
8000bd4c:	6c 08       	ld.w	r8,r6[0x0]
8000bd4e:	58 08       	cp.w	r8,0
8000bd50:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd54:	d8 22       	popm	r4-r7,pc
8000bd56:	d7 03       	nop

8000bd58 <_calloc_r>:
8000bd58:	d4 21       	pushm	r4-r7,lr
8000bd5a:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd5e:	fe b0 db 7f 	rcall	8000745c <_malloc_r>
8000bd62:	18 97       	mov	r7,r12
8000bd64:	c2 30       	breq	8000bdaa <_calloc_r+0x52>
8000bd66:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd6a:	e0 1a ff fc 	andl	r10,0xfffc
8000bd6e:	20 4a       	sub	r10,4
8000bd70:	e0 4a 00 24 	cp.w	r10,36
8000bd74:	e0 8b 00 18 	brhi	8000bda4 <_calloc_r+0x4c>
8000bd78:	18 98       	mov	r8,r12
8000bd7a:	59 3a       	cp.w	r10,19
8000bd7c:	e0 88 00 0f 	brls	8000bd9a <_calloc_r+0x42>
8000bd80:	30 09       	mov	r9,0
8000bd82:	10 a9       	st.w	r8++,r9
8000bd84:	10 a9       	st.w	r8++,r9
8000bd86:	59 ba       	cp.w	r10,27
8000bd88:	e0 88 00 09 	brls	8000bd9a <_calloc_r+0x42>
8000bd8c:	10 a9       	st.w	r8++,r9
8000bd8e:	10 a9       	st.w	r8++,r9
8000bd90:	e0 4a 00 24 	cp.w	r10,36
8000bd94:	c0 31       	brne	8000bd9a <_calloc_r+0x42>
8000bd96:	10 a9       	st.w	r8++,r9
8000bd98:	10 a9       	st.w	r8++,r9
8000bd9a:	30 09       	mov	r9,0
8000bd9c:	10 a9       	st.w	r8++,r9
8000bd9e:	91 19       	st.w	r8[0x4],r9
8000bda0:	91 09       	st.w	r8[0x0],r9
8000bda2:	c0 48       	rjmp	8000bdaa <_calloc_r+0x52>
8000bda4:	30 0b       	mov	r11,0
8000bda6:	fe b0 de 1b 	rcall	800079dc <memset>
8000bdaa:	0e 9c       	mov	r12,r7
8000bdac:	d8 22       	popm	r4-r7,pc
8000bdae:	d7 03       	nop

8000bdb0 <_close_r>:
8000bdb0:	d4 21       	pushm	r4-r7,lr
8000bdb2:	30 08       	mov	r8,0
8000bdb4:	18 97       	mov	r7,r12
8000bdb6:	e0 66 bf f8 	mov	r6,49144
8000bdba:	16 9c       	mov	r12,r11
8000bdbc:	8d 08       	st.w	r6[0x0],r8
8000bdbe:	fe b0 df b5 	rcall	80007d28 <_close>
8000bdc2:	5b fc       	cp.w	r12,-1
8000bdc4:	c0 51       	brne	8000bdce <_close_r+0x1e>
8000bdc6:	6c 08       	ld.w	r8,r6[0x0]
8000bdc8:	58 08       	cp.w	r8,0
8000bdca:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdce:	d8 22       	popm	r4-r7,pc

8000bdd0 <_fclose_r>:
8000bdd0:	d4 21       	pushm	r4-r7,lr
8000bdd2:	18 96       	mov	r6,r12
8000bdd4:	16 97       	mov	r7,r11
8000bdd6:	58 0b       	cp.w	r11,0
8000bdd8:	c0 31       	brne	8000bdde <_fclose_r+0xe>
8000bdda:	16 95       	mov	r5,r11
8000bddc:	c5 38       	rjmp	8000be82 <_fclose_r+0xb2>
8000bdde:	fe b0 f8 a9 	rcall	8000af30 <__sfp_lock_acquire>
8000bde2:	58 06       	cp.w	r6,0
8000bde4:	c0 70       	breq	8000bdf2 <_fclose_r+0x22>
8000bde6:	6c 68       	ld.w	r8,r6[0x18]
8000bde8:	58 08       	cp.w	r8,0
8000bdea:	c0 41       	brne	8000bdf2 <_fclose_r+0x22>
8000bdec:	0c 9c       	mov	r12,r6
8000bdee:	fe b0 f8 f3 	rcall	8000afd4 <__sinit>
8000bdf2:	fe c8 dc e2 	sub	r8,pc,-8990
8000bdf6:	10 37       	cp.w	r7,r8
8000bdf8:	c0 31       	brne	8000bdfe <_fclose_r+0x2e>
8000bdfa:	6c 07       	ld.w	r7,r6[0x0]
8000bdfc:	c0 c8       	rjmp	8000be14 <_fclose_r+0x44>
8000bdfe:	fe c8 dc ce 	sub	r8,pc,-9010
8000be02:	10 37       	cp.w	r7,r8
8000be04:	c0 31       	brne	8000be0a <_fclose_r+0x3a>
8000be06:	6c 17       	ld.w	r7,r6[0x4]
8000be08:	c0 68       	rjmp	8000be14 <_fclose_r+0x44>
8000be0a:	fe c8 dc ba 	sub	r8,pc,-9030
8000be0e:	10 37       	cp.w	r7,r8
8000be10:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be14:	8e 69       	ld.sh	r9,r7[0xc]
8000be16:	30 08       	mov	r8,0
8000be18:	f0 09 19 00 	cp.h	r9,r8
8000be1c:	c0 51       	brne	8000be26 <_fclose_r+0x56>
8000be1e:	fe b0 f8 8a 	rcall	8000af32 <__sfp_lock_release>
8000be22:	30 05       	mov	r5,0
8000be24:	c2 f8       	rjmp	8000be82 <_fclose_r+0xb2>
8000be26:	0e 9b       	mov	r11,r7
8000be28:	0c 9c       	mov	r12,r6
8000be2a:	fe b0 f7 fd 	rcall	8000ae24 <_fflush_r>
8000be2e:	6e c8       	ld.w	r8,r7[0x30]
8000be30:	18 95       	mov	r5,r12
8000be32:	58 08       	cp.w	r8,0
8000be34:	c0 60       	breq	8000be40 <_fclose_r+0x70>
8000be36:	6e 8b       	ld.w	r11,r7[0x20]
8000be38:	0c 9c       	mov	r12,r6
8000be3a:	5d 18       	icall	r8
8000be3c:	f9 b5 05 ff 	movlt	r5,-1
8000be40:	8e 68       	ld.sh	r8,r7[0xc]
8000be42:	ed b8 00 07 	bld	r8,0x7
8000be46:	c0 51       	brne	8000be50 <_fclose_r+0x80>
8000be48:	6e 4b       	ld.w	r11,r7[0x10]
8000be4a:	0c 9c       	mov	r12,r6
8000be4c:	fe b0 f9 5e 	rcall	8000b108 <_free_r>
8000be50:	6e db       	ld.w	r11,r7[0x34]
8000be52:	58 0b       	cp.w	r11,0
8000be54:	c0 a0       	breq	8000be68 <_fclose_r+0x98>
8000be56:	ee c8 ff bc 	sub	r8,r7,-68
8000be5a:	10 3b       	cp.w	r11,r8
8000be5c:	c0 40       	breq	8000be64 <_fclose_r+0x94>
8000be5e:	0c 9c       	mov	r12,r6
8000be60:	fe b0 f9 54 	rcall	8000b108 <_free_r>
8000be64:	30 08       	mov	r8,0
8000be66:	8f d8       	st.w	r7[0x34],r8
8000be68:	6f 2b       	ld.w	r11,r7[0x48]
8000be6a:	58 0b       	cp.w	r11,0
8000be6c:	c0 70       	breq	8000be7a <_fclose_r+0xaa>
8000be6e:	0c 9c       	mov	r12,r6
8000be70:	fe b0 f9 4c 	rcall	8000b108 <_free_r>
8000be74:	30 08       	mov	r8,0
8000be76:	ef 48 00 48 	st.w	r7[72],r8
8000be7a:	30 08       	mov	r8,0
8000be7c:	ae 68       	st.h	r7[0xc],r8
8000be7e:	fe b0 f8 5a 	rcall	8000af32 <__sfp_lock_release>
8000be82:	0a 9c       	mov	r12,r5
8000be84:	d8 22       	popm	r4-r7,pc
8000be86:	d7 03       	nop

8000be88 <fclose>:
8000be88:	d4 01       	pushm	lr
8000be8a:	e0 68 0a 3c 	mov	r8,2620
8000be8e:	18 9b       	mov	r11,r12
8000be90:	70 0c       	ld.w	r12,r8[0x0]
8000be92:	c9 ff       	rcall	8000bdd0 <_fclose_r>
8000be94:	d8 02       	popm	pc
8000be96:	d7 03       	nop

8000be98 <_fstat_r>:
8000be98:	d4 21       	pushm	r4-r7,lr
8000be9a:	16 98       	mov	r8,r11
8000be9c:	18 97       	mov	r7,r12
8000be9e:	10 9c       	mov	r12,r8
8000bea0:	30 08       	mov	r8,0
8000bea2:	e0 66 bf f8 	mov	r6,49144
8000bea6:	14 9b       	mov	r11,r10
8000bea8:	8d 08       	st.w	r6[0x0],r8
8000beaa:	fe b0 df 67 	rcall	80007d78 <_fstat>
8000beae:	5b fc       	cp.w	r12,-1
8000beb0:	c0 51       	brne	8000beba <_fstat_r+0x22>
8000beb2:	6c 08       	ld.w	r8,r6[0x0]
8000beb4:	58 08       	cp.w	r8,0
8000beb6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beba:	d8 22       	popm	r4-r7,pc

8000bebc <_lseek_r>:
8000bebc:	d4 21       	pushm	r4-r7,lr
8000bebe:	16 98       	mov	r8,r11
8000bec0:	18 97       	mov	r7,r12
8000bec2:	10 9c       	mov	r12,r8
8000bec4:	30 08       	mov	r8,0
8000bec6:	14 9b       	mov	r11,r10
8000bec8:	e0 66 bf f8 	mov	r6,49144
8000becc:	12 9a       	mov	r10,r9
8000bece:	8d 08       	st.w	r6[0x0],r8
8000bed0:	fe b0 df 36 	rcall	80007d3c <_lseek>
8000bed4:	5b fc       	cp.w	r12,-1
8000bed6:	c0 51       	brne	8000bee0 <_lseek_r+0x24>
8000bed8:	6c 08       	ld.w	r8,r6[0x0]
8000beda:	58 08       	cp.w	r8,0
8000bedc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bee0:	d8 22       	popm	r4-r7,pc
8000bee2:	d7 03       	nop

8000bee4 <_read_r>:
8000bee4:	d4 21       	pushm	r4-r7,lr
8000bee6:	16 98       	mov	r8,r11
8000bee8:	18 97       	mov	r7,r12
8000beea:	10 9c       	mov	r12,r8
8000beec:	30 08       	mov	r8,0
8000beee:	14 9b       	mov	r11,r10
8000bef0:	e0 66 bf f8 	mov	r6,49144
8000bef4:	12 9a       	mov	r10,r9
8000bef6:	8d 08       	st.w	r6[0x0],r8
8000bef8:	fe b0 d0 78 	rcall	80005fe8 <_read>
8000befc:	5b fc       	cp.w	r12,-1
8000befe:	c0 51       	brne	8000bf08 <_read_r+0x24>
8000bf00:	6c 08       	ld.w	r8,r6[0x0]
8000bf02:	58 08       	cp.w	r8,0
8000bf04:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf08:	d8 22       	popm	r4-r7,pc
8000bf0a:	d7 03       	nop

8000bf0c <__avr32_f64_mul>:
8000bf0c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bf10:	e0 80 00 dc 	breq	8000c0c8 <__avr32_f64_mul_op1_zero>
8000bf14:	d4 21       	pushm	r4-r7,lr
8000bf16:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf1a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bf1e:	30 15       	mov	r5,1
8000bf20:	c4 30       	breq	8000bfa6 <__avr32_f64_mul_op1_subnormal>
8000bf22:	ab 6b       	lsl	r11,0xa
8000bf24:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bf28:	ab 6a       	lsl	r10,0xa
8000bf2a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf2e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf32:	c5 c0       	breq	8000bfea <__avr32_f64_mul_op2_subnormal>
8000bf34:	a1 78       	lsl	r8,0x1
8000bf36:	5c f9       	rol	r9
8000bf38:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf3c:	e0 47 07 ff 	cp.w	r7,2047
8000bf40:	c7 70       	breq	8000c02e <__avr32_f64_mul_op_nan_or_inf>
8000bf42:	e0 46 07 ff 	cp.w	r6,2047
8000bf46:	c7 40       	breq	8000c02e <__avr32_f64_mul_op_nan_or_inf>
8000bf48:	ee 06 00 0c 	add	r12,r7,r6
8000bf4c:	e0 2c 03 fe 	sub	r12,1022
8000bf50:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf54:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf58:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf5c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf60:	08 07       	add	r7,r4
8000bf62:	f4 05 00 4a 	adc	r10,r10,r5
8000bf66:	5c 0b       	acr	r11
8000bf68:	ed bb 00 14 	bld	r11,0x14
8000bf6c:	c0 50       	breq	8000bf76 <__avr32_f64_mul+0x6a>
8000bf6e:	a1 77       	lsl	r7,0x1
8000bf70:	5c fa       	rol	r10
8000bf72:	5c fb       	rol	r11
8000bf74:	20 1c       	sub	r12,1
8000bf76:	58 0c       	cp.w	r12,0
8000bf78:	e0 8a 00 6f 	brle	8000c056 <__avr32_f64_mul_res_subnormal>
8000bf7c:	e0 4c 07 ff 	cp.w	r12,2047
8000bf80:	e0 84 00 9c 	brge	8000c0b8 <__avr32_f64_mul_res_inf>
8000bf84:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf88:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf8c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf90:	ee 17 80 00 	eorh	r7,0x8000
8000bf94:	f1 b7 04 20 	satu	r7,0x1
8000bf98:	0e 0a       	add	r10,r7
8000bf9a:	5c 0b       	acr	r11
8000bf9c:	ed be 00 1f 	bld	lr,0x1f
8000bfa0:	ef bb 00 1f 	bst	r11,0x1f
8000bfa4:	d8 22       	popm	r4-r7,pc

8000bfa6 <__avr32_f64_mul_op1_subnormal>:
8000bfa6:	e4 1b 00 0f 	andh	r11,0xf
8000bfaa:	f4 0c 12 00 	clz	r12,r10
8000bfae:	f6 06 12 00 	clz	r6,r11
8000bfb2:	f7 bc 03 e1 	sublo	r12,-31
8000bfb6:	f8 06 17 30 	movlo	r6,r12
8000bfba:	f7 b6 02 01 	subhs	r6,1
8000bfbe:	e0 46 00 20 	cp.w	r6,32
8000bfc2:	c0 d4       	brge	8000bfdc <__avr32_f64_mul_op1_subnormal+0x36>
8000bfc4:	ec 0c 11 20 	rsub	r12,r6,32
8000bfc8:	f6 06 09 4b 	lsl	r11,r11,r6
8000bfcc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bfd0:	18 4b       	or	r11,r12
8000bfd2:	f4 06 09 4a 	lsl	r10,r10,r6
8000bfd6:	20 b6       	sub	r6,11
8000bfd8:	0c 17       	sub	r7,r6
8000bfda:	ca ab       	rjmp	8000bf2e <__avr32_f64_mul+0x22>
8000bfdc:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfe0:	c6 40       	breq	8000c0a8 <__avr32_f64_mul_res_zero>
8000bfe2:	30 0a       	mov	r10,0
8000bfe4:	20 b6       	sub	r6,11
8000bfe6:	0c 17       	sub	r7,r6
8000bfe8:	ca 3b       	rjmp	8000bf2e <__avr32_f64_mul+0x22>

8000bfea <__avr32_f64_mul_op2_subnormal>:
8000bfea:	e4 19 00 0f 	andh	r9,0xf
8000bfee:	f0 0c 12 00 	clz	r12,r8
8000bff2:	f2 05 12 00 	clz	r5,r9
8000bff6:	f7 bc 03 ea 	sublo	r12,-22
8000bffa:	f8 05 17 30 	movlo	r5,r12
8000bffe:	f7 b5 02 0a 	subhs	r5,10
8000c002:	e0 45 00 20 	cp.w	r5,32
8000c006:	c0 d4       	brge	8000c020 <__avr32_f64_mul_op2_subnormal+0x36>
8000c008:	ea 0c 11 20 	rsub	r12,r5,32
8000c00c:	f2 05 09 49 	lsl	r9,r9,r5
8000c010:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c014:	18 49       	or	r9,r12
8000c016:	f0 05 09 48 	lsl	r8,r8,r5
8000c01a:	20 25       	sub	r5,2
8000c01c:	0a 16       	sub	r6,r5
8000c01e:	c8 fb       	rjmp	8000bf3c <__avr32_f64_mul+0x30>
8000c020:	f0 05 09 49 	lsl	r9,r8,r5
8000c024:	c4 20       	breq	8000c0a8 <__avr32_f64_mul_res_zero>
8000c026:	30 08       	mov	r8,0
8000c028:	20 25       	sub	r5,2
8000c02a:	0a 16       	sub	r6,r5
8000c02c:	c8 8b       	rjmp	8000bf3c <__avr32_f64_mul+0x30>

8000c02e <__avr32_f64_mul_op_nan_or_inf>:
8000c02e:	e4 19 00 0f 	andh	r9,0xf
8000c032:	e4 1b 00 0f 	andh	r11,0xf
8000c036:	14 4b       	or	r11,r10
8000c038:	10 49       	or	r9,r8
8000c03a:	e0 47 07 ff 	cp.w	r7,2047
8000c03e:	c0 91       	brne	8000c050 <__avr32_f64_mul_op1_not_naninf>
8000c040:	58 0b       	cp.w	r11,0
8000c042:	c3 81       	brne	8000c0b2 <__avr32_f64_mul_res_nan>
8000c044:	e0 46 07 ff 	cp.w	r6,2047
8000c048:	c3 81       	brne	8000c0b8 <__avr32_f64_mul_res_inf>
8000c04a:	58 09       	cp.w	r9,0
8000c04c:	c3 60       	breq	8000c0b8 <__avr32_f64_mul_res_inf>
8000c04e:	c3 28       	rjmp	8000c0b2 <__avr32_f64_mul_res_nan>

8000c050 <__avr32_f64_mul_op1_not_naninf>:
8000c050:	58 09       	cp.w	r9,0
8000c052:	c3 30       	breq	8000c0b8 <__avr32_f64_mul_res_inf>
8000c054:	c2 f8       	rjmp	8000c0b2 <__avr32_f64_mul_res_nan>

8000c056 <__avr32_f64_mul_res_subnormal>:
8000c056:	5c 3c       	neg	r12
8000c058:	2f fc       	sub	r12,-1
8000c05a:	f1 bc 04 c0 	satu	r12,0x6
8000c05e:	e0 4c 00 20 	cp.w	r12,32
8000c062:	c1 14       	brge	8000c084 <__avr32_f64_mul_res_subnormal+0x2e>
8000c064:	f8 08 11 20 	rsub	r8,r12,32
8000c068:	0e 46       	or	r6,r7
8000c06a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c06e:	f4 08 09 49 	lsl	r9,r10,r8
8000c072:	12 47       	or	r7,r9
8000c074:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c078:	f6 08 09 49 	lsl	r9,r11,r8
8000c07c:	12 4a       	or	r10,r9
8000c07e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c082:	c8 3b       	rjmp	8000bf88 <__avr32_f64_mul+0x7c>
8000c084:	f8 08 11 20 	rsub	r8,r12,32
8000c088:	f9 b9 00 00 	moveq	r9,0
8000c08c:	c0 30       	breq	8000c092 <__avr32_f64_mul_res_subnormal+0x3c>
8000c08e:	f6 08 09 49 	lsl	r9,r11,r8
8000c092:	0e 46       	or	r6,r7
8000c094:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c098:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c09c:	f3 ea 10 07 	or	r7,r9,r10
8000c0a0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c0a4:	30 0b       	mov	r11,0
8000c0a6:	c7 1b       	rjmp	8000bf88 <__avr32_f64_mul+0x7c>

8000c0a8 <__avr32_f64_mul_res_zero>:
8000c0a8:	1c 9b       	mov	r11,lr
8000c0aa:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0ae:	30 0a       	mov	r10,0
8000c0b0:	d8 22       	popm	r4-r7,pc

8000c0b2 <__avr32_f64_mul_res_nan>:
8000c0b2:	3f fb       	mov	r11,-1
8000c0b4:	3f fa       	mov	r10,-1
8000c0b6:	d8 22       	popm	r4-r7,pc

8000c0b8 <__avr32_f64_mul_res_inf>:
8000c0b8:	f0 6b 00 00 	mov	r11,-1048576
8000c0bc:	ed be 00 1f 	bld	lr,0x1f
8000c0c0:	ef bb 00 1f 	bst	r11,0x1f
8000c0c4:	30 0a       	mov	r10,0
8000c0c6:	d8 22       	popm	r4-r7,pc

8000c0c8 <__avr32_f64_mul_op1_zero>:
8000c0c8:	f7 e9 20 0b 	eor	r11,r11,r9
8000c0cc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0d0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c0d4:	e0 4c 07 ff 	cp.w	r12,2047
8000c0d8:	5e 1c       	retne	r12
8000c0da:	3f fa       	mov	r10,-1
8000c0dc:	3f fb       	mov	r11,-1
8000c0de:	5e fc       	retal	r12

8000c0e0 <__avr32_f64_sub_from_add>:
8000c0e0:	ee 19 80 00 	eorh	r9,0x8000

8000c0e4 <__avr32_f64_sub>:
8000c0e4:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0e8:	e0 86 00 ca 	brmi	8000c27c <__avr32_f64_add_from_sub>
8000c0ec:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0f0:	16 9c       	mov	r12,r11
8000c0f2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0f6:	bf db       	cbr	r11,0x1f
8000c0f8:	bf d9       	cbr	r9,0x1f
8000c0fa:	10 3a       	cp.w	r10,r8
8000c0fc:	f2 0b 13 00 	cpc	r11,r9
8000c100:	c0 92       	brcc	8000c112 <__avr32_f64_sub+0x2e>
8000c102:	16 97       	mov	r7,r11
8000c104:	12 9b       	mov	r11,r9
8000c106:	0e 99       	mov	r9,r7
8000c108:	14 97       	mov	r7,r10
8000c10a:	10 9a       	mov	r10,r8
8000c10c:	0e 98       	mov	r8,r7
8000c10e:	ee 1c 80 00 	eorh	r12,0x8000
8000c112:	f6 07 16 14 	lsr	r7,r11,0x14
8000c116:	ab 7b       	lsl	r11,0xb
8000c118:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c11c:	ab 7a       	lsl	r10,0xb
8000c11e:	bf bb       	sbr	r11,0x1f
8000c120:	f2 06 16 14 	lsr	r6,r9,0x14
8000c124:	c4 40       	breq	8000c1ac <__avr32_f64_sub_opL_subnormal>
8000c126:	ab 79       	lsl	r9,0xb
8000c128:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c12c:	ab 78       	lsl	r8,0xb
8000c12e:	bf b9       	sbr	r9,0x1f

8000c130 <__avr32_f64_sub_opL_subnormal_done>:
8000c130:	e0 47 07 ff 	cp.w	r7,2047
8000c134:	c4 f0       	breq	8000c1d2 <__avr32_f64_sub_opH_nan_or_inf>
8000c136:	0e 26       	rsub	r6,r7
8000c138:	c1 20       	breq	8000c15c <__avr32_f64_sub_shift_done>
8000c13a:	ec 05 11 20 	rsub	r5,r6,32
8000c13e:	e0 46 00 20 	cp.w	r6,32
8000c142:	c7 c2       	brcc	8000c23a <__avr32_f64_sub_longshift>
8000c144:	f0 05 09 4e 	lsl	lr,r8,r5
8000c148:	f2 05 09 45 	lsl	r5,r9,r5
8000c14c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c150:	f2 06 0a 49 	lsr	r9,r9,r6
8000c154:	0a 48       	or	r8,r5
8000c156:	58 0e       	cp.w	lr,0
8000c158:	5f 1e       	srne	lr
8000c15a:	1c 48       	or	r8,lr

8000c15c <__avr32_f64_sub_shift_done>:
8000c15c:	10 1a       	sub	r10,r8
8000c15e:	f6 09 01 4b 	sbc	r11,r11,r9
8000c162:	f6 06 12 00 	clz	r6,r11
8000c166:	c0 e0       	breq	8000c182 <__avr32_f64_sub_longnormalize_done>
8000c168:	c7 83       	brcs	8000c258 <__avr32_f64_sub_longnormalize>
8000c16a:	ec 0e 11 20 	rsub	lr,r6,32
8000c16e:	f6 06 09 4b 	lsl	r11,r11,r6
8000c172:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c176:	1c 4b       	or	r11,lr
8000c178:	f4 06 09 4a 	lsl	r10,r10,r6
8000c17c:	0c 17       	sub	r7,r6
8000c17e:	e0 8a 00 39 	brle	8000c1f0 <__avr32_f64_sub_subnormal_result>

8000c182 <__avr32_f64_sub_longnormalize_done>:
8000c182:	f4 09 15 15 	lsl	r9,r10,0x15
8000c186:	ab 9a       	lsr	r10,0xb
8000c188:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c18c:	ab 9b       	lsr	r11,0xb
8000c18e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c192:	18 4b       	or	r11,r12

8000c194 <__avr32_f64_sub_round>:
8000c194:	fc 17 80 00 	movh	r7,0x8000
8000c198:	ed ba 00 00 	bld	r10,0x0
8000c19c:	f7 b7 01 ff 	subne	r7,-1
8000c1a0:	0e 39       	cp.w	r9,r7
8000c1a2:	5f 29       	srhs	r9
8000c1a4:	12 0a       	add	r10,r9
8000c1a6:	5c 0b       	acr	r11
8000c1a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1ac <__avr32_f64_sub_opL_subnormal>:
8000c1ac:	ab 79       	lsl	r9,0xb
8000c1ae:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c1b2:	ab 78       	lsl	r8,0xb
8000c1b4:	f3 e8 10 0e 	or	lr,r9,r8
8000c1b8:	f9 b6 01 01 	movne	r6,1
8000c1bc:	ee 0e 11 00 	rsub	lr,r7,0
8000c1c0:	f9 b7 00 01 	moveq	r7,1
8000c1c4:	ef bb 00 1f 	bst	r11,0x1f
8000c1c8:	f7 ea 10 0e 	or	lr,r11,r10
8000c1cc:	f9 b7 00 00 	moveq	r7,0
8000c1d0:	cb 0b       	rjmp	8000c130 <__avr32_f64_sub_opL_subnormal_done>

8000c1d2 <__avr32_f64_sub_opH_nan_or_inf>:
8000c1d2:	bf db       	cbr	r11,0x1f
8000c1d4:	f7 ea 10 0e 	or	lr,r11,r10
8000c1d8:	c0 81       	brne	8000c1e8 <__avr32_f64_sub_return_nan>
8000c1da:	e0 46 07 ff 	cp.w	r6,2047
8000c1de:	c0 50       	breq	8000c1e8 <__avr32_f64_sub_return_nan>
8000c1e0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c1e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1e8 <__avr32_f64_sub_return_nan>:
8000c1e8:	3f fa       	mov	r10,-1
8000c1ea:	3f fb       	mov	r11,-1
8000c1ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1f0 <__avr32_f64_sub_subnormal_result>:
8000c1f0:	5c 37       	neg	r7
8000c1f2:	2f f7       	sub	r7,-1
8000c1f4:	f1 b7 04 c0 	satu	r7,0x6
8000c1f8:	e0 47 00 20 	cp.w	r7,32
8000c1fc:	c1 14       	brge	8000c21e <__avr32_f64_sub_subnormal_result+0x2e>
8000c1fe:	ee 08 11 20 	rsub	r8,r7,32
8000c202:	f4 08 09 49 	lsl	r9,r10,r8
8000c206:	5f 16       	srne	r6
8000c208:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c20c:	0c 4a       	or	r10,r6
8000c20e:	f6 08 09 49 	lsl	r9,r11,r8
8000c212:	f5 e9 10 0a 	or	r10,r10,r9
8000c216:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c21a:	30 07       	mov	r7,0
8000c21c:	cb 3b       	rjmp	8000c182 <__avr32_f64_sub_longnormalize_done>
8000c21e:	ee 08 11 40 	rsub	r8,r7,64
8000c222:	f6 08 09 49 	lsl	r9,r11,r8
8000c226:	14 49       	or	r9,r10
8000c228:	5f 16       	srne	r6
8000c22a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c22e:	0c 4a       	or	r10,r6
8000c230:	30 0b       	mov	r11,0
8000c232:	30 07       	mov	r7,0
8000c234:	ca 7b       	rjmp	8000c182 <__avr32_f64_sub_longnormalize_done>
8000c236:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c23a <__avr32_f64_sub_longshift>:
8000c23a:	f1 b6 04 c0 	satu	r6,0x6
8000c23e:	f0 0e 17 00 	moveq	lr,r8
8000c242:	c0 40       	breq	8000c24a <__avr32_f64_sub_longshift+0x10>
8000c244:	f2 05 09 4e 	lsl	lr,r9,r5
8000c248:	10 4e       	or	lr,r8
8000c24a:	f2 06 0a 48 	lsr	r8,r9,r6
8000c24e:	30 09       	mov	r9,0
8000c250:	58 0e       	cp.w	lr,0
8000c252:	5f 1e       	srne	lr
8000c254:	1c 48       	or	r8,lr
8000c256:	c8 3b       	rjmp	8000c15c <__avr32_f64_sub_shift_done>

8000c258 <__avr32_f64_sub_longnormalize>:
8000c258:	f4 06 12 00 	clz	r6,r10
8000c25c:	f9 b7 03 00 	movlo	r7,0
8000c260:	f9 b6 03 00 	movlo	r6,0
8000c264:	f9 bc 03 00 	movlo	r12,0
8000c268:	f7 b6 02 e0 	subhs	r6,-32
8000c26c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c270:	30 0a       	mov	r10,0
8000c272:	0c 17       	sub	r7,r6
8000c274:	fe 9a ff be 	brle	8000c1f0 <__avr32_f64_sub_subnormal_result>
8000c278:	c8 5b       	rjmp	8000c182 <__avr32_f64_sub_longnormalize_done>
8000c27a:	d7 03       	nop

8000c27c <__avr32_f64_add_from_sub>:
8000c27c:	ee 19 80 00 	eorh	r9,0x8000

8000c280 <__avr32_f64_add>:
8000c280:	f7 e9 20 0c 	eor	r12,r11,r9
8000c284:	fe 96 ff 2e 	brmi	8000c0e0 <__avr32_f64_sub_from_add>
8000c288:	eb cd 40 e0 	pushm	r5-r7,lr
8000c28c:	16 9c       	mov	r12,r11
8000c28e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c292:	bf db       	cbr	r11,0x1f
8000c294:	bf d9       	cbr	r9,0x1f
8000c296:	12 3b       	cp.w	r11,r9
8000c298:	c0 72       	brcc	8000c2a6 <__avr32_f64_add+0x26>
8000c29a:	16 97       	mov	r7,r11
8000c29c:	12 9b       	mov	r11,r9
8000c29e:	0e 99       	mov	r9,r7
8000c2a0:	14 97       	mov	r7,r10
8000c2a2:	10 9a       	mov	r10,r8
8000c2a4:	0e 98       	mov	r8,r7
8000c2a6:	30 0e       	mov	lr,0
8000c2a8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c2ac:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c2b0:	b5 ab       	sbr	r11,0x14
8000c2b2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c2b6:	c6 20       	breq	8000c37a <__avr32_f64_add_op2_subnormal>
8000c2b8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c2bc:	b5 a9       	sbr	r9,0x14
8000c2be:	e0 47 07 ff 	cp.w	r7,2047
8000c2c2:	c2 80       	breq	8000c312 <__avr32_f64_add_opH_nan_or_inf>
8000c2c4:	0e 26       	rsub	r6,r7
8000c2c6:	c1 20       	breq	8000c2ea <__avr32_f64_add_shift_done>
8000c2c8:	e0 46 00 36 	cp.w	r6,54
8000c2cc:	c1 52       	brcc	8000c2f6 <__avr32_f64_add_res_of_done>
8000c2ce:	ec 05 11 20 	rsub	r5,r6,32
8000c2d2:	e0 46 00 20 	cp.w	r6,32
8000c2d6:	c3 52       	brcc	8000c340 <__avr32_f64_add_longshift>
8000c2d8:	f0 05 09 4e 	lsl	lr,r8,r5
8000c2dc:	f2 05 09 45 	lsl	r5,r9,r5
8000c2e0:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2e4:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2e8:	0a 48       	or	r8,r5

8000c2ea <__avr32_f64_add_shift_done>:
8000c2ea:	10 0a       	add	r10,r8
8000c2ec:	f6 09 00 4b 	adc	r11,r11,r9
8000c2f0:	ed bb 00 15 	bld	r11,0x15
8000c2f4:	c3 40       	breq	8000c35c <__avr32_f64_add_res_of>

8000c2f6 <__avr32_f64_add_res_of_done>:
8000c2f6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2fa:	18 4b       	or	r11,r12

8000c2fc <__avr32_f64_add_round>:
8000c2fc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c300:	18 4e       	or	lr,r12
8000c302:	ee 1e 80 00 	eorh	lr,0x8000
8000c306:	f1 be 04 20 	satu	lr,0x1
8000c30a:	1c 0a       	add	r10,lr
8000c30c:	5c 0b       	acr	r11
8000c30e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c312 <__avr32_f64_add_opH_nan_or_inf>:
8000c312:	b5 cb       	cbr	r11,0x14
8000c314:	f7 ea 10 0e 	or	lr,r11,r10
8000c318:	c1 01       	brne	8000c338 <__avr32_f64_add_return_nan>
8000c31a:	e0 46 07 ff 	cp.w	r6,2047
8000c31e:	c0 30       	breq	8000c324 <__avr32_f64_add_opL_nan_or_inf>
8000c320:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c324 <__avr32_f64_add_opL_nan_or_inf>:
8000c324:	b5 c9       	cbr	r9,0x14
8000c326:	f3 e8 10 0e 	or	lr,r9,r8
8000c32a:	c0 71       	brne	8000c338 <__avr32_f64_add_return_nan>
8000c32c:	30 0a       	mov	r10,0
8000c32e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c332:	18 4b       	or	r11,r12
8000c334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c338 <__avr32_f64_add_return_nan>:
8000c338:	3f fa       	mov	r10,-1
8000c33a:	3f fb       	mov	r11,-1
8000c33c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c340 <__avr32_f64_add_longshift>:
8000c340:	f1 b6 04 c0 	satu	r6,0x6
8000c344:	f0 0e 17 00 	moveq	lr,r8
8000c348:	c0 60       	breq	8000c354 <__avr32_f64_add_longshift+0x14>
8000c34a:	f2 05 09 4e 	lsl	lr,r9,r5
8000c34e:	58 08       	cp.w	r8,0
8000c350:	5f 18       	srne	r8
8000c352:	10 4e       	or	lr,r8
8000c354:	f2 06 0a 48 	lsr	r8,r9,r6
8000c358:	30 09       	mov	r9,0
8000c35a:	cc 8b       	rjmp	8000c2ea <__avr32_f64_add_shift_done>

8000c35c <__avr32_f64_add_res_of>:
8000c35c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c360:	a1 9b       	lsr	r11,0x1
8000c362:	5d 0a       	ror	r10
8000c364:	5d 0e       	ror	lr
8000c366:	2f f7       	sub	r7,-1
8000c368:	e0 47 07 ff 	cp.w	r7,2047
8000c36c:	f9 ba 00 00 	moveq	r10,0
8000c370:	f9 bb 00 00 	moveq	r11,0
8000c374:	f9 be 00 00 	moveq	lr,0
8000c378:	cb fb       	rjmp	8000c2f6 <__avr32_f64_add_res_of_done>

8000c37a <__avr32_f64_add_op2_subnormal>:
8000c37a:	30 16       	mov	r6,1
8000c37c:	58 07       	cp.w	r7,0
8000c37e:	ca 01       	brne	8000c2be <__avr32_f64_add+0x3e>
8000c380:	b5 cb       	cbr	r11,0x14
8000c382:	10 0a       	add	r10,r8
8000c384:	f6 09 00 4b 	adc	r11,r11,r9
8000c388:	18 4b       	or	r11,r12
8000c38a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c38e:	d7 03       	nop

8000c390 <__avr32_f64_to_u32>:
8000c390:	58 0b       	cp.w	r11,0
8000c392:	5e 6d       	retmi	0

8000c394 <__avr32_f64_to_s32>:
8000c394:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c398:	b5 9c       	lsr	r12,0x15
8000c39a:	e0 2c 03 ff 	sub	r12,1023
8000c39e:	5e 3d       	retlo	0
8000c3a0:	f8 0c 11 1f 	rsub	r12,r12,31
8000c3a4:	16 99       	mov	r9,r11
8000c3a6:	ab 7b       	lsl	r11,0xb
8000c3a8:	bf bb       	sbr	r11,0x1f
8000c3aa:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c3ae:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c3b2:	a1 79       	lsl	r9,0x1
8000c3b4:	5e 2b       	reths	r11
8000c3b6:	5c 3b       	neg	r11
8000c3b8:	5e fb       	retal	r11

8000c3ba <__avr32_u32_to_f64>:
8000c3ba:	f8 cb 00 00 	sub	r11,r12,0
8000c3be:	30 0c       	mov	r12,0
8000c3c0:	c0 38       	rjmp	8000c3c6 <__avr32_s32_to_f64+0x4>

8000c3c2 <__avr32_s32_to_f64>:
8000c3c2:	18 9b       	mov	r11,r12
8000c3c4:	5c 4b       	abs	r11
8000c3c6:	30 0a       	mov	r10,0
8000c3c8:	5e 0b       	reteq	r11
8000c3ca:	d4 01       	pushm	lr
8000c3cc:	e0 69 04 1e 	mov	r9,1054
8000c3d0:	f6 08 12 00 	clz	r8,r11
8000c3d4:	c1 70       	breq	8000c402 <__avr32_s32_to_f64+0x40>
8000c3d6:	c0 c3       	brcs	8000c3ee <__avr32_s32_to_f64+0x2c>
8000c3d8:	f0 0e 11 20 	rsub	lr,r8,32
8000c3dc:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3e0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c3e4:	1c 4b       	or	r11,lr
8000c3e6:	f4 08 09 4a 	lsl	r10,r10,r8
8000c3ea:	10 19       	sub	r9,r8
8000c3ec:	c0 b8       	rjmp	8000c402 <__avr32_s32_to_f64+0x40>
8000c3ee:	f4 08 12 00 	clz	r8,r10
8000c3f2:	f9 b8 03 00 	movlo	r8,0
8000c3f6:	f7 b8 02 e0 	subhs	r8,-32
8000c3fa:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3fe:	30 0a       	mov	r10,0
8000c400:	10 19       	sub	r9,r8
8000c402:	58 09       	cp.w	r9,0
8000c404:	e0 89 00 30 	brgt	8000c464 <__avr32_s32_to_f64+0xa2>
8000c408:	5c 39       	neg	r9
8000c40a:	2f f9       	sub	r9,-1
8000c40c:	e0 49 00 36 	cp.w	r9,54
8000c410:	c0 43       	brcs	8000c418 <__avr32_s32_to_f64+0x56>
8000c412:	30 0b       	mov	r11,0
8000c414:	30 0a       	mov	r10,0
8000c416:	c2 68       	rjmp	8000c462 <__avr32_s32_to_f64+0xa0>
8000c418:	2f 69       	sub	r9,-10
8000c41a:	f2 08 11 20 	rsub	r8,r9,32
8000c41e:	e0 49 00 20 	cp.w	r9,32
8000c422:	c0 b2       	brcc	8000c438 <__avr32_s32_to_f64+0x76>
8000c424:	f4 08 09 4e 	lsl	lr,r10,r8
8000c428:	f6 08 09 48 	lsl	r8,r11,r8
8000c42c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c430:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c434:	10 4b       	or	r11,r8
8000c436:	c0 88       	rjmp	8000c446 <__avr32_s32_to_f64+0x84>
8000c438:	f6 08 09 4e 	lsl	lr,r11,r8
8000c43c:	14 4e       	or	lr,r10
8000c43e:	16 9a       	mov	r10,r11
8000c440:	30 0b       	mov	r11,0
8000c442:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c446:	ed ba 00 00 	bld	r10,0x0
8000c44a:	c0 92       	brcc	8000c45c <__avr32_s32_to_f64+0x9a>
8000c44c:	1c 7e       	tst	lr,lr
8000c44e:	c0 41       	brne	8000c456 <__avr32_s32_to_f64+0x94>
8000c450:	ed ba 00 01 	bld	r10,0x1
8000c454:	c0 42       	brcc	8000c45c <__avr32_s32_to_f64+0x9a>
8000c456:	2f fa       	sub	r10,-1
8000c458:	f7 bb 02 ff 	subhs	r11,-1
8000c45c:	5c fc       	rol	r12
8000c45e:	5d 0b       	ror	r11
8000c460:	5d 0a       	ror	r10
8000c462:	d8 02       	popm	pc
8000c464:	e0 68 03 ff 	mov	r8,1023
8000c468:	ed ba 00 0b 	bld	r10,0xb
8000c46c:	f7 b8 00 ff 	subeq	r8,-1
8000c470:	10 0a       	add	r10,r8
8000c472:	5c 0b       	acr	r11
8000c474:	f7 b9 03 fe 	sublo	r9,-2
8000c478:	e0 49 07 ff 	cp.w	r9,2047
8000c47c:	c0 55       	brlt	8000c486 <__avr32_s32_to_f64+0xc4>
8000c47e:	30 0a       	mov	r10,0
8000c480:	fc 1b ff e0 	movh	r11,0xffe0
8000c484:	c0 c8       	rjmp	8000c49c <__floatsidf_return_op1>
8000c486:	ed bb 00 1f 	bld	r11,0x1f
8000c48a:	f7 b9 01 01 	subne	r9,1
8000c48e:	ab 9a       	lsr	r10,0xb
8000c490:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c494:	a1 7b       	lsl	r11,0x1
8000c496:	ab 9b       	lsr	r11,0xb
8000c498:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c49c <__floatsidf_return_op1>:
8000c49c:	a1 7c       	lsl	r12,0x1
8000c49e:	5d 0b       	ror	r11
8000c4a0:	d8 02       	popm	pc

8000c4a2 <__avr32_f64_cmp_eq>:
8000c4a2:	10 3a       	cp.w	r10,r8
8000c4a4:	f2 0b 13 00 	cpc	r11,r9
8000c4a8:	c0 80       	breq	8000c4b8 <__avr32_f64_cmp_eq+0x16>
8000c4aa:	a1 7b       	lsl	r11,0x1
8000c4ac:	a1 79       	lsl	r9,0x1
8000c4ae:	14 4b       	or	r11,r10
8000c4b0:	12 4b       	or	r11,r9
8000c4b2:	10 4b       	or	r11,r8
8000c4b4:	5e 0f       	reteq	1
8000c4b6:	5e fd       	retal	0
8000c4b8:	a1 7b       	lsl	r11,0x1
8000c4ba:	fc 1c ff e0 	movh	r12,0xffe0
8000c4be:	58 0a       	cp.w	r10,0
8000c4c0:	f8 0b 13 00 	cpc	r11,r12
8000c4c4:	5e 8f       	retls	1
8000c4c6:	5e fd       	retal	0

8000c4c8 <__avr32_f64_cmp_ge>:
8000c4c8:	1a de       	st.w	--sp,lr
8000c4ca:	1a d7       	st.w	--sp,r7
8000c4cc:	a1 7b       	lsl	r11,0x1
8000c4ce:	5f 3c       	srlo	r12
8000c4d0:	a1 79       	lsl	r9,0x1
8000c4d2:	5f 37       	srlo	r7
8000c4d4:	5c fc       	rol	r12
8000c4d6:	fc 1e ff e0 	movh	lr,0xffe0
8000c4da:	58 0a       	cp.w	r10,0
8000c4dc:	fc 0b 13 00 	cpc	r11,lr
8000c4e0:	e0 8b 00 1d 	brhi	8000c51a <__avr32_f64_cmp_ge+0x52>
8000c4e4:	58 08       	cp.w	r8,0
8000c4e6:	fc 09 13 00 	cpc	r9,lr
8000c4ea:	e0 8b 00 18 	brhi	8000c51a <__avr32_f64_cmp_ge+0x52>
8000c4ee:	58 0b       	cp.w	r11,0
8000c4f0:	f5 ba 00 00 	subfeq	r10,0
8000c4f4:	c1 50       	breq	8000c51e <__avr32_f64_cmp_ge+0x56>
8000c4f6:	1b 07       	ld.w	r7,sp++
8000c4f8:	1b 0e       	ld.w	lr,sp++
8000c4fa:	58 3c       	cp.w	r12,3
8000c4fc:	c0 a0       	breq	8000c510 <__avr32_f64_cmp_ge+0x48>
8000c4fe:	58 1c       	cp.w	r12,1
8000c500:	c0 33       	brcs	8000c506 <__avr32_f64_cmp_ge+0x3e>
8000c502:	5e 0f       	reteq	1
8000c504:	5e 1d       	retne	0
8000c506:	10 3a       	cp.w	r10,r8
8000c508:	f2 0b 13 00 	cpc	r11,r9
8000c50c:	5e 2f       	reths	1
8000c50e:	5e 3d       	retlo	0
8000c510:	14 38       	cp.w	r8,r10
8000c512:	f6 09 13 00 	cpc	r9,r11
8000c516:	5e 2f       	reths	1
8000c518:	5e 3d       	retlo	0
8000c51a:	1b 07       	ld.w	r7,sp++
8000c51c:	d8 0a       	popm	pc,r12=0
8000c51e:	58 17       	cp.w	r7,1
8000c520:	5f 0c       	sreq	r12
8000c522:	58 09       	cp.w	r9,0
8000c524:	f5 b8 00 00 	subfeq	r8,0
8000c528:	1b 07       	ld.w	r7,sp++
8000c52a:	1b 0e       	ld.w	lr,sp++
8000c52c:	5e 0f       	reteq	1
8000c52e:	5e fc       	retal	r12

8000c530 <__avr32_f64_cmp_lt>:
8000c530:	1a de       	st.w	--sp,lr
8000c532:	1a d7       	st.w	--sp,r7
8000c534:	a1 7b       	lsl	r11,0x1
8000c536:	5f 3c       	srlo	r12
8000c538:	a1 79       	lsl	r9,0x1
8000c53a:	5f 37       	srlo	r7
8000c53c:	5c fc       	rol	r12
8000c53e:	fc 1e ff e0 	movh	lr,0xffe0
8000c542:	58 0a       	cp.w	r10,0
8000c544:	fc 0b 13 00 	cpc	r11,lr
8000c548:	e0 8b 00 1d 	brhi	8000c582 <__avr32_f64_cmp_lt+0x52>
8000c54c:	58 08       	cp.w	r8,0
8000c54e:	fc 09 13 00 	cpc	r9,lr
8000c552:	e0 8b 00 18 	brhi	8000c582 <__avr32_f64_cmp_lt+0x52>
8000c556:	58 0b       	cp.w	r11,0
8000c558:	f5 ba 00 00 	subfeq	r10,0
8000c55c:	c1 50       	breq	8000c586 <__avr32_f64_cmp_lt+0x56>
8000c55e:	1b 07       	ld.w	r7,sp++
8000c560:	1b 0e       	ld.w	lr,sp++
8000c562:	58 3c       	cp.w	r12,3
8000c564:	c0 a0       	breq	8000c578 <__avr32_f64_cmp_lt+0x48>
8000c566:	58 1c       	cp.w	r12,1
8000c568:	c0 33       	brcs	8000c56e <__avr32_f64_cmp_lt+0x3e>
8000c56a:	5e 0d       	reteq	0
8000c56c:	5e 1f       	retne	1
8000c56e:	10 3a       	cp.w	r10,r8
8000c570:	f2 0b 13 00 	cpc	r11,r9
8000c574:	5e 2d       	reths	0
8000c576:	5e 3f       	retlo	1
8000c578:	14 38       	cp.w	r8,r10
8000c57a:	f6 09 13 00 	cpc	r9,r11
8000c57e:	5e 2d       	reths	0
8000c580:	5e 3f       	retlo	1
8000c582:	1b 07       	ld.w	r7,sp++
8000c584:	d8 0a       	popm	pc,r12=0
8000c586:	58 17       	cp.w	r7,1
8000c588:	5f 1c       	srne	r12
8000c58a:	58 09       	cp.w	r9,0
8000c58c:	f5 b8 00 00 	subfeq	r8,0
8000c590:	1b 07       	ld.w	r7,sp++
8000c592:	1b 0e       	ld.w	lr,sp++
8000c594:	5e 0d       	reteq	0
8000c596:	5e fc       	retal	r12

8000c598 <__avr32_f64_div>:
8000c598:	eb cd 40 ff 	pushm	r0-r7,lr
8000c59c:	f7 e9 20 0e 	eor	lr,r11,r9
8000c5a0:	f6 07 16 14 	lsr	r7,r11,0x14
8000c5a4:	a9 7b       	lsl	r11,0x9
8000c5a6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c5aa:	a9 7a       	lsl	r10,0x9
8000c5ac:	bd bb       	sbr	r11,0x1d
8000c5ae:	e4 1b 3f ff 	andh	r11,0x3fff
8000c5b2:	ab d7       	cbr	r7,0xb
8000c5b4:	e0 80 00 cc 	breq	8000c74c <__avr32_f64_div_round_subnormal+0x54>
8000c5b8:	e0 47 07 ff 	cp.w	r7,2047
8000c5bc:	e0 84 00 b5 	brge	8000c726 <__avr32_f64_div_round_subnormal+0x2e>
8000c5c0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c5c4:	a9 79       	lsl	r9,0x9
8000c5c6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c5ca:	a9 78       	lsl	r8,0x9
8000c5cc:	bd b9       	sbr	r9,0x1d
8000c5ce:	e4 19 3f ff 	andh	r9,0x3fff
8000c5d2:	ab d6       	cbr	r6,0xb
8000c5d4:	e0 80 00 e2 	breq	8000c798 <__avr32_f64_div_round_subnormal+0xa0>
8000c5d8:	e0 46 07 ff 	cp.w	r6,2047
8000c5dc:	e0 84 00 b2 	brge	8000c740 <__avr32_f64_div_round_subnormal+0x48>
8000c5e0:	0c 17       	sub	r7,r6
8000c5e2:	fe 37 fc 01 	sub	r7,-1023
8000c5e6:	fc 1c 80 00 	movh	r12,0x8000
8000c5ea:	f8 03 16 01 	lsr	r3,r12,0x1
8000c5ee:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c5f2:	5c d4       	com	r4
8000c5f4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5f8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5fc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c600:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c604:	ea 03 15 02 	lsl	r3,r5,0x2
8000c608:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c60c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c610:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c614:	ea 03 15 02 	lsl	r3,r5,0x2
8000c618:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c61c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c620:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c624:	ea 03 15 02 	lsl	r3,r5,0x2
8000c628:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c62c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c630:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c634:	02 04       	add	r4,r1
8000c636:	5c 05       	acr	r5
8000c638:	a3 65       	lsl	r5,0x2
8000c63a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c63e:	a3 64       	lsl	r4,0x2
8000c640:	5c 34       	neg	r4
8000c642:	f8 05 01 45 	sbc	r5,r12,r5
8000c646:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c64a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c64e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c652:	02 04       	add	r4,r1
8000c654:	5c 05       	acr	r5
8000c656:	ea 03 15 02 	lsl	r3,r5,0x2
8000c65a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c65e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c662:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c666:	e4 09 07 40 	macu.d	r0,r2,r9
8000c66a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c66e:	02 04       	add	r4,r1
8000c670:	5c 05       	acr	r5
8000c672:	a3 65       	lsl	r5,0x2
8000c674:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c678:	a3 64       	lsl	r4,0x2
8000c67a:	5c 34       	neg	r4
8000c67c:	f8 05 01 45 	sbc	r5,r12,r5
8000c680:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c684:	e4 05 07 40 	macu.d	r0,r2,r5
8000c688:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c68c:	02 04       	add	r4,r1
8000c68e:	5c 05       	acr	r5
8000c690:	ea 03 15 02 	lsl	r3,r5,0x2
8000c694:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c698:	e8 02 15 02 	lsl	r2,r4,0x2
8000c69c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c6a0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c6a4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c6a8:	02 02       	add	r2,r1
8000c6aa:	5c 03       	acr	r3
8000c6ac:	ed b3 00 1c 	bld	r3,0x1c
8000c6b0:	c0 90       	breq	8000c6c2 <__avr32_f64_div+0x12a>
8000c6b2:	a1 72       	lsl	r2,0x1
8000c6b4:	5c f3       	rol	r3
8000c6b6:	20 17       	sub	r7,1
8000c6b8:	a3 9a       	lsr	r10,0x3
8000c6ba:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c6be:	a3 9b       	lsr	r11,0x3
8000c6c0:	c0 58       	rjmp	8000c6ca <__avr32_f64_div+0x132>
8000c6c2:	a5 8a       	lsr	r10,0x4
8000c6c4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c6c8:	a5 8b       	lsr	r11,0x4
8000c6ca:	58 07       	cp.w	r7,0
8000c6cc:	e0 8a 00 8b 	brle	8000c7e2 <__avr32_f64_div_res_subnormal>
8000c6d0:	e0 12 ff 00 	andl	r2,0xff00
8000c6d4:	e8 12 00 80 	orl	r2,0x80
8000c6d8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6dc:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6e0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6e4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6e8:	00 05       	add	r5,r0
8000c6ea:	f0 01 00 48 	adc	r8,r8,r1
8000c6ee:	5c 09       	acr	r9
8000c6f0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6f4:	58 04       	cp.w	r4,0
8000c6f6:	5c 25       	cpc	r5

8000c6f8 <__avr32_f64_div_round_subnormal>:
8000c6f8:	f4 08 13 00 	cpc	r8,r10
8000c6fc:	f6 09 13 00 	cpc	r9,r11
8000c700:	5f 36       	srlo	r6
8000c702:	f8 06 17 00 	moveq	r6,r12
8000c706:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c70a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c70e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c712:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c716:	ed be 00 1f 	bld	lr,0x1f
8000c71a:	ef bb 00 1f 	bst	r11,0x1f
8000c71e:	0c 0a       	add	r10,r6
8000c720:	5c 0b       	acr	r11
8000c722:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c726:	e4 1b 00 0f 	andh	r11,0xf
8000c72a:	14 4b       	or	r11,r10
8000c72c:	e0 81 00 a7 	brne	8000c87a <__avr32_f64_div_res_subnormal+0x98>
8000c730:	f2 06 16 14 	lsr	r6,r9,0x14
8000c734:	ab d6       	cbr	r6,0xb
8000c736:	e0 46 07 ff 	cp.w	r6,2047
8000c73a:	e0 81 00 a4 	brne	8000c882 <__avr32_f64_div_res_subnormal+0xa0>
8000c73e:	c9 e8       	rjmp	8000c87a <__avr32_f64_div_res_subnormal+0x98>
8000c740:	e4 19 00 0f 	andh	r9,0xf
8000c744:	10 49       	or	r9,r8
8000c746:	e0 81 00 9a 	brne	8000c87a <__avr32_f64_div_res_subnormal+0x98>
8000c74a:	c9 28       	rjmp	8000c86e <__avr32_f64_div_res_subnormal+0x8c>
8000c74c:	a3 7b       	lsl	r11,0x3
8000c74e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c752:	a3 7a       	lsl	r10,0x3
8000c754:	f5 eb 10 04 	or	r4,r10,r11
8000c758:	e0 80 00 a0 	breq	8000c898 <__avr32_f64_div_op1_zero>
8000c75c:	f6 04 12 00 	clz	r4,r11
8000c760:	c1 70       	breq	8000c78e <__avr32_f64_div_round_subnormal+0x96>
8000c762:	c0 c3       	brcs	8000c77a <__avr32_f64_div_round_subnormal+0x82>
8000c764:	e8 05 11 20 	rsub	r5,r4,32
8000c768:	f6 04 09 4b 	lsl	r11,r11,r4
8000c76c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c770:	0a 4b       	or	r11,r5
8000c772:	f4 04 09 4a 	lsl	r10,r10,r4
8000c776:	08 17       	sub	r7,r4
8000c778:	c0 b8       	rjmp	8000c78e <__avr32_f64_div_round_subnormal+0x96>
8000c77a:	f4 04 12 00 	clz	r4,r10
8000c77e:	f9 b4 03 00 	movlo	r4,0
8000c782:	f7 b4 02 e0 	subhs	r4,-32
8000c786:	f4 04 09 4b 	lsl	r11,r10,r4
8000c78a:	30 0a       	mov	r10,0
8000c78c:	08 17       	sub	r7,r4
8000c78e:	a3 8a       	lsr	r10,0x2
8000c790:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c794:	a3 8b       	lsr	r11,0x2
8000c796:	c1 1b       	rjmp	8000c5b8 <__avr32_f64_div+0x20>
8000c798:	a3 79       	lsl	r9,0x3
8000c79a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c79e:	a3 78       	lsl	r8,0x3
8000c7a0:	f3 e8 10 04 	or	r4,r9,r8
8000c7a4:	c6 f0       	breq	8000c882 <__avr32_f64_div_res_subnormal+0xa0>
8000c7a6:	f2 04 12 00 	clz	r4,r9
8000c7aa:	c1 70       	breq	8000c7d8 <__avr32_f64_div_round_subnormal+0xe0>
8000c7ac:	c0 c3       	brcs	8000c7c4 <__avr32_f64_div_round_subnormal+0xcc>
8000c7ae:	e8 05 11 20 	rsub	r5,r4,32
8000c7b2:	f2 04 09 49 	lsl	r9,r9,r4
8000c7b6:	f0 05 0a 45 	lsr	r5,r8,r5
8000c7ba:	0a 49       	or	r9,r5
8000c7bc:	f0 04 09 48 	lsl	r8,r8,r4
8000c7c0:	08 16       	sub	r6,r4
8000c7c2:	c0 b8       	rjmp	8000c7d8 <__avr32_f64_div_round_subnormal+0xe0>
8000c7c4:	f0 04 12 00 	clz	r4,r8
8000c7c8:	f9 b4 03 00 	movlo	r4,0
8000c7cc:	f7 b4 02 e0 	subhs	r4,-32
8000c7d0:	f0 04 09 49 	lsl	r9,r8,r4
8000c7d4:	30 08       	mov	r8,0
8000c7d6:	08 16       	sub	r6,r4
8000c7d8:	a3 88       	lsr	r8,0x2
8000c7da:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c7de:	a3 89       	lsr	r9,0x2
8000c7e0:	cf ca       	rjmp	8000c5d8 <__avr32_f64_div+0x40>

8000c7e2 <__avr32_f64_div_res_subnormal>:
8000c7e2:	5c 37       	neg	r7
8000c7e4:	2f f7       	sub	r7,-1
8000c7e6:	f1 b7 04 c0 	satu	r7,0x6
8000c7ea:	e0 47 00 20 	cp.w	r7,32
8000c7ee:	c1 54       	brge	8000c818 <__avr32_f64_div_res_subnormal+0x36>
8000c7f0:	ee 06 11 20 	rsub	r6,r7,32
8000c7f4:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7f8:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7fc:	18 42       	or	r2,r12
8000c7fe:	e6 07 0a 43 	lsr	r3,r3,r7
8000c802:	f4 06 09 41 	lsl	r1,r10,r6
8000c806:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c80a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c80e:	18 4a       	or	r10,r12
8000c810:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c814:	30 00       	mov	r0,0
8000c816:	c1 58       	rjmp	8000c840 <__avr32_f64_div_res_subnormal+0x5e>
8000c818:	ee 06 11 20 	rsub	r6,r7,32
8000c81c:	f9 b0 00 00 	moveq	r0,0
8000c820:	f9 bc 00 00 	moveq	r12,0
8000c824:	c0 50       	breq	8000c82e <__avr32_f64_div_res_subnormal+0x4c>
8000c826:	f4 06 09 40 	lsl	r0,r10,r6
8000c82a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c82e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c832:	30 03       	mov	r3,0
8000c834:	f4 07 0a 41 	lsr	r1,r10,r7
8000c838:	18 41       	or	r1,r12
8000c83a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c83e:	30 0b       	mov	r11,0
8000c840:	e0 12 ff 00 	andl	r2,0xff00
8000c844:	e8 12 00 80 	orl	r2,0x80
8000c848:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c84c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c850:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c854:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c858:	0c 05       	add	r5,r6
8000c85a:	f0 07 00 48 	adc	r8,r8,r7
8000c85e:	5c 09       	acr	r9
8000c860:	30 07       	mov	r7,0
8000c862:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c866:	00 34       	cp.w	r4,r0
8000c868:	e2 05 13 00 	cpc	r5,r1
8000c86c:	c4 6b       	rjmp	8000c6f8 <__avr32_f64_div_round_subnormal>
8000c86e:	1c 9b       	mov	r11,lr
8000c870:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c874:	30 0a       	mov	r10,0
8000c876:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c87a:	3f fb       	mov	r11,-1
8000c87c:	30 0a       	mov	r10,0
8000c87e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c882:	f5 eb 10 04 	or	r4,r10,r11
8000c886:	c0 90       	breq	8000c898 <__avr32_f64_div_op1_zero>
8000c888:	1c 9b       	mov	r11,lr
8000c88a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c88e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c892:	30 0a       	mov	r10,0
8000c894:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c898 <__avr32_f64_div_op1_zero>:
8000c898:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c89c:	ce f0       	breq	8000c87a <__avr32_f64_div_res_subnormal+0x98>
8000c89e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c8a2:	e0 44 07 ff 	cp.w	r4,2047
8000c8a6:	ce 41       	brne	8000c86e <__avr32_f64_div_res_subnormal+0x8c>
8000c8a8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c8ac:	ce 10       	breq	8000c86e <__avr32_f64_div_res_subnormal+0x8c>
8000c8ae:	ce 6b       	rjmp	8000c87a <__avr32_f64_div_res_subnormal+0x98>

8000c8b0 <__avr32_udiv64>:
8000c8b0:	d4 31       	pushm	r0-r7,lr
8000c8b2:	1a 97       	mov	r7,sp
8000c8b4:	20 3d       	sub	sp,12
8000c8b6:	10 9c       	mov	r12,r8
8000c8b8:	12 9e       	mov	lr,r9
8000c8ba:	14 93       	mov	r3,r10
8000c8bc:	58 09       	cp.w	r9,0
8000c8be:	e0 81 00 bd 	brne	8000ca38 <__avr32_udiv64+0x188>
8000c8c2:	16 38       	cp.w	r8,r11
8000c8c4:	e0 88 00 40 	brls	8000c944 <__avr32_udiv64+0x94>
8000c8c8:	f0 08 12 00 	clz	r8,r8
8000c8cc:	c0 d0       	breq	8000c8e6 <__avr32_udiv64+0x36>
8000c8ce:	f6 08 09 4b 	lsl	r11,r11,r8
8000c8d2:	f0 09 11 20 	rsub	r9,r8,32
8000c8d6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8da:	f4 09 0a 49 	lsr	r9,r10,r9
8000c8de:	f4 08 09 43 	lsl	r3,r10,r8
8000c8e2:	f3 eb 10 0b 	or	r11,r9,r11
8000c8e6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c8ea:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c8ee:	f6 0e 0d 00 	divu	r0,r11,lr
8000c8f2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8f6:	00 99       	mov	r9,r0
8000c8f8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8fc:	e0 0a 02 48 	mul	r8,r0,r10
8000c900:	10 3b       	cp.w	r11,r8
8000c902:	c0 a2       	brcc	8000c916 <__avr32_udiv64+0x66>
8000c904:	20 19       	sub	r9,1
8000c906:	18 0b       	add	r11,r12
8000c908:	18 3b       	cp.w	r11,r12
8000c90a:	c0 63       	brcs	8000c916 <__avr32_udiv64+0x66>
8000c90c:	10 3b       	cp.w	r11,r8
8000c90e:	f7 b9 03 01 	sublo	r9,1
8000c912:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c916:	f6 08 01 01 	sub	r1,r11,r8
8000c91a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c91e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c922:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c926:	00 98       	mov	r8,r0
8000c928:	e0 0a 02 4a 	mul	r10,r0,r10
8000c92c:	14 33       	cp.w	r3,r10
8000c92e:	c0 82       	brcc	8000c93e <__avr32_udiv64+0x8e>
8000c930:	20 18       	sub	r8,1
8000c932:	18 03       	add	r3,r12
8000c934:	18 33       	cp.w	r3,r12
8000c936:	c0 43       	brcs	8000c93e <__avr32_udiv64+0x8e>
8000c938:	14 33       	cp.w	r3,r10
8000c93a:	f7 b8 03 01 	sublo	r8,1
8000c93e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c942:	cd f8       	rjmp	8000cb00 <__avr32_udiv64+0x250>
8000c944:	58 08       	cp.w	r8,0
8000c946:	c0 51       	brne	8000c950 <__avr32_udiv64+0xa0>
8000c948:	30 19       	mov	r9,1
8000c94a:	f2 08 0d 08 	divu	r8,r9,r8
8000c94e:	10 9c       	mov	r12,r8
8000c950:	f8 06 12 00 	clz	r6,r12
8000c954:	c0 41       	brne	8000c95c <__avr32_udiv64+0xac>
8000c956:	18 1b       	sub	r11,r12
8000c958:	30 19       	mov	r9,1
8000c95a:	c4 08       	rjmp	8000c9da <__avr32_udiv64+0x12a>
8000c95c:	ec 01 11 20 	rsub	r1,r6,32
8000c960:	f4 01 0a 49 	lsr	r9,r10,r1
8000c964:	f8 06 09 4c 	lsl	r12,r12,r6
8000c968:	f6 06 09 48 	lsl	r8,r11,r6
8000c96c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c970:	f3 e8 10 08 	or	r8,r9,r8
8000c974:	f8 03 16 10 	lsr	r3,r12,0x10
8000c978:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c97c:	e2 03 0d 00 	divu	r0,r1,r3
8000c980:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c984:	00 9e       	mov	lr,r0
8000c986:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c98a:	e0 05 02 49 	mul	r9,r0,r5
8000c98e:	12 3b       	cp.w	r11,r9
8000c990:	c0 a2       	brcc	8000c9a4 <__avr32_udiv64+0xf4>
8000c992:	20 1e       	sub	lr,1
8000c994:	18 0b       	add	r11,r12
8000c996:	18 3b       	cp.w	r11,r12
8000c998:	c0 63       	brcs	8000c9a4 <__avr32_udiv64+0xf4>
8000c99a:	12 3b       	cp.w	r11,r9
8000c99c:	f7 be 03 01 	sublo	lr,1
8000c9a0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9a4:	12 1b       	sub	r11,r9
8000c9a6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c9aa:	f6 03 0d 02 	divu	r2,r11,r3
8000c9ae:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c9b2:	04 99       	mov	r9,r2
8000c9b4:	e4 05 02 4b 	mul	r11,r2,r5
8000c9b8:	16 38       	cp.w	r8,r11
8000c9ba:	c0 a2       	brcc	8000c9ce <__avr32_udiv64+0x11e>
8000c9bc:	20 19       	sub	r9,1
8000c9be:	18 08       	add	r8,r12
8000c9c0:	18 38       	cp.w	r8,r12
8000c9c2:	c0 63       	brcs	8000c9ce <__avr32_udiv64+0x11e>
8000c9c4:	16 38       	cp.w	r8,r11
8000c9c6:	f7 b9 03 01 	sublo	r9,1
8000c9ca:	f1 dc e3 08 	addcs	r8,r8,r12
8000c9ce:	f4 06 09 43 	lsl	r3,r10,r6
8000c9d2:	f0 0b 01 0b 	sub	r11,r8,r11
8000c9d6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c9da:	f8 06 16 10 	lsr	r6,r12,0x10
8000c9de:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c9e2:	f6 06 0d 00 	divu	r0,r11,r6
8000c9e6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9ea:	00 9a       	mov	r10,r0
8000c9ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9f0:	e0 0e 02 48 	mul	r8,r0,lr
8000c9f4:	10 3b       	cp.w	r11,r8
8000c9f6:	c0 a2       	brcc	8000ca0a <__avr32_udiv64+0x15a>
8000c9f8:	20 1a       	sub	r10,1
8000c9fa:	18 0b       	add	r11,r12
8000c9fc:	18 3b       	cp.w	r11,r12
8000c9fe:	c0 63       	brcs	8000ca0a <__avr32_udiv64+0x15a>
8000ca00:	10 3b       	cp.w	r11,r8
8000ca02:	f7 ba 03 01 	sublo	r10,1
8000ca06:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca0a:	f6 08 01 01 	sub	r1,r11,r8
8000ca0e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca12:	e2 06 0d 00 	divu	r0,r1,r6
8000ca16:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca1a:	00 98       	mov	r8,r0
8000ca1c:	e0 0e 02 4b 	mul	r11,r0,lr
8000ca20:	16 33       	cp.w	r3,r11
8000ca22:	c0 82       	brcc	8000ca32 <__avr32_udiv64+0x182>
8000ca24:	20 18       	sub	r8,1
8000ca26:	18 03       	add	r3,r12
8000ca28:	18 33       	cp.w	r3,r12
8000ca2a:	c0 43       	brcs	8000ca32 <__avr32_udiv64+0x182>
8000ca2c:	16 33       	cp.w	r3,r11
8000ca2e:	f7 b8 03 01 	sublo	r8,1
8000ca32:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca36:	c6 98       	rjmp	8000cb08 <__avr32_udiv64+0x258>
8000ca38:	16 39       	cp.w	r9,r11
8000ca3a:	e0 8b 00 65 	brhi	8000cb04 <__avr32_udiv64+0x254>
8000ca3e:	f2 09 12 00 	clz	r9,r9
8000ca42:	c0 b1       	brne	8000ca58 <__avr32_udiv64+0x1a8>
8000ca44:	10 3a       	cp.w	r10,r8
8000ca46:	5f 2a       	srhs	r10
8000ca48:	1c 3b       	cp.w	r11,lr
8000ca4a:	5f b8       	srhi	r8
8000ca4c:	10 4a       	or	r10,r8
8000ca4e:	f2 0a 18 00 	cp.b	r10,r9
8000ca52:	c5 90       	breq	8000cb04 <__avr32_udiv64+0x254>
8000ca54:	30 18       	mov	r8,1
8000ca56:	c5 98       	rjmp	8000cb08 <__avr32_udiv64+0x258>
8000ca58:	f0 09 09 46 	lsl	r6,r8,r9
8000ca5c:	f2 03 11 20 	rsub	r3,r9,32
8000ca60:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca64:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca68:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca6c:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca70:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca74:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca78:	18 42       	or	r2,r12
8000ca7a:	f1 ee 10 0c 	or	r12,r8,lr
8000ca7e:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca82:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca86:	e6 01 0d 04 	divu	r4,r3,r1
8000ca8a:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca8e:	08 9e       	mov	lr,r4
8000ca90:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca94:	e8 06 02 48 	mul	r8,r4,r6
8000ca98:	10 33       	cp.w	r3,r8
8000ca9a:	c0 a2       	brcc	8000caae <__avr32_udiv64+0x1fe>
8000ca9c:	20 1e       	sub	lr,1
8000ca9e:	18 03       	add	r3,r12
8000caa0:	18 33       	cp.w	r3,r12
8000caa2:	c0 63       	brcs	8000caae <__avr32_udiv64+0x1fe>
8000caa4:	10 33       	cp.w	r3,r8
8000caa6:	f7 be 03 01 	sublo	lr,1
8000caaa:	e7 dc e3 03 	addcs	r3,r3,r12
8000caae:	10 13       	sub	r3,r8
8000cab0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cab4:	e6 01 0d 00 	divu	r0,r3,r1
8000cab8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cabc:	00 98       	mov	r8,r0
8000cabe:	e0 06 02 46 	mul	r6,r0,r6
8000cac2:	0c 3b       	cp.w	r11,r6
8000cac4:	c0 a2       	brcc	8000cad8 <__avr32_udiv64+0x228>
8000cac6:	20 18       	sub	r8,1
8000cac8:	18 0b       	add	r11,r12
8000caca:	18 3b       	cp.w	r11,r12
8000cacc:	c0 63       	brcs	8000cad8 <__avr32_udiv64+0x228>
8000cace:	0c 3b       	cp.w	r11,r6
8000cad0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cad4:	f7 b8 03 01 	sublo	r8,1
8000cad8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cadc:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cae0:	0c 1b       	sub	r11,r6
8000cae2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cae6:	06 95       	mov	r5,r3
8000cae8:	16 35       	cp.w	r5,r11
8000caea:	e0 8b 00 0a 	brhi	8000cafe <__avr32_udiv64+0x24e>
8000caee:	5f 0b       	sreq	r11
8000caf0:	f4 09 09 49 	lsl	r9,r10,r9
8000caf4:	12 32       	cp.w	r2,r9
8000caf6:	5f b9       	srhi	r9
8000caf8:	f7 e9 00 09 	and	r9,r11,r9
8000cafc:	c0 60       	breq	8000cb08 <__avr32_udiv64+0x258>
8000cafe:	20 18       	sub	r8,1
8000cb00:	30 09       	mov	r9,0
8000cb02:	c0 38       	rjmp	8000cb08 <__avr32_udiv64+0x258>
8000cb04:	30 09       	mov	r9,0
8000cb06:	12 98       	mov	r8,r9
8000cb08:	10 9a       	mov	r10,r8
8000cb0a:	12 93       	mov	r3,r9
8000cb0c:	10 92       	mov	r2,r8
8000cb0e:	12 9b       	mov	r11,r9
8000cb10:	2f dd       	sub	sp,-12
8000cb12:	d8 32       	popm	r0-r7,pc

8000cb14 <__avr32_umod64>:
8000cb14:	d4 31       	pushm	r0-r7,lr
8000cb16:	1a 97       	mov	r7,sp
8000cb18:	20 3d       	sub	sp,12
8000cb1a:	10 9c       	mov	r12,r8
8000cb1c:	12 95       	mov	r5,r9
8000cb1e:	14 9e       	mov	lr,r10
8000cb20:	16 91       	mov	r1,r11
8000cb22:	16 96       	mov	r6,r11
8000cb24:	58 09       	cp.w	r9,0
8000cb26:	e0 81 00 81 	brne	8000cc28 <__avr32_umod64+0x114>
8000cb2a:	16 38       	cp.w	r8,r11
8000cb2c:	e0 88 00 12 	brls	8000cb50 <__avr32_umod64+0x3c>
8000cb30:	f0 08 12 00 	clz	r8,r8
8000cb34:	c4 e0       	breq	8000cbd0 <__avr32_umod64+0xbc>
8000cb36:	f6 08 09 46 	lsl	r6,r11,r8
8000cb3a:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb3e:	f0 0b 11 20 	rsub	r11,r8,32
8000cb42:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb46:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb4a:	f7 e6 10 06 	or	r6,r11,r6
8000cb4e:	c4 18       	rjmp	8000cbd0 <__avr32_umod64+0xbc>
8000cb50:	58 08       	cp.w	r8,0
8000cb52:	c0 51       	brne	8000cb5c <__avr32_umod64+0x48>
8000cb54:	30 19       	mov	r9,1
8000cb56:	f2 08 0d 08 	divu	r8,r9,r8
8000cb5a:	10 9c       	mov	r12,r8
8000cb5c:	f8 08 12 00 	clz	r8,r12
8000cb60:	c0 31       	brne	8000cb66 <__avr32_umod64+0x52>
8000cb62:	18 16       	sub	r6,r12
8000cb64:	c3 68       	rjmp	8000cbd0 <__avr32_umod64+0xbc>
8000cb66:	f0 03 11 20 	rsub	r3,r8,32
8000cb6a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb6e:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb72:	ec 08 09 49 	lsl	r9,r6,r8
8000cb76:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb7a:	f7 e9 10 09 	or	r9,r11,r9
8000cb7e:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb82:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb86:	e6 05 0d 02 	divu	r2,r3,r5
8000cb8a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb8e:	ec 02 02 4b 	mul	r11,r6,r2
8000cb92:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb96:	16 3e       	cp.w	lr,r11
8000cb98:	c0 72       	brcc	8000cba6 <__avr32_umod64+0x92>
8000cb9a:	18 0e       	add	lr,r12
8000cb9c:	18 3e       	cp.w	lr,r12
8000cb9e:	c0 43       	brcs	8000cba6 <__avr32_umod64+0x92>
8000cba0:	16 3e       	cp.w	lr,r11
8000cba2:	fd dc e3 0e 	addcs	lr,lr,r12
8000cba6:	fc 0b 01 03 	sub	r3,lr,r11
8000cbaa:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cbae:	e6 05 0d 02 	divu	r2,r3,r5
8000cbb2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbb6:	a5 36       	mul	r6,r2
8000cbb8:	0c 39       	cp.w	r9,r6
8000cbba:	c0 72       	brcc	8000cbc8 <__avr32_umod64+0xb4>
8000cbbc:	18 09       	add	r9,r12
8000cbbe:	18 39       	cp.w	r9,r12
8000cbc0:	c0 43       	brcs	8000cbc8 <__avr32_umod64+0xb4>
8000cbc2:	0c 39       	cp.w	r9,r6
8000cbc4:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbc8:	f2 06 01 06 	sub	r6,r9,r6
8000cbcc:	f4 08 09 4e 	lsl	lr,r10,r8
8000cbd0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cbd4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cbd8:	ec 0a 0d 02 	divu	r2,r6,r10
8000cbdc:	fc 09 16 10 	lsr	r9,lr,0x10
8000cbe0:	ea 02 02 4b 	mul	r11,r5,r2
8000cbe4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbe8:	16 39       	cp.w	r9,r11
8000cbea:	c0 72       	brcc	8000cbf8 <__avr32_umod64+0xe4>
8000cbec:	18 09       	add	r9,r12
8000cbee:	18 39       	cp.w	r9,r12
8000cbf0:	c0 43       	brcs	8000cbf8 <__avr32_umod64+0xe4>
8000cbf2:	16 39       	cp.w	r9,r11
8000cbf4:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbf8:	f2 0b 01 0b 	sub	r11,r9,r11
8000cbfc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cc00:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cc04:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cc08:	ea 0a 02 4a 	mul	r10,r5,r10
8000cc0c:	14 3e       	cp.w	lr,r10
8000cc0e:	c0 72       	brcc	8000cc1c <__avr32_umod64+0x108>
8000cc10:	18 0e       	add	lr,r12
8000cc12:	18 3e       	cp.w	lr,r12
8000cc14:	c0 43       	brcs	8000cc1c <__avr32_umod64+0x108>
8000cc16:	14 3e       	cp.w	lr,r10
8000cc18:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc1c:	fc 0a 01 0a 	sub	r10,lr,r10
8000cc20:	30 0b       	mov	r11,0
8000cc22:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cc26:	c7 b8       	rjmp	8000cd1c <__avr32_umod64+0x208>
8000cc28:	16 39       	cp.w	r9,r11
8000cc2a:	e0 8b 00 79 	brhi	8000cd1c <__avr32_umod64+0x208>
8000cc2e:	f2 09 12 00 	clz	r9,r9
8000cc32:	c1 21       	brne	8000cc56 <__avr32_umod64+0x142>
8000cc34:	10 3a       	cp.w	r10,r8
8000cc36:	5f 2b       	srhs	r11
8000cc38:	0a 31       	cp.w	r1,r5
8000cc3a:	5f ba       	srhi	r10
8000cc3c:	f7 ea 10 0a 	or	r10,r11,r10
8000cc40:	f2 0a 18 00 	cp.b	r10,r9
8000cc44:	c0 60       	breq	8000cc50 <__avr32_umod64+0x13c>
8000cc46:	fc 08 01 0c 	sub	r12,lr,r8
8000cc4a:	e2 05 01 46 	sbc	r6,r1,r5
8000cc4e:	18 9e       	mov	lr,r12
8000cc50:	0c 9b       	mov	r11,r6
8000cc52:	1c 9a       	mov	r10,lr
8000cc54:	c6 48       	rjmp	8000cd1c <__avr32_umod64+0x208>
8000cc56:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc5a:	f2 06 11 20 	rsub	r6,r9,32
8000cc5e:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc62:	f0 09 09 42 	lsl	r2,r8,r9
8000cc66:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc6a:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc6e:	18 48       	or	r8,r12
8000cc70:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc74:	f4 09 09 43 	lsl	r3,r10,r9
8000cc78:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc7c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc80:	16 4a       	or	r10,r11
8000cc82:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc86:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc8a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc8e:	08 91       	mov	r1,r4
8000cc90:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc94:	e8 0e 02 46 	mul	r6,r4,lr
8000cc98:	0c 3c       	cp.w	r12,r6
8000cc9a:	c0 a2       	brcc	8000ccae <__avr32_umod64+0x19a>
8000cc9c:	20 11       	sub	r1,1
8000cc9e:	10 0c       	add	r12,r8
8000cca0:	10 3c       	cp.w	r12,r8
8000cca2:	c0 63       	brcs	8000ccae <__avr32_umod64+0x19a>
8000cca4:	0c 3c       	cp.w	r12,r6
8000cca6:	f7 b1 03 01 	sublo	r1,1
8000ccaa:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ccae:	0c 1c       	sub	r12,r6
8000ccb0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ccb4:	f8 0b 0d 04 	divu	r4,r12,r11
8000ccb8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ccbc:	08 96       	mov	r6,r4
8000ccbe:	e8 0e 02 4e 	mul	lr,r4,lr
8000ccc2:	1c 3b       	cp.w	r11,lr
8000ccc4:	c0 a2       	brcc	8000ccd8 <__avr32_umod64+0x1c4>
8000ccc6:	20 16       	sub	r6,1
8000ccc8:	10 0b       	add	r11,r8
8000ccca:	10 3b       	cp.w	r11,r8
8000cccc:	c0 63       	brcs	8000ccd8 <__avr32_umod64+0x1c4>
8000ccce:	1c 3b       	cp.w	r11,lr
8000ccd0:	f7 b6 03 01 	sublo	r6,1
8000ccd4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ccd8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ccdc:	1c 1b       	sub	r11,lr
8000ccde:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cce2:	00 9e       	mov	lr,r0
8000cce4:	02 9c       	mov	r12,r1
8000cce6:	16 3c       	cp.w	r12,r11
8000cce8:	e0 8b 00 08 	brhi	8000ccf8 <__avr32_umod64+0x1e4>
8000ccec:	5f 06       	sreq	r6
8000ccee:	06 30       	cp.w	r0,r3
8000ccf0:	5f ba       	srhi	r10
8000ccf2:	ed ea 00 0a 	and	r10,r6,r10
8000ccf6:	c0 60       	breq	8000cd02 <__avr32_umod64+0x1ee>
8000ccf8:	fc 02 01 04 	sub	r4,lr,r2
8000ccfc:	f8 08 01 4c 	sbc	r12,r12,r8
8000cd00:	08 9e       	mov	lr,r4
8000cd02:	e6 0e 01 0a 	sub	r10,r3,lr
8000cd06:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cd0a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cd0e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cd12:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cd16:	f8 01 09 4c 	lsl	r12,r12,r1
8000cd1a:	18 4a       	or	r10,r12
8000cd1c:	2f dd       	sub	sp,-12
8000cd1e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 78 	sub	pc,pc,28792

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 df 	rcall	800056c4 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 d8 	rcall	800056c4 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 d1 	rcall	800056c4 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 ca 	rcall	800056c4 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
