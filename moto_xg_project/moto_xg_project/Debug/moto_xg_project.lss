
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009990  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ba00  8000ba00  0000be00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001090  8000bc00  8000bc00  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a2c  00000004  8000cc90  0000d404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000036b8  00000a30  8000d6bc  0000de30  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000de30  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001050  00000000  00000000  0000de60  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00002347  00000000  00000000  0000eeb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00025fba  00000000  00000000  000111f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00006267  00000000  00000000  000371b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000b950  00000000  00000000  0003d418  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002ae8  00000000  00000000  00048d68  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000691f  00000000  00000000  0004b850  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000c35f  00000000  00000000  0005216f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001148  00000000  00000000  0005e4d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d6 24 	sub	pc,pc,-10716

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 64       	ld.uh	r4,--r6

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 44       	or	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3c e8       	mov	r8,-50
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 f4       	sub	r4,15
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 08       	sub	r8,16
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 e8       	sub	r8,-114
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	bc 00       	st.h	lr[0x0],r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	58 d4       	cp.w	r4,13
8000208c:	00 00       	add	r0,r0
8000208e:	0a 34       	cp.w	r4,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	eb cd 40 fc 	pushm	r2-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002094:	f0 1f 00 12 	mcall	800020dc <app_cfg+0x4c>
80002098:	49 28       	lddpc	r8,800020e0 <app_cfg+0x50>
8000209a:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209c:	49 26       	lddpc	r6,800020e4 <app_cfg+0x54>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000209e:	49 37       	lddpc	r7,800020e8 <app_cfg+0x58>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020a0:	30 c2       	mov	r2,12
			connect_flag=1;	
800020a2:	30 13       	mov	r3,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a4:	10 95       	mov	r5,r8
800020a6:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020aa:	6c 08       	ld.w	r8,r6[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c0 91       	brne	800020c4 <app_cfg+0x34>
800020b4:	0f 88       	ld.ub	r8,r7[0x0]
800020b6:	58 08       	cp.w	r8,0
800020b8:	c0 61       	brne	800020c4 <app_cfg+0x34>
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020ba:	04 9c       	mov	r12,r2
800020bc:	f0 1f 00 0c 	mcall	800020ec <app_cfg+0x5c>
			connect_flag=1;	
800020c0:	ae 83       	st.b	r7[0x0],r3
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c2:	c0 78       	rjmp	800020d0 <app_cfg+0x40>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
800020c4:	0f 88       	ld.ub	r8,r7[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 41       	brne	800020d0 <app_cfg+0x40>
				//}
				
		}
		else
		{
			nop();
800020ca:	d7 03       	nop
			nop();
800020cc:	d7 03       	nop
			nop();
800020ce:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020d0:	08 9b       	mov	r11,r4
800020d2:	0a 9c       	mov	r12,r5
800020d4:	f0 1f 00 07 	mcall	800020f0 <app_cfg+0x60>
	}
800020d8:	ce 9b       	rjmp	800020aa <app_cfg+0x1a>
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	56 0c       	stdsp	sp[0x180],r12
800020e0:	00 00       	add	r0,r0
800020e2:	0a 38       	cp.w	r8,r5
800020e4:	00 00       	add	r0,r0
800020e6:	0d 64       	ld.uh	r4,--r6
800020e8:	00 00       	add	r0,r0
800020ea:	0a 40       	or	r0,r5
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	3d e8       	mov	r8,-34
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	57 74       	stdsp	sp[0x1dc],r4

800020f4 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020f4:	d4 01       	pushm	lr
  log("R");
800020f6:	48 3c       	lddpc	r12,80002100 <app_payload_tx_proc+0xc>
800020f8:	f0 1f 00 03 	mcall	80002104 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
800020fc:	d8 02       	popm	pc
800020fe:	00 00       	add	r0,r0
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	bc 08       	st.h	lr[0x0],r8
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	5c 98       	brev	r8

80002108 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002108:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000210a:	48 99       	lddpc	r9,8000212c <app_payload_rx_proc+0x24>
8000210c:	13 88       	ld.ub	r8,r9[0x0]
8000210e:	2f f8       	sub	r8,-1
80002110:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002112:	30 39       	mov	r9,3
80002114:	f2 08 18 00 	cp.b	r8,r9
80002118:	c0 71       	brne	80002126 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000211a:	30 09       	mov	r9,0
8000211c:	48 48       	lddpc	r8,8000212c <app_payload_rx_proc+0x24>
8000211e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002120:	48 4c       	lddpc	r12,80002130 <app_payload_rx_proc+0x28>
80002122:	f0 1f 00 05 	mcall	80002134 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002126:	48 58       	lddpc	r8,80002138 <app_payload_rx_proc+0x30>
80002128:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000212a:	d8 02       	popm	pc
8000212c:	00 00       	add	r0,r0
8000212e:	0a 42       	or	r2,r5
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	bc 0c       	st.h	lr[0x0],r12
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	5c 98       	brev	r8
80002138:	00 00       	add	r0,r0
8000213a:	0a 3e       	cp.w	lr,r5

8000213c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000213c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000213e:	48 3c       	lddpc	r12,80002148 <FD_brdcst_func+0xc>
80002140:	f0 1f 00 03 	mcall	8000214c <FD_brdcst_func+0x10>
	
}
80002144:	d8 02       	popm	pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	bc 18       	st.h	lr[0x2],r8
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	5c 98       	brev	r8

80002150 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002150:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002152:	48 3c       	lddpc	r12,8000215c <FD_reply_func+0xc>
80002154:	f0 1f 00 03 	mcall	80002160 <FD_reply_func+0x10>
	
	
}
80002158:	d8 02       	popm	pc
8000215a:	00 00       	add	r0,r0
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	bc 38       	st.h	lr[0x6],r8
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	5c 98       	brev	r8

80002164 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002166:	48 3c       	lddpc	r12,80002170 <FD_request_func+0xc>
80002168:	f0 1f 00 03 	mcall	80002174 <FD_request_func+0x10>
	
	
}
8000216c:	d8 02       	popm	pc
8000216e:	00 00       	add	r0,r0
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	bc 54       	st.h	lr[0xa],r4
80002174:	80 00       	ld.sh	r0,r0[0x0]
80002176:	5c 98       	brev	r8

80002178 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002178:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000217a:	48 3c       	lddpc	r12,80002184 <EnOB_brdcst_func+0xc>
8000217c:	f0 1f 00 03 	mcall	80002188 <EnOB_brdcst_func+0x10>
}
80002180:	d8 02       	popm	pc
80002182:	00 00       	add	r0,r0
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	bc 70       	st.h	lr[0xe],r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	5c 98       	brev	r8

8000218c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000218c:	eb cd 40 80 	pushm	r7,lr
80002190:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002192:	19 a9       	ld.ub	r9,r12[0x2]
80002194:	30 08       	mov	r8,0
80002196:	f0 09 18 00 	cp.b	r9,r8
8000219a:	c1 91       	brne	800021cc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000219c:	19 b8       	ld.ub	r8,r12[0x3]
8000219e:	30 19       	mov	r9,1
800021a0:	f2 08 18 00 	cp.b	r8,r9
800021a4:	c0 61       	brne	800021b0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021a6:	49 0c       	lddpc	r12,800021e4 <EnOB_reply_func+0x58>
800021a8:	f0 1f 00 10 	mcall	800021e8 <EnOB_reply_func+0x5c>
800021ac:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021b0:	58 08       	cp.w	r8,0
800021b2:	c0 61       	brne	800021be <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021b4:	48 ec       	lddpc	r12,800021ec <EnOB_reply_func+0x60>
800021b6:	f0 1f 00 0d 	mcall	800021e8 <EnOB_reply_func+0x5c>
800021ba:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021be:	1a d8       	st.w	--sp,r8
800021c0:	48 cc       	lddpc	r12,800021f0 <EnOB_reply_func+0x64>
800021c2:	f0 1f 00 0a 	mcall	800021e8 <EnOB_reply_func+0x5c>
800021c6:	2f fd       	sub	sp,-4
800021c8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021cc:	48 ac       	lddpc	r12,800021f4 <EnOB_reply_func+0x68>
800021ce:	f0 1f 00 07 	mcall	800021e8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021d2:	0f a8       	ld.ub	r8,r7[0x2]
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	48 9c       	lddpc	r12,800021f8 <EnOB_reply_func+0x6c>
800021d8:	f0 1f 00 04 	mcall	800021e8 <EnOB_reply_func+0x5c>
800021dc:	2f fd       	sub	sp,-4
800021de:	e3 cd 80 80 	ldm	sp++,r7,pc
800021e2:	00 00       	add	r0,r0
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	bc 88       	st.b	lr[0x0],r8
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	5c 98       	brev	r8
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	bc a0       	st.b	lr[0x2],r0
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	bc b4       	st.b	lr[0x3],r4
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	bc cc       	st.b	lr[0x4],r12
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	bc e8       	st.b	lr[0x6],r8

800021fc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021fe:	19 a9       	ld.ub	r9,r12[0x2]
80002200:	31 18       	mov	r8,17
80002202:	f0 09 18 00 	cp.b	r9,r8
80002206:	c0 41       	brne	8000220e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002208:	48 2c       	lddpc	r12,80002210 <SingleDetection_brdcst_func+0x14>
8000220a:	f0 1f 00 03 	mcall	80002214 <SingleDetection_brdcst_func+0x18>
8000220e:	d8 02       	popm	pc
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	bd 00       	ld.d	r0,lr
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	5c 98       	brev	r8

80002218 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002218:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000221a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000221e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002220:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xb4>
80002222:	f0 1f 00 2c 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002226:	0f 88       	ld.ub	r8,r7[0x0]
80002228:	1a d8       	st.w	--sp,r8
8000222a:	4a bc       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xbc>
8000222c:	f0 1f 00 29 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002230:	1a d5       	st.w	--sp,r5
80002232:	4a ac       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xc0>
80002234:	f0 1f 00 27 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002238:	0f a8       	ld.ub	r8,r7[0x2]
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	4a 8c       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xc4>
8000223e:	f0 1f 00 25 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002242:	2f dd       	sub	sp,-12
80002244:	58 05       	cp.w	r5,0
80002246:	c4 10       	breq	800022c8 <ButtonConfig_brdcst_func+0xb0>
80002248:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224a:	4a 64       	lddpc	r4,800022e0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000224c:	4a 63       	lddpc	r3,800022e4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000224e:	4a 72       	lddpc	r2,800022e8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002250:	4a 71       	lddpc	r1,800022ec <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002252:	4a 80       	lddpc	r0,800022f0 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002254:	0f b9       	ld.ub	r9,r7[0x3]
80002256:	0f c8       	ld.ub	r8,r7[0x4]
80002258:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225c:	1a d8       	st.w	--sp,r8
8000225e:	1a d6       	st.w	--sp,r6
80002260:	08 9c       	mov	r12,r4
80002262:	f0 1f 00 1c 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002266:	0f d9       	ld.ub	r9,r7[0x5]
80002268:	0f e8       	ld.ub	r8,r7[0x6]
8000226a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226e:	1a d8       	st.w	--sp,r8
80002270:	1a d6       	st.w	--sp,r6
80002272:	06 9c       	mov	r12,r3
80002274:	f0 1f 00 17 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002278:	0f f9       	ld.ub	r9,r7[0x7]
8000227a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000227e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002282:	1a d8       	st.w	--sp,r8
80002284:	1a d6       	st.w	--sp,r6
80002286:	04 9c       	mov	r12,r2
80002288:	f0 1f 00 12 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000228c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002290:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002294:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002298:	1a d8       	st.w	--sp,r8
8000229a:	1a d6       	st.w	--sp,r6
8000229c:	02 9c       	mov	r12,r1
8000229e:	f0 1f 00 0d 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022a2:	2f 8d       	sub	sp,-32
800022a4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022ac:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b0:	1a d8       	st.w	--sp,r8
800022b2:	1a d6       	st.w	--sp,r6
800022b4:	00 9c       	mov	r12,r0
800022b6:	f0 1f 00 07 	mcall	800022d0 <ButtonConfig_brdcst_func+0xb8>
800022ba:	2f f6       	sub	r6,-1
800022bc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022be:	2f ed       	sub	sp,-8
800022c0:	ec 05 18 00 	cp.b	r5,r6
800022c4:	fe 9b ff c8 	brhi	80002254 <ButtonConfig_brdcst_func+0x3c>
800022c8:	d8 32       	popm	r0-r7,pc
800022ca:	00 00       	add	r0,r0
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	bd 14       	ld.d	r4,--lr
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	5c 98       	brev	r8
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	bd 34       	mul	r4,lr
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	bd 48       	asr	r8,0x1c
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	bd 60       	lsl	r0,0x1c
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	bd 80       	lsr	r0,0x1c
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	bd a8       	sbr	r8,0x1c
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	bd d0       	cbr	r0,0x1d
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	bd f4       	*unknown*
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	be 1c       	st.h	pc[0x2],r12

800022f4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f4:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f8:	19 c7       	ld.ub	r7,r12[0x4]
800022fa:	19 d8       	ld.ub	r8,r12[0x5]
800022fc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002300:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002302:	48 ac       	lddpc	r12,80002328 <Phyuserinput_brdcst_func+0x34>
80002304:	f0 1f 00 0a 	mcall	8000232c <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002308:	36 08       	mov	r8,96
8000230a:	f0 07 19 00 	cp.h	r7,r8
8000230e:	c0 a1       	brne	80002322 <Phyuserinput_brdcst_func+0x2e>
80002310:	48 88       	lddpc	r8,80002330 <Phyuserinput_brdcst_func+0x3c>
80002312:	11 89       	ld.ub	r9,r8[0x0]
80002314:	30 18       	mov	r8,1
80002316:	f0 09 18 00 	cp.b	r9,r8
8000231a:	c0 41       	brne	80002322 <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
8000231c:	48 6c       	lddpc	r12,80002334 <Phyuserinput_brdcst_func+0x40>
8000231e:	f0 1f 00 04 	mcall	8000232c <Phyuserinput_brdcst_func+0x38>
80002322:	e3 cd 80 80 	ldm	sp++,r7,pc
80002326:	00 00       	add	r0,r0
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	be 40       	st.h	pc[0x8],r0
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	5c 98       	brev	r8
80002330:	00 00       	add	r0,r0
80002332:	0a 40       	or	r0,r5
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	be 60       	st.h	pc[0xc],r0

80002338 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002338:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000233c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002340:	0f 89       	ld.ub	r9,r7[0x0]
80002342:	30 08       	mov	r8,0
80002344:	f0 09 18 00 	cp.b	r9,r8
80002348:	c0 c1       	brne	80002360 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000234a:	48 9c       	lddpc	r12,8000236c <ButtonConfig_reply_func+0x34>
8000234c:	f0 1f 00 09 	mcall	80002370 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002350:	0f 98       	ld.ub	r8,r7[0x1]
80002352:	1a d8       	st.w	--sp,r8
80002354:	48 8c       	lddpc	r12,80002374 <ButtonConfig_reply_func+0x3c>
80002356:	f0 1f 00 07 	mcall	80002370 <ButtonConfig_reply_func+0x38>
8000235a:	2f fd       	sub	sp,-4
8000235c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002360:	48 6c       	lddpc	r12,80002378 <ButtonConfig_reply_func+0x40>
80002362:	f0 1f 00 04 	mcall	80002370 <ButtonConfig_reply_func+0x38>
80002366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000236a:	00 00       	add	r0,r0
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	be 70       	st.h	pc[0xe],r0
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	5c 98       	brev	r8
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	bd 34       	mul	r4,lr
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	be 88       	st.b	pc[0x0],r8

8000237c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000237c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000237e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002382:	0d 88       	ld.ub	r8,r6[0x0]
80002384:	32 49       	mov	r9,36
80002386:	f2 08 18 00 	cp.b	r8,r9
8000238a:	c2 91       	brne	800023dc <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000238c:	4a dc       	lddpc	r12,80002440 <DataSession_brdcst_func+0xc4>
8000238e:	f0 1f 00 2e 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002392:	0d a5       	ld.ub	r5,r6[0x2]
80002394:	0d b8       	ld.ub	r8,r6[0x3]
80002396:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000239a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000239c:	0d 98       	ld.ub	r8,r6[0x1]
8000239e:	1a d8       	st.w	--sp,r8
800023a0:	4a ac       	lddpc	r12,80002448 <DataSession_brdcst_func+0xcc>
800023a2:	f0 1f 00 29 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023a6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023aa:	1a d8       	st.w	--sp,r8
800023ac:	4a 8c       	lddpc	r12,8000244c <DataSession_brdcst_func+0xd0>
800023ae:	f0 1f 00 26 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023b2:	2f ed       	sub	sp,-8
800023b4:	58 05       	cp.w	r5,0
800023b6:	c4 40       	breq	8000243e <DataSession_brdcst_func+0xc2>
800023b8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023ba:	4a 64       	lddpc	r4,80002450 <DataSession_brdcst_func+0xd4>
800023bc:	ec 07 00 08 	add	r8,r6,r7
800023c0:	11 c8       	ld.ub	r8,r8[0x4]
800023c2:	1a d8       	st.w	--sp,r8
800023c4:	1a d7       	st.w	--sp,r7
800023c6:	08 9c       	mov	r12,r4
800023c8:	f0 1f 00 1f 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023cc:	2f f7       	sub	r7,-1
800023ce:	5c 57       	castu.b	r7
800023d0:	2f ed       	sub	sp,-8
800023d2:	ee 05 19 00 	cp.h	r5,r7
800023d6:	fe 9b ff f3 	brhi	800023bc <DataSession_brdcst_func+0x40>
800023da:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
800023dc:	1a d8       	st.w	--sp,r8
800023de:	49 ec       	lddpc	r12,80002454 <DataSession_brdcst_func+0xd8>
800023e0:	f0 1f 00 19 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		if (ptr->State)
800023e4:	2f fd       	sub	sp,-4
800023e6:	0d 89       	ld.ub	r9,r6[0x0]
800023e8:	30 08       	mov	r8,0
800023ea:	f0 09 18 00 	cp.b	r9,r8
800023ee:	c0 40       	breq	800023f6 <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
800023f0:	49 ac       	lddpc	r12,80002458 <DataSession_brdcst_func+0xdc>
800023f2:	f0 1f 00 15 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023f6:	0d a5       	ld.ub	r5,r6[0x2]
800023f8:	0d b8       	ld.ub	r8,r6[0x3]
800023fa:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023fe:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002400:	0d 98       	ld.ub	r8,r6[0x1]
80002402:	1a d8       	st.w	--sp,r8
80002404:	49 1c       	lddpc	r12,80002448 <DataSession_brdcst_func+0xcc>
80002406:	f0 1f 00 10 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000240a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000240e:	1a d8       	st.w	--sp,r8
80002410:	48 fc       	lddpc	r12,8000244c <DataSession_brdcst_func+0xd0>
80002412:	f0 1f 00 0d 	mcall	80002444 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002416:	2f ed       	sub	sp,-8
80002418:	58 05       	cp.w	r5,0
8000241a:	c1 20       	breq	8000243e <DataSession_brdcst_func+0xc2>
8000241c:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000241e:	48 d4       	lddpc	r4,80002450 <DataSession_brdcst_func+0xd4>
80002420:	ec 07 00 08 	add	r8,r6,r7
80002424:	11 c8       	ld.ub	r8,r8[0x4]
80002426:	1a d8       	st.w	--sp,r8
80002428:	1a d7       	st.w	--sp,r7
8000242a:	08 9c       	mov	r12,r4
8000242c:	f0 1f 00 06 	mcall	80002444 <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002430:	2f f7       	sub	r7,-1
80002432:	5c 57       	castu.b	r7
80002434:	2f ed       	sub	sp,-8
80002436:	ee 05 19 00 	cp.h	r5,r7
8000243a:	fe 9b ff f3 	brhi	80002420 <DataSession_brdcst_func+0xa4>
8000243e:	d8 22       	popm	r4-r7,pc
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	be a4       	st.b	pc[0x2],r4
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	5c 98       	brev	r8
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	be b8       	st.b	pc[0x3],r8
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	be d0       	st.b	pc[0x5],r0
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	be ec       	st.b	pc[0x6],r12
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	bf 04       	ld.d	r4,pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	bf 14       	ld.d	r4,--pc

8000245c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000245c:	eb cd 40 80 	pushm	r7,lr
80002460:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002462:	19 a9       	ld.ub	r9,r12[0x2]
80002464:	30 08       	mov	r8,0
80002466:	f0 09 18 00 	cp.b	r9,r8
8000246a:	c1 11       	brne	8000248c <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000246c:	49 3c       	lddpc	r12,800024b8 <DataSession_reply_func+0x5c>
8000246e:	f0 1f 00 14 	mcall	800024bc <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002472:	0f b8       	ld.ub	r8,r7[0x3]
80002474:	1a d8       	st.w	--sp,r8
80002476:	49 3c       	lddpc	r12,800024c0 <DataSession_reply_func+0x64>
80002478:	f0 1f 00 11 	mcall	800024bc <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
8000247c:	0f c8       	ld.ub	r8,r7[0x4]
8000247e:	1a d8       	st.w	--sp,r8
80002480:	49 1c       	lddpc	r12,800024c4 <DataSession_reply_func+0x68>
80002482:	f0 1f 00 0f 	mcall	800024bc <DataSession_reply_func+0x60>
80002486:	2f ed       	sub	sp,-8
80002488:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
8000248c:	48 fc       	lddpc	r12,800024c8 <DataSession_reply_func+0x6c>
8000248e:	f0 1f 00 0c 	mcall	800024bc <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
80002492:	0f a8       	ld.ub	r8,r7[0x2]
80002494:	1a d8       	st.w	--sp,r8
80002496:	48 ec       	lddpc	r12,800024cc <DataSession_reply_func+0x70>
80002498:	f0 1f 00 09 	mcall	800024bc <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
8000249c:	0f b8       	ld.ub	r8,r7[0x3]
8000249e:	1a d8       	st.w	--sp,r8
800024a0:	48 cc       	lddpc	r12,800024d0 <DataSession_reply_func+0x74>
800024a2:	f0 1f 00 07 	mcall	800024bc <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800024a6:	0f c8       	ld.ub	r8,r7[0x4]
800024a8:	1a d8       	st.w	--sp,r8
800024aa:	48 bc       	lddpc	r12,800024d4 <DataSession_reply_func+0x78>
800024ac:	f0 1f 00 04 	mcall	800024bc <DataSession_reply_func+0x60>
800024b0:	2f dd       	sub	sp,-12
800024b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b6:	00 00       	add	r0,r0
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	bf 2c       	st.d	pc++,r12
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	5c 98       	brev	r8
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	bf 3c       	mul	r12,pc
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	bf 48       	asr	r8,0x1e
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	bf 54       	asr	r4,0x1f
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	bf 64       	lsl	r4,0x1e
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	bf 74       	lsl	r4,0x1f
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	bf 80       	lsr	r0,0x1e

800024d8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800024dc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800024e0:	0f 98       	ld.ub	r8,r7[0x1]
800024e2:	1a d8       	st.w	--sp,r8
800024e4:	48 bc       	lddpc	r12,80002510 <CallControl_brdcst_func+0x38>
800024e6:	f0 1f 00 0c 	mcall	80002514 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024ea:	2f fd       	sub	sp,-4
800024ec:	0f 99       	ld.ub	r9,r7[0x1]
800024ee:	30 38       	mov	r8,3
800024f0:	f0 09 18 00 	cp.b	r9,r8
800024f4:	c0 41       	brne	800024fc <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024f6:	30 09       	mov	r9,0
800024f8:	48 88       	lddpc	r8,80002518 <CallControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024fc:	0f 99       	ld.ub	r9,r7[0x1]
800024fe:	30 48       	mov	r8,4
80002500:	f0 09 18 00 	cp.b	r9,r8
80002504:	c0 41       	brne	8000250c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002506:	30 19       	mov	r9,1
80002508:	48 48       	lddpc	r8,80002518 <CallControl_brdcst_func+0x40>
8000250a:	b0 89       	st.b	r8[0x0],r9
8000250c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	bf 8c       	lsr	r12,0x1e
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	5c 98       	brev	r8
80002518:	00 00       	add	r0,r0
8000251a:	0a 3d       	cp.w	sp,r5

8000251c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002524:	0f 99       	ld.ub	r9,r7[0x1]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c0 71       	brne	8000253a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000252e:	48 ac       	lddpc	r12,80002554 <TransmitControl_brdcst_func+0x38>
80002530:	f0 1f 00 0a 	mcall	80002558 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002534:	30 09       	mov	r9,0
80002536:	48 a8       	lddpc	r8,8000255c <TransmitControl_brdcst_func+0x40>
80002538:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000253a:	0f 99       	ld.ub	r9,r7[0x1]
8000253c:	30 18       	mov	r8,1
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 71       	brne	80002550 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002544:	48 7c       	lddpc	r12,80002560 <TransmitControl_brdcst_func+0x44>
80002546:	f0 1f 00 05 	mcall	80002558 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000254a:	30 19       	mov	r9,1
8000254c:	48 48       	lddpc	r8,8000255c <TransmitControl_brdcst_func+0x40>
8000254e:	b0 89       	st.b	r8[0x0],r9
80002550:	e3 cd 80 80 	ldm	sp++,r7,pc
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	bf a4       	sbr	r4,0x1e
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	5c 98       	brev	r8
8000255c:	00 00       	add	r0,r0
8000255e:	0a 3c       	cp.w	r12,r5
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	bf bc       	sbr	r12,0x1f

80002564 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002564:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002568:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000256c:	0f 89       	ld.ub	r9,r7[0x0]
8000256e:	30 08       	mov	r8,0
80002570:	f0 09 18 00 	cp.b	r9,r8
80002574:	c1 61       	brne	800025a0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002576:	48 ec       	lddpc	r12,800025ac <TransmitControl_reply_func+0x48>
80002578:	f0 1f 00 0e 	mcall	800025b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000257c:	0f 98       	ld.ub	r8,r7[0x1]
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 dc       	lddpc	r12,800025b4 <TransmitControl_reply_func+0x50>
80002582:	f0 1f 00 0c 	mcall	800025b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002586:	0f a8       	ld.ub	r8,r7[0x2]
80002588:	1a d8       	st.w	--sp,r8
8000258a:	48 cc       	lddpc	r12,800025b8 <TransmitControl_reply_func+0x54>
8000258c:	f0 1f 00 09 	mcall	800025b0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002590:	0f b8       	ld.ub	r8,r7[0x3]
80002592:	1a d8       	st.w	--sp,r8
80002594:	48 ac       	lddpc	r12,800025bc <TransmitControl_reply_func+0x58>
80002596:	f0 1f 00 07 	mcall	800025b0 <TransmitControl_reply_func+0x4c>
8000259a:	2f dd       	sub	sp,-12
8000259c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800025a0:	48 8c       	lddpc	r12,800025c0 <TransmitControl_reply_func+0x5c>
800025a2:	f0 1f 00 04 	mcall	800025b0 <TransmitControl_reply_func+0x4c>
800025a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800025aa:	00 00       	add	r0,r0
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	bf d0       	cbr	r0,0x1f
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	5c 98       	brev	r8
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	bf ec       	*unknown*
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	c0 00       	breq	800025ba <TransmitControl_reply_func+0x56>
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	c0 1c       	rcall	800025c0 <TransmitControl_reply_func+0x5c>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	c0 2c       	rcall	800025c6 <AudioRoutingControl_reply_func+0x2>

800025c4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800025c4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025c6:	19 a9       	ld.ub	r9,r12[0x2]
800025c8:	30 08       	mov	r8,0
800025ca:	f0 09 18 00 	cp.b	r9,r8
800025ce:	c0 51       	brne	800025d8 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800025d0:	48 4c       	lddpc	r12,800025e0 <AudioRoutingControl_reply_func+0x1c>
800025d2:	f0 1f 00 05 	mcall	800025e4 <AudioRoutingControl_reply_func+0x20>
800025d6:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800025d8:	48 4c       	lddpc	r12,800025e8 <AudioRoutingControl_reply_func+0x24>
800025da:	f0 1f 00 03 	mcall	800025e4 <AudioRoutingControl_reply_func+0x20>
800025de:	d8 02       	popm	pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c0 44       	brge	800025ea <AudioRoutingControl_reply_func+0x26>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	5c 98       	brev	r8
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c0 54       	brge	800025f4 <Volume_reply_func+0x8>

800025ec <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025f4:	0f 89       	ld.ub	r9,r7[0x0]
800025f6:	30 08       	mov	r8,0
800025f8:	f0 09 18 00 	cp.b	r9,r8
800025fc:	c1 b1       	brne	80002632 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025fe:	0f b8       	ld.ub	r8,r7[0x3]
80002600:	31 09       	mov	r9,16
80002602:	f2 08 18 00 	cp.b	r8,r9
80002606:	c0 f1       	brne	80002624 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002608:	48 dc       	lddpc	r12,8000263c <Volume_reply_func+0x50>
8000260a:	f0 1f 00 0e 	mcall	80002640 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000260e:	0f 99       	ld.ub	r9,r7[0x1]
80002610:	0f a8       	ld.ub	r8,r7[0x2]
80002612:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002616:	1a d8       	st.w	--sp,r8
80002618:	48 bc       	lddpc	r12,80002644 <Volume_reply_func+0x58>
8000261a:	f0 1f 00 0a 	mcall	80002640 <Volume_reply_func+0x54>
8000261e:	2f fd       	sub	sp,-4
80002620:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002624:	1a d8       	st.w	--sp,r8
80002626:	48 9c       	lddpc	r12,80002648 <Volume_reply_func+0x5c>
80002628:	f0 1f 00 06 	mcall	80002640 <Volume_reply_func+0x54>
8000262c:	2f fd       	sub	sp,-4
8000262e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002632:	48 7c       	lddpc	r12,8000264c <Volume_reply_func+0x60>
80002634:	f0 1f 00 03 	mcall	80002640 <Volume_reply_func+0x54>
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c0 68       	rjmp	8000264a <Volume_reply_func+0x5e>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	5c 98       	brev	r8
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	c0 7c       	rcall	80002654 <spk_brdcst_func+0x4>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c0 98       	rjmp	8000265c <spk_brdcst_func+0xc>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	c0 b0       	breq	80002664 <spk_brdcst_func+0x14>

80002650 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002650:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002652:	19 d9       	ld.ub	r9,r12[0x5]
80002654:	30 08       	mov	r8,0
80002656:	f0 09 18 00 	cp.b	r9,r8
8000265a:	c0 81       	brne	8000266a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000265c:	10 99       	mov	r9,r8
8000265e:	48 78       	lddpc	r8,80002678 <spk_brdcst_func+0x28>
80002660:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002662:	48 7c       	lddpc	r12,8000267c <spk_brdcst_func+0x2c>
80002664:	f0 1f 00 07 	mcall	80002680 <spk_brdcst_func+0x30>
80002668:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000266a:	30 19       	mov	r9,1
8000266c:	48 38       	lddpc	r8,80002678 <spk_brdcst_func+0x28>
8000266e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002670:	48 5c       	lddpc	r12,80002684 <spk_brdcst_func+0x34>
80002672:	f0 1f 00 04 	mcall	80002680 <spk_brdcst_func+0x30>
80002676:	d8 02       	popm	pc
80002678:	00 00       	add	r0,r0
8000267a:	0a 30       	cp.w	r0,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	c0 c8       	rjmp	80002696 <spk_reply_func+0xe>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	5c 98       	brev	r8
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	c0 d8       	rjmp	800026a0 <spk_reply_func+0x18>

80002688 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002688:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000268a:	19 a9       	ld.ub	r9,r12[0x2]
8000268c:	30 08       	mov	r8,0
8000268e:	f0 09 18 00 	cp.b	r9,r8
80002692:	c0 f1       	brne	800026b0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002694:	19 e9       	ld.ub	r9,r12[0x6]
80002696:	f0 09 18 00 	cp.b	r9,r8
8000269a:	c0 40       	breq	800026a2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000269c:	30 19       	mov	r9,1
8000269e:	48 98       	lddpc	r8,800026c0 <spk_reply_func+0x38>
800026a0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026a2:	19 e8       	ld.ub	r8,r12[0x6]
800026a4:	1a d8       	st.w	--sp,r8
800026a6:	48 8c       	lddpc	r12,800026c4 <spk_reply_func+0x3c>
800026a8:	f0 1f 00 08 	mcall	800026c8 <spk_reply_func+0x40>
800026ac:	2f fd       	sub	sp,-4
800026ae:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800026b0:	30 09       	mov	r9,0
800026b2:	48 48       	lddpc	r8,800026c0 <spk_reply_func+0x38>
800026b4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800026b6:	48 6c       	lddpc	r12,800026cc <spk_reply_func+0x44>
800026b8:	f0 1f 00 04 	mcall	800026c8 <spk_reply_func+0x40>
800026bc:	d8 02       	popm	pc
800026be:	00 00       	add	r0,r0
800026c0:	00 00       	add	r0,r0
800026c2:	0a 30       	cp.w	r0,r5
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	c0 e4       	brge	800026e2 <mic_brdcst_func+0x12>
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	5c 98       	brev	r8
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	c0 f4       	brge	800026ec <mic_brdcst_func+0x1c>

800026d0 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800026d8:	0f a9       	ld.ub	r9,r7[0x2]
800026da:	30 08       	mov	r8,0
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 71       	brne	800026ee <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026e2:	48 dc       	lddpc	r12,80002714 <mic_brdcst_func+0x44>
800026e4:	f0 1f 00 0d 	mcall	80002718 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026e8:	30 09       	mov	r9,0
800026ea:	48 d8       	lddpc	r8,8000271c <mic_brdcst_func+0x4c>
800026ec:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026ee:	0f a9       	ld.ub	r9,r7[0x2]
800026f0:	31 18       	mov	r8,17
800026f2:	f0 09 18 00 	cp.b	r9,r8
800026f6:	c0 d1       	brne	80002710 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026f8:	48 ac       	lddpc	r12,80002720 <mic_brdcst_func+0x50>
800026fa:	f0 1f 00 08 	mcall	80002718 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026fe:	48 89       	lddpc	r9,8000271c <mic_brdcst_func+0x4c>
80002700:	30 18       	mov	r8,1
80002702:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002704:	13 89       	ld.ub	r9,r9[0x0]
80002706:	f0 09 18 00 	cp.b	r9,r8
8000270a:	c0 31       	brne	80002710 <mic_brdcst_func+0x40>
8000270c:	48 68       	lddpc	r8,80002724 <mic_brdcst_func+0x54>
8000270e:	11 88       	ld.ub	r8,r8[0x0]
80002710:	e3 cd 80 80 	ldm	sp++,r7,pc
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	c1 00       	breq	80002736 <mic_reply_func+0xe>
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	5c 98       	brev	r8
8000271c:	00 00       	add	r0,r0
8000271e:	0a 41       	or	r1,r5
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	c1 14       	brge	80002744 <mic_reply_func+0x1c>
80002724:	00 00       	add	r0,r0
80002726:	0a 3d       	cp.w	sp,r5

80002728 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002728:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000272c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002730:	49 ac       	lddpc	r12,80002798 <mic_reply_func+0x70>
80002732:	f0 1f 00 1b 	mcall	8000279c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002736:	0f 89       	ld.ub	r9,r7[0x0]
80002738:	30 08       	mov	r8,0
8000273a:	f0 09 18 00 	cp.b	r9,r8
8000273e:	c2 71       	brne	8000278c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002740:	0f 98       	ld.ub	r8,r7[0x1]
80002742:	30 29       	mov	r9,2
80002744:	f2 08 18 00 	cp.b	r8,r9
80002748:	c1 b1       	brne	8000277e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000274a:	49 6c       	lddpc	r12,800027a0 <mic_reply_func+0x78>
8000274c:	f0 1f 00 14 	mcall	8000279c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002750:	0f a8       	ld.ub	r8,r7[0x2]
80002752:	1a d8       	st.w	--sp,r8
80002754:	49 4c       	lddpc	r12,800027a4 <mic_reply_func+0x7c>
80002756:	f0 1f 00 12 	mcall	8000279c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000275a:	0f b8       	ld.ub	r8,r7[0x3]
8000275c:	1a d8       	st.w	--sp,r8
8000275e:	49 3c       	lddpc	r12,800027a8 <mic_reply_func+0x80>
80002760:	f0 1f 00 0f 	mcall	8000279c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002764:	0f c8       	ld.ub	r8,r7[0x4]
80002766:	1a d8       	st.w	--sp,r8
80002768:	49 1c       	lddpc	r12,800027ac <mic_reply_func+0x84>
8000276a:	f0 1f 00 0d 	mcall	8000279c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000276e:	0f d8       	ld.ub	r8,r7[0x5]
80002770:	1a d8       	st.w	--sp,r8
80002772:	49 0c       	lddpc	r12,800027b0 <mic_reply_func+0x88>
80002774:	f0 1f 00 0a 	mcall	8000279c <mic_reply_func+0x74>
80002778:	2f cd       	sub	sp,-16
8000277a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000277e:	1a d8       	st.w	--sp,r8
80002780:	48 dc       	lddpc	r12,800027b4 <mic_reply_func+0x8c>
80002782:	f0 1f 00 07 	mcall	8000279c <mic_reply_func+0x74>
80002786:	2f fd       	sub	sp,-4
80002788:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000278c:	48 bc       	lddpc	r12,800027b8 <mic_reply_func+0x90>
8000278e:	f0 1f 00 04 	mcall	8000279c <mic_reply_func+0x74>
80002792:	e3 cd 80 80 	ldm	sp++,r7,pc
80002796:	00 00       	add	r0,r0
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c1 28       	rjmp	800027be <dcm_brdcst_func+0x2>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	5c 98       	brev	r8
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	c1 38       	rjmp	800027c8 <dcm_brdcst_func+0xc>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	c1 4c       	rcall	800027ce <dcm_brdcst_func+0x12>
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	c1 60       	breq	800027d6 <dcm_brdcst_func+0x1a>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	c1 7c       	rcall	800027dc <dcm_brdcst_func+0x20>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	c1 94       	brge	800027e4 <dcm_brdcst_func+0x28>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	c1 ac       	rcall	800027ea <dcm_brdcst_func+0x2e>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	c1 c4       	brge	800027f2 <dcm_brdcst_func+0x36>

800027bc <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800027bc:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800027c0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800027c4:	48 bc       	lddpc	r12,800027f0 <dcm_brdcst_func+0x34>
800027c6:	f0 1f 00 0c 	mcall	800027f4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800027ca:	0f 88       	ld.ub	r8,r7[0x0]
800027cc:	1a d8       	st.w	--sp,r8
800027ce:	48 bc       	lddpc	r12,800027f8 <dcm_brdcst_func+0x3c>
800027d0:	f0 1f 00 09 	mcall	800027f4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800027d4:	0f a8       	ld.ub	r8,r7[0x2]
800027d6:	1a d8       	st.w	--sp,r8
800027d8:	48 9c       	lddpc	r12,800027fc <dcm_brdcst_func+0x40>
800027da:	f0 1f 00 07 	mcall	800027f4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800027de:	0f 98       	ld.ub	r8,r7[0x1]
800027e0:	1a d8       	st.w	--sp,r8
800027e2:	48 8c       	lddpc	r12,80002800 <dcm_brdcst_func+0x44>
800027e4:	f0 1f 00 04 	mcall	800027f4 <dcm_brdcst_func+0x38>
800027e8:	2f dd       	sub	sp,-12
	
	
}
800027ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ee:	00 00       	add	r0,r0
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	c1 d4       	brge	8000282c <dcm_reply_func+0x28>
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	5c 98       	brev	r8
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	c1 e8       	rjmp	80002836 <dcm_reply_func+0x32>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	c1 fc       	rcall	8000283c <dcm_reply_func+0x38>
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	c2 14       	brge	80002844 <dcm_reply_func+0x40>

80002804 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002804:	eb cd 40 80 	pushm	r7,lr
80002808:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000280a:	19 a9       	ld.ub	r9,r12[0x2]
8000280c:	30 08       	mov	r8,0
8000280e:	f0 09 18 00 	cp.b	r9,r8
80002812:	c1 b1       	brne	80002848 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002814:	19 b8       	ld.ub	r8,r12[0x3]
80002816:	30 19       	mov	r9,1
80002818:	f2 08 18 00 	cp.b	r8,r9
8000281c:	c0 51       	brne	80002826 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000281e:	48 ec       	lddpc	r12,80002854 <dcm_reply_func+0x50>
80002820:	f0 1f 00 0e 	mcall	80002858 <dcm_reply_func+0x54>
80002824:	c0 a8       	rjmp	80002838 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002826:	58 08       	cp.w	r8,0
80002828:	c0 51       	brne	80002832 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000282a:	48 dc       	lddpc	r12,8000285c <dcm_reply_func+0x58>
8000282c:	f0 1f 00 0b 	mcall	80002858 <dcm_reply_func+0x54>
80002830:	c0 48       	rjmp	80002838 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002832:	48 cc       	lddpc	r12,80002860 <dcm_reply_func+0x5c>
80002834:	f0 1f 00 09 	mcall	80002858 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002838:	0f d8       	ld.ub	r8,r7[0x5]
8000283a:	1a d8       	st.w	--sp,r8
8000283c:	48 ac       	lddpc	r12,80002864 <dcm_reply_func+0x60>
8000283e:	f0 1f 00 07 	mcall	80002858 <dcm_reply_func+0x54>
80002842:	2f fd       	sub	sp,-4
80002844:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002848:	48 8c       	lddpc	r12,80002868 <dcm_reply_func+0x64>
8000284a:	f0 1f 00 04 	mcall	80002858 <dcm_reply_func+0x54>
8000284e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002852:	00 00       	add	r0,r0
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	c2 30       	breq	8000289c <DeviceInitializationStatus_brdcst_func+0x8>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	5c 98       	brev	r8
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	c2 44       	brge	800028a6 <DeviceInitializationStatus_brdcst_func+0x12>
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	c2 58       	rjmp	800028ac <DeviceInitializationStatus_brdcst_func+0x18>
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	c2 6c       	rcall	800028b2 <DeviceInitializationStatus_brdcst_func+0x1e>
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	c2 78       	rjmp	800028b8 <DeviceInitializationStatus_brdcst_func+0x24>

8000286c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000286c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000286e:	19 a9       	ld.ub	r9,r12[0x2]
80002870:	30 08       	mov	r8,0
80002872:	f0 09 18 00 	cp.b	r9,r8
80002876:	c0 51       	brne	80002880 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002878:	48 4c       	lddpc	r12,80002888 <ToneControl_reply_func+0x1c>
8000287a:	f0 1f 00 05 	mcall	8000288c <ToneControl_reply_func+0x20>
8000287e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002880:	48 4c       	lddpc	r12,80002890 <ToneControl_reply_func+0x24>
80002882:	f0 1f 00 03 	mcall	8000288c <ToneControl_reply_func+0x20>
80002886:	d8 02       	popm	pc
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	c2 84       	brge	800028da <CalculateBurst+0xe>
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	5c 98       	brev	r8
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	c2 90       	breq	800028e4 <CalculateBurst+0x18>

80002894 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002894:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002896:	19 e8       	ld.ub	r8,r12[0x6]
80002898:	30 19       	mov	r9,1
8000289a:	f2 08 18 00 	cp.b	r8,r9
8000289e:	c0 61       	brne	800028aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a0:	48 98       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028a2:	70 09       	ld.w	r9,r8[0x0]
800028a4:	a1 a9       	sbr	r9,0x0
800028a6:	91 09       	st.w	r8[0x0],r9
800028a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028aa:	30 29       	mov	r9,2
800028ac:	f2 08 18 00 	cp.b	r8,r9
800028b0:	c0 80       	breq	800028c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028b2:	48 58       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b4:	70 09       	ld.w	r9,r8[0x0]
800028b6:	e0 19 ff fc 	andl	r9,0xfffc
800028ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028bc:	f0 1f 00 03 	mcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
800028c0:	d8 02       	popm	pc
800028c2:	00 00       	add	r0,r0
800028c4:	00 00       	add	r0,r0
800028c6:	0d 64       	ld.uh	r4,--r6
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3d 3c       	mov	r12,-45

800028cc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028cc:	20 1c       	sub	r12,1
800028ce:	5c 5c       	castu.b	r12
800028d0:	31 18       	mov	r8,17
800028d2:	f0 0c 18 00 	cp.b	r12,r8
800028d6:	e0 88 00 03 	brls	800028dc <CalculateBurst+0x10>
800028da:	5e fd       	retal	0
800028dc:	48 28       	lddpc	r8,800028e4 <CalculateBurst+0x18>
800028de:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028e2:	5e fc       	retal	r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	c2 9c       	rcall	80002938 <payload_rx_process+0x18>

800028e8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028e8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ea:	48 98       	lddpc	r8,8000290c <payload_init+0x24>
800028ec:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028ee:	48 98       	lddpc	r8,80002910 <payload_init+0x28>
800028f0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028f2:	30 09       	mov	r9,0
800028f4:	1a d9       	st.w	--sp,r9
800028f6:	1a d9       	st.w	--sp,r9
800028f8:	1a d9       	st.w	--sp,r9
800028fa:	30 28       	mov	r8,2
800028fc:	e0 6a 04 00 	mov	r10,1024
80002900:	48 5b       	lddpc	r11,80002914 <payload_init+0x2c>
80002902:	48 6c       	lddpc	r12,80002918 <payload_init+0x30>
80002904:	f0 1f 00 06 	mcall	8000291c <payload_init+0x34>
80002908:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000290a:	d8 02       	popm	pc
8000290c:	00 00       	add	r0,r0
8000290e:	0a 48       	or	r8,r5
80002910:	00 00       	add	r0,r0
80002912:	0a 4c       	or	r12,r5
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	c2 e4       	brge	80002972 <set_idle_store_isr+0x6>
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	29 20       	sub	r0,-110
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	58 d4       	cp.w	r4,13

80002920 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002920:	eb cd 40 f8 	pushm	r3-r7,lr
80002924:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002926:	48 e8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	58 08       	cp.w	r8,0
8000292c:	c0 71       	brne	8000293a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000292e:	30 4b       	mov	r11,4
80002930:	30 5c       	mov	r12,5
80002932:	f0 1f 00 0c 	mcall	80002960 <payload_rx_process+0x40>
80002936:	48 a8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002938:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000293a:	48 96       	lddpc	r6,8000295c <payload_rx_process+0x3c>
8000293c:	30 05       	mov	r5,0
8000293e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002940:	48 93       	lddpc	r3,80002964 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	6c 0c       	ld.w	r12,r6[0x0]
80002944:	0a 99       	mov	r9,r5
80002946:	08 9a       	mov	r10,r4
80002948:	1a 9b       	mov	r11,sp
8000294a:	f0 1f 00 08 	mcall	80002968 <payload_rx_process+0x48>
8000294e:	58 1c       	cp.w	r12,1
80002950:	cf 91       	brne	80002942 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002952:	66 08       	ld.w	r8,r3[0x0]
80002954:	40 0c       	lddsp	r12,sp[0x0]
80002956:	5d 18       	icall	r8
80002958:	cf 5b       	rjmp	80002942 <payload_rx_process+0x22>
8000295a:	00 00       	add	r0,r0
8000295c:	00 00       	add	r0,r0
8000295e:	0a 78       	tst	r8,r5
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	52 00       	stdsp	sp[0x80],r0
80002964:	00 00       	add	r0,r0
80002966:	0a 48       	or	r8,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	4e f4       	lddpc	r4,80002b24 <phy_tx_func+0xc0>

8000296c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000296c:	d4 01       	pushm	lr
8000296e:	20 2d       	sub	sp,8
80002970:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002972:	30 09       	mov	r9,0
80002974:	fa ca ff f8 	sub	r10,sp,-8
80002978:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000297a:	1a 9b       	mov	r11,sp
8000297c:	f0 1f 00 02 	mcall	80002984 <set_idle_store_isr+0x18>
}
80002980:	2f ed       	sub	sp,-8
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	50 b0       	stdsp	sp[0x2c],r0

80002988 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002988:	d4 01       	pushm	lr
8000298a:	20 2d       	sub	sp,8
8000298c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000298e:	58 0c       	cp.w	r12,0
80002990:	c1 10       	breq	800029b2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 08       	mov	r8,0
80002994:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002996:	98 88       	ld.uh	r8,r12[0x0]
80002998:	e2 18 f0 00 	andl	r8,0xf000,COH
8000299c:	e0 48 40 00 	cp.w	r8,16384
800029a0:	c0 91       	brne	800029b2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029a2:	48 68       	lddpc	r8,800029b8 <phy_rx+0x30>
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	30 09       	mov	r9,0
800029a8:	fa ca ff fc 	sub	r10,sp,-4
800029ac:	1a 9b       	mov	r11,sp
800029ae:	f0 1f 00 04 	mcall	800029bc <phy_rx+0x34>
		}	

    }
		
 
}
800029b2:	2f ed       	sub	sp,-8
800029b4:	d8 02       	popm	pc
800029b6:	00 00       	add	r0,r0
800029b8:	00 00       	add	r0,r0
800029ba:	0a a4       	st.w	r5++,r4
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	50 b0       	stdsp	sp[0x2c],r0

800029c0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c0:	eb cd 40 80 	pushm	r7,lr
800029c4:	20 1d       	sub	sp,4
800029c6:	fa c7 ff fc 	sub	r7,sp,-4
800029ca:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029cc:	30 09       	mov	r9,0
800029ce:	12 9a       	mov	r10,r9
800029d0:	1a 9b       	mov	r11,sp
800029d2:	f0 1f 00 03 	mcall	800029dc <set_idle_store+0x1c>
}
800029d6:	2f fd       	sub	sp,-4
800029d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	51 00       	stdsp	sp[0x40],r0

800029e0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e0:	d4 01       	pushm	lr
800029e2:	20 1d       	sub	sp,4
800029e4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029e6:	98 88       	ld.uh	r8,r12[0x0]
800029e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ec:	e0 48 40 00 	cp.w	r8,16384
800029f0:	c0 d1       	brne	80002a0a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029f2:	49 08       	lddpc	r8,80002a30 <phy_tx+0x50>
800029f4:	70 08       	ld.w	r8,r8[0x0]
800029f6:	58 08       	cp.w	r8,0
800029f8:	c1 a0       	breq	80002a2c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029fa:	48 e8       	lddpc	r8,80002a30 <phy_tx+0x50>
800029fc:	70 0c       	ld.w	r12,r8[0x0]
800029fe:	30 09       	mov	r9,0
80002a00:	12 9a       	mov	r10,r9
80002a02:	1a 9b       	mov	r11,sp
80002a04:	f0 1f 00 0c 	mcall	80002a34 <phy_tx+0x54>
80002a08:	c1 28       	rjmp	80002a2c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a0a:	e0 48 10 00 	cp.w	r8,4096
80002a0e:	5f 0a       	sreq	r10
80002a10:	e0 48 20 00 	cp.w	r8,8192
80002a14:	5f 09       	sreq	r9
80002a16:	f5 e9 10 09 	or	r9,r10,r9
80002a1a:	c0 71       	brne	80002a28 <phy_tx+0x48>
80002a1c:	e0 48 50 00 	cp.w	r8,20480
80002a20:	c0 40       	breq	80002a28 <phy_tx+0x48>
80002a22:	e0 48 60 00 	cp.w	r8,24576
80002a26:	c0 31       	brne	80002a2c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a28:	48 48       	lddpc	r8,80002a38 <phy_tx+0x58>
80002a2a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a2c:	2f fd       	sub	sp,-4
80002a2e:	d8 02       	popm	pc
80002a30:	00 00       	add	r0,r0
80002a32:	0a b0       	st.h	r5++,r0
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	51 00       	stdsp	sp[0x40],r0
80002a38:	00 00       	add	r0,r0
80002a3a:	0a 98       	mov	r8,r5

80002a3c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a3c:	d4 01       	pushm	lr
80002a3e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a40:	30 08       	mov	r8,0
80002a42:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a44:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a46:	1a 9a       	mov	r10,sp
80002a48:	fa cb ff fc 	sub	r11,sp,-4
80002a4c:	f0 1f 00 05 	mcall	80002a60 <get_idle_store_isr+0x24>
80002a50:	58 1c       	cp.w	r12,1
80002a52:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a56:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a5a:	2f ed       	sub	sp,-8
80002a5c:	d8 02       	popm	pc
80002a5e:	00 00       	add	r0,r0
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	4e 04       	lddpc	r4,80002be0 <payload_rx+0x24>

80002a64 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a64:	eb cd 40 c0 	pushm	r6-r7,lr
80002a68:	20 1d       	sub	sp,4
80002a6a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a6c:	4b a8       	lddpc	r8,80002b54 <phy_tx_func+0xf0>
80002a6e:	70 08       	ld.w	r8,r8[0x0]
80002a70:	58 08       	cp.w	r8,0
80002a72:	c6 60       	breq	80002b3e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a74:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a76:	30 08       	mov	r8,0
80002a78:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a7a:	4b 88       	lddpc	r8,80002b58 <phy_tx_func+0xf4>
80002a7c:	70 08       	ld.w	r8,r8[0x0]
80002a7e:	58 18       	cp.w	r8,1
80002a80:	c2 60       	breq	80002acc <phy_tx_func+0x68>
80002a82:	c0 43       	brcs	80002a8a <phy_tx_func+0x26>
80002a84:	58 28       	cp.w	r8,2
80002a86:	c5 c1       	brne	80002b3e <phy_tx_func+0xda>
80002a88:	c5 58       	rjmp	80002b32 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a8a:	4b 38       	lddpc	r8,80002b54 <phy_tx_func+0xf0>
80002a8c:	70 0c       	ld.w	r12,r8[0x0]
80002a8e:	1a 9a       	mov	r10,sp
80002a90:	4b 3b       	lddpc	r11,80002b5c <phy_tx_func+0xf8>
80002a92:	f0 1f 00 34 	mcall	80002b60 <phy_tx_func+0xfc>
80002a96:	58 1c       	cp.w	r12,1
80002a98:	c1 41       	brne	80002ac0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a9a:	4b 18       	lddpc	r8,80002b5c <phy_tx_func+0xf8>
80002a9c:	70 08       	ld.w	r8,r8[0x0]
80002a9e:	90 08       	ld.sh	r8,r8[0x0]
80002aa0:	10 9a       	mov	r10,r8
80002aa2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002aa6:	4b 09       	lddpc	r9,80002b64 <phy_tx_func+0x100>
80002aa8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002aaa:	5c 78       	castu.h	r8
80002aac:	ea 18 ab cd 	orh	r8,0xabcd
80002ab0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ab2:	30 19       	mov	r9,1
80002ab4:	4a d8       	lddpc	r8,80002b68 <phy_tx_func+0x104>
80002ab6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ab8:	30 19       	mov	r9,1
80002aba:	4a 88       	lddpc	r8,80002b58 <phy_tx_func+0xf4>
80002abc:	91 09       	st.w	r8[0x0],r9
80002abe:	c4 08       	rjmp	80002b3e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ac0:	e0 68 5a 5a 	mov	r8,23130
80002ac4:	ea 18 ab cd 	orh	r8,0xabcd
80002ac8:	8f 18       	st.w	r7[0x4],r8
80002aca:	c3 a8       	rjmp	80002b3e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002acc:	4a 7a       	lddpc	r10,80002b68 <phy_tx_func+0x104>
80002ace:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ad0:	4a 39       	lddpc	r9,80002b5c <phy_tx_func+0xf8>
80002ad2:	72 09       	ld.w	r9,r9[0x0]
80002ad4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ad8:	b1 69       	lsl	r9,0x10
80002ada:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002adc:	2f f8       	sub	r8,-1
80002ade:	5c 58       	castu.b	r8
80002ae0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002ae2:	4a 1b       	lddpc	r11,80002b64 <phy_tx_func+0x100>
80002ae4:	96 0c       	ld.sh	r12,r11[0x0]
80002ae6:	20 2c       	sub	r12,2
80002ae8:	5c 8c       	casts.h	r12
80002aea:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002aee:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002af0:	30 0b       	mov	r11,0
80002af2:	f6 0a 19 00 	cp.h	r10,r11
80002af6:	e0 89 00 09 	brgt	80002b08 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002afa:	e8 19 00 ba 	orl	r9,0xba
80002afe:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b00:	30 09       	mov	r9,0
80002b02:	49 68       	lddpc	r8,80002b58 <phy_tx_func+0xf4>
80002b04:	91 09       	st.w	r8[0x0],r9
80002b06:	c1 c8       	rjmp	80002b3e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b08:	49 5a       	lddpc	r10,80002b5c <phy_tx_func+0xf8>
80002b0a:	74 0a       	ld.w	r10,r10[0x0]
80002b0c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b10:	14 49       	or	r9,r10
80002b12:	8f 19       	st.w	r7[0x4],r9
80002b14:	2f f8       	sub	r8,-1
80002b16:	49 59       	lddpc	r9,80002b68 <phy_tx_func+0x104>
80002b18:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b1a:	20 2c       	sub	r12,2
80002b1c:	49 28       	lddpc	r8,80002b64 <phy_tx_func+0x100>
80002b1e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b20:	30 08       	mov	r8,0
80002b22:	f0 0c 19 00 	cp.h	r12,r8
80002b26:	e0 89 00 0c 	brgt	80002b3e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b2a:	30 29       	mov	r9,2
80002b2c:	48 b8       	lddpc	r8,80002b58 <phy_tx_func+0xf4>
80002b2e:	91 09       	st.w	r8[0x0],r9
80002b30:	c0 78       	rjmp	80002b3e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b32:	fc 18 00 ba 	movh	r8,0xba
80002b36:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b38:	30 09       	mov	r9,0
80002b3a:	48 88       	lddpc	r8,80002b58 <phy_tx_func+0xf4>
80002b3c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b3e:	e0 68 5a 5a 	mov	r8,23130
80002b42:	ea 18 ab cd 	orh	r8,0xabcd
80002b46:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b48:	30 08       	mov	r8,0
80002b4a:	8f 38       	st.w	r7[0xc],r8
}
80002b4c:	2f fd       	sub	sp,-4
80002b4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b52:	00 00       	add	r0,r0
80002b54:	00 00       	add	r0,r0
80002b56:	0a b0       	st.h	r5++,r0
80002b58:	00 00       	add	r0,r0
80002b5a:	0a 6c       	and	r12,r5
80002b5c:	00 00       	add	r0,r0
80002b5e:	0a b8       	st.h	r5++,r8
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	4e 04       	lddpc	r4,80002ce0 <phy_rx_func+0xc4>
80002b64:	00 00       	add	r0,r0
80002b66:	0a 94       	mov	r4,r5
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 50       	eor	r0,r5

80002b6c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b6c:	d4 01       	pushm	lr
80002b6e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b70:	30 0a       	mov	r10,0
80002b72:	fa cb ff fc 	sub	r11,sp,-4
80002b76:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b78:	14 99       	mov	r9,r10
80002b7a:	1a 9b       	mov	r11,sp
80002b7c:	f0 1f 00 05 	mcall	80002b90 <get_idle_store+0x24>
80002b80:	58 1c       	cp.w	r12,1
80002b82:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b86:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002b8a:	2f fd       	sub	sp,-4
80002b8c:	d8 02       	popm	pc
80002b8e:	00 00       	add	r0,r0
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	4e f4       	lddpc	r4,80002d4c <phy_rx_func+0x130>

80002b94 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002b94:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002b96:	48 5b       	lddpc	r11,80002ba8 <phy_init+0x14>
80002b98:	48 5c       	lddpc	r12,80002bac <phy_init+0x18>
80002b9a:	f0 1f 00 06 	mcall	80002bb0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002b9e:	f0 1f 00 06 	mcall	80002bb4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002ba2:	f0 1f 00 06 	mcall	80002bb8 <phy_init+0x24>
	
}
80002ba6:	d8 02       	popm	pc
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	2a 64       	sub	r4,-90
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	2c 1c       	sub	r12,-63
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	3c 64       	mov	r4,-58
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	3c 78       	mov	r8,-57
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	45 94       	lddsp	r4,sp[0x164]

80002bbc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bbc:	d4 01       	pushm	lr
80002bbe:	20 2d       	sub	sp,8
80002bc0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bc2:	30 08       	mov	r8,0
80002bc4:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002bc6:	48 f8       	lddpc	r8,80002c00 <payload_rx+0x44>
80002bc8:	70 08       	ld.w	r8,r8[0x0]
80002bca:	58 08       	cp.w	r8,0
80002bcc:	c0 71       	brne	80002bda <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bce:	30 4b       	mov	r11,4
80002bd0:	30 5c       	mov	r12,5
80002bd2:	f0 1f 00 0d 	mcall	80002c04 <payload_rx+0x48>
80002bd6:	48 b8       	lddpc	r8,80002c00 <payload_rx+0x44>
80002bd8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002bda:	48 a8       	lddpc	r8,80002c00 <payload_rx+0x44>
80002bdc:	70 0c       	ld.w	r12,r8[0x0]
80002bde:	30 09       	mov	r9,0
80002be0:	fa ca ff fc 	sub	r10,sp,-4
80002be4:	1a 9b       	mov	r11,sp
80002be6:	f0 1f 00 09 	mcall	80002c08 <payload_rx+0x4c>
80002bea:	c0 91       	brne	80002bfc <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002bec:	48 88       	lddpc	r8,80002c0c <payload_rx+0x50>
80002bee:	70 0c       	ld.w	r12,r8[0x0]
80002bf0:	40 0b       	lddsp	r11,sp[0x0]
80002bf2:	f0 1f 00 08 	mcall	80002c10 <payload_rx+0x54>
		logFromISR("mm");
80002bf6:	48 8c       	lddpc	r12,80002c14 <payload_rx+0x58>
80002bf8:	f0 1f 00 08 	mcall	80002c18 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002bfc:	2f ed       	sub	sp,-8
80002bfe:	d8 02       	popm	pc
80002c00:	00 00       	add	r0,r0
80002c02:	0a 78       	tst	r8,r5
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	52 00       	stdsp	sp[0x80],r0
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	50 b0       	stdsp	sp[0x2c],r0
80002c0c:	00 00       	add	r0,r0
80002c0e:	0a 5c       	eor	r12,r5
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	29 6c       	sub	r12,-106
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	c2 f0       	breq	80002c74 <phy_rx_func+0x58>
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	5e 24       	reths	r4

80002c1c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c1c:	eb cd 40 e0 	pushm	r5-r7,lr
80002c20:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c22:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c26:	70 08       	ld.w	r8,r8[0x0]
80002c28:	58 08       	cp.w	r8,0
80002c2a:	e0 80 01 08 	breq	80002e3a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c2e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c30:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c34:	70 09       	ld.w	r9,r8[0x0]
80002c36:	2f f9       	sub	r9,-1
80002c38:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c3a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c3e:	70 08       	ld.w	r8,r8[0x0]
80002c40:	58 18       	cp.w	r8,1
80002c42:	e0 80 00 85 	breq	80002d4c <phy_rx_func+0x130>
80002c46:	c0 73       	brcs	80002c54 <phy_rx_func+0x38>
80002c48:	58 28       	cp.w	r8,2
80002c4a:	c5 c0       	breq	80002d02 <phy_rx_func+0xe6>
80002c4c:	58 38       	cp.w	r8,3
80002c4e:	e0 81 00 f6 	brne	80002e3a <phy_rx_func+0x21e>
80002c52:	cd 58       	rjmp	80002dfc <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c54:	e0 6a 5a 5a 	mov	r10,23130
80002c58:	ea 1a ab cd 	orh	r10,0xabcd
80002c5c:	14 36       	cp.w	r6,r10
80002c5e:	e0 80 00 ee 	breq	80002e3a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c62:	ec 08 16 10 	lsr	r8,r6,0x10
80002c66:	e0 48 ab cd 	cp.w	r8,43981
80002c6a:	e0 81 00 e8 	brne	80002e3a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c6e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c72:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c76:	20 28       	sub	r8,2
80002c78:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c7c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c7e:	30 09       	mov	r9,0
80002c80:	f2 08 19 00 	cp.h	r8,r9
80002c84:	e0 8a 00 db 	brle	80002e3a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002c88:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002c8c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002c8e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002c92:	70 0c       	ld.w	r12,r8[0x0]
80002c94:	f0 1f 03 88 	mcall	80003ab4 <phy_rx_func+0xe98>
80002c98:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002c9c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002c9e:	58 0c       	cp.w	r12,0
80002ca0:	e0 80 00 cd 	breq	80002e3a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002ca4:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002ca8:	90 09       	ld.sh	r9,r8[0x0]
80002caa:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cae:	2f f9       	sub	r9,-1
80002cb0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cb2:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cb6:	74 0a       	ld.w	r10,r10[0x0]
80002cb8:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002cbc:	76 0b       	ld.w	r11,r11[0x0]
80002cbe:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cc2:	2f f9       	sub	r9,-1
80002cc4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002cc6:	e2 16 0f 00 	andl	r6,0xf00,COH
80002cca:	e0 46 01 00 	cp.w	r6,256
80002cce:	c0 c0       	breq	80002ce6 <phy_rx_func+0xca>
80002cd0:	e0 8b 00 05 	brhi	80002cda <phy_rx_func+0xbe>
80002cd4:	58 06       	cp.w	r6,0
80002cd6:	c0 80       	breq	80002ce6 <phy_rx_func+0xca>
80002cd8:	c0 c8       	rjmp	80002cf0 <phy_rx_func+0xd4>
80002cda:	e0 46 02 00 	cp.w	r6,512
80002cde:	c0 40       	breq	80002ce6 <phy_rx_func+0xca>
80002ce0:	e0 46 03 00 	cp.w	r6,768
80002ce4:	c0 61       	brne	80002cf0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ce6:	30 29       	mov	r9,2
80002ce8:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002cec:	91 09       	st.w	r8[0x0],r9
80002cee:	ca 68       	rjmp	80002e3a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002cf0:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002cf4:	70 0c       	ld.w	r12,r8[0x0]
80002cf6:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002cfa:	70 0b       	ld.w	r11,r8[0x0]
80002cfc:	f0 1f 03 70 	mcall	80003abc <phy_rx_func+0xea0>
80002d00:	c9 d8       	rjmp	80002e3a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d02:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d06:	b1 86       	lsr	r6,0x10
80002d08:	14 06       	add	r6,r10
80002d0a:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d0e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d10:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d14:	90 09       	ld.sh	r9,r8[0x0]
80002d16:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d1a:	76 0b       	ld.w	r11,r11[0x0]
80002d1c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d20:	2f f9       	sub	r9,-1
80002d22:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d24:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d28:	92 08       	ld.sh	r8,r9[0x0]
80002d2a:	20 28       	sub	r8,2
80002d2c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d2e:	30 09       	mov	r9,0
80002d30:	f2 08 19 00 	cp.h	r8,r9
80002d34:	e0 8a 00 07 	brle	80002d42 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d38:	30 19       	mov	r9,1
80002d3a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d3e:	91 09       	st.w	r8[0x0],r9
80002d40:	c7 d8       	rjmp	80002e3a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d42:	30 39       	mov	r9,3
80002d44:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d48:	91 09       	st.w	r8[0x0],r9
80002d4a:	c7 88       	rjmp	80002e3a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d4c:	ec 0a 14 10 	asr	r10,r6,0x10
80002d50:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d54:	90 09       	ld.sh	r9,r8[0x0]
80002d56:	14 09       	add	r9,r10
80002d58:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d5a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d5e:	92 08       	ld.sh	r8,r9[0x0]
80002d60:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d64:	76 0b       	ld.w	r11,r11[0x0]
80002d66:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d6a:	2f f8       	sub	r8,-1
80002d6c:	5c 88       	casts.h	r8
80002d6e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d70:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d74:	94 09       	ld.sh	r9,r10[0x0]
80002d76:	20 29       	sub	r9,2
80002d78:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d7a:	30 0a       	mov	r10,0
80002d7c:	f4 09 19 00 	cp.h	r9,r10
80002d80:	e0 89 00 20 	brgt	80002dc0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002d84:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002d88:	e0 46 00 ba 	cp.w	r6,186
80002d8c:	c0 d1       	brne	80002da6 <phy_rx_func+0x18a>
80002d8e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002d92:	90 09       	ld.sh	r9,r8[0x0]
80002d94:	f4 09 19 00 	cp.h	r9,r10
80002d98:	c0 71       	brne	80002da6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002d9a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002d9e:	70 0c       	ld.w	r12,r8[0x0]
80002da0:	f0 1f 03 49 	mcall	80003ac4 <phy_rx_func+0xea8>
80002da4:	c0 98       	rjmp	80002db6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002da6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002daa:	70 0c       	ld.w	r12,r8[0x0]
80002dac:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002db0:	70 0b       	ld.w	r11,r8[0x0]
80002db2:	f0 1f 03 43 	mcall	80003abc <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002db6:	30 09       	mov	r9,0
80002db8:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dbc:	91 09       	st.w	r8[0x0],r9
80002dbe:	c3 e8       	rjmp	80002e3a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002dc0:	5c 86       	casts.h	r6
80002dc2:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002dc6:	92 0a       	ld.sh	r10,r9[0x0]
80002dc8:	0c 0a       	add	r10,r6
80002dca:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dcc:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002dd0:	72 09       	ld.w	r9,r9[0x0]
80002dd2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002dd6:	2f f8       	sub	r8,-1
80002dd8:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002ddc:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002dde:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002de2:	92 08       	ld.sh	r8,r9[0x0]
80002de4:	20 28       	sub	r8,2
80002de6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002de8:	30 09       	mov	r9,0
80002dea:	f2 08 19 00 	cp.h	r8,r9
80002dee:	e0 89 00 26 	brgt	80002e3a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002df2:	30 39       	mov	r9,3
80002df4:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002df8:	91 09       	st.w	r8[0x0],r9
80002dfa:	c2 08       	rjmp	80002e3a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002dfc:	e6 16 00 ff 	andh	r6,0xff,COH
80002e00:	fc 19 00 ba 	movh	r9,0xba
80002e04:	12 36       	cp.w	r6,r9
80002e06:	c0 e1       	brne	80002e22 <phy_rx_func+0x206>
80002e08:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e0c:	90 09       	ld.sh	r9,r8[0x0]
80002e0e:	30 08       	mov	r8,0
80002e10:	f0 09 19 00 	cp.h	r9,r8
80002e14:	c0 71       	brne	80002e22 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e16:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e1a:	70 0c       	ld.w	r12,r8[0x0]
80002e1c:	f0 1f 03 2a 	mcall	80003ac4 <phy_rx_func+0xea8>
80002e20:	c0 98       	rjmp	80002e32 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e22:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e26:	70 0c       	ld.w	r12,r8[0x0]
80002e28:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e2c:	70 0b       	ld.w	r11,r8[0x0]
80002e2e:	f0 1f 03 24 	mcall	80003abc <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e32:	30 09       	mov	r9,0
80002e34:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e38:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e3a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e3e:	11 89       	ld.ub	r9,r8[0x0]
80002e40:	30 08       	mov	r8,0
80002e42:	f0 09 18 00 	cp.b	r9,r8
80002e46:	c1 31       	brne	80002e6c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e48:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e4c:	6c 0c       	ld.w	r12,r6[0x0]
80002e4e:	f0 1f 03 1a 	mcall	80003ab4 <phy_rx_func+0xe98>
80002e52:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e56:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e58:	6c 0c       	ld.w	r12,r6[0x0]
80002e5a:	f0 1f 03 17 	mcall	80003ab4 <phy_rx_func+0xe98>
80002e5e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e62:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e64:	30 19       	mov	r9,1
80002e66:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e6a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e6c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e70:	70 08       	ld.w	r8,r8[0x0]
80002e72:	58 28       	cp.w	r8,2
80002e74:	e0 80 01 98 	breq	800031a4 <phy_rx_func+0x588>
80002e78:	e0 8b 00 06 	brhi	80002e84 <phy_rx_func+0x268>
80002e7c:	58 08       	cp.w	r8,0
80002e7e:	c0 b0       	breq	80002e94 <phy_rx_func+0x278>
80002e80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e84:	58 38       	cp.w	r8,3
80002e86:	e0 80 05 c5 	breq	80003a10 <phy_rx_func+0xdf4>
80002e8a:	58 48       	cp.w	r8,4
80002e8c:	e0 81 06 05 	brne	80003a96 <phy_rx_func+0xe7a>
80002e90:	e0 8f 02 4b 	bral	80003326 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002e94:	6e 28       	ld.w	r8,r7[0x8]
80002e96:	e0 6a 5a 5a 	mov	r10,23130
80002e9a:	ea 1a ab cd 	orh	r10,0xabcd
80002e9e:	14 38       	cp.w	r8,r10
80002ea0:	c0 71       	brne	80002eae <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002ea2:	30 09       	mov	r9,0
80002ea4:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002ea8:	91 09       	st.w	r8[0x0],r9
80002eaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002eae:	10 99       	mov	r9,r8
80002eb0:	e0 19 00 00 	andl	r9,0x0
80002eb4:	fc 1a ab cd 	movh	r10,0xabcd
80002eb8:	14 39       	cp.w	r9,r10
80002eba:	e0 81 05 ee 	brne	80003a96 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002ebe:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ec2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ec6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ec8:	6e 29       	ld.w	r9,r7[0x8]
80002eca:	e2 19 f0 00 	andl	r9,0xf000,COH
80002ece:	e0 49 c0 00 	cp.w	r9,49152
80002ed2:	e0 81 00 ce 	brne	8000306e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ed6:	30 1a       	mov	r10,1
80002ed8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002edc:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002ede:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002ee2:	72 09       	ld.w	r9,r9[0x0]
80002ee4:	58 09       	cp.w	r9,0
80002ee6:	c0 71       	brne	80002ef4 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002ee8:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002eec:	f0 1f 03 00 	mcall	80003aec <phy_rx_func+0xed0>
80002ef0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002ef4:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002ef8:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002efc:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002efe:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f02:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f06:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f0a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f0c:	13 89       	ld.ub	r9,r9[0x0]
80002f0e:	37 fa       	mov	r10,127
80002f10:	f4 09 18 00 	cp.b	r9,r10
80002f14:	c6 d0       	breq	80002fee <phy_rx_func+0x3d2>
80002f16:	e0 8b 00 0c 	brhi	80002f2e <phy_rx_func+0x312>
80002f1a:	31 2a       	mov	r10,18
80002f1c:	f4 09 18 00 	cp.b	r9,r10
80002f20:	c4 20       	breq	80002fa4 <phy_rx_func+0x388>
80002f22:	31 3a       	mov	r10,19
80002f24:	f4 09 18 00 	cp.b	r9,r10
80002f28:	e0 81 00 83 	brne	8000302e <phy_rx_func+0x412>
80002f2c:	c5 b8       	rjmp	80002fe2 <phy_rx_func+0x3c6>
80002f2e:	2f 09       	sub	r9,-16
80002f30:	30 1a       	mov	r10,1
80002f32:	f4 09 18 00 	cp.b	r9,r10
80002f36:	e0 8b 00 7c 	brhi	8000302e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f3a:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f3e:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f42:	59 08       	cp.w	r8,16
80002f44:	c0 71       	brne	80002f52 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f46:	30 19       	mov	r9,1
80002f48:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f4c:	91 09       	st.w	r8[0x0],r9
80002f4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f52:	e0 48 00 20 	cp.w	r8,32
80002f56:	c2 11       	brne	80002f98 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f58:	30 a9       	mov	r9,10
80002f5a:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f5e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f60:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f64:	6c 08       	ld.w	r8,r6[0x0]
80002f66:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f6a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f6e:	2f f8       	sub	r8,-1
80002f70:	6e 0c       	ld.w	r12,r7[0x0]
80002f72:	f4 ca fe 00 	sub	r10,r10,-512
80002f76:	30 0b       	mov	r11,0
80002f78:	10 0c       	add	r12,r8
80002f7a:	f0 1f 02 e1 	mcall	80003afc <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f7e:	30 08       	mov	r8,0
80002f80:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f82:	6e 0c       	ld.w	r12,r7[0x0]
80002f84:	f0 1f 02 df 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002f88:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002f8c:	70 0c       	ld.w	r12,r8[0x0]
80002f8e:	f0 1f 02 ca 	mcall	80003ab4 <phy_rx_func+0xe98>
80002f92:	8f 0c       	st.w	r7[0x0],r12
80002f94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002f98:	30 09       	mov	r9,0
80002f9a:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002f9e:	91 09       	st.w	r8[0x0],r9
80002fa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fa4:	20 48       	sub	r8,4
80002fa6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002faa:	93 08       	st.w	r9[0x0],r8
80002fac:	58 08       	cp.w	r8,0
80002fae:	e0 80 05 74 	breq	80003a96 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fb2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fb6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fba:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fbe:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fc0:	8e 69       	ld.sh	r9,r7[0xc]
80002fc2:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fc6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fc8:	8e 79       	ld.sh	r9,r7[0xe]
80002fca:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fcc:	f0 1f 02 d0 	mcall	80003b0c <phy_rx_func+0xef0>
80002fd0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002fd4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002fd6:	30 49       	mov	r9,4
80002fd8:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002fdc:	91 09       	st.w	r8[0x0],r9
80002fde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002fe2:	30 09       	mov	r9,0
80002fe4:	fe f8 0a f8 	ld.w	r8,pc[2808]
80002fe8:	91 09       	st.w	r8[0x0],r9
80002fea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fee:	20 48       	sub	r8,4
80002ff0:	fe f9 0a f0 	ld.w	r9,pc[2800]
80002ff4:	93 08       	st.w	r9[0x0],r8
80002ff6:	58 08       	cp.w	r8,0
80002ff8:	e0 80 05 4f 	breq	80003a96 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80002ffc:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003000:	70 09       	ld.w	r9,r8[0x0]
80003002:	8e 7b       	ld.sh	r11,r7[0xe]
80003004:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003008:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000300c:	2f f9       	sub	r9,-1
8000300e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003010:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003014:	70 09       	ld.w	r9,r8[0x0]
80003016:	20 29       	sub	r9,2
80003018:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000301a:	30 29       	mov	r9,2
8000301c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003020:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003022:	30 39       	mov	r9,3
80003024:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003028:	91 09       	st.w	r8[0x0],r9
8000302a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000302e:	30 3a       	mov	r10,3
80003030:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003034:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003036:	6e 2a       	ld.w	r10,r7[0x8]
80003038:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000303c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000303e:	6e 3a       	ld.w	r10,r7[0xc]
80003040:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003042:	59 48       	cp.w	r8,20
80003044:	c0 61       	brne	80003050 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003046:	31 89       	mov	r9,24
80003048:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000304c:	91 09       	st.w	r8[0x0],r9
8000304e:	c0 a8       	rjmp	80003062 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003050:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003054:	70 08       	ld.w	r8,r8[0x0]
80003056:	59 08       	cp.w	r8,16
80003058:	c0 51       	brne	80003062 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000305a:	31 09       	mov	r9,16
8000305c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003060:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003062:	30 49       	mov	r9,4
80003064:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003068:	91 09       	st.w	r8[0x0],r9
8000306a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000306e:	e0 49 10 00 	cp.w	r9,4096
80003072:	5f 1a       	srne	r10
80003074:	e0 49 20 00 	cp.w	r9,8192
80003078:	5f 19       	srne	r9
8000307a:	f5 e9 00 09 	and	r9,r10,r9
8000307e:	e0 81 05 0c 	brne	80003a96 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003082:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003086:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003088:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000308c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000308e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003092:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003094:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003098:	72 09       	ld.w	r9,r9[0x0]
8000309a:	58 09       	cp.w	r9,0
8000309c:	c0 71       	brne	800030aa <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000309e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030a2:	f0 1f 02 93 	mcall	80003aec <phy_rx_func+0xed0>
800030a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030aa:	6e 2a       	ld.w	r10,r7[0x8]
800030ac:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030b0:	58 1a       	cp.w	r10,1
800030b2:	e0 8b 00 4d 	brhi	8000314c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030b6:	20 48       	sub	r8,4
800030b8:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030bc:	93 08       	st.w	r9[0x0],r8
800030be:	58 08       	cp.w	r8,0
800030c0:	e0 80 04 eb 	breq	80003a96 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030c4:	8e 68       	ld.sh	r8,r7[0xc]
800030c6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030ca:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030ce:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030d0:	30 09       	mov	r9,0
800030d2:	f2 08 19 00 	cp.h	r8,r9
800030d6:	c0 70       	breq	800030e4 <phy_rx_func+0x4c8>
800030d8:	30 19       	mov	r9,1
800030da:	f2 08 19 00 	cp.h	r8,r9
800030de:	e0 81 04 dc 	brne	80003a96 <phy_rx_func+0xe7a>
800030e2:	c2 68       	rjmp	8000312e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800030e4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800030e8:	70 0a       	ld.w	r10,r8[0x0]
800030ea:	fe f9 09 e6 	ld.w	r9,pc[2534]
800030ee:	72 09       	ld.w	r9,r9[0x0]
800030f0:	8e 7b       	ld.sh	r11,r7[0xe]
800030f2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800030f6:	70 09       	ld.w	r9,r8[0x0]
800030f8:	2f f9       	sub	r9,-1
800030fa:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800030fc:	e0 49 00 ff 	cp.w	r9,255
80003100:	e0 88 00 11 	brls	80003122 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003104:	30 09       	mov	r9,0
80003106:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003108:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000310c:	6e 0c       	ld.w	r12,r7[0x0]
8000310e:	f0 1f 02 7d 	mcall	80003b00 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003112:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003116:	70 0c       	ld.w	r12,r8[0x0]
80003118:	f0 1f 02 67 	mcall	80003ab4 <phy_rx_func+0xe98>
8000311c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000311e:	e0 80 04 bc 	breq	80003a96 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003122:	30 29       	mov	r9,2
80003124:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003128:	91 09       	st.w	r8[0x0],r9
8000312a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000312e:	8e 79       	ld.sh	r9,r7[0xe]
80003130:	30 38       	mov	r8,3
80003132:	f0 09 19 00 	cp.h	r9,r8
80003136:	c0 51       	brne	80003140 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003138:	30 19       	mov	r9,1
8000313a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000313e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003140:	30 29       	mov	r9,2
80003142:	fe f8 09 96 	ld.w	r8,pc[2454]
80003146:	91 09       	st.w	r8[0x0],r9
80003148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000314c:	58 18       	cp.w	r8,1
8000314e:	e0 88 04 a4 	brls	80003a96 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003152:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003156:	70 0a       	ld.w	r10,r8[0x0]
80003158:	6e 3b       	ld.w	r11,r7[0xc]
8000315a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000315e:	70 09       	ld.w	r9,r8[0x0]
80003160:	2f f9       	sub	r9,-1
80003162:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003164:	e0 49 00 ff 	cp.w	r9,255
80003168:	e0 88 00 11 	brls	8000318a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000316c:	30 09       	mov	r9,0
8000316e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003170:	fe f7 09 60 	ld.w	r7,pc[2400]
80003174:	6e 0c       	ld.w	r12,r7[0x0]
80003176:	f0 1f 02 63 	mcall	80003b00 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000317a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000317e:	70 0c       	ld.w	r12,r8[0x0]
80003180:	f0 1f 02 4d 	mcall	80003ab4 <phy_rx_func+0xe98>
80003184:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003186:	e0 80 04 88 	breq	80003a96 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000318a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000318e:	72 08       	ld.w	r8,r9[0x0]
80003190:	20 28       	sub	r8,2
80003192:	93 08       	st.w	r9[0x0],r8
80003194:	e0 80 04 81 	breq	80003a96 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003198:	30 29       	mov	r9,2
8000319a:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000319e:	91 09       	st.w	r8[0x0],r9
800031a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031a4:	fe f8 09 84 	ld.w	r8,pc[2436]
800031a8:	70 0a       	ld.w	r10,r8[0x0]
800031aa:	fe f9 09 26 	ld.w	r9,pc[2342]
800031ae:	72 09       	ld.w	r9,r9[0x0]
800031b0:	8e 4b       	ld.sh	r11,r7[0x8]
800031b2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031b6:	70 09       	ld.w	r9,r8[0x0]
800031b8:	2f f9       	sub	r9,-1
800031ba:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031bc:	e0 49 00 ff 	cp.w	r9,255
800031c0:	e0 88 00 16 	brls	800031ec <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031c4:	30 09       	mov	r9,0
800031c6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031c8:	fe f6 09 08 	ld.w	r6,pc[2312]
800031cc:	6c 0c       	ld.w	r12,r6[0x0]
800031ce:	f0 1f 02 4d 	mcall	80003b00 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031d2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031d6:	70 0c       	ld.w	r12,r8[0x0]
800031d8:	f0 1f 02 37 	mcall	80003ab4 <phy_rx_func+0xe98>
800031dc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031de:	c0 71       	brne	800031ec <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031e0:	30 09       	mov	r9,0
800031e2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800031e6:	91 09       	st.w	r8[0x0],r9
800031e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800031ec:	fe f9 08 f4 	ld.w	r9,pc[2292]
800031f0:	72 08       	ld.w	r8,r9[0x0]
800031f2:	20 28       	sub	r8,2
800031f4:	93 08       	st.w	r9[0x0],r8
800031f6:	c0 71       	brne	80003204 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800031f8:	30 09       	mov	r9,0
800031fa:	fe f8 08 de 	ld.w	r8,pc[2270]
800031fe:	91 09       	st.w	r8[0x0],r9
80003200:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003204:	fe f8 09 24 	ld.w	r8,pc[2340]
80003208:	70 0a       	ld.w	r10,r8[0x0]
8000320a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000320e:	72 09       	ld.w	r9,r9[0x0]
80003210:	8e 5b       	ld.sh	r11,r7[0xa]
80003212:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003216:	70 09       	ld.w	r9,r8[0x0]
80003218:	2f f9       	sub	r9,-1
8000321a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000321c:	e0 49 00 ff 	cp.w	r9,255
80003220:	e0 88 00 16 	brls	8000324c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003224:	30 09       	mov	r9,0
80003226:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003228:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000322c:	6c 0c       	ld.w	r12,r6[0x0]
8000322e:	f0 1f 02 35 	mcall	80003b00 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003232:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003236:	70 0c       	ld.w	r12,r8[0x0]
80003238:	f0 1f 02 1f 	mcall	80003ab4 <phy_rx_func+0xe98>
8000323c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000323e:	c0 71       	brne	8000324c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003240:	30 09       	mov	r9,0
80003242:	fe f8 08 96 	ld.w	r8,pc[2198]
80003246:	91 09       	st.w	r8[0x0],r9
80003248:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000324c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003250:	72 08       	ld.w	r8,r9[0x0]
80003252:	20 28       	sub	r8,2
80003254:	93 08       	st.w	r9[0x0],r8
80003256:	c0 71       	brne	80003264 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003258:	30 09       	mov	r9,0
8000325a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000325e:	91 09       	st.w	r8[0x0],r9
80003260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003264:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003268:	70 0a       	ld.w	r10,r8[0x0]
8000326a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000326e:	72 09       	ld.w	r9,r9[0x0]
80003270:	8e 6b       	ld.sh	r11,r7[0xc]
80003272:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003276:	70 09       	ld.w	r9,r8[0x0]
80003278:	2f f9       	sub	r9,-1
8000327a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000327c:	e0 49 00 ff 	cp.w	r9,255
80003280:	e0 88 00 16 	brls	800032ac <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003284:	30 09       	mov	r9,0
80003286:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003288:	fe f6 08 48 	ld.w	r6,pc[2120]
8000328c:	6c 0c       	ld.w	r12,r6[0x0]
8000328e:	f0 1f 02 1d 	mcall	80003b00 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003292:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003296:	70 0c       	ld.w	r12,r8[0x0]
80003298:	f0 1f 02 07 	mcall	80003ab4 <phy_rx_func+0xe98>
8000329c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000329e:	c0 71       	brne	800032ac <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032a0:	30 09       	mov	r9,0
800032a2:	fe f8 08 36 	ld.w	r8,pc[2102]
800032a6:	91 09       	st.w	r8[0x0],r9
800032a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032ac:	fe f9 08 34 	ld.w	r9,pc[2100]
800032b0:	72 08       	ld.w	r8,r9[0x0]
800032b2:	20 28       	sub	r8,2
800032b4:	93 08       	st.w	r9[0x0],r8
800032b6:	c0 71       	brne	800032c4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032b8:	30 09       	mov	r9,0
800032ba:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032be:	91 09       	st.w	r8[0x0],r9
800032c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032c4:	fe f8 08 64 	ld.w	r8,pc[2148]
800032c8:	70 0a       	ld.w	r10,r8[0x0]
800032ca:	fe f9 08 06 	ld.w	r9,pc[2054]
800032ce:	72 09       	ld.w	r9,r9[0x0]
800032d0:	8e 7b       	ld.sh	r11,r7[0xe]
800032d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032d6:	70 09       	ld.w	r9,r8[0x0]
800032d8:	2f f9       	sub	r9,-1
800032da:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032dc:	e0 49 00 ff 	cp.w	r9,255
800032e0:	e0 88 00 16 	brls	8000330c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800032e4:	30 09       	mov	r9,0
800032e6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032e8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800032ec:	6e 0c       	ld.w	r12,r7[0x0]
800032ee:	f0 1f 02 05 	mcall	80003b00 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032f2:	fe f8 07 da 	ld.w	r8,pc[2010]
800032f6:	70 0c       	ld.w	r12,r8[0x0]
800032f8:	f0 1f 01 ef 	mcall	80003ab4 <phy_rx_func+0xe98>
800032fc:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800032fe:	c0 71       	brne	8000330c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003300:	30 09       	mov	r9,0
80003302:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003306:	91 09       	st.w	r8[0x0],r9
80003308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000330c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003310:	72 08       	ld.w	r8,r9[0x0]
80003312:	20 28       	sub	r8,2
80003314:	93 08       	st.w	r9[0x0],r8
80003316:	e0 81 03 c0 	brne	80003a96 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000331a:	30 09       	mov	r9,0
8000331c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003320:	91 09       	st.w	r8[0x0],r9
80003322:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003326:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000332a:	11 89       	ld.ub	r9,r8[0x0]
8000332c:	31 28       	mov	r8,18
8000332e:	f0 09 18 00 	cp.b	r9,r8
80003332:	e0 81 01 4c 	brne	800035ca <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003336:	ef 39 00 09 	ld.ub	r9,r7[9]
8000333a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000333e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003340:	11 89       	ld.ub	r9,r8[0x0]
80003342:	3f 28       	mov	r8,-14
80003344:	f0 09 18 00 	cp.b	r9,r8
80003348:	e0 81 01 3b 	brne	800035be <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000334c:	30 19       	mov	r9,1
8000334e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003352:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003354:	6e 29       	ld.w	r9,r7[0x8]
80003356:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000335a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000335e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003360:	8e 59       	ld.sh	r9,r7[0xa]
80003362:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003366:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003368:	8e 69       	ld.sh	r9,r7[0xc]
8000336a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000336c:	8e 79       	ld.sh	r9,r7[0xe]
8000336e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003370:	fe f8 07 88 	ld.w	r8,pc[1928]
80003374:	fe f9 07 60 	ld.w	r9,pc[1888]
80003378:	72 0a       	ld.w	r10,r9[0x0]
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003380:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003384:	70 09       	ld.w	r9,r8[0x0]
80003386:	2f f9       	sub	r9,-1
80003388:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000338a:	e0 49 01 ff 	cp.w	r9,511
8000338e:	e0 88 00 16 	brls	800033ba <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003392:	30 09       	mov	r9,0
80003394:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003396:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000339a:	6c 0c       	ld.w	r12,r6[0x0]
8000339c:	f0 1f 01 d9 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033a0:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033a4:	70 0c       	ld.w	r12,r8[0x0]
800033a6:	f0 1f 01 c4 	mcall	80003ab4 <phy_rx_func+0xe98>
800033aa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033ac:	c0 71       	brne	800033ba <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033ae:	30 09       	mov	r9,0
800033b0:	fe f8 07 28 	ld.w	r8,pc[1832]
800033b4:	91 09       	st.w	r8[0x0],r9
800033b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033ba:	fe f9 07 26 	ld.w	r9,pc[1830]
800033be:	72 08       	ld.w	r8,r9[0x0]
800033c0:	20 18       	sub	r8,1
800033c2:	93 08       	st.w	r9[0x0],r8
800033c4:	c0 71       	brne	800033d2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033c6:	30 09       	mov	r9,0
800033c8:	fe f8 07 10 	ld.w	r8,pc[1808]
800033cc:	91 09       	st.w	r8[0x0],r9
800033ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033d2:	fe f8 07 26 	ld.w	r8,pc[1830]
800033d6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033da:	72 0a       	ld.w	r10,r9[0x0]
800033dc:	70 09       	ld.w	r9,r8[0x0]
800033de:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033e2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033e6:	70 09       	ld.w	r9,r8[0x0]
800033e8:	2f f9       	sub	r9,-1
800033ea:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033ec:	e0 49 01 ff 	cp.w	r9,511
800033f0:	e0 88 00 16 	brls	8000341c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800033f4:	30 09       	mov	r9,0
800033f6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033f8:	fe f6 06 dc 	ld.w	r6,pc[1756]
800033fc:	6c 0c       	ld.w	r12,r6[0x0]
800033fe:	f0 1f 01 c1 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003402:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003406:	70 0c       	ld.w	r12,r8[0x0]
80003408:	f0 1f 01 ab 	mcall	80003ab4 <phy_rx_func+0xe98>
8000340c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000340e:	c0 71       	brne	8000341c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003410:	30 09       	mov	r9,0
80003412:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003416:	91 09       	st.w	r8[0x0],r9
80003418:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000341c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003420:	72 08       	ld.w	r8,r9[0x0]
80003422:	20 18       	sub	r8,1
80003424:	93 08       	st.w	r9[0x0],r8
80003426:	c0 71       	brne	80003434 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003428:	30 09       	mov	r9,0
8000342a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000342e:	91 09       	st.w	r8[0x0],r9
80003430:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003434:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003438:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000343c:	72 0a       	ld.w	r10,r9[0x0]
8000343e:	70 09       	ld.w	r9,r8[0x0]
80003440:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003444:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003448:	70 09       	ld.w	r9,r8[0x0]
8000344a:	2f f9       	sub	r9,-1
8000344c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000344e:	e0 49 01 ff 	cp.w	r9,511
80003452:	e0 88 00 16 	brls	8000347e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003456:	30 09       	mov	r9,0
80003458:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000345a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000345e:	6c 0c       	ld.w	r12,r6[0x0]
80003460:	f0 1f 01 a8 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003464:	fe f8 06 68 	ld.w	r8,pc[1640]
80003468:	70 0c       	ld.w	r12,r8[0x0]
8000346a:	f0 1f 01 93 	mcall	80003ab4 <phy_rx_func+0xe98>
8000346e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003470:	c0 71       	brne	8000347e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003472:	30 09       	mov	r9,0
80003474:	fe f8 06 64 	ld.w	r8,pc[1636]
80003478:	91 09       	st.w	r8[0x0],r9
8000347a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000347e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003482:	72 08       	ld.w	r8,r9[0x0]
80003484:	20 18       	sub	r8,1
80003486:	93 08       	st.w	r9[0x0],r8
80003488:	c0 71       	brne	80003496 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000348a:	30 09       	mov	r9,0
8000348c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003490:	91 09       	st.w	r8[0x0],r9
80003492:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003496:	fe f8 06 62 	ld.w	r8,pc[1634]
8000349a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000349e:	72 0a       	ld.w	r10,r9[0x0]
800034a0:	70 09       	ld.w	r9,r8[0x0]
800034a2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034a6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034aa:	70 09       	ld.w	r9,r8[0x0]
800034ac:	2f f9       	sub	r9,-1
800034ae:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034b0:	e0 49 01 ff 	cp.w	r9,511
800034b4:	e0 88 00 16 	brls	800034e0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034b8:	30 09       	mov	r9,0
800034ba:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034bc:	fe f6 06 18 	ld.w	r6,pc[1560]
800034c0:	6c 0c       	ld.w	r12,r6[0x0]
800034c2:	f0 1f 01 90 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034c6:	fe f8 06 06 	ld.w	r8,pc[1542]
800034ca:	70 0c       	ld.w	r12,r8[0x0]
800034cc:	f0 1f 01 7a 	mcall	80003ab4 <phy_rx_func+0xe98>
800034d0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034d2:	c0 71       	brne	800034e0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034d4:	30 09       	mov	r9,0
800034d6:	fe f8 06 02 	ld.w	r8,pc[1538]
800034da:	91 09       	st.w	r8[0x0],r9
800034dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034e0:	fe f9 06 00 	ld.w	r9,pc[1536]
800034e4:	72 08       	ld.w	r8,r9[0x0]
800034e6:	20 18       	sub	r8,1
800034e8:	93 08       	st.w	r9[0x0],r8
800034ea:	c0 71       	brne	800034f8 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800034ec:	30 09       	mov	r9,0
800034ee:	fe f8 05 ea 	ld.w	r8,pc[1514]
800034f2:	91 09       	st.w	r8[0x0],r9
800034f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800034f8:	fe f8 06 00 	ld.w	r8,pc[1536]
800034fc:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003500:	72 0a       	ld.w	r10,r9[0x0]
80003502:	70 09       	ld.w	r9,r8[0x0]
80003504:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003508:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000350c:	70 09       	ld.w	r9,r8[0x0]
8000350e:	2f f9       	sub	r9,-1
80003510:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003512:	e0 49 01 ff 	cp.w	r9,511
80003516:	e0 88 00 16 	brls	80003542 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000351a:	30 09       	mov	r9,0
8000351c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000351e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003522:	6c 0c       	ld.w	r12,r6[0x0]
80003524:	f0 1f 01 77 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003528:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000352c:	70 0c       	ld.w	r12,r8[0x0]
8000352e:	f0 1f 01 62 	mcall	80003ab4 <phy_rx_func+0xe98>
80003532:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003534:	c0 71       	brne	80003542 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003536:	30 09       	mov	r9,0
80003538:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000353c:	91 09       	st.w	r8[0x0],r9
8000353e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003542:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003546:	72 08       	ld.w	r8,r9[0x0]
80003548:	20 18       	sub	r8,1
8000354a:	93 08       	st.w	r9[0x0],r8
8000354c:	c0 71       	brne	8000355a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000354e:	30 09       	mov	r9,0
80003550:	fe f8 05 88 	ld.w	r8,pc[1416]
80003554:	91 09       	st.w	r8[0x0],r9
80003556:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000355a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000355e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003562:	72 0a       	ld.w	r10,r9[0x0]
80003564:	70 09       	ld.w	r9,r8[0x0]
80003566:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000356a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000356e:	70 09       	ld.w	r9,r8[0x0]
80003570:	2f f9       	sub	r9,-1
80003572:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003574:	e0 49 01 ff 	cp.w	r9,511
80003578:	e0 88 00 16 	brls	800035a4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000357c:	30 09       	mov	r9,0
8000357e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003580:	fe f7 05 54 	ld.w	r7,pc[1364]
80003584:	6e 0c       	ld.w	r12,r7[0x0]
80003586:	f0 1f 01 5f 	mcall	80003b00 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000358a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000358e:	70 0c       	ld.w	r12,r8[0x0]
80003590:	f0 1f 01 49 	mcall	80003ab4 <phy_rx_func+0xe98>
80003594:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003596:	c0 71       	brne	800035a4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003598:	30 09       	mov	r9,0
8000359a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000359e:	91 09       	st.w	r8[0x0],r9
800035a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a4:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035a8:	72 08       	ld.w	r8,r9[0x0]
800035aa:	20 18       	sub	r8,1
800035ac:	93 08       	st.w	r9[0x0],r8
800035ae:	e0 81 02 74 	brne	80003a96 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035b2:	30 09       	mov	r9,0
800035b4:	fe f8 05 24 	ld.w	r8,pc[1316]
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035be:	30 09       	mov	r9,0
800035c0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035c4:	91 09       	st.w	r8[0x0],r9
800035c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035ca:	fe f8 05 26 	ld.w	r8,pc[1318]
800035ce:	11 89       	ld.ub	r9,r8[0x0]
800035d0:	3f 28       	mov	r8,-14
800035d2:	f0 09 18 00 	cp.b	r9,r8
800035d6:	c4 31       	brne	8000365c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035d8:	8e 49       	ld.sh	r9,r7[0x8]
800035da:	fe f8 05 56 	ld.w	r8,pc[1366]
800035de:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035e0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035e4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800035e8:	72 0a       	ld.w	r10,r9[0x0]
800035ea:	70 09       	ld.w	r9,r8[0x0]
800035ec:	ef 3b 00 08 	ld.ub	r11,r7[8]
800035f0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800035f4:	70 09       	ld.w	r9,r8[0x0]
800035f6:	2f f9       	sub	r9,-1
800035f8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035fa:	e0 49 01 ff 	cp.w	r9,511
800035fe:	e0 88 00 16 	brls	8000362a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003602:	30 09       	mov	r9,0
80003604:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003606:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000360a:	6e 0c       	ld.w	r12,r7[0x0]
8000360c:	f0 1f 01 3d 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003610:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003614:	70 0c       	ld.w	r12,r8[0x0]
80003616:	f0 1f 01 28 	mcall	80003ab4 <phy_rx_func+0xe98>
8000361a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000361c:	c0 71       	brne	8000362a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000361e:	30 09       	mov	r9,0
80003620:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003624:	91 09       	st.w	r8[0x0],r9
80003626:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000362a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000362e:	72 08       	ld.w	r8,r9[0x0]
80003630:	20 18       	sub	r8,1
80003632:	93 08       	st.w	r9[0x0],r8
80003634:	c0 71       	brne	80003642 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003636:	30 09       	mov	r9,0
80003638:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000363c:	91 09       	st.w	r8[0x0],r9
8000363e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003642:	20 18       	sub	r8,1
80003644:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003648:	93 08       	st.w	r9[0x0],r8
8000364a:	58 08       	cp.w	r8,0
8000364c:	e0 81 02 25 	brne	80003a96 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003650:	30 09       	mov	r9,0
80003652:	fe f8 04 86 	ld.w	r8,pc[1158]
80003656:	91 09       	st.w	r8[0x0],r9
80003658:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000365c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003660:	11 89       	ld.ub	r9,r8[0x0]
80003662:	3f 38       	mov	r8,-13
80003664:	f0 09 18 00 	cp.b	r9,r8
80003668:	e0 81 01 0c 	brne	80003880 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000366c:	8e 49       	ld.sh	r9,r7[0x8]
8000366e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003672:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003674:	8e 59       	ld.sh	r9,r7[0xa]
80003676:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003678:	8e 69       	ld.sh	r9,r7[0xc]
8000367a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000367c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003680:	fe f9 04 54 	ld.w	r9,pc[1108]
80003684:	72 0a       	ld.w	r10,r9[0x0]
80003686:	70 09       	ld.w	r9,r8[0x0]
80003688:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000368c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003690:	70 09       	ld.w	r9,r8[0x0]
80003692:	2f f9       	sub	r9,-1
80003694:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003696:	e0 49 01 ff 	cp.w	r9,511
8000369a:	e0 88 00 16 	brls	800036c6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000369e:	30 09       	mov	r9,0
800036a0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036a2:	fe f6 04 32 	ld.w	r6,pc[1074]
800036a6:	6c 0c       	ld.w	r12,r6[0x0]
800036a8:	f0 1f 01 16 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036ac:	fe f8 04 20 	ld.w	r8,pc[1056]
800036b0:	70 0c       	ld.w	r12,r8[0x0]
800036b2:	f0 1f 01 01 	mcall	80003ab4 <phy_rx_func+0xe98>
800036b6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036b8:	c0 71       	brne	800036c6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036ba:	30 09       	mov	r9,0
800036bc:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036c0:	91 09       	st.w	r8[0x0],r9
800036c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036c6:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036ca:	72 08       	ld.w	r8,r9[0x0]
800036cc:	20 18       	sub	r8,1
800036ce:	93 08       	st.w	r9[0x0],r8
800036d0:	c0 71       	brne	800036de <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036d2:	30 09       	mov	r9,0
800036d4:	fe f8 04 04 	ld.w	r8,pc[1028]
800036d8:	91 09       	st.w	r8[0x0],r9
800036da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036de:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036e2:	fe f9 03 f2 	ld.w	r9,pc[1010]
800036e6:	72 0a       	ld.w	r10,r9[0x0]
800036e8:	70 09       	ld.w	r9,r8[0x0]
800036ea:	ef 3b 00 09 	ld.ub	r11,r7[9]
800036ee:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036f2:	70 09       	ld.w	r9,r8[0x0]
800036f4:	2f f9       	sub	r9,-1
800036f6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036f8:	e0 49 01 ff 	cp.w	r9,511
800036fc:	e0 88 00 16 	brls	80003728 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003700:	30 09       	mov	r9,0
80003702:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003704:	fe f6 03 d0 	ld.w	r6,pc[976]
80003708:	6c 0c       	ld.w	r12,r6[0x0]
8000370a:	f0 1f 00 fe 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000370e:	fe f8 03 be 	ld.w	r8,pc[958]
80003712:	70 0c       	ld.w	r12,r8[0x0]
80003714:	f0 1f 00 e8 	mcall	80003ab4 <phy_rx_func+0xe98>
80003718:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000371a:	c0 71       	brne	80003728 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000371c:	30 09       	mov	r9,0
8000371e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003722:	91 09       	st.w	r8[0x0],r9
80003724:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003728:	fe f9 03 b8 	ld.w	r9,pc[952]
8000372c:	72 08       	ld.w	r8,r9[0x0]
8000372e:	20 18       	sub	r8,1
80003730:	93 08       	st.w	r9[0x0],r8
80003732:	c0 71       	brne	80003740 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003734:	30 09       	mov	r9,0
80003736:	fe f8 03 a2 	ld.w	r8,pc[930]
8000373a:	91 09       	st.w	r8[0x0],r9
8000373c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003740:	fe f8 03 b8 	ld.w	r8,pc[952]
80003744:	fe f9 03 90 	ld.w	r9,pc[912]
80003748:	72 0a       	ld.w	r10,r9[0x0]
8000374a:	70 09       	ld.w	r9,r8[0x0]
8000374c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003750:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003754:	70 09       	ld.w	r9,r8[0x0]
80003756:	2f f9       	sub	r9,-1
80003758:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000375a:	e0 49 01 ff 	cp.w	r9,511
8000375e:	e0 88 00 16 	brls	8000378a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003762:	30 09       	mov	r9,0
80003764:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003766:	fe f6 03 6e 	ld.w	r6,pc[878]
8000376a:	6c 0c       	ld.w	r12,r6[0x0]
8000376c:	f0 1f 00 e5 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003770:	fe f8 03 5c 	ld.w	r8,pc[860]
80003774:	70 0c       	ld.w	r12,r8[0x0]
80003776:	f0 1f 00 d0 	mcall	80003ab4 <phy_rx_func+0xe98>
8000377a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000377c:	c0 71       	brne	8000378a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000377e:	30 09       	mov	r9,0
80003780:	fe f8 03 58 	ld.w	r8,pc[856]
80003784:	91 09       	st.w	r8[0x0],r9
80003786:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000378a:	fe f9 03 56 	ld.w	r9,pc[854]
8000378e:	72 08       	ld.w	r8,r9[0x0]
80003790:	20 18       	sub	r8,1
80003792:	93 08       	st.w	r9[0x0],r8
80003794:	c0 71       	brne	800037a2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003796:	30 09       	mov	r9,0
80003798:	fe f8 03 40 	ld.w	r8,pc[832]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037a2:	fe f8 03 56 	ld.w	r8,pc[854]
800037a6:	fe f9 03 2e 	ld.w	r9,pc[814]
800037aa:	72 0a       	ld.w	r10,r9[0x0]
800037ac:	70 09       	ld.w	r9,r8[0x0]
800037ae:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037b2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037b6:	70 09       	ld.w	r9,r8[0x0]
800037b8:	2f f9       	sub	r9,-1
800037ba:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037bc:	e0 49 01 ff 	cp.w	r9,511
800037c0:	e0 88 00 16 	brls	800037ec <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037c4:	30 09       	mov	r9,0
800037c6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037c8:	fe f6 03 0c 	ld.w	r6,pc[780]
800037cc:	6c 0c       	ld.w	r12,r6[0x0]
800037ce:	f0 1f 00 cd 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037d2:	fe f8 02 fa 	ld.w	r8,pc[762]
800037d6:	70 0c       	ld.w	r12,r8[0x0]
800037d8:	f0 1f 00 b7 	mcall	80003ab4 <phy_rx_func+0xe98>
800037dc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037de:	c0 71       	brne	800037ec <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037e0:	30 09       	mov	r9,0
800037e2:	fe f8 02 f6 	ld.w	r8,pc[758]
800037e6:	91 09       	st.w	r8[0x0],r9
800037e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ec:	fe f9 02 f4 	ld.w	r9,pc[756]
800037f0:	72 08       	ld.w	r8,r9[0x0]
800037f2:	20 18       	sub	r8,1
800037f4:	93 08       	st.w	r9[0x0],r8
800037f6:	c0 71       	brne	80003804 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800037f8:	30 09       	mov	r9,0
800037fa:	fe f8 02 de 	ld.w	r8,pc[734]
800037fe:	91 09       	st.w	r8[0x0],r9
80003800:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003804:	fe f8 02 f4 	ld.w	r8,pc[756]
80003808:	fe f9 02 cc 	ld.w	r9,pc[716]
8000380c:	72 0a       	ld.w	r10,r9[0x0]
8000380e:	70 09       	ld.w	r9,r8[0x0]
80003810:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003814:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003818:	70 09       	ld.w	r9,r8[0x0]
8000381a:	2f f9       	sub	r9,-1
8000381c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000381e:	e0 49 01 ff 	cp.w	r9,511
80003822:	e0 88 00 16 	brls	8000384e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003826:	30 09       	mov	r9,0
80003828:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000382a:	fe f7 02 aa 	ld.w	r7,pc[682]
8000382e:	6e 0c       	ld.w	r12,r7[0x0]
80003830:	f0 1f 00 b4 	mcall	80003b00 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003834:	fe f8 02 98 	ld.w	r8,pc[664]
80003838:	70 0c       	ld.w	r12,r8[0x0]
8000383a:	f0 1f 00 9f 	mcall	80003ab4 <phy_rx_func+0xe98>
8000383e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003840:	c0 71       	brne	8000384e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003842:	30 09       	mov	r9,0
80003844:	fe f8 02 94 	ld.w	r8,pc[660]
80003848:	91 09       	st.w	r8[0x0],r9
8000384a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000384e:	fe f9 02 92 	ld.w	r9,pc[658]
80003852:	72 08       	ld.w	r8,r9[0x0]
80003854:	20 18       	sub	r8,1
80003856:	93 08       	st.w	r9[0x0],r8
80003858:	c0 71       	brne	80003866 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000385a:	30 09       	mov	r9,0
8000385c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003860:	91 09       	st.w	r8[0x0],r9
80003862:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003866:	20 18       	sub	r8,1
80003868:	fe f9 02 78 	ld.w	r9,pc[632]
8000386c:	93 08       	st.w	r9[0x0],r8
8000386e:	58 08       	cp.w	r8,0
80003870:	e0 81 01 13 	brne	80003a96 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003874:	30 09       	mov	r9,0
80003876:	fe f8 02 62 	ld.w	r8,pc[610]
8000387a:	91 09       	st.w	r8[0x0],r9
8000387c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003880:	fe f8 02 70 	ld.w	r8,pc[624]
80003884:	11 89       	ld.ub	r9,r8[0x0]
80003886:	30 48       	mov	r8,4
80003888:	f0 09 18 00 	cp.b	r9,r8
8000388c:	c0 80       	breq	8000389c <phy_rx_func+0xc80>
8000388e:	fe f8 02 62 	ld.w	r8,pc[610]
80003892:	11 89       	ld.ub	r9,r8[0x0]
80003894:	30 38       	mov	r8,3
80003896:	f0 09 18 00 	cp.b	r9,r8
8000389a:	c1 41       	brne	800038c2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000389c:	6e 29       	ld.w	r9,r7[0x8]
8000389e:	fe f8 02 7a 	ld.w	r8,pc[634]
800038a2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038a4:	6e 39       	ld.w	r9,r7[0xc]
800038a6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038a8:	fe f9 02 38 	ld.w	r9,pc[568]
800038ac:	72 08       	ld.w	r8,r9[0x0]
800038ae:	20 88       	sub	r8,8
800038b0:	93 08       	st.w	r9[0x0],r8
800038b2:	e0 81 00 f2 	brne	80003a96 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038b6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038b8:	fe f9 02 20 	ld.w	r9,pc[544]
800038bc:	93 08       	st.w	r9[0x0],r8
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038c2:	fe f8 02 2e 	ld.w	r8,pc[558]
800038c6:	11 89       	ld.ub	r9,r8[0x0]
800038c8:	31 38       	mov	r8,19
800038ca:	f0 09 18 00 	cp.b	r9,r8
800038ce:	e0 81 00 9c 	brne	80003a06 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038d2:	fe f8 02 62 	ld.w	r8,pc[610]
800038d6:	11 88       	ld.ub	r8,r8[0x0]
800038d8:	30 c9       	mov	r9,12
800038da:	f2 08 18 00 	cp.b	r8,r9
800038de:	e0 81 00 7b 	brne	800039d4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038e2:	8e 49       	ld.sh	r9,r7[0x8]
800038e4:	fe f8 02 54 	ld.w	r8,pc[596]
800038e8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800038ec:	30 09       	mov	r9,0
800038ee:	fe f8 02 46 	ld.w	r8,pc[582]
800038f2:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038f4:	ef 39 00 0d 	ld.ub	r9,r7[13]
800038f8:	3f 38       	mov	r8,-13
800038fa:	f0 09 18 00 	cp.b	r9,r8
800038fe:	c6 61       	brne	800039ca <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003900:	10 99       	mov	r9,r8
80003902:	4f c8       	lddpc	r8,80003af0 <phy_rx_func+0xed4>
80003904:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003906:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000390a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000390e:	4f 58       	lddpc	r8,80003ae0 <phy_rx_func+0xec4>
80003910:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003912:	30 19       	mov	r9,1
80003914:	fe f8 02 0c 	ld.w	r8,pc[524]
80003918:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000391a:	8e 79       	ld.sh	r9,r7[0xe]
8000391c:	fe f8 02 14 	ld.w	r8,pc[532]
80003920:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003922:	4f 68       	lddpc	r8,80003af8 <phy_rx_func+0xedc>
80003924:	4e c9       	lddpc	r9,80003ad4 <phy_rx_func+0xeb8>
80003926:	72 0a       	ld.w	r10,r9[0x0]
80003928:	70 09       	ld.w	r9,r8[0x0]
8000392a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000392e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003932:	70 09       	ld.w	r9,r8[0x0]
80003934:	2f f9       	sub	r9,-1
80003936:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003938:	e0 49 01 ff 	cp.w	r9,511
8000393c:	e0 88 00 13 	brls	80003962 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003940:	30 09       	mov	r9,0
80003942:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003944:	4e 46       	lddpc	r6,80003ad4 <phy_rx_func+0xeb8>
80003946:	6c 0c       	ld.w	r12,r6[0x0]
80003948:	f0 1f 00 6e 	mcall	80003b00 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000394c:	4e 08       	lddpc	r8,80003acc <phy_rx_func+0xeb0>
8000394e:	70 0c       	ld.w	r12,r8[0x0]
80003950:	f0 1f 00 59 	mcall	80003ab4 <phy_rx_func+0xe98>
80003954:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003956:	c0 61       	brne	80003962 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003958:	30 09       	mov	r9,0
8000395a:	4e 08       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
8000395c:	91 09       	st.w	r8[0x0],r9
8000395e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003962:	4e 09       	lddpc	r9,80003ae0 <phy_rx_func+0xec4>
80003964:	72 08       	ld.w	r8,r9[0x0]
80003966:	20 18       	sub	r8,1
80003968:	93 08       	st.w	r9[0x0],r8
8000396a:	c0 61       	brne	80003976 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
8000396c:	30 09       	mov	r9,0
8000396e:	4d b8       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003976:	4e 18       	lddpc	r8,80003af8 <phy_rx_func+0xedc>
80003978:	4d 79       	lddpc	r9,80003ad4 <phy_rx_func+0xeb8>
8000397a:	72 0a       	ld.w	r10,r9[0x0]
8000397c:	70 09       	ld.w	r9,r8[0x0]
8000397e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003982:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003986:	70 09       	ld.w	r9,r8[0x0]
80003988:	2f f9       	sub	r9,-1
8000398a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000398c:	e0 49 01 ff 	cp.w	r9,511
80003990:	e0 88 00 13 	brls	800039b6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003994:	30 09       	mov	r9,0
80003996:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003998:	4c f7       	lddpc	r7,80003ad4 <phy_rx_func+0xeb8>
8000399a:	6e 0c       	ld.w	r12,r7[0x0]
8000399c:	f0 1f 00 59 	mcall	80003b00 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039a0:	4c b8       	lddpc	r8,80003acc <phy_rx_func+0xeb0>
800039a2:	70 0c       	ld.w	r12,r8[0x0]
800039a4:	f0 1f 00 44 	mcall	80003ab4 <phy_rx_func+0xe98>
800039a8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039aa:	c0 61       	brne	800039b6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039ac:	30 09       	mov	r9,0
800039ae:	4c b8       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
800039b0:	91 09       	st.w	r8[0x0],r9
800039b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039b6:	4c b9       	lddpc	r9,80003ae0 <phy_rx_func+0xec4>
800039b8:	72 08       	ld.w	r8,r9[0x0]
800039ba:	20 18       	sub	r8,1
800039bc:	93 08       	st.w	r9[0x0],r8
800039be:	c6 c1       	brne	80003a96 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039c0:	30 09       	mov	r9,0
800039c2:	4c 68       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
800039c4:	91 09       	st.w	r8[0x0],r9
800039c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039ca:	30 09       	mov	r9,0
800039cc:	4c 38       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
800039ce:	91 09       	st.w	r8[0x0],r9
800039d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039d4:	8e 4a       	ld.sh	r10,r7[0x8]
800039d6:	4d 99       	lddpc	r9,80003b38 <phy_rx_func+0xf1c>
800039d8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039dc:	4d 6a       	lddpc	r10,80003b34 <phy_rx_func+0xf18>
800039de:	15 88       	ld.ub	r8,r10[0x0]
800039e0:	f0 cb ff ff 	sub	r11,r8,-1
800039e4:	8e 5c       	ld.sh	r12,r7[0xa]
800039e6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800039ea:	f0 cb ff fe 	sub	r11,r8,-2
800039ee:	8e 6c       	ld.sh	r12,r7[0xc]
800039f0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800039f4:	f0 cb ff fd 	sub	r11,r8,-3
800039f8:	8e 7c       	ld.sh	r12,r7[0xe]
800039fa:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800039fe:	2f c8       	sub	r8,-4
80003a00:	b4 88       	st.b	r10[0x0],r8
80003a02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a06:	30 09       	mov	r9,0
80003a08:	4b 48       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
80003a0a:	91 09       	st.w	r8[0x0],r9
80003a0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a10:	4c 08       	lddpc	r8,80003b10 <phy_rx_func+0xef4>
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	8e 4b       	ld.sh	r11,r7[0x8]
80003a16:	4c 0a       	lddpc	r10,80003b14 <phy_rx_func+0xef8>
80003a18:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a1c:	2f f9       	sub	r9,-1
80003a1e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a20:	4b 58       	lddpc	r8,80003af4 <phy_rx_func+0xed8>
80003a22:	70 09       	ld.w	r9,r8[0x0]
80003a24:	20 29       	sub	r9,2
80003a26:	91 09       	st.w	r8[0x0],r9
80003a28:	70 08       	ld.w	r8,r8[0x0]
80003a2a:	58 08       	cp.w	r8,0
80003a2c:	c2 f1       	brne	80003a8a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a2e:	30 09       	mov	r9,0
80003a30:	4b 88       	lddpc	r8,80003b10 <phy_rx_func+0xef4>
80003a32:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a34:	8e 59       	ld.sh	r9,r7[0xa]
80003a36:	fe 78 82 12 	mov	r8,-32238
80003a3a:	f0 09 19 00 	cp.h	r9,r8
80003a3e:	c2 11       	brne	80003a80 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a40:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a44:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a48:	4a f8       	lddpc	r8,80003b04 <phy_rx_func+0xee8>
80003a4a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a4c:	8e 59       	ld.sh	r9,r7[0xa]
80003a4e:	4a f8       	lddpc	r8,80003b08 <phy_rx_func+0xeec>
80003a50:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a52:	8e 69       	ld.sh	r9,r7[0xc]
80003a54:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a56:	f0 1f 00 2e 	mcall	80003b0c <phy_rx_func+0xef0>
80003a5a:	4a 18       	lddpc	r8,80003adc <phy_rx_func+0xec0>
80003a5c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a5e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a62:	31 38       	mov	r8,19
80003a64:	f0 09 18 00 	cp.b	r9,r8
80003a68:	c0 71       	brne	80003a76 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a6a:	10 99       	mov	r9,r8
80003a6c:	4a 18       	lddpc	r8,80003af0 <phy_rx_func+0xed4>
80003a6e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a70:	30 09       	mov	r9,0
80003a72:	49 c8       	lddpc	r8,80003ae0 <phy_rx_func+0xec4>
80003a74:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a76:	30 49       	mov	r9,4
80003a78:	49 88       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
80003a7a:	91 09       	st.w	r8[0x0],r9
80003a7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a80:	30 09       	mov	r9,0
80003a82:	49 68       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
80003a84:	91 09       	st.w	r8[0x0],r9
80003a86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003a8a:	4a dc       	lddpc	r12,80003b3c <phy_rx_func+0xf20>
80003a8c:	f0 1f 00 18 	mcall	80003aec <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003a90:	30 09       	mov	r9,0
80003a92:	49 28       	lddpc	r8,80003ad8 <phy_rx_func+0xebc>
80003a94:	91 09       	st.w	r8[0x0],r9
80003a96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003a9a:	00 00       	add	r0,r0
80003a9c:	00 00       	add	r0,r0
80003a9e:	0a a4       	st.w	r5++,r4
80003aa0:	00 00       	add	r0,r0
80003aa2:	0a a8       	st.w	r5++,r8
80003aa4:	00 00       	add	r0,r0
80003aa6:	0a 8c       	andn	r12,r5
80003aa8:	00 00       	add	r0,r0
80003aaa:	0a 68       	and	r8,r5
80003aac:	00 00       	add	r0,r0
80003aae:	0a 60       	and	r0,r5
80003ab0:	00 00       	add	r0,r0
80003ab2:	0a a0       	st.w	r5++,r0
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	2a 3c       	sub	r12,-93
80003ab8:	00 00       	add	r0,r0
80003aba:	0a 74       	tst	r4,r5
80003abc:	80 00       	ld.sh	r0,r0[0x0]
80003abe:	29 6c       	sub	r12,-106
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a 58       	eor	r8,r5
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	29 88       	sub	r8,-104
80003ac8:	00 00       	add	r0,r0
80003aca:	0a 71       	tst	r1,r5
80003acc:	00 00       	add	r0,r0
80003ace:	0a 5c       	eor	r12,r5
80003ad0:	00 00       	add	r0,r0
80003ad2:	0a 88       	andn	r8,r5
80003ad4:	00 00       	add	r0,r0
80003ad6:	0a 80       	andn	r0,r5
80003ad8:	00 00       	add	r0,r0
80003ada:	0a bc       	st.h	r5++,r12
80003adc:	00 00       	add	r0,r0
80003ade:	0a 54       	eor	r4,r5
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a 64       	and	r4,r5
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 3f       	cp.w	pc,r5
80003ae8:	80 00       	ld.sh	r0,r0[0x0]
80003aea:	c2 f4       	brge	80003b48 <pdca_int_handler+0x8>
80003aec:	80 00       	ld.sh	r0,r0[0x0]
80003aee:	5e 24       	reths	r4
80003af0:	00 00       	add	r0,r0
80003af2:	0a 70       	tst	r0,r5
80003af4:	00 00       	add	r0,r0
80003af6:	0a 7c       	tst	r12,r5
80003af8:	00 00       	add	r0,r0
80003afa:	0a 90       	mov	r0,r5
80003afc:	80 00       	ld.sh	r0,r0[0x0]
80003afe:	66 50       	ld.w	r0,r3[0x14]
80003b00:	80 00       	ld.sh	r0,r0[0x0]
80003b02:	2b bc       	sub	r12,-69
80003b04:	00 00       	add	r0,r0
80003b06:	0a 32       	cp.w	r2,r5
80003b08:	00 00       	add	r0,r0
80003b0a:	0e 6c       	and	r12,r7
80003b0c:	80 00       	ld.sh	r0,r0[0x0]
80003b0e:	28 cc       	sub	r12,-116
80003b10:	00 00       	add	r0,r0
80003b12:	0a ac       	st.w	r5++,r12
80003b14:	00 00       	add	r0,r0
80003b16:	0d 70       	ld.ub	r0,--r6
80003b18:	00 00       	add	r0,r0
80003b1a:	0a c0       	st.b	r5++,r0
80003b1c:	00 00       	add	r0,r0
80003b1e:	0a 3e       	cp.w	lr,r5
80003b20:	00 00       	add	r0,r0
80003b22:	0a 31       	cp.w	r1,r5
80003b24:	00 00       	add	r0,r0
80003b26:	0a 9c       	mov	r12,r5
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 84       	andn	r4,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a 43       	or	r3,r5
80003b30:	00 00       	add	r0,r0
80003b32:	0d 68       	ld.uh	r8,--r6
80003b34:	00 00       	add	r0,r0
80003b36:	0a b4       	st.h	r5++,r4
80003b38:	00 00       	add	r0,r0
80003b3a:	0e 70       	tst	r0,r7
80003b3c:	80 00       	ld.sh	r0,r0[0x0]
80003b3e:	c3 0c       	rcall	80003b9e <pdca_int_handler+0x5e>

80003b40 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b40:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b42:	49 88       	lddpc	r8,80003ba0 <pdca_int_handler+0x60>
80003b44:	11 89       	ld.ub	r9,r8[0x0]
80003b46:	ec 19 00 01 	eorl	r9,0x1
80003b4a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b4c:	11 89       	ld.ub	r9,r8[0x0]
80003b4e:	a5 69       	lsl	r9,0x4
80003b50:	2f c9       	sub	r9,-4
80003b52:	49 5a       	lddpc	r10,80003ba4 <pdca_int_handler+0x64>
80003b54:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b56:	fe 7a 00 40 	mov	r10,-65472
80003b5a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b5c:	30 39       	mov	r9,3
80003b5e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b60:	11 8a       	ld.ub	r10,r8[0x0]
80003b62:	a5 6a       	lsl	r10,0x4
80003b64:	2f ca       	sub	r10,-4
80003b66:	49 18       	lddpc	r8,80003ba8 <pdca_int_handler+0x68>
80003b68:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b6a:	fe 78 00 00 	mov	r8,-65536
80003b6e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b70:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b72:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b74:	48 e8       	lddpc	r8,80003bac <pdca_int_handler+0x6c>
80003b76:	70 08       	ld.w	r8,r8[0x0]
80003b78:	58 08       	cp.w	r8,0
80003b7a:	c0 70       	breq	80003b88 <pdca_int_handler+0x48>
80003b7c:	48 99       	lddpc	r9,80003ba0 <pdca_int_handler+0x60>
80003b7e:	13 89       	ld.ub	r9,r9[0x0]
80003b80:	a5 69       	lsl	r9,0x4
80003b82:	48 ac       	lddpc	r12,80003ba8 <pdca_int_handler+0x68>
80003b84:	12 0c       	add	r12,r9
80003b86:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003b88:	48 a8       	lddpc	r8,80003bb0 <pdca_int_handler+0x70>
80003b8a:	70 08       	ld.w	r8,r8[0x0]
80003b8c:	58 08       	cp.w	r8,0
80003b8e:	c0 70       	breq	80003b9c <pdca_int_handler+0x5c>
80003b90:	48 49       	lddpc	r9,80003ba0 <pdca_int_handler+0x60>
80003b92:	13 89       	ld.ub	r9,r9[0x0]
80003b94:	a5 69       	lsl	r9,0x4
80003b96:	48 4c       	lddpc	r12,80003ba4 <pdca_int_handler+0x64>
80003b98:	12 0c       	add	r12,r9
80003b9a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003b9c:	d4 02       	popm	lr
80003b9e:	d6 03       	rete
80003ba0:	00 00       	add	r0,r0
80003ba2:	40 90       	lddsp	r0,sp[0x24]
80003ba4:	00 00       	add	r0,r0
80003ba6:	40 b8       	lddsp	r8,sp[0x2c]
80003ba8:	00 00       	add	r0,r0
80003baa:	40 98       	lddsp	r8,sp[0x24]
80003bac:	00 00       	add	r0,r0
80003bae:	0a c8       	st.b	r5++,r8
80003bb0:	00 00       	add	r0,r0
80003bb2:	0a cc       	st.b	r5++,r12

80003bb4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bb4:	fe 78 10 00 	mov	r8,-61440
80003bb8:	e0 69 0d c0 	mov	r9,3520
80003bbc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bc0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bc4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bc8:	fe 78 34 00 	mov	r8,-52224
80003bcc:	e0 69 80 00 	mov	r9,32768
80003bd0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003bd2:	30 09       	mov	r9,0
80003bd4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003bd6:	e0 69 04 21 	mov	r9,1057
80003bda:	ea 19 3f 20 	orh	r9,0x3f20
80003bde:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003be0:	e0 69 02 9f 	mov	r9,671
80003be4:	ea 19 01 00 	orh	r9,0x100
80003be8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003bea:	e0 6a 04 02 	mov	r10,1026
80003bee:	ea 1a 3f 20 	orh	r10,0x3f20
80003bf2:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003bf4:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003bf6:	5e fc       	retal	r12

80003bf8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003bf8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003bfa:	30 19       	mov	r9,1
80003bfc:	49 78       	lddpc	r8,80003c58 <local_start_PDC+0x60>
80003bfe:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c00:	fe 78 00 00 	mov	r8,-65536
80003c04:	30 7b       	mov	r11,7
80003c06:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c08:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c0a:	49 59       	lddpc	r9,80003c5c <local_start_PDC+0x64>
80003c0c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c10:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c12:	30 3a       	mov	r10,3
80003c14:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c16:	30 1c       	mov	r12,1
80003c18:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c1a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c1c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c1e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c20:	30 2c       	mov	r12,2
80003c22:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c24:	48 f9       	lddpc	r9,80003c60 <local_start_PDC+0x68>
80003c26:	e0 68 5a 5a 	mov	r8,23130
80003c2a:	ea 18 ab cd 	orh	r8,0xabcd
80003c2e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c30:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c32:	30 0e       	mov	lr,0
80003c34:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c36:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c38:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c3a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c3c:	fe 78 00 40 	mov	r8,-65472
80003c40:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c42:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c44:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c48:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c4a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c4c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c4e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c50:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c52:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c54:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c56:	d8 02       	popm	pc
80003c58:	00 00       	add	r0,r0
80003c5a:	40 90       	lddsp	r0,sp[0x24]
80003c5c:	00 00       	add	r0,r0
80003c5e:	40 98       	lddsp	r8,sp[0x24]
80003c60:	00 00       	add	r0,r0
80003c62:	40 b8       	lddsp	r8,sp[0x2c]

80003c64 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c64:	48 38       	lddpc	r8,80003c70 <register_rx_tx_func+0xc>
80003c66:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c68:	48 38       	lddpc	r8,80003c74 <register_rx_tx_func+0x10>
80003c6a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c6c:	5e fc       	retal	r12
80003c6e:	00 00       	add	r0,r0
80003c70:	00 00       	add	r0,r0
80003c72:	0a c8       	st.b	r5++,r8
80003c74:	00 00       	add	r0,r0
80003c76:	0a cc       	st.b	r5++,r12

80003c78 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c78:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c7a:	fe 78 10 00 	mov	r8,-61440
80003c7e:	30 29       	mov	r9,2
80003c80:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c84:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003c88:	30 3a       	mov	r10,3
80003c8a:	36 0b       	mov	r11,96
80003c8c:	49 3c       	lddpc	r12,80003cd8 <ssc_init+0x60>
80003c8e:	f0 1f 00 14 	mcall	80003cdc <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003c92:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003c94:	fe 79 10 00 	mov	r9,-61440
80003c98:	f2 f8 01 60 	ld.w	r8,r9[352]
80003c9c:	e2 18 00 02 	andl	r8,0x2,COH
80003ca0:	cf c0       	breq	80003c98 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ca2:	fe 79 10 00 	mov	r9,-61440
80003ca6:	f2 f8 01 60 	ld.w	r8,r9[352]
80003caa:	e2 18 00 02 	andl	r8,0x2,COH
80003cae:	cf c1       	brne	80003ca6 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003cb0:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003cb2:	f0 1f 00 0c 	mcall	80003ce0 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003cb6:	f0 1f 00 0c 	mcall	80003ce4 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cba:	fe 79 00 00 	mov	r9,-65536
80003cbe:	30 18       	mov	r8,1
80003cc0:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cc2:	fe 7a 00 40 	mov	r10,-65472
80003cc6:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cc8:	e0 6b 01 01 	mov	r11,257
80003ccc:	fe 7a 34 00 	mov	r10,-52224
80003cd0:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003cd2:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003cd4:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003cd6:	d8 02       	popm	pc
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	3b 40       	mov	r0,-76
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	46 c8       	lddsp	r8,sp[0x1b0]
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	3b b4       	mov	r4,-69
80003ce4:	80 00       	ld.sh	r0,r0[0x0]
80003ce6:	3b f8       	mov	r8,-65

80003ce8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ce8:	48 28       	lddpc	r8,80003cf0 <xcmp_register_app_list+0x8>
80003cea:	91 0c       	st.w	r8[0x0],r12
}
80003cec:	5e fc       	retal	r12
80003cee:	00 00       	add	r0,r0
80003cf0:	00 00       	add	r0,r0
80003cf2:	40 d8       	lddsp	r8,sp[0x34]

80003cf4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003cf4:	eb cd 40 80 	pushm	r7,lr
80003cf8:	fa cd 01 00 	sub	sp,sp,256
80003cfc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003cfe:	16 98       	mov	r8,r11
80003d00:	2f 08       	sub	r8,-16
80003d02:	af a8       	sbr	r8,0xe
80003d04:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d06:	3f f8       	mov	r8,-1
80003d08:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d0a:	30 b9       	mov	r9,11
80003d0c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d0e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d10:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d12:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d14:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d16:	f6 ca ff fe 	sub	r10,r11,-2
80003d1a:	18 9b       	mov	r11,r12
80003d1c:	fa cc ff f0 	sub	r12,sp,-16
80003d20:	f0 1f 00 05 	mcall	80003d34 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d24:	2f e7       	sub	r7,-2
80003d26:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d28:	1a 9c       	mov	r12,sp
80003d2a:	f0 1f 00 04 	mcall	80003d38 <xcmp_tx+0x44>
}
80003d2e:	2c 0d       	sub	sp,-256
80003d30:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d34:	80 00       	ld.sh	r0,r0[0x0]
80003d36:	65 08       	ld.w	r8,r2[0x40]
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	42 74       	lddsp	r4,sp[0x9c]

80003d3c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003d3c:	d4 01       	pushm	lr
80003d3e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003d42:	fe 78 b4 00 	mov	r8,-19456
80003d46:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003d48:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003d4c:	30 89       	mov	r9,8
80003d4e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003d50:	30 19       	mov	r9,1
80003d52:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003d54:	30 09       	mov	r9,0
80003d56:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003d58:	30 5a       	mov	r10,5
80003d5a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003d5c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003d5e:	30 7a       	mov	r10,7
80003d60:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003d62:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003d64:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003d66:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003d6a:	30 9b       	mov	r11,9
80003d6c:	fa cc ff fe 	sub	r12,sp,-2
80003d70:	f0 1f 00 02 	mcall	80003d78 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003d74:	2c dd       	sub	sp,-204
80003d76:	d8 02       	popm	pc
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	3c f4       	mov	r4,-49

80003d7c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003d7c:	d4 01       	pushm	lr
80003d7e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003d82:	fe 78 80 00 	mov	r8,-32768
80003d86:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003d88:	30 38       	mov	r8,3
80003d8a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003d8c:	30 1b       	mov	r11,1
80003d8e:	fa cc ff fe 	sub	r12,sp,-2
80003d92:	f0 1f 00 03 	mcall	80003d9c <xcmp_opcode_not_supported+0x20>
}
80003d96:	2c dd       	sub	sp,-204
80003d98:	d8 02       	popm	pc
80003d9a:	00 00       	add	r0,r0
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	3c f4       	mov	r4,-49

80003da0 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003da0:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003da2:	96 88       	ld.uh	r8,r11[0x0]
80003da4:	e2 18 f0 00 	andl	r8,0xf000,COH
80003da8:	e0 48 80 00 	cp.w	r8,32768
80003dac:	c0 f0       	breq	80003dca <xcmp_exec_func+0x2a>
80003dae:	e0 48 b0 00 	cp.w	r8,45056
80003db2:	c1 20       	breq	80003dd6 <xcmp_exec_func+0x36>
80003db4:	58 08       	cp.w	r8,0
80003db6:	c1 51       	brne	80003de0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003db8:	78 08       	ld.w	r8,r12[0x0]
80003dba:	58 08       	cp.w	r8,0
80003dbc:	c0 40       	breq	80003dc4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003dbe:	16 9c       	mov	r12,r11
80003dc0:	5d 18       	icall	r8
80003dc2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003dc4:	f0 1f 00 08 	mcall	80003de4 <xcmp_exec_func+0x44>
80003dc8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003dca:	78 18       	ld.w	r8,r12[0x4]
80003dcc:	58 08       	cp.w	r8,0
80003dce:	c0 90       	breq	80003de0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003dd0:	16 9c       	mov	r12,r11
80003dd2:	5d 18       	icall	r8
80003dd4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003dd6:	78 28       	ld.w	r8,r12[0x8]
80003dd8:	58 08       	cp.w	r8,0
80003dda:	c0 30       	breq	80003de0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003ddc:	16 9c       	mov	r12,r11
80003dde:	5d 18       	icall	r8
80003de0:	d8 02       	popm	pc
80003de2:	00 00       	add	r0,r0
80003de4:	80 00       	ld.sh	r0,r0[0x0]
80003de6:	3d 7c       	mov	r12,-41

80003de8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
80003de8:	d4 01       	pushm	lr
80003dea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003dee:	e0 68 04 09 	mov	r8,1033
80003df2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003df4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003df8:	30 19       	mov	r9,1
80003dfa:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
80003dfc:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80003e00:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
80003e02:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003e04:	30 09       	mov	r9,0
80003e06:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003e08:	fb 69 00 08 	st.b	sp[8],r9
80003e0c:	fa c8 ff f7 	sub	r8,sp,-9
80003e10:	b0 89       	st.b	r8[0x0],r9
80003e12:	fa c8 ff f6 	sub	r8,sp,-10
80003e16:	b0 89       	st.b	r8[0x0],r9
80003e18:	fa c8 ff f5 	sub	r8,sp,-11
80003e1c:	b0 89       	st.b	r8[0x0],r9
80003e1e:	fa c8 ff f4 	sub	r8,sp,-12
80003e22:	b0 89       	st.b	r8[0x0],r9
80003e24:	fa c8 ff f3 	sub	r8,sp,-13
80003e28:	b0 89       	st.b	r8[0x0],r9
80003e2a:	fa c8 ff f2 	sub	r8,sp,-14
80003e2e:	b0 89       	st.b	r8[0x0],r9
80003e30:	fa c8 ff f1 	sub	r8,sp,-15
80003e34:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003e36:	30 cb       	mov	r11,12
80003e38:	fa cc ff fe 	sub	r12,sp,-2
80003e3c:	f0 1f 00 02 	mcall	80003e44 <xcmp_IdleTestTone+0x5c>
}
80003e40:	2c dd       	sub	sp,-204
80003e42:	d8 02       	popm	pc
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	3c f4       	mov	r4,-49

80003e48 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003e48:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003e4a:	48 dc       	lddpc	r12,80003e7c <xcmp_init+0x34>
80003e4c:	f0 1f 00 0d 	mcall	80003e80 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003e50:	30 4b       	mov	r11,4
80003e52:	31 4c       	mov	r12,20
80003e54:	f0 1f 00 0c 	mcall	80003e84 <xcmp_init+0x3c>
80003e58:	48 c8       	lddpc	r8,80003e88 <xcmp_init+0x40>
80003e5a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003e5c:	30 09       	mov	r9,0
80003e5e:	1a d9       	st.w	--sp,r9
80003e60:	1a d9       	st.w	--sp,r9
80003e62:	1a d9       	st.w	--sp,r9
80003e64:	30 38       	mov	r8,3
80003e66:	e0 6a 01 80 	mov	r10,384
80003e6a:	48 9b       	lddpc	r11,80003e8c <xcmp_init+0x44>
80003e6c:	48 9c       	lddpc	r12,80003e90 <xcmp_init+0x48>
80003e6e:	f0 1f 00 0a 	mcall	80003e94 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003e72:	f0 1f 00 0a 	mcall	80003e98 <xcmp_init+0x50>
80003e76:	2f dd       	sub	sp,-12
	
}
80003e78:	d8 02       	popm	pc
80003e7a:	00 00       	add	r0,r0
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	3f 98       	mov	r8,-7
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	3f e4       	mov	r4,-2
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	52 00       	stdsp	sp[0x80],r0
80003e88:	00 00       	add	r0,r0
80003e8a:	0a e8       	st.h	--r5,r8
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	c3 38       	rjmp	80003ef4 <xcmp_rx_process+0x58>
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3e 9c       	mov	r12,-23
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	58 d4       	cp.w	r4,13
80003e98:	80 00       	ld.sh	r0,r0[0x0]
80003e9a:	40 1c       	lddsp	r12,sp[0x4]

80003e9c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003e9c:	d4 31       	pushm	r0-r7,lr
80003e9e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003ea0:	4b 16       	lddpc	r6,80003f64 <xcmp_rx_process+0xc8>
80003ea2:	30 05       	mov	r5,0
80003ea4:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ea6:	4b 13       	lddpc	r3,80003f68 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003ea8:	4b 12       	lddpc	r2,80003f6c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003eaa:	4b 21       	lddpc	r1,80003f70 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003eac:	4b 20       	lddpc	r0,80003f74 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003eae:	6c 0c       	ld.w	r12,r6[0x0]
80003eb0:	0a 99       	mov	r9,r5
80003eb2:	08 9a       	mov	r10,r4
80003eb4:	1a 9b       	mov	r11,sp
80003eb6:	f0 1f 00 31 	mcall	80003f78 <xcmp_rx_process+0xdc>
80003eba:	58 1c       	cp.w	r12,1
80003ebc:	cf 91       	brne	80003eae <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003ebe:	40 0b       	lddsp	r11,sp[0x0]
80003ec0:	58 0b       	cp.w	r11,0
80003ec2:	cf 60       	breq	80003eae <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003ec4:	96 0a       	ld.sh	r10,r11[0x0]
80003ec6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003eca:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003ece:	59 c8       	cp.w	r8,28
80003ed0:	c1 e0       	breq	80003f0c <xcmp_rx_process+0x70>
80003ed2:	e0 89 00 07 	brgt	80003ee0 <xcmp_rx_process+0x44>
80003ed6:	58 e8       	cp.w	r8,14
80003ed8:	c0 e0       	breq	80003ef4 <xcmp_rx_process+0x58>
80003eda:	58 f8       	cp.w	r8,15
80003edc:	c2 41       	brne	80003f24 <xcmp_rx_process+0x88>
80003ede:	c0 f8       	rjmp	80003efc <xcmp_rx_process+0x60>
80003ee0:	e0 48 01 09 	cp.w	r8,265
80003ee4:	c1 80       	breq	80003f14 <xcmp_rx_process+0x78>
80003ee6:	e0 48 01 0a 	cp.w	r8,266
80003eea:	c1 90       	breq	80003f1c <xcmp_rx_process+0x80>
80003eec:	e0 48 00 2c 	cp.w	r8,44
80003ef0:	c1 a1       	brne	80003f24 <xcmp_rx_process+0x88>
80003ef2:	c0 98       	rjmp	80003f04 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003ef4:	4a 2c       	lddpc	r12,80003f7c <xcmp_rx_process+0xe0>
80003ef6:	f0 1f 00 23 	mcall	80003f80 <xcmp_rx_process+0xe4>
					break;
80003efa:	c2 f8       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003efc:	4a 2c       	lddpc	r12,80003f84 <xcmp_rx_process+0xe8>
80003efe:	f0 1f 00 21 	mcall	80003f80 <xcmp_rx_process+0xe4>
					break;
80003f02:	c2 b8       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003f04:	4a 1c       	lddpc	r12,80003f88 <xcmp_rx_process+0xec>
80003f06:	f0 1f 00 1f 	mcall	80003f80 <xcmp_rx_process+0xe4>
					break;
80003f0a:	c2 78       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f0c:	04 9c       	mov	r12,r2
80003f0e:	f0 1f 00 1d 	mcall	80003f80 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003f12:	c2 38       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f14:	02 9c       	mov	r12,r1
80003f16:	f0 1f 00 1b 	mcall	80003f80 <xcmp_rx_process+0xe4>
					break;
80003f1a:	c1 f8       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f1c:	00 9c       	mov	r12,r0
80003f1e:	f0 1f 00 19 	mcall	80003f80 <xcmp_rx_process+0xe4>
					break;
80003f22:	c1 b8       	rjmp	80003f58 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003f24:	12 98       	mov	r8,r9
80003f26:	e2 18 04 00 	andl	r8,0x400,COH
80003f2a:	c0 70       	breq	80003f38 <xcmp_rx_process+0x9c>
80003f2c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003f30:	e0 48 00 68 	cp.w	r8,104
80003f34:	e0 8a 00 08 	brle	80003f44 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003f38:	e2 19 f0 00 	andl	r9,0xf000,COH
80003f3c:	c0 e1       	brne	80003f58 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003f3e:	f0 1f 00 14 	mcall	80003f8c <xcmp_rx_process+0xf0>
80003f42:	c0 b8       	rjmp	80003f58 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003f44:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003f48:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003f4c:	49 19       	lddpc	r9,80003f90 <xcmp_rx_process+0xf4>
80003f4e:	72 08       	ld.w	r8,r9[0x0]
80003f50:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003f54:	f0 1f 00 0b 	mcall	80003f80 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f58:	66 0c       	ld.w	r12,r3[0x0]
80003f5a:	40 0b       	lddsp	r11,sp[0x0]
80003f5c:	f0 1f 00 0e 	mcall	80003f94 <xcmp_rx_process+0xf8>
80003f60:	ca 7b       	rjmp	80003eae <xcmp_rx_process+0x12>
80003f62:	00 00       	add	r0,r0
80003f64:	00 00       	add	r0,r0
80003f66:	0a e8       	st.h	--r5,r8
80003f68:	00 00       	add	r0,r0
80003f6a:	0a a0       	st.w	r5++,r0
80003f6c:	00 00       	add	r0,r0
80003f6e:	0a f8       	st.b	--r5,r8
80003f70:	00 00       	add	r0,r0
80003f72:	0a ec       	st.h	--r5,r12
80003f74:	00 00       	add	r0,r0
80003f76:	0a dc       	st.w	--r5,r12
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	4e f4       	lddpc	r4,80004134 <xnl_init+0x118>
80003f7c:	00 00       	add	r0,r0
80003f7e:	0b 10       	ld.sh	r0,r5++
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3d a0       	mov	r0,-38
80003f84:	00 00       	add	r0,r0
80003f86:	0a d0       	st.w	--r5,r0
80003f88:	00 00       	add	r0,r0
80003f8a:	0b 04       	ld.w	r4,r5++
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	3d 7c       	mov	r12,-41
80003f90:	00 00       	add	r0,r0
80003f92:	40 d8       	lddsp	r8,sp[0x34]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	29 c0       	sub	r0,-100

80003f98 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80003f98:	eb cd 40 90 	pushm	r4,r7,lr
80003f9c:	20 1d       	sub	sp,4
80003f9e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003fa2:	48 c8       	lddpc	r8,80003fd0 <xcmp_rx+0x38>
80003fa4:	70 0c       	ld.w	r12,r8[0x0]
80003fa6:	f0 1f 00 0c 	mcall	80003fd4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80003faa:	c1 00       	breq	80003fca <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003fac:	fa c7 ff fc 	sub	r7,sp,-4
80003fb0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80003fb2:	e0 6a 00 ca 	mov	r10,202
80003fb6:	08 9b       	mov	r11,r4
80003fb8:	f0 1f 00 08 	mcall	80003fd8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80003fbc:	48 88       	lddpc	r8,80003fdc <xcmp_rx+0x44>
80003fbe:	70 0c       	ld.w	r12,r8[0x0]
80003fc0:	30 09       	mov	r9,0
80003fc2:	12 9a       	mov	r10,r9
80003fc4:	1a 9b       	mov	r11,sp
80003fc6:	f0 1f 00 07 	mcall	80003fe0 <xcmp_rx+0x48>
	}	
}
80003fca:	2f fd       	sub	sp,-4
80003fcc:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80003fd0:	00 00       	add	r0,r0
80003fd2:	0a a0       	st.w	r5++,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	2b 6c       	sub	r12,-74
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	65 08       	ld.w	r8,r2[0x40]
80003fdc:	00 00       	add	r0,r0
80003fde:	0a e8       	st.h	--r5,r8
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	51 00       	stdsp	sp[0x40],r0

80003fe4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80003fe4:	48 28       	lddpc	r8,80003fec <xnl_register_xcmp_func+0x8>
80003fe6:	91 0c       	st.w	r8[0x0],r12
}
80003fe8:	5e fc       	retal	r12
80003fea:	00 00       	add	r0,r0
80003fec:	00 00       	add	r0,r0
80003fee:	0b 40       	ld.w	r0,--r5

80003ff0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80003ff0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80003ff2:	48 88       	lddpc	r8,80004010 <xnl_get_msg_ack_func+0x20>
80003ff4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80003ff6:	98 49       	ld.sh	r9,r12[0x8]
80003ff8:	f0 09 19 00 	cp.h	r9,r8
80003ffc:	c0 81       	brne	8000400c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80003ffe:	48 68       	lddpc	r8,80004014 <xnl_get_msg_ack_func+0x24>
80004000:	70 0c       	ld.w	r12,r8[0x0]
80004002:	30 09       	mov	r9,0
80004004:	12 9a       	mov	r10,r9
80004006:	12 9b       	mov	r11,r9
80004008:	f0 1f 00 04 	mcall	80004018 <xnl_get_msg_ack_func+0x28>
8000400c:	d8 02       	popm	pc
8000400e:	00 00       	add	r0,r0
80004010:	00 00       	add	r0,r0
80004012:	0b 20       	ld.uh	r0,r5++
80004014:	00 00       	add	r0,r0
80004016:	0b 1c       	ld.sh	r12,r5++
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	51 00       	stdsp	sp[0x40],r0

8000401c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000401c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004020:	30 09       	mov	r9,0
80004022:	4b 78       	lddpc	r8,800040fc <xnl_init+0xe0>
80004024:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004026:	30 0b       	mov	r11,0
80004028:	30 1c       	mov	r12,1
8000402a:	f0 1f 00 36 	mcall	80004100 <xnl_init+0xe4>
8000402e:	4b 68       	lddpc	r8,80004104 <xnl_init+0xe8>
80004030:	91 0c       	st.w	r8[0x0],r12
80004032:	70 08       	ld.w	r8,r8[0x0]
80004034:	58 08       	cp.w	r8,0
80004036:	c0 80       	breq	80004046 <xnl_init+0x2a>
80004038:	4b 38       	lddpc	r8,80004104 <xnl_init+0xe8>
8000403a:	70 0c       	ld.w	r12,r8[0x0]
8000403c:	30 09       	mov	r9,0
8000403e:	12 9a       	mov	r10,r9
80004040:	12 9b       	mov	r11,r9
80004042:	f0 1f 00 32 	mcall	80004108 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004046:	30 4b       	mov	r11,4
80004048:	31 4c       	mov	r12,20
8000404a:	f0 1f 00 2e 	mcall	80004100 <xnl_init+0xe4>
8000404e:	4b 08       	lddpc	r8,8000410c <xnl_init+0xf0>
80004050:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004052:	30 4b       	mov	r11,4
80004054:	31 ec       	mov	r12,30
80004056:	f0 1f 00 2b 	mcall	80004100 <xnl_init+0xe4>
8000405a:	4a e8       	lddpc	r8,80004110 <xnl_init+0xf4>
8000405c:	91 0c       	st.w	r8[0x0],r12
8000405e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004060:	10 96       	mov	r6,r8
80004062:	4a d5       	lddpc	r5,80004114 <xnl_init+0xf8>
80004064:	6c 0c       	ld.w	r12,r6[0x0]
80004066:	ea 07 00 0b 	add	r11,r5,r7
8000406a:	f0 1f 00 2c 	mcall	80004118 <xnl_init+0xfc>
8000406e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004072:	e0 47 1e 00 	cp.w	r7,7680
80004076:	cf 71       	brne	80004064 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004078:	30 4b       	mov	r11,4
8000407a:	31 4c       	mov	r12,20
8000407c:	f0 1f 00 21 	mcall	80004100 <xnl_init+0xe4>
80004080:	4a 78       	lddpc	r8,8000411c <xnl_init+0x100>
80004082:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004084:	30 4b       	mov	r11,4
80004086:	30 ac       	mov	r12,10
80004088:	f0 1f 00 1e 	mcall	80004100 <xnl_init+0xe4>
8000408c:	4a 58       	lddpc	r8,80004120 <xnl_init+0x104>
8000408e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004090:	30 4b       	mov	r11,4
80004092:	30 ac       	mov	r12,10
80004094:	f0 1f 00 1b 	mcall	80004100 <xnl_init+0xe4>
80004098:	4a 38       	lddpc	r8,80004124 <xnl_init+0x108>
8000409a:	91 0c       	st.w	r8[0x0],r12
8000409c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000409e:	10 96       	mov	r6,r8
800040a0:	4a 25       	lddpc	r5,80004128 <xnl_init+0x10c>
800040a2:	6c 0c       	ld.w	r12,r6[0x0]
800040a4:	ea 07 00 0b 	add	r11,r5,r7
800040a8:	f0 1f 00 1c 	mcall	80004118 <xnl_init+0xfc>
800040ac:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800040b0:	e0 47 14 00 	cp.w	r7,5120
800040b4:	cf 71       	brne	800040a2 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800040b6:	30 4b       	mov	r11,4
800040b8:	30 5c       	mov	r12,5
800040ba:	f0 1f 00 12 	mcall	80004100 <xnl_init+0xe4>
800040be:	49 c8       	lddpc	r8,8000412c <xnl_init+0x110>
800040c0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800040c2:	30 07       	mov	r7,0
800040c4:	1a d7       	st.w	--sp,r7
800040c6:	1a d7       	st.w	--sp,r7
800040c8:	1a d7       	st.w	--sp,r7
800040ca:	30 38       	mov	r8,3
800040cc:	0e 99       	mov	r9,r7
800040ce:	e0 6a 02 00 	mov	r10,512
800040d2:	49 8b       	lddpc	r11,80004130 <xnl_init+0x114>
800040d4:	49 8c       	lddpc	r12,80004134 <xnl_init+0x118>
800040d6:	f0 1f 00 19 	mcall	80004138 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800040da:	1a d7       	st.w	--sp,r7
800040dc:	1a d7       	st.w	--sp,r7
800040de:	1a d7       	st.w	--sp,r7
800040e0:	30 38       	mov	r8,3
800040e2:	0e 99       	mov	r9,r7
800040e4:	e0 6a 03 20 	mov	r10,800
800040e8:	49 5b       	lddpc	r11,8000413c <xnl_init+0x120>
800040ea:	49 6c       	lddpc	r12,80004140 <xnl_init+0x124>
800040ec:	f0 1f 00 13 	mcall	80004138 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800040f0:	f0 1f 00 15 	mcall	80004144 <xnl_init+0x128>
800040f4:	2f ad       	sub	sp,-24
}
800040f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800040fa:	00 00       	add	r0,r0
800040fc:	00 00       	add	r0,r0
800040fe:	0b 20       	ld.uh	r0,r5++
80004100:	80 00       	ld.sh	r0,r0[0x0]
80004102:	52 00       	stdsp	sp[0x80],r0
80004104:	00 00       	add	r0,r0
80004106:	0b 1c       	ld.sh	r12,r5++
80004108:	80 00       	ld.sh	r0,r0[0x0]
8000410a:	51 00       	stdsp	sp[0x40],r0
8000410c:	00 00       	add	r0,r0
8000410e:	0b 2c       	ld.uh	r12,r5++
80004110:	00 00       	add	r0,r0
80004112:	0a a0       	st.w	r5++,r0
80004114:	00 00       	add	r0,r0
80004116:	22 8a       	sub	r10,40
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	29 c0       	sub	r0,-100
8000411c:	00 00       	add	r0,r0
8000411e:	0a b0       	st.h	r5++,r0
80004120:	00 00       	add	r0,r0
80004122:	0a a4       	st.w	r5++,r4
80004124:	00 00       	add	r0,r0
80004126:	0a 5c       	eor	r12,r5
80004128:	00 00       	add	r0,r0
8000412a:	0e 8a       	andn	r10,r7
8000412c:	00 00       	add	r0,r0
8000412e:	0a 78       	tst	r8,r5
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	c3 40       	breq	8000419a <xnl_rx_process+0x52>
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	41 48       	lddsp	r8,sp[0x50]
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	58 d4       	cp.w	r4,13
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	bc 00       	st.h	lr[0x0],r0
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	41 a8       	lddsp	r8,sp[0x68]
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	2b 94       	sub	r4,-71

80004148 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004148:	eb cd 40 fe 	pushm	r1-r7,lr
8000414c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000414e:	49 26       	lddpc	r6,80004194 <xnl_rx_process+0x4c>
80004150:	30 05       	mov	r5,0
80004152:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004154:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004156:	49 11       	lddpc	r1,80004198 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004158:	49 12       	lddpc	r2,8000419c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000415a:	6c 0c       	ld.w	r12,r6[0x0]
8000415c:	0a 99       	mov	r9,r5
8000415e:	08 9a       	mov	r10,r4
80004160:	1a 9b       	mov	r11,sp
80004162:	f0 1f 00 10 	mcall	800041a0 <xnl_rx_process+0x58>
80004166:	58 1c       	cp.w	r12,1
80004168:	cf 91       	brne	8000415a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000416a:	40 0c       	lddsp	r12,sp[0x0]
8000416c:	58 0c       	cp.w	r12,0
8000416e:	cf 60       	breq	8000415a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004170:	98 28       	ld.sh	r8,r12[0x4]
80004172:	e6 08 19 00 	cp.h	r8,r3
80004176:	e0 8b 00 0a 	brhi	8000418a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000417a:	5c 78       	castu.h	r8
8000417c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004180:	58 09       	cp.w	r9,0
80004182:	c0 40       	breq	8000418a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004184:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004188:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000418a:	62 0c       	ld.w	r12,r1[0x0]
8000418c:	40 0b       	lddsp	r11,sp[0x0]
8000418e:	f0 1f 00 06 	mcall	800041a4 <xnl_rx_process+0x5c>
80004192:	ce 4b       	rjmp	8000415a <xnl_rx_process+0x12>
80004194:	00 00       	add	r0,r0
80004196:	0a a4       	st.w	r5++,r4
80004198:	00 00       	add	r0,r0
8000419a:	0a a0       	st.w	r5++,r0
8000419c:	00 00       	add	r0,r0
8000419e:	04 f0       	st.b	--r2,r0
800041a0:	80 00       	ld.sh	r0,r0[0x0]
800041a2:	4e f4       	lddpc	r4,8000435c <xnl_data_msg_func+0x4>
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	29 c0       	sub	r0,-100

800041a8 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800041a8:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800041aa:	4a a6       	lddpc	r6,80004250 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800041ac:	4a a2       	lddpc	r2,80004254 <xnl_tx_process+0xac>
800041ae:	4a b4       	lddpc	r4,80004258 <xnl_tx_process+0xb0>
800041b0:	30 07       	mov	r7,0
800041b2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800041b4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800041b6:	4a a5       	lddpc	r5,8000425c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800041b8:	4a a3       	lddpc	r3,80004260 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800041ba:	6c 08       	ld.w	r8,r6[0x0]
800041bc:	58 08       	cp.w	r8,0
800041be:	c0 40       	breq	800041c6 <xnl_tx_process+0x1e>
800041c0:	58 18       	cp.w	r8,1
800041c2:	cf d1       	brne	800041bc <xnl_tx_process+0x14>
800041c4:	c2 48       	rjmp	8000420c <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800041c6:	64 0c       	ld.w	r12,r2[0x0]
800041c8:	0e 99       	mov	r9,r7
800041ca:	02 9a       	mov	r10,r1
800041cc:	08 9b       	mov	r11,r4
800041ce:	f0 1f 00 26 	mcall	80004264 <xnl_tx_process+0xbc>
800041d2:	58 1c       	cp.w	r12,1
800041d4:	cf 31       	brne	800041ba <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800041d6:	68 0b       	ld.w	r11,r4[0x0]
800041d8:	58 0b       	cp.w	r11,0
800041da:	cf 00       	breq	800041ba <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800041dc:	96 28       	ld.sh	r8,r11[0x4]
800041de:	e0 08 19 00 	cp.h	r8,r0
800041e2:	c0 71       	brne	800041f0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800041e4:	4a 18       	lddpc	r8,80004268 <xnl_tx_process+0xc0>
800041e6:	70 08       	ld.w	r8,r8[0x0]
800041e8:	10 9c       	mov	r12,r8
800041ea:	f0 1f 00 21 	mcall	8000426c <xnl_tx_process+0xc4>
						break;
800041ee:	ce 6b       	rjmp	800041ba <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800041f0:	16 9c       	mov	r12,r11
800041f2:	f0 1f 00 20 	mcall	80004270 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800041f6:	30 18       	mov	r8,1
800041f8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800041fa:	66 0c       	ld.w	r12,r3[0x0]
800041fc:	0e 99       	mov	r9,r7
800041fe:	0e 9a       	mov	r10,r7
80004200:	0e 9b       	mov	r11,r7
80004202:	f0 1f 00 19 	mcall	80004264 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004206:	30 18       	mov	r8,1
80004208:	8d 08       	st.w	r6[0x0],r8
8000420a:	cd 8b       	rjmp	800041ba <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
8000420c:	66 0c       	ld.w	r12,r3[0x0]
8000420e:	0e 99       	mov	r9,r7
80004210:	36 4a       	mov	r10,100
80004212:	0e 9b       	mov	r11,r7
80004214:	f0 1f 00 14 	mcall	80004264 <xnl_tx_process+0xbc>
80004218:	58 1c       	cp.w	r12,1
8000421a:	c0 81       	brne	8000422a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
8000421c:	49 38       	lddpc	r8,80004268 <xnl_tx_process+0xc0>
8000421e:	70 0c       	ld.w	r12,r8[0x0]
80004220:	68 0b       	ld.w	r11,r4[0x0]
80004222:	f0 1f 00 13 	mcall	8000426c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004226:	8d 07       	st.w	r6[0x0],r7
80004228:	cc 9b       	rjmp	800041ba <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000422a:	6a 08       	ld.w	r8,r5[0x0]
8000422c:	58 38       	cp.w	r8,3
8000422e:	e0 89 00 09 	brgt	80004240 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004232:	68 0c       	ld.w	r12,r4[0x0]
80004234:	f0 1f 00 0f 	mcall	80004270 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004238:	6a 08       	ld.w	r8,r5[0x0]
8000423a:	2f f8       	sub	r8,-1
8000423c:	8b 08       	st.w	r5[0x0],r8
8000423e:	cb eb       	rjmp	800041ba <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004240:	48 a8       	lddpc	r8,80004268 <xnl_tx_process+0xc0>
80004242:	70 0c       	ld.w	r12,r8[0x0]
80004244:	68 0b       	ld.w	r11,r4[0x0]
80004246:	f0 1f 00 0a 	mcall	8000426c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000424a:	8d 07       	st.w	r6[0x0],r7
8000424c:	cb 7b       	rjmp	800041ba <xnl_tx_process+0x12>
8000424e:	00 00       	add	r0,r0
80004250:	00 00       	add	r0,r0
80004252:	0b 3c       	ld.ub	r12,r5++
80004254:	00 00       	add	r0,r0
80004256:	0b 2c       	ld.uh	r12,r5++
80004258:	00 00       	add	r0,r0
8000425a:	0b 34       	ld.ub	r4,r5++
8000425c:	00 00       	add	r0,r0
8000425e:	0b 30       	ld.ub	r0,r5++
80004260:	00 00       	add	r0,r0
80004262:	0b 1c       	ld.sh	r12,r5++
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	4e f4       	lddpc	r4,80004420 <xnl_device_auth_reply_func+0x68>
80004268:	00 00       	add	r0,r0
8000426a:	0a a0       	st.w	r5++,r0
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	29 c0       	sub	r0,-100
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	29 e0       	sub	r0,-98

80004274 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004274:	eb cd 40 c0 	pushm	r6-r7,lr
80004278:	20 1d       	sub	sp,4
8000427a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000427c:	98 39       	ld.sh	r9,r12[0x6]
8000427e:	3f f8       	mov	r8,-1
80004280:	f0 09 19 00 	cp.h	r9,r8
80004284:	c0 a1       	brne	80004298 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004286:	4a e9       	lddpc	r9,8000433c <xnl_tx+0xc8>
80004288:	13 88       	ld.ub	r8,r9[0x0]
8000428a:	2f f8       	sub	r8,-1
8000428c:	5c 58       	castu.b	r8
8000428e:	b2 88       	st.b	r9[0x0],r8
80004290:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004294:	a9 a8       	sbr	r8,0x8
80004296:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004298:	8c 49       	ld.sh	r9,r6[0x8]
8000429a:	3f f8       	mov	r8,-1
8000429c:	f0 09 19 00 	cp.h	r9,r8
800042a0:	c0 41       	brne	800042a8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800042a2:	4a 88       	lddpc	r8,80004340 <xnl_tx+0xcc>
800042a4:	90 18       	ld.sh	r8,r8[0x2]
800042a6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800042a8:	8c 59       	ld.sh	r9,r6[0xa]
800042aa:	3f f8       	mov	r8,-1
800042ac:	f0 09 19 00 	cp.h	r9,r8
800042b0:	c0 41       	brne	800042b8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800042b2:	4a 48       	lddpc	r8,80004340 <xnl_tx+0xcc>
800042b4:	90 28       	ld.sh	r8,r8[0x4]
800042b6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800042b8:	8c 69       	ld.sh	r9,r6[0xc]
800042ba:	3f f8       	mov	r8,-1
800042bc:	f0 09 19 00 	cp.h	r9,r8
800042c0:	c0 e1       	brne	800042dc <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800042c2:	4a 08       	lddpc	r8,80004340 <xnl_tx+0xcc>
800042c4:	90 49       	ld.sh	r9,r8[0x8]
800042c6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800042c8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800042ca:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800042cc:	90 49       	ld.sh	r9,r8[0x8]
800042ce:	e0 19 ff 00 	andl	r9,0xff00
800042d2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800042d6:	f3 e8 10 08 	or	r8,r9,r8
800042da:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800042dc:	0d 98       	ld.ub	r8,r6[0x1]
800042de:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800042e0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800042e4:	10 0c       	add	r12,r8
800042e6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800042e8:	58 0c       	cp.w	r12,0
800042ea:	e0 89 00 04 	brgt	800042f2 <xnl_tx+0x7e>
800042ee:	30 09       	mov	r9,0
800042f0:	c0 d8       	rjmp	8000430a <xnl_tx+0x96>
800042f2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800042f6:	2f ec       	sub	r12,-2
800042f8:	30 09       	mov	r9,0
800042fa:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800042fc:	15 1b       	ld.sh	r11,r10++
800042fe:	f6 09 00 09 	add	r9,r11,r9
80004302:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004304:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004306:	18 38       	cp.w	r8,r12
80004308:	cf a1       	brne	800042fc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000430a:	5c 39       	neg	r9
8000430c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000430e:	48 e8       	lddpc	r8,80004344 <xnl_tx+0xd0>
80004310:	70 0c       	ld.w	r12,r8[0x0]
80004312:	f0 1f 00 0e 	mcall	80004348 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004316:	c1 00       	breq	80004336 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004318:	fa c7 ff fc 	sub	r7,sp,-4
8000431c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000431e:	e0 6a 01 00 	mov	r10,256
80004322:	0c 9b       	mov	r11,r6
80004324:	f0 1f 00 0a 	mcall	8000434c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004328:	48 a8       	lddpc	r8,80004350 <xnl_tx+0xdc>
8000432a:	70 0c       	ld.w	r12,r8[0x0]
8000432c:	30 09       	mov	r9,0
8000432e:	12 9a       	mov	r10,r9
80004330:	1a 9b       	mov	r11,sp
80004332:	f0 1f 00 09 	mcall	80004354 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004336:	2f fd       	sub	sp,-4
80004338:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000433c:	00 00       	add	r0,r0
8000433e:	0b 38       	ld.ub	r8,r5++
80004340:	00 00       	add	r0,r0
80004342:	0b 20       	ld.uh	r0,r5++
80004344:	00 00       	add	r0,r0
80004346:	0a a0       	st.w	r5++,r0
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	2b 6c       	sub	r12,-74
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	65 08       	ld.w	r8,r2[0x40]
80004350:	00 00       	add	r0,r0
80004352:	0b 2c       	ld.uh	r12,r5++
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	51 00       	stdsp	sp[0x40],r0

80004358 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004358:	eb cd 40 80 	pushm	r7,lr
8000435c:	fa cd 01 00 	sub	sp,sp,256
80004360:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004362:	e0 68 40 0e 	mov	r8,16398
80004366:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004368:	3f f8       	mov	r8,-1
8000436a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000436c:	30 c8       	mov	r8,12
8000436e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004370:	98 38       	ld.sh	r8,r12[0x6]
80004372:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004374:	98 58       	ld.sh	r8,r12[0xa]
80004376:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004378:	98 48       	ld.sh	r8,r12[0x8]
8000437a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000437c:	98 68       	ld.sh	r8,r12[0xc]
8000437e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004380:	30 08       	mov	r8,0
80004382:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004384:	1a 9c       	mov	r12,sp
80004386:	f0 1f 00 0a 	mcall	800043ac <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000438a:	fa cd 00 cc 	sub	sp,sp,204
8000438e:	e0 6a 00 ca 	mov	r10,202
80004392:	ee cb ff f0 	sub	r11,r7,-16
80004396:	1a 9c       	mov	r12,sp
80004398:	f0 1f 00 06 	mcall	800043b0 <xnl_data_msg_func+0x58>
8000439c:	48 68       	lddpc	r8,800043b4 <xnl_data_msg_func+0x5c>
8000439e:	70 08       	ld.w	r8,r8[0x0]
800043a0:	5d 18       	icall	r8
800043a2:	fa cd ff 34 	sub	sp,sp,-204
}
800043a6:	2c 0d       	sub	sp,-256
800043a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	42 74       	lddsp	r4,sp[0x9c]
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	65 08       	ld.w	r8,r2[0x40]
800043b4:	00 00       	add	r0,r0
800043b6:	0b 40       	ld.w	r0,--r5

800043b8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800043b8:	d4 21       	pushm	r4-r7,lr
800043ba:	fa cd 01 00 	sub	sp,sp,256
800043be:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800043c0:	4c 28       	lddpc	r8,800044c8 <xnl_device_auth_reply_func+0x110>
800043c2:	11 88       	ld.ub	r8,r8[0x0]
800043c4:	58 08       	cp.w	r8,0
800043c6:	e0 81 00 7f 	brne	800044c4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800043ca:	4c 18       	lddpc	r8,800044cc <xnl_device_auth_reply_func+0x114>
800043cc:	70 0c       	ld.w	r12,r8[0x0]
800043ce:	30 09       	mov	r9,0
800043d0:	12 9a       	mov	r10,r9
800043d2:	12 9b       	mov	r11,r9
800043d4:	f0 1f 00 3f 	mcall	800044d0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800043d8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800043dc:	4b b8       	lddpc	r8,800044c8 <xnl_device_auth_reply_func+0x110>
800043de:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800043e0:	ef 39 00 12 	ld.ub	r9,r7[18]
800043e4:	ef 38 00 13 	ld.ub	r8,r7[19]
800043e8:	b1 68       	lsl	r8,0x10
800043ea:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800043ee:	ef 38 00 15 	ld.ub	r8,r7[21]
800043f2:	f3 e8 10 08 	or	r8,r9,r8
800043f6:	ef 39 00 14 	ld.ub	r9,r7[20]
800043fa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800043fe:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004402:	ef 38 00 17 	ld.ub	r8,r7[23]
80004406:	b1 68       	lsl	r8,0x10
80004408:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000440c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004410:	f5 e8 10 08 	or	r8,r10,r8
80004414:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004418:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000441c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000441e:	e0 64 79 b9 	mov	r4,31161
80004422:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004426:	e0 65 45 07 	mov	r5,17671
8000442a:	ea 15 8a bd 	orh	r5,0x8abd
8000442e:	e0 66 f9 3d 	mov	r6,63805
80004432:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004436:	e0 6e b8 cf 	mov	lr,47311
8000443a:	ea 1e 36 83 	orh	lr,0x3683
8000443e:	e0 67 aa 1c 	mov	r7,43548
80004442:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004446:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004448:	f4 08 00 0c 	add	r12,r10,r8
8000444c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004450:	0a 0b       	add	r11,r5
80004452:	f9 eb 20 0b 	eor	r11,r12,r11
80004456:	f0 0c 16 05 	lsr	r12,r8,0x5
8000445a:	0c 0c       	add	r12,r6
8000445c:	18 5b       	eor	r11,r12
8000445e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004460:	f2 0c 15 04 	lsl	r12,r9,0x4
80004464:	1c 0c       	add	r12,lr
80004466:	f2 0b 16 05 	lsr	r11,r9,0x5
8000446a:	0e 0b       	add	r11,r7
8000446c:	f9 eb 20 0b 	eor	r11,r12,r11
80004470:	f2 0a 00 0c 	add	r12,r9,r10
80004474:	18 5b       	eor	r11,r12
80004476:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004478:	e0 6b 37 20 	mov	r11,14112
8000447c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004480:	16 3a       	cp.w	r10,r11
80004482:	ce 21       	brne	80004446 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004484:	e0 6a 40 1a 	mov	r10,16410
80004488:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000448a:	3f fa       	mov	r10,-1
8000448c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000448e:	30 6b       	mov	r11,6
80004490:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004492:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004494:	48 db       	lddpc	r11,800044c8 <xnl_device_auth_reply_func+0x110>
80004496:	96 1c       	ld.sh	r12,r11[0x2]
80004498:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000449a:	96 2b       	ld.sh	r11,r11[0x4]
8000449c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000449e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800044a0:	30 ca       	mov	r10,12
800044a2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800044a4:	30 0a       	mov	r10,0
800044a6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800044aa:	30 7a       	mov	r10,7
800044ac:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800044b0:	30 2a       	mov	r10,2
800044b2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800044b6:	fa ca ff ec 	sub	r10,sp,-20
800044ba:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800044bc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044be:	1a 9c       	mov	r12,sp
800044c0:	f0 1f 00 05 	mcall	800044d4 <xnl_device_auth_reply_func+0x11c>
}
800044c4:	2c 0d       	sub	sp,-256
800044c6:	d8 22       	popm	r4-r7,pc
800044c8:	00 00       	add	r0,r0
800044ca:	0b 20       	ld.uh	r0,r5++
800044cc:	00 00       	add	r0,r0
800044ce:	0b 1c       	ld.sh	r12,r5++
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	51 00       	stdsp	sp[0x40],r0
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	42 74       	lddsp	r4,sp[0x9c]

800044d8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800044d8:	eb cd 40 80 	pushm	r7,lr
800044dc:	fa cd 01 00 	sub	sp,sp,256
800044e0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800044e2:	49 28       	lddpc	r8,80004528 <xnl_master_status_brdcst_func+0x50>
800044e4:	11 88       	ld.ub	r8,r8[0x0]
800044e6:	58 08       	cp.w	r8,0
800044e8:	c1 c1       	brne	80004520 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800044ea:	49 18       	lddpc	r8,8000452c <xnl_master_status_brdcst_func+0x54>
800044ec:	70 0c       	ld.w	r12,r8[0x0]
800044ee:	30 09       	mov	r9,0
800044f0:	12 9a       	mov	r10,r9
800044f2:	12 9b       	mov	r11,r9
800044f4:	f0 1f 00 0f 	mcall	80004530 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800044f8:	8e 58       	ld.sh	r8,r7[0xa]
800044fa:	48 c9       	lddpc	r9,80004528 <xnl_master_status_brdcst_func+0x50>
800044fc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044fe:	e0 68 40 0e 	mov	r8,16398
80004502:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004504:	3f f8       	mov	r8,-1
80004506:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004508:	30 4a       	mov	r10,4
8000450a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000450c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000450e:	92 19       	ld.sh	r9,r9[0x2]
80004510:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004512:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004514:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004516:	30 08       	mov	r8,0
80004518:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000451a:	1a 9c       	mov	r12,sp
8000451c:	f0 1f 00 06 	mcall	80004534 <xnl_master_status_brdcst_func+0x5c>
}
80004520:	2c 0d       	sub	sp,-256
80004522:	e3 cd 80 80 	ldm	sp++,r7,pc
80004526:	00 00       	add	r0,r0
80004528:	00 00       	add	r0,r0
8000452a:	0b 20       	ld.uh	r0,r5++
8000452c:	00 00       	add	r0,r0
8000452e:	0b 1c       	ld.sh	r12,r5++
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	51 00       	stdsp	sp[0x40],r0
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	42 74       	lddsp	r4,sp[0x9c]

80004538 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004538:	eb cd 40 80 	pushm	r7,lr
8000453c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000453e:	49 28       	lddpc	r8,80004584 <xnl_device_conn_reply_func+0x4c>
80004540:	70 0c       	ld.w	r12,r8[0x0]
80004542:	30 09       	mov	r9,0
80004544:	12 9a       	mov	r10,r9
80004546:	12 9b       	mov	r11,r9
80004548:	f0 1f 00 10 	mcall	80004588 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000454c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004550:	10 99       	mov	r9,r8
80004552:	e2 19 ff 00 	andl	r9,0xff00,COH
80004556:	e0 49 01 00 	cp.w	r9,256
8000455a:	c0 60       	breq	80004566 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000455c:	0e 9c       	mov	r12,r7
8000455e:	f0 1f 00 0c 	mcall	8000458c <xnl_device_conn_reply_func+0x54>
80004562:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004566:	a9 68       	lsl	r8,0x8
80004568:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000456c:	48 98       	lddpc	r8,80004590 <xnl_device_conn_reply_func+0x58>
8000456e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004570:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004574:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004576:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000457a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000457c:	30 19       	mov	r9,1
8000457e:	b0 89       	st.b	r8[0x0],r9
80004580:	e3 cd 80 80 	ldm	sp++,r7,pc
80004584:	00 00       	add	r0,r0
80004586:	0b 1c       	ld.sh	r12,r5++
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	51 00       	stdsp	sp[0x40],r0
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	44 d8       	lddsp	r8,sp[0x134]
80004590:	00 00       	add	r0,r0
80004592:	0b 20       	ld.uh	r0,r5++

80004594 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004594:	d4 01       	pushm	lr
80004596:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000459a:	e0 68 40 0e 	mov	r8,16398
8000459e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045a0:	3f f8       	mov	r8,-1
800045a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800045a4:	30 38       	mov	r8,3
800045a6:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800045a8:	30 08       	mov	r8,0
800045aa:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800045ac:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800045ae:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800045b0:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800045b2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045b4:	1a 9c       	mov	r12,sp
800045b6:	f0 1f 00 03 	mcall	800045c0 <xnl_send_device_master_query+0x2c>
}
800045ba:	2c 0d       	sub	sp,-256
800045bc:	d8 02       	popm	pc
800045be:	00 00       	add	r0,r0
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	42 74       	lddsp	r4,sp[0x9c]

800045c4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800045c4:	fe 78 0c 00 	mov	r8,-62464
800045c8:	e0 69 03 07 	mov	r9,775
800045cc:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800045ce:	30 49       	mov	r9,4
800045d0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800045d2:	71 59       	ld.w	r9,r8[0x54]
800045d4:	e2 19 00 80 	andl	r9,0x80,COH
800045d8:	cf d0       	breq	800045d2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800045da:	fe 78 0c 00 	mov	r8,-62464
800045de:	30 59       	mov	r9,5
800045e0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800045e2:	e0 69 01 0d 	mov	r9,269
800045e6:	ea 19 10 07 	orh	r9,0x1007
800045ea:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800045ec:	71 59       	ld.w	r9,r8[0x54]
800045ee:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800045f2:	cf d0       	breq	800045ec <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800045f4:	fe 78 0c 00 	mov	r8,-62464
800045f8:	fc 19 00 80 	movh	r9,0x80
800045fc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800045fe:	34 0a       	mov	r10,64
80004600:	fe 69 14 00 	mov	r9,-125952
80004604:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004606:	30 69       	mov	r9,6
80004608:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000460a:	30 19       	mov	r9,1
8000460c:	fe 68 10 00 	mov	r8,-126976
80004610:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
80004612:	5e fc       	retal	r12

80004614 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80004614:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80004616:	30 3b       	mov	r11,3
80004618:	48 8c       	lddpc	r12,80004638 <local_start_timer+0x24>
8000461a:	f0 1f 00 09 	mcall	8000463c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000461e:	fe 78 38 00 	mov	r8,-51200
80004622:	e0 69 91 0d 	mov	r9,37133
80004626:	ea 19 00 52 	orh	r9,0x52
8000462a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000462c:	32 09       	mov	r9,32
8000462e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004630:	30 59       	mov	r9,5
80004632:	91 09       	st.w	r8[0x0],r9
}
80004634:	d8 02       	popm	pc
80004636:	00 00       	add	r0,r0
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	c3 48       	rjmp	800046a2 <gpio_enable_module+0xe>
8000463c:	80 00       	ld.sh	r0,r0[0x0]
8000463e:	46 94       	lddsp	r4,sp[0x1a4]

80004640 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004640:	f8 08 16 05 	lsr	r8,r12,0x5
80004644:	a9 68       	lsl	r8,0x8
80004646:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000464a:	58 1b       	cp.w	r11,1
8000464c:	c0 d0       	breq	80004666 <gpio_enable_module_pin+0x26>
8000464e:	c0 63       	brcs	8000465a <gpio_enable_module_pin+0x1a>
80004650:	58 2b       	cp.w	r11,2
80004652:	c1 00       	breq	80004672 <gpio_enable_module_pin+0x32>
80004654:	58 3b       	cp.w	r11,3
80004656:	c1 40       	breq	8000467e <gpio_enable_module_pin+0x3e>
80004658:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000465a:	30 19       	mov	r9,1
8000465c:	f2 0c 09 49 	lsl	r9,r9,r12
80004660:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004662:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004664:	c1 28       	rjmp	80004688 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004666:	30 19       	mov	r9,1
80004668:	f2 0c 09 49 	lsl	r9,r9,r12
8000466c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000466e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004670:	c0 c8       	rjmp	80004688 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004672:	30 19       	mov	r9,1
80004674:	f2 0c 09 49 	lsl	r9,r9,r12
80004678:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000467a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000467c:	c0 68       	rjmp	80004688 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000467e:	30 19       	mov	r9,1
80004680:	f2 0c 09 49 	lsl	r9,r9,r12
80004684:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004686:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004688:	30 19       	mov	r9,1
8000468a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000468e:	91 2c       	st.w	r8[0x8],r12
80004690:	5e fd       	retal	0
80004692:	d7 03       	nop

80004694 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004694:	d4 21       	pushm	r4-r7,lr
80004696:	18 97       	mov	r7,r12
80004698:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000469a:	58 0b       	cp.w	r11,0
8000469c:	c0 31       	brne	800046a2 <gpio_enable_module+0xe>
8000469e:	30 05       	mov	r5,0
800046a0:	c0 d8       	rjmp	800046ba <gpio_enable_module+0x26>
800046a2:	30 06       	mov	r6,0
800046a4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800046a6:	6e 1b       	ld.w	r11,r7[0x4]
800046a8:	6e 0c       	ld.w	r12,r7[0x0]
800046aa:	f0 1f 00 06 	mcall	800046c0 <gpio_enable_module+0x2c>
800046ae:	18 45       	or	r5,r12
		gpiomap++;
800046b0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800046b2:	2f f6       	sub	r6,-1
800046b4:	0c 34       	cp.w	r4,r6
800046b6:	fe 9b ff f8 	brhi	800046a6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800046ba:	0a 9c       	mov	r12,r5
800046bc:	d8 22       	popm	r4-r7,pc
800046be:	00 00       	add	r0,r0
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	46 40       	lddsp	r0,sp[0x190]

800046c4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800046c4:	c0 08       	rjmp	800046c4 <_unhandled_interrupt>
800046c6:	d7 03       	nop

800046c8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800046c8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800046cc:	49 99       	lddpc	r9,80004730 <INTC_register_interrupt+0x68>
800046ce:	f2 08 00 39 	add	r9,r9,r8<<0x3
800046d2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800046d6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800046d8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800046dc:	58 0a       	cp.w	r10,0
800046de:	c0 91       	brne	800046f0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800046e0:	49 59       	lddpc	r9,80004734 <INTC_register_interrupt+0x6c>
800046e2:	49 6a       	lddpc	r10,80004738 <INTC_register_interrupt+0x70>
800046e4:	12 1a       	sub	r10,r9
800046e6:	fe 79 08 00 	mov	r9,-63488
800046ea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800046ee:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800046f0:	58 1a       	cp.w	r10,1
800046f2:	c0 a1       	brne	80004706 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800046f4:	49 09       	lddpc	r9,80004734 <INTC_register_interrupt+0x6c>
800046f6:	49 2a       	lddpc	r10,8000473c <INTC_register_interrupt+0x74>
800046f8:	12 1a       	sub	r10,r9
800046fa:	bf aa       	sbr	r10,0x1e
800046fc:	fe 79 08 00 	mov	r9,-63488
80004700:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004704:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004706:	58 2a       	cp.w	r10,2
80004708:	c0 a1       	brne	8000471c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000470a:	48 b9       	lddpc	r9,80004734 <INTC_register_interrupt+0x6c>
8000470c:	48 da       	lddpc	r10,80004740 <INTC_register_interrupt+0x78>
8000470e:	12 1a       	sub	r10,r9
80004710:	bf ba       	sbr	r10,0x1f
80004712:	fe 79 08 00 	mov	r9,-63488
80004716:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000471a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000471c:	48 69       	lddpc	r9,80004734 <INTC_register_interrupt+0x6c>
8000471e:	48 aa       	lddpc	r10,80004744 <INTC_register_interrupt+0x7c>
80004720:	12 1a       	sub	r10,r9
80004722:	ea 1a c0 00 	orh	r10,0xc000
80004726:	fe 79 08 00 	mov	r9,-63488
8000472a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000472e:	5e fc       	retal	r12
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	c3 60       	breq	8000479e <_get_interrupt_handler+0x2>
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	ba 00       	st.h	sp[0x0],r0
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	bb 04       	ld.d	r4,sp
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	bb 12       	ld.d	r2,--sp
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	bb 20       	st.d	sp++,r0
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	bb 2e       	st.d	sp++,lr

80004748 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004748:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000474a:	49 18       	lddpc	r8,8000478c <INTC_init_interrupts+0x44>
8000474c:	e3 b8 00 01 	mtsr	0x4,r8
80004750:	49 0e       	lddpc	lr,80004790 <INTC_init_interrupts+0x48>
80004752:	30 07       	mov	r7,0
80004754:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004756:	49 0c       	lddpc	r12,80004794 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004758:	49 05       	lddpc	r5,80004798 <INTC_init_interrupts+0x50>
8000475a:	10 15       	sub	r5,r8
8000475c:	fe 76 08 00 	mov	r6,-63488
80004760:	c1 08       	rjmp	80004780 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004762:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004764:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004766:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004768:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000476c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000476e:	10 3a       	cp.w	r10,r8
80004770:	fe 9b ff fc 	brhi	80004768 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004774:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004778:	2f f7       	sub	r7,-1
8000477a:	2f 8e       	sub	lr,-8
8000477c:	59 37       	cp.w	r7,19
8000477e:	c0 50       	breq	80004788 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004780:	7c 08       	ld.w	r8,lr[0x0]
80004782:	58 08       	cp.w	r8,0
80004784:	ce f1       	brne	80004762 <INTC_init_interrupts+0x1a>
80004786:	cf 7b       	rjmp	80004774 <INTC_init_interrupts+0x2c>
80004788:	d8 22       	popm	r4-r7,pc
8000478a:	00 00       	add	r0,r0
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	ba 00       	st.h	sp[0x0],r0
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	c3 60       	breq	800047fe <usart_set_async_baudrate+0x2a>
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	46 c4       	lddsp	r4,sp[0x1b0]
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	bb 04       	ld.d	r4,sp

8000479c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000479c:	fe 78 08 00 	mov	r8,-63488
800047a0:	e0 69 00 83 	mov	r9,131
800047a4:	f2 0c 01 0c 	sub	r12,r9,r12
800047a8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800047ac:	f2 ca ff c0 	sub	r10,r9,-64
800047b0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800047b4:	58 08       	cp.w	r8,0
800047b6:	c0 21       	brne	800047ba <_get_interrupt_handler+0x1e>
800047b8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800047ba:	f0 08 12 00 	clz	r8,r8
800047be:	48 5a       	lddpc	r10,800047d0 <_get_interrupt_handler+0x34>
800047c0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800047c4:	f0 08 11 1f 	rsub	r8,r8,31
800047c8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800047ca:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800047ce:	5e fc       	retal	r12
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	c3 60       	breq	8000483e <usart_write_char+0x10>

800047d4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800047d4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800047d6:	f6 08 15 04 	lsl	r8,r11,0x4
800047da:	14 38       	cp.w	r8,r10
800047dc:	f9 b8 08 10 	movls	r8,16
800047e0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800047e4:	f0 0b 02 4b 	mul	r11,r8,r11
800047e8:	f6 09 16 01 	lsr	r9,r11,0x1
800047ec:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800047f0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800047f4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800047f8:	f2 cb 00 01 	sub	r11,r9,1
800047fc:	e0 4b ff fe 	cp.w	r11,65534
80004800:	e0 88 00 03 	brls	80004806 <usart_set_async_baudrate+0x32>
80004804:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004806:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004808:	e8 6e 00 00 	mov	lr,524288
8000480c:	59 08       	cp.w	r8,16
8000480e:	fc 08 17 10 	movne	r8,lr
80004812:	f9 b8 00 00 	moveq	r8,0
80004816:	e4 1b ff f7 	andh	r11,0xfff7
8000481a:	e0 1b fe cf 	andl	r11,0xfecf
8000481e:	16 48       	or	r8,r11
80004820:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004822:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004826:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000482a:	99 89       	st.w	r12[0x20],r9
8000482c:	d8 0a       	popm	pc,r12=0

8000482e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000482e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004830:	e2 18 00 02 	andl	r8,0x2,COH
80004834:	c0 31       	brne	8000483a <usart_write_char+0xc>
80004836:	30 2c       	mov	r12,2
80004838:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000483a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000483e:	99 7b       	st.w	r12[0x1c],r11
80004840:	5e fd       	retal	0
80004842:	d7 03       	nop

80004844 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004844:	eb cd 40 e0 	pushm	r5-r7,lr
80004848:	18 96       	mov	r6,r12
8000484a:	16 95       	mov	r5,r11
8000484c:	e0 67 27 0f 	mov	r7,9999
80004850:	c0 68       	rjmp	8000485c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004852:	58 07       	cp.w	r7,0
80004854:	c0 31       	brne	8000485a <usart_putchar+0x16>
80004856:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000485a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000485c:	0a 9b       	mov	r11,r5
8000485e:	0c 9c       	mov	r12,r6
80004860:	f0 1f 00 03 	mcall	8000486c <usart_putchar+0x28>
80004864:	cf 71       	brne	80004852 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004866:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000486a:	00 00       	add	r0,r0
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	48 2e       	lddpc	lr,80004874 <usart_read_char+0x4>

80004870 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004870:	78 58       	ld.w	r8,r12[0x14]
80004872:	e2 18 00 e0 	andl	r8,0xe0,COH
80004876:	c0 30       	breq	8000487c <usart_read_char+0xc>
80004878:	30 4c       	mov	r12,4
8000487a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000487c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000487e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004882:	c0 31       	brne	80004888 <usart_read_char+0x18>
80004884:	30 3c       	mov	r12,3
80004886:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004888:	78 68       	ld.w	r8,r12[0x18]
8000488a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000488e:	97 08       	st.w	r11[0x0],r8
80004890:	5e fd       	retal	0
80004892:	d7 03       	nop

80004894 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004894:	eb cd 40 c0 	pushm	r6-r7,lr
80004898:	20 1d       	sub	sp,4
8000489a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
8000489c:	1a 97       	mov	r7,sp
8000489e:	1a 9b       	mov	r11,sp
800048a0:	0c 9c       	mov	r12,r6
800048a2:	f0 1f 00 07 	mcall	800048bc <usart_getchar+0x28>
800048a6:	58 3c       	cp.w	r12,3
800048a8:	cf b0       	breq	8000489e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800048aa:	58 4c       	cp.w	r12,4
800048ac:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800048b0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800048b4:	2f fd       	sub	sp,-4
800048b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ba:	00 00       	add	r0,r0
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	48 70       	lddpc	r0,800048d8 <usart_write_line+0x18>

800048c0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800048c0:	eb cd 40 c0 	pushm	r6-r7,lr
800048c4:	18 96       	mov	r6,r12
800048c6:	16 97       	mov	r7,r11
  while (*string != '\0')
800048c8:	17 8b       	ld.ub	r11,r11[0x0]
800048ca:	58 0b       	cp.w	r11,0
800048cc:	c0 80       	breq	800048dc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800048ce:	2f f7       	sub	r7,-1
800048d0:	0c 9c       	mov	r12,r6
800048d2:	f0 1f 00 04 	mcall	800048e0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800048d6:	0f 8b       	ld.ub	r11,r7[0x0]
800048d8:	58 0b       	cp.w	r11,0
800048da:	cf a1       	brne	800048ce <usart_write_line+0xe>
800048dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	48 44       	lddpc	r4,800048f0 <usart_reset+0xc>

800048e4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800048e4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800048e8:	e6 18 00 01 	andh	r8,0x1,COH
800048ec:	c0 71       	brne	800048fa <usart_reset+0x16>
800048ee:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800048f0:	3f f8       	mov	r8,-1
800048f2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800048f4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800048f6:	d5 03       	csrf	0x10
800048f8:	c0 48       	rjmp	80004900 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800048fa:	3f f8       	mov	r8,-1
800048fc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800048fe:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004900:	30 08       	mov	r8,0
80004902:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004904:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004906:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004908:	ea 68 61 0c 	mov	r8,680204
8000490c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000490e:	5e fc       	retal	r12

80004910 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004910:	eb cd 40 e0 	pushm	r5-r7,lr
80004914:	18 96       	mov	r6,r12
80004916:	16 97       	mov	r7,r11
80004918:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000491a:	f0 1f 00 2f 	mcall	800049d4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000491e:	58 07       	cp.w	r7,0
80004920:	c5 80       	breq	800049d0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004922:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004924:	30 49       	mov	r9,4
80004926:	f2 08 18 00 	cp.b	r8,r9
8000492a:	e0 88 00 53 	brls	800049d0 <usart_init_rs232+0xc0>
8000492e:	30 99       	mov	r9,9
80004930:	f2 08 18 00 	cp.b	r8,r9
80004934:	e0 8b 00 4e 	brhi	800049d0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004938:	0f d9       	ld.ub	r9,r7[0x5]
8000493a:	30 78       	mov	r8,7
8000493c:	f0 09 18 00 	cp.b	r9,r8
80004940:	e0 8b 00 48 	brhi	800049d0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004944:	8e 39       	ld.sh	r9,r7[0x6]
80004946:	e0 68 01 01 	mov	r8,257
8000494a:	f0 09 19 00 	cp.h	r9,r8
8000494e:	e0 8b 00 41 	brhi	800049d0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004952:	ef 39 00 08 	ld.ub	r9,r7[8]
80004956:	30 38       	mov	r8,3
80004958:	f0 09 18 00 	cp.b	r9,r8
8000495c:	e0 8b 00 3a 	brhi	800049d0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004960:	0a 9a       	mov	r10,r5
80004962:	6e 0b       	ld.w	r11,r7[0x0]
80004964:	0c 9c       	mov	r12,r6
80004966:	f0 1f 00 1d 	mcall	800049d8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000496a:	58 1c       	cp.w	r12,1
8000496c:	c3 20       	breq	800049d0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000496e:	0f c8       	ld.ub	r8,r7[0x4]
80004970:	30 99       	mov	r9,9
80004972:	f2 08 18 00 	cp.b	r8,r9
80004976:	c0 51       	brne	80004980 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004978:	6c 18       	ld.w	r8,r6[0x4]
8000497a:	b1 b8       	sbr	r8,0x11
8000497c:	8d 18       	st.w	r6[0x4],r8
8000497e:	c0 68       	rjmp	8000498a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004980:	6c 19       	ld.w	r9,r6[0x4]
80004982:	20 58       	sub	r8,5
80004984:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004988:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000498a:	6c 19       	ld.w	r9,r6[0x4]
8000498c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004990:	0f d8       	ld.ub	r8,r7[0x5]
80004992:	a9 78       	lsl	r8,0x9
80004994:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004998:	12 48       	or	r8,r9
8000499a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000499c:	8e 38       	ld.sh	r8,r7[0x6]
8000499e:	30 29       	mov	r9,2
800049a0:	f2 08 19 00 	cp.h	r8,r9
800049a4:	e0 88 00 09 	brls	800049b6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800049a8:	6c 18       	ld.w	r8,r6[0x4]
800049aa:	ad b8       	sbr	r8,0xd
800049ac:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800049ae:	8e b8       	ld.uh	r8,r7[0x6]
800049b0:	20 28       	sub	r8,2
800049b2:	8d a8       	st.w	r6[0x28],r8
800049b4:	c0 68       	rjmp	800049c0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800049b6:	6c 19       	ld.w	r9,r6[0x4]
800049b8:	5c 78       	castu.h	r8
800049ba:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800049be:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800049c0:	6c 18       	ld.w	r8,r6[0x4]
800049c2:	e0 18 ff f0 	andl	r8,0xfff0
800049c6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800049c8:	35 08       	mov	r8,80
800049ca:	8d 08       	st.w	r6[0x0],r8
800049cc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800049d0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 e4       	lddpc	r4,80004a0c <idata_load_loop_end+0xe>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	47 d4       	lddsp	r4,sp[0x1f4]

800049dc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800049dc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800049e0:	fe c0 8f e0 	sub	r0,pc,-28704

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800049e4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800049e8:	d5 53       	csrf	0x15
  cp      r0, r1
800049ea:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
800049ec:	e0 61 0a 30 	mov	r1,2608
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800049f0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800049f2:	c0 62       	brcc	800049fe <idata_load_loop_end>
  cp      r0, r1
800049f4:	48 92       	lddpc	r2,80004a18 <udata_clear_loop_end+0x4>

800049f6 <idata_load_loop>:
  brlo    idata_load_loop
800049f6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800049f8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
800049fa:	02 30       	cp.w	r0,r1
  cp      r0, r1
800049fc:	cf d3       	brcs	800049f6 <idata_load_loop>

800049fe <idata_load_loop_end>:
  brhs    udata_clear_loop_end
800049fe:	e0 60 0a 30 	mov	r0,2608
  mov     r2, 0
  mov     r3, 0
80004a02:	e0 61 40 e8 	mov	r1,16616
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004a06:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004a08:	c0 62       	brcc	80004a14 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004a0a:	30 02       	mov	r2,0
80004a0c:	30 03       	mov	r3,0

80004a0e <udata_clear_loop>:
80004a0e:	a1 22       	st.d	r0++,r2
80004a10:	02 30       	cp.w	r0,r1
80004a12:	cf e3       	brcs	80004a0e <udata_clear_loop>

80004a14 <udata_clear_loop_end>:
80004a14:	fe cf e9 c4 	sub	pc,pc,-5692
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	cc 90       	breq	800049ac <usart_init_rs232+0x9c>

80004a1c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004a1c:	f8 c8 ff f8 	sub	r8,r12,-8
80004a20:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004a22:	3f f9       	mov	r9,-1
80004a24:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004a26:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004a28:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004a2a:	30 08       	mov	r8,0
80004a2c:	99 08       	st.w	r12[0x0],r8
}
80004a2e:	5e fc       	retal	r12

80004a30 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004a30:	30 08       	mov	r8,0
80004a32:	99 48       	st.w	r12[0x10],r8
}
80004a34:	5e fc       	retal	r12

80004a36 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004a36:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004a38:	70 19       	ld.w	r9,r8[0x4]
80004a3a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004a3c:	78 19       	ld.w	r9,r12[0x4]
80004a3e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004a40:	70 19       	ld.w	r9,r8[0x4]
80004a42:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004a44:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004a46:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004a48:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004a4a:	78 08       	ld.w	r8,r12[0x0]
80004a4c:	2f f8       	sub	r8,-1
80004a4e:	99 08       	st.w	r12[0x0],r8
}
80004a50:	5e fc       	retal	r12

80004a52 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004a52:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004a54:	5b fa       	cp.w	r10,-1
80004a56:	c0 31       	brne	80004a5c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004a58:	78 48       	ld.w	r8,r12[0x10]
80004a5a:	c0 c8       	rjmp	80004a72 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004a5c:	f8 c8 ff f8 	sub	r8,r12,-8
80004a60:	70 19       	ld.w	r9,r8[0x4]
80004a62:	72 09       	ld.w	r9,r9[0x0]
80004a64:	12 3a       	cp.w	r10,r9
80004a66:	c0 63       	brcs	80004a72 <vListInsert+0x20>
80004a68:	70 18       	ld.w	r8,r8[0x4]
80004a6a:	70 19       	ld.w	r9,r8[0x4]
80004a6c:	72 09       	ld.w	r9,r9[0x0]
80004a6e:	12 3a       	cp.w	r10,r9
80004a70:	cf c2       	brcc	80004a68 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004a72:	70 19       	ld.w	r9,r8[0x4]
80004a74:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004a76:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004a78:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004a7a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004a7c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004a7e:	78 08       	ld.w	r8,r12[0x0]
80004a80:	2f f8       	sub	r8,-1
80004a82:	99 08       	st.w	r12[0x0],r8
}
80004a84:	5e fc       	retal	r12

80004a86 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004a86:	78 18       	ld.w	r8,r12[0x4]
80004a88:	78 29       	ld.w	r9,r12[0x8]
80004a8a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004a8c:	78 28       	ld.w	r8,r12[0x8]
80004a8e:	78 19       	ld.w	r9,r12[0x4]
80004a90:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004a92:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004a94:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004a96:	18 39       	cp.w	r9,r12
80004a98:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004a9c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004aa0:	30 09       	mov	r9,0
80004aa2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004aa4:	70 09       	ld.w	r9,r8[0x0]
80004aa6:	20 19       	sub	r9,1
80004aa8:	91 09       	st.w	r8[0x0],r9
}
80004aaa:	5e fc       	retal	r12

80004aac <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004aac:	e0 68 08 08 	mov	r8,2056
80004ab0:	ea 18 08 08 	orh	r8,0x808
80004ab4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004ab6:	e0 68 09 09 	mov	r8,2313
80004aba:	ea 18 09 09 	orh	r8,0x909
80004abe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004ac0:	e0 68 0a 0a 	mov	r8,2570
80004ac4:	ea 18 0a 0a 	orh	r8,0xa0a
80004ac8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004aca:	e0 68 0b 0b 	mov	r8,2827
80004ace:	ea 18 0b 0b 	orh	r8,0xb0b
80004ad2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004ad4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004ad6:	e0 68 be ef 	mov	r8,48879
80004ada:	ea 18 de ad 	orh	r8,0xdead
80004ade:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004ae0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004ae2:	fc 18 00 40 	movh	r8,0x40
80004ae6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004ae8:	e0 68 00 ff 	mov	r8,255
80004aec:	ea 18 ff 00 	orh	r8,0xff00
80004af0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004af2:	e0 68 01 01 	mov	r8,257
80004af6:	ea 18 01 01 	orh	r8,0x101
80004afa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004afc:	e0 68 02 02 	mov	r8,514
80004b00:	ea 18 02 02 	orh	r8,0x202
80004b04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004b06:	e0 68 03 03 	mov	r8,771
80004b0a:	ea 18 03 03 	orh	r8,0x303
80004b0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004b10:	e0 68 04 04 	mov	r8,1028
80004b14:	ea 18 04 04 	orh	r8,0x404
80004b18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004b1a:	e0 68 05 05 	mov	r8,1285
80004b1e:	ea 18 05 05 	orh	r8,0x505
80004b22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004b24:	e0 68 06 06 	mov	r8,1542
80004b28:	ea 18 06 06 	orh	r8,0x606
80004b2c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004b2e:	e0 68 07 07 	mov	r8,1799
80004b32:	ea 18 07 07 	orh	r8,0x707
80004b36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004b38:	30 08       	mov	r8,0
80004b3a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004b3c:	5e fc       	retal	r12
80004b3e:	d7 03       	nop

80004b40 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004b40:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004b42:	48 38       	lddpc	r8,80004b4c <vPortEnterCritical+0xc>
80004b44:	70 09       	ld.w	r9,r8[0x0]
80004b46:	2f f9       	sub	r9,-1
80004b48:	91 09       	st.w	r8[0x0],r9
}
80004b4a:	5e fc       	retal	r12
80004b4c:	00 00       	add	r0,r0
80004b4e:	05 24       	ld.uh	r4,r2++

80004b50 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004b50:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004b52:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004b54:	30 0a       	mov	r10,0
80004b56:	14 9b       	mov	r11,r10
80004b58:	49 2c       	lddpc	r12,80004ba0 <xPortStartScheduler+0x50>
80004b5a:	f0 1f 00 13 	mcall	80004ba4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004b5e:	e0 68 5d c0 	mov	r8,24000
80004b62:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004b66:	30 08       	mov	r8,0
80004b68:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004b6c:	e0 68 0c bc 	mov	r8,3260
80004b70:	ea 18 00 00 	orh	r8,0x0
80004b74:	70 00       	ld.w	r0,r8[0x0]
80004b76:	60 0d       	ld.w	sp,r0[0x0]
80004b78:	1b 00       	ld.w	r0,sp++
80004b7a:	e0 68 05 24 	mov	r8,1316
80004b7e:	ea 18 00 00 	orh	r8,0x0
80004b82:	91 00       	st.w	r8[0x0],r0
80004b84:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004b88:	2f ed       	sub	sp,-8
80004b8a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004b8e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004b92:	e3 b0 00 00 	mtsr	0x0,r0
80004b96:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004b9a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004b9e:	d8 0a       	popm	pc,r12=0
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	4c 6c       	lddpc	r12,80004cb8 <LABEL_INT_SKIP_SAVE_CONTEXT_237+0x24>
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	46 c8       	lddsp	r8,sp[0x1b0]

80004ba8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004ba8:	20 6d       	sub	sp,24
80004baa:	eb cd 00 ff 	pushm	r0-r7
80004bae:	fa c7 ff c0 	sub	r7,sp,-64
80004bb2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004bb6:	ef 40 ff e0 	st.w	r7[-32],r0
80004bba:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004bbe:	ef 40 ff e4 	st.w	r7[-28],r0
80004bc2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004bc6:	e0 68 05 24 	mov	r8,1316
80004bca:	ea 18 00 00 	orh	r8,0x0
80004bce:	70 00       	ld.w	r0,r8[0x0]
80004bd0:	1a d0       	st.w	--sp,r0
80004bd2:	f0 1f 00 1a 	mcall	80004c38 <LABEL_RET_SCALL_263+0x14>
80004bd6:	e0 68 0c bc 	mov	r8,3260
80004bda:	ea 18 00 00 	orh	r8,0x0
80004bde:	70 00       	ld.w	r0,r8[0x0]
80004be0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004be2:	f0 1f 00 17 	mcall	80004c3c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004be6:	e0 68 0c bc 	mov	r8,3260
80004bea:	ea 18 00 00 	orh	r8,0x0
80004bee:	70 00       	ld.w	r0,r8[0x0]
80004bf0:	60 0d       	ld.w	sp,r0[0x0]
80004bf2:	1b 00       	ld.w	r0,sp++
80004bf4:	e0 68 05 24 	mov	r8,1316
80004bf8:	ea 18 00 00 	orh	r8,0x0
80004bfc:	91 00       	st.w	r8[0x0],r0
80004bfe:	fa c7 ff d8 	sub	r7,sp,-40
80004c02:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004c06:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004c0a:	e0 61 05 24 	mov	r1,1316
80004c0e:	ea 11 00 00 	orh	r1,0x0
80004c12:	62 02       	ld.w	r2,r1[0x0]
80004c14:	58 02       	cp.w	r2,0
80004c16:	c0 70       	breq	80004c24 <LABEL_RET_SCALL_263>
80004c18:	e4 c2 00 01 	sub	r2,r2,1
80004c1c:	83 02       	st.w	r1[0x0],r2
80004c1e:	58 02       	cp.w	r2,0
80004c20:	c0 21       	brne	80004c24 <LABEL_RET_SCALL_263>
80004c22:	b1 c0       	cbr	r0,0x10

80004c24 <LABEL_RET_SCALL_263>:
80004c24:	ef 40 ff f8 	st.w	r7[-8],r0
80004c28:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004c2c:	ef 40 ff fc 	st.w	r7[-4],r0
80004c30:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004c34:	2f ad       	sub	sp,-24
80004c36:	d6 13       	rets
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	4b 40       	lddpc	r0,80004d08 <_read>
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	52 84       	stdsp	sp[0xa0],r4

80004c40 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004c40:	e1 b8 00 43 	mfsr	r8,0x10c
80004c44:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004c48:	5e fc       	retal	r12
80004c4a:	d7 03       	nop

80004c4c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004c4c:	48 78       	lddpc	r8,80004c68 <vPortExitCritical+0x1c>
80004c4e:	70 08       	ld.w	r8,r8[0x0]
80004c50:	58 08       	cp.w	r8,0
80004c52:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004c54:	48 58       	lddpc	r8,80004c68 <vPortExitCritical+0x1c>
80004c56:	70 09       	ld.w	r9,r8[0x0]
80004c58:	20 19       	sub	r9,1
80004c5a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004c5c:	70 08       	ld.w	r8,r8[0x0]
80004c5e:	58 08       	cp.w	r8,0
80004c60:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004c62:	d5 03       	csrf	0x10
80004c64:	5e fc       	retal	r12
80004c66:	00 00       	add	r0,r0
80004c68:	00 00       	add	r0,r0
80004c6a:	05 24       	ld.uh	r4,r2++

80004c6c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004c6c:	eb cd 00 ff 	pushm	r0-r7
80004c70:	e0 68 05 24 	mov	r8,1316
80004c74:	ea 18 00 00 	orh	r8,0x0
80004c78:	70 00       	ld.w	r0,r8[0x0]
80004c7a:	1a d0       	st.w	--sp,r0
80004c7c:	7a 90       	ld.w	r0,sp[0x24]
80004c7e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004c82:	58 10       	cp.w	r0,1
80004c84:	e0 8b 00 08 	brhi	80004c94 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004c88:	e0 68 0c bc 	mov	r8,3260
80004c8c:	ea 18 00 00 	orh	r8,0x0
80004c90:	70 00       	ld.w	r0,r8[0x0]
80004c92:	81 0d       	st.w	r0[0x0],sp

80004c94 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004c94:	f0 1f 00 12 	mcall	80004cdc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004c98:	f0 1f 00 12 	mcall	80004ce0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004c9c:	f0 1f 00 12 	mcall	80004ce4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004ca0:	f0 1f 00 12 	mcall	80004ce8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004ca4:	7a 90       	ld.w	r0,sp[0x24]
80004ca6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004caa:	58 10       	cp.w	r0,1
80004cac:	e0 8b 00 0e 	brhi	80004cc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004cb0:	f0 1f 00 0c 	mcall	80004ce0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004cb4:	f0 1f 00 0e 	mcall	80004cec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004cb8:	f0 1f 00 0c 	mcall	80004ce8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004cbc:	e0 68 0c bc 	mov	r8,3260
80004cc0:	ea 18 00 00 	orh	r8,0x0
80004cc4:	70 00       	ld.w	r0,r8[0x0]
80004cc6:	60 0d       	ld.w	sp,r0[0x0]

80004cc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004cc8:	1b 00       	ld.w	r0,sp++
80004cca:	e0 68 05 24 	mov	r8,1316
80004cce:	ea 18 00 00 	orh	r8,0x0
80004cd2:	91 00       	st.w	r8[0x0],r0
80004cd4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004cd8:	d6 03       	rete
80004cda:	00 00       	add	r0,r0
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	4c 40       	lddpc	r0,80004dec <prvCopyDataFromQueue+0x18>
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	4b 40       	lddpc	r0,80004db0 <pvPortMalloc+0x4>
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	54 88       	stdsp	sp[0x120],r8
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	4c 4c       	lddpc	r12,80004df8 <prvCopyDataFromQueue+0x24>
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	52 84       	stdsp	sp[0xa0],r4

80004cf0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004cf0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004cf2:	f0 1f 00 02 	mcall	80004cf8 <__malloc_lock+0x8>
}
80004cf6:	d8 02       	popm	pc
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	52 74       	stdsp	sp[0x9c],r4

80004cfc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004cfc:	d4 01       	pushm	lr
	xTaskResumeAll();
80004cfe:	f0 1f 00 02 	mcall	80004d04 <__malloc_unlock+0x8>
}
80004d02:	d8 02       	popm	pc
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	56 30       	stdsp	sp[0x18c],r0

80004d08 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004d08:	d4 21       	pushm	r4-r7,lr
80004d0a:	16 95       	mov	r5,r11
80004d0c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004d0e:	58 0c       	cp.w	r12,0
80004d10:	c0 30       	breq	80004d16 <_read+0xe>
80004d12:	3f f7       	mov	r7,-1
80004d14:	c1 48       	rjmp	80004d3c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004d16:	58 0a       	cp.w	r10,0
80004d18:	e0 89 00 04 	brgt	80004d20 <_read+0x18>
80004d1c:	30 07       	mov	r7,0
80004d1e:	c0 f8       	rjmp	80004d3c <_read+0x34>
80004d20:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004d22:	48 84       	lddpc	r4,80004d40 <_read+0x38>
80004d24:	68 0c       	ld.w	r12,r4[0x0]
80004d26:	f0 1f 00 08 	mcall	80004d44 <_read+0x3c>
    if (c < 0)
80004d2a:	c0 95       	brlt	80004d3c <_read+0x34>
      break;

    *ptr++ = c;
80004d2c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004d30:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004d32:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004d36:	58 08       	cp.w	r8,0
80004d38:	fe 99 ff f6 	brgt	80004d24 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004d3c:	0e 9c       	mov	r12,r7
80004d3e:	d8 22       	popm	r4-r7,pc
80004d40:	00 00       	add	r0,r0
80004d42:	40 dc       	lddsp	r12,sp[0x34]
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	48 94       	lddpc	r4,80004d68 <_write+0x20>

80004d48 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004d48:	d4 21       	pushm	r4-r7,lr
80004d4a:	16 95       	mov	r5,r11
80004d4c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004d4e:	20 1c       	sub	r12,1
80004d50:	58 2c       	cp.w	r12,2
80004d52:	e0 8b 00 12 	brhi	80004d76 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004d56:	58 0a       	cp.w	r10,0
80004d58:	c0 31       	brne	80004d5e <_write+0x16>
80004d5a:	30 07       	mov	r7,0
80004d5c:	c0 e8       	rjmp	80004d78 <_write+0x30>
80004d5e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004d60:	48 74       	lddpc	r4,80004d7c <_write+0x34>
80004d62:	68 0c       	ld.w	r12,r4[0x0]
80004d64:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004d68:	f0 1f 00 06 	mcall	80004d80 <_write+0x38>
80004d6c:	c0 55       	brlt	80004d76 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004d6e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004d70:	0e 36       	cp.w	r6,r7
80004d72:	cf 81       	brne	80004d62 <_write+0x1a>
80004d74:	c0 28       	rjmp	80004d78 <_write+0x30>
80004d76:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004d78:	0e 9c       	mov	r12,r7
80004d7a:	d8 22       	popm	r4-r7,pc
80004d7c:	00 00       	add	r0,r0
80004d7e:	40 dc       	lddsp	r12,sp[0x34]
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	48 44       	lddpc	r4,80004d90 <vPortFree+0xc>

80004d84 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004d84:	eb cd 40 80 	pushm	r7,lr
80004d88:	18 97       	mov	r7,r12
	if( pv )
80004d8a:	58 0c       	cp.w	r12,0
80004d8c:	c0 80       	breq	80004d9c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004d8e:	f0 1f 00 05 	mcall	80004da0 <vPortFree+0x1c>
		{
			free( pv );
80004d92:	0e 9c       	mov	r12,r7
80004d94:	f0 1f 00 04 	mcall	80004da4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004d98:	f0 1f 00 04 	mcall	80004da8 <vPortFree+0x24>
80004d9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	52 74       	stdsp	sp[0x9c],r4
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	60 b0       	ld.w	r0,r0[0x2c]
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	56 30       	stdsp	sp[0x18c],r0

80004dac <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004dac:	eb cd 40 80 	pushm	r7,lr
80004db0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004db2:	f0 1f 00 06 	mcall	80004dc8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004db6:	0e 9c       	mov	r12,r7
80004db8:	f0 1f 00 05 	mcall	80004dcc <pvPortMalloc+0x20>
80004dbc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004dbe:	f0 1f 00 05 	mcall	80004dd0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004dc2:	0e 9c       	mov	r12,r7
80004dc4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	52 74       	stdsp	sp[0x9c],r4
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	60 c0       	ld.w	r0,r0[0x30]
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	56 30       	stdsp	sp[0x18c],r0

80004dd4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004dd4:	d4 01       	pushm	lr
80004dd6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004dd8:	78 09       	ld.w	r9,r12[0x0]
80004dda:	58 09       	cp.w	r9,0
80004ddc:	c1 10       	breq	80004dfe <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004dde:	78 3a       	ld.w	r10,r12[0xc]
80004de0:	79 09       	ld.w	r9,r12[0x40]
80004de2:	f4 09 00 09 	add	r9,r10,r9
80004de6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004de8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004dea:	14 39       	cp.w	r9,r10
80004dec:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004df0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004df4:	79 0a       	ld.w	r10,r12[0x40]
80004df6:	78 3b       	ld.w	r11,r12[0xc]
80004df8:	10 9c       	mov	r12,r8
80004dfa:	f0 1f 00 02 	mcall	80004e00 <prvCopyDataFromQueue+0x2c>
80004dfe:	d8 02       	popm	pc
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	65 08       	ld.w	r8,r2[0x40]

80004e04 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004e04:	eb cd 40 c0 	pushm	r6-r7,lr
80004e08:	18 97       	mov	r7,r12
80004e0a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004e0c:	78 e8       	ld.w	r8,r12[0x38]
80004e0e:	58 08       	cp.w	r8,0
80004e10:	c0 31       	brne	80004e16 <xQueueReceiveFromISR+0x12>
80004e12:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80004e16:	f0 1f 00 0e 	mcall	80004e4c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004e1a:	6e e8       	ld.w	r8,r7[0x38]
80004e1c:	20 18       	sub	r8,1
80004e1e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004e20:	6f 18       	ld.w	r8,r7[0x44]
80004e22:	5b f8       	cp.w	r8,-1
80004e24:	c0 d1       	brne	80004e3e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004e26:	6e 48       	ld.w	r8,r7[0x10]
80004e28:	58 08       	cp.w	r8,0
80004e2a:	c0 f0       	breq	80004e48 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004e2c:	ee cc ff f0 	sub	r12,r7,-16
80004e30:	f0 1f 00 08 	mcall	80004e50 <xQueueReceiveFromISR+0x4c>
80004e34:	c0 a0       	breq	80004e48 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80004e36:	30 1c       	mov	r12,1
80004e38:	8d 0c       	st.w	r6[0x0],r12
80004e3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004e3e:	2f f8       	sub	r8,-1
80004e40:	ef 48 00 44 	st.w	r7[68],r8
80004e44:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004e48:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4d d4       	lddpc	r4,80004fc0 <xQueueGenericReceive+0xcc>
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	54 0c       	stdsp	sp[0x100],r12

80004e54 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004e54:	eb cd 40 c0 	pushm	r6-r7,lr
80004e58:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004e5a:	f0 1f 00 23 	mcall	80004ee4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004e5e:	6f 28       	ld.w	r8,r7[0x48]
80004e60:	58 08       	cp.w	r8,0
80004e62:	e0 8a 00 18 	brle	80004e92 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004e66:	6e 98       	ld.w	r8,r7[0x24]
80004e68:	58 08       	cp.w	r8,0
80004e6a:	c1 40       	breq	80004e92 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004e6c:	ee c6 ff dc 	sub	r6,r7,-36
80004e70:	c0 48       	rjmp	80004e78 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004e72:	6e 98       	ld.w	r8,r7[0x24]
80004e74:	58 08       	cp.w	r8,0
80004e76:	c0 e0       	breq	80004e92 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004e78:	0c 9c       	mov	r12,r6
80004e7a:	f0 1f 00 1c 	mcall	80004ee8 <prvUnlockQueue+0x94>
80004e7e:	c0 30       	breq	80004e84 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004e80:	f0 1f 00 1b 	mcall	80004eec <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004e84:	6f 28       	ld.w	r8,r7[0x48]
80004e86:	20 18       	sub	r8,1
80004e88:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004e8c:	58 08       	cp.w	r8,0
80004e8e:	fe 99 ff f2 	brgt	80004e72 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004e92:	3f f8       	mov	r8,-1
80004e94:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004e98:	f0 1f 00 16 	mcall	80004ef0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004e9c:	f0 1f 00 12 	mcall	80004ee4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004ea0:	6f 18       	ld.w	r8,r7[0x44]
80004ea2:	58 08       	cp.w	r8,0
80004ea4:	e0 8a 00 18 	brle	80004ed4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004ea8:	6e 48       	ld.w	r8,r7[0x10]
80004eaa:	58 08       	cp.w	r8,0
80004eac:	c1 40       	breq	80004ed4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004eae:	ee c6 ff f0 	sub	r6,r7,-16
80004eb2:	c0 48       	rjmp	80004eba <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004eb4:	6e 48       	ld.w	r8,r7[0x10]
80004eb6:	58 08       	cp.w	r8,0
80004eb8:	c0 e0       	breq	80004ed4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004eba:	0c 9c       	mov	r12,r6
80004ebc:	f0 1f 00 0b 	mcall	80004ee8 <prvUnlockQueue+0x94>
80004ec0:	c0 30       	breq	80004ec6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004ec2:	f0 1f 00 0b 	mcall	80004eec <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004ec6:	6f 18       	ld.w	r8,r7[0x44]
80004ec8:	20 18       	sub	r8,1
80004eca:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004ece:	58 08       	cp.w	r8,0
80004ed0:	fe 99 ff f2 	brgt	80004eb4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004ed4:	3f f8       	mov	r8,-1
80004ed6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004eda:	f0 1f 00 06 	mcall	80004ef0 <prvUnlockQueue+0x9c>
}
80004ede:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ee2:	00 00       	add	r0,r0
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	4b 40       	lddpc	r0,80004fb4 <xQueueGenericReceive+0xc0>
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	54 0c       	stdsp	sp[0x100],r12
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	53 18       	stdsp	sp[0xc4],r8
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	4c 4c       	lddpc	r12,80005000 <xQueueGenericReceive+0x10c>

80004ef4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004ef4:	d4 31       	pushm	r0-r7,lr
80004ef6:	20 5d       	sub	sp,20
80004ef8:	18 97       	mov	r7,r12
80004efa:	50 0b       	stdsp	sp[0x0],r11
80004efc:	50 2a       	stdsp	sp[0x8],r10
80004efe:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004f00:	f8 c2 ff dc 	sub	r2,r12,-36
80004f04:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f06:	fa c4 ff f4 	sub	r4,sp,-12
80004f0a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004f0c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004f0e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004f12:	f0 1f 00 3e 	mcall	80005008 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004f16:	6e e8       	ld.w	r8,r7[0x38]
80004f18:	58 08       	cp.w	r8,0
80004f1a:	c2 a0       	breq	80004f6e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004f1c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004f1e:	40 0b       	lddsp	r11,sp[0x0]
80004f20:	0e 9c       	mov	r12,r7
80004f22:	f0 1f 00 3b 	mcall	8000500c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004f26:	40 18       	lddsp	r8,sp[0x4]
80004f28:	58 08       	cp.w	r8,0
80004f2a:	c1 51       	brne	80004f54 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004f2c:	6e e8       	ld.w	r8,r7[0x38]
80004f2e:	20 18       	sub	r8,1
80004f30:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004f32:	6e 08       	ld.w	r8,r7[0x0]
80004f34:	58 08       	cp.w	r8,0
80004f36:	c0 41       	brne	80004f3e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004f38:	f0 1f 00 36 	mcall	80005010 <xQueueGenericReceive+0x11c>
80004f3c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004f3e:	6e 48       	ld.w	r8,r7[0x10]
80004f40:	58 08       	cp.w	r8,0
80004f42:	c1 20       	breq	80004f66 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004f44:	ee cc ff f0 	sub	r12,r7,-16
80004f48:	f0 1f 00 33 	mcall	80005014 <xQueueGenericReceive+0x120>
80004f4c:	58 1c       	cp.w	r12,1
80004f4e:	c0 c1       	brne	80004f66 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004f50:	d7 33       	scall
80004f52:	c0 a8       	rjmp	80004f66 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004f54:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f56:	6e 98       	ld.w	r8,r7[0x24]
80004f58:	58 08       	cp.w	r8,0
80004f5a:	c0 60       	breq	80004f66 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004f5c:	04 9c       	mov	r12,r2
80004f5e:	f0 1f 00 2e 	mcall	80005014 <xQueueGenericReceive+0x120>
80004f62:	c0 20       	breq	80004f66 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004f64:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004f66:	f0 1f 00 2d 	mcall	80005018 <xQueueGenericReceive+0x124>
80004f6a:	30 1c       	mov	r12,1
				return pdPASS;
80004f6c:	c4 c8       	rjmp	80005004 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004f6e:	40 28       	lddsp	r8,sp[0x8]
80004f70:	58 08       	cp.w	r8,0
80004f72:	c0 51       	brne	80004f7c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004f74:	f0 1f 00 29 	mcall	80005018 <xQueueGenericReceive+0x124>
80004f78:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004f7a:	c4 58       	rjmp	80005004 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004f7c:	58 05       	cp.w	r5,0
80004f7e:	c0 51       	brne	80004f88 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f80:	08 9c       	mov	r12,r4
80004f82:	f0 1f 00 27 	mcall	8000501c <xQueueGenericReceive+0x128>
80004f86:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004f88:	f0 1f 00 24 	mcall	80005018 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004f8c:	f0 1f 00 25 	mcall	80005020 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80004f90:	f0 1f 00 1e 	mcall	80005008 <xQueueGenericReceive+0x114>
80004f94:	6f 18       	ld.w	r8,r7[0x44]
80004f96:	5b f8       	cp.w	r8,-1
80004f98:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004f9c:	6f 28       	ld.w	r8,r7[0x48]
80004f9e:	5b f8       	cp.w	r8,-1
80004fa0:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004fa4:	f0 1f 00 1d 	mcall	80005018 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004fa8:	06 9b       	mov	r11,r3
80004faa:	08 9c       	mov	r12,r4
80004fac:	f0 1f 00 1e 	mcall	80005024 <xQueueGenericReceive+0x130>
80004fb0:	c2 41       	brne	80004ff8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004fb2:	f0 1f 00 16 	mcall	80005008 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004fb6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004fb8:	f0 1f 00 18 	mcall	80005018 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004fbc:	58 06       	cp.w	r6,0
80004fbe:	c1 71       	brne	80004fec <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004fc0:	6e 08       	ld.w	r8,r7[0x0]
80004fc2:	58 08       	cp.w	r8,0
80004fc4:	c0 81       	brne	80004fd4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80004fc6:	f0 1f 00 11 	mcall	80005008 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80004fca:	6e 1c       	ld.w	r12,r7[0x4]
80004fcc:	f0 1f 00 17 	mcall	80005028 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80004fd0:	f0 1f 00 12 	mcall	80005018 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004fd4:	40 2b       	lddsp	r11,sp[0x8]
80004fd6:	04 9c       	mov	r12,r2
80004fd8:	f0 1f 00 15 	mcall	8000502c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004fdc:	0e 9c       	mov	r12,r7
80004fde:	f0 1f 00 15 	mcall	80005030 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80004fe2:	f0 1f 00 15 	mcall	80005034 <xQueueGenericReceive+0x140>
80004fe6:	c9 61       	brne	80004f12 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004fe8:	d7 33       	scall
80004fea:	c9 4b       	rjmp	80004f12 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004fec:	0e 9c       	mov	r12,r7
80004fee:	f0 1f 00 11 	mcall	80005030 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80004ff2:	f0 1f 00 11 	mcall	80005034 <xQueueGenericReceive+0x140>
80004ff6:	c8 eb       	rjmp	80004f12 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004ff8:	0e 9c       	mov	r12,r7
80004ffa:	f0 1f 00 0e 	mcall	80005030 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004ffe:	f0 1f 00 0e 	mcall	80005034 <xQueueGenericReceive+0x140>
80005002:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005004:	2f bd       	sub	sp,-20
80005006:	d8 32       	popm	r0-r7,pc
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	4b 40       	lddpc	r0,800050d8 <xQueueGenericSendFromISR+0x28>
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	4d d4       	lddpc	r4,80005180 <xQueueGenericSend+0x80>
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	53 24       	stdsp	sp[0xc8],r4
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	54 0c       	stdsp	sp[0x100],r12
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	4c 4c       	lddpc	r12,80005128 <xQueueGenericSend+0x28>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	53 00       	stdsp	sp[0xc0],r0
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	52 74       	stdsp	sp[0x9c],r4
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	55 9c       	stdsp	sp[0x164],r12
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	53 88       	stdsp	sp[0xe0],r8
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	57 f4       	stdsp	sp[0x1fc],r4
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	4e 54       	lddpc	r4,800051c4 <xQueueGenericSend+0xc4>
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	56 30       	stdsp	sp[0x18c],r0

80005038 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005038:	eb cd 40 80 	pushm	r7,lr
8000503c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000503e:	79 08       	ld.w	r8,r12[0x40]
80005040:	58 08       	cp.w	r8,0
80005042:	c0 a1       	brne	80005056 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005044:	78 08       	ld.w	r8,r12[0x0]
80005046:	58 08       	cp.w	r8,0
80005048:	c2 b1       	brne	8000509e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000504a:	78 1c       	ld.w	r12,r12[0x4]
8000504c:	f0 1f 00 17 	mcall	800050a8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005050:	30 08       	mov	r8,0
80005052:	8f 18       	st.w	r7[0x4],r8
80005054:	c2 58       	rjmp	8000509e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005056:	58 0a       	cp.w	r10,0
80005058:	c1 01       	brne	80005078 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000505a:	10 9a       	mov	r10,r8
8000505c:	78 2c       	ld.w	r12,r12[0x8]
8000505e:	f0 1f 00 14 	mcall	800050ac <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005062:	6e 29       	ld.w	r9,r7[0x8]
80005064:	6f 08       	ld.w	r8,r7[0x40]
80005066:	f2 08 00 08 	add	r8,r9,r8
8000506a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000506c:	6e 19       	ld.w	r9,r7[0x4]
8000506e:	12 38       	cp.w	r8,r9
80005070:	c1 73       	brcs	8000509e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005072:	6e 08       	ld.w	r8,r7[0x0]
80005074:	8f 28       	st.w	r7[0x8],r8
80005076:	c1 48       	rjmp	8000509e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005078:	10 9a       	mov	r10,r8
8000507a:	78 3c       	ld.w	r12,r12[0xc]
8000507c:	f0 1f 00 0c 	mcall	800050ac <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005080:	6f 08       	ld.w	r8,r7[0x40]
80005082:	6e 39       	ld.w	r9,r7[0xc]
80005084:	f2 08 01 08 	sub	r8,r9,r8
80005088:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000508a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000508c:	12 38       	cp.w	r8,r9
8000508e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005092:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005096:	f3 d8 e3 19 	subcs	r9,r9,r8
8000509a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000509e:	6e e8       	ld.w	r8,r7[0x38]
800050a0:	2f f8       	sub	r8,-1
800050a2:	8f e8       	st.w	r7[0x38],r8
}
800050a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	53 30       	stdsp	sp[0xcc],r0
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	65 08       	ld.w	r8,r2[0x40]

800050b0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800050b0:	eb cd 40 c0 	pushm	r6-r7,lr
800050b4:	18 97       	mov	r7,r12
800050b6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800050b8:	78 ec       	ld.w	r12,r12[0x38]
800050ba:	6e f8       	ld.w	r8,r7[0x3c]
800050bc:	10 3c       	cp.w	r12,r8
800050be:	c0 33       	brcs	800050c4 <xQueueGenericSendFromISR+0x14>
800050c0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800050c4:	12 9a       	mov	r10,r9
800050c6:	0e 9c       	mov	r12,r7
800050c8:	f0 1f 00 0c 	mcall	800050f8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800050cc:	6f 28       	ld.w	r8,r7[0x48]
800050ce:	5b f8       	cp.w	r8,-1
800050d0:	c0 d1       	brne	800050ea <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800050d2:	6e 98       	ld.w	r8,r7[0x24]
800050d4:	58 08       	cp.w	r8,0
800050d6:	c0 f0       	breq	800050f4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800050d8:	ee cc ff dc 	sub	r12,r7,-36
800050dc:	f0 1f 00 08 	mcall	800050fc <xQueueGenericSendFromISR+0x4c>
800050e0:	c0 a0       	breq	800050f4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800050e2:	30 1c       	mov	r12,1
800050e4:	8d 0c       	st.w	r6[0x0],r12
800050e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800050ea:	2f f8       	sub	r8,-1
800050ec:	ef 48 00 48 	st.w	r7[72],r8
800050f0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800050f4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	50 38       	stdsp	sp[0xc],r8
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	54 0c       	stdsp	sp[0x100],r12

80005100 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005100:	d4 31       	pushm	r0-r7,lr
80005102:	20 5d       	sub	sp,20
80005104:	18 97       	mov	r7,r12
80005106:	50 0b       	stdsp	sp[0x0],r11
80005108:	50 2a       	stdsp	sp[0x8],r10
8000510a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000510c:	f8 c0 ff f0 	sub	r0,r12,-16
80005110:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005112:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005116:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005118:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000511c:	f0 1f 00 2f 	mcall	800051d8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005120:	6e e9       	ld.w	r9,r7[0x38]
80005122:	6e f8       	ld.w	r8,r7[0x3c]
80005124:	10 39       	cp.w	r9,r8
80005126:	c1 42       	brcc	8000514e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005128:	40 1a       	lddsp	r10,sp[0x4]
8000512a:	40 0b       	lddsp	r11,sp[0x0]
8000512c:	0e 9c       	mov	r12,r7
8000512e:	f0 1f 00 2c 	mcall	800051dc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005132:	6e 98       	ld.w	r8,r7[0x24]
80005134:	58 08       	cp.w	r8,0
80005136:	c0 80       	breq	80005146 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005138:	ee cc ff dc 	sub	r12,r7,-36
8000513c:	f0 1f 00 29 	mcall	800051e0 <xQueueGenericSend+0xe0>
80005140:	58 1c       	cp.w	r12,1
80005142:	c0 21       	brne	80005146 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005144:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005146:	f0 1f 00 28 	mcall	800051e4 <xQueueGenericSend+0xe4>
8000514a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000514c:	c4 38       	rjmp	800051d2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000514e:	40 28       	lddsp	r8,sp[0x8]
80005150:	58 08       	cp.w	r8,0
80005152:	c0 51       	brne	8000515c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005154:	f0 1f 00 24 	mcall	800051e4 <xQueueGenericSend+0xe4>
80005158:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000515a:	c3 c8       	rjmp	800051d2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000515c:	58 04       	cp.w	r4,0
8000515e:	c0 51       	brne	80005168 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005160:	06 9c       	mov	r12,r3
80005162:	f0 1f 00 22 	mcall	800051e8 <xQueueGenericSend+0xe8>
80005166:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005168:	f0 1f 00 1f 	mcall	800051e4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000516c:	f0 1f 00 20 	mcall	800051ec <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005170:	f0 1f 00 1a 	mcall	800051d8 <xQueueGenericSend+0xd8>
80005174:	6f 18       	ld.w	r8,r7[0x44]
80005176:	5b f8       	cp.w	r8,-1
80005178:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000517c:	6f 28       	ld.w	r8,r7[0x48]
8000517e:	5b f8       	cp.w	r8,-1
80005180:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005184:	f0 1f 00 18 	mcall	800051e4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005188:	04 9b       	mov	r11,r2
8000518a:	06 9c       	mov	r12,r3
8000518c:	f0 1f 00 19 	mcall	800051f0 <xQueueGenericSend+0xf0>
80005190:	c1 b1       	brne	800051c6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005192:	f0 1f 00 12 	mcall	800051d8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005196:	6e e5       	ld.w	r5,r7[0x38]
80005198:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000519a:	f0 1f 00 13 	mcall	800051e4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000519e:	0c 35       	cp.w	r5,r6
800051a0:	c0 d1       	brne	800051ba <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800051a2:	40 2b       	lddsp	r11,sp[0x8]
800051a4:	00 9c       	mov	r12,r0
800051a6:	f0 1f 00 14 	mcall	800051f4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800051aa:	0e 9c       	mov	r12,r7
800051ac:	f0 1f 00 13 	mcall	800051f8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800051b0:	f0 1f 00 13 	mcall	800051fc <xQueueGenericSend+0xfc>
800051b4:	cb 41       	brne	8000511c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800051b6:	d7 33       	scall
800051b8:	cb 2b       	rjmp	8000511c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800051ba:	0e 9c       	mov	r12,r7
800051bc:	f0 1f 00 0f 	mcall	800051f8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800051c0:	f0 1f 00 0f 	mcall	800051fc <xQueueGenericSend+0xfc>
800051c4:	ca cb       	rjmp	8000511c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800051c6:	0e 9c       	mov	r12,r7
800051c8:	f0 1f 00 0c 	mcall	800051f8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800051cc:	f0 1f 00 0c 	mcall	800051fc <xQueueGenericSend+0xfc>
800051d0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800051d2:	2f bd       	sub	sp,-20
800051d4:	d8 32       	popm	r0-r7,pc
800051d6:	00 00       	add	r0,r0
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	4b 40       	lddpc	r0,800052a8 <vTaskSwitchContext+0x24>
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	50 38       	stdsp	sp[0xc],r8
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	54 0c       	stdsp	sp[0x100],r12
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	4c 4c       	lddpc	r12,800052f4 <vTaskSwitchContext+0x70>
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	53 00       	stdsp	sp[0xc0],r0
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	52 74       	stdsp	sp[0x9c],r4
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	55 9c       	stdsp	sp[0x164],r12
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	57 f4       	stdsp	sp[0x1fc],r4
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	4e 54       	lddpc	r4,8000538c <vTaskPriorityInherit+0x4>
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	56 30       	stdsp	sp[0x18c],r0

80005200 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005200:	d4 21       	pushm	r4-r7,lr
80005202:	18 97       	mov	r7,r12
80005204:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005206:	58 0c       	cp.w	r12,0
80005208:	c2 f0       	breq	80005266 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000520a:	34 cc       	mov	r12,76
8000520c:	f0 1f 00 17 	mcall	80005268 <xQueueCreate+0x68>
80005210:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005212:	c2 a0       	breq	80005266 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005214:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005218:	e8 cc ff ff 	sub	r12,r4,-1
8000521c:	f0 1f 00 13 	mcall	80005268 <xQueueCreate+0x68>
80005220:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005222:	c1 e0       	breq	8000525e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005224:	f8 04 00 04 	add	r4,r12,r4
80005228:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000522a:	30 08       	mov	r8,0
8000522c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000522e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005230:	ee c8 00 01 	sub	r8,r7,1
80005234:	ad 38       	mul	r8,r6
80005236:	10 0c       	add	r12,r8
80005238:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000523a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000523c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005240:	3f f8       	mov	r8,-1
80005242:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005246:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000524a:	ea cc ff f0 	sub	r12,r5,-16
8000524e:	f0 1f 00 08 	mcall	8000526c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005252:	ea cc ff dc 	sub	r12,r5,-36
80005256:	f0 1f 00 06 	mcall	8000526c <xQueueCreate+0x6c>
8000525a:	0a 9c       	mov	r12,r5
8000525c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000525e:	0a 9c       	mov	r12,r5
80005260:	f0 1f 00 04 	mcall	80005270 <xQueueCreate+0x70>
80005264:	d8 2a       	popm	r4-r7,pc,r12=0
80005266:	d8 2a       	popm	r4-r7,pc,r12=0
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	4d ac       	lddpc	r12,800053d0 <vTaskPriorityInherit+0x48>
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	4a 1c       	lddpc	r12,800052f0 <vTaskSwitchContext+0x6c>
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	4d 84       	lddpc	r4,800053d0 <vTaskPriorityInherit+0x48>

80005274 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005274:	48 38       	lddpc	r8,80005280 <vTaskSuspendAll+0xc>
80005276:	70 09       	ld.w	r9,r8[0x0]
80005278:	2f f9       	sub	r9,-1
8000527a:	91 09       	st.w	r8[0x0],r9
}
8000527c:	5e fc       	retal	r12
8000527e:	00 00       	add	r0,r0
80005280:	00 00       	add	r0,r0
80005282:	0c ec       	st.h	--r6,r12

80005284 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005284:	49 a8       	lddpc	r8,800052ec <vTaskSwitchContext+0x68>
80005286:	70 08       	ld.w	r8,r8[0x0]
80005288:	58 08       	cp.w	r8,0
8000528a:	c0 b1       	brne	800052a0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000528c:	49 98       	lddpc	r8,800052f0 <vTaskSwitchContext+0x6c>
8000528e:	70 08       	ld.w	r8,r8[0x0]
80005290:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005294:	49 89       	lddpc	r9,800052f4 <vTaskSwitchContext+0x70>
80005296:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000529a:	58 08       	cp.w	r8,0
8000529c:	c0 60       	breq	800052a8 <vTaskSwitchContext+0x24>
8000529e:	c1 18       	rjmp	800052c0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800052a0:	30 19       	mov	r9,1
800052a2:	49 68       	lddpc	r8,800052f8 <vTaskSwitchContext+0x74>
800052a4:	91 09       	st.w	r8[0x0],r9
800052a6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800052a8:	49 28       	lddpc	r8,800052f0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800052aa:	49 3a       	lddpc	r10,800052f4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800052ac:	70 09       	ld.w	r9,r8[0x0]
800052ae:	20 19       	sub	r9,1
800052b0:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800052b2:	70 09       	ld.w	r9,r8[0x0]
800052b4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800052b8:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800052bc:	58 09       	cp.w	r9,0
800052be:	cf 70       	breq	800052ac <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800052c0:	48 c8       	lddpc	r8,800052f0 <vTaskSwitchContext+0x6c>
800052c2:	70 08       	ld.w	r8,r8[0x0]
800052c4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800052c8:	48 b9       	lddpc	r9,800052f4 <vTaskSwitchContext+0x70>
800052ca:	f2 08 00 28 	add	r8,r9,r8<<0x2
800052ce:	70 19       	ld.w	r9,r8[0x4]
800052d0:	72 19       	ld.w	r9,r9[0x4]
800052d2:	91 19       	st.w	r8[0x4],r9
800052d4:	f0 ca ff f8 	sub	r10,r8,-8
800052d8:	14 39       	cp.w	r9,r10
800052da:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800052de:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800052e2:	70 18       	ld.w	r8,r8[0x4]
800052e4:	70 39       	ld.w	r9,r8[0xc]
800052e6:	48 68       	lddpc	r8,800052fc <vTaskSwitchContext+0x78>
800052e8:	91 09       	st.w	r8[0x0],r9
800052ea:	5e fc       	retal	r12
800052ec:	00 00       	add	r0,r0
800052ee:	0c ec       	st.h	--r6,r12
800052f0:	00 00       	add	r0,r0
800052f2:	0d 24       	ld.uh	r4,r6++
800052f4:	00 00       	add	r0,r0
800052f6:	0c 08       	add	r8,r6
800052f8:	00 00       	add	r0,r0
800052fa:	0d 0c       	ld.w	r12,r6++
800052fc:	00 00       	add	r0,r0
800052fe:	0c bc       	st.h	r6++,r12

80005300 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005300:	48 48       	lddpc	r8,80005310 <vTaskSetTimeOutState+0x10>
80005302:	70 08       	ld.w	r8,r8[0x0]
80005304:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005306:	48 48       	lddpc	r8,80005314 <vTaskSetTimeOutState+0x14>
80005308:	70 08       	ld.w	r8,r8[0x0]
8000530a:	99 18       	st.w	r12[0x4],r8
}
8000530c:	5e fc       	retal	r12
8000530e:	00 00       	add	r0,r0
80005310:	00 00       	add	r0,r0
80005312:	0c 00       	add	r0,r6
80005314:	00 00       	add	r0,r0
80005316:	0c e8       	st.h	--r6,r8

80005318 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005318:	30 19       	mov	r9,1
8000531a:	48 28       	lddpc	r8,80005320 <vTaskMissedYield+0x8>
8000531c:	91 09       	st.w	r8[0x0],r9
}
8000531e:	5e fc       	retal	r12
80005320:	00 00       	add	r0,r0
80005322:	0d 0c       	ld.w	r12,r6++

80005324 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005324:	48 28       	lddpc	r8,8000532c <xTaskGetCurrentTaskHandle+0x8>
80005326:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005328:	5e fc       	retal	r12
8000532a:	00 00       	add	r0,r0
8000532c:	00 00       	add	r0,r0
8000532e:	0c bc       	st.h	r6++,r12

80005330 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005330:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005334:	58 0c       	cp.w	r12,0
80005336:	c1 f0       	breq	80005374 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005338:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000533a:	78 b9       	ld.w	r9,r12[0x2c]
8000533c:	79 18       	ld.w	r8,r12[0x44]
8000533e:	10 39       	cp.w	r9,r8
80005340:	c1 a0       	breq	80005374 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005342:	f8 c6 ff fc 	sub	r6,r12,-4
80005346:	0c 9c       	mov	r12,r6
80005348:	f0 1f 00 0c 	mcall	80005378 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000534c:	6f 1c       	ld.w	r12,r7[0x44]
8000534e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005350:	f8 08 11 08 	rsub	r8,r12,8
80005354:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005356:	48 a8       	lddpc	r8,8000537c <vTaskPriorityDisinherit+0x4c>
80005358:	70 08       	ld.w	r8,r8[0x0]
8000535a:	10 3c       	cp.w	r12,r8
8000535c:	e0 88 00 04 	brls	80005364 <vTaskPriorityDisinherit+0x34>
80005360:	48 78       	lddpc	r8,8000537c <vTaskPriorityDisinherit+0x4c>
80005362:	91 0c       	st.w	r8[0x0],r12
80005364:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005368:	0c 9b       	mov	r11,r6
8000536a:	48 68       	lddpc	r8,80005380 <vTaskPriorityDisinherit+0x50>
8000536c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005370:	f0 1f 00 05 	mcall	80005384 <vTaskPriorityDisinherit+0x54>
80005374:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	4a 86       	lddpc	r6,80005418 <xTaskRemoveFromEventList+0xc>
8000537c:	00 00       	add	r0,r0
8000537e:	0d 24       	ld.uh	r4,r6++
80005380:	00 00       	add	r0,r0
80005382:	0c 08       	add	r8,r6
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	4a 36       	lddpc	r6,80005410 <xTaskRemoveFromEventList+0x4>

80005388 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005388:	eb cd 40 c0 	pushm	r6-r7,lr
8000538c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000538e:	49 b8       	lddpc	r8,800053f8 <vTaskPriorityInherit+0x70>
80005390:	70 08       	ld.w	r8,r8[0x0]
80005392:	78 b9       	ld.w	r9,r12[0x2c]
80005394:	70 b8       	ld.w	r8,r8[0x2c]
80005396:	10 39       	cp.w	r9,r8
80005398:	c2 d2       	brcc	800053f2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000539a:	49 88       	lddpc	r8,800053f8 <vTaskPriorityInherit+0x70>
8000539c:	70 08       	ld.w	r8,r8[0x0]
8000539e:	70 b8       	ld.w	r8,r8[0x2c]
800053a0:	f0 08 11 08 	rsub	r8,r8,8
800053a4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800053a6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800053aa:	49 59       	lddpc	r9,800053fc <vTaskPriorityInherit+0x74>
800053ac:	f2 08 00 28 	add	r8,r9,r8<<0x2
800053b0:	78 59       	ld.w	r9,r12[0x14]
800053b2:	10 39       	cp.w	r9,r8
800053b4:	c1 b1       	brne	800053ea <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800053b6:	f8 c6 ff fc 	sub	r6,r12,-4
800053ba:	0c 9c       	mov	r12,r6
800053bc:	f0 1f 00 11 	mcall	80005400 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800053c0:	48 e8       	lddpc	r8,800053f8 <vTaskPriorityInherit+0x70>
800053c2:	70 08       	ld.w	r8,r8[0x0]
800053c4:	70 bc       	ld.w	r12,r8[0x2c]
800053c6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800053c8:	48 f8       	lddpc	r8,80005404 <vTaskPriorityInherit+0x7c>
800053ca:	70 08       	ld.w	r8,r8[0x0]
800053cc:	10 3c       	cp.w	r12,r8
800053ce:	e0 88 00 04 	brls	800053d6 <vTaskPriorityInherit+0x4e>
800053d2:	48 d8       	lddpc	r8,80005404 <vTaskPriorityInherit+0x7c>
800053d4:	91 0c       	st.w	r8[0x0],r12
800053d6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800053da:	0c 9b       	mov	r11,r6
800053dc:	48 88       	lddpc	r8,800053fc <vTaskPriorityInherit+0x74>
800053de:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800053e2:	f0 1f 00 0a 	mcall	80005408 <vTaskPriorityInherit+0x80>
800053e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800053ea:	48 48       	lddpc	r8,800053f8 <vTaskPriorityInherit+0x70>
800053ec:	70 08       	ld.w	r8,r8[0x0]
800053ee:	70 b8       	ld.w	r8,r8[0x2c]
800053f0:	99 b8       	st.w	r12[0x2c],r8
800053f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053f6:	00 00       	add	r0,r0
800053f8:	00 00       	add	r0,r0
800053fa:	0c bc       	st.h	r6++,r12
800053fc:	00 00       	add	r0,r0
800053fe:	0c 08       	add	r8,r6
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	4a 86       	lddpc	r6,800054a0 <vTaskIncrementTick+0x18>
80005404:	00 00       	add	r0,r0
80005406:	0d 24       	ld.uh	r4,r6++
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	4a 36       	lddpc	r6,80005494 <vTaskIncrementTick+0xc>

8000540c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000540c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005410:	78 38       	ld.w	r8,r12[0xc]
80005412:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005414:	ee c6 ff e8 	sub	r6,r7,-24
80005418:	0c 9c       	mov	r12,r6
8000541a:	f0 1f 00 15 	mcall	8000546c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000541e:	49 58       	lddpc	r8,80005470 <xTaskRemoveFromEventList+0x64>
80005420:	70 08       	ld.w	r8,r8[0x0]
80005422:	58 08       	cp.w	r8,0
80005424:	c1 71       	brne	80005452 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005426:	ee c6 ff fc 	sub	r6,r7,-4
8000542a:	0c 9c       	mov	r12,r6
8000542c:	f0 1f 00 10 	mcall	8000546c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005430:	6e bc       	ld.w	r12,r7[0x2c]
80005432:	49 18       	lddpc	r8,80005474 <xTaskRemoveFromEventList+0x68>
80005434:	70 08       	ld.w	r8,r8[0x0]
80005436:	10 3c       	cp.w	r12,r8
80005438:	e0 88 00 04 	brls	80005440 <xTaskRemoveFromEventList+0x34>
8000543c:	48 e8       	lddpc	r8,80005474 <xTaskRemoveFromEventList+0x68>
8000543e:	91 0c       	st.w	r8[0x0],r12
80005440:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005444:	0c 9b       	mov	r11,r6
80005446:	48 d8       	lddpc	r8,80005478 <xTaskRemoveFromEventList+0x6c>
80005448:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000544c:	f0 1f 00 0c 	mcall	8000547c <xTaskRemoveFromEventList+0x70>
80005450:	c0 58       	rjmp	8000545a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005452:	0c 9b       	mov	r11,r6
80005454:	48 bc       	lddpc	r12,80005480 <xTaskRemoveFromEventList+0x74>
80005456:	f0 1f 00 0a 	mcall	8000547c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000545a:	48 b8       	lddpc	r8,80005484 <xTaskRemoveFromEventList+0x78>
8000545c:	70 08       	ld.w	r8,r8[0x0]
8000545e:	6e b9       	ld.w	r9,r7[0x2c]
80005460:	70 b8       	ld.w	r8,r8[0x2c]
80005462:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005464:	5f 2c       	srhs	r12
80005466:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000546a:	00 00       	add	r0,r0
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	4a 86       	lddpc	r6,8000550c <vTaskIncrementTick+0x84>
80005470:	00 00       	add	r0,r0
80005472:	0c ec       	st.h	--r6,r12
80005474:	00 00       	add	r0,r0
80005476:	0d 24       	ld.uh	r4,r6++
80005478:	00 00       	add	r0,r0
8000547a:	0c 08       	add	r8,r6
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	4a 36       	lddpc	r6,80005508 <vTaskIncrementTick+0x80>
80005480:	00 00       	add	r0,r0
80005482:	0c c0       	st.b	r6++,r0
80005484:	00 00       	add	r0,r0
80005486:	0c bc       	st.h	r6++,r12

80005488 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005488:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000548c:	4b 98       	lddpc	r8,80005570 <vTaskIncrementTick+0xe8>
8000548e:	70 08       	ld.w	r8,r8[0x0]
80005490:	58 08       	cp.w	r8,0
80005492:	c6 91       	brne	80005564 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005494:	4b 88       	lddpc	r8,80005574 <vTaskIncrementTick+0xec>
80005496:	70 09       	ld.w	r9,r8[0x0]
80005498:	2f f9       	sub	r9,-1
8000549a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000549c:	70 08       	ld.w	r8,r8[0x0]
8000549e:	58 08       	cp.w	r8,0
800054a0:	c1 a1       	brne	800054d4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800054a2:	4b 68       	lddpc	r8,80005578 <vTaskIncrementTick+0xf0>
800054a4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800054a6:	4b 69       	lddpc	r9,8000557c <vTaskIncrementTick+0xf4>
800054a8:	72 0b       	ld.w	r11,r9[0x0]
800054aa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800054ac:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800054ae:	4b 59       	lddpc	r9,80005580 <vTaskIncrementTick+0xf8>
800054b0:	72 0a       	ld.w	r10,r9[0x0]
800054b2:	2f fa       	sub	r10,-1
800054b4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800054b6:	70 08       	ld.w	r8,r8[0x0]
800054b8:	70 08       	ld.w	r8,r8[0x0]
800054ba:	58 08       	cp.w	r8,0
800054bc:	c0 51       	brne	800054c6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800054be:	3f f9       	mov	r9,-1
800054c0:	4b 18       	lddpc	r8,80005584 <vTaskIncrementTick+0xfc>
800054c2:	91 09       	st.w	r8[0x0],r9
800054c4:	c0 88       	rjmp	800054d4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800054c6:	4a d8       	lddpc	r8,80005578 <vTaskIncrementTick+0xf0>
800054c8:	70 08       	ld.w	r8,r8[0x0]
800054ca:	70 38       	ld.w	r8,r8[0xc]
800054cc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800054ce:	70 19       	ld.w	r9,r8[0x4]
800054d0:	4a d8       	lddpc	r8,80005584 <vTaskIncrementTick+0xfc>
800054d2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800054d4:	4a 88       	lddpc	r8,80005574 <vTaskIncrementTick+0xec>
800054d6:	70 09       	ld.w	r9,r8[0x0]
800054d8:	4a b8       	lddpc	r8,80005584 <vTaskIncrementTick+0xfc>
800054da:	70 08       	ld.w	r8,r8[0x0]
800054dc:	10 39       	cp.w	r9,r8
800054de:	c4 73       	brcs	8000556c <vTaskIncrementTick+0xe4>
800054e0:	4a 68       	lddpc	r8,80005578 <vTaskIncrementTick+0xf0>
800054e2:	70 08       	ld.w	r8,r8[0x0]
800054e4:	70 08       	ld.w	r8,r8[0x0]
800054e6:	58 08       	cp.w	r8,0
800054e8:	c0 c0       	breq	80005500 <vTaskIncrementTick+0x78>
800054ea:	4a 48       	lddpc	r8,80005578 <vTaskIncrementTick+0xf0>
800054ec:	70 08       	ld.w	r8,r8[0x0]
800054ee:	70 38       	ld.w	r8,r8[0xc]
800054f0:	70 37       	ld.w	r7,r8[0xc]
800054f2:	6e 18       	ld.w	r8,r7[0x4]
800054f4:	4a 09       	lddpc	r9,80005574 <vTaskIncrementTick+0xec>
800054f6:	72 09       	ld.w	r9,r9[0x0]
800054f8:	12 38       	cp.w	r8,r9
800054fa:	e0 88 00 14 	brls	80005522 <vTaskIncrementTick+0x9a>
800054fe:	c0 e8       	rjmp	8000551a <vTaskIncrementTick+0x92>
80005500:	3f f9       	mov	r9,-1
80005502:	4a 18       	lddpc	r8,80005584 <vTaskIncrementTick+0xfc>
80005504:	91 09       	st.w	r8[0x0],r9
80005506:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000550a:	6a 08       	ld.w	r8,r5[0x0]
8000550c:	70 38       	ld.w	r8,r8[0xc]
8000550e:	70 37       	ld.w	r7,r8[0xc]
80005510:	6e 18       	ld.w	r8,r7[0x4]
80005512:	64 09       	ld.w	r9,r2[0x0]
80005514:	12 38       	cp.w	r8,r9
80005516:	e0 88 00 0a 	brls	8000552a <vTaskIncrementTick+0xa2>
8000551a:	49 b9       	lddpc	r9,80005584 <vTaskIncrementTick+0xfc>
8000551c:	93 08       	st.w	r9[0x0],r8
8000551e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005522:	49 a4       	lddpc	r4,80005588 <vTaskIncrementTick+0x100>
80005524:	49 a3       	lddpc	r3,8000558c <vTaskIncrementTick+0x104>
80005526:	49 55       	lddpc	r5,80005578 <vTaskIncrementTick+0xf0>
80005528:	49 32       	lddpc	r2,80005574 <vTaskIncrementTick+0xec>
8000552a:	ee c6 ff fc 	sub	r6,r7,-4
8000552e:	0c 9c       	mov	r12,r6
80005530:	f0 1f 00 18 	mcall	80005590 <vTaskIncrementTick+0x108>
80005534:	6e a8       	ld.w	r8,r7[0x28]
80005536:	58 08       	cp.w	r8,0
80005538:	c0 50       	breq	80005542 <vTaskIncrementTick+0xba>
8000553a:	ee cc ff e8 	sub	r12,r7,-24
8000553e:	f0 1f 00 15 	mcall	80005590 <vTaskIncrementTick+0x108>
80005542:	6e bc       	ld.w	r12,r7[0x2c]
80005544:	68 08       	ld.w	r8,r4[0x0]
80005546:	10 3c       	cp.w	r12,r8
80005548:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000554c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005550:	0c 9b       	mov	r11,r6
80005552:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005556:	f0 1f 00 10 	mcall	80005594 <vTaskIncrementTick+0x10c>
8000555a:	6a 08       	ld.w	r8,r5[0x0]
8000555c:	70 08       	ld.w	r8,r8[0x0]
8000555e:	58 08       	cp.w	r8,0
80005560:	cd 51       	brne	8000550a <vTaskIncrementTick+0x82>
80005562:	cc fb       	rjmp	80005500 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005564:	48 d8       	lddpc	r8,80005598 <vTaskIncrementTick+0x110>
80005566:	70 09       	ld.w	r9,r8[0x0]
80005568:	2f f9       	sub	r9,-1
8000556a:	91 09       	st.w	r8[0x0],r9
8000556c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005570:	00 00       	add	r0,r0
80005572:	0c ec       	st.h	--r6,r12
80005574:	00 00       	add	r0,r0
80005576:	0c e8       	st.h	--r6,r8
80005578:	00 00       	add	r0,r0
8000557a:	0b f4       	ld.ub	r4,r5[0x7]
8000557c:	00 00       	add	r0,r0
8000557e:	0c 04       	add	r4,r6
80005580:	00 00       	add	r0,r0
80005582:	0c 00       	add	r0,r6
80005584:	00 00       	add	r0,r0
80005586:	05 28       	ld.uh	r8,r2++
80005588:	00 00       	add	r0,r0
8000558a:	0d 24       	ld.uh	r4,r6++
8000558c:	00 00       	add	r0,r0
8000558e:	0c 08       	add	r8,r6
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	4a 86       	lddpc	r6,80005630 <xTaskResumeAll>
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	4a 36       	lddpc	r6,80005620 <xTaskGetTickCount+0x14>
80005598:	00 00       	add	r0,r0
8000559a:	0b ec       	ld.ub	r12,r5[0x6]

8000559c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000559c:	eb cd 40 c0 	pushm	r6-r7,lr
800055a0:	18 97       	mov	r7,r12
800055a2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800055a4:	f0 1f 00 15 	mcall	800055f8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800055a8:	6c 08       	ld.w	r8,r6[0x0]
800055aa:	5b f8       	cp.w	r8,-1
800055ac:	c0 31       	brne	800055b2 <xTaskCheckForTimeOut+0x16>
800055ae:	30 07       	mov	r7,0
800055b0:	c1 f8       	rjmp	800055ee <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800055b2:	49 39       	lddpc	r9,800055fc <xTaskCheckForTimeOut+0x60>
800055b4:	72 09       	ld.w	r9,r9[0x0]
800055b6:	6e 0a       	ld.w	r10,r7[0x0]
800055b8:	12 3a       	cp.w	r10,r9
800055ba:	c0 70       	breq	800055c8 <xTaskCheckForTimeOut+0x2c>
800055bc:	49 19       	lddpc	r9,80005600 <xTaskCheckForTimeOut+0x64>
800055be:	72 09       	ld.w	r9,r9[0x0]
800055c0:	6e 1a       	ld.w	r10,r7[0x4]
800055c2:	12 3a       	cp.w	r10,r9
800055c4:	e0 88 00 14 	brls	800055ec <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800055c8:	48 e9       	lddpc	r9,80005600 <xTaskCheckForTimeOut+0x64>
800055ca:	72 0a       	ld.w	r10,r9[0x0]
800055cc:	6e 19       	ld.w	r9,r7[0x4]
800055ce:	12 1a       	sub	r10,r9
800055d0:	14 38       	cp.w	r8,r10
800055d2:	e0 88 00 0d 	brls	800055ec <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800055d6:	48 ba       	lddpc	r10,80005600 <xTaskCheckForTimeOut+0x64>
800055d8:	74 0a       	ld.w	r10,r10[0x0]
800055da:	14 19       	sub	r9,r10
800055dc:	f2 08 00 08 	add	r8,r9,r8
800055e0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800055e2:	0e 9c       	mov	r12,r7
800055e4:	f0 1f 00 08 	mcall	80005604 <xTaskCheckForTimeOut+0x68>
800055e8:	30 07       	mov	r7,0
800055ea:	c0 28       	rjmp	800055ee <xTaskCheckForTimeOut+0x52>
800055ec:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800055ee:	f0 1f 00 07 	mcall	80005608 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800055f2:	0e 9c       	mov	r12,r7
800055f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	4b 40       	lddpc	r0,800056c8 <xTaskResumeAll+0x98>
800055fc:	00 00       	add	r0,r0
800055fe:	0c 00       	add	r0,r6
80005600:	00 00       	add	r0,r0
80005602:	0c e8       	st.h	--r6,r8
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	53 00       	stdsp	sp[0xc0],r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	4c 4c       	lddpc	r12,80005718 <prvAddCurrentTaskToDelayedList>

8000560c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000560c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005610:	f0 1f 00 05 	mcall	80005624 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005614:	48 58       	lddpc	r8,80005628 <xTaskGetTickCount+0x1c>
80005616:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005618:	f0 1f 00 05 	mcall	8000562c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000561c:	0e 9c       	mov	r12,r7
8000561e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005622:	00 00       	add	r0,r0
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	4b 40       	lddpc	r0,800056f4 <xTaskResumeAll+0xc4>
80005628:	00 00       	add	r0,r0
8000562a:	0c e8       	st.h	--r6,r8
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	4c 4c       	lddpc	r12,8000573c <prvAddCurrentTaskToDelayedList+0x24>

80005630 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005630:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005634:	f0 1f 00 2c 	mcall	800056e4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005638:	4a c8       	lddpc	r8,800056e8 <xTaskResumeAll+0xb8>
8000563a:	70 09       	ld.w	r9,r8[0x0]
8000563c:	20 19       	sub	r9,1
8000563e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005640:	70 08       	ld.w	r8,r8[0x0]
80005642:	58 08       	cp.w	r8,0
80005644:	c4 91       	brne	800056d6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005646:	4a a8       	lddpc	r8,800056ec <xTaskResumeAll+0xbc>
80005648:	70 08       	ld.w	r8,r8[0x0]
8000564a:	58 08       	cp.w	r8,0
8000564c:	c4 50       	breq	800056d6 <xTaskResumeAll+0xa6>
8000564e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005650:	4a 85       	lddpc	r5,800056f0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005652:	4a 93       	lddpc	r3,800056f4 <xTaskResumeAll+0xc4>
80005654:	4a 92       	lddpc	r2,800056f8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005656:	4a a1       	lddpc	r1,800056fc <xTaskResumeAll+0xcc>
80005658:	c1 e8       	rjmp	80005694 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000565a:	6a 38       	ld.w	r8,r5[0xc]
8000565c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000565e:	ee cc ff e8 	sub	r12,r7,-24
80005662:	f0 1f 00 28 	mcall	80005700 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005666:	ee c6 ff fc 	sub	r6,r7,-4
8000566a:	0c 9c       	mov	r12,r6
8000566c:	f0 1f 00 25 	mcall	80005700 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005670:	6e bc       	ld.w	r12,r7[0x2c]
80005672:	66 08       	ld.w	r8,r3[0x0]
80005674:	10 3c       	cp.w	r12,r8
80005676:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000567a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000567e:	0c 9b       	mov	r11,r6
80005680:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005684:	f0 1f 00 20 	mcall	80005704 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005688:	62 08       	ld.w	r8,r1[0x0]
8000568a:	6e b9       	ld.w	r9,r7[0x2c]
8000568c:	70 b8       	ld.w	r8,r8[0x2c]
8000568e:	10 39       	cp.w	r9,r8
80005690:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005694:	6a 08       	ld.w	r8,r5[0x0]
80005696:	58 08       	cp.w	r8,0
80005698:	ce 11       	brne	8000565a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000569a:	49 c8       	lddpc	r8,80005708 <xTaskResumeAll+0xd8>
8000569c:	70 08       	ld.w	r8,r8[0x0]
8000569e:	58 08       	cp.w	r8,0
800056a0:	c0 f0       	breq	800056be <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800056a2:	49 a8       	lddpc	r8,80005708 <xTaskResumeAll+0xd8>
800056a4:	70 08       	ld.w	r8,r8[0x0]
800056a6:	58 08       	cp.w	r8,0
800056a8:	c1 10       	breq	800056ca <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800056aa:	49 87       	lddpc	r7,80005708 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800056ac:	f0 1f 00 18 	mcall	8000570c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800056b0:	6e 08       	ld.w	r8,r7[0x0]
800056b2:	20 18       	sub	r8,1
800056b4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800056b6:	6e 08       	ld.w	r8,r7[0x0]
800056b8:	58 08       	cp.w	r8,0
800056ba:	cf 91       	brne	800056ac <xTaskResumeAll+0x7c>
800056bc:	c0 78       	rjmp	800056ca <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800056be:	58 14       	cp.w	r4,1
800056c0:	c0 50       	breq	800056ca <xTaskResumeAll+0x9a>
800056c2:	49 48       	lddpc	r8,80005710 <xTaskResumeAll+0xe0>
800056c4:	70 08       	ld.w	r8,r8[0x0]
800056c6:	58 18       	cp.w	r8,1
800056c8:	c0 71       	brne	800056d6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800056ca:	30 09       	mov	r9,0
800056cc:	49 18       	lddpc	r8,80005710 <xTaskResumeAll+0xe0>
800056ce:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800056d0:	d7 33       	scall
800056d2:	30 17       	mov	r7,1
800056d4:	c0 28       	rjmp	800056d8 <xTaskResumeAll+0xa8>
800056d6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800056d8:	f0 1f 00 0f 	mcall	80005714 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800056dc:	0e 9c       	mov	r12,r7
800056de:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800056e2:	00 00       	add	r0,r0
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	4b 40       	lddpc	r0,800057b4 <vTaskDelayUntil+0x40>
800056e8:	00 00       	add	r0,r0
800056ea:	0c ec       	st.h	--r6,r12
800056ec:	00 00       	add	r0,r0
800056ee:	0d 08       	ld.w	r8,r6++
800056f0:	00 00       	add	r0,r0
800056f2:	0c c0       	st.b	r6++,r0
800056f4:	00 00       	add	r0,r0
800056f6:	0d 24       	ld.uh	r4,r6++
800056f8:	00 00       	add	r0,r0
800056fa:	0c 08       	add	r8,r6
800056fc:	00 00       	add	r0,r0
800056fe:	0c bc       	st.h	r6++,r12
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	4a 86       	lddpc	r6,800057a0 <vTaskDelayUntil+0x2c>
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	4a 36       	lddpc	r6,80005790 <vTaskDelayUntil+0x1c>
80005708:	00 00       	add	r0,r0
8000570a:	0b ec       	ld.ub	r12,r5[0x6]
8000570c:	80 00       	ld.sh	r0,r0[0x0]
8000570e:	54 88       	stdsp	sp[0x120],r8
80005710:	00 00       	add	r0,r0
80005712:	0d 0c       	ld.w	r12,r6++
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	4c 4c       	lddpc	r12,80005824 <vTaskPlaceOnEventList+0x30>

80005718 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005718:	eb cd 40 80 	pushm	r7,lr
8000571c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000571e:	49 08       	lddpc	r8,8000575c <prvAddCurrentTaskToDelayedList+0x44>
80005720:	70 08       	ld.w	r8,r8[0x0]
80005722:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005724:	48 f8       	lddpc	r8,80005760 <prvAddCurrentTaskToDelayedList+0x48>
80005726:	70 08       	ld.w	r8,r8[0x0]
80005728:	10 3c       	cp.w	r12,r8
8000572a:	c0 a2       	brcc	8000573e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000572c:	48 c8       	lddpc	r8,8000575c <prvAddCurrentTaskToDelayedList+0x44>
8000572e:	70 0b       	ld.w	r11,r8[0x0]
80005730:	48 d8       	lddpc	r8,80005764 <prvAddCurrentTaskToDelayedList+0x4c>
80005732:	70 0c       	ld.w	r12,r8[0x0]
80005734:	2f cb       	sub	r11,-4
80005736:	f0 1f 00 0d 	mcall	80005768 <prvAddCurrentTaskToDelayedList+0x50>
8000573a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000573e:	48 88       	lddpc	r8,8000575c <prvAddCurrentTaskToDelayedList+0x44>
80005740:	70 0b       	ld.w	r11,r8[0x0]
80005742:	48 b8       	lddpc	r8,8000576c <prvAddCurrentTaskToDelayedList+0x54>
80005744:	70 0c       	ld.w	r12,r8[0x0]
80005746:	2f cb       	sub	r11,-4
80005748:	f0 1f 00 08 	mcall	80005768 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000574c:	48 98       	lddpc	r8,80005770 <prvAddCurrentTaskToDelayedList+0x58>
8000574e:	70 08       	ld.w	r8,r8[0x0]
80005750:	10 37       	cp.w	r7,r8
80005752:	c0 32       	brcc	80005758 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005754:	48 78       	lddpc	r8,80005770 <prvAddCurrentTaskToDelayedList+0x58>
80005756:	91 07       	st.w	r8[0x0],r7
80005758:	e3 cd 80 80 	ldm	sp++,r7,pc
8000575c:	00 00       	add	r0,r0
8000575e:	0c bc       	st.h	r6++,r12
80005760:	00 00       	add	r0,r0
80005762:	0c e8       	st.h	--r6,r8
80005764:	00 00       	add	r0,r0
80005766:	0c 04       	add	r4,r6
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	4a 52       	lddpc	r2,800057fc <vTaskPlaceOnEventList+0x8>
8000576c:	00 00       	add	r0,r0
8000576e:	0b f4       	ld.ub	r4,r5[0x7]
80005770:	00 00       	add	r0,r0
80005772:	05 28       	ld.uh	r8,r2++

80005774 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005774:	eb cd 40 c0 	pushm	r6-r7,lr
80005778:	18 96       	mov	r6,r12
8000577a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000577c:	f0 1f 00 18 	mcall	800057dc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005780:	6c 08       	ld.w	r8,r6[0x0]
80005782:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005784:	49 79       	lddpc	r9,800057e0 <vTaskDelayUntil+0x6c>
80005786:	72 09       	ld.w	r9,r9[0x0]
80005788:	12 38       	cp.w	r8,r9
8000578a:	e0 88 00 0c 	brls	800057a2 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000578e:	0e 38       	cp.w	r8,r7
80005790:	e0 88 00 22 	brls	800057d4 <vTaskDelayUntil+0x60>
80005794:	49 38       	lddpc	r8,800057e0 <vTaskDelayUntil+0x6c>
80005796:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005798:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000579a:	10 37       	cp.w	r7,r8
8000579c:	e0 88 00 14 	brls	800057c4 <vTaskDelayUntil+0x50>
800057a0:	c0 a8       	rjmp	800057b4 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800057a2:	0e 38       	cp.w	r8,r7
800057a4:	e0 8b 00 16 	brhi	800057d0 <vTaskDelayUntil+0x5c>
800057a8:	48 e8       	lddpc	r8,800057e0 <vTaskDelayUntil+0x6c>
800057aa:	70 08       	ld.w	r8,r8[0x0]
800057ac:	10 37       	cp.w	r7,r8
800057ae:	e0 8b 00 11 	brhi	800057d0 <vTaskDelayUntil+0x5c>
800057b2:	c1 18       	rjmp	800057d4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057b4:	48 c8       	lddpc	r8,800057e4 <vTaskDelayUntil+0x70>
800057b6:	70 0c       	ld.w	r12,r8[0x0]
800057b8:	2f cc       	sub	r12,-4
800057ba:	f0 1f 00 0c 	mcall	800057e8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800057be:	0e 9c       	mov	r12,r7
800057c0:	f0 1f 00 0b 	mcall	800057ec <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800057c4:	f0 1f 00 0b 	mcall	800057f0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800057c8:	c0 81       	brne	800057d8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800057ca:	d7 33       	scall
800057cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800057d0:	8d 07       	st.w	r6[0x0],r7
800057d2:	cf 1b       	rjmp	800057b4 <vTaskDelayUntil+0x40>
800057d4:	8d 07       	st.w	r6[0x0],r7
800057d6:	cf 7b       	rjmp	800057c4 <vTaskDelayUntil+0x50>
800057d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	52 74       	stdsp	sp[0x9c],r4
800057e0:	00 00       	add	r0,r0
800057e2:	0c e8       	st.h	--r6,r8
800057e4:	00 00       	add	r0,r0
800057e6:	0c bc       	st.h	r6++,r12
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	4a 86       	lddpc	r6,80005888 <prvIdleTask+0x3c>
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	57 18       	stdsp	sp[0x1c4],r8
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	56 30       	stdsp	sp[0x18c],r0

800057f4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800057f4:	eb cd 40 c0 	pushm	r6-r7,lr
800057f8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800057fa:	48 e7       	lddpc	r7,80005830 <vTaskPlaceOnEventList+0x3c>
800057fc:	6e 0b       	ld.w	r11,r7[0x0]
800057fe:	2e 8b       	sub	r11,-24
80005800:	f0 1f 00 0d 	mcall	80005834 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005804:	6e 0c       	ld.w	r12,r7[0x0]
80005806:	2f cc       	sub	r12,-4
80005808:	f0 1f 00 0c 	mcall	80005838 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000580c:	5b f6       	cp.w	r6,-1
8000580e:	c0 81       	brne	8000581e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005810:	6e 0b       	ld.w	r11,r7[0x0]
80005812:	2f cb       	sub	r11,-4
80005814:	48 ac       	lddpc	r12,8000583c <vTaskPlaceOnEventList+0x48>
80005816:	f0 1f 00 0b 	mcall	80005840 <vTaskPlaceOnEventList+0x4c>
8000581a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000581e:	48 a8       	lddpc	r8,80005844 <vTaskPlaceOnEventList+0x50>
80005820:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005822:	ec 0c 00 0c 	add	r12,r6,r12
80005826:	f0 1f 00 09 	mcall	80005848 <vTaskPlaceOnEventList+0x54>
8000582a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000582e:	00 00       	add	r0,r0
80005830:	00 00       	add	r0,r0
80005832:	0c bc       	st.h	r6++,r12
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	4a 52       	lddpc	r2,800058c8 <prvIdleTask+0x7c>
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	4a 86       	lddpc	r6,800058d8 <xTaskGenericCreate+0x4>
8000583c:	00 00       	add	r0,r0
8000583e:	0d 10       	ld.sh	r0,r6++
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	4a 36       	lddpc	r6,800058cc <prvIdleTask+0x80>
80005844:	00 00       	add	r0,r0
80005846:	0c e8       	st.h	--r6,r8
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	57 18       	stdsp	sp[0x1c4],r8

8000584c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000584c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005850:	49 67       	lddpc	r7,800058a8 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005852:	49 74       	lddpc	r4,800058ac <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005854:	49 73       	lddpc	r3,800058b0 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005856:	49 85       	lddpc	r5,800058b4 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005858:	6e 08       	ld.w	r8,r7[0x0]
8000585a:	58 08       	cp.w	r8,0
8000585c:	c1 e0       	breq	80005898 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000585e:	f0 1f 00 17 	mcall	800058b8 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005862:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005864:	f0 1f 00 16 	mcall	800058bc <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005868:	58 06       	cp.w	r6,0
8000586a:	c1 70       	breq	80005898 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000586c:	f0 1f 00 15 	mcall	800058c0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005870:	68 38       	ld.w	r8,r4[0xc]
80005872:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005874:	ec cc ff fc 	sub	r12,r6,-4
80005878:	f0 1f 00 13 	mcall	800058c4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000587c:	66 08       	ld.w	r8,r3[0x0]
8000587e:	20 18       	sub	r8,1
80005880:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005882:	6e 08       	ld.w	r8,r7[0x0]
80005884:	20 18       	sub	r8,1
80005886:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005888:	f0 1f 00 10 	mcall	800058c8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000588c:	6c cc       	ld.w	r12,r6[0x30]
8000588e:	f0 1f 00 10 	mcall	800058cc <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005892:	0c 9c       	mov	r12,r6
80005894:	f0 1f 00 0e 	mcall	800058cc <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005898:	6a 08       	ld.w	r8,r5[0x0]
8000589a:	58 18       	cp.w	r8,1
8000589c:	e0 88 00 03 	brls	800058a2 <prvIdleTask+0x56>
			{
				taskYIELD();
800058a0:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800058a2:	f0 1f 00 0c 	mcall	800058d0 <prvIdleTask+0x84>
		}
		#endif
	}
800058a6:	cd 9b       	rjmp	80005858 <prvIdleTask+0xc>
800058a8:	00 00       	add	r0,r0
800058aa:	0b fc       	ld.ub	r12,r5[0x7]
800058ac:	00 00       	add	r0,r0
800058ae:	0c a8       	st.w	r6++,r8
800058b0:	00 00       	add	r0,r0
800058b2:	0d 08       	ld.w	r8,r6++
800058b4:	00 00       	add	r0,r0
800058b6:	0c 08       	add	r8,r6
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	52 74       	stdsp	sp[0x9c],r4
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	56 30       	stdsp	sp[0x18c],r0
800058c0:	80 00       	ld.sh	r0,r0[0x0]
800058c2:	4b 40       	lddpc	r0,80005990 <xTaskGenericCreate+0xbc>
800058c4:	80 00       	ld.sh	r0,r0[0x0]
800058c6:	4a 86       	lddpc	r6,80005964 <xTaskGenericCreate+0x90>
800058c8:	80 00       	ld.sh	r0,r0[0x0]
800058ca:	4c 4c       	lddpc	r12,800059d8 <xTaskGenericCreate+0x104>
800058cc:	80 00       	ld.sh	r0,r0[0x0]
800058ce:	4d 84       	lddpc	r4,80005a2c <xTaskGenericCreate+0x158>
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	20 2c       	sub	r12,2

800058d4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800058d4:	d4 31       	pushm	r0-r7,lr
800058d6:	20 1d       	sub	sp,4
800058d8:	fa c4 ff d8 	sub	r4,sp,-40
800058dc:	50 0c       	stdsp	sp[0x0],r12
800058de:	16 91       	mov	r1,r11
800058e0:	14 97       	mov	r7,r10
800058e2:	12 90       	mov	r0,r9
800058e4:	10 93       	mov	r3,r8
800058e6:	68 02       	ld.w	r2,r4[0x0]
800058e8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800058ea:	34 8c       	mov	r12,72
800058ec:	f0 1f 00 5c 	mcall	80005a5c <xTaskGenericCreate+0x188>
800058f0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800058f2:	c0 31       	brne	800058f8 <xTaskGenericCreate+0x24>
800058f4:	3f fc       	mov	r12,-1
800058f6:	ca f8       	rjmp	80005a54 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800058f8:	58 06       	cp.w	r6,0
800058fa:	e0 81 00 af 	brne	80005a58 <xTaskGenericCreate+0x184>
800058fe:	0e 9c       	mov	r12,r7
80005900:	5c 7c       	castu.h	r12
80005902:	a3 6c       	lsl	r12,0x2
80005904:	f0 1f 00 56 	mcall	80005a5c <xTaskGenericCreate+0x188>
80005908:	18 96       	mov	r6,r12
8000590a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
8000590c:	c0 61       	brne	80005918 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000590e:	0a 9c       	mov	r12,r5
80005910:	f0 1f 00 54 	mcall	80005a60 <xTaskGenericCreate+0x18c>
80005914:	3f fc       	mov	r12,-1
80005916:	c9 f8       	rjmp	80005a54 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005918:	5c 77       	castu.h	r7
8000591a:	ee 0a 15 02 	lsl	r10,r7,0x2
8000591e:	e0 6b 00 a5 	mov	r11,165
80005922:	0c 9c       	mov	r12,r6
80005924:	f0 1f 00 50 	mcall	80005a64 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005928:	ee c6 00 01 	sub	r6,r7,1
8000592c:	6a c8       	ld.w	r8,r5[0x30]
8000592e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005932:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005936:	31 0a       	mov	r10,16
80005938:	02 9b       	mov	r11,r1
8000593a:	ea cc ff cc 	sub	r12,r5,-52
8000593e:	f0 1f 00 4b 	mcall	80005a68 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005942:	30 08       	mov	r8,0
80005944:	eb 68 00 43 	st.b	r5[67],r8
80005948:	58 73       	cp.w	r3,7
8000594a:	e6 07 17 80 	movls	r7,r3
8000594e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005952:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005954:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005958:	ea c4 ff fc 	sub	r4,r5,-4
8000595c:	08 9c       	mov	r12,r4
8000595e:	f0 1f 00 44 	mcall	80005a6c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005962:	ea cc ff e8 	sub	r12,r5,-24
80005966:	f0 1f 00 42 	mcall	80005a6c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000596a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000596c:	ee 07 11 08 	rsub	r7,r7,8
80005970:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005972:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005974:	00 9a       	mov	r10,r0
80005976:	40 0b       	lddsp	r11,sp[0x0]
80005978:	0c 9c       	mov	r12,r6
8000597a:	f0 1f 00 3e 	mcall	80005a70 <xTaskGenericCreate+0x19c>
8000597e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005980:	58 02       	cp.w	r2,0
80005982:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005986:	f0 1f 00 3c 	mcall	80005a74 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000598a:	4b c8       	lddpc	r8,80005a78 <xTaskGenericCreate+0x1a4>
8000598c:	70 09       	ld.w	r9,r8[0x0]
8000598e:	2f f9       	sub	r9,-1
80005990:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005992:	4b b8       	lddpc	r8,80005a7c <xTaskGenericCreate+0x1a8>
80005994:	70 08       	ld.w	r8,r8[0x0]
80005996:	58 08       	cp.w	r8,0
80005998:	c2 61       	brne	800059e4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000599a:	4b 98       	lddpc	r8,80005a7c <xTaskGenericCreate+0x1a8>
8000599c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000599e:	4b 78       	lddpc	r8,80005a78 <xTaskGenericCreate+0x1a4>
800059a0:	70 08       	ld.w	r8,r8[0x0]
800059a2:	58 18       	cp.w	r8,1
800059a4:	c2 b1       	brne	800059fa <xTaskGenericCreate+0x126>
800059a6:	4b 77       	lddpc	r7,80005a80 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800059a8:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800059ac:	0e 9c       	mov	r12,r7
800059ae:	f0 1f 00 36 	mcall	80005a84 <xTaskGenericCreate+0x1b0>
800059b2:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800059b4:	0c 37       	cp.w	r7,r6
800059b6:	cf b1       	brne	800059ac <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800059b8:	4b 47       	lddpc	r7,80005a88 <xTaskGenericCreate+0x1b4>
800059ba:	0e 9c       	mov	r12,r7
800059bc:	f0 1f 00 32 	mcall	80005a84 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800059c0:	4b 36       	lddpc	r6,80005a8c <xTaskGenericCreate+0x1b8>
800059c2:	0c 9c       	mov	r12,r6
800059c4:	f0 1f 00 30 	mcall	80005a84 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800059c8:	4b 2c       	lddpc	r12,80005a90 <xTaskGenericCreate+0x1bc>
800059ca:	f0 1f 00 2f 	mcall	80005a84 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800059ce:	4b 2c       	lddpc	r12,80005a94 <xTaskGenericCreate+0x1c0>
800059d0:	f0 1f 00 2d 	mcall	80005a84 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800059d4:	4b 1c       	lddpc	r12,80005a98 <xTaskGenericCreate+0x1c4>
800059d6:	f0 1f 00 2c 	mcall	80005a84 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800059da:	4b 18       	lddpc	r8,80005a9c <xTaskGenericCreate+0x1c8>
800059dc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800059de:	4b 18       	lddpc	r8,80005aa0 <xTaskGenericCreate+0x1cc>
800059e0:	91 06       	st.w	r8[0x0],r6
800059e2:	c0 c8       	rjmp	800059fa <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800059e4:	4b 08       	lddpc	r8,80005aa4 <xTaskGenericCreate+0x1d0>
800059e6:	70 08       	ld.w	r8,r8[0x0]
800059e8:	58 08       	cp.w	r8,0
800059ea:	c0 81       	brne	800059fa <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800059ec:	4a 48       	lddpc	r8,80005a7c <xTaskGenericCreate+0x1a8>
800059ee:	70 08       	ld.w	r8,r8[0x0]
800059f0:	70 b8       	ld.w	r8,r8[0x2c]
800059f2:	10 33       	cp.w	r3,r8
800059f4:	c0 33       	brcs	800059fa <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800059f6:	4a 28       	lddpc	r8,80005a7c <xTaskGenericCreate+0x1a8>
800059f8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800059fa:	6a b8       	ld.w	r8,r5[0x2c]
800059fc:	4a b9       	lddpc	r9,80005aa8 <xTaskGenericCreate+0x1d4>
800059fe:	72 09       	ld.w	r9,r9[0x0]
80005a00:	12 38       	cp.w	r8,r9
80005a02:	e0 88 00 04 	brls	80005a0a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005a06:	4a 99       	lddpc	r9,80005aa8 <xTaskGenericCreate+0x1d4>
80005a08:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005a0a:	4a 98       	lddpc	r8,80005aac <xTaskGenericCreate+0x1d8>
80005a0c:	70 09       	ld.w	r9,r8[0x0]
80005a0e:	2f f9       	sub	r9,-1
80005a10:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005a12:	6a b8       	ld.w	r8,r5[0x2c]
80005a14:	4a 79       	lddpc	r9,80005ab0 <xTaskGenericCreate+0x1dc>
80005a16:	72 09       	ld.w	r9,r9[0x0]
80005a18:	12 38       	cp.w	r8,r9
80005a1a:	e0 88 00 04 	brls	80005a22 <xTaskGenericCreate+0x14e>
80005a1e:	4a 59       	lddpc	r9,80005ab0 <xTaskGenericCreate+0x1dc>
80005a20:	93 08       	st.w	r9[0x0],r8
80005a22:	6a bc       	ld.w	r12,r5[0x2c]
80005a24:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a28:	08 9b       	mov	r11,r4
80005a2a:	49 68       	lddpc	r8,80005a80 <xTaskGenericCreate+0x1ac>
80005a2c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a30:	f0 1f 00 21 	mcall	80005ab4 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005a34:	f0 1f 00 21 	mcall	80005ab8 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005a38:	49 b8       	lddpc	r8,80005aa4 <xTaskGenericCreate+0x1d0>
80005a3a:	70 08       	ld.w	r8,r8[0x0]
80005a3c:	58 08       	cp.w	r8,0
80005a3e:	c0 a0       	breq	80005a52 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005a40:	48 f8       	lddpc	r8,80005a7c <xTaskGenericCreate+0x1a8>
80005a42:	70 08       	ld.w	r8,r8[0x0]
80005a44:	70 b8       	ld.w	r8,r8[0x2c]
80005a46:	10 33       	cp.w	r3,r8
80005a48:	e0 88 00 05 	brls	80005a52 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005a4c:	d7 33       	scall
80005a4e:	30 1c       	mov	r12,1
80005a50:	c0 28       	rjmp	80005a54 <xTaskGenericCreate+0x180>
80005a52:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005a54:	2f fd       	sub	sp,-4
80005a56:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005a58:	99 c6       	st.w	r12[0x30],r6
80005a5a:	c5 fb       	rjmp	80005918 <xTaskGenericCreate+0x44>
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	4d ac       	lddpc	r12,80005bc4 <PrintDec+0x6>
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	4d 84       	lddpc	r4,80005bc0 <PrintDec+0x2>
80005a64:	80 00       	ld.sh	r0,r0[0x0]
80005a66:	66 50       	ld.w	r0,r3[0x14]
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	69 7c       	ld.w	r12,r4[0x5c]
80005a6c:	80 00       	ld.sh	r0,r0[0x0]
80005a6e:	4a 30       	lddpc	r0,80005af8 <vTaskStartScheduler+0x3c>
80005a70:	80 00       	ld.sh	r0,r0[0x0]
80005a72:	4a ac       	lddpc	r12,80005b18 <PrintHex+0xc>
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	4b 40       	lddpc	r0,80005b44 <PrintHex+0x38>
80005a78:	00 00       	add	r0,r0
80005a7a:	0d 08       	ld.w	r8,r6++
80005a7c:	00 00       	add	r0,r0
80005a7e:	0c bc       	st.h	r6++,r12
80005a80:	00 00       	add	r0,r0
80005a82:	0c 08       	add	r8,r6
80005a84:	80 00       	ld.sh	r0,r0[0x0]
80005a86:	4a 1c       	lddpc	r12,80005b08 <PrintChar>
80005a88:	00 00       	add	r0,r0
80005a8a:	0c d4       	st.w	--r6,r4
80005a8c:	00 00       	add	r0,r0
80005a8e:	0c f0       	st.b	--r6,r0
80005a90:	00 00       	add	r0,r0
80005a92:	0c c0       	st.b	r6++,r0
80005a94:	00 00       	add	r0,r0
80005a96:	0c a8       	st.w	r6++,r8
80005a98:	00 00       	add	r0,r0
80005a9a:	0d 10       	ld.sh	r0,r6++
80005a9c:	00 00       	add	r0,r0
80005a9e:	0b f4       	ld.ub	r4,r5[0x7]
80005aa0:	00 00       	add	r0,r0
80005aa2:	0c 04       	add	r4,r6
80005aa4:	00 00       	add	r0,r0
80005aa6:	0b f8       	ld.ub	r8,r5[0x7]
80005aa8:	00 00       	add	r0,r0
80005aaa:	0b f0       	ld.ub	r0,r5[0x7]
80005aac:	00 00       	add	r0,r0
80005aae:	0d 04       	ld.w	r4,r6++
80005ab0:	00 00       	add	r0,r0
80005ab2:	0d 24       	ld.uh	r4,r6++
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	4a 36       	lddpc	r6,80005b40 <PrintHex+0x34>
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	4c 4c       	lddpc	r12,80005bc8 <PrintDec+0xa>

80005abc <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005abc:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005abe:	30 09       	mov	r9,0
80005ac0:	1a d9       	st.w	--sp,r9
80005ac2:	1a d9       	st.w	--sp,r9
80005ac4:	1a d9       	st.w	--sp,r9
80005ac6:	12 98       	mov	r8,r9
80005ac8:	e0 6a 01 00 	mov	r10,256
80005acc:	48 9b       	lddpc	r11,80005af0 <vTaskStartScheduler+0x34>
80005ace:	48 ac       	lddpc	r12,80005af4 <vTaskStartScheduler+0x38>
80005ad0:	f0 1f 00 0a 	mcall	80005af8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005ad4:	2f dd       	sub	sp,-12
80005ad6:	58 1c       	cp.w	r12,1
80005ad8:	c0 a1       	brne	80005aec <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005ada:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005adc:	30 19       	mov	r9,1
80005ade:	48 88       	lddpc	r8,80005afc <vTaskStartScheduler+0x40>
80005ae0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005ae2:	30 09       	mov	r9,0
80005ae4:	48 78       	lddpc	r8,80005b00 <vTaskStartScheduler+0x44>
80005ae6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005ae8:	f0 1f 00 07 	mcall	80005b04 <vTaskStartScheduler+0x48>
80005aec:	d8 02       	popm	pc
80005aee:	00 00       	add	r0,r0
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	c3 f8       	rjmp	80005b70 <PrintHex+0x64>
80005af4:	80 00       	ld.sh	r0,r0[0x0]
80005af6:	58 4c       	cp.w	r12,4
80005af8:	80 00       	ld.sh	r0,r0[0x0]
80005afa:	58 d4       	cp.w	r4,13
80005afc:	00 00       	add	r0,r0
80005afe:	0b f8       	ld.ub	r8,r5[0x7]
80005b00:	00 00       	add	r0,r0
80005b02:	0c e8       	st.h	--r6,r8
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	4b 50       	lddpc	r0,80005bd8 <PrintDec+0x1a>

80005b08 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005b08:	16 cc       	st.b	r11++,r12
	return str;
}
80005b0a:	5e fb       	retal	r11

80005b0c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005b0c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b10:	20 3d       	sub	sp,12
80005b12:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005b14:	30 06       	mov	r6,0
80005b16:	30 07       	mov	r7,0
80005b18:	fa e7 00 00 	st.d	sp[0],r6
80005b1c:	30 0c       	mov	r12,0
80005b1e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005b20:	58 08       	cp.w	r8,0
80005b22:	c1 30       	breq	80005b48 <PrintHex+0x3c>
80005b24:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005b26:	1a 9c       	mov	r12,sp
80005b28:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005b2c:	58 9e       	cp.w	lr,9
80005b2e:	e0 8a 00 04 	brle	80005b36 <PrintHex+0x2a>
80005b32:	2c 9e       	sub	lr,-55
80005b34:	c0 48       	rjmp	80005b3c <PrintHex+0x30>
80005b36:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005b3a:	2d 0e       	sub	lr,-48
80005b3c:	f8 09 0b 0e 	st.b	r12[r9],lr
80005b40:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005b42:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005b44:	cf 21       	brne	80005b28 <PrintHex+0x1c>
80005b46:	c0 48       	rjmp	80005b4e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005b48:	33 08       	mov	r8,48
80005b4a:	ba 88       	st.b	sp[0x0],r8
80005b4c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005b4e:	f6 09 01 08 	sub	r8,r11,r9
80005b52:	58 08       	cp.w	r8,0
80005b54:	e0 8a 00 13 	brle	80005b7a <PrintHex+0x6e>
	{
		char num = len - cnt;
80005b58:	12 1b       	sub	r11,r9
80005b5a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005b5e:	18 9e       	mov	lr,r12
80005b60:	58 0c       	cp.w	r12,0
80005b62:	e0 8a 00 0c 	brle	80005b7a <PrintHex+0x6e>
80005b66:	1a 9b       	mov	r11,sp
80005b68:	12 0b       	add	r11,r9
80005b6a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005b6c:	33 07       	mov	r7,48
80005b6e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005b70:	2f f8       	sub	r8,-1
80005b72:	1c 38       	cp.w	r8,lr
80005b74:	cf d5       	brlt	80005b6e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005b76:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005b7a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005b7e:	f0 cb ff ff 	sub	r11,r8,-1
80005b82:	58 0b       	cp.w	r11,0
80005b84:	e0 8a 00 19 	brle	80005bb6 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005b88:	fa cb ff f4 	sub	r11,sp,-12
80005b8c:	f6 09 00 09 	add	r9,r11,r9
80005b90:	37 8b       	mov	r11,120
80005b92:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005b96:	fa c9 ff f4 	sub	r9,sp,-12
80005b9a:	10 09       	add	r9,r8
80005b9c:	33 0b       	mov	r11,48
80005b9e:	f3 6b ff f4 	st.b	r9[-12],r11
80005ba2:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005ba6:	fa ce 00 01 	sub	lr,sp,1
80005baa:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005bac:	11 8b       	ld.ub	r11,r8[0x0]
80005bae:	12 cb       	st.b	r9++,r11
80005bb0:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005bb2:	1c 38       	cp.w	r8,lr
80005bb4:	cf c1       	brne	80005bac <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005bb6:	14 9c       	mov	r12,r10
80005bb8:	2f dd       	sub	sp,-12
80005bba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005bbe <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005bbe:	d4 21       	pushm	r4-r7,lr
80005bc0:	20 3d       	sub	sp,12
80005bc2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005bc4:	30 06       	mov	r6,0
80005bc6:	30 07       	mov	r7,0
80005bc8:	fa e7 00 00 	st.d	sp[0],r6
80005bcc:	30 0c       	mov	r12,0
80005bce:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005bd0:	58 08       	cp.w	r8,0
80005bd2:	c0 35       	brlt	80005bd8 <PrintDec+0x1a>
80005bd4:	14 97       	mov	r7,r10
80005bd6:	c0 58       	rjmp	80005be0 <PrintDec+0x22>
	{
		*p++ = '-';
80005bd8:	14 97       	mov	r7,r10
80005bda:	32 d9       	mov	r9,45
80005bdc:	0e c9       	st.b	r7++,r9
		i = -i;
80005bde:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005be0:	58 08       	cp.w	r8,0
80005be2:	c0 51       	brne	80005bec <PrintDec+0x2e>
80005be4:	33 08       	mov	r8,48
80005be6:	ba 88       	st.b	sp[0x0],r8
80005be8:	30 1e       	mov	lr,1
80005bea:	c2 f8       	rjmp	80005c48 <PrintDec+0x8a>
	
	int ten = i%10;
80005bec:	e0 65 66 67 	mov	r5,26215
80005bf0:	ea 15 66 66 	orh	r5,0x6666
80005bf4:	f0 05 04 44 	muls.d	r4,r8,r5
80005bf8:	ea 0c 14 02 	asr	r12,r5,0x2
80005bfc:	f0 09 14 1f 	asr	r9,r8,0x1f
80005c00:	f8 09 01 09 	sub	r9,r12,r9
80005c04:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005c08:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005c0c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005c0e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005c10:	e0 66 66 67 	mov	r6,26215
80005c14:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005c18:	2d 09       	sub	r9,-48
80005c1a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005c1e:	2f fe       	sub	lr,-1
		i /= 10;
80005c20:	f0 06 04 44 	muls.d	r4,r8,r6
80005c24:	ea 09 14 02 	asr	r9,r5,0x2
80005c28:	bf 58       	asr	r8,0x1f
80005c2a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005c2e:	f0 06 04 44 	muls.d	r4,r8,r6
80005c32:	ea 09 14 02 	asr	r9,r5,0x2
80005c36:	f0 05 14 1f 	asr	r5,r8,0x1f
80005c3a:	0a 19       	sub	r9,r5
80005c3c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005c40:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005c44:	58 08       	cp.w	r8,0
80005c46:	ce 91       	brne	80005c18 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005c48:	f6 0e 01 08 	sub	r8,r11,lr
80005c4c:	58 08       	cp.w	r8,0
80005c4e:	e0 89 00 06 	brgt	80005c5a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005c52:	58 0e       	cp.w	lr,0
80005c54:	e0 89 00 14 	brgt	80005c7c <PrintDec+0xbe>
80005c58:	c1 d8       	rjmp	80005c92 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005c5a:	1c 1b       	sub	r11,lr
80005c5c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005c5e:	16 9c       	mov	r12,r11
80005c60:	58 0b       	cp.w	r11,0
80005c62:	fe 9a ff f8 	brle	80005c52 <PrintDec+0x94>
80005c66:	1a 99       	mov	r9,sp
80005c68:	1c 09       	add	r9,lr
80005c6a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005c6c:	33 06       	mov	r6,48
80005c6e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005c70:	2f f8       	sub	r8,-1
80005c72:	18 38       	cp.w	r8,r12
80005c74:	cf d5       	brlt	80005c6e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005c76:	f6 0e 00 0e 	add	lr,r11,lr
80005c7a:	ce cb       	rjmp	80005c52 <PrintDec+0x94>
80005c7c:	fa c8 ff f4 	sub	r8,sp,-12
80005c80:	1c 08       	add	r8,lr
80005c82:	20 d8       	sub	r8,13
80005c84:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005c88:	11 89       	ld.ub	r9,r8[0x0]
80005c8a:	0e c9       	st.b	r7++,r9
80005c8c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005c8e:	16 38       	cp.w	r8,r11
80005c90:	cf c1       	brne	80005c88 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005c92:	14 9c       	mov	r12,r10
80005c94:	2f dd       	sub	sp,-12
80005c96:	d8 22       	popm	r4-r7,pc

80005c98 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005c98:	d4 31       	pushm	r0-r7,lr
80005c9a:	fa cd 02 08 	sub	sp,sp,520
80005c9e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005ca0:	e0 6a 01 00 	mov	r10,256
80005ca4:	30 0b       	mov	r11,0
80005ca6:	fa cc fe f8 	sub	r12,sp,-264
80005caa:	f0 1f 00 4e 	mcall	80005de0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005cae:	fa c4 fd d4 	sub	r4,sp,-556
80005cb2:	30 0a       	mov	r10,0
80005cb4:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005cb6:	fa c3 ff fc 	sub	r3,sp,-4
80005cba:	e0 61 01 00 	mov	r1,256
80005cbe:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005cc0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005cc2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005cc6:	02 9a       	mov	r10,r1
80005cc8:	00 9b       	mov	r11,r0
80005cca:	06 9c       	mov	r12,r3
80005ccc:	f0 1f 00 45 	mcall	80005de0 <log+0x148>
			
					if(*str == '%')
80005cd0:	0f 88       	ld.ub	r8,r7[0x0]
80005cd2:	e4 08 18 00 	cp.b	r8,r2
80005cd6:	c5 71       	brne	80005d84 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005cd8:	ee c8 ff ff 	sub	r8,r7,-1
80005cdc:	11 89       	ld.ub	r9,r8[0x0]
80005cde:	4c 2a       	lddpc	r10,80005de4 <log+0x14c>
80005ce0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005ce2:	23 09       	sub	r9,48
80005ce4:	30 9a       	mov	r10,9
80005ce6:	f4 09 18 00 	cp.b	r9,r10
80005cea:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005cee:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005cf2:	f7 b9 08 30 	subls	r9,48
80005cf6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005cfa:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005cfe:	0f 88       	ld.ub	r8,r7[0x0]
80005d00:	22 58       	sub	r8,37
80005d02:	e0 48 00 53 	cp.w	r8,83
80005d06:	e0 8b 00 31 	brhi	80005d68 <log+0xd0>
80005d0a:	4b 89       	lddpc	r9,80005de8 <log+0x150>
80005d0c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005d10:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005d14:	06 9a       	mov	r10,r3
80005d16:	40 0b       	lddsp	r11,sp[0x0]
80005d18:	5c 5b       	castu.b	r11
80005d1a:	68 0c       	ld.w	r12,r4[0x0]
80005d1c:	f0 1f 00 34 	mcall	80005dec <log+0x154>
							break;
80005d20:	c2 98       	rjmp	80005d72 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005d22:	4b 4c       	lddpc	r12,80005df0 <log+0x158>
80005d24:	f0 1f 00 34 	mcall	80005df4 <log+0x15c>
80005d28:	08 95       	mov	r5,r4
80005d2a:	06 9c       	mov	r12,r3
							break;
80005d2c:	c2 38       	rjmp	80005d72 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005d2e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005d32:	06 9a       	mov	r10,r3
80005d34:	40 0b       	lddsp	r11,sp[0x0]
80005d36:	5c 5b       	castu.b	r11
80005d38:	68 0c       	ld.w	r12,r4[0x0]
80005d3a:	f0 1f 00 30 	mcall	80005df8 <log+0x160>
80005d3e:	06 9c       	mov	r12,r3
							break;
80005d40:	c1 98       	rjmp	80005d72 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005d42:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005d46:	06 9b       	mov	r11,r3
80005d48:	09 bc       	ld.ub	r12,r4[0x3]
80005d4a:	f0 1f 00 2d 	mcall	80005dfc <log+0x164>
80005d4e:	06 9c       	mov	r12,r3
							break;
80005d50:	c1 18       	rjmp	80005d72 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005d52:	e8 c5 ff fc 	sub	r5,r4,-4
80005d56:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005d58:	c0 d8       	rjmp	80005d72 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005d5a:	06 9b       	mov	r11,r3
80005d5c:	32 5c       	mov	r12,37
80005d5e:	f0 1f 00 28 	mcall	80005dfc <log+0x164>
80005d62:	08 95       	mov	r5,r4
80005d64:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005d66:	c0 68       	rjmp	80005d72 <log+0xda>
							
							default:
							log("I need relax.");
80005d68:	4a 6c       	lddpc	r12,80005e00 <log+0x168>
80005d6a:	f0 1f 00 23 	mcall	80005df4 <log+0x15c>
80005d6e:	08 95       	mov	r5,r4
80005d70:	06 9c       	mov	r12,r3
						}
						str++;
80005d72:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005d74:	1a dc       	st.w	--sp,r12
80005d76:	1a d6       	st.w	--sp,r6
80005d78:	4a 3b       	lddpc	r11,80005e04 <log+0x16c>
80005d7a:	0c 9c       	mov	r12,r6
80005d7c:	f0 1f 00 23 	mcall	80005e08 <log+0x170>
80005d80:	2f ed       	sub	sp,-8
80005d82:	c0 a8       	rjmp	80005d96 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005d84:	2f f7       	sub	r7,-1
80005d86:	1a d8       	st.w	--sp,r8
80005d88:	1a d6       	st.w	--sp,r6
80005d8a:	4a 1b       	lddpc	r11,80005e0c <log+0x174>
80005d8c:	0c 9c       	mov	r12,r6
80005d8e:	f0 1f 00 1f 	mcall	80005e08 <log+0x170>
80005d92:	08 95       	mov	r5,r4
80005d94:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005d96:	0f 89       	ld.ub	r9,r7[0x0]
80005d98:	30 08       	mov	r8,0
80005d9a:	f0 09 18 00 	cp.b	r9,r8
80005d9e:	c0 30       	breq	80005da4 <log+0x10c>
80005da0:	0a 94       	mov	r4,r5
80005da2:	c9 2b       	rjmp	80005cc6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005da4:	fa c7 fe f8 	sub	r7,sp,-264
80005da8:	1a d7       	st.w	--sp,r7
80005daa:	49 ab       	lddpc	r11,80005e10 <log+0x178>
80005dac:	0e 9c       	mov	r12,r7
80005dae:	f0 1f 00 17 	mcall	80005e08 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005db2:	5c 5c       	castu.b	r12
80005db4:	f8 c6 ff ff 	sub	r6,r12,-1
80005db8:	0c 9c       	mov	r12,r6
80005dba:	f0 1f 00 17 	mcall	80005e14 <log+0x17c>
80005dbe:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005dc0:	0c 9a       	mov	r10,r6
80005dc2:	0e 9b       	mov	r11,r7
80005dc4:	f0 1f 00 15 	mcall	80005e18 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80005dc8:	30 09       	mov	r9,0
80005dca:	30 5a       	mov	r10,5
80005dcc:	fa cb fe f8 	sub	r11,sp,-264
80005dd0:	49 38       	lddpc	r8,80005e1c <log+0x184>
80005dd2:	70 0c       	ld.w	r12,r8[0x0]
80005dd4:	f0 1f 00 13 	mcall	80005e20 <log+0x188>
80005dd8:	2f fd       	sub	sp,-4
	
	
}
80005dda:	fe 3d fd f8 	sub	sp,-520
80005dde:	d8 32       	popm	r0-r7,pc
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	66 50       	ld.w	r0,r3[0x14]
80005de4:	00 00       	add	r0,r0
80005de6:	0d 28       	ld.uh	r8,r6++
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	c4 00       	breq	80005e6a <logFromISR+0x46>
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	5b be       	cp.w	lr,-5
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	c6 ac       	rcall	80005ec6 <logFromISR+0xa2>
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	5c 98       	brev	r8
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	5b 0c       	cp.w	r12,-16
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	5b 08       	cp.w	r8,-16
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	c6 bc       	rcall	80005ed8 <logFromISR+0xb4>
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	c6 cc       	rcall	80005ede <logFromISR+0xba>
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	69 40       	ld.w	r0,r4[0x50]
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	c6 d4       	brge	80005ee8 <logFromISR+0xc4>
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	c6 dc       	rcall	80005eec <logFromISR+0xc8>
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	4d ac       	lddpc	r12,80005f7c <logFromISR+0x158>
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	65 08       	ld.w	r8,r2[0x40]
80005e1c:	00 00       	add	r0,r0
80005e1e:	40 e0       	lddsp	r0,sp[0x38]
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	51 00       	stdsp	sp[0x40],r0

80005e24 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005e24:	d4 31       	pushm	r0-r7,lr
80005e26:	fa cd 02 0c 	sub	sp,sp,524
80005e2a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80005e2c:	e0 6a 01 00 	mov	r10,256
80005e30:	30 0b       	mov	r11,0
80005e32:	fa cc fe f4 	sub	r12,sp,-268
80005e36:	f0 1f 00 4c 	mcall	80005f64 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80005e3a:	fa c4 fd d0 	sub	r4,sp,-560
80005e3e:	30 0a       	mov	r10,0
80005e40:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005e42:	fa c3 ff fc 	sub	r3,sp,-4
80005e46:	e0 61 01 00 	mov	r1,256
80005e4a:	14 90       	mov	r0,r10
			
			if(*str == '%')
80005e4c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005e4e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005e52:	02 9a       	mov	r10,r1
80005e54:	00 9b       	mov	r11,r0
80005e56:	06 9c       	mov	r12,r3
80005e58:	f0 1f 00 43 	mcall	80005f64 <logFromISR+0x140>
			
			if(*str == '%')
80005e5c:	0f 88       	ld.ub	r8,r7[0x0]
80005e5e:	e4 08 18 00 	cp.b	r8,r2
80005e62:	c5 11       	brne	80005f04 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80005e64:	ee c8 ff ff 	sub	r8,r7,-1
80005e68:	11 89       	ld.ub	r9,r8[0x0]
80005e6a:	4c 0a       	lddpc	r10,80005f68 <logFromISR+0x144>
80005e6c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80005e6e:	23 09       	sub	r9,48
80005e70:	30 9a       	mov	r10,9
80005e72:	f4 09 18 00 	cp.b	r9,r10
80005e76:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80005e7a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005e7e:	f7 b9 08 30 	subls	r9,48
80005e82:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80005e86:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80005e8a:	0f 88       	ld.ub	r8,r7[0x0]
80005e8c:	22 58       	sub	r8,37
80005e8e:	e0 48 00 53 	cp.w	r8,83
80005e92:	e0 8b 00 2b 	brhi	80005ee8 <logFromISR+0xc4>
80005e96:	4b 69       	lddpc	r9,80005f6c <logFromISR+0x148>
80005e98:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80005e9c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005ea0:	06 9a       	mov	r10,r3
80005ea2:	40 0b       	lddsp	r11,sp[0x0]
80005ea4:	5c 5b       	castu.b	r11
80005ea6:	68 0c       	ld.w	r12,r4[0x0]
80005ea8:	f0 1f 00 32 	mcall	80005f70 <logFromISR+0x14c>
					break;
80005eac:	c2 38       	rjmp	80005ef2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80005eae:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005eb2:	06 9a       	mov	r10,r3
80005eb4:	40 0b       	lddsp	r11,sp[0x0]
80005eb6:	5c 5b       	castu.b	r11
80005eb8:	68 0c       	ld.w	r12,r4[0x0]
80005eba:	f0 1f 00 2f 	mcall	80005f74 <logFromISR+0x150>
80005ebe:	06 9c       	mov	r12,r3
					break;
80005ec0:	c1 98       	rjmp	80005ef2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005ec2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005ec6:	06 9b       	mov	r11,r3
80005ec8:	09 bc       	ld.ub	r12,r4[0x3]
80005eca:	f0 1f 00 2c 	mcall	80005f78 <logFromISR+0x154>
80005ece:	06 9c       	mov	r12,r3
					break;
80005ed0:	c1 18       	rjmp	80005ef2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005ed2:	e8 c5 ff fc 	sub	r5,r4,-4
80005ed6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005ed8:	c0 d8       	rjmp	80005ef2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80005eda:	06 9b       	mov	r11,r3
80005edc:	32 5c       	mov	r12,37
80005ede:	f0 1f 00 27 	mcall	80005f78 <logFromISR+0x154>
80005ee2:	08 95       	mov	r5,r4
80005ee4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005ee6:	c0 68       	rjmp	80005ef2 <logFromISR+0xce>
					default:
					log("I need relax.");
80005ee8:	4a 5c       	lddpc	r12,80005f7c <logFromISR+0x158>
80005eea:	f0 1f 00 26 	mcall	80005f80 <logFromISR+0x15c>
80005eee:	08 95       	mov	r5,r4
80005ef0:	06 9c       	mov	r12,r3
				}
				str++;
80005ef2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005ef4:	1a dc       	st.w	--sp,r12
80005ef6:	1a d6       	st.w	--sp,r6
80005ef8:	4a 3b       	lddpc	r11,80005f84 <logFromISR+0x160>
80005efa:	0c 9c       	mov	r12,r6
80005efc:	f0 1f 00 23 	mcall	80005f88 <logFromISR+0x164>
80005f00:	2f ed       	sub	sp,-8
80005f02:	c0 a8       	rjmp	80005f16 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005f04:	2f f7       	sub	r7,-1
80005f06:	1a d8       	st.w	--sp,r8
80005f08:	1a d6       	st.w	--sp,r6
80005f0a:	4a 1b       	lddpc	r11,80005f8c <logFromISR+0x168>
80005f0c:	0c 9c       	mov	r12,r6
80005f0e:	f0 1f 00 1f 	mcall	80005f88 <logFromISR+0x164>
80005f12:	08 95       	mov	r5,r4
80005f14:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005f16:	0f 89       	ld.ub	r9,r7[0x0]
80005f18:	30 08       	mov	r8,0
80005f1a:	f0 09 18 00 	cp.b	r9,r8
80005f1e:	c0 30       	breq	80005f24 <logFromISR+0x100>
80005f20:	0a 94       	mov	r4,r5
80005f22:	c9 8b       	rjmp	80005e52 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005f24:	fa c7 fe f4 	sub	r7,sp,-268
80005f28:	1a d7       	st.w	--sp,r7
80005f2a:	49 ab       	lddpc	r11,80005f90 <logFromISR+0x16c>
80005f2c:	0e 9c       	mov	r12,r7
80005f2e:	f0 1f 00 17 	mcall	80005f88 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80005f32:	5c 5c       	castu.b	r12
80005f34:	f8 c6 ff ff 	sub	r6,r12,-1
80005f38:	0c 9c       	mov	r12,r6
80005f3a:	f0 1f 00 17 	mcall	80005f94 <logFromISR+0x170>
80005f3e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80005f40:	0c 9a       	mov	r10,r6
80005f42:	0e 9b       	mov	r11,r7
80005f44:	f0 1f 00 15 	mcall	80005f98 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005f48:	30 09       	mov	r9,0
80005f4a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80005f4c:	fa ca fe f8 	sub	r10,sp,-264
80005f50:	fa cb fe f4 	sub	r11,sp,-268
80005f54:	49 28       	lddpc	r8,80005f9c <logFromISR+0x178>
80005f56:	70 0c       	ld.w	r12,r8[0x0]
80005f58:	f0 1f 00 12 	mcall	80005fa0 <logFromISR+0x17c>
80005f5c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80005f5e:	fe 3d fd f4 	sub	sp,-524
80005f62:	d8 32       	popm	r0-r7,pc
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	66 50       	ld.w	r0,r3[0x14]
80005f68:	00 00       	add	r0,r0
80005f6a:	0d 29       	ld.uh	r9,r6++
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	c5 50       	breq	80006018 <task_log+0xc>
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5b be       	cp.w	lr,-5
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	5b 0c       	cp.w	r12,-16
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5b 08       	cp.w	r8,-16
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	c6 bc       	rcall	80006054 <main+0x4>
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	5c 98       	brev	r8
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	c6 cc       	rcall	8000605e <main+0xe>
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	69 40       	ld.w	r0,r4[0x50]
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	c6 d4       	brge	80006068 <main+0x18>
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	c6 dc       	rcall	8000606c <main+0x1c>
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	4d ac       	lddpc	r12,800060fc <_malloc_r+0x2c>
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	65 08       	ld.w	r8,r2[0x40]
80005f9c:	00 00       	add	r0,r0
80005f9e:	40 e0       	lddsp	r0,sp[0x38]
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	50 b0       	stdsp	sp[0x2c],r0

80005fa4 <log_init>:
		
	return str;
}

void log_init(void)
{
80005fa4:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005fa6:	30 2b       	mov	r11,2
80005fa8:	49 0c       	lddpc	r12,80005fe8 <log_init+0x44>
80005faa:	f0 1f 00 11 	mcall	80005fec <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005fae:	e0 6a 36 00 	mov	r10,13824
80005fb2:	ea 1a 01 6e 	orh	r10,0x16e
80005fb6:	48 fb       	lddpc	r11,80005ff0 <log_init+0x4c>
80005fb8:	fe 7c 18 00 	mov	r12,-59392
80005fbc:	f0 1f 00 0e 	mcall	80005ff4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005fc0:	30 4b       	mov	r11,4
80005fc2:	33 2c       	mov	r12,50
80005fc4:	f0 1f 00 0d 	mcall	80005ff8 <log_init+0x54>
80005fc8:	48 d8       	lddpc	r8,80005ffc <log_init+0x58>
80005fca:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005fcc:	30 09       	mov	r9,0
80005fce:	1a d9       	st.w	--sp,r9
80005fd0:	1a d9       	st.w	--sp,r9
80005fd2:	1a d9       	st.w	--sp,r9
80005fd4:	30 28       	mov	r8,2
80005fd6:	e0 6a 01 80 	mov	r10,384
80005fda:	48 ab       	lddpc	r11,80006000 <log_init+0x5c>
80005fdc:	48 ac       	lddpc	r12,80006004 <log_init+0x60>
80005fde:	f0 1f 00 0b 	mcall	80006008 <log_init+0x64>
80005fe2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005fe4:	d8 02       	popm	pc
80005fe6:	00 00       	add	r0,r0
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	c6 e8       	rjmp	800060c6 <malloc+0x6>
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	46 94       	lddsp	r4,sp[0x1a4]
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	c6 a0       	breq	800060c6 <malloc+0x6>
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	49 10       	lddpc	r0,80006038 <task_log+0x2c>
80005ff8:	80 00       	ld.sh	r0,r0[0x0]
80005ffa:	52 00       	stdsp	sp[0x80],r0
80005ffc:	00 00       	add	r0,r0
80005ffe:	40 e0       	lddsp	r0,sp[0x38]
80006000:	80 00       	ld.sh	r0,r0[0x0]
80006002:	c6 e4       	brge	800060de <_malloc_r+0xe>
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	60 0c       	ld.w	r12,r0[0x0]
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	58 d4       	cp.w	r4,13

8000600c <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000600c:	eb cd 40 f8 	pushm	r3-r7,lr
80006010:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006012:	48 c7       	lddpc	r7,80006040 <task_log+0x34>
80006014:	30 05       	mov	r5,0
80006016:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006018:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000601c:	0a 99       	mov	r9,r5
8000601e:	08 9a       	mov	r10,r4
80006020:	1a 9b       	mov	r11,sp
80006022:	6e 0c       	ld.w	r12,r7[0x0]
80006024:	f0 1f 00 08 	mcall	80006044 <task_log+0x38>
80006028:	58 1c       	cp.w	r12,1
8000602a:	cf 91       	brne	8000601c <task_log+0x10>
		{
			if( NULL != str)
8000602c:	40 0b       	lddsp	r11,sp[0x0]
8000602e:	58 0b       	cp.w	r11,0
80006030:	cf 60       	breq	8000601c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006032:	06 9c       	mov	r12,r3
80006034:	f0 1f 00 05 	mcall	80006048 <task_log+0x3c>
				vPortFree(str);
80006038:	40 0c       	lddsp	r12,sp[0x0]
8000603a:	f0 1f 00 05 	mcall	8000604c <task_log+0x40>
8000603e:	ce fb       	rjmp	8000601c <task_log+0x10>
80006040:	00 00       	add	r0,r0
80006042:	40 e0       	lddsp	r0,sp[0x38]
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	4e f4       	lddpc	r4,80006200 <_malloc_r+0x130>
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	48 c0       	lddpc	r0,80006078 <main+0x28>
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	4d 84       	lddpc	r4,800061ac <_malloc_r+0xdc>

80006050 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006050:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006052:	fe 78 10 00 	mov	r8,-61440
80006056:	30 19       	mov	r9,1
80006058:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000605c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006060:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006064:	d3 03       	ssrf	0x10
	local_start_pll0();
80006066:	f0 1f 00 0a 	mcall	8000608c <main+0x3c>
		
	INTC_init_interrupts();
8000606a:	f0 1f 00 0a 	mcall	80006090 <main+0x40>
		
	log_init();
8000606e:	f0 1f 00 0a 	mcall	80006094 <main+0x44>
	log("----start debug----");
80006072:	48 ac       	lddpc	r12,80006098 <main+0x48>
80006074:	f0 1f 00 0a 	mcall	8000609c <main+0x4c>

	//tc_init();
	
	//rfid_init();
		
	app_init();
80006078:	f0 1f 00 0a 	mcall	800060a0 <main+0x50>
		
	xcmp_init();
8000607c:	f0 1f 00 0a 	mcall	800060a4 <main+0x54>
	
	//while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
	//while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
	local_start_timer();
80006080:	f0 1f 00 0a 	mcall	800060a8 <main+0x58>
		
	//Enable_global_interrupt();
		
	vTaskStartScheduler();
80006084:	f0 1f 00 0a 	mcall	800060ac <main+0x5c>
	return 0;
	
}
80006088:	d8 0a       	popm	pc,r12=0
8000608a:	00 00       	add	r0,r0
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	45 c4       	lddsp	r4,sp[0x170]
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	47 48       	lddsp	r8,sp[0x1d0]
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	5f a4       	srle	r4
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	c6 f8       	rjmp	80006178 <_malloc_r+0xa8>
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	5c 98       	brev	r8
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	20 3c       	sub	r12,3
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	3e 48       	mov	r8,-28
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	46 14       	lddsp	r4,sp[0x184]
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	5a bc       	cp.w	r12,-21

800060b0 <free>:
800060b0:	d4 01       	pushm	lr
800060b2:	e0 68 0a 2c 	mov	r8,2604
800060b6:	18 9b       	mov	r11,r12
800060b8:	70 0c       	ld.w	r12,r8[0x0]
800060ba:	e0 a0 1e 61 	rcall	80009d7c <_free_r>
800060be:	d8 02       	popm	pc

800060c0 <malloc>:
800060c0:	d4 01       	pushm	lr
800060c2:	e0 68 0a 2c 	mov	r8,2604
800060c6:	18 9b       	mov	r11,r12
800060c8:	70 0c       	ld.w	r12,r8[0x0]
800060ca:	c0 3c       	rcall	800060d0 <_malloc_r>
800060cc:	d8 02       	popm	pc
800060ce:	d7 03       	nop

800060d0 <_malloc_r>:
800060d0:	d4 31       	pushm	r0-r7,lr
800060d2:	f6 c8 ff f5 	sub	r8,r11,-11
800060d6:	18 95       	mov	r5,r12
800060d8:	10 97       	mov	r7,r8
800060da:	e0 17 ff f8 	andl	r7,0xfff8
800060de:	59 68       	cp.w	r8,22
800060e0:	f9 b7 08 10 	movls	r7,16
800060e4:	16 37       	cp.w	r7,r11
800060e6:	5f 38       	srlo	r8
800060e8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800060ec:	c0 50       	breq	800060f6 <_malloc_r+0x26>
800060ee:	30 c8       	mov	r8,12
800060f0:	99 38       	st.w	r12[0xc],r8
800060f2:	e0 8f 01 fa 	bral	800064e6 <_malloc_r+0x416>
800060f6:	fe b0 f5 fd 	rcall	80004cf0 <__malloc_lock>
800060fa:	e0 47 01 f7 	cp.w	r7,503
800060fe:	e0 8b 00 1d 	brhi	80006138 <_malloc_r+0x68>
80006102:	ee 03 16 03 	lsr	r3,r7,0x3
80006106:	e0 68 05 2c 	mov	r8,1324
8000610a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000610e:	70 36       	ld.w	r6,r8[0xc]
80006110:	10 36       	cp.w	r6,r8
80006112:	c0 61       	brne	8000611e <_malloc_r+0x4e>
80006114:	ec c8 ff f8 	sub	r8,r6,-8
80006118:	70 36       	ld.w	r6,r8[0xc]
8000611a:	10 36       	cp.w	r6,r8
8000611c:	c0 c0       	breq	80006134 <_malloc_r+0x64>
8000611e:	6c 18       	ld.w	r8,r6[0x4]
80006120:	e0 18 ff fc 	andl	r8,0xfffc
80006124:	6c 3a       	ld.w	r10,r6[0xc]
80006126:	ec 08 00 09 	add	r9,r6,r8
8000612a:	0a 9c       	mov	r12,r5
8000612c:	6c 28       	ld.w	r8,r6[0x8]
8000612e:	95 28       	st.w	r10[0x8],r8
80006130:	91 3a       	st.w	r8[0xc],r10
80006132:	c4 78       	rjmp	800061c0 <_malloc_r+0xf0>
80006134:	2f e3       	sub	r3,-2
80006136:	c4 d8       	rjmp	800061d0 <_malloc_r+0x100>
80006138:	ee 03 16 09 	lsr	r3,r7,0x9
8000613c:	c0 41       	brne	80006144 <_malloc_r+0x74>
8000613e:	ee 03 16 03 	lsr	r3,r7,0x3
80006142:	c2 68       	rjmp	8000618e <_malloc_r+0xbe>
80006144:	58 43       	cp.w	r3,4
80006146:	e0 8b 00 06 	brhi	80006152 <_malloc_r+0x82>
8000614a:	ee 03 16 06 	lsr	r3,r7,0x6
8000614e:	2c 83       	sub	r3,-56
80006150:	c1 f8       	rjmp	8000618e <_malloc_r+0xbe>
80006152:	59 43       	cp.w	r3,20
80006154:	e0 8b 00 04 	brhi	8000615c <_malloc_r+0x8c>
80006158:	2a 53       	sub	r3,-91
8000615a:	c1 a8       	rjmp	8000618e <_malloc_r+0xbe>
8000615c:	e0 43 00 54 	cp.w	r3,84
80006160:	e0 8b 00 06 	brhi	8000616c <_malloc_r+0x9c>
80006164:	ee 03 16 0c 	lsr	r3,r7,0xc
80006168:	29 23       	sub	r3,-110
8000616a:	c1 28       	rjmp	8000618e <_malloc_r+0xbe>
8000616c:	e0 43 01 54 	cp.w	r3,340
80006170:	e0 8b 00 06 	brhi	8000617c <_malloc_r+0xac>
80006174:	ee 03 16 0f 	lsr	r3,r7,0xf
80006178:	28 93       	sub	r3,-119
8000617a:	c0 a8       	rjmp	8000618e <_malloc_r+0xbe>
8000617c:	e0 43 05 54 	cp.w	r3,1364
80006180:	e0 88 00 04 	brls	80006188 <_malloc_r+0xb8>
80006184:	37 e3       	mov	r3,126
80006186:	c0 48       	rjmp	8000618e <_malloc_r+0xbe>
80006188:	ee 03 16 12 	lsr	r3,r7,0x12
8000618c:	28 43       	sub	r3,-124
8000618e:	e0 6a 05 2c 	mov	r10,1324
80006192:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006196:	74 36       	ld.w	r6,r10[0xc]
80006198:	c1 98       	rjmp	800061ca <_malloc_r+0xfa>
8000619a:	6c 19       	ld.w	r9,r6[0x4]
8000619c:	e0 19 ff fc 	andl	r9,0xfffc
800061a0:	f2 07 01 0b 	sub	r11,r9,r7
800061a4:	58 fb       	cp.w	r11,15
800061a6:	e0 8a 00 04 	brle	800061ae <_malloc_r+0xde>
800061aa:	20 13       	sub	r3,1
800061ac:	c1 18       	rjmp	800061ce <_malloc_r+0xfe>
800061ae:	6c 38       	ld.w	r8,r6[0xc]
800061b0:	58 0b       	cp.w	r11,0
800061b2:	c0 b5       	brlt	800061c8 <_malloc_r+0xf8>
800061b4:	6c 2a       	ld.w	r10,r6[0x8]
800061b6:	ec 09 00 09 	add	r9,r6,r9
800061ba:	0a 9c       	mov	r12,r5
800061bc:	91 2a       	st.w	r8[0x8],r10
800061be:	95 38       	st.w	r10[0xc],r8
800061c0:	72 18       	ld.w	r8,r9[0x4]
800061c2:	a1 a8       	sbr	r8,0x0
800061c4:	93 18       	st.w	r9[0x4],r8
800061c6:	cb c8       	rjmp	8000633e <_malloc_r+0x26e>
800061c8:	10 96       	mov	r6,r8
800061ca:	14 36       	cp.w	r6,r10
800061cc:	ce 71       	brne	8000619a <_malloc_r+0xca>
800061ce:	2f f3       	sub	r3,-1
800061d0:	e0 6a 05 2c 	mov	r10,1324
800061d4:	f4 cc ff f8 	sub	r12,r10,-8
800061d8:	78 26       	ld.w	r6,r12[0x8]
800061da:	18 36       	cp.w	r6,r12
800061dc:	c6 c0       	breq	800062b4 <_malloc_r+0x1e4>
800061de:	6c 19       	ld.w	r9,r6[0x4]
800061e0:	e0 19 ff fc 	andl	r9,0xfffc
800061e4:	f2 07 01 08 	sub	r8,r9,r7
800061e8:	58 f8       	cp.w	r8,15
800061ea:	e0 89 00 8f 	brgt	80006308 <_malloc_r+0x238>
800061ee:	99 3c       	st.w	r12[0xc],r12
800061f0:	99 2c       	st.w	r12[0x8],r12
800061f2:	58 08       	cp.w	r8,0
800061f4:	c0 55       	brlt	800061fe <_malloc_r+0x12e>
800061f6:	ec 09 00 09 	add	r9,r6,r9
800061fa:	0a 9c       	mov	r12,r5
800061fc:	ce 2b       	rjmp	800061c0 <_malloc_r+0xf0>
800061fe:	e0 49 01 ff 	cp.w	r9,511
80006202:	e0 8b 00 13 	brhi	80006228 <_malloc_r+0x158>
80006206:	a3 99       	lsr	r9,0x3
80006208:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000620c:	70 2b       	ld.w	r11,r8[0x8]
8000620e:	8d 38       	st.w	r6[0xc],r8
80006210:	8d 2b       	st.w	r6[0x8],r11
80006212:	97 36       	st.w	r11[0xc],r6
80006214:	91 26       	st.w	r8[0x8],r6
80006216:	a3 49       	asr	r9,0x2
80006218:	74 18       	ld.w	r8,r10[0x4]
8000621a:	30 1b       	mov	r11,1
8000621c:	f6 09 09 49 	lsl	r9,r11,r9
80006220:	f1 e9 10 09 	or	r9,r8,r9
80006224:	95 19       	st.w	r10[0x4],r9
80006226:	c4 78       	rjmp	800062b4 <_malloc_r+0x1e4>
80006228:	f2 0a 16 09 	lsr	r10,r9,0x9
8000622c:	58 4a       	cp.w	r10,4
8000622e:	e0 8b 00 07 	brhi	8000623c <_malloc_r+0x16c>
80006232:	f2 0a 16 06 	lsr	r10,r9,0x6
80006236:	2c 8a       	sub	r10,-56
80006238:	c2 08       	rjmp	80006278 <_malloc_r+0x1a8>
8000623a:	d7 03       	nop
8000623c:	59 4a       	cp.w	r10,20
8000623e:	e0 8b 00 04 	brhi	80006246 <_malloc_r+0x176>
80006242:	2a 5a       	sub	r10,-91
80006244:	c1 a8       	rjmp	80006278 <_malloc_r+0x1a8>
80006246:	e0 4a 00 54 	cp.w	r10,84
8000624a:	e0 8b 00 06 	brhi	80006256 <_malloc_r+0x186>
8000624e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006252:	29 2a       	sub	r10,-110
80006254:	c1 28       	rjmp	80006278 <_malloc_r+0x1a8>
80006256:	e0 4a 01 54 	cp.w	r10,340
8000625a:	e0 8b 00 06 	brhi	80006266 <_malloc_r+0x196>
8000625e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006262:	28 9a       	sub	r10,-119
80006264:	c0 a8       	rjmp	80006278 <_malloc_r+0x1a8>
80006266:	e0 4a 05 54 	cp.w	r10,1364
8000626a:	e0 88 00 04 	brls	80006272 <_malloc_r+0x1a2>
8000626e:	37 ea       	mov	r10,126
80006270:	c0 48       	rjmp	80006278 <_malloc_r+0x1a8>
80006272:	f2 0a 16 12 	lsr	r10,r9,0x12
80006276:	28 4a       	sub	r10,-124
80006278:	e0 6b 05 2c 	mov	r11,1324
8000627c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006280:	68 28       	ld.w	r8,r4[0x8]
80006282:	08 38       	cp.w	r8,r4
80006284:	c0 e1       	brne	800062a0 <_malloc_r+0x1d0>
80006286:	76 19       	ld.w	r9,r11[0x4]
80006288:	a3 4a       	asr	r10,0x2
8000628a:	30 1e       	mov	lr,1
8000628c:	fc 0a 09 4a 	lsl	r10,lr,r10
80006290:	f3 ea 10 0a 	or	r10,r9,r10
80006294:	10 99       	mov	r9,r8
80006296:	97 1a       	st.w	r11[0x4],r10
80006298:	c0 a8       	rjmp	800062ac <_malloc_r+0x1dc>
8000629a:	70 28       	ld.w	r8,r8[0x8]
8000629c:	08 38       	cp.w	r8,r4
8000629e:	c0 60       	breq	800062aa <_malloc_r+0x1da>
800062a0:	70 1a       	ld.w	r10,r8[0x4]
800062a2:	e0 1a ff fc 	andl	r10,0xfffc
800062a6:	14 39       	cp.w	r9,r10
800062a8:	cf 93       	brcs	8000629a <_malloc_r+0x1ca>
800062aa:	70 39       	ld.w	r9,r8[0xc]
800062ac:	8d 39       	st.w	r6[0xc],r9
800062ae:	8d 28       	st.w	r6[0x8],r8
800062b0:	91 36       	st.w	r8[0xc],r6
800062b2:	93 26       	st.w	r9[0x8],r6
800062b4:	e6 08 14 02 	asr	r8,r3,0x2
800062b8:	30 1b       	mov	r11,1
800062ba:	e0 64 05 2c 	mov	r4,1324
800062be:	f6 08 09 4b 	lsl	r11,r11,r8
800062c2:	68 18       	ld.w	r8,r4[0x4]
800062c4:	10 3b       	cp.w	r11,r8
800062c6:	e0 8b 00 6b 	brhi	8000639c <_malloc_r+0x2cc>
800062ca:	f7 e8 00 09 	and	r9,r11,r8
800062ce:	c0 b1       	brne	800062e4 <_malloc_r+0x214>
800062d0:	e0 13 ff fc 	andl	r3,0xfffc
800062d4:	a1 7b       	lsl	r11,0x1
800062d6:	2f c3       	sub	r3,-4
800062d8:	c0 38       	rjmp	800062de <_malloc_r+0x20e>
800062da:	2f c3       	sub	r3,-4
800062dc:	a1 7b       	lsl	r11,0x1
800062de:	f7 e8 00 09 	and	r9,r11,r8
800062e2:	cf c0       	breq	800062da <_malloc_r+0x20a>
800062e4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800062e8:	06 92       	mov	r2,r3
800062ea:	1c 91       	mov	r1,lr
800062ec:	62 36       	ld.w	r6,r1[0xc]
800062ee:	c2 e8       	rjmp	8000634a <_malloc_r+0x27a>
800062f0:	6c 1a       	ld.w	r10,r6[0x4]
800062f2:	e0 1a ff fc 	andl	r10,0xfffc
800062f6:	f4 07 01 08 	sub	r8,r10,r7
800062fa:	58 f8       	cp.w	r8,15
800062fc:	e0 8a 00 15 	brle	80006326 <_malloc_r+0x256>
80006300:	6c 3a       	ld.w	r10,r6[0xc]
80006302:	6c 29       	ld.w	r9,r6[0x8]
80006304:	95 29       	st.w	r10[0x8],r9
80006306:	93 3a       	st.w	r9[0xc],r10
80006308:	0e 99       	mov	r9,r7
8000630a:	ec 07 00 07 	add	r7,r6,r7
8000630e:	a1 a9       	sbr	r9,0x0
80006310:	99 37       	st.w	r12[0xc],r7
80006312:	99 27       	st.w	r12[0x8],r7
80006314:	8d 19       	st.w	r6[0x4],r9
80006316:	ee 08 09 08 	st.w	r7[r8],r8
8000631a:	8f 2c       	st.w	r7[0x8],r12
8000631c:	8f 3c       	st.w	r7[0xc],r12
8000631e:	a1 a8       	sbr	r8,0x0
80006320:	0a 9c       	mov	r12,r5
80006322:	8f 18       	st.w	r7[0x4],r8
80006324:	c0 d8       	rjmp	8000633e <_malloc_r+0x26e>
80006326:	6c 39       	ld.w	r9,r6[0xc]
80006328:	58 08       	cp.w	r8,0
8000632a:	c0 f5       	brlt	80006348 <_malloc_r+0x278>
8000632c:	ec 0a 00 0a 	add	r10,r6,r10
80006330:	74 18       	ld.w	r8,r10[0x4]
80006332:	a1 a8       	sbr	r8,0x0
80006334:	0a 9c       	mov	r12,r5
80006336:	95 18       	st.w	r10[0x4],r8
80006338:	6c 28       	ld.w	r8,r6[0x8]
8000633a:	93 28       	st.w	r9[0x8],r8
8000633c:	91 39       	st.w	r8[0xc],r9
8000633e:	fe b0 f4 df 	rcall	80004cfc <__malloc_unlock>
80006342:	ec cc ff f8 	sub	r12,r6,-8
80006346:	d8 32       	popm	r0-r7,pc
80006348:	12 96       	mov	r6,r9
8000634a:	02 36       	cp.w	r6,r1
8000634c:	cd 21       	brne	800062f0 <_malloc_r+0x220>
8000634e:	2f f2       	sub	r2,-1
80006350:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006354:	c0 30       	breq	8000635a <_malloc_r+0x28a>
80006356:	2f 81       	sub	r1,-8
80006358:	cc ab       	rjmp	800062ec <_malloc_r+0x21c>
8000635a:	1c 98       	mov	r8,lr
8000635c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006360:	c0 81       	brne	80006370 <_malloc_r+0x2a0>
80006362:	68 19       	ld.w	r9,r4[0x4]
80006364:	f6 08 11 ff 	rsub	r8,r11,-1
80006368:	f3 e8 00 08 	and	r8,r9,r8
8000636c:	89 18       	st.w	r4[0x4],r8
8000636e:	c0 78       	rjmp	8000637c <_malloc_r+0x2ac>
80006370:	f0 c9 00 08 	sub	r9,r8,8
80006374:	20 13       	sub	r3,1
80006376:	70 08       	ld.w	r8,r8[0x0]
80006378:	12 38       	cp.w	r8,r9
8000637a:	cf 10       	breq	8000635c <_malloc_r+0x28c>
8000637c:	a1 7b       	lsl	r11,0x1
8000637e:	68 18       	ld.w	r8,r4[0x4]
80006380:	10 3b       	cp.w	r11,r8
80006382:	e0 8b 00 0d 	brhi	8000639c <_malloc_r+0x2cc>
80006386:	58 0b       	cp.w	r11,0
80006388:	c0 a0       	breq	8000639c <_malloc_r+0x2cc>
8000638a:	04 93       	mov	r3,r2
8000638c:	c0 38       	rjmp	80006392 <_malloc_r+0x2c2>
8000638e:	2f c3       	sub	r3,-4
80006390:	a1 7b       	lsl	r11,0x1
80006392:	f7 e8 00 09 	and	r9,r11,r8
80006396:	ca 71       	brne	800062e4 <_malloc_r+0x214>
80006398:	cf bb       	rjmp	8000638e <_malloc_r+0x2be>
8000639a:	d7 03       	nop
8000639c:	68 23       	ld.w	r3,r4[0x8]
8000639e:	66 12       	ld.w	r2,r3[0x4]
800063a0:	e0 12 ff fc 	andl	r2,0xfffc
800063a4:	0e 32       	cp.w	r2,r7
800063a6:	5f 39       	srlo	r9
800063a8:	e4 07 01 08 	sub	r8,r2,r7
800063ac:	58 f8       	cp.w	r8,15
800063ae:	5f aa       	srle	r10
800063b0:	f5 e9 10 09 	or	r9,r10,r9
800063b4:	e0 80 00 9a 	breq	800064e8 <_malloc_r+0x418>
800063b8:	e0 68 0d 34 	mov	r8,3380
800063bc:	70 01       	ld.w	r1,r8[0x0]
800063be:	e0 68 09 38 	mov	r8,2360
800063c2:	2f 01       	sub	r1,-16
800063c4:	70 08       	ld.w	r8,r8[0x0]
800063c6:	0e 01       	add	r1,r7
800063c8:	5b f8       	cp.w	r8,-1
800063ca:	c0 40       	breq	800063d2 <_malloc_r+0x302>
800063cc:	28 11       	sub	r1,-127
800063ce:	e0 11 ff 80 	andl	r1,0xff80
800063d2:	02 9b       	mov	r11,r1
800063d4:	0a 9c       	mov	r12,r5
800063d6:	e0 a0 02 a5 	rcall	80006920 <_sbrk_r>
800063da:	18 96       	mov	r6,r12
800063dc:	5b fc       	cp.w	r12,-1
800063de:	c7 50       	breq	800064c8 <_malloc_r+0x3f8>
800063e0:	e6 02 00 08 	add	r8,r3,r2
800063e4:	10 3c       	cp.w	r12,r8
800063e6:	c0 32       	brcc	800063ec <_malloc_r+0x31c>
800063e8:	08 33       	cp.w	r3,r4
800063ea:	c6 f1       	brne	800064c8 <_malloc_r+0x3f8>
800063ec:	e0 6a 0d 38 	mov	r10,3384
800063f0:	74 09       	ld.w	r9,r10[0x0]
800063f2:	e2 09 00 09 	add	r9,r1,r9
800063f6:	95 09       	st.w	r10[0x0],r9
800063f8:	10 36       	cp.w	r6,r8
800063fa:	c0 a1       	brne	8000640e <_malloc_r+0x33e>
800063fc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006400:	c0 71       	brne	8000640e <_malloc_r+0x33e>
80006402:	e2 02 00 02 	add	r2,r1,r2
80006406:	68 28       	ld.w	r8,r4[0x8]
80006408:	a1 a2       	sbr	r2,0x0
8000640a:	91 12       	st.w	r8[0x4],r2
8000640c:	c4 f8       	rjmp	800064aa <_malloc_r+0x3da>
8000640e:	e0 6a 09 38 	mov	r10,2360
80006412:	74 0b       	ld.w	r11,r10[0x0]
80006414:	5b fb       	cp.w	r11,-1
80006416:	c0 31       	brne	8000641c <_malloc_r+0x34c>
80006418:	95 06       	st.w	r10[0x0],r6
8000641a:	c0 78       	rjmp	80006428 <_malloc_r+0x358>
8000641c:	ec 09 00 09 	add	r9,r6,r9
80006420:	e0 6a 0d 38 	mov	r10,3384
80006424:	10 19       	sub	r9,r8
80006426:	95 09       	st.w	r10[0x0],r9
80006428:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000642c:	f0 09 11 08 	rsub	r9,r8,8
80006430:	58 08       	cp.w	r8,0
80006432:	f2 08 17 10 	movne	r8,r9
80006436:	ed d8 e1 06 	addne	r6,r6,r8
8000643a:	28 08       	sub	r8,-128
8000643c:	ec 01 00 01 	add	r1,r6,r1
80006440:	0a 9c       	mov	r12,r5
80006442:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006446:	f0 01 01 01 	sub	r1,r8,r1
8000644a:	02 9b       	mov	r11,r1
8000644c:	e0 a0 02 6a 	rcall	80006920 <_sbrk_r>
80006450:	e0 68 0d 38 	mov	r8,3384
80006454:	5b fc       	cp.w	r12,-1
80006456:	ec 0c 17 00 	moveq	r12,r6
8000645a:	f9 b1 00 00 	moveq	r1,0
8000645e:	70 09       	ld.w	r9,r8[0x0]
80006460:	0c 1c       	sub	r12,r6
80006462:	89 26       	st.w	r4[0x8],r6
80006464:	02 0c       	add	r12,r1
80006466:	12 01       	add	r1,r9
80006468:	a1 ac       	sbr	r12,0x0
8000646a:	91 01       	st.w	r8[0x0],r1
8000646c:	8d 1c       	st.w	r6[0x4],r12
8000646e:	08 33       	cp.w	r3,r4
80006470:	c1 d0       	breq	800064aa <_malloc_r+0x3da>
80006472:	58 f2       	cp.w	r2,15
80006474:	e0 8b 00 05 	brhi	8000647e <_malloc_r+0x3ae>
80006478:	30 18       	mov	r8,1
8000647a:	8d 18       	st.w	r6[0x4],r8
8000647c:	c2 68       	rjmp	800064c8 <_malloc_r+0x3f8>
8000647e:	30 59       	mov	r9,5
80006480:	20 c2       	sub	r2,12
80006482:	e0 12 ff f8 	andl	r2,0xfff8
80006486:	e6 02 00 08 	add	r8,r3,r2
8000648a:	91 29       	st.w	r8[0x8],r9
8000648c:	91 19       	st.w	r8[0x4],r9
8000648e:	66 18       	ld.w	r8,r3[0x4]
80006490:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006494:	e5 e8 10 08 	or	r8,r2,r8
80006498:	87 18       	st.w	r3[0x4],r8
8000649a:	58 f2       	cp.w	r2,15
8000649c:	e0 88 00 07 	brls	800064aa <_malloc_r+0x3da>
800064a0:	e6 cb ff f8 	sub	r11,r3,-8
800064a4:	0a 9c       	mov	r12,r5
800064a6:	e0 a0 1c 6b 	rcall	80009d7c <_free_r>
800064aa:	e0 69 0d 30 	mov	r9,3376
800064ae:	72 0a       	ld.w	r10,r9[0x0]
800064b0:	e0 68 0d 38 	mov	r8,3384
800064b4:	70 08       	ld.w	r8,r8[0x0]
800064b6:	14 38       	cp.w	r8,r10
800064b8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800064bc:	e0 69 0d 2c 	mov	r9,3372
800064c0:	72 0a       	ld.w	r10,r9[0x0]
800064c2:	14 38       	cp.w	r8,r10
800064c4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800064c8:	68 28       	ld.w	r8,r4[0x8]
800064ca:	70 18       	ld.w	r8,r8[0x4]
800064cc:	e0 18 ff fc 	andl	r8,0xfffc
800064d0:	0e 38       	cp.w	r8,r7
800064d2:	5f 39       	srlo	r9
800064d4:	0e 18       	sub	r8,r7
800064d6:	58 f8       	cp.w	r8,15
800064d8:	5f aa       	srle	r10
800064da:	f5 e9 10 09 	or	r9,r10,r9
800064de:	c0 50       	breq	800064e8 <_malloc_r+0x418>
800064e0:	0a 9c       	mov	r12,r5
800064e2:	fe b0 f4 0d 	rcall	80004cfc <__malloc_unlock>
800064e6:	d8 3a       	popm	r0-r7,pc,r12=0
800064e8:	68 26       	ld.w	r6,r4[0x8]
800064ea:	a1 a8       	sbr	r8,0x0
800064ec:	0e 99       	mov	r9,r7
800064ee:	a1 a9       	sbr	r9,0x0
800064f0:	8d 19       	st.w	r6[0x4],r9
800064f2:	ec 07 00 07 	add	r7,r6,r7
800064f6:	0a 9c       	mov	r12,r5
800064f8:	89 27       	st.w	r4[0x8],r7
800064fa:	8f 18       	st.w	r7[0x4],r8
800064fc:	fe b0 f4 00 	rcall	80004cfc <__malloc_unlock>
80006500:	ec cc ff f8 	sub	r12,r6,-8
80006504:	d8 32       	popm	r0-r7,pc
80006506:	d7 03       	nop

80006508 <memcpy>:
80006508:	58 8a       	cp.w	r10,8
8000650a:	c2 f5       	brlt	80006568 <memcpy+0x60>
8000650c:	f9 eb 10 09 	or	r9,r12,r11
80006510:	e2 19 00 03 	andl	r9,0x3,COH
80006514:	e0 81 00 97 	brne	80006642 <memcpy+0x13a>
80006518:	e0 4a 00 20 	cp.w	r10,32
8000651c:	c3 b4       	brge	80006592 <memcpy+0x8a>
8000651e:	f4 08 14 02 	asr	r8,r10,0x2
80006522:	f0 09 11 08 	rsub	r9,r8,8
80006526:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000652a:	76 69       	ld.w	r9,r11[0x18]
8000652c:	99 69       	st.w	r12[0x18],r9
8000652e:	76 59       	ld.w	r9,r11[0x14]
80006530:	99 59       	st.w	r12[0x14],r9
80006532:	76 49       	ld.w	r9,r11[0x10]
80006534:	99 49       	st.w	r12[0x10],r9
80006536:	76 39       	ld.w	r9,r11[0xc]
80006538:	99 39       	st.w	r12[0xc],r9
8000653a:	76 29       	ld.w	r9,r11[0x8]
8000653c:	99 29       	st.w	r12[0x8],r9
8000653e:	76 19       	ld.w	r9,r11[0x4]
80006540:	99 19       	st.w	r12[0x4],r9
80006542:	76 09       	ld.w	r9,r11[0x0]
80006544:	99 09       	st.w	r12[0x0],r9
80006546:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000654a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000654e:	e0 1a 00 03 	andl	r10,0x3
80006552:	f4 0a 11 04 	rsub	r10,r10,4
80006556:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000655a:	17 a9       	ld.ub	r9,r11[0x2]
8000655c:	b0 a9       	st.b	r8[0x2],r9
8000655e:	17 99       	ld.ub	r9,r11[0x1]
80006560:	b0 99       	st.b	r8[0x1],r9
80006562:	17 89       	ld.ub	r9,r11[0x0]
80006564:	b0 89       	st.b	r8[0x0],r9
80006566:	5e fc       	retal	r12
80006568:	f4 0a 11 09 	rsub	r10,r10,9
8000656c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006570:	17 f9       	ld.ub	r9,r11[0x7]
80006572:	b8 f9       	st.b	r12[0x7],r9
80006574:	17 e9       	ld.ub	r9,r11[0x6]
80006576:	b8 e9       	st.b	r12[0x6],r9
80006578:	17 d9       	ld.ub	r9,r11[0x5]
8000657a:	b8 d9       	st.b	r12[0x5],r9
8000657c:	17 c9       	ld.ub	r9,r11[0x4]
8000657e:	b8 c9       	st.b	r12[0x4],r9
80006580:	17 b9       	ld.ub	r9,r11[0x3]
80006582:	b8 b9       	st.b	r12[0x3],r9
80006584:	17 a9       	ld.ub	r9,r11[0x2]
80006586:	b8 a9       	st.b	r12[0x2],r9
80006588:	17 99       	ld.ub	r9,r11[0x1]
8000658a:	b8 99       	st.b	r12[0x1],r9
8000658c:	17 89       	ld.ub	r9,r11[0x0]
8000658e:	b8 89       	st.b	r12[0x0],r9
80006590:	5e fc       	retal	r12
80006592:	eb cd 40 c0 	pushm	r6-r7,lr
80006596:	18 99       	mov	r9,r12
80006598:	22 0a       	sub	r10,32
8000659a:	b7 07       	ld.d	r6,r11++
8000659c:	b3 26       	st.d	r9++,r6
8000659e:	b7 07       	ld.d	r6,r11++
800065a0:	b3 26       	st.d	r9++,r6
800065a2:	b7 07       	ld.d	r6,r11++
800065a4:	b3 26       	st.d	r9++,r6
800065a6:	b7 07       	ld.d	r6,r11++
800065a8:	b3 26       	st.d	r9++,r6
800065aa:	22 0a       	sub	r10,32
800065ac:	cf 74       	brge	8000659a <memcpy+0x92>
800065ae:	2f 0a       	sub	r10,-16
800065b0:	c0 65       	brlt	800065bc <memcpy+0xb4>
800065b2:	b7 07       	ld.d	r6,r11++
800065b4:	b3 26       	st.d	r9++,r6
800065b6:	b7 07       	ld.d	r6,r11++
800065b8:	b3 26       	st.d	r9++,r6
800065ba:	21 0a       	sub	r10,16
800065bc:	5c 3a       	neg	r10
800065be:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800065c2:	d7 03       	nop
800065c4:	d7 03       	nop
800065c6:	f7 36 00 0e 	ld.ub	r6,r11[14]
800065ca:	f3 66 00 0e 	st.b	r9[14],r6
800065ce:	f7 36 00 0d 	ld.ub	r6,r11[13]
800065d2:	f3 66 00 0d 	st.b	r9[13],r6
800065d6:	f7 36 00 0c 	ld.ub	r6,r11[12]
800065da:	f3 66 00 0c 	st.b	r9[12],r6
800065de:	f7 36 00 0b 	ld.ub	r6,r11[11]
800065e2:	f3 66 00 0b 	st.b	r9[11],r6
800065e6:	f7 36 00 0a 	ld.ub	r6,r11[10]
800065ea:	f3 66 00 0a 	st.b	r9[10],r6
800065ee:	f7 36 00 09 	ld.ub	r6,r11[9]
800065f2:	f3 66 00 09 	st.b	r9[9],r6
800065f6:	f7 36 00 08 	ld.ub	r6,r11[8]
800065fa:	f3 66 00 08 	st.b	r9[8],r6
800065fe:	f7 36 00 07 	ld.ub	r6,r11[7]
80006602:	f3 66 00 07 	st.b	r9[7],r6
80006606:	f7 36 00 06 	ld.ub	r6,r11[6]
8000660a:	f3 66 00 06 	st.b	r9[6],r6
8000660e:	f7 36 00 05 	ld.ub	r6,r11[5]
80006612:	f3 66 00 05 	st.b	r9[5],r6
80006616:	f7 36 00 04 	ld.ub	r6,r11[4]
8000661a:	f3 66 00 04 	st.b	r9[4],r6
8000661e:	f7 36 00 03 	ld.ub	r6,r11[3]
80006622:	f3 66 00 03 	st.b	r9[3],r6
80006626:	f7 36 00 02 	ld.ub	r6,r11[2]
8000662a:	f3 66 00 02 	st.b	r9[2],r6
8000662e:	f7 36 00 01 	ld.ub	r6,r11[1]
80006632:	f3 66 00 01 	st.b	r9[1],r6
80006636:	f7 36 00 00 	ld.ub	r6,r11[0]
8000663a:	f3 66 00 00 	st.b	r9[0],r6
8000663e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006642:	20 1a       	sub	r10,1
80006644:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006648:	f8 0a 0b 09 	st.b	r12[r10],r9
8000664c:	cf b1       	brne	80006642 <memcpy+0x13a>
8000664e:	5e fc       	retal	r12

80006650 <memset>:
80006650:	18 98       	mov	r8,r12
80006652:	c0 38       	rjmp	80006658 <memset+0x8>
80006654:	10 cb       	st.b	r8++,r11
80006656:	20 1a       	sub	r10,1
80006658:	58 0a       	cp.w	r10,0
8000665a:	cf d1       	brne	80006654 <memset+0x4>
8000665c:	5e fc       	retal	r12
8000665e:	d7 03       	nop

80006660 <_realloc_r>:
80006660:	d4 31       	pushm	r0-r7,lr
80006662:	20 1d       	sub	sp,4
80006664:	16 94       	mov	r4,r11
80006666:	18 92       	mov	r2,r12
80006668:	14 9b       	mov	r11,r10
8000666a:	58 04       	cp.w	r4,0
8000666c:	c0 51       	brne	80006676 <_realloc_r+0x16>
8000666e:	fe b0 fd 31 	rcall	800060d0 <_malloc_r>
80006672:	18 95       	mov	r5,r12
80006674:	c5 39       	rjmp	8000691a <_realloc_r+0x2ba>
80006676:	50 0a       	stdsp	sp[0x0],r10
80006678:	fe b0 f3 3c 	rcall	80004cf0 <__malloc_lock>
8000667c:	40 0b       	lddsp	r11,sp[0x0]
8000667e:	f6 c8 ff f5 	sub	r8,r11,-11
80006682:	e8 c1 00 08 	sub	r1,r4,8
80006686:	10 96       	mov	r6,r8
80006688:	62 1c       	ld.w	r12,r1[0x4]
8000668a:	e0 16 ff f8 	andl	r6,0xfff8
8000668e:	59 68       	cp.w	r8,22
80006690:	f9 b6 08 10 	movls	r6,16
80006694:	16 36       	cp.w	r6,r11
80006696:	5f 38       	srlo	r8
80006698:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000669c:	c0 50       	breq	800066a6 <_realloc_r+0x46>
8000669e:	30 c8       	mov	r8,12
800066a0:	30 05       	mov	r5,0
800066a2:	85 38       	st.w	r2[0xc],r8
800066a4:	c3 b9       	rjmp	8000691a <_realloc_r+0x2ba>
800066a6:	18 90       	mov	r0,r12
800066a8:	e0 10 ff fc 	andl	r0,0xfffc
800066ac:	0c 30       	cp.w	r0,r6
800066ae:	e0 84 01 0b 	brge	800068c4 <_realloc_r+0x264>
800066b2:	e0 68 05 2c 	mov	r8,1324
800066b6:	e2 00 00 09 	add	r9,r1,r0
800066ba:	70 25       	ld.w	r5,r8[0x8]
800066bc:	0a 39       	cp.w	r9,r5
800066be:	c0 90       	breq	800066d0 <_realloc_r+0x70>
800066c0:	72 1a       	ld.w	r10,r9[0x4]
800066c2:	a1 ca       	cbr	r10,0x0
800066c4:	f2 0a 00 0a 	add	r10,r9,r10
800066c8:	74 1a       	ld.w	r10,r10[0x4]
800066ca:	ed ba 00 00 	bld	r10,0x0
800066ce:	c2 20       	breq	80006712 <_realloc_r+0xb2>
800066d0:	72 1a       	ld.w	r10,r9[0x4]
800066d2:	e0 1a ff fc 	andl	r10,0xfffc
800066d6:	f4 00 00 03 	add	r3,r10,r0
800066da:	0a 39       	cp.w	r9,r5
800066dc:	c1 31       	brne	80006702 <_realloc_r+0xa2>
800066de:	ec c7 ff f0 	sub	r7,r6,-16
800066e2:	0e 33       	cp.w	r3,r7
800066e4:	c1 95       	brlt	80006716 <_realloc_r+0xb6>
800066e6:	e2 06 00 09 	add	r9,r1,r6
800066ea:	0c 13       	sub	r3,r6
800066ec:	a1 a3       	sbr	r3,0x0
800066ee:	93 13       	st.w	r9[0x4],r3
800066f0:	91 29       	st.w	r8[0x8],r9
800066f2:	04 9c       	mov	r12,r2
800066f4:	62 18       	ld.w	r8,r1[0x4]
800066f6:	08 95       	mov	r5,r4
800066f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800066fc:	10 46       	or	r6,r8
800066fe:	83 16       	st.w	r1[0x4],r6
80006700:	c0 b9       	rjmp	80006916 <_realloc_r+0x2b6>
80006702:	0c 33       	cp.w	r3,r6
80006704:	c0 95       	brlt	80006716 <_realloc_r+0xb6>
80006706:	72 28       	ld.w	r8,r9[0x8]
80006708:	02 97       	mov	r7,r1
8000670a:	72 39       	ld.w	r9,r9[0xc]
8000670c:	93 28       	st.w	r9[0x8],r8
8000670e:	91 39       	st.w	r8[0xc],r9
80006710:	cd c8       	rjmp	800068c8 <_realloc_r+0x268>
80006712:	30 0a       	mov	r10,0
80006714:	14 99       	mov	r9,r10
80006716:	ed bc 00 00 	bld	r12,0x0
8000671a:	e0 80 00 95 	breq	80006844 <_realloc_r+0x1e4>
8000671e:	62 07       	ld.w	r7,r1[0x0]
80006720:	e2 07 01 07 	sub	r7,r1,r7
80006724:	6e 1c       	ld.w	r12,r7[0x4]
80006726:	e0 1c ff fc 	andl	r12,0xfffc
8000672a:	58 09       	cp.w	r9,0
8000672c:	c5 60       	breq	800067d8 <_realloc_r+0x178>
8000672e:	f8 00 00 03 	add	r3,r12,r0
80006732:	0a 39       	cp.w	r9,r5
80006734:	c4 81       	brne	800067c4 <_realloc_r+0x164>
80006736:	14 03       	add	r3,r10
80006738:	ec c9 ff f0 	sub	r9,r6,-16
8000673c:	12 33       	cp.w	r3,r9
8000673e:	c4 d5       	brlt	800067d8 <_realloc_r+0x178>
80006740:	6e 3a       	ld.w	r10,r7[0xc]
80006742:	6e 29       	ld.w	r9,r7[0x8]
80006744:	95 29       	st.w	r10[0x8],r9
80006746:	93 3a       	st.w	r9[0xc],r10
80006748:	ee c5 ff f8 	sub	r5,r7,-8
8000674c:	e0 ca 00 04 	sub	r10,r0,4
80006750:	e0 4a 00 24 	cp.w	r10,36
80006754:	e0 8b 00 25 	brhi	8000679e <_realloc_r+0x13e>
80006758:	0a 99       	mov	r9,r5
8000675a:	59 3a       	cp.w	r10,19
8000675c:	e0 88 00 1a 	brls	80006790 <_realloc_r+0x130>
80006760:	09 09       	ld.w	r9,r4++
80006762:	8b 09       	st.w	r5[0x0],r9
80006764:	09 09       	ld.w	r9,r4++
80006766:	8f 39       	st.w	r7[0xc],r9
80006768:	ee c9 ff f0 	sub	r9,r7,-16
8000676c:	59 ba       	cp.w	r10,27
8000676e:	e0 88 00 11 	brls	80006790 <_realloc_r+0x130>
80006772:	09 0b       	ld.w	r11,r4++
80006774:	93 0b       	st.w	r9[0x0],r11
80006776:	09 09       	ld.w	r9,r4++
80006778:	8f 59       	st.w	r7[0x14],r9
8000677a:	ee c9 ff e8 	sub	r9,r7,-24
8000677e:	e0 4a 00 24 	cp.w	r10,36
80006782:	c0 71       	brne	80006790 <_realloc_r+0x130>
80006784:	09 0a       	ld.w	r10,r4++
80006786:	93 0a       	st.w	r9[0x0],r10
80006788:	ee c9 ff e0 	sub	r9,r7,-32
8000678c:	09 0a       	ld.w	r10,r4++
8000678e:	8f 7a       	st.w	r7[0x1c],r10
80006790:	09 0a       	ld.w	r10,r4++
80006792:	12 aa       	st.w	r9++,r10
80006794:	68 0a       	ld.w	r10,r4[0x0]
80006796:	93 0a       	st.w	r9[0x0],r10
80006798:	68 1a       	ld.w	r10,r4[0x4]
8000679a:	93 1a       	st.w	r9[0x4],r10
8000679c:	c0 78       	rjmp	800067aa <_realloc_r+0x14a>
8000679e:	50 08       	stdsp	sp[0x0],r8
800067a0:	08 9b       	mov	r11,r4
800067a2:	0a 9c       	mov	r12,r5
800067a4:	e0 a0 1d 8f 	rcall	8000a2c2 <memmove>
800067a8:	40 08       	lddsp	r8,sp[0x0]
800067aa:	ee 06 00 09 	add	r9,r7,r6
800067ae:	0c 13       	sub	r3,r6
800067b0:	a1 a3       	sbr	r3,0x0
800067b2:	93 13       	st.w	r9[0x4],r3
800067b4:	91 29       	st.w	r8[0x8],r9
800067b6:	04 9c       	mov	r12,r2
800067b8:	6e 18       	ld.w	r8,r7[0x4]
800067ba:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800067be:	10 46       	or	r6,r8
800067c0:	8f 16       	st.w	r7[0x4],r6
800067c2:	ca a8       	rjmp	80006916 <_realloc_r+0x2b6>
800067c4:	14 03       	add	r3,r10
800067c6:	0c 33       	cp.w	r3,r6
800067c8:	c0 85       	brlt	800067d8 <_realloc_r+0x178>
800067ca:	72 28       	ld.w	r8,r9[0x8]
800067cc:	72 39       	ld.w	r9,r9[0xc]
800067ce:	93 28       	st.w	r9[0x8],r8
800067d0:	91 39       	st.w	r8[0xc],r9
800067d2:	6e 28       	ld.w	r8,r7[0x8]
800067d4:	6e 39       	ld.w	r9,r7[0xc]
800067d6:	c0 78       	rjmp	800067e4 <_realloc_r+0x184>
800067d8:	f8 00 00 03 	add	r3,r12,r0
800067dc:	0c 33       	cp.w	r3,r6
800067de:	c3 35       	brlt	80006844 <_realloc_r+0x1e4>
800067e0:	6e 39       	ld.w	r9,r7[0xc]
800067e2:	6e 28       	ld.w	r8,r7[0x8]
800067e4:	93 28       	st.w	r9[0x8],r8
800067e6:	91 39       	st.w	r8[0xc],r9
800067e8:	e0 ca 00 04 	sub	r10,r0,4
800067ec:	ee cc ff f8 	sub	r12,r7,-8
800067f0:	e0 4a 00 24 	cp.w	r10,36
800067f4:	e0 8b 00 24 	brhi	8000683c <_realloc_r+0x1dc>
800067f8:	59 3a       	cp.w	r10,19
800067fa:	e0 88 00 1a 	brls	8000682e <_realloc_r+0x1ce>
800067fe:	09 08       	ld.w	r8,r4++
80006800:	99 08       	st.w	r12[0x0],r8
80006802:	09 08       	ld.w	r8,r4++
80006804:	8f 38       	st.w	r7[0xc],r8
80006806:	ee cc ff f0 	sub	r12,r7,-16
8000680a:	59 ba       	cp.w	r10,27
8000680c:	e0 88 00 11 	brls	8000682e <_realloc_r+0x1ce>
80006810:	09 08       	ld.w	r8,r4++
80006812:	99 08       	st.w	r12[0x0],r8
80006814:	09 08       	ld.w	r8,r4++
80006816:	8f 58       	st.w	r7[0x14],r8
80006818:	ee cc ff e8 	sub	r12,r7,-24
8000681c:	e0 4a 00 24 	cp.w	r10,36
80006820:	c0 71       	brne	8000682e <_realloc_r+0x1ce>
80006822:	09 08       	ld.w	r8,r4++
80006824:	99 08       	st.w	r12[0x0],r8
80006826:	ee cc ff e0 	sub	r12,r7,-32
8000682a:	09 08       	ld.w	r8,r4++
8000682c:	8f 78       	st.w	r7[0x1c],r8
8000682e:	09 08       	ld.w	r8,r4++
80006830:	18 a8       	st.w	r12++,r8
80006832:	68 08       	ld.w	r8,r4[0x0]
80006834:	99 08       	st.w	r12[0x0],r8
80006836:	68 18       	ld.w	r8,r4[0x4]
80006838:	99 18       	st.w	r12[0x4],r8
8000683a:	c4 78       	rjmp	800068c8 <_realloc_r+0x268>
8000683c:	08 9b       	mov	r11,r4
8000683e:	e0 a0 1d 42 	rcall	8000a2c2 <memmove>
80006842:	c4 38       	rjmp	800068c8 <_realloc_r+0x268>
80006844:	04 9c       	mov	r12,r2
80006846:	fe b0 fc 45 	rcall	800060d0 <_malloc_r>
8000684a:	18 95       	mov	r5,r12
8000684c:	c3 a0       	breq	800068c0 <_realloc_r+0x260>
8000684e:	62 18       	ld.w	r8,r1[0x4]
80006850:	f8 c9 00 08 	sub	r9,r12,8
80006854:	a1 c8       	cbr	r8,0x0
80006856:	e2 08 00 08 	add	r8,r1,r8
8000685a:	10 39       	cp.w	r9,r8
8000685c:	c0 71       	brne	8000686a <_realloc_r+0x20a>
8000685e:	72 13       	ld.w	r3,r9[0x4]
80006860:	02 97       	mov	r7,r1
80006862:	e0 13 ff fc 	andl	r3,0xfffc
80006866:	00 03       	add	r3,r0
80006868:	c3 08       	rjmp	800068c8 <_realloc_r+0x268>
8000686a:	e0 ca 00 04 	sub	r10,r0,4
8000686e:	e0 4a 00 24 	cp.w	r10,36
80006872:	e0 8b 00 20 	brhi	800068b2 <_realloc_r+0x252>
80006876:	08 99       	mov	r9,r4
80006878:	18 98       	mov	r8,r12
8000687a:	59 3a       	cp.w	r10,19
8000687c:	e0 88 00 14 	brls	800068a4 <_realloc_r+0x244>
80006880:	13 0b       	ld.w	r11,r9++
80006882:	10 ab       	st.w	r8++,r11
80006884:	13 0b       	ld.w	r11,r9++
80006886:	10 ab       	st.w	r8++,r11
80006888:	59 ba       	cp.w	r10,27
8000688a:	e0 88 00 0d 	brls	800068a4 <_realloc_r+0x244>
8000688e:	13 0b       	ld.w	r11,r9++
80006890:	10 ab       	st.w	r8++,r11
80006892:	13 0b       	ld.w	r11,r9++
80006894:	10 ab       	st.w	r8++,r11
80006896:	e0 4a 00 24 	cp.w	r10,36
8000689a:	c0 51       	brne	800068a4 <_realloc_r+0x244>
8000689c:	13 0a       	ld.w	r10,r9++
8000689e:	10 aa       	st.w	r8++,r10
800068a0:	13 0a       	ld.w	r10,r9++
800068a2:	10 aa       	st.w	r8++,r10
800068a4:	13 0a       	ld.w	r10,r9++
800068a6:	10 aa       	st.w	r8++,r10
800068a8:	72 0a       	ld.w	r10,r9[0x0]
800068aa:	91 0a       	st.w	r8[0x0],r10
800068ac:	72 19       	ld.w	r9,r9[0x4]
800068ae:	91 19       	st.w	r8[0x4],r9
800068b0:	c0 48       	rjmp	800068b8 <_realloc_r+0x258>
800068b2:	08 9b       	mov	r11,r4
800068b4:	e0 a0 1d 07 	rcall	8000a2c2 <memmove>
800068b8:	08 9b       	mov	r11,r4
800068ba:	04 9c       	mov	r12,r2
800068bc:	e0 a0 1a 60 	rcall	80009d7c <_free_r>
800068c0:	04 9c       	mov	r12,r2
800068c2:	c2 a8       	rjmp	80006916 <_realloc_r+0x2b6>
800068c4:	00 93       	mov	r3,r0
800068c6:	02 97       	mov	r7,r1
800068c8:	e6 06 01 09 	sub	r9,r3,r6
800068cc:	6e 18       	ld.w	r8,r7[0x4]
800068ce:	58 f9       	cp.w	r9,15
800068d0:	e0 88 00 16 	brls	800068fc <_realloc_r+0x29c>
800068d4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068d8:	ed e8 10 08 	or	r8,r6,r8
800068dc:	8f 18       	st.w	r7[0x4],r8
800068de:	12 98       	mov	r8,r9
800068e0:	a1 a8       	sbr	r8,0x0
800068e2:	ee 06 00 0b 	add	r11,r7,r6
800068e6:	f6 09 00 09 	add	r9,r11,r9
800068ea:	97 18       	st.w	r11[0x4],r8
800068ec:	72 18       	ld.w	r8,r9[0x4]
800068ee:	a1 a8       	sbr	r8,0x0
800068f0:	2f 8b       	sub	r11,-8
800068f2:	93 18       	st.w	r9[0x4],r8
800068f4:	04 9c       	mov	r12,r2
800068f6:	e0 a0 1a 43 	rcall	80009d7c <_free_r>
800068fa:	c0 b8       	rjmp	80006910 <_realloc_r+0x2b0>
800068fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006900:	e7 e8 10 08 	or	r8,r3,r8
80006904:	8f 18       	st.w	r7[0x4],r8
80006906:	ee 03 00 03 	add	r3,r7,r3
8000690a:	66 18       	ld.w	r8,r3[0x4]
8000690c:	a1 a8       	sbr	r8,0x0
8000690e:	87 18       	st.w	r3[0x4],r8
80006910:	04 9c       	mov	r12,r2
80006912:	ee c5 ff f8 	sub	r5,r7,-8
80006916:	fe b0 f1 f3 	rcall	80004cfc <__malloc_unlock>
8000691a:	0a 9c       	mov	r12,r5
8000691c:	2f fd       	sub	sp,-4
8000691e:	d8 32       	popm	r0-r7,pc

80006920 <_sbrk_r>:
80006920:	d4 21       	pushm	r4-r7,lr
80006922:	30 08       	mov	r8,0
80006924:	18 97       	mov	r7,r12
80006926:	e0 66 40 e4 	mov	r6,16612
8000692a:	16 9c       	mov	r12,r11
8000692c:	8d 08       	st.w	r6[0x0],r8
8000692e:	c8 5c       	rcall	80006a38 <_sbrk>
80006930:	5b fc       	cp.w	r12,-1
80006932:	c0 51       	brne	8000693c <_sbrk_r+0x1c>
80006934:	6c 08       	ld.w	r8,r6[0x0]
80006936:	58 08       	cp.w	r8,0
80006938:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000693c:	d8 22       	popm	r4-r7,pc
8000693e:	d7 03       	nop

80006940 <sprintf>:
80006940:	d4 01       	pushm	lr
80006942:	21 7d       	sub	sp,92
80006944:	e0 68 ff ff 	mov	r8,65535
80006948:	ea 18 7f ff 	orh	r8,0x7fff
8000694c:	50 58       	stdsp	sp[0x14],r8
8000694e:	50 28       	stdsp	sp[0x8],r8
80006950:	e0 68 02 08 	mov	r8,520
80006954:	ba 68       	st.h	sp[0xc],r8
80006956:	3f f8       	mov	r8,-1
80006958:	ba 78       	st.h	sp[0xe],r8
8000695a:	e0 68 0a 2c 	mov	r8,2604
8000695e:	50 4c       	stdsp	sp[0x10],r12
80006960:	16 9a       	mov	r10,r11
80006962:	50 0c       	stdsp	sp[0x0],r12
80006964:	fa c9 ff a0 	sub	r9,sp,-96
80006968:	70 0c       	ld.w	r12,r8[0x0]
8000696a:	1a 9b       	mov	r11,sp
8000696c:	e0 a0 02 1a 	rcall	80006da0 <_vfprintf_r>
80006970:	30 09       	mov	r9,0
80006972:	40 08       	lddsp	r8,sp[0x0]
80006974:	b0 89       	st.b	r8[0x0],r9
80006976:	2e 9d       	sub	sp,-92
80006978:	d8 02       	popm	pc
8000697a:	d7 03       	nop

8000697c <strncpy>:
8000697c:	30 08       	mov	r8,0
8000697e:	10 3a       	cp.w	r10,r8
80006980:	5e 0c       	reteq	r12
80006982:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006986:	f8 08 0b 09 	st.b	r12[r8],r9
8000698a:	2f f8       	sub	r8,-1
8000698c:	58 09       	cp.w	r9,0
8000698e:	cf 81       	brne	8000697e <strncpy+0x2>
80006990:	10 3a       	cp.w	r10,r8
80006992:	5e 0c       	reteq	r12
80006994:	f8 08 0b 09 	st.b	r12[r8],r9
80006998:	2f f8       	sub	r8,-1
8000699a:	cf bb       	rjmp	80006990 <strncpy+0x14>

8000699c <_close>:
8000699c:	30 28       	mov	r8,2
8000699e:	d6 73       	breakpoint
800069a0:	3f fc       	mov	r12,-1
800069a2:	35 8b       	mov	r11,88
800069a4:	58 0c       	cp.w	r12,0
800069a6:	5e 4c       	retge	r12
800069a8:	e0 6a 40 e4 	mov	r10,16612
800069ac:	95 0b       	st.w	r10[0x0],r11
800069ae:	5e fc       	retal	r12

800069b0 <_lseek>:
800069b0:	30 58       	mov	r8,5
800069b2:	d6 73       	breakpoint
800069b4:	3f fc       	mov	r12,-1
800069b6:	35 8b       	mov	r11,88
800069b8:	58 0c       	cp.w	r12,0
800069ba:	5e 4c       	retge	r12
800069bc:	e0 6a 40 e4 	mov	r10,16612
800069c0:	95 0b       	st.w	r10[0x0],r11
800069c2:	5e fc       	retal	r12

800069c4 <isatty>:
800069c4:	30 b8       	mov	r8,11
800069c6:	d6 73       	breakpoint
800069c8:	3f fc       	mov	r12,-1
800069ca:	35 8b       	mov	r11,88
800069cc:	58 0c       	cp.w	r12,0
800069ce:	5e 4c       	retge	r12
800069d0:	e0 6a 40 e4 	mov	r10,16612
800069d4:	95 0b       	st.w	r10[0x0],r11
800069d6:	5e fc       	retal	r12

800069d8 <_fstat_host>:
800069d8:	30 98       	mov	r8,9
800069da:	d6 73       	breakpoint
800069dc:	3f fc       	mov	r12,-1
800069de:	35 8b       	mov	r11,88
800069e0:	58 0c       	cp.w	r12,0
800069e2:	5e 4c       	retge	r12
800069e4:	e0 6a 40 e4 	mov	r10,16612
800069e8:	95 0b       	st.w	r10[0x0],r11
800069ea:	5e fc       	retal	r12

800069ec <_fstat>:
800069ec:	d4 21       	pushm	r4-r7,lr
800069ee:	21 0d       	sub	sp,64
800069f0:	16 97       	mov	r7,r11
800069f2:	1a 9b       	mov	r11,sp
800069f4:	cf 2f       	rcall	800069d8 <_fstat_host>
800069f6:	c0 34       	brge	800069fc <_fstat+0x10>
800069f8:	3f fc       	mov	r12,-1
800069fa:	c1 c8       	rjmp	80006a32 <_fstat+0x46>
800069fc:	40 08       	lddsp	r8,sp[0x0]
800069fe:	ae 08       	st.h	r7[0x0],r8
80006a00:	40 18       	lddsp	r8,sp[0x4]
80006a02:	ae 18       	st.h	r7[0x2],r8
80006a04:	40 28       	lddsp	r8,sp[0x8]
80006a06:	8f 18       	st.w	r7[0x4],r8
80006a08:	40 38       	lddsp	r8,sp[0xc]
80006a0a:	ae 48       	st.h	r7[0x8],r8
80006a0c:	40 48       	lddsp	r8,sp[0x10]
80006a0e:	ae 58       	st.h	r7[0xa],r8
80006a10:	40 58       	lddsp	r8,sp[0x14]
80006a12:	ae 68       	st.h	r7[0xc],r8
80006a14:	40 68       	lddsp	r8,sp[0x18]
80006a16:	ae 78       	st.h	r7[0xe],r8
80006a18:	40 88       	lddsp	r8,sp[0x20]
80006a1a:	8f 48       	st.w	r7[0x10],r8
80006a1c:	40 a8       	lddsp	r8,sp[0x28]
80006a1e:	8f b8       	st.w	r7[0x2c],r8
80006a20:	40 c8       	lddsp	r8,sp[0x30]
80006a22:	8f c8       	st.w	r7[0x30],r8
80006a24:	40 d8       	lddsp	r8,sp[0x34]
80006a26:	8f 58       	st.w	r7[0x14],r8
80006a28:	40 e8       	lddsp	r8,sp[0x38]
80006a2a:	30 0c       	mov	r12,0
80006a2c:	8f 78       	st.w	r7[0x1c],r8
80006a2e:	40 f8       	lddsp	r8,sp[0x3c]
80006a30:	8f 98       	st.w	r7[0x24],r8
80006a32:	2f 0d       	sub	sp,-64
80006a34:	d8 22       	popm	r4-r7,pc
80006a36:	d7 03       	nop

80006a38 <_sbrk>:
80006a38:	d4 01       	pushm	lr
80006a3a:	e0 68 0d 60 	mov	r8,3424
80006a3e:	70 09       	ld.w	r9,r8[0x0]
80006a40:	58 09       	cp.w	r9,0
80006a42:	c0 41       	brne	80006a4a <_sbrk+0x12>
80006a44:	e0 69 40 e8 	mov	r9,16616
80006a48:	91 09       	st.w	r8[0x0],r9
80006a4a:	e0 69 0d 60 	mov	r9,3424
80006a4e:	e0 7a 70 00 	mov	r10,94208
80006a52:	72 08       	ld.w	r8,r9[0x0]
80006a54:	f0 0c 00 0c 	add	r12,r8,r12
80006a58:	14 3c       	cp.w	r12,r10
80006a5a:	e0 8b 00 04 	brhi	80006a62 <_sbrk+0x2a>
80006a5e:	93 0c       	st.w	r9[0x0],r12
80006a60:	c0 68       	rjmp	80006a6c <_sbrk+0x34>
80006a62:	e0 a0 18 15 	rcall	80009a8c <__errno>
80006a66:	30 c8       	mov	r8,12
80006a68:	99 08       	st.w	r12[0x0],r8
80006a6a:	3f f8       	mov	r8,-1
80006a6c:	10 9c       	mov	r12,r8
80006a6e:	d8 02       	popm	pc

80006a70 <get_arg>:
80006a70:	d4 31       	pushm	r0-r7,lr
80006a72:	20 8d       	sub	sp,32
80006a74:	fa c4 ff bc 	sub	r4,sp,-68
80006a78:	50 4b       	stdsp	sp[0x10],r11
80006a7a:	68 2e       	ld.w	lr,r4[0x8]
80006a7c:	50 58       	stdsp	sp[0x14],r8
80006a7e:	12 96       	mov	r6,r9
80006a80:	7c 0b       	ld.w	r11,lr[0x0]
80006a82:	70 05       	ld.w	r5,r8[0x0]
80006a84:	50 6e       	stdsp	sp[0x18],lr
80006a86:	58 0b       	cp.w	r11,0
80006a88:	f4 0b 17 00 	moveq	r11,r10
80006a8c:	68 03       	ld.w	r3,r4[0x0]
80006a8e:	68 11       	ld.w	r1,r4[0x4]
80006a90:	40 49       	lddsp	r9,sp[0x10]
80006a92:	30 08       	mov	r8,0
80006a94:	c2 89       	rjmp	80006ce4 <get_arg+0x274>
80006a96:	2f fb       	sub	r11,-1
80006a98:	32 5c       	mov	r12,37
80006a9a:	17 8a       	ld.ub	r10,r11[0x0]
80006a9c:	f8 0a 18 00 	cp.b	r10,r12
80006aa0:	5f 1e       	srne	lr
80006aa2:	f0 0a 18 00 	cp.b	r10,r8
80006aa6:	5f 1c       	srne	r12
80006aa8:	fd ec 00 0c 	and	r12,lr,r12
80006aac:	f0 0c 18 00 	cp.b	r12,r8
80006ab0:	cf 31       	brne	80006a96 <get_arg+0x26>
80006ab2:	58 0a       	cp.w	r10,0
80006ab4:	e0 80 01 25 	breq	80006cfe <get_arg+0x28e>
80006ab8:	30 0c       	mov	r12,0
80006aba:	3f fa       	mov	r10,-1
80006abc:	18 90       	mov	r0,r12
80006abe:	50 3a       	stdsp	sp[0xc],r10
80006ac0:	18 94       	mov	r4,r12
80006ac2:	18 92       	mov	r2,r12
80006ac4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006ac8:	16 97       	mov	r7,r11
80006aca:	50 7c       	stdsp	sp[0x1c],r12
80006acc:	fe cc a0 ec 	sub	r12,pc,-24340
80006ad0:	0f 3a       	ld.ub	r10,r7++
80006ad2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006ad6:	40 7c       	lddsp	r12,sp[0x1c]
80006ad8:	1c 0c       	add	r12,lr
80006ada:	fe ce a1 c2 	sub	lr,pc,-24126
80006ade:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006ae2:	20 1e       	sub	lr,1
80006ae4:	50 0e       	stdsp	sp[0x0],lr
80006ae6:	fe ce a2 3a 	sub	lr,pc,-24006
80006aea:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006aee:	50 7c       	stdsp	sp[0x1c],r12
80006af0:	40 0c       	lddsp	r12,sp[0x0]
80006af2:	58 7c       	cp.w	r12,7
80006af4:	e0 8b 00 f1 	brhi	80006cd6 <get_arg+0x266>
80006af8:	fe ce a3 ec 	sub	lr,pc,-23572
80006afc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006b00:	36 8b       	mov	r11,104
80006b02:	f6 0a 18 00 	cp.b	r10,r11
80006b06:	e0 80 00 e8 	breq	80006cd6 <get_arg+0x266>
80006b0a:	37 1b       	mov	r11,113
80006b0c:	f6 0a 18 00 	cp.b	r10,r11
80006b10:	c0 70       	breq	80006b1e <get_arg+0xae>
80006b12:	34 cb       	mov	r11,76
80006b14:	f6 0a 18 00 	cp.b	r10,r11
80006b18:	c0 51       	brne	80006b22 <get_arg+0xb2>
80006b1a:	a3 b4       	sbr	r4,0x3
80006b1c:	cd d8       	rjmp	80006cd6 <get_arg+0x266>
80006b1e:	a5 b4       	sbr	r4,0x5
80006b20:	cd b8       	rjmp	80006cd6 <get_arg+0x266>
80006b22:	08 9a       	mov	r10,r4
80006b24:	0e 9b       	mov	r11,r7
80006b26:	a5 aa       	sbr	r10,0x4
80006b28:	17 3c       	ld.ub	r12,r11++
80006b2a:	a5 b4       	sbr	r4,0x5
80006b2c:	36 ce       	mov	lr,108
80006b2e:	fc 0c 18 00 	cp.b	r12,lr
80006b32:	e0 80 00 d3 	breq	80006cd8 <get_arg+0x268>
80006b36:	14 94       	mov	r4,r10
80006b38:	cc f8       	rjmp	80006cd6 <get_arg+0x266>
80006b3a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006b3e:	36 7c       	mov	r12,103
80006b40:	f8 0a 18 00 	cp.b	r10,r12
80006b44:	e0 8b 00 27 	brhi	80006b92 <get_arg+0x122>
80006b48:	36 5b       	mov	r11,101
80006b4a:	f6 0a 18 00 	cp.b	r10,r11
80006b4e:	c4 82       	brcc	80006bde <get_arg+0x16e>
80006b50:	34 fb       	mov	r11,79
80006b52:	f6 0a 18 00 	cp.b	r10,r11
80006b56:	c4 80       	breq	80006be6 <get_arg+0x176>
80006b58:	e0 8b 00 0c 	brhi	80006b70 <get_arg+0x100>
80006b5c:	34 5b       	mov	r11,69
80006b5e:	f6 0a 18 00 	cp.b	r10,r11
80006b62:	c3 e0       	breq	80006bde <get_arg+0x16e>
80006b64:	34 7b       	mov	r11,71
80006b66:	f6 0a 18 00 	cp.b	r10,r11
80006b6a:	c3 a0       	breq	80006bde <get_arg+0x16e>
80006b6c:	34 4b       	mov	r11,68
80006b6e:	c0 88       	rjmp	80006b7e <get_arg+0x10e>
80006b70:	35 8b       	mov	r11,88
80006b72:	f6 0a 18 00 	cp.b	r10,r11
80006b76:	c2 c0       	breq	80006bce <get_arg+0x15e>
80006b78:	e0 8b 00 07 	brhi	80006b86 <get_arg+0x116>
80006b7c:	35 5b       	mov	r11,85
80006b7e:	f6 0a 18 00 	cp.b	r10,r11
80006b82:	c3 51       	brne	80006bec <get_arg+0x17c>
80006b84:	c3 18       	rjmp	80006be6 <get_arg+0x176>
80006b86:	36 3b       	mov	r11,99
80006b88:	f6 0a 18 00 	cp.b	r10,r11
80006b8c:	c2 f0       	breq	80006bea <get_arg+0x17a>
80006b8e:	36 4b       	mov	r11,100
80006b90:	c0 e8       	rjmp	80006bac <get_arg+0x13c>
80006b92:	37 0b       	mov	r11,112
80006b94:	f6 0a 18 00 	cp.b	r10,r11
80006b98:	c2 50       	breq	80006be2 <get_arg+0x172>
80006b9a:	e0 8b 00 0d 	brhi	80006bb4 <get_arg+0x144>
80006b9e:	36 eb       	mov	r11,110
80006ba0:	f6 0a 18 00 	cp.b	r10,r11
80006ba4:	c1 f0       	breq	80006be2 <get_arg+0x172>
80006ba6:	e0 8b 00 14 	brhi	80006bce <get_arg+0x15e>
80006baa:	36 9b       	mov	r11,105
80006bac:	f6 0a 18 00 	cp.b	r10,r11
80006bb0:	c1 e1       	brne	80006bec <get_arg+0x17c>
80006bb2:	c0 e8       	rjmp	80006bce <get_arg+0x15e>
80006bb4:	37 5b       	mov	r11,117
80006bb6:	f6 0a 18 00 	cp.b	r10,r11
80006bba:	c0 a0       	breq	80006bce <get_arg+0x15e>
80006bbc:	37 8b       	mov	r11,120
80006bbe:	f6 0a 18 00 	cp.b	r10,r11
80006bc2:	c0 60       	breq	80006bce <get_arg+0x15e>
80006bc4:	37 3b       	mov	r11,115
80006bc6:	f6 0a 18 00 	cp.b	r10,r11
80006bca:	c1 11       	brne	80006bec <get_arg+0x17c>
80006bcc:	c0 b8       	rjmp	80006be2 <get_arg+0x172>
80006bce:	ed b4 00 04 	bld	r4,0x4
80006bd2:	c0 a0       	breq	80006be6 <get_arg+0x176>
80006bd4:	ed b4 00 05 	bld	r4,0x5
80006bd8:	c0 91       	brne	80006bea <get_arg+0x17a>
80006bda:	30 20       	mov	r0,2
80006bdc:	c0 88       	rjmp	80006bec <get_arg+0x17c>
80006bde:	30 40       	mov	r0,4
80006be0:	c0 68       	rjmp	80006bec <get_arg+0x17c>
80006be2:	30 30       	mov	r0,3
80006be4:	c0 48       	rjmp	80006bec <get_arg+0x17c>
80006be6:	30 10       	mov	r0,1
80006be8:	c0 28       	rjmp	80006bec <get_arg+0x17c>
80006bea:	30 00       	mov	r0,0
80006bec:	40 3b       	lddsp	r11,sp[0xc]
80006bee:	5b fb       	cp.w	r11,-1
80006bf0:	c0 40       	breq	80006bf8 <get_arg+0x188>
80006bf2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006bf6:	c7 08       	rjmp	80006cd6 <get_arg+0x266>
80006bf8:	58 60       	cp.w	r0,6
80006bfa:	e0 8b 00 6e 	brhi	80006cd6 <get_arg+0x266>
80006bfe:	6c 0a       	ld.w	r10,r6[0x0]
80006c00:	ea cc ff ff 	sub	r12,r5,-1
80006c04:	fe ce a4 d8 	sub	lr,pc,-23336
80006c08:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006c0c:	f4 cb ff f8 	sub	r11,r10,-8
80006c10:	8d 0b       	st.w	r6[0x0],r11
80006c12:	f4 ea 00 00 	ld.d	r10,r10[0]
80006c16:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006c1a:	c0 f8       	rjmp	80006c38 <get_arg+0x1c8>
80006c1c:	f4 cb ff fc 	sub	r11,r10,-4
80006c20:	8d 0b       	st.w	r6[0x0],r11
80006c22:	74 0a       	ld.w	r10,r10[0x0]
80006c24:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006c28:	c0 88       	rjmp	80006c38 <get_arg+0x1c8>
80006c2a:	f4 cb ff f8 	sub	r11,r10,-8
80006c2e:	8d 0b       	st.w	r6[0x0],r11
80006c30:	f4 ea 00 00 	ld.d	r10,r10[0]
80006c34:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006c38:	0e 9b       	mov	r11,r7
80006c3a:	18 95       	mov	r5,r12
80006c3c:	c4 e8       	rjmp	80006cd8 <get_arg+0x268>
80006c3e:	62 0a       	ld.w	r10,r1[0x0]
80006c40:	5b fa       	cp.w	r10,-1
80006c42:	c0 b1       	brne	80006c58 <get_arg+0x1e8>
80006c44:	50 19       	stdsp	sp[0x4],r9
80006c46:	50 28       	stdsp	sp[0x8],r8
80006c48:	e0 6a 00 80 	mov	r10,128
80006c4c:	30 0b       	mov	r11,0
80006c4e:	02 9c       	mov	r12,r1
80006c50:	fe b0 fd 00 	rcall	80006650 <memset>
80006c54:	40 28       	lddsp	r8,sp[0x8]
80006c56:	40 19       	lddsp	r9,sp[0x4]
80006c58:	e4 cc 00 01 	sub	r12,r2,1
80006c5c:	0e 9b       	mov	r11,r7
80006c5e:	50 3c       	stdsp	sp[0xc],r12
80006c60:	f2 0c 0c 49 	max	r9,r9,r12
80006c64:	c3 a8       	rjmp	80006cd8 <get_arg+0x268>
80006c66:	62 0a       	ld.w	r10,r1[0x0]
80006c68:	5b fa       	cp.w	r10,-1
80006c6a:	c0 b1       	brne	80006c80 <get_arg+0x210>
80006c6c:	50 19       	stdsp	sp[0x4],r9
80006c6e:	50 28       	stdsp	sp[0x8],r8
80006c70:	e0 6a 00 80 	mov	r10,128
80006c74:	30 0b       	mov	r11,0
80006c76:	02 9c       	mov	r12,r1
80006c78:	fe b0 fc ec 	rcall	80006650 <memset>
80006c7c:	40 28       	lddsp	r8,sp[0x8]
80006c7e:	40 19       	lddsp	r9,sp[0x4]
80006c80:	20 12       	sub	r2,1
80006c82:	30 0a       	mov	r10,0
80006c84:	0e 9b       	mov	r11,r7
80006c86:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006c8a:	f2 02 0c 49 	max	r9,r9,r2
80006c8e:	c2 58       	rjmp	80006cd8 <get_arg+0x268>
80006c90:	16 97       	mov	r7,r11
80006c92:	6c 0a       	ld.w	r10,r6[0x0]
80006c94:	f4 cb ff fc 	sub	r11,r10,-4
80006c98:	8d 0b       	st.w	r6[0x0],r11
80006c9a:	74 0a       	ld.w	r10,r10[0x0]
80006c9c:	0e 9b       	mov	r11,r7
80006c9e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006ca2:	2f f5       	sub	r5,-1
80006ca4:	c1 a8       	rjmp	80006cd8 <get_arg+0x268>
80006ca6:	f4 c2 00 30 	sub	r2,r10,48
80006caa:	c0 68       	rjmp	80006cb6 <get_arg+0x246>
80006cac:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006cb0:	2f f7       	sub	r7,-1
80006cb2:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006cb6:	0f 8a       	ld.ub	r10,r7[0x0]
80006cb8:	58 0a       	cp.w	r10,0
80006cba:	c0 e0       	breq	80006cd6 <get_arg+0x266>
80006cbc:	23 0a       	sub	r10,48
80006cbe:	58 9a       	cp.w	r10,9
80006cc0:	fe 98 ff f6 	brls	80006cac <get_arg+0x23c>
80006cc4:	c0 98       	rjmp	80006cd6 <get_arg+0x266>
80006cc6:	2f f7       	sub	r7,-1
80006cc8:	0f 8a       	ld.ub	r10,r7[0x0]
80006cca:	58 0a       	cp.w	r10,0
80006ccc:	c0 50       	breq	80006cd6 <get_arg+0x266>
80006cce:	23 0a       	sub	r10,48
80006cd0:	58 9a       	cp.w	r10,9
80006cd2:	fe 98 ff fa 	brls	80006cc6 <get_arg+0x256>
80006cd6:	0e 9b       	mov	r11,r7
80006cd8:	40 7c       	lddsp	r12,sp[0x1c]
80006cda:	30 ba       	mov	r10,11
80006cdc:	f4 0c 18 00 	cp.b	r12,r10
80006ce0:	fe 91 fe f2 	brne	80006ac4 <get_arg+0x54>
80006ce4:	40 42       	lddsp	r2,sp[0x10]
80006ce6:	17 8c       	ld.ub	r12,r11[0x0]
80006ce8:	0a 32       	cp.w	r2,r5
80006cea:	5f 4a       	srge	r10
80006cec:	f0 0c 18 00 	cp.b	r12,r8
80006cf0:	5f 1c       	srne	r12
80006cf2:	f9 ea 00 0a 	and	r10,r12,r10
80006cf6:	f0 0a 18 00 	cp.b	r10,r8
80006cfa:	fe 91 fe cf 	brne	80006a98 <get_arg+0x28>
80006cfe:	30 08       	mov	r8,0
80006d00:	40 4e       	lddsp	lr,sp[0x10]
80006d02:	17 8a       	ld.ub	r10,r11[0x0]
80006d04:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006d08:	f0 0a 18 00 	cp.b	r10,r8
80006d0c:	fc 09 17 10 	movne	r9,lr
80006d10:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006d14:	06 9e       	mov	lr,r3
80006d16:	c2 a8       	rjmp	80006d6a <get_arg+0x2fa>
80006d18:	62 0a       	ld.w	r10,r1[0x0]
80006d1a:	58 3a       	cp.w	r10,3
80006d1c:	c1 e0       	breq	80006d58 <get_arg+0x2e8>
80006d1e:	e0 89 00 07 	brgt	80006d2c <get_arg+0x2bc>
80006d22:	58 1a       	cp.w	r10,1
80006d24:	c1 a0       	breq	80006d58 <get_arg+0x2e8>
80006d26:	58 2a       	cp.w	r10,2
80006d28:	c1 81       	brne	80006d58 <get_arg+0x2e8>
80006d2a:	c0 58       	rjmp	80006d34 <get_arg+0x2c4>
80006d2c:	58 5a       	cp.w	r10,5
80006d2e:	c0 c0       	breq	80006d46 <get_arg+0x2d6>
80006d30:	c0 b5       	brlt	80006d46 <get_arg+0x2d6>
80006d32:	c1 38       	rjmp	80006d58 <get_arg+0x2e8>
80006d34:	6c 0a       	ld.w	r10,r6[0x0]
80006d36:	f4 cc ff f8 	sub	r12,r10,-8
80006d3a:	8d 0c       	st.w	r6[0x0],r12
80006d3c:	f4 e2 00 00 	ld.d	r2,r10[0]
80006d40:	f0 e3 00 00 	st.d	r8[0],r2
80006d44:	c1 08       	rjmp	80006d64 <get_arg+0x2f4>
80006d46:	6c 0a       	ld.w	r10,r6[0x0]
80006d48:	f4 cc ff f8 	sub	r12,r10,-8
80006d4c:	8d 0c       	st.w	r6[0x0],r12
80006d4e:	f4 e2 00 00 	ld.d	r2,r10[0]
80006d52:	f0 e3 00 00 	st.d	r8[0],r2
80006d56:	c0 78       	rjmp	80006d64 <get_arg+0x2f4>
80006d58:	6c 0a       	ld.w	r10,r6[0x0]
80006d5a:	f4 cc ff fc 	sub	r12,r10,-4
80006d5e:	8d 0c       	st.w	r6[0x0],r12
80006d60:	74 0a       	ld.w	r10,r10[0x0]
80006d62:	91 0a       	st.w	r8[0x0],r10
80006d64:	2f f5       	sub	r5,-1
80006d66:	2f 88       	sub	r8,-8
80006d68:	2f c1       	sub	r1,-4
80006d6a:	12 35       	cp.w	r5,r9
80006d6c:	fe 9a ff d6 	brle	80006d18 <get_arg+0x2a8>
80006d70:	1c 93       	mov	r3,lr
80006d72:	40 52       	lddsp	r2,sp[0x14]
80006d74:	40 6e       	lddsp	lr,sp[0x18]
80006d76:	85 05       	st.w	r2[0x0],r5
80006d78:	9d 0b       	st.w	lr[0x0],r11
80006d7a:	40 4b       	lddsp	r11,sp[0x10]
80006d7c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006d80:	2f 8d       	sub	sp,-32
80006d82:	d8 32       	popm	r0-r7,pc

80006d84 <__sprint_r>:
80006d84:	d4 21       	pushm	r4-r7,lr
80006d86:	14 97       	mov	r7,r10
80006d88:	74 28       	ld.w	r8,r10[0x8]
80006d8a:	58 08       	cp.w	r8,0
80006d8c:	c0 41       	brne	80006d94 <__sprint_r+0x10>
80006d8e:	95 18       	st.w	r10[0x4],r8
80006d90:	10 9c       	mov	r12,r8
80006d92:	d8 22       	popm	r4-r7,pc
80006d94:	e0 a0 18 ba 	rcall	80009f08 <__sfvwrite_r>
80006d98:	30 08       	mov	r8,0
80006d9a:	8f 18       	st.w	r7[0x4],r8
80006d9c:	8f 28       	st.w	r7[0x8],r8
80006d9e:	d8 22       	popm	r4-r7,pc

80006da0 <_vfprintf_r>:
80006da0:	d4 31       	pushm	r0-r7,lr
80006da2:	fa cd 06 bc 	sub	sp,sp,1724
80006da6:	51 09       	stdsp	sp[0x40],r9
80006da8:	16 91       	mov	r1,r11
80006daa:	14 97       	mov	r7,r10
80006dac:	18 95       	mov	r5,r12
80006dae:	e0 a0 1a 1d 	rcall	8000a1e8 <_localeconv_r>
80006db2:	78 0c       	ld.w	r12,r12[0x0]
80006db4:	50 cc       	stdsp	sp[0x30],r12
80006db6:	58 05       	cp.w	r5,0
80006db8:	c0 70       	breq	80006dc6 <_vfprintf_r+0x26>
80006dba:	6a 68       	ld.w	r8,r5[0x18]
80006dbc:	58 08       	cp.w	r8,0
80006dbe:	c0 41       	brne	80006dc6 <_vfprintf_r+0x26>
80006dc0:	0a 9c       	mov	r12,r5
80006dc2:	e0 a0 17 43 	rcall	80009c48 <__sinit>
80006dc6:	fe c8 a2 d6 	sub	r8,pc,-23850
80006dca:	10 31       	cp.w	r1,r8
80006dcc:	c0 31       	brne	80006dd2 <_vfprintf_r+0x32>
80006dce:	6a 01       	ld.w	r1,r5[0x0]
80006dd0:	c0 c8       	rjmp	80006de8 <_vfprintf_r+0x48>
80006dd2:	fe c8 a2 c2 	sub	r8,pc,-23870
80006dd6:	10 31       	cp.w	r1,r8
80006dd8:	c0 31       	brne	80006dde <_vfprintf_r+0x3e>
80006dda:	6a 11       	ld.w	r1,r5[0x4]
80006ddc:	c0 68       	rjmp	80006de8 <_vfprintf_r+0x48>
80006dde:	fe c8 a2 ae 	sub	r8,pc,-23890
80006de2:	10 31       	cp.w	r1,r8
80006de4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006de8:	82 68       	ld.sh	r8,r1[0xc]
80006dea:	ed b8 00 03 	bld	r8,0x3
80006dee:	c0 41       	brne	80006df6 <_vfprintf_r+0x56>
80006df0:	62 48       	ld.w	r8,r1[0x10]
80006df2:	58 08       	cp.w	r8,0
80006df4:	c0 71       	brne	80006e02 <_vfprintf_r+0x62>
80006df6:	02 9b       	mov	r11,r1
80006df8:	0a 9c       	mov	r12,r5
80006dfa:	e0 a0 0f 5d 	rcall	80008cb4 <__swsetup_r>
80006dfe:	e0 81 0f 54 	brne	80008ca6 <_vfprintf_r+0x1f06>
80006e02:	82 68       	ld.sh	r8,r1[0xc]
80006e04:	10 99       	mov	r9,r8
80006e06:	e2 19 00 1a 	andl	r9,0x1a,COH
80006e0a:	58 a9       	cp.w	r9,10
80006e0c:	c3 c1       	brne	80006e84 <_vfprintf_r+0xe4>
80006e0e:	82 79       	ld.sh	r9,r1[0xe]
80006e10:	30 0a       	mov	r10,0
80006e12:	f4 09 19 00 	cp.h	r9,r10
80006e16:	c3 75       	brlt	80006e84 <_vfprintf_r+0xe4>
80006e18:	a1 d8       	cbr	r8,0x1
80006e1a:	fb 58 05 d0 	st.h	sp[1488],r8
80006e1e:	62 88       	ld.w	r8,r1[0x20]
80006e20:	fb 48 05 e4 	st.w	sp[1508],r8
80006e24:	62 a8       	ld.w	r8,r1[0x28]
80006e26:	fb 48 05 ec 	st.w	sp[1516],r8
80006e2a:	fa c8 ff bc 	sub	r8,sp,-68
80006e2e:	fb 48 05 d4 	st.w	sp[1492],r8
80006e32:	fb 48 05 c4 	st.w	sp[1476],r8
80006e36:	e0 68 04 00 	mov	r8,1024
80006e3a:	fb 48 05 d8 	st.w	sp[1496],r8
80006e3e:	fb 48 05 cc 	st.w	sp[1484],r8
80006e42:	30 08       	mov	r8,0
80006e44:	fb 59 05 d2 	st.h	sp[1490],r9
80006e48:	0e 9a       	mov	r10,r7
80006e4a:	41 09       	lddsp	r9,sp[0x40]
80006e4c:	fa c7 fa 3c 	sub	r7,sp,-1476
80006e50:	fb 48 05 dc 	st.w	sp[1500],r8
80006e54:	0a 9c       	mov	r12,r5
80006e56:	0e 9b       	mov	r11,r7
80006e58:	ca 4f       	rcall	80006da0 <_vfprintf_r>
80006e5a:	50 bc       	stdsp	sp[0x2c],r12
80006e5c:	c0 95       	brlt	80006e6e <_vfprintf_r+0xce>
80006e5e:	0e 9b       	mov	r11,r7
80006e60:	0a 9c       	mov	r12,r5
80006e62:	e0 a0 16 1b 	rcall	80009a98 <_fflush_r>
80006e66:	40 be       	lddsp	lr,sp[0x2c]
80006e68:	f9 be 01 ff 	movne	lr,-1
80006e6c:	50 be       	stdsp	sp[0x2c],lr
80006e6e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006e72:	ed b8 00 06 	bld	r8,0x6
80006e76:	e0 81 0f 1a 	brne	80008caa <_vfprintf_r+0x1f0a>
80006e7a:	82 68       	ld.sh	r8,r1[0xc]
80006e7c:	a7 a8       	sbr	r8,0x6
80006e7e:	a2 68       	st.h	r1[0xc],r8
80006e80:	e0 8f 0f 15 	bral	80008caa <_vfprintf_r+0x1f0a>
80006e84:	30 08       	mov	r8,0
80006e86:	fb 48 06 b4 	st.w	sp[1716],r8
80006e8a:	fb 48 06 90 	st.w	sp[1680],r8
80006e8e:	fb 48 06 8c 	st.w	sp[1676],r8
80006e92:	fb 48 06 b0 	st.w	sp[1712],r8
80006e96:	30 08       	mov	r8,0
80006e98:	30 09       	mov	r9,0
80006e9a:	50 a7       	stdsp	sp[0x28],r7
80006e9c:	50 78       	stdsp	sp[0x1c],r8
80006e9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80006ea2:	3f f8       	mov	r8,-1
80006ea4:	50 59       	stdsp	sp[0x14],r9
80006ea6:	fb 43 06 88 	st.w	sp[1672],r3
80006eaa:	fb 48 05 44 	st.w	sp[1348],r8
80006eae:	12 9c       	mov	r12,r9
80006eb0:	50 69       	stdsp	sp[0x18],r9
80006eb2:	50 d9       	stdsp	sp[0x34],r9
80006eb4:	50 e9       	stdsp	sp[0x38],r9
80006eb6:	50 b9       	stdsp	sp[0x2c],r9
80006eb8:	12 97       	mov	r7,r9
80006eba:	0a 94       	mov	r4,r5
80006ebc:	40 a2       	lddsp	r2,sp[0x28]
80006ebe:	32 5a       	mov	r10,37
80006ec0:	30 08       	mov	r8,0
80006ec2:	c0 28       	rjmp	80006ec6 <_vfprintf_r+0x126>
80006ec4:	2f f2       	sub	r2,-1
80006ec6:	05 89       	ld.ub	r9,r2[0x0]
80006ec8:	f0 09 18 00 	cp.b	r9,r8
80006ecc:	5f 1b       	srne	r11
80006ece:	f4 09 18 00 	cp.b	r9,r10
80006ed2:	5f 19       	srne	r9
80006ed4:	f3 eb 00 0b 	and	r11,r9,r11
80006ed8:	f0 0b 18 00 	cp.b	r11,r8
80006edc:	cf 41       	brne	80006ec4 <_vfprintf_r+0x124>
80006ede:	40 ab       	lddsp	r11,sp[0x28]
80006ee0:	e4 0b 01 06 	sub	r6,r2,r11
80006ee4:	c1 e0       	breq	80006f20 <_vfprintf_r+0x180>
80006ee6:	fa f8 06 90 	ld.w	r8,sp[1680]
80006eea:	0c 08       	add	r8,r6
80006eec:	87 0b       	st.w	r3[0x0],r11
80006eee:	fb 48 06 90 	st.w	sp[1680],r8
80006ef2:	87 16       	st.w	r3[0x4],r6
80006ef4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006ef8:	2f f8       	sub	r8,-1
80006efa:	fb 48 06 8c 	st.w	sp[1676],r8
80006efe:	58 78       	cp.w	r8,7
80006f00:	e0 89 00 04 	brgt	80006f08 <_vfprintf_r+0x168>
80006f04:	2f 83       	sub	r3,-8
80006f06:	c0 a8       	rjmp	80006f1a <_vfprintf_r+0x17a>
80006f08:	fa ca f9 78 	sub	r10,sp,-1672
80006f0c:	02 9b       	mov	r11,r1
80006f0e:	08 9c       	mov	r12,r4
80006f10:	c3 af       	rcall	80006d84 <__sprint_r>
80006f12:	e0 81 0e c6 	brne	80008c9e <_vfprintf_r+0x1efe>
80006f16:	fa c3 f9 e0 	sub	r3,sp,-1568
80006f1a:	40 ba       	lddsp	r10,sp[0x2c]
80006f1c:	0c 0a       	add	r10,r6
80006f1e:	50 ba       	stdsp	sp[0x2c],r10
80006f20:	05 89       	ld.ub	r9,r2[0x0]
80006f22:	30 08       	mov	r8,0
80006f24:	f0 09 18 00 	cp.b	r9,r8
80006f28:	e0 80 0e aa 	breq	80008c7c <_vfprintf_r+0x1edc>
80006f2c:	30 09       	mov	r9,0
80006f2e:	fb 68 06 bb 	st.b	sp[1723],r8
80006f32:	0e 96       	mov	r6,r7
80006f34:	e4 c8 ff ff 	sub	r8,r2,-1
80006f38:	3f fe       	mov	lr,-1
80006f3a:	50 93       	stdsp	sp[0x24],r3
80006f3c:	50 41       	stdsp	sp[0x10],r1
80006f3e:	0e 93       	mov	r3,r7
80006f40:	04 91       	mov	r1,r2
80006f42:	50 89       	stdsp	sp[0x20],r9
80006f44:	50 a8       	stdsp	sp[0x28],r8
80006f46:	50 2e       	stdsp	sp[0x8],lr
80006f48:	50 39       	stdsp	sp[0xc],r9
80006f4a:	12 95       	mov	r5,r9
80006f4c:	12 90       	mov	r0,r9
80006f4e:	10 97       	mov	r7,r8
80006f50:	08 92       	mov	r2,r4
80006f52:	c0 78       	rjmp	80006f60 <_vfprintf_r+0x1c0>
80006f54:	3f fc       	mov	r12,-1
80006f56:	08 97       	mov	r7,r4
80006f58:	50 2c       	stdsp	sp[0x8],r12
80006f5a:	c0 38       	rjmp	80006f60 <_vfprintf_r+0x1c0>
80006f5c:	30 0b       	mov	r11,0
80006f5e:	50 3b       	stdsp	sp[0xc],r11
80006f60:	0f 38       	ld.ub	r8,r7++
80006f62:	c0 28       	rjmp	80006f66 <_vfprintf_r+0x1c6>
80006f64:	12 90       	mov	r0,r9
80006f66:	f0 c9 00 20 	sub	r9,r8,32
80006f6a:	e0 49 00 58 	cp.w	r9,88
80006f6e:	e0 8b 0a 30 	brhi	800083ce <_vfprintf_r+0x162e>
80006f72:	fe ca a8 2a 	sub	r10,pc,-22486
80006f76:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006f7a:	50 a7       	stdsp	sp[0x28],r7
80006f7c:	50 80       	stdsp	sp[0x20],r0
80006f7e:	0c 97       	mov	r7,r6
80006f80:	04 94       	mov	r4,r2
80006f82:	06 96       	mov	r6,r3
80006f84:	02 92       	mov	r2,r1
80006f86:	fe c9 a6 02 	sub	r9,pc,-23038
80006f8a:	40 93       	lddsp	r3,sp[0x24]
80006f8c:	10 90       	mov	r0,r8
80006f8e:	40 41       	lddsp	r1,sp[0x10]
80006f90:	50 d9       	stdsp	sp[0x34],r9
80006f92:	e0 8f 08 8e 	bral	800080ae <_vfprintf_r+0x130e>
80006f96:	30 08       	mov	r8,0
80006f98:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006f9c:	f0 09 18 00 	cp.b	r9,r8
80006fa0:	ce 01       	brne	80006f60 <_vfprintf_r+0x1c0>
80006fa2:	32 08       	mov	r8,32
80006fa4:	c6 e8       	rjmp	80007080 <_vfprintf_r+0x2e0>
80006fa6:	a1 a5       	sbr	r5,0x0
80006fa8:	cd cb       	rjmp	80006f60 <_vfprintf_r+0x1c0>
80006faa:	0f 89       	ld.ub	r9,r7[0x0]
80006fac:	f2 c8 00 30 	sub	r8,r9,48
80006fb0:	58 98       	cp.w	r8,9
80006fb2:	e0 8b 00 1d 	brhi	80006fec <_vfprintf_r+0x24c>
80006fb6:	ee c8 ff ff 	sub	r8,r7,-1
80006fba:	30 0b       	mov	r11,0
80006fbc:	23 09       	sub	r9,48
80006fbe:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006fc2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80006fc6:	11 39       	ld.ub	r9,r8++
80006fc8:	f2 ca 00 30 	sub	r10,r9,48
80006fcc:	58 9a       	cp.w	r10,9
80006fce:	fe 98 ff f7 	brls	80006fbc <_vfprintf_r+0x21c>
80006fd2:	e0 49 00 24 	cp.w	r9,36
80006fd6:	cc 31       	brne	80006f5c <_vfprintf_r+0x1bc>
80006fd8:	e0 4b 00 20 	cp.w	r11,32
80006fdc:	e0 89 0e 60 	brgt	80008c9c <_vfprintf_r+0x1efc>
80006fe0:	20 1b       	sub	r11,1
80006fe2:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006fe6:	12 3b       	cp.w	r11,r9
80006fe8:	c0 95       	brlt	80006ffa <_vfprintf_r+0x25a>
80006fea:	c1 08       	rjmp	8000700a <_vfprintf_r+0x26a>
80006fec:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006ff0:	ec ca ff ff 	sub	r10,r6,-1
80006ff4:	12 36       	cp.w	r6,r9
80006ff6:	c1 f5       	brlt	80007034 <_vfprintf_r+0x294>
80006ff8:	c2 68       	rjmp	80007044 <_vfprintf_r+0x2a4>
80006ffa:	fa ce f9 44 	sub	lr,sp,-1724
80006ffe:	10 97       	mov	r7,r8
80007000:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007004:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007008:	c3 58       	rjmp	80007072 <_vfprintf_r+0x2d2>
8000700a:	10 97       	mov	r7,r8
8000700c:	fa c8 f9 50 	sub	r8,sp,-1712
80007010:	1a d8       	st.w	--sp,r8
80007012:	fa c8 fa b8 	sub	r8,sp,-1352
80007016:	1a d8       	st.w	--sp,r8
80007018:	fa c8 fb b4 	sub	r8,sp,-1100
8000701c:	02 9a       	mov	r10,r1
8000701e:	1a d8       	st.w	--sp,r8
80007020:	04 9c       	mov	r12,r2
80007022:	fa c8 f9 40 	sub	r8,sp,-1728
80007026:	fa c9 ff b4 	sub	r9,sp,-76
8000702a:	fe b0 fd 23 	rcall	80006a70 <get_arg>
8000702e:	2f dd       	sub	sp,-12
80007030:	78 00       	ld.w	r0,r12[0x0]
80007032:	c2 08       	rjmp	80007072 <_vfprintf_r+0x2d2>
80007034:	fa cc f9 44 	sub	r12,sp,-1724
80007038:	14 96       	mov	r6,r10
8000703a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000703e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007042:	c1 88       	rjmp	80007072 <_vfprintf_r+0x2d2>
80007044:	41 08       	lddsp	r8,sp[0x40]
80007046:	59 f9       	cp.w	r9,31
80007048:	e0 89 00 11 	brgt	8000706a <_vfprintf_r+0x2ca>
8000704c:	f0 cb ff fc 	sub	r11,r8,-4
80007050:	51 0b       	stdsp	sp[0x40],r11
80007052:	70 00       	ld.w	r0,r8[0x0]
80007054:	fa cb f9 44 	sub	r11,sp,-1724
80007058:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000705c:	f1 40 fd 88 	st.w	r8[-632],r0
80007060:	2f f9       	sub	r9,-1
80007062:	14 96       	mov	r6,r10
80007064:	fb 49 06 b4 	st.w	sp[1716],r9
80007068:	c0 58       	rjmp	80007072 <_vfprintf_r+0x2d2>
8000706a:	70 00       	ld.w	r0,r8[0x0]
8000706c:	14 96       	mov	r6,r10
8000706e:	2f c8       	sub	r8,-4
80007070:	51 08       	stdsp	sp[0x40],r8
80007072:	58 00       	cp.w	r0,0
80007074:	fe 94 ff 76 	brge	80006f60 <_vfprintf_r+0x1c0>
80007078:	5c 30       	neg	r0
8000707a:	a3 a5       	sbr	r5,0x2
8000707c:	c7 2b       	rjmp	80006f60 <_vfprintf_r+0x1c0>
8000707e:	32 b8       	mov	r8,43
80007080:	fb 68 06 bb 	st.b	sp[1723],r8
80007084:	c6 eb       	rjmp	80006f60 <_vfprintf_r+0x1c0>
80007086:	0f 38       	ld.ub	r8,r7++
80007088:	e0 48 00 2a 	cp.w	r8,42
8000708c:	c0 30       	breq	80007092 <_vfprintf_r+0x2f2>
8000708e:	30 09       	mov	r9,0
80007090:	c7 98       	rjmp	80007182 <_vfprintf_r+0x3e2>
80007092:	0f 88       	ld.ub	r8,r7[0x0]
80007094:	f0 c9 00 30 	sub	r9,r8,48
80007098:	58 99       	cp.w	r9,9
8000709a:	e0 8b 00 1f 	brhi	800070d8 <_vfprintf_r+0x338>
8000709e:	ee c4 ff ff 	sub	r4,r7,-1
800070a2:	30 0b       	mov	r11,0
800070a4:	23 08       	sub	r8,48
800070a6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800070aa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800070ae:	09 38       	ld.ub	r8,r4++
800070b0:	f0 c9 00 30 	sub	r9,r8,48
800070b4:	58 99       	cp.w	r9,9
800070b6:	fe 98 ff f7 	brls	800070a4 <_vfprintf_r+0x304>
800070ba:	e0 48 00 24 	cp.w	r8,36
800070be:	fe 91 ff 4f 	brne	80006f5c <_vfprintf_r+0x1bc>
800070c2:	e0 4b 00 20 	cp.w	r11,32
800070c6:	e0 89 0d eb 	brgt	80008c9c <_vfprintf_r+0x1efc>
800070ca:	20 1b       	sub	r11,1
800070cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800070d0:	10 3b       	cp.w	r11,r8
800070d2:	c0 a5       	brlt	800070e6 <_vfprintf_r+0x346>
800070d4:	c1 18       	rjmp	800070f6 <_vfprintf_r+0x356>
800070d6:	d7 03       	nop
800070d8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800070dc:	ec c9 ff ff 	sub	r9,r6,-1
800070e0:	14 36       	cp.w	r6,r10
800070e2:	c1 f5       	brlt	80007120 <_vfprintf_r+0x380>
800070e4:	c2 88       	rjmp	80007134 <_vfprintf_r+0x394>
800070e6:	fa ca f9 44 	sub	r10,sp,-1724
800070ea:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800070ee:	f6 fb fd 88 	ld.w	r11,r11[-632]
800070f2:	50 2b       	stdsp	sp[0x8],r11
800070f4:	c3 c8       	rjmp	8000716c <_vfprintf_r+0x3cc>
800070f6:	fa c8 f9 50 	sub	r8,sp,-1712
800070fa:	1a d8       	st.w	--sp,r8
800070fc:	fa c8 fa b8 	sub	r8,sp,-1352
80007100:	1a d8       	st.w	--sp,r8
80007102:	fa c8 fb b4 	sub	r8,sp,-1100
80007106:	02 9a       	mov	r10,r1
80007108:	1a d8       	st.w	--sp,r8
8000710a:	04 9c       	mov	r12,r2
8000710c:	fa c8 f9 40 	sub	r8,sp,-1728
80007110:	fa c9 ff b4 	sub	r9,sp,-76
80007114:	fe b0 fc ae 	rcall	80006a70 <get_arg>
80007118:	2f dd       	sub	sp,-12
8000711a:	78 0c       	ld.w	r12,r12[0x0]
8000711c:	50 2c       	stdsp	sp[0x8],r12
8000711e:	c2 78       	rjmp	8000716c <_vfprintf_r+0x3cc>
80007120:	12 96       	mov	r6,r9
80007122:	0e 94       	mov	r4,r7
80007124:	fa c9 f9 44 	sub	r9,sp,-1724
80007128:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000712c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007130:	50 28       	stdsp	sp[0x8],r8
80007132:	c1 d8       	rjmp	8000716c <_vfprintf_r+0x3cc>
80007134:	41 08       	lddsp	r8,sp[0x40]
80007136:	59 fa       	cp.w	r10,31
80007138:	e0 89 00 14 	brgt	80007160 <_vfprintf_r+0x3c0>
8000713c:	f0 cb ff fc 	sub	r11,r8,-4
80007140:	70 08       	ld.w	r8,r8[0x0]
80007142:	51 0b       	stdsp	sp[0x40],r11
80007144:	50 28       	stdsp	sp[0x8],r8
80007146:	fa c6 f9 44 	sub	r6,sp,-1724
8000714a:	40 2e       	lddsp	lr,sp[0x8]
8000714c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007150:	f1 4e fd 88 	st.w	r8[-632],lr
80007154:	2f fa       	sub	r10,-1
80007156:	0e 94       	mov	r4,r7
80007158:	fb 4a 06 b4 	st.w	sp[1716],r10
8000715c:	12 96       	mov	r6,r9
8000715e:	c0 78       	rjmp	8000716c <_vfprintf_r+0x3cc>
80007160:	70 0c       	ld.w	r12,r8[0x0]
80007162:	0e 94       	mov	r4,r7
80007164:	2f c8       	sub	r8,-4
80007166:	50 2c       	stdsp	sp[0x8],r12
80007168:	12 96       	mov	r6,r9
8000716a:	51 08       	stdsp	sp[0x40],r8
8000716c:	40 2b       	lddsp	r11,sp[0x8]
8000716e:	58 0b       	cp.w	r11,0
80007170:	fe 95 fe f2 	brlt	80006f54 <_vfprintf_r+0x1b4>
80007174:	08 97       	mov	r7,r4
80007176:	cf 5a       	rjmp	80006f60 <_vfprintf_r+0x1c0>
80007178:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000717c:	0f 38       	ld.ub	r8,r7++
8000717e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007182:	f0 ca 00 30 	sub	r10,r8,48
80007186:	58 9a       	cp.w	r10,9
80007188:	fe 98 ff f8 	brls	80007178 <_vfprintf_r+0x3d8>
8000718c:	3f fa       	mov	r10,-1
8000718e:	f2 0a 0c 49 	max	r9,r9,r10
80007192:	50 29       	stdsp	sp[0x8],r9
80007194:	ce 9a       	rjmp	80006f66 <_vfprintf_r+0x1c6>
80007196:	a7 b5       	sbr	r5,0x7
80007198:	ce 4a       	rjmp	80006f60 <_vfprintf_r+0x1c0>
8000719a:	30 09       	mov	r9,0
8000719c:	23 08       	sub	r8,48
8000719e:	f2 09 00 29 	add	r9,r9,r9<<0x2
800071a2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800071a6:	0f 38       	ld.ub	r8,r7++
800071a8:	f0 ca 00 30 	sub	r10,r8,48
800071ac:	58 9a       	cp.w	r10,9
800071ae:	fe 98 ff f7 	brls	8000719c <_vfprintf_r+0x3fc>
800071b2:	e0 48 00 24 	cp.w	r8,36
800071b6:	fe 91 fe d7 	brne	80006f64 <_vfprintf_r+0x1c4>
800071ba:	e0 49 00 20 	cp.w	r9,32
800071be:	e0 89 0d 6f 	brgt	80008c9c <_vfprintf_r+0x1efc>
800071c2:	f2 c3 00 01 	sub	r3,r9,1
800071c6:	30 19       	mov	r9,1
800071c8:	50 39       	stdsp	sp[0xc],r9
800071ca:	cc ba       	rjmp	80006f60 <_vfprintf_r+0x1c0>
800071cc:	a3 b5       	sbr	r5,0x3
800071ce:	cc 9a       	rjmp	80006f60 <_vfprintf_r+0x1c0>
800071d0:	a7 a5       	sbr	r5,0x6
800071d2:	cc 7a       	rjmp	80006f60 <_vfprintf_r+0x1c0>
800071d4:	0a 98       	mov	r8,r5
800071d6:	a5 b5       	sbr	r5,0x5
800071d8:	a5 a8       	sbr	r8,0x4
800071da:	0f 89       	ld.ub	r9,r7[0x0]
800071dc:	36 ce       	mov	lr,108
800071de:	fc 09 18 00 	cp.b	r9,lr
800071e2:	f7 b7 00 ff 	subeq	r7,-1
800071e6:	f0 05 17 10 	movne	r5,r8
800071ea:	cb ba       	rjmp	80006f60 <_vfprintf_r+0x1c0>
800071ec:	a5 b5       	sbr	r5,0x5
800071ee:	cb 9a       	rjmp	80006f60 <_vfprintf_r+0x1c0>
800071f0:	50 a7       	stdsp	sp[0x28],r7
800071f2:	50 80       	stdsp	sp[0x20],r0
800071f4:	0c 97       	mov	r7,r6
800071f6:	10 90       	mov	r0,r8
800071f8:	06 96       	mov	r6,r3
800071fa:	04 94       	mov	r4,r2
800071fc:	40 93       	lddsp	r3,sp[0x24]
800071fe:	02 92       	mov	r2,r1
80007200:	0e 99       	mov	r9,r7
80007202:	40 41       	lddsp	r1,sp[0x10]
80007204:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007208:	40 3c       	lddsp	r12,sp[0xc]
8000720a:	58 0c       	cp.w	r12,0
8000720c:	c1 d0       	breq	80007246 <_vfprintf_r+0x4a6>
8000720e:	10 36       	cp.w	r6,r8
80007210:	c0 64       	brge	8000721c <_vfprintf_r+0x47c>
80007212:	fa cb f9 44 	sub	r11,sp,-1724
80007216:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000721a:	c1 d8       	rjmp	80007254 <_vfprintf_r+0x4b4>
8000721c:	fa c8 f9 50 	sub	r8,sp,-1712
80007220:	1a d8       	st.w	--sp,r8
80007222:	fa c8 fa b8 	sub	r8,sp,-1352
80007226:	1a d8       	st.w	--sp,r8
80007228:	fa c8 fb b4 	sub	r8,sp,-1100
8000722c:	1a d8       	st.w	--sp,r8
8000722e:	fa c8 f9 40 	sub	r8,sp,-1728
80007232:	fa c9 ff b4 	sub	r9,sp,-76
80007236:	04 9a       	mov	r10,r2
80007238:	0c 9b       	mov	r11,r6
8000723a:	08 9c       	mov	r12,r4
8000723c:	fe b0 fc 1a 	rcall	80006a70 <get_arg>
80007240:	2f dd       	sub	sp,-12
80007242:	19 b8       	ld.ub	r8,r12[0x3]
80007244:	c2 28       	rjmp	80007288 <_vfprintf_r+0x4e8>
80007246:	2f f7       	sub	r7,-1
80007248:	10 39       	cp.w	r9,r8
8000724a:	c0 84       	brge	8000725a <_vfprintf_r+0x4ba>
8000724c:	fa ca f9 44 	sub	r10,sp,-1724
80007250:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007254:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007258:	c1 88       	rjmp	80007288 <_vfprintf_r+0x4e8>
8000725a:	41 09       	lddsp	r9,sp[0x40]
8000725c:	59 f8       	cp.w	r8,31
8000725e:	e0 89 00 12 	brgt	80007282 <_vfprintf_r+0x4e2>
80007262:	f2 ca ff fc 	sub	r10,r9,-4
80007266:	51 0a       	stdsp	sp[0x40],r10
80007268:	72 09       	ld.w	r9,r9[0x0]
8000726a:	fa c6 f9 44 	sub	r6,sp,-1724
8000726e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007272:	2f f8       	sub	r8,-1
80007274:	f5 49 fd 88 	st.w	r10[-632],r9
80007278:	fb 48 06 b4 	st.w	sp[1716],r8
8000727c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007280:	c0 48       	rjmp	80007288 <_vfprintf_r+0x4e8>
80007282:	13 b8       	ld.ub	r8,r9[0x3]
80007284:	2f c9       	sub	r9,-4
80007286:	51 09       	stdsp	sp[0x40],r9
80007288:	fb 68 06 60 	st.b	sp[1632],r8
8000728c:	30 0e       	mov	lr,0
8000728e:	30 08       	mov	r8,0
80007290:	30 12       	mov	r2,1
80007292:	fb 68 06 bb 	st.b	sp[1723],r8
80007296:	50 2e       	stdsp	sp[0x8],lr
80007298:	e0 8f 08 ad 	bral	800083f2 <_vfprintf_r+0x1652>
8000729c:	50 a7       	stdsp	sp[0x28],r7
8000729e:	50 80       	stdsp	sp[0x20],r0
800072a0:	0c 97       	mov	r7,r6
800072a2:	04 94       	mov	r4,r2
800072a4:	06 96       	mov	r6,r3
800072a6:	02 92       	mov	r2,r1
800072a8:	40 93       	lddsp	r3,sp[0x24]
800072aa:	10 90       	mov	r0,r8
800072ac:	40 41       	lddsp	r1,sp[0x10]
800072ae:	a5 a5       	sbr	r5,0x4
800072b0:	c0 a8       	rjmp	800072c4 <_vfprintf_r+0x524>
800072b2:	50 a7       	stdsp	sp[0x28],r7
800072b4:	50 80       	stdsp	sp[0x20],r0
800072b6:	0c 97       	mov	r7,r6
800072b8:	04 94       	mov	r4,r2
800072ba:	06 96       	mov	r6,r3
800072bc:	02 92       	mov	r2,r1
800072be:	40 93       	lddsp	r3,sp[0x24]
800072c0:	10 90       	mov	r0,r8
800072c2:	40 41       	lddsp	r1,sp[0x10]
800072c4:	ed b5 00 05 	bld	r5,0x5
800072c8:	c5 11       	brne	8000736a <_vfprintf_r+0x5ca>
800072ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800072ce:	40 3c       	lddsp	r12,sp[0xc]
800072d0:	58 0c       	cp.w	r12,0
800072d2:	c1 e0       	breq	8000730e <_vfprintf_r+0x56e>
800072d4:	10 36       	cp.w	r6,r8
800072d6:	c0 64       	brge	800072e2 <_vfprintf_r+0x542>
800072d8:	fa cb f9 44 	sub	r11,sp,-1724
800072dc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800072e0:	c2 08       	rjmp	80007320 <_vfprintf_r+0x580>
800072e2:	fa c8 f9 50 	sub	r8,sp,-1712
800072e6:	1a d8       	st.w	--sp,r8
800072e8:	fa c8 fa b8 	sub	r8,sp,-1352
800072ec:	0c 9b       	mov	r11,r6
800072ee:	1a d8       	st.w	--sp,r8
800072f0:	fa c8 fb b4 	sub	r8,sp,-1100
800072f4:	1a d8       	st.w	--sp,r8
800072f6:	fa c9 ff b4 	sub	r9,sp,-76
800072fa:	fa c8 f9 40 	sub	r8,sp,-1728
800072fe:	04 9a       	mov	r10,r2
80007300:	08 9c       	mov	r12,r4
80007302:	fe b0 fb b7 	rcall	80006a70 <get_arg>
80007306:	2f dd       	sub	sp,-12
80007308:	78 1b       	ld.w	r11,r12[0x4]
8000730a:	78 09       	ld.w	r9,r12[0x0]
8000730c:	c2 b8       	rjmp	80007362 <_vfprintf_r+0x5c2>
8000730e:	ee ca ff ff 	sub	r10,r7,-1
80007312:	10 37       	cp.w	r7,r8
80007314:	c0 b4       	brge	8000732a <_vfprintf_r+0x58a>
80007316:	fa c9 f9 44 	sub	r9,sp,-1724
8000731a:	14 97       	mov	r7,r10
8000731c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007320:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007324:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007328:	c1 d8       	rjmp	80007362 <_vfprintf_r+0x5c2>
8000732a:	41 09       	lddsp	r9,sp[0x40]
8000732c:	59 f8       	cp.w	r8,31
8000732e:	e0 89 00 14 	brgt	80007356 <_vfprintf_r+0x5b6>
80007332:	f2 cb ff f8 	sub	r11,r9,-8
80007336:	51 0b       	stdsp	sp[0x40],r11
80007338:	fa c6 f9 44 	sub	r6,sp,-1724
8000733c:	72 1b       	ld.w	r11,r9[0x4]
8000733e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007342:	72 09       	ld.w	r9,r9[0x0]
80007344:	f9 4b fd 8c 	st.w	r12[-628],r11
80007348:	f9 49 fd 88 	st.w	r12[-632],r9
8000734c:	2f f8       	sub	r8,-1
8000734e:	14 97       	mov	r7,r10
80007350:	fb 48 06 b4 	st.w	sp[1716],r8
80007354:	c0 78       	rjmp	80007362 <_vfprintf_r+0x5c2>
80007356:	f2 c8 ff f8 	sub	r8,r9,-8
8000735a:	72 1b       	ld.w	r11,r9[0x4]
8000735c:	14 97       	mov	r7,r10
8000735e:	51 08       	stdsp	sp[0x40],r8
80007360:	72 09       	ld.w	r9,r9[0x0]
80007362:	16 98       	mov	r8,r11
80007364:	fa e9 00 00 	st.d	sp[0],r8
80007368:	ca e8       	rjmp	800074c4 <_vfprintf_r+0x724>
8000736a:	ed b5 00 04 	bld	r5,0x4
8000736e:	c1 71       	brne	8000739c <_vfprintf_r+0x5fc>
80007370:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007374:	40 3e       	lddsp	lr,sp[0xc]
80007376:	58 0e       	cp.w	lr,0
80007378:	c0 80       	breq	80007388 <_vfprintf_r+0x5e8>
8000737a:	10 36       	cp.w	r6,r8
8000737c:	c6 94       	brge	8000744e <_vfprintf_r+0x6ae>
8000737e:	fa cc f9 44 	sub	r12,sp,-1724
80007382:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007386:	c8 28       	rjmp	8000748a <_vfprintf_r+0x6ea>
80007388:	ee ca ff ff 	sub	r10,r7,-1
8000738c:	10 37       	cp.w	r7,r8
8000738e:	e0 84 00 81 	brge	80007490 <_vfprintf_r+0x6f0>
80007392:	fa cb f9 44 	sub	r11,sp,-1724
80007396:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000739a:	c7 78       	rjmp	80007488 <_vfprintf_r+0x6e8>
8000739c:	ed b5 00 06 	bld	r5,0x6
800073a0:	c4 b1       	brne	80007436 <_vfprintf_r+0x696>
800073a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073a6:	40 3c       	lddsp	r12,sp[0xc]
800073a8:	58 0c       	cp.w	r12,0
800073aa:	c1 d0       	breq	800073e4 <_vfprintf_r+0x644>
800073ac:	10 36       	cp.w	r6,r8
800073ae:	c0 64       	brge	800073ba <_vfprintf_r+0x61a>
800073b0:	fa cb f9 44 	sub	r11,sp,-1724
800073b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800073b8:	c1 f8       	rjmp	800073f6 <_vfprintf_r+0x656>
800073ba:	fa c8 f9 50 	sub	r8,sp,-1712
800073be:	1a d8       	st.w	--sp,r8
800073c0:	fa c8 fa b8 	sub	r8,sp,-1352
800073c4:	1a d8       	st.w	--sp,r8
800073c6:	fa c8 fb b4 	sub	r8,sp,-1100
800073ca:	1a d8       	st.w	--sp,r8
800073cc:	fa c8 f9 40 	sub	r8,sp,-1728
800073d0:	fa c9 ff b4 	sub	r9,sp,-76
800073d4:	04 9a       	mov	r10,r2
800073d6:	0c 9b       	mov	r11,r6
800073d8:	08 9c       	mov	r12,r4
800073da:	fe b0 fb 4b 	rcall	80006a70 <get_arg>
800073de:	2f dd       	sub	sp,-12
800073e0:	98 18       	ld.sh	r8,r12[0x2]
800073e2:	c2 68       	rjmp	8000742e <_vfprintf_r+0x68e>
800073e4:	ee ca ff ff 	sub	r10,r7,-1
800073e8:	10 37       	cp.w	r7,r8
800073ea:	c0 94       	brge	800073fc <_vfprintf_r+0x65c>
800073ec:	fa c9 f9 44 	sub	r9,sp,-1724
800073f0:	14 97       	mov	r7,r10
800073f2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800073f6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800073fa:	c1 a8       	rjmp	8000742e <_vfprintf_r+0x68e>
800073fc:	41 09       	lddsp	r9,sp[0x40]
800073fe:	59 f8       	cp.w	r8,31
80007400:	e0 89 00 13 	brgt	80007426 <_vfprintf_r+0x686>
80007404:	f2 cb ff fc 	sub	r11,r9,-4
80007408:	51 0b       	stdsp	sp[0x40],r11
8000740a:	72 09       	ld.w	r9,r9[0x0]
8000740c:	fa c6 f9 44 	sub	r6,sp,-1724
80007410:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007414:	2f f8       	sub	r8,-1
80007416:	f7 49 fd 88 	st.w	r11[-632],r9
8000741a:	fb 48 06 b4 	st.w	sp[1716],r8
8000741e:	14 97       	mov	r7,r10
80007420:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007424:	c0 58       	rjmp	8000742e <_vfprintf_r+0x68e>
80007426:	92 18       	ld.sh	r8,r9[0x2]
80007428:	14 97       	mov	r7,r10
8000742a:	2f c9       	sub	r9,-4
8000742c:	51 09       	stdsp	sp[0x40],r9
8000742e:	50 18       	stdsp	sp[0x4],r8
80007430:	bf 58       	asr	r8,0x1f
80007432:	50 08       	stdsp	sp[0x0],r8
80007434:	c4 88       	rjmp	800074c4 <_vfprintf_r+0x724>
80007436:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000743a:	40 3c       	lddsp	r12,sp[0xc]
8000743c:	58 0c       	cp.w	r12,0
8000743e:	c1 d0       	breq	80007478 <_vfprintf_r+0x6d8>
80007440:	10 36       	cp.w	r6,r8
80007442:	c0 64       	brge	8000744e <_vfprintf_r+0x6ae>
80007444:	fa cb f9 44 	sub	r11,sp,-1724
80007448:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000744c:	c1 f8       	rjmp	8000748a <_vfprintf_r+0x6ea>
8000744e:	fa c8 f9 50 	sub	r8,sp,-1712
80007452:	1a d8       	st.w	--sp,r8
80007454:	fa c8 fa b8 	sub	r8,sp,-1352
80007458:	0c 9b       	mov	r11,r6
8000745a:	1a d8       	st.w	--sp,r8
8000745c:	fa c8 fb b4 	sub	r8,sp,-1100
80007460:	04 9a       	mov	r10,r2
80007462:	1a d8       	st.w	--sp,r8
80007464:	08 9c       	mov	r12,r4
80007466:	fa c8 f9 40 	sub	r8,sp,-1728
8000746a:	fa c9 ff b4 	sub	r9,sp,-76
8000746e:	fe b0 fb 01 	rcall	80006a70 <get_arg>
80007472:	2f dd       	sub	sp,-12
80007474:	78 0b       	ld.w	r11,r12[0x0]
80007476:	c2 48       	rjmp	800074be <_vfprintf_r+0x71e>
80007478:	ee ca ff ff 	sub	r10,r7,-1
8000747c:	10 37       	cp.w	r7,r8
8000747e:	c0 94       	brge	80007490 <_vfprintf_r+0x6f0>
80007480:	fa c9 f9 44 	sub	r9,sp,-1724
80007484:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007488:	14 97       	mov	r7,r10
8000748a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000748e:	c1 88       	rjmp	800074be <_vfprintf_r+0x71e>
80007490:	41 09       	lddsp	r9,sp[0x40]
80007492:	59 f8       	cp.w	r8,31
80007494:	e0 89 00 11 	brgt	800074b6 <_vfprintf_r+0x716>
80007498:	f2 cb ff fc 	sub	r11,r9,-4
8000749c:	51 0b       	stdsp	sp[0x40],r11
8000749e:	fa c6 f9 44 	sub	r6,sp,-1724
800074a2:	72 0b       	ld.w	r11,r9[0x0]
800074a4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800074a8:	f3 4b fd 88 	st.w	r9[-632],r11
800074ac:	2f f8       	sub	r8,-1
800074ae:	14 97       	mov	r7,r10
800074b0:	fb 48 06 b4 	st.w	sp[1716],r8
800074b4:	c0 58       	rjmp	800074be <_vfprintf_r+0x71e>
800074b6:	72 0b       	ld.w	r11,r9[0x0]
800074b8:	14 97       	mov	r7,r10
800074ba:	2f c9       	sub	r9,-4
800074bc:	51 09       	stdsp	sp[0x40],r9
800074be:	50 1b       	stdsp	sp[0x4],r11
800074c0:	bf 5b       	asr	r11,0x1f
800074c2:	50 0b       	stdsp	sp[0x0],r11
800074c4:	fa ea 00 00 	ld.d	r10,sp[0]
800074c8:	58 0a       	cp.w	r10,0
800074ca:	5c 2b       	cpc	r11
800074cc:	c0 e4       	brge	800074e8 <_vfprintf_r+0x748>
800074ce:	30 08       	mov	r8,0
800074d0:	fa ea 00 00 	ld.d	r10,sp[0]
800074d4:	30 09       	mov	r9,0
800074d6:	f0 0a 01 0a 	sub	r10,r8,r10
800074da:	f2 0b 01 4b 	sbc	r11,r9,r11
800074de:	32 d8       	mov	r8,45
800074e0:	fa eb 00 00 	st.d	sp[0],r10
800074e4:	fb 68 06 bb 	st.b	sp[1723],r8
800074e8:	30 18       	mov	r8,1
800074ea:	e0 8f 06 fa 	bral	800082de <_vfprintf_r+0x153e>
800074ee:	50 a7       	stdsp	sp[0x28],r7
800074f0:	50 80       	stdsp	sp[0x20],r0
800074f2:	0c 97       	mov	r7,r6
800074f4:	04 94       	mov	r4,r2
800074f6:	06 96       	mov	r6,r3
800074f8:	02 92       	mov	r2,r1
800074fa:	40 93       	lddsp	r3,sp[0x24]
800074fc:	10 90       	mov	r0,r8
800074fe:	40 41       	lddsp	r1,sp[0x10]
80007500:	0e 99       	mov	r9,r7
80007502:	ed b5 00 03 	bld	r5,0x3
80007506:	c4 11       	brne	80007588 <_vfprintf_r+0x7e8>
80007508:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000750c:	40 3a       	lddsp	r10,sp[0xc]
8000750e:	58 0a       	cp.w	r10,0
80007510:	c1 90       	breq	80007542 <_vfprintf_r+0x7a2>
80007512:	10 36       	cp.w	r6,r8
80007514:	c6 45       	brlt	800075dc <_vfprintf_r+0x83c>
80007516:	fa c8 f9 50 	sub	r8,sp,-1712
8000751a:	1a d8       	st.w	--sp,r8
8000751c:	fa c8 fa b8 	sub	r8,sp,-1352
80007520:	1a d8       	st.w	--sp,r8
80007522:	fa c8 fb b4 	sub	r8,sp,-1100
80007526:	0c 9b       	mov	r11,r6
80007528:	1a d8       	st.w	--sp,r8
8000752a:	04 9a       	mov	r10,r2
8000752c:	fa c8 f9 40 	sub	r8,sp,-1728
80007530:	fa c9 ff b4 	sub	r9,sp,-76
80007534:	08 9c       	mov	r12,r4
80007536:	fe b0 fa 9d 	rcall	80006a70 <get_arg>
8000753a:	2f dd       	sub	sp,-12
8000753c:	78 16       	ld.w	r6,r12[0x4]
8000753e:	50 76       	stdsp	sp[0x1c],r6
80007540:	c4 88       	rjmp	800075d0 <_vfprintf_r+0x830>
80007542:	2f f7       	sub	r7,-1
80007544:	10 39       	cp.w	r9,r8
80007546:	c0 c4       	brge	8000755e <_vfprintf_r+0x7be>
80007548:	fa ce f9 44 	sub	lr,sp,-1724
8000754c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007550:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007554:	50 7c       	stdsp	sp[0x1c],r12
80007556:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000755a:	50 56       	stdsp	sp[0x14],r6
8000755c:	c6 68       	rjmp	80007628 <_vfprintf_r+0x888>
8000755e:	41 09       	lddsp	r9,sp[0x40]
80007560:	59 f8       	cp.w	r8,31
80007562:	e0 89 00 10 	brgt	80007582 <_vfprintf_r+0x7e2>
80007566:	f2 ca ff f8 	sub	r10,r9,-8
8000756a:	72 1b       	ld.w	r11,r9[0x4]
8000756c:	51 0a       	stdsp	sp[0x40],r10
8000756e:	72 09       	ld.w	r9,r9[0x0]
80007570:	fa ca f9 44 	sub	r10,sp,-1724
80007574:	50 7b       	stdsp	sp[0x1c],r11
80007576:	50 59       	stdsp	sp[0x14],r9
80007578:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000757c:	40 5b       	lddsp	r11,sp[0x14]
8000757e:	40 7a       	lddsp	r10,sp[0x1c]
80007580:	c4 78       	rjmp	8000760e <_vfprintf_r+0x86e>
80007582:	72 18       	ld.w	r8,r9[0x4]
80007584:	50 78       	stdsp	sp[0x1c],r8
80007586:	c4 c8       	rjmp	8000761e <_vfprintf_r+0x87e>
80007588:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000758c:	40 3e       	lddsp	lr,sp[0xc]
8000758e:	58 0e       	cp.w	lr,0
80007590:	c2 30       	breq	800075d6 <_vfprintf_r+0x836>
80007592:	10 36       	cp.w	r6,r8
80007594:	c0 94       	brge	800075a6 <_vfprintf_r+0x806>
80007596:	fa cc f9 44 	sub	r12,sp,-1724
8000759a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000759e:	ec fb fd 8c 	ld.w	r11,r6[-628]
800075a2:	50 7b       	stdsp	sp[0x1c],r11
800075a4:	cd 9b       	rjmp	80007556 <_vfprintf_r+0x7b6>
800075a6:	fa c8 f9 50 	sub	r8,sp,-1712
800075aa:	1a d8       	st.w	--sp,r8
800075ac:	fa c8 fa b8 	sub	r8,sp,-1352
800075b0:	04 9a       	mov	r10,r2
800075b2:	1a d8       	st.w	--sp,r8
800075b4:	fa c8 fb b4 	sub	r8,sp,-1100
800075b8:	0c 9b       	mov	r11,r6
800075ba:	1a d8       	st.w	--sp,r8
800075bc:	08 9c       	mov	r12,r4
800075be:	fa c8 f9 40 	sub	r8,sp,-1728
800075c2:	fa c9 ff b4 	sub	r9,sp,-76
800075c6:	fe b0 fa 55 	rcall	80006a70 <get_arg>
800075ca:	2f dd       	sub	sp,-12
800075cc:	78 1a       	ld.w	r10,r12[0x4]
800075ce:	50 7a       	stdsp	sp[0x1c],r10
800075d0:	78 0c       	ld.w	r12,r12[0x0]
800075d2:	50 5c       	stdsp	sp[0x14],r12
800075d4:	c2 a8       	rjmp	80007628 <_vfprintf_r+0x888>
800075d6:	2f f7       	sub	r7,-1
800075d8:	10 39       	cp.w	r9,r8
800075da:	c0 94       	brge	800075ec <_vfprintf_r+0x84c>
800075dc:	fa c9 f9 44 	sub	r9,sp,-1724
800075e0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800075e4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800075e8:	50 78       	stdsp	sp[0x1c],r8
800075ea:	cb 6b       	rjmp	80007556 <_vfprintf_r+0x7b6>
800075ec:	41 09       	lddsp	r9,sp[0x40]
800075ee:	59 f8       	cp.w	r8,31
800075f0:	e0 89 00 15 	brgt	8000761a <_vfprintf_r+0x87a>
800075f4:	f2 ca ff f8 	sub	r10,r9,-8
800075f8:	72 16       	ld.w	r6,r9[0x4]
800075fa:	72 09       	ld.w	r9,r9[0x0]
800075fc:	51 0a       	stdsp	sp[0x40],r10
800075fe:	50 59       	stdsp	sp[0x14],r9
80007600:	fa ce f9 44 	sub	lr,sp,-1724
80007604:	50 76       	stdsp	sp[0x1c],r6
80007606:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000760a:	40 5b       	lddsp	r11,sp[0x14]
8000760c:	0c 9a       	mov	r10,r6
8000760e:	f2 eb fd 88 	st.d	r9[-632],r10
80007612:	2f f8       	sub	r8,-1
80007614:	fb 48 06 b4 	st.w	sp[1716],r8
80007618:	c0 88       	rjmp	80007628 <_vfprintf_r+0x888>
8000761a:	72 1c       	ld.w	r12,r9[0x4]
8000761c:	50 7c       	stdsp	sp[0x1c],r12
8000761e:	f2 c8 ff f8 	sub	r8,r9,-8
80007622:	51 08       	stdsp	sp[0x40],r8
80007624:	72 09       	ld.w	r9,r9[0x0]
80007626:	50 59       	stdsp	sp[0x14],r9
80007628:	40 5b       	lddsp	r11,sp[0x14]
8000762a:	40 7a       	lddsp	r10,sp[0x1c]
8000762c:	e0 a0 19 54 	rcall	8000a8d4 <__isinfd>
80007630:	18 96       	mov	r6,r12
80007632:	c1 70       	breq	80007660 <_vfprintf_r+0x8c0>
80007634:	30 08       	mov	r8,0
80007636:	30 09       	mov	r9,0
80007638:	40 5b       	lddsp	r11,sp[0x14]
8000763a:	40 7a       	lddsp	r10,sp[0x1c]
8000763c:	e0 a0 1d b4 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
80007640:	c0 40       	breq	80007648 <_vfprintf_r+0x8a8>
80007642:	32 d8       	mov	r8,45
80007644:	fb 68 06 bb 	st.b	sp[1723],r8
80007648:	fe c8 ac b0 	sub	r8,pc,-21328
8000764c:	fe c6 ac b0 	sub	r6,pc,-21328
80007650:	a7 d5       	cbr	r5,0x7
80007652:	e0 40 00 47 	cp.w	r0,71
80007656:	f0 06 17 a0 	movle	r6,r8
8000765a:	30 32       	mov	r2,3
8000765c:	e0 8f 06 ce 	bral	800083f8 <_vfprintf_r+0x1658>
80007660:	40 5b       	lddsp	r11,sp[0x14]
80007662:	40 7a       	lddsp	r10,sp[0x1c]
80007664:	e0 a0 19 4d 	rcall	8000a8fe <__isnand>
80007668:	c0 e0       	breq	80007684 <_vfprintf_r+0x8e4>
8000766a:	50 26       	stdsp	sp[0x8],r6
8000766c:	fe c8 ac cc 	sub	r8,pc,-21300
80007670:	fe c6 ac cc 	sub	r6,pc,-21300
80007674:	a7 d5       	cbr	r5,0x7
80007676:	e0 40 00 47 	cp.w	r0,71
8000767a:	f0 06 17 a0 	movle	r6,r8
8000767e:	30 32       	mov	r2,3
80007680:	e0 8f 06 c2 	bral	80008404 <_vfprintf_r+0x1664>
80007684:	40 2a       	lddsp	r10,sp[0x8]
80007686:	5b fa       	cp.w	r10,-1
80007688:	c0 41       	brne	80007690 <_vfprintf_r+0x8f0>
8000768a:	30 69       	mov	r9,6
8000768c:	50 29       	stdsp	sp[0x8],r9
8000768e:	c1 18       	rjmp	800076b0 <_vfprintf_r+0x910>
80007690:	e0 40 00 47 	cp.w	r0,71
80007694:	5f 09       	sreq	r9
80007696:	e0 40 00 67 	cp.w	r0,103
8000769a:	5f 08       	sreq	r8
8000769c:	f3 e8 10 08 	or	r8,r9,r8
800076a0:	f8 08 18 00 	cp.b	r8,r12
800076a4:	c0 60       	breq	800076b0 <_vfprintf_r+0x910>
800076a6:	40 28       	lddsp	r8,sp[0x8]
800076a8:	58 08       	cp.w	r8,0
800076aa:	f9 b8 00 01 	moveq	r8,1
800076ae:	50 28       	stdsp	sp[0x8],r8
800076b0:	40 78       	lddsp	r8,sp[0x1c]
800076b2:	40 59       	lddsp	r9,sp[0x14]
800076b4:	fa e9 06 94 	st.d	sp[1684],r8
800076b8:	a9 a5       	sbr	r5,0x8
800076ba:	fa f8 06 94 	ld.w	r8,sp[1684]
800076be:	58 08       	cp.w	r8,0
800076c0:	c0 65       	brlt	800076cc <_vfprintf_r+0x92c>
800076c2:	40 5e       	lddsp	lr,sp[0x14]
800076c4:	30 0c       	mov	r12,0
800076c6:	50 6e       	stdsp	sp[0x18],lr
800076c8:	50 9c       	stdsp	sp[0x24],r12
800076ca:	c0 78       	rjmp	800076d8 <_vfprintf_r+0x938>
800076cc:	40 5b       	lddsp	r11,sp[0x14]
800076ce:	32 da       	mov	r10,45
800076d0:	ee 1b 80 00 	eorh	r11,0x8000
800076d4:	50 9a       	stdsp	sp[0x24],r10
800076d6:	50 6b       	stdsp	sp[0x18],r11
800076d8:	e0 40 00 46 	cp.w	r0,70
800076dc:	5f 09       	sreq	r9
800076de:	e0 40 00 66 	cp.w	r0,102
800076e2:	5f 08       	sreq	r8
800076e4:	f3 e8 10 08 	or	r8,r9,r8
800076e8:	50 48       	stdsp	sp[0x10],r8
800076ea:	c0 40       	breq	800076f2 <_vfprintf_r+0x952>
800076ec:	40 22       	lddsp	r2,sp[0x8]
800076ee:	30 39       	mov	r9,3
800076f0:	c1 08       	rjmp	80007710 <_vfprintf_r+0x970>
800076f2:	e0 40 00 45 	cp.w	r0,69
800076f6:	5f 09       	sreq	r9
800076f8:	e0 40 00 65 	cp.w	r0,101
800076fc:	5f 08       	sreq	r8
800076fe:	40 22       	lddsp	r2,sp[0x8]
80007700:	10 49       	or	r9,r8
80007702:	2f f2       	sub	r2,-1
80007704:	40 46       	lddsp	r6,sp[0x10]
80007706:	ec 09 18 00 	cp.b	r9,r6
8000770a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000770e:	30 29       	mov	r9,2
80007710:	fa c8 f9 5c 	sub	r8,sp,-1700
80007714:	1a d8       	st.w	--sp,r8
80007716:	fa c8 f9 54 	sub	r8,sp,-1708
8000771a:	1a d8       	st.w	--sp,r8
8000771c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007720:	08 9c       	mov	r12,r4
80007722:	1a d8       	st.w	--sp,r8
80007724:	04 98       	mov	r8,r2
80007726:	40 9b       	lddsp	r11,sp[0x24]
80007728:	40 aa       	lddsp	r10,sp[0x28]
8000772a:	e0 a0 0b c3 	rcall	80008eb0 <_dtoa_r>
8000772e:	e0 40 00 47 	cp.w	r0,71
80007732:	5f 19       	srne	r9
80007734:	e0 40 00 67 	cp.w	r0,103
80007738:	5f 18       	srne	r8
8000773a:	18 96       	mov	r6,r12
8000773c:	2f dd       	sub	sp,-12
8000773e:	f3 e8 00 08 	and	r8,r9,r8
80007742:	c0 41       	brne	8000774a <_vfprintf_r+0x9aa>
80007744:	ed b5 00 00 	bld	r5,0x0
80007748:	c3 01       	brne	800077a8 <_vfprintf_r+0xa08>
8000774a:	ec 02 00 0e 	add	lr,r6,r2
8000774e:	50 3e       	stdsp	sp[0xc],lr
80007750:	40 4c       	lddsp	r12,sp[0x10]
80007752:	58 0c       	cp.w	r12,0
80007754:	c1 50       	breq	8000777e <_vfprintf_r+0x9de>
80007756:	0d 89       	ld.ub	r9,r6[0x0]
80007758:	33 08       	mov	r8,48
8000775a:	f0 09 18 00 	cp.b	r9,r8
8000775e:	c0 b1       	brne	80007774 <_vfprintf_r+0x9d4>
80007760:	30 08       	mov	r8,0
80007762:	30 09       	mov	r9,0
80007764:	40 6b       	lddsp	r11,sp[0x18]
80007766:	40 7a       	lddsp	r10,sp[0x1c]
80007768:	e0 a0 1c d7 	rcall	8000b116 <__avr32_f64_cmp_eq>
8000776c:	fb b2 00 01 	rsubeq	r2,1
80007770:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007774:	40 3b       	lddsp	r11,sp[0xc]
80007776:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000777a:	10 0b       	add	r11,r8
8000777c:	50 3b       	stdsp	sp[0xc],r11
8000777e:	40 6b       	lddsp	r11,sp[0x18]
80007780:	30 08       	mov	r8,0
80007782:	30 09       	mov	r9,0
80007784:	40 7a       	lddsp	r10,sp[0x1c]
80007786:	e0 a0 1c c8 	rcall	8000b116 <__avr32_f64_cmp_eq>
8000778a:	c0 90       	breq	8000779c <_vfprintf_r+0x9fc>
8000778c:	40 3a       	lddsp	r10,sp[0xc]
8000778e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007792:	c0 58       	rjmp	8000779c <_vfprintf_r+0x9fc>
80007794:	10 c9       	st.b	r8++,r9
80007796:	fb 48 06 a4 	st.w	sp[1700],r8
8000779a:	c0 28       	rjmp	8000779e <_vfprintf_r+0x9fe>
8000779c:	33 09       	mov	r9,48
8000779e:	fa f8 06 a4 	ld.w	r8,sp[1700]
800077a2:	40 3e       	lddsp	lr,sp[0xc]
800077a4:	1c 38       	cp.w	r8,lr
800077a6:	cf 73       	brcs	80007794 <_vfprintf_r+0x9f4>
800077a8:	e0 40 00 47 	cp.w	r0,71
800077ac:	5f 09       	sreq	r9
800077ae:	e0 40 00 67 	cp.w	r0,103
800077b2:	5f 08       	sreq	r8
800077b4:	f3 e8 10 08 	or	r8,r9,r8
800077b8:	fa f9 06 a4 	ld.w	r9,sp[1700]
800077bc:	0c 19       	sub	r9,r6
800077be:	50 69       	stdsp	sp[0x18],r9
800077c0:	58 08       	cp.w	r8,0
800077c2:	c0 b0       	breq	800077d8 <_vfprintf_r+0xa38>
800077c4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800077c8:	5b d8       	cp.w	r8,-3
800077ca:	c0 55       	brlt	800077d4 <_vfprintf_r+0xa34>
800077cc:	40 2c       	lddsp	r12,sp[0x8]
800077ce:	18 38       	cp.w	r8,r12
800077d0:	e0 8a 00 6a 	brle	800078a4 <_vfprintf_r+0xb04>
800077d4:	20 20       	sub	r0,2
800077d6:	c0 58       	rjmp	800077e0 <_vfprintf_r+0xa40>
800077d8:	e0 40 00 65 	cp.w	r0,101
800077dc:	e0 89 00 46 	brgt	80007868 <_vfprintf_r+0xac8>
800077e0:	fa fb 06 ac 	ld.w	r11,sp[1708]
800077e4:	fb 60 06 9c 	st.b	sp[1692],r0
800077e8:	20 1b       	sub	r11,1
800077ea:	fb 4b 06 ac 	st.w	sp[1708],r11
800077ee:	c0 47       	brpl	800077f6 <_vfprintf_r+0xa56>
800077f0:	5c 3b       	neg	r11
800077f2:	32 d8       	mov	r8,45
800077f4:	c0 28       	rjmp	800077f8 <_vfprintf_r+0xa58>
800077f6:	32 b8       	mov	r8,43
800077f8:	fb 68 06 9d 	st.b	sp[1693],r8
800077fc:	58 9b       	cp.w	r11,9
800077fe:	e0 8a 00 1d 	brle	80007838 <_vfprintf_r+0xa98>
80007802:	fa c9 fa 35 	sub	r9,sp,-1483
80007806:	30 aa       	mov	r10,10
80007808:	12 98       	mov	r8,r9
8000780a:	0e 9c       	mov	r12,r7
8000780c:	0c 92       	mov	r2,r6
8000780e:	f6 0a 0c 06 	divs	r6,r11,r10
80007812:	0e 9b       	mov	r11,r7
80007814:	2d 0b       	sub	r11,-48
80007816:	10 fb       	st.b	--r8,r11
80007818:	0c 9b       	mov	r11,r6
8000781a:	58 96       	cp.w	r6,9
8000781c:	fe 99 ff f9 	brgt	8000780e <_vfprintf_r+0xa6e>
80007820:	2d 0b       	sub	r11,-48
80007822:	18 97       	mov	r7,r12
80007824:	04 96       	mov	r6,r2
80007826:	10 fb       	st.b	--r8,r11
80007828:	fa ca f9 62 	sub	r10,sp,-1694
8000782c:	c0 38       	rjmp	80007832 <_vfprintf_r+0xa92>
8000782e:	11 3b       	ld.ub	r11,r8++
80007830:	14 cb       	st.b	r10++,r11
80007832:	12 38       	cp.w	r8,r9
80007834:	cf d3       	brcs	8000782e <_vfprintf_r+0xa8e>
80007836:	c0 98       	rjmp	80007848 <_vfprintf_r+0xaa8>
80007838:	2d 0b       	sub	r11,-48
8000783a:	33 08       	mov	r8,48
8000783c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007840:	fb 68 06 9e 	st.b	sp[1694],r8
80007844:	fa ca f9 60 	sub	r10,sp,-1696
80007848:	fa c8 f9 64 	sub	r8,sp,-1692
8000784c:	f4 08 01 08 	sub	r8,r10,r8
80007850:	50 e8       	stdsp	sp[0x38],r8
80007852:	10 92       	mov	r2,r8
80007854:	40 6b       	lddsp	r11,sp[0x18]
80007856:	16 02       	add	r2,r11
80007858:	58 1b       	cp.w	r11,1
8000785a:	e0 89 00 05 	brgt	80007864 <_vfprintf_r+0xac4>
8000785e:	ed b5 00 00 	bld	r5,0x0
80007862:	c3 51       	brne	800078cc <_vfprintf_r+0xb2c>
80007864:	2f f2       	sub	r2,-1
80007866:	c3 38       	rjmp	800078cc <_vfprintf_r+0xb2c>
80007868:	e0 40 00 66 	cp.w	r0,102
8000786c:	c1 c1       	brne	800078a4 <_vfprintf_r+0xb04>
8000786e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007872:	58 02       	cp.w	r2,0
80007874:	e0 8a 00 0c 	brle	8000788c <_vfprintf_r+0xaec>
80007878:	40 2a       	lddsp	r10,sp[0x8]
8000787a:	58 0a       	cp.w	r10,0
8000787c:	c0 41       	brne	80007884 <_vfprintf_r+0xae4>
8000787e:	ed b5 00 00 	bld	r5,0x0
80007882:	c2 51       	brne	800078cc <_vfprintf_r+0xb2c>
80007884:	2f f2       	sub	r2,-1
80007886:	40 29       	lddsp	r9,sp[0x8]
80007888:	12 02       	add	r2,r9
8000788a:	c0 b8       	rjmp	800078a0 <_vfprintf_r+0xb00>
8000788c:	40 28       	lddsp	r8,sp[0x8]
8000788e:	58 08       	cp.w	r8,0
80007890:	c0 61       	brne	8000789c <_vfprintf_r+0xafc>
80007892:	ed b5 00 00 	bld	r5,0x0
80007896:	c0 30       	breq	8000789c <_vfprintf_r+0xafc>
80007898:	30 12       	mov	r2,1
8000789a:	c1 98       	rjmp	800078cc <_vfprintf_r+0xb2c>
8000789c:	40 22       	lddsp	r2,sp[0x8]
8000789e:	2f e2       	sub	r2,-2
800078a0:	36 60       	mov	r0,102
800078a2:	c1 58       	rjmp	800078cc <_vfprintf_r+0xb2c>
800078a4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800078a8:	40 6e       	lddsp	lr,sp[0x18]
800078aa:	1c 32       	cp.w	r2,lr
800078ac:	c0 65       	brlt	800078b8 <_vfprintf_r+0xb18>
800078ae:	ed b5 00 00 	bld	r5,0x0
800078b2:	f7 b2 00 ff 	subeq	r2,-1
800078b6:	c0 a8       	rjmp	800078ca <_vfprintf_r+0xb2a>
800078b8:	e4 08 11 02 	rsub	r8,r2,2
800078bc:	40 6c       	lddsp	r12,sp[0x18]
800078be:	58 02       	cp.w	r2,0
800078c0:	f0 02 17 a0 	movle	r2,r8
800078c4:	f9 b2 09 01 	movgt	r2,1
800078c8:	18 02       	add	r2,r12
800078ca:	36 70       	mov	r0,103
800078cc:	40 9b       	lddsp	r11,sp[0x24]
800078ce:	58 0b       	cp.w	r11,0
800078d0:	e0 80 05 94 	breq	800083f8 <_vfprintf_r+0x1658>
800078d4:	32 d8       	mov	r8,45
800078d6:	fb 68 06 bb 	st.b	sp[1723],r8
800078da:	e0 8f 05 93 	bral	80008400 <_vfprintf_r+0x1660>
800078de:	50 a7       	stdsp	sp[0x28],r7
800078e0:	04 94       	mov	r4,r2
800078e2:	0c 97       	mov	r7,r6
800078e4:	02 92       	mov	r2,r1
800078e6:	06 96       	mov	r6,r3
800078e8:	40 41       	lddsp	r1,sp[0x10]
800078ea:	40 93       	lddsp	r3,sp[0x24]
800078ec:	0e 99       	mov	r9,r7
800078ee:	ed b5 00 05 	bld	r5,0x5
800078f2:	c4 81       	brne	80007982 <_vfprintf_r+0xbe2>
800078f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078f8:	40 3e       	lddsp	lr,sp[0xc]
800078fa:	58 0e       	cp.w	lr,0
800078fc:	c1 d0       	breq	80007936 <_vfprintf_r+0xb96>
800078fe:	10 36       	cp.w	r6,r8
80007900:	c0 64       	brge	8000790c <_vfprintf_r+0xb6c>
80007902:	fa cc f9 44 	sub	r12,sp,-1724
80007906:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000790a:	c1 d8       	rjmp	80007944 <_vfprintf_r+0xba4>
8000790c:	fa c8 f9 50 	sub	r8,sp,-1712
80007910:	1a d8       	st.w	--sp,r8
80007912:	fa c8 fa b8 	sub	r8,sp,-1352
80007916:	04 9a       	mov	r10,r2
80007918:	1a d8       	st.w	--sp,r8
8000791a:	fa c8 fb b4 	sub	r8,sp,-1100
8000791e:	0c 9b       	mov	r11,r6
80007920:	1a d8       	st.w	--sp,r8
80007922:	08 9c       	mov	r12,r4
80007924:	fa c8 f9 40 	sub	r8,sp,-1728
80007928:	fa c9 ff b4 	sub	r9,sp,-76
8000792c:	fe b0 f8 a2 	rcall	80006a70 <get_arg>
80007930:	2f dd       	sub	sp,-12
80007932:	78 0a       	ld.w	r10,r12[0x0]
80007934:	c2 08       	rjmp	80007974 <_vfprintf_r+0xbd4>
80007936:	2f f7       	sub	r7,-1
80007938:	10 39       	cp.w	r9,r8
8000793a:	c0 84       	brge	8000794a <_vfprintf_r+0xbaa>
8000793c:	fa cb f9 44 	sub	r11,sp,-1724
80007940:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007944:	ec fa fd 88 	ld.w	r10,r6[-632]
80007948:	c1 68       	rjmp	80007974 <_vfprintf_r+0xbd4>
8000794a:	41 09       	lddsp	r9,sp[0x40]
8000794c:	59 f8       	cp.w	r8,31
8000794e:	e0 89 00 10 	brgt	8000796e <_vfprintf_r+0xbce>
80007952:	f2 ca ff fc 	sub	r10,r9,-4
80007956:	51 0a       	stdsp	sp[0x40],r10
80007958:	fa c6 f9 44 	sub	r6,sp,-1724
8000795c:	72 0a       	ld.w	r10,r9[0x0]
8000795e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007962:	f3 4a fd 88 	st.w	r9[-632],r10
80007966:	2f f8       	sub	r8,-1
80007968:	fb 48 06 b4 	st.w	sp[1716],r8
8000796c:	c0 48       	rjmp	80007974 <_vfprintf_r+0xbd4>
8000796e:	72 0a       	ld.w	r10,r9[0x0]
80007970:	2f c9       	sub	r9,-4
80007972:	51 09       	stdsp	sp[0x40],r9
80007974:	40 be       	lddsp	lr,sp[0x2c]
80007976:	1c 98       	mov	r8,lr
80007978:	95 1e       	st.w	r10[0x4],lr
8000797a:	bf 58       	asr	r8,0x1f
8000797c:	95 08       	st.w	r10[0x0],r8
8000797e:	fe 9f fa 9f 	bral	80006ebc <_vfprintf_r+0x11c>
80007982:	ed b5 00 04 	bld	r5,0x4
80007986:	c4 80       	breq	80007a16 <_vfprintf_r+0xc76>
80007988:	e2 15 00 40 	andl	r5,0x40,COH
8000798c:	c4 50       	breq	80007a16 <_vfprintf_r+0xc76>
8000798e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007992:	40 3c       	lddsp	r12,sp[0xc]
80007994:	58 0c       	cp.w	r12,0
80007996:	c1 d0       	breq	800079d0 <_vfprintf_r+0xc30>
80007998:	10 36       	cp.w	r6,r8
8000799a:	c0 64       	brge	800079a6 <_vfprintf_r+0xc06>
8000799c:	fa cb f9 44 	sub	r11,sp,-1724
800079a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079a4:	c1 d8       	rjmp	800079de <_vfprintf_r+0xc3e>
800079a6:	fa c8 f9 50 	sub	r8,sp,-1712
800079aa:	1a d8       	st.w	--sp,r8
800079ac:	fa c8 fa b8 	sub	r8,sp,-1352
800079b0:	04 9a       	mov	r10,r2
800079b2:	1a d8       	st.w	--sp,r8
800079b4:	fa c8 fb b4 	sub	r8,sp,-1100
800079b8:	0c 9b       	mov	r11,r6
800079ba:	1a d8       	st.w	--sp,r8
800079bc:	08 9c       	mov	r12,r4
800079be:	fa c8 f9 40 	sub	r8,sp,-1728
800079c2:	fa c9 ff b4 	sub	r9,sp,-76
800079c6:	fe b0 f8 55 	rcall	80006a70 <get_arg>
800079ca:	2f dd       	sub	sp,-12
800079cc:	78 0a       	ld.w	r10,r12[0x0]
800079ce:	c2 08       	rjmp	80007a0e <_vfprintf_r+0xc6e>
800079d0:	2f f7       	sub	r7,-1
800079d2:	10 39       	cp.w	r9,r8
800079d4:	c0 84       	brge	800079e4 <_vfprintf_r+0xc44>
800079d6:	fa ca f9 44 	sub	r10,sp,-1724
800079da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800079de:	ec fa fd 88 	ld.w	r10,r6[-632]
800079e2:	c1 68       	rjmp	80007a0e <_vfprintf_r+0xc6e>
800079e4:	41 09       	lddsp	r9,sp[0x40]
800079e6:	59 f8       	cp.w	r8,31
800079e8:	e0 89 00 10 	brgt	80007a08 <_vfprintf_r+0xc68>
800079ec:	f2 ca ff fc 	sub	r10,r9,-4
800079f0:	51 0a       	stdsp	sp[0x40],r10
800079f2:	fa c6 f9 44 	sub	r6,sp,-1724
800079f6:	72 0a       	ld.w	r10,r9[0x0]
800079f8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800079fc:	f3 4a fd 88 	st.w	r9[-632],r10
80007a00:	2f f8       	sub	r8,-1
80007a02:	fb 48 06 b4 	st.w	sp[1716],r8
80007a06:	c0 48       	rjmp	80007a0e <_vfprintf_r+0xc6e>
80007a08:	72 0a       	ld.w	r10,r9[0x0]
80007a0a:	2f c9       	sub	r9,-4
80007a0c:	51 09       	stdsp	sp[0x40],r9
80007a0e:	40 be       	lddsp	lr,sp[0x2c]
80007a10:	b4 0e       	st.h	r10[0x0],lr
80007a12:	fe 9f fa 55 	bral	80006ebc <_vfprintf_r+0x11c>
80007a16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a1a:	40 3c       	lddsp	r12,sp[0xc]
80007a1c:	58 0c       	cp.w	r12,0
80007a1e:	c1 d0       	breq	80007a58 <_vfprintf_r+0xcb8>
80007a20:	10 36       	cp.w	r6,r8
80007a22:	c0 64       	brge	80007a2e <_vfprintf_r+0xc8e>
80007a24:	fa cb f9 44 	sub	r11,sp,-1724
80007a28:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a2c:	c1 d8       	rjmp	80007a66 <_vfprintf_r+0xcc6>
80007a2e:	fa c8 f9 50 	sub	r8,sp,-1712
80007a32:	1a d8       	st.w	--sp,r8
80007a34:	fa c8 fa b8 	sub	r8,sp,-1352
80007a38:	04 9a       	mov	r10,r2
80007a3a:	1a d8       	st.w	--sp,r8
80007a3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007a40:	0c 9b       	mov	r11,r6
80007a42:	1a d8       	st.w	--sp,r8
80007a44:	08 9c       	mov	r12,r4
80007a46:	fa c8 f9 40 	sub	r8,sp,-1728
80007a4a:	fa c9 ff b4 	sub	r9,sp,-76
80007a4e:	fe b0 f8 11 	rcall	80006a70 <get_arg>
80007a52:	2f dd       	sub	sp,-12
80007a54:	78 0a       	ld.w	r10,r12[0x0]
80007a56:	c2 08       	rjmp	80007a96 <_vfprintf_r+0xcf6>
80007a58:	2f f7       	sub	r7,-1
80007a5a:	10 39       	cp.w	r9,r8
80007a5c:	c0 84       	brge	80007a6c <_vfprintf_r+0xccc>
80007a5e:	fa ca f9 44 	sub	r10,sp,-1724
80007a62:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007a66:	ec fa fd 88 	ld.w	r10,r6[-632]
80007a6a:	c1 68       	rjmp	80007a96 <_vfprintf_r+0xcf6>
80007a6c:	41 09       	lddsp	r9,sp[0x40]
80007a6e:	59 f8       	cp.w	r8,31
80007a70:	e0 89 00 10 	brgt	80007a90 <_vfprintf_r+0xcf0>
80007a74:	f2 ca ff fc 	sub	r10,r9,-4
80007a78:	51 0a       	stdsp	sp[0x40],r10
80007a7a:	fa c6 f9 44 	sub	r6,sp,-1724
80007a7e:	72 0a       	ld.w	r10,r9[0x0]
80007a80:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007a84:	f3 4a fd 88 	st.w	r9[-632],r10
80007a88:	2f f8       	sub	r8,-1
80007a8a:	fb 48 06 b4 	st.w	sp[1716],r8
80007a8e:	c0 48       	rjmp	80007a96 <_vfprintf_r+0xcf6>
80007a90:	72 0a       	ld.w	r10,r9[0x0]
80007a92:	2f c9       	sub	r9,-4
80007a94:	51 09       	stdsp	sp[0x40],r9
80007a96:	40 be       	lddsp	lr,sp[0x2c]
80007a98:	95 0e       	st.w	r10[0x0],lr
80007a9a:	fe 9f fa 11 	bral	80006ebc <_vfprintf_r+0x11c>
80007a9e:	50 a7       	stdsp	sp[0x28],r7
80007aa0:	50 80       	stdsp	sp[0x20],r0
80007aa2:	0c 97       	mov	r7,r6
80007aa4:	04 94       	mov	r4,r2
80007aa6:	06 96       	mov	r6,r3
80007aa8:	02 92       	mov	r2,r1
80007aaa:	40 93       	lddsp	r3,sp[0x24]
80007aac:	10 90       	mov	r0,r8
80007aae:	40 41       	lddsp	r1,sp[0x10]
80007ab0:	a5 a5       	sbr	r5,0x4
80007ab2:	c0 a8       	rjmp	80007ac6 <_vfprintf_r+0xd26>
80007ab4:	50 a7       	stdsp	sp[0x28],r7
80007ab6:	50 80       	stdsp	sp[0x20],r0
80007ab8:	0c 97       	mov	r7,r6
80007aba:	04 94       	mov	r4,r2
80007abc:	06 96       	mov	r6,r3
80007abe:	02 92       	mov	r2,r1
80007ac0:	40 93       	lddsp	r3,sp[0x24]
80007ac2:	10 90       	mov	r0,r8
80007ac4:	40 41       	lddsp	r1,sp[0x10]
80007ac6:	ed b5 00 05 	bld	r5,0x5
80007aca:	c5 d1       	brne	80007b84 <_vfprintf_r+0xde4>
80007acc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ad0:	40 3c       	lddsp	r12,sp[0xc]
80007ad2:	58 0c       	cp.w	r12,0
80007ad4:	c2 60       	breq	80007b20 <_vfprintf_r+0xd80>
80007ad6:	10 36       	cp.w	r6,r8
80007ad8:	c0 a4       	brge	80007aec <_vfprintf_r+0xd4c>
80007ada:	fa cb f9 44 	sub	r11,sp,-1724
80007ade:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ae2:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007ae6:	fa e9 00 00 	st.d	sp[0],r8
80007aea:	c1 88       	rjmp	80007b1a <_vfprintf_r+0xd7a>
80007aec:	fa c8 f9 50 	sub	r8,sp,-1712
80007af0:	1a d8       	st.w	--sp,r8
80007af2:	fa c8 fa b8 	sub	r8,sp,-1352
80007af6:	04 9a       	mov	r10,r2
80007af8:	1a d8       	st.w	--sp,r8
80007afa:	0c 9b       	mov	r11,r6
80007afc:	fa c8 fb b4 	sub	r8,sp,-1100
80007b00:	08 9c       	mov	r12,r4
80007b02:	1a d8       	st.w	--sp,r8
80007b04:	fa c8 f9 40 	sub	r8,sp,-1728
80007b08:	fa c9 ff b4 	sub	r9,sp,-76
80007b0c:	fe b0 f7 b2 	rcall	80006a70 <get_arg>
80007b10:	2f dd       	sub	sp,-12
80007b12:	f8 ea 00 00 	ld.d	r10,r12[0]
80007b16:	fa eb 00 00 	st.d	sp[0],r10
80007b1a:	30 08       	mov	r8,0
80007b1c:	e0 8f 03 de 	bral	800082d8 <_vfprintf_r+0x1538>
80007b20:	ee ca ff ff 	sub	r10,r7,-1
80007b24:	10 37       	cp.w	r7,r8
80007b26:	c0 b4       	brge	80007b3c <_vfprintf_r+0xd9c>
80007b28:	fa c9 f9 44 	sub	r9,sp,-1724
80007b2c:	14 97       	mov	r7,r10
80007b2e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b32:	ec ea fd 88 	ld.d	r10,r6[-632]
80007b36:	fa eb 00 00 	st.d	sp[0],r10
80007b3a:	c1 88       	rjmp	80007b6a <_vfprintf_r+0xdca>
80007b3c:	41 09       	lddsp	r9,sp[0x40]
80007b3e:	59 f8       	cp.w	r8,31
80007b40:	e0 89 00 18 	brgt	80007b70 <_vfprintf_r+0xdd0>
80007b44:	f2 e6 00 00 	ld.d	r6,r9[0]
80007b48:	f2 cb ff f8 	sub	r11,r9,-8
80007b4c:	fa e7 00 00 	st.d	sp[0],r6
80007b50:	51 0b       	stdsp	sp[0x40],r11
80007b52:	fa c6 f9 44 	sub	r6,sp,-1724
80007b56:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b5a:	fa e6 00 00 	ld.d	r6,sp[0]
80007b5e:	f2 e7 fd 88 	st.d	r9[-632],r6
80007b62:	2f f8       	sub	r8,-1
80007b64:	14 97       	mov	r7,r10
80007b66:	fb 48 06 b4 	st.w	sp[1716],r8
80007b6a:	40 38       	lddsp	r8,sp[0xc]
80007b6c:	e0 8f 03 b6 	bral	800082d8 <_vfprintf_r+0x1538>
80007b70:	f2 e6 00 00 	ld.d	r6,r9[0]
80007b74:	40 38       	lddsp	r8,sp[0xc]
80007b76:	fa e7 00 00 	st.d	sp[0],r6
80007b7a:	2f 89       	sub	r9,-8
80007b7c:	14 97       	mov	r7,r10
80007b7e:	51 09       	stdsp	sp[0x40],r9
80007b80:	e0 8f 03 ac 	bral	800082d8 <_vfprintf_r+0x1538>
80007b84:	ed b5 00 04 	bld	r5,0x4
80007b88:	c1 61       	brne	80007bb4 <_vfprintf_r+0xe14>
80007b8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b8e:	40 3e       	lddsp	lr,sp[0xc]
80007b90:	58 0e       	cp.w	lr,0
80007b92:	c0 80       	breq	80007ba2 <_vfprintf_r+0xe02>
80007b94:	10 36       	cp.w	r6,r8
80007b96:	c6 74       	brge	80007c64 <_vfprintf_r+0xec4>
80007b98:	fa cc f9 44 	sub	r12,sp,-1724
80007b9c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ba0:	c8 08       	rjmp	80007ca0 <_vfprintf_r+0xf00>
80007ba2:	ee ca ff ff 	sub	r10,r7,-1
80007ba6:	10 37       	cp.w	r7,r8
80007ba8:	c7 f4       	brge	80007ca6 <_vfprintf_r+0xf06>
80007baa:	fa cb f9 44 	sub	r11,sp,-1724
80007bae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007bb2:	c7 68       	rjmp	80007c9e <_vfprintf_r+0xefe>
80007bb4:	ed b5 00 06 	bld	r5,0x6
80007bb8:	c4 a1       	brne	80007c4c <_vfprintf_r+0xeac>
80007bba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bbe:	40 3c       	lddsp	r12,sp[0xc]
80007bc0:	58 0c       	cp.w	r12,0
80007bc2:	c1 d0       	breq	80007bfc <_vfprintf_r+0xe5c>
80007bc4:	10 36       	cp.w	r6,r8
80007bc6:	c0 64       	brge	80007bd2 <_vfprintf_r+0xe32>
80007bc8:	fa cb f9 44 	sub	r11,sp,-1724
80007bcc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007bd0:	c1 f8       	rjmp	80007c0e <_vfprintf_r+0xe6e>
80007bd2:	fa c8 f9 50 	sub	r8,sp,-1712
80007bd6:	1a d8       	st.w	--sp,r8
80007bd8:	fa c8 fa b8 	sub	r8,sp,-1352
80007bdc:	1a d8       	st.w	--sp,r8
80007bde:	fa c8 fb b4 	sub	r8,sp,-1100
80007be2:	1a d8       	st.w	--sp,r8
80007be4:	fa c8 f9 40 	sub	r8,sp,-1728
80007be8:	fa c9 ff b4 	sub	r9,sp,-76
80007bec:	04 9a       	mov	r10,r2
80007bee:	0c 9b       	mov	r11,r6
80007bf0:	08 9c       	mov	r12,r4
80007bf2:	fe b0 f7 3f 	rcall	80006a70 <get_arg>
80007bf6:	2f dd       	sub	sp,-12
80007bf8:	98 18       	ld.sh	r8,r12[0x2]
80007bfa:	c2 68       	rjmp	80007c46 <_vfprintf_r+0xea6>
80007bfc:	ee ca ff ff 	sub	r10,r7,-1
80007c00:	10 37       	cp.w	r7,r8
80007c02:	c0 94       	brge	80007c14 <_vfprintf_r+0xe74>
80007c04:	fa c9 f9 44 	sub	r9,sp,-1724
80007c08:	14 97       	mov	r7,r10
80007c0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c0e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007c12:	c1 a8       	rjmp	80007c46 <_vfprintf_r+0xea6>
80007c14:	41 09       	lddsp	r9,sp[0x40]
80007c16:	59 f8       	cp.w	r8,31
80007c18:	e0 89 00 13 	brgt	80007c3e <_vfprintf_r+0xe9e>
80007c1c:	f2 cb ff fc 	sub	r11,r9,-4
80007c20:	51 0b       	stdsp	sp[0x40],r11
80007c22:	72 09       	ld.w	r9,r9[0x0]
80007c24:	fa c6 f9 44 	sub	r6,sp,-1724
80007c28:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007c2c:	2f f8       	sub	r8,-1
80007c2e:	f7 49 fd 88 	st.w	r11[-632],r9
80007c32:	fb 48 06 b4 	st.w	sp[1716],r8
80007c36:	14 97       	mov	r7,r10
80007c38:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007c3c:	c0 58       	rjmp	80007c46 <_vfprintf_r+0xea6>
80007c3e:	92 18       	ld.sh	r8,r9[0x2]
80007c40:	14 97       	mov	r7,r10
80007c42:	2f c9       	sub	r9,-4
80007c44:	51 09       	stdsp	sp[0x40],r9
80007c46:	5c 78       	castu.h	r8
80007c48:	50 18       	stdsp	sp[0x4],r8
80007c4a:	c4 68       	rjmp	80007cd6 <_vfprintf_r+0xf36>
80007c4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c50:	40 3c       	lddsp	r12,sp[0xc]
80007c52:	58 0c       	cp.w	r12,0
80007c54:	c1 d0       	breq	80007c8e <_vfprintf_r+0xeee>
80007c56:	10 36       	cp.w	r6,r8
80007c58:	c0 64       	brge	80007c64 <_vfprintf_r+0xec4>
80007c5a:	fa cb f9 44 	sub	r11,sp,-1724
80007c5e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c62:	c1 f8       	rjmp	80007ca0 <_vfprintf_r+0xf00>
80007c64:	fa c8 f9 50 	sub	r8,sp,-1712
80007c68:	1a d8       	st.w	--sp,r8
80007c6a:	fa c8 fa b8 	sub	r8,sp,-1352
80007c6e:	0c 9b       	mov	r11,r6
80007c70:	1a d8       	st.w	--sp,r8
80007c72:	fa c8 fb b4 	sub	r8,sp,-1100
80007c76:	04 9a       	mov	r10,r2
80007c78:	1a d8       	st.w	--sp,r8
80007c7a:	08 9c       	mov	r12,r4
80007c7c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c80:	fa c9 ff b4 	sub	r9,sp,-76
80007c84:	fe b0 f6 f6 	rcall	80006a70 <get_arg>
80007c88:	2f dd       	sub	sp,-12
80007c8a:	78 0b       	ld.w	r11,r12[0x0]
80007c8c:	c2 48       	rjmp	80007cd4 <_vfprintf_r+0xf34>
80007c8e:	ee ca ff ff 	sub	r10,r7,-1
80007c92:	10 37       	cp.w	r7,r8
80007c94:	c0 94       	brge	80007ca6 <_vfprintf_r+0xf06>
80007c96:	fa c9 f9 44 	sub	r9,sp,-1724
80007c9a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c9e:	14 97       	mov	r7,r10
80007ca0:	ec fb fd 88 	ld.w	r11,r6[-632]
80007ca4:	c1 88       	rjmp	80007cd4 <_vfprintf_r+0xf34>
80007ca6:	41 09       	lddsp	r9,sp[0x40]
80007ca8:	59 f8       	cp.w	r8,31
80007caa:	e0 89 00 11 	brgt	80007ccc <_vfprintf_r+0xf2c>
80007cae:	f2 cb ff fc 	sub	r11,r9,-4
80007cb2:	51 0b       	stdsp	sp[0x40],r11
80007cb4:	fa c6 f9 44 	sub	r6,sp,-1724
80007cb8:	72 0b       	ld.w	r11,r9[0x0]
80007cba:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007cbe:	f3 4b fd 88 	st.w	r9[-632],r11
80007cc2:	2f f8       	sub	r8,-1
80007cc4:	14 97       	mov	r7,r10
80007cc6:	fb 48 06 b4 	st.w	sp[1716],r8
80007cca:	c0 58       	rjmp	80007cd4 <_vfprintf_r+0xf34>
80007ccc:	72 0b       	ld.w	r11,r9[0x0]
80007cce:	14 97       	mov	r7,r10
80007cd0:	2f c9       	sub	r9,-4
80007cd2:	51 09       	stdsp	sp[0x40],r9
80007cd4:	50 1b       	stdsp	sp[0x4],r11
80007cd6:	30 0e       	mov	lr,0
80007cd8:	50 0e       	stdsp	sp[0x0],lr
80007cda:	1c 98       	mov	r8,lr
80007cdc:	e0 8f 02 fe 	bral	800082d8 <_vfprintf_r+0x1538>
80007ce0:	50 a7       	stdsp	sp[0x28],r7
80007ce2:	50 80       	stdsp	sp[0x20],r0
80007ce4:	0c 97       	mov	r7,r6
80007ce6:	04 94       	mov	r4,r2
80007ce8:	06 96       	mov	r6,r3
80007cea:	02 92       	mov	r2,r1
80007cec:	40 93       	lddsp	r3,sp[0x24]
80007cee:	40 41       	lddsp	r1,sp[0x10]
80007cf0:	0e 99       	mov	r9,r7
80007cf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cf6:	40 3c       	lddsp	r12,sp[0xc]
80007cf8:	58 0c       	cp.w	r12,0
80007cfa:	c1 d0       	breq	80007d34 <_vfprintf_r+0xf94>
80007cfc:	10 36       	cp.w	r6,r8
80007cfe:	c0 64       	brge	80007d0a <_vfprintf_r+0xf6a>
80007d00:	fa cb f9 44 	sub	r11,sp,-1724
80007d04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d08:	c1 d8       	rjmp	80007d42 <_vfprintf_r+0xfa2>
80007d0a:	fa c8 f9 50 	sub	r8,sp,-1712
80007d0e:	1a d8       	st.w	--sp,r8
80007d10:	fa c8 fa b8 	sub	r8,sp,-1352
80007d14:	1a d8       	st.w	--sp,r8
80007d16:	fa c8 fb b4 	sub	r8,sp,-1100
80007d1a:	1a d8       	st.w	--sp,r8
80007d1c:	fa c9 ff b4 	sub	r9,sp,-76
80007d20:	fa c8 f9 40 	sub	r8,sp,-1728
80007d24:	04 9a       	mov	r10,r2
80007d26:	0c 9b       	mov	r11,r6
80007d28:	08 9c       	mov	r12,r4
80007d2a:	fe b0 f6 a3 	rcall	80006a70 <get_arg>
80007d2e:	2f dd       	sub	sp,-12
80007d30:	78 09       	ld.w	r9,r12[0x0]
80007d32:	c2 18       	rjmp	80007d74 <_vfprintf_r+0xfd4>
80007d34:	2f f7       	sub	r7,-1
80007d36:	10 39       	cp.w	r9,r8
80007d38:	c0 84       	brge	80007d48 <_vfprintf_r+0xfa8>
80007d3a:	fa ca f9 44 	sub	r10,sp,-1724
80007d3e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d42:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007d46:	c1 78       	rjmp	80007d74 <_vfprintf_r+0xfd4>
80007d48:	41 09       	lddsp	r9,sp[0x40]
80007d4a:	59 f8       	cp.w	r8,31
80007d4c:	e0 89 00 10 	brgt	80007d6c <_vfprintf_r+0xfcc>
80007d50:	f2 ca ff fc 	sub	r10,r9,-4
80007d54:	51 0a       	stdsp	sp[0x40],r10
80007d56:	fa c6 f9 44 	sub	r6,sp,-1724
80007d5a:	72 09       	ld.w	r9,r9[0x0]
80007d5c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d60:	f5 49 fd 88 	st.w	r10[-632],r9
80007d64:	2f f8       	sub	r8,-1
80007d66:	fb 48 06 b4 	st.w	sp[1716],r8
80007d6a:	c0 58       	rjmp	80007d74 <_vfprintf_r+0xfd4>
80007d6c:	f2 c8 ff fc 	sub	r8,r9,-4
80007d70:	51 08       	stdsp	sp[0x40],r8
80007d72:	72 09       	ld.w	r9,r9[0x0]
80007d74:	33 08       	mov	r8,48
80007d76:	fb 68 06 b8 	st.b	sp[1720],r8
80007d7a:	37 88       	mov	r8,120
80007d7c:	30 0e       	mov	lr,0
80007d7e:	fb 68 06 b9 	st.b	sp[1721],r8
80007d82:	fe cc b3 da 	sub	r12,pc,-19494
80007d86:	50 19       	stdsp	sp[0x4],r9
80007d88:	a1 b5       	sbr	r5,0x1
80007d8a:	50 0e       	stdsp	sp[0x0],lr
80007d8c:	50 dc       	stdsp	sp[0x34],r12
80007d8e:	30 28       	mov	r8,2
80007d90:	37 80       	mov	r0,120
80007d92:	e0 8f 02 a3 	bral	800082d8 <_vfprintf_r+0x1538>
80007d96:	50 a7       	stdsp	sp[0x28],r7
80007d98:	50 80       	stdsp	sp[0x20],r0
80007d9a:	10 90       	mov	r0,r8
80007d9c:	30 08       	mov	r8,0
80007d9e:	fb 68 06 bb 	st.b	sp[1723],r8
80007da2:	0c 97       	mov	r7,r6
80007da4:	04 94       	mov	r4,r2
80007da6:	06 96       	mov	r6,r3
80007da8:	02 92       	mov	r2,r1
80007daa:	40 93       	lddsp	r3,sp[0x24]
80007dac:	40 41       	lddsp	r1,sp[0x10]
80007dae:	0e 99       	mov	r9,r7
80007db0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007db4:	40 3b       	lddsp	r11,sp[0xc]
80007db6:	58 0b       	cp.w	r11,0
80007db8:	c1 d0       	breq	80007df2 <_vfprintf_r+0x1052>
80007dba:	10 36       	cp.w	r6,r8
80007dbc:	c0 64       	brge	80007dc8 <_vfprintf_r+0x1028>
80007dbe:	fa ca f9 44 	sub	r10,sp,-1724
80007dc2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007dc6:	c1 d8       	rjmp	80007e00 <_vfprintf_r+0x1060>
80007dc8:	fa c8 f9 50 	sub	r8,sp,-1712
80007dcc:	1a d8       	st.w	--sp,r8
80007dce:	fa c8 fa b8 	sub	r8,sp,-1352
80007dd2:	1a d8       	st.w	--sp,r8
80007dd4:	fa c8 fb b4 	sub	r8,sp,-1100
80007dd8:	0c 9b       	mov	r11,r6
80007dda:	1a d8       	st.w	--sp,r8
80007ddc:	04 9a       	mov	r10,r2
80007dde:	fa c8 f9 40 	sub	r8,sp,-1728
80007de2:	fa c9 ff b4 	sub	r9,sp,-76
80007de6:	08 9c       	mov	r12,r4
80007de8:	fe b0 f6 44 	rcall	80006a70 <get_arg>
80007dec:	2f dd       	sub	sp,-12
80007dee:	78 06       	ld.w	r6,r12[0x0]
80007df0:	c2 08       	rjmp	80007e30 <_vfprintf_r+0x1090>
80007df2:	2f f7       	sub	r7,-1
80007df4:	10 39       	cp.w	r9,r8
80007df6:	c0 84       	brge	80007e06 <_vfprintf_r+0x1066>
80007df8:	fa c9 f9 44 	sub	r9,sp,-1724
80007dfc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e00:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007e04:	c1 68       	rjmp	80007e30 <_vfprintf_r+0x1090>
80007e06:	41 09       	lddsp	r9,sp[0x40]
80007e08:	59 f8       	cp.w	r8,31
80007e0a:	e0 89 00 10 	brgt	80007e2a <_vfprintf_r+0x108a>
80007e0e:	f2 ca ff fc 	sub	r10,r9,-4
80007e12:	51 0a       	stdsp	sp[0x40],r10
80007e14:	72 06       	ld.w	r6,r9[0x0]
80007e16:	fa ce f9 44 	sub	lr,sp,-1724
80007e1a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007e1e:	f3 46 fd 88 	st.w	r9[-632],r6
80007e22:	2f f8       	sub	r8,-1
80007e24:	fb 48 06 b4 	st.w	sp[1716],r8
80007e28:	c0 48       	rjmp	80007e30 <_vfprintf_r+0x1090>
80007e2a:	72 06       	ld.w	r6,r9[0x0]
80007e2c:	2f c9       	sub	r9,-4
80007e2e:	51 09       	stdsp	sp[0x40],r9
80007e30:	40 2c       	lddsp	r12,sp[0x8]
80007e32:	58 0c       	cp.w	r12,0
80007e34:	c1 05       	brlt	80007e54 <_vfprintf_r+0x10b4>
80007e36:	18 9a       	mov	r10,r12
80007e38:	30 0b       	mov	r11,0
80007e3a:	0c 9c       	mov	r12,r6
80007e3c:	e0 a0 12 38 	rcall	8000a2ac <memchr>
80007e40:	e0 80 02 df 	breq	800083fe <_vfprintf_r+0x165e>
80007e44:	f8 06 01 02 	sub	r2,r12,r6
80007e48:	40 2b       	lddsp	r11,sp[0x8]
80007e4a:	16 32       	cp.w	r2,r11
80007e4c:	e0 89 02 d9 	brgt	800083fe <_vfprintf_r+0x165e>
80007e50:	e0 8f 02 d4 	bral	800083f8 <_vfprintf_r+0x1658>
80007e54:	30 0a       	mov	r10,0
80007e56:	0c 9c       	mov	r12,r6
80007e58:	50 2a       	stdsp	sp[0x8],r10
80007e5a:	e0 a0 15 99 	rcall	8000a98c <strlen>
80007e5e:	18 92       	mov	r2,r12
80007e60:	e0 8f 02 d2 	bral	80008404 <_vfprintf_r+0x1664>
80007e64:	50 a7       	stdsp	sp[0x28],r7
80007e66:	50 80       	stdsp	sp[0x20],r0
80007e68:	0c 97       	mov	r7,r6
80007e6a:	04 94       	mov	r4,r2
80007e6c:	06 96       	mov	r6,r3
80007e6e:	02 92       	mov	r2,r1
80007e70:	40 93       	lddsp	r3,sp[0x24]
80007e72:	10 90       	mov	r0,r8
80007e74:	40 41       	lddsp	r1,sp[0x10]
80007e76:	a5 a5       	sbr	r5,0x4
80007e78:	c0 a8       	rjmp	80007e8c <_vfprintf_r+0x10ec>
80007e7a:	50 a7       	stdsp	sp[0x28],r7
80007e7c:	50 80       	stdsp	sp[0x20],r0
80007e7e:	0c 97       	mov	r7,r6
80007e80:	04 94       	mov	r4,r2
80007e82:	06 96       	mov	r6,r3
80007e84:	02 92       	mov	r2,r1
80007e86:	40 93       	lddsp	r3,sp[0x24]
80007e88:	10 90       	mov	r0,r8
80007e8a:	40 41       	lddsp	r1,sp[0x10]
80007e8c:	ed b5 00 05 	bld	r5,0x5
80007e90:	c5 61       	brne	80007f3c <_vfprintf_r+0x119c>
80007e92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e96:	40 39       	lddsp	r9,sp[0xc]
80007e98:	58 09       	cp.w	r9,0
80007e9a:	c2 10       	breq	80007edc <_vfprintf_r+0x113c>
80007e9c:	10 36       	cp.w	r6,r8
80007e9e:	c0 74       	brge	80007eac <_vfprintf_r+0x110c>
80007ea0:	fa c8 f9 44 	sub	r8,sp,-1724
80007ea4:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007ea8:	c2 38       	rjmp	80007eee <_vfprintf_r+0x114e>
80007eaa:	d7 03       	nop
80007eac:	fa c8 f9 50 	sub	r8,sp,-1712
80007eb0:	1a d8       	st.w	--sp,r8
80007eb2:	fa c8 fa b8 	sub	r8,sp,-1352
80007eb6:	1a d8       	st.w	--sp,r8
80007eb8:	fa c8 fb b4 	sub	r8,sp,-1100
80007ebc:	1a d8       	st.w	--sp,r8
80007ebe:	fa c8 f9 40 	sub	r8,sp,-1728
80007ec2:	fa c9 ff b4 	sub	r9,sp,-76
80007ec6:	04 9a       	mov	r10,r2
80007ec8:	0c 9b       	mov	r11,r6
80007eca:	08 9c       	mov	r12,r4
80007ecc:	fe b0 f5 d2 	rcall	80006a70 <get_arg>
80007ed0:	2f dd       	sub	sp,-12
80007ed2:	f8 e8 00 00 	ld.d	r8,r12[0]
80007ed6:	fa e9 00 00 	st.d	sp[0],r8
80007eda:	c2 e8       	rjmp	80007f36 <_vfprintf_r+0x1196>
80007edc:	ee ca ff ff 	sub	r10,r7,-1
80007ee0:	10 37       	cp.w	r7,r8
80007ee2:	c0 b4       	brge	80007ef8 <_vfprintf_r+0x1158>
80007ee4:	fa c8 f9 44 	sub	r8,sp,-1724
80007ee8:	14 97       	mov	r7,r10
80007eea:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007eee:	ec ea fd 88 	ld.d	r10,r6[-632]
80007ef2:	fa eb 00 00 	st.d	sp[0],r10
80007ef6:	c2 08       	rjmp	80007f36 <_vfprintf_r+0x1196>
80007ef8:	41 09       	lddsp	r9,sp[0x40]
80007efa:	59 f8       	cp.w	r8,31
80007efc:	e0 89 00 16 	brgt	80007f28 <_vfprintf_r+0x1188>
80007f00:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f04:	f2 cb ff f8 	sub	r11,r9,-8
80007f08:	fa e7 00 00 	st.d	sp[0],r6
80007f0c:	51 0b       	stdsp	sp[0x40],r11
80007f0e:	fa c6 f9 44 	sub	r6,sp,-1724
80007f12:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f16:	fa e6 00 00 	ld.d	r6,sp[0]
80007f1a:	f2 e7 fd 88 	st.d	r9[-632],r6
80007f1e:	2f f8       	sub	r8,-1
80007f20:	14 97       	mov	r7,r10
80007f22:	fb 48 06 b4 	st.w	sp[1716],r8
80007f26:	c0 88       	rjmp	80007f36 <_vfprintf_r+0x1196>
80007f28:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f2c:	2f 89       	sub	r9,-8
80007f2e:	fa e7 00 00 	st.d	sp[0],r6
80007f32:	51 09       	stdsp	sp[0x40],r9
80007f34:	14 97       	mov	r7,r10
80007f36:	30 18       	mov	r8,1
80007f38:	e0 8f 01 d0 	bral	800082d8 <_vfprintf_r+0x1538>
80007f3c:	ed b5 00 04 	bld	r5,0x4
80007f40:	c1 61       	brne	80007f6c <_vfprintf_r+0x11cc>
80007f42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f46:	40 3e       	lddsp	lr,sp[0xc]
80007f48:	58 0e       	cp.w	lr,0
80007f4a:	c0 80       	breq	80007f5a <_vfprintf_r+0x11ba>
80007f4c:	10 36       	cp.w	r6,r8
80007f4e:	c6 74       	brge	8000801c <_vfprintf_r+0x127c>
80007f50:	fa cc f9 44 	sub	r12,sp,-1724
80007f54:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f58:	c8 08       	rjmp	80008058 <_vfprintf_r+0x12b8>
80007f5a:	ee ca ff ff 	sub	r10,r7,-1
80007f5e:	10 37       	cp.w	r7,r8
80007f60:	c7 f4       	brge	8000805e <_vfprintf_r+0x12be>
80007f62:	fa cb f9 44 	sub	r11,sp,-1724
80007f66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f6a:	c7 68       	rjmp	80008056 <_vfprintf_r+0x12b6>
80007f6c:	ed b5 00 06 	bld	r5,0x6
80007f70:	c4 a1       	brne	80008004 <_vfprintf_r+0x1264>
80007f72:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f76:	40 3c       	lddsp	r12,sp[0xc]
80007f78:	58 0c       	cp.w	r12,0
80007f7a:	c1 d0       	breq	80007fb4 <_vfprintf_r+0x1214>
80007f7c:	10 36       	cp.w	r6,r8
80007f7e:	c0 64       	brge	80007f8a <_vfprintf_r+0x11ea>
80007f80:	fa cb f9 44 	sub	r11,sp,-1724
80007f84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f88:	c1 f8       	rjmp	80007fc6 <_vfprintf_r+0x1226>
80007f8a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f8e:	1a d8       	st.w	--sp,r8
80007f90:	fa c8 fa b8 	sub	r8,sp,-1352
80007f94:	1a d8       	st.w	--sp,r8
80007f96:	fa c8 fb b4 	sub	r8,sp,-1100
80007f9a:	1a d8       	st.w	--sp,r8
80007f9c:	fa c8 f9 40 	sub	r8,sp,-1728
80007fa0:	fa c9 ff b4 	sub	r9,sp,-76
80007fa4:	04 9a       	mov	r10,r2
80007fa6:	0c 9b       	mov	r11,r6
80007fa8:	08 9c       	mov	r12,r4
80007faa:	fe b0 f5 63 	rcall	80006a70 <get_arg>
80007fae:	2f dd       	sub	sp,-12
80007fb0:	98 18       	ld.sh	r8,r12[0x2]
80007fb2:	c2 68       	rjmp	80007ffe <_vfprintf_r+0x125e>
80007fb4:	ee ca ff ff 	sub	r10,r7,-1
80007fb8:	10 37       	cp.w	r7,r8
80007fba:	c0 94       	brge	80007fcc <_vfprintf_r+0x122c>
80007fbc:	fa c9 f9 44 	sub	r9,sp,-1724
80007fc0:	14 97       	mov	r7,r10
80007fc2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fc6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007fca:	c1 a8       	rjmp	80007ffe <_vfprintf_r+0x125e>
80007fcc:	41 09       	lddsp	r9,sp[0x40]
80007fce:	59 f8       	cp.w	r8,31
80007fd0:	e0 89 00 13 	brgt	80007ff6 <_vfprintf_r+0x1256>
80007fd4:	f2 cb ff fc 	sub	r11,r9,-4
80007fd8:	51 0b       	stdsp	sp[0x40],r11
80007fda:	72 09       	ld.w	r9,r9[0x0]
80007fdc:	fa c6 f9 44 	sub	r6,sp,-1724
80007fe0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007fe4:	2f f8       	sub	r8,-1
80007fe6:	f7 49 fd 88 	st.w	r11[-632],r9
80007fea:	fb 48 06 b4 	st.w	sp[1716],r8
80007fee:	14 97       	mov	r7,r10
80007ff0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007ff4:	c0 58       	rjmp	80007ffe <_vfprintf_r+0x125e>
80007ff6:	92 18       	ld.sh	r8,r9[0x2]
80007ff8:	14 97       	mov	r7,r10
80007ffa:	2f c9       	sub	r9,-4
80007ffc:	51 09       	stdsp	sp[0x40],r9
80007ffe:	5c 78       	castu.h	r8
80008000:	50 18       	stdsp	sp[0x4],r8
80008002:	c4 68       	rjmp	8000808e <_vfprintf_r+0x12ee>
80008004:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008008:	40 3c       	lddsp	r12,sp[0xc]
8000800a:	58 0c       	cp.w	r12,0
8000800c:	c1 d0       	breq	80008046 <_vfprintf_r+0x12a6>
8000800e:	10 36       	cp.w	r6,r8
80008010:	c0 64       	brge	8000801c <_vfprintf_r+0x127c>
80008012:	fa cb f9 44 	sub	r11,sp,-1724
80008016:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000801a:	c1 f8       	rjmp	80008058 <_vfprintf_r+0x12b8>
8000801c:	fa c8 f9 50 	sub	r8,sp,-1712
80008020:	1a d8       	st.w	--sp,r8
80008022:	fa c8 fa b8 	sub	r8,sp,-1352
80008026:	0c 9b       	mov	r11,r6
80008028:	1a d8       	st.w	--sp,r8
8000802a:	fa c8 fb b4 	sub	r8,sp,-1100
8000802e:	04 9a       	mov	r10,r2
80008030:	1a d8       	st.w	--sp,r8
80008032:	08 9c       	mov	r12,r4
80008034:	fa c8 f9 40 	sub	r8,sp,-1728
80008038:	fa c9 ff b4 	sub	r9,sp,-76
8000803c:	fe b0 f5 1a 	rcall	80006a70 <get_arg>
80008040:	2f dd       	sub	sp,-12
80008042:	78 0b       	ld.w	r11,r12[0x0]
80008044:	c2 48       	rjmp	8000808c <_vfprintf_r+0x12ec>
80008046:	ee ca ff ff 	sub	r10,r7,-1
8000804a:	10 37       	cp.w	r7,r8
8000804c:	c0 94       	brge	8000805e <_vfprintf_r+0x12be>
8000804e:	fa c9 f9 44 	sub	r9,sp,-1724
80008052:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008056:	14 97       	mov	r7,r10
80008058:	ec fb fd 88 	ld.w	r11,r6[-632]
8000805c:	c1 88       	rjmp	8000808c <_vfprintf_r+0x12ec>
8000805e:	41 09       	lddsp	r9,sp[0x40]
80008060:	59 f8       	cp.w	r8,31
80008062:	e0 89 00 11 	brgt	80008084 <_vfprintf_r+0x12e4>
80008066:	f2 cb ff fc 	sub	r11,r9,-4
8000806a:	51 0b       	stdsp	sp[0x40],r11
8000806c:	fa c6 f9 44 	sub	r6,sp,-1724
80008070:	72 0b       	ld.w	r11,r9[0x0]
80008072:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008076:	f3 4b fd 88 	st.w	r9[-632],r11
8000807a:	2f f8       	sub	r8,-1
8000807c:	14 97       	mov	r7,r10
8000807e:	fb 48 06 b4 	st.w	sp[1716],r8
80008082:	c0 58       	rjmp	8000808c <_vfprintf_r+0x12ec>
80008084:	72 0b       	ld.w	r11,r9[0x0]
80008086:	14 97       	mov	r7,r10
80008088:	2f c9       	sub	r9,-4
8000808a:	51 09       	stdsp	sp[0x40],r9
8000808c:	50 1b       	stdsp	sp[0x4],r11
8000808e:	30 0e       	mov	lr,0
80008090:	30 18       	mov	r8,1
80008092:	50 0e       	stdsp	sp[0x0],lr
80008094:	c2 29       	rjmp	800082d8 <_vfprintf_r+0x1538>
80008096:	50 a7       	stdsp	sp[0x28],r7
80008098:	50 80       	stdsp	sp[0x20],r0
8000809a:	0c 97       	mov	r7,r6
8000809c:	04 94       	mov	r4,r2
8000809e:	06 96       	mov	r6,r3
800080a0:	02 92       	mov	r2,r1
800080a2:	fe cc b6 fa 	sub	r12,pc,-18694
800080a6:	40 93       	lddsp	r3,sp[0x24]
800080a8:	10 90       	mov	r0,r8
800080aa:	40 41       	lddsp	r1,sp[0x10]
800080ac:	50 dc       	stdsp	sp[0x34],r12
800080ae:	ed b5 00 05 	bld	r5,0x5
800080b2:	c5 51       	brne	8000815c <_vfprintf_r+0x13bc>
800080b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080b8:	40 3b       	lddsp	r11,sp[0xc]
800080ba:	58 0b       	cp.w	r11,0
800080bc:	c2 20       	breq	80008100 <_vfprintf_r+0x1360>
800080be:	10 36       	cp.w	r6,r8
800080c0:	c0 a4       	brge	800080d4 <_vfprintf_r+0x1334>
800080c2:	fa ca f9 44 	sub	r10,sp,-1724
800080c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080ca:	ec e8 fd 88 	ld.d	r8,r6[-632]
800080ce:	fa e9 00 00 	st.d	sp[0],r8
800080d2:	cf 28       	rjmp	800082b6 <_vfprintf_r+0x1516>
800080d4:	fa c8 f9 50 	sub	r8,sp,-1712
800080d8:	1a d8       	st.w	--sp,r8
800080da:	fa c8 fa b8 	sub	r8,sp,-1352
800080de:	04 9a       	mov	r10,r2
800080e0:	1a d8       	st.w	--sp,r8
800080e2:	0c 9b       	mov	r11,r6
800080e4:	fa c8 fb b4 	sub	r8,sp,-1100
800080e8:	08 9c       	mov	r12,r4
800080ea:	1a d8       	st.w	--sp,r8
800080ec:	fa c8 f9 40 	sub	r8,sp,-1728
800080f0:	fa c9 ff b4 	sub	r9,sp,-76
800080f4:	fe b0 f4 be 	rcall	80006a70 <get_arg>
800080f8:	2f dd       	sub	sp,-12
800080fa:	f8 ea 00 00 	ld.d	r10,r12[0]
800080fe:	c0 c8       	rjmp	80008116 <_vfprintf_r+0x1376>
80008100:	ee ca ff ff 	sub	r10,r7,-1
80008104:	10 37       	cp.w	r7,r8
80008106:	c0 b4       	brge	8000811c <_vfprintf_r+0x137c>
80008108:	fa c9 f9 44 	sub	r9,sp,-1724
8000810c:	14 97       	mov	r7,r10
8000810e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008112:	ec ea fd 88 	ld.d	r10,r6[-632]
80008116:	fa eb 00 00 	st.d	sp[0],r10
8000811a:	cc e8       	rjmp	800082b6 <_vfprintf_r+0x1516>
8000811c:	41 09       	lddsp	r9,sp[0x40]
8000811e:	59 f8       	cp.w	r8,31
80008120:	e0 89 00 16 	brgt	8000814c <_vfprintf_r+0x13ac>
80008124:	f2 e6 00 00 	ld.d	r6,r9[0]
80008128:	f2 cb ff f8 	sub	r11,r9,-8
8000812c:	fa e7 00 00 	st.d	sp[0],r6
80008130:	51 0b       	stdsp	sp[0x40],r11
80008132:	fa c6 f9 44 	sub	r6,sp,-1724
80008136:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000813a:	fa e6 00 00 	ld.d	r6,sp[0]
8000813e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008142:	2f f8       	sub	r8,-1
80008144:	14 97       	mov	r7,r10
80008146:	fb 48 06 b4 	st.w	sp[1716],r8
8000814a:	cb 68       	rjmp	800082b6 <_vfprintf_r+0x1516>
8000814c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008150:	2f 89       	sub	r9,-8
80008152:	fa e7 00 00 	st.d	sp[0],r6
80008156:	51 09       	stdsp	sp[0x40],r9
80008158:	14 97       	mov	r7,r10
8000815a:	ca e8       	rjmp	800082b6 <_vfprintf_r+0x1516>
8000815c:	ed b5 00 04 	bld	r5,0x4
80008160:	c1 71       	brne	8000818e <_vfprintf_r+0x13ee>
80008162:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008166:	40 3e       	lddsp	lr,sp[0xc]
80008168:	58 0e       	cp.w	lr,0
8000816a:	c0 80       	breq	8000817a <_vfprintf_r+0x13da>
8000816c:	10 36       	cp.w	r6,r8
8000816e:	c6 94       	brge	80008240 <_vfprintf_r+0x14a0>
80008170:	fa cc f9 44 	sub	r12,sp,-1724
80008174:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008178:	c8 28       	rjmp	8000827c <_vfprintf_r+0x14dc>
8000817a:	ee ca ff ff 	sub	r10,r7,-1
8000817e:	10 37       	cp.w	r7,r8
80008180:	e0 84 00 81 	brge	80008282 <_vfprintf_r+0x14e2>
80008184:	fa cb f9 44 	sub	r11,sp,-1724
80008188:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000818c:	c7 78       	rjmp	8000827a <_vfprintf_r+0x14da>
8000818e:	ed b5 00 06 	bld	r5,0x6
80008192:	c4 b1       	brne	80008228 <_vfprintf_r+0x1488>
80008194:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008198:	40 3c       	lddsp	r12,sp[0xc]
8000819a:	58 0c       	cp.w	r12,0
8000819c:	c1 d0       	breq	800081d6 <_vfprintf_r+0x1436>
8000819e:	10 36       	cp.w	r6,r8
800081a0:	c0 64       	brge	800081ac <_vfprintf_r+0x140c>
800081a2:	fa cb f9 44 	sub	r11,sp,-1724
800081a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081aa:	c1 f8       	rjmp	800081e8 <_vfprintf_r+0x1448>
800081ac:	fa c8 f9 50 	sub	r8,sp,-1712
800081b0:	1a d8       	st.w	--sp,r8
800081b2:	fa c8 fa b8 	sub	r8,sp,-1352
800081b6:	1a d8       	st.w	--sp,r8
800081b8:	fa c8 fb b4 	sub	r8,sp,-1100
800081bc:	1a d8       	st.w	--sp,r8
800081be:	fa c8 f9 40 	sub	r8,sp,-1728
800081c2:	fa c9 ff b4 	sub	r9,sp,-76
800081c6:	04 9a       	mov	r10,r2
800081c8:	0c 9b       	mov	r11,r6
800081ca:	08 9c       	mov	r12,r4
800081cc:	fe b0 f4 52 	rcall	80006a70 <get_arg>
800081d0:	2f dd       	sub	sp,-12
800081d2:	98 18       	ld.sh	r8,r12[0x2]
800081d4:	c2 78       	rjmp	80008222 <_vfprintf_r+0x1482>
800081d6:	ee ca ff ff 	sub	r10,r7,-1
800081da:	10 37       	cp.w	r7,r8
800081dc:	c0 a4       	brge	800081f0 <_vfprintf_r+0x1450>
800081de:	fa c9 f9 44 	sub	r9,sp,-1724
800081e2:	14 97       	mov	r7,r10
800081e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081e8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800081ec:	c1 b8       	rjmp	80008222 <_vfprintf_r+0x1482>
800081ee:	d7 03       	nop
800081f0:	41 09       	lddsp	r9,sp[0x40]
800081f2:	59 f8       	cp.w	r8,31
800081f4:	e0 89 00 13 	brgt	8000821a <_vfprintf_r+0x147a>
800081f8:	f2 cb ff fc 	sub	r11,r9,-4
800081fc:	51 0b       	stdsp	sp[0x40],r11
800081fe:	72 09       	ld.w	r9,r9[0x0]
80008200:	fa c6 f9 44 	sub	r6,sp,-1724
80008204:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008208:	2f f8       	sub	r8,-1
8000820a:	f7 49 fd 88 	st.w	r11[-632],r9
8000820e:	fb 48 06 b4 	st.w	sp[1716],r8
80008212:	14 97       	mov	r7,r10
80008214:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008218:	c0 58       	rjmp	80008222 <_vfprintf_r+0x1482>
8000821a:	92 18       	ld.sh	r8,r9[0x2]
8000821c:	14 97       	mov	r7,r10
8000821e:	2f c9       	sub	r9,-4
80008220:	51 09       	stdsp	sp[0x40],r9
80008222:	5c 78       	castu.h	r8
80008224:	50 18       	stdsp	sp[0x4],r8
80008226:	c4 68       	rjmp	800082b2 <_vfprintf_r+0x1512>
80008228:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000822c:	40 3c       	lddsp	r12,sp[0xc]
8000822e:	58 0c       	cp.w	r12,0
80008230:	c1 d0       	breq	8000826a <_vfprintf_r+0x14ca>
80008232:	10 36       	cp.w	r6,r8
80008234:	c0 64       	brge	80008240 <_vfprintf_r+0x14a0>
80008236:	fa cb f9 44 	sub	r11,sp,-1724
8000823a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000823e:	c1 f8       	rjmp	8000827c <_vfprintf_r+0x14dc>
80008240:	fa c8 f9 50 	sub	r8,sp,-1712
80008244:	1a d8       	st.w	--sp,r8
80008246:	fa c8 fa b8 	sub	r8,sp,-1352
8000824a:	0c 9b       	mov	r11,r6
8000824c:	1a d8       	st.w	--sp,r8
8000824e:	fa c8 fb b4 	sub	r8,sp,-1100
80008252:	04 9a       	mov	r10,r2
80008254:	1a d8       	st.w	--sp,r8
80008256:	08 9c       	mov	r12,r4
80008258:	fa c8 f9 40 	sub	r8,sp,-1728
8000825c:	fa c9 ff b4 	sub	r9,sp,-76
80008260:	fe b0 f4 08 	rcall	80006a70 <get_arg>
80008264:	2f dd       	sub	sp,-12
80008266:	78 0b       	ld.w	r11,r12[0x0]
80008268:	c2 48       	rjmp	800082b0 <_vfprintf_r+0x1510>
8000826a:	ee ca ff ff 	sub	r10,r7,-1
8000826e:	10 37       	cp.w	r7,r8
80008270:	c0 94       	brge	80008282 <_vfprintf_r+0x14e2>
80008272:	fa c9 f9 44 	sub	r9,sp,-1724
80008276:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000827a:	14 97       	mov	r7,r10
8000827c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008280:	c1 88       	rjmp	800082b0 <_vfprintf_r+0x1510>
80008282:	41 09       	lddsp	r9,sp[0x40]
80008284:	59 f8       	cp.w	r8,31
80008286:	e0 89 00 11 	brgt	800082a8 <_vfprintf_r+0x1508>
8000828a:	f2 cb ff fc 	sub	r11,r9,-4
8000828e:	51 0b       	stdsp	sp[0x40],r11
80008290:	fa c6 f9 44 	sub	r6,sp,-1724
80008294:	72 0b       	ld.w	r11,r9[0x0]
80008296:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000829a:	f3 4b fd 88 	st.w	r9[-632],r11
8000829e:	2f f8       	sub	r8,-1
800082a0:	14 97       	mov	r7,r10
800082a2:	fb 48 06 b4 	st.w	sp[1716],r8
800082a6:	c0 58       	rjmp	800082b0 <_vfprintf_r+0x1510>
800082a8:	72 0b       	ld.w	r11,r9[0x0]
800082aa:	14 97       	mov	r7,r10
800082ac:	2f c9       	sub	r9,-4
800082ae:	51 09       	stdsp	sp[0x40],r9
800082b0:	50 1b       	stdsp	sp[0x4],r11
800082b2:	30 0e       	mov	lr,0
800082b4:	50 0e       	stdsp	sp[0x0],lr
800082b6:	40 08       	lddsp	r8,sp[0x0]
800082b8:	40 1c       	lddsp	r12,sp[0x4]
800082ba:	18 48       	or	r8,r12
800082bc:	5f 19       	srne	r9
800082be:	0a 98       	mov	r8,r5
800082c0:	eb e9 00 09 	and	r9,r5,r9
800082c4:	a1 b8       	sbr	r8,0x1
800082c6:	58 09       	cp.w	r9,0
800082c8:	c0 70       	breq	800082d6 <_vfprintf_r+0x1536>
800082ca:	10 95       	mov	r5,r8
800082cc:	fb 60 06 b9 	st.b	sp[1721],r0
800082d0:	33 08       	mov	r8,48
800082d2:	fb 68 06 b8 	st.b	sp[1720],r8
800082d6:	30 28       	mov	r8,2
800082d8:	30 09       	mov	r9,0
800082da:	fb 69 06 bb 	st.b	sp[1723],r9
800082de:	0a 99       	mov	r9,r5
800082e0:	a7 d9       	cbr	r9,0x7
800082e2:	40 2b       	lddsp	r11,sp[0x8]
800082e4:	40 16       	lddsp	r6,sp[0x4]
800082e6:	58 0b       	cp.w	r11,0
800082e8:	5f 1a       	srne	r10
800082ea:	f2 05 17 40 	movge	r5,r9
800082ee:	fa c2 f9 78 	sub	r2,sp,-1672
800082f2:	40 09       	lddsp	r9,sp[0x0]
800082f4:	0c 49       	or	r9,r6
800082f6:	5f 19       	srne	r9
800082f8:	f5 e9 10 09 	or	r9,r10,r9
800082fc:	c5 c0       	breq	800083b4 <_vfprintf_r+0x1614>
800082fe:	30 19       	mov	r9,1
80008300:	f2 08 18 00 	cp.b	r8,r9
80008304:	c0 60       	breq	80008310 <_vfprintf_r+0x1570>
80008306:	30 29       	mov	r9,2
80008308:	f2 08 18 00 	cp.b	r8,r9
8000830c:	c0 41       	brne	80008314 <_vfprintf_r+0x1574>
8000830e:	c3 c8       	rjmp	80008386 <_vfprintf_r+0x15e6>
80008310:	04 96       	mov	r6,r2
80008312:	c3 08       	rjmp	80008372 <_vfprintf_r+0x15d2>
80008314:	04 96       	mov	r6,r2
80008316:	fa e8 00 00 	ld.d	r8,sp[0]
8000831a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000831e:	2d 0a       	sub	r10,-48
80008320:	0c fa       	st.b	--r6,r10
80008322:	f0 0b 16 03 	lsr	r11,r8,0x3
80008326:	f2 0c 16 03 	lsr	r12,r9,0x3
8000832a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000832e:	18 99       	mov	r9,r12
80008330:	16 98       	mov	r8,r11
80008332:	58 08       	cp.w	r8,0
80008334:	5c 29       	cpc	r9
80008336:	cf 21       	brne	8000831a <_vfprintf_r+0x157a>
80008338:	fa e9 00 00 	st.d	sp[0],r8
8000833c:	ed b5 00 00 	bld	r5,0x0
80008340:	c4 51       	brne	800083ca <_vfprintf_r+0x162a>
80008342:	33 09       	mov	r9,48
80008344:	f2 0a 18 00 	cp.b	r10,r9
80008348:	c4 10       	breq	800083ca <_vfprintf_r+0x162a>
8000834a:	0c f9       	st.b	--r6,r9
8000834c:	c3 f8       	rjmp	800083ca <_vfprintf_r+0x162a>
8000834e:	fa ea 00 00 	ld.d	r10,sp[0]
80008352:	30 a8       	mov	r8,10
80008354:	30 09       	mov	r9,0
80008356:	e0 a0 1a 19 	rcall	8000b788 <__avr32_umod64>
8000835a:	30 a8       	mov	r8,10
8000835c:	2d 0a       	sub	r10,-48
8000835e:	30 09       	mov	r9,0
80008360:	ac 8a       	st.b	r6[0x0],r10
80008362:	fa ea 00 00 	ld.d	r10,sp[0]
80008366:	e0 a0 18 df 	rcall	8000b524 <__avr32_udiv64>
8000836a:	16 99       	mov	r9,r11
8000836c:	14 98       	mov	r8,r10
8000836e:	fa e9 00 00 	st.d	sp[0],r8
80008372:	20 16       	sub	r6,1
80008374:	fa ea 00 00 	ld.d	r10,sp[0]
80008378:	58 9a       	cp.w	r10,9
8000837a:	5c 2b       	cpc	r11
8000837c:	fe 9b ff e9 	brhi	8000834e <_vfprintf_r+0x15ae>
80008380:	1b f8       	ld.ub	r8,sp[0x7]
80008382:	2d 08       	sub	r8,-48
80008384:	c2 08       	rjmp	800083c4 <_vfprintf_r+0x1624>
80008386:	04 96       	mov	r6,r2
80008388:	fa e8 00 00 	ld.d	r8,sp[0]
8000838c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008390:	40 de       	lddsp	lr,sp[0x34]
80008392:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008396:	0c fa       	st.b	--r6,r10
80008398:	f2 0b 16 04 	lsr	r11,r9,0x4
8000839c:	f0 0a 16 04 	lsr	r10,r8,0x4
800083a0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800083a4:	16 99       	mov	r9,r11
800083a6:	14 98       	mov	r8,r10
800083a8:	58 08       	cp.w	r8,0
800083aa:	5c 29       	cpc	r9
800083ac:	cf 01       	brne	8000838c <_vfprintf_r+0x15ec>
800083ae:	fa e9 00 00 	st.d	sp[0],r8
800083b2:	c0 c8       	rjmp	800083ca <_vfprintf_r+0x162a>
800083b4:	58 08       	cp.w	r8,0
800083b6:	c0 91       	brne	800083c8 <_vfprintf_r+0x1628>
800083b8:	ed b5 00 00 	bld	r5,0x0
800083bc:	c0 61       	brne	800083c8 <_vfprintf_r+0x1628>
800083be:	fa c6 f9 79 	sub	r6,sp,-1671
800083c2:	33 08       	mov	r8,48
800083c4:	ac 88       	st.b	r6[0x0],r8
800083c6:	c0 28       	rjmp	800083ca <_vfprintf_r+0x162a>
800083c8:	04 96       	mov	r6,r2
800083ca:	0c 12       	sub	r2,r6
800083cc:	c1 c8       	rjmp	80008404 <_vfprintf_r+0x1664>
800083ce:	50 a7       	stdsp	sp[0x28],r7
800083d0:	50 80       	stdsp	sp[0x20],r0
800083d2:	40 93       	lddsp	r3,sp[0x24]
800083d4:	0c 97       	mov	r7,r6
800083d6:	10 90       	mov	r0,r8
800083d8:	04 94       	mov	r4,r2
800083da:	40 41       	lddsp	r1,sp[0x10]
800083dc:	58 08       	cp.w	r8,0
800083de:	e0 80 04 4f 	breq	80008c7c <_vfprintf_r+0x1edc>
800083e2:	fb 68 06 60 	st.b	sp[1632],r8
800083e6:	30 0c       	mov	r12,0
800083e8:	30 08       	mov	r8,0
800083ea:	30 12       	mov	r2,1
800083ec:	fb 68 06 bb 	st.b	sp[1723],r8
800083f0:	50 2c       	stdsp	sp[0x8],r12
800083f2:	fa c6 f9 a0 	sub	r6,sp,-1632
800083f6:	c0 78       	rjmp	80008404 <_vfprintf_r+0x1664>
800083f8:	30 0b       	mov	r11,0
800083fa:	50 2b       	stdsp	sp[0x8],r11
800083fc:	c0 48       	rjmp	80008404 <_vfprintf_r+0x1664>
800083fe:	40 22       	lddsp	r2,sp[0x8]
80008400:	30 0a       	mov	r10,0
80008402:	50 2a       	stdsp	sp[0x8],r10
80008404:	40 29       	lddsp	r9,sp[0x8]
80008406:	e4 09 0c 49 	max	r9,r2,r9
8000840a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000840e:	50 39       	stdsp	sp[0xc],r9
80008410:	0a 9e       	mov	lr,r5
80008412:	30 09       	mov	r9,0
80008414:	e2 1e 00 02 	andl	lr,0x2,COH
80008418:	f2 08 18 00 	cp.b	r8,r9
8000841c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008420:	f7 b8 01 ff 	subne	r8,-1
80008424:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008428:	0a 9b       	mov	r11,r5
8000842a:	58 0e       	cp.w	lr,0
8000842c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008430:	f7 bc 01 fe 	subne	r12,-2
80008434:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008438:	e2 1b 00 84 	andl	r11,0x84,COH
8000843c:	50 fe       	stdsp	sp[0x3c],lr
8000843e:	50 9b       	stdsp	sp[0x24],r11
80008440:	c4 71       	brne	800084ce <_vfprintf_r+0x172e>
80008442:	40 8a       	lddsp	r10,sp[0x20]
80008444:	40 39       	lddsp	r9,sp[0xc]
80008446:	12 1a       	sub	r10,r9
80008448:	50 4a       	stdsp	sp[0x10],r10
8000844a:	58 0a       	cp.w	r10,0
8000844c:	e0 89 00 20 	brgt	8000848c <_vfprintf_r+0x16ec>
80008450:	c3 f8       	rjmp	800084ce <_vfprintf_r+0x172e>
80008452:	2f 09       	sub	r9,-16
80008454:	2f f8       	sub	r8,-1
80008456:	fe ce ba 96 	sub	lr,pc,-17770
8000845a:	31 0c       	mov	r12,16
8000845c:	fb 49 06 90 	st.w	sp[1680],r9
80008460:	87 0e       	st.w	r3[0x0],lr
80008462:	87 1c       	st.w	r3[0x4],r12
80008464:	fb 48 06 8c 	st.w	sp[1676],r8
80008468:	58 78       	cp.w	r8,7
8000846a:	e0 89 00 04 	brgt	80008472 <_vfprintf_r+0x16d2>
8000846e:	2f 83       	sub	r3,-8
80008470:	c0 b8       	rjmp	80008486 <_vfprintf_r+0x16e6>
80008472:	fa ca f9 78 	sub	r10,sp,-1672
80008476:	02 9b       	mov	r11,r1
80008478:	08 9c       	mov	r12,r4
8000847a:	fe b0 f4 85 	rcall	80006d84 <__sprint_r>
8000847e:	e0 81 04 10 	brne	80008c9e <_vfprintf_r+0x1efe>
80008482:	fa c3 f9 e0 	sub	r3,sp,-1568
80008486:	40 4b       	lddsp	r11,sp[0x10]
80008488:	21 0b       	sub	r11,16
8000848a:	50 4b       	stdsp	sp[0x10],r11
8000848c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008490:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008494:	fe ca ba d4 	sub	r10,pc,-17708
80008498:	40 4e       	lddsp	lr,sp[0x10]
8000849a:	59 0e       	cp.w	lr,16
8000849c:	fe 99 ff db 	brgt	80008452 <_vfprintf_r+0x16b2>
800084a0:	1c 09       	add	r9,lr
800084a2:	2f f8       	sub	r8,-1
800084a4:	87 0a       	st.w	r3[0x0],r10
800084a6:	fb 49 06 90 	st.w	sp[1680],r9
800084aa:	87 1e       	st.w	r3[0x4],lr
800084ac:	fb 48 06 8c 	st.w	sp[1676],r8
800084b0:	58 78       	cp.w	r8,7
800084b2:	e0 89 00 04 	brgt	800084ba <_vfprintf_r+0x171a>
800084b6:	2f 83       	sub	r3,-8
800084b8:	c0 b8       	rjmp	800084ce <_vfprintf_r+0x172e>
800084ba:	fa ca f9 78 	sub	r10,sp,-1672
800084be:	02 9b       	mov	r11,r1
800084c0:	08 9c       	mov	r12,r4
800084c2:	fe b0 f4 61 	rcall	80006d84 <__sprint_r>
800084c6:	e0 81 03 ec 	brne	80008c9e <_vfprintf_r+0x1efe>
800084ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800084ce:	30 09       	mov	r9,0
800084d0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800084d4:	f2 08 18 00 	cp.b	r8,r9
800084d8:	c1 f0       	breq	80008516 <_vfprintf_r+0x1776>
800084da:	fa f8 06 90 	ld.w	r8,sp[1680]
800084de:	fa c9 f9 45 	sub	r9,sp,-1723
800084e2:	2f f8       	sub	r8,-1
800084e4:	87 09       	st.w	r3[0x0],r9
800084e6:	fb 48 06 90 	st.w	sp[1680],r8
800084ea:	30 19       	mov	r9,1
800084ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084f0:	87 19       	st.w	r3[0x4],r9
800084f2:	2f f8       	sub	r8,-1
800084f4:	fb 48 06 8c 	st.w	sp[1676],r8
800084f8:	58 78       	cp.w	r8,7
800084fa:	e0 89 00 04 	brgt	80008502 <_vfprintf_r+0x1762>
800084fe:	2f 83       	sub	r3,-8
80008500:	c0 b8       	rjmp	80008516 <_vfprintf_r+0x1776>
80008502:	fa ca f9 78 	sub	r10,sp,-1672
80008506:	02 9b       	mov	r11,r1
80008508:	08 9c       	mov	r12,r4
8000850a:	fe b0 f4 3d 	rcall	80006d84 <__sprint_r>
8000850e:	e0 81 03 c8 	brne	80008c9e <_vfprintf_r+0x1efe>
80008512:	fa c3 f9 e0 	sub	r3,sp,-1568
80008516:	40 fc       	lddsp	r12,sp[0x3c]
80008518:	58 0c       	cp.w	r12,0
8000851a:	c1 f0       	breq	80008558 <_vfprintf_r+0x17b8>
8000851c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008520:	fa c9 f9 48 	sub	r9,sp,-1720
80008524:	2f e8       	sub	r8,-2
80008526:	87 09       	st.w	r3[0x0],r9
80008528:	fb 48 06 90 	st.w	sp[1680],r8
8000852c:	30 29       	mov	r9,2
8000852e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008532:	87 19       	st.w	r3[0x4],r9
80008534:	2f f8       	sub	r8,-1
80008536:	fb 48 06 8c 	st.w	sp[1676],r8
8000853a:	58 78       	cp.w	r8,7
8000853c:	e0 89 00 04 	brgt	80008544 <_vfprintf_r+0x17a4>
80008540:	2f 83       	sub	r3,-8
80008542:	c0 b8       	rjmp	80008558 <_vfprintf_r+0x17b8>
80008544:	fa ca f9 78 	sub	r10,sp,-1672
80008548:	02 9b       	mov	r11,r1
8000854a:	08 9c       	mov	r12,r4
8000854c:	fe b0 f4 1c 	rcall	80006d84 <__sprint_r>
80008550:	e0 81 03 a7 	brne	80008c9e <_vfprintf_r+0x1efe>
80008554:	fa c3 f9 e0 	sub	r3,sp,-1568
80008558:	40 9b       	lddsp	r11,sp[0x24]
8000855a:	e0 4b 00 80 	cp.w	r11,128
8000855e:	c4 71       	brne	800085ec <_vfprintf_r+0x184c>
80008560:	40 8a       	lddsp	r10,sp[0x20]
80008562:	40 39       	lddsp	r9,sp[0xc]
80008564:	12 1a       	sub	r10,r9
80008566:	50 4a       	stdsp	sp[0x10],r10
80008568:	58 0a       	cp.w	r10,0
8000856a:	e0 89 00 20 	brgt	800085aa <_vfprintf_r+0x180a>
8000856e:	c3 f8       	rjmp	800085ec <_vfprintf_r+0x184c>
80008570:	2f 09       	sub	r9,-16
80008572:	2f f8       	sub	r8,-1
80008574:	fe ce bb a4 	sub	lr,pc,-17500
80008578:	31 0c       	mov	r12,16
8000857a:	fb 49 06 90 	st.w	sp[1680],r9
8000857e:	87 0e       	st.w	r3[0x0],lr
80008580:	87 1c       	st.w	r3[0x4],r12
80008582:	fb 48 06 8c 	st.w	sp[1676],r8
80008586:	58 78       	cp.w	r8,7
80008588:	e0 89 00 04 	brgt	80008590 <_vfprintf_r+0x17f0>
8000858c:	2f 83       	sub	r3,-8
8000858e:	c0 b8       	rjmp	800085a4 <_vfprintf_r+0x1804>
80008590:	fa ca f9 78 	sub	r10,sp,-1672
80008594:	02 9b       	mov	r11,r1
80008596:	08 9c       	mov	r12,r4
80008598:	fe b0 f3 f6 	rcall	80006d84 <__sprint_r>
8000859c:	e0 81 03 81 	brne	80008c9e <_vfprintf_r+0x1efe>
800085a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800085a4:	40 4b       	lddsp	r11,sp[0x10]
800085a6:	21 0b       	sub	r11,16
800085a8:	50 4b       	stdsp	sp[0x10],r11
800085aa:	fa f9 06 90 	ld.w	r9,sp[1680]
800085ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085b2:	fe ca bb e2 	sub	r10,pc,-17438
800085b6:	40 4e       	lddsp	lr,sp[0x10]
800085b8:	59 0e       	cp.w	lr,16
800085ba:	fe 99 ff db 	brgt	80008570 <_vfprintf_r+0x17d0>
800085be:	1c 09       	add	r9,lr
800085c0:	2f f8       	sub	r8,-1
800085c2:	87 0a       	st.w	r3[0x0],r10
800085c4:	fb 49 06 90 	st.w	sp[1680],r9
800085c8:	87 1e       	st.w	r3[0x4],lr
800085ca:	fb 48 06 8c 	st.w	sp[1676],r8
800085ce:	58 78       	cp.w	r8,7
800085d0:	e0 89 00 04 	brgt	800085d8 <_vfprintf_r+0x1838>
800085d4:	2f 83       	sub	r3,-8
800085d6:	c0 b8       	rjmp	800085ec <_vfprintf_r+0x184c>
800085d8:	fa ca f9 78 	sub	r10,sp,-1672
800085dc:	02 9b       	mov	r11,r1
800085de:	08 9c       	mov	r12,r4
800085e0:	fe b0 f3 d2 	rcall	80006d84 <__sprint_r>
800085e4:	e0 81 03 5d 	brne	80008c9e <_vfprintf_r+0x1efe>
800085e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800085ec:	40 2c       	lddsp	r12,sp[0x8]
800085ee:	04 1c       	sub	r12,r2
800085f0:	50 2c       	stdsp	sp[0x8],r12
800085f2:	58 0c       	cp.w	r12,0
800085f4:	e0 89 00 20 	brgt	80008634 <_vfprintf_r+0x1894>
800085f8:	c3 f8       	rjmp	80008676 <_vfprintf_r+0x18d6>
800085fa:	2f 09       	sub	r9,-16
800085fc:	2f f8       	sub	r8,-1
800085fe:	fe cb bc 2e 	sub	r11,pc,-17362
80008602:	31 0a       	mov	r10,16
80008604:	fb 49 06 90 	st.w	sp[1680],r9
80008608:	87 0b       	st.w	r3[0x0],r11
8000860a:	87 1a       	st.w	r3[0x4],r10
8000860c:	fb 48 06 8c 	st.w	sp[1676],r8
80008610:	58 78       	cp.w	r8,7
80008612:	e0 89 00 04 	brgt	8000861a <_vfprintf_r+0x187a>
80008616:	2f 83       	sub	r3,-8
80008618:	c0 b8       	rjmp	8000862e <_vfprintf_r+0x188e>
8000861a:	fa ca f9 78 	sub	r10,sp,-1672
8000861e:	02 9b       	mov	r11,r1
80008620:	08 9c       	mov	r12,r4
80008622:	fe b0 f3 b1 	rcall	80006d84 <__sprint_r>
80008626:	e0 81 03 3c 	brne	80008c9e <_vfprintf_r+0x1efe>
8000862a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000862e:	40 29       	lddsp	r9,sp[0x8]
80008630:	21 09       	sub	r9,16
80008632:	50 29       	stdsp	sp[0x8],r9
80008634:	fa f9 06 90 	ld.w	r9,sp[1680]
80008638:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000863c:	fe ca bc 6c 	sub	r10,pc,-17300
80008640:	40 2e       	lddsp	lr,sp[0x8]
80008642:	59 0e       	cp.w	lr,16
80008644:	fe 99 ff db 	brgt	800085fa <_vfprintf_r+0x185a>
80008648:	1c 09       	add	r9,lr
8000864a:	2f f8       	sub	r8,-1
8000864c:	87 0a       	st.w	r3[0x0],r10
8000864e:	fb 49 06 90 	st.w	sp[1680],r9
80008652:	87 1e       	st.w	r3[0x4],lr
80008654:	fb 48 06 8c 	st.w	sp[1676],r8
80008658:	58 78       	cp.w	r8,7
8000865a:	e0 89 00 04 	brgt	80008662 <_vfprintf_r+0x18c2>
8000865e:	2f 83       	sub	r3,-8
80008660:	c0 b8       	rjmp	80008676 <_vfprintf_r+0x18d6>
80008662:	fa ca f9 78 	sub	r10,sp,-1672
80008666:	02 9b       	mov	r11,r1
80008668:	08 9c       	mov	r12,r4
8000866a:	fe b0 f3 8d 	rcall	80006d84 <__sprint_r>
8000866e:	e0 81 03 18 	brne	80008c9e <_vfprintf_r+0x1efe>
80008672:	fa c3 f9 e0 	sub	r3,sp,-1568
80008676:	ed b5 00 08 	bld	r5,0x8
8000867a:	c0 b0       	breq	80008690 <_vfprintf_r+0x18f0>
8000867c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008680:	87 12       	st.w	r3[0x4],r2
80008682:	87 06       	st.w	r3[0x0],r6
80008684:	f0 02 00 02 	add	r2,r8,r2
80008688:	fb 42 06 90 	st.w	sp[1680],r2
8000868c:	e0 8f 01 d4 	bral	80008a34 <_vfprintf_r+0x1c94>
80008690:	e0 40 00 65 	cp.w	r0,101
80008694:	e0 8a 01 d6 	brle	80008a40 <_vfprintf_r+0x1ca0>
80008698:	30 08       	mov	r8,0
8000869a:	30 09       	mov	r9,0
8000869c:	40 5b       	lddsp	r11,sp[0x14]
8000869e:	40 7a       	lddsp	r10,sp[0x1c]
800086a0:	e0 a0 15 3b 	rcall	8000b116 <__avr32_f64_cmp_eq>
800086a4:	c7 90       	breq	80008796 <_vfprintf_r+0x19f6>
800086a6:	fa f8 06 90 	ld.w	r8,sp[1680]
800086aa:	fe c9 bc ee 	sub	r9,pc,-17170
800086ae:	2f f8       	sub	r8,-1
800086b0:	87 09       	st.w	r3[0x0],r9
800086b2:	fb 48 06 90 	st.w	sp[1680],r8
800086b6:	30 19       	mov	r9,1
800086b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086bc:	87 19       	st.w	r3[0x4],r9
800086be:	2f f8       	sub	r8,-1
800086c0:	fb 48 06 8c 	st.w	sp[1676],r8
800086c4:	58 78       	cp.w	r8,7
800086c6:	e0 89 00 05 	brgt	800086d0 <_vfprintf_r+0x1930>
800086ca:	2f 83       	sub	r3,-8
800086cc:	c0 c8       	rjmp	800086e4 <_vfprintf_r+0x1944>
800086ce:	d7 03       	nop
800086d0:	fa ca f9 78 	sub	r10,sp,-1672
800086d4:	02 9b       	mov	r11,r1
800086d6:	08 9c       	mov	r12,r4
800086d8:	fe b0 f3 56 	rcall	80006d84 <__sprint_r>
800086dc:	e0 81 02 e1 	brne	80008c9e <_vfprintf_r+0x1efe>
800086e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800086e4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800086e8:	40 6c       	lddsp	r12,sp[0x18]
800086ea:	18 38       	cp.w	r8,r12
800086ec:	c0 55       	brlt	800086f6 <_vfprintf_r+0x1956>
800086ee:	ed b5 00 00 	bld	r5,0x0
800086f2:	e0 81 02 6b 	brne	80008bc8 <_vfprintf_r+0x1e28>
800086f6:	fa f8 06 90 	ld.w	r8,sp[1680]
800086fa:	2f f8       	sub	r8,-1
800086fc:	40 cb       	lddsp	r11,sp[0x30]
800086fe:	fb 48 06 90 	st.w	sp[1680],r8
80008702:	30 19       	mov	r9,1
80008704:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008708:	87 0b       	st.w	r3[0x0],r11
8000870a:	2f f8       	sub	r8,-1
8000870c:	87 19       	st.w	r3[0x4],r9
8000870e:	fb 48 06 8c 	st.w	sp[1676],r8
80008712:	58 78       	cp.w	r8,7
80008714:	e0 89 00 04 	brgt	8000871c <_vfprintf_r+0x197c>
80008718:	2f 83       	sub	r3,-8
8000871a:	c0 b8       	rjmp	80008730 <_vfprintf_r+0x1990>
8000871c:	fa ca f9 78 	sub	r10,sp,-1672
80008720:	02 9b       	mov	r11,r1
80008722:	08 9c       	mov	r12,r4
80008724:	fe b0 f3 30 	rcall	80006d84 <__sprint_r>
80008728:	e0 81 02 bb 	brne	80008c9e <_vfprintf_r+0x1efe>
8000872c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008730:	40 66       	lddsp	r6,sp[0x18]
80008732:	20 16       	sub	r6,1
80008734:	58 06       	cp.w	r6,0
80008736:	e0 89 00 1d 	brgt	80008770 <_vfprintf_r+0x19d0>
8000873a:	e0 8f 02 47 	bral	80008bc8 <_vfprintf_r+0x1e28>
8000873e:	2f 09       	sub	r9,-16
80008740:	2f f8       	sub	r8,-1
80008742:	fb 49 06 90 	st.w	sp[1680],r9
80008746:	87 02       	st.w	r3[0x0],r2
80008748:	87 10       	st.w	r3[0x4],r0
8000874a:	fb 48 06 8c 	st.w	sp[1676],r8
8000874e:	58 78       	cp.w	r8,7
80008750:	e0 89 00 04 	brgt	80008758 <_vfprintf_r+0x19b8>
80008754:	2f 83       	sub	r3,-8
80008756:	c0 b8       	rjmp	8000876c <_vfprintf_r+0x19cc>
80008758:	fa ca f9 78 	sub	r10,sp,-1672
8000875c:	02 9b       	mov	r11,r1
8000875e:	08 9c       	mov	r12,r4
80008760:	fe b0 f3 12 	rcall	80006d84 <__sprint_r>
80008764:	e0 81 02 9d 	brne	80008c9e <_vfprintf_r+0x1efe>
80008768:	fa c3 f9 e0 	sub	r3,sp,-1568
8000876c:	21 06       	sub	r6,16
8000876e:	c0 48       	rjmp	80008776 <_vfprintf_r+0x19d6>
80008770:	fe c2 bd a0 	sub	r2,pc,-16992
80008774:	31 00       	mov	r0,16
80008776:	fa f9 06 90 	ld.w	r9,sp[1680]
8000877a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000877e:	fe ca bd ae 	sub	r10,pc,-16978
80008782:	59 06       	cp.w	r6,16
80008784:	fe 99 ff dd 	brgt	8000873e <_vfprintf_r+0x199e>
80008788:	0c 09       	add	r9,r6
8000878a:	87 0a       	st.w	r3[0x0],r10
8000878c:	fb 49 06 90 	st.w	sp[1680],r9
80008790:	2f f8       	sub	r8,-1
80008792:	87 16       	st.w	r3[0x4],r6
80008794:	c5 39       	rjmp	80008a3a <_vfprintf_r+0x1c9a>
80008796:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000879a:	58 0a       	cp.w	r10,0
8000879c:	e0 89 00 92 	brgt	800088c0 <_vfprintf_r+0x1b20>
800087a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800087a4:	fe c9 bd e8 	sub	r9,pc,-16920
800087a8:	2f f8       	sub	r8,-1
800087aa:	87 09       	st.w	r3[0x0],r9
800087ac:	fb 48 06 90 	st.w	sp[1680],r8
800087b0:	30 19       	mov	r9,1
800087b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087b6:	87 19       	st.w	r3[0x4],r9
800087b8:	2f f8       	sub	r8,-1
800087ba:	fb 48 06 8c 	st.w	sp[1676],r8
800087be:	58 78       	cp.w	r8,7
800087c0:	e0 89 00 04 	brgt	800087c8 <_vfprintf_r+0x1a28>
800087c4:	2f 83       	sub	r3,-8
800087c6:	c0 b8       	rjmp	800087dc <_vfprintf_r+0x1a3c>
800087c8:	fa ca f9 78 	sub	r10,sp,-1672
800087cc:	02 9b       	mov	r11,r1
800087ce:	08 9c       	mov	r12,r4
800087d0:	fe b0 f2 da 	rcall	80006d84 <__sprint_r>
800087d4:	e0 81 02 65 	brne	80008c9e <_vfprintf_r+0x1efe>
800087d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800087dc:	fa f8 06 ac 	ld.w	r8,sp[1708]
800087e0:	58 08       	cp.w	r8,0
800087e2:	c0 81       	brne	800087f2 <_vfprintf_r+0x1a52>
800087e4:	40 6a       	lddsp	r10,sp[0x18]
800087e6:	58 0a       	cp.w	r10,0
800087e8:	c0 51       	brne	800087f2 <_vfprintf_r+0x1a52>
800087ea:	ed b5 00 00 	bld	r5,0x0
800087ee:	e0 81 01 ed 	brne	80008bc8 <_vfprintf_r+0x1e28>
800087f2:	40 c9       	lddsp	r9,sp[0x30]
800087f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800087f8:	2f f8       	sub	r8,-1
800087fa:	87 09       	st.w	r3[0x0],r9
800087fc:	fb 48 06 90 	st.w	sp[1680],r8
80008800:	30 19       	mov	r9,1
80008802:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008806:	87 19       	st.w	r3[0x4],r9
80008808:	2f f8       	sub	r8,-1
8000880a:	fb 48 06 8c 	st.w	sp[1676],r8
8000880e:	58 78       	cp.w	r8,7
80008810:	e0 89 00 04 	brgt	80008818 <_vfprintf_r+0x1a78>
80008814:	2f 83       	sub	r3,-8
80008816:	c0 b8       	rjmp	8000882c <_vfprintf_r+0x1a8c>
80008818:	fa ca f9 78 	sub	r10,sp,-1672
8000881c:	02 9b       	mov	r11,r1
8000881e:	08 9c       	mov	r12,r4
80008820:	fe b0 f2 b2 	rcall	80006d84 <__sprint_r>
80008824:	e0 81 02 3d 	brne	80008c9e <_vfprintf_r+0x1efe>
80008828:	fa c3 f9 e0 	sub	r3,sp,-1568
8000882c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008830:	5c 32       	neg	r2
80008832:	58 02       	cp.w	r2,0
80008834:	e0 89 00 1d 	brgt	8000886e <_vfprintf_r+0x1ace>
80008838:	c3 d8       	rjmp	800088b2 <_vfprintf_r+0x1b12>
8000883a:	2f 09       	sub	r9,-16
8000883c:	2f f8       	sub	r8,-1
8000883e:	31 0e       	mov	lr,16
80008840:	fb 49 06 90 	st.w	sp[1680],r9
80008844:	87 00       	st.w	r3[0x0],r0
80008846:	87 1e       	st.w	r3[0x4],lr
80008848:	fb 48 06 8c 	st.w	sp[1676],r8
8000884c:	58 78       	cp.w	r8,7
8000884e:	e0 89 00 04 	brgt	80008856 <_vfprintf_r+0x1ab6>
80008852:	2f 83       	sub	r3,-8
80008854:	c0 b8       	rjmp	8000886a <_vfprintf_r+0x1aca>
80008856:	fa ca f9 78 	sub	r10,sp,-1672
8000885a:	02 9b       	mov	r11,r1
8000885c:	08 9c       	mov	r12,r4
8000885e:	fe b0 f2 93 	rcall	80006d84 <__sprint_r>
80008862:	e0 81 02 1e 	brne	80008c9e <_vfprintf_r+0x1efe>
80008866:	fa c3 f9 e0 	sub	r3,sp,-1568
8000886a:	21 02       	sub	r2,16
8000886c:	c0 38       	rjmp	80008872 <_vfprintf_r+0x1ad2>
8000886e:	fe c0 be 9e 	sub	r0,pc,-16738
80008872:	fa f9 06 90 	ld.w	r9,sp[1680]
80008876:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000887a:	fe ca be aa 	sub	r10,pc,-16726
8000887e:	59 02       	cp.w	r2,16
80008880:	fe 99 ff dd 	brgt	8000883a <_vfprintf_r+0x1a9a>
80008884:	04 09       	add	r9,r2
80008886:	2f f8       	sub	r8,-1
80008888:	87 0a       	st.w	r3[0x0],r10
8000888a:	fb 49 06 90 	st.w	sp[1680],r9
8000888e:	87 12       	st.w	r3[0x4],r2
80008890:	fb 48 06 8c 	st.w	sp[1676],r8
80008894:	58 78       	cp.w	r8,7
80008896:	e0 89 00 04 	brgt	8000889e <_vfprintf_r+0x1afe>
8000889a:	2f 83       	sub	r3,-8
8000889c:	c0 b8       	rjmp	800088b2 <_vfprintf_r+0x1b12>
8000889e:	fa ca f9 78 	sub	r10,sp,-1672
800088a2:	02 9b       	mov	r11,r1
800088a4:	08 9c       	mov	r12,r4
800088a6:	fe b0 f2 6f 	rcall	80006d84 <__sprint_r>
800088aa:	e0 81 01 fa 	brne	80008c9e <_vfprintf_r+0x1efe>
800088ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800088b2:	40 6c       	lddsp	r12,sp[0x18]
800088b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800088b8:	87 06       	st.w	r3[0x0],r6
800088ba:	87 1c       	st.w	r3[0x4],r12
800088bc:	18 08       	add	r8,r12
800088be:	cb 98       	rjmp	80008a30 <_vfprintf_r+0x1c90>
800088c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800088c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088c8:	40 6b       	lddsp	r11,sp[0x18]
800088ca:	16 3a       	cp.w	r10,r11
800088cc:	c6 f5       	brlt	800089aa <_vfprintf_r+0x1c0a>
800088ce:	16 09       	add	r9,r11
800088d0:	2f f8       	sub	r8,-1
800088d2:	87 06       	st.w	r3[0x0],r6
800088d4:	fb 49 06 90 	st.w	sp[1680],r9
800088d8:	87 1b       	st.w	r3[0x4],r11
800088da:	fb 48 06 8c 	st.w	sp[1676],r8
800088de:	58 78       	cp.w	r8,7
800088e0:	e0 89 00 04 	brgt	800088e8 <_vfprintf_r+0x1b48>
800088e4:	2f 83       	sub	r3,-8
800088e6:	c0 b8       	rjmp	800088fc <_vfprintf_r+0x1b5c>
800088e8:	fa ca f9 78 	sub	r10,sp,-1672
800088ec:	02 9b       	mov	r11,r1
800088ee:	08 9c       	mov	r12,r4
800088f0:	fe b0 f2 4a 	rcall	80006d84 <__sprint_r>
800088f4:	e0 81 01 d5 	brne	80008c9e <_vfprintf_r+0x1efe>
800088f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800088fc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008900:	40 6a       	lddsp	r10,sp[0x18]
80008902:	14 16       	sub	r6,r10
80008904:	58 06       	cp.w	r6,0
80008906:	e0 89 00 1c 	brgt	8000893e <_vfprintf_r+0x1b9e>
8000890a:	c3 d8       	rjmp	80008984 <_vfprintf_r+0x1be4>
8000890c:	2f 09       	sub	r9,-16
8000890e:	2f f8       	sub	r8,-1
80008910:	fb 49 06 90 	st.w	sp[1680],r9
80008914:	87 02       	st.w	r3[0x0],r2
80008916:	87 10       	st.w	r3[0x4],r0
80008918:	fb 48 06 8c 	st.w	sp[1676],r8
8000891c:	58 78       	cp.w	r8,7
8000891e:	e0 89 00 04 	brgt	80008926 <_vfprintf_r+0x1b86>
80008922:	2f 83       	sub	r3,-8
80008924:	c0 b8       	rjmp	8000893a <_vfprintf_r+0x1b9a>
80008926:	fa ca f9 78 	sub	r10,sp,-1672
8000892a:	02 9b       	mov	r11,r1
8000892c:	08 9c       	mov	r12,r4
8000892e:	fe b0 f2 2b 	rcall	80006d84 <__sprint_r>
80008932:	e0 81 01 b6 	brne	80008c9e <_vfprintf_r+0x1efe>
80008936:	fa c3 f9 e0 	sub	r3,sp,-1568
8000893a:	21 06       	sub	r6,16
8000893c:	c0 48       	rjmp	80008944 <_vfprintf_r+0x1ba4>
8000893e:	fe c2 bf 6e 	sub	r2,pc,-16530
80008942:	31 00       	mov	r0,16
80008944:	fa f9 06 90 	ld.w	r9,sp[1680]
80008948:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000894c:	fe ca bf 7c 	sub	r10,pc,-16516
80008950:	59 06       	cp.w	r6,16
80008952:	fe 99 ff dd 	brgt	8000890c <_vfprintf_r+0x1b6c>
80008956:	0c 09       	add	r9,r6
80008958:	2f f8       	sub	r8,-1
8000895a:	87 0a       	st.w	r3[0x0],r10
8000895c:	fb 49 06 90 	st.w	sp[1680],r9
80008960:	87 16       	st.w	r3[0x4],r6
80008962:	fb 48 06 8c 	st.w	sp[1676],r8
80008966:	58 78       	cp.w	r8,7
80008968:	e0 89 00 04 	brgt	80008970 <_vfprintf_r+0x1bd0>
8000896c:	2f 83       	sub	r3,-8
8000896e:	c0 b8       	rjmp	80008984 <_vfprintf_r+0x1be4>
80008970:	fa ca f9 78 	sub	r10,sp,-1672
80008974:	02 9b       	mov	r11,r1
80008976:	08 9c       	mov	r12,r4
80008978:	fe b0 f2 06 	rcall	80006d84 <__sprint_r>
8000897c:	e0 81 01 91 	brne	80008c9e <_vfprintf_r+0x1efe>
80008980:	fa c3 f9 e0 	sub	r3,sp,-1568
80008984:	ed b5 00 00 	bld	r5,0x0
80008988:	e0 81 01 20 	brne	80008bc8 <_vfprintf_r+0x1e28>
8000898c:	40 c9       	lddsp	r9,sp[0x30]
8000898e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008992:	2f f8       	sub	r8,-1
80008994:	87 09       	st.w	r3[0x0],r9
80008996:	fb 48 06 90 	st.w	sp[1680],r8
8000899a:	30 19       	mov	r9,1
8000899c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089a0:	87 19       	st.w	r3[0x4],r9
800089a2:	2f f8       	sub	r8,-1
800089a4:	fb 48 06 8c 	st.w	sp[1676],r8
800089a8:	c0 29       	rjmp	80008bac <_vfprintf_r+0x1e0c>
800089aa:	14 09       	add	r9,r10
800089ac:	2f f8       	sub	r8,-1
800089ae:	fb 49 06 90 	st.w	sp[1680],r9
800089b2:	87 06       	st.w	r3[0x0],r6
800089b4:	87 1a       	st.w	r3[0x4],r10
800089b6:	fb 48 06 8c 	st.w	sp[1676],r8
800089ba:	58 78       	cp.w	r8,7
800089bc:	e0 89 00 04 	brgt	800089c4 <_vfprintf_r+0x1c24>
800089c0:	2f 83       	sub	r3,-8
800089c2:	c0 b8       	rjmp	800089d8 <_vfprintf_r+0x1c38>
800089c4:	fa ca f9 78 	sub	r10,sp,-1672
800089c8:	02 9b       	mov	r11,r1
800089ca:	08 9c       	mov	r12,r4
800089cc:	fe b0 f1 dc 	rcall	80006d84 <__sprint_r>
800089d0:	e0 81 01 67 	brne	80008c9e <_vfprintf_r+0x1efe>
800089d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800089d8:	40 c8       	lddsp	r8,sp[0x30]
800089da:	87 08       	st.w	r3[0x0],r8
800089dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800089e0:	2f f8       	sub	r8,-1
800089e2:	30 19       	mov	r9,1
800089e4:	fb 48 06 90 	st.w	sp[1680],r8
800089e8:	87 19       	st.w	r3[0x4],r9
800089ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089ee:	2f f8       	sub	r8,-1
800089f0:	fb 48 06 8c 	st.w	sp[1676],r8
800089f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089f8:	58 78       	cp.w	r8,7
800089fa:	e0 89 00 04 	brgt	80008a02 <_vfprintf_r+0x1c62>
800089fe:	2f 83       	sub	r3,-8
80008a00:	c0 b8       	rjmp	80008a16 <_vfprintf_r+0x1c76>
80008a02:	fa ca f9 78 	sub	r10,sp,-1672
80008a06:	02 9b       	mov	r11,r1
80008a08:	08 9c       	mov	r12,r4
80008a0a:	fe b0 f1 bd 	rcall	80006d84 <__sprint_r>
80008a0e:	e0 81 01 48 	brne	80008c9e <_vfprintf_r+0x1efe>
80008a12:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a16:	04 06       	add	r6,r2
80008a18:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a1c:	87 06       	st.w	r3[0x0],r6
80008a1e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a22:	40 66       	lddsp	r6,sp[0x18]
80008a24:	40 6e       	lddsp	lr,sp[0x18]
80008a26:	10 16       	sub	r6,r8
80008a28:	f2 08 01 08 	sub	r8,r9,r8
80008a2c:	87 16       	st.w	r3[0x4],r6
80008a2e:	1c 08       	add	r8,lr
80008a30:	fb 48 06 90 	st.w	sp[1680],r8
80008a34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a38:	2f f8       	sub	r8,-1
80008a3a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a3e:	cb 78       	rjmp	80008bac <_vfprintf_r+0x1e0c>
80008a40:	40 6c       	lddsp	r12,sp[0x18]
80008a42:	58 1c       	cp.w	r12,1
80008a44:	e0 89 00 06 	brgt	80008a50 <_vfprintf_r+0x1cb0>
80008a48:	ed b5 00 00 	bld	r5,0x0
80008a4c:	e0 81 00 85 	brne	80008b56 <_vfprintf_r+0x1db6>
80008a50:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a54:	2f f8       	sub	r8,-1
80008a56:	30 19       	mov	r9,1
80008a58:	fb 48 06 90 	st.w	sp[1680],r8
80008a5c:	87 06       	st.w	r3[0x0],r6
80008a5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a62:	87 19       	st.w	r3[0x4],r9
80008a64:	2f f8       	sub	r8,-1
80008a66:	fb 48 06 8c 	st.w	sp[1676],r8
80008a6a:	58 78       	cp.w	r8,7
80008a6c:	e0 89 00 04 	brgt	80008a74 <_vfprintf_r+0x1cd4>
80008a70:	2f 83       	sub	r3,-8
80008a72:	c0 b8       	rjmp	80008a88 <_vfprintf_r+0x1ce8>
80008a74:	fa ca f9 78 	sub	r10,sp,-1672
80008a78:	02 9b       	mov	r11,r1
80008a7a:	08 9c       	mov	r12,r4
80008a7c:	fe b0 f1 84 	rcall	80006d84 <__sprint_r>
80008a80:	e0 81 01 0f 	brne	80008c9e <_vfprintf_r+0x1efe>
80008a84:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a88:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a8c:	2f f8       	sub	r8,-1
80008a8e:	40 cb       	lddsp	r11,sp[0x30]
80008a90:	fb 48 06 90 	st.w	sp[1680],r8
80008a94:	30 19       	mov	r9,1
80008a96:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a9a:	87 0b       	st.w	r3[0x0],r11
80008a9c:	2f f8       	sub	r8,-1
80008a9e:	87 19       	st.w	r3[0x4],r9
80008aa0:	fb 48 06 8c 	st.w	sp[1676],r8
80008aa4:	58 78       	cp.w	r8,7
80008aa6:	e0 89 00 05 	brgt	80008ab0 <_vfprintf_r+0x1d10>
80008aaa:	2f 83       	sub	r3,-8
80008aac:	c0 c8       	rjmp	80008ac4 <_vfprintf_r+0x1d24>
80008aae:	d7 03       	nop
80008ab0:	fa ca f9 78 	sub	r10,sp,-1672
80008ab4:	02 9b       	mov	r11,r1
80008ab6:	08 9c       	mov	r12,r4
80008ab8:	fe b0 f1 66 	rcall	80006d84 <__sprint_r>
80008abc:	e0 81 00 f1 	brne	80008c9e <_vfprintf_r+0x1efe>
80008ac0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ac4:	30 08       	mov	r8,0
80008ac6:	30 09       	mov	r9,0
80008ac8:	40 5b       	lddsp	r11,sp[0x14]
80008aca:	40 7a       	lddsp	r10,sp[0x1c]
80008acc:	e0 a0 13 25 	rcall	8000b116 <__avr32_f64_cmp_eq>
80008ad0:	40 68       	lddsp	r8,sp[0x18]
80008ad2:	20 18       	sub	r8,1
80008ad4:	58 0c       	cp.w	r12,0
80008ad6:	c0 d1       	brne	80008af0 <_vfprintf_r+0x1d50>
80008ad8:	2f f6       	sub	r6,-1
80008ada:	87 18       	st.w	r3[0x4],r8
80008adc:	87 06       	st.w	r3[0x0],r6
80008ade:	fa f6 06 90 	ld.w	r6,sp[1680]
80008ae2:	10 06       	add	r6,r8
80008ae4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ae8:	fb 46 06 90 	st.w	sp[1680],r6
80008aec:	2f f8       	sub	r8,-1
80008aee:	c3 18       	rjmp	80008b50 <_vfprintf_r+0x1db0>
80008af0:	10 96       	mov	r6,r8
80008af2:	58 08       	cp.w	r8,0
80008af4:	e0 89 00 1c 	brgt	80008b2c <_vfprintf_r+0x1d8c>
80008af8:	c4 b8       	rjmp	80008b8e <_vfprintf_r+0x1dee>
80008afa:	2f 09       	sub	r9,-16
80008afc:	2f f8       	sub	r8,-1
80008afe:	fb 49 06 90 	st.w	sp[1680],r9
80008b02:	87 02       	st.w	r3[0x0],r2
80008b04:	87 10       	st.w	r3[0x4],r0
80008b06:	fb 48 06 8c 	st.w	sp[1676],r8
80008b0a:	58 78       	cp.w	r8,7
80008b0c:	e0 89 00 04 	brgt	80008b14 <_vfprintf_r+0x1d74>
80008b10:	2f 83       	sub	r3,-8
80008b12:	c0 b8       	rjmp	80008b28 <_vfprintf_r+0x1d88>
80008b14:	fa ca f9 78 	sub	r10,sp,-1672
80008b18:	02 9b       	mov	r11,r1
80008b1a:	08 9c       	mov	r12,r4
80008b1c:	fe b0 f1 34 	rcall	80006d84 <__sprint_r>
80008b20:	e0 81 00 bf 	brne	80008c9e <_vfprintf_r+0x1efe>
80008b24:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b28:	21 06       	sub	r6,16
80008b2a:	c0 48       	rjmp	80008b32 <_vfprintf_r+0x1d92>
80008b2c:	fe c2 c1 5c 	sub	r2,pc,-16036
80008b30:	31 00       	mov	r0,16
80008b32:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b3a:	fe ca c1 6a 	sub	r10,pc,-16022
80008b3e:	59 06       	cp.w	r6,16
80008b40:	fe 99 ff dd 	brgt	80008afa <_vfprintf_r+0x1d5a>
80008b44:	0c 09       	add	r9,r6
80008b46:	87 0a       	st.w	r3[0x0],r10
80008b48:	fb 49 06 90 	st.w	sp[1680],r9
80008b4c:	2f f8       	sub	r8,-1
80008b4e:	87 16       	st.w	r3[0x4],r6
80008b50:	fb 48 06 8c 	st.w	sp[1676],r8
80008b54:	c0 e8       	rjmp	80008b70 <_vfprintf_r+0x1dd0>
80008b56:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b5a:	2f f8       	sub	r8,-1
80008b5c:	30 19       	mov	r9,1
80008b5e:	fb 48 06 90 	st.w	sp[1680],r8
80008b62:	87 06       	st.w	r3[0x0],r6
80008b64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b68:	87 19       	st.w	r3[0x4],r9
80008b6a:	2f f8       	sub	r8,-1
80008b6c:	fb 48 06 8c 	st.w	sp[1676],r8
80008b70:	58 78       	cp.w	r8,7
80008b72:	e0 89 00 04 	brgt	80008b7a <_vfprintf_r+0x1dda>
80008b76:	2f 83       	sub	r3,-8
80008b78:	c0 b8       	rjmp	80008b8e <_vfprintf_r+0x1dee>
80008b7a:	fa ca f9 78 	sub	r10,sp,-1672
80008b7e:	02 9b       	mov	r11,r1
80008b80:	08 9c       	mov	r12,r4
80008b82:	fe b0 f1 01 	rcall	80006d84 <__sprint_r>
80008b86:	e0 81 00 8c 	brne	80008c9e <_vfprintf_r+0x1efe>
80008b8a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b8e:	40 ea       	lddsp	r10,sp[0x38]
80008b90:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b94:	14 08       	add	r8,r10
80008b96:	fa c9 f9 64 	sub	r9,sp,-1692
80008b9a:	fb 48 06 90 	st.w	sp[1680],r8
80008b9e:	87 1a       	st.w	r3[0x4],r10
80008ba0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ba4:	87 09       	st.w	r3[0x0],r9
80008ba6:	2f f8       	sub	r8,-1
80008ba8:	fb 48 06 8c 	st.w	sp[1676],r8
80008bac:	58 78       	cp.w	r8,7
80008bae:	e0 89 00 04 	brgt	80008bb6 <_vfprintf_r+0x1e16>
80008bb2:	2f 83       	sub	r3,-8
80008bb4:	c0 a8       	rjmp	80008bc8 <_vfprintf_r+0x1e28>
80008bb6:	fa ca f9 78 	sub	r10,sp,-1672
80008bba:	02 9b       	mov	r11,r1
80008bbc:	08 9c       	mov	r12,r4
80008bbe:	fe b0 f0 e3 	rcall	80006d84 <__sprint_r>
80008bc2:	c6 e1       	brne	80008c9e <_vfprintf_r+0x1efe>
80008bc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bc8:	e2 15 00 04 	andl	r5,0x4,COH
80008bcc:	c3 f0       	breq	80008c4a <_vfprintf_r+0x1eaa>
80008bce:	40 86       	lddsp	r6,sp[0x20]
80008bd0:	40 39       	lddsp	r9,sp[0xc]
80008bd2:	12 16       	sub	r6,r9
80008bd4:	58 06       	cp.w	r6,0
80008bd6:	e0 89 00 1a 	brgt	80008c0a <_vfprintf_r+0x1e6a>
80008bda:	c3 88       	rjmp	80008c4a <_vfprintf_r+0x1eaa>
80008bdc:	2f 09       	sub	r9,-16
80008bde:	2f f8       	sub	r8,-1
80008be0:	fb 49 06 90 	st.w	sp[1680],r9
80008be4:	87 05       	st.w	r3[0x0],r5
80008be6:	87 12       	st.w	r3[0x4],r2
80008be8:	fb 48 06 8c 	st.w	sp[1676],r8
80008bec:	58 78       	cp.w	r8,7
80008bee:	e0 89 00 04 	brgt	80008bf6 <_vfprintf_r+0x1e56>
80008bf2:	2f 83       	sub	r3,-8
80008bf4:	c0 98       	rjmp	80008c06 <_vfprintf_r+0x1e66>
80008bf6:	00 9a       	mov	r10,r0
80008bf8:	02 9b       	mov	r11,r1
80008bfa:	08 9c       	mov	r12,r4
80008bfc:	fe b0 f0 c4 	rcall	80006d84 <__sprint_r>
80008c00:	c4 f1       	brne	80008c9e <_vfprintf_r+0x1efe>
80008c02:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c06:	21 06       	sub	r6,16
80008c08:	c0 68       	rjmp	80008c14 <_vfprintf_r+0x1e74>
80008c0a:	fe c5 c2 4a 	sub	r5,pc,-15798
80008c0e:	31 02       	mov	r2,16
80008c10:	fa c0 f9 78 	sub	r0,sp,-1672
80008c14:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c1c:	fe ca c2 5c 	sub	r10,pc,-15780
80008c20:	59 06       	cp.w	r6,16
80008c22:	fe 99 ff dd 	brgt	80008bdc <_vfprintf_r+0x1e3c>
80008c26:	0c 09       	add	r9,r6
80008c28:	2f f8       	sub	r8,-1
80008c2a:	87 0a       	st.w	r3[0x0],r10
80008c2c:	87 16       	st.w	r3[0x4],r6
80008c2e:	fb 49 06 90 	st.w	sp[1680],r9
80008c32:	fb 48 06 8c 	st.w	sp[1676],r8
80008c36:	58 78       	cp.w	r8,7
80008c38:	e0 8a 00 09 	brle	80008c4a <_vfprintf_r+0x1eaa>
80008c3c:	fa ca f9 78 	sub	r10,sp,-1672
80008c40:	02 9b       	mov	r11,r1
80008c42:	08 9c       	mov	r12,r4
80008c44:	fe b0 f0 a0 	rcall	80006d84 <__sprint_r>
80008c48:	c2 b1       	brne	80008c9e <_vfprintf_r+0x1efe>
80008c4a:	40 bc       	lddsp	r12,sp[0x2c]
80008c4c:	40 36       	lddsp	r6,sp[0xc]
80008c4e:	40 8e       	lddsp	lr,sp[0x20]
80008c50:	ec 0e 0c 48 	max	r8,r6,lr
80008c54:	10 0c       	add	r12,r8
80008c56:	50 bc       	stdsp	sp[0x2c],r12
80008c58:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c5c:	58 08       	cp.w	r8,0
80008c5e:	c0 80       	breq	80008c6e <_vfprintf_r+0x1ece>
80008c60:	fa ca f9 78 	sub	r10,sp,-1672
80008c64:	02 9b       	mov	r11,r1
80008c66:	08 9c       	mov	r12,r4
80008c68:	fe b0 f0 8e 	rcall	80006d84 <__sprint_r>
80008c6c:	c1 91       	brne	80008c9e <_vfprintf_r+0x1efe>
80008c6e:	30 0b       	mov	r11,0
80008c70:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c74:	fb 4b 06 8c 	st.w	sp[1676],r11
80008c78:	fe 9f f1 22 	bral	80006ebc <_vfprintf_r+0x11c>
80008c7c:	08 95       	mov	r5,r4
80008c7e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c82:	58 08       	cp.w	r8,0
80008c84:	c0 80       	breq	80008c94 <_vfprintf_r+0x1ef4>
80008c86:	08 9c       	mov	r12,r4
80008c88:	fa ca f9 78 	sub	r10,sp,-1672
80008c8c:	02 9b       	mov	r11,r1
80008c8e:	fe b0 f0 7b 	rcall	80006d84 <__sprint_r>
80008c92:	c0 61       	brne	80008c9e <_vfprintf_r+0x1efe>
80008c94:	30 08       	mov	r8,0
80008c96:	fb 48 06 8c 	st.w	sp[1676],r8
80008c9a:	c0 28       	rjmp	80008c9e <_vfprintf_r+0x1efe>
80008c9c:	40 41       	lddsp	r1,sp[0x10]
80008c9e:	82 68       	ld.sh	r8,r1[0xc]
80008ca0:	ed b8 00 06 	bld	r8,0x6
80008ca4:	c0 31       	brne	80008caa <_vfprintf_r+0x1f0a>
80008ca6:	3f fa       	mov	r10,-1
80008ca8:	50 ba       	stdsp	sp[0x2c],r10
80008caa:	40 bc       	lddsp	r12,sp[0x2c]
80008cac:	fe 3d f9 44 	sub	sp,-1724
80008cb0:	d8 32       	popm	r0-r7,pc
80008cb2:	d7 03       	nop

80008cb4 <__swsetup_r>:
80008cb4:	d4 21       	pushm	r4-r7,lr
80008cb6:	e0 68 0a 2c 	mov	r8,2604
80008cba:	18 96       	mov	r6,r12
80008cbc:	16 97       	mov	r7,r11
80008cbe:	70 0c       	ld.w	r12,r8[0x0]
80008cc0:	58 0c       	cp.w	r12,0
80008cc2:	c0 60       	breq	80008cce <__swsetup_r+0x1a>
80008cc4:	78 68       	ld.w	r8,r12[0x18]
80008cc6:	58 08       	cp.w	r8,0
80008cc8:	c0 31       	brne	80008cce <__swsetup_r+0x1a>
80008cca:	e0 a0 07 bf 	rcall	80009c48 <__sinit>
80008cce:	fe c8 c1 de 	sub	r8,pc,-15906
80008cd2:	10 37       	cp.w	r7,r8
80008cd4:	c0 61       	brne	80008ce0 <__swsetup_r+0x2c>
80008cd6:	e0 68 0a 2c 	mov	r8,2604
80008cda:	70 08       	ld.w	r8,r8[0x0]
80008cdc:	70 07       	ld.w	r7,r8[0x0]
80008cde:	c1 28       	rjmp	80008d02 <__swsetup_r+0x4e>
80008ce0:	fe c8 c1 d0 	sub	r8,pc,-15920
80008ce4:	10 37       	cp.w	r7,r8
80008ce6:	c0 61       	brne	80008cf2 <__swsetup_r+0x3e>
80008ce8:	e0 68 0a 2c 	mov	r8,2604
80008cec:	70 08       	ld.w	r8,r8[0x0]
80008cee:	70 17       	ld.w	r7,r8[0x4]
80008cf0:	c0 98       	rjmp	80008d02 <__swsetup_r+0x4e>
80008cf2:	fe c8 c1 c2 	sub	r8,pc,-15934
80008cf6:	10 37       	cp.w	r7,r8
80008cf8:	c0 51       	brne	80008d02 <__swsetup_r+0x4e>
80008cfa:	e0 68 0a 2c 	mov	r8,2604
80008cfe:	70 08       	ld.w	r8,r8[0x0]
80008d00:	70 27       	ld.w	r7,r8[0x8]
80008d02:	8e 68       	ld.sh	r8,r7[0xc]
80008d04:	ed b8 00 03 	bld	r8,0x3
80008d08:	c1 e0       	breq	80008d44 <__swsetup_r+0x90>
80008d0a:	ed b8 00 04 	bld	r8,0x4
80008d0e:	c3 e1       	brne	80008d8a <__swsetup_r+0xd6>
80008d10:	ed b8 00 02 	bld	r8,0x2
80008d14:	c1 51       	brne	80008d3e <__swsetup_r+0x8a>
80008d16:	6e db       	ld.w	r11,r7[0x34]
80008d18:	58 0b       	cp.w	r11,0
80008d1a:	c0 a0       	breq	80008d2e <__swsetup_r+0x7a>
80008d1c:	ee c8 ff bc 	sub	r8,r7,-68
80008d20:	10 3b       	cp.w	r11,r8
80008d22:	c0 40       	breq	80008d2a <__swsetup_r+0x76>
80008d24:	0c 9c       	mov	r12,r6
80008d26:	e0 a0 08 2b 	rcall	80009d7c <_free_r>
80008d2a:	30 08       	mov	r8,0
80008d2c:	8f d8       	st.w	r7[0x34],r8
80008d2e:	8e 68       	ld.sh	r8,r7[0xc]
80008d30:	e0 18 ff db 	andl	r8,0xffdb
80008d34:	ae 68       	st.h	r7[0xc],r8
80008d36:	30 08       	mov	r8,0
80008d38:	8f 18       	st.w	r7[0x4],r8
80008d3a:	6e 48       	ld.w	r8,r7[0x10]
80008d3c:	8f 08       	st.w	r7[0x0],r8
80008d3e:	8e 68       	ld.sh	r8,r7[0xc]
80008d40:	a3 b8       	sbr	r8,0x3
80008d42:	ae 68       	st.h	r7[0xc],r8
80008d44:	6e 48       	ld.w	r8,r7[0x10]
80008d46:	58 08       	cp.w	r8,0
80008d48:	c0 b1       	brne	80008d5e <__swsetup_r+0xaa>
80008d4a:	8e 68       	ld.sh	r8,r7[0xc]
80008d4c:	e2 18 02 80 	andl	r8,0x280,COH
80008d50:	e0 48 02 00 	cp.w	r8,512
80008d54:	c0 50       	breq	80008d5e <__swsetup_r+0xaa>
80008d56:	0c 9c       	mov	r12,r6
80008d58:	0e 9b       	mov	r11,r7
80008d5a:	e0 a0 0a 4b 	rcall	8000a1f0 <__smakebuf_r>
80008d5e:	8e 69       	ld.sh	r9,r7[0xc]
80008d60:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008d64:	c0 70       	breq	80008d72 <__swsetup_r+0xbe>
80008d66:	30 08       	mov	r8,0
80008d68:	8f 28       	st.w	r7[0x8],r8
80008d6a:	6e 58       	ld.w	r8,r7[0x14]
80008d6c:	5c 38       	neg	r8
80008d6e:	8f 68       	st.w	r7[0x18],r8
80008d70:	c0 68       	rjmp	80008d7c <__swsetup_r+0xc8>
80008d72:	ed b9 00 01 	bld	r9,0x1
80008d76:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008d7a:	8f 28       	st.w	r7[0x8],r8
80008d7c:	6e 48       	ld.w	r8,r7[0x10]
80008d7e:	58 08       	cp.w	r8,0
80008d80:	c0 61       	brne	80008d8c <__swsetup_r+0xd8>
80008d82:	8e 68       	ld.sh	r8,r7[0xc]
80008d84:	ed b8 00 07 	bld	r8,0x7
80008d88:	c0 21       	brne	80008d8c <__swsetup_r+0xd8>
80008d8a:	dc 2a       	popm	r4-r7,pc,r12=-1
80008d8c:	d8 2a       	popm	r4-r7,pc,r12=0
80008d8e:	d7 03       	nop

80008d90 <quorem>:
80008d90:	d4 31       	pushm	r0-r7,lr
80008d92:	20 2d       	sub	sp,8
80008d94:	18 97       	mov	r7,r12
80008d96:	78 48       	ld.w	r8,r12[0x10]
80008d98:	76 46       	ld.w	r6,r11[0x10]
80008d9a:	0c 38       	cp.w	r8,r6
80008d9c:	c0 34       	brge	80008da2 <quorem+0x12>
80008d9e:	30 0c       	mov	r12,0
80008da0:	c8 58       	rjmp	80008eaa <quorem+0x11a>
80008da2:	ec c2 ff fc 	sub	r2,r6,-4
80008da6:	f6 c3 ff ec 	sub	r3,r11,-20
80008daa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008dae:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008db2:	2f f9       	sub	r9,-1
80008db4:	20 16       	sub	r6,1
80008db6:	f8 09 0d 08 	divu	r8,r12,r9
80008dba:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008dbe:	ee c4 ff ec 	sub	r4,r7,-20
80008dc2:	10 95       	mov	r5,r8
80008dc4:	58 08       	cp.w	r8,0
80008dc6:	c4 10       	breq	80008e48 <quorem+0xb8>
80008dc8:	30 09       	mov	r9,0
80008dca:	06 9a       	mov	r10,r3
80008dcc:	08 98       	mov	r8,r4
80008dce:	12 91       	mov	r1,r9
80008dd0:	50 0b       	stdsp	sp[0x0],r11
80008dd2:	70 0e       	ld.w	lr,r8[0x0]
80008dd4:	b1 8e       	lsr	lr,0x10
80008dd6:	50 1e       	stdsp	sp[0x4],lr
80008dd8:	15 0e       	ld.w	lr,r10++
80008dda:	fc 00 16 10 	lsr	r0,lr,0x10
80008dde:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008de2:	ea 0e 03 41 	mac	r1,r5,lr
80008de6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008dea:	b1 81       	lsr	r1,0x10
80008dec:	40 1b       	lddsp	r11,sp[0x4]
80008dee:	ea 00 02 40 	mul	r0,r5,r0
80008df2:	e2 00 00 00 	add	r0,r1,r0
80008df6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008dfa:	02 1b       	sub	r11,r1
80008dfc:	50 1b       	stdsp	sp[0x4],r11
80008dfe:	70 0b       	ld.w	r11,r8[0x0]
80008e00:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008e04:	02 09       	add	r9,r1
80008e06:	f2 0e 01 0e 	sub	lr,r9,lr
80008e0a:	b0 1e       	st.h	r8[0x2],lr
80008e0c:	fc 09 14 10 	asr	r9,lr,0x10
80008e10:	40 1e       	lddsp	lr,sp[0x4]
80008e12:	fc 09 00 09 	add	r9,lr,r9
80008e16:	b0 09       	st.h	r8[0x0],r9
80008e18:	e0 01 16 10 	lsr	r1,r0,0x10
80008e1c:	2f c8       	sub	r8,-4
80008e1e:	b1 49       	asr	r9,0x10
80008e20:	04 3a       	cp.w	r10,r2
80008e22:	fe 98 ff d8 	brls	80008dd2 <quorem+0x42>
80008e26:	40 0b       	lddsp	r11,sp[0x0]
80008e28:	58 0c       	cp.w	r12,0
80008e2a:	c0 f1       	brne	80008e48 <quorem+0xb8>
80008e2c:	ec c8 ff fb 	sub	r8,r6,-5
80008e30:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008e34:	c0 28       	rjmp	80008e38 <quorem+0xa8>
80008e36:	20 16       	sub	r6,1
80008e38:	20 48       	sub	r8,4
80008e3a:	08 38       	cp.w	r8,r4
80008e3c:	e0 88 00 05 	brls	80008e46 <quorem+0xb6>
80008e40:	70 09       	ld.w	r9,r8[0x0]
80008e42:	58 09       	cp.w	r9,0
80008e44:	cf 90       	breq	80008e36 <quorem+0xa6>
80008e46:	8f 46       	st.w	r7[0x10],r6
80008e48:	0e 9c       	mov	r12,r7
80008e4a:	e0 a0 0a d2 	rcall	8000a3ee <__mcmp>
80008e4e:	c2 d5       	brlt	80008ea8 <quorem+0x118>
80008e50:	2f f5       	sub	r5,-1
80008e52:	08 98       	mov	r8,r4
80008e54:	30 09       	mov	r9,0
80008e56:	07 0b       	ld.w	r11,r3++
80008e58:	f6 0a 16 10 	lsr	r10,r11,0x10
80008e5c:	70 0c       	ld.w	r12,r8[0x0]
80008e5e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008e62:	f8 0e 16 10 	lsr	lr,r12,0x10
80008e66:	14 1e       	sub	lr,r10
80008e68:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008e6c:	16 1a       	sub	r10,r11
80008e6e:	12 0a       	add	r10,r9
80008e70:	b0 1a       	st.h	r8[0x2],r10
80008e72:	b1 4a       	asr	r10,0x10
80008e74:	fc 0a 00 09 	add	r9,lr,r10
80008e78:	b0 09       	st.h	r8[0x0],r9
80008e7a:	2f c8       	sub	r8,-4
80008e7c:	b1 49       	asr	r9,0x10
80008e7e:	04 33       	cp.w	r3,r2
80008e80:	fe 98 ff eb 	brls	80008e56 <quorem+0xc6>
80008e84:	ec c8 ff fb 	sub	r8,r6,-5
80008e88:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008e8c:	58 09       	cp.w	r9,0
80008e8e:	c0 d1       	brne	80008ea8 <quorem+0x118>
80008e90:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008e94:	c0 28       	rjmp	80008e98 <quorem+0x108>
80008e96:	20 16       	sub	r6,1
80008e98:	20 48       	sub	r8,4
80008e9a:	08 38       	cp.w	r8,r4
80008e9c:	e0 88 00 05 	brls	80008ea6 <quorem+0x116>
80008ea0:	70 09       	ld.w	r9,r8[0x0]
80008ea2:	58 09       	cp.w	r9,0
80008ea4:	cf 90       	breq	80008e96 <quorem+0x106>
80008ea6:	8f 46       	st.w	r7[0x10],r6
80008ea8:	0a 9c       	mov	r12,r5
80008eaa:	2f ed       	sub	sp,-8
80008eac:	d8 32       	popm	r0-r7,pc
80008eae:	d7 03       	nop

80008eb0 <_dtoa_r>:
80008eb0:	d4 31       	pushm	r0-r7,lr
80008eb2:	21 ad       	sub	sp,104
80008eb4:	fa c4 ff 74 	sub	r4,sp,-140
80008eb8:	18 97       	mov	r7,r12
80008eba:	16 95       	mov	r5,r11
80008ebc:	68 2c       	ld.w	r12,r4[0x8]
80008ebe:	50 c9       	stdsp	sp[0x30],r9
80008ec0:	68 16       	ld.w	r6,r4[0x4]
80008ec2:	68 09       	ld.w	r9,r4[0x0]
80008ec4:	50 e8       	stdsp	sp[0x38],r8
80008ec6:	14 94       	mov	r4,r10
80008ec8:	51 2c       	stdsp	sp[0x48],r12
80008eca:	fa e5 00 08 	st.d	sp[8],r4
80008ece:	51 59       	stdsp	sp[0x54],r9
80008ed0:	6e 95       	ld.w	r5,r7[0x24]
80008ed2:	58 05       	cp.w	r5,0
80008ed4:	c0 91       	brne	80008ee6 <_dtoa_r+0x36>
80008ed6:	31 0c       	mov	r12,16
80008ed8:	fe b0 e8 f4 	rcall	800060c0 <malloc>
80008edc:	99 35       	st.w	r12[0xc],r5
80008ede:	8f 9c       	st.w	r7[0x24],r12
80008ee0:	99 15       	st.w	r12[0x4],r5
80008ee2:	99 25       	st.w	r12[0x8],r5
80008ee4:	99 05       	st.w	r12[0x0],r5
80008ee6:	6e 99       	ld.w	r9,r7[0x24]
80008ee8:	72 08       	ld.w	r8,r9[0x0]
80008eea:	58 08       	cp.w	r8,0
80008eec:	c0 f0       	breq	80008f0a <_dtoa_r+0x5a>
80008eee:	72 1a       	ld.w	r10,r9[0x4]
80008ef0:	91 1a       	st.w	r8[0x4],r10
80008ef2:	30 1a       	mov	r10,1
80008ef4:	72 19       	ld.w	r9,r9[0x4]
80008ef6:	f4 09 09 49 	lsl	r9,r10,r9
80008efa:	10 9b       	mov	r11,r8
80008efc:	91 29       	st.w	r8[0x8],r9
80008efe:	0e 9c       	mov	r12,r7
80008f00:	e0 a0 0a 90 	rcall	8000a420 <_Bfree>
80008f04:	6e 98       	ld.w	r8,r7[0x24]
80008f06:	30 09       	mov	r9,0
80008f08:	91 09       	st.w	r8[0x0],r9
80008f0a:	40 28       	lddsp	r8,sp[0x8]
80008f0c:	10 94       	mov	r4,r8
80008f0e:	58 08       	cp.w	r8,0
80008f10:	c0 64       	brge	80008f1c <_dtoa_r+0x6c>
80008f12:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80008f16:	50 28       	stdsp	sp[0x8],r8
80008f18:	30 18       	mov	r8,1
80008f1a:	c0 28       	rjmp	80008f1e <_dtoa_r+0x6e>
80008f1c:	30 08       	mov	r8,0
80008f1e:	8d 08       	st.w	r6[0x0],r8
80008f20:	fc 1c 7f f0 	movh	r12,0x7ff0
80008f24:	40 26       	lddsp	r6,sp[0x8]
80008f26:	0c 98       	mov	r8,r6
80008f28:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008f2c:	18 38       	cp.w	r8,r12
80008f2e:	c2 01       	brne	80008f6e <_dtoa_r+0xbe>
80008f30:	e0 68 27 0f 	mov	r8,9999
80008f34:	41 5b       	lddsp	r11,sp[0x54]
80008f36:	97 08       	st.w	r11[0x0],r8
80008f38:	40 3a       	lddsp	r10,sp[0xc]
80008f3a:	58 0a       	cp.w	r10,0
80008f3c:	c0 71       	brne	80008f4a <_dtoa_r+0x9a>
80008f3e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80008f42:	c0 41       	brne	80008f4a <_dtoa_r+0x9a>
80008f44:	fe cc c4 64 	sub	r12,pc,-15260
80008f48:	c0 38       	rjmp	80008f4e <_dtoa_r+0x9e>
80008f4a:	fe cc c4 5e 	sub	r12,pc,-15266
80008f4e:	41 29       	lddsp	r9,sp[0x48]
80008f50:	58 09       	cp.w	r9,0
80008f52:	e0 80 05 9a 	breq	80009a86 <_dtoa_r+0xbd6>
80008f56:	f8 c8 ff fd 	sub	r8,r12,-3
80008f5a:	f8 c9 ff f8 	sub	r9,r12,-8
80008f5e:	11 8b       	ld.ub	r11,r8[0x0]
80008f60:	30 0a       	mov	r10,0
80008f62:	41 25       	lddsp	r5,sp[0x48]
80008f64:	f4 0b 18 00 	cp.b	r11,r10
80008f68:	f2 08 17 10 	movne	r8,r9
80008f6c:	c1 68       	rjmp	80008f98 <_dtoa_r+0xe8>
80008f6e:	fa ea 00 08 	ld.d	r10,sp[8]
80008f72:	30 08       	mov	r8,0
80008f74:	fa eb 00 3c 	st.d	sp[60],r10
80008f78:	30 09       	mov	r9,0
80008f7a:	e0 a0 10 ce 	rcall	8000b116 <__avr32_f64_cmp_eq>
80008f7e:	c1 00       	breq	80008f9e <_dtoa_r+0xee>
80008f80:	30 18       	mov	r8,1
80008f82:	41 5a       	lddsp	r10,sp[0x54]
80008f84:	95 08       	st.w	r10[0x0],r8
80008f86:	fe cc c5 ca 	sub	r12,pc,-14902
80008f8a:	41 29       	lddsp	r9,sp[0x48]
80008f8c:	f8 08 00 08 	add	r8,r12,r8
80008f90:	58 09       	cp.w	r9,0
80008f92:	e0 80 05 7a 	breq	80009a86 <_dtoa_r+0xbd6>
80008f96:	12 95       	mov	r5,r9
80008f98:	8b 08       	st.w	r5[0x0],r8
80008f9a:	e0 8f 05 76 	bral	80009a86 <_dtoa_r+0xbd6>
80008f9e:	fa c8 ff 9c 	sub	r8,sp,-100
80008fa2:	fa c9 ff a0 	sub	r9,sp,-96
80008fa6:	fa ea 00 3c 	ld.d	r10,sp[60]
80008faa:	0e 9c       	mov	r12,r7
80008fac:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008fb0:	e0 a0 0a 8a 	rcall	8000a4c4 <__d2b>
80008fb4:	18 93       	mov	r3,r12
80008fb6:	58 05       	cp.w	r5,0
80008fb8:	c0 d0       	breq	80008fd2 <_dtoa_r+0x122>
80008fba:	fa ea 00 3c 	ld.d	r10,sp[60]
80008fbe:	30 04       	mov	r4,0
80008fc0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80008fc4:	ea c5 03 ff 	sub	r5,r5,1023
80008fc8:	10 9b       	mov	r11,r8
80008fca:	51 74       	stdsp	sp[0x5c],r4
80008fcc:	ea 1b 3f f0 	orh	r11,0x3ff0
80008fd0:	c2 58       	rjmp	8000901a <_dtoa_r+0x16a>
80008fd2:	41 88       	lddsp	r8,sp[0x60]
80008fd4:	41 9c       	lddsp	r12,sp[0x64]
80008fd6:	10 0c       	add	r12,r8
80008fd8:	f8 c5 fb ce 	sub	r5,r12,-1074
80008fdc:	e0 45 00 20 	cp.w	r5,32
80008fe0:	e0 8a 00 0e 	brle	80008ffc <_dtoa_r+0x14c>
80008fe4:	f8 cc fb ee 	sub	r12,r12,-1042
80008fe8:	40 3b       	lddsp	r11,sp[0xc]
80008fea:	ea 08 11 40 	rsub	r8,r5,64
80008fee:	f6 0c 0a 4c 	lsr	r12,r11,r12
80008ff2:	ec 08 09 46 	lsl	r6,r6,r8
80008ff6:	0c 4c       	or	r12,r6
80008ff8:	c0 78       	rjmp	80009006 <_dtoa_r+0x156>
80008ffa:	d7 03       	nop
80008ffc:	ea 0c 11 20 	rsub	r12,r5,32
80009000:	40 3a       	lddsp	r10,sp[0xc]
80009002:	f4 0c 09 4c 	lsl	r12,r10,r12
80009006:	e0 a0 10 14 	rcall	8000b02e <__avr32_u32_to_f64>
8000900a:	fc 18 fe 10 	movh	r8,0xfe10
8000900e:	30 19       	mov	r9,1
80009010:	ea c5 04 33 	sub	r5,r5,1075
80009014:	f0 0b 00 0b 	add	r11,r8,r11
80009018:	51 79       	stdsp	sp[0x5c],r9
8000901a:	30 08       	mov	r8,0
8000901c:	fc 19 3f f8 	movh	r9,0x3ff8
80009020:	e0 a0 0e 9c 	rcall	8000ad58 <__avr32_f64_sub>
80009024:	e0 68 43 61 	mov	r8,17249
80009028:	ea 18 63 6f 	orh	r8,0x636f
8000902c:	e0 69 87 a7 	mov	r9,34727
80009030:	ea 19 3f d2 	orh	r9,0x3fd2
80009034:	e0 a0 0d a6 	rcall	8000ab80 <__avr32_f64_mul>
80009038:	e0 68 c8 b3 	mov	r8,51379
8000903c:	ea 18 8b 60 	orh	r8,0x8b60
80009040:	e0 69 8a 28 	mov	r9,35368
80009044:	ea 19 3f c6 	orh	r9,0x3fc6
80009048:	e0 a0 0f 56 	rcall	8000aef4 <__avr32_f64_add>
8000904c:	0a 9c       	mov	r12,r5
8000904e:	14 90       	mov	r0,r10
80009050:	16 91       	mov	r1,r11
80009052:	e0 a0 0f f2 	rcall	8000b036 <__avr32_s32_to_f64>
80009056:	e0 68 79 fb 	mov	r8,31227
8000905a:	ea 18 50 9f 	orh	r8,0x509f
8000905e:	e0 69 44 13 	mov	r9,17427
80009062:	ea 19 3f d3 	orh	r9,0x3fd3
80009066:	e0 a0 0d 8d 	rcall	8000ab80 <__avr32_f64_mul>
8000906a:	14 98       	mov	r8,r10
8000906c:	16 99       	mov	r9,r11
8000906e:	00 9a       	mov	r10,r0
80009070:	02 9b       	mov	r11,r1
80009072:	e0 a0 0f 41 	rcall	8000aef4 <__avr32_f64_add>
80009076:	14 90       	mov	r0,r10
80009078:	16 91       	mov	r1,r11
8000907a:	e0 a0 0f c7 	rcall	8000b008 <__avr32_f64_to_s32>
8000907e:	30 08       	mov	r8,0
80009080:	18 96       	mov	r6,r12
80009082:	30 09       	mov	r9,0
80009084:	00 9a       	mov	r10,r0
80009086:	02 9b       	mov	r11,r1
80009088:	e0 a0 10 8e 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
8000908c:	c0 c0       	breq	800090a4 <_dtoa_r+0x1f4>
8000908e:	0c 9c       	mov	r12,r6
80009090:	e0 a0 0f d3 	rcall	8000b036 <__avr32_s32_to_f64>
80009094:	14 98       	mov	r8,r10
80009096:	16 99       	mov	r9,r11
80009098:	00 9a       	mov	r10,r0
8000909a:	02 9b       	mov	r11,r1
8000909c:	e0 a0 10 3d 	rcall	8000b116 <__avr32_f64_cmp_eq>
800090a0:	f7 b6 00 01 	subeq	r6,1
800090a4:	59 66       	cp.w	r6,22
800090a6:	e0 88 00 05 	brls	800090b0 <_dtoa_r+0x200>
800090aa:	30 18       	mov	r8,1
800090ac:	51 48       	stdsp	sp[0x50],r8
800090ae:	c1 38       	rjmp	800090d4 <_dtoa_r+0x224>
800090b0:	fe c8 c5 10 	sub	r8,pc,-15088
800090b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800090b8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800090bc:	e0 a0 10 74 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
800090c0:	f9 b4 00 00 	moveq	r4,0
800090c4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800090c8:	f7 b6 01 01 	subne	r6,1
800090cc:	f9 bc 01 00 	movne	r12,0
800090d0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800090d4:	41 90       	lddsp	r0,sp[0x64]
800090d6:	20 10       	sub	r0,1
800090d8:	0a 10       	sub	r0,r5
800090da:	c0 46       	brmi	800090e2 <_dtoa_r+0x232>
800090dc:	50 40       	stdsp	sp[0x10],r0
800090de:	30 00       	mov	r0,0
800090e0:	c0 48       	rjmp	800090e8 <_dtoa_r+0x238>
800090e2:	30 0b       	mov	r11,0
800090e4:	5c 30       	neg	r0
800090e6:	50 4b       	stdsp	sp[0x10],r11
800090e8:	ec 02 11 00 	rsub	r2,r6,0
800090ec:	58 06       	cp.w	r6,0
800090ee:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800090f2:	f5 d6 e4 0a 	addge	r10,r10,r6
800090f6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800090fa:	fb f6 4a 11 	st.wge	sp[0x44],r6
800090fe:	f9 b2 04 00 	movge	r2,0
80009102:	e1 d6 e5 10 	sublt	r0,r0,r6
80009106:	f9 b9 05 00 	movlt	r9,0
8000910a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000910e:	40 c8       	lddsp	r8,sp[0x30]
80009110:	58 98       	cp.w	r8,9
80009112:	e0 8b 00 20 	brhi	80009152 <_dtoa_r+0x2a2>
80009116:	58 58       	cp.w	r8,5
80009118:	f9 b4 0a 01 	movle	r4,1
8000911c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009120:	f7 b5 09 04 	subgt	r5,4
80009124:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009128:	f9 b4 09 00 	movgt	r4,0
8000912c:	40 cc       	lddsp	r12,sp[0x30]
8000912e:	58 3c       	cp.w	r12,3
80009130:	c2 d0       	breq	8000918a <_dtoa_r+0x2da>
80009132:	e0 89 00 05 	brgt	8000913c <_dtoa_r+0x28c>
80009136:	58 2c       	cp.w	r12,2
80009138:	c1 01       	brne	80009158 <_dtoa_r+0x2a8>
8000913a:	c1 88       	rjmp	8000916a <_dtoa_r+0x2ba>
8000913c:	40 cb       	lddsp	r11,sp[0x30]
8000913e:	58 4b       	cp.w	r11,4
80009140:	c0 60       	breq	8000914c <_dtoa_r+0x29c>
80009142:	58 5b       	cp.w	r11,5
80009144:	c0 a1       	brne	80009158 <_dtoa_r+0x2a8>
80009146:	30 1a       	mov	r10,1
80009148:	50 da       	stdsp	sp[0x34],r10
8000914a:	c2 28       	rjmp	8000918e <_dtoa_r+0x2de>
8000914c:	30 19       	mov	r9,1
8000914e:	50 d9       	stdsp	sp[0x34],r9
80009150:	c0 f8       	rjmp	8000916e <_dtoa_r+0x2be>
80009152:	30 08       	mov	r8,0
80009154:	30 14       	mov	r4,1
80009156:	50 c8       	stdsp	sp[0x30],r8
80009158:	3f f5       	mov	r5,-1
8000915a:	30 1c       	mov	r12,1
8000915c:	30 0b       	mov	r11,0
8000915e:	50 95       	stdsp	sp[0x24],r5
80009160:	50 dc       	stdsp	sp[0x34],r12
80009162:	0a 91       	mov	r1,r5
80009164:	31 28       	mov	r8,18
80009166:	50 eb       	stdsp	sp[0x38],r11
80009168:	c2 08       	rjmp	800091a8 <_dtoa_r+0x2f8>
8000916a:	30 0a       	mov	r10,0
8000916c:	50 da       	stdsp	sp[0x34],r10
8000916e:	40 e9       	lddsp	r9,sp[0x38]
80009170:	58 09       	cp.w	r9,0
80009172:	e0 89 00 07 	brgt	80009180 <_dtoa_r+0x2d0>
80009176:	30 18       	mov	r8,1
80009178:	50 98       	stdsp	sp[0x24],r8
8000917a:	10 91       	mov	r1,r8
8000917c:	50 e8       	stdsp	sp[0x38],r8
8000917e:	c1 58       	rjmp	800091a8 <_dtoa_r+0x2f8>
80009180:	40 e5       	lddsp	r5,sp[0x38]
80009182:	50 95       	stdsp	sp[0x24],r5
80009184:	0a 91       	mov	r1,r5
80009186:	0a 98       	mov	r8,r5
80009188:	c1 08       	rjmp	800091a8 <_dtoa_r+0x2f8>
8000918a:	30 0c       	mov	r12,0
8000918c:	50 dc       	stdsp	sp[0x34],r12
8000918e:	40 eb       	lddsp	r11,sp[0x38]
80009190:	ec 0b 00 0b 	add	r11,r6,r11
80009194:	50 9b       	stdsp	sp[0x24],r11
80009196:	16 98       	mov	r8,r11
80009198:	2f f8       	sub	r8,-1
8000919a:	58 08       	cp.w	r8,0
8000919c:	e0 89 00 05 	brgt	800091a6 <_dtoa_r+0x2f6>
800091a0:	10 91       	mov	r1,r8
800091a2:	30 18       	mov	r8,1
800091a4:	c0 28       	rjmp	800091a8 <_dtoa_r+0x2f8>
800091a6:	10 91       	mov	r1,r8
800091a8:	30 09       	mov	r9,0
800091aa:	6e 9a       	ld.w	r10,r7[0x24]
800091ac:	95 19       	st.w	r10[0x4],r9
800091ae:	30 49       	mov	r9,4
800091b0:	c0 68       	rjmp	800091bc <_dtoa_r+0x30c>
800091b2:	d7 03       	nop
800091b4:	6a 1a       	ld.w	r10,r5[0x4]
800091b6:	a1 79       	lsl	r9,0x1
800091b8:	2f fa       	sub	r10,-1
800091ba:	8b 1a       	st.w	r5[0x4],r10
800091bc:	6e 95       	ld.w	r5,r7[0x24]
800091be:	f2 ca ff ec 	sub	r10,r9,-20
800091c2:	10 3a       	cp.w	r10,r8
800091c4:	fe 98 ff f8 	brls	800091b4 <_dtoa_r+0x304>
800091c8:	6a 1b       	ld.w	r11,r5[0x4]
800091ca:	0e 9c       	mov	r12,r7
800091cc:	e0 a0 09 44 	rcall	8000a454 <_Balloc>
800091d0:	58 e1       	cp.w	r1,14
800091d2:	5f 88       	srls	r8
800091d4:	8b 0c       	st.w	r5[0x0],r12
800091d6:	f1 e4 00 04 	and	r4,r8,r4
800091da:	6e 98       	ld.w	r8,r7[0x24]
800091dc:	70 08       	ld.w	r8,r8[0x0]
800091de:	50 88       	stdsp	sp[0x20],r8
800091e0:	e0 80 01 82 	breq	800094e4 <_dtoa_r+0x634>
800091e4:	58 06       	cp.w	r6,0
800091e6:	e0 8a 00 43 	brle	8000926c <_dtoa_r+0x3bc>
800091ea:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800091ee:	fe c8 c6 4e 	sub	r8,pc,-14770
800091f2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800091f6:	fa e5 00 18 	st.d	sp[24],r4
800091fa:	ec 04 14 04 	asr	r4,r6,0x4
800091fe:	ed b4 00 04 	bld	r4,0x4
80009202:	c0 30       	breq	80009208 <_dtoa_r+0x358>
80009204:	30 25       	mov	r5,2
80009206:	c1 08       	rjmp	80009226 <_dtoa_r+0x376>
80009208:	fe c8 c5 a0 	sub	r8,pc,-14944
8000920c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009210:	fa ea 00 3c 	ld.d	r10,sp[60]
80009214:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009218:	e0 a0 0f fa 	rcall	8000b20c <__avr32_f64_div>
8000921c:	30 35       	mov	r5,3
8000921e:	14 98       	mov	r8,r10
80009220:	16 99       	mov	r9,r11
80009222:	fa e9 00 08 	st.d	sp[8],r8
80009226:	fe cc c5 be 	sub	r12,pc,-14914
8000922a:	50 a3       	stdsp	sp[0x28],r3
8000922c:	0c 93       	mov	r3,r6
8000922e:	18 96       	mov	r6,r12
80009230:	c0 f8       	rjmp	8000924e <_dtoa_r+0x39e>
80009232:	fa ea 00 18 	ld.d	r10,sp[24]
80009236:	ed b4 00 00 	bld	r4,0x0
8000923a:	c0 81       	brne	8000924a <_dtoa_r+0x39a>
8000923c:	ec e8 00 00 	ld.d	r8,r6[0]
80009240:	2f f5       	sub	r5,-1
80009242:	e0 a0 0c 9f 	rcall	8000ab80 <__avr32_f64_mul>
80009246:	fa eb 00 18 	st.d	sp[24],r10
8000924a:	a1 54       	asr	r4,0x1
8000924c:	2f 86       	sub	r6,-8
8000924e:	58 04       	cp.w	r4,0
80009250:	cf 11       	brne	80009232 <_dtoa_r+0x382>
80009252:	fa e8 00 18 	ld.d	r8,sp[24]
80009256:	fa ea 00 08 	ld.d	r10,sp[8]
8000925a:	06 96       	mov	r6,r3
8000925c:	e0 a0 0f d8 	rcall	8000b20c <__avr32_f64_div>
80009260:	40 a3       	lddsp	r3,sp[0x28]
80009262:	14 98       	mov	r8,r10
80009264:	16 99       	mov	r9,r11
80009266:	fa e9 00 08 	st.d	sp[8],r8
8000926a:	c2 f8       	rjmp	800092c8 <_dtoa_r+0x418>
8000926c:	ec 08 11 00 	rsub	r8,r6,0
80009270:	c0 31       	brne	80009276 <_dtoa_r+0x3c6>
80009272:	30 25       	mov	r5,2
80009274:	c2 a8       	rjmp	800092c8 <_dtoa_r+0x418>
80009276:	fe cc c6 0e 	sub	r12,pc,-14834
8000927a:	f0 04 14 04 	asr	r4,r8,0x4
8000927e:	50 1c       	stdsp	sp[0x4],r12
80009280:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009284:	fe c9 c6 e4 	sub	r9,pc,-14620
80009288:	fa ea 00 3c 	ld.d	r10,sp[60]
8000928c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009290:	e0 a0 0c 78 	rcall	8000ab80 <__avr32_f64_mul>
80009294:	40 1c       	lddsp	r12,sp[0x4]
80009296:	50 63       	stdsp	sp[0x18],r3
80009298:	30 25       	mov	r5,2
8000929a:	0c 93       	mov	r3,r6
8000929c:	fa eb 00 08 	st.d	sp[8],r10
800092a0:	18 96       	mov	r6,r12
800092a2:	c0 f8       	rjmp	800092c0 <_dtoa_r+0x410>
800092a4:	fa ea 00 08 	ld.d	r10,sp[8]
800092a8:	ed b4 00 00 	bld	r4,0x0
800092ac:	c0 81       	brne	800092bc <_dtoa_r+0x40c>
800092ae:	ec e8 00 00 	ld.d	r8,r6[0]
800092b2:	2f f5       	sub	r5,-1
800092b4:	e0 a0 0c 66 	rcall	8000ab80 <__avr32_f64_mul>
800092b8:	fa eb 00 08 	st.d	sp[8],r10
800092bc:	a1 54       	asr	r4,0x1
800092be:	2f 86       	sub	r6,-8
800092c0:	58 04       	cp.w	r4,0
800092c2:	cf 11       	brne	800092a4 <_dtoa_r+0x3f4>
800092c4:	06 96       	mov	r6,r3
800092c6:	40 63       	lddsp	r3,sp[0x18]
800092c8:	41 4a       	lddsp	r10,sp[0x50]
800092ca:	58 0a       	cp.w	r10,0
800092cc:	c2 a0       	breq	80009320 <_dtoa_r+0x470>
800092ce:	fa e8 00 08 	ld.d	r8,sp[8]
800092d2:	58 01       	cp.w	r1,0
800092d4:	5f 94       	srgt	r4
800092d6:	fa e9 00 18 	st.d	sp[24],r8
800092da:	30 08       	mov	r8,0
800092dc:	fc 19 3f f0 	movh	r9,0x3ff0
800092e0:	fa ea 00 18 	ld.d	r10,sp[24]
800092e4:	e0 a0 0f 60 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
800092e8:	f9 bc 00 00 	moveq	r12,0
800092ec:	f9 bc 01 01 	movne	r12,1
800092f0:	e9 ec 00 0c 	and	r12,r4,r12
800092f4:	c1 60       	breq	80009320 <_dtoa_r+0x470>
800092f6:	40 98       	lddsp	r8,sp[0x24]
800092f8:	58 08       	cp.w	r8,0
800092fa:	e0 8a 00 f1 	brle	800094dc <_dtoa_r+0x62c>
800092fe:	30 08       	mov	r8,0
80009300:	fc 19 40 24 	movh	r9,0x4024
80009304:	ec c4 00 01 	sub	r4,r6,1
80009308:	fa ea 00 18 	ld.d	r10,sp[24]
8000930c:	2f f5       	sub	r5,-1
8000930e:	50 64       	stdsp	sp[0x18],r4
80009310:	e0 a0 0c 38 	rcall	8000ab80 <__avr32_f64_mul>
80009314:	40 94       	lddsp	r4,sp[0x24]
80009316:	14 98       	mov	r8,r10
80009318:	16 99       	mov	r9,r11
8000931a:	fa e9 00 08 	st.d	sp[8],r8
8000931e:	c0 38       	rjmp	80009324 <_dtoa_r+0x474>
80009320:	50 66       	stdsp	sp[0x18],r6
80009322:	02 94       	mov	r4,r1
80009324:	0a 9c       	mov	r12,r5
80009326:	e0 a0 0e 88 	rcall	8000b036 <__avr32_s32_to_f64>
8000932a:	fa e8 00 08 	ld.d	r8,sp[8]
8000932e:	e0 a0 0c 29 	rcall	8000ab80 <__avr32_f64_mul>
80009332:	30 08       	mov	r8,0
80009334:	fc 19 40 1c 	movh	r9,0x401c
80009338:	e0 a0 0d de 	rcall	8000aef4 <__avr32_f64_add>
8000933c:	14 98       	mov	r8,r10
8000933e:	16 99       	mov	r9,r11
80009340:	fa e9 00 28 	st.d	sp[40],r8
80009344:	fc 18 fc c0 	movh	r8,0xfcc0
80009348:	40 a5       	lddsp	r5,sp[0x28]
8000934a:	10 05       	add	r5,r8
8000934c:	50 a5       	stdsp	sp[0x28],r5
8000934e:	58 04       	cp.w	r4,0
80009350:	c2 11       	brne	80009392 <_dtoa_r+0x4e2>
80009352:	fa ea 00 08 	ld.d	r10,sp[8]
80009356:	30 08       	mov	r8,0
80009358:	fc 19 40 14 	movh	r9,0x4014
8000935c:	e0 a0 0c fe 	rcall	8000ad58 <__avr32_f64_sub>
80009360:	40 bc       	lddsp	r12,sp[0x2c]
80009362:	fa eb 00 08 	st.d	sp[8],r10
80009366:	14 98       	mov	r8,r10
80009368:	16 99       	mov	r9,r11
8000936a:	18 9a       	mov	r10,r12
8000936c:	0a 9b       	mov	r11,r5
8000936e:	e0 a0 0f 1b 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
80009372:	e0 81 02 54 	brne	8000981a <_dtoa_r+0x96a>
80009376:	0a 98       	mov	r8,r5
80009378:	40 b9       	lddsp	r9,sp[0x2c]
8000937a:	ee 18 80 00 	eorh	r8,0x8000
8000937e:	fa ea 00 08 	ld.d	r10,sp[8]
80009382:	10 95       	mov	r5,r8
80009384:	12 98       	mov	r8,r9
80009386:	0a 99       	mov	r9,r5
80009388:	e0 a0 0f 0e 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
8000938c:	e0 81 02 3e 	brne	80009808 <_dtoa_r+0x958>
80009390:	ca 68       	rjmp	800094dc <_dtoa_r+0x62c>
80009392:	fe c9 c7 f2 	sub	r9,pc,-14350
80009396:	e8 c8 00 01 	sub	r8,r4,1
8000939a:	40 d5       	lddsp	r5,sp[0x34]
8000939c:	58 05       	cp.w	r5,0
8000939e:	c4 f0       	breq	8000943c <_dtoa_r+0x58c>
800093a0:	30 0c       	mov	r12,0
800093a2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800093a6:	51 3c       	stdsp	sp[0x4c],r12
800093a8:	30 0a       	mov	r10,0
800093aa:	fc 1b 3f e0 	movh	r11,0x3fe0
800093ae:	e0 a0 0f 2f 	rcall	8000b20c <__avr32_f64_div>
800093b2:	fa e8 00 28 	ld.d	r8,sp[40]
800093b6:	40 85       	lddsp	r5,sp[0x20]
800093b8:	e0 a0 0c d0 	rcall	8000ad58 <__avr32_f64_sub>
800093bc:	fa eb 00 28 	st.d	sp[40],r10
800093c0:	fa ea 00 08 	ld.d	r10,sp[8]
800093c4:	e0 a0 0e 22 	rcall	8000b008 <__avr32_f64_to_s32>
800093c8:	51 6c       	stdsp	sp[0x58],r12
800093ca:	e0 a0 0e 36 	rcall	8000b036 <__avr32_s32_to_f64>
800093ce:	14 98       	mov	r8,r10
800093d0:	16 99       	mov	r9,r11
800093d2:	fa ea 00 08 	ld.d	r10,sp[8]
800093d6:	e0 a0 0c c1 	rcall	8000ad58 <__avr32_f64_sub>
800093da:	fa eb 00 08 	st.d	sp[8],r10
800093de:	41 68       	lddsp	r8,sp[0x58]
800093e0:	2d 08       	sub	r8,-48
800093e2:	0a c8       	st.b	r5++,r8
800093e4:	41 39       	lddsp	r9,sp[0x4c]
800093e6:	2f f9       	sub	r9,-1
800093e8:	51 39       	stdsp	sp[0x4c],r9
800093ea:	fa e8 00 28 	ld.d	r8,sp[40]
800093ee:	e0 a0 0e db 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
800093f2:	e0 81 03 39 	brne	80009a64 <_dtoa_r+0xbb4>
800093f6:	fa e8 00 08 	ld.d	r8,sp[8]
800093fa:	30 0a       	mov	r10,0
800093fc:	fc 1b 3f f0 	movh	r11,0x3ff0
80009400:	e0 a0 0c ac 	rcall	8000ad58 <__avr32_f64_sub>
80009404:	fa e8 00 28 	ld.d	r8,sp[40]
80009408:	e0 a0 0e ce 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
8000940c:	fa ea 00 28 	ld.d	r10,sp[40]
80009410:	30 08       	mov	r8,0
80009412:	fc 19 40 24 	movh	r9,0x4024
80009416:	e0 81 00 da 	brne	800095ca <_dtoa_r+0x71a>
8000941a:	41 3c       	lddsp	r12,sp[0x4c]
8000941c:	08 3c       	cp.w	r12,r4
8000941e:	c5 f4       	brge	800094dc <_dtoa_r+0x62c>
80009420:	e0 a0 0b b0 	rcall	8000ab80 <__avr32_f64_mul>
80009424:	30 08       	mov	r8,0
80009426:	fa eb 00 28 	st.d	sp[40],r10
8000942a:	fc 19 40 24 	movh	r9,0x4024
8000942e:	fa ea 00 08 	ld.d	r10,sp[8]
80009432:	e0 a0 0b a7 	rcall	8000ab80 <__avr32_f64_mul>
80009436:	fa eb 00 08 	st.d	sp[8],r10
8000943a:	cc 3b       	rjmp	800093c0 <_dtoa_r+0x510>
8000943c:	40 85       	lddsp	r5,sp[0x20]
8000943e:	08 05       	add	r5,r4
80009440:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009444:	51 35       	stdsp	sp[0x4c],r5
80009446:	fa e8 00 28 	ld.d	r8,sp[40]
8000944a:	40 85       	lddsp	r5,sp[0x20]
8000944c:	e0 a0 0b 9a 	rcall	8000ab80 <__avr32_f64_mul>
80009450:	fa eb 00 28 	st.d	sp[40],r10
80009454:	fa ea 00 08 	ld.d	r10,sp[8]
80009458:	e0 a0 0d d8 	rcall	8000b008 <__avr32_f64_to_s32>
8000945c:	51 6c       	stdsp	sp[0x58],r12
8000945e:	e0 a0 0d ec 	rcall	8000b036 <__avr32_s32_to_f64>
80009462:	14 98       	mov	r8,r10
80009464:	16 99       	mov	r9,r11
80009466:	fa ea 00 08 	ld.d	r10,sp[8]
8000946a:	e0 a0 0c 77 	rcall	8000ad58 <__avr32_f64_sub>
8000946e:	fa eb 00 08 	st.d	sp[8],r10
80009472:	41 68       	lddsp	r8,sp[0x58]
80009474:	2d 08       	sub	r8,-48
80009476:	0a c8       	st.b	r5++,r8
80009478:	41 3c       	lddsp	r12,sp[0x4c]
8000947a:	18 35       	cp.w	r5,r12
8000947c:	c2 81       	brne	800094cc <_dtoa_r+0x61c>
8000947e:	30 08       	mov	r8,0
80009480:	fc 19 3f e0 	movh	r9,0x3fe0
80009484:	fa ea 00 28 	ld.d	r10,sp[40]
80009488:	e0 a0 0d 36 	rcall	8000aef4 <__avr32_f64_add>
8000948c:	40 85       	lddsp	r5,sp[0x20]
8000948e:	fa e8 00 08 	ld.d	r8,sp[8]
80009492:	08 05       	add	r5,r4
80009494:	e0 a0 0e 88 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
80009498:	e0 81 00 99 	brne	800095ca <_dtoa_r+0x71a>
8000949c:	fa e8 00 28 	ld.d	r8,sp[40]
800094a0:	30 0a       	mov	r10,0
800094a2:	fc 1b 3f e0 	movh	r11,0x3fe0
800094a6:	e0 a0 0c 59 	rcall	8000ad58 <__avr32_f64_sub>
800094aa:	14 98       	mov	r8,r10
800094ac:	16 99       	mov	r9,r11
800094ae:	fa ea 00 08 	ld.d	r10,sp[8]
800094b2:	e0 a0 0e 79 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
800094b6:	c1 30       	breq	800094dc <_dtoa_r+0x62c>
800094b8:	33 09       	mov	r9,48
800094ba:	0a 98       	mov	r8,r5
800094bc:	11 7a       	ld.ub	r10,--r8
800094be:	f2 0a 18 00 	cp.b	r10,r9
800094c2:	e0 81 02 d1 	brne	80009a64 <_dtoa_r+0xbb4>
800094c6:	10 95       	mov	r5,r8
800094c8:	cf 9b       	rjmp	800094ba <_dtoa_r+0x60a>
800094ca:	d7 03       	nop
800094cc:	30 08       	mov	r8,0
800094ce:	fc 19 40 24 	movh	r9,0x4024
800094d2:	e0 a0 0b 57 	rcall	8000ab80 <__avr32_f64_mul>
800094d6:	fa eb 00 08 	st.d	sp[8],r10
800094da:	cb db       	rjmp	80009454 <_dtoa_r+0x5a4>
800094dc:	fa ea 00 3c 	ld.d	r10,sp[60]
800094e0:	fa eb 00 08 	st.d	sp[8],r10
800094e4:	58 e6       	cp.w	r6,14
800094e6:	5f ab       	srle	r11
800094e8:	41 8a       	lddsp	r10,sp[0x60]
800094ea:	30 08       	mov	r8,0
800094ec:	f4 09 11 ff 	rsub	r9,r10,-1
800094f0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800094f4:	f0 09 18 00 	cp.b	r9,r8
800094f8:	e0 80 00 82 	breq	800095fc <_dtoa_r+0x74c>
800094fc:	40 ea       	lddsp	r10,sp[0x38]
800094fe:	58 01       	cp.w	r1,0
80009500:	5f a9       	srle	r9
80009502:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009506:	fe ca c9 66 	sub	r10,pc,-13978
8000950a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000950e:	fa e5 00 10 	st.d	sp[16],r4
80009512:	f0 09 18 00 	cp.b	r9,r8
80009516:	c1 40       	breq	8000953e <_dtoa_r+0x68e>
80009518:	58 01       	cp.w	r1,0
8000951a:	e0 81 01 77 	brne	80009808 <_dtoa_r+0x958>
8000951e:	30 08       	mov	r8,0
80009520:	fc 19 40 14 	movh	r9,0x4014
80009524:	08 9a       	mov	r10,r4
80009526:	0a 9b       	mov	r11,r5
80009528:	e0 a0 0b 2c 	rcall	8000ab80 <__avr32_f64_mul>
8000952c:	fa e8 00 08 	ld.d	r8,sp[8]
80009530:	e0 a0 0e 06 	rcall	8000b13c <__avr32_f64_cmp_ge>
80009534:	e0 81 01 6a 	brne	80009808 <_dtoa_r+0x958>
80009538:	02 92       	mov	r2,r1
8000953a:	e0 8f 01 72 	bral	8000981e <_dtoa_r+0x96e>
8000953e:	40 85       	lddsp	r5,sp[0x20]
80009540:	30 14       	mov	r4,1
80009542:	fa e8 00 10 	ld.d	r8,sp[16]
80009546:	fa ea 00 08 	ld.d	r10,sp[8]
8000954a:	e0 a0 0e 61 	rcall	8000b20c <__avr32_f64_div>
8000954e:	e0 a0 0d 5d 	rcall	8000b008 <__avr32_f64_to_s32>
80009552:	18 92       	mov	r2,r12
80009554:	e0 a0 0d 71 	rcall	8000b036 <__avr32_s32_to_f64>
80009558:	fa e8 00 10 	ld.d	r8,sp[16]
8000955c:	e0 a0 0b 12 	rcall	8000ab80 <__avr32_f64_mul>
80009560:	14 98       	mov	r8,r10
80009562:	16 99       	mov	r9,r11
80009564:	fa ea 00 08 	ld.d	r10,sp[8]
80009568:	e0 a0 0b f8 	rcall	8000ad58 <__avr32_f64_sub>
8000956c:	fa eb 00 08 	st.d	sp[8],r10
80009570:	e4 c8 ff d0 	sub	r8,r2,-48
80009574:	0a c8       	st.b	r5++,r8
80009576:	fc 19 40 24 	movh	r9,0x4024
8000957a:	30 08       	mov	r8,0
8000957c:	02 34       	cp.w	r4,r1
8000957e:	c3 31       	brne	800095e4 <_dtoa_r+0x734>
80009580:	fa e8 00 08 	ld.d	r8,sp[8]
80009584:	e0 a0 0c b8 	rcall	8000aef4 <__avr32_f64_add>
80009588:	16 91       	mov	r1,r11
8000958a:	14 90       	mov	r0,r10
8000958c:	14 98       	mov	r8,r10
8000958e:	02 99       	mov	r9,r1
80009590:	fa ea 00 10 	ld.d	r10,sp[16]
80009594:	e0 a0 0e 08 	rcall	8000b1a4 <__avr32_f64_cmp_lt>
80009598:	c1 a1       	brne	800095cc <_dtoa_r+0x71c>
8000959a:	fa e8 00 10 	ld.d	r8,sp[16]
8000959e:	00 9a       	mov	r10,r0
800095a0:	02 9b       	mov	r11,r1
800095a2:	e0 a0 0d ba 	rcall	8000b116 <__avr32_f64_cmp_eq>
800095a6:	e0 80 02 5e 	breq	80009a62 <_dtoa_r+0xbb2>
800095aa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800095ae:	c0 f1       	brne	800095cc <_dtoa_r+0x71c>
800095b0:	e0 8f 02 59 	bral	80009a62 <_dtoa_r+0xbb2>
800095b4:	40 8a       	lddsp	r10,sp[0x20]
800095b6:	14 38       	cp.w	r8,r10
800095b8:	c0 30       	breq	800095be <_dtoa_r+0x70e>
800095ba:	10 95       	mov	r5,r8
800095bc:	c0 98       	rjmp	800095ce <_dtoa_r+0x71e>
800095be:	33 08       	mov	r8,48
800095c0:	40 89       	lddsp	r9,sp[0x20]
800095c2:	2f f6       	sub	r6,-1
800095c4:	b2 88       	st.b	r9[0x0],r8
800095c6:	40 88       	lddsp	r8,sp[0x20]
800095c8:	c0 88       	rjmp	800095d8 <_dtoa_r+0x728>
800095ca:	40 66       	lddsp	r6,sp[0x18]
800095cc:	33 99       	mov	r9,57
800095ce:	0a 98       	mov	r8,r5
800095d0:	11 7a       	ld.ub	r10,--r8
800095d2:	f2 0a 18 00 	cp.b	r10,r9
800095d6:	ce f0       	breq	800095b4 <_dtoa_r+0x704>
800095d8:	50 66       	stdsp	sp[0x18],r6
800095da:	11 89       	ld.ub	r9,r8[0x0]
800095dc:	2f f9       	sub	r9,-1
800095de:	b0 89       	st.b	r8[0x0],r9
800095e0:	e0 8f 02 42 	bral	80009a64 <_dtoa_r+0xbb4>
800095e4:	e0 a0 0a ce 	rcall	8000ab80 <__avr32_f64_mul>
800095e8:	2f f4       	sub	r4,-1
800095ea:	fa eb 00 08 	st.d	sp[8],r10
800095ee:	30 08       	mov	r8,0
800095f0:	30 09       	mov	r9,0
800095f2:	e0 a0 0d 92 	rcall	8000b116 <__avr32_f64_cmp_eq>
800095f6:	ca 60       	breq	80009542 <_dtoa_r+0x692>
800095f8:	e0 8f 02 35 	bral	80009a62 <_dtoa_r+0xbb2>
800095fc:	40 d8       	lddsp	r8,sp[0x34]
800095fe:	58 08       	cp.w	r8,0
80009600:	c0 51       	brne	8000960a <_dtoa_r+0x75a>
80009602:	04 98       	mov	r8,r2
80009604:	00 95       	mov	r5,r0
80009606:	40 d4       	lddsp	r4,sp[0x34]
80009608:	c3 78       	rjmp	80009676 <_dtoa_r+0x7c6>
8000960a:	40 c5       	lddsp	r5,sp[0x30]
8000960c:	58 15       	cp.w	r5,1
8000960e:	e0 89 00 0f 	brgt	8000962c <_dtoa_r+0x77c>
80009612:	41 74       	lddsp	r4,sp[0x5c]
80009614:	58 04       	cp.w	r4,0
80009616:	c0 40       	breq	8000961e <_dtoa_r+0x76e>
80009618:	f4 c9 fb cd 	sub	r9,r10,-1075
8000961c:	c0 48       	rjmp	80009624 <_dtoa_r+0x774>
8000961e:	41 99       	lddsp	r9,sp[0x64]
80009620:	f2 09 11 36 	rsub	r9,r9,54
80009624:	04 98       	mov	r8,r2
80009626:	00 95       	mov	r5,r0
80009628:	c1 c8       	rjmp	80009660 <_dtoa_r+0x7b0>
8000962a:	d7 03       	nop
8000962c:	e2 c8 00 01 	sub	r8,r1,1
80009630:	58 01       	cp.w	r1,0
80009632:	e0 05 17 40 	movge	r5,r0
80009636:	e2 09 17 40 	movge	r9,r1
8000963a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000963e:	f9 b9 05 00 	movlt	r9,0
80009642:	10 32       	cp.w	r2,r8
80009644:	e5 d8 e4 18 	subge	r8,r2,r8
80009648:	f1 d2 e5 18 	sublt	r8,r8,r2
8000964c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009650:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009654:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009658:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000965c:	f9 b8 05 00 	movlt	r8,0
80009660:	40 4b       	lddsp	r11,sp[0x10]
80009662:	12 0b       	add	r11,r9
80009664:	50 08       	stdsp	sp[0x0],r8
80009666:	50 4b       	stdsp	sp[0x10],r11
80009668:	12 00       	add	r0,r9
8000966a:	30 1b       	mov	r11,1
8000966c:	0e 9c       	mov	r12,r7
8000966e:	e0 a0 08 a7 	rcall	8000a7bc <__i2b>
80009672:	40 08       	lddsp	r8,sp[0x0]
80009674:	18 94       	mov	r4,r12
80009676:	40 4a       	lddsp	r10,sp[0x10]
80009678:	58 05       	cp.w	r5,0
8000967a:	5f 99       	srgt	r9
8000967c:	58 0a       	cp.w	r10,0
8000967e:	5f 9a       	srgt	r10
80009680:	f5 e9 00 09 	and	r9,r10,r9
80009684:	c0 80       	breq	80009694 <_dtoa_r+0x7e4>
80009686:	40 4c       	lddsp	r12,sp[0x10]
80009688:	f8 05 0d 49 	min	r9,r12,r5
8000968c:	12 1c       	sub	r12,r9
8000968e:	12 10       	sub	r0,r9
80009690:	50 4c       	stdsp	sp[0x10],r12
80009692:	12 15       	sub	r5,r9
80009694:	58 02       	cp.w	r2,0
80009696:	e0 8a 00 27 	brle	800096e4 <_dtoa_r+0x834>
8000969a:	40 db       	lddsp	r11,sp[0x34]
8000969c:	58 0b       	cp.w	r11,0
8000969e:	c1 d0       	breq	800096d8 <_dtoa_r+0x828>
800096a0:	58 08       	cp.w	r8,0
800096a2:	e0 8a 00 17 	brle	800096d0 <_dtoa_r+0x820>
800096a6:	10 9a       	mov	r10,r8
800096a8:	50 08       	stdsp	sp[0x0],r8
800096aa:	08 9b       	mov	r11,r4
800096ac:	0e 9c       	mov	r12,r7
800096ae:	e0 a0 08 cd 	rcall	8000a848 <__pow5mult>
800096b2:	06 9a       	mov	r10,r3
800096b4:	18 9b       	mov	r11,r12
800096b6:	18 94       	mov	r4,r12
800096b8:	0e 9c       	mov	r12,r7
800096ba:	e0 a0 08 01 	rcall	8000a6bc <__multiply>
800096be:	18 99       	mov	r9,r12
800096c0:	06 9b       	mov	r11,r3
800096c2:	50 19       	stdsp	sp[0x4],r9
800096c4:	0e 9c       	mov	r12,r7
800096c6:	e0 a0 06 ad 	rcall	8000a420 <_Bfree>
800096ca:	40 19       	lddsp	r9,sp[0x4]
800096cc:	40 08       	lddsp	r8,sp[0x0]
800096ce:	12 93       	mov	r3,r9
800096d0:	e4 08 01 0a 	sub	r10,r2,r8
800096d4:	c0 80       	breq	800096e4 <_dtoa_r+0x834>
800096d6:	c0 28       	rjmp	800096da <_dtoa_r+0x82a>
800096d8:	04 9a       	mov	r10,r2
800096da:	06 9b       	mov	r11,r3
800096dc:	0e 9c       	mov	r12,r7
800096de:	e0 a0 08 b5 	rcall	8000a848 <__pow5mult>
800096e2:	18 93       	mov	r3,r12
800096e4:	30 1b       	mov	r11,1
800096e6:	0e 9c       	mov	r12,r7
800096e8:	e0 a0 08 6a 	rcall	8000a7bc <__i2b>
800096ec:	41 1a       	lddsp	r10,sp[0x44]
800096ee:	18 92       	mov	r2,r12
800096f0:	58 0a       	cp.w	r10,0
800096f2:	e0 8a 00 07 	brle	80009700 <_dtoa_r+0x850>
800096f6:	18 9b       	mov	r11,r12
800096f8:	0e 9c       	mov	r12,r7
800096fa:	e0 a0 08 a7 	rcall	8000a848 <__pow5mult>
800096fe:	18 92       	mov	r2,r12
80009700:	40 c9       	lddsp	r9,sp[0x30]
80009702:	58 19       	cp.w	r9,1
80009704:	e0 89 00 14 	brgt	8000972c <_dtoa_r+0x87c>
80009708:	40 38       	lddsp	r8,sp[0xc]
8000970a:	58 08       	cp.w	r8,0
8000970c:	c1 01       	brne	8000972c <_dtoa_r+0x87c>
8000970e:	40 29       	lddsp	r9,sp[0x8]
80009710:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009714:	c0 c1       	brne	8000972c <_dtoa_r+0x87c>
80009716:	12 98       	mov	r8,r9
80009718:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000971c:	c0 80       	breq	8000972c <_dtoa_r+0x87c>
8000971e:	40 4c       	lddsp	r12,sp[0x10]
80009720:	30 1b       	mov	r11,1
80009722:	2f fc       	sub	r12,-1
80009724:	2f f0       	sub	r0,-1
80009726:	50 4c       	stdsp	sp[0x10],r12
80009728:	50 6b       	stdsp	sp[0x18],r11
8000972a:	c0 38       	rjmp	80009730 <_dtoa_r+0x880>
8000972c:	30 0a       	mov	r10,0
8000972e:	50 6a       	stdsp	sp[0x18],r10
80009730:	41 19       	lddsp	r9,sp[0x44]
80009732:	58 09       	cp.w	r9,0
80009734:	c0 31       	brne	8000973a <_dtoa_r+0x88a>
80009736:	30 1c       	mov	r12,1
80009738:	c0 98       	rjmp	8000974a <_dtoa_r+0x89a>
8000973a:	64 48       	ld.w	r8,r2[0x10]
8000973c:	2f c8       	sub	r8,-4
8000973e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009742:	e0 a0 05 df 	rcall	8000a300 <__hi0bits>
80009746:	f8 0c 11 20 	rsub	r12,r12,32
8000974a:	40 4b       	lddsp	r11,sp[0x10]
8000974c:	f8 0b 00 08 	add	r8,r12,r11
80009750:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009754:	c0 c0       	breq	8000976c <_dtoa_r+0x8bc>
80009756:	f0 08 11 20 	rsub	r8,r8,32
8000975a:	58 48       	cp.w	r8,4
8000975c:	e0 8a 00 06 	brle	80009768 <_dtoa_r+0x8b8>
80009760:	20 48       	sub	r8,4
80009762:	10 0b       	add	r11,r8
80009764:	50 4b       	stdsp	sp[0x10],r11
80009766:	c0 78       	rjmp	80009774 <_dtoa_r+0x8c4>
80009768:	58 48       	cp.w	r8,4
8000976a:	c0 70       	breq	80009778 <_dtoa_r+0x8c8>
8000976c:	40 4a       	lddsp	r10,sp[0x10]
8000976e:	2e 48       	sub	r8,-28
80009770:	10 0a       	add	r10,r8
80009772:	50 4a       	stdsp	sp[0x10],r10
80009774:	10 00       	add	r0,r8
80009776:	10 05       	add	r5,r8
80009778:	58 00       	cp.w	r0,0
8000977a:	e0 8a 00 08 	brle	8000978a <_dtoa_r+0x8da>
8000977e:	06 9b       	mov	r11,r3
80009780:	00 9a       	mov	r10,r0
80009782:	0e 9c       	mov	r12,r7
80009784:	e0 a0 07 58 	rcall	8000a634 <__lshift>
80009788:	18 93       	mov	r3,r12
8000978a:	40 49       	lddsp	r9,sp[0x10]
8000978c:	58 09       	cp.w	r9,0
8000978e:	e0 8a 00 08 	brle	8000979e <_dtoa_r+0x8ee>
80009792:	04 9b       	mov	r11,r2
80009794:	12 9a       	mov	r10,r9
80009796:	0e 9c       	mov	r12,r7
80009798:	e0 a0 07 4e 	rcall	8000a634 <__lshift>
8000979c:	18 92       	mov	r2,r12
8000979e:	41 48       	lddsp	r8,sp[0x50]
800097a0:	58 08       	cp.w	r8,0
800097a2:	c1 b0       	breq	800097d8 <_dtoa_r+0x928>
800097a4:	04 9b       	mov	r11,r2
800097a6:	06 9c       	mov	r12,r3
800097a8:	e0 a0 06 23 	rcall	8000a3ee <__mcmp>
800097ac:	c1 64       	brge	800097d8 <_dtoa_r+0x928>
800097ae:	06 9b       	mov	r11,r3
800097b0:	30 09       	mov	r9,0
800097b2:	30 aa       	mov	r10,10
800097b4:	0e 9c       	mov	r12,r7
800097b6:	e0 a0 08 0b 	rcall	8000a7cc <__multadd>
800097ba:	20 16       	sub	r6,1
800097bc:	18 93       	mov	r3,r12
800097be:	40 dc       	lddsp	r12,sp[0x34]
800097c0:	58 0c       	cp.w	r12,0
800097c2:	c0 31       	brne	800097c8 <_dtoa_r+0x918>
800097c4:	40 91       	lddsp	r1,sp[0x24]
800097c6:	c0 98       	rjmp	800097d8 <_dtoa_r+0x928>
800097c8:	08 9b       	mov	r11,r4
800097ca:	40 91       	lddsp	r1,sp[0x24]
800097cc:	30 09       	mov	r9,0
800097ce:	30 aa       	mov	r10,10
800097d0:	0e 9c       	mov	r12,r7
800097d2:	e0 a0 07 fd 	rcall	8000a7cc <__multadd>
800097d6:	18 94       	mov	r4,r12
800097d8:	58 01       	cp.w	r1,0
800097da:	5f a9       	srle	r9
800097dc:	40 cb       	lddsp	r11,sp[0x30]
800097de:	58 2b       	cp.w	r11,2
800097e0:	5f 98       	srgt	r8
800097e2:	f3 e8 00 08 	and	r8,r9,r8
800097e6:	c2 50       	breq	80009830 <_dtoa_r+0x980>
800097e8:	58 01       	cp.w	r1,0
800097ea:	c1 11       	brne	8000980c <_dtoa_r+0x95c>
800097ec:	04 9b       	mov	r11,r2
800097ee:	02 99       	mov	r9,r1
800097f0:	30 5a       	mov	r10,5
800097f2:	0e 9c       	mov	r12,r7
800097f4:	e0 a0 07 ec 	rcall	8000a7cc <__multadd>
800097f8:	18 92       	mov	r2,r12
800097fa:	18 9b       	mov	r11,r12
800097fc:	06 9c       	mov	r12,r3
800097fe:	e0 a0 05 f8 	rcall	8000a3ee <__mcmp>
80009802:	e0 89 00 0f 	brgt	80009820 <_dtoa_r+0x970>
80009806:	c0 38       	rjmp	8000980c <_dtoa_r+0x95c>
80009808:	30 02       	mov	r2,0
8000980a:	04 94       	mov	r4,r2
8000980c:	40 ea       	lddsp	r10,sp[0x38]
8000980e:	30 09       	mov	r9,0
80009810:	5c da       	com	r10
80009812:	40 85       	lddsp	r5,sp[0x20]
80009814:	50 6a       	stdsp	sp[0x18],r10
80009816:	50 49       	stdsp	sp[0x10],r9
80009818:	c0 f9       	rjmp	80009a36 <_dtoa_r+0xb86>
8000981a:	08 92       	mov	r2,r4
8000981c:	40 66       	lddsp	r6,sp[0x18]
8000981e:	04 94       	mov	r4,r2
80009820:	2f f6       	sub	r6,-1
80009822:	50 66       	stdsp	sp[0x18],r6
80009824:	33 18       	mov	r8,49
80009826:	40 85       	lddsp	r5,sp[0x20]
80009828:	0a c8       	st.b	r5++,r8
8000982a:	30 08       	mov	r8,0
8000982c:	50 48       	stdsp	sp[0x10],r8
8000982e:	c0 49       	rjmp	80009a36 <_dtoa_r+0xb86>
80009830:	40 dc       	lddsp	r12,sp[0x34]
80009832:	58 0c       	cp.w	r12,0
80009834:	e0 80 00 b5 	breq	8000999e <_dtoa_r+0xaee>
80009838:	58 05       	cp.w	r5,0
8000983a:	e0 8a 00 08 	brle	8000984a <_dtoa_r+0x99a>
8000983e:	08 9b       	mov	r11,r4
80009840:	0a 9a       	mov	r10,r5
80009842:	0e 9c       	mov	r12,r7
80009844:	e0 a0 06 f8 	rcall	8000a634 <__lshift>
80009848:	18 94       	mov	r4,r12
8000984a:	40 6b       	lddsp	r11,sp[0x18]
8000984c:	58 0b       	cp.w	r11,0
8000984e:	c0 31       	brne	80009854 <_dtoa_r+0x9a4>
80009850:	08 9c       	mov	r12,r4
80009852:	c1 38       	rjmp	80009878 <_dtoa_r+0x9c8>
80009854:	68 1b       	ld.w	r11,r4[0x4]
80009856:	0e 9c       	mov	r12,r7
80009858:	e0 a0 05 fe 	rcall	8000a454 <_Balloc>
8000985c:	68 4a       	ld.w	r10,r4[0x10]
8000985e:	18 95       	mov	r5,r12
80009860:	e8 cb ff f4 	sub	r11,r4,-12
80009864:	2f ea       	sub	r10,-2
80009866:	2f 4c       	sub	r12,-12
80009868:	a3 6a       	lsl	r10,0x2
8000986a:	fe b0 e6 4f 	rcall	80006508 <memcpy>
8000986e:	0a 9b       	mov	r11,r5
80009870:	30 1a       	mov	r10,1
80009872:	0e 9c       	mov	r12,r7
80009874:	e0 a0 06 e0 	rcall	8000a634 <__lshift>
80009878:	50 44       	stdsp	sp[0x10],r4
8000987a:	40 3a       	lddsp	r10,sp[0xc]
8000987c:	30 19       	mov	r9,1
8000987e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009882:	18 94       	mov	r4,r12
80009884:	50 da       	stdsp	sp[0x34],r10
80009886:	40 85       	lddsp	r5,sp[0x20]
80009888:	50 99       	stdsp	sp[0x24],r9
8000988a:	50 26       	stdsp	sp[0x8],r6
8000988c:	50 e1       	stdsp	sp[0x38],r1
8000988e:	04 9b       	mov	r11,r2
80009890:	06 9c       	mov	r12,r3
80009892:	fe b0 fa 7f 	rcall	80008d90 <quorem>
80009896:	40 4b       	lddsp	r11,sp[0x10]
80009898:	f8 c0 ff d0 	sub	r0,r12,-48
8000989c:	06 9c       	mov	r12,r3
8000989e:	e0 a0 05 a8 	rcall	8000a3ee <__mcmp>
800098a2:	08 9a       	mov	r10,r4
800098a4:	50 6c       	stdsp	sp[0x18],r12
800098a6:	04 9b       	mov	r11,r2
800098a8:	0e 9c       	mov	r12,r7
800098aa:	e0 a0 06 5d 	rcall	8000a564 <__mdiff>
800098ae:	18 91       	mov	r1,r12
800098b0:	78 38       	ld.w	r8,r12[0xc]
800098b2:	58 08       	cp.w	r8,0
800098b4:	c0 30       	breq	800098ba <_dtoa_r+0xa0a>
800098b6:	30 16       	mov	r6,1
800098b8:	c0 68       	rjmp	800098c4 <_dtoa_r+0xa14>
800098ba:	18 9b       	mov	r11,r12
800098bc:	06 9c       	mov	r12,r3
800098be:	e0 a0 05 98 	rcall	8000a3ee <__mcmp>
800098c2:	18 96       	mov	r6,r12
800098c4:	0e 9c       	mov	r12,r7
800098c6:	02 9b       	mov	r11,r1
800098c8:	e0 a0 05 ac 	rcall	8000a420 <_Bfree>
800098cc:	40 cc       	lddsp	r12,sp[0x30]
800098ce:	ed ec 10 08 	or	r8,r6,r12
800098d2:	c0 d1       	brne	800098ec <_dtoa_r+0xa3c>
800098d4:	40 db       	lddsp	r11,sp[0x34]
800098d6:	58 0b       	cp.w	r11,0
800098d8:	c0 a1       	brne	800098ec <_dtoa_r+0xa3c>
800098da:	40 26       	lddsp	r6,sp[0x8]
800098dc:	e0 40 00 39 	cp.w	r0,57
800098e0:	c3 00       	breq	80009940 <_dtoa_r+0xa90>
800098e2:	40 6a       	lddsp	r10,sp[0x18]
800098e4:	58 0a       	cp.w	r10,0
800098e6:	e0 89 00 24 	brgt	8000992e <_dtoa_r+0xa7e>
800098ea:	c2 f8       	rjmp	80009948 <_dtoa_r+0xa98>
800098ec:	40 69       	lddsp	r9,sp[0x18]
800098ee:	58 09       	cp.w	r9,0
800098f0:	c0 85       	brlt	80009900 <_dtoa_r+0xa50>
800098f2:	12 98       	mov	r8,r9
800098f4:	40 cc       	lddsp	r12,sp[0x30]
800098f6:	18 48       	or	r8,r12
800098f8:	c1 d1       	brne	80009932 <_dtoa_r+0xa82>
800098fa:	40 db       	lddsp	r11,sp[0x34]
800098fc:	58 0b       	cp.w	r11,0
800098fe:	c1 a1       	brne	80009932 <_dtoa_r+0xa82>
80009900:	0c 99       	mov	r9,r6
80009902:	40 26       	lddsp	r6,sp[0x8]
80009904:	58 09       	cp.w	r9,0
80009906:	e0 8a 00 21 	brle	80009948 <_dtoa_r+0xa98>
8000990a:	06 9b       	mov	r11,r3
8000990c:	30 1a       	mov	r10,1
8000990e:	0e 9c       	mov	r12,r7
80009910:	e0 a0 06 92 	rcall	8000a634 <__lshift>
80009914:	04 9b       	mov	r11,r2
80009916:	18 93       	mov	r3,r12
80009918:	e0 a0 05 6b 	rcall	8000a3ee <__mcmp>
8000991c:	e0 89 00 06 	brgt	80009928 <_dtoa_r+0xa78>
80009920:	c1 41       	brne	80009948 <_dtoa_r+0xa98>
80009922:	ed b0 00 00 	bld	r0,0x0
80009926:	c1 11       	brne	80009948 <_dtoa_r+0xa98>
80009928:	e0 40 00 39 	cp.w	r0,57
8000992c:	c0 a0       	breq	80009940 <_dtoa_r+0xa90>
8000992e:	2f f0       	sub	r0,-1
80009930:	c0 c8       	rjmp	80009948 <_dtoa_r+0xa98>
80009932:	58 06       	cp.w	r6,0
80009934:	e0 8a 00 0c 	brle	8000994c <_dtoa_r+0xa9c>
80009938:	40 26       	lddsp	r6,sp[0x8]
8000993a:	e0 40 00 39 	cp.w	r0,57
8000993e:	c0 41       	brne	80009946 <_dtoa_r+0xa96>
80009940:	33 98       	mov	r8,57
80009942:	0a c8       	st.b	r5++,r8
80009944:	c6 78       	rjmp	80009a12 <_dtoa_r+0xb62>
80009946:	2f f0       	sub	r0,-1
80009948:	0a c0       	st.b	r5++,r0
8000994a:	c7 58       	rjmp	80009a34 <_dtoa_r+0xb84>
8000994c:	0a c0       	st.b	r5++,r0
8000994e:	40 9a       	lddsp	r10,sp[0x24]
80009950:	40 e9       	lddsp	r9,sp[0x38]
80009952:	12 3a       	cp.w	r10,r9
80009954:	c4 30       	breq	800099da <_dtoa_r+0xb2a>
80009956:	06 9b       	mov	r11,r3
80009958:	30 09       	mov	r9,0
8000995a:	30 aa       	mov	r10,10
8000995c:	0e 9c       	mov	r12,r7
8000995e:	e0 a0 07 37 	rcall	8000a7cc <__multadd>
80009962:	40 48       	lddsp	r8,sp[0x10]
80009964:	18 93       	mov	r3,r12
80009966:	08 38       	cp.w	r8,r4
80009968:	c0 91       	brne	8000997a <_dtoa_r+0xaca>
8000996a:	10 9b       	mov	r11,r8
8000996c:	30 09       	mov	r9,0
8000996e:	30 aa       	mov	r10,10
80009970:	0e 9c       	mov	r12,r7
80009972:	e0 a0 07 2d 	rcall	8000a7cc <__multadd>
80009976:	50 4c       	stdsp	sp[0x10],r12
80009978:	c0 e8       	rjmp	80009994 <_dtoa_r+0xae4>
8000997a:	40 4b       	lddsp	r11,sp[0x10]
8000997c:	30 09       	mov	r9,0
8000997e:	30 aa       	mov	r10,10
80009980:	0e 9c       	mov	r12,r7
80009982:	e0 a0 07 25 	rcall	8000a7cc <__multadd>
80009986:	08 9b       	mov	r11,r4
80009988:	50 4c       	stdsp	sp[0x10],r12
8000998a:	30 09       	mov	r9,0
8000998c:	30 aa       	mov	r10,10
8000998e:	0e 9c       	mov	r12,r7
80009990:	e0 a0 07 1e 	rcall	8000a7cc <__multadd>
80009994:	18 94       	mov	r4,r12
80009996:	40 9c       	lddsp	r12,sp[0x24]
80009998:	2f fc       	sub	r12,-1
8000999a:	50 9c       	stdsp	sp[0x24],r12
8000999c:	c7 9b       	rjmp	8000988e <_dtoa_r+0x9de>
8000999e:	30 18       	mov	r8,1
800099a0:	06 90       	mov	r0,r3
800099a2:	40 85       	lddsp	r5,sp[0x20]
800099a4:	08 93       	mov	r3,r4
800099a6:	0c 94       	mov	r4,r6
800099a8:	10 96       	mov	r6,r8
800099aa:	04 9b       	mov	r11,r2
800099ac:	00 9c       	mov	r12,r0
800099ae:	fe b0 f9 f1 	rcall	80008d90 <quorem>
800099b2:	2d 0c       	sub	r12,-48
800099b4:	0a cc       	st.b	r5++,r12
800099b6:	02 36       	cp.w	r6,r1
800099b8:	c0 a4       	brge	800099cc <_dtoa_r+0xb1c>
800099ba:	00 9b       	mov	r11,r0
800099bc:	30 09       	mov	r9,0
800099be:	30 aa       	mov	r10,10
800099c0:	0e 9c       	mov	r12,r7
800099c2:	2f f6       	sub	r6,-1
800099c4:	e0 a0 07 04 	rcall	8000a7cc <__multadd>
800099c8:	18 90       	mov	r0,r12
800099ca:	cf 0b       	rjmp	800099aa <_dtoa_r+0xafa>
800099cc:	08 96       	mov	r6,r4
800099ce:	30 0b       	mov	r11,0
800099d0:	06 94       	mov	r4,r3
800099d2:	50 4b       	stdsp	sp[0x10],r11
800099d4:	00 93       	mov	r3,r0
800099d6:	18 90       	mov	r0,r12
800099d8:	c0 28       	rjmp	800099dc <_dtoa_r+0xb2c>
800099da:	40 26       	lddsp	r6,sp[0x8]
800099dc:	06 9b       	mov	r11,r3
800099de:	30 1a       	mov	r10,1
800099e0:	0e 9c       	mov	r12,r7
800099e2:	e0 a0 06 29 	rcall	8000a634 <__lshift>
800099e6:	04 9b       	mov	r11,r2
800099e8:	18 93       	mov	r3,r12
800099ea:	e0 a0 05 02 	rcall	8000a3ee <__mcmp>
800099ee:	e0 89 00 12 	brgt	80009a12 <_dtoa_r+0xb62>
800099f2:	c1 b1       	brne	80009a28 <_dtoa_r+0xb78>
800099f4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
800099f8:	c0 d1       	brne	80009a12 <_dtoa_r+0xb62>
800099fa:	c1 78       	rjmp	80009a28 <_dtoa_r+0xb78>
800099fc:	40 89       	lddsp	r9,sp[0x20]
800099fe:	12 38       	cp.w	r8,r9
80009a00:	c0 30       	breq	80009a06 <_dtoa_r+0xb56>
80009a02:	10 95       	mov	r5,r8
80009a04:	c0 88       	rjmp	80009a14 <_dtoa_r+0xb64>
80009a06:	2f f6       	sub	r6,-1
80009a08:	50 66       	stdsp	sp[0x18],r6
80009a0a:	33 18       	mov	r8,49
80009a0c:	40 8c       	lddsp	r12,sp[0x20]
80009a0e:	b8 88       	st.b	r12[0x0],r8
80009a10:	c1 38       	rjmp	80009a36 <_dtoa_r+0xb86>
80009a12:	33 9a       	mov	r10,57
80009a14:	0a 98       	mov	r8,r5
80009a16:	11 79       	ld.ub	r9,--r8
80009a18:	f4 09 18 00 	cp.b	r9,r10
80009a1c:	cf 00       	breq	800099fc <_dtoa_r+0xb4c>
80009a1e:	2f f9       	sub	r9,-1
80009a20:	b0 89       	st.b	r8[0x0],r9
80009a22:	c0 98       	rjmp	80009a34 <_dtoa_r+0xb84>
80009a24:	10 95       	mov	r5,r8
80009a26:	c0 28       	rjmp	80009a2a <_dtoa_r+0xb7a>
80009a28:	33 09       	mov	r9,48
80009a2a:	0a 98       	mov	r8,r5
80009a2c:	11 7a       	ld.ub	r10,--r8
80009a2e:	f2 0a 18 00 	cp.b	r10,r9
80009a32:	cf 90       	breq	80009a24 <_dtoa_r+0xb74>
80009a34:	50 66       	stdsp	sp[0x18],r6
80009a36:	04 9b       	mov	r11,r2
80009a38:	0e 9c       	mov	r12,r7
80009a3a:	e0 a0 04 f3 	rcall	8000a420 <_Bfree>
80009a3e:	58 04       	cp.w	r4,0
80009a40:	c1 20       	breq	80009a64 <_dtoa_r+0xbb4>
80009a42:	40 4b       	lddsp	r11,sp[0x10]
80009a44:	08 3b       	cp.w	r11,r4
80009a46:	5f 19       	srne	r9
80009a48:	58 0b       	cp.w	r11,0
80009a4a:	5f 18       	srne	r8
80009a4c:	f3 e8 00 08 	and	r8,r9,r8
80009a50:	c0 40       	breq	80009a58 <_dtoa_r+0xba8>
80009a52:	0e 9c       	mov	r12,r7
80009a54:	e0 a0 04 e6 	rcall	8000a420 <_Bfree>
80009a58:	08 9b       	mov	r11,r4
80009a5a:	0e 9c       	mov	r12,r7
80009a5c:	e0 a0 04 e2 	rcall	8000a420 <_Bfree>
80009a60:	c0 28       	rjmp	80009a64 <_dtoa_r+0xbb4>
80009a62:	50 66       	stdsp	sp[0x18],r6
80009a64:	0e 9c       	mov	r12,r7
80009a66:	06 9b       	mov	r11,r3
80009a68:	e0 a0 04 dc 	rcall	8000a420 <_Bfree>
80009a6c:	30 08       	mov	r8,0
80009a6e:	aa 88       	st.b	r5[0x0],r8
80009a70:	40 68       	lddsp	r8,sp[0x18]
80009a72:	41 5a       	lddsp	r10,sp[0x54]
80009a74:	2f f8       	sub	r8,-1
80009a76:	41 29       	lddsp	r9,sp[0x48]
80009a78:	95 08       	st.w	r10[0x0],r8
80009a7a:	40 8c       	lddsp	r12,sp[0x20]
80009a7c:	58 09       	cp.w	r9,0
80009a7e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009a82:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009a86:	2e 6d       	sub	sp,-104
80009a88:	d8 32       	popm	r0-r7,pc
80009a8a:	d7 03       	nop

80009a8c <__errno>:
80009a8c:	e0 68 0a 2c 	mov	r8,2604
80009a90:	70 0c       	ld.w	r12,r8[0x0]
80009a92:	2f 4c       	sub	r12,-12
80009a94:	5e fc       	retal	r12
80009a96:	d7 03       	nop

80009a98 <_fflush_r>:
80009a98:	d4 21       	pushm	r4-r7,lr
80009a9a:	16 97       	mov	r7,r11
80009a9c:	18 96       	mov	r6,r12
80009a9e:	76 48       	ld.w	r8,r11[0x10]
80009aa0:	58 08       	cp.w	r8,0
80009aa2:	c7 f0       	breq	80009ba0 <_fflush_r+0x108>
80009aa4:	58 0c       	cp.w	r12,0
80009aa6:	c0 50       	breq	80009ab0 <_fflush_r+0x18>
80009aa8:	78 68       	ld.w	r8,r12[0x18]
80009aaa:	58 08       	cp.w	r8,0
80009aac:	c0 21       	brne	80009ab0 <_fflush_r+0x18>
80009aae:	cc dc       	rcall	80009c48 <__sinit>
80009ab0:	fe c8 cf c0 	sub	r8,pc,-12352
80009ab4:	10 37       	cp.w	r7,r8
80009ab6:	c0 31       	brne	80009abc <_fflush_r+0x24>
80009ab8:	6c 07       	ld.w	r7,r6[0x0]
80009aba:	c0 c8       	rjmp	80009ad2 <_fflush_r+0x3a>
80009abc:	fe c8 cf ac 	sub	r8,pc,-12372
80009ac0:	10 37       	cp.w	r7,r8
80009ac2:	c0 31       	brne	80009ac8 <_fflush_r+0x30>
80009ac4:	6c 17       	ld.w	r7,r6[0x4]
80009ac6:	c0 68       	rjmp	80009ad2 <_fflush_r+0x3a>
80009ac8:	fe c8 cf 98 	sub	r8,pc,-12392
80009acc:	10 37       	cp.w	r7,r8
80009ace:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009ad2:	8e 6a       	ld.sh	r10,r7[0xc]
80009ad4:	14 98       	mov	r8,r10
80009ad6:	ed ba 00 03 	bld	r10,0x3
80009ada:	c4 20       	breq	80009b5e <_fflush_r+0xc6>
80009adc:	ab ba       	sbr	r10,0xb
80009ade:	ae 6a       	st.h	r7[0xc],r10
80009ae0:	6e 18       	ld.w	r8,r7[0x4]
80009ae2:	58 08       	cp.w	r8,0
80009ae4:	e0 89 00 06 	brgt	80009af0 <_fflush_r+0x58>
80009ae8:	6f 08       	ld.w	r8,r7[0x40]
80009aea:	58 08       	cp.w	r8,0
80009aec:	e0 8a 00 5a 	brle	80009ba0 <_fflush_r+0x108>
80009af0:	6e b8       	ld.w	r8,r7[0x2c]
80009af2:	58 08       	cp.w	r8,0
80009af4:	c5 60       	breq	80009ba0 <_fflush_r+0x108>
80009af6:	e2 1a 10 00 	andl	r10,0x1000,COH
80009afa:	c0 30       	breq	80009b00 <_fflush_r+0x68>
80009afc:	6f 55       	ld.w	r5,r7[0x54]
80009afe:	c0 f8       	rjmp	80009b1c <_fflush_r+0x84>
80009b00:	30 19       	mov	r9,1
80009b02:	6e 8b       	ld.w	r11,r7[0x20]
80009b04:	0c 9c       	mov	r12,r6
80009b06:	5d 18       	icall	r8
80009b08:	18 95       	mov	r5,r12
80009b0a:	5b fc       	cp.w	r12,-1
80009b0c:	c0 81       	brne	80009b1c <_fflush_r+0x84>
80009b0e:	6c 38       	ld.w	r8,r6[0xc]
80009b10:	59 d8       	cp.w	r8,29
80009b12:	c4 70       	breq	80009ba0 <_fflush_r+0x108>
80009b14:	8e 68       	ld.sh	r8,r7[0xc]
80009b16:	a7 a8       	sbr	r8,0x6
80009b18:	ae 68       	st.h	r7[0xc],r8
80009b1a:	d8 22       	popm	r4-r7,pc
80009b1c:	8e 68       	ld.sh	r8,r7[0xc]
80009b1e:	ed b8 00 02 	bld	r8,0x2
80009b22:	c0 91       	brne	80009b34 <_fflush_r+0x9c>
80009b24:	6e 18       	ld.w	r8,r7[0x4]
80009b26:	10 15       	sub	r5,r8
80009b28:	6e d8       	ld.w	r8,r7[0x34]
80009b2a:	58 08       	cp.w	r8,0
80009b2c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009b30:	eb d8 e1 15 	subne	r5,r5,r8
80009b34:	6e b8       	ld.w	r8,r7[0x2c]
80009b36:	0c 9c       	mov	r12,r6
80009b38:	30 09       	mov	r9,0
80009b3a:	0a 9a       	mov	r10,r5
80009b3c:	6e 8b       	ld.w	r11,r7[0x20]
80009b3e:	5d 18       	icall	r8
80009b40:	8e 68       	ld.sh	r8,r7[0xc]
80009b42:	0a 3c       	cp.w	r12,r5
80009b44:	c2 61       	brne	80009b90 <_fflush_r+0xf8>
80009b46:	ab d8       	cbr	r8,0xb
80009b48:	30 0c       	mov	r12,0
80009b4a:	6e 49       	ld.w	r9,r7[0x10]
80009b4c:	ae 68       	st.h	r7[0xc],r8
80009b4e:	8f 1c       	st.w	r7[0x4],r12
80009b50:	8f 09       	st.w	r7[0x0],r9
80009b52:	ed b8 00 0c 	bld	r8,0xc
80009b56:	c2 51       	brne	80009ba0 <_fflush_r+0x108>
80009b58:	ef 45 00 54 	st.w	r7[84],r5
80009b5c:	d8 22       	popm	r4-r7,pc
80009b5e:	6e 45       	ld.w	r5,r7[0x10]
80009b60:	58 05       	cp.w	r5,0
80009b62:	c1 f0       	breq	80009ba0 <_fflush_r+0x108>
80009b64:	6e 04       	ld.w	r4,r7[0x0]
80009b66:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009b6a:	8f 05       	st.w	r7[0x0],r5
80009b6c:	f9 b8 01 00 	movne	r8,0
80009b70:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009b74:	0a 14       	sub	r4,r5
80009b76:	8f 28       	st.w	r7[0x8],r8
80009b78:	c1 18       	rjmp	80009b9a <_fflush_r+0x102>
80009b7a:	08 99       	mov	r9,r4
80009b7c:	0a 9a       	mov	r10,r5
80009b7e:	6e a8       	ld.w	r8,r7[0x28]
80009b80:	6e 8b       	ld.w	r11,r7[0x20]
80009b82:	0c 9c       	mov	r12,r6
80009b84:	5d 18       	icall	r8
80009b86:	18 14       	sub	r4,r12
80009b88:	58 0c       	cp.w	r12,0
80009b8a:	e0 89 00 07 	brgt	80009b98 <_fflush_r+0x100>
80009b8e:	8e 68       	ld.sh	r8,r7[0xc]
80009b90:	a7 a8       	sbr	r8,0x6
80009b92:	3f fc       	mov	r12,-1
80009b94:	ae 68       	st.h	r7[0xc],r8
80009b96:	d8 22       	popm	r4-r7,pc
80009b98:	18 05       	add	r5,r12
80009b9a:	58 04       	cp.w	r4,0
80009b9c:	fe 99 ff ef 	brgt	80009b7a <_fflush_r+0xe2>
80009ba0:	d8 2a       	popm	r4-r7,pc,r12=0
80009ba2:	d7 03       	nop

80009ba4 <__sfp_lock_acquire>:
80009ba4:	5e fc       	retal	r12

80009ba6 <__sfp_lock_release>:
80009ba6:	5e fc       	retal	r12

80009ba8 <_cleanup_r>:
80009ba8:	d4 01       	pushm	lr
80009baa:	fe cb f0 ae 	sub	r11,pc,-3922
80009bae:	e0 a0 02 f7 	rcall	8000a19c <_fwalk>
80009bb2:	d8 02       	popm	pc

80009bb4 <__sfmoreglue>:
80009bb4:	d4 21       	pushm	r4-r7,lr
80009bb6:	16 95       	mov	r5,r11
80009bb8:	f6 06 10 5c 	mul	r6,r11,92
80009bbc:	ec cb ff f4 	sub	r11,r6,-12
80009bc0:	fe b0 e2 88 	rcall	800060d0 <_malloc_r>
80009bc4:	18 97       	mov	r7,r12
80009bc6:	c0 90       	breq	80009bd8 <__sfmoreglue+0x24>
80009bc8:	99 15       	st.w	r12[0x4],r5
80009bca:	30 0b       	mov	r11,0
80009bcc:	2f 4c       	sub	r12,-12
80009bce:	0c 9a       	mov	r10,r6
80009bd0:	8f 2c       	st.w	r7[0x8],r12
80009bd2:	8f 0b       	st.w	r7[0x0],r11
80009bd4:	fe b0 e5 3e 	rcall	80006650 <memset>
80009bd8:	0e 9c       	mov	r12,r7
80009bda:	d8 22       	popm	r4-r7,pc

80009bdc <__sfp>:
80009bdc:	d4 21       	pushm	r4-r7,lr
80009bde:	fe c8 d0 8a 	sub	r8,pc,-12150
80009be2:	18 96       	mov	r6,r12
80009be4:	70 07       	ld.w	r7,r8[0x0]
80009be6:	6e 68       	ld.w	r8,r7[0x18]
80009be8:	58 08       	cp.w	r8,0
80009bea:	c0 31       	brne	80009bf0 <__sfp+0x14>
80009bec:	0e 9c       	mov	r12,r7
80009bee:	c2 dc       	rcall	80009c48 <__sinit>
80009bf0:	ee c7 ff 28 	sub	r7,r7,-216
80009bf4:	30 05       	mov	r5,0
80009bf6:	6e 2c       	ld.w	r12,r7[0x8]
80009bf8:	6e 18       	ld.w	r8,r7[0x4]
80009bfa:	c0 68       	rjmp	80009c06 <__sfp+0x2a>
80009bfc:	98 69       	ld.sh	r9,r12[0xc]
80009bfe:	ea 09 19 00 	cp.h	r9,r5
80009c02:	c1 10       	breq	80009c24 <__sfp+0x48>
80009c04:	2a 4c       	sub	r12,-92
80009c06:	20 18       	sub	r8,1
80009c08:	cf a7       	brpl	80009bfc <__sfp+0x20>
80009c0a:	6e 08       	ld.w	r8,r7[0x0]
80009c0c:	58 08       	cp.w	r8,0
80009c0e:	c0 61       	brne	80009c1a <__sfp+0x3e>
80009c10:	30 4b       	mov	r11,4
80009c12:	0c 9c       	mov	r12,r6
80009c14:	cd 0f       	rcall	80009bb4 <__sfmoreglue>
80009c16:	8f 0c       	st.w	r7[0x0],r12
80009c18:	c0 30       	breq	80009c1e <__sfp+0x42>
80009c1a:	6e 07       	ld.w	r7,r7[0x0]
80009c1c:	ce db       	rjmp	80009bf6 <__sfp+0x1a>
80009c1e:	30 c8       	mov	r8,12
80009c20:	8d 38       	st.w	r6[0xc],r8
80009c22:	d8 22       	popm	r4-r7,pc
80009c24:	30 08       	mov	r8,0
80009c26:	f9 48 00 4c 	st.w	r12[76],r8
80009c2a:	99 08       	st.w	r12[0x0],r8
80009c2c:	99 28       	st.w	r12[0x8],r8
80009c2e:	99 18       	st.w	r12[0x4],r8
80009c30:	99 48       	st.w	r12[0x10],r8
80009c32:	99 58       	st.w	r12[0x14],r8
80009c34:	99 68       	st.w	r12[0x18],r8
80009c36:	99 d8       	st.w	r12[0x34],r8
80009c38:	99 e8       	st.w	r12[0x38],r8
80009c3a:	f9 48 00 48 	st.w	r12[72],r8
80009c3e:	3f f8       	mov	r8,-1
80009c40:	b8 78       	st.h	r12[0xe],r8
80009c42:	30 18       	mov	r8,1
80009c44:	b8 68       	st.h	r12[0xc],r8
80009c46:	d8 22       	popm	r4-r7,pc

80009c48 <__sinit>:
80009c48:	d4 21       	pushm	r4-r7,lr
80009c4a:	18 96       	mov	r6,r12
80009c4c:	78 67       	ld.w	r7,r12[0x18]
80009c4e:	58 07       	cp.w	r7,0
80009c50:	c4 91       	brne	80009ce2 <__sinit+0x9a>
80009c52:	fe c8 00 aa 	sub	r8,pc,170
80009c56:	30 15       	mov	r5,1
80009c58:	99 a8       	st.w	r12[0x28],r8
80009c5a:	f9 47 00 d8 	st.w	r12[216],r7
80009c5e:	f9 47 00 dc 	st.w	r12[220],r7
80009c62:	f9 47 00 e0 	st.w	r12[224],r7
80009c66:	99 65       	st.w	r12[0x18],r5
80009c68:	cb af       	rcall	80009bdc <__sfp>
80009c6a:	8d 0c       	st.w	r6[0x0],r12
80009c6c:	0c 9c       	mov	r12,r6
80009c6e:	cb 7f       	rcall	80009bdc <__sfp>
80009c70:	8d 1c       	st.w	r6[0x4],r12
80009c72:	0c 9c       	mov	r12,r6
80009c74:	cb 4f       	rcall	80009bdc <__sfp>
80009c76:	6c 09       	ld.w	r9,r6[0x0]
80009c78:	30 48       	mov	r8,4
80009c7a:	93 07       	st.w	r9[0x0],r7
80009c7c:	b2 68       	st.h	r9[0xc],r8
80009c7e:	93 17       	st.w	r9[0x4],r7
80009c80:	93 27       	st.w	r9[0x8],r7
80009c82:	6c 18       	ld.w	r8,r6[0x4]
80009c84:	b2 77       	st.h	r9[0xe],r7
80009c86:	93 47       	st.w	r9[0x10],r7
80009c88:	93 57       	st.w	r9[0x14],r7
80009c8a:	93 67       	st.w	r9[0x18],r7
80009c8c:	93 89       	st.w	r9[0x20],r9
80009c8e:	91 07       	st.w	r8[0x0],r7
80009c90:	91 17       	st.w	r8[0x4],r7
80009c92:	91 27       	st.w	r8[0x8],r7
80009c94:	fe ce f3 24 	sub	lr,pc,-3292
80009c98:	fe cb f3 54 	sub	r11,pc,-3244
80009c9c:	93 9e       	st.w	r9[0x24],lr
80009c9e:	93 ab       	st.w	r9[0x28],r11
80009ca0:	fe ca f3 7c 	sub	r10,pc,-3204
80009ca4:	fe c4 f3 88 	sub	r4,pc,-3192
80009ca8:	93 ba       	st.w	r9[0x2c],r10
80009caa:	93 c4       	st.w	r9[0x30],r4
80009cac:	30 99       	mov	r9,9
80009cae:	b0 69       	st.h	r8[0xc],r9
80009cb0:	b0 75       	st.h	r8[0xe],r5
80009cb2:	91 c4       	st.w	r8[0x30],r4
80009cb4:	91 47       	st.w	r8[0x10],r7
80009cb6:	91 57       	st.w	r8[0x14],r7
80009cb8:	91 67       	st.w	r8[0x18],r7
80009cba:	91 88       	st.w	r8[0x20],r8
80009cbc:	91 9e       	st.w	r8[0x24],lr
80009cbe:	91 ab       	st.w	r8[0x28],r11
80009cc0:	91 ba       	st.w	r8[0x2c],r10
80009cc2:	8d 2c       	st.w	r6[0x8],r12
80009cc4:	31 28       	mov	r8,18
80009cc6:	99 07       	st.w	r12[0x0],r7
80009cc8:	b8 68       	st.h	r12[0xc],r8
80009cca:	99 17       	st.w	r12[0x4],r7
80009ccc:	99 27       	st.w	r12[0x8],r7
80009cce:	30 28       	mov	r8,2
80009cd0:	b8 78       	st.h	r12[0xe],r8
80009cd2:	99 c4       	st.w	r12[0x30],r4
80009cd4:	99 67       	st.w	r12[0x18],r7
80009cd6:	99 9e       	st.w	r12[0x24],lr
80009cd8:	99 ab       	st.w	r12[0x28],r11
80009cda:	99 ba       	st.w	r12[0x2c],r10
80009cdc:	99 47       	st.w	r12[0x10],r7
80009cde:	99 57       	st.w	r12[0x14],r7
80009ce0:	99 8c       	st.w	r12[0x20],r12
80009ce2:	d8 22       	popm	r4-r7,pc

80009ce4 <_malloc_trim_r>:
80009ce4:	d4 21       	pushm	r4-r7,lr
80009ce6:	16 95       	mov	r5,r11
80009ce8:	18 97       	mov	r7,r12
80009cea:	fe b0 d8 03 	rcall	80004cf0 <__malloc_lock>
80009cee:	e0 64 05 2c 	mov	r4,1324
80009cf2:	68 28       	ld.w	r8,r4[0x8]
80009cf4:	70 16       	ld.w	r6,r8[0x4]
80009cf6:	e0 16 ff fc 	andl	r6,0xfffc
80009cfa:	ec c8 ff 91 	sub	r8,r6,-111
80009cfe:	f0 05 01 05 	sub	r5,r8,r5
80009d02:	e0 15 ff 80 	andl	r5,0xff80
80009d06:	ea c5 00 80 	sub	r5,r5,128
80009d0a:	e0 45 00 7f 	cp.w	r5,127
80009d0e:	e0 8a 00 25 	brle	80009d58 <_malloc_trim_r+0x74>
80009d12:	30 0b       	mov	r11,0
80009d14:	0e 9c       	mov	r12,r7
80009d16:	fe b0 e6 05 	rcall	80006920 <_sbrk_r>
80009d1a:	68 28       	ld.w	r8,r4[0x8]
80009d1c:	0c 08       	add	r8,r6
80009d1e:	10 3c       	cp.w	r12,r8
80009d20:	c1 c1       	brne	80009d58 <_malloc_trim_r+0x74>
80009d22:	ea 0b 11 00 	rsub	r11,r5,0
80009d26:	0e 9c       	mov	r12,r7
80009d28:	fe b0 e5 fc 	rcall	80006920 <_sbrk_r>
80009d2c:	5b fc       	cp.w	r12,-1
80009d2e:	c1 91       	brne	80009d60 <_malloc_trim_r+0x7c>
80009d30:	30 0b       	mov	r11,0
80009d32:	0e 9c       	mov	r12,r7
80009d34:	fe b0 e5 f6 	rcall	80006920 <_sbrk_r>
80009d38:	68 28       	ld.w	r8,r4[0x8]
80009d3a:	f8 08 01 09 	sub	r9,r12,r8
80009d3e:	58 f9       	cp.w	r9,15
80009d40:	e0 8a 00 0c 	brle	80009d58 <_malloc_trim_r+0x74>
80009d44:	a1 a9       	sbr	r9,0x0
80009d46:	91 19       	st.w	r8[0x4],r9
80009d48:	e0 68 09 38 	mov	r8,2360
80009d4c:	70 09       	ld.w	r9,r8[0x0]
80009d4e:	e0 68 0d 38 	mov	r8,3384
80009d52:	f8 09 01 09 	sub	r9,r12,r9
80009d56:	91 09       	st.w	r8[0x0],r9
80009d58:	0e 9c       	mov	r12,r7
80009d5a:	fe b0 d7 d1 	rcall	80004cfc <__malloc_unlock>
80009d5e:	d8 2a       	popm	r4-r7,pc,r12=0
80009d60:	68 28       	ld.w	r8,r4[0x8]
80009d62:	0a 16       	sub	r6,r5
80009d64:	a1 a6       	sbr	r6,0x0
80009d66:	91 16       	st.w	r8[0x4],r6
80009d68:	e0 68 0d 38 	mov	r8,3384
80009d6c:	70 09       	ld.w	r9,r8[0x0]
80009d6e:	0a 19       	sub	r9,r5
80009d70:	0e 9c       	mov	r12,r7
80009d72:	91 09       	st.w	r8[0x0],r9
80009d74:	fe b0 d7 c4 	rcall	80004cfc <__malloc_unlock>
80009d78:	da 2a       	popm	r4-r7,pc,r12=1
80009d7a:	d7 03       	nop

80009d7c <_free_r>:
80009d7c:	d4 21       	pushm	r4-r7,lr
80009d7e:	16 96       	mov	r6,r11
80009d80:	18 97       	mov	r7,r12
80009d82:	58 0b       	cp.w	r11,0
80009d84:	e0 80 00 c0 	breq	80009f04 <_free_r+0x188>
80009d88:	fe b0 d7 b4 	rcall	80004cf0 <__malloc_lock>
80009d8c:	20 86       	sub	r6,8
80009d8e:	e0 6a 05 2c 	mov	r10,1324
80009d92:	6c 18       	ld.w	r8,r6[0x4]
80009d94:	74 2e       	ld.w	lr,r10[0x8]
80009d96:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009d9a:	a1 c8       	cbr	r8,0x0
80009d9c:	ec 08 00 09 	add	r9,r6,r8
80009da0:	72 1b       	ld.w	r11,r9[0x4]
80009da2:	e0 1b ff fc 	andl	r11,0xfffc
80009da6:	1c 39       	cp.w	r9,lr
80009da8:	c1 e1       	brne	80009de4 <_free_r+0x68>
80009daa:	f6 08 00 08 	add	r8,r11,r8
80009dae:	58 0c       	cp.w	r12,0
80009db0:	c0 81       	brne	80009dc0 <_free_r+0x44>
80009db2:	6c 09       	ld.w	r9,r6[0x0]
80009db4:	12 16       	sub	r6,r9
80009db6:	12 08       	add	r8,r9
80009db8:	6c 3b       	ld.w	r11,r6[0xc]
80009dba:	6c 29       	ld.w	r9,r6[0x8]
80009dbc:	97 29       	st.w	r11[0x8],r9
80009dbe:	93 3b       	st.w	r9[0xc],r11
80009dc0:	10 99       	mov	r9,r8
80009dc2:	95 26       	st.w	r10[0x8],r6
80009dc4:	a1 a9       	sbr	r9,0x0
80009dc6:	8d 19       	st.w	r6[0x4],r9
80009dc8:	e0 69 09 34 	mov	r9,2356
80009dcc:	72 09       	ld.w	r9,r9[0x0]
80009dce:	12 38       	cp.w	r8,r9
80009dd0:	c0 63       	brcs	80009ddc <_free_r+0x60>
80009dd2:	e0 68 0d 34 	mov	r8,3380
80009dd6:	0e 9c       	mov	r12,r7
80009dd8:	70 0b       	ld.w	r11,r8[0x0]
80009dda:	c8 5f       	rcall	80009ce4 <_malloc_trim_r>
80009ddc:	0e 9c       	mov	r12,r7
80009dde:	fe b0 d7 8f 	rcall	80004cfc <__malloc_unlock>
80009de2:	d8 22       	popm	r4-r7,pc
80009de4:	93 1b       	st.w	r9[0x4],r11
80009de6:	58 0c       	cp.w	r12,0
80009de8:	c0 30       	breq	80009dee <_free_r+0x72>
80009dea:	30 0c       	mov	r12,0
80009dec:	c1 08       	rjmp	80009e0c <_free_r+0x90>
80009dee:	6c 0e       	ld.w	lr,r6[0x0]
80009df0:	f4 c5 ff f8 	sub	r5,r10,-8
80009df4:	1c 16       	sub	r6,lr
80009df6:	1c 08       	add	r8,lr
80009df8:	6c 2e       	ld.w	lr,r6[0x8]
80009dfa:	0a 3e       	cp.w	lr,r5
80009dfc:	f9 bc 00 01 	moveq	r12,1
80009e00:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009e04:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009e08:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009e0c:	f2 0b 00 0e 	add	lr,r9,r11
80009e10:	7c 1e       	ld.w	lr,lr[0x4]
80009e12:	ed be 00 00 	bld	lr,0x0
80009e16:	c1 40       	breq	80009e3e <_free_r+0xc2>
80009e18:	16 08       	add	r8,r11
80009e1a:	58 0c       	cp.w	r12,0
80009e1c:	c0 d1       	brne	80009e36 <_free_r+0xba>
80009e1e:	e0 6e 05 2c 	mov	lr,1324
80009e22:	72 2b       	ld.w	r11,r9[0x8]
80009e24:	2f 8e       	sub	lr,-8
80009e26:	1c 3b       	cp.w	r11,lr
80009e28:	c0 71       	brne	80009e36 <_free_r+0xba>
80009e2a:	97 36       	st.w	r11[0xc],r6
80009e2c:	97 26       	st.w	r11[0x8],r6
80009e2e:	8d 2b       	st.w	r6[0x8],r11
80009e30:	8d 3b       	st.w	r6[0xc],r11
80009e32:	30 1c       	mov	r12,1
80009e34:	c0 58       	rjmp	80009e3e <_free_r+0xc2>
80009e36:	72 2b       	ld.w	r11,r9[0x8]
80009e38:	72 39       	ld.w	r9,r9[0xc]
80009e3a:	93 2b       	st.w	r9[0x8],r11
80009e3c:	97 39       	st.w	r11[0xc],r9
80009e3e:	10 99       	mov	r9,r8
80009e40:	ec 08 09 08 	st.w	r6[r8],r8
80009e44:	a1 a9       	sbr	r9,0x0
80009e46:	8d 19       	st.w	r6[0x4],r9
80009e48:	58 0c       	cp.w	r12,0
80009e4a:	c5 a1       	brne	80009efe <_free_r+0x182>
80009e4c:	e0 48 01 ff 	cp.w	r8,511
80009e50:	e0 8b 00 13 	brhi	80009e76 <_free_r+0xfa>
80009e54:	a3 98       	lsr	r8,0x3
80009e56:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009e5a:	72 2b       	ld.w	r11,r9[0x8]
80009e5c:	8d 39       	st.w	r6[0xc],r9
80009e5e:	8d 2b       	st.w	r6[0x8],r11
80009e60:	97 36       	st.w	r11[0xc],r6
80009e62:	93 26       	st.w	r9[0x8],r6
80009e64:	a3 48       	asr	r8,0x2
80009e66:	74 19       	ld.w	r9,r10[0x4]
80009e68:	30 1b       	mov	r11,1
80009e6a:	f6 08 09 48 	lsl	r8,r11,r8
80009e6e:	f3 e8 10 08 	or	r8,r9,r8
80009e72:	95 18       	st.w	r10[0x4],r8
80009e74:	c4 58       	rjmp	80009efe <_free_r+0x182>
80009e76:	f0 0b 16 09 	lsr	r11,r8,0x9
80009e7a:	58 4b       	cp.w	r11,4
80009e7c:	e0 8b 00 06 	brhi	80009e88 <_free_r+0x10c>
80009e80:	f0 0b 16 06 	lsr	r11,r8,0x6
80009e84:	2c 8b       	sub	r11,-56
80009e86:	c2 08       	rjmp	80009ec6 <_free_r+0x14a>
80009e88:	59 4b       	cp.w	r11,20
80009e8a:	e0 8b 00 04 	brhi	80009e92 <_free_r+0x116>
80009e8e:	2a 5b       	sub	r11,-91
80009e90:	c1 b8       	rjmp	80009ec6 <_free_r+0x14a>
80009e92:	e0 4b 00 54 	cp.w	r11,84
80009e96:	e0 8b 00 06 	brhi	80009ea2 <_free_r+0x126>
80009e9a:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009e9e:	29 2b       	sub	r11,-110
80009ea0:	c1 38       	rjmp	80009ec6 <_free_r+0x14a>
80009ea2:	e0 4b 01 54 	cp.w	r11,340
80009ea6:	e0 8b 00 06 	brhi	80009eb2 <_free_r+0x136>
80009eaa:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009eae:	28 9b       	sub	r11,-119
80009eb0:	c0 b8       	rjmp	80009ec6 <_free_r+0x14a>
80009eb2:	e0 4b 05 54 	cp.w	r11,1364
80009eb6:	e0 88 00 05 	brls	80009ec0 <_free_r+0x144>
80009eba:	37 eb       	mov	r11,126
80009ebc:	c0 58       	rjmp	80009ec6 <_free_r+0x14a>
80009ebe:	d7 03       	nop
80009ec0:	f0 0b 16 12 	lsr	r11,r8,0x12
80009ec4:	28 4b       	sub	r11,-124
80009ec6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009eca:	78 29       	ld.w	r9,r12[0x8]
80009ecc:	18 39       	cp.w	r9,r12
80009ece:	c0 e1       	brne	80009eea <_free_r+0x16e>
80009ed0:	74 18       	ld.w	r8,r10[0x4]
80009ed2:	a3 4b       	asr	r11,0x2
80009ed4:	30 1c       	mov	r12,1
80009ed6:	f8 0b 09 4b 	lsl	r11,r12,r11
80009eda:	f1 eb 10 0b 	or	r11,r8,r11
80009ede:	12 98       	mov	r8,r9
80009ee0:	95 1b       	st.w	r10[0x4],r11
80009ee2:	c0 a8       	rjmp	80009ef6 <_free_r+0x17a>
80009ee4:	72 29       	ld.w	r9,r9[0x8]
80009ee6:	18 39       	cp.w	r9,r12
80009ee8:	c0 60       	breq	80009ef4 <_free_r+0x178>
80009eea:	72 1a       	ld.w	r10,r9[0x4]
80009eec:	e0 1a ff fc 	andl	r10,0xfffc
80009ef0:	14 38       	cp.w	r8,r10
80009ef2:	cf 93       	brcs	80009ee4 <_free_r+0x168>
80009ef4:	72 38       	ld.w	r8,r9[0xc]
80009ef6:	8d 38       	st.w	r6[0xc],r8
80009ef8:	8d 29       	st.w	r6[0x8],r9
80009efa:	93 36       	st.w	r9[0xc],r6
80009efc:	91 26       	st.w	r8[0x8],r6
80009efe:	0e 9c       	mov	r12,r7
80009f00:	fe b0 d6 fe 	rcall	80004cfc <__malloc_unlock>
80009f04:	d8 22       	popm	r4-r7,pc
80009f06:	d7 03       	nop

80009f08 <__sfvwrite_r>:
80009f08:	d4 31       	pushm	r0-r7,lr
80009f0a:	20 3d       	sub	sp,12
80009f0c:	14 94       	mov	r4,r10
80009f0e:	18 95       	mov	r5,r12
80009f10:	16 97       	mov	r7,r11
80009f12:	74 28       	ld.w	r8,r10[0x8]
80009f14:	58 08       	cp.w	r8,0
80009f16:	e0 80 01 40 	breq	8000a196 <__sfvwrite_r+0x28e>
80009f1a:	96 68       	ld.sh	r8,r11[0xc]
80009f1c:	ed b8 00 03 	bld	r8,0x3
80009f20:	c0 41       	brne	80009f28 <__sfvwrite_r+0x20>
80009f22:	76 48       	ld.w	r8,r11[0x10]
80009f24:	58 08       	cp.w	r8,0
80009f26:	c0 c1       	brne	80009f3e <__sfvwrite_r+0x36>
80009f28:	0e 9b       	mov	r11,r7
80009f2a:	0a 9c       	mov	r12,r5
80009f2c:	fe b0 f6 c4 	rcall	80008cb4 <__swsetup_r>
80009f30:	c0 70       	breq	80009f3e <__sfvwrite_r+0x36>
80009f32:	8e 68       	ld.sh	r8,r7[0xc]
80009f34:	a7 a8       	sbr	r8,0x6
80009f36:	ae 68       	st.h	r7[0xc],r8
80009f38:	30 98       	mov	r8,9
80009f3a:	8b 38       	st.w	r5[0xc],r8
80009f3c:	c2 b9       	rjmp	8000a192 <__sfvwrite_r+0x28a>
80009f3e:	8e 63       	ld.sh	r3,r7[0xc]
80009f40:	68 00       	ld.w	r0,r4[0x0]
80009f42:	06 96       	mov	r6,r3
80009f44:	e2 16 00 02 	andl	r6,0x2,COH
80009f48:	c2 10       	breq	80009f8a <__sfvwrite_r+0x82>
80009f4a:	30 03       	mov	r3,0
80009f4c:	e0 62 04 00 	mov	r2,1024
80009f50:	06 96       	mov	r6,r3
80009f52:	c0 48       	rjmp	80009f5a <__sfvwrite_r+0x52>
80009f54:	60 03       	ld.w	r3,r0[0x0]
80009f56:	60 16       	ld.w	r6,r0[0x4]
80009f58:	2f 80       	sub	r0,-8
80009f5a:	58 06       	cp.w	r6,0
80009f5c:	cf c0       	breq	80009f54 <__sfvwrite_r+0x4c>
80009f5e:	e0 46 04 00 	cp.w	r6,1024
80009f62:	ec 09 17 80 	movls	r9,r6
80009f66:	e4 09 17 b0 	movhi	r9,r2
80009f6a:	06 9a       	mov	r10,r3
80009f6c:	6e a8       	ld.w	r8,r7[0x28]
80009f6e:	6e 8b       	ld.w	r11,r7[0x20]
80009f70:	0a 9c       	mov	r12,r5
80009f72:	5d 18       	icall	r8
80009f74:	18 16       	sub	r6,r12
80009f76:	58 0c       	cp.w	r12,0
80009f78:	e0 8a 01 0a 	brle	8000a18c <__sfvwrite_r+0x284>
80009f7c:	68 28       	ld.w	r8,r4[0x8]
80009f7e:	18 18       	sub	r8,r12
80009f80:	89 28       	st.w	r4[0x8],r8
80009f82:	e0 80 01 0a 	breq	8000a196 <__sfvwrite_r+0x28e>
80009f86:	18 03       	add	r3,r12
80009f88:	ce 9b       	rjmp	80009f5a <__sfvwrite_r+0x52>
80009f8a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009f8e:	c0 70       	breq	80009f9c <__sfvwrite_r+0x94>
80009f90:	50 06       	stdsp	sp[0x0],r6
80009f92:	0c 93       	mov	r3,r6
80009f94:	0c 91       	mov	r1,r6
80009f96:	50 15       	stdsp	sp[0x4],r5
80009f98:	08 92       	mov	r2,r4
80009f9a:	c9 c8       	rjmp	8000a0d2 <__sfvwrite_r+0x1ca>
80009f9c:	06 96       	mov	r6,r3
80009f9e:	08 91       	mov	r1,r4
80009fa0:	c0 48       	rjmp	80009fa8 <__sfvwrite_r+0xa0>
80009fa2:	60 03       	ld.w	r3,r0[0x0]
80009fa4:	60 16       	ld.w	r6,r0[0x4]
80009fa6:	2f 80       	sub	r0,-8
80009fa8:	58 06       	cp.w	r6,0
80009faa:	cf c0       	breq	80009fa2 <__sfvwrite_r+0x9a>
80009fac:	8e 68       	ld.sh	r8,r7[0xc]
80009fae:	6e 24       	ld.w	r4,r7[0x8]
80009fb0:	10 99       	mov	r9,r8
80009fb2:	e2 19 02 00 	andl	r9,0x200,COH
80009fb6:	c5 50       	breq	8000a060 <__sfvwrite_r+0x158>
80009fb8:	08 36       	cp.w	r6,r4
80009fba:	c4 43       	brcs	8000a042 <__sfvwrite_r+0x13a>
80009fbc:	10 99       	mov	r9,r8
80009fbe:	e2 19 04 80 	andl	r9,0x480,COH
80009fc2:	c4 00       	breq	8000a042 <__sfvwrite_r+0x13a>
80009fc4:	6e 4b       	ld.w	r11,r7[0x10]
80009fc6:	6e 09       	ld.w	r9,r7[0x0]
80009fc8:	16 19       	sub	r9,r11
80009fca:	50 09       	stdsp	sp[0x0],r9
80009fcc:	6e 59       	ld.w	r9,r7[0x14]
80009fce:	10 9c       	mov	r12,r8
80009fd0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009fd4:	30 28       	mov	r8,2
80009fd6:	f4 08 0c 08 	divs	r8,r10,r8
80009fda:	fa e9 00 04 	st.d	sp[4],r8
80009fde:	10 94       	mov	r4,r8
80009fe0:	40 09       	lddsp	r9,sp[0x0]
80009fe2:	e2 1c 04 00 	andl	r12,0x400,COH
80009fe6:	2f f9       	sub	r9,-1
80009fe8:	0c 09       	add	r9,r6
80009fea:	12 38       	cp.w	r8,r9
80009fec:	f2 04 17 30 	movlo	r4,r9
80009ff0:	58 0c       	cp.w	r12,0
80009ff2:	c1 10       	breq	8000a014 <__sfvwrite_r+0x10c>
80009ff4:	08 9b       	mov	r11,r4
80009ff6:	0a 9c       	mov	r12,r5
80009ff8:	fe b0 e0 6c 	rcall	800060d0 <_malloc_r>
80009ffc:	18 92       	mov	r2,r12
80009ffe:	c1 40       	breq	8000a026 <__sfvwrite_r+0x11e>
8000a000:	40 0a       	lddsp	r10,sp[0x0]
8000a002:	6e 4b       	ld.w	r11,r7[0x10]
8000a004:	fe b0 e2 82 	rcall	80006508 <memcpy>
8000a008:	8e 68       	ld.sh	r8,r7[0xc]
8000a00a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a00e:	a7 b8       	sbr	r8,0x7
8000a010:	ae 68       	st.h	r7[0xc],r8
8000a012:	c0 d8       	rjmp	8000a02c <__sfvwrite_r+0x124>
8000a014:	08 9a       	mov	r10,r4
8000a016:	0a 9c       	mov	r12,r5
8000a018:	fe b0 e3 24 	rcall	80006660 <_realloc_r>
8000a01c:	18 92       	mov	r2,r12
8000a01e:	c0 71       	brne	8000a02c <__sfvwrite_r+0x124>
8000a020:	6e 4b       	ld.w	r11,r7[0x10]
8000a022:	0a 9c       	mov	r12,r5
8000a024:	ca ce       	rcall	80009d7c <_free_r>
8000a026:	30 c8       	mov	r8,12
8000a028:	8b 38       	st.w	r5[0xc],r8
8000a02a:	cb 18       	rjmp	8000a18c <__sfvwrite_r+0x284>
8000a02c:	40 0a       	lddsp	r10,sp[0x0]
8000a02e:	40 09       	lddsp	r9,sp[0x0]
8000a030:	e8 0a 01 0a 	sub	r10,r4,r10
8000a034:	e4 09 00 08 	add	r8,r2,r9
8000a038:	8f 54       	st.w	r7[0x14],r4
8000a03a:	8f 2a       	st.w	r7[0x8],r10
8000a03c:	8f 08       	st.w	r7[0x0],r8
8000a03e:	8f 42       	st.w	r7[0x10],r2
8000a040:	0c 94       	mov	r4,r6
8000a042:	08 36       	cp.w	r6,r4
8000a044:	ec 04 17 30 	movlo	r4,r6
8000a048:	06 9b       	mov	r11,r3
8000a04a:	08 9a       	mov	r10,r4
8000a04c:	6e 0c       	ld.w	r12,r7[0x0]
8000a04e:	c3 ad       	rcall	8000a2c2 <memmove>
8000a050:	6e 08       	ld.w	r8,r7[0x0]
8000a052:	08 08       	add	r8,r4
8000a054:	8f 08       	st.w	r7[0x0],r8
8000a056:	6e 28       	ld.w	r8,r7[0x8]
8000a058:	08 18       	sub	r8,r4
8000a05a:	0c 94       	mov	r4,r6
8000a05c:	8f 28       	st.w	r7[0x8],r8
8000a05e:	c2 e8       	rjmp	8000a0ba <__sfvwrite_r+0x1b2>
8000a060:	08 36       	cp.w	r6,r4
8000a062:	5f ba       	srhi	r10
8000a064:	6e 0c       	ld.w	r12,r7[0x0]
8000a066:	6e 48       	ld.w	r8,r7[0x10]
8000a068:	10 3c       	cp.w	r12,r8
8000a06a:	5f b8       	srhi	r8
8000a06c:	f5 e8 00 08 	and	r8,r10,r8
8000a070:	f2 08 18 00 	cp.b	r8,r9
8000a074:	c0 d0       	breq	8000a08e <__sfvwrite_r+0x186>
8000a076:	06 9b       	mov	r11,r3
8000a078:	08 9a       	mov	r10,r4
8000a07a:	c2 4d       	rcall	8000a2c2 <memmove>
8000a07c:	6e 08       	ld.w	r8,r7[0x0]
8000a07e:	08 08       	add	r8,r4
8000a080:	0e 9b       	mov	r11,r7
8000a082:	8f 08       	st.w	r7[0x0],r8
8000a084:	0a 9c       	mov	r12,r5
8000a086:	fe b0 fd 09 	rcall	80009a98 <_fflush_r>
8000a08a:	c1 80       	breq	8000a0ba <__sfvwrite_r+0x1b2>
8000a08c:	c8 08       	rjmp	8000a18c <__sfvwrite_r+0x284>
8000a08e:	6e 59       	ld.w	r9,r7[0x14]
8000a090:	12 36       	cp.w	r6,r9
8000a092:	c0 a3       	brcs	8000a0a6 <__sfvwrite_r+0x19e>
8000a094:	6e a8       	ld.w	r8,r7[0x28]
8000a096:	06 9a       	mov	r10,r3
8000a098:	6e 8b       	ld.w	r11,r7[0x20]
8000a09a:	0a 9c       	mov	r12,r5
8000a09c:	5d 18       	icall	r8
8000a09e:	18 94       	mov	r4,r12
8000a0a0:	e0 89 00 0d 	brgt	8000a0ba <__sfvwrite_r+0x1b2>
8000a0a4:	c7 48       	rjmp	8000a18c <__sfvwrite_r+0x284>
8000a0a6:	0c 9a       	mov	r10,r6
8000a0a8:	06 9b       	mov	r11,r3
8000a0aa:	c0 cd       	rcall	8000a2c2 <memmove>
8000a0ac:	6e 08       	ld.w	r8,r7[0x0]
8000a0ae:	0c 08       	add	r8,r6
8000a0b0:	0c 94       	mov	r4,r6
8000a0b2:	8f 08       	st.w	r7[0x0],r8
8000a0b4:	6e 28       	ld.w	r8,r7[0x8]
8000a0b6:	0c 18       	sub	r8,r6
8000a0b8:	8f 28       	st.w	r7[0x8],r8
8000a0ba:	62 28       	ld.w	r8,r1[0x8]
8000a0bc:	08 18       	sub	r8,r4
8000a0be:	83 28       	st.w	r1[0x8],r8
8000a0c0:	c6 b0       	breq	8000a196 <__sfvwrite_r+0x28e>
8000a0c2:	08 16       	sub	r6,r4
8000a0c4:	08 03       	add	r3,r4
8000a0c6:	c7 1b       	rjmp	80009fa8 <__sfvwrite_r+0xa0>
8000a0c8:	60 03       	ld.w	r3,r0[0x0]
8000a0ca:	60 11       	ld.w	r1,r0[0x4]
8000a0cc:	30 08       	mov	r8,0
8000a0ce:	2f 80       	sub	r0,-8
8000a0d0:	50 08       	stdsp	sp[0x0],r8
8000a0d2:	58 01       	cp.w	r1,0
8000a0d4:	cf a0       	breq	8000a0c8 <__sfvwrite_r+0x1c0>
8000a0d6:	40 0a       	lddsp	r10,sp[0x0]
8000a0d8:	58 0a       	cp.w	r10,0
8000a0da:	c1 41       	brne	8000a102 <__sfvwrite_r+0x1fa>
8000a0dc:	e2 c6 ff ff 	sub	r6,r1,-1
8000a0e0:	02 9a       	mov	r10,r1
8000a0e2:	30 ab       	mov	r11,10
8000a0e4:	06 9c       	mov	r12,r3
8000a0e6:	ce 3c       	rcall	8000a2ac <memchr>
8000a0e8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a0ec:	58 0c       	cp.w	r12,0
8000a0ee:	f1 d3 e1 16 	subne	r6,r8,r3
8000a0f2:	f9 b9 01 01 	movne	r9,1
8000a0f6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a0fa:	f9 b8 00 01 	moveq	r8,1
8000a0fe:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a102:	02 36       	cp.w	r6,r1
8000a104:	ec 04 17 80 	movls	r4,r6
8000a108:	e2 04 17 b0 	movhi	r4,r1
8000a10c:	6e 59       	ld.w	r9,r7[0x14]
8000a10e:	6e 25       	ld.w	r5,r7[0x8]
8000a110:	f2 05 00 05 	add	r5,r9,r5
8000a114:	0a 34       	cp.w	r4,r5
8000a116:	5f 9a       	srgt	r10
8000a118:	6e 0c       	ld.w	r12,r7[0x0]
8000a11a:	6e 48       	ld.w	r8,r7[0x10]
8000a11c:	10 3c       	cp.w	r12,r8
8000a11e:	5f b8       	srhi	r8
8000a120:	f5 e8 00 08 	and	r8,r10,r8
8000a124:	30 0a       	mov	r10,0
8000a126:	f4 08 18 00 	cp.b	r8,r10
8000a12a:	c0 d0       	breq	8000a144 <__sfvwrite_r+0x23c>
8000a12c:	06 9b       	mov	r11,r3
8000a12e:	0a 9a       	mov	r10,r5
8000a130:	cc 9c       	rcall	8000a2c2 <memmove>
8000a132:	6e 08       	ld.w	r8,r7[0x0]
8000a134:	0a 08       	add	r8,r5
8000a136:	0e 9b       	mov	r11,r7
8000a138:	8f 08       	st.w	r7[0x0],r8
8000a13a:	40 1c       	lddsp	r12,sp[0x4]
8000a13c:	fe b0 fc ae 	rcall	80009a98 <_fflush_r>
8000a140:	c1 70       	breq	8000a16e <__sfvwrite_r+0x266>
8000a142:	c2 58       	rjmp	8000a18c <__sfvwrite_r+0x284>
8000a144:	12 34       	cp.w	r4,r9
8000a146:	c0 a5       	brlt	8000a15a <__sfvwrite_r+0x252>
8000a148:	6e a8       	ld.w	r8,r7[0x28]
8000a14a:	06 9a       	mov	r10,r3
8000a14c:	6e 8b       	ld.w	r11,r7[0x20]
8000a14e:	40 1c       	lddsp	r12,sp[0x4]
8000a150:	5d 18       	icall	r8
8000a152:	18 95       	mov	r5,r12
8000a154:	e0 89 00 0d 	brgt	8000a16e <__sfvwrite_r+0x266>
8000a158:	c1 a8       	rjmp	8000a18c <__sfvwrite_r+0x284>
8000a15a:	08 9a       	mov	r10,r4
8000a15c:	06 9b       	mov	r11,r3
8000a15e:	cb 2c       	rcall	8000a2c2 <memmove>
8000a160:	6e 08       	ld.w	r8,r7[0x0]
8000a162:	08 08       	add	r8,r4
8000a164:	08 95       	mov	r5,r4
8000a166:	8f 08       	st.w	r7[0x0],r8
8000a168:	6e 28       	ld.w	r8,r7[0x8]
8000a16a:	08 18       	sub	r8,r4
8000a16c:	8f 28       	st.w	r7[0x8],r8
8000a16e:	0a 16       	sub	r6,r5
8000a170:	c0 71       	brne	8000a17e <__sfvwrite_r+0x276>
8000a172:	0e 9b       	mov	r11,r7
8000a174:	40 1c       	lddsp	r12,sp[0x4]
8000a176:	fe b0 fc 91 	rcall	80009a98 <_fflush_r>
8000a17a:	c0 91       	brne	8000a18c <__sfvwrite_r+0x284>
8000a17c:	50 06       	stdsp	sp[0x0],r6
8000a17e:	64 28       	ld.w	r8,r2[0x8]
8000a180:	0a 18       	sub	r8,r5
8000a182:	85 28       	st.w	r2[0x8],r8
8000a184:	c0 90       	breq	8000a196 <__sfvwrite_r+0x28e>
8000a186:	0a 11       	sub	r1,r5
8000a188:	0a 03       	add	r3,r5
8000a18a:	ca 4b       	rjmp	8000a0d2 <__sfvwrite_r+0x1ca>
8000a18c:	8e 68       	ld.sh	r8,r7[0xc]
8000a18e:	a7 a8       	sbr	r8,0x6
8000a190:	ae 68       	st.h	r7[0xc],r8
8000a192:	3f fc       	mov	r12,-1
8000a194:	c0 28       	rjmp	8000a198 <__sfvwrite_r+0x290>
8000a196:	30 0c       	mov	r12,0
8000a198:	2f dd       	sub	sp,-12
8000a19a:	d8 32       	popm	r0-r7,pc

8000a19c <_fwalk>:
8000a19c:	d4 31       	pushm	r0-r7,lr
8000a19e:	30 05       	mov	r5,0
8000a1a0:	16 91       	mov	r1,r11
8000a1a2:	f8 c7 ff 28 	sub	r7,r12,-216
8000a1a6:	0a 92       	mov	r2,r5
8000a1a8:	fe b0 fc fe 	rcall	80009ba4 <__sfp_lock_acquire>
8000a1ac:	3f f3       	mov	r3,-1
8000a1ae:	c1 68       	rjmp	8000a1da <_fwalk+0x3e>
8000a1b0:	6e 26       	ld.w	r6,r7[0x8]
8000a1b2:	6e 14       	ld.w	r4,r7[0x4]
8000a1b4:	2f 46       	sub	r6,-12
8000a1b6:	c0 c8       	rjmp	8000a1ce <_fwalk+0x32>
8000a1b8:	8c 08       	ld.sh	r8,r6[0x0]
8000a1ba:	e4 08 19 00 	cp.h	r8,r2
8000a1be:	c0 70       	breq	8000a1cc <_fwalk+0x30>
8000a1c0:	8c 18       	ld.sh	r8,r6[0x2]
8000a1c2:	e6 08 19 00 	cp.h	r8,r3
8000a1c6:	c0 30       	breq	8000a1cc <_fwalk+0x30>
8000a1c8:	5d 11       	icall	r1
8000a1ca:	18 45       	or	r5,r12
8000a1cc:	2a 46       	sub	r6,-92
8000a1ce:	20 14       	sub	r4,1
8000a1d0:	ec cc 00 0c 	sub	r12,r6,12
8000a1d4:	58 04       	cp.w	r4,0
8000a1d6:	cf 14       	brge	8000a1b8 <_fwalk+0x1c>
8000a1d8:	6e 07       	ld.w	r7,r7[0x0]
8000a1da:	58 07       	cp.w	r7,0
8000a1dc:	ce a1       	brne	8000a1b0 <_fwalk+0x14>
8000a1de:	fe b0 fc e4 	rcall	80009ba6 <__sfp_lock_release>
8000a1e2:	0a 9c       	mov	r12,r5
8000a1e4:	d8 32       	popm	r0-r7,pc
8000a1e6:	d7 03       	nop

8000a1e8 <_localeconv_r>:
8000a1e8:	fe cc d6 90 	sub	r12,pc,-10608
8000a1ec:	5e fc       	retal	r12
8000a1ee:	d7 03       	nop

8000a1f0 <__smakebuf_r>:
8000a1f0:	d4 21       	pushm	r4-r7,lr
8000a1f2:	20 fd       	sub	sp,60
8000a1f4:	96 68       	ld.sh	r8,r11[0xc]
8000a1f6:	16 97       	mov	r7,r11
8000a1f8:	18 96       	mov	r6,r12
8000a1fa:	e2 18 00 02 	andl	r8,0x2,COH
8000a1fe:	c3 d1       	brne	8000a278 <__smakebuf_r+0x88>
8000a200:	96 7b       	ld.sh	r11,r11[0xe]
8000a202:	f0 0b 19 00 	cp.h	r11,r8
8000a206:	c0 55       	brlt	8000a210 <__smakebuf_r+0x20>
8000a208:	1a 9a       	mov	r10,sp
8000a20a:	e0 a0 04 81 	rcall	8000ab0c <_fstat_r>
8000a20e:	c0 f4       	brge	8000a22c <__smakebuf_r+0x3c>
8000a210:	8e 65       	ld.sh	r5,r7[0xc]
8000a212:	0a 98       	mov	r8,r5
8000a214:	ab b8       	sbr	r8,0xb
8000a216:	e2 15 00 80 	andl	r5,0x80,COH
8000a21a:	ae 68       	st.h	r7[0xc],r8
8000a21c:	30 04       	mov	r4,0
8000a21e:	e0 68 04 00 	mov	r8,1024
8000a222:	f9 b5 01 40 	movne	r5,64
8000a226:	f0 05 17 00 	moveq	r5,r8
8000a22a:	c1 c8       	rjmp	8000a262 <__smakebuf_r+0x72>
8000a22c:	40 18       	lddsp	r8,sp[0x4]
8000a22e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a232:	e0 48 20 00 	cp.w	r8,8192
8000a236:	5f 04       	sreq	r4
8000a238:	e0 48 80 00 	cp.w	r8,32768
8000a23c:	c0 e1       	brne	8000a258 <__smakebuf_r+0x68>
8000a23e:	6e b9       	ld.w	r9,r7[0x2c]
8000a240:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a244:	10 39       	cp.w	r9,r8
8000a246:	c0 91       	brne	8000a258 <__smakebuf_r+0x68>
8000a248:	8e 68       	ld.sh	r8,r7[0xc]
8000a24a:	e0 65 04 00 	mov	r5,1024
8000a24e:	ab a8       	sbr	r8,0xa
8000a250:	ef 45 00 50 	st.w	r7[80],r5
8000a254:	ae 68       	st.h	r7[0xc],r8
8000a256:	c0 68       	rjmp	8000a262 <__smakebuf_r+0x72>
8000a258:	8e 68       	ld.sh	r8,r7[0xc]
8000a25a:	e0 65 04 00 	mov	r5,1024
8000a25e:	ab b8       	sbr	r8,0xb
8000a260:	ae 68       	st.h	r7[0xc],r8
8000a262:	0a 9b       	mov	r11,r5
8000a264:	0c 9c       	mov	r12,r6
8000a266:	fe b0 df 35 	rcall	800060d0 <_malloc_r>
8000a26a:	8e 68       	ld.sh	r8,r7[0xc]
8000a26c:	c0 d1       	brne	8000a286 <__smakebuf_r+0x96>
8000a26e:	ed b8 00 09 	bld	r8,0x9
8000a272:	c1 b0       	breq	8000a2a8 <__smakebuf_r+0xb8>
8000a274:	a1 b8       	sbr	r8,0x1
8000a276:	ae 68       	st.h	r7[0xc],r8
8000a278:	ee c8 ff b9 	sub	r8,r7,-71
8000a27c:	8f 48       	st.w	r7[0x10],r8
8000a27e:	8f 08       	st.w	r7[0x0],r8
8000a280:	30 18       	mov	r8,1
8000a282:	8f 58       	st.w	r7[0x14],r8
8000a284:	c1 28       	rjmp	8000a2a8 <__smakebuf_r+0xb8>
8000a286:	a7 b8       	sbr	r8,0x7
8000a288:	8f 4c       	st.w	r7[0x10],r12
8000a28a:	ae 68       	st.h	r7[0xc],r8
8000a28c:	8f 55       	st.w	r7[0x14],r5
8000a28e:	fe c8 06 e6 	sub	r8,pc,1766
8000a292:	8f 0c       	st.w	r7[0x0],r12
8000a294:	8d a8       	st.w	r6[0x28],r8
8000a296:	58 04       	cp.w	r4,0
8000a298:	c0 80       	breq	8000a2a8 <__smakebuf_r+0xb8>
8000a29a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a29c:	fe b0 e3 94 	rcall	800069c4 <isatty>
8000a2a0:	c0 40       	breq	8000a2a8 <__smakebuf_r+0xb8>
8000a2a2:	8e 68       	ld.sh	r8,r7[0xc]
8000a2a4:	a1 a8       	sbr	r8,0x0
8000a2a6:	ae 68       	st.h	r7[0xc],r8
8000a2a8:	2f 1d       	sub	sp,-60
8000a2aa:	d8 22       	popm	r4-r7,pc

8000a2ac <memchr>:
8000a2ac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a2b0:	c0 68       	rjmp	8000a2bc <memchr+0x10>
8000a2b2:	20 1a       	sub	r10,1
8000a2b4:	19 88       	ld.ub	r8,r12[0x0]
8000a2b6:	16 38       	cp.w	r8,r11
8000a2b8:	5e 0c       	reteq	r12
8000a2ba:	2f fc       	sub	r12,-1
8000a2bc:	58 0a       	cp.w	r10,0
8000a2be:	cf a1       	brne	8000a2b2 <memchr+0x6>
8000a2c0:	5e fa       	retal	r10

8000a2c2 <memmove>:
8000a2c2:	d4 01       	pushm	lr
8000a2c4:	18 3b       	cp.w	r11,r12
8000a2c6:	c1 92       	brcc	8000a2f8 <memmove+0x36>
8000a2c8:	f6 0a 00 09 	add	r9,r11,r10
8000a2cc:	12 3c       	cp.w	r12,r9
8000a2ce:	c1 52       	brcc	8000a2f8 <memmove+0x36>
8000a2d0:	f8 0a 00 0b 	add	r11,r12,r10
8000a2d4:	30 08       	mov	r8,0
8000a2d6:	c0 68       	rjmp	8000a2e2 <memmove+0x20>
8000a2d8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a2dc:	20 1a       	sub	r10,1
8000a2de:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a2e2:	20 18       	sub	r8,1
8000a2e4:	58 0a       	cp.w	r10,0
8000a2e6:	cf 91       	brne	8000a2d8 <memmove+0x16>
8000a2e8:	d8 02       	popm	pc
8000a2ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a2ee:	20 1a       	sub	r10,1
8000a2f0:	f8 08 0b 09 	st.b	r12[r8],r9
8000a2f4:	2f f8       	sub	r8,-1
8000a2f6:	c0 28       	rjmp	8000a2fa <memmove+0x38>
8000a2f8:	30 08       	mov	r8,0
8000a2fa:	58 0a       	cp.w	r10,0
8000a2fc:	cf 71       	brne	8000a2ea <memmove+0x28>
8000a2fe:	d8 02       	popm	pc

8000a300 <__hi0bits>:
8000a300:	18 98       	mov	r8,r12
8000a302:	e0 1c 00 00 	andl	r12,0x0
8000a306:	f0 09 15 10 	lsl	r9,r8,0x10
8000a30a:	58 0c       	cp.w	r12,0
8000a30c:	f2 08 17 00 	moveq	r8,r9
8000a310:	f9 bc 00 10 	moveq	r12,16
8000a314:	f9 bc 01 00 	movne	r12,0
8000a318:	10 9a       	mov	r10,r8
8000a31a:	f0 09 15 08 	lsl	r9,r8,0x8
8000a31e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a322:	f7 bc 00 f8 	subeq	r12,-8
8000a326:	f2 08 17 00 	moveq	r8,r9
8000a32a:	10 9a       	mov	r10,r8
8000a32c:	f0 09 15 04 	lsl	r9,r8,0x4
8000a330:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a334:	f7 bc 00 fc 	subeq	r12,-4
8000a338:	f2 08 17 00 	moveq	r8,r9
8000a33c:	10 9a       	mov	r10,r8
8000a33e:	f0 09 15 02 	lsl	r9,r8,0x2
8000a342:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a346:	f7 bc 00 fe 	subeq	r12,-2
8000a34a:	f2 08 17 00 	moveq	r8,r9
8000a34e:	58 08       	cp.w	r8,0
8000a350:	5e 5c       	retlt	r12
8000a352:	ed b8 00 1e 	bld	r8,0x1e
8000a356:	f9 bc 01 20 	movne	r12,32
8000a35a:	f7 bc 00 ff 	subeq	r12,-1
8000a35e:	5e fc       	retal	r12

8000a360 <__lo0bits>:
8000a360:	18 99       	mov	r9,r12
8000a362:	78 08       	ld.w	r8,r12[0x0]
8000a364:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a368:	c1 50       	breq	8000a392 <__lo0bits+0x32>
8000a36a:	ed b8 00 00 	bld	r8,0x0
8000a36e:	c0 21       	brne	8000a372 <__lo0bits+0x12>
8000a370:	5e fd       	retal	0
8000a372:	10 9b       	mov	r11,r8
8000a374:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a378:	e2 1b 00 02 	andl	r11,0x2,COH
8000a37c:	a3 88       	lsr	r8,0x2
8000a37e:	58 0b       	cp.w	r11,0
8000a380:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a384:	f9 bc 01 01 	movne	r12,1
8000a388:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a38c:	f9 bc 00 02 	moveq	r12,2
8000a390:	5e fc       	retal	r12
8000a392:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a396:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a39a:	58 0a       	cp.w	r10,0
8000a39c:	f6 08 17 00 	moveq	r8,r11
8000a3a0:	f9 bc 00 10 	moveq	r12,16
8000a3a4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a3a8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a3ac:	58 0b       	cp.w	r11,0
8000a3ae:	f7 bc 00 f8 	subeq	r12,-8
8000a3b2:	f4 08 17 00 	moveq	r8,r10
8000a3b6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a3ba:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a3be:	58 0b       	cp.w	r11,0
8000a3c0:	f7 bc 00 fc 	subeq	r12,-4
8000a3c4:	f4 08 17 00 	moveq	r8,r10
8000a3c8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a3cc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a3d0:	58 0b       	cp.w	r11,0
8000a3d2:	f7 bc 00 fe 	subeq	r12,-2
8000a3d6:	f4 08 17 00 	moveq	r8,r10
8000a3da:	ed b8 00 00 	bld	r8,0x0
8000a3de:	c0 60       	breq	8000a3ea <__lo0bits+0x8a>
8000a3e0:	a1 98       	lsr	r8,0x1
8000a3e2:	c0 31       	brne	8000a3e8 <__lo0bits+0x88>
8000a3e4:	32 0c       	mov	r12,32
8000a3e6:	5e fc       	retal	r12
8000a3e8:	2f fc       	sub	r12,-1
8000a3ea:	93 08       	st.w	r9[0x0],r8
8000a3ec:	5e fc       	retal	r12

8000a3ee <__mcmp>:
8000a3ee:	d4 01       	pushm	lr
8000a3f0:	18 98       	mov	r8,r12
8000a3f2:	76 49       	ld.w	r9,r11[0x10]
8000a3f4:	78 4c       	ld.w	r12,r12[0x10]
8000a3f6:	12 1c       	sub	r12,r9
8000a3f8:	c1 31       	brne	8000a41e <__mcmp+0x30>
8000a3fa:	2f b9       	sub	r9,-5
8000a3fc:	a3 69       	lsl	r9,0x2
8000a3fe:	12 0b       	add	r11,r9
8000a400:	f0 09 00 09 	add	r9,r8,r9
8000a404:	2e c8       	sub	r8,-20
8000a406:	13 4e       	ld.w	lr,--r9
8000a408:	17 4a       	ld.w	r10,--r11
8000a40a:	14 3e       	cp.w	lr,r10
8000a40c:	c0 60       	breq	8000a418 <__mcmp+0x2a>
8000a40e:	f9 bc 03 ff 	movlo	r12,-1
8000a412:	f9 bc 02 01 	movhs	r12,1
8000a416:	d8 02       	popm	pc
8000a418:	10 39       	cp.w	r9,r8
8000a41a:	fe 9b ff f6 	brhi	8000a406 <__mcmp+0x18>
8000a41e:	d8 02       	popm	pc

8000a420 <_Bfree>:
8000a420:	d4 21       	pushm	r4-r7,lr
8000a422:	18 97       	mov	r7,r12
8000a424:	16 95       	mov	r5,r11
8000a426:	78 96       	ld.w	r6,r12[0x24]
8000a428:	58 06       	cp.w	r6,0
8000a42a:	c0 91       	brne	8000a43c <_Bfree+0x1c>
8000a42c:	31 0c       	mov	r12,16
8000a42e:	fe b0 de 49 	rcall	800060c0 <malloc>
8000a432:	99 36       	st.w	r12[0xc],r6
8000a434:	8f 9c       	st.w	r7[0x24],r12
8000a436:	99 16       	st.w	r12[0x4],r6
8000a438:	99 26       	st.w	r12[0x8],r6
8000a43a:	99 06       	st.w	r12[0x0],r6
8000a43c:	58 05       	cp.w	r5,0
8000a43e:	c0 90       	breq	8000a450 <_Bfree+0x30>
8000a440:	6a 19       	ld.w	r9,r5[0x4]
8000a442:	6e 98       	ld.w	r8,r7[0x24]
8000a444:	70 38       	ld.w	r8,r8[0xc]
8000a446:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a44a:	8b 0a       	st.w	r5[0x0],r10
8000a44c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a450:	d8 22       	popm	r4-r7,pc
8000a452:	d7 03       	nop

8000a454 <_Balloc>:
8000a454:	d4 21       	pushm	r4-r7,lr
8000a456:	18 97       	mov	r7,r12
8000a458:	16 96       	mov	r6,r11
8000a45a:	78 95       	ld.w	r5,r12[0x24]
8000a45c:	58 05       	cp.w	r5,0
8000a45e:	c0 91       	brne	8000a470 <_Balloc+0x1c>
8000a460:	31 0c       	mov	r12,16
8000a462:	fe b0 de 2f 	rcall	800060c0 <malloc>
8000a466:	99 35       	st.w	r12[0xc],r5
8000a468:	8f 9c       	st.w	r7[0x24],r12
8000a46a:	99 15       	st.w	r12[0x4],r5
8000a46c:	99 25       	st.w	r12[0x8],r5
8000a46e:	99 05       	st.w	r12[0x0],r5
8000a470:	6e 95       	ld.w	r5,r7[0x24]
8000a472:	6a 38       	ld.w	r8,r5[0xc]
8000a474:	58 08       	cp.w	r8,0
8000a476:	c0 b1       	brne	8000a48c <_Balloc+0x38>
8000a478:	31 0a       	mov	r10,16
8000a47a:	30 4b       	mov	r11,4
8000a47c:	0e 9c       	mov	r12,r7
8000a47e:	e0 a0 02 a7 	rcall	8000a9cc <_calloc_r>
8000a482:	8b 3c       	st.w	r5[0xc],r12
8000a484:	6e 98       	ld.w	r8,r7[0x24]
8000a486:	70 3c       	ld.w	r12,r8[0xc]
8000a488:	58 0c       	cp.w	r12,0
8000a48a:	c1 b0       	breq	8000a4c0 <_Balloc+0x6c>
8000a48c:	6e 98       	ld.w	r8,r7[0x24]
8000a48e:	70 38       	ld.w	r8,r8[0xc]
8000a490:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a494:	70 0c       	ld.w	r12,r8[0x0]
8000a496:	58 0c       	cp.w	r12,0
8000a498:	c0 40       	breq	8000a4a0 <_Balloc+0x4c>
8000a49a:	78 09       	ld.w	r9,r12[0x0]
8000a49c:	91 09       	st.w	r8[0x0],r9
8000a49e:	c0 e8       	rjmp	8000a4ba <_Balloc+0x66>
8000a4a0:	0e 9c       	mov	r12,r7
8000a4a2:	30 17       	mov	r7,1
8000a4a4:	0e 9b       	mov	r11,r7
8000a4a6:	ee 06 09 47 	lsl	r7,r7,r6
8000a4aa:	ee ca ff fb 	sub	r10,r7,-5
8000a4ae:	a3 6a       	lsl	r10,0x2
8000a4b0:	e0 a0 02 8e 	rcall	8000a9cc <_calloc_r>
8000a4b4:	c0 60       	breq	8000a4c0 <_Balloc+0x6c>
8000a4b6:	99 16       	st.w	r12[0x4],r6
8000a4b8:	99 27       	st.w	r12[0x8],r7
8000a4ba:	30 08       	mov	r8,0
8000a4bc:	99 38       	st.w	r12[0xc],r8
8000a4be:	99 48       	st.w	r12[0x10],r8
8000a4c0:	d8 22       	popm	r4-r7,pc
8000a4c2:	d7 03       	nop

8000a4c4 <__d2b>:
8000a4c4:	d4 31       	pushm	r0-r7,lr
8000a4c6:	20 2d       	sub	sp,8
8000a4c8:	16 93       	mov	r3,r11
8000a4ca:	12 96       	mov	r6,r9
8000a4cc:	10 95       	mov	r5,r8
8000a4ce:	14 92       	mov	r2,r10
8000a4d0:	30 1b       	mov	r11,1
8000a4d2:	cc 1f       	rcall	8000a454 <_Balloc>
8000a4d4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a4d8:	50 09       	stdsp	sp[0x0],r9
8000a4da:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a4de:	b5 a9       	sbr	r9,0x14
8000a4e0:	f0 01 16 14 	lsr	r1,r8,0x14
8000a4e4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a4e8:	18 94       	mov	r4,r12
8000a4ea:	58 02       	cp.w	r2,0
8000a4ec:	c1 d0       	breq	8000a526 <__d2b+0x62>
8000a4ee:	fa cc ff f8 	sub	r12,sp,-8
8000a4f2:	18 d2       	st.w	--r12,r2
8000a4f4:	c3 6f       	rcall	8000a360 <__lo0bits>
8000a4f6:	40 18       	lddsp	r8,sp[0x4]
8000a4f8:	c0 d0       	breq	8000a512 <__d2b+0x4e>
8000a4fa:	40 09       	lddsp	r9,sp[0x0]
8000a4fc:	f8 0a 11 20 	rsub	r10,r12,32
8000a500:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a504:	f5 e8 10 08 	or	r8,r10,r8
8000a508:	89 58       	st.w	r4[0x14],r8
8000a50a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a50e:	50 09       	stdsp	sp[0x0],r9
8000a510:	c0 28       	rjmp	8000a514 <__d2b+0x50>
8000a512:	89 58       	st.w	r4[0x14],r8
8000a514:	40 08       	lddsp	r8,sp[0x0]
8000a516:	58 08       	cp.w	r8,0
8000a518:	f9 b3 01 02 	movne	r3,2
8000a51c:	f9 b3 00 01 	moveq	r3,1
8000a520:	89 68       	st.w	r4[0x18],r8
8000a522:	89 43       	st.w	r4[0x10],r3
8000a524:	c0 88       	rjmp	8000a534 <__d2b+0x70>
8000a526:	1a 9c       	mov	r12,sp
8000a528:	c1 cf       	rcall	8000a360 <__lo0bits>
8000a52a:	30 13       	mov	r3,1
8000a52c:	40 08       	lddsp	r8,sp[0x0]
8000a52e:	2e 0c       	sub	r12,-32
8000a530:	89 43       	st.w	r4[0x10],r3
8000a532:	89 58       	st.w	r4[0x14],r8
8000a534:	58 01       	cp.w	r1,0
8000a536:	c0 90       	breq	8000a548 <__d2b+0x84>
8000a538:	e2 c1 04 33 	sub	r1,r1,1075
8000a53c:	18 01       	add	r1,r12
8000a53e:	8d 01       	st.w	r6[0x0],r1
8000a540:	f8 0c 11 35 	rsub	r12,r12,53
8000a544:	8b 0c       	st.w	r5[0x0],r12
8000a546:	c0 c8       	rjmp	8000a55e <__d2b+0x9a>
8000a548:	e6 c8 ff fc 	sub	r8,r3,-4
8000a54c:	f8 cc 04 32 	sub	r12,r12,1074
8000a550:	a5 73       	lsl	r3,0x5
8000a552:	8d 0c       	st.w	r6[0x0],r12
8000a554:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a558:	cd 4e       	rcall	8000a300 <__hi0bits>
8000a55a:	18 13       	sub	r3,r12
8000a55c:	8b 03       	st.w	r5[0x0],r3
8000a55e:	08 9c       	mov	r12,r4
8000a560:	2f ed       	sub	sp,-8
8000a562:	d8 32       	popm	r0-r7,pc

8000a564 <__mdiff>:
8000a564:	d4 31       	pushm	r0-r7,lr
8000a566:	74 48       	ld.w	r8,r10[0x10]
8000a568:	76 45       	ld.w	r5,r11[0x10]
8000a56a:	16 97       	mov	r7,r11
8000a56c:	14 96       	mov	r6,r10
8000a56e:	10 15       	sub	r5,r8
8000a570:	c1 31       	brne	8000a596 <__mdiff+0x32>
8000a572:	2f b8       	sub	r8,-5
8000a574:	ee ce ff ec 	sub	lr,r7,-20
8000a578:	a3 68       	lsl	r8,0x2
8000a57a:	f4 08 00 0b 	add	r11,r10,r8
8000a57e:	ee 08 00 08 	add	r8,r7,r8
8000a582:	11 4a       	ld.w	r10,--r8
8000a584:	17 49       	ld.w	r9,--r11
8000a586:	12 3a       	cp.w	r10,r9
8000a588:	c0 30       	breq	8000a58e <__mdiff+0x2a>
8000a58a:	c0 e2       	brcc	8000a5a6 <__mdiff+0x42>
8000a58c:	c0 78       	rjmp	8000a59a <__mdiff+0x36>
8000a58e:	1c 38       	cp.w	r8,lr
8000a590:	fe 9b ff f9 	brhi	8000a582 <__mdiff+0x1e>
8000a594:	c4 98       	rjmp	8000a626 <__mdiff+0xc2>
8000a596:	58 05       	cp.w	r5,0
8000a598:	c0 64       	brge	8000a5a4 <__mdiff+0x40>
8000a59a:	0e 98       	mov	r8,r7
8000a59c:	30 15       	mov	r5,1
8000a59e:	0c 97       	mov	r7,r6
8000a5a0:	10 96       	mov	r6,r8
8000a5a2:	c0 28       	rjmp	8000a5a6 <__mdiff+0x42>
8000a5a4:	30 05       	mov	r5,0
8000a5a6:	6e 1b       	ld.w	r11,r7[0x4]
8000a5a8:	c5 6f       	rcall	8000a454 <_Balloc>
8000a5aa:	6e 49       	ld.w	r9,r7[0x10]
8000a5ac:	6c 44       	ld.w	r4,r6[0x10]
8000a5ae:	99 35       	st.w	r12[0xc],r5
8000a5b0:	2f b4       	sub	r4,-5
8000a5b2:	f2 c5 ff fb 	sub	r5,r9,-5
8000a5b6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a5ba:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a5be:	2e c6       	sub	r6,-20
8000a5c0:	2e c7       	sub	r7,-20
8000a5c2:	f8 c8 ff ec 	sub	r8,r12,-20
8000a5c6:	30 0a       	mov	r10,0
8000a5c8:	0f 0e       	ld.w	lr,r7++
8000a5ca:	0d 0b       	ld.w	r11,r6++
8000a5cc:	fc 02 16 10 	lsr	r2,lr,0x10
8000a5d0:	f6 03 16 10 	lsr	r3,r11,0x10
8000a5d4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a5d8:	e4 03 01 03 	sub	r3,r2,r3
8000a5dc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a5e0:	fc 0b 01 0b 	sub	r11,lr,r11
8000a5e4:	f6 0a 00 0a 	add	r10,r11,r10
8000a5e8:	b0 1a       	st.h	r8[0x2],r10
8000a5ea:	b1 4a       	asr	r10,0x10
8000a5ec:	e6 0a 00 0a 	add	r10,r3,r10
8000a5f0:	b0 0a       	st.h	r8[0x0],r10
8000a5f2:	2f c8       	sub	r8,-4
8000a5f4:	b1 4a       	asr	r10,0x10
8000a5f6:	08 36       	cp.w	r6,r4
8000a5f8:	ce 83       	brcs	8000a5c8 <__mdiff+0x64>
8000a5fa:	c0 d8       	rjmp	8000a614 <__mdiff+0xb0>
8000a5fc:	0f 0b       	ld.w	r11,r7++
8000a5fe:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a602:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a606:	16 0a       	add	r10,r11
8000a608:	b0 1a       	st.h	r8[0x2],r10
8000a60a:	b1 4a       	asr	r10,0x10
8000a60c:	1c 0a       	add	r10,lr
8000a60e:	b0 0a       	st.h	r8[0x0],r10
8000a610:	2f c8       	sub	r8,-4
8000a612:	b1 4a       	asr	r10,0x10
8000a614:	0a 37       	cp.w	r7,r5
8000a616:	cf 33       	brcs	8000a5fc <__mdiff+0x98>
8000a618:	c0 28       	rjmp	8000a61c <__mdiff+0xb8>
8000a61a:	20 19       	sub	r9,1
8000a61c:	11 4a       	ld.w	r10,--r8
8000a61e:	58 0a       	cp.w	r10,0
8000a620:	cf d0       	breq	8000a61a <__mdiff+0xb6>
8000a622:	99 49       	st.w	r12[0x10],r9
8000a624:	d8 32       	popm	r0-r7,pc
8000a626:	30 0b       	mov	r11,0
8000a628:	c1 6f       	rcall	8000a454 <_Balloc>
8000a62a:	30 18       	mov	r8,1
8000a62c:	99 48       	st.w	r12[0x10],r8
8000a62e:	30 08       	mov	r8,0
8000a630:	99 58       	st.w	r12[0x14],r8
8000a632:	d8 32       	popm	r0-r7,pc

8000a634 <__lshift>:
8000a634:	d4 31       	pushm	r0-r7,lr
8000a636:	16 97       	mov	r7,r11
8000a638:	76 46       	ld.w	r6,r11[0x10]
8000a63a:	f4 02 14 05 	asr	r2,r10,0x5
8000a63e:	2f f6       	sub	r6,-1
8000a640:	14 93       	mov	r3,r10
8000a642:	18 94       	mov	r4,r12
8000a644:	04 06       	add	r6,r2
8000a646:	76 1b       	ld.w	r11,r11[0x4]
8000a648:	6e 28       	ld.w	r8,r7[0x8]
8000a64a:	c0 38       	rjmp	8000a650 <__lshift+0x1c>
8000a64c:	2f fb       	sub	r11,-1
8000a64e:	a1 78       	lsl	r8,0x1
8000a650:	10 36       	cp.w	r6,r8
8000a652:	fe 99 ff fd 	brgt	8000a64c <__lshift+0x18>
8000a656:	08 9c       	mov	r12,r4
8000a658:	cf ee       	rcall	8000a454 <_Balloc>
8000a65a:	30 09       	mov	r9,0
8000a65c:	18 95       	mov	r5,r12
8000a65e:	f8 c8 ff ec 	sub	r8,r12,-20
8000a662:	12 9a       	mov	r10,r9
8000a664:	c0 38       	rjmp	8000a66a <__lshift+0x36>
8000a666:	10 aa       	st.w	r8++,r10
8000a668:	2f f9       	sub	r9,-1
8000a66a:	04 39       	cp.w	r9,r2
8000a66c:	cf d5       	brlt	8000a666 <__lshift+0x32>
8000a66e:	6e 4b       	ld.w	r11,r7[0x10]
8000a670:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a674:	2f bb       	sub	r11,-5
8000a676:	ee c9 ff ec 	sub	r9,r7,-20
8000a67a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a67e:	58 03       	cp.w	r3,0
8000a680:	c1 30       	breq	8000a6a6 <__lshift+0x72>
8000a682:	e6 0c 11 20 	rsub	r12,r3,32
8000a686:	30 0a       	mov	r10,0
8000a688:	72 02       	ld.w	r2,r9[0x0]
8000a68a:	e4 03 09 42 	lsl	r2,r2,r3
8000a68e:	04 4a       	or	r10,r2
8000a690:	10 aa       	st.w	r8++,r10
8000a692:	13 0a       	ld.w	r10,r9++
8000a694:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a698:	16 39       	cp.w	r9,r11
8000a69a:	cf 73       	brcs	8000a688 <__lshift+0x54>
8000a69c:	91 0a       	st.w	r8[0x0],r10
8000a69e:	58 0a       	cp.w	r10,0
8000a6a0:	c0 70       	breq	8000a6ae <__lshift+0x7a>
8000a6a2:	2f f6       	sub	r6,-1
8000a6a4:	c0 58       	rjmp	8000a6ae <__lshift+0x7a>
8000a6a6:	13 0a       	ld.w	r10,r9++
8000a6a8:	10 aa       	st.w	r8++,r10
8000a6aa:	16 39       	cp.w	r9,r11
8000a6ac:	cf d3       	brcs	8000a6a6 <__lshift+0x72>
8000a6ae:	08 9c       	mov	r12,r4
8000a6b0:	20 16       	sub	r6,1
8000a6b2:	0e 9b       	mov	r11,r7
8000a6b4:	8b 46       	st.w	r5[0x10],r6
8000a6b6:	cb 5e       	rcall	8000a420 <_Bfree>
8000a6b8:	0a 9c       	mov	r12,r5
8000a6ba:	d8 32       	popm	r0-r7,pc

8000a6bc <__multiply>:
8000a6bc:	d4 31       	pushm	r0-r7,lr
8000a6be:	20 2d       	sub	sp,8
8000a6c0:	76 49       	ld.w	r9,r11[0x10]
8000a6c2:	74 48       	ld.w	r8,r10[0x10]
8000a6c4:	16 96       	mov	r6,r11
8000a6c6:	14 95       	mov	r5,r10
8000a6c8:	10 39       	cp.w	r9,r8
8000a6ca:	ec 08 17 50 	movlt	r8,r6
8000a6ce:	ea 06 17 50 	movlt	r6,r5
8000a6d2:	f0 05 17 50 	movlt	r5,r8
8000a6d6:	6c 28       	ld.w	r8,r6[0x8]
8000a6d8:	76 43       	ld.w	r3,r11[0x10]
8000a6da:	74 42       	ld.w	r2,r10[0x10]
8000a6dc:	76 1b       	ld.w	r11,r11[0x4]
8000a6de:	e4 03 00 07 	add	r7,r2,r3
8000a6e2:	10 37       	cp.w	r7,r8
8000a6e4:	f7 bb 09 ff 	subgt	r11,-1
8000a6e8:	cb 6e       	rcall	8000a454 <_Balloc>
8000a6ea:	ee c4 ff fb 	sub	r4,r7,-5
8000a6ee:	f8 c9 ff ec 	sub	r9,r12,-20
8000a6f2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a6f6:	30 0a       	mov	r10,0
8000a6f8:	12 98       	mov	r8,r9
8000a6fa:	c0 28       	rjmp	8000a6fe <__multiply+0x42>
8000a6fc:	10 aa       	st.w	r8++,r10
8000a6fe:	08 38       	cp.w	r8,r4
8000a700:	cf e3       	brcs	8000a6fc <__multiply+0x40>
8000a702:	2f b3       	sub	r3,-5
8000a704:	2f b2       	sub	r2,-5
8000a706:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a70a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a70e:	ec cb ff ec 	sub	r11,r6,-20
8000a712:	50 12       	stdsp	sp[0x4],r2
8000a714:	ea ca ff ec 	sub	r10,r5,-20
8000a718:	c4 48       	rjmp	8000a7a0 <__multiply+0xe4>
8000a71a:	94 95       	ld.uh	r5,r10[0x2]
8000a71c:	58 05       	cp.w	r5,0
8000a71e:	c2 00       	breq	8000a75e <__multiply+0xa2>
8000a720:	12 98       	mov	r8,r9
8000a722:	16 96       	mov	r6,r11
8000a724:	30 0e       	mov	lr,0
8000a726:	50 09       	stdsp	sp[0x0],r9
8000a728:	0d 02       	ld.w	r2,r6++
8000a72a:	e4 00 16 10 	lsr	r0,r2,0x10
8000a72e:	70 01       	ld.w	r1,r8[0x0]
8000a730:	70 09       	ld.w	r9,r8[0x0]
8000a732:	b1 81       	lsr	r1,0x10
8000a734:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a738:	e0 05 03 41 	mac	r1,r0,r5
8000a73c:	ab 32       	mul	r2,r5
8000a73e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a742:	00 02       	add	r2,r0
8000a744:	e4 0e 00 0e 	add	lr,r2,lr
8000a748:	b0 1e       	st.h	r8[0x2],lr
8000a74a:	b1 8e       	lsr	lr,0x10
8000a74c:	1c 01       	add	r1,lr
8000a74e:	b0 01       	st.h	r8[0x0],r1
8000a750:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a754:	2f c8       	sub	r8,-4
8000a756:	06 36       	cp.w	r6,r3
8000a758:	ce 83       	brcs	8000a728 <__multiply+0x6c>
8000a75a:	40 09       	lddsp	r9,sp[0x0]
8000a75c:	91 0e       	st.w	r8[0x0],lr
8000a75e:	94 86       	ld.uh	r6,r10[0x0]
8000a760:	58 06       	cp.w	r6,0
8000a762:	c1 d0       	breq	8000a79c <__multiply+0xe0>
8000a764:	72 02       	ld.w	r2,r9[0x0]
8000a766:	12 98       	mov	r8,r9
8000a768:	16 9e       	mov	lr,r11
8000a76a:	30 05       	mov	r5,0
8000a76c:	b0 12       	st.h	r8[0x2],r2
8000a76e:	1d 01       	ld.w	r1,lr++
8000a770:	90 82       	ld.uh	r2,r8[0x0]
8000a772:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a776:	ad 30       	mul	r0,r6
8000a778:	e0 02 00 02 	add	r2,r0,r2
8000a77c:	e4 05 00 05 	add	r5,r2,r5
8000a780:	b0 05       	st.h	r8[0x0],r5
8000a782:	b1 85       	lsr	r5,0x10
8000a784:	b1 81       	lsr	r1,0x10
8000a786:	2f c8       	sub	r8,-4
8000a788:	ad 31       	mul	r1,r6
8000a78a:	90 92       	ld.uh	r2,r8[0x2]
8000a78c:	e2 02 00 02 	add	r2,r1,r2
8000a790:	0a 02       	add	r2,r5
8000a792:	e4 05 16 10 	lsr	r5,r2,0x10
8000a796:	06 3e       	cp.w	lr,r3
8000a798:	ce a3       	brcs	8000a76c <__multiply+0xb0>
8000a79a:	91 02       	st.w	r8[0x0],r2
8000a79c:	2f ca       	sub	r10,-4
8000a79e:	2f c9       	sub	r9,-4
8000a7a0:	40 18       	lddsp	r8,sp[0x4]
8000a7a2:	10 3a       	cp.w	r10,r8
8000a7a4:	cb b3       	brcs	8000a71a <__multiply+0x5e>
8000a7a6:	c0 28       	rjmp	8000a7aa <__multiply+0xee>
8000a7a8:	20 17       	sub	r7,1
8000a7aa:	58 07       	cp.w	r7,0
8000a7ac:	e0 8a 00 05 	brle	8000a7b6 <__multiply+0xfa>
8000a7b0:	09 48       	ld.w	r8,--r4
8000a7b2:	58 08       	cp.w	r8,0
8000a7b4:	cf a0       	breq	8000a7a8 <__multiply+0xec>
8000a7b6:	99 47       	st.w	r12[0x10],r7
8000a7b8:	2f ed       	sub	sp,-8
8000a7ba:	d8 32       	popm	r0-r7,pc

8000a7bc <__i2b>:
8000a7bc:	d4 21       	pushm	r4-r7,lr
8000a7be:	16 97       	mov	r7,r11
8000a7c0:	30 1b       	mov	r11,1
8000a7c2:	c4 9e       	rcall	8000a454 <_Balloc>
8000a7c4:	30 19       	mov	r9,1
8000a7c6:	99 57       	st.w	r12[0x14],r7
8000a7c8:	99 49       	st.w	r12[0x10],r9
8000a7ca:	d8 22       	popm	r4-r7,pc

8000a7cc <__multadd>:
8000a7cc:	d4 31       	pushm	r0-r7,lr
8000a7ce:	30 08       	mov	r8,0
8000a7d0:	12 95       	mov	r5,r9
8000a7d2:	16 97       	mov	r7,r11
8000a7d4:	18 96       	mov	r6,r12
8000a7d6:	76 44       	ld.w	r4,r11[0x10]
8000a7d8:	f6 c9 ff ec 	sub	r9,r11,-20
8000a7dc:	72 0b       	ld.w	r11,r9[0x0]
8000a7de:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a7e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a7e6:	f4 0c 02 4c 	mul	r12,r10,r12
8000a7ea:	f4 0b 03 45 	mac	r5,r10,r11
8000a7ee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a7f2:	b1 85       	lsr	r5,0x10
8000a7f4:	18 05       	add	r5,r12
8000a7f6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a7fa:	f8 0b 00 0b 	add	r11,r12,r11
8000a7fe:	12 ab       	st.w	r9++,r11
8000a800:	2f f8       	sub	r8,-1
8000a802:	b1 85       	lsr	r5,0x10
8000a804:	08 38       	cp.w	r8,r4
8000a806:	ce b5       	brlt	8000a7dc <__multadd+0x10>
8000a808:	58 05       	cp.w	r5,0
8000a80a:	c1 c0       	breq	8000a842 <__multadd+0x76>
8000a80c:	6e 28       	ld.w	r8,r7[0x8]
8000a80e:	10 34       	cp.w	r4,r8
8000a810:	c1 35       	brlt	8000a836 <__multadd+0x6a>
8000a812:	6e 1b       	ld.w	r11,r7[0x4]
8000a814:	0c 9c       	mov	r12,r6
8000a816:	2f fb       	sub	r11,-1
8000a818:	c1 ee       	rcall	8000a454 <_Balloc>
8000a81a:	6e 4a       	ld.w	r10,r7[0x10]
8000a81c:	ee cb ff f4 	sub	r11,r7,-12
8000a820:	18 93       	mov	r3,r12
8000a822:	2f ea       	sub	r10,-2
8000a824:	2f 4c       	sub	r12,-12
8000a826:	a3 6a       	lsl	r10,0x2
8000a828:	fe b0 de 70 	rcall	80006508 <memcpy>
8000a82c:	0e 9b       	mov	r11,r7
8000a82e:	0c 9c       	mov	r12,r6
8000a830:	fe b0 fd f8 	rcall	8000a420 <_Bfree>
8000a834:	06 97       	mov	r7,r3
8000a836:	e8 c8 ff ff 	sub	r8,r4,-1
8000a83a:	2f b4       	sub	r4,-5
8000a83c:	8f 48       	st.w	r7[0x10],r8
8000a83e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a842:	0e 9c       	mov	r12,r7
8000a844:	d8 32       	popm	r0-r7,pc
8000a846:	d7 03       	nop

8000a848 <__pow5mult>:
8000a848:	d4 31       	pushm	r0-r7,lr
8000a84a:	14 96       	mov	r6,r10
8000a84c:	18 97       	mov	r7,r12
8000a84e:	16 94       	mov	r4,r11
8000a850:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a854:	c0 90       	breq	8000a866 <__pow5mult+0x1e>
8000a856:	20 18       	sub	r8,1
8000a858:	fe c9 dc c4 	sub	r9,pc,-9020
8000a85c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a860:	30 09       	mov	r9,0
8000a862:	cb 5f       	rcall	8000a7cc <__multadd>
8000a864:	18 94       	mov	r4,r12
8000a866:	a3 46       	asr	r6,0x2
8000a868:	c3 40       	breq	8000a8d0 <__pow5mult+0x88>
8000a86a:	6e 95       	ld.w	r5,r7[0x24]
8000a86c:	58 05       	cp.w	r5,0
8000a86e:	c0 91       	brne	8000a880 <__pow5mult+0x38>
8000a870:	31 0c       	mov	r12,16
8000a872:	fe b0 dc 27 	rcall	800060c0 <malloc>
8000a876:	99 35       	st.w	r12[0xc],r5
8000a878:	8f 9c       	st.w	r7[0x24],r12
8000a87a:	99 15       	st.w	r12[0x4],r5
8000a87c:	99 25       	st.w	r12[0x8],r5
8000a87e:	99 05       	st.w	r12[0x0],r5
8000a880:	6e 93       	ld.w	r3,r7[0x24]
8000a882:	66 25       	ld.w	r5,r3[0x8]
8000a884:	58 05       	cp.w	r5,0
8000a886:	c0 c1       	brne	8000a89e <__pow5mult+0x56>
8000a888:	e0 6b 02 71 	mov	r11,625
8000a88c:	0e 9c       	mov	r12,r7
8000a88e:	c9 7f       	rcall	8000a7bc <__i2b>
8000a890:	87 2c       	st.w	r3[0x8],r12
8000a892:	30 08       	mov	r8,0
8000a894:	18 95       	mov	r5,r12
8000a896:	99 08       	st.w	r12[0x0],r8
8000a898:	c0 38       	rjmp	8000a89e <__pow5mult+0x56>
8000a89a:	06 9c       	mov	r12,r3
8000a89c:	18 95       	mov	r5,r12
8000a89e:	ed b6 00 00 	bld	r6,0x0
8000a8a2:	c0 b1       	brne	8000a8b8 <__pow5mult+0x70>
8000a8a4:	08 9b       	mov	r11,r4
8000a8a6:	0a 9a       	mov	r10,r5
8000a8a8:	0e 9c       	mov	r12,r7
8000a8aa:	c0 9f       	rcall	8000a6bc <__multiply>
8000a8ac:	08 9b       	mov	r11,r4
8000a8ae:	18 93       	mov	r3,r12
8000a8b0:	0e 9c       	mov	r12,r7
8000a8b2:	06 94       	mov	r4,r3
8000a8b4:	fe b0 fd b6 	rcall	8000a420 <_Bfree>
8000a8b8:	a1 56       	asr	r6,0x1
8000a8ba:	c0 b0       	breq	8000a8d0 <__pow5mult+0x88>
8000a8bc:	6a 03       	ld.w	r3,r5[0x0]
8000a8be:	58 03       	cp.w	r3,0
8000a8c0:	ce d1       	brne	8000a89a <__pow5mult+0x52>
8000a8c2:	0a 9a       	mov	r10,r5
8000a8c4:	0a 9b       	mov	r11,r5
8000a8c6:	0e 9c       	mov	r12,r7
8000a8c8:	cf ae       	rcall	8000a6bc <__multiply>
8000a8ca:	8b 0c       	st.w	r5[0x0],r12
8000a8cc:	99 03       	st.w	r12[0x0],r3
8000a8ce:	ce 7b       	rjmp	8000a89c <__pow5mult+0x54>
8000a8d0:	08 9c       	mov	r12,r4
8000a8d2:	d8 32       	popm	r0-r7,pc

8000a8d4 <__isinfd>:
8000a8d4:	14 98       	mov	r8,r10
8000a8d6:	fc 19 7f f0 	movh	r9,0x7ff0
8000a8da:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a8de:	f0 0b 11 00 	rsub	r11,r8,0
8000a8e2:	f7 e8 10 08 	or	r8,r11,r8
8000a8e6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a8ea:	f2 08 01 08 	sub	r8,r9,r8
8000a8ee:	f0 0c 11 00 	rsub	r12,r8,0
8000a8f2:	f9 e8 10 08 	or	r8,r12,r8
8000a8f6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a8fa:	2f fc       	sub	r12,-1
8000a8fc:	5e fc       	retal	r12

8000a8fe <__isnand>:
8000a8fe:	14 98       	mov	r8,r10
8000a900:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a904:	f0 0c 11 00 	rsub	r12,r8,0
8000a908:	10 4c       	or	r12,r8
8000a90a:	fc 18 7f f0 	movh	r8,0x7ff0
8000a90e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a912:	f0 0c 01 0c 	sub	r12,r8,r12
8000a916:	bf 9c       	lsr	r12,0x1f
8000a918:	5e fc       	retal	r12
8000a91a:	d7 03       	nop

8000a91c <__sclose>:
8000a91c:	d4 01       	pushm	lr
8000a91e:	96 7b       	ld.sh	r11,r11[0xe]
8000a920:	c8 2c       	rcall	8000aa24 <_close_r>
8000a922:	d8 02       	popm	pc

8000a924 <__sseek>:
8000a924:	d4 21       	pushm	r4-r7,lr
8000a926:	16 97       	mov	r7,r11
8000a928:	96 7b       	ld.sh	r11,r11[0xe]
8000a92a:	c0 3d       	rcall	8000ab30 <_lseek_r>
8000a92c:	8e 68       	ld.sh	r8,r7[0xc]
8000a92e:	10 99       	mov	r9,r8
8000a930:	ad c8       	cbr	r8,0xc
8000a932:	ad a9       	sbr	r9,0xc
8000a934:	5b fc       	cp.w	r12,-1
8000a936:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000a93a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000a93e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000a942:	d8 22       	popm	r4-r7,pc

8000a944 <__swrite>:
8000a944:	d4 21       	pushm	r4-r7,lr
8000a946:	96 68       	ld.sh	r8,r11[0xc]
8000a948:	16 97       	mov	r7,r11
8000a94a:	14 95       	mov	r5,r10
8000a94c:	12 94       	mov	r4,r9
8000a94e:	e2 18 01 00 	andl	r8,0x100,COH
8000a952:	18 96       	mov	r6,r12
8000a954:	c0 50       	breq	8000a95e <__swrite+0x1a>
8000a956:	30 29       	mov	r9,2
8000a958:	30 0a       	mov	r10,0
8000a95a:	96 7b       	ld.sh	r11,r11[0xe]
8000a95c:	ce ac       	rcall	8000ab30 <_lseek_r>
8000a95e:	8e 68       	ld.sh	r8,r7[0xc]
8000a960:	ad c8       	cbr	r8,0xc
8000a962:	08 99       	mov	r9,r4
8000a964:	0a 9a       	mov	r10,r5
8000a966:	8e 7b       	ld.sh	r11,r7[0xe]
8000a968:	0c 9c       	mov	r12,r6
8000a96a:	ae 68       	st.h	r7[0xc],r8
8000a96c:	c1 cc       	rcall	8000a9a4 <_write_r>
8000a96e:	d8 22       	popm	r4-r7,pc

8000a970 <__sread>:
8000a970:	d4 21       	pushm	r4-r7,lr
8000a972:	16 97       	mov	r7,r11
8000a974:	96 7b       	ld.sh	r11,r11[0xe]
8000a976:	cf 1c       	rcall	8000ab58 <_read_r>
8000a978:	c0 65       	brlt	8000a984 <__sread+0x14>
8000a97a:	6f 58       	ld.w	r8,r7[0x54]
8000a97c:	18 08       	add	r8,r12
8000a97e:	ef 48 00 54 	st.w	r7[84],r8
8000a982:	d8 22       	popm	r4-r7,pc
8000a984:	8e 68       	ld.sh	r8,r7[0xc]
8000a986:	ad c8       	cbr	r8,0xc
8000a988:	ae 68       	st.h	r7[0xc],r8
8000a98a:	d8 22       	popm	r4-r7,pc

8000a98c <strlen>:
8000a98c:	30 09       	mov	r9,0
8000a98e:	18 98       	mov	r8,r12
8000a990:	c0 28       	rjmp	8000a994 <strlen+0x8>
8000a992:	2f f8       	sub	r8,-1
8000a994:	11 8a       	ld.ub	r10,r8[0x0]
8000a996:	f2 0a 18 00 	cp.b	r10,r9
8000a99a:	cf c1       	brne	8000a992 <strlen+0x6>
8000a99c:	f0 0c 01 0c 	sub	r12,r8,r12
8000a9a0:	5e fc       	retal	r12
8000a9a2:	d7 03       	nop

8000a9a4 <_write_r>:
8000a9a4:	d4 21       	pushm	r4-r7,lr
8000a9a6:	16 98       	mov	r8,r11
8000a9a8:	18 97       	mov	r7,r12
8000a9aa:	10 9c       	mov	r12,r8
8000a9ac:	30 08       	mov	r8,0
8000a9ae:	14 9b       	mov	r11,r10
8000a9b0:	e0 66 40 e4 	mov	r6,16612
8000a9b4:	12 9a       	mov	r10,r9
8000a9b6:	8d 08       	st.w	r6[0x0],r8
8000a9b8:	fe b0 d1 c8 	rcall	80004d48 <_write>
8000a9bc:	5b fc       	cp.w	r12,-1
8000a9be:	c0 51       	brne	8000a9c8 <_write_r+0x24>
8000a9c0:	6c 08       	ld.w	r8,r6[0x0]
8000a9c2:	58 08       	cp.w	r8,0
8000a9c4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a9c8:	d8 22       	popm	r4-r7,pc
8000a9ca:	d7 03       	nop

8000a9cc <_calloc_r>:
8000a9cc:	d4 21       	pushm	r4-r7,lr
8000a9ce:	f4 0b 02 4b 	mul	r11,r10,r11
8000a9d2:	fe b0 db 7f 	rcall	800060d0 <_malloc_r>
8000a9d6:	18 97       	mov	r7,r12
8000a9d8:	c2 30       	breq	8000aa1e <_calloc_r+0x52>
8000a9da:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000a9de:	e0 1a ff fc 	andl	r10,0xfffc
8000a9e2:	20 4a       	sub	r10,4
8000a9e4:	e0 4a 00 24 	cp.w	r10,36
8000a9e8:	e0 8b 00 18 	brhi	8000aa18 <_calloc_r+0x4c>
8000a9ec:	18 98       	mov	r8,r12
8000a9ee:	59 3a       	cp.w	r10,19
8000a9f0:	e0 88 00 0f 	brls	8000aa0e <_calloc_r+0x42>
8000a9f4:	30 09       	mov	r9,0
8000a9f6:	10 a9       	st.w	r8++,r9
8000a9f8:	10 a9       	st.w	r8++,r9
8000a9fa:	59 ba       	cp.w	r10,27
8000a9fc:	e0 88 00 09 	brls	8000aa0e <_calloc_r+0x42>
8000aa00:	10 a9       	st.w	r8++,r9
8000aa02:	10 a9       	st.w	r8++,r9
8000aa04:	e0 4a 00 24 	cp.w	r10,36
8000aa08:	c0 31       	brne	8000aa0e <_calloc_r+0x42>
8000aa0a:	10 a9       	st.w	r8++,r9
8000aa0c:	10 a9       	st.w	r8++,r9
8000aa0e:	30 09       	mov	r9,0
8000aa10:	10 a9       	st.w	r8++,r9
8000aa12:	91 19       	st.w	r8[0x4],r9
8000aa14:	91 09       	st.w	r8[0x0],r9
8000aa16:	c0 48       	rjmp	8000aa1e <_calloc_r+0x52>
8000aa18:	30 0b       	mov	r11,0
8000aa1a:	fe b0 de 1b 	rcall	80006650 <memset>
8000aa1e:	0e 9c       	mov	r12,r7
8000aa20:	d8 22       	popm	r4-r7,pc
8000aa22:	d7 03       	nop

8000aa24 <_close_r>:
8000aa24:	d4 21       	pushm	r4-r7,lr
8000aa26:	30 08       	mov	r8,0
8000aa28:	18 97       	mov	r7,r12
8000aa2a:	e0 66 40 e4 	mov	r6,16612
8000aa2e:	16 9c       	mov	r12,r11
8000aa30:	8d 08       	st.w	r6[0x0],r8
8000aa32:	fe b0 df b5 	rcall	8000699c <_close>
8000aa36:	5b fc       	cp.w	r12,-1
8000aa38:	c0 51       	brne	8000aa42 <_close_r+0x1e>
8000aa3a:	6c 08       	ld.w	r8,r6[0x0]
8000aa3c:	58 08       	cp.w	r8,0
8000aa3e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aa42:	d8 22       	popm	r4-r7,pc

8000aa44 <_fclose_r>:
8000aa44:	d4 21       	pushm	r4-r7,lr
8000aa46:	18 96       	mov	r6,r12
8000aa48:	16 97       	mov	r7,r11
8000aa4a:	58 0b       	cp.w	r11,0
8000aa4c:	c0 31       	brne	8000aa52 <_fclose_r+0xe>
8000aa4e:	16 95       	mov	r5,r11
8000aa50:	c5 38       	rjmp	8000aaf6 <_fclose_r+0xb2>
8000aa52:	fe b0 f8 a9 	rcall	80009ba4 <__sfp_lock_acquire>
8000aa56:	58 06       	cp.w	r6,0
8000aa58:	c0 70       	breq	8000aa66 <_fclose_r+0x22>
8000aa5a:	6c 68       	ld.w	r8,r6[0x18]
8000aa5c:	58 08       	cp.w	r8,0
8000aa5e:	c0 41       	brne	8000aa66 <_fclose_r+0x22>
8000aa60:	0c 9c       	mov	r12,r6
8000aa62:	fe b0 f8 f3 	rcall	80009c48 <__sinit>
8000aa66:	fe c8 df 76 	sub	r8,pc,-8330
8000aa6a:	10 37       	cp.w	r7,r8
8000aa6c:	c0 31       	brne	8000aa72 <_fclose_r+0x2e>
8000aa6e:	6c 07       	ld.w	r7,r6[0x0]
8000aa70:	c0 c8       	rjmp	8000aa88 <_fclose_r+0x44>
8000aa72:	fe c8 df 62 	sub	r8,pc,-8350
8000aa76:	10 37       	cp.w	r7,r8
8000aa78:	c0 31       	brne	8000aa7e <_fclose_r+0x3a>
8000aa7a:	6c 17       	ld.w	r7,r6[0x4]
8000aa7c:	c0 68       	rjmp	8000aa88 <_fclose_r+0x44>
8000aa7e:	fe c8 df 4e 	sub	r8,pc,-8370
8000aa82:	10 37       	cp.w	r7,r8
8000aa84:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa88:	8e 69       	ld.sh	r9,r7[0xc]
8000aa8a:	30 08       	mov	r8,0
8000aa8c:	f0 09 19 00 	cp.h	r9,r8
8000aa90:	c0 51       	brne	8000aa9a <_fclose_r+0x56>
8000aa92:	fe b0 f8 8a 	rcall	80009ba6 <__sfp_lock_release>
8000aa96:	30 05       	mov	r5,0
8000aa98:	c2 f8       	rjmp	8000aaf6 <_fclose_r+0xb2>
8000aa9a:	0e 9b       	mov	r11,r7
8000aa9c:	0c 9c       	mov	r12,r6
8000aa9e:	fe b0 f7 fd 	rcall	80009a98 <_fflush_r>
8000aaa2:	6e c8       	ld.w	r8,r7[0x30]
8000aaa4:	18 95       	mov	r5,r12
8000aaa6:	58 08       	cp.w	r8,0
8000aaa8:	c0 60       	breq	8000aab4 <_fclose_r+0x70>
8000aaaa:	6e 8b       	ld.w	r11,r7[0x20]
8000aaac:	0c 9c       	mov	r12,r6
8000aaae:	5d 18       	icall	r8
8000aab0:	f9 b5 05 ff 	movlt	r5,-1
8000aab4:	8e 68       	ld.sh	r8,r7[0xc]
8000aab6:	ed b8 00 07 	bld	r8,0x7
8000aaba:	c0 51       	brne	8000aac4 <_fclose_r+0x80>
8000aabc:	6e 4b       	ld.w	r11,r7[0x10]
8000aabe:	0c 9c       	mov	r12,r6
8000aac0:	fe b0 f9 5e 	rcall	80009d7c <_free_r>
8000aac4:	6e db       	ld.w	r11,r7[0x34]
8000aac6:	58 0b       	cp.w	r11,0
8000aac8:	c0 a0       	breq	8000aadc <_fclose_r+0x98>
8000aaca:	ee c8 ff bc 	sub	r8,r7,-68
8000aace:	10 3b       	cp.w	r11,r8
8000aad0:	c0 40       	breq	8000aad8 <_fclose_r+0x94>
8000aad2:	0c 9c       	mov	r12,r6
8000aad4:	fe b0 f9 54 	rcall	80009d7c <_free_r>
8000aad8:	30 08       	mov	r8,0
8000aada:	8f d8       	st.w	r7[0x34],r8
8000aadc:	6f 2b       	ld.w	r11,r7[0x48]
8000aade:	58 0b       	cp.w	r11,0
8000aae0:	c0 70       	breq	8000aaee <_fclose_r+0xaa>
8000aae2:	0c 9c       	mov	r12,r6
8000aae4:	fe b0 f9 4c 	rcall	80009d7c <_free_r>
8000aae8:	30 08       	mov	r8,0
8000aaea:	ef 48 00 48 	st.w	r7[72],r8
8000aaee:	30 08       	mov	r8,0
8000aaf0:	ae 68       	st.h	r7[0xc],r8
8000aaf2:	fe b0 f8 5a 	rcall	80009ba6 <__sfp_lock_release>
8000aaf6:	0a 9c       	mov	r12,r5
8000aaf8:	d8 22       	popm	r4-r7,pc
8000aafa:	d7 03       	nop

8000aafc <fclose>:
8000aafc:	d4 01       	pushm	lr
8000aafe:	e0 68 0a 2c 	mov	r8,2604
8000ab02:	18 9b       	mov	r11,r12
8000ab04:	70 0c       	ld.w	r12,r8[0x0]
8000ab06:	c9 ff       	rcall	8000aa44 <_fclose_r>
8000ab08:	d8 02       	popm	pc
8000ab0a:	d7 03       	nop

8000ab0c <_fstat_r>:
8000ab0c:	d4 21       	pushm	r4-r7,lr
8000ab0e:	16 98       	mov	r8,r11
8000ab10:	18 97       	mov	r7,r12
8000ab12:	10 9c       	mov	r12,r8
8000ab14:	30 08       	mov	r8,0
8000ab16:	e0 66 40 e4 	mov	r6,16612
8000ab1a:	14 9b       	mov	r11,r10
8000ab1c:	8d 08       	st.w	r6[0x0],r8
8000ab1e:	fe b0 df 67 	rcall	800069ec <_fstat>
8000ab22:	5b fc       	cp.w	r12,-1
8000ab24:	c0 51       	brne	8000ab2e <_fstat_r+0x22>
8000ab26:	6c 08       	ld.w	r8,r6[0x0]
8000ab28:	58 08       	cp.w	r8,0
8000ab2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab2e:	d8 22       	popm	r4-r7,pc

8000ab30 <_lseek_r>:
8000ab30:	d4 21       	pushm	r4-r7,lr
8000ab32:	16 98       	mov	r8,r11
8000ab34:	18 97       	mov	r7,r12
8000ab36:	10 9c       	mov	r12,r8
8000ab38:	30 08       	mov	r8,0
8000ab3a:	14 9b       	mov	r11,r10
8000ab3c:	e0 66 40 e4 	mov	r6,16612
8000ab40:	12 9a       	mov	r10,r9
8000ab42:	8d 08       	st.w	r6[0x0],r8
8000ab44:	fe b0 df 36 	rcall	800069b0 <_lseek>
8000ab48:	5b fc       	cp.w	r12,-1
8000ab4a:	c0 51       	brne	8000ab54 <_lseek_r+0x24>
8000ab4c:	6c 08       	ld.w	r8,r6[0x0]
8000ab4e:	58 08       	cp.w	r8,0
8000ab50:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab54:	d8 22       	popm	r4-r7,pc
8000ab56:	d7 03       	nop

8000ab58 <_read_r>:
8000ab58:	d4 21       	pushm	r4-r7,lr
8000ab5a:	16 98       	mov	r8,r11
8000ab5c:	18 97       	mov	r7,r12
8000ab5e:	10 9c       	mov	r12,r8
8000ab60:	30 08       	mov	r8,0
8000ab62:	14 9b       	mov	r11,r10
8000ab64:	e0 66 40 e4 	mov	r6,16612
8000ab68:	12 9a       	mov	r10,r9
8000ab6a:	8d 08       	st.w	r6[0x0],r8
8000ab6c:	fe b0 d0 ce 	rcall	80004d08 <_read>
8000ab70:	5b fc       	cp.w	r12,-1
8000ab72:	c0 51       	brne	8000ab7c <_read_r+0x24>
8000ab74:	6c 08       	ld.w	r8,r6[0x0]
8000ab76:	58 08       	cp.w	r8,0
8000ab78:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab7c:	d8 22       	popm	r4-r7,pc
8000ab7e:	d7 03       	nop

8000ab80 <__avr32_f64_mul>:
8000ab80:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ab84:	e0 80 00 dc 	breq	8000ad3c <__avr32_f64_mul_op1_zero>
8000ab88:	d4 21       	pushm	r4-r7,lr
8000ab8a:	f7 e9 20 0e 	eor	lr,r11,r9
8000ab8e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ab92:	30 15       	mov	r5,1
8000ab94:	c4 30       	breq	8000ac1a <__avr32_f64_mul_op1_subnormal>
8000ab96:	ab 6b       	lsl	r11,0xa
8000ab98:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ab9c:	ab 6a       	lsl	r10,0xa
8000ab9e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000aba2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000aba6:	c5 c0       	breq	8000ac5e <__avr32_f64_mul_op2_subnormal>
8000aba8:	a1 78       	lsl	r8,0x1
8000abaa:	5c f9       	rol	r9
8000abac:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000abb0:	e0 47 07 ff 	cp.w	r7,2047
8000abb4:	c7 70       	breq	8000aca2 <__avr32_f64_mul_op_nan_or_inf>
8000abb6:	e0 46 07 ff 	cp.w	r6,2047
8000abba:	c7 40       	breq	8000aca2 <__avr32_f64_mul_op_nan_or_inf>
8000abbc:	ee 06 00 0c 	add	r12,r7,r6
8000abc0:	e0 2c 03 fe 	sub	r12,1022
8000abc4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000abc8:	f4 09 07 44 	macu.d	r4,r10,r9
8000abcc:	f4 08 06 46 	mulu.d	r6,r10,r8
8000abd0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000abd4:	08 07       	add	r7,r4
8000abd6:	f4 05 00 4a 	adc	r10,r10,r5
8000abda:	5c 0b       	acr	r11
8000abdc:	ed bb 00 14 	bld	r11,0x14
8000abe0:	c0 50       	breq	8000abea <__avr32_f64_mul+0x6a>
8000abe2:	a1 77       	lsl	r7,0x1
8000abe4:	5c fa       	rol	r10
8000abe6:	5c fb       	rol	r11
8000abe8:	20 1c       	sub	r12,1
8000abea:	58 0c       	cp.w	r12,0
8000abec:	e0 8a 00 6f 	brle	8000acca <__avr32_f64_mul_res_subnormal>
8000abf0:	e0 4c 07 ff 	cp.w	r12,2047
8000abf4:	e0 84 00 9c 	brge	8000ad2c <__avr32_f64_mul_res_inf>
8000abf8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000abfc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ac00:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ac04:	ee 17 80 00 	eorh	r7,0x8000
8000ac08:	f1 b7 04 20 	satu	r7,0x1
8000ac0c:	0e 0a       	add	r10,r7
8000ac0e:	5c 0b       	acr	r11
8000ac10:	ed be 00 1f 	bld	lr,0x1f
8000ac14:	ef bb 00 1f 	bst	r11,0x1f
8000ac18:	d8 22       	popm	r4-r7,pc

8000ac1a <__avr32_f64_mul_op1_subnormal>:
8000ac1a:	e4 1b 00 0f 	andh	r11,0xf
8000ac1e:	f4 0c 12 00 	clz	r12,r10
8000ac22:	f6 06 12 00 	clz	r6,r11
8000ac26:	f7 bc 03 e1 	sublo	r12,-31
8000ac2a:	f8 06 17 30 	movlo	r6,r12
8000ac2e:	f7 b6 02 01 	subhs	r6,1
8000ac32:	e0 46 00 20 	cp.w	r6,32
8000ac36:	c0 d4       	brge	8000ac50 <__avr32_f64_mul_op1_subnormal+0x36>
8000ac38:	ec 0c 11 20 	rsub	r12,r6,32
8000ac3c:	f6 06 09 4b 	lsl	r11,r11,r6
8000ac40:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ac44:	18 4b       	or	r11,r12
8000ac46:	f4 06 09 4a 	lsl	r10,r10,r6
8000ac4a:	20 b6       	sub	r6,11
8000ac4c:	0c 17       	sub	r7,r6
8000ac4e:	ca ab       	rjmp	8000aba2 <__avr32_f64_mul+0x22>
8000ac50:	f4 06 09 4b 	lsl	r11,r10,r6
8000ac54:	c6 40       	breq	8000ad1c <__avr32_f64_mul_res_zero>
8000ac56:	30 0a       	mov	r10,0
8000ac58:	20 b6       	sub	r6,11
8000ac5a:	0c 17       	sub	r7,r6
8000ac5c:	ca 3b       	rjmp	8000aba2 <__avr32_f64_mul+0x22>

8000ac5e <__avr32_f64_mul_op2_subnormal>:
8000ac5e:	e4 19 00 0f 	andh	r9,0xf
8000ac62:	f0 0c 12 00 	clz	r12,r8
8000ac66:	f2 05 12 00 	clz	r5,r9
8000ac6a:	f7 bc 03 ea 	sublo	r12,-22
8000ac6e:	f8 05 17 30 	movlo	r5,r12
8000ac72:	f7 b5 02 0a 	subhs	r5,10
8000ac76:	e0 45 00 20 	cp.w	r5,32
8000ac7a:	c0 d4       	brge	8000ac94 <__avr32_f64_mul_op2_subnormal+0x36>
8000ac7c:	ea 0c 11 20 	rsub	r12,r5,32
8000ac80:	f2 05 09 49 	lsl	r9,r9,r5
8000ac84:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ac88:	18 49       	or	r9,r12
8000ac8a:	f0 05 09 48 	lsl	r8,r8,r5
8000ac8e:	20 25       	sub	r5,2
8000ac90:	0a 16       	sub	r6,r5
8000ac92:	c8 fb       	rjmp	8000abb0 <__avr32_f64_mul+0x30>
8000ac94:	f0 05 09 49 	lsl	r9,r8,r5
8000ac98:	c4 20       	breq	8000ad1c <__avr32_f64_mul_res_zero>
8000ac9a:	30 08       	mov	r8,0
8000ac9c:	20 25       	sub	r5,2
8000ac9e:	0a 16       	sub	r6,r5
8000aca0:	c8 8b       	rjmp	8000abb0 <__avr32_f64_mul+0x30>

8000aca2 <__avr32_f64_mul_op_nan_or_inf>:
8000aca2:	e4 19 00 0f 	andh	r9,0xf
8000aca6:	e4 1b 00 0f 	andh	r11,0xf
8000acaa:	14 4b       	or	r11,r10
8000acac:	10 49       	or	r9,r8
8000acae:	e0 47 07 ff 	cp.w	r7,2047
8000acb2:	c0 91       	brne	8000acc4 <__avr32_f64_mul_op1_not_naninf>
8000acb4:	58 0b       	cp.w	r11,0
8000acb6:	c3 81       	brne	8000ad26 <__avr32_f64_mul_res_nan>
8000acb8:	e0 46 07 ff 	cp.w	r6,2047
8000acbc:	c3 81       	brne	8000ad2c <__avr32_f64_mul_res_inf>
8000acbe:	58 09       	cp.w	r9,0
8000acc0:	c3 60       	breq	8000ad2c <__avr32_f64_mul_res_inf>
8000acc2:	c3 28       	rjmp	8000ad26 <__avr32_f64_mul_res_nan>

8000acc4 <__avr32_f64_mul_op1_not_naninf>:
8000acc4:	58 09       	cp.w	r9,0
8000acc6:	c3 30       	breq	8000ad2c <__avr32_f64_mul_res_inf>
8000acc8:	c2 f8       	rjmp	8000ad26 <__avr32_f64_mul_res_nan>

8000acca <__avr32_f64_mul_res_subnormal>:
8000acca:	5c 3c       	neg	r12
8000accc:	2f fc       	sub	r12,-1
8000acce:	f1 bc 04 c0 	satu	r12,0x6
8000acd2:	e0 4c 00 20 	cp.w	r12,32
8000acd6:	c1 14       	brge	8000acf8 <__avr32_f64_mul_res_subnormal+0x2e>
8000acd8:	f8 08 11 20 	rsub	r8,r12,32
8000acdc:	0e 46       	or	r6,r7
8000acde:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ace2:	f4 08 09 49 	lsl	r9,r10,r8
8000ace6:	12 47       	or	r7,r9
8000ace8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000acec:	f6 08 09 49 	lsl	r9,r11,r8
8000acf0:	12 4a       	or	r10,r9
8000acf2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000acf6:	c8 3b       	rjmp	8000abfc <__avr32_f64_mul+0x7c>
8000acf8:	f8 08 11 20 	rsub	r8,r12,32
8000acfc:	f9 b9 00 00 	moveq	r9,0
8000ad00:	c0 30       	breq	8000ad06 <__avr32_f64_mul_res_subnormal+0x3c>
8000ad02:	f6 08 09 49 	lsl	r9,r11,r8
8000ad06:	0e 46       	or	r6,r7
8000ad08:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ad0c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ad10:	f3 ea 10 07 	or	r7,r9,r10
8000ad14:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ad18:	30 0b       	mov	r11,0
8000ad1a:	c7 1b       	rjmp	8000abfc <__avr32_f64_mul+0x7c>

8000ad1c <__avr32_f64_mul_res_zero>:
8000ad1c:	1c 9b       	mov	r11,lr
8000ad1e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ad22:	30 0a       	mov	r10,0
8000ad24:	d8 22       	popm	r4-r7,pc

8000ad26 <__avr32_f64_mul_res_nan>:
8000ad26:	3f fb       	mov	r11,-1
8000ad28:	3f fa       	mov	r10,-1
8000ad2a:	d8 22       	popm	r4-r7,pc

8000ad2c <__avr32_f64_mul_res_inf>:
8000ad2c:	f0 6b 00 00 	mov	r11,-1048576
8000ad30:	ed be 00 1f 	bld	lr,0x1f
8000ad34:	ef bb 00 1f 	bst	r11,0x1f
8000ad38:	30 0a       	mov	r10,0
8000ad3a:	d8 22       	popm	r4-r7,pc

8000ad3c <__avr32_f64_mul_op1_zero>:
8000ad3c:	f7 e9 20 0b 	eor	r11,r11,r9
8000ad40:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ad44:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ad48:	e0 4c 07 ff 	cp.w	r12,2047
8000ad4c:	5e 1c       	retne	r12
8000ad4e:	3f fa       	mov	r10,-1
8000ad50:	3f fb       	mov	r11,-1
8000ad52:	5e fc       	retal	r12

8000ad54 <__avr32_f64_sub_from_add>:
8000ad54:	ee 19 80 00 	eorh	r9,0x8000

8000ad58 <__avr32_f64_sub>:
8000ad58:	f7 e9 20 0c 	eor	r12,r11,r9
8000ad5c:	e0 86 00 ca 	brmi	8000aef0 <__avr32_f64_add_from_sub>
8000ad60:	eb cd 40 e0 	pushm	r5-r7,lr
8000ad64:	16 9c       	mov	r12,r11
8000ad66:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ad6a:	bf db       	cbr	r11,0x1f
8000ad6c:	bf d9       	cbr	r9,0x1f
8000ad6e:	10 3a       	cp.w	r10,r8
8000ad70:	f2 0b 13 00 	cpc	r11,r9
8000ad74:	c0 92       	brcc	8000ad86 <__avr32_f64_sub+0x2e>
8000ad76:	16 97       	mov	r7,r11
8000ad78:	12 9b       	mov	r11,r9
8000ad7a:	0e 99       	mov	r9,r7
8000ad7c:	14 97       	mov	r7,r10
8000ad7e:	10 9a       	mov	r10,r8
8000ad80:	0e 98       	mov	r8,r7
8000ad82:	ee 1c 80 00 	eorh	r12,0x8000
8000ad86:	f6 07 16 14 	lsr	r7,r11,0x14
8000ad8a:	ab 7b       	lsl	r11,0xb
8000ad8c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ad90:	ab 7a       	lsl	r10,0xb
8000ad92:	bf bb       	sbr	r11,0x1f
8000ad94:	f2 06 16 14 	lsr	r6,r9,0x14
8000ad98:	c4 40       	breq	8000ae20 <__avr32_f64_sub_opL_subnormal>
8000ad9a:	ab 79       	lsl	r9,0xb
8000ad9c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ada0:	ab 78       	lsl	r8,0xb
8000ada2:	bf b9       	sbr	r9,0x1f

8000ada4 <__avr32_f64_sub_opL_subnormal_done>:
8000ada4:	e0 47 07 ff 	cp.w	r7,2047
8000ada8:	c4 f0       	breq	8000ae46 <__avr32_f64_sub_opH_nan_or_inf>
8000adaa:	0e 26       	rsub	r6,r7
8000adac:	c1 20       	breq	8000add0 <__avr32_f64_sub_shift_done>
8000adae:	ec 05 11 20 	rsub	r5,r6,32
8000adb2:	e0 46 00 20 	cp.w	r6,32
8000adb6:	c7 c2       	brcc	8000aeae <__avr32_f64_sub_longshift>
8000adb8:	f0 05 09 4e 	lsl	lr,r8,r5
8000adbc:	f2 05 09 45 	lsl	r5,r9,r5
8000adc0:	f0 06 0a 48 	lsr	r8,r8,r6
8000adc4:	f2 06 0a 49 	lsr	r9,r9,r6
8000adc8:	0a 48       	or	r8,r5
8000adca:	58 0e       	cp.w	lr,0
8000adcc:	5f 1e       	srne	lr
8000adce:	1c 48       	or	r8,lr

8000add0 <__avr32_f64_sub_shift_done>:
8000add0:	10 1a       	sub	r10,r8
8000add2:	f6 09 01 4b 	sbc	r11,r11,r9
8000add6:	f6 06 12 00 	clz	r6,r11
8000adda:	c0 e0       	breq	8000adf6 <__avr32_f64_sub_longnormalize_done>
8000addc:	c7 83       	brcs	8000aecc <__avr32_f64_sub_longnormalize>
8000adde:	ec 0e 11 20 	rsub	lr,r6,32
8000ade2:	f6 06 09 4b 	lsl	r11,r11,r6
8000ade6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000adea:	1c 4b       	or	r11,lr
8000adec:	f4 06 09 4a 	lsl	r10,r10,r6
8000adf0:	0c 17       	sub	r7,r6
8000adf2:	e0 8a 00 39 	brle	8000ae64 <__avr32_f64_sub_subnormal_result>

8000adf6 <__avr32_f64_sub_longnormalize_done>:
8000adf6:	f4 09 15 15 	lsl	r9,r10,0x15
8000adfa:	ab 9a       	lsr	r10,0xb
8000adfc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ae00:	ab 9b       	lsr	r11,0xb
8000ae02:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ae06:	18 4b       	or	r11,r12

8000ae08 <__avr32_f64_sub_round>:
8000ae08:	fc 17 80 00 	movh	r7,0x8000
8000ae0c:	ed ba 00 00 	bld	r10,0x0
8000ae10:	f7 b7 01 ff 	subne	r7,-1
8000ae14:	0e 39       	cp.w	r9,r7
8000ae16:	5f 29       	srhs	r9
8000ae18:	12 0a       	add	r10,r9
8000ae1a:	5c 0b       	acr	r11
8000ae1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae20 <__avr32_f64_sub_opL_subnormal>:
8000ae20:	ab 79       	lsl	r9,0xb
8000ae22:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ae26:	ab 78       	lsl	r8,0xb
8000ae28:	f3 e8 10 0e 	or	lr,r9,r8
8000ae2c:	f9 b6 01 01 	movne	r6,1
8000ae30:	ee 0e 11 00 	rsub	lr,r7,0
8000ae34:	f9 b7 00 01 	moveq	r7,1
8000ae38:	ef bb 00 1f 	bst	r11,0x1f
8000ae3c:	f7 ea 10 0e 	or	lr,r11,r10
8000ae40:	f9 b7 00 00 	moveq	r7,0
8000ae44:	cb 0b       	rjmp	8000ada4 <__avr32_f64_sub_opL_subnormal_done>

8000ae46 <__avr32_f64_sub_opH_nan_or_inf>:
8000ae46:	bf db       	cbr	r11,0x1f
8000ae48:	f7 ea 10 0e 	or	lr,r11,r10
8000ae4c:	c0 81       	brne	8000ae5c <__avr32_f64_sub_return_nan>
8000ae4e:	e0 46 07 ff 	cp.w	r6,2047
8000ae52:	c0 50       	breq	8000ae5c <__avr32_f64_sub_return_nan>
8000ae54:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ae58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae5c <__avr32_f64_sub_return_nan>:
8000ae5c:	3f fa       	mov	r10,-1
8000ae5e:	3f fb       	mov	r11,-1
8000ae60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae64 <__avr32_f64_sub_subnormal_result>:
8000ae64:	5c 37       	neg	r7
8000ae66:	2f f7       	sub	r7,-1
8000ae68:	f1 b7 04 c0 	satu	r7,0x6
8000ae6c:	e0 47 00 20 	cp.w	r7,32
8000ae70:	c1 14       	brge	8000ae92 <__avr32_f64_sub_subnormal_result+0x2e>
8000ae72:	ee 08 11 20 	rsub	r8,r7,32
8000ae76:	f4 08 09 49 	lsl	r9,r10,r8
8000ae7a:	5f 16       	srne	r6
8000ae7c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ae80:	0c 4a       	or	r10,r6
8000ae82:	f6 08 09 49 	lsl	r9,r11,r8
8000ae86:	f5 e9 10 0a 	or	r10,r10,r9
8000ae8a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ae8e:	30 07       	mov	r7,0
8000ae90:	cb 3b       	rjmp	8000adf6 <__avr32_f64_sub_longnormalize_done>
8000ae92:	ee 08 11 40 	rsub	r8,r7,64
8000ae96:	f6 08 09 49 	lsl	r9,r11,r8
8000ae9a:	14 49       	or	r9,r10
8000ae9c:	5f 16       	srne	r6
8000ae9e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000aea2:	0c 4a       	or	r10,r6
8000aea4:	30 0b       	mov	r11,0
8000aea6:	30 07       	mov	r7,0
8000aea8:	ca 7b       	rjmp	8000adf6 <__avr32_f64_sub_longnormalize_done>
8000aeaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000aeae <__avr32_f64_sub_longshift>:
8000aeae:	f1 b6 04 c0 	satu	r6,0x6
8000aeb2:	f0 0e 17 00 	moveq	lr,r8
8000aeb6:	c0 40       	breq	8000aebe <__avr32_f64_sub_longshift+0x10>
8000aeb8:	f2 05 09 4e 	lsl	lr,r9,r5
8000aebc:	10 4e       	or	lr,r8
8000aebe:	f2 06 0a 48 	lsr	r8,r9,r6
8000aec2:	30 09       	mov	r9,0
8000aec4:	58 0e       	cp.w	lr,0
8000aec6:	5f 1e       	srne	lr
8000aec8:	1c 48       	or	r8,lr
8000aeca:	c8 3b       	rjmp	8000add0 <__avr32_f64_sub_shift_done>

8000aecc <__avr32_f64_sub_longnormalize>:
8000aecc:	f4 06 12 00 	clz	r6,r10
8000aed0:	f9 b7 03 00 	movlo	r7,0
8000aed4:	f9 b6 03 00 	movlo	r6,0
8000aed8:	f9 bc 03 00 	movlo	r12,0
8000aedc:	f7 b6 02 e0 	subhs	r6,-32
8000aee0:	f4 06 09 4b 	lsl	r11,r10,r6
8000aee4:	30 0a       	mov	r10,0
8000aee6:	0c 17       	sub	r7,r6
8000aee8:	fe 9a ff be 	brle	8000ae64 <__avr32_f64_sub_subnormal_result>
8000aeec:	c8 5b       	rjmp	8000adf6 <__avr32_f64_sub_longnormalize_done>
8000aeee:	d7 03       	nop

8000aef0 <__avr32_f64_add_from_sub>:
8000aef0:	ee 19 80 00 	eorh	r9,0x8000

8000aef4 <__avr32_f64_add>:
8000aef4:	f7 e9 20 0c 	eor	r12,r11,r9
8000aef8:	fe 96 ff 2e 	brmi	8000ad54 <__avr32_f64_sub_from_add>
8000aefc:	eb cd 40 e0 	pushm	r5-r7,lr
8000af00:	16 9c       	mov	r12,r11
8000af02:	e6 1c 80 00 	andh	r12,0x8000,COH
8000af06:	bf db       	cbr	r11,0x1f
8000af08:	bf d9       	cbr	r9,0x1f
8000af0a:	12 3b       	cp.w	r11,r9
8000af0c:	c0 72       	brcc	8000af1a <__avr32_f64_add+0x26>
8000af0e:	16 97       	mov	r7,r11
8000af10:	12 9b       	mov	r11,r9
8000af12:	0e 99       	mov	r9,r7
8000af14:	14 97       	mov	r7,r10
8000af16:	10 9a       	mov	r10,r8
8000af18:	0e 98       	mov	r8,r7
8000af1a:	30 0e       	mov	lr,0
8000af1c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000af20:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000af24:	b5 ab       	sbr	r11,0x14
8000af26:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000af2a:	c6 20       	breq	8000afee <__avr32_f64_add_op2_subnormal>
8000af2c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000af30:	b5 a9       	sbr	r9,0x14
8000af32:	e0 47 07 ff 	cp.w	r7,2047
8000af36:	c2 80       	breq	8000af86 <__avr32_f64_add_opH_nan_or_inf>
8000af38:	0e 26       	rsub	r6,r7
8000af3a:	c1 20       	breq	8000af5e <__avr32_f64_add_shift_done>
8000af3c:	e0 46 00 36 	cp.w	r6,54
8000af40:	c1 52       	brcc	8000af6a <__avr32_f64_add_res_of_done>
8000af42:	ec 05 11 20 	rsub	r5,r6,32
8000af46:	e0 46 00 20 	cp.w	r6,32
8000af4a:	c3 52       	brcc	8000afb4 <__avr32_f64_add_longshift>
8000af4c:	f0 05 09 4e 	lsl	lr,r8,r5
8000af50:	f2 05 09 45 	lsl	r5,r9,r5
8000af54:	f0 06 0a 48 	lsr	r8,r8,r6
8000af58:	f2 06 0a 49 	lsr	r9,r9,r6
8000af5c:	0a 48       	or	r8,r5

8000af5e <__avr32_f64_add_shift_done>:
8000af5e:	10 0a       	add	r10,r8
8000af60:	f6 09 00 4b 	adc	r11,r11,r9
8000af64:	ed bb 00 15 	bld	r11,0x15
8000af68:	c3 40       	breq	8000afd0 <__avr32_f64_add_res_of>

8000af6a <__avr32_f64_add_res_of_done>:
8000af6a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000af6e:	18 4b       	or	r11,r12

8000af70 <__avr32_f64_add_round>:
8000af70:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000af74:	18 4e       	or	lr,r12
8000af76:	ee 1e 80 00 	eorh	lr,0x8000
8000af7a:	f1 be 04 20 	satu	lr,0x1
8000af7e:	1c 0a       	add	r10,lr
8000af80:	5c 0b       	acr	r11
8000af82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af86 <__avr32_f64_add_opH_nan_or_inf>:
8000af86:	b5 cb       	cbr	r11,0x14
8000af88:	f7 ea 10 0e 	or	lr,r11,r10
8000af8c:	c1 01       	brne	8000afac <__avr32_f64_add_return_nan>
8000af8e:	e0 46 07 ff 	cp.w	r6,2047
8000af92:	c0 30       	breq	8000af98 <__avr32_f64_add_opL_nan_or_inf>
8000af94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af98 <__avr32_f64_add_opL_nan_or_inf>:
8000af98:	b5 c9       	cbr	r9,0x14
8000af9a:	f3 e8 10 0e 	or	lr,r9,r8
8000af9e:	c0 71       	brne	8000afac <__avr32_f64_add_return_nan>
8000afa0:	30 0a       	mov	r10,0
8000afa2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000afa6:	18 4b       	or	r11,r12
8000afa8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000afac <__avr32_f64_add_return_nan>:
8000afac:	3f fa       	mov	r10,-1
8000afae:	3f fb       	mov	r11,-1
8000afb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000afb4 <__avr32_f64_add_longshift>:
8000afb4:	f1 b6 04 c0 	satu	r6,0x6
8000afb8:	f0 0e 17 00 	moveq	lr,r8
8000afbc:	c0 60       	breq	8000afc8 <__avr32_f64_add_longshift+0x14>
8000afbe:	f2 05 09 4e 	lsl	lr,r9,r5
8000afc2:	58 08       	cp.w	r8,0
8000afc4:	5f 18       	srne	r8
8000afc6:	10 4e       	or	lr,r8
8000afc8:	f2 06 0a 48 	lsr	r8,r9,r6
8000afcc:	30 09       	mov	r9,0
8000afce:	cc 8b       	rjmp	8000af5e <__avr32_f64_add_shift_done>

8000afd0 <__avr32_f64_add_res_of>:
8000afd0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000afd4:	a1 9b       	lsr	r11,0x1
8000afd6:	5d 0a       	ror	r10
8000afd8:	5d 0e       	ror	lr
8000afda:	2f f7       	sub	r7,-1
8000afdc:	e0 47 07 ff 	cp.w	r7,2047
8000afe0:	f9 ba 00 00 	moveq	r10,0
8000afe4:	f9 bb 00 00 	moveq	r11,0
8000afe8:	f9 be 00 00 	moveq	lr,0
8000afec:	cb fb       	rjmp	8000af6a <__avr32_f64_add_res_of_done>

8000afee <__avr32_f64_add_op2_subnormal>:
8000afee:	30 16       	mov	r6,1
8000aff0:	58 07       	cp.w	r7,0
8000aff2:	ca 01       	brne	8000af32 <__avr32_f64_add+0x3e>
8000aff4:	b5 cb       	cbr	r11,0x14
8000aff6:	10 0a       	add	r10,r8
8000aff8:	f6 09 00 4b 	adc	r11,r11,r9
8000affc:	18 4b       	or	r11,r12
8000affe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b002:	d7 03       	nop

8000b004 <__avr32_f64_to_u32>:
8000b004:	58 0b       	cp.w	r11,0
8000b006:	5e 6d       	retmi	0

8000b008 <__avr32_f64_to_s32>:
8000b008:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b00c:	b5 9c       	lsr	r12,0x15
8000b00e:	e0 2c 03 ff 	sub	r12,1023
8000b012:	5e 3d       	retlo	0
8000b014:	f8 0c 11 1f 	rsub	r12,r12,31
8000b018:	16 99       	mov	r9,r11
8000b01a:	ab 7b       	lsl	r11,0xb
8000b01c:	bf bb       	sbr	r11,0x1f
8000b01e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b022:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b026:	a1 79       	lsl	r9,0x1
8000b028:	5e 2b       	reths	r11
8000b02a:	5c 3b       	neg	r11
8000b02c:	5e fb       	retal	r11

8000b02e <__avr32_u32_to_f64>:
8000b02e:	f8 cb 00 00 	sub	r11,r12,0
8000b032:	30 0c       	mov	r12,0
8000b034:	c0 38       	rjmp	8000b03a <__avr32_s32_to_f64+0x4>

8000b036 <__avr32_s32_to_f64>:
8000b036:	18 9b       	mov	r11,r12
8000b038:	5c 4b       	abs	r11
8000b03a:	30 0a       	mov	r10,0
8000b03c:	5e 0b       	reteq	r11
8000b03e:	d4 01       	pushm	lr
8000b040:	e0 69 04 1e 	mov	r9,1054
8000b044:	f6 08 12 00 	clz	r8,r11
8000b048:	c1 70       	breq	8000b076 <__avr32_s32_to_f64+0x40>
8000b04a:	c0 c3       	brcs	8000b062 <__avr32_s32_to_f64+0x2c>
8000b04c:	f0 0e 11 20 	rsub	lr,r8,32
8000b050:	f6 08 09 4b 	lsl	r11,r11,r8
8000b054:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b058:	1c 4b       	or	r11,lr
8000b05a:	f4 08 09 4a 	lsl	r10,r10,r8
8000b05e:	10 19       	sub	r9,r8
8000b060:	c0 b8       	rjmp	8000b076 <__avr32_s32_to_f64+0x40>
8000b062:	f4 08 12 00 	clz	r8,r10
8000b066:	f9 b8 03 00 	movlo	r8,0
8000b06a:	f7 b8 02 e0 	subhs	r8,-32
8000b06e:	f4 08 09 4b 	lsl	r11,r10,r8
8000b072:	30 0a       	mov	r10,0
8000b074:	10 19       	sub	r9,r8
8000b076:	58 09       	cp.w	r9,0
8000b078:	e0 89 00 30 	brgt	8000b0d8 <__avr32_s32_to_f64+0xa2>
8000b07c:	5c 39       	neg	r9
8000b07e:	2f f9       	sub	r9,-1
8000b080:	e0 49 00 36 	cp.w	r9,54
8000b084:	c0 43       	brcs	8000b08c <__avr32_s32_to_f64+0x56>
8000b086:	30 0b       	mov	r11,0
8000b088:	30 0a       	mov	r10,0
8000b08a:	c2 68       	rjmp	8000b0d6 <__avr32_s32_to_f64+0xa0>
8000b08c:	2f 69       	sub	r9,-10
8000b08e:	f2 08 11 20 	rsub	r8,r9,32
8000b092:	e0 49 00 20 	cp.w	r9,32
8000b096:	c0 b2       	brcc	8000b0ac <__avr32_s32_to_f64+0x76>
8000b098:	f4 08 09 4e 	lsl	lr,r10,r8
8000b09c:	f6 08 09 48 	lsl	r8,r11,r8
8000b0a0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b0a4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b0a8:	10 4b       	or	r11,r8
8000b0aa:	c0 88       	rjmp	8000b0ba <__avr32_s32_to_f64+0x84>
8000b0ac:	f6 08 09 4e 	lsl	lr,r11,r8
8000b0b0:	14 4e       	or	lr,r10
8000b0b2:	16 9a       	mov	r10,r11
8000b0b4:	30 0b       	mov	r11,0
8000b0b6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b0ba:	ed ba 00 00 	bld	r10,0x0
8000b0be:	c0 92       	brcc	8000b0d0 <__avr32_s32_to_f64+0x9a>
8000b0c0:	1c 7e       	tst	lr,lr
8000b0c2:	c0 41       	brne	8000b0ca <__avr32_s32_to_f64+0x94>
8000b0c4:	ed ba 00 01 	bld	r10,0x1
8000b0c8:	c0 42       	brcc	8000b0d0 <__avr32_s32_to_f64+0x9a>
8000b0ca:	2f fa       	sub	r10,-1
8000b0cc:	f7 bb 02 ff 	subhs	r11,-1
8000b0d0:	5c fc       	rol	r12
8000b0d2:	5d 0b       	ror	r11
8000b0d4:	5d 0a       	ror	r10
8000b0d6:	d8 02       	popm	pc
8000b0d8:	e0 68 03 ff 	mov	r8,1023
8000b0dc:	ed ba 00 0b 	bld	r10,0xb
8000b0e0:	f7 b8 00 ff 	subeq	r8,-1
8000b0e4:	10 0a       	add	r10,r8
8000b0e6:	5c 0b       	acr	r11
8000b0e8:	f7 b9 03 fe 	sublo	r9,-2
8000b0ec:	e0 49 07 ff 	cp.w	r9,2047
8000b0f0:	c0 55       	brlt	8000b0fa <__avr32_s32_to_f64+0xc4>
8000b0f2:	30 0a       	mov	r10,0
8000b0f4:	fc 1b ff e0 	movh	r11,0xffe0
8000b0f8:	c0 c8       	rjmp	8000b110 <__floatsidf_return_op1>
8000b0fa:	ed bb 00 1f 	bld	r11,0x1f
8000b0fe:	f7 b9 01 01 	subne	r9,1
8000b102:	ab 9a       	lsr	r10,0xb
8000b104:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b108:	a1 7b       	lsl	r11,0x1
8000b10a:	ab 9b       	lsr	r11,0xb
8000b10c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b110 <__floatsidf_return_op1>:
8000b110:	a1 7c       	lsl	r12,0x1
8000b112:	5d 0b       	ror	r11
8000b114:	d8 02       	popm	pc

8000b116 <__avr32_f64_cmp_eq>:
8000b116:	10 3a       	cp.w	r10,r8
8000b118:	f2 0b 13 00 	cpc	r11,r9
8000b11c:	c0 80       	breq	8000b12c <__avr32_f64_cmp_eq+0x16>
8000b11e:	a1 7b       	lsl	r11,0x1
8000b120:	a1 79       	lsl	r9,0x1
8000b122:	14 4b       	or	r11,r10
8000b124:	12 4b       	or	r11,r9
8000b126:	10 4b       	or	r11,r8
8000b128:	5e 0f       	reteq	1
8000b12a:	5e fd       	retal	0
8000b12c:	a1 7b       	lsl	r11,0x1
8000b12e:	fc 1c ff e0 	movh	r12,0xffe0
8000b132:	58 0a       	cp.w	r10,0
8000b134:	f8 0b 13 00 	cpc	r11,r12
8000b138:	5e 8f       	retls	1
8000b13a:	5e fd       	retal	0

8000b13c <__avr32_f64_cmp_ge>:
8000b13c:	1a de       	st.w	--sp,lr
8000b13e:	1a d7       	st.w	--sp,r7
8000b140:	a1 7b       	lsl	r11,0x1
8000b142:	5f 3c       	srlo	r12
8000b144:	a1 79       	lsl	r9,0x1
8000b146:	5f 37       	srlo	r7
8000b148:	5c fc       	rol	r12
8000b14a:	fc 1e ff e0 	movh	lr,0xffe0
8000b14e:	58 0a       	cp.w	r10,0
8000b150:	fc 0b 13 00 	cpc	r11,lr
8000b154:	e0 8b 00 1d 	brhi	8000b18e <__avr32_f64_cmp_ge+0x52>
8000b158:	58 08       	cp.w	r8,0
8000b15a:	fc 09 13 00 	cpc	r9,lr
8000b15e:	e0 8b 00 18 	brhi	8000b18e <__avr32_f64_cmp_ge+0x52>
8000b162:	58 0b       	cp.w	r11,0
8000b164:	f5 ba 00 00 	subfeq	r10,0
8000b168:	c1 50       	breq	8000b192 <__avr32_f64_cmp_ge+0x56>
8000b16a:	1b 07       	ld.w	r7,sp++
8000b16c:	1b 0e       	ld.w	lr,sp++
8000b16e:	58 3c       	cp.w	r12,3
8000b170:	c0 a0       	breq	8000b184 <__avr32_f64_cmp_ge+0x48>
8000b172:	58 1c       	cp.w	r12,1
8000b174:	c0 33       	brcs	8000b17a <__avr32_f64_cmp_ge+0x3e>
8000b176:	5e 0f       	reteq	1
8000b178:	5e 1d       	retne	0
8000b17a:	10 3a       	cp.w	r10,r8
8000b17c:	f2 0b 13 00 	cpc	r11,r9
8000b180:	5e 2f       	reths	1
8000b182:	5e 3d       	retlo	0
8000b184:	14 38       	cp.w	r8,r10
8000b186:	f6 09 13 00 	cpc	r9,r11
8000b18a:	5e 2f       	reths	1
8000b18c:	5e 3d       	retlo	0
8000b18e:	1b 07       	ld.w	r7,sp++
8000b190:	d8 0a       	popm	pc,r12=0
8000b192:	58 17       	cp.w	r7,1
8000b194:	5f 0c       	sreq	r12
8000b196:	58 09       	cp.w	r9,0
8000b198:	f5 b8 00 00 	subfeq	r8,0
8000b19c:	1b 07       	ld.w	r7,sp++
8000b19e:	1b 0e       	ld.w	lr,sp++
8000b1a0:	5e 0f       	reteq	1
8000b1a2:	5e fc       	retal	r12

8000b1a4 <__avr32_f64_cmp_lt>:
8000b1a4:	1a de       	st.w	--sp,lr
8000b1a6:	1a d7       	st.w	--sp,r7
8000b1a8:	a1 7b       	lsl	r11,0x1
8000b1aa:	5f 3c       	srlo	r12
8000b1ac:	a1 79       	lsl	r9,0x1
8000b1ae:	5f 37       	srlo	r7
8000b1b0:	5c fc       	rol	r12
8000b1b2:	fc 1e ff e0 	movh	lr,0xffe0
8000b1b6:	58 0a       	cp.w	r10,0
8000b1b8:	fc 0b 13 00 	cpc	r11,lr
8000b1bc:	e0 8b 00 1d 	brhi	8000b1f6 <__avr32_f64_cmp_lt+0x52>
8000b1c0:	58 08       	cp.w	r8,0
8000b1c2:	fc 09 13 00 	cpc	r9,lr
8000b1c6:	e0 8b 00 18 	brhi	8000b1f6 <__avr32_f64_cmp_lt+0x52>
8000b1ca:	58 0b       	cp.w	r11,0
8000b1cc:	f5 ba 00 00 	subfeq	r10,0
8000b1d0:	c1 50       	breq	8000b1fa <__avr32_f64_cmp_lt+0x56>
8000b1d2:	1b 07       	ld.w	r7,sp++
8000b1d4:	1b 0e       	ld.w	lr,sp++
8000b1d6:	58 3c       	cp.w	r12,3
8000b1d8:	c0 a0       	breq	8000b1ec <__avr32_f64_cmp_lt+0x48>
8000b1da:	58 1c       	cp.w	r12,1
8000b1dc:	c0 33       	brcs	8000b1e2 <__avr32_f64_cmp_lt+0x3e>
8000b1de:	5e 0d       	reteq	0
8000b1e0:	5e 1f       	retne	1
8000b1e2:	10 3a       	cp.w	r10,r8
8000b1e4:	f2 0b 13 00 	cpc	r11,r9
8000b1e8:	5e 2d       	reths	0
8000b1ea:	5e 3f       	retlo	1
8000b1ec:	14 38       	cp.w	r8,r10
8000b1ee:	f6 09 13 00 	cpc	r9,r11
8000b1f2:	5e 2d       	reths	0
8000b1f4:	5e 3f       	retlo	1
8000b1f6:	1b 07       	ld.w	r7,sp++
8000b1f8:	d8 0a       	popm	pc,r12=0
8000b1fa:	58 17       	cp.w	r7,1
8000b1fc:	5f 1c       	srne	r12
8000b1fe:	58 09       	cp.w	r9,0
8000b200:	f5 b8 00 00 	subfeq	r8,0
8000b204:	1b 07       	ld.w	r7,sp++
8000b206:	1b 0e       	ld.w	lr,sp++
8000b208:	5e 0d       	reteq	0
8000b20a:	5e fc       	retal	r12

8000b20c <__avr32_f64_div>:
8000b20c:	eb cd 40 ff 	pushm	r0-r7,lr
8000b210:	f7 e9 20 0e 	eor	lr,r11,r9
8000b214:	f6 07 16 14 	lsr	r7,r11,0x14
8000b218:	a9 7b       	lsl	r11,0x9
8000b21a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b21e:	a9 7a       	lsl	r10,0x9
8000b220:	bd bb       	sbr	r11,0x1d
8000b222:	e4 1b 3f ff 	andh	r11,0x3fff
8000b226:	ab d7       	cbr	r7,0xb
8000b228:	e0 80 00 cc 	breq	8000b3c0 <__avr32_f64_div_round_subnormal+0x54>
8000b22c:	e0 47 07 ff 	cp.w	r7,2047
8000b230:	e0 84 00 b5 	brge	8000b39a <__avr32_f64_div_round_subnormal+0x2e>
8000b234:	f2 06 16 14 	lsr	r6,r9,0x14
8000b238:	a9 79       	lsl	r9,0x9
8000b23a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b23e:	a9 78       	lsl	r8,0x9
8000b240:	bd b9       	sbr	r9,0x1d
8000b242:	e4 19 3f ff 	andh	r9,0x3fff
8000b246:	ab d6       	cbr	r6,0xb
8000b248:	e0 80 00 e2 	breq	8000b40c <__avr32_f64_div_round_subnormal+0xa0>
8000b24c:	e0 46 07 ff 	cp.w	r6,2047
8000b250:	e0 84 00 b2 	brge	8000b3b4 <__avr32_f64_div_round_subnormal+0x48>
8000b254:	0c 17       	sub	r7,r6
8000b256:	fe 37 fc 01 	sub	r7,-1023
8000b25a:	fc 1c 80 00 	movh	r12,0x8000
8000b25e:	f8 03 16 01 	lsr	r3,r12,0x1
8000b262:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b266:	5c d4       	com	r4
8000b268:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b26c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b270:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b274:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b278:	ea 03 15 02 	lsl	r3,r5,0x2
8000b27c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b280:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b284:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b288:	ea 03 15 02 	lsl	r3,r5,0x2
8000b28c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b290:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b294:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b298:	ea 03 15 02 	lsl	r3,r5,0x2
8000b29c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b2a0:	e4 09 07 40 	macu.d	r0,r2,r9
8000b2a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b2a8:	02 04       	add	r4,r1
8000b2aa:	5c 05       	acr	r5
8000b2ac:	a3 65       	lsl	r5,0x2
8000b2ae:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b2b2:	a3 64       	lsl	r4,0x2
8000b2b4:	5c 34       	neg	r4
8000b2b6:	f8 05 01 45 	sbc	r5,r12,r5
8000b2ba:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b2be:	e4 05 07 40 	macu.d	r0,r2,r5
8000b2c2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b2c6:	02 04       	add	r4,r1
8000b2c8:	5c 05       	acr	r5
8000b2ca:	ea 03 15 02 	lsl	r3,r5,0x2
8000b2ce:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b2d2:	e8 02 15 02 	lsl	r2,r4,0x2
8000b2d6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b2da:	e4 09 07 40 	macu.d	r0,r2,r9
8000b2de:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b2e2:	02 04       	add	r4,r1
8000b2e4:	5c 05       	acr	r5
8000b2e6:	a3 65       	lsl	r5,0x2
8000b2e8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b2ec:	a3 64       	lsl	r4,0x2
8000b2ee:	5c 34       	neg	r4
8000b2f0:	f8 05 01 45 	sbc	r5,r12,r5
8000b2f4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b2f8:	e4 05 07 40 	macu.d	r0,r2,r5
8000b2fc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b300:	02 04       	add	r4,r1
8000b302:	5c 05       	acr	r5
8000b304:	ea 03 15 02 	lsl	r3,r5,0x2
8000b308:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b30c:	e8 02 15 02 	lsl	r2,r4,0x2
8000b310:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b314:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b318:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b31c:	02 02       	add	r2,r1
8000b31e:	5c 03       	acr	r3
8000b320:	ed b3 00 1c 	bld	r3,0x1c
8000b324:	c0 90       	breq	8000b336 <__avr32_f64_div+0x12a>
8000b326:	a1 72       	lsl	r2,0x1
8000b328:	5c f3       	rol	r3
8000b32a:	20 17       	sub	r7,1
8000b32c:	a3 9a       	lsr	r10,0x3
8000b32e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b332:	a3 9b       	lsr	r11,0x3
8000b334:	c0 58       	rjmp	8000b33e <__avr32_f64_div+0x132>
8000b336:	a5 8a       	lsr	r10,0x4
8000b338:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b33c:	a5 8b       	lsr	r11,0x4
8000b33e:	58 07       	cp.w	r7,0
8000b340:	e0 8a 00 8b 	brle	8000b456 <__avr32_f64_div_res_subnormal>
8000b344:	e0 12 ff 00 	andl	r2,0xff00
8000b348:	e8 12 00 80 	orl	r2,0x80
8000b34c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b350:	e4 09 07 40 	macu.d	r0,r2,r9
8000b354:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b358:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b35c:	00 05       	add	r5,r0
8000b35e:	f0 01 00 48 	adc	r8,r8,r1
8000b362:	5c 09       	acr	r9
8000b364:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b368:	58 04       	cp.w	r4,0
8000b36a:	5c 25       	cpc	r5

8000b36c <__avr32_f64_div_round_subnormal>:
8000b36c:	f4 08 13 00 	cpc	r8,r10
8000b370:	f6 09 13 00 	cpc	r9,r11
8000b374:	5f 36       	srlo	r6
8000b376:	f8 06 17 00 	moveq	r6,r12
8000b37a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b37e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b382:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b386:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b38a:	ed be 00 1f 	bld	lr,0x1f
8000b38e:	ef bb 00 1f 	bst	r11,0x1f
8000b392:	0c 0a       	add	r10,r6
8000b394:	5c 0b       	acr	r11
8000b396:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b39a:	e4 1b 00 0f 	andh	r11,0xf
8000b39e:	14 4b       	or	r11,r10
8000b3a0:	e0 81 00 a7 	brne	8000b4ee <__avr32_f64_div_res_subnormal+0x98>
8000b3a4:	f2 06 16 14 	lsr	r6,r9,0x14
8000b3a8:	ab d6       	cbr	r6,0xb
8000b3aa:	e0 46 07 ff 	cp.w	r6,2047
8000b3ae:	e0 81 00 a4 	brne	8000b4f6 <__avr32_f64_div_res_subnormal+0xa0>
8000b3b2:	c9 e8       	rjmp	8000b4ee <__avr32_f64_div_res_subnormal+0x98>
8000b3b4:	e4 19 00 0f 	andh	r9,0xf
8000b3b8:	10 49       	or	r9,r8
8000b3ba:	e0 81 00 9a 	brne	8000b4ee <__avr32_f64_div_res_subnormal+0x98>
8000b3be:	c9 28       	rjmp	8000b4e2 <__avr32_f64_div_res_subnormal+0x8c>
8000b3c0:	a3 7b       	lsl	r11,0x3
8000b3c2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b3c6:	a3 7a       	lsl	r10,0x3
8000b3c8:	f5 eb 10 04 	or	r4,r10,r11
8000b3cc:	e0 80 00 a0 	breq	8000b50c <__avr32_f64_div_op1_zero>
8000b3d0:	f6 04 12 00 	clz	r4,r11
8000b3d4:	c1 70       	breq	8000b402 <__avr32_f64_div_round_subnormal+0x96>
8000b3d6:	c0 c3       	brcs	8000b3ee <__avr32_f64_div_round_subnormal+0x82>
8000b3d8:	e8 05 11 20 	rsub	r5,r4,32
8000b3dc:	f6 04 09 4b 	lsl	r11,r11,r4
8000b3e0:	f4 05 0a 45 	lsr	r5,r10,r5
8000b3e4:	0a 4b       	or	r11,r5
8000b3e6:	f4 04 09 4a 	lsl	r10,r10,r4
8000b3ea:	08 17       	sub	r7,r4
8000b3ec:	c0 b8       	rjmp	8000b402 <__avr32_f64_div_round_subnormal+0x96>
8000b3ee:	f4 04 12 00 	clz	r4,r10
8000b3f2:	f9 b4 03 00 	movlo	r4,0
8000b3f6:	f7 b4 02 e0 	subhs	r4,-32
8000b3fa:	f4 04 09 4b 	lsl	r11,r10,r4
8000b3fe:	30 0a       	mov	r10,0
8000b400:	08 17       	sub	r7,r4
8000b402:	a3 8a       	lsr	r10,0x2
8000b404:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b408:	a3 8b       	lsr	r11,0x2
8000b40a:	c1 1b       	rjmp	8000b22c <__avr32_f64_div+0x20>
8000b40c:	a3 79       	lsl	r9,0x3
8000b40e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b412:	a3 78       	lsl	r8,0x3
8000b414:	f3 e8 10 04 	or	r4,r9,r8
8000b418:	c6 f0       	breq	8000b4f6 <__avr32_f64_div_res_subnormal+0xa0>
8000b41a:	f2 04 12 00 	clz	r4,r9
8000b41e:	c1 70       	breq	8000b44c <__avr32_f64_div_round_subnormal+0xe0>
8000b420:	c0 c3       	brcs	8000b438 <__avr32_f64_div_round_subnormal+0xcc>
8000b422:	e8 05 11 20 	rsub	r5,r4,32
8000b426:	f2 04 09 49 	lsl	r9,r9,r4
8000b42a:	f0 05 0a 45 	lsr	r5,r8,r5
8000b42e:	0a 49       	or	r9,r5
8000b430:	f0 04 09 48 	lsl	r8,r8,r4
8000b434:	08 16       	sub	r6,r4
8000b436:	c0 b8       	rjmp	8000b44c <__avr32_f64_div_round_subnormal+0xe0>
8000b438:	f0 04 12 00 	clz	r4,r8
8000b43c:	f9 b4 03 00 	movlo	r4,0
8000b440:	f7 b4 02 e0 	subhs	r4,-32
8000b444:	f0 04 09 49 	lsl	r9,r8,r4
8000b448:	30 08       	mov	r8,0
8000b44a:	08 16       	sub	r6,r4
8000b44c:	a3 88       	lsr	r8,0x2
8000b44e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b452:	a3 89       	lsr	r9,0x2
8000b454:	cf ca       	rjmp	8000b24c <__avr32_f64_div+0x40>

8000b456 <__avr32_f64_div_res_subnormal>:
8000b456:	5c 37       	neg	r7
8000b458:	2f f7       	sub	r7,-1
8000b45a:	f1 b7 04 c0 	satu	r7,0x6
8000b45e:	e0 47 00 20 	cp.w	r7,32
8000b462:	c1 54       	brge	8000b48c <__avr32_f64_div_res_subnormal+0x36>
8000b464:	ee 06 11 20 	rsub	r6,r7,32
8000b468:	e4 07 0a 42 	lsr	r2,r2,r7
8000b46c:	e6 06 09 4c 	lsl	r12,r3,r6
8000b470:	18 42       	or	r2,r12
8000b472:	e6 07 0a 43 	lsr	r3,r3,r7
8000b476:	f4 06 09 41 	lsl	r1,r10,r6
8000b47a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b47e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b482:	18 4a       	or	r10,r12
8000b484:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b488:	30 00       	mov	r0,0
8000b48a:	c1 58       	rjmp	8000b4b4 <__avr32_f64_div_res_subnormal+0x5e>
8000b48c:	ee 06 11 20 	rsub	r6,r7,32
8000b490:	f9 b0 00 00 	moveq	r0,0
8000b494:	f9 bc 00 00 	moveq	r12,0
8000b498:	c0 50       	breq	8000b4a2 <__avr32_f64_div_res_subnormal+0x4c>
8000b49a:	f4 06 09 40 	lsl	r0,r10,r6
8000b49e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b4a2:	e6 07 0a 42 	lsr	r2,r3,r7
8000b4a6:	30 03       	mov	r3,0
8000b4a8:	f4 07 0a 41 	lsr	r1,r10,r7
8000b4ac:	18 41       	or	r1,r12
8000b4ae:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b4b2:	30 0b       	mov	r11,0
8000b4b4:	e0 12 ff 00 	andl	r2,0xff00
8000b4b8:	e8 12 00 80 	orl	r2,0x80
8000b4bc:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b4c0:	e4 09 07 46 	macu.d	r6,r2,r9
8000b4c4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b4c8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b4cc:	0c 05       	add	r5,r6
8000b4ce:	f0 07 00 48 	adc	r8,r8,r7
8000b4d2:	5c 09       	acr	r9
8000b4d4:	30 07       	mov	r7,0
8000b4d6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b4da:	00 34       	cp.w	r4,r0
8000b4dc:	e2 05 13 00 	cpc	r5,r1
8000b4e0:	c4 6b       	rjmp	8000b36c <__avr32_f64_div_round_subnormal>
8000b4e2:	1c 9b       	mov	r11,lr
8000b4e4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b4e8:	30 0a       	mov	r10,0
8000b4ea:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b4ee:	3f fb       	mov	r11,-1
8000b4f0:	30 0a       	mov	r10,0
8000b4f2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b4f6:	f5 eb 10 04 	or	r4,r10,r11
8000b4fa:	c0 90       	breq	8000b50c <__avr32_f64_div_op1_zero>
8000b4fc:	1c 9b       	mov	r11,lr
8000b4fe:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b502:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b506:	30 0a       	mov	r10,0
8000b508:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b50c <__avr32_f64_div_op1_zero>:
8000b50c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b510:	ce f0       	breq	8000b4ee <__avr32_f64_div_res_subnormal+0x98>
8000b512:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b516:	e0 44 07 ff 	cp.w	r4,2047
8000b51a:	ce 41       	brne	8000b4e2 <__avr32_f64_div_res_subnormal+0x8c>
8000b51c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b520:	ce 10       	breq	8000b4e2 <__avr32_f64_div_res_subnormal+0x8c>
8000b522:	ce 6b       	rjmp	8000b4ee <__avr32_f64_div_res_subnormal+0x98>

8000b524 <__avr32_udiv64>:
8000b524:	d4 31       	pushm	r0-r7,lr
8000b526:	1a 97       	mov	r7,sp
8000b528:	20 3d       	sub	sp,12
8000b52a:	10 9c       	mov	r12,r8
8000b52c:	12 9e       	mov	lr,r9
8000b52e:	14 93       	mov	r3,r10
8000b530:	58 09       	cp.w	r9,0
8000b532:	e0 81 00 bd 	brne	8000b6ac <__avr32_udiv64+0x188>
8000b536:	16 38       	cp.w	r8,r11
8000b538:	e0 88 00 40 	brls	8000b5b8 <__avr32_udiv64+0x94>
8000b53c:	f0 08 12 00 	clz	r8,r8
8000b540:	c0 d0       	breq	8000b55a <__avr32_udiv64+0x36>
8000b542:	f6 08 09 4b 	lsl	r11,r11,r8
8000b546:	f0 09 11 20 	rsub	r9,r8,32
8000b54a:	f8 08 09 4c 	lsl	r12,r12,r8
8000b54e:	f4 09 0a 49 	lsr	r9,r10,r9
8000b552:	f4 08 09 43 	lsl	r3,r10,r8
8000b556:	f3 eb 10 0b 	or	r11,r9,r11
8000b55a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b55e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b562:	f6 0e 0d 00 	divu	r0,r11,lr
8000b566:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b56a:	00 99       	mov	r9,r0
8000b56c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b570:	e0 0a 02 48 	mul	r8,r0,r10
8000b574:	10 3b       	cp.w	r11,r8
8000b576:	c0 a2       	brcc	8000b58a <__avr32_udiv64+0x66>
8000b578:	20 19       	sub	r9,1
8000b57a:	18 0b       	add	r11,r12
8000b57c:	18 3b       	cp.w	r11,r12
8000b57e:	c0 63       	brcs	8000b58a <__avr32_udiv64+0x66>
8000b580:	10 3b       	cp.w	r11,r8
8000b582:	f7 b9 03 01 	sublo	r9,1
8000b586:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b58a:	f6 08 01 01 	sub	r1,r11,r8
8000b58e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b592:	e2 0e 0d 00 	divu	r0,r1,lr
8000b596:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b59a:	00 98       	mov	r8,r0
8000b59c:	e0 0a 02 4a 	mul	r10,r0,r10
8000b5a0:	14 33       	cp.w	r3,r10
8000b5a2:	c0 82       	brcc	8000b5b2 <__avr32_udiv64+0x8e>
8000b5a4:	20 18       	sub	r8,1
8000b5a6:	18 03       	add	r3,r12
8000b5a8:	18 33       	cp.w	r3,r12
8000b5aa:	c0 43       	brcs	8000b5b2 <__avr32_udiv64+0x8e>
8000b5ac:	14 33       	cp.w	r3,r10
8000b5ae:	f7 b8 03 01 	sublo	r8,1
8000b5b2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b5b6:	cd f8       	rjmp	8000b774 <__avr32_udiv64+0x250>
8000b5b8:	58 08       	cp.w	r8,0
8000b5ba:	c0 51       	brne	8000b5c4 <__avr32_udiv64+0xa0>
8000b5bc:	30 19       	mov	r9,1
8000b5be:	f2 08 0d 08 	divu	r8,r9,r8
8000b5c2:	10 9c       	mov	r12,r8
8000b5c4:	f8 06 12 00 	clz	r6,r12
8000b5c8:	c0 41       	brne	8000b5d0 <__avr32_udiv64+0xac>
8000b5ca:	18 1b       	sub	r11,r12
8000b5cc:	30 19       	mov	r9,1
8000b5ce:	c4 08       	rjmp	8000b64e <__avr32_udiv64+0x12a>
8000b5d0:	ec 01 11 20 	rsub	r1,r6,32
8000b5d4:	f4 01 0a 49 	lsr	r9,r10,r1
8000b5d8:	f8 06 09 4c 	lsl	r12,r12,r6
8000b5dc:	f6 06 09 48 	lsl	r8,r11,r6
8000b5e0:	f6 01 0a 41 	lsr	r1,r11,r1
8000b5e4:	f3 e8 10 08 	or	r8,r9,r8
8000b5e8:	f8 03 16 10 	lsr	r3,r12,0x10
8000b5ec:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b5f0:	e2 03 0d 00 	divu	r0,r1,r3
8000b5f4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b5f8:	00 9e       	mov	lr,r0
8000b5fa:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b5fe:	e0 05 02 49 	mul	r9,r0,r5
8000b602:	12 3b       	cp.w	r11,r9
8000b604:	c0 a2       	brcc	8000b618 <__avr32_udiv64+0xf4>
8000b606:	20 1e       	sub	lr,1
8000b608:	18 0b       	add	r11,r12
8000b60a:	18 3b       	cp.w	r11,r12
8000b60c:	c0 63       	brcs	8000b618 <__avr32_udiv64+0xf4>
8000b60e:	12 3b       	cp.w	r11,r9
8000b610:	f7 be 03 01 	sublo	lr,1
8000b614:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b618:	12 1b       	sub	r11,r9
8000b61a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b61e:	f6 03 0d 02 	divu	r2,r11,r3
8000b622:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b626:	04 99       	mov	r9,r2
8000b628:	e4 05 02 4b 	mul	r11,r2,r5
8000b62c:	16 38       	cp.w	r8,r11
8000b62e:	c0 a2       	brcc	8000b642 <__avr32_udiv64+0x11e>
8000b630:	20 19       	sub	r9,1
8000b632:	18 08       	add	r8,r12
8000b634:	18 38       	cp.w	r8,r12
8000b636:	c0 63       	brcs	8000b642 <__avr32_udiv64+0x11e>
8000b638:	16 38       	cp.w	r8,r11
8000b63a:	f7 b9 03 01 	sublo	r9,1
8000b63e:	f1 dc e3 08 	addcs	r8,r8,r12
8000b642:	f4 06 09 43 	lsl	r3,r10,r6
8000b646:	f0 0b 01 0b 	sub	r11,r8,r11
8000b64a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b64e:	f8 06 16 10 	lsr	r6,r12,0x10
8000b652:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b656:	f6 06 0d 00 	divu	r0,r11,r6
8000b65a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b65e:	00 9a       	mov	r10,r0
8000b660:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b664:	e0 0e 02 48 	mul	r8,r0,lr
8000b668:	10 3b       	cp.w	r11,r8
8000b66a:	c0 a2       	brcc	8000b67e <__avr32_udiv64+0x15a>
8000b66c:	20 1a       	sub	r10,1
8000b66e:	18 0b       	add	r11,r12
8000b670:	18 3b       	cp.w	r11,r12
8000b672:	c0 63       	brcs	8000b67e <__avr32_udiv64+0x15a>
8000b674:	10 3b       	cp.w	r11,r8
8000b676:	f7 ba 03 01 	sublo	r10,1
8000b67a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b67e:	f6 08 01 01 	sub	r1,r11,r8
8000b682:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b686:	e2 06 0d 00 	divu	r0,r1,r6
8000b68a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b68e:	00 98       	mov	r8,r0
8000b690:	e0 0e 02 4b 	mul	r11,r0,lr
8000b694:	16 33       	cp.w	r3,r11
8000b696:	c0 82       	brcc	8000b6a6 <__avr32_udiv64+0x182>
8000b698:	20 18       	sub	r8,1
8000b69a:	18 03       	add	r3,r12
8000b69c:	18 33       	cp.w	r3,r12
8000b69e:	c0 43       	brcs	8000b6a6 <__avr32_udiv64+0x182>
8000b6a0:	16 33       	cp.w	r3,r11
8000b6a2:	f7 b8 03 01 	sublo	r8,1
8000b6a6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b6aa:	c6 98       	rjmp	8000b77c <__avr32_udiv64+0x258>
8000b6ac:	16 39       	cp.w	r9,r11
8000b6ae:	e0 8b 00 65 	brhi	8000b778 <__avr32_udiv64+0x254>
8000b6b2:	f2 09 12 00 	clz	r9,r9
8000b6b6:	c0 b1       	brne	8000b6cc <__avr32_udiv64+0x1a8>
8000b6b8:	10 3a       	cp.w	r10,r8
8000b6ba:	5f 2a       	srhs	r10
8000b6bc:	1c 3b       	cp.w	r11,lr
8000b6be:	5f b8       	srhi	r8
8000b6c0:	10 4a       	or	r10,r8
8000b6c2:	f2 0a 18 00 	cp.b	r10,r9
8000b6c6:	c5 90       	breq	8000b778 <__avr32_udiv64+0x254>
8000b6c8:	30 18       	mov	r8,1
8000b6ca:	c5 98       	rjmp	8000b77c <__avr32_udiv64+0x258>
8000b6cc:	f0 09 09 46 	lsl	r6,r8,r9
8000b6d0:	f2 03 11 20 	rsub	r3,r9,32
8000b6d4:	fc 09 09 4e 	lsl	lr,lr,r9
8000b6d8:	f0 03 0a 48 	lsr	r8,r8,r3
8000b6dc:	f6 09 09 4c 	lsl	r12,r11,r9
8000b6e0:	f4 03 0a 42 	lsr	r2,r10,r3
8000b6e4:	ef 46 ff f4 	st.w	r7[-12],r6
8000b6e8:	f6 03 0a 43 	lsr	r3,r11,r3
8000b6ec:	18 42       	or	r2,r12
8000b6ee:	f1 ee 10 0c 	or	r12,r8,lr
8000b6f2:	f8 01 16 10 	lsr	r1,r12,0x10
8000b6f6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b6fa:	e6 01 0d 04 	divu	r4,r3,r1
8000b6fe:	e4 03 16 10 	lsr	r3,r2,0x10
8000b702:	08 9e       	mov	lr,r4
8000b704:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b708:	e8 06 02 48 	mul	r8,r4,r6
8000b70c:	10 33       	cp.w	r3,r8
8000b70e:	c0 a2       	brcc	8000b722 <__avr32_udiv64+0x1fe>
8000b710:	20 1e       	sub	lr,1
8000b712:	18 03       	add	r3,r12
8000b714:	18 33       	cp.w	r3,r12
8000b716:	c0 63       	brcs	8000b722 <__avr32_udiv64+0x1fe>
8000b718:	10 33       	cp.w	r3,r8
8000b71a:	f7 be 03 01 	sublo	lr,1
8000b71e:	e7 dc e3 03 	addcs	r3,r3,r12
8000b722:	10 13       	sub	r3,r8
8000b724:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b728:	e6 01 0d 00 	divu	r0,r3,r1
8000b72c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b730:	00 98       	mov	r8,r0
8000b732:	e0 06 02 46 	mul	r6,r0,r6
8000b736:	0c 3b       	cp.w	r11,r6
8000b738:	c0 a2       	brcc	8000b74c <__avr32_udiv64+0x228>
8000b73a:	20 18       	sub	r8,1
8000b73c:	18 0b       	add	r11,r12
8000b73e:	18 3b       	cp.w	r11,r12
8000b740:	c0 63       	brcs	8000b74c <__avr32_udiv64+0x228>
8000b742:	0c 3b       	cp.w	r11,r6
8000b744:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b748:	f7 b8 03 01 	sublo	r8,1
8000b74c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b750:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b754:	0c 1b       	sub	r11,r6
8000b756:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b75a:	06 95       	mov	r5,r3
8000b75c:	16 35       	cp.w	r5,r11
8000b75e:	e0 8b 00 0a 	brhi	8000b772 <__avr32_udiv64+0x24e>
8000b762:	5f 0b       	sreq	r11
8000b764:	f4 09 09 49 	lsl	r9,r10,r9
8000b768:	12 32       	cp.w	r2,r9
8000b76a:	5f b9       	srhi	r9
8000b76c:	f7 e9 00 09 	and	r9,r11,r9
8000b770:	c0 60       	breq	8000b77c <__avr32_udiv64+0x258>
8000b772:	20 18       	sub	r8,1
8000b774:	30 09       	mov	r9,0
8000b776:	c0 38       	rjmp	8000b77c <__avr32_udiv64+0x258>
8000b778:	30 09       	mov	r9,0
8000b77a:	12 98       	mov	r8,r9
8000b77c:	10 9a       	mov	r10,r8
8000b77e:	12 93       	mov	r3,r9
8000b780:	10 92       	mov	r2,r8
8000b782:	12 9b       	mov	r11,r9
8000b784:	2f dd       	sub	sp,-12
8000b786:	d8 32       	popm	r0-r7,pc

8000b788 <__avr32_umod64>:
8000b788:	d4 31       	pushm	r0-r7,lr
8000b78a:	1a 97       	mov	r7,sp
8000b78c:	20 3d       	sub	sp,12
8000b78e:	10 9c       	mov	r12,r8
8000b790:	12 95       	mov	r5,r9
8000b792:	14 9e       	mov	lr,r10
8000b794:	16 91       	mov	r1,r11
8000b796:	16 96       	mov	r6,r11
8000b798:	58 09       	cp.w	r9,0
8000b79a:	e0 81 00 81 	brne	8000b89c <__avr32_umod64+0x114>
8000b79e:	16 38       	cp.w	r8,r11
8000b7a0:	e0 88 00 12 	brls	8000b7c4 <__avr32_umod64+0x3c>
8000b7a4:	f0 08 12 00 	clz	r8,r8
8000b7a8:	c4 e0       	breq	8000b844 <__avr32_umod64+0xbc>
8000b7aa:	f6 08 09 46 	lsl	r6,r11,r8
8000b7ae:	f8 08 09 4c 	lsl	r12,r12,r8
8000b7b2:	f0 0b 11 20 	rsub	r11,r8,32
8000b7b6:	f4 08 09 4e 	lsl	lr,r10,r8
8000b7ba:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b7be:	f7 e6 10 06 	or	r6,r11,r6
8000b7c2:	c4 18       	rjmp	8000b844 <__avr32_umod64+0xbc>
8000b7c4:	58 08       	cp.w	r8,0
8000b7c6:	c0 51       	brne	8000b7d0 <__avr32_umod64+0x48>
8000b7c8:	30 19       	mov	r9,1
8000b7ca:	f2 08 0d 08 	divu	r8,r9,r8
8000b7ce:	10 9c       	mov	r12,r8
8000b7d0:	f8 08 12 00 	clz	r8,r12
8000b7d4:	c0 31       	brne	8000b7da <__avr32_umod64+0x52>
8000b7d6:	18 16       	sub	r6,r12
8000b7d8:	c3 68       	rjmp	8000b844 <__avr32_umod64+0xbc>
8000b7da:	f0 03 11 20 	rsub	r3,r8,32
8000b7de:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b7e2:	f8 08 09 4c 	lsl	r12,r12,r8
8000b7e6:	ec 08 09 49 	lsl	r9,r6,r8
8000b7ea:	ec 03 0a 43 	lsr	r3,r6,r3
8000b7ee:	f7 e9 10 09 	or	r9,r11,r9
8000b7f2:	f8 05 16 10 	lsr	r5,r12,0x10
8000b7f6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b7fa:	e6 05 0d 02 	divu	r2,r3,r5
8000b7fe:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b802:	ec 02 02 4b 	mul	r11,r6,r2
8000b806:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b80a:	16 3e       	cp.w	lr,r11
8000b80c:	c0 72       	brcc	8000b81a <__avr32_umod64+0x92>
8000b80e:	18 0e       	add	lr,r12
8000b810:	18 3e       	cp.w	lr,r12
8000b812:	c0 43       	brcs	8000b81a <__avr32_umod64+0x92>
8000b814:	16 3e       	cp.w	lr,r11
8000b816:	fd dc e3 0e 	addcs	lr,lr,r12
8000b81a:	fc 0b 01 03 	sub	r3,lr,r11
8000b81e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b822:	e6 05 0d 02 	divu	r2,r3,r5
8000b826:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b82a:	a5 36       	mul	r6,r2
8000b82c:	0c 39       	cp.w	r9,r6
8000b82e:	c0 72       	brcc	8000b83c <__avr32_umod64+0xb4>
8000b830:	18 09       	add	r9,r12
8000b832:	18 39       	cp.w	r9,r12
8000b834:	c0 43       	brcs	8000b83c <__avr32_umod64+0xb4>
8000b836:	0c 39       	cp.w	r9,r6
8000b838:	f3 dc e3 09 	addcs	r9,r9,r12
8000b83c:	f2 06 01 06 	sub	r6,r9,r6
8000b840:	f4 08 09 4e 	lsl	lr,r10,r8
8000b844:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b848:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b84c:	ec 0a 0d 02 	divu	r2,r6,r10
8000b850:	fc 09 16 10 	lsr	r9,lr,0x10
8000b854:	ea 02 02 4b 	mul	r11,r5,r2
8000b858:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b85c:	16 39       	cp.w	r9,r11
8000b85e:	c0 72       	brcc	8000b86c <__avr32_umod64+0xe4>
8000b860:	18 09       	add	r9,r12
8000b862:	18 39       	cp.w	r9,r12
8000b864:	c0 43       	brcs	8000b86c <__avr32_umod64+0xe4>
8000b866:	16 39       	cp.w	r9,r11
8000b868:	f3 dc e3 09 	addcs	r9,r9,r12
8000b86c:	f2 0b 01 0b 	sub	r11,r9,r11
8000b870:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b874:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b878:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b87c:	ea 0a 02 4a 	mul	r10,r5,r10
8000b880:	14 3e       	cp.w	lr,r10
8000b882:	c0 72       	brcc	8000b890 <__avr32_umod64+0x108>
8000b884:	18 0e       	add	lr,r12
8000b886:	18 3e       	cp.w	lr,r12
8000b888:	c0 43       	brcs	8000b890 <__avr32_umod64+0x108>
8000b88a:	14 3e       	cp.w	lr,r10
8000b88c:	fd dc e3 0e 	addcs	lr,lr,r12
8000b890:	fc 0a 01 0a 	sub	r10,lr,r10
8000b894:	30 0b       	mov	r11,0
8000b896:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b89a:	c7 b8       	rjmp	8000b990 <__avr32_umod64+0x208>
8000b89c:	16 39       	cp.w	r9,r11
8000b89e:	e0 8b 00 79 	brhi	8000b990 <__avr32_umod64+0x208>
8000b8a2:	f2 09 12 00 	clz	r9,r9
8000b8a6:	c1 21       	brne	8000b8ca <__avr32_umod64+0x142>
8000b8a8:	10 3a       	cp.w	r10,r8
8000b8aa:	5f 2b       	srhs	r11
8000b8ac:	0a 31       	cp.w	r1,r5
8000b8ae:	5f ba       	srhi	r10
8000b8b0:	f7 ea 10 0a 	or	r10,r11,r10
8000b8b4:	f2 0a 18 00 	cp.b	r10,r9
8000b8b8:	c0 60       	breq	8000b8c4 <__avr32_umod64+0x13c>
8000b8ba:	fc 08 01 0c 	sub	r12,lr,r8
8000b8be:	e2 05 01 46 	sbc	r6,r1,r5
8000b8c2:	18 9e       	mov	lr,r12
8000b8c4:	0c 9b       	mov	r11,r6
8000b8c6:	1c 9a       	mov	r10,lr
8000b8c8:	c6 48       	rjmp	8000b990 <__avr32_umod64+0x208>
8000b8ca:	ea 09 09 4c 	lsl	r12,r5,r9
8000b8ce:	f2 06 11 20 	rsub	r6,r9,32
8000b8d2:	f6 09 09 4b 	lsl	r11,r11,r9
8000b8d6:	f0 09 09 42 	lsl	r2,r8,r9
8000b8da:	ef 46 ff f4 	st.w	r7[-12],r6
8000b8de:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8e2:	18 48       	or	r8,r12
8000b8e4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b8e8:	f4 09 09 43 	lsl	r3,r10,r9
8000b8ec:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b8f0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b8f4:	16 4a       	or	r10,r11
8000b8f6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b8fa:	f8 0b 0d 04 	divu	r4,r12,r11
8000b8fe:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b902:	08 91       	mov	r1,r4
8000b904:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b908:	e8 0e 02 46 	mul	r6,r4,lr
8000b90c:	0c 3c       	cp.w	r12,r6
8000b90e:	c0 a2       	brcc	8000b922 <__avr32_umod64+0x19a>
8000b910:	20 11       	sub	r1,1
8000b912:	10 0c       	add	r12,r8
8000b914:	10 3c       	cp.w	r12,r8
8000b916:	c0 63       	brcs	8000b922 <__avr32_umod64+0x19a>
8000b918:	0c 3c       	cp.w	r12,r6
8000b91a:	f7 b1 03 01 	sublo	r1,1
8000b91e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b922:	0c 1c       	sub	r12,r6
8000b924:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b928:	f8 0b 0d 04 	divu	r4,r12,r11
8000b92c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000b930:	08 96       	mov	r6,r4
8000b932:	e8 0e 02 4e 	mul	lr,r4,lr
8000b936:	1c 3b       	cp.w	r11,lr
8000b938:	c0 a2       	brcc	8000b94c <__avr32_umod64+0x1c4>
8000b93a:	20 16       	sub	r6,1
8000b93c:	10 0b       	add	r11,r8
8000b93e:	10 3b       	cp.w	r11,r8
8000b940:	c0 63       	brcs	8000b94c <__avr32_umod64+0x1c4>
8000b942:	1c 3b       	cp.w	r11,lr
8000b944:	f7 b6 03 01 	sublo	r6,1
8000b948:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000b94c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000b950:	1c 1b       	sub	r11,lr
8000b952:	e2 02 06 40 	mulu.d	r0,r1,r2
8000b956:	00 9e       	mov	lr,r0
8000b958:	02 9c       	mov	r12,r1
8000b95a:	16 3c       	cp.w	r12,r11
8000b95c:	e0 8b 00 08 	brhi	8000b96c <__avr32_umod64+0x1e4>
8000b960:	5f 06       	sreq	r6
8000b962:	06 30       	cp.w	r0,r3
8000b964:	5f ba       	srhi	r10
8000b966:	ed ea 00 0a 	and	r10,r6,r10
8000b96a:	c0 60       	breq	8000b976 <__avr32_umod64+0x1ee>
8000b96c:	fc 02 01 04 	sub	r4,lr,r2
8000b970:	f8 08 01 4c 	sbc	r12,r12,r8
8000b974:	08 9e       	mov	lr,r4
8000b976:	e6 0e 01 0a 	sub	r10,r3,lr
8000b97a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000b97e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000b982:	f8 09 0a 4b 	lsr	r11,r12,r9
8000b986:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b98a:	f8 01 09 4c 	lsl	r12,r12,r1
8000b98e:	18 4a       	or	r10,r12
8000b990:	2f dd       	sub	sp,-12
8000b992:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ba00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ba00:	c0 08       	rjmp	8000ba00 <_evba>
	...

8000ba04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ba04:	c0 08       	rjmp	8000ba04 <_handle_TLB_Multiple_Hit>
	...

8000ba08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ba08:	c0 08       	rjmp	8000ba08 <_handle_Bus_Error_Data_Fetch>
	...

8000ba0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ba0c:	c0 08       	rjmp	8000ba0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ba10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ba10:	c0 08       	rjmp	8000ba10 <_handle_NMI>
	...

8000ba14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ba14:	c0 08       	rjmp	8000ba14 <_handle_Instruction_Address>
	...

8000ba18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ba18:	c0 08       	rjmp	8000ba18 <_handle_ITLB_Protection>
	...

8000ba1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ba1c:	c0 08       	rjmp	8000ba1c <_handle_Breakpoint>
	...

8000ba20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ba20:	c0 08       	rjmp	8000ba20 <_handle_Illegal_Opcode>
	...

8000ba24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ba24:	c0 08       	rjmp	8000ba24 <_handle_Unimplemented_Instruction>
	...

8000ba28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ba28:	c0 08       	rjmp	8000ba28 <_handle_Privilege_Violation>
	...

8000ba2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ba2c:	c0 08       	rjmp	8000ba2c <_handle_Floating_Point>
	...

8000ba30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ba30:	c0 08       	rjmp	8000ba30 <_handle_Coprocessor_Absent>
	...

8000ba34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ba34:	c0 08       	rjmp	8000ba34 <_handle_Data_Address_Read>
	...

8000ba38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ba38:	c0 08       	rjmp	8000ba38 <_handle_Data_Address_Write>
	...

8000ba3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ba3c:	c0 08       	rjmp	8000ba3c <_handle_DTLB_Protection_Read>
	...

8000ba40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ba40:	c0 08       	rjmp	8000ba40 <_handle_DTLB_Protection_Write>
	...

8000ba44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ba44:	c0 08       	rjmp	8000ba44 <_handle_DTLB_Modified>
	...

8000ba50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ba50:	c0 08       	rjmp	8000ba50 <_handle_ITLB_Miss>
	...

8000ba60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ba60:	c0 08       	rjmp	8000ba60 <_handle_DTLB_Miss_Read>
	...

8000ba70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ba70:	c0 08       	rjmp	8000ba70 <_handle_DTLB_Miss_Write>
	...

8000bb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bb00:	fe cf 6f 58 	sub	pc,pc,28504

8000bb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bb04:	30 0c       	mov	r12,0
8000bb06:	fe b0 c6 4b 	rcall	8000479c <_get_interrupt_handler>
8000bb0a:	58 0c       	cp.w	r12,0
8000bb0c:	f8 0f 17 10 	movne	pc,r12
8000bb10:	d6 03       	rete

8000bb12 <_int1>:
8000bb12:	30 1c       	mov	r12,1
8000bb14:	fe b0 c6 44 	rcall	8000479c <_get_interrupt_handler>
8000bb18:	58 0c       	cp.w	r12,0
8000bb1a:	f8 0f 17 10 	movne	pc,r12
8000bb1e:	d6 03       	rete

8000bb20 <_int2>:
8000bb20:	30 2c       	mov	r12,2
8000bb22:	fe b0 c6 3d 	rcall	8000479c <_get_interrupt_handler>
8000bb26:	58 0c       	cp.w	r12,0
8000bb28:	f8 0f 17 10 	movne	pc,r12
8000bb2c:	d6 03       	rete

8000bb2e <_int3>:
8000bb2e:	30 3c       	mov	r12,3
8000bb30:	fe b0 c6 36 	rcall	8000479c <_get_interrupt_handler>
8000bb34:	58 0c       	cp.w	r12,0
8000bb36:	f8 0f 17 10 	movne	pc,r12
8000bb3a:	d6 03       	rete

8000bb3c <ipr_val>:
8000bb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbfc:	d7 03 d7 03                                         ....
