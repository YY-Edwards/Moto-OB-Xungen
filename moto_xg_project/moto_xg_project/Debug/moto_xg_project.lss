
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009da4  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000010b0  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a2c  00000004  8000d0b0  0000d804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000036e0  00000a30  8000dadc  0000e230  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000e230  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001080  00000000  00000000  0000e260  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000023e9  00000000  00000000  0000f2e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002678a  00000000  00000000  000116c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00006475  00000000  00000000  00037e53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00014511  00000000  00000000  0003e2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002b48  00000000  00000000  000527dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00006a92  00000000  00000000  00055324  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000c511  00000000  00000000  0005bdb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 0137fb70  00000000  00000000  000682c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001170  00000000  00000000  013e7e38  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d2 34 	sub	pc,pc,-11724

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 80       	ld.ub	r0,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 48       	or	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	40 c8       	lddsp	r8,sp[0x30]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 70       	sub	r0,-121
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 10       	sub	r0,-111
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c0 00       	breq	80002082 <app_init+0x46>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 fc       	sub	r12,127
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	5c c4       	swap.bh	r4
8000208c:	00 00       	add	r0,r0
8000208e:	0a 3c       	cp.w	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	c0 08       	rjmp	8000209e <app_payload_tx_proc+0xe>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	60 88       	ld.w	r8,r0[0x20]

800020a4 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a4:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a6:	48 3c       	lddpc	r12,800020b0 <FD_brdcst_func+0xc>
800020a8:	f0 1f 00 03 	mcall	800020b4 <FD_brdcst_func+0x10>
	
}
800020ac:	d8 02       	popm	pc
800020ae:	00 00       	add	r0,r0
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	c0 0c       	rcall	800020b2 <FD_brdcst_func+0xe>
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	60 88       	ld.w	r8,r0[0x20]

800020b8 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ba:	48 3c       	lddpc	r12,800020c4 <FD_reply_func+0xc>
800020bc:	f0 1f 00 03 	mcall	800020c8 <FD_reply_func+0x10>
	
	
}
800020c0:	d8 02       	popm	pc
800020c2:	00 00       	add	r0,r0
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	c0 2c       	rcall	800020ca <FD_reply_func+0x12>
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	60 88       	ld.w	r8,r0[0x20]

800020cc <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020cc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ce:	48 3c       	lddpc	r12,800020d8 <FD_request_func+0xc>
800020d0:	f0 1f 00 03 	mcall	800020dc <FD_request_func+0x10>
	
	
}
800020d4:	d8 02       	popm	pc
800020d6:	00 00       	add	r0,r0
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	c0 48       	rjmp	800020e2 <EnOB_brdcst_func+0x2>
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	60 88       	ld.w	r8,r0[0x20]

800020e0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e2:	48 3c       	lddpc	r12,800020ec <EnOB_brdcst_func+0xc>
800020e4:	f0 1f 00 03 	mcall	800020f0 <EnOB_brdcst_func+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	c0 64       	brge	800020fa <EnOB_reply_func+0x6>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	60 88       	ld.w	r8,r0[0x20]

800020f4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f4:	eb cd 40 80 	pushm	r7,lr
800020f8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fa:	19 a9       	ld.ub	r9,r12[0x2]
800020fc:	30 08       	mov	r8,0
800020fe:	f0 09 18 00 	cp.b	r9,r8
80002102:	c1 91       	brne	80002134 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002104:	19 b8       	ld.ub	r8,r12[0x3]
80002106:	30 19       	mov	r9,1
80002108:	f2 08 18 00 	cp.b	r8,r9
8000210c:	c0 61       	brne	80002118 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210e:	49 0c       	lddpc	r12,8000214c <EnOB_reply_func+0x58>
80002110:	f0 1f 00 10 	mcall	80002150 <EnOB_reply_func+0x5c>
80002114:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002118:	58 08       	cp.w	r8,0
8000211a:	c0 61       	brne	80002126 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000211c:	48 ec       	lddpc	r12,80002154 <EnOB_reply_func+0x60>
8000211e:	f0 1f 00 0d 	mcall	80002150 <EnOB_reply_func+0x5c>
80002122:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002126:	1a d8       	st.w	--sp,r8
80002128:	48 cc       	lddpc	r12,80002158 <EnOB_reply_func+0x64>
8000212a:	f0 1f 00 0a 	mcall	80002150 <EnOB_reply_func+0x5c>
8000212e:	2f fd       	sub	sp,-4
80002130:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002134:	48 ac       	lddpc	r12,8000215c <EnOB_reply_func+0x68>
80002136:	f0 1f 00 07 	mcall	80002150 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213a:	0f a8       	ld.ub	r8,r7[0x2]
8000213c:	1a d8       	st.w	--sp,r8
8000213e:	48 9c       	lddpc	r12,80002160 <EnOB_reply_func+0x6c>
80002140:	f0 1f 00 04 	mcall	80002150 <EnOB_reply_func+0x5c>
80002144:	2f fd       	sub	sp,-4
80002146:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214a:	00 00       	add	r0,r0
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	c0 7c       	rcall	8000215c <EnOB_reply_func+0x68>
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	60 88       	ld.w	r8,r0[0x20]
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	c0 94       	brge	80002168 <SingleDetection_brdcst_func+0x4>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c0 a8       	rjmp	8000216e <SingleDetection_brdcst_func+0xa>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c0 c0       	breq	80002176 <SingleDetection_brdcst_func+0x12>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	c0 dc       	rcall	8000217c <SingleDetection_brdcst_func+0x18>

80002164 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 41       	brne	80002176 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 2c       	lddpc	r12,80002178 <SingleDetection_brdcst_func+0x14>
80002172:	f0 1f 00 03 	mcall	8000217c <SingleDetection_brdcst_func+0x18>
80002176:	d8 02       	popm	pc
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	c0 f4       	brge	80002198 <ButtonConfig_brdcst_func+0x18>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	60 88       	ld.w	r8,r0[0x20]

80002180 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002180:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002182:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002186:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002188:	4a bc       	lddpc	r12,80002234 <ButtonConfig_brdcst_func+0xb4>
8000218a:	f0 1f 00 2c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000218e:	0f 88       	ld.ub	r8,r7[0x0]
80002190:	1a d8       	st.w	--sp,r8
80002192:	4a bc       	lddpc	r12,8000223c <ButtonConfig_brdcst_func+0xbc>
80002194:	f0 1f 00 29 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002198:	1a d5       	st.w	--sp,r5
8000219a:	4a ac       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xc0>
8000219c:	f0 1f 00 27 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a0:	0f a8       	ld.ub	r8,r7[0x2]
800021a2:	1a d8       	st.w	--sp,r8
800021a4:	4a 8c       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc4>
800021a6:	f0 1f 00 25 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021aa:	2f dd       	sub	sp,-12
800021ac:	58 05       	cp.w	r5,0
800021ae:	c4 10       	breq	80002230 <ButtonConfig_brdcst_func+0xb0>
800021b0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b2:	4a 64       	lddpc	r4,80002248 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b4:	4a 63       	lddpc	r3,8000224c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021b6:	4a 72       	lddpc	r2,80002250 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021b8:	4a 71       	lddpc	r1,80002254 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ba:	4a 80       	lddpc	r0,80002258 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021bc:	0f b9       	ld.ub	r9,r7[0x3]
800021be:	0f c8       	ld.ub	r8,r7[0x4]
800021c0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	1a d6       	st.w	--sp,r6
800021c8:	08 9c       	mov	r12,r4
800021ca:	f0 1f 00 1c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ce:	0f d9       	ld.ub	r9,r7[0x5]
800021d0:	0f e8       	ld.ub	r8,r7[0x6]
800021d2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	1a d6       	st.w	--sp,r6
800021da:	06 9c       	mov	r12,r3
800021dc:	f0 1f 00 17 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e0:	0f f9       	ld.ub	r9,r7[0x7]
800021e2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021e6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ea:	1a d8       	st.w	--sp,r8
800021ec:	1a d6       	st.w	--sp,r6
800021ee:	04 9c       	mov	r12,r2
800021f0:	f0 1f 00 12 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f4:	ef 39 00 09 	ld.ub	r9,r7[9]
800021f8:	ef 38 00 0a 	ld.ub	r8,r7[10]
800021fc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002200:	1a d8       	st.w	--sp,r8
80002202:	1a d6       	st.w	--sp,r6
80002204:	02 9c       	mov	r12,r1
80002206:	f0 1f 00 0d 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220a:	2f 8d       	sub	sp,-32
8000220c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002210:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	00 9c       	mov	r12,r0
8000221e:	f0 1f 00 07 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
80002222:	2f f6       	sub	r6,-1
80002224:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002226:	2f ed       	sub	sp,-8
80002228:	ec 05 18 00 	cp.b	r5,r6
8000222c:	fe 9b ff c8 	brhi	800021bc <ButtonConfig_brdcst_func+0x3c>
80002230:	d8 32       	popm	r0-r7,pc
80002232:	00 00       	add	r0,r0
80002234:	80 00       	ld.sh	r0,r0[0x0]
80002236:	c1 08       	rjmp	80002256 <ButtonConfig_brdcst_func+0xd6>
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	60 88       	ld.w	r8,r0[0x20]
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	c1 28       	rjmp	80002262 <Phyuserinput_brdcst_func+0x6>
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	c1 3c       	rcall	80002268 <Phyuserinput_brdcst_func+0xc>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	c1 54       	brge	80002270 <Phyuserinput_brdcst_func+0x14>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	c1 74       	brge	80002278 <Phyuserinput_brdcst_func+0x1c>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	c1 9c       	rcall	80002280 <Phyuserinput_brdcst_func+0x24>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	c1 c4       	brge	8000228a <Phyuserinput_brdcst_func+0x2e>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	c1 e8       	rjmp	80002292 <Phyuserinput_brdcst_func+0x36>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	c2 10       	breq	8000229c <Phyuserinput_brdcst_func+0x40>

8000225c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000225c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002260:	19 c7       	ld.ub	r7,r12[0x4]
80002262:	19 d8       	ld.ub	r8,r12[0x5]
80002264:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002268:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000226a:	48 ac       	lddpc	r12,80002290 <Phyuserinput_brdcst_func+0x34>
8000226c:	f0 1f 00 0a 	mcall	80002294 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002270:	36 08       	mov	r8,96
80002272:	f0 07 19 00 	cp.h	r7,r8
80002276:	c0 a1       	brne	8000228a <Phyuserinput_brdcst_func+0x2e>
80002278:	48 88       	lddpc	r8,80002298 <Phyuserinput_brdcst_func+0x3c>
8000227a:	11 89       	ld.ub	r9,r8[0x0]
8000227c:	30 18       	mov	r8,1
8000227e:	f0 09 18 00 	cp.b	r9,r8
80002282:	c0 41       	brne	8000228a <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
80002284:	48 6c       	lddpc	r12,8000229c <Phyuserinput_brdcst_func+0x40>
80002286:	f0 1f 00 04 	mcall	80002294 <Phyuserinput_brdcst_func+0x38>
8000228a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000228e:	00 00       	add	r0,r0
80002290:	80 00       	ld.sh	r0,r0[0x0]
80002292:	c2 34       	brge	800022d8 <ButtonConfig_reply_func+0x38>
80002294:	80 00       	ld.sh	r0,r0[0x0]
80002296:	60 88       	ld.w	r8,r0[0x20]
80002298:	00 00       	add	r0,r0
8000229a:	0a 44       	or	r4,r5
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	c2 54       	brge	800022e8 <DataSession_brdcst_func+0x4>

800022a0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022a4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022a8:	0f 89       	ld.ub	r9,r7[0x0]
800022aa:	30 08       	mov	r8,0
800022ac:	f0 09 18 00 	cp.b	r9,r8
800022b0:	c0 c1       	brne	800022c8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022b2:	48 9c       	lddpc	r12,800022d4 <ButtonConfig_reply_func+0x34>
800022b4:	f0 1f 00 09 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022b8:	0f 98       	ld.ub	r8,r7[0x1]
800022ba:	1a d8       	st.w	--sp,r8
800022bc:	48 8c       	lddpc	r12,800022dc <ButtonConfig_reply_func+0x3c>
800022be:	f0 1f 00 07 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
800022c2:	2f fd       	sub	sp,-4
800022c4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022c8:	48 6c       	lddpc	r12,800022e0 <ButtonConfig_reply_func+0x40>
800022ca:	f0 1f 00 04 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
800022ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c2 64       	brge	80002322 <DataSession_brdcst_func+0x3e>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	60 88       	ld.w	r8,r0[0x20]
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c1 28       	rjmp	80002302 <DataSession_brdcst_func+0x1e>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c2 7c       	rcall	80002330 <DataSession_brdcst_func+0x4c>

800022e4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800022e6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800022ea:	0d 88       	ld.ub	r8,r6[0x0]
800022ec:	32 49       	mov	r9,36
800022ee:	f2 08 18 00 	cp.b	r8,r9
800022f2:	c2 91       	brne	80002344 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800022f4:	4a dc       	lddpc	r12,800023a8 <DataSession_brdcst_func+0xc4>
800022f6:	f0 1f 00 2e 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800022fa:	0d a5       	ld.ub	r5,r6[0x2]
800022fc:	0d b8       	ld.ub	r8,r6[0x3]
800022fe:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002302:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002304:	0d 98       	ld.ub	r8,r6[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	4a ac       	lddpc	r12,800023b0 <DataSession_brdcst_func+0xcc>
8000230a:	f0 1f 00 29 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000230e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002312:	1a d8       	st.w	--sp,r8
80002314:	4a 8c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0xd0>
80002316:	f0 1f 00 26 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000231a:	2f ed       	sub	sp,-8
8000231c:	58 05       	cp.w	r5,0
8000231e:	c4 40       	breq	800023a6 <DataSession_brdcst_func+0xc2>
80002320:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002322:	4a 64       	lddpc	r4,800023b8 <DataSession_brdcst_func+0xd4>
80002324:	ec 07 00 08 	add	r8,r6,r7
80002328:	11 c8       	ld.ub	r8,r8[0x4]
8000232a:	1a d8       	st.w	--sp,r8
8000232c:	1a d7       	st.w	--sp,r7
8000232e:	08 9c       	mov	r12,r4
80002330:	f0 1f 00 1f 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002334:	2f f7       	sub	r7,-1
80002336:	5c 57       	castu.b	r7
80002338:	2f ed       	sub	sp,-8
8000233a:	ee 05 19 00 	cp.h	r5,r7
8000233e:	fe 9b ff f3 	brhi	80002324 <DataSession_brdcst_func+0x40>
80002342:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
80002344:	1a d8       	st.w	--sp,r8
80002346:	49 ec       	lddpc	r12,800023bc <DataSession_brdcst_func+0xd8>
80002348:	f0 1f 00 19 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		if (ptr->State)
8000234c:	2f fd       	sub	sp,-4
8000234e:	0d 89       	ld.ub	r9,r6[0x0]
80002350:	30 08       	mov	r8,0
80002352:	f0 09 18 00 	cp.b	r9,r8
80002356:	c0 40       	breq	8000235e <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
80002358:	49 ac       	lddpc	r12,800023c0 <DataSession_brdcst_func+0xdc>
8000235a:	f0 1f 00 15 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	49 1c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0xcc>
8000236e:	f0 1f 00 10 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 fc       	lddpc	r12,800023b4 <DataSession_brdcst_func+0xd0>
8000237a:	f0 1f 00 0d 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c1 20       	breq	800023a6 <DataSession_brdcst_func+0xc2>
80002384:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	48 d4       	lddpc	r4,800023b8 <DataSession_brdcst_func+0xd4>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 06 	mcall	800023ac <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0xa4>
800023a6:	d8 22       	popm	r4-r7,pc
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	c2 98       	rjmp	800023fc <DataSession_reply_func+0x38>
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	60 88       	ld.w	r8,r0[0x20]
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	c2 ac       	rcall	80002406 <DataSession_reply_func+0x42>
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	c2 c4       	brge	8000240e <DataSession_reply_func+0x4a>
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	c2 e0       	breq	80002416 <DataSession_reply_func+0x52>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	c2 f8       	rjmp	8000241c <DataSession_reply_func+0x58>
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	c3 08       	rjmp	80002422 <DataSession_reply_func+0x5e>

800023c4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a9       	ld.ub	r9,r12[0x2]
800023cc:	30 08       	mov	r8,0
800023ce:	f0 09 18 00 	cp.b	r9,r8
800023d2:	c1 11       	brne	800023f4 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800023d4:	49 3c       	lddpc	r12,80002420 <DataSession_reply_func+0x5c>
800023d6:	f0 1f 00 14 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023da:	0f b8       	ld.ub	r8,r7[0x3]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	49 3c       	lddpc	r12,80002428 <DataSession_reply_func+0x64>
800023e0:	f0 1f 00 11 	mcall	80002424 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023e4:	0f c8       	ld.ub	r8,r7[0x4]
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	49 1c       	lddpc	r12,8000242c <DataSession_reply_func+0x68>
800023ea:	f0 1f 00 0f 	mcall	80002424 <DataSession_reply_func+0x60>
800023ee:	2f ed       	sub	sp,-8
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023f4:	48 fc       	lddpc	r12,80002430 <DataSession_reply_func+0x6c>
800023f6:	f0 1f 00 0c 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023fa:	0f a8       	ld.ub	r8,r7[0x2]
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	48 ec       	lddpc	r12,80002434 <DataSession_reply_func+0x70>
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002404:	0f b8       	ld.ub	r8,r7[0x3]
80002406:	1a d8       	st.w	--sp,r8
80002408:	48 cc       	lddpc	r12,80002438 <DataSession_reply_func+0x74>
8000240a:	f0 1f 00 07 	mcall	80002424 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000240e:	0f c8       	ld.ub	r8,r7[0x4]
80002410:	1a d8       	st.w	--sp,r8
80002412:	48 bc       	lddpc	r12,8000243c <DataSession_reply_func+0x78>
80002414:	f0 1f 00 04 	mcall	80002424 <DataSession_reply_func+0x60>
80002418:	2f dd       	sub	sp,-12
8000241a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000241e:	00 00       	add	r0,r0
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c3 20       	breq	80002486 <TransmitControl_brdcst_func+0x2>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	60 88       	ld.w	r8,r0[0x20]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c3 30       	breq	80002490 <TransmitControl_brdcst_func+0xc>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	c3 3c       	rcall	80002494 <TransmitControl_brdcst_func+0x10>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c3 48       	rjmp	8000249a <TransmitControl_brdcst_func+0x16>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	c3 58       	rjmp	800024a0 <TransmitControl_brdcst_func+0x1c>
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	c3 68       	rjmp	800024a6 <TransmitControl_brdcst_func+0x22>
8000243c:	80 00       	ld.sh	r0,r0[0x0]
8000243e:	c3 74       	brge	800024ac <TransmitControl_brdcst_func+0x28>

80002440 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002440:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002444:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002448:	0f 98       	ld.ub	r8,r7[0x1]
8000244a:	1a d8       	st.w	--sp,r8
8000244c:	48 bc       	lddpc	r12,80002478 <CallControl_brdcst_func+0x38>
8000244e:	f0 1f 00 0c 	mcall	8000247c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002452:	2f fd       	sub	sp,-4
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 38       	mov	r8,3
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 41       	brne	80002464 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000245e:	30 09       	mov	r9,0
80002460:	48 88       	lddpc	r8,80002480 <CallControl_brdcst_func+0x40>
80002462:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002464:	0f 99       	ld.ub	r9,r7[0x1]
80002466:	30 48       	mov	r8,4
80002468:	f0 09 18 00 	cp.b	r9,r8
8000246c:	c0 41       	brne	80002474 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000246e:	30 19       	mov	r9,1
80002470:	48 48       	lddpc	r8,80002480 <CallControl_brdcst_func+0x40>
80002472:	b0 89       	st.b	r8[0x0],r9
80002474:	e3 cd 80 80 	ldm	sp++,r7,pc
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c3 80       	breq	800024ea <TransmitControl_reply_func+0x1e>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	60 88       	ld.w	r8,r0[0x20]
80002480:	00 00       	add	r0,r0
80002482:	0a 40       	or	r0,r5

80002484 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 71       	brne	800024a2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002496:	48 ac       	lddpc	r12,800024bc <TransmitControl_brdcst_func+0x38>
80002498:	f0 1f 00 0a 	mcall	800024c0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
8000249c:	30 09       	mov	r9,0
8000249e:	48 a8       	lddpc	r8,800024c4 <TransmitControl_brdcst_func+0x40>
800024a0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024a2:	0f 99       	ld.ub	r9,r7[0x1]
800024a4:	30 18       	mov	r8,1
800024a6:	f0 09 18 00 	cp.b	r9,r8
800024aa:	c0 71       	brne	800024b8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024ac:	48 7c       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x44>
800024ae:	f0 1f 00 05 	mcall	800024c0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <TransmitControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c3 98       	rjmp	80002530 <AudioRoutingControl_reply_func+0x4>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	60 88       	ld.w	r8,r0[0x20]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 38       	cp.w	r8,r5
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	c3 b0       	breq	80002540 <AudioRoutingControl_reply_func+0x14>

800024cc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024d0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024d4:	0f 89       	ld.ub	r9,r7[0x0]
800024d6:	30 08       	mov	r8,0
800024d8:	f0 09 18 00 	cp.b	r9,r8
800024dc:	c1 61       	brne	80002508 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024de:	48 ec       	lddpc	r12,80002514 <TransmitControl_reply_func+0x48>
800024e0:	f0 1f 00 0e 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024e4:	0f 98       	ld.ub	r8,r7[0x1]
800024e6:	1a d8       	st.w	--sp,r8
800024e8:	48 dc       	lddpc	r12,8000251c <TransmitControl_reply_func+0x50>
800024ea:	f0 1f 00 0c 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024ee:	0f a8       	ld.ub	r8,r7[0x2]
800024f0:	1a d8       	st.w	--sp,r8
800024f2:	48 cc       	lddpc	r12,80002520 <TransmitControl_reply_func+0x54>
800024f4:	f0 1f 00 09 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024f8:	0f b8       	ld.ub	r8,r7[0x3]
800024fa:	1a d8       	st.w	--sp,r8
800024fc:	48 ac       	lddpc	r12,80002524 <TransmitControl_reply_func+0x58>
800024fe:	f0 1f 00 07 	mcall	80002518 <TransmitControl_reply_func+0x4c>
80002502:	2f dd       	sub	sp,-12
80002504:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002508:	48 8c       	lddpc	r12,80002528 <TransmitControl_reply_func+0x5c>
8000250a:	f0 1f 00 04 	mcall	80002518 <TransmitControl_reply_func+0x4c>
8000250e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002512:	00 00       	add	r0,r0
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	c3 c4       	brge	8000258e <Volume_reply_func+0x3a>
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	60 88       	ld.w	r8,r0[0x20]
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	c3 e0       	breq	8000259a <Volume_reply_func+0x46>
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	c3 f4       	brge	800025a0 <Volume_reply_func+0x4c>
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	c4 10       	breq	800025a8 <Volume_reply_func+0x54>
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	c4 20       	breq	800025ae <Volume_reply_func+0x5a>

8000252c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000252c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000252e:	19 a9       	ld.ub	r9,r12[0x2]
80002530:	30 08       	mov	r8,0
80002532:	f0 09 18 00 	cp.b	r9,r8
80002536:	c0 51       	brne	80002540 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002538:	48 4c       	lddpc	r12,80002548 <AudioRoutingControl_reply_func+0x1c>
8000253a:	f0 1f 00 05 	mcall	8000254c <AudioRoutingControl_reply_func+0x20>
8000253e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002540:	48 4c       	lddpc	r12,80002550 <AudioRoutingControl_reply_func+0x24>
80002542:	f0 1f 00 03 	mcall	8000254c <AudioRoutingControl_reply_func+0x20>
80002546:	d8 02       	popm	pc
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	c4 38       	rjmp	800025d0 <spk_brdcst_func+0x18>
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	60 88       	ld.w	r8,r0[0x20]
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	c4 48       	rjmp	800025da <spk_brdcst_func+0x22>

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	c4 5c       	rcall	80002630 <spk_reply_func+0x40>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	60 88       	ld.w	r8,r0[0x20]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	c4 70       	breq	8000263c <mic_brdcst_func+0x4>
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	c4 8c       	rcall	80002642 <mic_brdcst_func+0xa>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	c4 a4       	brge	8000264a <mic_brdcst_func+0x12>

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 81       	brne	800025d2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025c4:	10 99       	mov	r9,r8
800025c6:	48 78       	lddpc	r8,800025e0 <spk_brdcst_func+0x28>
800025c8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025ca:	48 7c       	lddpc	r12,800025e4 <spk_brdcst_func+0x2c>
800025cc:	f0 1f 00 07 	mcall	800025e8 <spk_brdcst_func+0x30>
800025d0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800025d2:	30 19       	mov	r9,1
800025d4:	48 38       	lddpc	r8,800025e0 <spk_brdcst_func+0x28>
800025d6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025d8:	48 5c       	lddpc	r12,800025ec <spk_brdcst_func+0x34>
800025da:	f0 1f 00 04 	mcall	800025e8 <spk_brdcst_func+0x30>
800025de:	d8 02       	popm	pc
800025e0:	00 00       	add	r0,r0
800025e2:	0a 30       	cp.w	r0,r5
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	c4 bc       	rcall	8000267c <mic_brdcst_func+0x44>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	60 88       	ld.w	r8,r0[0x20]
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c4 cc       	rcall	80002686 <mic_brdcst_func+0x4e>

800025f0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025f2:	19 a9       	ld.ub	r9,r12[0x2]
800025f4:	30 08       	mov	r8,0
800025f6:	f0 09 18 00 	cp.b	r9,r8
800025fa:	c0 f1       	brne	80002618 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025fc:	19 e9       	ld.ub	r9,r12[0x6]
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 40       	breq	8000260a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002604:	30 19       	mov	r9,1
80002606:	48 98       	lddpc	r8,80002628 <spk_reply_func+0x38>
80002608:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000260a:	19 e8       	ld.ub	r8,r12[0x6]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	48 8c       	lddpc	r12,8000262c <spk_reply_func+0x3c>
80002610:	f0 1f 00 08 	mcall	80002630 <spk_reply_func+0x40>
80002614:	2f fd       	sub	sp,-4
80002616:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 48       	lddpc	r8,80002628 <spk_reply_func+0x38>
8000261c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000261e:	48 6c       	lddpc	r12,80002634 <spk_reply_func+0x44>
80002620:	f0 1f 00 04 	mcall	80002630 <spk_reply_func+0x40>
80002624:	d8 02       	popm	pc
80002626:	00 00       	add	r0,r0
80002628:	00 00       	add	r0,r0
8000262a:	0a 30       	cp.w	r0,r5
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	c4 d8       	rjmp	800026c8 <mic_reply_func+0x38>
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	60 88       	ld.w	r8,r0[0x20]
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	c4 e8       	rjmp	800026d2 <mic_reply_func+0x42>

80002638 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002638:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000263c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002640:	0f a9       	ld.ub	r9,r7[0x2]
80002642:	30 08       	mov	r8,0
80002644:	f0 09 18 00 	cp.b	r9,r8
80002648:	c0 71       	brne	80002656 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000264a:	48 dc       	lddpc	r12,8000267c <mic_brdcst_func+0x44>
8000264c:	f0 1f 00 0d 	mcall	80002680 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002650:	30 09       	mov	r9,0
80002652:	48 d8       	lddpc	r8,80002684 <mic_brdcst_func+0x4c>
80002654:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002656:	0f a9       	ld.ub	r9,r7[0x2]
80002658:	31 18       	mov	r8,17
8000265a:	f0 09 18 00 	cp.b	r9,r8
8000265e:	c0 d1       	brne	80002678 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002660:	48 ac       	lddpc	r12,80002688 <mic_brdcst_func+0x50>
80002662:	f0 1f 00 08 	mcall	80002680 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002666:	48 89       	lddpc	r9,80002684 <mic_brdcst_func+0x4c>
80002668:	30 18       	mov	r8,1
8000266a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000266c:	13 89       	ld.ub	r9,r9[0x0]
8000266e:	f0 09 18 00 	cp.b	r9,r8
80002672:	c0 31       	brne	80002678 <mic_brdcst_func+0x40>
80002674:	48 68       	lddpc	r8,8000268c <mic_brdcst_func+0x54>
80002676:	11 88       	ld.ub	r8,r8[0x0]
80002678:	e3 cd 80 80 	ldm	sp++,r7,pc
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	c4 f4       	brge	8000271c <mic_reply_func+0x8c>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	60 88       	ld.w	r8,r0[0x20]
80002684:	00 00       	add	r0,r0
80002686:	0a 45       	or	r5,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	c5 08       	rjmp	8000272a <dcm_brdcst_func+0x6>
8000268c:	00 00       	add	r0,r0
8000268e:	0a 40       	or	r0,r5

80002690 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002690:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002694:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002698:	49 ac       	lddpc	r12,80002700 <mic_reply_func+0x70>
8000269a:	f0 1f 00 1b 	mcall	80002704 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000269e:	0f 89       	ld.ub	r9,r7[0x0]
800026a0:	30 08       	mov	r8,0
800026a2:	f0 09 18 00 	cp.b	r9,r8
800026a6:	c2 71       	brne	800026f4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026a8:	0f 98       	ld.ub	r8,r7[0x1]
800026aa:	30 29       	mov	r9,2
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c1 b1       	brne	800026e6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026b2:	49 6c       	lddpc	r12,80002708 <mic_reply_func+0x78>
800026b4:	f0 1f 00 14 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026b8:	0f a8       	ld.ub	r8,r7[0x2]
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	49 4c       	lddpc	r12,8000270c <mic_reply_func+0x7c>
800026be:	f0 1f 00 12 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026c2:	0f b8       	ld.ub	r8,r7[0x3]
800026c4:	1a d8       	st.w	--sp,r8
800026c6:	49 3c       	lddpc	r12,80002710 <mic_reply_func+0x80>
800026c8:	f0 1f 00 0f 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026cc:	0f c8       	ld.ub	r8,r7[0x4]
800026ce:	1a d8       	st.w	--sp,r8
800026d0:	49 1c       	lddpc	r12,80002714 <mic_reply_func+0x84>
800026d2:	f0 1f 00 0d 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026d6:	0f d8       	ld.ub	r8,r7[0x5]
800026d8:	1a d8       	st.w	--sp,r8
800026da:	49 0c       	lddpc	r12,80002718 <mic_reply_func+0x88>
800026dc:	f0 1f 00 0a 	mcall	80002704 <mic_reply_func+0x74>
800026e0:	2f cd       	sub	sp,-16
800026e2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026e6:	1a d8       	st.w	--sp,r8
800026e8:	48 dc       	lddpc	r12,8000271c <mic_reply_func+0x8c>
800026ea:	f0 1f 00 07 	mcall	80002704 <mic_reply_func+0x74>
800026ee:	2f fd       	sub	sp,-4
800026f0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026f4:	48 bc       	lddpc	r12,80002720 <mic_reply_func+0x90>
800026f6:	f0 1f 00 04 	mcall	80002704 <mic_reply_func+0x74>
800026fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fe:	00 00       	add	r0,r0
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	c5 1c       	rcall	800027a4 <dcm_reply_func+0x38>
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	60 88       	ld.w	r8,r0[0x20]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	c5 2c       	rcall	800027ae <dcm_reply_func+0x42>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	c5 40       	breq	800027b6 <dcm_reply_func+0x4a>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	c5 54       	brge	800027bc <dcm_reply_func+0x50>
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	c5 70       	breq	800027c4 <dcm_reply_func+0x58>
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	c5 88       	rjmp	800027ca <dcm_reply_func+0x5e>
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	c5 a0       	breq	800027d2 <dcm_reply_func+0x66>
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	c5 b8       	rjmp	800027d8 <ToneControl_reply_func+0x4>

80002724 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002724:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002728:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000272c:	48 bc       	lddpc	r12,80002758 <dcm_brdcst_func+0x34>
8000272e:	f0 1f 00 0c 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002732:	0f 88       	ld.ub	r8,r7[0x0]
80002734:	1a d8       	st.w	--sp,r8
80002736:	48 bc       	lddpc	r12,80002760 <dcm_brdcst_func+0x3c>
80002738:	f0 1f 00 09 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000273c:	0f a8       	ld.ub	r8,r7[0x2]
8000273e:	1a d8       	st.w	--sp,r8
80002740:	48 9c       	lddpc	r12,80002764 <dcm_brdcst_func+0x40>
80002742:	f0 1f 00 07 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002746:	0f 98       	ld.ub	r8,r7[0x1]
80002748:	1a d8       	st.w	--sp,r8
8000274a:	48 8c       	lddpc	r12,80002768 <dcm_brdcst_func+0x44>
8000274c:	f0 1f 00 04 	mcall	8000275c <dcm_brdcst_func+0x38>
80002750:	2f dd       	sub	sp,-12
	
	
}
80002752:	e3 cd 80 80 	ldm	sp++,r7,pc
80002756:	00 00       	add	r0,r0
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	c5 c8       	rjmp	80002812 <app_cfg+0x16>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	60 88       	ld.w	r8,r0[0x20]
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	c5 dc       	rcall	8000281c <app_cfg+0x20>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	c5 f0       	breq	80002824 <app_cfg+0x28>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	c6 08       	rjmp	8000282a <app_cfg+0x2e>

8000276c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000276c:	eb cd 40 80 	pushm	r7,lr
80002770:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002772:	19 a9       	ld.ub	r9,r12[0x2]
80002774:	30 08       	mov	r8,0
80002776:	f0 09 18 00 	cp.b	r9,r8
8000277a:	c1 b1       	brne	800027b0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000277c:	19 b8       	ld.ub	r8,r12[0x3]
8000277e:	30 19       	mov	r9,1
80002780:	f2 08 18 00 	cp.b	r8,r9
80002784:	c0 51       	brne	8000278e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002786:	48 ec       	lddpc	r12,800027bc <dcm_reply_func+0x50>
80002788:	f0 1f 00 0e 	mcall	800027c0 <dcm_reply_func+0x54>
8000278c:	c0 a8       	rjmp	800027a0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000278e:	58 08       	cp.w	r8,0
80002790:	c0 51       	brne	8000279a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002792:	48 dc       	lddpc	r12,800027c4 <dcm_reply_func+0x58>
80002794:	f0 1f 00 0b 	mcall	800027c0 <dcm_reply_func+0x54>
80002798:	c0 48       	rjmp	800027a0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000279a:	48 cc       	lddpc	r12,800027c8 <dcm_reply_func+0x5c>
8000279c:	f0 1f 00 09 	mcall	800027c0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027a0:	0f d8       	ld.ub	r8,r7[0x5]
800027a2:	1a d8       	st.w	--sp,r8
800027a4:	48 ac       	lddpc	r12,800027cc <dcm_reply_func+0x60>
800027a6:	f0 1f 00 07 	mcall	800027c0 <dcm_reply_func+0x54>
800027aa:	2f fd       	sub	sp,-4
800027ac:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027b0:	48 8c       	lddpc	r12,800027d0 <dcm_reply_func+0x64>
800027b2:	f0 1f 00 04 	mcall	800027c0 <dcm_reply_func+0x54>
800027b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ba:	00 00       	add	r0,r0
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	c6 24       	brge	80002882 <app_payload_rx_proc+0x12>
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	60 88       	ld.w	r8,r0[0x20]
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	c6 38       	rjmp	8000288c <app_payload_rx_proc+0x1c>
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	c6 4c       	rcall	80002892 <app_payload_rx_proc+0x22>
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	c6 60       	breq	8000289a <app_payload_rx_proc+0x2a>
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	c6 6c       	rcall	8000289e <app_payload_rx_proc+0x2e>

800027d4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027d4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027d6:	19 a9       	ld.ub	r9,r12[0x2]
800027d8:	30 08       	mov	r8,0
800027da:	f0 09 18 00 	cp.b	r9,r8
800027de:	c0 51       	brne	800027e8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027e0:	48 4c       	lddpc	r12,800027f0 <ToneControl_reply_func+0x1c>
800027e2:	f0 1f 00 05 	mcall	800027f4 <ToneControl_reply_func+0x20>
800027e6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027e8:	48 4c       	lddpc	r12,800027f8 <ToneControl_reply_func+0x24>
800027ea:	f0 1f 00 03 	mcall	800027f4 <ToneControl_reply_func+0x20>
800027ee:	d8 02       	popm	pc
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	c6 78       	rjmp	800028c0 <DeviceInitializationStatus_brdcst_func+0x4>
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	60 88       	ld.w	r8,r0[0x20]
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	c6 84       	brge	800028ca <DeviceInitializationStatus_brdcst_func+0xe>

800027fc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027fc:	eb cd 40 fe 	pushm	r1-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002800:	f0 1f 00 14 	mcall	80002850 <app_cfg+0x54>
80002804:	49 48       	lddpc	r8,80002854 <app_cfg+0x58>
80002806:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002808:	49 46       	lddpc	r6,80002858 <app_cfg+0x5c>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000280a:	49 57       	lddpc	r7,8000285c <app_cfg+0x60>
				//if(rfid_auto_reader(card_id) == 0){
					//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
				//}
				//else
				{
					log("read card err!!!\n");
8000280c:	49 53       	lddpc	r3,80002860 <app_cfg+0x64>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
8000280e:	30 c1       	mov	r1,12
			connect_flag=1;	
80002810:	30 12       	mov	r2,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002812:	10 95       	mov	r5,r8
80002814:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002818:	6c 08       	ld.w	r8,r6[0x0]
8000281a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000281e:	58 38       	cp.w	r8,3
80002820:	c0 91       	brne	80002832 <app_cfg+0x36>
80002822:	0f 88       	ld.ub	r8,r7[0x0]
80002824:	58 08       	cp.w	r8,0
80002826:	c0 61       	brne	80002832 <app_cfg+0x36>
		{	
			xcmp_IdleTestTone(Priority_Beep);
80002828:	02 9c       	mov	r12,r1
8000282a:	f0 1f 00 0f 	mcall	80002864 <app_cfg+0x68>
			connect_flag=1;	
8000282e:	ae 82       	st.b	r7[0x0],r2
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002830:	c0 b8       	rjmp	80002846 <app_cfg+0x4a>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
80002832:	0f 88       	ld.ub	r8,r7[0x0]
80002834:	58 08       	cp.w	r8,0
80002836:	c0 50       	breq	80002840 <app_cfg+0x44>
				//if(rfid_auto_reader(card_id) == 0){
					//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
				//}
				//else
				{
					log("read card err!!!\n");
80002838:	06 9c       	mov	r12,r3
8000283a:	f0 1f 00 0c 	mcall	80002868 <app_cfg+0x6c>
8000283e:	c0 48       	rjmp	80002846 <app_cfg+0x4a>
				}
				
		}
		else
		{
			nop();
80002840:	d7 03       	nop
			nop();
80002842:	d7 03       	nop
			nop();
80002844:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002846:	08 9b       	mov	r11,r4
80002848:	0a 9c       	mov	r12,r5
8000284a:	f0 1f 00 09 	mcall	8000286c <app_cfg+0x70>
	}
8000284e:	ce 5b       	rjmp	80002818 <app_cfg+0x1c>
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	59 fc       	cp.w	r12,31
80002854:	00 00       	add	r0,r0
80002856:	0a 34       	cp.w	r4,r5
80002858:	00 00       	add	r0,r0
8000285a:	0d 80       	ld.ub	r0,r6[0x0]
8000285c:	00 00       	add	r0,r0
8000285e:	0a 44       	or	r4,r5
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	c6 90       	breq	80002934 <payload_init+0x24>
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	41 c8       	lddsp	r8,sp[0x70]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	60 88       	ld.w	r8,r0[0x20]
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	5b 64       	cp.w	r4,-10

80002870 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002870:	eb cd 40 80 	pushm	r7,lr
80002874:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002876:	48 c9       	lddpc	r9,800028a4 <app_payload_rx_proc+0x34>
80002878:	13 88       	ld.ub	r8,r9[0x0]
8000287a:	2f f8       	sub	r8,-1
8000287c:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000287e:	30 39       	mov	r9,3
80002880:	f2 08 18 00 	cp.b	r8,r9
80002884:	c0 71       	brne	80002892 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002886:	30 09       	mov	r9,0
80002888:	48 78       	lddpc	r8,800028a4 <app_payload_rx_proc+0x34>
8000288a:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
8000288c:	48 7c       	lddpc	r12,800028a8 <app_payload_rx_proc+0x38>
8000288e:	f0 1f 00 08 	mcall	800028ac <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002892:	48 88       	lddpc	r8,800028b0 <app_payload_rx_proc+0x40>
80002894:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002896:	48 88       	lddpc	r8,800028b4 <app_payload_rx_proc+0x44>
80002898:	70 0c       	ld.w	r12,r8[0x0]
8000289a:	0e 9b       	mov	r11,r7
8000289c:	f0 1f 00 07 	mcall	800028b8 <app_payload_rx_proc+0x48>

}
800028a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a4:	00 00       	add	r0,r0
800028a6:	0a 42       	or	r2,r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	c6 a4       	brge	8000297e <payload_rx_process+0x36>
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	60 88       	ld.w	r8,r0[0x20]
800028b0:	00 00       	add	r0,r0
800028b2:	0a 39       	cp.w	r9,r5
800028b4:	00 00       	add	r0,r0
800028b6:	0a 94       	mov	r4,r5
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	29 e8       	sub	r8,-98

800028bc <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028bc:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028be:	19 e8       	ld.ub	r8,r12[0x6]
800028c0:	30 19       	mov	r9,1
800028c2:	f2 08 18 00 	cp.b	r8,r9
800028c6:	c0 61       	brne	800028d2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028c8:	48 98       	lddpc	r8,800028ec <DeviceInitializationStatus_brdcst_func+0x30>
800028ca:	70 09       	ld.w	r9,r8[0x0]
800028cc:	a1 a9       	sbr	r9,0x0
800028ce:	91 09       	st.w	r8[0x0],r9
800028d0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028d2:	30 29       	mov	r9,2
800028d4:	f2 08 18 00 	cp.b	r8,r9
800028d8:	c0 80       	breq	800028e8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028da:	48 58       	lddpc	r8,800028ec <DeviceInitializationStatus_brdcst_func+0x30>
800028dc:	70 09       	ld.w	r9,r8[0x0]
800028de:	e0 19 ff fc 	andl	r9,0xfffc
800028e2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028e4:	f0 1f 00 03 	mcall	800028f0 <DeviceInitializationStatus_brdcst_func+0x34>
800028e8:	d8 02       	popm	pc
800028ea:	00 00       	add	r0,r0
800028ec:	00 00       	add	r0,r0
800028ee:	0d 80       	ld.ub	r0,r6[0x0]
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	41 1c       	lddsp	r12,sp[0x44]

800028f4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028f4:	20 1c       	sub	r12,1
800028f6:	5c 5c       	castu.b	r12
800028f8:	31 18       	mov	r8,17
800028fa:	f0 0c 18 00 	cp.b	r12,r8
800028fe:	e0 88 00 03 	brls	80002904 <CalculateBurst+0x10>
80002902:	5e fd       	retal	0
80002904:	48 28       	lddpc	r8,8000290c <CalculateBurst+0x18>
80002906:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
8000290a:	5e fc       	retal	r12
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	c6 b8       	rjmp	800029e4 <phy_rx+0x34>

80002910 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002910:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002912:	48 98       	lddpc	r8,80002934 <payload_init+0x24>
80002914:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002916:	48 98       	lddpc	r8,80002938 <payload_init+0x28>
80002918:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000291a:	30 09       	mov	r9,0
8000291c:	1a d9       	st.w	--sp,r9
8000291e:	1a d9       	st.w	--sp,r9
80002920:	1a d9       	st.w	--sp,r9
80002922:	30 28       	mov	r8,2
80002924:	e0 6a 04 00 	mov	r10,1024
80002928:	48 5b       	lddpc	r11,8000293c <payload_init+0x2c>
8000292a:	48 6c       	lddpc	r12,80002940 <payload_init+0x30>
8000292c:	f0 1f 00 06 	mcall	80002944 <payload_init+0x34>
80002930:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002932:	d8 02       	popm	pc
80002934:	00 00       	add	r0,r0
80002936:	0a 4c       	or	r12,r5
80002938:	00 00       	add	r0,r0
8000293a:	0a 50       	eor	r0,r5
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	c7 00       	breq	80002a1e <phy_tx+0x16>
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	29 48       	sub	r8,-108
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	5c c4       	swap.bh	r4

80002948 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002948:	eb cd 40 f8 	pushm	r3-r7,lr
8000294c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000294e:	48 e8       	lddpc	r8,80002984 <payload_rx_process+0x3c>
80002950:	70 08       	ld.w	r8,r8[0x0]
80002952:	58 08       	cp.w	r8,0
80002954:	c0 71       	brne	80002962 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002956:	30 4b       	mov	r11,4
80002958:	30 5c       	mov	r12,5
8000295a:	f0 1f 00 0c 	mcall	80002988 <payload_rx_process+0x40>
8000295e:	48 a8       	lddpc	r8,80002984 <payload_rx_process+0x3c>
80002960:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002962:	48 96       	lddpc	r6,80002984 <payload_rx_process+0x3c>
80002964:	30 05       	mov	r5,0
80002966:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002968:	48 93       	lddpc	r3,8000298c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000296a:	6c 0c       	ld.w	r12,r6[0x0]
8000296c:	0a 99       	mov	r9,r5
8000296e:	08 9a       	mov	r10,r4
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 08 	mcall	80002990 <payload_rx_process+0x48>
80002976:	58 1c       	cp.w	r12,1
80002978:	cf 91       	brne	8000296a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000297a:	66 08       	ld.w	r8,r3[0x0]
8000297c:	40 0c       	lddsp	r12,sp[0x0]
8000297e:	5d 18       	icall	r8
80002980:	cf 5b       	rjmp	8000296a <payload_rx_process+0x22>
80002982:	00 00       	add	r0,r0
80002984:	00 00       	add	r0,r0
80002986:	0a 64       	and	r4,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	55 f0       	stdsp	sp[0x17c],r0
8000298c:	00 00       	add	r0,r0
8000298e:	0a 4c       	or	r12,r5
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	52 e4       	stdsp	sp[0xb8],r4

80002994 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002994:	d4 01       	pushm	lr
80002996:	20 2d       	sub	sp,8
80002998:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000299a:	30 09       	mov	r9,0
8000299c:	fa ca ff f8 	sub	r10,sp,-8
800029a0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029a2:	1a 9b       	mov	r11,sp
800029a4:	f0 1f 00 02 	mcall	800029ac <set_idle_store_isr+0x18>
}
800029a8:	2f ed       	sub	sp,-8
800029aa:	d8 02       	popm	pc
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	54 a0       	stdsp	sp[0x128],r0

800029b0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029b0:	d4 01       	pushm	lr
800029b2:	20 2d       	sub	sp,8
800029b4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029b6:	58 0c       	cp.w	r12,0
800029b8:	c1 10       	breq	800029da <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029ba:	30 08       	mov	r8,0
800029bc:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029be:	98 88       	ld.uh	r8,r12[0x0]
800029c0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029c4:	e0 48 40 00 	cp.w	r8,16384
800029c8:	c0 91       	brne	800029da <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029ca:	48 68       	lddpc	r8,800029e0 <phy_rx+0x30>
800029cc:	70 0c       	ld.w	r12,r8[0x0]
800029ce:	30 09       	mov	r9,0
800029d0:	fa ca ff fc 	sub	r10,sp,-4
800029d4:	1a 9b       	mov	r11,sp
800029d6:	f0 1f 00 04 	mcall	800029e4 <phy_rx+0x34>
		}	

    }
		
 
}
800029da:	2f ed       	sub	sp,-8
800029dc:	d8 02       	popm	pc
800029de:	00 00       	add	r0,r0
800029e0:	00 00       	add	r0,r0
800029e2:	0a a8       	st.w	r5++,r8
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	54 a0       	stdsp	sp[0x128],r0

800029e8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029e8:	eb cd 40 80 	pushm	r7,lr
800029ec:	20 1d       	sub	sp,4
800029ee:	fa c7 ff fc 	sub	r7,sp,-4
800029f2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029f4:	30 09       	mov	r9,0
800029f6:	12 9a       	mov	r10,r9
800029f8:	1a 9b       	mov	r11,sp
800029fa:	f0 1f 00 03 	mcall	80002a04 <set_idle_store+0x1c>
}
800029fe:	2f fd       	sub	sp,-4
80002a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	54 f0       	stdsp	sp[0x13c],r0

80002a08 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a08:	d4 01       	pushm	lr
80002a0a:	20 1d       	sub	sp,4
80002a0c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a0e:	98 88       	ld.uh	r8,r12[0x0]
80002a10:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a14:	e0 48 40 00 	cp.w	r8,16384
80002a18:	c0 d1       	brne	80002a32 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a1a:	49 08       	lddpc	r8,80002a58 <phy_tx+0x50>
80002a1c:	70 08       	ld.w	r8,r8[0x0]
80002a1e:	58 08       	cp.w	r8,0
80002a20:	c1 a0       	breq	80002a54 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a22:	48 e8       	lddpc	r8,80002a58 <phy_tx+0x50>
80002a24:	70 0c       	ld.w	r12,r8[0x0]
80002a26:	30 09       	mov	r9,0
80002a28:	12 9a       	mov	r10,r9
80002a2a:	1a 9b       	mov	r11,sp
80002a2c:	f0 1f 00 0c 	mcall	80002a5c <phy_tx+0x54>
80002a30:	c1 28       	rjmp	80002a54 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a32:	e0 48 10 00 	cp.w	r8,4096
80002a36:	5f 0a       	sreq	r10
80002a38:	e0 48 20 00 	cp.w	r8,8192
80002a3c:	5f 09       	sreq	r9
80002a3e:	f5 e9 10 09 	or	r9,r10,r9
80002a42:	c0 71       	brne	80002a50 <phy_tx+0x48>
80002a44:	e0 48 50 00 	cp.w	r8,20480
80002a48:	c0 40       	breq	80002a50 <phy_tx+0x48>
80002a4a:	e0 48 60 00 	cp.w	r8,24576
80002a4e:	c0 31       	brne	80002a54 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a50:	48 48       	lddpc	r8,80002a60 <phy_tx+0x58>
80002a52:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a54:	2f fd       	sub	sp,-4
80002a56:	d8 02       	popm	pc
80002a58:	00 00       	add	r0,r0
80002a5a:	0a bc       	st.h	r5++,r12
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	54 f0       	stdsp	sp[0x13c],r0
80002a60:	00 00       	add	r0,r0
80002a62:	0a 9c       	mov	r12,r5

80002a64 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a64:	d4 01       	pushm	lr
80002a66:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a68:	30 08       	mov	r8,0
80002a6a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a6c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a6e:	1a 9a       	mov	r10,sp
80002a70:	fa cb ff fc 	sub	r11,sp,-4
80002a74:	f0 1f 00 05 	mcall	80002a88 <get_idle_store_isr+0x24>
80002a78:	58 1c       	cp.w	r12,1
80002a7a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a7e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a82:	2f ed       	sub	sp,-8
80002a84:	d8 02       	popm	pc
80002a86:	00 00       	add	r0,r0
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	51 f4       	stdsp	sp[0x7c],r4

80002a8c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a90:	20 1d       	sub	sp,4
80002a92:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a94:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a98:	70 08       	ld.w	r8,r8[0x0]
80002a9a:	58 08       	cp.w	r8,0
80002a9c:	c7 40       	breq	80002b84 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a9e:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aa0:	30 08       	mov	r8,0
80002aa2:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002aa4:	fe f8 04 64 	ld.w	r8,pc[1124]
80002aa8:	70 08       	ld.w	r8,r8[0x0]
80002aaa:	58 18       	cp.w	r8,1
80002aac:	c2 90       	breq	80002afe <phy_tx_func+0x72>
80002aae:	c0 43       	brcs	80002ab6 <phy_tx_func+0x2a>
80002ab0:	58 28       	cp.w	r8,2
80002ab2:	c6 91       	brne	80002b84 <phy_tx_func+0xf8>
80002ab4:	c6 18       	rjmp	80002b76 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ab6:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	1a 9a       	mov	r10,sp
80002abe:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002ac2:	f0 1f 01 14 	mcall	80002f10 <phy_tx_func+0x484>
80002ac6:	58 1c       	cp.w	r12,1
80002ac8:	c1 51       	brne	80002af2 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aca:	fe f8 04 42 	ld.w	r8,pc[1090]
80002ace:	70 08       	ld.w	r8,r8[0x0]
80002ad0:	11 9a       	ld.ub	r10,r8[0x1]
80002ad2:	fe f9 04 42 	ld.w	r9,pc[1090]
80002ad6:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ad8:	90 88       	ld.uh	r8,r8[0x0]
80002ada:	ea 18 ab cd 	orh	r8,0xabcd
80002ade:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ae0:	30 19       	mov	r9,1
80002ae2:	fe f8 04 36 	ld.w	r8,pc[1078]
80002ae6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ae8:	30 19       	mov	r9,1
80002aea:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002aee:	91 09       	st.w	r8[0x0],r9
80002af0:	c4 a8       	rjmp	80002b84 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002af2:	e0 68 5a 5a 	mov	r8,23130
80002af6:	ea 18 ab cd 	orh	r8,0xabcd
80002afa:	8f 18       	st.w	r7[0x4],r8
80002afc:	c4 48       	rjmp	80002b84 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002afe:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002b02:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b04:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b08:	74 0a       	ld.w	r10,r10[0x0]
80002b0a:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b0e:	b1 6a       	lsl	r10,0x10
80002b10:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b12:	2f f8       	sub	r8,-1
80002b14:	5c 58       	castu.b	r8
80002b16:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b18:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b1c:	94 09       	ld.sh	r9,r10[0x0]
80002b1e:	20 29       	sub	r9,2
80002b20:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b22:	30 0a       	mov	r10,0
80002b24:	f4 09 19 00 	cp.h	r9,r10
80002b28:	e0 89 00 0b 	brgt	80002b3e <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b2c:	78 18       	ld.w	r8,r12[0x4]
80002b2e:	e8 18 00 ba 	orl	r8,0xba
80002b32:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b34:	30 09       	mov	r9,0
80002b36:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b3a:	91 09       	st.w	r8[0x0],r9
80002b3c:	c2 48       	rjmp	80002b84 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b3e:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b42:	72 09       	ld.w	r9,r9[0x0]
80002b44:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b48:	78 1a       	ld.w	r10,r12[0x4]
80002b4a:	f5 e9 10 09 	or	r9,r10,r9
80002b4e:	99 19       	st.w	r12[0x4],r9
80002b50:	2f f8       	sub	r8,-1
80002b52:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b56:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b58:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b5c:	92 08       	ld.sh	r8,r9[0x0]
80002b5e:	20 28       	sub	r8,2
80002b60:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b62:	30 09       	mov	r9,0
80002b64:	f2 08 19 00 	cp.h	r8,r9
80002b68:	e0 89 00 0e 	brgt	80002b84 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b6c:	30 29       	mov	r9,2
80002b6e:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b72:	91 09       	st.w	r8[0x0],r9
80002b74:	c0 88       	rjmp	80002b84 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b76:	fc 18 00 ba 	movh	r8,0xba
80002b7a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b7c:	30 09       	mov	r9,0
80002b7e:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b82:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b84:	fe f8 03 98 	ld.w	r8,pc[920]
80002b88:	11 89       	ld.ub	r9,r8[0x0]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f0 09 18 00 	cp.b	r9,r8
80002b90:	e0 81 01 af 	brne	80002eee <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b94:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	e0 48 05 b0 	cp.w	r8,1456
80002b9e:	f9 b8 02 00 	movhs	r8,0
80002ba2:	fe f9 03 7e 	ld.w	r9,pc[894]
80002ba6:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002ba8:	fe f8 03 7c 	ld.w	r8,pc[892]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 68       	cp.w	r8,6
80002bb0:	e0 8b 01 95 	brhi	80002eda <phy_tx_func+0x44e>
80002bb4:	fe f9 03 74 	ld.w	r9,pc[884]
80002bb8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002bbc:	fe f8 03 70 	ld.w	r8,pc[880]
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	58 08       	cp.w	r8,0
80002bc4:	c0 b0       	breq	80002bda <phy_tx_func+0x14e>
80002bc6:	fe f8 03 66 	ld.w	r8,pc[870]
80002bca:	70 08       	ld.w	r8,r8[0x0]
80002bcc:	58 a8       	cp.w	r8,10
80002bce:	c0 60       	breq	80002bda <phy_tx_func+0x14e>
80002bd0:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bd4:	70 08       	ld.w	r8,r8[0x0]
80002bd6:	58 18       	cp.w	r8,1
80002bd8:	c0 a1       	brne	80002bec <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bda:	e0 68 5a 5a 	mov	r8,23130
80002bde:	ea 18 ab cd 	orh	r8,0xabcd
80002be2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002be4:	30 08       	mov	r8,0
80002be6:	8f 38       	st.w	r7[0xc],r8
80002be8:	e0 8f 01 8a 	bral	80002efc <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bec:	fe f8 03 40 	ld.w	r8,pc[832]
80002bf0:	70 08       	ld.w	r8,r8[0x0]
80002bf2:	58 38       	cp.w	r8,3
80002bf4:	c0 91       	brne	80002c06 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bf6:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bfa:	70 09       	ld.w	r9,r8[0x0]
80002bfc:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bfe:	70 18       	ld.w	r8,r8[0x4]
80002c00:	8f 38       	st.w	r7[0xc],r8
80002c02:	e0 8f 01 7d 	bral	80002efc <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c06:	fe f8 03 26 	ld.w	r8,pc[806]
80002c0a:	70 08       	ld.w	r8,r8[0x0]
80002c0c:	58 28       	cp.w	r8,2
80002c0e:	c1 31       	brne	80002c34 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c10:	e0 68 c0 32 	mov	r8,49202
80002c14:	ea 18 ab cd 	orh	r8,0xabcd
80002c18:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c1a:	fe 78 84 7f 	mov	r8,-31617
80002c1e:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c20:	fe f8 03 14 	ld.w	r8,pc[788]
80002c24:	90 08       	ld.sh	r8,r8[0x0]
80002c26:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c28:	30 39       	mov	r9,3
80002c2a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c2e:	91 09       	st.w	r8[0x0],r9
80002c30:	e0 8f 01 66 	bral	80002efc <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c34:	e0 68 c0 0e 	mov	r8,49166
80002c38:	ea 18 ab cd 	orh	r8,0xabcd
80002c3c:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c3e:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c42:	90 09       	ld.sh	r9,r8[0x0]
80002c44:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c46:	90 18       	ld.sh	r8,r8[0x2]
80002c48:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c4a:	30 19       	mov	r9,1
80002c4c:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c50:	91 09       	st.w	r8[0x0],r9
80002c52:	e0 8f 01 55 	bral	80002efc <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c56:	fe 78 88 f2 	mov	r8,-30478
80002c5a:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c5c:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c60:	70 08       	ld.w	r8,r8[0x0]
80002c62:	58 48       	cp.w	r8,4
80002c64:	c0 60       	breq	80002c70 <phy_tx_func+0x1e4>
80002c66:	c4 53       	brcs	80002cf0 <phy_tx_func+0x264>
80002c68:	58 98       	cp.w	r8,9
80002c6a:	e0 8b 00 43 	brhi	80002cf0 <phy_tx_func+0x264>
80002c6e:	c2 98       	rjmp	80002cc0 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c70:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c74:	11 89       	ld.ub	r9,r8[0x0]
80002c76:	30 18       	mov	r8,1
80002c78:	f0 09 18 00 	cp.b	r9,r8
80002c7c:	c0 a1       	brne	80002c90 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c7e:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c82:	90 09       	ld.sh	r9,r8[0x0]
80002c84:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c86:	90 19       	ld.sh	r9,r8[0x2]
80002c88:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c8a:	90 28       	ld.sh	r8,r8[0x4]
80002c8c:	ae 78       	st.h	r7[0xe],r8
80002c8e:	c1 48       	rjmp	80002cb6 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c90:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c94:	92 0b       	ld.sh	r11,r9[0x0]
80002c96:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c9a:	90 0a       	ld.sh	r10,r8[0x0]
80002c9c:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca0:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002ca2:	92 1b       	ld.sh	r11,r9[0x2]
80002ca4:	90 1a       	ld.sh	r10,r8[0x2]
80002ca6:	f7 ea 20 0a 	eor	r10,r11,r10
80002caa:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cac:	92 29       	ld.sh	r9,r9[0x4]
80002cae:	90 28       	ld.sh	r8,r8[0x4]
80002cb0:	f3 e8 20 08 	eor	r8,r9,r8
80002cb4:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cb6:	30 29       	mov	r9,2
80002cb8:	fe f8 02 6c 	ld.w	r8,pc[620]
80002cbc:	91 09       	st.w	r8[0x0],r9
80002cbe:	c1 f9       	rjmp	80002efc <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cc0:	fe f9 02 84 	ld.w	r9,pc[644]
80002cc4:	92 0b       	ld.sh	r11,r9[0x0]
80002cc6:	fe f8 02 7a 	ld.w	r8,pc[634]
80002cca:	90 0a       	ld.sh	r10,r8[0x0]
80002ccc:	f7 ea 20 0a 	eor	r10,r11,r10
80002cd0:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cd2:	92 1b       	ld.sh	r11,r9[0x2]
80002cd4:	90 1a       	ld.sh	r10,r8[0x2]
80002cd6:	f7 ea 20 0a 	eor	r10,r11,r10
80002cda:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cdc:	92 29       	ld.sh	r9,r9[0x4]
80002cde:	90 28       	ld.sh	r8,r8[0x4]
80002ce0:	f3 e8 20 08 	eor	r8,r9,r8
80002ce4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002ce6:	30 29       	mov	r9,2
80002ce8:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cec:	91 09       	st.w	r8[0x0],r9
80002cee:	c0 79       	rjmp	80002efc <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cf0:	e0 68 5a 5a 	mov	r8,23130
80002cf4:	ea 18 ab cd 	orh	r8,0xabcd
80002cf8:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cfa:	30 08       	mov	r8,0
80002cfc:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cfe:	fe f9 02 26 	ld.w	r9,pc[550]
80002d02:	93 08       	st.w	r9[0x0],r8
80002d04:	cf c8       	rjmp	80002efc <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002d06:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d0a:	90 38       	ld.sh	r8,r8[0x6]
80002d0c:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d0e:	e0 68 00 ba 	mov	r8,186
80002d12:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d14:	30 08       	mov	r8,0
80002d16:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d18:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d1a:	30 09       	mov	r9,0
80002d1c:	fe f8 02 08 	ld.w	r8,pc[520]
80002d20:	91 09       	st.w	r8[0x0],r9
80002d22:	ce d8       	rjmp	80002efc <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d24:	fe f8 02 10 	ld.w	r8,pc[528]
80002d28:	90 18       	ld.sh	r8,r8[0x2]
80002d2a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d2c:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d30:	90 08       	ld.sh	r8,r8[0x0]
80002d32:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d34:	4f e8       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002d36:	70 08       	ld.w	r8,r8[0x0]
80002d38:	58 48       	cp.w	r8,4
80002d3a:	c0 d1       	brne	80002d54 <phy_tx_func+0x2c8>
80002d3c:	fe f8 02 00 	ld.w	r8,pc[512]
80002d40:	11 89       	ld.ub	r9,r8[0x0]
80002d42:	30 18       	mov	r8,1
80002d44:	f0 09 18 00 	cp.b	r9,r8
80002d48:	c0 61       	brne	80002d54 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d4a:	4f c8       	lddpc	r8,80002f38 <phy_tx_func+0x4ac>
80002d4c:	90 18       	ld.sh	r8,r8[0x2]
80002d4e:	a9 a8       	sbr	r8,0x8
80002d50:	ae 68       	st.h	r7[0xc],r8
80002d52:	c0 48       	rjmp	80002d5a <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d54:	4f 98       	lddpc	r8,80002f38 <phy_tx_func+0x4ac>
80002d56:	90 18       	ld.sh	r8,r8[0x2]
80002d58:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d5a:	fe 78 9a 13 	mov	r8,-26093
80002d5e:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d60:	30 49       	mov	r9,4
80002d62:	4f 18       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002d64:	91 09       	st.w	r8[0x0],r9
80002d66:	cc b8       	rjmp	80002efc <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d68:	4f 88       	lddpc	r8,80002f48 <phy_tx_func+0x4bc>
80002d6a:	70 0a       	ld.w	r10,r8[0x0]
80002d6c:	4f 89       	lddpc	r9,80002f4c <phy_tx_func+0x4c0>
80002d6e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d72:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d74:	70 0a       	ld.w	r10,r8[0x0]
80002d76:	2f fa       	sub	r10,-1
80002d78:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d7c:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d7e:	70 0a       	ld.w	r10,r8[0x0]
80002d80:	2f ea       	sub	r10,-2
80002d82:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d86:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d88:	70 0a       	ld.w	r10,r8[0x0]
80002d8a:	2f da       	sub	r10,-3
80002d8c:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d90:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d92:	70 09       	ld.w	r9,r8[0x0]
80002d94:	2f c9       	sub	r9,-4
80002d96:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d98:	58 c9       	cp.w	r9,12
80002d9a:	c0 51       	brne	80002da4 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d9c:	30 59       	mov	r9,5
80002d9e:	4e 28       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002da0:	91 09       	st.w	r8[0x0],r9
80002da2:	ca d8       	rjmp	80002efc <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002da4:	30 49       	mov	r9,4
80002da6:	4e 08       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	ca 98       	rjmp	80002efc <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dac:	4e 78       	lddpc	r8,80002f48 <phy_tx_func+0x4bc>
80002dae:	70 0a       	ld.w	r10,r8[0x0]
80002db0:	4e 79       	lddpc	r9,80002f4c <phy_tx_func+0x4c0>
80002db2:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002db6:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002db8:	30 09       	mov	r9,0
80002dba:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002dbc:	fe 78 80 03 	mov	r8,-32765
80002dc0:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002dc2:	fe 78 88 f3 	mov	r8,-30477
80002dc6:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002dc8:	4d 98       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002dca:	70 08       	ld.w	r8,r8[0x0]
80002dcc:	58 48       	cp.w	r8,4
80002dce:	c0 60       	breq	80002dda <phy_tx_func+0x34e>
80002dd0:	c2 83       	brcs	80002e20 <phy_tx_func+0x394>
80002dd2:	58 98       	cp.w	r8,9
80002dd4:	e0 8b 00 26 	brhi	80002e20 <phy_tx_func+0x394>
80002dd8:	c1 98       	rjmp	80002e0a <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dda:	4d 98       	lddpc	r8,80002f3c <phy_tx_func+0x4b0>
80002ddc:	11 89       	ld.ub	r9,r8[0x0]
80002dde:	30 18       	mov	r8,1
80002de0:	f0 09 18 00 	cp.b	r9,r8
80002de4:	c0 81       	brne	80002df4 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002de6:	4d 88       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002de8:	90 0a       	ld.sh	r10,r8[0x0]
80002dea:	4d a9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002dec:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dee:	90 08       	ld.sh	r8,r8[0x0]
80002df0:	ae 78       	st.h	r7[0xe],r8
80002df2:	c0 88       	rjmp	80002e02 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002df4:	4d 78       	lddpc	r8,80002f50 <phy_tx_func+0x4c4>
80002df6:	90 08       	ld.sh	r8,r8[0x0]
80002df8:	4d 39       	lddpc	r9,80002f44 <phy_tx_func+0x4b8>
80002dfa:	92 09       	ld.sh	r9,r9[0x0]
80002dfc:	f3 e8 20 08 	eor	r8,r9,r8
80002e00:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e02:	30 69       	mov	r9,6
80002e04:	4c 88       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e06:	91 09       	st.w	r8[0x0],r9
80002e08:	c7 a8       	rjmp	80002efc <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e0a:	4d 28       	lddpc	r8,80002f50 <phy_tx_func+0x4c4>
80002e0c:	90 08       	ld.sh	r8,r8[0x0]
80002e0e:	4c e9       	lddpc	r9,80002f44 <phy_tx_func+0x4b8>
80002e10:	92 09       	ld.sh	r9,r9[0x0]
80002e12:	f3 e8 20 08 	eor	r8,r9,r8
80002e16:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e18:	30 69       	mov	r9,6
80002e1a:	4c 38       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e1c:	91 09       	st.w	r8[0x0],r9
80002e1e:	c6 f8       	rjmp	80002efc <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e20:	e0 68 5a 5a 	mov	r8,23130
80002e24:	ea 18 ab cd 	orh	r8,0xabcd
80002e28:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e2a:	30 08       	mov	r8,0
80002e2c:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e2e:	4b e9       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002e30:	93 08       	st.w	r9[0x0],r8
80002e32:	c6 58       	rjmp	80002efc <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e34:	4b e8       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002e36:	70 08       	ld.w	r8,r8[0x0]
80002e38:	58 48       	cp.w	r8,4
80002e3a:	c0 60       	breq	80002e46 <phy_tx_func+0x3ba>
80002e3c:	c4 53       	brcs	80002ec6 <phy_tx_func+0x43a>
80002e3e:	58 98       	cp.w	r8,9
80002e40:	e0 8b 00 43 	brhi	80002ec6 <phy_tx_func+0x43a>
80002e44:	c2 d8       	rjmp	80002e9e <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e46:	4b e8       	lddpc	r8,80002f3c <phy_tx_func+0x4b0>
80002e48:	11 89       	ld.ub	r9,r8[0x0]
80002e4a:	30 18       	mov	r8,1
80002e4c:	f0 09 18 00 	cp.b	r9,r8
80002e50:	c1 31       	brne	80002e76 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e52:	4b d8       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002e54:	90 1a       	ld.sh	r10,r8[0x2]
80002e56:	4b f9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002e58:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e5a:	90 2a       	ld.sh	r10,r8[0x4]
80002e5c:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e5e:	90 3a       	ld.sh	r10,r8[0x6]
80002e60:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e62:	90 19       	ld.sh	r9,r8[0x2]
80002e64:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e66:	90 29       	ld.sh	r9,r8[0x4]
80002e68:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e6a:	90 38       	ld.sh	r8,r8[0x6]
80002e6c:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e6e:	e0 68 00 ba 	mov	r8,186
80002e72:	ae 78       	st.h	r7[0xe],r8
80002e74:	c1 18       	rjmp	80002e96 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e76:	4b 48       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002e78:	90 1a       	ld.sh	r10,r8[0x2]
80002e7a:	4b 69       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002e7c:	92 1b       	ld.sh	r11,r9[0x2]
80002e7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e82:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e84:	90 2a       	ld.sh	r10,r8[0x4]
80002e86:	92 29       	ld.sh	r9,r9[0x4]
80002e88:	14 59       	eor	r9,r10
80002e8a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e8c:	90 38       	ld.sh	r8,r8[0x6]
80002e8e:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e90:	e0 68 00 ba 	mov	r8,186
80002e94:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e96:	30 09       	mov	r9,0
80002e98:	4a 38       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e9a:	91 09       	st.w	r8[0x0],r9
80002e9c:	c3 08       	rjmp	80002efc <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e9e:	4a a8       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002ea0:	90 1a       	ld.sh	r10,r8[0x2]
80002ea2:	4a c9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002ea4:	92 1b       	ld.sh	r11,r9[0x2]
80002ea6:	f7 ea 20 0a 	eor	r10,r11,r10
80002eaa:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002eac:	90 2a       	ld.sh	r10,r8[0x4]
80002eae:	92 29       	ld.sh	r9,r9[0x4]
80002eb0:	14 59       	eor	r9,r10
80002eb2:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002eb4:	90 38       	ld.sh	r8,r8[0x6]
80002eb6:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002eb8:	e0 68 00 ba 	mov	r8,186
80002ebc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ebe:	30 09       	mov	r9,0
80002ec0:	49 98       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002ec2:	91 09       	st.w	r8[0x0],r9
80002ec4:	c1 c8       	rjmp	80002efc <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec6:	e0 68 5a 5a 	mov	r8,23130
80002eca:	ea 18 ab cd 	orh	r8,0xabcd
80002ece:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed0:	30 08       	mov	r8,0
80002ed2:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ed4:	49 49       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002ed6:	93 08       	st.w	r9[0x0],r8
80002ed8:	c1 28       	rjmp	80002efc <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eda:	e0 68 5a 5a 	mov	r8,23130
80002ede:	ea 18 ab cd 	orh	r8,0xabcd
80002ee2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ee4:	30 08       	mov	r8,0
80002ee6:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ee8:	48 f9       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002eea:	93 08       	st.w	r9[0x0],r8
80002eec:	c0 88       	rjmp	80002efc <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eee:	e0 68 5a 5a 	mov	r8,23130
80002ef2:	ea 18 ab cd 	orh	r8,0xabcd
80002ef6:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ef8:	30 08       	mov	r8,0
80002efa:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002efc:	2f fd       	sub	sp,-4
80002efe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f02:	00 00       	add	r0,r0
80002f04:	00 00       	add	r0,r0
80002f06:	0a bc       	st.h	r5++,r12
80002f08:	00 00       	add	r0,r0
80002f0a:	0a 78       	tst	r8,r5
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a d0       	st.w	--r5,r0
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	51 f4       	stdsp	sp[0x7c],r4
80002f14:	00 00       	add	r0,r0
80002f16:	0a a2       	st.w	r5++,r2
80002f18:	00 00       	add	r0,r0
80002f1a:	0a 58       	eor	r8,r5
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a 43       	or	r3,r5
80002f20:	00 00       	add	r0,r0
80002f22:	0a cc       	st.b	r5++,r12
80002f24:	00 00       	add	r0,r0
80002f26:	0a 68       	and	r8,r5
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	c7 0c       	rcall	8000300a <phy_rx_func+0x6>
80002f2c:	00 00       	add	r0,r0
80002f2e:	0a c0       	st.b	r5++,r0
80002f30:	00 00       	add	r0,r0
80002f32:	0a 80       	andn	r0,r5
80002f34:	00 00       	add	r0,r0
80002f36:	0d 94       	ld.ub	r4,r6[0x1]
80002f38:	00 00       	add	r0,r0
80002f3a:	0e 90       	mov	r0,r7
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 46       	or	r6,r5
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	c6 ae       	rcall	80002c16 <phy_tx_func+0x18a>
80002f44:	00 00       	add	r0,r0
80002f46:	0d 8c       	ld.ub	r12,r6[0x0]
80002f48:	00 00       	add	r0,r0
80002f4a:	0a c4       	st.b	r5++,r4
80002f4c:	00 00       	add	r0,r0
80002f4e:	0e 94       	mov	r4,r7
80002f50:	00 00       	add	r0,r0
80002f52:	0d 98       	ld.ub	r8,r6[0x1]

80002f54 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f54:	d4 01       	pushm	lr
80002f56:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f58:	30 0a       	mov	r10,0
80002f5a:	fa cb ff fc 	sub	r11,sp,-4
80002f5e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f60:	14 99       	mov	r9,r10
80002f62:	1a 9b       	mov	r11,sp
80002f64:	f0 1f 00 05 	mcall	80002f78 <get_idle_store+0x24>
80002f68:	58 1c       	cp.w	r12,1
80002f6a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f6e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f72:	2f fd       	sub	sp,-4
80002f74:	d8 02       	popm	pc
80002f76:	00 00       	add	r0,r0
80002f78:	80 00       	ld.sh	r0,r0[0x0]
80002f7a:	52 e4       	stdsp	sp[0xb8],r4

80002f7c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f7c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f7e:	48 5b       	lddpc	r11,80002f90 <phy_init+0x14>
80002f80:	48 5c       	lddpc	r12,80002f94 <phy_init+0x18>
80002f82:	f0 1f 00 06 	mcall	80002f98 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002f86:	f0 1f 00 06 	mcall	80002f9c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002f8a:	f0 1f 00 06 	mcall	80002fa0 <phy_init+0x24>
	
}
80002f8e:	d8 02       	popm	pc
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	2a 8c       	sub	r12,-88
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	30 04       	mov	r4,0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	40 4c       	lddsp	r12,sp[0x10]
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	40 60       	lddsp	r0,sp[0x18]
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	49 74       	lddpc	r4,80002ffc <payload_rx+0x58>

80002fa4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002fa4:	d4 01       	pushm	lr
80002fa6:	20 2d       	sub	sp,8
80002fa8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002faa:	30 08       	mov	r8,0
80002fac:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002fae:	48 f8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fb0:	70 08       	ld.w	r8,r8[0x0]
80002fb2:	58 08       	cp.w	r8,0
80002fb4:	c0 71       	brne	80002fc2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002fb6:	30 4b       	mov	r11,4
80002fb8:	30 5c       	mov	r12,5
80002fba:	f0 1f 00 0d 	mcall	80002fec <payload_rx+0x48>
80002fbe:	48 b8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fc0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002fc2:	48 a8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fc4:	70 0c       	ld.w	r12,r8[0x0]
80002fc6:	30 09       	mov	r9,0
80002fc8:	fa ca ff fc 	sub	r10,sp,-4
80002fcc:	1a 9b       	mov	r11,sp
80002fce:	f0 1f 00 09 	mcall	80002ff0 <payload_rx+0x4c>
80002fd2:	c0 91       	brne	80002fe4 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002fd4:	48 88       	lddpc	r8,80002ff4 <payload_rx+0x50>
80002fd6:	70 0c       	ld.w	r12,r8[0x0]
80002fd8:	40 0b       	lddsp	r11,sp[0x0]
80002fda:	f0 1f 00 08 	mcall	80002ff8 <payload_rx+0x54>
		logFromISR("mm");
80002fde:	48 8c       	lddpc	r12,80002ffc <payload_rx+0x58>
80002fe0:	f0 1f 00 08 	mcall	80003000 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002fe4:	2f ed       	sub	sp,-8
80002fe6:	d8 02       	popm	pc
80002fe8:	00 00       	add	r0,r0
80002fea:	0a 64       	and	r4,r5
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	55 f0       	stdsp	sp[0x17c],r0
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	54 a0       	stdsp	sp[0x128],r0
80002ff4:	00 00       	add	r0,r0
80002ff6:	0a 94       	mov	r4,r5
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	29 94       	sub	r4,-103
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	c7 28       	rjmp	800030e2 <phy_rx_func+0xde>
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	62 14       	ld.w	r4,r1[0x4]

80003004 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003004:	eb cd 40 e0 	pushm	r5-r7,lr
80003008:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000300a:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000300e:	70 08       	ld.w	r8,r8[0x0]
80003010:	58 08       	cp.w	r8,0
80003012:	e0 80 01 08 	breq	80003222 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003016:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003018:	fe f8 0e 70 	ld.w	r8,pc[3696]
8000301c:	70 09       	ld.w	r9,r8[0x0]
8000301e:	2f f9       	sub	r9,-1
80003020:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003022:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003026:	70 08       	ld.w	r8,r8[0x0]
80003028:	58 18       	cp.w	r8,1
8000302a:	e0 80 00 85 	breq	80003134 <phy_rx_func+0x130>
8000302e:	c0 73       	brcs	8000303c <phy_rx_func+0x38>
80003030:	58 28       	cp.w	r8,2
80003032:	c5 c0       	breq	800030ea <phy_rx_func+0xe6>
80003034:	58 38       	cp.w	r8,3
80003036:	e0 81 00 f6 	brne	80003222 <phy_rx_func+0x21e>
8000303a:	cd 58       	rjmp	800031e4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000303c:	e0 6a 5a 5a 	mov	r10,23130
80003040:	ea 1a ab cd 	orh	r10,0xabcd
80003044:	14 36       	cp.w	r6,r10
80003046:	e0 80 00 ee 	breq	80003222 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000304a:	ec 08 16 10 	lsr	r8,r6,0x10
8000304e:	e0 48 ab cd 	cp.w	r8,43981
80003052:	e0 81 00 e8 	brne	80003222 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003056:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000305a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000305e:	20 28       	sub	r8,2
80003060:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003064:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003066:	30 09       	mov	r9,0
80003068:	f2 08 19 00 	cp.h	r8,r9
8000306c:	e0 8a 00 db 	brle	80003222 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003070:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003074:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003076:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000307a:	70 0c       	ld.w	r12,r8[0x0]
8000307c:	f0 1f 03 88 	mcall	80003e9c <phy_rx_func+0xe98>
80003080:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003084:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003086:	58 0c       	cp.w	r12,0
80003088:	e0 80 00 cd 	breq	80003222 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000308c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003090:	90 09       	ld.sh	r9,r8[0x0]
80003092:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003096:	2f f9       	sub	r9,-1
80003098:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000309a:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000309e:	74 0a       	ld.w	r10,r10[0x0]
800030a0:	fe fb 0d e8 	ld.w	r11,pc[3560]
800030a4:	76 0b       	ld.w	r11,r11[0x0]
800030a6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800030aa:	2f f9       	sub	r9,-1
800030ac:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800030ae:	e2 16 0f 00 	andl	r6,0xf00,COH
800030b2:	e0 46 01 00 	cp.w	r6,256
800030b6:	c0 c0       	breq	800030ce <phy_rx_func+0xca>
800030b8:	e0 8b 00 05 	brhi	800030c2 <phy_rx_func+0xbe>
800030bc:	58 06       	cp.w	r6,0
800030be:	c0 80       	breq	800030ce <phy_rx_func+0xca>
800030c0:	c0 c8       	rjmp	800030d8 <phy_rx_func+0xd4>
800030c2:	e0 46 02 00 	cp.w	r6,512
800030c6:	c0 40       	breq	800030ce <phy_rx_func+0xca>
800030c8:	e0 46 03 00 	cp.w	r6,768
800030cc:	c0 61       	brne	800030d8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800030ce:	30 29       	mov	r9,2
800030d0:	fe f8 0d bc 	ld.w	r8,pc[3516]
800030d4:	91 09       	st.w	r8[0x0],r9
800030d6:	ca 68       	rjmp	80003222 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800030d8:	fe f8 0d c0 	ld.w	r8,pc[3520]
800030dc:	70 0c       	ld.w	r12,r8[0x0]
800030de:	fe f8 0d c2 	ld.w	r8,pc[3522]
800030e2:	70 0b       	ld.w	r11,r8[0x0]
800030e4:	f0 1f 03 70 	mcall	80003ea4 <phy_rx_func+0xea0>
800030e8:	c9 d8       	rjmp	80003222 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800030ea:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800030ee:	b1 86       	lsr	r6,0x10
800030f0:	14 06       	add	r6,r10
800030f2:	fe f8 0d b6 	ld.w	r8,pc[3510]
800030f6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800030f8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800030fc:	90 09       	ld.sh	r9,r8[0x0]
800030fe:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003102:	76 0b       	ld.w	r11,r11[0x0]
80003104:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003108:	2f f9       	sub	r9,-1
8000310a:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000310c:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003110:	92 08       	ld.sh	r8,r9[0x0]
80003112:	20 28       	sub	r8,2
80003114:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003116:	30 09       	mov	r9,0
80003118:	f2 08 19 00 	cp.h	r8,r9
8000311c:	e0 8a 00 07 	brle	8000312a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003120:	30 19       	mov	r9,1
80003122:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003126:	91 09       	st.w	r8[0x0],r9
80003128:	c7 d8       	rjmp	80003222 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000312a:	30 39       	mov	r9,3
8000312c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	c7 88       	rjmp	80003222 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003134:	ec 0a 14 10 	asr	r10,r6,0x10
80003138:	fe f8 0d 70 	ld.w	r8,pc[3440]
8000313c:	90 09       	ld.sh	r9,r8[0x0]
8000313e:	14 09       	add	r9,r10
80003140:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003142:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003146:	92 08       	ld.sh	r8,r9[0x0]
80003148:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000314c:	76 0b       	ld.w	r11,r11[0x0]
8000314e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003152:	2f f8       	sub	r8,-1
80003154:	5c 88       	casts.h	r8
80003156:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003158:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000315c:	94 09       	ld.sh	r9,r10[0x0]
8000315e:	20 29       	sub	r9,2
80003160:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003162:	30 0a       	mov	r10,0
80003164:	f4 09 19 00 	cp.h	r9,r10
80003168:	e0 89 00 20 	brgt	800031a8 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000316c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003170:	e0 46 00 ba 	cp.w	r6,186
80003174:	c0 d1       	brne	8000318e <phy_rx_func+0x18a>
80003176:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000317a:	90 09       	ld.sh	r9,r8[0x0]
8000317c:	f4 09 19 00 	cp.h	r9,r10
80003180:	c0 71       	brne	8000318e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003182:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003186:	70 0c       	ld.w	r12,r8[0x0]
80003188:	f0 1f 03 49 	mcall	80003eac <phy_rx_func+0xea8>
8000318c:	c0 98       	rjmp	8000319e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000318e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003192:	70 0c       	ld.w	r12,r8[0x0]
80003194:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003198:	70 0b       	ld.w	r11,r8[0x0]
8000319a:	f0 1f 03 43 	mcall	80003ea4 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000319e:	30 09       	mov	r9,0
800031a0:	fe f8 0c ec 	ld.w	r8,pc[3308]
800031a4:	91 09       	st.w	r8[0x0],r9
800031a6:	c3 e8       	rjmp	80003222 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800031a8:	5c 86       	casts.h	r6
800031aa:	fe f9 0c fe 	ld.w	r9,pc[3326]
800031ae:	92 0a       	ld.sh	r10,r9[0x0]
800031b0:	0c 0a       	add	r10,r6
800031b2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031b4:	fe f9 0c ec 	ld.w	r9,pc[3308]
800031b8:	72 09       	ld.w	r9,r9[0x0]
800031ba:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031be:	2f f8       	sub	r8,-1
800031c0:	fe f9 0c d4 	ld.w	r9,pc[3284]
800031c4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031c6:	fe f9 0c ca 	ld.w	r9,pc[3274]
800031ca:	92 08       	ld.sh	r8,r9[0x0]
800031cc:	20 28       	sub	r8,2
800031ce:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800031d0:	30 09       	mov	r9,0
800031d2:	f2 08 19 00 	cp.h	r8,r9
800031d6:	e0 89 00 26 	brgt	80003222 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800031da:	30 39       	mov	r9,3
800031dc:	fe f8 0c b0 	ld.w	r8,pc[3248]
800031e0:	91 09       	st.w	r8[0x0],r9
800031e2:	c2 08       	rjmp	80003222 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800031e4:	e6 16 00 ff 	andh	r6,0xff,COH
800031e8:	fc 19 00 ba 	movh	r9,0xba
800031ec:	12 36       	cp.w	r6,r9
800031ee:	c0 e1       	brne	8000320a <phy_rx_func+0x206>
800031f0:	fe f8 0c b8 	ld.w	r8,pc[3256]
800031f4:	90 09       	ld.sh	r9,r8[0x0]
800031f6:	30 08       	mov	r8,0
800031f8:	f0 09 19 00 	cp.h	r9,r8
800031fc:	c0 71       	brne	8000320a <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800031fe:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003202:	70 0c       	ld.w	r12,r8[0x0]
80003204:	f0 1f 03 2a 	mcall	80003eac <phy_rx_func+0xea8>
80003208:	c0 98       	rjmp	8000321a <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000320a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000320e:	70 0c       	ld.w	r12,r8[0x0]
80003210:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003214:	70 0b       	ld.w	r11,r8[0x0]
80003216:	f0 1f 03 24 	mcall	80003ea4 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000321a:	30 09       	mov	r9,0
8000321c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003220:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003222:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003226:	11 89       	ld.ub	r9,r8[0x0]
80003228:	30 08       	mov	r8,0
8000322a:	f0 09 18 00 	cp.b	r9,r8
8000322e:	c1 31       	brne	80003254 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003230:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003234:	6c 0c       	ld.w	r12,r6[0x0]
80003236:	f0 1f 03 1a 	mcall	80003e9c <phy_rx_func+0xe98>
8000323a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000323e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003240:	6c 0c       	ld.w	r12,r6[0x0]
80003242:	f0 1f 03 17 	mcall	80003e9c <phy_rx_func+0xe98>
80003246:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000324a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000324c:	30 19       	mov	r9,1
8000324e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003252:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003254:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003258:	70 08       	ld.w	r8,r8[0x0]
8000325a:	58 28       	cp.w	r8,2
8000325c:	e0 80 01 98 	breq	8000358c <phy_rx_func+0x588>
80003260:	e0 8b 00 06 	brhi	8000326c <phy_rx_func+0x268>
80003264:	58 08       	cp.w	r8,0
80003266:	c0 b0       	breq	8000327c <phy_rx_func+0x278>
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000326c:	58 38       	cp.w	r8,3
8000326e:	e0 80 05 c5 	breq	80003df8 <phy_rx_func+0xdf4>
80003272:	58 48       	cp.w	r8,4
80003274:	e0 81 06 05 	brne	80003e7e <phy_rx_func+0xe7a>
80003278:	e0 8f 02 4b 	bral	8000370e <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000327c:	6e 28       	ld.w	r8,r7[0x8]
8000327e:	e0 6a 5a 5a 	mov	r10,23130
80003282:	ea 1a ab cd 	orh	r10,0xabcd
80003286:	14 38       	cp.w	r8,r10
80003288:	c0 71       	brne	80003296 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000328a:	30 09       	mov	r9,0
8000328c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003290:	91 09       	st.w	r8[0x0],r9
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003296:	10 99       	mov	r9,r8
80003298:	e0 19 00 00 	andl	r9,0x0
8000329c:	fc 1a ab cd 	movh	r10,0xabcd
800032a0:	14 39       	cp.w	r9,r10
800032a2:	e0 81 05 ee 	brne	80003e7e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032a6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032aa:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800032ae:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800032b0:	6e 29       	ld.w	r9,r7[0x8]
800032b2:	e2 19 f0 00 	andl	r9,0xf000,COH
800032b6:	e0 49 c0 00 	cp.w	r9,49152
800032ba:	e0 81 00 ce 	brne	80003456 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800032be:	30 1a       	mov	r10,1
800032c0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800032c4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800032c6:	fe f9 0b f6 	ld.w	r9,pc[3062]
800032ca:	72 09       	ld.w	r9,r9[0x0]
800032cc:	58 09       	cp.w	r9,0
800032ce:	c0 71       	brne	800032dc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032d0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800032d4:	f0 1f 03 00 	mcall	80003ed4 <phy_rx_func+0xed0>
800032d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800032dc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800032e0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800032e4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800032e6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800032ea:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800032ee:	fe fa 0b ee 	ld.w	r10,pc[3054]
800032f2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800032f4:	13 89       	ld.ub	r9,r9[0x0]
800032f6:	37 fa       	mov	r10,127
800032f8:	f4 09 18 00 	cp.b	r9,r10
800032fc:	c6 d0       	breq	800033d6 <phy_rx_func+0x3d2>
800032fe:	e0 8b 00 0c 	brhi	80003316 <phy_rx_func+0x312>
80003302:	31 2a       	mov	r10,18
80003304:	f4 09 18 00 	cp.b	r9,r10
80003308:	c4 20       	breq	8000338c <phy_rx_func+0x388>
8000330a:	31 3a       	mov	r10,19
8000330c:	f4 09 18 00 	cp.b	r9,r10
80003310:	e0 81 00 83 	brne	80003416 <phy_rx_func+0x412>
80003314:	c5 b8       	rjmp	800033ca <phy_rx_func+0x3c6>
80003316:	2f 09       	sub	r9,-16
80003318:	30 1a       	mov	r10,1
8000331a:	f4 09 18 00 	cp.b	r9,r10
8000331e:	e0 8b 00 7c 	brhi	80003416 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003322:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003326:	e2 18 00 f0 	andl	r8,0xf0,COH
8000332a:	59 08       	cp.w	r8,16
8000332c:	c0 71       	brne	8000333a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000332e:	30 19       	mov	r9,1
80003330:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003334:	91 09       	st.w	r8[0x0],r9
80003336:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000333a:	e0 48 00 20 	cp.w	r8,32
8000333e:	c2 11       	brne	80003380 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003340:	30 a9       	mov	r9,10
80003342:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003346:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003348:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000334c:	6c 08       	ld.w	r8,r6[0x0]
8000334e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003352:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003356:	2f f8       	sub	r8,-1
80003358:	6e 0c       	ld.w	r12,r7[0x0]
8000335a:	f4 ca fe 00 	sub	r10,r10,-512
8000335e:	30 0b       	mov	r11,0
80003360:	10 0c       	add	r12,r8
80003362:	f0 1f 02 e1 	mcall	80003ee4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003366:	30 08       	mov	r8,0
80003368:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000336a:	6e 0c       	ld.w	r12,r7[0x0]
8000336c:	f0 1f 02 df 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003370:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003374:	70 0c       	ld.w	r12,r8[0x0]
80003376:	f0 1f 02 ca 	mcall	80003e9c <phy_rx_func+0xe98>
8000337a:	8f 0c       	st.w	r7[0x0],r12
8000337c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003380:	30 09       	mov	r9,0
80003382:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003386:	91 09       	st.w	r8[0x0],r9
80003388:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000338c:	20 48       	sub	r8,4
8000338e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003392:	93 08       	st.w	r9[0x0],r8
80003394:	58 08       	cp.w	r8,0
80003396:	e0 80 05 74 	breq	80003e7e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000339a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000339e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033a2:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800033a6:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800033a8:	8e 69       	ld.sh	r9,r7[0xc]
800033aa:	fe f8 0b 46 	ld.w	r8,pc[2886]
800033ae:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800033b0:	8e 79       	ld.sh	r9,r7[0xe]
800033b2:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800033b4:	f0 1f 02 d0 	mcall	80003ef4 <phy_rx_func+0xef0>
800033b8:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800033bc:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800033be:	30 49       	mov	r9,4
800033c0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800033ca:	30 09       	mov	r9,0
800033cc:	fe f8 0a f8 	ld.w	r8,pc[2808]
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033d6:	20 48       	sub	r8,4
800033d8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800033dc:	93 08       	st.w	r9[0x0],r8
800033de:	58 08       	cp.w	r8,0
800033e0:	e0 80 05 4f 	breq	80003e7e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800033e4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800033e8:	70 09       	ld.w	r9,r8[0x0]
800033ea:	8e 7b       	ld.sh	r11,r7[0xe]
800033ec:	fe fa 0b 10 	ld.w	r10,pc[2832]
800033f0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800033f4:	2f f9       	sub	r9,-1
800033f6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800033f8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800033fc:	70 09       	ld.w	r9,r8[0x0]
800033fe:	20 29       	sub	r9,2
80003400:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003402:	30 29       	mov	r9,2
80003404:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003408:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000340a:	30 39       	mov	r9,3
8000340c:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003410:	91 09       	st.w	r8[0x0],r9
80003412:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003416:	30 3a       	mov	r10,3
80003418:	fe f9 0a ac 	ld.w	r9,pc[2732]
8000341c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000341e:	6e 2a       	ld.w	r10,r7[0x8]
80003420:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003424:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003426:	6e 3a       	ld.w	r10,r7[0xc]
80003428:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000342a:	59 48       	cp.w	r8,20
8000342c:	c0 61       	brne	80003438 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000342e:	31 89       	mov	r9,24
80003430:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003434:	91 09       	st.w	r8[0x0],r9
80003436:	c0 a8       	rjmp	8000344a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003438:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000343c:	70 08       	ld.w	r8,r8[0x0]
8000343e:	59 08       	cp.w	r8,16
80003440:	c0 51       	brne	8000344a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003442:	31 09       	mov	r9,16
80003444:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003448:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000344a:	30 49       	mov	r9,4
8000344c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003450:	91 09       	st.w	r8[0x0],r9
80003452:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003456:	e0 49 10 00 	cp.w	r9,4096
8000345a:	5f 1a       	srne	r10
8000345c:	e0 49 20 00 	cp.w	r9,8192
80003460:	5f 19       	srne	r9
80003462:	f5 e9 00 09 	and	r9,r10,r9
80003466:	e0 81 05 0c 	brne	80003e7e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000346a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000346e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003470:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003474:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003476:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000347a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000347c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003480:	72 09       	ld.w	r9,r9[0x0]
80003482:	58 09       	cp.w	r9,0
80003484:	c0 71       	brne	80003492 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003486:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000348a:	f0 1f 02 93 	mcall	80003ed4 <phy_rx_func+0xed0>
8000348e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003492:	6e 2a       	ld.w	r10,r7[0x8]
80003494:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003498:	58 1a       	cp.w	r10,1
8000349a:	e0 8b 00 4d 	brhi	80003534 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000349e:	20 48       	sub	r8,4
800034a0:	fe f9 0a 28 	ld.w	r9,pc[2600]
800034a4:	93 08       	st.w	r9[0x0],r8
800034a6:	58 08       	cp.w	r8,0
800034a8:	e0 80 04 eb 	breq	80003e7e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800034ac:	8e 68       	ld.sh	r8,r7[0xc]
800034ae:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800034b2:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800034b6:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800034b8:	30 09       	mov	r9,0
800034ba:	f2 08 19 00 	cp.h	r8,r9
800034be:	c0 70       	breq	800034cc <phy_rx_func+0x4c8>
800034c0:	30 19       	mov	r9,1
800034c2:	f2 08 19 00 	cp.h	r8,r9
800034c6:	e0 81 04 dc 	brne	80003e7e <phy_rx_func+0xe7a>
800034ca:	c2 68       	rjmp	80003516 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034cc:	fe f8 0a 44 	ld.w	r8,pc[2628]
800034d0:	70 0a       	ld.w	r10,r8[0x0]
800034d2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800034d6:	72 09       	ld.w	r9,r9[0x0]
800034d8:	8e 7b       	ld.sh	r11,r7[0xe]
800034da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800034de:	70 09       	ld.w	r9,r8[0x0]
800034e0:	2f f9       	sub	r9,-1
800034e2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034e4:	e0 49 00 ff 	cp.w	r9,255
800034e8:	e0 88 00 11 	brls	8000350a <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800034ec:	30 09       	mov	r9,0
800034ee:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800034f0:	fe f7 09 c8 	ld.w	r7,pc[2504]
800034f4:	6e 0c       	ld.w	r12,r7[0x0]
800034f6:	f0 1f 02 7d 	mcall	80003ee8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800034fa:	fe f8 09 ba 	ld.w	r8,pc[2490]
800034fe:	70 0c       	ld.w	r12,r8[0x0]
80003500:	f0 1f 02 67 	mcall	80003e9c <phy_rx_func+0xe98>
80003504:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003506:	e0 80 04 bc 	breq	80003e7e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000350a:	30 29       	mov	r9,2
8000350c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003510:	91 09       	st.w	r8[0x0],r9
80003512:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003516:	8e 79       	ld.sh	r9,r7[0xe]
80003518:	30 38       	mov	r8,3
8000351a:	f0 09 19 00 	cp.h	r9,r8
8000351e:	c0 51       	brne	80003528 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003520:	30 19       	mov	r9,1
80003522:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003526:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003528:	30 29       	mov	r9,2
8000352a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000352e:	91 09       	st.w	r8[0x0],r9
80003530:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003534:	58 18       	cp.w	r8,1
80003536:	e0 88 04 a4 	brls	80003e7e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000353a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000353e:	70 0a       	ld.w	r10,r8[0x0]
80003540:	6e 3b       	ld.w	r11,r7[0xc]
80003542:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003546:	70 09       	ld.w	r9,r8[0x0]
80003548:	2f f9       	sub	r9,-1
8000354a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000354c:	e0 49 00 ff 	cp.w	r9,255
80003550:	e0 88 00 11 	brls	80003572 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003554:	30 09       	mov	r9,0
80003556:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003558:	fe f7 09 60 	ld.w	r7,pc[2400]
8000355c:	6e 0c       	ld.w	r12,r7[0x0]
8000355e:	f0 1f 02 63 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003562:	fe f8 09 52 	ld.w	r8,pc[2386]
80003566:	70 0c       	ld.w	r12,r8[0x0]
80003568:	f0 1f 02 4d 	mcall	80003e9c <phy_rx_func+0xe98>
8000356c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000356e:	e0 80 04 88 	breq	80003e7e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003572:	fe f9 09 56 	ld.w	r9,pc[2390]
80003576:	72 08       	ld.w	r8,r9[0x0]
80003578:	20 28       	sub	r8,2
8000357a:	93 08       	st.w	r9[0x0],r8
8000357c:	e0 80 04 81 	breq	80003e7e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003580:	30 29       	mov	r9,2
80003582:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003586:	91 09       	st.w	r8[0x0],r9
80003588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000358c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003590:	70 0a       	ld.w	r10,r8[0x0]
80003592:	fe f9 09 26 	ld.w	r9,pc[2342]
80003596:	72 09       	ld.w	r9,r9[0x0]
80003598:	8e 4b       	ld.sh	r11,r7[0x8]
8000359a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000359e:	70 09       	ld.w	r9,r8[0x0]
800035a0:	2f f9       	sub	r9,-1
800035a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035a4:	e0 49 00 ff 	cp.w	r9,255
800035a8:	e0 88 00 16 	brls	800035d4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800035ac:	30 09       	mov	r9,0
800035ae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035b0:	fe f6 09 08 	ld.w	r6,pc[2312]
800035b4:	6c 0c       	ld.w	r12,r6[0x0]
800035b6:	f0 1f 02 4d 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035ba:	fe f8 08 fa 	ld.w	r8,pc[2298]
800035be:	70 0c       	ld.w	r12,r8[0x0]
800035c0:	f0 1f 02 37 	mcall	80003e9c <phy_rx_func+0xe98>
800035c4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800035c6:	c0 71       	brne	800035d4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800035c8:	30 09       	mov	r9,0
800035ca:	fe f8 08 f6 	ld.w	r8,pc[2294]
800035ce:	91 09       	st.w	r8[0x0],r9
800035d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800035d4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800035d8:	72 08       	ld.w	r8,r9[0x0]
800035da:	20 28       	sub	r8,2
800035dc:	93 08       	st.w	r9[0x0],r8
800035de:	c0 71       	brne	800035ec <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800035e0:	30 09       	mov	r9,0
800035e2:	fe f8 08 de 	ld.w	r8,pc[2270]
800035e6:	91 09       	st.w	r8[0x0],r9
800035e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800035ec:	fe f8 09 24 	ld.w	r8,pc[2340]
800035f0:	70 0a       	ld.w	r10,r8[0x0]
800035f2:	fe f9 08 c6 	ld.w	r9,pc[2246]
800035f6:	72 09       	ld.w	r9,r9[0x0]
800035f8:	8e 5b       	ld.sh	r11,r7[0xa]
800035fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035fe:	70 09       	ld.w	r9,r8[0x0]
80003600:	2f f9       	sub	r9,-1
80003602:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003604:	e0 49 00 ff 	cp.w	r9,255
80003608:	e0 88 00 16 	brls	80003634 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
8000360c:	30 09       	mov	r9,0
8000360e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003610:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003614:	6c 0c       	ld.w	r12,r6[0x0]
80003616:	f0 1f 02 35 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000361a:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000361e:	70 0c       	ld.w	r12,r8[0x0]
80003620:	f0 1f 02 1f 	mcall	80003e9c <phy_rx_func+0xe98>
80003624:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003626:	c0 71       	brne	80003634 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003628:	30 09       	mov	r9,0
8000362a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000362e:	91 09       	st.w	r8[0x0],r9
80003630:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003634:	fe f9 08 94 	ld.w	r9,pc[2196]
80003638:	72 08       	ld.w	r8,r9[0x0]
8000363a:	20 28       	sub	r8,2
8000363c:	93 08       	st.w	r9[0x0],r8
8000363e:	c0 71       	brne	8000364c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003640:	30 09       	mov	r9,0
80003642:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003646:	91 09       	st.w	r8[0x0],r9
80003648:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000364c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003650:	70 0a       	ld.w	r10,r8[0x0]
80003652:	fe f9 08 66 	ld.w	r9,pc[2150]
80003656:	72 09       	ld.w	r9,r9[0x0]
80003658:	8e 6b       	ld.sh	r11,r7[0xc]
8000365a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000365e:	70 09       	ld.w	r9,r8[0x0]
80003660:	2f f9       	sub	r9,-1
80003662:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003664:	e0 49 00 ff 	cp.w	r9,255
80003668:	e0 88 00 16 	brls	80003694 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000366c:	30 09       	mov	r9,0
8000366e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003670:	fe f6 08 48 	ld.w	r6,pc[2120]
80003674:	6c 0c       	ld.w	r12,r6[0x0]
80003676:	f0 1f 02 1d 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000367a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000367e:	70 0c       	ld.w	r12,r8[0x0]
80003680:	f0 1f 02 07 	mcall	80003e9c <phy_rx_func+0xe98>
80003684:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003686:	c0 71       	brne	80003694 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003688:	30 09       	mov	r9,0
8000368a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000368e:	91 09       	st.w	r8[0x0],r9
80003690:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003694:	fe f9 08 34 	ld.w	r9,pc[2100]
80003698:	72 08       	ld.w	r8,r9[0x0]
8000369a:	20 28       	sub	r8,2
8000369c:	93 08       	st.w	r9[0x0],r8
8000369e:	c0 71       	brne	800036ac <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800036a0:	30 09       	mov	r9,0
800036a2:	fe f8 08 1e 	ld.w	r8,pc[2078]
800036a6:	91 09       	st.w	r8[0x0],r9
800036a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800036ac:	fe f8 08 64 	ld.w	r8,pc[2148]
800036b0:	70 0a       	ld.w	r10,r8[0x0]
800036b2:	fe f9 08 06 	ld.w	r9,pc[2054]
800036b6:	72 09       	ld.w	r9,r9[0x0]
800036b8:	8e 7b       	ld.sh	r11,r7[0xe]
800036ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036be:	70 09       	ld.w	r9,r8[0x0]
800036c0:	2f f9       	sub	r9,-1
800036c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036c4:	e0 49 00 ff 	cp.w	r9,255
800036c8:	e0 88 00 16 	brls	800036f4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800036cc:	30 09       	mov	r9,0
800036ce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036d0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800036d4:	6e 0c       	ld.w	r12,r7[0x0]
800036d6:	f0 1f 02 05 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036da:	fe f8 07 da 	ld.w	r8,pc[2010]
800036de:	70 0c       	ld.w	r12,r8[0x0]
800036e0:	f0 1f 01 ef 	mcall	80003e9c <phy_rx_func+0xe98>
800036e4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800036e6:	c0 71       	brne	800036f4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800036e8:	30 09       	mov	r9,0
800036ea:	fe f8 07 d6 	ld.w	r8,pc[2006]
800036ee:	91 09       	st.w	r8[0x0],r9
800036f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036f4:	fe f9 07 d4 	ld.w	r9,pc[2004]
800036f8:	72 08       	ld.w	r8,r9[0x0]
800036fa:	20 28       	sub	r8,2
800036fc:	93 08       	st.w	r9[0x0],r8
800036fe:	e0 81 03 c0 	brne	80003e7e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003702:	30 09       	mov	r9,0
80003704:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003708:	91 09       	st.w	r8[0x0],r9
8000370a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000370e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003712:	11 89       	ld.ub	r9,r8[0x0]
80003714:	31 28       	mov	r8,18
80003716:	f0 09 18 00 	cp.b	r9,r8
8000371a:	e0 81 01 4c 	brne	800039b2 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000371e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003722:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003726:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003728:	11 89       	ld.ub	r9,r8[0x0]
8000372a:	3f 28       	mov	r8,-14
8000372c:	f0 09 18 00 	cp.b	r9,r8
80003730:	e0 81 01 3b 	brne	800039a6 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003734:	30 19       	mov	r9,1
80003736:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000373a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000373c:	6e 29       	ld.w	r9,r7[0x8]
8000373e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003742:	fe f8 07 86 	ld.w	r8,pc[1926]
80003746:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003748:	8e 59       	ld.sh	r9,r7[0xa]
8000374a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000374e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003750:	8e 69       	ld.sh	r9,r7[0xc]
80003752:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003754:	8e 79       	ld.sh	r9,r7[0xe]
80003756:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003758:	fe f8 07 88 	ld.w	r8,pc[1928]
8000375c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003760:	72 0a       	ld.w	r10,r9[0x0]
80003762:	70 09       	ld.w	r9,r8[0x0]
80003764:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003768:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000376c:	70 09       	ld.w	r9,r8[0x0]
8000376e:	2f f9       	sub	r9,-1
80003770:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003772:	e0 49 01 ff 	cp.w	r9,511
80003776:	e0 88 00 16 	brls	800037a2 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000377a:	30 09       	mov	r9,0
8000377c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000377e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003782:	6c 0c       	ld.w	r12,r6[0x0]
80003784:	f0 1f 01 d9 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003788:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000378c:	70 0c       	ld.w	r12,r8[0x0]
8000378e:	f0 1f 01 c4 	mcall	80003e9c <phy_rx_func+0xe98>
80003792:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003794:	c0 71       	brne	800037a2 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003796:	30 09       	mov	r9,0
80003798:	fe f8 07 28 	ld.w	r8,pc[1832]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037a2:	fe f9 07 26 	ld.w	r9,pc[1830]
800037a6:	72 08       	ld.w	r8,r9[0x0]
800037a8:	20 18       	sub	r8,1
800037aa:	93 08       	st.w	r9[0x0],r8
800037ac:	c0 71       	brne	800037ba <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800037ae:	30 09       	mov	r9,0
800037b0:	fe f8 07 10 	ld.w	r8,pc[1808]
800037b4:	91 09       	st.w	r8[0x0],r9
800037b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800037ba:	fe f8 07 26 	ld.w	r8,pc[1830]
800037be:	fe f9 06 fe 	ld.w	r9,pc[1790]
800037c2:	72 0a       	ld.w	r10,r9[0x0]
800037c4:	70 09       	ld.w	r9,r8[0x0]
800037c6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037ca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037ce:	70 09       	ld.w	r9,r8[0x0]
800037d0:	2f f9       	sub	r9,-1
800037d2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037d4:	e0 49 01 ff 	cp.w	r9,511
800037d8:	e0 88 00 16 	brls	80003804 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800037dc:	30 09       	mov	r9,0
800037de:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037e0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800037e4:	6c 0c       	ld.w	r12,r6[0x0]
800037e6:	f0 1f 01 c1 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037ea:	fe f8 06 ca 	ld.w	r8,pc[1738]
800037ee:	70 0c       	ld.w	r12,r8[0x0]
800037f0:	f0 1f 01 ab 	mcall	80003e9c <phy_rx_func+0xe98>
800037f4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f6:	c0 71       	brne	80003804 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800037f8:	30 09       	mov	r9,0
800037fa:	fe f8 06 c6 	ld.w	r8,pc[1734]
800037fe:	91 09       	st.w	r8[0x0],r9
80003800:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003804:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003808:	72 08       	ld.w	r8,r9[0x0]
8000380a:	20 18       	sub	r8,1
8000380c:	93 08       	st.w	r9[0x0],r8
8000380e:	c0 71       	brne	8000381c <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003810:	30 09       	mov	r9,0
80003812:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003816:	91 09       	st.w	r8[0x0],r9
80003818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000381c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003820:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003824:	72 0a       	ld.w	r10,r9[0x0]
80003826:	70 09       	ld.w	r9,r8[0x0]
80003828:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000382c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003830:	70 09       	ld.w	r9,r8[0x0]
80003832:	2f f9       	sub	r9,-1
80003834:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003836:	e0 49 01 ff 	cp.w	r9,511
8000383a:	e0 88 00 16 	brls	80003866 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000383e:	30 09       	mov	r9,0
80003840:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003842:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003846:	6c 0c       	ld.w	r12,r6[0x0]
80003848:	f0 1f 01 a8 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000384c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003850:	70 0c       	ld.w	r12,r8[0x0]
80003852:	f0 1f 01 93 	mcall	80003e9c <phy_rx_func+0xe98>
80003856:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003858:	c0 71       	brne	80003866 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000385a:	30 09       	mov	r9,0
8000385c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003860:	91 09       	st.w	r8[0x0],r9
80003862:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003866:	fe f9 06 62 	ld.w	r9,pc[1634]
8000386a:	72 08       	ld.w	r8,r9[0x0]
8000386c:	20 18       	sub	r8,1
8000386e:	93 08       	st.w	r9[0x0],r8
80003870:	c0 71       	brne	8000387e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003872:	30 09       	mov	r9,0
80003874:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003878:	91 09       	st.w	r8[0x0],r9
8000387a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000387e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003882:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003886:	72 0a       	ld.w	r10,r9[0x0]
80003888:	70 09       	ld.w	r9,r8[0x0]
8000388a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000388e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003892:	70 09       	ld.w	r9,r8[0x0]
80003894:	2f f9       	sub	r9,-1
80003896:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003898:	e0 49 01 ff 	cp.w	r9,511
8000389c:	e0 88 00 16 	brls	800038c8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800038a0:	30 09       	mov	r9,0
800038a2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038a4:	fe f6 06 18 	ld.w	r6,pc[1560]
800038a8:	6c 0c       	ld.w	r12,r6[0x0]
800038aa:	f0 1f 01 90 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038ae:	fe f8 06 06 	ld.w	r8,pc[1542]
800038b2:	70 0c       	ld.w	r12,r8[0x0]
800038b4:	f0 1f 01 7a 	mcall	80003e9c <phy_rx_func+0xe98>
800038b8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038ba:	c0 71       	brne	800038c8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800038bc:	30 09       	mov	r9,0
800038be:	fe f8 06 02 	ld.w	r8,pc[1538]
800038c2:	91 09       	st.w	r8[0x0],r9
800038c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038c8:	fe f9 06 00 	ld.w	r9,pc[1536]
800038cc:	72 08       	ld.w	r8,r9[0x0]
800038ce:	20 18       	sub	r8,1
800038d0:	93 08       	st.w	r9[0x0],r8
800038d2:	c0 71       	brne	800038e0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800038d4:	30 09       	mov	r9,0
800038d6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800038da:	91 09       	st.w	r8[0x0],r9
800038dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800038e0:	fe f8 06 00 	ld.w	r8,pc[1536]
800038e4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800038e8:	72 0a       	ld.w	r10,r9[0x0]
800038ea:	70 09       	ld.w	r9,r8[0x0]
800038ec:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800038f0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038f4:	70 09       	ld.w	r9,r8[0x0]
800038f6:	2f f9       	sub	r9,-1
800038f8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038fa:	e0 49 01 ff 	cp.w	r9,511
800038fe:	e0 88 00 16 	brls	8000392a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003902:	30 09       	mov	r9,0
80003904:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003906:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000390a:	6c 0c       	ld.w	r12,r6[0x0]
8000390c:	f0 1f 01 77 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003910:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003914:	70 0c       	ld.w	r12,r8[0x0]
80003916:	f0 1f 01 62 	mcall	80003e9c <phy_rx_func+0xe98>
8000391a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000391c:	c0 71       	brne	8000392a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000391e:	30 09       	mov	r9,0
80003920:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003924:	91 09       	st.w	r8[0x0],r9
80003926:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000392a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000392e:	72 08       	ld.w	r8,r9[0x0]
80003930:	20 18       	sub	r8,1
80003932:	93 08       	st.w	r9[0x0],r8
80003934:	c0 71       	brne	80003942 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003936:	30 09       	mov	r9,0
80003938:	fe f8 05 88 	ld.w	r8,pc[1416]
8000393c:	91 09       	st.w	r8[0x0],r9
8000393e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003942:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003946:	fe f9 05 76 	ld.w	r9,pc[1398]
8000394a:	72 0a       	ld.w	r10,r9[0x0]
8000394c:	70 09       	ld.w	r9,r8[0x0]
8000394e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003952:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003956:	70 09       	ld.w	r9,r8[0x0]
80003958:	2f f9       	sub	r9,-1
8000395a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000395c:	e0 49 01 ff 	cp.w	r9,511
80003960:	e0 88 00 16 	brls	8000398c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003964:	30 09       	mov	r9,0
80003966:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003968:	fe f7 05 54 	ld.w	r7,pc[1364]
8000396c:	6e 0c       	ld.w	r12,r7[0x0]
8000396e:	f0 1f 01 5f 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003972:	fe f8 05 42 	ld.w	r8,pc[1346]
80003976:	70 0c       	ld.w	r12,r8[0x0]
80003978:	f0 1f 01 49 	mcall	80003e9c <phy_rx_func+0xe98>
8000397c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000397e:	c0 71       	brne	8000398c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003980:	30 09       	mov	r9,0
80003982:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003986:	91 09       	st.w	r8[0x0],r9
80003988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000398c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003990:	72 08       	ld.w	r8,r9[0x0]
80003992:	20 18       	sub	r8,1
80003994:	93 08       	st.w	r9[0x0],r8
80003996:	e0 81 02 74 	brne	80003e7e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000399a:	30 09       	mov	r9,0
8000399c:	fe f8 05 24 	ld.w	r8,pc[1316]
800039a0:	91 09       	st.w	r8[0x0],r9
800039a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800039a6:	30 09       	mov	r9,0
800039a8:	fe f8 05 18 	ld.w	r8,pc[1304]
800039ac:	91 09       	st.w	r8[0x0],r9
800039ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800039b2:	fe f8 05 26 	ld.w	r8,pc[1318]
800039b6:	11 89       	ld.ub	r9,r8[0x0]
800039b8:	3f 28       	mov	r8,-14
800039ba:	f0 09 18 00 	cp.b	r9,r8
800039be:	c4 31       	brne	80003a44 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800039c0:	8e 49       	ld.sh	r9,r7[0x8]
800039c2:	fe f8 05 56 	ld.w	r8,pc[1366]
800039c6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800039c8:	fe f8 05 18 	ld.w	r8,pc[1304]
800039cc:	fe f9 04 f0 	ld.w	r9,pc[1264]
800039d0:	72 0a       	ld.w	r10,r9[0x0]
800039d2:	70 09       	ld.w	r9,r8[0x0]
800039d4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800039d8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039dc:	70 09       	ld.w	r9,r8[0x0]
800039de:	2f f9       	sub	r9,-1
800039e0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e2:	e0 49 01 ff 	cp.w	r9,511
800039e6:	e0 88 00 16 	brls	80003a12 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039ea:	30 09       	mov	r9,0
800039ec:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039ee:	fe f7 04 ce 	ld.w	r7,pc[1230]
800039f2:	6e 0c       	ld.w	r12,r7[0x0]
800039f4:	f0 1f 01 3d 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f8:	fe f8 04 bc 	ld.w	r8,pc[1212]
800039fc:	70 0c       	ld.w	r12,r8[0x0]
800039fe:	f0 1f 01 28 	mcall	80003e9c <phy_rx_func+0xe98>
80003a02:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a04:	c0 71       	brne	80003a12 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003a06:	30 09       	mov	r9,0
80003a08:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a12:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003a16:	72 08       	ld.w	r8,r9[0x0]
80003a18:	20 18       	sub	r8,1
80003a1a:	93 08       	st.w	r9[0x0],r8
80003a1c:	c0 71       	brne	80003a2a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003a2a:	20 18       	sub	r8,1
80003a2c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003a30:	93 08       	st.w	r9[0x0],r8
80003a32:	58 08       	cp.w	r8,0
80003a34:	e0 81 02 25 	brne	80003e7e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003a38:	30 09       	mov	r9,0
80003a3a:	fe f8 04 86 	ld.w	r8,pc[1158]
80003a3e:	91 09       	st.w	r8[0x0],r9
80003a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003a44:	fe f8 04 94 	ld.w	r8,pc[1172]
80003a48:	11 89       	ld.ub	r9,r8[0x0]
80003a4a:	3f 38       	mov	r8,-13
80003a4c:	f0 09 18 00 	cp.b	r9,r8
80003a50:	e0 81 01 0c 	brne	80003c68 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003a54:	8e 49       	ld.sh	r9,r7[0x8]
80003a56:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003a5a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003a5c:	8e 59       	ld.sh	r9,r7[0xa]
80003a5e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003a60:	8e 69       	ld.sh	r9,r7[0xc]
80003a62:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003a64:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003a68:	fe f9 04 54 	ld.w	r9,pc[1108]
80003a6c:	72 0a       	ld.w	r10,r9[0x0]
80003a6e:	70 09       	ld.w	r9,r8[0x0]
80003a70:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a74:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a78:	70 09       	ld.w	r9,r8[0x0]
80003a7a:	2f f9       	sub	r9,-1
80003a7c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a7e:	e0 49 01 ff 	cp.w	r9,511
80003a82:	e0 88 00 16 	brls	80003aae <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a86:	30 09       	mov	r9,0
80003a88:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a8a:	fe f6 04 32 	ld.w	r6,pc[1074]
80003a8e:	6c 0c       	ld.w	r12,r6[0x0]
80003a90:	f0 1f 01 16 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a94:	fe f8 04 20 	ld.w	r8,pc[1056]
80003a98:	70 0c       	ld.w	r12,r8[0x0]
80003a9a:	f0 1f 01 01 	mcall	80003e9c <phy_rx_func+0xe98>
80003a9e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003aa0:	c0 71       	brne	80003aae <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003aa2:	30 09       	mov	r9,0
80003aa4:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003aa8:	91 09       	st.w	r8[0x0],r9
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aae:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003ab2:	72 08       	ld.w	r8,r9[0x0]
80003ab4:	20 18       	sub	r8,1
80003ab6:	93 08       	st.w	r9[0x0],r8
80003ab8:	c0 71       	brne	80003ac6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003aba:	30 09       	mov	r9,0
80003abc:	fe f8 04 04 	ld.w	r8,pc[1028]
80003ac0:	91 09       	st.w	r8[0x0],r9
80003ac2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003ac6:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003aca:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003ace:	72 0a       	ld.w	r10,r9[0x0]
80003ad0:	70 09       	ld.w	r9,r8[0x0]
80003ad2:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ad6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ada:	70 09       	ld.w	r9,r8[0x0]
80003adc:	2f f9       	sub	r9,-1
80003ade:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ae0:	e0 49 01 ff 	cp.w	r9,511
80003ae4:	e0 88 00 16 	brls	80003b10 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ae8:	30 09       	mov	r9,0
80003aea:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003aec:	fe f6 03 d0 	ld.w	r6,pc[976]
80003af0:	6c 0c       	ld.w	r12,r6[0x0]
80003af2:	f0 1f 00 fe 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003af6:	fe f8 03 be 	ld.w	r8,pc[958]
80003afa:	70 0c       	ld.w	r12,r8[0x0]
80003afc:	f0 1f 00 e8 	mcall	80003e9c <phy_rx_func+0xe98>
80003b00:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b02:	c0 71       	brne	80003b10 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003b04:	30 09       	mov	r9,0
80003b06:	fe f8 03 ba 	ld.w	r8,pc[954]
80003b0a:	91 09       	st.w	r8[0x0],r9
80003b0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b10:	fe f9 03 b8 	ld.w	r9,pc[952]
80003b14:	72 08       	ld.w	r8,r9[0x0]
80003b16:	20 18       	sub	r8,1
80003b18:	93 08       	st.w	r9[0x0],r8
80003b1a:	c0 71       	brne	80003b28 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003b1c:	30 09       	mov	r9,0
80003b1e:	fe f8 03 a2 	ld.w	r8,pc[930]
80003b22:	91 09       	st.w	r8[0x0],r9
80003b24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003b28:	fe f8 03 b8 	ld.w	r8,pc[952]
80003b2c:	fe f9 03 90 	ld.w	r9,pc[912]
80003b30:	72 0a       	ld.w	r10,r9[0x0]
80003b32:	70 09       	ld.w	r9,r8[0x0]
80003b34:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b38:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b3c:	70 09       	ld.w	r9,r8[0x0]
80003b3e:	2f f9       	sub	r9,-1
80003b40:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b42:	e0 49 01 ff 	cp.w	r9,511
80003b46:	e0 88 00 16 	brls	80003b72 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b4a:	30 09       	mov	r9,0
80003b4c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b4e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003b52:	6c 0c       	ld.w	r12,r6[0x0]
80003b54:	f0 1f 00 e5 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b58:	fe f8 03 5c 	ld.w	r8,pc[860]
80003b5c:	70 0c       	ld.w	r12,r8[0x0]
80003b5e:	f0 1f 00 d0 	mcall	80003e9c <phy_rx_func+0xe98>
80003b62:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b64:	c0 71       	brne	80003b72 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003b66:	30 09       	mov	r9,0
80003b68:	fe f8 03 58 	ld.w	r8,pc[856]
80003b6c:	91 09       	st.w	r8[0x0],r9
80003b6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b72:	fe f9 03 56 	ld.w	r9,pc[854]
80003b76:	72 08       	ld.w	r8,r9[0x0]
80003b78:	20 18       	sub	r8,1
80003b7a:	93 08       	st.w	r9[0x0],r8
80003b7c:	c0 71       	brne	80003b8a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003b7e:	30 09       	mov	r9,0
80003b80:	fe f8 03 40 	ld.w	r8,pc[832]
80003b84:	91 09       	st.w	r8[0x0],r9
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003b8a:	fe f8 03 56 	ld.w	r8,pc[854]
80003b8e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003b92:	72 0a       	ld.w	r10,r9[0x0]
80003b94:	70 09       	ld.w	r9,r8[0x0]
80003b96:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b9a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b9e:	70 09       	ld.w	r9,r8[0x0]
80003ba0:	2f f9       	sub	r9,-1
80003ba2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ba4:	e0 49 01 ff 	cp.w	r9,511
80003ba8:	e0 88 00 16 	brls	80003bd4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003bac:	30 09       	mov	r9,0
80003bae:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003bb0:	fe f6 03 0c 	ld.w	r6,pc[780]
80003bb4:	6c 0c       	ld.w	r12,r6[0x0]
80003bb6:	f0 1f 00 cd 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bba:	fe f8 02 fa 	ld.w	r8,pc[762]
80003bbe:	70 0c       	ld.w	r12,r8[0x0]
80003bc0:	f0 1f 00 b7 	mcall	80003e9c <phy_rx_func+0xe98>
80003bc4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bc6:	c0 71       	brne	80003bd4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003bc8:	30 09       	mov	r9,0
80003bca:	fe f8 02 f6 	ld.w	r8,pc[758]
80003bce:	91 09       	st.w	r8[0x0],r9
80003bd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bd4:	fe f9 02 f4 	ld.w	r9,pc[756]
80003bd8:	72 08       	ld.w	r8,r9[0x0]
80003bda:	20 18       	sub	r8,1
80003bdc:	93 08       	st.w	r9[0x0],r8
80003bde:	c0 71       	brne	80003bec <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003be0:	30 09       	mov	r9,0
80003be2:	fe f8 02 de 	ld.w	r8,pc[734]
80003be6:	91 09       	st.w	r8[0x0],r9
80003be8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003bec:	fe f8 02 f4 	ld.w	r8,pc[756]
80003bf0:	fe f9 02 cc 	ld.w	r9,pc[716]
80003bf4:	72 0a       	ld.w	r10,r9[0x0]
80003bf6:	70 09       	ld.w	r9,r8[0x0]
80003bf8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003bfc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c00:	70 09       	ld.w	r9,r8[0x0]
80003c02:	2f f9       	sub	r9,-1
80003c04:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c06:	e0 49 01 ff 	cp.w	r9,511
80003c0a:	e0 88 00 16 	brls	80003c36 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c0e:	30 09       	mov	r9,0
80003c10:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c12:	fe f7 02 aa 	ld.w	r7,pc[682]
80003c16:	6e 0c       	ld.w	r12,r7[0x0]
80003c18:	f0 1f 00 b4 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c1c:	fe f8 02 98 	ld.w	r8,pc[664]
80003c20:	70 0c       	ld.w	r12,r8[0x0]
80003c22:	f0 1f 00 9f 	mcall	80003e9c <phy_rx_func+0xe98>
80003c26:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c28:	c0 71       	brne	80003c36 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003c2a:	30 09       	mov	r9,0
80003c2c:	fe f8 02 94 	ld.w	r8,pc[660]
80003c30:	91 09       	st.w	r8[0x0],r9
80003c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c36:	fe f9 02 92 	ld.w	r9,pc[658]
80003c3a:	72 08       	ld.w	r8,r9[0x0]
80003c3c:	20 18       	sub	r8,1
80003c3e:	93 08       	st.w	r9[0x0],r8
80003c40:	c0 71       	brne	80003c4e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003c42:	30 09       	mov	r9,0
80003c44:	fe f8 02 7c 	ld.w	r8,pc[636]
80003c48:	91 09       	st.w	r8[0x0],r9
80003c4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003c4e:	20 18       	sub	r8,1
80003c50:	fe f9 02 78 	ld.w	r9,pc[632]
80003c54:	93 08       	st.w	r9[0x0],r8
80003c56:	58 08       	cp.w	r8,0
80003c58:	e0 81 01 13 	brne	80003e7e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003c5c:	30 09       	mov	r9,0
80003c5e:	fe f8 02 62 	ld.w	r8,pc[610]
80003c62:	91 09       	st.w	r8[0x0],r9
80003c64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003c68:	fe f8 02 70 	ld.w	r8,pc[624]
80003c6c:	11 89       	ld.ub	r9,r8[0x0]
80003c6e:	30 48       	mov	r8,4
80003c70:	f0 09 18 00 	cp.b	r9,r8
80003c74:	c0 80       	breq	80003c84 <phy_rx_func+0xc80>
80003c76:	fe f8 02 62 	ld.w	r8,pc[610]
80003c7a:	11 89       	ld.ub	r9,r8[0x0]
80003c7c:	30 38       	mov	r8,3
80003c7e:	f0 09 18 00 	cp.b	r9,r8
80003c82:	c1 41       	brne	80003caa <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003c84:	6e 29       	ld.w	r9,r7[0x8]
80003c86:	fe f8 02 7a 	ld.w	r8,pc[634]
80003c8a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003c8c:	6e 39       	ld.w	r9,r7[0xc]
80003c8e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003c90:	fe f9 02 38 	ld.w	r9,pc[568]
80003c94:	72 08       	ld.w	r8,r9[0x0]
80003c96:	20 88       	sub	r8,8
80003c98:	93 08       	st.w	r9[0x0],r8
80003c9a:	e0 81 00 f2 	brne	80003e7e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003c9e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ca0:	fe f9 02 20 	ld.w	r9,pc[544]
80003ca4:	93 08       	st.w	r9[0x0],r8
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003caa:	fe f8 02 2e 	ld.w	r8,pc[558]
80003cae:	11 89       	ld.ub	r9,r8[0x0]
80003cb0:	31 38       	mov	r8,19
80003cb2:	f0 09 18 00 	cp.b	r9,r8
80003cb6:	e0 81 00 9c 	brne	80003dee <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003cba:	fe f8 02 62 	ld.w	r8,pc[610]
80003cbe:	11 88       	ld.ub	r8,r8[0x0]
80003cc0:	30 c9       	mov	r9,12
80003cc2:	f2 08 18 00 	cp.b	r8,r9
80003cc6:	e0 81 00 7b 	brne	80003dbc <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003cca:	8e 49       	ld.sh	r9,r7[0x8]
80003ccc:	fe f8 02 54 	ld.w	r8,pc[596]
80003cd0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003cd4:	30 09       	mov	r9,0
80003cd6:	fe f8 02 46 	ld.w	r8,pc[582]
80003cda:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cdc:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ce0:	3f 38       	mov	r8,-13
80003ce2:	f0 09 18 00 	cp.b	r9,r8
80003ce6:	c6 61       	brne	80003db2 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ce8:	10 99       	mov	r9,r8
80003cea:	4f c8       	lddpc	r8,80003ed8 <phy_rx_func+0xed4>
80003cec:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003cee:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003cf2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003cf6:	4f 58       	lddpc	r8,80003ec8 <phy_rx_func+0xec4>
80003cf8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003cfa:	30 19       	mov	r9,1
80003cfc:	fe f8 02 0c 	ld.w	r8,pc[524]
80003d00:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003d02:	8e 79       	ld.sh	r9,r7[0xe]
80003d04:	fe f8 02 14 	ld.w	r8,pc[532]
80003d08:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003d0a:	4f 68       	lddpc	r8,80003ee0 <phy_rx_func+0xedc>
80003d0c:	4e c9       	lddpc	r9,80003ebc <phy_rx_func+0xeb8>
80003d0e:	72 0a       	ld.w	r10,r9[0x0]
80003d10:	70 09       	ld.w	r9,r8[0x0]
80003d12:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d16:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d1a:	70 09       	ld.w	r9,r8[0x0]
80003d1c:	2f f9       	sub	r9,-1
80003d1e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d20:	e0 49 01 ff 	cp.w	r9,511
80003d24:	e0 88 00 13 	brls	80003d4a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d28:	30 09       	mov	r9,0
80003d2a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d2c:	4e 46       	lddpc	r6,80003ebc <phy_rx_func+0xeb8>
80003d2e:	6c 0c       	ld.w	r12,r6[0x0]
80003d30:	f0 1f 00 6e 	mcall	80003ee8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d34:	4e 08       	lddpc	r8,80003eb4 <phy_rx_func+0xeb0>
80003d36:	70 0c       	ld.w	r12,r8[0x0]
80003d38:	f0 1f 00 59 	mcall	80003e9c <phy_rx_func+0xe98>
80003d3c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d3e:	c0 61       	brne	80003d4a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003d40:	30 09       	mov	r9,0
80003d42:	4e 08       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d44:	91 09       	st.w	r8[0x0],r9
80003d46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d4a:	4e 09       	lddpc	r9,80003ec8 <phy_rx_func+0xec4>
80003d4c:	72 08       	ld.w	r8,r9[0x0]
80003d4e:	20 18       	sub	r8,1
80003d50:	93 08       	st.w	r9[0x0],r8
80003d52:	c0 61       	brne	80003d5e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003d54:	30 09       	mov	r9,0
80003d56:	4d b8       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d58:	91 09       	st.w	r8[0x0],r9
80003d5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003d5e:	4e 18       	lddpc	r8,80003ee0 <phy_rx_func+0xedc>
80003d60:	4d 79       	lddpc	r9,80003ebc <phy_rx_func+0xeb8>
80003d62:	72 0a       	ld.w	r10,r9[0x0]
80003d64:	70 09       	ld.w	r9,r8[0x0]
80003d66:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d6a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d6e:	70 09       	ld.w	r9,r8[0x0]
80003d70:	2f f9       	sub	r9,-1
80003d72:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d74:	e0 49 01 ff 	cp.w	r9,511
80003d78:	e0 88 00 13 	brls	80003d9e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d7c:	30 09       	mov	r9,0
80003d7e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d80:	4c f7       	lddpc	r7,80003ebc <phy_rx_func+0xeb8>
80003d82:	6e 0c       	ld.w	r12,r7[0x0]
80003d84:	f0 1f 00 59 	mcall	80003ee8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d88:	4c b8       	lddpc	r8,80003eb4 <phy_rx_func+0xeb0>
80003d8a:	70 0c       	ld.w	r12,r8[0x0]
80003d8c:	f0 1f 00 44 	mcall	80003e9c <phy_rx_func+0xe98>
80003d90:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d92:	c0 61       	brne	80003d9e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003d94:	30 09       	mov	r9,0
80003d96:	4c b8       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d98:	91 09       	st.w	r8[0x0],r9
80003d9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d9e:	4c b9       	lddpc	r9,80003ec8 <phy_rx_func+0xec4>
80003da0:	72 08       	ld.w	r8,r9[0x0]
80003da2:	20 18       	sub	r8,1
80003da4:	93 08       	st.w	r9[0x0],r8
80003da6:	c6 c1       	brne	80003e7e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003da8:	30 09       	mov	r9,0
80003daa:	4c 68       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003dac:	91 09       	st.w	r8[0x0],r9
80003dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003db2:	30 09       	mov	r9,0
80003db4:	4c 38       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003db6:	91 09       	st.w	r8[0x0],r9
80003db8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003dbc:	8e 4a       	ld.sh	r10,r7[0x8]
80003dbe:	4d 99       	lddpc	r9,80003f20 <phy_rx_func+0xf1c>
80003dc0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003dc4:	4d 6a       	lddpc	r10,80003f1c <phy_rx_func+0xf18>
80003dc6:	15 88       	ld.ub	r8,r10[0x0]
80003dc8:	f0 cb ff ff 	sub	r11,r8,-1
80003dcc:	8e 5c       	ld.sh	r12,r7[0xa]
80003dce:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003dd2:	f0 cb ff fe 	sub	r11,r8,-2
80003dd6:	8e 6c       	ld.sh	r12,r7[0xc]
80003dd8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ddc:	f0 cb ff fd 	sub	r11,r8,-3
80003de0:	8e 7c       	ld.sh	r12,r7[0xe]
80003de2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003de6:	2f c8       	sub	r8,-4
80003de8:	b4 88       	st.b	r10[0x0],r8
80003dea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003dee:	30 09       	mov	r9,0
80003df0:	4b 48       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003df2:	91 09       	st.w	r8[0x0],r9
80003df4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003df8:	4c 08       	lddpc	r8,80003ef8 <phy_rx_func+0xef4>
80003dfa:	70 09       	ld.w	r9,r8[0x0]
80003dfc:	8e 4b       	ld.sh	r11,r7[0x8]
80003dfe:	4c 0a       	lddpc	r10,80003efc <phy_rx_func+0xef8>
80003e00:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003e04:	2f f9       	sub	r9,-1
80003e06:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e08:	4b 58       	lddpc	r8,80003edc <phy_rx_func+0xed8>
80003e0a:	70 09       	ld.w	r9,r8[0x0]
80003e0c:	20 29       	sub	r9,2
80003e0e:	91 09       	st.w	r8[0x0],r9
80003e10:	70 08       	ld.w	r8,r8[0x0]
80003e12:	58 08       	cp.w	r8,0
80003e14:	c2 f1       	brne	80003e72 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003e16:	30 09       	mov	r9,0
80003e18:	4b 88       	lddpc	r8,80003ef8 <phy_rx_func+0xef4>
80003e1a:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e1c:	8e 59       	ld.sh	r9,r7[0xa]
80003e1e:	fe 78 82 12 	mov	r8,-32238
80003e22:	f0 09 19 00 	cp.h	r9,r8
80003e26:	c2 11       	brne	80003e68 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003e28:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e2c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003e30:	4a f8       	lddpc	r8,80003eec <phy_rx_func+0xee8>
80003e32:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e34:	8e 59       	ld.sh	r9,r7[0xa]
80003e36:	4a f8       	lddpc	r8,80003ef0 <phy_rx_func+0xeec>
80003e38:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e3a:	8e 69       	ld.sh	r9,r7[0xc]
80003e3c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e3e:	f0 1f 00 2e 	mcall	80003ef4 <phy_rx_func+0xef0>
80003e42:	4a 18       	lddpc	r8,80003ec4 <phy_rx_func+0xec0>
80003e44:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e46:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003e4a:	31 38       	mov	r8,19
80003e4c:	f0 09 18 00 	cp.b	r9,r8
80003e50:	c0 71       	brne	80003e5e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003e52:	10 99       	mov	r9,r8
80003e54:	4a 18       	lddpc	r8,80003ed8 <phy_rx_func+0xed4>
80003e56:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003e58:	30 09       	mov	r9,0
80003e5a:	49 c8       	lddpc	r8,80003ec8 <phy_rx_func+0xec4>
80003e5c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003e5e:	30 49       	mov	r9,4
80003e60:	49 88       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e62:	91 09       	st.w	r8[0x0],r9
80003e64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003e68:	30 09       	mov	r9,0
80003e6a:	49 68       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e6c:	91 09       	st.w	r8[0x0],r9
80003e6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003e72:	4a dc       	lddpc	r12,80003f24 <phy_rx_func+0xf20>
80003e74:	f0 1f 00 18 	mcall	80003ed4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003e78:	30 09       	mov	r9,0
80003e7a:	49 28       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e7c:	91 09       	st.w	r8[0x0],r9
80003e7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e82:	00 00       	add	r0,r0
80003e84:	00 00       	add	r0,r0
80003e86:	0a a8       	st.w	r5++,r8
80003e88:	00 00       	add	r0,r0
80003e8a:	0a b4       	st.h	r5++,r4
80003e8c:	00 00       	add	r0,r0
80003e8e:	0a 98       	mov	r8,r5
80003e90:	00 00       	add	r0,r0
80003e92:	0a 70       	tst	r0,r5
80003e94:	00 00       	add	r0,r0
80003e96:	0a 60       	and	r0,r5
80003e98:	00 00       	add	r0,r0
80003e9a:	0a 8c       	andn	r12,r5
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	2a 64       	sub	r4,-90
80003ea0:	00 00       	add	r0,r0
80003ea2:	0a b8       	st.h	r5++,r8
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	29 94       	sub	r4,-103
80003ea8:	00 00       	add	r0,r0
80003eaa:	0a a0       	st.w	r5++,r0
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	29 b0       	sub	r0,-101
80003eb0:	00 00       	add	r0,r0
80003eb2:	0a 7d       	tst	sp,r5
80003eb4:	00 00       	add	r0,r0
80003eb6:	0a 94       	mov	r4,r5
80003eb8:	00 00       	add	r0,r0
80003eba:	0a ac       	st.w	r5++,r12
80003ebc:	00 00       	add	r0,r0
80003ebe:	0a c8       	st.b	r5++,r8
80003ec0:	00 00       	add	r0,r0
80003ec2:	0a 88       	andn	r8,r5
80003ec4:	00 00       	add	r0,r0
80003ec6:	0a c0       	st.b	r5++,r0
80003ec8:	00 00       	add	r0,r0
80003eca:	0a 6c       	and	r12,r5
80003ecc:	00 00       	add	r0,r0
80003ece:	0a 43       	or	r3,r5
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	c7 2c       	rcall	80003fb6 <local_start_SSC+0x1a>
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	62 14       	ld.w	r4,r1[0x4]
80003ed8:	00 00       	add	r0,r0
80003eda:	0a 7c       	tst	r12,r5
80003edc:	00 00       	add	r0,r0
80003ede:	0a 5c       	eor	r12,r5
80003ee0:	00 00       	add	r0,r0
80003ee2:	0a 74       	tst	r4,r5
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	6a 64       	ld.w	r4,r5[0x18]
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	2f a4       	sub	r4,-6
80003eec:	00 00       	add	r0,r0
80003eee:	0a 46       	or	r6,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	0e 90       	mov	r0,r7
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	28 f4       	sub	r4,-113
80003ef8:	00 00       	add	r0,r0
80003efa:	0a a4       	st.w	r5++,r4
80003efc:	00 00       	add	r0,r0
80003efe:	0d 94       	ld.ub	r4,r6[0x1]
80003f00:	00 00       	add	r0,r0
80003f02:	0a 80       	andn	r0,r5
80003f04:	00 00       	add	r0,r0
80003f06:	0a 39       	cp.w	r9,r5
80003f08:	00 00       	add	r0,r0
80003f0a:	0a 41       	or	r1,r5
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a 54       	eor	r4,r5
80003f10:	00 00       	add	r0,r0
80003f12:	0a 90       	mov	r0,r5
80003f14:	00 00       	add	r0,r0
80003f16:	0a 47       	or	r7,r5
80003f18:	00 00       	add	r0,r0
80003f1a:	0d 8c       	ld.ub	r12,r6[0x0]
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a b0       	st.h	r5++,r0
80003f20:	00 00       	add	r0,r0
80003f22:	0e 94       	mov	r4,r7
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	c7 44       	brge	8000400e <local_start_PDC+0x2e>

80003f28 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f28:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f2a:	49 88       	lddpc	r8,80003f88 <pdca_int_handler+0x60>
80003f2c:	11 89       	ld.ub	r9,r8[0x0]
80003f2e:	ec 19 00 01 	eorl	r9,0x1
80003f32:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f34:	11 89       	ld.ub	r9,r8[0x0]
80003f36:	a5 69       	lsl	r9,0x4
80003f38:	2f c9       	sub	r9,-4
80003f3a:	49 5a       	lddpc	r10,80003f8c <pdca_int_handler+0x64>
80003f3c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f3e:	fe 7a 00 40 	mov	r10,-65472
80003f42:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f44:	30 39       	mov	r9,3
80003f46:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003f48:	11 8a       	ld.ub	r10,r8[0x0]
80003f4a:	a5 6a       	lsl	r10,0x4
80003f4c:	2f ca       	sub	r10,-4
80003f4e:	49 18       	lddpc	r8,80003f90 <pdca_int_handler+0x68>
80003f50:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003f52:	fe 78 00 00 	mov	r8,-65536
80003f56:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003f58:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003f5a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003f5c:	48 e8       	lddpc	r8,80003f94 <pdca_int_handler+0x6c>
80003f5e:	70 08       	ld.w	r8,r8[0x0]
80003f60:	58 08       	cp.w	r8,0
80003f62:	c0 70       	breq	80003f70 <pdca_int_handler+0x48>
80003f64:	48 99       	lddpc	r9,80003f88 <pdca_int_handler+0x60>
80003f66:	13 89       	ld.ub	r9,r9[0x0]
80003f68:	a5 69       	lsl	r9,0x4
80003f6a:	48 ac       	lddpc	r12,80003f90 <pdca_int_handler+0x68>
80003f6c:	12 0c       	add	r12,r9
80003f6e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003f70:	48 a8       	lddpc	r8,80003f98 <pdca_int_handler+0x70>
80003f72:	70 08       	ld.w	r8,r8[0x0]
80003f74:	58 08       	cp.w	r8,0
80003f76:	c0 70       	breq	80003f84 <pdca_int_handler+0x5c>
80003f78:	48 49       	lddpc	r9,80003f88 <pdca_int_handler+0x60>
80003f7a:	13 89       	ld.ub	r9,r9[0x0]
80003f7c:	a5 69       	lsl	r9,0x4
80003f7e:	48 4c       	lddpc	r12,80003f8c <pdca_int_handler+0x64>
80003f80:	12 0c       	add	r12,r9
80003f82:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003f84:	d4 02       	popm	lr
80003f86:	d6 03       	rete
80003f88:	00 00       	add	r0,r0
80003f8a:	40 b4       	lddsp	r4,sp[0x2c]
80003f8c:	00 00       	add	r0,r0
80003f8e:	40 dc       	lddsp	r12,sp[0x34]
80003f90:	00 00       	add	r0,r0
80003f92:	40 bc       	lddsp	r12,sp[0x2c]
80003f94:	00 00       	add	r0,r0
80003f96:	0a d4       	st.w	--r5,r4
80003f98:	00 00       	add	r0,r0
80003f9a:	0a d8       	st.w	--r5,r8

80003f9c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003f9c:	fe 78 10 00 	mov	r8,-61440
80003fa0:	e0 69 0d c0 	mov	r9,3520
80003fa4:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003fa8:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003fac:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003fb0:	fe 78 34 00 	mov	r8,-52224
80003fb4:	e0 69 80 00 	mov	r9,32768
80003fb8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003fba:	30 09       	mov	r9,0
80003fbc:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003fbe:	e0 69 04 21 	mov	r9,1057
80003fc2:	ea 19 3f 20 	orh	r9,0x3f20
80003fc6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003fc8:	e0 69 02 9f 	mov	r9,671
80003fcc:	ea 19 01 00 	orh	r9,0x100
80003fd0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003fd2:	e0 6a 04 02 	mov	r10,1026
80003fd6:	ea 1a 3f 20 	orh	r10,0x3f20
80003fda:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003fdc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003fde:	5e fc       	retal	r12

80003fe0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003fe0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003fe2:	30 19       	mov	r9,1
80003fe4:	49 78       	lddpc	r8,80004040 <local_start_PDC+0x60>
80003fe6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003fe8:	fe 78 00 00 	mov	r8,-65536
80003fec:	30 7b       	mov	r11,7
80003fee:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003ff0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003ff2:	49 59       	lddpc	r9,80004044 <local_start_PDC+0x64>
80003ff4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ff8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003ffa:	30 3a       	mov	r10,3
80003ffc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003ffe:	30 1c       	mov	r12,1
80004000:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004002:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004004:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004006:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004008:	30 2c       	mov	r12,2
8000400a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
8000400c:	48 f9       	lddpc	r9,80004048 <local_start_PDC+0x68>
8000400e:	e0 68 5a 5a 	mov	r8,23130
80004012:	ea 18 ab cd 	orh	r8,0xabcd
80004016:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004018:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000401a:	30 0e       	mov	lr,0
8000401c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000401e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004020:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004022:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004024:	fe 78 00 40 	mov	r8,-65472
80004028:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000402a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000402c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004030:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004032:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004034:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004036:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004038:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000403a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000403c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000403e:	d8 02       	popm	pc
80004040:	00 00       	add	r0,r0
80004042:	40 b4       	lddsp	r4,sp[0x2c]
80004044:	00 00       	add	r0,r0
80004046:	40 bc       	lddsp	r12,sp[0x2c]
80004048:	00 00       	add	r0,r0
8000404a:	40 dc       	lddsp	r12,sp[0x34]

8000404c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000404c:	48 38       	lddpc	r8,80004058 <register_rx_tx_func+0xc>
8000404e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004050:	48 38       	lddpc	r8,8000405c <register_rx_tx_func+0x10>
80004052:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004054:	5e fc       	retal	r12
80004056:	00 00       	add	r0,r0
80004058:	00 00       	add	r0,r0
8000405a:	0a d4       	st.w	--r5,r4
8000405c:	00 00       	add	r0,r0
8000405e:	0a d8       	st.w	--r5,r8

80004060 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004060:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004062:	fe 78 10 00 	mov	r8,-61440
80004066:	30 29       	mov	r9,2
80004068:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000406c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004070:	10 99       	mov	r9,r8
80004072:	f2 f8 01 60 	ld.w	r8,r9[352]
80004076:	e2 18 00 02 	andl	r8,0x2,COH
8000407a:	cf c0       	breq	80004072 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000407c:	fe 79 10 00 	mov	r9,-61440
80004080:	f2 f8 01 60 	ld.w	r8,r9[352]
80004084:	e2 18 00 02 	andl	r8,0x2,COH
80004088:	cf c1       	brne	80004080 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000408a:	30 3a       	mov	r10,3
8000408c:	36 0b       	mov	r11,96
8000408e:	48 bc       	lddpc	r12,800040b8 <ssc_init+0x58>
80004090:	f0 1f 00 0b 	mcall	800040bc <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004094:	f0 1f 00 0b 	mcall	800040c0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004098:	f0 1f 00 0b 	mcall	800040c4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000409c:	fe 79 00 00 	mov	r9,-65536
800040a0:	30 18       	mov	r8,1
800040a2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800040a4:	fe 7a 00 40 	mov	r10,-65472
800040a8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800040aa:	e0 6b 01 01 	mov	r11,257
800040ae:	fe 7a 34 00 	mov	r10,-52224
800040b2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800040b4:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800040b6:	d8 02       	popm	pc
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	3f 28       	mov	r8,-14
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	4a b8       	lddpc	r8,80004168 <xcmp_opcode_not_supported+0xc>
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	3f 9c       	mov	r12,-7
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	3f e0       	mov	r0,-2

800040c8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800040c8:	48 28       	lddpc	r8,800040d0 <xcmp_register_app_list+0x8>
800040ca:	91 0c       	st.w	r8[0x0],r12
}
800040cc:	5e fc       	retal	r12
800040ce:	00 00       	add	r0,r0
800040d0:	00 00       	add	r0,r0
800040d2:	40 fc       	lddsp	r12,sp[0x3c]

800040d4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800040d4:	eb cd 40 80 	pushm	r7,lr
800040d8:	fa cd 01 00 	sub	sp,sp,256
800040dc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800040de:	16 98       	mov	r8,r11
800040e0:	2f 08       	sub	r8,-16
800040e2:	af a8       	sbr	r8,0xe
800040e4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800040e6:	3f f8       	mov	r8,-1
800040e8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800040ea:	30 b9       	mov	r9,11
800040ec:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800040ee:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800040f0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800040f2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040f4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800040f6:	f6 ca ff fe 	sub	r10,r11,-2
800040fa:	18 9b       	mov	r11,r12
800040fc:	fa cc ff f0 	sub	r12,sp,-16
80004100:	f0 1f 00 05 	mcall	80004114 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004104:	2f e7       	sub	r7,-2
80004106:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004108:	1a 9c       	mov	r12,sp
8000410a:	f0 1f 00 04 	mcall	80004118 <xcmp_tx+0x44>
}
8000410e:	2c 0d       	sub	sp,-256
80004110:	e3 cd 80 80 	ldm	sp++,r7,pc
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	69 1c       	ld.w	r12,r4[0x44]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	46 54       	lddsp	r4,sp[0x194]

8000411c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000411c:	d4 01       	pushm	lr
8000411e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004122:	fe 78 b4 00 	mov	r8,-19456
80004126:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004128:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000412c:	30 89       	mov	r9,8
8000412e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004130:	30 19       	mov	r9,1
80004132:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004134:	30 09       	mov	r9,0
80004136:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004138:	30 5a       	mov	r10,5
8000413a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000413c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000413e:	30 7a       	mov	r10,7
80004140:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004142:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004144:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004146:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000414a:	30 9b       	mov	r11,9
8000414c:	fa cc ff fe 	sub	r12,sp,-2
80004150:	f0 1f 00 02 	mcall	80004158 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004154:	2c dd       	sub	sp,-204
80004156:	d8 02       	popm	pc
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	40 d4       	lddsp	r4,sp[0x34]

8000415c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000415c:	d4 01       	pushm	lr
8000415e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004162:	fe 78 80 00 	mov	r8,-32768
80004166:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004168:	30 38       	mov	r8,3
8000416a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000416c:	30 1b       	mov	r11,1
8000416e:	fa cc ff fe 	sub	r12,sp,-2
80004172:	f0 1f 00 03 	mcall	8000417c <xcmp_opcode_not_supported+0x20>
}
80004176:	2c dd       	sub	sp,-204
80004178:	d8 02       	popm	pc
8000417a:	00 00       	add	r0,r0
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	40 d4       	lddsp	r4,sp[0x34]

80004180 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004180:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004182:	96 88       	ld.uh	r8,r11[0x0]
80004184:	e2 18 f0 00 	andl	r8,0xf000,COH
80004188:	e0 48 80 00 	cp.w	r8,32768
8000418c:	c0 f0       	breq	800041aa <xcmp_exec_func+0x2a>
8000418e:	e0 48 b0 00 	cp.w	r8,45056
80004192:	c1 20       	breq	800041b6 <xcmp_exec_func+0x36>
80004194:	58 08       	cp.w	r8,0
80004196:	c1 51       	brne	800041c0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004198:	78 08       	ld.w	r8,r12[0x0]
8000419a:	58 08       	cp.w	r8,0
8000419c:	c0 40       	breq	800041a4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000419e:	16 9c       	mov	r12,r11
800041a0:	5d 18       	icall	r8
800041a2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800041a4:	f0 1f 00 08 	mcall	800041c4 <xcmp_exec_func+0x44>
800041a8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800041aa:	78 18       	ld.w	r8,r12[0x4]
800041ac:	58 08       	cp.w	r8,0
800041ae:	c0 90       	breq	800041c0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800041b0:	16 9c       	mov	r12,r11
800041b2:	5d 18       	icall	r8
800041b4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800041b6:	78 28       	ld.w	r8,r12[0x8]
800041b8:	58 08       	cp.w	r8,0
800041ba:	c0 30       	breq	800041c0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800041bc:	16 9c       	mov	r12,r11
800041be:	5d 18       	icall	r8
800041c0:	d8 02       	popm	pc
800041c2:	00 00       	add	r0,r0
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	41 5c       	lddsp	r12,sp[0x54]

800041c8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
800041c8:	d4 01       	pushm	lr
800041ca:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800041ce:	e0 68 04 09 	mov	r8,1033
800041d2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800041d4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800041d8:	30 19       	mov	r9,1
800041da:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
800041dc:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
800041e0:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
800041e2:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800041e4:	30 09       	mov	r9,0
800041e6:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800041e8:	fb 69 00 08 	st.b	sp[8],r9
800041ec:	fa c8 ff f7 	sub	r8,sp,-9
800041f0:	b0 89       	st.b	r8[0x0],r9
800041f2:	fa c8 ff f6 	sub	r8,sp,-10
800041f6:	b0 89       	st.b	r8[0x0],r9
800041f8:	fa c8 ff f5 	sub	r8,sp,-11
800041fc:	b0 89       	st.b	r8[0x0],r9
800041fe:	fa c8 ff f4 	sub	r8,sp,-12
80004202:	b0 89       	st.b	r8[0x0],r9
80004204:	fa c8 ff f3 	sub	r8,sp,-13
80004208:	b0 89       	st.b	r8[0x0],r9
8000420a:	fa c8 ff f2 	sub	r8,sp,-14
8000420e:	b0 89       	st.b	r8[0x0],r9
80004210:	fa c8 ff f1 	sub	r8,sp,-15
80004214:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004216:	30 cb       	mov	r11,12
80004218:	fa cc ff fe 	sub	r12,sp,-2
8000421c:	f0 1f 00 02 	mcall	80004224 <xcmp_IdleTestTone+0x5c>
}
80004220:	2c dd       	sub	sp,-204
80004222:	d8 02       	popm	pc
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	40 d4       	lddsp	r4,sp[0x34]

80004228 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004228:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000422a:	48 dc       	lddpc	r12,8000425c <xcmp_init+0x34>
8000422c:	f0 1f 00 0d 	mcall	80004260 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004230:	30 4b       	mov	r11,4
80004232:	31 4c       	mov	r12,20
80004234:	f0 1f 00 0c 	mcall	80004264 <xcmp_init+0x3c>
80004238:	48 c8       	lddpc	r8,80004268 <xcmp_init+0x40>
8000423a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000423c:	30 09       	mov	r9,0
8000423e:	1a d9       	st.w	--sp,r9
80004240:	1a d9       	st.w	--sp,r9
80004242:	1a d9       	st.w	--sp,r9
80004244:	30 38       	mov	r8,3
80004246:	e0 6a 01 80 	mov	r10,384
8000424a:	48 9b       	lddpc	r11,8000426c <xcmp_init+0x44>
8000424c:	48 9c       	lddpc	r12,80004270 <xcmp_init+0x48>
8000424e:	f0 1f 00 0a 	mcall	80004274 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004252:	f0 1f 00 0a 	mcall	80004278 <xcmp_init+0x50>
80004256:	2f dd       	sub	sp,-12
	
}
80004258:	d8 02       	popm	pc
8000425a:	00 00       	add	r0,r0
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	43 78       	lddsp	r8,sp[0xdc]
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	43 c4       	lddsp	r4,sp[0xf0]
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	55 f0       	stdsp	sp[0x17c],r0
80004268:	00 00       	add	r0,r0
8000426a:	0a f4       	st.b	--r5,r4
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	c7 70       	breq	8000435c <xcmp_rx_process+0xe0>
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	42 7c       	lddsp	r12,sp[0x9c]
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	5c c4       	swap.bh	r4
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	43 fc       	lddsp	r12,sp[0xfc]

8000427c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000427c:	d4 31       	pushm	r0-r7,lr
8000427e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004280:	4b 16       	lddpc	r6,80004344 <xcmp_rx_process+0xc8>
80004282:	30 05       	mov	r5,0
80004284:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004286:	4b 13       	lddpc	r3,80004348 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004288:	4b 12       	lddpc	r2,8000434c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000428a:	4b 21       	lddpc	r1,80004350 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000428c:	4b 20       	lddpc	r0,80004354 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000428e:	6c 0c       	ld.w	r12,r6[0x0]
80004290:	0a 99       	mov	r9,r5
80004292:	08 9a       	mov	r10,r4
80004294:	1a 9b       	mov	r11,sp
80004296:	f0 1f 00 31 	mcall	80004358 <xcmp_rx_process+0xdc>
8000429a:	58 1c       	cp.w	r12,1
8000429c:	cf 91       	brne	8000428e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000429e:	40 0b       	lddsp	r11,sp[0x0]
800042a0:	58 0b       	cp.w	r11,0
800042a2:	cf 60       	breq	8000428e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800042a4:	96 0a       	ld.sh	r10,r11[0x0]
800042a6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800042aa:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800042ae:	59 c8       	cp.w	r8,28
800042b0:	c1 e0       	breq	800042ec <xcmp_rx_process+0x70>
800042b2:	e0 89 00 07 	brgt	800042c0 <xcmp_rx_process+0x44>
800042b6:	58 e8       	cp.w	r8,14
800042b8:	c0 e0       	breq	800042d4 <xcmp_rx_process+0x58>
800042ba:	58 f8       	cp.w	r8,15
800042bc:	c2 41       	brne	80004304 <xcmp_rx_process+0x88>
800042be:	c0 f8       	rjmp	800042dc <xcmp_rx_process+0x60>
800042c0:	e0 48 01 09 	cp.w	r8,265
800042c4:	c1 80       	breq	800042f4 <xcmp_rx_process+0x78>
800042c6:	e0 48 01 0a 	cp.w	r8,266
800042ca:	c1 90       	breq	800042fc <xcmp_rx_process+0x80>
800042cc:	e0 48 00 2c 	cp.w	r8,44
800042d0:	c1 a1       	brne	80004304 <xcmp_rx_process+0x88>
800042d2:	c0 98       	rjmp	800042e4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800042d4:	4a 2c       	lddpc	r12,8000435c <xcmp_rx_process+0xe0>
800042d6:	f0 1f 00 23 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042da:	c2 f8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800042dc:	4a 2c       	lddpc	r12,80004364 <xcmp_rx_process+0xe8>
800042de:	f0 1f 00 21 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042e2:	c2 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800042e4:	4a 1c       	lddpc	r12,80004368 <xcmp_rx_process+0xec>
800042e6:	f0 1f 00 1f 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042ea:	c2 78       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800042ec:	04 9c       	mov	r12,r2
800042ee:	f0 1f 00 1d 	mcall	80004360 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800042f2:	c2 38       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800042f4:	02 9c       	mov	r12,r1
800042f6:	f0 1f 00 1b 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042fa:	c1 f8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800042fc:	00 9c       	mov	r12,r0
800042fe:	f0 1f 00 19 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
80004302:	c1 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004304:	12 98       	mov	r8,r9
80004306:	e2 18 04 00 	andl	r8,0x400,COH
8000430a:	c0 70       	breq	80004318 <xcmp_rx_process+0x9c>
8000430c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004310:	e0 48 00 68 	cp.w	r8,104
80004314:	e0 8a 00 08 	brle	80004324 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004318:	e2 19 f0 00 	andl	r9,0xf000,COH
8000431c:	c0 e1       	brne	80004338 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000431e:	f0 1f 00 14 	mcall	8000436c <xcmp_rx_process+0xf0>
80004322:	c0 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004324:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004328:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000432c:	49 19       	lddpc	r9,80004370 <xcmp_rx_process+0xf4>
8000432e:	72 08       	ld.w	r8,r9[0x0]
80004330:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004334:	f0 1f 00 0b 	mcall	80004360 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004338:	66 0c       	ld.w	r12,r3[0x0]
8000433a:	40 0b       	lddsp	r11,sp[0x0]
8000433c:	f0 1f 00 0e 	mcall	80004374 <xcmp_rx_process+0xf8>
80004340:	ca 7b       	rjmp	8000428e <xcmp_rx_process+0x12>
80004342:	00 00       	add	r0,r0
80004344:	00 00       	add	r0,r0
80004346:	0a f4       	st.b	--r5,r4
80004348:	00 00       	add	r0,r0
8000434a:	0a 8c       	andn	r12,r5
8000434c:	00 00       	add	r0,r0
8000434e:	0b 04       	ld.w	r4,r5++
80004350:	00 00       	add	r0,r0
80004352:	0a f8       	st.b	--r5,r8
80004354:	00 00       	add	r0,r0
80004356:	0a e8       	st.h	--r5,r8
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	52 e4       	stdsp	sp[0xb8],r4
8000435c:	00 00       	add	r0,r0
8000435e:	0b 1c       	ld.sh	r12,r5++
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	41 80       	lddsp	r0,sp[0x60]
80004364:	00 00       	add	r0,r0
80004366:	0a dc       	st.w	--r5,r12
80004368:	00 00       	add	r0,r0
8000436a:	0b 10       	ld.sh	r0,r5++
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	41 5c       	lddsp	r12,sp[0x54]
80004370:	00 00       	add	r0,r0
80004372:	40 fc       	lddsp	r12,sp[0x3c]
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	29 e8       	sub	r8,-98

80004378 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004378:	eb cd 40 90 	pushm	r4,r7,lr
8000437c:	20 1d       	sub	sp,4
8000437e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004382:	48 c8       	lddpc	r8,800043b0 <xcmp_rx+0x38>
80004384:	70 0c       	ld.w	r12,r8[0x0]
80004386:	f0 1f 00 0c 	mcall	800043b4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000438a:	c1 00       	breq	800043aa <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000438c:	fa c7 ff fc 	sub	r7,sp,-4
80004390:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004392:	e0 6a 00 ca 	mov	r10,202
80004396:	08 9b       	mov	r11,r4
80004398:	f0 1f 00 08 	mcall	800043b8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000439c:	48 88       	lddpc	r8,800043bc <xcmp_rx+0x44>
8000439e:	70 0c       	ld.w	r12,r8[0x0]
800043a0:	30 09       	mov	r9,0
800043a2:	12 9a       	mov	r10,r9
800043a4:	1a 9b       	mov	r11,sp
800043a6:	f0 1f 00 07 	mcall	800043c0 <xcmp_rx+0x48>
	}	
}
800043aa:	2f fd       	sub	sp,-4
800043ac:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800043b0:	00 00       	add	r0,r0
800043b2:	0a 8c       	andn	r12,r5
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	2f 54       	sub	r4,-11
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	69 1c       	ld.w	r12,r4[0x44]
800043bc:	00 00       	add	r0,r0
800043be:	0a f4       	st.b	--r5,r4
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	54 f0       	stdsp	sp[0x13c],r0

800043c4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800043c4:	48 28       	lddpc	r8,800043cc <xnl_register_xcmp_func+0x8>
800043c6:	91 0c       	st.w	r8[0x0],r12
}
800043c8:	5e fc       	retal	r12
800043ca:	00 00       	add	r0,r0
800043cc:	00 00       	add	r0,r0
800043ce:	0b 4c       	ld.w	r12,--r5

800043d0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800043d0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800043d2:	48 88       	lddpc	r8,800043f0 <xnl_get_msg_ack_func+0x20>
800043d4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800043d6:	98 49       	ld.sh	r9,r12[0x8]
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 81       	brne	800043ec <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800043de:	48 68       	lddpc	r8,800043f4 <xnl_get_msg_ack_func+0x24>
800043e0:	70 0c       	ld.w	r12,r8[0x0]
800043e2:	30 09       	mov	r9,0
800043e4:	12 9a       	mov	r10,r9
800043e6:	12 9b       	mov	r11,r9
800043e8:	f0 1f 00 04 	mcall	800043f8 <xnl_get_msg_ack_func+0x28>
800043ec:	d8 02       	popm	pc
800043ee:	00 00       	add	r0,r0
800043f0:	00 00       	add	r0,r0
800043f2:	0b 2c       	ld.uh	r12,r5++
800043f4:	00 00       	add	r0,r0
800043f6:	0b 28       	ld.uh	r8,r5++
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	54 f0       	stdsp	sp[0x13c],r0

800043fc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800043fc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004400:	30 09       	mov	r9,0
80004402:	4b 78       	lddpc	r8,800044dc <xnl_init+0xe0>
80004404:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004406:	30 0b       	mov	r11,0
80004408:	30 1c       	mov	r12,1
8000440a:	f0 1f 00 36 	mcall	800044e0 <xnl_init+0xe4>
8000440e:	4b 68       	lddpc	r8,800044e4 <xnl_init+0xe8>
80004410:	91 0c       	st.w	r8[0x0],r12
80004412:	70 08       	ld.w	r8,r8[0x0]
80004414:	58 08       	cp.w	r8,0
80004416:	c0 80       	breq	80004426 <xnl_init+0x2a>
80004418:	4b 38       	lddpc	r8,800044e4 <xnl_init+0xe8>
8000441a:	70 0c       	ld.w	r12,r8[0x0]
8000441c:	30 09       	mov	r9,0
8000441e:	12 9a       	mov	r10,r9
80004420:	12 9b       	mov	r11,r9
80004422:	f0 1f 00 32 	mcall	800044e8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004426:	30 4b       	mov	r11,4
80004428:	31 4c       	mov	r12,20
8000442a:	f0 1f 00 2e 	mcall	800044e0 <xnl_init+0xe4>
8000442e:	4b 08       	lddpc	r8,800044ec <xnl_init+0xf0>
80004430:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004432:	30 4b       	mov	r11,4
80004434:	31 ec       	mov	r12,30
80004436:	f0 1f 00 2b 	mcall	800044e0 <xnl_init+0xe4>
8000443a:	4a e8       	lddpc	r8,800044f0 <xnl_init+0xf4>
8000443c:	91 0c       	st.w	r8[0x0],r12
8000443e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004440:	10 96       	mov	r6,r8
80004442:	4a d5       	lddpc	r5,800044f4 <xnl_init+0xf8>
80004444:	6c 0c       	ld.w	r12,r6[0x0]
80004446:	ea 07 00 0b 	add	r11,r5,r7
8000444a:	f0 1f 00 2c 	mcall	800044f8 <xnl_init+0xfc>
8000444e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004452:	e0 47 1e 00 	cp.w	r7,7680
80004456:	cf 71       	brne	80004444 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004458:	30 4b       	mov	r11,4
8000445a:	31 4c       	mov	r12,20
8000445c:	f0 1f 00 21 	mcall	800044e0 <xnl_init+0xe4>
80004460:	4a 78       	lddpc	r8,800044fc <xnl_init+0x100>
80004462:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004464:	30 4b       	mov	r11,4
80004466:	30 ac       	mov	r12,10
80004468:	f0 1f 00 1e 	mcall	800044e0 <xnl_init+0xe4>
8000446c:	4a 58       	lddpc	r8,80004500 <xnl_init+0x104>
8000446e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004470:	30 4b       	mov	r11,4
80004472:	30 ac       	mov	r12,10
80004474:	f0 1f 00 1b 	mcall	800044e0 <xnl_init+0xe4>
80004478:	4a 38       	lddpc	r8,80004504 <xnl_init+0x108>
8000447a:	91 0c       	st.w	r8[0x0],r12
8000447c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000447e:	10 96       	mov	r6,r8
80004480:	4a 25       	lddpc	r5,80004508 <xnl_init+0x10c>
80004482:	6c 0c       	ld.w	r12,r6[0x0]
80004484:	ea 07 00 0b 	add	r11,r5,r7
80004488:	f0 1f 00 1c 	mcall	800044f8 <xnl_init+0xfc>
8000448c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004490:	e0 47 14 00 	cp.w	r7,5120
80004494:	cf 71       	brne	80004482 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004496:	30 4b       	mov	r11,4
80004498:	30 5c       	mov	r12,5
8000449a:	f0 1f 00 12 	mcall	800044e0 <xnl_init+0xe4>
8000449e:	49 c8       	lddpc	r8,8000450c <xnl_init+0x110>
800044a0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800044a2:	30 07       	mov	r7,0
800044a4:	1a d7       	st.w	--sp,r7
800044a6:	1a d7       	st.w	--sp,r7
800044a8:	1a d7       	st.w	--sp,r7
800044aa:	30 38       	mov	r8,3
800044ac:	0e 99       	mov	r9,r7
800044ae:	e0 6a 02 00 	mov	r10,512
800044b2:	49 8b       	lddpc	r11,80004510 <xnl_init+0x114>
800044b4:	49 8c       	lddpc	r12,80004514 <xnl_init+0x118>
800044b6:	f0 1f 00 19 	mcall	80004518 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044ba:	1a d7       	st.w	--sp,r7
800044bc:	1a d7       	st.w	--sp,r7
800044be:	1a d7       	st.w	--sp,r7
800044c0:	30 38       	mov	r8,3
800044c2:	0e 99       	mov	r9,r7
800044c4:	e0 6a 03 20 	mov	r10,800
800044c8:	49 5b       	lddpc	r11,8000451c <xnl_init+0x120>
800044ca:	49 6c       	lddpc	r12,80004520 <xnl_init+0x124>
800044cc:	f0 1f 00 13 	mcall	80004518 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800044d0:	f0 1f 00 15 	mcall	80004524 <xnl_init+0x128>
800044d4:	2f ad       	sub	sp,-24
}
800044d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800044da:	00 00       	add	r0,r0
800044dc:	00 00       	add	r0,r0
800044de:	0b 2c       	ld.uh	r12,r5++
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	55 f0       	stdsp	sp[0x17c],r0
800044e4:	00 00       	add	r0,r0
800044e6:	0b 28       	ld.uh	r8,r5++
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	54 f0       	stdsp	sp[0x13c],r0
800044ec:	00 00       	add	r0,r0
800044ee:	0b 38       	ld.ub	r8,r5++
800044f0:	00 00       	add	r0,r0
800044f2:	0a 8c       	andn	r12,r5
800044f4:	00 00       	add	r0,r0
800044f6:	22 ae       	sub	lr,42
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	29 e8       	sub	r8,-98
800044fc:	00 00       	add	r0,r0
800044fe:	0a bc       	st.h	r5++,r12
80004500:	00 00       	add	r0,r0
80004502:	0a a8       	st.w	r5++,r8
80004504:	00 00       	add	r0,r0
80004506:	0a 94       	mov	r4,r5
80004508:	00 00       	add	r0,r0
8000450a:	0e ae       	st.w	r7++,lr
8000450c:	00 00       	add	r0,r0
8000450e:	0a 64       	and	r4,r5
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	c7 78       	rjmp	80004600 <xnl_tx_process+0x78>
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	45 28       	lddsp	r8,sp[0x148]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	5c c4       	swap.bh	r4
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	c0 00       	breq	8000451e <xnl_init+0x122>
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	45 88       	lddsp	r8,sp[0x160]
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	2f 7c       	sub	r12,-9

80004528 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004528:	eb cd 40 fe 	pushm	r1-r7,lr
8000452c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000452e:	49 26       	lddpc	r6,80004574 <xnl_rx_process+0x4c>
80004530:	30 05       	mov	r5,0
80004532:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004534:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004536:	49 11       	lddpc	r1,80004578 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004538:	49 12       	lddpc	r2,8000457c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000453a:	6c 0c       	ld.w	r12,r6[0x0]
8000453c:	0a 99       	mov	r9,r5
8000453e:	08 9a       	mov	r10,r4
80004540:	1a 9b       	mov	r11,sp
80004542:	f0 1f 00 10 	mcall	80004580 <xnl_rx_process+0x58>
80004546:	58 1c       	cp.w	r12,1
80004548:	cf 91       	brne	8000453a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000454a:	40 0c       	lddsp	r12,sp[0x0]
8000454c:	58 0c       	cp.w	r12,0
8000454e:	cf 60       	breq	8000453a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004550:	98 28       	ld.sh	r8,r12[0x4]
80004552:	e6 08 19 00 	cp.h	r8,r3
80004556:	e0 8b 00 0a 	brhi	8000456a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000455a:	5c 78       	castu.h	r8
8000455c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004560:	58 09       	cp.w	r9,0
80004562:	c0 40       	breq	8000456a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004564:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004568:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000456a:	62 0c       	ld.w	r12,r1[0x0]
8000456c:	40 0b       	lddsp	r11,sp[0x0]
8000456e:	f0 1f 00 06 	mcall	80004584 <xnl_rx_process+0x5c>
80004572:	ce 4b       	rjmp	8000453a <xnl_rx_process+0x12>
80004574:	00 00       	add	r0,r0
80004576:	0a a8       	st.w	r5++,r8
80004578:	00 00       	add	r0,r0
8000457a:	0a 8c       	andn	r12,r5
8000457c:	00 00       	add	r0,r0
8000457e:	04 f0       	st.b	--r2,r0
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	52 e4       	stdsp	sp[0xb8],r4
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	29 e8       	sub	r8,-98

80004588 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004588:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000458a:	4a a6       	lddpc	r6,80004630 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000458c:	4a a2       	lddpc	r2,80004634 <xnl_tx_process+0xac>
8000458e:	4a b4       	lddpc	r4,80004638 <xnl_tx_process+0xb0>
80004590:	30 07       	mov	r7,0
80004592:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004594:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004596:	4a a5       	lddpc	r5,8000463c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004598:	4a a3       	lddpc	r3,80004640 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000459a:	6c 08       	ld.w	r8,r6[0x0]
8000459c:	58 08       	cp.w	r8,0
8000459e:	c0 40       	breq	800045a6 <xnl_tx_process+0x1e>
800045a0:	58 18       	cp.w	r8,1
800045a2:	cf d1       	brne	8000459c <xnl_tx_process+0x14>
800045a4:	c2 48       	rjmp	800045ec <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800045a6:	64 0c       	ld.w	r12,r2[0x0]
800045a8:	0e 99       	mov	r9,r7
800045aa:	02 9a       	mov	r10,r1
800045ac:	08 9b       	mov	r11,r4
800045ae:	f0 1f 00 26 	mcall	80004644 <xnl_tx_process+0xbc>
800045b2:	58 1c       	cp.w	r12,1
800045b4:	cf 31       	brne	8000459a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800045b6:	68 0b       	ld.w	r11,r4[0x0]
800045b8:	58 0b       	cp.w	r11,0
800045ba:	cf 00       	breq	8000459a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800045bc:	96 28       	ld.sh	r8,r11[0x4]
800045be:	e0 08 19 00 	cp.h	r8,r0
800045c2:	c0 71       	brne	800045d0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800045c4:	4a 18       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
800045c6:	70 08       	ld.w	r8,r8[0x0]
800045c8:	10 9c       	mov	r12,r8
800045ca:	f0 1f 00 21 	mcall	8000464c <xnl_tx_process+0xc4>
						break;
800045ce:	ce 6b       	rjmp	8000459a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800045d0:	16 9c       	mov	r12,r11
800045d2:	f0 1f 00 20 	mcall	80004650 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800045d6:	30 18       	mov	r8,1
800045d8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800045da:	66 0c       	ld.w	r12,r3[0x0]
800045dc:	0e 99       	mov	r9,r7
800045de:	0e 9a       	mov	r10,r7
800045e0:	0e 9b       	mov	r11,r7
800045e2:	f0 1f 00 19 	mcall	80004644 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800045e6:	30 18       	mov	r8,1
800045e8:	8d 08       	st.w	r6[0x0],r8
800045ea:	cd 8b       	rjmp	8000459a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800045ec:	66 0c       	ld.w	r12,r3[0x0]
800045ee:	0e 99       	mov	r9,r7
800045f0:	36 4a       	mov	r10,100
800045f2:	0e 9b       	mov	r11,r7
800045f4:	f0 1f 00 14 	mcall	80004644 <xnl_tx_process+0xbc>
800045f8:	58 1c       	cp.w	r12,1
800045fa:	c0 81       	brne	8000460a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800045fc:	49 38       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
800045fe:	70 0c       	ld.w	r12,r8[0x0]
80004600:	68 0b       	ld.w	r11,r4[0x0]
80004602:	f0 1f 00 13 	mcall	8000464c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004606:	8d 07       	st.w	r6[0x0],r7
80004608:	cc 9b       	rjmp	8000459a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000460a:	6a 08       	ld.w	r8,r5[0x0]
8000460c:	58 38       	cp.w	r8,3
8000460e:	e0 89 00 09 	brgt	80004620 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004612:	68 0c       	ld.w	r12,r4[0x0]
80004614:	f0 1f 00 0f 	mcall	80004650 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004618:	6a 08       	ld.w	r8,r5[0x0]
8000461a:	2f f8       	sub	r8,-1
8000461c:	8b 08       	st.w	r5[0x0],r8
8000461e:	cb eb       	rjmp	8000459a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004620:	48 a8       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
80004622:	70 0c       	ld.w	r12,r8[0x0]
80004624:	68 0b       	ld.w	r11,r4[0x0]
80004626:	f0 1f 00 0a 	mcall	8000464c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000462a:	8d 07       	st.w	r6[0x0],r7
8000462c:	cb 7b       	rjmp	8000459a <xnl_tx_process+0x12>
8000462e:	00 00       	add	r0,r0
80004630:	00 00       	add	r0,r0
80004632:	0b 48       	ld.w	r8,--r5
80004634:	00 00       	add	r0,r0
80004636:	0b 38       	ld.ub	r8,r5++
80004638:	00 00       	add	r0,r0
8000463a:	0b 40       	ld.w	r0,--r5
8000463c:	00 00       	add	r0,r0
8000463e:	0b 3c       	ld.ub	r12,r5++
80004640:	00 00       	add	r0,r0
80004642:	0b 28       	ld.uh	r8,r5++
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	52 e4       	stdsp	sp[0xb8],r4
80004648:	00 00       	add	r0,r0
8000464a:	0a 8c       	andn	r12,r5
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	29 e8       	sub	r8,-98
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	2a 08       	sub	r8,-96

80004654 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004654:	eb cd 40 c0 	pushm	r6-r7,lr
80004658:	20 1d       	sub	sp,4
8000465a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000465c:	98 39       	ld.sh	r9,r12[0x6]
8000465e:	3f f8       	mov	r8,-1
80004660:	f0 09 19 00 	cp.h	r9,r8
80004664:	c0 a1       	brne	80004678 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004666:	4a e9       	lddpc	r9,8000471c <xnl_tx+0xc8>
80004668:	13 88       	ld.ub	r8,r9[0x0]
8000466a:	2f f8       	sub	r8,-1
8000466c:	5c 58       	castu.b	r8
8000466e:	b2 88       	st.b	r9[0x0],r8
80004670:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004674:	a9 a8       	sbr	r8,0x8
80004676:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004678:	8c 49       	ld.sh	r9,r6[0x8]
8000467a:	3f f8       	mov	r8,-1
8000467c:	f0 09 19 00 	cp.h	r9,r8
80004680:	c0 41       	brne	80004688 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004682:	4a 88       	lddpc	r8,80004720 <xnl_tx+0xcc>
80004684:	90 18       	ld.sh	r8,r8[0x2]
80004686:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004688:	8c 59       	ld.sh	r9,r6[0xa]
8000468a:	3f f8       	mov	r8,-1
8000468c:	f0 09 19 00 	cp.h	r9,r8
80004690:	c0 41       	brne	80004698 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004692:	4a 48       	lddpc	r8,80004720 <xnl_tx+0xcc>
80004694:	90 28       	ld.sh	r8,r8[0x4]
80004696:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004698:	8c 69       	ld.sh	r9,r6[0xc]
8000469a:	3f f8       	mov	r8,-1
8000469c:	f0 09 19 00 	cp.h	r9,r8
800046a0:	c0 e1       	brne	800046bc <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800046a2:	4a 08       	lddpc	r8,80004720 <xnl_tx+0xcc>
800046a4:	90 49       	ld.sh	r9,r8[0x8]
800046a6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800046a8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800046aa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800046ac:	90 49       	ld.sh	r9,r8[0x8]
800046ae:	e0 19 ff 00 	andl	r9,0xff00
800046b2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800046b6:	f3 e8 10 08 	or	r8,r9,r8
800046ba:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800046bc:	0d 98       	ld.ub	r8,r6[0x1]
800046be:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800046c0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800046c4:	10 0c       	add	r12,r8
800046c6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046c8:	58 0c       	cp.w	r12,0
800046ca:	e0 89 00 04 	brgt	800046d2 <xnl_tx+0x7e>
800046ce:	30 09       	mov	r9,0
800046d0:	c0 d8       	rjmp	800046ea <xnl_tx+0x96>
800046d2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800046d6:	2f ec       	sub	r12,-2
800046d8:	30 09       	mov	r9,0
800046da:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800046dc:	15 1b       	ld.sh	r11,r10++
800046de:	f6 09 00 09 	add	r9,r11,r9
800046e2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800046e4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046e6:	18 38       	cp.w	r8,r12
800046e8:	cf a1       	brne	800046dc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800046ea:	5c 39       	neg	r9
800046ec:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046ee:	48 e8       	lddpc	r8,80004724 <xnl_tx+0xd0>
800046f0:	70 0c       	ld.w	r12,r8[0x0]
800046f2:	f0 1f 00 0e 	mcall	80004728 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800046f6:	c1 00       	breq	80004716 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046f8:	fa c7 ff fc 	sub	r7,sp,-4
800046fc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800046fe:	e0 6a 01 00 	mov	r10,256
80004702:	0c 9b       	mov	r11,r6
80004704:	f0 1f 00 0a 	mcall	8000472c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004708:	48 a8       	lddpc	r8,80004730 <xnl_tx+0xdc>
8000470a:	70 0c       	ld.w	r12,r8[0x0]
8000470c:	30 09       	mov	r9,0
8000470e:	12 9a       	mov	r10,r9
80004710:	1a 9b       	mov	r11,sp
80004712:	f0 1f 00 09 	mcall	80004734 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004716:	2f fd       	sub	sp,-4
80004718:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000471c:	00 00       	add	r0,r0
8000471e:	0b 44       	ld.w	r4,--r5
80004720:	00 00       	add	r0,r0
80004722:	0b 2c       	ld.uh	r12,r5++
80004724:	00 00       	add	r0,r0
80004726:	0a 8c       	andn	r12,r5
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	2f 54       	sub	r4,-11
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	69 1c       	ld.w	r12,r4[0x44]
80004730:	00 00       	add	r0,r0
80004732:	0b 38       	ld.ub	r8,r5++
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	54 f0       	stdsp	sp[0x13c],r0

80004738 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004738:	eb cd 40 80 	pushm	r7,lr
8000473c:	fa cd 01 00 	sub	sp,sp,256
80004740:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004742:	e0 68 40 0e 	mov	r8,16398
80004746:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004748:	3f f8       	mov	r8,-1
8000474a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000474c:	30 c8       	mov	r8,12
8000474e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004750:	98 38       	ld.sh	r8,r12[0x6]
80004752:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004754:	98 58       	ld.sh	r8,r12[0xa]
80004756:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004758:	98 48       	ld.sh	r8,r12[0x8]
8000475a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000475c:	98 68       	ld.sh	r8,r12[0xc]
8000475e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004760:	30 08       	mov	r8,0
80004762:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004764:	1a 9c       	mov	r12,sp
80004766:	f0 1f 00 0a 	mcall	8000478c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000476a:	fa cd 00 cc 	sub	sp,sp,204
8000476e:	e0 6a 00 ca 	mov	r10,202
80004772:	ee cb ff f0 	sub	r11,r7,-16
80004776:	1a 9c       	mov	r12,sp
80004778:	f0 1f 00 06 	mcall	80004790 <xnl_data_msg_func+0x58>
8000477c:	48 68       	lddpc	r8,80004794 <xnl_data_msg_func+0x5c>
8000477e:	70 08       	ld.w	r8,r8[0x0]
80004780:	5d 18       	icall	r8
80004782:	fa cd ff 34 	sub	sp,sp,-204
}
80004786:	2c 0d       	sub	sp,-256
80004788:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	46 54       	lddsp	r4,sp[0x194]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	69 1c       	ld.w	r12,r4[0x44]
80004794:	00 00       	add	r0,r0
80004796:	0b 4c       	ld.w	r12,--r5

80004798 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004798:	d4 21       	pushm	r4-r7,lr
8000479a:	fa cd 01 00 	sub	sp,sp,256
8000479e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800047a0:	4c 28       	lddpc	r8,800048a8 <xnl_device_auth_reply_func+0x110>
800047a2:	11 88       	ld.ub	r8,r8[0x0]
800047a4:	58 08       	cp.w	r8,0
800047a6:	c7 e1       	brne	800048a2 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800047a8:	4c 18       	lddpc	r8,800048ac <xnl_device_auth_reply_func+0x114>
800047aa:	70 0c       	ld.w	r12,r8[0x0]
800047ac:	30 09       	mov	r9,0
800047ae:	12 9a       	mov	r10,r9
800047b0:	12 9b       	mov	r11,r9
800047b2:	f0 1f 00 40 	mcall	800048b0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800047b6:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800047ba:	4b c8       	lddpc	r8,800048a8 <xnl_device_auth_reply_func+0x110>
800047bc:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800047be:	ef 39 00 12 	ld.ub	r9,r7[18]
800047c2:	ef 38 00 13 	ld.ub	r8,r7[19]
800047c6:	b1 68       	lsl	r8,0x10
800047c8:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800047cc:	ef 38 00 15 	ld.ub	r8,r7[21]
800047d0:	f3 e8 10 08 	or	r8,r9,r8
800047d4:	ef 39 00 14 	ld.ub	r9,r7[20]
800047d8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800047dc:	ef 3a 00 16 	ld.ub	r10,r7[22]
800047e0:	ef 38 00 17 	ld.ub	r8,r7[23]
800047e4:	b1 68       	lsl	r8,0x10
800047e6:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800047ea:	ef 38 00 19 	ld.ub	r8,r7[25]
800047ee:	f5 e8 10 08 	or	r8,r10,r8
800047f2:	ef 3a 00 18 	ld.ub	r10,r7[24]
800047f6:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800047fa:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047fc:	e0 64 79 b9 	mov	r4,31161
80004800:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004804:	e0 65 45 07 	mov	r5,17671
80004808:	ea 15 8a bd 	orh	r5,0x8abd
8000480c:	e0 66 f9 3d 	mov	r6,63805
80004810:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004814:	e0 6e b8 cf 	mov	lr,47311
80004818:	ea 1e 36 83 	orh	lr,0x3683
8000481c:	e0 67 aa 1c 	mov	r7,43548
80004820:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004824:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004826:	f4 08 00 0c 	add	r12,r10,r8
8000482a:	f0 0b 15 04 	lsl	r11,r8,0x4
8000482e:	0a 0b       	add	r11,r5
80004830:	f9 eb 20 0b 	eor	r11,r12,r11
80004834:	f0 0c 16 05 	lsr	r12,r8,0x5
80004838:	0c 0c       	add	r12,r6
8000483a:	18 5b       	eor	r11,r12
8000483c:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000483e:	f2 0c 15 04 	lsl	r12,r9,0x4
80004842:	1c 0c       	add	r12,lr
80004844:	f2 0b 16 05 	lsr	r11,r9,0x5
80004848:	0e 0b       	add	r11,r7
8000484a:	f9 eb 20 0b 	eor	r11,r12,r11
8000484e:	f2 0a 00 0c 	add	r12,r9,r10
80004852:	18 5b       	eor	r11,r12
80004854:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004856:	e0 6b 37 20 	mov	r11,14112
8000485a:	ea 1b c6 ef 	orh	r11,0xc6ef
8000485e:	16 3a       	cp.w	r10,r11
80004860:	ce 21       	brne	80004824 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004862:	e0 6a 40 1a 	mov	r10,16410
80004866:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004868:	3f fa       	mov	r10,-1
8000486a:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000486c:	30 6b       	mov	r11,6
8000486e:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004870:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004872:	48 eb       	lddpc	r11,800048a8 <xnl_device_auth_reply_func+0x110>
80004874:	96 1c       	ld.sh	r12,r11[0x2]
80004876:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004878:	96 2b       	ld.sh	r11,r11[0x4]
8000487a:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000487c:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000487e:	30 ca       	mov	r10,12
80004880:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004882:	30 0a       	mov	r10,0
80004884:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004888:	30 7a       	mov	r10,7
8000488a:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000488e:	30 2a       	mov	r10,2
80004890:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004894:	fa ca ff ec 	sub	r10,sp,-20
80004898:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000489a:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000489c:	1a 9c       	mov	r12,sp
8000489e:	f0 1f 00 06 	mcall	800048b4 <xnl_device_auth_reply_func+0x11c>
}
800048a2:	2c 0d       	sub	sp,-256
800048a4:	d8 22       	popm	r4-r7,pc
800048a6:	00 00       	add	r0,r0
800048a8:	00 00       	add	r0,r0
800048aa:	0b 2c       	ld.uh	r12,r5++
800048ac:	00 00       	add	r0,r0
800048ae:	0b 28       	ld.uh	r8,r5++
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	54 f0       	stdsp	sp[0x13c],r0
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	46 54       	lddsp	r4,sp[0x194]

800048b8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800048b8:	eb cd 40 80 	pushm	r7,lr
800048bc:	fa cd 01 00 	sub	sp,sp,256
800048c0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800048c2:	49 28       	lddpc	r8,80004908 <xnl_master_status_brdcst_func+0x50>
800048c4:	11 88       	ld.ub	r8,r8[0x0]
800048c6:	58 08       	cp.w	r8,0
800048c8:	c1 c1       	brne	80004900 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800048ca:	49 18       	lddpc	r8,8000490c <xnl_master_status_brdcst_func+0x54>
800048cc:	70 0c       	ld.w	r12,r8[0x0]
800048ce:	30 09       	mov	r9,0
800048d0:	12 9a       	mov	r10,r9
800048d2:	12 9b       	mov	r11,r9
800048d4:	f0 1f 00 0f 	mcall	80004910 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800048d8:	8e 58       	ld.sh	r8,r7[0xa]
800048da:	48 c9       	lddpc	r9,80004908 <xnl_master_status_brdcst_func+0x50>
800048dc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800048de:	e0 68 40 0e 	mov	r8,16398
800048e2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048e4:	3f f8       	mov	r8,-1
800048e6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800048e8:	30 4a       	mov	r10,4
800048ea:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048ec:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048ee:	92 19       	ld.sh	r9,r9[0x2]
800048f0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800048f2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048f4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800048f6:	30 08       	mov	r8,0
800048f8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800048fa:	1a 9c       	mov	r12,sp
800048fc:	f0 1f 00 06 	mcall	80004914 <xnl_master_status_brdcst_func+0x5c>
}
80004900:	2c 0d       	sub	sp,-256
80004902:	e3 cd 80 80 	ldm	sp++,r7,pc
80004906:	00 00       	add	r0,r0
80004908:	00 00       	add	r0,r0
8000490a:	0b 2c       	ld.uh	r12,r5++
8000490c:	00 00       	add	r0,r0
8000490e:	0b 28       	ld.uh	r8,r5++
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	54 f0       	stdsp	sp[0x13c],r0
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	46 54       	lddsp	r4,sp[0x194]

80004918 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004918:	eb cd 40 80 	pushm	r7,lr
8000491c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000491e:	49 28       	lddpc	r8,80004964 <xnl_device_conn_reply_func+0x4c>
80004920:	70 0c       	ld.w	r12,r8[0x0]
80004922:	30 09       	mov	r9,0
80004924:	12 9a       	mov	r10,r9
80004926:	12 9b       	mov	r11,r9
80004928:	f0 1f 00 10 	mcall	80004968 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000492c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004930:	10 99       	mov	r9,r8
80004932:	e2 19 ff 00 	andl	r9,0xff00,COH
80004936:	e0 49 01 00 	cp.w	r9,256
8000493a:	c0 60       	breq	80004946 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000493c:	0e 9c       	mov	r12,r7
8000493e:	f0 1f 00 0c 	mcall	8000496c <xnl_device_conn_reply_func+0x54>
80004942:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004946:	a9 68       	lsl	r8,0x8
80004948:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000494c:	48 98       	lddpc	r8,80004970 <xnl_device_conn_reply_func+0x58>
8000494e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004950:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004954:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004956:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000495a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000495c:	30 19       	mov	r9,1
8000495e:	b0 89       	st.b	r8[0x0],r9
80004960:	e3 cd 80 80 	ldm	sp++,r7,pc
80004964:	00 00       	add	r0,r0
80004966:	0b 28       	ld.uh	r8,r5++
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	54 f0       	stdsp	sp[0x13c],r0
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	48 b8       	lddpc	r8,80004998 <xnl_send_device_master_query+0x24>
80004970:	00 00       	add	r0,r0
80004972:	0b 2c       	ld.uh	r12,r5++

80004974 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004974:	d4 01       	pushm	lr
80004976:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000497a:	e0 68 40 0e 	mov	r8,16398
8000497e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004980:	3f f8       	mov	r8,-1
80004982:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004984:	30 38       	mov	r8,3
80004986:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004988:	30 08       	mov	r8,0
8000498a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000498c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000498e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004990:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004992:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004994:	1a 9c       	mov	r12,sp
80004996:	f0 1f 00 03 	mcall	800049a0 <xnl_send_device_master_query+0x2c>
}
8000499a:	2c 0d       	sub	sp,-256
8000499c:	d8 02       	popm	pc
8000499e:	00 00       	add	r0,r0
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	46 54       	lddsp	r4,sp[0x194]

800049a4 <rfid_init>:
	
	//tc_init();//ㄥ跺200msㄥ诲
	
	//rc522_init();
		
}
800049a4:	5e fc       	retal	r12

800049a6 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800049a6:	fe 78 0c 00 	mov	r8,-62464
800049aa:	e0 69 03 07 	mov	r9,775
800049ae:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800049b0:	30 49       	mov	r9,4
800049b2:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800049b4:	71 59       	ld.w	r9,r8[0x54]
800049b6:	e2 19 00 80 	andl	r9,0x80,COH
800049ba:	cf d0       	breq	800049b4 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800049bc:	fe 78 0c 00 	mov	r8,-62464
800049c0:	30 59       	mov	r9,5
800049c2:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800049c4:	e0 69 01 0d 	mov	r9,269
800049c8:	ea 19 10 07 	orh	r9,0x1007
800049cc:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800049ce:	71 59       	ld.w	r9,r8[0x54]
800049d0:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800049d4:	cf d0       	breq	800049ce <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800049d6:	fe 78 0c 00 	mov	r8,-62464
800049da:	fc 19 00 80 	movh	r9,0x80
800049de:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800049e0:	34 0a       	mov	r10,64
800049e2:	fe 69 14 00 	mov	r9,-125952
800049e6:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800049e8:	30 69       	mov	r9,6
800049ea:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800049ec:	30 19       	mov	r9,1
800049ee:	fe 68 10 00 	mov	r8,-126976
800049f2:	91 19       	st.w	r8[0x4],r9
}
800049f4:	5e fc       	retal	r12

800049f6 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800049f6:	fe 78 10 00 	mov	r8,-61440
800049fa:	fc 19 00 10 	movh	r9,0x10
800049fe:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004a00:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004a02:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004a04:	30 39       	mov	r9,3
80004a06:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004a0a:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004a0e:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004a12:	fe 78 38 00 	mov	r8,-51200
80004a16:	30 49       	mov	r9,4
80004a18:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004a1c:	e0 69 91 0d 	mov	r9,37133
80004a20:	ea 19 00 52 	orh	r9,0x52
80004a24:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004a26:	32 09       	mov	r9,32
80004a28:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004a2a:	30 59       	mov	r9,5
80004a2c:	91 09       	st.w	r8[0x0],r9
}
80004a2e:	5e fc       	retal	r12

80004a30 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004a30:	f8 08 16 05 	lsr	r8,r12,0x5
80004a34:	a9 68       	lsl	r8,0x8
80004a36:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004a3a:	58 1b       	cp.w	r11,1
80004a3c:	c0 d0       	breq	80004a56 <gpio_enable_module_pin+0x26>
80004a3e:	c0 63       	brcs	80004a4a <gpio_enable_module_pin+0x1a>
80004a40:	58 2b       	cp.w	r11,2
80004a42:	c1 00       	breq	80004a62 <gpio_enable_module_pin+0x32>
80004a44:	58 3b       	cp.w	r11,3
80004a46:	c1 40       	breq	80004a6e <gpio_enable_module_pin+0x3e>
80004a48:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004a4a:	30 19       	mov	r9,1
80004a4c:	f2 0c 09 49 	lsl	r9,r9,r12
80004a50:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004a52:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a54:	c1 28       	rjmp	80004a78 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004a56:	30 19       	mov	r9,1
80004a58:	f2 0c 09 49 	lsl	r9,r9,r12
80004a5c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004a5e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a60:	c0 c8       	rjmp	80004a78 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004a62:	30 19       	mov	r9,1
80004a64:	f2 0c 09 49 	lsl	r9,r9,r12
80004a68:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004a6a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a6c:	c0 68       	rjmp	80004a78 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004a6e:	30 19       	mov	r9,1
80004a70:	f2 0c 09 49 	lsl	r9,r9,r12
80004a74:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004a76:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004a78:	30 19       	mov	r9,1
80004a7a:	f2 0c 09 4c 	lsl	r12,r9,r12
80004a7e:	91 2c       	st.w	r8[0x8],r12
80004a80:	5e fd       	retal	0
80004a82:	d7 03       	nop

80004a84 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004a84:	d4 21       	pushm	r4-r7,lr
80004a86:	18 97       	mov	r7,r12
80004a88:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004a8a:	58 0b       	cp.w	r11,0
80004a8c:	c0 31       	brne	80004a92 <gpio_enable_module+0xe>
80004a8e:	30 05       	mov	r5,0
80004a90:	c0 d8       	rjmp	80004aaa <gpio_enable_module+0x26>
80004a92:	30 06       	mov	r6,0
80004a94:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004a96:	6e 1b       	ld.w	r11,r7[0x4]
80004a98:	6e 0c       	ld.w	r12,r7[0x0]
80004a9a:	f0 1f 00 06 	mcall	80004ab0 <gpio_enable_module+0x2c>
80004a9e:	18 45       	or	r5,r12
		gpiomap++;
80004aa0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004aa2:	2f f6       	sub	r6,-1
80004aa4:	0c 34       	cp.w	r4,r6
80004aa6:	fe 9b ff f8 	brhi	80004a96 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004aaa:	0a 9c       	mov	r12,r5
80004aac:	d8 22       	popm	r4-r7,pc
80004aae:	00 00       	add	r0,r0
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	4a 30       	lddpc	r0,80004b3c <INTC_init_interrupts+0x4>

80004ab4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004ab4:	c0 08       	rjmp	80004ab4 <_unhandled_interrupt>
80004ab6:	d7 03       	nop

80004ab8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004ab8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004abc:	49 99       	lddpc	r9,80004b20 <INTC_register_interrupt+0x68>
80004abe:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004ac2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004ac6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004ac8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004acc:	58 0a       	cp.w	r10,0
80004ace:	c0 91       	brne	80004ae0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004ad0:	49 59       	lddpc	r9,80004b24 <INTC_register_interrupt+0x6c>
80004ad2:	49 6a       	lddpc	r10,80004b28 <INTC_register_interrupt+0x70>
80004ad4:	12 1a       	sub	r10,r9
80004ad6:	fe 79 08 00 	mov	r9,-63488
80004ada:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ade:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004ae0:	58 1a       	cp.w	r10,1
80004ae2:	c0 a1       	brne	80004af6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004ae4:	49 09       	lddpc	r9,80004b24 <INTC_register_interrupt+0x6c>
80004ae6:	49 2a       	lddpc	r10,80004b2c <INTC_register_interrupt+0x74>
80004ae8:	12 1a       	sub	r10,r9
80004aea:	bf aa       	sbr	r10,0x1e
80004aec:	fe 79 08 00 	mov	r9,-63488
80004af0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004af4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004af6:	58 2a       	cp.w	r10,2
80004af8:	c0 a1       	brne	80004b0c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004afa:	48 b9       	lddpc	r9,80004b24 <INTC_register_interrupt+0x6c>
80004afc:	48 da       	lddpc	r10,80004b30 <INTC_register_interrupt+0x78>
80004afe:	12 1a       	sub	r10,r9
80004b00:	bf ba       	sbr	r10,0x1f
80004b02:	fe 79 08 00 	mov	r9,-63488
80004b06:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b0a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004b0c:	48 69       	lddpc	r9,80004b24 <INTC_register_interrupt+0x6c>
80004b0e:	48 aa       	lddpc	r10,80004b34 <INTC_register_interrupt+0x7c>
80004b10:	12 1a       	sub	r10,r9
80004b12:	ea 1a c0 00 	orh	r10,0xc000
80004b16:	fe 79 08 00 	mov	r9,-63488
80004b1a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b1e:	5e fc       	retal	r12
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	c7 80       	breq	80004c12 <usart_set_async_baudrate+0x4e>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	be 00       	st.h	pc[0x0],r0
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	bf 04       	ld.d	r4,pc
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	bf 12       	ld.d	r2,--pc
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	bf 20       	st.d	pc++,r0
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	bf 2e       	st.d	pc++,lr

80004b38 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004b38:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004b3a:	49 18       	lddpc	r8,80004b7c <INTC_init_interrupts+0x44>
80004b3c:	e3 b8 00 01 	mtsr	0x4,r8
80004b40:	49 0e       	lddpc	lr,80004b80 <INTC_init_interrupts+0x48>
80004b42:	30 07       	mov	r7,0
80004b44:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004b46:	49 0c       	lddpc	r12,80004b84 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b48:	49 05       	lddpc	r5,80004b88 <INTC_init_interrupts+0x50>
80004b4a:	10 15       	sub	r5,r8
80004b4c:	fe 76 08 00 	mov	r6,-63488
80004b50:	c1 08       	rjmp	80004b70 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004b52:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004b54:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b56:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004b58:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004b5c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b5e:	10 3a       	cp.w	r10,r8
80004b60:	fe 9b ff fc 	brhi	80004b58 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b64:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004b68:	2f f7       	sub	r7,-1
80004b6a:	2f 8e       	sub	lr,-8
80004b6c:	59 37       	cp.w	r7,19
80004b6e:	c0 50       	breq	80004b78 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b70:	7c 08       	ld.w	r8,lr[0x0]
80004b72:	58 08       	cp.w	r8,0
80004b74:	ce f1       	brne	80004b52 <INTC_init_interrupts+0x1a>
80004b76:	cf 7b       	rjmp	80004b64 <INTC_init_interrupts+0x2c>
80004b78:	d8 22       	popm	r4-r7,pc
80004b7a:	00 00       	add	r0,r0
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	be 00       	st.h	pc[0x0],r0
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	c7 80       	breq	80004c72 <usart_read_char+0x12>
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	4a b4       	lddpc	r4,80004c30 <usart_write_char+0x12>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	bf 04       	ld.d	r4,pc

80004b8c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004b8c:	fe 78 08 00 	mov	r8,-63488
80004b90:	e0 69 00 83 	mov	r9,131
80004b94:	f2 0c 01 0c 	sub	r12,r9,r12
80004b98:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004b9c:	f2 ca ff c0 	sub	r10,r9,-64
80004ba0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004ba4:	58 08       	cp.w	r8,0
80004ba6:	c0 21       	brne	80004baa <_get_interrupt_handler+0x1e>
80004ba8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004baa:	f0 08 12 00 	clz	r8,r8
80004bae:	48 5a       	lddpc	r10,80004bc0 <_get_interrupt_handler+0x34>
80004bb0:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004bb4:	f0 08 11 1f 	rsub	r8,r8,31
80004bb8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004bba:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004bbe:	5e fc       	retal	r12
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	c7 80       	breq	80004cb2 <usart_write_line+0x2>

80004bc4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004bc4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004bc6:	f6 08 15 04 	lsl	r8,r11,0x4
80004bca:	14 38       	cp.w	r8,r10
80004bcc:	f9 b8 08 10 	movls	r8,16
80004bd0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004bd4:	f0 0b 02 4b 	mul	r11,r8,r11
80004bd8:	f6 09 16 01 	lsr	r9,r11,0x1
80004bdc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004be0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004be4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004be8:	f2 cb 00 01 	sub	r11,r9,1
80004bec:	e0 4b ff fe 	cp.w	r11,65534
80004bf0:	e0 88 00 03 	brls	80004bf6 <usart_set_async_baudrate+0x32>
80004bf4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004bf6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004bf8:	e8 6e 00 00 	mov	lr,524288
80004bfc:	59 08       	cp.w	r8,16
80004bfe:	fc 08 17 10 	movne	r8,lr
80004c02:	f9 b8 00 00 	moveq	r8,0
80004c06:	e4 1b ff f7 	andh	r11,0xfff7
80004c0a:	e0 1b fe cf 	andl	r11,0xfecf
80004c0e:	16 48       	or	r8,r11
80004c10:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004c12:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004c16:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004c1a:	99 89       	st.w	r12[0x20],r9
80004c1c:	d8 0a       	popm	pc,r12=0

80004c1e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004c1e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004c20:	e2 18 00 02 	andl	r8,0x2,COH
80004c24:	c0 31       	brne	80004c2a <usart_write_char+0xc>
80004c26:	30 2c       	mov	r12,2
80004c28:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004c2a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004c2e:	99 7b       	st.w	r12[0x1c],r11
80004c30:	5e fd       	retal	0
80004c32:	d7 03       	nop

80004c34 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004c34:	eb cd 40 e0 	pushm	r5-r7,lr
80004c38:	18 96       	mov	r6,r12
80004c3a:	16 95       	mov	r5,r11
80004c3c:	e0 67 27 0f 	mov	r7,9999
80004c40:	c0 68       	rjmp	80004c4c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004c42:	58 07       	cp.w	r7,0
80004c44:	c0 31       	brne	80004c4a <usart_putchar+0x16>
80004c46:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004c4a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004c4c:	0a 9b       	mov	r11,r5
80004c4e:	0c 9c       	mov	r12,r6
80004c50:	f0 1f 00 03 	mcall	80004c5c <usart_putchar+0x28>
80004c54:	cf 71       	brne	80004c42 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004c56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c5a:	00 00       	add	r0,r0
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	4c 1e       	lddpc	lr,80004d60 <usart_init_rs232+0x60>

80004c60 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004c60:	78 58       	ld.w	r8,r12[0x14]
80004c62:	e2 18 00 e0 	andl	r8,0xe0,COH
80004c66:	c0 30       	breq	80004c6c <usart_read_char+0xc>
80004c68:	30 4c       	mov	r12,4
80004c6a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004c6c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004c6e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c72:	c0 31       	brne	80004c78 <usart_read_char+0x18>
80004c74:	30 3c       	mov	r12,3
80004c76:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004c78:	78 68       	ld.w	r8,r12[0x18]
80004c7a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004c7e:	97 08       	st.w	r11[0x0],r8
80004c80:	5e fd       	retal	0
80004c82:	d7 03       	nop

80004c84 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004c84:	eb cd 40 c0 	pushm	r6-r7,lr
80004c88:	20 1d       	sub	sp,4
80004c8a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004c8c:	1a 97       	mov	r7,sp
80004c8e:	1a 9b       	mov	r11,sp
80004c90:	0c 9c       	mov	r12,r6
80004c92:	f0 1f 00 07 	mcall	80004cac <usart_getchar+0x28>
80004c96:	58 3c       	cp.w	r12,3
80004c98:	cf b0       	breq	80004c8e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004c9a:	58 4c       	cp.w	r12,4
80004c9c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004ca0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004ca4:	2f fd       	sub	sp,-4
80004ca6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004caa:	00 00       	add	r0,r0
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	4c 60       	lddpc	r0,80004dc4 <usart_init_rs232+0xc4>

80004cb0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80004cb4:	18 96       	mov	r6,r12
80004cb6:	16 97       	mov	r7,r11
  while (*string != '\0')
80004cb8:	17 8b       	ld.ub	r11,r11[0x0]
80004cba:	58 0b       	cp.w	r11,0
80004cbc:	c0 80       	breq	80004ccc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004cbe:	2f f7       	sub	r7,-1
80004cc0:	0c 9c       	mov	r12,r6
80004cc2:	f0 1f 00 04 	mcall	80004cd0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004cc6:	0f 8b       	ld.ub	r11,r7[0x0]
80004cc8:	58 0b       	cp.w	r11,0
80004cca:	cf a1       	brne	80004cbe <usart_write_line+0xe>
80004ccc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	4c 34       	lddpc	r4,80004ddc <_stext+0x10>

80004cd4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004cd4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004cd8:	e6 18 00 01 	andh	r8,0x1,COH
80004cdc:	c0 71       	brne	80004cea <usart_reset+0x16>
80004cde:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004ce0:	3f f8       	mov	r8,-1
80004ce2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ce4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004ce6:	d5 03       	csrf	0x10
80004ce8:	c0 48       	rjmp	80004cf0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004cea:	3f f8       	mov	r8,-1
80004cec:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004cee:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004cf0:	30 08       	mov	r8,0
80004cf2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004cf4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004cf6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004cf8:	ea 68 61 0c 	mov	r8,680204
80004cfc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004cfe:	5e fc       	retal	r12

80004d00 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004d00:	eb cd 40 e0 	pushm	r5-r7,lr
80004d04:	18 96       	mov	r6,r12
80004d06:	16 97       	mov	r7,r11
80004d08:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004d0a:	f0 1f 00 2f 	mcall	80004dc4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004d0e:	58 07       	cp.w	r7,0
80004d10:	c5 80       	breq	80004dc0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004d12:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004d14:	30 49       	mov	r9,4
80004d16:	f2 08 18 00 	cp.b	r8,r9
80004d1a:	e0 88 00 53 	brls	80004dc0 <usart_init_rs232+0xc0>
80004d1e:	30 99       	mov	r9,9
80004d20:	f2 08 18 00 	cp.b	r8,r9
80004d24:	e0 8b 00 4e 	brhi	80004dc0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004d28:	0f d9       	ld.ub	r9,r7[0x5]
80004d2a:	30 78       	mov	r8,7
80004d2c:	f0 09 18 00 	cp.b	r9,r8
80004d30:	e0 8b 00 48 	brhi	80004dc0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004d34:	8e 39       	ld.sh	r9,r7[0x6]
80004d36:	e0 68 01 01 	mov	r8,257
80004d3a:	f0 09 19 00 	cp.h	r9,r8
80004d3e:	e0 8b 00 41 	brhi	80004dc0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004d42:	ef 39 00 08 	ld.ub	r9,r7[8]
80004d46:	30 38       	mov	r8,3
80004d48:	f0 09 18 00 	cp.b	r9,r8
80004d4c:	e0 8b 00 3a 	brhi	80004dc0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004d50:	0a 9a       	mov	r10,r5
80004d52:	6e 0b       	ld.w	r11,r7[0x0]
80004d54:	0c 9c       	mov	r12,r6
80004d56:	f0 1f 00 1d 	mcall	80004dc8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004d5a:	58 1c       	cp.w	r12,1
80004d5c:	c3 20       	breq	80004dc0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004d5e:	0f c8       	ld.ub	r8,r7[0x4]
80004d60:	30 99       	mov	r9,9
80004d62:	f2 08 18 00 	cp.b	r8,r9
80004d66:	c0 51       	brne	80004d70 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004d68:	6c 18       	ld.w	r8,r6[0x4]
80004d6a:	b1 b8       	sbr	r8,0x11
80004d6c:	8d 18       	st.w	r6[0x4],r8
80004d6e:	c0 68       	rjmp	80004d7a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004d70:	6c 19       	ld.w	r9,r6[0x4]
80004d72:	20 58       	sub	r8,5
80004d74:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004d78:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004d7a:	6c 19       	ld.w	r9,r6[0x4]
80004d7c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004d80:	0f d8       	ld.ub	r8,r7[0x5]
80004d82:	a9 78       	lsl	r8,0x9
80004d84:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004d88:	12 48       	or	r8,r9
80004d8a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004d8c:	8e 38       	ld.sh	r8,r7[0x6]
80004d8e:	30 29       	mov	r9,2
80004d90:	f2 08 19 00 	cp.h	r8,r9
80004d94:	e0 88 00 09 	brls	80004da6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004d98:	6c 18       	ld.w	r8,r6[0x4]
80004d9a:	ad b8       	sbr	r8,0xd
80004d9c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004d9e:	8e b8       	ld.uh	r8,r7[0x6]
80004da0:	20 28       	sub	r8,2
80004da2:	8d a8       	st.w	r6[0x28],r8
80004da4:	c0 68       	rjmp	80004db0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004da6:	6c 19       	ld.w	r9,r6[0x4]
80004da8:	5c 78       	castu.h	r8
80004daa:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004dae:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004db0:	6c 18       	ld.w	r8,r6[0x4]
80004db2:	e0 18 ff f0 	andl	r8,0xfff0
80004db6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004db8:	35 08       	mov	r8,80
80004dba:	8d 08       	st.w	r6[0x0],r8
80004dbc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004dc0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	4c d4       	lddpc	r4,80004ef8 <pxPortInitialiseStack+0x5c>
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	4b c4       	lddpc	r4,80004eb8 <pxPortInitialiseStack+0x1c>

80004dcc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004dcc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004dd0:	fe c0 8f d0 	sub	r0,pc,-28720

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004dd4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004dd8:	d5 53       	csrf	0x15
  cp      r0, r1
80004dda:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004ddc:	e0 61 0a 30 	mov	r1,2608
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004de0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004de2:	c0 62       	brcc	80004dee <idata_load_loop_end>
  cp      r0, r1
80004de4:	48 92       	lddpc	r2,80004e08 <udata_clear_loop_end+0x4>

80004de6 <idata_load_loop>:
  brlo    idata_load_loop
80004de6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004de8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004dea:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004dec:	cf d3       	brcs	80004de6 <idata_load_loop>

80004dee <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004dee:	e0 60 0a 30 	mov	r0,2608
  mov     r2, 0
  mov     r3, 0
80004df2:	e0 61 41 10 	mov	r1,16656
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004df6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004df8:	c0 62       	brcc	80004e04 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004dfa:	30 02       	mov	r2,0
80004dfc:	30 03       	mov	r3,0

80004dfe <udata_clear_loop>:
80004dfe:	a1 22       	st.d	r0++,r2
80004e00:	02 30       	cp.w	r0,r1
80004e02:	cf e3       	brcs	80004dfe <udata_clear_loop>

80004e04 <udata_clear_loop_end>:
80004e04:	fe cf e9 c4 	sub	pc,pc,-5692
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	d0 b0       	acall	0xb

80004e0c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004e0c:	f8 c8 ff f8 	sub	r8,r12,-8
80004e10:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004e12:	3f f9       	mov	r9,-1
80004e14:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004e16:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004e18:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004e1a:	30 08       	mov	r8,0
80004e1c:	99 08       	st.w	r12[0x0],r8
}
80004e1e:	5e fc       	retal	r12

80004e20 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004e20:	30 08       	mov	r8,0
80004e22:	99 48       	st.w	r12[0x10],r8
}
80004e24:	5e fc       	retal	r12

80004e26 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004e26:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004e28:	70 19       	ld.w	r9,r8[0x4]
80004e2a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004e2c:	78 19       	ld.w	r9,r12[0x4]
80004e2e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004e30:	70 19       	ld.w	r9,r8[0x4]
80004e32:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004e34:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004e36:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004e38:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004e3a:	78 08       	ld.w	r8,r12[0x0]
80004e3c:	2f f8       	sub	r8,-1
80004e3e:	99 08       	st.w	r12[0x0],r8
}
80004e40:	5e fc       	retal	r12

80004e42 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004e42:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004e44:	5b fa       	cp.w	r10,-1
80004e46:	c0 31       	brne	80004e4c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004e48:	78 48       	ld.w	r8,r12[0x10]
80004e4a:	c0 c8       	rjmp	80004e62 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004e4c:	f8 c8 ff f8 	sub	r8,r12,-8
80004e50:	70 19       	ld.w	r9,r8[0x4]
80004e52:	72 09       	ld.w	r9,r9[0x0]
80004e54:	12 3a       	cp.w	r10,r9
80004e56:	c0 63       	brcs	80004e62 <vListInsert+0x20>
80004e58:	70 18       	ld.w	r8,r8[0x4]
80004e5a:	70 19       	ld.w	r9,r8[0x4]
80004e5c:	72 09       	ld.w	r9,r9[0x0]
80004e5e:	12 3a       	cp.w	r10,r9
80004e60:	cf c2       	brcc	80004e58 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004e62:	70 19       	ld.w	r9,r8[0x4]
80004e64:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004e66:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004e68:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004e6a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004e6c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004e6e:	78 08       	ld.w	r8,r12[0x0]
80004e70:	2f f8       	sub	r8,-1
80004e72:	99 08       	st.w	r12[0x0],r8
}
80004e74:	5e fc       	retal	r12

80004e76 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004e76:	78 18       	ld.w	r8,r12[0x4]
80004e78:	78 29       	ld.w	r9,r12[0x8]
80004e7a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004e7c:	78 28       	ld.w	r8,r12[0x8]
80004e7e:	78 19       	ld.w	r9,r12[0x4]
80004e80:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004e82:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004e84:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004e86:	18 39       	cp.w	r9,r12
80004e88:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004e8c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004e90:	30 09       	mov	r9,0
80004e92:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004e94:	70 09       	ld.w	r9,r8[0x0]
80004e96:	20 19       	sub	r9,1
80004e98:	91 09       	st.w	r8[0x0],r9
}
80004e9a:	5e fc       	retal	r12

80004e9c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004e9c:	e0 68 08 08 	mov	r8,2056
80004ea0:	ea 18 08 08 	orh	r8,0x808
80004ea4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004ea6:	e0 68 09 09 	mov	r8,2313
80004eaa:	ea 18 09 09 	orh	r8,0x909
80004eae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004eb0:	e0 68 0a 0a 	mov	r8,2570
80004eb4:	ea 18 0a 0a 	orh	r8,0xa0a
80004eb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004eba:	e0 68 0b 0b 	mov	r8,2827
80004ebe:	ea 18 0b 0b 	orh	r8,0xb0b
80004ec2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004ec4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004ec6:	e0 68 be ef 	mov	r8,48879
80004eca:	ea 18 de ad 	orh	r8,0xdead
80004ece:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004ed0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004ed2:	fc 18 00 40 	movh	r8,0x40
80004ed6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004ed8:	e0 68 00 ff 	mov	r8,255
80004edc:	ea 18 ff 00 	orh	r8,0xff00
80004ee0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004ee2:	e0 68 01 01 	mov	r8,257
80004ee6:	ea 18 01 01 	orh	r8,0x101
80004eea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004eec:	e0 68 02 02 	mov	r8,514
80004ef0:	ea 18 02 02 	orh	r8,0x202
80004ef4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004ef6:	e0 68 03 03 	mov	r8,771
80004efa:	ea 18 03 03 	orh	r8,0x303
80004efe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004f00:	e0 68 04 04 	mov	r8,1028
80004f04:	ea 18 04 04 	orh	r8,0x404
80004f08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004f0a:	e0 68 05 05 	mov	r8,1285
80004f0e:	ea 18 05 05 	orh	r8,0x505
80004f12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004f14:	e0 68 06 06 	mov	r8,1542
80004f18:	ea 18 06 06 	orh	r8,0x606
80004f1c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004f1e:	e0 68 07 07 	mov	r8,1799
80004f22:	ea 18 07 07 	orh	r8,0x707
80004f26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004f28:	30 08       	mov	r8,0
80004f2a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004f2c:	5e fc       	retal	r12
80004f2e:	d7 03       	nop

80004f30 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004f30:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004f32:	48 38       	lddpc	r8,80004f3c <vPortEnterCritical+0xc>
80004f34:	70 09       	ld.w	r9,r8[0x0]
80004f36:	2f f9       	sub	r9,-1
80004f38:	91 09       	st.w	r8[0x0],r9
}
80004f3a:	5e fc       	retal	r12
80004f3c:	00 00       	add	r0,r0
80004f3e:	05 24       	ld.uh	r4,r2++

80004f40 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004f40:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004f42:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004f44:	30 0a       	mov	r10,0
80004f46:	14 9b       	mov	r11,r10
80004f48:	49 2c       	lddpc	r12,80004f90 <xPortStartScheduler+0x50>
80004f4a:	f0 1f 00 13 	mcall	80004f94 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004f4e:	e0 68 5d c0 	mov	r8,24000
80004f52:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004f56:	30 08       	mov	r8,0
80004f58:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004f5c:	e0 68 0c c8 	mov	r8,3272
80004f60:	ea 18 00 00 	orh	r8,0x0
80004f64:	70 00       	ld.w	r0,r8[0x0]
80004f66:	60 0d       	ld.w	sp,r0[0x0]
80004f68:	1b 00       	ld.w	r0,sp++
80004f6a:	e0 68 05 24 	mov	r8,1316
80004f6e:	ea 18 00 00 	orh	r8,0x0
80004f72:	91 00       	st.w	r8[0x0],r0
80004f74:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f78:	2f ed       	sub	sp,-8
80004f7a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004f7e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004f82:	e3 b0 00 00 	mtsr	0x0,r0
80004f86:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004f8a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004f8e:	d8 0a       	popm	pc,r12=0
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	50 5c       	stdsp	sp[0x14],r12
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4a b8       	lddpc	r8,80005040 <vPortExitCritical+0x4>

80004f98 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004f98:	20 6d       	sub	sp,24
80004f9a:	eb cd 00 ff 	pushm	r0-r7
80004f9e:	fa c7 ff c0 	sub	r7,sp,-64
80004fa2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004fa6:	ef 40 ff e0 	st.w	r7[-32],r0
80004faa:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004fae:	ef 40 ff e4 	st.w	r7[-28],r0
80004fb2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004fb6:	e0 68 05 24 	mov	r8,1316
80004fba:	ea 18 00 00 	orh	r8,0x0
80004fbe:	70 00       	ld.w	r0,r8[0x0]
80004fc0:	1a d0       	st.w	--sp,r0
80004fc2:	f0 1f 00 1a 	mcall	80005028 <LABEL_RET_SCALL_263+0x14>
80004fc6:	e0 68 0c c8 	mov	r8,3272
80004fca:	ea 18 00 00 	orh	r8,0x0
80004fce:	70 00       	ld.w	r0,r8[0x0]
80004fd0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004fd2:	f0 1f 00 17 	mcall	8000502c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004fd6:	e0 68 0c c8 	mov	r8,3272
80004fda:	ea 18 00 00 	orh	r8,0x0
80004fde:	70 00       	ld.w	r0,r8[0x0]
80004fe0:	60 0d       	ld.w	sp,r0[0x0]
80004fe2:	1b 00       	ld.w	r0,sp++
80004fe4:	e0 68 05 24 	mov	r8,1316
80004fe8:	ea 18 00 00 	orh	r8,0x0
80004fec:	91 00       	st.w	r8[0x0],r0
80004fee:	fa c7 ff d8 	sub	r7,sp,-40
80004ff2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004ff6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004ffa:	e0 61 05 24 	mov	r1,1316
80004ffe:	ea 11 00 00 	orh	r1,0x0
80005002:	62 02       	ld.w	r2,r1[0x0]
80005004:	58 02       	cp.w	r2,0
80005006:	c0 70       	breq	80005014 <LABEL_RET_SCALL_263>
80005008:	e4 c2 00 01 	sub	r2,r2,1
8000500c:	83 02       	st.w	r1[0x0],r2
8000500e:	58 02       	cp.w	r2,0
80005010:	c0 21       	brne	80005014 <LABEL_RET_SCALL_263>
80005012:	b1 c0       	cbr	r0,0x10

80005014 <LABEL_RET_SCALL_263>:
80005014:	ef 40 ff f8 	st.w	r7[-8],r0
80005018:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000501c:	ef 40 ff fc 	st.w	r7[-4],r0
80005020:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005024:	2f ad       	sub	sp,-24
80005026:	d6 13       	rets
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	4f 30       	lddpc	r0,800051f4 <xQueueReceiveFromISR>
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	56 74       	stdsp	sp[0x19c],r4

80005030 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005030:	e1 b8 00 43 	mfsr	r8,0x10c
80005034:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005038:	5e fc       	retal	r12
8000503a:	d7 03       	nop

8000503c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000503c:	48 78       	lddpc	r8,80005058 <vPortExitCritical+0x1c>
8000503e:	70 08       	ld.w	r8,r8[0x0]
80005040:	58 08       	cp.w	r8,0
80005042:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005044:	48 58       	lddpc	r8,80005058 <vPortExitCritical+0x1c>
80005046:	70 09       	ld.w	r9,r8[0x0]
80005048:	20 19       	sub	r9,1
8000504a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000504c:	70 08       	ld.w	r8,r8[0x0]
8000504e:	58 08       	cp.w	r8,0
80005050:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005052:	d5 03       	csrf	0x10
80005054:	5e fc       	retal	r12
80005056:	00 00       	add	r0,r0
80005058:	00 00       	add	r0,r0
8000505a:	05 24       	ld.uh	r4,r2++

8000505c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000505c:	eb cd 00 ff 	pushm	r0-r7
80005060:	e0 68 05 24 	mov	r8,1316
80005064:	ea 18 00 00 	orh	r8,0x0
80005068:	70 00       	ld.w	r0,r8[0x0]
8000506a:	1a d0       	st.w	--sp,r0
8000506c:	7a 90       	ld.w	r0,sp[0x24]
8000506e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005072:	58 10       	cp.w	r0,1
80005074:	e0 8b 00 08 	brhi	80005084 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005078:	e0 68 0c c8 	mov	r8,3272
8000507c:	ea 18 00 00 	orh	r8,0x0
80005080:	70 00       	ld.w	r0,r8[0x0]
80005082:	81 0d       	st.w	r0[0x0],sp

80005084 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005084:	f0 1f 00 12 	mcall	800050cc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005088:	f0 1f 00 12 	mcall	800050d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000508c:	f0 1f 00 12 	mcall	800050d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005090:	f0 1f 00 12 	mcall	800050d8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005094:	7a 90       	ld.w	r0,sp[0x24]
80005096:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000509a:	58 10       	cp.w	r0,1
8000509c:	e0 8b 00 0e 	brhi	800050b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800050a0:	f0 1f 00 0c 	mcall	800050d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800050a4:	f0 1f 00 0e 	mcall	800050dc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800050a8:	f0 1f 00 0c 	mcall	800050d8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800050ac:	e0 68 0c c8 	mov	r8,3272
800050b0:	ea 18 00 00 	orh	r8,0x0
800050b4:	70 00       	ld.w	r0,r8[0x0]
800050b6:	60 0d       	ld.w	sp,r0[0x0]

800050b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800050b8:	1b 00       	ld.w	r0,sp++
800050ba:	e0 68 05 24 	mov	r8,1316
800050be:	ea 18 00 00 	orh	r8,0x0
800050c2:	91 00       	st.w	r8[0x0],r0
800050c4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800050c8:	d6 03       	rete
800050ca:	00 00       	add	r0,r0
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	50 30       	stdsp	sp[0xc],r0
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	4f 30       	lddpc	r0,8000529c <prvUnlockQueue+0x58>
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	58 78       	cp.w	r8,7
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	50 3c       	stdsp	sp[0xc],r12
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	56 74       	stdsp	sp[0x19c],r4

800050e0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800050e0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800050e2:	f0 1f 00 02 	mcall	800050e8 <__malloc_lock+0x8>
}
800050e6:	d8 02       	popm	pc
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	56 64       	stdsp	sp[0x198],r4

800050ec <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800050ec:	d4 01       	pushm	lr
	xTaskResumeAll();
800050ee:	f0 1f 00 02 	mcall	800050f4 <__malloc_unlock+0x8>
}
800050f2:	d8 02       	popm	pc
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	5a 20       	cp.w	r0,-30

800050f8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800050f8:	d4 21       	pushm	r4-r7,lr
800050fa:	16 95       	mov	r5,r11
800050fc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800050fe:	58 0c       	cp.w	r12,0
80005100:	c0 30       	breq	80005106 <_read+0xe>
80005102:	3f f7       	mov	r7,-1
80005104:	c1 48       	rjmp	8000512c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005106:	58 0a       	cp.w	r10,0
80005108:	e0 89 00 04 	brgt	80005110 <_read+0x18>
8000510c:	30 07       	mov	r7,0
8000510e:	c0 f8       	rjmp	8000512c <_read+0x34>
80005110:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005112:	48 84       	lddpc	r4,80005130 <_read+0x38>
80005114:	68 0c       	ld.w	r12,r4[0x0]
80005116:	f0 1f 00 08 	mcall	80005134 <_read+0x3c>
    if (c < 0)
8000511a:	c0 95       	brlt	8000512c <_read+0x34>
      break;

    *ptr++ = c;
8000511c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005120:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005122:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005126:	58 08       	cp.w	r8,0
80005128:	fe 99 ff f6 	brgt	80005114 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000512c:	0e 9c       	mov	r12,r7
8000512e:	d8 22       	popm	r4-r7,pc
80005130:	00 00       	add	r0,r0
80005132:	41 00       	lddsp	r0,sp[0x40]
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	4c 84       	lddpc	r4,80005254 <prvUnlockQueue+0x10>

80005138 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005138:	d4 21       	pushm	r4-r7,lr
8000513a:	16 95       	mov	r5,r11
8000513c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000513e:	20 1c       	sub	r12,1
80005140:	58 2c       	cp.w	r12,2
80005142:	e0 8b 00 12 	brhi	80005166 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005146:	58 0a       	cp.w	r10,0
80005148:	c0 31       	brne	8000514e <_write+0x16>
8000514a:	30 07       	mov	r7,0
8000514c:	c0 e8       	rjmp	80005168 <_write+0x30>
8000514e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005150:	48 74       	lddpc	r4,8000516c <_write+0x34>
80005152:	68 0c       	ld.w	r12,r4[0x0]
80005154:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005158:	f0 1f 00 06 	mcall	80005170 <_write+0x38>
8000515c:	c0 55       	brlt	80005166 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000515e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005160:	0e 36       	cp.w	r6,r7
80005162:	cf 81       	brne	80005152 <_write+0x1a>
80005164:	c0 28       	rjmp	80005168 <_write+0x30>
80005166:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005168:	0e 9c       	mov	r12,r7
8000516a:	d8 22       	popm	r4-r7,pc
8000516c:	00 00       	add	r0,r0
8000516e:	41 00       	lddsp	r0,sp[0x40]
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	4c 34       	lddpc	r4,8000527c <prvUnlockQueue+0x38>

80005174 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005174:	eb cd 40 80 	pushm	r7,lr
80005178:	18 97       	mov	r7,r12
	if( pv )
8000517a:	58 0c       	cp.w	r12,0
8000517c:	c0 80       	breq	8000518c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000517e:	f0 1f 00 05 	mcall	80005190 <vPortFree+0x1c>
		{
			free( pv );
80005182:	0e 9c       	mov	r12,r7
80005184:	f0 1f 00 04 	mcall	80005194 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005188:	f0 1f 00 04 	mcall	80005198 <vPortFree+0x24>
8000518c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	56 64       	stdsp	sp[0x198],r4
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	64 c4       	ld.w	r4,r2[0x30]
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	5a 20       	cp.w	r0,-30

8000519c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000519c:	eb cd 40 80 	pushm	r7,lr
800051a0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800051a2:	f0 1f 00 06 	mcall	800051b8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800051a6:	0e 9c       	mov	r12,r7
800051a8:	f0 1f 00 05 	mcall	800051bc <pvPortMalloc+0x20>
800051ac:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800051ae:	f0 1f 00 05 	mcall	800051c0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800051b2:	0e 9c       	mov	r12,r7
800051b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	56 64       	stdsp	sp[0x198],r4
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	64 d4       	ld.w	r4,r2[0x34]
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	5a 20       	cp.w	r0,-30

800051c4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800051c4:	d4 01       	pushm	lr
800051c6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800051c8:	78 09       	ld.w	r9,r12[0x0]
800051ca:	58 09       	cp.w	r9,0
800051cc:	c1 10       	breq	800051ee <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800051ce:	78 3a       	ld.w	r10,r12[0xc]
800051d0:	79 09       	ld.w	r9,r12[0x40]
800051d2:	f4 09 00 09 	add	r9,r10,r9
800051d6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800051d8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800051da:	14 39       	cp.w	r9,r10
800051dc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800051e0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800051e4:	79 0a       	ld.w	r10,r12[0x40]
800051e6:	78 3b       	ld.w	r11,r12[0xc]
800051e8:	10 9c       	mov	r12,r8
800051ea:	f0 1f 00 02 	mcall	800051f0 <prvCopyDataFromQueue+0x2c>
800051ee:	d8 02       	popm	pc
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	69 1c       	ld.w	r12,r4[0x44]

800051f4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800051f4:	eb cd 40 c0 	pushm	r6-r7,lr
800051f8:	18 97       	mov	r7,r12
800051fa:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800051fc:	78 e8       	ld.w	r8,r12[0x38]
800051fe:	58 08       	cp.w	r8,0
80005200:	c0 31       	brne	80005206 <xQueueReceiveFromISR+0x12>
80005202:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005206:	f0 1f 00 0e 	mcall	8000523c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000520a:	6e e8       	ld.w	r8,r7[0x38]
8000520c:	20 18       	sub	r8,1
8000520e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005210:	6f 18       	ld.w	r8,r7[0x44]
80005212:	5b f8       	cp.w	r8,-1
80005214:	c0 d1       	brne	8000522e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005216:	6e 48       	ld.w	r8,r7[0x10]
80005218:	58 08       	cp.w	r8,0
8000521a:	c0 f0       	breq	80005238 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000521c:	ee cc ff f0 	sub	r12,r7,-16
80005220:	f0 1f 00 08 	mcall	80005240 <xQueueReceiveFromISR+0x4c>
80005224:	c0 a0       	breq	80005238 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005226:	30 1c       	mov	r12,1
80005228:	8d 0c       	st.w	r6[0x0],r12
8000522a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000522e:	2f f8       	sub	r8,-1
80005230:	ef 48 00 44 	st.w	r7[68],r8
80005234:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005238:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	51 c4       	stdsp	sp[0x70],r4
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	57 fc       	stdsp	sp[0x1fc],r12

80005244 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005244:	eb cd 40 c0 	pushm	r6-r7,lr
80005248:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000524a:	f0 1f 00 23 	mcall	800052d4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000524e:	6f 28       	ld.w	r8,r7[0x48]
80005250:	58 08       	cp.w	r8,0
80005252:	e0 8a 00 18 	brle	80005282 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005256:	6e 98       	ld.w	r8,r7[0x24]
80005258:	58 08       	cp.w	r8,0
8000525a:	c1 40       	breq	80005282 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000525c:	ee c6 ff dc 	sub	r6,r7,-36
80005260:	c0 48       	rjmp	80005268 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005262:	6e 98       	ld.w	r8,r7[0x24]
80005264:	58 08       	cp.w	r8,0
80005266:	c0 e0       	breq	80005282 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005268:	0c 9c       	mov	r12,r6
8000526a:	f0 1f 00 1c 	mcall	800052d8 <prvUnlockQueue+0x94>
8000526e:	c0 30       	breq	80005274 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005270:	f0 1f 00 1b 	mcall	800052dc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005274:	6f 28       	ld.w	r8,r7[0x48]
80005276:	20 18       	sub	r8,1
80005278:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000527c:	58 08       	cp.w	r8,0
8000527e:	fe 99 ff f2 	brgt	80005262 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005282:	3f f8       	mov	r8,-1
80005284:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005288:	f0 1f 00 16 	mcall	800052e0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000528c:	f0 1f 00 12 	mcall	800052d4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005290:	6f 18       	ld.w	r8,r7[0x44]
80005292:	58 08       	cp.w	r8,0
80005294:	e0 8a 00 18 	brle	800052c4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005298:	6e 48       	ld.w	r8,r7[0x10]
8000529a:	58 08       	cp.w	r8,0
8000529c:	c1 40       	breq	800052c4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000529e:	ee c6 ff f0 	sub	r6,r7,-16
800052a2:	c0 48       	rjmp	800052aa <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052a4:	6e 48       	ld.w	r8,r7[0x10]
800052a6:	58 08       	cp.w	r8,0
800052a8:	c0 e0       	breq	800052c4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800052aa:	0c 9c       	mov	r12,r6
800052ac:	f0 1f 00 0b 	mcall	800052d8 <prvUnlockQueue+0x94>
800052b0:	c0 30       	breq	800052b6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800052b2:	f0 1f 00 0b 	mcall	800052dc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800052b6:	6f 18       	ld.w	r8,r7[0x44]
800052b8:	20 18       	sub	r8,1
800052ba:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800052be:	58 08       	cp.w	r8,0
800052c0:	fe 99 ff f2 	brgt	800052a4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800052c4:	3f f8       	mov	r8,-1
800052c6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800052ca:	f0 1f 00 06 	mcall	800052e0 <prvUnlockQueue+0x9c>
}
800052ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052d2:	00 00       	add	r0,r0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	4f 30       	lddpc	r0,800054a0 <xQueueGenericSendFromISR>
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	57 fc       	stdsp	sp[0x1fc],r12
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	57 08       	stdsp	sp[0x1c0],r8
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	50 3c       	stdsp	sp[0xc],r12

800052e4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800052e4:	d4 31       	pushm	r0-r7,lr
800052e6:	20 5d       	sub	sp,20
800052e8:	18 97       	mov	r7,r12
800052ea:	50 0b       	stdsp	sp[0x0],r11
800052ec:	50 2a       	stdsp	sp[0x8],r10
800052ee:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800052f0:	f8 c2 ff dc 	sub	r2,r12,-36
800052f4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800052f6:	fa c4 ff f4 	sub	r4,sp,-12
800052fa:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800052fc:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800052fe:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005302:	f0 1f 00 3e 	mcall	800053f8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005306:	6e e8       	ld.w	r8,r7[0x38]
80005308:	58 08       	cp.w	r8,0
8000530a:	c2 a0       	breq	8000535e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000530c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000530e:	40 0b       	lddsp	r11,sp[0x0]
80005310:	0e 9c       	mov	r12,r7
80005312:	f0 1f 00 3b 	mcall	800053fc <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005316:	40 18       	lddsp	r8,sp[0x4]
80005318:	58 08       	cp.w	r8,0
8000531a:	c1 51       	brne	80005344 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000531c:	6e e8       	ld.w	r8,r7[0x38]
8000531e:	20 18       	sub	r8,1
80005320:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005322:	6e 08       	ld.w	r8,r7[0x0]
80005324:	58 08       	cp.w	r8,0
80005326:	c0 41       	brne	8000532e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005328:	f0 1f 00 36 	mcall	80005400 <xQueueGenericReceive+0x11c>
8000532c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000532e:	6e 48       	ld.w	r8,r7[0x10]
80005330:	58 08       	cp.w	r8,0
80005332:	c1 20       	breq	80005356 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005334:	ee cc ff f0 	sub	r12,r7,-16
80005338:	f0 1f 00 33 	mcall	80005404 <xQueueGenericReceive+0x120>
8000533c:	58 1c       	cp.w	r12,1
8000533e:	c0 c1       	brne	80005356 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005340:	d7 33       	scall
80005342:	c0 a8       	rjmp	80005356 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005344:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005346:	6e 98       	ld.w	r8,r7[0x24]
80005348:	58 08       	cp.w	r8,0
8000534a:	c0 60       	breq	80005356 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000534c:	04 9c       	mov	r12,r2
8000534e:	f0 1f 00 2e 	mcall	80005404 <xQueueGenericReceive+0x120>
80005352:	c0 20       	breq	80005356 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005354:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005356:	f0 1f 00 2d 	mcall	80005408 <xQueueGenericReceive+0x124>
8000535a:	30 1c       	mov	r12,1
				return pdPASS;
8000535c:	c4 c8       	rjmp	800053f4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000535e:	40 28       	lddsp	r8,sp[0x8]
80005360:	58 08       	cp.w	r8,0
80005362:	c0 51       	brne	8000536c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005364:	f0 1f 00 29 	mcall	80005408 <xQueueGenericReceive+0x124>
80005368:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000536a:	c4 58       	rjmp	800053f4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000536c:	58 05       	cp.w	r5,0
8000536e:	c0 51       	brne	80005378 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005370:	08 9c       	mov	r12,r4
80005372:	f0 1f 00 27 	mcall	8000540c <xQueueGenericReceive+0x128>
80005376:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005378:	f0 1f 00 24 	mcall	80005408 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000537c:	f0 1f 00 25 	mcall	80005410 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005380:	f0 1f 00 1e 	mcall	800053f8 <xQueueGenericReceive+0x114>
80005384:	6f 18       	ld.w	r8,r7[0x44]
80005386:	5b f8       	cp.w	r8,-1
80005388:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000538c:	6f 28       	ld.w	r8,r7[0x48]
8000538e:	5b f8       	cp.w	r8,-1
80005390:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005394:	f0 1f 00 1d 	mcall	80005408 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005398:	06 9b       	mov	r11,r3
8000539a:	08 9c       	mov	r12,r4
8000539c:	f0 1f 00 1e 	mcall	80005414 <xQueueGenericReceive+0x130>
800053a0:	c2 41       	brne	800053e8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800053a2:	f0 1f 00 16 	mcall	800053f8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800053a6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800053a8:	f0 1f 00 18 	mcall	80005408 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800053ac:	58 06       	cp.w	r6,0
800053ae:	c1 71       	brne	800053dc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800053b0:	6e 08       	ld.w	r8,r7[0x0]
800053b2:	58 08       	cp.w	r8,0
800053b4:	c0 81       	brne	800053c4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800053b6:	f0 1f 00 11 	mcall	800053f8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800053ba:	6e 1c       	ld.w	r12,r7[0x4]
800053bc:	f0 1f 00 17 	mcall	80005418 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800053c0:	f0 1f 00 12 	mcall	80005408 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800053c4:	40 2b       	lddsp	r11,sp[0x8]
800053c6:	04 9c       	mov	r12,r2
800053c8:	f0 1f 00 15 	mcall	8000541c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800053cc:	0e 9c       	mov	r12,r7
800053ce:	f0 1f 00 15 	mcall	80005420 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800053d2:	f0 1f 00 15 	mcall	80005424 <xQueueGenericReceive+0x140>
800053d6:	c9 61       	brne	80005302 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800053d8:	d7 33       	scall
800053da:	c9 4b       	rjmp	80005302 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800053dc:	0e 9c       	mov	r12,r7
800053de:	f0 1f 00 11 	mcall	80005420 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800053e2:	f0 1f 00 11 	mcall	80005424 <xQueueGenericReceive+0x140>
800053e6:	c8 eb       	rjmp	80005302 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800053e8:	0e 9c       	mov	r12,r7
800053ea:	f0 1f 00 0e 	mcall	80005420 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800053ee:	f0 1f 00 0e 	mcall	80005424 <xQueueGenericReceive+0x140>
800053f2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800053f4:	2f bd       	sub	sp,-20
800053f6:	d8 32       	popm	r0-r7,pc
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	4f 30       	lddpc	r0,800055c4 <xQueueGenericSend+0xd4>
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	51 c4       	stdsp	sp[0x70],r4
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	57 14       	stdsp	sp[0x1c4],r4
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	57 fc       	stdsp	sp[0x1fc],r12
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	50 3c       	stdsp	sp[0xc],r12
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	56 f0       	stdsp	sp[0x1bc],r0
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	56 64       	stdsp	sp[0x198],r4
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	59 8c       	cp.w	r12,24
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	57 78       	stdsp	sp[0x1dc],r8
8000541c:	80 00       	ld.sh	r0,r0[0x0]
8000541e:	5b e4       	cp.w	r4,-2
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	52 44       	stdsp	sp[0x90],r4
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	5a 20       	cp.w	r0,-30

80005428 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005428:	eb cd 40 80 	pushm	r7,lr
8000542c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000542e:	79 08       	ld.w	r8,r12[0x40]
80005430:	58 08       	cp.w	r8,0
80005432:	c0 a1       	brne	80005446 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005434:	78 08       	ld.w	r8,r12[0x0]
80005436:	58 08       	cp.w	r8,0
80005438:	c2 b1       	brne	8000548e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000543a:	78 1c       	ld.w	r12,r12[0x4]
8000543c:	f0 1f 00 17 	mcall	80005498 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005440:	30 08       	mov	r8,0
80005442:	8f 18       	st.w	r7[0x4],r8
80005444:	c2 58       	rjmp	8000548e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005446:	58 0a       	cp.w	r10,0
80005448:	c1 01       	brne	80005468 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000544a:	10 9a       	mov	r10,r8
8000544c:	78 2c       	ld.w	r12,r12[0x8]
8000544e:	f0 1f 00 14 	mcall	8000549c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005452:	6e 29       	ld.w	r9,r7[0x8]
80005454:	6f 08       	ld.w	r8,r7[0x40]
80005456:	f2 08 00 08 	add	r8,r9,r8
8000545a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000545c:	6e 19       	ld.w	r9,r7[0x4]
8000545e:	12 38       	cp.w	r8,r9
80005460:	c1 73       	brcs	8000548e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005462:	6e 08       	ld.w	r8,r7[0x0]
80005464:	8f 28       	st.w	r7[0x8],r8
80005466:	c1 48       	rjmp	8000548e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005468:	10 9a       	mov	r10,r8
8000546a:	78 3c       	ld.w	r12,r12[0xc]
8000546c:	f0 1f 00 0c 	mcall	8000549c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005470:	6f 08       	ld.w	r8,r7[0x40]
80005472:	6e 39       	ld.w	r9,r7[0xc]
80005474:	f2 08 01 08 	sub	r8,r9,r8
80005478:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000547a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000547c:	12 38       	cp.w	r8,r9
8000547e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005482:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005486:	f3 d8 e3 19 	subcs	r9,r9,r8
8000548a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000548e:	6e e8       	ld.w	r8,r7[0x38]
80005490:	2f f8       	sub	r8,-1
80005492:	8f e8       	st.w	r7[0x38],r8
}
80005494:	e3 cd 80 80 	ldm	sp++,r7,pc
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	57 20       	stdsp	sp[0x1c8],r0
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	69 1c       	ld.w	r12,r4[0x44]

800054a0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800054a0:	eb cd 40 c0 	pushm	r6-r7,lr
800054a4:	18 97       	mov	r7,r12
800054a6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800054a8:	78 ec       	ld.w	r12,r12[0x38]
800054aa:	6e f8       	ld.w	r8,r7[0x3c]
800054ac:	10 3c       	cp.w	r12,r8
800054ae:	c0 33       	brcs	800054b4 <xQueueGenericSendFromISR+0x14>
800054b0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800054b4:	12 9a       	mov	r10,r9
800054b6:	0e 9c       	mov	r12,r7
800054b8:	f0 1f 00 0c 	mcall	800054e8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800054bc:	6f 28       	ld.w	r8,r7[0x48]
800054be:	5b f8       	cp.w	r8,-1
800054c0:	c0 d1       	brne	800054da <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054c2:	6e 98       	ld.w	r8,r7[0x24]
800054c4:	58 08       	cp.w	r8,0
800054c6:	c0 f0       	breq	800054e4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054c8:	ee cc ff dc 	sub	r12,r7,-36
800054cc:	f0 1f 00 08 	mcall	800054ec <xQueueGenericSendFromISR+0x4c>
800054d0:	c0 a0       	breq	800054e4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800054d2:	30 1c       	mov	r12,1
800054d4:	8d 0c       	st.w	r6[0x0],r12
800054d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800054da:	2f f8       	sub	r8,-1
800054dc:	ef 48 00 48 	st.w	r7[72],r8
800054e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800054e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 28       	stdsp	sp[0x108],r8
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	57 fc       	stdsp	sp[0x1fc],r12

800054f0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800054f0:	d4 31       	pushm	r0-r7,lr
800054f2:	20 5d       	sub	sp,20
800054f4:	18 97       	mov	r7,r12
800054f6:	50 0b       	stdsp	sp[0x0],r11
800054f8:	50 2a       	stdsp	sp[0x8],r10
800054fa:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800054fc:	f8 c0 ff f0 	sub	r0,r12,-16
80005500:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005502:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005506:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005508:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000550c:	f0 1f 00 2f 	mcall	800055c8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005510:	6e e9       	ld.w	r9,r7[0x38]
80005512:	6e f8       	ld.w	r8,r7[0x3c]
80005514:	10 39       	cp.w	r9,r8
80005516:	c1 42       	brcc	8000553e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005518:	40 1a       	lddsp	r10,sp[0x4]
8000551a:	40 0b       	lddsp	r11,sp[0x0]
8000551c:	0e 9c       	mov	r12,r7
8000551e:	f0 1f 00 2c 	mcall	800055cc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005522:	6e 98       	ld.w	r8,r7[0x24]
80005524:	58 08       	cp.w	r8,0
80005526:	c0 80       	breq	80005536 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005528:	ee cc ff dc 	sub	r12,r7,-36
8000552c:	f0 1f 00 29 	mcall	800055d0 <xQueueGenericSend+0xe0>
80005530:	58 1c       	cp.w	r12,1
80005532:	c0 21       	brne	80005536 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005534:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005536:	f0 1f 00 28 	mcall	800055d4 <xQueueGenericSend+0xe4>
8000553a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000553c:	c4 38       	rjmp	800055c2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000553e:	40 28       	lddsp	r8,sp[0x8]
80005540:	58 08       	cp.w	r8,0
80005542:	c0 51       	brne	8000554c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005544:	f0 1f 00 24 	mcall	800055d4 <xQueueGenericSend+0xe4>
80005548:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000554a:	c3 c8       	rjmp	800055c2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000554c:	58 04       	cp.w	r4,0
8000554e:	c0 51       	brne	80005558 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005550:	06 9c       	mov	r12,r3
80005552:	f0 1f 00 22 	mcall	800055d8 <xQueueGenericSend+0xe8>
80005556:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005558:	f0 1f 00 1f 	mcall	800055d4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000555c:	f0 1f 00 20 	mcall	800055dc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005560:	f0 1f 00 1a 	mcall	800055c8 <xQueueGenericSend+0xd8>
80005564:	6f 18       	ld.w	r8,r7[0x44]
80005566:	5b f8       	cp.w	r8,-1
80005568:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000556c:	6f 28       	ld.w	r8,r7[0x48]
8000556e:	5b f8       	cp.w	r8,-1
80005570:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005574:	f0 1f 00 18 	mcall	800055d4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005578:	04 9b       	mov	r11,r2
8000557a:	06 9c       	mov	r12,r3
8000557c:	f0 1f 00 19 	mcall	800055e0 <xQueueGenericSend+0xf0>
80005580:	c1 b1       	brne	800055b6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005582:	f0 1f 00 12 	mcall	800055c8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005586:	6e e5       	ld.w	r5,r7[0x38]
80005588:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000558a:	f0 1f 00 13 	mcall	800055d4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000558e:	0c 35       	cp.w	r5,r6
80005590:	c0 d1       	brne	800055aa <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005592:	40 2b       	lddsp	r11,sp[0x8]
80005594:	00 9c       	mov	r12,r0
80005596:	f0 1f 00 14 	mcall	800055e4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000559a:	0e 9c       	mov	r12,r7
8000559c:	f0 1f 00 13 	mcall	800055e8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800055a0:	f0 1f 00 13 	mcall	800055ec <xQueueGenericSend+0xfc>
800055a4:	cb 41       	brne	8000550c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800055a6:	d7 33       	scall
800055a8:	cb 2b       	rjmp	8000550c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800055aa:	0e 9c       	mov	r12,r7
800055ac:	f0 1f 00 0f 	mcall	800055e8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800055b0:	f0 1f 00 0f 	mcall	800055ec <xQueueGenericSend+0xfc>
800055b4:	ca cb       	rjmp	8000550c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800055b6:	0e 9c       	mov	r12,r7
800055b8:	f0 1f 00 0c 	mcall	800055e8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800055bc:	f0 1f 00 0c 	mcall	800055ec <xQueueGenericSend+0xfc>
800055c0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800055c2:	2f bd       	sub	sp,-20
800055c4:	d8 32       	popm	r0-r7,pc
800055c6:	00 00       	add	r0,r0
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	4f 30       	lddpc	r0,80005794 <vTaskPriorityInherit+0x1c>
800055cc:	80 00       	ld.sh	r0,r0[0x0]
800055ce:	54 28       	stdsp	sp[0x108],r8
800055d0:	80 00       	ld.sh	r0,r0[0x0]
800055d2:	57 fc       	stdsp	sp[0x1fc],r12
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	50 3c       	stdsp	sp[0xc],r12
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	56 f0       	stdsp	sp[0x1bc],r0
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	56 64       	stdsp	sp[0x198],r4
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	59 8c       	cp.w	r12,24
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	5b e4       	cp.w	r4,-2
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	52 44       	stdsp	sp[0x90],r4
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	5a 20       	cp.w	r0,-30

800055f0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800055f0:	d4 21       	pushm	r4-r7,lr
800055f2:	18 97       	mov	r7,r12
800055f4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800055f6:	58 0c       	cp.w	r12,0
800055f8:	c2 f0       	breq	80005656 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800055fa:	34 cc       	mov	r12,76
800055fc:	f0 1f 00 17 	mcall	80005658 <xQueueCreate+0x68>
80005600:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005602:	c2 a0       	breq	80005656 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005604:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005608:	e8 cc ff ff 	sub	r12,r4,-1
8000560c:	f0 1f 00 13 	mcall	80005658 <xQueueCreate+0x68>
80005610:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005612:	c1 e0       	breq	8000564e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005614:	f8 04 00 04 	add	r4,r12,r4
80005618:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000561a:	30 08       	mov	r8,0
8000561c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000561e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005620:	ee c8 00 01 	sub	r8,r7,1
80005624:	ad 38       	mul	r8,r6
80005626:	10 0c       	add	r12,r8
80005628:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000562a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000562c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005630:	3f f8       	mov	r8,-1
80005632:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005636:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000563a:	ea cc ff f0 	sub	r12,r5,-16
8000563e:	f0 1f 00 08 	mcall	8000565c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005642:	ea cc ff dc 	sub	r12,r5,-36
80005646:	f0 1f 00 06 	mcall	8000565c <xQueueCreate+0x6c>
8000564a:	0a 9c       	mov	r12,r5
8000564c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000564e:	0a 9c       	mov	r12,r5
80005650:	f0 1f 00 04 	mcall	80005660 <xQueueCreate+0x70>
80005654:	d8 2a       	popm	r4-r7,pc,r12=0
80005656:	d8 2a       	popm	r4-r7,pc,r12=0
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	51 9c       	stdsp	sp[0x64],r12
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	4e 0c       	lddpc	r12,800057dc <vTaskPriorityInherit+0x64>
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	51 74       	stdsp	sp[0x5c],r4

80005664 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005664:	48 38       	lddpc	r8,80005670 <vTaskSuspendAll+0xc>
80005666:	70 09       	ld.w	r9,r8[0x0]
80005668:	2f f9       	sub	r9,-1
8000566a:	91 09       	st.w	r8[0x0],r9
}
8000566c:	5e fc       	retal	r12
8000566e:	00 00       	add	r0,r0
80005670:	00 00       	add	r0,r0
80005672:	0c f8       	st.b	--r6,r8

80005674 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005674:	49 a8       	lddpc	r8,800056dc <vTaskSwitchContext+0x68>
80005676:	70 08       	ld.w	r8,r8[0x0]
80005678:	58 08       	cp.w	r8,0
8000567a:	c0 b1       	brne	80005690 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000567c:	49 98       	lddpc	r8,800056e0 <vTaskSwitchContext+0x6c>
8000567e:	70 08       	ld.w	r8,r8[0x0]
80005680:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005684:	49 89       	lddpc	r9,800056e4 <vTaskSwitchContext+0x70>
80005686:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000568a:	58 08       	cp.w	r8,0
8000568c:	c0 60       	breq	80005698 <vTaskSwitchContext+0x24>
8000568e:	c1 18       	rjmp	800056b0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005690:	30 19       	mov	r9,1
80005692:	49 68       	lddpc	r8,800056e8 <vTaskSwitchContext+0x74>
80005694:	91 09       	st.w	r8[0x0],r9
80005696:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005698:	49 28       	lddpc	r8,800056e0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000569a:	49 3a       	lddpc	r10,800056e4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000569c:	70 09       	ld.w	r9,r8[0x0]
8000569e:	20 19       	sub	r9,1
800056a0:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800056a2:	70 09       	ld.w	r9,r8[0x0]
800056a4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800056a8:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800056ac:	58 09       	cp.w	r9,0
800056ae:	cf 70       	breq	8000569c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800056b0:	48 c8       	lddpc	r8,800056e0 <vTaskSwitchContext+0x6c>
800056b2:	70 08       	ld.w	r8,r8[0x0]
800056b4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800056b8:	48 b9       	lddpc	r9,800056e4 <vTaskSwitchContext+0x70>
800056ba:	f2 08 00 28 	add	r8,r9,r8<<0x2
800056be:	70 19       	ld.w	r9,r8[0x4]
800056c0:	72 19       	ld.w	r9,r9[0x4]
800056c2:	91 19       	st.w	r8[0x4],r9
800056c4:	f0 ca ff f8 	sub	r10,r8,-8
800056c8:	14 39       	cp.w	r9,r10
800056ca:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800056ce:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800056d2:	70 18       	ld.w	r8,r8[0x4]
800056d4:	70 39       	ld.w	r9,r8[0xc]
800056d6:	48 68       	lddpc	r8,800056ec <vTaskSwitchContext+0x78>
800056d8:	91 09       	st.w	r8[0x0],r9
800056da:	5e fc       	retal	r12
800056dc:	00 00       	add	r0,r0
800056de:	0c f8       	st.b	--r6,r8
800056e0:	00 00       	add	r0,r0
800056e2:	0d 30       	ld.ub	r0,r6++
800056e4:	00 00       	add	r0,r0
800056e6:	0c 14       	sub	r4,r6
800056e8:	00 00       	add	r0,r0
800056ea:	0d 18       	ld.sh	r8,r6++
800056ec:	00 00       	add	r0,r0
800056ee:	0c c8       	st.b	r6++,r8

800056f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800056f0:	48 48       	lddpc	r8,80005700 <vTaskSetTimeOutState+0x10>
800056f2:	70 08       	ld.w	r8,r8[0x0]
800056f4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800056f6:	48 48       	lddpc	r8,80005704 <vTaskSetTimeOutState+0x14>
800056f8:	70 08       	ld.w	r8,r8[0x0]
800056fa:	99 18       	st.w	r12[0x4],r8
}
800056fc:	5e fc       	retal	r12
800056fe:	00 00       	add	r0,r0
80005700:	00 00       	add	r0,r0
80005702:	0c 0c       	add	r12,r6
80005704:	00 00       	add	r0,r0
80005706:	0c f4       	st.b	--r6,r4

80005708 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005708:	30 19       	mov	r9,1
8000570a:	48 28       	lddpc	r8,80005710 <vTaskMissedYield+0x8>
8000570c:	91 09       	st.w	r8[0x0],r9
}
8000570e:	5e fc       	retal	r12
80005710:	00 00       	add	r0,r0
80005712:	0d 18       	ld.sh	r8,r6++

80005714 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005714:	48 28       	lddpc	r8,8000571c <xTaskGetCurrentTaskHandle+0x8>
80005716:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005718:	5e fc       	retal	r12
8000571a:	00 00       	add	r0,r0
8000571c:	00 00       	add	r0,r0
8000571e:	0c c8       	st.b	r6++,r8

80005720 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005720:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005724:	58 0c       	cp.w	r12,0
80005726:	c1 f0       	breq	80005764 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005728:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000572a:	78 b9       	ld.w	r9,r12[0x2c]
8000572c:	79 18       	ld.w	r8,r12[0x44]
8000572e:	10 39       	cp.w	r9,r8
80005730:	c1 a0       	breq	80005764 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005732:	f8 c6 ff fc 	sub	r6,r12,-4
80005736:	0c 9c       	mov	r12,r6
80005738:	f0 1f 00 0c 	mcall	80005768 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000573c:	6f 1c       	ld.w	r12,r7[0x44]
8000573e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005740:	f8 08 11 08 	rsub	r8,r12,8
80005744:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005746:	48 a8       	lddpc	r8,8000576c <vTaskPriorityDisinherit+0x4c>
80005748:	70 08       	ld.w	r8,r8[0x0]
8000574a:	10 3c       	cp.w	r12,r8
8000574c:	e0 88 00 04 	brls	80005754 <vTaskPriorityDisinherit+0x34>
80005750:	48 78       	lddpc	r8,8000576c <vTaskPriorityDisinherit+0x4c>
80005752:	91 0c       	st.w	r8[0x0],r12
80005754:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005758:	0c 9b       	mov	r11,r6
8000575a:	48 68       	lddpc	r8,80005770 <vTaskPriorityDisinherit+0x50>
8000575c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005760:	f0 1f 00 05 	mcall	80005774 <vTaskPriorityDisinherit+0x54>
80005764:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	4e 76       	lddpc	r6,80005904 <vTaskIncrementTick+0x8c>
8000576c:	00 00       	add	r0,r0
8000576e:	0d 30       	ld.ub	r0,r6++
80005770:	00 00       	add	r0,r0
80005772:	0c 14       	sub	r4,r6
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	4e 26       	lddpc	r6,800058fc <vTaskIncrementTick+0x84>

80005778 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005778:	eb cd 40 c0 	pushm	r6-r7,lr
8000577c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000577e:	49 b8       	lddpc	r8,800057e8 <vTaskPriorityInherit+0x70>
80005780:	70 08       	ld.w	r8,r8[0x0]
80005782:	78 b9       	ld.w	r9,r12[0x2c]
80005784:	70 b8       	ld.w	r8,r8[0x2c]
80005786:	10 39       	cp.w	r9,r8
80005788:	c2 d2       	brcc	800057e2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000578a:	49 88       	lddpc	r8,800057e8 <vTaskPriorityInherit+0x70>
8000578c:	70 08       	ld.w	r8,r8[0x0]
8000578e:	70 b8       	ld.w	r8,r8[0x2c]
80005790:	f0 08 11 08 	rsub	r8,r8,8
80005794:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005796:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000579a:	49 59       	lddpc	r9,800057ec <vTaskPriorityInherit+0x74>
8000579c:	f2 08 00 28 	add	r8,r9,r8<<0x2
800057a0:	78 59       	ld.w	r9,r12[0x14]
800057a2:	10 39       	cp.w	r9,r8
800057a4:	c1 b1       	brne	800057da <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800057a6:	f8 c6 ff fc 	sub	r6,r12,-4
800057aa:	0c 9c       	mov	r12,r6
800057ac:	f0 1f 00 11 	mcall	800057f0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800057b0:	48 e8       	lddpc	r8,800057e8 <vTaskPriorityInherit+0x70>
800057b2:	70 08       	ld.w	r8,r8[0x0]
800057b4:	70 bc       	ld.w	r12,r8[0x2c]
800057b6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800057b8:	48 f8       	lddpc	r8,800057f4 <vTaskPriorityInherit+0x7c>
800057ba:	70 08       	ld.w	r8,r8[0x0]
800057bc:	10 3c       	cp.w	r12,r8
800057be:	e0 88 00 04 	brls	800057c6 <vTaskPriorityInherit+0x4e>
800057c2:	48 d8       	lddpc	r8,800057f4 <vTaskPriorityInherit+0x7c>
800057c4:	91 0c       	st.w	r8[0x0],r12
800057c6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800057ca:	0c 9b       	mov	r11,r6
800057cc:	48 88       	lddpc	r8,800057ec <vTaskPriorityInherit+0x74>
800057ce:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800057d2:	f0 1f 00 0a 	mcall	800057f8 <vTaskPriorityInherit+0x80>
800057d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800057da:	48 48       	lddpc	r8,800057e8 <vTaskPriorityInherit+0x70>
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	70 b8       	ld.w	r8,r8[0x2c]
800057e0:	99 b8       	st.w	r12[0x2c],r8
800057e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057e6:	00 00       	add	r0,r0
800057e8:	00 00       	add	r0,r0
800057ea:	0c c8       	st.b	r6++,r8
800057ec:	00 00       	add	r0,r0
800057ee:	0c 14       	sub	r4,r6
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	4e 76       	lddpc	r6,8000598c <xTaskCheckForTimeOut>
800057f4:	00 00       	add	r0,r0
800057f6:	0d 30       	ld.ub	r0,r6++
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	4e 26       	lddpc	r6,80005980 <vTaskIncrementTick+0x108>

800057fc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800057fc:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005800:	78 38       	ld.w	r8,r12[0xc]
80005802:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005804:	ee c6 ff e8 	sub	r6,r7,-24
80005808:	0c 9c       	mov	r12,r6
8000580a:	f0 1f 00 15 	mcall	8000585c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000580e:	49 58       	lddpc	r8,80005860 <xTaskRemoveFromEventList+0x64>
80005810:	70 08       	ld.w	r8,r8[0x0]
80005812:	58 08       	cp.w	r8,0
80005814:	c1 71       	brne	80005842 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005816:	ee c6 ff fc 	sub	r6,r7,-4
8000581a:	0c 9c       	mov	r12,r6
8000581c:	f0 1f 00 10 	mcall	8000585c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005820:	6e bc       	ld.w	r12,r7[0x2c]
80005822:	49 18       	lddpc	r8,80005864 <xTaskRemoveFromEventList+0x68>
80005824:	70 08       	ld.w	r8,r8[0x0]
80005826:	10 3c       	cp.w	r12,r8
80005828:	e0 88 00 04 	brls	80005830 <xTaskRemoveFromEventList+0x34>
8000582c:	48 e8       	lddpc	r8,80005864 <xTaskRemoveFromEventList+0x68>
8000582e:	91 0c       	st.w	r8[0x0],r12
80005830:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005834:	0c 9b       	mov	r11,r6
80005836:	48 d8       	lddpc	r8,80005868 <xTaskRemoveFromEventList+0x6c>
80005838:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000583c:	f0 1f 00 0c 	mcall	8000586c <xTaskRemoveFromEventList+0x70>
80005840:	c0 58       	rjmp	8000584a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005842:	0c 9b       	mov	r11,r6
80005844:	48 bc       	lddpc	r12,80005870 <xTaskRemoveFromEventList+0x74>
80005846:	f0 1f 00 0a 	mcall	8000586c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000584a:	48 b8       	lddpc	r8,80005874 <xTaskRemoveFromEventList+0x78>
8000584c:	70 08       	ld.w	r8,r8[0x0]
8000584e:	6e b9       	ld.w	r9,r7[0x2c]
80005850:	70 b8       	ld.w	r8,r8[0x2c]
80005852:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005854:	5f 2c       	srhs	r12
80005856:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000585a:	00 00       	add	r0,r0
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	4e 76       	lddpc	r6,800059f8 <xTaskCheckForTimeOut+0x6c>
80005860:	00 00       	add	r0,r0
80005862:	0c f8       	st.b	--r6,r8
80005864:	00 00       	add	r0,r0
80005866:	0d 30       	ld.ub	r0,r6++
80005868:	00 00       	add	r0,r0
8000586a:	0c 14       	sub	r4,r6
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	4e 26       	lddpc	r6,800059f4 <xTaskCheckForTimeOut+0x68>
80005870:	00 00       	add	r0,r0
80005872:	0c cc       	st.b	r6++,r12
80005874:	00 00       	add	r0,r0
80005876:	0c c8       	st.b	r6++,r8

80005878 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005878:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000587c:	4b 98       	lddpc	r8,80005960 <vTaskIncrementTick+0xe8>
8000587e:	70 08       	ld.w	r8,r8[0x0]
80005880:	58 08       	cp.w	r8,0
80005882:	c6 91       	brne	80005954 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005884:	4b 88       	lddpc	r8,80005964 <vTaskIncrementTick+0xec>
80005886:	70 09       	ld.w	r9,r8[0x0]
80005888:	2f f9       	sub	r9,-1
8000588a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000588c:	70 08       	ld.w	r8,r8[0x0]
8000588e:	58 08       	cp.w	r8,0
80005890:	c1 a1       	brne	800058c4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005892:	4b 68       	lddpc	r8,80005968 <vTaskIncrementTick+0xf0>
80005894:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005896:	4b 69       	lddpc	r9,8000596c <vTaskIncrementTick+0xf4>
80005898:	72 0b       	ld.w	r11,r9[0x0]
8000589a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000589c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000589e:	4b 59       	lddpc	r9,80005970 <vTaskIncrementTick+0xf8>
800058a0:	72 0a       	ld.w	r10,r9[0x0]
800058a2:	2f fa       	sub	r10,-1
800058a4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800058a6:	70 08       	ld.w	r8,r8[0x0]
800058a8:	70 08       	ld.w	r8,r8[0x0]
800058aa:	58 08       	cp.w	r8,0
800058ac:	c0 51       	brne	800058b6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800058ae:	3f f9       	mov	r9,-1
800058b0:	4b 18       	lddpc	r8,80005974 <vTaskIncrementTick+0xfc>
800058b2:	91 09       	st.w	r8[0x0],r9
800058b4:	c0 88       	rjmp	800058c4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800058b6:	4a d8       	lddpc	r8,80005968 <vTaskIncrementTick+0xf0>
800058b8:	70 08       	ld.w	r8,r8[0x0]
800058ba:	70 38       	ld.w	r8,r8[0xc]
800058bc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800058be:	70 19       	ld.w	r9,r8[0x4]
800058c0:	4a d8       	lddpc	r8,80005974 <vTaskIncrementTick+0xfc>
800058c2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800058c4:	4a 88       	lddpc	r8,80005964 <vTaskIncrementTick+0xec>
800058c6:	70 09       	ld.w	r9,r8[0x0]
800058c8:	4a b8       	lddpc	r8,80005974 <vTaskIncrementTick+0xfc>
800058ca:	70 08       	ld.w	r8,r8[0x0]
800058cc:	10 39       	cp.w	r9,r8
800058ce:	c4 73       	brcs	8000595c <vTaskIncrementTick+0xe4>
800058d0:	4a 68       	lddpc	r8,80005968 <vTaskIncrementTick+0xf0>
800058d2:	70 08       	ld.w	r8,r8[0x0]
800058d4:	70 08       	ld.w	r8,r8[0x0]
800058d6:	58 08       	cp.w	r8,0
800058d8:	c0 c0       	breq	800058f0 <vTaskIncrementTick+0x78>
800058da:	4a 48       	lddpc	r8,80005968 <vTaskIncrementTick+0xf0>
800058dc:	70 08       	ld.w	r8,r8[0x0]
800058de:	70 38       	ld.w	r8,r8[0xc]
800058e0:	70 37       	ld.w	r7,r8[0xc]
800058e2:	6e 18       	ld.w	r8,r7[0x4]
800058e4:	4a 09       	lddpc	r9,80005964 <vTaskIncrementTick+0xec>
800058e6:	72 09       	ld.w	r9,r9[0x0]
800058e8:	12 38       	cp.w	r8,r9
800058ea:	e0 88 00 14 	brls	80005912 <vTaskIncrementTick+0x9a>
800058ee:	c0 e8       	rjmp	8000590a <vTaskIncrementTick+0x92>
800058f0:	3f f9       	mov	r9,-1
800058f2:	4a 18       	lddpc	r8,80005974 <vTaskIncrementTick+0xfc>
800058f4:	91 09       	st.w	r8[0x0],r9
800058f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800058fa:	6a 08       	ld.w	r8,r5[0x0]
800058fc:	70 38       	ld.w	r8,r8[0xc]
800058fe:	70 37       	ld.w	r7,r8[0xc]
80005900:	6e 18       	ld.w	r8,r7[0x4]
80005902:	64 09       	ld.w	r9,r2[0x0]
80005904:	12 38       	cp.w	r8,r9
80005906:	e0 88 00 0a 	brls	8000591a <vTaskIncrementTick+0xa2>
8000590a:	49 b9       	lddpc	r9,80005974 <vTaskIncrementTick+0xfc>
8000590c:	93 08       	st.w	r9[0x0],r8
8000590e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005912:	49 a4       	lddpc	r4,80005978 <vTaskIncrementTick+0x100>
80005914:	49 a3       	lddpc	r3,8000597c <vTaskIncrementTick+0x104>
80005916:	49 55       	lddpc	r5,80005968 <vTaskIncrementTick+0xf0>
80005918:	49 32       	lddpc	r2,80005964 <vTaskIncrementTick+0xec>
8000591a:	ee c6 ff fc 	sub	r6,r7,-4
8000591e:	0c 9c       	mov	r12,r6
80005920:	f0 1f 00 18 	mcall	80005980 <vTaskIncrementTick+0x108>
80005924:	6e a8       	ld.w	r8,r7[0x28]
80005926:	58 08       	cp.w	r8,0
80005928:	c0 50       	breq	80005932 <vTaskIncrementTick+0xba>
8000592a:	ee cc ff e8 	sub	r12,r7,-24
8000592e:	f0 1f 00 15 	mcall	80005980 <vTaskIncrementTick+0x108>
80005932:	6e bc       	ld.w	r12,r7[0x2c]
80005934:	68 08       	ld.w	r8,r4[0x0]
80005936:	10 3c       	cp.w	r12,r8
80005938:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000593c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005940:	0c 9b       	mov	r11,r6
80005942:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005946:	f0 1f 00 10 	mcall	80005984 <vTaskIncrementTick+0x10c>
8000594a:	6a 08       	ld.w	r8,r5[0x0]
8000594c:	70 08       	ld.w	r8,r8[0x0]
8000594e:	58 08       	cp.w	r8,0
80005950:	cd 51       	brne	800058fa <vTaskIncrementTick+0x82>
80005952:	cc fb       	rjmp	800058f0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005954:	48 d8       	lddpc	r8,80005988 <vTaskIncrementTick+0x110>
80005956:	70 09       	ld.w	r9,r8[0x0]
80005958:	2f f9       	sub	r9,-1
8000595a:	91 09       	st.w	r8[0x0],r9
8000595c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005960:	00 00       	add	r0,r0
80005962:	0c f8       	st.b	--r6,r8
80005964:	00 00       	add	r0,r0
80005966:	0c f4       	st.b	--r6,r4
80005968:	00 00       	add	r0,r0
8000596a:	0c 00       	add	r0,r6
8000596c:	00 00       	add	r0,r0
8000596e:	0c 10       	sub	r0,r6
80005970:	00 00       	add	r0,r0
80005972:	0c 0c       	add	r12,r6
80005974:	00 00       	add	r0,r0
80005976:	05 28       	ld.uh	r8,r2++
80005978:	00 00       	add	r0,r0
8000597a:	0d 30       	ld.ub	r0,r6++
8000597c:	00 00       	add	r0,r0
8000597e:	0c 14       	sub	r4,r6
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	4e 76       	lddpc	r6,80005b1c <prvAddCurrentTaskToDelayedList+0x14>
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	4e 26       	lddpc	r6,80005b0c <prvAddCurrentTaskToDelayedList+0x4>
80005988:	00 00       	add	r0,r0
8000598a:	0b f8       	ld.ub	r8,r5[0x7]

8000598c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000598c:	eb cd 40 c0 	pushm	r6-r7,lr
80005990:	18 97       	mov	r7,r12
80005992:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005994:	f0 1f 00 15 	mcall	800059e8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005998:	6c 08       	ld.w	r8,r6[0x0]
8000599a:	5b f8       	cp.w	r8,-1
8000599c:	c0 31       	brne	800059a2 <xTaskCheckForTimeOut+0x16>
8000599e:	30 07       	mov	r7,0
800059a0:	c1 f8       	rjmp	800059de <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800059a2:	49 39       	lddpc	r9,800059ec <xTaskCheckForTimeOut+0x60>
800059a4:	72 09       	ld.w	r9,r9[0x0]
800059a6:	6e 0a       	ld.w	r10,r7[0x0]
800059a8:	12 3a       	cp.w	r10,r9
800059aa:	c0 70       	breq	800059b8 <xTaskCheckForTimeOut+0x2c>
800059ac:	49 19       	lddpc	r9,800059f0 <xTaskCheckForTimeOut+0x64>
800059ae:	72 09       	ld.w	r9,r9[0x0]
800059b0:	6e 1a       	ld.w	r10,r7[0x4]
800059b2:	12 3a       	cp.w	r10,r9
800059b4:	e0 88 00 14 	brls	800059dc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800059b8:	48 e9       	lddpc	r9,800059f0 <xTaskCheckForTimeOut+0x64>
800059ba:	72 0a       	ld.w	r10,r9[0x0]
800059bc:	6e 19       	ld.w	r9,r7[0x4]
800059be:	12 1a       	sub	r10,r9
800059c0:	14 38       	cp.w	r8,r10
800059c2:	e0 88 00 0d 	brls	800059dc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800059c6:	48 ba       	lddpc	r10,800059f0 <xTaskCheckForTimeOut+0x64>
800059c8:	74 0a       	ld.w	r10,r10[0x0]
800059ca:	14 19       	sub	r9,r10
800059cc:	f2 08 00 08 	add	r8,r9,r8
800059d0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800059d2:	0e 9c       	mov	r12,r7
800059d4:	f0 1f 00 08 	mcall	800059f4 <xTaskCheckForTimeOut+0x68>
800059d8:	30 07       	mov	r7,0
800059da:	c0 28       	rjmp	800059de <xTaskCheckForTimeOut+0x52>
800059dc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800059de:	f0 1f 00 07 	mcall	800059f8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800059e2:	0e 9c       	mov	r12,r7
800059e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	4f 30       	lddpc	r0,80005bb4 <vTaskDelayUntil+0x50>
800059ec:	00 00       	add	r0,r0
800059ee:	0c 0c       	add	r12,r6
800059f0:	00 00       	add	r0,r0
800059f2:	0c f4       	st.b	--r6,r4
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	56 f0       	stdsp	sp[0x1bc],r0
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	50 3c       	stdsp	sp[0xc],r12

800059fc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800059fc:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005a00:	f0 1f 00 05 	mcall	80005a14 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005a04:	48 58       	lddpc	r8,80005a18 <xTaskGetTickCount+0x1c>
80005a06:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005a08:	f0 1f 00 05 	mcall	80005a1c <xTaskGetTickCount+0x20>

	return xTicks;
}
80005a0c:	0e 9c       	mov	r12,r7
80005a0e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a12:	00 00       	add	r0,r0
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	4f 30       	lddpc	r0,80005be0 <vTaskDelayUntil+0x7c>
80005a18:	00 00       	add	r0,r0
80005a1a:	0c f4       	st.b	--r6,r4
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	50 3c       	stdsp	sp[0xc],r12

80005a20 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005a20:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005a24:	f0 1f 00 2c 	mcall	80005ad4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005a28:	4a c8       	lddpc	r8,80005ad8 <xTaskResumeAll+0xb8>
80005a2a:	70 09       	ld.w	r9,r8[0x0]
80005a2c:	20 19       	sub	r9,1
80005a2e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a30:	70 08       	ld.w	r8,r8[0x0]
80005a32:	58 08       	cp.w	r8,0
80005a34:	c4 91       	brne	80005ac6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005a36:	4a a8       	lddpc	r8,80005adc <xTaskResumeAll+0xbc>
80005a38:	70 08       	ld.w	r8,r8[0x0]
80005a3a:	58 08       	cp.w	r8,0
80005a3c:	c4 50       	breq	80005ac6 <xTaskResumeAll+0xa6>
80005a3e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005a40:	4a 85       	lddpc	r5,80005ae0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005a42:	4a 93       	lddpc	r3,80005ae4 <xTaskResumeAll+0xc4>
80005a44:	4a 92       	lddpc	r2,80005ae8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a46:	4a a1       	lddpc	r1,80005aec <xTaskResumeAll+0xcc>
80005a48:	c1 e8       	rjmp	80005a84 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005a4a:	6a 38       	ld.w	r8,r5[0xc]
80005a4c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005a4e:	ee cc ff e8 	sub	r12,r7,-24
80005a52:	f0 1f 00 28 	mcall	80005af0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005a56:	ee c6 ff fc 	sub	r6,r7,-4
80005a5a:	0c 9c       	mov	r12,r6
80005a5c:	f0 1f 00 25 	mcall	80005af0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005a60:	6e bc       	ld.w	r12,r7[0x2c]
80005a62:	66 08       	ld.w	r8,r3[0x0]
80005a64:	10 3c       	cp.w	r12,r8
80005a66:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005a6a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a6e:	0c 9b       	mov	r11,r6
80005a70:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005a74:	f0 1f 00 20 	mcall	80005af4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a78:	62 08       	ld.w	r8,r1[0x0]
80005a7a:	6e b9       	ld.w	r9,r7[0x2c]
80005a7c:	70 b8       	ld.w	r8,r8[0x2c]
80005a7e:	10 39       	cp.w	r9,r8
80005a80:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005a84:	6a 08       	ld.w	r8,r5[0x0]
80005a86:	58 08       	cp.w	r8,0
80005a88:	ce 11       	brne	80005a4a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a8a:	49 c8       	lddpc	r8,80005af8 <xTaskResumeAll+0xd8>
80005a8c:	70 08       	ld.w	r8,r8[0x0]
80005a8e:	58 08       	cp.w	r8,0
80005a90:	c0 f0       	breq	80005aae <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a92:	49 a8       	lddpc	r8,80005af8 <xTaskResumeAll+0xd8>
80005a94:	70 08       	ld.w	r8,r8[0x0]
80005a96:	58 08       	cp.w	r8,0
80005a98:	c1 10       	breq	80005aba <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005a9a:	49 87       	lddpc	r7,80005af8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005a9c:	f0 1f 00 18 	mcall	80005afc <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005aa0:	6e 08       	ld.w	r8,r7[0x0]
80005aa2:	20 18       	sub	r8,1
80005aa4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005aa6:	6e 08       	ld.w	r8,r7[0x0]
80005aa8:	58 08       	cp.w	r8,0
80005aaa:	cf 91       	brne	80005a9c <xTaskResumeAll+0x7c>
80005aac:	c0 78       	rjmp	80005aba <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005aae:	58 14       	cp.w	r4,1
80005ab0:	c0 50       	breq	80005aba <xTaskResumeAll+0x9a>
80005ab2:	49 48       	lddpc	r8,80005b00 <xTaskResumeAll+0xe0>
80005ab4:	70 08       	ld.w	r8,r8[0x0]
80005ab6:	58 18       	cp.w	r8,1
80005ab8:	c0 71       	brne	80005ac6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005aba:	30 09       	mov	r9,0
80005abc:	49 18       	lddpc	r8,80005b00 <xTaskResumeAll+0xe0>
80005abe:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005ac0:	d7 33       	scall
80005ac2:	30 17       	mov	r7,1
80005ac4:	c0 28       	rjmp	80005ac8 <xTaskResumeAll+0xa8>
80005ac6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005ac8:	f0 1f 00 0f 	mcall	80005b04 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005acc:	0e 9c       	mov	r12,r7
80005ace:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005ad2:	00 00       	add	r0,r0
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	4f 30       	lddpc	r0,80005ca0 <prvIdleTask+0x64>
80005ad8:	00 00       	add	r0,r0
80005ada:	0c f8       	st.b	--r6,r8
80005adc:	00 00       	add	r0,r0
80005ade:	0d 14       	ld.sh	r4,r6++
80005ae0:	00 00       	add	r0,r0
80005ae2:	0c cc       	st.b	r6++,r12
80005ae4:	00 00       	add	r0,r0
80005ae6:	0d 30       	ld.ub	r0,r6++
80005ae8:	00 00       	add	r0,r0
80005aea:	0c 14       	sub	r4,r6
80005aec:	00 00       	add	r0,r0
80005aee:	0c c8       	st.b	r6++,r8
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	4e 76       	lddpc	r6,80005c8c <prvIdleTask+0x50>
80005af4:	80 00       	ld.sh	r0,r0[0x0]
80005af6:	4e 26       	lddpc	r6,80005c7c <prvIdleTask+0x40>
80005af8:	00 00       	add	r0,r0
80005afa:	0b f8       	ld.ub	r8,r5[0x7]
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	58 78       	cp.w	r8,7
80005b00:	00 00       	add	r0,r0
80005b02:	0d 18       	ld.sh	r8,r6++
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	50 3c       	stdsp	sp[0xc],r12

80005b08 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005b08:	eb cd 40 80 	pushm	r7,lr
80005b0c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005b0e:	49 08       	lddpc	r8,80005b4c <prvAddCurrentTaskToDelayedList+0x44>
80005b10:	70 08       	ld.w	r8,r8[0x0]
80005b12:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005b14:	48 f8       	lddpc	r8,80005b50 <prvAddCurrentTaskToDelayedList+0x48>
80005b16:	70 08       	ld.w	r8,r8[0x0]
80005b18:	10 3c       	cp.w	r12,r8
80005b1a:	c0 a2       	brcc	80005b2e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b1c:	48 c8       	lddpc	r8,80005b4c <prvAddCurrentTaskToDelayedList+0x44>
80005b1e:	70 0b       	ld.w	r11,r8[0x0]
80005b20:	48 d8       	lddpc	r8,80005b54 <prvAddCurrentTaskToDelayedList+0x4c>
80005b22:	70 0c       	ld.w	r12,r8[0x0]
80005b24:	2f cb       	sub	r11,-4
80005b26:	f0 1f 00 0d 	mcall	80005b58 <prvAddCurrentTaskToDelayedList+0x50>
80005b2a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b2e:	48 88       	lddpc	r8,80005b4c <prvAddCurrentTaskToDelayedList+0x44>
80005b30:	70 0b       	ld.w	r11,r8[0x0]
80005b32:	48 b8       	lddpc	r8,80005b5c <prvAddCurrentTaskToDelayedList+0x54>
80005b34:	70 0c       	ld.w	r12,r8[0x0]
80005b36:	2f cb       	sub	r11,-4
80005b38:	f0 1f 00 08 	mcall	80005b58 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005b3c:	48 98       	lddpc	r8,80005b60 <prvAddCurrentTaskToDelayedList+0x58>
80005b3e:	70 08       	ld.w	r8,r8[0x0]
80005b40:	10 37       	cp.w	r7,r8
80005b42:	c0 32       	brcc	80005b48 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005b44:	48 78       	lddpc	r8,80005b60 <prvAddCurrentTaskToDelayedList+0x58>
80005b46:	91 07       	st.w	r8[0x0],r7
80005b48:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b4c:	00 00       	add	r0,r0
80005b4e:	0c c8       	st.b	r6++,r8
80005b50:	00 00       	add	r0,r0
80005b52:	0c f4       	st.b	--r6,r4
80005b54:	00 00       	add	r0,r0
80005b56:	0c 10       	sub	r0,r6
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	4e 42       	lddpc	r2,80005ce8 <xTaskGenericCreate+0x24>
80005b5c:	00 00       	add	r0,r0
80005b5e:	0c 00       	add	r0,r6
80005b60:	00 00       	add	r0,r0
80005b62:	05 28       	ld.uh	r8,r2++

80005b64 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005b64:	eb cd 40 c0 	pushm	r6-r7,lr
80005b68:	18 96       	mov	r6,r12
80005b6a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005b6c:	f0 1f 00 18 	mcall	80005bcc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005b70:	6c 08       	ld.w	r8,r6[0x0]
80005b72:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005b74:	49 79       	lddpc	r9,80005bd0 <vTaskDelayUntil+0x6c>
80005b76:	72 09       	ld.w	r9,r9[0x0]
80005b78:	12 38       	cp.w	r8,r9
80005b7a:	e0 88 00 0c 	brls	80005b92 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005b7e:	0e 38       	cp.w	r8,r7
80005b80:	e0 88 00 22 	brls	80005bc4 <vTaskDelayUntil+0x60>
80005b84:	49 38       	lddpc	r8,80005bd0 <vTaskDelayUntil+0x6c>
80005b86:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b88:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005b8a:	10 37       	cp.w	r7,r8
80005b8c:	e0 88 00 14 	brls	80005bb4 <vTaskDelayUntil+0x50>
80005b90:	c0 a8       	rjmp	80005ba4 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005b92:	0e 38       	cp.w	r8,r7
80005b94:	e0 8b 00 16 	brhi	80005bc0 <vTaskDelayUntil+0x5c>
80005b98:	48 e8       	lddpc	r8,80005bd0 <vTaskDelayUntil+0x6c>
80005b9a:	70 08       	ld.w	r8,r8[0x0]
80005b9c:	10 37       	cp.w	r7,r8
80005b9e:	e0 8b 00 11 	brhi	80005bc0 <vTaskDelayUntil+0x5c>
80005ba2:	c1 18       	rjmp	80005bc4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ba4:	48 c8       	lddpc	r8,80005bd4 <vTaskDelayUntil+0x70>
80005ba6:	70 0c       	ld.w	r12,r8[0x0]
80005ba8:	2f cc       	sub	r12,-4
80005baa:	f0 1f 00 0c 	mcall	80005bd8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005bae:	0e 9c       	mov	r12,r7
80005bb0:	f0 1f 00 0b 	mcall	80005bdc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005bb4:	f0 1f 00 0b 	mcall	80005be0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005bb8:	c0 81       	brne	80005bc8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005bba:	d7 33       	scall
80005bbc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005bc0:	8d 07       	st.w	r6[0x0],r7
80005bc2:	cf 1b       	rjmp	80005ba4 <vTaskDelayUntil+0x40>
80005bc4:	8d 07       	st.w	r6[0x0],r7
80005bc6:	cf 7b       	rjmp	80005bb4 <vTaskDelayUntil+0x50>
80005bc8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	56 64       	stdsp	sp[0x198],r4
80005bd0:	00 00       	add	r0,r0
80005bd2:	0c f4       	st.b	--r6,r4
80005bd4:	00 00       	add	r0,r0
80005bd6:	0c c8       	st.b	r6++,r8
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	4e 76       	lddpc	r6,80005d74 <xTaskGenericCreate+0xb0>
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	5b 08       	cp.w	r8,-16
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	5a 20       	cp.w	r0,-30

80005be4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005be4:	eb cd 40 c0 	pushm	r6-r7,lr
80005be8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005bea:	48 e7       	lddpc	r7,80005c20 <vTaskPlaceOnEventList+0x3c>
80005bec:	6e 0b       	ld.w	r11,r7[0x0]
80005bee:	2e 8b       	sub	r11,-24
80005bf0:	f0 1f 00 0d 	mcall	80005c24 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005bf4:	6e 0c       	ld.w	r12,r7[0x0]
80005bf6:	2f cc       	sub	r12,-4
80005bf8:	f0 1f 00 0c 	mcall	80005c28 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005bfc:	5b f6       	cp.w	r6,-1
80005bfe:	c0 81       	brne	80005c0e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c00:	6e 0b       	ld.w	r11,r7[0x0]
80005c02:	2f cb       	sub	r11,-4
80005c04:	48 ac       	lddpc	r12,80005c2c <vTaskPlaceOnEventList+0x48>
80005c06:	f0 1f 00 0b 	mcall	80005c30 <vTaskPlaceOnEventList+0x4c>
80005c0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005c0e:	48 a8       	lddpc	r8,80005c34 <vTaskPlaceOnEventList+0x50>
80005c10:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005c12:	ec 0c 00 0c 	add	r12,r6,r12
80005c16:	f0 1f 00 09 	mcall	80005c38 <vTaskPlaceOnEventList+0x54>
80005c1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c1e:	00 00       	add	r0,r0
80005c20:	00 00       	add	r0,r0
80005c22:	0c c8       	st.b	r6++,r8
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	4e 42       	lddpc	r2,80005db4 <xTaskGenericCreate+0xf0>
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	4e 76       	lddpc	r6,80005dc4 <xTaskGenericCreate+0x100>
80005c2c:	00 00       	add	r0,r0
80005c2e:	0d 1c       	ld.sh	r12,r6++
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	4e 26       	lddpc	r6,80005db8 <xTaskGenericCreate+0xf4>
80005c34:	00 00       	add	r0,r0
80005c36:	0c f4       	st.b	--r6,r4
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	5b 08       	cp.w	r8,-16

80005c3c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005c3c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005c40:	49 67       	lddpc	r7,80005c98 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005c42:	49 74       	lddpc	r4,80005c9c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005c44:	49 73       	lddpc	r3,80005ca0 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005c46:	49 85       	lddpc	r5,80005ca4 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005c48:	6e 08       	ld.w	r8,r7[0x0]
80005c4a:	58 08       	cp.w	r8,0
80005c4c:	c1 e0       	breq	80005c88 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005c4e:	f0 1f 00 17 	mcall	80005ca8 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005c52:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005c54:	f0 1f 00 16 	mcall	80005cac <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005c58:	58 06       	cp.w	r6,0
80005c5a:	c1 70       	breq	80005c88 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005c5c:	f0 1f 00 15 	mcall	80005cb0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005c60:	68 38       	ld.w	r8,r4[0xc]
80005c62:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c64:	ec cc ff fc 	sub	r12,r6,-4
80005c68:	f0 1f 00 13 	mcall	80005cb4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005c6c:	66 08       	ld.w	r8,r3[0x0]
80005c6e:	20 18       	sub	r8,1
80005c70:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005c72:	6e 08       	ld.w	r8,r7[0x0]
80005c74:	20 18       	sub	r8,1
80005c76:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005c78:	f0 1f 00 10 	mcall	80005cb8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005c7c:	6c cc       	ld.w	r12,r6[0x30]
80005c7e:	f0 1f 00 10 	mcall	80005cbc <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005c82:	0c 9c       	mov	r12,r6
80005c84:	f0 1f 00 0e 	mcall	80005cbc <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005c88:	6a 08       	ld.w	r8,r5[0x0]
80005c8a:	58 18       	cp.w	r8,1
80005c8c:	e0 88 00 03 	brls	80005c92 <prvIdleTask+0x56>
			{
				taskYIELD();
80005c90:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005c92:	f0 1f 00 0c 	mcall	80005cc0 <prvIdleTask+0x84>
		}
		#endif
	}
80005c96:	cd 9b       	rjmp	80005c48 <prvIdleTask+0xc>
80005c98:	00 00       	add	r0,r0
80005c9a:	0c 08       	add	r8,r6
80005c9c:	00 00       	add	r0,r0
80005c9e:	0c b4       	st.h	r6++,r4
80005ca0:	00 00       	add	r0,r0
80005ca2:	0d 14       	ld.sh	r4,r6++
80005ca4:	00 00       	add	r0,r0
80005ca6:	0c 14       	sub	r4,r6
80005ca8:	80 00       	ld.sh	r0,r0[0x0]
80005caa:	56 64       	stdsp	sp[0x198],r4
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	5a 20       	cp.w	r0,-30
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	4f 30       	lddpc	r0,80005e7c <xTaskGenericCreate+0x1b8>
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	4e 76       	lddpc	r6,80005e50 <xTaskGenericCreate+0x18c>
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	50 3c       	stdsp	sp[0xc],r12
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	51 74       	stdsp	sp[0x5c],r4
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	20 2c       	sub	r12,2

80005cc4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005cc4:	d4 31       	pushm	r0-r7,lr
80005cc6:	20 1d       	sub	sp,4
80005cc8:	fa c4 ff d8 	sub	r4,sp,-40
80005ccc:	50 0c       	stdsp	sp[0x0],r12
80005cce:	16 91       	mov	r1,r11
80005cd0:	14 97       	mov	r7,r10
80005cd2:	12 90       	mov	r0,r9
80005cd4:	10 93       	mov	r3,r8
80005cd6:	68 02       	ld.w	r2,r4[0x0]
80005cd8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005cda:	34 8c       	mov	r12,72
80005cdc:	f0 1f 00 5c 	mcall	80005e4c <xTaskGenericCreate+0x188>
80005ce0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005ce2:	c0 31       	brne	80005ce8 <xTaskGenericCreate+0x24>
80005ce4:	3f fc       	mov	r12,-1
80005ce6:	ca f8       	rjmp	80005e44 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ce8:	58 06       	cp.w	r6,0
80005cea:	e0 81 00 af 	brne	80005e48 <xTaskGenericCreate+0x184>
80005cee:	0e 9c       	mov	r12,r7
80005cf0:	5c 7c       	castu.h	r12
80005cf2:	a3 6c       	lsl	r12,0x2
80005cf4:	f0 1f 00 56 	mcall	80005e4c <xTaskGenericCreate+0x188>
80005cf8:	18 96       	mov	r6,r12
80005cfa:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005cfc:	c0 61       	brne	80005d08 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005cfe:	0a 9c       	mov	r12,r5
80005d00:	f0 1f 00 54 	mcall	80005e50 <xTaskGenericCreate+0x18c>
80005d04:	3f fc       	mov	r12,-1
80005d06:	c9 f8       	rjmp	80005e44 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005d08:	5c 77       	castu.h	r7
80005d0a:	ee 0a 15 02 	lsl	r10,r7,0x2
80005d0e:	e0 6b 00 a5 	mov	r11,165
80005d12:	0c 9c       	mov	r12,r6
80005d14:	f0 1f 00 50 	mcall	80005e54 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005d18:	ee c6 00 01 	sub	r6,r7,1
80005d1c:	6a c8       	ld.w	r8,r5[0x30]
80005d1e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005d22:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005d26:	31 0a       	mov	r10,16
80005d28:	02 9b       	mov	r11,r1
80005d2a:	ea cc ff cc 	sub	r12,r5,-52
80005d2e:	f0 1f 00 4b 	mcall	80005e58 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005d32:	30 08       	mov	r8,0
80005d34:	eb 68 00 43 	st.b	r5[67],r8
80005d38:	58 73       	cp.w	r3,7
80005d3a:	e6 07 17 80 	movls	r7,r3
80005d3e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005d42:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005d44:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005d48:	ea c4 ff fc 	sub	r4,r5,-4
80005d4c:	08 9c       	mov	r12,r4
80005d4e:	f0 1f 00 44 	mcall	80005e5c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005d52:	ea cc ff e8 	sub	r12,r5,-24
80005d56:	f0 1f 00 42 	mcall	80005e5c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005d5a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005d5c:	ee 07 11 08 	rsub	r7,r7,8
80005d60:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005d62:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005d64:	00 9a       	mov	r10,r0
80005d66:	40 0b       	lddsp	r11,sp[0x0]
80005d68:	0c 9c       	mov	r12,r6
80005d6a:	f0 1f 00 3e 	mcall	80005e60 <xTaskGenericCreate+0x19c>
80005d6e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005d70:	58 02       	cp.w	r2,0
80005d72:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005d76:	f0 1f 00 3c 	mcall	80005e64 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005d7a:	4b c8       	lddpc	r8,80005e68 <xTaskGenericCreate+0x1a4>
80005d7c:	70 09       	ld.w	r9,r8[0x0]
80005d7e:	2f f9       	sub	r9,-1
80005d80:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005d82:	4b b8       	lddpc	r8,80005e6c <xTaskGenericCreate+0x1a8>
80005d84:	70 08       	ld.w	r8,r8[0x0]
80005d86:	58 08       	cp.w	r8,0
80005d88:	c2 61       	brne	80005dd4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005d8a:	4b 98       	lddpc	r8,80005e6c <xTaskGenericCreate+0x1a8>
80005d8c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005d8e:	4b 78       	lddpc	r8,80005e68 <xTaskGenericCreate+0x1a4>
80005d90:	70 08       	ld.w	r8,r8[0x0]
80005d92:	58 18       	cp.w	r8,1
80005d94:	c2 b1       	brne	80005dea <xTaskGenericCreate+0x126>
80005d96:	4b 77       	lddpc	r7,80005e70 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005d98:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005d9c:	0e 9c       	mov	r12,r7
80005d9e:	f0 1f 00 36 	mcall	80005e74 <xTaskGenericCreate+0x1b0>
80005da2:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005da4:	0c 37       	cp.w	r7,r6
80005da6:	cf b1       	brne	80005d9c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005da8:	4b 47       	lddpc	r7,80005e78 <xTaskGenericCreate+0x1b4>
80005daa:	0e 9c       	mov	r12,r7
80005dac:	f0 1f 00 32 	mcall	80005e74 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005db0:	4b 36       	lddpc	r6,80005e7c <xTaskGenericCreate+0x1b8>
80005db2:	0c 9c       	mov	r12,r6
80005db4:	f0 1f 00 30 	mcall	80005e74 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005db8:	4b 2c       	lddpc	r12,80005e80 <xTaskGenericCreate+0x1bc>
80005dba:	f0 1f 00 2f 	mcall	80005e74 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005dbe:	4b 2c       	lddpc	r12,80005e84 <xTaskGenericCreate+0x1c0>
80005dc0:	f0 1f 00 2d 	mcall	80005e74 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005dc4:	4b 1c       	lddpc	r12,80005e88 <xTaskGenericCreate+0x1c4>
80005dc6:	f0 1f 00 2c 	mcall	80005e74 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005dca:	4b 18       	lddpc	r8,80005e8c <xTaskGenericCreate+0x1c8>
80005dcc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005dce:	4b 18       	lddpc	r8,80005e90 <xTaskGenericCreate+0x1cc>
80005dd0:	91 06       	st.w	r8[0x0],r6
80005dd2:	c0 c8       	rjmp	80005dea <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005dd4:	4b 08       	lddpc	r8,80005e94 <xTaskGenericCreate+0x1d0>
80005dd6:	70 08       	ld.w	r8,r8[0x0]
80005dd8:	58 08       	cp.w	r8,0
80005dda:	c0 81       	brne	80005dea <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005ddc:	4a 48       	lddpc	r8,80005e6c <xTaskGenericCreate+0x1a8>
80005dde:	70 08       	ld.w	r8,r8[0x0]
80005de0:	70 b8       	ld.w	r8,r8[0x2c]
80005de2:	10 33       	cp.w	r3,r8
80005de4:	c0 33       	brcs	80005dea <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005de6:	4a 28       	lddpc	r8,80005e6c <xTaskGenericCreate+0x1a8>
80005de8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005dea:	6a b8       	ld.w	r8,r5[0x2c]
80005dec:	4a b9       	lddpc	r9,80005e98 <xTaskGenericCreate+0x1d4>
80005dee:	72 09       	ld.w	r9,r9[0x0]
80005df0:	12 38       	cp.w	r8,r9
80005df2:	e0 88 00 04 	brls	80005dfa <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005df6:	4a 99       	lddpc	r9,80005e98 <xTaskGenericCreate+0x1d4>
80005df8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005dfa:	4a 98       	lddpc	r8,80005e9c <xTaskGenericCreate+0x1d8>
80005dfc:	70 09       	ld.w	r9,r8[0x0]
80005dfe:	2f f9       	sub	r9,-1
80005e00:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005e02:	6a b8       	ld.w	r8,r5[0x2c]
80005e04:	4a 79       	lddpc	r9,80005ea0 <xTaskGenericCreate+0x1dc>
80005e06:	72 09       	ld.w	r9,r9[0x0]
80005e08:	12 38       	cp.w	r8,r9
80005e0a:	e0 88 00 04 	brls	80005e12 <xTaskGenericCreate+0x14e>
80005e0e:	4a 59       	lddpc	r9,80005ea0 <xTaskGenericCreate+0x1dc>
80005e10:	93 08       	st.w	r9[0x0],r8
80005e12:	6a bc       	ld.w	r12,r5[0x2c]
80005e14:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e18:	08 9b       	mov	r11,r4
80005e1a:	49 68       	lddpc	r8,80005e70 <xTaskGenericCreate+0x1ac>
80005e1c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e20:	f0 1f 00 21 	mcall	80005ea4 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005e24:	f0 1f 00 21 	mcall	80005ea8 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005e28:	49 b8       	lddpc	r8,80005e94 <xTaskGenericCreate+0x1d0>
80005e2a:	70 08       	ld.w	r8,r8[0x0]
80005e2c:	58 08       	cp.w	r8,0
80005e2e:	c0 a0       	breq	80005e42 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005e30:	48 f8       	lddpc	r8,80005e6c <xTaskGenericCreate+0x1a8>
80005e32:	70 08       	ld.w	r8,r8[0x0]
80005e34:	70 b8       	ld.w	r8,r8[0x2c]
80005e36:	10 33       	cp.w	r3,r8
80005e38:	e0 88 00 05 	brls	80005e42 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005e3c:	d7 33       	scall
80005e3e:	30 1c       	mov	r12,1
80005e40:	c0 28       	rjmp	80005e44 <xTaskGenericCreate+0x180>
80005e42:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005e44:	2f fd       	sub	sp,-4
80005e46:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005e48:	99 c6       	st.w	r12[0x30],r6
80005e4a:	c5 fb       	rjmp	80005d08 <xTaskGenericCreate+0x44>
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	51 9c       	stdsp	sp[0x64],r12
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	51 74       	stdsp	sp[0x5c],r4
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	6a 64       	ld.w	r4,r5[0x18]
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	6d 90       	ld.w	r0,r6[0x64]
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	4e 20       	lddpc	r0,80005fe4 <PrintDec+0x36>
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	4e 9c       	lddpc	r12,80006004 <PrintDec+0x56>
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	4f 30       	lddpc	r0,80006030 <PrintDec+0x82>
80005e68:	00 00       	add	r0,r0
80005e6a:	0d 14       	ld.sh	r4,r6++
80005e6c:	00 00       	add	r0,r0
80005e6e:	0c c8       	st.b	r6++,r8
80005e70:	00 00       	add	r0,r0
80005e72:	0c 14       	sub	r4,r6
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	4e 0c       	lddpc	r12,80005ff4 <PrintDec+0x46>
80005e78:	00 00       	add	r0,r0
80005e7a:	0c e0       	st.h	--r6,r0
80005e7c:	00 00       	add	r0,r0
80005e7e:	0c fc       	st.b	--r6,r12
80005e80:	00 00       	add	r0,r0
80005e82:	0c cc       	st.b	r6++,r12
80005e84:	00 00       	add	r0,r0
80005e86:	0c b4       	st.h	r6++,r4
80005e88:	00 00       	add	r0,r0
80005e8a:	0d 1c       	ld.sh	r12,r6++
80005e8c:	00 00       	add	r0,r0
80005e8e:	0c 00       	add	r0,r6
80005e90:	00 00       	add	r0,r0
80005e92:	0c 10       	sub	r0,r6
80005e94:	00 00       	add	r0,r0
80005e96:	0c 04       	add	r4,r6
80005e98:	00 00       	add	r0,r0
80005e9a:	0b fc       	ld.ub	r12,r5[0x7]
80005e9c:	00 00       	add	r0,r0
80005e9e:	0d 10       	ld.sh	r0,r6++
80005ea0:	00 00       	add	r0,r0
80005ea2:	0d 30       	ld.ub	r0,r6++
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	4e 26       	lddpc	r6,8000602c <PrintDec+0x7e>
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	50 3c       	stdsp	sp[0xc],r12

80005eac <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005eac:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005eae:	30 09       	mov	r9,0
80005eb0:	1a d9       	st.w	--sp,r9
80005eb2:	1a d9       	st.w	--sp,r9
80005eb4:	1a d9       	st.w	--sp,r9
80005eb6:	12 98       	mov	r8,r9
80005eb8:	e0 6a 01 00 	mov	r10,256
80005ebc:	48 9b       	lddpc	r11,80005ee0 <vTaskStartScheduler+0x34>
80005ebe:	48 ac       	lddpc	r12,80005ee4 <vTaskStartScheduler+0x38>
80005ec0:	f0 1f 00 0a 	mcall	80005ee8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005ec4:	2f dd       	sub	sp,-12
80005ec6:	58 1c       	cp.w	r12,1
80005ec8:	c0 a1       	brne	80005edc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005eca:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005ecc:	30 19       	mov	r9,1
80005ece:	48 88       	lddpc	r8,80005eec <vTaskStartScheduler+0x40>
80005ed0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005ed2:	30 09       	mov	r9,0
80005ed4:	48 78       	lddpc	r8,80005ef0 <vTaskStartScheduler+0x44>
80005ed6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005ed8:	f0 1f 00 07 	mcall	80005ef4 <vTaskStartScheduler+0x48>
80005edc:	d8 02       	popm	pc
80005ede:	00 00       	add	r0,r0
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	c8 18       	rjmp	80005fe4 <PrintDec+0x36>
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5c 3c       	neg	r12
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	5c c4       	swap.bh	r4
80005eec:	00 00       	add	r0,r0
80005eee:	0c 04       	add	r4,r6
80005ef0:	00 00       	add	r0,r0
80005ef2:	0c f4       	st.b	--r6,r4
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	4f 40       	lddpc	r0,800060c4 <log+0x3c>

80005ef8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005ef8:	16 cc       	st.b	r11++,r12
	return str;
}
80005efa:	5e fb       	retal	r11

80005efc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005efc:	eb cd 40 c0 	pushm	r6-r7,lr
80005f00:	20 3d       	sub	sp,12
80005f02:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005f04:	30 06       	mov	r6,0
80005f06:	30 07       	mov	r7,0
80005f08:	fa e7 00 00 	st.d	sp[0],r6
80005f0c:	30 0c       	mov	r12,0
80005f0e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005f10:	58 08       	cp.w	r8,0
80005f12:	c1 30       	breq	80005f38 <PrintHex+0x3c>
80005f14:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005f16:	1a 9c       	mov	r12,sp
80005f18:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005f1c:	58 9e       	cp.w	lr,9
80005f1e:	e0 8a 00 04 	brle	80005f26 <PrintHex+0x2a>
80005f22:	2c 9e       	sub	lr,-55
80005f24:	c0 48       	rjmp	80005f2c <PrintHex+0x30>
80005f26:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005f2a:	2d 0e       	sub	lr,-48
80005f2c:	f8 09 0b 0e 	st.b	r12[r9],lr
80005f30:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005f32:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005f34:	cf 21       	brne	80005f18 <PrintHex+0x1c>
80005f36:	c0 48       	rjmp	80005f3e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005f38:	33 08       	mov	r8,48
80005f3a:	ba 88       	st.b	sp[0x0],r8
80005f3c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005f3e:	f6 09 01 08 	sub	r8,r11,r9
80005f42:	58 08       	cp.w	r8,0
80005f44:	e0 8a 00 13 	brle	80005f6a <PrintHex+0x6e>
	{
		char num = len - cnt;
80005f48:	12 1b       	sub	r11,r9
80005f4a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005f4e:	18 9e       	mov	lr,r12
80005f50:	58 0c       	cp.w	r12,0
80005f52:	e0 8a 00 0c 	brle	80005f6a <PrintHex+0x6e>
80005f56:	1a 9b       	mov	r11,sp
80005f58:	12 0b       	add	r11,r9
80005f5a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005f5c:	33 07       	mov	r7,48
80005f5e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005f60:	2f f8       	sub	r8,-1
80005f62:	1c 38       	cp.w	r8,lr
80005f64:	cf d5       	brlt	80005f5e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005f66:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005f6a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005f6e:	f0 cb ff ff 	sub	r11,r8,-1
80005f72:	58 0b       	cp.w	r11,0
80005f74:	e0 8a 00 19 	brle	80005fa6 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005f78:	fa cb ff f4 	sub	r11,sp,-12
80005f7c:	f6 09 00 09 	add	r9,r11,r9
80005f80:	37 8b       	mov	r11,120
80005f82:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005f86:	fa c9 ff f4 	sub	r9,sp,-12
80005f8a:	10 09       	add	r9,r8
80005f8c:	33 0b       	mov	r11,48
80005f8e:	f3 6b ff f4 	st.b	r9[-12],r11
80005f92:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005f96:	fa ce 00 01 	sub	lr,sp,1
80005f9a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005f9c:	11 8b       	ld.ub	r11,r8[0x0]
80005f9e:	12 cb       	st.b	r9++,r11
80005fa0:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005fa2:	1c 38       	cp.w	r8,lr
80005fa4:	cf c1       	brne	80005f9c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005fa6:	14 9c       	mov	r12,r10
80005fa8:	2f dd       	sub	sp,-12
80005faa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005fae <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005fae:	d4 21       	pushm	r4-r7,lr
80005fb0:	20 3d       	sub	sp,12
80005fb2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005fb4:	30 06       	mov	r6,0
80005fb6:	30 07       	mov	r7,0
80005fb8:	fa e7 00 00 	st.d	sp[0],r6
80005fbc:	30 0c       	mov	r12,0
80005fbe:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005fc0:	58 08       	cp.w	r8,0
80005fc2:	c0 35       	brlt	80005fc8 <PrintDec+0x1a>
80005fc4:	14 97       	mov	r7,r10
80005fc6:	c0 58       	rjmp	80005fd0 <PrintDec+0x22>
	{
		*p++ = '-';
80005fc8:	14 97       	mov	r7,r10
80005fca:	32 d9       	mov	r9,45
80005fcc:	0e c9       	st.b	r7++,r9
		i = -i;
80005fce:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005fd0:	58 08       	cp.w	r8,0
80005fd2:	c0 51       	brne	80005fdc <PrintDec+0x2e>
80005fd4:	33 08       	mov	r8,48
80005fd6:	ba 88       	st.b	sp[0x0],r8
80005fd8:	30 1e       	mov	lr,1
80005fda:	c2 f8       	rjmp	80006038 <PrintDec+0x8a>
	
	int ten = i%10;
80005fdc:	e0 65 66 67 	mov	r5,26215
80005fe0:	ea 15 66 66 	orh	r5,0x6666
80005fe4:	f0 05 04 44 	muls.d	r4,r8,r5
80005fe8:	ea 0c 14 02 	asr	r12,r5,0x2
80005fec:	f0 09 14 1f 	asr	r9,r8,0x1f
80005ff0:	f8 09 01 09 	sub	r9,r12,r9
80005ff4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ff8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005ffc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005ffe:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006000:	e0 66 66 67 	mov	r6,26215
80006004:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006008:	2d 09       	sub	r9,-48
8000600a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000600e:	2f fe       	sub	lr,-1
		i /= 10;
80006010:	f0 06 04 44 	muls.d	r4,r8,r6
80006014:	ea 09 14 02 	asr	r9,r5,0x2
80006018:	bf 58       	asr	r8,0x1f
8000601a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000601e:	f0 06 04 44 	muls.d	r4,r8,r6
80006022:	ea 09 14 02 	asr	r9,r5,0x2
80006026:	f0 05 14 1f 	asr	r5,r8,0x1f
8000602a:	0a 19       	sub	r9,r5
8000602c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006030:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006034:	58 08       	cp.w	r8,0
80006036:	ce 91       	brne	80006008 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006038:	f6 0e 01 08 	sub	r8,r11,lr
8000603c:	58 08       	cp.w	r8,0
8000603e:	e0 89 00 06 	brgt	8000604a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006042:	58 0e       	cp.w	lr,0
80006044:	e0 89 00 14 	brgt	8000606c <PrintDec+0xbe>
80006048:	c1 d8       	rjmp	80006082 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000604a:	1c 1b       	sub	r11,lr
8000604c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000604e:	16 9c       	mov	r12,r11
80006050:	58 0b       	cp.w	r11,0
80006052:	fe 9a ff f8 	brle	80006042 <PrintDec+0x94>
80006056:	1a 99       	mov	r9,sp
80006058:	1c 09       	add	r9,lr
8000605a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000605c:	33 06       	mov	r6,48
8000605e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006060:	2f f8       	sub	r8,-1
80006062:	18 38       	cp.w	r8,r12
80006064:	cf d5       	brlt	8000605e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006066:	f6 0e 00 0e 	add	lr,r11,lr
8000606a:	ce cb       	rjmp	80006042 <PrintDec+0x94>
8000606c:	fa c8 ff f4 	sub	r8,sp,-12
80006070:	1c 08       	add	r8,lr
80006072:	20 d8       	sub	r8,13
80006074:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006078:	11 89       	ld.ub	r9,r8[0x0]
8000607a:	0e c9       	st.b	r7++,r9
8000607c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000607e:	16 38       	cp.w	r8,r11
80006080:	cf c1       	brne	80006078 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006082:	14 9c       	mov	r12,r10
80006084:	2f dd       	sub	sp,-12
80006086:	d8 22       	popm	r4-r7,pc

80006088 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006088:	d4 31       	pushm	r0-r7,lr
8000608a:	fa cd 02 08 	sub	sp,sp,520
8000608e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006090:	e0 6a 01 00 	mov	r10,256
80006094:	30 0b       	mov	r11,0
80006096:	fa cc fe f8 	sub	r12,sp,-264
8000609a:	f0 1f 00 4e 	mcall	800061d0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000609e:	fa c4 fd d4 	sub	r4,sp,-556
800060a2:	30 0a       	mov	r10,0
800060a4:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800060a6:	fa c3 ff fc 	sub	r3,sp,-4
800060aa:	e0 61 01 00 	mov	r1,256
800060ae:	14 90       	mov	r0,r10
			
					if(*str == '%')
800060b0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800060b2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800060b6:	02 9a       	mov	r10,r1
800060b8:	00 9b       	mov	r11,r0
800060ba:	06 9c       	mov	r12,r3
800060bc:	f0 1f 00 45 	mcall	800061d0 <log+0x148>
			
					if(*str == '%')
800060c0:	0f 88       	ld.ub	r8,r7[0x0]
800060c2:	e4 08 18 00 	cp.b	r8,r2
800060c6:	c5 71       	brne	80006174 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800060c8:	ee c8 ff ff 	sub	r8,r7,-1
800060cc:	11 89       	ld.ub	r9,r8[0x0]
800060ce:	4c 2a       	lddpc	r10,800061d4 <log+0x14c>
800060d0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800060d2:	23 09       	sub	r9,48
800060d4:	30 9a       	mov	r10,9
800060d6:	f4 09 18 00 	cp.b	r9,r10
800060da:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800060de:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800060e2:	f7 b9 08 30 	subls	r9,48
800060e6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800060ea:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800060ee:	0f 88       	ld.ub	r8,r7[0x0]
800060f0:	22 58       	sub	r8,37
800060f2:	e0 48 00 53 	cp.w	r8,83
800060f6:	e0 8b 00 31 	brhi	80006158 <log+0xd0>
800060fa:	4b 89       	lddpc	r9,800061d8 <log+0x150>
800060fc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006100:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006104:	06 9a       	mov	r10,r3
80006106:	40 0b       	lddsp	r11,sp[0x0]
80006108:	5c 5b       	castu.b	r11
8000610a:	68 0c       	ld.w	r12,r4[0x0]
8000610c:	f0 1f 00 34 	mcall	800061dc <log+0x154>
							break;
80006110:	c2 98       	rjmp	80006162 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006112:	4b 4c       	lddpc	r12,800061e0 <log+0x158>
80006114:	f0 1f 00 34 	mcall	800061e4 <log+0x15c>
80006118:	08 95       	mov	r5,r4
8000611a:	06 9c       	mov	r12,r3
							break;
8000611c:	c2 38       	rjmp	80006162 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000611e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006122:	06 9a       	mov	r10,r3
80006124:	40 0b       	lddsp	r11,sp[0x0]
80006126:	5c 5b       	castu.b	r11
80006128:	68 0c       	ld.w	r12,r4[0x0]
8000612a:	f0 1f 00 30 	mcall	800061e8 <log+0x160>
8000612e:	06 9c       	mov	r12,r3
							break;
80006130:	c1 98       	rjmp	80006162 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006132:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006136:	06 9b       	mov	r11,r3
80006138:	09 bc       	ld.ub	r12,r4[0x3]
8000613a:	f0 1f 00 2d 	mcall	800061ec <log+0x164>
8000613e:	06 9c       	mov	r12,r3
							break;
80006140:	c1 18       	rjmp	80006162 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006142:	e8 c5 ff fc 	sub	r5,r4,-4
80006146:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006148:	c0 d8       	rjmp	80006162 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000614a:	06 9b       	mov	r11,r3
8000614c:	32 5c       	mov	r12,37
8000614e:	f0 1f 00 28 	mcall	800061ec <log+0x164>
80006152:	08 95       	mov	r5,r4
80006154:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006156:	c0 68       	rjmp	80006162 <log+0xda>
							
							default:
							log("I need relax.");
80006158:	4a 6c       	lddpc	r12,800061f0 <log+0x168>
8000615a:	f0 1f 00 23 	mcall	800061e4 <log+0x15c>
8000615e:	08 95       	mov	r5,r4
80006160:	06 9c       	mov	r12,r3
						}
						str++;
80006162:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006164:	1a dc       	st.w	--sp,r12
80006166:	1a d6       	st.w	--sp,r6
80006168:	4a 3b       	lddpc	r11,800061f4 <log+0x16c>
8000616a:	0c 9c       	mov	r12,r6
8000616c:	f0 1f 00 23 	mcall	800061f8 <log+0x170>
80006170:	2f ed       	sub	sp,-8
80006172:	c0 a8       	rjmp	80006186 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006174:	2f f7       	sub	r7,-1
80006176:	1a d8       	st.w	--sp,r8
80006178:	1a d6       	st.w	--sp,r6
8000617a:	4a 1b       	lddpc	r11,800061fc <log+0x174>
8000617c:	0c 9c       	mov	r12,r6
8000617e:	f0 1f 00 1f 	mcall	800061f8 <log+0x170>
80006182:	08 95       	mov	r5,r4
80006184:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006186:	0f 89       	ld.ub	r9,r7[0x0]
80006188:	30 08       	mov	r8,0
8000618a:	f0 09 18 00 	cp.b	r9,r8
8000618e:	c0 30       	breq	80006194 <log+0x10c>
80006190:	0a 94       	mov	r4,r5
80006192:	c9 2b       	rjmp	800060b6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006194:	fa c7 fe f8 	sub	r7,sp,-264
80006198:	1a d7       	st.w	--sp,r7
8000619a:	49 ab       	lddpc	r11,80006200 <log+0x178>
8000619c:	0e 9c       	mov	r12,r7
8000619e:	f0 1f 00 17 	mcall	800061f8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800061a2:	5c 5c       	castu.b	r12
800061a4:	f8 c6 ff ff 	sub	r6,r12,-1
800061a8:	0c 9c       	mov	r12,r6
800061aa:	f0 1f 00 17 	mcall	80006204 <log+0x17c>
800061ae:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800061b0:	0c 9a       	mov	r10,r6
800061b2:	0e 9b       	mov	r11,r7
800061b4:	f0 1f 00 15 	mcall	80006208 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800061b8:	30 09       	mov	r9,0
800061ba:	30 5a       	mov	r10,5
800061bc:	fa cb fe f8 	sub	r11,sp,-264
800061c0:	49 38       	lddpc	r8,8000620c <log+0x184>
800061c2:	70 0c       	ld.w	r12,r8[0x0]
800061c4:	f0 1f 00 13 	mcall	80006210 <log+0x188>
800061c8:	2f fd       	sub	sp,-4
	
	
}
800061ca:	fe 3d fd f8 	sub	sp,-520
800061ce:	d8 32       	popm	r0-r7,pc
800061d0:	80 00       	ld.sh	r0,r0[0x0]
800061d2:	6a 64       	ld.w	r4,r5[0x18]
800061d4:	00 00       	add	r0,r0
800061d6:	0d 34       	ld.ub	r4,r6++
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	c8 20       	breq	800060de <log+0x56>
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	5f ae       	srle	lr
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	ca cc       	rcall	8000633a <logFromISR+0x126>
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	60 88       	ld.w	r8,r0[0x20]
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	5e fc       	retal	r12
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	5e f8       	retal	r8
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	ca dc       	rcall	8000634c <logFromISR+0x138>
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	ca ec       	rcall	80006352 <logFromISR+0x13e>
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	6d 54       	ld.w	r4,r6[0x54]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	ca f4       	brge	8000615c <log+0xd4>
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	ca fc       	rcall	80006360 <logFromISR+0x14c>
80006204:	80 00       	ld.sh	r0,r0[0x0]
80006206:	51 9c       	stdsp	sp[0x64],r12
80006208:	80 00       	ld.sh	r0,r0[0x0]
8000620a:	69 1c       	ld.w	r12,r4[0x44]
8000620c:	00 00       	add	r0,r0
8000620e:	41 04       	lddsp	r4,sp[0x40]
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	54 f0       	stdsp	sp[0x13c],r0

80006214 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006214:	d4 31       	pushm	r0-r7,lr
80006216:	fa cd 02 0c 	sub	sp,sp,524
8000621a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000621c:	e0 6a 01 00 	mov	r10,256
80006220:	30 0b       	mov	r11,0
80006222:	fa cc fe f4 	sub	r12,sp,-268
80006226:	f0 1f 00 4c 	mcall	80006354 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000622a:	fa c4 fd d0 	sub	r4,sp,-560
8000622e:	30 0a       	mov	r10,0
80006230:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006232:	fa c3 ff fc 	sub	r3,sp,-4
80006236:	e0 61 01 00 	mov	r1,256
8000623a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000623c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000623e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006242:	02 9a       	mov	r10,r1
80006244:	00 9b       	mov	r11,r0
80006246:	06 9c       	mov	r12,r3
80006248:	f0 1f 00 43 	mcall	80006354 <logFromISR+0x140>
			
			if(*str == '%')
8000624c:	0f 88       	ld.ub	r8,r7[0x0]
8000624e:	e4 08 18 00 	cp.b	r8,r2
80006252:	c5 11       	brne	800062f4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006254:	ee c8 ff ff 	sub	r8,r7,-1
80006258:	11 89       	ld.ub	r9,r8[0x0]
8000625a:	4c 0a       	lddpc	r10,80006358 <logFromISR+0x144>
8000625c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000625e:	23 09       	sub	r9,48
80006260:	30 9a       	mov	r10,9
80006262:	f4 09 18 00 	cp.b	r9,r10
80006266:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000626a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000626e:	f7 b9 08 30 	subls	r9,48
80006272:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006276:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000627a:	0f 88       	ld.ub	r8,r7[0x0]
8000627c:	22 58       	sub	r8,37
8000627e:	e0 48 00 53 	cp.w	r8,83
80006282:	e0 8b 00 2b 	brhi	800062d8 <logFromISR+0xc4>
80006286:	4b 69       	lddpc	r9,8000635c <logFromISR+0x148>
80006288:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000628c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006290:	06 9a       	mov	r10,r3
80006292:	40 0b       	lddsp	r11,sp[0x0]
80006294:	5c 5b       	castu.b	r11
80006296:	68 0c       	ld.w	r12,r4[0x0]
80006298:	f0 1f 00 32 	mcall	80006360 <logFromISR+0x14c>
					break;
8000629c:	c2 38       	rjmp	800062e2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000629e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800062a2:	06 9a       	mov	r10,r3
800062a4:	40 0b       	lddsp	r11,sp[0x0]
800062a6:	5c 5b       	castu.b	r11
800062a8:	68 0c       	ld.w	r12,r4[0x0]
800062aa:	f0 1f 00 2f 	mcall	80006364 <logFromISR+0x150>
800062ae:	06 9c       	mov	r12,r3
					break;
800062b0:	c1 98       	rjmp	800062e2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800062b2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800062b6:	06 9b       	mov	r11,r3
800062b8:	09 bc       	ld.ub	r12,r4[0x3]
800062ba:	f0 1f 00 2c 	mcall	80006368 <logFromISR+0x154>
800062be:	06 9c       	mov	r12,r3
					break;
800062c0:	c1 18       	rjmp	800062e2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800062c2:	e8 c5 ff fc 	sub	r5,r4,-4
800062c6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800062c8:	c0 d8       	rjmp	800062e2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800062ca:	06 9b       	mov	r11,r3
800062cc:	32 5c       	mov	r12,37
800062ce:	f0 1f 00 27 	mcall	80006368 <logFromISR+0x154>
800062d2:	08 95       	mov	r5,r4
800062d4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800062d6:	c0 68       	rjmp	800062e2 <logFromISR+0xce>
					default:
					log("I need relax.");
800062d8:	4a 5c       	lddpc	r12,8000636c <logFromISR+0x158>
800062da:	f0 1f 00 26 	mcall	80006370 <logFromISR+0x15c>
800062de:	08 95       	mov	r5,r4
800062e0:	06 9c       	mov	r12,r3
				}
				str++;
800062e2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800062e4:	1a dc       	st.w	--sp,r12
800062e6:	1a d6       	st.w	--sp,r6
800062e8:	4a 3b       	lddpc	r11,80006374 <logFromISR+0x160>
800062ea:	0c 9c       	mov	r12,r6
800062ec:	f0 1f 00 23 	mcall	80006378 <logFromISR+0x164>
800062f0:	2f ed       	sub	sp,-8
800062f2:	c0 a8       	rjmp	80006306 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800062f4:	2f f7       	sub	r7,-1
800062f6:	1a d8       	st.w	--sp,r8
800062f8:	1a d6       	st.w	--sp,r6
800062fa:	4a 1b       	lddpc	r11,8000637c <logFromISR+0x168>
800062fc:	0c 9c       	mov	r12,r6
800062fe:	f0 1f 00 1f 	mcall	80006378 <logFromISR+0x164>
80006302:	08 95       	mov	r5,r4
80006304:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006306:	0f 89       	ld.ub	r9,r7[0x0]
80006308:	30 08       	mov	r8,0
8000630a:	f0 09 18 00 	cp.b	r9,r8
8000630e:	c0 30       	breq	80006314 <logFromISR+0x100>
80006310:	0a 94       	mov	r4,r5
80006312:	c9 8b       	rjmp	80006242 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006314:	fa c7 fe f4 	sub	r7,sp,-268
80006318:	1a d7       	st.w	--sp,r7
8000631a:	49 ab       	lddpc	r11,80006380 <logFromISR+0x16c>
8000631c:	0e 9c       	mov	r12,r7
8000631e:	f0 1f 00 17 	mcall	80006378 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006322:	5c 5c       	castu.b	r12
80006324:	f8 c6 ff ff 	sub	r6,r12,-1
80006328:	0c 9c       	mov	r12,r6
8000632a:	f0 1f 00 17 	mcall	80006384 <logFromISR+0x170>
8000632e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006330:	0c 9a       	mov	r10,r6
80006332:	0e 9b       	mov	r11,r7
80006334:	f0 1f 00 15 	mcall	80006388 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006338:	30 09       	mov	r9,0
8000633a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000633c:	fa ca fe f8 	sub	r10,sp,-264
80006340:	fa cb fe f4 	sub	r11,sp,-268
80006344:	49 28       	lddpc	r8,8000638c <logFromISR+0x178>
80006346:	70 0c       	ld.w	r12,r8[0x0]
80006348:	f0 1f 00 12 	mcall	80006390 <logFromISR+0x17c>
8000634c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000634e:	fe 3d fd f4 	sub	sp,-524
80006352:	d8 32       	popm	r0-r7,pc
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	6a 64       	ld.w	r4,r5[0x18]
80006358:	00 00       	add	r0,r0
8000635a:	0d 35       	ld.ub	r5,r6++
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	c9 70       	breq	8000628c <logFromISR+0x78>
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	5f ae       	srle	lr
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	5e fc       	retal	r12
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	5e f8       	retal	r8
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	ca dc       	rcall	800064c8 <free+0x4>
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	60 88       	ld.w	r8,r0[0x20]
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	ca ec       	rcall	800064d2 <free+0xe>
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	6d 54       	ld.w	r4,r6[0x54]
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	ca f4       	brge	800062dc <logFromISR+0xc8>
80006380:	80 00       	ld.sh	r0,r0[0x0]
80006382:	ca fc       	rcall	800064e0 <malloc+0xc>
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	51 9c       	stdsp	sp[0x64],r12
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	69 1c       	ld.w	r12,r4[0x44]
8000638c:	00 00       	add	r0,r0
8000638e:	41 04       	lddsp	r4,sp[0x40]
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	54 a0       	stdsp	sp[0x128],r0

80006394 <log_init>:
		
	return str;
}

void log_init(void)
{
80006394:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006396:	30 2b       	mov	r11,2
80006398:	49 0c       	lddpc	r12,800063d8 <log_init+0x44>
8000639a:	f0 1f 00 11 	mcall	800063dc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000639e:	e0 6a 36 00 	mov	r10,13824
800063a2:	ea 1a 01 6e 	orh	r10,0x16e
800063a6:	48 fb       	lddpc	r11,800063e0 <log_init+0x4c>
800063a8:	fe 7c 18 00 	mov	r12,-59392
800063ac:	f0 1f 00 0e 	mcall	800063e4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800063b0:	30 4b       	mov	r11,4
800063b2:	33 2c       	mov	r12,50
800063b4:	f0 1f 00 0d 	mcall	800063e8 <log_init+0x54>
800063b8:	48 d8       	lddpc	r8,800063ec <log_init+0x58>
800063ba:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800063bc:	30 09       	mov	r9,0
800063be:	1a d9       	st.w	--sp,r9
800063c0:	1a d9       	st.w	--sp,r9
800063c2:	1a d9       	st.w	--sp,r9
800063c4:	30 28       	mov	r8,2
800063c6:	e0 6a 01 80 	mov	r10,384
800063ca:	48 ab       	lddpc	r11,800063f0 <log_init+0x5c>
800063cc:	48 ac       	lddpc	r12,800063f4 <log_init+0x60>
800063ce:	f0 1f 00 0b 	mcall	800063f8 <log_init+0x64>
800063d2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800063d4:	d8 02       	popm	pc
800063d6:	00 00       	add	r0,r0
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	cb 08       	rjmp	8000653a <_malloc_r+0x56>
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	4a 84       	lddpc	r4,8000647c <main+0x3c>
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	ca c0       	breq	8000633a <logFromISR+0x126>
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	4d 00       	lddpc	r0,80006524 <_malloc_r+0x40>
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	55 f0       	stdsp	sp[0x17c],r0
800063ec:	00 00       	add	r0,r0
800063ee:	41 04       	lddsp	r4,sp[0x40]
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	cb 04       	brge	80006352 <logFromISR+0x13e>
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	63 fc       	ld.w	r12,r1[0x7c]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	5c c4       	swap.bh	r4

800063fc <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800063fc:	eb cd 40 f8 	pushm	r3-r7,lr
80006400:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006402:	48 c7       	lddpc	r7,80006430 <task_log+0x34>
80006404:	30 05       	mov	r5,0
80006406:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006408:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000640c:	0a 99       	mov	r9,r5
8000640e:	08 9a       	mov	r10,r4
80006410:	1a 9b       	mov	r11,sp
80006412:	6e 0c       	ld.w	r12,r7[0x0]
80006414:	f0 1f 00 08 	mcall	80006434 <task_log+0x38>
80006418:	58 1c       	cp.w	r12,1
8000641a:	cf 91       	brne	8000640c <task_log+0x10>
		{
			if( NULL != str)
8000641c:	40 0b       	lddsp	r11,sp[0x0]
8000641e:	58 0b       	cp.w	r11,0
80006420:	cf 60       	breq	8000640c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006422:	06 9c       	mov	r12,r3
80006424:	f0 1f 00 05 	mcall	80006438 <task_log+0x3c>
				vPortFree(str);
80006428:	40 0c       	lddsp	r12,sp[0x0]
8000642a:	f0 1f 00 05 	mcall	8000643c <task_log+0x40>
8000642e:	ce fb       	rjmp	8000640c <task_log+0x10>
80006430:	00 00       	add	r0,r0
80006432:	41 04       	lddsp	r4,sp[0x40]
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	52 e4       	stdsp	sp[0xb8],r4
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	4c b0       	lddpc	r0,80006564 <_malloc_r+0x80>
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	51 74       	stdsp	sp[0x5c],r4

80006440 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006440:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006442:	fe 78 10 00 	mov	r8,-61440
80006446:	30 19       	mov	r9,1
80006448:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000644c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006450:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006454:	d3 03       	ssrf	0x10
	local_start_pll0();
80006456:	f0 1f 00 12 	mcall	8000649c <main+0x5c>
		
	INTC_init_interrupts();
8000645a:	f0 1f 00 12 	mcall	800064a0 <main+0x60>
		
	log_init();
8000645e:	f0 1f 00 12 	mcall	800064a4 <main+0x64>
	log("----start debug----");
80006462:	49 2c       	lddpc	r12,800064a8 <main+0x68>
80006464:	f0 1f 00 12 	mcall	800064ac <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006468:	f0 1f 00 12 	mcall	800064b0 <main+0x70>
		
	app_init();
8000646c:	f0 1f 00 12 	mcall	800064b4 <main+0x74>
		
	xcmp_init();
80006470:	f0 1f 00 12 	mcall	800064b8 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006474:	fe 79 10 00 	mov	r9,-61440
80006478:	f2 f8 01 60 	ld.w	r8,r9[352]
8000647c:	e2 18 00 02 	andl	r8,0x2,COH
80006480:	cf c0       	breq	80006478 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006482:	fe 79 10 00 	mov	r9,-61440
80006486:	f2 f8 01 60 	ld.w	r8,r9[352]
8000648a:	e2 18 00 02 	andl	r8,0x2,COH
8000648e:	cf c1       	brne	80006486 <main+0x46>
	local_start_timer();
80006490:	f0 1f 00 0b 	mcall	800064bc <main+0x7c>
		
	Enable_global_interrupt();
80006494:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006496:	f0 1f 00 0b 	mcall	800064c0 <main+0x80>
	return 0;
	
}
8000649a:	d8 0a       	popm	pc,r12=0
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	49 a6       	lddpc	r6,80006504 <_malloc_r+0x20>
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	4b 38       	lddpc	r8,8000656c <_malloc_r+0x88>
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	63 94       	ld.w	r4,r1[0x64]
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	cb 18       	rjmp	8000660c <_malloc_r+0x128>
800064ac:	80 00       	ld.sh	r0,r0[0x0]
800064ae:	60 88       	ld.w	r8,r0[0x20]
800064b0:	80 00       	ld.sh	r0,r0[0x0]
800064b2:	49 a4       	lddpc	r4,80006518 <_malloc_r+0x34>
800064b4:	80 00       	ld.sh	r0,r0[0x0]
800064b6:	20 3c       	sub	r12,3
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	42 28       	lddsp	r8,sp[0x88]
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	49 f6       	lddpc	r6,80006538 <_malloc_r+0x54>
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	5e ac       	retle	r12

800064c4 <free>:
800064c4:	d4 01       	pushm	lr
800064c6:	e0 68 0a 2c 	mov	r8,2604
800064ca:	18 9b       	mov	r11,r12
800064cc:	70 0c       	ld.w	r12,r8[0x0]
800064ce:	e0 a0 1e 61 	rcall	8000a190 <_free_r>
800064d2:	d8 02       	popm	pc

800064d4 <malloc>:
800064d4:	d4 01       	pushm	lr
800064d6:	e0 68 0a 2c 	mov	r8,2604
800064da:	18 9b       	mov	r11,r12
800064dc:	70 0c       	ld.w	r12,r8[0x0]
800064de:	c0 3c       	rcall	800064e4 <_malloc_r>
800064e0:	d8 02       	popm	pc
800064e2:	d7 03       	nop

800064e4 <_malloc_r>:
800064e4:	d4 31       	pushm	r0-r7,lr
800064e6:	f6 c8 ff f5 	sub	r8,r11,-11
800064ea:	18 95       	mov	r5,r12
800064ec:	10 97       	mov	r7,r8
800064ee:	e0 17 ff f8 	andl	r7,0xfff8
800064f2:	59 68       	cp.w	r8,22
800064f4:	f9 b7 08 10 	movls	r7,16
800064f8:	16 37       	cp.w	r7,r11
800064fa:	5f 38       	srlo	r8
800064fc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006500:	c0 50       	breq	8000650a <_malloc_r+0x26>
80006502:	30 c8       	mov	r8,12
80006504:	99 38       	st.w	r12[0xc],r8
80006506:	e0 8f 01 fa 	bral	800068fa <_malloc_r+0x416>
8000650a:	fe b0 f5 eb 	rcall	800050e0 <__malloc_lock>
8000650e:	e0 47 01 f7 	cp.w	r7,503
80006512:	e0 8b 00 1d 	brhi	8000654c <_malloc_r+0x68>
80006516:	ee 03 16 03 	lsr	r3,r7,0x3
8000651a:	e0 68 05 2c 	mov	r8,1324
8000651e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006522:	70 36       	ld.w	r6,r8[0xc]
80006524:	10 36       	cp.w	r6,r8
80006526:	c0 61       	brne	80006532 <_malloc_r+0x4e>
80006528:	ec c8 ff f8 	sub	r8,r6,-8
8000652c:	70 36       	ld.w	r6,r8[0xc]
8000652e:	10 36       	cp.w	r6,r8
80006530:	c0 c0       	breq	80006548 <_malloc_r+0x64>
80006532:	6c 18       	ld.w	r8,r6[0x4]
80006534:	e0 18 ff fc 	andl	r8,0xfffc
80006538:	6c 3a       	ld.w	r10,r6[0xc]
8000653a:	ec 08 00 09 	add	r9,r6,r8
8000653e:	0a 9c       	mov	r12,r5
80006540:	6c 28       	ld.w	r8,r6[0x8]
80006542:	95 28       	st.w	r10[0x8],r8
80006544:	91 3a       	st.w	r8[0xc],r10
80006546:	c4 78       	rjmp	800065d4 <_malloc_r+0xf0>
80006548:	2f e3       	sub	r3,-2
8000654a:	c4 d8       	rjmp	800065e4 <_malloc_r+0x100>
8000654c:	ee 03 16 09 	lsr	r3,r7,0x9
80006550:	c0 41       	brne	80006558 <_malloc_r+0x74>
80006552:	ee 03 16 03 	lsr	r3,r7,0x3
80006556:	c2 68       	rjmp	800065a2 <_malloc_r+0xbe>
80006558:	58 43       	cp.w	r3,4
8000655a:	e0 8b 00 06 	brhi	80006566 <_malloc_r+0x82>
8000655e:	ee 03 16 06 	lsr	r3,r7,0x6
80006562:	2c 83       	sub	r3,-56
80006564:	c1 f8       	rjmp	800065a2 <_malloc_r+0xbe>
80006566:	59 43       	cp.w	r3,20
80006568:	e0 8b 00 04 	brhi	80006570 <_malloc_r+0x8c>
8000656c:	2a 53       	sub	r3,-91
8000656e:	c1 a8       	rjmp	800065a2 <_malloc_r+0xbe>
80006570:	e0 43 00 54 	cp.w	r3,84
80006574:	e0 8b 00 06 	brhi	80006580 <_malloc_r+0x9c>
80006578:	ee 03 16 0c 	lsr	r3,r7,0xc
8000657c:	29 23       	sub	r3,-110
8000657e:	c1 28       	rjmp	800065a2 <_malloc_r+0xbe>
80006580:	e0 43 01 54 	cp.w	r3,340
80006584:	e0 8b 00 06 	brhi	80006590 <_malloc_r+0xac>
80006588:	ee 03 16 0f 	lsr	r3,r7,0xf
8000658c:	28 93       	sub	r3,-119
8000658e:	c0 a8       	rjmp	800065a2 <_malloc_r+0xbe>
80006590:	e0 43 05 54 	cp.w	r3,1364
80006594:	e0 88 00 04 	brls	8000659c <_malloc_r+0xb8>
80006598:	37 e3       	mov	r3,126
8000659a:	c0 48       	rjmp	800065a2 <_malloc_r+0xbe>
8000659c:	ee 03 16 12 	lsr	r3,r7,0x12
800065a0:	28 43       	sub	r3,-124
800065a2:	e0 6a 05 2c 	mov	r10,1324
800065a6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800065aa:	74 36       	ld.w	r6,r10[0xc]
800065ac:	c1 98       	rjmp	800065de <_malloc_r+0xfa>
800065ae:	6c 19       	ld.w	r9,r6[0x4]
800065b0:	e0 19 ff fc 	andl	r9,0xfffc
800065b4:	f2 07 01 0b 	sub	r11,r9,r7
800065b8:	58 fb       	cp.w	r11,15
800065ba:	e0 8a 00 04 	brle	800065c2 <_malloc_r+0xde>
800065be:	20 13       	sub	r3,1
800065c0:	c1 18       	rjmp	800065e2 <_malloc_r+0xfe>
800065c2:	6c 38       	ld.w	r8,r6[0xc]
800065c4:	58 0b       	cp.w	r11,0
800065c6:	c0 b5       	brlt	800065dc <_malloc_r+0xf8>
800065c8:	6c 2a       	ld.w	r10,r6[0x8]
800065ca:	ec 09 00 09 	add	r9,r6,r9
800065ce:	0a 9c       	mov	r12,r5
800065d0:	91 2a       	st.w	r8[0x8],r10
800065d2:	95 38       	st.w	r10[0xc],r8
800065d4:	72 18       	ld.w	r8,r9[0x4]
800065d6:	a1 a8       	sbr	r8,0x0
800065d8:	93 18       	st.w	r9[0x4],r8
800065da:	cb c8       	rjmp	80006752 <_malloc_r+0x26e>
800065dc:	10 96       	mov	r6,r8
800065de:	14 36       	cp.w	r6,r10
800065e0:	ce 71       	brne	800065ae <_malloc_r+0xca>
800065e2:	2f f3       	sub	r3,-1
800065e4:	e0 6a 05 2c 	mov	r10,1324
800065e8:	f4 cc ff f8 	sub	r12,r10,-8
800065ec:	78 26       	ld.w	r6,r12[0x8]
800065ee:	18 36       	cp.w	r6,r12
800065f0:	c6 c0       	breq	800066c8 <_malloc_r+0x1e4>
800065f2:	6c 19       	ld.w	r9,r6[0x4]
800065f4:	e0 19 ff fc 	andl	r9,0xfffc
800065f8:	f2 07 01 08 	sub	r8,r9,r7
800065fc:	58 f8       	cp.w	r8,15
800065fe:	e0 89 00 8f 	brgt	8000671c <_malloc_r+0x238>
80006602:	99 3c       	st.w	r12[0xc],r12
80006604:	99 2c       	st.w	r12[0x8],r12
80006606:	58 08       	cp.w	r8,0
80006608:	c0 55       	brlt	80006612 <_malloc_r+0x12e>
8000660a:	ec 09 00 09 	add	r9,r6,r9
8000660e:	0a 9c       	mov	r12,r5
80006610:	ce 2b       	rjmp	800065d4 <_malloc_r+0xf0>
80006612:	e0 49 01 ff 	cp.w	r9,511
80006616:	e0 8b 00 13 	brhi	8000663c <_malloc_r+0x158>
8000661a:	a3 99       	lsr	r9,0x3
8000661c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006620:	70 2b       	ld.w	r11,r8[0x8]
80006622:	8d 38       	st.w	r6[0xc],r8
80006624:	8d 2b       	st.w	r6[0x8],r11
80006626:	97 36       	st.w	r11[0xc],r6
80006628:	91 26       	st.w	r8[0x8],r6
8000662a:	a3 49       	asr	r9,0x2
8000662c:	74 18       	ld.w	r8,r10[0x4]
8000662e:	30 1b       	mov	r11,1
80006630:	f6 09 09 49 	lsl	r9,r11,r9
80006634:	f1 e9 10 09 	or	r9,r8,r9
80006638:	95 19       	st.w	r10[0x4],r9
8000663a:	c4 78       	rjmp	800066c8 <_malloc_r+0x1e4>
8000663c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006640:	58 4a       	cp.w	r10,4
80006642:	e0 8b 00 07 	brhi	80006650 <_malloc_r+0x16c>
80006646:	f2 0a 16 06 	lsr	r10,r9,0x6
8000664a:	2c 8a       	sub	r10,-56
8000664c:	c2 08       	rjmp	8000668c <_malloc_r+0x1a8>
8000664e:	d7 03       	nop
80006650:	59 4a       	cp.w	r10,20
80006652:	e0 8b 00 04 	brhi	8000665a <_malloc_r+0x176>
80006656:	2a 5a       	sub	r10,-91
80006658:	c1 a8       	rjmp	8000668c <_malloc_r+0x1a8>
8000665a:	e0 4a 00 54 	cp.w	r10,84
8000665e:	e0 8b 00 06 	brhi	8000666a <_malloc_r+0x186>
80006662:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006666:	29 2a       	sub	r10,-110
80006668:	c1 28       	rjmp	8000668c <_malloc_r+0x1a8>
8000666a:	e0 4a 01 54 	cp.w	r10,340
8000666e:	e0 8b 00 06 	brhi	8000667a <_malloc_r+0x196>
80006672:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006676:	28 9a       	sub	r10,-119
80006678:	c0 a8       	rjmp	8000668c <_malloc_r+0x1a8>
8000667a:	e0 4a 05 54 	cp.w	r10,1364
8000667e:	e0 88 00 04 	brls	80006686 <_malloc_r+0x1a2>
80006682:	37 ea       	mov	r10,126
80006684:	c0 48       	rjmp	8000668c <_malloc_r+0x1a8>
80006686:	f2 0a 16 12 	lsr	r10,r9,0x12
8000668a:	28 4a       	sub	r10,-124
8000668c:	e0 6b 05 2c 	mov	r11,1324
80006690:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006694:	68 28       	ld.w	r8,r4[0x8]
80006696:	08 38       	cp.w	r8,r4
80006698:	c0 e1       	brne	800066b4 <_malloc_r+0x1d0>
8000669a:	76 19       	ld.w	r9,r11[0x4]
8000669c:	a3 4a       	asr	r10,0x2
8000669e:	30 1e       	mov	lr,1
800066a0:	fc 0a 09 4a 	lsl	r10,lr,r10
800066a4:	f3 ea 10 0a 	or	r10,r9,r10
800066a8:	10 99       	mov	r9,r8
800066aa:	97 1a       	st.w	r11[0x4],r10
800066ac:	c0 a8       	rjmp	800066c0 <_malloc_r+0x1dc>
800066ae:	70 28       	ld.w	r8,r8[0x8]
800066b0:	08 38       	cp.w	r8,r4
800066b2:	c0 60       	breq	800066be <_malloc_r+0x1da>
800066b4:	70 1a       	ld.w	r10,r8[0x4]
800066b6:	e0 1a ff fc 	andl	r10,0xfffc
800066ba:	14 39       	cp.w	r9,r10
800066bc:	cf 93       	brcs	800066ae <_malloc_r+0x1ca>
800066be:	70 39       	ld.w	r9,r8[0xc]
800066c0:	8d 39       	st.w	r6[0xc],r9
800066c2:	8d 28       	st.w	r6[0x8],r8
800066c4:	91 36       	st.w	r8[0xc],r6
800066c6:	93 26       	st.w	r9[0x8],r6
800066c8:	e6 08 14 02 	asr	r8,r3,0x2
800066cc:	30 1b       	mov	r11,1
800066ce:	e0 64 05 2c 	mov	r4,1324
800066d2:	f6 08 09 4b 	lsl	r11,r11,r8
800066d6:	68 18       	ld.w	r8,r4[0x4]
800066d8:	10 3b       	cp.w	r11,r8
800066da:	e0 8b 00 6b 	brhi	800067b0 <_malloc_r+0x2cc>
800066de:	f7 e8 00 09 	and	r9,r11,r8
800066e2:	c0 b1       	brne	800066f8 <_malloc_r+0x214>
800066e4:	e0 13 ff fc 	andl	r3,0xfffc
800066e8:	a1 7b       	lsl	r11,0x1
800066ea:	2f c3       	sub	r3,-4
800066ec:	c0 38       	rjmp	800066f2 <_malloc_r+0x20e>
800066ee:	2f c3       	sub	r3,-4
800066f0:	a1 7b       	lsl	r11,0x1
800066f2:	f7 e8 00 09 	and	r9,r11,r8
800066f6:	cf c0       	breq	800066ee <_malloc_r+0x20a>
800066f8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800066fc:	06 92       	mov	r2,r3
800066fe:	1c 91       	mov	r1,lr
80006700:	62 36       	ld.w	r6,r1[0xc]
80006702:	c2 e8       	rjmp	8000675e <_malloc_r+0x27a>
80006704:	6c 1a       	ld.w	r10,r6[0x4]
80006706:	e0 1a ff fc 	andl	r10,0xfffc
8000670a:	f4 07 01 08 	sub	r8,r10,r7
8000670e:	58 f8       	cp.w	r8,15
80006710:	e0 8a 00 15 	brle	8000673a <_malloc_r+0x256>
80006714:	6c 3a       	ld.w	r10,r6[0xc]
80006716:	6c 29       	ld.w	r9,r6[0x8]
80006718:	95 29       	st.w	r10[0x8],r9
8000671a:	93 3a       	st.w	r9[0xc],r10
8000671c:	0e 99       	mov	r9,r7
8000671e:	ec 07 00 07 	add	r7,r6,r7
80006722:	a1 a9       	sbr	r9,0x0
80006724:	99 37       	st.w	r12[0xc],r7
80006726:	99 27       	st.w	r12[0x8],r7
80006728:	8d 19       	st.w	r6[0x4],r9
8000672a:	ee 08 09 08 	st.w	r7[r8],r8
8000672e:	8f 2c       	st.w	r7[0x8],r12
80006730:	8f 3c       	st.w	r7[0xc],r12
80006732:	a1 a8       	sbr	r8,0x0
80006734:	0a 9c       	mov	r12,r5
80006736:	8f 18       	st.w	r7[0x4],r8
80006738:	c0 d8       	rjmp	80006752 <_malloc_r+0x26e>
8000673a:	6c 39       	ld.w	r9,r6[0xc]
8000673c:	58 08       	cp.w	r8,0
8000673e:	c0 f5       	brlt	8000675c <_malloc_r+0x278>
80006740:	ec 0a 00 0a 	add	r10,r6,r10
80006744:	74 18       	ld.w	r8,r10[0x4]
80006746:	a1 a8       	sbr	r8,0x0
80006748:	0a 9c       	mov	r12,r5
8000674a:	95 18       	st.w	r10[0x4],r8
8000674c:	6c 28       	ld.w	r8,r6[0x8]
8000674e:	93 28       	st.w	r9[0x8],r8
80006750:	91 39       	st.w	r8[0xc],r9
80006752:	fe b0 f4 cd 	rcall	800050ec <__malloc_unlock>
80006756:	ec cc ff f8 	sub	r12,r6,-8
8000675a:	d8 32       	popm	r0-r7,pc
8000675c:	12 96       	mov	r6,r9
8000675e:	02 36       	cp.w	r6,r1
80006760:	cd 21       	brne	80006704 <_malloc_r+0x220>
80006762:	2f f2       	sub	r2,-1
80006764:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006768:	c0 30       	breq	8000676e <_malloc_r+0x28a>
8000676a:	2f 81       	sub	r1,-8
8000676c:	cc ab       	rjmp	80006700 <_malloc_r+0x21c>
8000676e:	1c 98       	mov	r8,lr
80006770:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006774:	c0 81       	brne	80006784 <_malloc_r+0x2a0>
80006776:	68 19       	ld.w	r9,r4[0x4]
80006778:	f6 08 11 ff 	rsub	r8,r11,-1
8000677c:	f3 e8 00 08 	and	r8,r9,r8
80006780:	89 18       	st.w	r4[0x4],r8
80006782:	c0 78       	rjmp	80006790 <_malloc_r+0x2ac>
80006784:	f0 c9 00 08 	sub	r9,r8,8
80006788:	20 13       	sub	r3,1
8000678a:	70 08       	ld.w	r8,r8[0x0]
8000678c:	12 38       	cp.w	r8,r9
8000678e:	cf 10       	breq	80006770 <_malloc_r+0x28c>
80006790:	a1 7b       	lsl	r11,0x1
80006792:	68 18       	ld.w	r8,r4[0x4]
80006794:	10 3b       	cp.w	r11,r8
80006796:	e0 8b 00 0d 	brhi	800067b0 <_malloc_r+0x2cc>
8000679a:	58 0b       	cp.w	r11,0
8000679c:	c0 a0       	breq	800067b0 <_malloc_r+0x2cc>
8000679e:	04 93       	mov	r3,r2
800067a0:	c0 38       	rjmp	800067a6 <_malloc_r+0x2c2>
800067a2:	2f c3       	sub	r3,-4
800067a4:	a1 7b       	lsl	r11,0x1
800067a6:	f7 e8 00 09 	and	r9,r11,r8
800067aa:	ca 71       	brne	800066f8 <_malloc_r+0x214>
800067ac:	cf bb       	rjmp	800067a2 <_malloc_r+0x2be>
800067ae:	d7 03       	nop
800067b0:	68 23       	ld.w	r3,r4[0x8]
800067b2:	66 12       	ld.w	r2,r3[0x4]
800067b4:	e0 12 ff fc 	andl	r2,0xfffc
800067b8:	0e 32       	cp.w	r2,r7
800067ba:	5f 39       	srlo	r9
800067bc:	e4 07 01 08 	sub	r8,r2,r7
800067c0:	58 f8       	cp.w	r8,15
800067c2:	5f aa       	srle	r10
800067c4:	f5 e9 10 09 	or	r9,r10,r9
800067c8:	e0 80 00 9a 	breq	800068fc <_malloc_r+0x418>
800067cc:	e0 68 0d 40 	mov	r8,3392
800067d0:	70 01       	ld.w	r1,r8[0x0]
800067d2:	e0 68 09 38 	mov	r8,2360
800067d6:	2f 01       	sub	r1,-16
800067d8:	70 08       	ld.w	r8,r8[0x0]
800067da:	0e 01       	add	r1,r7
800067dc:	5b f8       	cp.w	r8,-1
800067de:	c0 40       	breq	800067e6 <_malloc_r+0x302>
800067e0:	28 11       	sub	r1,-127
800067e2:	e0 11 ff 80 	andl	r1,0xff80
800067e6:	02 9b       	mov	r11,r1
800067e8:	0a 9c       	mov	r12,r5
800067ea:	e0 a0 02 a5 	rcall	80006d34 <_sbrk_r>
800067ee:	18 96       	mov	r6,r12
800067f0:	5b fc       	cp.w	r12,-1
800067f2:	c7 50       	breq	800068dc <_malloc_r+0x3f8>
800067f4:	e6 02 00 08 	add	r8,r3,r2
800067f8:	10 3c       	cp.w	r12,r8
800067fa:	c0 32       	brcc	80006800 <_malloc_r+0x31c>
800067fc:	08 33       	cp.w	r3,r4
800067fe:	c6 f1       	brne	800068dc <_malloc_r+0x3f8>
80006800:	e0 6a 0d 44 	mov	r10,3396
80006804:	74 09       	ld.w	r9,r10[0x0]
80006806:	e2 09 00 09 	add	r9,r1,r9
8000680a:	95 09       	st.w	r10[0x0],r9
8000680c:	10 36       	cp.w	r6,r8
8000680e:	c0 a1       	brne	80006822 <_malloc_r+0x33e>
80006810:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006814:	c0 71       	brne	80006822 <_malloc_r+0x33e>
80006816:	e2 02 00 02 	add	r2,r1,r2
8000681a:	68 28       	ld.w	r8,r4[0x8]
8000681c:	a1 a2       	sbr	r2,0x0
8000681e:	91 12       	st.w	r8[0x4],r2
80006820:	c4 f8       	rjmp	800068be <_malloc_r+0x3da>
80006822:	e0 6a 09 38 	mov	r10,2360
80006826:	74 0b       	ld.w	r11,r10[0x0]
80006828:	5b fb       	cp.w	r11,-1
8000682a:	c0 31       	brne	80006830 <_malloc_r+0x34c>
8000682c:	95 06       	st.w	r10[0x0],r6
8000682e:	c0 78       	rjmp	8000683c <_malloc_r+0x358>
80006830:	ec 09 00 09 	add	r9,r6,r9
80006834:	e0 6a 0d 44 	mov	r10,3396
80006838:	10 19       	sub	r9,r8
8000683a:	95 09       	st.w	r10[0x0],r9
8000683c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006840:	f0 09 11 08 	rsub	r9,r8,8
80006844:	58 08       	cp.w	r8,0
80006846:	f2 08 17 10 	movne	r8,r9
8000684a:	ed d8 e1 06 	addne	r6,r6,r8
8000684e:	28 08       	sub	r8,-128
80006850:	ec 01 00 01 	add	r1,r6,r1
80006854:	0a 9c       	mov	r12,r5
80006856:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000685a:	f0 01 01 01 	sub	r1,r8,r1
8000685e:	02 9b       	mov	r11,r1
80006860:	e0 a0 02 6a 	rcall	80006d34 <_sbrk_r>
80006864:	e0 68 0d 44 	mov	r8,3396
80006868:	5b fc       	cp.w	r12,-1
8000686a:	ec 0c 17 00 	moveq	r12,r6
8000686e:	f9 b1 00 00 	moveq	r1,0
80006872:	70 09       	ld.w	r9,r8[0x0]
80006874:	0c 1c       	sub	r12,r6
80006876:	89 26       	st.w	r4[0x8],r6
80006878:	02 0c       	add	r12,r1
8000687a:	12 01       	add	r1,r9
8000687c:	a1 ac       	sbr	r12,0x0
8000687e:	91 01       	st.w	r8[0x0],r1
80006880:	8d 1c       	st.w	r6[0x4],r12
80006882:	08 33       	cp.w	r3,r4
80006884:	c1 d0       	breq	800068be <_malloc_r+0x3da>
80006886:	58 f2       	cp.w	r2,15
80006888:	e0 8b 00 05 	brhi	80006892 <_malloc_r+0x3ae>
8000688c:	30 18       	mov	r8,1
8000688e:	8d 18       	st.w	r6[0x4],r8
80006890:	c2 68       	rjmp	800068dc <_malloc_r+0x3f8>
80006892:	30 59       	mov	r9,5
80006894:	20 c2       	sub	r2,12
80006896:	e0 12 ff f8 	andl	r2,0xfff8
8000689a:	e6 02 00 08 	add	r8,r3,r2
8000689e:	91 29       	st.w	r8[0x8],r9
800068a0:	91 19       	st.w	r8[0x4],r9
800068a2:	66 18       	ld.w	r8,r3[0x4]
800068a4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068a8:	e5 e8 10 08 	or	r8,r2,r8
800068ac:	87 18       	st.w	r3[0x4],r8
800068ae:	58 f2       	cp.w	r2,15
800068b0:	e0 88 00 07 	brls	800068be <_malloc_r+0x3da>
800068b4:	e6 cb ff f8 	sub	r11,r3,-8
800068b8:	0a 9c       	mov	r12,r5
800068ba:	e0 a0 1c 6b 	rcall	8000a190 <_free_r>
800068be:	e0 69 0d 3c 	mov	r9,3388
800068c2:	72 0a       	ld.w	r10,r9[0x0]
800068c4:	e0 68 0d 44 	mov	r8,3396
800068c8:	70 08       	ld.w	r8,r8[0x0]
800068ca:	14 38       	cp.w	r8,r10
800068cc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068d0:	e0 69 0d 38 	mov	r9,3384
800068d4:	72 0a       	ld.w	r10,r9[0x0]
800068d6:	14 38       	cp.w	r8,r10
800068d8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068dc:	68 28       	ld.w	r8,r4[0x8]
800068de:	70 18       	ld.w	r8,r8[0x4]
800068e0:	e0 18 ff fc 	andl	r8,0xfffc
800068e4:	0e 38       	cp.w	r8,r7
800068e6:	5f 39       	srlo	r9
800068e8:	0e 18       	sub	r8,r7
800068ea:	58 f8       	cp.w	r8,15
800068ec:	5f aa       	srle	r10
800068ee:	f5 e9 10 09 	or	r9,r10,r9
800068f2:	c0 50       	breq	800068fc <_malloc_r+0x418>
800068f4:	0a 9c       	mov	r12,r5
800068f6:	fe b0 f3 fb 	rcall	800050ec <__malloc_unlock>
800068fa:	d8 3a       	popm	r0-r7,pc,r12=0
800068fc:	68 26       	ld.w	r6,r4[0x8]
800068fe:	a1 a8       	sbr	r8,0x0
80006900:	0e 99       	mov	r9,r7
80006902:	a1 a9       	sbr	r9,0x0
80006904:	8d 19       	st.w	r6[0x4],r9
80006906:	ec 07 00 07 	add	r7,r6,r7
8000690a:	0a 9c       	mov	r12,r5
8000690c:	89 27       	st.w	r4[0x8],r7
8000690e:	8f 18       	st.w	r7[0x4],r8
80006910:	fe b0 f3 ee 	rcall	800050ec <__malloc_unlock>
80006914:	ec cc ff f8 	sub	r12,r6,-8
80006918:	d8 32       	popm	r0-r7,pc
8000691a:	d7 03       	nop

8000691c <memcpy>:
8000691c:	58 8a       	cp.w	r10,8
8000691e:	c2 f5       	brlt	8000697c <memcpy+0x60>
80006920:	f9 eb 10 09 	or	r9,r12,r11
80006924:	e2 19 00 03 	andl	r9,0x3,COH
80006928:	e0 81 00 97 	brne	80006a56 <memcpy+0x13a>
8000692c:	e0 4a 00 20 	cp.w	r10,32
80006930:	c3 b4       	brge	800069a6 <memcpy+0x8a>
80006932:	f4 08 14 02 	asr	r8,r10,0x2
80006936:	f0 09 11 08 	rsub	r9,r8,8
8000693a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000693e:	76 69       	ld.w	r9,r11[0x18]
80006940:	99 69       	st.w	r12[0x18],r9
80006942:	76 59       	ld.w	r9,r11[0x14]
80006944:	99 59       	st.w	r12[0x14],r9
80006946:	76 49       	ld.w	r9,r11[0x10]
80006948:	99 49       	st.w	r12[0x10],r9
8000694a:	76 39       	ld.w	r9,r11[0xc]
8000694c:	99 39       	st.w	r12[0xc],r9
8000694e:	76 29       	ld.w	r9,r11[0x8]
80006950:	99 29       	st.w	r12[0x8],r9
80006952:	76 19       	ld.w	r9,r11[0x4]
80006954:	99 19       	st.w	r12[0x4],r9
80006956:	76 09       	ld.w	r9,r11[0x0]
80006958:	99 09       	st.w	r12[0x0],r9
8000695a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000695e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006962:	e0 1a 00 03 	andl	r10,0x3
80006966:	f4 0a 11 04 	rsub	r10,r10,4
8000696a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000696e:	17 a9       	ld.ub	r9,r11[0x2]
80006970:	b0 a9       	st.b	r8[0x2],r9
80006972:	17 99       	ld.ub	r9,r11[0x1]
80006974:	b0 99       	st.b	r8[0x1],r9
80006976:	17 89       	ld.ub	r9,r11[0x0]
80006978:	b0 89       	st.b	r8[0x0],r9
8000697a:	5e fc       	retal	r12
8000697c:	f4 0a 11 09 	rsub	r10,r10,9
80006980:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006984:	17 f9       	ld.ub	r9,r11[0x7]
80006986:	b8 f9       	st.b	r12[0x7],r9
80006988:	17 e9       	ld.ub	r9,r11[0x6]
8000698a:	b8 e9       	st.b	r12[0x6],r9
8000698c:	17 d9       	ld.ub	r9,r11[0x5]
8000698e:	b8 d9       	st.b	r12[0x5],r9
80006990:	17 c9       	ld.ub	r9,r11[0x4]
80006992:	b8 c9       	st.b	r12[0x4],r9
80006994:	17 b9       	ld.ub	r9,r11[0x3]
80006996:	b8 b9       	st.b	r12[0x3],r9
80006998:	17 a9       	ld.ub	r9,r11[0x2]
8000699a:	b8 a9       	st.b	r12[0x2],r9
8000699c:	17 99       	ld.ub	r9,r11[0x1]
8000699e:	b8 99       	st.b	r12[0x1],r9
800069a0:	17 89       	ld.ub	r9,r11[0x0]
800069a2:	b8 89       	st.b	r12[0x0],r9
800069a4:	5e fc       	retal	r12
800069a6:	eb cd 40 c0 	pushm	r6-r7,lr
800069aa:	18 99       	mov	r9,r12
800069ac:	22 0a       	sub	r10,32
800069ae:	b7 07       	ld.d	r6,r11++
800069b0:	b3 26       	st.d	r9++,r6
800069b2:	b7 07       	ld.d	r6,r11++
800069b4:	b3 26       	st.d	r9++,r6
800069b6:	b7 07       	ld.d	r6,r11++
800069b8:	b3 26       	st.d	r9++,r6
800069ba:	b7 07       	ld.d	r6,r11++
800069bc:	b3 26       	st.d	r9++,r6
800069be:	22 0a       	sub	r10,32
800069c0:	cf 74       	brge	800069ae <memcpy+0x92>
800069c2:	2f 0a       	sub	r10,-16
800069c4:	c0 65       	brlt	800069d0 <memcpy+0xb4>
800069c6:	b7 07       	ld.d	r6,r11++
800069c8:	b3 26       	st.d	r9++,r6
800069ca:	b7 07       	ld.d	r6,r11++
800069cc:	b3 26       	st.d	r9++,r6
800069ce:	21 0a       	sub	r10,16
800069d0:	5c 3a       	neg	r10
800069d2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800069d6:	d7 03       	nop
800069d8:	d7 03       	nop
800069da:	f7 36 00 0e 	ld.ub	r6,r11[14]
800069de:	f3 66 00 0e 	st.b	r9[14],r6
800069e2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800069e6:	f3 66 00 0d 	st.b	r9[13],r6
800069ea:	f7 36 00 0c 	ld.ub	r6,r11[12]
800069ee:	f3 66 00 0c 	st.b	r9[12],r6
800069f2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800069f6:	f3 66 00 0b 	st.b	r9[11],r6
800069fa:	f7 36 00 0a 	ld.ub	r6,r11[10]
800069fe:	f3 66 00 0a 	st.b	r9[10],r6
80006a02:	f7 36 00 09 	ld.ub	r6,r11[9]
80006a06:	f3 66 00 09 	st.b	r9[9],r6
80006a0a:	f7 36 00 08 	ld.ub	r6,r11[8]
80006a0e:	f3 66 00 08 	st.b	r9[8],r6
80006a12:	f7 36 00 07 	ld.ub	r6,r11[7]
80006a16:	f3 66 00 07 	st.b	r9[7],r6
80006a1a:	f7 36 00 06 	ld.ub	r6,r11[6]
80006a1e:	f3 66 00 06 	st.b	r9[6],r6
80006a22:	f7 36 00 05 	ld.ub	r6,r11[5]
80006a26:	f3 66 00 05 	st.b	r9[5],r6
80006a2a:	f7 36 00 04 	ld.ub	r6,r11[4]
80006a2e:	f3 66 00 04 	st.b	r9[4],r6
80006a32:	f7 36 00 03 	ld.ub	r6,r11[3]
80006a36:	f3 66 00 03 	st.b	r9[3],r6
80006a3a:	f7 36 00 02 	ld.ub	r6,r11[2]
80006a3e:	f3 66 00 02 	st.b	r9[2],r6
80006a42:	f7 36 00 01 	ld.ub	r6,r11[1]
80006a46:	f3 66 00 01 	st.b	r9[1],r6
80006a4a:	f7 36 00 00 	ld.ub	r6,r11[0]
80006a4e:	f3 66 00 00 	st.b	r9[0],r6
80006a52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a56:	20 1a       	sub	r10,1
80006a58:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a5c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006a60:	cf b1       	brne	80006a56 <memcpy+0x13a>
80006a62:	5e fc       	retal	r12

80006a64 <memset>:
80006a64:	18 98       	mov	r8,r12
80006a66:	c0 38       	rjmp	80006a6c <memset+0x8>
80006a68:	10 cb       	st.b	r8++,r11
80006a6a:	20 1a       	sub	r10,1
80006a6c:	58 0a       	cp.w	r10,0
80006a6e:	cf d1       	brne	80006a68 <memset+0x4>
80006a70:	5e fc       	retal	r12
80006a72:	d7 03       	nop

80006a74 <_realloc_r>:
80006a74:	d4 31       	pushm	r0-r7,lr
80006a76:	20 1d       	sub	sp,4
80006a78:	16 94       	mov	r4,r11
80006a7a:	18 92       	mov	r2,r12
80006a7c:	14 9b       	mov	r11,r10
80006a7e:	58 04       	cp.w	r4,0
80006a80:	c0 51       	brne	80006a8a <_realloc_r+0x16>
80006a82:	fe b0 fd 31 	rcall	800064e4 <_malloc_r>
80006a86:	18 95       	mov	r5,r12
80006a88:	c5 39       	rjmp	80006d2e <_realloc_r+0x2ba>
80006a8a:	50 0a       	stdsp	sp[0x0],r10
80006a8c:	fe b0 f3 2a 	rcall	800050e0 <__malloc_lock>
80006a90:	40 0b       	lddsp	r11,sp[0x0]
80006a92:	f6 c8 ff f5 	sub	r8,r11,-11
80006a96:	e8 c1 00 08 	sub	r1,r4,8
80006a9a:	10 96       	mov	r6,r8
80006a9c:	62 1c       	ld.w	r12,r1[0x4]
80006a9e:	e0 16 ff f8 	andl	r6,0xfff8
80006aa2:	59 68       	cp.w	r8,22
80006aa4:	f9 b6 08 10 	movls	r6,16
80006aa8:	16 36       	cp.w	r6,r11
80006aaa:	5f 38       	srlo	r8
80006aac:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006ab0:	c0 50       	breq	80006aba <_realloc_r+0x46>
80006ab2:	30 c8       	mov	r8,12
80006ab4:	30 05       	mov	r5,0
80006ab6:	85 38       	st.w	r2[0xc],r8
80006ab8:	c3 b9       	rjmp	80006d2e <_realloc_r+0x2ba>
80006aba:	18 90       	mov	r0,r12
80006abc:	e0 10 ff fc 	andl	r0,0xfffc
80006ac0:	0c 30       	cp.w	r0,r6
80006ac2:	e0 84 01 0b 	brge	80006cd8 <_realloc_r+0x264>
80006ac6:	e0 68 05 2c 	mov	r8,1324
80006aca:	e2 00 00 09 	add	r9,r1,r0
80006ace:	70 25       	ld.w	r5,r8[0x8]
80006ad0:	0a 39       	cp.w	r9,r5
80006ad2:	c0 90       	breq	80006ae4 <_realloc_r+0x70>
80006ad4:	72 1a       	ld.w	r10,r9[0x4]
80006ad6:	a1 ca       	cbr	r10,0x0
80006ad8:	f2 0a 00 0a 	add	r10,r9,r10
80006adc:	74 1a       	ld.w	r10,r10[0x4]
80006ade:	ed ba 00 00 	bld	r10,0x0
80006ae2:	c2 20       	breq	80006b26 <_realloc_r+0xb2>
80006ae4:	72 1a       	ld.w	r10,r9[0x4]
80006ae6:	e0 1a ff fc 	andl	r10,0xfffc
80006aea:	f4 00 00 03 	add	r3,r10,r0
80006aee:	0a 39       	cp.w	r9,r5
80006af0:	c1 31       	brne	80006b16 <_realloc_r+0xa2>
80006af2:	ec c7 ff f0 	sub	r7,r6,-16
80006af6:	0e 33       	cp.w	r3,r7
80006af8:	c1 95       	brlt	80006b2a <_realloc_r+0xb6>
80006afa:	e2 06 00 09 	add	r9,r1,r6
80006afe:	0c 13       	sub	r3,r6
80006b00:	a1 a3       	sbr	r3,0x0
80006b02:	93 13       	st.w	r9[0x4],r3
80006b04:	91 29       	st.w	r8[0x8],r9
80006b06:	04 9c       	mov	r12,r2
80006b08:	62 18       	ld.w	r8,r1[0x4]
80006b0a:	08 95       	mov	r5,r4
80006b0c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b10:	10 46       	or	r6,r8
80006b12:	83 16       	st.w	r1[0x4],r6
80006b14:	c0 b9       	rjmp	80006d2a <_realloc_r+0x2b6>
80006b16:	0c 33       	cp.w	r3,r6
80006b18:	c0 95       	brlt	80006b2a <_realloc_r+0xb6>
80006b1a:	72 28       	ld.w	r8,r9[0x8]
80006b1c:	02 97       	mov	r7,r1
80006b1e:	72 39       	ld.w	r9,r9[0xc]
80006b20:	93 28       	st.w	r9[0x8],r8
80006b22:	91 39       	st.w	r8[0xc],r9
80006b24:	cd c8       	rjmp	80006cdc <_realloc_r+0x268>
80006b26:	30 0a       	mov	r10,0
80006b28:	14 99       	mov	r9,r10
80006b2a:	ed bc 00 00 	bld	r12,0x0
80006b2e:	e0 80 00 95 	breq	80006c58 <_realloc_r+0x1e4>
80006b32:	62 07       	ld.w	r7,r1[0x0]
80006b34:	e2 07 01 07 	sub	r7,r1,r7
80006b38:	6e 1c       	ld.w	r12,r7[0x4]
80006b3a:	e0 1c ff fc 	andl	r12,0xfffc
80006b3e:	58 09       	cp.w	r9,0
80006b40:	c5 60       	breq	80006bec <_realloc_r+0x178>
80006b42:	f8 00 00 03 	add	r3,r12,r0
80006b46:	0a 39       	cp.w	r9,r5
80006b48:	c4 81       	brne	80006bd8 <_realloc_r+0x164>
80006b4a:	14 03       	add	r3,r10
80006b4c:	ec c9 ff f0 	sub	r9,r6,-16
80006b50:	12 33       	cp.w	r3,r9
80006b52:	c4 d5       	brlt	80006bec <_realloc_r+0x178>
80006b54:	6e 3a       	ld.w	r10,r7[0xc]
80006b56:	6e 29       	ld.w	r9,r7[0x8]
80006b58:	95 29       	st.w	r10[0x8],r9
80006b5a:	93 3a       	st.w	r9[0xc],r10
80006b5c:	ee c5 ff f8 	sub	r5,r7,-8
80006b60:	e0 ca 00 04 	sub	r10,r0,4
80006b64:	e0 4a 00 24 	cp.w	r10,36
80006b68:	e0 8b 00 25 	brhi	80006bb2 <_realloc_r+0x13e>
80006b6c:	0a 99       	mov	r9,r5
80006b6e:	59 3a       	cp.w	r10,19
80006b70:	e0 88 00 1a 	brls	80006ba4 <_realloc_r+0x130>
80006b74:	09 09       	ld.w	r9,r4++
80006b76:	8b 09       	st.w	r5[0x0],r9
80006b78:	09 09       	ld.w	r9,r4++
80006b7a:	8f 39       	st.w	r7[0xc],r9
80006b7c:	ee c9 ff f0 	sub	r9,r7,-16
80006b80:	59 ba       	cp.w	r10,27
80006b82:	e0 88 00 11 	brls	80006ba4 <_realloc_r+0x130>
80006b86:	09 0b       	ld.w	r11,r4++
80006b88:	93 0b       	st.w	r9[0x0],r11
80006b8a:	09 09       	ld.w	r9,r4++
80006b8c:	8f 59       	st.w	r7[0x14],r9
80006b8e:	ee c9 ff e8 	sub	r9,r7,-24
80006b92:	e0 4a 00 24 	cp.w	r10,36
80006b96:	c0 71       	brne	80006ba4 <_realloc_r+0x130>
80006b98:	09 0a       	ld.w	r10,r4++
80006b9a:	93 0a       	st.w	r9[0x0],r10
80006b9c:	ee c9 ff e0 	sub	r9,r7,-32
80006ba0:	09 0a       	ld.w	r10,r4++
80006ba2:	8f 7a       	st.w	r7[0x1c],r10
80006ba4:	09 0a       	ld.w	r10,r4++
80006ba6:	12 aa       	st.w	r9++,r10
80006ba8:	68 0a       	ld.w	r10,r4[0x0]
80006baa:	93 0a       	st.w	r9[0x0],r10
80006bac:	68 1a       	ld.w	r10,r4[0x4]
80006bae:	93 1a       	st.w	r9[0x4],r10
80006bb0:	c0 78       	rjmp	80006bbe <_realloc_r+0x14a>
80006bb2:	50 08       	stdsp	sp[0x0],r8
80006bb4:	08 9b       	mov	r11,r4
80006bb6:	0a 9c       	mov	r12,r5
80006bb8:	e0 a0 1d 8f 	rcall	8000a6d6 <memmove>
80006bbc:	40 08       	lddsp	r8,sp[0x0]
80006bbe:	ee 06 00 09 	add	r9,r7,r6
80006bc2:	0c 13       	sub	r3,r6
80006bc4:	a1 a3       	sbr	r3,0x0
80006bc6:	93 13       	st.w	r9[0x4],r3
80006bc8:	91 29       	st.w	r8[0x8],r9
80006bca:	04 9c       	mov	r12,r2
80006bcc:	6e 18       	ld.w	r8,r7[0x4]
80006bce:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bd2:	10 46       	or	r6,r8
80006bd4:	8f 16       	st.w	r7[0x4],r6
80006bd6:	ca a8       	rjmp	80006d2a <_realloc_r+0x2b6>
80006bd8:	14 03       	add	r3,r10
80006bda:	0c 33       	cp.w	r3,r6
80006bdc:	c0 85       	brlt	80006bec <_realloc_r+0x178>
80006bde:	72 28       	ld.w	r8,r9[0x8]
80006be0:	72 39       	ld.w	r9,r9[0xc]
80006be2:	93 28       	st.w	r9[0x8],r8
80006be4:	91 39       	st.w	r8[0xc],r9
80006be6:	6e 28       	ld.w	r8,r7[0x8]
80006be8:	6e 39       	ld.w	r9,r7[0xc]
80006bea:	c0 78       	rjmp	80006bf8 <_realloc_r+0x184>
80006bec:	f8 00 00 03 	add	r3,r12,r0
80006bf0:	0c 33       	cp.w	r3,r6
80006bf2:	c3 35       	brlt	80006c58 <_realloc_r+0x1e4>
80006bf4:	6e 39       	ld.w	r9,r7[0xc]
80006bf6:	6e 28       	ld.w	r8,r7[0x8]
80006bf8:	93 28       	st.w	r9[0x8],r8
80006bfa:	91 39       	st.w	r8[0xc],r9
80006bfc:	e0 ca 00 04 	sub	r10,r0,4
80006c00:	ee cc ff f8 	sub	r12,r7,-8
80006c04:	e0 4a 00 24 	cp.w	r10,36
80006c08:	e0 8b 00 24 	brhi	80006c50 <_realloc_r+0x1dc>
80006c0c:	59 3a       	cp.w	r10,19
80006c0e:	e0 88 00 1a 	brls	80006c42 <_realloc_r+0x1ce>
80006c12:	09 08       	ld.w	r8,r4++
80006c14:	99 08       	st.w	r12[0x0],r8
80006c16:	09 08       	ld.w	r8,r4++
80006c18:	8f 38       	st.w	r7[0xc],r8
80006c1a:	ee cc ff f0 	sub	r12,r7,-16
80006c1e:	59 ba       	cp.w	r10,27
80006c20:	e0 88 00 11 	brls	80006c42 <_realloc_r+0x1ce>
80006c24:	09 08       	ld.w	r8,r4++
80006c26:	99 08       	st.w	r12[0x0],r8
80006c28:	09 08       	ld.w	r8,r4++
80006c2a:	8f 58       	st.w	r7[0x14],r8
80006c2c:	ee cc ff e8 	sub	r12,r7,-24
80006c30:	e0 4a 00 24 	cp.w	r10,36
80006c34:	c0 71       	brne	80006c42 <_realloc_r+0x1ce>
80006c36:	09 08       	ld.w	r8,r4++
80006c38:	99 08       	st.w	r12[0x0],r8
80006c3a:	ee cc ff e0 	sub	r12,r7,-32
80006c3e:	09 08       	ld.w	r8,r4++
80006c40:	8f 78       	st.w	r7[0x1c],r8
80006c42:	09 08       	ld.w	r8,r4++
80006c44:	18 a8       	st.w	r12++,r8
80006c46:	68 08       	ld.w	r8,r4[0x0]
80006c48:	99 08       	st.w	r12[0x0],r8
80006c4a:	68 18       	ld.w	r8,r4[0x4]
80006c4c:	99 18       	st.w	r12[0x4],r8
80006c4e:	c4 78       	rjmp	80006cdc <_realloc_r+0x268>
80006c50:	08 9b       	mov	r11,r4
80006c52:	e0 a0 1d 42 	rcall	8000a6d6 <memmove>
80006c56:	c4 38       	rjmp	80006cdc <_realloc_r+0x268>
80006c58:	04 9c       	mov	r12,r2
80006c5a:	fe b0 fc 45 	rcall	800064e4 <_malloc_r>
80006c5e:	18 95       	mov	r5,r12
80006c60:	c3 a0       	breq	80006cd4 <_realloc_r+0x260>
80006c62:	62 18       	ld.w	r8,r1[0x4]
80006c64:	f8 c9 00 08 	sub	r9,r12,8
80006c68:	a1 c8       	cbr	r8,0x0
80006c6a:	e2 08 00 08 	add	r8,r1,r8
80006c6e:	10 39       	cp.w	r9,r8
80006c70:	c0 71       	brne	80006c7e <_realloc_r+0x20a>
80006c72:	72 13       	ld.w	r3,r9[0x4]
80006c74:	02 97       	mov	r7,r1
80006c76:	e0 13 ff fc 	andl	r3,0xfffc
80006c7a:	00 03       	add	r3,r0
80006c7c:	c3 08       	rjmp	80006cdc <_realloc_r+0x268>
80006c7e:	e0 ca 00 04 	sub	r10,r0,4
80006c82:	e0 4a 00 24 	cp.w	r10,36
80006c86:	e0 8b 00 20 	brhi	80006cc6 <_realloc_r+0x252>
80006c8a:	08 99       	mov	r9,r4
80006c8c:	18 98       	mov	r8,r12
80006c8e:	59 3a       	cp.w	r10,19
80006c90:	e0 88 00 14 	brls	80006cb8 <_realloc_r+0x244>
80006c94:	13 0b       	ld.w	r11,r9++
80006c96:	10 ab       	st.w	r8++,r11
80006c98:	13 0b       	ld.w	r11,r9++
80006c9a:	10 ab       	st.w	r8++,r11
80006c9c:	59 ba       	cp.w	r10,27
80006c9e:	e0 88 00 0d 	brls	80006cb8 <_realloc_r+0x244>
80006ca2:	13 0b       	ld.w	r11,r9++
80006ca4:	10 ab       	st.w	r8++,r11
80006ca6:	13 0b       	ld.w	r11,r9++
80006ca8:	10 ab       	st.w	r8++,r11
80006caa:	e0 4a 00 24 	cp.w	r10,36
80006cae:	c0 51       	brne	80006cb8 <_realloc_r+0x244>
80006cb0:	13 0a       	ld.w	r10,r9++
80006cb2:	10 aa       	st.w	r8++,r10
80006cb4:	13 0a       	ld.w	r10,r9++
80006cb6:	10 aa       	st.w	r8++,r10
80006cb8:	13 0a       	ld.w	r10,r9++
80006cba:	10 aa       	st.w	r8++,r10
80006cbc:	72 0a       	ld.w	r10,r9[0x0]
80006cbe:	91 0a       	st.w	r8[0x0],r10
80006cc0:	72 19       	ld.w	r9,r9[0x4]
80006cc2:	91 19       	st.w	r8[0x4],r9
80006cc4:	c0 48       	rjmp	80006ccc <_realloc_r+0x258>
80006cc6:	08 9b       	mov	r11,r4
80006cc8:	e0 a0 1d 07 	rcall	8000a6d6 <memmove>
80006ccc:	08 9b       	mov	r11,r4
80006cce:	04 9c       	mov	r12,r2
80006cd0:	e0 a0 1a 60 	rcall	8000a190 <_free_r>
80006cd4:	04 9c       	mov	r12,r2
80006cd6:	c2 a8       	rjmp	80006d2a <_realloc_r+0x2b6>
80006cd8:	00 93       	mov	r3,r0
80006cda:	02 97       	mov	r7,r1
80006cdc:	e6 06 01 09 	sub	r9,r3,r6
80006ce0:	6e 18       	ld.w	r8,r7[0x4]
80006ce2:	58 f9       	cp.w	r9,15
80006ce4:	e0 88 00 16 	brls	80006d10 <_realloc_r+0x29c>
80006ce8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006cec:	ed e8 10 08 	or	r8,r6,r8
80006cf0:	8f 18       	st.w	r7[0x4],r8
80006cf2:	12 98       	mov	r8,r9
80006cf4:	a1 a8       	sbr	r8,0x0
80006cf6:	ee 06 00 0b 	add	r11,r7,r6
80006cfa:	f6 09 00 09 	add	r9,r11,r9
80006cfe:	97 18       	st.w	r11[0x4],r8
80006d00:	72 18       	ld.w	r8,r9[0x4]
80006d02:	a1 a8       	sbr	r8,0x0
80006d04:	2f 8b       	sub	r11,-8
80006d06:	93 18       	st.w	r9[0x4],r8
80006d08:	04 9c       	mov	r12,r2
80006d0a:	e0 a0 1a 43 	rcall	8000a190 <_free_r>
80006d0e:	c0 b8       	rjmp	80006d24 <_realloc_r+0x2b0>
80006d10:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d14:	e7 e8 10 08 	or	r8,r3,r8
80006d18:	8f 18       	st.w	r7[0x4],r8
80006d1a:	ee 03 00 03 	add	r3,r7,r3
80006d1e:	66 18       	ld.w	r8,r3[0x4]
80006d20:	a1 a8       	sbr	r8,0x0
80006d22:	87 18       	st.w	r3[0x4],r8
80006d24:	04 9c       	mov	r12,r2
80006d26:	ee c5 ff f8 	sub	r5,r7,-8
80006d2a:	fe b0 f1 e1 	rcall	800050ec <__malloc_unlock>
80006d2e:	0a 9c       	mov	r12,r5
80006d30:	2f fd       	sub	sp,-4
80006d32:	d8 32       	popm	r0-r7,pc

80006d34 <_sbrk_r>:
80006d34:	d4 21       	pushm	r4-r7,lr
80006d36:	30 08       	mov	r8,0
80006d38:	18 97       	mov	r7,r12
80006d3a:	e0 66 41 08 	mov	r6,16648
80006d3e:	16 9c       	mov	r12,r11
80006d40:	8d 08       	st.w	r6[0x0],r8
80006d42:	c8 5c       	rcall	80006e4c <_sbrk>
80006d44:	5b fc       	cp.w	r12,-1
80006d46:	c0 51       	brne	80006d50 <_sbrk_r+0x1c>
80006d48:	6c 08       	ld.w	r8,r6[0x0]
80006d4a:	58 08       	cp.w	r8,0
80006d4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006d50:	d8 22       	popm	r4-r7,pc
80006d52:	d7 03       	nop

80006d54 <sprintf>:
80006d54:	d4 01       	pushm	lr
80006d56:	21 7d       	sub	sp,92
80006d58:	e0 68 ff ff 	mov	r8,65535
80006d5c:	ea 18 7f ff 	orh	r8,0x7fff
80006d60:	50 58       	stdsp	sp[0x14],r8
80006d62:	50 28       	stdsp	sp[0x8],r8
80006d64:	e0 68 02 08 	mov	r8,520
80006d68:	ba 68       	st.h	sp[0xc],r8
80006d6a:	3f f8       	mov	r8,-1
80006d6c:	ba 78       	st.h	sp[0xe],r8
80006d6e:	e0 68 0a 2c 	mov	r8,2604
80006d72:	50 4c       	stdsp	sp[0x10],r12
80006d74:	16 9a       	mov	r10,r11
80006d76:	50 0c       	stdsp	sp[0x0],r12
80006d78:	fa c9 ff a0 	sub	r9,sp,-96
80006d7c:	70 0c       	ld.w	r12,r8[0x0]
80006d7e:	1a 9b       	mov	r11,sp
80006d80:	e0 a0 02 1a 	rcall	800071b4 <_vfprintf_r>
80006d84:	30 09       	mov	r9,0
80006d86:	40 08       	lddsp	r8,sp[0x0]
80006d88:	b0 89       	st.b	r8[0x0],r9
80006d8a:	2e 9d       	sub	sp,-92
80006d8c:	d8 02       	popm	pc
80006d8e:	d7 03       	nop

80006d90 <strncpy>:
80006d90:	30 08       	mov	r8,0
80006d92:	10 3a       	cp.w	r10,r8
80006d94:	5e 0c       	reteq	r12
80006d96:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006d9a:	f8 08 0b 09 	st.b	r12[r8],r9
80006d9e:	2f f8       	sub	r8,-1
80006da0:	58 09       	cp.w	r9,0
80006da2:	cf 81       	brne	80006d92 <strncpy+0x2>
80006da4:	10 3a       	cp.w	r10,r8
80006da6:	5e 0c       	reteq	r12
80006da8:	f8 08 0b 09 	st.b	r12[r8],r9
80006dac:	2f f8       	sub	r8,-1
80006dae:	cf bb       	rjmp	80006da4 <strncpy+0x14>

80006db0 <_close>:
80006db0:	30 28       	mov	r8,2
80006db2:	d6 73       	breakpoint
80006db4:	3f fc       	mov	r12,-1
80006db6:	35 8b       	mov	r11,88
80006db8:	58 0c       	cp.w	r12,0
80006dba:	5e 4c       	retge	r12
80006dbc:	e0 6a 41 08 	mov	r10,16648
80006dc0:	95 0b       	st.w	r10[0x0],r11
80006dc2:	5e fc       	retal	r12

80006dc4 <_lseek>:
80006dc4:	30 58       	mov	r8,5
80006dc6:	d6 73       	breakpoint
80006dc8:	3f fc       	mov	r12,-1
80006dca:	35 8b       	mov	r11,88
80006dcc:	58 0c       	cp.w	r12,0
80006dce:	5e 4c       	retge	r12
80006dd0:	e0 6a 41 08 	mov	r10,16648
80006dd4:	95 0b       	st.w	r10[0x0],r11
80006dd6:	5e fc       	retal	r12

80006dd8 <isatty>:
80006dd8:	30 b8       	mov	r8,11
80006dda:	d6 73       	breakpoint
80006ddc:	3f fc       	mov	r12,-1
80006dde:	35 8b       	mov	r11,88
80006de0:	58 0c       	cp.w	r12,0
80006de2:	5e 4c       	retge	r12
80006de4:	e0 6a 41 08 	mov	r10,16648
80006de8:	95 0b       	st.w	r10[0x0],r11
80006dea:	5e fc       	retal	r12

80006dec <_fstat_host>:
80006dec:	30 98       	mov	r8,9
80006dee:	d6 73       	breakpoint
80006df0:	3f fc       	mov	r12,-1
80006df2:	35 8b       	mov	r11,88
80006df4:	58 0c       	cp.w	r12,0
80006df6:	5e 4c       	retge	r12
80006df8:	e0 6a 41 08 	mov	r10,16648
80006dfc:	95 0b       	st.w	r10[0x0],r11
80006dfe:	5e fc       	retal	r12

80006e00 <_fstat>:
80006e00:	d4 21       	pushm	r4-r7,lr
80006e02:	21 0d       	sub	sp,64
80006e04:	16 97       	mov	r7,r11
80006e06:	1a 9b       	mov	r11,sp
80006e08:	cf 2f       	rcall	80006dec <_fstat_host>
80006e0a:	c0 34       	brge	80006e10 <_fstat+0x10>
80006e0c:	3f fc       	mov	r12,-1
80006e0e:	c1 c8       	rjmp	80006e46 <_fstat+0x46>
80006e10:	40 08       	lddsp	r8,sp[0x0]
80006e12:	ae 08       	st.h	r7[0x0],r8
80006e14:	40 18       	lddsp	r8,sp[0x4]
80006e16:	ae 18       	st.h	r7[0x2],r8
80006e18:	40 28       	lddsp	r8,sp[0x8]
80006e1a:	8f 18       	st.w	r7[0x4],r8
80006e1c:	40 38       	lddsp	r8,sp[0xc]
80006e1e:	ae 48       	st.h	r7[0x8],r8
80006e20:	40 48       	lddsp	r8,sp[0x10]
80006e22:	ae 58       	st.h	r7[0xa],r8
80006e24:	40 58       	lddsp	r8,sp[0x14]
80006e26:	ae 68       	st.h	r7[0xc],r8
80006e28:	40 68       	lddsp	r8,sp[0x18]
80006e2a:	ae 78       	st.h	r7[0xe],r8
80006e2c:	40 88       	lddsp	r8,sp[0x20]
80006e2e:	8f 48       	st.w	r7[0x10],r8
80006e30:	40 a8       	lddsp	r8,sp[0x28]
80006e32:	8f b8       	st.w	r7[0x2c],r8
80006e34:	40 c8       	lddsp	r8,sp[0x30]
80006e36:	8f c8       	st.w	r7[0x30],r8
80006e38:	40 d8       	lddsp	r8,sp[0x34]
80006e3a:	8f 58       	st.w	r7[0x14],r8
80006e3c:	40 e8       	lddsp	r8,sp[0x38]
80006e3e:	30 0c       	mov	r12,0
80006e40:	8f 78       	st.w	r7[0x1c],r8
80006e42:	40 f8       	lddsp	r8,sp[0x3c]
80006e44:	8f 98       	st.w	r7[0x24],r8
80006e46:	2f 0d       	sub	sp,-64
80006e48:	d8 22       	popm	r4-r7,pc
80006e4a:	d7 03       	nop

80006e4c <_sbrk>:
80006e4c:	d4 01       	pushm	lr
80006e4e:	e0 68 0d 6c 	mov	r8,3436
80006e52:	70 09       	ld.w	r9,r8[0x0]
80006e54:	58 09       	cp.w	r9,0
80006e56:	c0 41       	brne	80006e5e <_sbrk+0x12>
80006e58:	e0 69 41 10 	mov	r9,16656
80006e5c:	91 09       	st.w	r8[0x0],r9
80006e5e:	e0 69 0d 6c 	mov	r9,3436
80006e62:	e0 7a 70 00 	mov	r10,94208
80006e66:	72 08       	ld.w	r8,r9[0x0]
80006e68:	f0 0c 00 0c 	add	r12,r8,r12
80006e6c:	14 3c       	cp.w	r12,r10
80006e6e:	e0 8b 00 04 	brhi	80006e76 <_sbrk+0x2a>
80006e72:	93 0c       	st.w	r9[0x0],r12
80006e74:	c0 68       	rjmp	80006e80 <_sbrk+0x34>
80006e76:	e0 a0 18 15 	rcall	80009ea0 <__errno>
80006e7a:	30 c8       	mov	r8,12
80006e7c:	99 08       	st.w	r12[0x0],r8
80006e7e:	3f f8       	mov	r8,-1
80006e80:	10 9c       	mov	r12,r8
80006e82:	d8 02       	popm	pc

80006e84 <get_arg>:
80006e84:	d4 31       	pushm	r0-r7,lr
80006e86:	20 8d       	sub	sp,32
80006e88:	fa c4 ff bc 	sub	r4,sp,-68
80006e8c:	50 4b       	stdsp	sp[0x10],r11
80006e8e:	68 2e       	ld.w	lr,r4[0x8]
80006e90:	50 58       	stdsp	sp[0x14],r8
80006e92:	12 96       	mov	r6,r9
80006e94:	7c 0b       	ld.w	r11,lr[0x0]
80006e96:	70 05       	ld.w	r5,r8[0x0]
80006e98:	50 6e       	stdsp	sp[0x18],lr
80006e9a:	58 0b       	cp.w	r11,0
80006e9c:	f4 0b 17 00 	moveq	r11,r10
80006ea0:	68 03       	ld.w	r3,r4[0x0]
80006ea2:	68 11       	ld.w	r1,r4[0x4]
80006ea4:	40 49       	lddsp	r9,sp[0x10]
80006ea6:	30 08       	mov	r8,0
80006ea8:	c2 89       	rjmp	800070f8 <get_arg+0x274>
80006eaa:	2f fb       	sub	r11,-1
80006eac:	32 5c       	mov	r12,37
80006eae:	17 8a       	ld.ub	r10,r11[0x0]
80006eb0:	f8 0a 18 00 	cp.b	r10,r12
80006eb4:	5f 1e       	srne	lr
80006eb6:	f0 0a 18 00 	cp.b	r10,r8
80006eba:	5f 1c       	srne	r12
80006ebc:	fd ec 00 0c 	and	r12,lr,r12
80006ec0:	f0 0c 18 00 	cp.b	r12,r8
80006ec4:	cf 31       	brne	80006eaa <get_arg+0x26>
80006ec6:	58 0a       	cp.w	r10,0
80006ec8:	e0 80 01 25 	breq	80007112 <get_arg+0x28e>
80006ecc:	30 0c       	mov	r12,0
80006ece:	3f fa       	mov	r10,-1
80006ed0:	18 90       	mov	r0,r12
80006ed2:	50 3a       	stdsp	sp[0xc],r10
80006ed4:	18 94       	mov	r4,r12
80006ed6:	18 92       	mov	r2,r12
80006ed8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006edc:	16 97       	mov	r7,r11
80006ede:	50 7c       	stdsp	sp[0x1c],r12
80006ee0:	fe cc a0 e0 	sub	r12,pc,-24352
80006ee4:	0f 3a       	ld.ub	r10,r7++
80006ee6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006eea:	40 7c       	lddsp	r12,sp[0x1c]
80006eec:	1c 0c       	add	r12,lr
80006eee:	fe ce a1 b6 	sub	lr,pc,-24138
80006ef2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006ef6:	20 1e       	sub	lr,1
80006ef8:	50 0e       	stdsp	sp[0x0],lr
80006efa:	fe ce a2 2e 	sub	lr,pc,-24018
80006efe:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006f02:	50 7c       	stdsp	sp[0x1c],r12
80006f04:	40 0c       	lddsp	r12,sp[0x0]
80006f06:	58 7c       	cp.w	r12,7
80006f08:	e0 8b 00 f1 	brhi	800070ea <get_arg+0x266>
80006f0c:	fe ce a3 e0 	sub	lr,pc,-23584
80006f10:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006f14:	36 8b       	mov	r11,104
80006f16:	f6 0a 18 00 	cp.b	r10,r11
80006f1a:	e0 80 00 e8 	breq	800070ea <get_arg+0x266>
80006f1e:	37 1b       	mov	r11,113
80006f20:	f6 0a 18 00 	cp.b	r10,r11
80006f24:	c0 70       	breq	80006f32 <get_arg+0xae>
80006f26:	34 cb       	mov	r11,76
80006f28:	f6 0a 18 00 	cp.b	r10,r11
80006f2c:	c0 51       	brne	80006f36 <get_arg+0xb2>
80006f2e:	a3 b4       	sbr	r4,0x3
80006f30:	cd d8       	rjmp	800070ea <get_arg+0x266>
80006f32:	a5 b4       	sbr	r4,0x5
80006f34:	cd b8       	rjmp	800070ea <get_arg+0x266>
80006f36:	08 9a       	mov	r10,r4
80006f38:	0e 9b       	mov	r11,r7
80006f3a:	a5 aa       	sbr	r10,0x4
80006f3c:	17 3c       	ld.ub	r12,r11++
80006f3e:	a5 b4       	sbr	r4,0x5
80006f40:	36 ce       	mov	lr,108
80006f42:	fc 0c 18 00 	cp.b	r12,lr
80006f46:	e0 80 00 d3 	breq	800070ec <get_arg+0x268>
80006f4a:	14 94       	mov	r4,r10
80006f4c:	cc f8       	rjmp	800070ea <get_arg+0x266>
80006f4e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006f52:	36 7c       	mov	r12,103
80006f54:	f8 0a 18 00 	cp.b	r10,r12
80006f58:	e0 8b 00 27 	brhi	80006fa6 <get_arg+0x122>
80006f5c:	36 5b       	mov	r11,101
80006f5e:	f6 0a 18 00 	cp.b	r10,r11
80006f62:	c4 82       	brcc	80006ff2 <get_arg+0x16e>
80006f64:	34 fb       	mov	r11,79
80006f66:	f6 0a 18 00 	cp.b	r10,r11
80006f6a:	c4 80       	breq	80006ffa <get_arg+0x176>
80006f6c:	e0 8b 00 0c 	brhi	80006f84 <get_arg+0x100>
80006f70:	34 5b       	mov	r11,69
80006f72:	f6 0a 18 00 	cp.b	r10,r11
80006f76:	c3 e0       	breq	80006ff2 <get_arg+0x16e>
80006f78:	34 7b       	mov	r11,71
80006f7a:	f6 0a 18 00 	cp.b	r10,r11
80006f7e:	c3 a0       	breq	80006ff2 <get_arg+0x16e>
80006f80:	34 4b       	mov	r11,68
80006f82:	c0 88       	rjmp	80006f92 <get_arg+0x10e>
80006f84:	35 8b       	mov	r11,88
80006f86:	f6 0a 18 00 	cp.b	r10,r11
80006f8a:	c2 c0       	breq	80006fe2 <get_arg+0x15e>
80006f8c:	e0 8b 00 07 	brhi	80006f9a <get_arg+0x116>
80006f90:	35 5b       	mov	r11,85
80006f92:	f6 0a 18 00 	cp.b	r10,r11
80006f96:	c3 51       	brne	80007000 <get_arg+0x17c>
80006f98:	c3 18       	rjmp	80006ffa <get_arg+0x176>
80006f9a:	36 3b       	mov	r11,99
80006f9c:	f6 0a 18 00 	cp.b	r10,r11
80006fa0:	c2 f0       	breq	80006ffe <get_arg+0x17a>
80006fa2:	36 4b       	mov	r11,100
80006fa4:	c0 e8       	rjmp	80006fc0 <get_arg+0x13c>
80006fa6:	37 0b       	mov	r11,112
80006fa8:	f6 0a 18 00 	cp.b	r10,r11
80006fac:	c2 50       	breq	80006ff6 <get_arg+0x172>
80006fae:	e0 8b 00 0d 	brhi	80006fc8 <get_arg+0x144>
80006fb2:	36 eb       	mov	r11,110
80006fb4:	f6 0a 18 00 	cp.b	r10,r11
80006fb8:	c1 f0       	breq	80006ff6 <get_arg+0x172>
80006fba:	e0 8b 00 14 	brhi	80006fe2 <get_arg+0x15e>
80006fbe:	36 9b       	mov	r11,105
80006fc0:	f6 0a 18 00 	cp.b	r10,r11
80006fc4:	c1 e1       	brne	80007000 <get_arg+0x17c>
80006fc6:	c0 e8       	rjmp	80006fe2 <get_arg+0x15e>
80006fc8:	37 5b       	mov	r11,117
80006fca:	f6 0a 18 00 	cp.b	r10,r11
80006fce:	c0 a0       	breq	80006fe2 <get_arg+0x15e>
80006fd0:	37 8b       	mov	r11,120
80006fd2:	f6 0a 18 00 	cp.b	r10,r11
80006fd6:	c0 60       	breq	80006fe2 <get_arg+0x15e>
80006fd8:	37 3b       	mov	r11,115
80006fda:	f6 0a 18 00 	cp.b	r10,r11
80006fde:	c1 11       	brne	80007000 <get_arg+0x17c>
80006fe0:	c0 b8       	rjmp	80006ff6 <get_arg+0x172>
80006fe2:	ed b4 00 04 	bld	r4,0x4
80006fe6:	c0 a0       	breq	80006ffa <get_arg+0x176>
80006fe8:	ed b4 00 05 	bld	r4,0x5
80006fec:	c0 91       	brne	80006ffe <get_arg+0x17a>
80006fee:	30 20       	mov	r0,2
80006ff0:	c0 88       	rjmp	80007000 <get_arg+0x17c>
80006ff2:	30 40       	mov	r0,4
80006ff4:	c0 68       	rjmp	80007000 <get_arg+0x17c>
80006ff6:	30 30       	mov	r0,3
80006ff8:	c0 48       	rjmp	80007000 <get_arg+0x17c>
80006ffa:	30 10       	mov	r0,1
80006ffc:	c0 28       	rjmp	80007000 <get_arg+0x17c>
80006ffe:	30 00       	mov	r0,0
80007000:	40 3b       	lddsp	r11,sp[0xc]
80007002:	5b fb       	cp.w	r11,-1
80007004:	c0 40       	breq	8000700c <get_arg+0x188>
80007006:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000700a:	c7 08       	rjmp	800070ea <get_arg+0x266>
8000700c:	58 60       	cp.w	r0,6
8000700e:	e0 8b 00 6e 	brhi	800070ea <get_arg+0x266>
80007012:	6c 0a       	ld.w	r10,r6[0x0]
80007014:	ea cc ff ff 	sub	r12,r5,-1
80007018:	fe ce a4 cc 	sub	lr,pc,-23348
8000701c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007020:	f4 cb ff f8 	sub	r11,r10,-8
80007024:	8d 0b       	st.w	r6[0x0],r11
80007026:	f4 ea 00 00 	ld.d	r10,r10[0]
8000702a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000702e:	c0 f8       	rjmp	8000704c <get_arg+0x1c8>
80007030:	f4 cb ff fc 	sub	r11,r10,-4
80007034:	8d 0b       	st.w	r6[0x0],r11
80007036:	74 0a       	ld.w	r10,r10[0x0]
80007038:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000703c:	c0 88       	rjmp	8000704c <get_arg+0x1c8>
8000703e:	f4 cb ff f8 	sub	r11,r10,-8
80007042:	8d 0b       	st.w	r6[0x0],r11
80007044:	f4 ea 00 00 	ld.d	r10,r10[0]
80007048:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000704c:	0e 9b       	mov	r11,r7
8000704e:	18 95       	mov	r5,r12
80007050:	c4 e8       	rjmp	800070ec <get_arg+0x268>
80007052:	62 0a       	ld.w	r10,r1[0x0]
80007054:	5b fa       	cp.w	r10,-1
80007056:	c0 b1       	brne	8000706c <get_arg+0x1e8>
80007058:	50 19       	stdsp	sp[0x4],r9
8000705a:	50 28       	stdsp	sp[0x8],r8
8000705c:	e0 6a 00 80 	mov	r10,128
80007060:	30 0b       	mov	r11,0
80007062:	02 9c       	mov	r12,r1
80007064:	fe b0 fd 00 	rcall	80006a64 <memset>
80007068:	40 28       	lddsp	r8,sp[0x8]
8000706a:	40 19       	lddsp	r9,sp[0x4]
8000706c:	e4 cc 00 01 	sub	r12,r2,1
80007070:	0e 9b       	mov	r11,r7
80007072:	50 3c       	stdsp	sp[0xc],r12
80007074:	f2 0c 0c 49 	max	r9,r9,r12
80007078:	c3 a8       	rjmp	800070ec <get_arg+0x268>
8000707a:	62 0a       	ld.w	r10,r1[0x0]
8000707c:	5b fa       	cp.w	r10,-1
8000707e:	c0 b1       	brne	80007094 <get_arg+0x210>
80007080:	50 19       	stdsp	sp[0x4],r9
80007082:	50 28       	stdsp	sp[0x8],r8
80007084:	e0 6a 00 80 	mov	r10,128
80007088:	30 0b       	mov	r11,0
8000708a:	02 9c       	mov	r12,r1
8000708c:	fe b0 fc ec 	rcall	80006a64 <memset>
80007090:	40 28       	lddsp	r8,sp[0x8]
80007092:	40 19       	lddsp	r9,sp[0x4]
80007094:	20 12       	sub	r2,1
80007096:	30 0a       	mov	r10,0
80007098:	0e 9b       	mov	r11,r7
8000709a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000709e:	f2 02 0c 49 	max	r9,r9,r2
800070a2:	c2 58       	rjmp	800070ec <get_arg+0x268>
800070a4:	16 97       	mov	r7,r11
800070a6:	6c 0a       	ld.w	r10,r6[0x0]
800070a8:	f4 cb ff fc 	sub	r11,r10,-4
800070ac:	8d 0b       	st.w	r6[0x0],r11
800070ae:	74 0a       	ld.w	r10,r10[0x0]
800070b0:	0e 9b       	mov	r11,r7
800070b2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800070b6:	2f f5       	sub	r5,-1
800070b8:	c1 a8       	rjmp	800070ec <get_arg+0x268>
800070ba:	f4 c2 00 30 	sub	r2,r10,48
800070be:	c0 68       	rjmp	800070ca <get_arg+0x246>
800070c0:	e4 02 00 22 	add	r2,r2,r2<<0x2
800070c4:	2f f7       	sub	r7,-1
800070c6:	f4 02 00 12 	add	r2,r10,r2<<0x1
800070ca:	0f 8a       	ld.ub	r10,r7[0x0]
800070cc:	58 0a       	cp.w	r10,0
800070ce:	c0 e0       	breq	800070ea <get_arg+0x266>
800070d0:	23 0a       	sub	r10,48
800070d2:	58 9a       	cp.w	r10,9
800070d4:	fe 98 ff f6 	brls	800070c0 <get_arg+0x23c>
800070d8:	c0 98       	rjmp	800070ea <get_arg+0x266>
800070da:	2f f7       	sub	r7,-1
800070dc:	0f 8a       	ld.ub	r10,r7[0x0]
800070de:	58 0a       	cp.w	r10,0
800070e0:	c0 50       	breq	800070ea <get_arg+0x266>
800070e2:	23 0a       	sub	r10,48
800070e4:	58 9a       	cp.w	r10,9
800070e6:	fe 98 ff fa 	brls	800070da <get_arg+0x256>
800070ea:	0e 9b       	mov	r11,r7
800070ec:	40 7c       	lddsp	r12,sp[0x1c]
800070ee:	30 ba       	mov	r10,11
800070f0:	f4 0c 18 00 	cp.b	r12,r10
800070f4:	fe 91 fe f2 	brne	80006ed8 <get_arg+0x54>
800070f8:	40 42       	lddsp	r2,sp[0x10]
800070fa:	17 8c       	ld.ub	r12,r11[0x0]
800070fc:	0a 32       	cp.w	r2,r5
800070fe:	5f 4a       	srge	r10
80007100:	f0 0c 18 00 	cp.b	r12,r8
80007104:	5f 1c       	srne	r12
80007106:	f9 ea 00 0a 	and	r10,r12,r10
8000710a:	f0 0a 18 00 	cp.b	r10,r8
8000710e:	fe 91 fe cf 	brne	80006eac <get_arg+0x28>
80007112:	30 08       	mov	r8,0
80007114:	40 4e       	lddsp	lr,sp[0x10]
80007116:	17 8a       	ld.ub	r10,r11[0x0]
80007118:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000711c:	f0 0a 18 00 	cp.b	r10,r8
80007120:	fc 09 17 10 	movne	r9,lr
80007124:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007128:	06 9e       	mov	lr,r3
8000712a:	c2 a8       	rjmp	8000717e <get_arg+0x2fa>
8000712c:	62 0a       	ld.w	r10,r1[0x0]
8000712e:	58 3a       	cp.w	r10,3
80007130:	c1 e0       	breq	8000716c <get_arg+0x2e8>
80007132:	e0 89 00 07 	brgt	80007140 <get_arg+0x2bc>
80007136:	58 1a       	cp.w	r10,1
80007138:	c1 a0       	breq	8000716c <get_arg+0x2e8>
8000713a:	58 2a       	cp.w	r10,2
8000713c:	c1 81       	brne	8000716c <get_arg+0x2e8>
8000713e:	c0 58       	rjmp	80007148 <get_arg+0x2c4>
80007140:	58 5a       	cp.w	r10,5
80007142:	c0 c0       	breq	8000715a <get_arg+0x2d6>
80007144:	c0 b5       	brlt	8000715a <get_arg+0x2d6>
80007146:	c1 38       	rjmp	8000716c <get_arg+0x2e8>
80007148:	6c 0a       	ld.w	r10,r6[0x0]
8000714a:	f4 cc ff f8 	sub	r12,r10,-8
8000714e:	8d 0c       	st.w	r6[0x0],r12
80007150:	f4 e2 00 00 	ld.d	r2,r10[0]
80007154:	f0 e3 00 00 	st.d	r8[0],r2
80007158:	c1 08       	rjmp	80007178 <get_arg+0x2f4>
8000715a:	6c 0a       	ld.w	r10,r6[0x0]
8000715c:	f4 cc ff f8 	sub	r12,r10,-8
80007160:	8d 0c       	st.w	r6[0x0],r12
80007162:	f4 e2 00 00 	ld.d	r2,r10[0]
80007166:	f0 e3 00 00 	st.d	r8[0],r2
8000716a:	c0 78       	rjmp	80007178 <get_arg+0x2f4>
8000716c:	6c 0a       	ld.w	r10,r6[0x0]
8000716e:	f4 cc ff fc 	sub	r12,r10,-4
80007172:	8d 0c       	st.w	r6[0x0],r12
80007174:	74 0a       	ld.w	r10,r10[0x0]
80007176:	91 0a       	st.w	r8[0x0],r10
80007178:	2f f5       	sub	r5,-1
8000717a:	2f 88       	sub	r8,-8
8000717c:	2f c1       	sub	r1,-4
8000717e:	12 35       	cp.w	r5,r9
80007180:	fe 9a ff d6 	brle	8000712c <get_arg+0x2a8>
80007184:	1c 93       	mov	r3,lr
80007186:	40 52       	lddsp	r2,sp[0x14]
80007188:	40 6e       	lddsp	lr,sp[0x18]
8000718a:	85 05       	st.w	r2[0x0],r5
8000718c:	9d 0b       	st.w	lr[0x0],r11
8000718e:	40 4b       	lddsp	r11,sp[0x10]
80007190:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007194:	2f 8d       	sub	sp,-32
80007196:	d8 32       	popm	r0-r7,pc

80007198 <__sprint_r>:
80007198:	d4 21       	pushm	r4-r7,lr
8000719a:	14 97       	mov	r7,r10
8000719c:	74 28       	ld.w	r8,r10[0x8]
8000719e:	58 08       	cp.w	r8,0
800071a0:	c0 41       	brne	800071a8 <__sprint_r+0x10>
800071a2:	95 18       	st.w	r10[0x4],r8
800071a4:	10 9c       	mov	r12,r8
800071a6:	d8 22       	popm	r4-r7,pc
800071a8:	e0 a0 18 ba 	rcall	8000a31c <__sfvwrite_r>
800071ac:	30 08       	mov	r8,0
800071ae:	8f 18       	st.w	r7[0x4],r8
800071b0:	8f 28       	st.w	r7[0x8],r8
800071b2:	d8 22       	popm	r4-r7,pc

800071b4 <_vfprintf_r>:
800071b4:	d4 31       	pushm	r0-r7,lr
800071b6:	fa cd 06 bc 	sub	sp,sp,1724
800071ba:	51 09       	stdsp	sp[0x40],r9
800071bc:	16 91       	mov	r1,r11
800071be:	14 97       	mov	r7,r10
800071c0:	18 95       	mov	r5,r12
800071c2:	e0 a0 1a 1d 	rcall	8000a5fc <_localeconv_r>
800071c6:	78 0c       	ld.w	r12,r12[0x0]
800071c8:	50 cc       	stdsp	sp[0x30],r12
800071ca:	58 05       	cp.w	r5,0
800071cc:	c0 70       	breq	800071da <_vfprintf_r+0x26>
800071ce:	6a 68       	ld.w	r8,r5[0x18]
800071d0:	58 08       	cp.w	r8,0
800071d2:	c0 41       	brne	800071da <_vfprintf_r+0x26>
800071d4:	0a 9c       	mov	r12,r5
800071d6:	e0 a0 17 43 	rcall	8000a05c <__sinit>
800071da:	fe c8 a2 ca 	sub	r8,pc,-23862
800071de:	10 31       	cp.w	r1,r8
800071e0:	c0 31       	brne	800071e6 <_vfprintf_r+0x32>
800071e2:	6a 01       	ld.w	r1,r5[0x0]
800071e4:	c0 c8       	rjmp	800071fc <_vfprintf_r+0x48>
800071e6:	fe c8 a2 b6 	sub	r8,pc,-23882
800071ea:	10 31       	cp.w	r1,r8
800071ec:	c0 31       	brne	800071f2 <_vfprintf_r+0x3e>
800071ee:	6a 11       	ld.w	r1,r5[0x4]
800071f0:	c0 68       	rjmp	800071fc <_vfprintf_r+0x48>
800071f2:	fe c8 a2 a2 	sub	r8,pc,-23902
800071f6:	10 31       	cp.w	r1,r8
800071f8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800071fc:	82 68       	ld.sh	r8,r1[0xc]
800071fe:	ed b8 00 03 	bld	r8,0x3
80007202:	c0 41       	brne	8000720a <_vfprintf_r+0x56>
80007204:	62 48       	ld.w	r8,r1[0x10]
80007206:	58 08       	cp.w	r8,0
80007208:	c0 71       	brne	80007216 <_vfprintf_r+0x62>
8000720a:	02 9b       	mov	r11,r1
8000720c:	0a 9c       	mov	r12,r5
8000720e:	e0 a0 0f 5d 	rcall	800090c8 <__swsetup_r>
80007212:	e0 81 0f 54 	brne	800090ba <_vfprintf_r+0x1f06>
80007216:	82 68       	ld.sh	r8,r1[0xc]
80007218:	10 99       	mov	r9,r8
8000721a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000721e:	58 a9       	cp.w	r9,10
80007220:	c3 c1       	brne	80007298 <_vfprintf_r+0xe4>
80007222:	82 79       	ld.sh	r9,r1[0xe]
80007224:	30 0a       	mov	r10,0
80007226:	f4 09 19 00 	cp.h	r9,r10
8000722a:	c3 75       	brlt	80007298 <_vfprintf_r+0xe4>
8000722c:	a1 d8       	cbr	r8,0x1
8000722e:	fb 58 05 d0 	st.h	sp[1488],r8
80007232:	62 88       	ld.w	r8,r1[0x20]
80007234:	fb 48 05 e4 	st.w	sp[1508],r8
80007238:	62 a8       	ld.w	r8,r1[0x28]
8000723a:	fb 48 05 ec 	st.w	sp[1516],r8
8000723e:	fa c8 ff bc 	sub	r8,sp,-68
80007242:	fb 48 05 d4 	st.w	sp[1492],r8
80007246:	fb 48 05 c4 	st.w	sp[1476],r8
8000724a:	e0 68 04 00 	mov	r8,1024
8000724e:	fb 48 05 d8 	st.w	sp[1496],r8
80007252:	fb 48 05 cc 	st.w	sp[1484],r8
80007256:	30 08       	mov	r8,0
80007258:	fb 59 05 d2 	st.h	sp[1490],r9
8000725c:	0e 9a       	mov	r10,r7
8000725e:	41 09       	lddsp	r9,sp[0x40]
80007260:	fa c7 fa 3c 	sub	r7,sp,-1476
80007264:	fb 48 05 dc 	st.w	sp[1500],r8
80007268:	0a 9c       	mov	r12,r5
8000726a:	0e 9b       	mov	r11,r7
8000726c:	ca 4f       	rcall	800071b4 <_vfprintf_r>
8000726e:	50 bc       	stdsp	sp[0x2c],r12
80007270:	c0 95       	brlt	80007282 <_vfprintf_r+0xce>
80007272:	0e 9b       	mov	r11,r7
80007274:	0a 9c       	mov	r12,r5
80007276:	e0 a0 16 1b 	rcall	80009eac <_fflush_r>
8000727a:	40 be       	lddsp	lr,sp[0x2c]
8000727c:	f9 be 01 ff 	movne	lr,-1
80007280:	50 be       	stdsp	sp[0x2c],lr
80007282:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007286:	ed b8 00 06 	bld	r8,0x6
8000728a:	e0 81 0f 1a 	brne	800090be <_vfprintf_r+0x1f0a>
8000728e:	82 68       	ld.sh	r8,r1[0xc]
80007290:	a7 a8       	sbr	r8,0x6
80007292:	a2 68       	st.h	r1[0xc],r8
80007294:	e0 8f 0f 15 	bral	800090be <_vfprintf_r+0x1f0a>
80007298:	30 08       	mov	r8,0
8000729a:	fb 48 06 b4 	st.w	sp[1716],r8
8000729e:	fb 48 06 90 	st.w	sp[1680],r8
800072a2:	fb 48 06 8c 	st.w	sp[1676],r8
800072a6:	fb 48 06 b0 	st.w	sp[1712],r8
800072aa:	30 08       	mov	r8,0
800072ac:	30 09       	mov	r9,0
800072ae:	50 a7       	stdsp	sp[0x28],r7
800072b0:	50 78       	stdsp	sp[0x1c],r8
800072b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800072b6:	3f f8       	mov	r8,-1
800072b8:	50 59       	stdsp	sp[0x14],r9
800072ba:	fb 43 06 88 	st.w	sp[1672],r3
800072be:	fb 48 05 44 	st.w	sp[1348],r8
800072c2:	12 9c       	mov	r12,r9
800072c4:	50 69       	stdsp	sp[0x18],r9
800072c6:	50 d9       	stdsp	sp[0x34],r9
800072c8:	50 e9       	stdsp	sp[0x38],r9
800072ca:	50 b9       	stdsp	sp[0x2c],r9
800072cc:	12 97       	mov	r7,r9
800072ce:	0a 94       	mov	r4,r5
800072d0:	40 a2       	lddsp	r2,sp[0x28]
800072d2:	32 5a       	mov	r10,37
800072d4:	30 08       	mov	r8,0
800072d6:	c0 28       	rjmp	800072da <_vfprintf_r+0x126>
800072d8:	2f f2       	sub	r2,-1
800072da:	05 89       	ld.ub	r9,r2[0x0]
800072dc:	f0 09 18 00 	cp.b	r9,r8
800072e0:	5f 1b       	srne	r11
800072e2:	f4 09 18 00 	cp.b	r9,r10
800072e6:	5f 19       	srne	r9
800072e8:	f3 eb 00 0b 	and	r11,r9,r11
800072ec:	f0 0b 18 00 	cp.b	r11,r8
800072f0:	cf 41       	brne	800072d8 <_vfprintf_r+0x124>
800072f2:	40 ab       	lddsp	r11,sp[0x28]
800072f4:	e4 0b 01 06 	sub	r6,r2,r11
800072f8:	c1 e0       	breq	80007334 <_vfprintf_r+0x180>
800072fa:	fa f8 06 90 	ld.w	r8,sp[1680]
800072fe:	0c 08       	add	r8,r6
80007300:	87 0b       	st.w	r3[0x0],r11
80007302:	fb 48 06 90 	st.w	sp[1680],r8
80007306:	87 16       	st.w	r3[0x4],r6
80007308:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000730c:	2f f8       	sub	r8,-1
8000730e:	fb 48 06 8c 	st.w	sp[1676],r8
80007312:	58 78       	cp.w	r8,7
80007314:	e0 89 00 04 	brgt	8000731c <_vfprintf_r+0x168>
80007318:	2f 83       	sub	r3,-8
8000731a:	c0 a8       	rjmp	8000732e <_vfprintf_r+0x17a>
8000731c:	fa ca f9 78 	sub	r10,sp,-1672
80007320:	02 9b       	mov	r11,r1
80007322:	08 9c       	mov	r12,r4
80007324:	c3 af       	rcall	80007198 <__sprint_r>
80007326:	e0 81 0e c6 	brne	800090b2 <_vfprintf_r+0x1efe>
8000732a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000732e:	40 ba       	lddsp	r10,sp[0x2c]
80007330:	0c 0a       	add	r10,r6
80007332:	50 ba       	stdsp	sp[0x2c],r10
80007334:	05 89       	ld.ub	r9,r2[0x0]
80007336:	30 08       	mov	r8,0
80007338:	f0 09 18 00 	cp.b	r9,r8
8000733c:	e0 80 0e aa 	breq	80009090 <_vfprintf_r+0x1edc>
80007340:	30 09       	mov	r9,0
80007342:	fb 68 06 bb 	st.b	sp[1723],r8
80007346:	0e 96       	mov	r6,r7
80007348:	e4 c8 ff ff 	sub	r8,r2,-1
8000734c:	3f fe       	mov	lr,-1
8000734e:	50 93       	stdsp	sp[0x24],r3
80007350:	50 41       	stdsp	sp[0x10],r1
80007352:	0e 93       	mov	r3,r7
80007354:	04 91       	mov	r1,r2
80007356:	50 89       	stdsp	sp[0x20],r9
80007358:	50 a8       	stdsp	sp[0x28],r8
8000735a:	50 2e       	stdsp	sp[0x8],lr
8000735c:	50 39       	stdsp	sp[0xc],r9
8000735e:	12 95       	mov	r5,r9
80007360:	12 90       	mov	r0,r9
80007362:	10 97       	mov	r7,r8
80007364:	08 92       	mov	r2,r4
80007366:	c0 78       	rjmp	80007374 <_vfprintf_r+0x1c0>
80007368:	3f fc       	mov	r12,-1
8000736a:	08 97       	mov	r7,r4
8000736c:	50 2c       	stdsp	sp[0x8],r12
8000736e:	c0 38       	rjmp	80007374 <_vfprintf_r+0x1c0>
80007370:	30 0b       	mov	r11,0
80007372:	50 3b       	stdsp	sp[0xc],r11
80007374:	0f 38       	ld.ub	r8,r7++
80007376:	c0 28       	rjmp	8000737a <_vfprintf_r+0x1c6>
80007378:	12 90       	mov	r0,r9
8000737a:	f0 c9 00 20 	sub	r9,r8,32
8000737e:	e0 49 00 58 	cp.w	r9,88
80007382:	e0 8b 0a 30 	brhi	800087e2 <_vfprintf_r+0x162e>
80007386:	fe ca a8 1e 	sub	r10,pc,-22498
8000738a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000738e:	50 a7       	stdsp	sp[0x28],r7
80007390:	50 80       	stdsp	sp[0x20],r0
80007392:	0c 97       	mov	r7,r6
80007394:	04 94       	mov	r4,r2
80007396:	06 96       	mov	r6,r3
80007398:	02 92       	mov	r2,r1
8000739a:	fe c9 a5 f6 	sub	r9,pc,-23050
8000739e:	40 93       	lddsp	r3,sp[0x24]
800073a0:	10 90       	mov	r0,r8
800073a2:	40 41       	lddsp	r1,sp[0x10]
800073a4:	50 d9       	stdsp	sp[0x34],r9
800073a6:	e0 8f 08 8e 	bral	800084c2 <_vfprintf_r+0x130e>
800073aa:	30 08       	mov	r8,0
800073ac:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800073b0:	f0 09 18 00 	cp.b	r9,r8
800073b4:	ce 01       	brne	80007374 <_vfprintf_r+0x1c0>
800073b6:	32 08       	mov	r8,32
800073b8:	c6 e8       	rjmp	80007494 <_vfprintf_r+0x2e0>
800073ba:	a1 a5       	sbr	r5,0x0
800073bc:	cd cb       	rjmp	80007374 <_vfprintf_r+0x1c0>
800073be:	0f 89       	ld.ub	r9,r7[0x0]
800073c0:	f2 c8 00 30 	sub	r8,r9,48
800073c4:	58 98       	cp.w	r8,9
800073c6:	e0 8b 00 1d 	brhi	80007400 <_vfprintf_r+0x24c>
800073ca:	ee c8 ff ff 	sub	r8,r7,-1
800073ce:	30 0b       	mov	r11,0
800073d0:	23 09       	sub	r9,48
800073d2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800073d6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800073da:	11 39       	ld.ub	r9,r8++
800073dc:	f2 ca 00 30 	sub	r10,r9,48
800073e0:	58 9a       	cp.w	r10,9
800073e2:	fe 98 ff f7 	brls	800073d0 <_vfprintf_r+0x21c>
800073e6:	e0 49 00 24 	cp.w	r9,36
800073ea:	cc 31       	brne	80007370 <_vfprintf_r+0x1bc>
800073ec:	e0 4b 00 20 	cp.w	r11,32
800073f0:	e0 89 0e 60 	brgt	800090b0 <_vfprintf_r+0x1efc>
800073f4:	20 1b       	sub	r11,1
800073f6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800073fa:	12 3b       	cp.w	r11,r9
800073fc:	c0 95       	brlt	8000740e <_vfprintf_r+0x25a>
800073fe:	c1 08       	rjmp	8000741e <_vfprintf_r+0x26a>
80007400:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007404:	ec ca ff ff 	sub	r10,r6,-1
80007408:	12 36       	cp.w	r6,r9
8000740a:	c1 f5       	brlt	80007448 <_vfprintf_r+0x294>
8000740c:	c2 68       	rjmp	80007458 <_vfprintf_r+0x2a4>
8000740e:	fa ce f9 44 	sub	lr,sp,-1724
80007412:	10 97       	mov	r7,r8
80007414:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007418:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000741c:	c3 58       	rjmp	80007486 <_vfprintf_r+0x2d2>
8000741e:	10 97       	mov	r7,r8
80007420:	fa c8 f9 50 	sub	r8,sp,-1712
80007424:	1a d8       	st.w	--sp,r8
80007426:	fa c8 fa b8 	sub	r8,sp,-1352
8000742a:	1a d8       	st.w	--sp,r8
8000742c:	fa c8 fb b4 	sub	r8,sp,-1100
80007430:	02 9a       	mov	r10,r1
80007432:	1a d8       	st.w	--sp,r8
80007434:	04 9c       	mov	r12,r2
80007436:	fa c8 f9 40 	sub	r8,sp,-1728
8000743a:	fa c9 ff b4 	sub	r9,sp,-76
8000743e:	fe b0 fd 23 	rcall	80006e84 <get_arg>
80007442:	2f dd       	sub	sp,-12
80007444:	78 00       	ld.w	r0,r12[0x0]
80007446:	c2 08       	rjmp	80007486 <_vfprintf_r+0x2d2>
80007448:	fa cc f9 44 	sub	r12,sp,-1724
8000744c:	14 96       	mov	r6,r10
8000744e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007452:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007456:	c1 88       	rjmp	80007486 <_vfprintf_r+0x2d2>
80007458:	41 08       	lddsp	r8,sp[0x40]
8000745a:	59 f9       	cp.w	r9,31
8000745c:	e0 89 00 11 	brgt	8000747e <_vfprintf_r+0x2ca>
80007460:	f0 cb ff fc 	sub	r11,r8,-4
80007464:	51 0b       	stdsp	sp[0x40],r11
80007466:	70 00       	ld.w	r0,r8[0x0]
80007468:	fa cb f9 44 	sub	r11,sp,-1724
8000746c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007470:	f1 40 fd 88 	st.w	r8[-632],r0
80007474:	2f f9       	sub	r9,-1
80007476:	14 96       	mov	r6,r10
80007478:	fb 49 06 b4 	st.w	sp[1716],r9
8000747c:	c0 58       	rjmp	80007486 <_vfprintf_r+0x2d2>
8000747e:	70 00       	ld.w	r0,r8[0x0]
80007480:	14 96       	mov	r6,r10
80007482:	2f c8       	sub	r8,-4
80007484:	51 08       	stdsp	sp[0x40],r8
80007486:	58 00       	cp.w	r0,0
80007488:	fe 94 ff 76 	brge	80007374 <_vfprintf_r+0x1c0>
8000748c:	5c 30       	neg	r0
8000748e:	a3 a5       	sbr	r5,0x2
80007490:	c7 2b       	rjmp	80007374 <_vfprintf_r+0x1c0>
80007492:	32 b8       	mov	r8,43
80007494:	fb 68 06 bb 	st.b	sp[1723],r8
80007498:	c6 eb       	rjmp	80007374 <_vfprintf_r+0x1c0>
8000749a:	0f 38       	ld.ub	r8,r7++
8000749c:	e0 48 00 2a 	cp.w	r8,42
800074a0:	c0 30       	breq	800074a6 <_vfprintf_r+0x2f2>
800074a2:	30 09       	mov	r9,0
800074a4:	c7 98       	rjmp	80007596 <_vfprintf_r+0x3e2>
800074a6:	0f 88       	ld.ub	r8,r7[0x0]
800074a8:	f0 c9 00 30 	sub	r9,r8,48
800074ac:	58 99       	cp.w	r9,9
800074ae:	e0 8b 00 1f 	brhi	800074ec <_vfprintf_r+0x338>
800074b2:	ee c4 ff ff 	sub	r4,r7,-1
800074b6:	30 0b       	mov	r11,0
800074b8:	23 08       	sub	r8,48
800074ba:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800074be:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800074c2:	09 38       	ld.ub	r8,r4++
800074c4:	f0 c9 00 30 	sub	r9,r8,48
800074c8:	58 99       	cp.w	r9,9
800074ca:	fe 98 ff f7 	brls	800074b8 <_vfprintf_r+0x304>
800074ce:	e0 48 00 24 	cp.w	r8,36
800074d2:	fe 91 ff 4f 	brne	80007370 <_vfprintf_r+0x1bc>
800074d6:	e0 4b 00 20 	cp.w	r11,32
800074da:	e0 89 0d eb 	brgt	800090b0 <_vfprintf_r+0x1efc>
800074de:	20 1b       	sub	r11,1
800074e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074e4:	10 3b       	cp.w	r11,r8
800074e6:	c0 a5       	brlt	800074fa <_vfprintf_r+0x346>
800074e8:	c1 18       	rjmp	8000750a <_vfprintf_r+0x356>
800074ea:	d7 03       	nop
800074ec:	fa fa 06 b4 	ld.w	r10,sp[1716]
800074f0:	ec c9 ff ff 	sub	r9,r6,-1
800074f4:	14 36       	cp.w	r6,r10
800074f6:	c1 f5       	brlt	80007534 <_vfprintf_r+0x380>
800074f8:	c2 88       	rjmp	80007548 <_vfprintf_r+0x394>
800074fa:	fa ca f9 44 	sub	r10,sp,-1724
800074fe:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007502:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007506:	50 2b       	stdsp	sp[0x8],r11
80007508:	c3 c8       	rjmp	80007580 <_vfprintf_r+0x3cc>
8000750a:	fa c8 f9 50 	sub	r8,sp,-1712
8000750e:	1a d8       	st.w	--sp,r8
80007510:	fa c8 fa b8 	sub	r8,sp,-1352
80007514:	1a d8       	st.w	--sp,r8
80007516:	fa c8 fb b4 	sub	r8,sp,-1100
8000751a:	02 9a       	mov	r10,r1
8000751c:	1a d8       	st.w	--sp,r8
8000751e:	04 9c       	mov	r12,r2
80007520:	fa c8 f9 40 	sub	r8,sp,-1728
80007524:	fa c9 ff b4 	sub	r9,sp,-76
80007528:	fe b0 fc ae 	rcall	80006e84 <get_arg>
8000752c:	2f dd       	sub	sp,-12
8000752e:	78 0c       	ld.w	r12,r12[0x0]
80007530:	50 2c       	stdsp	sp[0x8],r12
80007532:	c2 78       	rjmp	80007580 <_vfprintf_r+0x3cc>
80007534:	12 96       	mov	r6,r9
80007536:	0e 94       	mov	r4,r7
80007538:	fa c9 f9 44 	sub	r9,sp,-1724
8000753c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007540:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007544:	50 28       	stdsp	sp[0x8],r8
80007546:	c1 d8       	rjmp	80007580 <_vfprintf_r+0x3cc>
80007548:	41 08       	lddsp	r8,sp[0x40]
8000754a:	59 fa       	cp.w	r10,31
8000754c:	e0 89 00 14 	brgt	80007574 <_vfprintf_r+0x3c0>
80007550:	f0 cb ff fc 	sub	r11,r8,-4
80007554:	70 08       	ld.w	r8,r8[0x0]
80007556:	51 0b       	stdsp	sp[0x40],r11
80007558:	50 28       	stdsp	sp[0x8],r8
8000755a:	fa c6 f9 44 	sub	r6,sp,-1724
8000755e:	40 2e       	lddsp	lr,sp[0x8]
80007560:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007564:	f1 4e fd 88 	st.w	r8[-632],lr
80007568:	2f fa       	sub	r10,-1
8000756a:	0e 94       	mov	r4,r7
8000756c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007570:	12 96       	mov	r6,r9
80007572:	c0 78       	rjmp	80007580 <_vfprintf_r+0x3cc>
80007574:	70 0c       	ld.w	r12,r8[0x0]
80007576:	0e 94       	mov	r4,r7
80007578:	2f c8       	sub	r8,-4
8000757a:	50 2c       	stdsp	sp[0x8],r12
8000757c:	12 96       	mov	r6,r9
8000757e:	51 08       	stdsp	sp[0x40],r8
80007580:	40 2b       	lddsp	r11,sp[0x8]
80007582:	58 0b       	cp.w	r11,0
80007584:	fe 95 fe f2 	brlt	80007368 <_vfprintf_r+0x1b4>
80007588:	08 97       	mov	r7,r4
8000758a:	cf 5a       	rjmp	80007374 <_vfprintf_r+0x1c0>
8000758c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007590:	0f 38       	ld.ub	r8,r7++
80007592:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007596:	f0 ca 00 30 	sub	r10,r8,48
8000759a:	58 9a       	cp.w	r10,9
8000759c:	fe 98 ff f8 	brls	8000758c <_vfprintf_r+0x3d8>
800075a0:	3f fa       	mov	r10,-1
800075a2:	f2 0a 0c 49 	max	r9,r9,r10
800075a6:	50 29       	stdsp	sp[0x8],r9
800075a8:	ce 9a       	rjmp	8000737a <_vfprintf_r+0x1c6>
800075aa:	a7 b5       	sbr	r5,0x7
800075ac:	ce 4a       	rjmp	80007374 <_vfprintf_r+0x1c0>
800075ae:	30 09       	mov	r9,0
800075b0:	23 08       	sub	r8,48
800075b2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075b6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800075ba:	0f 38       	ld.ub	r8,r7++
800075bc:	f0 ca 00 30 	sub	r10,r8,48
800075c0:	58 9a       	cp.w	r10,9
800075c2:	fe 98 ff f7 	brls	800075b0 <_vfprintf_r+0x3fc>
800075c6:	e0 48 00 24 	cp.w	r8,36
800075ca:	fe 91 fe d7 	brne	80007378 <_vfprintf_r+0x1c4>
800075ce:	e0 49 00 20 	cp.w	r9,32
800075d2:	e0 89 0d 6f 	brgt	800090b0 <_vfprintf_r+0x1efc>
800075d6:	f2 c3 00 01 	sub	r3,r9,1
800075da:	30 19       	mov	r9,1
800075dc:	50 39       	stdsp	sp[0xc],r9
800075de:	cc ba       	rjmp	80007374 <_vfprintf_r+0x1c0>
800075e0:	a3 b5       	sbr	r5,0x3
800075e2:	cc 9a       	rjmp	80007374 <_vfprintf_r+0x1c0>
800075e4:	a7 a5       	sbr	r5,0x6
800075e6:	cc 7a       	rjmp	80007374 <_vfprintf_r+0x1c0>
800075e8:	0a 98       	mov	r8,r5
800075ea:	a5 b5       	sbr	r5,0x5
800075ec:	a5 a8       	sbr	r8,0x4
800075ee:	0f 89       	ld.ub	r9,r7[0x0]
800075f0:	36 ce       	mov	lr,108
800075f2:	fc 09 18 00 	cp.b	r9,lr
800075f6:	f7 b7 00 ff 	subeq	r7,-1
800075fa:	f0 05 17 10 	movne	r5,r8
800075fe:	cb ba       	rjmp	80007374 <_vfprintf_r+0x1c0>
80007600:	a5 b5       	sbr	r5,0x5
80007602:	cb 9a       	rjmp	80007374 <_vfprintf_r+0x1c0>
80007604:	50 a7       	stdsp	sp[0x28],r7
80007606:	50 80       	stdsp	sp[0x20],r0
80007608:	0c 97       	mov	r7,r6
8000760a:	10 90       	mov	r0,r8
8000760c:	06 96       	mov	r6,r3
8000760e:	04 94       	mov	r4,r2
80007610:	40 93       	lddsp	r3,sp[0x24]
80007612:	02 92       	mov	r2,r1
80007614:	0e 99       	mov	r9,r7
80007616:	40 41       	lddsp	r1,sp[0x10]
80007618:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000761c:	40 3c       	lddsp	r12,sp[0xc]
8000761e:	58 0c       	cp.w	r12,0
80007620:	c1 d0       	breq	8000765a <_vfprintf_r+0x4a6>
80007622:	10 36       	cp.w	r6,r8
80007624:	c0 64       	brge	80007630 <_vfprintf_r+0x47c>
80007626:	fa cb f9 44 	sub	r11,sp,-1724
8000762a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000762e:	c1 d8       	rjmp	80007668 <_vfprintf_r+0x4b4>
80007630:	fa c8 f9 50 	sub	r8,sp,-1712
80007634:	1a d8       	st.w	--sp,r8
80007636:	fa c8 fa b8 	sub	r8,sp,-1352
8000763a:	1a d8       	st.w	--sp,r8
8000763c:	fa c8 fb b4 	sub	r8,sp,-1100
80007640:	1a d8       	st.w	--sp,r8
80007642:	fa c8 f9 40 	sub	r8,sp,-1728
80007646:	fa c9 ff b4 	sub	r9,sp,-76
8000764a:	04 9a       	mov	r10,r2
8000764c:	0c 9b       	mov	r11,r6
8000764e:	08 9c       	mov	r12,r4
80007650:	fe b0 fc 1a 	rcall	80006e84 <get_arg>
80007654:	2f dd       	sub	sp,-12
80007656:	19 b8       	ld.ub	r8,r12[0x3]
80007658:	c2 28       	rjmp	8000769c <_vfprintf_r+0x4e8>
8000765a:	2f f7       	sub	r7,-1
8000765c:	10 39       	cp.w	r9,r8
8000765e:	c0 84       	brge	8000766e <_vfprintf_r+0x4ba>
80007660:	fa ca f9 44 	sub	r10,sp,-1724
80007664:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007668:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000766c:	c1 88       	rjmp	8000769c <_vfprintf_r+0x4e8>
8000766e:	41 09       	lddsp	r9,sp[0x40]
80007670:	59 f8       	cp.w	r8,31
80007672:	e0 89 00 12 	brgt	80007696 <_vfprintf_r+0x4e2>
80007676:	f2 ca ff fc 	sub	r10,r9,-4
8000767a:	51 0a       	stdsp	sp[0x40],r10
8000767c:	72 09       	ld.w	r9,r9[0x0]
8000767e:	fa c6 f9 44 	sub	r6,sp,-1724
80007682:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007686:	2f f8       	sub	r8,-1
80007688:	f5 49 fd 88 	st.w	r10[-632],r9
8000768c:	fb 48 06 b4 	st.w	sp[1716],r8
80007690:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007694:	c0 48       	rjmp	8000769c <_vfprintf_r+0x4e8>
80007696:	13 b8       	ld.ub	r8,r9[0x3]
80007698:	2f c9       	sub	r9,-4
8000769a:	51 09       	stdsp	sp[0x40],r9
8000769c:	fb 68 06 60 	st.b	sp[1632],r8
800076a0:	30 0e       	mov	lr,0
800076a2:	30 08       	mov	r8,0
800076a4:	30 12       	mov	r2,1
800076a6:	fb 68 06 bb 	st.b	sp[1723],r8
800076aa:	50 2e       	stdsp	sp[0x8],lr
800076ac:	e0 8f 08 ad 	bral	80008806 <_vfprintf_r+0x1652>
800076b0:	50 a7       	stdsp	sp[0x28],r7
800076b2:	50 80       	stdsp	sp[0x20],r0
800076b4:	0c 97       	mov	r7,r6
800076b6:	04 94       	mov	r4,r2
800076b8:	06 96       	mov	r6,r3
800076ba:	02 92       	mov	r2,r1
800076bc:	40 93       	lddsp	r3,sp[0x24]
800076be:	10 90       	mov	r0,r8
800076c0:	40 41       	lddsp	r1,sp[0x10]
800076c2:	a5 a5       	sbr	r5,0x4
800076c4:	c0 a8       	rjmp	800076d8 <_vfprintf_r+0x524>
800076c6:	50 a7       	stdsp	sp[0x28],r7
800076c8:	50 80       	stdsp	sp[0x20],r0
800076ca:	0c 97       	mov	r7,r6
800076cc:	04 94       	mov	r4,r2
800076ce:	06 96       	mov	r6,r3
800076d0:	02 92       	mov	r2,r1
800076d2:	40 93       	lddsp	r3,sp[0x24]
800076d4:	10 90       	mov	r0,r8
800076d6:	40 41       	lddsp	r1,sp[0x10]
800076d8:	ed b5 00 05 	bld	r5,0x5
800076dc:	c5 11       	brne	8000777e <_vfprintf_r+0x5ca>
800076de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076e2:	40 3c       	lddsp	r12,sp[0xc]
800076e4:	58 0c       	cp.w	r12,0
800076e6:	c1 e0       	breq	80007722 <_vfprintf_r+0x56e>
800076e8:	10 36       	cp.w	r6,r8
800076ea:	c0 64       	brge	800076f6 <_vfprintf_r+0x542>
800076ec:	fa cb f9 44 	sub	r11,sp,-1724
800076f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076f4:	c2 08       	rjmp	80007734 <_vfprintf_r+0x580>
800076f6:	fa c8 f9 50 	sub	r8,sp,-1712
800076fa:	1a d8       	st.w	--sp,r8
800076fc:	fa c8 fa b8 	sub	r8,sp,-1352
80007700:	0c 9b       	mov	r11,r6
80007702:	1a d8       	st.w	--sp,r8
80007704:	fa c8 fb b4 	sub	r8,sp,-1100
80007708:	1a d8       	st.w	--sp,r8
8000770a:	fa c9 ff b4 	sub	r9,sp,-76
8000770e:	fa c8 f9 40 	sub	r8,sp,-1728
80007712:	04 9a       	mov	r10,r2
80007714:	08 9c       	mov	r12,r4
80007716:	fe b0 fb b7 	rcall	80006e84 <get_arg>
8000771a:	2f dd       	sub	sp,-12
8000771c:	78 1b       	ld.w	r11,r12[0x4]
8000771e:	78 09       	ld.w	r9,r12[0x0]
80007720:	c2 b8       	rjmp	80007776 <_vfprintf_r+0x5c2>
80007722:	ee ca ff ff 	sub	r10,r7,-1
80007726:	10 37       	cp.w	r7,r8
80007728:	c0 b4       	brge	8000773e <_vfprintf_r+0x58a>
8000772a:	fa c9 f9 44 	sub	r9,sp,-1724
8000772e:	14 97       	mov	r7,r10
80007730:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007734:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007738:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000773c:	c1 d8       	rjmp	80007776 <_vfprintf_r+0x5c2>
8000773e:	41 09       	lddsp	r9,sp[0x40]
80007740:	59 f8       	cp.w	r8,31
80007742:	e0 89 00 14 	brgt	8000776a <_vfprintf_r+0x5b6>
80007746:	f2 cb ff f8 	sub	r11,r9,-8
8000774a:	51 0b       	stdsp	sp[0x40],r11
8000774c:	fa c6 f9 44 	sub	r6,sp,-1724
80007750:	72 1b       	ld.w	r11,r9[0x4]
80007752:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007756:	72 09       	ld.w	r9,r9[0x0]
80007758:	f9 4b fd 8c 	st.w	r12[-628],r11
8000775c:	f9 49 fd 88 	st.w	r12[-632],r9
80007760:	2f f8       	sub	r8,-1
80007762:	14 97       	mov	r7,r10
80007764:	fb 48 06 b4 	st.w	sp[1716],r8
80007768:	c0 78       	rjmp	80007776 <_vfprintf_r+0x5c2>
8000776a:	f2 c8 ff f8 	sub	r8,r9,-8
8000776e:	72 1b       	ld.w	r11,r9[0x4]
80007770:	14 97       	mov	r7,r10
80007772:	51 08       	stdsp	sp[0x40],r8
80007774:	72 09       	ld.w	r9,r9[0x0]
80007776:	16 98       	mov	r8,r11
80007778:	fa e9 00 00 	st.d	sp[0],r8
8000777c:	ca e8       	rjmp	800078d8 <_vfprintf_r+0x724>
8000777e:	ed b5 00 04 	bld	r5,0x4
80007782:	c1 71       	brne	800077b0 <_vfprintf_r+0x5fc>
80007784:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007788:	40 3e       	lddsp	lr,sp[0xc]
8000778a:	58 0e       	cp.w	lr,0
8000778c:	c0 80       	breq	8000779c <_vfprintf_r+0x5e8>
8000778e:	10 36       	cp.w	r6,r8
80007790:	c6 94       	brge	80007862 <_vfprintf_r+0x6ae>
80007792:	fa cc f9 44 	sub	r12,sp,-1724
80007796:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000779a:	c8 28       	rjmp	8000789e <_vfprintf_r+0x6ea>
8000779c:	ee ca ff ff 	sub	r10,r7,-1
800077a0:	10 37       	cp.w	r7,r8
800077a2:	e0 84 00 81 	brge	800078a4 <_vfprintf_r+0x6f0>
800077a6:	fa cb f9 44 	sub	r11,sp,-1724
800077aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077ae:	c7 78       	rjmp	8000789c <_vfprintf_r+0x6e8>
800077b0:	ed b5 00 06 	bld	r5,0x6
800077b4:	c4 b1       	brne	8000784a <_vfprintf_r+0x696>
800077b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077ba:	40 3c       	lddsp	r12,sp[0xc]
800077bc:	58 0c       	cp.w	r12,0
800077be:	c1 d0       	breq	800077f8 <_vfprintf_r+0x644>
800077c0:	10 36       	cp.w	r6,r8
800077c2:	c0 64       	brge	800077ce <_vfprintf_r+0x61a>
800077c4:	fa cb f9 44 	sub	r11,sp,-1724
800077c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077cc:	c1 f8       	rjmp	8000780a <_vfprintf_r+0x656>
800077ce:	fa c8 f9 50 	sub	r8,sp,-1712
800077d2:	1a d8       	st.w	--sp,r8
800077d4:	fa c8 fa b8 	sub	r8,sp,-1352
800077d8:	1a d8       	st.w	--sp,r8
800077da:	fa c8 fb b4 	sub	r8,sp,-1100
800077de:	1a d8       	st.w	--sp,r8
800077e0:	fa c8 f9 40 	sub	r8,sp,-1728
800077e4:	fa c9 ff b4 	sub	r9,sp,-76
800077e8:	04 9a       	mov	r10,r2
800077ea:	0c 9b       	mov	r11,r6
800077ec:	08 9c       	mov	r12,r4
800077ee:	fe b0 fb 4b 	rcall	80006e84 <get_arg>
800077f2:	2f dd       	sub	sp,-12
800077f4:	98 18       	ld.sh	r8,r12[0x2]
800077f6:	c2 68       	rjmp	80007842 <_vfprintf_r+0x68e>
800077f8:	ee ca ff ff 	sub	r10,r7,-1
800077fc:	10 37       	cp.w	r7,r8
800077fe:	c0 94       	brge	80007810 <_vfprintf_r+0x65c>
80007800:	fa c9 f9 44 	sub	r9,sp,-1724
80007804:	14 97       	mov	r7,r10
80007806:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000780a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000780e:	c1 a8       	rjmp	80007842 <_vfprintf_r+0x68e>
80007810:	41 09       	lddsp	r9,sp[0x40]
80007812:	59 f8       	cp.w	r8,31
80007814:	e0 89 00 13 	brgt	8000783a <_vfprintf_r+0x686>
80007818:	f2 cb ff fc 	sub	r11,r9,-4
8000781c:	51 0b       	stdsp	sp[0x40],r11
8000781e:	72 09       	ld.w	r9,r9[0x0]
80007820:	fa c6 f9 44 	sub	r6,sp,-1724
80007824:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007828:	2f f8       	sub	r8,-1
8000782a:	f7 49 fd 88 	st.w	r11[-632],r9
8000782e:	fb 48 06 b4 	st.w	sp[1716],r8
80007832:	14 97       	mov	r7,r10
80007834:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007838:	c0 58       	rjmp	80007842 <_vfprintf_r+0x68e>
8000783a:	92 18       	ld.sh	r8,r9[0x2]
8000783c:	14 97       	mov	r7,r10
8000783e:	2f c9       	sub	r9,-4
80007840:	51 09       	stdsp	sp[0x40],r9
80007842:	50 18       	stdsp	sp[0x4],r8
80007844:	bf 58       	asr	r8,0x1f
80007846:	50 08       	stdsp	sp[0x0],r8
80007848:	c4 88       	rjmp	800078d8 <_vfprintf_r+0x724>
8000784a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000784e:	40 3c       	lddsp	r12,sp[0xc]
80007850:	58 0c       	cp.w	r12,0
80007852:	c1 d0       	breq	8000788c <_vfprintf_r+0x6d8>
80007854:	10 36       	cp.w	r6,r8
80007856:	c0 64       	brge	80007862 <_vfprintf_r+0x6ae>
80007858:	fa cb f9 44 	sub	r11,sp,-1724
8000785c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007860:	c1 f8       	rjmp	8000789e <_vfprintf_r+0x6ea>
80007862:	fa c8 f9 50 	sub	r8,sp,-1712
80007866:	1a d8       	st.w	--sp,r8
80007868:	fa c8 fa b8 	sub	r8,sp,-1352
8000786c:	0c 9b       	mov	r11,r6
8000786e:	1a d8       	st.w	--sp,r8
80007870:	fa c8 fb b4 	sub	r8,sp,-1100
80007874:	04 9a       	mov	r10,r2
80007876:	1a d8       	st.w	--sp,r8
80007878:	08 9c       	mov	r12,r4
8000787a:	fa c8 f9 40 	sub	r8,sp,-1728
8000787e:	fa c9 ff b4 	sub	r9,sp,-76
80007882:	fe b0 fb 01 	rcall	80006e84 <get_arg>
80007886:	2f dd       	sub	sp,-12
80007888:	78 0b       	ld.w	r11,r12[0x0]
8000788a:	c2 48       	rjmp	800078d2 <_vfprintf_r+0x71e>
8000788c:	ee ca ff ff 	sub	r10,r7,-1
80007890:	10 37       	cp.w	r7,r8
80007892:	c0 94       	brge	800078a4 <_vfprintf_r+0x6f0>
80007894:	fa c9 f9 44 	sub	r9,sp,-1724
80007898:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000789c:	14 97       	mov	r7,r10
8000789e:	ec fb fd 88 	ld.w	r11,r6[-632]
800078a2:	c1 88       	rjmp	800078d2 <_vfprintf_r+0x71e>
800078a4:	41 09       	lddsp	r9,sp[0x40]
800078a6:	59 f8       	cp.w	r8,31
800078a8:	e0 89 00 11 	brgt	800078ca <_vfprintf_r+0x716>
800078ac:	f2 cb ff fc 	sub	r11,r9,-4
800078b0:	51 0b       	stdsp	sp[0x40],r11
800078b2:	fa c6 f9 44 	sub	r6,sp,-1724
800078b6:	72 0b       	ld.w	r11,r9[0x0]
800078b8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800078bc:	f3 4b fd 88 	st.w	r9[-632],r11
800078c0:	2f f8       	sub	r8,-1
800078c2:	14 97       	mov	r7,r10
800078c4:	fb 48 06 b4 	st.w	sp[1716],r8
800078c8:	c0 58       	rjmp	800078d2 <_vfprintf_r+0x71e>
800078ca:	72 0b       	ld.w	r11,r9[0x0]
800078cc:	14 97       	mov	r7,r10
800078ce:	2f c9       	sub	r9,-4
800078d0:	51 09       	stdsp	sp[0x40],r9
800078d2:	50 1b       	stdsp	sp[0x4],r11
800078d4:	bf 5b       	asr	r11,0x1f
800078d6:	50 0b       	stdsp	sp[0x0],r11
800078d8:	fa ea 00 00 	ld.d	r10,sp[0]
800078dc:	58 0a       	cp.w	r10,0
800078de:	5c 2b       	cpc	r11
800078e0:	c0 e4       	brge	800078fc <_vfprintf_r+0x748>
800078e2:	30 08       	mov	r8,0
800078e4:	fa ea 00 00 	ld.d	r10,sp[0]
800078e8:	30 09       	mov	r9,0
800078ea:	f0 0a 01 0a 	sub	r10,r8,r10
800078ee:	f2 0b 01 4b 	sbc	r11,r9,r11
800078f2:	32 d8       	mov	r8,45
800078f4:	fa eb 00 00 	st.d	sp[0],r10
800078f8:	fb 68 06 bb 	st.b	sp[1723],r8
800078fc:	30 18       	mov	r8,1
800078fe:	e0 8f 06 fa 	bral	800086f2 <_vfprintf_r+0x153e>
80007902:	50 a7       	stdsp	sp[0x28],r7
80007904:	50 80       	stdsp	sp[0x20],r0
80007906:	0c 97       	mov	r7,r6
80007908:	04 94       	mov	r4,r2
8000790a:	06 96       	mov	r6,r3
8000790c:	02 92       	mov	r2,r1
8000790e:	40 93       	lddsp	r3,sp[0x24]
80007910:	10 90       	mov	r0,r8
80007912:	40 41       	lddsp	r1,sp[0x10]
80007914:	0e 99       	mov	r9,r7
80007916:	ed b5 00 03 	bld	r5,0x3
8000791a:	c4 11       	brne	8000799c <_vfprintf_r+0x7e8>
8000791c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007920:	40 3a       	lddsp	r10,sp[0xc]
80007922:	58 0a       	cp.w	r10,0
80007924:	c1 90       	breq	80007956 <_vfprintf_r+0x7a2>
80007926:	10 36       	cp.w	r6,r8
80007928:	c6 45       	brlt	800079f0 <_vfprintf_r+0x83c>
8000792a:	fa c8 f9 50 	sub	r8,sp,-1712
8000792e:	1a d8       	st.w	--sp,r8
80007930:	fa c8 fa b8 	sub	r8,sp,-1352
80007934:	1a d8       	st.w	--sp,r8
80007936:	fa c8 fb b4 	sub	r8,sp,-1100
8000793a:	0c 9b       	mov	r11,r6
8000793c:	1a d8       	st.w	--sp,r8
8000793e:	04 9a       	mov	r10,r2
80007940:	fa c8 f9 40 	sub	r8,sp,-1728
80007944:	fa c9 ff b4 	sub	r9,sp,-76
80007948:	08 9c       	mov	r12,r4
8000794a:	fe b0 fa 9d 	rcall	80006e84 <get_arg>
8000794e:	2f dd       	sub	sp,-12
80007950:	78 16       	ld.w	r6,r12[0x4]
80007952:	50 76       	stdsp	sp[0x1c],r6
80007954:	c4 88       	rjmp	800079e4 <_vfprintf_r+0x830>
80007956:	2f f7       	sub	r7,-1
80007958:	10 39       	cp.w	r9,r8
8000795a:	c0 c4       	brge	80007972 <_vfprintf_r+0x7be>
8000795c:	fa ce f9 44 	sub	lr,sp,-1724
80007960:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007964:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007968:	50 7c       	stdsp	sp[0x1c],r12
8000796a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000796e:	50 56       	stdsp	sp[0x14],r6
80007970:	c6 68       	rjmp	80007a3c <_vfprintf_r+0x888>
80007972:	41 09       	lddsp	r9,sp[0x40]
80007974:	59 f8       	cp.w	r8,31
80007976:	e0 89 00 10 	brgt	80007996 <_vfprintf_r+0x7e2>
8000797a:	f2 ca ff f8 	sub	r10,r9,-8
8000797e:	72 1b       	ld.w	r11,r9[0x4]
80007980:	51 0a       	stdsp	sp[0x40],r10
80007982:	72 09       	ld.w	r9,r9[0x0]
80007984:	fa ca f9 44 	sub	r10,sp,-1724
80007988:	50 7b       	stdsp	sp[0x1c],r11
8000798a:	50 59       	stdsp	sp[0x14],r9
8000798c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007990:	40 5b       	lddsp	r11,sp[0x14]
80007992:	40 7a       	lddsp	r10,sp[0x1c]
80007994:	c4 78       	rjmp	80007a22 <_vfprintf_r+0x86e>
80007996:	72 18       	ld.w	r8,r9[0x4]
80007998:	50 78       	stdsp	sp[0x1c],r8
8000799a:	c4 c8       	rjmp	80007a32 <_vfprintf_r+0x87e>
8000799c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079a0:	40 3e       	lddsp	lr,sp[0xc]
800079a2:	58 0e       	cp.w	lr,0
800079a4:	c2 30       	breq	800079ea <_vfprintf_r+0x836>
800079a6:	10 36       	cp.w	r6,r8
800079a8:	c0 94       	brge	800079ba <_vfprintf_r+0x806>
800079aa:	fa cc f9 44 	sub	r12,sp,-1724
800079ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
800079b2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800079b6:	50 7b       	stdsp	sp[0x1c],r11
800079b8:	cd 9b       	rjmp	8000796a <_vfprintf_r+0x7b6>
800079ba:	fa c8 f9 50 	sub	r8,sp,-1712
800079be:	1a d8       	st.w	--sp,r8
800079c0:	fa c8 fa b8 	sub	r8,sp,-1352
800079c4:	04 9a       	mov	r10,r2
800079c6:	1a d8       	st.w	--sp,r8
800079c8:	fa c8 fb b4 	sub	r8,sp,-1100
800079cc:	0c 9b       	mov	r11,r6
800079ce:	1a d8       	st.w	--sp,r8
800079d0:	08 9c       	mov	r12,r4
800079d2:	fa c8 f9 40 	sub	r8,sp,-1728
800079d6:	fa c9 ff b4 	sub	r9,sp,-76
800079da:	fe b0 fa 55 	rcall	80006e84 <get_arg>
800079de:	2f dd       	sub	sp,-12
800079e0:	78 1a       	ld.w	r10,r12[0x4]
800079e2:	50 7a       	stdsp	sp[0x1c],r10
800079e4:	78 0c       	ld.w	r12,r12[0x0]
800079e6:	50 5c       	stdsp	sp[0x14],r12
800079e8:	c2 a8       	rjmp	80007a3c <_vfprintf_r+0x888>
800079ea:	2f f7       	sub	r7,-1
800079ec:	10 39       	cp.w	r9,r8
800079ee:	c0 94       	brge	80007a00 <_vfprintf_r+0x84c>
800079f0:	fa c9 f9 44 	sub	r9,sp,-1724
800079f4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800079f8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800079fc:	50 78       	stdsp	sp[0x1c],r8
800079fe:	cb 6b       	rjmp	8000796a <_vfprintf_r+0x7b6>
80007a00:	41 09       	lddsp	r9,sp[0x40]
80007a02:	59 f8       	cp.w	r8,31
80007a04:	e0 89 00 15 	brgt	80007a2e <_vfprintf_r+0x87a>
80007a08:	f2 ca ff f8 	sub	r10,r9,-8
80007a0c:	72 16       	ld.w	r6,r9[0x4]
80007a0e:	72 09       	ld.w	r9,r9[0x0]
80007a10:	51 0a       	stdsp	sp[0x40],r10
80007a12:	50 59       	stdsp	sp[0x14],r9
80007a14:	fa ce f9 44 	sub	lr,sp,-1724
80007a18:	50 76       	stdsp	sp[0x1c],r6
80007a1a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007a1e:	40 5b       	lddsp	r11,sp[0x14]
80007a20:	0c 9a       	mov	r10,r6
80007a22:	f2 eb fd 88 	st.d	r9[-632],r10
80007a26:	2f f8       	sub	r8,-1
80007a28:	fb 48 06 b4 	st.w	sp[1716],r8
80007a2c:	c0 88       	rjmp	80007a3c <_vfprintf_r+0x888>
80007a2e:	72 1c       	ld.w	r12,r9[0x4]
80007a30:	50 7c       	stdsp	sp[0x1c],r12
80007a32:	f2 c8 ff f8 	sub	r8,r9,-8
80007a36:	51 08       	stdsp	sp[0x40],r8
80007a38:	72 09       	ld.w	r9,r9[0x0]
80007a3a:	50 59       	stdsp	sp[0x14],r9
80007a3c:	40 5b       	lddsp	r11,sp[0x14]
80007a3e:	40 7a       	lddsp	r10,sp[0x1c]
80007a40:	e0 a0 19 54 	rcall	8000ace8 <__isinfd>
80007a44:	18 96       	mov	r6,r12
80007a46:	c1 70       	breq	80007a74 <_vfprintf_r+0x8c0>
80007a48:	30 08       	mov	r8,0
80007a4a:	30 09       	mov	r9,0
80007a4c:	40 5b       	lddsp	r11,sp[0x14]
80007a4e:	40 7a       	lddsp	r10,sp[0x1c]
80007a50:	e0 a0 1d b4 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
80007a54:	c0 40       	breq	80007a5c <_vfprintf_r+0x8a8>
80007a56:	32 d8       	mov	r8,45
80007a58:	fb 68 06 bb 	st.b	sp[1723],r8
80007a5c:	fe c8 ac a4 	sub	r8,pc,-21340
80007a60:	fe c6 ac a4 	sub	r6,pc,-21340
80007a64:	a7 d5       	cbr	r5,0x7
80007a66:	e0 40 00 47 	cp.w	r0,71
80007a6a:	f0 06 17 a0 	movle	r6,r8
80007a6e:	30 32       	mov	r2,3
80007a70:	e0 8f 06 ce 	bral	8000880c <_vfprintf_r+0x1658>
80007a74:	40 5b       	lddsp	r11,sp[0x14]
80007a76:	40 7a       	lddsp	r10,sp[0x1c]
80007a78:	e0 a0 19 4d 	rcall	8000ad12 <__isnand>
80007a7c:	c0 e0       	breq	80007a98 <_vfprintf_r+0x8e4>
80007a7e:	50 26       	stdsp	sp[0x8],r6
80007a80:	fe c8 ac c0 	sub	r8,pc,-21312
80007a84:	fe c6 ac c0 	sub	r6,pc,-21312
80007a88:	a7 d5       	cbr	r5,0x7
80007a8a:	e0 40 00 47 	cp.w	r0,71
80007a8e:	f0 06 17 a0 	movle	r6,r8
80007a92:	30 32       	mov	r2,3
80007a94:	e0 8f 06 c2 	bral	80008818 <_vfprintf_r+0x1664>
80007a98:	40 2a       	lddsp	r10,sp[0x8]
80007a9a:	5b fa       	cp.w	r10,-1
80007a9c:	c0 41       	brne	80007aa4 <_vfprintf_r+0x8f0>
80007a9e:	30 69       	mov	r9,6
80007aa0:	50 29       	stdsp	sp[0x8],r9
80007aa2:	c1 18       	rjmp	80007ac4 <_vfprintf_r+0x910>
80007aa4:	e0 40 00 47 	cp.w	r0,71
80007aa8:	5f 09       	sreq	r9
80007aaa:	e0 40 00 67 	cp.w	r0,103
80007aae:	5f 08       	sreq	r8
80007ab0:	f3 e8 10 08 	or	r8,r9,r8
80007ab4:	f8 08 18 00 	cp.b	r8,r12
80007ab8:	c0 60       	breq	80007ac4 <_vfprintf_r+0x910>
80007aba:	40 28       	lddsp	r8,sp[0x8]
80007abc:	58 08       	cp.w	r8,0
80007abe:	f9 b8 00 01 	moveq	r8,1
80007ac2:	50 28       	stdsp	sp[0x8],r8
80007ac4:	40 78       	lddsp	r8,sp[0x1c]
80007ac6:	40 59       	lddsp	r9,sp[0x14]
80007ac8:	fa e9 06 94 	st.d	sp[1684],r8
80007acc:	a9 a5       	sbr	r5,0x8
80007ace:	fa f8 06 94 	ld.w	r8,sp[1684]
80007ad2:	58 08       	cp.w	r8,0
80007ad4:	c0 65       	brlt	80007ae0 <_vfprintf_r+0x92c>
80007ad6:	40 5e       	lddsp	lr,sp[0x14]
80007ad8:	30 0c       	mov	r12,0
80007ada:	50 6e       	stdsp	sp[0x18],lr
80007adc:	50 9c       	stdsp	sp[0x24],r12
80007ade:	c0 78       	rjmp	80007aec <_vfprintf_r+0x938>
80007ae0:	40 5b       	lddsp	r11,sp[0x14]
80007ae2:	32 da       	mov	r10,45
80007ae4:	ee 1b 80 00 	eorh	r11,0x8000
80007ae8:	50 9a       	stdsp	sp[0x24],r10
80007aea:	50 6b       	stdsp	sp[0x18],r11
80007aec:	e0 40 00 46 	cp.w	r0,70
80007af0:	5f 09       	sreq	r9
80007af2:	e0 40 00 66 	cp.w	r0,102
80007af6:	5f 08       	sreq	r8
80007af8:	f3 e8 10 08 	or	r8,r9,r8
80007afc:	50 48       	stdsp	sp[0x10],r8
80007afe:	c0 40       	breq	80007b06 <_vfprintf_r+0x952>
80007b00:	40 22       	lddsp	r2,sp[0x8]
80007b02:	30 39       	mov	r9,3
80007b04:	c1 08       	rjmp	80007b24 <_vfprintf_r+0x970>
80007b06:	e0 40 00 45 	cp.w	r0,69
80007b0a:	5f 09       	sreq	r9
80007b0c:	e0 40 00 65 	cp.w	r0,101
80007b10:	5f 08       	sreq	r8
80007b12:	40 22       	lddsp	r2,sp[0x8]
80007b14:	10 49       	or	r9,r8
80007b16:	2f f2       	sub	r2,-1
80007b18:	40 46       	lddsp	r6,sp[0x10]
80007b1a:	ec 09 18 00 	cp.b	r9,r6
80007b1e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007b22:	30 29       	mov	r9,2
80007b24:	fa c8 f9 5c 	sub	r8,sp,-1700
80007b28:	1a d8       	st.w	--sp,r8
80007b2a:	fa c8 f9 54 	sub	r8,sp,-1708
80007b2e:	1a d8       	st.w	--sp,r8
80007b30:	fa c8 f9 4c 	sub	r8,sp,-1716
80007b34:	08 9c       	mov	r12,r4
80007b36:	1a d8       	st.w	--sp,r8
80007b38:	04 98       	mov	r8,r2
80007b3a:	40 9b       	lddsp	r11,sp[0x24]
80007b3c:	40 aa       	lddsp	r10,sp[0x28]
80007b3e:	e0 a0 0b c3 	rcall	800092c4 <_dtoa_r>
80007b42:	e0 40 00 47 	cp.w	r0,71
80007b46:	5f 19       	srne	r9
80007b48:	e0 40 00 67 	cp.w	r0,103
80007b4c:	5f 18       	srne	r8
80007b4e:	18 96       	mov	r6,r12
80007b50:	2f dd       	sub	sp,-12
80007b52:	f3 e8 00 08 	and	r8,r9,r8
80007b56:	c0 41       	brne	80007b5e <_vfprintf_r+0x9aa>
80007b58:	ed b5 00 00 	bld	r5,0x0
80007b5c:	c3 01       	brne	80007bbc <_vfprintf_r+0xa08>
80007b5e:	ec 02 00 0e 	add	lr,r6,r2
80007b62:	50 3e       	stdsp	sp[0xc],lr
80007b64:	40 4c       	lddsp	r12,sp[0x10]
80007b66:	58 0c       	cp.w	r12,0
80007b68:	c1 50       	breq	80007b92 <_vfprintf_r+0x9de>
80007b6a:	0d 89       	ld.ub	r9,r6[0x0]
80007b6c:	33 08       	mov	r8,48
80007b6e:	f0 09 18 00 	cp.b	r9,r8
80007b72:	c0 b1       	brne	80007b88 <_vfprintf_r+0x9d4>
80007b74:	30 08       	mov	r8,0
80007b76:	30 09       	mov	r9,0
80007b78:	40 6b       	lddsp	r11,sp[0x18]
80007b7a:	40 7a       	lddsp	r10,sp[0x1c]
80007b7c:	e0 a0 1c d7 	rcall	8000b52a <__avr32_f64_cmp_eq>
80007b80:	fb b2 00 01 	rsubeq	r2,1
80007b84:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007b88:	40 3b       	lddsp	r11,sp[0xc]
80007b8a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007b8e:	10 0b       	add	r11,r8
80007b90:	50 3b       	stdsp	sp[0xc],r11
80007b92:	40 6b       	lddsp	r11,sp[0x18]
80007b94:	30 08       	mov	r8,0
80007b96:	30 09       	mov	r9,0
80007b98:	40 7a       	lddsp	r10,sp[0x1c]
80007b9a:	e0 a0 1c c8 	rcall	8000b52a <__avr32_f64_cmp_eq>
80007b9e:	c0 90       	breq	80007bb0 <_vfprintf_r+0x9fc>
80007ba0:	40 3a       	lddsp	r10,sp[0xc]
80007ba2:	fb 4a 06 a4 	st.w	sp[1700],r10
80007ba6:	c0 58       	rjmp	80007bb0 <_vfprintf_r+0x9fc>
80007ba8:	10 c9       	st.b	r8++,r9
80007baa:	fb 48 06 a4 	st.w	sp[1700],r8
80007bae:	c0 28       	rjmp	80007bb2 <_vfprintf_r+0x9fe>
80007bb0:	33 09       	mov	r9,48
80007bb2:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007bb6:	40 3e       	lddsp	lr,sp[0xc]
80007bb8:	1c 38       	cp.w	r8,lr
80007bba:	cf 73       	brcs	80007ba8 <_vfprintf_r+0x9f4>
80007bbc:	e0 40 00 47 	cp.w	r0,71
80007bc0:	5f 09       	sreq	r9
80007bc2:	e0 40 00 67 	cp.w	r0,103
80007bc6:	5f 08       	sreq	r8
80007bc8:	f3 e8 10 08 	or	r8,r9,r8
80007bcc:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007bd0:	0c 19       	sub	r9,r6
80007bd2:	50 69       	stdsp	sp[0x18],r9
80007bd4:	58 08       	cp.w	r8,0
80007bd6:	c0 b0       	breq	80007bec <_vfprintf_r+0xa38>
80007bd8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007bdc:	5b d8       	cp.w	r8,-3
80007bde:	c0 55       	brlt	80007be8 <_vfprintf_r+0xa34>
80007be0:	40 2c       	lddsp	r12,sp[0x8]
80007be2:	18 38       	cp.w	r8,r12
80007be4:	e0 8a 00 6a 	brle	80007cb8 <_vfprintf_r+0xb04>
80007be8:	20 20       	sub	r0,2
80007bea:	c0 58       	rjmp	80007bf4 <_vfprintf_r+0xa40>
80007bec:	e0 40 00 65 	cp.w	r0,101
80007bf0:	e0 89 00 46 	brgt	80007c7c <_vfprintf_r+0xac8>
80007bf4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007bf8:	fb 60 06 9c 	st.b	sp[1692],r0
80007bfc:	20 1b       	sub	r11,1
80007bfe:	fb 4b 06 ac 	st.w	sp[1708],r11
80007c02:	c0 47       	brpl	80007c0a <_vfprintf_r+0xa56>
80007c04:	5c 3b       	neg	r11
80007c06:	32 d8       	mov	r8,45
80007c08:	c0 28       	rjmp	80007c0c <_vfprintf_r+0xa58>
80007c0a:	32 b8       	mov	r8,43
80007c0c:	fb 68 06 9d 	st.b	sp[1693],r8
80007c10:	58 9b       	cp.w	r11,9
80007c12:	e0 8a 00 1d 	brle	80007c4c <_vfprintf_r+0xa98>
80007c16:	fa c9 fa 35 	sub	r9,sp,-1483
80007c1a:	30 aa       	mov	r10,10
80007c1c:	12 98       	mov	r8,r9
80007c1e:	0e 9c       	mov	r12,r7
80007c20:	0c 92       	mov	r2,r6
80007c22:	f6 0a 0c 06 	divs	r6,r11,r10
80007c26:	0e 9b       	mov	r11,r7
80007c28:	2d 0b       	sub	r11,-48
80007c2a:	10 fb       	st.b	--r8,r11
80007c2c:	0c 9b       	mov	r11,r6
80007c2e:	58 96       	cp.w	r6,9
80007c30:	fe 99 ff f9 	brgt	80007c22 <_vfprintf_r+0xa6e>
80007c34:	2d 0b       	sub	r11,-48
80007c36:	18 97       	mov	r7,r12
80007c38:	04 96       	mov	r6,r2
80007c3a:	10 fb       	st.b	--r8,r11
80007c3c:	fa ca f9 62 	sub	r10,sp,-1694
80007c40:	c0 38       	rjmp	80007c46 <_vfprintf_r+0xa92>
80007c42:	11 3b       	ld.ub	r11,r8++
80007c44:	14 cb       	st.b	r10++,r11
80007c46:	12 38       	cp.w	r8,r9
80007c48:	cf d3       	brcs	80007c42 <_vfprintf_r+0xa8e>
80007c4a:	c0 98       	rjmp	80007c5c <_vfprintf_r+0xaa8>
80007c4c:	2d 0b       	sub	r11,-48
80007c4e:	33 08       	mov	r8,48
80007c50:	fb 6b 06 9f 	st.b	sp[1695],r11
80007c54:	fb 68 06 9e 	st.b	sp[1694],r8
80007c58:	fa ca f9 60 	sub	r10,sp,-1696
80007c5c:	fa c8 f9 64 	sub	r8,sp,-1692
80007c60:	f4 08 01 08 	sub	r8,r10,r8
80007c64:	50 e8       	stdsp	sp[0x38],r8
80007c66:	10 92       	mov	r2,r8
80007c68:	40 6b       	lddsp	r11,sp[0x18]
80007c6a:	16 02       	add	r2,r11
80007c6c:	58 1b       	cp.w	r11,1
80007c6e:	e0 89 00 05 	brgt	80007c78 <_vfprintf_r+0xac4>
80007c72:	ed b5 00 00 	bld	r5,0x0
80007c76:	c3 51       	brne	80007ce0 <_vfprintf_r+0xb2c>
80007c78:	2f f2       	sub	r2,-1
80007c7a:	c3 38       	rjmp	80007ce0 <_vfprintf_r+0xb2c>
80007c7c:	e0 40 00 66 	cp.w	r0,102
80007c80:	c1 c1       	brne	80007cb8 <_vfprintf_r+0xb04>
80007c82:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007c86:	58 02       	cp.w	r2,0
80007c88:	e0 8a 00 0c 	brle	80007ca0 <_vfprintf_r+0xaec>
80007c8c:	40 2a       	lddsp	r10,sp[0x8]
80007c8e:	58 0a       	cp.w	r10,0
80007c90:	c0 41       	brne	80007c98 <_vfprintf_r+0xae4>
80007c92:	ed b5 00 00 	bld	r5,0x0
80007c96:	c2 51       	brne	80007ce0 <_vfprintf_r+0xb2c>
80007c98:	2f f2       	sub	r2,-1
80007c9a:	40 29       	lddsp	r9,sp[0x8]
80007c9c:	12 02       	add	r2,r9
80007c9e:	c0 b8       	rjmp	80007cb4 <_vfprintf_r+0xb00>
80007ca0:	40 28       	lddsp	r8,sp[0x8]
80007ca2:	58 08       	cp.w	r8,0
80007ca4:	c0 61       	brne	80007cb0 <_vfprintf_r+0xafc>
80007ca6:	ed b5 00 00 	bld	r5,0x0
80007caa:	c0 30       	breq	80007cb0 <_vfprintf_r+0xafc>
80007cac:	30 12       	mov	r2,1
80007cae:	c1 98       	rjmp	80007ce0 <_vfprintf_r+0xb2c>
80007cb0:	40 22       	lddsp	r2,sp[0x8]
80007cb2:	2f e2       	sub	r2,-2
80007cb4:	36 60       	mov	r0,102
80007cb6:	c1 58       	rjmp	80007ce0 <_vfprintf_r+0xb2c>
80007cb8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007cbc:	40 6e       	lddsp	lr,sp[0x18]
80007cbe:	1c 32       	cp.w	r2,lr
80007cc0:	c0 65       	brlt	80007ccc <_vfprintf_r+0xb18>
80007cc2:	ed b5 00 00 	bld	r5,0x0
80007cc6:	f7 b2 00 ff 	subeq	r2,-1
80007cca:	c0 a8       	rjmp	80007cde <_vfprintf_r+0xb2a>
80007ccc:	e4 08 11 02 	rsub	r8,r2,2
80007cd0:	40 6c       	lddsp	r12,sp[0x18]
80007cd2:	58 02       	cp.w	r2,0
80007cd4:	f0 02 17 a0 	movle	r2,r8
80007cd8:	f9 b2 09 01 	movgt	r2,1
80007cdc:	18 02       	add	r2,r12
80007cde:	36 70       	mov	r0,103
80007ce0:	40 9b       	lddsp	r11,sp[0x24]
80007ce2:	58 0b       	cp.w	r11,0
80007ce4:	e0 80 05 94 	breq	8000880c <_vfprintf_r+0x1658>
80007ce8:	32 d8       	mov	r8,45
80007cea:	fb 68 06 bb 	st.b	sp[1723],r8
80007cee:	e0 8f 05 93 	bral	80008814 <_vfprintf_r+0x1660>
80007cf2:	50 a7       	stdsp	sp[0x28],r7
80007cf4:	04 94       	mov	r4,r2
80007cf6:	0c 97       	mov	r7,r6
80007cf8:	02 92       	mov	r2,r1
80007cfa:	06 96       	mov	r6,r3
80007cfc:	40 41       	lddsp	r1,sp[0x10]
80007cfe:	40 93       	lddsp	r3,sp[0x24]
80007d00:	0e 99       	mov	r9,r7
80007d02:	ed b5 00 05 	bld	r5,0x5
80007d06:	c4 81       	brne	80007d96 <_vfprintf_r+0xbe2>
80007d08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d0c:	40 3e       	lddsp	lr,sp[0xc]
80007d0e:	58 0e       	cp.w	lr,0
80007d10:	c1 d0       	breq	80007d4a <_vfprintf_r+0xb96>
80007d12:	10 36       	cp.w	r6,r8
80007d14:	c0 64       	brge	80007d20 <_vfprintf_r+0xb6c>
80007d16:	fa cc f9 44 	sub	r12,sp,-1724
80007d1a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d1e:	c1 d8       	rjmp	80007d58 <_vfprintf_r+0xba4>
80007d20:	fa c8 f9 50 	sub	r8,sp,-1712
80007d24:	1a d8       	st.w	--sp,r8
80007d26:	fa c8 fa b8 	sub	r8,sp,-1352
80007d2a:	04 9a       	mov	r10,r2
80007d2c:	1a d8       	st.w	--sp,r8
80007d2e:	fa c8 fb b4 	sub	r8,sp,-1100
80007d32:	0c 9b       	mov	r11,r6
80007d34:	1a d8       	st.w	--sp,r8
80007d36:	08 9c       	mov	r12,r4
80007d38:	fa c8 f9 40 	sub	r8,sp,-1728
80007d3c:	fa c9 ff b4 	sub	r9,sp,-76
80007d40:	fe b0 f8 a2 	rcall	80006e84 <get_arg>
80007d44:	2f dd       	sub	sp,-12
80007d46:	78 0a       	ld.w	r10,r12[0x0]
80007d48:	c2 08       	rjmp	80007d88 <_vfprintf_r+0xbd4>
80007d4a:	2f f7       	sub	r7,-1
80007d4c:	10 39       	cp.w	r9,r8
80007d4e:	c0 84       	brge	80007d5e <_vfprintf_r+0xbaa>
80007d50:	fa cb f9 44 	sub	r11,sp,-1724
80007d54:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d58:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d5c:	c1 68       	rjmp	80007d88 <_vfprintf_r+0xbd4>
80007d5e:	41 09       	lddsp	r9,sp[0x40]
80007d60:	59 f8       	cp.w	r8,31
80007d62:	e0 89 00 10 	brgt	80007d82 <_vfprintf_r+0xbce>
80007d66:	f2 ca ff fc 	sub	r10,r9,-4
80007d6a:	51 0a       	stdsp	sp[0x40],r10
80007d6c:	fa c6 f9 44 	sub	r6,sp,-1724
80007d70:	72 0a       	ld.w	r10,r9[0x0]
80007d72:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d76:	f3 4a fd 88 	st.w	r9[-632],r10
80007d7a:	2f f8       	sub	r8,-1
80007d7c:	fb 48 06 b4 	st.w	sp[1716],r8
80007d80:	c0 48       	rjmp	80007d88 <_vfprintf_r+0xbd4>
80007d82:	72 0a       	ld.w	r10,r9[0x0]
80007d84:	2f c9       	sub	r9,-4
80007d86:	51 09       	stdsp	sp[0x40],r9
80007d88:	40 be       	lddsp	lr,sp[0x2c]
80007d8a:	1c 98       	mov	r8,lr
80007d8c:	95 1e       	st.w	r10[0x4],lr
80007d8e:	bf 58       	asr	r8,0x1f
80007d90:	95 08       	st.w	r10[0x0],r8
80007d92:	fe 9f fa 9f 	bral	800072d0 <_vfprintf_r+0x11c>
80007d96:	ed b5 00 04 	bld	r5,0x4
80007d9a:	c4 80       	breq	80007e2a <_vfprintf_r+0xc76>
80007d9c:	e2 15 00 40 	andl	r5,0x40,COH
80007da0:	c4 50       	breq	80007e2a <_vfprintf_r+0xc76>
80007da2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007da6:	40 3c       	lddsp	r12,sp[0xc]
80007da8:	58 0c       	cp.w	r12,0
80007daa:	c1 d0       	breq	80007de4 <_vfprintf_r+0xc30>
80007dac:	10 36       	cp.w	r6,r8
80007dae:	c0 64       	brge	80007dba <_vfprintf_r+0xc06>
80007db0:	fa cb f9 44 	sub	r11,sp,-1724
80007db4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007db8:	c1 d8       	rjmp	80007df2 <_vfprintf_r+0xc3e>
80007dba:	fa c8 f9 50 	sub	r8,sp,-1712
80007dbe:	1a d8       	st.w	--sp,r8
80007dc0:	fa c8 fa b8 	sub	r8,sp,-1352
80007dc4:	04 9a       	mov	r10,r2
80007dc6:	1a d8       	st.w	--sp,r8
80007dc8:	fa c8 fb b4 	sub	r8,sp,-1100
80007dcc:	0c 9b       	mov	r11,r6
80007dce:	1a d8       	st.w	--sp,r8
80007dd0:	08 9c       	mov	r12,r4
80007dd2:	fa c8 f9 40 	sub	r8,sp,-1728
80007dd6:	fa c9 ff b4 	sub	r9,sp,-76
80007dda:	fe b0 f8 55 	rcall	80006e84 <get_arg>
80007dde:	2f dd       	sub	sp,-12
80007de0:	78 0a       	ld.w	r10,r12[0x0]
80007de2:	c2 08       	rjmp	80007e22 <_vfprintf_r+0xc6e>
80007de4:	2f f7       	sub	r7,-1
80007de6:	10 39       	cp.w	r9,r8
80007de8:	c0 84       	brge	80007df8 <_vfprintf_r+0xc44>
80007dea:	fa ca f9 44 	sub	r10,sp,-1724
80007dee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007df2:	ec fa fd 88 	ld.w	r10,r6[-632]
80007df6:	c1 68       	rjmp	80007e22 <_vfprintf_r+0xc6e>
80007df8:	41 09       	lddsp	r9,sp[0x40]
80007dfa:	59 f8       	cp.w	r8,31
80007dfc:	e0 89 00 10 	brgt	80007e1c <_vfprintf_r+0xc68>
80007e00:	f2 ca ff fc 	sub	r10,r9,-4
80007e04:	51 0a       	stdsp	sp[0x40],r10
80007e06:	fa c6 f9 44 	sub	r6,sp,-1724
80007e0a:	72 0a       	ld.w	r10,r9[0x0]
80007e0c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e10:	f3 4a fd 88 	st.w	r9[-632],r10
80007e14:	2f f8       	sub	r8,-1
80007e16:	fb 48 06 b4 	st.w	sp[1716],r8
80007e1a:	c0 48       	rjmp	80007e22 <_vfprintf_r+0xc6e>
80007e1c:	72 0a       	ld.w	r10,r9[0x0]
80007e1e:	2f c9       	sub	r9,-4
80007e20:	51 09       	stdsp	sp[0x40],r9
80007e22:	40 be       	lddsp	lr,sp[0x2c]
80007e24:	b4 0e       	st.h	r10[0x0],lr
80007e26:	fe 9f fa 55 	bral	800072d0 <_vfprintf_r+0x11c>
80007e2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e2e:	40 3c       	lddsp	r12,sp[0xc]
80007e30:	58 0c       	cp.w	r12,0
80007e32:	c1 d0       	breq	80007e6c <_vfprintf_r+0xcb8>
80007e34:	10 36       	cp.w	r6,r8
80007e36:	c0 64       	brge	80007e42 <_vfprintf_r+0xc8e>
80007e38:	fa cb f9 44 	sub	r11,sp,-1724
80007e3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e40:	c1 d8       	rjmp	80007e7a <_vfprintf_r+0xcc6>
80007e42:	fa c8 f9 50 	sub	r8,sp,-1712
80007e46:	1a d8       	st.w	--sp,r8
80007e48:	fa c8 fa b8 	sub	r8,sp,-1352
80007e4c:	04 9a       	mov	r10,r2
80007e4e:	1a d8       	st.w	--sp,r8
80007e50:	fa c8 fb b4 	sub	r8,sp,-1100
80007e54:	0c 9b       	mov	r11,r6
80007e56:	1a d8       	st.w	--sp,r8
80007e58:	08 9c       	mov	r12,r4
80007e5a:	fa c8 f9 40 	sub	r8,sp,-1728
80007e5e:	fa c9 ff b4 	sub	r9,sp,-76
80007e62:	fe b0 f8 11 	rcall	80006e84 <get_arg>
80007e66:	2f dd       	sub	sp,-12
80007e68:	78 0a       	ld.w	r10,r12[0x0]
80007e6a:	c2 08       	rjmp	80007eaa <_vfprintf_r+0xcf6>
80007e6c:	2f f7       	sub	r7,-1
80007e6e:	10 39       	cp.w	r9,r8
80007e70:	c0 84       	brge	80007e80 <_vfprintf_r+0xccc>
80007e72:	fa ca f9 44 	sub	r10,sp,-1724
80007e76:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e7a:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e7e:	c1 68       	rjmp	80007eaa <_vfprintf_r+0xcf6>
80007e80:	41 09       	lddsp	r9,sp[0x40]
80007e82:	59 f8       	cp.w	r8,31
80007e84:	e0 89 00 10 	brgt	80007ea4 <_vfprintf_r+0xcf0>
80007e88:	f2 ca ff fc 	sub	r10,r9,-4
80007e8c:	51 0a       	stdsp	sp[0x40],r10
80007e8e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e92:	72 0a       	ld.w	r10,r9[0x0]
80007e94:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e98:	f3 4a fd 88 	st.w	r9[-632],r10
80007e9c:	2f f8       	sub	r8,-1
80007e9e:	fb 48 06 b4 	st.w	sp[1716],r8
80007ea2:	c0 48       	rjmp	80007eaa <_vfprintf_r+0xcf6>
80007ea4:	72 0a       	ld.w	r10,r9[0x0]
80007ea6:	2f c9       	sub	r9,-4
80007ea8:	51 09       	stdsp	sp[0x40],r9
80007eaa:	40 be       	lddsp	lr,sp[0x2c]
80007eac:	95 0e       	st.w	r10[0x0],lr
80007eae:	fe 9f fa 11 	bral	800072d0 <_vfprintf_r+0x11c>
80007eb2:	50 a7       	stdsp	sp[0x28],r7
80007eb4:	50 80       	stdsp	sp[0x20],r0
80007eb6:	0c 97       	mov	r7,r6
80007eb8:	04 94       	mov	r4,r2
80007eba:	06 96       	mov	r6,r3
80007ebc:	02 92       	mov	r2,r1
80007ebe:	40 93       	lddsp	r3,sp[0x24]
80007ec0:	10 90       	mov	r0,r8
80007ec2:	40 41       	lddsp	r1,sp[0x10]
80007ec4:	a5 a5       	sbr	r5,0x4
80007ec6:	c0 a8       	rjmp	80007eda <_vfprintf_r+0xd26>
80007ec8:	50 a7       	stdsp	sp[0x28],r7
80007eca:	50 80       	stdsp	sp[0x20],r0
80007ecc:	0c 97       	mov	r7,r6
80007ece:	04 94       	mov	r4,r2
80007ed0:	06 96       	mov	r6,r3
80007ed2:	02 92       	mov	r2,r1
80007ed4:	40 93       	lddsp	r3,sp[0x24]
80007ed6:	10 90       	mov	r0,r8
80007ed8:	40 41       	lddsp	r1,sp[0x10]
80007eda:	ed b5 00 05 	bld	r5,0x5
80007ede:	c5 d1       	brne	80007f98 <_vfprintf_r+0xde4>
80007ee0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ee4:	40 3c       	lddsp	r12,sp[0xc]
80007ee6:	58 0c       	cp.w	r12,0
80007ee8:	c2 60       	breq	80007f34 <_vfprintf_r+0xd80>
80007eea:	10 36       	cp.w	r6,r8
80007eec:	c0 a4       	brge	80007f00 <_vfprintf_r+0xd4c>
80007eee:	fa cb f9 44 	sub	r11,sp,-1724
80007ef2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ef6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007efa:	fa e9 00 00 	st.d	sp[0],r8
80007efe:	c1 88       	rjmp	80007f2e <_vfprintf_r+0xd7a>
80007f00:	fa c8 f9 50 	sub	r8,sp,-1712
80007f04:	1a d8       	st.w	--sp,r8
80007f06:	fa c8 fa b8 	sub	r8,sp,-1352
80007f0a:	04 9a       	mov	r10,r2
80007f0c:	1a d8       	st.w	--sp,r8
80007f0e:	0c 9b       	mov	r11,r6
80007f10:	fa c8 fb b4 	sub	r8,sp,-1100
80007f14:	08 9c       	mov	r12,r4
80007f16:	1a d8       	st.w	--sp,r8
80007f18:	fa c8 f9 40 	sub	r8,sp,-1728
80007f1c:	fa c9 ff b4 	sub	r9,sp,-76
80007f20:	fe b0 f7 b2 	rcall	80006e84 <get_arg>
80007f24:	2f dd       	sub	sp,-12
80007f26:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f2a:	fa eb 00 00 	st.d	sp[0],r10
80007f2e:	30 08       	mov	r8,0
80007f30:	e0 8f 03 de 	bral	800086ec <_vfprintf_r+0x1538>
80007f34:	ee ca ff ff 	sub	r10,r7,-1
80007f38:	10 37       	cp.w	r7,r8
80007f3a:	c0 b4       	brge	80007f50 <_vfprintf_r+0xd9c>
80007f3c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f40:	14 97       	mov	r7,r10
80007f42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f46:	ec ea fd 88 	ld.d	r10,r6[-632]
80007f4a:	fa eb 00 00 	st.d	sp[0],r10
80007f4e:	c1 88       	rjmp	80007f7e <_vfprintf_r+0xdca>
80007f50:	41 09       	lddsp	r9,sp[0x40]
80007f52:	59 f8       	cp.w	r8,31
80007f54:	e0 89 00 18 	brgt	80007f84 <_vfprintf_r+0xdd0>
80007f58:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f5c:	f2 cb ff f8 	sub	r11,r9,-8
80007f60:	fa e7 00 00 	st.d	sp[0],r6
80007f64:	51 0b       	stdsp	sp[0x40],r11
80007f66:	fa c6 f9 44 	sub	r6,sp,-1724
80007f6a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f6e:	fa e6 00 00 	ld.d	r6,sp[0]
80007f72:	f2 e7 fd 88 	st.d	r9[-632],r6
80007f76:	2f f8       	sub	r8,-1
80007f78:	14 97       	mov	r7,r10
80007f7a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f7e:	40 38       	lddsp	r8,sp[0xc]
80007f80:	e0 8f 03 b6 	bral	800086ec <_vfprintf_r+0x1538>
80007f84:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f88:	40 38       	lddsp	r8,sp[0xc]
80007f8a:	fa e7 00 00 	st.d	sp[0],r6
80007f8e:	2f 89       	sub	r9,-8
80007f90:	14 97       	mov	r7,r10
80007f92:	51 09       	stdsp	sp[0x40],r9
80007f94:	e0 8f 03 ac 	bral	800086ec <_vfprintf_r+0x1538>
80007f98:	ed b5 00 04 	bld	r5,0x4
80007f9c:	c1 61       	brne	80007fc8 <_vfprintf_r+0xe14>
80007f9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fa2:	40 3e       	lddsp	lr,sp[0xc]
80007fa4:	58 0e       	cp.w	lr,0
80007fa6:	c0 80       	breq	80007fb6 <_vfprintf_r+0xe02>
80007fa8:	10 36       	cp.w	r6,r8
80007faa:	c6 74       	brge	80008078 <_vfprintf_r+0xec4>
80007fac:	fa cc f9 44 	sub	r12,sp,-1724
80007fb0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fb4:	c8 08       	rjmp	800080b4 <_vfprintf_r+0xf00>
80007fb6:	ee ca ff ff 	sub	r10,r7,-1
80007fba:	10 37       	cp.w	r7,r8
80007fbc:	c7 f4       	brge	800080ba <_vfprintf_r+0xf06>
80007fbe:	fa cb f9 44 	sub	r11,sp,-1724
80007fc2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fc6:	c7 68       	rjmp	800080b2 <_vfprintf_r+0xefe>
80007fc8:	ed b5 00 06 	bld	r5,0x6
80007fcc:	c4 a1       	brne	80008060 <_vfprintf_r+0xeac>
80007fce:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fd2:	40 3c       	lddsp	r12,sp[0xc]
80007fd4:	58 0c       	cp.w	r12,0
80007fd6:	c1 d0       	breq	80008010 <_vfprintf_r+0xe5c>
80007fd8:	10 36       	cp.w	r6,r8
80007fda:	c0 64       	brge	80007fe6 <_vfprintf_r+0xe32>
80007fdc:	fa cb f9 44 	sub	r11,sp,-1724
80007fe0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fe4:	c1 f8       	rjmp	80008022 <_vfprintf_r+0xe6e>
80007fe6:	fa c8 f9 50 	sub	r8,sp,-1712
80007fea:	1a d8       	st.w	--sp,r8
80007fec:	fa c8 fa b8 	sub	r8,sp,-1352
80007ff0:	1a d8       	st.w	--sp,r8
80007ff2:	fa c8 fb b4 	sub	r8,sp,-1100
80007ff6:	1a d8       	st.w	--sp,r8
80007ff8:	fa c8 f9 40 	sub	r8,sp,-1728
80007ffc:	fa c9 ff b4 	sub	r9,sp,-76
80008000:	04 9a       	mov	r10,r2
80008002:	0c 9b       	mov	r11,r6
80008004:	08 9c       	mov	r12,r4
80008006:	fe b0 f7 3f 	rcall	80006e84 <get_arg>
8000800a:	2f dd       	sub	sp,-12
8000800c:	98 18       	ld.sh	r8,r12[0x2]
8000800e:	c2 68       	rjmp	8000805a <_vfprintf_r+0xea6>
80008010:	ee ca ff ff 	sub	r10,r7,-1
80008014:	10 37       	cp.w	r7,r8
80008016:	c0 94       	brge	80008028 <_vfprintf_r+0xe74>
80008018:	fa c9 f9 44 	sub	r9,sp,-1724
8000801c:	14 97       	mov	r7,r10
8000801e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008022:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008026:	c1 a8       	rjmp	8000805a <_vfprintf_r+0xea6>
80008028:	41 09       	lddsp	r9,sp[0x40]
8000802a:	59 f8       	cp.w	r8,31
8000802c:	e0 89 00 13 	brgt	80008052 <_vfprintf_r+0xe9e>
80008030:	f2 cb ff fc 	sub	r11,r9,-4
80008034:	51 0b       	stdsp	sp[0x40],r11
80008036:	72 09       	ld.w	r9,r9[0x0]
80008038:	fa c6 f9 44 	sub	r6,sp,-1724
8000803c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008040:	2f f8       	sub	r8,-1
80008042:	f7 49 fd 88 	st.w	r11[-632],r9
80008046:	fb 48 06 b4 	st.w	sp[1716],r8
8000804a:	14 97       	mov	r7,r10
8000804c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008050:	c0 58       	rjmp	8000805a <_vfprintf_r+0xea6>
80008052:	92 18       	ld.sh	r8,r9[0x2]
80008054:	14 97       	mov	r7,r10
80008056:	2f c9       	sub	r9,-4
80008058:	51 09       	stdsp	sp[0x40],r9
8000805a:	5c 78       	castu.h	r8
8000805c:	50 18       	stdsp	sp[0x4],r8
8000805e:	c4 68       	rjmp	800080ea <_vfprintf_r+0xf36>
80008060:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008064:	40 3c       	lddsp	r12,sp[0xc]
80008066:	58 0c       	cp.w	r12,0
80008068:	c1 d0       	breq	800080a2 <_vfprintf_r+0xeee>
8000806a:	10 36       	cp.w	r6,r8
8000806c:	c0 64       	brge	80008078 <_vfprintf_r+0xec4>
8000806e:	fa cb f9 44 	sub	r11,sp,-1724
80008072:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008076:	c1 f8       	rjmp	800080b4 <_vfprintf_r+0xf00>
80008078:	fa c8 f9 50 	sub	r8,sp,-1712
8000807c:	1a d8       	st.w	--sp,r8
8000807e:	fa c8 fa b8 	sub	r8,sp,-1352
80008082:	0c 9b       	mov	r11,r6
80008084:	1a d8       	st.w	--sp,r8
80008086:	fa c8 fb b4 	sub	r8,sp,-1100
8000808a:	04 9a       	mov	r10,r2
8000808c:	1a d8       	st.w	--sp,r8
8000808e:	08 9c       	mov	r12,r4
80008090:	fa c8 f9 40 	sub	r8,sp,-1728
80008094:	fa c9 ff b4 	sub	r9,sp,-76
80008098:	fe b0 f6 f6 	rcall	80006e84 <get_arg>
8000809c:	2f dd       	sub	sp,-12
8000809e:	78 0b       	ld.w	r11,r12[0x0]
800080a0:	c2 48       	rjmp	800080e8 <_vfprintf_r+0xf34>
800080a2:	ee ca ff ff 	sub	r10,r7,-1
800080a6:	10 37       	cp.w	r7,r8
800080a8:	c0 94       	brge	800080ba <_vfprintf_r+0xf06>
800080aa:	fa c9 f9 44 	sub	r9,sp,-1724
800080ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080b2:	14 97       	mov	r7,r10
800080b4:	ec fb fd 88 	ld.w	r11,r6[-632]
800080b8:	c1 88       	rjmp	800080e8 <_vfprintf_r+0xf34>
800080ba:	41 09       	lddsp	r9,sp[0x40]
800080bc:	59 f8       	cp.w	r8,31
800080be:	e0 89 00 11 	brgt	800080e0 <_vfprintf_r+0xf2c>
800080c2:	f2 cb ff fc 	sub	r11,r9,-4
800080c6:	51 0b       	stdsp	sp[0x40],r11
800080c8:	fa c6 f9 44 	sub	r6,sp,-1724
800080cc:	72 0b       	ld.w	r11,r9[0x0]
800080ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080d2:	f3 4b fd 88 	st.w	r9[-632],r11
800080d6:	2f f8       	sub	r8,-1
800080d8:	14 97       	mov	r7,r10
800080da:	fb 48 06 b4 	st.w	sp[1716],r8
800080de:	c0 58       	rjmp	800080e8 <_vfprintf_r+0xf34>
800080e0:	72 0b       	ld.w	r11,r9[0x0]
800080e2:	14 97       	mov	r7,r10
800080e4:	2f c9       	sub	r9,-4
800080e6:	51 09       	stdsp	sp[0x40],r9
800080e8:	50 1b       	stdsp	sp[0x4],r11
800080ea:	30 0e       	mov	lr,0
800080ec:	50 0e       	stdsp	sp[0x0],lr
800080ee:	1c 98       	mov	r8,lr
800080f0:	e0 8f 02 fe 	bral	800086ec <_vfprintf_r+0x1538>
800080f4:	50 a7       	stdsp	sp[0x28],r7
800080f6:	50 80       	stdsp	sp[0x20],r0
800080f8:	0c 97       	mov	r7,r6
800080fa:	04 94       	mov	r4,r2
800080fc:	06 96       	mov	r6,r3
800080fe:	02 92       	mov	r2,r1
80008100:	40 93       	lddsp	r3,sp[0x24]
80008102:	40 41       	lddsp	r1,sp[0x10]
80008104:	0e 99       	mov	r9,r7
80008106:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000810a:	40 3c       	lddsp	r12,sp[0xc]
8000810c:	58 0c       	cp.w	r12,0
8000810e:	c1 d0       	breq	80008148 <_vfprintf_r+0xf94>
80008110:	10 36       	cp.w	r6,r8
80008112:	c0 64       	brge	8000811e <_vfprintf_r+0xf6a>
80008114:	fa cb f9 44 	sub	r11,sp,-1724
80008118:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000811c:	c1 d8       	rjmp	80008156 <_vfprintf_r+0xfa2>
8000811e:	fa c8 f9 50 	sub	r8,sp,-1712
80008122:	1a d8       	st.w	--sp,r8
80008124:	fa c8 fa b8 	sub	r8,sp,-1352
80008128:	1a d8       	st.w	--sp,r8
8000812a:	fa c8 fb b4 	sub	r8,sp,-1100
8000812e:	1a d8       	st.w	--sp,r8
80008130:	fa c9 ff b4 	sub	r9,sp,-76
80008134:	fa c8 f9 40 	sub	r8,sp,-1728
80008138:	04 9a       	mov	r10,r2
8000813a:	0c 9b       	mov	r11,r6
8000813c:	08 9c       	mov	r12,r4
8000813e:	fe b0 f6 a3 	rcall	80006e84 <get_arg>
80008142:	2f dd       	sub	sp,-12
80008144:	78 09       	ld.w	r9,r12[0x0]
80008146:	c2 18       	rjmp	80008188 <_vfprintf_r+0xfd4>
80008148:	2f f7       	sub	r7,-1
8000814a:	10 39       	cp.w	r9,r8
8000814c:	c0 84       	brge	8000815c <_vfprintf_r+0xfa8>
8000814e:	fa ca f9 44 	sub	r10,sp,-1724
80008152:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008156:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000815a:	c1 78       	rjmp	80008188 <_vfprintf_r+0xfd4>
8000815c:	41 09       	lddsp	r9,sp[0x40]
8000815e:	59 f8       	cp.w	r8,31
80008160:	e0 89 00 10 	brgt	80008180 <_vfprintf_r+0xfcc>
80008164:	f2 ca ff fc 	sub	r10,r9,-4
80008168:	51 0a       	stdsp	sp[0x40],r10
8000816a:	fa c6 f9 44 	sub	r6,sp,-1724
8000816e:	72 09       	ld.w	r9,r9[0x0]
80008170:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008174:	f5 49 fd 88 	st.w	r10[-632],r9
80008178:	2f f8       	sub	r8,-1
8000817a:	fb 48 06 b4 	st.w	sp[1716],r8
8000817e:	c0 58       	rjmp	80008188 <_vfprintf_r+0xfd4>
80008180:	f2 c8 ff fc 	sub	r8,r9,-4
80008184:	51 08       	stdsp	sp[0x40],r8
80008186:	72 09       	ld.w	r9,r9[0x0]
80008188:	33 08       	mov	r8,48
8000818a:	fb 68 06 b8 	st.b	sp[1720],r8
8000818e:	37 88       	mov	r8,120
80008190:	30 0e       	mov	lr,0
80008192:	fb 68 06 b9 	st.b	sp[1721],r8
80008196:	fe cc b3 ce 	sub	r12,pc,-19506
8000819a:	50 19       	stdsp	sp[0x4],r9
8000819c:	a1 b5       	sbr	r5,0x1
8000819e:	50 0e       	stdsp	sp[0x0],lr
800081a0:	50 dc       	stdsp	sp[0x34],r12
800081a2:	30 28       	mov	r8,2
800081a4:	37 80       	mov	r0,120
800081a6:	e0 8f 02 a3 	bral	800086ec <_vfprintf_r+0x1538>
800081aa:	50 a7       	stdsp	sp[0x28],r7
800081ac:	50 80       	stdsp	sp[0x20],r0
800081ae:	10 90       	mov	r0,r8
800081b0:	30 08       	mov	r8,0
800081b2:	fb 68 06 bb 	st.b	sp[1723],r8
800081b6:	0c 97       	mov	r7,r6
800081b8:	04 94       	mov	r4,r2
800081ba:	06 96       	mov	r6,r3
800081bc:	02 92       	mov	r2,r1
800081be:	40 93       	lddsp	r3,sp[0x24]
800081c0:	40 41       	lddsp	r1,sp[0x10]
800081c2:	0e 99       	mov	r9,r7
800081c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081c8:	40 3b       	lddsp	r11,sp[0xc]
800081ca:	58 0b       	cp.w	r11,0
800081cc:	c1 d0       	breq	80008206 <_vfprintf_r+0x1052>
800081ce:	10 36       	cp.w	r6,r8
800081d0:	c0 64       	brge	800081dc <_vfprintf_r+0x1028>
800081d2:	fa ca f9 44 	sub	r10,sp,-1724
800081d6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081da:	c1 d8       	rjmp	80008214 <_vfprintf_r+0x1060>
800081dc:	fa c8 f9 50 	sub	r8,sp,-1712
800081e0:	1a d8       	st.w	--sp,r8
800081e2:	fa c8 fa b8 	sub	r8,sp,-1352
800081e6:	1a d8       	st.w	--sp,r8
800081e8:	fa c8 fb b4 	sub	r8,sp,-1100
800081ec:	0c 9b       	mov	r11,r6
800081ee:	1a d8       	st.w	--sp,r8
800081f0:	04 9a       	mov	r10,r2
800081f2:	fa c8 f9 40 	sub	r8,sp,-1728
800081f6:	fa c9 ff b4 	sub	r9,sp,-76
800081fa:	08 9c       	mov	r12,r4
800081fc:	fe b0 f6 44 	rcall	80006e84 <get_arg>
80008200:	2f dd       	sub	sp,-12
80008202:	78 06       	ld.w	r6,r12[0x0]
80008204:	c2 08       	rjmp	80008244 <_vfprintf_r+0x1090>
80008206:	2f f7       	sub	r7,-1
80008208:	10 39       	cp.w	r9,r8
8000820a:	c0 84       	brge	8000821a <_vfprintf_r+0x1066>
8000820c:	fa c9 f9 44 	sub	r9,sp,-1724
80008210:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008214:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008218:	c1 68       	rjmp	80008244 <_vfprintf_r+0x1090>
8000821a:	41 09       	lddsp	r9,sp[0x40]
8000821c:	59 f8       	cp.w	r8,31
8000821e:	e0 89 00 10 	brgt	8000823e <_vfprintf_r+0x108a>
80008222:	f2 ca ff fc 	sub	r10,r9,-4
80008226:	51 0a       	stdsp	sp[0x40],r10
80008228:	72 06       	ld.w	r6,r9[0x0]
8000822a:	fa ce f9 44 	sub	lr,sp,-1724
8000822e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008232:	f3 46 fd 88 	st.w	r9[-632],r6
80008236:	2f f8       	sub	r8,-1
80008238:	fb 48 06 b4 	st.w	sp[1716],r8
8000823c:	c0 48       	rjmp	80008244 <_vfprintf_r+0x1090>
8000823e:	72 06       	ld.w	r6,r9[0x0]
80008240:	2f c9       	sub	r9,-4
80008242:	51 09       	stdsp	sp[0x40],r9
80008244:	40 2c       	lddsp	r12,sp[0x8]
80008246:	58 0c       	cp.w	r12,0
80008248:	c1 05       	brlt	80008268 <_vfprintf_r+0x10b4>
8000824a:	18 9a       	mov	r10,r12
8000824c:	30 0b       	mov	r11,0
8000824e:	0c 9c       	mov	r12,r6
80008250:	e0 a0 12 38 	rcall	8000a6c0 <memchr>
80008254:	e0 80 02 df 	breq	80008812 <_vfprintf_r+0x165e>
80008258:	f8 06 01 02 	sub	r2,r12,r6
8000825c:	40 2b       	lddsp	r11,sp[0x8]
8000825e:	16 32       	cp.w	r2,r11
80008260:	e0 89 02 d9 	brgt	80008812 <_vfprintf_r+0x165e>
80008264:	e0 8f 02 d4 	bral	8000880c <_vfprintf_r+0x1658>
80008268:	30 0a       	mov	r10,0
8000826a:	0c 9c       	mov	r12,r6
8000826c:	50 2a       	stdsp	sp[0x8],r10
8000826e:	e0 a0 15 99 	rcall	8000ada0 <strlen>
80008272:	18 92       	mov	r2,r12
80008274:	e0 8f 02 d2 	bral	80008818 <_vfprintf_r+0x1664>
80008278:	50 a7       	stdsp	sp[0x28],r7
8000827a:	50 80       	stdsp	sp[0x20],r0
8000827c:	0c 97       	mov	r7,r6
8000827e:	04 94       	mov	r4,r2
80008280:	06 96       	mov	r6,r3
80008282:	02 92       	mov	r2,r1
80008284:	40 93       	lddsp	r3,sp[0x24]
80008286:	10 90       	mov	r0,r8
80008288:	40 41       	lddsp	r1,sp[0x10]
8000828a:	a5 a5       	sbr	r5,0x4
8000828c:	c0 a8       	rjmp	800082a0 <_vfprintf_r+0x10ec>
8000828e:	50 a7       	stdsp	sp[0x28],r7
80008290:	50 80       	stdsp	sp[0x20],r0
80008292:	0c 97       	mov	r7,r6
80008294:	04 94       	mov	r4,r2
80008296:	06 96       	mov	r6,r3
80008298:	02 92       	mov	r2,r1
8000829a:	40 93       	lddsp	r3,sp[0x24]
8000829c:	10 90       	mov	r0,r8
8000829e:	40 41       	lddsp	r1,sp[0x10]
800082a0:	ed b5 00 05 	bld	r5,0x5
800082a4:	c5 61       	brne	80008350 <_vfprintf_r+0x119c>
800082a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082aa:	40 39       	lddsp	r9,sp[0xc]
800082ac:	58 09       	cp.w	r9,0
800082ae:	c2 10       	breq	800082f0 <_vfprintf_r+0x113c>
800082b0:	10 36       	cp.w	r6,r8
800082b2:	c0 74       	brge	800082c0 <_vfprintf_r+0x110c>
800082b4:	fa c8 f9 44 	sub	r8,sp,-1724
800082b8:	f0 06 00 36 	add	r6,r8,r6<<0x3
800082bc:	c2 38       	rjmp	80008302 <_vfprintf_r+0x114e>
800082be:	d7 03       	nop
800082c0:	fa c8 f9 50 	sub	r8,sp,-1712
800082c4:	1a d8       	st.w	--sp,r8
800082c6:	fa c8 fa b8 	sub	r8,sp,-1352
800082ca:	1a d8       	st.w	--sp,r8
800082cc:	fa c8 fb b4 	sub	r8,sp,-1100
800082d0:	1a d8       	st.w	--sp,r8
800082d2:	fa c8 f9 40 	sub	r8,sp,-1728
800082d6:	fa c9 ff b4 	sub	r9,sp,-76
800082da:	04 9a       	mov	r10,r2
800082dc:	0c 9b       	mov	r11,r6
800082de:	08 9c       	mov	r12,r4
800082e0:	fe b0 f5 d2 	rcall	80006e84 <get_arg>
800082e4:	2f dd       	sub	sp,-12
800082e6:	f8 e8 00 00 	ld.d	r8,r12[0]
800082ea:	fa e9 00 00 	st.d	sp[0],r8
800082ee:	c2 e8       	rjmp	8000834a <_vfprintf_r+0x1196>
800082f0:	ee ca ff ff 	sub	r10,r7,-1
800082f4:	10 37       	cp.w	r7,r8
800082f6:	c0 b4       	brge	8000830c <_vfprintf_r+0x1158>
800082f8:	fa c8 f9 44 	sub	r8,sp,-1724
800082fc:	14 97       	mov	r7,r10
800082fe:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008302:	ec ea fd 88 	ld.d	r10,r6[-632]
80008306:	fa eb 00 00 	st.d	sp[0],r10
8000830a:	c2 08       	rjmp	8000834a <_vfprintf_r+0x1196>
8000830c:	41 09       	lddsp	r9,sp[0x40]
8000830e:	59 f8       	cp.w	r8,31
80008310:	e0 89 00 16 	brgt	8000833c <_vfprintf_r+0x1188>
80008314:	f2 e6 00 00 	ld.d	r6,r9[0]
80008318:	f2 cb ff f8 	sub	r11,r9,-8
8000831c:	fa e7 00 00 	st.d	sp[0],r6
80008320:	51 0b       	stdsp	sp[0x40],r11
80008322:	fa c6 f9 44 	sub	r6,sp,-1724
80008326:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000832a:	fa e6 00 00 	ld.d	r6,sp[0]
8000832e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008332:	2f f8       	sub	r8,-1
80008334:	14 97       	mov	r7,r10
80008336:	fb 48 06 b4 	st.w	sp[1716],r8
8000833a:	c0 88       	rjmp	8000834a <_vfprintf_r+0x1196>
8000833c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008340:	2f 89       	sub	r9,-8
80008342:	fa e7 00 00 	st.d	sp[0],r6
80008346:	51 09       	stdsp	sp[0x40],r9
80008348:	14 97       	mov	r7,r10
8000834a:	30 18       	mov	r8,1
8000834c:	e0 8f 01 d0 	bral	800086ec <_vfprintf_r+0x1538>
80008350:	ed b5 00 04 	bld	r5,0x4
80008354:	c1 61       	brne	80008380 <_vfprintf_r+0x11cc>
80008356:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000835a:	40 3e       	lddsp	lr,sp[0xc]
8000835c:	58 0e       	cp.w	lr,0
8000835e:	c0 80       	breq	8000836e <_vfprintf_r+0x11ba>
80008360:	10 36       	cp.w	r6,r8
80008362:	c6 74       	brge	80008430 <_vfprintf_r+0x127c>
80008364:	fa cc f9 44 	sub	r12,sp,-1724
80008368:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000836c:	c8 08       	rjmp	8000846c <_vfprintf_r+0x12b8>
8000836e:	ee ca ff ff 	sub	r10,r7,-1
80008372:	10 37       	cp.w	r7,r8
80008374:	c7 f4       	brge	80008472 <_vfprintf_r+0x12be>
80008376:	fa cb f9 44 	sub	r11,sp,-1724
8000837a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000837e:	c7 68       	rjmp	8000846a <_vfprintf_r+0x12b6>
80008380:	ed b5 00 06 	bld	r5,0x6
80008384:	c4 a1       	brne	80008418 <_vfprintf_r+0x1264>
80008386:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000838a:	40 3c       	lddsp	r12,sp[0xc]
8000838c:	58 0c       	cp.w	r12,0
8000838e:	c1 d0       	breq	800083c8 <_vfprintf_r+0x1214>
80008390:	10 36       	cp.w	r6,r8
80008392:	c0 64       	brge	8000839e <_vfprintf_r+0x11ea>
80008394:	fa cb f9 44 	sub	r11,sp,-1724
80008398:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000839c:	c1 f8       	rjmp	800083da <_vfprintf_r+0x1226>
8000839e:	fa c8 f9 50 	sub	r8,sp,-1712
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	fa c8 fa b8 	sub	r8,sp,-1352
800083a8:	1a d8       	st.w	--sp,r8
800083aa:	fa c8 fb b4 	sub	r8,sp,-1100
800083ae:	1a d8       	st.w	--sp,r8
800083b0:	fa c8 f9 40 	sub	r8,sp,-1728
800083b4:	fa c9 ff b4 	sub	r9,sp,-76
800083b8:	04 9a       	mov	r10,r2
800083ba:	0c 9b       	mov	r11,r6
800083bc:	08 9c       	mov	r12,r4
800083be:	fe b0 f5 63 	rcall	80006e84 <get_arg>
800083c2:	2f dd       	sub	sp,-12
800083c4:	98 18       	ld.sh	r8,r12[0x2]
800083c6:	c2 68       	rjmp	80008412 <_vfprintf_r+0x125e>
800083c8:	ee ca ff ff 	sub	r10,r7,-1
800083cc:	10 37       	cp.w	r7,r8
800083ce:	c0 94       	brge	800083e0 <_vfprintf_r+0x122c>
800083d0:	fa c9 f9 44 	sub	r9,sp,-1724
800083d4:	14 97       	mov	r7,r10
800083d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083da:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800083de:	c1 a8       	rjmp	80008412 <_vfprintf_r+0x125e>
800083e0:	41 09       	lddsp	r9,sp[0x40]
800083e2:	59 f8       	cp.w	r8,31
800083e4:	e0 89 00 13 	brgt	8000840a <_vfprintf_r+0x1256>
800083e8:	f2 cb ff fc 	sub	r11,r9,-4
800083ec:	51 0b       	stdsp	sp[0x40],r11
800083ee:	72 09       	ld.w	r9,r9[0x0]
800083f0:	fa c6 f9 44 	sub	r6,sp,-1724
800083f4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800083f8:	2f f8       	sub	r8,-1
800083fa:	f7 49 fd 88 	st.w	r11[-632],r9
800083fe:	fb 48 06 b4 	st.w	sp[1716],r8
80008402:	14 97       	mov	r7,r10
80008404:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008408:	c0 58       	rjmp	80008412 <_vfprintf_r+0x125e>
8000840a:	92 18       	ld.sh	r8,r9[0x2]
8000840c:	14 97       	mov	r7,r10
8000840e:	2f c9       	sub	r9,-4
80008410:	51 09       	stdsp	sp[0x40],r9
80008412:	5c 78       	castu.h	r8
80008414:	50 18       	stdsp	sp[0x4],r8
80008416:	c4 68       	rjmp	800084a2 <_vfprintf_r+0x12ee>
80008418:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000841c:	40 3c       	lddsp	r12,sp[0xc]
8000841e:	58 0c       	cp.w	r12,0
80008420:	c1 d0       	breq	8000845a <_vfprintf_r+0x12a6>
80008422:	10 36       	cp.w	r6,r8
80008424:	c0 64       	brge	80008430 <_vfprintf_r+0x127c>
80008426:	fa cb f9 44 	sub	r11,sp,-1724
8000842a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000842e:	c1 f8       	rjmp	8000846c <_vfprintf_r+0x12b8>
80008430:	fa c8 f9 50 	sub	r8,sp,-1712
80008434:	1a d8       	st.w	--sp,r8
80008436:	fa c8 fa b8 	sub	r8,sp,-1352
8000843a:	0c 9b       	mov	r11,r6
8000843c:	1a d8       	st.w	--sp,r8
8000843e:	fa c8 fb b4 	sub	r8,sp,-1100
80008442:	04 9a       	mov	r10,r2
80008444:	1a d8       	st.w	--sp,r8
80008446:	08 9c       	mov	r12,r4
80008448:	fa c8 f9 40 	sub	r8,sp,-1728
8000844c:	fa c9 ff b4 	sub	r9,sp,-76
80008450:	fe b0 f5 1a 	rcall	80006e84 <get_arg>
80008454:	2f dd       	sub	sp,-12
80008456:	78 0b       	ld.w	r11,r12[0x0]
80008458:	c2 48       	rjmp	800084a0 <_vfprintf_r+0x12ec>
8000845a:	ee ca ff ff 	sub	r10,r7,-1
8000845e:	10 37       	cp.w	r7,r8
80008460:	c0 94       	brge	80008472 <_vfprintf_r+0x12be>
80008462:	fa c9 f9 44 	sub	r9,sp,-1724
80008466:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000846a:	14 97       	mov	r7,r10
8000846c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008470:	c1 88       	rjmp	800084a0 <_vfprintf_r+0x12ec>
80008472:	41 09       	lddsp	r9,sp[0x40]
80008474:	59 f8       	cp.w	r8,31
80008476:	e0 89 00 11 	brgt	80008498 <_vfprintf_r+0x12e4>
8000847a:	f2 cb ff fc 	sub	r11,r9,-4
8000847e:	51 0b       	stdsp	sp[0x40],r11
80008480:	fa c6 f9 44 	sub	r6,sp,-1724
80008484:	72 0b       	ld.w	r11,r9[0x0]
80008486:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000848a:	f3 4b fd 88 	st.w	r9[-632],r11
8000848e:	2f f8       	sub	r8,-1
80008490:	14 97       	mov	r7,r10
80008492:	fb 48 06 b4 	st.w	sp[1716],r8
80008496:	c0 58       	rjmp	800084a0 <_vfprintf_r+0x12ec>
80008498:	72 0b       	ld.w	r11,r9[0x0]
8000849a:	14 97       	mov	r7,r10
8000849c:	2f c9       	sub	r9,-4
8000849e:	51 09       	stdsp	sp[0x40],r9
800084a0:	50 1b       	stdsp	sp[0x4],r11
800084a2:	30 0e       	mov	lr,0
800084a4:	30 18       	mov	r8,1
800084a6:	50 0e       	stdsp	sp[0x0],lr
800084a8:	c2 29       	rjmp	800086ec <_vfprintf_r+0x1538>
800084aa:	50 a7       	stdsp	sp[0x28],r7
800084ac:	50 80       	stdsp	sp[0x20],r0
800084ae:	0c 97       	mov	r7,r6
800084b0:	04 94       	mov	r4,r2
800084b2:	06 96       	mov	r6,r3
800084b4:	02 92       	mov	r2,r1
800084b6:	fe cc b6 ee 	sub	r12,pc,-18706
800084ba:	40 93       	lddsp	r3,sp[0x24]
800084bc:	10 90       	mov	r0,r8
800084be:	40 41       	lddsp	r1,sp[0x10]
800084c0:	50 dc       	stdsp	sp[0x34],r12
800084c2:	ed b5 00 05 	bld	r5,0x5
800084c6:	c5 51       	brne	80008570 <_vfprintf_r+0x13bc>
800084c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084cc:	40 3b       	lddsp	r11,sp[0xc]
800084ce:	58 0b       	cp.w	r11,0
800084d0:	c2 20       	breq	80008514 <_vfprintf_r+0x1360>
800084d2:	10 36       	cp.w	r6,r8
800084d4:	c0 a4       	brge	800084e8 <_vfprintf_r+0x1334>
800084d6:	fa ca f9 44 	sub	r10,sp,-1724
800084da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084de:	ec e8 fd 88 	ld.d	r8,r6[-632]
800084e2:	fa e9 00 00 	st.d	sp[0],r8
800084e6:	cf 28       	rjmp	800086ca <_vfprintf_r+0x1516>
800084e8:	fa c8 f9 50 	sub	r8,sp,-1712
800084ec:	1a d8       	st.w	--sp,r8
800084ee:	fa c8 fa b8 	sub	r8,sp,-1352
800084f2:	04 9a       	mov	r10,r2
800084f4:	1a d8       	st.w	--sp,r8
800084f6:	0c 9b       	mov	r11,r6
800084f8:	fa c8 fb b4 	sub	r8,sp,-1100
800084fc:	08 9c       	mov	r12,r4
800084fe:	1a d8       	st.w	--sp,r8
80008500:	fa c8 f9 40 	sub	r8,sp,-1728
80008504:	fa c9 ff b4 	sub	r9,sp,-76
80008508:	fe b0 f4 be 	rcall	80006e84 <get_arg>
8000850c:	2f dd       	sub	sp,-12
8000850e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008512:	c0 c8       	rjmp	8000852a <_vfprintf_r+0x1376>
80008514:	ee ca ff ff 	sub	r10,r7,-1
80008518:	10 37       	cp.w	r7,r8
8000851a:	c0 b4       	brge	80008530 <_vfprintf_r+0x137c>
8000851c:	fa c9 f9 44 	sub	r9,sp,-1724
80008520:	14 97       	mov	r7,r10
80008522:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008526:	ec ea fd 88 	ld.d	r10,r6[-632]
8000852a:	fa eb 00 00 	st.d	sp[0],r10
8000852e:	cc e8       	rjmp	800086ca <_vfprintf_r+0x1516>
80008530:	41 09       	lddsp	r9,sp[0x40]
80008532:	59 f8       	cp.w	r8,31
80008534:	e0 89 00 16 	brgt	80008560 <_vfprintf_r+0x13ac>
80008538:	f2 e6 00 00 	ld.d	r6,r9[0]
8000853c:	f2 cb ff f8 	sub	r11,r9,-8
80008540:	fa e7 00 00 	st.d	sp[0],r6
80008544:	51 0b       	stdsp	sp[0x40],r11
80008546:	fa c6 f9 44 	sub	r6,sp,-1724
8000854a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000854e:	fa e6 00 00 	ld.d	r6,sp[0]
80008552:	f2 e7 fd 88 	st.d	r9[-632],r6
80008556:	2f f8       	sub	r8,-1
80008558:	14 97       	mov	r7,r10
8000855a:	fb 48 06 b4 	st.w	sp[1716],r8
8000855e:	cb 68       	rjmp	800086ca <_vfprintf_r+0x1516>
80008560:	f2 e6 00 00 	ld.d	r6,r9[0]
80008564:	2f 89       	sub	r9,-8
80008566:	fa e7 00 00 	st.d	sp[0],r6
8000856a:	51 09       	stdsp	sp[0x40],r9
8000856c:	14 97       	mov	r7,r10
8000856e:	ca e8       	rjmp	800086ca <_vfprintf_r+0x1516>
80008570:	ed b5 00 04 	bld	r5,0x4
80008574:	c1 71       	brne	800085a2 <_vfprintf_r+0x13ee>
80008576:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000857a:	40 3e       	lddsp	lr,sp[0xc]
8000857c:	58 0e       	cp.w	lr,0
8000857e:	c0 80       	breq	8000858e <_vfprintf_r+0x13da>
80008580:	10 36       	cp.w	r6,r8
80008582:	c6 94       	brge	80008654 <_vfprintf_r+0x14a0>
80008584:	fa cc f9 44 	sub	r12,sp,-1724
80008588:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000858c:	c8 28       	rjmp	80008690 <_vfprintf_r+0x14dc>
8000858e:	ee ca ff ff 	sub	r10,r7,-1
80008592:	10 37       	cp.w	r7,r8
80008594:	e0 84 00 81 	brge	80008696 <_vfprintf_r+0x14e2>
80008598:	fa cb f9 44 	sub	r11,sp,-1724
8000859c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085a0:	c7 78       	rjmp	8000868e <_vfprintf_r+0x14da>
800085a2:	ed b5 00 06 	bld	r5,0x6
800085a6:	c4 b1       	brne	8000863c <_vfprintf_r+0x1488>
800085a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ac:	40 3c       	lddsp	r12,sp[0xc]
800085ae:	58 0c       	cp.w	r12,0
800085b0:	c1 d0       	breq	800085ea <_vfprintf_r+0x1436>
800085b2:	10 36       	cp.w	r6,r8
800085b4:	c0 64       	brge	800085c0 <_vfprintf_r+0x140c>
800085b6:	fa cb f9 44 	sub	r11,sp,-1724
800085ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085be:	c1 f8       	rjmp	800085fc <_vfprintf_r+0x1448>
800085c0:	fa c8 f9 50 	sub	r8,sp,-1712
800085c4:	1a d8       	st.w	--sp,r8
800085c6:	fa c8 fa b8 	sub	r8,sp,-1352
800085ca:	1a d8       	st.w	--sp,r8
800085cc:	fa c8 fb b4 	sub	r8,sp,-1100
800085d0:	1a d8       	st.w	--sp,r8
800085d2:	fa c8 f9 40 	sub	r8,sp,-1728
800085d6:	fa c9 ff b4 	sub	r9,sp,-76
800085da:	04 9a       	mov	r10,r2
800085dc:	0c 9b       	mov	r11,r6
800085de:	08 9c       	mov	r12,r4
800085e0:	fe b0 f4 52 	rcall	80006e84 <get_arg>
800085e4:	2f dd       	sub	sp,-12
800085e6:	98 18       	ld.sh	r8,r12[0x2]
800085e8:	c2 78       	rjmp	80008636 <_vfprintf_r+0x1482>
800085ea:	ee ca ff ff 	sub	r10,r7,-1
800085ee:	10 37       	cp.w	r7,r8
800085f0:	c0 a4       	brge	80008604 <_vfprintf_r+0x1450>
800085f2:	fa c9 f9 44 	sub	r9,sp,-1724
800085f6:	14 97       	mov	r7,r10
800085f8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085fc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008600:	c1 b8       	rjmp	80008636 <_vfprintf_r+0x1482>
80008602:	d7 03       	nop
80008604:	41 09       	lddsp	r9,sp[0x40]
80008606:	59 f8       	cp.w	r8,31
80008608:	e0 89 00 13 	brgt	8000862e <_vfprintf_r+0x147a>
8000860c:	f2 cb ff fc 	sub	r11,r9,-4
80008610:	51 0b       	stdsp	sp[0x40],r11
80008612:	72 09       	ld.w	r9,r9[0x0]
80008614:	fa c6 f9 44 	sub	r6,sp,-1724
80008618:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000861c:	2f f8       	sub	r8,-1
8000861e:	f7 49 fd 88 	st.w	r11[-632],r9
80008622:	fb 48 06 b4 	st.w	sp[1716],r8
80008626:	14 97       	mov	r7,r10
80008628:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000862c:	c0 58       	rjmp	80008636 <_vfprintf_r+0x1482>
8000862e:	92 18       	ld.sh	r8,r9[0x2]
80008630:	14 97       	mov	r7,r10
80008632:	2f c9       	sub	r9,-4
80008634:	51 09       	stdsp	sp[0x40],r9
80008636:	5c 78       	castu.h	r8
80008638:	50 18       	stdsp	sp[0x4],r8
8000863a:	c4 68       	rjmp	800086c6 <_vfprintf_r+0x1512>
8000863c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008640:	40 3c       	lddsp	r12,sp[0xc]
80008642:	58 0c       	cp.w	r12,0
80008644:	c1 d0       	breq	8000867e <_vfprintf_r+0x14ca>
80008646:	10 36       	cp.w	r6,r8
80008648:	c0 64       	brge	80008654 <_vfprintf_r+0x14a0>
8000864a:	fa cb f9 44 	sub	r11,sp,-1724
8000864e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008652:	c1 f8       	rjmp	80008690 <_vfprintf_r+0x14dc>
80008654:	fa c8 f9 50 	sub	r8,sp,-1712
80008658:	1a d8       	st.w	--sp,r8
8000865a:	fa c8 fa b8 	sub	r8,sp,-1352
8000865e:	0c 9b       	mov	r11,r6
80008660:	1a d8       	st.w	--sp,r8
80008662:	fa c8 fb b4 	sub	r8,sp,-1100
80008666:	04 9a       	mov	r10,r2
80008668:	1a d8       	st.w	--sp,r8
8000866a:	08 9c       	mov	r12,r4
8000866c:	fa c8 f9 40 	sub	r8,sp,-1728
80008670:	fa c9 ff b4 	sub	r9,sp,-76
80008674:	fe b0 f4 08 	rcall	80006e84 <get_arg>
80008678:	2f dd       	sub	sp,-12
8000867a:	78 0b       	ld.w	r11,r12[0x0]
8000867c:	c2 48       	rjmp	800086c4 <_vfprintf_r+0x1510>
8000867e:	ee ca ff ff 	sub	r10,r7,-1
80008682:	10 37       	cp.w	r7,r8
80008684:	c0 94       	brge	80008696 <_vfprintf_r+0x14e2>
80008686:	fa c9 f9 44 	sub	r9,sp,-1724
8000868a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000868e:	14 97       	mov	r7,r10
80008690:	ec fb fd 88 	ld.w	r11,r6[-632]
80008694:	c1 88       	rjmp	800086c4 <_vfprintf_r+0x1510>
80008696:	41 09       	lddsp	r9,sp[0x40]
80008698:	59 f8       	cp.w	r8,31
8000869a:	e0 89 00 11 	brgt	800086bc <_vfprintf_r+0x1508>
8000869e:	f2 cb ff fc 	sub	r11,r9,-4
800086a2:	51 0b       	stdsp	sp[0x40],r11
800086a4:	fa c6 f9 44 	sub	r6,sp,-1724
800086a8:	72 0b       	ld.w	r11,r9[0x0]
800086aa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086ae:	f3 4b fd 88 	st.w	r9[-632],r11
800086b2:	2f f8       	sub	r8,-1
800086b4:	14 97       	mov	r7,r10
800086b6:	fb 48 06 b4 	st.w	sp[1716],r8
800086ba:	c0 58       	rjmp	800086c4 <_vfprintf_r+0x1510>
800086bc:	72 0b       	ld.w	r11,r9[0x0]
800086be:	14 97       	mov	r7,r10
800086c0:	2f c9       	sub	r9,-4
800086c2:	51 09       	stdsp	sp[0x40],r9
800086c4:	50 1b       	stdsp	sp[0x4],r11
800086c6:	30 0e       	mov	lr,0
800086c8:	50 0e       	stdsp	sp[0x0],lr
800086ca:	40 08       	lddsp	r8,sp[0x0]
800086cc:	40 1c       	lddsp	r12,sp[0x4]
800086ce:	18 48       	or	r8,r12
800086d0:	5f 19       	srne	r9
800086d2:	0a 98       	mov	r8,r5
800086d4:	eb e9 00 09 	and	r9,r5,r9
800086d8:	a1 b8       	sbr	r8,0x1
800086da:	58 09       	cp.w	r9,0
800086dc:	c0 70       	breq	800086ea <_vfprintf_r+0x1536>
800086de:	10 95       	mov	r5,r8
800086e0:	fb 60 06 b9 	st.b	sp[1721],r0
800086e4:	33 08       	mov	r8,48
800086e6:	fb 68 06 b8 	st.b	sp[1720],r8
800086ea:	30 28       	mov	r8,2
800086ec:	30 09       	mov	r9,0
800086ee:	fb 69 06 bb 	st.b	sp[1723],r9
800086f2:	0a 99       	mov	r9,r5
800086f4:	a7 d9       	cbr	r9,0x7
800086f6:	40 2b       	lddsp	r11,sp[0x8]
800086f8:	40 16       	lddsp	r6,sp[0x4]
800086fa:	58 0b       	cp.w	r11,0
800086fc:	5f 1a       	srne	r10
800086fe:	f2 05 17 40 	movge	r5,r9
80008702:	fa c2 f9 78 	sub	r2,sp,-1672
80008706:	40 09       	lddsp	r9,sp[0x0]
80008708:	0c 49       	or	r9,r6
8000870a:	5f 19       	srne	r9
8000870c:	f5 e9 10 09 	or	r9,r10,r9
80008710:	c5 c0       	breq	800087c8 <_vfprintf_r+0x1614>
80008712:	30 19       	mov	r9,1
80008714:	f2 08 18 00 	cp.b	r8,r9
80008718:	c0 60       	breq	80008724 <_vfprintf_r+0x1570>
8000871a:	30 29       	mov	r9,2
8000871c:	f2 08 18 00 	cp.b	r8,r9
80008720:	c0 41       	brne	80008728 <_vfprintf_r+0x1574>
80008722:	c3 c8       	rjmp	8000879a <_vfprintf_r+0x15e6>
80008724:	04 96       	mov	r6,r2
80008726:	c3 08       	rjmp	80008786 <_vfprintf_r+0x15d2>
80008728:	04 96       	mov	r6,r2
8000872a:	fa e8 00 00 	ld.d	r8,sp[0]
8000872e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008732:	2d 0a       	sub	r10,-48
80008734:	0c fa       	st.b	--r6,r10
80008736:	f0 0b 16 03 	lsr	r11,r8,0x3
8000873a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000873e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008742:	18 99       	mov	r9,r12
80008744:	16 98       	mov	r8,r11
80008746:	58 08       	cp.w	r8,0
80008748:	5c 29       	cpc	r9
8000874a:	cf 21       	brne	8000872e <_vfprintf_r+0x157a>
8000874c:	fa e9 00 00 	st.d	sp[0],r8
80008750:	ed b5 00 00 	bld	r5,0x0
80008754:	c4 51       	brne	800087de <_vfprintf_r+0x162a>
80008756:	33 09       	mov	r9,48
80008758:	f2 0a 18 00 	cp.b	r10,r9
8000875c:	c4 10       	breq	800087de <_vfprintf_r+0x162a>
8000875e:	0c f9       	st.b	--r6,r9
80008760:	c3 f8       	rjmp	800087de <_vfprintf_r+0x162a>
80008762:	fa ea 00 00 	ld.d	r10,sp[0]
80008766:	30 a8       	mov	r8,10
80008768:	30 09       	mov	r9,0
8000876a:	e0 a0 1a 19 	rcall	8000bb9c <__avr32_umod64>
8000876e:	30 a8       	mov	r8,10
80008770:	2d 0a       	sub	r10,-48
80008772:	30 09       	mov	r9,0
80008774:	ac 8a       	st.b	r6[0x0],r10
80008776:	fa ea 00 00 	ld.d	r10,sp[0]
8000877a:	e0 a0 18 df 	rcall	8000b938 <__avr32_udiv64>
8000877e:	16 99       	mov	r9,r11
80008780:	14 98       	mov	r8,r10
80008782:	fa e9 00 00 	st.d	sp[0],r8
80008786:	20 16       	sub	r6,1
80008788:	fa ea 00 00 	ld.d	r10,sp[0]
8000878c:	58 9a       	cp.w	r10,9
8000878e:	5c 2b       	cpc	r11
80008790:	fe 9b ff e9 	brhi	80008762 <_vfprintf_r+0x15ae>
80008794:	1b f8       	ld.ub	r8,sp[0x7]
80008796:	2d 08       	sub	r8,-48
80008798:	c2 08       	rjmp	800087d8 <_vfprintf_r+0x1624>
8000879a:	04 96       	mov	r6,r2
8000879c:	fa e8 00 00 	ld.d	r8,sp[0]
800087a0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800087a4:	40 de       	lddsp	lr,sp[0x34]
800087a6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800087aa:	0c fa       	st.b	--r6,r10
800087ac:	f2 0b 16 04 	lsr	r11,r9,0x4
800087b0:	f0 0a 16 04 	lsr	r10,r8,0x4
800087b4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800087b8:	16 99       	mov	r9,r11
800087ba:	14 98       	mov	r8,r10
800087bc:	58 08       	cp.w	r8,0
800087be:	5c 29       	cpc	r9
800087c0:	cf 01       	brne	800087a0 <_vfprintf_r+0x15ec>
800087c2:	fa e9 00 00 	st.d	sp[0],r8
800087c6:	c0 c8       	rjmp	800087de <_vfprintf_r+0x162a>
800087c8:	58 08       	cp.w	r8,0
800087ca:	c0 91       	brne	800087dc <_vfprintf_r+0x1628>
800087cc:	ed b5 00 00 	bld	r5,0x0
800087d0:	c0 61       	brne	800087dc <_vfprintf_r+0x1628>
800087d2:	fa c6 f9 79 	sub	r6,sp,-1671
800087d6:	33 08       	mov	r8,48
800087d8:	ac 88       	st.b	r6[0x0],r8
800087da:	c0 28       	rjmp	800087de <_vfprintf_r+0x162a>
800087dc:	04 96       	mov	r6,r2
800087de:	0c 12       	sub	r2,r6
800087e0:	c1 c8       	rjmp	80008818 <_vfprintf_r+0x1664>
800087e2:	50 a7       	stdsp	sp[0x28],r7
800087e4:	50 80       	stdsp	sp[0x20],r0
800087e6:	40 93       	lddsp	r3,sp[0x24]
800087e8:	0c 97       	mov	r7,r6
800087ea:	10 90       	mov	r0,r8
800087ec:	04 94       	mov	r4,r2
800087ee:	40 41       	lddsp	r1,sp[0x10]
800087f0:	58 08       	cp.w	r8,0
800087f2:	e0 80 04 4f 	breq	80009090 <_vfprintf_r+0x1edc>
800087f6:	fb 68 06 60 	st.b	sp[1632],r8
800087fa:	30 0c       	mov	r12,0
800087fc:	30 08       	mov	r8,0
800087fe:	30 12       	mov	r2,1
80008800:	fb 68 06 bb 	st.b	sp[1723],r8
80008804:	50 2c       	stdsp	sp[0x8],r12
80008806:	fa c6 f9 a0 	sub	r6,sp,-1632
8000880a:	c0 78       	rjmp	80008818 <_vfprintf_r+0x1664>
8000880c:	30 0b       	mov	r11,0
8000880e:	50 2b       	stdsp	sp[0x8],r11
80008810:	c0 48       	rjmp	80008818 <_vfprintf_r+0x1664>
80008812:	40 22       	lddsp	r2,sp[0x8]
80008814:	30 0a       	mov	r10,0
80008816:	50 2a       	stdsp	sp[0x8],r10
80008818:	40 29       	lddsp	r9,sp[0x8]
8000881a:	e4 09 0c 49 	max	r9,r2,r9
8000881e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008822:	50 39       	stdsp	sp[0xc],r9
80008824:	0a 9e       	mov	lr,r5
80008826:	30 09       	mov	r9,0
80008828:	e2 1e 00 02 	andl	lr,0x2,COH
8000882c:	f2 08 18 00 	cp.b	r8,r9
80008830:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008834:	f7 b8 01 ff 	subne	r8,-1
80008838:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000883c:	0a 9b       	mov	r11,r5
8000883e:	58 0e       	cp.w	lr,0
80008840:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008844:	f7 bc 01 fe 	subne	r12,-2
80008848:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000884c:	e2 1b 00 84 	andl	r11,0x84,COH
80008850:	50 fe       	stdsp	sp[0x3c],lr
80008852:	50 9b       	stdsp	sp[0x24],r11
80008854:	c4 71       	brne	800088e2 <_vfprintf_r+0x172e>
80008856:	40 8a       	lddsp	r10,sp[0x20]
80008858:	40 39       	lddsp	r9,sp[0xc]
8000885a:	12 1a       	sub	r10,r9
8000885c:	50 4a       	stdsp	sp[0x10],r10
8000885e:	58 0a       	cp.w	r10,0
80008860:	e0 89 00 20 	brgt	800088a0 <_vfprintf_r+0x16ec>
80008864:	c3 f8       	rjmp	800088e2 <_vfprintf_r+0x172e>
80008866:	2f 09       	sub	r9,-16
80008868:	2f f8       	sub	r8,-1
8000886a:	fe ce ba 8a 	sub	lr,pc,-17782
8000886e:	31 0c       	mov	r12,16
80008870:	fb 49 06 90 	st.w	sp[1680],r9
80008874:	87 0e       	st.w	r3[0x0],lr
80008876:	87 1c       	st.w	r3[0x4],r12
80008878:	fb 48 06 8c 	st.w	sp[1676],r8
8000887c:	58 78       	cp.w	r8,7
8000887e:	e0 89 00 04 	brgt	80008886 <_vfprintf_r+0x16d2>
80008882:	2f 83       	sub	r3,-8
80008884:	c0 b8       	rjmp	8000889a <_vfprintf_r+0x16e6>
80008886:	fa ca f9 78 	sub	r10,sp,-1672
8000888a:	02 9b       	mov	r11,r1
8000888c:	08 9c       	mov	r12,r4
8000888e:	fe b0 f4 85 	rcall	80007198 <__sprint_r>
80008892:	e0 81 04 10 	brne	800090b2 <_vfprintf_r+0x1efe>
80008896:	fa c3 f9 e0 	sub	r3,sp,-1568
8000889a:	40 4b       	lddsp	r11,sp[0x10]
8000889c:	21 0b       	sub	r11,16
8000889e:	50 4b       	stdsp	sp[0x10],r11
800088a0:	fa f9 06 90 	ld.w	r9,sp[1680]
800088a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088a8:	fe ca ba c8 	sub	r10,pc,-17720
800088ac:	40 4e       	lddsp	lr,sp[0x10]
800088ae:	59 0e       	cp.w	lr,16
800088b0:	fe 99 ff db 	brgt	80008866 <_vfprintf_r+0x16b2>
800088b4:	1c 09       	add	r9,lr
800088b6:	2f f8       	sub	r8,-1
800088b8:	87 0a       	st.w	r3[0x0],r10
800088ba:	fb 49 06 90 	st.w	sp[1680],r9
800088be:	87 1e       	st.w	r3[0x4],lr
800088c0:	fb 48 06 8c 	st.w	sp[1676],r8
800088c4:	58 78       	cp.w	r8,7
800088c6:	e0 89 00 04 	brgt	800088ce <_vfprintf_r+0x171a>
800088ca:	2f 83       	sub	r3,-8
800088cc:	c0 b8       	rjmp	800088e2 <_vfprintf_r+0x172e>
800088ce:	fa ca f9 78 	sub	r10,sp,-1672
800088d2:	02 9b       	mov	r11,r1
800088d4:	08 9c       	mov	r12,r4
800088d6:	fe b0 f4 61 	rcall	80007198 <__sprint_r>
800088da:	e0 81 03 ec 	brne	800090b2 <_vfprintf_r+0x1efe>
800088de:	fa c3 f9 e0 	sub	r3,sp,-1568
800088e2:	30 09       	mov	r9,0
800088e4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800088e8:	f2 08 18 00 	cp.b	r8,r9
800088ec:	c1 f0       	breq	8000892a <_vfprintf_r+0x1776>
800088ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800088f2:	fa c9 f9 45 	sub	r9,sp,-1723
800088f6:	2f f8       	sub	r8,-1
800088f8:	87 09       	st.w	r3[0x0],r9
800088fa:	fb 48 06 90 	st.w	sp[1680],r8
800088fe:	30 19       	mov	r9,1
80008900:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008904:	87 19       	st.w	r3[0x4],r9
80008906:	2f f8       	sub	r8,-1
80008908:	fb 48 06 8c 	st.w	sp[1676],r8
8000890c:	58 78       	cp.w	r8,7
8000890e:	e0 89 00 04 	brgt	80008916 <_vfprintf_r+0x1762>
80008912:	2f 83       	sub	r3,-8
80008914:	c0 b8       	rjmp	8000892a <_vfprintf_r+0x1776>
80008916:	fa ca f9 78 	sub	r10,sp,-1672
8000891a:	02 9b       	mov	r11,r1
8000891c:	08 9c       	mov	r12,r4
8000891e:	fe b0 f4 3d 	rcall	80007198 <__sprint_r>
80008922:	e0 81 03 c8 	brne	800090b2 <_vfprintf_r+0x1efe>
80008926:	fa c3 f9 e0 	sub	r3,sp,-1568
8000892a:	40 fc       	lddsp	r12,sp[0x3c]
8000892c:	58 0c       	cp.w	r12,0
8000892e:	c1 f0       	breq	8000896c <_vfprintf_r+0x17b8>
80008930:	fa f8 06 90 	ld.w	r8,sp[1680]
80008934:	fa c9 f9 48 	sub	r9,sp,-1720
80008938:	2f e8       	sub	r8,-2
8000893a:	87 09       	st.w	r3[0x0],r9
8000893c:	fb 48 06 90 	st.w	sp[1680],r8
80008940:	30 29       	mov	r9,2
80008942:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008946:	87 19       	st.w	r3[0x4],r9
80008948:	2f f8       	sub	r8,-1
8000894a:	fb 48 06 8c 	st.w	sp[1676],r8
8000894e:	58 78       	cp.w	r8,7
80008950:	e0 89 00 04 	brgt	80008958 <_vfprintf_r+0x17a4>
80008954:	2f 83       	sub	r3,-8
80008956:	c0 b8       	rjmp	8000896c <_vfprintf_r+0x17b8>
80008958:	fa ca f9 78 	sub	r10,sp,-1672
8000895c:	02 9b       	mov	r11,r1
8000895e:	08 9c       	mov	r12,r4
80008960:	fe b0 f4 1c 	rcall	80007198 <__sprint_r>
80008964:	e0 81 03 a7 	brne	800090b2 <_vfprintf_r+0x1efe>
80008968:	fa c3 f9 e0 	sub	r3,sp,-1568
8000896c:	40 9b       	lddsp	r11,sp[0x24]
8000896e:	e0 4b 00 80 	cp.w	r11,128
80008972:	c4 71       	brne	80008a00 <_vfprintf_r+0x184c>
80008974:	40 8a       	lddsp	r10,sp[0x20]
80008976:	40 39       	lddsp	r9,sp[0xc]
80008978:	12 1a       	sub	r10,r9
8000897a:	50 4a       	stdsp	sp[0x10],r10
8000897c:	58 0a       	cp.w	r10,0
8000897e:	e0 89 00 20 	brgt	800089be <_vfprintf_r+0x180a>
80008982:	c3 f8       	rjmp	80008a00 <_vfprintf_r+0x184c>
80008984:	2f 09       	sub	r9,-16
80008986:	2f f8       	sub	r8,-1
80008988:	fe ce bb 98 	sub	lr,pc,-17512
8000898c:	31 0c       	mov	r12,16
8000898e:	fb 49 06 90 	st.w	sp[1680],r9
80008992:	87 0e       	st.w	r3[0x0],lr
80008994:	87 1c       	st.w	r3[0x4],r12
80008996:	fb 48 06 8c 	st.w	sp[1676],r8
8000899a:	58 78       	cp.w	r8,7
8000899c:	e0 89 00 04 	brgt	800089a4 <_vfprintf_r+0x17f0>
800089a0:	2f 83       	sub	r3,-8
800089a2:	c0 b8       	rjmp	800089b8 <_vfprintf_r+0x1804>
800089a4:	fa ca f9 78 	sub	r10,sp,-1672
800089a8:	02 9b       	mov	r11,r1
800089aa:	08 9c       	mov	r12,r4
800089ac:	fe b0 f3 f6 	rcall	80007198 <__sprint_r>
800089b0:	e0 81 03 81 	brne	800090b2 <_vfprintf_r+0x1efe>
800089b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800089b8:	40 4b       	lddsp	r11,sp[0x10]
800089ba:	21 0b       	sub	r11,16
800089bc:	50 4b       	stdsp	sp[0x10],r11
800089be:	fa f9 06 90 	ld.w	r9,sp[1680]
800089c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089c6:	fe ca bb d6 	sub	r10,pc,-17450
800089ca:	40 4e       	lddsp	lr,sp[0x10]
800089cc:	59 0e       	cp.w	lr,16
800089ce:	fe 99 ff db 	brgt	80008984 <_vfprintf_r+0x17d0>
800089d2:	1c 09       	add	r9,lr
800089d4:	2f f8       	sub	r8,-1
800089d6:	87 0a       	st.w	r3[0x0],r10
800089d8:	fb 49 06 90 	st.w	sp[1680],r9
800089dc:	87 1e       	st.w	r3[0x4],lr
800089de:	fb 48 06 8c 	st.w	sp[1676],r8
800089e2:	58 78       	cp.w	r8,7
800089e4:	e0 89 00 04 	brgt	800089ec <_vfprintf_r+0x1838>
800089e8:	2f 83       	sub	r3,-8
800089ea:	c0 b8       	rjmp	80008a00 <_vfprintf_r+0x184c>
800089ec:	fa ca f9 78 	sub	r10,sp,-1672
800089f0:	02 9b       	mov	r11,r1
800089f2:	08 9c       	mov	r12,r4
800089f4:	fe b0 f3 d2 	rcall	80007198 <__sprint_r>
800089f8:	e0 81 03 5d 	brne	800090b2 <_vfprintf_r+0x1efe>
800089fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a00:	40 2c       	lddsp	r12,sp[0x8]
80008a02:	04 1c       	sub	r12,r2
80008a04:	50 2c       	stdsp	sp[0x8],r12
80008a06:	58 0c       	cp.w	r12,0
80008a08:	e0 89 00 20 	brgt	80008a48 <_vfprintf_r+0x1894>
80008a0c:	c3 f8       	rjmp	80008a8a <_vfprintf_r+0x18d6>
80008a0e:	2f 09       	sub	r9,-16
80008a10:	2f f8       	sub	r8,-1
80008a12:	fe cb bc 22 	sub	r11,pc,-17374
80008a16:	31 0a       	mov	r10,16
80008a18:	fb 49 06 90 	st.w	sp[1680],r9
80008a1c:	87 0b       	st.w	r3[0x0],r11
80008a1e:	87 1a       	st.w	r3[0x4],r10
80008a20:	fb 48 06 8c 	st.w	sp[1676],r8
80008a24:	58 78       	cp.w	r8,7
80008a26:	e0 89 00 04 	brgt	80008a2e <_vfprintf_r+0x187a>
80008a2a:	2f 83       	sub	r3,-8
80008a2c:	c0 b8       	rjmp	80008a42 <_vfprintf_r+0x188e>
80008a2e:	fa ca f9 78 	sub	r10,sp,-1672
80008a32:	02 9b       	mov	r11,r1
80008a34:	08 9c       	mov	r12,r4
80008a36:	fe b0 f3 b1 	rcall	80007198 <__sprint_r>
80008a3a:	e0 81 03 3c 	brne	800090b2 <_vfprintf_r+0x1efe>
80008a3e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a42:	40 29       	lddsp	r9,sp[0x8]
80008a44:	21 09       	sub	r9,16
80008a46:	50 29       	stdsp	sp[0x8],r9
80008a48:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a50:	fe ca bc 60 	sub	r10,pc,-17312
80008a54:	40 2e       	lddsp	lr,sp[0x8]
80008a56:	59 0e       	cp.w	lr,16
80008a58:	fe 99 ff db 	brgt	80008a0e <_vfprintf_r+0x185a>
80008a5c:	1c 09       	add	r9,lr
80008a5e:	2f f8       	sub	r8,-1
80008a60:	87 0a       	st.w	r3[0x0],r10
80008a62:	fb 49 06 90 	st.w	sp[1680],r9
80008a66:	87 1e       	st.w	r3[0x4],lr
80008a68:	fb 48 06 8c 	st.w	sp[1676],r8
80008a6c:	58 78       	cp.w	r8,7
80008a6e:	e0 89 00 04 	brgt	80008a76 <_vfprintf_r+0x18c2>
80008a72:	2f 83       	sub	r3,-8
80008a74:	c0 b8       	rjmp	80008a8a <_vfprintf_r+0x18d6>
80008a76:	fa ca f9 78 	sub	r10,sp,-1672
80008a7a:	02 9b       	mov	r11,r1
80008a7c:	08 9c       	mov	r12,r4
80008a7e:	fe b0 f3 8d 	rcall	80007198 <__sprint_r>
80008a82:	e0 81 03 18 	brne	800090b2 <_vfprintf_r+0x1efe>
80008a86:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a8a:	ed b5 00 08 	bld	r5,0x8
80008a8e:	c0 b0       	breq	80008aa4 <_vfprintf_r+0x18f0>
80008a90:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a94:	87 12       	st.w	r3[0x4],r2
80008a96:	87 06       	st.w	r3[0x0],r6
80008a98:	f0 02 00 02 	add	r2,r8,r2
80008a9c:	fb 42 06 90 	st.w	sp[1680],r2
80008aa0:	e0 8f 01 d4 	bral	80008e48 <_vfprintf_r+0x1c94>
80008aa4:	e0 40 00 65 	cp.w	r0,101
80008aa8:	e0 8a 01 d6 	brle	80008e54 <_vfprintf_r+0x1ca0>
80008aac:	30 08       	mov	r8,0
80008aae:	30 09       	mov	r9,0
80008ab0:	40 5b       	lddsp	r11,sp[0x14]
80008ab2:	40 7a       	lddsp	r10,sp[0x1c]
80008ab4:	e0 a0 15 3b 	rcall	8000b52a <__avr32_f64_cmp_eq>
80008ab8:	c7 90       	breq	80008baa <_vfprintf_r+0x19f6>
80008aba:	fa f8 06 90 	ld.w	r8,sp[1680]
80008abe:	fe c9 bc e2 	sub	r9,pc,-17182
80008ac2:	2f f8       	sub	r8,-1
80008ac4:	87 09       	st.w	r3[0x0],r9
80008ac6:	fb 48 06 90 	st.w	sp[1680],r8
80008aca:	30 19       	mov	r9,1
80008acc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ad0:	87 19       	st.w	r3[0x4],r9
80008ad2:	2f f8       	sub	r8,-1
80008ad4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ad8:	58 78       	cp.w	r8,7
80008ada:	e0 89 00 05 	brgt	80008ae4 <_vfprintf_r+0x1930>
80008ade:	2f 83       	sub	r3,-8
80008ae0:	c0 c8       	rjmp	80008af8 <_vfprintf_r+0x1944>
80008ae2:	d7 03       	nop
80008ae4:	fa ca f9 78 	sub	r10,sp,-1672
80008ae8:	02 9b       	mov	r11,r1
80008aea:	08 9c       	mov	r12,r4
80008aec:	fe b0 f3 56 	rcall	80007198 <__sprint_r>
80008af0:	e0 81 02 e1 	brne	800090b2 <_vfprintf_r+0x1efe>
80008af4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008af8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008afc:	40 6c       	lddsp	r12,sp[0x18]
80008afe:	18 38       	cp.w	r8,r12
80008b00:	c0 55       	brlt	80008b0a <_vfprintf_r+0x1956>
80008b02:	ed b5 00 00 	bld	r5,0x0
80008b06:	e0 81 02 6b 	brne	80008fdc <_vfprintf_r+0x1e28>
80008b0a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b0e:	2f f8       	sub	r8,-1
80008b10:	40 cb       	lddsp	r11,sp[0x30]
80008b12:	fb 48 06 90 	st.w	sp[1680],r8
80008b16:	30 19       	mov	r9,1
80008b18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b1c:	87 0b       	st.w	r3[0x0],r11
80008b1e:	2f f8       	sub	r8,-1
80008b20:	87 19       	st.w	r3[0x4],r9
80008b22:	fb 48 06 8c 	st.w	sp[1676],r8
80008b26:	58 78       	cp.w	r8,7
80008b28:	e0 89 00 04 	brgt	80008b30 <_vfprintf_r+0x197c>
80008b2c:	2f 83       	sub	r3,-8
80008b2e:	c0 b8       	rjmp	80008b44 <_vfprintf_r+0x1990>
80008b30:	fa ca f9 78 	sub	r10,sp,-1672
80008b34:	02 9b       	mov	r11,r1
80008b36:	08 9c       	mov	r12,r4
80008b38:	fe b0 f3 30 	rcall	80007198 <__sprint_r>
80008b3c:	e0 81 02 bb 	brne	800090b2 <_vfprintf_r+0x1efe>
80008b40:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b44:	40 66       	lddsp	r6,sp[0x18]
80008b46:	20 16       	sub	r6,1
80008b48:	58 06       	cp.w	r6,0
80008b4a:	e0 89 00 1d 	brgt	80008b84 <_vfprintf_r+0x19d0>
80008b4e:	e0 8f 02 47 	bral	80008fdc <_vfprintf_r+0x1e28>
80008b52:	2f 09       	sub	r9,-16
80008b54:	2f f8       	sub	r8,-1
80008b56:	fb 49 06 90 	st.w	sp[1680],r9
80008b5a:	87 02       	st.w	r3[0x0],r2
80008b5c:	87 10       	st.w	r3[0x4],r0
80008b5e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b62:	58 78       	cp.w	r8,7
80008b64:	e0 89 00 04 	brgt	80008b6c <_vfprintf_r+0x19b8>
80008b68:	2f 83       	sub	r3,-8
80008b6a:	c0 b8       	rjmp	80008b80 <_vfprintf_r+0x19cc>
80008b6c:	fa ca f9 78 	sub	r10,sp,-1672
80008b70:	02 9b       	mov	r11,r1
80008b72:	08 9c       	mov	r12,r4
80008b74:	fe b0 f3 12 	rcall	80007198 <__sprint_r>
80008b78:	e0 81 02 9d 	brne	800090b2 <_vfprintf_r+0x1efe>
80008b7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b80:	21 06       	sub	r6,16
80008b82:	c0 48       	rjmp	80008b8a <_vfprintf_r+0x19d6>
80008b84:	fe c2 bd 94 	sub	r2,pc,-17004
80008b88:	31 00       	mov	r0,16
80008b8a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b92:	fe ca bd a2 	sub	r10,pc,-16990
80008b96:	59 06       	cp.w	r6,16
80008b98:	fe 99 ff dd 	brgt	80008b52 <_vfprintf_r+0x199e>
80008b9c:	0c 09       	add	r9,r6
80008b9e:	87 0a       	st.w	r3[0x0],r10
80008ba0:	fb 49 06 90 	st.w	sp[1680],r9
80008ba4:	2f f8       	sub	r8,-1
80008ba6:	87 16       	st.w	r3[0x4],r6
80008ba8:	c5 39       	rjmp	80008e4e <_vfprintf_r+0x1c9a>
80008baa:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008bae:	58 0a       	cp.w	r10,0
80008bb0:	e0 89 00 92 	brgt	80008cd4 <_vfprintf_r+0x1b20>
80008bb4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bb8:	fe c9 bd dc 	sub	r9,pc,-16932
80008bbc:	2f f8       	sub	r8,-1
80008bbe:	87 09       	st.w	r3[0x0],r9
80008bc0:	fb 48 06 90 	st.w	sp[1680],r8
80008bc4:	30 19       	mov	r9,1
80008bc6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bca:	87 19       	st.w	r3[0x4],r9
80008bcc:	2f f8       	sub	r8,-1
80008bce:	fb 48 06 8c 	st.w	sp[1676],r8
80008bd2:	58 78       	cp.w	r8,7
80008bd4:	e0 89 00 04 	brgt	80008bdc <_vfprintf_r+0x1a28>
80008bd8:	2f 83       	sub	r3,-8
80008bda:	c0 b8       	rjmp	80008bf0 <_vfprintf_r+0x1a3c>
80008bdc:	fa ca f9 78 	sub	r10,sp,-1672
80008be0:	02 9b       	mov	r11,r1
80008be2:	08 9c       	mov	r12,r4
80008be4:	fe b0 f2 da 	rcall	80007198 <__sprint_r>
80008be8:	e0 81 02 65 	brne	800090b2 <_vfprintf_r+0x1efe>
80008bec:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bf0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bf4:	58 08       	cp.w	r8,0
80008bf6:	c0 81       	brne	80008c06 <_vfprintf_r+0x1a52>
80008bf8:	40 6a       	lddsp	r10,sp[0x18]
80008bfa:	58 0a       	cp.w	r10,0
80008bfc:	c0 51       	brne	80008c06 <_vfprintf_r+0x1a52>
80008bfe:	ed b5 00 00 	bld	r5,0x0
80008c02:	e0 81 01 ed 	brne	80008fdc <_vfprintf_r+0x1e28>
80008c06:	40 c9       	lddsp	r9,sp[0x30]
80008c08:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c0c:	2f f8       	sub	r8,-1
80008c0e:	87 09       	st.w	r3[0x0],r9
80008c10:	fb 48 06 90 	st.w	sp[1680],r8
80008c14:	30 19       	mov	r9,1
80008c16:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c1a:	87 19       	st.w	r3[0x4],r9
80008c1c:	2f f8       	sub	r8,-1
80008c1e:	fb 48 06 8c 	st.w	sp[1676],r8
80008c22:	58 78       	cp.w	r8,7
80008c24:	e0 89 00 04 	brgt	80008c2c <_vfprintf_r+0x1a78>
80008c28:	2f 83       	sub	r3,-8
80008c2a:	c0 b8       	rjmp	80008c40 <_vfprintf_r+0x1a8c>
80008c2c:	fa ca f9 78 	sub	r10,sp,-1672
80008c30:	02 9b       	mov	r11,r1
80008c32:	08 9c       	mov	r12,r4
80008c34:	fe b0 f2 b2 	rcall	80007198 <__sprint_r>
80008c38:	e0 81 02 3d 	brne	800090b2 <_vfprintf_r+0x1efe>
80008c3c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c40:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c44:	5c 32       	neg	r2
80008c46:	58 02       	cp.w	r2,0
80008c48:	e0 89 00 1d 	brgt	80008c82 <_vfprintf_r+0x1ace>
80008c4c:	c3 d8       	rjmp	80008cc6 <_vfprintf_r+0x1b12>
80008c4e:	2f 09       	sub	r9,-16
80008c50:	2f f8       	sub	r8,-1
80008c52:	31 0e       	mov	lr,16
80008c54:	fb 49 06 90 	st.w	sp[1680],r9
80008c58:	87 00       	st.w	r3[0x0],r0
80008c5a:	87 1e       	st.w	r3[0x4],lr
80008c5c:	fb 48 06 8c 	st.w	sp[1676],r8
80008c60:	58 78       	cp.w	r8,7
80008c62:	e0 89 00 04 	brgt	80008c6a <_vfprintf_r+0x1ab6>
80008c66:	2f 83       	sub	r3,-8
80008c68:	c0 b8       	rjmp	80008c7e <_vfprintf_r+0x1aca>
80008c6a:	fa ca f9 78 	sub	r10,sp,-1672
80008c6e:	02 9b       	mov	r11,r1
80008c70:	08 9c       	mov	r12,r4
80008c72:	fe b0 f2 93 	rcall	80007198 <__sprint_r>
80008c76:	e0 81 02 1e 	brne	800090b2 <_vfprintf_r+0x1efe>
80008c7a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c7e:	21 02       	sub	r2,16
80008c80:	c0 38       	rjmp	80008c86 <_vfprintf_r+0x1ad2>
80008c82:	fe c0 be 92 	sub	r0,pc,-16750
80008c86:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c8e:	fe ca be 9e 	sub	r10,pc,-16738
80008c92:	59 02       	cp.w	r2,16
80008c94:	fe 99 ff dd 	brgt	80008c4e <_vfprintf_r+0x1a9a>
80008c98:	04 09       	add	r9,r2
80008c9a:	2f f8       	sub	r8,-1
80008c9c:	87 0a       	st.w	r3[0x0],r10
80008c9e:	fb 49 06 90 	st.w	sp[1680],r9
80008ca2:	87 12       	st.w	r3[0x4],r2
80008ca4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ca8:	58 78       	cp.w	r8,7
80008caa:	e0 89 00 04 	brgt	80008cb2 <_vfprintf_r+0x1afe>
80008cae:	2f 83       	sub	r3,-8
80008cb0:	c0 b8       	rjmp	80008cc6 <_vfprintf_r+0x1b12>
80008cb2:	fa ca f9 78 	sub	r10,sp,-1672
80008cb6:	02 9b       	mov	r11,r1
80008cb8:	08 9c       	mov	r12,r4
80008cba:	fe b0 f2 6f 	rcall	80007198 <__sprint_r>
80008cbe:	e0 81 01 fa 	brne	800090b2 <_vfprintf_r+0x1efe>
80008cc2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cc6:	40 6c       	lddsp	r12,sp[0x18]
80008cc8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ccc:	87 06       	st.w	r3[0x0],r6
80008cce:	87 1c       	st.w	r3[0x4],r12
80008cd0:	18 08       	add	r8,r12
80008cd2:	cb 98       	rjmp	80008e44 <_vfprintf_r+0x1c90>
80008cd4:	fa f9 06 90 	ld.w	r9,sp[1680]
80008cd8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cdc:	40 6b       	lddsp	r11,sp[0x18]
80008cde:	16 3a       	cp.w	r10,r11
80008ce0:	c6 f5       	brlt	80008dbe <_vfprintf_r+0x1c0a>
80008ce2:	16 09       	add	r9,r11
80008ce4:	2f f8       	sub	r8,-1
80008ce6:	87 06       	st.w	r3[0x0],r6
80008ce8:	fb 49 06 90 	st.w	sp[1680],r9
80008cec:	87 1b       	st.w	r3[0x4],r11
80008cee:	fb 48 06 8c 	st.w	sp[1676],r8
80008cf2:	58 78       	cp.w	r8,7
80008cf4:	e0 89 00 04 	brgt	80008cfc <_vfprintf_r+0x1b48>
80008cf8:	2f 83       	sub	r3,-8
80008cfa:	c0 b8       	rjmp	80008d10 <_vfprintf_r+0x1b5c>
80008cfc:	fa ca f9 78 	sub	r10,sp,-1672
80008d00:	02 9b       	mov	r11,r1
80008d02:	08 9c       	mov	r12,r4
80008d04:	fe b0 f2 4a 	rcall	80007198 <__sprint_r>
80008d08:	e0 81 01 d5 	brne	800090b2 <_vfprintf_r+0x1efe>
80008d0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d10:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008d14:	40 6a       	lddsp	r10,sp[0x18]
80008d16:	14 16       	sub	r6,r10
80008d18:	58 06       	cp.w	r6,0
80008d1a:	e0 89 00 1c 	brgt	80008d52 <_vfprintf_r+0x1b9e>
80008d1e:	c3 d8       	rjmp	80008d98 <_vfprintf_r+0x1be4>
80008d20:	2f 09       	sub	r9,-16
80008d22:	2f f8       	sub	r8,-1
80008d24:	fb 49 06 90 	st.w	sp[1680],r9
80008d28:	87 02       	st.w	r3[0x0],r2
80008d2a:	87 10       	st.w	r3[0x4],r0
80008d2c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d30:	58 78       	cp.w	r8,7
80008d32:	e0 89 00 04 	brgt	80008d3a <_vfprintf_r+0x1b86>
80008d36:	2f 83       	sub	r3,-8
80008d38:	c0 b8       	rjmp	80008d4e <_vfprintf_r+0x1b9a>
80008d3a:	fa ca f9 78 	sub	r10,sp,-1672
80008d3e:	02 9b       	mov	r11,r1
80008d40:	08 9c       	mov	r12,r4
80008d42:	fe b0 f2 2b 	rcall	80007198 <__sprint_r>
80008d46:	e0 81 01 b6 	brne	800090b2 <_vfprintf_r+0x1efe>
80008d4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d4e:	21 06       	sub	r6,16
80008d50:	c0 48       	rjmp	80008d58 <_vfprintf_r+0x1ba4>
80008d52:	fe c2 bf 62 	sub	r2,pc,-16542
80008d56:	31 00       	mov	r0,16
80008d58:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d5c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d60:	fe ca bf 70 	sub	r10,pc,-16528
80008d64:	59 06       	cp.w	r6,16
80008d66:	fe 99 ff dd 	brgt	80008d20 <_vfprintf_r+0x1b6c>
80008d6a:	0c 09       	add	r9,r6
80008d6c:	2f f8       	sub	r8,-1
80008d6e:	87 0a       	st.w	r3[0x0],r10
80008d70:	fb 49 06 90 	st.w	sp[1680],r9
80008d74:	87 16       	st.w	r3[0x4],r6
80008d76:	fb 48 06 8c 	st.w	sp[1676],r8
80008d7a:	58 78       	cp.w	r8,7
80008d7c:	e0 89 00 04 	brgt	80008d84 <_vfprintf_r+0x1bd0>
80008d80:	2f 83       	sub	r3,-8
80008d82:	c0 b8       	rjmp	80008d98 <_vfprintf_r+0x1be4>
80008d84:	fa ca f9 78 	sub	r10,sp,-1672
80008d88:	02 9b       	mov	r11,r1
80008d8a:	08 9c       	mov	r12,r4
80008d8c:	fe b0 f2 06 	rcall	80007198 <__sprint_r>
80008d90:	e0 81 01 91 	brne	800090b2 <_vfprintf_r+0x1efe>
80008d94:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d98:	ed b5 00 00 	bld	r5,0x0
80008d9c:	e0 81 01 20 	brne	80008fdc <_vfprintf_r+0x1e28>
80008da0:	40 c9       	lddsp	r9,sp[0x30]
80008da2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008da6:	2f f8       	sub	r8,-1
80008da8:	87 09       	st.w	r3[0x0],r9
80008daa:	fb 48 06 90 	st.w	sp[1680],r8
80008dae:	30 19       	mov	r9,1
80008db0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db4:	87 19       	st.w	r3[0x4],r9
80008db6:	2f f8       	sub	r8,-1
80008db8:	fb 48 06 8c 	st.w	sp[1676],r8
80008dbc:	c0 29       	rjmp	80008fc0 <_vfprintf_r+0x1e0c>
80008dbe:	14 09       	add	r9,r10
80008dc0:	2f f8       	sub	r8,-1
80008dc2:	fb 49 06 90 	st.w	sp[1680],r9
80008dc6:	87 06       	st.w	r3[0x0],r6
80008dc8:	87 1a       	st.w	r3[0x4],r10
80008dca:	fb 48 06 8c 	st.w	sp[1676],r8
80008dce:	58 78       	cp.w	r8,7
80008dd0:	e0 89 00 04 	brgt	80008dd8 <_vfprintf_r+0x1c24>
80008dd4:	2f 83       	sub	r3,-8
80008dd6:	c0 b8       	rjmp	80008dec <_vfprintf_r+0x1c38>
80008dd8:	fa ca f9 78 	sub	r10,sp,-1672
80008ddc:	02 9b       	mov	r11,r1
80008dde:	08 9c       	mov	r12,r4
80008de0:	fe b0 f1 dc 	rcall	80007198 <__sprint_r>
80008de4:	e0 81 01 67 	brne	800090b2 <_vfprintf_r+0x1efe>
80008de8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dec:	40 c8       	lddsp	r8,sp[0x30]
80008dee:	87 08       	st.w	r3[0x0],r8
80008df0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008df4:	2f f8       	sub	r8,-1
80008df6:	30 19       	mov	r9,1
80008df8:	fb 48 06 90 	st.w	sp[1680],r8
80008dfc:	87 19       	st.w	r3[0x4],r9
80008dfe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e02:	2f f8       	sub	r8,-1
80008e04:	fb 48 06 8c 	st.w	sp[1676],r8
80008e08:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e0c:	58 78       	cp.w	r8,7
80008e0e:	e0 89 00 04 	brgt	80008e16 <_vfprintf_r+0x1c62>
80008e12:	2f 83       	sub	r3,-8
80008e14:	c0 b8       	rjmp	80008e2a <_vfprintf_r+0x1c76>
80008e16:	fa ca f9 78 	sub	r10,sp,-1672
80008e1a:	02 9b       	mov	r11,r1
80008e1c:	08 9c       	mov	r12,r4
80008e1e:	fe b0 f1 bd 	rcall	80007198 <__sprint_r>
80008e22:	e0 81 01 48 	brne	800090b2 <_vfprintf_r+0x1efe>
80008e26:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e2a:	04 06       	add	r6,r2
80008e2c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008e30:	87 06       	st.w	r3[0x0],r6
80008e32:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e36:	40 66       	lddsp	r6,sp[0x18]
80008e38:	40 6e       	lddsp	lr,sp[0x18]
80008e3a:	10 16       	sub	r6,r8
80008e3c:	f2 08 01 08 	sub	r8,r9,r8
80008e40:	87 16       	st.w	r3[0x4],r6
80008e42:	1c 08       	add	r8,lr
80008e44:	fb 48 06 90 	st.w	sp[1680],r8
80008e48:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e4c:	2f f8       	sub	r8,-1
80008e4e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e52:	cb 78       	rjmp	80008fc0 <_vfprintf_r+0x1e0c>
80008e54:	40 6c       	lddsp	r12,sp[0x18]
80008e56:	58 1c       	cp.w	r12,1
80008e58:	e0 89 00 06 	brgt	80008e64 <_vfprintf_r+0x1cb0>
80008e5c:	ed b5 00 00 	bld	r5,0x0
80008e60:	e0 81 00 85 	brne	80008f6a <_vfprintf_r+0x1db6>
80008e64:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e68:	2f f8       	sub	r8,-1
80008e6a:	30 19       	mov	r9,1
80008e6c:	fb 48 06 90 	st.w	sp[1680],r8
80008e70:	87 06       	st.w	r3[0x0],r6
80008e72:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e76:	87 19       	st.w	r3[0x4],r9
80008e78:	2f f8       	sub	r8,-1
80008e7a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e7e:	58 78       	cp.w	r8,7
80008e80:	e0 89 00 04 	brgt	80008e88 <_vfprintf_r+0x1cd4>
80008e84:	2f 83       	sub	r3,-8
80008e86:	c0 b8       	rjmp	80008e9c <_vfprintf_r+0x1ce8>
80008e88:	fa ca f9 78 	sub	r10,sp,-1672
80008e8c:	02 9b       	mov	r11,r1
80008e8e:	08 9c       	mov	r12,r4
80008e90:	fe b0 f1 84 	rcall	80007198 <__sprint_r>
80008e94:	e0 81 01 0f 	brne	800090b2 <_vfprintf_r+0x1efe>
80008e98:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e9c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ea0:	2f f8       	sub	r8,-1
80008ea2:	40 cb       	lddsp	r11,sp[0x30]
80008ea4:	fb 48 06 90 	st.w	sp[1680],r8
80008ea8:	30 19       	mov	r9,1
80008eaa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eae:	87 0b       	st.w	r3[0x0],r11
80008eb0:	2f f8       	sub	r8,-1
80008eb2:	87 19       	st.w	r3[0x4],r9
80008eb4:	fb 48 06 8c 	st.w	sp[1676],r8
80008eb8:	58 78       	cp.w	r8,7
80008eba:	e0 89 00 05 	brgt	80008ec4 <_vfprintf_r+0x1d10>
80008ebe:	2f 83       	sub	r3,-8
80008ec0:	c0 c8       	rjmp	80008ed8 <_vfprintf_r+0x1d24>
80008ec2:	d7 03       	nop
80008ec4:	fa ca f9 78 	sub	r10,sp,-1672
80008ec8:	02 9b       	mov	r11,r1
80008eca:	08 9c       	mov	r12,r4
80008ecc:	fe b0 f1 66 	rcall	80007198 <__sprint_r>
80008ed0:	e0 81 00 f1 	brne	800090b2 <_vfprintf_r+0x1efe>
80008ed4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ed8:	30 08       	mov	r8,0
80008eda:	30 09       	mov	r9,0
80008edc:	40 5b       	lddsp	r11,sp[0x14]
80008ede:	40 7a       	lddsp	r10,sp[0x1c]
80008ee0:	e0 a0 13 25 	rcall	8000b52a <__avr32_f64_cmp_eq>
80008ee4:	40 68       	lddsp	r8,sp[0x18]
80008ee6:	20 18       	sub	r8,1
80008ee8:	58 0c       	cp.w	r12,0
80008eea:	c0 d1       	brne	80008f04 <_vfprintf_r+0x1d50>
80008eec:	2f f6       	sub	r6,-1
80008eee:	87 18       	st.w	r3[0x4],r8
80008ef0:	87 06       	st.w	r3[0x0],r6
80008ef2:	fa f6 06 90 	ld.w	r6,sp[1680]
80008ef6:	10 06       	add	r6,r8
80008ef8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008efc:	fb 46 06 90 	st.w	sp[1680],r6
80008f00:	2f f8       	sub	r8,-1
80008f02:	c3 18       	rjmp	80008f64 <_vfprintf_r+0x1db0>
80008f04:	10 96       	mov	r6,r8
80008f06:	58 08       	cp.w	r8,0
80008f08:	e0 89 00 1c 	brgt	80008f40 <_vfprintf_r+0x1d8c>
80008f0c:	c4 b8       	rjmp	80008fa2 <_vfprintf_r+0x1dee>
80008f0e:	2f 09       	sub	r9,-16
80008f10:	2f f8       	sub	r8,-1
80008f12:	fb 49 06 90 	st.w	sp[1680],r9
80008f16:	87 02       	st.w	r3[0x0],r2
80008f18:	87 10       	st.w	r3[0x4],r0
80008f1a:	fb 48 06 8c 	st.w	sp[1676],r8
80008f1e:	58 78       	cp.w	r8,7
80008f20:	e0 89 00 04 	brgt	80008f28 <_vfprintf_r+0x1d74>
80008f24:	2f 83       	sub	r3,-8
80008f26:	c0 b8       	rjmp	80008f3c <_vfprintf_r+0x1d88>
80008f28:	fa ca f9 78 	sub	r10,sp,-1672
80008f2c:	02 9b       	mov	r11,r1
80008f2e:	08 9c       	mov	r12,r4
80008f30:	fe b0 f1 34 	rcall	80007198 <__sprint_r>
80008f34:	e0 81 00 bf 	brne	800090b2 <_vfprintf_r+0x1efe>
80008f38:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f3c:	21 06       	sub	r6,16
80008f3e:	c0 48       	rjmp	80008f46 <_vfprintf_r+0x1d92>
80008f40:	fe c2 c1 50 	sub	r2,pc,-16048
80008f44:	31 00       	mov	r0,16
80008f46:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f4e:	fe ca c1 5e 	sub	r10,pc,-16034
80008f52:	59 06       	cp.w	r6,16
80008f54:	fe 99 ff dd 	brgt	80008f0e <_vfprintf_r+0x1d5a>
80008f58:	0c 09       	add	r9,r6
80008f5a:	87 0a       	st.w	r3[0x0],r10
80008f5c:	fb 49 06 90 	st.w	sp[1680],r9
80008f60:	2f f8       	sub	r8,-1
80008f62:	87 16       	st.w	r3[0x4],r6
80008f64:	fb 48 06 8c 	st.w	sp[1676],r8
80008f68:	c0 e8       	rjmp	80008f84 <_vfprintf_r+0x1dd0>
80008f6a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f6e:	2f f8       	sub	r8,-1
80008f70:	30 19       	mov	r9,1
80008f72:	fb 48 06 90 	st.w	sp[1680],r8
80008f76:	87 06       	st.w	r3[0x0],r6
80008f78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f7c:	87 19       	st.w	r3[0x4],r9
80008f7e:	2f f8       	sub	r8,-1
80008f80:	fb 48 06 8c 	st.w	sp[1676],r8
80008f84:	58 78       	cp.w	r8,7
80008f86:	e0 89 00 04 	brgt	80008f8e <_vfprintf_r+0x1dda>
80008f8a:	2f 83       	sub	r3,-8
80008f8c:	c0 b8       	rjmp	80008fa2 <_vfprintf_r+0x1dee>
80008f8e:	fa ca f9 78 	sub	r10,sp,-1672
80008f92:	02 9b       	mov	r11,r1
80008f94:	08 9c       	mov	r12,r4
80008f96:	fe b0 f1 01 	rcall	80007198 <__sprint_r>
80008f9a:	e0 81 00 8c 	brne	800090b2 <_vfprintf_r+0x1efe>
80008f9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fa2:	40 ea       	lddsp	r10,sp[0x38]
80008fa4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fa8:	14 08       	add	r8,r10
80008faa:	fa c9 f9 64 	sub	r9,sp,-1692
80008fae:	fb 48 06 90 	st.w	sp[1680],r8
80008fb2:	87 1a       	st.w	r3[0x4],r10
80008fb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fb8:	87 09       	st.w	r3[0x0],r9
80008fba:	2f f8       	sub	r8,-1
80008fbc:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc0:	58 78       	cp.w	r8,7
80008fc2:	e0 89 00 04 	brgt	80008fca <_vfprintf_r+0x1e16>
80008fc6:	2f 83       	sub	r3,-8
80008fc8:	c0 a8       	rjmp	80008fdc <_vfprintf_r+0x1e28>
80008fca:	fa ca f9 78 	sub	r10,sp,-1672
80008fce:	02 9b       	mov	r11,r1
80008fd0:	08 9c       	mov	r12,r4
80008fd2:	fe b0 f0 e3 	rcall	80007198 <__sprint_r>
80008fd6:	c6 e1       	brne	800090b2 <_vfprintf_r+0x1efe>
80008fd8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fdc:	e2 15 00 04 	andl	r5,0x4,COH
80008fe0:	c3 f0       	breq	8000905e <_vfprintf_r+0x1eaa>
80008fe2:	40 86       	lddsp	r6,sp[0x20]
80008fe4:	40 39       	lddsp	r9,sp[0xc]
80008fe6:	12 16       	sub	r6,r9
80008fe8:	58 06       	cp.w	r6,0
80008fea:	e0 89 00 1a 	brgt	8000901e <_vfprintf_r+0x1e6a>
80008fee:	c3 88       	rjmp	8000905e <_vfprintf_r+0x1eaa>
80008ff0:	2f 09       	sub	r9,-16
80008ff2:	2f f8       	sub	r8,-1
80008ff4:	fb 49 06 90 	st.w	sp[1680],r9
80008ff8:	87 05       	st.w	r3[0x0],r5
80008ffa:	87 12       	st.w	r3[0x4],r2
80008ffc:	fb 48 06 8c 	st.w	sp[1676],r8
80009000:	58 78       	cp.w	r8,7
80009002:	e0 89 00 04 	brgt	8000900a <_vfprintf_r+0x1e56>
80009006:	2f 83       	sub	r3,-8
80009008:	c0 98       	rjmp	8000901a <_vfprintf_r+0x1e66>
8000900a:	00 9a       	mov	r10,r0
8000900c:	02 9b       	mov	r11,r1
8000900e:	08 9c       	mov	r12,r4
80009010:	fe b0 f0 c4 	rcall	80007198 <__sprint_r>
80009014:	c4 f1       	brne	800090b2 <_vfprintf_r+0x1efe>
80009016:	fa c3 f9 e0 	sub	r3,sp,-1568
8000901a:	21 06       	sub	r6,16
8000901c:	c0 68       	rjmp	80009028 <_vfprintf_r+0x1e74>
8000901e:	fe c5 c2 3e 	sub	r5,pc,-15810
80009022:	31 02       	mov	r2,16
80009024:	fa c0 f9 78 	sub	r0,sp,-1672
80009028:	fa f9 06 90 	ld.w	r9,sp[1680]
8000902c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009030:	fe ca c2 50 	sub	r10,pc,-15792
80009034:	59 06       	cp.w	r6,16
80009036:	fe 99 ff dd 	brgt	80008ff0 <_vfprintf_r+0x1e3c>
8000903a:	0c 09       	add	r9,r6
8000903c:	2f f8       	sub	r8,-1
8000903e:	87 0a       	st.w	r3[0x0],r10
80009040:	87 16       	st.w	r3[0x4],r6
80009042:	fb 49 06 90 	st.w	sp[1680],r9
80009046:	fb 48 06 8c 	st.w	sp[1676],r8
8000904a:	58 78       	cp.w	r8,7
8000904c:	e0 8a 00 09 	brle	8000905e <_vfprintf_r+0x1eaa>
80009050:	fa ca f9 78 	sub	r10,sp,-1672
80009054:	02 9b       	mov	r11,r1
80009056:	08 9c       	mov	r12,r4
80009058:	fe b0 f0 a0 	rcall	80007198 <__sprint_r>
8000905c:	c2 b1       	brne	800090b2 <_vfprintf_r+0x1efe>
8000905e:	40 bc       	lddsp	r12,sp[0x2c]
80009060:	40 36       	lddsp	r6,sp[0xc]
80009062:	40 8e       	lddsp	lr,sp[0x20]
80009064:	ec 0e 0c 48 	max	r8,r6,lr
80009068:	10 0c       	add	r12,r8
8000906a:	50 bc       	stdsp	sp[0x2c],r12
8000906c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009070:	58 08       	cp.w	r8,0
80009072:	c0 80       	breq	80009082 <_vfprintf_r+0x1ece>
80009074:	fa ca f9 78 	sub	r10,sp,-1672
80009078:	02 9b       	mov	r11,r1
8000907a:	08 9c       	mov	r12,r4
8000907c:	fe b0 f0 8e 	rcall	80007198 <__sprint_r>
80009080:	c1 91       	brne	800090b2 <_vfprintf_r+0x1efe>
80009082:	30 0b       	mov	r11,0
80009084:	fa c3 f9 e0 	sub	r3,sp,-1568
80009088:	fb 4b 06 8c 	st.w	sp[1676],r11
8000908c:	fe 9f f1 22 	bral	800072d0 <_vfprintf_r+0x11c>
80009090:	08 95       	mov	r5,r4
80009092:	fa f8 06 90 	ld.w	r8,sp[1680]
80009096:	58 08       	cp.w	r8,0
80009098:	c0 80       	breq	800090a8 <_vfprintf_r+0x1ef4>
8000909a:	08 9c       	mov	r12,r4
8000909c:	fa ca f9 78 	sub	r10,sp,-1672
800090a0:	02 9b       	mov	r11,r1
800090a2:	fe b0 f0 7b 	rcall	80007198 <__sprint_r>
800090a6:	c0 61       	brne	800090b2 <_vfprintf_r+0x1efe>
800090a8:	30 08       	mov	r8,0
800090aa:	fb 48 06 8c 	st.w	sp[1676],r8
800090ae:	c0 28       	rjmp	800090b2 <_vfprintf_r+0x1efe>
800090b0:	40 41       	lddsp	r1,sp[0x10]
800090b2:	82 68       	ld.sh	r8,r1[0xc]
800090b4:	ed b8 00 06 	bld	r8,0x6
800090b8:	c0 31       	brne	800090be <_vfprintf_r+0x1f0a>
800090ba:	3f fa       	mov	r10,-1
800090bc:	50 ba       	stdsp	sp[0x2c],r10
800090be:	40 bc       	lddsp	r12,sp[0x2c]
800090c0:	fe 3d f9 44 	sub	sp,-1724
800090c4:	d8 32       	popm	r0-r7,pc
800090c6:	d7 03       	nop

800090c8 <__swsetup_r>:
800090c8:	d4 21       	pushm	r4-r7,lr
800090ca:	e0 68 0a 2c 	mov	r8,2604
800090ce:	18 96       	mov	r6,r12
800090d0:	16 97       	mov	r7,r11
800090d2:	70 0c       	ld.w	r12,r8[0x0]
800090d4:	58 0c       	cp.w	r12,0
800090d6:	c0 60       	breq	800090e2 <__swsetup_r+0x1a>
800090d8:	78 68       	ld.w	r8,r12[0x18]
800090da:	58 08       	cp.w	r8,0
800090dc:	c0 31       	brne	800090e2 <__swsetup_r+0x1a>
800090de:	e0 a0 07 bf 	rcall	8000a05c <__sinit>
800090e2:	fe c8 c1 d2 	sub	r8,pc,-15918
800090e6:	10 37       	cp.w	r7,r8
800090e8:	c0 61       	brne	800090f4 <__swsetup_r+0x2c>
800090ea:	e0 68 0a 2c 	mov	r8,2604
800090ee:	70 08       	ld.w	r8,r8[0x0]
800090f0:	70 07       	ld.w	r7,r8[0x0]
800090f2:	c1 28       	rjmp	80009116 <__swsetup_r+0x4e>
800090f4:	fe c8 c1 c4 	sub	r8,pc,-15932
800090f8:	10 37       	cp.w	r7,r8
800090fa:	c0 61       	brne	80009106 <__swsetup_r+0x3e>
800090fc:	e0 68 0a 2c 	mov	r8,2604
80009100:	70 08       	ld.w	r8,r8[0x0]
80009102:	70 17       	ld.w	r7,r8[0x4]
80009104:	c0 98       	rjmp	80009116 <__swsetup_r+0x4e>
80009106:	fe c8 c1 b6 	sub	r8,pc,-15946
8000910a:	10 37       	cp.w	r7,r8
8000910c:	c0 51       	brne	80009116 <__swsetup_r+0x4e>
8000910e:	e0 68 0a 2c 	mov	r8,2604
80009112:	70 08       	ld.w	r8,r8[0x0]
80009114:	70 27       	ld.w	r7,r8[0x8]
80009116:	8e 68       	ld.sh	r8,r7[0xc]
80009118:	ed b8 00 03 	bld	r8,0x3
8000911c:	c1 e0       	breq	80009158 <__swsetup_r+0x90>
8000911e:	ed b8 00 04 	bld	r8,0x4
80009122:	c3 e1       	brne	8000919e <__swsetup_r+0xd6>
80009124:	ed b8 00 02 	bld	r8,0x2
80009128:	c1 51       	brne	80009152 <__swsetup_r+0x8a>
8000912a:	6e db       	ld.w	r11,r7[0x34]
8000912c:	58 0b       	cp.w	r11,0
8000912e:	c0 a0       	breq	80009142 <__swsetup_r+0x7a>
80009130:	ee c8 ff bc 	sub	r8,r7,-68
80009134:	10 3b       	cp.w	r11,r8
80009136:	c0 40       	breq	8000913e <__swsetup_r+0x76>
80009138:	0c 9c       	mov	r12,r6
8000913a:	e0 a0 08 2b 	rcall	8000a190 <_free_r>
8000913e:	30 08       	mov	r8,0
80009140:	8f d8       	st.w	r7[0x34],r8
80009142:	8e 68       	ld.sh	r8,r7[0xc]
80009144:	e0 18 ff db 	andl	r8,0xffdb
80009148:	ae 68       	st.h	r7[0xc],r8
8000914a:	30 08       	mov	r8,0
8000914c:	8f 18       	st.w	r7[0x4],r8
8000914e:	6e 48       	ld.w	r8,r7[0x10]
80009150:	8f 08       	st.w	r7[0x0],r8
80009152:	8e 68       	ld.sh	r8,r7[0xc]
80009154:	a3 b8       	sbr	r8,0x3
80009156:	ae 68       	st.h	r7[0xc],r8
80009158:	6e 48       	ld.w	r8,r7[0x10]
8000915a:	58 08       	cp.w	r8,0
8000915c:	c0 b1       	brne	80009172 <__swsetup_r+0xaa>
8000915e:	8e 68       	ld.sh	r8,r7[0xc]
80009160:	e2 18 02 80 	andl	r8,0x280,COH
80009164:	e0 48 02 00 	cp.w	r8,512
80009168:	c0 50       	breq	80009172 <__swsetup_r+0xaa>
8000916a:	0c 9c       	mov	r12,r6
8000916c:	0e 9b       	mov	r11,r7
8000916e:	e0 a0 0a 4b 	rcall	8000a604 <__smakebuf_r>
80009172:	8e 69       	ld.sh	r9,r7[0xc]
80009174:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009178:	c0 70       	breq	80009186 <__swsetup_r+0xbe>
8000917a:	30 08       	mov	r8,0
8000917c:	8f 28       	st.w	r7[0x8],r8
8000917e:	6e 58       	ld.w	r8,r7[0x14]
80009180:	5c 38       	neg	r8
80009182:	8f 68       	st.w	r7[0x18],r8
80009184:	c0 68       	rjmp	80009190 <__swsetup_r+0xc8>
80009186:	ed b9 00 01 	bld	r9,0x1
8000918a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000918e:	8f 28       	st.w	r7[0x8],r8
80009190:	6e 48       	ld.w	r8,r7[0x10]
80009192:	58 08       	cp.w	r8,0
80009194:	c0 61       	brne	800091a0 <__swsetup_r+0xd8>
80009196:	8e 68       	ld.sh	r8,r7[0xc]
80009198:	ed b8 00 07 	bld	r8,0x7
8000919c:	c0 21       	brne	800091a0 <__swsetup_r+0xd8>
8000919e:	dc 2a       	popm	r4-r7,pc,r12=-1
800091a0:	d8 2a       	popm	r4-r7,pc,r12=0
800091a2:	d7 03       	nop

800091a4 <quorem>:
800091a4:	d4 31       	pushm	r0-r7,lr
800091a6:	20 2d       	sub	sp,8
800091a8:	18 97       	mov	r7,r12
800091aa:	78 48       	ld.w	r8,r12[0x10]
800091ac:	76 46       	ld.w	r6,r11[0x10]
800091ae:	0c 38       	cp.w	r8,r6
800091b0:	c0 34       	brge	800091b6 <quorem+0x12>
800091b2:	30 0c       	mov	r12,0
800091b4:	c8 58       	rjmp	800092be <quorem+0x11a>
800091b6:	ec c2 ff fc 	sub	r2,r6,-4
800091ba:	f6 c3 ff ec 	sub	r3,r11,-20
800091be:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800091c2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800091c6:	2f f9       	sub	r9,-1
800091c8:	20 16       	sub	r6,1
800091ca:	f8 09 0d 08 	divu	r8,r12,r9
800091ce:	f6 02 00 22 	add	r2,r11,r2<<0x2
800091d2:	ee c4 ff ec 	sub	r4,r7,-20
800091d6:	10 95       	mov	r5,r8
800091d8:	58 08       	cp.w	r8,0
800091da:	c4 10       	breq	8000925c <quorem+0xb8>
800091dc:	30 09       	mov	r9,0
800091de:	06 9a       	mov	r10,r3
800091e0:	08 98       	mov	r8,r4
800091e2:	12 91       	mov	r1,r9
800091e4:	50 0b       	stdsp	sp[0x0],r11
800091e6:	70 0e       	ld.w	lr,r8[0x0]
800091e8:	b1 8e       	lsr	lr,0x10
800091ea:	50 1e       	stdsp	sp[0x4],lr
800091ec:	15 0e       	ld.w	lr,r10++
800091ee:	fc 00 16 10 	lsr	r0,lr,0x10
800091f2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800091f6:	ea 0e 03 41 	mac	r1,r5,lr
800091fa:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800091fe:	b1 81       	lsr	r1,0x10
80009200:	40 1b       	lddsp	r11,sp[0x4]
80009202:	ea 00 02 40 	mul	r0,r5,r0
80009206:	e2 00 00 00 	add	r0,r1,r0
8000920a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000920e:	02 1b       	sub	r11,r1
80009210:	50 1b       	stdsp	sp[0x4],r11
80009212:	70 0b       	ld.w	r11,r8[0x0]
80009214:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009218:	02 09       	add	r9,r1
8000921a:	f2 0e 01 0e 	sub	lr,r9,lr
8000921e:	b0 1e       	st.h	r8[0x2],lr
80009220:	fc 09 14 10 	asr	r9,lr,0x10
80009224:	40 1e       	lddsp	lr,sp[0x4]
80009226:	fc 09 00 09 	add	r9,lr,r9
8000922a:	b0 09       	st.h	r8[0x0],r9
8000922c:	e0 01 16 10 	lsr	r1,r0,0x10
80009230:	2f c8       	sub	r8,-4
80009232:	b1 49       	asr	r9,0x10
80009234:	04 3a       	cp.w	r10,r2
80009236:	fe 98 ff d8 	brls	800091e6 <quorem+0x42>
8000923a:	40 0b       	lddsp	r11,sp[0x0]
8000923c:	58 0c       	cp.w	r12,0
8000923e:	c0 f1       	brne	8000925c <quorem+0xb8>
80009240:	ec c8 ff fb 	sub	r8,r6,-5
80009244:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009248:	c0 28       	rjmp	8000924c <quorem+0xa8>
8000924a:	20 16       	sub	r6,1
8000924c:	20 48       	sub	r8,4
8000924e:	08 38       	cp.w	r8,r4
80009250:	e0 88 00 05 	brls	8000925a <quorem+0xb6>
80009254:	70 09       	ld.w	r9,r8[0x0]
80009256:	58 09       	cp.w	r9,0
80009258:	cf 90       	breq	8000924a <quorem+0xa6>
8000925a:	8f 46       	st.w	r7[0x10],r6
8000925c:	0e 9c       	mov	r12,r7
8000925e:	e0 a0 0a d2 	rcall	8000a802 <__mcmp>
80009262:	c2 d5       	brlt	800092bc <quorem+0x118>
80009264:	2f f5       	sub	r5,-1
80009266:	08 98       	mov	r8,r4
80009268:	30 09       	mov	r9,0
8000926a:	07 0b       	ld.w	r11,r3++
8000926c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009270:	70 0c       	ld.w	r12,r8[0x0]
80009272:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009276:	f8 0e 16 10 	lsr	lr,r12,0x10
8000927a:	14 1e       	sub	lr,r10
8000927c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009280:	16 1a       	sub	r10,r11
80009282:	12 0a       	add	r10,r9
80009284:	b0 1a       	st.h	r8[0x2],r10
80009286:	b1 4a       	asr	r10,0x10
80009288:	fc 0a 00 09 	add	r9,lr,r10
8000928c:	b0 09       	st.h	r8[0x0],r9
8000928e:	2f c8       	sub	r8,-4
80009290:	b1 49       	asr	r9,0x10
80009292:	04 33       	cp.w	r3,r2
80009294:	fe 98 ff eb 	brls	8000926a <quorem+0xc6>
80009298:	ec c8 ff fb 	sub	r8,r6,-5
8000929c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800092a0:	58 09       	cp.w	r9,0
800092a2:	c0 d1       	brne	800092bc <quorem+0x118>
800092a4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800092a8:	c0 28       	rjmp	800092ac <quorem+0x108>
800092aa:	20 16       	sub	r6,1
800092ac:	20 48       	sub	r8,4
800092ae:	08 38       	cp.w	r8,r4
800092b0:	e0 88 00 05 	brls	800092ba <quorem+0x116>
800092b4:	70 09       	ld.w	r9,r8[0x0]
800092b6:	58 09       	cp.w	r9,0
800092b8:	cf 90       	breq	800092aa <quorem+0x106>
800092ba:	8f 46       	st.w	r7[0x10],r6
800092bc:	0a 9c       	mov	r12,r5
800092be:	2f ed       	sub	sp,-8
800092c0:	d8 32       	popm	r0-r7,pc
800092c2:	d7 03       	nop

800092c4 <_dtoa_r>:
800092c4:	d4 31       	pushm	r0-r7,lr
800092c6:	21 ad       	sub	sp,104
800092c8:	fa c4 ff 74 	sub	r4,sp,-140
800092cc:	18 97       	mov	r7,r12
800092ce:	16 95       	mov	r5,r11
800092d0:	68 2c       	ld.w	r12,r4[0x8]
800092d2:	50 c9       	stdsp	sp[0x30],r9
800092d4:	68 16       	ld.w	r6,r4[0x4]
800092d6:	68 09       	ld.w	r9,r4[0x0]
800092d8:	50 e8       	stdsp	sp[0x38],r8
800092da:	14 94       	mov	r4,r10
800092dc:	51 2c       	stdsp	sp[0x48],r12
800092de:	fa e5 00 08 	st.d	sp[8],r4
800092e2:	51 59       	stdsp	sp[0x54],r9
800092e4:	6e 95       	ld.w	r5,r7[0x24]
800092e6:	58 05       	cp.w	r5,0
800092e8:	c0 91       	brne	800092fa <_dtoa_r+0x36>
800092ea:	31 0c       	mov	r12,16
800092ec:	fe b0 e8 f4 	rcall	800064d4 <malloc>
800092f0:	99 35       	st.w	r12[0xc],r5
800092f2:	8f 9c       	st.w	r7[0x24],r12
800092f4:	99 15       	st.w	r12[0x4],r5
800092f6:	99 25       	st.w	r12[0x8],r5
800092f8:	99 05       	st.w	r12[0x0],r5
800092fa:	6e 99       	ld.w	r9,r7[0x24]
800092fc:	72 08       	ld.w	r8,r9[0x0]
800092fe:	58 08       	cp.w	r8,0
80009300:	c0 f0       	breq	8000931e <_dtoa_r+0x5a>
80009302:	72 1a       	ld.w	r10,r9[0x4]
80009304:	91 1a       	st.w	r8[0x4],r10
80009306:	30 1a       	mov	r10,1
80009308:	72 19       	ld.w	r9,r9[0x4]
8000930a:	f4 09 09 49 	lsl	r9,r10,r9
8000930e:	10 9b       	mov	r11,r8
80009310:	91 29       	st.w	r8[0x8],r9
80009312:	0e 9c       	mov	r12,r7
80009314:	e0 a0 0a 90 	rcall	8000a834 <_Bfree>
80009318:	6e 98       	ld.w	r8,r7[0x24]
8000931a:	30 09       	mov	r9,0
8000931c:	91 09       	st.w	r8[0x0],r9
8000931e:	40 28       	lddsp	r8,sp[0x8]
80009320:	10 94       	mov	r4,r8
80009322:	58 08       	cp.w	r8,0
80009324:	c0 64       	brge	80009330 <_dtoa_r+0x6c>
80009326:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000932a:	50 28       	stdsp	sp[0x8],r8
8000932c:	30 18       	mov	r8,1
8000932e:	c0 28       	rjmp	80009332 <_dtoa_r+0x6e>
80009330:	30 08       	mov	r8,0
80009332:	8d 08       	st.w	r6[0x0],r8
80009334:	fc 1c 7f f0 	movh	r12,0x7ff0
80009338:	40 26       	lddsp	r6,sp[0x8]
8000933a:	0c 98       	mov	r8,r6
8000933c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009340:	18 38       	cp.w	r8,r12
80009342:	c2 01       	brne	80009382 <_dtoa_r+0xbe>
80009344:	e0 68 27 0f 	mov	r8,9999
80009348:	41 5b       	lddsp	r11,sp[0x54]
8000934a:	97 08       	st.w	r11[0x0],r8
8000934c:	40 3a       	lddsp	r10,sp[0xc]
8000934e:	58 0a       	cp.w	r10,0
80009350:	c0 71       	brne	8000935e <_dtoa_r+0x9a>
80009352:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009356:	c0 41       	brne	8000935e <_dtoa_r+0x9a>
80009358:	fe cc c4 58 	sub	r12,pc,-15272
8000935c:	c0 38       	rjmp	80009362 <_dtoa_r+0x9e>
8000935e:	fe cc c4 52 	sub	r12,pc,-15278
80009362:	41 29       	lddsp	r9,sp[0x48]
80009364:	58 09       	cp.w	r9,0
80009366:	e0 80 05 9a 	breq	80009e9a <_dtoa_r+0xbd6>
8000936a:	f8 c8 ff fd 	sub	r8,r12,-3
8000936e:	f8 c9 ff f8 	sub	r9,r12,-8
80009372:	11 8b       	ld.ub	r11,r8[0x0]
80009374:	30 0a       	mov	r10,0
80009376:	41 25       	lddsp	r5,sp[0x48]
80009378:	f4 0b 18 00 	cp.b	r11,r10
8000937c:	f2 08 17 10 	movne	r8,r9
80009380:	c1 68       	rjmp	800093ac <_dtoa_r+0xe8>
80009382:	fa ea 00 08 	ld.d	r10,sp[8]
80009386:	30 08       	mov	r8,0
80009388:	fa eb 00 3c 	st.d	sp[60],r10
8000938c:	30 09       	mov	r9,0
8000938e:	e0 a0 10 ce 	rcall	8000b52a <__avr32_f64_cmp_eq>
80009392:	c1 00       	breq	800093b2 <_dtoa_r+0xee>
80009394:	30 18       	mov	r8,1
80009396:	41 5a       	lddsp	r10,sp[0x54]
80009398:	95 08       	st.w	r10[0x0],r8
8000939a:	fe cc c5 be 	sub	r12,pc,-14914
8000939e:	41 29       	lddsp	r9,sp[0x48]
800093a0:	f8 08 00 08 	add	r8,r12,r8
800093a4:	58 09       	cp.w	r9,0
800093a6:	e0 80 05 7a 	breq	80009e9a <_dtoa_r+0xbd6>
800093aa:	12 95       	mov	r5,r9
800093ac:	8b 08       	st.w	r5[0x0],r8
800093ae:	e0 8f 05 76 	bral	80009e9a <_dtoa_r+0xbd6>
800093b2:	fa c8 ff 9c 	sub	r8,sp,-100
800093b6:	fa c9 ff a0 	sub	r9,sp,-96
800093ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800093be:	0e 9c       	mov	r12,r7
800093c0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800093c4:	e0 a0 0a 8a 	rcall	8000a8d8 <__d2b>
800093c8:	18 93       	mov	r3,r12
800093ca:	58 05       	cp.w	r5,0
800093cc:	c0 d0       	breq	800093e6 <_dtoa_r+0x122>
800093ce:	fa ea 00 3c 	ld.d	r10,sp[60]
800093d2:	30 04       	mov	r4,0
800093d4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800093d8:	ea c5 03 ff 	sub	r5,r5,1023
800093dc:	10 9b       	mov	r11,r8
800093de:	51 74       	stdsp	sp[0x5c],r4
800093e0:	ea 1b 3f f0 	orh	r11,0x3ff0
800093e4:	c2 58       	rjmp	8000942e <_dtoa_r+0x16a>
800093e6:	41 88       	lddsp	r8,sp[0x60]
800093e8:	41 9c       	lddsp	r12,sp[0x64]
800093ea:	10 0c       	add	r12,r8
800093ec:	f8 c5 fb ce 	sub	r5,r12,-1074
800093f0:	e0 45 00 20 	cp.w	r5,32
800093f4:	e0 8a 00 0e 	brle	80009410 <_dtoa_r+0x14c>
800093f8:	f8 cc fb ee 	sub	r12,r12,-1042
800093fc:	40 3b       	lddsp	r11,sp[0xc]
800093fe:	ea 08 11 40 	rsub	r8,r5,64
80009402:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009406:	ec 08 09 46 	lsl	r6,r6,r8
8000940a:	0c 4c       	or	r12,r6
8000940c:	c0 78       	rjmp	8000941a <_dtoa_r+0x156>
8000940e:	d7 03       	nop
80009410:	ea 0c 11 20 	rsub	r12,r5,32
80009414:	40 3a       	lddsp	r10,sp[0xc]
80009416:	f4 0c 09 4c 	lsl	r12,r10,r12
8000941a:	e0 a0 10 14 	rcall	8000b442 <__avr32_u32_to_f64>
8000941e:	fc 18 fe 10 	movh	r8,0xfe10
80009422:	30 19       	mov	r9,1
80009424:	ea c5 04 33 	sub	r5,r5,1075
80009428:	f0 0b 00 0b 	add	r11,r8,r11
8000942c:	51 79       	stdsp	sp[0x5c],r9
8000942e:	30 08       	mov	r8,0
80009430:	fc 19 3f f8 	movh	r9,0x3ff8
80009434:	e0 a0 0e 9c 	rcall	8000b16c <__avr32_f64_sub>
80009438:	e0 68 43 61 	mov	r8,17249
8000943c:	ea 18 63 6f 	orh	r8,0x636f
80009440:	e0 69 87 a7 	mov	r9,34727
80009444:	ea 19 3f d2 	orh	r9,0x3fd2
80009448:	e0 a0 0d a6 	rcall	8000af94 <__avr32_f64_mul>
8000944c:	e0 68 c8 b3 	mov	r8,51379
80009450:	ea 18 8b 60 	orh	r8,0x8b60
80009454:	e0 69 8a 28 	mov	r9,35368
80009458:	ea 19 3f c6 	orh	r9,0x3fc6
8000945c:	e0 a0 0f 56 	rcall	8000b308 <__avr32_f64_add>
80009460:	0a 9c       	mov	r12,r5
80009462:	14 90       	mov	r0,r10
80009464:	16 91       	mov	r1,r11
80009466:	e0 a0 0f f2 	rcall	8000b44a <__avr32_s32_to_f64>
8000946a:	e0 68 79 fb 	mov	r8,31227
8000946e:	ea 18 50 9f 	orh	r8,0x509f
80009472:	e0 69 44 13 	mov	r9,17427
80009476:	ea 19 3f d3 	orh	r9,0x3fd3
8000947a:	e0 a0 0d 8d 	rcall	8000af94 <__avr32_f64_mul>
8000947e:	14 98       	mov	r8,r10
80009480:	16 99       	mov	r9,r11
80009482:	00 9a       	mov	r10,r0
80009484:	02 9b       	mov	r11,r1
80009486:	e0 a0 0f 41 	rcall	8000b308 <__avr32_f64_add>
8000948a:	14 90       	mov	r0,r10
8000948c:	16 91       	mov	r1,r11
8000948e:	e0 a0 0f c7 	rcall	8000b41c <__avr32_f64_to_s32>
80009492:	30 08       	mov	r8,0
80009494:	18 96       	mov	r6,r12
80009496:	30 09       	mov	r9,0
80009498:	00 9a       	mov	r10,r0
8000949a:	02 9b       	mov	r11,r1
8000949c:	e0 a0 10 8e 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800094a0:	c0 c0       	breq	800094b8 <_dtoa_r+0x1f4>
800094a2:	0c 9c       	mov	r12,r6
800094a4:	e0 a0 0f d3 	rcall	8000b44a <__avr32_s32_to_f64>
800094a8:	14 98       	mov	r8,r10
800094aa:	16 99       	mov	r9,r11
800094ac:	00 9a       	mov	r10,r0
800094ae:	02 9b       	mov	r11,r1
800094b0:	e0 a0 10 3d 	rcall	8000b52a <__avr32_f64_cmp_eq>
800094b4:	f7 b6 00 01 	subeq	r6,1
800094b8:	59 66       	cp.w	r6,22
800094ba:	e0 88 00 05 	brls	800094c4 <_dtoa_r+0x200>
800094be:	30 18       	mov	r8,1
800094c0:	51 48       	stdsp	sp[0x50],r8
800094c2:	c1 38       	rjmp	800094e8 <_dtoa_r+0x224>
800094c4:	fe c8 c5 04 	sub	r8,pc,-15100
800094c8:	fa ea 00 3c 	ld.d	r10,sp[60]
800094cc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800094d0:	e0 a0 10 74 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800094d4:	f9 b4 00 00 	moveq	r4,0
800094d8:	fb f4 0a 14 	st.weq	sp[0x50],r4
800094dc:	f7 b6 01 01 	subne	r6,1
800094e0:	f9 bc 01 00 	movne	r12,0
800094e4:	fb fc 1a 14 	st.wne	sp[0x50],r12
800094e8:	41 90       	lddsp	r0,sp[0x64]
800094ea:	20 10       	sub	r0,1
800094ec:	0a 10       	sub	r0,r5
800094ee:	c0 46       	brmi	800094f6 <_dtoa_r+0x232>
800094f0:	50 40       	stdsp	sp[0x10],r0
800094f2:	30 00       	mov	r0,0
800094f4:	c0 48       	rjmp	800094fc <_dtoa_r+0x238>
800094f6:	30 0b       	mov	r11,0
800094f8:	5c 30       	neg	r0
800094fa:	50 4b       	stdsp	sp[0x10],r11
800094fc:	ec 02 11 00 	rsub	r2,r6,0
80009500:	58 06       	cp.w	r6,0
80009502:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009506:	f5 d6 e4 0a 	addge	r10,r10,r6
8000950a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000950e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009512:	f9 b2 04 00 	movge	r2,0
80009516:	e1 d6 e5 10 	sublt	r0,r0,r6
8000951a:	f9 b9 05 00 	movlt	r9,0
8000951e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009522:	40 c8       	lddsp	r8,sp[0x30]
80009524:	58 98       	cp.w	r8,9
80009526:	e0 8b 00 20 	brhi	80009566 <_dtoa_r+0x2a2>
8000952a:	58 58       	cp.w	r8,5
8000952c:	f9 b4 0a 01 	movle	r4,1
80009530:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009534:	f7 b5 09 04 	subgt	r5,4
80009538:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000953c:	f9 b4 09 00 	movgt	r4,0
80009540:	40 cc       	lddsp	r12,sp[0x30]
80009542:	58 3c       	cp.w	r12,3
80009544:	c2 d0       	breq	8000959e <_dtoa_r+0x2da>
80009546:	e0 89 00 05 	brgt	80009550 <_dtoa_r+0x28c>
8000954a:	58 2c       	cp.w	r12,2
8000954c:	c1 01       	brne	8000956c <_dtoa_r+0x2a8>
8000954e:	c1 88       	rjmp	8000957e <_dtoa_r+0x2ba>
80009550:	40 cb       	lddsp	r11,sp[0x30]
80009552:	58 4b       	cp.w	r11,4
80009554:	c0 60       	breq	80009560 <_dtoa_r+0x29c>
80009556:	58 5b       	cp.w	r11,5
80009558:	c0 a1       	brne	8000956c <_dtoa_r+0x2a8>
8000955a:	30 1a       	mov	r10,1
8000955c:	50 da       	stdsp	sp[0x34],r10
8000955e:	c2 28       	rjmp	800095a2 <_dtoa_r+0x2de>
80009560:	30 19       	mov	r9,1
80009562:	50 d9       	stdsp	sp[0x34],r9
80009564:	c0 f8       	rjmp	80009582 <_dtoa_r+0x2be>
80009566:	30 08       	mov	r8,0
80009568:	30 14       	mov	r4,1
8000956a:	50 c8       	stdsp	sp[0x30],r8
8000956c:	3f f5       	mov	r5,-1
8000956e:	30 1c       	mov	r12,1
80009570:	30 0b       	mov	r11,0
80009572:	50 95       	stdsp	sp[0x24],r5
80009574:	50 dc       	stdsp	sp[0x34],r12
80009576:	0a 91       	mov	r1,r5
80009578:	31 28       	mov	r8,18
8000957a:	50 eb       	stdsp	sp[0x38],r11
8000957c:	c2 08       	rjmp	800095bc <_dtoa_r+0x2f8>
8000957e:	30 0a       	mov	r10,0
80009580:	50 da       	stdsp	sp[0x34],r10
80009582:	40 e9       	lddsp	r9,sp[0x38]
80009584:	58 09       	cp.w	r9,0
80009586:	e0 89 00 07 	brgt	80009594 <_dtoa_r+0x2d0>
8000958a:	30 18       	mov	r8,1
8000958c:	50 98       	stdsp	sp[0x24],r8
8000958e:	10 91       	mov	r1,r8
80009590:	50 e8       	stdsp	sp[0x38],r8
80009592:	c1 58       	rjmp	800095bc <_dtoa_r+0x2f8>
80009594:	40 e5       	lddsp	r5,sp[0x38]
80009596:	50 95       	stdsp	sp[0x24],r5
80009598:	0a 91       	mov	r1,r5
8000959a:	0a 98       	mov	r8,r5
8000959c:	c1 08       	rjmp	800095bc <_dtoa_r+0x2f8>
8000959e:	30 0c       	mov	r12,0
800095a0:	50 dc       	stdsp	sp[0x34],r12
800095a2:	40 eb       	lddsp	r11,sp[0x38]
800095a4:	ec 0b 00 0b 	add	r11,r6,r11
800095a8:	50 9b       	stdsp	sp[0x24],r11
800095aa:	16 98       	mov	r8,r11
800095ac:	2f f8       	sub	r8,-1
800095ae:	58 08       	cp.w	r8,0
800095b0:	e0 89 00 05 	brgt	800095ba <_dtoa_r+0x2f6>
800095b4:	10 91       	mov	r1,r8
800095b6:	30 18       	mov	r8,1
800095b8:	c0 28       	rjmp	800095bc <_dtoa_r+0x2f8>
800095ba:	10 91       	mov	r1,r8
800095bc:	30 09       	mov	r9,0
800095be:	6e 9a       	ld.w	r10,r7[0x24]
800095c0:	95 19       	st.w	r10[0x4],r9
800095c2:	30 49       	mov	r9,4
800095c4:	c0 68       	rjmp	800095d0 <_dtoa_r+0x30c>
800095c6:	d7 03       	nop
800095c8:	6a 1a       	ld.w	r10,r5[0x4]
800095ca:	a1 79       	lsl	r9,0x1
800095cc:	2f fa       	sub	r10,-1
800095ce:	8b 1a       	st.w	r5[0x4],r10
800095d0:	6e 95       	ld.w	r5,r7[0x24]
800095d2:	f2 ca ff ec 	sub	r10,r9,-20
800095d6:	10 3a       	cp.w	r10,r8
800095d8:	fe 98 ff f8 	brls	800095c8 <_dtoa_r+0x304>
800095dc:	6a 1b       	ld.w	r11,r5[0x4]
800095de:	0e 9c       	mov	r12,r7
800095e0:	e0 a0 09 44 	rcall	8000a868 <_Balloc>
800095e4:	58 e1       	cp.w	r1,14
800095e6:	5f 88       	srls	r8
800095e8:	8b 0c       	st.w	r5[0x0],r12
800095ea:	f1 e4 00 04 	and	r4,r8,r4
800095ee:	6e 98       	ld.w	r8,r7[0x24]
800095f0:	70 08       	ld.w	r8,r8[0x0]
800095f2:	50 88       	stdsp	sp[0x20],r8
800095f4:	e0 80 01 82 	breq	800098f8 <_dtoa_r+0x634>
800095f8:	58 06       	cp.w	r6,0
800095fa:	e0 8a 00 43 	brle	80009680 <_dtoa_r+0x3bc>
800095fe:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009602:	fe c8 c6 42 	sub	r8,pc,-14782
80009606:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000960a:	fa e5 00 18 	st.d	sp[24],r4
8000960e:	ec 04 14 04 	asr	r4,r6,0x4
80009612:	ed b4 00 04 	bld	r4,0x4
80009616:	c0 30       	breq	8000961c <_dtoa_r+0x358>
80009618:	30 25       	mov	r5,2
8000961a:	c1 08       	rjmp	8000963a <_dtoa_r+0x376>
8000961c:	fe c8 c5 94 	sub	r8,pc,-14956
80009620:	f0 e8 00 20 	ld.d	r8,r8[32]
80009624:	fa ea 00 3c 	ld.d	r10,sp[60]
80009628:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000962c:	e0 a0 0f fa 	rcall	8000b620 <__avr32_f64_div>
80009630:	30 35       	mov	r5,3
80009632:	14 98       	mov	r8,r10
80009634:	16 99       	mov	r9,r11
80009636:	fa e9 00 08 	st.d	sp[8],r8
8000963a:	fe cc c5 b2 	sub	r12,pc,-14926
8000963e:	50 a3       	stdsp	sp[0x28],r3
80009640:	0c 93       	mov	r3,r6
80009642:	18 96       	mov	r6,r12
80009644:	c0 f8       	rjmp	80009662 <_dtoa_r+0x39e>
80009646:	fa ea 00 18 	ld.d	r10,sp[24]
8000964a:	ed b4 00 00 	bld	r4,0x0
8000964e:	c0 81       	brne	8000965e <_dtoa_r+0x39a>
80009650:	ec e8 00 00 	ld.d	r8,r6[0]
80009654:	2f f5       	sub	r5,-1
80009656:	e0 a0 0c 9f 	rcall	8000af94 <__avr32_f64_mul>
8000965a:	fa eb 00 18 	st.d	sp[24],r10
8000965e:	a1 54       	asr	r4,0x1
80009660:	2f 86       	sub	r6,-8
80009662:	58 04       	cp.w	r4,0
80009664:	cf 11       	brne	80009646 <_dtoa_r+0x382>
80009666:	fa e8 00 18 	ld.d	r8,sp[24]
8000966a:	fa ea 00 08 	ld.d	r10,sp[8]
8000966e:	06 96       	mov	r6,r3
80009670:	e0 a0 0f d8 	rcall	8000b620 <__avr32_f64_div>
80009674:	40 a3       	lddsp	r3,sp[0x28]
80009676:	14 98       	mov	r8,r10
80009678:	16 99       	mov	r9,r11
8000967a:	fa e9 00 08 	st.d	sp[8],r8
8000967e:	c2 f8       	rjmp	800096dc <_dtoa_r+0x418>
80009680:	ec 08 11 00 	rsub	r8,r6,0
80009684:	c0 31       	brne	8000968a <_dtoa_r+0x3c6>
80009686:	30 25       	mov	r5,2
80009688:	c2 a8       	rjmp	800096dc <_dtoa_r+0x418>
8000968a:	fe cc c6 02 	sub	r12,pc,-14846
8000968e:	f0 04 14 04 	asr	r4,r8,0x4
80009692:	50 1c       	stdsp	sp[0x4],r12
80009694:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009698:	fe c9 c6 d8 	sub	r9,pc,-14632
8000969c:	fa ea 00 3c 	ld.d	r10,sp[60]
800096a0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800096a4:	e0 a0 0c 78 	rcall	8000af94 <__avr32_f64_mul>
800096a8:	40 1c       	lddsp	r12,sp[0x4]
800096aa:	50 63       	stdsp	sp[0x18],r3
800096ac:	30 25       	mov	r5,2
800096ae:	0c 93       	mov	r3,r6
800096b0:	fa eb 00 08 	st.d	sp[8],r10
800096b4:	18 96       	mov	r6,r12
800096b6:	c0 f8       	rjmp	800096d4 <_dtoa_r+0x410>
800096b8:	fa ea 00 08 	ld.d	r10,sp[8]
800096bc:	ed b4 00 00 	bld	r4,0x0
800096c0:	c0 81       	brne	800096d0 <_dtoa_r+0x40c>
800096c2:	ec e8 00 00 	ld.d	r8,r6[0]
800096c6:	2f f5       	sub	r5,-1
800096c8:	e0 a0 0c 66 	rcall	8000af94 <__avr32_f64_mul>
800096cc:	fa eb 00 08 	st.d	sp[8],r10
800096d0:	a1 54       	asr	r4,0x1
800096d2:	2f 86       	sub	r6,-8
800096d4:	58 04       	cp.w	r4,0
800096d6:	cf 11       	brne	800096b8 <_dtoa_r+0x3f4>
800096d8:	06 96       	mov	r6,r3
800096da:	40 63       	lddsp	r3,sp[0x18]
800096dc:	41 4a       	lddsp	r10,sp[0x50]
800096de:	58 0a       	cp.w	r10,0
800096e0:	c2 a0       	breq	80009734 <_dtoa_r+0x470>
800096e2:	fa e8 00 08 	ld.d	r8,sp[8]
800096e6:	58 01       	cp.w	r1,0
800096e8:	5f 94       	srgt	r4
800096ea:	fa e9 00 18 	st.d	sp[24],r8
800096ee:	30 08       	mov	r8,0
800096f0:	fc 19 3f f0 	movh	r9,0x3ff0
800096f4:	fa ea 00 18 	ld.d	r10,sp[24]
800096f8:	e0 a0 0f 60 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800096fc:	f9 bc 00 00 	moveq	r12,0
80009700:	f9 bc 01 01 	movne	r12,1
80009704:	e9 ec 00 0c 	and	r12,r4,r12
80009708:	c1 60       	breq	80009734 <_dtoa_r+0x470>
8000970a:	40 98       	lddsp	r8,sp[0x24]
8000970c:	58 08       	cp.w	r8,0
8000970e:	e0 8a 00 f1 	brle	800098f0 <_dtoa_r+0x62c>
80009712:	30 08       	mov	r8,0
80009714:	fc 19 40 24 	movh	r9,0x4024
80009718:	ec c4 00 01 	sub	r4,r6,1
8000971c:	fa ea 00 18 	ld.d	r10,sp[24]
80009720:	2f f5       	sub	r5,-1
80009722:	50 64       	stdsp	sp[0x18],r4
80009724:	e0 a0 0c 38 	rcall	8000af94 <__avr32_f64_mul>
80009728:	40 94       	lddsp	r4,sp[0x24]
8000972a:	14 98       	mov	r8,r10
8000972c:	16 99       	mov	r9,r11
8000972e:	fa e9 00 08 	st.d	sp[8],r8
80009732:	c0 38       	rjmp	80009738 <_dtoa_r+0x474>
80009734:	50 66       	stdsp	sp[0x18],r6
80009736:	02 94       	mov	r4,r1
80009738:	0a 9c       	mov	r12,r5
8000973a:	e0 a0 0e 88 	rcall	8000b44a <__avr32_s32_to_f64>
8000973e:	fa e8 00 08 	ld.d	r8,sp[8]
80009742:	e0 a0 0c 29 	rcall	8000af94 <__avr32_f64_mul>
80009746:	30 08       	mov	r8,0
80009748:	fc 19 40 1c 	movh	r9,0x401c
8000974c:	e0 a0 0d de 	rcall	8000b308 <__avr32_f64_add>
80009750:	14 98       	mov	r8,r10
80009752:	16 99       	mov	r9,r11
80009754:	fa e9 00 28 	st.d	sp[40],r8
80009758:	fc 18 fc c0 	movh	r8,0xfcc0
8000975c:	40 a5       	lddsp	r5,sp[0x28]
8000975e:	10 05       	add	r5,r8
80009760:	50 a5       	stdsp	sp[0x28],r5
80009762:	58 04       	cp.w	r4,0
80009764:	c2 11       	brne	800097a6 <_dtoa_r+0x4e2>
80009766:	fa ea 00 08 	ld.d	r10,sp[8]
8000976a:	30 08       	mov	r8,0
8000976c:	fc 19 40 14 	movh	r9,0x4014
80009770:	e0 a0 0c fe 	rcall	8000b16c <__avr32_f64_sub>
80009774:	40 bc       	lddsp	r12,sp[0x2c]
80009776:	fa eb 00 08 	st.d	sp[8],r10
8000977a:	14 98       	mov	r8,r10
8000977c:	16 99       	mov	r9,r11
8000977e:	18 9a       	mov	r10,r12
80009780:	0a 9b       	mov	r11,r5
80009782:	e0 a0 0f 1b 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
80009786:	e0 81 02 54 	brne	80009c2e <_dtoa_r+0x96a>
8000978a:	0a 98       	mov	r8,r5
8000978c:	40 b9       	lddsp	r9,sp[0x2c]
8000978e:	ee 18 80 00 	eorh	r8,0x8000
80009792:	fa ea 00 08 	ld.d	r10,sp[8]
80009796:	10 95       	mov	r5,r8
80009798:	12 98       	mov	r8,r9
8000979a:	0a 99       	mov	r9,r5
8000979c:	e0 a0 0f 0e 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800097a0:	e0 81 02 3e 	brne	80009c1c <_dtoa_r+0x958>
800097a4:	ca 68       	rjmp	800098f0 <_dtoa_r+0x62c>
800097a6:	fe c9 c7 e6 	sub	r9,pc,-14362
800097aa:	e8 c8 00 01 	sub	r8,r4,1
800097ae:	40 d5       	lddsp	r5,sp[0x34]
800097b0:	58 05       	cp.w	r5,0
800097b2:	c4 f0       	breq	80009850 <_dtoa_r+0x58c>
800097b4:	30 0c       	mov	r12,0
800097b6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800097ba:	51 3c       	stdsp	sp[0x4c],r12
800097bc:	30 0a       	mov	r10,0
800097be:	fc 1b 3f e0 	movh	r11,0x3fe0
800097c2:	e0 a0 0f 2f 	rcall	8000b620 <__avr32_f64_div>
800097c6:	fa e8 00 28 	ld.d	r8,sp[40]
800097ca:	40 85       	lddsp	r5,sp[0x20]
800097cc:	e0 a0 0c d0 	rcall	8000b16c <__avr32_f64_sub>
800097d0:	fa eb 00 28 	st.d	sp[40],r10
800097d4:	fa ea 00 08 	ld.d	r10,sp[8]
800097d8:	e0 a0 0e 22 	rcall	8000b41c <__avr32_f64_to_s32>
800097dc:	51 6c       	stdsp	sp[0x58],r12
800097de:	e0 a0 0e 36 	rcall	8000b44a <__avr32_s32_to_f64>
800097e2:	14 98       	mov	r8,r10
800097e4:	16 99       	mov	r9,r11
800097e6:	fa ea 00 08 	ld.d	r10,sp[8]
800097ea:	e0 a0 0c c1 	rcall	8000b16c <__avr32_f64_sub>
800097ee:	fa eb 00 08 	st.d	sp[8],r10
800097f2:	41 68       	lddsp	r8,sp[0x58]
800097f4:	2d 08       	sub	r8,-48
800097f6:	0a c8       	st.b	r5++,r8
800097f8:	41 39       	lddsp	r9,sp[0x4c]
800097fa:	2f f9       	sub	r9,-1
800097fc:	51 39       	stdsp	sp[0x4c],r9
800097fe:	fa e8 00 28 	ld.d	r8,sp[40]
80009802:	e0 a0 0e db 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
80009806:	e0 81 03 39 	brne	80009e78 <_dtoa_r+0xbb4>
8000980a:	fa e8 00 08 	ld.d	r8,sp[8]
8000980e:	30 0a       	mov	r10,0
80009810:	fc 1b 3f f0 	movh	r11,0x3ff0
80009814:	e0 a0 0c ac 	rcall	8000b16c <__avr32_f64_sub>
80009818:	fa e8 00 28 	ld.d	r8,sp[40]
8000981c:	e0 a0 0e ce 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
80009820:	fa ea 00 28 	ld.d	r10,sp[40]
80009824:	30 08       	mov	r8,0
80009826:	fc 19 40 24 	movh	r9,0x4024
8000982a:	e0 81 00 da 	brne	800099de <_dtoa_r+0x71a>
8000982e:	41 3c       	lddsp	r12,sp[0x4c]
80009830:	08 3c       	cp.w	r12,r4
80009832:	c5 f4       	brge	800098f0 <_dtoa_r+0x62c>
80009834:	e0 a0 0b b0 	rcall	8000af94 <__avr32_f64_mul>
80009838:	30 08       	mov	r8,0
8000983a:	fa eb 00 28 	st.d	sp[40],r10
8000983e:	fc 19 40 24 	movh	r9,0x4024
80009842:	fa ea 00 08 	ld.d	r10,sp[8]
80009846:	e0 a0 0b a7 	rcall	8000af94 <__avr32_f64_mul>
8000984a:	fa eb 00 08 	st.d	sp[8],r10
8000984e:	cc 3b       	rjmp	800097d4 <_dtoa_r+0x510>
80009850:	40 85       	lddsp	r5,sp[0x20]
80009852:	08 05       	add	r5,r4
80009854:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009858:	51 35       	stdsp	sp[0x4c],r5
8000985a:	fa e8 00 28 	ld.d	r8,sp[40]
8000985e:	40 85       	lddsp	r5,sp[0x20]
80009860:	e0 a0 0b 9a 	rcall	8000af94 <__avr32_f64_mul>
80009864:	fa eb 00 28 	st.d	sp[40],r10
80009868:	fa ea 00 08 	ld.d	r10,sp[8]
8000986c:	e0 a0 0d d8 	rcall	8000b41c <__avr32_f64_to_s32>
80009870:	51 6c       	stdsp	sp[0x58],r12
80009872:	e0 a0 0d ec 	rcall	8000b44a <__avr32_s32_to_f64>
80009876:	14 98       	mov	r8,r10
80009878:	16 99       	mov	r9,r11
8000987a:	fa ea 00 08 	ld.d	r10,sp[8]
8000987e:	e0 a0 0c 77 	rcall	8000b16c <__avr32_f64_sub>
80009882:	fa eb 00 08 	st.d	sp[8],r10
80009886:	41 68       	lddsp	r8,sp[0x58]
80009888:	2d 08       	sub	r8,-48
8000988a:	0a c8       	st.b	r5++,r8
8000988c:	41 3c       	lddsp	r12,sp[0x4c]
8000988e:	18 35       	cp.w	r5,r12
80009890:	c2 81       	brne	800098e0 <_dtoa_r+0x61c>
80009892:	30 08       	mov	r8,0
80009894:	fc 19 3f e0 	movh	r9,0x3fe0
80009898:	fa ea 00 28 	ld.d	r10,sp[40]
8000989c:	e0 a0 0d 36 	rcall	8000b308 <__avr32_f64_add>
800098a0:	40 85       	lddsp	r5,sp[0x20]
800098a2:	fa e8 00 08 	ld.d	r8,sp[8]
800098a6:	08 05       	add	r5,r4
800098a8:	e0 a0 0e 88 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800098ac:	e0 81 00 99 	brne	800099de <_dtoa_r+0x71a>
800098b0:	fa e8 00 28 	ld.d	r8,sp[40]
800098b4:	30 0a       	mov	r10,0
800098b6:	fc 1b 3f e0 	movh	r11,0x3fe0
800098ba:	e0 a0 0c 59 	rcall	8000b16c <__avr32_f64_sub>
800098be:	14 98       	mov	r8,r10
800098c0:	16 99       	mov	r9,r11
800098c2:	fa ea 00 08 	ld.d	r10,sp[8]
800098c6:	e0 a0 0e 79 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800098ca:	c1 30       	breq	800098f0 <_dtoa_r+0x62c>
800098cc:	33 09       	mov	r9,48
800098ce:	0a 98       	mov	r8,r5
800098d0:	11 7a       	ld.ub	r10,--r8
800098d2:	f2 0a 18 00 	cp.b	r10,r9
800098d6:	e0 81 02 d1 	brne	80009e78 <_dtoa_r+0xbb4>
800098da:	10 95       	mov	r5,r8
800098dc:	cf 9b       	rjmp	800098ce <_dtoa_r+0x60a>
800098de:	d7 03       	nop
800098e0:	30 08       	mov	r8,0
800098e2:	fc 19 40 24 	movh	r9,0x4024
800098e6:	e0 a0 0b 57 	rcall	8000af94 <__avr32_f64_mul>
800098ea:	fa eb 00 08 	st.d	sp[8],r10
800098ee:	cb db       	rjmp	80009868 <_dtoa_r+0x5a4>
800098f0:	fa ea 00 3c 	ld.d	r10,sp[60]
800098f4:	fa eb 00 08 	st.d	sp[8],r10
800098f8:	58 e6       	cp.w	r6,14
800098fa:	5f ab       	srle	r11
800098fc:	41 8a       	lddsp	r10,sp[0x60]
800098fe:	30 08       	mov	r8,0
80009900:	f4 09 11 ff 	rsub	r9,r10,-1
80009904:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009908:	f0 09 18 00 	cp.b	r9,r8
8000990c:	e0 80 00 82 	breq	80009a10 <_dtoa_r+0x74c>
80009910:	40 ea       	lddsp	r10,sp[0x38]
80009912:	58 01       	cp.w	r1,0
80009914:	5f a9       	srle	r9
80009916:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000991a:	fe ca c9 5a 	sub	r10,pc,-13990
8000991e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009922:	fa e5 00 10 	st.d	sp[16],r4
80009926:	f0 09 18 00 	cp.b	r9,r8
8000992a:	c1 40       	breq	80009952 <_dtoa_r+0x68e>
8000992c:	58 01       	cp.w	r1,0
8000992e:	e0 81 01 77 	brne	80009c1c <_dtoa_r+0x958>
80009932:	30 08       	mov	r8,0
80009934:	fc 19 40 14 	movh	r9,0x4014
80009938:	08 9a       	mov	r10,r4
8000993a:	0a 9b       	mov	r11,r5
8000993c:	e0 a0 0b 2c 	rcall	8000af94 <__avr32_f64_mul>
80009940:	fa e8 00 08 	ld.d	r8,sp[8]
80009944:	e0 a0 0e 06 	rcall	8000b550 <__avr32_f64_cmp_ge>
80009948:	e0 81 01 6a 	brne	80009c1c <_dtoa_r+0x958>
8000994c:	02 92       	mov	r2,r1
8000994e:	e0 8f 01 72 	bral	80009c32 <_dtoa_r+0x96e>
80009952:	40 85       	lddsp	r5,sp[0x20]
80009954:	30 14       	mov	r4,1
80009956:	fa e8 00 10 	ld.d	r8,sp[16]
8000995a:	fa ea 00 08 	ld.d	r10,sp[8]
8000995e:	e0 a0 0e 61 	rcall	8000b620 <__avr32_f64_div>
80009962:	e0 a0 0d 5d 	rcall	8000b41c <__avr32_f64_to_s32>
80009966:	18 92       	mov	r2,r12
80009968:	e0 a0 0d 71 	rcall	8000b44a <__avr32_s32_to_f64>
8000996c:	fa e8 00 10 	ld.d	r8,sp[16]
80009970:	e0 a0 0b 12 	rcall	8000af94 <__avr32_f64_mul>
80009974:	14 98       	mov	r8,r10
80009976:	16 99       	mov	r9,r11
80009978:	fa ea 00 08 	ld.d	r10,sp[8]
8000997c:	e0 a0 0b f8 	rcall	8000b16c <__avr32_f64_sub>
80009980:	fa eb 00 08 	st.d	sp[8],r10
80009984:	e4 c8 ff d0 	sub	r8,r2,-48
80009988:	0a c8       	st.b	r5++,r8
8000998a:	fc 19 40 24 	movh	r9,0x4024
8000998e:	30 08       	mov	r8,0
80009990:	02 34       	cp.w	r4,r1
80009992:	c3 31       	brne	800099f8 <_dtoa_r+0x734>
80009994:	fa e8 00 08 	ld.d	r8,sp[8]
80009998:	e0 a0 0c b8 	rcall	8000b308 <__avr32_f64_add>
8000999c:	16 91       	mov	r1,r11
8000999e:	14 90       	mov	r0,r10
800099a0:	14 98       	mov	r8,r10
800099a2:	02 99       	mov	r9,r1
800099a4:	fa ea 00 10 	ld.d	r10,sp[16]
800099a8:	e0 a0 0e 08 	rcall	8000b5b8 <__avr32_f64_cmp_lt>
800099ac:	c1 a1       	brne	800099e0 <_dtoa_r+0x71c>
800099ae:	fa e8 00 10 	ld.d	r8,sp[16]
800099b2:	00 9a       	mov	r10,r0
800099b4:	02 9b       	mov	r11,r1
800099b6:	e0 a0 0d ba 	rcall	8000b52a <__avr32_f64_cmp_eq>
800099ba:	e0 80 02 5e 	breq	80009e76 <_dtoa_r+0xbb2>
800099be:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800099c2:	c0 f1       	brne	800099e0 <_dtoa_r+0x71c>
800099c4:	e0 8f 02 59 	bral	80009e76 <_dtoa_r+0xbb2>
800099c8:	40 8a       	lddsp	r10,sp[0x20]
800099ca:	14 38       	cp.w	r8,r10
800099cc:	c0 30       	breq	800099d2 <_dtoa_r+0x70e>
800099ce:	10 95       	mov	r5,r8
800099d0:	c0 98       	rjmp	800099e2 <_dtoa_r+0x71e>
800099d2:	33 08       	mov	r8,48
800099d4:	40 89       	lddsp	r9,sp[0x20]
800099d6:	2f f6       	sub	r6,-1
800099d8:	b2 88       	st.b	r9[0x0],r8
800099da:	40 88       	lddsp	r8,sp[0x20]
800099dc:	c0 88       	rjmp	800099ec <_dtoa_r+0x728>
800099de:	40 66       	lddsp	r6,sp[0x18]
800099e0:	33 99       	mov	r9,57
800099e2:	0a 98       	mov	r8,r5
800099e4:	11 7a       	ld.ub	r10,--r8
800099e6:	f2 0a 18 00 	cp.b	r10,r9
800099ea:	ce f0       	breq	800099c8 <_dtoa_r+0x704>
800099ec:	50 66       	stdsp	sp[0x18],r6
800099ee:	11 89       	ld.ub	r9,r8[0x0]
800099f0:	2f f9       	sub	r9,-1
800099f2:	b0 89       	st.b	r8[0x0],r9
800099f4:	e0 8f 02 42 	bral	80009e78 <_dtoa_r+0xbb4>
800099f8:	e0 a0 0a ce 	rcall	8000af94 <__avr32_f64_mul>
800099fc:	2f f4       	sub	r4,-1
800099fe:	fa eb 00 08 	st.d	sp[8],r10
80009a02:	30 08       	mov	r8,0
80009a04:	30 09       	mov	r9,0
80009a06:	e0 a0 0d 92 	rcall	8000b52a <__avr32_f64_cmp_eq>
80009a0a:	ca 60       	breq	80009956 <_dtoa_r+0x692>
80009a0c:	e0 8f 02 35 	bral	80009e76 <_dtoa_r+0xbb2>
80009a10:	40 d8       	lddsp	r8,sp[0x34]
80009a12:	58 08       	cp.w	r8,0
80009a14:	c0 51       	brne	80009a1e <_dtoa_r+0x75a>
80009a16:	04 98       	mov	r8,r2
80009a18:	00 95       	mov	r5,r0
80009a1a:	40 d4       	lddsp	r4,sp[0x34]
80009a1c:	c3 78       	rjmp	80009a8a <_dtoa_r+0x7c6>
80009a1e:	40 c5       	lddsp	r5,sp[0x30]
80009a20:	58 15       	cp.w	r5,1
80009a22:	e0 89 00 0f 	brgt	80009a40 <_dtoa_r+0x77c>
80009a26:	41 74       	lddsp	r4,sp[0x5c]
80009a28:	58 04       	cp.w	r4,0
80009a2a:	c0 40       	breq	80009a32 <_dtoa_r+0x76e>
80009a2c:	f4 c9 fb cd 	sub	r9,r10,-1075
80009a30:	c0 48       	rjmp	80009a38 <_dtoa_r+0x774>
80009a32:	41 99       	lddsp	r9,sp[0x64]
80009a34:	f2 09 11 36 	rsub	r9,r9,54
80009a38:	04 98       	mov	r8,r2
80009a3a:	00 95       	mov	r5,r0
80009a3c:	c1 c8       	rjmp	80009a74 <_dtoa_r+0x7b0>
80009a3e:	d7 03       	nop
80009a40:	e2 c8 00 01 	sub	r8,r1,1
80009a44:	58 01       	cp.w	r1,0
80009a46:	e0 05 17 40 	movge	r5,r0
80009a4a:	e2 09 17 40 	movge	r9,r1
80009a4e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009a52:	f9 b9 05 00 	movlt	r9,0
80009a56:	10 32       	cp.w	r2,r8
80009a58:	e5 d8 e4 18 	subge	r8,r2,r8
80009a5c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009a60:	e5 d8 e5 02 	addlt	r2,r2,r8
80009a64:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009a68:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009a6c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009a70:	f9 b8 05 00 	movlt	r8,0
80009a74:	40 4b       	lddsp	r11,sp[0x10]
80009a76:	12 0b       	add	r11,r9
80009a78:	50 08       	stdsp	sp[0x0],r8
80009a7a:	50 4b       	stdsp	sp[0x10],r11
80009a7c:	12 00       	add	r0,r9
80009a7e:	30 1b       	mov	r11,1
80009a80:	0e 9c       	mov	r12,r7
80009a82:	e0 a0 08 a7 	rcall	8000abd0 <__i2b>
80009a86:	40 08       	lddsp	r8,sp[0x0]
80009a88:	18 94       	mov	r4,r12
80009a8a:	40 4a       	lddsp	r10,sp[0x10]
80009a8c:	58 05       	cp.w	r5,0
80009a8e:	5f 99       	srgt	r9
80009a90:	58 0a       	cp.w	r10,0
80009a92:	5f 9a       	srgt	r10
80009a94:	f5 e9 00 09 	and	r9,r10,r9
80009a98:	c0 80       	breq	80009aa8 <_dtoa_r+0x7e4>
80009a9a:	40 4c       	lddsp	r12,sp[0x10]
80009a9c:	f8 05 0d 49 	min	r9,r12,r5
80009aa0:	12 1c       	sub	r12,r9
80009aa2:	12 10       	sub	r0,r9
80009aa4:	50 4c       	stdsp	sp[0x10],r12
80009aa6:	12 15       	sub	r5,r9
80009aa8:	58 02       	cp.w	r2,0
80009aaa:	e0 8a 00 27 	brle	80009af8 <_dtoa_r+0x834>
80009aae:	40 db       	lddsp	r11,sp[0x34]
80009ab0:	58 0b       	cp.w	r11,0
80009ab2:	c1 d0       	breq	80009aec <_dtoa_r+0x828>
80009ab4:	58 08       	cp.w	r8,0
80009ab6:	e0 8a 00 17 	brle	80009ae4 <_dtoa_r+0x820>
80009aba:	10 9a       	mov	r10,r8
80009abc:	50 08       	stdsp	sp[0x0],r8
80009abe:	08 9b       	mov	r11,r4
80009ac0:	0e 9c       	mov	r12,r7
80009ac2:	e0 a0 08 cd 	rcall	8000ac5c <__pow5mult>
80009ac6:	06 9a       	mov	r10,r3
80009ac8:	18 9b       	mov	r11,r12
80009aca:	18 94       	mov	r4,r12
80009acc:	0e 9c       	mov	r12,r7
80009ace:	e0 a0 08 01 	rcall	8000aad0 <__multiply>
80009ad2:	18 99       	mov	r9,r12
80009ad4:	06 9b       	mov	r11,r3
80009ad6:	50 19       	stdsp	sp[0x4],r9
80009ad8:	0e 9c       	mov	r12,r7
80009ada:	e0 a0 06 ad 	rcall	8000a834 <_Bfree>
80009ade:	40 19       	lddsp	r9,sp[0x4]
80009ae0:	40 08       	lddsp	r8,sp[0x0]
80009ae2:	12 93       	mov	r3,r9
80009ae4:	e4 08 01 0a 	sub	r10,r2,r8
80009ae8:	c0 80       	breq	80009af8 <_dtoa_r+0x834>
80009aea:	c0 28       	rjmp	80009aee <_dtoa_r+0x82a>
80009aec:	04 9a       	mov	r10,r2
80009aee:	06 9b       	mov	r11,r3
80009af0:	0e 9c       	mov	r12,r7
80009af2:	e0 a0 08 b5 	rcall	8000ac5c <__pow5mult>
80009af6:	18 93       	mov	r3,r12
80009af8:	30 1b       	mov	r11,1
80009afa:	0e 9c       	mov	r12,r7
80009afc:	e0 a0 08 6a 	rcall	8000abd0 <__i2b>
80009b00:	41 1a       	lddsp	r10,sp[0x44]
80009b02:	18 92       	mov	r2,r12
80009b04:	58 0a       	cp.w	r10,0
80009b06:	e0 8a 00 07 	brle	80009b14 <_dtoa_r+0x850>
80009b0a:	18 9b       	mov	r11,r12
80009b0c:	0e 9c       	mov	r12,r7
80009b0e:	e0 a0 08 a7 	rcall	8000ac5c <__pow5mult>
80009b12:	18 92       	mov	r2,r12
80009b14:	40 c9       	lddsp	r9,sp[0x30]
80009b16:	58 19       	cp.w	r9,1
80009b18:	e0 89 00 14 	brgt	80009b40 <_dtoa_r+0x87c>
80009b1c:	40 38       	lddsp	r8,sp[0xc]
80009b1e:	58 08       	cp.w	r8,0
80009b20:	c1 01       	brne	80009b40 <_dtoa_r+0x87c>
80009b22:	40 29       	lddsp	r9,sp[0x8]
80009b24:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009b28:	c0 c1       	brne	80009b40 <_dtoa_r+0x87c>
80009b2a:	12 98       	mov	r8,r9
80009b2c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009b30:	c0 80       	breq	80009b40 <_dtoa_r+0x87c>
80009b32:	40 4c       	lddsp	r12,sp[0x10]
80009b34:	30 1b       	mov	r11,1
80009b36:	2f fc       	sub	r12,-1
80009b38:	2f f0       	sub	r0,-1
80009b3a:	50 4c       	stdsp	sp[0x10],r12
80009b3c:	50 6b       	stdsp	sp[0x18],r11
80009b3e:	c0 38       	rjmp	80009b44 <_dtoa_r+0x880>
80009b40:	30 0a       	mov	r10,0
80009b42:	50 6a       	stdsp	sp[0x18],r10
80009b44:	41 19       	lddsp	r9,sp[0x44]
80009b46:	58 09       	cp.w	r9,0
80009b48:	c0 31       	brne	80009b4e <_dtoa_r+0x88a>
80009b4a:	30 1c       	mov	r12,1
80009b4c:	c0 98       	rjmp	80009b5e <_dtoa_r+0x89a>
80009b4e:	64 48       	ld.w	r8,r2[0x10]
80009b50:	2f c8       	sub	r8,-4
80009b52:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009b56:	e0 a0 05 df 	rcall	8000a714 <__hi0bits>
80009b5a:	f8 0c 11 20 	rsub	r12,r12,32
80009b5e:	40 4b       	lddsp	r11,sp[0x10]
80009b60:	f8 0b 00 08 	add	r8,r12,r11
80009b64:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009b68:	c0 c0       	breq	80009b80 <_dtoa_r+0x8bc>
80009b6a:	f0 08 11 20 	rsub	r8,r8,32
80009b6e:	58 48       	cp.w	r8,4
80009b70:	e0 8a 00 06 	brle	80009b7c <_dtoa_r+0x8b8>
80009b74:	20 48       	sub	r8,4
80009b76:	10 0b       	add	r11,r8
80009b78:	50 4b       	stdsp	sp[0x10],r11
80009b7a:	c0 78       	rjmp	80009b88 <_dtoa_r+0x8c4>
80009b7c:	58 48       	cp.w	r8,4
80009b7e:	c0 70       	breq	80009b8c <_dtoa_r+0x8c8>
80009b80:	40 4a       	lddsp	r10,sp[0x10]
80009b82:	2e 48       	sub	r8,-28
80009b84:	10 0a       	add	r10,r8
80009b86:	50 4a       	stdsp	sp[0x10],r10
80009b88:	10 00       	add	r0,r8
80009b8a:	10 05       	add	r5,r8
80009b8c:	58 00       	cp.w	r0,0
80009b8e:	e0 8a 00 08 	brle	80009b9e <_dtoa_r+0x8da>
80009b92:	06 9b       	mov	r11,r3
80009b94:	00 9a       	mov	r10,r0
80009b96:	0e 9c       	mov	r12,r7
80009b98:	e0 a0 07 58 	rcall	8000aa48 <__lshift>
80009b9c:	18 93       	mov	r3,r12
80009b9e:	40 49       	lddsp	r9,sp[0x10]
80009ba0:	58 09       	cp.w	r9,0
80009ba2:	e0 8a 00 08 	brle	80009bb2 <_dtoa_r+0x8ee>
80009ba6:	04 9b       	mov	r11,r2
80009ba8:	12 9a       	mov	r10,r9
80009baa:	0e 9c       	mov	r12,r7
80009bac:	e0 a0 07 4e 	rcall	8000aa48 <__lshift>
80009bb0:	18 92       	mov	r2,r12
80009bb2:	41 48       	lddsp	r8,sp[0x50]
80009bb4:	58 08       	cp.w	r8,0
80009bb6:	c1 b0       	breq	80009bec <_dtoa_r+0x928>
80009bb8:	04 9b       	mov	r11,r2
80009bba:	06 9c       	mov	r12,r3
80009bbc:	e0 a0 06 23 	rcall	8000a802 <__mcmp>
80009bc0:	c1 64       	brge	80009bec <_dtoa_r+0x928>
80009bc2:	06 9b       	mov	r11,r3
80009bc4:	30 09       	mov	r9,0
80009bc6:	30 aa       	mov	r10,10
80009bc8:	0e 9c       	mov	r12,r7
80009bca:	e0 a0 08 0b 	rcall	8000abe0 <__multadd>
80009bce:	20 16       	sub	r6,1
80009bd0:	18 93       	mov	r3,r12
80009bd2:	40 dc       	lddsp	r12,sp[0x34]
80009bd4:	58 0c       	cp.w	r12,0
80009bd6:	c0 31       	brne	80009bdc <_dtoa_r+0x918>
80009bd8:	40 91       	lddsp	r1,sp[0x24]
80009bda:	c0 98       	rjmp	80009bec <_dtoa_r+0x928>
80009bdc:	08 9b       	mov	r11,r4
80009bde:	40 91       	lddsp	r1,sp[0x24]
80009be0:	30 09       	mov	r9,0
80009be2:	30 aa       	mov	r10,10
80009be4:	0e 9c       	mov	r12,r7
80009be6:	e0 a0 07 fd 	rcall	8000abe0 <__multadd>
80009bea:	18 94       	mov	r4,r12
80009bec:	58 01       	cp.w	r1,0
80009bee:	5f a9       	srle	r9
80009bf0:	40 cb       	lddsp	r11,sp[0x30]
80009bf2:	58 2b       	cp.w	r11,2
80009bf4:	5f 98       	srgt	r8
80009bf6:	f3 e8 00 08 	and	r8,r9,r8
80009bfa:	c2 50       	breq	80009c44 <_dtoa_r+0x980>
80009bfc:	58 01       	cp.w	r1,0
80009bfe:	c1 11       	brne	80009c20 <_dtoa_r+0x95c>
80009c00:	04 9b       	mov	r11,r2
80009c02:	02 99       	mov	r9,r1
80009c04:	30 5a       	mov	r10,5
80009c06:	0e 9c       	mov	r12,r7
80009c08:	e0 a0 07 ec 	rcall	8000abe0 <__multadd>
80009c0c:	18 92       	mov	r2,r12
80009c0e:	18 9b       	mov	r11,r12
80009c10:	06 9c       	mov	r12,r3
80009c12:	e0 a0 05 f8 	rcall	8000a802 <__mcmp>
80009c16:	e0 89 00 0f 	brgt	80009c34 <_dtoa_r+0x970>
80009c1a:	c0 38       	rjmp	80009c20 <_dtoa_r+0x95c>
80009c1c:	30 02       	mov	r2,0
80009c1e:	04 94       	mov	r4,r2
80009c20:	40 ea       	lddsp	r10,sp[0x38]
80009c22:	30 09       	mov	r9,0
80009c24:	5c da       	com	r10
80009c26:	40 85       	lddsp	r5,sp[0x20]
80009c28:	50 6a       	stdsp	sp[0x18],r10
80009c2a:	50 49       	stdsp	sp[0x10],r9
80009c2c:	c0 f9       	rjmp	80009e4a <_dtoa_r+0xb86>
80009c2e:	08 92       	mov	r2,r4
80009c30:	40 66       	lddsp	r6,sp[0x18]
80009c32:	04 94       	mov	r4,r2
80009c34:	2f f6       	sub	r6,-1
80009c36:	50 66       	stdsp	sp[0x18],r6
80009c38:	33 18       	mov	r8,49
80009c3a:	40 85       	lddsp	r5,sp[0x20]
80009c3c:	0a c8       	st.b	r5++,r8
80009c3e:	30 08       	mov	r8,0
80009c40:	50 48       	stdsp	sp[0x10],r8
80009c42:	c0 49       	rjmp	80009e4a <_dtoa_r+0xb86>
80009c44:	40 dc       	lddsp	r12,sp[0x34]
80009c46:	58 0c       	cp.w	r12,0
80009c48:	e0 80 00 b5 	breq	80009db2 <_dtoa_r+0xaee>
80009c4c:	58 05       	cp.w	r5,0
80009c4e:	e0 8a 00 08 	brle	80009c5e <_dtoa_r+0x99a>
80009c52:	08 9b       	mov	r11,r4
80009c54:	0a 9a       	mov	r10,r5
80009c56:	0e 9c       	mov	r12,r7
80009c58:	e0 a0 06 f8 	rcall	8000aa48 <__lshift>
80009c5c:	18 94       	mov	r4,r12
80009c5e:	40 6b       	lddsp	r11,sp[0x18]
80009c60:	58 0b       	cp.w	r11,0
80009c62:	c0 31       	brne	80009c68 <_dtoa_r+0x9a4>
80009c64:	08 9c       	mov	r12,r4
80009c66:	c1 38       	rjmp	80009c8c <_dtoa_r+0x9c8>
80009c68:	68 1b       	ld.w	r11,r4[0x4]
80009c6a:	0e 9c       	mov	r12,r7
80009c6c:	e0 a0 05 fe 	rcall	8000a868 <_Balloc>
80009c70:	68 4a       	ld.w	r10,r4[0x10]
80009c72:	18 95       	mov	r5,r12
80009c74:	e8 cb ff f4 	sub	r11,r4,-12
80009c78:	2f ea       	sub	r10,-2
80009c7a:	2f 4c       	sub	r12,-12
80009c7c:	a3 6a       	lsl	r10,0x2
80009c7e:	fe b0 e6 4f 	rcall	8000691c <memcpy>
80009c82:	0a 9b       	mov	r11,r5
80009c84:	30 1a       	mov	r10,1
80009c86:	0e 9c       	mov	r12,r7
80009c88:	e0 a0 06 e0 	rcall	8000aa48 <__lshift>
80009c8c:	50 44       	stdsp	sp[0x10],r4
80009c8e:	40 3a       	lddsp	r10,sp[0xc]
80009c90:	30 19       	mov	r9,1
80009c92:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009c96:	18 94       	mov	r4,r12
80009c98:	50 da       	stdsp	sp[0x34],r10
80009c9a:	40 85       	lddsp	r5,sp[0x20]
80009c9c:	50 99       	stdsp	sp[0x24],r9
80009c9e:	50 26       	stdsp	sp[0x8],r6
80009ca0:	50 e1       	stdsp	sp[0x38],r1
80009ca2:	04 9b       	mov	r11,r2
80009ca4:	06 9c       	mov	r12,r3
80009ca6:	fe b0 fa 7f 	rcall	800091a4 <quorem>
80009caa:	40 4b       	lddsp	r11,sp[0x10]
80009cac:	f8 c0 ff d0 	sub	r0,r12,-48
80009cb0:	06 9c       	mov	r12,r3
80009cb2:	e0 a0 05 a8 	rcall	8000a802 <__mcmp>
80009cb6:	08 9a       	mov	r10,r4
80009cb8:	50 6c       	stdsp	sp[0x18],r12
80009cba:	04 9b       	mov	r11,r2
80009cbc:	0e 9c       	mov	r12,r7
80009cbe:	e0 a0 06 5d 	rcall	8000a978 <__mdiff>
80009cc2:	18 91       	mov	r1,r12
80009cc4:	78 38       	ld.w	r8,r12[0xc]
80009cc6:	58 08       	cp.w	r8,0
80009cc8:	c0 30       	breq	80009cce <_dtoa_r+0xa0a>
80009cca:	30 16       	mov	r6,1
80009ccc:	c0 68       	rjmp	80009cd8 <_dtoa_r+0xa14>
80009cce:	18 9b       	mov	r11,r12
80009cd0:	06 9c       	mov	r12,r3
80009cd2:	e0 a0 05 98 	rcall	8000a802 <__mcmp>
80009cd6:	18 96       	mov	r6,r12
80009cd8:	0e 9c       	mov	r12,r7
80009cda:	02 9b       	mov	r11,r1
80009cdc:	e0 a0 05 ac 	rcall	8000a834 <_Bfree>
80009ce0:	40 cc       	lddsp	r12,sp[0x30]
80009ce2:	ed ec 10 08 	or	r8,r6,r12
80009ce6:	c0 d1       	brne	80009d00 <_dtoa_r+0xa3c>
80009ce8:	40 db       	lddsp	r11,sp[0x34]
80009cea:	58 0b       	cp.w	r11,0
80009cec:	c0 a1       	brne	80009d00 <_dtoa_r+0xa3c>
80009cee:	40 26       	lddsp	r6,sp[0x8]
80009cf0:	e0 40 00 39 	cp.w	r0,57
80009cf4:	c3 00       	breq	80009d54 <_dtoa_r+0xa90>
80009cf6:	40 6a       	lddsp	r10,sp[0x18]
80009cf8:	58 0a       	cp.w	r10,0
80009cfa:	e0 89 00 24 	brgt	80009d42 <_dtoa_r+0xa7e>
80009cfe:	c2 f8       	rjmp	80009d5c <_dtoa_r+0xa98>
80009d00:	40 69       	lddsp	r9,sp[0x18]
80009d02:	58 09       	cp.w	r9,0
80009d04:	c0 85       	brlt	80009d14 <_dtoa_r+0xa50>
80009d06:	12 98       	mov	r8,r9
80009d08:	40 cc       	lddsp	r12,sp[0x30]
80009d0a:	18 48       	or	r8,r12
80009d0c:	c1 d1       	brne	80009d46 <_dtoa_r+0xa82>
80009d0e:	40 db       	lddsp	r11,sp[0x34]
80009d10:	58 0b       	cp.w	r11,0
80009d12:	c1 a1       	brne	80009d46 <_dtoa_r+0xa82>
80009d14:	0c 99       	mov	r9,r6
80009d16:	40 26       	lddsp	r6,sp[0x8]
80009d18:	58 09       	cp.w	r9,0
80009d1a:	e0 8a 00 21 	brle	80009d5c <_dtoa_r+0xa98>
80009d1e:	06 9b       	mov	r11,r3
80009d20:	30 1a       	mov	r10,1
80009d22:	0e 9c       	mov	r12,r7
80009d24:	e0 a0 06 92 	rcall	8000aa48 <__lshift>
80009d28:	04 9b       	mov	r11,r2
80009d2a:	18 93       	mov	r3,r12
80009d2c:	e0 a0 05 6b 	rcall	8000a802 <__mcmp>
80009d30:	e0 89 00 06 	brgt	80009d3c <_dtoa_r+0xa78>
80009d34:	c1 41       	brne	80009d5c <_dtoa_r+0xa98>
80009d36:	ed b0 00 00 	bld	r0,0x0
80009d3a:	c1 11       	brne	80009d5c <_dtoa_r+0xa98>
80009d3c:	e0 40 00 39 	cp.w	r0,57
80009d40:	c0 a0       	breq	80009d54 <_dtoa_r+0xa90>
80009d42:	2f f0       	sub	r0,-1
80009d44:	c0 c8       	rjmp	80009d5c <_dtoa_r+0xa98>
80009d46:	58 06       	cp.w	r6,0
80009d48:	e0 8a 00 0c 	brle	80009d60 <_dtoa_r+0xa9c>
80009d4c:	40 26       	lddsp	r6,sp[0x8]
80009d4e:	e0 40 00 39 	cp.w	r0,57
80009d52:	c0 41       	brne	80009d5a <_dtoa_r+0xa96>
80009d54:	33 98       	mov	r8,57
80009d56:	0a c8       	st.b	r5++,r8
80009d58:	c6 78       	rjmp	80009e26 <_dtoa_r+0xb62>
80009d5a:	2f f0       	sub	r0,-1
80009d5c:	0a c0       	st.b	r5++,r0
80009d5e:	c7 58       	rjmp	80009e48 <_dtoa_r+0xb84>
80009d60:	0a c0       	st.b	r5++,r0
80009d62:	40 9a       	lddsp	r10,sp[0x24]
80009d64:	40 e9       	lddsp	r9,sp[0x38]
80009d66:	12 3a       	cp.w	r10,r9
80009d68:	c4 30       	breq	80009dee <_dtoa_r+0xb2a>
80009d6a:	06 9b       	mov	r11,r3
80009d6c:	30 09       	mov	r9,0
80009d6e:	30 aa       	mov	r10,10
80009d70:	0e 9c       	mov	r12,r7
80009d72:	e0 a0 07 37 	rcall	8000abe0 <__multadd>
80009d76:	40 48       	lddsp	r8,sp[0x10]
80009d78:	18 93       	mov	r3,r12
80009d7a:	08 38       	cp.w	r8,r4
80009d7c:	c0 91       	brne	80009d8e <_dtoa_r+0xaca>
80009d7e:	10 9b       	mov	r11,r8
80009d80:	30 09       	mov	r9,0
80009d82:	30 aa       	mov	r10,10
80009d84:	0e 9c       	mov	r12,r7
80009d86:	e0 a0 07 2d 	rcall	8000abe0 <__multadd>
80009d8a:	50 4c       	stdsp	sp[0x10],r12
80009d8c:	c0 e8       	rjmp	80009da8 <_dtoa_r+0xae4>
80009d8e:	40 4b       	lddsp	r11,sp[0x10]
80009d90:	30 09       	mov	r9,0
80009d92:	30 aa       	mov	r10,10
80009d94:	0e 9c       	mov	r12,r7
80009d96:	e0 a0 07 25 	rcall	8000abe0 <__multadd>
80009d9a:	08 9b       	mov	r11,r4
80009d9c:	50 4c       	stdsp	sp[0x10],r12
80009d9e:	30 09       	mov	r9,0
80009da0:	30 aa       	mov	r10,10
80009da2:	0e 9c       	mov	r12,r7
80009da4:	e0 a0 07 1e 	rcall	8000abe0 <__multadd>
80009da8:	18 94       	mov	r4,r12
80009daa:	40 9c       	lddsp	r12,sp[0x24]
80009dac:	2f fc       	sub	r12,-1
80009dae:	50 9c       	stdsp	sp[0x24],r12
80009db0:	c7 9b       	rjmp	80009ca2 <_dtoa_r+0x9de>
80009db2:	30 18       	mov	r8,1
80009db4:	06 90       	mov	r0,r3
80009db6:	40 85       	lddsp	r5,sp[0x20]
80009db8:	08 93       	mov	r3,r4
80009dba:	0c 94       	mov	r4,r6
80009dbc:	10 96       	mov	r6,r8
80009dbe:	04 9b       	mov	r11,r2
80009dc0:	00 9c       	mov	r12,r0
80009dc2:	fe b0 f9 f1 	rcall	800091a4 <quorem>
80009dc6:	2d 0c       	sub	r12,-48
80009dc8:	0a cc       	st.b	r5++,r12
80009dca:	02 36       	cp.w	r6,r1
80009dcc:	c0 a4       	brge	80009de0 <_dtoa_r+0xb1c>
80009dce:	00 9b       	mov	r11,r0
80009dd0:	30 09       	mov	r9,0
80009dd2:	30 aa       	mov	r10,10
80009dd4:	0e 9c       	mov	r12,r7
80009dd6:	2f f6       	sub	r6,-1
80009dd8:	e0 a0 07 04 	rcall	8000abe0 <__multadd>
80009ddc:	18 90       	mov	r0,r12
80009dde:	cf 0b       	rjmp	80009dbe <_dtoa_r+0xafa>
80009de0:	08 96       	mov	r6,r4
80009de2:	30 0b       	mov	r11,0
80009de4:	06 94       	mov	r4,r3
80009de6:	50 4b       	stdsp	sp[0x10],r11
80009de8:	00 93       	mov	r3,r0
80009dea:	18 90       	mov	r0,r12
80009dec:	c0 28       	rjmp	80009df0 <_dtoa_r+0xb2c>
80009dee:	40 26       	lddsp	r6,sp[0x8]
80009df0:	06 9b       	mov	r11,r3
80009df2:	30 1a       	mov	r10,1
80009df4:	0e 9c       	mov	r12,r7
80009df6:	e0 a0 06 29 	rcall	8000aa48 <__lshift>
80009dfa:	04 9b       	mov	r11,r2
80009dfc:	18 93       	mov	r3,r12
80009dfe:	e0 a0 05 02 	rcall	8000a802 <__mcmp>
80009e02:	e0 89 00 12 	brgt	80009e26 <_dtoa_r+0xb62>
80009e06:	c1 b1       	brne	80009e3c <_dtoa_r+0xb78>
80009e08:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009e0c:	c0 d1       	brne	80009e26 <_dtoa_r+0xb62>
80009e0e:	c1 78       	rjmp	80009e3c <_dtoa_r+0xb78>
80009e10:	40 89       	lddsp	r9,sp[0x20]
80009e12:	12 38       	cp.w	r8,r9
80009e14:	c0 30       	breq	80009e1a <_dtoa_r+0xb56>
80009e16:	10 95       	mov	r5,r8
80009e18:	c0 88       	rjmp	80009e28 <_dtoa_r+0xb64>
80009e1a:	2f f6       	sub	r6,-1
80009e1c:	50 66       	stdsp	sp[0x18],r6
80009e1e:	33 18       	mov	r8,49
80009e20:	40 8c       	lddsp	r12,sp[0x20]
80009e22:	b8 88       	st.b	r12[0x0],r8
80009e24:	c1 38       	rjmp	80009e4a <_dtoa_r+0xb86>
80009e26:	33 9a       	mov	r10,57
80009e28:	0a 98       	mov	r8,r5
80009e2a:	11 79       	ld.ub	r9,--r8
80009e2c:	f4 09 18 00 	cp.b	r9,r10
80009e30:	cf 00       	breq	80009e10 <_dtoa_r+0xb4c>
80009e32:	2f f9       	sub	r9,-1
80009e34:	b0 89       	st.b	r8[0x0],r9
80009e36:	c0 98       	rjmp	80009e48 <_dtoa_r+0xb84>
80009e38:	10 95       	mov	r5,r8
80009e3a:	c0 28       	rjmp	80009e3e <_dtoa_r+0xb7a>
80009e3c:	33 09       	mov	r9,48
80009e3e:	0a 98       	mov	r8,r5
80009e40:	11 7a       	ld.ub	r10,--r8
80009e42:	f2 0a 18 00 	cp.b	r10,r9
80009e46:	cf 90       	breq	80009e38 <_dtoa_r+0xb74>
80009e48:	50 66       	stdsp	sp[0x18],r6
80009e4a:	04 9b       	mov	r11,r2
80009e4c:	0e 9c       	mov	r12,r7
80009e4e:	e0 a0 04 f3 	rcall	8000a834 <_Bfree>
80009e52:	58 04       	cp.w	r4,0
80009e54:	c1 20       	breq	80009e78 <_dtoa_r+0xbb4>
80009e56:	40 4b       	lddsp	r11,sp[0x10]
80009e58:	08 3b       	cp.w	r11,r4
80009e5a:	5f 19       	srne	r9
80009e5c:	58 0b       	cp.w	r11,0
80009e5e:	5f 18       	srne	r8
80009e60:	f3 e8 00 08 	and	r8,r9,r8
80009e64:	c0 40       	breq	80009e6c <_dtoa_r+0xba8>
80009e66:	0e 9c       	mov	r12,r7
80009e68:	e0 a0 04 e6 	rcall	8000a834 <_Bfree>
80009e6c:	08 9b       	mov	r11,r4
80009e6e:	0e 9c       	mov	r12,r7
80009e70:	e0 a0 04 e2 	rcall	8000a834 <_Bfree>
80009e74:	c0 28       	rjmp	80009e78 <_dtoa_r+0xbb4>
80009e76:	50 66       	stdsp	sp[0x18],r6
80009e78:	0e 9c       	mov	r12,r7
80009e7a:	06 9b       	mov	r11,r3
80009e7c:	e0 a0 04 dc 	rcall	8000a834 <_Bfree>
80009e80:	30 08       	mov	r8,0
80009e82:	aa 88       	st.b	r5[0x0],r8
80009e84:	40 68       	lddsp	r8,sp[0x18]
80009e86:	41 5a       	lddsp	r10,sp[0x54]
80009e88:	2f f8       	sub	r8,-1
80009e8a:	41 29       	lddsp	r9,sp[0x48]
80009e8c:	95 08       	st.w	r10[0x0],r8
80009e8e:	40 8c       	lddsp	r12,sp[0x20]
80009e90:	58 09       	cp.w	r9,0
80009e92:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009e96:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009e9a:	2e 6d       	sub	sp,-104
80009e9c:	d8 32       	popm	r0-r7,pc
80009e9e:	d7 03       	nop

80009ea0 <__errno>:
80009ea0:	e0 68 0a 2c 	mov	r8,2604
80009ea4:	70 0c       	ld.w	r12,r8[0x0]
80009ea6:	2f 4c       	sub	r12,-12
80009ea8:	5e fc       	retal	r12
80009eaa:	d7 03       	nop

80009eac <_fflush_r>:
80009eac:	d4 21       	pushm	r4-r7,lr
80009eae:	16 97       	mov	r7,r11
80009eb0:	18 96       	mov	r6,r12
80009eb2:	76 48       	ld.w	r8,r11[0x10]
80009eb4:	58 08       	cp.w	r8,0
80009eb6:	c7 f0       	breq	80009fb4 <_fflush_r+0x108>
80009eb8:	58 0c       	cp.w	r12,0
80009eba:	c0 50       	breq	80009ec4 <_fflush_r+0x18>
80009ebc:	78 68       	ld.w	r8,r12[0x18]
80009ebe:	58 08       	cp.w	r8,0
80009ec0:	c0 21       	brne	80009ec4 <_fflush_r+0x18>
80009ec2:	cc dc       	rcall	8000a05c <__sinit>
80009ec4:	fe c8 cf b4 	sub	r8,pc,-12364
80009ec8:	10 37       	cp.w	r7,r8
80009eca:	c0 31       	brne	80009ed0 <_fflush_r+0x24>
80009ecc:	6c 07       	ld.w	r7,r6[0x0]
80009ece:	c0 c8       	rjmp	80009ee6 <_fflush_r+0x3a>
80009ed0:	fe c8 cf a0 	sub	r8,pc,-12384
80009ed4:	10 37       	cp.w	r7,r8
80009ed6:	c0 31       	brne	80009edc <_fflush_r+0x30>
80009ed8:	6c 17       	ld.w	r7,r6[0x4]
80009eda:	c0 68       	rjmp	80009ee6 <_fflush_r+0x3a>
80009edc:	fe c8 cf 8c 	sub	r8,pc,-12404
80009ee0:	10 37       	cp.w	r7,r8
80009ee2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009ee6:	8e 6a       	ld.sh	r10,r7[0xc]
80009ee8:	14 98       	mov	r8,r10
80009eea:	ed ba 00 03 	bld	r10,0x3
80009eee:	c4 20       	breq	80009f72 <_fflush_r+0xc6>
80009ef0:	ab ba       	sbr	r10,0xb
80009ef2:	ae 6a       	st.h	r7[0xc],r10
80009ef4:	6e 18       	ld.w	r8,r7[0x4]
80009ef6:	58 08       	cp.w	r8,0
80009ef8:	e0 89 00 06 	brgt	80009f04 <_fflush_r+0x58>
80009efc:	6f 08       	ld.w	r8,r7[0x40]
80009efe:	58 08       	cp.w	r8,0
80009f00:	e0 8a 00 5a 	brle	80009fb4 <_fflush_r+0x108>
80009f04:	6e b8       	ld.w	r8,r7[0x2c]
80009f06:	58 08       	cp.w	r8,0
80009f08:	c5 60       	breq	80009fb4 <_fflush_r+0x108>
80009f0a:	e2 1a 10 00 	andl	r10,0x1000,COH
80009f0e:	c0 30       	breq	80009f14 <_fflush_r+0x68>
80009f10:	6f 55       	ld.w	r5,r7[0x54]
80009f12:	c0 f8       	rjmp	80009f30 <_fflush_r+0x84>
80009f14:	30 19       	mov	r9,1
80009f16:	6e 8b       	ld.w	r11,r7[0x20]
80009f18:	0c 9c       	mov	r12,r6
80009f1a:	5d 18       	icall	r8
80009f1c:	18 95       	mov	r5,r12
80009f1e:	5b fc       	cp.w	r12,-1
80009f20:	c0 81       	brne	80009f30 <_fflush_r+0x84>
80009f22:	6c 38       	ld.w	r8,r6[0xc]
80009f24:	59 d8       	cp.w	r8,29
80009f26:	c4 70       	breq	80009fb4 <_fflush_r+0x108>
80009f28:	8e 68       	ld.sh	r8,r7[0xc]
80009f2a:	a7 a8       	sbr	r8,0x6
80009f2c:	ae 68       	st.h	r7[0xc],r8
80009f2e:	d8 22       	popm	r4-r7,pc
80009f30:	8e 68       	ld.sh	r8,r7[0xc]
80009f32:	ed b8 00 02 	bld	r8,0x2
80009f36:	c0 91       	brne	80009f48 <_fflush_r+0x9c>
80009f38:	6e 18       	ld.w	r8,r7[0x4]
80009f3a:	10 15       	sub	r5,r8
80009f3c:	6e d8       	ld.w	r8,r7[0x34]
80009f3e:	58 08       	cp.w	r8,0
80009f40:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009f44:	eb d8 e1 15 	subne	r5,r5,r8
80009f48:	6e b8       	ld.w	r8,r7[0x2c]
80009f4a:	0c 9c       	mov	r12,r6
80009f4c:	30 09       	mov	r9,0
80009f4e:	0a 9a       	mov	r10,r5
80009f50:	6e 8b       	ld.w	r11,r7[0x20]
80009f52:	5d 18       	icall	r8
80009f54:	8e 68       	ld.sh	r8,r7[0xc]
80009f56:	0a 3c       	cp.w	r12,r5
80009f58:	c2 61       	brne	80009fa4 <_fflush_r+0xf8>
80009f5a:	ab d8       	cbr	r8,0xb
80009f5c:	30 0c       	mov	r12,0
80009f5e:	6e 49       	ld.w	r9,r7[0x10]
80009f60:	ae 68       	st.h	r7[0xc],r8
80009f62:	8f 1c       	st.w	r7[0x4],r12
80009f64:	8f 09       	st.w	r7[0x0],r9
80009f66:	ed b8 00 0c 	bld	r8,0xc
80009f6a:	c2 51       	brne	80009fb4 <_fflush_r+0x108>
80009f6c:	ef 45 00 54 	st.w	r7[84],r5
80009f70:	d8 22       	popm	r4-r7,pc
80009f72:	6e 45       	ld.w	r5,r7[0x10]
80009f74:	58 05       	cp.w	r5,0
80009f76:	c1 f0       	breq	80009fb4 <_fflush_r+0x108>
80009f78:	6e 04       	ld.w	r4,r7[0x0]
80009f7a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009f7e:	8f 05       	st.w	r7[0x0],r5
80009f80:	f9 b8 01 00 	movne	r8,0
80009f84:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009f88:	0a 14       	sub	r4,r5
80009f8a:	8f 28       	st.w	r7[0x8],r8
80009f8c:	c1 18       	rjmp	80009fae <_fflush_r+0x102>
80009f8e:	08 99       	mov	r9,r4
80009f90:	0a 9a       	mov	r10,r5
80009f92:	6e a8       	ld.w	r8,r7[0x28]
80009f94:	6e 8b       	ld.w	r11,r7[0x20]
80009f96:	0c 9c       	mov	r12,r6
80009f98:	5d 18       	icall	r8
80009f9a:	18 14       	sub	r4,r12
80009f9c:	58 0c       	cp.w	r12,0
80009f9e:	e0 89 00 07 	brgt	80009fac <_fflush_r+0x100>
80009fa2:	8e 68       	ld.sh	r8,r7[0xc]
80009fa4:	a7 a8       	sbr	r8,0x6
80009fa6:	3f fc       	mov	r12,-1
80009fa8:	ae 68       	st.h	r7[0xc],r8
80009faa:	d8 22       	popm	r4-r7,pc
80009fac:	18 05       	add	r5,r12
80009fae:	58 04       	cp.w	r4,0
80009fb0:	fe 99 ff ef 	brgt	80009f8e <_fflush_r+0xe2>
80009fb4:	d8 2a       	popm	r4-r7,pc,r12=0
80009fb6:	d7 03       	nop

80009fb8 <__sfp_lock_acquire>:
80009fb8:	5e fc       	retal	r12

80009fba <__sfp_lock_release>:
80009fba:	5e fc       	retal	r12

80009fbc <_cleanup_r>:
80009fbc:	d4 01       	pushm	lr
80009fbe:	fe cb f0 ae 	sub	r11,pc,-3922
80009fc2:	e0 a0 02 f7 	rcall	8000a5b0 <_fwalk>
80009fc6:	d8 02       	popm	pc

80009fc8 <__sfmoreglue>:
80009fc8:	d4 21       	pushm	r4-r7,lr
80009fca:	16 95       	mov	r5,r11
80009fcc:	f6 06 10 5c 	mul	r6,r11,92
80009fd0:	ec cb ff f4 	sub	r11,r6,-12
80009fd4:	fe b0 e2 88 	rcall	800064e4 <_malloc_r>
80009fd8:	18 97       	mov	r7,r12
80009fda:	c0 90       	breq	80009fec <__sfmoreglue+0x24>
80009fdc:	99 15       	st.w	r12[0x4],r5
80009fde:	30 0b       	mov	r11,0
80009fe0:	2f 4c       	sub	r12,-12
80009fe2:	0c 9a       	mov	r10,r6
80009fe4:	8f 2c       	st.w	r7[0x8],r12
80009fe6:	8f 0b       	st.w	r7[0x0],r11
80009fe8:	fe b0 e5 3e 	rcall	80006a64 <memset>
80009fec:	0e 9c       	mov	r12,r7
80009fee:	d8 22       	popm	r4-r7,pc

80009ff0 <__sfp>:
80009ff0:	d4 21       	pushm	r4-r7,lr
80009ff2:	fe c8 d0 7e 	sub	r8,pc,-12162
80009ff6:	18 96       	mov	r6,r12
80009ff8:	70 07       	ld.w	r7,r8[0x0]
80009ffa:	6e 68       	ld.w	r8,r7[0x18]
80009ffc:	58 08       	cp.w	r8,0
80009ffe:	c0 31       	brne	8000a004 <__sfp+0x14>
8000a000:	0e 9c       	mov	r12,r7
8000a002:	c2 dc       	rcall	8000a05c <__sinit>
8000a004:	ee c7 ff 28 	sub	r7,r7,-216
8000a008:	30 05       	mov	r5,0
8000a00a:	6e 2c       	ld.w	r12,r7[0x8]
8000a00c:	6e 18       	ld.w	r8,r7[0x4]
8000a00e:	c0 68       	rjmp	8000a01a <__sfp+0x2a>
8000a010:	98 69       	ld.sh	r9,r12[0xc]
8000a012:	ea 09 19 00 	cp.h	r9,r5
8000a016:	c1 10       	breq	8000a038 <__sfp+0x48>
8000a018:	2a 4c       	sub	r12,-92
8000a01a:	20 18       	sub	r8,1
8000a01c:	cf a7       	brpl	8000a010 <__sfp+0x20>
8000a01e:	6e 08       	ld.w	r8,r7[0x0]
8000a020:	58 08       	cp.w	r8,0
8000a022:	c0 61       	brne	8000a02e <__sfp+0x3e>
8000a024:	30 4b       	mov	r11,4
8000a026:	0c 9c       	mov	r12,r6
8000a028:	cd 0f       	rcall	80009fc8 <__sfmoreglue>
8000a02a:	8f 0c       	st.w	r7[0x0],r12
8000a02c:	c0 30       	breq	8000a032 <__sfp+0x42>
8000a02e:	6e 07       	ld.w	r7,r7[0x0]
8000a030:	ce db       	rjmp	8000a00a <__sfp+0x1a>
8000a032:	30 c8       	mov	r8,12
8000a034:	8d 38       	st.w	r6[0xc],r8
8000a036:	d8 22       	popm	r4-r7,pc
8000a038:	30 08       	mov	r8,0
8000a03a:	f9 48 00 4c 	st.w	r12[76],r8
8000a03e:	99 08       	st.w	r12[0x0],r8
8000a040:	99 28       	st.w	r12[0x8],r8
8000a042:	99 18       	st.w	r12[0x4],r8
8000a044:	99 48       	st.w	r12[0x10],r8
8000a046:	99 58       	st.w	r12[0x14],r8
8000a048:	99 68       	st.w	r12[0x18],r8
8000a04a:	99 d8       	st.w	r12[0x34],r8
8000a04c:	99 e8       	st.w	r12[0x38],r8
8000a04e:	f9 48 00 48 	st.w	r12[72],r8
8000a052:	3f f8       	mov	r8,-1
8000a054:	b8 78       	st.h	r12[0xe],r8
8000a056:	30 18       	mov	r8,1
8000a058:	b8 68       	st.h	r12[0xc],r8
8000a05a:	d8 22       	popm	r4-r7,pc

8000a05c <__sinit>:
8000a05c:	d4 21       	pushm	r4-r7,lr
8000a05e:	18 96       	mov	r6,r12
8000a060:	78 67       	ld.w	r7,r12[0x18]
8000a062:	58 07       	cp.w	r7,0
8000a064:	c4 91       	brne	8000a0f6 <__sinit+0x9a>
8000a066:	fe c8 00 aa 	sub	r8,pc,170
8000a06a:	30 15       	mov	r5,1
8000a06c:	99 a8       	st.w	r12[0x28],r8
8000a06e:	f9 47 00 d8 	st.w	r12[216],r7
8000a072:	f9 47 00 dc 	st.w	r12[220],r7
8000a076:	f9 47 00 e0 	st.w	r12[224],r7
8000a07a:	99 65       	st.w	r12[0x18],r5
8000a07c:	cb af       	rcall	80009ff0 <__sfp>
8000a07e:	8d 0c       	st.w	r6[0x0],r12
8000a080:	0c 9c       	mov	r12,r6
8000a082:	cb 7f       	rcall	80009ff0 <__sfp>
8000a084:	8d 1c       	st.w	r6[0x4],r12
8000a086:	0c 9c       	mov	r12,r6
8000a088:	cb 4f       	rcall	80009ff0 <__sfp>
8000a08a:	6c 09       	ld.w	r9,r6[0x0]
8000a08c:	30 48       	mov	r8,4
8000a08e:	93 07       	st.w	r9[0x0],r7
8000a090:	b2 68       	st.h	r9[0xc],r8
8000a092:	93 17       	st.w	r9[0x4],r7
8000a094:	93 27       	st.w	r9[0x8],r7
8000a096:	6c 18       	ld.w	r8,r6[0x4]
8000a098:	b2 77       	st.h	r9[0xe],r7
8000a09a:	93 47       	st.w	r9[0x10],r7
8000a09c:	93 57       	st.w	r9[0x14],r7
8000a09e:	93 67       	st.w	r9[0x18],r7
8000a0a0:	93 89       	st.w	r9[0x20],r9
8000a0a2:	91 07       	st.w	r8[0x0],r7
8000a0a4:	91 17       	st.w	r8[0x4],r7
8000a0a6:	91 27       	st.w	r8[0x8],r7
8000a0a8:	fe ce f3 24 	sub	lr,pc,-3292
8000a0ac:	fe cb f3 54 	sub	r11,pc,-3244
8000a0b0:	93 9e       	st.w	r9[0x24],lr
8000a0b2:	93 ab       	st.w	r9[0x28],r11
8000a0b4:	fe ca f3 7c 	sub	r10,pc,-3204
8000a0b8:	fe c4 f3 88 	sub	r4,pc,-3192
8000a0bc:	93 ba       	st.w	r9[0x2c],r10
8000a0be:	93 c4       	st.w	r9[0x30],r4
8000a0c0:	30 99       	mov	r9,9
8000a0c2:	b0 69       	st.h	r8[0xc],r9
8000a0c4:	b0 75       	st.h	r8[0xe],r5
8000a0c6:	91 c4       	st.w	r8[0x30],r4
8000a0c8:	91 47       	st.w	r8[0x10],r7
8000a0ca:	91 57       	st.w	r8[0x14],r7
8000a0cc:	91 67       	st.w	r8[0x18],r7
8000a0ce:	91 88       	st.w	r8[0x20],r8
8000a0d0:	91 9e       	st.w	r8[0x24],lr
8000a0d2:	91 ab       	st.w	r8[0x28],r11
8000a0d4:	91 ba       	st.w	r8[0x2c],r10
8000a0d6:	8d 2c       	st.w	r6[0x8],r12
8000a0d8:	31 28       	mov	r8,18
8000a0da:	99 07       	st.w	r12[0x0],r7
8000a0dc:	b8 68       	st.h	r12[0xc],r8
8000a0de:	99 17       	st.w	r12[0x4],r7
8000a0e0:	99 27       	st.w	r12[0x8],r7
8000a0e2:	30 28       	mov	r8,2
8000a0e4:	b8 78       	st.h	r12[0xe],r8
8000a0e6:	99 c4       	st.w	r12[0x30],r4
8000a0e8:	99 67       	st.w	r12[0x18],r7
8000a0ea:	99 9e       	st.w	r12[0x24],lr
8000a0ec:	99 ab       	st.w	r12[0x28],r11
8000a0ee:	99 ba       	st.w	r12[0x2c],r10
8000a0f0:	99 47       	st.w	r12[0x10],r7
8000a0f2:	99 57       	st.w	r12[0x14],r7
8000a0f4:	99 8c       	st.w	r12[0x20],r12
8000a0f6:	d8 22       	popm	r4-r7,pc

8000a0f8 <_malloc_trim_r>:
8000a0f8:	d4 21       	pushm	r4-r7,lr
8000a0fa:	16 95       	mov	r5,r11
8000a0fc:	18 97       	mov	r7,r12
8000a0fe:	fe b0 d7 f1 	rcall	800050e0 <__malloc_lock>
8000a102:	e0 64 05 2c 	mov	r4,1324
8000a106:	68 28       	ld.w	r8,r4[0x8]
8000a108:	70 16       	ld.w	r6,r8[0x4]
8000a10a:	e0 16 ff fc 	andl	r6,0xfffc
8000a10e:	ec c8 ff 91 	sub	r8,r6,-111
8000a112:	f0 05 01 05 	sub	r5,r8,r5
8000a116:	e0 15 ff 80 	andl	r5,0xff80
8000a11a:	ea c5 00 80 	sub	r5,r5,128
8000a11e:	e0 45 00 7f 	cp.w	r5,127
8000a122:	e0 8a 00 25 	brle	8000a16c <_malloc_trim_r+0x74>
8000a126:	30 0b       	mov	r11,0
8000a128:	0e 9c       	mov	r12,r7
8000a12a:	fe b0 e6 05 	rcall	80006d34 <_sbrk_r>
8000a12e:	68 28       	ld.w	r8,r4[0x8]
8000a130:	0c 08       	add	r8,r6
8000a132:	10 3c       	cp.w	r12,r8
8000a134:	c1 c1       	brne	8000a16c <_malloc_trim_r+0x74>
8000a136:	ea 0b 11 00 	rsub	r11,r5,0
8000a13a:	0e 9c       	mov	r12,r7
8000a13c:	fe b0 e5 fc 	rcall	80006d34 <_sbrk_r>
8000a140:	5b fc       	cp.w	r12,-1
8000a142:	c1 91       	brne	8000a174 <_malloc_trim_r+0x7c>
8000a144:	30 0b       	mov	r11,0
8000a146:	0e 9c       	mov	r12,r7
8000a148:	fe b0 e5 f6 	rcall	80006d34 <_sbrk_r>
8000a14c:	68 28       	ld.w	r8,r4[0x8]
8000a14e:	f8 08 01 09 	sub	r9,r12,r8
8000a152:	58 f9       	cp.w	r9,15
8000a154:	e0 8a 00 0c 	brle	8000a16c <_malloc_trim_r+0x74>
8000a158:	a1 a9       	sbr	r9,0x0
8000a15a:	91 19       	st.w	r8[0x4],r9
8000a15c:	e0 68 09 38 	mov	r8,2360
8000a160:	70 09       	ld.w	r9,r8[0x0]
8000a162:	e0 68 0d 44 	mov	r8,3396
8000a166:	f8 09 01 09 	sub	r9,r12,r9
8000a16a:	91 09       	st.w	r8[0x0],r9
8000a16c:	0e 9c       	mov	r12,r7
8000a16e:	fe b0 d7 bf 	rcall	800050ec <__malloc_unlock>
8000a172:	d8 2a       	popm	r4-r7,pc,r12=0
8000a174:	68 28       	ld.w	r8,r4[0x8]
8000a176:	0a 16       	sub	r6,r5
8000a178:	a1 a6       	sbr	r6,0x0
8000a17a:	91 16       	st.w	r8[0x4],r6
8000a17c:	e0 68 0d 44 	mov	r8,3396
8000a180:	70 09       	ld.w	r9,r8[0x0]
8000a182:	0a 19       	sub	r9,r5
8000a184:	0e 9c       	mov	r12,r7
8000a186:	91 09       	st.w	r8[0x0],r9
8000a188:	fe b0 d7 b2 	rcall	800050ec <__malloc_unlock>
8000a18c:	da 2a       	popm	r4-r7,pc,r12=1
8000a18e:	d7 03       	nop

8000a190 <_free_r>:
8000a190:	d4 21       	pushm	r4-r7,lr
8000a192:	16 96       	mov	r6,r11
8000a194:	18 97       	mov	r7,r12
8000a196:	58 0b       	cp.w	r11,0
8000a198:	e0 80 00 c0 	breq	8000a318 <_free_r+0x188>
8000a19c:	fe b0 d7 a2 	rcall	800050e0 <__malloc_lock>
8000a1a0:	20 86       	sub	r6,8
8000a1a2:	e0 6a 05 2c 	mov	r10,1324
8000a1a6:	6c 18       	ld.w	r8,r6[0x4]
8000a1a8:	74 2e       	ld.w	lr,r10[0x8]
8000a1aa:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a1ae:	a1 c8       	cbr	r8,0x0
8000a1b0:	ec 08 00 09 	add	r9,r6,r8
8000a1b4:	72 1b       	ld.w	r11,r9[0x4]
8000a1b6:	e0 1b ff fc 	andl	r11,0xfffc
8000a1ba:	1c 39       	cp.w	r9,lr
8000a1bc:	c1 e1       	brne	8000a1f8 <_free_r+0x68>
8000a1be:	f6 08 00 08 	add	r8,r11,r8
8000a1c2:	58 0c       	cp.w	r12,0
8000a1c4:	c0 81       	brne	8000a1d4 <_free_r+0x44>
8000a1c6:	6c 09       	ld.w	r9,r6[0x0]
8000a1c8:	12 16       	sub	r6,r9
8000a1ca:	12 08       	add	r8,r9
8000a1cc:	6c 3b       	ld.w	r11,r6[0xc]
8000a1ce:	6c 29       	ld.w	r9,r6[0x8]
8000a1d0:	97 29       	st.w	r11[0x8],r9
8000a1d2:	93 3b       	st.w	r9[0xc],r11
8000a1d4:	10 99       	mov	r9,r8
8000a1d6:	95 26       	st.w	r10[0x8],r6
8000a1d8:	a1 a9       	sbr	r9,0x0
8000a1da:	8d 19       	st.w	r6[0x4],r9
8000a1dc:	e0 69 09 34 	mov	r9,2356
8000a1e0:	72 09       	ld.w	r9,r9[0x0]
8000a1e2:	12 38       	cp.w	r8,r9
8000a1e4:	c0 63       	brcs	8000a1f0 <_free_r+0x60>
8000a1e6:	e0 68 0d 40 	mov	r8,3392
8000a1ea:	0e 9c       	mov	r12,r7
8000a1ec:	70 0b       	ld.w	r11,r8[0x0]
8000a1ee:	c8 5f       	rcall	8000a0f8 <_malloc_trim_r>
8000a1f0:	0e 9c       	mov	r12,r7
8000a1f2:	fe b0 d7 7d 	rcall	800050ec <__malloc_unlock>
8000a1f6:	d8 22       	popm	r4-r7,pc
8000a1f8:	93 1b       	st.w	r9[0x4],r11
8000a1fa:	58 0c       	cp.w	r12,0
8000a1fc:	c0 30       	breq	8000a202 <_free_r+0x72>
8000a1fe:	30 0c       	mov	r12,0
8000a200:	c1 08       	rjmp	8000a220 <_free_r+0x90>
8000a202:	6c 0e       	ld.w	lr,r6[0x0]
8000a204:	f4 c5 ff f8 	sub	r5,r10,-8
8000a208:	1c 16       	sub	r6,lr
8000a20a:	1c 08       	add	r8,lr
8000a20c:	6c 2e       	ld.w	lr,r6[0x8]
8000a20e:	0a 3e       	cp.w	lr,r5
8000a210:	f9 bc 00 01 	moveq	r12,1
8000a214:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a218:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a21c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a220:	f2 0b 00 0e 	add	lr,r9,r11
8000a224:	7c 1e       	ld.w	lr,lr[0x4]
8000a226:	ed be 00 00 	bld	lr,0x0
8000a22a:	c1 40       	breq	8000a252 <_free_r+0xc2>
8000a22c:	16 08       	add	r8,r11
8000a22e:	58 0c       	cp.w	r12,0
8000a230:	c0 d1       	brne	8000a24a <_free_r+0xba>
8000a232:	e0 6e 05 2c 	mov	lr,1324
8000a236:	72 2b       	ld.w	r11,r9[0x8]
8000a238:	2f 8e       	sub	lr,-8
8000a23a:	1c 3b       	cp.w	r11,lr
8000a23c:	c0 71       	brne	8000a24a <_free_r+0xba>
8000a23e:	97 36       	st.w	r11[0xc],r6
8000a240:	97 26       	st.w	r11[0x8],r6
8000a242:	8d 2b       	st.w	r6[0x8],r11
8000a244:	8d 3b       	st.w	r6[0xc],r11
8000a246:	30 1c       	mov	r12,1
8000a248:	c0 58       	rjmp	8000a252 <_free_r+0xc2>
8000a24a:	72 2b       	ld.w	r11,r9[0x8]
8000a24c:	72 39       	ld.w	r9,r9[0xc]
8000a24e:	93 2b       	st.w	r9[0x8],r11
8000a250:	97 39       	st.w	r11[0xc],r9
8000a252:	10 99       	mov	r9,r8
8000a254:	ec 08 09 08 	st.w	r6[r8],r8
8000a258:	a1 a9       	sbr	r9,0x0
8000a25a:	8d 19       	st.w	r6[0x4],r9
8000a25c:	58 0c       	cp.w	r12,0
8000a25e:	c5 a1       	brne	8000a312 <_free_r+0x182>
8000a260:	e0 48 01 ff 	cp.w	r8,511
8000a264:	e0 8b 00 13 	brhi	8000a28a <_free_r+0xfa>
8000a268:	a3 98       	lsr	r8,0x3
8000a26a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a26e:	72 2b       	ld.w	r11,r9[0x8]
8000a270:	8d 39       	st.w	r6[0xc],r9
8000a272:	8d 2b       	st.w	r6[0x8],r11
8000a274:	97 36       	st.w	r11[0xc],r6
8000a276:	93 26       	st.w	r9[0x8],r6
8000a278:	a3 48       	asr	r8,0x2
8000a27a:	74 19       	ld.w	r9,r10[0x4]
8000a27c:	30 1b       	mov	r11,1
8000a27e:	f6 08 09 48 	lsl	r8,r11,r8
8000a282:	f3 e8 10 08 	or	r8,r9,r8
8000a286:	95 18       	st.w	r10[0x4],r8
8000a288:	c4 58       	rjmp	8000a312 <_free_r+0x182>
8000a28a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a28e:	58 4b       	cp.w	r11,4
8000a290:	e0 8b 00 06 	brhi	8000a29c <_free_r+0x10c>
8000a294:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a298:	2c 8b       	sub	r11,-56
8000a29a:	c2 08       	rjmp	8000a2da <_free_r+0x14a>
8000a29c:	59 4b       	cp.w	r11,20
8000a29e:	e0 8b 00 04 	brhi	8000a2a6 <_free_r+0x116>
8000a2a2:	2a 5b       	sub	r11,-91
8000a2a4:	c1 b8       	rjmp	8000a2da <_free_r+0x14a>
8000a2a6:	e0 4b 00 54 	cp.w	r11,84
8000a2aa:	e0 8b 00 06 	brhi	8000a2b6 <_free_r+0x126>
8000a2ae:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a2b2:	29 2b       	sub	r11,-110
8000a2b4:	c1 38       	rjmp	8000a2da <_free_r+0x14a>
8000a2b6:	e0 4b 01 54 	cp.w	r11,340
8000a2ba:	e0 8b 00 06 	brhi	8000a2c6 <_free_r+0x136>
8000a2be:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a2c2:	28 9b       	sub	r11,-119
8000a2c4:	c0 b8       	rjmp	8000a2da <_free_r+0x14a>
8000a2c6:	e0 4b 05 54 	cp.w	r11,1364
8000a2ca:	e0 88 00 05 	brls	8000a2d4 <_free_r+0x144>
8000a2ce:	37 eb       	mov	r11,126
8000a2d0:	c0 58       	rjmp	8000a2da <_free_r+0x14a>
8000a2d2:	d7 03       	nop
8000a2d4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a2d8:	28 4b       	sub	r11,-124
8000a2da:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a2de:	78 29       	ld.w	r9,r12[0x8]
8000a2e0:	18 39       	cp.w	r9,r12
8000a2e2:	c0 e1       	brne	8000a2fe <_free_r+0x16e>
8000a2e4:	74 18       	ld.w	r8,r10[0x4]
8000a2e6:	a3 4b       	asr	r11,0x2
8000a2e8:	30 1c       	mov	r12,1
8000a2ea:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a2ee:	f1 eb 10 0b 	or	r11,r8,r11
8000a2f2:	12 98       	mov	r8,r9
8000a2f4:	95 1b       	st.w	r10[0x4],r11
8000a2f6:	c0 a8       	rjmp	8000a30a <_free_r+0x17a>
8000a2f8:	72 29       	ld.w	r9,r9[0x8]
8000a2fa:	18 39       	cp.w	r9,r12
8000a2fc:	c0 60       	breq	8000a308 <_free_r+0x178>
8000a2fe:	72 1a       	ld.w	r10,r9[0x4]
8000a300:	e0 1a ff fc 	andl	r10,0xfffc
8000a304:	14 38       	cp.w	r8,r10
8000a306:	cf 93       	brcs	8000a2f8 <_free_r+0x168>
8000a308:	72 38       	ld.w	r8,r9[0xc]
8000a30a:	8d 38       	st.w	r6[0xc],r8
8000a30c:	8d 29       	st.w	r6[0x8],r9
8000a30e:	93 36       	st.w	r9[0xc],r6
8000a310:	91 26       	st.w	r8[0x8],r6
8000a312:	0e 9c       	mov	r12,r7
8000a314:	fe b0 d6 ec 	rcall	800050ec <__malloc_unlock>
8000a318:	d8 22       	popm	r4-r7,pc
8000a31a:	d7 03       	nop

8000a31c <__sfvwrite_r>:
8000a31c:	d4 31       	pushm	r0-r7,lr
8000a31e:	20 3d       	sub	sp,12
8000a320:	14 94       	mov	r4,r10
8000a322:	18 95       	mov	r5,r12
8000a324:	16 97       	mov	r7,r11
8000a326:	74 28       	ld.w	r8,r10[0x8]
8000a328:	58 08       	cp.w	r8,0
8000a32a:	e0 80 01 40 	breq	8000a5aa <__sfvwrite_r+0x28e>
8000a32e:	96 68       	ld.sh	r8,r11[0xc]
8000a330:	ed b8 00 03 	bld	r8,0x3
8000a334:	c0 41       	brne	8000a33c <__sfvwrite_r+0x20>
8000a336:	76 48       	ld.w	r8,r11[0x10]
8000a338:	58 08       	cp.w	r8,0
8000a33a:	c0 c1       	brne	8000a352 <__sfvwrite_r+0x36>
8000a33c:	0e 9b       	mov	r11,r7
8000a33e:	0a 9c       	mov	r12,r5
8000a340:	fe b0 f6 c4 	rcall	800090c8 <__swsetup_r>
8000a344:	c0 70       	breq	8000a352 <__sfvwrite_r+0x36>
8000a346:	8e 68       	ld.sh	r8,r7[0xc]
8000a348:	a7 a8       	sbr	r8,0x6
8000a34a:	ae 68       	st.h	r7[0xc],r8
8000a34c:	30 98       	mov	r8,9
8000a34e:	8b 38       	st.w	r5[0xc],r8
8000a350:	c2 b9       	rjmp	8000a5a6 <__sfvwrite_r+0x28a>
8000a352:	8e 63       	ld.sh	r3,r7[0xc]
8000a354:	68 00       	ld.w	r0,r4[0x0]
8000a356:	06 96       	mov	r6,r3
8000a358:	e2 16 00 02 	andl	r6,0x2,COH
8000a35c:	c2 10       	breq	8000a39e <__sfvwrite_r+0x82>
8000a35e:	30 03       	mov	r3,0
8000a360:	e0 62 04 00 	mov	r2,1024
8000a364:	06 96       	mov	r6,r3
8000a366:	c0 48       	rjmp	8000a36e <__sfvwrite_r+0x52>
8000a368:	60 03       	ld.w	r3,r0[0x0]
8000a36a:	60 16       	ld.w	r6,r0[0x4]
8000a36c:	2f 80       	sub	r0,-8
8000a36e:	58 06       	cp.w	r6,0
8000a370:	cf c0       	breq	8000a368 <__sfvwrite_r+0x4c>
8000a372:	e0 46 04 00 	cp.w	r6,1024
8000a376:	ec 09 17 80 	movls	r9,r6
8000a37a:	e4 09 17 b0 	movhi	r9,r2
8000a37e:	06 9a       	mov	r10,r3
8000a380:	6e a8       	ld.w	r8,r7[0x28]
8000a382:	6e 8b       	ld.w	r11,r7[0x20]
8000a384:	0a 9c       	mov	r12,r5
8000a386:	5d 18       	icall	r8
8000a388:	18 16       	sub	r6,r12
8000a38a:	58 0c       	cp.w	r12,0
8000a38c:	e0 8a 01 0a 	brle	8000a5a0 <__sfvwrite_r+0x284>
8000a390:	68 28       	ld.w	r8,r4[0x8]
8000a392:	18 18       	sub	r8,r12
8000a394:	89 28       	st.w	r4[0x8],r8
8000a396:	e0 80 01 0a 	breq	8000a5aa <__sfvwrite_r+0x28e>
8000a39a:	18 03       	add	r3,r12
8000a39c:	ce 9b       	rjmp	8000a36e <__sfvwrite_r+0x52>
8000a39e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a3a2:	c0 70       	breq	8000a3b0 <__sfvwrite_r+0x94>
8000a3a4:	50 06       	stdsp	sp[0x0],r6
8000a3a6:	0c 93       	mov	r3,r6
8000a3a8:	0c 91       	mov	r1,r6
8000a3aa:	50 15       	stdsp	sp[0x4],r5
8000a3ac:	08 92       	mov	r2,r4
8000a3ae:	c9 c8       	rjmp	8000a4e6 <__sfvwrite_r+0x1ca>
8000a3b0:	06 96       	mov	r6,r3
8000a3b2:	08 91       	mov	r1,r4
8000a3b4:	c0 48       	rjmp	8000a3bc <__sfvwrite_r+0xa0>
8000a3b6:	60 03       	ld.w	r3,r0[0x0]
8000a3b8:	60 16       	ld.w	r6,r0[0x4]
8000a3ba:	2f 80       	sub	r0,-8
8000a3bc:	58 06       	cp.w	r6,0
8000a3be:	cf c0       	breq	8000a3b6 <__sfvwrite_r+0x9a>
8000a3c0:	8e 68       	ld.sh	r8,r7[0xc]
8000a3c2:	6e 24       	ld.w	r4,r7[0x8]
8000a3c4:	10 99       	mov	r9,r8
8000a3c6:	e2 19 02 00 	andl	r9,0x200,COH
8000a3ca:	c5 50       	breq	8000a474 <__sfvwrite_r+0x158>
8000a3cc:	08 36       	cp.w	r6,r4
8000a3ce:	c4 43       	brcs	8000a456 <__sfvwrite_r+0x13a>
8000a3d0:	10 99       	mov	r9,r8
8000a3d2:	e2 19 04 80 	andl	r9,0x480,COH
8000a3d6:	c4 00       	breq	8000a456 <__sfvwrite_r+0x13a>
8000a3d8:	6e 4b       	ld.w	r11,r7[0x10]
8000a3da:	6e 09       	ld.w	r9,r7[0x0]
8000a3dc:	16 19       	sub	r9,r11
8000a3de:	50 09       	stdsp	sp[0x0],r9
8000a3e0:	6e 59       	ld.w	r9,r7[0x14]
8000a3e2:	10 9c       	mov	r12,r8
8000a3e4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a3e8:	30 28       	mov	r8,2
8000a3ea:	f4 08 0c 08 	divs	r8,r10,r8
8000a3ee:	fa e9 00 04 	st.d	sp[4],r8
8000a3f2:	10 94       	mov	r4,r8
8000a3f4:	40 09       	lddsp	r9,sp[0x0]
8000a3f6:	e2 1c 04 00 	andl	r12,0x400,COH
8000a3fa:	2f f9       	sub	r9,-1
8000a3fc:	0c 09       	add	r9,r6
8000a3fe:	12 38       	cp.w	r8,r9
8000a400:	f2 04 17 30 	movlo	r4,r9
8000a404:	58 0c       	cp.w	r12,0
8000a406:	c1 10       	breq	8000a428 <__sfvwrite_r+0x10c>
8000a408:	08 9b       	mov	r11,r4
8000a40a:	0a 9c       	mov	r12,r5
8000a40c:	fe b0 e0 6c 	rcall	800064e4 <_malloc_r>
8000a410:	18 92       	mov	r2,r12
8000a412:	c1 40       	breq	8000a43a <__sfvwrite_r+0x11e>
8000a414:	40 0a       	lddsp	r10,sp[0x0]
8000a416:	6e 4b       	ld.w	r11,r7[0x10]
8000a418:	fe b0 e2 82 	rcall	8000691c <memcpy>
8000a41c:	8e 68       	ld.sh	r8,r7[0xc]
8000a41e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a422:	a7 b8       	sbr	r8,0x7
8000a424:	ae 68       	st.h	r7[0xc],r8
8000a426:	c0 d8       	rjmp	8000a440 <__sfvwrite_r+0x124>
8000a428:	08 9a       	mov	r10,r4
8000a42a:	0a 9c       	mov	r12,r5
8000a42c:	fe b0 e3 24 	rcall	80006a74 <_realloc_r>
8000a430:	18 92       	mov	r2,r12
8000a432:	c0 71       	brne	8000a440 <__sfvwrite_r+0x124>
8000a434:	6e 4b       	ld.w	r11,r7[0x10]
8000a436:	0a 9c       	mov	r12,r5
8000a438:	ca ce       	rcall	8000a190 <_free_r>
8000a43a:	30 c8       	mov	r8,12
8000a43c:	8b 38       	st.w	r5[0xc],r8
8000a43e:	cb 18       	rjmp	8000a5a0 <__sfvwrite_r+0x284>
8000a440:	40 0a       	lddsp	r10,sp[0x0]
8000a442:	40 09       	lddsp	r9,sp[0x0]
8000a444:	e8 0a 01 0a 	sub	r10,r4,r10
8000a448:	e4 09 00 08 	add	r8,r2,r9
8000a44c:	8f 54       	st.w	r7[0x14],r4
8000a44e:	8f 2a       	st.w	r7[0x8],r10
8000a450:	8f 08       	st.w	r7[0x0],r8
8000a452:	8f 42       	st.w	r7[0x10],r2
8000a454:	0c 94       	mov	r4,r6
8000a456:	08 36       	cp.w	r6,r4
8000a458:	ec 04 17 30 	movlo	r4,r6
8000a45c:	06 9b       	mov	r11,r3
8000a45e:	08 9a       	mov	r10,r4
8000a460:	6e 0c       	ld.w	r12,r7[0x0]
8000a462:	c3 ad       	rcall	8000a6d6 <memmove>
8000a464:	6e 08       	ld.w	r8,r7[0x0]
8000a466:	08 08       	add	r8,r4
8000a468:	8f 08       	st.w	r7[0x0],r8
8000a46a:	6e 28       	ld.w	r8,r7[0x8]
8000a46c:	08 18       	sub	r8,r4
8000a46e:	0c 94       	mov	r4,r6
8000a470:	8f 28       	st.w	r7[0x8],r8
8000a472:	c2 e8       	rjmp	8000a4ce <__sfvwrite_r+0x1b2>
8000a474:	08 36       	cp.w	r6,r4
8000a476:	5f ba       	srhi	r10
8000a478:	6e 0c       	ld.w	r12,r7[0x0]
8000a47a:	6e 48       	ld.w	r8,r7[0x10]
8000a47c:	10 3c       	cp.w	r12,r8
8000a47e:	5f b8       	srhi	r8
8000a480:	f5 e8 00 08 	and	r8,r10,r8
8000a484:	f2 08 18 00 	cp.b	r8,r9
8000a488:	c0 d0       	breq	8000a4a2 <__sfvwrite_r+0x186>
8000a48a:	06 9b       	mov	r11,r3
8000a48c:	08 9a       	mov	r10,r4
8000a48e:	c2 4d       	rcall	8000a6d6 <memmove>
8000a490:	6e 08       	ld.w	r8,r7[0x0]
8000a492:	08 08       	add	r8,r4
8000a494:	0e 9b       	mov	r11,r7
8000a496:	8f 08       	st.w	r7[0x0],r8
8000a498:	0a 9c       	mov	r12,r5
8000a49a:	fe b0 fd 09 	rcall	80009eac <_fflush_r>
8000a49e:	c1 80       	breq	8000a4ce <__sfvwrite_r+0x1b2>
8000a4a0:	c8 08       	rjmp	8000a5a0 <__sfvwrite_r+0x284>
8000a4a2:	6e 59       	ld.w	r9,r7[0x14]
8000a4a4:	12 36       	cp.w	r6,r9
8000a4a6:	c0 a3       	brcs	8000a4ba <__sfvwrite_r+0x19e>
8000a4a8:	6e a8       	ld.w	r8,r7[0x28]
8000a4aa:	06 9a       	mov	r10,r3
8000a4ac:	6e 8b       	ld.w	r11,r7[0x20]
8000a4ae:	0a 9c       	mov	r12,r5
8000a4b0:	5d 18       	icall	r8
8000a4b2:	18 94       	mov	r4,r12
8000a4b4:	e0 89 00 0d 	brgt	8000a4ce <__sfvwrite_r+0x1b2>
8000a4b8:	c7 48       	rjmp	8000a5a0 <__sfvwrite_r+0x284>
8000a4ba:	0c 9a       	mov	r10,r6
8000a4bc:	06 9b       	mov	r11,r3
8000a4be:	c0 cd       	rcall	8000a6d6 <memmove>
8000a4c0:	6e 08       	ld.w	r8,r7[0x0]
8000a4c2:	0c 08       	add	r8,r6
8000a4c4:	0c 94       	mov	r4,r6
8000a4c6:	8f 08       	st.w	r7[0x0],r8
8000a4c8:	6e 28       	ld.w	r8,r7[0x8]
8000a4ca:	0c 18       	sub	r8,r6
8000a4cc:	8f 28       	st.w	r7[0x8],r8
8000a4ce:	62 28       	ld.w	r8,r1[0x8]
8000a4d0:	08 18       	sub	r8,r4
8000a4d2:	83 28       	st.w	r1[0x8],r8
8000a4d4:	c6 b0       	breq	8000a5aa <__sfvwrite_r+0x28e>
8000a4d6:	08 16       	sub	r6,r4
8000a4d8:	08 03       	add	r3,r4
8000a4da:	c7 1b       	rjmp	8000a3bc <__sfvwrite_r+0xa0>
8000a4dc:	60 03       	ld.w	r3,r0[0x0]
8000a4de:	60 11       	ld.w	r1,r0[0x4]
8000a4e0:	30 08       	mov	r8,0
8000a4e2:	2f 80       	sub	r0,-8
8000a4e4:	50 08       	stdsp	sp[0x0],r8
8000a4e6:	58 01       	cp.w	r1,0
8000a4e8:	cf a0       	breq	8000a4dc <__sfvwrite_r+0x1c0>
8000a4ea:	40 0a       	lddsp	r10,sp[0x0]
8000a4ec:	58 0a       	cp.w	r10,0
8000a4ee:	c1 41       	brne	8000a516 <__sfvwrite_r+0x1fa>
8000a4f0:	e2 c6 ff ff 	sub	r6,r1,-1
8000a4f4:	02 9a       	mov	r10,r1
8000a4f6:	30 ab       	mov	r11,10
8000a4f8:	06 9c       	mov	r12,r3
8000a4fa:	ce 3c       	rcall	8000a6c0 <memchr>
8000a4fc:	f8 c8 ff ff 	sub	r8,r12,-1
8000a500:	58 0c       	cp.w	r12,0
8000a502:	f1 d3 e1 16 	subne	r6,r8,r3
8000a506:	f9 b9 01 01 	movne	r9,1
8000a50a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a50e:	f9 b8 00 01 	moveq	r8,1
8000a512:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a516:	02 36       	cp.w	r6,r1
8000a518:	ec 04 17 80 	movls	r4,r6
8000a51c:	e2 04 17 b0 	movhi	r4,r1
8000a520:	6e 59       	ld.w	r9,r7[0x14]
8000a522:	6e 25       	ld.w	r5,r7[0x8]
8000a524:	f2 05 00 05 	add	r5,r9,r5
8000a528:	0a 34       	cp.w	r4,r5
8000a52a:	5f 9a       	srgt	r10
8000a52c:	6e 0c       	ld.w	r12,r7[0x0]
8000a52e:	6e 48       	ld.w	r8,r7[0x10]
8000a530:	10 3c       	cp.w	r12,r8
8000a532:	5f b8       	srhi	r8
8000a534:	f5 e8 00 08 	and	r8,r10,r8
8000a538:	30 0a       	mov	r10,0
8000a53a:	f4 08 18 00 	cp.b	r8,r10
8000a53e:	c0 d0       	breq	8000a558 <__sfvwrite_r+0x23c>
8000a540:	06 9b       	mov	r11,r3
8000a542:	0a 9a       	mov	r10,r5
8000a544:	cc 9c       	rcall	8000a6d6 <memmove>
8000a546:	6e 08       	ld.w	r8,r7[0x0]
8000a548:	0a 08       	add	r8,r5
8000a54a:	0e 9b       	mov	r11,r7
8000a54c:	8f 08       	st.w	r7[0x0],r8
8000a54e:	40 1c       	lddsp	r12,sp[0x4]
8000a550:	fe b0 fc ae 	rcall	80009eac <_fflush_r>
8000a554:	c1 70       	breq	8000a582 <__sfvwrite_r+0x266>
8000a556:	c2 58       	rjmp	8000a5a0 <__sfvwrite_r+0x284>
8000a558:	12 34       	cp.w	r4,r9
8000a55a:	c0 a5       	brlt	8000a56e <__sfvwrite_r+0x252>
8000a55c:	6e a8       	ld.w	r8,r7[0x28]
8000a55e:	06 9a       	mov	r10,r3
8000a560:	6e 8b       	ld.w	r11,r7[0x20]
8000a562:	40 1c       	lddsp	r12,sp[0x4]
8000a564:	5d 18       	icall	r8
8000a566:	18 95       	mov	r5,r12
8000a568:	e0 89 00 0d 	brgt	8000a582 <__sfvwrite_r+0x266>
8000a56c:	c1 a8       	rjmp	8000a5a0 <__sfvwrite_r+0x284>
8000a56e:	08 9a       	mov	r10,r4
8000a570:	06 9b       	mov	r11,r3
8000a572:	cb 2c       	rcall	8000a6d6 <memmove>
8000a574:	6e 08       	ld.w	r8,r7[0x0]
8000a576:	08 08       	add	r8,r4
8000a578:	08 95       	mov	r5,r4
8000a57a:	8f 08       	st.w	r7[0x0],r8
8000a57c:	6e 28       	ld.w	r8,r7[0x8]
8000a57e:	08 18       	sub	r8,r4
8000a580:	8f 28       	st.w	r7[0x8],r8
8000a582:	0a 16       	sub	r6,r5
8000a584:	c0 71       	brne	8000a592 <__sfvwrite_r+0x276>
8000a586:	0e 9b       	mov	r11,r7
8000a588:	40 1c       	lddsp	r12,sp[0x4]
8000a58a:	fe b0 fc 91 	rcall	80009eac <_fflush_r>
8000a58e:	c0 91       	brne	8000a5a0 <__sfvwrite_r+0x284>
8000a590:	50 06       	stdsp	sp[0x0],r6
8000a592:	64 28       	ld.w	r8,r2[0x8]
8000a594:	0a 18       	sub	r8,r5
8000a596:	85 28       	st.w	r2[0x8],r8
8000a598:	c0 90       	breq	8000a5aa <__sfvwrite_r+0x28e>
8000a59a:	0a 11       	sub	r1,r5
8000a59c:	0a 03       	add	r3,r5
8000a59e:	ca 4b       	rjmp	8000a4e6 <__sfvwrite_r+0x1ca>
8000a5a0:	8e 68       	ld.sh	r8,r7[0xc]
8000a5a2:	a7 a8       	sbr	r8,0x6
8000a5a4:	ae 68       	st.h	r7[0xc],r8
8000a5a6:	3f fc       	mov	r12,-1
8000a5a8:	c0 28       	rjmp	8000a5ac <__sfvwrite_r+0x290>
8000a5aa:	30 0c       	mov	r12,0
8000a5ac:	2f dd       	sub	sp,-12
8000a5ae:	d8 32       	popm	r0-r7,pc

8000a5b0 <_fwalk>:
8000a5b0:	d4 31       	pushm	r0-r7,lr
8000a5b2:	30 05       	mov	r5,0
8000a5b4:	16 91       	mov	r1,r11
8000a5b6:	f8 c7 ff 28 	sub	r7,r12,-216
8000a5ba:	0a 92       	mov	r2,r5
8000a5bc:	fe b0 fc fe 	rcall	80009fb8 <__sfp_lock_acquire>
8000a5c0:	3f f3       	mov	r3,-1
8000a5c2:	c1 68       	rjmp	8000a5ee <_fwalk+0x3e>
8000a5c4:	6e 26       	ld.w	r6,r7[0x8]
8000a5c6:	6e 14       	ld.w	r4,r7[0x4]
8000a5c8:	2f 46       	sub	r6,-12
8000a5ca:	c0 c8       	rjmp	8000a5e2 <_fwalk+0x32>
8000a5cc:	8c 08       	ld.sh	r8,r6[0x0]
8000a5ce:	e4 08 19 00 	cp.h	r8,r2
8000a5d2:	c0 70       	breq	8000a5e0 <_fwalk+0x30>
8000a5d4:	8c 18       	ld.sh	r8,r6[0x2]
8000a5d6:	e6 08 19 00 	cp.h	r8,r3
8000a5da:	c0 30       	breq	8000a5e0 <_fwalk+0x30>
8000a5dc:	5d 11       	icall	r1
8000a5de:	18 45       	or	r5,r12
8000a5e0:	2a 46       	sub	r6,-92
8000a5e2:	20 14       	sub	r4,1
8000a5e4:	ec cc 00 0c 	sub	r12,r6,12
8000a5e8:	58 04       	cp.w	r4,0
8000a5ea:	cf 14       	brge	8000a5cc <_fwalk+0x1c>
8000a5ec:	6e 07       	ld.w	r7,r7[0x0]
8000a5ee:	58 07       	cp.w	r7,0
8000a5f0:	ce a1       	brne	8000a5c4 <_fwalk+0x14>
8000a5f2:	fe b0 fc e4 	rcall	80009fba <__sfp_lock_release>
8000a5f6:	0a 9c       	mov	r12,r5
8000a5f8:	d8 32       	popm	r0-r7,pc
8000a5fa:	d7 03       	nop

8000a5fc <_localeconv_r>:
8000a5fc:	fe cc d6 84 	sub	r12,pc,-10620
8000a600:	5e fc       	retal	r12
8000a602:	d7 03       	nop

8000a604 <__smakebuf_r>:
8000a604:	d4 21       	pushm	r4-r7,lr
8000a606:	20 fd       	sub	sp,60
8000a608:	96 68       	ld.sh	r8,r11[0xc]
8000a60a:	16 97       	mov	r7,r11
8000a60c:	18 96       	mov	r6,r12
8000a60e:	e2 18 00 02 	andl	r8,0x2,COH
8000a612:	c3 d1       	brne	8000a68c <__smakebuf_r+0x88>
8000a614:	96 7b       	ld.sh	r11,r11[0xe]
8000a616:	f0 0b 19 00 	cp.h	r11,r8
8000a61a:	c0 55       	brlt	8000a624 <__smakebuf_r+0x20>
8000a61c:	1a 9a       	mov	r10,sp
8000a61e:	e0 a0 04 81 	rcall	8000af20 <_fstat_r>
8000a622:	c0 f4       	brge	8000a640 <__smakebuf_r+0x3c>
8000a624:	8e 65       	ld.sh	r5,r7[0xc]
8000a626:	0a 98       	mov	r8,r5
8000a628:	ab b8       	sbr	r8,0xb
8000a62a:	e2 15 00 80 	andl	r5,0x80,COH
8000a62e:	ae 68       	st.h	r7[0xc],r8
8000a630:	30 04       	mov	r4,0
8000a632:	e0 68 04 00 	mov	r8,1024
8000a636:	f9 b5 01 40 	movne	r5,64
8000a63a:	f0 05 17 00 	moveq	r5,r8
8000a63e:	c1 c8       	rjmp	8000a676 <__smakebuf_r+0x72>
8000a640:	40 18       	lddsp	r8,sp[0x4]
8000a642:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a646:	e0 48 20 00 	cp.w	r8,8192
8000a64a:	5f 04       	sreq	r4
8000a64c:	e0 48 80 00 	cp.w	r8,32768
8000a650:	c0 e1       	brne	8000a66c <__smakebuf_r+0x68>
8000a652:	6e b9       	ld.w	r9,r7[0x2c]
8000a654:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a658:	10 39       	cp.w	r9,r8
8000a65a:	c0 91       	brne	8000a66c <__smakebuf_r+0x68>
8000a65c:	8e 68       	ld.sh	r8,r7[0xc]
8000a65e:	e0 65 04 00 	mov	r5,1024
8000a662:	ab a8       	sbr	r8,0xa
8000a664:	ef 45 00 50 	st.w	r7[80],r5
8000a668:	ae 68       	st.h	r7[0xc],r8
8000a66a:	c0 68       	rjmp	8000a676 <__smakebuf_r+0x72>
8000a66c:	8e 68       	ld.sh	r8,r7[0xc]
8000a66e:	e0 65 04 00 	mov	r5,1024
8000a672:	ab b8       	sbr	r8,0xb
8000a674:	ae 68       	st.h	r7[0xc],r8
8000a676:	0a 9b       	mov	r11,r5
8000a678:	0c 9c       	mov	r12,r6
8000a67a:	fe b0 df 35 	rcall	800064e4 <_malloc_r>
8000a67e:	8e 68       	ld.sh	r8,r7[0xc]
8000a680:	c0 d1       	brne	8000a69a <__smakebuf_r+0x96>
8000a682:	ed b8 00 09 	bld	r8,0x9
8000a686:	c1 b0       	breq	8000a6bc <__smakebuf_r+0xb8>
8000a688:	a1 b8       	sbr	r8,0x1
8000a68a:	ae 68       	st.h	r7[0xc],r8
8000a68c:	ee c8 ff b9 	sub	r8,r7,-71
8000a690:	8f 48       	st.w	r7[0x10],r8
8000a692:	8f 08       	st.w	r7[0x0],r8
8000a694:	30 18       	mov	r8,1
8000a696:	8f 58       	st.w	r7[0x14],r8
8000a698:	c1 28       	rjmp	8000a6bc <__smakebuf_r+0xb8>
8000a69a:	a7 b8       	sbr	r8,0x7
8000a69c:	8f 4c       	st.w	r7[0x10],r12
8000a69e:	ae 68       	st.h	r7[0xc],r8
8000a6a0:	8f 55       	st.w	r7[0x14],r5
8000a6a2:	fe c8 06 e6 	sub	r8,pc,1766
8000a6a6:	8f 0c       	st.w	r7[0x0],r12
8000a6a8:	8d a8       	st.w	r6[0x28],r8
8000a6aa:	58 04       	cp.w	r4,0
8000a6ac:	c0 80       	breq	8000a6bc <__smakebuf_r+0xb8>
8000a6ae:	8e 7c       	ld.sh	r12,r7[0xe]
8000a6b0:	fe b0 e3 94 	rcall	80006dd8 <isatty>
8000a6b4:	c0 40       	breq	8000a6bc <__smakebuf_r+0xb8>
8000a6b6:	8e 68       	ld.sh	r8,r7[0xc]
8000a6b8:	a1 a8       	sbr	r8,0x0
8000a6ba:	ae 68       	st.h	r7[0xc],r8
8000a6bc:	2f 1d       	sub	sp,-60
8000a6be:	d8 22       	popm	r4-r7,pc

8000a6c0 <memchr>:
8000a6c0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a6c4:	c0 68       	rjmp	8000a6d0 <memchr+0x10>
8000a6c6:	20 1a       	sub	r10,1
8000a6c8:	19 88       	ld.ub	r8,r12[0x0]
8000a6ca:	16 38       	cp.w	r8,r11
8000a6cc:	5e 0c       	reteq	r12
8000a6ce:	2f fc       	sub	r12,-1
8000a6d0:	58 0a       	cp.w	r10,0
8000a6d2:	cf a1       	brne	8000a6c6 <memchr+0x6>
8000a6d4:	5e fa       	retal	r10

8000a6d6 <memmove>:
8000a6d6:	d4 01       	pushm	lr
8000a6d8:	18 3b       	cp.w	r11,r12
8000a6da:	c1 92       	brcc	8000a70c <memmove+0x36>
8000a6dc:	f6 0a 00 09 	add	r9,r11,r10
8000a6e0:	12 3c       	cp.w	r12,r9
8000a6e2:	c1 52       	brcc	8000a70c <memmove+0x36>
8000a6e4:	f8 0a 00 0b 	add	r11,r12,r10
8000a6e8:	30 08       	mov	r8,0
8000a6ea:	c0 68       	rjmp	8000a6f6 <memmove+0x20>
8000a6ec:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a6f0:	20 1a       	sub	r10,1
8000a6f2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a6f6:	20 18       	sub	r8,1
8000a6f8:	58 0a       	cp.w	r10,0
8000a6fa:	cf 91       	brne	8000a6ec <memmove+0x16>
8000a6fc:	d8 02       	popm	pc
8000a6fe:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a702:	20 1a       	sub	r10,1
8000a704:	f8 08 0b 09 	st.b	r12[r8],r9
8000a708:	2f f8       	sub	r8,-1
8000a70a:	c0 28       	rjmp	8000a70e <memmove+0x38>
8000a70c:	30 08       	mov	r8,0
8000a70e:	58 0a       	cp.w	r10,0
8000a710:	cf 71       	brne	8000a6fe <memmove+0x28>
8000a712:	d8 02       	popm	pc

8000a714 <__hi0bits>:
8000a714:	18 98       	mov	r8,r12
8000a716:	e0 1c 00 00 	andl	r12,0x0
8000a71a:	f0 09 15 10 	lsl	r9,r8,0x10
8000a71e:	58 0c       	cp.w	r12,0
8000a720:	f2 08 17 00 	moveq	r8,r9
8000a724:	f9 bc 00 10 	moveq	r12,16
8000a728:	f9 bc 01 00 	movne	r12,0
8000a72c:	10 9a       	mov	r10,r8
8000a72e:	f0 09 15 08 	lsl	r9,r8,0x8
8000a732:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a736:	f7 bc 00 f8 	subeq	r12,-8
8000a73a:	f2 08 17 00 	moveq	r8,r9
8000a73e:	10 9a       	mov	r10,r8
8000a740:	f0 09 15 04 	lsl	r9,r8,0x4
8000a744:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a748:	f7 bc 00 fc 	subeq	r12,-4
8000a74c:	f2 08 17 00 	moveq	r8,r9
8000a750:	10 9a       	mov	r10,r8
8000a752:	f0 09 15 02 	lsl	r9,r8,0x2
8000a756:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a75a:	f7 bc 00 fe 	subeq	r12,-2
8000a75e:	f2 08 17 00 	moveq	r8,r9
8000a762:	58 08       	cp.w	r8,0
8000a764:	5e 5c       	retlt	r12
8000a766:	ed b8 00 1e 	bld	r8,0x1e
8000a76a:	f9 bc 01 20 	movne	r12,32
8000a76e:	f7 bc 00 ff 	subeq	r12,-1
8000a772:	5e fc       	retal	r12

8000a774 <__lo0bits>:
8000a774:	18 99       	mov	r9,r12
8000a776:	78 08       	ld.w	r8,r12[0x0]
8000a778:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a77c:	c1 50       	breq	8000a7a6 <__lo0bits+0x32>
8000a77e:	ed b8 00 00 	bld	r8,0x0
8000a782:	c0 21       	brne	8000a786 <__lo0bits+0x12>
8000a784:	5e fd       	retal	0
8000a786:	10 9b       	mov	r11,r8
8000a788:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a78c:	e2 1b 00 02 	andl	r11,0x2,COH
8000a790:	a3 88       	lsr	r8,0x2
8000a792:	58 0b       	cp.w	r11,0
8000a794:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a798:	f9 bc 01 01 	movne	r12,1
8000a79c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a7a0:	f9 bc 00 02 	moveq	r12,2
8000a7a4:	5e fc       	retal	r12
8000a7a6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a7aa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a7ae:	58 0a       	cp.w	r10,0
8000a7b0:	f6 08 17 00 	moveq	r8,r11
8000a7b4:	f9 bc 00 10 	moveq	r12,16
8000a7b8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a7bc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a7c0:	58 0b       	cp.w	r11,0
8000a7c2:	f7 bc 00 f8 	subeq	r12,-8
8000a7c6:	f4 08 17 00 	moveq	r8,r10
8000a7ca:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a7ce:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a7d2:	58 0b       	cp.w	r11,0
8000a7d4:	f7 bc 00 fc 	subeq	r12,-4
8000a7d8:	f4 08 17 00 	moveq	r8,r10
8000a7dc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a7e0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a7e4:	58 0b       	cp.w	r11,0
8000a7e6:	f7 bc 00 fe 	subeq	r12,-2
8000a7ea:	f4 08 17 00 	moveq	r8,r10
8000a7ee:	ed b8 00 00 	bld	r8,0x0
8000a7f2:	c0 60       	breq	8000a7fe <__lo0bits+0x8a>
8000a7f4:	a1 98       	lsr	r8,0x1
8000a7f6:	c0 31       	brne	8000a7fc <__lo0bits+0x88>
8000a7f8:	32 0c       	mov	r12,32
8000a7fa:	5e fc       	retal	r12
8000a7fc:	2f fc       	sub	r12,-1
8000a7fe:	93 08       	st.w	r9[0x0],r8
8000a800:	5e fc       	retal	r12

8000a802 <__mcmp>:
8000a802:	d4 01       	pushm	lr
8000a804:	18 98       	mov	r8,r12
8000a806:	76 49       	ld.w	r9,r11[0x10]
8000a808:	78 4c       	ld.w	r12,r12[0x10]
8000a80a:	12 1c       	sub	r12,r9
8000a80c:	c1 31       	brne	8000a832 <__mcmp+0x30>
8000a80e:	2f b9       	sub	r9,-5
8000a810:	a3 69       	lsl	r9,0x2
8000a812:	12 0b       	add	r11,r9
8000a814:	f0 09 00 09 	add	r9,r8,r9
8000a818:	2e c8       	sub	r8,-20
8000a81a:	13 4e       	ld.w	lr,--r9
8000a81c:	17 4a       	ld.w	r10,--r11
8000a81e:	14 3e       	cp.w	lr,r10
8000a820:	c0 60       	breq	8000a82c <__mcmp+0x2a>
8000a822:	f9 bc 03 ff 	movlo	r12,-1
8000a826:	f9 bc 02 01 	movhs	r12,1
8000a82a:	d8 02       	popm	pc
8000a82c:	10 39       	cp.w	r9,r8
8000a82e:	fe 9b ff f6 	brhi	8000a81a <__mcmp+0x18>
8000a832:	d8 02       	popm	pc

8000a834 <_Bfree>:
8000a834:	d4 21       	pushm	r4-r7,lr
8000a836:	18 97       	mov	r7,r12
8000a838:	16 95       	mov	r5,r11
8000a83a:	78 96       	ld.w	r6,r12[0x24]
8000a83c:	58 06       	cp.w	r6,0
8000a83e:	c0 91       	brne	8000a850 <_Bfree+0x1c>
8000a840:	31 0c       	mov	r12,16
8000a842:	fe b0 de 49 	rcall	800064d4 <malloc>
8000a846:	99 36       	st.w	r12[0xc],r6
8000a848:	8f 9c       	st.w	r7[0x24],r12
8000a84a:	99 16       	st.w	r12[0x4],r6
8000a84c:	99 26       	st.w	r12[0x8],r6
8000a84e:	99 06       	st.w	r12[0x0],r6
8000a850:	58 05       	cp.w	r5,0
8000a852:	c0 90       	breq	8000a864 <_Bfree+0x30>
8000a854:	6a 19       	ld.w	r9,r5[0x4]
8000a856:	6e 98       	ld.w	r8,r7[0x24]
8000a858:	70 38       	ld.w	r8,r8[0xc]
8000a85a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a85e:	8b 0a       	st.w	r5[0x0],r10
8000a860:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a864:	d8 22       	popm	r4-r7,pc
8000a866:	d7 03       	nop

8000a868 <_Balloc>:
8000a868:	d4 21       	pushm	r4-r7,lr
8000a86a:	18 97       	mov	r7,r12
8000a86c:	16 96       	mov	r6,r11
8000a86e:	78 95       	ld.w	r5,r12[0x24]
8000a870:	58 05       	cp.w	r5,0
8000a872:	c0 91       	brne	8000a884 <_Balloc+0x1c>
8000a874:	31 0c       	mov	r12,16
8000a876:	fe b0 de 2f 	rcall	800064d4 <malloc>
8000a87a:	99 35       	st.w	r12[0xc],r5
8000a87c:	8f 9c       	st.w	r7[0x24],r12
8000a87e:	99 15       	st.w	r12[0x4],r5
8000a880:	99 25       	st.w	r12[0x8],r5
8000a882:	99 05       	st.w	r12[0x0],r5
8000a884:	6e 95       	ld.w	r5,r7[0x24]
8000a886:	6a 38       	ld.w	r8,r5[0xc]
8000a888:	58 08       	cp.w	r8,0
8000a88a:	c0 b1       	brne	8000a8a0 <_Balloc+0x38>
8000a88c:	31 0a       	mov	r10,16
8000a88e:	30 4b       	mov	r11,4
8000a890:	0e 9c       	mov	r12,r7
8000a892:	e0 a0 02 a7 	rcall	8000ade0 <_calloc_r>
8000a896:	8b 3c       	st.w	r5[0xc],r12
8000a898:	6e 98       	ld.w	r8,r7[0x24]
8000a89a:	70 3c       	ld.w	r12,r8[0xc]
8000a89c:	58 0c       	cp.w	r12,0
8000a89e:	c1 b0       	breq	8000a8d4 <_Balloc+0x6c>
8000a8a0:	6e 98       	ld.w	r8,r7[0x24]
8000a8a2:	70 38       	ld.w	r8,r8[0xc]
8000a8a4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a8a8:	70 0c       	ld.w	r12,r8[0x0]
8000a8aa:	58 0c       	cp.w	r12,0
8000a8ac:	c0 40       	breq	8000a8b4 <_Balloc+0x4c>
8000a8ae:	78 09       	ld.w	r9,r12[0x0]
8000a8b0:	91 09       	st.w	r8[0x0],r9
8000a8b2:	c0 e8       	rjmp	8000a8ce <_Balloc+0x66>
8000a8b4:	0e 9c       	mov	r12,r7
8000a8b6:	30 17       	mov	r7,1
8000a8b8:	0e 9b       	mov	r11,r7
8000a8ba:	ee 06 09 47 	lsl	r7,r7,r6
8000a8be:	ee ca ff fb 	sub	r10,r7,-5
8000a8c2:	a3 6a       	lsl	r10,0x2
8000a8c4:	e0 a0 02 8e 	rcall	8000ade0 <_calloc_r>
8000a8c8:	c0 60       	breq	8000a8d4 <_Balloc+0x6c>
8000a8ca:	99 16       	st.w	r12[0x4],r6
8000a8cc:	99 27       	st.w	r12[0x8],r7
8000a8ce:	30 08       	mov	r8,0
8000a8d0:	99 38       	st.w	r12[0xc],r8
8000a8d2:	99 48       	st.w	r12[0x10],r8
8000a8d4:	d8 22       	popm	r4-r7,pc
8000a8d6:	d7 03       	nop

8000a8d8 <__d2b>:
8000a8d8:	d4 31       	pushm	r0-r7,lr
8000a8da:	20 2d       	sub	sp,8
8000a8dc:	16 93       	mov	r3,r11
8000a8de:	12 96       	mov	r6,r9
8000a8e0:	10 95       	mov	r5,r8
8000a8e2:	14 92       	mov	r2,r10
8000a8e4:	30 1b       	mov	r11,1
8000a8e6:	cc 1f       	rcall	8000a868 <_Balloc>
8000a8e8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a8ec:	50 09       	stdsp	sp[0x0],r9
8000a8ee:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a8f2:	b5 a9       	sbr	r9,0x14
8000a8f4:	f0 01 16 14 	lsr	r1,r8,0x14
8000a8f8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a8fc:	18 94       	mov	r4,r12
8000a8fe:	58 02       	cp.w	r2,0
8000a900:	c1 d0       	breq	8000a93a <__d2b+0x62>
8000a902:	fa cc ff f8 	sub	r12,sp,-8
8000a906:	18 d2       	st.w	--r12,r2
8000a908:	c3 6f       	rcall	8000a774 <__lo0bits>
8000a90a:	40 18       	lddsp	r8,sp[0x4]
8000a90c:	c0 d0       	breq	8000a926 <__d2b+0x4e>
8000a90e:	40 09       	lddsp	r9,sp[0x0]
8000a910:	f8 0a 11 20 	rsub	r10,r12,32
8000a914:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a918:	f5 e8 10 08 	or	r8,r10,r8
8000a91c:	89 58       	st.w	r4[0x14],r8
8000a91e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a922:	50 09       	stdsp	sp[0x0],r9
8000a924:	c0 28       	rjmp	8000a928 <__d2b+0x50>
8000a926:	89 58       	st.w	r4[0x14],r8
8000a928:	40 08       	lddsp	r8,sp[0x0]
8000a92a:	58 08       	cp.w	r8,0
8000a92c:	f9 b3 01 02 	movne	r3,2
8000a930:	f9 b3 00 01 	moveq	r3,1
8000a934:	89 68       	st.w	r4[0x18],r8
8000a936:	89 43       	st.w	r4[0x10],r3
8000a938:	c0 88       	rjmp	8000a948 <__d2b+0x70>
8000a93a:	1a 9c       	mov	r12,sp
8000a93c:	c1 cf       	rcall	8000a774 <__lo0bits>
8000a93e:	30 13       	mov	r3,1
8000a940:	40 08       	lddsp	r8,sp[0x0]
8000a942:	2e 0c       	sub	r12,-32
8000a944:	89 43       	st.w	r4[0x10],r3
8000a946:	89 58       	st.w	r4[0x14],r8
8000a948:	58 01       	cp.w	r1,0
8000a94a:	c0 90       	breq	8000a95c <__d2b+0x84>
8000a94c:	e2 c1 04 33 	sub	r1,r1,1075
8000a950:	18 01       	add	r1,r12
8000a952:	8d 01       	st.w	r6[0x0],r1
8000a954:	f8 0c 11 35 	rsub	r12,r12,53
8000a958:	8b 0c       	st.w	r5[0x0],r12
8000a95a:	c0 c8       	rjmp	8000a972 <__d2b+0x9a>
8000a95c:	e6 c8 ff fc 	sub	r8,r3,-4
8000a960:	f8 cc 04 32 	sub	r12,r12,1074
8000a964:	a5 73       	lsl	r3,0x5
8000a966:	8d 0c       	st.w	r6[0x0],r12
8000a968:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a96c:	cd 4e       	rcall	8000a714 <__hi0bits>
8000a96e:	18 13       	sub	r3,r12
8000a970:	8b 03       	st.w	r5[0x0],r3
8000a972:	08 9c       	mov	r12,r4
8000a974:	2f ed       	sub	sp,-8
8000a976:	d8 32       	popm	r0-r7,pc

8000a978 <__mdiff>:
8000a978:	d4 31       	pushm	r0-r7,lr
8000a97a:	74 48       	ld.w	r8,r10[0x10]
8000a97c:	76 45       	ld.w	r5,r11[0x10]
8000a97e:	16 97       	mov	r7,r11
8000a980:	14 96       	mov	r6,r10
8000a982:	10 15       	sub	r5,r8
8000a984:	c1 31       	brne	8000a9aa <__mdiff+0x32>
8000a986:	2f b8       	sub	r8,-5
8000a988:	ee ce ff ec 	sub	lr,r7,-20
8000a98c:	a3 68       	lsl	r8,0x2
8000a98e:	f4 08 00 0b 	add	r11,r10,r8
8000a992:	ee 08 00 08 	add	r8,r7,r8
8000a996:	11 4a       	ld.w	r10,--r8
8000a998:	17 49       	ld.w	r9,--r11
8000a99a:	12 3a       	cp.w	r10,r9
8000a99c:	c0 30       	breq	8000a9a2 <__mdiff+0x2a>
8000a99e:	c0 e2       	brcc	8000a9ba <__mdiff+0x42>
8000a9a0:	c0 78       	rjmp	8000a9ae <__mdiff+0x36>
8000a9a2:	1c 38       	cp.w	r8,lr
8000a9a4:	fe 9b ff f9 	brhi	8000a996 <__mdiff+0x1e>
8000a9a8:	c4 98       	rjmp	8000aa3a <__mdiff+0xc2>
8000a9aa:	58 05       	cp.w	r5,0
8000a9ac:	c0 64       	brge	8000a9b8 <__mdiff+0x40>
8000a9ae:	0e 98       	mov	r8,r7
8000a9b0:	30 15       	mov	r5,1
8000a9b2:	0c 97       	mov	r7,r6
8000a9b4:	10 96       	mov	r6,r8
8000a9b6:	c0 28       	rjmp	8000a9ba <__mdiff+0x42>
8000a9b8:	30 05       	mov	r5,0
8000a9ba:	6e 1b       	ld.w	r11,r7[0x4]
8000a9bc:	c5 6f       	rcall	8000a868 <_Balloc>
8000a9be:	6e 49       	ld.w	r9,r7[0x10]
8000a9c0:	6c 44       	ld.w	r4,r6[0x10]
8000a9c2:	99 35       	st.w	r12[0xc],r5
8000a9c4:	2f b4       	sub	r4,-5
8000a9c6:	f2 c5 ff fb 	sub	r5,r9,-5
8000a9ca:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a9ce:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a9d2:	2e c6       	sub	r6,-20
8000a9d4:	2e c7       	sub	r7,-20
8000a9d6:	f8 c8 ff ec 	sub	r8,r12,-20
8000a9da:	30 0a       	mov	r10,0
8000a9dc:	0f 0e       	ld.w	lr,r7++
8000a9de:	0d 0b       	ld.w	r11,r6++
8000a9e0:	fc 02 16 10 	lsr	r2,lr,0x10
8000a9e4:	f6 03 16 10 	lsr	r3,r11,0x10
8000a9e8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a9ec:	e4 03 01 03 	sub	r3,r2,r3
8000a9f0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9f4:	fc 0b 01 0b 	sub	r11,lr,r11
8000a9f8:	f6 0a 00 0a 	add	r10,r11,r10
8000a9fc:	b0 1a       	st.h	r8[0x2],r10
8000a9fe:	b1 4a       	asr	r10,0x10
8000aa00:	e6 0a 00 0a 	add	r10,r3,r10
8000aa04:	b0 0a       	st.h	r8[0x0],r10
8000aa06:	2f c8       	sub	r8,-4
8000aa08:	b1 4a       	asr	r10,0x10
8000aa0a:	08 36       	cp.w	r6,r4
8000aa0c:	ce 83       	brcs	8000a9dc <__mdiff+0x64>
8000aa0e:	c0 d8       	rjmp	8000aa28 <__mdiff+0xb0>
8000aa10:	0f 0b       	ld.w	r11,r7++
8000aa12:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aa16:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa1a:	16 0a       	add	r10,r11
8000aa1c:	b0 1a       	st.h	r8[0x2],r10
8000aa1e:	b1 4a       	asr	r10,0x10
8000aa20:	1c 0a       	add	r10,lr
8000aa22:	b0 0a       	st.h	r8[0x0],r10
8000aa24:	2f c8       	sub	r8,-4
8000aa26:	b1 4a       	asr	r10,0x10
8000aa28:	0a 37       	cp.w	r7,r5
8000aa2a:	cf 33       	brcs	8000aa10 <__mdiff+0x98>
8000aa2c:	c0 28       	rjmp	8000aa30 <__mdiff+0xb8>
8000aa2e:	20 19       	sub	r9,1
8000aa30:	11 4a       	ld.w	r10,--r8
8000aa32:	58 0a       	cp.w	r10,0
8000aa34:	cf d0       	breq	8000aa2e <__mdiff+0xb6>
8000aa36:	99 49       	st.w	r12[0x10],r9
8000aa38:	d8 32       	popm	r0-r7,pc
8000aa3a:	30 0b       	mov	r11,0
8000aa3c:	c1 6f       	rcall	8000a868 <_Balloc>
8000aa3e:	30 18       	mov	r8,1
8000aa40:	99 48       	st.w	r12[0x10],r8
8000aa42:	30 08       	mov	r8,0
8000aa44:	99 58       	st.w	r12[0x14],r8
8000aa46:	d8 32       	popm	r0-r7,pc

8000aa48 <__lshift>:
8000aa48:	d4 31       	pushm	r0-r7,lr
8000aa4a:	16 97       	mov	r7,r11
8000aa4c:	76 46       	ld.w	r6,r11[0x10]
8000aa4e:	f4 02 14 05 	asr	r2,r10,0x5
8000aa52:	2f f6       	sub	r6,-1
8000aa54:	14 93       	mov	r3,r10
8000aa56:	18 94       	mov	r4,r12
8000aa58:	04 06       	add	r6,r2
8000aa5a:	76 1b       	ld.w	r11,r11[0x4]
8000aa5c:	6e 28       	ld.w	r8,r7[0x8]
8000aa5e:	c0 38       	rjmp	8000aa64 <__lshift+0x1c>
8000aa60:	2f fb       	sub	r11,-1
8000aa62:	a1 78       	lsl	r8,0x1
8000aa64:	10 36       	cp.w	r6,r8
8000aa66:	fe 99 ff fd 	brgt	8000aa60 <__lshift+0x18>
8000aa6a:	08 9c       	mov	r12,r4
8000aa6c:	cf ee       	rcall	8000a868 <_Balloc>
8000aa6e:	30 09       	mov	r9,0
8000aa70:	18 95       	mov	r5,r12
8000aa72:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa76:	12 9a       	mov	r10,r9
8000aa78:	c0 38       	rjmp	8000aa7e <__lshift+0x36>
8000aa7a:	10 aa       	st.w	r8++,r10
8000aa7c:	2f f9       	sub	r9,-1
8000aa7e:	04 39       	cp.w	r9,r2
8000aa80:	cf d5       	brlt	8000aa7a <__lshift+0x32>
8000aa82:	6e 4b       	ld.w	r11,r7[0x10]
8000aa84:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aa88:	2f bb       	sub	r11,-5
8000aa8a:	ee c9 ff ec 	sub	r9,r7,-20
8000aa8e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aa92:	58 03       	cp.w	r3,0
8000aa94:	c1 30       	breq	8000aaba <__lshift+0x72>
8000aa96:	e6 0c 11 20 	rsub	r12,r3,32
8000aa9a:	30 0a       	mov	r10,0
8000aa9c:	72 02       	ld.w	r2,r9[0x0]
8000aa9e:	e4 03 09 42 	lsl	r2,r2,r3
8000aaa2:	04 4a       	or	r10,r2
8000aaa4:	10 aa       	st.w	r8++,r10
8000aaa6:	13 0a       	ld.w	r10,r9++
8000aaa8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aaac:	16 39       	cp.w	r9,r11
8000aaae:	cf 73       	brcs	8000aa9c <__lshift+0x54>
8000aab0:	91 0a       	st.w	r8[0x0],r10
8000aab2:	58 0a       	cp.w	r10,0
8000aab4:	c0 70       	breq	8000aac2 <__lshift+0x7a>
8000aab6:	2f f6       	sub	r6,-1
8000aab8:	c0 58       	rjmp	8000aac2 <__lshift+0x7a>
8000aaba:	13 0a       	ld.w	r10,r9++
8000aabc:	10 aa       	st.w	r8++,r10
8000aabe:	16 39       	cp.w	r9,r11
8000aac0:	cf d3       	brcs	8000aaba <__lshift+0x72>
8000aac2:	08 9c       	mov	r12,r4
8000aac4:	20 16       	sub	r6,1
8000aac6:	0e 9b       	mov	r11,r7
8000aac8:	8b 46       	st.w	r5[0x10],r6
8000aaca:	cb 5e       	rcall	8000a834 <_Bfree>
8000aacc:	0a 9c       	mov	r12,r5
8000aace:	d8 32       	popm	r0-r7,pc

8000aad0 <__multiply>:
8000aad0:	d4 31       	pushm	r0-r7,lr
8000aad2:	20 2d       	sub	sp,8
8000aad4:	76 49       	ld.w	r9,r11[0x10]
8000aad6:	74 48       	ld.w	r8,r10[0x10]
8000aad8:	16 96       	mov	r6,r11
8000aada:	14 95       	mov	r5,r10
8000aadc:	10 39       	cp.w	r9,r8
8000aade:	ec 08 17 50 	movlt	r8,r6
8000aae2:	ea 06 17 50 	movlt	r6,r5
8000aae6:	f0 05 17 50 	movlt	r5,r8
8000aaea:	6c 28       	ld.w	r8,r6[0x8]
8000aaec:	76 43       	ld.w	r3,r11[0x10]
8000aaee:	74 42       	ld.w	r2,r10[0x10]
8000aaf0:	76 1b       	ld.w	r11,r11[0x4]
8000aaf2:	e4 03 00 07 	add	r7,r2,r3
8000aaf6:	10 37       	cp.w	r7,r8
8000aaf8:	f7 bb 09 ff 	subgt	r11,-1
8000aafc:	cb 6e       	rcall	8000a868 <_Balloc>
8000aafe:	ee c4 ff fb 	sub	r4,r7,-5
8000ab02:	f8 c9 ff ec 	sub	r9,r12,-20
8000ab06:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ab0a:	30 0a       	mov	r10,0
8000ab0c:	12 98       	mov	r8,r9
8000ab0e:	c0 28       	rjmp	8000ab12 <__multiply+0x42>
8000ab10:	10 aa       	st.w	r8++,r10
8000ab12:	08 38       	cp.w	r8,r4
8000ab14:	cf e3       	brcs	8000ab10 <__multiply+0x40>
8000ab16:	2f b3       	sub	r3,-5
8000ab18:	2f b2       	sub	r2,-5
8000ab1a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ab1e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ab22:	ec cb ff ec 	sub	r11,r6,-20
8000ab26:	50 12       	stdsp	sp[0x4],r2
8000ab28:	ea ca ff ec 	sub	r10,r5,-20
8000ab2c:	c4 48       	rjmp	8000abb4 <__multiply+0xe4>
8000ab2e:	94 95       	ld.uh	r5,r10[0x2]
8000ab30:	58 05       	cp.w	r5,0
8000ab32:	c2 00       	breq	8000ab72 <__multiply+0xa2>
8000ab34:	12 98       	mov	r8,r9
8000ab36:	16 96       	mov	r6,r11
8000ab38:	30 0e       	mov	lr,0
8000ab3a:	50 09       	stdsp	sp[0x0],r9
8000ab3c:	0d 02       	ld.w	r2,r6++
8000ab3e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ab42:	70 01       	ld.w	r1,r8[0x0]
8000ab44:	70 09       	ld.w	r9,r8[0x0]
8000ab46:	b1 81       	lsr	r1,0x10
8000ab48:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ab4c:	e0 05 03 41 	mac	r1,r0,r5
8000ab50:	ab 32       	mul	r2,r5
8000ab52:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ab56:	00 02       	add	r2,r0
8000ab58:	e4 0e 00 0e 	add	lr,r2,lr
8000ab5c:	b0 1e       	st.h	r8[0x2],lr
8000ab5e:	b1 8e       	lsr	lr,0x10
8000ab60:	1c 01       	add	r1,lr
8000ab62:	b0 01       	st.h	r8[0x0],r1
8000ab64:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ab68:	2f c8       	sub	r8,-4
8000ab6a:	06 36       	cp.w	r6,r3
8000ab6c:	ce 83       	brcs	8000ab3c <__multiply+0x6c>
8000ab6e:	40 09       	lddsp	r9,sp[0x0]
8000ab70:	91 0e       	st.w	r8[0x0],lr
8000ab72:	94 86       	ld.uh	r6,r10[0x0]
8000ab74:	58 06       	cp.w	r6,0
8000ab76:	c1 d0       	breq	8000abb0 <__multiply+0xe0>
8000ab78:	72 02       	ld.w	r2,r9[0x0]
8000ab7a:	12 98       	mov	r8,r9
8000ab7c:	16 9e       	mov	lr,r11
8000ab7e:	30 05       	mov	r5,0
8000ab80:	b0 12       	st.h	r8[0x2],r2
8000ab82:	1d 01       	ld.w	r1,lr++
8000ab84:	90 82       	ld.uh	r2,r8[0x0]
8000ab86:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ab8a:	ad 30       	mul	r0,r6
8000ab8c:	e0 02 00 02 	add	r2,r0,r2
8000ab90:	e4 05 00 05 	add	r5,r2,r5
8000ab94:	b0 05       	st.h	r8[0x0],r5
8000ab96:	b1 85       	lsr	r5,0x10
8000ab98:	b1 81       	lsr	r1,0x10
8000ab9a:	2f c8       	sub	r8,-4
8000ab9c:	ad 31       	mul	r1,r6
8000ab9e:	90 92       	ld.uh	r2,r8[0x2]
8000aba0:	e2 02 00 02 	add	r2,r1,r2
8000aba4:	0a 02       	add	r2,r5
8000aba6:	e4 05 16 10 	lsr	r5,r2,0x10
8000abaa:	06 3e       	cp.w	lr,r3
8000abac:	ce a3       	brcs	8000ab80 <__multiply+0xb0>
8000abae:	91 02       	st.w	r8[0x0],r2
8000abb0:	2f ca       	sub	r10,-4
8000abb2:	2f c9       	sub	r9,-4
8000abb4:	40 18       	lddsp	r8,sp[0x4]
8000abb6:	10 3a       	cp.w	r10,r8
8000abb8:	cb b3       	brcs	8000ab2e <__multiply+0x5e>
8000abba:	c0 28       	rjmp	8000abbe <__multiply+0xee>
8000abbc:	20 17       	sub	r7,1
8000abbe:	58 07       	cp.w	r7,0
8000abc0:	e0 8a 00 05 	brle	8000abca <__multiply+0xfa>
8000abc4:	09 48       	ld.w	r8,--r4
8000abc6:	58 08       	cp.w	r8,0
8000abc8:	cf a0       	breq	8000abbc <__multiply+0xec>
8000abca:	99 47       	st.w	r12[0x10],r7
8000abcc:	2f ed       	sub	sp,-8
8000abce:	d8 32       	popm	r0-r7,pc

8000abd0 <__i2b>:
8000abd0:	d4 21       	pushm	r4-r7,lr
8000abd2:	16 97       	mov	r7,r11
8000abd4:	30 1b       	mov	r11,1
8000abd6:	c4 9e       	rcall	8000a868 <_Balloc>
8000abd8:	30 19       	mov	r9,1
8000abda:	99 57       	st.w	r12[0x14],r7
8000abdc:	99 49       	st.w	r12[0x10],r9
8000abde:	d8 22       	popm	r4-r7,pc

8000abe0 <__multadd>:
8000abe0:	d4 31       	pushm	r0-r7,lr
8000abe2:	30 08       	mov	r8,0
8000abe4:	12 95       	mov	r5,r9
8000abe6:	16 97       	mov	r7,r11
8000abe8:	18 96       	mov	r6,r12
8000abea:	76 44       	ld.w	r4,r11[0x10]
8000abec:	f6 c9 ff ec 	sub	r9,r11,-20
8000abf0:	72 0b       	ld.w	r11,r9[0x0]
8000abf2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000abf6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000abfa:	f4 0c 02 4c 	mul	r12,r10,r12
8000abfe:	f4 0b 03 45 	mac	r5,r10,r11
8000ac02:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ac06:	b1 85       	lsr	r5,0x10
8000ac08:	18 05       	add	r5,r12
8000ac0a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ac0e:	f8 0b 00 0b 	add	r11,r12,r11
8000ac12:	12 ab       	st.w	r9++,r11
8000ac14:	2f f8       	sub	r8,-1
8000ac16:	b1 85       	lsr	r5,0x10
8000ac18:	08 38       	cp.w	r8,r4
8000ac1a:	ce b5       	brlt	8000abf0 <__multadd+0x10>
8000ac1c:	58 05       	cp.w	r5,0
8000ac1e:	c1 c0       	breq	8000ac56 <__multadd+0x76>
8000ac20:	6e 28       	ld.w	r8,r7[0x8]
8000ac22:	10 34       	cp.w	r4,r8
8000ac24:	c1 35       	brlt	8000ac4a <__multadd+0x6a>
8000ac26:	6e 1b       	ld.w	r11,r7[0x4]
8000ac28:	0c 9c       	mov	r12,r6
8000ac2a:	2f fb       	sub	r11,-1
8000ac2c:	c1 ee       	rcall	8000a868 <_Balloc>
8000ac2e:	6e 4a       	ld.w	r10,r7[0x10]
8000ac30:	ee cb ff f4 	sub	r11,r7,-12
8000ac34:	18 93       	mov	r3,r12
8000ac36:	2f ea       	sub	r10,-2
8000ac38:	2f 4c       	sub	r12,-12
8000ac3a:	a3 6a       	lsl	r10,0x2
8000ac3c:	fe b0 de 70 	rcall	8000691c <memcpy>
8000ac40:	0e 9b       	mov	r11,r7
8000ac42:	0c 9c       	mov	r12,r6
8000ac44:	fe b0 fd f8 	rcall	8000a834 <_Bfree>
8000ac48:	06 97       	mov	r7,r3
8000ac4a:	e8 c8 ff ff 	sub	r8,r4,-1
8000ac4e:	2f b4       	sub	r4,-5
8000ac50:	8f 48       	st.w	r7[0x10],r8
8000ac52:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ac56:	0e 9c       	mov	r12,r7
8000ac58:	d8 32       	popm	r0-r7,pc
8000ac5a:	d7 03       	nop

8000ac5c <__pow5mult>:
8000ac5c:	d4 31       	pushm	r0-r7,lr
8000ac5e:	14 96       	mov	r6,r10
8000ac60:	18 97       	mov	r7,r12
8000ac62:	16 94       	mov	r4,r11
8000ac64:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ac68:	c0 90       	breq	8000ac7a <__pow5mult+0x1e>
8000ac6a:	20 18       	sub	r8,1
8000ac6c:	fe c9 dc b8 	sub	r9,pc,-9032
8000ac70:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ac74:	30 09       	mov	r9,0
8000ac76:	cb 5f       	rcall	8000abe0 <__multadd>
8000ac78:	18 94       	mov	r4,r12
8000ac7a:	a3 46       	asr	r6,0x2
8000ac7c:	c3 40       	breq	8000ace4 <__pow5mult+0x88>
8000ac7e:	6e 95       	ld.w	r5,r7[0x24]
8000ac80:	58 05       	cp.w	r5,0
8000ac82:	c0 91       	brne	8000ac94 <__pow5mult+0x38>
8000ac84:	31 0c       	mov	r12,16
8000ac86:	fe b0 dc 27 	rcall	800064d4 <malloc>
8000ac8a:	99 35       	st.w	r12[0xc],r5
8000ac8c:	8f 9c       	st.w	r7[0x24],r12
8000ac8e:	99 15       	st.w	r12[0x4],r5
8000ac90:	99 25       	st.w	r12[0x8],r5
8000ac92:	99 05       	st.w	r12[0x0],r5
8000ac94:	6e 93       	ld.w	r3,r7[0x24]
8000ac96:	66 25       	ld.w	r5,r3[0x8]
8000ac98:	58 05       	cp.w	r5,0
8000ac9a:	c0 c1       	brne	8000acb2 <__pow5mult+0x56>
8000ac9c:	e0 6b 02 71 	mov	r11,625
8000aca0:	0e 9c       	mov	r12,r7
8000aca2:	c9 7f       	rcall	8000abd0 <__i2b>
8000aca4:	87 2c       	st.w	r3[0x8],r12
8000aca6:	30 08       	mov	r8,0
8000aca8:	18 95       	mov	r5,r12
8000acaa:	99 08       	st.w	r12[0x0],r8
8000acac:	c0 38       	rjmp	8000acb2 <__pow5mult+0x56>
8000acae:	06 9c       	mov	r12,r3
8000acb0:	18 95       	mov	r5,r12
8000acb2:	ed b6 00 00 	bld	r6,0x0
8000acb6:	c0 b1       	brne	8000accc <__pow5mult+0x70>
8000acb8:	08 9b       	mov	r11,r4
8000acba:	0a 9a       	mov	r10,r5
8000acbc:	0e 9c       	mov	r12,r7
8000acbe:	c0 9f       	rcall	8000aad0 <__multiply>
8000acc0:	08 9b       	mov	r11,r4
8000acc2:	18 93       	mov	r3,r12
8000acc4:	0e 9c       	mov	r12,r7
8000acc6:	06 94       	mov	r4,r3
8000acc8:	fe b0 fd b6 	rcall	8000a834 <_Bfree>
8000accc:	a1 56       	asr	r6,0x1
8000acce:	c0 b0       	breq	8000ace4 <__pow5mult+0x88>
8000acd0:	6a 03       	ld.w	r3,r5[0x0]
8000acd2:	58 03       	cp.w	r3,0
8000acd4:	ce d1       	brne	8000acae <__pow5mult+0x52>
8000acd6:	0a 9a       	mov	r10,r5
8000acd8:	0a 9b       	mov	r11,r5
8000acda:	0e 9c       	mov	r12,r7
8000acdc:	cf ae       	rcall	8000aad0 <__multiply>
8000acde:	8b 0c       	st.w	r5[0x0],r12
8000ace0:	99 03       	st.w	r12[0x0],r3
8000ace2:	ce 7b       	rjmp	8000acb0 <__pow5mult+0x54>
8000ace4:	08 9c       	mov	r12,r4
8000ace6:	d8 32       	popm	r0-r7,pc

8000ace8 <__isinfd>:
8000ace8:	14 98       	mov	r8,r10
8000acea:	fc 19 7f f0 	movh	r9,0x7ff0
8000acee:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000acf2:	f0 0b 11 00 	rsub	r11,r8,0
8000acf6:	f7 e8 10 08 	or	r8,r11,r8
8000acfa:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000acfe:	f2 08 01 08 	sub	r8,r9,r8
8000ad02:	f0 0c 11 00 	rsub	r12,r8,0
8000ad06:	f9 e8 10 08 	or	r8,r12,r8
8000ad0a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ad0e:	2f fc       	sub	r12,-1
8000ad10:	5e fc       	retal	r12

8000ad12 <__isnand>:
8000ad12:	14 98       	mov	r8,r10
8000ad14:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad18:	f0 0c 11 00 	rsub	r12,r8,0
8000ad1c:	10 4c       	or	r12,r8
8000ad1e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ad22:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ad26:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad2a:	bf 9c       	lsr	r12,0x1f
8000ad2c:	5e fc       	retal	r12
8000ad2e:	d7 03       	nop

8000ad30 <__sclose>:
8000ad30:	d4 01       	pushm	lr
8000ad32:	96 7b       	ld.sh	r11,r11[0xe]
8000ad34:	c8 2c       	rcall	8000ae38 <_close_r>
8000ad36:	d8 02       	popm	pc

8000ad38 <__sseek>:
8000ad38:	d4 21       	pushm	r4-r7,lr
8000ad3a:	16 97       	mov	r7,r11
8000ad3c:	96 7b       	ld.sh	r11,r11[0xe]
8000ad3e:	c0 3d       	rcall	8000af44 <_lseek_r>
8000ad40:	8e 68       	ld.sh	r8,r7[0xc]
8000ad42:	10 99       	mov	r9,r8
8000ad44:	ad c8       	cbr	r8,0xc
8000ad46:	ad a9       	sbr	r9,0xc
8000ad48:	5b fc       	cp.w	r12,-1
8000ad4a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ad4e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ad52:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ad56:	d8 22       	popm	r4-r7,pc

8000ad58 <__swrite>:
8000ad58:	d4 21       	pushm	r4-r7,lr
8000ad5a:	96 68       	ld.sh	r8,r11[0xc]
8000ad5c:	16 97       	mov	r7,r11
8000ad5e:	14 95       	mov	r5,r10
8000ad60:	12 94       	mov	r4,r9
8000ad62:	e2 18 01 00 	andl	r8,0x100,COH
8000ad66:	18 96       	mov	r6,r12
8000ad68:	c0 50       	breq	8000ad72 <__swrite+0x1a>
8000ad6a:	30 29       	mov	r9,2
8000ad6c:	30 0a       	mov	r10,0
8000ad6e:	96 7b       	ld.sh	r11,r11[0xe]
8000ad70:	ce ac       	rcall	8000af44 <_lseek_r>
8000ad72:	8e 68       	ld.sh	r8,r7[0xc]
8000ad74:	ad c8       	cbr	r8,0xc
8000ad76:	08 99       	mov	r9,r4
8000ad78:	0a 9a       	mov	r10,r5
8000ad7a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ad7c:	0c 9c       	mov	r12,r6
8000ad7e:	ae 68       	st.h	r7[0xc],r8
8000ad80:	c1 cc       	rcall	8000adb8 <_write_r>
8000ad82:	d8 22       	popm	r4-r7,pc

8000ad84 <__sread>:
8000ad84:	d4 21       	pushm	r4-r7,lr
8000ad86:	16 97       	mov	r7,r11
8000ad88:	96 7b       	ld.sh	r11,r11[0xe]
8000ad8a:	cf 1c       	rcall	8000af6c <_read_r>
8000ad8c:	c0 65       	brlt	8000ad98 <__sread+0x14>
8000ad8e:	6f 58       	ld.w	r8,r7[0x54]
8000ad90:	18 08       	add	r8,r12
8000ad92:	ef 48 00 54 	st.w	r7[84],r8
8000ad96:	d8 22       	popm	r4-r7,pc
8000ad98:	8e 68       	ld.sh	r8,r7[0xc]
8000ad9a:	ad c8       	cbr	r8,0xc
8000ad9c:	ae 68       	st.h	r7[0xc],r8
8000ad9e:	d8 22       	popm	r4-r7,pc

8000ada0 <strlen>:
8000ada0:	30 09       	mov	r9,0
8000ada2:	18 98       	mov	r8,r12
8000ada4:	c0 28       	rjmp	8000ada8 <strlen+0x8>
8000ada6:	2f f8       	sub	r8,-1
8000ada8:	11 8a       	ld.ub	r10,r8[0x0]
8000adaa:	f2 0a 18 00 	cp.b	r10,r9
8000adae:	cf c1       	brne	8000ada6 <strlen+0x6>
8000adb0:	f0 0c 01 0c 	sub	r12,r8,r12
8000adb4:	5e fc       	retal	r12
8000adb6:	d7 03       	nop

8000adb8 <_write_r>:
8000adb8:	d4 21       	pushm	r4-r7,lr
8000adba:	16 98       	mov	r8,r11
8000adbc:	18 97       	mov	r7,r12
8000adbe:	10 9c       	mov	r12,r8
8000adc0:	30 08       	mov	r8,0
8000adc2:	14 9b       	mov	r11,r10
8000adc4:	e0 66 41 08 	mov	r6,16648
8000adc8:	12 9a       	mov	r10,r9
8000adca:	8d 08       	st.w	r6[0x0],r8
8000adcc:	fe b0 d1 b6 	rcall	80005138 <_write>
8000add0:	5b fc       	cp.w	r12,-1
8000add2:	c0 51       	brne	8000addc <_write_r+0x24>
8000add4:	6c 08       	ld.w	r8,r6[0x0]
8000add6:	58 08       	cp.w	r8,0
8000add8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000addc:	d8 22       	popm	r4-r7,pc
8000adde:	d7 03       	nop

8000ade0 <_calloc_r>:
8000ade0:	d4 21       	pushm	r4-r7,lr
8000ade2:	f4 0b 02 4b 	mul	r11,r10,r11
8000ade6:	fe b0 db 7f 	rcall	800064e4 <_malloc_r>
8000adea:	18 97       	mov	r7,r12
8000adec:	c2 30       	breq	8000ae32 <_calloc_r+0x52>
8000adee:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000adf2:	e0 1a ff fc 	andl	r10,0xfffc
8000adf6:	20 4a       	sub	r10,4
8000adf8:	e0 4a 00 24 	cp.w	r10,36
8000adfc:	e0 8b 00 18 	brhi	8000ae2c <_calloc_r+0x4c>
8000ae00:	18 98       	mov	r8,r12
8000ae02:	59 3a       	cp.w	r10,19
8000ae04:	e0 88 00 0f 	brls	8000ae22 <_calloc_r+0x42>
8000ae08:	30 09       	mov	r9,0
8000ae0a:	10 a9       	st.w	r8++,r9
8000ae0c:	10 a9       	st.w	r8++,r9
8000ae0e:	59 ba       	cp.w	r10,27
8000ae10:	e0 88 00 09 	brls	8000ae22 <_calloc_r+0x42>
8000ae14:	10 a9       	st.w	r8++,r9
8000ae16:	10 a9       	st.w	r8++,r9
8000ae18:	e0 4a 00 24 	cp.w	r10,36
8000ae1c:	c0 31       	brne	8000ae22 <_calloc_r+0x42>
8000ae1e:	10 a9       	st.w	r8++,r9
8000ae20:	10 a9       	st.w	r8++,r9
8000ae22:	30 09       	mov	r9,0
8000ae24:	10 a9       	st.w	r8++,r9
8000ae26:	91 19       	st.w	r8[0x4],r9
8000ae28:	91 09       	st.w	r8[0x0],r9
8000ae2a:	c0 48       	rjmp	8000ae32 <_calloc_r+0x52>
8000ae2c:	30 0b       	mov	r11,0
8000ae2e:	fe b0 de 1b 	rcall	80006a64 <memset>
8000ae32:	0e 9c       	mov	r12,r7
8000ae34:	d8 22       	popm	r4-r7,pc
8000ae36:	d7 03       	nop

8000ae38 <_close_r>:
8000ae38:	d4 21       	pushm	r4-r7,lr
8000ae3a:	30 08       	mov	r8,0
8000ae3c:	18 97       	mov	r7,r12
8000ae3e:	e0 66 41 08 	mov	r6,16648
8000ae42:	16 9c       	mov	r12,r11
8000ae44:	8d 08       	st.w	r6[0x0],r8
8000ae46:	fe b0 df b5 	rcall	80006db0 <_close>
8000ae4a:	5b fc       	cp.w	r12,-1
8000ae4c:	c0 51       	brne	8000ae56 <_close_r+0x1e>
8000ae4e:	6c 08       	ld.w	r8,r6[0x0]
8000ae50:	58 08       	cp.w	r8,0
8000ae52:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae56:	d8 22       	popm	r4-r7,pc

8000ae58 <_fclose_r>:
8000ae58:	d4 21       	pushm	r4-r7,lr
8000ae5a:	18 96       	mov	r6,r12
8000ae5c:	16 97       	mov	r7,r11
8000ae5e:	58 0b       	cp.w	r11,0
8000ae60:	c0 31       	brne	8000ae66 <_fclose_r+0xe>
8000ae62:	16 95       	mov	r5,r11
8000ae64:	c5 38       	rjmp	8000af0a <_fclose_r+0xb2>
8000ae66:	fe b0 f8 a9 	rcall	80009fb8 <__sfp_lock_acquire>
8000ae6a:	58 06       	cp.w	r6,0
8000ae6c:	c0 70       	breq	8000ae7a <_fclose_r+0x22>
8000ae6e:	6c 68       	ld.w	r8,r6[0x18]
8000ae70:	58 08       	cp.w	r8,0
8000ae72:	c0 41       	brne	8000ae7a <_fclose_r+0x22>
8000ae74:	0c 9c       	mov	r12,r6
8000ae76:	fe b0 f8 f3 	rcall	8000a05c <__sinit>
8000ae7a:	fe c8 df 6a 	sub	r8,pc,-8342
8000ae7e:	10 37       	cp.w	r7,r8
8000ae80:	c0 31       	brne	8000ae86 <_fclose_r+0x2e>
8000ae82:	6c 07       	ld.w	r7,r6[0x0]
8000ae84:	c0 c8       	rjmp	8000ae9c <_fclose_r+0x44>
8000ae86:	fe c8 df 56 	sub	r8,pc,-8362
8000ae8a:	10 37       	cp.w	r7,r8
8000ae8c:	c0 31       	brne	8000ae92 <_fclose_r+0x3a>
8000ae8e:	6c 17       	ld.w	r7,r6[0x4]
8000ae90:	c0 68       	rjmp	8000ae9c <_fclose_r+0x44>
8000ae92:	fe c8 df 42 	sub	r8,pc,-8382
8000ae96:	10 37       	cp.w	r7,r8
8000ae98:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae9c:	8e 69       	ld.sh	r9,r7[0xc]
8000ae9e:	30 08       	mov	r8,0
8000aea0:	f0 09 19 00 	cp.h	r9,r8
8000aea4:	c0 51       	brne	8000aeae <_fclose_r+0x56>
8000aea6:	fe b0 f8 8a 	rcall	80009fba <__sfp_lock_release>
8000aeaa:	30 05       	mov	r5,0
8000aeac:	c2 f8       	rjmp	8000af0a <_fclose_r+0xb2>
8000aeae:	0e 9b       	mov	r11,r7
8000aeb0:	0c 9c       	mov	r12,r6
8000aeb2:	fe b0 f7 fd 	rcall	80009eac <_fflush_r>
8000aeb6:	6e c8       	ld.w	r8,r7[0x30]
8000aeb8:	18 95       	mov	r5,r12
8000aeba:	58 08       	cp.w	r8,0
8000aebc:	c0 60       	breq	8000aec8 <_fclose_r+0x70>
8000aebe:	6e 8b       	ld.w	r11,r7[0x20]
8000aec0:	0c 9c       	mov	r12,r6
8000aec2:	5d 18       	icall	r8
8000aec4:	f9 b5 05 ff 	movlt	r5,-1
8000aec8:	8e 68       	ld.sh	r8,r7[0xc]
8000aeca:	ed b8 00 07 	bld	r8,0x7
8000aece:	c0 51       	brne	8000aed8 <_fclose_r+0x80>
8000aed0:	6e 4b       	ld.w	r11,r7[0x10]
8000aed2:	0c 9c       	mov	r12,r6
8000aed4:	fe b0 f9 5e 	rcall	8000a190 <_free_r>
8000aed8:	6e db       	ld.w	r11,r7[0x34]
8000aeda:	58 0b       	cp.w	r11,0
8000aedc:	c0 a0       	breq	8000aef0 <_fclose_r+0x98>
8000aede:	ee c8 ff bc 	sub	r8,r7,-68
8000aee2:	10 3b       	cp.w	r11,r8
8000aee4:	c0 40       	breq	8000aeec <_fclose_r+0x94>
8000aee6:	0c 9c       	mov	r12,r6
8000aee8:	fe b0 f9 54 	rcall	8000a190 <_free_r>
8000aeec:	30 08       	mov	r8,0
8000aeee:	8f d8       	st.w	r7[0x34],r8
8000aef0:	6f 2b       	ld.w	r11,r7[0x48]
8000aef2:	58 0b       	cp.w	r11,0
8000aef4:	c0 70       	breq	8000af02 <_fclose_r+0xaa>
8000aef6:	0c 9c       	mov	r12,r6
8000aef8:	fe b0 f9 4c 	rcall	8000a190 <_free_r>
8000aefc:	30 08       	mov	r8,0
8000aefe:	ef 48 00 48 	st.w	r7[72],r8
8000af02:	30 08       	mov	r8,0
8000af04:	ae 68       	st.h	r7[0xc],r8
8000af06:	fe b0 f8 5a 	rcall	80009fba <__sfp_lock_release>
8000af0a:	0a 9c       	mov	r12,r5
8000af0c:	d8 22       	popm	r4-r7,pc
8000af0e:	d7 03       	nop

8000af10 <fclose>:
8000af10:	d4 01       	pushm	lr
8000af12:	e0 68 0a 2c 	mov	r8,2604
8000af16:	18 9b       	mov	r11,r12
8000af18:	70 0c       	ld.w	r12,r8[0x0]
8000af1a:	c9 ff       	rcall	8000ae58 <_fclose_r>
8000af1c:	d8 02       	popm	pc
8000af1e:	d7 03       	nop

8000af20 <_fstat_r>:
8000af20:	d4 21       	pushm	r4-r7,lr
8000af22:	16 98       	mov	r8,r11
8000af24:	18 97       	mov	r7,r12
8000af26:	10 9c       	mov	r12,r8
8000af28:	30 08       	mov	r8,0
8000af2a:	e0 66 41 08 	mov	r6,16648
8000af2e:	14 9b       	mov	r11,r10
8000af30:	8d 08       	st.w	r6[0x0],r8
8000af32:	fe b0 df 67 	rcall	80006e00 <_fstat>
8000af36:	5b fc       	cp.w	r12,-1
8000af38:	c0 51       	brne	8000af42 <_fstat_r+0x22>
8000af3a:	6c 08       	ld.w	r8,r6[0x0]
8000af3c:	58 08       	cp.w	r8,0
8000af3e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af42:	d8 22       	popm	r4-r7,pc

8000af44 <_lseek_r>:
8000af44:	d4 21       	pushm	r4-r7,lr
8000af46:	16 98       	mov	r8,r11
8000af48:	18 97       	mov	r7,r12
8000af4a:	10 9c       	mov	r12,r8
8000af4c:	30 08       	mov	r8,0
8000af4e:	14 9b       	mov	r11,r10
8000af50:	e0 66 41 08 	mov	r6,16648
8000af54:	12 9a       	mov	r10,r9
8000af56:	8d 08       	st.w	r6[0x0],r8
8000af58:	fe b0 df 36 	rcall	80006dc4 <_lseek>
8000af5c:	5b fc       	cp.w	r12,-1
8000af5e:	c0 51       	brne	8000af68 <_lseek_r+0x24>
8000af60:	6c 08       	ld.w	r8,r6[0x0]
8000af62:	58 08       	cp.w	r8,0
8000af64:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af68:	d8 22       	popm	r4-r7,pc
8000af6a:	d7 03       	nop

8000af6c <_read_r>:
8000af6c:	d4 21       	pushm	r4-r7,lr
8000af6e:	16 98       	mov	r8,r11
8000af70:	18 97       	mov	r7,r12
8000af72:	10 9c       	mov	r12,r8
8000af74:	30 08       	mov	r8,0
8000af76:	14 9b       	mov	r11,r10
8000af78:	e0 66 41 08 	mov	r6,16648
8000af7c:	12 9a       	mov	r10,r9
8000af7e:	8d 08       	st.w	r6[0x0],r8
8000af80:	fe b0 d0 bc 	rcall	800050f8 <_read>
8000af84:	5b fc       	cp.w	r12,-1
8000af86:	c0 51       	brne	8000af90 <_read_r+0x24>
8000af88:	6c 08       	ld.w	r8,r6[0x0]
8000af8a:	58 08       	cp.w	r8,0
8000af8c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af90:	d8 22       	popm	r4-r7,pc
8000af92:	d7 03       	nop

8000af94 <__avr32_f64_mul>:
8000af94:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000af98:	e0 80 00 dc 	breq	8000b150 <__avr32_f64_mul_op1_zero>
8000af9c:	d4 21       	pushm	r4-r7,lr
8000af9e:	f7 e9 20 0e 	eor	lr,r11,r9
8000afa2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000afa6:	30 15       	mov	r5,1
8000afa8:	c4 30       	breq	8000b02e <__avr32_f64_mul_op1_subnormal>
8000afaa:	ab 6b       	lsl	r11,0xa
8000afac:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000afb0:	ab 6a       	lsl	r10,0xa
8000afb2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000afb6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000afba:	c5 c0       	breq	8000b072 <__avr32_f64_mul_op2_subnormal>
8000afbc:	a1 78       	lsl	r8,0x1
8000afbe:	5c f9       	rol	r9
8000afc0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000afc4:	e0 47 07 ff 	cp.w	r7,2047
8000afc8:	c7 70       	breq	8000b0b6 <__avr32_f64_mul_op_nan_or_inf>
8000afca:	e0 46 07 ff 	cp.w	r6,2047
8000afce:	c7 40       	breq	8000b0b6 <__avr32_f64_mul_op_nan_or_inf>
8000afd0:	ee 06 00 0c 	add	r12,r7,r6
8000afd4:	e0 2c 03 fe 	sub	r12,1022
8000afd8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000afdc:	f4 09 07 44 	macu.d	r4,r10,r9
8000afe0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000afe4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000afe8:	08 07       	add	r7,r4
8000afea:	f4 05 00 4a 	adc	r10,r10,r5
8000afee:	5c 0b       	acr	r11
8000aff0:	ed bb 00 14 	bld	r11,0x14
8000aff4:	c0 50       	breq	8000affe <__avr32_f64_mul+0x6a>
8000aff6:	a1 77       	lsl	r7,0x1
8000aff8:	5c fa       	rol	r10
8000affa:	5c fb       	rol	r11
8000affc:	20 1c       	sub	r12,1
8000affe:	58 0c       	cp.w	r12,0
8000b000:	e0 8a 00 6f 	brle	8000b0de <__avr32_f64_mul_res_subnormal>
8000b004:	e0 4c 07 ff 	cp.w	r12,2047
8000b008:	e0 84 00 9c 	brge	8000b140 <__avr32_f64_mul_res_inf>
8000b00c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b010:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b014:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b018:	ee 17 80 00 	eorh	r7,0x8000
8000b01c:	f1 b7 04 20 	satu	r7,0x1
8000b020:	0e 0a       	add	r10,r7
8000b022:	5c 0b       	acr	r11
8000b024:	ed be 00 1f 	bld	lr,0x1f
8000b028:	ef bb 00 1f 	bst	r11,0x1f
8000b02c:	d8 22       	popm	r4-r7,pc

8000b02e <__avr32_f64_mul_op1_subnormal>:
8000b02e:	e4 1b 00 0f 	andh	r11,0xf
8000b032:	f4 0c 12 00 	clz	r12,r10
8000b036:	f6 06 12 00 	clz	r6,r11
8000b03a:	f7 bc 03 e1 	sublo	r12,-31
8000b03e:	f8 06 17 30 	movlo	r6,r12
8000b042:	f7 b6 02 01 	subhs	r6,1
8000b046:	e0 46 00 20 	cp.w	r6,32
8000b04a:	c0 d4       	brge	8000b064 <__avr32_f64_mul_op1_subnormal+0x36>
8000b04c:	ec 0c 11 20 	rsub	r12,r6,32
8000b050:	f6 06 09 4b 	lsl	r11,r11,r6
8000b054:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b058:	18 4b       	or	r11,r12
8000b05a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b05e:	20 b6       	sub	r6,11
8000b060:	0c 17       	sub	r7,r6
8000b062:	ca ab       	rjmp	8000afb6 <__avr32_f64_mul+0x22>
8000b064:	f4 06 09 4b 	lsl	r11,r10,r6
8000b068:	c6 40       	breq	8000b130 <__avr32_f64_mul_res_zero>
8000b06a:	30 0a       	mov	r10,0
8000b06c:	20 b6       	sub	r6,11
8000b06e:	0c 17       	sub	r7,r6
8000b070:	ca 3b       	rjmp	8000afb6 <__avr32_f64_mul+0x22>

8000b072 <__avr32_f64_mul_op2_subnormal>:
8000b072:	e4 19 00 0f 	andh	r9,0xf
8000b076:	f0 0c 12 00 	clz	r12,r8
8000b07a:	f2 05 12 00 	clz	r5,r9
8000b07e:	f7 bc 03 ea 	sublo	r12,-22
8000b082:	f8 05 17 30 	movlo	r5,r12
8000b086:	f7 b5 02 0a 	subhs	r5,10
8000b08a:	e0 45 00 20 	cp.w	r5,32
8000b08e:	c0 d4       	brge	8000b0a8 <__avr32_f64_mul_op2_subnormal+0x36>
8000b090:	ea 0c 11 20 	rsub	r12,r5,32
8000b094:	f2 05 09 49 	lsl	r9,r9,r5
8000b098:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b09c:	18 49       	or	r9,r12
8000b09e:	f0 05 09 48 	lsl	r8,r8,r5
8000b0a2:	20 25       	sub	r5,2
8000b0a4:	0a 16       	sub	r6,r5
8000b0a6:	c8 fb       	rjmp	8000afc4 <__avr32_f64_mul+0x30>
8000b0a8:	f0 05 09 49 	lsl	r9,r8,r5
8000b0ac:	c4 20       	breq	8000b130 <__avr32_f64_mul_res_zero>
8000b0ae:	30 08       	mov	r8,0
8000b0b0:	20 25       	sub	r5,2
8000b0b2:	0a 16       	sub	r6,r5
8000b0b4:	c8 8b       	rjmp	8000afc4 <__avr32_f64_mul+0x30>

8000b0b6 <__avr32_f64_mul_op_nan_or_inf>:
8000b0b6:	e4 19 00 0f 	andh	r9,0xf
8000b0ba:	e4 1b 00 0f 	andh	r11,0xf
8000b0be:	14 4b       	or	r11,r10
8000b0c0:	10 49       	or	r9,r8
8000b0c2:	e0 47 07 ff 	cp.w	r7,2047
8000b0c6:	c0 91       	brne	8000b0d8 <__avr32_f64_mul_op1_not_naninf>
8000b0c8:	58 0b       	cp.w	r11,0
8000b0ca:	c3 81       	brne	8000b13a <__avr32_f64_mul_res_nan>
8000b0cc:	e0 46 07 ff 	cp.w	r6,2047
8000b0d0:	c3 81       	brne	8000b140 <__avr32_f64_mul_res_inf>
8000b0d2:	58 09       	cp.w	r9,0
8000b0d4:	c3 60       	breq	8000b140 <__avr32_f64_mul_res_inf>
8000b0d6:	c3 28       	rjmp	8000b13a <__avr32_f64_mul_res_nan>

8000b0d8 <__avr32_f64_mul_op1_not_naninf>:
8000b0d8:	58 09       	cp.w	r9,0
8000b0da:	c3 30       	breq	8000b140 <__avr32_f64_mul_res_inf>
8000b0dc:	c2 f8       	rjmp	8000b13a <__avr32_f64_mul_res_nan>

8000b0de <__avr32_f64_mul_res_subnormal>:
8000b0de:	5c 3c       	neg	r12
8000b0e0:	2f fc       	sub	r12,-1
8000b0e2:	f1 bc 04 c0 	satu	r12,0x6
8000b0e6:	e0 4c 00 20 	cp.w	r12,32
8000b0ea:	c1 14       	brge	8000b10c <__avr32_f64_mul_res_subnormal+0x2e>
8000b0ec:	f8 08 11 20 	rsub	r8,r12,32
8000b0f0:	0e 46       	or	r6,r7
8000b0f2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b0f6:	f4 08 09 49 	lsl	r9,r10,r8
8000b0fa:	12 47       	or	r7,r9
8000b0fc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b100:	f6 08 09 49 	lsl	r9,r11,r8
8000b104:	12 4a       	or	r10,r9
8000b106:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b10a:	c8 3b       	rjmp	8000b010 <__avr32_f64_mul+0x7c>
8000b10c:	f8 08 11 20 	rsub	r8,r12,32
8000b110:	f9 b9 00 00 	moveq	r9,0
8000b114:	c0 30       	breq	8000b11a <__avr32_f64_mul_res_subnormal+0x3c>
8000b116:	f6 08 09 49 	lsl	r9,r11,r8
8000b11a:	0e 46       	or	r6,r7
8000b11c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b120:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b124:	f3 ea 10 07 	or	r7,r9,r10
8000b128:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b12c:	30 0b       	mov	r11,0
8000b12e:	c7 1b       	rjmp	8000b010 <__avr32_f64_mul+0x7c>

8000b130 <__avr32_f64_mul_res_zero>:
8000b130:	1c 9b       	mov	r11,lr
8000b132:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b136:	30 0a       	mov	r10,0
8000b138:	d8 22       	popm	r4-r7,pc

8000b13a <__avr32_f64_mul_res_nan>:
8000b13a:	3f fb       	mov	r11,-1
8000b13c:	3f fa       	mov	r10,-1
8000b13e:	d8 22       	popm	r4-r7,pc

8000b140 <__avr32_f64_mul_res_inf>:
8000b140:	f0 6b 00 00 	mov	r11,-1048576
8000b144:	ed be 00 1f 	bld	lr,0x1f
8000b148:	ef bb 00 1f 	bst	r11,0x1f
8000b14c:	30 0a       	mov	r10,0
8000b14e:	d8 22       	popm	r4-r7,pc

8000b150 <__avr32_f64_mul_op1_zero>:
8000b150:	f7 e9 20 0b 	eor	r11,r11,r9
8000b154:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b158:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b15c:	e0 4c 07 ff 	cp.w	r12,2047
8000b160:	5e 1c       	retne	r12
8000b162:	3f fa       	mov	r10,-1
8000b164:	3f fb       	mov	r11,-1
8000b166:	5e fc       	retal	r12

8000b168 <__avr32_f64_sub_from_add>:
8000b168:	ee 19 80 00 	eorh	r9,0x8000

8000b16c <__avr32_f64_sub>:
8000b16c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b170:	e0 86 00 ca 	brmi	8000b304 <__avr32_f64_add_from_sub>
8000b174:	eb cd 40 e0 	pushm	r5-r7,lr
8000b178:	16 9c       	mov	r12,r11
8000b17a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b17e:	bf db       	cbr	r11,0x1f
8000b180:	bf d9       	cbr	r9,0x1f
8000b182:	10 3a       	cp.w	r10,r8
8000b184:	f2 0b 13 00 	cpc	r11,r9
8000b188:	c0 92       	brcc	8000b19a <__avr32_f64_sub+0x2e>
8000b18a:	16 97       	mov	r7,r11
8000b18c:	12 9b       	mov	r11,r9
8000b18e:	0e 99       	mov	r9,r7
8000b190:	14 97       	mov	r7,r10
8000b192:	10 9a       	mov	r10,r8
8000b194:	0e 98       	mov	r8,r7
8000b196:	ee 1c 80 00 	eorh	r12,0x8000
8000b19a:	f6 07 16 14 	lsr	r7,r11,0x14
8000b19e:	ab 7b       	lsl	r11,0xb
8000b1a0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b1a4:	ab 7a       	lsl	r10,0xb
8000b1a6:	bf bb       	sbr	r11,0x1f
8000b1a8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1ac:	c4 40       	breq	8000b234 <__avr32_f64_sub_opL_subnormal>
8000b1ae:	ab 79       	lsl	r9,0xb
8000b1b0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b1b4:	ab 78       	lsl	r8,0xb
8000b1b6:	bf b9       	sbr	r9,0x1f

8000b1b8 <__avr32_f64_sub_opL_subnormal_done>:
8000b1b8:	e0 47 07 ff 	cp.w	r7,2047
8000b1bc:	c4 f0       	breq	8000b25a <__avr32_f64_sub_opH_nan_or_inf>
8000b1be:	0e 26       	rsub	r6,r7
8000b1c0:	c1 20       	breq	8000b1e4 <__avr32_f64_sub_shift_done>
8000b1c2:	ec 05 11 20 	rsub	r5,r6,32
8000b1c6:	e0 46 00 20 	cp.w	r6,32
8000b1ca:	c7 c2       	brcc	8000b2c2 <__avr32_f64_sub_longshift>
8000b1cc:	f0 05 09 4e 	lsl	lr,r8,r5
8000b1d0:	f2 05 09 45 	lsl	r5,r9,r5
8000b1d4:	f0 06 0a 48 	lsr	r8,r8,r6
8000b1d8:	f2 06 0a 49 	lsr	r9,r9,r6
8000b1dc:	0a 48       	or	r8,r5
8000b1de:	58 0e       	cp.w	lr,0
8000b1e0:	5f 1e       	srne	lr
8000b1e2:	1c 48       	or	r8,lr

8000b1e4 <__avr32_f64_sub_shift_done>:
8000b1e4:	10 1a       	sub	r10,r8
8000b1e6:	f6 09 01 4b 	sbc	r11,r11,r9
8000b1ea:	f6 06 12 00 	clz	r6,r11
8000b1ee:	c0 e0       	breq	8000b20a <__avr32_f64_sub_longnormalize_done>
8000b1f0:	c7 83       	brcs	8000b2e0 <__avr32_f64_sub_longnormalize>
8000b1f2:	ec 0e 11 20 	rsub	lr,r6,32
8000b1f6:	f6 06 09 4b 	lsl	r11,r11,r6
8000b1fa:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b1fe:	1c 4b       	or	r11,lr
8000b200:	f4 06 09 4a 	lsl	r10,r10,r6
8000b204:	0c 17       	sub	r7,r6
8000b206:	e0 8a 00 39 	brle	8000b278 <__avr32_f64_sub_subnormal_result>

8000b20a <__avr32_f64_sub_longnormalize_done>:
8000b20a:	f4 09 15 15 	lsl	r9,r10,0x15
8000b20e:	ab 9a       	lsr	r10,0xb
8000b210:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b214:	ab 9b       	lsr	r11,0xb
8000b216:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b21a:	18 4b       	or	r11,r12

8000b21c <__avr32_f64_sub_round>:
8000b21c:	fc 17 80 00 	movh	r7,0x8000
8000b220:	ed ba 00 00 	bld	r10,0x0
8000b224:	f7 b7 01 ff 	subne	r7,-1
8000b228:	0e 39       	cp.w	r9,r7
8000b22a:	5f 29       	srhs	r9
8000b22c:	12 0a       	add	r10,r9
8000b22e:	5c 0b       	acr	r11
8000b230:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b234 <__avr32_f64_sub_opL_subnormal>:
8000b234:	ab 79       	lsl	r9,0xb
8000b236:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b23a:	ab 78       	lsl	r8,0xb
8000b23c:	f3 e8 10 0e 	or	lr,r9,r8
8000b240:	f9 b6 01 01 	movne	r6,1
8000b244:	ee 0e 11 00 	rsub	lr,r7,0
8000b248:	f9 b7 00 01 	moveq	r7,1
8000b24c:	ef bb 00 1f 	bst	r11,0x1f
8000b250:	f7 ea 10 0e 	or	lr,r11,r10
8000b254:	f9 b7 00 00 	moveq	r7,0
8000b258:	cb 0b       	rjmp	8000b1b8 <__avr32_f64_sub_opL_subnormal_done>

8000b25a <__avr32_f64_sub_opH_nan_or_inf>:
8000b25a:	bf db       	cbr	r11,0x1f
8000b25c:	f7 ea 10 0e 	or	lr,r11,r10
8000b260:	c0 81       	brne	8000b270 <__avr32_f64_sub_return_nan>
8000b262:	e0 46 07 ff 	cp.w	r6,2047
8000b266:	c0 50       	breq	8000b270 <__avr32_f64_sub_return_nan>
8000b268:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b26c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b270 <__avr32_f64_sub_return_nan>:
8000b270:	3f fa       	mov	r10,-1
8000b272:	3f fb       	mov	r11,-1
8000b274:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b278 <__avr32_f64_sub_subnormal_result>:
8000b278:	5c 37       	neg	r7
8000b27a:	2f f7       	sub	r7,-1
8000b27c:	f1 b7 04 c0 	satu	r7,0x6
8000b280:	e0 47 00 20 	cp.w	r7,32
8000b284:	c1 14       	brge	8000b2a6 <__avr32_f64_sub_subnormal_result+0x2e>
8000b286:	ee 08 11 20 	rsub	r8,r7,32
8000b28a:	f4 08 09 49 	lsl	r9,r10,r8
8000b28e:	5f 16       	srne	r6
8000b290:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b294:	0c 4a       	or	r10,r6
8000b296:	f6 08 09 49 	lsl	r9,r11,r8
8000b29a:	f5 e9 10 0a 	or	r10,r10,r9
8000b29e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b2a2:	30 07       	mov	r7,0
8000b2a4:	cb 3b       	rjmp	8000b20a <__avr32_f64_sub_longnormalize_done>
8000b2a6:	ee 08 11 40 	rsub	r8,r7,64
8000b2aa:	f6 08 09 49 	lsl	r9,r11,r8
8000b2ae:	14 49       	or	r9,r10
8000b2b0:	5f 16       	srne	r6
8000b2b2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b2b6:	0c 4a       	or	r10,r6
8000b2b8:	30 0b       	mov	r11,0
8000b2ba:	30 07       	mov	r7,0
8000b2bc:	ca 7b       	rjmp	8000b20a <__avr32_f64_sub_longnormalize_done>
8000b2be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2c2 <__avr32_f64_sub_longshift>:
8000b2c2:	f1 b6 04 c0 	satu	r6,0x6
8000b2c6:	f0 0e 17 00 	moveq	lr,r8
8000b2ca:	c0 40       	breq	8000b2d2 <__avr32_f64_sub_longshift+0x10>
8000b2cc:	f2 05 09 4e 	lsl	lr,r9,r5
8000b2d0:	10 4e       	or	lr,r8
8000b2d2:	f2 06 0a 48 	lsr	r8,r9,r6
8000b2d6:	30 09       	mov	r9,0
8000b2d8:	58 0e       	cp.w	lr,0
8000b2da:	5f 1e       	srne	lr
8000b2dc:	1c 48       	or	r8,lr
8000b2de:	c8 3b       	rjmp	8000b1e4 <__avr32_f64_sub_shift_done>

8000b2e0 <__avr32_f64_sub_longnormalize>:
8000b2e0:	f4 06 12 00 	clz	r6,r10
8000b2e4:	f9 b7 03 00 	movlo	r7,0
8000b2e8:	f9 b6 03 00 	movlo	r6,0
8000b2ec:	f9 bc 03 00 	movlo	r12,0
8000b2f0:	f7 b6 02 e0 	subhs	r6,-32
8000b2f4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b2f8:	30 0a       	mov	r10,0
8000b2fa:	0c 17       	sub	r7,r6
8000b2fc:	fe 9a ff be 	brle	8000b278 <__avr32_f64_sub_subnormal_result>
8000b300:	c8 5b       	rjmp	8000b20a <__avr32_f64_sub_longnormalize_done>
8000b302:	d7 03       	nop

8000b304 <__avr32_f64_add_from_sub>:
8000b304:	ee 19 80 00 	eorh	r9,0x8000

8000b308 <__avr32_f64_add>:
8000b308:	f7 e9 20 0c 	eor	r12,r11,r9
8000b30c:	fe 96 ff 2e 	brmi	8000b168 <__avr32_f64_sub_from_add>
8000b310:	eb cd 40 e0 	pushm	r5-r7,lr
8000b314:	16 9c       	mov	r12,r11
8000b316:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b31a:	bf db       	cbr	r11,0x1f
8000b31c:	bf d9       	cbr	r9,0x1f
8000b31e:	12 3b       	cp.w	r11,r9
8000b320:	c0 72       	brcc	8000b32e <__avr32_f64_add+0x26>
8000b322:	16 97       	mov	r7,r11
8000b324:	12 9b       	mov	r11,r9
8000b326:	0e 99       	mov	r9,r7
8000b328:	14 97       	mov	r7,r10
8000b32a:	10 9a       	mov	r10,r8
8000b32c:	0e 98       	mov	r8,r7
8000b32e:	30 0e       	mov	lr,0
8000b330:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b334:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b338:	b5 ab       	sbr	r11,0x14
8000b33a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b33e:	c6 20       	breq	8000b402 <__avr32_f64_add_op2_subnormal>
8000b340:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b344:	b5 a9       	sbr	r9,0x14
8000b346:	e0 47 07 ff 	cp.w	r7,2047
8000b34a:	c2 80       	breq	8000b39a <__avr32_f64_add_opH_nan_or_inf>
8000b34c:	0e 26       	rsub	r6,r7
8000b34e:	c1 20       	breq	8000b372 <__avr32_f64_add_shift_done>
8000b350:	e0 46 00 36 	cp.w	r6,54
8000b354:	c1 52       	brcc	8000b37e <__avr32_f64_add_res_of_done>
8000b356:	ec 05 11 20 	rsub	r5,r6,32
8000b35a:	e0 46 00 20 	cp.w	r6,32
8000b35e:	c3 52       	brcc	8000b3c8 <__avr32_f64_add_longshift>
8000b360:	f0 05 09 4e 	lsl	lr,r8,r5
8000b364:	f2 05 09 45 	lsl	r5,r9,r5
8000b368:	f0 06 0a 48 	lsr	r8,r8,r6
8000b36c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b370:	0a 48       	or	r8,r5

8000b372 <__avr32_f64_add_shift_done>:
8000b372:	10 0a       	add	r10,r8
8000b374:	f6 09 00 4b 	adc	r11,r11,r9
8000b378:	ed bb 00 15 	bld	r11,0x15
8000b37c:	c3 40       	breq	8000b3e4 <__avr32_f64_add_res_of>

8000b37e <__avr32_f64_add_res_of_done>:
8000b37e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b382:	18 4b       	or	r11,r12

8000b384 <__avr32_f64_add_round>:
8000b384:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b388:	18 4e       	or	lr,r12
8000b38a:	ee 1e 80 00 	eorh	lr,0x8000
8000b38e:	f1 be 04 20 	satu	lr,0x1
8000b392:	1c 0a       	add	r10,lr
8000b394:	5c 0b       	acr	r11
8000b396:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b39a <__avr32_f64_add_opH_nan_or_inf>:
8000b39a:	b5 cb       	cbr	r11,0x14
8000b39c:	f7 ea 10 0e 	or	lr,r11,r10
8000b3a0:	c1 01       	brne	8000b3c0 <__avr32_f64_add_return_nan>
8000b3a2:	e0 46 07 ff 	cp.w	r6,2047
8000b3a6:	c0 30       	breq	8000b3ac <__avr32_f64_add_opL_nan_or_inf>
8000b3a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3ac <__avr32_f64_add_opL_nan_or_inf>:
8000b3ac:	b5 c9       	cbr	r9,0x14
8000b3ae:	f3 e8 10 0e 	or	lr,r9,r8
8000b3b2:	c0 71       	brne	8000b3c0 <__avr32_f64_add_return_nan>
8000b3b4:	30 0a       	mov	r10,0
8000b3b6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b3ba:	18 4b       	or	r11,r12
8000b3bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3c0 <__avr32_f64_add_return_nan>:
8000b3c0:	3f fa       	mov	r10,-1
8000b3c2:	3f fb       	mov	r11,-1
8000b3c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3c8 <__avr32_f64_add_longshift>:
8000b3c8:	f1 b6 04 c0 	satu	r6,0x6
8000b3cc:	f0 0e 17 00 	moveq	lr,r8
8000b3d0:	c0 60       	breq	8000b3dc <__avr32_f64_add_longshift+0x14>
8000b3d2:	f2 05 09 4e 	lsl	lr,r9,r5
8000b3d6:	58 08       	cp.w	r8,0
8000b3d8:	5f 18       	srne	r8
8000b3da:	10 4e       	or	lr,r8
8000b3dc:	f2 06 0a 48 	lsr	r8,r9,r6
8000b3e0:	30 09       	mov	r9,0
8000b3e2:	cc 8b       	rjmp	8000b372 <__avr32_f64_add_shift_done>

8000b3e4 <__avr32_f64_add_res_of>:
8000b3e4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b3e8:	a1 9b       	lsr	r11,0x1
8000b3ea:	5d 0a       	ror	r10
8000b3ec:	5d 0e       	ror	lr
8000b3ee:	2f f7       	sub	r7,-1
8000b3f0:	e0 47 07 ff 	cp.w	r7,2047
8000b3f4:	f9 ba 00 00 	moveq	r10,0
8000b3f8:	f9 bb 00 00 	moveq	r11,0
8000b3fc:	f9 be 00 00 	moveq	lr,0
8000b400:	cb fb       	rjmp	8000b37e <__avr32_f64_add_res_of_done>

8000b402 <__avr32_f64_add_op2_subnormal>:
8000b402:	30 16       	mov	r6,1
8000b404:	58 07       	cp.w	r7,0
8000b406:	ca 01       	brne	8000b346 <__avr32_f64_add+0x3e>
8000b408:	b5 cb       	cbr	r11,0x14
8000b40a:	10 0a       	add	r10,r8
8000b40c:	f6 09 00 4b 	adc	r11,r11,r9
8000b410:	18 4b       	or	r11,r12
8000b412:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b416:	d7 03       	nop

8000b418 <__avr32_f64_to_u32>:
8000b418:	58 0b       	cp.w	r11,0
8000b41a:	5e 6d       	retmi	0

8000b41c <__avr32_f64_to_s32>:
8000b41c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b420:	b5 9c       	lsr	r12,0x15
8000b422:	e0 2c 03 ff 	sub	r12,1023
8000b426:	5e 3d       	retlo	0
8000b428:	f8 0c 11 1f 	rsub	r12,r12,31
8000b42c:	16 99       	mov	r9,r11
8000b42e:	ab 7b       	lsl	r11,0xb
8000b430:	bf bb       	sbr	r11,0x1f
8000b432:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b436:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b43a:	a1 79       	lsl	r9,0x1
8000b43c:	5e 2b       	reths	r11
8000b43e:	5c 3b       	neg	r11
8000b440:	5e fb       	retal	r11

8000b442 <__avr32_u32_to_f64>:
8000b442:	f8 cb 00 00 	sub	r11,r12,0
8000b446:	30 0c       	mov	r12,0
8000b448:	c0 38       	rjmp	8000b44e <__avr32_s32_to_f64+0x4>

8000b44a <__avr32_s32_to_f64>:
8000b44a:	18 9b       	mov	r11,r12
8000b44c:	5c 4b       	abs	r11
8000b44e:	30 0a       	mov	r10,0
8000b450:	5e 0b       	reteq	r11
8000b452:	d4 01       	pushm	lr
8000b454:	e0 69 04 1e 	mov	r9,1054
8000b458:	f6 08 12 00 	clz	r8,r11
8000b45c:	c1 70       	breq	8000b48a <__avr32_s32_to_f64+0x40>
8000b45e:	c0 c3       	brcs	8000b476 <__avr32_s32_to_f64+0x2c>
8000b460:	f0 0e 11 20 	rsub	lr,r8,32
8000b464:	f6 08 09 4b 	lsl	r11,r11,r8
8000b468:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b46c:	1c 4b       	or	r11,lr
8000b46e:	f4 08 09 4a 	lsl	r10,r10,r8
8000b472:	10 19       	sub	r9,r8
8000b474:	c0 b8       	rjmp	8000b48a <__avr32_s32_to_f64+0x40>
8000b476:	f4 08 12 00 	clz	r8,r10
8000b47a:	f9 b8 03 00 	movlo	r8,0
8000b47e:	f7 b8 02 e0 	subhs	r8,-32
8000b482:	f4 08 09 4b 	lsl	r11,r10,r8
8000b486:	30 0a       	mov	r10,0
8000b488:	10 19       	sub	r9,r8
8000b48a:	58 09       	cp.w	r9,0
8000b48c:	e0 89 00 30 	brgt	8000b4ec <__avr32_s32_to_f64+0xa2>
8000b490:	5c 39       	neg	r9
8000b492:	2f f9       	sub	r9,-1
8000b494:	e0 49 00 36 	cp.w	r9,54
8000b498:	c0 43       	brcs	8000b4a0 <__avr32_s32_to_f64+0x56>
8000b49a:	30 0b       	mov	r11,0
8000b49c:	30 0a       	mov	r10,0
8000b49e:	c2 68       	rjmp	8000b4ea <__avr32_s32_to_f64+0xa0>
8000b4a0:	2f 69       	sub	r9,-10
8000b4a2:	f2 08 11 20 	rsub	r8,r9,32
8000b4a6:	e0 49 00 20 	cp.w	r9,32
8000b4aa:	c0 b2       	brcc	8000b4c0 <__avr32_s32_to_f64+0x76>
8000b4ac:	f4 08 09 4e 	lsl	lr,r10,r8
8000b4b0:	f6 08 09 48 	lsl	r8,r11,r8
8000b4b4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4b8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b4bc:	10 4b       	or	r11,r8
8000b4be:	c0 88       	rjmp	8000b4ce <__avr32_s32_to_f64+0x84>
8000b4c0:	f6 08 09 4e 	lsl	lr,r11,r8
8000b4c4:	14 4e       	or	lr,r10
8000b4c6:	16 9a       	mov	r10,r11
8000b4c8:	30 0b       	mov	r11,0
8000b4ca:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4ce:	ed ba 00 00 	bld	r10,0x0
8000b4d2:	c0 92       	brcc	8000b4e4 <__avr32_s32_to_f64+0x9a>
8000b4d4:	1c 7e       	tst	lr,lr
8000b4d6:	c0 41       	brne	8000b4de <__avr32_s32_to_f64+0x94>
8000b4d8:	ed ba 00 01 	bld	r10,0x1
8000b4dc:	c0 42       	brcc	8000b4e4 <__avr32_s32_to_f64+0x9a>
8000b4de:	2f fa       	sub	r10,-1
8000b4e0:	f7 bb 02 ff 	subhs	r11,-1
8000b4e4:	5c fc       	rol	r12
8000b4e6:	5d 0b       	ror	r11
8000b4e8:	5d 0a       	ror	r10
8000b4ea:	d8 02       	popm	pc
8000b4ec:	e0 68 03 ff 	mov	r8,1023
8000b4f0:	ed ba 00 0b 	bld	r10,0xb
8000b4f4:	f7 b8 00 ff 	subeq	r8,-1
8000b4f8:	10 0a       	add	r10,r8
8000b4fa:	5c 0b       	acr	r11
8000b4fc:	f7 b9 03 fe 	sublo	r9,-2
8000b500:	e0 49 07 ff 	cp.w	r9,2047
8000b504:	c0 55       	brlt	8000b50e <__avr32_s32_to_f64+0xc4>
8000b506:	30 0a       	mov	r10,0
8000b508:	fc 1b ff e0 	movh	r11,0xffe0
8000b50c:	c0 c8       	rjmp	8000b524 <__floatsidf_return_op1>
8000b50e:	ed bb 00 1f 	bld	r11,0x1f
8000b512:	f7 b9 01 01 	subne	r9,1
8000b516:	ab 9a       	lsr	r10,0xb
8000b518:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b51c:	a1 7b       	lsl	r11,0x1
8000b51e:	ab 9b       	lsr	r11,0xb
8000b520:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b524 <__floatsidf_return_op1>:
8000b524:	a1 7c       	lsl	r12,0x1
8000b526:	5d 0b       	ror	r11
8000b528:	d8 02       	popm	pc

8000b52a <__avr32_f64_cmp_eq>:
8000b52a:	10 3a       	cp.w	r10,r8
8000b52c:	f2 0b 13 00 	cpc	r11,r9
8000b530:	c0 80       	breq	8000b540 <__avr32_f64_cmp_eq+0x16>
8000b532:	a1 7b       	lsl	r11,0x1
8000b534:	a1 79       	lsl	r9,0x1
8000b536:	14 4b       	or	r11,r10
8000b538:	12 4b       	or	r11,r9
8000b53a:	10 4b       	or	r11,r8
8000b53c:	5e 0f       	reteq	1
8000b53e:	5e fd       	retal	0
8000b540:	a1 7b       	lsl	r11,0x1
8000b542:	fc 1c ff e0 	movh	r12,0xffe0
8000b546:	58 0a       	cp.w	r10,0
8000b548:	f8 0b 13 00 	cpc	r11,r12
8000b54c:	5e 8f       	retls	1
8000b54e:	5e fd       	retal	0

8000b550 <__avr32_f64_cmp_ge>:
8000b550:	1a de       	st.w	--sp,lr
8000b552:	1a d7       	st.w	--sp,r7
8000b554:	a1 7b       	lsl	r11,0x1
8000b556:	5f 3c       	srlo	r12
8000b558:	a1 79       	lsl	r9,0x1
8000b55a:	5f 37       	srlo	r7
8000b55c:	5c fc       	rol	r12
8000b55e:	fc 1e ff e0 	movh	lr,0xffe0
8000b562:	58 0a       	cp.w	r10,0
8000b564:	fc 0b 13 00 	cpc	r11,lr
8000b568:	e0 8b 00 1d 	brhi	8000b5a2 <__avr32_f64_cmp_ge+0x52>
8000b56c:	58 08       	cp.w	r8,0
8000b56e:	fc 09 13 00 	cpc	r9,lr
8000b572:	e0 8b 00 18 	brhi	8000b5a2 <__avr32_f64_cmp_ge+0x52>
8000b576:	58 0b       	cp.w	r11,0
8000b578:	f5 ba 00 00 	subfeq	r10,0
8000b57c:	c1 50       	breq	8000b5a6 <__avr32_f64_cmp_ge+0x56>
8000b57e:	1b 07       	ld.w	r7,sp++
8000b580:	1b 0e       	ld.w	lr,sp++
8000b582:	58 3c       	cp.w	r12,3
8000b584:	c0 a0       	breq	8000b598 <__avr32_f64_cmp_ge+0x48>
8000b586:	58 1c       	cp.w	r12,1
8000b588:	c0 33       	brcs	8000b58e <__avr32_f64_cmp_ge+0x3e>
8000b58a:	5e 0f       	reteq	1
8000b58c:	5e 1d       	retne	0
8000b58e:	10 3a       	cp.w	r10,r8
8000b590:	f2 0b 13 00 	cpc	r11,r9
8000b594:	5e 2f       	reths	1
8000b596:	5e 3d       	retlo	0
8000b598:	14 38       	cp.w	r8,r10
8000b59a:	f6 09 13 00 	cpc	r9,r11
8000b59e:	5e 2f       	reths	1
8000b5a0:	5e 3d       	retlo	0
8000b5a2:	1b 07       	ld.w	r7,sp++
8000b5a4:	d8 0a       	popm	pc,r12=0
8000b5a6:	58 17       	cp.w	r7,1
8000b5a8:	5f 0c       	sreq	r12
8000b5aa:	58 09       	cp.w	r9,0
8000b5ac:	f5 b8 00 00 	subfeq	r8,0
8000b5b0:	1b 07       	ld.w	r7,sp++
8000b5b2:	1b 0e       	ld.w	lr,sp++
8000b5b4:	5e 0f       	reteq	1
8000b5b6:	5e fc       	retal	r12

8000b5b8 <__avr32_f64_cmp_lt>:
8000b5b8:	1a de       	st.w	--sp,lr
8000b5ba:	1a d7       	st.w	--sp,r7
8000b5bc:	a1 7b       	lsl	r11,0x1
8000b5be:	5f 3c       	srlo	r12
8000b5c0:	a1 79       	lsl	r9,0x1
8000b5c2:	5f 37       	srlo	r7
8000b5c4:	5c fc       	rol	r12
8000b5c6:	fc 1e ff e0 	movh	lr,0xffe0
8000b5ca:	58 0a       	cp.w	r10,0
8000b5cc:	fc 0b 13 00 	cpc	r11,lr
8000b5d0:	e0 8b 00 1d 	brhi	8000b60a <__avr32_f64_cmp_lt+0x52>
8000b5d4:	58 08       	cp.w	r8,0
8000b5d6:	fc 09 13 00 	cpc	r9,lr
8000b5da:	e0 8b 00 18 	brhi	8000b60a <__avr32_f64_cmp_lt+0x52>
8000b5de:	58 0b       	cp.w	r11,0
8000b5e0:	f5 ba 00 00 	subfeq	r10,0
8000b5e4:	c1 50       	breq	8000b60e <__avr32_f64_cmp_lt+0x56>
8000b5e6:	1b 07       	ld.w	r7,sp++
8000b5e8:	1b 0e       	ld.w	lr,sp++
8000b5ea:	58 3c       	cp.w	r12,3
8000b5ec:	c0 a0       	breq	8000b600 <__avr32_f64_cmp_lt+0x48>
8000b5ee:	58 1c       	cp.w	r12,1
8000b5f0:	c0 33       	brcs	8000b5f6 <__avr32_f64_cmp_lt+0x3e>
8000b5f2:	5e 0d       	reteq	0
8000b5f4:	5e 1f       	retne	1
8000b5f6:	10 3a       	cp.w	r10,r8
8000b5f8:	f2 0b 13 00 	cpc	r11,r9
8000b5fc:	5e 2d       	reths	0
8000b5fe:	5e 3f       	retlo	1
8000b600:	14 38       	cp.w	r8,r10
8000b602:	f6 09 13 00 	cpc	r9,r11
8000b606:	5e 2d       	reths	0
8000b608:	5e 3f       	retlo	1
8000b60a:	1b 07       	ld.w	r7,sp++
8000b60c:	d8 0a       	popm	pc,r12=0
8000b60e:	58 17       	cp.w	r7,1
8000b610:	5f 1c       	srne	r12
8000b612:	58 09       	cp.w	r9,0
8000b614:	f5 b8 00 00 	subfeq	r8,0
8000b618:	1b 07       	ld.w	r7,sp++
8000b61a:	1b 0e       	ld.w	lr,sp++
8000b61c:	5e 0d       	reteq	0
8000b61e:	5e fc       	retal	r12

8000b620 <__avr32_f64_div>:
8000b620:	eb cd 40 ff 	pushm	r0-r7,lr
8000b624:	f7 e9 20 0e 	eor	lr,r11,r9
8000b628:	f6 07 16 14 	lsr	r7,r11,0x14
8000b62c:	a9 7b       	lsl	r11,0x9
8000b62e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b632:	a9 7a       	lsl	r10,0x9
8000b634:	bd bb       	sbr	r11,0x1d
8000b636:	e4 1b 3f ff 	andh	r11,0x3fff
8000b63a:	ab d7       	cbr	r7,0xb
8000b63c:	e0 80 00 cc 	breq	8000b7d4 <__avr32_f64_div_round_subnormal+0x54>
8000b640:	e0 47 07 ff 	cp.w	r7,2047
8000b644:	e0 84 00 b5 	brge	8000b7ae <__avr32_f64_div_round_subnormal+0x2e>
8000b648:	f2 06 16 14 	lsr	r6,r9,0x14
8000b64c:	a9 79       	lsl	r9,0x9
8000b64e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b652:	a9 78       	lsl	r8,0x9
8000b654:	bd b9       	sbr	r9,0x1d
8000b656:	e4 19 3f ff 	andh	r9,0x3fff
8000b65a:	ab d6       	cbr	r6,0xb
8000b65c:	e0 80 00 e2 	breq	8000b820 <__avr32_f64_div_round_subnormal+0xa0>
8000b660:	e0 46 07 ff 	cp.w	r6,2047
8000b664:	e0 84 00 b2 	brge	8000b7c8 <__avr32_f64_div_round_subnormal+0x48>
8000b668:	0c 17       	sub	r7,r6
8000b66a:	fe 37 fc 01 	sub	r7,-1023
8000b66e:	fc 1c 80 00 	movh	r12,0x8000
8000b672:	f8 03 16 01 	lsr	r3,r12,0x1
8000b676:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b67a:	5c d4       	com	r4
8000b67c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b680:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b684:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b688:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b68c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b690:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b694:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b698:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b69c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6a0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6a4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6a8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6ac:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6b0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6b4:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6b8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6bc:	02 04       	add	r4,r1
8000b6be:	5c 05       	acr	r5
8000b6c0:	a3 65       	lsl	r5,0x2
8000b6c2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b6c6:	a3 64       	lsl	r4,0x2
8000b6c8:	5c 34       	neg	r4
8000b6ca:	f8 05 01 45 	sbc	r5,r12,r5
8000b6ce:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b6d2:	e4 05 07 40 	macu.d	r0,r2,r5
8000b6d6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6da:	02 04       	add	r4,r1
8000b6dc:	5c 05       	acr	r5
8000b6de:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6e2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b6e6:	e8 02 15 02 	lsl	r2,r4,0x2
8000b6ea:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6ee:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6f2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6f6:	02 04       	add	r4,r1
8000b6f8:	5c 05       	acr	r5
8000b6fa:	a3 65       	lsl	r5,0x2
8000b6fc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b700:	a3 64       	lsl	r4,0x2
8000b702:	5c 34       	neg	r4
8000b704:	f8 05 01 45 	sbc	r5,r12,r5
8000b708:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b70c:	e4 05 07 40 	macu.d	r0,r2,r5
8000b710:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b714:	02 04       	add	r4,r1
8000b716:	5c 05       	acr	r5
8000b718:	ea 03 15 02 	lsl	r3,r5,0x2
8000b71c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b720:	e8 02 15 02 	lsl	r2,r4,0x2
8000b724:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b728:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b72c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b730:	02 02       	add	r2,r1
8000b732:	5c 03       	acr	r3
8000b734:	ed b3 00 1c 	bld	r3,0x1c
8000b738:	c0 90       	breq	8000b74a <__avr32_f64_div+0x12a>
8000b73a:	a1 72       	lsl	r2,0x1
8000b73c:	5c f3       	rol	r3
8000b73e:	20 17       	sub	r7,1
8000b740:	a3 9a       	lsr	r10,0x3
8000b742:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b746:	a3 9b       	lsr	r11,0x3
8000b748:	c0 58       	rjmp	8000b752 <__avr32_f64_div+0x132>
8000b74a:	a5 8a       	lsr	r10,0x4
8000b74c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b750:	a5 8b       	lsr	r11,0x4
8000b752:	58 07       	cp.w	r7,0
8000b754:	e0 8a 00 8b 	brle	8000b86a <__avr32_f64_div_res_subnormal>
8000b758:	e0 12 ff 00 	andl	r2,0xff00
8000b75c:	e8 12 00 80 	orl	r2,0x80
8000b760:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b764:	e4 09 07 40 	macu.d	r0,r2,r9
8000b768:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b76c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b770:	00 05       	add	r5,r0
8000b772:	f0 01 00 48 	adc	r8,r8,r1
8000b776:	5c 09       	acr	r9
8000b778:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b77c:	58 04       	cp.w	r4,0
8000b77e:	5c 25       	cpc	r5

8000b780 <__avr32_f64_div_round_subnormal>:
8000b780:	f4 08 13 00 	cpc	r8,r10
8000b784:	f6 09 13 00 	cpc	r9,r11
8000b788:	5f 36       	srlo	r6
8000b78a:	f8 06 17 00 	moveq	r6,r12
8000b78e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b792:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b796:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b79a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b79e:	ed be 00 1f 	bld	lr,0x1f
8000b7a2:	ef bb 00 1f 	bst	r11,0x1f
8000b7a6:	0c 0a       	add	r10,r6
8000b7a8:	5c 0b       	acr	r11
8000b7aa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b7ae:	e4 1b 00 0f 	andh	r11,0xf
8000b7b2:	14 4b       	or	r11,r10
8000b7b4:	e0 81 00 a7 	brne	8000b902 <__avr32_f64_div_res_subnormal+0x98>
8000b7b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7bc:	ab d6       	cbr	r6,0xb
8000b7be:	e0 46 07 ff 	cp.w	r6,2047
8000b7c2:	e0 81 00 a4 	brne	8000b90a <__avr32_f64_div_res_subnormal+0xa0>
8000b7c6:	c9 e8       	rjmp	8000b902 <__avr32_f64_div_res_subnormal+0x98>
8000b7c8:	e4 19 00 0f 	andh	r9,0xf
8000b7cc:	10 49       	or	r9,r8
8000b7ce:	e0 81 00 9a 	brne	8000b902 <__avr32_f64_div_res_subnormal+0x98>
8000b7d2:	c9 28       	rjmp	8000b8f6 <__avr32_f64_div_res_subnormal+0x8c>
8000b7d4:	a3 7b       	lsl	r11,0x3
8000b7d6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b7da:	a3 7a       	lsl	r10,0x3
8000b7dc:	f5 eb 10 04 	or	r4,r10,r11
8000b7e0:	e0 80 00 a0 	breq	8000b920 <__avr32_f64_div_op1_zero>
8000b7e4:	f6 04 12 00 	clz	r4,r11
8000b7e8:	c1 70       	breq	8000b816 <__avr32_f64_div_round_subnormal+0x96>
8000b7ea:	c0 c3       	brcs	8000b802 <__avr32_f64_div_round_subnormal+0x82>
8000b7ec:	e8 05 11 20 	rsub	r5,r4,32
8000b7f0:	f6 04 09 4b 	lsl	r11,r11,r4
8000b7f4:	f4 05 0a 45 	lsr	r5,r10,r5
8000b7f8:	0a 4b       	or	r11,r5
8000b7fa:	f4 04 09 4a 	lsl	r10,r10,r4
8000b7fe:	08 17       	sub	r7,r4
8000b800:	c0 b8       	rjmp	8000b816 <__avr32_f64_div_round_subnormal+0x96>
8000b802:	f4 04 12 00 	clz	r4,r10
8000b806:	f9 b4 03 00 	movlo	r4,0
8000b80a:	f7 b4 02 e0 	subhs	r4,-32
8000b80e:	f4 04 09 4b 	lsl	r11,r10,r4
8000b812:	30 0a       	mov	r10,0
8000b814:	08 17       	sub	r7,r4
8000b816:	a3 8a       	lsr	r10,0x2
8000b818:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b81c:	a3 8b       	lsr	r11,0x2
8000b81e:	c1 1b       	rjmp	8000b640 <__avr32_f64_div+0x20>
8000b820:	a3 79       	lsl	r9,0x3
8000b822:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b826:	a3 78       	lsl	r8,0x3
8000b828:	f3 e8 10 04 	or	r4,r9,r8
8000b82c:	c6 f0       	breq	8000b90a <__avr32_f64_div_res_subnormal+0xa0>
8000b82e:	f2 04 12 00 	clz	r4,r9
8000b832:	c1 70       	breq	8000b860 <__avr32_f64_div_round_subnormal+0xe0>
8000b834:	c0 c3       	brcs	8000b84c <__avr32_f64_div_round_subnormal+0xcc>
8000b836:	e8 05 11 20 	rsub	r5,r4,32
8000b83a:	f2 04 09 49 	lsl	r9,r9,r4
8000b83e:	f0 05 0a 45 	lsr	r5,r8,r5
8000b842:	0a 49       	or	r9,r5
8000b844:	f0 04 09 48 	lsl	r8,r8,r4
8000b848:	08 16       	sub	r6,r4
8000b84a:	c0 b8       	rjmp	8000b860 <__avr32_f64_div_round_subnormal+0xe0>
8000b84c:	f0 04 12 00 	clz	r4,r8
8000b850:	f9 b4 03 00 	movlo	r4,0
8000b854:	f7 b4 02 e0 	subhs	r4,-32
8000b858:	f0 04 09 49 	lsl	r9,r8,r4
8000b85c:	30 08       	mov	r8,0
8000b85e:	08 16       	sub	r6,r4
8000b860:	a3 88       	lsr	r8,0x2
8000b862:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b866:	a3 89       	lsr	r9,0x2
8000b868:	cf ca       	rjmp	8000b660 <__avr32_f64_div+0x40>

8000b86a <__avr32_f64_div_res_subnormal>:
8000b86a:	5c 37       	neg	r7
8000b86c:	2f f7       	sub	r7,-1
8000b86e:	f1 b7 04 c0 	satu	r7,0x6
8000b872:	e0 47 00 20 	cp.w	r7,32
8000b876:	c1 54       	brge	8000b8a0 <__avr32_f64_div_res_subnormal+0x36>
8000b878:	ee 06 11 20 	rsub	r6,r7,32
8000b87c:	e4 07 0a 42 	lsr	r2,r2,r7
8000b880:	e6 06 09 4c 	lsl	r12,r3,r6
8000b884:	18 42       	or	r2,r12
8000b886:	e6 07 0a 43 	lsr	r3,r3,r7
8000b88a:	f4 06 09 41 	lsl	r1,r10,r6
8000b88e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b892:	f6 06 09 4c 	lsl	r12,r11,r6
8000b896:	18 4a       	or	r10,r12
8000b898:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b89c:	30 00       	mov	r0,0
8000b89e:	c1 58       	rjmp	8000b8c8 <__avr32_f64_div_res_subnormal+0x5e>
8000b8a0:	ee 06 11 20 	rsub	r6,r7,32
8000b8a4:	f9 b0 00 00 	moveq	r0,0
8000b8a8:	f9 bc 00 00 	moveq	r12,0
8000b8ac:	c0 50       	breq	8000b8b6 <__avr32_f64_div_res_subnormal+0x4c>
8000b8ae:	f4 06 09 40 	lsl	r0,r10,r6
8000b8b2:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8b6:	e6 07 0a 42 	lsr	r2,r3,r7
8000b8ba:	30 03       	mov	r3,0
8000b8bc:	f4 07 0a 41 	lsr	r1,r10,r7
8000b8c0:	18 41       	or	r1,r12
8000b8c2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b8c6:	30 0b       	mov	r11,0
8000b8c8:	e0 12 ff 00 	andl	r2,0xff00
8000b8cc:	e8 12 00 80 	orl	r2,0x80
8000b8d0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b8d4:	e4 09 07 46 	macu.d	r6,r2,r9
8000b8d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b8dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b8e0:	0c 05       	add	r5,r6
8000b8e2:	f0 07 00 48 	adc	r8,r8,r7
8000b8e6:	5c 09       	acr	r9
8000b8e8:	30 07       	mov	r7,0
8000b8ea:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b8ee:	00 34       	cp.w	r4,r0
8000b8f0:	e2 05 13 00 	cpc	r5,r1
8000b8f4:	c4 6b       	rjmp	8000b780 <__avr32_f64_div_round_subnormal>
8000b8f6:	1c 9b       	mov	r11,lr
8000b8f8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b8fc:	30 0a       	mov	r10,0
8000b8fe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b902:	3f fb       	mov	r11,-1
8000b904:	30 0a       	mov	r10,0
8000b906:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b90a:	f5 eb 10 04 	or	r4,r10,r11
8000b90e:	c0 90       	breq	8000b920 <__avr32_f64_div_op1_zero>
8000b910:	1c 9b       	mov	r11,lr
8000b912:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b916:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b91a:	30 0a       	mov	r10,0
8000b91c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b920 <__avr32_f64_div_op1_zero>:
8000b920:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b924:	ce f0       	breq	8000b902 <__avr32_f64_div_res_subnormal+0x98>
8000b926:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b92a:	e0 44 07 ff 	cp.w	r4,2047
8000b92e:	ce 41       	brne	8000b8f6 <__avr32_f64_div_res_subnormal+0x8c>
8000b930:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b934:	ce 10       	breq	8000b8f6 <__avr32_f64_div_res_subnormal+0x8c>
8000b936:	ce 6b       	rjmp	8000b902 <__avr32_f64_div_res_subnormal+0x98>

8000b938 <__avr32_udiv64>:
8000b938:	d4 31       	pushm	r0-r7,lr
8000b93a:	1a 97       	mov	r7,sp
8000b93c:	20 3d       	sub	sp,12
8000b93e:	10 9c       	mov	r12,r8
8000b940:	12 9e       	mov	lr,r9
8000b942:	14 93       	mov	r3,r10
8000b944:	58 09       	cp.w	r9,0
8000b946:	e0 81 00 bd 	brne	8000bac0 <__avr32_udiv64+0x188>
8000b94a:	16 38       	cp.w	r8,r11
8000b94c:	e0 88 00 40 	brls	8000b9cc <__avr32_udiv64+0x94>
8000b950:	f0 08 12 00 	clz	r8,r8
8000b954:	c0 d0       	breq	8000b96e <__avr32_udiv64+0x36>
8000b956:	f6 08 09 4b 	lsl	r11,r11,r8
8000b95a:	f0 09 11 20 	rsub	r9,r8,32
8000b95e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b962:	f4 09 0a 49 	lsr	r9,r10,r9
8000b966:	f4 08 09 43 	lsl	r3,r10,r8
8000b96a:	f3 eb 10 0b 	or	r11,r9,r11
8000b96e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b972:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b976:	f6 0e 0d 00 	divu	r0,r11,lr
8000b97a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b97e:	00 99       	mov	r9,r0
8000b980:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b984:	e0 0a 02 48 	mul	r8,r0,r10
8000b988:	10 3b       	cp.w	r11,r8
8000b98a:	c0 a2       	brcc	8000b99e <__avr32_udiv64+0x66>
8000b98c:	20 19       	sub	r9,1
8000b98e:	18 0b       	add	r11,r12
8000b990:	18 3b       	cp.w	r11,r12
8000b992:	c0 63       	brcs	8000b99e <__avr32_udiv64+0x66>
8000b994:	10 3b       	cp.w	r11,r8
8000b996:	f7 b9 03 01 	sublo	r9,1
8000b99a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b99e:	f6 08 01 01 	sub	r1,r11,r8
8000b9a2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b9a6:	e2 0e 0d 00 	divu	r0,r1,lr
8000b9aa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b9ae:	00 98       	mov	r8,r0
8000b9b0:	e0 0a 02 4a 	mul	r10,r0,r10
8000b9b4:	14 33       	cp.w	r3,r10
8000b9b6:	c0 82       	brcc	8000b9c6 <__avr32_udiv64+0x8e>
8000b9b8:	20 18       	sub	r8,1
8000b9ba:	18 03       	add	r3,r12
8000b9bc:	18 33       	cp.w	r3,r12
8000b9be:	c0 43       	brcs	8000b9c6 <__avr32_udiv64+0x8e>
8000b9c0:	14 33       	cp.w	r3,r10
8000b9c2:	f7 b8 03 01 	sublo	r8,1
8000b9c6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b9ca:	cd f8       	rjmp	8000bb88 <__avr32_udiv64+0x250>
8000b9cc:	58 08       	cp.w	r8,0
8000b9ce:	c0 51       	brne	8000b9d8 <__avr32_udiv64+0xa0>
8000b9d0:	30 19       	mov	r9,1
8000b9d2:	f2 08 0d 08 	divu	r8,r9,r8
8000b9d6:	10 9c       	mov	r12,r8
8000b9d8:	f8 06 12 00 	clz	r6,r12
8000b9dc:	c0 41       	brne	8000b9e4 <__avr32_udiv64+0xac>
8000b9de:	18 1b       	sub	r11,r12
8000b9e0:	30 19       	mov	r9,1
8000b9e2:	c4 08       	rjmp	8000ba62 <__avr32_udiv64+0x12a>
8000b9e4:	ec 01 11 20 	rsub	r1,r6,32
8000b9e8:	f4 01 0a 49 	lsr	r9,r10,r1
8000b9ec:	f8 06 09 4c 	lsl	r12,r12,r6
8000b9f0:	f6 06 09 48 	lsl	r8,r11,r6
8000b9f4:	f6 01 0a 41 	lsr	r1,r11,r1
8000b9f8:	f3 e8 10 08 	or	r8,r9,r8
8000b9fc:	f8 03 16 10 	lsr	r3,r12,0x10
8000ba00:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ba04:	e2 03 0d 00 	divu	r0,r1,r3
8000ba08:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ba0c:	00 9e       	mov	lr,r0
8000ba0e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba12:	e0 05 02 49 	mul	r9,r0,r5
8000ba16:	12 3b       	cp.w	r11,r9
8000ba18:	c0 a2       	brcc	8000ba2c <__avr32_udiv64+0xf4>
8000ba1a:	20 1e       	sub	lr,1
8000ba1c:	18 0b       	add	r11,r12
8000ba1e:	18 3b       	cp.w	r11,r12
8000ba20:	c0 63       	brcs	8000ba2c <__avr32_udiv64+0xf4>
8000ba22:	12 3b       	cp.w	r11,r9
8000ba24:	f7 be 03 01 	sublo	lr,1
8000ba28:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba2c:	12 1b       	sub	r11,r9
8000ba2e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba32:	f6 03 0d 02 	divu	r2,r11,r3
8000ba36:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ba3a:	04 99       	mov	r9,r2
8000ba3c:	e4 05 02 4b 	mul	r11,r2,r5
8000ba40:	16 38       	cp.w	r8,r11
8000ba42:	c0 a2       	brcc	8000ba56 <__avr32_udiv64+0x11e>
8000ba44:	20 19       	sub	r9,1
8000ba46:	18 08       	add	r8,r12
8000ba48:	18 38       	cp.w	r8,r12
8000ba4a:	c0 63       	brcs	8000ba56 <__avr32_udiv64+0x11e>
8000ba4c:	16 38       	cp.w	r8,r11
8000ba4e:	f7 b9 03 01 	sublo	r9,1
8000ba52:	f1 dc e3 08 	addcs	r8,r8,r12
8000ba56:	f4 06 09 43 	lsl	r3,r10,r6
8000ba5a:	f0 0b 01 0b 	sub	r11,r8,r11
8000ba5e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ba62:	f8 06 16 10 	lsr	r6,r12,0x10
8000ba66:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ba6a:	f6 06 0d 00 	divu	r0,r11,r6
8000ba6e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba72:	00 9a       	mov	r10,r0
8000ba74:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba78:	e0 0e 02 48 	mul	r8,r0,lr
8000ba7c:	10 3b       	cp.w	r11,r8
8000ba7e:	c0 a2       	brcc	8000ba92 <__avr32_udiv64+0x15a>
8000ba80:	20 1a       	sub	r10,1
8000ba82:	18 0b       	add	r11,r12
8000ba84:	18 3b       	cp.w	r11,r12
8000ba86:	c0 63       	brcs	8000ba92 <__avr32_udiv64+0x15a>
8000ba88:	10 3b       	cp.w	r11,r8
8000ba8a:	f7 ba 03 01 	sublo	r10,1
8000ba8e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba92:	f6 08 01 01 	sub	r1,r11,r8
8000ba96:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba9a:	e2 06 0d 00 	divu	r0,r1,r6
8000ba9e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000baa2:	00 98       	mov	r8,r0
8000baa4:	e0 0e 02 4b 	mul	r11,r0,lr
8000baa8:	16 33       	cp.w	r3,r11
8000baaa:	c0 82       	brcc	8000baba <__avr32_udiv64+0x182>
8000baac:	20 18       	sub	r8,1
8000baae:	18 03       	add	r3,r12
8000bab0:	18 33       	cp.w	r3,r12
8000bab2:	c0 43       	brcs	8000baba <__avr32_udiv64+0x182>
8000bab4:	16 33       	cp.w	r3,r11
8000bab6:	f7 b8 03 01 	sublo	r8,1
8000baba:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000babe:	c6 98       	rjmp	8000bb90 <__avr32_udiv64+0x258>
8000bac0:	16 39       	cp.w	r9,r11
8000bac2:	e0 8b 00 65 	brhi	8000bb8c <__avr32_udiv64+0x254>
8000bac6:	f2 09 12 00 	clz	r9,r9
8000baca:	c0 b1       	brne	8000bae0 <__avr32_udiv64+0x1a8>
8000bacc:	10 3a       	cp.w	r10,r8
8000bace:	5f 2a       	srhs	r10
8000bad0:	1c 3b       	cp.w	r11,lr
8000bad2:	5f b8       	srhi	r8
8000bad4:	10 4a       	or	r10,r8
8000bad6:	f2 0a 18 00 	cp.b	r10,r9
8000bada:	c5 90       	breq	8000bb8c <__avr32_udiv64+0x254>
8000badc:	30 18       	mov	r8,1
8000bade:	c5 98       	rjmp	8000bb90 <__avr32_udiv64+0x258>
8000bae0:	f0 09 09 46 	lsl	r6,r8,r9
8000bae4:	f2 03 11 20 	rsub	r3,r9,32
8000bae8:	fc 09 09 4e 	lsl	lr,lr,r9
8000baec:	f0 03 0a 48 	lsr	r8,r8,r3
8000baf0:	f6 09 09 4c 	lsl	r12,r11,r9
8000baf4:	f4 03 0a 42 	lsr	r2,r10,r3
8000baf8:	ef 46 ff f4 	st.w	r7[-12],r6
8000bafc:	f6 03 0a 43 	lsr	r3,r11,r3
8000bb00:	18 42       	or	r2,r12
8000bb02:	f1 ee 10 0c 	or	r12,r8,lr
8000bb06:	f8 01 16 10 	lsr	r1,r12,0x10
8000bb0a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb0e:	e6 01 0d 04 	divu	r4,r3,r1
8000bb12:	e4 03 16 10 	lsr	r3,r2,0x10
8000bb16:	08 9e       	mov	lr,r4
8000bb18:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bb1c:	e8 06 02 48 	mul	r8,r4,r6
8000bb20:	10 33       	cp.w	r3,r8
8000bb22:	c0 a2       	brcc	8000bb36 <__avr32_udiv64+0x1fe>
8000bb24:	20 1e       	sub	lr,1
8000bb26:	18 03       	add	r3,r12
8000bb28:	18 33       	cp.w	r3,r12
8000bb2a:	c0 63       	brcs	8000bb36 <__avr32_udiv64+0x1fe>
8000bb2c:	10 33       	cp.w	r3,r8
8000bb2e:	f7 be 03 01 	sublo	lr,1
8000bb32:	e7 dc e3 03 	addcs	r3,r3,r12
8000bb36:	10 13       	sub	r3,r8
8000bb38:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bb3c:	e6 01 0d 00 	divu	r0,r3,r1
8000bb40:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb44:	00 98       	mov	r8,r0
8000bb46:	e0 06 02 46 	mul	r6,r0,r6
8000bb4a:	0c 3b       	cp.w	r11,r6
8000bb4c:	c0 a2       	brcc	8000bb60 <__avr32_udiv64+0x228>
8000bb4e:	20 18       	sub	r8,1
8000bb50:	18 0b       	add	r11,r12
8000bb52:	18 3b       	cp.w	r11,r12
8000bb54:	c0 63       	brcs	8000bb60 <__avr32_udiv64+0x228>
8000bb56:	0c 3b       	cp.w	r11,r6
8000bb58:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb5c:	f7 b8 03 01 	sublo	r8,1
8000bb60:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bb64:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bb68:	0c 1b       	sub	r11,r6
8000bb6a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bb6e:	06 95       	mov	r5,r3
8000bb70:	16 35       	cp.w	r5,r11
8000bb72:	e0 8b 00 0a 	brhi	8000bb86 <__avr32_udiv64+0x24e>
8000bb76:	5f 0b       	sreq	r11
8000bb78:	f4 09 09 49 	lsl	r9,r10,r9
8000bb7c:	12 32       	cp.w	r2,r9
8000bb7e:	5f b9       	srhi	r9
8000bb80:	f7 e9 00 09 	and	r9,r11,r9
8000bb84:	c0 60       	breq	8000bb90 <__avr32_udiv64+0x258>
8000bb86:	20 18       	sub	r8,1
8000bb88:	30 09       	mov	r9,0
8000bb8a:	c0 38       	rjmp	8000bb90 <__avr32_udiv64+0x258>
8000bb8c:	30 09       	mov	r9,0
8000bb8e:	12 98       	mov	r8,r9
8000bb90:	10 9a       	mov	r10,r8
8000bb92:	12 93       	mov	r3,r9
8000bb94:	10 92       	mov	r2,r8
8000bb96:	12 9b       	mov	r11,r9
8000bb98:	2f dd       	sub	sp,-12
8000bb9a:	d8 32       	popm	r0-r7,pc

8000bb9c <__avr32_umod64>:
8000bb9c:	d4 31       	pushm	r0-r7,lr
8000bb9e:	1a 97       	mov	r7,sp
8000bba0:	20 3d       	sub	sp,12
8000bba2:	10 9c       	mov	r12,r8
8000bba4:	12 95       	mov	r5,r9
8000bba6:	14 9e       	mov	lr,r10
8000bba8:	16 91       	mov	r1,r11
8000bbaa:	16 96       	mov	r6,r11
8000bbac:	58 09       	cp.w	r9,0
8000bbae:	e0 81 00 81 	brne	8000bcb0 <__avr32_umod64+0x114>
8000bbb2:	16 38       	cp.w	r8,r11
8000bbb4:	e0 88 00 12 	brls	8000bbd8 <__avr32_umod64+0x3c>
8000bbb8:	f0 08 12 00 	clz	r8,r8
8000bbbc:	c4 e0       	breq	8000bc58 <__avr32_umod64+0xbc>
8000bbbe:	f6 08 09 46 	lsl	r6,r11,r8
8000bbc2:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbc6:	f0 0b 11 20 	rsub	r11,r8,32
8000bbca:	f4 08 09 4e 	lsl	lr,r10,r8
8000bbce:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bbd2:	f7 e6 10 06 	or	r6,r11,r6
8000bbd6:	c4 18       	rjmp	8000bc58 <__avr32_umod64+0xbc>
8000bbd8:	58 08       	cp.w	r8,0
8000bbda:	c0 51       	brne	8000bbe4 <__avr32_umod64+0x48>
8000bbdc:	30 19       	mov	r9,1
8000bbde:	f2 08 0d 08 	divu	r8,r9,r8
8000bbe2:	10 9c       	mov	r12,r8
8000bbe4:	f8 08 12 00 	clz	r8,r12
8000bbe8:	c0 31       	brne	8000bbee <__avr32_umod64+0x52>
8000bbea:	18 16       	sub	r6,r12
8000bbec:	c3 68       	rjmp	8000bc58 <__avr32_umod64+0xbc>
8000bbee:	f0 03 11 20 	rsub	r3,r8,32
8000bbf2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bbf6:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbfa:	ec 08 09 49 	lsl	r9,r6,r8
8000bbfe:	ec 03 0a 43 	lsr	r3,r6,r3
8000bc02:	f7 e9 10 09 	or	r9,r11,r9
8000bc06:	f8 05 16 10 	lsr	r5,r12,0x10
8000bc0a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bc0e:	e6 05 0d 02 	divu	r2,r3,r5
8000bc12:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bc16:	ec 02 02 4b 	mul	r11,r6,r2
8000bc1a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bc1e:	16 3e       	cp.w	lr,r11
8000bc20:	c0 72       	brcc	8000bc2e <__avr32_umod64+0x92>
8000bc22:	18 0e       	add	lr,r12
8000bc24:	18 3e       	cp.w	lr,r12
8000bc26:	c0 43       	brcs	8000bc2e <__avr32_umod64+0x92>
8000bc28:	16 3e       	cp.w	lr,r11
8000bc2a:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc2e:	fc 0b 01 03 	sub	r3,lr,r11
8000bc32:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bc36:	e6 05 0d 02 	divu	r2,r3,r5
8000bc3a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc3e:	a5 36       	mul	r6,r2
8000bc40:	0c 39       	cp.w	r9,r6
8000bc42:	c0 72       	brcc	8000bc50 <__avr32_umod64+0xb4>
8000bc44:	18 09       	add	r9,r12
8000bc46:	18 39       	cp.w	r9,r12
8000bc48:	c0 43       	brcs	8000bc50 <__avr32_umod64+0xb4>
8000bc4a:	0c 39       	cp.w	r9,r6
8000bc4c:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc50:	f2 06 01 06 	sub	r6,r9,r6
8000bc54:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc58:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bc5c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bc60:	ec 0a 0d 02 	divu	r2,r6,r10
8000bc64:	fc 09 16 10 	lsr	r9,lr,0x10
8000bc68:	ea 02 02 4b 	mul	r11,r5,r2
8000bc6c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc70:	16 39       	cp.w	r9,r11
8000bc72:	c0 72       	brcc	8000bc80 <__avr32_umod64+0xe4>
8000bc74:	18 09       	add	r9,r12
8000bc76:	18 39       	cp.w	r9,r12
8000bc78:	c0 43       	brcs	8000bc80 <__avr32_umod64+0xe4>
8000bc7a:	16 39       	cp.w	r9,r11
8000bc7c:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc80:	f2 0b 01 0b 	sub	r11,r9,r11
8000bc84:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bc88:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bc8c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bc90:	ea 0a 02 4a 	mul	r10,r5,r10
8000bc94:	14 3e       	cp.w	lr,r10
8000bc96:	c0 72       	brcc	8000bca4 <__avr32_umod64+0x108>
8000bc98:	18 0e       	add	lr,r12
8000bc9a:	18 3e       	cp.w	lr,r12
8000bc9c:	c0 43       	brcs	8000bca4 <__avr32_umod64+0x108>
8000bc9e:	14 3e       	cp.w	lr,r10
8000bca0:	fd dc e3 0e 	addcs	lr,lr,r12
8000bca4:	fc 0a 01 0a 	sub	r10,lr,r10
8000bca8:	30 0b       	mov	r11,0
8000bcaa:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bcae:	c7 b8       	rjmp	8000bda4 <__avr32_umod64+0x208>
8000bcb0:	16 39       	cp.w	r9,r11
8000bcb2:	e0 8b 00 79 	brhi	8000bda4 <__avr32_umod64+0x208>
8000bcb6:	f2 09 12 00 	clz	r9,r9
8000bcba:	c1 21       	brne	8000bcde <__avr32_umod64+0x142>
8000bcbc:	10 3a       	cp.w	r10,r8
8000bcbe:	5f 2b       	srhs	r11
8000bcc0:	0a 31       	cp.w	r1,r5
8000bcc2:	5f ba       	srhi	r10
8000bcc4:	f7 ea 10 0a 	or	r10,r11,r10
8000bcc8:	f2 0a 18 00 	cp.b	r10,r9
8000bccc:	c0 60       	breq	8000bcd8 <__avr32_umod64+0x13c>
8000bcce:	fc 08 01 0c 	sub	r12,lr,r8
8000bcd2:	e2 05 01 46 	sbc	r6,r1,r5
8000bcd6:	18 9e       	mov	lr,r12
8000bcd8:	0c 9b       	mov	r11,r6
8000bcda:	1c 9a       	mov	r10,lr
8000bcdc:	c6 48       	rjmp	8000bda4 <__avr32_umod64+0x208>
8000bcde:	ea 09 09 4c 	lsl	r12,r5,r9
8000bce2:	f2 06 11 20 	rsub	r6,r9,32
8000bce6:	f6 09 09 4b 	lsl	r11,r11,r9
8000bcea:	f0 09 09 42 	lsl	r2,r8,r9
8000bcee:	ef 46 ff f4 	st.w	r7[-12],r6
8000bcf2:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcf6:	18 48       	or	r8,r12
8000bcf8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bcfc:	f4 09 09 43 	lsl	r3,r10,r9
8000bd00:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bd04:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bd08:	16 4a       	or	r10,r11
8000bd0a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bd0e:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd12:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bd16:	08 91       	mov	r1,r4
8000bd18:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bd1c:	e8 0e 02 46 	mul	r6,r4,lr
8000bd20:	0c 3c       	cp.w	r12,r6
8000bd22:	c0 a2       	brcc	8000bd36 <__avr32_umod64+0x19a>
8000bd24:	20 11       	sub	r1,1
8000bd26:	10 0c       	add	r12,r8
8000bd28:	10 3c       	cp.w	r12,r8
8000bd2a:	c0 63       	brcs	8000bd36 <__avr32_umod64+0x19a>
8000bd2c:	0c 3c       	cp.w	r12,r6
8000bd2e:	f7 b1 03 01 	sublo	r1,1
8000bd32:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bd36:	0c 1c       	sub	r12,r6
8000bd38:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bd3c:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd40:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bd44:	08 96       	mov	r6,r4
8000bd46:	e8 0e 02 4e 	mul	lr,r4,lr
8000bd4a:	1c 3b       	cp.w	r11,lr
8000bd4c:	c0 a2       	brcc	8000bd60 <__avr32_umod64+0x1c4>
8000bd4e:	20 16       	sub	r6,1
8000bd50:	10 0b       	add	r11,r8
8000bd52:	10 3b       	cp.w	r11,r8
8000bd54:	c0 63       	brcs	8000bd60 <__avr32_umod64+0x1c4>
8000bd56:	1c 3b       	cp.w	r11,lr
8000bd58:	f7 b6 03 01 	sublo	r6,1
8000bd5c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bd60:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bd64:	1c 1b       	sub	r11,lr
8000bd66:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bd6a:	00 9e       	mov	lr,r0
8000bd6c:	02 9c       	mov	r12,r1
8000bd6e:	16 3c       	cp.w	r12,r11
8000bd70:	e0 8b 00 08 	brhi	8000bd80 <__avr32_umod64+0x1e4>
8000bd74:	5f 06       	sreq	r6
8000bd76:	06 30       	cp.w	r0,r3
8000bd78:	5f ba       	srhi	r10
8000bd7a:	ed ea 00 0a 	and	r10,r6,r10
8000bd7e:	c0 60       	breq	8000bd8a <__avr32_umod64+0x1ee>
8000bd80:	fc 02 01 04 	sub	r4,lr,r2
8000bd84:	f8 08 01 4c 	sbc	r12,r12,r8
8000bd88:	08 9e       	mov	lr,r4
8000bd8a:	e6 0e 01 0a 	sub	r10,r3,lr
8000bd8e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bd92:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bd96:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bd9a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bd9e:	f8 01 09 4c 	lsl	r12,r12,r1
8000bda2:	18 4a       	or	r10,r12
8000bda4:	2f dd       	sub	sp,-12
8000bda6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 6f 68 	sub	pc,pc,28520

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c6 43 	rcall	80004b8c <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c6 3c 	rcall	80004b8c <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c6 35 	rcall	80004b8c <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c6 2e 	rcall	80004b8c <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
