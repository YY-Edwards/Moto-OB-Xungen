
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aa40  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000124c  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e04c  8000e04c  0000e44c  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000e050  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00005130  00000a40  8000ea8c  0000f240  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001680  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000035f0  00000000  00000000  000108f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c2af  00000000  00000000  00013ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007272  00000000  00000000  0004018f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d382  00000000  00000000  00047401  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003ce0  00000000  00000000  00054784  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007f6d  00000000  00000000  00058464  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f267  00000000  00000000  000603d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001748  00000000  00000000  0006f638  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 c8 	sub	pc,pc,-14904

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 94       	ld.ub	r4,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 60       	and	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d c0       	mov	r0,-36
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a 68       	sub	r8,-90
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 c4       	sub	r4,124
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	69 78       	ld.w	r8,r4[0x5c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ce 08       	rjmp	8000225e <ButtonConfig_brdcst_func+0x7a>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6d 3c       	ld.w	r12,r6[0x4c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 57       	eor	r7,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ce 0c       	rcall	8000228e <ButtonConfig_brdcst_func+0xaa>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6d 3c       	ld.w	r12,r6[0x4c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 49       	or	r9,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ce 18       	rjmp	800022a8 <ButtonConfig_brdcst_func+0xc4>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6d 3c       	ld.w	r12,r6[0x4c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ce 38       	rjmp	800022c0 <ButtonConfig_reply_func>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6d 3c       	ld.w	r12,r6[0x4c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ce 54       	brge	800020d8 <FD_brdcst_func>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6d 3c       	ld.w	r12,r6[0x4c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ce 70       	breq	800020f0 <FD_reply_func+0x4>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6d 3c       	ld.w	r12,r6[0x4c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 88       	rjmp	80002352 <BatteryLevel_brdcst_func+0x4e>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6d 3c       	ld.w	r12,r6[0x4c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ce a0       	breq	8000215e <EnOB_reply_func+0x36>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ce b4       	brge	80002164 <EnOB_reply_func+0x3c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ce cc       	rcall	8000236a <ShutDown_brdcst_func+0xe>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce e8       	rjmp	80002372 <ShutDown_brdcst_func+0x16>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	cf 00       	breq	800021b2 <SingleDetection_brdcst_func+0x1a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6d 3c       	ld.w	r12,r6[0x4c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	cf 14       	brge	800021c0 <SingleDetection_brdcst_func+0x28>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	cf 24       	brge	800021c6 <SingleDetection_brdcst_func+0x2e>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	cf 38       	rjmp	80002480 <TransmitControl_brdcst_func+0x34>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6d 3c       	ld.w	r12,r6[0x4c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	cf 58       	rjmp	8000248c <TransmitControl_brdcst_func+0x40>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	cf 6c       	rcall	80002492 <TransmitControl_brdcst_func+0x46>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cf 84       	brge	8000229a <ButtonConfig_brdcst_func+0xb6>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	cf a4       	brge	800022a2 <ButtonConfig_brdcst_func+0xbe>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cf cc       	rcall	800024aa <TransmitControl_reply_func+0x16>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cf f4       	brge	800022b4 <ButtonConfig_brdcst_func+0xd0>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 40       	acall	0x4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d0 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6d 3c       	ld.w	r12,r6[0x4c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cf 58       	rjmp	800024e8 <TransmitControl_reply_func+0x54>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d0 7c       	*unknown*

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 cc       	lddpc	r12,80002344 <BatteryLevel_brdcst_func+0x40>
80002318:	f0 1f 00 0c 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 cc       	lddpc	r12,8000234c <BatteryLevel_brdcst_func+0x48>
80002320:	f0 1f 00 0a 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 ac       	lddpc	r12,80002350 <BatteryLevel_brdcst_func+0x4c>
8000232a:	f0 1f 00 08 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
8000232e:	8e 98       	ld.uh	r8,r7[0x2]
80002330:	1a d8       	st.w	--sp,r8
80002332:	48 9c       	lddpc	r12,80002354 <BatteryLevel_brdcst_func+0x50>
80002334:	f0 1f 00 05 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
80002338:	0f 89       	ld.ub	r9,r7[0x0]
8000233a:	48 88       	lddpc	r8,80002358 <BatteryLevel_brdcst_func+0x54>
8000233c:	b0 89       	st.b	r8[0x0],r9
8000233e:	2f ed       	sub	sp,-8

}
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d0 98       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	6d 3c       	ld.w	r12,r6[0x4c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d0 a8       	*unknown*
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	d0 bc       	*unknown*
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	d0 d4       	*unknown*
80002358:	00 00       	add	r0,r0
8000235a:	0a 41       	or	r1,r5

8000235c <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
8000235c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
8000235e:	19 a8       	ld.ub	r8,r12[0x2]
80002360:	30 19       	mov	r9,1
80002362:	f2 08 18 00 	cp.b	r8,r9
80002366:	c0 51       	brne	80002370 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002368:	48 6c       	lddpc	r12,80002380 <ShutDown_brdcst_func+0x24>
8000236a:	f0 1f 00 07 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000236e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002370:	30 29       	mov	r9,2
80002372:	f2 08 18 00 	cp.b	r8,r9
80002376:	c0 41       	brne	8000237e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002378:	48 4c       	lddpc	r12,80002388 <ShutDown_brdcst_func+0x2c>
8000237a:	f0 1f 00 03 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000237e:	d8 02       	popm	pc
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d0 ec       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	6d 3c       	ld.w	r12,r6[0x4c]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d1 00       	acall	0x10

8000238c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000238c:	eb cd 40 80 	pushm	r7,lr
80002390:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002392:	19 a9       	ld.ub	r9,r12[0x2]
80002394:	30 08       	mov	r8,0
80002396:	f0 09 18 00 	cp.b	r9,r8
8000239a:	c1 11       	brne	800023bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000239c:	49 3c       	lddpc	r12,800023e8 <DataSession_reply_func+0x5c>
8000239e:	f0 1f 00 14 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023a2:	0f b8       	ld.ub	r8,r7[0x3]
800023a4:	1a d8       	st.w	--sp,r8
800023a6:	49 3c       	lddpc	r12,800023f0 <DataSession_reply_func+0x64>
800023a8:	f0 1f 00 11 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023ac:	0f c8       	ld.ub	r8,r7[0x4]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 1c       	lddpc	r12,800023f4 <DataSession_reply_func+0x68>
800023b2:	f0 1f 00 0f 	mcall	800023ec <DataSession_reply_func+0x60>
800023b6:	2f ed       	sub	sp,-8
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023bc:	48 fc       	lddpc	r12,800023f8 <DataSession_reply_func+0x6c>
800023be:	f0 1f 00 0c 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023c2:	0f a8       	ld.ub	r8,r7[0x2]
800023c4:	1a d8       	st.w	--sp,r8
800023c6:	48 ec       	lddpc	r12,800023fc <DataSession_reply_func+0x70>
800023c8:	f0 1f 00 09 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023cc:	0f b8       	ld.ub	r8,r7[0x3]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x74>
800023d2:	f0 1f 00 07 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023d6:	0f c8       	ld.ub	r8,r7[0x4]
800023d8:	1a d8       	st.w	--sp,r8
800023da:	48 bc       	lddpc	r12,80002404 <DataSession_reply_func+0x78>
800023dc:	f0 1f 00 04 	mcall	800023ec <DataSession_reply_func+0x60>
800023e0:	2f dd       	sub	sp,-12
800023e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e6:	00 00       	add	r0,r0
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 10       	acall	0x11
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	6d 3c       	ld.w	r12,r6[0x4c]
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	d1 20       	acall	0x12
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d1 2c       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	d1 38       	*unknown*
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d1 48       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d1 58       	*unknown*
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d1 64       	*unknown*

80002408 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000240c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 bc       	lddpc	r12,80002440 <CallControl_brdcst_func+0x38>
80002416:	f0 1f 00 0c 	mcall	80002444 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000241a:	2f fd       	sub	sp,-4
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 38       	mov	r8,3
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002426:	30 09       	mov	r9,0
80002428:	48 88       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000242c:	0f 99       	ld.ub	r9,r7[0x1]
8000242e:	30 48       	mov	r8,4
80002430:	f0 09 18 00 	cp.b	r9,r8
80002434:	c0 41       	brne	8000243c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002436:	30 19       	mov	r9,1
80002438:	48 48       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000243a:	b0 89       	st.b	r8[0x0],r9
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	d1 70       	acall	0x17
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	6d 3c       	ld.w	r12,r6[0x4c]
80002448:	00 00       	add	r0,r0
8000244a:	0a 4b       	or	r11,r5

8000244c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000244c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002450:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 08       	mov	r8,0
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 71       	brne	8000246a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000245e:	48 ac       	lddpc	r12,80002484 <TransmitControl_brdcst_func+0x38>
80002460:	f0 1f 00 0a 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002464:	30 09       	mov	r9,0
80002466:	48 a8       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
80002468:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000246a:	0f 99       	ld.ub	r9,r7[0x1]
8000246c:	30 18       	mov	r8,1
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c0 71       	brne	80002480 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002474:	48 7c       	lddpc	r12,80002490 <TransmitControl_brdcst_func+0x44>
80002476:	f0 1f 00 05 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000247a:	30 19       	mov	r9,1
8000247c:	48 48       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
8000247e:	b0 89       	st.b	r8[0x0],r9
80002480:	e3 cd 80 80 	ldm	sp++,r7,pc
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d1 88       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	6d 3c       	ld.w	r12,r6[0x4c]
8000248c:	00 00       	add	r0,r0
8000248e:	0a 4a       	or	r10,r5
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d1 a0       	acall	0x1a

80002494 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 61       	brne	800024d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024a6:	48 ec       	lddpc	r12,800024dc <TransmitControl_reply_func+0x48>
800024a8:	f0 1f 00 0e 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024ac:	0f 98       	ld.ub	r8,r7[0x1]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	48 dc       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x50>
800024b2:	f0 1f 00 0c 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024b6:	0f a8       	ld.ub	r8,r7[0x2]
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 cc       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x54>
800024bc:	f0 1f 00 09 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024c0:	0f b8       	ld.ub	r8,r7[0x3]
800024c2:	1a d8       	st.w	--sp,r8
800024c4:	48 ac       	lddpc	r12,800024ec <TransmitControl_reply_func+0x58>
800024c6:	f0 1f 00 07 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024ca:	2f dd       	sub	sp,-12
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 8c       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x5c>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d1 b4       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6d 3c       	ld.w	r12,r6[0x4c]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d1 d0       	acall	0x1d
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d1 e4       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d2 00       	acall	0x20
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d2 10       	acall	0x21

800024f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024f6:	19 a9       	ld.ub	r9,r12[0x2]
800024f8:	30 08       	mov	r8,0
800024fa:	f0 09 18 00 	cp.b	r9,r8
800024fe:	c0 51       	brne	80002508 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002500:	48 4c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x1c>
80002502:	f0 1f 00 05 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
80002506:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002508:	48 4c       	lddpc	r12,80002518 <AudioRoutingControl_reply_func+0x24>
8000250a:	f0 1f 00 03 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
8000250e:	d8 02       	popm	pc
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	d2 28       	*unknown*
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	6d 3c       	ld.w	r12,r6[0x4c]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d2 38       	*unknown*

8000251c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 b1       	brne	80002562 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000252e:	0f b8       	ld.ub	r8,r7[0x3]
80002530:	31 09       	mov	r9,16
80002532:	f2 08 18 00 	cp.b	r8,r9
80002536:	c0 f1       	brne	80002554 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002538:	48 dc       	lddpc	r12,8000256c <Volume_reply_func+0x50>
8000253a:	f0 1f 00 0e 	mcall	80002570 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000253e:	0f 99       	ld.ub	r9,r7[0x1]
80002540:	0f a8       	ld.ub	r8,r7[0x2]
80002542:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002546:	1a d8       	st.w	--sp,r8
80002548:	48 bc       	lddpc	r12,80002574 <Volume_reply_func+0x58>
8000254a:	f0 1f 00 0a 	mcall	80002570 <Volume_reply_func+0x54>
8000254e:	2f fd       	sub	sp,-4
80002550:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 9c       	lddpc	r12,80002578 <Volume_reply_func+0x5c>
80002558:	f0 1f 00 06 	mcall	80002570 <Volume_reply_func+0x54>
8000255c:	2f fd       	sub	sp,-4
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002562:	48 7c       	lddpc	r12,8000257c <Volume_reply_func+0x60>
80002564:	f0 1f 00 03 	mcall	80002570 <Volume_reply_func+0x54>
80002568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d2 4c       	*unknown*
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	6d 3c       	ld.w	r12,r6[0x4c]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d2 60       	acall	0x26
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d2 7c       	*unknown*
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d2 94       	*unknown*

80002580 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002582:	19 d9       	ld.ub	r9,r12[0x5]
80002584:	30 08       	mov	r8,0
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 81       	brne	8000259a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000258c:	10 99       	mov	r9,r8
8000258e:	48 78       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
80002590:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002592:	48 7c       	lddpc	r12,800025ac <spk_brdcst_func+0x2c>
80002594:	f0 1f 00 07 	mcall	800025b0 <spk_brdcst_func+0x30>
80002598:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000259a:	30 19       	mov	r9,1
8000259c:	48 38       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
8000259e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025a0:	48 5c       	lddpc	r12,800025b4 <spk_brdcst_func+0x34>
800025a2:	f0 1f 00 04 	mcall	800025b0 <spk_brdcst_func+0x30>
800025a6:	d8 02       	popm	pc
800025a8:	00 00       	add	r0,r0
800025aa:	0a 40       	or	r0,r5
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d2 ac       	*unknown*
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	6d 3c       	ld.w	r12,r6[0x4c]
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d2 bc       	*unknown*

800025b8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ba:	19 a9       	ld.ub	r9,r12[0x2]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 f1       	brne	800025e0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025c4:	19 e9       	ld.ub	r9,r12[0x6]
800025c6:	f0 09 18 00 	cp.b	r9,r8
800025ca:	c0 40       	breq	800025d2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025cc:	30 19       	mov	r9,1
800025ce:	48 98       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025d0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025d2:	19 e8       	ld.ub	r8,r12[0x6]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	48 8c       	lddpc	r12,800025f4 <spk_reply_func+0x3c>
800025d8:	f0 1f 00 08 	mcall	800025f8 <spk_reply_func+0x40>
800025dc:	2f fd       	sub	sp,-4
800025de:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025e0:	30 09       	mov	r9,0
800025e2:	48 48       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025e4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025e6:	48 6c       	lddpc	r12,800025fc <spk_reply_func+0x44>
800025e8:	f0 1f 00 04 	mcall	800025f8 <spk_reply_func+0x40>
800025ec:	d8 02       	popm	pc
800025ee:	00 00       	add	r0,r0
800025f0:	00 00       	add	r0,r0
800025f2:	0a 40       	or	r0,r5
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d2 c8       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	6d 3c       	ld.w	r12,r6[0x4c]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d2 d8       	*unknown*

80002600 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002600:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002604:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002608:	0f a9       	ld.ub	r9,r7[0x2]
8000260a:	30 08       	mov	r8,0
8000260c:	f0 09 18 00 	cp.b	r9,r8
80002610:	c0 71       	brne	8000261e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002612:	48 dc       	lddpc	r12,80002644 <mic_brdcst_func+0x44>
80002614:	f0 1f 00 0d 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 d8       	lddpc	r8,8000264c <mic_brdcst_func+0x4c>
8000261c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000261e:	0f a9       	ld.ub	r9,r7[0x2]
80002620:	31 18       	mov	r8,17
80002622:	f0 09 18 00 	cp.b	r9,r8
80002626:	c0 d1       	brne	80002640 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002628:	48 ac       	lddpc	r12,80002650 <mic_brdcst_func+0x50>
8000262a:	f0 1f 00 08 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000262e:	48 89       	lddpc	r9,8000264c <mic_brdcst_func+0x4c>
80002630:	30 18       	mov	r8,1
80002632:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002634:	13 89       	ld.ub	r9,r9[0x0]
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 31       	brne	80002640 <mic_brdcst_func+0x40>
8000263c:	48 68       	lddpc	r8,80002654 <mic_brdcst_func+0x54>
8000263e:	11 88       	ld.ub	r8,r8[0x0]
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d2 e4       	*unknown*
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	6d 3c       	ld.w	r12,r6[0x4c]
8000264c:	00 00       	add	r0,r0
8000264e:	0a 56       	eor	r6,r5
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d2 f8       	*unknown*
80002654:	00 00       	add	r0,r0
80002656:	0a 4b       	or	r11,r5

80002658 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002658:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000265c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002660:	49 ac       	lddpc	r12,800026c8 <mic_reply_func+0x70>
80002662:	f0 1f 00 1b 	mcall	800026cc <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002666:	0f 89       	ld.ub	r9,r7[0x0]
80002668:	30 08       	mov	r8,0
8000266a:	f0 09 18 00 	cp.b	r9,r8
8000266e:	c2 71       	brne	800026bc <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002670:	0f 98       	ld.ub	r8,r7[0x1]
80002672:	30 29       	mov	r9,2
80002674:	f2 08 18 00 	cp.b	r8,r9
80002678:	c1 b1       	brne	800026ae <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000267a:	49 6c       	lddpc	r12,800026d0 <mic_reply_func+0x78>
8000267c:	f0 1f 00 14 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002680:	0f a8       	ld.ub	r8,r7[0x2]
80002682:	1a d8       	st.w	--sp,r8
80002684:	49 4c       	lddpc	r12,800026d4 <mic_reply_func+0x7c>
80002686:	f0 1f 00 12 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000268a:	0f b8       	ld.ub	r8,r7[0x3]
8000268c:	1a d8       	st.w	--sp,r8
8000268e:	49 3c       	lddpc	r12,800026d8 <mic_reply_func+0x80>
80002690:	f0 1f 00 0f 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002694:	0f c8       	ld.ub	r8,r7[0x4]
80002696:	1a d8       	st.w	--sp,r8
80002698:	49 1c       	lddpc	r12,800026dc <mic_reply_func+0x84>
8000269a:	f0 1f 00 0d 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000269e:	0f d8       	ld.ub	r8,r7[0x5]
800026a0:	1a d8       	st.w	--sp,r8
800026a2:	49 0c       	lddpc	r12,800026e0 <mic_reply_func+0x88>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_reply_func+0x74>
800026a8:	2f cd       	sub	sp,-16
800026aa:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ae:	1a d8       	st.w	--sp,r8
800026b0:	48 dc       	lddpc	r12,800026e4 <mic_reply_func+0x8c>
800026b2:	f0 1f 00 07 	mcall	800026cc <mic_reply_func+0x74>
800026b6:	2f fd       	sub	sp,-4
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026bc:	48 bc       	lddpc	r12,800026e8 <mic_reply_func+0x90>
800026be:	f0 1f 00 04 	mcall	800026cc <mic_reply_func+0x74>
800026c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c6:	00 00       	add	r0,r0
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 0c       	*unknown*
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	6d 3c       	ld.w	r12,r6[0x4c]
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d3 1c       	*unknown*
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d3 30       	acall	0x33
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d3 44       	*unknown*
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d3 60       	acall	0x36
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d3 78       	*unknown*
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	d3 90       	acall	0x39
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	d3 a8       	*unknown*

800026ec <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f4:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x34>
800026f6:	f0 1f 00 0c 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026fa:	0f 88       	ld.ub	r8,r7[0x0]
800026fc:	1a d8       	st.w	--sp,r8
800026fe:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x3c>
80002700:	f0 1f 00 09 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	48 9c       	lddpc	r12,8000272c <dcm_brdcst_func+0x40>
8000270a:	f0 1f 00 07 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000270e:	0f 98       	ld.ub	r8,r7[0x1]
80002710:	1a d8       	st.w	--sp,r8
80002712:	48 8c       	lddpc	r12,80002730 <dcm_brdcst_func+0x44>
80002714:	f0 1f 00 04 	mcall	80002724 <dcm_brdcst_func+0x38>
80002718:	2f dd       	sub	sp,-12
	
	
}
8000271a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271e:	00 00       	add	r0,r0
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d3 b8       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	6d 3c       	ld.w	r12,r6[0x4c]
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d3 cc       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	d3 e0       	acall	0x3e
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d3 f8       	*unknown*

80002734 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002734:	eb cd 40 80 	pushm	r7,lr
80002738:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000273a:	19 a9       	ld.ub	r9,r12[0x2]
8000273c:	30 08       	mov	r8,0
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c1 b1       	brne	80002778 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002744:	19 b8       	ld.ub	r8,r12[0x3]
80002746:	30 19       	mov	r9,1
80002748:	f2 08 18 00 	cp.b	r8,r9
8000274c:	c0 51       	brne	80002756 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000274e:	48 ec       	lddpc	r12,80002784 <dcm_reply_func+0x50>
80002750:	f0 1f 00 0e 	mcall	80002788 <dcm_reply_func+0x54>
80002754:	c0 a8       	rjmp	80002768 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002756:	58 08       	cp.w	r8,0
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000275a:	48 dc       	lddpc	r12,8000278c <dcm_reply_func+0x58>
8000275c:	f0 1f 00 0b 	mcall	80002788 <dcm_reply_func+0x54>
80002760:	c0 48       	rjmp	80002768 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002762:	48 cc       	lddpc	r12,80002790 <dcm_reply_func+0x5c>
80002764:	f0 1f 00 09 	mcall	80002788 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002768:	0f d8       	ld.ub	r8,r7[0x5]
8000276a:	1a d8       	st.w	--sp,r8
8000276c:	48 ac       	lddpc	r12,80002794 <dcm_reply_func+0x60>
8000276e:	f0 1f 00 07 	mcall	80002788 <dcm_reply_func+0x54>
80002772:	2f fd       	sub	sp,-4
80002774:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002778:	48 8c       	lddpc	r12,80002798 <dcm_reply_func+0x64>
8000277a:	f0 1f 00 04 	mcall	80002788 <dcm_reply_func+0x54>
8000277e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002782:	00 00       	add	r0,r0
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d4 14       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	6d 3c       	ld.w	r12,r6[0x4c]
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d4 28       	*unknown*
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d4 3c       	*unknown*
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d4 50       	acall	0x45
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d4 5c       	*unknown*

8000279c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000279e:	19 a9       	ld.ub	r9,r12[0x2]
800027a0:	30 08       	mov	r8,0
800027a2:	f0 09 18 00 	cp.b	r9,r8
800027a6:	c0 51       	brne	800027b0 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x1c>
800027aa:	f0 1f 00 05 	mcall	800027bc <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x24>
800027b2:	f0 1f 00 03 	mcall	800027bc <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d4 68       	*unknown*
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	6d 3c       	ld.w	r12,r6[0x4c]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	d4 74       	*unknown*

800027c4 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027c4:	d4 31       	pushm	r0-r7,lr
800027c6:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c8:	31 ac       	mov	r12,26
800027ca:	f0 1f 00 29 	mcall	8000286c <app_cfg+0xa8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 29 	mcall	80002870 <app_cfg+0xac>
800027d2:	4a 98       	lddpc	r8,80002874 <app_cfg+0xb0>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
800027d6:	4a 97       	lddpc	r7,80002878 <app_cfg+0xb4>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027d8:	4a 96       	lddpc	r6,8000287c <app_cfg+0xb8>
				else
				{
					nop();
					nop();
					nop();
					log("connecting...\n");
800027da:	4a a5       	lddpc	r5,80002880 <app_cfg+0xbc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027dc:	4a a4       	lddpc	r4,80002884 <app_cfg+0xc0>
				{
					connect_flag=1;
800027de:	30 13       	mov	r3,1
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027e0:	30 c2       	mov	r2,12
800027e2:	30 11       	mov	r1,1
					OB_State = OB_WAITINGAPPTASK;
800027e4:	30 30       	mov	r0,3
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	58 08       	cp.w	r8,0
800027ea:	c0 40       	breq	800027f2 <app_cfg+0x2e>
800027ec:	58 38       	cp.w	r8,3
800027ee:	c3 91       	brne	80002860 <app_cfg+0x9c>
800027f0:	c1 a8       	rjmp	80002824 <app_cfg+0x60>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	6c 08       	ld.w	r8,r6[0x0]
800027f4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f8:	58 38       	cp.w	r8,3
800027fa:	c0 e1       	brne	80002816 <app_cfg+0x52>
800027fc:	09 88       	ld.ub	r8,r4[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c0 b1       	brne	80002816 <app_cfg+0x52>
				{
					connect_flag=1;
80002802:	a8 83       	st.b	r4[0x0],r3
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	04 9b       	mov	r11,r2
80002806:	02 9c       	mov	r12,r1
80002808:	f0 1f 00 20 	mcall	80002888 <app_cfg+0xc4>
					OB_State = OB_WAITINGAPPTASK;
8000280c:	8f 00       	st.w	r7[0x0],r0
					log("connect OB okay!\n");
8000280e:	4a 0c       	lddpc	r12,8000288c <app_cfg+0xc8>
80002810:	f0 1f 00 20 	mcall	80002890 <app_cfg+0xcc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002814:	c2 68       	rjmp	80002860 <app_cfg+0x9c>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002816:	d7 03       	nop
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					log("connecting...\n");
8000281c:	0a 9c       	mov	r12,r5
8000281e:	f0 1f 00 1d 	mcall	80002890 <app_cfg+0xcc>
80002822:	c1 f8       	rjmp	80002860 <app_cfg+0x9c>
				}
								
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002824:	49 c8       	lddpc	r8,80002894 <app_cfg+0xd0>
80002826:	70 0c       	ld.w	r12,r8[0x0]
80002828:	30 09       	mov	r9,0
8000282a:	e0 6a 0f a0 	mov	r10,4000
8000282e:	1a 9b       	mov	r11,sp
80002830:	f0 1f 00 1a 	mcall	80002898 <app_cfg+0xd4>
80002834:	58 1c       	cp.w	r12,1
80002836:	c1 11       	brne	80002858 <app_cfg+0x94>
					{
						if(data_ptr!=NULL){//resend message
80002838:	40 08       	lddsp	r8,sp[0x0]
8000283a:	58 08       	cp.w	r8,0
8000283c:	c0 e0       	breq	80002858 <app_cfg+0x94>
							
							log("receive Okay!\n");						
8000283e:	49 8c       	lddpc	r12,8000289c <app_cfg+0xd8>
80002840:	f0 1f 00 14 	mcall	80002890 <app_cfg+0xcc>
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
80002844:	36 1a       	mov	r10,97
80002846:	31 ab       	mov	r11,26
80002848:	40 0c       	lddsp	r12,sp[0x0]
8000284a:	f0 1f 00 16 	mcall	800028a0 <app_cfg+0xdc>
							set_message_store(data_ptr);
8000284e:	49 68       	lddpc	r8,800028a4 <app_cfg+0xe0>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	40 0b       	lddsp	r11,sp[0x0]
80002854:	f0 1f 00 15 	mcall	800028a8 <app_cfg+0xe4>
							
						}
						
					}
										
					nop();
80002858:	d7 03       	nop
					log("app task run!\n");
8000285a:	49 5c       	lddpc	r12,800028ac <app_cfg+0xe8>
8000285c:	f0 1f 00 0d 	mcall	80002890 <app_cfg+0xcc>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002860:	e0 6b 0f a0 	mov	r11,4000
80002864:	48 4c       	lddpc	r12,80002874 <app_cfg+0xb0>
80002866:	f0 1f 00 13 	mcall	800028b0 <app_cfg+0xec>
	}
8000286a:	cb eb       	rjmp	800027e6 <app_cfg+0x22>
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	5e 08       	reteq	r8
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	66 68       	ld.w	r8,r3[0x18]
80002874:	00 00       	add	r0,r0
80002876:	0a 44       	or	r4,r5
80002878:	00 00       	add	r0,r0
8000287a:	0a 58       	eor	r8,r5
8000287c:	00 00       	add	r0,r0
8000287e:	0d 94       	ld.ub	r4,r6[0x1]
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	d4 94       	*unknown*
80002884:	00 00       	add	r0,r0
80002886:	0a 55       	eor	r5,r5
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	3f 4c       	mov	r12,-12
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d4 80       	acall	0x48
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	6d 3c       	ld.w	r12,r6[0x4c]
80002894:	00 00       	add	r0,r0
80002896:	0b 6c       	ld.uh	r12,--r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	5f 50       	srlt	r0
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d4 a4       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	3e 14       	mov	r4,-31
800028a4:	00 00       	add	r0,r0
800028a6:	0b 70       	ld.ub	r0,--r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2a e8       	sub	r8,-82
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	d4 b4       	*unknown*
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	68 18       	ld.w	r8,r4[0x4]

800028b4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800028b4:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800028b8:	19 c7       	ld.ub	r7,r12[0x4]
800028ba:	19 d8       	ld.ub	r8,r12[0x5]
800028bc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800028c0:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800028c2:	48 dc       	lddpc	r12,800028f4 <Phyuserinput_brdcst_func+0x40>
800028c4:	f0 1f 00 0d 	mcall	800028f8 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800028c8:	36 08       	mov	r8,96
800028ca:	f0 07 19 00 	cp.h	r7,r8
800028ce:	c1 11       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
800028d0:	48 b8       	lddpc	r8,800028fc <Phyuserinput_brdcst_func+0x48>
800028d2:	11 89       	ld.ub	r9,r8[0x0]
800028d4:	30 18       	mov	r8,1
800028d6:	f0 09 18 00 	cp.b	r9,r8
800028da:	c0 b1       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028dc:	31 4b       	mov	r11,20
800028de:	30 1c       	mov	r12,1
800028e0:	f0 1f 00 08 	mcall	80002900 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
800028e4:	e0 6c 01 90 	mov	r12,400
800028e8:	f0 1f 00 07 	mcall	80002904 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028ec:	f0 1f 00 07 	mcall	80002908 <Phyuserinput_brdcst_func+0x54>
800028f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d4 c4       	*unknown*
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	6d 3c       	ld.w	r12,r6[0x4c]
800028fc:	00 00       	add	r0,r0
800028fe:	0a 55       	eor	r5,r5
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	3f 4c       	mov	r12,-12
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	67 d0       	ld.w	r0,r3[0x74]
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	4f b0       	lddpc	r0,80002af4 <set_idle_store+0xc>

8000290c <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000290c:	d4 21       	pushm	r4-r7,lr
8000290e:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002910:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002914:	0d 88       	ld.ub	r8,r6[0x0]
80002916:	32 49       	mov	r9,36
80002918:	f2 08 18 00 	cp.b	r8,r9
8000291c:	c2 91       	brne	8000296e <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000291e:	4b 0c       	lddpc	r12,800029dc <DataSession_brdcst_func+0xd0>
80002920:	f0 1f 00 30 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002924:	0d a5       	ld.ub	r5,r6[0x2]
80002926:	0d b8       	ld.ub	r8,r6[0x3]
80002928:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000292c:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000292e:	0d 98       	ld.ub	r8,r6[0x1]
80002930:	1a d8       	st.w	--sp,r8
80002932:	4a dc       	lddpc	r12,800029e4 <DataSession_brdcst_func+0xd8>
80002934:	f0 1f 00 2b 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002938:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	4a bc       	lddpc	r12,800029e8 <DataSession_brdcst_func+0xdc>
80002940:	f0 1f 00 28 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
		for(i=0; i<data_length; i++)
80002944:	2f ed       	sub	sp,-8
80002946:	58 05       	cp.w	r5,0
80002948:	c4 70       	breq	800029d6 <DataSession_brdcst_func+0xca>
8000294a:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000294c:	4a 84       	lddpc	r4,800029ec <DataSession_brdcst_func+0xe0>
8000294e:	ec 07 00 08 	add	r8,r6,r7
80002952:	11 c8       	ld.ub	r8,r8[0x4]
80002954:	1a d8       	st.w	--sp,r8
80002956:	1a d7       	st.w	--sp,r7
80002958:	08 9c       	mov	r12,r4
8000295a:	f0 1f 00 22 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000295e:	2f f7       	sub	r7,-1
80002960:	5c 57       	castu.b	r7
80002962:	2f ed       	sub	sp,-8
80002964:	ee 05 19 00 	cp.h	r5,r7
80002968:	fe 9b ff f3 	brhi	8000294e <DataSession_brdcst_func+0x42>
8000296c:	c3 58       	rjmp	800029d6 <DataSession_brdcst_func+0xca>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000296e:	1a d8       	st.w	--sp,r8
80002970:	4a 0c       	lddpc	r12,800029f0 <DataSession_brdcst_func+0xe4>
80002972:	f0 1f 00 1c 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002976:	0d 88       	ld.ub	r8,r6[0x0]
80002978:	2f fd       	sub	sp,-4
8000297a:	30 39       	mov	r9,3
8000297c:	f2 08 18 00 	cp.b	r8,r9
80002980:	c0 51       	brne	8000298a <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002982:	49 dc       	lddpc	r12,800029f4 <DataSession_brdcst_func+0xe8>
80002984:	f0 1f 00 17 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
80002988:	c2 38       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000298a:	30 49       	mov	r9,4
8000298c:	f2 08 18 00 	cp.b	r8,r9
80002990:	c1 f1       	brne	800029ce <DataSession_brdcst_func+0xc2>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002992:	31 aa       	mov	r10,26
80002994:	ec cb ff fc 	sub	r11,r6,-4
80002998:	fa cc ff fe 	sub	r12,sp,-2
8000299c:	f0 1f 00 17 	mcall	800029f8 <DataSession_brdcst_func+0xec>

			Message_Protocol_t * myptr = get_message_store();	
800029a0:	49 78       	lddpc	r8,800029fc <DataSession_brdcst_func+0xf0>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 17 	mcall	80002a00 <DataSession_brdcst_func+0xf4>
800029a8:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
800029aa:	c0 f0       	breq	800029c8 <DataSession_brdcst_func+0xbc>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800029ac:	31 aa       	mov	r10,26
800029ae:	fa cb ff fe 	sub	r11,sp,-2
800029b2:	f0 1f 00 12 	mcall	800029f8 <DataSession_brdcst_func+0xec>
				xQueueSend(xg_resend_queue, &myptr, 0);
800029b6:	49 48       	lddpc	r8,80002a04 <DataSession_brdcst_func+0xf8>
800029b8:	70 0c       	ld.w	r12,r8[0x0]
800029ba:	30 09       	mov	r9,0
800029bc:	12 9a       	mov	r10,r9
800029be:	fa cb ff e4 	sub	r11,sp,-28
800029c2:	f0 1f 00 12 	mcall	80002a08 <DataSession_brdcst_func+0xfc>
800029c6:	c0 48       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
			}
			else
			{
				log("myptr: err\n\r" );
800029c8:	49 1c       	lddpc	r12,80002a0c <DataSession_brdcst_func+0x100>
800029ca:	f0 1f 00 06 	mcall	800029e0 <DataSession_brdcst_func+0xd4>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		
		xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800029ce:	30 cb       	mov	r11,12
800029d0:	30 1c       	mov	r12,1
800029d2:	f0 1f 00 10 	mcall	80002a10 <DataSession_brdcst_func+0x104>
				//
		//}
		
	}
	
}
800029d6:	2f 8d       	sub	sp,-32
800029d8:	d8 22       	popm	r4-r7,pc
800029da:	00 00       	add	r0,r0
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	d4 e4       	*unknown*
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	6d 3c       	ld.w	r12,r6[0x4c]
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	d4 f8       	*unknown*
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	d5 10       	acall	0x51
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	d5 2c       	*unknown*
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	d5 44       	*unknown*
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	d5 50       	acall	0x55
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	75 b8       	ld.w	r8,r10[0x6c]
800029fc:	00 00       	add	r0,r0
800029fe:	0b 70       	ld.ub	r0,--r5
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	2c 94       	sub	r4,-55
80002a04:	00 00       	add	r0,r0
80002a06:	0b 6c       	ld.uh	r12,--r5
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	61 5c       	ld.w	r12,r0[0x54]
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	d5 68       	*unknown*
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	3f 4c       	mov	r12,-12

80002a14 <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a14:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a16:	19 e8       	ld.ub	r8,r12[0x6]
80002a18:	30 19       	mov	r9,1
80002a1a:	f2 08 18 00 	cp.b	r8,r9
80002a1e:	c0 61       	brne	80002a2a <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a20:	48 98       	lddpc	r8,80002a44 <DeviceInitializationStatus_brdcst_func+0x30>
80002a22:	70 09       	ld.w	r9,r8[0x0]
80002a24:	a1 a9       	sbr	r9,0x0
80002a26:	91 09       	st.w	r8[0x0],r9
80002a28:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a2a:	30 29       	mov	r9,2
80002a2c:	f2 08 18 00 	cp.b	r8,r9
80002a30:	c0 80       	breq	80002a40 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a32:	48 58       	lddpc	r8,80002a44 <DeviceInitializationStatus_brdcst_func+0x30>
80002a34:	70 09       	ld.w	r9,r8[0x0]
80002a36:	e0 19 ff fc 	andl	r9,0xfffc
80002a3a:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a3c:	f0 1f 00 03 	mcall	80002a48 <DeviceInitializationStatus_brdcst_func+0x34>
80002a40:	d8 02       	popm	pc
80002a42:	00 00       	add	r0,r0
80002a44:	00 00       	add	r0,r0
80002a46:	0d 94       	ld.ub	r4,r6[0x1]
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	3e a0       	mov	r0,-22

80002a4c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a4c:	20 1c       	sub	r12,1
80002a4e:	5c 5c       	castu.b	r12
80002a50:	31 18       	mov	r8,17
80002a52:	f0 0c 18 00 	cp.b	r12,r8
80002a56:	e0 88 00 03 	brls	80002a5c <CalculateBurst+0x10>
80002a5a:	5e fd       	retal	0
80002a5c:	48 28       	lddpc	r8,80002a64 <CalculateBurst+0x18>
80002a5e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a62:	5e fc       	retal	r12
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	d5 78       	*unknown*

80002a68 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a68:	48 38       	lddpc	r8,80002a74 <payload_init+0xc>
80002a6a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a6c:	48 38       	lddpc	r8,80002a78 <payload_init+0x10>
80002a6e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a70:	5e fc       	retal	r12
80002a72:	00 00       	add	r0,r0
80002a74:	00 00       	add	r0,r0
80002a76:	0a 64       	and	r4,r5
80002a78:	00 00       	add	r0,r0
80002a7a:	0a 68       	and	r8,r5

80002a7c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a7c:	d4 01       	pushm	lr
80002a7e:	20 2d       	sub	sp,8
80002a80:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a82:	30 09       	mov	r9,0
80002a84:	fa ca ff f8 	sub	r10,sp,-8
80002a88:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a8a:	1a 9b       	mov	r11,sp
80002a8c:	f0 1f 00 02 	mcall	80002a94 <set_idle_store_isr+0x18>
}
80002a90:	2f ed       	sub	sp,-8
80002a92:	d8 02       	popm	pc
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	61 0c       	ld.w	r12,r0[0x40]

80002a98 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a98:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a9a:	48 48       	lddpc	r8,80002aa8 <payload_rx+0x10>
80002a9c:	70 08       	ld.w	r8,r8[0x0]
80002a9e:	18 9b       	mov	r11,r12
80002aa0:	10 9c       	mov	r12,r8
80002aa2:	f0 1f 00 03 	mcall	80002aac <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002aa6:	d8 02       	popm	pc
80002aa8:	00 00       	add	r0,r0
80002aaa:	0a a0       	st.w	r5++,r0
80002aac:	80 00       	ld.sh	r0,r0[0x0]
80002aae:	2a 7c       	sub	r12,-89

80002ab0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002ab0:	d4 01       	pushm	lr
80002ab2:	20 2d       	sub	sp,8
80002ab4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002ab6:	58 0c       	cp.w	r12,0
80002ab8:	c1 10       	breq	80002ada <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aba:	30 08       	mov	r8,0
80002abc:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002abe:	98 88       	ld.uh	r8,r12[0x0]
80002ac0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ac4:	e0 48 40 00 	cp.w	r8,16384
80002ac8:	c0 91       	brne	80002ada <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002aca:	48 68       	lddpc	r8,80002ae0 <phy_rx+0x30>
80002acc:	70 0c       	ld.w	r12,r8[0x0]
80002ace:	30 09       	mov	r9,0
80002ad0:	fa ca ff fc 	sub	r10,sp,-4
80002ad4:	1a 9b       	mov	r11,sp
80002ad6:	f0 1f 00 04 	mcall	80002ae4 <phy_rx+0x34>
		}	

    }
		
 
}
80002ada:	2f ed       	sub	sp,-8
80002adc:	d8 02       	popm	pc
80002ade:	00 00       	add	r0,r0
80002ae0:	00 00       	add	r0,r0
80002ae2:	0a ac       	st.w	r5++,r12
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	61 0c       	ld.w	r12,r0[0x40]

80002ae8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ae8:	eb cd 40 80 	pushm	r7,lr
80002aec:	20 1d       	sub	sp,4
80002aee:	fa c7 ff fc 	sub	r7,sp,-4
80002af2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002af4:	30 09       	mov	r9,0
80002af6:	12 9a       	mov	r10,r9
80002af8:	1a 9b       	mov	r11,sp
80002afa:	f0 1f 00 03 	mcall	80002b04 <set_idle_store+0x1c>
}
80002afe:	2f fd       	sub	sp,-4
80002b00:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	61 5c       	ld.w	r12,r0[0x54]

80002b08 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b08:	d4 01       	pushm	lr
80002b0a:	20 1d       	sub	sp,4
80002b0c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b0e:	98 88       	ld.uh	r8,r12[0x0]
80002b10:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b14:	e0 48 40 00 	cp.w	r8,16384
80002b18:	c0 d1       	brne	80002b32 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b1a:	49 08       	lddpc	r8,80002b58 <phy_tx+0x50>
80002b1c:	70 08       	ld.w	r8,r8[0x0]
80002b1e:	58 08       	cp.w	r8,0
80002b20:	c1 a0       	breq	80002b54 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b22:	48 e8       	lddpc	r8,80002b58 <phy_tx+0x50>
80002b24:	70 0c       	ld.w	r12,r8[0x0]
80002b26:	30 09       	mov	r9,0
80002b28:	12 9a       	mov	r10,r9
80002b2a:	1a 9b       	mov	r11,sp
80002b2c:	f0 1f 00 0c 	mcall	80002b5c <phy_tx+0x54>
80002b30:	c1 28       	rjmp	80002b54 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b32:	e0 48 10 00 	cp.w	r8,4096
80002b36:	5f 0a       	sreq	r10
80002b38:	e0 48 20 00 	cp.w	r8,8192
80002b3c:	5f 09       	sreq	r9
80002b3e:	f5 e9 10 09 	or	r9,r10,r9
80002b42:	c0 71       	brne	80002b50 <phy_tx+0x48>
80002b44:	e0 48 50 00 	cp.w	r8,20480
80002b48:	c0 40       	breq	80002b50 <phy_tx+0x48>
80002b4a:	e0 48 60 00 	cp.w	r8,24576
80002b4e:	c0 31       	brne	80002b54 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b50:	48 48       	lddpc	r8,80002b60 <phy_tx+0x58>
80002b52:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b54:	2f fd       	sub	sp,-4
80002b56:	d8 02       	popm	pc
80002b58:	00 00       	add	r0,r0
80002b5a:	0a cc       	st.b	r5++,r12
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	61 5c       	ld.w	r12,r0[0x54]
80002b60:	00 00       	add	r0,r0
80002b62:	0a c0       	st.b	r5++,r0

80002b64 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b64:	d4 01       	pushm	lr
80002b66:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b68:	30 08       	mov	r8,0
80002b6a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b6c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b6e:	1a 9a       	mov	r10,sp
80002b70:	fa cb ff fc 	sub	r11,sp,-4
80002b74:	f0 1f 00 05 	mcall	80002b88 <get_idle_store_isr+0x24>
80002b78:	58 1c       	cp.w	r12,1
80002b7a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b7e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b82:	2f ed       	sub	sp,-8
80002b84:	d8 02       	popm	pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	5e 60       	retmi	r0

80002b8c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002b90:	20 1d       	sub	sp,4
80002b92:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b94:	4b a8       	lddpc	r8,80002c7c <phy_tx_func+0xf0>
80002b96:	70 08       	ld.w	r8,r8[0x0]
80002b98:	58 08       	cp.w	r8,0
80002b9a:	c6 60       	breq	80002c66 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b9c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b9e:	30 08       	mov	r8,0
80002ba0:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002ba2:	4b 88       	lddpc	r8,80002c80 <phy_tx_func+0xf4>
80002ba4:	70 08       	ld.w	r8,r8[0x0]
80002ba6:	58 18       	cp.w	r8,1
80002ba8:	c2 60       	breq	80002bf4 <phy_tx_func+0x68>
80002baa:	c0 43       	brcs	80002bb2 <phy_tx_func+0x26>
80002bac:	58 28       	cp.w	r8,2
80002bae:	c5 c1       	brne	80002c66 <phy_tx_func+0xda>
80002bb0:	c5 58       	rjmp	80002c5a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002bb2:	4b 38       	lddpc	r8,80002c7c <phy_tx_func+0xf0>
80002bb4:	70 0c       	ld.w	r12,r8[0x0]
80002bb6:	1a 9a       	mov	r10,sp
80002bb8:	4b 3b       	lddpc	r11,80002c84 <phy_tx_func+0xf8>
80002bba:	f0 1f 00 34 	mcall	80002c88 <phy_tx_func+0xfc>
80002bbe:	58 1c       	cp.w	r12,1
80002bc0:	c1 41       	brne	80002be8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bc2:	4b 18       	lddpc	r8,80002c84 <phy_tx_func+0xf8>
80002bc4:	70 08       	ld.w	r8,r8[0x0]
80002bc6:	90 08       	ld.sh	r8,r8[0x0]
80002bc8:	10 9a       	mov	r10,r8
80002bca:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002bce:	4b 09       	lddpc	r9,80002c8c <phy_tx_func+0x100>
80002bd0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bd2:	5c 78       	castu.h	r8
80002bd4:	ea 18 ab cd 	orh	r8,0xabcd
80002bd8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bda:	30 19       	mov	r9,1
80002bdc:	4a d8       	lddpc	r8,80002c90 <phy_tx_func+0x104>
80002bde:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002be0:	30 19       	mov	r9,1
80002be2:	4a 88       	lddpc	r8,80002c80 <phy_tx_func+0xf4>
80002be4:	91 09       	st.w	r8[0x0],r9
80002be6:	c4 08       	rjmp	80002c66 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002be8:	e0 68 5a 5a 	mov	r8,23130
80002bec:	ea 18 ab cd 	orh	r8,0xabcd
80002bf0:	8f 18       	st.w	r7[0x4],r8
80002bf2:	c3 a8       	rjmp	80002c66 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002bf4:	4a 7a       	lddpc	r10,80002c90 <phy_tx_func+0x104>
80002bf6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002bf8:	4a 39       	lddpc	r9,80002c84 <phy_tx_func+0xf8>
80002bfa:	72 09       	ld.w	r9,r9[0x0]
80002bfc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002c00:	b1 69       	lsl	r9,0x10
80002c02:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c04:	2f f8       	sub	r8,-1
80002c06:	5c 58       	castu.b	r8
80002c08:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002c0a:	4a 1b       	lddpc	r11,80002c8c <phy_tx_func+0x100>
80002c0c:	96 0c       	ld.sh	r12,r11[0x0]
80002c0e:	20 2c       	sub	r12,2
80002c10:	5c 8c       	casts.h	r12
80002c12:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c16:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c18:	30 0b       	mov	r11,0
80002c1a:	f6 0a 19 00 	cp.h	r10,r11
80002c1e:	e0 89 00 09 	brgt	80002c30 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c22:	e8 19 00 ba 	orl	r9,0xba
80002c26:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c28:	30 09       	mov	r9,0
80002c2a:	49 68       	lddpc	r8,80002c80 <phy_tx_func+0xf4>
80002c2c:	91 09       	st.w	r8[0x0],r9
80002c2e:	c1 c8       	rjmp	80002c66 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c30:	49 5a       	lddpc	r10,80002c84 <phy_tx_func+0xf8>
80002c32:	74 0a       	ld.w	r10,r10[0x0]
80002c34:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c38:	14 49       	or	r9,r10
80002c3a:	8f 19       	st.w	r7[0x4],r9
80002c3c:	2f f8       	sub	r8,-1
80002c3e:	49 59       	lddpc	r9,80002c90 <phy_tx_func+0x104>
80002c40:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c42:	20 2c       	sub	r12,2
80002c44:	49 28       	lddpc	r8,80002c8c <phy_tx_func+0x100>
80002c46:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c48:	30 08       	mov	r8,0
80002c4a:	f0 0c 19 00 	cp.h	r12,r8
80002c4e:	e0 89 00 0c 	brgt	80002c66 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c52:	30 29       	mov	r9,2
80002c54:	48 b8       	lddpc	r8,80002c80 <phy_tx_func+0xf4>
80002c56:	91 09       	st.w	r8[0x0],r9
80002c58:	c0 78       	rjmp	80002c66 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c5a:	fc 18 00 ba 	movh	r8,0xba
80002c5e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c60:	30 09       	mov	r9,0
80002c62:	48 88       	lddpc	r8,80002c80 <phy_tx_func+0xf4>
80002c64:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002c66:	e0 68 5a 5a 	mov	r8,23130
80002c6a:	ea 18 ab cd 	orh	r8,0xabcd
80002c6e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c70:	30 08       	mov	r8,0
80002c72:	8f 38       	st.w	r7[0xc],r8
}
80002c74:	2f fd       	sub	sp,-4
80002c76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c7a:	00 00       	add	r0,r0
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a cc       	st.b	r5++,r12
80002c80:	00 00       	add	r0,r0
80002c82:	0a 8c       	andn	r12,r5
80002c84:	00 00       	add	r0,r0
80002c86:	0a 98       	mov	r8,r5
80002c88:	80 00       	ld.sh	r0,r0[0x0]
80002c8a:	5e 60       	retmi	r0
80002c8c:	00 00       	add	r0,r0
80002c8e:	0a b4       	st.h	r5++,r4
80002c90:	00 00       	add	r0,r0
80002c92:	0a 6c       	and	r12,r5

80002c94 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c94:	d4 01       	pushm	lr
80002c96:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c98:	30 0a       	mov	r10,0
80002c9a:	fa cb ff fc 	sub	r11,sp,-4
80002c9e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002ca0:	14 99       	mov	r9,r10
80002ca2:	1a 9b       	mov	r11,sp
80002ca4:	f0 1f 00 05 	mcall	80002cb8 <get_idle_store+0x24>
80002ca8:	58 1c       	cp.w	r12,1
80002caa:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cae:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002cb2:	2f fd       	sub	sp,-4
80002cb4:	d8 02       	popm	pc
80002cb6:	00 00       	add	r0,r0
80002cb8:	80 00       	ld.sh	r0,r0[0x0]
80002cba:	5f 50       	srlt	r0

80002cbc <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cbc:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cbe:	48 5b       	lddpc	r11,80002cd0 <phy_init+0x14>
80002cc0:	48 5c       	lddpc	r12,80002cd4 <phy_init+0x18>
80002cc2:	f0 1f 00 06 	mcall	80002cd8 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002cc6:	f0 1f 00 06 	mcall	80002cdc <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002cca:	f0 1f 00 06 	mcall	80002ce0 <phy_init+0x24>
	
}
80002cce:	d8 02       	popm	pc
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	2b 8c       	sub	r12,-72
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	2c e4       	sub	r4,-50
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	3d 38       	mov	r8,-45
80002cdc:	80 00       	ld.sh	r0,r0[0x0]
80002cde:	3d 4c       	mov	r12,-44
80002ce0:	80 00       	ld.sh	r0,r0[0x0]
80002ce2:	46 f8       	lddsp	r8,sp[0x1bc]

80002ce4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ce4:	eb cd 40 e0 	pushm	r5-r7,lr
80002ce8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002cea:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002cee:	70 08       	ld.w	r8,r8[0x0]
80002cf0:	58 08       	cp.w	r8,0
80002cf2:	e0 80 01 08 	breq	80002f02 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002cf6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002cf8:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002cfc:	70 09       	ld.w	r9,r8[0x0]
80002cfe:	2f f9       	sub	r9,-1
80002d00:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002d02:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002d06:	70 08       	ld.w	r8,r8[0x0]
80002d08:	58 18       	cp.w	r8,1
80002d0a:	e0 80 00 85 	breq	80002e14 <phy_rx_func+0x130>
80002d0e:	c0 73       	brcs	80002d1c <phy_rx_func+0x38>
80002d10:	58 28       	cp.w	r8,2
80002d12:	c5 c0       	breq	80002dca <phy_rx_func+0xe6>
80002d14:	58 38       	cp.w	r8,3
80002d16:	e0 81 00 f6 	brne	80002f02 <phy_rx_func+0x21e>
80002d1a:	cd 58       	rjmp	80002ec4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d1c:	e0 6a 5a 5a 	mov	r10,23130
80002d20:	ea 1a ab cd 	orh	r10,0xabcd
80002d24:	14 36       	cp.w	r6,r10
80002d26:	e0 80 00 ee 	breq	80002f02 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d2a:	ec 08 16 10 	lsr	r8,r6,0x10
80002d2e:	e0 48 ab cd 	cp.w	r8,43981
80002d32:	e0 81 00 e8 	brne	80002f02 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d36:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d3a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d3e:	20 28       	sub	r8,2
80002d40:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d44:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d46:	30 09       	mov	r9,0
80002d48:	f2 08 19 00 	cp.h	r8,r9
80002d4c:	e0 8a 00 db 	brle	80002f02 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d50:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d54:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d56:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d5a:	70 0c       	ld.w	r12,r8[0x0]
80002d5c:	f0 1f 03 88 	mcall	80003b7c <phy_rx_func+0xe98>
80002d60:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002d64:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002d66:	58 0c       	cp.w	r12,0
80002d68:	e0 80 00 cd 	breq	80002f02 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d6c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d70:	90 09       	ld.sh	r9,r8[0x0]
80002d72:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d76:	2f f9       	sub	r9,-1
80002d78:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d7a:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d7e:	74 0a       	ld.w	r10,r10[0x0]
80002d80:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d84:	76 0b       	ld.w	r11,r11[0x0]
80002d86:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d8a:	2f f9       	sub	r9,-1
80002d8c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d8e:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d92:	e0 46 01 00 	cp.w	r6,256
80002d96:	c0 c0       	breq	80002dae <phy_rx_func+0xca>
80002d98:	e0 8b 00 05 	brhi	80002da2 <phy_rx_func+0xbe>
80002d9c:	58 06       	cp.w	r6,0
80002d9e:	c0 80       	breq	80002dae <phy_rx_func+0xca>
80002da0:	c0 c8       	rjmp	80002db8 <phy_rx_func+0xd4>
80002da2:	e0 46 02 00 	cp.w	r6,512
80002da6:	c0 40       	breq	80002dae <phy_rx_func+0xca>
80002da8:	e0 46 03 00 	cp.w	r6,768
80002dac:	c0 61       	brne	80002db8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002dae:	30 29       	mov	r9,2
80002db0:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002db4:	91 09       	st.w	r8[0x0],r9
80002db6:	ca 68       	rjmp	80002f02 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002db8:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002dbc:	70 0c       	ld.w	r12,r8[0x0]
80002dbe:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002dc2:	70 0b       	ld.w	r11,r8[0x0]
80002dc4:	f0 1f 03 70 	mcall	80003b84 <phy_rx_func+0xea0>
80002dc8:	c9 d8       	rjmp	80002f02 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002dca:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002dce:	b1 86       	lsr	r6,0x10
80002dd0:	14 06       	add	r6,r10
80002dd2:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002dd6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dd8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ddc:	90 09       	ld.sh	r9,r8[0x0]
80002dde:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002de2:	76 0b       	ld.w	r11,r11[0x0]
80002de4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002de8:	2f f9       	sub	r9,-1
80002dea:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002dec:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002df0:	92 08       	ld.sh	r8,r9[0x0]
80002df2:	20 28       	sub	r8,2
80002df4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002df6:	30 09       	mov	r9,0
80002df8:	f2 08 19 00 	cp.h	r8,r9
80002dfc:	e0 8a 00 07 	brle	80002e0a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002e00:	30 19       	mov	r9,1
80002e02:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002e06:	91 09       	st.w	r8[0x0],r9
80002e08:	c7 d8       	rjmp	80002f02 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002e0a:	30 39       	mov	r9,3
80002e0c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002e10:	91 09       	st.w	r8[0x0],r9
80002e12:	c7 88       	rjmp	80002f02 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002e14:	ec 0a 14 10 	asr	r10,r6,0x10
80002e18:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e1c:	90 09       	ld.sh	r9,r8[0x0]
80002e1e:	14 09       	add	r9,r10
80002e20:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e22:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e26:	92 08       	ld.sh	r8,r9[0x0]
80002e28:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e2c:	76 0b       	ld.w	r11,r11[0x0]
80002e2e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e32:	2f f8       	sub	r8,-1
80002e34:	5c 88       	casts.h	r8
80002e36:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e38:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e3c:	94 09       	ld.sh	r9,r10[0x0]
80002e3e:	20 29       	sub	r9,2
80002e40:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e42:	30 0a       	mov	r10,0
80002e44:	f4 09 19 00 	cp.h	r9,r10
80002e48:	e0 89 00 20 	brgt	80002e88 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e4c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e50:	e0 46 00 ba 	cp.w	r6,186
80002e54:	c0 d1       	brne	80002e6e <phy_rx_func+0x18a>
80002e56:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e5a:	90 09       	ld.sh	r9,r8[0x0]
80002e5c:	f4 09 19 00 	cp.h	r9,r10
80002e60:	c0 71       	brne	80002e6e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e62:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002e66:	70 0c       	ld.w	r12,r8[0x0]
80002e68:	f0 1f 03 49 	mcall	80003b8c <phy_rx_func+0xea8>
80002e6c:	c0 98       	rjmp	80002e7e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e6e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e72:	70 0c       	ld.w	r12,r8[0x0]
80002e74:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e78:	70 0b       	ld.w	r11,r8[0x0]
80002e7a:	f0 1f 03 43 	mcall	80003b84 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e7e:	30 09       	mov	r9,0
80002e80:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e84:	91 09       	st.w	r8[0x0],r9
80002e86:	c3 e8       	rjmp	80002f02 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e88:	5c 86       	casts.h	r6
80002e8a:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e8e:	92 0a       	ld.sh	r10,r9[0x0]
80002e90:	0c 0a       	add	r10,r6
80002e92:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e94:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e98:	72 09       	ld.w	r9,r9[0x0]
80002e9a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e9e:	2f f8       	sub	r8,-1
80002ea0:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002ea4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002ea6:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002eaa:	92 08       	ld.sh	r8,r9[0x0]
80002eac:	20 28       	sub	r8,2
80002eae:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002eb0:	30 09       	mov	r9,0
80002eb2:	f2 08 19 00 	cp.h	r8,r9
80002eb6:	e0 89 00 26 	brgt	80002f02 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002eba:	30 39       	mov	r9,3
80002ebc:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002ec0:	91 09       	st.w	r8[0x0],r9
80002ec2:	c2 08       	rjmp	80002f02 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002ec4:	e6 16 00 ff 	andh	r6,0xff,COH
80002ec8:	fc 19 00 ba 	movh	r9,0xba
80002ecc:	12 36       	cp.w	r6,r9
80002ece:	c0 e1       	brne	80002eea <phy_rx_func+0x206>
80002ed0:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ed4:	90 09       	ld.sh	r9,r8[0x0]
80002ed6:	30 08       	mov	r8,0
80002ed8:	f0 09 19 00 	cp.h	r9,r8
80002edc:	c0 71       	brne	80002eea <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002ede:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002ee2:	70 0c       	ld.w	r12,r8[0x0]
80002ee4:	f0 1f 03 2a 	mcall	80003b8c <phy_rx_func+0xea8>
80002ee8:	c0 98       	rjmp	80002efa <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002eea:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002eee:	70 0c       	ld.w	r12,r8[0x0]
80002ef0:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002ef4:	70 0b       	ld.w	r11,r8[0x0]
80002ef6:	f0 1f 03 24 	mcall	80003b84 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002efa:	30 09       	mov	r9,0
80002efc:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002f00:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002f02:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002f06:	11 89       	ld.ub	r9,r8[0x0]
80002f08:	30 08       	mov	r8,0
80002f0a:	f0 09 18 00 	cp.b	r9,r8
80002f0e:	c1 31       	brne	80002f34 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002f10:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002f14:	6c 0c       	ld.w	r12,r6[0x0]
80002f16:	f0 1f 03 1a 	mcall	80003b7c <phy_rx_func+0xe98>
80002f1a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f1e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f20:	6c 0c       	ld.w	r12,r6[0x0]
80002f22:	f0 1f 03 17 	mcall	80003b7c <phy_rx_func+0xe98>
80002f26:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f2a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f2c:	30 19       	mov	r9,1
80002f2e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f32:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f34:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f38:	70 08       	ld.w	r8,r8[0x0]
80002f3a:	58 28       	cp.w	r8,2
80002f3c:	e0 80 01 98 	breq	8000326c <phy_rx_func+0x588>
80002f40:	e0 8b 00 06 	brhi	80002f4c <phy_rx_func+0x268>
80002f44:	58 08       	cp.w	r8,0
80002f46:	c0 b0       	breq	80002f5c <phy_rx_func+0x278>
80002f48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f4c:	58 38       	cp.w	r8,3
80002f4e:	e0 80 05 c5 	breq	80003ad8 <phy_rx_func+0xdf4>
80002f52:	58 48       	cp.w	r8,4
80002f54:	e0 81 06 05 	brne	80003b5e <phy_rx_func+0xe7a>
80002f58:	e0 8f 02 4b 	bral	800033ee <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f5c:	6e 28       	ld.w	r8,r7[0x8]
80002f5e:	e0 6a 5a 5a 	mov	r10,23130
80002f62:	ea 1a ab cd 	orh	r10,0xabcd
80002f66:	14 38       	cp.w	r8,r10
80002f68:	c0 71       	brne	80002f76 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f6a:	30 09       	mov	r9,0
80002f6c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f70:	91 09       	st.w	r8[0x0],r9
80002f72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f76:	10 99       	mov	r9,r8
80002f78:	e0 19 00 00 	andl	r9,0x0
80002f7c:	fc 1a ab cd 	movh	r10,0xabcd
80002f80:	14 39       	cp.w	r9,r10
80002f82:	e0 81 05 ee 	brne	80003b5e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f86:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f8a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f8e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f90:	6e 29       	ld.w	r9,r7[0x8]
80002f92:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f96:	e0 49 c0 00 	cp.w	r9,49152
80002f9a:	e0 81 00 ce 	brne	80003136 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f9e:	30 1a       	mov	r10,1
80002fa0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002fa4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002fa6:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002faa:	72 09       	ld.w	r9,r9[0x0]
80002fac:	58 09       	cp.w	r9,0
80002fae:	c0 71       	brne	80002fbc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002fb0:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002fb4:	f0 1f 03 00 	mcall	80003bb4 <phy_rx_func+0xed0>
80002fb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002fbc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002fc0:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002fc4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002fc6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002fca:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002fce:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002fd2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002fd4:	13 89       	ld.ub	r9,r9[0x0]
80002fd6:	37 fa       	mov	r10,127
80002fd8:	f4 09 18 00 	cp.b	r9,r10
80002fdc:	c6 d0       	breq	800030b6 <phy_rx_func+0x3d2>
80002fde:	e0 8b 00 0c 	brhi	80002ff6 <phy_rx_func+0x312>
80002fe2:	31 2a       	mov	r10,18
80002fe4:	f4 09 18 00 	cp.b	r9,r10
80002fe8:	c4 20       	breq	8000306c <phy_rx_func+0x388>
80002fea:	31 3a       	mov	r10,19
80002fec:	f4 09 18 00 	cp.b	r9,r10
80002ff0:	e0 81 00 83 	brne	800030f6 <phy_rx_func+0x412>
80002ff4:	c5 b8       	rjmp	800030aa <phy_rx_func+0x3c6>
80002ff6:	2f 09       	sub	r9,-16
80002ff8:	30 1a       	mov	r10,1
80002ffa:	f4 09 18 00 	cp.b	r9,r10
80002ffe:	e0 8b 00 7c 	brhi	800030f6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003002:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003006:	e2 18 00 f0 	andl	r8,0xf0,COH
8000300a:	59 08       	cp.w	r8,16
8000300c:	c0 71       	brne	8000301a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000300e:	30 19       	mov	r9,1
80003010:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003014:	91 09       	st.w	r8[0x0],r9
80003016:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000301a:	e0 48 00 20 	cp.w	r8,32
8000301e:	c2 11       	brne	80003060 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003020:	30 a9       	mov	r9,10
80003022:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003026:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003028:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000302c:	6c 08       	ld.w	r8,r6[0x0]
8000302e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003032:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003036:	2f f8       	sub	r8,-1
80003038:	6e 0c       	ld.w	r12,r7[0x0]
8000303a:	f4 ca fe 00 	sub	r10,r10,-512
8000303e:	30 0b       	mov	r11,0
80003040:	10 0c       	add	r12,r8
80003042:	f0 1f 02 e1 	mcall	80003bc4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003046:	30 08       	mov	r8,0
80003048:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000304a:	6e 0c       	ld.w	r12,r7[0x0]
8000304c:	f0 1f 02 df 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003050:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003054:	70 0c       	ld.w	r12,r8[0x0]
80003056:	f0 1f 02 ca 	mcall	80003b7c <phy_rx_func+0xe98>
8000305a:	8f 0c       	st.w	r7[0x0],r12
8000305c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003060:	30 09       	mov	r9,0
80003062:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003066:	91 09       	st.w	r8[0x0],r9
80003068:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000306c:	20 48       	sub	r8,4
8000306e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003072:	93 08       	st.w	r9[0x0],r8
80003074:	58 08       	cp.w	r8,0
80003076:	e0 80 05 74 	breq	80003b5e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000307a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000307e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003082:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003086:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003088:	8e 69       	ld.sh	r9,r7[0xc]
8000308a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000308e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003090:	8e 79       	ld.sh	r9,r7[0xe]
80003092:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003094:	f0 1f 02 d0 	mcall	80003bd4 <phy_rx_func+0xef0>
80003098:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000309c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000309e:	30 49       	mov	r9,4
800030a0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800030a4:	91 09       	st.w	r8[0x0],r9
800030a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800030aa:	30 09       	mov	r9,0
800030ac:	fe f8 0a f8 	ld.w	r8,pc[2808]
800030b0:	91 09       	st.w	r8[0x0],r9
800030b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030b6:	20 48       	sub	r8,4
800030b8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030bc:	93 08       	st.w	r9[0x0],r8
800030be:	58 08       	cp.w	r8,0
800030c0:	e0 80 05 4f 	breq	80003b5e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800030c4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800030c8:	70 09       	ld.w	r9,r8[0x0]
800030ca:	8e 7b       	ld.sh	r11,r7[0xe]
800030cc:	fe fa 0b 10 	ld.w	r10,pc[2832]
800030d0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800030d4:	2f f9       	sub	r9,-1
800030d6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800030d8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800030dc:	70 09       	ld.w	r9,r8[0x0]
800030de:	20 29       	sub	r9,2
800030e0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800030e2:	30 29       	mov	r9,2
800030e4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800030e8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800030ea:	30 39       	mov	r9,3
800030ec:	fe f8 0a b4 	ld.w	r8,pc[2740]
800030f0:	91 09       	st.w	r8[0x0],r9
800030f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800030f6:	30 3a       	mov	r10,3
800030f8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800030fc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800030fe:	6e 2a       	ld.w	r10,r7[0x8]
80003100:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003104:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003106:	6e 3a       	ld.w	r10,r7[0xc]
80003108:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000310a:	59 48       	cp.w	r8,20
8000310c:	c0 61       	brne	80003118 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000310e:	31 89       	mov	r9,24
80003110:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003114:	91 09       	st.w	r8[0x0],r9
80003116:	c0 a8       	rjmp	8000312a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003118:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000311c:	70 08       	ld.w	r8,r8[0x0]
8000311e:	59 08       	cp.w	r8,16
80003120:	c0 51       	brne	8000312a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003122:	31 09       	mov	r9,16
80003124:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003128:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000312a:	30 49       	mov	r9,4
8000312c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003136:	e0 49 10 00 	cp.w	r9,4096
8000313a:	5f 1a       	srne	r10
8000313c:	e0 49 20 00 	cp.w	r9,8192
80003140:	5f 19       	srne	r9
80003142:	f5 e9 00 09 	and	r9,r10,r9
80003146:	e0 81 05 0c 	brne	80003b5e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000314a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000314e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003150:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003154:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003156:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000315a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000315c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003160:	72 09       	ld.w	r9,r9[0x0]
80003162:	58 09       	cp.w	r9,0
80003164:	c0 71       	brne	80003172 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003166:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000316a:	f0 1f 02 93 	mcall	80003bb4 <phy_rx_func+0xed0>
8000316e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003172:	6e 2a       	ld.w	r10,r7[0x8]
80003174:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003178:	58 1a       	cp.w	r10,1
8000317a:	e0 8b 00 4d 	brhi	80003214 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000317e:	20 48       	sub	r8,4
80003180:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003184:	93 08       	st.w	r9[0x0],r8
80003186:	58 08       	cp.w	r8,0
80003188:	e0 80 04 eb 	breq	80003b5e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
8000318c:	8e 68       	ld.sh	r8,r7[0xc]
8000318e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003192:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003196:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003198:	30 09       	mov	r9,0
8000319a:	f2 08 19 00 	cp.h	r8,r9
8000319e:	c0 70       	breq	800031ac <phy_rx_func+0x4c8>
800031a0:	30 19       	mov	r9,1
800031a2:	f2 08 19 00 	cp.h	r8,r9
800031a6:	e0 81 04 dc 	brne	80003b5e <phy_rx_func+0xe7a>
800031aa:	c2 68       	rjmp	800031f6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031ac:	fe f8 0a 44 	ld.w	r8,pc[2628]
800031b0:	70 0a       	ld.w	r10,r8[0x0]
800031b2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800031b6:	72 09       	ld.w	r9,r9[0x0]
800031b8:	8e 7b       	ld.sh	r11,r7[0xe]
800031ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031be:	70 09       	ld.w	r9,r8[0x0]
800031c0:	2f f9       	sub	r9,-1
800031c2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031c4:	e0 49 00 ff 	cp.w	r9,255
800031c8:	e0 88 00 11 	brls	800031ea <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800031cc:	30 09       	mov	r9,0
800031ce:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800031d0:	fe f7 09 c8 	ld.w	r7,pc[2504]
800031d4:	6e 0c       	ld.w	r12,r7[0x0]
800031d6:	f0 1f 02 7d 	mcall	80003bc8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800031da:	fe f8 09 ba 	ld.w	r8,pc[2490]
800031de:	70 0c       	ld.w	r12,r8[0x0]
800031e0:	f0 1f 02 67 	mcall	80003b7c <phy_rx_func+0xe98>
800031e4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800031e6:	e0 80 04 bc 	breq	80003b5e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800031ea:	30 29       	mov	r9,2
800031ec:	fe f8 09 b4 	ld.w	r8,pc[2484]
800031f0:	91 09       	st.w	r8[0x0],r9
800031f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031f6:	8e 79       	ld.sh	r9,r7[0xe]
800031f8:	30 38       	mov	r8,3
800031fa:	f0 09 19 00 	cp.h	r9,r8
800031fe:	c0 51       	brne	80003208 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003200:	30 19       	mov	r9,1
80003202:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003206:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003208:	30 29       	mov	r9,2
8000320a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000320e:	91 09       	st.w	r8[0x0],r9
80003210:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003214:	58 18       	cp.w	r8,1
80003216:	e0 88 04 a4 	brls	80003b5e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000321a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000321e:	70 0a       	ld.w	r10,r8[0x0]
80003220:	6e 3b       	ld.w	r11,r7[0xc]
80003222:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003226:	70 09       	ld.w	r9,r8[0x0]
80003228:	2f f9       	sub	r9,-1
8000322a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000322c:	e0 49 00 ff 	cp.w	r9,255
80003230:	e0 88 00 11 	brls	80003252 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003234:	30 09       	mov	r9,0
80003236:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003238:	fe f7 09 60 	ld.w	r7,pc[2400]
8000323c:	6e 0c       	ld.w	r12,r7[0x0]
8000323e:	f0 1f 02 63 	mcall	80003bc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003242:	fe f8 09 52 	ld.w	r8,pc[2386]
80003246:	70 0c       	ld.w	r12,r8[0x0]
80003248:	f0 1f 02 4d 	mcall	80003b7c <phy_rx_func+0xe98>
8000324c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000324e:	e0 80 04 88 	breq	80003b5e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003252:	fe f9 09 56 	ld.w	r9,pc[2390]
80003256:	72 08       	ld.w	r8,r9[0x0]
80003258:	20 28       	sub	r8,2
8000325a:	93 08       	st.w	r9[0x0],r8
8000325c:	e0 80 04 81 	breq	80003b5e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003260:	30 29       	mov	r9,2
80003262:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003266:	91 09       	st.w	r8[0x0],r9
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000326c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003270:	70 0a       	ld.w	r10,r8[0x0]
80003272:	fe f9 09 26 	ld.w	r9,pc[2342]
80003276:	72 09       	ld.w	r9,r9[0x0]
80003278:	8e 4b       	ld.sh	r11,r7[0x8]
8000327a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000327e:	70 09       	ld.w	r9,r8[0x0]
80003280:	2f f9       	sub	r9,-1
80003282:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003284:	e0 49 00 ff 	cp.w	r9,255
80003288:	e0 88 00 16 	brls	800032b4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
8000328c:	30 09       	mov	r9,0
8000328e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003290:	fe f6 09 08 	ld.w	r6,pc[2312]
80003294:	6c 0c       	ld.w	r12,r6[0x0]
80003296:	f0 1f 02 4d 	mcall	80003bc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000329a:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000329e:	70 0c       	ld.w	r12,r8[0x0]
800032a0:	f0 1f 02 37 	mcall	80003b7c <phy_rx_func+0xe98>
800032a4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032a6:	c0 71       	brne	800032b4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800032a8:	30 09       	mov	r9,0
800032aa:	fe f8 08 f6 	ld.w	r8,pc[2294]
800032ae:	91 09       	st.w	r8[0x0],r9
800032b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800032b4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032b8:	72 08       	ld.w	r8,r9[0x0]
800032ba:	20 28       	sub	r8,2
800032bc:	93 08       	st.w	r9[0x0],r8
800032be:	c0 71       	brne	800032cc <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032c0:	30 09       	mov	r9,0
800032c2:	fe f8 08 de 	ld.w	r8,pc[2270]
800032c6:	91 09       	st.w	r8[0x0],r9
800032c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800032cc:	fe f8 09 24 	ld.w	r8,pc[2340]
800032d0:	70 0a       	ld.w	r10,r8[0x0]
800032d2:	fe f9 08 c6 	ld.w	r9,pc[2246]
800032d6:	72 09       	ld.w	r9,r9[0x0]
800032d8:	8e 5b       	ld.sh	r11,r7[0xa]
800032da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032de:	70 09       	ld.w	r9,r8[0x0]
800032e0:	2f f9       	sub	r9,-1
800032e2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e4:	e0 49 00 ff 	cp.w	r9,255
800032e8:	e0 88 00 16 	brls	80003314 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800032ec:	30 09       	mov	r9,0
800032ee:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032f0:	fe f6 08 a8 	ld.w	r6,pc[2216]
800032f4:	6c 0c       	ld.w	r12,r6[0x0]
800032f6:	f0 1f 02 35 	mcall	80003bc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032fa:	fe f8 08 9a 	ld.w	r8,pc[2202]
800032fe:	70 0c       	ld.w	r12,r8[0x0]
80003300:	f0 1f 02 1f 	mcall	80003b7c <phy_rx_func+0xe98>
80003304:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003306:	c0 71       	brne	80003314 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003308:	30 09       	mov	r9,0
8000330a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000330e:	91 09       	st.w	r8[0x0],r9
80003310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003314:	fe f9 08 94 	ld.w	r9,pc[2196]
80003318:	72 08       	ld.w	r8,r9[0x0]
8000331a:	20 28       	sub	r8,2
8000331c:	93 08       	st.w	r9[0x0],r8
8000331e:	c0 71       	brne	8000332c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003320:	30 09       	mov	r9,0
80003322:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003326:	91 09       	st.w	r8[0x0],r9
80003328:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000332c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003330:	70 0a       	ld.w	r10,r8[0x0]
80003332:	fe f9 08 66 	ld.w	r9,pc[2150]
80003336:	72 09       	ld.w	r9,r9[0x0]
80003338:	8e 6b       	ld.sh	r11,r7[0xc]
8000333a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000333e:	70 09       	ld.w	r9,r8[0x0]
80003340:	2f f9       	sub	r9,-1
80003342:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003344:	e0 49 00 ff 	cp.w	r9,255
80003348:	e0 88 00 16 	brls	80003374 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000334c:	30 09       	mov	r9,0
8000334e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003350:	fe f6 08 48 	ld.w	r6,pc[2120]
80003354:	6c 0c       	ld.w	r12,r6[0x0]
80003356:	f0 1f 02 1d 	mcall	80003bc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000335a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000335e:	70 0c       	ld.w	r12,r8[0x0]
80003360:	f0 1f 02 07 	mcall	80003b7c <phy_rx_func+0xe98>
80003364:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003366:	c0 71       	brne	80003374 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003368:	30 09       	mov	r9,0
8000336a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000336e:	91 09       	st.w	r8[0x0],r9
80003370:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003374:	fe f9 08 34 	ld.w	r9,pc[2100]
80003378:	72 08       	ld.w	r8,r9[0x0]
8000337a:	20 28       	sub	r8,2
8000337c:	93 08       	st.w	r9[0x0],r8
8000337e:	c0 71       	brne	8000338c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003380:	30 09       	mov	r9,0
80003382:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003386:	91 09       	st.w	r8[0x0],r9
80003388:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000338c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003390:	70 0a       	ld.w	r10,r8[0x0]
80003392:	fe f9 08 06 	ld.w	r9,pc[2054]
80003396:	72 09       	ld.w	r9,r9[0x0]
80003398:	8e 7b       	ld.sh	r11,r7[0xe]
8000339a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000339e:	70 09       	ld.w	r9,r8[0x0]
800033a0:	2f f9       	sub	r9,-1
800033a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a4:	e0 49 00 ff 	cp.w	r9,255
800033a8:	e0 88 00 16 	brls	800033d4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800033ac:	30 09       	mov	r9,0
800033ae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033b0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800033b4:	6e 0c       	ld.w	r12,r7[0x0]
800033b6:	f0 1f 02 05 	mcall	80003bc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033ba:	fe f8 07 da 	ld.w	r8,pc[2010]
800033be:	70 0c       	ld.w	r12,r8[0x0]
800033c0:	f0 1f 01 ef 	mcall	80003b7c <phy_rx_func+0xe98>
800033c4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033c6:	c0 71       	brne	800033d4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800033c8:	30 09       	mov	r9,0
800033ca:	fe f8 07 d6 	ld.w	r8,pc[2006]
800033ce:	91 09       	st.w	r8[0x0],r9
800033d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033d4:	fe f9 07 d4 	ld.w	r9,pc[2004]
800033d8:	72 08       	ld.w	r8,r9[0x0]
800033da:	20 28       	sub	r8,2
800033dc:	93 08       	st.w	r9[0x0],r8
800033de:	e0 81 03 c0 	brne	80003b5e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800033e2:	30 09       	mov	r9,0
800033e4:	fe f8 07 bc 	ld.w	r8,pc[1980]
800033e8:	91 09       	st.w	r8[0x0],r9
800033ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800033ee:	fe f8 07 ca 	ld.w	r8,pc[1994]
800033f2:	11 89       	ld.ub	r9,r8[0x0]
800033f4:	31 28       	mov	r8,18
800033f6:	f0 09 18 00 	cp.b	r9,r8
800033fa:	e0 81 01 4c 	brne	80003692 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800033fe:	ef 39 00 09 	ld.ub	r9,r7[9]
80003402:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003406:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003408:	11 89       	ld.ub	r9,r8[0x0]
8000340a:	3f 28       	mov	r8,-14
8000340c:	f0 09 18 00 	cp.b	r9,r8
80003410:	e0 81 01 3b 	brne	80003686 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003414:	30 19       	mov	r9,1
80003416:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000341a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000341c:	6e 29       	ld.w	r9,r7[0x8]
8000341e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003422:	fe f8 07 86 	ld.w	r8,pc[1926]
80003426:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003428:	8e 59       	ld.sh	r9,r7[0xa]
8000342a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000342e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003430:	8e 69       	ld.sh	r9,r7[0xc]
80003432:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003434:	8e 79       	ld.sh	r9,r7[0xe]
80003436:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003438:	fe f8 07 88 	ld.w	r8,pc[1928]
8000343c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003440:	72 0a       	ld.w	r10,r9[0x0]
80003442:	70 09       	ld.w	r9,r8[0x0]
80003444:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003448:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000344c:	70 09       	ld.w	r9,r8[0x0]
8000344e:	2f f9       	sub	r9,-1
80003450:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003452:	e0 49 01 ff 	cp.w	r9,511
80003456:	e0 88 00 16 	brls	80003482 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000345a:	30 09       	mov	r9,0
8000345c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000345e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003462:	6c 0c       	ld.w	r12,r6[0x0]
80003464:	f0 1f 01 d9 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003468:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000346c:	70 0c       	ld.w	r12,r8[0x0]
8000346e:	f0 1f 01 c4 	mcall	80003b7c <phy_rx_func+0xe98>
80003472:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003474:	c0 71       	brne	80003482 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003476:	30 09       	mov	r9,0
80003478:	fe f8 07 28 	ld.w	r8,pc[1832]
8000347c:	91 09       	st.w	r8[0x0],r9
8000347e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003482:	fe f9 07 26 	ld.w	r9,pc[1830]
80003486:	72 08       	ld.w	r8,r9[0x0]
80003488:	20 18       	sub	r8,1
8000348a:	93 08       	st.w	r9[0x0],r8
8000348c:	c0 71       	brne	8000349a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000348e:	30 09       	mov	r9,0
80003490:	fe f8 07 10 	ld.w	r8,pc[1808]
80003494:	91 09       	st.w	r8[0x0],r9
80003496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000349a:	fe f8 07 26 	ld.w	r8,pc[1830]
8000349e:	fe f9 06 fe 	ld.w	r9,pc[1790]
800034a2:	72 0a       	ld.w	r10,r9[0x0]
800034a4:	70 09       	ld.w	r9,r8[0x0]
800034a6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800034aa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ae:	70 09       	ld.w	r9,r8[0x0]
800034b0:	2f f9       	sub	r9,-1
800034b2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034b4:	e0 49 01 ff 	cp.w	r9,511
800034b8:	e0 88 00 16 	brls	800034e4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034bc:	30 09       	mov	r9,0
800034be:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034c0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800034c4:	6c 0c       	ld.w	r12,r6[0x0]
800034c6:	f0 1f 01 c1 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034ca:	fe f8 06 ca 	ld.w	r8,pc[1738]
800034ce:	70 0c       	ld.w	r12,r8[0x0]
800034d0:	f0 1f 01 ab 	mcall	80003b7c <phy_rx_func+0xe98>
800034d4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034d6:	c0 71       	brne	800034e4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800034d8:	30 09       	mov	r9,0
800034da:	fe f8 06 c6 	ld.w	r8,pc[1734]
800034de:	91 09       	st.w	r8[0x0],r9
800034e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034e4:	fe f9 06 c4 	ld.w	r9,pc[1732]
800034e8:	72 08       	ld.w	r8,r9[0x0]
800034ea:	20 18       	sub	r8,1
800034ec:	93 08       	st.w	r9[0x0],r8
800034ee:	c0 71       	brne	800034fc <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800034f0:	30 09       	mov	r9,0
800034f2:	fe f8 06 ae 	ld.w	r8,pc[1710]
800034f6:	91 09       	st.w	r8[0x0],r9
800034f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800034fc:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003500:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003504:	72 0a       	ld.w	r10,r9[0x0]
80003506:	70 09       	ld.w	r9,r8[0x0]
80003508:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000350c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003510:	70 09       	ld.w	r9,r8[0x0]
80003512:	2f f9       	sub	r9,-1
80003514:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003516:	e0 49 01 ff 	cp.w	r9,511
8000351a:	e0 88 00 16 	brls	80003546 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000351e:	30 09       	mov	r9,0
80003520:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003522:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003526:	6c 0c       	ld.w	r12,r6[0x0]
80003528:	f0 1f 01 a8 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000352c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003530:	70 0c       	ld.w	r12,r8[0x0]
80003532:	f0 1f 01 93 	mcall	80003b7c <phy_rx_func+0xe98>
80003536:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003538:	c0 71       	brne	80003546 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000353a:	30 09       	mov	r9,0
8000353c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003540:	91 09       	st.w	r8[0x0],r9
80003542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003546:	fe f9 06 62 	ld.w	r9,pc[1634]
8000354a:	72 08       	ld.w	r8,r9[0x0]
8000354c:	20 18       	sub	r8,1
8000354e:	93 08       	st.w	r9[0x0],r8
80003550:	c0 71       	brne	8000355e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003552:	30 09       	mov	r9,0
80003554:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003558:	91 09       	st.w	r8[0x0],r9
8000355a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000355e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003562:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003566:	72 0a       	ld.w	r10,r9[0x0]
80003568:	70 09       	ld.w	r9,r8[0x0]
8000356a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000356e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003572:	70 09       	ld.w	r9,r8[0x0]
80003574:	2f f9       	sub	r9,-1
80003576:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003578:	e0 49 01 ff 	cp.w	r9,511
8000357c:	e0 88 00 16 	brls	800035a8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003580:	30 09       	mov	r9,0
80003582:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003584:	fe f6 06 18 	ld.w	r6,pc[1560]
80003588:	6c 0c       	ld.w	r12,r6[0x0]
8000358a:	f0 1f 01 90 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000358e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003592:	70 0c       	ld.w	r12,r8[0x0]
80003594:	f0 1f 01 7a 	mcall	80003b7c <phy_rx_func+0xe98>
80003598:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000359a:	c0 71       	brne	800035a8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
8000359c:	30 09       	mov	r9,0
8000359e:	fe f8 06 02 	ld.w	r8,pc[1538]
800035a2:	91 09       	st.w	r8[0x0],r9
800035a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a8:	fe f9 06 00 	ld.w	r9,pc[1536]
800035ac:	72 08       	ld.w	r8,r9[0x0]
800035ae:	20 18       	sub	r8,1
800035b0:	93 08       	st.w	r9[0x0],r8
800035b2:	c0 71       	brne	800035c0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800035b4:	30 09       	mov	r9,0
800035b6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035ba:	91 09       	st.w	r8[0x0],r9
800035bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035c0:	fe f8 06 00 	ld.w	r8,pc[1536]
800035c4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800035c8:	72 0a       	ld.w	r10,r9[0x0]
800035ca:	70 09       	ld.w	r9,r8[0x0]
800035cc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800035d0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035d4:	70 09       	ld.w	r9,r8[0x0]
800035d6:	2f f9       	sub	r9,-1
800035d8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035da:	e0 49 01 ff 	cp.w	r9,511
800035de:	e0 88 00 16 	brls	8000360a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800035e2:	30 09       	mov	r9,0
800035e4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e6:	fe f6 05 b6 	ld.w	r6,pc[1462]
800035ea:	6c 0c       	ld.w	r12,r6[0x0]
800035ec:	f0 1f 01 77 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035f0:	fe f8 05 a4 	ld.w	r8,pc[1444]
800035f4:	70 0c       	ld.w	r12,r8[0x0]
800035f6:	f0 1f 01 62 	mcall	80003b7c <phy_rx_func+0xe98>
800035fa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035fc:	c0 71       	brne	8000360a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800035fe:	30 09       	mov	r9,0
80003600:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003604:	91 09       	st.w	r8[0x0],r9
80003606:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000360a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000360e:	72 08       	ld.w	r8,r9[0x0]
80003610:	20 18       	sub	r8,1
80003612:	93 08       	st.w	r9[0x0],r8
80003614:	c0 71       	brne	80003622 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003616:	30 09       	mov	r9,0
80003618:	fe f8 05 88 	ld.w	r8,pc[1416]
8000361c:	91 09       	st.w	r8[0x0],r9
8000361e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003622:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003626:	fe f9 05 76 	ld.w	r9,pc[1398]
8000362a:	72 0a       	ld.w	r10,r9[0x0]
8000362c:	70 09       	ld.w	r9,r8[0x0]
8000362e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003632:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003636:	70 09       	ld.w	r9,r8[0x0]
80003638:	2f f9       	sub	r9,-1
8000363a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363c:	e0 49 01 ff 	cp.w	r9,511
80003640:	e0 88 00 16 	brls	8000366c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003644:	30 09       	mov	r9,0
80003646:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003648:	fe f7 05 54 	ld.w	r7,pc[1364]
8000364c:	6e 0c       	ld.w	r12,r7[0x0]
8000364e:	f0 1f 01 5f 	mcall	80003bc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003652:	fe f8 05 42 	ld.w	r8,pc[1346]
80003656:	70 0c       	ld.w	r12,r8[0x0]
80003658:	f0 1f 01 49 	mcall	80003b7c <phy_rx_func+0xe98>
8000365c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000365e:	c0 71       	brne	8000366c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003660:	30 09       	mov	r9,0
80003662:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003666:	91 09       	st.w	r8[0x0],r9
80003668:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000366c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003670:	72 08       	ld.w	r8,r9[0x0]
80003672:	20 18       	sub	r8,1
80003674:	93 08       	st.w	r9[0x0],r8
80003676:	e0 81 02 74 	brne	80003b5e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000367a:	30 09       	mov	r9,0
8000367c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003680:	91 09       	st.w	r8[0x0],r9
80003682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003686:	30 09       	mov	r9,0
80003688:	fe f8 05 18 	ld.w	r8,pc[1304]
8000368c:	91 09       	st.w	r8[0x0],r9
8000368e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003692:	fe f8 05 26 	ld.w	r8,pc[1318]
80003696:	11 89       	ld.ub	r9,r8[0x0]
80003698:	3f 28       	mov	r8,-14
8000369a:	f0 09 18 00 	cp.b	r9,r8
8000369e:	c4 31       	brne	80003724 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800036a0:	8e 49       	ld.sh	r9,r7[0x8]
800036a2:	fe f8 05 56 	ld.w	r8,pc[1366]
800036a6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800036a8:	fe f8 05 18 	ld.w	r8,pc[1304]
800036ac:	fe f9 04 f0 	ld.w	r9,pc[1264]
800036b0:	72 0a       	ld.w	r10,r9[0x0]
800036b2:	70 09       	ld.w	r9,r8[0x0]
800036b4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036b8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036bc:	70 09       	ld.w	r9,r8[0x0]
800036be:	2f f9       	sub	r9,-1
800036c0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036c2:	e0 49 01 ff 	cp.w	r9,511
800036c6:	e0 88 00 16 	brls	800036f2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800036ca:	30 09       	mov	r9,0
800036cc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036ce:	fe f7 04 ce 	ld.w	r7,pc[1230]
800036d2:	6e 0c       	ld.w	r12,r7[0x0]
800036d4:	f0 1f 01 3d 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036d8:	fe f8 04 bc 	ld.w	r8,pc[1212]
800036dc:	70 0c       	ld.w	r12,r8[0x0]
800036de:	f0 1f 01 28 	mcall	80003b7c <phy_rx_func+0xe98>
800036e2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036e4:	c0 71       	brne	800036f2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800036e6:	30 09       	mov	r9,0
800036e8:	fe f8 04 b8 	ld.w	r8,pc[1208]
800036ec:	91 09       	st.w	r8[0x0],r9
800036ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036f2:	fe f9 04 b6 	ld.w	r9,pc[1206]
800036f6:	72 08       	ld.w	r8,r9[0x0]
800036f8:	20 18       	sub	r8,1
800036fa:	93 08       	st.w	r9[0x0],r8
800036fc:	c0 71       	brne	8000370a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800036fe:	30 09       	mov	r9,0
80003700:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003704:	91 09       	st.w	r8[0x0],r9
80003706:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000370a:	20 18       	sub	r8,1
8000370c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003710:	93 08       	st.w	r9[0x0],r8
80003712:	58 08       	cp.w	r8,0
80003714:	e0 81 02 25 	brne	80003b5e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003718:	30 09       	mov	r9,0
8000371a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000371e:	91 09       	st.w	r8[0x0],r9
80003720:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003724:	fe f8 04 94 	ld.w	r8,pc[1172]
80003728:	11 89       	ld.ub	r9,r8[0x0]
8000372a:	3f 38       	mov	r8,-13
8000372c:	f0 09 18 00 	cp.b	r9,r8
80003730:	e0 81 01 0c 	brne	80003948 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003734:	8e 49       	ld.sh	r9,r7[0x8]
80003736:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000373a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000373c:	8e 59       	ld.sh	r9,r7[0xa]
8000373e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003740:	8e 69       	ld.sh	r9,r7[0xc]
80003742:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003744:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003748:	fe f9 04 54 	ld.w	r9,pc[1108]
8000374c:	72 0a       	ld.w	r10,r9[0x0]
8000374e:	70 09       	ld.w	r9,r8[0x0]
80003750:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003754:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003758:	70 09       	ld.w	r9,r8[0x0]
8000375a:	2f f9       	sub	r9,-1
8000375c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000375e:	e0 49 01 ff 	cp.w	r9,511
80003762:	e0 88 00 16 	brls	8000378e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003766:	30 09       	mov	r9,0
80003768:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000376a:	fe f6 04 32 	ld.w	r6,pc[1074]
8000376e:	6c 0c       	ld.w	r12,r6[0x0]
80003770:	f0 1f 01 16 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003774:	fe f8 04 20 	ld.w	r8,pc[1056]
80003778:	70 0c       	ld.w	r12,r8[0x0]
8000377a:	f0 1f 01 01 	mcall	80003b7c <phy_rx_func+0xe98>
8000377e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003780:	c0 71       	brne	8000378e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003782:	30 09       	mov	r9,0
80003784:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003788:	91 09       	st.w	r8[0x0],r9
8000378a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000378e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003792:	72 08       	ld.w	r8,r9[0x0]
80003794:	20 18       	sub	r8,1
80003796:	93 08       	st.w	r9[0x0],r8
80003798:	c0 71       	brne	800037a6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000379a:	30 09       	mov	r9,0
8000379c:	fe f8 04 04 	ld.w	r8,pc[1028]
800037a0:	91 09       	st.w	r8[0x0],r9
800037a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800037a6:	fe f8 04 1a 	ld.w	r8,pc[1050]
800037aa:	fe f9 03 f2 	ld.w	r9,pc[1010]
800037ae:	72 0a       	ld.w	r10,r9[0x0]
800037b0:	70 09       	ld.w	r9,r8[0x0]
800037b2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800037b6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037ba:	70 09       	ld.w	r9,r8[0x0]
800037bc:	2f f9       	sub	r9,-1
800037be:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037c0:	e0 49 01 ff 	cp.w	r9,511
800037c4:	e0 88 00 16 	brls	800037f0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800037c8:	30 09       	mov	r9,0
800037ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037cc:	fe f6 03 d0 	ld.w	r6,pc[976]
800037d0:	6c 0c       	ld.w	r12,r6[0x0]
800037d2:	f0 1f 00 fe 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037d6:	fe f8 03 be 	ld.w	r8,pc[958]
800037da:	70 0c       	ld.w	r12,r8[0x0]
800037dc:	f0 1f 00 e8 	mcall	80003b7c <phy_rx_func+0xe98>
800037e0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037e2:	c0 71       	brne	800037f0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800037e4:	30 09       	mov	r9,0
800037e6:	fe f8 03 ba 	ld.w	r8,pc[954]
800037ea:	91 09       	st.w	r8[0x0],r9
800037ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037f0:	fe f9 03 b8 	ld.w	r9,pc[952]
800037f4:	72 08       	ld.w	r8,r9[0x0]
800037f6:	20 18       	sub	r8,1
800037f8:	93 08       	st.w	r9[0x0],r8
800037fa:	c0 71       	brne	80003808 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800037fc:	30 09       	mov	r9,0
800037fe:	fe f8 03 a2 	ld.w	r8,pc[930]
80003802:	91 09       	st.w	r8[0x0],r9
80003804:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003808:	fe f8 03 b8 	ld.w	r8,pc[952]
8000380c:	fe f9 03 90 	ld.w	r9,pc[912]
80003810:	72 0a       	ld.w	r10,r9[0x0]
80003812:	70 09       	ld.w	r9,r8[0x0]
80003814:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003818:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000381c:	70 09       	ld.w	r9,r8[0x0]
8000381e:	2f f9       	sub	r9,-1
80003820:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003822:	e0 49 01 ff 	cp.w	r9,511
80003826:	e0 88 00 16 	brls	80003852 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000382a:	30 09       	mov	r9,0
8000382c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000382e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003832:	6c 0c       	ld.w	r12,r6[0x0]
80003834:	f0 1f 00 e5 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003838:	fe f8 03 5c 	ld.w	r8,pc[860]
8000383c:	70 0c       	ld.w	r12,r8[0x0]
8000383e:	f0 1f 00 d0 	mcall	80003b7c <phy_rx_func+0xe98>
80003842:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003844:	c0 71       	brne	80003852 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 03 58 	ld.w	r8,pc[856]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003852:	fe f9 03 56 	ld.w	r9,pc[854]
80003856:	72 08       	ld.w	r8,r9[0x0]
80003858:	20 18       	sub	r8,1
8000385a:	93 08       	st.w	r9[0x0],r8
8000385c:	c0 71       	brne	8000386a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000385e:	30 09       	mov	r9,0
80003860:	fe f8 03 40 	ld.w	r8,pc[832]
80003864:	91 09       	st.w	r8[0x0],r9
80003866:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000386a:	fe f8 03 56 	ld.w	r8,pc[854]
8000386e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003872:	72 0a       	ld.w	r10,r9[0x0]
80003874:	70 09       	ld.w	r9,r8[0x0]
80003876:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000387a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000387e:	70 09       	ld.w	r9,r8[0x0]
80003880:	2f f9       	sub	r9,-1
80003882:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003884:	e0 49 01 ff 	cp.w	r9,511
80003888:	e0 88 00 16 	brls	800038b4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388c:	30 09       	mov	r9,0
8000388e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003890:	fe f6 03 0c 	ld.w	r6,pc[780]
80003894:	6c 0c       	ld.w	r12,r6[0x0]
80003896:	f0 1f 00 cd 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000389a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000389e:	70 0c       	ld.w	r12,r8[0x0]
800038a0:	f0 1f 00 b7 	mcall	80003b7c <phy_rx_func+0xe98>
800038a4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a6:	c0 71       	brne	800038b4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800038a8:	30 09       	mov	r9,0
800038aa:	fe f8 02 f6 	ld.w	r8,pc[758]
800038ae:	91 09       	st.w	r8[0x0],r9
800038b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b4:	fe f9 02 f4 	ld.w	r9,pc[756]
800038b8:	72 08       	ld.w	r8,r9[0x0]
800038ba:	20 18       	sub	r8,1
800038bc:	93 08       	st.w	r9[0x0],r8
800038be:	c0 71       	brne	800038cc <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038c0:	30 09       	mov	r9,0
800038c2:	fe f8 02 de 	ld.w	r8,pc[734]
800038c6:	91 09       	st.w	r8[0x0],r9
800038c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800038cc:	fe f8 02 f4 	ld.w	r8,pc[756]
800038d0:	fe f9 02 cc 	ld.w	r9,pc[716]
800038d4:	72 0a       	ld.w	r10,r9[0x0]
800038d6:	70 09       	ld.w	r9,r8[0x0]
800038d8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038e0:	70 09       	ld.w	r9,r8[0x0]
800038e2:	2f f9       	sub	r9,-1
800038e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e6:	e0 49 01 ff 	cp.w	r9,511
800038ea:	e0 88 00 16 	brls	80003916 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ee:	30 09       	mov	r9,0
800038f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038f2:	fe f7 02 aa 	ld.w	r7,pc[682]
800038f6:	6e 0c       	ld.w	r12,r7[0x0]
800038f8:	f0 1f 00 b4 	mcall	80003bc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038fc:	fe f8 02 98 	ld.w	r8,pc[664]
80003900:	70 0c       	ld.w	r12,r8[0x0]
80003902:	f0 1f 00 9f 	mcall	80003b7c <phy_rx_func+0xe98>
80003906:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003908:	c0 71       	brne	80003916 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000390a:	30 09       	mov	r9,0
8000390c:	fe f8 02 94 	ld.w	r8,pc[660]
80003910:	91 09       	st.w	r8[0x0],r9
80003912:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003916:	fe f9 02 92 	ld.w	r9,pc[658]
8000391a:	72 08       	ld.w	r8,r9[0x0]
8000391c:	20 18       	sub	r8,1
8000391e:	93 08       	st.w	r9[0x0],r8
80003920:	c0 71       	brne	8000392e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003922:	30 09       	mov	r9,0
80003924:	fe f8 02 7c 	ld.w	r8,pc[636]
80003928:	91 09       	st.w	r8[0x0],r9
8000392a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000392e:	20 18       	sub	r8,1
80003930:	fe f9 02 78 	ld.w	r9,pc[632]
80003934:	93 08       	st.w	r9[0x0],r8
80003936:	58 08       	cp.w	r8,0
80003938:	e0 81 01 13 	brne	80003b5e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000393c:	30 09       	mov	r9,0
8000393e:	fe f8 02 62 	ld.w	r8,pc[610]
80003942:	91 09       	st.w	r8[0x0],r9
80003944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003948:	fe f8 02 70 	ld.w	r8,pc[624]
8000394c:	11 89       	ld.ub	r9,r8[0x0]
8000394e:	30 48       	mov	r8,4
80003950:	f0 09 18 00 	cp.b	r9,r8
80003954:	c0 80       	breq	80003964 <phy_rx_func+0xc80>
80003956:	fe f8 02 62 	ld.w	r8,pc[610]
8000395a:	11 89       	ld.ub	r9,r8[0x0]
8000395c:	30 38       	mov	r8,3
8000395e:	f0 09 18 00 	cp.b	r9,r8
80003962:	c1 41       	brne	8000398a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003964:	6e 29       	ld.w	r9,r7[0x8]
80003966:	fe f8 02 7a 	ld.w	r8,pc[634]
8000396a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000396c:	6e 39       	ld.w	r9,r7[0xc]
8000396e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003970:	fe f9 02 38 	ld.w	r9,pc[568]
80003974:	72 08       	ld.w	r8,r9[0x0]
80003976:	20 88       	sub	r8,8
80003978:	93 08       	st.w	r9[0x0],r8
8000397a:	e0 81 00 f2 	brne	80003b5e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
8000397e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003980:	fe f9 02 20 	ld.w	r9,pc[544]
80003984:	93 08       	st.w	r9[0x0],r8
80003986:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000398a:	fe f8 02 2e 	ld.w	r8,pc[558]
8000398e:	11 89       	ld.ub	r9,r8[0x0]
80003990:	31 38       	mov	r8,19
80003992:	f0 09 18 00 	cp.b	r9,r8
80003996:	e0 81 00 9c 	brne	80003ace <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000399a:	fe f8 02 62 	ld.w	r8,pc[610]
8000399e:	11 88       	ld.ub	r8,r8[0x0]
800039a0:	30 c9       	mov	r9,12
800039a2:	f2 08 18 00 	cp.b	r8,r9
800039a6:	e0 81 00 7b 	brne	80003a9c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800039aa:	8e 49       	ld.sh	r9,r7[0x8]
800039ac:	fe f8 02 54 	ld.w	r8,pc[596]
800039b0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800039b4:	30 09       	mov	r9,0
800039b6:	fe f8 02 46 	ld.w	r8,pc[582]
800039ba:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039bc:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039c0:	3f 38       	mov	r8,-13
800039c2:	f0 09 18 00 	cp.b	r9,r8
800039c6:	c6 61       	brne	80003a92 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800039c8:	10 99       	mov	r9,r8
800039ca:	4f c8       	lddpc	r8,80003bb8 <phy_rx_func+0xed4>
800039cc:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800039ce:	ef 39 00 0c 	ld.ub	r9,r7[12]
800039d2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800039d6:	4f 58       	lddpc	r8,80003ba8 <phy_rx_func+0xec4>
800039d8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800039da:	30 19       	mov	r9,1
800039dc:	fe f8 02 0c 	ld.w	r8,pc[524]
800039e0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800039e2:	8e 79       	ld.sh	r9,r7[0xe]
800039e4:	fe f8 02 14 	ld.w	r8,pc[532]
800039e8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800039ea:	4f 68       	lddpc	r8,80003bc0 <phy_rx_func+0xedc>
800039ec:	4e c9       	lddpc	r9,80003b9c <phy_rx_func+0xeb8>
800039ee:	72 0a       	ld.w	r10,r9[0x0]
800039f0:	70 09       	ld.w	r9,r8[0x0]
800039f2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800039f6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	2f f9       	sub	r9,-1
800039fe:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a00:	e0 49 01 ff 	cp.w	r9,511
80003a04:	e0 88 00 13 	brls	80003a2a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a08:	30 09       	mov	r9,0
80003a0a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a0c:	4e 46       	lddpc	r6,80003b9c <phy_rx_func+0xeb8>
80003a0e:	6c 0c       	ld.w	r12,r6[0x0]
80003a10:	f0 1f 00 6e 	mcall	80003bc8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a14:	4e 08       	lddpc	r8,80003b94 <phy_rx_func+0xeb0>
80003a16:	70 0c       	ld.w	r12,r8[0x0]
80003a18:	f0 1f 00 59 	mcall	80003b7c <phy_rx_func+0xe98>
80003a1c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a1e:	c0 61       	brne	80003a2a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a20:	30 09       	mov	r9,0
80003a22:	4e 08       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a2a:	4e 09       	lddpc	r9,80003ba8 <phy_rx_func+0xec4>
80003a2c:	72 08       	ld.w	r8,r9[0x0]
80003a2e:	20 18       	sub	r8,1
80003a30:	93 08       	st.w	r9[0x0],r8
80003a32:	c0 61       	brne	80003a3e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a34:	30 09       	mov	r9,0
80003a36:	4d b8       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003a38:	91 09       	st.w	r8[0x0],r9
80003a3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a3e:	4e 18       	lddpc	r8,80003bc0 <phy_rx_func+0xedc>
80003a40:	4d 79       	lddpc	r9,80003b9c <phy_rx_func+0xeb8>
80003a42:	72 0a       	ld.w	r10,r9[0x0]
80003a44:	70 09       	ld.w	r9,r8[0x0]
80003a46:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a4a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a4e:	70 09       	ld.w	r9,r8[0x0]
80003a50:	2f f9       	sub	r9,-1
80003a52:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a54:	e0 49 01 ff 	cp.w	r9,511
80003a58:	e0 88 00 13 	brls	80003a7e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a5c:	30 09       	mov	r9,0
80003a5e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a60:	4c f7       	lddpc	r7,80003b9c <phy_rx_func+0xeb8>
80003a62:	6e 0c       	ld.w	r12,r7[0x0]
80003a64:	f0 1f 00 59 	mcall	80003bc8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a68:	4c b8       	lddpc	r8,80003b94 <phy_rx_func+0xeb0>
80003a6a:	70 0c       	ld.w	r12,r8[0x0]
80003a6c:	f0 1f 00 44 	mcall	80003b7c <phy_rx_func+0xe98>
80003a70:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a72:	c0 61       	brne	80003a7e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a74:	30 09       	mov	r9,0
80003a76:	4c b8       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003a78:	91 09       	st.w	r8[0x0],r9
80003a7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a7e:	4c b9       	lddpc	r9,80003ba8 <phy_rx_func+0xec4>
80003a80:	72 08       	ld.w	r8,r9[0x0]
80003a82:	20 18       	sub	r8,1
80003a84:	93 08       	st.w	r9[0x0],r8
80003a86:	c6 c1       	brne	80003b5e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a88:	30 09       	mov	r9,0
80003a8a:	4c 68       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003a8c:	91 09       	st.w	r8[0x0],r9
80003a8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a92:	30 09       	mov	r9,0
80003a94:	4c 38       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003a96:	91 09       	st.w	r8[0x0],r9
80003a98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a9c:	8e 4a       	ld.sh	r10,r7[0x8]
80003a9e:	4d 99       	lddpc	r9,80003c00 <phy_rx_func+0xf1c>
80003aa0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003aa4:	4d 6a       	lddpc	r10,80003bfc <phy_rx_func+0xf18>
80003aa6:	15 88       	ld.ub	r8,r10[0x0]
80003aa8:	f0 cb ff ff 	sub	r11,r8,-1
80003aac:	8e 5c       	ld.sh	r12,r7[0xa]
80003aae:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003ab2:	f0 cb ff fe 	sub	r11,r8,-2
80003ab6:	8e 6c       	ld.sh	r12,r7[0xc]
80003ab8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003abc:	f0 cb ff fd 	sub	r11,r8,-3
80003ac0:	8e 7c       	ld.sh	r12,r7[0xe]
80003ac2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003ac6:	2f c8       	sub	r8,-4
80003ac8:	b4 88       	st.b	r10[0x0],r8
80003aca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ace:	30 09       	mov	r9,0
80003ad0:	4b 48       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003ad2:	91 09       	st.w	r8[0x0],r9
80003ad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ad8:	4c 08       	lddpc	r8,80003bd8 <phy_rx_func+0xef4>
80003ada:	70 09       	ld.w	r9,r8[0x0]
80003adc:	8e 4b       	ld.sh	r11,r7[0x8]
80003ade:	4c 0a       	lddpc	r10,80003bdc <phy_rx_func+0xef8>
80003ae0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ae4:	2f f9       	sub	r9,-1
80003ae6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ae8:	4b 58       	lddpc	r8,80003bbc <phy_rx_func+0xed8>
80003aea:	70 09       	ld.w	r9,r8[0x0]
80003aec:	20 29       	sub	r9,2
80003aee:	91 09       	st.w	r8[0x0],r9
80003af0:	70 08       	ld.w	r8,r8[0x0]
80003af2:	58 08       	cp.w	r8,0
80003af4:	c2 f1       	brne	80003b52 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003af6:	30 09       	mov	r9,0
80003af8:	4b 88       	lddpc	r8,80003bd8 <phy_rx_func+0xef4>
80003afa:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003afc:	8e 59       	ld.sh	r9,r7[0xa]
80003afe:	fe 78 82 12 	mov	r8,-32238
80003b02:	f0 09 19 00 	cp.h	r9,r8
80003b06:	c2 11       	brne	80003b48 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003b08:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003b0c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b10:	4a f8       	lddpc	r8,80003bcc <phy_rx_func+0xee8>
80003b12:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003b14:	8e 59       	ld.sh	r9,r7[0xa]
80003b16:	4a f8       	lddpc	r8,80003bd0 <phy_rx_func+0xeec>
80003b18:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b1a:	8e 69       	ld.sh	r9,r7[0xc]
80003b1c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b1e:	f0 1f 00 2e 	mcall	80003bd4 <phy_rx_func+0xef0>
80003b22:	4a 18       	lddpc	r8,80003ba4 <phy_rx_func+0xec0>
80003b24:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b26:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b2a:	31 38       	mov	r8,19
80003b2c:	f0 09 18 00 	cp.b	r9,r8
80003b30:	c0 71       	brne	80003b3e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b32:	10 99       	mov	r9,r8
80003b34:	4a 18       	lddpc	r8,80003bb8 <phy_rx_func+0xed4>
80003b36:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b38:	30 09       	mov	r9,0
80003b3a:	49 c8       	lddpc	r8,80003ba8 <phy_rx_func+0xec4>
80003b3c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b3e:	30 49       	mov	r9,4
80003b40:	49 88       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003b42:	91 09       	st.w	r8[0x0],r9
80003b44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b48:	30 09       	mov	r9,0
80003b4a:	49 68       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003b4c:	91 09       	st.w	r8[0x0],r9
80003b4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b52:	4a dc       	lddpc	r12,80003c04 <phy_rx_func+0xf20>
80003b54:	f0 1f 00 18 	mcall	80003bb4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b58:	30 09       	mov	r9,0
80003b5a:	49 28       	lddpc	r8,80003ba0 <phy_rx_func+0xebc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b62:	00 00       	add	r0,r0
80003b64:	00 00       	add	r0,r0
80003b66:	0a ac       	st.w	r5++,r12
80003b68:	00 00       	add	r0,r0
80003b6a:	0a c4       	st.b	r5++,r4
80003b6c:	00 00       	add	r0,r0
80003b6e:	0a a4       	st.w	r5++,r4
80003b70:	00 00       	add	r0,r0
80003b72:	0a 86       	andn	r6,r5
80003b74:	00 00       	add	r0,r0
80003b76:	0a 74       	tst	r4,r5
80003b78:	00 00       	add	r0,r0
80003b7a:	0a 9c       	mov	r12,r5
80003b7c:	80 00       	ld.sh	r0,r0[0x0]
80003b7e:	2b 64       	sub	r4,-74
80003b80:	00 00       	add	r0,r0
80003b82:	0a 94       	mov	r4,r5
80003b84:	80 00       	ld.sh	r0,r0[0x0]
80003b86:	2a 7c       	sub	r12,-89
80003b88:	00 00       	add	r0,r0
80003b8a:	0a a8       	st.w	r5++,r8
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	2a b0       	sub	r0,-85
80003b90:	00 00       	add	r0,r0
80003b92:	0a 85       	andn	r5,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a a0       	st.w	r5++,r0
80003b98:	00 00       	add	r0,r0
80003b9a:	0a b0       	st.h	r5++,r0
80003b9c:	00 00       	add	r0,r0
80003b9e:	0a 88       	andn	r8,r5
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a d0       	st.w	--r5,r0
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a b8       	st.h	r5++,r8
80003ba8:	00 00       	add	r0,r0
80003baa:	0a 70       	tst	r0,r5
80003bac:	00 00       	add	r0,r0
80003bae:	0a 54       	eor	r4,r5
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	d5 c0       	acall	0x5c
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	6e c8       	ld.w	r8,r7[0x30]
80003bb8:	00 00       	add	r0,r0
80003bba:	0a 84       	andn	r4,r5
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a dc       	st.w	--r5,r12
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a bc       	st.h	r5++,r12
80003bc4:	80 00       	ld.sh	r0,r0[0x0]
80003bc6:	77 00       	ld.w	r0,r11[0x40]
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2a 98       	sub	r8,-87
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 48       	or	r8,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	1e a8       	st.w	pc++,r8
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	2a 4c       	sub	r12,-92
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 78       	tst	r8,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	1d ac       	ld.ub	r12,lr[0x2]
80003be0:	00 00       	add	r0,r0
80003be2:	0a 7c       	tst	r12,r5
80003be4:	00 00       	add	r0,r0
80003be6:	0a 49       	or	r9,r5
80003be8:	00 00       	add	r0,r0
80003bea:	0a 4c       	or	r12,r5
80003bec:	00 00       	add	r0,r0
80003bee:	0a d4       	st.w	--r5,r4
80003bf0:	00 00       	add	r0,r0
80003bf2:	0a 90       	mov	r0,r5
80003bf4:	00 00       	add	r0,r0
80003bf6:	0a 5c       	eor	r12,r5
80003bf8:	00 00       	add	r0,r0
80003bfa:	1d a4       	ld.ub	r4,lr[0x2]
80003bfc:	00 00       	add	r0,r0
80003bfe:	0a c8       	st.b	r5++,r8
80003c00:	00 00       	add	r0,r0
80003c02:	1e ac       	st.w	pc++,r12
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	d5 d8       	*unknown*

80003c08 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003c08:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003c0a:	49 a8       	lddpc	r8,80003c70 <pdca_int_handler+0x68>
80003c0c:	70 09       	ld.w	r9,r8[0x0]
80003c0e:	2f f9       	sub	r9,-1
80003c10:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c12:	49 98       	lddpc	r8,80003c74 <pdca_int_handler+0x6c>
80003c14:	11 89       	ld.ub	r9,r8[0x0]
80003c16:	ec 19 00 01 	eorl	r9,0x1
80003c1a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c1c:	11 89       	ld.ub	r9,r8[0x0]
80003c1e:	a5 69       	lsl	r9,0x4
80003c20:	2f c9       	sub	r9,-4
80003c22:	49 6a       	lddpc	r10,80003c78 <pdca_int_handler+0x70>
80003c24:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c26:	fe 7a 00 40 	mov	r10,-65472
80003c2a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c2c:	30 39       	mov	r9,3
80003c2e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c30:	11 8a       	ld.ub	r10,r8[0x0]
80003c32:	a5 6a       	lsl	r10,0x4
80003c34:	2f ca       	sub	r10,-4
80003c36:	49 28       	lddpc	r8,80003c7c <pdca_int_handler+0x74>
80003c38:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c3a:	fe 78 00 00 	mov	r8,-65536
80003c3e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c40:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c42:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c44:	48 f8       	lddpc	r8,80003c80 <pdca_int_handler+0x78>
80003c46:	70 08       	ld.w	r8,r8[0x0]
80003c48:	58 08       	cp.w	r8,0
80003c4a:	c0 70       	breq	80003c58 <pdca_int_handler+0x50>
80003c4c:	48 a9       	lddpc	r9,80003c74 <pdca_int_handler+0x6c>
80003c4e:	13 89       	ld.ub	r9,r9[0x0]
80003c50:	a5 69       	lsl	r9,0x4
80003c52:	48 bc       	lddpc	r12,80003c7c <pdca_int_handler+0x74>
80003c54:	12 0c       	add	r12,r9
80003c56:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c58:	48 b8       	lddpc	r8,80003c84 <pdca_int_handler+0x7c>
80003c5a:	70 08       	ld.w	r8,r8[0x0]
80003c5c:	58 08       	cp.w	r8,0
80003c5e:	c0 70       	breq	80003c6c <pdca_int_handler+0x64>
80003c60:	48 59       	lddpc	r9,80003c74 <pdca_int_handler+0x6c>
80003c62:	13 89       	ld.ub	r9,r9[0x0]
80003c64:	a5 69       	lsl	r9,0x4
80003c66:	48 5c       	lddpc	r12,80003c78 <pdca_int_handler+0x70>
80003c68:	12 0c       	add	r12,r9
80003c6a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c6c:	d4 02       	popm	lr
80003c6e:	d6 03       	rete
80003c70:	00 00       	add	r0,r0
80003c72:	0a e4       	st.h	--r5,r4
80003c74:	00 00       	add	r0,r0
80003c76:	50 cc       	stdsp	sp[0x30],r12
80003c78:	00 00       	add	r0,r0
80003c7a:	50 f4       	stdsp	sp[0x3c],r4
80003c7c:	00 00       	add	r0,r0
80003c7e:	50 d4       	stdsp	sp[0x34],r4
80003c80:	00 00       	add	r0,r0
80003c82:	0a e0       	st.h	--r5,r0
80003c84:	00 00       	add	r0,r0
80003c86:	0a e8       	st.h	--r5,r8

80003c88 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c88:	fe 78 10 00 	mov	r8,-61440
80003c8c:	e0 69 0d c0 	mov	r9,3520
80003c90:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c94:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c98:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c9c:	fe 78 34 00 	mov	r8,-52224
80003ca0:	e0 69 80 00 	mov	r9,32768
80003ca4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003ca6:	30 09       	mov	r9,0
80003ca8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003caa:	e0 69 04 21 	mov	r9,1057
80003cae:	ea 19 3f 20 	orh	r9,0x3f20
80003cb2:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003cb4:	e0 69 02 9f 	mov	r9,671
80003cb8:	ea 19 01 00 	orh	r9,0x100
80003cbc:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003cbe:	e0 6a 04 02 	mov	r10,1026
80003cc2:	ea 1a 3f 20 	orh	r10,0x3f20
80003cc6:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003cc8:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cca:	5e fc       	retal	r12

80003ccc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003ccc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cce:	30 19       	mov	r9,1
80003cd0:	49 78       	lddpc	r8,80003d2c <local_start_PDC+0x60>
80003cd2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cd4:	fe 78 00 00 	mov	r8,-65536
80003cd8:	30 7b       	mov	r11,7
80003cda:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cdc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cde:	49 59       	lddpc	r9,80003d30 <local_start_PDC+0x64>
80003ce0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ce4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003ce6:	30 3a       	mov	r10,3
80003ce8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cea:	30 1c       	mov	r12,1
80003cec:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003cee:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003cf0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cf2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003cf4:	30 2c       	mov	r12,2
80003cf6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003cf8:	48 f9       	lddpc	r9,80003d34 <local_start_PDC+0x68>
80003cfa:	e0 68 5a 5a 	mov	r8,23130
80003cfe:	ea 18 ab cd 	orh	r8,0xabcd
80003d02:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003d04:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003d06:	30 0e       	mov	lr,0
80003d08:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003d0a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003d0c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003d0e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d10:	fe 78 00 40 	mov	r8,-65472
80003d14:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d16:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d18:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d1c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d1e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d20:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d22:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d24:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d26:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d28:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d2a:	d8 02       	popm	pc
80003d2c:	00 00       	add	r0,r0
80003d2e:	50 cc       	stdsp	sp[0x30],r12
80003d30:	00 00       	add	r0,r0
80003d32:	50 d4       	stdsp	sp[0x34],r4
80003d34:	00 00       	add	r0,r0
80003d36:	50 f4       	stdsp	sp[0x3c],r4

80003d38 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d38:	48 38       	lddpc	r8,80003d44 <register_rx_tx_func+0xc>
80003d3a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d3c:	48 38       	lddpc	r8,80003d48 <register_rx_tx_func+0x10>
80003d3e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d40:	5e fc       	retal	r12
80003d42:	00 00       	add	r0,r0
80003d44:	00 00       	add	r0,r0
80003d46:	0a e0       	st.h	--r5,r0
80003d48:	00 00       	add	r0,r0
80003d4a:	0a e8       	st.h	--r5,r8

80003d4c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d4c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d4e:	fe 78 10 00 	mov	r8,-61440
80003d52:	30 29       	mov	r9,2
80003d54:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d58:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d5c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d5e:	30 3a       	mov	r10,3
80003d60:	36 0b       	mov	r11,96
80003d62:	49 4c       	lddpc	r12,80003db0 <ssc_init+0x64>
80003d64:	f0 1f 00 14 	mcall	80003db4 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003d68:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d6a:	fe 79 10 00 	mov	r9,-61440
80003d6e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d72:	e2 18 00 02 	andl	r8,0x2,COH
80003d76:	cf c0       	breq	80003d6e <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d78:	fe 79 10 00 	mov	r9,-61440
80003d7c:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d80:	e2 18 00 02 	andl	r8,0x2,COH
80003d84:	cf c1       	brne	80003d7c <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003d86:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003d88:	f0 1f 00 0c 	mcall	80003db8 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003d8c:	f0 1f 00 0c 	mcall	80003dbc <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d90:	fe 79 00 00 	mov	r9,-65536
80003d94:	30 18       	mov	r8,1
80003d96:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d98:	fe 7a 00 40 	mov	r10,-65472
80003d9c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d9e:	e0 6b 01 01 	mov	r11,257
80003da2:	fe 7a 34 00 	mov	r10,-52224
80003da6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003da8:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003daa:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003dac:	d8 02       	popm	pc
80003dae:	00 00       	add	r0,r0
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	3c 08       	mov	r8,-64
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	53 6c       	stdsp	sp[0xd8],r12
80003db8:	80 00       	ld.sh	r0,r0[0x0]
80003dba:	3c 88       	mov	r8,-56
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	3c cc       	mov	r12,-52

80003dc0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003dc0:	48 28       	lddpc	r8,80003dc8 <xcmp_register_app_list+0x8>
80003dc2:	91 0c       	st.w	r8[0x0],r12
}
80003dc4:	5e fc       	retal	r12
80003dc6:	00 00       	add	r0,r0
80003dc8:	00 00       	add	r0,r0
80003dca:	51 14       	stdsp	sp[0x44],r4

80003dcc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003dcc:	eb cd 40 80 	pushm	r7,lr
80003dd0:	fa cd 01 00 	sub	sp,sp,256
80003dd4:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dd6:	16 98       	mov	r8,r11
80003dd8:	2f 08       	sub	r8,-16
80003dda:	af a8       	sbr	r8,0xe
80003ddc:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dde:	3f f8       	mov	r8,-1
80003de0:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003de2:	30 b9       	mov	r9,11
80003de4:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003de6:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003de8:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dea:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003dec:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003dee:	f6 ca ff fe 	sub	r10,r11,-2
80003df2:	18 9b       	mov	r11,r12
80003df4:	fa cc ff f0 	sub	r12,sp,-16
80003df8:	f0 1f 00 05 	mcall	80003e0c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003dfc:	2f e7       	sub	r7,-2
80003dfe:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003e00:	1a 9c       	mov	r12,sp
80003e02:	f0 1f 00 04 	mcall	80003e10 <xcmp_tx+0x44>
}
80003e06:	2c 0d       	sub	sp,-256
80003e08:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e0c:	80 00       	ld.sh	r0,r0[0x0]
80003e0e:	75 b8       	ld.w	r8,r10[0x6c]
80003e10:	80 00       	ld.sh	r0,r0[0x0]
80003e12:	43 d8       	lddsp	r8,sp[0xf4]

80003e14 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003e14:	d4 21       	pushm	r4-r7,lr
80003e16:	fa cd 00 d0 	sub	sp,sp,208
80003e1a:	18 94       	mov	r4,r12
80003e1c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e1e:	e0 68 01 00 	mov	r8,256
80003e22:	f0 0b 19 00 	cp.h	r11,r8
80003e26:	e0 8b 00 36 	brhi	80003e92 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e2a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e2e:	e0 68 04 1d 	mov	r8,1053
80003e32:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e34:	30 18       	mov	r8,1
80003e36:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e38:	32 08       	mov	r8,32
80003e3a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e3c:	30 28       	mov	r8,2
80003e3e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e40:	30 48       	mov	r8,4
80003e42:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e44:	ea 1a 0c 00 	orh	r10,0xc00
80003e48:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e4a:	30 4a       	mov	r10,4
80003e4c:	1a 9b       	mov	r11,sp
80003e4e:	fa cc ff f4 	sub	r12,sp,-12
80003e52:	f0 1f 00 12 	mcall	80003e98 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e56:	30 f8       	mov	r8,15
80003e58:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e5c:	3a 78       	mov	r8,-89
80003e5e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e62:	30 08       	mov	r8,0
80003e64:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e68:	0e 9a       	mov	r10,r7
80003e6a:	5c 7a       	castu.h	r10
80003e6c:	f4 08 16 08 	lsr	r8,r10,0x8
80003e70:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e74:	0e 96       	mov	r6,r7
80003e76:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e7a:	08 9b       	mov	r11,r4
80003e7c:	fa cc ff eb 	sub	r12,sp,-21
80003e80:	f0 1f 00 06 	mcall	80003e98 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e84:	ee cb ff f3 	sub	r11,r7,-13
80003e88:	5c 5b       	castu.b	r11
80003e8a:	fa cc ff fa 	sub	r12,sp,-6
80003e8e:	f0 1f 00 04 	mcall	80003e9c <xcmp_data_session_req+0x88>
}
80003e92:	2c cd       	sub	sp,-208
80003e94:	d8 22       	popm	r4-r7,pc
80003e96:	00 00       	add	r0,r0
80003e98:	80 00       	ld.sh	r0,r0[0x0]
80003e9a:	75 b8       	ld.w	r8,r10[0x6c]
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	3d cc       	mov	r12,-36

80003ea0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003ea0:	d4 01       	pushm	lr
80003ea2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ea6:	fe 78 b4 00 	mov	r8,-19456
80003eaa:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003eac:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003eb0:	30 89       	mov	r9,8
80003eb2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003eb4:	30 19       	mov	r9,1
80003eb6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003eb8:	30 09       	mov	r9,0
80003eba:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003ebc:	30 5a       	mov	r10,5
80003ebe:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003ec0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003ec2:	30 7a       	mov	r10,7
80003ec4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ec6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ec8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003eca:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ece:	30 9b       	mov	r11,9
80003ed0:	fa cc ff fe 	sub	r12,sp,-2
80003ed4:	f0 1f 00 02 	mcall	80003edc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ed8:	2c dd       	sub	sp,-204
80003eda:	d8 02       	popm	pc
80003edc:	80 00       	ld.sh	r0,r0[0x0]
80003ede:	3d cc       	mov	r12,-36

80003ee0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ee0:	d4 01       	pushm	lr
80003ee2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003ee6:	fe 78 80 00 	mov	r8,-32768
80003eea:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003eec:	30 38       	mov	r8,3
80003eee:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ef0:	30 1b       	mov	r11,1
80003ef2:	fa cc ff fe 	sub	r12,sp,-2
80003ef6:	f0 1f 00 03 	mcall	80003f00 <xcmp_opcode_not_supported+0x20>
}
80003efa:	2c dd       	sub	sp,-204
80003efc:	d8 02       	popm	pc
80003efe:	00 00       	add	r0,r0
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	3d cc       	mov	r12,-36

80003f04 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f04:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f06:	96 88       	ld.uh	r8,r11[0x0]
80003f08:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f0c:	e0 48 80 00 	cp.w	r8,32768
80003f10:	c0 f0       	breq	80003f2e <xcmp_exec_func+0x2a>
80003f12:	e0 48 b0 00 	cp.w	r8,45056
80003f16:	c1 20       	breq	80003f3a <xcmp_exec_func+0x36>
80003f18:	58 08       	cp.w	r8,0
80003f1a:	c1 51       	brne	80003f44 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f1c:	78 08       	ld.w	r8,r12[0x0]
80003f1e:	58 08       	cp.w	r8,0
80003f20:	c0 40       	breq	80003f28 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f22:	16 9c       	mov	r12,r11
80003f24:	5d 18       	icall	r8
80003f26:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f28:	f0 1f 00 08 	mcall	80003f48 <xcmp_exec_func+0x44>
80003f2c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f2e:	78 18       	ld.w	r8,r12[0x4]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 90       	breq	80003f44 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f34:	16 9c       	mov	r12,r11
80003f36:	5d 18       	icall	r8
80003f38:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f3a:	78 28       	ld.w	r8,r12[0x8]
80003f3c:	58 08       	cp.w	r8,0
80003f3e:	c0 30       	breq	80003f44 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f40:	16 9c       	mov	r12,r11
80003f42:	5d 18       	icall	r8
80003f44:	d8 02       	popm	pc
80003f46:	00 00       	add	r0,r0
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	3e e0       	mov	r0,-18

80003f4c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f4c:	d4 01       	pushm	lr
80003f4e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f52:	e0 68 04 09 	mov	r8,1033
80003f56:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f58:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f5c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f5e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f62:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f64:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f66:	30 09       	mov	r9,0
80003f68:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f6a:	fb 69 00 08 	st.b	sp[8],r9
80003f6e:	fa c8 ff f7 	sub	r8,sp,-9
80003f72:	b0 89       	st.b	r8[0x0],r9
80003f74:	fa c8 ff f6 	sub	r8,sp,-10
80003f78:	b0 89       	st.b	r8[0x0],r9
80003f7a:	fa c8 ff f5 	sub	r8,sp,-11
80003f7e:	b0 89       	st.b	r8[0x0],r9
80003f80:	fa c8 ff f4 	sub	r8,sp,-12
80003f84:	b0 89       	st.b	r8[0x0],r9
80003f86:	fa c8 ff f3 	sub	r8,sp,-13
80003f8a:	b0 89       	st.b	r8[0x0],r9
80003f8c:	fa c8 ff f2 	sub	r8,sp,-14
80003f90:	b0 89       	st.b	r8[0x0],r9
80003f92:	fa c8 ff f1 	sub	r8,sp,-15
80003f96:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f98:	30 cb       	mov	r11,12
80003f9a:	fa cc ff fe 	sub	r12,sp,-2
80003f9e:	f0 1f 00 03 	mcall	80003fa8 <xcmp_IdleTestTone+0x5c>
}
80003fa2:	2c dd       	sub	sp,-204
80003fa4:	d8 02       	popm	pc
80003fa6:	00 00       	add	r0,r0
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	3d cc       	mov	r12,-36

80003fac <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fac:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fae:	48 dc       	lddpc	r12,80003fe0 <xcmp_init+0x34>
80003fb0:	f0 1f 00 0d 	mcall	80003fe4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fb4:	30 4b       	mov	r11,4
80003fb6:	31 4c       	mov	r12,20
80003fb8:	f0 1f 00 0c 	mcall	80003fe8 <xcmp_init+0x3c>
80003fbc:	48 c8       	lddpc	r8,80003fec <xcmp_init+0x40>
80003fbe:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fc0:	30 09       	mov	r9,0
80003fc2:	1a d9       	st.w	--sp,r9
80003fc4:	1a d9       	st.w	--sp,r9
80003fc6:	1a d9       	st.w	--sp,r9
80003fc8:	30 38       	mov	r8,3
80003fca:	e0 6a 04 00 	mov	r10,1024
80003fce:	48 9b       	lddpc	r11,80003ff0 <xcmp_init+0x44>
80003fd0:	48 9c       	lddpc	r12,80003ff4 <xcmp_init+0x48>
80003fd2:	f0 1f 00 0a 	mcall	80003ff8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003fd6:	f0 1f 00 0a 	mcall	80003ffc <xcmp_init+0x50>
80003fda:	2f dd       	sub	sp,-12
	
}
80003fdc:	d8 02       	popm	pc
80003fde:	00 00       	add	r0,r0
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	40 fc       	lddsp	r12,sp[0x3c]
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	41 48       	lddsp	r8,sp[0x50]
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	62 5c       	ld.w	r12,r1[0x14]
80003fec:	00 00       	add	r0,r0
80003fee:	0b 04       	ld.w	r4,r5++
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	d6 04       	*unknown*
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	40 00       	lddsp	r0,sp[0x0]
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	69 78       	ld.w	r8,r4[0x5c]
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	41 80       	lddsp	r0,sp[0x60]

80004000 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004000:	d4 31       	pushm	r0-r7,lr
80004002:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004004:	4b 16       	lddpc	r6,800040c8 <xcmp_rx_process+0xc8>
80004006:	30 05       	mov	r5,0
80004008:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000400a:	4b 13       	lddpc	r3,800040cc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000400c:	4b 12       	lddpc	r2,800040d0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000400e:	4b 21       	lddpc	r1,800040d4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004010:	4b 20       	lddpc	r0,800040d8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004012:	6c 0c       	ld.w	r12,r6[0x0]
80004014:	0a 99       	mov	r9,r5
80004016:	08 9a       	mov	r10,r4
80004018:	1a 9b       	mov	r11,sp
8000401a:	f0 1f 00 31 	mcall	800040dc <xcmp_rx_process+0xdc>
8000401e:	58 1c       	cp.w	r12,1
80004020:	cf 91       	brne	80004012 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004022:	40 0b       	lddsp	r11,sp[0x0]
80004024:	58 0b       	cp.w	r11,0
80004026:	cf 60       	breq	80004012 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004028:	96 0a       	ld.sh	r10,r11[0x0]
8000402a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000402e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004032:	59 c8       	cp.w	r8,28
80004034:	c1 e0       	breq	80004070 <xcmp_rx_process+0x70>
80004036:	e0 89 00 07 	brgt	80004044 <xcmp_rx_process+0x44>
8000403a:	58 e8       	cp.w	r8,14
8000403c:	c0 e0       	breq	80004058 <xcmp_rx_process+0x58>
8000403e:	58 f8       	cp.w	r8,15
80004040:	c2 41       	brne	80004088 <xcmp_rx_process+0x88>
80004042:	c0 f8       	rjmp	80004060 <xcmp_rx_process+0x60>
80004044:	e0 48 01 09 	cp.w	r8,265
80004048:	c1 80       	breq	80004078 <xcmp_rx_process+0x78>
8000404a:	e0 48 01 0a 	cp.w	r8,266
8000404e:	c1 90       	breq	80004080 <xcmp_rx_process+0x80>
80004050:	e0 48 00 2c 	cp.w	r8,44
80004054:	c1 a1       	brne	80004088 <xcmp_rx_process+0x88>
80004056:	c0 98       	rjmp	80004068 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004058:	4a 2c       	lddpc	r12,800040e0 <xcmp_rx_process+0xe0>
8000405a:	f0 1f 00 23 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000405e:	c2 f8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004060:	4a 2c       	lddpc	r12,800040e8 <xcmp_rx_process+0xe8>
80004062:	f0 1f 00 21 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
80004066:	c2 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004068:	4a 1c       	lddpc	r12,800040ec <xcmp_rx_process+0xec>
8000406a:	f0 1f 00 1f 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000406e:	c2 78       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004070:	04 9c       	mov	r12,r2
80004072:	f0 1f 00 1d 	mcall	800040e4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004076:	c2 38       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004078:	02 9c       	mov	r12,r1
8000407a:	f0 1f 00 1b 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000407e:	c1 f8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004080:	00 9c       	mov	r12,r0
80004082:	f0 1f 00 19 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
80004086:	c1 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004088:	12 98       	mov	r8,r9
8000408a:	e2 18 04 00 	andl	r8,0x400,COH
8000408e:	c0 70       	breq	8000409c <xcmp_rx_process+0x9c>
80004090:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004094:	e0 48 00 68 	cp.w	r8,104
80004098:	e0 8a 00 08 	brle	800040a8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000409c:	e2 19 f0 00 	andl	r9,0xf000,COH
800040a0:	c0 e1       	brne	800040bc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800040a2:	f0 1f 00 14 	mcall	800040f0 <xcmp_rx_process+0xf0>
800040a6:	c0 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800040a8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040ac:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040b0:	49 19       	lddpc	r9,800040f4 <xcmp_rx_process+0xf4>
800040b2:	72 08       	ld.w	r8,r9[0x0]
800040b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040b8:	f0 1f 00 0b 	mcall	800040e4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040bc:	66 0c       	ld.w	r12,r3[0x0]
800040be:	40 0b       	lddsp	r11,sp[0x0]
800040c0:	f0 1f 00 0e 	mcall	800040f8 <xcmp_rx_process+0xf8>
800040c4:	ca 7b       	rjmp	80004012 <xcmp_rx_process+0x12>
800040c6:	00 00       	add	r0,r0
800040c8:	00 00       	add	r0,r0
800040ca:	0b 04       	ld.w	r4,r5++
800040cc:	00 00       	add	r0,r0
800040ce:	0a 9c       	mov	r12,r5
800040d0:	00 00       	add	r0,r0
800040d2:	0b 14       	ld.sh	r4,r5++
800040d4:	00 00       	add	r0,r0
800040d6:	0b 08       	ld.w	r8,r5++
800040d8:	00 00       	add	r0,r0
800040da:	0a f8       	st.b	--r5,r8
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	5f 50       	srlt	r0
800040e0:	00 00       	add	r0,r0
800040e2:	0b 2c       	ld.uh	r12,r5++
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3f 04       	mov	r4,-16
800040e8:	00 00       	add	r0,r0
800040ea:	0a ec       	st.h	--r5,r12
800040ec:	00 00       	add	r0,r0
800040ee:	0b 20       	ld.uh	r0,r5++
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	3e e0       	mov	r0,-18
800040f4:	00 00       	add	r0,r0
800040f6:	51 14       	stdsp	sp[0x44],r4
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	2a e8       	sub	r8,-82

800040fc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040fc:	eb cd 40 90 	pushm	r4,r7,lr
80004100:	20 1d       	sub	sp,4
80004102:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004106:	48 c8       	lddpc	r8,80004134 <xcmp_rx+0x38>
80004108:	70 0c       	ld.w	r12,r8[0x0]
8000410a:	f0 1f 00 0c 	mcall	80004138 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000410e:	c1 00       	breq	8000412e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004110:	fa c7 ff fc 	sub	r7,sp,-4
80004114:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004116:	e0 6a 00 ca 	mov	r10,202
8000411a:	08 9b       	mov	r11,r4
8000411c:	f0 1f 00 08 	mcall	8000413c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004120:	48 88       	lddpc	r8,80004140 <xcmp_rx+0x44>
80004122:	70 0c       	ld.w	r12,r8[0x0]
80004124:	30 09       	mov	r9,0
80004126:	12 9a       	mov	r10,r9
80004128:	1a 9b       	mov	r11,sp
8000412a:	f0 1f 00 07 	mcall	80004144 <xcmp_rx+0x48>
	}	
}
8000412e:	2f fd       	sub	sp,-4
80004130:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004134:	00 00       	add	r0,r0
80004136:	0a 9c       	mov	r12,r5
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	2c 94       	sub	r4,-55
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	75 b8       	ld.w	r8,r10[0x6c]
80004140:	00 00       	add	r0,r0
80004142:	0b 04       	ld.w	r4,r5++
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	61 5c       	ld.w	r12,r0[0x54]

80004148 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004148:	48 28       	lddpc	r8,80004150 <xnl_register_xcmp_func+0x8>
8000414a:	91 0c       	st.w	r8[0x0],r12
}
8000414c:	5e fc       	retal	r12
8000414e:	00 00       	add	r0,r0
80004150:	00 00       	add	r0,r0
80004152:	0b 58       	ld.sh	r8,--r5

80004154 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004154:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004156:	48 88       	lddpc	r8,80004174 <xnl_get_msg_ack_func+0x20>
80004158:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000415a:	98 49       	ld.sh	r9,r12[0x8]
8000415c:	f0 09 19 00 	cp.h	r9,r8
80004160:	c0 81       	brne	80004170 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004162:	48 68       	lddpc	r8,80004178 <xnl_get_msg_ack_func+0x24>
80004164:	70 0c       	ld.w	r12,r8[0x0]
80004166:	30 09       	mov	r9,0
80004168:	12 9a       	mov	r10,r9
8000416a:	12 9b       	mov	r11,r9
8000416c:	f0 1f 00 04 	mcall	8000417c <xnl_get_msg_ack_func+0x28>
80004170:	d8 02       	popm	pc
80004172:	00 00       	add	r0,r0
80004174:	00 00       	add	r0,r0
80004176:	0b 3e       	ld.ub	lr,r5++
80004178:	00 00       	add	r0,r0
8000417a:	0b 38       	ld.ub	r8,r5++
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	61 5c       	ld.w	r12,r0[0x54]

80004180 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004180:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004184:	30 09       	mov	r9,0
80004186:	4b 78       	lddpc	r8,80004260 <xnl_init+0xe0>
80004188:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000418a:	30 0b       	mov	r11,0
8000418c:	30 1c       	mov	r12,1
8000418e:	f0 1f 00 36 	mcall	80004264 <xnl_init+0xe4>
80004192:	4b 68       	lddpc	r8,80004268 <xnl_init+0xe8>
80004194:	91 0c       	st.w	r8[0x0],r12
80004196:	70 08       	ld.w	r8,r8[0x0]
80004198:	58 08       	cp.w	r8,0
8000419a:	c0 80       	breq	800041aa <xnl_init+0x2a>
8000419c:	4b 38       	lddpc	r8,80004268 <xnl_init+0xe8>
8000419e:	70 0c       	ld.w	r12,r8[0x0]
800041a0:	30 09       	mov	r9,0
800041a2:	12 9a       	mov	r10,r9
800041a4:	12 9b       	mov	r11,r9
800041a6:	f0 1f 00 32 	mcall	8000426c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800041aa:	30 4b       	mov	r11,4
800041ac:	31 4c       	mov	r12,20
800041ae:	f0 1f 00 2e 	mcall	80004264 <xnl_init+0xe4>
800041b2:	4b 08       	lddpc	r8,80004270 <xnl_init+0xf0>
800041b4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041b6:	30 4b       	mov	r11,4
800041b8:	31 ec       	mov	r12,30
800041ba:	f0 1f 00 2b 	mcall	80004264 <xnl_init+0xe4>
800041be:	4a e8       	lddpc	r8,80004274 <xnl_init+0xf4>
800041c0:	91 0c       	st.w	r8[0x0],r12
800041c2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800041c4:	10 96       	mov	r6,r8
800041c6:	4a d5       	lddpc	r5,80004278 <xnl_init+0xf8>
800041c8:	6c 0c       	ld.w	r12,r6[0x0]
800041ca:	ea 07 00 0b 	add	r11,r5,r7
800041ce:	f0 1f 00 2c 	mcall	8000427c <xnl_init+0xfc>
800041d2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800041d6:	e0 47 1e 00 	cp.w	r7,7680
800041da:	cf 71       	brne	800041c8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041dc:	30 4b       	mov	r11,4
800041de:	31 4c       	mov	r12,20
800041e0:	f0 1f 00 21 	mcall	80004264 <xnl_init+0xe4>
800041e4:	4a 78       	lddpc	r8,80004280 <xnl_init+0x100>
800041e6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041e8:	30 4b       	mov	r11,4
800041ea:	30 ac       	mov	r12,10
800041ec:	f0 1f 00 1e 	mcall	80004264 <xnl_init+0xe4>
800041f0:	4a 58       	lddpc	r8,80004284 <xnl_init+0x104>
800041f2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041f4:	30 4b       	mov	r11,4
800041f6:	30 ac       	mov	r12,10
800041f8:	f0 1f 00 1b 	mcall	80004264 <xnl_init+0xe4>
800041fc:	4a 38       	lddpc	r8,80004288 <xnl_init+0x108>
800041fe:	91 0c       	st.w	r8[0x0],r12
80004200:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004202:	10 96       	mov	r6,r8
80004204:	4a 25       	lddpc	r5,8000428c <xnl_init+0x10c>
80004206:	6c 0c       	ld.w	r12,r6[0x0]
80004208:	ea 07 00 0b 	add	r11,r5,r7
8000420c:	f0 1f 00 1c 	mcall	8000427c <xnl_init+0xfc>
80004210:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004214:	e0 47 14 00 	cp.w	r7,5120
80004218:	cf 71       	brne	80004206 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000421a:	30 4b       	mov	r11,4
8000421c:	30 5c       	mov	r12,5
8000421e:	f0 1f 00 12 	mcall	80004264 <xnl_init+0xe4>
80004222:	49 c8       	lddpc	r8,80004290 <xnl_init+0x110>
80004224:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004226:	30 07       	mov	r7,0
80004228:	1a d7       	st.w	--sp,r7
8000422a:	1a d7       	st.w	--sp,r7
8000422c:	1a d7       	st.w	--sp,r7
8000422e:	30 38       	mov	r8,3
80004230:	0e 99       	mov	r9,r7
80004232:	e0 6a 00 dc 	mov	r10,220
80004236:	49 8b       	lddpc	r11,80004294 <xnl_init+0x114>
80004238:	49 8c       	lddpc	r12,80004298 <xnl_init+0x118>
8000423a:	f0 1f 00 19 	mcall	8000429c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000423e:	1a d7       	st.w	--sp,r7
80004240:	1a d7       	st.w	--sp,r7
80004242:	1a d7       	st.w	--sp,r7
80004244:	30 38       	mov	r8,3
80004246:	0e 99       	mov	r9,r7
80004248:	e0 6a 00 82 	mov	r10,130
8000424c:	49 5b       	lddpc	r11,800042a0 <xnl_init+0x120>
8000424e:	49 6c       	lddpc	r12,800042a4 <xnl_init+0x124>
80004250:	f0 1f 00 13 	mcall	8000429c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004254:	f0 1f 00 15 	mcall	800042a8 <xnl_init+0x128>
80004258:	2f ad       	sub	sp,-24
}
8000425a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000425e:	00 00       	add	r0,r0
80004260:	00 00       	add	r0,r0
80004262:	0b 3e       	ld.ub	lr,r5++
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	62 5c       	ld.w	r12,r1[0x14]
80004268:	00 00       	add	r0,r0
8000426a:	0b 38       	ld.ub	r8,r5++
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	61 5c       	ld.w	r12,r0[0x54]
80004270:	00 00       	add	r0,r0
80004272:	0b 4c       	ld.w	r12,--r5
80004274:	00 00       	add	r0,r0
80004276:	0a 9c       	mov	r12,r5
80004278:	00 00       	add	r0,r0
8000427a:	32 c6       	mov	r6,44
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	2a e8       	sub	r8,-82
80004280:	00 00       	add	r0,r0
80004282:	0a cc       	st.b	r5++,r12
80004284:	00 00       	add	r0,r0
80004286:	0a ac       	st.w	r5++,r12
80004288:	00 00       	add	r0,r0
8000428a:	0a a0       	st.w	r5++,r0
8000428c:	00 00       	add	r0,r0
8000428e:	1e c6       	st.b	pc++,r6
80004290:	00 00       	add	r0,r0
80004292:	0a d8       	st.w	--r5,r8
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	d6 0c       	*unknown*
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	42 ac       	lddsp	r12,sp[0xa8]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	69 78       	ld.w	r8,r4[0x5c]
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	d6 14       	*unknown*
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	43 0c       	lddsp	r12,sp[0xc0]
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	2c bc       	sub	r12,-53

800042ac <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042ac:	eb cd 40 fe 	pushm	r1-r7,lr
800042b0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042b2:	49 26       	lddpc	r6,800042f8 <xnl_rx_process+0x4c>
800042b4:	30 05       	mov	r5,0
800042b6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042b8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ba:	49 11       	lddpc	r1,800042fc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042bc:	49 12       	lddpc	r2,80004300 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042be:	6c 0c       	ld.w	r12,r6[0x0]
800042c0:	0a 99       	mov	r9,r5
800042c2:	08 9a       	mov	r10,r4
800042c4:	1a 9b       	mov	r11,sp
800042c6:	f0 1f 00 10 	mcall	80004304 <xnl_rx_process+0x58>
800042ca:	58 1c       	cp.w	r12,1
800042cc:	cf 91       	brne	800042be <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042ce:	40 0c       	lddsp	r12,sp[0x0]
800042d0:	58 0c       	cp.w	r12,0
800042d2:	cf 60       	breq	800042be <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042d4:	98 28       	ld.sh	r8,r12[0x4]
800042d6:	e6 08 19 00 	cp.h	r8,r3
800042da:	e0 8b 00 0a 	brhi	800042ee <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042de:	5c 78       	castu.h	r8
800042e0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042e4:	58 09       	cp.w	r9,0
800042e6:	c0 40       	breq	800042ee <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042e8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042ec:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ee:	62 0c       	ld.w	r12,r1[0x0]
800042f0:	40 0b       	lddsp	r11,sp[0x0]
800042f2:	f0 1f 00 06 	mcall	80004308 <xnl_rx_process+0x5c>
800042f6:	ce 4b       	rjmp	800042be <xnl_rx_process+0x12>
800042f8:	00 00       	add	r0,r0
800042fa:	0a ac       	st.w	r5++,r12
800042fc:	00 00       	add	r0,r0
800042fe:	0a 9c       	mov	r12,r5
80004300:	00 00       	add	r0,r0
80004302:	04 f4       	st.b	--r2,r4
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	5f 50       	srlt	r0
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	2a e8       	sub	r8,-82

8000430c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000430c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000430e:	4a a6       	lddpc	r6,800043b4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004310:	4a a2       	lddpc	r2,800043b8 <xnl_tx_process+0xac>
80004312:	4a b4       	lddpc	r4,800043bc <xnl_tx_process+0xb0>
80004314:	30 07       	mov	r7,0
80004316:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004318:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000431a:	4a a5       	lddpc	r5,800043c0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000431c:	4a a3       	lddpc	r3,800043c4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000431e:	6c 08       	ld.w	r8,r6[0x0]
80004320:	58 08       	cp.w	r8,0
80004322:	c0 40       	breq	8000432a <xnl_tx_process+0x1e>
80004324:	58 18       	cp.w	r8,1
80004326:	cf d1       	brne	80004320 <xnl_tx_process+0x14>
80004328:	c2 48       	rjmp	80004370 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000432a:	64 0c       	ld.w	r12,r2[0x0]
8000432c:	0e 99       	mov	r9,r7
8000432e:	02 9a       	mov	r10,r1
80004330:	08 9b       	mov	r11,r4
80004332:	f0 1f 00 26 	mcall	800043c8 <xnl_tx_process+0xbc>
80004336:	58 1c       	cp.w	r12,1
80004338:	cf 31       	brne	8000431e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000433a:	68 0b       	ld.w	r11,r4[0x0]
8000433c:	58 0b       	cp.w	r11,0
8000433e:	cf 00       	breq	8000431e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004340:	96 28       	ld.sh	r8,r11[0x4]
80004342:	e0 08 19 00 	cp.h	r8,r0
80004346:	c0 71       	brne	80004354 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004348:	4a 18       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
8000434a:	70 08       	ld.w	r8,r8[0x0]
8000434c:	10 9c       	mov	r12,r8
8000434e:	f0 1f 00 21 	mcall	800043d0 <xnl_tx_process+0xc4>
						break;
80004352:	ce 6b       	rjmp	8000431e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004354:	16 9c       	mov	r12,r11
80004356:	f0 1f 00 20 	mcall	800043d4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000435a:	30 18       	mov	r8,1
8000435c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000435e:	66 0c       	ld.w	r12,r3[0x0]
80004360:	0e 99       	mov	r9,r7
80004362:	0e 9a       	mov	r10,r7
80004364:	0e 9b       	mov	r11,r7
80004366:	f0 1f 00 19 	mcall	800043c8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000436a:	30 18       	mov	r8,1
8000436c:	8d 08       	st.w	r6[0x0],r8
8000436e:	cd 8b       	rjmp	8000431e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004370:	66 0c       	ld.w	r12,r3[0x0]
80004372:	0e 99       	mov	r9,r7
80004374:	36 4a       	mov	r10,100
80004376:	0e 9b       	mov	r11,r7
80004378:	f0 1f 00 14 	mcall	800043c8 <xnl_tx_process+0xbc>
8000437c:	58 1c       	cp.w	r12,1
8000437e:	c0 81       	brne	8000438e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004380:	49 38       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
80004382:	70 0c       	ld.w	r12,r8[0x0]
80004384:	68 0b       	ld.w	r11,r4[0x0]
80004386:	f0 1f 00 13 	mcall	800043d0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000438a:	8d 07       	st.w	r6[0x0],r7
8000438c:	cc 9b       	rjmp	8000431e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000438e:	6a 08       	ld.w	r8,r5[0x0]
80004390:	58 38       	cp.w	r8,3
80004392:	e0 89 00 09 	brgt	800043a4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004396:	68 0c       	ld.w	r12,r4[0x0]
80004398:	f0 1f 00 0f 	mcall	800043d4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000439c:	6a 08       	ld.w	r8,r5[0x0]
8000439e:	2f f8       	sub	r8,-1
800043a0:	8b 08       	st.w	r5[0x0],r8
800043a2:	cb eb       	rjmp	8000431e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800043a4:	48 a8       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
800043a6:	70 0c       	ld.w	r12,r8[0x0]
800043a8:	68 0b       	ld.w	r11,r4[0x0]
800043aa:	f0 1f 00 0a 	mcall	800043d0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043ae:	8d 07       	st.w	r6[0x0],r7
800043b0:	cb 7b       	rjmp	8000431e <xnl_tx_process+0x12>
800043b2:	00 00       	add	r0,r0
800043b4:	00 00       	add	r0,r0
800043b6:	0b 48       	ld.w	r8,--r5
800043b8:	00 00       	add	r0,r0
800043ba:	0b 4c       	ld.w	r12,--r5
800043bc:	00 00       	add	r0,r0
800043be:	0b 54       	ld.sh	r4,--r5
800043c0:	00 00       	add	r0,r0
800043c2:	0b 50       	ld.sh	r0,--r5
800043c4:	00 00       	add	r0,r0
800043c6:	0b 38       	ld.ub	r8,r5++
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	5f 50       	srlt	r0
800043cc:	00 00       	add	r0,r0
800043ce:	0a 9c       	mov	r12,r5
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	2a e8       	sub	r8,-82
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	2b 08       	sub	r8,-80

800043d8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043d8:	eb cd 40 c0 	pushm	r6-r7,lr
800043dc:	20 1d       	sub	sp,4
800043de:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043e0:	98 39       	ld.sh	r9,r12[0x6]
800043e2:	3f f8       	mov	r8,-1
800043e4:	f0 09 19 00 	cp.h	r9,r8
800043e8:	c0 a1       	brne	800043fc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043ea:	4a e9       	lddpc	r9,800044a0 <xnl_tx+0xc8>
800043ec:	13 88       	ld.ub	r8,r9[0x0]
800043ee:	2f f8       	sub	r8,-1
800043f0:	5c 58       	castu.b	r8
800043f2:	b2 88       	st.b	r9[0x0],r8
800043f4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043f8:	a9 a8       	sbr	r8,0x8
800043fa:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043fc:	8c 49       	ld.sh	r9,r6[0x8]
800043fe:	3f f8       	mov	r8,-1
80004400:	f0 09 19 00 	cp.h	r9,r8
80004404:	c0 41       	brne	8000440c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004406:	4a 88       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004408:	90 18       	ld.sh	r8,r8[0x2]
8000440a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000440c:	8c 59       	ld.sh	r9,r6[0xa]
8000440e:	3f f8       	mov	r8,-1
80004410:	f0 09 19 00 	cp.h	r9,r8
80004414:	c0 41       	brne	8000441c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004416:	4a 48       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004418:	90 28       	ld.sh	r8,r8[0x4]
8000441a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000441c:	8c 69       	ld.sh	r9,r6[0xc]
8000441e:	3f f8       	mov	r8,-1
80004420:	f0 09 19 00 	cp.h	r9,r8
80004424:	c0 e1       	brne	80004440 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004426:	4a 08       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004428:	90 49       	ld.sh	r9,r8[0x8]
8000442a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000442c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000442e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004430:	90 49       	ld.sh	r9,r8[0x8]
80004432:	e0 19 ff 00 	andl	r9,0xff00
80004436:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000443a:	f3 e8 10 08 	or	r8,r9,r8
8000443e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004440:	0d 98       	ld.ub	r8,r6[0x1]
80004442:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004444:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004448:	10 0c       	add	r12,r8
8000444a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000444c:	58 0c       	cp.w	r12,0
8000444e:	e0 89 00 04 	brgt	80004456 <xnl_tx+0x7e>
80004452:	30 09       	mov	r9,0
80004454:	c0 d8       	rjmp	8000446e <xnl_tx+0x96>
80004456:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000445a:	2f ec       	sub	r12,-2
8000445c:	30 09       	mov	r9,0
8000445e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004460:	15 1b       	ld.sh	r11,r10++
80004462:	f6 09 00 09 	add	r9,r11,r9
80004466:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004468:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000446a:	18 38       	cp.w	r8,r12
8000446c:	cf a1       	brne	80004460 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000446e:	5c 39       	neg	r9
80004470:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004472:	48 e8       	lddpc	r8,800044a8 <xnl_tx+0xd0>
80004474:	70 0c       	ld.w	r12,r8[0x0]
80004476:	f0 1f 00 0e 	mcall	800044ac <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000447a:	c1 00       	breq	8000449a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000447c:	fa c7 ff fc 	sub	r7,sp,-4
80004480:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004482:	e0 6a 01 00 	mov	r10,256
80004486:	0c 9b       	mov	r11,r6
80004488:	f0 1f 00 0a 	mcall	800044b0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000448c:	48 a8       	lddpc	r8,800044b4 <xnl_tx+0xdc>
8000448e:	70 0c       	ld.w	r12,r8[0x0]
80004490:	30 09       	mov	r9,0
80004492:	12 9a       	mov	r10,r9
80004494:	1a 9b       	mov	r11,sp
80004496:	f0 1f 00 09 	mcall	800044b8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000449a:	2f fd       	sub	sp,-4
8000449c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044a0:	00 00       	add	r0,r0
800044a2:	0b 3c       	ld.ub	r12,r5++
800044a4:	00 00       	add	r0,r0
800044a6:	0b 3e       	ld.ub	lr,r5++
800044a8:	00 00       	add	r0,r0
800044aa:	0a 9c       	mov	r12,r5
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	2c 94       	sub	r4,-55
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	75 b8       	ld.w	r8,r10[0x6c]
800044b4:	00 00       	add	r0,r0
800044b6:	0b 4c       	ld.w	r12,--r5
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	61 5c       	ld.w	r12,r0[0x54]

800044bc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044bc:	eb cd 40 80 	pushm	r7,lr
800044c0:	fa cd 01 00 	sub	sp,sp,256
800044c4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044c6:	e0 68 40 0e 	mov	r8,16398
800044ca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044cc:	3f f8       	mov	r8,-1
800044ce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044d0:	30 c8       	mov	r8,12
800044d2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044d4:	98 38       	ld.sh	r8,r12[0x6]
800044d6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044d8:	98 58       	ld.sh	r8,r12[0xa]
800044da:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044dc:	98 48       	ld.sh	r8,r12[0x8]
800044de:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044e0:	98 68       	ld.sh	r8,r12[0xc]
800044e2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044e4:	30 08       	mov	r8,0
800044e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044e8:	1a 9c       	mov	r12,sp
800044ea:	f0 1f 00 0a 	mcall	80004510 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044ee:	fa cd 00 cc 	sub	sp,sp,204
800044f2:	e0 6a 00 ca 	mov	r10,202
800044f6:	ee cb ff f0 	sub	r11,r7,-16
800044fa:	1a 9c       	mov	r12,sp
800044fc:	f0 1f 00 06 	mcall	80004514 <xnl_data_msg_func+0x58>
80004500:	48 68       	lddpc	r8,80004518 <xnl_data_msg_func+0x5c>
80004502:	70 08       	ld.w	r8,r8[0x0]
80004504:	5d 18       	icall	r8
80004506:	fa cd ff 34 	sub	sp,sp,-204
}
8000450a:	2c 0d       	sub	sp,-256
8000450c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	43 d8       	lddsp	r8,sp[0xf4]
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	75 b8       	ld.w	r8,r10[0x6c]
80004518:	00 00       	add	r0,r0
8000451a:	0b 58       	ld.sh	r8,--r5

8000451c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000451c:	d4 21       	pushm	r4-r7,lr
8000451e:	fa cd 01 00 	sub	sp,sp,256
80004522:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004524:	4c 28       	lddpc	r8,8000462c <xnl_device_auth_reply_func+0x110>
80004526:	11 88       	ld.ub	r8,r8[0x0]
80004528:	58 08       	cp.w	r8,0
8000452a:	e0 81 00 7f 	brne	80004628 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000452e:	4c 18       	lddpc	r8,80004630 <xnl_device_auth_reply_func+0x114>
80004530:	70 0c       	ld.w	r12,r8[0x0]
80004532:	30 09       	mov	r9,0
80004534:	12 9a       	mov	r10,r9
80004536:	12 9b       	mov	r11,r9
80004538:	f0 1f 00 3f 	mcall	80004634 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000453c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004540:	4b b8       	lddpc	r8,8000462c <xnl_device_auth_reply_func+0x110>
80004542:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004544:	ef 39 00 12 	ld.ub	r9,r7[18]
80004548:	ef 38 00 13 	ld.ub	r8,r7[19]
8000454c:	b1 68       	lsl	r8,0x10
8000454e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004552:	ef 38 00 15 	ld.ub	r8,r7[21]
80004556:	f3 e8 10 08 	or	r8,r9,r8
8000455a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000455e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004562:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004566:	ef 38 00 17 	ld.ub	r8,r7[23]
8000456a:	b1 68       	lsl	r8,0x10
8000456c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004570:	ef 38 00 19 	ld.ub	r8,r7[25]
80004574:	f5 e8 10 08 	or	r8,r10,r8
80004578:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000457c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004580:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004582:	e0 64 79 b9 	mov	r4,31161
80004586:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000458a:	e0 65 45 07 	mov	r5,17671
8000458e:	ea 15 8a bd 	orh	r5,0x8abd
80004592:	e0 66 f9 3d 	mov	r6,63805
80004596:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000459a:	e0 6e b8 cf 	mov	lr,47311
8000459e:	ea 1e 36 83 	orh	lr,0x3683
800045a2:	e0 67 aa 1c 	mov	r7,43548
800045a6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045aa:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045ac:	f4 08 00 0c 	add	r12,r10,r8
800045b0:	f0 0b 15 04 	lsl	r11,r8,0x4
800045b4:	0a 0b       	add	r11,r5
800045b6:	f9 eb 20 0b 	eor	r11,r12,r11
800045ba:	f0 0c 16 05 	lsr	r12,r8,0x5
800045be:	0c 0c       	add	r12,r6
800045c0:	18 5b       	eor	r11,r12
800045c2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045c4:	f2 0c 15 04 	lsl	r12,r9,0x4
800045c8:	1c 0c       	add	r12,lr
800045ca:	f2 0b 16 05 	lsr	r11,r9,0x5
800045ce:	0e 0b       	add	r11,r7
800045d0:	f9 eb 20 0b 	eor	r11,r12,r11
800045d4:	f2 0a 00 0c 	add	r12,r9,r10
800045d8:	18 5b       	eor	r11,r12
800045da:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045dc:	e0 6b 37 20 	mov	r11,14112
800045e0:	ea 1b c6 ef 	orh	r11,0xc6ef
800045e4:	16 3a       	cp.w	r10,r11
800045e6:	ce 21       	brne	800045aa <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045e8:	e0 6a 40 1a 	mov	r10,16410
800045ec:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045ee:	3f fa       	mov	r10,-1
800045f0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045f2:	30 6b       	mov	r11,6
800045f4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045f6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045f8:	48 db       	lddpc	r11,8000462c <xnl_device_auth_reply_func+0x110>
800045fa:	96 1c       	ld.sh	r12,r11[0x2]
800045fc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045fe:	96 2b       	ld.sh	r11,r11[0x4]
80004600:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004602:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004604:	30 ca       	mov	r10,12
80004606:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004608:	30 0a       	mov	r10,0
8000460a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000460e:	30 7a       	mov	r10,7
80004610:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004614:	30 2a       	mov	r10,2
80004616:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000461a:	fa ca ff ec 	sub	r10,sp,-20
8000461e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004620:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004622:	1a 9c       	mov	r12,sp
80004624:	f0 1f 00 05 	mcall	80004638 <xnl_device_auth_reply_func+0x11c>
}
80004628:	2c 0d       	sub	sp,-256
8000462a:	d8 22       	popm	r4-r7,pc
8000462c:	00 00       	add	r0,r0
8000462e:	0b 3e       	ld.ub	lr,r5++
80004630:	00 00       	add	r0,r0
80004632:	0b 38       	ld.ub	r8,r5++
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	61 5c       	ld.w	r12,r0[0x54]
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	43 d8       	lddsp	r8,sp[0xf4]

8000463c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000463c:	eb cd 40 80 	pushm	r7,lr
80004640:	fa cd 01 00 	sub	sp,sp,256
80004644:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004646:	49 28       	lddpc	r8,8000468c <xnl_master_status_brdcst_func+0x50>
80004648:	11 88       	ld.ub	r8,r8[0x0]
8000464a:	58 08       	cp.w	r8,0
8000464c:	c1 c1       	brne	80004684 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000464e:	49 18       	lddpc	r8,80004690 <xnl_master_status_brdcst_func+0x54>
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	30 09       	mov	r9,0
80004654:	12 9a       	mov	r10,r9
80004656:	12 9b       	mov	r11,r9
80004658:	f0 1f 00 0f 	mcall	80004694 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000465c:	8e 58       	ld.sh	r8,r7[0xa]
8000465e:	48 c9       	lddpc	r9,8000468c <xnl_master_status_brdcst_func+0x50>
80004660:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004662:	e0 68 40 0e 	mov	r8,16398
80004666:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004668:	3f f8       	mov	r8,-1
8000466a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000466c:	30 4a       	mov	r10,4
8000466e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004670:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004672:	92 19       	ld.sh	r9,r9[0x2]
80004674:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004676:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004678:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000467a:	30 08       	mov	r8,0
8000467c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000467e:	1a 9c       	mov	r12,sp
80004680:	f0 1f 00 06 	mcall	80004698 <xnl_master_status_brdcst_func+0x5c>
}
80004684:	2c 0d       	sub	sp,-256
80004686:	e3 cd 80 80 	ldm	sp++,r7,pc
8000468a:	00 00       	add	r0,r0
8000468c:	00 00       	add	r0,r0
8000468e:	0b 3e       	ld.ub	lr,r5++
80004690:	00 00       	add	r0,r0
80004692:	0b 38       	ld.ub	r8,r5++
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	61 5c       	ld.w	r12,r0[0x54]
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	43 d8       	lddsp	r8,sp[0xf4]

8000469c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000469c:	eb cd 40 80 	pushm	r7,lr
800046a0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046a2:	49 28       	lddpc	r8,800046e8 <xnl_device_conn_reply_func+0x4c>
800046a4:	70 0c       	ld.w	r12,r8[0x0]
800046a6:	30 09       	mov	r9,0
800046a8:	12 9a       	mov	r10,r9
800046aa:	12 9b       	mov	r11,r9
800046ac:	f0 1f 00 10 	mcall	800046ec <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046b0:	ef 18 00 10 	ld.uh	r8,r7[16]
800046b4:	10 99       	mov	r9,r8
800046b6:	e2 19 ff 00 	andl	r9,0xff00,COH
800046ba:	e0 49 01 00 	cp.w	r9,256
800046be:	c0 60       	breq	800046ca <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046c0:	0e 9c       	mov	r12,r7
800046c2:	f0 1f 00 0c 	mcall	800046f0 <xnl_device_conn_reply_func+0x54>
800046c6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046ca:	a9 68       	lsl	r8,0x8
800046cc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800046d0:	48 98       	lddpc	r8,800046f4 <xnl_device_conn_reply_func+0x58>
800046d2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046d4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046d8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046da:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046de:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046e0:	30 19       	mov	r9,1
800046e2:	b0 89       	st.b	r8[0x0],r9
800046e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046e8:	00 00       	add	r0,r0
800046ea:	0b 38       	ld.ub	r8,r5++
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	61 5c       	ld.w	r12,r0[0x54]
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	46 3c       	lddsp	r12,sp[0x18c]
800046f4:	00 00       	add	r0,r0
800046f6:	0b 3e       	ld.ub	lr,r5++

800046f8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046f8:	d4 01       	pushm	lr
800046fa:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046fe:	e0 68 40 0e 	mov	r8,16398
80004702:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004704:	3f f8       	mov	r8,-1
80004706:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004708:	30 38       	mov	r8,3
8000470a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000470c:	30 08       	mov	r8,0
8000470e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004710:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004712:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004714:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004716:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004718:	1a 9c       	mov	r12,sp
8000471a:	f0 1f 00 03 	mcall	80004724 <xnl_send_device_master_query+0x2c>
}
8000471e:	2c 0d       	sub	sp,-256
80004720:	d8 02       	popm	pc
80004722:	00 00       	add	r0,r0
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	43 d8       	lddsp	r8,sp[0xf4]

80004728 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004728:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000472a:	48 78       	lddpc	r8,80004744 <RC522_SPI_SetSpeed+0x1c>
8000472c:	70 09       	ld.w	r9,r8[0x0]
8000472e:	72 ca       	ld.w	r10,r9[0x30]
80004730:	5c 7c       	castu.h	r12
80004732:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004736:	f9 ea 10 0a 	or	r10,r12,r10
8000473a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000473c:	70 0c       	ld.w	r12,r8[0x0]
8000473e:	f0 1f 00 03 	mcall	80004748 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004742:	d8 02       	popm	pc
80004744:	00 00       	add	r0,r0
80004746:	1d a0       	ld.ub	r0,lr[0x2]
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	56 4c       	stdsp	sp[0x190],r12

8000474c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000474c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000474e:	e0 6c 0a 00 	mov	r12,2560
80004752:	f0 1f 00 02 	mcall	80004758 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004756:	d8 02       	popm	pc
80004758:	80 00       	ld.sh	r0,r0[0x0]
8000475a:	47 28       	lddsp	r8,sp[0x1c8]

8000475c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000475c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004760:	48 76       	lddpc	r6,8000477c <RC522_ReadByte+0x20>
80004762:	e0 6b 00 ff 	mov	r11,255
80004766:	6c 0c       	ld.w	r12,r6[0x0]
80004768:	f0 1f 00 06 	mcall	80004780 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000476c:	30 07       	mov	r7,0
8000476e:	0e 9b       	mov	r11,r7
80004770:	6c 0c       	ld.w	r12,r6[0x0]
80004772:	f0 1f 00 05 	mcall	80004784 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004776:	0f 9c       	ld.ub	r12,r7[0x1]
80004778:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000477c:	00 00       	add	r0,r0
8000477e:	1d a0       	ld.ub	r0,lr[0x2]
80004780:	80 00       	ld.sh	r0,r0[0x0]
80004782:	56 52       	stdsp	sp[0x194],r2
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	56 6e       	stdsp	sp[0x198],lr

80004788 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004788:	eb cd 40 80 	pushm	r7,lr
8000478c:	20 1d       	sub	sp,4
8000478e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004790:	48 77       	lddpc	r7,800047ac <RC522_WriteByte+0x24>
80004792:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004796:	6e 0c       	ld.w	r12,r7[0x0]
80004798:	f0 1f 00 06 	mcall	800047b0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000479c:	1a 9b       	mov	r11,sp
8000479e:	6e 0c       	ld.w	r12,r7[0x0]
800047a0:	f0 1f 00 05 	mcall	800047b4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800047a4:	5c 5c       	castu.b	r12
800047a6:	2f fd       	sub	sp,-4
800047a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ac:	00 00       	add	r0,r0
800047ae:	1d a0       	ld.ub	r0,lr[0x2]
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	56 52       	stdsp	sp[0x194],r2
800047b4:	80 00       	ld.sh	r0,r0[0x0]
800047b6:	56 6e       	stdsp	sp[0x198],lr

800047b8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047b8:	eb cd 40 e0 	pushm	r5-r7,lr
800047bc:	18 96       	mov	r6,r12
800047be:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047c0:	48 a7       	lddpc	r7,800047e8 <WriteRawRC+0x30>
800047c2:	30 0b       	mov	r11,0
800047c4:	6e 0c       	ld.w	r12,r7[0x0]
800047c6:	f0 1f 00 0a 	mcall	800047ec <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800047ca:	ec 0c 15 01 	lsl	r12,r6,0x1
800047ce:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047d2:	f0 1f 00 08 	mcall	800047f0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800047d6:	0a 9c       	mov	r12,r5
800047d8:	f0 1f 00 06 	mcall	800047f0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800047dc:	30 0b       	mov	r11,0
800047de:	6e 0c       	ld.w	r12,r7[0x0]
800047e0:	f0 1f 00 05 	mcall	800047f4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800047e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800047e8:	00 00       	add	r0,r0
800047ea:	1d a0       	ld.ub	r0,lr[0x2]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	57 b8       	stdsp	sp[0x1ec],r8
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	47 88       	lddsp	r8,sp[0x1e0]
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	57 78       	stdsp	sp[0x1dc],r8

800047f8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047f8:	d4 01       	pushm	lr

	SET_RC522RST;
800047fa:	31 9c       	mov	r12,25
800047fc:	f0 1f 00 1b 	mcall	80004868 <PcdReset+0x70>
	delay_ns(10);
80004800:	30 ac       	mov	r12,10
80004802:	f0 1f 00 1b 	mcall	8000486c <PcdReset+0x74>

	CLR_RC522RST;
80004806:	31 9c       	mov	r12,25
80004808:	f0 1f 00 1a 	mcall	80004870 <PcdReset+0x78>
	delay_ns(10);
8000480c:	30 ac       	mov	r12,10
8000480e:	f0 1f 00 18 	mcall	8000486c <PcdReset+0x74>

	SET_RC522RST;
80004812:	31 9c       	mov	r12,25
80004814:	f0 1f 00 15 	mcall	80004868 <PcdReset+0x70>
	delay_ns(10);
80004818:	30 ac       	mov	r12,10
8000481a:	f0 1f 00 15 	mcall	8000486c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000481e:	30 fb       	mov	r11,15
80004820:	30 1c       	mov	r12,1
80004822:	f0 1f 00 15 	mcall	80004874 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004826:	30 fb       	mov	r11,15
80004828:	30 1c       	mov	r12,1
8000482a:	f0 1f 00 13 	mcall	80004874 <PcdReset+0x7c>
	delay_ns(10);
8000482e:	30 ac       	mov	r12,10
80004830:	f0 1f 00 0f 	mcall	8000486c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004834:	33 db       	mov	r11,61
80004836:	31 1c       	mov	r12,17
80004838:	f0 1f 00 0f 	mcall	80004874 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000483c:	31 eb       	mov	r11,30
8000483e:	32 dc       	mov	r12,45
80004840:	f0 1f 00 0d 	mcall	80004874 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004844:	30 0b       	mov	r11,0
80004846:	32 cc       	mov	r12,44
80004848:	f0 1f 00 0b 	mcall	80004874 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000484c:	e0 6b 00 8d 	mov	r11,141
80004850:	32 ac       	mov	r12,42
80004852:	f0 1f 00 09 	mcall	80004874 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004856:	33 eb       	mov	r11,62
80004858:	32 bc       	mov	r12,43
8000485a:	f0 1f 00 07 	mcall	80004874 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000485e:	34 0b       	mov	r11,64
80004860:	31 5c       	mov	r12,21
80004862:	f0 1f 00 05 	mcall	80004874 <PcdReset+0x7c>
	
	return MI_OK;
}
80004866:	d8 0a       	popm	pc,r12=0
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	53 30       	stdsp	sp[0xcc],r0
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	51 14       	stdsp	sp[0x44],r4
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	53 4c       	stdsp	sp[0xd0],r12
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	47 b8       	lddsp	r8,sp[0x1ec]

80004878 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004878:	eb cd 40 c0 	pushm	r6-r7,lr
8000487c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000487e:	48 c7       	lddpc	r7,800048ac <ReadRawRC+0x34>
80004880:	30 0b       	mov	r11,0
80004882:	6e 0c       	ld.w	r12,r7[0x0]
80004884:	f0 1f 00 0b 	mcall	800048b0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004888:	a1 76       	lsl	r6,0x1
8000488a:	0c 9c       	mov	r12,r6
8000488c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004890:	a7 bc       	sbr	r12,0x7
80004892:	f0 1f 00 09 	mcall	800048b4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004896:	f0 1f 00 09 	mcall	800048b8 <ReadRawRC+0x40>
8000489a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000489c:	30 0b       	mov	r11,0
8000489e:	6e 0c       	ld.w	r12,r7[0x0]
800048a0:	f0 1f 00 07 	mcall	800048bc <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800048a4:	0c 9c       	mov	r12,r6
800048a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048aa:	00 00       	add	r0,r0
800048ac:	00 00       	add	r0,r0
800048ae:	1d a0       	ld.ub	r0,lr[0x2]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	57 b8       	stdsp	sp[0x1ec],r8
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	47 88       	lddsp	r8,sp[0x1e0]
800048b8:	80 00       	ld.sh	r0,r0[0x0]
800048ba:	47 5c       	lddsp	r12,sp[0x1d4]
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	57 78       	stdsp	sp[0x1dc],r8

800048c0 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048c0:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048c2:	30 1c       	mov	r12,1
800048c4:	f0 1f 00 02 	mcall	800048cc <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800048c8:	d8 02       	popm	pc
800048ca:	00 00       	add	r0,r0
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	48 78       	lddpc	r8,800048e8 <Powerdown_RC522+0x18>

800048d0 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800048d0:	eb cd 40 80 	pushm	r7,lr
800048d4:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800048d6:	30 1c       	mov	r12,1
800048d8:	f0 1f 00 0d 	mcall	8000490c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800048dc:	30 18       	mov	r8,1
800048de:	f0 07 18 00 	cp.b	r7,r8
800048e2:	c0 91       	brne	800048f4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800048e4:	18 9b       	mov	r11,r12
800048e6:	a5 ab       	sbr	r11,0x4
800048e8:	5c 5b       	castu.b	r11
800048ea:	30 1c       	mov	r12,1
800048ec:	f0 1f 00 09 	mcall	80004910 <Powerdown_RC522+0x40>
800048f0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800048f4:	18 9b       	mov	r11,r12
800048f6:	30 1c       	mov	r12,1
800048f8:	f0 1f 00 06 	mcall	80004910 <Powerdown_RC522+0x40>
		delay_ns(2);
800048fc:	30 2c       	mov	r12,2
800048fe:	f0 1f 00 06 	mcall	80004914 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004902:	f0 1f 00 06 	mcall	80004918 <Powerdown_RC522+0x48>
80004906:	e3 cd 80 80 	ldm	sp++,r7,pc
8000490a:	00 00       	add	r0,r0
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	48 78       	lddpc	r8,80004928 <SetBitMask+0xc>
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	47 b8       	lddsp	r8,sp[0x1ec]
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	51 14       	stdsp	sp[0x44],r4
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	48 c0       	lddpc	r0,80004948 <PcdAntennaOn+0x8>

8000491c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000491c:	eb cd 40 c0 	pushm	r6-r7,lr
80004920:	18 97       	mov	r7,r12
80004922:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004924:	f0 1f 00 05 	mcall	80004938 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004928:	f9 e6 10 0b 	or	r11,r12,r6
8000492c:	5c 5b       	castu.b	r11
8000492e:	0e 9c       	mov	r12,r7
80004930:	f0 1f 00 03 	mcall	8000493c <SetBitMask+0x20>
}
80004934:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	48 78       	lddpc	r8,80004954 <PcdAntennaOn+0x14>
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	47 b8       	lddsp	r8,sp[0x1ec]

80004940 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004940:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004942:	31 4c       	mov	r12,20
80004944:	f0 1f 00 05 	mcall	80004958 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004948:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000494c:	c0 51       	brne	80004956 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000494e:	30 3b       	mov	r11,3
80004950:	31 4c       	mov	r12,20
80004952:	f0 1f 00 03 	mcall	8000495c <PcdAntennaOn+0x1c>
80004956:	d8 02       	popm	pc
80004958:	80 00       	ld.sh	r0,r0[0x0]
8000495a:	48 78       	lddpc	r8,80004974 <ClearBitMask+0x14>
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	49 1c       	lddpc	r12,800049a0 <M500PcdConfigISOType+0x8>

80004960 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004960:	eb cd 40 c0 	pushm	r6-r7,lr
80004964:	18 97       	mov	r7,r12
80004966:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004968:	f0 1f 00 06 	mcall	80004980 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
8000496c:	5c d6       	com	r6
8000496e:	f9 e6 00 06 	and	r6,r12,r6
80004972:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004976:	0e 9c       	mov	r12,r7
80004978:	f0 1f 00 03 	mcall	80004984 <ClearBitMask+0x24>
	
}
8000497c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	48 78       	lddpc	r8,8000499c <M500PcdConfigISOType+0x4>
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	47 b8       	lddsp	r8,sp[0x1ec]

80004988 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004988:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000498a:	30 3b       	mov	r11,3
8000498c:	31 4c       	mov	r12,20
8000498e:	f0 1f 00 02 	mcall	80004994 <PcdAntennaOff+0xc>
}
80004992:	d8 02       	popm	pc
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	49 60       	lddpc	r0,800049ec <M500PcdConfigISOType+0x54>

80004998 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004998:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000499a:	34 18       	mov	r8,65
8000499c:	f0 0c 18 00 	cp.b	r12,r8
800049a0:	c0 20       	breq	800049a4 <M500PcdConfigISOType+0xc>
800049a2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800049a4:	30 8b       	mov	r11,8
800049a6:	16 9c       	mov	r12,r11
800049a8:	f0 1f 00 14 	mcall	800049f8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049ac:	33 db       	mov	r11,61
800049ae:	31 1c       	mov	r12,17
800049b0:	f0 1f 00 13 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049b4:	e0 6b 00 86 	mov	r11,134
800049b8:	31 7c       	mov	r12,23
800049ba:	f0 1f 00 11 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049be:	37 fb       	mov	r11,127
800049c0:	32 6c       	mov	r12,38
800049c2:	f0 1f 00 0f 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800049c6:	31 eb       	mov	r11,30
800049c8:	32 dc       	mov	r12,45
800049ca:	f0 1f 00 0d 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800049ce:	30 0b       	mov	r11,0
800049d0:	32 cc       	mov	r12,44
800049d2:	f0 1f 00 0b 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800049d6:	e0 6b 00 8d 	mov	r11,141
800049da:	32 ac       	mov	r12,42
800049dc:	f0 1f 00 08 	mcall	800049fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800049e0:	33 eb       	mov	r11,62
800049e2:	32 bc       	mov	r12,43
800049e4:	f0 1f 00 06 	mcall	800049fc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800049e8:	e0 6c 03 e8 	mov	r12,1000
800049ec:	f0 1f 00 05 	mcall	80004a00 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800049f0:	f0 1f 00 05 	mcall	80004a04 <M500PcdConfigISOType+0x6c>
800049f4:	d8 0a       	popm	pc,r12=0
800049f6:	00 00       	add	r0,r0
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 60       	lddpc	r0,80004a50 <rc522_init+0x48>
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	47 b8       	lddsp	r8,sp[0x1ec]
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	51 14       	stdsp	sp[0x44],r4
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	49 40       	lddpc	r0,80004a54 <rc522_init+0x4c>

80004a08 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004a08:	eb cd 40 c0 	pushm	r6-r7,lr
80004a0c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a0e:	4a 38       	lddpc	r8,80004a98 <rc522_init+0x90>
80004a10:	1a 96       	mov	r6,sp
80004a12:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a16:	fa eb 00 00 	st.d	sp[0],r10
80004a1a:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a1e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a22:	30 4b       	mov	r11,4
80004a24:	49 ec       	lddpc	r12,80004a9c <rc522_init+0x94>
80004a26:	f0 1f 00 1f 	mcall	80004aa0 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a2a:	31 9c       	mov	r12,25
80004a2c:	f0 1f 00 1e 	mcall	80004aa4 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a30:	31 9c       	mov	r12,25
80004a32:	f0 1f 00 1e 	mcall	80004aa8 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a36:	49 e7       	lddpc	r7,80004aac <rc522_init+0xa4>
80004a38:	fe 7c 24 00 	mov	r12,-56320
80004a3c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a3e:	1a 9b       	mov	r11,sp
80004a40:	f0 1f 00 1c 	mcall	80004ab0 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a44:	30 09       	mov	r9,0
80004a46:	12 9a       	mov	r10,r9
80004a48:	12 9b       	mov	r11,r9
80004a4a:	6e 0c       	ld.w	r12,r7[0x0]
80004a4c:	f0 1f 00 1a 	mcall	80004ab4 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a50:	6e 0c       	ld.w	r12,r7[0x0]
80004a52:	f0 1f 00 1a 	mcall	80004ab8 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a56:	e0 6a 36 00 	mov	r10,13824
80004a5a:	ea 1a 01 6e 	orh	r10,0x16e
80004a5e:	1a 9b       	mov	r11,sp
80004a60:	6e 0c       	ld.w	r12,r7[0x0]
80004a62:	f0 1f 00 17 	mcall	80004abc <rc522_init+0xb4>
80004a66:	c0 50       	breq	80004a70 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004a68:	30 29       	mov	r9,2
80004a6a:	49 68       	lddpc	r8,80004ac0 <rc522_init+0xb8>
80004a6c:	b0 89       	st.b	r8[0x0],r9
80004a6e:	c0 38       	rjmp	80004a74 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004a70:	f0 1f 00 15 	mcall	80004ac4 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004a74:	f0 1f 00 15 	mcall	80004ac8 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004a78:	f0 1f 00 15 	mcall	80004acc <rc522_init+0xc4>
	
	delay_ms(2); 
80004a7c:	30 2c       	mov	r12,2
80004a7e:	f0 1f 00 15 	mcall	80004ad0 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004a82:	f0 1f 00 15 	mcall	80004ad4 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004a86:	34 1c       	mov	r12,65
80004a88:	f0 1f 00 14 	mcall	80004ad8 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004a8c:	30 1c       	mov	r12,1
80004a8e:	f0 1f 00 14 	mcall	80004adc <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004a92:	2f cd       	sub	sp,-16
80004a94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	d6 24       	*unknown*
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	d6 34       	*unknown*
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	52 e8       	stdsp	sp[0xb8],r8
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	53 18       	stdsp	sp[0xc4],r8
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	53 30       	stdsp	sp[0xcc],r0
80004aac:	00 00       	add	r0,r0
80004aae:	1d a0       	ld.ub	r0,lr[0x2]
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	55 e8       	stdsp	sp[0x178],r8
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	56 20       	stdsp	sp[0x188],r0
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	56 4c       	stdsp	sp[0x190],r12
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	56 90       	stdsp	sp[0x1a4],r0
80004ac0:	00 00       	add	r0,r0
80004ac2:	0b 5c       	ld.sh	r12,--r5
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	47 4c       	lddsp	r12,sp[0x1d0]
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	47 f8       	lddsp	r8,sp[0x1fc]
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 88       	lddpc	r8,80004b2c <PcdComMF522+0x4c>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	51 54       	stdsp	sp[0x54],r4
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	49 40       	lddpc	r0,80004b24 <PcdComMF522+0x44>
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	49 98       	lddpc	r8,80004b3c <PcdComMF522+0x5c>
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	48 d0       	lddpc	r0,80004b10 <PcdComMF522+0x30>

80004ae0 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004ae0:	d4 31       	pushm	r0-r7,lr
80004ae2:	20 1d       	sub	sp,4
80004ae4:	18 92       	mov	r2,r12
80004ae6:	16 95       	mov	r5,r11
80004ae8:	14 96       	mov	r6,r10
80004aea:	50 09       	stdsp	sp[0x0],r9
80004aec:	10 90       	mov	r0,r8
80004aee:	f8 c8 00 0c 	sub	r8,r12,12
80004af2:	5c 58       	castu.b	r8
80004af4:	30 29       	mov	r9,2
80004af6:	f2 08 18 00 	cp.b	r8,r9
80004afa:	e0 88 00 05 	brls	80004b04 <PcdComMF522+0x24>
80004afe:	30 03       	mov	r3,0
80004b00:	06 91       	mov	r1,r3
80004b02:	c0 78       	rjmp	80004b10 <PcdComMF522+0x30>
80004b04:	4c f9       	lddpc	r9,80004c40 <PcdComMF522+0x160>
80004b06:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004b0a:	4c f9       	lddpc	r9,80004c44 <PcdComMF522+0x164>
80004b0c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b10:	02 9b       	mov	r11,r1
80004b12:	a7 bb       	sbr	r11,0x7
80004b14:	30 2c       	mov	r12,2
80004b16:	f0 1f 00 4d 	mcall	80004c48 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b1a:	e0 6b 00 80 	mov	r11,128
80004b1e:	30 4c       	mov	r12,4
80004b20:	f0 1f 00 4b 	mcall	80004c4c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b24:	30 0b       	mov	r11,0
80004b26:	30 1c       	mov	r12,1
80004b28:	f0 1f 00 48 	mcall	80004c48 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b2c:	e0 6b 00 80 	mov	r11,128
80004b30:	30 ac       	mov	r12,10
80004b32:	f0 1f 00 48 	mcall	80004c50 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b36:	58 06       	cp.w	r6,0
80004b38:	c0 c0       	breq	80004b50 <PcdComMF522+0x70>
80004b3a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b3c:	30 94       	mov	r4,9
80004b3e:	0f 3b       	ld.ub	r11,r7++
80004b40:	08 9c       	mov	r12,r4
80004b42:	f0 1f 00 42 	mcall	80004c48 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b46:	0e 98       	mov	r8,r7
80004b48:	0a 18       	sub	r8,r5
80004b4a:	ec 08 19 00 	cp.h	r8,r6
80004b4e:	cf 83       	brcs	80004b3e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b50:	04 9b       	mov	r11,r2
80004b52:	30 1c       	mov	r12,1
80004b54:	f0 1f 00 3d 	mcall	80004c48 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b58:	30 c8       	mov	r8,12
80004b5a:	f0 02 18 00 	cp.b	r2,r8
80004b5e:	c0 61       	brne	80004b6a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b60:	e0 6b 00 80 	mov	r11,128
80004b64:	30 dc       	mov	r12,13
80004b66:	f0 1f 00 3b 	mcall	80004c50 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b6a:	30 4c       	mov	r12,4
80004b6c:	f0 1f 00 3a 	mcall	80004c54 <PcdComMF522+0x174>
80004b70:	18 97       	mov	r7,r12
80004b72:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b76:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b78:	30 44       	mov	r4,4
80004b7a:	c0 88       	rjmp	80004b8a <PcdComMF522+0xaa>
80004b7c:	08 9c       	mov	r12,r4
80004b7e:	f0 1f 00 36 	mcall	80004c54 <PcdComMF522+0x174>
80004b82:	18 97       	mov	r7,r12
		i--;
80004b84:	20 16       	sub	r6,1
80004b86:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b88:	c0 a0       	breq	80004b9c <PcdComMF522+0xbc>
80004b8a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004b8e:	c4 c1       	brne	80004c26 <PcdComMF522+0x146>
80004b90:	ef e3 00 08 	and	r8,r7,r3
80004b94:	ea 08 18 00 	cp.b	r8,r5
80004b98:	cf 20       	breq	80004b7c <PcdComMF522+0x9c>
80004b9a:	c4 68       	rjmp	80004c26 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004b9c:	e0 6b 00 80 	mov	r11,128
80004ba0:	30 dc       	mov	r12,13
80004ba2:	f0 1f 00 2b 	mcall	80004c4c <PcdComMF522+0x16c>
80004ba6:	30 27       	mov	r7,2
80004ba8:	c3 38       	rjmp	80004c0e <PcdComMF522+0x12e>
80004baa:	02 67       	and	r7,r1
80004bac:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004bb0:	30 c8       	mov	r8,12
80004bb2:	f0 02 18 00 	cp.b	r2,r8
80004bb6:	c2 c1       	brne	80004c0e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bb8:	30 ac       	mov	r12,10
80004bba:	f0 1f 00 27 	mcall	80004c54 <PcdComMF522+0x174>
80004bbe:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bc0:	30 cc       	mov	r12,12
80004bc2:	f0 1f 00 25 	mcall	80004c54 <PcdComMF522+0x174>
80004bc6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004bca:	c0 70       	breq	80004bd8 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004bcc:	08 98       	mov	r8,r4
80004bce:	20 18       	sub	r8,1
80004bd0:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004bd4:	a0 8c       	st.b	r0[0x0],r12
80004bd6:	c0 48       	rjmp	80004bde <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004bd8:	e8 08 15 03 	lsl	r8,r4,0x3
80004bdc:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004bde:	58 04       	cp.w	r4,0
80004be0:	c0 61       	brne	80004bec <PcdComMF522+0x10c>
80004be2:	30 14       	mov	r4,1
80004be4:	40 05       	lddsp	r5,sp[0x0]
80004be6:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004be8:	30 93       	mov	r3,9
80004bea:	c0 98       	rjmp	80004bfc <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004bec:	31 28       	mov	r8,18
80004bee:	f0 04 18 00 	cp.b	r4,r8
80004bf2:	f9 b4 0b 12 	movhi	r4,18
80004bf6:	58 04       	cp.w	r4,0
80004bf8:	cf 61       	brne	80004be4 <PcdComMF522+0x104>
80004bfa:	c0 a8       	rjmp	80004c0e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bfc:	06 9c       	mov	r12,r3
80004bfe:	f0 1f 00 16 	mcall	80004c54 <PcdComMF522+0x174>
80004c02:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c04:	ec 05 01 08 	sub	r8,r6,r5
80004c08:	e8 08 19 00 	cp.h	r8,r4
80004c0c:	cf 83       	brcs	80004bfc <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c0e:	e0 6b 00 80 	mov	r11,128
80004c12:	30 cc       	mov	r12,12
80004c14:	f0 1f 00 0f 	mcall	80004c50 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c18:	30 0b       	mov	r11,0
80004c1a:	30 1c       	mov	r12,1
80004c1c:	f0 1f 00 0b 	mcall	80004c48 <PcdComMF522+0x168>
	return status;
}
80004c20:	0e 9c       	mov	r12,r7
80004c22:	2f fd       	sub	sp,-4
80004c24:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c26:	e0 6b 00 80 	mov	r11,128
80004c2a:	30 dc       	mov	r12,13
80004c2c:	f0 1f 00 08 	mcall	80004c4c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c30:	30 6c       	mov	r12,6
80004c32:	f0 1f 00 09 	mcall	80004c54 <PcdComMF522+0x174>
80004c36:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c3a:	cb 80       	breq	80004baa <PcdComMF522+0xca>
80004c3c:	30 27       	mov	r7,2
80004c3e:	ce 8b       	rjmp	80004c0e <PcdComMF522+0x12e>
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	d6 1c       	*unknown*
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	d6 20       	acall	0x62
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	47 b8       	lddsp	r8,sp[0x1ec]
80004c4c:	80 00       	ld.sh	r0,r0[0x0]
80004c4e:	49 60       	lddpc	r0,80004ca4 <PcdAnticoll+0x4c>
80004c50:	80 00       	ld.sh	r0,r0[0x0]
80004c52:	49 1c       	lddpc	r12,80004c94 <PcdAnticoll+0x3c>
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	48 78       	lddpc	r8,80004c70 <PcdAnticoll+0x18>

80004c58 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c58:	eb cd 40 c0 	pushm	r6-r7,lr
80004c5c:	20 5d       	sub	sp,20
80004c5e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c60:	30 8b       	mov	r11,8
80004c62:	16 9c       	mov	r12,r11
80004c64:	f0 1f 00 1a 	mcall	80004ccc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004c68:	30 0b       	mov	r11,0
80004c6a:	30 dc       	mov	r12,13
80004c6c:	f0 1f 00 19 	mcall	80004cd0 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004c70:	e0 6b 00 80 	mov	r11,128
80004c74:	30 ec       	mov	r12,14
80004c76:	f0 1f 00 16 	mcall	80004ccc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004c7a:	39 38       	mov	r8,-109
80004c7c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004c7e:	32 08       	mov	r8,32
80004c80:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004c82:	1a 9b       	mov	r11,sp
80004c84:	fa c8 ff ed 	sub	r8,sp,-19
80004c88:	1a 99       	mov	r9,sp
80004c8a:	30 2a       	mov	r10,2
80004c8c:	30 cc       	mov	r12,12
80004c8e:	f0 1f 00 12 	mcall	80004cd4 <PcdAnticoll+0x7c>
80004c92:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004c94:	c1 21       	brne	80004cb8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c96:	1b 89       	ld.ub	r9,sp[0x0]
80004c98:	ac 89       	st.b	r6[0x0],r9
80004c9a:	1b 98       	ld.ub	r8,sp[0x1]
80004c9c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004c9e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ca0:	1b a8       	ld.ub	r8,sp[0x2]
80004ca2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004ca4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ca8:	1b b9       	ld.ub	r9,sp[0x3]
80004caa:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004cac:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004cae:	1b c9       	ld.ub	r9,sp[0x4]
80004cb0:	f0 09 18 00 	cp.b	r9,r8
80004cb4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cb8:	e0 6b 00 80 	mov	r11,128
80004cbc:	30 ec       	mov	r12,14
80004cbe:	f0 1f 00 07 	mcall	80004cd8 <PcdAnticoll+0x80>
	return status;
}
80004cc2:	0e 9c       	mov	r12,r7
80004cc4:	2f bd       	sub	sp,-20
80004cc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cca:	00 00       	add	r0,r0
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	49 60       	lddpc	r0,80004d24 <PcdRequest+0x48>
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	47 b8       	lddsp	r8,sp[0x1ec]
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	4a e0       	lddpc	r0,80004d8c <CalulateCRC+0x4c>
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	49 1c       	lddpc	r12,80004d1c <PcdRequest+0x40>

80004cdc <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004cdc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ce0:	20 5d       	sub	sp,20
80004ce2:	18 97       	mov	r7,r12
80004ce4:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004ce6:	30 8b       	mov	r11,8
80004ce8:	16 9c       	mov	r12,r11
80004cea:	f0 1f 00 12 	mcall	80004d30 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004cee:	30 7b       	mov	r11,7
80004cf0:	30 dc       	mov	r12,13
80004cf2:	f0 1f 00 11 	mcall	80004d34 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004cf6:	30 3b       	mov	r11,3
80004cf8:	31 4c       	mov	r12,20
80004cfa:	f0 1f 00 10 	mcall	80004d38 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004cfe:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004d00:	1a 9b       	mov	r11,sp
80004d02:	fa c8 ff ed 	sub	r8,sp,-19
80004d06:	1a 99       	mov	r9,sp
80004d08:	30 1a       	mov	r10,1
80004d0a:	30 cc       	mov	r12,12
80004d0c:	f0 1f 00 0c 	mcall	80004d3c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d10:	c0 c1       	brne	80004d28 <PcdRequest+0x4c>
80004d12:	31 08       	mov	r8,16
80004d14:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d18:	f0 09 18 00 	cp.b	r9,r8
80004d1c:	c0 61       	brne	80004d28 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d1e:	1b 88       	ld.ub	r8,sp[0x0]
80004d20:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d22:	1b 98       	ld.ub	r8,sp[0x1]
80004d24:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d26:	c0 28       	rjmp	80004d2a <PcdRequest+0x4e>
80004d28:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d2a:	2f bd       	sub	sp,-20
80004d2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	49 60       	lddpc	r0,80004d88 <CalulateCRC+0x48>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	47 b8       	lddsp	r8,sp[0x1ec]
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	49 1c       	lddpc	r12,80004d7c <CalulateCRC+0x3c>
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4a e0       	lddpc	r0,80004df4 <PcdSelect+0x28>

80004d40 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d40:	eb cd 40 f8 	pushm	r3-r7,lr
80004d44:	18 95       	mov	r5,r12
80004d46:	16 96       	mov	r6,r11
80004d48:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d4a:	30 4b       	mov	r11,4
80004d4c:	30 5c       	mov	r12,5
80004d4e:	f0 1f 00 1c 	mcall	80004dbc <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d52:	30 0b       	mov	r11,0
80004d54:	30 1c       	mov	r12,1
80004d56:	f0 1f 00 1b 	mcall	80004dc0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d5a:	e0 6b 00 80 	mov	r11,128
80004d5e:	30 ac       	mov	r12,10
80004d60:	f0 1f 00 19 	mcall	80004dc4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004d64:	58 06       	cp.w	r6,0
80004d66:	c0 c0       	breq	80004d7e <CalulateCRC+0x3e>
80004d68:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004d6a:	30 94       	mov	r4,9
80004d6c:	0f 3b       	ld.ub	r11,r7++
80004d6e:	08 9c       	mov	r12,r4
80004d70:	f0 1f 00 14 	mcall	80004dc0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004d74:	0e 98       	mov	r8,r7
80004d76:	0a 18       	sub	r8,r5
80004d78:	ec 08 18 00 	cp.b	r8,r6
80004d7c:	cf 83       	brcs	80004d6c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004d7e:	30 3b       	mov	r11,3
80004d80:	30 1c       	mov	r12,1
80004d82:	f0 1f 00 10 	mcall	80004dc0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004d86:	30 5c       	mov	r12,5
80004d88:	f0 1f 00 10 	mcall	80004dc8 <CalulateCRC+0x88>
80004d8c:	e0 67 00 fe 	mov	r7,254
80004d90:	30 56       	mov	r6,5
80004d92:	c0 78       	rjmp	80004da0 <CalulateCRC+0x60>
80004d94:	0c 9c       	mov	r12,r6
80004d96:	f0 1f 00 0d 	mcall	80004dc8 <CalulateCRC+0x88>
		i--;
80004d9a:	20 17       	sub	r7,1
80004d9c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004d9e:	c0 40       	breq	80004da6 <CalulateCRC+0x66>
80004da0:	e2 1c 00 04 	andl	r12,0x4,COH
80004da4:	cf 80       	breq	80004d94 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004da6:	32 2c       	mov	r12,34
80004da8:	f0 1f 00 08 	mcall	80004dc8 <CalulateCRC+0x88>
80004dac:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004dae:	32 1c       	mov	r12,33
80004db0:	f0 1f 00 06 	mcall	80004dc8 <CalulateCRC+0x88>
80004db4:	a6 9c       	st.b	r3[0x1],r12
}
80004db6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004dba:	00 00       	add	r0,r0
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	49 60       	lddpc	r0,80004e14 <PcdSelect+0x48>
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	47 b8       	lddsp	r8,sp[0x1ec]
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	49 1c       	lddpc	r12,80004e08 <PcdSelect+0x3c>
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	48 78       	lddpc	r8,80004de4 <PcdSelect+0x18>

80004dcc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004dcc:	eb cd 40 80 	pushm	r7,lr
80004dd0:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dd2:	39 38       	mov	r8,-109
80004dd4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004dd6:	37 08       	mov	r8,112
80004dd8:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004dda:	30 08       	mov	r8,0
80004ddc:	ba e8       	st.b	sp[0x6],r8
80004dde:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004de2:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004de6:	19 89       	ld.ub	r9,r12[0x0]
80004de8:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004dea:	19 3a       	ld.ub	r10,r12++
80004dec:	1b e9       	ld.ub	r9,sp[0x6]
80004dee:	f5 e9 20 09 	eor	r9,r10,r9
80004df2:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004df4:	16 38       	cp.w	r8,r11
80004df6:	cf 81       	brne	80004de6 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004df8:	1a 97       	mov	r7,sp
80004dfa:	fa ca ff f9 	sub	r10,sp,-7
80004dfe:	30 7b       	mov	r11,7
80004e00:	1a 9c       	mov	r12,sp
80004e02:	f0 1f 00 0d 	mcall	80004e34 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004e06:	30 8b       	mov	r11,8
80004e08:	16 9c       	mov	r12,r11
80004e0a:	f0 1f 00 0c 	mcall	80004e38 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e0e:	fa c8 ff ed 	sub	r8,sp,-19
80004e12:	1a 99       	mov	r9,sp
80004e14:	30 9a       	mov	r10,9
80004e16:	1a 9b       	mov	r11,sp
80004e18:	30 cc       	mov	r12,12
80004e1a:	f0 1f 00 09 	mcall	80004e3c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e1e:	c0 71       	brne	80004e2c <PcdSelect+0x60>
80004e20:	31 88       	mov	r8,24
80004e22:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e26:	f0 09 18 00 	cp.b	r9,r8
80004e2a:	c0 20       	breq	80004e2e <PcdSelect+0x62>
80004e2c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e2e:	2f bd       	sub	sp,-20
80004e30:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	4d 40       	lddpc	r0,80004f84 <scan_patrol+0x24>
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	49 60       	lddpc	r0,80004e90 <rfid_auto_reader+0x50>
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4a e0       	lddpc	r0,80004ef4 <rfid_auto_reader+0xb4>

80004e40 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e40:	eb cd 40 c0 	pushm	r6-r7,lr
80004e44:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e46:	f0 1f 00 37 	mcall	80004f20 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e4a:	4b 7b       	lddpc	r11,80004f24 <rfid_auto_reader+0xe4>
80004e4c:	35 2c       	mov	r12,82
80004e4e:	f0 1f 00 37 	mcall	80004f28 <rfid_auto_reader+0xe8>
80004e52:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e54:	c6 31       	brne	80004f1a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e56:	4b 48       	lddpc	r8,80004f24 <rfid_auto_reader+0xe4>
80004e58:	11 88       	ld.ub	r8,r8[0x0]
80004e5a:	30 49       	mov	r9,4
80004e5c:	f2 08 18 00 	cp.b	r8,r9
80004e60:	c0 b1       	brne	80004e76 <rfid_auto_reader+0x36>
80004e62:	4b 19       	lddpc	r9,80004f24 <rfid_auto_reader+0xe4>
80004e64:	13 9a       	ld.ub	r10,r9[0x1]
80004e66:	30 09       	mov	r9,0
80004e68:	f2 0a 18 00 	cp.b	r10,r9
80004e6c:	c0 51       	brne	80004e76 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004e6e:	4b 0c       	lddpc	r12,80004f2c <rfid_auto_reader+0xec>
80004e70:	f0 1f 00 30 	mcall	80004f30 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e74:	c3 c8       	rjmp	80004eec <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e76:	30 29       	mov	r9,2
80004e78:	f2 08 18 00 	cp.b	r8,r9
80004e7c:	c0 b1       	brne	80004e92 <rfid_auto_reader+0x52>
80004e7e:	4a a9       	lddpc	r9,80004f24 <rfid_auto_reader+0xe4>
80004e80:	13 9a       	ld.ub	r10,r9[0x1]
80004e82:	30 09       	mov	r9,0
80004e84:	f2 0a 18 00 	cp.b	r10,r9
80004e88:	c0 51       	brne	80004e92 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004e8a:	4a bc       	lddpc	r12,80004f34 <rfid_auto_reader+0xf4>
80004e8c:	f0 1f 00 29 	mcall	80004f30 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e90:	c2 e8       	rjmp	80004eec <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004e92:	34 49       	mov	r9,68
80004e94:	f2 08 18 00 	cp.b	r8,r9
80004e98:	c0 b1       	brne	80004eae <rfid_auto_reader+0x6e>
80004e9a:	4a 39       	lddpc	r9,80004f24 <rfid_auto_reader+0xe4>
80004e9c:	13 9a       	ld.ub	r10,r9[0x1]
80004e9e:	30 09       	mov	r9,0
80004ea0:	f2 0a 18 00 	cp.b	r10,r9
80004ea4:	c0 51       	brne	80004eae <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004ea6:	4a 5c       	lddpc	r12,80004f38 <rfid_auto_reader+0xf8>
80004ea8:	f0 1f 00 22 	mcall	80004f30 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004eac:	c2 08       	rjmp	80004eec <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004eae:	30 89       	mov	r9,8
80004eb0:	f2 08 18 00 	cp.b	r8,r9
80004eb4:	c0 b1       	brne	80004eca <rfid_auto_reader+0x8a>
80004eb6:	49 c9       	lddpc	r9,80004f24 <rfid_auto_reader+0xe4>
80004eb8:	13 9a       	ld.ub	r10,r9[0x1]
80004eba:	30 09       	mov	r9,0
80004ebc:	f2 0a 18 00 	cp.b	r10,r9
80004ec0:	c0 51       	brne	80004eca <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004ec2:	49 fc       	lddpc	r12,80004f3c <rfid_auto_reader+0xfc>
80004ec4:	f0 1f 00 1b 	mcall	80004f30 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ec8:	c1 28       	rjmp	80004eec <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004eca:	34 49       	mov	r9,68
80004ecc:	f2 08 18 00 	cp.b	r8,r9
80004ed0:	c0 b1       	brne	80004ee6 <rfid_auto_reader+0xa6>
80004ed2:	49 58       	lddpc	r8,80004f24 <rfid_auto_reader+0xe4>
80004ed4:	11 99       	ld.ub	r9,r8[0x1]
80004ed6:	30 38       	mov	r8,3
80004ed8:	f0 09 18 00 	cp.b	r9,r8
80004edc:	c0 51       	brne	80004ee6 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004ede:	49 9c       	lddpc	r12,80004f40 <rfid_auto_reader+0x100>
80004ee0:	f0 1f 00 14 	mcall	80004f30 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ee4:	c0 48       	rjmp	80004eec <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004ee6:	49 8c       	lddpc	r12,80004f44 <rfid_auto_reader+0x104>
80004ee8:	f0 1f 00 12 	mcall	80004f30 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004eec:	49 7c       	lddpc	r12,80004f48 <rfid_auto_reader+0x108>
80004eee:	f0 1f 00 18 	mcall	80004f4c <rfid_auto_reader+0x10c>
80004ef2:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004ef4:	c0 60       	breq	80004f00 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004ef6:	37 8b       	mov	r11,120
80004ef8:	30 1c       	mov	r12,1
80004efa:	f0 1f 00 16 	mcall	80004f50 <rfid_auto_reader+0x110>
		return status;
80004efe:	c0 e8       	rjmp	80004f1a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004f00:	49 2c       	lddpc	r12,80004f48 <rfid_auto_reader+0x108>
80004f02:	f0 1f 00 15 	mcall	80004f54 <rfid_auto_reader+0x114>
80004f06:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004f08:	c0 91       	brne	80004f1a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004f0a:	30 4a       	mov	r10,4
80004f0c:	48 fb       	lddpc	r11,80004f48 <rfid_auto_reader+0x108>
80004f0e:	0c 9c       	mov	r12,r6
80004f10:	f0 1f 00 12 	mcall	80004f58 <rfid_auto_reader+0x118>
		log("select okay\n");
80004f14:	49 2c       	lddpc	r12,80004f5c <rfid_auto_reader+0x11c>
80004f16:	f0 1f 00 07 	mcall	80004f30 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004f1a:	0e 9c       	mov	r12,r7
80004f1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	47 f8       	lddsp	r8,sp[0x1fc]
80004f24:	00 00       	add	r0,r0
80004f26:	51 28       	stdsp	sp[0x48],r8
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4c dc       	lddpc	r12,8000505c <rfid_sendID_message+0xac>
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	d6 54       	*unknown*
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	6d 3c       	ld.w	r12,r6[0x4c]
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	d6 60       	acall	0x66
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	d6 6c       	*unknown*
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	d6 7c       	*unknown*
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	d6 84       	*unknown*
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	d6 90       	acall	0x69
80004f48:	00 00       	add	r0,r0
80004f4a:	51 2c       	stdsp	sp[0x48],r12
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	4c 58       	lddpc	r8,80005060 <rfid_sendID_message+0xb0>
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	3f 4c       	mov	r12,-12
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	4d cc       	lddpc	r12,800050c4 <rfid_sendID_message+0x114>
80004f58:	80 00       	ld.sh	r0,r0[0x0]
80004f5a:	75 b8       	ld.w	r8,r10[0x6c]
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	d6 9c       	*unknown*

80004f60 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f60:	eb cd 40 80 	pushm	r7,lr
80004f64:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004f66:	f0 1f 00 0d 	mcall	80004f98 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004f6a:	30 0c       	mov	r12,0
80004f6c:	f0 1f 00 0c 	mcall	80004f9c <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004f70:	0e 9c       	mov	r12,r7
80004f72:	f0 1f 00 0c 	mcall	80004fa0 <scan_patrol+0x40>
80004f76:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004f78:	30 1c       	mov	r12,1
80004f7a:	f0 1f 00 09 	mcall	80004f9c <scan_patrol+0x3c>
	if(return_err == 0)
80004f7e:	58 07       	cp.w	r7,0
80004f80:	c0 51       	brne	80004f8a <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004f82:	48 9c       	lddpc	r12,80004fa4 <scan_patrol+0x44>
80004f84:	f0 1f 00 09 	mcall	80004fa8 <scan_patrol+0x48>
80004f88:	c0 48       	rjmp	80004f90 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004f8a:	48 9c       	lddpc	r12,80004fac <scan_patrol+0x4c>
80004f8c:	f0 1f 00 07 	mcall	80004fa8 <scan_patrol+0x48>
		
	return return_err;

}
80004f90:	0e 9c       	mov	r12,r7
80004f92:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f96:	00 00       	add	r0,r0
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	47 f8       	lddsp	r8,sp[0x1fc]
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	48 d0       	lddpc	r0,80004fd0 <rfid_sendID_message+0x20>
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	4e 40       	lddpc	r0,80005130 <delay_us+0x4>
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	d6 ac       	*unknown*
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	6d 3c       	ld.w	r12,r6[0x4c]
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	d6 c0       	acall	0x6c

80004fb0 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
80004fb0:	eb cd 40 e0 	pushm	r5-r7,lr
80004fb4:	21 bd       	sub	sp,108
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004fb6:	4c bc       	lddpc	r12,800050e0 <rfid_sendID_message+0x130>
80004fb8:	30 08       	mov	r8,0
80004fba:	30 09       	mov	r9,0
80004fbc:	f8 e9 00 00 	st.d	r12[0],r8
80004fc0:	30 0a       	mov	r10,0
80004fc2:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004fc4:	fa e9 00 1c 	st.d	sp[28],r8
80004fc8:	fa e9 00 24 	st.d	sp[36],r8
80004fcc:	fa e9 00 2c 	st.d	sp[44],r8
80004fd0:	fa e9 00 34 	st.d	sp[52],r8
80004fd4:	fa e9 00 3c 	st.d	sp[60],r8
80004fd8:	fa e9 00 44 	st.d	sp[68],r8
80004fdc:	fa e9 00 4c 	st.d	sp[76],r8
80004fe0:	fa e9 00 54 	st.d	sp[84],r8
80004fe4:	fa e9 00 5c 	st.d	sp[92],r8
80004fe8:	fa e9 00 64 	st.d	sp[100],r8
	
	return_err = scan_patrol(SN);
80004fec:	f0 1f 00 3e 	mcall	800050e4 <rfid_sendID_message+0x134>
80004ff0:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ff2:	c6 c1       	brne	800050ca <rfid_sendID_message+0x11a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ff4:	4b b6       	lddpc	r6,800050e0 <rfid_sendID_message+0x130>
80004ff6:	0d b8       	ld.ub	r8,r6[0x3]
80004ff8:	1a d8       	st.w	--sp,r8
80004ffa:	0d a8       	ld.ub	r8,r6[0x2]
80004ffc:	1a d8       	st.w	--sp,r8
80004ffe:	0d 98       	ld.ub	r8,r6[0x1]
80005000:	1a d8       	st.w	--sp,r8
80005002:	0d 88       	ld.ub	r8,r6[0x0]
80005004:	1a d8       	st.w	--sp,r8
80005006:	4b 9c       	lddpc	r12,800050e8 <rfid_sendID_message+0x138>
80005008:	f0 1f 00 39 	mcall	800050ec <rfid_sendID_message+0x13c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
8000500c:	37 7b       	mov	r11,119
8000500e:	30 1c       	mov	r12,1
80005010:	f0 1f 00 38 	mcall	800050f0 <rfid_sendID_message+0x140>
80005014:	fa c8 ff ee 	sub	r8,sp,-18
80005018:	fa c9 ff ec 	sub	r9,sp,-20
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
8000501c:	ec c5 ff fc 	sub	r5,r6,-4
80005020:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005022:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005024:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005026:	0d 8a       	ld.ub	r10,r6[0x0]
80005028:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000502c:	fc 0b 18 00 	cp.b	r11,lr
80005030:	f7 bb 08 d0 	subls	r11,-48
80005034:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005038:	f7 bb 0b a9 	subhi	r11,-87
8000503c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005040:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005042:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005046:	fc 0a 18 00 	cp.b	r10,lr
8000504a:	f7 ba 08 d0 	subls	r10,-48
8000504e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005052:	f7 ba 0b a9 	subhi	r10,-87
80005056:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000505a:	b0 bc       	st.b	r8[0x3],r12
8000505c:	2f f6       	sub	r6,-1
8000505e:	2f c8       	sub	r8,-4
80005060:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005062:	0a 36       	cp.w	r6,r5
80005064:	ce 11       	brne	80005026 <rfid_sendID_message+0x76>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80005066:	4a 48       	lddpc	r8,800050f4 <rfid_sendID_message+0x144>
80005068:	11 89       	ld.ub	r9,r8[0x0]
8000506a:	39 f8       	mov	r8,-97
8000506c:	f0 09 18 00 	cp.b	r9,r8
80005070:	e0 88 00 05 	brls	8000507a <rfid_sendID_message+0xca>
80005074:	38 09       	mov	r9,-128
80005076:	4a 08       	lddpc	r8,800050f4 <rfid_sendID_message+0x144>
80005078:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
8000507a:	49 f8       	lddpc	r8,800050f4 <rfid_sendID_message+0x144>
8000507c:	11 86       	ld.ub	r6,r8[0x0]
8000507e:	2f f6       	sub	r6,-1
80005080:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005082:	30 5a       	mov	r10,5
80005084:	49 db       	lddpc	r11,800050f8 <rfid_sendID_message+0x148>
80005086:	fa cc ff e9 	sub	r12,sp,-23
8000508a:	f0 1f 00 1d 	mcall	800050fc <rfid_sendID_message+0x14c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000508e:	31 88       	mov	r8,24
80005090:	fb 58 00 12 	st.h	sp[18],r8
80005094:	fb 66 00 16 	st.b	sp[22],r6
80005098:	fe 78 e0 00 	mov	r8,-8192
8000509c:	fb 58 00 14 	st.h	sp[20],r8
800050a0:	fa c6 ff e4 	sub	r6,sp,-28
800050a4:	30 aa       	mov	r10,10
800050a6:	fa cb ff ee 	sub	r11,sp,-18
800050aa:	0c 9c       	mov	r12,r6
800050ac:	f0 1f 00 14 	mcall	800050fc <rfid_sendID_message+0x14c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800050b0:	31 0a       	mov	r10,16
800050b2:	fa cb ff fe 	sub	r11,sp,-2
800050b6:	fa cc ff da 	sub	r12,sp,-38
800050ba:	f0 1f 00 11 	mcall	800050fc <rfid_sendID_message+0x14c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800050be:	36 1a       	mov	r10,97
800050c0:	31 ab       	mov	r11,26
800050c2:	0c 9c       	mov	r12,r6
800050c4:	f0 1f 00 0f 	mcall	80005100 <rfid_sendID_message+0x150>
800050c8:	c0 88       	rjmp	800050d8 <rfid_sendID_message+0x128>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800050ca:	37 8b       	mov	r11,120
800050cc:	30 1c       	mov	r12,1
800050ce:	f0 1f 00 09 	mcall	800050f0 <rfid_sendID_message+0x140>
		log("no card find...\n");
800050d2:	48 dc       	lddpc	r12,80005104 <rfid_sendID_message+0x154>
800050d4:	f0 1f 00 06 	mcall	800050ec <rfid_sendID_message+0x13c>
	}
	
	return return_err;
	
}
800050d8:	0e 9c       	mov	r12,r7
800050da:	2e 5d       	sub	sp,-108
800050dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050e0:	00 00       	add	r0,r0
800050e2:	0b 60       	ld.uh	r0,--r5
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	4f 60       	lddpc	r0,800052bc <gpio_enable_module_pin+0x26>
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	d6 d4       	*unknown*
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	6d 3c       	ld.w	r12,r6[0x4c]
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	3f 4c       	mov	r12,-12
800050f4:	00 00       	add	r0,r0
800050f6:	05 30       	ld.ub	r0,r2++
800050f8:	00 00       	add	r0,r0
800050fa:	05 28       	ld.uh	r8,r2++
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	75 b8       	ld.w	r8,r10[0x6c]
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	3e 14       	mov	r4,-31
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	d6 f0       	acall	0x6f

80005108 <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80005108:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000510a:	f0 1f 00 02 	mcall	80005110 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000510e:	d8 02       	popm	pc
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	4a 08       	lddpc	r8,80005190 <local_start_timer+0x14>

80005114 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005114:	58 0c       	cp.w	r12,0
80005116:	5e 0c       	reteq	r12
80005118:	30 08       	mov	r8,0
	{
		nop();
8000511a:	d7 03       	nop
		nop();
8000511c:	d7 03       	nop
		nop();
8000511e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005120:	2f f8       	sub	r8,-1
80005122:	10 3c       	cp.w	r12,r8
80005124:	fe 9b ff fb 	brhi	8000511a <delay_ns+0x6>
80005128:	5e fc       	retal	r12
8000512a:	d7 03       	nop

8000512c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000512c:	eb cd 40 e0 	pushm	r5-r7,lr
80005130:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005132:	58 0c       	cp.w	r12,0
80005134:	c0 b0       	breq	8000514a <delay_us+0x1e>
80005136:	30 07       	mov	r7,0
		delay_ns(1000);
80005138:	e0 65 03 e8 	mov	r5,1000
8000513c:	0a 9c       	mov	r12,r5
8000513e:	f0 1f 00 05 	mcall	80005150 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005142:	2f f7       	sub	r7,-1
80005144:	0e 36       	cp.w	r6,r7
80005146:	fe 9b ff fb 	brhi	8000513c <delay_us+0x10>
8000514a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000514e:	00 00       	add	r0,r0
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	51 14       	stdsp	sp[0x44],r4

80005154 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005154:	eb cd 40 e0 	pushm	r5-r7,lr
80005158:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000515a:	58 0c       	cp.w	r12,0
8000515c:	c0 b0       	breq	80005172 <delay_ms+0x1e>
8000515e:	30 07       	mov	r7,0
		delay_us(1000);
80005160:	e0 65 03 e8 	mov	r5,1000
80005164:	0a 9c       	mov	r12,r5
80005166:	f0 1f 00 05 	mcall	80005178 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000516a:	2f f7       	sub	r7,-1
8000516c:	0e 36       	cp.w	r6,r7
8000516e:	fe 9b ff fb 	brhi	80005164 <delay_ms+0x10>
80005172:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005176:	00 00       	add	r0,r0
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	51 2c       	stdsp	sp[0x48],r12

8000517c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
8000517c:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000517e:	30 3b       	mov	r11,3
80005180:	48 8c       	lddpc	r12,800051a0 <local_start_timer+0x24>
80005182:	f0 1f 00 09 	mcall	800051a4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005186:	fe 78 38 00 	mov	r8,-51200
8000518a:	e0 69 91 0d 	mov	r9,37133
8000518e:	ea 19 00 52 	orh	r9,0x52
80005192:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005194:	32 09       	mov	r9,32
80005196:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005198:	30 59       	mov	r9,5
8000519a:	91 09       	st.w	r8[0x0],r9
}
8000519c:	d8 02       	popm	pc
8000519e:	00 00       	add	r0,r0
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	d7 04       	*unknown*
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	52 e8       	stdsp	sp[0xb8],r8

800051a8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800051a8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800051aa:	30 3a       	mov	r10,3
800051ac:	e0 6b 1b 00 	mov	r11,6912
800051b0:	ea 1b 00 b7 	orh	r11,0xb7
800051b4:	fe 7c 0c 00 	mov	r12,-62464
800051b8:	f0 1f 00 19 	mcall	8000521c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800051bc:	31 08       	mov	r8,16
800051be:	1a d8       	st.w	--sp,r8
800051c0:	30 08       	mov	r8,0
800051c2:	30 19       	mov	r9,1
800051c4:	30 7a       	mov	r10,7
800051c6:	10 9b       	mov	r11,r8
800051c8:	fe 7c 0c 00 	mov	r12,-62464
800051cc:	f0 1f 00 15 	mcall	80005220 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800051d0:	30 08       	mov	r8,0
800051d2:	30 19       	mov	r9,1
800051d4:	12 9a       	mov	r10,r9
800051d6:	10 9b       	mov	r11,r8
800051d8:	fe 7c 0c 00 	mov	r12,-62464
800051dc:	f0 1f 00 12 	mcall	80005224 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
800051e0:	30 0b       	mov	r11,0
800051e2:	fe 7c 0c 00 	mov	r12,-62464
800051e6:	f0 1f 00 11 	mcall	80005228 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800051ea:	fe 7c 0c 00 	mov	r12,-62464
800051ee:	f0 1f 00 10 	mcall	8000522c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800051f2:	30 0a       	mov	r10,0
800051f4:	1a da       	st.w	--sp,r10
800051f6:	1a da       	st.w	--sp,r10
800051f8:	14 98       	mov	r8,r10
800051fa:	14 99       	mov	r9,r10
800051fc:	30 1b       	mov	r11,1
800051fe:	fe 7c 0c 00 	mov	r12,-62464
80005202:	f0 1f 00 0c 	mcall	80005230 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005206:	30 1c       	mov	r12,1
80005208:	f0 1f 00 0b 	mcall	80005234 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000520c:	30 2b       	mov	r11,2
8000520e:	fe 7c 0c 00 	mov	r12,-62464
80005212:	f0 1f 00 0a 	mcall	80005238 <local_start_pll0+0x90>
80005216:	2f dd       	sub	sp,-12
/****/
}
80005218:	d8 02       	popm	pc
8000521a:	00 00       	add	r0,r0
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	55 9c       	stdsp	sp[0x164],r12
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	55 3e       	stdsp	sp[0x14c],lr
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	55 60       	stdsp	sp[0x158],r0
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	55 7a       	stdsp	sp[0x15c],r10
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	55 88       	stdsp	sp[0x160],r8
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	54 f8       	stdsp	sp[0x13c],r8
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	52 88       	stdsp	sp[0xa0],r8
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	55 92       	stdsp	sp[0x164],r2

8000523c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
8000523c:	eb cd 40 e0 	pushm	r5-r7,lr
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
80005240:	30 4b       	mov	r11,4
80005242:	36 4c       	mov	r12,100
80005244:	f0 1f 00 0c 	mcall	80005274 <xg_flashc_init+0x38>
80005248:	48 c8       	lddpc	r8,80005278 <xg_flashc_init+0x3c>
8000524a:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
8000524c:	30 4b       	mov	r11,4
8000524e:	36 4c       	mov	r12,100
80005250:	f0 1f 00 09 	mcall	80005274 <xg_flashc_init+0x38>
80005254:	48 a8       	lddpc	r8,8000527c <xg_flashc_init+0x40>
80005256:	91 0c       	st.w	r8[0x0],r12
80005258:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000525a:	10 96       	mov	r6,r8
8000525c:	48 95       	lddpc	r5,80005280 <xg_flashc_init+0x44>
8000525e:	6c 0c       	ld.w	r12,r6[0x0]
80005260:	ea 07 00 0b 	add	r11,r5,r7
80005264:	f0 1f 00 08 	mcall	80005284 <xg_flashc_init+0x48>
80005268:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000526a:	e0 47 0a 28 	cp.w	r7,2600
8000526e:	cf 81       	brne	8000525e <xg_flashc_init+0x22>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	62 5c       	ld.w	r12,r1[0x14]
80005278:	00 00       	add	r0,r0
8000527a:	0b 6c       	ld.uh	r12,--r5
8000527c:	00 00       	add	r0,r0
8000527e:	0b 70       	ld.ub	r0,--r5
80005280:	00 00       	add	r0,r0
80005282:	51 30       	stdsp	sp[0x4c],r0
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	2a e8       	sub	r8,-82

80005288 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005288:	fe 68 14 00 	mov	r8,-125952
8000528c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000528e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005292:	91 09       	st.w	r8[0x0],r9
}
80005294:	5e fc       	retal	r12

80005296 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005296:	f8 08 16 05 	lsr	r8,r12,0x5
8000529a:	a9 68       	lsl	r8,0x8
8000529c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800052a0:	58 1b       	cp.w	r11,1
800052a2:	c0 d0       	breq	800052bc <gpio_enable_module_pin+0x26>
800052a4:	c0 63       	brcs	800052b0 <gpio_enable_module_pin+0x1a>
800052a6:	58 2b       	cp.w	r11,2
800052a8:	c1 00       	breq	800052c8 <gpio_enable_module_pin+0x32>
800052aa:	58 3b       	cp.w	r11,3
800052ac:	c1 40       	breq	800052d4 <gpio_enable_module_pin+0x3e>
800052ae:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052b0:	30 19       	mov	r9,1
800052b2:	f2 0c 09 49 	lsl	r9,r9,r12
800052b6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052b8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052ba:	c1 28       	rjmp	800052de <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052bc:	30 19       	mov	r9,1
800052be:	f2 0c 09 49 	lsl	r9,r9,r12
800052c2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052c4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052c6:	c0 c8       	rjmp	800052de <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052c8:	30 19       	mov	r9,1
800052ca:	f2 0c 09 49 	lsl	r9,r9,r12
800052ce:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052d0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052d2:	c0 68       	rjmp	800052de <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052d4:	30 19       	mov	r9,1
800052d6:	f2 0c 09 49 	lsl	r9,r9,r12
800052da:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052dc:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800052de:	30 19       	mov	r9,1
800052e0:	f2 0c 09 4c 	lsl	r12,r9,r12
800052e4:	91 2c       	st.w	r8[0x8],r12
800052e6:	5e fd       	retal	0

800052e8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800052e8:	d4 21       	pushm	r4-r7,lr
800052ea:	18 97       	mov	r7,r12
800052ec:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800052ee:	58 0b       	cp.w	r11,0
800052f0:	c0 31       	brne	800052f6 <gpio_enable_module+0xe>
800052f2:	30 05       	mov	r5,0
800052f4:	c0 d8       	rjmp	8000530e <gpio_enable_module+0x26>
800052f6:	30 06       	mov	r6,0
800052f8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800052fa:	6e 1b       	ld.w	r11,r7[0x4]
800052fc:	6e 0c       	ld.w	r12,r7[0x0]
800052fe:	f0 1f 00 06 	mcall	80005314 <gpio_enable_module+0x2c>
80005302:	18 45       	or	r5,r12
		gpiomap++;
80005304:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005306:	2f f6       	sub	r6,-1
80005308:	0c 34       	cp.w	r4,r6
8000530a:	fe 9b ff f8 	brhi	800052fa <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000530e:	0a 9c       	mov	r12,r5
80005310:	d8 22       	popm	r4-r7,pc
80005312:	00 00       	add	r0,r0
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	52 96       	stdsp	sp[0xa4],r6

80005318 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005318:	f8 08 16 05 	lsr	r8,r12,0x5
8000531c:	a9 68       	lsl	r8,0x8
8000531e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005322:	30 19       	mov	r9,1
80005324:	f2 0c 09 4c 	lsl	r12,r9,r12
80005328:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000532c:	91 1c       	st.w	r8[0x4],r12
}
8000532e:	5e fc       	retal	r12

80005330 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005330:	f8 08 16 05 	lsr	r8,r12,0x5
80005334:	a9 68       	lsl	r8,0x8
80005336:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000533a:	30 19       	mov	r9,1
8000533c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005340:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005344:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005348:	91 1c       	st.w	r8[0x4],r12
}
8000534a:	5e fc       	retal	r12

8000534c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000534c:	f8 08 16 05 	lsr	r8,r12,0x5
80005350:	a9 68       	lsl	r8,0x8
80005352:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005356:	30 19       	mov	r9,1
80005358:	f2 0c 09 4c 	lsl	r12,r9,r12
8000535c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005360:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005364:	91 1c       	st.w	r8[0x4],r12
}
80005366:	5e fc       	retal	r12

80005368 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005368:	c0 08       	rjmp	80005368 <_unhandled_interrupt>
8000536a:	d7 03       	nop

8000536c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000536c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005370:	49 99       	lddpc	r9,800053d4 <INTC_register_interrupt+0x68>
80005372:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005376:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000537a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000537c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005380:	58 0a       	cp.w	r10,0
80005382:	c0 91       	brne	80005394 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005384:	49 59       	lddpc	r9,800053d8 <INTC_register_interrupt+0x6c>
80005386:	49 6a       	lddpc	r10,800053dc <INTC_register_interrupt+0x70>
80005388:	12 1a       	sub	r10,r9
8000538a:	fe 79 08 00 	mov	r9,-63488
8000538e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005392:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005394:	58 1a       	cp.w	r10,1
80005396:	c0 a1       	brne	800053aa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005398:	49 09       	lddpc	r9,800053d8 <INTC_register_interrupt+0x6c>
8000539a:	49 2a       	lddpc	r10,800053e0 <INTC_register_interrupt+0x74>
8000539c:	12 1a       	sub	r10,r9
8000539e:	bf aa       	sbr	r10,0x1e
800053a0:	fe 79 08 00 	mov	r9,-63488
800053a4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053a8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800053aa:	58 2a       	cp.w	r10,2
800053ac:	c0 a1       	brne	800053c0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800053ae:	48 b9       	lddpc	r9,800053d8 <INTC_register_interrupt+0x6c>
800053b0:	48 da       	lddpc	r10,800053e4 <INTC_register_interrupt+0x78>
800053b2:	12 1a       	sub	r10,r9
800053b4:	bf ba       	sbr	r10,0x1f
800053b6:	fe 79 08 00 	mov	r9,-63488
800053ba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053be:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800053c0:	48 69       	lddpc	r9,800053d8 <INTC_register_interrupt+0x6c>
800053c2:	48 aa       	lddpc	r10,800053e8 <INTC_register_interrupt+0x7c>
800053c4:	12 1a       	sub	r10,r9
800053c6:	ea 1a c0 00 	orh	r10,0xc000
800053ca:	fe 79 08 00 	mov	r9,-63488
800053ce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053d2:	5e fc       	retal	r12
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	d7 1c       	*unknown*
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	cc 00       	breq	8000535a <gpio_clr_gpio_pin+0xe>
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	cd 04       	brge	8000537e <INTC_register_interrupt+0x12>
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	cd 12       	brcc	80005384 <INTC_register_interrupt+0x18>
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	cd 20       	breq	8000538a <INTC_register_interrupt+0x1e>
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	cd 2e       	rcall	8000518e <local_start_timer+0x12>

800053ec <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800053ec:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800053ee:	49 18       	lddpc	r8,80005430 <INTC_init_interrupts+0x44>
800053f0:	e3 b8 00 01 	mtsr	0x4,r8
800053f4:	49 0e       	lddpc	lr,80005434 <INTC_init_interrupts+0x48>
800053f6:	30 07       	mov	r7,0
800053f8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800053fa:	49 0c       	lddpc	r12,80005438 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053fc:	49 05       	lddpc	r5,8000543c <INTC_init_interrupts+0x50>
800053fe:	10 15       	sub	r5,r8
80005400:	fe 76 08 00 	mov	r6,-63488
80005404:	c1 08       	rjmp	80005424 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005406:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005408:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000540a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000540c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005410:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005412:	10 3a       	cp.w	r10,r8
80005414:	fe 9b ff fc 	brhi	8000540c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005418:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000541c:	2f f7       	sub	r7,-1
8000541e:	2f 8e       	sub	lr,-8
80005420:	59 37       	cp.w	r7,19
80005422:	c0 50       	breq	8000542c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005424:	7c 08       	ld.w	r8,lr[0x0]
80005426:	58 08       	cp.w	r8,0
80005428:	ce f1       	brne	80005406 <INTC_init_interrupts+0x1a>
8000542a:	cf 7b       	rjmp	80005418 <INTC_init_interrupts+0x2c>
8000542c:	d8 22       	popm	r4-r7,pc
8000542e:	00 00       	add	r0,r0
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	cc 00       	breq	800053b2 <INTC_register_interrupt+0x46>
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	d7 1c       	*unknown*
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	53 68       	stdsp	sp[0xd8],r8
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	cd 04       	brge	800053de <INTC_register_interrupt+0x72>

80005440 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005440:	fe 78 08 00 	mov	r8,-63488
80005444:	e0 69 00 83 	mov	r9,131
80005448:	f2 0c 01 0c 	sub	r12,r9,r12
8000544c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005450:	f2 ca ff c0 	sub	r10,r9,-64
80005454:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005458:	58 08       	cp.w	r8,0
8000545a:	c0 21       	brne	8000545e <_get_interrupt_handler+0x1e>
8000545c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000545e:	f0 08 12 00 	clz	r8,r8
80005462:	48 5a       	lddpc	r10,80005474 <_get_interrupt_handler+0x34>
80005464:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005468:	f0 08 11 1f 	rsub	r8,r8,31
8000546c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000546e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005472:	5e fc       	retal	r12
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	d7 1c       	*unknown*

80005478 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005478:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000547a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000547e:	99 a8       	st.w	r12[0x28],r8
}
80005480:	5e fc       	retal	r12
80005482:	d7 03       	nop

80005484 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005484:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005486:	ec 5b bb 9f 	cp.w	r11,899999
8000548a:	e0 8b 00 04 	brhi	80005492 <pm_enable_osc0_crystal+0xe>
8000548e:	30 4b       	mov	r11,4
80005490:	c1 38       	rjmp	800054b6 <pm_enable_osc0_crystal+0x32>
80005492:	e0 68 c6 bf 	mov	r8,50879
80005496:	ea 18 00 2d 	orh	r8,0x2d
8000549a:	10 3b       	cp.w	r11,r8
8000549c:	e0 8b 00 04 	brhi	800054a4 <pm_enable_osc0_crystal+0x20>
800054a0:	30 5b       	mov	r11,5
800054a2:	c0 a8       	rjmp	800054b6 <pm_enable_osc0_crystal+0x32>
800054a4:	e0 68 12 00 	mov	r8,4608
800054a8:	ea 18 00 7a 	orh	r8,0x7a
800054ac:	10 3b       	cp.w	r11,r8
800054ae:	f9 bb 03 06 	movlo	r11,6
800054b2:	f9 bb 02 07 	movhs	r11,7
800054b6:	f0 1f 00 02 	mcall	800054bc <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800054ba:	d8 02       	popm	pc
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	54 78       	stdsp	sp[0x11c],r8

800054c0 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800054c0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800054c2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800054c6:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800054c8:	78 08       	ld.w	r8,r12[0x0]
800054ca:	a3 a8       	sbr	r8,0x2
800054cc:	99 08       	st.w	r12[0x0],r8
}
800054ce:	5e fc       	retal	r12

800054d0 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800054d0:	79 58       	ld.w	r8,r12[0x54]
800054d2:	e2 18 00 80 	andl	r8,0x80,COH
800054d6:	cf d0       	breq	800054d0 <pm_wait_for_clk0_ready>
}
800054d8:	5e fc       	retal	r12
800054da:	d7 03       	nop

800054dc <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800054dc:	eb cd 40 80 	pushm	r7,lr
800054e0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800054e2:	f0 1f 00 04 	mcall	800054f0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800054e6:	0e 9c       	mov	r12,r7
800054e8:	f0 1f 00 03 	mcall	800054f4 <pm_enable_clk0+0x18>
}
800054ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	54 c0       	stdsp	sp[0x130],r0
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	54 d0       	stdsp	sp[0x134],r0

800054f8 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800054f8:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800054fc:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005500:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005502:	09 f7       	ld.ub	r7,r4[0x7]
80005504:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005508:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000550c:	09 b4       	ld.ub	r4,r4[0x3]
8000550e:	08 96       	mov	r6,r4
80005510:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005514:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005518:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000551c:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005520:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005524:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005528:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000552c:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005530:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005532:	79 58       	ld.w	r8,r12[0x54]
80005534:	e2 18 00 20 	andl	r8,0x20,COH
80005538:	cf d0       	breq	80005532 <pm_cksel+0x3a>
}
8000553a:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000553e <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000553e:	eb cd 40 80 	pushm	r7,lr
80005542:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005544:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005546:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000554a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000554e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005552:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005556:	2f 8b       	sub	r11,-8
80005558:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000555c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005560 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005560:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005562:	2f 8b       	sub	r11,-8
80005564:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005568:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000556c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005570:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005574:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005578:	d8 02       	popm	pc

8000557a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000557a:	2f 8b       	sub	r11,-8
8000557c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005580:	a1 a8       	sbr	r8,0x0
80005582:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005586:	5e fc       	retal	r12

80005588 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005588:	79 58       	ld.w	r8,r12[0x54]
8000558a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000558e:	cf d0       	breq	80005588 <pm_wait_for_pll0_locked>
}
80005590:	5e fc       	retal	r12

80005592 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005592:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005594:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005598:	99 08       	st.w	r12[0x0],r8
}
8000559a:	5e fc       	retal	r12

8000559c <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
8000559c:	eb cd 40 c0 	pushm	r6-r7,lr
800055a0:	18 97       	mov	r7,r12
800055a2:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800055a4:	f0 1f 00 06 	mcall	800055bc <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800055a8:	0c 9b       	mov	r11,r6
800055aa:	0e 9c       	mov	r12,r7
800055ac:	f0 1f 00 05 	mcall	800055c0 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800055b0:	30 1b       	mov	r11,1
800055b2:	0e 9c       	mov	r12,r7
800055b4:	f0 1f 00 04 	mcall	800055c4 <pm_switch_to_osc0+0x28>
}
800055b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	54 84       	stdsp	sp[0x120],r4
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	54 dc       	stdsp	sp[0x134],r12
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	55 92       	stdsp	sp[0x164],r2

800055c8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800055c8:	f8 c8 00 01 	sub	r8,r12,1
800055cc:	f0 0b 00 0b 	add	r11,r8,r11
800055d0:	f6 0c 0d 0a 	divu	r10,r11,r12
800055d4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800055d6:	f4 c8 00 01 	sub	r8,r10,1
800055da:	e0 48 00 fe 	cp.w	r8,254
800055de:	e0 88 00 03 	brls	800055e4 <getBaudDiv+0x1c>
800055e2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800055e4:	5c 8c       	casts.h	r12
}
800055e6:	5e fc       	retal	r12

800055e8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800055e8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800055ec:	30 18       	mov	r8,1
800055ee:	f0 09 18 00 	cp.b	r9,r8
800055f2:	e0 88 00 04 	brls	800055fa <spi_initMaster+0x12>
800055f6:	30 2c       	mov	r12,2
800055f8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800055fa:	e0 68 00 80 	mov	r8,128
800055fe:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005600:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005602:	30 19       	mov	r9,1
80005604:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005608:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000560c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005610:	30 09       	mov	r9,0
80005612:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005616:	30 fa       	mov	r10,15
80005618:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000561c:	99 18       	st.w	r12[0x4],r8
8000561e:	5e f9       	retal	r9

80005620 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005620:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005622:	30 18       	mov	r8,1
80005624:	f0 0b 18 00 	cp.b	r11,r8
80005628:	5f be       	srhi	lr
8000562a:	f0 0a 18 00 	cp.b	r10,r8
8000562e:	5f b8       	srhi	r8
80005630:	fd e8 10 08 	or	r8,lr,r8
80005634:	c0 30       	breq	8000563a <spi_selectionMode+0x1a>
80005636:	30 2c       	mov	r12,2
80005638:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000563a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000563c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005640:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005644:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005648:	99 18       	st.w	r12[0x4],r8
8000564a:	d8 0a       	popm	pc,r12=0

8000564c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000564c:	30 18       	mov	r8,1
8000564e:	99 08       	st.w	r12[0x0],r8
}
80005650:	5e fc       	retal	r12

80005652 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005652:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005656:	c0 58       	rjmp	80005660 <spi_write+0xe>
		if (!timeout--) {
80005658:	58 08       	cp.w	r8,0
8000565a:	c0 21       	brne	8000565e <spi_write+0xc>
8000565c:	5e ff       	retal	1
8000565e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005660:	78 49       	ld.w	r9,r12[0x10]
80005662:	e2 19 00 02 	andl	r9,0x2,COH
80005666:	cf 90       	breq	80005658 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005668:	5c 7b       	castu.h	r11
8000566a:	99 3b       	st.w	r12[0xc],r11
8000566c:	5e fd       	retal	0

8000566e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000566e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005672:	c0 58       	rjmp	8000567c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005674:	58 08       	cp.w	r8,0
80005676:	c0 21       	brne	8000567a <spi_read+0xc>
80005678:	5e ff       	retal	1
8000567a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000567c:	78 49       	ld.w	r9,r12[0x10]
8000567e:	e2 19 02 01 	andl	r9,0x201,COH
80005682:	e0 49 02 01 	cp.w	r9,513
80005686:	cf 71       	brne	80005674 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005688:	78 28       	ld.w	r8,r12[0x8]
8000568a:	b6 08       	st.h	r11[0x0],r8
8000568c:	5e fd       	retal	0
8000568e:	d7 03       	nop

80005690 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005690:	eb cd 40 f8 	pushm	r3-r7,lr
80005694:	18 95       	mov	r5,r12
80005696:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005698:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000569c:	30 38       	mov	r8,3
8000569e:	f0 06 18 00 	cp.b	r6,r8
800056a2:	e0 8b 00 5e 	brhi	8000575e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800056a6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056aa:	30 18       	mov	r8,1
800056ac:	f0 04 18 00 	cp.b	r4,r8
800056b0:	e0 8b 00 57 	brhi	8000575e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800056b4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056b8:	30 78       	mov	r8,7
800056ba:	f0 03 18 00 	cp.b	r3,r8
800056be:	e0 88 00 50 	brls	8000575e <spi_setupChipReg+0xce>
800056c2:	31 08       	mov	r8,16
800056c4:	f0 03 18 00 	cp.b	r3,r8
800056c8:	e0 8b 00 4b 	brhi	8000575e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800056cc:	14 9b       	mov	r11,r10
800056ce:	6e 1c       	ld.w	r12,r7[0x4]
800056d0:	f0 1f 00 26 	mcall	80005768 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800056d4:	c4 55       	brlt	8000575e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800056d6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800056d8:	ec 09 16 01 	lsr	r9,r6,0x1
800056dc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800056e0:	ec 16 00 01 	eorl	r6,0x1
800056e4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800056e8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800056ec:	20 83       	sub	r3,8
800056ee:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800056f2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800056f6:	ef 39 00 09 	ld.ub	r9,r7[9]
800056fa:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800056fe:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005702:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005706:	0f 89       	ld.ub	r9,r7[0x0]
80005708:	30 1a       	mov	r10,1
8000570a:	f4 09 18 00 	cp.b	r9,r10
8000570e:	c0 d0       	breq	80005728 <spi_setupChipReg+0x98>
80005710:	c0 a3       	brcs	80005724 <spi_setupChipReg+0x94>
80005712:	30 2a       	mov	r10,2
80005714:	f4 09 18 00 	cp.b	r9,r10
80005718:	c0 a0       	breq	8000572c <spi_setupChipReg+0x9c>
8000571a:	30 3a       	mov	r10,3
8000571c:	f4 09 18 00 	cp.b	r9,r10
80005720:	c1 f1       	brne	8000575e <spi_setupChipReg+0xce>
80005722:	c0 78       	rjmp	80005730 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005724:	8b c8       	st.w	r5[0x30],r8
		break;
80005726:	c0 68       	rjmp	80005732 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005728:	8b d8       	st.w	r5[0x34],r8
		break;
8000572a:	c0 48       	rjmp	80005732 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000572c:	8b e8       	st.w	r5[0x38],r8
		break;
8000572e:	c0 28       	rjmp	80005732 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005730:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005732:	48 f8       	lddpc	r8,8000576c <spi_setupChipReg+0xdc>
80005734:	70 08       	ld.w	r8,r8[0x0]
80005736:	58 08       	cp.w	r8,0
80005738:	c1 61       	brne	80005764 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000573a:	30 0b       	mov	r11,0
8000573c:	30 1c       	mov	r12,1
8000573e:	f0 1f 00 0d 	mcall	80005770 <spi_setupChipReg+0xe0>
80005742:	48 b8       	lddpc	r8,8000576c <spi_setupChipReg+0xdc>
80005744:	91 0c       	st.w	r8[0x0],r12
80005746:	58 0c       	cp.w	r12,0
80005748:	c0 a0       	breq	8000575c <spi_setupChipReg+0xcc>
8000574a:	30 09       	mov	r9,0
8000574c:	12 9a       	mov	r10,r9
8000574e:	12 9b       	mov	r11,r9
80005750:	f0 1f 00 09 	mcall	80005774 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005754:	48 68       	lddpc	r8,8000576c <spi_setupChipReg+0xdc>
80005756:	70 08       	ld.w	r8,r8[0x0]
80005758:	58 08       	cp.w	r8,0
8000575a:	c0 51       	brne	80005764 <spi_setupChipReg+0xd4>
8000575c:	c0 08       	rjmp	8000575c <spi_setupChipReg+0xcc>
8000575e:	30 2c       	mov	r12,2
80005760:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005764:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	55 c8       	stdsp	sp[0x170],r8
8000576c:	00 00       	add	r0,r0
8000576e:	5b 5c       	cp.w	r12,-11
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	62 5c       	ld.w	r12,r1[0x14]
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	61 5c       	ld.w	r12,r0[0x54]

80005778 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005778:	d4 01       	pushm	lr
8000577a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000577e:	c0 58       	rjmp	80005788 <spi_unselectChip+0x10>
		if (!timeout--) {
80005780:	58 08       	cp.w	r8,0
80005782:	c0 21       	brne	80005786 <spi_unselectChip+0xe>
80005784:	da 0a       	popm	pc,r12=1
80005786:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005788:	78 49       	ld.w	r9,r12[0x10]
8000578a:	e2 19 02 00 	andl	r9,0x200,COH
8000578e:	cf 90       	breq	80005780 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005790:	78 18       	ld.w	r8,r12[0x4]
80005792:	ea 18 00 0f 	orh	r8,0xf
80005796:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005798:	fc 18 01 00 	movh	r8,0x100
8000579c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000579e:	30 09       	mov	r9,0
800057a0:	12 9a       	mov	r10,r9
800057a2:	12 9b       	mov	r11,r9
800057a4:	48 38       	lddpc	r8,800057b0 <spi_unselectChip+0x38>
800057a6:	70 0c       	ld.w	r12,r8[0x0]
800057a8:	f0 1f 00 03 	mcall	800057b4 <spi_unselectChip+0x3c>
800057ac:	d8 0a       	popm	pc,r12=0
800057ae:	00 00       	add	r0,r0
800057b0:	00 00       	add	r0,r0
800057b2:	5b 5c       	cp.w	r12,-11
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	61 5c       	ld.w	r12,r0[0x54]

800057b8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057b8:	eb cd 40 f8 	pushm	r3-r7,lr
800057bc:	18 94       	mov	r4,r12
800057be:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800057c0:	49 a6       	lddpc	r6,80005828 <spi_selectChip+0x70>
800057c2:	30 07       	mov	r7,0
800057c4:	31 45       	mov	r5,20
800057c6:	0e 99       	mov	r9,r7
800057c8:	0a 9a       	mov	r10,r5
800057ca:	0e 9b       	mov	r11,r7
800057cc:	6c 0c       	ld.w	r12,r6[0x0]
800057ce:	f0 1f 00 18 	mcall	8000582c <spi_selectChip+0x74>
800057d2:	cf a0       	breq	800057c6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800057d4:	68 18       	ld.w	r8,r4[0x4]
800057d6:	ea 18 00 0f 	orh	r8,0xf
800057da:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800057dc:	68 18       	ld.w	r8,r4[0x4]
800057de:	e2 18 00 04 	andl	r8,0x4,COH
800057e2:	c1 10       	breq	80005804 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800057e4:	30 e8       	mov	r8,14
800057e6:	f0 03 18 00 	cp.b	r3,r8
800057ea:	e0 8b 00 1c 	brhi	80005822 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800057ee:	68 19       	ld.w	r9,r4[0x4]
800057f0:	e6 08 15 10 	lsl	r8,r3,0x10
800057f4:	ea 18 ff f0 	orh	r8,0xfff0
800057f8:	e8 18 ff ff 	orl	r8,0xffff
800057fc:	12 68       	and	r8,r9
800057fe:	89 18       	st.w	r4[0x4],r8
80005800:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005804:	30 38       	mov	r8,3
80005806:	f0 03 18 00 	cp.b	r3,r8
8000580a:	e0 8b 00 0c 	brhi	80005822 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000580e:	68 19       	ld.w	r9,r4[0x4]
80005810:	2f 03       	sub	r3,-16
80005812:	30 18       	mov	r8,1
80005814:	f0 03 09 48 	lsl	r8,r8,r3
80005818:	5c d8       	com	r8
8000581a:	12 68       	and	r8,r9
8000581c:	89 18       	st.w	r4[0x4],r8
8000581e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005822:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005824:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005828:	00 00       	add	r0,r0
8000582a:	5b 5c       	cp.w	r12,-11
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	5f 50       	srlt	r0

80005830 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005830:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005832:	f6 08 15 04 	lsl	r8,r11,0x4
80005836:	14 38       	cp.w	r8,r10
80005838:	f9 b8 08 10 	movls	r8,16
8000583c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005840:	f0 0b 02 4b 	mul	r11,r8,r11
80005844:	f6 09 16 01 	lsr	r9,r11,0x1
80005848:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000584c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005850:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005854:	f2 cb 00 01 	sub	r11,r9,1
80005858:	e0 4b ff fe 	cp.w	r11,65534
8000585c:	e0 88 00 03 	brls	80005862 <usart_set_async_baudrate+0x32>
80005860:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005862:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005864:	e8 6e 00 00 	mov	lr,524288
80005868:	59 08       	cp.w	r8,16
8000586a:	fc 08 17 10 	movne	r8,lr
8000586e:	f9 b8 00 00 	moveq	r8,0
80005872:	e4 1b ff f7 	andh	r11,0xfff7
80005876:	e0 1b fe cf 	andl	r11,0xfecf
8000587a:	16 48       	or	r8,r11
8000587c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000587e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005882:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005886:	99 89       	st.w	r12[0x20],r9
80005888:	d8 0a       	popm	pc,r12=0

8000588a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000588a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000588c:	e2 18 00 02 	andl	r8,0x2,COH
80005890:	c0 31       	brne	80005896 <usart_write_char+0xc>
80005892:	30 2c       	mov	r12,2
80005894:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005896:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000589a:	99 7b       	st.w	r12[0x1c],r11
8000589c:	5e fd       	retal	0
8000589e:	d7 03       	nop

800058a0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800058a0:	eb cd 40 e0 	pushm	r5-r7,lr
800058a4:	18 96       	mov	r6,r12
800058a6:	16 95       	mov	r5,r11
800058a8:	e0 67 27 0f 	mov	r7,9999
800058ac:	c0 68       	rjmp	800058b8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800058ae:	58 07       	cp.w	r7,0
800058b0:	c0 31       	brne	800058b6 <usart_putchar+0x16>
800058b2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800058b6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800058b8:	0a 9b       	mov	r11,r5
800058ba:	0c 9c       	mov	r12,r6
800058bc:	f0 1f 00 03 	mcall	800058c8 <usart_putchar+0x28>
800058c0:	cf 71       	brne	800058ae <usart_putchar+0xe>

  return USART_SUCCESS;
}
800058c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800058c6:	00 00       	add	r0,r0
800058c8:	80 00       	ld.sh	r0,r0[0x0]
800058ca:	58 8a       	cp.w	r10,8

800058cc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800058cc:	78 58       	ld.w	r8,r12[0x14]
800058ce:	e2 18 00 e0 	andl	r8,0xe0,COH
800058d2:	c0 30       	breq	800058d8 <usart_read_char+0xc>
800058d4:	30 4c       	mov	r12,4
800058d6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800058d8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800058da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058de:	c0 31       	brne	800058e4 <usart_read_char+0x18>
800058e0:	30 3c       	mov	r12,3
800058e2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800058e4:	78 68       	ld.w	r8,r12[0x18]
800058e6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800058ea:	97 08       	st.w	r11[0x0],r8
800058ec:	5e fd       	retal	0
800058ee:	d7 03       	nop

800058f0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800058f0:	eb cd 40 c0 	pushm	r6-r7,lr
800058f4:	20 1d       	sub	sp,4
800058f6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800058f8:	1a 97       	mov	r7,sp
800058fa:	1a 9b       	mov	r11,sp
800058fc:	0c 9c       	mov	r12,r6
800058fe:	f0 1f 00 07 	mcall	80005918 <usart_getchar+0x28>
80005902:	58 3c       	cp.w	r12,3
80005904:	cf b0       	breq	800058fa <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005906:	58 4c       	cp.w	r12,4
80005908:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000590c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005910:	2f fd       	sub	sp,-4
80005912:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005916:	00 00       	add	r0,r0
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	58 cc       	cp.w	r12,12

8000591c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000591c:	eb cd 40 c0 	pushm	r6-r7,lr
80005920:	18 96       	mov	r6,r12
80005922:	16 97       	mov	r7,r11
  while (*string != '\0')
80005924:	17 8b       	ld.ub	r11,r11[0x0]
80005926:	58 0b       	cp.w	r11,0
80005928:	c0 80       	breq	80005938 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000592a:	2f f7       	sub	r7,-1
8000592c:	0c 9c       	mov	r12,r6
8000592e:	f0 1f 00 04 	mcall	8000593c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005932:	0f 8b       	ld.ub	r11,r7[0x0]
80005934:	58 0b       	cp.w	r11,0
80005936:	cf a1       	brne	8000592a <usart_write_line+0xe>
80005938:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	58 a0       	cp.w	r0,10

80005940 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005940:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005944:	e6 18 00 01 	andh	r8,0x1,COH
80005948:	c0 71       	brne	80005956 <usart_reset+0x16>
8000594a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000594c:	3f f8       	mov	r8,-1
8000594e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005950:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005952:	d5 03       	csrf	0x10
80005954:	c0 48       	rjmp	8000595c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005956:	3f f8       	mov	r8,-1
80005958:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000595a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000595c:	30 08       	mov	r8,0
8000595e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005960:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005962:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005964:	ea 68 61 0c 	mov	r8,680204
80005968:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000596a:	5e fc       	retal	r12

8000596c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000596c:	eb cd 40 e0 	pushm	r5-r7,lr
80005970:	18 96       	mov	r6,r12
80005972:	16 97       	mov	r7,r11
80005974:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005976:	f0 1f 00 2f 	mcall	80005a30 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000597a:	58 07       	cp.w	r7,0
8000597c:	c5 80       	breq	80005a2c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000597e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005980:	30 49       	mov	r9,4
80005982:	f2 08 18 00 	cp.b	r8,r9
80005986:	e0 88 00 53 	brls	80005a2c <usart_init_rs232+0xc0>
8000598a:	30 99       	mov	r9,9
8000598c:	f2 08 18 00 	cp.b	r8,r9
80005990:	e0 8b 00 4e 	brhi	80005a2c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005994:	0f d9       	ld.ub	r9,r7[0x5]
80005996:	30 78       	mov	r8,7
80005998:	f0 09 18 00 	cp.b	r9,r8
8000599c:	e0 8b 00 48 	brhi	80005a2c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800059a0:	8e 39       	ld.sh	r9,r7[0x6]
800059a2:	e0 68 01 01 	mov	r8,257
800059a6:	f0 09 19 00 	cp.h	r9,r8
800059aa:	e0 8b 00 41 	brhi	80005a2c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800059ae:	ef 39 00 08 	ld.ub	r9,r7[8]
800059b2:	30 38       	mov	r8,3
800059b4:	f0 09 18 00 	cp.b	r9,r8
800059b8:	e0 8b 00 3a 	brhi	80005a2c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800059bc:	0a 9a       	mov	r10,r5
800059be:	6e 0b       	ld.w	r11,r7[0x0]
800059c0:	0c 9c       	mov	r12,r6
800059c2:	f0 1f 00 1d 	mcall	80005a34 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800059c6:	58 1c       	cp.w	r12,1
800059c8:	c3 20       	breq	80005a2c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800059ca:	0f c8       	ld.ub	r8,r7[0x4]
800059cc:	30 99       	mov	r9,9
800059ce:	f2 08 18 00 	cp.b	r8,r9
800059d2:	c0 51       	brne	800059dc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800059d4:	6c 18       	ld.w	r8,r6[0x4]
800059d6:	b1 b8       	sbr	r8,0x11
800059d8:	8d 18       	st.w	r6[0x4],r8
800059da:	c0 68       	rjmp	800059e6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800059dc:	6c 19       	ld.w	r9,r6[0x4]
800059de:	20 58       	sub	r8,5
800059e0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800059e4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800059e6:	6c 19       	ld.w	r9,r6[0x4]
800059e8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800059ec:	0f d8       	ld.ub	r8,r7[0x5]
800059ee:	a9 78       	lsl	r8,0x9
800059f0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800059f4:	12 48       	or	r8,r9
800059f6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800059f8:	8e 38       	ld.sh	r8,r7[0x6]
800059fa:	30 29       	mov	r9,2
800059fc:	f2 08 19 00 	cp.h	r8,r9
80005a00:	e0 88 00 09 	brls	80005a12 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005a04:	6c 18       	ld.w	r8,r6[0x4]
80005a06:	ad b8       	sbr	r8,0xd
80005a08:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005a0a:	8e b8       	ld.uh	r8,r7[0x6]
80005a0c:	20 28       	sub	r8,2
80005a0e:	8d a8       	st.w	r6[0x28],r8
80005a10:	c0 68       	rjmp	80005a1c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005a12:	6c 19       	ld.w	r9,r6[0x4]
80005a14:	5c 78       	castu.h	r8
80005a16:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005a1a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005a1c:	6c 18       	ld.w	r8,r6[0x4]
80005a1e:	e0 18 ff f0 	andl	r8,0xfff0
80005a22:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005a24:	35 08       	mov	r8,80
80005a26:	8d 08       	st.w	r6[0x0],r8
80005a28:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005a2c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 40       	cp.w	r0,20
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	58 30       	cp.w	r0,3

80005a38 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005a38:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005a3c:	fe c0 8e 3c 	sub	r0,pc,-29124

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005a40:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005a44:	d5 53       	csrf	0x15
  cp      r0, r1
80005a46:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005a48:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005a4c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005a4e:	c0 62       	brcc	80005a5a <idata_load_loop_end>
  cp      r0, r1
80005a50:	48 92       	lddpc	r2,80005a74 <udata_clear_loop_end+0x4>

80005a52 <idata_load_loop>:
  brlo    idata_load_loop
80005a52:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005a54:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005a56:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005a58:	cf d3       	brcs	80005a52 <idata_load_loop>

80005a5a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005a5a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005a5e:	e0 61 5b 70 	mov	r1,23408
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005a62:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005a64:	c0 62       	brcc	80005a70 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005a66:	30 02       	mov	r2,0
80005a68:	30 03       	mov	r3,0

80005a6a <udata_clear_loop>:
80005a6a:	a1 22       	st.d	r0++,r2
80005a6c:	02 30       	cp.w	r0,r1
80005a6e:	cf e3       	brcs	80005a6a <udata_clear_loop>

80005a70 <udata_clear_loop_end>:
80005a70:	fe cf e9 80 	sub	pc,pc,-5760
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	e0 50 f8 c8 	cp.w	r0,129224

80005a78 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005a78:	f8 c8 ff f8 	sub	r8,r12,-8
80005a7c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005a7e:	3f f9       	mov	r9,-1
80005a80:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005a82:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005a84:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005a86:	30 08       	mov	r8,0
80005a88:	99 08       	st.w	r12[0x0],r8
}
80005a8a:	5e fc       	retal	r12

80005a8c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005a8c:	30 08       	mov	r8,0
80005a8e:	99 48       	st.w	r12[0x10],r8
}
80005a90:	5e fc       	retal	r12

80005a92 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005a92:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005a94:	70 19       	ld.w	r9,r8[0x4]
80005a96:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005a98:	78 19       	ld.w	r9,r12[0x4]
80005a9a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005a9c:	70 19       	ld.w	r9,r8[0x4]
80005a9e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005aa0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005aa2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005aa4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005aa6:	78 08       	ld.w	r8,r12[0x0]
80005aa8:	2f f8       	sub	r8,-1
80005aaa:	99 08       	st.w	r12[0x0],r8
}
80005aac:	5e fc       	retal	r12

80005aae <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005aae:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005ab0:	5b fa       	cp.w	r10,-1
80005ab2:	c0 31       	brne	80005ab8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ab4:	78 48       	ld.w	r8,r12[0x10]
80005ab6:	c0 c8       	rjmp	80005ace <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ab8:	f8 c8 ff f8 	sub	r8,r12,-8
80005abc:	70 19       	ld.w	r9,r8[0x4]
80005abe:	72 09       	ld.w	r9,r9[0x0]
80005ac0:	12 3a       	cp.w	r10,r9
80005ac2:	c0 63       	brcs	80005ace <vListInsert+0x20>
80005ac4:	70 18       	ld.w	r8,r8[0x4]
80005ac6:	70 19       	ld.w	r9,r8[0x4]
80005ac8:	72 09       	ld.w	r9,r9[0x0]
80005aca:	12 3a       	cp.w	r10,r9
80005acc:	cf c2       	brcc	80005ac4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005ace:	70 19       	ld.w	r9,r8[0x4]
80005ad0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ad2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005ad4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005ad6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ad8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ada:	78 08       	ld.w	r8,r12[0x0]
80005adc:	2f f8       	sub	r8,-1
80005ade:	99 08       	st.w	r12[0x0],r8
}
80005ae0:	5e fc       	retal	r12

80005ae2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ae2:	78 18       	ld.w	r8,r12[0x4]
80005ae4:	78 29       	ld.w	r9,r12[0x8]
80005ae6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ae8:	78 28       	ld.w	r8,r12[0x8]
80005aea:	78 19       	ld.w	r9,r12[0x4]
80005aec:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005aee:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005af0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005af2:	18 39       	cp.w	r9,r12
80005af4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005af8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005afc:	30 09       	mov	r9,0
80005afe:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b00:	70 09       	ld.w	r9,r8[0x0]
80005b02:	20 19       	sub	r9,1
80005b04:	91 09       	st.w	r8[0x0],r9
}
80005b06:	5e fc       	retal	r12

80005b08 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b08:	e0 68 08 08 	mov	r8,2056
80005b0c:	ea 18 08 08 	orh	r8,0x808
80005b10:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b12:	e0 68 09 09 	mov	r8,2313
80005b16:	ea 18 09 09 	orh	r8,0x909
80005b1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005b1c:	e0 68 0a 0a 	mov	r8,2570
80005b20:	ea 18 0a 0a 	orh	r8,0xa0a
80005b24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005b26:	e0 68 0b 0b 	mov	r8,2827
80005b2a:	ea 18 0b 0b 	orh	r8,0xb0b
80005b2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005b30:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005b32:	e0 68 be ef 	mov	r8,48879
80005b36:	ea 18 de ad 	orh	r8,0xdead
80005b3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005b3c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005b3e:	fc 18 00 40 	movh	r8,0x40
80005b42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005b44:	e0 68 00 ff 	mov	r8,255
80005b48:	ea 18 ff 00 	orh	r8,0xff00
80005b4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005b4e:	e0 68 01 01 	mov	r8,257
80005b52:	ea 18 01 01 	orh	r8,0x101
80005b56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005b58:	e0 68 02 02 	mov	r8,514
80005b5c:	ea 18 02 02 	orh	r8,0x202
80005b60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005b62:	e0 68 03 03 	mov	r8,771
80005b66:	ea 18 03 03 	orh	r8,0x303
80005b6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005b6c:	e0 68 04 04 	mov	r8,1028
80005b70:	ea 18 04 04 	orh	r8,0x404
80005b74:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005b76:	e0 68 05 05 	mov	r8,1285
80005b7a:	ea 18 05 05 	orh	r8,0x505
80005b7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005b80:	e0 68 06 06 	mov	r8,1542
80005b84:	ea 18 06 06 	orh	r8,0x606
80005b88:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005b8a:	e0 68 07 07 	mov	r8,1799
80005b8e:	ea 18 07 07 	orh	r8,0x707
80005b92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005b94:	30 08       	mov	r8,0
80005b96:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005b98:	5e fc       	retal	r12
80005b9a:	d7 03       	nop

80005b9c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005b9c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005b9e:	48 38       	lddpc	r8,80005ba8 <vPortEnterCritical+0xc>
80005ba0:	70 09       	ld.w	r9,r8[0x0]
80005ba2:	2f f9       	sub	r9,-1
80005ba4:	91 09       	st.w	r8[0x0],r9
}
80005ba6:	5e fc       	retal	r12
80005ba8:	00 00       	add	r0,r0
80005baa:	05 34       	ld.ub	r4,r2++

80005bac <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005bac:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005bae:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005bb0:	30 0a       	mov	r10,0
80005bb2:	14 9b       	mov	r11,r10
80005bb4:	49 2c       	lddpc	r12,80005bfc <xPortStartScheduler+0x50>
80005bb6:	f0 1f 00 13 	mcall	80005c00 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005bba:	e0 68 5d c0 	mov	r8,24000
80005bbe:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005bc2:	30 08       	mov	r8,0
80005bc4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005bc8:	e0 68 0c ec 	mov	r8,3308
80005bcc:	ea 18 00 00 	orh	r8,0x0
80005bd0:	70 00       	ld.w	r0,r8[0x0]
80005bd2:	60 0d       	ld.w	sp,r0[0x0]
80005bd4:	1b 00       	ld.w	r0,sp++
80005bd6:	e0 68 05 34 	mov	r8,1332
80005bda:	ea 18 00 00 	orh	r8,0x0
80005bde:	91 00       	st.w	r8[0x0],r0
80005be0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005be4:	2f ed       	sub	sp,-8
80005be6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005bea:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005bee:	e3 b0 00 00 	mtsr	0x0,r0
80005bf2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005bf6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005bfa:	d8 0a       	popm	pc,r12=0
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	5c c8       	swap.bh	r8
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	53 6c       	stdsp	sp[0xd8],r12

80005c04 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c04:	20 6d       	sub	sp,24
80005c06:	eb cd 00 ff 	pushm	r0-r7
80005c0a:	fa c7 ff c0 	sub	r7,sp,-64
80005c0e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c12:	ef 40 ff e0 	st.w	r7[-32],r0
80005c16:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c1a:	ef 40 ff e4 	st.w	r7[-28],r0
80005c1e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005c22:	e0 68 05 34 	mov	r8,1332
80005c26:	ea 18 00 00 	orh	r8,0x0
80005c2a:	70 00       	ld.w	r0,r8[0x0]
80005c2c:	1a d0       	st.w	--sp,r0
80005c2e:	f0 1f 00 1a 	mcall	80005c94 <LABEL_RET_SCALL_263+0x14>
80005c32:	e0 68 0c ec 	mov	r8,3308
80005c36:	ea 18 00 00 	orh	r8,0x0
80005c3a:	70 00       	ld.w	r0,r8[0x0]
80005c3c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005c3e:	f0 1f 00 17 	mcall	80005c98 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005c42:	e0 68 0c ec 	mov	r8,3308
80005c46:	ea 18 00 00 	orh	r8,0x0
80005c4a:	70 00       	ld.w	r0,r8[0x0]
80005c4c:	60 0d       	ld.w	sp,r0[0x0]
80005c4e:	1b 00       	ld.w	r0,sp++
80005c50:	e0 68 05 34 	mov	r8,1332
80005c54:	ea 18 00 00 	orh	r8,0x0
80005c58:	91 00       	st.w	r8[0x0],r0
80005c5a:	fa c7 ff d8 	sub	r7,sp,-40
80005c5e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005c62:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005c66:	e0 61 05 34 	mov	r1,1332
80005c6a:	ea 11 00 00 	orh	r1,0x0
80005c6e:	62 02       	ld.w	r2,r1[0x0]
80005c70:	58 02       	cp.w	r2,0
80005c72:	c0 70       	breq	80005c80 <LABEL_RET_SCALL_263>
80005c74:	e4 c2 00 01 	sub	r2,r2,1
80005c78:	83 02       	st.w	r1[0x0],r2
80005c7a:	58 02       	cp.w	r2,0
80005c7c:	c0 21       	brne	80005c80 <LABEL_RET_SCALL_263>
80005c7e:	b1 c0       	cbr	r0,0x10

80005c80 <LABEL_RET_SCALL_263>:
80005c80:	ef 40 ff f8 	st.w	r7[-8],r0
80005c84:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005c88:	ef 40 ff fc 	st.w	r7[-4],r0
80005c8c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c90:	2f ad       	sub	sp,-24
80005c92:	d6 13       	rets
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	5b 9c       	cp.w	r12,-7
80005c98:	80 00       	ld.sh	r0,r0[0x0]
80005c9a:	62 e0       	ld.w	r0,r1[0x38]

80005c9c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005c9c:	e1 b8 00 43 	mfsr	r8,0x10c
80005ca0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005ca4:	5e fc       	retal	r12
80005ca6:	d7 03       	nop

80005ca8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005ca8:	48 78       	lddpc	r8,80005cc4 <vPortExitCritical+0x1c>
80005caa:	70 08       	ld.w	r8,r8[0x0]
80005cac:	58 08       	cp.w	r8,0
80005cae:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005cb0:	48 58       	lddpc	r8,80005cc4 <vPortExitCritical+0x1c>
80005cb2:	70 09       	ld.w	r9,r8[0x0]
80005cb4:	20 19       	sub	r9,1
80005cb6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005cb8:	70 08       	ld.w	r8,r8[0x0]
80005cba:	58 08       	cp.w	r8,0
80005cbc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005cbe:	d5 03       	csrf	0x10
80005cc0:	5e fc       	retal	r12
80005cc2:	00 00       	add	r0,r0
80005cc4:	00 00       	add	r0,r0
80005cc6:	05 34       	ld.ub	r4,r2++

80005cc8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005cc8:	eb cd 00 ff 	pushm	r0-r7
80005ccc:	e0 68 05 34 	mov	r8,1332
80005cd0:	ea 18 00 00 	orh	r8,0x0
80005cd4:	70 00       	ld.w	r0,r8[0x0]
80005cd6:	1a d0       	st.w	--sp,r0
80005cd8:	7a 90       	ld.w	r0,sp[0x24]
80005cda:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005cde:	58 10       	cp.w	r0,1
80005ce0:	e0 8b 00 08 	brhi	80005cf0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005ce4:	e0 68 0c ec 	mov	r8,3308
80005ce8:	ea 18 00 00 	orh	r8,0x0
80005cec:	70 00       	ld.w	r0,r8[0x0]
80005cee:	81 0d       	st.w	r0[0x0],sp

80005cf0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005cf0:	f0 1f 00 12 	mcall	80005d38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005cf4:	f0 1f 00 12 	mcall	80005d3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005cf8:	f0 1f 00 12 	mcall	80005d40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005cfc:	f0 1f 00 12 	mcall	80005d44 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d00:	7a 90       	ld.w	r0,sp[0x24]
80005d02:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d06:	58 10       	cp.w	r0,1
80005d08:	e0 8b 00 0e 	brhi	80005d24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d0c:	f0 1f 00 0c 	mcall	80005d3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d10:	f0 1f 00 0e 	mcall	80005d48 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d14:	f0 1f 00 0c 	mcall	80005d44 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d18:	e0 68 0c ec 	mov	r8,3308
80005d1c:	ea 18 00 00 	orh	r8,0x0
80005d20:	70 00       	ld.w	r0,r8[0x0]
80005d22:	60 0d       	ld.w	sp,r0[0x0]

80005d24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005d24:	1b 00       	ld.w	r0,sp++
80005d26:	e0 68 05 34 	mov	r8,1332
80005d2a:	ea 18 00 00 	orh	r8,0x0
80005d2e:	91 00       	st.w	r8[0x0],r0
80005d30:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d34:	d6 03       	rete
80005d36:	00 00       	add	r0,r0
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	5c 9c       	brev	r12
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	5b 9c       	cp.w	r12,-7
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	64 e4       	ld.w	r4,r2[0x38]
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	5c a8       	swap.h	r8
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	62 e0       	ld.w	r0,r1[0x38]

80005d4c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005d4c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005d4e:	f0 1f 00 02 	mcall	80005d54 <__malloc_lock+0x8>
}
80005d52:	d8 02       	popm	pc
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	62 d0       	ld.w	r0,r1[0x34]

80005d58 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005d58:	d4 01       	pushm	lr
	xTaskResumeAll();
80005d5a:	f0 1f 00 02 	mcall	80005d60 <__malloc_unlock+0x8>
}
80005d5e:	d8 02       	popm	pc
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	66 8c       	ld.w	r12,r3[0x20]

80005d64 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005d64:	d4 21       	pushm	r4-r7,lr
80005d66:	16 95       	mov	r5,r11
80005d68:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005d6a:	58 0c       	cp.w	r12,0
80005d6c:	c0 30       	breq	80005d72 <_read+0xe>
80005d6e:	3f f7       	mov	r7,-1
80005d70:	c1 48       	rjmp	80005d98 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005d72:	58 0a       	cp.w	r10,0
80005d74:	e0 89 00 04 	brgt	80005d7c <_read+0x18>
80005d78:	30 07       	mov	r7,0
80005d7a:	c0 f8       	rjmp	80005d98 <_read+0x34>
80005d7c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005d7e:	48 84       	lddpc	r4,80005d9c <_read+0x38>
80005d80:	68 0c       	ld.w	r12,r4[0x0]
80005d82:	f0 1f 00 08 	mcall	80005da0 <_read+0x3c>
    if (c < 0)
80005d86:	c0 95       	brlt	80005d98 <_read+0x34>
      break;

    *ptr++ = c;
80005d88:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005d8c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005d8e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005d92:	58 08       	cp.w	r8,0
80005d94:	fe 99 ff f6 	brgt	80005d80 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005d98:	0e 9c       	mov	r12,r7
80005d9a:	d8 22       	popm	r4-r7,pc
80005d9c:	00 00       	add	r0,r0
80005d9e:	5b 60       	cp.w	r0,-10
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	58 f0       	cp.w	r0,15

80005da4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005da4:	d4 21       	pushm	r4-r7,lr
80005da6:	16 95       	mov	r5,r11
80005da8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005daa:	20 1c       	sub	r12,1
80005dac:	58 2c       	cp.w	r12,2
80005dae:	e0 8b 00 12 	brhi	80005dd2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005db2:	58 0a       	cp.w	r10,0
80005db4:	c0 31       	brne	80005dba <_write+0x16>
80005db6:	30 07       	mov	r7,0
80005db8:	c0 e8       	rjmp	80005dd4 <_write+0x30>
80005dba:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005dbc:	48 74       	lddpc	r4,80005dd8 <_write+0x34>
80005dbe:	68 0c       	ld.w	r12,r4[0x0]
80005dc0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005dc4:	f0 1f 00 06 	mcall	80005ddc <_write+0x38>
80005dc8:	c0 55       	brlt	80005dd2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005dca:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005dcc:	0e 36       	cp.w	r6,r7
80005dce:	cf 81       	brne	80005dbe <_write+0x1a>
80005dd0:	c0 28       	rjmp	80005dd4 <_write+0x30>
80005dd2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005dd4:	0e 9c       	mov	r12,r7
80005dd6:	d8 22       	popm	r4-r7,pc
80005dd8:	00 00       	add	r0,r0
80005dda:	5b 60       	cp.w	r0,-10
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	58 a0       	cp.w	r0,10

80005de0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005de0:	eb cd 40 80 	pushm	r7,lr
80005de4:	18 97       	mov	r7,r12
	if( pv )
80005de6:	58 0c       	cp.w	r12,0
80005de8:	c0 80       	breq	80005df8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005dea:	f0 1f 00 05 	mcall	80005dfc <vPortFree+0x1c>
		{
			free( pv );
80005dee:	0e 9c       	mov	r12,r7
80005df0:	f0 1f 00 04 	mcall	80005e00 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005df4:	f0 1f 00 04 	mcall	80005e04 <vPortFree+0x24>
80005df8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	62 d0       	ld.w	r0,r1[0x34]
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	71 60       	ld.w	r0,r8[0x58]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	66 8c       	ld.w	r12,r3[0x20]

80005e08 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e08:	eb cd 40 80 	pushm	r7,lr
80005e0c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e0e:	f0 1f 00 06 	mcall	80005e24 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e12:	0e 9c       	mov	r12,r7
80005e14:	f0 1f 00 05 	mcall	80005e28 <pvPortMalloc+0x20>
80005e18:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e1a:	f0 1f 00 05 	mcall	80005e2c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005e1e:	0e 9c       	mov	r12,r7
80005e20:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	62 d0       	ld.w	r0,r1[0x34]
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	71 70       	ld.w	r0,r8[0x5c]
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	66 8c       	ld.w	r12,r3[0x20]

80005e30 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005e30:	d4 01       	pushm	lr
80005e32:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005e34:	78 09       	ld.w	r9,r12[0x0]
80005e36:	58 09       	cp.w	r9,0
80005e38:	c1 10       	breq	80005e5a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005e3a:	78 3a       	ld.w	r10,r12[0xc]
80005e3c:	79 09       	ld.w	r9,r12[0x40]
80005e3e:	f4 09 00 09 	add	r9,r10,r9
80005e42:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005e44:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005e46:	14 39       	cp.w	r9,r10
80005e48:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005e4c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005e50:	79 0a       	ld.w	r10,r12[0x40]
80005e52:	78 3b       	ld.w	r11,r12[0xc]
80005e54:	10 9c       	mov	r12,r8
80005e56:	f0 1f 00 02 	mcall	80005e5c <prvCopyDataFromQueue+0x2c>
80005e5a:	d8 02       	popm	pc
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	75 b8       	ld.w	r8,r10[0x6c]

80005e60 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005e60:	eb cd 40 c0 	pushm	r6-r7,lr
80005e64:	18 97       	mov	r7,r12
80005e66:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e68:	78 e8       	ld.w	r8,r12[0x38]
80005e6a:	58 08       	cp.w	r8,0
80005e6c:	c0 31       	brne	80005e72 <xQueueReceiveFromISR+0x12>
80005e6e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e72:	f0 1f 00 0e 	mcall	80005ea8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005e76:	6e e8       	ld.w	r8,r7[0x38]
80005e78:	20 18       	sub	r8,1
80005e7a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005e7c:	6f 18       	ld.w	r8,r7[0x44]
80005e7e:	5b f8       	cp.w	r8,-1
80005e80:	c0 d1       	brne	80005e9a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e82:	6e 48       	ld.w	r8,r7[0x10]
80005e84:	58 08       	cp.w	r8,0
80005e86:	c0 f0       	breq	80005ea4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005e88:	ee cc ff f0 	sub	r12,r7,-16
80005e8c:	f0 1f 00 08 	mcall	80005eac <xQueueReceiveFromISR+0x4c>
80005e90:	c0 a0       	breq	80005ea4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005e92:	30 1c       	mov	r12,1
80005e94:	8d 0c       	st.w	r6[0x0],r12
80005e96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005e9a:	2f f8       	sub	r8,-1
80005e9c:	ef 48 00 44 	st.w	r7[68],r8
80005ea0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ea4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	5e 30       	retlo	r0
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	64 68       	ld.w	r8,r2[0x18]

80005eb0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005eb0:	eb cd 40 c0 	pushm	r6-r7,lr
80005eb4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005eb6:	f0 1f 00 23 	mcall	80005f40 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005eba:	6f 28       	ld.w	r8,r7[0x48]
80005ebc:	58 08       	cp.w	r8,0
80005ebe:	e0 8a 00 18 	brle	80005eee <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ec2:	6e 98       	ld.w	r8,r7[0x24]
80005ec4:	58 08       	cp.w	r8,0
80005ec6:	c1 40       	breq	80005eee <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ec8:	ee c6 ff dc 	sub	r6,r7,-36
80005ecc:	c0 48       	rjmp	80005ed4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ece:	6e 98       	ld.w	r8,r7[0x24]
80005ed0:	58 08       	cp.w	r8,0
80005ed2:	c0 e0       	breq	80005eee <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ed4:	0c 9c       	mov	r12,r6
80005ed6:	f0 1f 00 1c 	mcall	80005f44 <prvUnlockQueue+0x94>
80005eda:	c0 30       	breq	80005ee0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005edc:	f0 1f 00 1b 	mcall	80005f48 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005ee0:	6f 28       	ld.w	r8,r7[0x48]
80005ee2:	20 18       	sub	r8,1
80005ee4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005ee8:	58 08       	cp.w	r8,0
80005eea:	fe 99 ff f2 	brgt	80005ece <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005eee:	3f f8       	mov	r8,-1
80005ef0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005ef4:	f0 1f 00 16 	mcall	80005f4c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005ef8:	f0 1f 00 12 	mcall	80005f40 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005efc:	6f 18       	ld.w	r8,r7[0x44]
80005efe:	58 08       	cp.w	r8,0
80005f00:	e0 8a 00 18 	brle	80005f30 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f04:	6e 48       	ld.w	r8,r7[0x10]
80005f06:	58 08       	cp.w	r8,0
80005f08:	c1 40       	breq	80005f30 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f0a:	ee c6 ff f0 	sub	r6,r7,-16
80005f0e:	c0 48       	rjmp	80005f16 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f10:	6e 48       	ld.w	r8,r7[0x10]
80005f12:	58 08       	cp.w	r8,0
80005f14:	c0 e0       	breq	80005f30 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f16:	0c 9c       	mov	r12,r6
80005f18:	f0 1f 00 0b 	mcall	80005f44 <prvUnlockQueue+0x94>
80005f1c:	c0 30       	breq	80005f22 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005f1e:	f0 1f 00 0b 	mcall	80005f48 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005f22:	6f 18       	ld.w	r8,r7[0x44]
80005f24:	20 18       	sub	r8,1
80005f26:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f2a:	58 08       	cp.w	r8,0
80005f2c:	fe 99 ff f2 	brgt	80005f10 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005f30:	3f f8       	mov	r8,-1
80005f32:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005f36:	f0 1f 00 06 	mcall	80005f4c <prvUnlockQueue+0x9c>
}
80005f3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f3e:	00 00       	add	r0,r0
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	5b 9c       	cp.w	r12,-7
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	64 68       	ld.w	r8,r2[0x18]
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	63 74       	ld.w	r4,r1[0x5c]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	5c a8       	swap.h	r8

80005f50 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005f50:	d4 31       	pushm	r0-r7,lr
80005f52:	20 5d       	sub	sp,20
80005f54:	18 97       	mov	r7,r12
80005f56:	50 0b       	stdsp	sp[0x0],r11
80005f58:	50 2a       	stdsp	sp[0x8],r10
80005f5a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f5c:	f8 c2 ff dc 	sub	r2,r12,-36
80005f60:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005f62:	fa c4 ff f4 	sub	r4,sp,-12
80005f66:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005f68:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f6a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005f6e:	f0 1f 00 3e 	mcall	80006064 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f72:	6e e8       	ld.w	r8,r7[0x38]
80005f74:	58 08       	cp.w	r8,0
80005f76:	c2 a0       	breq	80005fca <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005f78:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f7a:	40 0b       	lddsp	r11,sp[0x0]
80005f7c:	0e 9c       	mov	r12,r7
80005f7e:	f0 1f 00 3b 	mcall	80006068 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005f82:	40 18       	lddsp	r8,sp[0x4]
80005f84:	58 08       	cp.w	r8,0
80005f86:	c1 51       	brne	80005fb0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005f88:	6e e8       	ld.w	r8,r7[0x38]
80005f8a:	20 18       	sub	r8,1
80005f8c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005f8e:	6e 08       	ld.w	r8,r7[0x0]
80005f90:	58 08       	cp.w	r8,0
80005f92:	c0 41       	brne	80005f9a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005f94:	f0 1f 00 36 	mcall	8000606c <xQueueGenericReceive+0x11c>
80005f98:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f9a:	6e 48       	ld.w	r8,r7[0x10]
80005f9c:	58 08       	cp.w	r8,0
80005f9e:	c1 20       	breq	80005fc2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005fa0:	ee cc ff f0 	sub	r12,r7,-16
80005fa4:	f0 1f 00 33 	mcall	80006070 <xQueueGenericReceive+0x120>
80005fa8:	58 1c       	cp.w	r12,1
80005faa:	c0 c1       	brne	80005fc2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005fac:	d7 33       	scall
80005fae:	c0 a8       	rjmp	80005fc2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005fb0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fb2:	6e 98       	ld.w	r8,r7[0x24]
80005fb4:	58 08       	cp.w	r8,0
80005fb6:	c0 60       	breq	80005fc2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fb8:	04 9c       	mov	r12,r2
80005fba:	f0 1f 00 2e 	mcall	80006070 <xQueueGenericReceive+0x120>
80005fbe:	c0 20       	breq	80005fc2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005fc0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005fc2:	f0 1f 00 2d 	mcall	80006074 <xQueueGenericReceive+0x124>
80005fc6:	30 1c       	mov	r12,1
				return pdPASS;
80005fc8:	c4 c8       	rjmp	80006060 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005fca:	40 28       	lddsp	r8,sp[0x8]
80005fcc:	58 08       	cp.w	r8,0
80005fce:	c0 51       	brne	80005fd8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005fd0:	f0 1f 00 29 	mcall	80006074 <xQueueGenericReceive+0x124>
80005fd4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005fd6:	c4 58       	rjmp	80006060 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005fd8:	58 05       	cp.w	r5,0
80005fda:	c0 51       	brne	80005fe4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fdc:	08 9c       	mov	r12,r4
80005fde:	f0 1f 00 27 	mcall	80006078 <xQueueGenericReceive+0x128>
80005fe2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005fe4:	f0 1f 00 24 	mcall	80006074 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005fe8:	f0 1f 00 25 	mcall	8000607c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005fec:	f0 1f 00 1e 	mcall	80006064 <xQueueGenericReceive+0x114>
80005ff0:	6f 18       	ld.w	r8,r7[0x44]
80005ff2:	5b f8       	cp.w	r8,-1
80005ff4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ff8:	6f 28       	ld.w	r8,r7[0x48]
80005ffa:	5b f8       	cp.w	r8,-1
80005ffc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006000:	f0 1f 00 1d 	mcall	80006074 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006004:	06 9b       	mov	r11,r3
80006006:	08 9c       	mov	r12,r4
80006008:	f0 1f 00 1e 	mcall	80006080 <xQueueGenericReceive+0x130>
8000600c:	c2 41       	brne	80006054 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000600e:	f0 1f 00 16 	mcall	80006064 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006012:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006014:	f0 1f 00 18 	mcall	80006074 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006018:	58 06       	cp.w	r6,0
8000601a:	c1 71       	brne	80006048 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000601c:	6e 08       	ld.w	r8,r7[0x0]
8000601e:	58 08       	cp.w	r8,0
80006020:	c0 81       	brne	80006030 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006022:	f0 1f 00 11 	mcall	80006064 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006026:	6e 1c       	ld.w	r12,r7[0x4]
80006028:	f0 1f 00 17 	mcall	80006084 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000602c:	f0 1f 00 12 	mcall	80006074 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006030:	40 2b       	lddsp	r11,sp[0x8]
80006032:	04 9c       	mov	r12,r2
80006034:	f0 1f 00 15 	mcall	80006088 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006038:	0e 9c       	mov	r12,r7
8000603a:	f0 1f 00 15 	mcall	8000608c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000603e:	f0 1f 00 15 	mcall	80006090 <xQueueGenericReceive+0x140>
80006042:	c9 61       	brne	80005f6e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006044:	d7 33       	scall
80006046:	c9 4b       	rjmp	80005f6e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006048:	0e 9c       	mov	r12,r7
8000604a:	f0 1f 00 11 	mcall	8000608c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000604e:	f0 1f 00 11 	mcall	80006090 <xQueueGenericReceive+0x140>
80006052:	c8 eb       	rjmp	80005f6e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006054:	0e 9c       	mov	r12,r7
80006056:	f0 1f 00 0e 	mcall	8000608c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000605a:	f0 1f 00 0e 	mcall	80006090 <xQueueGenericReceive+0x140>
8000605e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006060:	2f bd       	sub	sp,-20
80006062:	d8 32       	popm	r0-r7,pc
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	5b 9c       	cp.w	r12,-7
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	5e 30       	retlo	r0
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	63 80       	ld.w	r0,r1[0x60]
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	64 68       	ld.w	r8,r2[0x18]
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	5c a8       	swap.h	r8
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	63 5c       	ld.w	r12,r1[0x54]
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	62 d0       	ld.w	r0,r1[0x34]
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	65 f8       	ld.w	r8,r2[0x7c]
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	63 e4       	ld.w	r4,r1[0x78]
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	68 98       	ld.w	r8,r4[0x24]
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	5e b0       	rethi	r0
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	66 8c       	ld.w	r12,r3[0x20]

80006094 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006094:	eb cd 40 80 	pushm	r7,lr
80006098:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000609a:	79 08       	ld.w	r8,r12[0x40]
8000609c:	58 08       	cp.w	r8,0
8000609e:	c0 a1       	brne	800060b2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060a0:	78 08       	ld.w	r8,r12[0x0]
800060a2:	58 08       	cp.w	r8,0
800060a4:	c2 b1       	brne	800060fa <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800060a6:	78 1c       	ld.w	r12,r12[0x4]
800060a8:	f0 1f 00 17 	mcall	80006104 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800060ac:	30 08       	mov	r8,0
800060ae:	8f 18       	st.w	r7[0x4],r8
800060b0:	c2 58       	rjmp	800060fa <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800060b2:	58 0a       	cp.w	r10,0
800060b4:	c1 01       	brne	800060d4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060b6:	10 9a       	mov	r10,r8
800060b8:	78 2c       	ld.w	r12,r12[0x8]
800060ba:	f0 1f 00 14 	mcall	80006108 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800060be:	6e 29       	ld.w	r9,r7[0x8]
800060c0:	6f 08       	ld.w	r8,r7[0x40]
800060c2:	f2 08 00 08 	add	r8,r9,r8
800060c6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800060c8:	6e 19       	ld.w	r9,r7[0x4]
800060ca:	12 38       	cp.w	r8,r9
800060cc:	c1 73       	brcs	800060fa <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800060ce:	6e 08       	ld.w	r8,r7[0x0]
800060d0:	8f 28       	st.w	r7[0x8],r8
800060d2:	c1 48       	rjmp	800060fa <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060d4:	10 9a       	mov	r10,r8
800060d6:	78 3c       	ld.w	r12,r12[0xc]
800060d8:	f0 1f 00 0c 	mcall	80006108 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800060dc:	6f 08       	ld.w	r8,r7[0x40]
800060de:	6e 39       	ld.w	r9,r7[0xc]
800060e0:	f2 08 01 08 	sub	r8,r9,r8
800060e4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800060e6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800060e8:	12 38       	cp.w	r8,r9
800060ea:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800060ee:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800060f2:	f3 d8 e3 19 	subcs	r9,r9,r8
800060f6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800060fa:	6e e8       	ld.w	r8,r7[0x38]
800060fc:	2f f8       	sub	r8,-1
800060fe:	8f e8       	st.w	r7[0x38],r8
}
80006100:	e3 cd 80 80 	ldm	sp++,r7,pc
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	63 8c       	ld.w	r12,r1[0x60]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	75 b8       	ld.w	r8,r10[0x6c]

8000610c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000610c:	eb cd 40 c0 	pushm	r6-r7,lr
80006110:	18 97       	mov	r7,r12
80006112:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006114:	78 ec       	ld.w	r12,r12[0x38]
80006116:	6e f8       	ld.w	r8,r7[0x3c]
80006118:	10 3c       	cp.w	r12,r8
8000611a:	c0 33       	brcs	80006120 <xQueueGenericSendFromISR+0x14>
8000611c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006120:	12 9a       	mov	r10,r9
80006122:	0e 9c       	mov	r12,r7
80006124:	f0 1f 00 0c 	mcall	80006154 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006128:	6f 28       	ld.w	r8,r7[0x48]
8000612a:	5b f8       	cp.w	r8,-1
8000612c:	c0 d1       	brne	80006146 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000612e:	6e 98       	ld.w	r8,r7[0x24]
80006130:	58 08       	cp.w	r8,0
80006132:	c0 f0       	breq	80006150 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006134:	ee cc ff dc 	sub	r12,r7,-36
80006138:	f0 1f 00 08 	mcall	80006158 <xQueueGenericSendFromISR+0x4c>
8000613c:	c0 a0       	breq	80006150 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000613e:	30 1c       	mov	r12,1
80006140:	8d 0c       	st.w	r6[0x0],r12
80006142:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006146:	2f f8       	sub	r8,-1
80006148:	ef 48 00 48 	st.w	r7[72],r8
8000614c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006150:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	60 94       	ld.w	r4,r0[0x24]
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	64 68       	ld.w	r8,r2[0x18]

8000615c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000615c:	d4 31       	pushm	r0-r7,lr
8000615e:	20 5d       	sub	sp,20
80006160:	18 97       	mov	r7,r12
80006162:	50 0b       	stdsp	sp[0x0],r11
80006164:	50 2a       	stdsp	sp[0x8],r10
80006166:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006168:	f8 c0 ff f0 	sub	r0,r12,-16
8000616c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000616e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006172:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006174:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006178:	f0 1f 00 2f 	mcall	80006234 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000617c:	6e e9       	ld.w	r9,r7[0x38]
8000617e:	6e f8       	ld.w	r8,r7[0x3c]
80006180:	10 39       	cp.w	r9,r8
80006182:	c1 42       	brcc	800061aa <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006184:	40 1a       	lddsp	r10,sp[0x4]
80006186:	40 0b       	lddsp	r11,sp[0x0]
80006188:	0e 9c       	mov	r12,r7
8000618a:	f0 1f 00 2c 	mcall	80006238 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000618e:	6e 98       	ld.w	r8,r7[0x24]
80006190:	58 08       	cp.w	r8,0
80006192:	c0 80       	breq	800061a2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006194:	ee cc ff dc 	sub	r12,r7,-36
80006198:	f0 1f 00 29 	mcall	8000623c <xQueueGenericSend+0xe0>
8000619c:	58 1c       	cp.w	r12,1
8000619e:	c0 21       	brne	800061a2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800061a0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800061a2:	f0 1f 00 28 	mcall	80006240 <xQueueGenericSend+0xe4>
800061a6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800061a8:	c4 38       	rjmp	8000622e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800061aa:	40 28       	lddsp	r8,sp[0x8]
800061ac:	58 08       	cp.w	r8,0
800061ae:	c0 51       	brne	800061b8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800061b0:	f0 1f 00 24 	mcall	80006240 <xQueueGenericSend+0xe4>
800061b4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800061b6:	c3 c8       	rjmp	8000622e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800061b8:	58 04       	cp.w	r4,0
800061ba:	c0 51       	brne	800061c4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061bc:	06 9c       	mov	r12,r3
800061be:	f0 1f 00 22 	mcall	80006244 <xQueueGenericSend+0xe8>
800061c2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800061c4:	f0 1f 00 1f 	mcall	80006240 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061c8:	f0 1f 00 20 	mcall	80006248 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800061cc:	f0 1f 00 1a 	mcall	80006234 <xQueueGenericSend+0xd8>
800061d0:	6f 18       	ld.w	r8,r7[0x44]
800061d2:	5b f8       	cp.w	r8,-1
800061d4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800061d8:	6f 28       	ld.w	r8,r7[0x48]
800061da:	5b f8       	cp.w	r8,-1
800061dc:	ef f1 0a 12 	st.weq	r7[0x48],r1
800061e0:	f0 1f 00 18 	mcall	80006240 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061e4:	04 9b       	mov	r11,r2
800061e6:	06 9c       	mov	r12,r3
800061e8:	f0 1f 00 19 	mcall	8000624c <xQueueGenericSend+0xf0>
800061ec:	c1 b1       	brne	80006222 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800061ee:	f0 1f 00 12 	mcall	80006234 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800061f2:	6e e5       	ld.w	r5,r7[0x38]
800061f4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800061f6:	f0 1f 00 13 	mcall	80006240 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800061fa:	0c 35       	cp.w	r5,r6
800061fc:	c0 d1       	brne	80006216 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061fe:	40 2b       	lddsp	r11,sp[0x8]
80006200:	00 9c       	mov	r12,r0
80006202:	f0 1f 00 14 	mcall	80006250 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006206:	0e 9c       	mov	r12,r7
80006208:	f0 1f 00 13 	mcall	80006254 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000620c:	f0 1f 00 13 	mcall	80006258 <xQueueGenericSend+0xfc>
80006210:	cb 41       	brne	80006178 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006212:	d7 33       	scall
80006214:	cb 2b       	rjmp	80006178 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006216:	0e 9c       	mov	r12,r7
80006218:	f0 1f 00 0f 	mcall	80006254 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000621c:	f0 1f 00 0f 	mcall	80006258 <xQueueGenericSend+0xfc>
80006220:	ca cb       	rjmp	80006178 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006222:	0e 9c       	mov	r12,r7
80006224:	f0 1f 00 0c 	mcall	80006254 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006228:	f0 1f 00 0c 	mcall	80006258 <xQueueGenericSend+0xfc>
8000622c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000622e:	2f bd       	sub	sp,-20
80006230:	d8 32       	popm	r0-r7,pc
80006232:	00 00       	add	r0,r0
80006234:	80 00       	ld.sh	r0,r0[0x0]
80006236:	5b 9c       	cp.w	r12,-7
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	60 94       	ld.w	r4,r0[0x24]
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	64 68       	ld.w	r8,r2[0x18]
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	5c a8       	swap.h	r8
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	63 5c       	ld.w	r12,r1[0x54]
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	62 d0       	ld.w	r0,r1[0x34]
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	65 f8       	ld.w	r8,r2[0x7c]
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	68 98       	ld.w	r8,r4[0x24]
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	5e b0       	rethi	r0
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	66 8c       	ld.w	r12,r3[0x20]

8000625c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000625c:	d4 21       	pushm	r4-r7,lr
8000625e:	18 97       	mov	r7,r12
80006260:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006262:	58 0c       	cp.w	r12,0
80006264:	c2 f0       	breq	800062c2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006266:	34 cc       	mov	r12,76
80006268:	f0 1f 00 17 	mcall	800062c4 <xQueueCreate+0x68>
8000626c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000626e:	c2 a0       	breq	800062c2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006270:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006274:	e8 cc ff ff 	sub	r12,r4,-1
80006278:	f0 1f 00 13 	mcall	800062c4 <xQueueCreate+0x68>
8000627c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000627e:	c1 e0       	breq	800062ba <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006280:	f8 04 00 04 	add	r4,r12,r4
80006284:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006286:	30 08       	mov	r8,0
80006288:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000628a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000628c:	ee c8 00 01 	sub	r8,r7,1
80006290:	ad 38       	mul	r8,r6
80006292:	10 0c       	add	r12,r8
80006294:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006296:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006298:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000629c:	3f f8       	mov	r8,-1
8000629e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800062a2:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800062a6:	ea cc ff f0 	sub	r12,r5,-16
800062aa:	f0 1f 00 08 	mcall	800062c8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800062ae:	ea cc ff dc 	sub	r12,r5,-36
800062b2:	f0 1f 00 06 	mcall	800062c8 <xQueueCreate+0x6c>
800062b6:	0a 9c       	mov	r12,r5
800062b8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800062ba:	0a 9c       	mov	r12,r5
800062bc:	f0 1f 00 04 	mcall	800062cc <xQueueCreate+0x70>
800062c0:	d8 2a       	popm	r4-r7,pc,r12=0
800062c2:	d8 2a       	popm	r4-r7,pc,r12=0
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	5e 08       	reteq	r8
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	5a 78       	cp.w	r8,-25
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	5d e0       	*unknown*

800062d0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800062d0:	48 38       	lddpc	r8,800062dc <vTaskSuspendAll+0xc>
800062d2:	70 09       	ld.w	r9,r8[0x0]
800062d4:	2f f9       	sub	r9,-1
800062d6:	91 09       	st.w	r8[0x0],r9
}
800062d8:	5e fc       	retal	r12
800062da:	00 00       	add	r0,r0
800062dc:	00 00       	add	r0,r0
800062de:	0d 1c       	ld.sh	r12,r6++

800062e0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800062e0:	49 a8       	lddpc	r8,80006348 <vTaskSwitchContext+0x68>
800062e2:	70 08       	ld.w	r8,r8[0x0]
800062e4:	58 08       	cp.w	r8,0
800062e6:	c0 b1       	brne	800062fc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062e8:	49 98       	lddpc	r8,8000634c <vTaskSwitchContext+0x6c>
800062ea:	70 08       	ld.w	r8,r8[0x0]
800062ec:	f0 08 00 28 	add	r8,r8,r8<<0x2
800062f0:	49 89       	lddpc	r9,80006350 <vTaskSwitchContext+0x70>
800062f2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800062f6:	58 08       	cp.w	r8,0
800062f8:	c0 60       	breq	80006304 <vTaskSwitchContext+0x24>
800062fa:	c1 18       	rjmp	8000631c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800062fc:	30 19       	mov	r9,1
800062fe:	49 68       	lddpc	r8,80006354 <vTaskSwitchContext+0x74>
80006300:	91 09       	st.w	r8[0x0],r9
80006302:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006304:	49 28       	lddpc	r8,8000634c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006306:	49 3a       	lddpc	r10,80006350 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006308:	70 09       	ld.w	r9,r8[0x0]
8000630a:	20 19       	sub	r9,1
8000630c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000630e:	70 09       	ld.w	r9,r8[0x0]
80006310:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006314:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006318:	58 09       	cp.w	r9,0
8000631a:	cf 70       	breq	80006308 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000631c:	48 c8       	lddpc	r8,8000634c <vTaskSwitchContext+0x6c>
8000631e:	70 08       	ld.w	r8,r8[0x0]
80006320:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006324:	48 b9       	lddpc	r9,80006350 <vTaskSwitchContext+0x70>
80006326:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000632a:	70 19       	ld.w	r9,r8[0x4]
8000632c:	72 19       	ld.w	r9,r9[0x4]
8000632e:	91 19       	st.w	r8[0x4],r9
80006330:	f0 ca ff f8 	sub	r10,r8,-8
80006334:	14 39       	cp.w	r9,r10
80006336:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000633a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000633e:	70 18       	ld.w	r8,r8[0x4]
80006340:	70 39       	ld.w	r9,r8[0xc]
80006342:	48 68       	lddpc	r8,80006358 <vTaskSwitchContext+0x78>
80006344:	91 09       	st.w	r8[0x0],r9
80006346:	5e fc       	retal	r12
80006348:	00 00       	add	r0,r0
8000634a:	0d 1c       	ld.sh	r12,r6++
8000634c:	00 00       	add	r0,r0
8000634e:	0d 54       	ld.sh	r4,--r6
80006350:	00 00       	add	r0,r0
80006352:	0c 38       	cp.w	r8,r6
80006354:	00 00       	add	r0,r0
80006356:	0d 3c       	ld.ub	r12,r6++
80006358:	00 00       	add	r0,r0
8000635a:	0c ec       	st.h	--r6,r12

8000635c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000635c:	48 48       	lddpc	r8,8000636c <vTaskSetTimeOutState+0x10>
8000635e:	70 08       	ld.w	r8,r8[0x0]
80006360:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006362:	48 48       	lddpc	r8,80006370 <vTaskSetTimeOutState+0x14>
80006364:	70 08       	ld.w	r8,r8[0x0]
80006366:	99 18       	st.w	r12[0x4],r8
}
80006368:	5e fc       	retal	r12
8000636a:	00 00       	add	r0,r0
8000636c:	00 00       	add	r0,r0
8000636e:	0c 30       	cp.w	r0,r6
80006370:	00 00       	add	r0,r0
80006372:	0d 18       	ld.sh	r8,r6++

80006374 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006374:	30 19       	mov	r9,1
80006376:	48 28       	lddpc	r8,8000637c <vTaskMissedYield+0x8>
80006378:	91 09       	st.w	r8[0x0],r9
}
8000637a:	5e fc       	retal	r12
8000637c:	00 00       	add	r0,r0
8000637e:	0d 3c       	ld.ub	r12,r6++

80006380 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006380:	48 28       	lddpc	r8,80006388 <xTaskGetCurrentTaskHandle+0x8>
80006382:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006384:	5e fc       	retal	r12
80006386:	00 00       	add	r0,r0
80006388:	00 00       	add	r0,r0
8000638a:	0c ec       	st.h	--r6,r12

8000638c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000638c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006390:	58 0c       	cp.w	r12,0
80006392:	c1 f0       	breq	800063d0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006394:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006396:	78 b9       	ld.w	r9,r12[0x2c]
80006398:	79 18       	ld.w	r8,r12[0x44]
8000639a:	10 39       	cp.w	r9,r8
8000639c:	c1 a0       	breq	800063d0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000639e:	f8 c6 ff fc 	sub	r6,r12,-4
800063a2:	0c 9c       	mov	r12,r6
800063a4:	f0 1f 00 0c 	mcall	800063d4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800063a8:	6f 1c       	ld.w	r12,r7[0x44]
800063aa:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800063ac:	f8 08 11 08 	rsub	r8,r12,8
800063b0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800063b2:	48 a8       	lddpc	r8,800063d8 <vTaskPriorityDisinherit+0x4c>
800063b4:	70 08       	ld.w	r8,r8[0x0]
800063b6:	10 3c       	cp.w	r12,r8
800063b8:	e0 88 00 04 	brls	800063c0 <vTaskPriorityDisinherit+0x34>
800063bc:	48 78       	lddpc	r8,800063d8 <vTaskPriorityDisinherit+0x4c>
800063be:	91 0c       	st.w	r8[0x0],r12
800063c0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063c4:	0c 9b       	mov	r11,r6
800063c6:	48 68       	lddpc	r8,800063dc <vTaskPriorityDisinherit+0x50>
800063c8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800063cc:	f0 1f 00 05 	mcall	800063e0 <vTaskPriorityDisinherit+0x54>
800063d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	5a e2       	cp.w	r2,-18
800063d8:	00 00       	add	r0,r0
800063da:	0d 54       	ld.sh	r4,--r6
800063dc:	00 00       	add	r0,r0
800063de:	0c 38       	cp.w	r8,r6
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	5a 92       	cp.w	r2,-23

800063e4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800063e4:	eb cd 40 c0 	pushm	r6-r7,lr
800063e8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800063ea:	49 b8       	lddpc	r8,80006454 <vTaskPriorityInherit+0x70>
800063ec:	70 08       	ld.w	r8,r8[0x0]
800063ee:	78 b9       	ld.w	r9,r12[0x2c]
800063f0:	70 b8       	ld.w	r8,r8[0x2c]
800063f2:	10 39       	cp.w	r9,r8
800063f4:	c2 d2       	brcc	8000644e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800063f6:	49 88       	lddpc	r8,80006454 <vTaskPriorityInherit+0x70>
800063f8:	70 08       	ld.w	r8,r8[0x0]
800063fa:	70 b8       	ld.w	r8,r8[0x2c]
800063fc:	f0 08 11 08 	rsub	r8,r8,8
80006400:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006402:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006406:	49 59       	lddpc	r9,80006458 <vTaskPriorityInherit+0x74>
80006408:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000640c:	78 59       	ld.w	r9,r12[0x14]
8000640e:	10 39       	cp.w	r9,r8
80006410:	c1 b1       	brne	80006446 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006412:	f8 c6 ff fc 	sub	r6,r12,-4
80006416:	0c 9c       	mov	r12,r6
80006418:	f0 1f 00 11 	mcall	8000645c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000641c:	48 e8       	lddpc	r8,80006454 <vTaskPriorityInherit+0x70>
8000641e:	70 08       	ld.w	r8,r8[0x0]
80006420:	70 bc       	ld.w	r12,r8[0x2c]
80006422:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006424:	48 f8       	lddpc	r8,80006460 <vTaskPriorityInherit+0x7c>
80006426:	70 08       	ld.w	r8,r8[0x0]
80006428:	10 3c       	cp.w	r12,r8
8000642a:	e0 88 00 04 	brls	80006432 <vTaskPriorityInherit+0x4e>
8000642e:	48 d8       	lddpc	r8,80006460 <vTaskPriorityInherit+0x7c>
80006430:	91 0c       	st.w	r8[0x0],r12
80006432:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006436:	0c 9b       	mov	r11,r6
80006438:	48 88       	lddpc	r8,80006458 <vTaskPriorityInherit+0x74>
8000643a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000643e:	f0 1f 00 0a 	mcall	80006464 <vTaskPriorityInherit+0x80>
80006442:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006446:	48 48       	lddpc	r8,80006454 <vTaskPriorityInherit+0x70>
80006448:	70 08       	ld.w	r8,r8[0x0]
8000644a:	70 b8       	ld.w	r8,r8[0x2c]
8000644c:	99 b8       	st.w	r12[0x2c],r8
8000644e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006452:	00 00       	add	r0,r0
80006454:	00 00       	add	r0,r0
80006456:	0c ec       	st.h	--r6,r12
80006458:	00 00       	add	r0,r0
8000645a:	0c 38       	cp.w	r8,r6
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	5a e2       	cp.w	r2,-18
80006460:	00 00       	add	r0,r0
80006462:	0d 54       	ld.sh	r4,--r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	5a 92       	cp.w	r2,-23

80006468 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006468:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000646c:	78 38       	ld.w	r8,r12[0xc]
8000646e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006470:	ee c6 ff e8 	sub	r6,r7,-24
80006474:	0c 9c       	mov	r12,r6
80006476:	f0 1f 00 15 	mcall	800064c8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000647a:	49 58       	lddpc	r8,800064cc <xTaskRemoveFromEventList+0x64>
8000647c:	70 08       	ld.w	r8,r8[0x0]
8000647e:	58 08       	cp.w	r8,0
80006480:	c1 71       	brne	800064ae <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006482:	ee c6 ff fc 	sub	r6,r7,-4
80006486:	0c 9c       	mov	r12,r6
80006488:	f0 1f 00 10 	mcall	800064c8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000648c:	6e bc       	ld.w	r12,r7[0x2c]
8000648e:	49 18       	lddpc	r8,800064d0 <xTaskRemoveFromEventList+0x68>
80006490:	70 08       	ld.w	r8,r8[0x0]
80006492:	10 3c       	cp.w	r12,r8
80006494:	e0 88 00 04 	brls	8000649c <xTaskRemoveFromEventList+0x34>
80006498:	48 e8       	lddpc	r8,800064d0 <xTaskRemoveFromEventList+0x68>
8000649a:	91 0c       	st.w	r8[0x0],r12
8000649c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064a0:	0c 9b       	mov	r11,r6
800064a2:	48 d8       	lddpc	r8,800064d4 <xTaskRemoveFromEventList+0x6c>
800064a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064a8:	f0 1f 00 0c 	mcall	800064d8 <xTaskRemoveFromEventList+0x70>
800064ac:	c0 58       	rjmp	800064b6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800064ae:	0c 9b       	mov	r11,r6
800064b0:	48 bc       	lddpc	r12,800064dc <xTaskRemoveFromEventList+0x74>
800064b2:	f0 1f 00 0a 	mcall	800064d8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800064b6:	48 b8       	lddpc	r8,800064e0 <xTaskRemoveFromEventList+0x78>
800064b8:	70 08       	ld.w	r8,r8[0x0]
800064ba:	6e b9       	ld.w	r9,r7[0x2c]
800064bc:	70 b8       	ld.w	r8,r8[0x2c]
800064be:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800064c0:	5f 2c       	srhs	r12
800064c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064c6:	00 00       	add	r0,r0
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	5a e2       	cp.w	r2,-18
800064cc:	00 00       	add	r0,r0
800064ce:	0d 1c       	ld.sh	r12,r6++
800064d0:	00 00       	add	r0,r0
800064d2:	0d 54       	ld.sh	r4,--r6
800064d4:	00 00       	add	r0,r0
800064d6:	0c 38       	cp.w	r8,r6
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	5a 92       	cp.w	r2,-23
800064dc:	00 00       	add	r0,r0
800064de:	0c f0       	st.b	--r6,r0
800064e0:	00 00       	add	r0,r0
800064e2:	0c ec       	st.h	--r6,r12

800064e4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800064e4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064e8:	4b 98       	lddpc	r8,800065cc <vTaskIncrementTick+0xe8>
800064ea:	70 08       	ld.w	r8,r8[0x0]
800064ec:	58 08       	cp.w	r8,0
800064ee:	c6 91       	brne	800065c0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800064f0:	4b 88       	lddpc	r8,800065d0 <vTaskIncrementTick+0xec>
800064f2:	70 09       	ld.w	r9,r8[0x0]
800064f4:	2f f9       	sub	r9,-1
800064f6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800064f8:	70 08       	ld.w	r8,r8[0x0]
800064fa:	58 08       	cp.w	r8,0
800064fc:	c1 a1       	brne	80006530 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800064fe:	4b 68       	lddpc	r8,800065d4 <vTaskIncrementTick+0xf0>
80006500:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006502:	4b 69       	lddpc	r9,800065d8 <vTaskIncrementTick+0xf4>
80006504:	72 0b       	ld.w	r11,r9[0x0]
80006506:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006508:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000650a:	4b 59       	lddpc	r9,800065dc <vTaskIncrementTick+0xf8>
8000650c:	72 0a       	ld.w	r10,r9[0x0]
8000650e:	2f fa       	sub	r10,-1
80006510:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	70 08       	ld.w	r8,r8[0x0]
80006516:	58 08       	cp.w	r8,0
80006518:	c0 51       	brne	80006522 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000651a:	3f f9       	mov	r9,-1
8000651c:	4b 18       	lddpc	r8,800065e0 <vTaskIncrementTick+0xfc>
8000651e:	91 09       	st.w	r8[0x0],r9
80006520:	c0 88       	rjmp	80006530 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006522:	4a d8       	lddpc	r8,800065d4 <vTaskIncrementTick+0xf0>
80006524:	70 08       	ld.w	r8,r8[0x0]
80006526:	70 38       	ld.w	r8,r8[0xc]
80006528:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000652a:	70 19       	ld.w	r9,r8[0x4]
8000652c:	4a d8       	lddpc	r8,800065e0 <vTaskIncrementTick+0xfc>
8000652e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006530:	4a 88       	lddpc	r8,800065d0 <vTaskIncrementTick+0xec>
80006532:	70 09       	ld.w	r9,r8[0x0]
80006534:	4a b8       	lddpc	r8,800065e0 <vTaskIncrementTick+0xfc>
80006536:	70 08       	ld.w	r8,r8[0x0]
80006538:	10 39       	cp.w	r9,r8
8000653a:	c4 73       	brcs	800065c8 <vTaskIncrementTick+0xe4>
8000653c:	4a 68       	lddpc	r8,800065d4 <vTaskIncrementTick+0xf0>
8000653e:	70 08       	ld.w	r8,r8[0x0]
80006540:	70 08       	ld.w	r8,r8[0x0]
80006542:	58 08       	cp.w	r8,0
80006544:	c0 c0       	breq	8000655c <vTaskIncrementTick+0x78>
80006546:	4a 48       	lddpc	r8,800065d4 <vTaskIncrementTick+0xf0>
80006548:	70 08       	ld.w	r8,r8[0x0]
8000654a:	70 38       	ld.w	r8,r8[0xc]
8000654c:	70 37       	ld.w	r7,r8[0xc]
8000654e:	6e 18       	ld.w	r8,r7[0x4]
80006550:	4a 09       	lddpc	r9,800065d0 <vTaskIncrementTick+0xec>
80006552:	72 09       	ld.w	r9,r9[0x0]
80006554:	12 38       	cp.w	r8,r9
80006556:	e0 88 00 14 	brls	8000657e <vTaskIncrementTick+0x9a>
8000655a:	c0 e8       	rjmp	80006576 <vTaskIncrementTick+0x92>
8000655c:	3f f9       	mov	r9,-1
8000655e:	4a 18       	lddpc	r8,800065e0 <vTaskIncrementTick+0xfc>
80006560:	91 09       	st.w	r8[0x0],r9
80006562:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006566:	6a 08       	ld.w	r8,r5[0x0]
80006568:	70 38       	ld.w	r8,r8[0xc]
8000656a:	70 37       	ld.w	r7,r8[0xc]
8000656c:	6e 18       	ld.w	r8,r7[0x4]
8000656e:	64 09       	ld.w	r9,r2[0x0]
80006570:	12 38       	cp.w	r8,r9
80006572:	e0 88 00 0a 	brls	80006586 <vTaskIncrementTick+0xa2>
80006576:	49 b9       	lddpc	r9,800065e0 <vTaskIncrementTick+0xfc>
80006578:	93 08       	st.w	r9[0x0],r8
8000657a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000657e:	49 a4       	lddpc	r4,800065e4 <vTaskIncrementTick+0x100>
80006580:	49 a3       	lddpc	r3,800065e8 <vTaskIncrementTick+0x104>
80006582:	49 55       	lddpc	r5,800065d4 <vTaskIncrementTick+0xf0>
80006584:	49 32       	lddpc	r2,800065d0 <vTaskIncrementTick+0xec>
80006586:	ee c6 ff fc 	sub	r6,r7,-4
8000658a:	0c 9c       	mov	r12,r6
8000658c:	f0 1f 00 18 	mcall	800065ec <vTaskIncrementTick+0x108>
80006590:	6e a8       	ld.w	r8,r7[0x28]
80006592:	58 08       	cp.w	r8,0
80006594:	c0 50       	breq	8000659e <vTaskIncrementTick+0xba>
80006596:	ee cc ff e8 	sub	r12,r7,-24
8000659a:	f0 1f 00 15 	mcall	800065ec <vTaskIncrementTick+0x108>
8000659e:	6e bc       	ld.w	r12,r7[0x2c]
800065a0:	68 08       	ld.w	r8,r4[0x0]
800065a2:	10 3c       	cp.w	r12,r8
800065a4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800065a8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065ac:	0c 9b       	mov	r11,r6
800065ae:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800065b2:	f0 1f 00 10 	mcall	800065f0 <vTaskIncrementTick+0x10c>
800065b6:	6a 08       	ld.w	r8,r5[0x0]
800065b8:	70 08       	ld.w	r8,r8[0x0]
800065ba:	58 08       	cp.w	r8,0
800065bc:	cd 51       	brne	80006566 <vTaskIncrementTick+0x82>
800065be:	cc fb       	rjmp	8000655c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800065c0:	48 d8       	lddpc	r8,800065f4 <vTaskIncrementTick+0x110>
800065c2:	70 09       	ld.w	r9,r8[0x0]
800065c4:	2f f9       	sub	r9,-1
800065c6:	91 09       	st.w	r8[0x0],r9
800065c8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065cc:	00 00       	add	r0,r0
800065ce:	0d 1c       	ld.sh	r12,r6++
800065d0:	00 00       	add	r0,r0
800065d2:	0d 18       	ld.sh	r8,r6++
800065d4:	00 00       	add	r0,r0
800065d6:	0c 24       	rsub	r4,r6
800065d8:	00 00       	add	r0,r0
800065da:	0c 34       	cp.w	r4,r6
800065dc:	00 00       	add	r0,r0
800065de:	0c 30       	cp.w	r0,r6
800065e0:	00 00       	add	r0,r0
800065e2:	05 38       	ld.ub	r8,r2++
800065e4:	00 00       	add	r0,r0
800065e6:	0d 54       	ld.sh	r4,--r6
800065e8:	00 00       	add	r0,r0
800065ea:	0c 38       	cp.w	r8,r6
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	5a e2       	cp.w	r2,-18
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	5a 92       	cp.w	r2,-23
800065f4:	00 00       	add	r0,r0
800065f6:	0c 1c       	sub	r12,r6

800065f8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800065f8:	eb cd 40 c0 	pushm	r6-r7,lr
800065fc:	18 97       	mov	r7,r12
800065fe:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006600:	f0 1f 00 15 	mcall	80006654 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006604:	6c 08       	ld.w	r8,r6[0x0]
80006606:	5b f8       	cp.w	r8,-1
80006608:	c0 31       	brne	8000660e <xTaskCheckForTimeOut+0x16>
8000660a:	30 07       	mov	r7,0
8000660c:	c1 f8       	rjmp	8000664a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000660e:	49 39       	lddpc	r9,80006658 <xTaskCheckForTimeOut+0x60>
80006610:	72 09       	ld.w	r9,r9[0x0]
80006612:	6e 0a       	ld.w	r10,r7[0x0]
80006614:	12 3a       	cp.w	r10,r9
80006616:	c0 70       	breq	80006624 <xTaskCheckForTimeOut+0x2c>
80006618:	49 19       	lddpc	r9,8000665c <xTaskCheckForTimeOut+0x64>
8000661a:	72 09       	ld.w	r9,r9[0x0]
8000661c:	6e 1a       	ld.w	r10,r7[0x4]
8000661e:	12 3a       	cp.w	r10,r9
80006620:	e0 88 00 14 	brls	80006648 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006624:	48 e9       	lddpc	r9,8000665c <xTaskCheckForTimeOut+0x64>
80006626:	72 0a       	ld.w	r10,r9[0x0]
80006628:	6e 19       	ld.w	r9,r7[0x4]
8000662a:	12 1a       	sub	r10,r9
8000662c:	14 38       	cp.w	r8,r10
8000662e:	e0 88 00 0d 	brls	80006648 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006632:	48 ba       	lddpc	r10,8000665c <xTaskCheckForTimeOut+0x64>
80006634:	74 0a       	ld.w	r10,r10[0x0]
80006636:	14 19       	sub	r9,r10
80006638:	f2 08 00 08 	add	r8,r9,r8
8000663c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000663e:	0e 9c       	mov	r12,r7
80006640:	f0 1f 00 08 	mcall	80006660 <xTaskCheckForTimeOut+0x68>
80006644:	30 07       	mov	r7,0
80006646:	c0 28       	rjmp	8000664a <xTaskCheckForTimeOut+0x52>
80006648:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000664a:	f0 1f 00 07 	mcall	80006664 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000664e:	0e 9c       	mov	r12,r7
80006650:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006654:	80 00       	ld.sh	r0,r0[0x0]
80006656:	5b 9c       	cp.w	r12,-7
80006658:	00 00       	add	r0,r0
8000665a:	0c 30       	cp.w	r0,r6
8000665c:	00 00       	add	r0,r0
8000665e:	0d 18       	ld.sh	r8,r6++
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	63 5c       	ld.w	r12,r1[0x54]
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	5c a8       	swap.h	r8

80006668 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006668:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000666c:	f0 1f 00 05 	mcall	80006680 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006670:	48 58       	lddpc	r8,80006684 <xTaskGetTickCount+0x1c>
80006672:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006674:	f0 1f 00 05 	mcall	80006688 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006678:	0e 9c       	mov	r12,r7
8000667a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000667e:	00 00       	add	r0,r0
80006680:	80 00       	ld.sh	r0,r0[0x0]
80006682:	5b 9c       	cp.w	r12,-7
80006684:	00 00       	add	r0,r0
80006686:	0d 18       	ld.sh	r8,r6++
80006688:	80 00       	ld.sh	r0,r0[0x0]
8000668a:	5c a8       	swap.h	r8

8000668c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000668c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006690:	f0 1f 00 2c 	mcall	80006740 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006694:	4a c8       	lddpc	r8,80006744 <xTaskResumeAll+0xb8>
80006696:	70 09       	ld.w	r9,r8[0x0]
80006698:	20 19       	sub	r9,1
8000669a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000669c:	70 08       	ld.w	r8,r8[0x0]
8000669e:	58 08       	cp.w	r8,0
800066a0:	c4 91       	brne	80006732 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800066a2:	4a a8       	lddpc	r8,80006748 <xTaskResumeAll+0xbc>
800066a4:	70 08       	ld.w	r8,r8[0x0]
800066a6:	58 08       	cp.w	r8,0
800066a8:	c4 50       	breq	80006732 <xTaskResumeAll+0xa6>
800066aa:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800066ac:	4a 85       	lddpc	r5,8000674c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800066ae:	4a 93       	lddpc	r3,80006750 <xTaskResumeAll+0xc4>
800066b0:	4a 92       	lddpc	r2,80006754 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066b2:	4a a1       	lddpc	r1,80006758 <xTaskResumeAll+0xcc>
800066b4:	c1 e8       	rjmp	800066f0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800066b6:	6a 38       	ld.w	r8,r5[0xc]
800066b8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800066ba:	ee cc ff e8 	sub	r12,r7,-24
800066be:	f0 1f 00 28 	mcall	8000675c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800066c2:	ee c6 ff fc 	sub	r6,r7,-4
800066c6:	0c 9c       	mov	r12,r6
800066c8:	f0 1f 00 25 	mcall	8000675c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800066cc:	6e bc       	ld.w	r12,r7[0x2c]
800066ce:	66 08       	ld.w	r8,r3[0x0]
800066d0:	10 3c       	cp.w	r12,r8
800066d2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800066d6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066da:	0c 9b       	mov	r11,r6
800066dc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800066e0:	f0 1f 00 20 	mcall	80006760 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066e4:	62 08       	ld.w	r8,r1[0x0]
800066e6:	6e b9       	ld.w	r9,r7[0x2c]
800066e8:	70 b8       	ld.w	r8,r8[0x2c]
800066ea:	10 39       	cp.w	r9,r8
800066ec:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800066f0:	6a 08       	ld.w	r8,r5[0x0]
800066f2:	58 08       	cp.w	r8,0
800066f4:	ce 11       	brne	800066b6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066f6:	49 c8       	lddpc	r8,80006764 <xTaskResumeAll+0xd8>
800066f8:	70 08       	ld.w	r8,r8[0x0]
800066fa:	58 08       	cp.w	r8,0
800066fc:	c0 f0       	breq	8000671a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066fe:	49 a8       	lddpc	r8,80006764 <xTaskResumeAll+0xd8>
80006700:	70 08       	ld.w	r8,r8[0x0]
80006702:	58 08       	cp.w	r8,0
80006704:	c1 10       	breq	80006726 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006706:	49 87       	lddpc	r7,80006764 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006708:	f0 1f 00 18 	mcall	80006768 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000670c:	6e 08       	ld.w	r8,r7[0x0]
8000670e:	20 18       	sub	r8,1
80006710:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006712:	6e 08       	ld.w	r8,r7[0x0]
80006714:	58 08       	cp.w	r8,0
80006716:	cf 91       	brne	80006708 <xTaskResumeAll+0x7c>
80006718:	c0 78       	rjmp	80006726 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000671a:	58 14       	cp.w	r4,1
8000671c:	c0 50       	breq	80006726 <xTaskResumeAll+0x9a>
8000671e:	49 48       	lddpc	r8,8000676c <xTaskResumeAll+0xe0>
80006720:	70 08       	ld.w	r8,r8[0x0]
80006722:	58 18       	cp.w	r8,1
80006724:	c0 71       	brne	80006732 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006726:	30 09       	mov	r9,0
80006728:	49 18       	lddpc	r8,8000676c <xTaskResumeAll+0xe0>
8000672a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000672c:	d7 33       	scall
8000672e:	30 17       	mov	r7,1
80006730:	c0 28       	rjmp	80006734 <xTaskResumeAll+0xa8>
80006732:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006734:	f0 1f 00 0f 	mcall	80006770 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006738:	0e 9c       	mov	r12,r7
8000673a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000673e:	00 00       	add	r0,r0
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	5b 9c       	cp.w	r12,-7
80006744:	00 00       	add	r0,r0
80006746:	0d 1c       	ld.sh	r12,r6++
80006748:	00 00       	add	r0,r0
8000674a:	0d 38       	ld.ub	r8,r6++
8000674c:	00 00       	add	r0,r0
8000674e:	0c f0       	st.b	--r6,r0
80006750:	00 00       	add	r0,r0
80006752:	0d 54       	ld.sh	r4,--r6
80006754:	00 00       	add	r0,r0
80006756:	0c 38       	cp.w	r8,r6
80006758:	00 00       	add	r0,r0
8000675a:	0c ec       	st.h	--r6,r12
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	5a e2       	cp.w	r2,-18
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	5a 92       	cp.w	r2,-23
80006764:	00 00       	add	r0,r0
80006766:	0c 1c       	sub	r12,r6
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	64 e4       	ld.w	r4,r2[0x38]
8000676c:	00 00       	add	r0,r0
8000676e:	0d 3c       	ld.ub	r12,r6++
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	5c a8       	swap.h	r8

80006774 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006774:	eb cd 40 80 	pushm	r7,lr
80006778:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000677a:	49 08       	lddpc	r8,800067b8 <prvAddCurrentTaskToDelayedList+0x44>
8000677c:	70 08       	ld.w	r8,r8[0x0]
8000677e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006780:	48 f8       	lddpc	r8,800067bc <prvAddCurrentTaskToDelayedList+0x48>
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	10 3c       	cp.w	r12,r8
80006786:	c0 a2       	brcc	8000679a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006788:	48 c8       	lddpc	r8,800067b8 <prvAddCurrentTaskToDelayedList+0x44>
8000678a:	70 0b       	ld.w	r11,r8[0x0]
8000678c:	48 d8       	lddpc	r8,800067c0 <prvAddCurrentTaskToDelayedList+0x4c>
8000678e:	70 0c       	ld.w	r12,r8[0x0]
80006790:	2f cb       	sub	r11,-4
80006792:	f0 1f 00 0d 	mcall	800067c4 <prvAddCurrentTaskToDelayedList+0x50>
80006796:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000679a:	48 88       	lddpc	r8,800067b8 <prvAddCurrentTaskToDelayedList+0x44>
8000679c:	70 0b       	ld.w	r11,r8[0x0]
8000679e:	48 b8       	lddpc	r8,800067c8 <prvAddCurrentTaskToDelayedList+0x54>
800067a0:	70 0c       	ld.w	r12,r8[0x0]
800067a2:	2f cb       	sub	r11,-4
800067a4:	f0 1f 00 08 	mcall	800067c4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800067a8:	48 98       	lddpc	r8,800067cc <prvAddCurrentTaskToDelayedList+0x58>
800067aa:	70 08       	ld.w	r8,r8[0x0]
800067ac:	10 37       	cp.w	r7,r8
800067ae:	c0 32       	brcc	800067b4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800067b0:	48 78       	lddpc	r8,800067cc <prvAddCurrentTaskToDelayedList+0x58>
800067b2:	91 07       	st.w	r8[0x0],r7
800067b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800067b8:	00 00       	add	r0,r0
800067ba:	0c ec       	st.h	--r6,r12
800067bc:	00 00       	add	r0,r0
800067be:	0d 18       	ld.sh	r8,r6++
800067c0:	00 00       	add	r0,r0
800067c2:	0c 34       	cp.w	r4,r6
800067c4:	80 00       	ld.sh	r0,r0[0x0]
800067c6:	5a ae       	cp.w	lr,-22
800067c8:	00 00       	add	r0,r0
800067ca:	0c 24       	rsub	r4,r6
800067cc:	00 00       	add	r0,r0
800067ce:	05 38       	ld.ub	r8,r2++

800067d0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800067d0:	eb cd 40 c0 	pushm	r6-r7,lr
800067d4:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800067d6:	58 0c       	cp.w	r12,0
800067d8:	c1 10       	breq	800067fa <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800067da:	f0 1f 00 0a 	mcall	80006800 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800067de:	48 a8       	lddpc	r8,80006804 <vTaskDelay+0x34>
800067e0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800067e2:	48 a8       	lddpc	r8,80006808 <vTaskDelay+0x38>
800067e4:	70 0c       	ld.w	r12,r8[0x0]
800067e6:	2f cc       	sub	r12,-4
800067e8:	f0 1f 00 09 	mcall	8000680c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800067ec:	ee 06 00 0c 	add	r12,r7,r6
800067f0:	f0 1f 00 08 	mcall	80006810 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800067f4:	f0 1f 00 08 	mcall	80006814 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800067f8:	c0 21       	brne	800067fc <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800067fa:	d7 33       	scall
800067fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	62 d0       	ld.w	r0,r1[0x34]
80006804:	00 00       	add	r0,r0
80006806:	0d 18       	ld.sh	r8,r6++
80006808:	00 00       	add	r0,r0
8000680a:	0c ec       	st.h	--r6,r12
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	5a e2       	cp.w	r2,-18
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	67 74       	ld.w	r4,r3[0x5c]
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	66 8c       	ld.w	r12,r3[0x20]

80006818 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006818:	eb cd 40 c0 	pushm	r6-r7,lr
8000681c:	18 96       	mov	r6,r12
8000681e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006820:	f0 1f 00 18 	mcall	80006880 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006824:	6c 08       	ld.w	r8,r6[0x0]
80006826:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006828:	49 79       	lddpc	r9,80006884 <vTaskDelayUntil+0x6c>
8000682a:	72 09       	ld.w	r9,r9[0x0]
8000682c:	12 38       	cp.w	r8,r9
8000682e:	e0 88 00 0c 	brls	80006846 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006832:	0e 38       	cp.w	r8,r7
80006834:	e0 88 00 22 	brls	80006878 <vTaskDelayUntil+0x60>
80006838:	49 38       	lddpc	r8,80006884 <vTaskDelayUntil+0x6c>
8000683a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000683c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000683e:	10 37       	cp.w	r7,r8
80006840:	e0 88 00 14 	brls	80006868 <vTaskDelayUntil+0x50>
80006844:	c0 a8       	rjmp	80006858 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006846:	0e 38       	cp.w	r8,r7
80006848:	e0 8b 00 16 	brhi	80006874 <vTaskDelayUntil+0x5c>
8000684c:	48 e8       	lddpc	r8,80006884 <vTaskDelayUntil+0x6c>
8000684e:	70 08       	ld.w	r8,r8[0x0]
80006850:	10 37       	cp.w	r7,r8
80006852:	e0 8b 00 11 	brhi	80006874 <vTaskDelayUntil+0x5c>
80006856:	c1 18       	rjmp	80006878 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006858:	48 c8       	lddpc	r8,80006888 <vTaskDelayUntil+0x70>
8000685a:	70 0c       	ld.w	r12,r8[0x0]
8000685c:	2f cc       	sub	r12,-4
8000685e:	f0 1f 00 0c 	mcall	8000688c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006862:	0e 9c       	mov	r12,r7
80006864:	f0 1f 00 0b 	mcall	80006890 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006868:	f0 1f 00 0b 	mcall	80006894 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000686c:	c0 81       	brne	8000687c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000686e:	d7 33       	scall
80006870:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006874:	8d 07       	st.w	r6[0x0],r7
80006876:	cf 1b       	rjmp	80006858 <vTaskDelayUntil+0x40>
80006878:	8d 07       	st.w	r6[0x0],r7
8000687a:	cf 7b       	rjmp	80006868 <vTaskDelayUntil+0x50>
8000687c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	62 d0       	ld.w	r0,r1[0x34]
80006884:	00 00       	add	r0,r0
80006886:	0d 18       	ld.sh	r8,r6++
80006888:	00 00       	add	r0,r0
8000688a:	0c ec       	st.h	--r6,r12
8000688c:	80 00       	ld.sh	r0,r0[0x0]
8000688e:	5a e2       	cp.w	r2,-18
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	67 74       	ld.w	r4,r3[0x5c]
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	66 8c       	ld.w	r12,r3[0x20]

80006898 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006898:	eb cd 40 c0 	pushm	r6-r7,lr
8000689c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000689e:	48 e7       	lddpc	r7,800068d4 <vTaskPlaceOnEventList+0x3c>
800068a0:	6e 0b       	ld.w	r11,r7[0x0]
800068a2:	2e 8b       	sub	r11,-24
800068a4:	f0 1f 00 0d 	mcall	800068d8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068a8:	6e 0c       	ld.w	r12,r7[0x0]
800068aa:	2f cc       	sub	r12,-4
800068ac:	f0 1f 00 0c 	mcall	800068dc <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800068b0:	5b f6       	cp.w	r6,-1
800068b2:	c0 81       	brne	800068c2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068b4:	6e 0b       	ld.w	r11,r7[0x0]
800068b6:	2f cb       	sub	r11,-4
800068b8:	48 ac       	lddpc	r12,800068e0 <vTaskPlaceOnEventList+0x48>
800068ba:	f0 1f 00 0b 	mcall	800068e4 <vTaskPlaceOnEventList+0x4c>
800068be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800068c2:	48 a8       	lddpc	r8,800068e8 <vTaskPlaceOnEventList+0x50>
800068c4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800068c6:	ec 0c 00 0c 	add	r12,r6,r12
800068ca:	f0 1f 00 09 	mcall	800068ec <vTaskPlaceOnEventList+0x54>
800068ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068d2:	00 00       	add	r0,r0
800068d4:	00 00       	add	r0,r0
800068d6:	0c ec       	st.h	--r6,r12
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	5a ae       	cp.w	lr,-22
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	5a e2       	cp.w	r2,-18
800068e0:	00 00       	add	r0,r0
800068e2:	0d 40       	ld.w	r0,--r6
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	5a 92       	cp.w	r2,-23
800068e8:	00 00       	add	r0,r0
800068ea:	0d 18       	ld.sh	r8,r6++
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	67 74       	ld.w	r4,r3[0x5c]

800068f0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800068f0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068f4:	49 67       	lddpc	r7,8000694c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800068f6:	49 74       	lddpc	r4,80006950 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800068f8:	49 73       	lddpc	r3,80006954 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800068fa:	49 85       	lddpc	r5,80006958 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068fc:	6e 08       	ld.w	r8,r7[0x0]
800068fe:	58 08       	cp.w	r8,0
80006900:	c1 e0       	breq	8000693c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006902:	f0 1f 00 17 	mcall	8000695c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006906:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006908:	f0 1f 00 16 	mcall	80006960 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
8000690c:	58 06       	cp.w	r6,0
8000690e:	c1 70       	breq	8000693c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006910:	f0 1f 00 15 	mcall	80006964 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006914:	68 38       	ld.w	r8,r4[0xc]
80006916:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006918:	ec cc ff fc 	sub	r12,r6,-4
8000691c:	f0 1f 00 13 	mcall	80006968 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006920:	66 08       	ld.w	r8,r3[0x0]
80006922:	20 18       	sub	r8,1
80006924:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006926:	6e 08       	ld.w	r8,r7[0x0]
80006928:	20 18       	sub	r8,1
8000692a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
8000692c:	f0 1f 00 10 	mcall	8000696c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006930:	6c cc       	ld.w	r12,r6[0x30]
80006932:	f0 1f 00 10 	mcall	80006970 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006936:	0c 9c       	mov	r12,r6
80006938:	f0 1f 00 0e 	mcall	80006970 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000693c:	6a 08       	ld.w	r8,r5[0x0]
8000693e:	58 18       	cp.w	r8,1
80006940:	e0 88 00 03 	brls	80006946 <prvIdleTask+0x56>
			{
				taskYIELD();
80006944:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006946:	f0 1f 00 0c 	mcall	80006974 <prvIdleTask+0x84>
		}
		#endif
	}
8000694a:	cd 9b       	rjmp	800068fc <prvIdleTask+0xc>
8000694c:	00 00       	add	r0,r0
8000694e:	0c 2c       	rsub	r12,r6
80006950:	00 00       	add	r0,r0
80006952:	0c d8       	st.w	--r6,r8
80006954:	00 00       	add	r0,r0
80006956:	0d 38       	ld.ub	r8,r6++
80006958:	00 00       	add	r0,r0
8000695a:	0c 38       	cp.w	r8,r6
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	62 d0       	ld.w	r0,r1[0x34]
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	66 8c       	ld.w	r12,r3[0x20]
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	5b 9c       	cp.w	r12,-7
80006968:	80 00       	ld.sh	r0,r0[0x0]
8000696a:	5a e2       	cp.w	r2,-18
8000696c:	80 00       	ld.sh	r0,r0[0x0]
8000696e:	5c a8       	swap.h	r8
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	5d e0       	*unknown*
80006974:	80 00       	ld.sh	r0,r0[0x0]
80006976:	20 2c       	sub	r12,2

80006978 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006978:	d4 31       	pushm	r0-r7,lr
8000697a:	20 1d       	sub	sp,4
8000697c:	fa c4 ff d8 	sub	r4,sp,-40
80006980:	50 0c       	stdsp	sp[0x0],r12
80006982:	16 91       	mov	r1,r11
80006984:	14 97       	mov	r7,r10
80006986:	12 90       	mov	r0,r9
80006988:	10 93       	mov	r3,r8
8000698a:	68 02       	ld.w	r2,r4[0x0]
8000698c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000698e:	34 8c       	mov	r12,72
80006990:	f0 1f 00 5c 	mcall	80006b00 <xTaskGenericCreate+0x188>
80006994:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006996:	c0 31       	brne	8000699c <xTaskGenericCreate+0x24>
80006998:	3f fc       	mov	r12,-1
8000699a:	ca f8       	rjmp	80006af8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000699c:	58 06       	cp.w	r6,0
8000699e:	e0 81 00 af 	brne	80006afc <xTaskGenericCreate+0x184>
800069a2:	0e 9c       	mov	r12,r7
800069a4:	5c 7c       	castu.h	r12
800069a6:	a3 6c       	lsl	r12,0x2
800069a8:	f0 1f 00 56 	mcall	80006b00 <xTaskGenericCreate+0x188>
800069ac:	18 96       	mov	r6,r12
800069ae:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800069b0:	c0 61       	brne	800069bc <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800069b2:	0a 9c       	mov	r12,r5
800069b4:	f0 1f 00 54 	mcall	80006b04 <xTaskGenericCreate+0x18c>
800069b8:	3f fc       	mov	r12,-1
800069ba:	c9 f8       	rjmp	80006af8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800069bc:	5c 77       	castu.h	r7
800069be:	ee 0a 15 02 	lsl	r10,r7,0x2
800069c2:	e0 6b 00 a5 	mov	r11,165
800069c6:	0c 9c       	mov	r12,r6
800069c8:	f0 1f 00 50 	mcall	80006b08 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800069cc:	ee c6 00 01 	sub	r6,r7,1
800069d0:	6a c8       	ld.w	r8,r5[0x30]
800069d2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800069d6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800069da:	31 0a       	mov	r10,16
800069dc:	02 9b       	mov	r11,r1
800069de:	ea cc ff cc 	sub	r12,r5,-52
800069e2:	f0 1f 00 4b 	mcall	80006b0c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800069e6:	30 08       	mov	r8,0
800069e8:	eb 68 00 43 	st.b	r5[67],r8
800069ec:	58 73       	cp.w	r3,7
800069ee:	e6 07 17 80 	movls	r7,r3
800069f2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800069f6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800069f8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800069fc:	ea c4 ff fc 	sub	r4,r5,-4
80006a00:	08 9c       	mov	r12,r4
80006a02:	f0 1f 00 44 	mcall	80006b10 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006a06:	ea cc ff e8 	sub	r12,r5,-24
80006a0a:	f0 1f 00 42 	mcall	80006b10 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a0e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a10:	ee 07 11 08 	rsub	r7,r7,8
80006a14:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a16:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a18:	00 9a       	mov	r10,r0
80006a1a:	40 0b       	lddsp	r11,sp[0x0]
80006a1c:	0c 9c       	mov	r12,r6
80006a1e:	f0 1f 00 3e 	mcall	80006b14 <xTaskGenericCreate+0x19c>
80006a22:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006a24:	58 02       	cp.w	r2,0
80006a26:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a2a:	f0 1f 00 3c 	mcall	80006b18 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a2e:	4b c8       	lddpc	r8,80006b1c <xTaskGenericCreate+0x1a4>
80006a30:	70 09       	ld.w	r9,r8[0x0]
80006a32:	2f f9       	sub	r9,-1
80006a34:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a36:	4b b8       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1a8>
80006a38:	70 08       	ld.w	r8,r8[0x0]
80006a3a:	58 08       	cp.w	r8,0
80006a3c:	c2 61       	brne	80006a88 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a3e:	4b 98       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1a8>
80006a40:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a42:	4b 78       	lddpc	r8,80006b1c <xTaskGenericCreate+0x1a4>
80006a44:	70 08       	ld.w	r8,r8[0x0]
80006a46:	58 18       	cp.w	r8,1
80006a48:	c2 b1       	brne	80006a9e <xTaskGenericCreate+0x126>
80006a4a:	4b 77       	lddpc	r7,80006b24 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a4c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a50:	0e 9c       	mov	r12,r7
80006a52:	f0 1f 00 36 	mcall	80006b28 <xTaskGenericCreate+0x1b0>
80006a56:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a58:	0c 37       	cp.w	r7,r6
80006a5a:	cf b1       	brne	80006a50 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006a5c:	4b 47       	lddpc	r7,80006b2c <xTaskGenericCreate+0x1b4>
80006a5e:	0e 9c       	mov	r12,r7
80006a60:	f0 1f 00 32 	mcall	80006b28 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006a64:	4b 36       	lddpc	r6,80006b30 <xTaskGenericCreate+0x1b8>
80006a66:	0c 9c       	mov	r12,r6
80006a68:	f0 1f 00 30 	mcall	80006b28 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006a6c:	4b 2c       	lddpc	r12,80006b34 <xTaskGenericCreate+0x1bc>
80006a6e:	f0 1f 00 2f 	mcall	80006b28 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006a72:	4b 2c       	lddpc	r12,80006b38 <xTaskGenericCreate+0x1c0>
80006a74:	f0 1f 00 2d 	mcall	80006b28 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006a78:	4b 1c       	lddpc	r12,80006b3c <xTaskGenericCreate+0x1c4>
80006a7a:	f0 1f 00 2c 	mcall	80006b28 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006a7e:	4b 18       	lddpc	r8,80006b40 <xTaskGenericCreate+0x1c8>
80006a80:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006a82:	4b 18       	lddpc	r8,80006b44 <xTaskGenericCreate+0x1cc>
80006a84:	91 06       	st.w	r8[0x0],r6
80006a86:	c0 c8       	rjmp	80006a9e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006a88:	4b 08       	lddpc	r8,80006b48 <xTaskGenericCreate+0x1d0>
80006a8a:	70 08       	ld.w	r8,r8[0x0]
80006a8c:	58 08       	cp.w	r8,0
80006a8e:	c0 81       	brne	80006a9e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006a90:	4a 48       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1a8>
80006a92:	70 08       	ld.w	r8,r8[0x0]
80006a94:	70 b8       	ld.w	r8,r8[0x2c]
80006a96:	10 33       	cp.w	r3,r8
80006a98:	c0 33       	brcs	80006a9e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006a9a:	4a 28       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1a8>
80006a9c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006a9e:	6a b8       	ld.w	r8,r5[0x2c]
80006aa0:	4a b9       	lddpc	r9,80006b4c <xTaskGenericCreate+0x1d4>
80006aa2:	72 09       	ld.w	r9,r9[0x0]
80006aa4:	12 38       	cp.w	r8,r9
80006aa6:	e0 88 00 04 	brls	80006aae <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006aaa:	4a 99       	lddpc	r9,80006b4c <xTaskGenericCreate+0x1d4>
80006aac:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006aae:	4a 98       	lddpc	r8,80006b50 <xTaskGenericCreate+0x1d8>
80006ab0:	70 09       	ld.w	r9,r8[0x0]
80006ab2:	2f f9       	sub	r9,-1
80006ab4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ab6:	6a b8       	ld.w	r8,r5[0x2c]
80006ab8:	4a 79       	lddpc	r9,80006b54 <xTaskGenericCreate+0x1dc>
80006aba:	72 09       	ld.w	r9,r9[0x0]
80006abc:	12 38       	cp.w	r8,r9
80006abe:	e0 88 00 04 	brls	80006ac6 <xTaskGenericCreate+0x14e>
80006ac2:	4a 59       	lddpc	r9,80006b54 <xTaskGenericCreate+0x1dc>
80006ac4:	93 08       	st.w	r9[0x0],r8
80006ac6:	6a bc       	ld.w	r12,r5[0x2c]
80006ac8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006acc:	08 9b       	mov	r11,r4
80006ace:	49 68       	lddpc	r8,80006b24 <xTaskGenericCreate+0x1ac>
80006ad0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ad4:	f0 1f 00 21 	mcall	80006b58 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006ad8:	f0 1f 00 21 	mcall	80006b5c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006adc:	49 b8       	lddpc	r8,80006b48 <xTaskGenericCreate+0x1d0>
80006ade:	70 08       	ld.w	r8,r8[0x0]
80006ae0:	58 08       	cp.w	r8,0
80006ae2:	c0 a0       	breq	80006af6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ae4:	48 f8       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1a8>
80006ae6:	70 08       	ld.w	r8,r8[0x0]
80006ae8:	70 b8       	ld.w	r8,r8[0x2c]
80006aea:	10 33       	cp.w	r3,r8
80006aec:	e0 88 00 05 	brls	80006af6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006af0:	d7 33       	scall
80006af2:	30 1c       	mov	r12,1
80006af4:	c0 28       	rjmp	80006af8 <xTaskGenericCreate+0x180>
80006af6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006af8:	2f fd       	sub	sp,-4
80006afa:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006afc:	99 c6       	st.w	r12[0x30],r6
80006afe:	c5 fb       	rjmp	800069bc <xTaskGenericCreate+0x44>
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	5e 08       	reteq	r8
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	5d e0       	*unknown*
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	77 00       	ld.w	r0,r11[0x40]
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	7a 2c       	ld.w	r12,sp[0x8]
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	5a 8c       	cp.w	r12,-24
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	5b 08       	cp.w	r8,-16
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	5b 9c       	cp.w	r12,-7
80006b1c:	00 00       	add	r0,r0
80006b1e:	0d 38       	ld.ub	r8,r6++
80006b20:	00 00       	add	r0,r0
80006b22:	0c ec       	st.h	--r6,r12
80006b24:	00 00       	add	r0,r0
80006b26:	0c 38       	cp.w	r8,r6
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	5a 78       	cp.w	r8,-25
80006b2c:	00 00       	add	r0,r0
80006b2e:	0d 04       	ld.w	r4,r6++
80006b30:	00 00       	add	r0,r0
80006b32:	0d 20       	ld.uh	r0,r6++
80006b34:	00 00       	add	r0,r0
80006b36:	0c f0       	st.b	--r6,r0
80006b38:	00 00       	add	r0,r0
80006b3a:	0c d8       	st.w	--r6,r8
80006b3c:	00 00       	add	r0,r0
80006b3e:	0d 40       	ld.w	r0,--r6
80006b40:	00 00       	add	r0,r0
80006b42:	0c 24       	rsub	r4,r6
80006b44:	00 00       	add	r0,r0
80006b46:	0c 34       	cp.w	r4,r6
80006b48:	00 00       	add	r0,r0
80006b4a:	0c 28       	rsub	r8,r6
80006b4c:	00 00       	add	r0,r0
80006b4e:	0c 20       	rsub	r0,r6
80006b50:	00 00       	add	r0,r0
80006b52:	0d 34       	ld.ub	r4,r6++
80006b54:	00 00       	add	r0,r0
80006b56:	0d 54       	ld.sh	r4,--r6
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	5a 92       	cp.w	r2,-23
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5c a8       	swap.h	r8

80006b60 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006b60:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006b62:	30 09       	mov	r9,0
80006b64:	1a d9       	st.w	--sp,r9
80006b66:	1a d9       	st.w	--sp,r9
80006b68:	1a d9       	st.w	--sp,r9
80006b6a:	12 98       	mov	r8,r9
80006b6c:	e0 6a 01 00 	mov	r10,256
80006b70:	48 9b       	lddpc	r11,80006b94 <vTaskStartScheduler+0x34>
80006b72:	48 ac       	lddpc	r12,80006b98 <vTaskStartScheduler+0x38>
80006b74:	f0 1f 00 0a 	mcall	80006b9c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006b78:	2f dd       	sub	sp,-12
80006b7a:	58 1c       	cp.w	r12,1
80006b7c:	c0 a1       	brne	80006b90 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006b7e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006b80:	30 19       	mov	r9,1
80006b82:	48 88       	lddpc	r8,80006ba0 <vTaskStartScheduler+0x40>
80006b84:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006b86:	30 09       	mov	r9,0
80006b88:	48 78       	lddpc	r8,80006ba4 <vTaskStartScheduler+0x44>
80006b8a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006b8c:	f0 1f 00 07 	mcall	80006ba8 <vTaskStartScheduler+0x48>
80006b90:	d8 02       	popm	pc
80006b92:	00 00       	add	r0,r0
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	d7 b4       	*unknown*
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	68 f0       	ld.w	r0,r4[0x3c]
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	69 78       	ld.w	r8,r4[0x5c]
80006ba0:	00 00       	add	r0,r0
80006ba2:	0c 28       	rsub	r8,r6
80006ba4:	00 00       	add	r0,r0
80006ba6:	0d 18       	ld.sh	r8,r6++
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	5b ac       	cp.w	r12,-6

80006bac <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006bac:	16 cc       	st.b	r11++,r12
	return str;
}
80006bae:	5e fb       	retal	r11

80006bb0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006bb0:	eb cd 40 c0 	pushm	r6-r7,lr
80006bb4:	20 3d       	sub	sp,12
80006bb6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006bb8:	30 06       	mov	r6,0
80006bba:	30 07       	mov	r7,0
80006bbc:	fa e7 00 00 	st.d	sp[0],r6
80006bc0:	30 0c       	mov	r12,0
80006bc2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006bc4:	58 08       	cp.w	r8,0
80006bc6:	c1 30       	breq	80006bec <PrintHex+0x3c>
80006bc8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006bca:	1a 9c       	mov	r12,sp
80006bcc:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006bd0:	58 9e       	cp.w	lr,9
80006bd2:	e0 8a 00 04 	brle	80006bda <PrintHex+0x2a>
80006bd6:	2c 9e       	sub	lr,-55
80006bd8:	c0 48       	rjmp	80006be0 <PrintHex+0x30>
80006bda:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006bde:	2d 0e       	sub	lr,-48
80006be0:	f8 09 0b 0e 	st.b	r12[r9],lr
80006be4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006be6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006be8:	cf 21       	brne	80006bcc <PrintHex+0x1c>
80006bea:	c0 48       	rjmp	80006bf2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006bec:	33 08       	mov	r8,48
80006bee:	ba 88       	st.b	sp[0x0],r8
80006bf0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006bf2:	f6 09 01 08 	sub	r8,r11,r9
80006bf6:	58 08       	cp.w	r8,0
80006bf8:	e0 8a 00 13 	brle	80006c1e <PrintHex+0x6e>
	{
		char num = len - cnt;
80006bfc:	12 1b       	sub	r11,r9
80006bfe:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006c02:	18 9e       	mov	lr,r12
80006c04:	58 0c       	cp.w	r12,0
80006c06:	e0 8a 00 0c 	brle	80006c1e <PrintHex+0x6e>
80006c0a:	1a 9b       	mov	r11,sp
80006c0c:	12 0b       	add	r11,r9
80006c0e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c10:	33 07       	mov	r7,48
80006c12:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c14:	2f f8       	sub	r8,-1
80006c16:	1c 38       	cp.w	r8,lr
80006c18:	cf d5       	brlt	80006c12 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c1a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c1e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006c22:	f0 cb ff ff 	sub	r11,r8,-1
80006c26:	58 0b       	cp.w	r11,0
80006c28:	e0 8a 00 19 	brle	80006c5a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c2c:	fa cb ff f4 	sub	r11,sp,-12
80006c30:	f6 09 00 09 	add	r9,r11,r9
80006c34:	37 8b       	mov	r11,120
80006c36:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c3a:	fa c9 ff f4 	sub	r9,sp,-12
80006c3e:	10 09       	add	r9,r8
80006c40:	33 0b       	mov	r11,48
80006c42:	f3 6b ff f4 	st.b	r9[-12],r11
80006c46:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c4a:	fa ce 00 01 	sub	lr,sp,1
80006c4e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c50:	11 8b       	ld.ub	r11,r8[0x0]
80006c52:	12 cb       	st.b	r9++,r11
80006c54:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c56:	1c 38       	cp.w	r8,lr
80006c58:	cf c1       	brne	80006c50 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c5a:	14 9c       	mov	r12,r10
80006c5c:	2f dd       	sub	sp,-12
80006c5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006c62 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006c62:	d4 21       	pushm	r4-r7,lr
80006c64:	20 3d       	sub	sp,12
80006c66:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006c68:	30 06       	mov	r6,0
80006c6a:	30 07       	mov	r7,0
80006c6c:	fa e7 00 00 	st.d	sp[0],r6
80006c70:	30 0c       	mov	r12,0
80006c72:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006c74:	58 08       	cp.w	r8,0
80006c76:	c0 35       	brlt	80006c7c <PrintDec+0x1a>
80006c78:	14 97       	mov	r7,r10
80006c7a:	c0 58       	rjmp	80006c84 <PrintDec+0x22>
	{
		*p++ = '-';
80006c7c:	14 97       	mov	r7,r10
80006c7e:	32 d9       	mov	r9,45
80006c80:	0e c9       	st.b	r7++,r9
		i = -i;
80006c82:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006c84:	58 08       	cp.w	r8,0
80006c86:	c0 51       	brne	80006c90 <PrintDec+0x2e>
80006c88:	33 08       	mov	r8,48
80006c8a:	ba 88       	st.b	sp[0x0],r8
80006c8c:	30 1e       	mov	lr,1
80006c8e:	c2 f8       	rjmp	80006cec <PrintDec+0x8a>
	
	int ten = i%10;
80006c90:	e0 65 66 67 	mov	r5,26215
80006c94:	ea 15 66 66 	orh	r5,0x6666
80006c98:	f0 05 04 44 	muls.d	r4,r8,r5
80006c9c:	ea 0c 14 02 	asr	r12,r5,0x2
80006ca0:	f0 09 14 1f 	asr	r9,r8,0x1f
80006ca4:	f8 09 01 09 	sub	r9,r12,r9
80006ca8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006cac:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006cb0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006cb2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006cb4:	e0 66 66 67 	mov	r6,26215
80006cb8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006cbc:	2d 09       	sub	r9,-48
80006cbe:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006cc2:	2f fe       	sub	lr,-1
		i /= 10;
80006cc4:	f0 06 04 44 	muls.d	r4,r8,r6
80006cc8:	ea 09 14 02 	asr	r9,r5,0x2
80006ccc:	bf 58       	asr	r8,0x1f
80006cce:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006cd2:	f0 06 04 44 	muls.d	r4,r8,r6
80006cd6:	ea 09 14 02 	asr	r9,r5,0x2
80006cda:	f0 05 14 1f 	asr	r5,r8,0x1f
80006cde:	0a 19       	sub	r9,r5
80006ce0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ce4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006ce8:	58 08       	cp.w	r8,0
80006cea:	ce 91       	brne	80006cbc <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006cec:	f6 0e 01 08 	sub	r8,r11,lr
80006cf0:	58 08       	cp.w	r8,0
80006cf2:	e0 89 00 06 	brgt	80006cfe <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006cf6:	58 0e       	cp.w	lr,0
80006cf8:	e0 89 00 14 	brgt	80006d20 <PrintDec+0xbe>
80006cfc:	c1 d8       	rjmp	80006d36 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006cfe:	1c 1b       	sub	r11,lr
80006d00:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006d02:	16 9c       	mov	r12,r11
80006d04:	58 0b       	cp.w	r11,0
80006d06:	fe 9a ff f8 	brle	80006cf6 <PrintDec+0x94>
80006d0a:	1a 99       	mov	r9,sp
80006d0c:	1c 09       	add	r9,lr
80006d0e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d10:	33 06       	mov	r6,48
80006d12:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d14:	2f f8       	sub	r8,-1
80006d16:	18 38       	cp.w	r8,r12
80006d18:	cf d5       	brlt	80006d12 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d1a:	f6 0e 00 0e 	add	lr,r11,lr
80006d1e:	ce cb       	rjmp	80006cf6 <PrintDec+0x94>
80006d20:	fa c8 ff f4 	sub	r8,sp,-12
80006d24:	1c 08       	add	r8,lr
80006d26:	20 d8       	sub	r8,13
80006d28:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d2c:	11 89       	ld.ub	r9,r8[0x0]
80006d2e:	0e c9       	st.b	r7++,r9
80006d30:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d32:	16 38       	cp.w	r8,r11
80006d34:	cf c1       	brne	80006d2c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d36:	14 9c       	mov	r12,r10
80006d38:	2f dd       	sub	sp,-12
80006d3a:	d8 22       	popm	r4-r7,pc

80006d3c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d3c:	d4 31       	pushm	r0-r7,lr
80006d3e:	fa cd 02 08 	sub	sp,sp,520
80006d42:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d44:	e0 6a 01 00 	mov	r10,256
80006d48:	30 0b       	mov	r11,0
80006d4a:	fa cc fe f8 	sub	r12,sp,-264
80006d4e:	f0 1f 00 4e 	mcall	80006e84 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d52:	fa c4 fd d4 	sub	r4,sp,-556
80006d56:	30 0a       	mov	r10,0
80006d58:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d5a:	fa c3 ff fc 	sub	r3,sp,-4
80006d5e:	e0 61 01 00 	mov	r1,256
80006d62:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006d64:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006d66:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d6a:	02 9a       	mov	r10,r1
80006d6c:	00 9b       	mov	r11,r0
80006d6e:	06 9c       	mov	r12,r3
80006d70:	f0 1f 00 45 	mcall	80006e84 <log+0x148>
			
					if(*str == '%')
80006d74:	0f 88       	ld.ub	r8,r7[0x0]
80006d76:	e4 08 18 00 	cp.b	r8,r2
80006d7a:	c5 71       	brne	80006e28 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006d7c:	ee c8 ff ff 	sub	r8,r7,-1
80006d80:	11 89       	ld.ub	r9,r8[0x0]
80006d82:	4c 2a       	lddpc	r10,80006e88 <log+0x14c>
80006d84:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006d86:	23 09       	sub	r9,48
80006d88:	30 9a       	mov	r10,9
80006d8a:	f4 09 18 00 	cp.b	r9,r10
80006d8e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006d92:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006d96:	f7 b9 08 30 	subls	r9,48
80006d9a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006d9e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006da2:	0f 88       	ld.ub	r8,r7[0x0]
80006da4:	22 58       	sub	r8,37
80006da6:	e0 48 00 53 	cp.w	r8,83
80006daa:	e0 8b 00 31 	brhi	80006e0c <log+0xd0>
80006dae:	4b 89       	lddpc	r9,80006e8c <log+0x150>
80006db0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006db4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006db8:	06 9a       	mov	r10,r3
80006dba:	40 0b       	lddsp	r11,sp[0x0]
80006dbc:	5c 5b       	castu.b	r11
80006dbe:	68 0c       	ld.w	r12,r4[0x0]
80006dc0:	f0 1f 00 34 	mcall	80006e90 <log+0x154>
							break;
80006dc4:	c2 98       	rjmp	80006e16 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006dc6:	4b 4c       	lddpc	r12,80006e94 <log+0x158>
80006dc8:	f0 1f 00 34 	mcall	80006e98 <log+0x15c>
80006dcc:	08 95       	mov	r5,r4
80006dce:	06 9c       	mov	r12,r3
							break;
80006dd0:	c2 38       	rjmp	80006e16 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006dd2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006dd6:	06 9a       	mov	r10,r3
80006dd8:	40 0b       	lddsp	r11,sp[0x0]
80006dda:	5c 5b       	castu.b	r11
80006ddc:	68 0c       	ld.w	r12,r4[0x0]
80006dde:	f0 1f 00 30 	mcall	80006e9c <log+0x160>
80006de2:	06 9c       	mov	r12,r3
							break;
80006de4:	c1 98       	rjmp	80006e16 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006de6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006dea:	06 9b       	mov	r11,r3
80006dec:	09 bc       	ld.ub	r12,r4[0x3]
80006dee:	f0 1f 00 2d 	mcall	80006ea0 <log+0x164>
80006df2:	06 9c       	mov	r12,r3
							break;
80006df4:	c1 18       	rjmp	80006e16 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006df6:	e8 c5 ff fc 	sub	r5,r4,-4
80006dfa:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006dfc:	c0 d8       	rjmp	80006e16 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006dfe:	06 9b       	mov	r11,r3
80006e00:	32 5c       	mov	r12,37
80006e02:	f0 1f 00 28 	mcall	80006ea0 <log+0x164>
80006e06:	08 95       	mov	r5,r4
80006e08:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006e0a:	c0 68       	rjmp	80006e16 <log+0xda>
							
							default:
							log("I need relax.");
80006e0c:	4a 6c       	lddpc	r12,80006ea4 <log+0x168>
80006e0e:	f0 1f 00 23 	mcall	80006e98 <log+0x15c>
80006e12:	08 95       	mov	r5,r4
80006e14:	06 9c       	mov	r12,r3
						}
						str++;
80006e16:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e18:	1a dc       	st.w	--sp,r12
80006e1a:	1a d6       	st.w	--sp,r6
80006e1c:	4a 3b       	lddpc	r11,80006ea8 <log+0x16c>
80006e1e:	0c 9c       	mov	r12,r6
80006e20:	f0 1f 00 23 	mcall	80006eac <log+0x170>
80006e24:	2f ed       	sub	sp,-8
80006e26:	c0 a8       	rjmp	80006e3a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e28:	2f f7       	sub	r7,-1
80006e2a:	1a d8       	st.w	--sp,r8
80006e2c:	1a d6       	st.w	--sp,r6
80006e2e:	4a 1b       	lddpc	r11,80006eb0 <log+0x174>
80006e30:	0c 9c       	mov	r12,r6
80006e32:	f0 1f 00 1f 	mcall	80006eac <log+0x170>
80006e36:	08 95       	mov	r5,r4
80006e38:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e3a:	0f 89       	ld.ub	r9,r7[0x0]
80006e3c:	30 08       	mov	r8,0
80006e3e:	f0 09 18 00 	cp.b	r9,r8
80006e42:	c0 30       	breq	80006e48 <log+0x10c>
80006e44:	0a 94       	mov	r4,r5
80006e46:	c9 2b       	rjmp	80006d6a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e48:	fa c7 fe f8 	sub	r7,sp,-264
80006e4c:	1a d7       	st.w	--sp,r7
80006e4e:	49 ab       	lddpc	r11,80006eb4 <log+0x178>
80006e50:	0e 9c       	mov	r12,r7
80006e52:	f0 1f 00 17 	mcall	80006eac <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e56:	5c 5c       	castu.b	r12
80006e58:	f8 c6 ff ff 	sub	r6,r12,-1
80006e5c:	0c 9c       	mov	r12,r6
80006e5e:	f0 1f 00 17 	mcall	80006eb8 <log+0x17c>
80006e62:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006e64:	0c 9a       	mov	r10,r6
80006e66:	0e 9b       	mov	r11,r7
80006e68:	f0 1f 00 15 	mcall	80006ebc <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006e6c:	30 09       	mov	r9,0
80006e6e:	30 5a       	mov	r10,5
80006e70:	fa cb fe f8 	sub	r11,sp,-264
80006e74:	49 38       	lddpc	r8,80006ec0 <log+0x184>
80006e76:	70 0c       	ld.w	r12,r8[0x0]
80006e78:	f0 1f 00 13 	mcall	80006ec4 <log+0x188>
80006e7c:	2f fd       	sub	sp,-4
	
	
}
80006e7e:	fe 3d fd f8 	sub	sp,-520
80006e82:	d8 32       	popm	r0-r7,pc
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	77 00       	ld.w	r0,r11[0x40]
80006e88:	00 00       	add	r0,r0
80006e8a:	0d 58       	ld.sh	r8,--r6
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	d7 bc       	*unknown*
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	6c 62       	ld.w	r2,r6[0x18]
80006e94:	80 00       	ld.sh	r0,r0[0x0]
80006e96:	da 68       	*unknown*
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	6d 3c       	ld.w	r12,r6[0x4c]
80006e9c:	80 00       	ld.sh	r0,r0[0x0]
80006e9e:	6b b0       	ld.w	r0,r5[0x6c]
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	6b ac       	ld.w	r12,r5[0x68]
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	da 78       	*unknown*
80006ea8:	80 00       	ld.sh	r0,r0[0x0]
80006eaa:	da 88       	*unknown*
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	79 f0       	ld.w	r0,r12[0x7c]
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	da 90       	acall	0xa9
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	da 98       	*unknown*
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	5e 08       	reteq	r8
80006ebc:	80 00       	ld.sh	r0,r0[0x0]
80006ebe:	75 b8       	ld.w	r8,r10[0x6c]
80006ec0:	00 00       	add	r0,r0
80006ec2:	5b 64       	cp.w	r4,-10
80006ec4:	80 00       	ld.sh	r0,r0[0x0]
80006ec6:	61 5c       	ld.w	r12,r0[0x54]

80006ec8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006ec8:	d4 31       	pushm	r0-r7,lr
80006eca:	fa cd 02 0c 	sub	sp,sp,524
80006ece:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006ed0:	e0 6a 01 00 	mov	r10,256
80006ed4:	30 0b       	mov	r11,0
80006ed6:	fa cc fe f4 	sub	r12,sp,-268
80006eda:	f0 1f 00 4c 	mcall	80007008 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006ede:	fa c4 fd d0 	sub	r4,sp,-560
80006ee2:	30 0a       	mov	r10,0
80006ee4:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ee6:	fa c3 ff fc 	sub	r3,sp,-4
80006eea:	e0 61 01 00 	mov	r1,256
80006eee:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006ef0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ef2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ef6:	02 9a       	mov	r10,r1
80006ef8:	00 9b       	mov	r11,r0
80006efa:	06 9c       	mov	r12,r3
80006efc:	f0 1f 00 43 	mcall	80007008 <logFromISR+0x140>
			
			if(*str == '%')
80006f00:	0f 88       	ld.ub	r8,r7[0x0]
80006f02:	e4 08 18 00 	cp.b	r8,r2
80006f06:	c5 11       	brne	80006fa8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006f08:	ee c8 ff ff 	sub	r8,r7,-1
80006f0c:	11 89       	ld.ub	r9,r8[0x0]
80006f0e:	4c 0a       	lddpc	r10,8000700c <logFromISR+0x144>
80006f10:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f12:	23 09       	sub	r9,48
80006f14:	30 9a       	mov	r10,9
80006f16:	f4 09 18 00 	cp.b	r9,r10
80006f1a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006f1e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f22:	f7 b9 08 30 	subls	r9,48
80006f26:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f2a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f2e:	0f 88       	ld.ub	r8,r7[0x0]
80006f30:	22 58       	sub	r8,37
80006f32:	e0 48 00 53 	cp.w	r8,83
80006f36:	e0 8b 00 2b 	brhi	80006f8c <logFromISR+0xc4>
80006f3a:	4b 69       	lddpc	r9,80007010 <logFromISR+0x148>
80006f3c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f40:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f44:	06 9a       	mov	r10,r3
80006f46:	40 0b       	lddsp	r11,sp[0x0]
80006f48:	5c 5b       	castu.b	r11
80006f4a:	68 0c       	ld.w	r12,r4[0x0]
80006f4c:	f0 1f 00 32 	mcall	80007014 <logFromISR+0x14c>
					break;
80006f50:	c2 38       	rjmp	80006f96 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f52:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f56:	06 9a       	mov	r10,r3
80006f58:	40 0b       	lddsp	r11,sp[0x0]
80006f5a:	5c 5b       	castu.b	r11
80006f5c:	68 0c       	ld.w	r12,r4[0x0]
80006f5e:	f0 1f 00 2f 	mcall	80007018 <logFromISR+0x150>
80006f62:	06 9c       	mov	r12,r3
					break;
80006f64:	c1 98       	rjmp	80006f96 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006f66:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006f6a:	06 9b       	mov	r11,r3
80006f6c:	09 bc       	ld.ub	r12,r4[0x3]
80006f6e:	f0 1f 00 2c 	mcall	8000701c <logFromISR+0x154>
80006f72:	06 9c       	mov	r12,r3
					break;
80006f74:	c1 18       	rjmp	80006f96 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006f76:	e8 c5 ff fc 	sub	r5,r4,-4
80006f7a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006f7c:	c0 d8       	rjmp	80006f96 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006f7e:	06 9b       	mov	r11,r3
80006f80:	32 5c       	mov	r12,37
80006f82:	f0 1f 00 27 	mcall	8000701c <logFromISR+0x154>
80006f86:	08 95       	mov	r5,r4
80006f88:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006f8a:	c0 68       	rjmp	80006f96 <logFromISR+0xce>
					default:
					log("I need relax.");
80006f8c:	4a 5c       	lddpc	r12,80007020 <logFromISR+0x158>
80006f8e:	f0 1f 00 26 	mcall	80007024 <logFromISR+0x15c>
80006f92:	08 95       	mov	r5,r4
80006f94:	06 9c       	mov	r12,r3
				}
				str++;
80006f96:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006f98:	1a dc       	st.w	--sp,r12
80006f9a:	1a d6       	st.w	--sp,r6
80006f9c:	4a 3b       	lddpc	r11,80007028 <logFromISR+0x160>
80006f9e:	0c 9c       	mov	r12,r6
80006fa0:	f0 1f 00 23 	mcall	8000702c <logFromISR+0x164>
80006fa4:	2f ed       	sub	sp,-8
80006fa6:	c0 a8       	rjmp	80006fba <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fa8:	2f f7       	sub	r7,-1
80006faa:	1a d8       	st.w	--sp,r8
80006fac:	1a d6       	st.w	--sp,r6
80006fae:	4a 1b       	lddpc	r11,80007030 <logFromISR+0x168>
80006fb0:	0c 9c       	mov	r12,r6
80006fb2:	f0 1f 00 1f 	mcall	8000702c <logFromISR+0x164>
80006fb6:	08 95       	mov	r5,r4
80006fb8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006fba:	0f 89       	ld.ub	r9,r7[0x0]
80006fbc:	30 08       	mov	r8,0
80006fbe:	f0 09 18 00 	cp.b	r9,r8
80006fc2:	c0 30       	breq	80006fc8 <logFromISR+0x100>
80006fc4:	0a 94       	mov	r4,r5
80006fc6:	c9 8b       	rjmp	80006ef6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006fc8:	fa c7 fe f4 	sub	r7,sp,-268
80006fcc:	1a d7       	st.w	--sp,r7
80006fce:	49 ab       	lddpc	r11,80007034 <logFromISR+0x16c>
80006fd0:	0e 9c       	mov	r12,r7
80006fd2:	f0 1f 00 17 	mcall	8000702c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006fd6:	5c 5c       	castu.b	r12
80006fd8:	f8 c6 ff ff 	sub	r6,r12,-1
80006fdc:	0c 9c       	mov	r12,r6
80006fde:	f0 1f 00 17 	mcall	80007038 <logFromISR+0x170>
80006fe2:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006fe4:	0c 9a       	mov	r10,r6
80006fe6:	0e 9b       	mov	r11,r7
80006fe8:	f0 1f 00 15 	mcall	8000703c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006fec:	30 09       	mov	r9,0
80006fee:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006ff0:	fa ca fe f8 	sub	r10,sp,-264
80006ff4:	fa cb fe f4 	sub	r11,sp,-268
80006ff8:	49 28       	lddpc	r8,80007040 <logFromISR+0x178>
80006ffa:	70 0c       	ld.w	r12,r8[0x0]
80006ffc:	f0 1f 00 12 	mcall	80007044 <logFromISR+0x17c>
80007000:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007002:	fe 3d fd f4 	sub	sp,-524
80007006:	d8 32       	popm	r0-r7,pc
80007008:	80 00       	ld.sh	r0,r0[0x0]
8000700a:	77 00       	ld.w	r0,r11[0x40]
8000700c:	00 00       	add	r0,r0
8000700e:	0d 59       	ld.sh	r9,--r6
80007010:	80 00       	ld.sh	r0,r0[0x0]
80007012:	d9 0c       	*unknown*
80007014:	80 00       	ld.sh	r0,r0[0x0]
80007016:	6c 62       	ld.w	r2,r6[0x18]
80007018:	80 00       	ld.sh	r0,r0[0x0]
8000701a:	6b b0       	ld.w	r0,r5[0x6c]
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	6b ac       	ld.w	r12,r5[0x68]
80007020:	80 00       	ld.sh	r0,r0[0x0]
80007022:	da 78       	*unknown*
80007024:	80 00       	ld.sh	r0,r0[0x0]
80007026:	6d 3c       	ld.w	r12,r6[0x4c]
80007028:	80 00       	ld.sh	r0,r0[0x0]
8000702a:	da 88       	*unknown*
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	79 f0       	ld.w	r0,r12[0x7c]
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	da 90       	acall	0xa9
80007034:	80 00       	ld.sh	r0,r0[0x0]
80007036:	da 98       	*unknown*
80007038:	80 00       	ld.sh	r0,r0[0x0]
8000703a:	5e 08       	reteq	r8
8000703c:	80 00       	ld.sh	r0,r0[0x0]
8000703e:	75 b8       	ld.w	r8,r10[0x6c]
80007040:	00 00       	add	r0,r0
80007042:	5b 64       	cp.w	r4,-10
80007044:	80 00       	ld.sh	r0,r0[0x0]
80007046:	61 0c       	ld.w	r12,r0[0x40]

80007048 <log_init>:
		
	return str;
}

void log_init(void)
{
80007048:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000704a:	30 2b       	mov	r11,2
8000704c:	48 fc       	lddpc	r12,80007088 <log_init+0x40>
8000704e:	f0 1f 00 10 	mcall	8000708c <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007052:	e0 6a 36 00 	mov	r10,13824
80007056:	ea 1a 01 6e 	orh	r10,0x16e
8000705a:	48 eb       	lddpc	r11,80007090 <log_init+0x48>
8000705c:	fe 7c 18 00 	mov	r12,-59392
80007060:	f0 1f 00 0d 	mcall	80007094 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007064:	30 4b       	mov	r11,4
80007066:	33 2c       	mov	r12,50
80007068:	f0 1f 00 0c 	mcall	80007098 <log_init+0x50>
8000706c:	48 c8       	lddpc	r8,8000709c <log_init+0x54>
8000706e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007070:	30 09       	mov	r9,0
80007072:	1a d9       	st.w	--sp,r9
80007074:	1a d9       	st.w	--sp,r9
80007076:	1a d9       	st.w	--sp,r9
80007078:	30 28       	mov	r8,2
8000707a:	36 4a       	mov	r10,100
8000707c:	48 9b       	lddpc	r11,800070a0 <log_init+0x58>
8000707e:	48 ac       	lddpc	r12,800070a4 <log_init+0x5c>
80007080:	f0 1f 00 0a 	mcall	800070a8 <log_init+0x60>
80007084:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007086:	d8 02       	popm	pc
80007088:	80 00       	ld.sh	r0,r0[0x0]
8000708a:	da a4       	*unknown*
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	52 e8       	stdsp	sp[0xb8],r8
80007090:	80 00       	ld.sh	r0,r0[0x0]
80007092:	da 5c       	*unknown*
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	59 6c       	cp.w	r12,22
80007098:	80 00       	ld.sh	r0,r0[0x0]
8000709a:	62 5c       	ld.w	r12,r1[0x14]
8000709c:	00 00       	add	r0,r0
8000709e:	5b 64       	cp.w	r4,-10
800070a0:	80 00       	ld.sh	r0,r0[0x0]
800070a2:	da a0       	acall	0xaa
800070a4:	80 00       	ld.sh	r0,r0[0x0]
800070a6:	70 ac       	ld.w	r12,r8[0x28]
800070a8:	80 00       	ld.sh	r0,r0[0x0]
800070aa:	69 78       	ld.w	r8,r4[0x5c]

800070ac <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800070ac:	eb cd 40 f8 	pushm	r3-r7,lr
800070b0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070b2:	48 c7       	lddpc	r7,800070e0 <task_log+0x34>
800070b4:	30 05       	mov	r5,0
800070b6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800070b8:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070bc:	0a 99       	mov	r9,r5
800070be:	08 9a       	mov	r10,r4
800070c0:	1a 9b       	mov	r11,sp
800070c2:	6e 0c       	ld.w	r12,r7[0x0]
800070c4:	f0 1f 00 08 	mcall	800070e4 <task_log+0x38>
800070c8:	58 1c       	cp.w	r12,1
800070ca:	cf 91       	brne	800070bc <task_log+0x10>
		{
			if( NULL != str)
800070cc:	40 0b       	lddsp	r11,sp[0x0]
800070ce:	58 0b       	cp.w	r11,0
800070d0:	cf 60       	breq	800070bc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800070d2:	06 9c       	mov	r12,r3
800070d4:	f0 1f 00 05 	mcall	800070e8 <task_log+0x3c>
				vPortFree(str);
800070d8:	40 0c       	lddsp	r12,sp[0x0]
800070da:	f0 1f 00 05 	mcall	800070ec <task_log+0x40>
800070de:	ce fb       	rjmp	800070bc <task_log+0x10>
800070e0:	00 00       	add	r0,r0
800070e2:	5b 64       	cp.w	r4,-10
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	5f 50       	srlt	r0
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	59 1c       	cp.w	r12,17
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	5d e0       	*unknown*

800070f0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800070f0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800070f2:	fe 78 10 00 	mov	r8,-61440
800070f6:	30 19       	mov	r9,1
800070f8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800070fc:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007100:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007104:	d3 03       	ssrf	0x10
	local_start_pll0();
80007106:	f0 1f 00 0c 	mcall	80007134 <main+0x44>
		
	INTC_init_interrupts();
8000710a:	f0 1f 00 0c 	mcall	80007138 <main+0x48>
		
	log_init();
8000710e:	f0 1f 00 0c 	mcall	8000713c <main+0x4c>
	log("----start debug----");
80007112:	48 cc       	lddpc	r12,80007140 <main+0x50>
80007114:	f0 1f 00 0c 	mcall	80007144 <main+0x54>
	
	xg_flashc_init();
80007118:	f0 1f 00 0c 	mcall	80007148 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
8000711c:	f0 1f 00 0c 	mcall	8000714c <main+0x5c>
		
	app_init();
80007120:	f0 1f 00 0c 	mcall	80007150 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007124:	f0 1f 00 0c 	mcall	80007154 <main+0x64>

	local_start_timer();
80007128:	f0 1f 00 0c 	mcall	80007158 <main+0x68>
		
	vTaskStartScheduler();
8000712c:	f0 1f 00 0c 	mcall	8000715c <main+0x6c>
	return 0;
	
}
80007130:	d8 0a       	popm	pc,r12=0
80007132:	00 00       	add	r0,r0
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	51 a8       	stdsp	sp[0x68],r8
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	53 ec       	stdsp	sp[0xf8],r12
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	70 48       	ld.w	r8,r8[0x10]
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	da b4       	*unknown*
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	6d 3c       	ld.w	r12,r6[0x4c]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	52 3c       	stdsp	sp[0x8c],r12
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	51 08       	stdsp	sp[0x40],r8
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	20 3c       	sub	r12,3
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	3f ac       	mov	r12,-6
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	51 7c       	stdsp	sp[0x5c],r12
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	6b 60       	ld.w	r0,r5[0x58]

80007160 <free>:
80007160:	d4 01       	pushm	lr
80007162:	e0 68 0a 3c 	mov	r8,2620
80007166:	18 9b       	mov	r11,r12
80007168:	70 0c       	ld.w	r12,r8[0x0]
8000716a:	e0 a0 1e 61 	rcall	8000ae2c <_free_r>
8000716e:	d8 02       	popm	pc

80007170 <malloc>:
80007170:	d4 01       	pushm	lr
80007172:	e0 68 0a 3c 	mov	r8,2620
80007176:	18 9b       	mov	r11,r12
80007178:	70 0c       	ld.w	r12,r8[0x0]
8000717a:	c0 3c       	rcall	80007180 <_malloc_r>
8000717c:	d8 02       	popm	pc
8000717e:	d7 03       	nop

80007180 <_malloc_r>:
80007180:	d4 31       	pushm	r0-r7,lr
80007182:	f6 c8 ff f5 	sub	r8,r11,-11
80007186:	18 95       	mov	r5,r12
80007188:	10 97       	mov	r7,r8
8000718a:	e0 17 ff f8 	andl	r7,0xfff8
8000718e:	59 68       	cp.w	r8,22
80007190:	f9 b7 08 10 	movls	r7,16
80007194:	16 37       	cp.w	r7,r11
80007196:	5f 38       	srlo	r8
80007198:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000719c:	c0 50       	breq	800071a6 <_malloc_r+0x26>
8000719e:	30 c8       	mov	r8,12
800071a0:	99 38       	st.w	r12[0xc],r8
800071a2:	e0 8f 01 fa 	bral	80007596 <_malloc_r+0x416>
800071a6:	fe b0 f5 d3 	rcall	80005d4c <__malloc_lock>
800071aa:	e0 47 01 f7 	cp.w	r7,503
800071ae:	e0 8b 00 1d 	brhi	800071e8 <_malloc_r+0x68>
800071b2:	ee 03 16 03 	lsr	r3,r7,0x3
800071b6:	e0 68 05 3c 	mov	r8,1340
800071ba:	f0 03 00 38 	add	r8,r8,r3<<0x3
800071be:	70 36       	ld.w	r6,r8[0xc]
800071c0:	10 36       	cp.w	r6,r8
800071c2:	c0 61       	brne	800071ce <_malloc_r+0x4e>
800071c4:	ec c8 ff f8 	sub	r8,r6,-8
800071c8:	70 36       	ld.w	r6,r8[0xc]
800071ca:	10 36       	cp.w	r6,r8
800071cc:	c0 c0       	breq	800071e4 <_malloc_r+0x64>
800071ce:	6c 18       	ld.w	r8,r6[0x4]
800071d0:	e0 18 ff fc 	andl	r8,0xfffc
800071d4:	6c 3a       	ld.w	r10,r6[0xc]
800071d6:	ec 08 00 09 	add	r9,r6,r8
800071da:	0a 9c       	mov	r12,r5
800071dc:	6c 28       	ld.w	r8,r6[0x8]
800071de:	95 28       	st.w	r10[0x8],r8
800071e0:	91 3a       	st.w	r8[0xc],r10
800071e2:	c4 78       	rjmp	80007270 <_malloc_r+0xf0>
800071e4:	2f e3       	sub	r3,-2
800071e6:	c4 d8       	rjmp	80007280 <_malloc_r+0x100>
800071e8:	ee 03 16 09 	lsr	r3,r7,0x9
800071ec:	c0 41       	brne	800071f4 <_malloc_r+0x74>
800071ee:	ee 03 16 03 	lsr	r3,r7,0x3
800071f2:	c2 68       	rjmp	8000723e <_malloc_r+0xbe>
800071f4:	58 43       	cp.w	r3,4
800071f6:	e0 8b 00 06 	brhi	80007202 <_malloc_r+0x82>
800071fa:	ee 03 16 06 	lsr	r3,r7,0x6
800071fe:	2c 83       	sub	r3,-56
80007200:	c1 f8       	rjmp	8000723e <_malloc_r+0xbe>
80007202:	59 43       	cp.w	r3,20
80007204:	e0 8b 00 04 	brhi	8000720c <_malloc_r+0x8c>
80007208:	2a 53       	sub	r3,-91
8000720a:	c1 a8       	rjmp	8000723e <_malloc_r+0xbe>
8000720c:	e0 43 00 54 	cp.w	r3,84
80007210:	e0 8b 00 06 	brhi	8000721c <_malloc_r+0x9c>
80007214:	ee 03 16 0c 	lsr	r3,r7,0xc
80007218:	29 23       	sub	r3,-110
8000721a:	c1 28       	rjmp	8000723e <_malloc_r+0xbe>
8000721c:	e0 43 01 54 	cp.w	r3,340
80007220:	e0 8b 00 06 	brhi	8000722c <_malloc_r+0xac>
80007224:	ee 03 16 0f 	lsr	r3,r7,0xf
80007228:	28 93       	sub	r3,-119
8000722a:	c0 a8       	rjmp	8000723e <_malloc_r+0xbe>
8000722c:	e0 43 05 54 	cp.w	r3,1364
80007230:	e0 88 00 04 	brls	80007238 <_malloc_r+0xb8>
80007234:	37 e3       	mov	r3,126
80007236:	c0 48       	rjmp	8000723e <_malloc_r+0xbe>
80007238:	ee 03 16 12 	lsr	r3,r7,0x12
8000723c:	28 43       	sub	r3,-124
8000723e:	e0 6a 05 3c 	mov	r10,1340
80007242:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007246:	74 36       	ld.w	r6,r10[0xc]
80007248:	c1 98       	rjmp	8000727a <_malloc_r+0xfa>
8000724a:	6c 19       	ld.w	r9,r6[0x4]
8000724c:	e0 19 ff fc 	andl	r9,0xfffc
80007250:	f2 07 01 0b 	sub	r11,r9,r7
80007254:	58 fb       	cp.w	r11,15
80007256:	e0 8a 00 04 	brle	8000725e <_malloc_r+0xde>
8000725a:	20 13       	sub	r3,1
8000725c:	c1 18       	rjmp	8000727e <_malloc_r+0xfe>
8000725e:	6c 38       	ld.w	r8,r6[0xc]
80007260:	58 0b       	cp.w	r11,0
80007262:	c0 b5       	brlt	80007278 <_malloc_r+0xf8>
80007264:	6c 2a       	ld.w	r10,r6[0x8]
80007266:	ec 09 00 09 	add	r9,r6,r9
8000726a:	0a 9c       	mov	r12,r5
8000726c:	91 2a       	st.w	r8[0x8],r10
8000726e:	95 38       	st.w	r10[0xc],r8
80007270:	72 18       	ld.w	r8,r9[0x4]
80007272:	a1 a8       	sbr	r8,0x0
80007274:	93 18       	st.w	r9[0x4],r8
80007276:	cb c8       	rjmp	800073ee <_malloc_r+0x26e>
80007278:	10 96       	mov	r6,r8
8000727a:	14 36       	cp.w	r6,r10
8000727c:	ce 71       	brne	8000724a <_malloc_r+0xca>
8000727e:	2f f3       	sub	r3,-1
80007280:	e0 6a 05 3c 	mov	r10,1340
80007284:	f4 cc ff f8 	sub	r12,r10,-8
80007288:	78 26       	ld.w	r6,r12[0x8]
8000728a:	18 36       	cp.w	r6,r12
8000728c:	c6 c0       	breq	80007364 <_malloc_r+0x1e4>
8000728e:	6c 19       	ld.w	r9,r6[0x4]
80007290:	e0 19 ff fc 	andl	r9,0xfffc
80007294:	f2 07 01 08 	sub	r8,r9,r7
80007298:	58 f8       	cp.w	r8,15
8000729a:	e0 89 00 8f 	brgt	800073b8 <_malloc_r+0x238>
8000729e:	99 3c       	st.w	r12[0xc],r12
800072a0:	99 2c       	st.w	r12[0x8],r12
800072a2:	58 08       	cp.w	r8,0
800072a4:	c0 55       	brlt	800072ae <_malloc_r+0x12e>
800072a6:	ec 09 00 09 	add	r9,r6,r9
800072aa:	0a 9c       	mov	r12,r5
800072ac:	ce 2b       	rjmp	80007270 <_malloc_r+0xf0>
800072ae:	e0 49 01 ff 	cp.w	r9,511
800072b2:	e0 8b 00 13 	brhi	800072d8 <_malloc_r+0x158>
800072b6:	a3 99       	lsr	r9,0x3
800072b8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800072bc:	70 2b       	ld.w	r11,r8[0x8]
800072be:	8d 38       	st.w	r6[0xc],r8
800072c0:	8d 2b       	st.w	r6[0x8],r11
800072c2:	97 36       	st.w	r11[0xc],r6
800072c4:	91 26       	st.w	r8[0x8],r6
800072c6:	a3 49       	asr	r9,0x2
800072c8:	74 18       	ld.w	r8,r10[0x4]
800072ca:	30 1b       	mov	r11,1
800072cc:	f6 09 09 49 	lsl	r9,r11,r9
800072d0:	f1 e9 10 09 	or	r9,r8,r9
800072d4:	95 19       	st.w	r10[0x4],r9
800072d6:	c4 78       	rjmp	80007364 <_malloc_r+0x1e4>
800072d8:	f2 0a 16 09 	lsr	r10,r9,0x9
800072dc:	58 4a       	cp.w	r10,4
800072de:	e0 8b 00 07 	brhi	800072ec <_malloc_r+0x16c>
800072e2:	f2 0a 16 06 	lsr	r10,r9,0x6
800072e6:	2c 8a       	sub	r10,-56
800072e8:	c2 08       	rjmp	80007328 <_malloc_r+0x1a8>
800072ea:	d7 03       	nop
800072ec:	59 4a       	cp.w	r10,20
800072ee:	e0 8b 00 04 	brhi	800072f6 <_malloc_r+0x176>
800072f2:	2a 5a       	sub	r10,-91
800072f4:	c1 a8       	rjmp	80007328 <_malloc_r+0x1a8>
800072f6:	e0 4a 00 54 	cp.w	r10,84
800072fa:	e0 8b 00 06 	brhi	80007306 <_malloc_r+0x186>
800072fe:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007302:	29 2a       	sub	r10,-110
80007304:	c1 28       	rjmp	80007328 <_malloc_r+0x1a8>
80007306:	e0 4a 01 54 	cp.w	r10,340
8000730a:	e0 8b 00 06 	brhi	80007316 <_malloc_r+0x196>
8000730e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007312:	28 9a       	sub	r10,-119
80007314:	c0 a8       	rjmp	80007328 <_malloc_r+0x1a8>
80007316:	e0 4a 05 54 	cp.w	r10,1364
8000731a:	e0 88 00 04 	brls	80007322 <_malloc_r+0x1a2>
8000731e:	37 ea       	mov	r10,126
80007320:	c0 48       	rjmp	80007328 <_malloc_r+0x1a8>
80007322:	f2 0a 16 12 	lsr	r10,r9,0x12
80007326:	28 4a       	sub	r10,-124
80007328:	e0 6b 05 3c 	mov	r11,1340
8000732c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007330:	68 28       	ld.w	r8,r4[0x8]
80007332:	08 38       	cp.w	r8,r4
80007334:	c0 e1       	brne	80007350 <_malloc_r+0x1d0>
80007336:	76 19       	ld.w	r9,r11[0x4]
80007338:	a3 4a       	asr	r10,0x2
8000733a:	30 1e       	mov	lr,1
8000733c:	fc 0a 09 4a 	lsl	r10,lr,r10
80007340:	f3 ea 10 0a 	or	r10,r9,r10
80007344:	10 99       	mov	r9,r8
80007346:	97 1a       	st.w	r11[0x4],r10
80007348:	c0 a8       	rjmp	8000735c <_malloc_r+0x1dc>
8000734a:	70 28       	ld.w	r8,r8[0x8]
8000734c:	08 38       	cp.w	r8,r4
8000734e:	c0 60       	breq	8000735a <_malloc_r+0x1da>
80007350:	70 1a       	ld.w	r10,r8[0x4]
80007352:	e0 1a ff fc 	andl	r10,0xfffc
80007356:	14 39       	cp.w	r9,r10
80007358:	cf 93       	brcs	8000734a <_malloc_r+0x1ca>
8000735a:	70 39       	ld.w	r9,r8[0xc]
8000735c:	8d 39       	st.w	r6[0xc],r9
8000735e:	8d 28       	st.w	r6[0x8],r8
80007360:	91 36       	st.w	r8[0xc],r6
80007362:	93 26       	st.w	r9[0x8],r6
80007364:	e6 08 14 02 	asr	r8,r3,0x2
80007368:	30 1b       	mov	r11,1
8000736a:	e0 64 05 3c 	mov	r4,1340
8000736e:	f6 08 09 4b 	lsl	r11,r11,r8
80007372:	68 18       	ld.w	r8,r4[0x4]
80007374:	10 3b       	cp.w	r11,r8
80007376:	e0 8b 00 6b 	brhi	8000744c <_malloc_r+0x2cc>
8000737a:	f7 e8 00 09 	and	r9,r11,r8
8000737e:	c0 b1       	brne	80007394 <_malloc_r+0x214>
80007380:	e0 13 ff fc 	andl	r3,0xfffc
80007384:	a1 7b       	lsl	r11,0x1
80007386:	2f c3       	sub	r3,-4
80007388:	c0 38       	rjmp	8000738e <_malloc_r+0x20e>
8000738a:	2f c3       	sub	r3,-4
8000738c:	a1 7b       	lsl	r11,0x1
8000738e:	f7 e8 00 09 	and	r9,r11,r8
80007392:	cf c0       	breq	8000738a <_malloc_r+0x20a>
80007394:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007398:	06 92       	mov	r2,r3
8000739a:	1c 91       	mov	r1,lr
8000739c:	62 36       	ld.w	r6,r1[0xc]
8000739e:	c2 e8       	rjmp	800073fa <_malloc_r+0x27a>
800073a0:	6c 1a       	ld.w	r10,r6[0x4]
800073a2:	e0 1a ff fc 	andl	r10,0xfffc
800073a6:	f4 07 01 08 	sub	r8,r10,r7
800073aa:	58 f8       	cp.w	r8,15
800073ac:	e0 8a 00 15 	brle	800073d6 <_malloc_r+0x256>
800073b0:	6c 3a       	ld.w	r10,r6[0xc]
800073b2:	6c 29       	ld.w	r9,r6[0x8]
800073b4:	95 29       	st.w	r10[0x8],r9
800073b6:	93 3a       	st.w	r9[0xc],r10
800073b8:	0e 99       	mov	r9,r7
800073ba:	ec 07 00 07 	add	r7,r6,r7
800073be:	a1 a9       	sbr	r9,0x0
800073c0:	99 37       	st.w	r12[0xc],r7
800073c2:	99 27       	st.w	r12[0x8],r7
800073c4:	8d 19       	st.w	r6[0x4],r9
800073c6:	ee 08 09 08 	st.w	r7[r8],r8
800073ca:	8f 2c       	st.w	r7[0x8],r12
800073cc:	8f 3c       	st.w	r7[0xc],r12
800073ce:	a1 a8       	sbr	r8,0x0
800073d0:	0a 9c       	mov	r12,r5
800073d2:	8f 18       	st.w	r7[0x4],r8
800073d4:	c0 d8       	rjmp	800073ee <_malloc_r+0x26e>
800073d6:	6c 39       	ld.w	r9,r6[0xc]
800073d8:	58 08       	cp.w	r8,0
800073da:	c0 f5       	brlt	800073f8 <_malloc_r+0x278>
800073dc:	ec 0a 00 0a 	add	r10,r6,r10
800073e0:	74 18       	ld.w	r8,r10[0x4]
800073e2:	a1 a8       	sbr	r8,0x0
800073e4:	0a 9c       	mov	r12,r5
800073e6:	95 18       	st.w	r10[0x4],r8
800073e8:	6c 28       	ld.w	r8,r6[0x8]
800073ea:	93 28       	st.w	r9[0x8],r8
800073ec:	91 39       	st.w	r8[0xc],r9
800073ee:	fe b0 f4 b5 	rcall	80005d58 <__malloc_unlock>
800073f2:	ec cc ff f8 	sub	r12,r6,-8
800073f6:	d8 32       	popm	r0-r7,pc
800073f8:	12 96       	mov	r6,r9
800073fa:	02 36       	cp.w	r6,r1
800073fc:	cd 21       	brne	800073a0 <_malloc_r+0x220>
800073fe:	2f f2       	sub	r2,-1
80007400:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007404:	c0 30       	breq	8000740a <_malloc_r+0x28a>
80007406:	2f 81       	sub	r1,-8
80007408:	cc ab       	rjmp	8000739c <_malloc_r+0x21c>
8000740a:	1c 98       	mov	r8,lr
8000740c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007410:	c0 81       	brne	80007420 <_malloc_r+0x2a0>
80007412:	68 19       	ld.w	r9,r4[0x4]
80007414:	f6 08 11 ff 	rsub	r8,r11,-1
80007418:	f3 e8 00 08 	and	r8,r9,r8
8000741c:	89 18       	st.w	r4[0x4],r8
8000741e:	c0 78       	rjmp	8000742c <_malloc_r+0x2ac>
80007420:	f0 c9 00 08 	sub	r9,r8,8
80007424:	20 13       	sub	r3,1
80007426:	70 08       	ld.w	r8,r8[0x0]
80007428:	12 38       	cp.w	r8,r9
8000742a:	cf 10       	breq	8000740c <_malloc_r+0x28c>
8000742c:	a1 7b       	lsl	r11,0x1
8000742e:	68 18       	ld.w	r8,r4[0x4]
80007430:	10 3b       	cp.w	r11,r8
80007432:	e0 8b 00 0d 	brhi	8000744c <_malloc_r+0x2cc>
80007436:	58 0b       	cp.w	r11,0
80007438:	c0 a0       	breq	8000744c <_malloc_r+0x2cc>
8000743a:	04 93       	mov	r3,r2
8000743c:	c0 38       	rjmp	80007442 <_malloc_r+0x2c2>
8000743e:	2f c3       	sub	r3,-4
80007440:	a1 7b       	lsl	r11,0x1
80007442:	f7 e8 00 09 	and	r9,r11,r8
80007446:	ca 71       	brne	80007394 <_malloc_r+0x214>
80007448:	cf bb       	rjmp	8000743e <_malloc_r+0x2be>
8000744a:	d7 03       	nop
8000744c:	68 23       	ld.w	r3,r4[0x8]
8000744e:	66 12       	ld.w	r2,r3[0x4]
80007450:	e0 12 ff fc 	andl	r2,0xfffc
80007454:	0e 32       	cp.w	r2,r7
80007456:	5f 39       	srlo	r9
80007458:	e4 07 01 08 	sub	r8,r2,r7
8000745c:	58 f8       	cp.w	r8,15
8000745e:	5f aa       	srle	r10
80007460:	f5 e9 10 09 	or	r9,r10,r9
80007464:	e0 80 00 9a 	breq	80007598 <_malloc_r+0x418>
80007468:	e0 68 0d 64 	mov	r8,3428
8000746c:	70 01       	ld.w	r1,r8[0x0]
8000746e:	e0 68 09 48 	mov	r8,2376
80007472:	2f 01       	sub	r1,-16
80007474:	70 08       	ld.w	r8,r8[0x0]
80007476:	0e 01       	add	r1,r7
80007478:	5b f8       	cp.w	r8,-1
8000747a:	c0 40       	breq	80007482 <_malloc_r+0x302>
8000747c:	28 11       	sub	r1,-127
8000747e:	e0 11 ff 80 	andl	r1,0xff80
80007482:	02 9b       	mov	r11,r1
80007484:	0a 9c       	mov	r12,r5
80007486:	e0 a0 02 a5 	rcall	800079d0 <_sbrk_r>
8000748a:	18 96       	mov	r6,r12
8000748c:	5b fc       	cp.w	r12,-1
8000748e:	c7 50       	breq	80007578 <_malloc_r+0x3f8>
80007490:	e6 02 00 08 	add	r8,r3,r2
80007494:	10 3c       	cp.w	r12,r8
80007496:	c0 32       	brcc	8000749c <_malloc_r+0x31c>
80007498:	08 33       	cp.w	r3,r4
8000749a:	c6 f1       	brne	80007578 <_malloc_r+0x3f8>
8000749c:	e0 6a 0d 68 	mov	r10,3432
800074a0:	74 09       	ld.w	r9,r10[0x0]
800074a2:	e2 09 00 09 	add	r9,r1,r9
800074a6:	95 09       	st.w	r10[0x0],r9
800074a8:	10 36       	cp.w	r6,r8
800074aa:	c0 a1       	brne	800074be <_malloc_r+0x33e>
800074ac:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800074b0:	c0 71       	brne	800074be <_malloc_r+0x33e>
800074b2:	e2 02 00 02 	add	r2,r1,r2
800074b6:	68 28       	ld.w	r8,r4[0x8]
800074b8:	a1 a2       	sbr	r2,0x0
800074ba:	91 12       	st.w	r8[0x4],r2
800074bc:	c4 f8       	rjmp	8000755a <_malloc_r+0x3da>
800074be:	e0 6a 09 48 	mov	r10,2376
800074c2:	74 0b       	ld.w	r11,r10[0x0]
800074c4:	5b fb       	cp.w	r11,-1
800074c6:	c0 31       	brne	800074cc <_malloc_r+0x34c>
800074c8:	95 06       	st.w	r10[0x0],r6
800074ca:	c0 78       	rjmp	800074d8 <_malloc_r+0x358>
800074cc:	ec 09 00 09 	add	r9,r6,r9
800074d0:	e0 6a 0d 68 	mov	r10,3432
800074d4:	10 19       	sub	r9,r8
800074d6:	95 09       	st.w	r10[0x0],r9
800074d8:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800074dc:	f0 09 11 08 	rsub	r9,r8,8
800074e0:	58 08       	cp.w	r8,0
800074e2:	f2 08 17 10 	movne	r8,r9
800074e6:	ed d8 e1 06 	addne	r6,r6,r8
800074ea:	28 08       	sub	r8,-128
800074ec:	ec 01 00 01 	add	r1,r6,r1
800074f0:	0a 9c       	mov	r12,r5
800074f2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800074f6:	f0 01 01 01 	sub	r1,r8,r1
800074fa:	02 9b       	mov	r11,r1
800074fc:	e0 a0 02 6a 	rcall	800079d0 <_sbrk_r>
80007500:	e0 68 0d 68 	mov	r8,3432
80007504:	5b fc       	cp.w	r12,-1
80007506:	ec 0c 17 00 	moveq	r12,r6
8000750a:	f9 b1 00 00 	moveq	r1,0
8000750e:	70 09       	ld.w	r9,r8[0x0]
80007510:	0c 1c       	sub	r12,r6
80007512:	89 26       	st.w	r4[0x8],r6
80007514:	02 0c       	add	r12,r1
80007516:	12 01       	add	r1,r9
80007518:	a1 ac       	sbr	r12,0x0
8000751a:	91 01       	st.w	r8[0x0],r1
8000751c:	8d 1c       	st.w	r6[0x4],r12
8000751e:	08 33       	cp.w	r3,r4
80007520:	c1 d0       	breq	8000755a <_malloc_r+0x3da>
80007522:	58 f2       	cp.w	r2,15
80007524:	e0 8b 00 05 	brhi	8000752e <_malloc_r+0x3ae>
80007528:	30 18       	mov	r8,1
8000752a:	8d 18       	st.w	r6[0x4],r8
8000752c:	c2 68       	rjmp	80007578 <_malloc_r+0x3f8>
8000752e:	30 59       	mov	r9,5
80007530:	20 c2       	sub	r2,12
80007532:	e0 12 ff f8 	andl	r2,0xfff8
80007536:	e6 02 00 08 	add	r8,r3,r2
8000753a:	91 29       	st.w	r8[0x8],r9
8000753c:	91 19       	st.w	r8[0x4],r9
8000753e:	66 18       	ld.w	r8,r3[0x4]
80007540:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007544:	e5 e8 10 08 	or	r8,r2,r8
80007548:	87 18       	st.w	r3[0x4],r8
8000754a:	58 f2       	cp.w	r2,15
8000754c:	e0 88 00 07 	brls	8000755a <_malloc_r+0x3da>
80007550:	e6 cb ff f8 	sub	r11,r3,-8
80007554:	0a 9c       	mov	r12,r5
80007556:	e0 a0 1c 6b 	rcall	8000ae2c <_free_r>
8000755a:	e0 69 0d 60 	mov	r9,3424
8000755e:	72 0a       	ld.w	r10,r9[0x0]
80007560:	e0 68 0d 68 	mov	r8,3432
80007564:	70 08       	ld.w	r8,r8[0x0]
80007566:	14 38       	cp.w	r8,r10
80007568:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000756c:	e0 69 0d 5c 	mov	r9,3420
80007570:	72 0a       	ld.w	r10,r9[0x0]
80007572:	14 38       	cp.w	r8,r10
80007574:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007578:	68 28       	ld.w	r8,r4[0x8]
8000757a:	70 18       	ld.w	r8,r8[0x4]
8000757c:	e0 18 ff fc 	andl	r8,0xfffc
80007580:	0e 38       	cp.w	r8,r7
80007582:	5f 39       	srlo	r9
80007584:	0e 18       	sub	r8,r7
80007586:	58 f8       	cp.w	r8,15
80007588:	5f aa       	srle	r10
8000758a:	f5 e9 10 09 	or	r9,r10,r9
8000758e:	c0 50       	breq	80007598 <_malloc_r+0x418>
80007590:	0a 9c       	mov	r12,r5
80007592:	fe b0 f3 e3 	rcall	80005d58 <__malloc_unlock>
80007596:	d8 3a       	popm	r0-r7,pc,r12=0
80007598:	68 26       	ld.w	r6,r4[0x8]
8000759a:	a1 a8       	sbr	r8,0x0
8000759c:	0e 99       	mov	r9,r7
8000759e:	a1 a9       	sbr	r9,0x0
800075a0:	8d 19       	st.w	r6[0x4],r9
800075a2:	ec 07 00 07 	add	r7,r6,r7
800075a6:	0a 9c       	mov	r12,r5
800075a8:	89 27       	st.w	r4[0x8],r7
800075aa:	8f 18       	st.w	r7[0x4],r8
800075ac:	fe b0 f3 d6 	rcall	80005d58 <__malloc_unlock>
800075b0:	ec cc ff f8 	sub	r12,r6,-8
800075b4:	d8 32       	popm	r0-r7,pc
800075b6:	d7 03       	nop

800075b8 <memcpy>:
800075b8:	58 8a       	cp.w	r10,8
800075ba:	c2 f5       	brlt	80007618 <memcpy+0x60>
800075bc:	f9 eb 10 09 	or	r9,r12,r11
800075c0:	e2 19 00 03 	andl	r9,0x3,COH
800075c4:	e0 81 00 97 	brne	800076f2 <memcpy+0x13a>
800075c8:	e0 4a 00 20 	cp.w	r10,32
800075cc:	c3 b4       	brge	80007642 <memcpy+0x8a>
800075ce:	f4 08 14 02 	asr	r8,r10,0x2
800075d2:	f0 09 11 08 	rsub	r9,r8,8
800075d6:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800075da:	76 69       	ld.w	r9,r11[0x18]
800075dc:	99 69       	st.w	r12[0x18],r9
800075de:	76 59       	ld.w	r9,r11[0x14]
800075e0:	99 59       	st.w	r12[0x14],r9
800075e2:	76 49       	ld.w	r9,r11[0x10]
800075e4:	99 49       	st.w	r12[0x10],r9
800075e6:	76 39       	ld.w	r9,r11[0xc]
800075e8:	99 39       	st.w	r12[0xc],r9
800075ea:	76 29       	ld.w	r9,r11[0x8]
800075ec:	99 29       	st.w	r12[0x8],r9
800075ee:	76 19       	ld.w	r9,r11[0x4]
800075f0:	99 19       	st.w	r12[0x4],r9
800075f2:	76 09       	ld.w	r9,r11[0x0]
800075f4:	99 09       	st.w	r12[0x0],r9
800075f6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800075fa:	f8 08 00 28 	add	r8,r12,r8<<0x2
800075fe:	e0 1a 00 03 	andl	r10,0x3
80007602:	f4 0a 11 04 	rsub	r10,r10,4
80007606:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000760a:	17 a9       	ld.ub	r9,r11[0x2]
8000760c:	b0 a9       	st.b	r8[0x2],r9
8000760e:	17 99       	ld.ub	r9,r11[0x1]
80007610:	b0 99       	st.b	r8[0x1],r9
80007612:	17 89       	ld.ub	r9,r11[0x0]
80007614:	b0 89       	st.b	r8[0x0],r9
80007616:	5e fc       	retal	r12
80007618:	f4 0a 11 09 	rsub	r10,r10,9
8000761c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007620:	17 f9       	ld.ub	r9,r11[0x7]
80007622:	b8 f9       	st.b	r12[0x7],r9
80007624:	17 e9       	ld.ub	r9,r11[0x6]
80007626:	b8 e9       	st.b	r12[0x6],r9
80007628:	17 d9       	ld.ub	r9,r11[0x5]
8000762a:	b8 d9       	st.b	r12[0x5],r9
8000762c:	17 c9       	ld.ub	r9,r11[0x4]
8000762e:	b8 c9       	st.b	r12[0x4],r9
80007630:	17 b9       	ld.ub	r9,r11[0x3]
80007632:	b8 b9       	st.b	r12[0x3],r9
80007634:	17 a9       	ld.ub	r9,r11[0x2]
80007636:	b8 a9       	st.b	r12[0x2],r9
80007638:	17 99       	ld.ub	r9,r11[0x1]
8000763a:	b8 99       	st.b	r12[0x1],r9
8000763c:	17 89       	ld.ub	r9,r11[0x0]
8000763e:	b8 89       	st.b	r12[0x0],r9
80007640:	5e fc       	retal	r12
80007642:	eb cd 40 c0 	pushm	r6-r7,lr
80007646:	18 99       	mov	r9,r12
80007648:	22 0a       	sub	r10,32
8000764a:	b7 07       	ld.d	r6,r11++
8000764c:	b3 26       	st.d	r9++,r6
8000764e:	b7 07       	ld.d	r6,r11++
80007650:	b3 26       	st.d	r9++,r6
80007652:	b7 07       	ld.d	r6,r11++
80007654:	b3 26       	st.d	r9++,r6
80007656:	b7 07       	ld.d	r6,r11++
80007658:	b3 26       	st.d	r9++,r6
8000765a:	22 0a       	sub	r10,32
8000765c:	cf 74       	brge	8000764a <memcpy+0x92>
8000765e:	2f 0a       	sub	r10,-16
80007660:	c0 65       	brlt	8000766c <memcpy+0xb4>
80007662:	b7 07       	ld.d	r6,r11++
80007664:	b3 26       	st.d	r9++,r6
80007666:	b7 07       	ld.d	r6,r11++
80007668:	b3 26       	st.d	r9++,r6
8000766a:	21 0a       	sub	r10,16
8000766c:	5c 3a       	neg	r10
8000766e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007672:	d7 03       	nop
80007674:	d7 03       	nop
80007676:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000767a:	f3 66 00 0e 	st.b	r9[14],r6
8000767e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007682:	f3 66 00 0d 	st.b	r9[13],r6
80007686:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000768a:	f3 66 00 0c 	st.b	r9[12],r6
8000768e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007692:	f3 66 00 0b 	st.b	r9[11],r6
80007696:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000769a:	f3 66 00 0a 	st.b	r9[10],r6
8000769e:	f7 36 00 09 	ld.ub	r6,r11[9]
800076a2:	f3 66 00 09 	st.b	r9[9],r6
800076a6:	f7 36 00 08 	ld.ub	r6,r11[8]
800076aa:	f3 66 00 08 	st.b	r9[8],r6
800076ae:	f7 36 00 07 	ld.ub	r6,r11[7]
800076b2:	f3 66 00 07 	st.b	r9[7],r6
800076b6:	f7 36 00 06 	ld.ub	r6,r11[6]
800076ba:	f3 66 00 06 	st.b	r9[6],r6
800076be:	f7 36 00 05 	ld.ub	r6,r11[5]
800076c2:	f3 66 00 05 	st.b	r9[5],r6
800076c6:	f7 36 00 04 	ld.ub	r6,r11[4]
800076ca:	f3 66 00 04 	st.b	r9[4],r6
800076ce:	f7 36 00 03 	ld.ub	r6,r11[3]
800076d2:	f3 66 00 03 	st.b	r9[3],r6
800076d6:	f7 36 00 02 	ld.ub	r6,r11[2]
800076da:	f3 66 00 02 	st.b	r9[2],r6
800076de:	f7 36 00 01 	ld.ub	r6,r11[1]
800076e2:	f3 66 00 01 	st.b	r9[1],r6
800076e6:	f7 36 00 00 	ld.ub	r6,r11[0]
800076ea:	f3 66 00 00 	st.b	r9[0],r6
800076ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076f2:	20 1a       	sub	r10,1
800076f4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800076f8:	f8 0a 0b 09 	st.b	r12[r10],r9
800076fc:	cf b1       	brne	800076f2 <memcpy+0x13a>
800076fe:	5e fc       	retal	r12

80007700 <memset>:
80007700:	18 98       	mov	r8,r12
80007702:	c0 38       	rjmp	80007708 <memset+0x8>
80007704:	10 cb       	st.b	r8++,r11
80007706:	20 1a       	sub	r10,1
80007708:	58 0a       	cp.w	r10,0
8000770a:	cf d1       	brne	80007704 <memset+0x4>
8000770c:	5e fc       	retal	r12
8000770e:	d7 03       	nop

80007710 <_realloc_r>:
80007710:	d4 31       	pushm	r0-r7,lr
80007712:	20 1d       	sub	sp,4
80007714:	16 94       	mov	r4,r11
80007716:	18 92       	mov	r2,r12
80007718:	14 9b       	mov	r11,r10
8000771a:	58 04       	cp.w	r4,0
8000771c:	c0 51       	brne	80007726 <_realloc_r+0x16>
8000771e:	fe b0 fd 31 	rcall	80007180 <_malloc_r>
80007722:	18 95       	mov	r5,r12
80007724:	c5 39       	rjmp	800079ca <_realloc_r+0x2ba>
80007726:	50 0a       	stdsp	sp[0x0],r10
80007728:	fe b0 f3 12 	rcall	80005d4c <__malloc_lock>
8000772c:	40 0b       	lddsp	r11,sp[0x0]
8000772e:	f6 c8 ff f5 	sub	r8,r11,-11
80007732:	e8 c1 00 08 	sub	r1,r4,8
80007736:	10 96       	mov	r6,r8
80007738:	62 1c       	ld.w	r12,r1[0x4]
8000773a:	e0 16 ff f8 	andl	r6,0xfff8
8000773e:	59 68       	cp.w	r8,22
80007740:	f9 b6 08 10 	movls	r6,16
80007744:	16 36       	cp.w	r6,r11
80007746:	5f 38       	srlo	r8
80007748:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000774c:	c0 50       	breq	80007756 <_realloc_r+0x46>
8000774e:	30 c8       	mov	r8,12
80007750:	30 05       	mov	r5,0
80007752:	85 38       	st.w	r2[0xc],r8
80007754:	c3 b9       	rjmp	800079ca <_realloc_r+0x2ba>
80007756:	18 90       	mov	r0,r12
80007758:	e0 10 ff fc 	andl	r0,0xfffc
8000775c:	0c 30       	cp.w	r0,r6
8000775e:	e0 84 01 0b 	brge	80007974 <_realloc_r+0x264>
80007762:	e0 68 05 3c 	mov	r8,1340
80007766:	e2 00 00 09 	add	r9,r1,r0
8000776a:	70 25       	ld.w	r5,r8[0x8]
8000776c:	0a 39       	cp.w	r9,r5
8000776e:	c0 90       	breq	80007780 <_realloc_r+0x70>
80007770:	72 1a       	ld.w	r10,r9[0x4]
80007772:	a1 ca       	cbr	r10,0x0
80007774:	f2 0a 00 0a 	add	r10,r9,r10
80007778:	74 1a       	ld.w	r10,r10[0x4]
8000777a:	ed ba 00 00 	bld	r10,0x0
8000777e:	c2 20       	breq	800077c2 <_realloc_r+0xb2>
80007780:	72 1a       	ld.w	r10,r9[0x4]
80007782:	e0 1a ff fc 	andl	r10,0xfffc
80007786:	f4 00 00 03 	add	r3,r10,r0
8000778a:	0a 39       	cp.w	r9,r5
8000778c:	c1 31       	brne	800077b2 <_realloc_r+0xa2>
8000778e:	ec c7 ff f0 	sub	r7,r6,-16
80007792:	0e 33       	cp.w	r3,r7
80007794:	c1 95       	brlt	800077c6 <_realloc_r+0xb6>
80007796:	e2 06 00 09 	add	r9,r1,r6
8000779a:	0c 13       	sub	r3,r6
8000779c:	a1 a3       	sbr	r3,0x0
8000779e:	93 13       	st.w	r9[0x4],r3
800077a0:	91 29       	st.w	r8[0x8],r9
800077a2:	04 9c       	mov	r12,r2
800077a4:	62 18       	ld.w	r8,r1[0x4]
800077a6:	08 95       	mov	r5,r4
800077a8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077ac:	10 46       	or	r6,r8
800077ae:	83 16       	st.w	r1[0x4],r6
800077b0:	c0 b9       	rjmp	800079c6 <_realloc_r+0x2b6>
800077b2:	0c 33       	cp.w	r3,r6
800077b4:	c0 95       	brlt	800077c6 <_realloc_r+0xb6>
800077b6:	72 28       	ld.w	r8,r9[0x8]
800077b8:	02 97       	mov	r7,r1
800077ba:	72 39       	ld.w	r9,r9[0xc]
800077bc:	93 28       	st.w	r9[0x8],r8
800077be:	91 39       	st.w	r8[0xc],r9
800077c0:	cd c8       	rjmp	80007978 <_realloc_r+0x268>
800077c2:	30 0a       	mov	r10,0
800077c4:	14 99       	mov	r9,r10
800077c6:	ed bc 00 00 	bld	r12,0x0
800077ca:	e0 80 00 95 	breq	800078f4 <_realloc_r+0x1e4>
800077ce:	62 07       	ld.w	r7,r1[0x0]
800077d0:	e2 07 01 07 	sub	r7,r1,r7
800077d4:	6e 1c       	ld.w	r12,r7[0x4]
800077d6:	e0 1c ff fc 	andl	r12,0xfffc
800077da:	58 09       	cp.w	r9,0
800077dc:	c5 60       	breq	80007888 <_realloc_r+0x178>
800077de:	f8 00 00 03 	add	r3,r12,r0
800077e2:	0a 39       	cp.w	r9,r5
800077e4:	c4 81       	brne	80007874 <_realloc_r+0x164>
800077e6:	14 03       	add	r3,r10
800077e8:	ec c9 ff f0 	sub	r9,r6,-16
800077ec:	12 33       	cp.w	r3,r9
800077ee:	c4 d5       	brlt	80007888 <_realloc_r+0x178>
800077f0:	6e 3a       	ld.w	r10,r7[0xc]
800077f2:	6e 29       	ld.w	r9,r7[0x8]
800077f4:	95 29       	st.w	r10[0x8],r9
800077f6:	93 3a       	st.w	r9[0xc],r10
800077f8:	ee c5 ff f8 	sub	r5,r7,-8
800077fc:	e0 ca 00 04 	sub	r10,r0,4
80007800:	e0 4a 00 24 	cp.w	r10,36
80007804:	e0 8b 00 25 	brhi	8000784e <_realloc_r+0x13e>
80007808:	0a 99       	mov	r9,r5
8000780a:	59 3a       	cp.w	r10,19
8000780c:	e0 88 00 1a 	brls	80007840 <_realloc_r+0x130>
80007810:	09 09       	ld.w	r9,r4++
80007812:	8b 09       	st.w	r5[0x0],r9
80007814:	09 09       	ld.w	r9,r4++
80007816:	8f 39       	st.w	r7[0xc],r9
80007818:	ee c9 ff f0 	sub	r9,r7,-16
8000781c:	59 ba       	cp.w	r10,27
8000781e:	e0 88 00 11 	brls	80007840 <_realloc_r+0x130>
80007822:	09 0b       	ld.w	r11,r4++
80007824:	93 0b       	st.w	r9[0x0],r11
80007826:	09 09       	ld.w	r9,r4++
80007828:	8f 59       	st.w	r7[0x14],r9
8000782a:	ee c9 ff e8 	sub	r9,r7,-24
8000782e:	e0 4a 00 24 	cp.w	r10,36
80007832:	c0 71       	brne	80007840 <_realloc_r+0x130>
80007834:	09 0a       	ld.w	r10,r4++
80007836:	93 0a       	st.w	r9[0x0],r10
80007838:	ee c9 ff e0 	sub	r9,r7,-32
8000783c:	09 0a       	ld.w	r10,r4++
8000783e:	8f 7a       	st.w	r7[0x1c],r10
80007840:	09 0a       	ld.w	r10,r4++
80007842:	12 aa       	st.w	r9++,r10
80007844:	68 0a       	ld.w	r10,r4[0x0]
80007846:	93 0a       	st.w	r9[0x0],r10
80007848:	68 1a       	ld.w	r10,r4[0x4]
8000784a:	93 1a       	st.w	r9[0x4],r10
8000784c:	c0 78       	rjmp	8000785a <_realloc_r+0x14a>
8000784e:	50 08       	stdsp	sp[0x0],r8
80007850:	08 9b       	mov	r11,r4
80007852:	0a 9c       	mov	r12,r5
80007854:	e0 a0 1d 8f 	rcall	8000b372 <memmove>
80007858:	40 08       	lddsp	r8,sp[0x0]
8000785a:	ee 06 00 09 	add	r9,r7,r6
8000785e:	0c 13       	sub	r3,r6
80007860:	a1 a3       	sbr	r3,0x0
80007862:	93 13       	st.w	r9[0x4],r3
80007864:	91 29       	st.w	r8[0x8],r9
80007866:	04 9c       	mov	r12,r2
80007868:	6e 18       	ld.w	r8,r7[0x4]
8000786a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000786e:	10 46       	or	r6,r8
80007870:	8f 16       	st.w	r7[0x4],r6
80007872:	ca a8       	rjmp	800079c6 <_realloc_r+0x2b6>
80007874:	14 03       	add	r3,r10
80007876:	0c 33       	cp.w	r3,r6
80007878:	c0 85       	brlt	80007888 <_realloc_r+0x178>
8000787a:	72 28       	ld.w	r8,r9[0x8]
8000787c:	72 39       	ld.w	r9,r9[0xc]
8000787e:	93 28       	st.w	r9[0x8],r8
80007880:	91 39       	st.w	r8[0xc],r9
80007882:	6e 28       	ld.w	r8,r7[0x8]
80007884:	6e 39       	ld.w	r9,r7[0xc]
80007886:	c0 78       	rjmp	80007894 <_realloc_r+0x184>
80007888:	f8 00 00 03 	add	r3,r12,r0
8000788c:	0c 33       	cp.w	r3,r6
8000788e:	c3 35       	brlt	800078f4 <_realloc_r+0x1e4>
80007890:	6e 39       	ld.w	r9,r7[0xc]
80007892:	6e 28       	ld.w	r8,r7[0x8]
80007894:	93 28       	st.w	r9[0x8],r8
80007896:	91 39       	st.w	r8[0xc],r9
80007898:	e0 ca 00 04 	sub	r10,r0,4
8000789c:	ee cc ff f8 	sub	r12,r7,-8
800078a0:	e0 4a 00 24 	cp.w	r10,36
800078a4:	e0 8b 00 24 	brhi	800078ec <_realloc_r+0x1dc>
800078a8:	59 3a       	cp.w	r10,19
800078aa:	e0 88 00 1a 	brls	800078de <_realloc_r+0x1ce>
800078ae:	09 08       	ld.w	r8,r4++
800078b0:	99 08       	st.w	r12[0x0],r8
800078b2:	09 08       	ld.w	r8,r4++
800078b4:	8f 38       	st.w	r7[0xc],r8
800078b6:	ee cc ff f0 	sub	r12,r7,-16
800078ba:	59 ba       	cp.w	r10,27
800078bc:	e0 88 00 11 	brls	800078de <_realloc_r+0x1ce>
800078c0:	09 08       	ld.w	r8,r4++
800078c2:	99 08       	st.w	r12[0x0],r8
800078c4:	09 08       	ld.w	r8,r4++
800078c6:	8f 58       	st.w	r7[0x14],r8
800078c8:	ee cc ff e8 	sub	r12,r7,-24
800078cc:	e0 4a 00 24 	cp.w	r10,36
800078d0:	c0 71       	brne	800078de <_realloc_r+0x1ce>
800078d2:	09 08       	ld.w	r8,r4++
800078d4:	99 08       	st.w	r12[0x0],r8
800078d6:	ee cc ff e0 	sub	r12,r7,-32
800078da:	09 08       	ld.w	r8,r4++
800078dc:	8f 78       	st.w	r7[0x1c],r8
800078de:	09 08       	ld.w	r8,r4++
800078e0:	18 a8       	st.w	r12++,r8
800078e2:	68 08       	ld.w	r8,r4[0x0]
800078e4:	99 08       	st.w	r12[0x0],r8
800078e6:	68 18       	ld.w	r8,r4[0x4]
800078e8:	99 18       	st.w	r12[0x4],r8
800078ea:	c4 78       	rjmp	80007978 <_realloc_r+0x268>
800078ec:	08 9b       	mov	r11,r4
800078ee:	e0 a0 1d 42 	rcall	8000b372 <memmove>
800078f2:	c4 38       	rjmp	80007978 <_realloc_r+0x268>
800078f4:	04 9c       	mov	r12,r2
800078f6:	fe b0 fc 45 	rcall	80007180 <_malloc_r>
800078fa:	18 95       	mov	r5,r12
800078fc:	c3 a0       	breq	80007970 <_realloc_r+0x260>
800078fe:	62 18       	ld.w	r8,r1[0x4]
80007900:	f8 c9 00 08 	sub	r9,r12,8
80007904:	a1 c8       	cbr	r8,0x0
80007906:	e2 08 00 08 	add	r8,r1,r8
8000790a:	10 39       	cp.w	r9,r8
8000790c:	c0 71       	brne	8000791a <_realloc_r+0x20a>
8000790e:	72 13       	ld.w	r3,r9[0x4]
80007910:	02 97       	mov	r7,r1
80007912:	e0 13 ff fc 	andl	r3,0xfffc
80007916:	00 03       	add	r3,r0
80007918:	c3 08       	rjmp	80007978 <_realloc_r+0x268>
8000791a:	e0 ca 00 04 	sub	r10,r0,4
8000791e:	e0 4a 00 24 	cp.w	r10,36
80007922:	e0 8b 00 20 	brhi	80007962 <_realloc_r+0x252>
80007926:	08 99       	mov	r9,r4
80007928:	18 98       	mov	r8,r12
8000792a:	59 3a       	cp.w	r10,19
8000792c:	e0 88 00 14 	brls	80007954 <_realloc_r+0x244>
80007930:	13 0b       	ld.w	r11,r9++
80007932:	10 ab       	st.w	r8++,r11
80007934:	13 0b       	ld.w	r11,r9++
80007936:	10 ab       	st.w	r8++,r11
80007938:	59 ba       	cp.w	r10,27
8000793a:	e0 88 00 0d 	brls	80007954 <_realloc_r+0x244>
8000793e:	13 0b       	ld.w	r11,r9++
80007940:	10 ab       	st.w	r8++,r11
80007942:	13 0b       	ld.w	r11,r9++
80007944:	10 ab       	st.w	r8++,r11
80007946:	e0 4a 00 24 	cp.w	r10,36
8000794a:	c0 51       	brne	80007954 <_realloc_r+0x244>
8000794c:	13 0a       	ld.w	r10,r9++
8000794e:	10 aa       	st.w	r8++,r10
80007950:	13 0a       	ld.w	r10,r9++
80007952:	10 aa       	st.w	r8++,r10
80007954:	13 0a       	ld.w	r10,r9++
80007956:	10 aa       	st.w	r8++,r10
80007958:	72 0a       	ld.w	r10,r9[0x0]
8000795a:	91 0a       	st.w	r8[0x0],r10
8000795c:	72 19       	ld.w	r9,r9[0x4]
8000795e:	91 19       	st.w	r8[0x4],r9
80007960:	c0 48       	rjmp	80007968 <_realloc_r+0x258>
80007962:	08 9b       	mov	r11,r4
80007964:	e0 a0 1d 07 	rcall	8000b372 <memmove>
80007968:	08 9b       	mov	r11,r4
8000796a:	04 9c       	mov	r12,r2
8000796c:	e0 a0 1a 60 	rcall	8000ae2c <_free_r>
80007970:	04 9c       	mov	r12,r2
80007972:	c2 a8       	rjmp	800079c6 <_realloc_r+0x2b6>
80007974:	00 93       	mov	r3,r0
80007976:	02 97       	mov	r7,r1
80007978:	e6 06 01 09 	sub	r9,r3,r6
8000797c:	6e 18       	ld.w	r8,r7[0x4]
8000797e:	58 f9       	cp.w	r9,15
80007980:	e0 88 00 16 	brls	800079ac <_realloc_r+0x29c>
80007984:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007988:	ed e8 10 08 	or	r8,r6,r8
8000798c:	8f 18       	st.w	r7[0x4],r8
8000798e:	12 98       	mov	r8,r9
80007990:	a1 a8       	sbr	r8,0x0
80007992:	ee 06 00 0b 	add	r11,r7,r6
80007996:	f6 09 00 09 	add	r9,r11,r9
8000799a:	97 18       	st.w	r11[0x4],r8
8000799c:	72 18       	ld.w	r8,r9[0x4]
8000799e:	a1 a8       	sbr	r8,0x0
800079a0:	2f 8b       	sub	r11,-8
800079a2:	93 18       	st.w	r9[0x4],r8
800079a4:	04 9c       	mov	r12,r2
800079a6:	e0 a0 1a 43 	rcall	8000ae2c <_free_r>
800079aa:	c0 b8       	rjmp	800079c0 <_realloc_r+0x2b0>
800079ac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079b0:	e7 e8 10 08 	or	r8,r3,r8
800079b4:	8f 18       	st.w	r7[0x4],r8
800079b6:	ee 03 00 03 	add	r3,r7,r3
800079ba:	66 18       	ld.w	r8,r3[0x4]
800079bc:	a1 a8       	sbr	r8,0x0
800079be:	87 18       	st.w	r3[0x4],r8
800079c0:	04 9c       	mov	r12,r2
800079c2:	ee c5 ff f8 	sub	r5,r7,-8
800079c6:	fe b0 f1 c9 	rcall	80005d58 <__malloc_unlock>
800079ca:	0a 9c       	mov	r12,r5
800079cc:	2f fd       	sub	sp,-4
800079ce:	d8 32       	popm	r0-r7,pc

800079d0 <_sbrk_r>:
800079d0:	d4 21       	pushm	r4-r7,lr
800079d2:	30 08       	mov	r8,0
800079d4:	18 97       	mov	r7,r12
800079d6:	e0 66 5b 68 	mov	r6,23400
800079da:	16 9c       	mov	r12,r11
800079dc:	8d 08       	st.w	r6[0x0],r8
800079de:	c8 5c       	rcall	80007ae8 <_sbrk>
800079e0:	5b fc       	cp.w	r12,-1
800079e2:	c0 51       	brne	800079ec <_sbrk_r+0x1c>
800079e4:	6c 08       	ld.w	r8,r6[0x0]
800079e6:	58 08       	cp.w	r8,0
800079e8:	ef f8 1a 03 	st.wne	r7[0xc],r8
800079ec:	d8 22       	popm	r4-r7,pc
800079ee:	d7 03       	nop

800079f0 <sprintf>:
800079f0:	d4 01       	pushm	lr
800079f2:	21 7d       	sub	sp,92
800079f4:	e0 68 ff ff 	mov	r8,65535
800079f8:	ea 18 7f ff 	orh	r8,0x7fff
800079fc:	50 58       	stdsp	sp[0x14],r8
800079fe:	50 28       	stdsp	sp[0x8],r8
80007a00:	e0 68 02 08 	mov	r8,520
80007a04:	ba 68       	st.h	sp[0xc],r8
80007a06:	3f f8       	mov	r8,-1
80007a08:	ba 78       	st.h	sp[0xe],r8
80007a0a:	e0 68 0a 3c 	mov	r8,2620
80007a0e:	50 4c       	stdsp	sp[0x10],r12
80007a10:	16 9a       	mov	r10,r11
80007a12:	50 0c       	stdsp	sp[0x0],r12
80007a14:	fa c9 ff a0 	sub	r9,sp,-96
80007a18:	70 0c       	ld.w	r12,r8[0x0]
80007a1a:	1a 9b       	mov	r11,sp
80007a1c:	e0 a0 02 1a 	rcall	80007e50 <_vfprintf_r>
80007a20:	30 09       	mov	r9,0
80007a22:	40 08       	lddsp	r8,sp[0x0]
80007a24:	b0 89       	st.b	r8[0x0],r9
80007a26:	2e 9d       	sub	sp,-92
80007a28:	d8 02       	popm	pc
80007a2a:	d7 03       	nop

80007a2c <strncpy>:
80007a2c:	30 08       	mov	r8,0
80007a2e:	10 3a       	cp.w	r10,r8
80007a30:	5e 0c       	reteq	r12
80007a32:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007a36:	f8 08 0b 09 	st.b	r12[r8],r9
80007a3a:	2f f8       	sub	r8,-1
80007a3c:	58 09       	cp.w	r9,0
80007a3e:	cf 81       	brne	80007a2e <strncpy+0x2>
80007a40:	10 3a       	cp.w	r10,r8
80007a42:	5e 0c       	reteq	r12
80007a44:	f8 08 0b 09 	st.b	r12[r8],r9
80007a48:	2f f8       	sub	r8,-1
80007a4a:	cf bb       	rjmp	80007a40 <strncpy+0x14>

80007a4c <_close>:
80007a4c:	30 28       	mov	r8,2
80007a4e:	d6 73       	breakpoint
80007a50:	3f fc       	mov	r12,-1
80007a52:	35 8b       	mov	r11,88
80007a54:	58 0c       	cp.w	r12,0
80007a56:	5e 4c       	retge	r12
80007a58:	e0 6a 5b 68 	mov	r10,23400
80007a5c:	95 0b       	st.w	r10[0x0],r11
80007a5e:	5e fc       	retal	r12

80007a60 <_lseek>:
80007a60:	30 58       	mov	r8,5
80007a62:	d6 73       	breakpoint
80007a64:	3f fc       	mov	r12,-1
80007a66:	35 8b       	mov	r11,88
80007a68:	58 0c       	cp.w	r12,0
80007a6a:	5e 4c       	retge	r12
80007a6c:	e0 6a 5b 68 	mov	r10,23400
80007a70:	95 0b       	st.w	r10[0x0],r11
80007a72:	5e fc       	retal	r12

80007a74 <isatty>:
80007a74:	30 b8       	mov	r8,11
80007a76:	d6 73       	breakpoint
80007a78:	3f fc       	mov	r12,-1
80007a7a:	35 8b       	mov	r11,88
80007a7c:	58 0c       	cp.w	r12,0
80007a7e:	5e 4c       	retge	r12
80007a80:	e0 6a 5b 68 	mov	r10,23400
80007a84:	95 0b       	st.w	r10[0x0],r11
80007a86:	5e fc       	retal	r12

80007a88 <_fstat_host>:
80007a88:	30 98       	mov	r8,9
80007a8a:	d6 73       	breakpoint
80007a8c:	3f fc       	mov	r12,-1
80007a8e:	35 8b       	mov	r11,88
80007a90:	58 0c       	cp.w	r12,0
80007a92:	5e 4c       	retge	r12
80007a94:	e0 6a 5b 68 	mov	r10,23400
80007a98:	95 0b       	st.w	r10[0x0],r11
80007a9a:	5e fc       	retal	r12

80007a9c <_fstat>:
80007a9c:	d4 21       	pushm	r4-r7,lr
80007a9e:	21 0d       	sub	sp,64
80007aa0:	16 97       	mov	r7,r11
80007aa2:	1a 9b       	mov	r11,sp
80007aa4:	cf 2f       	rcall	80007a88 <_fstat_host>
80007aa6:	c0 34       	brge	80007aac <_fstat+0x10>
80007aa8:	3f fc       	mov	r12,-1
80007aaa:	c1 c8       	rjmp	80007ae2 <_fstat+0x46>
80007aac:	40 08       	lddsp	r8,sp[0x0]
80007aae:	ae 08       	st.h	r7[0x0],r8
80007ab0:	40 18       	lddsp	r8,sp[0x4]
80007ab2:	ae 18       	st.h	r7[0x2],r8
80007ab4:	40 28       	lddsp	r8,sp[0x8]
80007ab6:	8f 18       	st.w	r7[0x4],r8
80007ab8:	40 38       	lddsp	r8,sp[0xc]
80007aba:	ae 48       	st.h	r7[0x8],r8
80007abc:	40 48       	lddsp	r8,sp[0x10]
80007abe:	ae 58       	st.h	r7[0xa],r8
80007ac0:	40 58       	lddsp	r8,sp[0x14]
80007ac2:	ae 68       	st.h	r7[0xc],r8
80007ac4:	40 68       	lddsp	r8,sp[0x18]
80007ac6:	ae 78       	st.h	r7[0xe],r8
80007ac8:	40 88       	lddsp	r8,sp[0x20]
80007aca:	8f 48       	st.w	r7[0x10],r8
80007acc:	40 a8       	lddsp	r8,sp[0x28]
80007ace:	8f b8       	st.w	r7[0x2c],r8
80007ad0:	40 c8       	lddsp	r8,sp[0x30]
80007ad2:	8f c8       	st.w	r7[0x30],r8
80007ad4:	40 d8       	lddsp	r8,sp[0x34]
80007ad6:	8f 58       	st.w	r7[0x14],r8
80007ad8:	40 e8       	lddsp	r8,sp[0x38]
80007ada:	30 0c       	mov	r12,0
80007adc:	8f 78       	st.w	r7[0x1c],r8
80007ade:	40 f8       	lddsp	r8,sp[0x3c]
80007ae0:	8f 98       	st.w	r7[0x24],r8
80007ae2:	2f 0d       	sub	sp,-64
80007ae4:	d8 22       	popm	r4-r7,pc
80007ae6:	d7 03       	nop

80007ae8 <_sbrk>:
80007ae8:	d4 01       	pushm	lr
80007aea:	e0 68 0d 90 	mov	r8,3472
80007aee:	70 09       	ld.w	r9,r8[0x0]
80007af0:	58 09       	cp.w	r9,0
80007af2:	c0 41       	brne	80007afa <_sbrk+0x12>
80007af4:	e0 69 5b 70 	mov	r9,23408
80007af8:	91 09       	st.w	r8[0x0],r9
80007afa:	e0 69 0d 90 	mov	r9,3472
80007afe:	e0 7a 70 00 	mov	r10,94208
80007b02:	72 08       	ld.w	r8,r9[0x0]
80007b04:	f0 0c 00 0c 	add	r12,r8,r12
80007b08:	14 3c       	cp.w	r12,r10
80007b0a:	e0 8b 00 04 	brhi	80007b12 <_sbrk+0x2a>
80007b0e:	93 0c       	st.w	r9[0x0],r12
80007b10:	c0 68       	rjmp	80007b1c <_sbrk+0x34>
80007b12:	e0 a0 18 15 	rcall	8000ab3c <__errno>
80007b16:	30 c8       	mov	r8,12
80007b18:	99 08       	st.w	r12[0x0],r8
80007b1a:	3f f8       	mov	r8,-1
80007b1c:	10 9c       	mov	r12,r8
80007b1e:	d8 02       	popm	pc

80007b20 <get_arg>:
80007b20:	d4 31       	pushm	r0-r7,lr
80007b22:	20 8d       	sub	sp,32
80007b24:	fa c4 ff bc 	sub	r4,sp,-68
80007b28:	50 4b       	stdsp	sp[0x10],r11
80007b2a:	68 2e       	ld.w	lr,r4[0x8]
80007b2c:	50 58       	stdsp	sp[0x14],r8
80007b2e:	12 96       	mov	r6,r9
80007b30:	7c 0b       	ld.w	r11,lr[0x0]
80007b32:	70 05       	ld.w	r5,r8[0x0]
80007b34:	50 6e       	stdsp	sp[0x18],lr
80007b36:	58 0b       	cp.w	r11,0
80007b38:	f4 0b 17 00 	moveq	r11,r10
80007b3c:	68 03       	ld.w	r3,r4[0x0]
80007b3e:	68 11       	ld.w	r1,r4[0x4]
80007b40:	40 49       	lddsp	r9,sp[0x10]
80007b42:	30 08       	mov	r8,0
80007b44:	c2 89       	rjmp	80007d94 <get_arg+0x274>
80007b46:	2f fb       	sub	r11,-1
80007b48:	32 5c       	mov	r12,37
80007b4a:	17 8a       	ld.ub	r10,r11[0x0]
80007b4c:	f8 0a 18 00 	cp.b	r10,r12
80007b50:	5f 1e       	srne	lr
80007b52:	f0 0a 18 00 	cp.b	r10,r8
80007b56:	5f 1c       	srne	r12
80007b58:	fd ec 00 0c 	and	r12,lr,r12
80007b5c:	f0 0c 18 00 	cp.b	r12,r8
80007b60:	cf 31       	brne	80007b46 <get_arg+0x26>
80007b62:	58 0a       	cp.w	r10,0
80007b64:	e0 80 01 25 	breq	80007dae <get_arg+0x28e>
80007b68:	30 0c       	mov	r12,0
80007b6a:	3f fa       	mov	r10,-1
80007b6c:	18 90       	mov	r0,r12
80007b6e:	50 3a       	stdsp	sp[0xc],r10
80007b70:	18 94       	mov	r4,r12
80007b72:	18 92       	mov	r2,r12
80007b74:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007b78:	16 97       	mov	r7,r11
80007b7a:	50 7c       	stdsp	sp[0x1c],r12
80007b7c:	fe cc 9d e0 	sub	r12,pc,-25120
80007b80:	0f 3a       	ld.ub	r10,r7++
80007b82:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007b86:	40 7c       	lddsp	r12,sp[0x1c]
80007b88:	1c 0c       	add	r12,lr
80007b8a:	fe ce 9e b6 	sub	lr,pc,-24906
80007b8e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007b92:	20 1e       	sub	lr,1
80007b94:	50 0e       	stdsp	sp[0x0],lr
80007b96:	fe ce 9f 2e 	sub	lr,pc,-24786
80007b9a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007b9e:	50 7c       	stdsp	sp[0x1c],r12
80007ba0:	40 0c       	lddsp	r12,sp[0x0]
80007ba2:	58 7c       	cp.w	r12,7
80007ba4:	e0 8b 00 f1 	brhi	80007d86 <get_arg+0x266>
80007ba8:	fe ce a0 e0 	sub	lr,pc,-24352
80007bac:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007bb0:	36 8b       	mov	r11,104
80007bb2:	f6 0a 18 00 	cp.b	r10,r11
80007bb6:	e0 80 00 e8 	breq	80007d86 <get_arg+0x266>
80007bba:	37 1b       	mov	r11,113
80007bbc:	f6 0a 18 00 	cp.b	r10,r11
80007bc0:	c0 70       	breq	80007bce <get_arg+0xae>
80007bc2:	34 cb       	mov	r11,76
80007bc4:	f6 0a 18 00 	cp.b	r10,r11
80007bc8:	c0 51       	brne	80007bd2 <get_arg+0xb2>
80007bca:	a3 b4       	sbr	r4,0x3
80007bcc:	cd d8       	rjmp	80007d86 <get_arg+0x266>
80007bce:	a5 b4       	sbr	r4,0x5
80007bd0:	cd b8       	rjmp	80007d86 <get_arg+0x266>
80007bd2:	08 9a       	mov	r10,r4
80007bd4:	0e 9b       	mov	r11,r7
80007bd6:	a5 aa       	sbr	r10,0x4
80007bd8:	17 3c       	ld.ub	r12,r11++
80007bda:	a5 b4       	sbr	r4,0x5
80007bdc:	36 ce       	mov	lr,108
80007bde:	fc 0c 18 00 	cp.b	r12,lr
80007be2:	e0 80 00 d3 	breq	80007d88 <get_arg+0x268>
80007be6:	14 94       	mov	r4,r10
80007be8:	cc f8       	rjmp	80007d86 <get_arg+0x266>
80007bea:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007bee:	36 7c       	mov	r12,103
80007bf0:	f8 0a 18 00 	cp.b	r10,r12
80007bf4:	e0 8b 00 27 	brhi	80007c42 <get_arg+0x122>
80007bf8:	36 5b       	mov	r11,101
80007bfa:	f6 0a 18 00 	cp.b	r10,r11
80007bfe:	c4 82       	brcc	80007c8e <get_arg+0x16e>
80007c00:	34 fb       	mov	r11,79
80007c02:	f6 0a 18 00 	cp.b	r10,r11
80007c06:	c4 80       	breq	80007c96 <get_arg+0x176>
80007c08:	e0 8b 00 0c 	brhi	80007c20 <get_arg+0x100>
80007c0c:	34 5b       	mov	r11,69
80007c0e:	f6 0a 18 00 	cp.b	r10,r11
80007c12:	c3 e0       	breq	80007c8e <get_arg+0x16e>
80007c14:	34 7b       	mov	r11,71
80007c16:	f6 0a 18 00 	cp.b	r10,r11
80007c1a:	c3 a0       	breq	80007c8e <get_arg+0x16e>
80007c1c:	34 4b       	mov	r11,68
80007c1e:	c0 88       	rjmp	80007c2e <get_arg+0x10e>
80007c20:	35 8b       	mov	r11,88
80007c22:	f6 0a 18 00 	cp.b	r10,r11
80007c26:	c2 c0       	breq	80007c7e <get_arg+0x15e>
80007c28:	e0 8b 00 07 	brhi	80007c36 <get_arg+0x116>
80007c2c:	35 5b       	mov	r11,85
80007c2e:	f6 0a 18 00 	cp.b	r10,r11
80007c32:	c3 51       	brne	80007c9c <get_arg+0x17c>
80007c34:	c3 18       	rjmp	80007c96 <get_arg+0x176>
80007c36:	36 3b       	mov	r11,99
80007c38:	f6 0a 18 00 	cp.b	r10,r11
80007c3c:	c2 f0       	breq	80007c9a <get_arg+0x17a>
80007c3e:	36 4b       	mov	r11,100
80007c40:	c0 e8       	rjmp	80007c5c <get_arg+0x13c>
80007c42:	37 0b       	mov	r11,112
80007c44:	f6 0a 18 00 	cp.b	r10,r11
80007c48:	c2 50       	breq	80007c92 <get_arg+0x172>
80007c4a:	e0 8b 00 0d 	brhi	80007c64 <get_arg+0x144>
80007c4e:	36 eb       	mov	r11,110
80007c50:	f6 0a 18 00 	cp.b	r10,r11
80007c54:	c1 f0       	breq	80007c92 <get_arg+0x172>
80007c56:	e0 8b 00 14 	brhi	80007c7e <get_arg+0x15e>
80007c5a:	36 9b       	mov	r11,105
80007c5c:	f6 0a 18 00 	cp.b	r10,r11
80007c60:	c1 e1       	brne	80007c9c <get_arg+0x17c>
80007c62:	c0 e8       	rjmp	80007c7e <get_arg+0x15e>
80007c64:	37 5b       	mov	r11,117
80007c66:	f6 0a 18 00 	cp.b	r10,r11
80007c6a:	c0 a0       	breq	80007c7e <get_arg+0x15e>
80007c6c:	37 8b       	mov	r11,120
80007c6e:	f6 0a 18 00 	cp.b	r10,r11
80007c72:	c0 60       	breq	80007c7e <get_arg+0x15e>
80007c74:	37 3b       	mov	r11,115
80007c76:	f6 0a 18 00 	cp.b	r10,r11
80007c7a:	c1 11       	brne	80007c9c <get_arg+0x17c>
80007c7c:	c0 b8       	rjmp	80007c92 <get_arg+0x172>
80007c7e:	ed b4 00 04 	bld	r4,0x4
80007c82:	c0 a0       	breq	80007c96 <get_arg+0x176>
80007c84:	ed b4 00 05 	bld	r4,0x5
80007c88:	c0 91       	brne	80007c9a <get_arg+0x17a>
80007c8a:	30 20       	mov	r0,2
80007c8c:	c0 88       	rjmp	80007c9c <get_arg+0x17c>
80007c8e:	30 40       	mov	r0,4
80007c90:	c0 68       	rjmp	80007c9c <get_arg+0x17c>
80007c92:	30 30       	mov	r0,3
80007c94:	c0 48       	rjmp	80007c9c <get_arg+0x17c>
80007c96:	30 10       	mov	r0,1
80007c98:	c0 28       	rjmp	80007c9c <get_arg+0x17c>
80007c9a:	30 00       	mov	r0,0
80007c9c:	40 3b       	lddsp	r11,sp[0xc]
80007c9e:	5b fb       	cp.w	r11,-1
80007ca0:	c0 40       	breq	80007ca8 <get_arg+0x188>
80007ca2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007ca6:	c7 08       	rjmp	80007d86 <get_arg+0x266>
80007ca8:	58 60       	cp.w	r0,6
80007caa:	e0 8b 00 6e 	brhi	80007d86 <get_arg+0x266>
80007cae:	6c 0a       	ld.w	r10,r6[0x0]
80007cb0:	ea cc ff ff 	sub	r12,r5,-1
80007cb4:	fe ce a1 cc 	sub	lr,pc,-24116
80007cb8:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007cbc:	f4 cb ff f8 	sub	r11,r10,-8
80007cc0:	8d 0b       	st.w	r6[0x0],r11
80007cc2:	f4 ea 00 00 	ld.d	r10,r10[0]
80007cc6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007cca:	c0 f8       	rjmp	80007ce8 <get_arg+0x1c8>
80007ccc:	f4 cb ff fc 	sub	r11,r10,-4
80007cd0:	8d 0b       	st.w	r6[0x0],r11
80007cd2:	74 0a       	ld.w	r10,r10[0x0]
80007cd4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007cd8:	c0 88       	rjmp	80007ce8 <get_arg+0x1c8>
80007cda:	f4 cb ff f8 	sub	r11,r10,-8
80007cde:	8d 0b       	st.w	r6[0x0],r11
80007ce0:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ce4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007ce8:	0e 9b       	mov	r11,r7
80007cea:	18 95       	mov	r5,r12
80007cec:	c4 e8       	rjmp	80007d88 <get_arg+0x268>
80007cee:	62 0a       	ld.w	r10,r1[0x0]
80007cf0:	5b fa       	cp.w	r10,-1
80007cf2:	c0 b1       	brne	80007d08 <get_arg+0x1e8>
80007cf4:	50 19       	stdsp	sp[0x4],r9
80007cf6:	50 28       	stdsp	sp[0x8],r8
80007cf8:	e0 6a 00 80 	mov	r10,128
80007cfc:	30 0b       	mov	r11,0
80007cfe:	02 9c       	mov	r12,r1
80007d00:	fe b0 fd 00 	rcall	80007700 <memset>
80007d04:	40 28       	lddsp	r8,sp[0x8]
80007d06:	40 19       	lddsp	r9,sp[0x4]
80007d08:	e4 cc 00 01 	sub	r12,r2,1
80007d0c:	0e 9b       	mov	r11,r7
80007d0e:	50 3c       	stdsp	sp[0xc],r12
80007d10:	f2 0c 0c 49 	max	r9,r9,r12
80007d14:	c3 a8       	rjmp	80007d88 <get_arg+0x268>
80007d16:	62 0a       	ld.w	r10,r1[0x0]
80007d18:	5b fa       	cp.w	r10,-1
80007d1a:	c0 b1       	brne	80007d30 <get_arg+0x210>
80007d1c:	50 19       	stdsp	sp[0x4],r9
80007d1e:	50 28       	stdsp	sp[0x8],r8
80007d20:	e0 6a 00 80 	mov	r10,128
80007d24:	30 0b       	mov	r11,0
80007d26:	02 9c       	mov	r12,r1
80007d28:	fe b0 fc ec 	rcall	80007700 <memset>
80007d2c:	40 28       	lddsp	r8,sp[0x8]
80007d2e:	40 19       	lddsp	r9,sp[0x4]
80007d30:	20 12       	sub	r2,1
80007d32:	30 0a       	mov	r10,0
80007d34:	0e 9b       	mov	r11,r7
80007d36:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007d3a:	f2 02 0c 49 	max	r9,r9,r2
80007d3e:	c2 58       	rjmp	80007d88 <get_arg+0x268>
80007d40:	16 97       	mov	r7,r11
80007d42:	6c 0a       	ld.w	r10,r6[0x0]
80007d44:	f4 cb ff fc 	sub	r11,r10,-4
80007d48:	8d 0b       	st.w	r6[0x0],r11
80007d4a:	74 0a       	ld.w	r10,r10[0x0]
80007d4c:	0e 9b       	mov	r11,r7
80007d4e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d52:	2f f5       	sub	r5,-1
80007d54:	c1 a8       	rjmp	80007d88 <get_arg+0x268>
80007d56:	f4 c2 00 30 	sub	r2,r10,48
80007d5a:	c0 68       	rjmp	80007d66 <get_arg+0x246>
80007d5c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007d60:	2f f7       	sub	r7,-1
80007d62:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007d66:	0f 8a       	ld.ub	r10,r7[0x0]
80007d68:	58 0a       	cp.w	r10,0
80007d6a:	c0 e0       	breq	80007d86 <get_arg+0x266>
80007d6c:	23 0a       	sub	r10,48
80007d6e:	58 9a       	cp.w	r10,9
80007d70:	fe 98 ff f6 	brls	80007d5c <get_arg+0x23c>
80007d74:	c0 98       	rjmp	80007d86 <get_arg+0x266>
80007d76:	2f f7       	sub	r7,-1
80007d78:	0f 8a       	ld.ub	r10,r7[0x0]
80007d7a:	58 0a       	cp.w	r10,0
80007d7c:	c0 50       	breq	80007d86 <get_arg+0x266>
80007d7e:	23 0a       	sub	r10,48
80007d80:	58 9a       	cp.w	r10,9
80007d82:	fe 98 ff fa 	brls	80007d76 <get_arg+0x256>
80007d86:	0e 9b       	mov	r11,r7
80007d88:	40 7c       	lddsp	r12,sp[0x1c]
80007d8a:	30 ba       	mov	r10,11
80007d8c:	f4 0c 18 00 	cp.b	r12,r10
80007d90:	fe 91 fe f2 	brne	80007b74 <get_arg+0x54>
80007d94:	40 42       	lddsp	r2,sp[0x10]
80007d96:	17 8c       	ld.ub	r12,r11[0x0]
80007d98:	0a 32       	cp.w	r2,r5
80007d9a:	5f 4a       	srge	r10
80007d9c:	f0 0c 18 00 	cp.b	r12,r8
80007da0:	5f 1c       	srne	r12
80007da2:	f9 ea 00 0a 	and	r10,r12,r10
80007da6:	f0 0a 18 00 	cp.b	r10,r8
80007daa:	fe 91 fe cf 	brne	80007b48 <get_arg+0x28>
80007dae:	30 08       	mov	r8,0
80007db0:	40 4e       	lddsp	lr,sp[0x10]
80007db2:	17 8a       	ld.ub	r10,r11[0x0]
80007db4:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007db8:	f0 0a 18 00 	cp.b	r10,r8
80007dbc:	fc 09 17 10 	movne	r9,lr
80007dc0:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007dc4:	06 9e       	mov	lr,r3
80007dc6:	c2 a8       	rjmp	80007e1a <get_arg+0x2fa>
80007dc8:	62 0a       	ld.w	r10,r1[0x0]
80007dca:	58 3a       	cp.w	r10,3
80007dcc:	c1 e0       	breq	80007e08 <get_arg+0x2e8>
80007dce:	e0 89 00 07 	brgt	80007ddc <get_arg+0x2bc>
80007dd2:	58 1a       	cp.w	r10,1
80007dd4:	c1 a0       	breq	80007e08 <get_arg+0x2e8>
80007dd6:	58 2a       	cp.w	r10,2
80007dd8:	c1 81       	brne	80007e08 <get_arg+0x2e8>
80007dda:	c0 58       	rjmp	80007de4 <get_arg+0x2c4>
80007ddc:	58 5a       	cp.w	r10,5
80007dde:	c0 c0       	breq	80007df6 <get_arg+0x2d6>
80007de0:	c0 b5       	brlt	80007df6 <get_arg+0x2d6>
80007de2:	c1 38       	rjmp	80007e08 <get_arg+0x2e8>
80007de4:	6c 0a       	ld.w	r10,r6[0x0]
80007de6:	f4 cc ff f8 	sub	r12,r10,-8
80007dea:	8d 0c       	st.w	r6[0x0],r12
80007dec:	f4 e2 00 00 	ld.d	r2,r10[0]
80007df0:	f0 e3 00 00 	st.d	r8[0],r2
80007df4:	c1 08       	rjmp	80007e14 <get_arg+0x2f4>
80007df6:	6c 0a       	ld.w	r10,r6[0x0]
80007df8:	f4 cc ff f8 	sub	r12,r10,-8
80007dfc:	8d 0c       	st.w	r6[0x0],r12
80007dfe:	f4 e2 00 00 	ld.d	r2,r10[0]
80007e02:	f0 e3 00 00 	st.d	r8[0],r2
80007e06:	c0 78       	rjmp	80007e14 <get_arg+0x2f4>
80007e08:	6c 0a       	ld.w	r10,r6[0x0]
80007e0a:	f4 cc ff fc 	sub	r12,r10,-4
80007e0e:	8d 0c       	st.w	r6[0x0],r12
80007e10:	74 0a       	ld.w	r10,r10[0x0]
80007e12:	91 0a       	st.w	r8[0x0],r10
80007e14:	2f f5       	sub	r5,-1
80007e16:	2f 88       	sub	r8,-8
80007e18:	2f c1       	sub	r1,-4
80007e1a:	12 35       	cp.w	r5,r9
80007e1c:	fe 9a ff d6 	brle	80007dc8 <get_arg+0x2a8>
80007e20:	1c 93       	mov	r3,lr
80007e22:	40 52       	lddsp	r2,sp[0x14]
80007e24:	40 6e       	lddsp	lr,sp[0x18]
80007e26:	85 05       	st.w	r2[0x0],r5
80007e28:	9d 0b       	st.w	lr[0x0],r11
80007e2a:	40 4b       	lddsp	r11,sp[0x10]
80007e2c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007e30:	2f 8d       	sub	sp,-32
80007e32:	d8 32       	popm	r0-r7,pc

80007e34 <__sprint_r>:
80007e34:	d4 21       	pushm	r4-r7,lr
80007e36:	14 97       	mov	r7,r10
80007e38:	74 28       	ld.w	r8,r10[0x8]
80007e3a:	58 08       	cp.w	r8,0
80007e3c:	c0 41       	brne	80007e44 <__sprint_r+0x10>
80007e3e:	95 18       	st.w	r10[0x4],r8
80007e40:	10 9c       	mov	r12,r8
80007e42:	d8 22       	popm	r4-r7,pc
80007e44:	e0 a0 18 ba 	rcall	8000afb8 <__sfvwrite_r>
80007e48:	30 08       	mov	r8,0
80007e4a:	8f 18       	st.w	r7[0x4],r8
80007e4c:	8f 28       	st.w	r7[0x8],r8
80007e4e:	d8 22       	popm	r4-r7,pc

80007e50 <_vfprintf_r>:
80007e50:	d4 31       	pushm	r0-r7,lr
80007e52:	fa cd 06 bc 	sub	sp,sp,1724
80007e56:	51 09       	stdsp	sp[0x40],r9
80007e58:	16 91       	mov	r1,r11
80007e5a:	14 97       	mov	r7,r10
80007e5c:	18 95       	mov	r5,r12
80007e5e:	e0 a0 1a 1d 	rcall	8000b298 <_localeconv_r>
80007e62:	78 0c       	ld.w	r12,r12[0x0]
80007e64:	50 cc       	stdsp	sp[0x30],r12
80007e66:	58 05       	cp.w	r5,0
80007e68:	c0 70       	breq	80007e76 <_vfprintf_r+0x26>
80007e6a:	6a 68       	ld.w	r8,r5[0x18]
80007e6c:	58 08       	cp.w	r8,0
80007e6e:	c0 41       	brne	80007e76 <_vfprintf_r+0x26>
80007e70:	0a 9c       	mov	r12,r5
80007e72:	e0 a0 17 43 	rcall	8000acf8 <__sinit>
80007e76:	fe c8 9f ca 	sub	r8,pc,-24630
80007e7a:	10 31       	cp.w	r1,r8
80007e7c:	c0 31       	brne	80007e82 <_vfprintf_r+0x32>
80007e7e:	6a 01       	ld.w	r1,r5[0x0]
80007e80:	c0 c8       	rjmp	80007e98 <_vfprintf_r+0x48>
80007e82:	fe c8 9f b6 	sub	r8,pc,-24650
80007e86:	10 31       	cp.w	r1,r8
80007e88:	c0 31       	brne	80007e8e <_vfprintf_r+0x3e>
80007e8a:	6a 11       	ld.w	r1,r5[0x4]
80007e8c:	c0 68       	rjmp	80007e98 <_vfprintf_r+0x48>
80007e8e:	fe c8 9f a2 	sub	r8,pc,-24670
80007e92:	10 31       	cp.w	r1,r8
80007e94:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007e98:	82 68       	ld.sh	r8,r1[0xc]
80007e9a:	ed b8 00 03 	bld	r8,0x3
80007e9e:	c0 41       	brne	80007ea6 <_vfprintf_r+0x56>
80007ea0:	62 48       	ld.w	r8,r1[0x10]
80007ea2:	58 08       	cp.w	r8,0
80007ea4:	c0 71       	brne	80007eb2 <_vfprintf_r+0x62>
80007ea6:	02 9b       	mov	r11,r1
80007ea8:	0a 9c       	mov	r12,r5
80007eaa:	e0 a0 0f 5d 	rcall	80009d64 <__swsetup_r>
80007eae:	e0 81 0f 54 	brne	80009d56 <_vfprintf_r+0x1f06>
80007eb2:	82 68       	ld.sh	r8,r1[0xc]
80007eb4:	10 99       	mov	r9,r8
80007eb6:	e2 19 00 1a 	andl	r9,0x1a,COH
80007eba:	58 a9       	cp.w	r9,10
80007ebc:	c3 c1       	brne	80007f34 <_vfprintf_r+0xe4>
80007ebe:	82 79       	ld.sh	r9,r1[0xe]
80007ec0:	30 0a       	mov	r10,0
80007ec2:	f4 09 19 00 	cp.h	r9,r10
80007ec6:	c3 75       	brlt	80007f34 <_vfprintf_r+0xe4>
80007ec8:	a1 d8       	cbr	r8,0x1
80007eca:	fb 58 05 d0 	st.h	sp[1488],r8
80007ece:	62 88       	ld.w	r8,r1[0x20]
80007ed0:	fb 48 05 e4 	st.w	sp[1508],r8
80007ed4:	62 a8       	ld.w	r8,r1[0x28]
80007ed6:	fb 48 05 ec 	st.w	sp[1516],r8
80007eda:	fa c8 ff bc 	sub	r8,sp,-68
80007ede:	fb 48 05 d4 	st.w	sp[1492],r8
80007ee2:	fb 48 05 c4 	st.w	sp[1476],r8
80007ee6:	e0 68 04 00 	mov	r8,1024
80007eea:	fb 48 05 d8 	st.w	sp[1496],r8
80007eee:	fb 48 05 cc 	st.w	sp[1484],r8
80007ef2:	30 08       	mov	r8,0
80007ef4:	fb 59 05 d2 	st.h	sp[1490],r9
80007ef8:	0e 9a       	mov	r10,r7
80007efa:	41 09       	lddsp	r9,sp[0x40]
80007efc:	fa c7 fa 3c 	sub	r7,sp,-1476
80007f00:	fb 48 05 dc 	st.w	sp[1500],r8
80007f04:	0a 9c       	mov	r12,r5
80007f06:	0e 9b       	mov	r11,r7
80007f08:	ca 4f       	rcall	80007e50 <_vfprintf_r>
80007f0a:	50 bc       	stdsp	sp[0x2c],r12
80007f0c:	c0 95       	brlt	80007f1e <_vfprintf_r+0xce>
80007f0e:	0e 9b       	mov	r11,r7
80007f10:	0a 9c       	mov	r12,r5
80007f12:	e0 a0 16 1b 	rcall	8000ab48 <_fflush_r>
80007f16:	40 be       	lddsp	lr,sp[0x2c]
80007f18:	f9 be 01 ff 	movne	lr,-1
80007f1c:	50 be       	stdsp	sp[0x2c],lr
80007f1e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007f22:	ed b8 00 06 	bld	r8,0x6
80007f26:	e0 81 0f 1a 	brne	80009d5a <_vfprintf_r+0x1f0a>
80007f2a:	82 68       	ld.sh	r8,r1[0xc]
80007f2c:	a7 a8       	sbr	r8,0x6
80007f2e:	a2 68       	st.h	r1[0xc],r8
80007f30:	e0 8f 0f 15 	bral	80009d5a <_vfprintf_r+0x1f0a>
80007f34:	30 08       	mov	r8,0
80007f36:	fb 48 06 b4 	st.w	sp[1716],r8
80007f3a:	fb 48 06 90 	st.w	sp[1680],r8
80007f3e:	fb 48 06 8c 	st.w	sp[1676],r8
80007f42:	fb 48 06 b0 	st.w	sp[1712],r8
80007f46:	30 08       	mov	r8,0
80007f48:	30 09       	mov	r9,0
80007f4a:	50 a7       	stdsp	sp[0x28],r7
80007f4c:	50 78       	stdsp	sp[0x1c],r8
80007f4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f52:	3f f8       	mov	r8,-1
80007f54:	50 59       	stdsp	sp[0x14],r9
80007f56:	fb 43 06 88 	st.w	sp[1672],r3
80007f5a:	fb 48 05 44 	st.w	sp[1348],r8
80007f5e:	12 9c       	mov	r12,r9
80007f60:	50 69       	stdsp	sp[0x18],r9
80007f62:	50 d9       	stdsp	sp[0x34],r9
80007f64:	50 e9       	stdsp	sp[0x38],r9
80007f66:	50 b9       	stdsp	sp[0x2c],r9
80007f68:	12 97       	mov	r7,r9
80007f6a:	0a 94       	mov	r4,r5
80007f6c:	40 a2       	lddsp	r2,sp[0x28]
80007f6e:	32 5a       	mov	r10,37
80007f70:	30 08       	mov	r8,0
80007f72:	c0 28       	rjmp	80007f76 <_vfprintf_r+0x126>
80007f74:	2f f2       	sub	r2,-1
80007f76:	05 89       	ld.ub	r9,r2[0x0]
80007f78:	f0 09 18 00 	cp.b	r9,r8
80007f7c:	5f 1b       	srne	r11
80007f7e:	f4 09 18 00 	cp.b	r9,r10
80007f82:	5f 19       	srne	r9
80007f84:	f3 eb 00 0b 	and	r11,r9,r11
80007f88:	f0 0b 18 00 	cp.b	r11,r8
80007f8c:	cf 41       	brne	80007f74 <_vfprintf_r+0x124>
80007f8e:	40 ab       	lddsp	r11,sp[0x28]
80007f90:	e4 0b 01 06 	sub	r6,r2,r11
80007f94:	c1 e0       	breq	80007fd0 <_vfprintf_r+0x180>
80007f96:	fa f8 06 90 	ld.w	r8,sp[1680]
80007f9a:	0c 08       	add	r8,r6
80007f9c:	87 0b       	st.w	r3[0x0],r11
80007f9e:	fb 48 06 90 	st.w	sp[1680],r8
80007fa2:	87 16       	st.w	r3[0x4],r6
80007fa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007fa8:	2f f8       	sub	r8,-1
80007faa:	fb 48 06 8c 	st.w	sp[1676],r8
80007fae:	58 78       	cp.w	r8,7
80007fb0:	e0 89 00 04 	brgt	80007fb8 <_vfprintf_r+0x168>
80007fb4:	2f 83       	sub	r3,-8
80007fb6:	c0 a8       	rjmp	80007fca <_vfprintf_r+0x17a>
80007fb8:	fa ca f9 78 	sub	r10,sp,-1672
80007fbc:	02 9b       	mov	r11,r1
80007fbe:	08 9c       	mov	r12,r4
80007fc0:	c3 af       	rcall	80007e34 <__sprint_r>
80007fc2:	e0 81 0e c6 	brne	80009d4e <_vfprintf_r+0x1efe>
80007fc6:	fa c3 f9 e0 	sub	r3,sp,-1568
80007fca:	40 ba       	lddsp	r10,sp[0x2c]
80007fcc:	0c 0a       	add	r10,r6
80007fce:	50 ba       	stdsp	sp[0x2c],r10
80007fd0:	05 89       	ld.ub	r9,r2[0x0]
80007fd2:	30 08       	mov	r8,0
80007fd4:	f0 09 18 00 	cp.b	r9,r8
80007fd8:	e0 80 0e aa 	breq	80009d2c <_vfprintf_r+0x1edc>
80007fdc:	30 09       	mov	r9,0
80007fde:	fb 68 06 bb 	st.b	sp[1723],r8
80007fe2:	0e 96       	mov	r6,r7
80007fe4:	e4 c8 ff ff 	sub	r8,r2,-1
80007fe8:	3f fe       	mov	lr,-1
80007fea:	50 93       	stdsp	sp[0x24],r3
80007fec:	50 41       	stdsp	sp[0x10],r1
80007fee:	0e 93       	mov	r3,r7
80007ff0:	04 91       	mov	r1,r2
80007ff2:	50 89       	stdsp	sp[0x20],r9
80007ff4:	50 a8       	stdsp	sp[0x28],r8
80007ff6:	50 2e       	stdsp	sp[0x8],lr
80007ff8:	50 39       	stdsp	sp[0xc],r9
80007ffa:	12 95       	mov	r5,r9
80007ffc:	12 90       	mov	r0,r9
80007ffe:	10 97       	mov	r7,r8
80008000:	08 92       	mov	r2,r4
80008002:	c0 78       	rjmp	80008010 <_vfprintf_r+0x1c0>
80008004:	3f fc       	mov	r12,-1
80008006:	08 97       	mov	r7,r4
80008008:	50 2c       	stdsp	sp[0x8],r12
8000800a:	c0 38       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000800c:	30 0b       	mov	r11,0
8000800e:	50 3b       	stdsp	sp[0xc],r11
80008010:	0f 38       	ld.ub	r8,r7++
80008012:	c0 28       	rjmp	80008016 <_vfprintf_r+0x1c6>
80008014:	12 90       	mov	r0,r9
80008016:	f0 c9 00 20 	sub	r9,r8,32
8000801a:	e0 49 00 58 	cp.w	r9,88
8000801e:	e0 8b 0a 30 	brhi	8000947e <_vfprintf_r+0x162e>
80008022:	fe ca a5 1e 	sub	r10,pc,-23266
80008026:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000802a:	50 a7       	stdsp	sp[0x28],r7
8000802c:	50 80       	stdsp	sp[0x20],r0
8000802e:	0c 97       	mov	r7,r6
80008030:	04 94       	mov	r4,r2
80008032:	06 96       	mov	r6,r3
80008034:	02 92       	mov	r2,r1
80008036:	fe c9 a2 f6 	sub	r9,pc,-23818
8000803a:	40 93       	lddsp	r3,sp[0x24]
8000803c:	10 90       	mov	r0,r8
8000803e:	40 41       	lddsp	r1,sp[0x10]
80008040:	50 d9       	stdsp	sp[0x34],r9
80008042:	e0 8f 08 8e 	bral	8000915e <_vfprintf_r+0x130e>
80008046:	30 08       	mov	r8,0
80008048:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000804c:	f0 09 18 00 	cp.b	r9,r8
80008050:	ce 01       	brne	80008010 <_vfprintf_r+0x1c0>
80008052:	32 08       	mov	r8,32
80008054:	c6 e8       	rjmp	80008130 <_vfprintf_r+0x2e0>
80008056:	a1 a5       	sbr	r5,0x0
80008058:	cd cb       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000805a:	0f 89       	ld.ub	r9,r7[0x0]
8000805c:	f2 c8 00 30 	sub	r8,r9,48
80008060:	58 98       	cp.w	r8,9
80008062:	e0 8b 00 1d 	brhi	8000809c <_vfprintf_r+0x24c>
80008066:	ee c8 ff ff 	sub	r8,r7,-1
8000806a:	30 0b       	mov	r11,0
8000806c:	23 09       	sub	r9,48
8000806e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008072:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008076:	11 39       	ld.ub	r9,r8++
80008078:	f2 ca 00 30 	sub	r10,r9,48
8000807c:	58 9a       	cp.w	r10,9
8000807e:	fe 98 ff f7 	brls	8000806c <_vfprintf_r+0x21c>
80008082:	e0 49 00 24 	cp.w	r9,36
80008086:	cc 31       	brne	8000800c <_vfprintf_r+0x1bc>
80008088:	e0 4b 00 20 	cp.w	r11,32
8000808c:	e0 89 0e 60 	brgt	80009d4c <_vfprintf_r+0x1efc>
80008090:	20 1b       	sub	r11,1
80008092:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008096:	12 3b       	cp.w	r11,r9
80008098:	c0 95       	brlt	800080aa <_vfprintf_r+0x25a>
8000809a:	c1 08       	rjmp	800080ba <_vfprintf_r+0x26a>
8000809c:	fa f9 06 b4 	ld.w	r9,sp[1716]
800080a0:	ec ca ff ff 	sub	r10,r6,-1
800080a4:	12 36       	cp.w	r6,r9
800080a6:	c1 f5       	brlt	800080e4 <_vfprintf_r+0x294>
800080a8:	c2 68       	rjmp	800080f4 <_vfprintf_r+0x2a4>
800080aa:	fa ce f9 44 	sub	lr,sp,-1724
800080ae:	10 97       	mov	r7,r8
800080b0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800080b4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800080b8:	c3 58       	rjmp	80008122 <_vfprintf_r+0x2d2>
800080ba:	10 97       	mov	r7,r8
800080bc:	fa c8 f9 50 	sub	r8,sp,-1712
800080c0:	1a d8       	st.w	--sp,r8
800080c2:	fa c8 fa b8 	sub	r8,sp,-1352
800080c6:	1a d8       	st.w	--sp,r8
800080c8:	fa c8 fb b4 	sub	r8,sp,-1100
800080cc:	02 9a       	mov	r10,r1
800080ce:	1a d8       	st.w	--sp,r8
800080d0:	04 9c       	mov	r12,r2
800080d2:	fa c8 f9 40 	sub	r8,sp,-1728
800080d6:	fa c9 ff b4 	sub	r9,sp,-76
800080da:	fe b0 fd 23 	rcall	80007b20 <get_arg>
800080de:	2f dd       	sub	sp,-12
800080e0:	78 00       	ld.w	r0,r12[0x0]
800080e2:	c2 08       	rjmp	80008122 <_vfprintf_r+0x2d2>
800080e4:	fa cc f9 44 	sub	r12,sp,-1724
800080e8:	14 96       	mov	r6,r10
800080ea:	f8 03 00 38 	add	r8,r12,r3<<0x3
800080ee:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800080f2:	c1 88       	rjmp	80008122 <_vfprintf_r+0x2d2>
800080f4:	41 08       	lddsp	r8,sp[0x40]
800080f6:	59 f9       	cp.w	r9,31
800080f8:	e0 89 00 11 	brgt	8000811a <_vfprintf_r+0x2ca>
800080fc:	f0 cb ff fc 	sub	r11,r8,-4
80008100:	51 0b       	stdsp	sp[0x40],r11
80008102:	70 00       	ld.w	r0,r8[0x0]
80008104:	fa cb f9 44 	sub	r11,sp,-1724
80008108:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000810c:	f1 40 fd 88 	st.w	r8[-632],r0
80008110:	2f f9       	sub	r9,-1
80008112:	14 96       	mov	r6,r10
80008114:	fb 49 06 b4 	st.w	sp[1716],r9
80008118:	c0 58       	rjmp	80008122 <_vfprintf_r+0x2d2>
8000811a:	70 00       	ld.w	r0,r8[0x0]
8000811c:	14 96       	mov	r6,r10
8000811e:	2f c8       	sub	r8,-4
80008120:	51 08       	stdsp	sp[0x40],r8
80008122:	58 00       	cp.w	r0,0
80008124:	fe 94 ff 76 	brge	80008010 <_vfprintf_r+0x1c0>
80008128:	5c 30       	neg	r0
8000812a:	a3 a5       	sbr	r5,0x2
8000812c:	c7 2b       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000812e:	32 b8       	mov	r8,43
80008130:	fb 68 06 bb 	st.b	sp[1723],r8
80008134:	c6 eb       	rjmp	80008010 <_vfprintf_r+0x1c0>
80008136:	0f 38       	ld.ub	r8,r7++
80008138:	e0 48 00 2a 	cp.w	r8,42
8000813c:	c0 30       	breq	80008142 <_vfprintf_r+0x2f2>
8000813e:	30 09       	mov	r9,0
80008140:	c7 98       	rjmp	80008232 <_vfprintf_r+0x3e2>
80008142:	0f 88       	ld.ub	r8,r7[0x0]
80008144:	f0 c9 00 30 	sub	r9,r8,48
80008148:	58 99       	cp.w	r9,9
8000814a:	e0 8b 00 1f 	brhi	80008188 <_vfprintf_r+0x338>
8000814e:	ee c4 ff ff 	sub	r4,r7,-1
80008152:	30 0b       	mov	r11,0
80008154:	23 08       	sub	r8,48
80008156:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000815a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000815e:	09 38       	ld.ub	r8,r4++
80008160:	f0 c9 00 30 	sub	r9,r8,48
80008164:	58 99       	cp.w	r9,9
80008166:	fe 98 ff f7 	brls	80008154 <_vfprintf_r+0x304>
8000816a:	e0 48 00 24 	cp.w	r8,36
8000816e:	fe 91 ff 4f 	brne	8000800c <_vfprintf_r+0x1bc>
80008172:	e0 4b 00 20 	cp.w	r11,32
80008176:	e0 89 0d eb 	brgt	80009d4c <_vfprintf_r+0x1efc>
8000817a:	20 1b       	sub	r11,1
8000817c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008180:	10 3b       	cp.w	r11,r8
80008182:	c0 a5       	brlt	80008196 <_vfprintf_r+0x346>
80008184:	c1 18       	rjmp	800081a6 <_vfprintf_r+0x356>
80008186:	d7 03       	nop
80008188:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000818c:	ec c9 ff ff 	sub	r9,r6,-1
80008190:	14 36       	cp.w	r6,r10
80008192:	c1 f5       	brlt	800081d0 <_vfprintf_r+0x380>
80008194:	c2 88       	rjmp	800081e4 <_vfprintf_r+0x394>
80008196:	fa ca f9 44 	sub	r10,sp,-1724
8000819a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000819e:	f6 fb fd 88 	ld.w	r11,r11[-632]
800081a2:	50 2b       	stdsp	sp[0x8],r11
800081a4:	c3 c8       	rjmp	8000821c <_vfprintf_r+0x3cc>
800081a6:	fa c8 f9 50 	sub	r8,sp,-1712
800081aa:	1a d8       	st.w	--sp,r8
800081ac:	fa c8 fa b8 	sub	r8,sp,-1352
800081b0:	1a d8       	st.w	--sp,r8
800081b2:	fa c8 fb b4 	sub	r8,sp,-1100
800081b6:	02 9a       	mov	r10,r1
800081b8:	1a d8       	st.w	--sp,r8
800081ba:	04 9c       	mov	r12,r2
800081bc:	fa c8 f9 40 	sub	r8,sp,-1728
800081c0:	fa c9 ff b4 	sub	r9,sp,-76
800081c4:	fe b0 fc ae 	rcall	80007b20 <get_arg>
800081c8:	2f dd       	sub	sp,-12
800081ca:	78 0c       	ld.w	r12,r12[0x0]
800081cc:	50 2c       	stdsp	sp[0x8],r12
800081ce:	c2 78       	rjmp	8000821c <_vfprintf_r+0x3cc>
800081d0:	12 96       	mov	r6,r9
800081d2:	0e 94       	mov	r4,r7
800081d4:	fa c9 f9 44 	sub	r9,sp,-1724
800081d8:	f2 03 00 38 	add	r8,r9,r3<<0x3
800081dc:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800081e0:	50 28       	stdsp	sp[0x8],r8
800081e2:	c1 d8       	rjmp	8000821c <_vfprintf_r+0x3cc>
800081e4:	41 08       	lddsp	r8,sp[0x40]
800081e6:	59 fa       	cp.w	r10,31
800081e8:	e0 89 00 14 	brgt	80008210 <_vfprintf_r+0x3c0>
800081ec:	f0 cb ff fc 	sub	r11,r8,-4
800081f0:	70 08       	ld.w	r8,r8[0x0]
800081f2:	51 0b       	stdsp	sp[0x40],r11
800081f4:	50 28       	stdsp	sp[0x8],r8
800081f6:	fa c6 f9 44 	sub	r6,sp,-1724
800081fa:	40 2e       	lddsp	lr,sp[0x8]
800081fc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008200:	f1 4e fd 88 	st.w	r8[-632],lr
80008204:	2f fa       	sub	r10,-1
80008206:	0e 94       	mov	r4,r7
80008208:	fb 4a 06 b4 	st.w	sp[1716],r10
8000820c:	12 96       	mov	r6,r9
8000820e:	c0 78       	rjmp	8000821c <_vfprintf_r+0x3cc>
80008210:	70 0c       	ld.w	r12,r8[0x0]
80008212:	0e 94       	mov	r4,r7
80008214:	2f c8       	sub	r8,-4
80008216:	50 2c       	stdsp	sp[0x8],r12
80008218:	12 96       	mov	r6,r9
8000821a:	51 08       	stdsp	sp[0x40],r8
8000821c:	40 2b       	lddsp	r11,sp[0x8]
8000821e:	58 0b       	cp.w	r11,0
80008220:	fe 95 fe f2 	brlt	80008004 <_vfprintf_r+0x1b4>
80008224:	08 97       	mov	r7,r4
80008226:	cf 5a       	rjmp	80008010 <_vfprintf_r+0x1c0>
80008228:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000822c:	0f 38       	ld.ub	r8,r7++
8000822e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008232:	f0 ca 00 30 	sub	r10,r8,48
80008236:	58 9a       	cp.w	r10,9
80008238:	fe 98 ff f8 	brls	80008228 <_vfprintf_r+0x3d8>
8000823c:	3f fa       	mov	r10,-1
8000823e:	f2 0a 0c 49 	max	r9,r9,r10
80008242:	50 29       	stdsp	sp[0x8],r9
80008244:	ce 9a       	rjmp	80008016 <_vfprintf_r+0x1c6>
80008246:	a7 b5       	sbr	r5,0x7
80008248:	ce 4a       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000824a:	30 09       	mov	r9,0
8000824c:	23 08       	sub	r8,48
8000824e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008252:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008256:	0f 38       	ld.ub	r8,r7++
80008258:	f0 ca 00 30 	sub	r10,r8,48
8000825c:	58 9a       	cp.w	r10,9
8000825e:	fe 98 ff f7 	brls	8000824c <_vfprintf_r+0x3fc>
80008262:	e0 48 00 24 	cp.w	r8,36
80008266:	fe 91 fe d7 	brne	80008014 <_vfprintf_r+0x1c4>
8000826a:	e0 49 00 20 	cp.w	r9,32
8000826e:	e0 89 0d 6f 	brgt	80009d4c <_vfprintf_r+0x1efc>
80008272:	f2 c3 00 01 	sub	r3,r9,1
80008276:	30 19       	mov	r9,1
80008278:	50 39       	stdsp	sp[0xc],r9
8000827a:	cc ba       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000827c:	a3 b5       	sbr	r5,0x3
8000827e:	cc 9a       	rjmp	80008010 <_vfprintf_r+0x1c0>
80008280:	a7 a5       	sbr	r5,0x6
80008282:	cc 7a       	rjmp	80008010 <_vfprintf_r+0x1c0>
80008284:	0a 98       	mov	r8,r5
80008286:	a5 b5       	sbr	r5,0x5
80008288:	a5 a8       	sbr	r8,0x4
8000828a:	0f 89       	ld.ub	r9,r7[0x0]
8000828c:	36 ce       	mov	lr,108
8000828e:	fc 09 18 00 	cp.b	r9,lr
80008292:	f7 b7 00 ff 	subeq	r7,-1
80008296:	f0 05 17 10 	movne	r5,r8
8000829a:	cb ba       	rjmp	80008010 <_vfprintf_r+0x1c0>
8000829c:	a5 b5       	sbr	r5,0x5
8000829e:	cb 9a       	rjmp	80008010 <_vfprintf_r+0x1c0>
800082a0:	50 a7       	stdsp	sp[0x28],r7
800082a2:	50 80       	stdsp	sp[0x20],r0
800082a4:	0c 97       	mov	r7,r6
800082a6:	10 90       	mov	r0,r8
800082a8:	06 96       	mov	r6,r3
800082aa:	04 94       	mov	r4,r2
800082ac:	40 93       	lddsp	r3,sp[0x24]
800082ae:	02 92       	mov	r2,r1
800082b0:	0e 99       	mov	r9,r7
800082b2:	40 41       	lddsp	r1,sp[0x10]
800082b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082b8:	40 3c       	lddsp	r12,sp[0xc]
800082ba:	58 0c       	cp.w	r12,0
800082bc:	c1 d0       	breq	800082f6 <_vfprintf_r+0x4a6>
800082be:	10 36       	cp.w	r6,r8
800082c0:	c0 64       	brge	800082cc <_vfprintf_r+0x47c>
800082c2:	fa cb f9 44 	sub	r11,sp,-1724
800082c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082ca:	c1 d8       	rjmp	80008304 <_vfprintf_r+0x4b4>
800082cc:	fa c8 f9 50 	sub	r8,sp,-1712
800082d0:	1a d8       	st.w	--sp,r8
800082d2:	fa c8 fa b8 	sub	r8,sp,-1352
800082d6:	1a d8       	st.w	--sp,r8
800082d8:	fa c8 fb b4 	sub	r8,sp,-1100
800082dc:	1a d8       	st.w	--sp,r8
800082de:	fa c8 f9 40 	sub	r8,sp,-1728
800082e2:	fa c9 ff b4 	sub	r9,sp,-76
800082e6:	04 9a       	mov	r10,r2
800082e8:	0c 9b       	mov	r11,r6
800082ea:	08 9c       	mov	r12,r4
800082ec:	fe b0 fc 1a 	rcall	80007b20 <get_arg>
800082f0:	2f dd       	sub	sp,-12
800082f2:	19 b8       	ld.ub	r8,r12[0x3]
800082f4:	c2 28       	rjmp	80008338 <_vfprintf_r+0x4e8>
800082f6:	2f f7       	sub	r7,-1
800082f8:	10 39       	cp.w	r9,r8
800082fa:	c0 84       	brge	8000830a <_vfprintf_r+0x4ba>
800082fc:	fa ca f9 44 	sub	r10,sp,-1724
80008300:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008304:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008308:	c1 88       	rjmp	80008338 <_vfprintf_r+0x4e8>
8000830a:	41 09       	lddsp	r9,sp[0x40]
8000830c:	59 f8       	cp.w	r8,31
8000830e:	e0 89 00 12 	brgt	80008332 <_vfprintf_r+0x4e2>
80008312:	f2 ca ff fc 	sub	r10,r9,-4
80008316:	51 0a       	stdsp	sp[0x40],r10
80008318:	72 09       	ld.w	r9,r9[0x0]
8000831a:	fa c6 f9 44 	sub	r6,sp,-1724
8000831e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008322:	2f f8       	sub	r8,-1
80008324:	f5 49 fd 88 	st.w	r10[-632],r9
80008328:	fb 48 06 b4 	st.w	sp[1716],r8
8000832c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008330:	c0 48       	rjmp	80008338 <_vfprintf_r+0x4e8>
80008332:	13 b8       	ld.ub	r8,r9[0x3]
80008334:	2f c9       	sub	r9,-4
80008336:	51 09       	stdsp	sp[0x40],r9
80008338:	fb 68 06 60 	st.b	sp[1632],r8
8000833c:	30 0e       	mov	lr,0
8000833e:	30 08       	mov	r8,0
80008340:	30 12       	mov	r2,1
80008342:	fb 68 06 bb 	st.b	sp[1723],r8
80008346:	50 2e       	stdsp	sp[0x8],lr
80008348:	e0 8f 08 ad 	bral	800094a2 <_vfprintf_r+0x1652>
8000834c:	50 a7       	stdsp	sp[0x28],r7
8000834e:	50 80       	stdsp	sp[0x20],r0
80008350:	0c 97       	mov	r7,r6
80008352:	04 94       	mov	r4,r2
80008354:	06 96       	mov	r6,r3
80008356:	02 92       	mov	r2,r1
80008358:	40 93       	lddsp	r3,sp[0x24]
8000835a:	10 90       	mov	r0,r8
8000835c:	40 41       	lddsp	r1,sp[0x10]
8000835e:	a5 a5       	sbr	r5,0x4
80008360:	c0 a8       	rjmp	80008374 <_vfprintf_r+0x524>
80008362:	50 a7       	stdsp	sp[0x28],r7
80008364:	50 80       	stdsp	sp[0x20],r0
80008366:	0c 97       	mov	r7,r6
80008368:	04 94       	mov	r4,r2
8000836a:	06 96       	mov	r6,r3
8000836c:	02 92       	mov	r2,r1
8000836e:	40 93       	lddsp	r3,sp[0x24]
80008370:	10 90       	mov	r0,r8
80008372:	40 41       	lddsp	r1,sp[0x10]
80008374:	ed b5 00 05 	bld	r5,0x5
80008378:	c5 11       	brne	8000841a <_vfprintf_r+0x5ca>
8000837a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000837e:	40 3c       	lddsp	r12,sp[0xc]
80008380:	58 0c       	cp.w	r12,0
80008382:	c1 e0       	breq	800083be <_vfprintf_r+0x56e>
80008384:	10 36       	cp.w	r6,r8
80008386:	c0 64       	brge	80008392 <_vfprintf_r+0x542>
80008388:	fa cb f9 44 	sub	r11,sp,-1724
8000838c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008390:	c2 08       	rjmp	800083d0 <_vfprintf_r+0x580>
80008392:	fa c8 f9 50 	sub	r8,sp,-1712
80008396:	1a d8       	st.w	--sp,r8
80008398:	fa c8 fa b8 	sub	r8,sp,-1352
8000839c:	0c 9b       	mov	r11,r6
8000839e:	1a d8       	st.w	--sp,r8
800083a0:	fa c8 fb b4 	sub	r8,sp,-1100
800083a4:	1a d8       	st.w	--sp,r8
800083a6:	fa c9 ff b4 	sub	r9,sp,-76
800083aa:	fa c8 f9 40 	sub	r8,sp,-1728
800083ae:	04 9a       	mov	r10,r2
800083b0:	08 9c       	mov	r12,r4
800083b2:	fe b0 fb b7 	rcall	80007b20 <get_arg>
800083b6:	2f dd       	sub	sp,-12
800083b8:	78 1b       	ld.w	r11,r12[0x4]
800083ba:	78 09       	ld.w	r9,r12[0x0]
800083bc:	c2 b8       	rjmp	80008412 <_vfprintf_r+0x5c2>
800083be:	ee ca ff ff 	sub	r10,r7,-1
800083c2:	10 37       	cp.w	r7,r8
800083c4:	c0 b4       	brge	800083da <_vfprintf_r+0x58a>
800083c6:	fa c9 f9 44 	sub	r9,sp,-1724
800083ca:	14 97       	mov	r7,r10
800083cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083d0:	ec fb fd 8c 	ld.w	r11,r6[-628]
800083d4:	ec f9 fd 88 	ld.w	r9,r6[-632]
800083d8:	c1 d8       	rjmp	80008412 <_vfprintf_r+0x5c2>
800083da:	41 09       	lddsp	r9,sp[0x40]
800083dc:	59 f8       	cp.w	r8,31
800083de:	e0 89 00 14 	brgt	80008406 <_vfprintf_r+0x5b6>
800083e2:	f2 cb ff f8 	sub	r11,r9,-8
800083e6:	51 0b       	stdsp	sp[0x40],r11
800083e8:	fa c6 f9 44 	sub	r6,sp,-1724
800083ec:	72 1b       	ld.w	r11,r9[0x4]
800083ee:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800083f2:	72 09       	ld.w	r9,r9[0x0]
800083f4:	f9 4b fd 8c 	st.w	r12[-628],r11
800083f8:	f9 49 fd 88 	st.w	r12[-632],r9
800083fc:	2f f8       	sub	r8,-1
800083fe:	14 97       	mov	r7,r10
80008400:	fb 48 06 b4 	st.w	sp[1716],r8
80008404:	c0 78       	rjmp	80008412 <_vfprintf_r+0x5c2>
80008406:	f2 c8 ff f8 	sub	r8,r9,-8
8000840a:	72 1b       	ld.w	r11,r9[0x4]
8000840c:	14 97       	mov	r7,r10
8000840e:	51 08       	stdsp	sp[0x40],r8
80008410:	72 09       	ld.w	r9,r9[0x0]
80008412:	16 98       	mov	r8,r11
80008414:	fa e9 00 00 	st.d	sp[0],r8
80008418:	ca e8       	rjmp	80008574 <_vfprintf_r+0x724>
8000841a:	ed b5 00 04 	bld	r5,0x4
8000841e:	c1 71       	brne	8000844c <_vfprintf_r+0x5fc>
80008420:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008424:	40 3e       	lddsp	lr,sp[0xc]
80008426:	58 0e       	cp.w	lr,0
80008428:	c0 80       	breq	80008438 <_vfprintf_r+0x5e8>
8000842a:	10 36       	cp.w	r6,r8
8000842c:	c6 94       	brge	800084fe <_vfprintf_r+0x6ae>
8000842e:	fa cc f9 44 	sub	r12,sp,-1724
80008432:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008436:	c8 28       	rjmp	8000853a <_vfprintf_r+0x6ea>
80008438:	ee ca ff ff 	sub	r10,r7,-1
8000843c:	10 37       	cp.w	r7,r8
8000843e:	e0 84 00 81 	brge	80008540 <_vfprintf_r+0x6f0>
80008442:	fa cb f9 44 	sub	r11,sp,-1724
80008446:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000844a:	c7 78       	rjmp	80008538 <_vfprintf_r+0x6e8>
8000844c:	ed b5 00 06 	bld	r5,0x6
80008450:	c4 b1       	brne	800084e6 <_vfprintf_r+0x696>
80008452:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008456:	40 3c       	lddsp	r12,sp[0xc]
80008458:	58 0c       	cp.w	r12,0
8000845a:	c1 d0       	breq	80008494 <_vfprintf_r+0x644>
8000845c:	10 36       	cp.w	r6,r8
8000845e:	c0 64       	brge	8000846a <_vfprintf_r+0x61a>
80008460:	fa cb f9 44 	sub	r11,sp,-1724
80008464:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008468:	c1 f8       	rjmp	800084a6 <_vfprintf_r+0x656>
8000846a:	fa c8 f9 50 	sub	r8,sp,-1712
8000846e:	1a d8       	st.w	--sp,r8
80008470:	fa c8 fa b8 	sub	r8,sp,-1352
80008474:	1a d8       	st.w	--sp,r8
80008476:	fa c8 fb b4 	sub	r8,sp,-1100
8000847a:	1a d8       	st.w	--sp,r8
8000847c:	fa c8 f9 40 	sub	r8,sp,-1728
80008480:	fa c9 ff b4 	sub	r9,sp,-76
80008484:	04 9a       	mov	r10,r2
80008486:	0c 9b       	mov	r11,r6
80008488:	08 9c       	mov	r12,r4
8000848a:	fe b0 fb 4b 	rcall	80007b20 <get_arg>
8000848e:	2f dd       	sub	sp,-12
80008490:	98 18       	ld.sh	r8,r12[0x2]
80008492:	c2 68       	rjmp	800084de <_vfprintf_r+0x68e>
80008494:	ee ca ff ff 	sub	r10,r7,-1
80008498:	10 37       	cp.w	r7,r8
8000849a:	c0 94       	brge	800084ac <_vfprintf_r+0x65c>
8000849c:	fa c9 f9 44 	sub	r9,sp,-1724
800084a0:	14 97       	mov	r7,r10
800084a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084a6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800084aa:	c1 a8       	rjmp	800084de <_vfprintf_r+0x68e>
800084ac:	41 09       	lddsp	r9,sp[0x40]
800084ae:	59 f8       	cp.w	r8,31
800084b0:	e0 89 00 13 	brgt	800084d6 <_vfprintf_r+0x686>
800084b4:	f2 cb ff fc 	sub	r11,r9,-4
800084b8:	51 0b       	stdsp	sp[0x40],r11
800084ba:	72 09       	ld.w	r9,r9[0x0]
800084bc:	fa c6 f9 44 	sub	r6,sp,-1724
800084c0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084c4:	2f f8       	sub	r8,-1
800084c6:	f7 49 fd 88 	st.w	r11[-632],r9
800084ca:	fb 48 06 b4 	st.w	sp[1716],r8
800084ce:	14 97       	mov	r7,r10
800084d0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084d4:	c0 58       	rjmp	800084de <_vfprintf_r+0x68e>
800084d6:	92 18       	ld.sh	r8,r9[0x2]
800084d8:	14 97       	mov	r7,r10
800084da:	2f c9       	sub	r9,-4
800084dc:	51 09       	stdsp	sp[0x40],r9
800084de:	50 18       	stdsp	sp[0x4],r8
800084e0:	bf 58       	asr	r8,0x1f
800084e2:	50 08       	stdsp	sp[0x0],r8
800084e4:	c4 88       	rjmp	80008574 <_vfprintf_r+0x724>
800084e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084ea:	40 3c       	lddsp	r12,sp[0xc]
800084ec:	58 0c       	cp.w	r12,0
800084ee:	c1 d0       	breq	80008528 <_vfprintf_r+0x6d8>
800084f0:	10 36       	cp.w	r6,r8
800084f2:	c0 64       	brge	800084fe <_vfprintf_r+0x6ae>
800084f4:	fa cb f9 44 	sub	r11,sp,-1724
800084f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084fc:	c1 f8       	rjmp	8000853a <_vfprintf_r+0x6ea>
800084fe:	fa c8 f9 50 	sub	r8,sp,-1712
80008502:	1a d8       	st.w	--sp,r8
80008504:	fa c8 fa b8 	sub	r8,sp,-1352
80008508:	0c 9b       	mov	r11,r6
8000850a:	1a d8       	st.w	--sp,r8
8000850c:	fa c8 fb b4 	sub	r8,sp,-1100
80008510:	04 9a       	mov	r10,r2
80008512:	1a d8       	st.w	--sp,r8
80008514:	08 9c       	mov	r12,r4
80008516:	fa c8 f9 40 	sub	r8,sp,-1728
8000851a:	fa c9 ff b4 	sub	r9,sp,-76
8000851e:	fe b0 fb 01 	rcall	80007b20 <get_arg>
80008522:	2f dd       	sub	sp,-12
80008524:	78 0b       	ld.w	r11,r12[0x0]
80008526:	c2 48       	rjmp	8000856e <_vfprintf_r+0x71e>
80008528:	ee ca ff ff 	sub	r10,r7,-1
8000852c:	10 37       	cp.w	r7,r8
8000852e:	c0 94       	brge	80008540 <_vfprintf_r+0x6f0>
80008530:	fa c9 f9 44 	sub	r9,sp,-1724
80008534:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008538:	14 97       	mov	r7,r10
8000853a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000853e:	c1 88       	rjmp	8000856e <_vfprintf_r+0x71e>
80008540:	41 09       	lddsp	r9,sp[0x40]
80008542:	59 f8       	cp.w	r8,31
80008544:	e0 89 00 11 	brgt	80008566 <_vfprintf_r+0x716>
80008548:	f2 cb ff fc 	sub	r11,r9,-4
8000854c:	51 0b       	stdsp	sp[0x40],r11
8000854e:	fa c6 f9 44 	sub	r6,sp,-1724
80008552:	72 0b       	ld.w	r11,r9[0x0]
80008554:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008558:	f3 4b fd 88 	st.w	r9[-632],r11
8000855c:	2f f8       	sub	r8,-1
8000855e:	14 97       	mov	r7,r10
80008560:	fb 48 06 b4 	st.w	sp[1716],r8
80008564:	c0 58       	rjmp	8000856e <_vfprintf_r+0x71e>
80008566:	72 0b       	ld.w	r11,r9[0x0]
80008568:	14 97       	mov	r7,r10
8000856a:	2f c9       	sub	r9,-4
8000856c:	51 09       	stdsp	sp[0x40],r9
8000856e:	50 1b       	stdsp	sp[0x4],r11
80008570:	bf 5b       	asr	r11,0x1f
80008572:	50 0b       	stdsp	sp[0x0],r11
80008574:	fa ea 00 00 	ld.d	r10,sp[0]
80008578:	58 0a       	cp.w	r10,0
8000857a:	5c 2b       	cpc	r11
8000857c:	c0 e4       	brge	80008598 <_vfprintf_r+0x748>
8000857e:	30 08       	mov	r8,0
80008580:	fa ea 00 00 	ld.d	r10,sp[0]
80008584:	30 09       	mov	r9,0
80008586:	f0 0a 01 0a 	sub	r10,r8,r10
8000858a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000858e:	32 d8       	mov	r8,45
80008590:	fa eb 00 00 	st.d	sp[0],r10
80008594:	fb 68 06 bb 	st.b	sp[1723],r8
80008598:	30 18       	mov	r8,1
8000859a:	e0 8f 06 fa 	bral	8000938e <_vfprintf_r+0x153e>
8000859e:	50 a7       	stdsp	sp[0x28],r7
800085a0:	50 80       	stdsp	sp[0x20],r0
800085a2:	0c 97       	mov	r7,r6
800085a4:	04 94       	mov	r4,r2
800085a6:	06 96       	mov	r6,r3
800085a8:	02 92       	mov	r2,r1
800085aa:	40 93       	lddsp	r3,sp[0x24]
800085ac:	10 90       	mov	r0,r8
800085ae:	40 41       	lddsp	r1,sp[0x10]
800085b0:	0e 99       	mov	r9,r7
800085b2:	ed b5 00 03 	bld	r5,0x3
800085b6:	c4 11       	brne	80008638 <_vfprintf_r+0x7e8>
800085b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085bc:	40 3a       	lddsp	r10,sp[0xc]
800085be:	58 0a       	cp.w	r10,0
800085c0:	c1 90       	breq	800085f2 <_vfprintf_r+0x7a2>
800085c2:	10 36       	cp.w	r6,r8
800085c4:	c6 45       	brlt	8000868c <_vfprintf_r+0x83c>
800085c6:	fa c8 f9 50 	sub	r8,sp,-1712
800085ca:	1a d8       	st.w	--sp,r8
800085cc:	fa c8 fa b8 	sub	r8,sp,-1352
800085d0:	1a d8       	st.w	--sp,r8
800085d2:	fa c8 fb b4 	sub	r8,sp,-1100
800085d6:	0c 9b       	mov	r11,r6
800085d8:	1a d8       	st.w	--sp,r8
800085da:	04 9a       	mov	r10,r2
800085dc:	fa c8 f9 40 	sub	r8,sp,-1728
800085e0:	fa c9 ff b4 	sub	r9,sp,-76
800085e4:	08 9c       	mov	r12,r4
800085e6:	fe b0 fa 9d 	rcall	80007b20 <get_arg>
800085ea:	2f dd       	sub	sp,-12
800085ec:	78 16       	ld.w	r6,r12[0x4]
800085ee:	50 76       	stdsp	sp[0x1c],r6
800085f0:	c4 88       	rjmp	80008680 <_vfprintf_r+0x830>
800085f2:	2f f7       	sub	r7,-1
800085f4:	10 39       	cp.w	r9,r8
800085f6:	c0 c4       	brge	8000860e <_vfprintf_r+0x7be>
800085f8:	fa ce f9 44 	sub	lr,sp,-1724
800085fc:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008600:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008604:	50 7c       	stdsp	sp[0x1c],r12
80008606:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000860a:	50 56       	stdsp	sp[0x14],r6
8000860c:	c6 68       	rjmp	800086d8 <_vfprintf_r+0x888>
8000860e:	41 09       	lddsp	r9,sp[0x40]
80008610:	59 f8       	cp.w	r8,31
80008612:	e0 89 00 10 	brgt	80008632 <_vfprintf_r+0x7e2>
80008616:	f2 ca ff f8 	sub	r10,r9,-8
8000861a:	72 1b       	ld.w	r11,r9[0x4]
8000861c:	51 0a       	stdsp	sp[0x40],r10
8000861e:	72 09       	ld.w	r9,r9[0x0]
80008620:	fa ca f9 44 	sub	r10,sp,-1724
80008624:	50 7b       	stdsp	sp[0x1c],r11
80008626:	50 59       	stdsp	sp[0x14],r9
80008628:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000862c:	40 5b       	lddsp	r11,sp[0x14]
8000862e:	40 7a       	lddsp	r10,sp[0x1c]
80008630:	c4 78       	rjmp	800086be <_vfprintf_r+0x86e>
80008632:	72 18       	ld.w	r8,r9[0x4]
80008634:	50 78       	stdsp	sp[0x1c],r8
80008636:	c4 c8       	rjmp	800086ce <_vfprintf_r+0x87e>
80008638:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000863c:	40 3e       	lddsp	lr,sp[0xc]
8000863e:	58 0e       	cp.w	lr,0
80008640:	c2 30       	breq	80008686 <_vfprintf_r+0x836>
80008642:	10 36       	cp.w	r6,r8
80008644:	c0 94       	brge	80008656 <_vfprintf_r+0x806>
80008646:	fa cc f9 44 	sub	r12,sp,-1724
8000864a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000864e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008652:	50 7b       	stdsp	sp[0x1c],r11
80008654:	cd 9b       	rjmp	80008606 <_vfprintf_r+0x7b6>
80008656:	fa c8 f9 50 	sub	r8,sp,-1712
8000865a:	1a d8       	st.w	--sp,r8
8000865c:	fa c8 fa b8 	sub	r8,sp,-1352
80008660:	04 9a       	mov	r10,r2
80008662:	1a d8       	st.w	--sp,r8
80008664:	fa c8 fb b4 	sub	r8,sp,-1100
80008668:	0c 9b       	mov	r11,r6
8000866a:	1a d8       	st.w	--sp,r8
8000866c:	08 9c       	mov	r12,r4
8000866e:	fa c8 f9 40 	sub	r8,sp,-1728
80008672:	fa c9 ff b4 	sub	r9,sp,-76
80008676:	fe b0 fa 55 	rcall	80007b20 <get_arg>
8000867a:	2f dd       	sub	sp,-12
8000867c:	78 1a       	ld.w	r10,r12[0x4]
8000867e:	50 7a       	stdsp	sp[0x1c],r10
80008680:	78 0c       	ld.w	r12,r12[0x0]
80008682:	50 5c       	stdsp	sp[0x14],r12
80008684:	c2 a8       	rjmp	800086d8 <_vfprintf_r+0x888>
80008686:	2f f7       	sub	r7,-1
80008688:	10 39       	cp.w	r9,r8
8000868a:	c0 94       	brge	8000869c <_vfprintf_r+0x84c>
8000868c:	fa c9 f9 44 	sub	r9,sp,-1724
80008690:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008694:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008698:	50 78       	stdsp	sp[0x1c],r8
8000869a:	cb 6b       	rjmp	80008606 <_vfprintf_r+0x7b6>
8000869c:	41 09       	lddsp	r9,sp[0x40]
8000869e:	59 f8       	cp.w	r8,31
800086a0:	e0 89 00 15 	brgt	800086ca <_vfprintf_r+0x87a>
800086a4:	f2 ca ff f8 	sub	r10,r9,-8
800086a8:	72 16       	ld.w	r6,r9[0x4]
800086aa:	72 09       	ld.w	r9,r9[0x0]
800086ac:	51 0a       	stdsp	sp[0x40],r10
800086ae:	50 59       	stdsp	sp[0x14],r9
800086b0:	fa ce f9 44 	sub	lr,sp,-1724
800086b4:	50 76       	stdsp	sp[0x1c],r6
800086b6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800086ba:	40 5b       	lddsp	r11,sp[0x14]
800086bc:	0c 9a       	mov	r10,r6
800086be:	f2 eb fd 88 	st.d	r9[-632],r10
800086c2:	2f f8       	sub	r8,-1
800086c4:	fb 48 06 b4 	st.w	sp[1716],r8
800086c8:	c0 88       	rjmp	800086d8 <_vfprintf_r+0x888>
800086ca:	72 1c       	ld.w	r12,r9[0x4]
800086cc:	50 7c       	stdsp	sp[0x1c],r12
800086ce:	f2 c8 ff f8 	sub	r8,r9,-8
800086d2:	51 08       	stdsp	sp[0x40],r8
800086d4:	72 09       	ld.w	r9,r9[0x0]
800086d6:	50 59       	stdsp	sp[0x14],r9
800086d8:	40 5b       	lddsp	r11,sp[0x14]
800086da:	40 7a       	lddsp	r10,sp[0x1c]
800086dc:	e0 a0 19 54 	rcall	8000b984 <__isinfd>
800086e0:	18 96       	mov	r6,r12
800086e2:	c1 70       	breq	80008710 <_vfprintf_r+0x8c0>
800086e4:	30 08       	mov	r8,0
800086e6:	30 09       	mov	r9,0
800086e8:	40 5b       	lddsp	r11,sp[0x14]
800086ea:	40 7a       	lddsp	r10,sp[0x1c]
800086ec:	e0 a0 1d b4 	rcall	8000c254 <__avr32_f64_cmp_lt>
800086f0:	c0 40       	breq	800086f8 <_vfprintf_r+0x8a8>
800086f2:	32 d8       	mov	r8,45
800086f4:	fb 68 06 bb 	st.b	sp[1723],r8
800086f8:	fe c8 a9 a4 	sub	r8,pc,-22108
800086fc:	fe c6 a9 a4 	sub	r6,pc,-22108
80008700:	a7 d5       	cbr	r5,0x7
80008702:	e0 40 00 47 	cp.w	r0,71
80008706:	f0 06 17 a0 	movle	r6,r8
8000870a:	30 32       	mov	r2,3
8000870c:	e0 8f 06 ce 	bral	800094a8 <_vfprintf_r+0x1658>
80008710:	40 5b       	lddsp	r11,sp[0x14]
80008712:	40 7a       	lddsp	r10,sp[0x1c]
80008714:	e0 a0 19 4d 	rcall	8000b9ae <__isnand>
80008718:	c0 e0       	breq	80008734 <_vfprintf_r+0x8e4>
8000871a:	50 26       	stdsp	sp[0x8],r6
8000871c:	fe c8 a9 c0 	sub	r8,pc,-22080
80008720:	fe c6 a9 c0 	sub	r6,pc,-22080
80008724:	a7 d5       	cbr	r5,0x7
80008726:	e0 40 00 47 	cp.w	r0,71
8000872a:	f0 06 17 a0 	movle	r6,r8
8000872e:	30 32       	mov	r2,3
80008730:	e0 8f 06 c2 	bral	800094b4 <_vfprintf_r+0x1664>
80008734:	40 2a       	lddsp	r10,sp[0x8]
80008736:	5b fa       	cp.w	r10,-1
80008738:	c0 41       	brne	80008740 <_vfprintf_r+0x8f0>
8000873a:	30 69       	mov	r9,6
8000873c:	50 29       	stdsp	sp[0x8],r9
8000873e:	c1 18       	rjmp	80008760 <_vfprintf_r+0x910>
80008740:	e0 40 00 47 	cp.w	r0,71
80008744:	5f 09       	sreq	r9
80008746:	e0 40 00 67 	cp.w	r0,103
8000874a:	5f 08       	sreq	r8
8000874c:	f3 e8 10 08 	or	r8,r9,r8
80008750:	f8 08 18 00 	cp.b	r8,r12
80008754:	c0 60       	breq	80008760 <_vfprintf_r+0x910>
80008756:	40 28       	lddsp	r8,sp[0x8]
80008758:	58 08       	cp.w	r8,0
8000875a:	f9 b8 00 01 	moveq	r8,1
8000875e:	50 28       	stdsp	sp[0x8],r8
80008760:	40 78       	lddsp	r8,sp[0x1c]
80008762:	40 59       	lddsp	r9,sp[0x14]
80008764:	fa e9 06 94 	st.d	sp[1684],r8
80008768:	a9 a5       	sbr	r5,0x8
8000876a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000876e:	58 08       	cp.w	r8,0
80008770:	c0 65       	brlt	8000877c <_vfprintf_r+0x92c>
80008772:	40 5e       	lddsp	lr,sp[0x14]
80008774:	30 0c       	mov	r12,0
80008776:	50 6e       	stdsp	sp[0x18],lr
80008778:	50 9c       	stdsp	sp[0x24],r12
8000877a:	c0 78       	rjmp	80008788 <_vfprintf_r+0x938>
8000877c:	40 5b       	lddsp	r11,sp[0x14]
8000877e:	32 da       	mov	r10,45
80008780:	ee 1b 80 00 	eorh	r11,0x8000
80008784:	50 9a       	stdsp	sp[0x24],r10
80008786:	50 6b       	stdsp	sp[0x18],r11
80008788:	e0 40 00 46 	cp.w	r0,70
8000878c:	5f 09       	sreq	r9
8000878e:	e0 40 00 66 	cp.w	r0,102
80008792:	5f 08       	sreq	r8
80008794:	f3 e8 10 08 	or	r8,r9,r8
80008798:	50 48       	stdsp	sp[0x10],r8
8000879a:	c0 40       	breq	800087a2 <_vfprintf_r+0x952>
8000879c:	40 22       	lddsp	r2,sp[0x8]
8000879e:	30 39       	mov	r9,3
800087a0:	c1 08       	rjmp	800087c0 <_vfprintf_r+0x970>
800087a2:	e0 40 00 45 	cp.w	r0,69
800087a6:	5f 09       	sreq	r9
800087a8:	e0 40 00 65 	cp.w	r0,101
800087ac:	5f 08       	sreq	r8
800087ae:	40 22       	lddsp	r2,sp[0x8]
800087b0:	10 49       	or	r9,r8
800087b2:	2f f2       	sub	r2,-1
800087b4:	40 46       	lddsp	r6,sp[0x10]
800087b6:	ec 09 18 00 	cp.b	r9,r6
800087ba:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800087be:	30 29       	mov	r9,2
800087c0:	fa c8 f9 5c 	sub	r8,sp,-1700
800087c4:	1a d8       	st.w	--sp,r8
800087c6:	fa c8 f9 54 	sub	r8,sp,-1708
800087ca:	1a d8       	st.w	--sp,r8
800087cc:	fa c8 f9 4c 	sub	r8,sp,-1716
800087d0:	08 9c       	mov	r12,r4
800087d2:	1a d8       	st.w	--sp,r8
800087d4:	04 98       	mov	r8,r2
800087d6:	40 9b       	lddsp	r11,sp[0x24]
800087d8:	40 aa       	lddsp	r10,sp[0x28]
800087da:	e0 a0 0b c3 	rcall	80009f60 <_dtoa_r>
800087de:	e0 40 00 47 	cp.w	r0,71
800087e2:	5f 19       	srne	r9
800087e4:	e0 40 00 67 	cp.w	r0,103
800087e8:	5f 18       	srne	r8
800087ea:	18 96       	mov	r6,r12
800087ec:	2f dd       	sub	sp,-12
800087ee:	f3 e8 00 08 	and	r8,r9,r8
800087f2:	c0 41       	brne	800087fa <_vfprintf_r+0x9aa>
800087f4:	ed b5 00 00 	bld	r5,0x0
800087f8:	c3 01       	brne	80008858 <_vfprintf_r+0xa08>
800087fa:	ec 02 00 0e 	add	lr,r6,r2
800087fe:	50 3e       	stdsp	sp[0xc],lr
80008800:	40 4c       	lddsp	r12,sp[0x10]
80008802:	58 0c       	cp.w	r12,0
80008804:	c1 50       	breq	8000882e <_vfprintf_r+0x9de>
80008806:	0d 89       	ld.ub	r9,r6[0x0]
80008808:	33 08       	mov	r8,48
8000880a:	f0 09 18 00 	cp.b	r9,r8
8000880e:	c0 b1       	brne	80008824 <_vfprintf_r+0x9d4>
80008810:	30 08       	mov	r8,0
80008812:	30 09       	mov	r9,0
80008814:	40 6b       	lddsp	r11,sp[0x18]
80008816:	40 7a       	lddsp	r10,sp[0x1c]
80008818:	e0 a0 1c d7 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000881c:	fb b2 00 01 	rsubeq	r2,1
80008820:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008824:	40 3b       	lddsp	r11,sp[0xc]
80008826:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000882a:	10 0b       	add	r11,r8
8000882c:	50 3b       	stdsp	sp[0xc],r11
8000882e:	40 6b       	lddsp	r11,sp[0x18]
80008830:	30 08       	mov	r8,0
80008832:	30 09       	mov	r9,0
80008834:	40 7a       	lddsp	r10,sp[0x1c]
80008836:	e0 a0 1c c8 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000883a:	c0 90       	breq	8000884c <_vfprintf_r+0x9fc>
8000883c:	40 3a       	lddsp	r10,sp[0xc]
8000883e:	fb 4a 06 a4 	st.w	sp[1700],r10
80008842:	c0 58       	rjmp	8000884c <_vfprintf_r+0x9fc>
80008844:	10 c9       	st.b	r8++,r9
80008846:	fb 48 06 a4 	st.w	sp[1700],r8
8000884a:	c0 28       	rjmp	8000884e <_vfprintf_r+0x9fe>
8000884c:	33 09       	mov	r9,48
8000884e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008852:	40 3e       	lddsp	lr,sp[0xc]
80008854:	1c 38       	cp.w	r8,lr
80008856:	cf 73       	brcs	80008844 <_vfprintf_r+0x9f4>
80008858:	e0 40 00 47 	cp.w	r0,71
8000885c:	5f 09       	sreq	r9
8000885e:	e0 40 00 67 	cp.w	r0,103
80008862:	5f 08       	sreq	r8
80008864:	f3 e8 10 08 	or	r8,r9,r8
80008868:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000886c:	0c 19       	sub	r9,r6
8000886e:	50 69       	stdsp	sp[0x18],r9
80008870:	58 08       	cp.w	r8,0
80008872:	c0 b0       	breq	80008888 <_vfprintf_r+0xa38>
80008874:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008878:	5b d8       	cp.w	r8,-3
8000887a:	c0 55       	brlt	80008884 <_vfprintf_r+0xa34>
8000887c:	40 2c       	lddsp	r12,sp[0x8]
8000887e:	18 38       	cp.w	r8,r12
80008880:	e0 8a 00 6a 	brle	80008954 <_vfprintf_r+0xb04>
80008884:	20 20       	sub	r0,2
80008886:	c0 58       	rjmp	80008890 <_vfprintf_r+0xa40>
80008888:	e0 40 00 65 	cp.w	r0,101
8000888c:	e0 89 00 46 	brgt	80008918 <_vfprintf_r+0xac8>
80008890:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008894:	fb 60 06 9c 	st.b	sp[1692],r0
80008898:	20 1b       	sub	r11,1
8000889a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000889e:	c0 47       	brpl	800088a6 <_vfprintf_r+0xa56>
800088a0:	5c 3b       	neg	r11
800088a2:	32 d8       	mov	r8,45
800088a4:	c0 28       	rjmp	800088a8 <_vfprintf_r+0xa58>
800088a6:	32 b8       	mov	r8,43
800088a8:	fb 68 06 9d 	st.b	sp[1693],r8
800088ac:	58 9b       	cp.w	r11,9
800088ae:	e0 8a 00 1d 	brle	800088e8 <_vfprintf_r+0xa98>
800088b2:	fa c9 fa 35 	sub	r9,sp,-1483
800088b6:	30 aa       	mov	r10,10
800088b8:	12 98       	mov	r8,r9
800088ba:	0e 9c       	mov	r12,r7
800088bc:	0c 92       	mov	r2,r6
800088be:	f6 0a 0c 06 	divs	r6,r11,r10
800088c2:	0e 9b       	mov	r11,r7
800088c4:	2d 0b       	sub	r11,-48
800088c6:	10 fb       	st.b	--r8,r11
800088c8:	0c 9b       	mov	r11,r6
800088ca:	58 96       	cp.w	r6,9
800088cc:	fe 99 ff f9 	brgt	800088be <_vfprintf_r+0xa6e>
800088d0:	2d 0b       	sub	r11,-48
800088d2:	18 97       	mov	r7,r12
800088d4:	04 96       	mov	r6,r2
800088d6:	10 fb       	st.b	--r8,r11
800088d8:	fa ca f9 62 	sub	r10,sp,-1694
800088dc:	c0 38       	rjmp	800088e2 <_vfprintf_r+0xa92>
800088de:	11 3b       	ld.ub	r11,r8++
800088e0:	14 cb       	st.b	r10++,r11
800088e2:	12 38       	cp.w	r8,r9
800088e4:	cf d3       	brcs	800088de <_vfprintf_r+0xa8e>
800088e6:	c0 98       	rjmp	800088f8 <_vfprintf_r+0xaa8>
800088e8:	2d 0b       	sub	r11,-48
800088ea:	33 08       	mov	r8,48
800088ec:	fb 6b 06 9f 	st.b	sp[1695],r11
800088f0:	fb 68 06 9e 	st.b	sp[1694],r8
800088f4:	fa ca f9 60 	sub	r10,sp,-1696
800088f8:	fa c8 f9 64 	sub	r8,sp,-1692
800088fc:	f4 08 01 08 	sub	r8,r10,r8
80008900:	50 e8       	stdsp	sp[0x38],r8
80008902:	10 92       	mov	r2,r8
80008904:	40 6b       	lddsp	r11,sp[0x18]
80008906:	16 02       	add	r2,r11
80008908:	58 1b       	cp.w	r11,1
8000890a:	e0 89 00 05 	brgt	80008914 <_vfprintf_r+0xac4>
8000890e:	ed b5 00 00 	bld	r5,0x0
80008912:	c3 51       	brne	8000897c <_vfprintf_r+0xb2c>
80008914:	2f f2       	sub	r2,-1
80008916:	c3 38       	rjmp	8000897c <_vfprintf_r+0xb2c>
80008918:	e0 40 00 66 	cp.w	r0,102
8000891c:	c1 c1       	brne	80008954 <_vfprintf_r+0xb04>
8000891e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008922:	58 02       	cp.w	r2,0
80008924:	e0 8a 00 0c 	brle	8000893c <_vfprintf_r+0xaec>
80008928:	40 2a       	lddsp	r10,sp[0x8]
8000892a:	58 0a       	cp.w	r10,0
8000892c:	c0 41       	brne	80008934 <_vfprintf_r+0xae4>
8000892e:	ed b5 00 00 	bld	r5,0x0
80008932:	c2 51       	brne	8000897c <_vfprintf_r+0xb2c>
80008934:	2f f2       	sub	r2,-1
80008936:	40 29       	lddsp	r9,sp[0x8]
80008938:	12 02       	add	r2,r9
8000893a:	c0 b8       	rjmp	80008950 <_vfprintf_r+0xb00>
8000893c:	40 28       	lddsp	r8,sp[0x8]
8000893e:	58 08       	cp.w	r8,0
80008940:	c0 61       	brne	8000894c <_vfprintf_r+0xafc>
80008942:	ed b5 00 00 	bld	r5,0x0
80008946:	c0 30       	breq	8000894c <_vfprintf_r+0xafc>
80008948:	30 12       	mov	r2,1
8000894a:	c1 98       	rjmp	8000897c <_vfprintf_r+0xb2c>
8000894c:	40 22       	lddsp	r2,sp[0x8]
8000894e:	2f e2       	sub	r2,-2
80008950:	36 60       	mov	r0,102
80008952:	c1 58       	rjmp	8000897c <_vfprintf_r+0xb2c>
80008954:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008958:	40 6e       	lddsp	lr,sp[0x18]
8000895a:	1c 32       	cp.w	r2,lr
8000895c:	c0 65       	brlt	80008968 <_vfprintf_r+0xb18>
8000895e:	ed b5 00 00 	bld	r5,0x0
80008962:	f7 b2 00 ff 	subeq	r2,-1
80008966:	c0 a8       	rjmp	8000897a <_vfprintf_r+0xb2a>
80008968:	e4 08 11 02 	rsub	r8,r2,2
8000896c:	40 6c       	lddsp	r12,sp[0x18]
8000896e:	58 02       	cp.w	r2,0
80008970:	f0 02 17 a0 	movle	r2,r8
80008974:	f9 b2 09 01 	movgt	r2,1
80008978:	18 02       	add	r2,r12
8000897a:	36 70       	mov	r0,103
8000897c:	40 9b       	lddsp	r11,sp[0x24]
8000897e:	58 0b       	cp.w	r11,0
80008980:	e0 80 05 94 	breq	800094a8 <_vfprintf_r+0x1658>
80008984:	32 d8       	mov	r8,45
80008986:	fb 68 06 bb 	st.b	sp[1723],r8
8000898a:	e0 8f 05 93 	bral	800094b0 <_vfprintf_r+0x1660>
8000898e:	50 a7       	stdsp	sp[0x28],r7
80008990:	04 94       	mov	r4,r2
80008992:	0c 97       	mov	r7,r6
80008994:	02 92       	mov	r2,r1
80008996:	06 96       	mov	r6,r3
80008998:	40 41       	lddsp	r1,sp[0x10]
8000899a:	40 93       	lddsp	r3,sp[0x24]
8000899c:	0e 99       	mov	r9,r7
8000899e:	ed b5 00 05 	bld	r5,0x5
800089a2:	c4 81       	brne	80008a32 <_vfprintf_r+0xbe2>
800089a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089a8:	40 3e       	lddsp	lr,sp[0xc]
800089aa:	58 0e       	cp.w	lr,0
800089ac:	c1 d0       	breq	800089e6 <_vfprintf_r+0xb96>
800089ae:	10 36       	cp.w	r6,r8
800089b0:	c0 64       	brge	800089bc <_vfprintf_r+0xb6c>
800089b2:	fa cc f9 44 	sub	r12,sp,-1724
800089b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089ba:	c1 d8       	rjmp	800089f4 <_vfprintf_r+0xba4>
800089bc:	fa c8 f9 50 	sub	r8,sp,-1712
800089c0:	1a d8       	st.w	--sp,r8
800089c2:	fa c8 fa b8 	sub	r8,sp,-1352
800089c6:	04 9a       	mov	r10,r2
800089c8:	1a d8       	st.w	--sp,r8
800089ca:	fa c8 fb b4 	sub	r8,sp,-1100
800089ce:	0c 9b       	mov	r11,r6
800089d0:	1a d8       	st.w	--sp,r8
800089d2:	08 9c       	mov	r12,r4
800089d4:	fa c8 f9 40 	sub	r8,sp,-1728
800089d8:	fa c9 ff b4 	sub	r9,sp,-76
800089dc:	fe b0 f8 a2 	rcall	80007b20 <get_arg>
800089e0:	2f dd       	sub	sp,-12
800089e2:	78 0a       	ld.w	r10,r12[0x0]
800089e4:	c2 08       	rjmp	80008a24 <_vfprintf_r+0xbd4>
800089e6:	2f f7       	sub	r7,-1
800089e8:	10 39       	cp.w	r9,r8
800089ea:	c0 84       	brge	800089fa <_vfprintf_r+0xbaa>
800089ec:	fa cb f9 44 	sub	r11,sp,-1724
800089f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089f4:	ec fa fd 88 	ld.w	r10,r6[-632]
800089f8:	c1 68       	rjmp	80008a24 <_vfprintf_r+0xbd4>
800089fa:	41 09       	lddsp	r9,sp[0x40]
800089fc:	59 f8       	cp.w	r8,31
800089fe:	e0 89 00 10 	brgt	80008a1e <_vfprintf_r+0xbce>
80008a02:	f2 ca ff fc 	sub	r10,r9,-4
80008a06:	51 0a       	stdsp	sp[0x40],r10
80008a08:	fa c6 f9 44 	sub	r6,sp,-1724
80008a0c:	72 0a       	ld.w	r10,r9[0x0]
80008a0e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a12:	f3 4a fd 88 	st.w	r9[-632],r10
80008a16:	2f f8       	sub	r8,-1
80008a18:	fb 48 06 b4 	st.w	sp[1716],r8
80008a1c:	c0 48       	rjmp	80008a24 <_vfprintf_r+0xbd4>
80008a1e:	72 0a       	ld.w	r10,r9[0x0]
80008a20:	2f c9       	sub	r9,-4
80008a22:	51 09       	stdsp	sp[0x40],r9
80008a24:	40 be       	lddsp	lr,sp[0x2c]
80008a26:	1c 98       	mov	r8,lr
80008a28:	95 1e       	st.w	r10[0x4],lr
80008a2a:	bf 58       	asr	r8,0x1f
80008a2c:	95 08       	st.w	r10[0x0],r8
80008a2e:	fe 9f fa 9f 	bral	80007f6c <_vfprintf_r+0x11c>
80008a32:	ed b5 00 04 	bld	r5,0x4
80008a36:	c4 80       	breq	80008ac6 <_vfprintf_r+0xc76>
80008a38:	e2 15 00 40 	andl	r5,0x40,COH
80008a3c:	c4 50       	breq	80008ac6 <_vfprintf_r+0xc76>
80008a3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a42:	40 3c       	lddsp	r12,sp[0xc]
80008a44:	58 0c       	cp.w	r12,0
80008a46:	c1 d0       	breq	80008a80 <_vfprintf_r+0xc30>
80008a48:	10 36       	cp.w	r6,r8
80008a4a:	c0 64       	brge	80008a56 <_vfprintf_r+0xc06>
80008a4c:	fa cb f9 44 	sub	r11,sp,-1724
80008a50:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a54:	c1 d8       	rjmp	80008a8e <_vfprintf_r+0xc3e>
80008a56:	fa c8 f9 50 	sub	r8,sp,-1712
80008a5a:	1a d8       	st.w	--sp,r8
80008a5c:	fa c8 fa b8 	sub	r8,sp,-1352
80008a60:	04 9a       	mov	r10,r2
80008a62:	1a d8       	st.w	--sp,r8
80008a64:	fa c8 fb b4 	sub	r8,sp,-1100
80008a68:	0c 9b       	mov	r11,r6
80008a6a:	1a d8       	st.w	--sp,r8
80008a6c:	08 9c       	mov	r12,r4
80008a6e:	fa c8 f9 40 	sub	r8,sp,-1728
80008a72:	fa c9 ff b4 	sub	r9,sp,-76
80008a76:	fe b0 f8 55 	rcall	80007b20 <get_arg>
80008a7a:	2f dd       	sub	sp,-12
80008a7c:	78 0a       	ld.w	r10,r12[0x0]
80008a7e:	c2 08       	rjmp	80008abe <_vfprintf_r+0xc6e>
80008a80:	2f f7       	sub	r7,-1
80008a82:	10 39       	cp.w	r9,r8
80008a84:	c0 84       	brge	80008a94 <_vfprintf_r+0xc44>
80008a86:	fa ca f9 44 	sub	r10,sp,-1724
80008a8a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a8e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a92:	c1 68       	rjmp	80008abe <_vfprintf_r+0xc6e>
80008a94:	41 09       	lddsp	r9,sp[0x40]
80008a96:	59 f8       	cp.w	r8,31
80008a98:	e0 89 00 10 	brgt	80008ab8 <_vfprintf_r+0xc68>
80008a9c:	f2 ca ff fc 	sub	r10,r9,-4
80008aa0:	51 0a       	stdsp	sp[0x40],r10
80008aa2:	fa c6 f9 44 	sub	r6,sp,-1724
80008aa6:	72 0a       	ld.w	r10,r9[0x0]
80008aa8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aac:	f3 4a fd 88 	st.w	r9[-632],r10
80008ab0:	2f f8       	sub	r8,-1
80008ab2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ab6:	c0 48       	rjmp	80008abe <_vfprintf_r+0xc6e>
80008ab8:	72 0a       	ld.w	r10,r9[0x0]
80008aba:	2f c9       	sub	r9,-4
80008abc:	51 09       	stdsp	sp[0x40],r9
80008abe:	40 be       	lddsp	lr,sp[0x2c]
80008ac0:	b4 0e       	st.h	r10[0x0],lr
80008ac2:	fe 9f fa 55 	bral	80007f6c <_vfprintf_r+0x11c>
80008ac6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008aca:	40 3c       	lddsp	r12,sp[0xc]
80008acc:	58 0c       	cp.w	r12,0
80008ace:	c1 d0       	breq	80008b08 <_vfprintf_r+0xcb8>
80008ad0:	10 36       	cp.w	r6,r8
80008ad2:	c0 64       	brge	80008ade <_vfprintf_r+0xc8e>
80008ad4:	fa cb f9 44 	sub	r11,sp,-1724
80008ad8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008adc:	c1 d8       	rjmp	80008b16 <_vfprintf_r+0xcc6>
80008ade:	fa c8 f9 50 	sub	r8,sp,-1712
80008ae2:	1a d8       	st.w	--sp,r8
80008ae4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ae8:	04 9a       	mov	r10,r2
80008aea:	1a d8       	st.w	--sp,r8
80008aec:	fa c8 fb b4 	sub	r8,sp,-1100
80008af0:	0c 9b       	mov	r11,r6
80008af2:	1a d8       	st.w	--sp,r8
80008af4:	08 9c       	mov	r12,r4
80008af6:	fa c8 f9 40 	sub	r8,sp,-1728
80008afa:	fa c9 ff b4 	sub	r9,sp,-76
80008afe:	fe b0 f8 11 	rcall	80007b20 <get_arg>
80008b02:	2f dd       	sub	sp,-12
80008b04:	78 0a       	ld.w	r10,r12[0x0]
80008b06:	c2 08       	rjmp	80008b46 <_vfprintf_r+0xcf6>
80008b08:	2f f7       	sub	r7,-1
80008b0a:	10 39       	cp.w	r9,r8
80008b0c:	c0 84       	brge	80008b1c <_vfprintf_r+0xccc>
80008b0e:	fa ca f9 44 	sub	r10,sp,-1724
80008b12:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b16:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b1a:	c1 68       	rjmp	80008b46 <_vfprintf_r+0xcf6>
80008b1c:	41 09       	lddsp	r9,sp[0x40]
80008b1e:	59 f8       	cp.w	r8,31
80008b20:	e0 89 00 10 	brgt	80008b40 <_vfprintf_r+0xcf0>
80008b24:	f2 ca ff fc 	sub	r10,r9,-4
80008b28:	51 0a       	stdsp	sp[0x40],r10
80008b2a:	fa c6 f9 44 	sub	r6,sp,-1724
80008b2e:	72 0a       	ld.w	r10,r9[0x0]
80008b30:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b34:	f3 4a fd 88 	st.w	r9[-632],r10
80008b38:	2f f8       	sub	r8,-1
80008b3a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b3e:	c0 48       	rjmp	80008b46 <_vfprintf_r+0xcf6>
80008b40:	72 0a       	ld.w	r10,r9[0x0]
80008b42:	2f c9       	sub	r9,-4
80008b44:	51 09       	stdsp	sp[0x40],r9
80008b46:	40 be       	lddsp	lr,sp[0x2c]
80008b48:	95 0e       	st.w	r10[0x0],lr
80008b4a:	fe 9f fa 11 	bral	80007f6c <_vfprintf_r+0x11c>
80008b4e:	50 a7       	stdsp	sp[0x28],r7
80008b50:	50 80       	stdsp	sp[0x20],r0
80008b52:	0c 97       	mov	r7,r6
80008b54:	04 94       	mov	r4,r2
80008b56:	06 96       	mov	r6,r3
80008b58:	02 92       	mov	r2,r1
80008b5a:	40 93       	lddsp	r3,sp[0x24]
80008b5c:	10 90       	mov	r0,r8
80008b5e:	40 41       	lddsp	r1,sp[0x10]
80008b60:	a5 a5       	sbr	r5,0x4
80008b62:	c0 a8       	rjmp	80008b76 <_vfprintf_r+0xd26>
80008b64:	50 a7       	stdsp	sp[0x28],r7
80008b66:	50 80       	stdsp	sp[0x20],r0
80008b68:	0c 97       	mov	r7,r6
80008b6a:	04 94       	mov	r4,r2
80008b6c:	06 96       	mov	r6,r3
80008b6e:	02 92       	mov	r2,r1
80008b70:	40 93       	lddsp	r3,sp[0x24]
80008b72:	10 90       	mov	r0,r8
80008b74:	40 41       	lddsp	r1,sp[0x10]
80008b76:	ed b5 00 05 	bld	r5,0x5
80008b7a:	c5 d1       	brne	80008c34 <_vfprintf_r+0xde4>
80008b7c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b80:	40 3c       	lddsp	r12,sp[0xc]
80008b82:	58 0c       	cp.w	r12,0
80008b84:	c2 60       	breq	80008bd0 <_vfprintf_r+0xd80>
80008b86:	10 36       	cp.w	r6,r8
80008b88:	c0 a4       	brge	80008b9c <_vfprintf_r+0xd4c>
80008b8a:	fa cb f9 44 	sub	r11,sp,-1724
80008b8e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b92:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008b96:	fa e9 00 00 	st.d	sp[0],r8
80008b9a:	c1 88       	rjmp	80008bca <_vfprintf_r+0xd7a>
80008b9c:	fa c8 f9 50 	sub	r8,sp,-1712
80008ba0:	1a d8       	st.w	--sp,r8
80008ba2:	fa c8 fa b8 	sub	r8,sp,-1352
80008ba6:	04 9a       	mov	r10,r2
80008ba8:	1a d8       	st.w	--sp,r8
80008baa:	0c 9b       	mov	r11,r6
80008bac:	fa c8 fb b4 	sub	r8,sp,-1100
80008bb0:	08 9c       	mov	r12,r4
80008bb2:	1a d8       	st.w	--sp,r8
80008bb4:	fa c8 f9 40 	sub	r8,sp,-1728
80008bb8:	fa c9 ff b4 	sub	r9,sp,-76
80008bbc:	fe b0 f7 b2 	rcall	80007b20 <get_arg>
80008bc0:	2f dd       	sub	sp,-12
80008bc2:	f8 ea 00 00 	ld.d	r10,r12[0]
80008bc6:	fa eb 00 00 	st.d	sp[0],r10
80008bca:	30 08       	mov	r8,0
80008bcc:	e0 8f 03 de 	bral	80009388 <_vfprintf_r+0x1538>
80008bd0:	ee ca ff ff 	sub	r10,r7,-1
80008bd4:	10 37       	cp.w	r7,r8
80008bd6:	c0 b4       	brge	80008bec <_vfprintf_r+0xd9c>
80008bd8:	fa c9 f9 44 	sub	r9,sp,-1724
80008bdc:	14 97       	mov	r7,r10
80008bde:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008be2:	ec ea fd 88 	ld.d	r10,r6[-632]
80008be6:	fa eb 00 00 	st.d	sp[0],r10
80008bea:	c1 88       	rjmp	80008c1a <_vfprintf_r+0xdca>
80008bec:	41 09       	lddsp	r9,sp[0x40]
80008bee:	59 f8       	cp.w	r8,31
80008bf0:	e0 89 00 18 	brgt	80008c20 <_vfprintf_r+0xdd0>
80008bf4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bf8:	f2 cb ff f8 	sub	r11,r9,-8
80008bfc:	fa e7 00 00 	st.d	sp[0],r6
80008c00:	51 0b       	stdsp	sp[0x40],r11
80008c02:	fa c6 f9 44 	sub	r6,sp,-1724
80008c06:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c0a:	fa e6 00 00 	ld.d	r6,sp[0]
80008c0e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c12:	2f f8       	sub	r8,-1
80008c14:	14 97       	mov	r7,r10
80008c16:	fb 48 06 b4 	st.w	sp[1716],r8
80008c1a:	40 38       	lddsp	r8,sp[0xc]
80008c1c:	e0 8f 03 b6 	bral	80009388 <_vfprintf_r+0x1538>
80008c20:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c24:	40 38       	lddsp	r8,sp[0xc]
80008c26:	fa e7 00 00 	st.d	sp[0],r6
80008c2a:	2f 89       	sub	r9,-8
80008c2c:	14 97       	mov	r7,r10
80008c2e:	51 09       	stdsp	sp[0x40],r9
80008c30:	e0 8f 03 ac 	bral	80009388 <_vfprintf_r+0x1538>
80008c34:	ed b5 00 04 	bld	r5,0x4
80008c38:	c1 61       	brne	80008c64 <_vfprintf_r+0xe14>
80008c3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c3e:	40 3e       	lddsp	lr,sp[0xc]
80008c40:	58 0e       	cp.w	lr,0
80008c42:	c0 80       	breq	80008c52 <_vfprintf_r+0xe02>
80008c44:	10 36       	cp.w	r6,r8
80008c46:	c6 74       	brge	80008d14 <_vfprintf_r+0xec4>
80008c48:	fa cc f9 44 	sub	r12,sp,-1724
80008c4c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c50:	c8 08       	rjmp	80008d50 <_vfprintf_r+0xf00>
80008c52:	ee ca ff ff 	sub	r10,r7,-1
80008c56:	10 37       	cp.w	r7,r8
80008c58:	c7 f4       	brge	80008d56 <_vfprintf_r+0xf06>
80008c5a:	fa cb f9 44 	sub	r11,sp,-1724
80008c5e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c62:	c7 68       	rjmp	80008d4e <_vfprintf_r+0xefe>
80008c64:	ed b5 00 06 	bld	r5,0x6
80008c68:	c4 a1       	brne	80008cfc <_vfprintf_r+0xeac>
80008c6a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c6e:	40 3c       	lddsp	r12,sp[0xc]
80008c70:	58 0c       	cp.w	r12,0
80008c72:	c1 d0       	breq	80008cac <_vfprintf_r+0xe5c>
80008c74:	10 36       	cp.w	r6,r8
80008c76:	c0 64       	brge	80008c82 <_vfprintf_r+0xe32>
80008c78:	fa cb f9 44 	sub	r11,sp,-1724
80008c7c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c80:	c1 f8       	rjmp	80008cbe <_vfprintf_r+0xe6e>
80008c82:	fa c8 f9 50 	sub	r8,sp,-1712
80008c86:	1a d8       	st.w	--sp,r8
80008c88:	fa c8 fa b8 	sub	r8,sp,-1352
80008c8c:	1a d8       	st.w	--sp,r8
80008c8e:	fa c8 fb b4 	sub	r8,sp,-1100
80008c92:	1a d8       	st.w	--sp,r8
80008c94:	fa c8 f9 40 	sub	r8,sp,-1728
80008c98:	fa c9 ff b4 	sub	r9,sp,-76
80008c9c:	04 9a       	mov	r10,r2
80008c9e:	0c 9b       	mov	r11,r6
80008ca0:	08 9c       	mov	r12,r4
80008ca2:	fe b0 f7 3f 	rcall	80007b20 <get_arg>
80008ca6:	2f dd       	sub	sp,-12
80008ca8:	98 18       	ld.sh	r8,r12[0x2]
80008caa:	c2 68       	rjmp	80008cf6 <_vfprintf_r+0xea6>
80008cac:	ee ca ff ff 	sub	r10,r7,-1
80008cb0:	10 37       	cp.w	r7,r8
80008cb2:	c0 94       	brge	80008cc4 <_vfprintf_r+0xe74>
80008cb4:	fa c9 f9 44 	sub	r9,sp,-1724
80008cb8:	14 97       	mov	r7,r10
80008cba:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cbe:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008cc2:	c1 a8       	rjmp	80008cf6 <_vfprintf_r+0xea6>
80008cc4:	41 09       	lddsp	r9,sp[0x40]
80008cc6:	59 f8       	cp.w	r8,31
80008cc8:	e0 89 00 13 	brgt	80008cee <_vfprintf_r+0xe9e>
80008ccc:	f2 cb ff fc 	sub	r11,r9,-4
80008cd0:	51 0b       	stdsp	sp[0x40],r11
80008cd2:	72 09       	ld.w	r9,r9[0x0]
80008cd4:	fa c6 f9 44 	sub	r6,sp,-1724
80008cd8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008cdc:	2f f8       	sub	r8,-1
80008cde:	f7 49 fd 88 	st.w	r11[-632],r9
80008ce2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ce6:	14 97       	mov	r7,r10
80008ce8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008cec:	c0 58       	rjmp	80008cf6 <_vfprintf_r+0xea6>
80008cee:	92 18       	ld.sh	r8,r9[0x2]
80008cf0:	14 97       	mov	r7,r10
80008cf2:	2f c9       	sub	r9,-4
80008cf4:	51 09       	stdsp	sp[0x40],r9
80008cf6:	5c 78       	castu.h	r8
80008cf8:	50 18       	stdsp	sp[0x4],r8
80008cfa:	c4 68       	rjmp	80008d86 <_vfprintf_r+0xf36>
80008cfc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d00:	40 3c       	lddsp	r12,sp[0xc]
80008d02:	58 0c       	cp.w	r12,0
80008d04:	c1 d0       	breq	80008d3e <_vfprintf_r+0xeee>
80008d06:	10 36       	cp.w	r6,r8
80008d08:	c0 64       	brge	80008d14 <_vfprintf_r+0xec4>
80008d0a:	fa cb f9 44 	sub	r11,sp,-1724
80008d0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d12:	c1 f8       	rjmp	80008d50 <_vfprintf_r+0xf00>
80008d14:	fa c8 f9 50 	sub	r8,sp,-1712
80008d18:	1a d8       	st.w	--sp,r8
80008d1a:	fa c8 fa b8 	sub	r8,sp,-1352
80008d1e:	0c 9b       	mov	r11,r6
80008d20:	1a d8       	st.w	--sp,r8
80008d22:	fa c8 fb b4 	sub	r8,sp,-1100
80008d26:	04 9a       	mov	r10,r2
80008d28:	1a d8       	st.w	--sp,r8
80008d2a:	08 9c       	mov	r12,r4
80008d2c:	fa c8 f9 40 	sub	r8,sp,-1728
80008d30:	fa c9 ff b4 	sub	r9,sp,-76
80008d34:	fe b0 f6 f6 	rcall	80007b20 <get_arg>
80008d38:	2f dd       	sub	sp,-12
80008d3a:	78 0b       	ld.w	r11,r12[0x0]
80008d3c:	c2 48       	rjmp	80008d84 <_vfprintf_r+0xf34>
80008d3e:	ee ca ff ff 	sub	r10,r7,-1
80008d42:	10 37       	cp.w	r7,r8
80008d44:	c0 94       	brge	80008d56 <_vfprintf_r+0xf06>
80008d46:	fa c9 f9 44 	sub	r9,sp,-1724
80008d4a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d4e:	14 97       	mov	r7,r10
80008d50:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d54:	c1 88       	rjmp	80008d84 <_vfprintf_r+0xf34>
80008d56:	41 09       	lddsp	r9,sp[0x40]
80008d58:	59 f8       	cp.w	r8,31
80008d5a:	e0 89 00 11 	brgt	80008d7c <_vfprintf_r+0xf2c>
80008d5e:	f2 cb ff fc 	sub	r11,r9,-4
80008d62:	51 0b       	stdsp	sp[0x40],r11
80008d64:	fa c6 f9 44 	sub	r6,sp,-1724
80008d68:	72 0b       	ld.w	r11,r9[0x0]
80008d6a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d6e:	f3 4b fd 88 	st.w	r9[-632],r11
80008d72:	2f f8       	sub	r8,-1
80008d74:	14 97       	mov	r7,r10
80008d76:	fb 48 06 b4 	st.w	sp[1716],r8
80008d7a:	c0 58       	rjmp	80008d84 <_vfprintf_r+0xf34>
80008d7c:	72 0b       	ld.w	r11,r9[0x0]
80008d7e:	14 97       	mov	r7,r10
80008d80:	2f c9       	sub	r9,-4
80008d82:	51 09       	stdsp	sp[0x40],r9
80008d84:	50 1b       	stdsp	sp[0x4],r11
80008d86:	30 0e       	mov	lr,0
80008d88:	50 0e       	stdsp	sp[0x0],lr
80008d8a:	1c 98       	mov	r8,lr
80008d8c:	e0 8f 02 fe 	bral	80009388 <_vfprintf_r+0x1538>
80008d90:	50 a7       	stdsp	sp[0x28],r7
80008d92:	50 80       	stdsp	sp[0x20],r0
80008d94:	0c 97       	mov	r7,r6
80008d96:	04 94       	mov	r4,r2
80008d98:	06 96       	mov	r6,r3
80008d9a:	02 92       	mov	r2,r1
80008d9c:	40 93       	lddsp	r3,sp[0x24]
80008d9e:	40 41       	lddsp	r1,sp[0x10]
80008da0:	0e 99       	mov	r9,r7
80008da2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008da6:	40 3c       	lddsp	r12,sp[0xc]
80008da8:	58 0c       	cp.w	r12,0
80008daa:	c1 d0       	breq	80008de4 <_vfprintf_r+0xf94>
80008dac:	10 36       	cp.w	r6,r8
80008dae:	c0 64       	brge	80008dba <_vfprintf_r+0xf6a>
80008db0:	fa cb f9 44 	sub	r11,sp,-1724
80008db4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008db8:	c1 d8       	rjmp	80008df2 <_vfprintf_r+0xfa2>
80008dba:	fa c8 f9 50 	sub	r8,sp,-1712
80008dbe:	1a d8       	st.w	--sp,r8
80008dc0:	fa c8 fa b8 	sub	r8,sp,-1352
80008dc4:	1a d8       	st.w	--sp,r8
80008dc6:	fa c8 fb b4 	sub	r8,sp,-1100
80008dca:	1a d8       	st.w	--sp,r8
80008dcc:	fa c9 ff b4 	sub	r9,sp,-76
80008dd0:	fa c8 f9 40 	sub	r8,sp,-1728
80008dd4:	04 9a       	mov	r10,r2
80008dd6:	0c 9b       	mov	r11,r6
80008dd8:	08 9c       	mov	r12,r4
80008dda:	fe b0 f6 a3 	rcall	80007b20 <get_arg>
80008dde:	2f dd       	sub	sp,-12
80008de0:	78 09       	ld.w	r9,r12[0x0]
80008de2:	c2 18       	rjmp	80008e24 <_vfprintf_r+0xfd4>
80008de4:	2f f7       	sub	r7,-1
80008de6:	10 39       	cp.w	r9,r8
80008de8:	c0 84       	brge	80008df8 <_vfprintf_r+0xfa8>
80008dea:	fa ca f9 44 	sub	r10,sp,-1724
80008dee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008df2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008df6:	c1 78       	rjmp	80008e24 <_vfprintf_r+0xfd4>
80008df8:	41 09       	lddsp	r9,sp[0x40]
80008dfa:	59 f8       	cp.w	r8,31
80008dfc:	e0 89 00 10 	brgt	80008e1c <_vfprintf_r+0xfcc>
80008e00:	f2 ca ff fc 	sub	r10,r9,-4
80008e04:	51 0a       	stdsp	sp[0x40],r10
80008e06:	fa c6 f9 44 	sub	r6,sp,-1724
80008e0a:	72 09       	ld.w	r9,r9[0x0]
80008e0c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e10:	f5 49 fd 88 	st.w	r10[-632],r9
80008e14:	2f f8       	sub	r8,-1
80008e16:	fb 48 06 b4 	st.w	sp[1716],r8
80008e1a:	c0 58       	rjmp	80008e24 <_vfprintf_r+0xfd4>
80008e1c:	f2 c8 ff fc 	sub	r8,r9,-4
80008e20:	51 08       	stdsp	sp[0x40],r8
80008e22:	72 09       	ld.w	r9,r9[0x0]
80008e24:	33 08       	mov	r8,48
80008e26:	fb 68 06 b8 	st.b	sp[1720],r8
80008e2a:	37 88       	mov	r8,120
80008e2c:	30 0e       	mov	lr,0
80008e2e:	fb 68 06 b9 	st.b	sp[1721],r8
80008e32:	fe cc b0 ce 	sub	r12,pc,-20274
80008e36:	50 19       	stdsp	sp[0x4],r9
80008e38:	a1 b5       	sbr	r5,0x1
80008e3a:	50 0e       	stdsp	sp[0x0],lr
80008e3c:	50 dc       	stdsp	sp[0x34],r12
80008e3e:	30 28       	mov	r8,2
80008e40:	37 80       	mov	r0,120
80008e42:	e0 8f 02 a3 	bral	80009388 <_vfprintf_r+0x1538>
80008e46:	50 a7       	stdsp	sp[0x28],r7
80008e48:	50 80       	stdsp	sp[0x20],r0
80008e4a:	10 90       	mov	r0,r8
80008e4c:	30 08       	mov	r8,0
80008e4e:	fb 68 06 bb 	st.b	sp[1723],r8
80008e52:	0c 97       	mov	r7,r6
80008e54:	04 94       	mov	r4,r2
80008e56:	06 96       	mov	r6,r3
80008e58:	02 92       	mov	r2,r1
80008e5a:	40 93       	lddsp	r3,sp[0x24]
80008e5c:	40 41       	lddsp	r1,sp[0x10]
80008e5e:	0e 99       	mov	r9,r7
80008e60:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e64:	40 3b       	lddsp	r11,sp[0xc]
80008e66:	58 0b       	cp.w	r11,0
80008e68:	c1 d0       	breq	80008ea2 <_vfprintf_r+0x1052>
80008e6a:	10 36       	cp.w	r6,r8
80008e6c:	c0 64       	brge	80008e78 <_vfprintf_r+0x1028>
80008e6e:	fa ca f9 44 	sub	r10,sp,-1724
80008e72:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e76:	c1 d8       	rjmp	80008eb0 <_vfprintf_r+0x1060>
80008e78:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e82:	1a d8       	st.w	--sp,r8
80008e84:	fa c8 fb b4 	sub	r8,sp,-1100
80008e88:	0c 9b       	mov	r11,r6
80008e8a:	1a d8       	st.w	--sp,r8
80008e8c:	04 9a       	mov	r10,r2
80008e8e:	fa c8 f9 40 	sub	r8,sp,-1728
80008e92:	fa c9 ff b4 	sub	r9,sp,-76
80008e96:	08 9c       	mov	r12,r4
80008e98:	fe b0 f6 44 	rcall	80007b20 <get_arg>
80008e9c:	2f dd       	sub	sp,-12
80008e9e:	78 06       	ld.w	r6,r12[0x0]
80008ea0:	c2 08       	rjmp	80008ee0 <_vfprintf_r+0x1090>
80008ea2:	2f f7       	sub	r7,-1
80008ea4:	10 39       	cp.w	r9,r8
80008ea6:	c0 84       	brge	80008eb6 <_vfprintf_r+0x1066>
80008ea8:	fa c9 f9 44 	sub	r9,sp,-1724
80008eac:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eb0:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008eb4:	c1 68       	rjmp	80008ee0 <_vfprintf_r+0x1090>
80008eb6:	41 09       	lddsp	r9,sp[0x40]
80008eb8:	59 f8       	cp.w	r8,31
80008eba:	e0 89 00 10 	brgt	80008eda <_vfprintf_r+0x108a>
80008ebe:	f2 ca ff fc 	sub	r10,r9,-4
80008ec2:	51 0a       	stdsp	sp[0x40],r10
80008ec4:	72 06       	ld.w	r6,r9[0x0]
80008ec6:	fa ce f9 44 	sub	lr,sp,-1724
80008eca:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008ece:	f3 46 fd 88 	st.w	r9[-632],r6
80008ed2:	2f f8       	sub	r8,-1
80008ed4:	fb 48 06 b4 	st.w	sp[1716],r8
80008ed8:	c0 48       	rjmp	80008ee0 <_vfprintf_r+0x1090>
80008eda:	72 06       	ld.w	r6,r9[0x0]
80008edc:	2f c9       	sub	r9,-4
80008ede:	51 09       	stdsp	sp[0x40],r9
80008ee0:	40 2c       	lddsp	r12,sp[0x8]
80008ee2:	58 0c       	cp.w	r12,0
80008ee4:	c1 05       	brlt	80008f04 <_vfprintf_r+0x10b4>
80008ee6:	18 9a       	mov	r10,r12
80008ee8:	30 0b       	mov	r11,0
80008eea:	0c 9c       	mov	r12,r6
80008eec:	e0 a0 12 38 	rcall	8000b35c <memchr>
80008ef0:	e0 80 02 df 	breq	800094ae <_vfprintf_r+0x165e>
80008ef4:	f8 06 01 02 	sub	r2,r12,r6
80008ef8:	40 2b       	lddsp	r11,sp[0x8]
80008efa:	16 32       	cp.w	r2,r11
80008efc:	e0 89 02 d9 	brgt	800094ae <_vfprintf_r+0x165e>
80008f00:	e0 8f 02 d4 	bral	800094a8 <_vfprintf_r+0x1658>
80008f04:	30 0a       	mov	r10,0
80008f06:	0c 9c       	mov	r12,r6
80008f08:	50 2a       	stdsp	sp[0x8],r10
80008f0a:	e0 a0 15 99 	rcall	8000ba3c <strlen>
80008f0e:	18 92       	mov	r2,r12
80008f10:	e0 8f 02 d2 	bral	800094b4 <_vfprintf_r+0x1664>
80008f14:	50 a7       	stdsp	sp[0x28],r7
80008f16:	50 80       	stdsp	sp[0x20],r0
80008f18:	0c 97       	mov	r7,r6
80008f1a:	04 94       	mov	r4,r2
80008f1c:	06 96       	mov	r6,r3
80008f1e:	02 92       	mov	r2,r1
80008f20:	40 93       	lddsp	r3,sp[0x24]
80008f22:	10 90       	mov	r0,r8
80008f24:	40 41       	lddsp	r1,sp[0x10]
80008f26:	a5 a5       	sbr	r5,0x4
80008f28:	c0 a8       	rjmp	80008f3c <_vfprintf_r+0x10ec>
80008f2a:	50 a7       	stdsp	sp[0x28],r7
80008f2c:	50 80       	stdsp	sp[0x20],r0
80008f2e:	0c 97       	mov	r7,r6
80008f30:	04 94       	mov	r4,r2
80008f32:	06 96       	mov	r6,r3
80008f34:	02 92       	mov	r2,r1
80008f36:	40 93       	lddsp	r3,sp[0x24]
80008f38:	10 90       	mov	r0,r8
80008f3a:	40 41       	lddsp	r1,sp[0x10]
80008f3c:	ed b5 00 05 	bld	r5,0x5
80008f40:	c5 61       	brne	80008fec <_vfprintf_r+0x119c>
80008f42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f46:	40 39       	lddsp	r9,sp[0xc]
80008f48:	58 09       	cp.w	r9,0
80008f4a:	c2 10       	breq	80008f8c <_vfprintf_r+0x113c>
80008f4c:	10 36       	cp.w	r6,r8
80008f4e:	c0 74       	brge	80008f5c <_vfprintf_r+0x110c>
80008f50:	fa c8 f9 44 	sub	r8,sp,-1724
80008f54:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f58:	c2 38       	rjmp	80008f9e <_vfprintf_r+0x114e>
80008f5a:	d7 03       	nop
80008f5c:	fa c8 f9 50 	sub	r8,sp,-1712
80008f60:	1a d8       	st.w	--sp,r8
80008f62:	fa c8 fa b8 	sub	r8,sp,-1352
80008f66:	1a d8       	st.w	--sp,r8
80008f68:	fa c8 fb b4 	sub	r8,sp,-1100
80008f6c:	1a d8       	st.w	--sp,r8
80008f6e:	fa c8 f9 40 	sub	r8,sp,-1728
80008f72:	fa c9 ff b4 	sub	r9,sp,-76
80008f76:	04 9a       	mov	r10,r2
80008f78:	0c 9b       	mov	r11,r6
80008f7a:	08 9c       	mov	r12,r4
80008f7c:	fe b0 f5 d2 	rcall	80007b20 <get_arg>
80008f80:	2f dd       	sub	sp,-12
80008f82:	f8 e8 00 00 	ld.d	r8,r12[0]
80008f86:	fa e9 00 00 	st.d	sp[0],r8
80008f8a:	c2 e8       	rjmp	80008fe6 <_vfprintf_r+0x1196>
80008f8c:	ee ca ff ff 	sub	r10,r7,-1
80008f90:	10 37       	cp.w	r7,r8
80008f92:	c0 b4       	brge	80008fa8 <_vfprintf_r+0x1158>
80008f94:	fa c8 f9 44 	sub	r8,sp,-1724
80008f98:	14 97       	mov	r7,r10
80008f9a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f9e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008fa2:	fa eb 00 00 	st.d	sp[0],r10
80008fa6:	c2 08       	rjmp	80008fe6 <_vfprintf_r+0x1196>
80008fa8:	41 09       	lddsp	r9,sp[0x40]
80008faa:	59 f8       	cp.w	r8,31
80008fac:	e0 89 00 16 	brgt	80008fd8 <_vfprintf_r+0x1188>
80008fb0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fb4:	f2 cb ff f8 	sub	r11,r9,-8
80008fb8:	fa e7 00 00 	st.d	sp[0],r6
80008fbc:	51 0b       	stdsp	sp[0x40],r11
80008fbe:	fa c6 f9 44 	sub	r6,sp,-1724
80008fc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fc6:	fa e6 00 00 	ld.d	r6,sp[0]
80008fca:	f2 e7 fd 88 	st.d	r9[-632],r6
80008fce:	2f f8       	sub	r8,-1
80008fd0:	14 97       	mov	r7,r10
80008fd2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fd6:	c0 88       	rjmp	80008fe6 <_vfprintf_r+0x1196>
80008fd8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fdc:	2f 89       	sub	r9,-8
80008fde:	fa e7 00 00 	st.d	sp[0],r6
80008fe2:	51 09       	stdsp	sp[0x40],r9
80008fe4:	14 97       	mov	r7,r10
80008fe6:	30 18       	mov	r8,1
80008fe8:	e0 8f 01 d0 	bral	80009388 <_vfprintf_r+0x1538>
80008fec:	ed b5 00 04 	bld	r5,0x4
80008ff0:	c1 61       	brne	8000901c <_vfprintf_r+0x11cc>
80008ff2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ff6:	40 3e       	lddsp	lr,sp[0xc]
80008ff8:	58 0e       	cp.w	lr,0
80008ffa:	c0 80       	breq	8000900a <_vfprintf_r+0x11ba>
80008ffc:	10 36       	cp.w	r6,r8
80008ffe:	c6 74       	brge	800090cc <_vfprintf_r+0x127c>
80009000:	fa cc f9 44 	sub	r12,sp,-1724
80009004:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009008:	c8 08       	rjmp	80009108 <_vfprintf_r+0x12b8>
8000900a:	ee ca ff ff 	sub	r10,r7,-1
8000900e:	10 37       	cp.w	r7,r8
80009010:	c7 f4       	brge	8000910e <_vfprintf_r+0x12be>
80009012:	fa cb f9 44 	sub	r11,sp,-1724
80009016:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000901a:	c7 68       	rjmp	80009106 <_vfprintf_r+0x12b6>
8000901c:	ed b5 00 06 	bld	r5,0x6
80009020:	c4 a1       	brne	800090b4 <_vfprintf_r+0x1264>
80009022:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009026:	40 3c       	lddsp	r12,sp[0xc]
80009028:	58 0c       	cp.w	r12,0
8000902a:	c1 d0       	breq	80009064 <_vfprintf_r+0x1214>
8000902c:	10 36       	cp.w	r6,r8
8000902e:	c0 64       	brge	8000903a <_vfprintf_r+0x11ea>
80009030:	fa cb f9 44 	sub	r11,sp,-1724
80009034:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009038:	c1 f8       	rjmp	80009076 <_vfprintf_r+0x1226>
8000903a:	fa c8 f9 50 	sub	r8,sp,-1712
8000903e:	1a d8       	st.w	--sp,r8
80009040:	fa c8 fa b8 	sub	r8,sp,-1352
80009044:	1a d8       	st.w	--sp,r8
80009046:	fa c8 fb b4 	sub	r8,sp,-1100
8000904a:	1a d8       	st.w	--sp,r8
8000904c:	fa c8 f9 40 	sub	r8,sp,-1728
80009050:	fa c9 ff b4 	sub	r9,sp,-76
80009054:	04 9a       	mov	r10,r2
80009056:	0c 9b       	mov	r11,r6
80009058:	08 9c       	mov	r12,r4
8000905a:	fe b0 f5 63 	rcall	80007b20 <get_arg>
8000905e:	2f dd       	sub	sp,-12
80009060:	98 18       	ld.sh	r8,r12[0x2]
80009062:	c2 68       	rjmp	800090ae <_vfprintf_r+0x125e>
80009064:	ee ca ff ff 	sub	r10,r7,-1
80009068:	10 37       	cp.w	r7,r8
8000906a:	c0 94       	brge	8000907c <_vfprintf_r+0x122c>
8000906c:	fa c9 f9 44 	sub	r9,sp,-1724
80009070:	14 97       	mov	r7,r10
80009072:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009076:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000907a:	c1 a8       	rjmp	800090ae <_vfprintf_r+0x125e>
8000907c:	41 09       	lddsp	r9,sp[0x40]
8000907e:	59 f8       	cp.w	r8,31
80009080:	e0 89 00 13 	brgt	800090a6 <_vfprintf_r+0x1256>
80009084:	f2 cb ff fc 	sub	r11,r9,-4
80009088:	51 0b       	stdsp	sp[0x40],r11
8000908a:	72 09       	ld.w	r9,r9[0x0]
8000908c:	fa c6 f9 44 	sub	r6,sp,-1724
80009090:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009094:	2f f8       	sub	r8,-1
80009096:	f7 49 fd 88 	st.w	r11[-632],r9
8000909a:	fb 48 06 b4 	st.w	sp[1716],r8
8000909e:	14 97       	mov	r7,r10
800090a0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800090a4:	c0 58       	rjmp	800090ae <_vfprintf_r+0x125e>
800090a6:	92 18       	ld.sh	r8,r9[0x2]
800090a8:	14 97       	mov	r7,r10
800090aa:	2f c9       	sub	r9,-4
800090ac:	51 09       	stdsp	sp[0x40],r9
800090ae:	5c 78       	castu.h	r8
800090b0:	50 18       	stdsp	sp[0x4],r8
800090b2:	c4 68       	rjmp	8000913e <_vfprintf_r+0x12ee>
800090b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090b8:	40 3c       	lddsp	r12,sp[0xc]
800090ba:	58 0c       	cp.w	r12,0
800090bc:	c1 d0       	breq	800090f6 <_vfprintf_r+0x12a6>
800090be:	10 36       	cp.w	r6,r8
800090c0:	c0 64       	brge	800090cc <_vfprintf_r+0x127c>
800090c2:	fa cb f9 44 	sub	r11,sp,-1724
800090c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090ca:	c1 f8       	rjmp	80009108 <_vfprintf_r+0x12b8>
800090cc:	fa c8 f9 50 	sub	r8,sp,-1712
800090d0:	1a d8       	st.w	--sp,r8
800090d2:	fa c8 fa b8 	sub	r8,sp,-1352
800090d6:	0c 9b       	mov	r11,r6
800090d8:	1a d8       	st.w	--sp,r8
800090da:	fa c8 fb b4 	sub	r8,sp,-1100
800090de:	04 9a       	mov	r10,r2
800090e0:	1a d8       	st.w	--sp,r8
800090e2:	08 9c       	mov	r12,r4
800090e4:	fa c8 f9 40 	sub	r8,sp,-1728
800090e8:	fa c9 ff b4 	sub	r9,sp,-76
800090ec:	fe b0 f5 1a 	rcall	80007b20 <get_arg>
800090f0:	2f dd       	sub	sp,-12
800090f2:	78 0b       	ld.w	r11,r12[0x0]
800090f4:	c2 48       	rjmp	8000913c <_vfprintf_r+0x12ec>
800090f6:	ee ca ff ff 	sub	r10,r7,-1
800090fa:	10 37       	cp.w	r7,r8
800090fc:	c0 94       	brge	8000910e <_vfprintf_r+0x12be>
800090fe:	fa c9 f9 44 	sub	r9,sp,-1724
80009102:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009106:	14 97       	mov	r7,r10
80009108:	ec fb fd 88 	ld.w	r11,r6[-632]
8000910c:	c1 88       	rjmp	8000913c <_vfprintf_r+0x12ec>
8000910e:	41 09       	lddsp	r9,sp[0x40]
80009110:	59 f8       	cp.w	r8,31
80009112:	e0 89 00 11 	brgt	80009134 <_vfprintf_r+0x12e4>
80009116:	f2 cb ff fc 	sub	r11,r9,-4
8000911a:	51 0b       	stdsp	sp[0x40],r11
8000911c:	fa c6 f9 44 	sub	r6,sp,-1724
80009120:	72 0b       	ld.w	r11,r9[0x0]
80009122:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009126:	f3 4b fd 88 	st.w	r9[-632],r11
8000912a:	2f f8       	sub	r8,-1
8000912c:	14 97       	mov	r7,r10
8000912e:	fb 48 06 b4 	st.w	sp[1716],r8
80009132:	c0 58       	rjmp	8000913c <_vfprintf_r+0x12ec>
80009134:	72 0b       	ld.w	r11,r9[0x0]
80009136:	14 97       	mov	r7,r10
80009138:	2f c9       	sub	r9,-4
8000913a:	51 09       	stdsp	sp[0x40],r9
8000913c:	50 1b       	stdsp	sp[0x4],r11
8000913e:	30 0e       	mov	lr,0
80009140:	30 18       	mov	r8,1
80009142:	50 0e       	stdsp	sp[0x0],lr
80009144:	c2 29       	rjmp	80009388 <_vfprintf_r+0x1538>
80009146:	50 a7       	stdsp	sp[0x28],r7
80009148:	50 80       	stdsp	sp[0x20],r0
8000914a:	0c 97       	mov	r7,r6
8000914c:	04 94       	mov	r4,r2
8000914e:	06 96       	mov	r6,r3
80009150:	02 92       	mov	r2,r1
80009152:	fe cc b3 ee 	sub	r12,pc,-19474
80009156:	40 93       	lddsp	r3,sp[0x24]
80009158:	10 90       	mov	r0,r8
8000915a:	40 41       	lddsp	r1,sp[0x10]
8000915c:	50 dc       	stdsp	sp[0x34],r12
8000915e:	ed b5 00 05 	bld	r5,0x5
80009162:	c5 51       	brne	8000920c <_vfprintf_r+0x13bc>
80009164:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009168:	40 3b       	lddsp	r11,sp[0xc]
8000916a:	58 0b       	cp.w	r11,0
8000916c:	c2 20       	breq	800091b0 <_vfprintf_r+0x1360>
8000916e:	10 36       	cp.w	r6,r8
80009170:	c0 a4       	brge	80009184 <_vfprintf_r+0x1334>
80009172:	fa ca f9 44 	sub	r10,sp,-1724
80009176:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000917a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000917e:	fa e9 00 00 	st.d	sp[0],r8
80009182:	cf 28       	rjmp	80009366 <_vfprintf_r+0x1516>
80009184:	fa c8 f9 50 	sub	r8,sp,-1712
80009188:	1a d8       	st.w	--sp,r8
8000918a:	fa c8 fa b8 	sub	r8,sp,-1352
8000918e:	04 9a       	mov	r10,r2
80009190:	1a d8       	st.w	--sp,r8
80009192:	0c 9b       	mov	r11,r6
80009194:	fa c8 fb b4 	sub	r8,sp,-1100
80009198:	08 9c       	mov	r12,r4
8000919a:	1a d8       	st.w	--sp,r8
8000919c:	fa c8 f9 40 	sub	r8,sp,-1728
800091a0:	fa c9 ff b4 	sub	r9,sp,-76
800091a4:	fe b0 f4 be 	rcall	80007b20 <get_arg>
800091a8:	2f dd       	sub	sp,-12
800091aa:	f8 ea 00 00 	ld.d	r10,r12[0]
800091ae:	c0 c8       	rjmp	800091c6 <_vfprintf_r+0x1376>
800091b0:	ee ca ff ff 	sub	r10,r7,-1
800091b4:	10 37       	cp.w	r7,r8
800091b6:	c0 b4       	brge	800091cc <_vfprintf_r+0x137c>
800091b8:	fa c9 f9 44 	sub	r9,sp,-1724
800091bc:	14 97       	mov	r7,r10
800091be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091c2:	ec ea fd 88 	ld.d	r10,r6[-632]
800091c6:	fa eb 00 00 	st.d	sp[0],r10
800091ca:	cc e8       	rjmp	80009366 <_vfprintf_r+0x1516>
800091cc:	41 09       	lddsp	r9,sp[0x40]
800091ce:	59 f8       	cp.w	r8,31
800091d0:	e0 89 00 16 	brgt	800091fc <_vfprintf_r+0x13ac>
800091d4:	f2 e6 00 00 	ld.d	r6,r9[0]
800091d8:	f2 cb ff f8 	sub	r11,r9,-8
800091dc:	fa e7 00 00 	st.d	sp[0],r6
800091e0:	51 0b       	stdsp	sp[0x40],r11
800091e2:	fa c6 f9 44 	sub	r6,sp,-1724
800091e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091ea:	fa e6 00 00 	ld.d	r6,sp[0]
800091ee:	f2 e7 fd 88 	st.d	r9[-632],r6
800091f2:	2f f8       	sub	r8,-1
800091f4:	14 97       	mov	r7,r10
800091f6:	fb 48 06 b4 	st.w	sp[1716],r8
800091fa:	cb 68       	rjmp	80009366 <_vfprintf_r+0x1516>
800091fc:	f2 e6 00 00 	ld.d	r6,r9[0]
80009200:	2f 89       	sub	r9,-8
80009202:	fa e7 00 00 	st.d	sp[0],r6
80009206:	51 09       	stdsp	sp[0x40],r9
80009208:	14 97       	mov	r7,r10
8000920a:	ca e8       	rjmp	80009366 <_vfprintf_r+0x1516>
8000920c:	ed b5 00 04 	bld	r5,0x4
80009210:	c1 71       	brne	8000923e <_vfprintf_r+0x13ee>
80009212:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009216:	40 3e       	lddsp	lr,sp[0xc]
80009218:	58 0e       	cp.w	lr,0
8000921a:	c0 80       	breq	8000922a <_vfprintf_r+0x13da>
8000921c:	10 36       	cp.w	r6,r8
8000921e:	c6 94       	brge	800092f0 <_vfprintf_r+0x14a0>
80009220:	fa cc f9 44 	sub	r12,sp,-1724
80009224:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009228:	c8 28       	rjmp	8000932c <_vfprintf_r+0x14dc>
8000922a:	ee ca ff ff 	sub	r10,r7,-1
8000922e:	10 37       	cp.w	r7,r8
80009230:	e0 84 00 81 	brge	80009332 <_vfprintf_r+0x14e2>
80009234:	fa cb f9 44 	sub	r11,sp,-1724
80009238:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000923c:	c7 78       	rjmp	8000932a <_vfprintf_r+0x14da>
8000923e:	ed b5 00 06 	bld	r5,0x6
80009242:	c4 b1       	brne	800092d8 <_vfprintf_r+0x1488>
80009244:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009248:	40 3c       	lddsp	r12,sp[0xc]
8000924a:	58 0c       	cp.w	r12,0
8000924c:	c1 d0       	breq	80009286 <_vfprintf_r+0x1436>
8000924e:	10 36       	cp.w	r6,r8
80009250:	c0 64       	brge	8000925c <_vfprintf_r+0x140c>
80009252:	fa cb f9 44 	sub	r11,sp,-1724
80009256:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000925a:	c1 f8       	rjmp	80009298 <_vfprintf_r+0x1448>
8000925c:	fa c8 f9 50 	sub	r8,sp,-1712
80009260:	1a d8       	st.w	--sp,r8
80009262:	fa c8 fa b8 	sub	r8,sp,-1352
80009266:	1a d8       	st.w	--sp,r8
80009268:	fa c8 fb b4 	sub	r8,sp,-1100
8000926c:	1a d8       	st.w	--sp,r8
8000926e:	fa c8 f9 40 	sub	r8,sp,-1728
80009272:	fa c9 ff b4 	sub	r9,sp,-76
80009276:	04 9a       	mov	r10,r2
80009278:	0c 9b       	mov	r11,r6
8000927a:	08 9c       	mov	r12,r4
8000927c:	fe b0 f4 52 	rcall	80007b20 <get_arg>
80009280:	2f dd       	sub	sp,-12
80009282:	98 18       	ld.sh	r8,r12[0x2]
80009284:	c2 78       	rjmp	800092d2 <_vfprintf_r+0x1482>
80009286:	ee ca ff ff 	sub	r10,r7,-1
8000928a:	10 37       	cp.w	r7,r8
8000928c:	c0 a4       	brge	800092a0 <_vfprintf_r+0x1450>
8000928e:	fa c9 f9 44 	sub	r9,sp,-1724
80009292:	14 97       	mov	r7,r10
80009294:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009298:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000929c:	c1 b8       	rjmp	800092d2 <_vfprintf_r+0x1482>
8000929e:	d7 03       	nop
800092a0:	41 09       	lddsp	r9,sp[0x40]
800092a2:	59 f8       	cp.w	r8,31
800092a4:	e0 89 00 13 	brgt	800092ca <_vfprintf_r+0x147a>
800092a8:	f2 cb ff fc 	sub	r11,r9,-4
800092ac:	51 0b       	stdsp	sp[0x40],r11
800092ae:	72 09       	ld.w	r9,r9[0x0]
800092b0:	fa c6 f9 44 	sub	r6,sp,-1724
800092b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800092b8:	2f f8       	sub	r8,-1
800092ba:	f7 49 fd 88 	st.w	r11[-632],r9
800092be:	fb 48 06 b4 	st.w	sp[1716],r8
800092c2:	14 97       	mov	r7,r10
800092c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800092c8:	c0 58       	rjmp	800092d2 <_vfprintf_r+0x1482>
800092ca:	92 18       	ld.sh	r8,r9[0x2]
800092cc:	14 97       	mov	r7,r10
800092ce:	2f c9       	sub	r9,-4
800092d0:	51 09       	stdsp	sp[0x40],r9
800092d2:	5c 78       	castu.h	r8
800092d4:	50 18       	stdsp	sp[0x4],r8
800092d6:	c4 68       	rjmp	80009362 <_vfprintf_r+0x1512>
800092d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092dc:	40 3c       	lddsp	r12,sp[0xc]
800092de:	58 0c       	cp.w	r12,0
800092e0:	c1 d0       	breq	8000931a <_vfprintf_r+0x14ca>
800092e2:	10 36       	cp.w	r6,r8
800092e4:	c0 64       	brge	800092f0 <_vfprintf_r+0x14a0>
800092e6:	fa cb f9 44 	sub	r11,sp,-1724
800092ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ee:	c1 f8       	rjmp	8000932c <_vfprintf_r+0x14dc>
800092f0:	fa c8 f9 50 	sub	r8,sp,-1712
800092f4:	1a d8       	st.w	--sp,r8
800092f6:	fa c8 fa b8 	sub	r8,sp,-1352
800092fa:	0c 9b       	mov	r11,r6
800092fc:	1a d8       	st.w	--sp,r8
800092fe:	fa c8 fb b4 	sub	r8,sp,-1100
80009302:	04 9a       	mov	r10,r2
80009304:	1a d8       	st.w	--sp,r8
80009306:	08 9c       	mov	r12,r4
80009308:	fa c8 f9 40 	sub	r8,sp,-1728
8000930c:	fa c9 ff b4 	sub	r9,sp,-76
80009310:	fe b0 f4 08 	rcall	80007b20 <get_arg>
80009314:	2f dd       	sub	sp,-12
80009316:	78 0b       	ld.w	r11,r12[0x0]
80009318:	c2 48       	rjmp	80009360 <_vfprintf_r+0x1510>
8000931a:	ee ca ff ff 	sub	r10,r7,-1
8000931e:	10 37       	cp.w	r7,r8
80009320:	c0 94       	brge	80009332 <_vfprintf_r+0x14e2>
80009322:	fa c9 f9 44 	sub	r9,sp,-1724
80009326:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000932a:	14 97       	mov	r7,r10
8000932c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009330:	c1 88       	rjmp	80009360 <_vfprintf_r+0x1510>
80009332:	41 09       	lddsp	r9,sp[0x40]
80009334:	59 f8       	cp.w	r8,31
80009336:	e0 89 00 11 	brgt	80009358 <_vfprintf_r+0x1508>
8000933a:	f2 cb ff fc 	sub	r11,r9,-4
8000933e:	51 0b       	stdsp	sp[0x40],r11
80009340:	fa c6 f9 44 	sub	r6,sp,-1724
80009344:	72 0b       	ld.w	r11,r9[0x0]
80009346:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000934a:	f3 4b fd 88 	st.w	r9[-632],r11
8000934e:	2f f8       	sub	r8,-1
80009350:	14 97       	mov	r7,r10
80009352:	fb 48 06 b4 	st.w	sp[1716],r8
80009356:	c0 58       	rjmp	80009360 <_vfprintf_r+0x1510>
80009358:	72 0b       	ld.w	r11,r9[0x0]
8000935a:	14 97       	mov	r7,r10
8000935c:	2f c9       	sub	r9,-4
8000935e:	51 09       	stdsp	sp[0x40],r9
80009360:	50 1b       	stdsp	sp[0x4],r11
80009362:	30 0e       	mov	lr,0
80009364:	50 0e       	stdsp	sp[0x0],lr
80009366:	40 08       	lddsp	r8,sp[0x0]
80009368:	40 1c       	lddsp	r12,sp[0x4]
8000936a:	18 48       	or	r8,r12
8000936c:	5f 19       	srne	r9
8000936e:	0a 98       	mov	r8,r5
80009370:	eb e9 00 09 	and	r9,r5,r9
80009374:	a1 b8       	sbr	r8,0x1
80009376:	58 09       	cp.w	r9,0
80009378:	c0 70       	breq	80009386 <_vfprintf_r+0x1536>
8000937a:	10 95       	mov	r5,r8
8000937c:	fb 60 06 b9 	st.b	sp[1721],r0
80009380:	33 08       	mov	r8,48
80009382:	fb 68 06 b8 	st.b	sp[1720],r8
80009386:	30 28       	mov	r8,2
80009388:	30 09       	mov	r9,0
8000938a:	fb 69 06 bb 	st.b	sp[1723],r9
8000938e:	0a 99       	mov	r9,r5
80009390:	a7 d9       	cbr	r9,0x7
80009392:	40 2b       	lddsp	r11,sp[0x8]
80009394:	40 16       	lddsp	r6,sp[0x4]
80009396:	58 0b       	cp.w	r11,0
80009398:	5f 1a       	srne	r10
8000939a:	f2 05 17 40 	movge	r5,r9
8000939e:	fa c2 f9 78 	sub	r2,sp,-1672
800093a2:	40 09       	lddsp	r9,sp[0x0]
800093a4:	0c 49       	or	r9,r6
800093a6:	5f 19       	srne	r9
800093a8:	f5 e9 10 09 	or	r9,r10,r9
800093ac:	c5 c0       	breq	80009464 <_vfprintf_r+0x1614>
800093ae:	30 19       	mov	r9,1
800093b0:	f2 08 18 00 	cp.b	r8,r9
800093b4:	c0 60       	breq	800093c0 <_vfprintf_r+0x1570>
800093b6:	30 29       	mov	r9,2
800093b8:	f2 08 18 00 	cp.b	r8,r9
800093bc:	c0 41       	brne	800093c4 <_vfprintf_r+0x1574>
800093be:	c3 c8       	rjmp	80009436 <_vfprintf_r+0x15e6>
800093c0:	04 96       	mov	r6,r2
800093c2:	c3 08       	rjmp	80009422 <_vfprintf_r+0x15d2>
800093c4:	04 96       	mov	r6,r2
800093c6:	fa e8 00 00 	ld.d	r8,sp[0]
800093ca:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800093ce:	2d 0a       	sub	r10,-48
800093d0:	0c fa       	st.b	--r6,r10
800093d2:	f0 0b 16 03 	lsr	r11,r8,0x3
800093d6:	f2 0c 16 03 	lsr	r12,r9,0x3
800093da:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800093de:	18 99       	mov	r9,r12
800093e0:	16 98       	mov	r8,r11
800093e2:	58 08       	cp.w	r8,0
800093e4:	5c 29       	cpc	r9
800093e6:	cf 21       	brne	800093ca <_vfprintf_r+0x157a>
800093e8:	fa e9 00 00 	st.d	sp[0],r8
800093ec:	ed b5 00 00 	bld	r5,0x0
800093f0:	c4 51       	brne	8000947a <_vfprintf_r+0x162a>
800093f2:	33 09       	mov	r9,48
800093f4:	f2 0a 18 00 	cp.b	r10,r9
800093f8:	c4 10       	breq	8000947a <_vfprintf_r+0x162a>
800093fa:	0c f9       	st.b	--r6,r9
800093fc:	c3 f8       	rjmp	8000947a <_vfprintf_r+0x162a>
800093fe:	fa ea 00 00 	ld.d	r10,sp[0]
80009402:	30 a8       	mov	r8,10
80009404:	30 09       	mov	r9,0
80009406:	e0 a0 1a 19 	rcall	8000c838 <__avr32_umod64>
8000940a:	30 a8       	mov	r8,10
8000940c:	2d 0a       	sub	r10,-48
8000940e:	30 09       	mov	r9,0
80009410:	ac 8a       	st.b	r6[0x0],r10
80009412:	fa ea 00 00 	ld.d	r10,sp[0]
80009416:	e0 a0 18 df 	rcall	8000c5d4 <__avr32_udiv64>
8000941a:	16 99       	mov	r9,r11
8000941c:	14 98       	mov	r8,r10
8000941e:	fa e9 00 00 	st.d	sp[0],r8
80009422:	20 16       	sub	r6,1
80009424:	fa ea 00 00 	ld.d	r10,sp[0]
80009428:	58 9a       	cp.w	r10,9
8000942a:	5c 2b       	cpc	r11
8000942c:	fe 9b ff e9 	brhi	800093fe <_vfprintf_r+0x15ae>
80009430:	1b f8       	ld.ub	r8,sp[0x7]
80009432:	2d 08       	sub	r8,-48
80009434:	c2 08       	rjmp	80009474 <_vfprintf_r+0x1624>
80009436:	04 96       	mov	r6,r2
80009438:	fa e8 00 00 	ld.d	r8,sp[0]
8000943c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009440:	40 de       	lddsp	lr,sp[0x34]
80009442:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009446:	0c fa       	st.b	--r6,r10
80009448:	f2 0b 16 04 	lsr	r11,r9,0x4
8000944c:	f0 0a 16 04 	lsr	r10,r8,0x4
80009450:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009454:	16 99       	mov	r9,r11
80009456:	14 98       	mov	r8,r10
80009458:	58 08       	cp.w	r8,0
8000945a:	5c 29       	cpc	r9
8000945c:	cf 01       	brne	8000943c <_vfprintf_r+0x15ec>
8000945e:	fa e9 00 00 	st.d	sp[0],r8
80009462:	c0 c8       	rjmp	8000947a <_vfprintf_r+0x162a>
80009464:	58 08       	cp.w	r8,0
80009466:	c0 91       	brne	80009478 <_vfprintf_r+0x1628>
80009468:	ed b5 00 00 	bld	r5,0x0
8000946c:	c0 61       	brne	80009478 <_vfprintf_r+0x1628>
8000946e:	fa c6 f9 79 	sub	r6,sp,-1671
80009472:	33 08       	mov	r8,48
80009474:	ac 88       	st.b	r6[0x0],r8
80009476:	c0 28       	rjmp	8000947a <_vfprintf_r+0x162a>
80009478:	04 96       	mov	r6,r2
8000947a:	0c 12       	sub	r2,r6
8000947c:	c1 c8       	rjmp	800094b4 <_vfprintf_r+0x1664>
8000947e:	50 a7       	stdsp	sp[0x28],r7
80009480:	50 80       	stdsp	sp[0x20],r0
80009482:	40 93       	lddsp	r3,sp[0x24]
80009484:	0c 97       	mov	r7,r6
80009486:	10 90       	mov	r0,r8
80009488:	04 94       	mov	r4,r2
8000948a:	40 41       	lddsp	r1,sp[0x10]
8000948c:	58 08       	cp.w	r8,0
8000948e:	e0 80 04 4f 	breq	80009d2c <_vfprintf_r+0x1edc>
80009492:	fb 68 06 60 	st.b	sp[1632],r8
80009496:	30 0c       	mov	r12,0
80009498:	30 08       	mov	r8,0
8000949a:	30 12       	mov	r2,1
8000949c:	fb 68 06 bb 	st.b	sp[1723],r8
800094a0:	50 2c       	stdsp	sp[0x8],r12
800094a2:	fa c6 f9 a0 	sub	r6,sp,-1632
800094a6:	c0 78       	rjmp	800094b4 <_vfprintf_r+0x1664>
800094a8:	30 0b       	mov	r11,0
800094aa:	50 2b       	stdsp	sp[0x8],r11
800094ac:	c0 48       	rjmp	800094b4 <_vfprintf_r+0x1664>
800094ae:	40 22       	lddsp	r2,sp[0x8]
800094b0:	30 0a       	mov	r10,0
800094b2:	50 2a       	stdsp	sp[0x8],r10
800094b4:	40 29       	lddsp	r9,sp[0x8]
800094b6:	e4 09 0c 49 	max	r9,r2,r9
800094ba:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800094be:	50 39       	stdsp	sp[0xc],r9
800094c0:	0a 9e       	mov	lr,r5
800094c2:	30 09       	mov	r9,0
800094c4:	e2 1e 00 02 	andl	lr,0x2,COH
800094c8:	f2 08 18 00 	cp.b	r8,r9
800094cc:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800094d0:	f7 b8 01 ff 	subne	r8,-1
800094d4:	fb f8 1a 03 	st.wne	sp[0xc],r8
800094d8:	0a 9b       	mov	r11,r5
800094da:	58 0e       	cp.w	lr,0
800094dc:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800094e0:	f7 bc 01 fe 	subne	r12,-2
800094e4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800094e8:	e2 1b 00 84 	andl	r11,0x84,COH
800094ec:	50 fe       	stdsp	sp[0x3c],lr
800094ee:	50 9b       	stdsp	sp[0x24],r11
800094f0:	c4 71       	brne	8000957e <_vfprintf_r+0x172e>
800094f2:	40 8a       	lddsp	r10,sp[0x20]
800094f4:	40 39       	lddsp	r9,sp[0xc]
800094f6:	12 1a       	sub	r10,r9
800094f8:	50 4a       	stdsp	sp[0x10],r10
800094fa:	58 0a       	cp.w	r10,0
800094fc:	e0 89 00 20 	brgt	8000953c <_vfprintf_r+0x16ec>
80009500:	c3 f8       	rjmp	8000957e <_vfprintf_r+0x172e>
80009502:	2f 09       	sub	r9,-16
80009504:	2f f8       	sub	r8,-1
80009506:	fe ce b7 8a 	sub	lr,pc,-18550
8000950a:	31 0c       	mov	r12,16
8000950c:	fb 49 06 90 	st.w	sp[1680],r9
80009510:	87 0e       	st.w	r3[0x0],lr
80009512:	87 1c       	st.w	r3[0x4],r12
80009514:	fb 48 06 8c 	st.w	sp[1676],r8
80009518:	58 78       	cp.w	r8,7
8000951a:	e0 89 00 04 	brgt	80009522 <_vfprintf_r+0x16d2>
8000951e:	2f 83       	sub	r3,-8
80009520:	c0 b8       	rjmp	80009536 <_vfprintf_r+0x16e6>
80009522:	fa ca f9 78 	sub	r10,sp,-1672
80009526:	02 9b       	mov	r11,r1
80009528:	08 9c       	mov	r12,r4
8000952a:	fe b0 f4 85 	rcall	80007e34 <__sprint_r>
8000952e:	e0 81 04 10 	brne	80009d4e <_vfprintf_r+0x1efe>
80009532:	fa c3 f9 e0 	sub	r3,sp,-1568
80009536:	40 4b       	lddsp	r11,sp[0x10]
80009538:	21 0b       	sub	r11,16
8000953a:	50 4b       	stdsp	sp[0x10],r11
8000953c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009540:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009544:	fe ca b7 c8 	sub	r10,pc,-18488
80009548:	40 4e       	lddsp	lr,sp[0x10]
8000954a:	59 0e       	cp.w	lr,16
8000954c:	fe 99 ff db 	brgt	80009502 <_vfprintf_r+0x16b2>
80009550:	1c 09       	add	r9,lr
80009552:	2f f8       	sub	r8,-1
80009554:	87 0a       	st.w	r3[0x0],r10
80009556:	fb 49 06 90 	st.w	sp[1680],r9
8000955a:	87 1e       	st.w	r3[0x4],lr
8000955c:	fb 48 06 8c 	st.w	sp[1676],r8
80009560:	58 78       	cp.w	r8,7
80009562:	e0 89 00 04 	brgt	8000956a <_vfprintf_r+0x171a>
80009566:	2f 83       	sub	r3,-8
80009568:	c0 b8       	rjmp	8000957e <_vfprintf_r+0x172e>
8000956a:	fa ca f9 78 	sub	r10,sp,-1672
8000956e:	02 9b       	mov	r11,r1
80009570:	08 9c       	mov	r12,r4
80009572:	fe b0 f4 61 	rcall	80007e34 <__sprint_r>
80009576:	e0 81 03 ec 	brne	80009d4e <_vfprintf_r+0x1efe>
8000957a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000957e:	30 09       	mov	r9,0
80009580:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009584:	f2 08 18 00 	cp.b	r8,r9
80009588:	c1 f0       	breq	800095c6 <_vfprintf_r+0x1776>
8000958a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000958e:	fa c9 f9 45 	sub	r9,sp,-1723
80009592:	2f f8       	sub	r8,-1
80009594:	87 09       	st.w	r3[0x0],r9
80009596:	fb 48 06 90 	st.w	sp[1680],r8
8000959a:	30 19       	mov	r9,1
8000959c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095a0:	87 19       	st.w	r3[0x4],r9
800095a2:	2f f8       	sub	r8,-1
800095a4:	fb 48 06 8c 	st.w	sp[1676],r8
800095a8:	58 78       	cp.w	r8,7
800095aa:	e0 89 00 04 	brgt	800095b2 <_vfprintf_r+0x1762>
800095ae:	2f 83       	sub	r3,-8
800095b0:	c0 b8       	rjmp	800095c6 <_vfprintf_r+0x1776>
800095b2:	fa ca f9 78 	sub	r10,sp,-1672
800095b6:	02 9b       	mov	r11,r1
800095b8:	08 9c       	mov	r12,r4
800095ba:	fe b0 f4 3d 	rcall	80007e34 <__sprint_r>
800095be:	e0 81 03 c8 	brne	80009d4e <_vfprintf_r+0x1efe>
800095c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800095c6:	40 fc       	lddsp	r12,sp[0x3c]
800095c8:	58 0c       	cp.w	r12,0
800095ca:	c1 f0       	breq	80009608 <_vfprintf_r+0x17b8>
800095cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800095d0:	fa c9 f9 48 	sub	r9,sp,-1720
800095d4:	2f e8       	sub	r8,-2
800095d6:	87 09       	st.w	r3[0x0],r9
800095d8:	fb 48 06 90 	st.w	sp[1680],r8
800095dc:	30 29       	mov	r9,2
800095de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095e2:	87 19       	st.w	r3[0x4],r9
800095e4:	2f f8       	sub	r8,-1
800095e6:	fb 48 06 8c 	st.w	sp[1676],r8
800095ea:	58 78       	cp.w	r8,7
800095ec:	e0 89 00 04 	brgt	800095f4 <_vfprintf_r+0x17a4>
800095f0:	2f 83       	sub	r3,-8
800095f2:	c0 b8       	rjmp	80009608 <_vfprintf_r+0x17b8>
800095f4:	fa ca f9 78 	sub	r10,sp,-1672
800095f8:	02 9b       	mov	r11,r1
800095fa:	08 9c       	mov	r12,r4
800095fc:	fe b0 f4 1c 	rcall	80007e34 <__sprint_r>
80009600:	e0 81 03 a7 	brne	80009d4e <_vfprintf_r+0x1efe>
80009604:	fa c3 f9 e0 	sub	r3,sp,-1568
80009608:	40 9b       	lddsp	r11,sp[0x24]
8000960a:	e0 4b 00 80 	cp.w	r11,128
8000960e:	c4 71       	brne	8000969c <_vfprintf_r+0x184c>
80009610:	40 8a       	lddsp	r10,sp[0x20]
80009612:	40 39       	lddsp	r9,sp[0xc]
80009614:	12 1a       	sub	r10,r9
80009616:	50 4a       	stdsp	sp[0x10],r10
80009618:	58 0a       	cp.w	r10,0
8000961a:	e0 89 00 20 	brgt	8000965a <_vfprintf_r+0x180a>
8000961e:	c3 f8       	rjmp	8000969c <_vfprintf_r+0x184c>
80009620:	2f 09       	sub	r9,-16
80009622:	2f f8       	sub	r8,-1
80009624:	fe ce b8 98 	sub	lr,pc,-18280
80009628:	31 0c       	mov	r12,16
8000962a:	fb 49 06 90 	st.w	sp[1680],r9
8000962e:	87 0e       	st.w	r3[0x0],lr
80009630:	87 1c       	st.w	r3[0x4],r12
80009632:	fb 48 06 8c 	st.w	sp[1676],r8
80009636:	58 78       	cp.w	r8,7
80009638:	e0 89 00 04 	brgt	80009640 <_vfprintf_r+0x17f0>
8000963c:	2f 83       	sub	r3,-8
8000963e:	c0 b8       	rjmp	80009654 <_vfprintf_r+0x1804>
80009640:	fa ca f9 78 	sub	r10,sp,-1672
80009644:	02 9b       	mov	r11,r1
80009646:	08 9c       	mov	r12,r4
80009648:	fe b0 f3 f6 	rcall	80007e34 <__sprint_r>
8000964c:	e0 81 03 81 	brne	80009d4e <_vfprintf_r+0x1efe>
80009650:	fa c3 f9 e0 	sub	r3,sp,-1568
80009654:	40 4b       	lddsp	r11,sp[0x10]
80009656:	21 0b       	sub	r11,16
80009658:	50 4b       	stdsp	sp[0x10],r11
8000965a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000965e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009662:	fe ca b8 d6 	sub	r10,pc,-18218
80009666:	40 4e       	lddsp	lr,sp[0x10]
80009668:	59 0e       	cp.w	lr,16
8000966a:	fe 99 ff db 	brgt	80009620 <_vfprintf_r+0x17d0>
8000966e:	1c 09       	add	r9,lr
80009670:	2f f8       	sub	r8,-1
80009672:	87 0a       	st.w	r3[0x0],r10
80009674:	fb 49 06 90 	st.w	sp[1680],r9
80009678:	87 1e       	st.w	r3[0x4],lr
8000967a:	fb 48 06 8c 	st.w	sp[1676],r8
8000967e:	58 78       	cp.w	r8,7
80009680:	e0 89 00 04 	brgt	80009688 <_vfprintf_r+0x1838>
80009684:	2f 83       	sub	r3,-8
80009686:	c0 b8       	rjmp	8000969c <_vfprintf_r+0x184c>
80009688:	fa ca f9 78 	sub	r10,sp,-1672
8000968c:	02 9b       	mov	r11,r1
8000968e:	08 9c       	mov	r12,r4
80009690:	fe b0 f3 d2 	rcall	80007e34 <__sprint_r>
80009694:	e0 81 03 5d 	brne	80009d4e <_vfprintf_r+0x1efe>
80009698:	fa c3 f9 e0 	sub	r3,sp,-1568
8000969c:	40 2c       	lddsp	r12,sp[0x8]
8000969e:	04 1c       	sub	r12,r2
800096a0:	50 2c       	stdsp	sp[0x8],r12
800096a2:	58 0c       	cp.w	r12,0
800096a4:	e0 89 00 20 	brgt	800096e4 <_vfprintf_r+0x1894>
800096a8:	c3 f8       	rjmp	80009726 <_vfprintf_r+0x18d6>
800096aa:	2f 09       	sub	r9,-16
800096ac:	2f f8       	sub	r8,-1
800096ae:	fe cb b9 22 	sub	r11,pc,-18142
800096b2:	31 0a       	mov	r10,16
800096b4:	fb 49 06 90 	st.w	sp[1680],r9
800096b8:	87 0b       	st.w	r3[0x0],r11
800096ba:	87 1a       	st.w	r3[0x4],r10
800096bc:	fb 48 06 8c 	st.w	sp[1676],r8
800096c0:	58 78       	cp.w	r8,7
800096c2:	e0 89 00 04 	brgt	800096ca <_vfprintf_r+0x187a>
800096c6:	2f 83       	sub	r3,-8
800096c8:	c0 b8       	rjmp	800096de <_vfprintf_r+0x188e>
800096ca:	fa ca f9 78 	sub	r10,sp,-1672
800096ce:	02 9b       	mov	r11,r1
800096d0:	08 9c       	mov	r12,r4
800096d2:	fe b0 f3 b1 	rcall	80007e34 <__sprint_r>
800096d6:	e0 81 03 3c 	brne	80009d4e <_vfprintf_r+0x1efe>
800096da:	fa c3 f9 e0 	sub	r3,sp,-1568
800096de:	40 29       	lddsp	r9,sp[0x8]
800096e0:	21 09       	sub	r9,16
800096e2:	50 29       	stdsp	sp[0x8],r9
800096e4:	fa f9 06 90 	ld.w	r9,sp[1680]
800096e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096ec:	fe ca b9 60 	sub	r10,pc,-18080
800096f0:	40 2e       	lddsp	lr,sp[0x8]
800096f2:	59 0e       	cp.w	lr,16
800096f4:	fe 99 ff db 	brgt	800096aa <_vfprintf_r+0x185a>
800096f8:	1c 09       	add	r9,lr
800096fa:	2f f8       	sub	r8,-1
800096fc:	87 0a       	st.w	r3[0x0],r10
800096fe:	fb 49 06 90 	st.w	sp[1680],r9
80009702:	87 1e       	st.w	r3[0x4],lr
80009704:	fb 48 06 8c 	st.w	sp[1676],r8
80009708:	58 78       	cp.w	r8,7
8000970a:	e0 89 00 04 	brgt	80009712 <_vfprintf_r+0x18c2>
8000970e:	2f 83       	sub	r3,-8
80009710:	c0 b8       	rjmp	80009726 <_vfprintf_r+0x18d6>
80009712:	fa ca f9 78 	sub	r10,sp,-1672
80009716:	02 9b       	mov	r11,r1
80009718:	08 9c       	mov	r12,r4
8000971a:	fe b0 f3 8d 	rcall	80007e34 <__sprint_r>
8000971e:	e0 81 03 18 	brne	80009d4e <_vfprintf_r+0x1efe>
80009722:	fa c3 f9 e0 	sub	r3,sp,-1568
80009726:	ed b5 00 08 	bld	r5,0x8
8000972a:	c0 b0       	breq	80009740 <_vfprintf_r+0x18f0>
8000972c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009730:	87 12       	st.w	r3[0x4],r2
80009732:	87 06       	st.w	r3[0x0],r6
80009734:	f0 02 00 02 	add	r2,r8,r2
80009738:	fb 42 06 90 	st.w	sp[1680],r2
8000973c:	e0 8f 01 d4 	bral	80009ae4 <_vfprintf_r+0x1c94>
80009740:	e0 40 00 65 	cp.w	r0,101
80009744:	e0 8a 01 d6 	brle	80009af0 <_vfprintf_r+0x1ca0>
80009748:	30 08       	mov	r8,0
8000974a:	30 09       	mov	r9,0
8000974c:	40 5b       	lddsp	r11,sp[0x14]
8000974e:	40 7a       	lddsp	r10,sp[0x1c]
80009750:	e0 a0 15 3b 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
80009754:	c7 90       	breq	80009846 <_vfprintf_r+0x19f6>
80009756:	fa f8 06 90 	ld.w	r8,sp[1680]
8000975a:	fe c9 b9 e2 	sub	r9,pc,-17950
8000975e:	2f f8       	sub	r8,-1
80009760:	87 09       	st.w	r3[0x0],r9
80009762:	fb 48 06 90 	st.w	sp[1680],r8
80009766:	30 19       	mov	r9,1
80009768:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000976c:	87 19       	st.w	r3[0x4],r9
8000976e:	2f f8       	sub	r8,-1
80009770:	fb 48 06 8c 	st.w	sp[1676],r8
80009774:	58 78       	cp.w	r8,7
80009776:	e0 89 00 05 	brgt	80009780 <_vfprintf_r+0x1930>
8000977a:	2f 83       	sub	r3,-8
8000977c:	c0 c8       	rjmp	80009794 <_vfprintf_r+0x1944>
8000977e:	d7 03       	nop
80009780:	fa ca f9 78 	sub	r10,sp,-1672
80009784:	02 9b       	mov	r11,r1
80009786:	08 9c       	mov	r12,r4
80009788:	fe b0 f3 56 	rcall	80007e34 <__sprint_r>
8000978c:	e0 81 02 e1 	brne	80009d4e <_vfprintf_r+0x1efe>
80009790:	fa c3 f9 e0 	sub	r3,sp,-1568
80009794:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009798:	40 6c       	lddsp	r12,sp[0x18]
8000979a:	18 38       	cp.w	r8,r12
8000979c:	c0 55       	brlt	800097a6 <_vfprintf_r+0x1956>
8000979e:	ed b5 00 00 	bld	r5,0x0
800097a2:	e0 81 02 6b 	brne	80009c78 <_vfprintf_r+0x1e28>
800097a6:	fa f8 06 90 	ld.w	r8,sp[1680]
800097aa:	2f f8       	sub	r8,-1
800097ac:	40 cb       	lddsp	r11,sp[0x30]
800097ae:	fb 48 06 90 	st.w	sp[1680],r8
800097b2:	30 19       	mov	r9,1
800097b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097b8:	87 0b       	st.w	r3[0x0],r11
800097ba:	2f f8       	sub	r8,-1
800097bc:	87 19       	st.w	r3[0x4],r9
800097be:	fb 48 06 8c 	st.w	sp[1676],r8
800097c2:	58 78       	cp.w	r8,7
800097c4:	e0 89 00 04 	brgt	800097cc <_vfprintf_r+0x197c>
800097c8:	2f 83       	sub	r3,-8
800097ca:	c0 b8       	rjmp	800097e0 <_vfprintf_r+0x1990>
800097cc:	fa ca f9 78 	sub	r10,sp,-1672
800097d0:	02 9b       	mov	r11,r1
800097d2:	08 9c       	mov	r12,r4
800097d4:	fe b0 f3 30 	rcall	80007e34 <__sprint_r>
800097d8:	e0 81 02 bb 	brne	80009d4e <_vfprintf_r+0x1efe>
800097dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e0:	40 66       	lddsp	r6,sp[0x18]
800097e2:	20 16       	sub	r6,1
800097e4:	58 06       	cp.w	r6,0
800097e6:	e0 89 00 1d 	brgt	80009820 <_vfprintf_r+0x19d0>
800097ea:	e0 8f 02 47 	bral	80009c78 <_vfprintf_r+0x1e28>
800097ee:	2f 09       	sub	r9,-16
800097f0:	2f f8       	sub	r8,-1
800097f2:	fb 49 06 90 	st.w	sp[1680],r9
800097f6:	87 02       	st.w	r3[0x0],r2
800097f8:	87 10       	st.w	r3[0x4],r0
800097fa:	fb 48 06 8c 	st.w	sp[1676],r8
800097fe:	58 78       	cp.w	r8,7
80009800:	e0 89 00 04 	brgt	80009808 <_vfprintf_r+0x19b8>
80009804:	2f 83       	sub	r3,-8
80009806:	c0 b8       	rjmp	8000981c <_vfprintf_r+0x19cc>
80009808:	fa ca f9 78 	sub	r10,sp,-1672
8000980c:	02 9b       	mov	r11,r1
8000980e:	08 9c       	mov	r12,r4
80009810:	fe b0 f3 12 	rcall	80007e34 <__sprint_r>
80009814:	e0 81 02 9d 	brne	80009d4e <_vfprintf_r+0x1efe>
80009818:	fa c3 f9 e0 	sub	r3,sp,-1568
8000981c:	21 06       	sub	r6,16
8000981e:	c0 48       	rjmp	80009826 <_vfprintf_r+0x19d6>
80009820:	fe c2 ba 94 	sub	r2,pc,-17772
80009824:	31 00       	mov	r0,16
80009826:	fa f9 06 90 	ld.w	r9,sp[1680]
8000982a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000982e:	fe ca ba a2 	sub	r10,pc,-17758
80009832:	59 06       	cp.w	r6,16
80009834:	fe 99 ff dd 	brgt	800097ee <_vfprintf_r+0x199e>
80009838:	0c 09       	add	r9,r6
8000983a:	87 0a       	st.w	r3[0x0],r10
8000983c:	fb 49 06 90 	st.w	sp[1680],r9
80009840:	2f f8       	sub	r8,-1
80009842:	87 16       	st.w	r3[0x4],r6
80009844:	c5 39       	rjmp	80009aea <_vfprintf_r+0x1c9a>
80009846:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000984a:	58 0a       	cp.w	r10,0
8000984c:	e0 89 00 92 	brgt	80009970 <_vfprintf_r+0x1b20>
80009850:	fa f8 06 90 	ld.w	r8,sp[1680]
80009854:	fe c9 ba dc 	sub	r9,pc,-17700
80009858:	2f f8       	sub	r8,-1
8000985a:	87 09       	st.w	r3[0x0],r9
8000985c:	fb 48 06 90 	st.w	sp[1680],r8
80009860:	30 19       	mov	r9,1
80009862:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009866:	87 19       	st.w	r3[0x4],r9
80009868:	2f f8       	sub	r8,-1
8000986a:	fb 48 06 8c 	st.w	sp[1676],r8
8000986e:	58 78       	cp.w	r8,7
80009870:	e0 89 00 04 	brgt	80009878 <_vfprintf_r+0x1a28>
80009874:	2f 83       	sub	r3,-8
80009876:	c0 b8       	rjmp	8000988c <_vfprintf_r+0x1a3c>
80009878:	fa ca f9 78 	sub	r10,sp,-1672
8000987c:	02 9b       	mov	r11,r1
8000987e:	08 9c       	mov	r12,r4
80009880:	fe b0 f2 da 	rcall	80007e34 <__sprint_r>
80009884:	e0 81 02 65 	brne	80009d4e <_vfprintf_r+0x1efe>
80009888:	fa c3 f9 e0 	sub	r3,sp,-1568
8000988c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009890:	58 08       	cp.w	r8,0
80009892:	c0 81       	brne	800098a2 <_vfprintf_r+0x1a52>
80009894:	40 6a       	lddsp	r10,sp[0x18]
80009896:	58 0a       	cp.w	r10,0
80009898:	c0 51       	brne	800098a2 <_vfprintf_r+0x1a52>
8000989a:	ed b5 00 00 	bld	r5,0x0
8000989e:	e0 81 01 ed 	brne	80009c78 <_vfprintf_r+0x1e28>
800098a2:	40 c9       	lddsp	r9,sp[0x30]
800098a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800098a8:	2f f8       	sub	r8,-1
800098aa:	87 09       	st.w	r3[0x0],r9
800098ac:	fb 48 06 90 	st.w	sp[1680],r8
800098b0:	30 19       	mov	r9,1
800098b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098b6:	87 19       	st.w	r3[0x4],r9
800098b8:	2f f8       	sub	r8,-1
800098ba:	fb 48 06 8c 	st.w	sp[1676],r8
800098be:	58 78       	cp.w	r8,7
800098c0:	e0 89 00 04 	brgt	800098c8 <_vfprintf_r+0x1a78>
800098c4:	2f 83       	sub	r3,-8
800098c6:	c0 b8       	rjmp	800098dc <_vfprintf_r+0x1a8c>
800098c8:	fa ca f9 78 	sub	r10,sp,-1672
800098cc:	02 9b       	mov	r11,r1
800098ce:	08 9c       	mov	r12,r4
800098d0:	fe b0 f2 b2 	rcall	80007e34 <__sprint_r>
800098d4:	e0 81 02 3d 	brne	80009d4e <_vfprintf_r+0x1efe>
800098d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098dc:	fa f2 06 ac 	ld.w	r2,sp[1708]
800098e0:	5c 32       	neg	r2
800098e2:	58 02       	cp.w	r2,0
800098e4:	e0 89 00 1d 	brgt	8000991e <_vfprintf_r+0x1ace>
800098e8:	c3 d8       	rjmp	80009962 <_vfprintf_r+0x1b12>
800098ea:	2f 09       	sub	r9,-16
800098ec:	2f f8       	sub	r8,-1
800098ee:	31 0e       	mov	lr,16
800098f0:	fb 49 06 90 	st.w	sp[1680],r9
800098f4:	87 00       	st.w	r3[0x0],r0
800098f6:	87 1e       	st.w	r3[0x4],lr
800098f8:	fb 48 06 8c 	st.w	sp[1676],r8
800098fc:	58 78       	cp.w	r8,7
800098fe:	e0 89 00 04 	brgt	80009906 <_vfprintf_r+0x1ab6>
80009902:	2f 83       	sub	r3,-8
80009904:	c0 b8       	rjmp	8000991a <_vfprintf_r+0x1aca>
80009906:	fa ca f9 78 	sub	r10,sp,-1672
8000990a:	02 9b       	mov	r11,r1
8000990c:	08 9c       	mov	r12,r4
8000990e:	fe b0 f2 93 	rcall	80007e34 <__sprint_r>
80009912:	e0 81 02 1e 	brne	80009d4e <_vfprintf_r+0x1efe>
80009916:	fa c3 f9 e0 	sub	r3,sp,-1568
8000991a:	21 02       	sub	r2,16
8000991c:	c0 38       	rjmp	80009922 <_vfprintf_r+0x1ad2>
8000991e:	fe c0 bb 92 	sub	r0,pc,-17518
80009922:	fa f9 06 90 	ld.w	r9,sp[1680]
80009926:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000992a:	fe ca bb 9e 	sub	r10,pc,-17506
8000992e:	59 02       	cp.w	r2,16
80009930:	fe 99 ff dd 	brgt	800098ea <_vfprintf_r+0x1a9a>
80009934:	04 09       	add	r9,r2
80009936:	2f f8       	sub	r8,-1
80009938:	87 0a       	st.w	r3[0x0],r10
8000993a:	fb 49 06 90 	st.w	sp[1680],r9
8000993e:	87 12       	st.w	r3[0x4],r2
80009940:	fb 48 06 8c 	st.w	sp[1676],r8
80009944:	58 78       	cp.w	r8,7
80009946:	e0 89 00 04 	brgt	8000994e <_vfprintf_r+0x1afe>
8000994a:	2f 83       	sub	r3,-8
8000994c:	c0 b8       	rjmp	80009962 <_vfprintf_r+0x1b12>
8000994e:	fa ca f9 78 	sub	r10,sp,-1672
80009952:	02 9b       	mov	r11,r1
80009954:	08 9c       	mov	r12,r4
80009956:	fe b0 f2 6f 	rcall	80007e34 <__sprint_r>
8000995a:	e0 81 01 fa 	brne	80009d4e <_vfprintf_r+0x1efe>
8000995e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009962:	40 6c       	lddsp	r12,sp[0x18]
80009964:	fa f8 06 90 	ld.w	r8,sp[1680]
80009968:	87 06       	st.w	r3[0x0],r6
8000996a:	87 1c       	st.w	r3[0x4],r12
8000996c:	18 08       	add	r8,r12
8000996e:	cb 98       	rjmp	80009ae0 <_vfprintf_r+0x1c90>
80009970:	fa f9 06 90 	ld.w	r9,sp[1680]
80009974:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009978:	40 6b       	lddsp	r11,sp[0x18]
8000997a:	16 3a       	cp.w	r10,r11
8000997c:	c6 f5       	brlt	80009a5a <_vfprintf_r+0x1c0a>
8000997e:	16 09       	add	r9,r11
80009980:	2f f8       	sub	r8,-1
80009982:	87 06       	st.w	r3[0x0],r6
80009984:	fb 49 06 90 	st.w	sp[1680],r9
80009988:	87 1b       	st.w	r3[0x4],r11
8000998a:	fb 48 06 8c 	st.w	sp[1676],r8
8000998e:	58 78       	cp.w	r8,7
80009990:	e0 89 00 04 	brgt	80009998 <_vfprintf_r+0x1b48>
80009994:	2f 83       	sub	r3,-8
80009996:	c0 b8       	rjmp	800099ac <_vfprintf_r+0x1b5c>
80009998:	fa ca f9 78 	sub	r10,sp,-1672
8000999c:	02 9b       	mov	r11,r1
8000999e:	08 9c       	mov	r12,r4
800099a0:	fe b0 f2 4a 	rcall	80007e34 <__sprint_r>
800099a4:	e0 81 01 d5 	brne	80009d4e <_vfprintf_r+0x1efe>
800099a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ac:	fa f6 06 ac 	ld.w	r6,sp[1708]
800099b0:	40 6a       	lddsp	r10,sp[0x18]
800099b2:	14 16       	sub	r6,r10
800099b4:	58 06       	cp.w	r6,0
800099b6:	e0 89 00 1c 	brgt	800099ee <_vfprintf_r+0x1b9e>
800099ba:	c3 d8       	rjmp	80009a34 <_vfprintf_r+0x1be4>
800099bc:	2f 09       	sub	r9,-16
800099be:	2f f8       	sub	r8,-1
800099c0:	fb 49 06 90 	st.w	sp[1680],r9
800099c4:	87 02       	st.w	r3[0x0],r2
800099c6:	87 10       	st.w	r3[0x4],r0
800099c8:	fb 48 06 8c 	st.w	sp[1676],r8
800099cc:	58 78       	cp.w	r8,7
800099ce:	e0 89 00 04 	brgt	800099d6 <_vfprintf_r+0x1b86>
800099d2:	2f 83       	sub	r3,-8
800099d4:	c0 b8       	rjmp	800099ea <_vfprintf_r+0x1b9a>
800099d6:	fa ca f9 78 	sub	r10,sp,-1672
800099da:	02 9b       	mov	r11,r1
800099dc:	08 9c       	mov	r12,r4
800099de:	fe b0 f2 2b 	rcall	80007e34 <__sprint_r>
800099e2:	e0 81 01 b6 	brne	80009d4e <_vfprintf_r+0x1efe>
800099e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ea:	21 06       	sub	r6,16
800099ec:	c0 48       	rjmp	800099f4 <_vfprintf_r+0x1ba4>
800099ee:	fe c2 bc 62 	sub	r2,pc,-17310
800099f2:	31 00       	mov	r0,16
800099f4:	fa f9 06 90 	ld.w	r9,sp[1680]
800099f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099fc:	fe ca bc 70 	sub	r10,pc,-17296
80009a00:	59 06       	cp.w	r6,16
80009a02:	fe 99 ff dd 	brgt	800099bc <_vfprintf_r+0x1b6c>
80009a06:	0c 09       	add	r9,r6
80009a08:	2f f8       	sub	r8,-1
80009a0a:	87 0a       	st.w	r3[0x0],r10
80009a0c:	fb 49 06 90 	st.w	sp[1680],r9
80009a10:	87 16       	st.w	r3[0x4],r6
80009a12:	fb 48 06 8c 	st.w	sp[1676],r8
80009a16:	58 78       	cp.w	r8,7
80009a18:	e0 89 00 04 	brgt	80009a20 <_vfprintf_r+0x1bd0>
80009a1c:	2f 83       	sub	r3,-8
80009a1e:	c0 b8       	rjmp	80009a34 <_vfprintf_r+0x1be4>
80009a20:	fa ca f9 78 	sub	r10,sp,-1672
80009a24:	02 9b       	mov	r11,r1
80009a26:	08 9c       	mov	r12,r4
80009a28:	fe b0 f2 06 	rcall	80007e34 <__sprint_r>
80009a2c:	e0 81 01 91 	brne	80009d4e <_vfprintf_r+0x1efe>
80009a30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a34:	ed b5 00 00 	bld	r5,0x0
80009a38:	e0 81 01 20 	brne	80009c78 <_vfprintf_r+0x1e28>
80009a3c:	40 c9       	lddsp	r9,sp[0x30]
80009a3e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a42:	2f f8       	sub	r8,-1
80009a44:	87 09       	st.w	r3[0x0],r9
80009a46:	fb 48 06 90 	st.w	sp[1680],r8
80009a4a:	30 19       	mov	r9,1
80009a4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a50:	87 19       	st.w	r3[0x4],r9
80009a52:	2f f8       	sub	r8,-1
80009a54:	fb 48 06 8c 	st.w	sp[1676],r8
80009a58:	c0 29       	rjmp	80009c5c <_vfprintf_r+0x1e0c>
80009a5a:	14 09       	add	r9,r10
80009a5c:	2f f8       	sub	r8,-1
80009a5e:	fb 49 06 90 	st.w	sp[1680],r9
80009a62:	87 06       	st.w	r3[0x0],r6
80009a64:	87 1a       	st.w	r3[0x4],r10
80009a66:	fb 48 06 8c 	st.w	sp[1676],r8
80009a6a:	58 78       	cp.w	r8,7
80009a6c:	e0 89 00 04 	brgt	80009a74 <_vfprintf_r+0x1c24>
80009a70:	2f 83       	sub	r3,-8
80009a72:	c0 b8       	rjmp	80009a88 <_vfprintf_r+0x1c38>
80009a74:	fa ca f9 78 	sub	r10,sp,-1672
80009a78:	02 9b       	mov	r11,r1
80009a7a:	08 9c       	mov	r12,r4
80009a7c:	fe b0 f1 dc 	rcall	80007e34 <__sprint_r>
80009a80:	e0 81 01 67 	brne	80009d4e <_vfprintf_r+0x1efe>
80009a84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a88:	40 c8       	lddsp	r8,sp[0x30]
80009a8a:	87 08       	st.w	r3[0x0],r8
80009a8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a90:	2f f8       	sub	r8,-1
80009a92:	30 19       	mov	r9,1
80009a94:	fb 48 06 90 	st.w	sp[1680],r8
80009a98:	87 19       	st.w	r3[0x4],r9
80009a9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a9e:	2f f8       	sub	r8,-1
80009aa0:	fb 48 06 8c 	st.w	sp[1676],r8
80009aa4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009aa8:	58 78       	cp.w	r8,7
80009aaa:	e0 89 00 04 	brgt	80009ab2 <_vfprintf_r+0x1c62>
80009aae:	2f 83       	sub	r3,-8
80009ab0:	c0 b8       	rjmp	80009ac6 <_vfprintf_r+0x1c76>
80009ab2:	fa ca f9 78 	sub	r10,sp,-1672
80009ab6:	02 9b       	mov	r11,r1
80009ab8:	08 9c       	mov	r12,r4
80009aba:	fe b0 f1 bd 	rcall	80007e34 <__sprint_r>
80009abe:	e0 81 01 48 	brne	80009d4e <_vfprintf_r+0x1efe>
80009ac2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ac6:	04 06       	add	r6,r2
80009ac8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009acc:	87 06       	st.w	r3[0x0],r6
80009ace:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ad2:	40 66       	lddsp	r6,sp[0x18]
80009ad4:	40 6e       	lddsp	lr,sp[0x18]
80009ad6:	10 16       	sub	r6,r8
80009ad8:	f2 08 01 08 	sub	r8,r9,r8
80009adc:	87 16       	st.w	r3[0x4],r6
80009ade:	1c 08       	add	r8,lr
80009ae0:	fb 48 06 90 	st.w	sp[1680],r8
80009ae4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ae8:	2f f8       	sub	r8,-1
80009aea:	fb 48 06 8c 	st.w	sp[1676],r8
80009aee:	cb 78       	rjmp	80009c5c <_vfprintf_r+0x1e0c>
80009af0:	40 6c       	lddsp	r12,sp[0x18]
80009af2:	58 1c       	cp.w	r12,1
80009af4:	e0 89 00 06 	brgt	80009b00 <_vfprintf_r+0x1cb0>
80009af8:	ed b5 00 00 	bld	r5,0x0
80009afc:	e0 81 00 85 	brne	80009c06 <_vfprintf_r+0x1db6>
80009b00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b04:	2f f8       	sub	r8,-1
80009b06:	30 19       	mov	r9,1
80009b08:	fb 48 06 90 	st.w	sp[1680],r8
80009b0c:	87 06       	st.w	r3[0x0],r6
80009b0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b12:	87 19       	st.w	r3[0x4],r9
80009b14:	2f f8       	sub	r8,-1
80009b16:	fb 48 06 8c 	st.w	sp[1676],r8
80009b1a:	58 78       	cp.w	r8,7
80009b1c:	e0 89 00 04 	brgt	80009b24 <_vfprintf_r+0x1cd4>
80009b20:	2f 83       	sub	r3,-8
80009b22:	c0 b8       	rjmp	80009b38 <_vfprintf_r+0x1ce8>
80009b24:	fa ca f9 78 	sub	r10,sp,-1672
80009b28:	02 9b       	mov	r11,r1
80009b2a:	08 9c       	mov	r12,r4
80009b2c:	fe b0 f1 84 	rcall	80007e34 <__sprint_r>
80009b30:	e0 81 01 0f 	brne	80009d4e <_vfprintf_r+0x1efe>
80009b34:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b3c:	2f f8       	sub	r8,-1
80009b3e:	40 cb       	lddsp	r11,sp[0x30]
80009b40:	fb 48 06 90 	st.w	sp[1680],r8
80009b44:	30 19       	mov	r9,1
80009b46:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b4a:	87 0b       	st.w	r3[0x0],r11
80009b4c:	2f f8       	sub	r8,-1
80009b4e:	87 19       	st.w	r3[0x4],r9
80009b50:	fb 48 06 8c 	st.w	sp[1676],r8
80009b54:	58 78       	cp.w	r8,7
80009b56:	e0 89 00 05 	brgt	80009b60 <_vfprintf_r+0x1d10>
80009b5a:	2f 83       	sub	r3,-8
80009b5c:	c0 c8       	rjmp	80009b74 <_vfprintf_r+0x1d24>
80009b5e:	d7 03       	nop
80009b60:	fa ca f9 78 	sub	r10,sp,-1672
80009b64:	02 9b       	mov	r11,r1
80009b66:	08 9c       	mov	r12,r4
80009b68:	fe b0 f1 66 	rcall	80007e34 <__sprint_r>
80009b6c:	e0 81 00 f1 	brne	80009d4e <_vfprintf_r+0x1efe>
80009b70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b74:	30 08       	mov	r8,0
80009b76:	30 09       	mov	r9,0
80009b78:	40 5b       	lddsp	r11,sp[0x14]
80009b7a:	40 7a       	lddsp	r10,sp[0x1c]
80009b7c:	e0 a0 13 25 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
80009b80:	40 68       	lddsp	r8,sp[0x18]
80009b82:	20 18       	sub	r8,1
80009b84:	58 0c       	cp.w	r12,0
80009b86:	c0 d1       	brne	80009ba0 <_vfprintf_r+0x1d50>
80009b88:	2f f6       	sub	r6,-1
80009b8a:	87 18       	st.w	r3[0x4],r8
80009b8c:	87 06       	st.w	r3[0x0],r6
80009b8e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009b92:	10 06       	add	r6,r8
80009b94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b98:	fb 46 06 90 	st.w	sp[1680],r6
80009b9c:	2f f8       	sub	r8,-1
80009b9e:	c3 18       	rjmp	80009c00 <_vfprintf_r+0x1db0>
80009ba0:	10 96       	mov	r6,r8
80009ba2:	58 08       	cp.w	r8,0
80009ba4:	e0 89 00 1c 	brgt	80009bdc <_vfprintf_r+0x1d8c>
80009ba8:	c4 b8       	rjmp	80009c3e <_vfprintf_r+0x1dee>
80009baa:	2f 09       	sub	r9,-16
80009bac:	2f f8       	sub	r8,-1
80009bae:	fb 49 06 90 	st.w	sp[1680],r9
80009bb2:	87 02       	st.w	r3[0x0],r2
80009bb4:	87 10       	st.w	r3[0x4],r0
80009bb6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bba:	58 78       	cp.w	r8,7
80009bbc:	e0 89 00 04 	brgt	80009bc4 <_vfprintf_r+0x1d74>
80009bc0:	2f 83       	sub	r3,-8
80009bc2:	c0 b8       	rjmp	80009bd8 <_vfprintf_r+0x1d88>
80009bc4:	fa ca f9 78 	sub	r10,sp,-1672
80009bc8:	02 9b       	mov	r11,r1
80009bca:	08 9c       	mov	r12,r4
80009bcc:	fe b0 f1 34 	rcall	80007e34 <__sprint_r>
80009bd0:	e0 81 00 bf 	brne	80009d4e <_vfprintf_r+0x1efe>
80009bd4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bd8:	21 06       	sub	r6,16
80009bda:	c0 48       	rjmp	80009be2 <_vfprintf_r+0x1d92>
80009bdc:	fe c2 be 50 	sub	r2,pc,-16816
80009be0:	31 00       	mov	r0,16
80009be2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009be6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bea:	fe ca be 5e 	sub	r10,pc,-16802
80009bee:	59 06       	cp.w	r6,16
80009bf0:	fe 99 ff dd 	brgt	80009baa <_vfprintf_r+0x1d5a>
80009bf4:	0c 09       	add	r9,r6
80009bf6:	87 0a       	st.w	r3[0x0],r10
80009bf8:	fb 49 06 90 	st.w	sp[1680],r9
80009bfc:	2f f8       	sub	r8,-1
80009bfe:	87 16       	st.w	r3[0x4],r6
80009c00:	fb 48 06 8c 	st.w	sp[1676],r8
80009c04:	c0 e8       	rjmp	80009c20 <_vfprintf_r+0x1dd0>
80009c06:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c0a:	2f f8       	sub	r8,-1
80009c0c:	30 19       	mov	r9,1
80009c0e:	fb 48 06 90 	st.w	sp[1680],r8
80009c12:	87 06       	st.w	r3[0x0],r6
80009c14:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c18:	87 19       	st.w	r3[0x4],r9
80009c1a:	2f f8       	sub	r8,-1
80009c1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c20:	58 78       	cp.w	r8,7
80009c22:	e0 89 00 04 	brgt	80009c2a <_vfprintf_r+0x1dda>
80009c26:	2f 83       	sub	r3,-8
80009c28:	c0 b8       	rjmp	80009c3e <_vfprintf_r+0x1dee>
80009c2a:	fa ca f9 78 	sub	r10,sp,-1672
80009c2e:	02 9b       	mov	r11,r1
80009c30:	08 9c       	mov	r12,r4
80009c32:	fe b0 f1 01 	rcall	80007e34 <__sprint_r>
80009c36:	e0 81 00 8c 	brne	80009d4e <_vfprintf_r+0x1efe>
80009c3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c3e:	40 ea       	lddsp	r10,sp[0x38]
80009c40:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c44:	14 08       	add	r8,r10
80009c46:	fa c9 f9 64 	sub	r9,sp,-1692
80009c4a:	fb 48 06 90 	st.w	sp[1680],r8
80009c4e:	87 1a       	st.w	r3[0x4],r10
80009c50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c54:	87 09       	st.w	r3[0x0],r9
80009c56:	2f f8       	sub	r8,-1
80009c58:	fb 48 06 8c 	st.w	sp[1676],r8
80009c5c:	58 78       	cp.w	r8,7
80009c5e:	e0 89 00 04 	brgt	80009c66 <_vfprintf_r+0x1e16>
80009c62:	2f 83       	sub	r3,-8
80009c64:	c0 a8       	rjmp	80009c78 <_vfprintf_r+0x1e28>
80009c66:	fa ca f9 78 	sub	r10,sp,-1672
80009c6a:	02 9b       	mov	r11,r1
80009c6c:	08 9c       	mov	r12,r4
80009c6e:	fe b0 f0 e3 	rcall	80007e34 <__sprint_r>
80009c72:	c6 e1       	brne	80009d4e <_vfprintf_r+0x1efe>
80009c74:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c78:	e2 15 00 04 	andl	r5,0x4,COH
80009c7c:	c3 f0       	breq	80009cfa <_vfprintf_r+0x1eaa>
80009c7e:	40 86       	lddsp	r6,sp[0x20]
80009c80:	40 39       	lddsp	r9,sp[0xc]
80009c82:	12 16       	sub	r6,r9
80009c84:	58 06       	cp.w	r6,0
80009c86:	e0 89 00 1a 	brgt	80009cba <_vfprintf_r+0x1e6a>
80009c8a:	c3 88       	rjmp	80009cfa <_vfprintf_r+0x1eaa>
80009c8c:	2f 09       	sub	r9,-16
80009c8e:	2f f8       	sub	r8,-1
80009c90:	fb 49 06 90 	st.w	sp[1680],r9
80009c94:	87 05       	st.w	r3[0x0],r5
80009c96:	87 12       	st.w	r3[0x4],r2
80009c98:	fb 48 06 8c 	st.w	sp[1676],r8
80009c9c:	58 78       	cp.w	r8,7
80009c9e:	e0 89 00 04 	brgt	80009ca6 <_vfprintf_r+0x1e56>
80009ca2:	2f 83       	sub	r3,-8
80009ca4:	c0 98       	rjmp	80009cb6 <_vfprintf_r+0x1e66>
80009ca6:	00 9a       	mov	r10,r0
80009ca8:	02 9b       	mov	r11,r1
80009caa:	08 9c       	mov	r12,r4
80009cac:	fe b0 f0 c4 	rcall	80007e34 <__sprint_r>
80009cb0:	c4 f1       	brne	80009d4e <_vfprintf_r+0x1efe>
80009cb2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cb6:	21 06       	sub	r6,16
80009cb8:	c0 68       	rjmp	80009cc4 <_vfprintf_r+0x1e74>
80009cba:	fe c5 bf 3e 	sub	r5,pc,-16578
80009cbe:	31 02       	mov	r2,16
80009cc0:	fa c0 f9 78 	sub	r0,sp,-1672
80009cc4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cc8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ccc:	fe ca bf 50 	sub	r10,pc,-16560
80009cd0:	59 06       	cp.w	r6,16
80009cd2:	fe 99 ff dd 	brgt	80009c8c <_vfprintf_r+0x1e3c>
80009cd6:	0c 09       	add	r9,r6
80009cd8:	2f f8       	sub	r8,-1
80009cda:	87 0a       	st.w	r3[0x0],r10
80009cdc:	87 16       	st.w	r3[0x4],r6
80009cde:	fb 49 06 90 	st.w	sp[1680],r9
80009ce2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce6:	58 78       	cp.w	r8,7
80009ce8:	e0 8a 00 09 	brle	80009cfa <_vfprintf_r+0x1eaa>
80009cec:	fa ca f9 78 	sub	r10,sp,-1672
80009cf0:	02 9b       	mov	r11,r1
80009cf2:	08 9c       	mov	r12,r4
80009cf4:	fe b0 f0 a0 	rcall	80007e34 <__sprint_r>
80009cf8:	c2 b1       	brne	80009d4e <_vfprintf_r+0x1efe>
80009cfa:	40 bc       	lddsp	r12,sp[0x2c]
80009cfc:	40 36       	lddsp	r6,sp[0xc]
80009cfe:	40 8e       	lddsp	lr,sp[0x20]
80009d00:	ec 0e 0c 48 	max	r8,r6,lr
80009d04:	10 0c       	add	r12,r8
80009d06:	50 bc       	stdsp	sp[0x2c],r12
80009d08:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d0c:	58 08       	cp.w	r8,0
80009d0e:	c0 80       	breq	80009d1e <_vfprintf_r+0x1ece>
80009d10:	fa ca f9 78 	sub	r10,sp,-1672
80009d14:	02 9b       	mov	r11,r1
80009d16:	08 9c       	mov	r12,r4
80009d18:	fe b0 f0 8e 	rcall	80007e34 <__sprint_r>
80009d1c:	c1 91       	brne	80009d4e <_vfprintf_r+0x1efe>
80009d1e:	30 0b       	mov	r11,0
80009d20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d24:	fb 4b 06 8c 	st.w	sp[1676],r11
80009d28:	fe 9f f1 22 	bral	80007f6c <_vfprintf_r+0x11c>
80009d2c:	08 95       	mov	r5,r4
80009d2e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d32:	58 08       	cp.w	r8,0
80009d34:	c0 80       	breq	80009d44 <_vfprintf_r+0x1ef4>
80009d36:	08 9c       	mov	r12,r4
80009d38:	fa ca f9 78 	sub	r10,sp,-1672
80009d3c:	02 9b       	mov	r11,r1
80009d3e:	fe b0 f0 7b 	rcall	80007e34 <__sprint_r>
80009d42:	c0 61       	brne	80009d4e <_vfprintf_r+0x1efe>
80009d44:	30 08       	mov	r8,0
80009d46:	fb 48 06 8c 	st.w	sp[1676],r8
80009d4a:	c0 28       	rjmp	80009d4e <_vfprintf_r+0x1efe>
80009d4c:	40 41       	lddsp	r1,sp[0x10]
80009d4e:	82 68       	ld.sh	r8,r1[0xc]
80009d50:	ed b8 00 06 	bld	r8,0x6
80009d54:	c0 31       	brne	80009d5a <_vfprintf_r+0x1f0a>
80009d56:	3f fa       	mov	r10,-1
80009d58:	50 ba       	stdsp	sp[0x2c],r10
80009d5a:	40 bc       	lddsp	r12,sp[0x2c]
80009d5c:	fe 3d f9 44 	sub	sp,-1724
80009d60:	d8 32       	popm	r0-r7,pc
80009d62:	d7 03       	nop

80009d64 <__swsetup_r>:
80009d64:	d4 21       	pushm	r4-r7,lr
80009d66:	e0 68 0a 3c 	mov	r8,2620
80009d6a:	18 96       	mov	r6,r12
80009d6c:	16 97       	mov	r7,r11
80009d6e:	70 0c       	ld.w	r12,r8[0x0]
80009d70:	58 0c       	cp.w	r12,0
80009d72:	c0 60       	breq	80009d7e <__swsetup_r+0x1a>
80009d74:	78 68       	ld.w	r8,r12[0x18]
80009d76:	58 08       	cp.w	r8,0
80009d78:	c0 31       	brne	80009d7e <__swsetup_r+0x1a>
80009d7a:	e0 a0 07 bf 	rcall	8000acf8 <__sinit>
80009d7e:	fe c8 be d2 	sub	r8,pc,-16686
80009d82:	10 37       	cp.w	r7,r8
80009d84:	c0 61       	brne	80009d90 <__swsetup_r+0x2c>
80009d86:	e0 68 0a 3c 	mov	r8,2620
80009d8a:	70 08       	ld.w	r8,r8[0x0]
80009d8c:	70 07       	ld.w	r7,r8[0x0]
80009d8e:	c1 28       	rjmp	80009db2 <__swsetup_r+0x4e>
80009d90:	fe c8 be c4 	sub	r8,pc,-16700
80009d94:	10 37       	cp.w	r7,r8
80009d96:	c0 61       	brne	80009da2 <__swsetup_r+0x3e>
80009d98:	e0 68 0a 3c 	mov	r8,2620
80009d9c:	70 08       	ld.w	r8,r8[0x0]
80009d9e:	70 17       	ld.w	r7,r8[0x4]
80009da0:	c0 98       	rjmp	80009db2 <__swsetup_r+0x4e>
80009da2:	fe c8 be b6 	sub	r8,pc,-16714
80009da6:	10 37       	cp.w	r7,r8
80009da8:	c0 51       	brne	80009db2 <__swsetup_r+0x4e>
80009daa:	e0 68 0a 3c 	mov	r8,2620
80009dae:	70 08       	ld.w	r8,r8[0x0]
80009db0:	70 27       	ld.w	r7,r8[0x8]
80009db2:	8e 68       	ld.sh	r8,r7[0xc]
80009db4:	ed b8 00 03 	bld	r8,0x3
80009db8:	c1 e0       	breq	80009df4 <__swsetup_r+0x90>
80009dba:	ed b8 00 04 	bld	r8,0x4
80009dbe:	c3 e1       	brne	80009e3a <__swsetup_r+0xd6>
80009dc0:	ed b8 00 02 	bld	r8,0x2
80009dc4:	c1 51       	brne	80009dee <__swsetup_r+0x8a>
80009dc6:	6e db       	ld.w	r11,r7[0x34]
80009dc8:	58 0b       	cp.w	r11,0
80009dca:	c0 a0       	breq	80009dde <__swsetup_r+0x7a>
80009dcc:	ee c8 ff bc 	sub	r8,r7,-68
80009dd0:	10 3b       	cp.w	r11,r8
80009dd2:	c0 40       	breq	80009dda <__swsetup_r+0x76>
80009dd4:	0c 9c       	mov	r12,r6
80009dd6:	e0 a0 08 2b 	rcall	8000ae2c <_free_r>
80009dda:	30 08       	mov	r8,0
80009ddc:	8f d8       	st.w	r7[0x34],r8
80009dde:	8e 68       	ld.sh	r8,r7[0xc]
80009de0:	e0 18 ff db 	andl	r8,0xffdb
80009de4:	ae 68       	st.h	r7[0xc],r8
80009de6:	30 08       	mov	r8,0
80009de8:	8f 18       	st.w	r7[0x4],r8
80009dea:	6e 48       	ld.w	r8,r7[0x10]
80009dec:	8f 08       	st.w	r7[0x0],r8
80009dee:	8e 68       	ld.sh	r8,r7[0xc]
80009df0:	a3 b8       	sbr	r8,0x3
80009df2:	ae 68       	st.h	r7[0xc],r8
80009df4:	6e 48       	ld.w	r8,r7[0x10]
80009df6:	58 08       	cp.w	r8,0
80009df8:	c0 b1       	brne	80009e0e <__swsetup_r+0xaa>
80009dfa:	8e 68       	ld.sh	r8,r7[0xc]
80009dfc:	e2 18 02 80 	andl	r8,0x280,COH
80009e00:	e0 48 02 00 	cp.w	r8,512
80009e04:	c0 50       	breq	80009e0e <__swsetup_r+0xaa>
80009e06:	0c 9c       	mov	r12,r6
80009e08:	0e 9b       	mov	r11,r7
80009e0a:	e0 a0 0a 4b 	rcall	8000b2a0 <__smakebuf_r>
80009e0e:	8e 69       	ld.sh	r9,r7[0xc]
80009e10:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009e14:	c0 70       	breq	80009e22 <__swsetup_r+0xbe>
80009e16:	30 08       	mov	r8,0
80009e18:	8f 28       	st.w	r7[0x8],r8
80009e1a:	6e 58       	ld.w	r8,r7[0x14]
80009e1c:	5c 38       	neg	r8
80009e1e:	8f 68       	st.w	r7[0x18],r8
80009e20:	c0 68       	rjmp	80009e2c <__swsetup_r+0xc8>
80009e22:	ed b9 00 01 	bld	r9,0x1
80009e26:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009e2a:	8f 28       	st.w	r7[0x8],r8
80009e2c:	6e 48       	ld.w	r8,r7[0x10]
80009e2e:	58 08       	cp.w	r8,0
80009e30:	c0 61       	brne	80009e3c <__swsetup_r+0xd8>
80009e32:	8e 68       	ld.sh	r8,r7[0xc]
80009e34:	ed b8 00 07 	bld	r8,0x7
80009e38:	c0 21       	brne	80009e3c <__swsetup_r+0xd8>
80009e3a:	dc 2a       	popm	r4-r7,pc,r12=-1
80009e3c:	d8 2a       	popm	r4-r7,pc,r12=0
80009e3e:	d7 03       	nop

80009e40 <quorem>:
80009e40:	d4 31       	pushm	r0-r7,lr
80009e42:	20 2d       	sub	sp,8
80009e44:	18 97       	mov	r7,r12
80009e46:	78 48       	ld.w	r8,r12[0x10]
80009e48:	76 46       	ld.w	r6,r11[0x10]
80009e4a:	0c 38       	cp.w	r8,r6
80009e4c:	c0 34       	brge	80009e52 <quorem+0x12>
80009e4e:	30 0c       	mov	r12,0
80009e50:	c8 58       	rjmp	80009f5a <quorem+0x11a>
80009e52:	ec c2 ff fc 	sub	r2,r6,-4
80009e56:	f6 c3 ff ec 	sub	r3,r11,-20
80009e5a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009e5e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009e62:	2f f9       	sub	r9,-1
80009e64:	20 16       	sub	r6,1
80009e66:	f8 09 0d 08 	divu	r8,r12,r9
80009e6a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009e6e:	ee c4 ff ec 	sub	r4,r7,-20
80009e72:	10 95       	mov	r5,r8
80009e74:	58 08       	cp.w	r8,0
80009e76:	c4 10       	breq	80009ef8 <quorem+0xb8>
80009e78:	30 09       	mov	r9,0
80009e7a:	06 9a       	mov	r10,r3
80009e7c:	08 98       	mov	r8,r4
80009e7e:	12 91       	mov	r1,r9
80009e80:	50 0b       	stdsp	sp[0x0],r11
80009e82:	70 0e       	ld.w	lr,r8[0x0]
80009e84:	b1 8e       	lsr	lr,0x10
80009e86:	50 1e       	stdsp	sp[0x4],lr
80009e88:	15 0e       	ld.w	lr,r10++
80009e8a:	fc 00 16 10 	lsr	r0,lr,0x10
80009e8e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009e92:	ea 0e 03 41 	mac	r1,r5,lr
80009e96:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009e9a:	b1 81       	lsr	r1,0x10
80009e9c:	40 1b       	lddsp	r11,sp[0x4]
80009e9e:	ea 00 02 40 	mul	r0,r5,r0
80009ea2:	e2 00 00 00 	add	r0,r1,r0
80009ea6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009eaa:	02 1b       	sub	r11,r1
80009eac:	50 1b       	stdsp	sp[0x4],r11
80009eae:	70 0b       	ld.w	r11,r8[0x0]
80009eb0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009eb4:	02 09       	add	r9,r1
80009eb6:	f2 0e 01 0e 	sub	lr,r9,lr
80009eba:	b0 1e       	st.h	r8[0x2],lr
80009ebc:	fc 09 14 10 	asr	r9,lr,0x10
80009ec0:	40 1e       	lddsp	lr,sp[0x4]
80009ec2:	fc 09 00 09 	add	r9,lr,r9
80009ec6:	b0 09       	st.h	r8[0x0],r9
80009ec8:	e0 01 16 10 	lsr	r1,r0,0x10
80009ecc:	2f c8       	sub	r8,-4
80009ece:	b1 49       	asr	r9,0x10
80009ed0:	04 3a       	cp.w	r10,r2
80009ed2:	fe 98 ff d8 	brls	80009e82 <quorem+0x42>
80009ed6:	40 0b       	lddsp	r11,sp[0x0]
80009ed8:	58 0c       	cp.w	r12,0
80009eda:	c0 f1       	brne	80009ef8 <quorem+0xb8>
80009edc:	ec c8 ff fb 	sub	r8,r6,-5
80009ee0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ee4:	c0 28       	rjmp	80009ee8 <quorem+0xa8>
80009ee6:	20 16       	sub	r6,1
80009ee8:	20 48       	sub	r8,4
80009eea:	08 38       	cp.w	r8,r4
80009eec:	e0 88 00 05 	brls	80009ef6 <quorem+0xb6>
80009ef0:	70 09       	ld.w	r9,r8[0x0]
80009ef2:	58 09       	cp.w	r9,0
80009ef4:	cf 90       	breq	80009ee6 <quorem+0xa6>
80009ef6:	8f 46       	st.w	r7[0x10],r6
80009ef8:	0e 9c       	mov	r12,r7
80009efa:	e0 a0 0a d2 	rcall	8000b49e <__mcmp>
80009efe:	c2 d5       	brlt	80009f58 <quorem+0x118>
80009f00:	2f f5       	sub	r5,-1
80009f02:	08 98       	mov	r8,r4
80009f04:	30 09       	mov	r9,0
80009f06:	07 0b       	ld.w	r11,r3++
80009f08:	f6 0a 16 10 	lsr	r10,r11,0x10
80009f0c:	70 0c       	ld.w	r12,r8[0x0]
80009f0e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009f12:	f8 0e 16 10 	lsr	lr,r12,0x10
80009f16:	14 1e       	sub	lr,r10
80009f18:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009f1c:	16 1a       	sub	r10,r11
80009f1e:	12 0a       	add	r10,r9
80009f20:	b0 1a       	st.h	r8[0x2],r10
80009f22:	b1 4a       	asr	r10,0x10
80009f24:	fc 0a 00 09 	add	r9,lr,r10
80009f28:	b0 09       	st.h	r8[0x0],r9
80009f2a:	2f c8       	sub	r8,-4
80009f2c:	b1 49       	asr	r9,0x10
80009f2e:	04 33       	cp.w	r3,r2
80009f30:	fe 98 ff eb 	brls	80009f06 <quorem+0xc6>
80009f34:	ec c8 ff fb 	sub	r8,r6,-5
80009f38:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009f3c:	58 09       	cp.w	r9,0
80009f3e:	c0 d1       	brne	80009f58 <quorem+0x118>
80009f40:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f44:	c0 28       	rjmp	80009f48 <quorem+0x108>
80009f46:	20 16       	sub	r6,1
80009f48:	20 48       	sub	r8,4
80009f4a:	08 38       	cp.w	r8,r4
80009f4c:	e0 88 00 05 	brls	80009f56 <quorem+0x116>
80009f50:	70 09       	ld.w	r9,r8[0x0]
80009f52:	58 09       	cp.w	r9,0
80009f54:	cf 90       	breq	80009f46 <quorem+0x106>
80009f56:	8f 46       	st.w	r7[0x10],r6
80009f58:	0a 9c       	mov	r12,r5
80009f5a:	2f ed       	sub	sp,-8
80009f5c:	d8 32       	popm	r0-r7,pc
80009f5e:	d7 03       	nop

80009f60 <_dtoa_r>:
80009f60:	d4 31       	pushm	r0-r7,lr
80009f62:	21 ad       	sub	sp,104
80009f64:	fa c4 ff 74 	sub	r4,sp,-140
80009f68:	18 97       	mov	r7,r12
80009f6a:	16 95       	mov	r5,r11
80009f6c:	68 2c       	ld.w	r12,r4[0x8]
80009f6e:	50 c9       	stdsp	sp[0x30],r9
80009f70:	68 16       	ld.w	r6,r4[0x4]
80009f72:	68 09       	ld.w	r9,r4[0x0]
80009f74:	50 e8       	stdsp	sp[0x38],r8
80009f76:	14 94       	mov	r4,r10
80009f78:	51 2c       	stdsp	sp[0x48],r12
80009f7a:	fa e5 00 08 	st.d	sp[8],r4
80009f7e:	51 59       	stdsp	sp[0x54],r9
80009f80:	6e 95       	ld.w	r5,r7[0x24]
80009f82:	58 05       	cp.w	r5,0
80009f84:	c0 91       	brne	80009f96 <_dtoa_r+0x36>
80009f86:	31 0c       	mov	r12,16
80009f88:	fe b0 e8 f4 	rcall	80007170 <malloc>
80009f8c:	99 35       	st.w	r12[0xc],r5
80009f8e:	8f 9c       	st.w	r7[0x24],r12
80009f90:	99 15       	st.w	r12[0x4],r5
80009f92:	99 25       	st.w	r12[0x8],r5
80009f94:	99 05       	st.w	r12[0x0],r5
80009f96:	6e 99       	ld.w	r9,r7[0x24]
80009f98:	72 08       	ld.w	r8,r9[0x0]
80009f9a:	58 08       	cp.w	r8,0
80009f9c:	c0 f0       	breq	80009fba <_dtoa_r+0x5a>
80009f9e:	72 1a       	ld.w	r10,r9[0x4]
80009fa0:	91 1a       	st.w	r8[0x4],r10
80009fa2:	30 1a       	mov	r10,1
80009fa4:	72 19       	ld.w	r9,r9[0x4]
80009fa6:	f4 09 09 49 	lsl	r9,r10,r9
80009faa:	10 9b       	mov	r11,r8
80009fac:	91 29       	st.w	r8[0x8],r9
80009fae:	0e 9c       	mov	r12,r7
80009fb0:	e0 a0 0a 90 	rcall	8000b4d0 <_Bfree>
80009fb4:	6e 98       	ld.w	r8,r7[0x24]
80009fb6:	30 09       	mov	r9,0
80009fb8:	91 09       	st.w	r8[0x0],r9
80009fba:	40 28       	lddsp	r8,sp[0x8]
80009fbc:	10 94       	mov	r4,r8
80009fbe:	58 08       	cp.w	r8,0
80009fc0:	c0 64       	brge	80009fcc <_dtoa_r+0x6c>
80009fc2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009fc6:	50 28       	stdsp	sp[0x8],r8
80009fc8:	30 18       	mov	r8,1
80009fca:	c0 28       	rjmp	80009fce <_dtoa_r+0x6e>
80009fcc:	30 08       	mov	r8,0
80009fce:	8d 08       	st.w	r6[0x0],r8
80009fd0:	fc 1c 7f f0 	movh	r12,0x7ff0
80009fd4:	40 26       	lddsp	r6,sp[0x8]
80009fd6:	0c 98       	mov	r8,r6
80009fd8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009fdc:	18 38       	cp.w	r8,r12
80009fde:	c2 01       	brne	8000a01e <_dtoa_r+0xbe>
80009fe0:	e0 68 27 0f 	mov	r8,9999
80009fe4:	41 5b       	lddsp	r11,sp[0x54]
80009fe6:	97 08       	st.w	r11[0x0],r8
80009fe8:	40 3a       	lddsp	r10,sp[0xc]
80009fea:	58 0a       	cp.w	r10,0
80009fec:	c0 71       	brne	80009ffa <_dtoa_r+0x9a>
80009fee:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009ff2:	c0 41       	brne	80009ffa <_dtoa_r+0x9a>
80009ff4:	fe cc c1 58 	sub	r12,pc,-16040
80009ff8:	c0 38       	rjmp	80009ffe <_dtoa_r+0x9e>
80009ffa:	fe cc c1 52 	sub	r12,pc,-16046
80009ffe:	41 29       	lddsp	r9,sp[0x48]
8000a000:	58 09       	cp.w	r9,0
8000a002:	e0 80 05 9a 	breq	8000ab36 <_dtoa_r+0xbd6>
8000a006:	f8 c8 ff fd 	sub	r8,r12,-3
8000a00a:	f8 c9 ff f8 	sub	r9,r12,-8
8000a00e:	11 8b       	ld.ub	r11,r8[0x0]
8000a010:	30 0a       	mov	r10,0
8000a012:	41 25       	lddsp	r5,sp[0x48]
8000a014:	f4 0b 18 00 	cp.b	r11,r10
8000a018:	f2 08 17 10 	movne	r8,r9
8000a01c:	c1 68       	rjmp	8000a048 <_dtoa_r+0xe8>
8000a01e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a022:	30 08       	mov	r8,0
8000a024:	fa eb 00 3c 	st.d	sp[60],r10
8000a028:	30 09       	mov	r9,0
8000a02a:	e0 a0 10 ce 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000a02e:	c1 00       	breq	8000a04e <_dtoa_r+0xee>
8000a030:	30 18       	mov	r8,1
8000a032:	41 5a       	lddsp	r10,sp[0x54]
8000a034:	95 08       	st.w	r10[0x0],r8
8000a036:	fe cc c2 be 	sub	r12,pc,-15682
8000a03a:	41 29       	lddsp	r9,sp[0x48]
8000a03c:	f8 08 00 08 	add	r8,r12,r8
8000a040:	58 09       	cp.w	r9,0
8000a042:	e0 80 05 7a 	breq	8000ab36 <_dtoa_r+0xbd6>
8000a046:	12 95       	mov	r5,r9
8000a048:	8b 08       	st.w	r5[0x0],r8
8000a04a:	e0 8f 05 76 	bral	8000ab36 <_dtoa_r+0xbd6>
8000a04e:	fa c8 ff 9c 	sub	r8,sp,-100
8000a052:	fa c9 ff a0 	sub	r9,sp,-96
8000a056:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a05a:	0e 9c       	mov	r12,r7
8000a05c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a060:	e0 a0 0a 8a 	rcall	8000b574 <__d2b>
8000a064:	18 93       	mov	r3,r12
8000a066:	58 05       	cp.w	r5,0
8000a068:	c0 d0       	breq	8000a082 <_dtoa_r+0x122>
8000a06a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a06e:	30 04       	mov	r4,0
8000a070:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a074:	ea c5 03 ff 	sub	r5,r5,1023
8000a078:	10 9b       	mov	r11,r8
8000a07a:	51 74       	stdsp	sp[0x5c],r4
8000a07c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a080:	c2 58       	rjmp	8000a0ca <_dtoa_r+0x16a>
8000a082:	41 88       	lddsp	r8,sp[0x60]
8000a084:	41 9c       	lddsp	r12,sp[0x64]
8000a086:	10 0c       	add	r12,r8
8000a088:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a08c:	e0 45 00 20 	cp.w	r5,32
8000a090:	e0 8a 00 0e 	brle	8000a0ac <_dtoa_r+0x14c>
8000a094:	f8 cc fb ee 	sub	r12,r12,-1042
8000a098:	40 3b       	lddsp	r11,sp[0xc]
8000a09a:	ea 08 11 40 	rsub	r8,r5,64
8000a09e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a0a2:	ec 08 09 46 	lsl	r6,r6,r8
8000a0a6:	0c 4c       	or	r12,r6
8000a0a8:	c0 78       	rjmp	8000a0b6 <_dtoa_r+0x156>
8000a0aa:	d7 03       	nop
8000a0ac:	ea 0c 11 20 	rsub	r12,r5,32
8000a0b0:	40 3a       	lddsp	r10,sp[0xc]
8000a0b2:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a0b6:	e0 a0 10 14 	rcall	8000c0de <__avr32_u32_to_f64>
8000a0ba:	fc 18 fe 10 	movh	r8,0xfe10
8000a0be:	30 19       	mov	r9,1
8000a0c0:	ea c5 04 33 	sub	r5,r5,1075
8000a0c4:	f0 0b 00 0b 	add	r11,r8,r11
8000a0c8:	51 79       	stdsp	sp[0x5c],r9
8000a0ca:	30 08       	mov	r8,0
8000a0cc:	fc 19 3f f8 	movh	r9,0x3ff8
8000a0d0:	e0 a0 0e 9c 	rcall	8000be08 <__avr32_f64_sub>
8000a0d4:	e0 68 43 61 	mov	r8,17249
8000a0d8:	ea 18 63 6f 	orh	r8,0x636f
8000a0dc:	e0 69 87 a7 	mov	r9,34727
8000a0e0:	ea 19 3f d2 	orh	r9,0x3fd2
8000a0e4:	e0 a0 0d a6 	rcall	8000bc30 <__avr32_f64_mul>
8000a0e8:	e0 68 c8 b3 	mov	r8,51379
8000a0ec:	ea 18 8b 60 	orh	r8,0x8b60
8000a0f0:	e0 69 8a 28 	mov	r9,35368
8000a0f4:	ea 19 3f c6 	orh	r9,0x3fc6
8000a0f8:	e0 a0 0f 56 	rcall	8000bfa4 <__avr32_f64_add>
8000a0fc:	0a 9c       	mov	r12,r5
8000a0fe:	14 90       	mov	r0,r10
8000a100:	16 91       	mov	r1,r11
8000a102:	e0 a0 0f f2 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a106:	e0 68 79 fb 	mov	r8,31227
8000a10a:	ea 18 50 9f 	orh	r8,0x509f
8000a10e:	e0 69 44 13 	mov	r9,17427
8000a112:	ea 19 3f d3 	orh	r9,0x3fd3
8000a116:	e0 a0 0d 8d 	rcall	8000bc30 <__avr32_f64_mul>
8000a11a:	14 98       	mov	r8,r10
8000a11c:	16 99       	mov	r9,r11
8000a11e:	00 9a       	mov	r10,r0
8000a120:	02 9b       	mov	r11,r1
8000a122:	e0 a0 0f 41 	rcall	8000bfa4 <__avr32_f64_add>
8000a126:	14 90       	mov	r0,r10
8000a128:	16 91       	mov	r1,r11
8000a12a:	e0 a0 0f c7 	rcall	8000c0b8 <__avr32_f64_to_s32>
8000a12e:	30 08       	mov	r8,0
8000a130:	18 96       	mov	r6,r12
8000a132:	30 09       	mov	r9,0
8000a134:	00 9a       	mov	r10,r0
8000a136:	02 9b       	mov	r11,r1
8000a138:	e0 a0 10 8e 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a13c:	c0 c0       	breq	8000a154 <_dtoa_r+0x1f4>
8000a13e:	0c 9c       	mov	r12,r6
8000a140:	e0 a0 0f d3 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a144:	14 98       	mov	r8,r10
8000a146:	16 99       	mov	r9,r11
8000a148:	00 9a       	mov	r10,r0
8000a14a:	02 9b       	mov	r11,r1
8000a14c:	e0 a0 10 3d 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000a150:	f7 b6 00 01 	subeq	r6,1
8000a154:	59 66       	cp.w	r6,22
8000a156:	e0 88 00 05 	brls	8000a160 <_dtoa_r+0x200>
8000a15a:	30 18       	mov	r8,1
8000a15c:	51 48       	stdsp	sp[0x50],r8
8000a15e:	c1 38       	rjmp	8000a184 <_dtoa_r+0x224>
8000a160:	fe c8 c2 04 	sub	r8,pc,-15868
8000a164:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a168:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a16c:	e0 a0 10 74 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a170:	f9 b4 00 00 	moveq	r4,0
8000a174:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a178:	f7 b6 01 01 	subne	r6,1
8000a17c:	f9 bc 01 00 	movne	r12,0
8000a180:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a184:	41 90       	lddsp	r0,sp[0x64]
8000a186:	20 10       	sub	r0,1
8000a188:	0a 10       	sub	r0,r5
8000a18a:	c0 46       	brmi	8000a192 <_dtoa_r+0x232>
8000a18c:	50 40       	stdsp	sp[0x10],r0
8000a18e:	30 00       	mov	r0,0
8000a190:	c0 48       	rjmp	8000a198 <_dtoa_r+0x238>
8000a192:	30 0b       	mov	r11,0
8000a194:	5c 30       	neg	r0
8000a196:	50 4b       	stdsp	sp[0x10],r11
8000a198:	ec 02 11 00 	rsub	r2,r6,0
8000a19c:	58 06       	cp.w	r6,0
8000a19e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a1a2:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a1a6:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a1aa:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a1ae:	f9 b2 04 00 	movge	r2,0
8000a1b2:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a1b6:	f9 b9 05 00 	movlt	r9,0
8000a1ba:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a1be:	40 c8       	lddsp	r8,sp[0x30]
8000a1c0:	58 98       	cp.w	r8,9
8000a1c2:	e0 8b 00 20 	brhi	8000a202 <_dtoa_r+0x2a2>
8000a1c6:	58 58       	cp.w	r8,5
8000a1c8:	f9 b4 0a 01 	movle	r4,1
8000a1cc:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a1d0:	f7 b5 09 04 	subgt	r5,4
8000a1d4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a1d8:	f9 b4 09 00 	movgt	r4,0
8000a1dc:	40 cc       	lddsp	r12,sp[0x30]
8000a1de:	58 3c       	cp.w	r12,3
8000a1e0:	c2 d0       	breq	8000a23a <_dtoa_r+0x2da>
8000a1e2:	e0 89 00 05 	brgt	8000a1ec <_dtoa_r+0x28c>
8000a1e6:	58 2c       	cp.w	r12,2
8000a1e8:	c1 01       	brne	8000a208 <_dtoa_r+0x2a8>
8000a1ea:	c1 88       	rjmp	8000a21a <_dtoa_r+0x2ba>
8000a1ec:	40 cb       	lddsp	r11,sp[0x30]
8000a1ee:	58 4b       	cp.w	r11,4
8000a1f0:	c0 60       	breq	8000a1fc <_dtoa_r+0x29c>
8000a1f2:	58 5b       	cp.w	r11,5
8000a1f4:	c0 a1       	brne	8000a208 <_dtoa_r+0x2a8>
8000a1f6:	30 1a       	mov	r10,1
8000a1f8:	50 da       	stdsp	sp[0x34],r10
8000a1fa:	c2 28       	rjmp	8000a23e <_dtoa_r+0x2de>
8000a1fc:	30 19       	mov	r9,1
8000a1fe:	50 d9       	stdsp	sp[0x34],r9
8000a200:	c0 f8       	rjmp	8000a21e <_dtoa_r+0x2be>
8000a202:	30 08       	mov	r8,0
8000a204:	30 14       	mov	r4,1
8000a206:	50 c8       	stdsp	sp[0x30],r8
8000a208:	3f f5       	mov	r5,-1
8000a20a:	30 1c       	mov	r12,1
8000a20c:	30 0b       	mov	r11,0
8000a20e:	50 95       	stdsp	sp[0x24],r5
8000a210:	50 dc       	stdsp	sp[0x34],r12
8000a212:	0a 91       	mov	r1,r5
8000a214:	31 28       	mov	r8,18
8000a216:	50 eb       	stdsp	sp[0x38],r11
8000a218:	c2 08       	rjmp	8000a258 <_dtoa_r+0x2f8>
8000a21a:	30 0a       	mov	r10,0
8000a21c:	50 da       	stdsp	sp[0x34],r10
8000a21e:	40 e9       	lddsp	r9,sp[0x38]
8000a220:	58 09       	cp.w	r9,0
8000a222:	e0 89 00 07 	brgt	8000a230 <_dtoa_r+0x2d0>
8000a226:	30 18       	mov	r8,1
8000a228:	50 98       	stdsp	sp[0x24],r8
8000a22a:	10 91       	mov	r1,r8
8000a22c:	50 e8       	stdsp	sp[0x38],r8
8000a22e:	c1 58       	rjmp	8000a258 <_dtoa_r+0x2f8>
8000a230:	40 e5       	lddsp	r5,sp[0x38]
8000a232:	50 95       	stdsp	sp[0x24],r5
8000a234:	0a 91       	mov	r1,r5
8000a236:	0a 98       	mov	r8,r5
8000a238:	c1 08       	rjmp	8000a258 <_dtoa_r+0x2f8>
8000a23a:	30 0c       	mov	r12,0
8000a23c:	50 dc       	stdsp	sp[0x34],r12
8000a23e:	40 eb       	lddsp	r11,sp[0x38]
8000a240:	ec 0b 00 0b 	add	r11,r6,r11
8000a244:	50 9b       	stdsp	sp[0x24],r11
8000a246:	16 98       	mov	r8,r11
8000a248:	2f f8       	sub	r8,-1
8000a24a:	58 08       	cp.w	r8,0
8000a24c:	e0 89 00 05 	brgt	8000a256 <_dtoa_r+0x2f6>
8000a250:	10 91       	mov	r1,r8
8000a252:	30 18       	mov	r8,1
8000a254:	c0 28       	rjmp	8000a258 <_dtoa_r+0x2f8>
8000a256:	10 91       	mov	r1,r8
8000a258:	30 09       	mov	r9,0
8000a25a:	6e 9a       	ld.w	r10,r7[0x24]
8000a25c:	95 19       	st.w	r10[0x4],r9
8000a25e:	30 49       	mov	r9,4
8000a260:	c0 68       	rjmp	8000a26c <_dtoa_r+0x30c>
8000a262:	d7 03       	nop
8000a264:	6a 1a       	ld.w	r10,r5[0x4]
8000a266:	a1 79       	lsl	r9,0x1
8000a268:	2f fa       	sub	r10,-1
8000a26a:	8b 1a       	st.w	r5[0x4],r10
8000a26c:	6e 95       	ld.w	r5,r7[0x24]
8000a26e:	f2 ca ff ec 	sub	r10,r9,-20
8000a272:	10 3a       	cp.w	r10,r8
8000a274:	fe 98 ff f8 	brls	8000a264 <_dtoa_r+0x304>
8000a278:	6a 1b       	ld.w	r11,r5[0x4]
8000a27a:	0e 9c       	mov	r12,r7
8000a27c:	e0 a0 09 44 	rcall	8000b504 <_Balloc>
8000a280:	58 e1       	cp.w	r1,14
8000a282:	5f 88       	srls	r8
8000a284:	8b 0c       	st.w	r5[0x0],r12
8000a286:	f1 e4 00 04 	and	r4,r8,r4
8000a28a:	6e 98       	ld.w	r8,r7[0x24]
8000a28c:	70 08       	ld.w	r8,r8[0x0]
8000a28e:	50 88       	stdsp	sp[0x20],r8
8000a290:	e0 80 01 82 	breq	8000a594 <_dtoa_r+0x634>
8000a294:	58 06       	cp.w	r6,0
8000a296:	e0 8a 00 43 	brle	8000a31c <_dtoa_r+0x3bc>
8000a29a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a29e:	fe c8 c3 42 	sub	r8,pc,-15550
8000a2a2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a2a6:	fa e5 00 18 	st.d	sp[24],r4
8000a2aa:	ec 04 14 04 	asr	r4,r6,0x4
8000a2ae:	ed b4 00 04 	bld	r4,0x4
8000a2b2:	c0 30       	breq	8000a2b8 <_dtoa_r+0x358>
8000a2b4:	30 25       	mov	r5,2
8000a2b6:	c1 08       	rjmp	8000a2d6 <_dtoa_r+0x376>
8000a2b8:	fe c8 c2 94 	sub	r8,pc,-15724
8000a2bc:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a2c0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2c4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a2c8:	e0 a0 0f fa 	rcall	8000c2bc <__avr32_f64_div>
8000a2cc:	30 35       	mov	r5,3
8000a2ce:	14 98       	mov	r8,r10
8000a2d0:	16 99       	mov	r9,r11
8000a2d2:	fa e9 00 08 	st.d	sp[8],r8
8000a2d6:	fe cc c2 b2 	sub	r12,pc,-15694
8000a2da:	50 a3       	stdsp	sp[0x28],r3
8000a2dc:	0c 93       	mov	r3,r6
8000a2de:	18 96       	mov	r6,r12
8000a2e0:	c0 f8       	rjmp	8000a2fe <_dtoa_r+0x39e>
8000a2e2:	fa ea 00 18 	ld.d	r10,sp[24]
8000a2e6:	ed b4 00 00 	bld	r4,0x0
8000a2ea:	c0 81       	brne	8000a2fa <_dtoa_r+0x39a>
8000a2ec:	ec e8 00 00 	ld.d	r8,r6[0]
8000a2f0:	2f f5       	sub	r5,-1
8000a2f2:	e0 a0 0c 9f 	rcall	8000bc30 <__avr32_f64_mul>
8000a2f6:	fa eb 00 18 	st.d	sp[24],r10
8000a2fa:	a1 54       	asr	r4,0x1
8000a2fc:	2f 86       	sub	r6,-8
8000a2fe:	58 04       	cp.w	r4,0
8000a300:	cf 11       	brne	8000a2e2 <_dtoa_r+0x382>
8000a302:	fa e8 00 18 	ld.d	r8,sp[24]
8000a306:	fa ea 00 08 	ld.d	r10,sp[8]
8000a30a:	06 96       	mov	r6,r3
8000a30c:	e0 a0 0f d8 	rcall	8000c2bc <__avr32_f64_div>
8000a310:	40 a3       	lddsp	r3,sp[0x28]
8000a312:	14 98       	mov	r8,r10
8000a314:	16 99       	mov	r9,r11
8000a316:	fa e9 00 08 	st.d	sp[8],r8
8000a31a:	c2 f8       	rjmp	8000a378 <_dtoa_r+0x418>
8000a31c:	ec 08 11 00 	rsub	r8,r6,0
8000a320:	c0 31       	brne	8000a326 <_dtoa_r+0x3c6>
8000a322:	30 25       	mov	r5,2
8000a324:	c2 a8       	rjmp	8000a378 <_dtoa_r+0x418>
8000a326:	fe cc c3 02 	sub	r12,pc,-15614
8000a32a:	f0 04 14 04 	asr	r4,r8,0x4
8000a32e:	50 1c       	stdsp	sp[0x4],r12
8000a330:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a334:	fe c9 c3 d8 	sub	r9,pc,-15400
8000a338:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a33c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a340:	e0 a0 0c 78 	rcall	8000bc30 <__avr32_f64_mul>
8000a344:	40 1c       	lddsp	r12,sp[0x4]
8000a346:	50 63       	stdsp	sp[0x18],r3
8000a348:	30 25       	mov	r5,2
8000a34a:	0c 93       	mov	r3,r6
8000a34c:	fa eb 00 08 	st.d	sp[8],r10
8000a350:	18 96       	mov	r6,r12
8000a352:	c0 f8       	rjmp	8000a370 <_dtoa_r+0x410>
8000a354:	fa ea 00 08 	ld.d	r10,sp[8]
8000a358:	ed b4 00 00 	bld	r4,0x0
8000a35c:	c0 81       	brne	8000a36c <_dtoa_r+0x40c>
8000a35e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a362:	2f f5       	sub	r5,-1
8000a364:	e0 a0 0c 66 	rcall	8000bc30 <__avr32_f64_mul>
8000a368:	fa eb 00 08 	st.d	sp[8],r10
8000a36c:	a1 54       	asr	r4,0x1
8000a36e:	2f 86       	sub	r6,-8
8000a370:	58 04       	cp.w	r4,0
8000a372:	cf 11       	brne	8000a354 <_dtoa_r+0x3f4>
8000a374:	06 96       	mov	r6,r3
8000a376:	40 63       	lddsp	r3,sp[0x18]
8000a378:	41 4a       	lddsp	r10,sp[0x50]
8000a37a:	58 0a       	cp.w	r10,0
8000a37c:	c2 a0       	breq	8000a3d0 <_dtoa_r+0x470>
8000a37e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a382:	58 01       	cp.w	r1,0
8000a384:	5f 94       	srgt	r4
8000a386:	fa e9 00 18 	st.d	sp[24],r8
8000a38a:	30 08       	mov	r8,0
8000a38c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a390:	fa ea 00 18 	ld.d	r10,sp[24]
8000a394:	e0 a0 0f 60 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a398:	f9 bc 00 00 	moveq	r12,0
8000a39c:	f9 bc 01 01 	movne	r12,1
8000a3a0:	e9 ec 00 0c 	and	r12,r4,r12
8000a3a4:	c1 60       	breq	8000a3d0 <_dtoa_r+0x470>
8000a3a6:	40 98       	lddsp	r8,sp[0x24]
8000a3a8:	58 08       	cp.w	r8,0
8000a3aa:	e0 8a 00 f1 	brle	8000a58c <_dtoa_r+0x62c>
8000a3ae:	30 08       	mov	r8,0
8000a3b0:	fc 19 40 24 	movh	r9,0x4024
8000a3b4:	ec c4 00 01 	sub	r4,r6,1
8000a3b8:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3bc:	2f f5       	sub	r5,-1
8000a3be:	50 64       	stdsp	sp[0x18],r4
8000a3c0:	e0 a0 0c 38 	rcall	8000bc30 <__avr32_f64_mul>
8000a3c4:	40 94       	lddsp	r4,sp[0x24]
8000a3c6:	14 98       	mov	r8,r10
8000a3c8:	16 99       	mov	r9,r11
8000a3ca:	fa e9 00 08 	st.d	sp[8],r8
8000a3ce:	c0 38       	rjmp	8000a3d4 <_dtoa_r+0x474>
8000a3d0:	50 66       	stdsp	sp[0x18],r6
8000a3d2:	02 94       	mov	r4,r1
8000a3d4:	0a 9c       	mov	r12,r5
8000a3d6:	e0 a0 0e 88 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a3da:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3de:	e0 a0 0c 29 	rcall	8000bc30 <__avr32_f64_mul>
8000a3e2:	30 08       	mov	r8,0
8000a3e4:	fc 19 40 1c 	movh	r9,0x401c
8000a3e8:	e0 a0 0d de 	rcall	8000bfa4 <__avr32_f64_add>
8000a3ec:	14 98       	mov	r8,r10
8000a3ee:	16 99       	mov	r9,r11
8000a3f0:	fa e9 00 28 	st.d	sp[40],r8
8000a3f4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a3f8:	40 a5       	lddsp	r5,sp[0x28]
8000a3fa:	10 05       	add	r5,r8
8000a3fc:	50 a5       	stdsp	sp[0x28],r5
8000a3fe:	58 04       	cp.w	r4,0
8000a400:	c2 11       	brne	8000a442 <_dtoa_r+0x4e2>
8000a402:	fa ea 00 08 	ld.d	r10,sp[8]
8000a406:	30 08       	mov	r8,0
8000a408:	fc 19 40 14 	movh	r9,0x4014
8000a40c:	e0 a0 0c fe 	rcall	8000be08 <__avr32_f64_sub>
8000a410:	40 bc       	lddsp	r12,sp[0x2c]
8000a412:	fa eb 00 08 	st.d	sp[8],r10
8000a416:	14 98       	mov	r8,r10
8000a418:	16 99       	mov	r9,r11
8000a41a:	18 9a       	mov	r10,r12
8000a41c:	0a 9b       	mov	r11,r5
8000a41e:	e0 a0 0f 1b 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a422:	e0 81 02 54 	brne	8000a8ca <_dtoa_r+0x96a>
8000a426:	0a 98       	mov	r8,r5
8000a428:	40 b9       	lddsp	r9,sp[0x2c]
8000a42a:	ee 18 80 00 	eorh	r8,0x8000
8000a42e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a432:	10 95       	mov	r5,r8
8000a434:	12 98       	mov	r8,r9
8000a436:	0a 99       	mov	r9,r5
8000a438:	e0 a0 0f 0e 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a43c:	e0 81 02 3e 	brne	8000a8b8 <_dtoa_r+0x958>
8000a440:	ca 68       	rjmp	8000a58c <_dtoa_r+0x62c>
8000a442:	fe c9 c4 e6 	sub	r9,pc,-15130
8000a446:	e8 c8 00 01 	sub	r8,r4,1
8000a44a:	40 d5       	lddsp	r5,sp[0x34]
8000a44c:	58 05       	cp.w	r5,0
8000a44e:	c4 f0       	breq	8000a4ec <_dtoa_r+0x58c>
8000a450:	30 0c       	mov	r12,0
8000a452:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a456:	51 3c       	stdsp	sp[0x4c],r12
8000a458:	30 0a       	mov	r10,0
8000a45a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a45e:	e0 a0 0f 2f 	rcall	8000c2bc <__avr32_f64_div>
8000a462:	fa e8 00 28 	ld.d	r8,sp[40]
8000a466:	40 85       	lddsp	r5,sp[0x20]
8000a468:	e0 a0 0c d0 	rcall	8000be08 <__avr32_f64_sub>
8000a46c:	fa eb 00 28 	st.d	sp[40],r10
8000a470:	fa ea 00 08 	ld.d	r10,sp[8]
8000a474:	e0 a0 0e 22 	rcall	8000c0b8 <__avr32_f64_to_s32>
8000a478:	51 6c       	stdsp	sp[0x58],r12
8000a47a:	e0 a0 0e 36 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a47e:	14 98       	mov	r8,r10
8000a480:	16 99       	mov	r9,r11
8000a482:	fa ea 00 08 	ld.d	r10,sp[8]
8000a486:	e0 a0 0c c1 	rcall	8000be08 <__avr32_f64_sub>
8000a48a:	fa eb 00 08 	st.d	sp[8],r10
8000a48e:	41 68       	lddsp	r8,sp[0x58]
8000a490:	2d 08       	sub	r8,-48
8000a492:	0a c8       	st.b	r5++,r8
8000a494:	41 39       	lddsp	r9,sp[0x4c]
8000a496:	2f f9       	sub	r9,-1
8000a498:	51 39       	stdsp	sp[0x4c],r9
8000a49a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a49e:	e0 a0 0e db 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a4a2:	e0 81 03 39 	brne	8000ab14 <_dtoa_r+0xbb4>
8000a4a6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4aa:	30 0a       	mov	r10,0
8000a4ac:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a4b0:	e0 a0 0c ac 	rcall	8000be08 <__avr32_f64_sub>
8000a4b4:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4b8:	e0 a0 0e ce 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a4bc:	fa ea 00 28 	ld.d	r10,sp[40]
8000a4c0:	30 08       	mov	r8,0
8000a4c2:	fc 19 40 24 	movh	r9,0x4024
8000a4c6:	e0 81 00 da 	brne	8000a67a <_dtoa_r+0x71a>
8000a4ca:	41 3c       	lddsp	r12,sp[0x4c]
8000a4cc:	08 3c       	cp.w	r12,r4
8000a4ce:	c5 f4       	brge	8000a58c <_dtoa_r+0x62c>
8000a4d0:	e0 a0 0b b0 	rcall	8000bc30 <__avr32_f64_mul>
8000a4d4:	30 08       	mov	r8,0
8000a4d6:	fa eb 00 28 	st.d	sp[40],r10
8000a4da:	fc 19 40 24 	movh	r9,0x4024
8000a4de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4e2:	e0 a0 0b a7 	rcall	8000bc30 <__avr32_f64_mul>
8000a4e6:	fa eb 00 08 	st.d	sp[8],r10
8000a4ea:	cc 3b       	rjmp	8000a470 <_dtoa_r+0x510>
8000a4ec:	40 85       	lddsp	r5,sp[0x20]
8000a4ee:	08 05       	add	r5,r4
8000a4f0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a4f4:	51 35       	stdsp	sp[0x4c],r5
8000a4f6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4fa:	40 85       	lddsp	r5,sp[0x20]
8000a4fc:	e0 a0 0b 9a 	rcall	8000bc30 <__avr32_f64_mul>
8000a500:	fa eb 00 28 	st.d	sp[40],r10
8000a504:	fa ea 00 08 	ld.d	r10,sp[8]
8000a508:	e0 a0 0d d8 	rcall	8000c0b8 <__avr32_f64_to_s32>
8000a50c:	51 6c       	stdsp	sp[0x58],r12
8000a50e:	e0 a0 0d ec 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a512:	14 98       	mov	r8,r10
8000a514:	16 99       	mov	r9,r11
8000a516:	fa ea 00 08 	ld.d	r10,sp[8]
8000a51a:	e0 a0 0c 77 	rcall	8000be08 <__avr32_f64_sub>
8000a51e:	fa eb 00 08 	st.d	sp[8],r10
8000a522:	41 68       	lddsp	r8,sp[0x58]
8000a524:	2d 08       	sub	r8,-48
8000a526:	0a c8       	st.b	r5++,r8
8000a528:	41 3c       	lddsp	r12,sp[0x4c]
8000a52a:	18 35       	cp.w	r5,r12
8000a52c:	c2 81       	brne	8000a57c <_dtoa_r+0x61c>
8000a52e:	30 08       	mov	r8,0
8000a530:	fc 19 3f e0 	movh	r9,0x3fe0
8000a534:	fa ea 00 28 	ld.d	r10,sp[40]
8000a538:	e0 a0 0d 36 	rcall	8000bfa4 <__avr32_f64_add>
8000a53c:	40 85       	lddsp	r5,sp[0x20]
8000a53e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a542:	08 05       	add	r5,r4
8000a544:	e0 a0 0e 88 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a548:	e0 81 00 99 	brne	8000a67a <_dtoa_r+0x71a>
8000a54c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a550:	30 0a       	mov	r10,0
8000a552:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a556:	e0 a0 0c 59 	rcall	8000be08 <__avr32_f64_sub>
8000a55a:	14 98       	mov	r8,r10
8000a55c:	16 99       	mov	r9,r11
8000a55e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a562:	e0 a0 0e 79 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a566:	c1 30       	breq	8000a58c <_dtoa_r+0x62c>
8000a568:	33 09       	mov	r9,48
8000a56a:	0a 98       	mov	r8,r5
8000a56c:	11 7a       	ld.ub	r10,--r8
8000a56e:	f2 0a 18 00 	cp.b	r10,r9
8000a572:	e0 81 02 d1 	brne	8000ab14 <_dtoa_r+0xbb4>
8000a576:	10 95       	mov	r5,r8
8000a578:	cf 9b       	rjmp	8000a56a <_dtoa_r+0x60a>
8000a57a:	d7 03       	nop
8000a57c:	30 08       	mov	r8,0
8000a57e:	fc 19 40 24 	movh	r9,0x4024
8000a582:	e0 a0 0b 57 	rcall	8000bc30 <__avr32_f64_mul>
8000a586:	fa eb 00 08 	st.d	sp[8],r10
8000a58a:	cb db       	rjmp	8000a504 <_dtoa_r+0x5a4>
8000a58c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a590:	fa eb 00 08 	st.d	sp[8],r10
8000a594:	58 e6       	cp.w	r6,14
8000a596:	5f ab       	srle	r11
8000a598:	41 8a       	lddsp	r10,sp[0x60]
8000a59a:	30 08       	mov	r8,0
8000a59c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a5a0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a5a4:	f0 09 18 00 	cp.b	r9,r8
8000a5a8:	e0 80 00 82 	breq	8000a6ac <_dtoa_r+0x74c>
8000a5ac:	40 ea       	lddsp	r10,sp[0x38]
8000a5ae:	58 01       	cp.w	r1,0
8000a5b0:	5f a9       	srle	r9
8000a5b2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a5b6:	fe ca c6 5a 	sub	r10,pc,-14758
8000a5ba:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a5be:	fa e5 00 10 	st.d	sp[16],r4
8000a5c2:	f0 09 18 00 	cp.b	r9,r8
8000a5c6:	c1 40       	breq	8000a5ee <_dtoa_r+0x68e>
8000a5c8:	58 01       	cp.w	r1,0
8000a5ca:	e0 81 01 77 	brne	8000a8b8 <_dtoa_r+0x958>
8000a5ce:	30 08       	mov	r8,0
8000a5d0:	fc 19 40 14 	movh	r9,0x4014
8000a5d4:	08 9a       	mov	r10,r4
8000a5d6:	0a 9b       	mov	r11,r5
8000a5d8:	e0 a0 0b 2c 	rcall	8000bc30 <__avr32_f64_mul>
8000a5dc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5e0:	e0 a0 0e 06 	rcall	8000c1ec <__avr32_f64_cmp_ge>
8000a5e4:	e0 81 01 6a 	brne	8000a8b8 <_dtoa_r+0x958>
8000a5e8:	02 92       	mov	r2,r1
8000a5ea:	e0 8f 01 72 	bral	8000a8ce <_dtoa_r+0x96e>
8000a5ee:	40 85       	lddsp	r5,sp[0x20]
8000a5f0:	30 14       	mov	r4,1
8000a5f2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a5f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5fa:	e0 a0 0e 61 	rcall	8000c2bc <__avr32_f64_div>
8000a5fe:	e0 a0 0d 5d 	rcall	8000c0b8 <__avr32_f64_to_s32>
8000a602:	18 92       	mov	r2,r12
8000a604:	e0 a0 0d 71 	rcall	8000c0e6 <__avr32_s32_to_f64>
8000a608:	fa e8 00 10 	ld.d	r8,sp[16]
8000a60c:	e0 a0 0b 12 	rcall	8000bc30 <__avr32_f64_mul>
8000a610:	14 98       	mov	r8,r10
8000a612:	16 99       	mov	r9,r11
8000a614:	fa ea 00 08 	ld.d	r10,sp[8]
8000a618:	e0 a0 0b f8 	rcall	8000be08 <__avr32_f64_sub>
8000a61c:	fa eb 00 08 	st.d	sp[8],r10
8000a620:	e4 c8 ff d0 	sub	r8,r2,-48
8000a624:	0a c8       	st.b	r5++,r8
8000a626:	fc 19 40 24 	movh	r9,0x4024
8000a62a:	30 08       	mov	r8,0
8000a62c:	02 34       	cp.w	r4,r1
8000a62e:	c3 31       	brne	8000a694 <_dtoa_r+0x734>
8000a630:	fa e8 00 08 	ld.d	r8,sp[8]
8000a634:	e0 a0 0c b8 	rcall	8000bfa4 <__avr32_f64_add>
8000a638:	16 91       	mov	r1,r11
8000a63a:	14 90       	mov	r0,r10
8000a63c:	14 98       	mov	r8,r10
8000a63e:	02 99       	mov	r9,r1
8000a640:	fa ea 00 10 	ld.d	r10,sp[16]
8000a644:	e0 a0 0e 08 	rcall	8000c254 <__avr32_f64_cmp_lt>
8000a648:	c1 a1       	brne	8000a67c <_dtoa_r+0x71c>
8000a64a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a64e:	00 9a       	mov	r10,r0
8000a650:	02 9b       	mov	r11,r1
8000a652:	e0 a0 0d ba 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000a656:	e0 80 02 5e 	breq	8000ab12 <_dtoa_r+0xbb2>
8000a65a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a65e:	c0 f1       	brne	8000a67c <_dtoa_r+0x71c>
8000a660:	e0 8f 02 59 	bral	8000ab12 <_dtoa_r+0xbb2>
8000a664:	40 8a       	lddsp	r10,sp[0x20]
8000a666:	14 38       	cp.w	r8,r10
8000a668:	c0 30       	breq	8000a66e <_dtoa_r+0x70e>
8000a66a:	10 95       	mov	r5,r8
8000a66c:	c0 98       	rjmp	8000a67e <_dtoa_r+0x71e>
8000a66e:	33 08       	mov	r8,48
8000a670:	40 89       	lddsp	r9,sp[0x20]
8000a672:	2f f6       	sub	r6,-1
8000a674:	b2 88       	st.b	r9[0x0],r8
8000a676:	40 88       	lddsp	r8,sp[0x20]
8000a678:	c0 88       	rjmp	8000a688 <_dtoa_r+0x728>
8000a67a:	40 66       	lddsp	r6,sp[0x18]
8000a67c:	33 99       	mov	r9,57
8000a67e:	0a 98       	mov	r8,r5
8000a680:	11 7a       	ld.ub	r10,--r8
8000a682:	f2 0a 18 00 	cp.b	r10,r9
8000a686:	ce f0       	breq	8000a664 <_dtoa_r+0x704>
8000a688:	50 66       	stdsp	sp[0x18],r6
8000a68a:	11 89       	ld.ub	r9,r8[0x0]
8000a68c:	2f f9       	sub	r9,-1
8000a68e:	b0 89       	st.b	r8[0x0],r9
8000a690:	e0 8f 02 42 	bral	8000ab14 <_dtoa_r+0xbb4>
8000a694:	e0 a0 0a ce 	rcall	8000bc30 <__avr32_f64_mul>
8000a698:	2f f4       	sub	r4,-1
8000a69a:	fa eb 00 08 	st.d	sp[8],r10
8000a69e:	30 08       	mov	r8,0
8000a6a0:	30 09       	mov	r9,0
8000a6a2:	e0 a0 0d 92 	rcall	8000c1c6 <__avr32_f64_cmp_eq>
8000a6a6:	ca 60       	breq	8000a5f2 <_dtoa_r+0x692>
8000a6a8:	e0 8f 02 35 	bral	8000ab12 <_dtoa_r+0xbb2>
8000a6ac:	40 d8       	lddsp	r8,sp[0x34]
8000a6ae:	58 08       	cp.w	r8,0
8000a6b0:	c0 51       	brne	8000a6ba <_dtoa_r+0x75a>
8000a6b2:	04 98       	mov	r8,r2
8000a6b4:	00 95       	mov	r5,r0
8000a6b6:	40 d4       	lddsp	r4,sp[0x34]
8000a6b8:	c3 78       	rjmp	8000a726 <_dtoa_r+0x7c6>
8000a6ba:	40 c5       	lddsp	r5,sp[0x30]
8000a6bc:	58 15       	cp.w	r5,1
8000a6be:	e0 89 00 0f 	brgt	8000a6dc <_dtoa_r+0x77c>
8000a6c2:	41 74       	lddsp	r4,sp[0x5c]
8000a6c4:	58 04       	cp.w	r4,0
8000a6c6:	c0 40       	breq	8000a6ce <_dtoa_r+0x76e>
8000a6c8:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a6cc:	c0 48       	rjmp	8000a6d4 <_dtoa_r+0x774>
8000a6ce:	41 99       	lddsp	r9,sp[0x64]
8000a6d0:	f2 09 11 36 	rsub	r9,r9,54
8000a6d4:	04 98       	mov	r8,r2
8000a6d6:	00 95       	mov	r5,r0
8000a6d8:	c1 c8       	rjmp	8000a710 <_dtoa_r+0x7b0>
8000a6da:	d7 03       	nop
8000a6dc:	e2 c8 00 01 	sub	r8,r1,1
8000a6e0:	58 01       	cp.w	r1,0
8000a6e2:	e0 05 17 40 	movge	r5,r0
8000a6e6:	e2 09 17 40 	movge	r9,r1
8000a6ea:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a6ee:	f9 b9 05 00 	movlt	r9,0
8000a6f2:	10 32       	cp.w	r2,r8
8000a6f4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a6f8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a6fc:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a700:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a704:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a708:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a70c:	f9 b8 05 00 	movlt	r8,0
8000a710:	40 4b       	lddsp	r11,sp[0x10]
8000a712:	12 0b       	add	r11,r9
8000a714:	50 08       	stdsp	sp[0x0],r8
8000a716:	50 4b       	stdsp	sp[0x10],r11
8000a718:	12 00       	add	r0,r9
8000a71a:	30 1b       	mov	r11,1
8000a71c:	0e 9c       	mov	r12,r7
8000a71e:	e0 a0 08 a7 	rcall	8000b86c <__i2b>
8000a722:	40 08       	lddsp	r8,sp[0x0]
8000a724:	18 94       	mov	r4,r12
8000a726:	40 4a       	lddsp	r10,sp[0x10]
8000a728:	58 05       	cp.w	r5,0
8000a72a:	5f 99       	srgt	r9
8000a72c:	58 0a       	cp.w	r10,0
8000a72e:	5f 9a       	srgt	r10
8000a730:	f5 e9 00 09 	and	r9,r10,r9
8000a734:	c0 80       	breq	8000a744 <_dtoa_r+0x7e4>
8000a736:	40 4c       	lddsp	r12,sp[0x10]
8000a738:	f8 05 0d 49 	min	r9,r12,r5
8000a73c:	12 1c       	sub	r12,r9
8000a73e:	12 10       	sub	r0,r9
8000a740:	50 4c       	stdsp	sp[0x10],r12
8000a742:	12 15       	sub	r5,r9
8000a744:	58 02       	cp.w	r2,0
8000a746:	e0 8a 00 27 	brle	8000a794 <_dtoa_r+0x834>
8000a74a:	40 db       	lddsp	r11,sp[0x34]
8000a74c:	58 0b       	cp.w	r11,0
8000a74e:	c1 d0       	breq	8000a788 <_dtoa_r+0x828>
8000a750:	58 08       	cp.w	r8,0
8000a752:	e0 8a 00 17 	brle	8000a780 <_dtoa_r+0x820>
8000a756:	10 9a       	mov	r10,r8
8000a758:	50 08       	stdsp	sp[0x0],r8
8000a75a:	08 9b       	mov	r11,r4
8000a75c:	0e 9c       	mov	r12,r7
8000a75e:	e0 a0 08 cd 	rcall	8000b8f8 <__pow5mult>
8000a762:	06 9a       	mov	r10,r3
8000a764:	18 9b       	mov	r11,r12
8000a766:	18 94       	mov	r4,r12
8000a768:	0e 9c       	mov	r12,r7
8000a76a:	e0 a0 08 01 	rcall	8000b76c <__multiply>
8000a76e:	18 99       	mov	r9,r12
8000a770:	06 9b       	mov	r11,r3
8000a772:	50 19       	stdsp	sp[0x4],r9
8000a774:	0e 9c       	mov	r12,r7
8000a776:	e0 a0 06 ad 	rcall	8000b4d0 <_Bfree>
8000a77a:	40 19       	lddsp	r9,sp[0x4]
8000a77c:	40 08       	lddsp	r8,sp[0x0]
8000a77e:	12 93       	mov	r3,r9
8000a780:	e4 08 01 0a 	sub	r10,r2,r8
8000a784:	c0 80       	breq	8000a794 <_dtoa_r+0x834>
8000a786:	c0 28       	rjmp	8000a78a <_dtoa_r+0x82a>
8000a788:	04 9a       	mov	r10,r2
8000a78a:	06 9b       	mov	r11,r3
8000a78c:	0e 9c       	mov	r12,r7
8000a78e:	e0 a0 08 b5 	rcall	8000b8f8 <__pow5mult>
8000a792:	18 93       	mov	r3,r12
8000a794:	30 1b       	mov	r11,1
8000a796:	0e 9c       	mov	r12,r7
8000a798:	e0 a0 08 6a 	rcall	8000b86c <__i2b>
8000a79c:	41 1a       	lddsp	r10,sp[0x44]
8000a79e:	18 92       	mov	r2,r12
8000a7a0:	58 0a       	cp.w	r10,0
8000a7a2:	e0 8a 00 07 	brle	8000a7b0 <_dtoa_r+0x850>
8000a7a6:	18 9b       	mov	r11,r12
8000a7a8:	0e 9c       	mov	r12,r7
8000a7aa:	e0 a0 08 a7 	rcall	8000b8f8 <__pow5mult>
8000a7ae:	18 92       	mov	r2,r12
8000a7b0:	40 c9       	lddsp	r9,sp[0x30]
8000a7b2:	58 19       	cp.w	r9,1
8000a7b4:	e0 89 00 14 	brgt	8000a7dc <_dtoa_r+0x87c>
8000a7b8:	40 38       	lddsp	r8,sp[0xc]
8000a7ba:	58 08       	cp.w	r8,0
8000a7bc:	c1 01       	brne	8000a7dc <_dtoa_r+0x87c>
8000a7be:	40 29       	lddsp	r9,sp[0x8]
8000a7c0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a7c4:	c0 c1       	brne	8000a7dc <_dtoa_r+0x87c>
8000a7c6:	12 98       	mov	r8,r9
8000a7c8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a7cc:	c0 80       	breq	8000a7dc <_dtoa_r+0x87c>
8000a7ce:	40 4c       	lddsp	r12,sp[0x10]
8000a7d0:	30 1b       	mov	r11,1
8000a7d2:	2f fc       	sub	r12,-1
8000a7d4:	2f f0       	sub	r0,-1
8000a7d6:	50 4c       	stdsp	sp[0x10],r12
8000a7d8:	50 6b       	stdsp	sp[0x18],r11
8000a7da:	c0 38       	rjmp	8000a7e0 <_dtoa_r+0x880>
8000a7dc:	30 0a       	mov	r10,0
8000a7de:	50 6a       	stdsp	sp[0x18],r10
8000a7e0:	41 19       	lddsp	r9,sp[0x44]
8000a7e2:	58 09       	cp.w	r9,0
8000a7e4:	c0 31       	brne	8000a7ea <_dtoa_r+0x88a>
8000a7e6:	30 1c       	mov	r12,1
8000a7e8:	c0 98       	rjmp	8000a7fa <_dtoa_r+0x89a>
8000a7ea:	64 48       	ld.w	r8,r2[0x10]
8000a7ec:	2f c8       	sub	r8,-4
8000a7ee:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a7f2:	e0 a0 05 df 	rcall	8000b3b0 <__hi0bits>
8000a7f6:	f8 0c 11 20 	rsub	r12,r12,32
8000a7fa:	40 4b       	lddsp	r11,sp[0x10]
8000a7fc:	f8 0b 00 08 	add	r8,r12,r11
8000a800:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a804:	c0 c0       	breq	8000a81c <_dtoa_r+0x8bc>
8000a806:	f0 08 11 20 	rsub	r8,r8,32
8000a80a:	58 48       	cp.w	r8,4
8000a80c:	e0 8a 00 06 	brle	8000a818 <_dtoa_r+0x8b8>
8000a810:	20 48       	sub	r8,4
8000a812:	10 0b       	add	r11,r8
8000a814:	50 4b       	stdsp	sp[0x10],r11
8000a816:	c0 78       	rjmp	8000a824 <_dtoa_r+0x8c4>
8000a818:	58 48       	cp.w	r8,4
8000a81a:	c0 70       	breq	8000a828 <_dtoa_r+0x8c8>
8000a81c:	40 4a       	lddsp	r10,sp[0x10]
8000a81e:	2e 48       	sub	r8,-28
8000a820:	10 0a       	add	r10,r8
8000a822:	50 4a       	stdsp	sp[0x10],r10
8000a824:	10 00       	add	r0,r8
8000a826:	10 05       	add	r5,r8
8000a828:	58 00       	cp.w	r0,0
8000a82a:	e0 8a 00 08 	brle	8000a83a <_dtoa_r+0x8da>
8000a82e:	06 9b       	mov	r11,r3
8000a830:	00 9a       	mov	r10,r0
8000a832:	0e 9c       	mov	r12,r7
8000a834:	e0 a0 07 58 	rcall	8000b6e4 <__lshift>
8000a838:	18 93       	mov	r3,r12
8000a83a:	40 49       	lddsp	r9,sp[0x10]
8000a83c:	58 09       	cp.w	r9,0
8000a83e:	e0 8a 00 08 	brle	8000a84e <_dtoa_r+0x8ee>
8000a842:	04 9b       	mov	r11,r2
8000a844:	12 9a       	mov	r10,r9
8000a846:	0e 9c       	mov	r12,r7
8000a848:	e0 a0 07 4e 	rcall	8000b6e4 <__lshift>
8000a84c:	18 92       	mov	r2,r12
8000a84e:	41 48       	lddsp	r8,sp[0x50]
8000a850:	58 08       	cp.w	r8,0
8000a852:	c1 b0       	breq	8000a888 <_dtoa_r+0x928>
8000a854:	04 9b       	mov	r11,r2
8000a856:	06 9c       	mov	r12,r3
8000a858:	e0 a0 06 23 	rcall	8000b49e <__mcmp>
8000a85c:	c1 64       	brge	8000a888 <_dtoa_r+0x928>
8000a85e:	06 9b       	mov	r11,r3
8000a860:	30 09       	mov	r9,0
8000a862:	30 aa       	mov	r10,10
8000a864:	0e 9c       	mov	r12,r7
8000a866:	e0 a0 08 0b 	rcall	8000b87c <__multadd>
8000a86a:	20 16       	sub	r6,1
8000a86c:	18 93       	mov	r3,r12
8000a86e:	40 dc       	lddsp	r12,sp[0x34]
8000a870:	58 0c       	cp.w	r12,0
8000a872:	c0 31       	brne	8000a878 <_dtoa_r+0x918>
8000a874:	40 91       	lddsp	r1,sp[0x24]
8000a876:	c0 98       	rjmp	8000a888 <_dtoa_r+0x928>
8000a878:	08 9b       	mov	r11,r4
8000a87a:	40 91       	lddsp	r1,sp[0x24]
8000a87c:	30 09       	mov	r9,0
8000a87e:	30 aa       	mov	r10,10
8000a880:	0e 9c       	mov	r12,r7
8000a882:	e0 a0 07 fd 	rcall	8000b87c <__multadd>
8000a886:	18 94       	mov	r4,r12
8000a888:	58 01       	cp.w	r1,0
8000a88a:	5f a9       	srle	r9
8000a88c:	40 cb       	lddsp	r11,sp[0x30]
8000a88e:	58 2b       	cp.w	r11,2
8000a890:	5f 98       	srgt	r8
8000a892:	f3 e8 00 08 	and	r8,r9,r8
8000a896:	c2 50       	breq	8000a8e0 <_dtoa_r+0x980>
8000a898:	58 01       	cp.w	r1,0
8000a89a:	c1 11       	brne	8000a8bc <_dtoa_r+0x95c>
8000a89c:	04 9b       	mov	r11,r2
8000a89e:	02 99       	mov	r9,r1
8000a8a0:	30 5a       	mov	r10,5
8000a8a2:	0e 9c       	mov	r12,r7
8000a8a4:	e0 a0 07 ec 	rcall	8000b87c <__multadd>
8000a8a8:	18 92       	mov	r2,r12
8000a8aa:	18 9b       	mov	r11,r12
8000a8ac:	06 9c       	mov	r12,r3
8000a8ae:	e0 a0 05 f8 	rcall	8000b49e <__mcmp>
8000a8b2:	e0 89 00 0f 	brgt	8000a8d0 <_dtoa_r+0x970>
8000a8b6:	c0 38       	rjmp	8000a8bc <_dtoa_r+0x95c>
8000a8b8:	30 02       	mov	r2,0
8000a8ba:	04 94       	mov	r4,r2
8000a8bc:	40 ea       	lddsp	r10,sp[0x38]
8000a8be:	30 09       	mov	r9,0
8000a8c0:	5c da       	com	r10
8000a8c2:	40 85       	lddsp	r5,sp[0x20]
8000a8c4:	50 6a       	stdsp	sp[0x18],r10
8000a8c6:	50 49       	stdsp	sp[0x10],r9
8000a8c8:	c0 f9       	rjmp	8000aae6 <_dtoa_r+0xb86>
8000a8ca:	08 92       	mov	r2,r4
8000a8cc:	40 66       	lddsp	r6,sp[0x18]
8000a8ce:	04 94       	mov	r4,r2
8000a8d0:	2f f6       	sub	r6,-1
8000a8d2:	50 66       	stdsp	sp[0x18],r6
8000a8d4:	33 18       	mov	r8,49
8000a8d6:	40 85       	lddsp	r5,sp[0x20]
8000a8d8:	0a c8       	st.b	r5++,r8
8000a8da:	30 08       	mov	r8,0
8000a8dc:	50 48       	stdsp	sp[0x10],r8
8000a8de:	c0 49       	rjmp	8000aae6 <_dtoa_r+0xb86>
8000a8e0:	40 dc       	lddsp	r12,sp[0x34]
8000a8e2:	58 0c       	cp.w	r12,0
8000a8e4:	e0 80 00 b5 	breq	8000aa4e <_dtoa_r+0xaee>
8000a8e8:	58 05       	cp.w	r5,0
8000a8ea:	e0 8a 00 08 	brle	8000a8fa <_dtoa_r+0x99a>
8000a8ee:	08 9b       	mov	r11,r4
8000a8f0:	0a 9a       	mov	r10,r5
8000a8f2:	0e 9c       	mov	r12,r7
8000a8f4:	e0 a0 06 f8 	rcall	8000b6e4 <__lshift>
8000a8f8:	18 94       	mov	r4,r12
8000a8fa:	40 6b       	lddsp	r11,sp[0x18]
8000a8fc:	58 0b       	cp.w	r11,0
8000a8fe:	c0 31       	brne	8000a904 <_dtoa_r+0x9a4>
8000a900:	08 9c       	mov	r12,r4
8000a902:	c1 38       	rjmp	8000a928 <_dtoa_r+0x9c8>
8000a904:	68 1b       	ld.w	r11,r4[0x4]
8000a906:	0e 9c       	mov	r12,r7
8000a908:	e0 a0 05 fe 	rcall	8000b504 <_Balloc>
8000a90c:	68 4a       	ld.w	r10,r4[0x10]
8000a90e:	18 95       	mov	r5,r12
8000a910:	e8 cb ff f4 	sub	r11,r4,-12
8000a914:	2f ea       	sub	r10,-2
8000a916:	2f 4c       	sub	r12,-12
8000a918:	a3 6a       	lsl	r10,0x2
8000a91a:	fe b0 e6 4f 	rcall	800075b8 <memcpy>
8000a91e:	0a 9b       	mov	r11,r5
8000a920:	30 1a       	mov	r10,1
8000a922:	0e 9c       	mov	r12,r7
8000a924:	e0 a0 06 e0 	rcall	8000b6e4 <__lshift>
8000a928:	50 44       	stdsp	sp[0x10],r4
8000a92a:	40 3a       	lddsp	r10,sp[0xc]
8000a92c:	30 19       	mov	r9,1
8000a92e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a932:	18 94       	mov	r4,r12
8000a934:	50 da       	stdsp	sp[0x34],r10
8000a936:	40 85       	lddsp	r5,sp[0x20]
8000a938:	50 99       	stdsp	sp[0x24],r9
8000a93a:	50 26       	stdsp	sp[0x8],r6
8000a93c:	50 e1       	stdsp	sp[0x38],r1
8000a93e:	04 9b       	mov	r11,r2
8000a940:	06 9c       	mov	r12,r3
8000a942:	fe b0 fa 7f 	rcall	80009e40 <quorem>
8000a946:	40 4b       	lddsp	r11,sp[0x10]
8000a948:	f8 c0 ff d0 	sub	r0,r12,-48
8000a94c:	06 9c       	mov	r12,r3
8000a94e:	e0 a0 05 a8 	rcall	8000b49e <__mcmp>
8000a952:	08 9a       	mov	r10,r4
8000a954:	50 6c       	stdsp	sp[0x18],r12
8000a956:	04 9b       	mov	r11,r2
8000a958:	0e 9c       	mov	r12,r7
8000a95a:	e0 a0 06 5d 	rcall	8000b614 <__mdiff>
8000a95e:	18 91       	mov	r1,r12
8000a960:	78 38       	ld.w	r8,r12[0xc]
8000a962:	58 08       	cp.w	r8,0
8000a964:	c0 30       	breq	8000a96a <_dtoa_r+0xa0a>
8000a966:	30 16       	mov	r6,1
8000a968:	c0 68       	rjmp	8000a974 <_dtoa_r+0xa14>
8000a96a:	18 9b       	mov	r11,r12
8000a96c:	06 9c       	mov	r12,r3
8000a96e:	e0 a0 05 98 	rcall	8000b49e <__mcmp>
8000a972:	18 96       	mov	r6,r12
8000a974:	0e 9c       	mov	r12,r7
8000a976:	02 9b       	mov	r11,r1
8000a978:	e0 a0 05 ac 	rcall	8000b4d0 <_Bfree>
8000a97c:	40 cc       	lddsp	r12,sp[0x30]
8000a97e:	ed ec 10 08 	or	r8,r6,r12
8000a982:	c0 d1       	brne	8000a99c <_dtoa_r+0xa3c>
8000a984:	40 db       	lddsp	r11,sp[0x34]
8000a986:	58 0b       	cp.w	r11,0
8000a988:	c0 a1       	brne	8000a99c <_dtoa_r+0xa3c>
8000a98a:	40 26       	lddsp	r6,sp[0x8]
8000a98c:	e0 40 00 39 	cp.w	r0,57
8000a990:	c3 00       	breq	8000a9f0 <_dtoa_r+0xa90>
8000a992:	40 6a       	lddsp	r10,sp[0x18]
8000a994:	58 0a       	cp.w	r10,0
8000a996:	e0 89 00 24 	brgt	8000a9de <_dtoa_r+0xa7e>
8000a99a:	c2 f8       	rjmp	8000a9f8 <_dtoa_r+0xa98>
8000a99c:	40 69       	lddsp	r9,sp[0x18]
8000a99e:	58 09       	cp.w	r9,0
8000a9a0:	c0 85       	brlt	8000a9b0 <_dtoa_r+0xa50>
8000a9a2:	12 98       	mov	r8,r9
8000a9a4:	40 cc       	lddsp	r12,sp[0x30]
8000a9a6:	18 48       	or	r8,r12
8000a9a8:	c1 d1       	brne	8000a9e2 <_dtoa_r+0xa82>
8000a9aa:	40 db       	lddsp	r11,sp[0x34]
8000a9ac:	58 0b       	cp.w	r11,0
8000a9ae:	c1 a1       	brne	8000a9e2 <_dtoa_r+0xa82>
8000a9b0:	0c 99       	mov	r9,r6
8000a9b2:	40 26       	lddsp	r6,sp[0x8]
8000a9b4:	58 09       	cp.w	r9,0
8000a9b6:	e0 8a 00 21 	brle	8000a9f8 <_dtoa_r+0xa98>
8000a9ba:	06 9b       	mov	r11,r3
8000a9bc:	30 1a       	mov	r10,1
8000a9be:	0e 9c       	mov	r12,r7
8000a9c0:	e0 a0 06 92 	rcall	8000b6e4 <__lshift>
8000a9c4:	04 9b       	mov	r11,r2
8000a9c6:	18 93       	mov	r3,r12
8000a9c8:	e0 a0 05 6b 	rcall	8000b49e <__mcmp>
8000a9cc:	e0 89 00 06 	brgt	8000a9d8 <_dtoa_r+0xa78>
8000a9d0:	c1 41       	brne	8000a9f8 <_dtoa_r+0xa98>
8000a9d2:	ed b0 00 00 	bld	r0,0x0
8000a9d6:	c1 11       	brne	8000a9f8 <_dtoa_r+0xa98>
8000a9d8:	e0 40 00 39 	cp.w	r0,57
8000a9dc:	c0 a0       	breq	8000a9f0 <_dtoa_r+0xa90>
8000a9de:	2f f0       	sub	r0,-1
8000a9e0:	c0 c8       	rjmp	8000a9f8 <_dtoa_r+0xa98>
8000a9e2:	58 06       	cp.w	r6,0
8000a9e4:	e0 8a 00 0c 	brle	8000a9fc <_dtoa_r+0xa9c>
8000a9e8:	40 26       	lddsp	r6,sp[0x8]
8000a9ea:	e0 40 00 39 	cp.w	r0,57
8000a9ee:	c0 41       	brne	8000a9f6 <_dtoa_r+0xa96>
8000a9f0:	33 98       	mov	r8,57
8000a9f2:	0a c8       	st.b	r5++,r8
8000a9f4:	c6 78       	rjmp	8000aac2 <_dtoa_r+0xb62>
8000a9f6:	2f f0       	sub	r0,-1
8000a9f8:	0a c0       	st.b	r5++,r0
8000a9fa:	c7 58       	rjmp	8000aae4 <_dtoa_r+0xb84>
8000a9fc:	0a c0       	st.b	r5++,r0
8000a9fe:	40 9a       	lddsp	r10,sp[0x24]
8000aa00:	40 e9       	lddsp	r9,sp[0x38]
8000aa02:	12 3a       	cp.w	r10,r9
8000aa04:	c4 30       	breq	8000aa8a <_dtoa_r+0xb2a>
8000aa06:	06 9b       	mov	r11,r3
8000aa08:	30 09       	mov	r9,0
8000aa0a:	30 aa       	mov	r10,10
8000aa0c:	0e 9c       	mov	r12,r7
8000aa0e:	e0 a0 07 37 	rcall	8000b87c <__multadd>
8000aa12:	40 48       	lddsp	r8,sp[0x10]
8000aa14:	18 93       	mov	r3,r12
8000aa16:	08 38       	cp.w	r8,r4
8000aa18:	c0 91       	brne	8000aa2a <_dtoa_r+0xaca>
8000aa1a:	10 9b       	mov	r11,r8
8000aa1c:	30 09       	mov	r9,0
8000aa1e:	30 aa       	mov	r10,10
8000aa20:	0e 9c       	mov	r12,r7
8000aa22:	e0 a0 07 2d 	rcall	8000b87c <__multadd>
8000aa26:	50 4c       	stdsp	sp[0x10],r12
8000aa28:	c0 e8       	rjmp	8000aa44 <_dtoa_r+0xae4>
8000aa2a:	40 4b       	lddsp	r11,sp[0x10]
8000aa2c:	30 09       	mov	r9,0
8000aa2e:	30 aa       	mov	r10,10
8000aa30:	0e 9c       	mov	r12,r7
8000aa32:	e0 a0 07 25 	rcall	8000b87c <__multadd>
8000aa36:	08 9b       	mov	r11,r4
8000aa38:	50 4c       	stdsp	sp[0x10],r12
8000aa3a:	30 09       	mov	r9,0
8000aa3c:	30 aa       	mov	r10,10
8000aa3e:	0e 9c       	mov	r12,r7
8000aa40:	e0 a0 07 1e 	rcall	8000b87c <__multadd>
8000aa44:	18 94       	mov	r4,r12
8000aa46:	40 9c       	lddsp	r12,sp[0x24]
8000aa48:	2f fc       	sub	r12,-1
8000aa4a:	50 9c       	stdsp	sp[0x24],r12
8000aa4c:	c7 9b       	rjmp	8000a93e <_dtoa_r+0x9de>
8000aa4e:	30 18       	mov	r8,1
8000aa50:	06 90       	mov	r0,r3
8000aa52:	40 85       	lddsp	r5,sp[0x20]
8000aa54:	08 93       	mov	r3,r4
8000aa56:	0c 94       	mov	r4,r6
8000aa58:	10 96       	mov	r6,r8
8000aa5a:	04 9b       	mov	r11,r2
8000aa5c:	00 9c       	mov	r12,r0
8000aa5e:	fe b0 f9 f1 	rcall	80009e40 <quorem>
8000aa62:	2d 0c       	sub	r12,-48
8000aa64:	0a cc       	st.b	r5++,r12
8000aa66:	02 36       	cp.w	r6,r1
8000aa68:	c0 a4       	brge	8000aa7c <_dtoa_r+0xb1c>
8000aa6a:	00 9b       	mov	r11,r0
8000aa6c:	30 09       	mov	r9,0
8000aa6e:	30 aa       	mov	r10,10
8000aa70:	0e 9c       	mov	r12,r7
8000aa72:	2f f6       	sub	r6,-1
8000aa74:	e0 a0 07 04 	rcall	8000b87c <__multadd>
8000aa78:	18 90       	mov	r0,r12
8000aa7a:	cf 0b       	rjmp	8000aa5a <_dtoa_r+0xafa>
8000aa7c:	08 96       	mov	r6,r4
8000aa7e:	30 0b       	mov	r11,0
8000aa80:	06 94       	mov	r4,r3
8000aa82:	50 4b       	stdsp	sp[0x10],r11
8000aa84:	00 93       	mov	r3,r0
8000aa86:	18 90       	mov	r0,r12
8000aa88:	c0 28       	rjmp	8000aa8c <_dtoa_r+0xb2c>
8000aa8a:	40 26       	lddsp	r6,sp[0x8]
8000aa8c:	06 9b       	mov	r11,r3
8000aa8e:	30 1a       	mov	r10,1
8000aa90:	0e 9c       	mov	r12,r7
8000aa92:	e0 a0 06 29 	rcall	8000b6e4 <__lshift>
8000aa96:	04 9b       	mov	r11,r2
8000aa98:	18 93       	mov	r3,r12
8000aa9a:	e0 a0 05 02 	rcall	8000b49e <__mcmp>
8000aa9e:	e0 89 00 12 	brgt	8000aac2 <_dtoa_r+0xb62>
8000aaa2:	c1 b1       	brne	8000aad8 <_dtoa_r+0xb78>
8000aaa4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aaa8:	c0 d1       	brne	8000aac2 <_dtoa_r+0xb62>
8000aaaa:	c1 78       	rjmp	8000aad8 <_dtoa_r+0xb78>
8000aaac:	40 89       	lddsp	r9,sp[0x20]
8000aaae:	12 38       	cp.w	r8,r9
8000aab0:	c0 30       	breq	8000aab6 <_dtoa_r+0xb56>
8000aab2:	10 95       	mov	r5,r8
8000aab4:	c0 88       	rjmp	8000aac4 <_dtoa_r+0xb64>
8000aab6:	2f f6       	sub	r6,-1
8000aab8:	50 66       	stdsp	sp[0x18],r6
8000aaba:	33 18       	mov	r8,49
8000aabc:	40 8c       	lddsp	r12,sp[0x20]
8000aabe:	b8 88       	st.b	r12[0x0],r8
8000aac0:	c1 38       	rjmp	8000aae6 <_dtoa_r+0xb86>
8000aac2:	33 9a       	mov	r10,57
8000aac4:	0a 98       	mov	r8,r5
8000aac6:	11 79       	ld.ub	r9,--r8
8000aac8:	f4 09 18 00 	cp.b	r9,r10
8000aacc:	cf 00       	breq	8000aaac <_dtoa_r+0xb4c>
8000aace:	2f f9       	sub	r9,-1
8000aad0:	b0 89       	st.b	r8[0x0],r9
8000aad2:	c0 98       	rjmp	8000aae4 <_dtoa_r+0xb84>
8000aad4:	10 95       	mov	r5,r8
8000aad6:	c0 28       	rjmp	8000aada <_dtoa_r+0xb7a>
8000aad8:	33 09       	mov	r9,48
8000aada:	0a 98       	mov	r8,r5
8000aadc:	11 7a       	ld.ub	r10,--r8
8000aade:	f2 0a 18 00 	cp.b	r10,r9
8000aae2:	cf 90       	breq	8000aad4 <_dtoa_r+0xb74>
8000aae4:	50 66       	stdsp	sp[0x18],r6
8000aae6:	04 9b       	mov	r11,r2
8000aae8:	0e 9c       	mov	r12,r7
8000aaea:	e0 a0 04 f3 	rcall	8000b4d0 <_Bfree>
8000aaee:	58 04       	cp.w	r4,0
8000aaf0:	c1 20       	breq	8000ab14 <_dtoa_r+0xbb4>
8000aaf2:	40 4b       	lddsp	r11,sp[0x10]
8000aaf4:	08 3b       	cp.w	r11,r4
8000aaf6:	5f 19       	srne	r9
8000aaf8:	58 0b       	cp.w	r11,0
8000aafa:	5f 18       	srne	r8
8000aafc:	f3 e8 00 08 	and	r8,r9,r8
8000ab00:	c0 40       	breq	8000ab08 <_dtoa_r+0xba8>
8000ab02:	0e 9c       	mov	r12,r7
8000ab04:	e0 a0 04 e6 	rcall	8000b4d0 <_Bfree>
8000ab08:	08 9b       	mov	r11,r4
8000ab0a:	0e 9c       	mov	r12,r7
8000ab0c:	e0 a0 04 e2 	rcall	8000b4d0 <_Bfree>
8000ab10:	c0 28       	rjmp	8000ab14 <_dtoa_r+0xbb4>
8000ab12:	50 66       	stdsp	sp[0x18],r6
8000ab14:	0e 9c       	mov	r12,r7
8000ab16:	06 9b       	mov	r11,r3
8000ab18:	e0 a0 04 dc 	rcall	8000b4d0 <_Bfree>
8000ab1c:	30 08       	mov	r8,0
8000ab1e:	aa 88       	st.b	r5[0x0],r8
8000ab20:	40 68       	lddsp	r8,sp[0x18]
8000ab22:	41 5a       	lddsp	r10,sp[0x54]
8000ab24:	2f f8       	sub	r8,-1
8000ab26:	41 29       	lddsp	r9,sp[0x48]
8000ab28:	95 08       	st.w	r10[0x0],r8
8000ab2a:	40 8c       	lddsp	r12,sp[0x20]
8000ab2c:	58 09       	cp.w	r9,0
8000ab2e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ab32:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ab36:	2e 6d       	sub	sp,-104
8000ab38:	d8 32       	popm	r0-r7,pc
8000ab3a:	d7 03       	nop

8000ab3c <__errno>:
8000ab3c:	e0 68 0a 3c 	mov	r8,2620
8000ab40:	70 0c       	ld.w	r12,r8[0x0]
8000ab42:	2f 4c       	sub	r12,-12
8000ab44:	5e fc       	retal	r12
8000ab46:	d7 03       	nop

8000ab48 <_fflush_r>:
8000ab48:	d4 21       	pushm	r4-r7,lr
8000ab4a:	16 97       	mov	r7,r11
8000ab4c:	18 96       	mov	r6,r12
8000ab4e:	76 48       	ld.w	r8,r11[0x10]
8000ab50:	58 08       	cp.w	r8,0
8000ab52:	c7 f0       	breq	8000ac50 <_fflush_r+0x108>
8000ab54:	58 0c       	cp.w	r12,0
8000ab56:	c0 50       	breq	8000ab60 <_fflush_r+0x18>
8000ab58:	78 68       	ld.w	r8,r12[0x18]
8000ab5a:	58 08       	cp.w	r8,0
8000ab5c:	c0 21       	brne	8000ab60 <_fflush_r+0x18>
8000ab5e:	cc dc       	rcall	8000acf8 <__sinit>
8000ab60:	fe c8 cc b4 	sub	r8,pc,-13132
8000ab64:	10 37       	cp.w	r7,r8
8000ab66:	c0 31       	brne	8000ab6c <_fflush_r+0x24>
8000ab68:	6c 07       	ld.w	r7,r6[0x0]
8000ab6a:	c0 c8       	rjmp	8000ab82 <_fflush_r+0x3a>
8000ab6c:	fe c8 cc a0 	sub	r8,pc,-13152
8000ab70:	10 37       	cp.w	r7,r8
8000ab72:	c0 31       	brne	8000ab78 <_fflush_r+0x30>
8000ab74:	6c 17       	ld.w	r7,r6[0x4]
8000ab76:	c0 68       	rjmp	8000ab82 <_fflush_r+0x3a>
8000ab78:	fe c8 cc 8c 	sub	r8,pc,-13172
8000ab7c:	10 37       	cp.w	r7,r8
8000ab7e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ab82:	8e 6a       	ld.sh	r10,r7[0xc]
8000ab84:	14 98       	mov	r8,r10
8000ab86:	ed ba 00 03 	bld	r10,0x3
8000ab8a:	c4 20       	breq	8000ac0e <_fflush_r+0xc6>
8000ab8c:	ab ba       	sbr	r10,0xb
8000ab8e:	ae 6a       	st.h	r7[0xc],r10
8000ab90:	6e 18       	ld.w	r8,r7[0x4]
8000ab92:	58 08       	cp.w	r8,0
8000ab94:	e0 89 00 06 	brgt	8000aba0 <_fflush_r+0x58>
8000ab98:	6f 08       	ld.w	r8,r7[0x40]
8000ab9a:	58 08       	cp.w	r8,0
8000ab9c:	e0 8a 00 5a 	brle	8000ac50 <_fflush_r+0x108>
8000aba0:	6e b8       	ld.w	r8,r7[0x2c]
8000aba2:	58 08       	cp.w	r8,0
8000aba4:	c5 60       	breq	8000ac50 <_fflush_r+0x108>
8000aba6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000abaa:	c0 30       	breq	8000abb0 <_fflush_r+0x68>
8000abac:	6f 55       	ld.w	r5,r7[0x54]
8000abae:	c0 f8       	rjmp	8000abcc <_fflush_r+0x84>
8000abb0:	30 19       	mov	r9,1
8000abb2:	6e 8b       	ld.w	r11,r7[0x20]
8000abb4:	0c 9c       	mov	r12,r6
8000abb6:	5d 18       	icall	r8
8000abb8:	18 95       	mov	r5,r12
8000abba:	5b fc       	cp.w	r12,-1
8000abbc:	c0 81       	brne	8000abcc <_fflush_r+0x84>
8000abbe:	6c 38       	ld.w	r8,r6[0xc]
8000abc0:	59 d8       	cp.w	r8,29
8000abc2:	c4 70       	breq	8000ac50 <_fflush_r+0x108>
8000abc4:	8e 68       	ld.sh	r8,r7[0xc]
8000abc6:	a7 a8       	sbr	r8,0x6
8000abc8:	ae 68       	st.h	r7[0xc],r8
8000abca:	d8 22       	popm	r4-r7,pc
8000abcc:	8e 68       	ld.sh	r8,r7[0xc]
8000abce:	ed b8 00 02 	bld	r8,0x2
8000abd2:	c0 91       	brne	8000abe4 <_fflush_r+0x9c>
8000abd4:	6e 18       	ld.w	r8,r7[0x4]
8000abd6:	10 15       	sub	r5,r8
8000abd8:	6e d8       	ld.w	r8,r7[0x34]
8000abda:	58 08       	cp.w	r8,0
8000abdc:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000abe0:	eb d8 e1 15 	subne	r5,r5,r8
8000abe4:	6e b8       	ld.w	r8,r7[0x2c]
8000abe6:	0c 9c       	mov	r12,r6
8000abe8:	30 09       	mov	r9,0
8000abea:	0a 9a       	mov	r10,r5
8000abec:	6e 8b       	ld.w	r11,r7[0x20]
8000abee:	5d 18       	icall	r8
8000abf0:	8e 68       	ld.sh	r8,r7[0xc]
8000abf2:	0a 3c       	cp.w	r12,r5
8000abf4:	c2 61       	brne	8000ac40 <_fflush_r+0xf8>
8000abf6:	ab d8       	cbr	r8,0xb
8000abf8:	30 0c       	mov	r12,0
8000abfa:	6e 49       	ld.w	r9,r7[0x10]
8000abfc:	ae 68       	st.h	r7[0xc],r8
8000abfe:	8f 1c       	st.w	r7[0x4],r12
8000ac00:	8f 09       	st.w	r7[0x0],r9
8000ac02:	ed b8 00 0c 	bld	r8,0xc
8000ac06:	c2 51       	brne	8000ac50 <_fflush_r+0x108>
8000ac08:	ef 45 00 54 	st.w	r7[84],r5
8000ac0c:	d8 22       	popm	r4-r7,pc
8000ac0e:	6e 45       	ld.w	r5,r7[0x10]
8000ac10:	58 05       	cp.w	r5,0
8000ac12:	c1 f0       	breq	8000ac50 <_fflush_r+0x108>
8000ac14:	6e 04       	ld.w	r4,r7[0x0]
8000ac16:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ac1a:	8f 05       	st.w	r7[0x0],r5
8000ac1c:	f9 b8 01 00 	movne	r8,0
8000ac20:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ac24:	0a 14       	sub	r4,r5
8000ac26:	8f 28       	st.w	r7[0x8],r8
8000ac28:	c1 18       	rjmp	8000ac4a <_fflush_r+0x102>
8000ac2a:	08 99       	mov	r9,r4
8000ac2c:	0a 9a       	mov	r10,r5
8000ac2e:	6e a8       	ld.w	r8,r7[0x28]
8000ac30:	6e 8b       	ld.w	r11,r7[0x20]
8000ac32:	0c 9c       	mov	r12,r6
8000ac34:	5d 18       	icall	r8
8000ac36:	18 14       	sub	r4,r12
8000ac38:	58 0c       	cp.w	r12,0
8000ac3a:	e0 89 00 07 	brgt	8000ac48 <_fflush_r+0x100>
8000ac3e:	8e 68       	ld.sh	r8,r7[0xc]
8000ac40:	a7 a8       	sbr	r8,0x6
8000ac42:	3f fc       	mov	r12,-1
8000ac44:	ae 68       	st.h	r7[0xc],r8
8000ac46:	d8 22       	popm	r4-r7,pc
8000ac48:	18 05       	add	r5,r12
8000ac4a:	58 04       	cp.w	r4,0
8000ac4c:	fe 99 ff ef 	brgt	8000ac2a <_fflush_r+0xe2>
8000ac50:	d8 2a       	popm	r4-r7,pc,r12=0
8000ac52:	d7 03       	nop

8000ac54 <__sfp_lock_acquire>:
8000ac54:	5e fc       	retal	r12

8000ac56 <__sfp_lock_release>:
8000ac56:	5e fc       	retal	r12

8000ac58 <_cleanup_r>:
8000ac58:	d4 01       	pushm	lr
8000ac5a:	fe cb f0 ae 	sub	r11,pc,-3922
8000ac5e:	e0 a0 02 f7 	rcall	8000b24c <_fwalk>
8000ac62:	d8 02       	popm	pc

8000ac64 <__sfmoreglue>:
8000ac64:	d4 21       	pushm	r4-r7,lr
8000ac66:	16 95       	mov	r5,r11
8000ac68:	f6 06 10 5c 	mul	r6,r11,92
8000ac6c:	ec cb ff f4 	sub	r11,r6,-12
8000ac70:	fe b0 e2 88 	rcall	80007180 <_malloc_r>
8000ac74:	18 97       	mov	r7,r12
8000ac76:	c0 90       	breq	8000ac88 <__sfmoreglue+0x24>
8000ac78:	99 15       	st.w	r12[0x4],r5
8000ac7a:	30 0b       	mov	r11,0
8000ac7c:	2f 4c       	sub	r12,-12
8000ac7e:	0c 9a       	mov	r10,r6
8000ac80:	8f 2c       	st.w	r7[0x8],r12
8000ac82:	8f 0b       	st.w	r7[0x0],r11
8000ac84:	fe b0 e5 3e 	rcall	80007700 <memset>
8000ac88:	0e 9c       	mov	r12,r7
8000ac8a:	d8 22       	popm	r4-r7,pc

8000ac8c <__sfp>:
8000ac8c:	d4 21       	pushm	r4-r7,lr
8000ac8e:	fe c8 cd 7e 	sub	r8,pc,-12930
8000ac92:	18 96       	mov	r6,r12
8000ac94:	70 07       	ld.w	r7,r8[0x0]
8000ac96:	6e 68       	ld.w	r8,r7[0x18]
8000ac98:	58 08       	cp.w	r8,0
8000ac9a:	c0 31       	brne	8000aca0 <__sfp+0x14>
8000ac9c:	0e 9c       	mov	r12,r7
8000ac9e:	c2 dc       	rcall	8000acf8 <__sinit>
8000aca0:	ee c7 ff 28 	sub	r7,r7,-216
8000aca4:	30 05       	mov	r5,0
8000aca6:	6e 2c       	ld.w	r12,r7[0x8]
8000aca8:	6e 18       	ld.w	r8,r7[0x4]
8000acaa:	c0 68       	rjmp	8000acb6 <__sfp+0x2a>
8000acac:	98 69       	ld.sh	r9,r12[0xc]
8000acae:	ea 09 19 00 	cp.h	r9,r5
8000acb2:	c1 10       	breq	8000acd4 <__sfp+0x48>
8000acb4:	2a 4c       	sub	r12,-92
8000acb6:	20 18       	sub	r8,1
8000acb8:	cf a7       	brpl	8000acac <__sfp+0x20>
8000acba:	6e 08       	ld.w	r8,r7[0x0]
8000acbc:	58 08       	cp.w	r8,0
8000acbe:	c0 61       	brne	8000acca <__sfp+0x3e>
8000acc0:	30 4b       	mov	r11,4
8000acc2:	0c 9c       	mov	r12,r6
8000acc4:	cd 0f       	rcall	8000ac64 <__sfmoreglue>
8000acc6:	8f 0c       	st.w	r7[0x0],r12
8000acc8:	c0 30       	breq	8000acce <__sfp+0x42>
8000acca:	6e 07       	ld.w	r7,r7[0x0]
8000accc:	ce db       	rjmp	8000aca6 <__sfp+0x1a>
8000acce:	30 c8       	mov	r8,12
8000acd0:	8d 38       	st.w	r6[0xc],r8
8000acd2:	d8 22       	popm	r4-r7,pc
8000acd4:	30 08       	mov	r8,0
8000acd6:	f9 48 00 4c 	st.w	r12[76],r8
8000acda:	99 08       	st.w	r12[0x0],r8
8000acdc:	99 28       	st.w	r12[0x8],r8
8000acde:	99 18       	st.w	r12[0x4],r8
8000ace0:	99 48       	st.w	r12[0x10],r8
8000ace2:	99 58       	st.w	r12[0x14],r8
8000ace4:	99 68       	st.w	r12[0x18],r8
8000ace6:	99 d8       	st.w	r12[0x34],r8
8000ace8:	99 e8       	st.w	r12[0x38],r8
8000acea:	f9 48 00 48 	st.w	r12[72],r8
8000acee:	3f f8       	mov	r8,-1
8000acf0:	b8 78       	st.h	r12[0xe],r8
8000acf2:	30 18       	mov	r8,1
8000acf4:	b8 68       	st.h	r12[0xc],r8
8000acf6:	d8 22       	popm	r4-r7,pc

8000acf8 <__sinit>:
8000acf8:	d4 21       	pushm	r4-r7,lr
8000acfa:	18 96       	mov	r6,r12
8000acfc:	78 67       	ld.w	r7,r12[0x18]
8000acfe:	58 07       	cp.w	r7,0
8000ad00:	c4 91       	brne	8000ad92 <__sinit+0x9a>
8000ad02:	fe c8 00 aa 	sub	r8,pc,170
8000ad06:	30 15       	mov	r5,1
8000ad08:	99 a8       	st.w	r12[0x28],r8
8000ad0a:	f9 47 00 d8 	st.w	r12[216],r7
8000ad0e:	f9 47 00 dc 	st.w	r12[220],r7
8000ad12:	f9 47 00 e0 	st.w	r12[224],r7
8000ad16:	99 65       	st.w	r12[0x18],r5
8000ad18:	cb af       	rcall	8000ac8c <__sfp>
8000ad1a:	8d 0c       	st.w	r6[0x0],r12
8000ad1c:	0c 9c       	mov	r12,r6
8000ad1e:	cb 7f       	rcall	8000ac8c <__sfp>
8000ad20:	8d 1c       	st.w	r6[0x4],r12
8000ad22:	0c 9c       	mov	r12,r6
8000ad24:	cb 4f       	rcall	8000ac8c <__sfp>
8000ad26:	6c 09       	ld.w	r9,r6[0x0]
8000ad28:	30 48       	mov	r8,4
8000ad2a:	93 07       	st.w	r9[0x0],r7
8000ad2c:	b2 68       	st.h	r9[0xc],r8
8000ad2e:	93 17       	st.w	r9[0x4],r7
8000ad30:	93 27       	st.w	r9[0x8],r7
8000ad32:	6c 18       	ld.w	r8,r6[0x4]
8000ad34:	b2 77       	st.h	r9[0xe],r7
8000ad36:	93 47       	st.w	r9[0x10],r7
8000ad38:	93 57       	st.w	r9[0x14],r7
8000ad3a:	93 67       	st.w	r9[0x18],r7
8000ad3c:	93 89       	st.w	r9[0x20],r9
8000ad3e:	91 07       	st.w	r8[0x0],r7
8000ad40:	91 17       	st.w	r8[0x4],r7
8000ad42:	91 27       	st.w	r8[0x8],r7
8000ad44:	fe ce f3 24 	sub	lr,pc,-3292
8000ad48:	fe cb f3 54 	sub	r11,pc,-3244
8000ad4c:	93 9e       	st.w	r9[0x24],lr
8000ad4e:	93 ab       	st.w	r9[0x28],r11
8000ad50:	fe ca f3 7c 	sub	r10,pc,-3204
8000ad54:	fe c4 f3 88 	sub	r4,pc,-3192
8000ad58:	93 ba       	st.w	r9[0x2c],r10
8000ad5a:	93 c4       	st.w	r9[0x30],r4
8000ad5c:	30 99       	mov	r9,9
8000ad5e:	b0 69       	st.h	r8[0xc],r9
8000ad60:	b0 75       	st.h	r8[0xe],r5
8000ad62:	91 c4       	st.w	r8[0x30],r4
8000ad64:	91 47       	st.w	r8[0x10],r7
8000ad66:	91 57       	st.w	r8[0x14],r7
8000ad68:	91 67       	st.w	r8[0x18],r7
8000ad6a:	91 88       	st.w	r8[0x20],r8
8000ad6c:	91 9e       	st.w	r8[0x24],lr
8000ad6e:	91 ab       	st.w	r8[0x28],r11
8000ad70:	91 ba       	st.w	r8[0x2c],r10
8000ad72:	8d 2c       	st.w	r6[0x8],r12
8000ad74:	31 28       	mov	r8,18
8000ad76:	99 07       	st.w	r12[0x0],r7
8000ad78:	b8 68       	st.h	r12[0xc],r8
8000ad7a:	99 17       	st.w	r12[0x4],r7
8000ad7c:	99 27       	st.w	r12[0x8],r7
8000ad7e:	30 28       	mov	r8,2
8000ad80:	b8 78       	st.h	r12[0xe],r8
8000ad82:	99 c4       	st.w	r12[0x30],r4
8000ad84:	99 67       	st.w	r12[0x18],r7
8000ad86:	99 9e       	st.w	r12[0x24],lr
8000ad88:	99 ab       	st.w	r12[0x28],r11
8000ad8a:	99 ba       	st.w	r12[0x2c],r10
8000ad8c:	99 47       	st.w	r12[0x10],r7
8000ad8e:	99 57       	st.w	r12[0x14],r7
8000ad90:	99 8c       	st.w	r12[0x20],r12
8000ad92:	d8 22       	popm	r4-r7,pc

8000ad94 <_malloc_trim_r>:
8000ad94:	d4 21       	pushm	r4-r7,lr
8000ad96:	16 95       	mov	r5,r11
8000ad98:	18 97       	mov	r7,r12
8000ad9a:	fe b0 d7 d9 	rcall	80005d4c <__malloc_lock>
8000ad9e:	e0 64 05 3c 	mov	r4,1340
8000ada2:	68 28       	ld.w	r8,r4[0x8]
8000ada4:	70 16       	ld.w	r6,r8[0x4]
8000ada6:	e0 16 ff fc 	andl	r6,0xfffc
8000adaa:	ec c8 ff 91 	sub	r8,r6,-111
8000adae:	f0 05 01 05 	sub	r5,r8,r5
8000adb2:	e0 15 ff 80 	andl	r5,0xff80
8000adb6:	ea c5 00 80 	sub	r5,r5,128
8000adba:	e0 45 00 7f 	cp.w	r5,127
8000adbe:	e0 8a 00 25 	brle	8000ae08 <_malloc_trim_r+0x74>
8000adc2:	30 0b       	mov	r11,0
8000adc4:	0e 9c       	mov	r12,r7
8000adc6:	fe b0 e6 05 	rcall	800079d0 <_sbrk_r>
8000adca:	68 28       	ld.w	r8,r4[0x8]
8000adcc:	0c 08       	add	r8,r6
8000adce:	10 3c       	cp.w	r12,r8
8000add0:	c1 c1       	brne	8000ae08 <_malloc_trim_r+0x74>
8000add2:	ea 0b 11 00 	rsub	r11,r5,0
8000add6:	0e 9c       	mov	r12,r7
8000add8:	fe b0 e5 fc 	rcall	800079d0 <_sbrk_r>
8000addc:	5b fc       	cp.w	r12,-1
8000adde:	c1 91       	brne	8000ae10 <_malloc_trim_r+0x7c>
8000ade0:	30 0b       	mov	r11,0
8000ade2:	0e 9c       	mov	r12,r7
8000ade4:	fe b0 e5 f6 	rcall	800079d0 <_sbrk_r>
8000ade8:	68 28       	ld.w	r8,r4[0x8]
8000adea:	f8 08 01 09 	sub	r9,r12,r8
8000adee:	58 f9       	cp.w	r9,15
8000adf0:	e0 8a 00 0c 	brle	8000ae08 <_malloc_trim_r+0x74>
8000adf4:	a1 a9       	sbr	r9,0x0
8000adf6:	91 19       	st.w	r8[0x4],r9
8000adf8:	e0 68 09 48 	mov	r8,2376
8000adfc:	70 09       	ld.w	r9,r8[0x0]
8000adfe:	e0 68 0d 68 	mov	r8,3432
8000ae02:	f8 09 01 09 	sub	r9,r12,r9
8000ae06:	91 09       	st.w	r8[0x0],r9
8000ae08:	0e 9c       	mov	r12,r7
8000ae0a:	fe b0 d7 a7 	rcall	80005d58 <__malloc_unlock>
8000ae0e:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae10:	68 28       	ld.w	r8,r4[0x8]
8000ae12:	0a 16       	sub	r6,r5
8000ae14:	a1 a6       	sbr	r6,0x0
8000ae16:	91 16       	st.w	r8[0x4],r6
8000ae18:	e0 68 0d 68 	mov	r8,3432
8000ae1c:	70 09       	ld.w	r9,r8[0x0]
8000ae1e:	0a 19       	sub	r9,r5
8000ae20:	0e 9c       	mov	r12,r7
8000ae22:	91 09       	st.w	r8[0x0],r9
8000ae24:	fe b0 d7 9a 	rcall	80005d58 <__malloc_unlock>
8000ae28:	da 2a       	popm	r4-r7,pc,r12=1
8000ae2a:	d7 03       	nop

8000ae2c <_free_r>:
8000ae2c:	d4 21       	pushm	r4-r7,lr
8000ae2e:	16 96       	mov	r6,r11
8000ae30:	18 97       	mov	r7,r12
8000ae32:	58 0b       	cp.w	r11,0
8000ae34:	e0 80 00 c0 	breq	8000afb4 <_free_r+0x188>
8000ae38:	fe b0 d7 8a 	rcall	80005d4c <__malloc_lock>
8000ae3c:	20 86       	sub	r6,8
8000ae3e:	e0 6a 05 3c 	mov	r10,1340
8000ae42:	6c 18       	ld.w	r8,r6[0x4]
8000ae44:	74 2e       	ld.w	lr,r10[0x8]
8000ae46:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ae4a:	a1 c8       	cbr	r8,0x0
8000ae4c:	ec 08 00 09 	add	r9,r6,r8
8000ae50:	72 1b       	ld.w	r11,r9[0x4]
8000ae52:	e0 1b ff fc 	andl	r11,0xfffc
8000ae56:	1c 39       	cp.w	r9,lr
8000ae58:	c1 e1       	brne	8000ae94 <_free_r+0x68>
8000ae5a:	f6 08 00 08 	add	r8,r11,r8
8000ae5e:	58 0c       	cp.w	r12,0
8000ae60:	c0 81       	brne	8000ae70 <_free_r+0x44>
8000ae62:	6c 09       	ld.w	r9,r6[0x0]
8000ae64:	12 16       	sub	r6,r9
8000ae66:	12 08       	add	r8,r9
8000ae68:	6c 3b       	ld.w	r11,r6[0xc]
8000ae6a:	6c 29       	ld.w	r9,r6[0x8]
8000ae6c:	97 29       	st.w	r11[0x8],r9
8000ae6e:	93 3b       	st.w	r9[0xc],r11
8000ae70:	10 99       	mov	r9,r8
8000ae72:	95 26       	st.w	r10[0x8],r6
8000ae74:	a1 a9       	sbr	r9,0x0
8000ae76:	8d 19       	st.w	r6[0x4],r9
8000ae78:	e0 69 09 44 	mov	r9,2372
8000ae7c:	72 09       	ld.w	r9,r9[0x0]
8000ae7e:	12 38       	cp.w	r8,r9
8000ae80:	c0 63       	brcs	8000ae8c <_free_r+0x60>
8000ae82:	e0 68 0d 64 	mov	r8,3428
8000ae86:	0e 9c       	mov	r12,r7
8000ae88:	70 0b       	ld.w	r11,r8[0x0]
8000ae8a:	c8 5f       	rcall	8000ad94 <_malloc_trim_r>
8000ae8c:	0e 9c       	mov	r12,r7
8000ae8e:	fe b0 d7 65 	rcall	80005d58 <__malloc_unlock>
8000ae92:	d8 22       	popm	r4-r7,pc
8000ae94:	93 1b       	st.w	r9[0x4],r11
8000ae96:	58 0c       	cp.w	r12,0
8000ae98:	c0 30       	breq	8000ae9e <_free_r+0x72>
8000ae9a:	30 0c       	mov	r12,0
8000ae9c:	c1 08       	rjmp	8000aebc <_free_r+0x90>
8000ae9e:	6c 0e       	ld.w	lr,r6[0x0]
8000aea0:	f4 c5 ff f8 	sub	r5,r10,-8
8000aea4:	1c 16       	sub	r6,lr
8000aea6:	1c 08       	add	r8,lr
8000aea8:	6c 2e       	ld.w	lr,r6[0x8]
8000aeaa:	0a 3e       	cp.w	lr,r5
8000aeac:	f9 bc 00 01 	moveq	r12,1
8000aeb0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aeb4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aeb8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aebc:	f2 0b 00 0e 	add	lr,r9,r11
8000aec0:	7c 1e       	ld.w	lr,lr[0x4]
8000aec2:	ed be 00 00 	bld	lr,0x0
8000aec6:	c1 40       	breq	8000aeee <_free_r+0xc2>
8000aec8:	16 08       	add	r8,r11
8000aeca:	58 0c       	cp.w	r12,0
8000aecc:	c0 d1       	brne	8000aee6 <_free_r+0xba>
8000aece:	e0 6e 05 3c 	mov	lr,1340
8000aed2:	72 2b       	ld.w	r11,r9[0x8]
8000aed4:	2f 8e       	sub	lr,-8
8000aed6:	1c 3b       	cp.w	r11,lr
8000aed8:	c0 71       	brne	8000aee6 <_free_r+0xba>
8000aeda:	97 36       	st.w	r11[0xc],r6
8000aedc:	97 26       	st.w	r11[0x8],r6
8000aede:	8d 2b       	st.w	r6[0x8],r11
8000aee0:	8d 3b       	st.w	r6[0xc],r11
8000aee2:	30 1c       	mov	r12,1
8000aee4:	c0 58       	rjmp	8000aeee <_free_r+0xc2>
8000aee6:	72 2b       	ld.w	r11,r9[0x8]
8000aee8:	72 39       	ld.w	r9,r9[0xc]
8000aeea:	93 2b       	st.w	r9[0x8],r11
8000aeec:	97 39       	st.w	r11[0xc],r9
8000aeee:	10 99       	mov	r9,r8
8000aef0:	ec 08 09 08 	st.w	r6[r8],r8
8000aef4:	a1 a9       	sbr	r9,0x0
8000aef6:	8d 19       	st.w	r6[0x4],r9
8000aef8:	58 0c       	cp.w	r12,0
8000aefa:	c5 a1       	brne	8000afae <_free_r+0x182>
8000aefc:	e0 48 01 ff 	cp.w	r8,511
8000af00:	e0 8b 00 13 	brhi	8000af26 <_free_r+0xfa>
8000af04:	a3 98       	lsr	r8,0x3
8000af06:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000af0a:	72 2b       	ld.w	r11,r9[0x8]
8000af0c:	8d 39       	st.w	r6[0xc],r9
8000af0e:	8d 2b       	st.w	r6[0x8],r11
8000af10:	97 36       	st.w	r11[0xc],r6
8000af12:	93 26       	st.w	r9[0x8],r6
8000af14:	a3 48       	asr	r8,0x2
8000af16:	74 19       	ld.w	r9,r10[0x4]
8000af18:	30 1b       	mov	r11,1
8000af1a:	f6 08 09 48 	lsl	r8,r11,r8
8000af1e:	f3 e8 10 08 	or	r8,r9,r8
8000af22:	95 18       	st.w	r10[0x4],r8
8000af24:	c4 58       	rjmp	8000afae <_free_r+0x182>
8000af26:	f0 0b 16 09 	lsr	r11,r8,0x9
8000af2a:	58 4b       	cp.w	r11,4
8000af2c:	e0 8b 00 06 	brhi	8000af38 <_free_r+0x10c>
8000af30:	f0 0b 16 06 	lsr	r11,r8,0x6
8000af34:	2c 8b       	sub	r11,-56
8000af36:	c2 08       	rjmp	8000af76 <_free_r+0x14a>
8000af38:	59 4b       	cp.w	r11,20
8000af3a:	e0 8b 00 04 	brhi	8000af42 <_free_r+0x116>
8000af3e:	2a 5b       	sub	r11,-91
8000af40:	c1 b8       	rjmp	8000af76 <_free_r+0x14a>
8000af42:	e0 4b 00 54 	cp.w	r11,84
8000af46:	e0 8b 00 06 	brhi	8000af52 <_free_r+0x126>
8000af4a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000af4e:	29 2b       	sub	r11,-110
8000af50:	c1 38       	rjmp	8000af76 <_free_r+0x14a>
8000af52:	e0 4b 01 54 	cp.w	r11,340
8000af56:	e0 8b 00 06 	brhi	8000af62 <_free_r+0x136>
8000af5a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000af5e:	28 9b       	sub	r11,-119
8000af60:	c0 b8       	rjmp	8000af76 <_free_r+0x14a>
8000af62:	e0 4b 05 54 	cp.w	r11,1364
8000af66:	e0 88 00 05 	brls	8000af70 <_free_r+0x144>
8000af6a:	37 eb       	mov	r11,126
8000af6c:	c0 58       	rjmp	8000af76 <_free_r+0x14a>
8000af6e:	d7 03       	nop
8000af70:	f0 0b 16 12 	lsr	r11,r8,0x12
8000af74:	28 4b       	sub	r11,-124
8000af76:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000af7a:	78 29       	ld.w	r9,r12[0x8]
8000af7c:	18 39       	cp.w	r9,r12
8000af7e:	c0 e1       	brne	8000af9a <_free_r+0x16e>
8000af80:	74 18       	ld.w	r8,r10[0x4]
8000af82:	a3 4b       	asr	r11,0x2
8000af84:	30 1c       	mov	r12,1
8000af86:	f8 0b 09 4b 	lsl	r11,r12,r11
8000af8a:	f1 eb 10 0b 	or	r11,r8,r11
8000af8e:	12 98       	mov	r8,r9
8000af90:	95 1b       	st.w	r10[0x4],r11
8000af92:	c0 a8       	rjmp	8000afa6 <_free_r+0x17a>
8000af94:	72 29       	ld.w	r9,r9[0x8]
8000af96:	18 39       	cp.w	r9,r12
8000af98:	c0 60       	breq	8000afa4 <_free_r+0x178>
8000af9a:	72 1a       	ld.w	r10,r9[0x4]
8000af9c:	e0 1a ff fc 	andl	r10,0xfffc
8000afa0:	14 38       	cp.w	r8,r10
8000afa2:	cf 93       	brcs	8000af94 <_free_r+0x168>
8000afa4:	72 38       	ld.w	r8,r9[0xc]
8000afa6:	8d 38       	st.w	r6[0xc],r8
8000afa8:	8d 29       	st.w	r6[0x8],r9
8000afaa:	93 36       	st.w	r9[0xc],r6
8000afac:	91 26       	st.w	r8[0x8],r6
8000afae:	0e 9c       	mov	r12,r7
8000afb0:	fe b0 d6 d4 	rcall	80005d58 <__malloc_unlock>
8000afb4:	d8 22       	popm	r4-r7,pc
8000afb6:	d7 03       	nop

8000afb8 <__sfvwrite_r>:
8000afb8:	d4 31       	pushm	r0-r7,lr
8000afba:	20 3d       	sub	sp,12
8000afbc:	14 94       	mov	r4,r10
8000afbe:	18 95       	mov	r5,r12
8000afc0:	16 97       	mov	r7,r11
8000afc2:	74 28       	ld.w	r8,r10[0x8]
8000afc4:	58 08       	cp.w	r8,0
8000afc6:	e0 80 01 40 	breq	8000b246 <__sfvwrite_r+0x28e>
8000afca:	96 68       	ld.sh	r8,r11[0xc]
8000afcc:	ed b8 00 03 	bld	r8,0x3
8000afd0:	c0 41       	brne	8000afd8 <__sfvwrite_r+0x20>
8000afd2:	76 48       	ld.w	r8,r11[0x10]
8000afd4:	58 08       	cp.w	r8,0
8000afd6:	c0 c1       	brne	8000afee <__sfvwrite_r+0x36>
8000afd8:	0e 9b       	mov	r11,r7
8000afda:	0a 9c       	mov	r12,r5
8000afdc:	fe b0 f6 c4 	rcall	80009d64 <__swsetup_r>
8000afe0:	c0 70       	breq	8000afee <__sfvwrite_r+0x36>
8000afe2:	8e 68       	ld.sh	r8,r7[0xc]
8000afe4:	a7 a8       	sbr	r8,0x6
8000afe6:	ae 68       	st.h	r7[0xc],r8
8000afe8:	30 98       	mov	r8,9
8000afea:	8b 38       	st.w	r5[0xc],r8
8000afec:	c2 b9       	rjmp	8000b242 <__sfvwrite_r+0x28a>
8000afee:	8e 63       	ld.sh	r3,r7[0xc]
8000aff0:	68 00       	ld.w	r0,r4[0x0]
8000aff2:	06 96       	mov	r6,r3
8000aff4:	e2 16 00 02 	andl	r6,0x2,COH
8000aff8:	c2 10       	breq	8000b03a <__sfvwrite_r+0x82>
8000affa:	30 03       	mov	r3,0
8000affc:	e0 62 04 00 	mov	r2,1024
8000b000:	06 96       	mov	r6,r3
8000b002:	c0 48       	rjmp	8000b00a <__sfvwrite_r+0x52>
8000b004:	60 03       	ld.w	r3,r0[0x0]
8000b006:	60 16       	ld.w	r6,r0[0x4]
8000b008:	2f 80       	sub	r0,-8
8000b00a:	58 06       	cp.w	r6,0
8000b00c:	cf c0       	breq	8000b004 <__sfvwrite_r+0x4c>
8000b00e:	e0 46 04 00 	cp.w	r6,1024
8000b012:	ec 09 17 80 	movls	r9,r6
8000b016:	e4 09 17 b0 	movhi	r9,r2
8000b01a:	06 9a       	mov	r10,r3
8000b01c:	6e a8       	ld.w	r8,r7[0x28]
8000b01e:	6e 8b       	ld.w	r11,r7[0x20]
8000b020:	0a 9c       	mov	r12,r5
8000b022:	5d 18       	icall	r8
8000b024:	18 16       	sub	r6,r12
8000b026:	58 0c       	cp.w	r12,0
8000b028:	e0 8a 01 0a 	brle	8000b23c <__sfvwrite_r+0x284>
8000b02c:	68 28       	ld.w	r8,r4[0x8]
8000b02e:	18 18       	sub	r8,r12
8000b030:	89 28       	st.w	r4[0x8],r8
8000b032:	e0 80 01 0a 	breq	8000b246 <__sfvwrite_r+0x28e>
8000b036:	18 03       	add	r3,r12
8000b038:	ce 9b       	rjmp	8000b00a <__sfvwrite_r+0x52>
8000b03a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b03e:	c0 70       	breq	8000b04c <__sfvwrite_r+0x94>
8000b040:	50 06       	stdsp	sp[0x0],r6
8000b042:	0c 93       	mov	r3,r6
8000b044:	0c 91       	mov	r1,r6
8000b046:	50 15       	stdsp	sp[0x4],r5
8000b048:	08 92       	mov	r2,r4
8000b04a:	c9 c8       	rjmp	8000b182 <__sfvwrite_r+0x1ca>
8000b04c:	06 96       	mov	r6,r3
8000b04e:	08 91       	mov	r1,r4
8000b050:	c0 48       	rjmp	8000b058 <__sfvwrite_r+0xa0>
8000b052:	60 03       	ld.w	r3,r0[0x0]
8000b054:	60 16       	ld.w	r6,r0[0x4]
8000b056:	2f 80       	sub	r0,-8
8000b058:	58 06       	cp.w	r6,0
8000b05a:	cf c0       	breq	8000b052 <__sfvwrite_r+0x9a>
8000b05c:	8e 68       	ld.sh	r8,r7[0xc]
8000b05e:	6e 24       	ld.w	r4,r7[0x8]
8000b060:	10 99       	mov	r9,r8
8000b062:	e2 19 02 00 	andl	r9,0x200,COH
8000b066:	c5 50       	breq	8000b110 <__sfvwrite_r+0x158>
8000b068:	08 36       	cp.w	r6,r4
8000b06a:	c4 43       	brcs	8000b0f2 <__sfvwrite_r+0x13a>
8000b06c:	10 99       	mov	r9,r8
8000b06e:	e2 19 04 80 	andl	r9,0x480,COH
8000b072:	c4 00       	breq	8000b0f2 <__sfvwrite_r+0x13a>
8000b074:	6e 4b       	ld.w	r11,r7[0x10]
8000b076:	6e 09       	ld.w	r9,r7[0x0]
8000b078:	16 19       	sub	r9,r11
8000b07a:	50 09       	stdsp	sp[0x0],r9
8000b07c:	6e 59       	ld.w	r9,r7[0x14]
8000b07e:	10 9c       	mov	r12,r8
8000b080:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b084:	30 28       	mov	r8,2
8000b086:	f4 08 0c 08 	divs	r8,r10,r8
8000b08a:	fa e9 00 04 	st.d	sp[4],r8
8000b08e:	10 94       	mov	r4,r8
8000b090:	40 09       	lddsp	r9,sp[0x0]
8000b092:	e2 1c 04 00 	andl	r12,0x400,COH
8000b096:	2f f9       	sub	r9,-1
8000b098:	0c 09       	add	r9,r6
8000b09a:	12 38       	cp.w	r8,r9
8000b09c:	f2 04 17 30 	movlo	r4,r9
8000b0a0:	58 0c       	cp.w	r12,0
8000b0a2:	c1 10       	breq	8000b0c4 <__sfvwrite_r+0x10c>
8000b0a4:	08 9b       	mov	r11,r4
8000b0a6:	0a 9c       	mov	r12,r5
8000b0a8:	fe b0 e0 6c 	rcall	80007180 <_malloc_r>
8000b0ac:	18 92       	mov	r2,r12
8000b0ae:	c1 40       	breq	8000b0d6 <__sfvwrite_r+0x11e>
8000b0b0:	40 0a       	lddsp	r10,sp[0x0]
8000b0b2:	6e 4b       	ld.w	r11,r7[0x10]
8000b0b4:	fe b0 e2 82 	rcall	800075b8 <memcpy>
8000b0b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b0ba:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b0be:	a7 b8       	sbr	r8,0x7
8000b0c0:	ae 68       	st.h	r7[0xc],r8
8000b0c2:	c0 d8       	rjmp	8000b0dc <__sfvwrite_r+0x124>
8000b0c4:	08 9a       	mov	r10,r4
8000b0c6:	0a 9c       	mov	r12,r5
8000b0c8:	fe b0 e3 24 	rcall	80007710 <_realloc_r>
8000b0cc:	18 92       	mov	r2,r12
8000b0ce:	c0 71       	brne	8000b0dc <__sfvwrite_r+0x124>
8000b0d0:	6e 4b       	ld.w	r11,r7[0x10]
8000b0d2:	0a 9c       	mov	r12,r5
8000b0d4:	ca ce       	rcall	8000ae2c <_free_r>
8000b0d6:	30 c8       	mov	r8,12
8000b0d8:	8b 38       	st.w	r5[0xc],r8
8000b0da:	cb 18       	rjmp	8000b23c <__sfvwrite_r+0x284>
8000b0dc:	40 0a       	lddsp	r10,sp[0x0]
8000b0de:	40 09       	lddsp	r9,sp[0x0]
8000b0e0:	e8 0a 01 0a 	sub	r10,r4,r10
8000b0e4:	e4 09 00 08 	add	r8,r2,r9
8000b0e8:	8f 54       	st.w	r7[0x14],r4
8000b0ea:	8f 2a       	st.w	r7[0x8],r10
8000b0ec:	8f 08       	st.w	r7[0x0],r8
8000b0ee:	8f 42       	st.w	r7[0x10],r2
8000b0f0:	0c 94       	mov	r4,r6
8000b0f2:	08 36       	cp.w	r6,r4
8000b0f4:	ec 04 17 30 	movlo	r4,r6
8000b0f8:	06 9b       	mov	r11,r3
8000b0fa:	08 9a       	mov	r10,r4
8000b0fc:	6e 0c       	ld.w	r12,r7[0x0]
8000b0fe:	c3 ad       	rcall	8000b372 <memmove>
8000b100:	6e 08       	ld.w	r8,r7[0x0]
8000b102:	08 08       	add	r8,r4
8000b104:	8f 08       	st.w	r7[0x0],r8
8000b106:	6e 28       	ld.w	r8,r7[0x8]
8000b108:	08 18       	sub	r8,r4
8000b10a:	0c 94       	mov	r4,r6
8000b10c:	8f 28       	st.w	r7[0x8],r8
8000b10e:	c2 e8       	rjmp	8000b16a <__sfvwrite_r+0x1b2>
8000b110:	08 36       	cp.w	r6,r4
8000b112:	5f ba       	srhi	r10
8000b114:	6e 0c       	ld.w	r12,r7[0x0]
8000b116:	6e 48       	ld.w	r8,r7[0x10]
8000b118:	10 3c       	cp.w	r12,r8
8000b11a:	5f b8       	srhi	r8
8000b11c:	f5 e8 00 08 	and	r8,r10,r8
8000b120:	f2 08 18 00 	cp.b	r8,r9
8000b124:	c0 d0       	breq	8000b13e <__sfvwrite_r+0x186>
8000b126:	06 9b       	mov	r11,r3
8000b128:	08 9a       	mov	r10,r4
8000b12a:	c2 4d       	rcall	8000b372 <memmove>
8000b12c:	6e 08       	ld.w	r8,r7[0x0]
8000b12e:	08 08       	add	r8,r4
8000b130:	0e 9b       	mov	r11,r7
8000b132:	8f 08       	st.w	r7[0x0],r8
8000b134:	0a 9c       	mov	r12,r5
8000b136:	fe b0 fd 09 	rcall	8000ab48 <_fflush_r>
8000b13a:	c1 80       	breq	8000b16a <__sfvwrite_r+0x1b2>
8000b13c:	c8 08       	rjmp	8000b23c <__sfvwrite_r+0x284>
8000b13e:	6e 59       	ld.w	r9,r7[0x14]
8000b140:	12 36       	cp.w	r6,r9
8000b142:	c0 a3       	brcs	8000b156 <__sfvwrite_r+0x19e>
8000b144:	6e a8       	ld.w	r8,r7[0x28]
8000b146:	06 9a       	mov	r10,r3
8000b148:	6e 8b       	ld.w	r11,r7[0x20]
8000b14a:	0a 9c       	mov	r12,r5
8000b14c:	5d 18       	icall	r8
8000b14e:	18 94       	mov	r4,r12
8000b150:	e0 89 00 0d 	brgt	8000b16a <__sfvwrite_r+0x1b2>
8000b154:	c7 48       	rjmp	8000b23c <__sfvwrite_r+0x284>
8000b156:	0c 9a       	mov	r10,r6
8000b158:	06 9b       	mov	r11,r3
8000b15a:	c0 cd       	rcall	8000b372 <memmove>
8000b15c:	6e 08       	ld.w	r8,r7[0x0]
8000b15e:	0c 08       	add	r8,r6
8000b160:	0c 94       	mov	r4,r6
8000b162:	8f 08       	st.w	r7[0x0],r8
8000b164:	6e 28       	ld.w	r8,r7[0x8]
8000b166:	0c 18       	sub	r8,r6
8000b168:	8f 28       	st.w	r7[0x8],r8
8000b16a:	62 28       	ld.w	r8,r1[0x8]
8000b16c:	08 18       	sub	r8,r4
8000b16e:	83 28       	st.w	r1[0x8],r8
8000b170:	c6 b0       	breq	8000b246 <__sfvwrite_r+0x28e>
8000b172:	08 16       	sub	r6,r4
8000b174:	08 03       	add	r3,r4
8000b176:	c7 1b       	rjmp	8000b058 <__sfvwrite_r+0xa0>
8000b178:	60 03       	ld.w	r3,r0[0x0]
8000b17a:	60 11       	ld.w	r1,r0[0x4]
8000b17c:	30 08       	mov	r8,0
8000b17e:	2f 80       	sub	r0,-8
8000b180:	50 08       	stdsp	sp[0x0],r8
8000b182:	58 01       	cp.w	r1,0
8000b184:	cf a0       	breq	8000b178 <__sfvwrite_r+0x1c0>
8000b186:	40 0a       	lddsp	r10,sp[0x0]
8000b188:	58 0a       	cp.w	r10,0
8000b18a:	c1 41       	brne	8000b1b2 <__sfvwrite_r+0x1fa>
8000b18c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b190:	02 9a       	mov	r10,r1
8000b192:	30 ab       	mov	r11,10
8000b194:	06 9c       	mov	r12,r3
8000b196:	ce 3c       	rcall	8000b35c <memchr>
8000b198:	f8 c8 ff ff 	sub	r8,r12,-1
8000b19c:	58 0c       	cp.w	r12,0
8000b19e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b1a2:	f9 b9 01 01 	movne	r9,1
8000b1a6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b1aa:	f9 b8 00 01 	moveq	r8,1
8000b1ae:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b1b2:	02 36       	cp.w	r6,r1
8000b1b4:	ec 04 17 80 	movls	r4,r6
8000b1b8:	e2 04 17 b0 	movhi	r4,r1
8000b1bc:	6e 59       	ld.w	r9,r7[0x14]
8000b1be:	6e 25       	ld.w	r5,r7[0x8]
8000b1c0:	f2 05 00 05 	add	r5,r9,r5
8000b1c4:	0a 34       	cp.w	r4,r5
8000b1c6:	5f 9a       	srgt	r10
8000b1c8:	6e 0c       	ld.w	r12,r7[0x0]
8000b1ca:	6e 48       	ld.w	r8,r7[0x10]
8000b1cc:	10 3c       	cp.w	r12,r8
8000b1ce:	5f b8       	srhi	r8
8000b1d0:	f5 e8 00 08 	and	r8,r10,r8
8000b1d4:	30 0a       	mov	r10,0
8000b1d6:	f4 08 18 00 	cp.b	r8,r10
8000b1da:	c0 d0       	breq	8000b1f4 <__sfvwrite_r+0x23c>
8000b1dc:	06 9b       	mov	r11,r3
8000b1de:	0a 9a       	mov	r10,r5
8000b1e0:	cc 9c       	rcall	8000b372 <memmove>
8000b1e2:	6e 08       	ld.w	r8,r7[0x0]
8000b1e4:	0a 08       	add	r8,r5
8000b1e6:	0e 9b       	mov	r11,r7
8000b1e8:	8f 08       	st.w	r7[0x0],r8
8000b1ea:	40 1c       	lddsp	r12,sp[0x4]
8000b1ec:	fe b0 fc ae 	rcall	8000ab48 <_fflush_r>
8000b1f0:	c1 70       	breq	8000b21e <__sfvwrite_r+0x266>
8000b1f2:	c2 58       	rjmp	8000b23c <__sfvwrite_r+0x284>
8000b1f4:	12 34       	cp.w	r4,r9
8000b1f6:	c0 a5       	brlt	8000b20a <__sfvwrite_r+0x252>
8000b1f8:	6e a8       	ld.w	r8,r7[0x28]
8000b1fa:	06 9a       	mov	r10,r3
8000b1fc:	6e 8b       	ld.w	r11,r7[0x20]
8000b1fe:	40 1c       	lddsp	r12,sp[0x4]
8000b200:	5d 18       	icall	r8
8000b202:	18 95       	mov	r5,r12
8000b204:	e0 89 00 0d 	brgt	8000b21e <__sfvwrite_r+0x266>
8000b208:	c1 a8       	rjmp	8000b23c <__sfvwrite_r+0x284>
8000b20a:	08 9a       	mov	r10,r4
8000b20c:	06 9b       	mov	r11,r3
8000b20e:	cb 2c       	rcall	8000b372 <memmove>
8000b210:	6e 08       	ld.w	r8,r7[0x0]
8000b212:	08 08       	add	r8,r4
8000b214:	08 95       	mov	r5,r4
8000b216:	8f 08       	st.w	r7[0x0],r8
8000b218:	6e 28       	ld.w	r8,r7[0x8]
8000b21a:	08 18       	sub	r8,r4
8000b21c:	8f 28       	st.w	r7[0x8],r8
8000b21e:	0a 16       	sub	r6,r5
8000b220:	c0 71       	brne	8000b22e <__sfvwrite_r+0x276>
8000b222:	0e 9b       	mov	r11,r7
8000b224:	40 1c       	lddsp	r12,sp[0x4]
8000b226:	fe b0 fc 91 	rcall	8000ab48 <_fflush_r>
8000b22a:	c0 91       	brne	8000b23c <__sfvwrite_r+0x284>
8000b22c:	50 06       	stdsp	sp[0x0],r6
8000b22e:	64 28       	ld.w	r8,r2[0x8]
8000b230:	0a 18       	sub	r8,r5
8000b232:	85 28       	st.w	r2[0x8],r8
8000b234:	c0 90       	breq	8000b246 <__sfvwrite_r+0x28e>
8000b236:	0a 11       	sub	r1,r5
8000b238:	0a 03       	add	r3,r5
8000b23a:	ca 4b       	rjmp	8000b182 <__sfvwrite_r+0x1ca>
8000b23c:	8e 68       	ld.sh	r8,r7[0xc]
8000b23e:	a7 a8       	sbr	r8,0x6
8000b240:	ae 68       	st.h	r7[0xc],r8
8000b242:	3f fc       	mov	r12,-1
8000b244:	c0 28       	rjmp	8000b248 <__sfvwrite_r+0x290>
8000b246:	30 0c       	mov	r12,0
8000b248:	2f dd       	sub	sp,-12
8000b24a:	d8 32       	popm	r0-r7,pc

8000b24c <_fwalk>:
8000b24c:	d4 31       	pushm	r0-r7,lr
8000b24e:	30 05       	mov	r5,0
8000b250:	16 91       	mov	r1,r11
8000b252:	f8 c7 ff 28 	sub	r7,r12,-216
8000b256:	0a 92       	mov	r2,r5
8000b258:	fe b0 fc fe 	rcall	8000ac54 <__sfp_lock_acquire>
8000b25c:	3f f3       	mov	r3,-1
8000b25e:	c1 68       	rjmp	8000b28a <_fwalk+0x3e>
8000b260:	6e 26       	ld.w	r6,r7[0x8]
8000b262:	6e 14       	ld.w	r4,r7[0x4]
8000b264:	2f 46       	sub	r6,-12
8000b266:	c0 c8       	rjmp	8000b27e <_fwalk+0x32>
8000b268:	8c 08       	ld.sh	r8,r6[0x0]
8000b26a:	e4 08 19 00 	cp.h	r8,r2
8000b26e:	c0 70       	breq	8000b27c <_fwalk+0x30>
8000b270:	8c 18       	ld.sh	r8,r6[0x2]
8000b272:	e6 08 19 00 	cp.h	r8,r3
8000b276:	c0 30       	breq	8000b27c <_fwalk+0x30>
8000b278:	5d 11       	icall	r1
8000b27a:	18 45       	or	r5,r12
8000b27c:	2a 46       	sub	r6,-92
8000b27e:	20 14       	sub	r4,1
8000b280:	ec cc 00 0c 	sub	r12,r6,12
8000b284:	58 04       	cp.w	r4,0
8000b286:	cf 14       	brge	8000b268 <_fwalk+0x1c>
8000b288:	6e 07       	ld.w	r7,r7[0x0]
8000b28a:	58 07       	cp.w	r7,0
8000b28c:	ce a1       	brne	8000b260 <_fwalk+0x14>
8000b28e:	fe b0 fc e4 	rcall	8000ac56 <__sfp_lock_release>
8000b292:	0a 9c       	mov	r12,r5
8000b294:	d8 32       	popm	r0-r7,pc
8000b296:	d7 03       	nop

8000b298 <_localeconv_r>:
8000b298:	fe cc d3 84 	sub	r12,pc,-11388
8000b29c:	5e fc       	retal	r12
8000b29e:	d7 03       	nop

8000b2a0 <__smakebuf_r>:
8000b2a0:	d4 21       	pushm	r4-r7,lr
8000b2a2:	20 fd       	sub	sp,60
8000b2a4:	96 68       	ld.sh	r8,r11[0xc]
8000b2a6:	16 97       	mov	r7,r11
8000b2a8:	18 96       	mov	r6,r12
8000b2aa:	e2 18 00 02 	andl	r8,0x2,COH
8000b2ae:	c3 d1       	brne	8000b328 <__smakebuf_r+0x88>
8000b2b0:	96 7b       	ld.sh	r11,r11[0xe]
8000b2b2:	f0 0b 19 00 	cp.h	r11,r8
8000b2b6:	c0 55       	brlt	8000b2c0 <__smakebuf_r+0x20>
8000b2b8:	1a 9a       	mov	r10,sp
8000b2ba:	e0 a0 04 81 	rcall	8000bbbc <_fstat_r>
8000b2be:	c0 f4       	brge	8000b2dc <__smakebuf_r+0x3c>
8000b2c0:	8e 65       	ld.sh	r5,r7[0xc]
8000b2c2:	0a 98       	mov	r8,r5
8000b2c4:	ab b8       	sbr	r8,0xb
8000b2c6:	e2 15 00 80 	andl	r5,0x80,COH
8000b2ca:	ae 68       	st.h	r7[0xc],r8
8000b2cc:	30 04       	mov	r4,0
8000b2ce:	e0 68 04 00 	mov	r8,1024
8000b2d2:	f9 b5 01 40 	movne	r5,64
8000b2d6:	f0 05 17 00 	moveq	r5,r8
8000b2da:	c1 c8       	rjmp	8000b312 <__smakebuf_r+0x72>
8000b2dc:	40 18       	lddsp	r8,sp[0x4]
8000b2de:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b2e2:	e0 48 20 00 	cp.w	r8,8192
8000b2e6:	5f 04       	sreq	r4
8000b2e8:	e0 48 80 00 	cp.w	r8,32768
8000b2ec:	c0 e1       	brne	8000b308 <__smakebuf_r+0x68>
8000b2ee:	6e b9       	ld.w	r9,r7[0x2c]
8000b2f0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b2f4:	10 39       	cp.w	r9,r8
8000b2f6:	c0 91       	brne	8000b308 <__smakebuf_r+0x68>
8000b2f8:	8e 68       	ld.sh	r8,r7[0xc]
8000b2fa:	e0 65 04 00 	mov	r5,1024
8000b2fe:	ab a8       	sbr	r8,0xa
8000b300:	ef 45 00 50 	st.w	r7[80],r5
8000b304:	ae 68       	st.h	r7[0xc],r8
8000b306:	c0 68       	rjmp	8000b312 <__smakebuf_r+0x72>
8000b308:	8e 68       	ld.sh	r8,r7[0xc]
8000b30a:	e0 65 04 00 	mov	r5,1024
8000b30e:	ab b8       	sbr	r8,0xb
8000b310:	ae 68       	st.h	r7[0xc],r8
8000b312:	0a 9b       	mov	r11,r5
8000b314:	0c 9c       	mov	r12,r6
8000b316:	fe b0 df 35 	rcall	80007180 <_malloc_r>
8000b31a:	8e 68       	ld.sh	r8,r7[0xc]
8000b31c:	c0 d1       	brne	8000b336 <__smakebuf_r+0x96>
8000b31e:	ed b8 00 09 	bld	r8,0x9
8000b322:	c1 b0       	breq	8000b358 <__smakebuf_r+0xb8>
8000b324:	a1 b8       	sbr	r8,0x1
8000b326:	ae 68       	st.h	r7[0xc],r8
8000b328:	ee c8 ff b9 	sub	r8,r7,-71
8000b32c:	8f 48       	st.w	r7[0x10],r8
8000b32e:	8f 08       	st.w	r7[0x0],r8
8000b330:	30 18       	mov	r8,1
8000b332:	8f 58       	st.w	r7[0x14],r8
8000b334:	c1 28       	rjmp	8000b358 <__smakebuf_r+0xb8>
8000b336:	a7 b8       	sbr	r8,0x7
8000b338:	8f 4c       	st.w	r7[0x10],r12
8000b33a:	ae 68       	st.h	r7[0xc],r8
8000b33c:	8f 55       	st.w	r7[0x14],r5
8000b33e:	fe c8 06 e6 	sub	r8,pc,1766
8000b342:	8f 0c       	st.w	r7[0x0],r12
8000b344:	8d a8       	st.w	r6[0x28],r8
8000b346:	58 04       	cp.w	r4,0
8000b348:	c0 80       	breq	8000b358 <__smakebuf_r+0xb8>
8000b34a:	8e 7c       	ld.sh	r12,r7[0xe]
8000b34c:	fe b0 e3 94 	rcall	80007a74 <isatty>
8000b350:	c0 40       	breq	8000b358 <__smakebuf_r+0xb8>
8000b352:	8e 68       	ld.sh	r8,r7[0xc]
8000b354:	a1 a8       	sbr	r8,0x0
8000b356:	ae 68       	st.h	r7[0xc],r8
8000b358:	2f 1d       	sub	sp,-60
8000b35a:	d8 22       	popm	r4-r7,pc

8000b35c <memchr>:
8000b35c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b360:	c0 68       	rjmp	8000b36c <memchr+0x10>
8000b362:	20 1a       	sub	r10,1
8000b364:	19 88       	ld.ub	r8,r12[0x0]
8000b366:	16 38       	cp.w	r8,r11
8000b368:	5e 0c       	reteq	r12
8000b36a:	2f fc       	sub	r12,-1
8000b36c:	58 0a       	cp.w	r10,0
8000b36e:	cf a1       	brne	8000b362 <memchr+0x6>
8000b370:	5e fa       	retal	r10

8000b372 <memmove>:
8000b372:	d4 01       	pushm	lr
8000b374:	18 3b       	cp.w	r11,r12
8000b376:	c1 92       	brcc	8000b3a8 <memmove+0x36>
8000b378:	f6 0a 00 09 	add	r9,r11,r10
8000b37c:	12 3c       	cp.w	r12,r9
8000b37e:	c1 52       	brcc	8000b3a8 <memmove+0x36>
8000b380:	f8 0a 00 0b 	add	r11,r12,r10
8000b384:	30 08       	mov	r8,0
8000b386:	c0 68       	rjmp	8000b392 <memmove+0x20>
8000b388:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b38c:	20 1a       	sub	r10,1
8000b38e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b392:	20 18       	sub	r8,1
8000b394:	58 0a       	cp.w	r10,0
8000b396:	cf 91       	brne	8000b388 <memmove+0x16>
8000b398:	d8 02       	popm	pc
8000b39a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b39e:	20 1a       	sub	r10,1
8000b3a0:	f8 08 0b 09 	st.b	r12[r8],r9
8000b3a4:	2f f8       	sub	r8,-1
8000b3a6:	c0 28       	rjmp	8000b3aa <memmove+0x38>
8000b3a8:	30 08       	mov	r8,0
8000b3aa:	58 0a       	cp.w	r10,0
8000b3ac:	cf 71       	brne	8000b39a <memmove+0x28>
8000b3ae:	d8 02       	popm	pc

8000b3b0 <__hi0bits>:
8000b3b0:	18 98       	mov	r8,r12
8000b3b2:	e0 1c 00 00 	andl	r12,0x0
8000b3b6:	f0 09 15 10 	lsl	r9,r8,0x10
8000b3ba:	58 0c       	cp.w	r12,0
8000b3bc:	f2 08 17 00 	moveq	r8,r9
8000b3c0:	f9 bc 00 10 	moveq	r12,16
8000b3c4:	f9 bc 01 00 	movne	r12,0
8000b3c8:	10 9a       	mov	r10,r8
8000b3ca:	f0 09 15 08 	lsl	r9,r8,0x8
8000b3ce:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b3d2:	f7 bc 00 f8 	subeq	r12,-8
8000b3d6:	f2 08 17 00 	moveq	r8,r9
8000b3da:	10 9a       	mov	r10,r8
8000b3dc:	f0 09 15 04 	lsl	r9,r8,0x4
8000b3e0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b3e4:	f7 bc 00 fc 	subeq	r12,-4
8000b3e8:	f2 08 17 00 	moveq	r8,r9
8000b3ec:	10 9a       	mov	r10,r8
8000b3ee:	f0 09 15 02 	lsl	r9,r8,0x2
8000b3f2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b3f6:	f7 bc 00 fe 	subeq	r12,-2
8000b3fa:	f2 08 17 00 	moveq	r8,r9
8000b3fe:	58 08       	cp.w	r8,0
8000b400:	5e 5c       	retlt	r12
8000b402:	ed b8 00 1e 	bld	r8,0x1e
8000b406:	f9 bc 01 20 	movne	r12,32
8000b40a:	f7 bc 00 ff 	subeq	r12,-1
8000b40e:	5e fc       	retal	r12

8000b410 <__lo0bits>:
8000b410:	18 99       	mov	r9,r12
8000b412:	78 08       	ld.w	r8,r12[0x0]
8000b414:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b418:	c1 50       	breq	8000b442 <__lo0bits+0x32>
8000b41a:	ed b8 00 00 	bld	r8,0x0
8000b41e:	c0 21       	brne	8000b422 <__lo0bits+0x12>
8000b420:	5e fd       	retal	0
8000b422:	10 9b       	mov	r11,r8
8000b424:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b428:	e2 1b 00 02 	andl	r11,0x2,COH
8000b42c:	a3 88       	lsr	r8,0x2
8000b42e:	58 0b       	cp.w	r11,0
8000b430:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b434:	f9 bc 01 01 	movne	r12,1
8000b438:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b43c:	f9 bc 00 02 	moveq	r12,2
8000b440:	5e fc       	retal	r12
8000b442:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b446:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b44a:	58 0a       	cp.w	r10,0
8000b44c:	f6 08 17 00 	moveq	r8,r11
8000b450:	f9 bc 00 10 	moveq	r12,16
8000b454:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b458:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b45c:	58 0b       	cp.w	r11,0
8000b45e:	f7 bc 00 f8 	subeq	r12,-8
8000b462:	f4 08 17 00 	moveq	r8,r10
8000b466:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b46a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b46e:	58 0b       	cp.w	r11,0
8000b470:	f7 bc 00 fc 	subeq	r12,-4
8000b474:	f4 08 17 00 	moveq	r8,r10
8000b478:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b47c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b480:	58 0b       	cp.w	r11,0
8000b482:	f7 bc 00 fe 	subeq	r12,-2
8000b486:	f4 08 17 00 	moveq	r8,r10
8000b48a:	ed b8 00 00 	bld	r8,0x0
8000b48e:	c0 60       	breq	8000b49a <__lo0bits+0x8a>
8000b490:	a1 98       	lsr	r8,0x1
8000b492:	c0 31       	brne	8000b498 <__lo0bits+0x88>
8000b494:	32 0c       	mov	r12,32
8000b496:	5e fc       	retal	r12
8000b498:	2f fc       	sub	r12,-1
8000b49a:	93 08       	st.w	r9[0x0],r8
8000b49c:	5e fc       	retal	r12

8000b49e <__mcmp>:
8000b49e:	d4 01       	pushm	lr
8000b4a0:	18 98       	mov	r8,r12
8000b4a2:	76 49       	ld.w	r9,r11[0x10]
8000b4a4:	78 4c       	ld.w	r12,r12[0x10]
8000b4a6:	12 1c       	sub	r12,r9
8000b4a8:	c1 31       	brne	8000b4ce <__mcmp+0x30>
8000b4aa:	2f b9       	sub	r9,-5
8000b4ac:	a3 69       	lsl	r9,0x2
8000b4ae:	12 0b       	add	r11,r9
8000b4b0:	f0 09 00 09 	add	r9,r8,r9
8000b4b4:	2e c8       	sub	r8,-20
8000b4b6:	13 4e       	ld.w	lr,--r9
8000b4b8:	17 4a       	ld.w	r10,--r11
8000b4ba:	14 3e       	cp.w	lr,r10
8000b4bc:	c0 60       	breq	8000b4c8 <__mcmp+0x2a>
8000b4be:	f9 bc 03 ff 	movlo	r12,-1
8000b4c2:	f9 bc 02 01 	movhs	r12,1
8000b4c6:	d8 02       	popm	pc
8000b4c8:	10 39       	cp.w	r9,r8
8000b4ca:	fe 9b ff f6 	brhi	8000b4b6 <__mcmp+0x18>
8000b4ce:	d8 02       	popm	pc

8000b4d0 <_Bfree>:
8000b4d0:	d4 21       	pushm	r4-r7,lr
8000b4d2:	18 97       	mov	r7,r12
8000b4d4:	16 95       	mov	r5,r11
8000b4d6:	78 96       	ld.w	r6,r12[0x24]
8000b4d8:	58 06       	cp.w	r6,0
8000b4da:	c0 91       	brne	8000b4ec <_Bfree+0x1c>
8000b4dc:	31 0c       	mov	r12,16
8000b4de:	fe b0 de 49 	rcall	80007170 <malloc>
8000b4e2:	99 36       	st.w	r12[0xc],r6
8000b4e4:	8f 9c       	st.w	r7[0x24],r12
8000b4e6:	99 16       	st.w	r12[0x4],r6
8000b4e8:	99 26       	st.w	r12[0x8],r6
8000b4ea:	99 06       	st.w	r12[0x0],r6
8000b4ec:	58 05       	cp.w	r5,0
8000b4ee:	c0 90       	breq	8000b500 <_Bfree+0x30>
8000b4f0:	6a 19       	ld.w	r9,r5[0x4]
8000b4f2:	6e 98       	ld.w	r8,r7[0x24]
8000b4f4:	70 38       	ld.w	r8,r8[0xc]
8000b4f6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b4fa:	8b 0a       	st.w	r5[0x0],r10
8000b4fc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b500:	d8 22       	popm	r4-r7,pc
8000b502:	d7 03       	nop

8000b504 <_Balloc>:
8000b504:	d4 21       	pushm	r4-r7,lr
8000b506:	18 97       	mov	r7,r12
8000b508:	16 96       	mov	r6,r11
8000b50a:	78 95       	ld.w	r5,r12[0x24]
8000b50c:	58 05       	cp.w	r5,0
8000b50e:	c0 91       	brne	8000b520 <_Balloc+0x1c>
8000b510:	31 0c       	mov	r12,16
8000b512:	fe b0 de 2f 	rcall	80007170 <malloc>
8000b516:	99 35       	st.w	r12[0xc],r5
8000b518:	8f 9c       	st.w	r7[0x24],r12
8000b51a:	99 15       	st.w	r12[0x4],r5
8000b51c:	99 25       	st.w	r12[0x8],r5
8000b51e:	99 05       	st.w	r12[0x0],r5
8000b520:	6e 95       	ld.w	r5,r7[0x24]
8000b522:	6a 38       	ld.w	r8,r5[0xc]
8000b524:	58 08       	cp.w	r8,0
8000b526:	c0 b1       	brne	8000b53c <_Balloc+0x38>
8000b528:	31 0a       	mov	r10,16
8000b52a:	30 4b       	mov	r11,4
8000b52c:	0e 9c       	mov	r12,r7
8000b52e:	e0 a0 02 a7 	rcall	8000ba7c <_calloc_r>
8000b532:	8b 3c       	st.w	r5[0xc],r12
8000b534:	6e 98       	ld.w	r8,r7[0x24]
8000b536:	70 3c       	ld.w	r12,r8[0xc]
8000b538:	58 0c       	cp.w	r12,0
8000b53a:	c1 b0       	breq	8000b570 <_Balloc+0x6c>
8000b53c:	6e 98       	ld.w	r8,r7[0x24]
8000b53e:	70 38       	ld.w	r8,r8[0xc]
8000b540:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b544:	70 0c       	ld.w	r12,r8[0x0]
8000b546:	58 0c       	cp.w	r12,0
8000b548:	c0 40       	breq	8000b550 <_Balloc+0x4c>
8000b54a:	78 09       	ld.w	r9,r12[0x0]
8000b54c:	91 09       	st.w	r8[0x0],r9
8000b54e:	c0 e8       	rjmp	8000b56a <_Balloc+0x66>
8000b550:	0e 9c       	mov	r12,r7
8000b552:	30 17       	mov	r7,1
8000b554:	0e 9b       	mov	r11,r7
8000b556:	ee 06 09 47 	lsl	r7,r7,r6
8000b55a:	ee ca ff fb 	sub	r10,r7,-5
8000b55e:	a3 6a       	lsl	r10,0x2
8000b560:	e0 a0 02 8e 	rcall	8000ba7c <_calloc_r>
8000b564:	c0 60       	breq	8000b570 <_Balloc+0x6c>
8000b566:	99 16       	st.w	r12[0x4],r6
8000b568:	99 27       	st.w	r12[0x8],r7
8000b56a:	30 08       	mov	r8,0
8000b56c:	99 38       	st.w	r12[0xc],r8
8000b56e:	99 48       	st.w	r12[0x10],r8
8000b570:	d8 22       	popm	r4-r7,pc
8000b572:	d7 03       	nop

8000b574 <__d2b>:
8000b574:	d4 31       	pushm	r0-r7,lr
8000b576:	20 2d       	sub	sp,8
8000b578:	16 93       	mov	r3,r11
8000b57a:	12 96       	mov	r6,r9
8000b57c:	10 95       	mov	r5,r8
8000b57e:	14 92       	mov	r2,r10
8000b580:	30 1b       	mov	r11,1
8000b582:	cc 1f       	rcall	8000b504 <_Balloc>
8000b584:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b588:	50 09       	stdsp	sp[0x0],r9
8000b58a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b58e:	b5 a9       	sbr	r9,0x14
8000b590:	f0 01 16 14 	lsr	r1,r8,0x14
8000b594:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b598:	18 94       	mov	r4,r12
8000b59a:	58 02       	cp.w	r2,0
8000b59c:	c1 d0       	breq	8000b5d6 <__d2b+0x62>
8000b59e:	fa cc ff f8 	sub	r12,sp,-8
8000b5a2:	18 d2       	st.w	--r12,r2
8000b5a4:	c3 6f       	rcall	8000b410 <__lo0bits>
8000b5a6:	40 18       	lddsp	r8,sp[0x4]
8000b5a8:	c0 d0       	breq	8000b5c2 <__d2b+0x4e>
8000b5aa:	40 09       	lddsp	r9,sp[0x0]
8000b5ac:	f8 0a 11 20 	rsub	r10,r12,32
8000b5b0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b5b4:	f5 e8 10 08 	or	r8,r10,r8
8000b5b8:	89 58       	st.w	r4[0x14],r8
8000b5ba:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b5be:	50 09       	stdsp	sp[0x0],r9
8000b5c0:	c0 28       	rjmp	8000b5c4 <__d2b+0x50>
8000b5c2:	89 58       	st.w	r4[0x14],r8
8000b5c4:	40 08       	lddsp	r8,sp[0x0]
8000b5c6:	58 08       	cp.w	r8,0
8000b5c8:	f9 b3 01 02 	movne	r3,2
8000b5cc:	f9 b3 00 01 	moveq	r3,1
8000b5d0:	89 68       	st.w	r4[0x18],r8
8000b5d2:	89 43       	st.w	r4[0x10],r3
8000b5d4:	c0 88       	rjmp	8000b5e4 <__d2b+0x70>
8000b5d6:	1a 9c       	mov	r12,sp
8000b5d8:	c1 cf       	rcall	8000b410 <__lo0bits>
8000b5da:	30 13       	mov	r3,1
8000b5dc:	40 08       	lddsp	r8,sp[0x0]
8000b5de:	2e 0c       	sub	r12,-32
8000b5e0:	89 43       	st.w	r4[0x10],r3
8000b5e2:	89 58       	st.w	r4[0x14],r8
8000b5e4:	58 01       	cp.w	r1,0
8000b5e6:	c0 90       	breq	8000b5f8 <__d2b+0x84>
8000b5e8:	e2 c1 04 33 	sub	r1,r1,1075
8000b5ec:	18 01       	add	r1,r12
8000b5ee:	8d 01       	st.w	r6[0x0],r1
8000b5f0:	f8 0c 11 35 	rsub	r12,r12,53
8000b5f4:	8b 0c       	st.w	r5[0x0],r12
8000b5f6:	c0 c8       	rjmp	8000b60e <__d2b+0x9a>
8000b5f8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b5fc:	f8 cc 04 32 	sub	r12,r12,1074
8000b600:	a5 73       	lsl	r3,0x5
8000b602:	8d 0c       	st.w	r6[0x0],r12
8000b604:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b608:	cd 4e       	rcall	8000b3b0 <__hi0bits>
8000b60a:	18 13       	sub	r3,r12
8000b60c:	8b 03       	st.w	r5[0x0],r3
8000b60e:	08 9c       	mov	r12,r4
8000b610:	2f ed       	sub	sp,-8
8000b612:	d8 32       	popm	r0-r7,pc

8000b614 <__mdiff>:
8000b614:	d4 31       	pushm	r0-r7,lr
8000b616:	74 48       	ld.w	r8,r10[0x10]
8000b618:	76 45       	ld.w	r5,r11[0x10]
8000b61a:	16 97       	mov	r7,r11
8000b61c:	14 96       	mov	r6,r10
8000b61e:	10 15       	sub	r5,r8
8000b620:	c1 31       	brne	8000b646 <__mdiff+0x32>
8000b622:	2f b8       	sub	r8,-5
8000b624:	ee ce ff ec 	sub	lr,r7,-20
8000b628:	a3 68       	lsl	r8,0x2
8000b62a:	f4 08 00 0b 	add	r11,r10,r8
8000b62e:	ee 08 00 08 	add	r8,r7,r8
8000b632:	11 4a       	ld.w	r10,--r8
8000b634:	17 49       	ld.w	r9,--r11
8000b636:	12 3a       	cp.w	r10,r9
8000b638:	c0 30       	breq	8000b63e <__mdiff+0x2a>
8000b63a:	c0 e2       	brcc	8000b656 <__mdiff+0x42>
8000b63c:	c0 78       	rjmp	8000b64a <__mdiff+0x36>
8000b63e:	1c 38       	cp.w	r8,lr
8000b640:	fe 9b ff f9 	brhi	8000b632 <__mdiff+0x1e>
8000b644:	c4 98       	rjmp	8000b6d6 <__mdiff+0xc2>
8000b646:	58 05       	cp.w	r5,0
8000b648:	c0 64       	brge	8000b654 <__mdiff+0x40>
8000b64a:	0e 98       	mov	r8,r7
8000b64c:	30 15       	mov	r5,1
8000b64e:	0c 97       	mov	r7,r6
8000b650:	10 96       	mov	r6,r8
8000b652:	c0 28       	rjmp	8000b656 <__mdiff+0x42>
8000b654:	30 05       	mov	r5,0
8000b656:	6e 1b       	ld.w	r11,r7[0x4]
8000b658:	c5 6f       	rcall	8000b504 <_Balloc>
8000b65a:	6e 49       	ld.w	r9,r7[0x10]
8000b65c:	6c 44       	ld.w	r4,r6[0x10]
8000b65e:	99 35       	st.w	r12[0xc],r5
8000b660:	2f b4       	sub	r4,-5
8000b662:	f2 c5 ff fb 	sub	r5,r9,-5
8000b666:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b66a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b66e:	2e c6       	sub	r6,-20
8000b670:	2e c7       	sub	r7,-20
8000b672:	f8 c8 ff ec 	sub	r8,r12,-20
8000b676:	30 0a       	mov	r10,0
8000b678:	0f 0e       	ld.w	lr,r7++
8000b67a:	0d 0b       	ld.w	r11,r6++
8000b67c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b680:	f6 03 16 10 	lsr	r3,r11,0x10
8000b684:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b688:	e4 03 01 03 	sub	r3,r2,r3
8000b68c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b690:	fc 0b 01 0b 	sub	r11,lr,r11
8000b694:	f6 0a 00 0a 	add	r10,r11,r10
8000b698:	b0 1a       	st.h	r8[0x2],r10
8000b69a:	b1 4a       	asr	r10,0x10
8000b69c:	e6 0a 00 0a 	add	r10,r3,r10
8000b6a0:	b0 0a       	st.h	r8[0x0],r10
8000b6a2:	2f c8       	sub	r8,-4
8000b6a4:	b1 4a       	asr	r10,0x10
8000b6a6:	08 36       	cp.w	r6,r4
8000b6a8:	ce 83       	brcs	8000b678 <__mdiff+0x64>
8000b6aa:	c0 d8       	rjmp	8000b6c4 <__mdiff+0xb0>
8000b6ac:	0f 0b       	ld.w	r11,r7++
8000b6ae:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b6b2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b6b6:	16 0a       	add	r10,r11
8000b6b8:	b0 1a       	st.h	r8[0x2],r10
8000b6ba:	b1 4a       	asr	r10,0x10
8000b6bc:	1c 0a       	add	r10,lr
8000b6be:	b0 0a       	st.h	r8[0x0],r10
8000b6c0:	2f c8       	sub	r8,-4
8000b6c2:	b1 4a       	asr	r10,0x10
8000b6c4:	0a 37       	cp.w	r7,r5
8000b6c6:	cf 33       	brcs	8000b6ac <__mdiff+0x98>
8000b6c8:	c0 28       	rjmp	8000b6cc <__mdiff+0xb8>
8000b6ca:	20 19       	sub	r9,1
8000b6cc:	11 4a       	ld.w	r10,--r8
8000b6ce:	58 0a       	cp.w	r10,0
8000b6d0:	cf d0       	breq	8000b6ca <__mdiff+0xb6>
8000b6d2:	99 49       	st.w	r12[0x10],r9
8000b6d4:	d8 32       	popm	r0-r7,pc
8000b6d6:	30 0b       	mov	r11,0
8000b6d8:	c1 6f       	rcall	8000b504 <_Balloc>
8000b6da:	30 18       	mov	r8,1
8000b6dc:	99 48       	st.w	r12[0x10],r8
8000b6de:	30 08       	mov	r8,0
8000b6e0:	99 58       	st.w	r12[0x14],r8
8000b6e2:	d8 32       	popm	r0-r7,pc

8000b6e4 <__lshift>:
8000b6e4:	d4 31       	pushm	r0-r7,lr
8000b6e6:	16 97       	mov	r7,r11
8000b6e8:	76 46       	ld.w	r6,r11[0x10]
8000b6ea:	f4 02 14 05 	asr	r2,r10,0x5
8000b6ee:	2f f6       	sub	r6,-1
8000b6f0:	14 93       	mov	r3,r10
8000b6f2:	18 94       	mov	r4,r12
8000b6f4:	04 06       	add	r6,r2
8000b6f6:	76 1b       	ld.w	r11,r11[0x4]
8000b6f8:	6e 28       	ld.w	r8,r7[0x8]
8000b6fa:	c0 38       	rjmp	8000b700 <__lshift+0x1c>
8000b6fc:	2f fb       	sub	r11,-1
8000b6fe:	a1 78       	lsl	r8,0x1
8000b700:	10 36       	cp.w	r6,r8
8000b702:	fe 99 ff fd 	brgt	8000b6fc <__lshift+0x18>
8000b706:	08 9c       	mov	r12,r4
8000b708:	cf ee       	rcall	8000b504 <_Balloc>
8000b70a:	30 09       	mov	r9,0
8000b70c:	18 95       	mov	r5,r12
8000b70e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b712:	12 9a       	mov	r10,r9
8000b714:	c0 38       	rjmp	8000b71a <__lshift+0x36>
8000b716:	10 aa       	st.w	r8++,r10
8000b718:	2f f9       	sub	r9,-1
8000b71a:	04 39       	cp.w	r9,r2
8000b71c:	cf d5       	brlt	8000b716 <__lshift+0x32>
8000b71e:	6e 4b       	ld.w	r11,r7[0x10]
8000b720:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b724:	2f bb       	sub	r11,-5
8000b726:	ee c9 ff ec 	sub	r9,r7,-20
8000b72a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b72e:	58 03       	cp.w	r3,0
8000b730:	c1 30       	breq	8000b756 <__lshift+0x72>
8000b732:	e6 0c 11 20 	rsub	r12,r3,32
8000b736:	30 0a       	mov	r10,0
8000b738:	72 02       	ld.w	r2,r9[0x0]
8000b73a:	e4 03 09 42 	lsl	r2,r2,r3
8000b73e:	04 4a       	or	r10,r2
8000b740:	10 aa       	st.w	r8++,r10
8000b742:	13 0a       	ld.w	r10,r9++
8000b744:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b748:	16 39       	cp.w	r9,r11
8000b74a:	cf 73       	brcs	8000b738 <__lshift+0x54>
8000b74c:	91 0a       	st.w	r8[0x0],r10
8000b74e:	58 0a       	cp.w	r10,0
8000b750:	c0 70       	breq	8000b75e <__lshift+0x7a>
8000b752:	2f f6       	sub	r6,-1
8000b754:	c0 58       	rjmp	8000b75e <__lshift+0x7a>
8000b756:	13 0a       	ld.w	r10,r9++
8000b758:	10 aa       	st.w	r8++,r10
8000b75a:	16 39       	cp.w	r9,r11
8000b75c:	cf d3       	brcs	8000b756 <__lshift+0x72>
8000b75e:	08 9c       	mov	r12,r4
8000b760:	20 16       	sub	r6,1
8000b762:	0e 9b       	mov	r11,r7
8000b764:	8b 46       	st.w	r5[0x10],r6
8000b766:	cb 5e       	rcall	8000b4d0 <_Bfree>
8000b768:	0a 9c       	mov	r12,r5
8000b76a:	d8 32       	popm	r0-r7,pc

8000b76c <__multiply>:
8000b76c:	d4 31       	pushm	r0-r7,lr
8000b76e:	20 2d       	sub	sp,8
8000b770:	76 49       	ld.w	r9,r11[0x10]
8000b772:	74 48       	ld.w	r8,r10[0x10]
8000b774:	16 96       	mov	r6,r11
8000b776:	14 95       	mov	r5,r10
8000b778:	10 39       	cp.w	r9,r8
8000b77a:	ec 08 17 50 	movlt	r8,r6
8000b77e:	ea 06 17 50 	movlt	r6,r5
8000b782:	f0 05 17 50 	movlt	r5,r8
8000b786:	6c 28       	ld.w	r8,r6[0x8]
8000b788:	76 43       	ld.w	r3,r11[0x10]
8000b78a:	74 42       	ld.w	r2,r10[0x10]
8000b78c:	76 1b       	ld.w	r11,r11[0x4]
8000b78e:	e4 03 00 07 	add	r7,r2,r3
8000b792:	10 37       	cp.w	r7,r8
8000b794:	f7 bb 09 ff 	subgt	r11,-1
8000b798:	cb 6e       	rcall	8000b504 <_Balloc>
8000b79a:	ee c4 ff fb 	sub	r4,r7,-5
8000b79e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b7a2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b7a6:	30 0a       	mov	r10,0
8000b7a8:	12 98       	mov	r8,r9
8000b7aa:	c0 28       	rjmp	8000b7ae <__multiply+0x42>
8000b7ac:	10 aa       	st.w	r8++,r10
8000b7ae:	08 38       	cp.w	r8,r4
8000b7b0:	cf e3       	brcs	8000b7ac <__multiply+0x40>
8000b7b2:	2f b3       	sub	r3,-5
8000b7b4:	2f b2       	sub	r2,-5
8000b7b6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b7ba:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b7be:	ec cb ff ec 	sub	r11,r6,-20
8000b7c2:	50 12       	stdsp	sp[0x4],r2
8000b7c4:	ea ca ff ec 	sub	r10,r5,-20
8000b7c8:	c4 48       	rjmp	8000b850 <__multiply+0xe4>
8000b7ca:	94 95       	ld.uh	r5,r10[0x2]
8000b7cc:	58 05       	cp.w	r5,0
8000b7ce:	c2 00       	breq	8000b80e <__multiply+0xa2>
8000b7d0:	12 98       	mov	r8,r9
8000b7d2:	16 96       	mov	r6,r11
8000b7d4:	30 0e       	mov	lr,0
8000b7d6:	50 09       	stdsp	sp[0x0],r9
8000b7d8:	0d 02       	ld.w	r2,r6++
8000b7da:	e4 00 16 10 	lsr	r0,r2,0x10
8000b7de:	70 01       	ld.w	r1,r8[0x0]
8000b7e0:	70 09       	ld.w	r9,r8[0x0]
8000b7e2:	b1 81       	lsr	r1,0x10
8000b7e4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b7e8:	e0 05 03 41 	mac	r1,r0,r5
8000b7ec:	ab 32       	mul	r2,r5
8000b7ee:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b7f2:	00 02       	add	r2,r0
8000b7f4:	e4 0e 00 0e 	add	lr,r2,lr
8000b7f8:	b0 1e       	st.h	r8[0x2],lr
8000b7fa:	b1 8e       	lsr	lr,0x10
8000b7fc:	1c 01       	add	r1,lr
8000b7fe:	b0 01       	st.h	r8[0x0],r1
8000b800:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b804:	2f c8       	sub	r8,-4
8000b806:	06 36       	cp.w	r6,r3
8000b808:	ce 83       	brcs	8000b7d8 <__multiply+0x6c>
8000b80a:	40 09       	lddsp	r9,sp[0x0]
8000b80c:	91 0e       	st.w	r8[0x0],lr
8000b80e:	94 86       	ld.uh	r6,r10[0x0]
8000b810:	58 06       	cp.w	r6,0
8000b812:	c1 d0       	breq	8000b84c <__multiply+0xe0>
8000b814:	72 02       	ld.w	r2,r9[0x0]
8000b816:	12 98       	mov	r8,r9
8000b818:	16 9e       	mov	lr,r11
8000b81a:	30 05       	mov	r5,0
8000b81c:	b0 12       	st.h	r8[0x2],r2
8000b81e:	1d 01       	ld.w	r1,lr++
8000b820:	90 82       	ld.uh	r2,r8[0x0]
8000b822:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b826:	ad 30       	mul	r0,r6
8000b828:	e0 02 00 02 	add	r2,r0,r2
8000b82c:	e4 05 00 05 	add	r5,r2,r5
8000b830:	b0 05       	st.h	r8[0x0],r5
8000b832:	b1 85       	lsr	r5,0x10
8000b834:	b1 81       	lsr	r1,0x10
8000b836:	2f c8       	sub	r8,-4
8000b838:	ad 31       	mul	r1,r6
8000b83a:	90 92       	ld.uh	r2,r8[0x2]
8000b83c:	e2 02 00 02 	add	r2,r1,r2
8000b840:	0a 02       	add	r2,r5
8000b842:	e4 05 16 10 	lsr	r5,r2,0x10
8000b846:	06 3e       	cp.w	lr,r3
8000b848:	ce a3       	brcs	8000b81c <__multiply+0xb0>
8000b84a:	91 02       	st.w	r8[0x0],r2
8000b84c:	2f ca       	sub	r10,-4
8000b84e:	2f c9       	sub	r9,-4
8000b850:	40 18       	lddsp	r8,sp[0x4]
8000b852:	10 3a       	cp.w	r10,r8
8000b854:	cb b3       	brcs	8000b7ca <__multiply+0x5e>
8000b856:	c0 28       	rjmp	8000b85a <__multiply+0xee>
8000b858:	20 17       	sub	r7,1
8000b85a:	58 07       	cp.w	r7,0
8000b85c:	e0 8a 00 05 	brle	8000b866 <__multiply+0xfa>
8000b860:	09 48       	ld.w	r8,--r4
8000b862:	58 08       	cp.w	r8,0
8000b864:	cf a0       	breq	8000b858 <__multiply+0xec>
8000b866:	99 47       	st.w	r12[0x10],r7
8000b868:	2f ed       	sub	sp,-8
8000b86a:	d8 32       	popm	r0-r7,pc

8000b86c <__i2b>:
8000b86c:	d4 21       	pushm	r4-r7,lr
8000b86e:	16 97       	mov	r7,r11
8000b870:	30 1b       	mov	r11,1
8000b872:	c4 9e       	rcall	8000b504 <_Balloc>
8000b874:	30 19       	mov	r9,1
8000b876:	99 57       	st.w	r12[0x14],r7
8000b878:	99 49       	st.w	r12[0x10],r9
8000b87a:	d8 22       	popm	r4-r7,pc

8000b87c <__multadd>:
8000b87c:	d4 31       	pushm	r0-r7,lr
8000b87e:	30 08       	mov	r8,0
8000b880:	12 95       	mov	r5,r9
8000b882:	16 97       	mov	r7,r11
8000b884:	18 96       	mov	r6,r12
8000b886:	76 44       	ld.w	r4,r11[0x10]
8000b888:	f6 c9 ff ec 	sub	r9,r11,-20
8000b88c:	72 0b       	ld.w	r11,r9[0x0]
8000b88e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b892:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b896:	f4 0c 02 4c 	mul	r12,r10,r12
8000b89a:	f4 0b 03 45 	mac	r5,r10,r11
8000b89e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b8a2:	b1 85       	lsr	r5,0x10
8000b8a4:	18 05       	add	r5,r12
8000b8a6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b8aa:	f8 0b 00 0b 	add	r11,r12,r11
8000b8ae:	12 ab       	st.w	r9++,r11
8000b8b0:	2f f8       	sub	r8,-1
8000b8b2:	b1 85       	lsr	r5,0x10
8000b8b4:	08 38       	cp.w	r8,r4
8000b8b6:	ce b5       	brlt	8000b88c <__multadd+0x10>
8000b8b8:	58 05       	cp.w	r5,0
8000b8ba:	c1 c0       	breq	8000b8f2 <__multadd+0x76>
8000b8bc:	6e 28       	ld.w	r8,r7[0x8]
8000b8be:	10 34       	cp.w	r4,r8
8000b8c0:	c1 35       	brlt	8000b8e6 <__multadd+0x6a>
8000b8c2:	6e 1b       	ld.w	r11,r7[0x4]
8000b8c4:	0c 9c       	mov	r12,r6
8000b8c6:	2f fb       	sub	r11,-1
8000b8c8:	c1 ee       	rcall	8000b504 <_Balloc>
8000b8ca:	6e 4a       	ld.w	r10,r7[0x10]
8000b8cc:	ee cb ff f4 	sub	r11,r7,-12
8000b8d0:	18 93       	mov	r3,r12
8000b8d2:	2f ea       	sub	r10,-2
8000b8d4:	2f 4c       	sub	r12,-12
8000b8d6:	a3 6a       	lsl	r10,0x2
8000b8d8:	fe b0 de 70 	rcall	800075b8 <memcpy>
8000b8dc:	0e 9b       	mov	r11,r7
8000b8de:	0c 9c       	mov	r12,r6
8000b8e0:	fe b0 fd f8 	rcall	8000b4d0 <_Bfree>
8000b8e4:	06 97       	mov	r7,r3
8000b8e6:	e8 c8 ff ff 	sub	r8,r4,-1
8000b8ea:	2f b4       	sub	r4,-5
8000b8ec:	8f 48       	st.w	r7[0x10],r8
8000b8ee:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b8f2:	0e 9c       	mov	r12,r7
8000b8f4:	d8 32       	popm	r0-r7,pc
8000b8f6:	d7 03       	nop

8000b8f8 <__pow5mult>:
8000b8f8:	d4 31       	pushm	r0-r7,lr
8000b8fa:	14 96       	mov	r6,r10
8000b8fc:	18 97       	mov	r7,r12
8000b8fe:	16 94       	mov	r4,r11
8000b900:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b904:	c0 90       	breq	8000b916 <__pow5mult+0x1e>
8000b906:	20 18       	sub	r8,1
8000b908:	fe c9 d9 b8 	sub	r9,pc,-9800
8000b90c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b910:	30 09       	mov	r9,0
8000b912:	cb 5f       	rcall	8000b87c <__multadd>
8000b914:	18 94       	mov	r4,r12
8000b916:	a3 46       	asr	r6,0x2
8000b918:	c3 40       	breq	8000b980 <__pow5mult+0x88>
8000b91a:	6e 95       	ld.w	r5,r7[0x24]
8000b91c:	58 05       	cp.w	r5,0
8000b91e:	c0 91       	brne	8000b930 <__pow5mult+0x38>
8000b920:	31 0c       	mov	r12,16
8000b922:	fe b0 dc 27 	rcall	80007170 <malloc>
8000b926:	99 35       	st.w	r12[0xc],r5
8000b928:	8f 9c       	st.w	r7[0x24],r12
8000b92a:	99 15       	st.w	r12[0x4],r5
8000b92c:	99 25       	st.w	r12[0x8],r5
8000b92e:	99 05       	st.w	r12[0x0],r5
8000b930:	6e 93       	ld.w	r3,r7[0x24]
8000b932:	66 25       	ld.w	r5,r3[0x8]
8000b934:	58 05       	cp.w	r5,0
8000b936:	c0 c1       	brne	8000b94e <__pow5mult+0x56>
8000b938:	e0 6b 02 71 	mov	r11,625
8000b93c:	0e 9c       	mov	r12,r7
8000b93e:	c9 7f       	rcall	8000b86c <__i2b>
8000b940:	87 2c       	st.w	r3[0x8],r12
8000b942:	30 08       	mov	r8,0
8000b944:	18 95       	mov	r5,r12
8000b946:	99 08       	st.w	r12[0x0],r8
8000b948:	c0 38       	rjmp	8000b94e <__pow5mult+0x56>
8000b94a:	06 9c       	mov	r12,r3
8000b94c:	18 95       	mov	r5,r12
8000b94e:	ed b6 00 00 	bld	r6,0x0
8000b952:	c0 b1       	brne	8000b968 <__pow5mult+0x70>
8000b954:	08 9b       	mov	r11,r4
8000b956:	0a 9a       	mov	r10,r5
8000b958:	0e 9c       	mov	r12,r7
8000b95a:	c0 9f       	rcall	8000b76c <__multiply>
8000b95c:	08 9b       	mov	r11,r4
8000b95e:	18 93       	mov	r3,r12
8000b960:	0e 9c       	mov	r12,r7
8000b962:	06 94       	mov	r4,r3
8000b964:	fe b0 fd b6 	rcall	8000b4d0 <_Bfree>
8000b968:	a1 56       	asr	r6,0x1
8000b96a:	c0 b0       	breq	8000b980 <__pow5mult+0x88>
8000b96c:	6a 03       	ld.w	r3,r5[0x0]
8000b96e:	58 03       	cp.w	r3,0
8000b970:	ce d1       	brne	8000b94a <__pow5mult+0x52>
8000b972:	0a 9a       	mov	r10,r5
8000b974:	0a 9b       	mov	r11,r5
8000b976:	0e 9c       	mov	r12,r7
8000b978:	cf ae       	rcall	8000b76c <__multiply>
8000b97a:	8b 0c       	st.w	r5[0x0],r12
8000b97c:	99 03       	st.w	r12[0x0],r3
8000b97e:	ce 7b       	rjmp	8000b94c <__pow5mult+0x54>
8000b980:	08 9c       	mov	r12,r4
8000b982:	d8 32       	popm	r0-r7,pc

8000b984 <__isinfd>:
8000b984:	14 98       	mov	r8,r10
8000b986:	fc 19 7f f0 	movh	r9,0x7ff0
8000b98a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b98e:	f0 0b 11 00 	rsub	r11,r8,0
8000b992:	f7 e8 10 08 	or	r8,r11,r8
8000b996:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b99a:	f2 08 01 08 	sub	r8,r9,r8
8000b99e:	f0 0c 11 00 	rsub	r12,r8,0
8000b9a2:	f9 e8 10 08 	or	r8,r12,r8
8000b9a6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b9aa:	2f fc       	sub	r12,-1
8000b9ac:	5e fc       	retal	r12

8000b9ae <__isnand>:
8000b9ae:	14 98       	mov	r8,r10
8000b9b0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b9b4:	f0 0c 11 00 	rsub	r12,r8,0
8000b9b8:	10 4c       	or	r12,r8
8000b9ba:	fc 18 7f f0 	movh	r8,0x7ff0
8000b9be:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b9c2:	f0 0c 01 0c 	sub	r12,r8,r12
8000b9c6:	bf 9c       	lsr	r12,0x1f
8000b9c8:	5e fc       	retal	r12
8000b9ca:	d7 03       	nop

8000b9cc <__sclose>:
8000b9cc:	d4 01       	pushm	lr
8000b9ce:	96 7b       	ld.sh	r11,r11[0xe]
8000b9d0:	c8 2c       	rcall	8000bad4 <_close_r>
8000b9d2:	d8 02       	popm	pc

8000b9d4 <__sseek>:
8000b9d4:	d4 21       	pushm	r4-r7,lr
8000b9d6:	16 97       	mov	r7,r11
8000b9d8:	96 7b       	ld.sh	r11,r11[0xe]
8000b9da:	c0 3d       	rcall	8000bbe0 <_lseek_r>
8000b9dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b9de:	10 99       	mov	r9,r8
8000b9e0:	ad c8       	cbr	r8,0xc
8000b9e2:	ad a9       	sbr	r9,0xc
8000b9e4:	5b fc       	cp.w	r12,-1
8000b9e6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b9ea:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b9ee:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b9f2:	d8 22       	popm	r4-r7,pc

8000b9f4 <__swrite>:
8000b9f4:	d4 21       	pushm	r4-r7,lr
8000b9f6:	96 68       	ld.sh	r8,r11[0xc]
8000b9f8:	16 97       	mov	r7,r11
8000b9fa:	14 95       	mov	r5,r10
8000b9fc:	12 94       	mov	r4,r9
8000b9fe:	e2 18 01 00 	andl	r8,0x100,COH
8000ba02:	18 96       	mov	r6,r12
8000ba04:	c0 50       	breq	8000ba0e <__swrite+0x1a>
8000ba06:	30 29       	mov	r9,2
8000ba08:	30 0a       	mov	r10,0
8000ba0a:	96 7b       	ld.sh	r11,r11[0xe]
8000ba0c:	ce ac       	rcall	8000bbe0 <_lseek_r>
8000ba0e:	8e 68       	ld.sh	r8,r7[0xc]
8000ba10:	ad c8       	cbr	r8,0xc
8000ba12:	08 99       	mov	r9,r4
8000ba14:	0a 9a       	mov	r10,r5
8000ba16:	8e 7b       	ld.sh	r11,r7[0xe]
8000ba18:	0c 9c       	mov	r12,r6
8000ba1a:	ae 68       	st.h	r7[0xc],r8
8000ba1c:	c1 cc       	rcall	8000ba54 <_write_r>
8000ba1e:	d8 22       	popm	r4-r7,pc

8000ba20 <__sread>:
8000ba20:	d4 21       	pushm	r4-r7,lr
8000ba22:	16 97       	mov	r7,r11
8000ba24:	96 7b       	ld.sh	r11,r11[0xe]
8000ba26:	cf 1c       	rcall	8000bc08 <_read_r>
8000ba28:	c0 65       	brlt	8000ba34 <__sread+0x14>
8000ba2a:	6f 58       	ld.w	r8,r7[0x54]
8000ba2c:	18 08       	add	r8,r12
8000ba2e:	ef 48 00 54 	st.w	r7[84],r8
8000ba32:	d8 22       	popm	r4-r7,pc
8000ba34:	8e 68       	ld.sh	r8,r7[0xc]
8000ba36:	ad c8       	cbr	r8,0xc
8000ba38:	ae 68       	st.h	r7[0xc],r8
8000ba3a:	d8 22       	popm	r4-r7,pc

8000ba3c <strlen>:
8000ba3c:	30 09       	mov	r9,0
8000ba3e:	18 98       	mov	r8,r12
8000ba40:	c0 28       	rjmp	8000ba44 <strlen+0x8>
8000ba42:	2f f8       	sub	r8,-1
8000ba44:	11 8a       	ld.ub	r10,r8[0x0]
8000ba46:	f2 0a 18 00 	cp.b	r10,r9
8000ba4a:	cf c1       	brne	8000ba42 <strlen+0x6>
8000ba4c:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba50:	5e fc       	retal	r12
8000ba52:	d7 03       	nop

8000ba54 <_write_r>:
8000ba54:	d4 21       	pushm	r4-r7,lr
8000ba56:	16 98       	mov	r8,r11
8000ba58:	18 97       	mov	r7,r12
8000ba5a:	10 9c       	mov	r12,r8
8000ba5c:	30 08       	mov	r8,0
8000ba5e:	14 9b       	mov	r11,r10
8000ba60:	e0 66 5b 68 	mov	r6,23400
8000ba64:	12 9a       	mov	r10,r9
8000ba66:	8d 08       	st.w	r6[0x0],r8
8000ba68:	fe b0 d1 9e 	rcall	80005da4 <_write>
8000ba6c:	5b fc       	cp.w	r12,-1
8000ba6e:	c0 51       	brne	8000ba78 <_write_r+0x24>
8000ba70:	6c 08       	ld.w	r8,r6[0x0]
8000ba72:	58 08       	cp.w	r8,0
8000ba74:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ba78:	d8 22       	popm	r4-r7,pc
8000ba7a:	d7 03       	nop

8000ba7c <_calloc_r>:
8000ba7c:	d4 21       	pushm	r4-r7,lr
8000ba7e:	f4 0b 02 4b 	mul	r11,r10,r11
8000ba82:	fe b0 db 7f 	rcall	80007180 <_malloc_r>
8000ba86:	18 97       	mov	r7,r12
8000ba88:	c2 30       	breq	8000bace <_calloc_r+0x52>
8000ba8a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ba8e:	e0 1a ff fc 	andl	r10,0xfffc
8000ba92:	20 4a       	sub	r10,4
8000ba94:	e0 4a 00 24 	cp.w	r10,36
8000ba98:	e0 8b 00 18 	brhi	8000bac8 <_calloc_r+0x4c>
8000ba9c:	18 98       	mov	r8,r12
8000ba9e:	59 3a       	cp.w	r10,19
8000baa0:	e0 88 00 0f 	brls	8000babe <_calloc_r+0x42>
8000baa4:	30 09       	mov	r9,0
8000baa6:	10 a9       	st.w	r8++,r9
8000baa8:	10 a9       	st.w	r8++,r9
8000baaa:	59 ba       	cp.w	r10,27
8000baac:	e0 88 00 09 	brls	8000babe <_calloc_r+0x42>
8000bab0:	10 a9       	st.w	r8++,r9
8000bab2:	10 a9       	st.w	r8++,r9
8000bab4:	e0 4a 00 24 	cp.w	r10,36
8000bab8:	c0 31       	brne	8000babe <_calloc_r+0x42>
8000baba:	10 a9       	st.w	r8++,r9
8000babc:	10 a9       	st.w	r8++,r9
8000babe:	30 09       	mov	r9,0
8000bac0:	10 a9       	st.w	r8++,r9
8000bac2:	91 19       	st.w	r8[0x4],r9
8000bac4:	91 09       	st.w	r8[0x0],r9
8000bac6:	c0 48       	rjmp	8000bace <_calloc_r+0x52>
8000bac8:	30 0b       	mov	r11,0
8000baca:	fe b0 de 1b 	rcall	80007700 <memset>
8000bace:	0e 9c       	mov	r12,r7
8000bad0:	d8 22       	popm	r4-r7,pc
8000bad2:	d7 03       	nop

8000bad4 <_close_r>:
8000bad4:	d4 21       	pushm	r4-r7,lr
8000bad6:	30 08       	mov	r8,0
8000bad8:	18 97       	mov	r7,r12
8000bada:	e0 66 5b 68 	mov	r6,23400
8000bade:	16 9c       	mov	r12,r11
8000bae0:	8d 08       	st.w	r6[0x0],r8
8000bae2:	fe b0 df b5 	rcall	80007a4c <_close>
8000bae6:	5b fc       	cp.w	r12,-1
8000bae8:	c0 51       	brne	8000baf2 <_close_r+0x1e>
8000baea:	6c 08       	ld.w	r8,r6[0x0]
8000baec:	58 08       	cp.w	r8,0
8000baee:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000baf2:	d8 22       	popm	r4-r7,pc

8000baf4 <_fclose_r>:
8000baf4:	d4 21       	pushm	r4-r7,lr
8000baf6:	18 96       	mov	r6,r12
8000baf8:	16 97       	mov	r7,r11
8000bafa:	58 0b       	cp.w	r11,0
8000bafc:	c0 31       	brne	8000bb02 <_fclose_r+0xe>
8000bafe:	16 95       	mov	r5,r11
8000bb00:	c5 38       	rjmp	8000bba6 <_fclose_r+0xb2>
8000bb02:	fe b0 f8 a9 	rcall	8000ac54 <__sfp_lock_acquire>
8000bb06:	58 06       	cp.w	r6,0
8000bb08:	c0 70       	breq	8000bb16 <_fclose_r+0x22>
8000bb0a:	6c 68       	ld.w	r8,r6[0x18]
8000bb0c:	58 08       	cp.w	r8,0
8000bb0e:	c0 41       	brne	8000bb16 <_fclose_r+0x22>
8000bb10:	0c 9c       	mov	r12,r6
8000bb12:	fe b0 f8 f3 	rcall	8000acf8 <__sinit>
8000bb16:	fe c8 dc 6a 	sub	r8,pc,-9110
8000bb1a:	10 37       	cp.w	r7,r8
8000bb1c:	c0 31       	brne	8000bb22 <_fclose_r+0x2e>
8000bb1e:	6c 07       	ld.w	r7,r6[0x0]
8000bb20:	c0 c8       	rjmp	8000bb38 <_fclose_r+0x44>
8000bb22:	fe c8 dc 56 	sub	r8,pc,-9130
8000bb26:	10 37       	cp.w	r7,r8
8000bb28:	c0 31       	brne	8000bb2e <_fclose_r+0x3a>
8000bb2a:	6c 17       	ld.w	r7,r6[0x4]
8000bb2c:	c0 68       	rjmp	8000bb38 <_fclose_r+0x44>
8000bb2e:	fe c8 dc 42 	sub	r8,pc,-9150
8000bb32:	10 37       	cp.w	r7,r8
8000bb34:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bb38:	8e 69       	ld.sh	r9,r7[0xc]
8000bb3a:	30 08       	mov	r8,0
8000bb3c:	f0 09 19 00 	cp.h	r9,r8
8000bb40:	c0 51       	brne	8000bb4a <_fclose_r+0x56>
8000bb42:	fe b0 f8 8a 	rcall	8000ac56 <__sfp_lock_release>
8000bb46:	30 05       	mov	r5,0
8000bb48:	c2 f8       	rjmp	8000bba6 <_fclose_r+0xb2>
8000bb4a:	0e 9b       	mov	r11,r7
8000bb4c:	0c 9c       	mov	r12,r6
8000bb4e:	fe b0 f7 fd 	rcall	8000ab48 <_fflush_r>
8000bb52:	6e c8       	ld.w	r8,r7[0x30]
8000bb54:	18 95       	mov	r5,r12
8000bb56:	58 08       	cp.w	r8,0
8000bb58:	c0 60       	breq	8000bb64 <_fclose_r+0x70>
8000bb5a:	6e 8b       	ld.w	r11,r7[0x20]
8000bb5c:	0c 9c       	mov	r12,r6
8000bb5e:	5d 18       	icall	r8
8000bb60:	f9 b5 05 ff 	movlt	r5,-1
8000bb64:	8e 68       	ld.sh	r8,r7[0xc]
8000bb66:	ed b8 00 07 	bld	r8,0x7
8000bb6a:	c0 51       	brne	8000bb74 <_fclose_r+0x80>
8000bb6c:	6e 4b       	ld.w	r11,r7[0x10]
8000bb6e:	0c 9c       	mov	r12,r6
8000bb70:	fe b0 f9 5e 	rcall	8000ae2c <_free_r>
8000bb74:	6e db       	ld.w	r11,r7[0x34]
8000bb76:	58 0b       	cp.w	r11,0
8000bb78:	c0 a0       	breq	8000bb8c <_fclose_r+0x98>
8000bb7a:	ee c8 ff bc 	sub	r8,r7,-68
8000bb7e:	10 3b       	cp.w	r11,r8
8000bb80:	c0 40       	breq	8000bb88 <_fclose_r+0x94>
8000bb82:	0c 9c       	mov	r12,r6
8000bb84:	fe b0 f9 54 	rcall	8000ae2c <_free_r>
8000bb88:	30 08       	mov	r8,0
8000bb8a:	8f d8       	st.w	r7[0x34],r8
8000bb8c:	6f 2b       	ld.w	r11,r7[0x48]
8000bb8e:	58 0b       	cp.w	r11,0
8000bb90:	c0 70       	breq	8000bb9e <_fclose_r+0xaa>
8000bb92:	0c 9c       	mov	r12,r6
8000bb94:	fe b0 f9 4c 	rcall	8000ae2c <_free_r>
8000bb98:	30 08       	mov	r8,0
8000bb9a:	ef 48 00 48 	st.w	r7[72],r8
8000bb9e:	30 08       	mov	r8,0
8000bba0:	ae 68       	st.h	r7[0xc],r8
8000bba2:	fe b0 f8 5a 	rcall	8000ac56 <__sfp_lock_release>
8000bba6:	0a 9c       	mov	r12,r5
8000bba8:	d8 22       	popm	r4-r7,pc
8000bbaa:	d7 03       	nop

8000bbac <fclose>:
8000bbac:	d4 01       	pushm	lr
8000bbae:	e0 68 0a 3c 	mov	r8,2620
8000bbb2:	18 9b       	mov	r11,r12
8000bbb4:	70 0c       	ld.w	r12,r8[0x0]
8000bbb6:	c9 ff       	rcall	8000baf4 <_fclose_r>
8000bbb8:	d8 02       	popm	pc
8000bbba:	d7 03       	nop

8000bbbc <_fstat_r>:
8000bbbc:	d4 21       	pushm	r4-r7,lr
8000bbbe:	16 98       	mov	r8,r11
8000bbc0:	18 97       	mov	r7,r12
8000bbc2:	10 9c       	mov	r12,r8
8000bbc4:	30 08       	mov	r8,0
8000bbc6:	e0 66 5b 68 	mov	r6,23400
8000bbca:	14 9b       	mov	r11,r10
8000bbcc:	8d 08       	st.w	r6[0x0],r8
8000bbce:	fe b0 df 67 	rcall	80007a9c <_fstat>
8000bbd2:	5b fc       	cp.w	r12,-1
8000bbd4:	c0 51       	brne	8000bbde <_fstat_r+0x22>
8000bbd6:	6c 08       	ld.w	r8,r6[0x0]
8000bbd8:	58 08       	cp.w	r8,0
8000bbda:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbde:	d8 22       	popm	r4-r7,pc

8000bbe0 <_lseek_r>:
8000bbe0:	d4 21       	pushm	r4-r7,lr
8000bbe2:	16 98       	mov	r8,r11
8000bbe4:	18 97       	mov	r7,r12
8000bbe6:	10 9c       	mov	r12,r8
8000bbe8:	30 08       	mov	r8,0
8000bbea:	14 9b       	mov	r11,r10
8000bbec:	e0 66 5b 68 	mov	r6,23400
8000bbf0:	12 9a       	mov	r10,r9
8000bbf2:	8d 08       	st.w	r6[0x0],r8
8000bbf4:	fe b0 df 36 	rcall	80007a60 <_lseek>
8000bbf8:	5b fc       	cp.w	r12,-1
8000bbfa:	c0 51       	brne	8000bc04 <_lseek_r+0x24>
8000bbfc:	6c 08       	ld.w	r8,r6[0x0]
8000bbfe:	58 08       	cp.w	r8,0
8000bc00:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc04:	d8 22       	popm	r4-r7,pc
8000bc06:	d7 03       	nop

8000bc08 <_read_r>:
8000bc08:	d4 21       	pushm	r4-r7,lr
8000bc0a:	16 98       	mov	r8,r11
8000bc0c:	18 97       	mov	r7,r12
8000bc0e:	10 9c       	mov	r12,r8
8000bc10:	30 08       	mov	r8,0
8000bc12:	14 9b       	mov	r11,r10
8000bc14:	e0 66 5b 68 	mov	r6,23400
8000bc18:	12 9a       	mov	r10,r9
8000bc1a:	8d 08       	st.w	r6[0x0],r8
8000bc1c:	fe b0 d0 a4 	rcall	80005d64 <_read>
8000bc20:	5b fc       	cp.w	r12,-1
8000bc22:	c0 51       	brne	8000bc2c <_read_r+0x24>
8000bc24:	6c 08       	ld.w	r8,r6[0x0]
8000bc26:	58 08       	cp.w	r8,0
8000bc28:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc2c:	d8 22       	popm	r4-r7,pc
8000bc2e:	d7 03       	nop

8000bc30 <__avr32_f64_mul>:
8000bc30:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bc34:	e0 80 00 dc 	breq	8000bdec <__avr32_f64_mul_op1_zero>
8000bc38:	d4 21       	pushm	r4-r7,lr
8000bc3a:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc3e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc42:	30 15       	mov	r5,1
8000bc44:	c4 30       	breq	8000bcca <__avr32_f64_mul_op1_subnormal>
8000bc46:	ab 6b       	lsl	r11,0xa
8000bc48:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bc4c:	ab 6a       	lsl	r10,0xa
8000bc4e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bc52:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc56:	c5 c0       	breq	8000bd0e <__avr32_f64_mul_op2_subnormal>
8000bc58:	a1 78       	lsl	r8,0x1
8000bc5a:	5c f9       	rol	r9
8000bc5c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bc60:	e0 47 07 ff 	cp.w	r7,2047
8000bc64:	c7 70       	breq	8000bd52 <__avr32_f64_mul_op_nan_or_inf>
8000bc66:	e0 46 07 ff 	cp.w	r6,2047
8000bc6a:	c7 40       	breq	8000bd52 <__avr32_f64_mul_op_nan_or_inf>
8000bc6c:	ee 06 00 0c 	add	r12,r7,r6
8000bc70:	e0 2c 03 fe 	sub	r12,1022
8000bc74:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bc78:	f4 09 07 44 	macu.d	r4,r10,r9
8000bc7c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bc80:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bc84:	08 07       	add	r7,r4
8000bc86:	f4 05 00 4a 	adc	r10,r10,r5
8000bc8a:	5c 0b       	acr	r11
8000bc8c:	ed bb 00 14 	bld	r11,0x14
8000bc90:	c0 50       	breq	8000bc9a <__avr32_f64_mul+0x6a>
8000bc92:	a1 77       	lsl	r7,0x1
8000bc94:	5c fa       	rol	r10
8000bc96:	5c fb       	rol	r11
8000bc98:	20 1c       	sub	r12,1
8000bc9a:	58 0c       	cp.w	r12,0
8000bc9c:	e0 8a 00 6f 	brle	8000bd7a <__avr32_f64_mul_res_subnormal>
8000bca0:	e0 4c 07 ff 	cp.w	r12,2047
8000bca4:	e0 84 00 9c 	brge	8000bddc <__avr32_f64_mul_res_inf>
8000bca8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bcac:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bcb0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bcb4:	ee 17 80 00 	eorh	r7,0x8000
8000bcb8:	f1 b7 04 20 	satu	r7,0x1
8000bcbc:	0e 0a       	add	r10,r7
8000bcbe:	5c 0b       	acr	r11
8000bcc0:	ed be 00 1f 	bld	lr,0x1f
8000bcc4:	ef bb 00 1f 	bst	r11,0x1f
8000bcc8:	d8 22       	popm	r4-r7,pc

8000bcca <__avr32_f64_mul_op1_subnormal>:
8000bcca:	e4 1b 00 0f 	andh	r11,0xf
8000bcce:	f4 0c 12 00 	clz	r12,r10
8000bcd2:	f6 06 12 00 	clz	r6,r11
8000bcd6:	f7 bc 03 e1 	sublo	r12,-31
8000bcda:	f8 06 17 30 	movlo	r6,r12
8000bcde:	f7 b6 02 01 	subhs	r6,1
8000bce2:	e0 46 00 20 	cp.w	r6,32
8000bce6:	c0 d4       	brge	8000bd00 <__avr32_f64_mul_op1_subnormal+0x36>
8000bce8:	ec 0c 11 20 	rsub	r12,r6,32
8000bcec:	f6 06 09 4b 	lsl	r11,r11,r6
8000bcf0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bcf4:	18 4b       	or	r11,r12
8000bcf6:	f4 06 09 4a 	lsl	r10,r10,r6
8000bcfa:	20 b6       	sub	r6,11
8000bcfc:	0c 17       	sub	r7,r6
8000bcfe:	ca ab       	rjmp	8000bc52 <__avr32_f64_mul+0x22>
8000bd00:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd04:	c6 40       	breq	8000bdcc <__avr32_f64_mul_res_zero>
8000bd06:	30 0a       	mov	r10,0
8000bd08:	20 b6       	sub	r6,11
8000bd0a:	0c 17       	sub	r7,r6
8000bd0c:	ca 3b       	rjmp	8000bc52 <__avr32_f64_mul+0x22>

8000bd0e <__avr32_f64_mul_op2_subnormal>:
8000bd0e:	e4 19 00 0f 	andh	r9,0xf
8000bd12:	f0 0c 12 00 	clz	r12,r8
8000bd16:	f2 05 12 00 	clz	r5,r9
8000bd1a:	f7 bc 03 ea 	sublo	r12,-22
8000bd1e:	f8 05 17 30 	movlo	r5,r12
8000bd22:	f7 b5 02 0a 	subhs	r5,10
8000bd26:	e0 45 00 20 	cp.w	r5,32
8000bd2a:	c0 d4       	brge	8000bd44 <__avr32_f64_mul_op2_subnormal+0x36>
8000bd2c:	ea 0c 11 20 	rsub	r12,r5,32
8000bd30:	f2 05 09 49 	lsl	r9,r9,r5
8000bd34:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bd38:	18 49       	or	r9,r12
8000bd3a:	f0 05 09 48 	lsl	r8,r8,r5
8000bd3e:	20 25       	sub	r5,2
8000bd40:	0a 16       	sub	r6,r5
8000bd42:	c8 fb       	rjmp	8000bc60 <__avr32_f64_mul+0x30>
8000bd44:	f0 05 09 49 	lsl	r9,r8,r5
8000bd48:	c4 20       	breq	8000bdcc <__avr32_f64_mul_res_zero>
8000bd4a:	30 08       	mov	r8,0
8000bd4c:	20 25       	sub	r5,2
8000bd4e:	0a 16       	sub	r6,r5
8000bd50:	c8 8b       	rjmp	8000bc60 <__avr32_f64_mul+0x30>

8000bd52 <__avr32_f64_mul_op_nan_or_inf>:
8000bd52:	e4 19 00 0f 	andh	r9,0xf
8000bd56:	e4 1b 00 0f 	andh	r11,0xf
8000bd5a:	14 4b       	or	r11,r10
8000bd5c:	10 49       	or	r9,r8
8000bd5e:	e0 47 07 ff 	cp.w	r7,2047
8000bd62:	c0 91       	brne	8000bd74 <__avr32_f64_mul_op1_not_naninf>
8000bd64:	58 0b       	cp.w	r11,0
8000bd66:	c3 81       	brne	8000bdd6 <__avr32_f64_mul_res_nan>
8000bd68:	e0 46 07 ff 	cp.w	r6,2047
8000bd6c:	c3 81       	brne	8000bddc <__avr32_f64_mul_res_inf>
8000bd6e:	58 09       	cp.w	r9,0
8000bd70:	c3 60       	breq	8000bddc <__avr32_f64_mul_res_inf>
8000bd72:	c3 28       	rjmp	8000bdd6 <__avr32_f64_mul_res_nan>

8000bd74 <__avr32_f64_mul_op1_not_naninf>:
8000bd74:	58 09       	cp.w	r9,0
8000bd76:	c3 30       	breq	8000bddc <__avr32_f64_mul_res_inf>
8000bd78:	c2 f8       	rjmp	8000bdd6 <__avr32_f64_mul_res_nan>

8000bd7a <__avr32_f64_mul_res_subnormal>:
8000bd7a:	5c 3c       	neg	r12
8000bd7c:	2f fc       	sub	r12,-1
8000bd7e:	f1 bc 04 c0 	satu	r12,0x6
8000bd82:	e0 4c 00 20 	cp.w	r12,32
8000bd86:	c1 14       	brge	8000bda8 <__avr32_f64_mul_res_subnormal+0x2e>
8000bd88:	f8 08 11 20 	rsub	r8,r12,32
8000bd8c:	0e 46       	or	r6,r7
8000bd8e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bd92:	f4 08 09 49 	lsl	r9,r10,r8
8000bd96:	12 47       	or	r7,r9
8000bd98:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bd9c:	f6 08 09 49 	lsl	r9,r11,r8
8000bda0:	12 4a       	or	r10,r9
8000bda2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bda6:	c8 3b       	rjmp	8000bcac <__avr32_f64_mul+0x7c>
8000bda8:	f8 08 11 20 	rsub	r8,r12,32
8000bdac:	f9 b9 00 00 	moveq	r9,0
8000bdb0:	c0 30       	breq	8000bdb6 <__avr32_f64_mul_res_subnormal+0x3c>
8000bdb2:	f6 08 09 49 	lsl	r9,r11,r8
8000bdb6:	0e 46       	or	r6,r7
8000bdb8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bdbc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bdc0:	f3 ea 10 07 	or	r7,r9,r10
8000bdc4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bdc8:	30 0b       	mov	r11,0
8000bdca:	c7 1b       	rjmp	8000bcac <__avr32_f64_mul+0x7c>

8000bdcc <__avr32_f64_mul_res_zero>:
8000bdcc:	1c 9b       	mov	r11,lr
8000bdce:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdd2:	30 0a       	mov	r10,0
8000bdd4:	d8 22       	popm	r4-r7,pc

8000bdd6 <__avr32_f64_mul_res_nan>:
8000bdd6:	3f fb       	mov	r11,-1
8000bdd8:	3f fa       	mov	r10,-1
8000bdda:	d8 22       	popm	r4-r7,pc

8000bddc <__avr32_f64_mul_res_inf>:
8000bddc:	f0 6b 00 00 	mov	r11,-1048576
8000bde0:	ed be 00 1f 	bld	lr,0x1f
8000bde4:	ef bb 00 1f 	bst	r11,0x1f
8000bde8:	30 0a       	mov	r10,0
8000bdea:	d8 22       	popm	r4-r7,pc

8000bdec <__avr32_f64_mul_op1_zero>:
8000bdec:	f7 e9 20 0b 	eor	r11,r11,r9
8000bdf0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdf4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bdf8:	e0 4c 07 ff 	cp.w	r12,2047
8000bdfc:	5e 1c       	retne	r12
8000bdfe:	3f fa       	mov	r10,-1
8000be00:	3f fb       	mov	r11,-1
8000be02:	5e fc       	retal	r12

8000be04 <__avr32_f64_sub_from_add>:
8000be04:	ee 19 80 00 	eorh	r9,0x8000

8000be08 <__avr32_f64_sub>:
8000be08:	f7 e9 20 0c 	eor	r12,r11,r9
8000be0c:	e0 86 00 ca 	brmi	8000bfa0 <__avr32_f64_add_from_sub>
8000be10:	eb cd 40 e0 	pushm	r5-r7,lr
8000be14:	16 9c       	mov	r12,r11
8000be16:	e6 1c 80 00 	andh	r12,0x8000,COH
8000be1a:	bf db       	cbr	r11,0x1f
8000be1c:	bf d9       	cbr	r9,0x1f
8000be1e:	10 3a       	cp.w	r10,r8
8000be20:	f2 0b 13 00 	cpc	r11,r9
8000be24:	c0 92       	brcc	8000be36 <__avr32_f64_sub+0x2e>
8000be26:	16 97       	mov	r7,r11
8000be28:	12 9b       	mov	r11,r9
8000be2a:	0e 99       	mov	r9,r7
8000be2c:	14 97       	mov	r7,r10
8000be2e:	10 9a       	mov	r10,r8
8000be30:	0e 98       	mov	r8,r7
8000be32:	ee 1c 80 00 	eorh	r12,0x8000
8000be36:	f6 07 16 14 	lsr	r7,r11,0x14
8000be3a:	ab 7b       	lsl	r11,0xb
8000be3c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be40:	ab 7a       	lsl	r10,0xb
8000be42:	bf bb       	sbr	r11,0x1f
8000be44:	f2 06 16 14 	lsr	r6,r9,0x14
8000be48:	c4 40       	breq	8000bed0 <__avr32_f64_sub_opL_subnormal>
8000be4a:	ab 79       	lsl	r9,0xb
8000be4c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000be50:	ab 78       	lsl	r8,0xb
8000be52:	bf b9       	sbr	r9,0x1f

8000be54 <__avr32_f64_sub_opL_subnormal_done>:
8000be54:	e0 47 07 ff 	cp.w	r7,2047
8000be58:	c4 f0       	breq	8000bef6 <__avr32_f64_sub_opH_nan_or_inf>
8000be5a:	0e 26       	rsub	r6,r7
8000be5c:	c1 20       	breq	8000be80 <__avr32_f64_sub_shift_done>
8000be5e:	ec 05 11 20 	rsub	r5,r6,32
8000be62:	e0 46 00 20 	cp.w	r6,32
8000be66:	c7 c2       	brcc	8000bf5e <__avr32_f64_sub_longshift>
8000be68:	f0 05 09 4e 	lsl	lr,r8,r5
8000be6c:	f2 05 09 45 	lsl	r5,r9,r5
8000be70:	f0 06 0a 48 	lsr	r8,r8,r6
8000be74:	f2 06 0a 49 	lsr	r9,r9,r6
8000be78:	0a 48       	or	r8,r5
8000be7a:	58 0e       	cp.w	lr,0
8000be7c:	5f 1e       	srne	lr
8000be7e:	1c 48       	or	r8,lr

8000be80 <__avr32_f64_sub_shift_done>:
8000be80:	10 1a       	sub	r10,r8
8000be82:	f6 09 01 4b 	sbc	r11,r11,r9
8000be86:	f6 06 12 00 	clz	r6,r11
8000be8a:	c0 e0       	breq	8000bea6 <__avr32_f64_sub_longnormalize_done>
8000be8c:	c7 83       	brcs	8000bf7c <__avr32_f64_sub_longnormalize>
8000be8e:	ec 0e 11 20 	rsub	lr,r6,32
8000be92:	f6 06 09 4b 	lsl	r11,r11,r6
8000be96:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be9a:	1c 4b       	or	r11,lr
8000be9c:	f4 06 09 4a 	lsl	r10,r10,r6
8000bea0:	0c 17       	sub	r7,r6
8000bea2:	e0 8a 00 39 	brle	8000bf14 <__avr32_f64_sub_subnormal_result>

8000bea6 <__avr32_f64_sub_longnormalize_done>:
8000bea6:	f4 09 15 15 	lsl	r9,r10,0x15
8000beaa:	ab 9a       	lsr	r10,0xb
8000beac:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000beb0:	ab 9b       	lsr	r11,0xb
8000beb2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000beb6:	18 4b       	or	r11,r12

8000beb8 <__avr32_f64_sub_round>:
8000beb8:	fc 17 80 00 	movh	r7,0x8000
8000bebc:	ed ba 00 00 	bld	r10,0x0
8000bec0:	f7 b7 01 ff 	subne	r7,-1
8000bec4:	0e 39       	cp.w	r9,r7
8000bec6:	5f 29       	srhs	r9
8000bec8:	12 0a       	add	r10,r9
8000beca:	5c 0b       	acr	r11
8000becc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bed0 <__avr32_f64_sub_opL_subnormal>:
8000bed0:	ab 79       	lsl	r9,0xb
8000bed2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bed6:	ab 78       	lsl	r8,0xb
8000bed8:	f3 e8 10 0e 	or	lr,r9,r8
8000bedc:	f9 b6 01 01 	movne	r6,1
8000bee0:	ee 0e 11 00 	rsub	lr,r7,0
8000bee4:	f9 b7 00 01 	moveq	r7,1
8000bee8:	ef bb 00 1f 	bst	r11,0x1f
8000beec:	f7 ea 10 0e 	or	lr,r11,r10
8000bef0:	f9 b7 00 00 	moveq	r7,0
8000bef4:	cb 0b       	rjmp	8000be54 <__avr32_f64_sub_opL_subnormal_done>

8000bef6 <__avr32_f64_sub_opH_nan_or_inf>:
8000bef6:	bf db       	cbr	r11,0x1f
8000bef8:	f7 ea 10 0e 	or	lr,r11,r10
8000befc:	c0 81       	brne	8000bf0c <__avr32_f64_sub_return_nan>
8000befe:	e0 46 07 ff 	cp.w	r6,2047
8000bf02:	c0 50       	breq	8000bf0c <__avr32_f64_sub_return_nan>
8000bf04:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bf08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf0c <__avr32_f64_sub_return_nan>:
8000bf0c:	3f fa       	mov	r10,-1
8000bf0e:	3f fb       	mov	r11,-1
8000bf10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf14 <__avr32_f64_sub_subnormal_result>:
8000bf14:	5c 37       	neg	r7
8000bf16:	2f f7       	sub	r7,-1
8000bf18:	f1 b7 04 c0 	satu	r7,0x6
8000bf1c:	e0 47 00 20 	cp.w	r7,32
8000bf20:	c1 14       	brge	8000bf42 <__avr32_f64_sub_subnormal_result+0x2e>
8000bf22:	ee 08 11 20 	rsub	r8,r7,32
8000bf26:	f4 08 09 49 	lsl	r9,r10,r8
8000bf2a:	5f 16       	srne	r6
8000bf2c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf30:	0c 4a       	or	r10,r6
8000bf32:	f6 08 09 49 	lsl	r9,r11,r8
8000bf36:	f5 e9 10 0a 	or	r10,r10,r9
8000bf3a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bf3e:	30 07       	mov	r7,0
8000bf40:	cb 3b       	rjmp	8000bea6 <__avr32_f64_sub_longnormalize_done>
8000bf42:	ee 08 11 40 	rsub	r8,r7,64
8000bf46:	f6 08 09 49 	lsl	r9,r11,r8
8000bf4a:	14 49       	or	r9,r10
8000bf4c:	5f 16       	srne	r6
8000bf4e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bf52:	0c 4a       	or	r10,r6
8000bf54:	30 0b       	mov	r11,0
8000bf56:	30 07       	mov	r7,0
8000bf58:	ca 7b       	rjmp	8000bea6 <__avr32_f64_sub_longnormalize_done>
8000bf5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf5e <__avr32_f64_sub_longshift>:
8000bf5e:	f1 b6 04 c0 	satu	r6,0x6
8000bf62:	f0 0e 17 00 	moveq	lr,r8
8000bf66:	c0 40       	breq	8000bf6e <__avr32_f64_sub_longshift+0x10>
8000bf68:	f2 05 09 4e 	lsl	lr,r9,r5
8000bf6c:	10 4e       	or	lr,r8
8000bf6e:	f2 06 0a 48 	lsr	r8,r9,r6
8000bf72:	30 09       	mov	r9,0
8000bf74:	58 0e       	cp.w	lr,0
8000bf76:	5f 1e       	srne	lr
8000bf78:	1c 48       	or	r8,lr
8000bf7a:	c8 3b       	rjmp	8000be80 <__avr32_f64_sub_shift_done>

8000bf7c <__avr32_f64_sub_longnormalize>:
8000bf7c:	f4 06 12 00 	clz	r6,r10
8000bf80:	f9 b7 03 00 	movlo	r7,0
8000bf84:	f9 b6 03 00 	movlo	r6,0
8000bf88:	f9 bc 03 00 	movlo	r12,0
8000bf8c:	f7 b6 02 e0 	subhs	r6,-32
8000bf90:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf94:	30 0a       	mov	r10,0
8000bf96:	0c 17       	sub	r7,r6
8000bf98:	fe 9a ff be 	brle	8000bf14 <__avr32_f64_sub_subnormal_result>
8000bf9c:	c8 5b       	rjmp	8000bea6 <__avr32_f64_sub_longnormalize_done>
8000bf9e:	d7 03       	nop

8000bfa0 <__avr32_f64_add_from_sub>:
8000bfa0:	ee 19 80 00 	eorh	r9,0x8000

8000bfa4 <__avr32_f64_add>:
8000bfa4:	f7 e9 20 0c 	eor	r12,r11,r9
8000bfa8:	fe 96 ff 2e 	brmi	8000be04 <__avr32_f64_sub_from_add>
8000bfac:	eb cd 40 e0 	pushm	r5-r7,lr
8000bfb0:	16 9c       	mov	r12,r11
8000bfb2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bfb6:	bf db       	cbr	r11,0x1f
8000bfb8:	bf d9       	cbr	r9,0x1f
8000bfba:	12 3b       	cp.w	r11,r9
8000bfbc:	c0 72       	brcc	8000bfca <__avr32_f64_add+0x26>
8000bfbe:	16 97       	mov	r7,r11
8000bfc0:	12 9b       	mov	r11,r9
8000bfc2:	0e 99       	mov	r9,r7
8000bfc4:	14 97       	mov	r7,r10
8000bfc6:	10 9a       	mov	r10,r8
8000bfc8:	0e 98       	mov	r8,r7
8000bfca:	30 0e       	mov	lr,0
8000bfcc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bfd0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bfd4:	b5 ab       	sbr	r11,0x14
8000bfd6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bfda:	c6 20       	breq	8000c09e <__avr32_f64_add_op2_subnormal>
8000bfdc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bfe0:	b5 a9       	sbr	r9,0x14
8000bfe2:	e0 47 07 ff 	cp.w	r7,2047
8000bfe6:	c2 80       	breq	8000c036 <__avr32_f64_add_opH_nan_or_inf>
8000bfe8:	0e 26       	rsub	r6,r7
8000bfea:	c1 20       	breq	8000c00e <__avr32_f64_add_shift_done>
8000bfec:	e0 46 00 36 	cp.w	r6,54
8000bff0:	c1 52       	brcc	8000c01a <__avr32_f64_add_res_of_done>
8000bff2:	ec 05 11 20 	rsub	r5,r6,32
8000bff6:	e0 46 00 20 	cp.w	r6,32
8000bffa:	c3 52       	brcc	8000c064 <__avr32_f64_add_longshift>
8000bffc:	f0 05 09 4e 	lsl	lr,r8,r5
8000c000:	f2 05 09 45 	lsl	r5,r9,r5
8000c004:	f0 06 0a 48 	lsr	r8,r8,r6
8000c008:	f2 06 0a 49 	lsr	r9,r9,r6
8000c00c:	0a 48       	or	r8,r5

8000c00e <__avr32_f64_add_shift_done>:
8000c00e:	10 0a       	add	r10,r8
8000c010:	f6 09 00 4b 	adc	r11,r11,r9
8000c014:	ed bb 00 15 	bld	r11,0x15
8000c018:	c3 40       	breq	8000c080 <__avr32_f64_add_res_of>

8000c01a <__avr32_f64_add_res_of_done>:
8000c01a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c01e:	18 4b       	or	r11,r12

8000c020 <__avr32_f64_add_round>:
8000c020:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c024:	18 4e       	or	lr,r12
8000c026:	ee 1e 80 00 	eorh	lr,0x8000
8000c02a:	f1 be 04 20 	satu	lr,0x1
8000c02e:	1c 0a       	add	r10,lr
8000c030:	5c 0b       	acr	r11
8000c032:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c036 <__avr32_f64_add_opH_nan_or_inf>:
8000c036:	b5 cb       	cbr	r11,0x14
8000c038:	f7 ea 10 0e 	or	lr,r11,r10
8000c03c:	c1 01       	brne	8000c05c <__avr32_f64_add_return_nan>
8000c03e:	e0 46 07 ff 	cp.w	r6,2047
8000c042:	c0 30       	breq	8000c048 <__avr32_f64_add_opL_nan_or_inf>
8000c044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c048 <__avr32_f64_add_opL_nan_or_inf>:
8000c048:	b5 c9       	cbr	r9,0x14
8000c04a:	f3 e8 10 0e 	or	lr,r9,r8
8000c04e:	c0 71       	brne	8000c05c <__avr32_f64_add_return_nan>
8000c050:	30 0a       	mov	r10,0
8000c052:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c056:	18 4b       	or	r11,r12
8000c058:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c05c <__avr32_f64_add_return_nan>:
8000c05c:	3f fa       	mov	r10,-1
8000c05e:	3f fb       	mov	r11,-1
8000c060:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c064 <__avr32_f64_add_longshift>:
8000c064:	f1 b6 04 c0 	satu	r6,0x6
8000c068:	f0 0e 17 00 	moveq	lr,r8
8000c06c:	c0 60       	breq	8000c078 <__avr32_f64_add_longshift+0x14>
8000c06e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c072:	58 08       	cp.w	r8,0
8000c074:	5f 18       	srne	r8
8000c076:	10 4e       	or	lr,r8
8000c078:	f2 06 0a 48 	lsr	r8,r9,r6
8000c07c:	30 09       	mov	r9,0
8000c07e:	cc 8b       	rjmp	8000c00e <__avr32_f64_add_shift_done>

8000c080 <__avr32_f64_add_res_of>:
8000c080:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c084:	a1 9b       	lsr	r11,0x1
8000c086:	5d 0a       	ror	r10
8000c088:	5d 0e       	ror	lr
8000c08a:	2f f7       	sub	r7,-1
8000c08c:	e0 47 07 ff 	cp.w	r7,2047
8000c090:	f9 ba 00 00 	moveq	r10,0
8000c094:	f9 bb 00 00 	moveq	r11,0
8000c098:	f9 be 00 00 	moveq	lr,0
8000c09c:	cb fb       	rjmp	8000c01a <__avr32_f64_add_res_of_done>

8000c09e <__avr32_f64_add_op2_subnormal>:
8000c09e:	30 16       	mov	r6,1
8000c0a0:	58 07       	cp.w	r7,0
8000c0a2:	ca 01       	brne	8000bfe2 <__avr32_f64_add+0x3e>
8000c0a4:	b5 cb       	cbr	r11,0x14
8000c0a6:	10 0a       	add	r10,r8
8000c0a8:	f6 09 00 4b 	adc	r11,r11,r9
8000c0ac:	18 4b       	or	r11,r12
8000c0ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c0b2:	d7 03       	nop

8000c0b4 <__avr32_f64_to_u32>:
8000c0b4:	58 0b       	cp.w	r11,0
8000c0b6:	5e 6d       	retmi	0

8000c0b8 <__avr32_f64_to_s32>:
8000c0b8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c0bc:	b5 9c       	lsr	r12,0x15
8000c0be:	e0 2c 03 ff 	sub	r12,1023
8000c0c2:	5e 3d       	retlo	0
8000c0c4:	f8 0c 11 1f 	rsub	r12,r12,31
8000c0c8:	16 99       	mov	r9,r11
8000c0ca:	ab 7b       	lsl	r11,0xb
8000c0cc:	bf bb       	sbr	r11,0x1f
8000c0ce:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0d2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0d6:	a1 79       	lsl	r9,0x1
8000c0d8:	5e 2b       	reths	r11
8000c0da:	5c 3b       	neg	r11
8000c0dc:	5e fb       	retal	r11

8000c0de <__avr32_u32_to_f64>:
8000c0de:	f8 cb 00 00 	sub	r11,r12,0
8000c0e2:	30 0c       	mov	r12,0
8000c0e4:	c0 38       	rjmp	8000c0ea <__avr32_s32_to_f64+0x4>

8000c0e6 <__avr32_s32_to_f64>:
8000c0e6:	18 9b       	mov	r11,r12
8000c0e8:	5c 4b       	abs	r11
8000c0ea:	30 0a       	mov	r10,0
8000c0ec:	5e 0b       	reteq	r11
8000c0ee:	d4 01       	pushm	lr
8000c0f0:	e0 69 04 1e 	mov	r9,1054
8000c0f4:	f6 08 12 00 	clz	r8,r11
8000c0f8:	c1 70       	breq	8000c126 <__avr32_s32_to_f64+0x40>
8000c0fa:	c0 c3       	brcs	8000c112 <__avr32_s32_to_f64+0x2c>
8000c0fc:	f0 0e 11 20 	rsub	lr,r8,32
8000c100:	f6 08 09 4b 	lsl	r11,r11,r8
8000c104:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c108:	1c 4b       	or	r11,lr
8000c10a:	f4 08 09 4a 	lsl	r10,r10,r8
8000c10e:	10 19       	sub	r9,r8
8000c110:	c0 b8       	rjmp	8000c126 <__avr32_s32_to_f64+0x40>
8000c112:	f4 08 12 00 	clz	r8,r10
8000c116:	f9 b8 03 00 	movlo	r8,0
8000c11a:	f7 b8 02 e0 	subhs	r8,-32
8000c11e:	f4 08 09 4b 	lsl	r11,r10,r8
8000c122:	30 0a       	mov	r10,0
8000c124:	10 19       	sub	r9,r8
8000c126:	58 09       	cp.w	r9,0
8000c128:	e0 89 00 30 	brgt	8000c188 <__avr32_s32_to_f64+0xa2>
8000c12c:	5c 39       	neg	r9
8000c12e:	2f f9       	sub	r9,-1
8000c130:	e0 49 00 36 	cp.w	r9,54
8000c134:	c0 43       	brcs	8000c13c <__avr32_s32_to_f64+0x56>
8000c136:	30 0b       	mov	r11,0
8000c138:	30 0a       	mov	r10,0
8000c13a:	c2 68       	rjmp	8000c186 <__avr32_s32_to_f64+0xa0>
8000c13c:	2f 69       	sub	r9,-10
8000c13e:	f2 08 11 20 	rsub	r8,r9,32
8000c142:	e0 49 00 20 	cp.w	r9,32
8000c146:	c0 b2       	brcc	8000c15c <__avr32_s32_to_f64+0x76>
8000c148:	f4 08 09 4e 	lsl	lr,r10,r8
8000c14c:	f6 08 09 48 	lsl	r8,r11,r8
8000c150:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c154:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c158:	10 4b       	or	r11,r8
8000c15a:	c0 88       	rjmp	8000c16a <__avr32_s32_to_f64+0x84>
8000c15c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c160:	14 4e       	or	lr,r10
8000c162:	16 9a       	mov	r10,r11
8000c164:	30 0b       	mov	r11,0
8000c166:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c16a:	ed ba 00 00 	bld	r10,0x0
8000c16e:	c0 92       	brcc	8000c180 <__avr32_s32_to_f64+0x9a>
8000c170:	1c 7e       	tst	lr,lr
8000c172:	c0 41       	brne	8000c17a <__avr32_s32_to_f64+0x94>
8000c174:	ed ba 00 01 	bld	r10,0x1
8000c178:	c0 42       	brcc	8000c180 <__avr32_s32_to_f64+0x9a>
8000c17a:	2f fa       	sub	r10,-1
8000c17c:	f7 bb 02 ff 	subhs	r11,-1
8000c180:	5c fc       	rol	r12
8000c182:	5d 0b       	ror	r11
8000c184:	5d 0a       	ror	r10
8000c186:	d8 02       	popm	pc
8000c188:	e0 68 03 ff 	mov	r8,1023
8000c18c:	ed ba 00 0b 	bld	r10,0xb
8000c190:	f7 b8 00 ff 	subeq	r8,-1
8000c194:	10 0a       	add	r10,r8
8000c196:	5c 0b       	acr	r11
8000c198:	f7 b9 03 fe 	sublo	r9,-2
8000c19c:	e0 49 07 ff 	cp.w	r9,2047
8000c1a0:	c0 55       	brlt	8000c1aa <__avr32_s32_to_f64+0xc4>
8000c1a2:	30 0a       	mov	r10,0
8000c1a4:	fc 1b ff e0 	movh	r11,0xffe0
8000c1a8:	c0 c8       	rjmp	8000c1c0 <__floatsidf_return_op1>
8000c1aa:	ed bb 00 1f 	bld	r11,0x1f
8000c1ae:	f7 b9 01 01 	subne	r9,1
8000c1b2:	ab 9a       	lsr	r10,0xb
8000c1b4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c1b8:	a1 7b       	lsl	r11,0x1
8000c1ba:	ab 9b       	lsr	r11,0xb
8000c1bc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c1c0 <__floatsidf_return_op1>:
8000c1c0:	a1 7c       	lsl	r12,0x1
8000c1c2:	5d 0b       	ror	r11
8000c1c4:	d8 02       	popm	pc

8000c1c6 <__avr32_f64_cmp_eq>:
8000c1c6:	10 3a       	cp.w	r10,r8
8000c1c8:	f2 0b 13 00 	cpc	r11,r9
8000c1cc:	c0 80       	breq	8000c1dc <__avr32_f64_cmp_eq+0x16>
8000c1ce:	a1 7b       	lsl	r11,0x1
8000c1d0:	a1 79       	lsl	r9,0x1
8000c1d2:	14 4b       	or	r11,r10
8000c1d4:	12 4b       	or	r11,r9
8000c1d6:	10 4b       	or	r11,r8
8000c1d8:	5e 0f       	reteq	1
8000c1da:	5e fd       	retal	0
8000c1dc:	a1 7b       	lsl	r11,0x1
8000c1de:	fc 1c ff e0 	movh	r12,0xffe0
8000c1e2:	58 0a       	cp.w	r10,0
8000c1e4:	f8 0b 13 00 	cpc	r11,r12
8000c1e8:	5e 8f       	retls	1
8000c1ea:	5e fd       	retal	0

8000c1ec <__avr32_f64_cmp_ge>:
8000c1ec:	1a de       	st.w	--sp,lr
8000c1ee:	1a d7       	st.w	--sp,r7
8000c1f0:	a1 7b       	lsl	r11,0x1
8000c1f2:	5f 3c       	srlo	r12
8000c1f4:	a1 79       	lsl	r9,0x1
8000c1f6:	5f 37       	srlo	r7
8000c1f8:	5c fc       	rol	r12
8000c1fa:	fc 1e ff e0 	movh	lr,0xffe0
8000c1fe:	58 0a       	cp.w	r10,0
8000c200:	fc 0b 13 00 	cpc	r11,lr
8000c204:	e0 8b 00 1d 	brhi	8000c23e <__avr32_f64_cmp_ge+0x52>
8000c208:	58 08       	cp.w	r8,0
8000c20a:	fc 09 13 00 	cpc	r9,lr
8000c20e:	e0 8b 00 18 	brhi	8000c23e <__avr32_f64_cmp_ge+0x52>
8000c212:	58 0b       	cp.w	r11,0
8000c214:	f5 ba 00 00 	subfeq	r10,0
8000c218:	c1 50       	breq	8000c242 <__avr32_f64_cmp_ge+0x56>
8000c21a:	1b 07       	ld.w	r7,sp++
8000c21c:	1b 0e       	ld.w	lr,sp++
8000c21e:	58 3c       	cp.w	r12,3
8000c220:	c0 a0       	breq	8000c234 <__avr32_f64_cmp_ge+0x48>
8000c222:	58 1c       	cp.w	r12,1
8000c224:	c0 33       	brcs	8000c22a <__avr32_f64_cmp_ge+0x3e>
8000c226:	5e 0f       	reteq	1
8000c228:	5e 1d       	retne	0
8000c22a:	10 3a       	cp.w	r10,r8
8000c22c:	f2 0b 13 00 	cpc	r11,r9
8000c230:	5e 2f       	reths	1
8000c232:	5e 3d       	retlo	0
8000c234:	14 38       	cp.w	r8,r10
8000c236:	f6 09 13 00 	cpc	r9,r11
8000c23a:	5e 2f       	reths	1
8000c23c:	5e 3d       	retlo	0
8000c23e:	1b 07       	ld.w	r7,sp++
8000c240:	d8 0a       	popm	pc,r12=0
8000c242:	58 17       	cp.w	r7,1
8000c244:	5f 0c       	sreq	r12
8000c246:	58 09       	cp.w	r9,0
8000c248:	f5 b8 00 00 	subfeq	r8,0
8000c24c:	1b 07       	ld.w	r7,sp++
8000c24e:	1b 0e       	ld.w	lr,sp++
8000c250:	5e 0f       	reteq	1
8000c252:	5e fc       	retal	r12

8000c254 <__avr32_f64_cmp_lt>:
8000c254:	1a de       	st.w	--sp,lr
8000c256:	1a d7       	st.w	--sp,r7
8000c258:	a1 7b       	lsl	r11,0x1
8000c25a:	5f 3c       	srlo	r12
8000c25c:	a1 79       	lsl	r9,0x1
8000c25e:	5f 37       	srlo	r7
8000c260:	5c fc       	rol	r12
8000c262:	fc 1e ff e0 	movh	lr,0xffe0
8000c266:	58 0a       	cp.w	r10,0
8000c268:	fc 0b 13 00 	cpc	r11,lr
8000c26c:	e0 8b 00 1d 	brhi	8000c2a6 <__avr32_f64_cmp_lt+0x52>
8000c270:	58 08       	cp.w	r8,0
8000c272:	fc 09 13 00 	cpc	r9,lr
8000c276:	e0 8b 00 18 	brhi	8000c2a6 <__avr32_f64_cmp_lt+0x52>
8000c27a:	58 0b       	cp.w	r11,0
8000c27c:	f5 ba 00 00 	subfeq	r10,0
8000c280:	c1 50       	breq	8000c2aa <__avr32_f64_cmp_lt+0x56>
8000c282:	1b 07       	ld.w	r7,sp++
8000c284:	1b 0e       	ld.w	lr,sp++
8000c286:	58 3c       	cp.w	r12,3
8000c288:	c0 a0       	breq	8000c29c <__avr32_f64_cmp_lt+0x48>
8000c28a:	58 1c       	cp.w	r12,1
8000c28c:	c0 33       	brcs	8000c292 <__avr32_f64_cmp_lt+0x3e>
8000c28e:	5e 0d       	reteq	0
8000c290:	5e 1f       	retne	1
8000c292:	10 3a       	cp.w	r10,r8
8000c294:	f2 0b 13 00 	cpc	r11,r9
8000c298:	5e 2d       	reths	0
8000c29a:	5e 3f       	retlo	1
8000c29c:	14 38       	cp.w	r8,r10
8000c29e:	f6 09 13 00 	cpc	r9,r11
8000c2a2:	5e 2d       	reths	0
8000c2a4:	5e 3f       	retlo	1
8000c2a6:	1b 07       	ld.w	r7,sp++
8000c2a8:	d8 0a       	popm	pc,r12=0
8000c2aa:	58 17       	cp.w	r7,1
8000c2ac:	5f 1c       	srne	r12
8000c2ae:	58 09       	cp.w	r9,0
8000c2b0:	f5 b8 00 00 	subfeq	r8,0
8000c2b4:	1b 07       	ld.w	r7,sp++
8000c2b6:	1b 0e       	ld.w	lr,sp++
8000c2b8:	5e 0d       	reteq	0
8000c2ba:	5e fc       	retal	r12

8000c2bc <__avr32_f64_div>:
8000c2bc:	eb cd 40 ff 	pushm	r0-r7,lr
8000c2c0:	f7 e9 20 0e 	eor	lr,r11,r9
8000c2c4:	f6 07 16 14 	lsr	r7,r11,0x14
8000c2c8:	a9 7b       	lsl	r11,0x9
8000c2ca:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c2ce:	a9 7a       	lsl	r10,0x9
8000c2d0:	bd bb       	sbr	r11,0x1d
8000c2d2:	e4 1b 3f ff 	andh	r11,0x3fff
8000c2d6:	ab d7       	cbr	r7,0xb
8000c2d8:	e0 80 00 cc 	breq	8000c470 <__avr32_f64_div_round_subnormal+0x54>
8000c2dc:	e0 47 07 ff 	cp.w	r7,2047
8000c2e0:	e0 84 00 b5 	brge	8000c44a <__avr32_f64_div_round_subnormal+0x2e>
8000c2e4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c2e8:	a9 79       	lsl	r9,0x9
8000c2ea:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c2ee:	a9 78       	lsl	r8,0x9
8000c2f0:	bd b9       	sbr	r9,0x1d
8000c2f2:	e4 19 3f ff 	andh	r9,0x3fff
8000c2f6:	ab d6       	cbr	r6,0xb
8000c2f8:	e0 80 00 e2 	breq	8000c4bc <__avr32_f64_div_round_subnormal+0xa0>
8000c2fc:	e0 46 07 ff 	cp.w	r6,2047
8000c300:	e0 84 00 b2 	brge	8000c464 <__avr32_f64_div_round_subnormal+0x48>
8000c304:	0c 17       	sub	r7,r6
8000c306:	fe 37 fc 01 	sub	r7,-1023
8000c30a:	fc 1c 80 00 	movh	r12,0x8000
8000c30e:	f8 03 16 01 	lsr	r3,r12,0x1
8000c312:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c316:	5c d4       	com	r4
8000c318:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c31c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c320:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c324:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c328:	ea 03 15 02 	lsl	r3,r5,0x2
8000c32c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c330:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c334:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c338:	ea 03 15 02 	lsl	r3,r5,0x2
8000c33c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c340:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c344:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c348:	ea 03 15 02 	lsl	r3,r5,0x2
8000c34c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c350:	e4 09 07 40 	macu.d	r0,r2,r9
8000c354:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c358:	02 04       	add	r4,r1
8000c35a:	5c 05       	acr	r5
8000c35c:	a3 65       	lsl	r5,0x2
8000c35e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c362:	a3 64       	lsl	r4,0x2
8000c364:	5c 34       	neg	r4
8000c366:	f8 05 01 45 	sbc	r5,r12,r5
8000c36a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c36e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c372:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c376:	02 04       	add	r4,r1
8000c378:	5c 05       	acr	r5
8000c37a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c37e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c382:	e8 02 15 02 	lsl	r2,r4,0x2
8000c386:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c38a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c38e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c392:	02 04       	add	r4,r1
8000c394:	5c 05       	acr	r5
8000c396:	a3 65       	lsl	r5,0x2
8000c398:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c39c:	a3 64       	lsl	r4,0x2
8000c39e:	5c 34       	neg	r4
8000c3a0:	f8 05 01 45 	sbc	r5,r12,r5
8000c3a4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c3a8:	e4 05 07 40 	macu.d	r0,r2,r5
8000c3ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3b0:	02 04       	add	r4,r1
8000c3b2:	5c 05       	acr	r5
8000c3b4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3b8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c3bc:	e8 02 15 02 	lsl	r2,r4,0x2
8000c3c0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c3c4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c3c8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c3cc:	02 02       	add	r2,r1
8000c3ce:	5c 03       	acr	r3
8000c3d0:	ed b3 00 1c 	bld	r3,0x1c
8000c3d4:	c0 90       	breq	8000c3e6 <__avr32_f64_div+0x12a>
8000c3d6:	a1 72       	lsl	r2,0x1
8000c3d8:	5c f3       	rol	r3
8000c3da:	20 17       	sub	r7,1
8000c3dc:	a3 9a       	lsr	r10,0x3
8000c3de:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c3e2:	a3 9b       	lsr	r11,0x3
8000c3e4:	c0 58       	rjmp	8000c3ee <__avr32_f64_div+0x132>
8000c3e6:	a5 8a       	lsr	r10,0x4
8000c3e8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c3ec:	a5 8b       	lsr	r11,0x4
8000c3ee:	58 07       	cp.w	r7,0
8000c3f0:	e0 8a 00 8b 	brle	8000c506 <__avr32_f64_div_res_subnormal>
8000c3f4:	e0 12 ff 00 	andl	r2,0xff00
8000c3f8:	e8 12 00 80 	orl	r2,0x80
8000c3fc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c400:	e4 09 07 40 	macu.d	r0,r2,r9
8000c404:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c408:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c40c:	00 05       	add	r5,r0
8000c40e:	f0 01 00 48 	adc	r8,r8,r1
8000c412:	5c 09       	acr	r9
8000c414:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c418:	58 04       	cp.w	r4,0
8000c41a:	5c 25       	cpc	r5

8000c41c <__avr32_f64_div_round_subnormal>:
8000c41c:	f4 08 13 00 	cpc	r8,r10
8000c420:	f6 09 13 00 	cpc	r9,r11
8000c424:	5f 36       	srlo	r6
8000c426:	f8 06 17 00 	moveq	r6,r12
8000c42a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c42e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c432:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c436:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c43a:	ed be 00 1f 	bld	lr,0x1f
8000c43e:	ef bb 00 1f 	bst	r11,0x1f
8000c442:	0c 0a       	add	r10,r6
8000c444:	5c 0b       	acr	r11
8000c446:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c44a:	e4 1b 00 0f 	andh	r11,0xf
8000c44e:	14 4b       	or	r11,r10
8000c450:	e0 81 00 a7 	brne	8000c59e <__avr32_f64_div_res_subnormal+0x98>
8000c454:	f2 06 16 14 	lsr	r6,r9,0x14
8000c458:	ab d6       	cbr	r6,0xb
8000c45a:	e0 46 07 ff 	cp.w	r6,2047
8000c45e:	e0 81 00 a4 	brne	8000c5a6 <__avr32_f64_div_res_subnormal+0xa0>
8000c462:	c9 e8       	rjmp	8000c59e <__avr32_f64_div_res_subnormal+0x98>
8000c464:	e4 19 00 0f 	andh	r9,0xf
8000c468:	10 49       	or	r9,r8
8000c46a:	e0 81 00 9a 	brne	8000c59e <__avr32_f64_div_res_subnormal+0x98>
8000c46e:	c9 28       	rjmp	8000c592 <__avr32_f64_div_res_subnormal+0x8c>
8000c470:	a3 7b       	lsl	r11,0x3
8000c472:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c476:	a3 7a       	lsl	r10,0x3
8000c478:	f5 eb 10 04 	or	r4,r10,r11
8000c47c:	e0 80 00 a0 	breq	8000c5bc <__avr32_f64_div_op1_zero>
8000c480:	f6 04 12 00 	clz	r4,r11
8000c484:	c1 70       	breq	8000c4b2 <__avr32_f64_div_round_subnormal+0x96>
8000c486:	c0 c3       	brcs	8000c49e <__avr32_f64_div_round_subnormal+0x82>
8000c488:	e8 05 11 20 	rsub	r5,r4,32
8000c48c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c490:	f4 05 0a 45 	lsr	r5,r10,r5
8000c494:	0a 4b       	or	r11,r5
8000c496:	f4 04 09 4a 	lsl	r10,r10,r4
8000c49a:	08 17       	sub	r7,r4
8000c49c:	c0 b8       	rjmp	8000c4b2 <__avr32_f64_div_round_subnormal+0x96>
8000c49e:	f4 04 12 00 	clz	r4,r10
8000c4a2:	f9 b4 03 00 	movlo	r4,0
8000c4a6:	f7 b4 02 e0 	subhs	r4,-32
8000c4aa:	f4 04 09 4b 	lsl	r11,r10,r4
8000c4ae:	30 0a       	mov	r10,0
8000c4b0:	08 17       	sub	r7,r4
8000c4b2:	a3 8a       	lsr	r10,0x2
8000c4b4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c4b8:	a3 8b       	lsr	r11,0x2
8000c4ba:	c1 1b       	rjmp	8000c2dc <__avr32_f64_div+0x20>
8000c4bc:	a3 79       	lsl	r9,0x3
8000c4be:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c4c2:	a3 78       	lsl	r8,0x3
8000c4c4:	f3 e8 10 04 	or	r4,r9,r8
8000c4c8:	c6 f0       	breq	8000c5a6 <__avr32_f64_div_res_subnormal+0xa0>
8000c4ca:	f2 04 12 00 	clz	r4,r9
8000c4ce:	c1 70       	breq	8000c4fc <__avr32_f64_div_round_subnormal+0xe0>
8000c4d0:	c0 c3       	brcs	8000c4e8 <__avr32_f64_div_round_subnormal+0xcc>
8000c4d2:	e8 05 11 20 	rsub	r5,r4,32
8000c4d6:	f2 04 09 49 	lsl	r9,r9,r4
8000c4da:	f0 05 0a 45 	lsr	r5,r8,r5
8000c4de:	0a 49       	or	r9,r5
8000c4e0:	f0 04 09 48 	lsl	r8,r8,r4
8000c4e4:	08 16       	sub	r6,r4
8000c4e6:	c0 b8       	rjmp	8000c4fc <__avr32_f64_div_round_subnormal+0xe0>
8000c4e8:	f0 04 12 00 	clz	r4,r8
8000c4ec:	f9 b4 03 00 	movlo	r4,0
8000c4f0:	f7 b4 02 e0 	subhs	r4,-32
8000c4f4:	f0 04 09 49 	lsl	r9,r8,r4
8000c4f8:	30 08       	mov	r8,0
8000c4fa:	08 16       	sub	r6,r4
8000c4fc:	a3 88       	lsr	r8,0x2
8000c4fe:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c502:	a3 89       	lsr	r9,0x2
8000c504:	cf ca       	rjmp	8000c2fc <__avr32_f64_div+0x40>

8000c506 <__avr32_f64_div_res_subnormal>:
8000c506:	5c 37       	neg	r7
8000c508:	2f f7       	sub	r7,-1
8000c50a:	f1 b7 04 c0 	satu	r7,0x6
8000c50e:	e0 47 00 20 	cp.w	r7,32
8000c512:	c1 54       	brge	8000c53c <__avr32_f64_div_res_subnormal+0x36>
8000c514:	ee 06 11 20 	rsub	r6,r7,32
8000c518:	e4 07 0a 42 	lsr	r2,r2,r7
8000c51c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c520:	18 42       	or	r2,r12
8000c522:	e6 07 0a 43 	lsr	r3,r3,r7
8000c526:	f4 06 09 41 	lsl	r1,r10,r6
8000c52a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c52e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c532:	18 4a       	or	r10,r12
8000c534:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c538:	30 00       	mov	r0,0
8000c53a:	c1 58       	rjmp	8000c564 <__avr32_f64_div_res_subnormal+0x5e>
8000c53c:	ee 06 11 20 	rsub	r6,r7,32
8000c540:	f9 b0 00 00 	moveq	r0,0
8000c544:	f9 bc 00 00 	moveq	r12,0
8000c548:	c0 50       	breq	8000c552 <__avr32_f64_div_res_subnormal+0x4c>
8000c54a:	f4 06 09 40 	lsl	r0,r10,r6
8000c54e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c552:	e6 07 0a 42 	lsr	r2,r3,r7
8000c556:	30 03       	mov	r3,0
8000c558:	f4 07 0a 41 	lsr	r1,r10,r7
8000c55c:	18 41       	or	r1,r12
8000c55e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c562:	30 0b       	mov	r11,0
8000c564:	e0 12 ff 00 	andl	r2,0xff00
8000c568:	e8 12 00 80 	orl	r2,0x80
8000c56c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c570:	e4 09 07 46 	macu.d	r6,r2,r9
8000c574:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c578:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c57c:	0c 05       	add	r5,r6
8000c57e:	f0 07 00 48 	adc	r8,r8,r7
8000c582:	5c 09       	acr	r9
8000c584:	30 07       	mov	r7,0
8000c586:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c58a:	00 34       	cp.w	r4,r0
8000c58c:	e2 05 13 00 	cpc	r5,r1
8000c590:	c4 6b       	rjmp	8000c41c <__avr32_f64_div_round_subnormal>
8000c592:	1c 9b       	mov	r11,lr
8000c594:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c598:	30 0a       	mov	r10,0
8000c59a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c59e:	3f fb       	mov	r11,-1
8000c5a0:	30 0a       	mov	r10,0
8000c5a2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c5a6:	f5 eb 10 04 	or	r4,r10,r11
8000c5aa:	c0 90       	breq	8000c5bc <__avr32_f64_div_op1_zero>
8000c5ac:	1c 9b       	mov	r11,lr
8000c5ae:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c5b2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c5b6:	30 0a       	mov	r10,0
8000c5b8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c5bc <__avr32_f64_div_op1_zero>:
8000c5bc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c5c0:	ce f0       	breq	8000c59e <__avr32_f64_div_res_subnormal+0x98>
8000c5c2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c5c6:	e0 44 07 ff 	cp.w	r4,2047
8000c5ca:	ce 41       	brne	8000c592 <__avr32_f64_div_res_subnormal+0x8c>
8000c5cc:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c5d0:	ce 10       	breq	8000c592 <__avr32_f64_div_res_subnormal+0x8c>
8000c5d2:	ce 6b       	rjmp	8000c59e <__avr32_f64_div_res_subnormal+0x98>

8000c5d4 <__avr32_udiv64>:
8000c5d4:	d4 31       	pushm	r0-r7,lr
8000c5d6:	1a 97       	mov	r7,sp
8000c5d8:	20 3d       	sub	sp,12
8000c5da:	10 9c       	mov	r12,r8
8000c5dc:	12 9e       	mov	lr,r9
8000c5de:	14 93       	mov	r3,r10
8000c5e0:	58 09       	cp.w	r9,0
8000c5e2:	e0 81 00 bd 	brne	8000c75c <__avr32_udiv64+0x188>
8000c5e6:	16 38       	cp.w	r8,r11
8000c5e8:	e0 88 00 40 	brls	8000c668 <__avr32_udiv64+0x94>
8000c5ec:	f0 08 12 00 	clz	r8,r8
8000c5f0:	c0 d0       	breq	8000c60a <__avr32_udiv64+0x36>
8000c5f2:	f6 08 09 4b 	lsl	r11,r11,r8
8000c5f6:	f0 09 11 20 	rsub	r9,r8,32
8000c5fa:	f8 08 09 4c 	lsl	r12,r12,r8
8000c5fe:	f4 09 0a 49 	lsr	r9,r10,r9
8000c602:	f4 08 09 43 	lsl	r3,r10,r8
8000c606:	f3 eb 10 0b 	or	r11,r9,r11
8000c60a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c60e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c612:	f6 0e 0d 00 	divu	r0,r11,lr
8000c616:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c61a:	00 99       	mov	r9,r0
8000c61c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c620:	e0 0a 02 48 	mul	r8,r0,r10
8000c624:	10 3b       	cp.w	r11,r8
8000c626:	c0 a2       	brcc	8000c63a <__avr32_udiv64+0x66>
8000c628:	20 19       	sub	r9,1
8000c62a:	18 0b       	add	r11,r12
8000c62c:	18 3b       	cp.w	r11,r12
8000c62e:	c0 63       	brcs	8000c63a <__avr32_udiv64+0x66>
8000c630:	10 3b       	cp.w	r11,r8
8000c632:	f7 b9 03 01 	sublo	r9,1
8000c636:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c63a:	f6 08 01 01 	sub	r1,r11,r8
8000c63e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c642:	e2 0e 0d 00 	divu	r0,r1,lr
8000c646:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c64a:	00 98       	mov	r8,r0
8000c64c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c650:	14 33       	cp.w	r3,r10
8000c652:	c0 82       	brcc	8000c662 <__avr32_udiv64+0x8e>
8000c654:	20 18       	sub	r8,1
8000c656:	18 03       	add	r3,r12
8000c658:	18 33       	cp.w	r3,r12
8000c65a:	c0 43       	brcs	8000c662 <__avr32_udiv64+0x8e>
8000c65c:	14 33       	cp.w	r3,r10
8000c65e:	f7 b8 03 01 	sublo	r8,1
8000c662:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c666:	cd f8       	rjmp	8000c824 <__avr32_udiv64+0x250>
8000c668:	58 08       	cp.w	r8,0
8000c66a:	c0 51       	brne	8000c674 <__avr32_udiv64+0xa0>
8000c66c:	30 19       	mov	r9,1
8000c66e:	f2 08 0d 08 	divu	r8,r9,r8
8000c672:	10 9c       	mov	r12,r8
8000c674:	f8 06 12 00 	clz	r6,r12
8000c678:	c0 41       	brne	8000c680 <__avr32_udiv64+0xac>
8000c67a:	18 1b       	sub	r11,r12
8000c67c:	30 19       	mov	r9,1
8000c67e:	c4 08       	rjmp	8000c6fe <__avr32_udiv64+0x12a>
8000c680:	ec 01 11 20 	rsub	r1,r6,32
8000c684:	f4 01 0a 49 	lsr	r9,r10,r1
8000c688:	f8 06 09 4c 	lsl	r12,r12,r6
8000c68c:	f6 06 09 48 	lsl	r8,r11,r6
8000c690:	f6 01 0a 41 	lsr	r1,r11,r1
8000c694:	f3 e8 10 08 	or	r8,r9,r8
8000c698:	f8 03 16 10 	lsr	r3,r12,0x10
8000c69c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c6a0:	e2 03 0d 00 	divu	r0,r1,r3
8000c6a4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c6a8:	00 9e       	mov	lr,r0
8000c6aa:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6ae:	e0 05 02 49 	mul	r9,r0,r5
8000c6b2:	12 3b       	cp.w	r11,r9
8000c6b4:	c0 a2       	brcc	8000c6c8 <__avr32_udiv64+0xf4>
8000c6b6:	20 1e       	sub	lr,1
8000c6b8:	18 0b       	add	r11,r12
8000c6ba:	18 3b       	cp.w	r11,r12
8000c6bc:	c0 63       	brcs	8000c6c8 <__avr32_udiv64+0xf4>
8000c6be:	12 3b       	cp.w	r11,r9
8000c6c0:	f7 be 03 01 	sublo	lr,1
8000c6c4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6c8:	12 1b       	sub	r11,r9
8000c6ca:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c6ce:	f6 03 0d 02 	divu	r2,r11,r3
8000c6d2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c6d6:	04 99       	mov	r9,r2
8000c6d8:	e4 05 02 4b 	mul	r11,r2,r5
8000c6dc:	16 38       	cp.w	r8,r11
8000c6de:	c0 a2       	brcc	8000c6f2 <__avr32_udiv64+0x11e>
8000c6e0:	20 19       	sub	r9,1
8000c6e2:	18 08       	add	r8,r12
8000c6e4:	18 38       	cp.w	r8,r12
8000c6e6:	c0 63       	brcs	8000c6f2 <__avr32_udiv64+0x11e>
8000c6e8:	16 38       	cp.w	r8,r11
8000c6ea:	f7 b9 03 01 	sublo	r9,1
8000c6ee:	f1 dc e3 08 	addcs	r8,r8,r12
8000c6f2:	f4 06 09 43 	lsl	r3,r10,r6
8000c6f6:	f0 0b 01 0b 	sub	r11,r8,r11
8000c6fa:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c6fe:	f8 06 16 10 	lsr	r6,r12,0x10
8000c702:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c706:	f6 06 0d 00 	divu	r0,r11,r6
8000c70a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c70e:	00 9a       	mov	r10,r0
8000c710:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c714:	e0 0e 02 48 	mul	r8,r0,lr
8000c718:	10 3b       	cp.w	r11,r8
8000c71a:	c0 a2       	brcc	8000c72e <__avr32_udiv64+0x15a>
8000c71c:	20 1a       	sub	r10,1
8000c71e:	18 0b       	add	r11,r12
8000c720:	18 3b       	cp.w	r11,r12
8000c722:	c0 63       	brcs	8000c72e <__avr32_udiv64+0x15a>
8000c724:	10 3b       	cp.w	r11,r8
8000c726:	f7 ba 03 01 	sublo	r10,1
8000c72a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c72e:	f6 08 01 01 	sub	r1,r11,r8
8000c732:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c736:	e2 06 0d 00 	divu	r0,r1,r6
8000c73a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c73e:	00 98       	mov	r8,r0
8000c740:	e0 0e 02 4b 	mul	r11,r0,lr
8000c744:	16 33       	cp.w	r3,r11
8000c746:	c0 82       	brcc	8000c756 <__avr32_udiv64+0x182>
8000c748:	20 18       	sub	r8,1
8000c74a:	18 03       	add	r3,r12
8000c74c:	18 33       	cp.w	r3,r12
8000c74e:	c0 43       	brcs	8000c756 <__avr32_udiv64+0x182>
8000c750:	16 33       	cp.w	r3,r11
8000c752:	f7 b8 03 01 	sublo	r8,1
8000c756:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c75a:	c6 98       	rjmp	8000c82c <__avr32_udiv64+0x258>
8000c75c:	16 39       	cp.w	r9,r11
8000c75e:	e0 8b 00 65 	brhi	8000c828 <__avr32_udiv64+0x254>
8000c762:	f2 09 12 00 	clz	r9,r9
8000c766:	c0 b1       	brne	8000c77c <__avr32_udiv64+0x1a8>
8000c768:	10 3a       	cp.w	r10,r8
8000c76a:	5f 2a       	srhs	r10
8000c76c:	1c 3b       	cp.w	r11,lr
8000c76e:	5f b8       	srhi	r8
8000c770:	10 4a       	or	r10,r8
8000c772:	f2 0a 18 00 	cp.b	r10,r9
8000c776:	c5 90       	breq	8000c828 <__avr32_udiv64+0x254>
8000c778:	30 18       	mov	r8,1
8000c77a:	c5 98       	rjmp	8000c82c <__avr32_udiv64+0x258>
8000c77c:	f0 09 09 46 	lsl	r6,r8,r9
8000c780:	f2 03 11 20 	rsub	r3,r9,32
8000c784:	fc 09 09 4e 	lsl	lr,lr,r9
8000c788:	f0 03 0a 48 	lsr	r8,r8,r3
8000c78c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c790:	f4 03 0a 42 	lsr	r2,r10,r3
8000c794:	ef 46 ff f4 	st.w	r7[-12],r6
8000c798:	f6 03 0a 43 	lsr	r3,r11,r3
8000c79c:	18 42       	or	r2,r12
8000c79e:	f1 ee 10 0c 	or	r12,r8,lr
8000c7a2:	f8 01 16 10 	lsr	r1,r12,0x10
8000c7a6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c7aa:	e6 01 0d 04 	divu	r4,r3,r1
8000c7ae:	e4 03 16 10 	lsr	r3,r2,0x10
8000c7b2:	08 9e       	mov	lr,r4
8000c7b4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c7b8:	e8 06 02 48 	mul	r8,r4,r6
8000c7bc:	10 33       	cp.w	r3,r8
8000c7be:	c0 a2       	brcc	8000c7d2 <__avr32_udiv64+0x1fe>
8000c7c0:	20 1e       	sub	lr,1
8000c7c2:	18 03       	add	r3,r12
8000c7c4:	18 33       	cp.w	r3,r12
8000c7c6:	c0 63       	brcs	8000c7d2 <__avr32_udiv64+0x1fe>
8000c7c8:	10 33       	cp.w	r3,r8
8000c7ca:	f7 be 03 01 	sublo	lr,1
8000c7ce:	e7 dc e3 03 	addcs	r3,r3,r12
8000c7d2:	10 13       	sub	r3,r8
8000c7d4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c7d8:	e6 01 0d 00 	divu	r0,r3,r1
8000c7dc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7e0:	00 98       	mov	r8,r0
8000c7e2:	e0 06 02 46 	mul	r6,r0,r6
8000c7e6:	0c 3b       	cp.w	r11,r6
8000c7e8:	c0 a2       	brcc	8000c7fc <__avr32_udiv64+0x228>
8000c7ea:	20 18       	sub	r8,1
8000c7ec:	18 0b       	add	r11,r12
8000c7ee:	18 3b       	cp.w	r11,r12
8000c7f0:	c0 63       	brcs	8000c7fc <__avr32_udiv64+0x228>
8000c7f2:	0c 3b       	cp.w	r11,r6
8000c7f4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7f8:	f7 b8 03 01 	sublo	r8,1
8000c7fc:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c800:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c804:	0c 1b       	sub	r11,r6
8000c806:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c80a:	06 95       	mov	r5,r3
8000c80c:	16 35       	cp.w	r5,r11
8000c80e:	e0 8b 00 0a 	brhi	8000c822 <__avr32_udiv64+0x24e>
8000c812:	5f 0b       	sreq	r11
8000c814:	f4 09 09 49 	lsl	r9,r10,r9
8000c818:	12 32       	cp.w	r2,r9
8000c81a:	5f b9       	srhi	r9
8000c81c:	f7 e9 00 09 	and	r9,r11,r9
8000c820:	c0 60       	breq	8000c82c <__avr32_udiv64+0x258>
8000c822:	20 18       	sub	r8,1
8000c824:	30 09       	mov	r9,0
8000c826:	c0 38       	rjmp	8000c82c <__avr32_udiv64+0x258>
8000c828:	30 09       	mov	r9,0
8000c82a:	12 98       	mov	r8,r9
8000c82c:	10 9a       	mov	r10,r8
8000c82e:	12 93       	mov	r3,r9
8000c830:	10 92       	mov	r2,r8
8000c832:	12 9b       	mov	r11,r9
8000c834:	2f dd       	sub	sp,-12
8000c836:	d8 32       	popm	r0-r7,pc

8000c838 <__avr32_umod64>:
8000c838:	d4 31       	pushm	r0-r7,lr
8000c83a:	1a 97       	mov	r7,sp
8000c83c:	20 3d       	sub	sp,12
8000c83e:	10 9c       	mov	r12,r8
8000c840:	12 95       	mov	r5,r9
8000c842:	14 9e       	mov	lr,r10
8000c844:	16 91       	mov	r1,r11
8000c846:	16 96       	mov	r6,r11
8000c848:	58 09       	cp.w	r9,0
8000c84a:	e0 81 00 81 	brne	8000c94c <__avr32_umod64+0x114>
8000c84e:	16 38       	cp.w	r8,r11
8000c850:	e0 88 00 12 	brls	8000c874 <__avr32_umod64+0x3c>
8000c854:	f0 08 12 00 	clz	r8,r8
8000c858:	c4 e0       	breq	8000c8f4 <__avr32_umod64+0xbc>
8000c85a:	f6 08 09 46 	lsl	r6,r11,r8
8000c85e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c862:	f0 0b 11 20 	rsub	r11,r8,32
8000c866:	f4 08 09 4e 	lsl	lr,r10,r8
8000c86a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c86e:	f7 e6 10 06 	or	r6,r11,r6
8000c872:	c4 18       	rjmp	8000c8f4 <__avr32_umod64+0xbc>
8000c874:	58 08       	cp.w	r8,0
8000c876:	c0 51       	brne	8000c880 <__avr32_umod64+0x48>
8000c878:	30 19       	mov	r9,1
8000c87a:	f2 08 0d 08 	divu	r8,r9,r8
8000c87e:	10 9c       	mov	r12,r8
8000c880:	f8 08 12 00 	clz	r8,r12
8000c884:	c0 31       	brne	8000c88a <__avr32_umod64+0x52>
8000c886:	18 16       	sub	r6,r12
8000c888:	c3 68       	rjmp	8000c8f4 <__avr32_umod64+0xbc>
8000c88a:	f0 03 11 20 	rsub	r3,r8,32
8000c88e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c892:	f8 08 09 4c 	lsl	r12,r12,r8
8000c896:	ec 08 09 49 	lsl	r9,r6,r8
8000c89a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c89e:	f7 e9 10 09 	or	r9,r11,r9
8000c8a2:	f8 05 16 10 	lsr	r5,r12,0x10
8000c8a6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c8aa:	e6 05 0d 02 	divu	r2,r3,r5
8000c8ae:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c8b2:	ec 02 02 4b 	mul	r11,r6,r2
8000c8b6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c8ba:	16 3e       	cp.w	lr,r11
8000c8bc:	c0 72       	brcc	8000c8ca <__avr32_umod64+0x92>
8000c8be:	18 0e       	add	lr,r12
8000c8c0:	18 3e       	cp.w	lr,r12
8000c8c2:	c0 43       	brcs	8000c8ca <__avr32_umod64+0x92>
8000c8c4:	16 3e       	cp.w	lr,r11
8000c8c6:	fd dc e3 0e 	addcs	lr,lr,r12
8000c8ca:	fc 0b 01 03 	sub	r3,lr,r11
8000c8ce:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c8d2:	e6 05 0d 02 	divu	r2,r3,r5
8000c8d6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c8da:	a5 36       	mul	r6,r2
8000c8dc:	0c 39       	cp.w	r9,r6
8000c8de:	c0 72       	brcc	8000c8ec <__avr32_umod64+0xb4>
8000c8e0:	18 09       	add	r9,r12
8000c8e2:	18 39       	cp.w	r9,r12
8000c8e4:	c0 43       	brcs	8000c8ec <__avr32_umod64+0xb4>
8000c8e6:	0c 39       	cp.w	r9,r6
8000c8e8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c8ec:	f2 06 01 06 	sub	r6,r9,r6
8000c8f0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c8f4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c8f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c8fc:	ec 0a 0d 02 	divu	r2,r6,r10
8000c900:	fc 09 16 10 	lsr	r9,lr,0x10
8000c904:	ea 02 02 4b 	mul	r11,r5,r2
8000c908:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c90c:	16 39       	cp.w	r9,r11
8000c90e:	c0 72       	brcc	8000c91c <__avr32_umod64+0xe4>
8000c910:	18 09       	add	r9,r12
8000c912:	18 39       	cp.w	r9,r12
8000c914:	c0 43       	brcs	8000c91c <__avr32_umod64+0xe4>
8000c916:	16 39       	cp.w	r9,r11
8000c918:	f3 dc e3 09 	addcs	r9,r9,r12
8000c91c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c920:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c924:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c928:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c92c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c930:	14 3e       	cp.w	lr,r10
8000c932:	c0 72       	brcc	8000c940 <__avr32_umod64+0x108>
8000c934:	18 0e       	add	lr,r12
8000c936:	18 3e       	cp.w	lr,r12
8000c938:	c0 43       	brcs	8000c940 <__avr32_umod64+0x108>
8000c93a:	14 3e       	cp.w	lr,r10
8000c93c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c940:	fc 0a 01 0a 	sub	r10,lr,r10
8000c944:	30 0b       	mov	r11,0
8000c946:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c94a:	c7 b8       	rjmp	8000ca40 <__avr32_umod64+0x208>
8000c94c:	16 39       	cp.w	r9,r11
8000c94e:	e0 8b 00 79 	brhi	8000ca40 <__avr32_umod64+0x208>
8000c952:	f2 09 12 00 	clz	r9,r9
8000c956:	c1 21       	brne	8000c97a <__avr32_umod64+0x142>
8000c958:	10 3a       	cp.w	r10,r8
8000c95a:	5f 2b       	srhs	r11
8000c95c:	0a 31       	cp.w	r1,r5
8000c95e:	5f ba       	srhi	r10
8000c960:	f7 ea 10 0a 	or	r10,r11,r10
8000c964:	f2 0a 18 00 	cp.b	r10,r9
8000c968:	c0 60       	breq	8000c974 <__avr32_umod64+0x13c>
8000c96a:	fc 08 01 0c 	sub	r12,lr,r8
8000c96e:	e2 05 01 46 	sbc	r6,r1,r5
8000c972:	18 9e       	mov	lr,r12
8000c974:	0c 9b       	mov	r11,r6
8000c976:	1c 9a       	mov	r10,lr
8000c978:	c6 48       	rjmp	8000ca40 <__avr32_umod64+0x208>
8000c97a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c97e:	f2 06 11 20 	rsub	r6,r9,32
8000c982:	f6 09 09 4b 	lsl	r11,r11,r9
8000c986:	f0 09 09 42 	lsl	r2,r8,r9
8000c98a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c98e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c992:	18 48       	or	r8,r12
8000c994:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c998:	f4 09 09 43 	lsl	r3,r10,r9
8000c99c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c9a0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c9a4:	16 4a       	or	r10,r11
8000c9a6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c9aa:	f8 0b 0d 04 	divu	r4,r12,r11
8000c9ae:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c9b2:	08 91       	mov	r1,r4
8000c9b4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c9b8:	e8 0e 02 46 	mul	r6,r4,lr
8000c9bc:	0c 3c       	cp.w	r12,r6
8000c9be:	c0 a2       	brcc	8000c9d2 <__avr32_umod64+0x19a>
8000c9c0:	20 11       	sub	r1,1
8000c9c2:	10 0c       	add	r12,r8
8000c9c4:	10 3c       	cp.w	r12,r8
8000c9c6:	c0 63       	brcs	8000c9d2 <__avr32_umod64+0x19a>
8000c9c8:	0c 3c       	cp.w	r12,r6
8000c9ca:	f7 b1 03 01 	sublo	r1,1
8000c9ce:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c9d2:	0c 1c       	sub	r12,r6
8000c9d4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c9d8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c9dc:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c9e0:	08 96       	mov	r6,r4
8000c9e2:	e8 0e 02 4e 	mul	lr,r4,lr
8000c9e6:	1c 3b       	cp.w	r11,lr
8000c9e8:	c0 a2       	brcc	8000c9fc <__avr32_umod64+0x1c4>
8000c9ea:	20 16       	sub	r6,1
8000c9ec:	10 0b       	add	r11,r8
8000c9ee:	10 3b       	cp.w	r11,r8
8000c9f0:	c0 63       	brcs	8000c9fc <__avr32_umod64+0x1c4>
8000c9f2:	1c 3b       	cp.w	r11,lr
8000c9f4:	f7 b6 03 01 	sublo	r6,1
8000c9f8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c9fc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ca00:	1c 1b       	sub	r11,lr
8000ca02:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ca06:	00 9e       	mov	lr,r0
8000ca08:	02 9c       	mov	r12,r1
8000ca0a:	16 3c       	cp.w	r12,r11
8000ca0c:	e0 8b 00 08 	brhi	8000ca1c <__avr32_umod64+0x1e4>
8000ca10:	5f 06       	sreq	r6
8000ca12:	06 30       	cp.w	r0,r3
8000ca14:	5f ba       	srhi	r10
8000ca16:	ed ea 00 0a 	and	r10,r6,r10
8000ca1a:	c0 60       	breq	8000ca26 <__avr32_umod64+0x1ee>
8000ca1c:	fc 02 01 04 	sub	r4,lr,r2
8000ca20:	f8 08 01 4c 	sbc	r12,r12,r8
8000ca24:	08 9e       	mov	lr,r4
8000ca26:	e6 0e 01 0a 	sub	r10,r3,lr
8000ca2a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ca2e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ca32:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ca36:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ca3a:	f8 01 09 4c 	lsl	r12,r12,r1
8000ca3e:	18 4a       	or	r10,r12
8000ca40:	2f dd       	sub	sp,-12
8000ca42:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 fc 	sub	pc,pc,28924

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 9d 	rcall	80005440 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 96 	rcall	80005440 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 8f 	rcall	80005440 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 88 	rcall	80005440 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
