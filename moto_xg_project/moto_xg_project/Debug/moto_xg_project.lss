
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a714  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001154  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000db54  8000db54  0000df54  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000db58  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e590  0000ea3c  2**0
                  ALLOC
  8 .bss          000046e0  00000a40  8000e590  0000ea40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001290  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 0000287a  00000000  00000000  0000fd00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000298e9  00000000  00000000  0001257a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006c60  00000000  00000000  0003be63  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c5f7  00000000  00000000  00042ac3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000031cc  00000000  00000000  0004f0bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000072b3  00000000  00000000  00052288  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000da52  00000000  00000000  0005953b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001368  00000000  00000000  00066f90  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c8 f0 	sub	pc,pc,-14096

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 7c       	ld.ub	r12,--r6

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d 04       	mov	r4,-48
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 18       	sub	r8,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 04       	sub	r4,-112
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ca 00       	breq	80001fc2 <_trampoline+0x1fc2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	66 50       	ld.w	r0,r3[0x14]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000209c:	49 77       	lddpc	r7,800020f8 <app_cfg+0x68>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000209e:	30 62       	mov	r2,6
800020a0:	30 13       	mov	r3,1
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a2:	30 11       	mov	r1,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020a4:	30 c0       	mov	r0,12
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 95       	mov	r5,r8
800020a8:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c0 a1       	brne	800020c8 <app_cfg+0x38>
800020b6:	0f 88       	ld.ub	r8,r7[0x0]
800020b8:	58 08       	cp.w	r8,0
800020ba:	c0 71       	brne	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
800020bc:	ae 81       	st.b	r7[0x0],r1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020be:	00 9b       	mov	r11,r0
800020c0:	06 9c       	mov	r12,r3
800020c2:	f0 1f 00 0f 	mcall	800020fc <app_cfg+0x6c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c6:	c0 d8       	rjmp	800020e0 <app_cfg+0x50>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800020c8:	0f 88       	ld.ub	r8,r7[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 30       	breq	800020d2 <app_cfg+0x42>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
800020ce:	d7 03       	nop
800020d0:	c0 88       	rjmp	800020e0 <app_cfg+0x50>
				
		}
		else
		{
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			nop();
800020d6:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800020d8:	04 9b       	mov	r11,r2
800020da:	06 9c       	mov	r12,r3
800020dc:	f0 1f 00 08 	mcall	800020fc <app_cfg+0x6c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e0:	08 9b       	mov	r11,r4
800020e2:	0a 9c       	mov	r12,r5
800020e4:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020e8:	ce 2b       	rjmp	800020ac <app_cfg+0x1c>
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	63 40       	ld.w	r0,r1[0x50]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 48       	or	r8,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d 7c       	ld.ub	r12,--r6
800020f8:	00 00       	add	r0,r0
800020fa:	0a 4c       	or	r12,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	3e 90       	mov	r0,-23
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	64 f0       	ld.w	r0,r2[0x3c]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	ca 08       	rjmp	80002252 <ButtonConfig_brdcst_func+0x2a>
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	6a 14       	ld.w	r4,r5[0x4]

80002118 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002118:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000211a:	48 99       	lddpc	r9,8000213c <app_payload_rx_proc+0x24>
8000211c:	13 88       	ld.ub	r8,r9[0x0]
8000211e:	2f f8       	sub	r8,-1
80002120:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002122:	30 39       	mov	r9,3
80002124:	f2 08 18 00 	cp.b	r8,r9
80002128:	c0 71       	brne	80002136 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000212a:	30 09       	mov	r9,0
8000212c:	48 48       	lddpc	r8,8000213c <app_payload_rx_proc+0x24>
8000212e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002130:	48 4c       	lddpc	r12,80002140 <app_payload_rx_proc+0x28>
80002132:	f0 1f 00 05 	mcall	80002144 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002136:	48 58       	lddpc	r8,80002148 <app_payload_rx_proc+0x30>
80002138:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000213a:	d8 02       	popm	pc
8000213c:	00 00       	add	r0,r0
8000213e:	0a 55       	eor	r5,r5
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	ca 0c       	rcall	80002282 <ButtonConfig_brdcst_func+0x5a>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	6a 14       	ld.w	r4,r5[0x4]
80002148:	00 00       	add	r0,r0
8000214a:	0a 43       	or	r3,r5

8000214c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_brdcst_func+0x10>
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ca 18       	rjmp	8000229c <ButtonConfig_brdcst_func+0x74>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	6a 14       	ld.w	r4,r5[0x4]

80002160 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_reply_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_reply_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	ca 38       	rjmp	800022b4 <ButtonConfig_brdcst_func+0x8c>
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	6a 14       	ld.w	r4,r5[0x4]

80002174 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <FD_request_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <FD_request_func+0x10>
	
	
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ca 54       	brge	800020cc <app_cfg+0x3c>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6a 14       	ld.w	r4,r5[0x4]

80002188 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002188:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000218a:	48 3c       	lddpc	r12,80002194 <EnOB_brdcst_func+0xc>
8000218c:	f0 1f 00 03 	mcall	80002198 <EnOB_brdcst_func+0x10>
}
80002190:	d8 02       	popm	pc
80002192:	00 00       	add	r0,r0
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ca 70       	breq	800020e4 <app_cfg+0x54>
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	6a 14       	ld.w	r4,r5[0x4]

8000219c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000219c:	eb cd 40 80 	pushm	r7,lr
800021a0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800021a2:	19 a9       	ld.ub	r9,r12[0x2]
800021a4:	30 08       	mov	r8,0
800021a6:	f0 09 18 00 	cp.b	r9,r8
800021aa:	c1 91       	brne	800021dc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021ac:	19 b8       	ld.ub	r8,r12[0x3]
800021ae:	30 19       	mov	r9,1
800021b0:	f2 08 18 00 	cp.b	r8,r9
800021b4:	c0 61       	brne	800021c0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021b6:	49 0c       	lddpc	r12,800021f4 <EnOB_reply_func+0x58>
800021b8:	f0 1f 00 10 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021c0:	58 08       	cp.w	r8,0
800021c2:	c0 61       	brne	800021ce <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021c4:	48 ec       	lddpc	r12,800021fc <EnOB_reply_func+0x60>
800021c6:	f0 1f 00 0d 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	48 cc       	lddpc	r12,80002200 <EnOB_reply_func+0x64>
800021d2:	f0 1f 00 0a 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021d6:	2f fd       	sub	sp,-4
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021dc:	48 ac       	lddpc	r12,80002204 <EnOB_reply_func+0x68>
800021de:	f0 1f 00 07 	mcall	800021f8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 9c       	lddpc	r12,80002208 <EnOB_reply_func+0x6c>
800021e8:	f0 1f 00 04 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	ca 88       	rjmp	80002346 <ButtonConfig_reply_func+0x42>
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	6a 14       	ld.w	r4,r5[0x4]
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	ca a0       	breq	80002152 <FD_brdcst_func+0x6>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	ca b4       	brge	80002158 <FD_brdcst_func+0xc>
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	ca cc       	rcall	8000235e <DataSession_brdcst_func+0x16>
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	ca e8       	rjmp	80002366 <DataSession_brdcst_func+0x1e>

8000220c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000220e:	19 a9       	ld.ub	r9,r12[0x2]
80002210:	31 18       	mov	r8,17
80002212:	f0 09 18 00 	cp.b	r9,r8
80002216:	c0 41       	brne	8000221e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002218:	48 2c       	lddpc	r12,80002220 <SingleDetection_brdcst_func+0x14>
8000221a:	f0 1f 00 03 	mcall	80002224 <SingleDetection_brdcst_func+0x18>
8000221e:	d8 02       	popm	pc
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	cb 00       	breq	80002182 <FD_request_func+0xe>
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	6a 14       	ld.w	r4,r5[0x4]

80002228 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002228:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000222a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000222e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002230:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xb4>
80002232:	f0 1f 00 2c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002236:	0f 88       	ld.ub	r8,r7[0x0]
80002238:	1a d8       	st.w	--sp,r8
8000223a:	4a bc       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xbc>
8000223c:	f0 1f 00 29 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002240:	1a d5       	st.w	--sp,r5
80002242:	4a ac       	lddpc	r12,800022e8 <ButtonConfig_brdcst_func+0xc0>
80002244:	f0 1f 00 27 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002248:	0f a8       	ld.ub	r8,r7[0x2]
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	4a 8c       	lddpc	r12,800022ec <ButtonConfig_brdcst_func+0xc4>
8000224e:	f0 1f 00 25 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002252:	2f dd       	sub	sp,-12
80002254:	58 05       	cp.w	r5,0
80002256:	c4 10       	breq	800022d8 <ButtonConfig_brdcst_func+0xb0>
80002258:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225a:	4a 64       	lddpc	r4,800022f0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225c:	4a 63       	lddpc	r3,800022f4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000225e:	4a 72       	lddpc	r2,800022f8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	4a 71       	lddpc	r1,800022fc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002262:	4a 80       	lddpc	r0,80002300 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002264:	0f b9       	ld.ub	r9,r7[0x3]
80002266:	0f c8       	ld.ub	r8,r7[0x4]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	08 9c       	mov	r12,r4
80002272:	f0 1f 00 1c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002276:	0f d9       	ld.ub	r9,r7[0x5]
80002278:	0f e8       	ld.ub	r8,r7[0x6]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	06 9c       	mov	r12,r3
80002284:	f0 1f 00 17 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002288:	0f f9       	ld.ub	r9,r7[0x7]
8000228a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000228e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002292:	1a d8       	st.w	--sp,r8
80002294:	1a d6       	st.w	--sp,r6
80002296:	04 9c       	mov	r12,r2
80002298:	f0 1f 00 12 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000229c:	ef 39 00 09 	ld.ub	r9,r7[9]
800022a0:	ef 38 00 0a 	ld.ub	r8,r7[10]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	02 9c       	mov	r12,r1
800022ae:	f0 1f 00 0d 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022b2:	2f 8d       	sub	sp,-32
800022b4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022bc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022c0:	1a d8       	st.w	--sp,r8
800022c2:	1a d6       	st.w	--sp,r6
800022c4:	00 9c       	mov	r12,r0
800022c6:	f0 1f 00 07 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
800022ca:	2f f6       	sub	r6,-1
800022cc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ce:	2f ed       	sub	sp,-8
800022d0:	ec 05 18 00 	cp.b	r5,r6
800022d4:	fe 9b ff c8 	brhi	80002264 <ButtonConfig_brdcst_func+0x3c>
800022d8:	d8 32       	popm	r0-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cb 14       	brge	80002240 <ButtonConfig_brdcst_func+0x18>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	6a 14       	ld.w	r4,r5[0x4]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cb 34       	brge	8000224c <ButtonConfig_brdcst_func+0x24>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cb 48       	rjmp	80002452 <DataSession_reply_func+0x32>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	cb 60       	breq	8000225a <ButtonConfig_brdcst_func+0x32>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	cb 80       	breq	80002262 <ButtonConfig_brdcst_func+0x3a>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	cb a8       	rjmp	8000246a <DataSession_reply_func+0x4a>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	cb d0       	breq	80002274 <ButtonConfig_brdcst_func+0x4c>
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cb f4       	brge	8000227c <ButtonConfig_brdcst_func+0x54>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	cc 1c       	rcall	80002484 <DataSession_reply_func+0x64>

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	cc 40       	breq	800022c2 <ButtonConfig_brdcst_func+0x9a>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	6a 14       	ld.w	r4,r5[0x4]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	cb 34       	brge	800022a8 <ButtonConfig_brdcst_func+0x80>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	cc 58       	rjmp	800024d0 <CallControl_brdcst_func+0x34>

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	4a 9c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
8000235a:	f0 1f 00 2a 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	4a 6c       	lddpc	r12,80002404 <DataSession_brdcst_func+0xbc>
8000236e:	f0 1f 00 25 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	4a 4c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
8000237a:	f0 1f 00 22 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c3 b0       	breq	800023f8 <DataSession_brdcst_func+0xb0>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	4a 24       	lddpc	r4,8000240c <DataSession_brdcst_func+0xc4>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 1b 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	49 ac       	lddpc	r12,80002410 <DataSession_brdcst_func+0xc8>
800023ac:	f0 1f 00 15 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		if (ptr->State == DATA_SESSION_TX_Suc)
800023b0:	0d 88       	ld.ub	r8,r6[0x0]
800023b2:	2f fd       	sub	sp,-4
800023b4:	30 39       	mov	r9,3
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c0 51       	brne	800023c4 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
800023bc:	49 6c       	lddpc	r12,80002414 <DataSession_brdcst_func+0xcc>
800023be:	f0 1f 00 11 	mcall	80002400 <DataSession_brdcst_func+0xb8>
800023c2:	c0 c8       	rjmp	800023da <DataSession_brdcst_func+0x92>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800023c4:	30 49       	mov	r9,4
800023c6:	f2 08 18 00 	cp.b	r8,r9
800023ca:	c0 81       	brne	800023da <DataSession_brdcst_func+0x92>
		{
			log("data transmit failure\n");
800023cc:	49 3c       	lddpc	r12,80002418 <DataSession_brdcst_func+0xd0>
800023ce:	f0 1f 00 0d 	mcall	80002400 <DataSession_brdcst_func+0xb8>
			xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
800023d2:	37 8b       	mov	r11,120
800023d4:	30 1c       	mov	r12,1
800023d6:	f0 1f 00 12 	mcall	8000241c <DataSession_brdcst_func+0xd4>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023da:	0d a7       	ld.ub	r7,r6[0x2]
800023dc:	0d b8       	ld.ub	r8,r6[0x3]
800023de:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
800023e2:	0d 98       	ld.ub	r8,r6[0x1]
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	48 8c       	lddpc	r12,80002404 <DataSession_brdcst_func+0xbc>
800023e8:	f0 1f 00 06 	mcall	80002400 <DataSession_brdcst_func+0xb8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023ec:	5c 77       	castu.h	r7
800023ee:	1a d7       	st.w	--sp,r7
800023f0:	48 6c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
800023f2:	f0 1f 00 04 	mcall	80002400 <DataSession_brdcst_func+0xb8>
800023f6:	2f ed       	sub	sp,-8
800023f8:	d8 22       	popm	r4-r7,pc
800023fa:	00 00       	add	r0,r0
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	cc 74       	brge	8000238c <DataSession_brdcst_func+0x44>
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	6a 14       	ld.w	r4,r5[0x4]
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	cc 88       	rjmp	80002596 <AudioRoutingControl_reply_func+0xe>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	cc a0       	breq	8000239e <DataSession_brdcst_func+0x56>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	cc bc       	rcall	800025a4 <AudioRoutingControl_reply_func+0x1c>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	cc d4       	brge	800023ac <DataSession_brdcst_func+0x64>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	cc e0       	breq	800023b2 <DataSession_brdcst_func+0x6a>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	cc f8       	rjmp	800025b8 <Volume_reply_func+0x8>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	3e 90       	mov	r0,-23

80002420 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002420:	eb cd 40 80 	pushm	r7,lr
80002424:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002426:	19 a9       	ld.ub	r9,r12[0x2]
80002428:	30 08       	mov	r8,0
8000242a:	f0 09 18 00 	cp.b	r9,r8
8000242e:	c1 11       	brne	80002450 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002430:	49 3c       	lddpc	r12,8000247c <DataSession_reply_func+0x5c>
80002432:	f0 1f 00 14 	mcall	80002480 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002436:	0f b8       	ld.ub	r8,r7[0x3]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	49 3c       	lddpc	r12,80002484 <DataSession_reply_func+0x64>
8000243c:	f0 1f 00 11 	mcall	80002480 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002440:	0f c8       	ld.ub	r8,r7[0x4]
80002442:	1a d8       	st.w	--sp,r8
80002444:	49 1c       	lddpc	r12,80002488 <DataSession_reply_func+0x68>
80002446:	f0 1f 00 0f 	mcall	80002480 <DataSession_reply_func+0x60>
8000244a:	2f ed       	sub	sp,-8
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002450:	48 fc       	lddpc	r12,8000248c <DataSession_reply_func+0x6c>
80002452:	f0 1f 00 0c 	mcall	80002480 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
80002456:	0f a8       	ld.ub	r8,r7[0x2]
80002458:	1a d8       	st.w	--sp,r8
8000245a:	48 ec       	lddpc	r12,80002490 <DataSession_reply_func+0x70>
8000245c:	f0 1f 00 09 	mcall	80002480 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002460:	0f b8       	ld.ub	r8,r7[0x3]
80002462:	1a d8       	st.w	--sp,r8
80002464:	48 cc       	lddpc	r12,80002494 <DataSession_reply_func+0x74>
80002466:	f0 1f 00 07 	mcall	80002480 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000246a:	0f c8       	ld.ub	r8,r7[0x4]
8000246c:	1a d8       	st.w	--sp,r8
8000246e:	48 bc       	lddpc	r12,80002498 <DataSession_reply_func+0x78>
80002470:	f0 1f 00 04 	mcall	80002480 <DataSession_reply_func+0x60>
80002474:	2f dd       	sub	sp,-12
80002476:	e3 cd 80 80 	ldm	sp++,r7,pc
8000247a:	00 00       	add	r0,r0
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	cd 10       	breq	80002420 <DataSession_reply_func>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	6a 14       	ld.w	r4,r5[0x4]
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	cd 20       	breq	8000242a <DataSession_reply_func+0xa>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	cd 2c       	rcall	8000262e <spk_brdcst_func+0x1a>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	cd 38       	rjmp	80002634 <spk_brdcst_func+0x20>
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	cd 48       	rjmp	8000263a <spk_brdcst_func+0x26>
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	cd 58       	rjmp	80002640 <spk_brdcst_func+0x2c>
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	cd 64       	brge	80002446 <DataSession_reply_func+0x26>

8000249c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800024a4:	0f 98       	ld.ub	r8,r7[0x1]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 bc       	lddpc	r12,800024d4 <CallControl_brdcst_func+0x38>
800024aa:	f0 1f 00 0c 	mcall	800024d8 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024ae:	2f fd       	sub	sp,-4
800024b0:	0f 99       	ld.ub	r9,r7[0x1]
800024b2:	30 38       	mov	r8,3
800024b4:	f0 09 18 00 	cp.b	r9,r8
800024b8:	c0 41       	brne	800024c0 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ba:	30 09       	mov	r9,0
800024bc:	48 88       	lddpc	r8,800024dc <CallControl_brdcst_func+0x40>
800024be:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024c0:	0f 99       	ld.ub	r9,r7[0x1]
800024c2:	30 48       	mov	r8,4
800024c4:	f0 09 18 00 	cp.b	r9,r8
800024c8:	c0 41       	brne	800024d0 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024ca:	30 19       	mov	r9,1
800024cc:	48 48       	lddpc	r8,800024dc <CallControl_brdcst_func+0x40>
800024ce:	b0 89       	st.b	r8[0x0],r9
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	cd 70       	breq	80002484 <DataSession_reply_func+0x64>
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	6a 14       	ld.w	r4,r5[0x4]
800024dc:	00 00       	add	r0,r0
800024de:	0a 45       	or	r5,r5

800024e0 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024e4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024e8:	0f 99       	ld.ub	r9,r7[0x1]
800024ea:	30 08       	mov	r8,0
800024ec:	f0 09 18 00 	cp.b	r9,r8
800024f0:	c0 71       	brne	800024fe <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024f2:	48 ac       	lddpc	r12,80002518 <TransmitControl_brdcst_func+0x38>
800024f4:	f0 1f 00 0a 	mcall	8000251c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024f8:	30 09       	mov	r9,0
800024fa:	48 a8       	lddpc	r8,80002520 <TransmitControl_brdcst_func+0x40>
800024fc:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024fe:	0f 99       	ld.ub	r9,r7[0x1]
80002500:	30 18       	mov	r8,1
80002502:	f0 09 18 00 	cp.b	r9,r8
80002506:	c0 71       	brne	80002514 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002508:	48 7c       	lddpc	r12,80002524 <TransmitControl_brdcst_func+0x44>
8000250a:	f0 1f 00 05 	mcall	8000251c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000250e:	30 19       	mov	r9,1
80002510:	48 48       	lddpc	r8,80002520 <TransmitControl_brdcst_func+0x40>
80002512:	b0 89       	st.b	r8[0x0],r9
80002514:	e3 cd 80 80 	ldm	sp++,r7,pc
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	cd 88       	rjmp	800026ca <mic_brdcst_func+0x36>
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	6a 14       	ld.w	r4,r5[0x4]
80002520:	00 00       	add	r0,r0
80002522:	0a 44       	or	r4,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	cd a0       	breq	800024da <CallControl_brdcst_func+0x3e>

80002528 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002528:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000252c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002530:	0f 89       	ld.ub	r9,r7[0x0]
80002532:	30 08       	mov	r8,0
80002534:	f0 09 18 00 	cp.b	r9,r8
80002538:	c1 61       	brne	80002564 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000253a:	48 ec       	lddpc	r12,80002570 <TransmitControl_reply_func+0x48>
8000253c:	f0 1f 00 0e 	mcall	80002574 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002540:	0f 98       	ld.ub	r8,r7[0x1]
80002542:	1a d8       	st.w	--sp,r8
80002544:	48 dc       	lddpc	r12,80002578 <TransmitControl_reply_func+0x50>
80002546:	f0 1f 00 0c 	mcall	80002574 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000254a:	0f a8       	ld.ub	r8,r7[0x2]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 cc       	lddpc	r12,8000257c <TransmitControl_reply_func+0x54>
80002550:	f0 1f 00 09 	mcall	80002574 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002554:	0f b8       	ld.ub	r8,r7[0x3]
80002556:	1a d8       	st.w	--sp,r8
80002558:	48 ac       	lddpc	r12,80002580 <TransmitControl_reply_func+0x58>
8000255a:	f0 1f 00 07 	mcall	80002574 <TransmitControl_reply_func+0x4c>
8000255e:	2f dd       	sub	sp,-12
80002560:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002564:	48 8c       	lddpc	r12,80002584 <TransmitControl_reply_func+0x5c>
80002566:	f0 1f 00 04 	mcall	80002574 <TransmitControl_reply_func+0x4c>
8000256a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000256e:	00 00       	add	r0,r0
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	cd b4       	brge	80002528 <TransmitControl_reply_func>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	6a 14       	ld.w	r4,r5[0x4]
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	cd d0       	breq	80002534 <TransmitControl_reply_func+0xc>
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	cd e4       	brge	8000253a <TransmitControl_reply_func+0x12>
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	ce 00       	breq	80002542 <TransmitControl_reply_func+0x1a>
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	ce 10       	breq	80002548 <TransmitControl_reply_func+0x20>

80002588 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002588:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000258a:	19 a9       	ld.ub	r9,r12[0x2]
8000258c:	30 08       	mov	r8,0
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 51       	brne	8000259c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002594:	48 4c       	lddpc	r12,800025a4 <AudioRoutingControl_reply_func+0x1c>
80002596:	f0 1f 00 05 	mcall	800025a8 <AudioRoutingControl_reply_func+0x20>
8000259a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000259c:	48 4c       	lddpc	r12,800025ac <AudioRoutingControl_reply_func+0x24>
8000259e:	f0 1f 00 03 	mcall	800025a8 <AudioRoutingControl_reply_func+0x20>
800025a2:	d8 02       	popm	pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	ce 28       	rjmp	8000276a <mic_reply_func+0x7e>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	6a 14       	ld.w	r4,r5[0x4]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	ce 38       	rjmp	80002774 <mic_reply_func+0x88>

800025b0 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025b0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025b4:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025b8:	0f 89       	ld.ub	r9,r7[0x0]
800025ba:	30 08       	mov	r8,0
800025bc:	f0 09 18 00 	cp.b	r9,r8
800025c0:	c1 b1       	brne	800025f6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025c2:	0f b8       	ld.ub	r8,r7[0x3]
800025c4:	31 09       	mov	r9,16
800025c6:	f2 08 18 00 	cp.b	r8,r9
800025ca:	c0 f1       	brne	800025e8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025cc:	48 dc       	lddpc	r12,80002600 <Volume_reply_func+0x50>
800025ce:	f0 1f 00 0e 	mcall	80002604 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025d2:	0f 99       	ld.ub	r9,r7[0x1]
800025d4:	0f a8       	ld.ub	r8,r7[0x2]
800025d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025da:	1a d8       	st.w	--sp,r8
800025dc:	48 bc       	lddpc	r12,80002608 <Volume_reply_func+0x58>
800025de:	f0 1f 00 0a 	mcall	80002604 <Volume_reply_func+0x54>
800025e2:	2f fd       	sub	sp,-4
800025e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	48 9c       	lddpc	r12,8000260c <Volume_reply_func+0x5c>
800025ec:	f0 1f 00 06 	mcall	80002604 <Volume_reply_func+0x54>
800025f0:	2f fd       	sub	sp,-4
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025f6:	48 7c       	lddpc	r12,80002610 <Volume_reply_func+0x60>
800025f8:	f0 1f 00 03 	mcall	80002604 <Volume_reply_func+0x54>
800025fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	ce 4c       	rcall	800027ca <dcm_reply_func+0x2>
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	6a 14       	ld.w	r4,r5[0x4]
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	ce 60       	breq	800025d6 <Volume_reply_func+0x26>
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	ce 7c       	rcall	800027dc <dcm_reply_func+0x14>
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	ce 94       	brge	800025e4 <Volume_reply_func+0x34>

80002614 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002614:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002616:	19 d9       	ld.ub	r9,r12[0x5]
80002618:	30 08       	mov	r8,0
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 81       	brne	8000262e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002620:	10 99       	mov	r9,r8
80002622:	48 78       	lddpc	r8,8000263c <spk_brdcst_func+0x28>
80002624:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002626:	48 7c       	lddpc	r12,80002640 <spk_brdcst_func+0x2c>
80002628:	f0 1f 00 07 	mcall	80002644 <spk_brdcst_func+0x30>
8000262c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000262e:	30 19       	mov	r9,1
80002630:	48 38       	lddpc	r8,8000263c <spk_brdcst_func+0x28>
80002632:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002634:	48 5c       	lddpc	r12,80002648 <spk_brdcst_func+0x34>
80002636:	f0 1f 00 04 	mcall	80002644 <spk_brdcst_func+0x30>
8000263a:	d8 02       	popm	pc
8000263c:	00 00       	add	r0,r0
8000263e:	0a 40       	or	r0,r5
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	ce ac       	rcall	80002816 <dcm_reply_func+0x4e>
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	6a 14       	ld.w	r4,r5[0x4]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	ce bc       	rcall	80002820 <dcm_reply_func+0x58>

8000264c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000264c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000264e:	19 a9       	ld.ub	r9,r12[0x2]
80002650:	30 08       	mov	r8,0
80002652:	f0 09 18 00 	cp.b	r9,r8
80002656:	c0 f1       	brne	80002674 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002658:	19 e9       	ld.ub	r9,r12[0x6]
8000265a:	f0 09 18 00 	cp.b	r9,r8
8000265e:	c0 40       	breq	80002666 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002660:	30 19       	mov	r9,1
80002662:	48 98       	lddpc	r8,80002684 <spk_reply_func+0x38>
80002664:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002666:	19 e8       	ld.ub	r8,r12[0x6]
80002668:	1a d8       	st.w	--sp,r8
8000266a:	48 8c       	lddpc	r12,80002688 <spk_reply_func+0x3c>
8000266c:	f0 1f 00 08 	mcall	8000268c <spk_reply_func+0x40>
80002670:	2f fd       	sub	sp,-4
80002672:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002674:	30 09       	mov	r9,0
80002676:	48 48       	lddpc	r8,80002684 <spk_reply_func+0x38>
80002678:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000267a:	48 6c       	lddpc	r12,80002690 <spk_reply_func+0x44>
8000267c:	f0 1f 00 04 	mcall	8000268c <spk_reply_func+0x40>
80002680:	d8 02       	popm	pc
80002682:	00 00       	add	r0,r0
80002684:	00 00       	add	r0,r0
80002686:	0a 40       	or	r0,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	ce c8       	rjmp	80002862 <Phyuserinput_brdcst_func+0xa>
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	6a 14       	ld.w	r4,r5[0x4]
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	ce d8       	rjmp	8000286c <Phyuserinput_brdcst_func+0x14>

80002694 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002694:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002698:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000269c:	0f a9       	ld.ub	r9,r7[0x2]
8000269e:	30 08       	mov	r8,0
800026a0:	f0 09 18 00 	cp.b	r9,r8
800026a4:	c0 71       	brne	800026b2 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026a6:	48 dc       	lddpc	r12,800026d8 <mic_brdcst_func+0x44>
800026a8:	f0 1f 00 0d 	mcall	800026dc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026ac:	30 09       	mov	r9,0
800026ae:	48 d8       	lddpc	r8,800026e0 <mic_brdcst_func+0x4c>
800026b0:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026b2:	0f a9       	ld.ub	r9,r7[0x2]
800026b4:	31 18       	mov	r8,17
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c0 d1       	brne	800026d4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026bc:	48 ac       	lddpc	r12,800026e4 <mic_brdcst_func+0x50>
800026be:	f0 1f 00 08 	mcall	800026dc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026c2:	48 89       	lddpc	r9,800026e0 <mic_brdcst_func+0x4c>
800026c4:	30 18       	mov	r8,1
800026c6:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026c8:	13 89       	ld.ub	r9,r9[0x0]
800026ca:	f0 09 18 00 	cp.b	r9,r8
800026ce:	c0 31       	brne	800026d4 <mic_brdcst_func+0x40>
800026d0:	48 68       	lddpc	r8,800026e8 <mic_brdcst_func+0x54>
800026d2:	11 88       	ld.ub	r8,r8[0x0]
800026d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	ce e4       	brge	800026b6 <mic_brdcst_func+0x22>
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	6a 14       	ld.w	r4,r5[0x4]
800026e0:	00 00       	add	r0,r0
800026e2:	0a 54       	eor	r4,r5
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	ce f8       	rjmp	800028c4 <DeviceInitializationStatus_brdcst_func+0x14>
800026e8:	00 00       	add	r0,r0
800026ea:	0a 45       	or	r5,r5

800026ec <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026f4:	49 ac       	lddpc	r12,8000275c <mic_reply_func+0x70>
800026f6:	f0 1f 00 1b 	mcall	80002760 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026fa:	0f 89       	ld.ub	r9,r7[0x0]
800026fc:	30 08       	mov	r8,0
800026fe:	f0 09 18 00 	cp.b	r9,r8
80002702:	c2 71       	brne	80002750 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002704:	0f 98       	ld.ub	r8,r7[0x1]
80002706:	30 29       	mov	r9,2
80002708:	f2 08 18 00 	cp.b	r8,r9
8000270c:	c1 b1       	brne	80002742 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000270e:	49 6c       	lddpc	r12,80002764 <mic_reply_func+0x78>
80002710:	f0 1f 00 14 	mcall	80002760 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002714:	0f a8       	ld.ub	r8,r7[0x2]
80002716:	1a d8       	st.w	--sp,r8
80002718:	49 4c       	lddpc	r12,80002768 <mic_reply_func+0x7c>
8000271a:	f0 1f 00 12 	mcall	80002760 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000271e:	0f b8       	ld.ub	r8,r7[0x3]
80002720:	1a d8       	st.w	--sp,r8
80002722:	49 3c       	lddpc	r12,8000276c <mic_reply_func+0x80>
80002724:	f0 1f 00 0f 	mcall	80002760 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002728:	0f c8       	ld.ub	r8,r7[0x4]
8000272a:	1a d8       	st.w	--sp,r8
8000272c:	49 1c       	lddpc	r12,80002770 <mic_reply_func+0x84>
8000272e:	f0 1f 00 0d 	mcall	80002760 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002732:	0f d8       	ld.ub	r8,r7[0x5]
80002734:	1a d8       	st.w	--sp,r8
80002736:	49 0c       	lddpc	r12,80002774 <mic_reply_func+0x88>
80002738:	f0 1f 00 0a 	mcall	80002760 <mic_reply_func+0x74>
8000273c:	2f cd       	sub	sp,-16
8000273e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002742:	1a d8       	st.w	--sp,r8
80002744:	48 dc       	lddpc	r12,80002778 <mic_reply_func+0x8c>
80002746:	f0 1f 00 07 	mcall	80002760 <mic_reply_func+0x74>
8000274a:	2f fd       	sub	sp,-4
8000274c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002750:	48 bc       	lddpc	r12,8000277c <mic_reply_func+0x90>
80002752:	f0 1f 00 04 	mcall	80002760 <mic_reply_func+0x74>
80002756:	e3 cd 80 80 	ldm	sp++,r7,pc
8000275a:	00 00       	add	r0,r0
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	cf 0c       	rcall	8000293e <payload_rx_process+0x2>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	6a 14       	ld.w	r4,r5[0x4]
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	cf 1c       	rcall	80002948 <payload_rx_process+0xc>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	cf 30       	breq	80002750 <mic_reply_func+0x64>
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	cf 44       	brge	80002756 <mic_reply_func+0x6a>
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	cf 60       	breq	8000275e <mic_reply_func+0x72>
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	cf 78       	rjmp	80002964 <payload_rx_process+0x28>
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	cf 90       	breq	8000276c <mic_reply_func+0x80>
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	cf a8       	rjmp	80002972 <payload_rx_process+0x36>

80002780 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002780:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002784:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002788:	48 bc       	lddpc	r12,800027b4 <dcm_brdcst_func+0x34>
8000278a:	f0 1f 00 0c 	mcall	800027b8 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000278e:	0f 88       	ld.ub	r8,r7[0x0]
80002790:	1a d8       	st.w	--sp,r8
80002792:	48 bc       	lddpc	r12,800027bc <dcm_brdcst_func+0x3c>
80002794:	f0 1f 00 09 	mcall	800027b8 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002798:	0f a8       	ld.ub	r8,r7[0x2]
8000279a:	1a d8       	st.w	--sp,r8
8000279c:	48 9c       	lddpc	r12,800027c0 <dcm_brdcst_func+0x40>
8000279e:	f0 1f 00 07 	mcall	800027b8 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800027a2:	0f 98       	ld.ub	r8,r7[0x1]
800027a4:	1a d8       	st.w	--sp,r8
800027a6:	48 8c       	lddpc	r12,800027c4 <dcm_brdcst_func+0x44>
800027a8:	f0 1f 00 04 	mcall	800027b8 <dcm_brdcst_func+0x38>
800027ac:	2f dd       	sub	sp,-12
	
	
}
800027ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800027b2:	00 00       	add	r0,r0
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	cf b8       	rjmp	800029ac <phy_rx+0x8>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	6a 14       	ld.w	r4,r5[0x4]
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	cf cc       	rcall	800029b6 <phy_rx+0x12>
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	cf e0       	breq	800027be <dcm_brdcst_func+0x3e>
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	cf f8       	rjmp	800029c4 <phy_rx+0x20>

800027c8 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027c8:	eb cd 40 80 	pushm	r7,lr
800027cc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ce:	19 a9       	ld.ub	r9,r12[0x2]
800027d0:	30 08       	mov	r8,0
800027d2:	f0 09 18 00 	cp.b	r9,r8
800027d6:	c1 b1       	brne	8000280c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027d8:	19 b8       	ld.ub	r8,r12[0x3]
800027da:	30 19       	mov	r9,1
800027dc:	f2 08 18 00 	cp.b	r8,r9
800027e0:	c0 51       	brne	800027ea <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027e2:	48 ec       	lddpc	r12,80002818 <dcm_reply_func+0x50>
800027e4:	f0 1f 00 0e 	mcall	8000281c <dcm_reply_func+0x54>
800027e8:	c0 a8       	rjmp	800027fc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027ea:	58 08       	cp.w	r8,0
800027ec:	c0 51       	brne	800027f6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027ee:	48 dc       	lddpc	r12,80002820 <dcm_reply_func+0x58>
800027f0:	f0 1f 00 0b 	mcall	8000281c <dcm_reply_func+0x54>
800027f4:	c0 48       	rjmp	800027fc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027f6:	48 cc       	lddpc	r12,80002824 <dcm_reply_func+0x5c>
800027f8:	f0 1f 00 09 	mcall	8000281c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027fc:	0f d8       	ld.ub	r8,r7[0x5]
800027fe:	1a d8       	st.w	--sp,r8
80002800:	48 ac       	lddpc	r12,80002828 <dcm_reply_func+0x60>
80002802:	f0 1f 00 07 	mcall	8000281c <dcm_reply_func+0x54>
80002806:	2f fd       	sub	sp,-4
80002808:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000280c:	48 8c       	lddpc	r12,8000282c <dcm_reply_func+0x64>
8000280e:	f0 1f 00 04 	mcall	8000281c <dcm_reply_func+0x54>
80002812:	e3 cd 80 80 	ldm	sp++,r7,pc
80002816:	00 00       	add	r0,r0
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d0 14       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	6a 14       	ld.w	r4,r5[0x4]
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	d0 28       	*unknown*
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	d0 3c       	*unknown*
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	d0 50       	acall	0x5
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	d0 5c       	*unknown*

80002830 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002830:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002832:	19 a9       	ld.ub	r9,r12[0x2]
80002834:	30 08       	mov	r8,0
80002836:	f0 09 18 00 	cp.b	r9,r8
8000283a:	c0 51       	brne	80002844 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000283c:	48 4c       	lddpc	r12,8000284c <ToneControl_reply_func+0x1c>
8000283e:	f0 1f 00 05 	mcall	80002850 <ToneControl_reply_func+0x20>
80002842:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002844:	48 4c       	lddpc	r12,80002854 <ToneControl_reply_func+0x24>
80002846:	f0 1f 00 03 	mcall	80002850 <ToneControl_reply_func+0x20>
8000284a:	d8 02       	popm	pc
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d0 68       	*unknown*
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	6a 14       	ld.w	r4,r5[0x4]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	d0 74       	*unknown*

80002858 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002858:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000285c:	19 c7       	ld.ub	r7,r12[0x4]
8000285e:	19 d8       	ld.ub	r8,r12[0x5]
80002860:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002864:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002866:	48 dc       	lddpc	r12,80002898 <Phyuserinput_brdcst_func+0x40>
80002868:	f0 1f 00 0d 	mcall	8000289c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000286c:	36 08       	mov	r8,96
8000286e:	f0 07 19 00 	cp.h	r7,r8
80002872:	c1 11       	brne	80002894 <Phyuserinput_brdcst_func+0x3c>
80002874:	48 b8       	lddpc	r8,800028a0 <Phyuserinput_brdcst_func+0x48>
80002876:	11 89       	ld.ub	r9,r8[0x0]
80002878:	30 18       	mov	r8,1
8000287a:	f0 09 18 00 	cp.b	r9,r8
8000287e:	c0 b1       	brne	80002894 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		//xcmp_IdleTestTone(Tone_Start, Private_Call_Receive_Tone);//set tone to indicate the scan!!!
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002880:	31 4b       	mov	r11,20
80002882:	30 1c       	mov	r12,1
80002884:	f0 1f 00 08 	mcall	800028a4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
80002888:	e0 6c 03 20 	mov	r12,800
8000288c:	f0 1f 00 07 	mcall	800028a8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002890:	f0 1f 00 07 	mcall	800028ac <Phyuserinput_brdcst_func+0x54>
80002894:	e3 cd 80 80 	ldm	sp++,r7,pc
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	d0 80       	acall	0x8
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	6a 14       	ld.w	r4,r5[0x4]
800028a0:	00 00       	add	r0,r0
800028a2:	0a 4c       	or	r12,r5
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	3e 90       	mov	r0,-23
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	64 a8       	ld.w	r8,r2[0x28]
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	4e 64       	lddpc	r4,80002a44 <phy_tx+0x48>

800028b0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028b0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028b2:	19 e8       	ld.ub	r8,r12[0x6]
800028b4:	30 19       	mov	r9,1
800028b6:	f2 08 18 00 	cp.b	r8,r9
800028ba:	c0 61       	brne	800028c6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028bc:	48 98       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028be:	70 09       	ld.w	r9,r8[0x0]
800028c0:	a1 a9       	sbr	r9,0x0
800028c2:	91 09       	st.w	r8[0x0],r9
800028c4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c6:	30 29       	mov	r9,2
800028c8:	f2 08 18 00 	cp.b	r8,r9
800028cc:	c0 80       	breq	800028dc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ce:	48 58       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028d0:	70 09       	ld.w	r9,r8[0x0]
800028d2:	e0 19 ff fc 	andl	r9,0xfffc
800028d6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d8:	f0 1f 00 03 	mcall	800028e4 <DeviceInitializationStatus_brdcst_func+0x34>
800028dc:	d8 02       	popm	pc
800028de:	00 00       	add	r0,r0
800028e0:	00 00       	add	r0,r0
800028e2:	0d 7c       	ld.ub	r12,--r6
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	3d e4       	mov	r4,-34

800028e8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028e8:	20 1c       	sub	r12,1
800028ea:	5c 5c       	castu.b	r12
800028ec:	31 18       	mov	r8,17
800028ee:	f0 0c 18 00 	cp.b	r12,r8
800028f2:	e0 88 00 03 	brls	800028f8 <CalculateBurst+0x10>
800028f6:	5e fd       	retal	0
800028f8:	48 28       	lddpc	r8,80002900 <CalculateBurst+0x18>
800028fa:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028fe:	5e fc       	retal	r12
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	d0 a0       	acall	0xa

80002904 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002904:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002906:	48 98       	lddpc	r8,80002928 <payload_init+0x24>
80002908:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000290a:	48 98       	lddpc	r8,8000292c <payload_init+0x28>
8000290c:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000290e:	30 09       	mov	r9,0
80002910:	1a d9       	st.w	--sp,r9
80002912:	1a d9       	st.w	--sp,r9
80002914:	1a d9       	st.w	--sp,r9
80002916:	30 28       	mov	r8,2
80002918:	e0 6a 04 00 	mov	r10,1024
8000291c:	48 5b       	lddpc	r11,80002930 <payload_init+0x2c>
8000291e:	48 6c       	lddpc	r12,80002934 <payload_init+0x30>
80002920:	f0 1f 00 06 	mcall	80002938 <payload_init+0x34>
80002924:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002926:	d8 02       	popm	pc
80002928:	00 00       	add	r0,r0
8000292a:	0a 5c       	eor	r12,r5
8000292c:	00 00       	add	r0,r0
8000292e:	0a 60       	and	r0,r5
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	d0 e8       	*unknown*
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	29 3c       	sub	r12,-109
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	66 50       	ld.w	r0,r3[0x14]

8000293c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
8000293c:	eb cd 40 f8 	pushm	r3-r7,lr
80002940:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002942:	48 e8       	lddpc	r8,80002978 <payload_rx_process+0x3c>
80002944:	70 08       	ld.w	r8,r8[0x0]
80002946:	58 08       	cp.w	r8,0
80002948:	c0 71       	brne	80002956 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000294a:	30 4b       	mov	r11,4
8000294c:	30 5c       	mov	r12,5
8000294e:	f0 1f 00 0c 	mcall	8000297c <payload_rx_process+0x40>
80002952:	48 a8       	lddpc	r8,80002978 <payload_rx_process+0x3c>
80002954:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002956:	48 96       	lddpc	r6,80002978 <payload_rx_process+0x3c>
80002958:	30 05       	mov	r5,0
8000295a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000295c:	48 93       	lddpc	r3,80002980 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000295e:	6c 0c       	ld.w	r12,r6[0x0]
80002960:	0a 99       	mov	r9,r5
80002962:	08 9a       	mov	r10,r4
80002964:	1a 9b       	mov	r11,sp
80002966:	f0 1f 00 08 	mcall	80002984 <payload_rx_process+0x48>
8000296a:	58 1c       	cp.w	r12,1
8000296c:	cf 91       	brne	8000295e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000296e:	66 08       	ld.w	r8,r3[0x0]
80002970:	40 0c       	lddsp	r12,sp[0x0]
80002972:	5d 18       	icall	r8
80002974:	cf 5b       	rjmp	8000295e <payload_rx_process+0x22>
80002976:	00 00       	add	r0,r0
80002978:	00 00       	add	r0,r0
8000297a:	0a 8c       	andn	r12,r5
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	5f 34       	srlo	r4
80002980:	00 00       	add	r0,r0
80002982:	0a 5c       	eor	r12,r5
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	5c 28       	cpc	r8

80002988 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002988:	d4 01       	pushm	lr
8000298a:	20 2d       	sub	sp,8
8000298c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000298e:	30 09       	mov	r9,0
80002990:	fa ca ff f8 	sub	r10,sp,-8
80002994:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002996:	1a 9b       	mov	r11,sp
80002998:	f0 1f 00 02 	mcall	800029a0 <set_idle_store_isr+0x18>
}
8000299c:	2f ed       	sub	sp,-8
8000299e:	d8 02       	popm	pc
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	5d e4       	*unknown*

800029a4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029a4:	d4 01       	pushm	lr
800029a6:	20 2d       	sub	sp,8
800029a8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029aa:	58 0c       	cp.w	r12,0
800029ac:	c1 10       	breq	800029ce <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029ae:	30 08       	mov	r8,0
800029b0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029b2:	98 88       	ld.uh	r8,r12[0x0]
800029b4:	e2 18 f0 00 	andl	r8,0xf000,COH
800029b8:	e0 48 40 00 	cp.w	r8,16384
800029bc:	c0 91       	brne	800029ce <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029be:	48 68       	lddpc	r8,800029d4 <phy_rx+0x30>
800029c0:	70 0c       	ld.w	r12,r8[0x0]
800029c2:	30 09       	mov	r9,0
800029c4:	fa ca ff fc 	sub	r10,sp,-4
800029c8:	1a 9b       	mov	r11,sp
800029ca:	f0 1f 00 04 	mcall	800029d8 <phy_rx+0x34>
		}	

    }
		
 
}
800029ce:	2f ed       	sub	sp,-8
800029d0:	d8 02       	popm	pc
800029d2:	00 00       	add	r0,r0
800029d4:	00 00       	add	r0,r0
800029d6:	0a b8       	st.h	r5++,r8
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	5d e4       	*unknown*

800029dc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029dc:	eb cd 40 80 	pushm	r7,lr
800029e0:	20 1d       	sub	sp,4
800029e2:	fa c7 ff fc 	sub	r7,sp,-4
800029e6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029e8:	30 09       	mov	r9,0
800029ea:	12 9a       	mov	r10,r9
800029ec:	1a 9b       	mov	r11,sp
800029ee:	f0 1f 00 03 	mcall	800029f8 <set_idle_store+0x1c>
}
800029f2:	2f fd       	sub	sp,-4
800029f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	5e 34       	retlo	r4

800029fc <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029fc:	d4 01       	pushm	lr
800029fe:	20 1d       	sub	sp,4
80002a00:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a02:	98 88       	ld.uh	r8,r12[0x0]
80002a04:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a08:	e0 48 40 00 	cp.w	r8,16384
80002a0c:	c0 d1       	brne	80002a26 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a0e:	49 08       	lddpc	r8,80002a4c <phy_tx+0x50>
80002a10:	70 08       	ld.w	r8,r8[0x0]
80002a12:	58 08       	cp.w	r8,0
80002a14:	c1 a0       	breq	80002a48 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a16:	48 e8       	lddpc	r8,80002a4c <phy_tx+0x50>
80002a18:	70 0c       	ld.w	r12,r8[0x0]
80002a1a:	30 09       	mov	r9,0
80002a1c:	12 9a       	mov	r10,r9
80002a1e:	1a 9b       	mov	r11,sp
80002a20:	f0 1f 00 0c 	mcall	80002a50 <phy_tx+0x54>
80002a24:	c1 28       	rjmp	80002a48 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a26:	e0 48 10 00 	cp.w	r8,4096
80002a2a:	5f 0a       	sreq	r10
80002a2c:	e0 48 20 00 	cp.w	r8,8192
80002a30:	5f 09       	sreq	r9
80002a32:	f5 e9 10 09 	or	r9,r10,r9
80002a36:	c0 71       	brne	80002a44 <phy_tx+0x48>
80002a38:	e0 48 50 00 	cp.w	r8,20480
80002a3c:	c0 40       	breq	80002a44 <phy_tx+0x48>
80002a3e:	e0 48 60 00 	cp.w	r8,24576
80002a42:	c0 31       	brne	80002a48 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a44:	48 48       	lddpc	r8,80002a54 <phy_tx+0x58>
80002a46:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a48:	2f fd       	sub	sp,-4
80002a4a:	d8 02       	popm	pc
80002a4c:	00 00       	add	r0,r0
80002a4e:	0a c4       	st.b	r5++,r4
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	5e 34       	retlo	r4
80002a54:	00 00       	add	r0,r0
80002a56:	0a ac       	st.w	r5++,r12

80002a58 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a58:	d4 01       	pushm	lr
80002a5a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a5c:	30 08       	mov	r8,0
80002a5e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a60:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a62:	1a 9a       	mov	r10,sp
80002a64:	fa cb ff fc 	sub	r11,sp,-4
80002a68:	f0 1f 00 05 	mcall	80002a7c <get_idle_store_isr+0x24>
80002a6c:	58 1c       	cp.w	r12,1
80002a6e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a72:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a76:	2f ed       	sub	sp,-8
80002a78:	d8 02       	popm	pc
80002a7a:	00 00       	add	r0,r0
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	5b 38       	cp.w	r8,-13

80002a80 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a80:	eb cd 40 c0 	pushm	r6-r7,lr
80002a84:	20 1d       	sub	sp,4
80002a86:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a88:	4b a8       	lddpc	r8,80002b70 <phy_tx_func+0xf0>
80002a8a:	70 08       	ld.w	r8,r8[0x0]
80002a8c:	58 08       	cp.w	r8,0
80002a8e:	c6 60       	breq	80002b5a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a90:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a92:	30 08       	mov	r8,0
80002a94:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a96:	4b 88       	lddpc	r8,80002b74 <phy_tx_func+0xf4>
80002a98:	70 08       	ld.w	r8,r8[0x0]
80002a9a:	58 18       	cp.w	r8,1
80002a9c:	c2 60       	breq	80002ae8 <phy_tx_func+0x68>
80002a9e:	c0 43       	brcs	80002aa6 <phy_tx_func+0x26>
80002aa0:	58 28       	cp.w	r8,2
80002aa2:	c5 c1       	brne	80002b5a <phy_tx_func+0xda>
80002aa4:	c5 58       	rjmp	80002b4e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002aa6:	4b 38       	lddpc	r8,80002b70 <phy_tx_func+0xf0>
80002aa8:	70 0c       	ld.w	r12,r8[0x0]
80002aaa:	1a 9a       	mov	r10,sp
80002aac:	4b 3b       	lddpc	r11,80002b78 <phy_tx_func+0xf8>
80002aae:	f0 1f 00 34 	mcall	80002b7c <phy_tx_func+0xfc>
80002ab2:	58 1c       	cp.w	r12,1
80002ab4:	c1 41       	brne	80002adc <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ab6:	4b 18       	lddpc	r8,80002b78 <phy_tx_func+0xf8>
80002ab8:	70 08       	ld.w	r8,r8[0x0]
80002aba:	90 08       	ld.sh	r8,r8[0x0]
80002abc:	10 9a       	mov	r10,r8
80002abe:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002ac2:	4b 09       	lddpc	r9,80002b80 <phy_tx_func+0x100>
80002ac4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ac6:	5c 78       	castu.h	r8
80002ac8:	ea 18 ab cd 	orh	r8,0xabcd
80002acc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ace:	30 19       	mov	r9,1
80002ad0:	4a d8       	lddpc	r8,80002b84 <phy_tx_func+0x104>
80002ad2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ad4:	30 19       	mov	r9,1
80002ad6:	4a 88       	lddpc	r8,80002b74 <phy_tx_func+0xf4>
80002ad8:	91 09       	st.w	r8[0x0],r9
80002ada:	c4 08       	rjmp	80002b5a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002adc:	e0 68 5a 5a 	mov	r8,23130
80002ae0:	ea 18 ab cd 	orh	r8,0xabcd
80002ae4:	8f 18       	st.w	r7[0x4],r8
80002ae6:	c3 a8       	rjmp	80002b5a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ae8:	4a 7a       	lddpc	r10,80002b84 <phy_tx_func+0x104>
80002aea:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002aec:	4a 39       	lddpc	r9,80002b78 <phy_tx_func+0xf8>
80002aee:	72 09       	ld.w	r9,r9[0x0]
80002af0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002af4:	b1 69       	lsl	r9,0x10
80002af6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002af8:	2f f8       	sub	r8,-1
80002afa:	5c 58       	castu.b	r8
80002afc:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002afe:	4a 1b       	lddpc	r11,80002b80 <phy_tx_func+0x100>
80002b00:	96 0c       	ld.sh	r12,r11[0x0]
80002b02:	20 2c       	sub	r12,2
80002b04:	5c 8c       	casts.h	r12
80002b06:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002b0a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b0c:	30 0b       	mov	r11,0
80002b0e:	f6 0a 19 00 	cp.h	r10,r11
80002b12:	e0 89 00 09 	brgt	80002b24 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b16:	e8 19 00 ba 	orl	r9,0xba
80002b1a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b1c:	30 09       	mov	r9,0
80002b1e:	49 68       	lddpc	r8,80002b74 <phy_tx_func+0xf4>
80002b20:	91 09       	st.w	r8[0x0],r9
80002b22:	c1 c8       	rjmp	80002b5a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b24:	49 5a       	lddpc	r10,80002b78 <phy_tx_func+0xf8>
80002b26:	74 0a       	ld.w	r10,r10[0x0]
80002b28:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b2c:	14 49       	or	r9,r10
80002b2e:	8f 19       	st.w	r7[0x4],r9
80002b30:	2f f8       	sub	r8,-1
80002b32:	49 59       	lddpc	r9,80002b84 <phy_tx_func+0x104>
80002b34:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b36:	20 2c       	sub	r12,2
80002b38:	49 28       	lddpc	r8,80002b80 <phy_tx_func+0x100>
80002b3a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b3c:	30 08       	mov	r8,0
80002b3e:	f0 0c 19 00 	cp.h	r12,r8
80002b42:	e0 89 00 0c 	brgt	80002b5a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b46:	30 29       	mov	r9,2
80002b48:	48 b8       	lddpc	r8,80002b74 <phy_tx_func+0xf4>
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c0 78       	rjmp	80002b5a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b4e:	fc 18 00 ba 	movh	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b54:	30 09       	mov	r9,0
80002b56:	48 88       	lddpc	r8,80002b74 <phy_tx_func+0xf4>
80002b58:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b5a:	e0 68 5a 5a 	mov	r8,23130
80002b5e:	ea 18 ab cd 	orh	r8,0xabcd
80002b62:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b64:	30 08       	mov	r8,0
80002b66:	8f 38       	st.w	r7[0xc],r8
}
80002b68:	2f fd       	sub	sp,-4
80002b6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b6e:	00 00       	add	r0,r0
80002b70:	00 00       	add	r0,r0
80002b72:	0a c4       	st.b	r5++,r4
80002b74:	00 00       	add	r0,r0
80002b76:	0a 80       	andn	r0,r5
80002b78:	00 00       	add	r0,r0
80002b7a:	0a cc       	st.b	r5++,r12
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	5b 38       	cp.w	r8,-13
80002b80:	00 00       	add	r0,r0
80002b82:	0a a8       	st.w	r5++,r8
80002b84:	00 00       	add	r0,r0
80002b86:	0a 64       	and	r4,r5

80002b88 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b88:	d4 01       	pushm	lr
80002b8a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b8c:	30 0a       	mov	r10,0
80002b8e:	fa cb ff fc 	sub	r11,sp,-4
80002b92:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b94:	14 99       	mov	r9,r10
80002b96:	1a 9b       	mov	r11,sp
80002b98:	f0 1f 00 05 	mcall	80002bac <get_idle_store+0x24>
80002b9c:	58 1c       	cp.w	r12,1
80002b9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ba2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002ba6:	2f fd       	sub	sp,-4
80002ba8:	d8 02       	popm	pc
80002baa:	00 00       	add	r0,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	5c 28       	cpc	r8

80002bb0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002bb0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002bb2:	48 5b       	lddpc	r11,80002bc4 <phy_init+0x14>
80002bb4:	48 5c       	lddpc	r12,80002bc8 <phy_init+0x18>
80002bb6:	f0 1f 00 06 	mcall	80002bcc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002bba:	f0 1f 00 06 	mcall	80002bd0 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002bbe:	f0 1f 00 06 	mcall	80002bd4 <phy_init+0x24>
	
}
80002bc2:	d8 02       	popm	pc
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	2a 80       	sub	r0,-88
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	2c 38       	sub	r8,-61
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	3c 80       	mov	r0,-56
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	3c 94       	mov	r4,-55
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	46 3c       	lddsp	r12,sp[0x18c]

80002bd8 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bd8:	d4 01       	pushm	lr
80002bda:	20 2d       	sub	sp,8
80002bdc:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bde:	30 08       	mov	r8,0
80002be0:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002be2:	48 f8       	lddpc	r8,80002c1c <payload_rx+0x44>
80002be4:	70 08       	ld.w	r8,r8[0x0]
80002be6:	58 08       	cp.w	r8,0
80002be8:	c0 71       	brne	80002bf6 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bea:	30 4b       	mov	r11,4
80002bec:	30 5c       	mov	r12,5
80002bee:	f0 1f 00 0d 	mcall	80002c20 <payload_rx+0x48>
80002bf2:	48 b8       	lddpc	r8,80002c1c <payload_rx+0x44>
80002bf4:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002bf6:	48 a8       	lddpc	r8,80002c1c <payload_rx+0x44>
80002bf8:	70 0c       	ld.w	r12,r8[0x0]
80002bfa:	30 09       	mov	r9,0
80002bfc:	fa ca ff fc 	sub	r10,sp,-4
80002c00:	1a 9b       	mov	r11,sp
80002c02:	f0 1f 00 09 	mcall	80002c24 <payload_rx+0x4c>
80002c06:	c0 91       	brne	80002c18 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002c08:	48 88       	lddpc	r8,80002c28 <payload_rx+0x50>
80002c0a:	70 0c       	ld.w	r12,r8[0x0]
80002c0c:	40 0b       	lddsp	r11,sp[0x0]
80002c0e:	f0 1f 00 08 	mcall	80002c2c <payload_rx+0x54>
		logFromISR("mm");
80002c12:	48 8c       	lddpc	r12,80002c30 <payload_rx+0x58>
80002c14:	f0 1f 00 08 	mcall	80002c34 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002c18:	2f ed       	sub	sp,-8
80002c1a:	d8 02       	popm	pc
80002c1c:	00 00       	add	r0,r0
80002c1e:	0a 8c       	andn	r12,r5
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	5f 34       	srlo	r4
80002c24:	80 00       	ld.sh	r0,r0[0x0]
80002c26:	5d e4       	*unknown*
80002c28:	00 00       	add	r0,r0
80002c2a:	0a 70       	tst	r0,r5
80002c2c:	80 00       	ld.sh	r0,r0[0x0]
80002c2e:	29 88       	sub	r8,-104
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	d0 f4       	*unknown*
80002c34:	80 00       	ld.sh	r0,r0[0x0]
80002c36:	6b a0       	ld.w	r0,r5[0x68]

80002c38 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c38:	eb cd 40 e0 	pushm	r5-r7,lr
80002c3c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c3e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c42:	70 08       	ld.w	r8,r8[0x0]
80002c44:	58 08       	cp.w	r8,0
80002c46:	e0 80 01 08 	breq	80002e56 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c4a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c4c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c50:	70 09       	ld.w	r9,r8[0x0]
80002c52:	2f f9       	sub	r9,-1
80002c54:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c56:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c5a:	70 08       	ld.w	r8,r8[0x0]
80002c5c:	58 18       	cp.w	r8,1
80002c5e:	e0 80 00 85 	breq	80002d68 <phy_rx_func+0x130>
80002c62:	c0 73       	brcs	80002c70 <phy_rx_func+0x38>
80002c64:	58 28       	cp.w	r8,2
80002c66:	c5 c0       	breq	80002d1e <phy_rx_func+0xe6>
80002c68:	58 38       	cp.w	r8,3
80002c6a:	e0 81 00 f6 	brne	80002e56 <phy_rx_func+0x21e>
80002c6e:	cd 58       	rjmp	80002e18 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c70:	e0 6a 5a 5a 	mov	r10,23130
80002c74:	ea 1a ab cd 	orh	r10,0xabcd
80002c78:	14 36       	cp.w	r6,r10
80002c7a:	e0 80 00 ee 	breq	80002e56 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c7e:	ec 08 16 10 	lsr	r8,r6,0x10
80002c82:	e0 48 ab cd 	cp.w	r8,43981
80002c86:	e0 81 00 e8 	brne	80002e56 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c8a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c8e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c92:	20 28       	sub	r8,2
80002c94:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c98:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c9a:	30 09       	mov	r9,0
80002c9c:	f2 08 19 00 	cp.h	r8,r9
80002ca0:	e0 8a 00 db 	brle	80002e56 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ca4:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002ca8:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002caa:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002cae:	70 0c       	ld.w	r12,r8[0x0]
80002cb0:	f0 1f 03 88 	mcall	80003ad0 <phy_rx_func+0xe98>
80002cb4:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002cb8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002cba:	58 0c       	cp.w	r12,0
80002cbc:	e0 80 00 cd 	breq	80002e56 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002cc0:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cc4:	90 09       	ld.sh	r9,r8[0x0]
80002cc6:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cca:	2f f9       	sub	r9,-1
80002ccc:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cce:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cd2:	74 0a       	ld.w	r10,r10[0x0]
80002cd4:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002cd8:	76 0b       	ld.w	r11,r11[0x0]
80002cda:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cde:	2f f9       	sub	r9,-1
80002ce0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002ce2:	e2 16 0f 00 	andl	r6,0xf00,COH
80002ce6:	e0 46 01 00 	cp.w	r6,256
80002cea:	c0 c0       	breq	80002d02 <phy_rx_func+0xca>
80002cec:	e0 8b 00 05 	brhi	80002cf6 <phy_rx_func+0xbe>
80002cf0:	58 06       	cp.w	r6,0
80002cf2:	c0 80       	breq	80002d02 <phy_rx_func+0xca>
80002cf4:	c0 c8       	rjmp	80002d0c <phy_rx_func+0xd4>
80002cf6:	e0 46 02 00 	cp.w	r6,512
80002cfa:	c0 40       	breq	80002d02 <phy_rx_func+0xca>
80002cfc:	e0 46 03 00 	cp.w	r6,768
80002d00:	c0 61       	brne	80002d0c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002d02:	30 29       	mov	r9,2
80002d04:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002d08:	91 09       	st.w	r8[0x0],r9
80002d0a:	ca 68       	rjmp	80002e56 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002d0c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002d10:	70 0c       	ld.w	r12,r8[0x0]
80002d12:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d16:	70 0b       	ld.w	r11,r8[0x0]
80002d18:	f0 1f 03 70 	mcall	80003ad8 <phy_rx_func+0xea0>
80002d1c:	c9 d8       	rjmp	80002e56 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d1e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d22:	b1 86       	lsr	r6,0x10
80002d24:	14 06       	add	r6,r10
80002d26:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d2a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d2c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d30:	90 09       	ld.sh	r9,r8[0x0]
80002d32:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d36:	76 0b       	ld.w	r11,r11[0x0]
80002d38:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d3c:	2f f9       	sub	r9,-1
80002d3e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d40:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d44:	92 08       	ld.sh	r8,r9[0x0]
80002d46:	20 28       	sub	r8,2
80002d48:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d4a:	30 09       	mov	r9,0
80002d4c:	f2 08 19 00 	cp.h	r8,r9
80002d50:	e0 8a 00 07 	brle	80002d5e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d54:	30 19       	mov	r9,1
80002d56:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d5a:	91 09       	st.w	r8[0x0],r9
80002d5c:	c7 d8       	rjmp	80002e56 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d5e:	30 39       	mov	r9,3
80002d60:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d64:	91 09       	st.w	r8[0x0],r9
80002d66:	c7 88       	rjmp	80002e56 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d68:	ec 0a 14 10 	asr	r10,r6,0x10
80002d6c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d70:	90 09       	ld.sh	r9,r8[0x0]
80002d72:	14 09       	add	r9,r10
80002d74:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d76:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d7a:	92 08       	ld.sh	r8,r9[0x0]
80002d7c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d80:	76 0b       	ld.w	r11,r11[0x0]
80002d82:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d86:	2f f8       	sub	r8,-1
80002d88:	5c 88       	casts.h	r8
80002d8a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d8c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d90:	94 09       	ld.sh	r9,r10[0x0]
80002d92:	20 29       	sub	r9,2
80002d94:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d96:	30 0a       	mov	r10,0
80002d98:	f4 09 19 00 	cp.h	r9,r10
80002d9c:	e0 89 00 20 	brgt	80002ddc <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002da0:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002da4:	e0 46 00 ba 	cp.w	r6,186
80002da8:	c0 d1       	brne	80002dc2 <phy_rx_func+0x18a>
80002daa:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002dae:	90 09       	ld.sh	r9,r8[0x0]
80002db0:	f4 09 19 00 	cp.h	r9,r10
80002db4:	c0 71       	brne	80002dc2 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002db6:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002dba:	70 0c       	ld.w	r12,r8[0x0]
80002dbc:	f0 1f 03 49 	mcall	80003ae0 <phy_rx_func+0xea8>
80002dc0:	c0 98       	rjmp	80002dd2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002dc2:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002dc6:	70 0c       	ld.w	r12,r8[0x0]
80002dc8:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002dcc:	70 0b       	ld.w	r11,r8[0x0]
80002dce:	f0 1f 03 43 	mcall	80003ad8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dd2:	30 09       	mov	r9,0
80002dd4:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dd8:	91 09       	st.w	r8[0x0],r9
80002dda:	c3 e8       	rjmp	80002e56 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002ddc:	5c 86       	casts.h	r6
80002dde:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002de2:	92 0a       	ld.sh	r10,r9[0x0]
80002de4:	0c 0a       	add	r10,r6
80002de6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002de8:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002dec:	72 09       	ld.w	r9,r9[0x0]
80002dee:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002df2:	2f f8       	sub	r8,-1
80002df4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002df8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002dfa:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002dfe:	92 08       	ld.sh	r8,r9[0x0]
80002e00:	20 28       	sub	r8,2
80002e02:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002e04:	30 09       	mov	r9,0
80002e06:	f2 08 19 00 	cp.h	r8,r9
80002e0a:	e0 89 00 26 	brgt	80002e56 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002e0e:	30 39       	mov	r9,3
80002e10:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e14:	91 09       	st.w	r8[0x0],r9
80002e16:	c2 08       	rjmp	80002e56 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e18:	e6 16 00 ff 	andh	r6,0xff,COH
80002e1c:	fc 19 00 ba 	movh	r9,0xba
80002e20:	12 36       	cp.w	r6,r9
80002e22:	c0 e1       	brne	80002e3e <phy_rx_func+0x206>
80002e24:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e28:	90 09       	ld.sh	r9,r8[0x0]
80002e2a:	30 08       	mov	r8,0
80002e2c:	f0 09 19 00 	cp.h	r9,r8
80002e30:	c0 71       	brne	80002e3e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e32:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e36:	70 0c       	ld.w	r12,r8[0x0]
80002e38:	f0 1f 03 2a 	mcall	80003ae0 <phy_rx_func+0xea8>
80002e3c:	c0 98       	rjmp	80002e4e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e3e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e42:	70 0c       	ld.w	r12,r8[0x0]
80002e44:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e48:	70 0b       	ld.w	r11,r8[0x0]
80002e4a:	f0 1f 03 24 	mcall	80003ad8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e4e:	30 09       	mov	r9,0
80002e50:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e54:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e56:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e5a:	11 89       	ld.ub	r9,r8[0x0]
80002e5c:	30 08       	mov	r8,0
80002e5e:	f0 09 18 00 	cp.b	r9,r8
80002e62:	c1 31       	brne	80002e88 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e64:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e68:	6c 0c       	ld.w	r12,r6[0x0]
80002e6a:	f0 1f 03 1a 	mcall	80003ad0 <phy_rx_func+0xe98>
80002e6e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e72:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e74:	6c 0c       	ld.w	r12,r6[0x0]
80002e76:	f0 1f 03 17 	mcall	80003ad0 <phy_rx_func+0xe98>
80002e7a:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e7e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e80:	30 19       	mov	r9,1
80002e82:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e86:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e88:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e8c:	70 08       	ld.w	r8,r8[0x0]
80002e8e:	58 28       	cp.w	r8,2
80002e90:	e0 80 01 98 	breq	800031c0 <phy_rx_func+0x588>
80002e94:	e0 8b 00 06 	brhi	80002ea0 <phy_rx_func+0x268>
80002e98:	58 08       	cp.w	r8,0
80002e9a:	c0 b0       	breq	80002eb0 <phy_rx_func+0x278>
80002e9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ea0:	58 38       	cp.w	r8,3
80002ea2:	e0 80 05 c5 	breq	80003a2c <phy_rx_func+0xdf4>
80002ea6:	58 48       	cp.w	r8,4
80002ea8:	e0 81 06 05 	brne	80003ab2 <phy_rx_func+0xe7a>
80002eac:	e0 8f 02 4b 	bral	80003342 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002eb0:	6e 28       	ld.w	r8,r7[0x8]
80002eb2:	e0 6a 5a 5a 	mov	r10,23130
80002eb6:	ea 1a ab cd 	orh	r10,0xabcd
80002eba:	14 38       	cp.w	r8,r10
80002ebc:	c0 71       	brne	80002eca <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002ebe:	30 09       	mov	r9,0
80002ec0:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002ec4:	91 09       	st.w	r8[0x0],r9
80002ec6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002eca:	10 99       	mov	r9,r8
80002ecc:	e0 19 00 00 	andl	r9,0x0
80002ed0:	fc 1a ab cd 	movh	r10,0xabcd
80002ed4:	14 39       	cp.w	r9,r10
80002ed6:	e0 81 05 ee 	brne	80003ab2 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002eda:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ede:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ee2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ee4:	6e 29       	ld.w	r9,r7[0x8]
80002ee6:	e2 19 f0 00 	andl	r9,0xf000,COH
80002eea:	e0 49 c0 00 	cp.w	r9,49152
80002eee:	e0 81 00 ce 	brne	8000308a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ef2:	30 1a       	mov	r10,1
80002ef4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002ef8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002efa:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002efe:	72 09       	ld.w	r9,r9[0x0]
80002f00:	58 09       	cp.w	r9,0
80002f02:	c0 71       	brne	80002f10 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002f04:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002f08:	f0 1f 03 00 	mcall	80003b08 <phy_rx_func+0xed0>
80002f0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002f10:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f14:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f18:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f1a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f1e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f22:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f26:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f28:	13 89       	ld.ub	r9,r9[0x0]
80002f2a:	37 fa       	mov	r10,127
80002f2c:	f4 09 18 00 	cp.b	r9,r10
80002f30:	c6 d0       	breq	8000300a <phy_rx_func+0x3d2>
80002f32:	e0 8b 00 0c 	brhi	80002f4a <phy_rx_func+0x312>
80002f36:	31 2a       	mov	r10,18
80002f38:	f4 09 18 00 	cp.b	r9,r10
80002f3c:	c4 20       	breq	80002fc0 <phy_rx_func+0x388>
80002f3e:	31 3a       	mov	r10,19
80002f40:	f4 09 18 00 	cp.b	r9,r10
80002f44:	e0 81 00 83 	brne	8000304a <phy_rx_func+0x412>
80002f48:	c5 b8       	rjmp	80002ffe <phy_rx_func+0x3c6>
80002f4a:	2f 09       	sub	r9,-16
80002f4c:	30 1a       	mov	r10,1
80002f4e:	f4 09 18 00 	cp.b	r9,r10
80002f52:	e0 8b 00 7c 	brhi	8000304a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f56:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f5a:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f5e:	59 08       	cp.w	r8,16
80002f60:	c0 71       	brne	80002f6e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f62:	30 19       	mov	r9,1
80002f64:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f68:	91 09       	st.w	r8[0x0],r9
80002f6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f6e:	e0 48 00 20 	cp.w	r8,32
80002f72:	c2 11       	brne	80002fb4 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f74:	30 a9       	mov	r9,10
80002f76:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f7a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f7c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f80:	6c 08       	ld.w	r8,r6[0x0]
80002f82:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f86:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f8a:	2f f8       	sub	r8,-1
80002f8c:	6e 0c       	ld.w	r12,r7[0x0]
80002f8e:	f4 ca fe 00 	sub	r10,r10,-512
80002f92:	30 0b       	mov	r11,0
80002f94:	10 0c       	add	r12,r8
80002f96:	f0 1f 02 e1 	mcall	80003b18 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f9a:	30 08       	mov	r8,0
80002f9c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f9e:	6e 0c       	ld.w	r12,r7[0x0]
80002fa0:	f0 1f 02 df 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002fa4:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002fa8:	70 0c       	ld.w	r12,r8[0x0]
80002faa:	f0 1f 02 ca 	mcall	80003ad0 <phy_rx_func+0xe98>
80002fae:	8f 0c       	st.w	r7[0x0],r12
80002fb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fb4:	30 09       	mov	r9,0
80002fb6:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fba:	91 09       	st.w	r8[0x0],r9
80002fbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fc0:	20 48       	sub	r8,4
80002fc2:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fc6:	93 08       	st.w	r9[0x0],r8
80002fc8:	58 08       	cp.w	r8,0
80002fca:	e0 80 05 74 	breq	80003ab2 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fce:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fd2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fd6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fda:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fdc:	8e 69       	ld.sh	r9,r7[0xc]
80002fde:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fe2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fe4:	8e 79       	ld.sh	r9,r7[0xe]
80002fe6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fe8:	f0 1f 02 d0 	mcall	80003b28 <phy_rx_func+0xef0>
80002fec:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002ff0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002ff2:	30 49       	mov	r9,4
80002ff4:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002ff8:	91 09       	st.w	r8[0x0],r9
80002ffa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002ffe:	30 09       	mov	r9,0
80003000:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003004:	91 09       	st.w	r8[0x0],r9
80003006:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000300a:	20 48       	sub	r8,4
8000300c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003010:	93 08       	st.w	r9[0x0],r8
80003012:	58 08       	cp.w	r8,0
80003014:	e0 80 05 4f 	breq	80003ab2 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003018:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000301c:	70 09       	ld.w	r9,r8[0x0]
8000301e:	8e 7b       	ld.sh	r11,r7[0xe]
80003020:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003024:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003028:	2f f9       	sub	r9,-1
8000302a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000302c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003030:	70 09       	ld.w	r9,r8[0x0]
80003032:	20 29       	sub	r9,2
80003034:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003036:	30 29       	mov	r9,2
80003038:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000303c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000303e:	30 39       	mov	r9,3
80003040:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003044:	91 09       	st.w	r8[0x0],r9
80003046:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000304a:	30 3a       	mov	r10,3
8000304c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003050:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003052:	6e 2a       	ld.w	r10,r7[0x8]
80003054:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003058:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000305a:	6e 3a       	ld.w	r10,r7[0xc]
8000305c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000305e:	59 48       	cp.w	r8,20
80003060:	c0 61       	brne	8000306c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003062:	31 89       	mov	r9,24
80003064:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003068:	91 09       	st.w	r8[0x0],r9
8000306a:	c0 a8       	rjmp	8000307e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000306c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003070:	70 08       	ld.w	r8,r8[0x0]
80003072:	59 08       	cp.w	r8,16
80003074:	c0 51       	brne	8000307e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003076:	31 09       	mov	r9,16
80003078:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000307c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000307e:	30 49       	mov	r9,4
80003080:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003084:	91 09       	st.w	r8[0x0],r9
80003086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000308a:	e0 49 10 00 	cp.w	r9,4096
8000308e:	5f 1a       	srne	r10
80003090:	e0 49 20 00 	cp.w	r9,8192
80003094:	5f 19       	srne	r9
80003096:	f5 e9 00 09 	and	r9,r10,r9
8000309a:	e0 81 05 0c 	brne	80003ab2 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000309e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800030a2:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800030a4:	fe fa 0a 98 	ld.w	r10,pc[2712]
800030a8:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800030aa:	fe fa 0a 62 	ld.w	r10,pc[2658]
800030ae:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800030b0:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030b4:	72 09       	ld.w	r9,r9[0x0]
800030b6:	58 09       	cp.w	r9,0
800030b8:	c0 71       	brne	800030c6 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030ba:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030be:	f0 1f 02 93 	mcall	80003b08 <phy_rx_func+0xed0>
800030c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030c6:	6e 2a       	ld.w	r10,r7[0x8]
800030c8:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030cc:	58 1a       	cp.w	r10,1
800030ce:	e0 8b 00 4d 	brhi	80003168 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030d2:	20 48       	sub	r8,4
800030d4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030d8:	93 08       	st.w	r9[0x0],r8
800030da:	58 08       	cp.w	r8,0
800030dc:	e0 80 04 eb 	breq	80003ab2 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030e0:	8e 68       	ld.sh	r8,r7[0xc]
800030e2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030e6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030ea:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030ec:	30 09       	mov	r9,0
800030ee:	f2 08 19 00 	cp.h	r8,r9
800030f2:	c0 70       	breq	80003100 <phy_rx_func+0x4c8>
800030f4:	30 19       	mov	r9,1
800030f6:	f2 08 19 00 	cp.h	r8,r9
800030fa:	e0 81 04 dc 	brne	80003ab2 <phy_rx_func+0xe7a>
800030fe:	c2 68       	rjmp	8000314a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003100:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003104:	70 0a       	ld.w	r10,r8[0x0]
80003106:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000310a:	72 09       	ld.w	r9,r9[0x0]
8000310c:	8e 7b       	ld.sh	r11,r7[0xe]
8000310e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003112:	70 09       	ld.w	r9,r8[0x0]
80003114:	2f f9       	sub	r9,-1
80003116:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003118:	e0 49 00 ff 	cp.w	r9,255
8000311c:	e0 88 00 11 	brls	8000313e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003120:	30 09       	mov	r9,0
80003122:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003124:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003128:	6e 0c       	ld.w	r12,r7[0x0]
8000312a:	f0 1f 02 7d 	mcall	80003b1c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000312e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003132:	70 0c       	ld.w	r12,r8[0x0]
80003134:	f0 1f 02 67 	mcall	80003ad0 <phy_rx_func+0xe98>
80003138:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000313a:	e0 80 04 bc 	breq	80003ab2 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000313e:	30 29       	mov	r9,2
80003140:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003144:	91 09       	st.w	r8[0x0],r9
80003146:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000314a:	8e 79       	ld.sh	r9,r7[0xe]
8000314c:	30 38       	mov	r8,3
8000314e:	f0 09 19 00 	cp.h	r9,r8
80003152:	c0 51       	brne	8000315c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003154:	30 19       	mov	r9,1
80003156:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000315a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000315c:	30 29       	mov	r9,2
8000315e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003162:	91 09       	st.w	r8[0x0],r9
80003164:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003168:	58 18       	cp.w	r8,1
8000316a:	e0 88 04 a4 	brls	80003ab2 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000316e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003172:	70 0a       	ld.w	r10,r8[0x0]
80003174:	6e 3b       	ld.w	r11,r7[0xc]
80003176:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000317a:	70 09       	ld.w	r9,r8[0x0]
8000317c:	2f f9       	sub	r9,-1
8000317e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003180:	e0 49 00 ff 	cp.w	r9,255
80003184:	e0 88 00 11 	brls	800031a6 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003188:	30 09       	mov	r9,0
8000318a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000318c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003190:	6e 0c       	ld.w	r12,r7[0x0]
80003192:	f0 1f 02 63 	mcall	80003b1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003196:	fe f8 09 52 	ld.w	r8,pc[2386]
8000319a:	70 0c       	ld.w	r12,r8[0x0]
8000319c:	f0 1f 02 4d 	mcall	80003ad0 <phy_rx_func+0xe98>
800031a0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800031a2:	e0 80 04 88 	breq	80003ab2 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800031a6:	fe f9 09 56 	ld.w	r9,pc[2390]
800031aa:	72 08       	ld.w	r8,r9[0x0]
800031ac:	20 28       	sub	r8,2
800031ae:	93 08       	st.w	r9[0x0],r8
800031b0:	e0 80 04 81 	breq	80003ab2 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031b4:	30 29       	mov	r9,2
800031b6:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031ba:	91 09       	st.w	r8[0x0],r9
800031bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031c0:	fe f8 09 84 	ld.w	r8,pc[2436]
800031c4:	70 0a       	ld.w	r10,r8[0x0]
800031c6:	fe f9 09 26 	ld.w	r9,pc[2342]
800031ca:	72 09       	ld.w	r9,r9[0x0]
800031cc:	8e 4b       	ld.sh	r11,r7[0x8]
800031ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031d2:	70 09       	ld.w	r9,r8[0x0]
800031d4:	2f f9       	sub	r9,-1
800031d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031d8:	e0 49 00 ff 	cp.w	r9,255
800031dc:	e0 88 00 16 	brls	80003208 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031e0:	30 09       	mov	r9,0
800031e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031e4:	fe f6 09 08 	ld.w	r6,pc[2312]
800031e8:	6c 0c       	ld.w	r12,r6[0x0]
800031ea:	f0 1f 02 4d 	mcall	80003b1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031ee:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031f2:	70 0c       	ld.w	r12,r8[0x0]
800031f4:	f0 1f 02 37 	mcall	80003ad0 <phy_rx_func+0xe98>
800031f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031fa:	c0 71       	brne	80003208 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031fc:	30 09       	mov	r9,0
800031fe:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003202:	91 09       	st.w	r8[0x0],r9
80003204:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003208:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000320c:	72 08       	ld.w	r8,r9[0x0]
8000320e:	20 28       	sub	r8,2
80003210:	93 08       	st.w	r9[0x0],r8
80003212:	c0 71       	brne	80003220 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003214:	30 09       	mov	r9,0
80003216:	fe f8 08 de 	ld.w	r8,pc[2270]
8000321a:	91 09       	st.w	r8[0x0],r9
8000321c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003220:	fe f8 09 24 	ld.w	r8,pc[2340]
80003224:	70 0a       	ld.w	r10,r8[0x0]
80003226:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000322a:	72 09       	ld.w	r9,r9[0x0]
8000322c:	8e 5b       	ld.sh	r11,r7[0xa]
8000322e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003232:	70 09       	ld.w	r9,r8[0x0]
80003234:	2f f9       	sub	r9,-1
80003236:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003238:	e0 49 00 ff 	cp.w	r9,255
8000323c:	e0 88 00 16 	brls	80003268 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003240:	30 09       	mov	r9,0
80003242:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003244:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003248:	6c 0c       	ld.w	r12,r6[0x0]
8000324a:	f0 1f 02 35 	mcall	80003b1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000324e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003252:	70 0c       	ld.w	r12,r8[0x0]
80003254:	f0 1f 02 1f 	mcall	80003ad0 <phy_rx_func+0xe98>
80003258:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000325a:	c0 71       	brne	80003268 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000325c:	30 09       	mov	r9,0
8000325e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003262:	91 09       	st.w	r8[0x0],r9
80003264:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003268:	fe f9 08 94 	ld.w	r9,pc[2196]
8000326c:	72 08       	ld.w	r8,r9[0x0]
8000326e:	20 28       	sub	r8,2
80003270:	93 08       	st.w	r9[0x0],r8
80003272:	c0 71       	brne	80003280 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003274:	30 09       	mov	r9,0
80003276:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000327a:	91 09       	st.w	r8[0x0],r9
8000327c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003280:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003284:	70 0a       	ld.w	r10,r8[0x0]
80003286:	fe f9 08 66 	ld.w	r9,pc[2150]
8000328a:	72 09       	ld.w	r9,r9[0x0]
8000328c:	8e 6b       	ld.sh	r11,r7[0xc]
8000328e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003292:	70 09       	ld.w	r9,r8[0x0]
80003294:	2f f9       	sub	r9,-1
80003296:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003298:	e0 49 00 ff 	cp.w	r9,255
8000329c:	e0 88 00 16 	brls	800032c8 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800032a0:	30 09       	mov	r9,0
800032a2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032a4:	fe f6 08 48 	ld.w	r6,pc[2120]
800032a8:	6c 0c       	ld.w	r12,r6[0x0]
800032aa:	f0 1f 02 1d 	mcall	80003b1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032ae:	fe f8 08 3a 	ld.w	r8,pc[2106]
800032b2:	70 0c       	ld.w	r12,r8[0x0]
800032b4:	f0 1f 02 07 	mcall	80003ad0 <phy_rx_func+0xe98>
800032b8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032ba:	c0 71       	brne	800032c8 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032bc:	30 09       	mov	r9,0
800032be:	fe f8 08 36 	ld.w	r8,pc[2102]
800032c2:	91 09       	st.w	r8[0x0],r9
800032c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032c8:	fe f9 08 34 	ld.w	r9,pc[2100]
800032cc:	72 08       	ld.w	r8,r9[0x0]
800032ce:	20 28       	sub	r8,2
800032d0:	93 08       	st.w	r9[0x0],r8
800032d2:	c0 71       	brne	800032e0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032d4:	30 09       	mov	r9,0
800032d6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032da:	91 09       	st.w	r8[0x0],r9
800032dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032e0:	fe f8 08 64 	ld.w	r8,pc[2148]
800032e4:	70 0a       	ld.w	r10,r8[0x0]
800032e6:	fe f9 08 06 	ld.w	r9,pc[2054]
800032ea:	72 09       	ld.w	r9,r9[0x0]
800032ec:	8e 7b       	ld.sh	r11,r7[0xe]
800032ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032f2:	70 09       	ld.w	r9,r8[0x0]
800032f4:	2f f9       	sub	r9,-1
800032f6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032f8:	e0 49 00 ff 	cp.w	r9,255
800032fc:	e0 88 00 16 	brls	80003328 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003300:	30 09       	mov	r9,0
80003302:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003304:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003308:	6e 0c       	ld.w	r12,r7[0x0]
8000330a:	f0 1f 02 05 	mcall	80003b1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000330e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003312:	70 0c       	ld.w	r12,r8[0x0]
80003314:	f0 1f 01 ef 	mcall	80003ad0 <phy_rx_func+0xe98>
80003318:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000331a:	c0 71       	brne	80003328 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000331c:	30 09       	mov	r9,0
8000331e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003322:	91 09       	st.w	r8[0x0],r9
80003324:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003328:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000332c:	72 08       	ld.w	r8,r9[0x0]
8000332e:	20 28       	sub	r8,2
80003330:	93 08       	st.w	r9[0x0],r8
80003332:	e0 81 03 c0 	brne	80003ab2 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003336:	30 09       	mov	r9,0
80003338:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000333c:	91 09       	st.w	r8[0x0],r9
8000333e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003342:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003346:	11 89       	ld.ub	r9,r8[0x0]
80003348:	31 28       	mov	r8,18
8000334a:	f0 09 18 00 	cp.b	r9,r8
8000334e:	e0 81 01 4c 	brne	800035e6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003352:	ef 39 00 09 	ld.ub	r9,r7[9]
80003356:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000335a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000335c:	11 89       	ld.ub	r9,r8[0x0]
8000335e:	3f 28       	mov	r8,-14
80003360:	f0 09 18 00 	cp.b	r9,r8
80003364:	e0 81 01 3b 	brne	800035da <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003368:	30 19       	mov	r9,1
8000336a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000336e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003370:	6e 29       	ld.w	r9,r7[0x8]
80003372:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003376:	fe f8 07 86 	ld.w	r8,pc[1926]
8000337a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000337c:	8e 59       	ld.sh	r9,r7[0xa]
8000337e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003382:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003384:	8e 69       	ld.sh	r9,r7[0xc]
80003386:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003388:	8e 79       	ld.sh	r9,r7[0xe]
8000338a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000338c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003390:	fe f9 07 60 	ld.w	r9,pc[1888]
80003394:	72 0a       	ld.w	r10,r9[0x0]
80003396:	70 09       	ld.w	r9,r8[0x0]
80003398:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000339c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033a0:	70 09       	ld.w	r9,r8[0x0]
800033a2:	2f f9       	sub	r9,-1
800033a4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033a6:	e0 49 01 ff 	cp.w	r9,511
800033aa:	e0 88 00 16 	brls	800033d6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800033ae:	30 09       	mov	r9,0
800033b0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033b2:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033b6:	6c 0c       	ld.w	r12,r6[0x0]
800033b8:	f0 1f 01 d9 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033bc:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033c0:	70 0c       	ld.w	r12,r8[0x0]
800033c2:	f0 1f 01 c4 	mcall	80003ad0 <phy_rx_func+0xe98>
800033c6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033c8:	c0 71       	brne	800033d6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033ca:	30 09       	mov	r9,0
800033cc:	fe f8 07 28 	ld.w	r8,pc[1832]
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033d6:	fe f9 07 26 	ld.w	r9,pc[1830]
800033da:	72 08       	ld.w	r8,r9[0x0]
800033dc:	20 18       	sub	r8,1
800033de:	93 08       	st.w	r9[0x0],r8
800033e0:	c0 71       	brne	800033ee <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033e2:	30 09       	mov	r9,0
800033e4:	fe f8 07 10 	ld.w	r8,pc[1808]
800033e8:	91 09       	st.w	r8[0x0],r9
800033ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033ee:	fe f8 07 26 	ld.w	r8,pc[1830]
800033f2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033f6:	72 0a       	ld.w	r10,r9[0x0]
800033f8:	70 09       	ld.w	r9,r8[0x0]
800033fa:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033fe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003402:	70 09       	ld.w	r9,r8[0x0]
80003404:	2f f9       	sub	r9,-1
80003406:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003408:	e0 49 01 ff 	cp.w	r9,511
8000340c:	e0 88 00 16 	brls	80003438 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003410:	30 09       	mov	r9,0
80003412:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003414:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003418:	6c 0c       	ld.w	r12,r6[0x0]
8000341a:	f0 1f 01 c1 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000341e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003422:	70 0c       	ld.w	r12,r8[0x0]
80003424:	f0 1f 01 ab 	mcall	80003ad0 <phy_rx_func+0xe98>
80003428:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000342a:	c0 71       	brne	80003438 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
8000342c:	30 09       	mov	r9,0
8000342e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003438:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000343c:	72 08       	ld.w	r8,r9[0x0]
8000343e:	20 18       	sub	r8,1
80003440:	93 08       	st.w	r9[0x0],r8
80003442:	c0 71       	brne	80003450 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003444:	30 09       	mov	r9,0
80003446:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000344a:	91 09       	st.w	r8[0x0],r9
8000344c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003450:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003454:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003458:	72 0a       	ld.w	r10,r9[0x0]
8000345a:	70 09       	ld.w	r9,r8[0x0]
8000345c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003460:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003464:	70 09       	ld.w	r9,r8[0x0]
80003466:	2f f9       	sub	r9,-1
80003468:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000346a:	e0 49 01 ff 	cp.w	r9,511
8000346e:	e0 88 00 16 	brls	8000349a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003472:	30 09       	mov	r9,0
80003474:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003476:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000347a:	6c 0c       	ld.w	r12,r6[0x0]
8000347c:	f0 1f 01 a8 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003480:	fe f8 06 68 	ld.w	r8,pc[1640]
80003484:	70 0c       	ld.w	r12,r8[0x0]
80003486:	f0 1f 01 93 	mcall	80003ad0 <phy_rx_func+0xe98>
8000348a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000348c:	c0 71       	brne	8000349a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000348e:	30 09       	mov	r9,0
80003490:	fe f8 06 64 	ld.w	r8,pc[1636]
80003494:	91 09       	st.w	r8[0x0],r9
80003496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000349a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000349e:	72 08       	ld.w	r8,r9[0x0]
800034a0:	20 18       	sub	r8,1
800034a2:	93 08       	st.w	r9[0x0],r8
800034a4:	c0 71       	brne	800034b2 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800034a6:	30 09       	mov	r9,0
800034a8:	fe f8 06 4c 	ld.w	r8,pc[1612]
800034ac:	91 09       	st.w	r8[0x0],r9
800034ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800034b2:	fe f8 06 62 	ld.w	r8,pc[1634]
800034b6:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034ba:	72 0a       	ld.w	r10,r9[0x0]
800034bc:	70 09       	ld.w	r9,r8[0x0]
800034be:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034c2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034c6:	70 09       	ld.w	r9,r8[0x0]
800034c8:	2f f9       	sub	r9,-1
800034ca:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034cc:	e0 49 01 ff 	cp.w	r9,511
800034d0:	e0 88 00 16 	brls	800034fc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034d4:	30 09       	mov	r9,0
800034d6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034d8:	fe f6 06 18 	ld.w	r6,pc[1560]
800034dc:	6c 0c       	ld.w	r12,r6[0x0]
800034de:	f0 1f 01 90 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034e2:	fe f8 06 06 	ld.w	r8,pc[1542]
800034e6:	70 0c       	ld.w	r12,r8[0x0]
800034e8:	f0 1f 01 7a 	mcall	80003ad0 <phy_rx_func+0xe98>
800034ec:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034ee:	c0 71       	brne	800034fc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034f0:	30 09       	mov	r9,0
800034f2:	fe f8 06 02 	ld.w	r8,pc[1538]
800034f6:	91 09       	st.w	r8[0x0],r9
800034f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034fc:	fe f9 06 00 	ld.w	r9,pc[1536]
80003500:	72 08       	ld.w	r8,r9[0x0]
80003502:	20 18       	sub	r8,1
80003504:	93 08       	st.w	r9[0x0],r8
80003506:	c0 71       	brne	80003514 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003508:	30 09       	mov	r9,0
8000350a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000350e:	91 09       	st.w	r8[0x0],r9
80003510:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003514:	fe f8 06 00 	ld.w	r8,pc[1536]
80003518:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000351c:	72 0a       	ld.w	r10,r9[0x0]
8000351e:	70 09       	ld.w	r9,r8[0x0]
80003520:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003524:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003528:	70 09       	ld.w	r9,r8[0x0]
8000352a:	2f f9       	sub	r9,-1
8000352c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000352e:	e0 49 01 ff 	cp.w	r9,511
80003532:	e0 88 00 16 	brls	8000355e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003536:	30 09       	mov	r9,0
80003538:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000353a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000353e:	6c 0c       	ld.w	r12,r6[0x0]
80003540:	f0 1f 01 77 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003544:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003548:	70 0c       	ld.w	r12,r8[0x0]
8000354a:	f0 1f 01 62 	mcall	80003ad0 <phy_rx_func+0xe98>
8000354e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003550:	c0 71       	brne	8000355e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003552:	30 09       	mov	r9,0
80003554:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003558:	91 09       	st.w	r8[0x0],r9
8000355a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000355e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003562:	72 08       	ld.w	r8,r9[0x0]
80003564:	20 18       	sub	r8,1
80003566:	93 08       	st.w	r9[0x0],r8
80003568:	c0 71       	brne	80003576 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000356a:	30 09       	mov	r9,0
8000356c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003570:	91 09       	st.w	r8[0x0],r9
80003572:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003576:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000357a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000357e:	72 0a       	ld.w	r10,r9[0x0]
80003580:	70 09       	ld.w	r9,r8[0x0]
80003582:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003586:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000358a:	70 09       	ld.w	r9,r8[0x0]
8000358c:	2f f9       	sub	r9,-1
8000358e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003590:	e0 49 01 ff 	cp.w	r9,511
80003594:	e0 88 00 16 	brls	800035c0 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003598:	30 09       	mov	r9,0
8000359a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000359c:	fe f7 05 54 	ld.w	r7,pc[1364]
800035a0:	6e 0c       	ld.w	r12,r7[0x0]
800035a2:	f0 1f 01 5f 	mcall	80003b1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035a6:	fe f8 05 42 	ld.w	r8,pc[1346]
800035aa:	70 0c       	ld.w	r12,r8[0x0]
800035ac:	f0 1f 01 49 	mcall	80003ad0 <phy_rx_func+0xe98>
800035b0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035b2:	c0 71       	brne	800035c0 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035b4:	30 09       	mov	r9,0
800035b6:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035ba:	91 09       	st.w	r8[0x0],r9
800035bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035c0:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035c4:	72 08       	ld.w	r8,r9[0x0]
800035c6:	20 18       	sub	r8,1
800035c8:	93 08       	st.w	r9[0x0],r8
800035ca:	e0 81 02 74 	brne	80003ab2 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035ce:	30 09       	mov	r9,0
800035d0:	fe f8 05 24 	ld.w	r8,pc[1316]
800035d4:	91 09       	st.w	r8[0x0],r9
800035d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035da:	30 09       	mov	r9,0
800035dc:	fe f8 05 18 	ld.w	r8,pc[1304]
800035e0:	91 09       	st.w	r8[0x0],r9
800035e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035e6:	fe f8 05 26 	ld.w	r8,pc[1318]
800035ea:	11 89       	ld.ub	r9,r8[0x0]
800035ec:	3f 28       	mov	r8,-14
800035ee:	f0 09 18 00 	cp.b	r9,r8
800035f2:	c4 31       	brne	80003678 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035f4:	8e 49       	ld.sh	r9,r7[0x8]
800035f6:	fe f8 05 56 	ld.w	r8,pc[1366]
800035fa:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035fc:	fe f8 05 18 	ld.w	r8,pc[1304]
80003600:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003604:	72 0a       	ld.w	r10,r9[0x0]
80003606:	70 09       	ld.w	r9,r8[0x0]
80003608:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000360c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003610:	70 09       	ld.w	r9,r8[0x0]
80003612:	2f f9       	sub	r9,-1
80003614:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003616:	e0 49 01 ff 	cp.w	r9,511
8000361a:	e0 88 00 16 	brls	80003646 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000361e:	30 09       	mov	r9,0
80003620:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003622:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003626:	6e 0c       	ld.w	r12,r7[0x0]
80003628:	f0 1f 01 3d 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000362c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003630:	70 0c       	ld.w	r12,r8[0x0]
80003632:	f0 1f 01 28 	mcall	80003ad0 <phy_rx_func+0xe98>
80003636:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003638:	c0 71       	brne	80003646 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000363a:	30 09       	mov	r9,0
8000363c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003640:	91 09       	st.w	r8[0x0],r9
80003642:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003646:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000364a:	72 08       	ld.w	r8,r9[0x0]
8000364c:	20 18       	sub	r8,1
8000364e:	93 08       	st.w	r9[0x0],r8
80003650:	c0 71       	brne	8000365e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003652:	30 09       	mov	r9,0
80003654:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003658:	91 09       	st.w	r8[0x0],r9
8000365a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000365e:	20 18       	sub	r8,1
80003660:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003664:	93 08       	st.w	r9[0x0],r8
80003666:	58 08       	cp.w	r8,0
80003668:	e0 81 02 25 	brne	80003ab2 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000366c:	30 09       	mov	r9,0
8000366e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003678:	fe f8 04 94 	ld.w	r8,pc[1172]
8000367c:	11 89       	ld.ub	r9,r8[0x0]
8000367e:	3f 38       	mov	r8,-13
80003680:	f0 09 18 00 	cp.b	r9,r8
80003684:	e0 81 01 0c 	brne	8000389c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003688:	8e 49       	ld.sh	r9,r7[0x8]
8000368a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000368e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003690:	8e 59       	ld.sh	r9,r7[0xa]
80003692:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003694:	8e 69       	ld.sh	r9,r7[0xc]
80003696:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003698:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000369c:	fe f9 04 54 	ld.w	r9,pc[1108]
800036a0:	72 0a       	ld.w	r10,r9[0x0]
800036a2:	70 09       	ld.w	r9,r8[0x0]
800036a4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036a8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036ac:	70 09       	ld.w	r9,r8[0x0]
800036ae:	2f f9       	sub	r9,-1
800036b0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036b2:	e0 49 01 ff 	cp.w	r9,511
800036b6:	e0 88 00 16 	brls	800036e2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036ba:	30 09       	mov	r9,0
800036bc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036be:	fe f6 04 32 	ld.w	r6,pc[1074]
800036c2:	6c 0c       	ld.w	r12,r6[0x0]
800036c4:	f0 1f 01 16 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036c8:	fe f8 04 20 	ld.w	r8,pc[1056]
800036cc:	70 0c       	ld.w	r12,r8[0x0]
800036ce:	f0 1f 01 01 	mcall	80003ad0 <phy_rx_func+0xe98>
800036d2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036d4:	c0 71       	brne	800036e2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036d6:	30 09       	mov	r9,0
800036d8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036dc:	91 09       	st.w	r8[0x0],r9
800036de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036e2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036e6:	72 08       	ld.w	r8,r9[0x0]
800036e8:	20 18       	sub	r8,1
800036ea:	93 08       	st.w	r9[0x0],r8
800036ec:	c0 71       	brne	800036fa <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036ee:	30 09       	mov	r9,0
800036f0:	fe f8 04 04 	ld.w	r8,pc[1028]
800036f4:	91 09       	st.w	r8[0x0],r9
800036f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036fa:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036fe:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003702:	72 0a       	ld.w	r10,r9[0x0]
80003704:	70 09       	ld.w	r9,r8[0x0]
80003706:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000370a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000370e:	70 09       	ld.w	r9,r8[0x0]
80003710:	2f f9       	sub	r9,-1
80003712:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003714:	e0 49 01 ff 	cp.w	r9,511
80003718:	e0 88 00 16 	brls	80003744 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000371c:	30 09       	mov	r9,0
8000371e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003720:	fe f6 03 d0 	ld.w	r6,pc[976]
80003724:	6c 0c       	ld.w	r12,r6[0x0]
80003726:	f0 1f 00 fe 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000372a:	fe f8 03 be 	ld.w	r8,pc[958]
8000372e:	70 0c       	ld.w	r12,r8[0x0]
80003730:	f0 1f 00 e8 	mcall	80003ad0 <phy_rx_func+0xe98>
80003734:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003736:	c0 71       	brne	80003744 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003738:	30 09       	mov	r9,0
8000373a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000373e:	91 09       	st.w	r8[0x0],r9
80003740:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003744:	fe f9 03 b8 	ld.w	r9,pc[952]
80003748:	72 08       	ld.w	r8,r9[0x0]
8000374a:	20 18       	sub	r8,1
8000374c:	93 08       	st.w	r9[0x0],r8
8000374e:	c0 71       	brne	8000375c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003750:	30 09       	mov	r9,0
80003752:	fe f8 03 a2 	ld.w	r8,pc[930]
80003756:	91 09       	st.w	r8[0x0],r9
80003758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000375c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003760:	fe f9 03 90 	ld.w	r9,pc[912]
80003764:	72 0a       	ld.w	r10,r9[0x0]
80003766:	70 09       	ld.w	r9,r8[0x0]
80003768:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000376c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003770:	70 09       	ld.w	r9,r8[0x0]
80003772:	2f f9       	sub	r9,-1
80003774:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003776:	e0 49 01 ff 	cp.w	r9,511
8000377a:	e0 88 00 16 	brls	800037a6 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000377e:	30 09       	mov	r9,0
80003780:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003782:	fe f6 03 6e 	ld.w	r6,pc[878]
80003786:	6c 0c       	ld.w	r12,r6[0x0]
80003788:	f0 1f 00 e5 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000378c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003790:	70 0c       	ld.w	r12,r8[0x0]
80003792:	f0 1f 00 d0 	mcall	80003ad0 <phy_rx_func+0xe98>
80003796:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003798:	c0 71       	brne	800037a6 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000379a:	30 09       	mov	r9,0
8000379c:	fe f8 03 58 	ld.w	r8,pc[856]
800037a0:	91 09       	st.w	r8[0x0],r9
800037a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037a6:	fe f9 03 56 	ld.w	r9,pc[854]
800037aa:	72 08       	ld.w	r8,r9[0x0]
800037ac:	20 18       	sub	r8,1
800037ae:	93 08       	st.w	r9[0x0],r8
800037b0:	c0 71       	brne	800037be <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800037b2:	30 09       	mov	r9,0
800037b4:	fe f8 03 40 	ld.w	r8,pc[832]
800037b8:	91 09       	st.w	r8[0x0],r9
800037ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037be:	fe f8 03 56 	ld.w	r8,pc[854]
800037c2:	fe f9 03 2e 	ld.w	r9,pc[814]
800037c6:	72 0a       	ld.w	r10,r9[0x0]
800037c8:	70 09       	ld.w	r9,r8[0x0]
800037ca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037ce:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037d2:	70 09       	ld.w	r9,r8[0x0]
800037d4:	2f f9       	sub	r9,-1
800037d6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037d8:	e0 49 01 ff 	cp.w	r9,511
800037dc:	e0 88 00 16 	brls	80003808 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037e0:	30 09       	mov	r9,0
800037e2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037e4:	fe f6 03 0c 	ld.w	r6,pc[780]
800037e8:	6c 0c       	ld.w	r12,r6[0x0]
800037ea:	f0 1f 00 cd 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037ee:	fe f8 02 fa 	ld.w	r8,pc[762]
800037f2:	70 0c       	ld.w	r12,r8[0x0]
800037f4:	f0 1f 00 b7 	mcall	80003ad0 <phy_rx_func+0xe98>
800037f8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037fa:	c0 71       	brne	80003808 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037fc:	30 09       	mov	r9,0
800037fe:	fe f8 02 f6 	ld.w	r8,pc[758]
80003802:	91 09       	st.w	r8[0x0],r9
80003804:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003808:	fe f9 02 f4 	ld.w	r9,pc[756]
8000380c:	72 08       	ld.w	r8,r9[0x0]
8000380e:	20 18       	sub	r8,1
80003810:	93 08       	st.w	r9[0x0],r8
80003812:	c0 71       	brne	80003820 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003814:	30 09       	mov	r9,0
80003816:	fe f8 02 de 	ld.w	r8,pc[734]
8000381a:	91 09       	st.w	r8[0x0],r9
8000381c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003820:	fe f8 02 f4 	ld.w	r8,pc[756]
80003824:	fe f9 02 cc 	ld.w	r9,pc[716]
80003828:	72 0a       	ld.w	r10,r9[0x0]
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003830:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003834:	70 09       	ld.w	r9,r8[0x0]
80003836:	2f f9       	sub	r9,-1
80003838:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000383a:	e0 49 01 ff 	cp.w	r9,511
8000383e:	e0 88 00 16 	brls	8000386a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003842:	30 09       	mov	r9,0
80003844:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003846:	fe f7 02 aa 	ld.w	r7,pc[682]
8000384a:	6e 0c       	ld.w	r12,r7[0x0]
8000384c:	f0 1f 00 b4 	mcall	80003b1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003850:	fe f8 02 98 	ld.w	r8,pc[664]
80003854:	70 0c       	ld.w	r12,r8[0x0]
80003856:	f0 1f 00 9f 	mcall	80003ad0 <phy_rx_func+0xe98>
8000385a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000385c:	c0 71       	brne	8000386a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000385e:	30 09       	mov	r9,0
80003860:	fe f8 02 94 	ld.w	r8,pc[660]
80003864:	91 09       	st.w	r8[0x0],r9
80003866:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000386a:	fe f9 02 92 	ld.w	r9,pc[658]
8000386e:	72 08       	ld.w	r8,r9[0x0]
80003870:	20 18       	sub	r8,1
80003872:	93 08       	st.w	r9[0x0],r8
80003874:	c0 71       	brne	80003882 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003876:	30 09       	mov	r9,0
80003878:	fe f8 02 7c 	ld.w	r8,pc[636]
8000387c:	91 09       	st.w	r8[0x0],r9
8000387e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003882:	20 18       	sub	r8,1
80003884:	fe f9 02 78 	ld.w	r9,pc[632]
80003888:	93 08       	st.w	r9[0x0],r8
8000388a:	58 08       	cp.w	r8,0
8000388c:	e0 81 01 13 	brne	80003ab2 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003890:	30 09       	mov	r9,0
80003892:	fe f8 02 62 	ld.w	r8,pc[610]
80003896:	91 09       	st.w	r8[0x0],r9
80003898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000389c:	fe f8 02 70 	ld.w	r8,pc[624]
800038a0:	11 89       	ld.ub	r9,r8[0x0]
800038a2:	30 48       	mov	r8,4
800038a4:	f0 09 18 00 	cp.b	r9,r8
800038a8:	c0 80       	breq	800038b8 <phy_rx_func+0xc80>
800038aa:	fe f8 02 62 	ld.w	r8,pc[610]
800038ae:	11 89       	ld.ub	r9,r8[0x0]
800038b0:	30 38       	mov	r8,3
800038b2:	f0 09 18 00 	cp.b	r9,r8
800038b6:	c1 41       	brne	800038de <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038b8:	6e 29       	ld.w	r9,r7[0x8]
800038ba:	fe f8 02 7a 	ld.w	r8,pc[634]
800038be:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038c0:	6e 39       	ld.w	r9,r7[0xc]
800038c2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038c4:	fe f9 02 38 	ld.w	r9,pc[568]
800038c8:	72 08       	ld.w	r8,r9[0x0]
800038ca:	20 88       	sub	r8,8
800038cc:	93 08       	st.w	r9[0x0],r8
800038ce:	e0 81 00 f2 	brne	80003ab2 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038d2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038d4:	fe f9 02 20 	ld.w	r9,pc[544]
800038d8:	93 08       	st.w	r9[0x0],r8
800038da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038de:	fe f8 02 2e 	ld.w	r8,pc[558]
800038e2:	11 89       	ld.ub	r9,r8[0x0]
800038e4:	31 38       	mov	r8,19
800038e6:	f0 09 18 00 	cp.b	r9,r8
800038ea:	e0 81 00 9c 	brne	80003a22 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038ee:	fe f8 02 62 	ld.w	r8,pc[610]
800038f2:	11 88       	ld.ub	r8,r8[0x0]
800038f4:	30 c9       	mov	r9,12
800038f6:	f2 08 18 00 	cp.b	r8,r9
800038fa:	e0 81 00 7b 	brne	800039f0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038fe:	8e 49       	ld.sh	r9,r7[0x8]
80003900:	fe f8 02 54 	ld.w	r8,pc[596]
80003904:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003908:	30 09       	mov	r9,0
8000390a:	fe f8 02 46 	ld.w	r8,pc[582]
8000390e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003910:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003914:	3f 38       	mov	r8,-13
80003916:	f0 09 18 00 	cp.b	r9,r8
8000391a:	c6 61       	brne	800039e6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
8000391c:	10 99       	mov	r9,r8
8000391e:	4f c8       	lddpc	r8,80003b0c <phy_rx_func+0xed4>
80003920:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003922:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003926:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000392a:	4f 58       	lddpc	r8,80003afc <phy_rx_func+0xec4>
8000392c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000392e:	30 19       	mov	r9,1
80003930:	fe f8 02 0c 	ld.w	r8,pc[524]
80003934:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003936:	8e 79       	ld.sh	r9,r7[0xe]
80003938:	fe f8 02 14 	ld.w	r8,pc[532]
8000393c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000393e:	4f 68       	lddpc	r8,80003b14 <phy_rx_func+0xedc>
80003940:	4e c9       	lddpc	r9,80003af0 <phy_rx_func+0xeb8>
80003942:	72 0a       	ld.w	r10,r9[0x0]
80003944:	70 09       	ld.w	r9,r8[0x0]
80003946:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000394a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000394e:	70 09       	ld.w	r9,r8[0x0]
80003950:	2f f9       	sub	r9,-1
80003952:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003954:	e0 49 01 ff 	cp.w	r9,511
80003958:	e0 88 00 13 	brls	8000397e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
8000395c:	30 09       	mov	r9,0
8000395e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003960:	4e 46       	lddpc	r6,80003af0 <phy_rx_func+0xeb8>
80003962:	6c 0c       	ld.w	r12,r6[0x0]
80003964:	f0 1f 00 6e 	mcall	80003b1c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003968:	4e 08       	lddpc	r8,80003ae8 <phy_rx_func+0xeb0>
8000396a:	70 0c       	ld.w	r12,r8[0x0]
8000396c:	f0 1f 00 59 	mcall	80003ad0 <phy_rx_func+0xe98>
80003970:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003972:	c0 61       	brne	8000397e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003974:	30 09       	mov	r9,0
80003976:	4e 08       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
80003978:	91 09       	st.w	r8[0x0],r9
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000397e:	4e 09       	lddpc	r9,80003afc <phy_rx_func+0xec4>
80003980:	72 08       	ld.w	r8,r9[0x0]
80003982:	20 18       	sub	r8,1
80003984:	93 08       	st.w	r9[0x0],r8
80003986:	c0 61       	brne	80003992 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003988:	30 09       	mov	r9,0
8000398a:	4d b8       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
8000398c:	91 09       	st.w	r8[0x0],r9
8000398e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003992:	4e 18       	lddpc	r8,80003b14 <phy_rx_func+0xedc>
80003994:	4d 79       	lddpc	r9,80003af0 <phy_rx_func+0xeb8>
80003996:	72 0a       	ld.w	r10,r9[0x0]
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000399e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039a2:	70 09       	ld.w	r9,r8[0x0]
800039a4:	2f f9       	sub	r9,-1
800039a6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039a8:	e0 49 01 ff 	cp.w	r9,511
800039ac:	e0 88 00 13 	brls	800039d2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800039b0:	30 09       	mov	r9,0
800039b2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039b4:	4c f7       	lddpc	r7,80003af0 <phy_rx_func+0xeb8>
800039b6:	6e 0c       	ld.w	r12,r7[0x0]
800039b8:	f0 1f 00 59 	mcall	80003b1c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039bc:	4c b8       	lddpc	r8,80003ae8 <phy_rx_func+0xeb0>
800039be:	70 0c       	ld.w	r12,r8[0x0]
800039c0:	f0 1f 00 44 	mcall	80003ad0 <phy_rx_func+0xe98>
800039c4:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039c6:	c0 61       	brne	800039d2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039c8:	30 09       	mov	r9,0
800039ca:	4c b8       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
800039cc:	91 09       	st.w	r8[0x0],r9
800039ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039d2:	4c b9       	lddpc	r9,80003afc <phy_rx_func+0xec4>
800039d4:	72 08       	ld.w	r8,r9[0x0]
800039d6:	20 18       	sub	r8,1
800039d8:	93 08       	st.w	r9[0x0],r8
800039da:	c6 c1       	brne	80003ab2 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	4c 68       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039e6:	30 09       	mov	r9,0
800039e8:	4c 38       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039f0:	8e 4a       	ld.sh	r10,r7[0x8]
800039f2:	4d 99       	lddpc	r9,80003b54 <phy_rx_func+0xf1c>
800039f4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039f8:	4d 6a       	lddpc	r10,80003b50 <phy_rx_func+0xf18>
800039fa:	15 88       	ld.ub	r8,r10[0x0]
800039fc:	f0 cb ff ff 	sub	r11,r8,-1
80003a00:	8e 5c       	ld.sh	r12,r7[0xa]
80003a02:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003a06:	f0 cb ff fe 	sub	r11,r8,-2
80003a0a:	8e 6c       	ld.sh	r12,r7[0xc]
80003a0c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003a10:	f0 cb ff fd 	sub	r11,r8,-3
80003a14:	8e 7c       	ld.sh	r12,r7[0xe]
80003a16:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a1a:	2f c8       	sub	r8,-4
80003a1c:	b4 88       	st.b	r10[0x0],r8
80003a1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a22:	30 09       	mov	r9,0
80003a24:	4b 48       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
80003a26:	91 09       	st.w	r8[0x0],r9
80003a28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a2c:	4c 08       	lddpc	r8,80003b2c <phy_rx_func+0xef4>
80003a2e:	70 09       	ld.w	r9,r8[0x0]
80003a30:	8e 4b       	ld.sh	r11,r7[0x8]
80003a32:	4c 0a       	lddpc	r10,80003b30 <phy_rx_func+0xef8>
80003a34:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a38:	2f f9       	sub	r9,-1
80003a3a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a3c:	4b 58       	lddpc	r8,80003b10 <phy_rx_func+0xed8>
80003a3e:	70 09       	ld.w	r9,r8[0x0]
80003a40:	20 29       	sub	r9,2
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	70 08       	ld.w	r8,r8[0x0]
80003a46:	58 08       	cp.w	r8,0
80003a48:	c2 f1       	brne	80003aa6 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a4a:	30 09       	mov	r9,0
80003a4c:	4b 88       	lddpc	r8,80003b2c <phy_rx_func+0xef4>
80003a4e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a50:	8e 59       	ld.sh	r9,r7[0xa]
80003a52:	fe 78 82 12 	mov	r8,-32238
80003a56:	f0 09 19 00 	cp.h	r9,r8
80003a5a:	c2 11       	brne	80003a9c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a5c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a60:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a64:	4a f8       	lddpc	r8,80003b20 <phy_rx_func+0xee8>
80003a66:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a68:	8e 59       	ld.sh	r9,r7[0xa]
80003a6a:	4a f8       	lddpc	r8,80003b24 <phy_rx_func+0xeec>
80003a6c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a6e:	8e 69       	ld.sh	r9,r7[0xc]
80003a70:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a72:	f0 1f 00 2e 	mcall	80003b28 <phy_rx_func+0xef0>
80003a76:	4a 18       	lddpc	r8,80003af8 <phy_rx_func+0xec0>
80003a78:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a7a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a7e:	31 38       	mov	r8,19
80003a80:	f0 09 18 00 	cp.b	r9,r8
80003a84:	c0 71       	brne	80003a92 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a86:	10 99       	mov	r9,r8
80003a88:	4a 18       	lddpc	r8,80003b0c <phy_rx_func+0xed4>
80003a8a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a8c:	30 09       	mov	r9,0
80003a8e:	49 c8       	lddpc	r8,80003afc <phy_rx_func+0xec4>
80003a90:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a92:	30 49       	mov	r9,4
80003a94:	49 88       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
80003a96:	91 09       	st.w	r8[0x0],r9
80003a98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a9c:	30 09       	mov	r9,0
80003a9e:	49 68       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
80003aa0:	91 09       	st.w	r8[0x0],r9
80003aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003aa6:	4a dc       	lddpc	r12,80003b58 <phy_rx_func+0xf20>
80003aa8:	f0 1f 00 18 	mcall	80003b08 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003aac:	30 09       	mov	r9,0
80003aae:	49 28       	lddpc	r8,80003af4 <phy_rx_func+0xebc>
80003ab0:	91 09       	st.w	r8[0x0],r9
80003ab2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ab6:	00 00       	add	r0,r0
80003ab8:	00 00       	add	r0,r0
80003aba:	0a b8       	st.h	r5++,r8
80003abc:	00 00       	add	r0,r0
80003abe:	0a bc       	st.h	r5++,r12
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a a0       	st.w	r5++,r0
80003ac4:	00 00       	add	r0,r0
80003ac6:	0a 7c       	tst	r12,r5
80003ac8:	00 00       	add	r0,r0
80003aca:	0a 74       	tst	r4,r5
80003acc:	00 00       	add	r0,r0
80003ace:	0a b4       	st.h	r5++,r4
80003ad0:	80 00       	ld.sh	r0,r0[0x0]
80003ad2:	2a 58       	sub	r8,-91
80003ad4:	00 00       	add	r0,r0
80003ad6:	0a 88       	andn	r8,r5
80003ad8:	80 00       	ld.sh	r0,r0[0x0]
80003ada:	29 88       	sub	r8,-104
80003adc:	00 00       	add	r0,r0
80003ade:	0a 6c       	and	r12,r5
80003ae0:	80 00       	ld.sh	r0,r0[0x0]
80003ae2:	29 a4       	sub	r4,-102
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 85       	andn	r5,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	0a 70       	tst	r0,r5
80003aec:	00 00       	add	r0,r0
80003aee:	0a 9c       	mov	r12,r5
80003af0:	00 00       	add	r0,r0
80003af2:	0a 94       	mov	r4,r5
80003af4:	00 00       	add	r0,r0
80003af6:	0a d0       	st.w	--r5,r0
80003af8:	00 00       	add	r0,r0
80003afa:	0a 68       	and	r8,r5
80003afc:	00 00       	add	r0,r0
80003afe:	0a 78       	tst	r8,r5
80003b00:	00 00       	add	r0,r0
80003b02:	0a 46       	or	r6,r5
80003b04:	80 00       	ld.sh	r0,r0[0x0]
80003b06:	d0 f8       	*unknown*
80003b08:	80 00       	ld.sh	r0,r0[0x0]
80003b0a:	6b a0       	ld.w	r0,r5[0x68]
80003b0c:	00 00       	add	r0,r0
80003b0e:	0a 84       	andn	r4,r5
80003b10:	00 00       	add	r0,r0
80003b12:	0a 90       	mov	r0,r5
80003b14:	00 00       	add	r0,r0
80003b16:	0a a4       	st.w	r5++,r4
80003b18:	80 00       	ld.sh	r0,r0[0x0]
80003b1a:	73 d4       	ld.w	r4,r9[0x74]
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	2b d8       	sub	r8,-67
80003b20:	00 00       	add	r0,r0
80003b22:	0a 42       	or	r2,r5
80003b24:	00 00       	add	r0,r0
80003b26:	1e 88       	andn	r8,pc
80003b28:	80 00       	ld.sh	r0,r0[0x0]
80003b2a:	28 e8       	sub	r8,-114
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a c0       	st.b	r5++,r0
80003b30:	00 00       	add	r0,r0
80003b32:	1d 8c       	ld.ub	r12,lr[0x0]
80003b34:	00 00       	add	r0,r0
80003b36:	0a d4       	st.w	--r5,r4
80003b38:	00 00       	add	r0,r0
80003b3a:	0a 43       	or	r3,r5
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a 41       	or	r1,r5
80003b40:	00 00       	add	r0,r0
80003b42:	0a b0       	st.h	r5++,r0
80003b44:	00 00       	add	r0,r0
80003b46:	0a 98       	mov	r8,r5
80003b48:	00 00       	add	r0,r0
80003b4a:	0a 56       	eor	r6,r5
80003b4c:	00 00       	add	r0,r0
80003b4e:	1d 84       	ld.ub	r4,lr[0x0]
80003b50:	00 00       	add	r0,r0
80003b52:	0a c8       	st.b	r5++,r8
80003b54:	00 00       	add	r0,r0
80003b56:	1e 8c       	andn	r12,pc
80003b58:	80 00       	ld.sh	r0,r0[0x0]
80003b5a:	d1 10       	acall	0x11

80003b5c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b5c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b5e:	49 88       	lddpc	r8,80003bbc <pdca_int_handler+0x60>
80003b60:	11 89       	ld.ub	r9,r8[0x0]
80003b62:	ec 19 00 01 	eorl	r9,0x1
80003b66:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b68:	11 89       	ld.ub	r9,r8[0x0]
80003b6a:	a5 69       	lsl	r9,0x4
80003b6c:	2f c9       	sub	r9,-4
80003b6e:	49 5a       	lddpc	r10,80003bc0 <pdca_int_handler+0x64>
80003b70:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b72:	fe 7a 00 40 	mov	r10,-65472
80003b76:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b78:	30 39       	mov	r9,3
80003b7a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b7c:	11 8a       	ld.ub	r10,r8[0x0]
80003b7e:	a5 6a       	lsl	r10,0x4
80003b80:	2f ca       	sub	r10,-4
80003b82:	49 18       	lddpc	r8,80003bc4 <pdca_int_handler+0x68>
80003b84:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b86:	fe 78 00 00 	mov	r8,-65536
80003b8a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b8c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b8e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b90:	48 e8       	lddpc	r8,80003bc8 <pdca_int_handler+0x6c>
80003b92:	70 08       	ld.w	r8,r8[0x0]
80003b94:	58 08       	cp.w	r8,0
80003b96:	c0 70       	breq	80003ba4 <pdca_int_handler+0x48>
80003b98:	48 99       	lddpc	r9,80003bbc <pdca_int_handler+0x60>
80003b9a:	13 89       	ld.ub	r9,r9[0x0]
80003b9c:	a5 69       	lsl	r9,0x4
80003b9e:	48 ac       	lddpc	r12,80003bc4 <pdca_int_handler+0x68>
80003ba0:	12 0c       	add	r12,r9
80003ba2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003ba4:	48 a8       	lddpc	r8,80003bcc <pdca_int_handler+0x70>
80003ba6:	70 08       	ld.w	r8,r8[0x0]
80003ba8:	58 08       	cp.w	r8,0
80003baa:	c0 70       	breq	80003bb8 <pdca_int_handler+0x5c>
80003bac:	48 49       	lddpc	r9,80003bbc <pdca_int_handler+0x60>
80003bae:	13 89       	ld.ub	r9,r9[0x0]
80003bb0:	a5 69       	lsl	r9,0x4
80003bb2:	48 4c       	lddpc	r12,80003bc0 <pdca_int_handler+0x64>
80003bb4:	12 0c       	add	r12,r9
80003bb6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003bb8:	d4 02       	popm	lr
80003bba:	d6 03       	rete
80003bbc:	00 00       	add	r0,r0
80003bbe:	50 ac       	stdsp	sp[0x28],r12
80003bc0:	00 00       	add	r0,r0
80003bc2:	50 d4       	stdsp	sp[0x34],r4
80003bc4:	00 00       	add	r0,r0
80003bc6:	50 b4       	stdsp	sp[0x2c],r4
80003bc8:	00 00       	add	r0,r0
80003bca:	0a dc       	st.w	--r5,r12
80003bcc:	00 00       	add	r0,r0
80003bce:	0a e0       	st.h	--r5,r0

80003bd0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bd0:	fe 78 10 00 	mov	r8,-61440
80003bd4:	e0 69 0d c0 	mov	r9,3520
80003bd8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bdc:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003be0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003be4:	fe 78 34 00 	mov	r8,-52224
80003be8:	e0 69 80 00 	mov	r9,32768
80003bec:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003bee:	30 09       	mov	r9,0
80003bf0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003bf2:	e0 69 04 21 	mov	r9,1057
80003bf6:	ea 19 3f 20 	orh	r9,0x3f20
80003bfa:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003bfc:	e0 69 02 9f 	mov	r9,671
80003c00:	ea 19 01 00 	orh	r9,0x100
80003c04:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003c06:	e0 6a 04 02 	mov	r10,1026
80003c0a:	ea 1a 3f 20 	orh	r10,0x3f20
80003c0e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003c10:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003c12:	5e fc       	retal	r12

80003c14 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c14:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c16:	30 19       	mov	r9,1
80003c18:	49 78       	lddpc	r8,80003c74 <local_start_PDC+0x60>
80003c1a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c1c:	fe 78 00 00 	mov	r8,-65536
80003c20:	30 7b       	mov	r11,7
80003c22:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c24:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c26:	49 59       	lddpc	r9,80003c78 <local_start_PDC+0x64>
80003c28:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c2c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c2e:	30 3a       	mov	r10,3
80003c30:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c32:	30 1c       	mov	r12,1
80003c34:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c36:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c38:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c3a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c3c:	30 2c       	mov	r12,2
80003c3e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c40:	48 f9       	lddpc	r9,80003c7c <local_start_PDC+0x68>
80003c42:	e0 68 5a 5a 	mov	r8,23130
80003c46:	ea 18 ab cd 	orh	r8,0xabcd
80003c4a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c4c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c4e:	30 0e       	mov	lr,0
80003c50:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c52:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c54:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c56:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c58:	fe 78 00 40 	mov	r8,-65472
80003c5c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c5e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c60:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c64:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c66:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c68:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c6a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c6c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c6e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c70:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c72:	d8 02       	popm	pc
80003c74:	00 00       	add	r0,r0
80003c76:	50 ac       	stdsp	sp[0x28],r12
80003c78:	00 00       	add	r0,r0
80003c7a:	50 b4       	stdsp	sp[0x2c],r4
80003c7c:	00 00       	add	r0,r0
80003c7e:	50 d4       	stdsp	sp[0x34],r4

80003c80 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c80:	48 38       	lddpc	r8,80003c8c <register_rx_tx_func+0xc>
80003c82:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c84:	48 38       	lddpc	r8,80003c90 <register_rx_tx_func+0x10>
80003c86:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c88:	5e fc       	retal	r12
80003c8a:	00 00       	add	r0,r0
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a dc       	st.w	--r5,r12
80003c90:	00 00       	add	r0,r0
80003c92:	0a e0       	st.h	--r5,r0

80003c94 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c94:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c96:	fe 78 10 00 	mov	r8,-61440
80003c9a:	30 29       	mov	r9,2
80003c9c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003ca0:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003ca4:	30 3a       	mov	r10,3
80003ca6:	36 0b       	mov	r11,96
80003ca8:	49 3c       	lddpc	r12,80003cf4 <ssc_init+0x60>
80003caa:	f0 1f 00 14 	mcall	80003cf8 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003cae:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003cb0:	fe 79 10 00 	mov	r9,-61440
80003cb4:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cb8:	e2 18 00 02 	andl	r8,0x2,COH
80003cbc:	cf c0       	breq	80003cb4 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003cbe:	fe 79 10 00 	mov	r9,-61440
80003cc2:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cc6:	e2 18 00 02 	andl	r8,0x2,COH
80003cca:	cf c1       	brne	80003cc2 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003ccc:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003cce:	f0 1f 00 0c 	mcall	80003cfc <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003cd2:	f0 1f 00 0c 	mcall	80003d00 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cd6:	fe 79 00 00 	mov	r9,-65536
80003cda:	30 18       	mov	r8,1
80003cdc:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cde:	fe 7a 00 40 	mov	r10,-65472
80003ce2:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ce4:	e0 6b 01 01 	mov	r11,257
80003ce8:	fe 7a 34 00 	mov	r10,-52224
80003cec:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003cee:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003cf0:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003cf2:	d8 02       	popm	pc
80003cf4:	80 00       	ld.sh	r0,r0[0x0]
80003cf6:	3b 5c       	mov	r12,-75
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	51 94       	stdsp	sp[0x64],r4
80003cfc:	80 00       	ld.sh	r0,r0[0x0]
80003cfe:	3b d0       	mov	r0,-67
80003d00:	80 00       	ld.sh	r0,r0[0x0]
80003d02:	3c 14       	mov	r4,-63

80003d04 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003d04:	48 28       	lddpc	r8,80003d0c <xcmp_register_app_list+0x8>
80003d06:	91 0c       	st.w	r8[0x0],r12
}
80003d08:	5e fc       	retal	r12
80003d0a:	00 00       	add	r0,r0
80003d0c:	00 00       	add	r0,r0
80003d0e:	50 f4       	stdsp	sp[0x3c],r4

80003d10 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d10:	eb cd 40 80 	pushm	r7,lr
80003d14:	fa cd 01 00 	sub	sp,sp,256
80003d18:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d1a:	16 98       	mov	r8,r11
80003d1c:	2f 08       	sub	r8,-16
80003d1e:	af a8       	sbr	r8,0xe
80003d20:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d22:	3f f8       	mov	r8,-1
80003d24:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d26:	30 b9       	mov	r9,11
80003d28:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d2a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d2c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d2e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d30:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d32:	f6 ca ff fe 	sub	r10,r11,-2
80003d36:	18 9b       	mov	r11,r12
80003d38:	fa cc ff f0 	sub	r12,sp,-16
80003d3c:	f0 1f 00 05 	mcall	80003d50 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d40:	2f e7       	sub	r7,-2
80003d42:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d44:	1a 9c       	mov	r12,sp
80003d46:	f0 1f 00 04 	mcall	80003d54 <xcmp_tx+0x44>
}
80003d4a:	2c 0d       	sub	sp,-256
80003d4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	72 8c       	ld.w	r12,r9[0x20]
80003d54:	80 00       	ld.sh	r0,r0[0x0]
80003d56:	43 1c       	lddsp	r12,sp[0xc4]

80003d58 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d58:	d4 21       	pushm	r4-r7,lr
80003d5a:	fa cd 00 d0 	sub	sp,sp,208
80003d5e:	18 94       	mov	r4,r12
80003d60:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d62:	e0 68 01 00 	mov	r8,256
80003d66:	f0 0b 19 00 	cp.h	r11,r8
80003d6a:	e0 8b 00 36 	brhi	80003dd6 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d6e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d72:	e0 68 04 1d 	mov	r8,1053
80003d76:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003d78:	30 18       	mov	r8,1
80003d7a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003d7c:	32 08       	mov	r8,32
80003d7e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003d80:	30 28       	mov	r8,2
80003d82:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003d84:	30 48       	mov	r8,4
80003d86:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003d88:	ea 1a 0c 00 	orh	r10,0xc00
80003d8c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003d8e:	30 4a       	mov	r10,4
80003d90:	1a 9b       	mov	r11,sp
80003d92:	fa cc ff f4 	sub	r12,sp,-12
80003d96:	f0 1f 00 12 	mcall	80003ddc <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003d9a:	30 f8       	mov	r8,15
80003d9c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003da0:	3a 78       	mov	r8,-89
80003da2:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003da6:	30 08       	mov	r8,0
80003da8:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003dac:	0e 9a       	mov	r10,r7
80003dae:	5c 7a       	castu.h	r10
80003db0:	f4 08 16 08 	lsr	r8,r10,0x8
80003db4:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003db8:	0e 96       	mov	r6,r7
80003dba:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003dbe:	08 9b       	mov	r11,r4
80003dc0:	fa cc ff eb 	sub	r12,sp,-21
80003dc4:	f0 1f 00 06 	mcall	80003ddc <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003dc8:	ee cb ff f3 	sub	r11,r7,-13
80003dcc:	5c 5b       	castu.b	r11
80003dce:	fa cc ff fa 	sub	r12,sp,-6
80003dd2:	f0 1f 00 04 	mcall	80003de0 <xcmp_data_session_req+0x88>
}
80003dd6:	2c cd       	sub	sp,-208
80003dd8:	d8 22       	popm	r4-r7,pc
80003dda:	00 00       	add	r0,r0
80003ddc:	80 00       	ld.sh	r0,r0[0x0]
80003dde:	72 8c       	ld.w	r12,r9[0x20]
80003de0:	80 00       	ld.sh	r0,r0[0x0]
80003de2:	3d 10       	mov	r0,-47

80003de4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003de4:	d4 01       	pushm	lr
80003de6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dea:	fe 78 b4 00 	mov	r8,-19456
80003dee:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003df0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003df4:	30 89       	mov	r9,8
80003df6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003df8:	30 19       	mov	r9,1
80003dfa:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003dfc:	30 09       	mov	r9,0
80003dfe:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003e00:	30 5a       	mov	r10,5
80003e02:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003e04:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003e06:	30 7a       	mov	r10,7
80003e08:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003e0a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e0c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e0e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e12:	30 9b       	mov	r11,9
80003e14:	fa cc ff fe 	sub	r12,sp,-2
80003e18:	f0 1f 00 02 	mcall	80003e20 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e1c:	2c dd       	sub	sp,-204
80003e1e:	d8 02       	popm	pc
80003e20:	80 00       	ld.sh	r0,r0[0x0]
80003e22:	3d 10       	mov	r0,-47

80003e24 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e24:	d4 01       	pushm	lr
80003e26:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e2a:	fe 78 80 00 	mov	r8,-32768
80003e2e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e30:	30 38       	mov	r8,3
80003e32:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e34:	30 1b       	mov	r11,1
80003e36:	fa cc ff fe 	sub	r12,sp,-2
80003e3a:	f0 1f 00 03 	mcall	80003e44 <xcmp_opcode_not_supported+0x20>
}
80003e3e:	2c dd       	sub	sp,-204
80003e40:	d8 02       	popm	pc
80003e42:	00 00       	add	r0,r0
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	3d 10       	mov	r0,-47

80003e48 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e48:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e4a:	96 88       	ld.uh	r8,r11[0x0]
80003e4c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e50:	e0 48 80 00 	cp.w	r8,32768
80003e54:	c0 f0       	breq	80003e72 <xcmp_exec_func+0x2a>
80003e56:	e0 48 b0 00 	cp.w	r8,45056
80003e5a:	c1 20       	breq	80003e7e <xcmp_exec_func+0x36>
80003e5c:	58 08       	cp.w	r8,0
80003e5e:	c1 51       	brne	80003e88 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e60:	78 08       	ld.w	r8,r12[0x0]
80003e62:	58 08       	cp.w	r8,0
80003e64:	c0 40       	breq	80003e6c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e66:	16 9c       	mov	r12,r11
80003e68:	5d 18       	icall	r8
80003e6a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e6c:	f0 1f 00 08 	mcall	80003e8c <xcmp_exec_func+0x44>
80003e70:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e72:	78 18       	ld.w	r8,r12[0x4]
80003e74:	58 08       	cp.w	r8,0
80003e76:	c0 90       	breq	80003e88 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e78:	16 9c       	mov	r12,r11
80003e7a:	5d 18       	icall	r8
80003e7c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e7e:	78 28       	ld.w	r8,r12[0x8]
80003e80:	58 08       	cp.w	r8,0
80003e82:	c0 30       	breq	80003e88 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e84:	16 9c       	mov	r12,r11
80003e86:	5d 18       	icall	r8
80003e88:	d8 02       	popm	pc
80003e8a:	00 00       	add	r0,r0
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	3e 24       	mov	r4,-30

80003e90 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003e90:	d4 01       	pushm	lr
80003e92:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003e96:	e0 68 04 09 	mov	r8,1033
80003e9a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003e9c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003ea0:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003ea2:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003ea6:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003ea8:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003eaa:	30 09       	mov	r9,0
80003eac:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003eae:	fb 69 00 08 	st.b	sp[8],r9
80003eb2:	fa c8 ff f7 	sub	r8,sp,-9
80003eb6:	b0 89       	st.b	r8[0x0],r9
80003eb8:	fa c8 ff f6 	sub	r8,sp,-10
80003ebc:	b0 89       	st.b	r8[0x0],r9
80003ebe:	fa c8 ff f5 	sub	r8,sp,-11
80003ec2:	b0 89       	st.b	r8[0x0],r9
80003ec4:	fa c8 ff f4 	sub	r8,sp,-12
80003ec8:	b0 89       	st.b	r8[0x0],r9
80003eca:	fa c8 ff f3 	sub	r8,sp,-13
80003ece:	b0 89       	st.b	r8[0x0],r9
80003ed0:	fa c8 ff f2 	sub	r8,sp,-14
80003ed4:	b0 89       	st.b	r8[0x0],r9
80003ed6:	fa c8 ff f1 	sub	r8,sp,-15
80003eda:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003edc:	30 cb       	mov	r11,12
80003ede:	fa cc ff fe 	sub	r12,sp,-2
80003ee2:	f0 1f 00 03 	mcall	80003eec <xcmp_IdleTestTone+0x5c>
}
80003ee6:	2c dd       	sub	sp,-204
80003ee8:	d8 02       	popm	pc
80003eea:	00 00       	add	r0,r0
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	3d 10       	mov	r0,-47

80003ef0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ef0:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ef2:	48 dc       	lddpc	r12,80003f24 <xcmp_init+0x34>
80003ef4:	f0 1f 00 0d 	mcall	80003f28 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003ef8:	30 4b       	mov	r11,4
80003efa:	31 4c       	mov	r12,20
80003efc:	f0 1f 00 0c 	mcall	80003f2c <xcmp_init+0x3c>
80003f00:	48 c8       	lddpc	r8,80003f30 <xcmp_init+0x40>
80003f02:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003f04:	30 09       	mov	r9,0
80003f06:	1a d9       	st.w	--sp,r9
80003f08:	1a d9       	st.w	--sp,r9
80003f0a:	1a d9       	st.w	--sp,r9
80003f0c:	30 38       	mov	r8,3
80003f0e:	e0 6a 01 80 	mov	r10,384
80003f12:	48 9b       	lddpc	r11,80003f34 <xcmp_init+0x44>
80003f14:	48 9c       	lddpc	r12,80003f38 <xcmp_init+0x48>
80003f16:	f0 1f 00 0a 	mcall	80003f3c <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003f1a:	f0 1f 00 0a 	mcall	80003f40 <xcmp_init+0x50>
80003f1e:	2f dd       	sub	sp,-12
	
}
80003f20:	d8 02       	popm	pc
80003f22:	00 00       	add	r0,r0
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	40 40       	lddsp	r0,sp[0x10]
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	40 8c       	lddsp	r12,sp[0x20]
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	5f 34       	srlo	r4
80003f30:	00 00       	add	r0,r0
80003f32:	0a fc       	st.b	--r5,r12
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	d1 3c       	*unknown*
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	3f 44       	mov	r4,-12
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	66 50       	ld.w	r0,r3[0x14]
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	40 c4       	lddsp	r4,sp[0x30]

80003f44 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f44:	d4 31       	pushm	r0-r7,lr
80003f46:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f48:	4b 16       	lddpc	r6,8000400c <xcmp_rx_process+0xc8>
80003f4a:	30 05       	mov	r5,0
80003f4c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f4e:	4b 13       	lddpc	r3,80004010 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f50:	4b 12       	lddpc	r2,80004014 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f52:	4b 21       	lddpc	r1,80004018 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f54:	4b 20       	lddpc	r0,8000401c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f56:	6c 0c       	ld.w	r12,r6[0x0]
80003f58:	0a 99       	mov	r9,r5
80003f5a:	08 9a       	mov	r10,r4
80003f5c:	1a 9b       	mov	r11,sp
80003f5e:	f0 1f 00 31 	mcall	80004020 <xcmp_rx_process+0xdc>
80003f62:	58 1c       	cp.w	r12,1
80003f64:	cf 91       	brne	80003f56 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f66:	40 0b       	lddsp	r11,sp[0x0]
80003f68:	58 0b       	cp.w	r11,0
80003f6a:	cf 60       	breq	80003f56 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f6c:	96 0a       	ld.sh	r10,r11[0x0]
80003f6e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f72:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f76:	59 c8       	cp.w	r8,28
80003f78:	c1 e0       	breq	80003fb4 <xcmp_rx_process+0x70>
80003f7a:	e0 89 00 07 	brgt	80003f88 <xcmp_rx_process+0x44>
80003f7e:	58 e8       	cp.w	r8,14
80003f80:	c0 e0       	breq	80003f9c <xcmp_rx_process+0x58>
80003f82:	58 f8       	cp.w	r8,15
80003f84:	c2 41       	brne	80003fcc <xcmp_rx_process+0x88>
80003f86:	c0 f8       	rjmp	80003fa4 <xcmp_rx_process+0x60>
80003f88:	e0 48 01 09 	cp.w	r8,265
80003f8c:	c1 80       	breq	80003fbc <xcmp_rx_process+0x78>
80003f8e:	e0 48 01 0a 	cp.w	r8,266
80003f92:	c1 90       	breq	80003fc4 <xcmp_rx_process+0x80>
80003f94:	e0 48 00 2c 	cp.w	r8,44
80003f98:	c1 a1       	brne	80003fcc <xcmp_rx_process+0x88>
80003f9a:	c0 98       	rjmp	80003fac <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003f9c:	4a 2c       	lddpc	r12,80004024 <xcmp_rx_process+0xe0>
80003f9e:	f0 1f 00 23 	mcall	80004028 <xcmp_rx_process+0xe4>
					break;
80003fa2:	c2 f8       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003fa4:	4a 2c       	lddpc	r12,8000402c <xcmp_rx_process+0xe8>
80003fa6:	f0 1f 00 21 	mcall	80004028 <xcmp_rx_process+0xe4>
					break;
80003faa:	c2 b8       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003fac:	4a 1c       	lddpc	r12,80004030 <xcmp_rx_process+0xec>
80003fae:	f0 1f 00 1f 	mcall	80004028 <xcmp_rx_process+0xe4>
					break;
80003fb2:	c2 78       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fb4:	04 9c       	mov	r12,r2
80003fb6:	f0 1f 00 1d 	mcall	80004028 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003fba:	c2 38       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fbc:	02 9c       	mov	r12,r1
80003fbe:	f0 1f 00 1b 	mcall	80004028 <xcmp_rx_process+0xe4>
					break;
80003fc2:	c1 f8       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fc4:	00 9c       	mov	r12,r0
80003fc6:	f0 1f 00 19 	mcall	80004028 <xcmp_rx_process+0xe4>
					break;
80003fca:	c1 b8       	rjmp	80004000 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fcc:	12 98       	mov	r8,r9
80003fce:	e2 18 04 00 	andl	r8,0x400,COH
80003fd2:	c0 70       	breq	80003fe0 <xcmp_rx_process+0x9c>
80003fd4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fd8:	e0 48 00 68 	cp.w	r8,104
80003fdc:	e0 8a 00 08 	brle	80003fec <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003fe0:	e2 19 f0 00 	andl	r9,0xf000,COH
80003fe4:	c0 e1       	brne	80004000 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003fe6:	f0 1f 00 14 	mcall	80004034 <xcmp_rx_process+0xf0>
80003fea:	c0 b8       	rjmp	80004000 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003fec:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003ff0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003ff4:	49 19       	lddpc	r9,80004038 <xcmp_rx_process+0xf4>
80003ff6:	72 08       	ld.w	r8,r9[0x0]
80003ff8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003ffc:	f0 1f 00 0b 	mcall	80004028 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004000:	66 0c       	ld.w	r12,r3[0x0]
80004002:	40 0b       	lddsp	r11,sp[0x0]
80004004:	f0 1f 00 0e 	mcall	8000403c <xcmp_rx_process+0xf8>
80004008:	ca 7b       	rjmp	80003f56 <xcmp_rx_process+0x12>
8000400a:	00 00       	add	r0,r0
8000400c:	00 00       	add	r0,r0
8000400e:	0a fc       	st.b	--r5,r12
80004010:	00 00       	add	r0,r0
80004012:	0a b4       	st.h	r5++,r4
80004014:	00 00       	add	r0,r0
80004016:	0b 0c       	ld.w	r12,r5++
80004018:	00 00       	add	r0,r0
8000401a:	0b 00       	ld.w	r0,r5++
8000401c:	00 00       	add	r0,r0
8000401e:	0a f0       	st.b	--r5,r0
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	5c 28       	cpc	r8
80004024:	00 00       	add	r0,r0
80004026:	0b 24       	ld.uh	r4,r5++
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3e 48       	mov	r8,-28
8000402c:	00 00       	add	r0,r0
8000402e:	0a e4       	st.h	--r5,r4
80004030:	00 00       	add	r0,r0
80004032:	0b 18       	ld.sh	r8,r5++
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	3e 24       	mov	r4,-30
80004038:	00 00       	add	r0,r0
8000403a:	50 f4       	stdsp	sp[0x3c],r4
8000403c:	80 00       	ld.sh	r0,r0[0x0]
8000403e:	29 dc       	sub	r12,-99

80004040 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004040:	eb cd 40 90 	pushm	r4,r7,lr
80004044:	20 1d       	sub	sp,4
80004046:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000404a:	48 c8       	lddpc	r8,80004078 <xcmp_rx+0x38>
8000404c:	70 0c       	ld.w	r12,r8[0x0]
8000404e:	f0 1f 00 0c 	mcall	8000407c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004052:	c1 00       	breq	80004072 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004054:	fa c7 ff fc 	sub	r7,sp,-4
80004058:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000405a:	e0 6a 00 ca 	mov	r10,202
8000405e:	08 9b       	mov	r11,r4
80004060:	f0 1f 00 08 	mcall	80004080 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004064:	48 88       	lddpc	r8,80004084 <xcmp_rx+0x44>
80004066:	70 0c       	ld.w	r12,r8[0x0]
80004068:	30 09       	mov	r9,0
8000406a:	12 9a       	mov	r10,r9
8000406c:	1a 9b       	mov	r11,sp
8000406e:	f0 1f 00 07 	mcall	80004088 <xcmp_rx+0x48>
	}	
}
80004072:	2f fd       	sub	sp,-4
80004074:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004078:	00 00       	add	r0,r0
8000407a:	0a b4       	st.h	r5++,r4
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	2b 88       	sub	r8,-72
80004080:	80 00       	ld.sh	r0,r0[0x0]
80004082:	72 8c       	ld.w	r12,r9[0x20]
80004084:	00 00       	add	r0,r0
80004086:	0a fc       	st.b	--r5,r12
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	5e 34       	retlo	r4

8000408c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000408c:	48 28       	lddpc	r8,80004094 <xnl_register_xcmp_func+0x8>
8000408e:	91 0c       	st.w	r8[0x0],r12
}
80004090:	5e fc       	retal	r12
80004092:	00 00       	add	r0,r0
80004094:	00 00       	add	r0,r0
80004096:	0b 54       	ld.sh	r4,--r5

80004098 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004098:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000409a:	48 88       	lddpc	r8,800040b8 <xnl_get_msg_ack_func+0x20>
8000409c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000409e:	98 49       	ld.sh	r9,r12[0x8]
800040a0:	f0 09 19 00 	cp.h	r9,r8
800040a4:	c0 81       	brne	800040b4 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800040a6:	48 68       	lddpc	r8,800040bc <xnl_get_msg_ack_func+0x24>
800040a8:	70 0c       	ld.w	r12,r8[0x0]
800040aa:	30 09       	mov	r9,0
800040ac:	12 9a       	mov	r10,r9
800040ae:	12 9b       	mov	r11,r9
800040b0:	f0 1f 00 04 	mcall	800040c0 <xnl_get_msg_ack_func+0x28>
800040b4:	d8 02       	popm	pc
800040b6:	00 00       	add	r0,r0
800040b8:	00 00       	add	r0,r0
800040ba:	0b 34       	ld.ub	r4,r5++
800040bc:	00 00       	add	r0,r0
800040be:	0b 30       	ld.ub	r0,r5++
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	5e 34       	retlo	r4

800040c4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040c4:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040c8:	30 09       	mov	r9,0
800040ca:	4b 78       	lddpc	r8,800041a4 <xnl_init+0xe0>
800040cc:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040ce:	30 0b       	mov	r11,0
800040d0:	30 1c       	mov	r12,1
800040d2:	f0 1f 00 36 	mcall	800041a8 <xnl_init+0xe4>
800040d6:	4b 68       	lddpc	r8,800041ac <xnl_init+0xe8>
800040d8:	91 0c       	st.w	r8[0x0],r12
800040da:	70 08       	ld.w	r8,r8[0x0]
800040dc:	58 08       	cp.w	r8,0
800040de:	c0 80       	breq	800040ee <xnl_init+0x2a>
800040e0:	4b 38       	lddpc	r8,800041ac <xnl_init+0xe8>
800040e2:	70 0c       	ld.w	r12,r8[0x0]
800040e4:	30 09       	mov	r9,0
800040e6:	12 9a       	mov	r10,r9
800040e8:	12 9b       	mov	r11,r9
800040ea:	f0 1f 00 32 	mcall	800041b0 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800040ee:	30 4b       	mov	r11,4
800040f0:	31 4c       	mov	r12,20
800040f2:	f0 1f 00 2e 	mcall	800041a8 <xnl_init+0xe4>
800040f6:	4b 08       	lddpc	r8,800041b4 <xnl_init+0xf0>
800040f8:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040fa:	30 4b       	mov	r11,4
800040fc:	31 ec       	mov	r12,30
800040fe:	f0 1f 00 2b 	mcall	800041a8 <xnl_init+0xe4>
80004102:	4a e8       	lddpc	r8,800041b8 <xnl_init+0xf4>
80004104:	91 0c       	st.w	r8[0x0],r12
80004106:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004108:	10 96       	mov	r6,r8
8000410a:	4a d5       	lddpc	r5,800041bc <xnl_init+0xf8>
8000410c:	6c 0c       	ld.w	r12,r6[0x0]
8000410e:	ea 07 00 0b 	add	r11,r5,r7
80004112:	f0 1f 00 2c 	mcall	800041c0 <xnl_init+0xfc>
80004116:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000411a:	e0 47 1e 00 	cp.w	r7,7680
8000411e:	cf 71       	brne	8000410c <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004120:	30 4b       	mov	r11,4
80004122:	31 4c       	mov	r12,20
80004124:	f0 1f 00 21 	mcall	800041a8 <xnl_init+0xe4>
80004128:	4a 78       	lddpc	r8,800041c4 <xnl_init+0x100>
8000412a:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000412c:	30 4b       	mov	r11,4
8000412e:	30 ac       	mov	r12,10
80004130:	f0 1f 00 1e 	mcall	800041a8 <xnl_init+0xe4>
80004134:	4a 58       	lddpc	r8,800041c8 <xnl_init+0x104>
80004136:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004138:	30 4b       	mov	r11,4
8000413a:	30 ac       	mov	r12,10
8000413c:	f0 1f 00 1b 	mcall	800041a8 <xnl_init+0xe4>
80004140:	4a 38       	lddpc	r8,800041cc <xnl_init+0x108>
80004142:	91 0c       	st.w	r8[0x0],r12
80004144:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004146:	10 96       	mov	r6,r8
80004148:	4a 25       	lddpc	r5,800041d0 <xnl_init+0x10c>
8000414a:	6c 0c       	ld.w	r12,r6[0x0]
8000414c:	ea 07 00 0b 	add	r11,r5,r7
80004150:	f0 1f 00 1c 	mcall	800041c0 <xnl_init+0xfc>
80004154:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004158:	e0 47 14 00 	cp.w	r7,5120
8000415c:	cf 71       	brne	8000414a <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000415e:	30 4b       	mov	r11,4
80004160:	30 5c       	mov	r12,5
80004162:	f0 1f 00 12 	mcall	800041a8 <xnl_init+0xe4>
80004166:	49 c8       	lddpc	r8,800041d4 <xnl_init+0x110>
80004168:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000416a:	30 07       	mov	r7,0
8000416c:	1a d7       	st.w	--sp,r7
8000416e:	1a d7       	st.w	--sp,r7
80004170:	1a d7       	st.w	--sp,r7
80004172:	30 38       	mov	r8,3
80004174:	0e 99       	mov	r9,r7
80004176:	e0 6a 02 00 	mov	r10,512
8000417a:	49 8b       	lddpc	r11,800041d8 <xnl_init+0x114>
8000417c:	49 8c       	lddpc	r12,800041dc <xnl_init+0x118>
8000417e:	f0 1f 00 19 	mcall	800041e0 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004182:	1a d7       	st.w	--sp,r7
80004184:	1a d7       	st.w	--sp,r7
80004186:	1a d7       	st.w	--sp,r7
80004188:	30 38       	mov	r8,3
8000418a:	0e 99       	mov	r9,r7
8000418c:	e0 6a 03 20 	mov	r10,800
80004190:	49 5b       	lddpc	r11,800041e4 <xnl_init+0x120>
80004192:	49 6c       	lddpc	r12,800041e8 <xnl_init+0x124>
80004194:	f0 1f 00 13 	mcall	800041e0 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004198:	f0 1f 00 15 	mcall	800041ec <xnl_init+0x128>
8000419c:	2f ad       	sub	sp,-24
}
8000419e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800041a2:	00 00       	add	r0,r0
800041a4:	00 00       	add	r0,r0
800041a6:	0b 34       	ld.ub	r4,r5++
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	5f 34       	srlo	r4
800041ac:	00 00       	add	r0,r0
800041ae:	0b 30       	ld.ub	r0,r5++
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	5e 34       	retlo	r4
800041b4:	00 00       	add	r0,r0
800041b6:	0b 40       	ld.w	r0,--r5
800041b8:	00 00       	add	r0,r0
800041ba:	0a b4       	st.h	r5++,r4
800041bc:	00 00       	add	r0,r0
800041be:	32 a6       	mov	r6,42
800041c0:	80 00       	ld.sh	r0,r0[0x0]
800041c2:	29 dc       	sub	r12,-99
800041c4:	00 00       	add	r0,r0
800041c6:	0a c4       	st.b	r5++,r4
800041c8:	00 00       	add	r0,r0
800041ca:	0a b8       	st.h	r5++,r8
800041cc:	00 00       	add	r0,r0
800041ce:	0a 70       	tst	r0,r5
800041d0:	00 00       	add	r0,r0
800041d2:	1e a6       	st.w	pc++,r6
800041d4:	00 00       	add	r0,r0
800041d6:	0a 8c       	andn	r12,r5
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	d1 44       	*unknown*
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	41 f0       	lddsp	r0,sp[0x7c]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	66 50       	ld.w	r0,r3[0x14]
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	ca 00       	breq	80004126 <xnl_init+0x62>
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	42 50       	lddsp	r0,sp[0x94]
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	2b b0       	sub	r0,-69

800041f0 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041f0:	eb cd 40 fe 	pushm	r1-r7,lr
800041f4:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041f6:	49 26       	lddpc	r6,8000423c <xnl_rx_process+0x4c>
800041f8:	30 05       	mov	r5,0
800041fa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041fc:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041fe:	49 11       	lddpc	r1,80004240 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004200:	49 12       	lddpc	r2,80004244 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004202:	6c 0c       	ld.w	r12,r6[0x0]
80004204:	0a 99       	mov	r9,r5
80004206:	08 9a       	mov	r10,r4
80004208:	1a 9b       	mov	r11,sp
8000420a:	f0 1f 00 10 	mcall	80004248 <xnl_rx_process+0x58>
8000420e:	58 1c       	cp.w	r12,1
80004210:	cf 91       	brne	80004202 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004212:	40 0c       	lddsp	r12,sp[0x0]
80004214:	58 0c       	cp.w	r12,0
80004216:	cf 60       	breq	80004202 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004218:	98 28       	ld.sh	r8,r12[0x4]
8000421a:	e6 08 19 00 	cp.h	r8,r3
8000421e:	e0 8b 00 0a 	brhi	80004232 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004222:	5c 78       	castu.h	r8
80004224:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004228:	58 09       	cp.w	r9,0
8000422a:	c0 40       	breq	80004232 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000422c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004230:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004232:	62 0c       	ld.w	r12,r1[0x0]
80004234:	40 0b       	lddsp	r11,sp[0x0]
80004236:	f0 1f 00 06 	mcall	8000424c <xnl_rx_process+0x5c>
8000423a:	ce 4b       	rjmp	80004202 <xnl_rx_process+0x12>
8000423c:	00 00       	add	r0,r0
8000423e:	0a b8       	st.h	r5++,r8
80004240:	00 00       	add	r0,r0
80004242:	0a b4       	st.h	r5++,r4
80004244:	00 00       	add	r0,r0
80004246:	04 f0       	st.b	--r2,r0
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	5c 28       	cpc	r8
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	29 dc       	sub	r12,-99

80004250 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004250:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004252:	4a a6       	lddpc	r6,800042f8 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004254:	4a a2       	lddpc	r2,800042fc <xnl_tx_process+0xac>
80004256:	4a b4       	lddpc	r4,80004300 <xnl_tx_process+0xb0>
80004258:	30 07       	mov	r7,0
8000425a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000425c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000425e:	4a a5       	lddpc	r5,80004304 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004260:	4a a3       	lddpc	r3,80004308 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004262:	6c 08       	ld.w	r8,r6[0x0]
80004264:	58 08       	cp.w	r8,0
80004266:	c0 40       	breq	8000426e <xnl_tx_process+0x1e>
80004268:	58 18       	cp.w	r8,1
8000426a:	cf d1       	brne	80004264 <xnl_tx_process+0x14>
8000426c:	c2 48       	rjmp	800042b4 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000426e:	64 0c       	ld.w	r12,r2[0x0]
80004270:	0e 99       	mov	r9,r7
80004272:	02 9a       	mov	r10,r1
80004274:	08 9b       	mov	r11,r4
80004276:	f0 1f 00 26 	mcall	8000430c <xnl_tx_process+0xbc>
8000427a:	58 1c       	cp.w	r12,1
8000427c:	cf 31       	brne	80004262 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000427e:	68 0b       	ld.w	r11,r4[0x0]
80004280:	58 0b       	cp.w	r11,0
80004282:	cf 00       	breq	80004262 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004284:	96 28       	ld.sh	r8,r11[0x4]
80004286:	e0 08 19 00 	cp.h	r8,r0
8000428a:	c0 71       	brne	80004298 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000428c:	4a 18       	lddpc	r8,80004310 <xnl_tx_process+0xc0>
8000428e:	70 08       	ld.w	r8,r8[0x0]
80004290:	10 9c       	mov	r12,r8
80004292:	f0 1f 00 21 	mcall	80004314 <xnl_tx_process+0xc4>
						break;
80004296:	ce 6b       	rjmp	80004262 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004298:	16 9c       	mov	r12,r11
8000429a:	f0 1f 00 20 	mcall	80004318 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000429e:	30 18       	mov	r8,1
800042a0:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042a2:	66 0c       	ld.w	r12,r3[0x0]
800042a4:	0e 99       	mov	r9,r7
800042a6:	0e 9a       	mov	r10,r7
800042a8:	0e 9b       	mov	r11,r7
800042aa:	f0 1f 00 19 	mcall	8000430c <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800042ae:	30 18       	mov	r8,1
800042b0:	8d 08       	st.w	r6[0x0],r8
800042b2:	cd 8b       	rjmp	80004262 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042b4:	66 0c       	ld.w	r12,r3[0x0]
800042b6:	0e 99       	mov	r9,r7
800042b8:	36 4a       	mov	r10,100
800042ba:	0e 9b       	mov	r11,r7
800042bc:	f0 1f 00 14 	mcall	8000430c <xnl_tx_process+0xbc>
800042c0:	58 1c       	cp.w	r12,1
800042c2:	c0 81       	brne	800042d2 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042c4:	49 38       	lddpc	r8,80004310 <xnl_tx_process+0xc0>
800042c6:	70 0c       	ld.w	r12,r8[0x0]
800042c8:	68 0b       	ld.w	r11,r4[0x0]
800042ca:	f0 1f 00 13 	mcall	80004314 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042ce:	8d 07       	st.w	r6[0x0],r7
800042d0:	cc 9b       	rjmp	80004262 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042d2:	6a 08       	ld.w	r8,r5[0x0]
800042d4:	58 38       	cp.w	r8,3
800042d6:	e0 89 00 09 	brgt	800042e8 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042da:	68 0c       	ld.w	r12,r4[0x0]
800042dc:	f0 1f 00 0f 	mcall	80004318 <xnl_tx_process+0xc8>
						xnl_send_times++;
800042e0:	6a 08       	ld.w	r8,r5[0x0]
800042e2:	2f f8       	sub	r8,-1
800042e4:	8b 08       	st.w	r5[0x0],r8
800042e6:	cb eb       	rjmp	80004262 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042e8:	48 a8       	lddpc	r8,80004310 <xnl_tx_process+0xc0>
800042ea:	70 0c       	ld.w	r12,r8[0x0]
800042ec:	68 0b       	ld.w	r11,r4[0x0]
800042ee:	f0 1f 00 0a 	mcall	80004314 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042f2:	8d 07       	st.w	r6[0x0],r7
800042f4:	cb 7b       	rjmp	80004262 <xnl_tx_process+0x12>
800042f6:	00 00       	add	r0,r0
800042f8:	00 00       	add	r0,r0
800042fa:	0b 50       	ld.sh	r0,--r5
800042fc:	00 00       	add	r0,r0
800042fe:	0b 40       	ld.w	r0,--r5
80004300:	00 00       	add	r0,r0
80004302:	0b 48       	ld.w	r8,--r5
80004304:	00 00       	add	r0,r0
80004306:	0b 44       	ld.w	r4,--r5
80004308:	00 00       	add	r0,r0
8000430a:	0b 30       	ld.ub	r0,r5++
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	5c 28       	cpc	r8
80004310:	00 00       	add	r0,r0
80004312:	0a b4       	st.h	r5++,r4
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	29 dc       	sub	r12,-99
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	29 fc       	sub	r12,-97

8000431c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000431c:	eb cd 40 c0 	pushm	r6-r7,lr
80004320:	20 1d       	sub	sp,4
80004322:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004324:	98 39       	ld.sh	r9,r12[0x6]
80004326:	3f f8       	mov	r8,-1
80004328:	f0 09 19 00 	cp.h	r9,r8
8000432c:	c0 a1       	brne	80004340 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000432e:	4a e9       	lddpc	r9,800043e4 <xnl_tx+0xc8>
80004330:	13 88       	ld.ub	r8,r9[0x0]
80004332:	2f f8       	sub	r8,-1
80004334:	5c 58       	castu.b	r8
80004336:	b2 88       	st.b	r9[0x0],r8
80004338:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000433c:	a9 a8       	sbr	r8,0x8
8000433e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004340:	8c 49       	ld.sh	r9,r6[0x8]
80004342:	3f f8       	mov	r8,-1
80004344:	f0 09 19 00 	cp.h	r9,r8
80004348:	c0 41       	brne	80004350 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000434a:	4a 88       	lddpc	r8,800043e8 <xnl_tx+0xcc>
8000434c:	90 18       	ld.sh	r8,r8[0x2]
8000434e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004350:	8c 59       	ld.sh	r9,r6[0xa]
80004352:	3f f8       	mov	r8,-1
80004354:	f0 09 19 00 	cp.h	r9,r8
80004358:	c0 41       	brne	80004360 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000435a:	4a 48       	lddpc	r8,800043e8 <xnl_tx+0xcc>
8000435c:	90 28       	ld.sh	r8,r8[0x4]
8000435e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004360:	8c 69       	ld.sh	r9,r6[0xc]
80004362:	3f f8       	mov	r8,-1
80004364:	f0 09 19 00 	cp.h	r9,r8
80004368:	c0 e1       	brne	80004384 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000436a:	4a 08       	lddpc	r8,800043e8 <xnl_tx+0xcc>
8000436c:	90 49       	ld.sh	r9,r8[0x8]
8000436e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004370:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004372:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004374:	90 49       	ld.sh	r9,r8[0x8]
80004376:	e0 19 ff 00 	andl	r9,0xff00
8000437a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000437e:	f3 e8 10 08 	or	r8,r9,r8
80004382:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004384:	0d 98       	ld.ub	r8,r6[0x1]
80004386:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004388:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000438c:	10 0c       	add	r12,r8
8000438e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004390:	58 0c       	cp.w	r12,0
80004392:	e0 89 00 04 	brgt	8000439a <xnl_tx+0x7e>
80004396:	30 09       	mov	r9,0
80004398:	c0 d8       	rjmp	800043b2 <xnl_tx+0x96>
8000439a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000439e:	2f ec       	sub	r12,-2
800043a0:	30 09       	mov	r9,0
800043a2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043a4:	15 1b       	ld.sh	r11,r10++
800043a6:	f6 09 00 09 	add	r9,r11,r9
800043aa:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043ac:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043ae:	18 38       	cp.w	r8,r12
800043b0:	cf a1       	brne	800043a4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043b2:	5c 39       	neg	r9
800043b4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043b6:	48 e8       	lddpc	r8,800043ec <xnl_tx+0xd0>
800043b8:	70 0c       	ld.w	r12,r8[0x0]
800043ba:	f0 1f 00 0e 	mcall	800043f0 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043be:	c1 00       	breq	800043de <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043c0:	fa c7 ff fc 	sub	r7,sp,-4
800043c4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043c6:	e0 6a 01 00 	mov	r10,256
800043ca:	0c 9b       	mov	r11,r6
800043cc:	f0 1f 00 0a 	mcall	800043f4 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043d0:	48 a8       	lddpc	r8,800043f8 <xnl_tx+0xdc>
800043d2:	70 0c       	ld.w	r12,r8[0x0]
800043d4:	30 09       	mov	r9,0
800043d6:	12 9a       	mov	r10,r9
800043d8:	1a 9b       	mov	r11,sp
800043da:	f0 1f 00 09 	mcall	800043fc <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043de:	2f fd       	sub	sp,-4
800043e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043e4:	00 00       	add	r0,r0
800043e6:	0b 4c       	ld.w	r12,--r5
800043e8:	00 00       	add	r0,r0
800043ea:	0b 34       	ld.ub	r4,r5++
800043ec:	00 00       	add	r0,r0
800043ee:	0a b4       	st.h	r5++,r4
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	2b 88       	sub	r8,-72
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	72 8c       	ld.w	r12,r9[0x20]
800043f8:	00 00       	add	r0,r0
800043fa:	0b 40       	ld.w	r0,--r5
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	5e 34       	retlo	r4

80004400 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004400:	eb cd 40 80 	pushm	r7,lr
80004404:	fa cd 01 00 	sub	sp,sp,256
80004408:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000440a:	e0 68 40 0e 	mov	r8,16398
8000440e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004410:	3f f8       	mov	r8,-1
80004412:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004414:	30 c8       	mov	r8,12
80004416:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004418:	98 38       	ld.sh	r8,r12[0x6]
8000441a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000441c:	98 58       	ld.sh	r8,r12[0xa]
8000441e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004420:	98 48       	ld.sh	r8,r12[0x8]
80004422:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004424:	98 68       	ld.sh	r8,r12[0xc]
80004426:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004428:	30 08       	mov	r8,0
8000442a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000442c:	1a 9c       	mov	r12,sp
8000442e:	f0 1f 00 0a 	mcall	80004454 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004432:	fa cd 00 cc 	sub	sp,sp,204
80004436:	e0 6a 00 ca 	mov	r10,202
8000443a:	ee cb ff f0 	sub	r11,r7,-16
8000443e:	1a 9c       	mov	r12,sp
80004440:	f0 1f 00 06 	mcall	80004458 <xnl_data_msg_func+0x58>
80004444:	48 68       	lddpc	r8,8000445c <xnl_data_msg_func+0x5c>
80004446:	70 08       	ld.w	r8,r8[0x0]
80004448:	5d 18       	icall	r8
8000444a:	fa cd ff 34 	sub	sp,sp,-204
}
8000444e:	2c 0d       	sub	sp,-256
80004450:	e3 cd 80 80 	ldm	sp++,r7,pc
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	43 1c       	lddsp	r12,sp[0xc4]
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	72 8c       	ld.w	r12,r9[0x20]
8000445c:	00 00       	add	r0,r0
8000445e:	0b 54       	ld.sh	r4,--r5

80004460 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004460:	d4 21       	pushm	r4-r7,lr
80004462:	fa cd 01 00 	sub	sp,sp,256
80004466:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004468:	4c 28       	lddpc	r8,80004570 <xnl_device_auth_reply_func+0x110>
8000446a:	11 88       	ld.ub	r8,r8[0x0]
8000446c:	58 08       	cp.w	r8,0
8000446e:	e0 81 00 7f 	brne	8000456c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004472:	4c 18       	lddpc	r8,80004574 <xnl_device_auth_reply_func+0x114>
80004474:	70 0c       	ld.w	r12,r8[0x0]
80004476:	30 09       	mov	r9,0
80004478:	12 9a       	mov	r10,r9
8000447a:	12 9b       	mov	r11,r9
8000447c:	f0 1f 00 3f 	mcall	80004578 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004480:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004484:	4b b8       	lddpc	r8,80004570 <xnl_device_auth_reply_func+0x110>
80004486:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004488:	ef 39 00 12 	ld.ub	r9,r7[18]
8000448c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004490:	b1 68       	lsl	r8,0x10
80004492:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004496:	ef 38 00 15 	ld.ub	r8,r7[21]
8000449a:	f3 e8 10 08 	or	r8,r9,r8
8000449e:	ef 39 00 14 	ld.ub	r9,r7[20]
800044a2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800044a6:	ef 3a 00 16 	ld.ub	r10,r7[22]
800044aa:	ef 38 00 17 	ld.ub	r8,r7[23]
800044ae:	b1 68       	lsl	r8,0x10
800044b0:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800044b4:	ef 38 00 19 	ld.ub	r8,r7[25]
800044b8:	f5 e8 10 08 	or	r8,r10,r8
800044bc:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044c0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044c4:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044c6:	e0 64 79 b9 	mov	r4,31161
800044ca:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044ce:	e0 65 45 07 	mov	r5,17671
800044d2:	ea 15 8a bd 	orh	r5,0x8abd
800044d6:	e0 66 f9 3d 	mov	r6,63805
800044da:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044de:	e0 6e b8 cf 	mov	lr,47311
800044e2:	ea 1e 36 83 	orh	lr,0x3683
800044e6:	e0 67 aa 1c 	mov	r7,43548
800044ea:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044ee:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044f0:	f4 08 00 0c 	add	r12,r10,r8
800044f4:	f0 0b 15 04 	lsl	r11,r8,0x4
800044f8:	0a 0b       	add	r11,r5
800044fa:	f9 eb 20 0b 	eor	r11,r12,r11
800044fe:	f0 0c 16 05 	lsr	r12,r8,0x5
80004502:	0c 0c       	add	r12,r6
80004504:	18 5b       	eor	r11,r12
80004506:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004508:	f2 0c 15 04 	lsl	r12,r9,0x4
8000450c:	1c 0c       	add	r12,lr
8000450e:	f2 0b 16 05 	lsr	r11,r9,0x5
80004512:	0e 0b       	add	r11,r7
80004514:	f9 eb 20 0b 	eor	r11,r12,r11
80004518:	f2 0a 00 0c 	add	r12,r9,r10
8000451c:	18 5b       	eor	r11,r12
8000451e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004520:	e0 6b 37 20 	mov	r11,14112
80004524:	ea 1b c6 ef 	orh	r11,0xc6ef
80004528:	16 3a       	cp.w	r10,r11
8000452a:	ce 21       	brne	800044ee <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000452c:	e0 6a 40 1a 	mov	r10,16410
80004530:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004532:	3f fa       	mov	r10,-1
80004534:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004536:	30 6b       	mov	r11,6
80004538:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000453a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000453c:	48 db       	lddpc	r11,80004570 <xnl_device_auth_reply_func+0x110>
8000453e:	96 1c       	ld.sh	r12,r11[0x2]
80004540:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004542:	96 2b       	ld.sh	r11,r11[0x4]
80004544:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004546:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004548:	30 ca       	mov	r10,12
8000454a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000454c:	30 0a       	mov	r10,0
8000454e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004552:	30 7a       	mov	r10,7
80004554:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004558:	30 2a       	mov	r10,2
8000455a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000455e:	fa ca ff ec 	sub	r10,sp,-20
80004562:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004564:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004566:	1a 9c       	mov	r12,sp
80004568:	f0 1f 00 05 	mcall	8000457c <xnl_device_auth_reply_func+0x11c>
}
8000456c:	2c 0d       	sub	sp,-256
8000456e:	d8 22       	popm	r4-r7,pc
80004570:	00 00       	add	r0,r0
80004572:	0b 34       	ld.ub	r4,r5++
80004574:	00 00       	add	r0,r0
80004576:	0b 30       	ld.ub	r0,r5++
80004578:	80 00       	ld.sh	r0,r0[0x0]
8000457a:	5e 34       	retlo	r4
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	43 1c       	lddsp	r12,sp[0xc4]

80004580 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004580:	eb cd 40 80 	pushm	r7,lr
80004584:	fa cd 01 00 	sub	sp,sp,256
80004588:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000458a:	49 28       	lddpc	r8,800045d0 <xnl_master_status_brdcst_func+0x50>
8000458c:	11 88       	ld.ub	r8,r8[0x0]
8000458e:	58 08       	cp.w	r8,0
80004590:	c1 c1       	brne	800045c8 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004592:	49 18       	lddpc	r8,800045d4 <xnl_master_status_brdcst_func+0x54>
80004594:	70 0c       	ld.w	r12,r8[0x0]
80004596:	30 09       	mov	r9,0
80004598:	12 9a       	mov	r10,r9
8000459a:	12 9b       	mov	r11,r9
8000459c:	f0 1f 00 0f 	mcall	800045d8 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800045a0:	8e 58       	ld.sh	r8,r7[0xa]
800045a2:	48 c9       	lddpc	r9,800045d0 <xnl_master_status_brdcst_func+0x50>
800045a4:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045a6:	e0 68 40 0e 	mov	r8,16398
800045aa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045ac:	3f f8       	mov	r8,-1
800045ae:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800045b0:	30 4a       	mov	r10,4
800045b2:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045b4:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045b6:	92 19       	ld.sh	r9,r9[0x2]
800045b8:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800045ba:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045bc:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045be:	30 08       	mov	r8,0
800045c0:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045c2:	1a 9c       	mov	r12,sp
800045c4:	f0 1f 00 06 	mcall	800045dc <xnl_master_status_brdcst_func+0x5c>
}
800045c8:	2c 0d       	sub	sp,-256
800045ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800045ce:	00 00       	add	r0,r0
800045d0:	00 00       	add	r0,r0
800045d2:	0b 34       	ld.ub	r4,r5++
800045d4:	00 00       	add	r0,r0
800045d6:	0b 30       	ld.ub	r0,r5++
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	5e 34       	retlo	r4
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	43 1c       	lddsp	r12,sp[0xc4]

800045e0 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800045e0:	eb cd 40 80 	pushm	r7,lr
800045e4:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800045e6:	49 28       	lddpc	r8,8000462c <xnl_device_conn_reply_func+0x4c>
800045e8:	70 0c       	ld.w	r12,r8[0x0]
800045ea:	30 09       	mov	r9,0
800045ec:	12 9a       	mov	r10,r9
800045ee:	12 9b       	mov	r11,r9
800045f0:	f0 1f 00 10 	mcall	80004630 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045f4:	ef 18 00 10 	ld.uh	r8,r7[16]
800045f8:	10 99       	mov	r9,r8
800045fa:	e2 19 ff 00 	andl	r9,0xff00,COH
800045fe:	e0 49 01 00 	cp.w	r9,256
80004602:	c0 60       	breq	8000460e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004604:	0e 9c       	mov	r12,r7
80004606:	f0 1f 00 0c 	mcall	80004634 <xnl_device_conn_reply_func+0x54>
8000460a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000460e:	a9 68       	lsl	r8,0x8
80004610:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004614:	48 98       	lddpc	r8,80004638 <xnl_device_conn_reply_func+0x58>
80004616:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004618:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000461c:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000461e:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004622:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004624:	30 19       	mov	r9,1
80004626:	b0 89       	st.b	r8[0x0],r9
80004628:	e3 cd 80 80 	ldm	sp++,r7,pc
8000462c:	00 00       	add	r0,r0
8000462e:	0b 30       	ld.ub	r0,r5++
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	5e 34       	retlo	r4
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	45 80       	lddsp	r0,sp[0x160]
80004638:	00 00       	add	r0,r0
8000463a:	0b 34       	ld.ub	r4,r5++

8000463c <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
8000463c:	d4 01       	pushm	lr
8000463e:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004642:	e0 68 40 0e 	mov	r8,16398
80004646:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004648:	3f f8       	mov	r8,-1
8000464a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000464c:	30 38       	mov	r8,3
8000464e:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004650:	30 08       	mov	r8,0
80004652:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004654:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004656:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004658:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000465a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000465c:	1a 9c       	mov	r12,sp
8000465e:	f0 1f 00 03 	mcall	80004668 <xnl_send_device_master_query+0x2c>
}
80004662:	2c 0d       	sub	sp,-256
80004664:	d8 02       	popm	pc
80004666:	00 00       	add	r0,r0
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	43 1c       	lddsp	r12,sp[0xc4]

8000466c <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000466c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000466e:	48 78       	lddpc	r8,80004688 <RC522_SPI_SetSpeed+0x1c>
80004670:	70 09       	ld.w	r9,r8[0x0]
80004672:	72 ca       	ld.w	r10,r9[0x30]
80004674:	5c 7c       	castu.h	r12
80004676:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000467a:	f9 ea 10 0a 	or	r10,r12,r10
8000467e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004680:	70 0c       	ld.w	r12,r8[0x0]
80004682:	f0 1f 00 03 	mcall	8000468c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004686:	d8 02       	popm	pc
80004688:	00 00       	add	r0,r0
8000468a:	1d 80       	ld.ub	r0,lr[0x0]
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	53 24       	stdsp	sp[0xc8],r4

80004690 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004690:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004692:	e0 6c 04 00 	mov	r12,1024
80004696:	f0 1f 00 02 	mcall	8000469c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000469a:	d8 02       	popm	pc
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	46 6c       	lddsp	r12,sp[0x198]

800046a0 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800046a0:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
800046a4:	48 b7       	lddpc	r7,800046d0 <RC522_ReadByte+0x30>
800046a6:	30 0b       	mov	r11,0
800046a8:	6e 0c       	ld.w	r12,r7[0x0]
800046aa:	f0 1f 00 0b 	mcall	800046d4 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046ae:	e0 6b 00 ff 	mov	r11,255
800046b2:	6e 0c       	ld.w	r12,r7[0x0]
800046b4:	f0 1f 00 09 	mcall	800046d8 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800046b8:	30 06       	mov	r6,0
800046ba:	0c 9b       	mov	r11,r6
800046bc:	6e 0c       	ld.w	r12,r7[0x0]
800046be:	f0 1f 00 08 	mcall	800046dc <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046c2:	0c 9b       	mov	r11,r6
800046c4:	6e 0c       	ld.w	r12,r7[0x0]
800046c6:	f0 1f 00 07 	mcall	800046e0 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
800046ca:	0d 9c       	ld.ub	r12,r6[0x1]
800046cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046d0:	00 00       	add	r0,r0
800046d2:	1d 80       	ld.ub	r0,lr[0x0]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	54 90       	stdsp	sp[0x124],r0
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	53 2a       	stdsp	sp[0xc8],r10
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	53 46       	stdsp	sp[0xd0],r6
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	54 50       	stdsp	sp[0x114],r0

800046e4 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800046e4:	eb cd 40 c0 	pushm	r6-r7,lr
800046e8:	20 1d       	sub	sp,4
800046ea:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800046ec:	48 c7       	lddpc	r7,8000471c <RC522_WriteByte+0x38>
800046ee:	30 0b       	mov	r11,0
800046f0:	6e 0c       	ld.w	r12,r7[0x0]
800046f2:	f0 1f 00 0c 	mcall	80004720 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800046f6:	1b 8b       	ld.ub	r11,sp[0x0]
800046f8:	6e 0c       	ld.w	r12,r7[0x0]
800046fa:	f0 1f 00 0b 	mcall	80004724 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800046fe:	1a 9b       	mov	r11,sp
80004700:	6e 0c       	ld.w	r12,r7[0x0]
80004702:	f0 1f 00 0a 	mcall	80004728 <RC522_WriteByte+0x44>
80004706:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004708:	30 0b       	mov	r11,0
8000470a:	6e 0c       	ld.w	r12,r7[0x0]
8000470c:	f0 1f 00 08 	mcall	8000472c <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004710:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004714:	2f fd       	sub	sp,-4
80004716:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000471a:	00 00       	add	r0,r0
8000471c:	00 00       	add	r0,r0
8000471e:	1d 80       	ld.ub	r0,lr[0x0]
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	54 90       	stdsp	sp[0x124],r0
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	53 2a       	stdsp	sp[0xc8],r10
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	53 46       	stdsp	sp[0xd0],r6
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	54 50       	stdsp	sp[0x114],r0

80004730 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004730:	eb cd 40 c0 	pushm	r6-r7,lr
80004734:	18 96       	mov	r6,r12
80004736:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004738:	31 8c       	mov	r12,24
8000473a:	f0 1f 00 09 	mcall	8000475c <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000473e:	ec 0c 15 01 	lsl	r12,r6,0x1
80004742:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004746:	f0 1f 00 07 	mcall	80004760 <WriteRawRC+0x30>
	RC522_WriteByte(value);
8000474a:	0e 9c       	mov	r12,r7
8000474c:	f0 1f 00 05 	mcall	80004760 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004750:	31 8c       	mov	r12,24
80004752:	f0 1f 00 05 	mcall	80004764 <WriteRawRC+0x34>

}
80004756:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000475a:	00 00       	add	r0,r0
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	51 74       	stdsp	sp[0x5c],r4
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	46 e4       	lddsp	r4,sp[0x1b8]
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	51 58       	stdsp	sp[0x54],r8

80004768 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004768:	d4 01       	pushm	lr

	SET_RC522RST;
8000476a:	31 9c       	mov	r12,25
8000476c:	f0 1f 00 1b 	mcall	800047d8 <PcdReset+0x70>
	delay_ns(10);
80004770:	30 ac       	mov	r12,10
80004772:	f0 1f 00 1b 	mcall	800047dc <PcdReset+0x74>

	CLR_RC522RST;
80004776:	31 9c       	mov	r12,25
80004778:	f0 1f 00 1a 	mcall	800047e0 <PcdReset+0x78>
	delay_ns(10);
8000477c:	30 ac       	mov	r12,10
8000477e:	f0 1f 00 18 	mcall	800047dc <PcdReset+0x74>

	SET_RC522RST;
80004782:	31 9c       	mov	r12,25
80004784:	f0 1f 00 15 	mcall	800047d8 <PcdReset+0x70>
	delay_ns(10);
80004788:	30 ac       	mov	r12,10
8000478a:	f0 1f 00 15 	mcall	800047dc <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000478e:	30 fb       	mov	r11,15
80004790:	30 1c       	mov	r12,1
80004792:	f0 1f 00 15 	mcall	800047e4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004796:	30 fb       	mov	r11,15
80004798:	30 1c       	mov	r12,1
8000479a:	f0 1f 00 13 	mcall	800047e4 <PcdReset+0x7c>
	delay_ns(10);
8000479e:	30 ac       	mov	r12,10
800047a0:	f0 1f 00 0f 	mcall	800047dc <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800047a4:	33 db       	mov	r11,61
800047a6:	31 1c       	mov	r12,17
800047a8:	f0 1f 00 0f 	mcall	800047e4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047ac:	31 eb       	mov	r11,30
800047ae:	32 dc       	mov	r12,45
800047b0:	f0 1f 00 0d 	mcall	800047e4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800047b4:	30 0b       	mov	r11,0
800047b6:	32 cc       	mov	r12,44
800047b8:	f0 1f 00 0b 	mcall	800047e4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800047bc:	e0 6b 00 8d 	mov	r11,141
800047c0:	32 ac       	mov	r12,42
800047c2:	f0 1f 00 09 	mcall	800047e4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800047c6:	33 eb       	mov	r11,62
800047c8:	32 bc       	mov	r12,43
800047ca:	f0 1f 00 07 	mcall	800047e4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800047ce:	34 0b       	mov	r11,64
800047d0:	31 5c       	mov	r12,21
800047d2:	f0 1f 00 05 	mcall	800047e4 <PcdReset+0x7c>
	
	return MI_OK;
}
800047d6:	d8 0a       	popm	pc,r12=0
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	51 58       	stdsp	sp[0x54],r8
800047dc:	80 00       	ld.sh	r0,r0[0x0]
800047de:	50 28       	stdsp	sp[0x8],r8
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	51 74       	stdsp	sp[0x5c],r4
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	47 30       	lddsp	r0,sp[0x1cc]

800047e8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800047e8:	eb cd 40 80 	pushm	r7,lr
800047ec:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800047ee:	31 8c       	mov	r12,24
800047f0:	f0 1f 00 0a 	mcall	80004818 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800047f4:	ee 08 15 01 	lsl	r8,r7,0x1
800047f8:	10 9c       	mov	r12,r8
800047fa:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047fe:	a7 bc       	sbr	r12,0x7
80004800:	f0 1f 00 07 	mcall	8000481c <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004804:	f0 1f 00 07 	mcall	80004820 <ReadRawRC+0x38>
80004808:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
8000480a:	31 8c       	mov	r12,24
8000480c:	f0 1f 00 06 	mcall	80004824 <ReadRawRC+0x3c>
	return ucResult;
}
80004810:	0e 9c       	mov	r12,r7
80004812:	e3 cd 80 80 	ldm	sp++,r7,pc
80004816:	00 00       	add	r0,r0
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	51 74       	stdsp	sp[0x5c],r4
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	46 e4       	lddsp	r4,sp[0x1b8]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	46 a0       	lddsp	r0,sp[0x1a8]
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	51 58       	stdsp	sp[0x54],r8

80004828 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004828:	eb cd 40 c0 	pushm	r6-r7,lr
8000482c:	18 97       	mov	r7,r12
8000482e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004830:	f0 1f 00 05 	mcall	80004844 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004834:	f9 e6 10 0b 	or	r11,r12,r6
80004838:	5c 5b       	castu.b	r11
8000483a:	0e 9c       	mov	r12,r7
8000483c:	f0 1f 00 03 	mcall	80004848 <SetBitMask+0x20>
}
80004840:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	47 e8       	lddsp	r8,sp[0x1f8]
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	47 30       	lddsp	r0,sp[0x1cc]

8000484c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
8000484c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000484e:	31 4c       	mov	r12,20
80004850:	f0 1f 00 05 	mcall	80004864 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004854:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004858:	c0 51       	brne	80004862 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000485a:	30 3b       	mov	r11,3
8000485c:	31 4c       	mov	r12,20
8000485e:	f0 1f 00 03 	mcall	80004868 <PcdAntennaOn+0x1c>
80004862:	d8 02       	popm	pc
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	47 e8       	lddsp	r8,sp[0x1f8]
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	48 28       	lddpc	r8,80004870 <ClearBitMask+0x4>

8000486c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
8000486c:	eb cd 40 c0 	pushm	r6-r7,lr
80004870:	18 97       	mov	r7,r12
80004872:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004874:	f0 1f 00 06 	mcall	8000488c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004878:	5c d6       	com	r6
8000487a:	f9 e6 00 06 	and	r6,r12,r6
8000487e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004882:	0e 9c       	mov	r12,r7
80004884:	f0 1f 00 03 	mcall	80004890 <ClearBitMask+0x24>
	
}
80004888:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	47 e8       	lddsp	r8,sp[0x1f8]
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	47 30       	lddsp	r0,sp[0x1cc]

80004894 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004894:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004896:	30 3b       	mov	r11,3
80004898:	31 4c       	mov	r12,20
8000489a:	f0 1f 00 02 	mcall	800048a0 <PcdAntennaOff+0xc>
}
8000489e:	d8 02       	popm	pc
800048a0:	80 00       	ld.sh	r0,r0[0x0]
800048a2:	48 6c       	lddpc	r12,800048b8 <M500PcdConfigISOType+0x14>

800048a4 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800048a4:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800048a6:	34 18       	mov	r8,65
800048a8:	f0 0c 18 00 	cp.b	r12,r8
800048ac:	c0 20       	breq	800048b0 <M500PcdConfigISOType+0xc>
800048ae:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048b0:	30 8b       	mov	r11,8
800048b2:	16 9c       	mov	r12,r11
800048b4:	f0 1f 00 14 	mcall	80004904 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800048b8:	33 db       	mov	r11,61
800048ba:	31 1c       	mov	r12,17
800048bc:	f0 1f 00 13 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800048c0:	e0 6b 00 86 	mov	r11,134
800048c4:	31 7c       	mov	r12,23
800048c6:	f0 1f 00 11 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800048ca:	37 fb       	mov	r11,127
800048cc:	32 6c       	mov	r12,38
800048ce:	f0 1f 00 0f 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800048d2:	31 eb       	mov	r11,30
800048d4:	32 dc       	mov	r12,45
800048d6:	f0 1f 00 0d 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800048da:	30 0b       	mov	r11,0
800048dc:	32 cc       	mov	r12,44
800048de:	f0 1f 00 0b 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800048e2:	e0 6b 00 8d 	mov	r11,141
800048e6:	32 ac       	mov	r12,42
800048e8:	f0 1f 00 08 	mcall	80004908 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800048ec:	33 eb       	mov	r11,62
800048ee:	32 bc       	mov	r12,43
800048f0:	f0 1f 00 06 	mcall	80004908 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800048f4:	e0 6c 03 e8 	mov	r12,1000
800048f8:	f0 1f 00 05 	mcall	8000490c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800048fc:	f0 1f 00 05 	mcall	80004910 <M500PcdConfigISOType+0x6c>
80004900:	d8 0a       	popm	pc,r12=0
80004902:	00 00       	add	r0,r0
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	48 6c       	lddpc	r12,8000491c <rc522_init+0x8>
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	47 30       	lddsp	r0,sp[0x1cc]
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	50 28       	stdsp	sp[0x8],r8
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	48 4c       	lddpc	r12,80004920 <rc522_init+0xc>

80004914 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004914:	eb cd 40 c0 	pushm	r6-r7,lr
80004918:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000491a:	4a 28       	lddpc	r8,800049a0 <rc522_init+0x8c>
8000491c:	1a 96       	mov	r6,sp
8000491e:	f0 ea 00 00 	ld.d	r10,r8[0]
80004922:	fa eb 00 00 	st.d	sp[0],r10
80004926:	f0 e8 00 08 	ld.d	r8,r8[8]
8000492a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
8000492e:	30 4b       	mov	r11,4
80004930:	49 dc       	lddpc	r12,800049a4 <rc522_init+0x90>
80004932:	f0 1f 00 1e 	mcall	800049a8 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004936:	31 9c       	mov	r12,25
80004938:	f0 1f 00 1d 	mcall	800049ac <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
8000493c:	31 9c       	mov	r12,25
8000493e:	f0 1f 00 1d 	mcall	800049b0 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004942:	49 d7       	lddpc	r7,800049b4 <rc522_init+0xa0>
80004944:	fe 7c 24 00 	mov	r12,-56320
80004948:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000494a:	1a 9b       	mov	r11,sp
8000494c:	f0 1f 00 1b 	mcall	800049b8 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004950:	30 09       	mov	r9,0
80004952:	12 9a       	mov	r10,r9
80004954:	12 9b       	mov	r11,r9
80004956:	6e 0c       	ld.w	r12,r7[0x0]
80004958:	f0 1f 00 19 	mcall	800049bc <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
8000495c:	6e 0c       	ld.w	r12,r7[0x0]
8000495e:	f0 1f 00 19 	mcall	800049c0 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004962:	e0 6a 36 00 	mov	r10,13824
80004966:	ea 1a 01 6e 	orh	r10,0x16e
8000496a:	1a 9b       	mov	r11,sp
8000496c:	6e 0c       	ld.w	r12,r7[0x0]
8000496e:	f0 1f 00 16 	mcall	800049c4 <rc522_init+0xb0>
80004972:	c0 50       	breq	8000497c <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004974:	30 29       	mov	r9,2
80004976:	49 58       	lddpc	r8,800049c8 <rc522_init+0xb4>
80004978:	b0 89       	st.b	r8[0x0],r9
8000497a:	c0 38       	rjmp	80004980 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
8000497c:	f0 1f 00 14 	mcall	800049cc <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004980:	f0 1f 00 14 	mcall	800049d0 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004984:	f0 1f 00 14 	mcall	800049d4 <rc522_init+0xc0>
	
	delay_ms(2); 
80004988:	30 2c       	mov	r12,2
8000498a:	f0 1f 00 14 	mcall	800049d8 <rc522_init+0xc4>
	
	PcdAntennaOn();
8000498e:	f0 1f 00 14 	mcall	800049dc <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004992:	34 1c       	mov	r12,65
80004994:	f0 1f 00 13 	mcall	800049e0 <rc522_init+0xcc>
	

80004998:	2f cd       	sub	sp,-16
8000499a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000499e:	00 00       	add	r0,r0
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	d1 74       	*unknown*
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	d1 4c       	*unknown*
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	51 10       	stdsp	sp[0x44],r0
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	51 40       	stdsp	sp[0x50],r0
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	51 58       	stdsp	sp[0x54],r8
800049b4:	00 00       	add	r0,r0
800049b6:	1d 80       	ld.ub	r0,lr[0x0]
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	52 c0       	stdsp	sp[0xb0],r0
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	52 f8       	stdsp	sp[0xbc],r8
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	53 24       	stdsp	sp[0xc8],r4
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	53 68       	stdsp	sp[0xd8],r8
800049c8:	00 00       	add	r0,r0
800049ca:	0b 58       	ld.sh	r8,--r5
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	46 90       	lddsp	r0,sp[0x1a4]
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	47 68       	lddsp	r8,sp[0x1d8]
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 94       	lddpc	r4,800049f8 <PcdComMF522+0x14>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	50 68       	stdsp	sp[0x18],r8
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	48 4c       	lddpc	r12,800049ec <PcdComMF522+0x8>
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	48 a4       	lddpc	r4,80004a08 <PcdComMF522+0x24>

800049e4 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
800049e4:	d4 31       	pushm	r0-r7,lr
800049e6:	20 1d       	sub	sp,4
800049e8:	18 92       	mov	r2,r12
800049ea:	16 95       	mov	r5,r11
800049ec:	14 96       	mov	r6,r10
800049ee:	50 09       	stdsp	sp[0x0],r9
800049f0:	10 90       	mov	r0,r8
800049f2:	f8 c8 00 0c 	sub	r8,r12,12
800049f6:	5c 58       	castu.b	r8
800049f8:	30 29       	mov	r9,2
800049fa:	f2 08 18 00 	cp.b	r8,r9
800049fe:	e0 88 00 05 	brls	80004a08 <PcdComMF522+0x24>
80004a02:	30 03       	mov	r3,0
80004a04:	06 91       	mov	r1,r3
80004a06:	c0 78       	rjmp	80004a14 <PcdComMF522+0x30>
80004a08:	4c f9       	lddpc	r9,80004b44 <PcdComMF522+0x160>
80004a0a:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a0e:	4c f9       	lddpc	r9,80004b48 <PcdComMF522+0x164>
80004a10:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a14:	02 9b       	mov	r11,r1
80004a16:	a7 bb       	sbr	r11,0x7
80004a18:	30 2c       	mov	r12,2
80004a1a:	f0 1f 00 4d 	mcall	80004b4c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a1e:	e0 6b 00 80 	mov	r11,128
80004a22:	30 4c       	mov	r12,4
80004a24:	f0 1f 00 4b 	mcall	80004b50 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a28:	30 0b       	mov	r11,0
80004a2a:	30 1c       	mov	r12,1
80004a2c:	f0 1f 00 48 	mcall	80004b4c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a30:	e0 6b 00 80 	mov	r11,128
80004a34:	30 ac       	mov	r12,10
80004a36:	f0 1f 00 48 	mcall	80004b54 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a3a:	58 06       	cp.w	r6,0
80004a3c:	c0 c0       	breq	80004a54 <PcdComMF522+0x70>
80004a3e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a40:	30 94       	mov	r4,9
80004a42:	0f 3b       	ld.ub	r11,r7++
80004a44:	08 9c       	mov	r12,r4
80004a46:	f0 1f 00 42 	mcall	80004b4c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a4a:	0e 98       	mov	r8,r7
80004a4c:	0a 18       	sub	r8,r5
80004a4e:	ec 08 19 00 	cp.h	r8,r6
80004a52:	cf 83       	brcs	80004a42 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004a54:	04 9b       	mov	r11,r2
80004a56:	30 1c       	mov	r12,1
80004a58:	f0 1f 00 3d 	mcall	80004b4c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004a5c:	30 c8       	mov	r8,12
80004a5e:	f0 02 18 00 	cp.b	r2,r8
80004a62:	c0 61       	brne	80004a6e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004a64:	e0 6b 00 80 	mov	r11,128
80004a68:	30 dc       	mov	r12,13
80004a6a:	f0 1f 00 3b 	mcall	80004b54 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a6e:	30 4c       	mov	r12,4
80004a70:	f0 1f 00 3a 	mcall	80004b58 <PcdComMF522+0x174>
80004a74:	18 97       	mov	r7,r12
80004a76:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a7a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a7c:	30 44       	mov	r4,4
80004a7e:	c0 88       	rjmp	80004a8e <PcdComMF522+0xaa>
80004a80:	08 9c       	mov	r12,r4
80004a82:	f0 1f 00 36 	mcall	80004b58 <PcdComMF522+0x174>
80004a86:	18 97       	mov	r7,r12
		i--;
80004a88:	20 16       	sub	r6,1
80004a8a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a8c:	c0 a0       	breq	80004aa0 <PcdComMF522+0xbc>
80004a8e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004a92:	c4 c1       	brne	80004b2a <PcdComMF522+0x146>
80004a94:	ef e3 00 08 	and	r8,r7,r3
80004a98:	ea 08 18 00 	cp.b	r8,r5
80004a9c:	cf 20       	breq	80004a80 <PcdComMF522+0x9c>
80004a9e:	c4 68       	rjmp	80004b2a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004aa0:	e0 6b 00 80 	mov	r11,128
80004aa4:	30 dc       	mov	r12,13
80004aa6:	f0 1f 00 2b 	mcall	80004b50 <PcdComMF522+0x16c>
80004aaa:	30 27       	mov	r7,2
80004aac:	c3 38       	rjmp	80004b12 <PcdComMF522+0x12e>
80004aae:	02 67       	and	r7,r1
80004ab0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ab4:	30 c8       	mov	r8,12
80004ab6:	f0 02 18 00 	cp.b	r2,r8
80004aba:	c2 c1       	brne	80004b12 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004abc:	30 ac       	mov	r12,10
80004abe:	f0 1f 00 27 	mcall	80004b58 <PcdComMF522+0x174>
80004ac2:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004ac4:	30 cc       	mov	r12,12
80004ac6:	f0 1f 00 25 	mcall	80004b58 <PcdComMF522+0x174>
80004aca:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004ace:	c0 70       	breq	80004adc <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004ad0:	08 98       	mov	r8,r4
80004ad2:	20 18       	sub	r8,1
80004ad4:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004ad8:	a0 8c       	st.b	r0[0x0],r12
80004ada:	c0 48       	rjmp	80004ae2 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004adc:	e8 08 15 03 	lsl	r8,r4,0x3
80004ae0:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004ae2:	58 04       	cp.w	r4,0
80004ae4:	c0 61       	brne	80004af0 <PcdComMF522+0x10c>
80004ae6:	30 14       	mov	r4,1
80004ae8:	40 05       	lddsp	r5,sp[0x0]
80004aea:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004aec:	30 93       	mov	r3,9
80004aee:	c0 98       	rjmp	80004b00 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004af0:	31 28       	mov	r8,18
80004af2:	f0 04 18 00 	cp.b	r4,r8
80004af6:	f9 b4 0b 12 	movhi	r4,18
80004afa:	58 04       	cp.w	r4,0
80004afc:	cf 61       	brne	80004ae8 <PcdComMF522+0x104>
80004afe:	c0 a8       	rjmp	80004b12 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b00:	06 9c       	mov	r12,r3
80004b02:	f0 1f 00 16 	mcall	80004b58 <PcdComMF522+0x174>
80004b06:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b08:	ec 05 01 08 	sub	r8,r6,r5
80004b0c:	e8 08 19 00 	cp.h	r8,r4
80004b10:	cf 83       	brcs	80004b00 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b12:	e0 6b 00 80 	mov	r11,128
80004b16:	30 cc       	mov	r12,12
80004b18:	f0 1f 00 0f 	mcall	80004b54 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b1c:	30 0b       	mov	r11,0
80004b1e:	30 1c       	mov	r12,1
80004b20:	f0 1f 00 0b 	mcall	80004b4c <PcdComMF522+0x168>
	return status;
}
80004b24:	0e 9c       	mov	r12,r7
80004b26:	2f fd       	sub	sp,-4
80004b28:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b2a:	e0 6b 00 80 	mov	r11,128
80004b2e:	30 dc       	mov	r12,13
80004b30:	f0 1f 00 08 	mcall	80004b50 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b34:	30 6c       	mov	r12,6
80004b36:	f0 1f 00 09 	mcall	80004b58 <PcdComMF522+0x174>
80004b3a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b3e:	cb 80       	breq	80004aae <PcdComMF522+0xca>
80004b40:	30 27       	mov	r7,2
80004b42:	ce 8b       	rjmp	80004b12 <PcdComMF522+0x12e>
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	d1 6c       	*unknown*
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	d1 70       	acall	0x17
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	47 30       	lddsp	r0,sp[0x1cc]
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	48 6c       	lddpc	r12,80004b68 <PcdAnticoll+0xc>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	48 28       	lddpc	r8,80004b5c <PcdAnticoll>
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	47 e8       	lddsp	r8,sp[0x1f8]

80004b5c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004b5c:	eb cd 40 c0 	pushm	r6-r7,lr
80004b60:	20 5d       	sub	sp,20
80004b62:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004b64:	30 8b       	mov	r11,8
80004b66:	16 9c       	mov	r12,r11
80004b68:	f0 1f 00 1a 	mcall	80004bd0 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004b6c:	30 0b       	mov	r11,0
80004b6e:	30 dc       	mov	r12,13
80004b70:	f0 1f 00 19 	mcall	80004bd4 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004b74:	e0 6b 00 80 	mov	r11,128
80004b78:	30 ec       	mov	r12,14
80004b7a:	f0 1f 00 16 	mcall	80004bd0 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004b7e:	39 38       	mov	r8,-109
80004b80:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004b82:	32 08       	mov	r8,32
80004b84:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004b86:	1a 9b       	mov	r11,sp
80004b88:	fa c8 ff ed 	sub	r8,sp,-19
80004b8c:	1a 99       	mov	r9,sp
80004b8e:	30 2a       	mov	r10,2
80004b90:	30 cc       	mov	r12,12
80004b92:	f0 1f 00 12 	mcall	80004bd8 <PcdAnticoll+0x7c>
80004b96:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004b98:	c1 21       	brne	80004bbc <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004b9a:	1b 89       	ld.ub	r9,sp[0x0]
80004b9c:	ac 89       	st.b	r6[0x0],r9
80004b9e:	1b 98       	ld.ub	r8,sp[0x1]
80004ba0:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004ba2:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ba4:	1b a8       	ld.ub	r8,sp[0x2]
80004ba6:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004ba8:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bac:	1b b9       	ld.ub	r9,sp[0x3]
80004bae:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004bb0:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004bb2:	1b c9       	ld.ub	r9,sp[0x4]
80004bb4:	f0 09 18 00 	cp.b	r9,r8
80004bb8:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004bbc:	e0 6b 00 80 	mov	r11,128
80004bc0:	30 ec       	mov	r12,14
80004bc2:	f0 1f 00 07 	mcall	80004bdc <PcdAnticoll+0x80>
	return status;
}
80004bc6:	0e 9c       	mov	r12,r7
80004bc8:	2f bd       	sub	sp,-20
80004bca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bce:	00 00       	add	r0,r0
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	48 6c       	lddpc	r12,80004be8 <PcdRequest+0x8>
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	47 30       	lddsp	r0,sp[0x1cc]
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	49 e4       	lddpc	r4,80004c50 <CalulateCRC+0xc>
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	48 28       	lddpc	r8,80004be4 <PcdRequest+0x4>

80004be0 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004be0:	eb cd 40 c0 	pushm	r6-r7,lr
80004be4:	20 5d       	sub	sp,20
80004be6:	18 97       	mov	r7,r12
80004be8:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004bea:	30 8b       	mov	r11,8
80004bec:	16 9c       	mov	r12,r11
80004bee:	f0 1f 00 12 	mcall	80004c34 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004bf2:	30 7b       	mov	r11,7
80004bf4:	30 dc       	mov	r12,13
80004bf6:	f0 1f 00 11 	mcall	80004c38 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004bfa:	30 3b       	mov	r11,3
80004bfc:	31 4c       	mov	r12,20
80004bfe:	f0 1f 00 10 	mcall	80004c3c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004c02:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004c04:	1a 9b       	mov	r11,sp
80004c06:	fa c8 ff ed 	sub	r8,sp,-19
80004c0a:	1a 99       	mov	r9,sp
80004c0c:	30 1a       	mov	r10,1
80004c0e:	30 cc       	mov	r12,12
80004c10:	f0 1f 00 0c 	mcall	80004c40 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c14:	c0 c1       	brne	80004c2c <PcdRequest+0x4c>
80004c16:	31 08       	mov	r8,16
80004c18:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c1c:	f0 09 18 00 	cp.b	r9,r8
80004c20:	c0 61       	brne	80004c2c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c22:	1b 88       	ld.ub	r8,sp[0x0]
80004c24:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c26:	1b 98       	ld.ub	r8,sp[0x1]
80004c28:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c2a:	c0 28       	rjmp	80004c2e <PcdRequest+0x4e>
80004c2c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c2e:	2f bd       	sub	sp,-20
80004c30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	48 6c       	lddpc	r12,80004c4c <CalulateCRC+0x8>
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	47 30       	lddsp	r0,sp[0x1cc]
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	48 28       	lddpc	r8,80004c44 <CalulateCRC>
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	49 e4       	lddpc	r4,80004cb8 <CalulateCRC+0x74>

80004c44 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c44:	eb cd 40 f8 	pushm	r3-r7,lr
80004c48:	18 95       	mov	r5,r12
80004c4a:	16 96       	mov	r6,r11
80004c4c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c4e:	30 4b       	mov	r11,4
80004c50:	30 5c       	mov	r12,5
80004c52:	f0 1f 00 1c 	mcall	80004cc0 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c56:	30 0b       	mov	r11,0
80004c58:	30 1c       	mov	r12,1
80004c5a:	f0 1f 00 1b 	mcall	80004cc4 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004c5e:	e0 6b 00 80 	mov	r11,128
80004c62:	30 ac       	mov	r12,10
80004c64:	f0 1f 00 19 	mcall	80004cc8 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004c68:	58 06       	cp.w	r6,0
80004c6a:	c0 c0       	breq	80004c82 <CalulateCRC+0x3e>
80004c6c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004c6e:	30 94       	mov	r4,9
80004c70:	0f 3b       	ld.ub	r11,r7++
80004c72:	08 9c       	mov	r12,r4
80004c74:	f0 1f 00 14 	mcall	80004cc4 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004c78:	0e 98       	mov	r8,r7
80004c7a:	0a 18       	sub	r8,r5
80004c7c:	ec 08 18 00 	cp.b	r8,r6
80004c80:	cf 83       	brcs	80004c70 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004c82:	30 3b       	mov	r11,3
80004c84:	30 1c       	mov	r12,1
80004c86:	f0 1f 00 10 	mcall	80004cc4 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004c8a:	30 5c       	mov	r12,5
80004c8c:	f0 1f 00 10 	mcall	80004ccc <CalulateCRC+0x88>
80004c90:	e0 67 00 fe 	mov	r7,254
80004c94:	30 56       	mov	r6,5
80004c96:	c0 78       	rjmp	80004ca4 <CalulateCRC+0x60>
80004c98:	0c 9c       	mov	r12,r6
80004c9a:	f0 1f 00 0d 	mcall	80004ccc <CalulateCRC+0x88>
		i--;
80004c9e:	20 17       	sub	r7,1
80004ca0:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004ca2:	c0 40       	breq	80004caa <CalulateCRC+0x66>
80004ca4:	e2 1c 00 04 	andl	r12,0x4,COH
80004ca8:	cf 80       	breq	80004c98 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004caa:	32 2c       	mov	r12,34
80004cac:	f0 1f 00 08 	mcall	80004ccc <CalulateCRC+0x88>
80004cb0:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004cb2:	32 1c       	mov	r12,33
80004cb4:	f0 1f 00 06 	mcall	80004ccc <CalulateCRC+0x88>
80004cb8:	a6 9c       	st.b	r3[0x1],r12
}
80004cba:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004cbe:	00 00       	add	r0,r0
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	48 6c       	lddpc	r12,80004cd8 <PcdSelect+0x8>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	47 30       	lddsp	r0,sp[0x1cc]
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	48 28       	lddpc	r8,80004cd0 <PcdSelect>
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	47 e8       	lddsp	r8,sp[0x1f8]

80004cd0 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004cd0:	eb cd 40 80 	pushm	r7,lr
80004cd4:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cd6:	39 38       	mov	r8,-109
80004cd8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004cda:	37 08       	mov	r8,112
80004cdc:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004cde:	30 08       	mov	r8,0
80004ce0:	ba e8       	st.b	sp[0x6],r8
80004ce2:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004ce6:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004cea:	19 89       	ld.ub	r9,r12[0x0]
80004cec:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004cee:	19 3a       	ld.ub	r10,r12++
80004cf0:	1b e9       	ld.ub	r9,sp[0x6]
80004cf2:	f5 e9 20 09 	eor	r9,r10,r9
80004cf6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004cf8:	16 38       	cp.w	r8,r11
80004cfa:	cf 81       	brne	80004cea <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004cfc:	1a 97       	mov	r7,sp
80004cfe:	fa ca ff f9 	sub	r10,sp,-7
80004d02:	30 7b       	mov	r11,7
80004d04:	1a 9c       	mov	r12,sp
80004d06:	f0 1f 00 0d 	mcall	80004d38 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004d0a:	30 8b       	mov	r11,8
80004d0c:	16 9c       	mov	r12,r11
80004d0e:	f0 1f 00 0c 	mcall	80004d3c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d12:	fa c8 ff ed 	sub	r8,sp,-19
80004d16:	1a 99       	mov	r9,sp
80004d18:	30 9a       	mov	r10,9
80004d1a:	1a 9b       	mov	r11,sp
80004d1c:	30 cc       	mov	r12,12
80004d1e:	f0 1f 00 09 	mcall	80004d40 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d22:	c0 71       	brne	80004d30 <PcdSelect+0x60>
80004d24:	31 88       	mov	r8,24
80004d26:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d2a:	f0 09 18 00 	cp.b	r9,r8
80004d2e:	c0 20       	breq	80004d32 <PcdSelect+0x62>
80004d30:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d32:	2f bd       	sub	sp,-20
80004d34:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	4c 44       	lddpc	r4,80004e48 <rfid_auto_reader+0x104>
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	48 6c       	lddpc	r12,80004d54 <rfid_auto_reader+0x10>
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	49 e4       	lddpc	r4,80004db8 <rfid_auto_reader+0x74>

80004d44 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d44:	eb cd 40 c0 	pushm	r6-r7,lr
80004d48:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d4a:	f0 1f 00 37 	mcall	80004e24 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d4e:	4b 7b       	lddpc	r11,80004e28 <rfid_auto_reader+0xe4>
80004d50:	35 2c       	mov	r12,82
80004d52:	f0 1f 00 37 	mcall	80004e2c <rfid_auto_reader+0xe8>
80004d56:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004d58:	c6 31       	brne	80004e1e <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d5a:	4b 48       	lddpc	r8,80004e28 <rfid_auto_reader+0xe4>
80004d5c:	11 88       	ld.ub	r8,r8[0x0]
80004d5e:	30 49       	mov	r9,4
80004d60:	f2 08 18 00 	cp.b	r8,r9
80004d64:	c0 b1       	brne	80004d7a <rfid_auto_reader+0x36>
80004d66:	4b 19       	lddpc	r9,80004e28 <rfid_auto_reader+0xe4>
80004d68:	13 9a       	ld.ub	r10,r9[0x1]
80004d6a:	30 09       	mov	r9,0
80004d6c:	f2 0a 18 00 	cp.b	r10,r9
80004d70:	c0 51       	brne	80004d7a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004d72:	4b 0c       	lddpc	r12,80004e30 <rfid_auto_reader+0xec>
80004d74:	f0 1f 00 30 	mcall	80004e34 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d78:	c3 c8       	rjmp	80004df0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d7a:	30 29       	mov	r9,2
80004d7c:	f2 08 18 00 	cp.b	r8,r9
80004d80:	c0 b1       	brne	80004d96 <rfid_auto_reader+0x52>
80004d82:	4a a9       	lddpc	r9,80004e28 <rfid_auto_reader+0xe4>
80004d84:	13 9a       	ld.ub	r10,r9[0x1]
80004d86:	30 09       	mov	r9,0
80004d88:	f2 0a 18 00 	cp.b	r10,r9
80004d8c:	c0 51       	brne	80004d96 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004d8e:	4a bc       	lddpc	r12,80004e38 <rfid_auto_reader+0xf4>
80004d90:	f0 1f 00 29 	mcall	80004e34 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d94:	c2 e8       	rjmp	80004df0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004d96:	34 49       	mov	r9,68
80004d98:	f2 08 18 00 	cp.b	r8,r9
80004d9c:	c0 b1       	brne	80004db2 <rfid_auto_reader+0x6e>
80004d9e:	4a 39       	lddpc	r9,80004e28 <rfid_auto_reader+0xe4>
80004da0:	13 9a       	ld.ub	r10,r9[0x1]
80004da2:	30 09       	mov	r9,0
80004da4:	f2 0a 18 00 	cp.b	r10,r9
80004da8:	c0 51       	brne	80004db2 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004daa:	4a 5c       	lddpc	r12,80004e3c <rfid_auto_reader+0xf8>
80004dac:	f0 1f 00 22 	mcall	80004e34 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004db0:	c2 08       	rjmp	80004df0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004db2:	30 89       	mov	r9,8
80004db4:	f2 08 18 00 	cp.b	r8,r9
80004db8:	c0 b1       	brne	80004dce <rfid_auto_reader+0x8a>
80004dba:	49 c9       	lddpc	r9,80004e28 <rfid_auto_reader+0xe4>
80004dbc:	13 9a       	ld.ub	r10,r9[0x1]
80004dbe:	30 09       	mov	r9,0
80004dc0:	f2 0a 18 00 	cp.b	r10,r9
80004dc4:	c0 51       	brne	80004dce <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004dc6:	49 fc       	lddpc	r12,80004e40 <rfid_auto_reader+0xfc>
80004dc8:	f0 1f 00 1b 	mcall	80004e34 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dcc:	c1 28       	rjmp	80004df0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004dce:	34 49       	mov	r9,68
80004dd0:	f2 08 18 00 	cp.b	r8,r9
80004dd4:	c0 b1       	brne	80004dea <rfid_auto_reader+0xa6>
80004dd6:	49 58       	lddpc	r8,80004e28 <rfid_auto_reader+0xe4>
80004dd8:	11 99       	ld.ub	r9,r8[0x1]
80004dda:	30 38       	mov	r8,3
80004ddc:	f0 09 18 00 	cp.b	r9,r8
80004de0:	c0 51       	brne	80004dea <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004de2:	49 9c       	lddpc	r12,80004e44 <rfid_auto_reader+0x100>
80004de4:	f0 1f 00 14 	mcall	80004e34 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004de8:	c0 48       	rjmp	80004df0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004dea:	49 8c       	lddpc	r12,80004e48 <rfid_auto_reader+0x104>
80004dec:	f0 1f 00 12 	mcall	80004e34 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004df0:	49 7c       	lddpc	r12,80004e4c <rfid_auto_reader+0x108>
80004df2:	f0 1f 00 18 	mcall	80004e50 <rfid_auto_reader+0x10c>
80004df6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004df8:	c0 60       	breq	80004e04 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004dfa:	37 8b       	mov	r11,120
80004dfc:	30 1c       	mov	r12,1
80004dfe:	f0 1f 00 16 	mcall	80004e54 <rfid_auto_reader+0x110>
		return status;
80004e02:	c0 e8       	rjmp	80004e1e <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004e04:	49 2c       	lddpc	r12,80004e4c <rfid_auto_reader+0x108>
80004e06:	f0 1f 00 15 	mcall	80004e58 <rfid_auto_reader+0x114>
80004e0a:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004e0c:	c0 91       	brne	80004e1e <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e0e:	30 4a       	mov	r10,4
80004e10:	48 fb       	lddpc	r11,80004e4c <rfid_auto_reader+0x108>
80004e12:	0c 9c       	mov	r12,r6
80004e14:	f0 1f 00 12 	mcall	80004e5c <rfid_auto_reader+0x118>
		log("select okay\n");
80004e18:	49 2c       	lddpc	r12,80004e60 <rfid_auto_reader+0x11c>
80004e1a:	f0 1f 00 07 	mcall	80004e34 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004e1e:	0e 9c       	mov	r12,r7
80004e20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	47 68       	lddsp	r8,sp[0x1d8]
80004e28:	00 00       	add	r0,r0
80004e2a:	51 08       	stdsp	sp[0x40],r8
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4b e0       	lddpc	r0,80004f24 <rfid_sendID_message+0xc0>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	d1 84       	*unknown*
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	6a 14       	ld.w	r4,r5[0x4]
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	d1 90       	acall	0x19
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	d1 9c       	*unknown*
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	d1 ac       	*unknown*
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	d1 b4       	*unknown*
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	d1 c0       	acall	0x1c
80004e4c:	00 00       	add	r0,r0
80004e4e:	51 0c       	stdsp	sp[0x40],r12
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	4b 5c       	lddpc	r12,80004f24 <rfid_sendID_message+0xc0>
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	3e 90       	mov	r0,-23
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	4c d0       	lddpc	r0,80004f8c <rfid_sendID_message+0x128>
80004e5c:	80 00       	ld.sh	r0,r0[0x0]
80004e5e:	72 8c       	ld.w	r12,r9[0x20]
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	d1 cc       	*unknown*

80004e64 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80004e64:	eb cd 40 e0 	pushm	r5-r7,lr
80004e68:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004e6a:	fa ca ff a4 	sub	r10,sp,-92
80004e6e:	30 08       	mov	r8,0
80004e70:	30 09       	mov	r9,0
80004e72:	f4 e9 00 00 	st.d	r10[0],r8
80004e76:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80004e7a:	fa cc ff 94 	sub	r12,sp,-108
80004e7e:	f8 e9 00 00 	st.d	r12[0],r8
80004e82:	30 0a       	mov	r10,0
80004e84:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004e86:	fa e9 00 0c 	st.d	sp[12],r8
80004e8a:	fa e9 00 14 	st.d	sp[20],r8
80004e8e:	fa e9 00 1c 	st.d	sp[28],r8
80004e92:	fa e9 00 24 	st.d	sp[36],r8
80004e96:	fa e9 00 2c 	st.d	sp[44],r8
80004e9a:	fa e9 00 34 	st.d	sp[52],r8
80004e9e:	fa e9 00 3c 	st.d	sp[60],r8
80004ea2:	fa e9 00 44 	st.d	sp[68],r8
80004ea6:	fa e9 00 4c 	st.d	sp[76],r8
80004eaa:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
80004eae:	f0 1f 00 3f 	mcall	80004fa8 <rfid_sendID_message+0x144>
80004eb2:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004eb4:	c6 e1       	brne	80004f90 <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004eb6:	fb 38 00 6f 	ld.ub	r8,sp[111]
80004eba:	1a d8       	st.w	--sp,r8
80004ebc:	fb 38 00 72 	ld.ub	r8,sp[114]
80004ec0:	1a d8       	st.w	--sp,r8
80004ec2:	fb 38 00 75 	ld.ub	r8,sp[117]
80004ec6:	1a d8       	st.w	--sp,r8
80004ec8:	fb 38 00 78 	ld.ub	r8,sp[120]
80004ecc:	1a d8       	st.w	--sp,r8
80004ece:	4b 8c       	lddpc	r12,80004fac <rfid_sendID_message+0x148>
80004ed0:	f0 1f 00 38 	mcall	80004fb0 <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80004ed4:	37 7b       	mov	r11,119
80004ed6:	30 1c       	mov	r12,1
80004ed8:	f0 1f 00 37 	mcall	80004fb4 <rfid_sendID_message+0x150>
80004edc:	fa c9 ff 84 	sub	r9,sp,-124
80004ee0:	fa c8 ff 94 	sub	r8,sp,-108
80004ee4:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80004ee8:	fa c5 ff 80 	sub	r5,sp,-128
80004eec:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004eee:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80004ef0:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004ef2:	13 8b       	ld.ub	r11,r9[0x0]
80004ef4:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004ef8:	fc 0c 18 00 	cp.b	r12,lr
80004efc:	f7 bc 08 d0 	subls	r12,-48
80004f00:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80004f04:	f7 bc 0b a9 	subhi	r12,-87
80004f08:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
80004f0c:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f0e:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80004f12:	fc 0b 18 00 	cp.b	r11,lr
80004f16:	f7 bb 08 d0 	subls	r11,-48
80004f1a:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80004f1e:	f7 bb 0b a9 	subhi	r11,-87
80004f22:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80004f26:	b0 b6       	st.b	r8[0x3],r6
80004f28:	2f f9       	sub	r9,-1
80004f2a:	2f c8       	sub	r8,-4
80004f2c:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f2e:	0a 39       	cp.w	r9,r5
80004f30:	ce 11       	brne	80004ef2 <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f32:	4a 28       	lddpc	r8,80004fb8 <rfid_sendID_message+0x154>
80004f34:	11 89       	ld.ub	r9,r8[0x0]
80004f36:	39 f8       	mov	r8,-97
80004f38:	f0 09 18 00 	cp.b	r9,r8
80004f3c:	e0 88 00 05 	brls	80004f46 <rfid_sendID_message+0xe2>
80004f40:	38 09       	mov	r9,-128
80004f42:	49 e8       	lddpc	r8,80004fb8 <rfid_sendID_message+0x154>
80004f44:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f46:	49 d8       	lddpc	r8,80004fb8 <rfid_sendID_message+0x154>
80004f48:	11 86       	ld.ub	r6,r8[0x0]
80004f4a:	2f f6       	sub	r6,-1
80004f4c:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f4e:	30 5a       	mov	r10,5
80004f50:	49 bb       	lddpc	r11,80004fbc <rfid_sendID_message+0x158>
80004f52:	fa cc ff f9 	sub	r12,sp,-7
80004f56:	f0 1f 00 1b 	mcall	80004fc0 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f5a:	31 88       	mov	r8,24
80004f5c:	ba 18       	st.h	sp[0x2],r8
80004f5e:	ba e6       	st.b	sp[0x6],r6
80004f60:	fe 78 e0 00 	mov	r8,-8192
80004f64:	ba 28       	st.h	sp[0x4],r8
80004f66:	fa c6 ff f4 	sub	r6,sp,-12
80004f6a:	30 aa       	mov	r10,10
80004f6c:	fa cb ff fe 	sub	r11,sp,-2
80004f70:	0c 9c       	mov	r12,r6
80004f72:	f0 1f 00 14 	mcall	80004fc0 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80004f76:	31 0a       	mov	r10,16
80004f78:	fa cb ff a4 	sub	r11,sp,-92
80004f7c:	fa cc ff ea 	sub	r12,sp,-22
80004f80:	f0 1f 00 10 	mcall	80004fc0 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80004f84:	30 9a       	mov	r10,9
80004f86:	31 ab       	mov	r11,26
80004f88:	0c 9c       	mov	r12,r6
80004f8a:	f0 1f 00 0f 	mcall	80004fc4 <rfid_sendID_message+0x160>
80004f8e:	c0 88       	rjmp	80004f9e <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80004f90:	37 8b       	mov	r11,120
80004f92:	30 1c       	mov	r12,1
80004f94:	f0 1f 00 08 	mcall	80004fb4 <rfid_sendID_message+0x150>
		log("no card find...\n");
80004f98:	48 cc       	lddpc	r12,80004fc8 <rfid_sendID_message+0x164>
80004f9a:	f0 1f 00 06 	mcall	80004fb0 <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
80004f9e:	0e 9c       	mov	r12,r7
80004fa0:	2e 2d       	sub	sp,-120
80004fa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004fa6:	00 00       	add	r0,r0
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	4d 44       	lddpc	r4,800050f8 <gpio_enable_module_pin+0x3c>
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	d1 dc       	*unknown*
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	6a 14       	ld.w	r4,r5[0x4]
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	3e 90       	mov	r0,-23
80004fb8:	00 00       	add	r0,r0
80004fba:	05 2c       	ld.uh	r12,r2++
80004fbc:	00 00       	add	r0,r0
80004fbe:	05 24       	ld.uh	r4,r2++
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	72 8c       	ld.w	r12,r9[0x20]
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	3d 58       	mov	r8,-43
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	d1 f8       	*unknown*

80004fcc <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004fcc:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004fce:	f0 1f 00 02 	mcall	80004fd4 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80004fd2:	d8 02       	popm	pc
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	49 14       	lddpc	r4,80005018 <local_start_pll0+0x40>

80004fd8 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004fd8:	fe 78 0c 00 	mov	r8,-62464
80004fdc:	e0 69 03 07 	mov	r9,775
80004fe0:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004fe2:	30 49       	mov	r9,4
80004fe4:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004fe6:	71 59       	ld.w	r9,r8[0x54]
80004fe8:	e2 19 00 80 	andl	r9,0x80,COH
80004fec:	cf d0       	breq	80004fe6 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004fee:	fe 78 0c 00 	mov	r8,-62464
80004ff2:	30 59       	mov	r9,5
80004ff4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004ff6:	e0 69 01 0d 	mov	r9,269
80004ffa:	ea 19 10 07 	orh	r9,0x1007
80004ffe:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005000:	71 59       	ld.w	r9,r8[0x54]
80005002:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005006:	cf d0       	breq	80005000 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005008:	fe 78 0c 00 	mov	r8,-62464
8000500c:	fc 19 00 80 	movh	r9,0x80
80005010:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005012:	34 0a       	mov	r10,64
80005014:	fe 69 14 00 	mov	r9,-125952
80005018:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000501a:	30 69       	mov	r9,6
8000501c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000501e:	30 19       	mov	r9,1
80005020:	fe 68 10 00 	mov	r8,-126976
80005024:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
80005026:	5e fc       	retal	r12

80005028 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005028:	58 0c       	cp.w	r12,0
8000502a:	5e 0c       	reteq	r12
8000502c:	30 08       	mov	r8,0
	{
		nop();
8000502e:	d7 03       	nop
		nop();
80005030:	d7 03       	nop
		nop();
80005032:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005034:	2f f8       	sub	r8,-1
80005036:	10 3c       	cp.w	r12,r8
80005038:	fe 9b ff fb 	brhi	8000502e <delay_ns+0x6>
8000503c:	5e fc       	retal	r12
8000503e:	d7 03       	nop

80005040 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005040:	eb cd 40 e0 	pushm	r5-r7,lr
80005044:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005046:	58 0c       	cp.w	r12,0
80005048:	c0 b0       	breq	8000505e <delay_us+0x1e>
8000504a:	30 07       	mov	r7,0
		delay_ns(1000);
8000504c:	e0 65 03 e8 	mov	r5,1000
80005050:	0a 9c       	mov	r12,r5
80005052:	f0 1f 00 05 	mcall	80005064 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005056:	2f f7       	sub	r7,-1
80005058:	0e 36       	cp.w	r6,r7
8000505a:	fe 9b ff fb 	brhi	80005050 <delay_us+0x10>
8000505e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005062:	00 00       	add	r0,r0
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	50 28       	stdsp	sp[0x8],r8

80005068 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005068:	eb cd 40 e0 	pushm	r5-r7,lr
8000506c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000506e:	58 0c       	cp.w	r12,0
80005070:	c0 b0       	breq	80005086 <delay_ms+0x1e>
80005072:	30 07       	mov	r7,0
		delay_us(1000);
80005074:	e0 65 03 e8 	mov	r5,1000
80005078:	0a 9c       	mov	r12,r5
8000507a:	f0 1f 00 05 	mcall	8000508c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000507e:	2f f7       	sub	r7,-1
80005080:	0e 36       	cp.w	r6,r7
80005082:	fe 9b ff fb 	brhi	80005078 <delay_ms+0x10>
80005086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000508a:	00 00       	add	r0,r0
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	50 40       	stdsp	sp[0x10],r0

80005090 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005090:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005092:	30 3b       	mov	r11,3
80005094:	48 8c       	lddpc	r12,800050b4 <local_start_timer+0x24>
80005096:	f0 1f 00 09 	mcall	800050b8 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000509a:	fe 78 38 00 	mov	r8,-51200
8000509e:	e0 69 91 0d 	mov	r9,37133
800050a2:	ea 19 00 52 	orh	r9,0x52
800050a6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800050a8:	32 09       	mov	r9,32
800050aa:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050ac:	30 59       	mov	r9,5
800050ae:	91 09       	st.w	r8[0x0],r9
}
800050b0:	d8 02       	popm	pc
800050b2:	00 00       	add	r0,r0
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	d2 0c       	*unknown*
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	51 10       	stdsp	sp[0x44],r0

800050bc <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800050bc:	f8 08 16 05 	lsr	r8,r12,0x5
800050c0:	a9 68       	lsl	r8,0x8
800050c2:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800050c6:	58 1b       	cp.w	r11,1
800050c8:	c0 d0       	breq	800050e2 <gpio_enable_module_pin+0x26>
800050ca:	c0 63       	brcs	800050d6 <gpio_enable_module_pin+0x1a>
800050cc:	58 2b       	cp.w	r11,2
800050ce:	c1 00       	breq	800050ee <gpio_enable_module_pin+0x32>
800050d0:	58 3b       	cp.w	r11,3
800050d2:	c1 40       	breq	800050fa <gpio_enable_module_pin+0x3e>
800050d4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050d6:	30 19       	mov	r9,1
800050d8:	f2 0c 09 49 	lsl	r9,r9,r12
800050dc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050de:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050e0:	c1 28       	rjmp	80005104 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050e2:	30 19       	mov	r9,1
800050e4:	f2 0c 09 49 	lsl	r9,r9,r12
800050e8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050ea:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050ec:	c0 c8       	rjmp	80005104 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050ee:	30 19       	mov	r9,1
800050f0:	f2 0c 09 49 	lsl	r9,r9,r12
800050f4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800050f6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050f8:	c0 68       	rjmp	80005104 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050fa:	30 19       	mov	r9,1
800050fc:	f2 0c 09 49 	lsl	r9,r9,r12
80005100:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005102:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005104:	30 19       	mov	r9,1
80005106:	f2 0c 09 4c 	lsl	r12,r9,r12
8000510a:	91 2c       	st.w	r8[0x8],r12
8000510c:	5e fd       	retal	0
8000510e:	d7 03       	nop

80005110 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005110:	d4 21       	pushm	r4-r7,lr
80005112:	18 97       	mov	r7,r12
80005114:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005116:	58 0b       	cp.w	r11,0
80005118:	c0 31       	brne	8000511e <gpio_enable_module+0xe>
8000511a:	30 05       	mov	r5,0
8000511c:	c0 d8       	rjmp	80005136 <gpio_enable_module+0x26>
8000511e:	30 06       	mov	r6,0
80005120:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005122:	6e 1b       	ld.w	r11,r7[0x4]
80005124:	6e 0c       	ld.w	r12,r7[0x0]
80005126:	f0 1f 00 06 	mcall	8000513c <gpio_enable_module+0x2c>
8000512a:	18 45       	or	r5,r12
		gpiomap++;
8000512c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000512e:	2f f6       	sub	r6,-1
80005130:	0c 34       	cp.w	r4,r6
80005132:	fe 9b ff f8 	brhi	80005122 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005136:	0a 9c       	mov	r12,r5
80005138:	d8 22       	popm	r4-r7,pc
8000513a:	00 00       	add	r0,r0
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	50 bc       	stdsp	sp[0x2c],r12

80005140 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005140:	f8 08 16 05 	lsr	r8,r12,0x5
80005144:	a9 68       	lsl	r8,0x8
80005146:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000514a:	30 19       	mov	r9,1
8000514c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005150:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005154:	91 1c       	st.w	r8[0x4],r12
}
80005156:	5e fc       	retal	r12

80005158 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005158:	f8 08 16 05 	lsr	r8,r12,0x5
8000515c:	a9 68       	lsl	r8,0x8
8000515e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005162:	30 19       	mov	r9,1
80005164:	f2 0c 09 4c 	lsl	r12,r9,r12
80005168:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000516c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005170:	91 1c       	st.w	r8[0x4],r12
}
80005172:	5e fc       	retal	r12

80005174 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005174:	f8 08 16 05 	lsr	r8,r12,0x5
80005178:	a9 68       	lsl	r8,0x8
8000517a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000517e:	30 19       	mov	r9,1
80005180:	f2 0c 09 4c 	lsl	r12,r9,r12
80005184:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005188:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000518c:	91 1c       	st.w	r8[0x4],r12
}
8000518e:	5e fc       	retal	r12

80005190 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005190:	c0 08       	rjmp	80005190 <_unhandled_interrupt>
80005192:	d7 03       	nop

80005194 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005194:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005198:	49 99       	lddpc	r9,800051fc <INTC_register_interrupt+0x68>
8000519a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000519e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800051a2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800051a4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800051a8:	58 0a       	cp.w	r10,0
800051aa:	c0 91       	brne	800051bc <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800051ac:	49 59       	lddpc	r9,80005200 <INTC_register_interrupt+0x6c>
800051ae:	49 6a       	lddpc	r10,80005204 <INTC_register_interrupt+0x70>
800051b0:	12 1a       	sub	r10,r9
800051b2:	fe 79 08 00 	mov	r9,-63488
800051b6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051ba:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800051bc:	58 1a       	cp.w	r10,1
800051be:	c0 a1       	brne	800051d2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800051c0:	49 09       	lddpc	r9,80005200 <INTC_register_interrupt+0x6c>
800051c2:	49 2a       	lddpc	r10,80005208 <INTC_register_interrupt+0x74>
800051c4:	12 1a       	sub	r10,r9
800051c6:	bf aa       	sbr	r10,0x1e
800051c8:	fe 79 08 00 	mov	r9,-63488
800051cc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051d0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800051d2:	58 2a       	cp.w	r10,2
800051d4:	c0 a1       	brne	800051e8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800051d6:	48 b9       	lddpc	r9,80005200 <INTC_register_interrupt+0x6c>
800051d8:	48 da       	lddpc	r10,8000520c <INTC_register_interrupt+0x78>
800051da:	12 1a       	sub	r10,r9
800051dc:	bf ba       	sbr	r10,0x1f
800051de:	fe 79 08 00 	mov	r9,-63488
800051e2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051e6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800051e8:	48 69       	lddpc	r9,80005200 <INTC_register_interrupt+0x6c>
800051ea:	48 aa       	lddpc	r10,80005210 <INTC_register_interrupt+0x7c>
800051ec:	12 1a       	sub	r10,r9
800051ee:	ea 1a c0 00 	orh	r10,0xc000
800051f2:	fe 79 08 00 	mov	r9,-63488
800051f6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051fa:	5e fc       	retal	r12
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	d2 24       	*unknown*
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	c8 00       	breq	80005102 <gpio_enable_module_pin+0x46>
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	c9 04       	brge	80005126 <gpio_enable_module+0x16>
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	c9 12       	brcc	8000512c <gpio_enable_module+0x1c>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	c9 20       	breq	80005132 <gpio_enable_module+0x22>
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	c9 2e       	rcall	80004f36 <rfid_sendID_message+0xd2>

80005214 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005214:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005216:	49 18       	lddpc	r8,80005258 <INTC_init_interrupts+0x44>
80005218:	e3 b8 00 01 	mtsr	0x4,r8
8000521c:	49 0e       	lddpc	lr,8000525c <INTC_init_interrupts+0x48>
8000521e:	30 07       	mov	r7,0
80005220:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005222:	49 0c       	lddpc	r12,80005260 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005224:	49 05       	lddpc	r5,80005264 <INTC_init_interrupts+0x50>
80005226:	10 15       	sub	r5,r8
80005228:	fe 76 08 00 	mov	r6,-63488
8000522c:	c1 08       	rjmp	8000524c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000522e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005230:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005232:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005234:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005238:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000523a:	10 3a       	cp.w	r10,r8
8000523c:	fe 9b ff fc 	brhi	80005234 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005240:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005244:	2f f7       	sub	r7,-1
80005246:	2f 8e       	sub	lr,-8
80005248:	59 37       	cp.w	r7,19
8000524a:	c0 50       	breq	80005254 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000524c:	7c 08       	ld.w	r8,lr[0x0]
8000524e:	58 08       	cp.w	r8,0
80005250:	ce f1       	brne	8000522e <INTC_init_interrupts+0x1a>
80005252:	cf 7b       	rjmp	80005240 <INTC_init_interrupts+0x2c>
80005254:	d8 22       	popm	r4-r7,pc
80005256:	00 00       	add	r0,r0
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	c8 00       	breq	8000515a <gpio_set_gpio_pin+0x2>
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	d2 24       	*unknown*
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	51 90       	stdsp	sp[0x64],r0
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	c9 04       	brge	80005186 <gpio_clr_gpio_pin+0x12>

80005268 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005268:	fe 78 08 00 	mov	r8,-63488
8000526c:	e0 69 00 83 	mov	r9,131
80005270:	f2 0c 01 0c 	sub	r12,r9,r12
80005274:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005278:	f2 ca ff c0 	sub	r10,r9,-64
8000527c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005280:	58 08       	cp.w	r8,0
80005282:	c0 21       	brne	80005286 <_get_interrupt_handler+0x1e>
80005284:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005286:	f0 08 12 00 	clz	r8,r8
8000528a:	48 5a       	lddpc	r10,8000529c <_get_interrupt_handler+0x34>
8000528c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005290:	f0 08 11 1f 	rsub	r8,r8,31
80005294:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005296:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000529a:	5e fc       	retal	r12
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	d2 24       	*unknown*

800052a0 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800052a0:	f8 c8 00 01 	sub	r8,r12,1
800052a4:	f0 0b 00 0b 	add	r11,r8,r11
800052a8:	f6 0c 0d 0a 	divu	r10,r11,r12
800052ac:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800052ae:	f4 c8 00 01 	sub	r8,r10,1
800052b2:	e0 48 00 fe 	cp.w	r8,254
800052b6:	e0 88 00 03 	brls	800052bc <getBaudDiv+0x1c>
800052ba:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800052bc:	5c 8c       	casts.h	r12
}
800052be:	5e fc       	retal	r12

800052c0 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800052c0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800052c4:	30 18       	mov	r8,1
800052c6:	f0 09 18 00 	cp.b	r9,r8
800052ca:	e0 88 00 04 	brls	800052d2 <spi_initMaster+0x12>
800052ce:	30 2c       	mov	r12,2
800052d0:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800052d2:	e0 68 00 80 	mov	r8,128
800052d6:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800052d8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800052da:	30 19       	mov	r9,1
800052dc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800052e0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800052e4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800052e8:	30 09       	mov	r9,0
800052ea:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800052ee:	30 fa       	mov	r10,15
800052f0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800052f4:	99 18       	st.w	r12[0x4],r8
800052f6:	5e f9       	retal	r9

800052f8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800052f8:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800052fa:	30 18       	mov	r8,1
800052fc:	f0 0b 18 00 	cp.b	r11,r8
80005300:	5f be       	srhi	lr
80005302:	f0 0a 18 00 	cp.b	r10,r8
80005306:	5f b8       	srhi	r8
80005308:	fd e8 10 08 	or	r8,lr,r8
8000530c:	c0 30       	breq	80005312 <spi_selectionMode+0x1a>
8000530e:	30 2c       	mov	r12,2
80005310:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005312:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005314:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005318:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000531c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005320:	99 18       	st.w	r12[0x4],r8
80005322:	d8 0a       	popm	pc,r12=0

80005324 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005324:	30 18       	mov	r8,1
80005326:	99 08       	st.w	r12[0x0],r8
}
80005328:	5e fc       	retal	r12

8000532a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000532a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000532e:	c0 58       	rjmp	80005338 <spi_write+0xe>
		if (!timeout--) {
80005330:	58 08       	cp.w	r8,0
80005332:	c0 21       	brne	80005336 <spi_write+0xc>
80005334:	5e ff       	retal	1
80005336:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005338:	78 49       	ld.w	r9,r12[0x10]
8000533a:	e2 19 00 02 	andl	r9,0x2,COH
8000533e:	cf 90       	breq	80005330 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005340:	5c 7b       	castu.h	r11
80005342:	99 3b       	st.w	r12[0xc],r11
80005344:	5e fd       	retal	0

80005346 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005346:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000534a:	c0 58       	rjmp	80005354 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000534c:	58 08       	cp.w	r8,0
8000534e:	c0 21       	brne	80005352 <spi_read+0xc>
80005350:	5e ff       	retal	1
80005352:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005354:	78 49       	ld.w	r9,r12[0x10]
80005356:	e2 19 02 01 	andl	r9,0x201,COH
8000535a:	e0 49 02 01 	cp.w	r9,513
8000535e:	cf 71       	brne	8000534c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005360:	78 28       	ld.w	r8,r12[0x8]
80005362:	b6 08       	st.h	r11[0x0],r8
80005364:	5e fd       	retal	0
80005366:	d7 03       	nop

80005368 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005368:	eb cd 40 f8 	pushm	r3-r7,lr
8000536c:	18 95       	mov	r5,r12
8000536e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005370:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005374:	30 38       	mov	r8,3
80005376:	f0 06 18 00 	cp.b	r6,r8
8000537a:	e0 8b 00 5e 	brhi	80005436 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000537e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005382:	30 18       	mov	r8,1
80005384:	f0 04 18 00 	cp.b	r4,r8
80005388:	e0 8b 00 57 	brhi	80005436 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000538c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005390:	30 78       	mov	r8,7
80005392:	f0 03 18 00 	cp.b	r3,r8
80005396:	e0 88 00 50 	brls	80005436 <spi_setupChipReg+0xce>
8000539a:	31 08       	mov	r8,16
8000539c:	f0 03 18 00 	cp.b	r3,r8
800053a0:	e0 8b 00 4b 	brhi	80005436 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800053a4:	14 9b       	mov	r11,r10
800053a6:	6e 1c       	ld.w	r12,r7[0x4]
800053a8:	f0 1f 00 26 	mcall	80005440 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800053ac:	c4 55       	brlt	80005436 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800053ae:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800053b0:	ec 09 16 01 	lsr	r9,r6,0x1
800053b4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800053b8:	ec 16 00 01 	eorl	r6,0x1
800053bc:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800053c0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800053c4:	20 83       	sub	r3,8
800053c6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800053ca:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800053ce:	ef 39 00 09 	ld.ub	r9,r7[9]
800053d2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800053d6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800053da:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800053de:	0f 89       	ld.ub	r9,r7[0x0]
800053e0:	30 1a       	mov	r10,1
800053e2:	f4 09 18 00 	cp.b	r9,r10
800053e6:	c0 d0       	breq	80005400 <spi_setupChipReg+0x98>
800053e8:	c0 a3       	brcs	800053fc <spi_setupChipReg+0x94>
800053ea:	30 2a       	mov	r10,2
800053ec:	f4 09 18 00 	cp.b	r9,r10
800053f0:	c0 a0       	breq	80005404 <spi_setupChipReg+0x9c>
800053f2:	30 3a       	mov	r10,3
800053f4:	f4 09 18 00 	cp.b	r9,r10
800053f8:	c1 f1       	brne	80005436 <spi_setupChipReg+0xce>
800053fa:	c0 78       	rjmp	80005408 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800053fc:	8b c8       	st.w	r5[0x30],r8
		break;
800053fe:	c0 68       	rjmp	8000540a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005400:	8b d8       	st.w	r5[0x34],r8
		break;
80005402:	c0 48       	rjmp	8000540a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005404:	8b e8       	st.w	r5[0x38],r8
		break;
80005406:	c0 28       	rjmp	8000540a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005408:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000540a:	48 f8       	lddpc	r8,80005444 <spi_setupChipReg+0xdc>
8000540c:	70 08       	ld.w	r8,r8[0x0]
8000540e:	58 08       	cp.w	r8,0
80005410:	c1 61       	brne	8000543c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005412:	30 0b       	mov	r11,0
80005414:	30 1c       	mov	r12,1
80005416:	f0 1f 00 0d 	mcall	80005448 <spi_setupChipReg+0xe0>
8000541a:	48 b8       	lddpc	r8,80005444 <spi_setupChipReg+0xdc>
8000541c:	91 0c       	st.w	r8[0x0],r12
8000541e:	58 0c       	cp.w	r12,0
80005420:	c0 a0       	breq	80005434 <spi_setupChipReg+0xcc>
80005422:	30 09       	mov	r9,0
80005424:	12 9a       	mov	r10,r9
80005426:	12 9b       	mov	r11,r9
80005428:	f0 1f 00 09 	mcall	8000544c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000542c:	48 68       	lddpc	r8,80005444 <spi_setupChipReg+0xdc>
8000542e:	70 08       	ld.w	r8,r8[0x0]
80005430:	58 08       	cp.w	r8,0
80005432:	c0 51       	brne	8000543c <spi_setupChipReg+0xd4>
80005434:	c0 08       	rjmp	80005434 <spi_setupChipReg+0xcc>
80005436:	30 2c       	mov	r12,2
80005438:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000543c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	52 a0       	stdsp	sp[0xa8],r0
80005444:	00 00       	add	r0,r0
80005446:	51 10       	stdsp	sp[0x44],r0
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	5f 34       	srlo	r4
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	5e 34       	retlo	r4

80005450 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005450:	d4 01       	pushm	lr
80005452:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005456:	c0 58       	rjmp	80005460 <spi_unselectChip+0x10>
		if (!timeout--) {
80005458:	58 08       	cp.w	r8,0
8000545a:	c0 21       	brne	8000545e <spi_unselectChip+0xe>
8000545c:	da 0a       	popm	pc,r12=1
8000545e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005460:	78 49       	ld.w	r9,r12[0x10]
80005462:	e2 19 02 00 	andl	r9,0x200,COH
80005466:	cf 90       	breq	80005458 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005468:	78 18       	ld.w	r8,r12[0x4]
8000546a:	ea 18 00 0f 	orh	r8,0xf
8000546e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005470:	fc 18 01 00 	movh	r8,0x100
80005474:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005476:	30 09       	mov	r9,0
80005478:	12 9a       	mov	r10,r9
8000547a:	12 9b       	mov	r11,r9
8000547c:	48 38       	lddpc	r8,80005488 <spi_unselectChip+0x38>
8000547e:	70 0c       	ld.w	r12,r8[0x0]
80005480:	f0 1f 00 03 	mcall	8000548c <spi_unselectChip+0x3c>
80005484:	d8 0a       	popm	pc,r12=0
80005486:	00 00       	add	r0,r0
80005488:	00 00       	add	r0,r0
8000548a:	51 10       	stdsp	sp[0x44],r0
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	5e 34       	retlo	r4

80005490 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005490:	eb cd 40 f8 	pushm	r3-r7,lr
80005494:	18 94       	mov	r4,r12
80005496:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005498:	49 a6       	lddpc	r6,80005500 <spi_selectChip+0x70>
8000549a:	30 07       	mov	r7,0
8000549c:	31 45       	mov	r5,20
8000549e:	0e 99       	mov	r9,r7
800054a0:	0a 9a       	mov	r10,r5
800054a2:	0e 9b       	mov	r11,r7
800054a4:	6c 0c       	ld.w	r12,r6[0x0]
800054a6:	f0 1f 00 18 	mcall	80005504 <spi_selectChip+0x74>
800054aa:	cf a0       	breq	8000549e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800054ac:	68 18       	ld.w	r8,r4[0x4]
800054ae:	ea 18 00 0f 	orh	r8,0xf
800054b2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800054b4:	68 18       	ld.w	r8,r4[0x4]
800054b6:	e2 18 00 04 	andl	r8,0x4,COH
800054ba:	c1 10       	breq	800054dc <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800054bc:	30 e8       	mov	r8,14
800054be:	f0 03 18 00 	cp.b	r3,r8
800054c2:	e0 8b 00 1c 	brhi	800054fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800054c6:	68 19       	ld.w	r9,r4[0x4]
800054c8:	e6 08 15 10 	lsl	r8,r3,0x10
800054cc:	ea 18 ff f0 	orh	r8,0xfff0
800054d0:	e8 18 ff ff 	orl	r8,0xffff
800054d4:	12 68       	and	r8,r9
800054d6:	89 18       	st.w	r4[0x4],r8
800054d8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800054dc:	30 38       	mov	r8,3
800054de:	f0 03 18 00 	cp.b	r3,r8
800054e2:	e0 8b 00 0c 	brhi	800054fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800054e6:	68 19       	ld.w	r9,r4[0x4]
800054e8:	2f 03       	sub	r3,-16
800054ea:	30 18       	mov	r8,1
800054ec:	f0 03 09 48 	lsl	r8,r8,r3
800054f0:	5c d8       	com	r8
800054f2:	12 68       	and	r8,r9
800054f4:	89 18       	st.w	r4[0x4],r8
800054f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800054fa:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800054fc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005500:	00 00       	add	r0,r0
80005502:	51 10       	stdsp	sp[0x44],r0
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	5c 28       	cpc	r8

80005508 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005508:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000550a:	f6 08 15 04 	lsl	r8,r11,0x4
8000550e:	14 38       	cp.w	r8,r10
80005510:	f9 b8 08 10 	movls	r8,16
80005514:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005518:	f0 0b 02 4b 	mul	r11,r8,r11
8000551c:	f6 09 16 01 	lsr	r9,r11,0x1
80005520:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005524:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005528:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000552c:	f2 cb 00 01 	sub	r11,r9,1
80005530:	e0 4b ff fe 	cp.w	r11,65534
80005534:	e0 88 00 03 	brls	8000553a <usart_set_async_baudrate+0x32>
80005538:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000553a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000553c:	e8 6e 00 00 	mov	lr,524288
80005540:	59 08       	cp.w	r8,16
80005542:	fc 08 17 10 	movne	r8,lr
80005546:	f9 b8 00 00 	moveq	r8,0
8000554a:	e4 1b ff f7 	andh	r11,0xfff7
8000554e:	e0 1b fe cf 	andl	r11,0xfecf
80005552:	16 48       	or	r8,r11
80005554:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005556:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000555a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000555e:	99 89       	st.w	r12[0x20],r9
80005560:	d8 0a       	popm	pc,r12=0

80005562 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005562:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005564:	e2 18 00 02 	andl	r8,0x2,COH
80005568:	c0 31       	brne	8000556e <usart_write_char+0xc>
8000556a:	30 2c       	mov	r12,2
8000556c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000556e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005572:	99 7b       	st.w	r12[0x1c],r11
80005574:	5e fd       	retal	0
80005576:	d7 03       	nop

80005578 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005578:	eb cd 40 e0 	pushm	r5-r7,lr
8000557c:	18 96       	mov	r6,r12
8000557e:	16 95       	mov	r5,r11
80005580:	e0 67 27 0f 	mov	r7,9999
80005584:	c0 68       	rjmp	80005590 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005586:	58 07       	cp.w	r7,0
80005588:	c0 31       	brne	8000558e <usart_putchar+0x16>
8000558a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000558e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005590:	0a 9b       	mov	r11,r5
80005592:	0c 9c       	mov	r12,r6
80005594:	f0 1f 00 03 	mcall	800055a0 <usart_putchar+0x28>
80005598:	cf 71       	brne	80005586 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000559a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000559e:	00 00       	add	r0,r0
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	55 62       	stdsp	sp[0x158],r2

800055a4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800055a4:	78 58       	ld.w	r8,r12[0x14]
800055a6:	e2 18 00 e0 	andl	r8,0xe0,COH
800055aa:	c0 30       	breq	800055b0 <usart_read_char+0xc>
800055ac:	30 4c       	mov	r12,4
800055ae:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800055b0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800055b2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055b6:	c0 31       	brne	800055bc <usart_read_char+0x18>
800055b8:	30 3c       	mov	r12,3
800055ba:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800055bc:	78 68       	ld.w	r8,r12[0x18]
800055be:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800055c2:	97 08       	st.w	r11[0x0],r8
800055c4:	5e fd       	retal	0
800055c6:	d7 03       	nop

800055c8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800055c8:	eb cd 40 c0 	pushm	r6-r7,lr
800055cc:	20 1d       	sub	sp,4
800055ce:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800055d0:	1a 97       	mov	r7,sp
800055d2:	1a 9b       	mov	r11,sp
800055d4:	0c 9c       	mov	r12,r6
800055d6:	f0 1f 00 07 	mcall	800055f0 <usart_getchar+0x28>
800055da:	58 3c       	cp.w	r12,3
800055dc:	cf b0       	breq	800055d2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800055de:	58 4c       	cp.w	r12,4
800055e0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800055e4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800055e8:	2f fd       	sub	sp,-4
800055ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055ee:	00 00       	add	r0,r0
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	55 a4       	stdsp	sp[0x168],r4

800055f4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800055f4:	eb cd 40 c0 	pushm	r6-r7,lr
800055f8:	18 96       	mov	r6,r12
800055fa:	16 97       	mov	r7,r11
  while (*string != '\0')
800055fc:	17 8b       	ld.ub	r11,r11[0x0]
800055fe:	58 0b       	cp.w	r11,0
80005600:	c0 80       	breq	80005610 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005602:	2f f7       	sub	r7,-1
80005604:	0c 9c       	mov	r12,r6
80005606:	f0 1f 00 04 	mcall	80005614 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000560a:	0f 8b       	ld.ub	r11,r7[0x0]
8000560c:	58 0b       	cp.w	r11,0
8000560e:	cf a1       	brne	80005602 <usart_write_line+0xe>
80005610:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	55 78       	stdsp	sp[0x15c],r8

80005618 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005618:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000561c:	e6 18 00 01 	andh	r8,0x1,COH
80005620:	c0 71       	brne	8000562e <usart_reset+0x16>
80005622:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005624:	3f f8       	mov	r8,-1
80005626:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005628:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000562a:	d5 03       	csrf	0x10
8000562c:	c0 48       	rjmp	80005634 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000562e:	3f f8       	mov	r8,-1
80005630:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005632:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005634:	30 08       	mov	r8,0
80005636:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005638:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000563a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000563c:	ea 68 61 0c 	mov	r8,680204
80005640:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005642:	5e fc       	retal	r12

80005644 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005644:	eb cd 40 e0 	pushm	r5-r7,lr
80005648:	18 96       	mov	r6,r12
8000564a:	16 97       	mov	r7,r11
8000564c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000564e:	f0 1f 00 2f 	mcall	80005708 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005652:	58 07       	cp.w	r7,0
80005654:	c5 80       	breq	80005704 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005656:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005658:	30 49       	mov	r9,4
8000565a:	f2 08 18 00 	cp.b	r8,r9
8000565e:	e0 88 00 53 	brls	80005704 <usart_init_rs232+0xc0>
80005662:	30 99       	mov	r9,9
80005664:	f2 08 18 00 	cp.b	r8,r9
80005668:	e0 8b 00 4e 	brhi	80005704 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000566c:	0f d9       	ld.ub	r9,r7[0x5]
8000566e:	30 78       	mov	r8,7
80005670:	f0 09 18 00 	cp.b	r9,r8
80005674:	e0 8b 00 48 	brhi	80005704 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005678:	8e 39       	ld.sh	r9,r7[0x6]
8000567a:	e0 68 01 01 	mov	r8,257
8000567e:	f0 09 19 00 	cp.h	r9,r8
80005682:	e0 8b 00 41 	brhi	80005704 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005686:	ef 39 00 08 	ld.ub	r9,r7[8]
8000568a:	30 38       	mov	r8,3
8000568c:	f0 09 18 00 	cp.b	r9,r8
80005690:	e0 8b 00 3a 	brhi	80005704 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005694:	0a 9a       	mov	r10,r5
80005696:	6e 0b       	ld.w	r11,r7[0x0]
80005698:	0c 9c       	mov	r12,r6
8000569a:	f0 1f 00 1d 	mcall	8000570c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000569e:	58 1c       	cp.w	r12,1
800056a0:	c3 20       	breq	80005704 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800056a2:	0f c8       	ld.ub	r8,r7[0x4]
800056a4:	30 99       	mov	r9,9
800056a6:	f2 08 18 00 	cp.b	r8,r9
800056aa:	c0 51       	brne	800056b4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800056ac:	6c 18       	ld.w	r8,r6[0x4]
800056ae:	b1 b8       	sbr	r8,0x11
800056b0:	8d 18       	st.w	r6[0x4],r8
800056b2:	c0 68       	rjmp	800056be <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800056b4:	6c 19       	ld.w	r9,r6[0x4]
800056b6:	20 58       	sub	r8,5
800056b8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800056bc:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800056be:	6c 19       	ld.w	r9,r6[0x4]
800056c0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800056c4:	0f d8       	ld.ub	r8,r7[0x5]
800056c6:	a9 78       	lsl	r8,0x9
800056c8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800056cc:	12 48       	or	r8,r9
800056ce:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800056d0:	8e 38       	ld.sh	r8,r7[0x6]
800056d2:	30 29       	mov	r9,2
800056d4:	f2 08 19 00 	cp.h	r8,r9
800056d8:	e0 88 00 09 	brls	800056ea <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800056dc:	6c 18       	ld.w	r8,r6[0x4]
800056de:	ad b8       	sbr	r8,0xd
800056e0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800056e2:	8e b8       	ld.uh	r8,r7[0x6]
800056e4:	20 28       	sub	r8,2
800056e6:	8d a8       	st.w	r6[0x28],r8
800056e8:	c0 68       	rjmp	800056f4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800056ea:	6c 19       	ld.w	r9,r6[0x4]
800056ec:	5c 78       	castu.h	r8
800056ee:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800056f2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800056f4:	6c 18       	ld.w	r8,r6[0x4]
800056f6:	e0 18 ff f0 	andl	r8,0xfff0
800056fa:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800056fc:	35 08       	mov	r8,80
800056fe:	8d 08       	st.w	r6[0x0],r8
80005700:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005704:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	56 18       	stdsp	sp[0x184],r8
8000570c:	80 00       	ld.sh	r0,r0[0x0]
8000570e:	55 08       	stdsp	sp[0x140],r8

80005710 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005710:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005714:	fe c0 8f 14 	sub	r0,pc,-28908

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005718:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000571c:	d5 53       	csrf	0x15
  cp      r0, r1
8000571e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005720:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005724:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005726:	c0 62       	brcc	80005732 <idata_load_loop_end>
  cp      r0, r1
80005728:	48 92       	lddpc	r2,8000574c <udata_clear_loop_end+0x4>

8000572a <idata_load_loop>:
  brlo    idata_load_loop
8000572a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000572c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000572e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005730:	cf d3       	brcs	8000572a <idata_load_loop>

80005732 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005732:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005736:	e0 61 51 20 	mov	r1,20768
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000573a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000573c:	c0 62       	brcc	80005748 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000573e:	30 02       	mov	r2,0
80005740:	30 03       	mov	r3,0

80005742 <udata_clear_loop>:
80005742:	a1 22       	st.d	r0++,r2
80005744:	02 30       	cp.w	r0,r1
80005746:	cf e3       	brcs	80005742 <udata_clear_loop>

80005748 <udata_clear_loop_end>:
80005748:	fe cf e9 7c 	sub	pc,pc,-5764
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	db 58       	*unknown*

80005750 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005750:	f8 c8 ff f8 	sub	r8,r12,-8
80005754:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005756:	3f f9       	mov	r9,-1
80005758:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000575a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000575c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000575e:	30 08       	mov	r8,0
80005760:	99 08       	st.w	r12[0x0],r8
}
80005762:	5e fc       	retal	r12

80005764 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005764:	30 08       	mov	r8,0
80005766:	99 48       	st.w	r12[0x10],r8
}
80005768:	5e fc       	retal	r12

8000576a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000576a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000576c:	70 19       	ld.w	r9,r8[0x4]
8000576e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005770:	78 19       	ld.w	r9,r12[0x4]
80005772:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005774:	70 19       	ld.w	r9,r8[0x4]
80005776:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005778:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000577a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000577c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000577e:	78 08       	ld.w	r8,r12[0x0]
80005780:	2f f8       	sub	r8,-1
80005782:	99 08       	st.w	r12[0x0],r8
}
80005784:	5e fc       	retal	r12

80005786 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005786:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005788:	5b fa       	cp.w	r10,-1
8000578a:	c0 31       	brne	80005790 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000578c:	78 48       	ld.w	r8,r12[0x10]
8000578e:	c0 c8       	rjmp	800057a6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005790:	f8 c8 ff f8 	sub	r8,r12,-8
80005794:	70 19       	ld.w	r9,r8[0x4]
80005796:	72 09       	ld.w	r9,r9[0x0]
80005798:	12 3a       	cp.w	r10,r9
8000579a:	c0 63       	brcs	800057a6 <vListInsert+0x20>
8000579c:	70 18       	ld.w	r8,r8[0x4]
8000579e:	70 19       	ld.w	r9,r8[0x4]
800057a0:	72 09       	ld.w	r9,r9[0x0]
800057a2:	12 3a       	cp.w	r10,r9
800057a4:	cf c2       	brcc	8000579c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800057a6:	70 19       	ld.w	r9,r8[0x4]
800057a8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800057aa:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800057ac:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800057ae:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800057b0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800057b2:	78 08       	ld.w	r8,r12[0x0]
800057b4:	2f f8       	sub	r8,-1
800057b6:	99 08       	st.w	r12[0x0],r8
}
800057b8:	5e fc       	retal	r12

800057ba <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800057ba:	78 18       	ld.w	r8,r12[0x4]
800057bc:	78 29       	ld.w	r9,r12[0x8]
800057be:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800057c0:	78 28       	ld.w	r8,r12[0x8]
800057c2:	78 19       	ld.w	r9,r12[0x4]
800057c4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800057c6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800057c8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800057ca:	18 39       	cp.w	r9,r12
800057cc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057d0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057d4:	30 09       	mov	r9,0
800057d6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057d8:	70 09       	ld.w	r9,r8[0x0]
800057da:	20 19       	sub	r9,1
800057dc:	91 09       	st.w	r8[0x0],r9
}
800057de:	5e fc       	retal	r12

800057e0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057e0:	e0 68 08 08 	mov	r8,2056
800057e4:	ea 18 08 08 	orh	r8,0x808
800057e8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057ea:	e0 68 09 09 	mov	r8,2313
800057ee:	ea 18 09 09 	orh	r8,0x909
800057f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057f4:	e0 68 0a 0a 	mov	r8,2570
800057f8:	ea 18 0a 0a 	orh	r8,0xa0a
800057fc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800057fe:	e0 68 0b 0b 	mov	r8,2827
80005802:	ea 18 0b 0b 	orh	r8,0xb0b
80005806:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005808:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000580a:	e0 68 be ef 	mov	r8,48879
8000580e:	ea 18 de ad 	orh	r8,0xdead
80005812:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005814:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005816:	fc 18 00 40 	movh	r8,0x40
8000581a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000581c:	e0 68 00 ff 	mov	r8,255
80005820:	ea 18 ff 00 	orh	r8,0xff00
80005824:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005826:	e0 68 01 01 	mov	r8,257
8000582a:	ea 18 01 01 	orh	r8,0x101
8000582e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005830:	e0 68 02 02 	mov	r8,514
80005834:	ea 18 02 02 	orh	r8,0x202
80005838:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000583a:	e0 68 03 03 	mov	r8,771
8000583e:	ea 18 03 03 	orh	r8,0x303
80005842:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005844:	e0 68 04 04 	mov	r8,1028
80005848:	ea 18 04 04 	orh	r8,0x404
8000584c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000584e:	e0 68 05 05 	mov	r8,1285
80005852:	ea 18 05 05 	orh	r8,0x505
80005856:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005858:	e0 68 06 06 	mov	r8,1542
8000585c:	ea 18 06 06 	orh	r8,0x606
80005860:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005862:	e0 68 07 07 	mov	r8,1799
80005866:	ea 18 07 07 	orh	r8,0x707
8000586a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000586c:	30 08       	mov	r8,0
8000586e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005870:	5e fc       	retal	r12
80005872:	d7 03       	nop

80005874 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005874:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005876:	48 38       	lddpc	r8,80005880 <vPortEnterCritical+0xc>
80005878:	70 09       	ld.w	r9,r8[0x0]
8000587a:	2f f9       	sub	r9,-1
8000587c:	91 09       	st.w	r8[0x0],r9
}
8000587e:	5e fc       	retal	r12
80005880:	00 00       	add	r0,r0
80005882:	05 30       	ld.ub	r0,r2++

80005884 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005884:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005886:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005888:	30 0a       	mov	r10,0
8000588a:	14 9b       	mov	r11,r10
8000588c:	49 2c       	lddpc	r12,800058d4 <xPortStartScheduler+0x50>
8000588e:	f0 1f 00 13 	mcall	800058d8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005892:	e0 68 5d c0 	mov	r8,24000
80005896:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000589a:	30 08       	mov	r8,0
8000589c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800058a0:	e0 68 0c d4 	mov	r8,3284
800058a4:	ea 18 00 00 	orh	r8,0x0
800058a8:	70 00       	ld.w	r0,r8[0x0]
800058aa:	60 0d       	ld.w	sp,r0[0x0]
800058ac:	1b 00       	ld.w	r0,sp++
800058ae:	e0 68 05 30 	mov	r8,1328
800058b2:	ea 18 00 00 	orh	r8,0x0
800058b6:	91 00       	st.w	r8[0x0],r0
800058b8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800058bc:	2f ed       	sub	sp,-8
800058be:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800058c2:	fa f0 ff e0 	ld.w	r0,sp[-32]
800058c6:	e3 b0 00 00 	mtsr	0x0,r0
800058ca:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058ce:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058d2:	d8 0a       	popm	pc,r12=0
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	59 a0       	cp.w	r0,26
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	51 94       	stdsp	sp[0x64],r4

800058dc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058dc:	20 6d       	sub	sp,24
800058de:	eb cd 00 ff 	pushm	r0-r7
800058e2:	fa c7 ff c0 	sub	r7,sp,-64
800058e6:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058ea:	ef 40 ff e0 	st.w	r7[-32],r0
800058ee:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058f2:	ef 40 ff e4 	st.w	r7[-28],r0
800058f6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800058fa:	e0 68 05 30 	mov	r8,1328
800058fe:	ea 18 00 00 	orh	r8,0x0
80005902:	70 00       	ld.w	r0,r8[0x0]
80005904:	1a d0       	st.w	--sp,r0
80005906:	f0 1f 00 1a 	mcall	8000596c <LABEL_RET_SCALL_263+0x14>
8000590a:	e0 68 0c d4 	mov	r8,3284
8000590e:	ea 18 00 00 	orh	r8,0x0
80005912:	70 00       	ld.w	r0,r8[0x0]
80005914:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005916:	f0 1f 00 17 	mcall	80005970 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000591a:	e0 68 0c d4 	mov	r8,3284
8000591e:	ea 18 00 00 	orh	r8,0x0
80005922:	70 00       	ld.w	r0,r8[0x0]
80005924:	60 0d       	ld.w	sp,r0[0x0]
80005926:	1b 00       	ld.w	r0,sp++
80005928:	e0 68 05 30 	mov	r8,1328
8000592c:	ea 18 00 00 	orh	r8,0x0
80005930:	91 00       	st.w	r8[0x0],r0
80005932:	fa c7 ff d8 	sub	r7,sp,-40
80005936:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000593a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000593e:	e0 61 05 30 	mov	r1,1328
80005942:	ea 11 00 00 	orh	r1,0x0
80005946:	62 02       	ld.w	r2,r1[0x0]
80005948:	58 02       	cp.w	r2,0
8000594a:	c0 70       	breq	80005958 <LABEL_RET_SCALL_263>
8000594c:	e4 c2 00 01 	sub	r2,r2,1
80005950:	83 02       	st.w	r1[0x0],r2
80005952:	58 02       	cp.w	r2,0
80005954:	c0 21       	brne	80005958 <LABEL_RET_SCALL_263>
80005956:	b1 c0       	cbr	r0,0x10

80005958 <LABEL_RET_SCALL_263>:
80005958:	ef 40 ff f8 	st.w	r7[-8],r0
8000595c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005960:	ef 40 ff fc 	st.w	r7[-4],r0
80005964:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005968:	2f ad       	sub	sp,-24
8000596a:	d6 13       	rets
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	58 74       	cp.w	r4,7
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	5f b8       	srhi	r8

80005974 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005974:	e1 b8 00 43 	mfsr	r8,0x10c
80005978:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000597c:	5e fc       	retal	r12
8000597e:	d7 03       	nop

80005980 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005980:	48 78       	lddpc	r8,8000599c <vPortExitCritical+0x1c>
80005982:	70 08       	ld.w	r8,r8[0x0]
80005984:	58 08       	cp.w	r8,0
80005986:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005988:	48 58       	lddpc	r8,8000599c <vPortExitCritical+0x1c>
8000598a:	70 09       	ld.w	r9,r8[0x0]
8000598c:	20 19       	sub	r9,1
8000598e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005990:	70 08       	ld.w	r8,r8[0x0]
80005992:	58 08       	cp.w	r8,0
80005994:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005996:	d5 03       	csrf	0x10
80005998:	5e fc       	retal	r12
8000599a:	00 00       	add	r0,r0
8000599c:	00 00       	add	r0,r0
8000599e:	05 30       	ld.ub	r0,r2++

800059a0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800059a0:	eb cd 00 ff 	pushm	r0-r7
800059a4:	e0 68 05 30 	mov	r8,1328
800059a8:	ea 18 00 00 	orh	r8,0x0
800059ac:	70 00       	ld.w	r0,r8[0x0]
800059ae:	1a d0       	st.w	--sp,r0
800059b0:	7a 90       	ld.w	r0,sp[0x24]
800059b2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059b6:	58 10       	cp.w	r0,1
800059b8:	e0 8b 00 08 	brhi	800059c8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800059bc:	e0 68 0c d4 	mov	r8,3284
800059c0:	ea 18 00 00 	orh	r8,0x0
800059c4:	70 00       	ld.w	r0,r8[0x0]
800059c6:	81 0d       	st.w	r0[0x0],sp

800059c8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800059c8:	f0 1f 00 12 	mcall	80005a10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059cc:	f0 1f 00 12 	mcall	80005a14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800059d0:	f0 1f 00 12 	mcall	80005a18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059d4:	f0 1f 00 12 	mcall	80005a1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059d8:	7a 90       	ld.w	r0,sp[0x24]
800059da:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059de:	58 10       	cp.w	r0,1
800059e0:	e0 8b 00 0e 	brhi	800059fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059e4:	f0 1f 00 0c 	mcall	80005a14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059e8:	f0 1f 00 0e 	mcall	80005a20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800059ec:	f0 1f 00 0c 	mcall	80005a1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800059f0:	e0 68 0c d4 	mov	r8,3284
800059f4:	ea 18 00 00 	orh	r8,0x0
800059f8:	70 00       	ld.w	r0,r8[0x0]
800059fa:	60 0d       	ld.w	sp,r0[0x0]

800059fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800059fc:	1b 00       	ld.w	r0,sp++
800059fe:	e0 68 05 30 	mov	r8,1328
80005a02:	ea 18 00 00 	orh	r8,0x0
80005a06:	91 00       	st.w	r8[0x0],r0
80005a08:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005a0c:	d6 03       	rete
80005a0e:	00 00       	add	r0,r0
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	59 74       	cp.w	r4,23
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	58 74       	cp.w	r4,7
80005a18:	80 00       	ld.sh	r0,r0[0x0]
80005a1a:	61 bc       	ld.w	r12,r0[0x6c]
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	59 80       	cp.w	r0,24
80005a20:	80 00       	ld.sh	r0,r0[0x0]
80005a22:	5f b8       	srhi	r8

80005a24 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005a24:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005a26:	f0 1f 00 02 	mcall	80005a2c <__malloc_lock+0x8>
}
80005a2a:	d8 02       	popm	pc
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	5f a8       	srle	r8

80005a30 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005a30:	d4 01       	pushm	lr
	xTaskResumeAll();
80005a32:	f0 1f 00 02 	mcall	80005a38 <__malloc_unlock+0x8>
}
80005a36:	d8 02       	popm	pc
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	63 64       	ld.w	r4,r1[0x58]

80005a3c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a3c:	d4 21       	pushm	r4-r7,lr
80005a3e:	16 95       	mov	r5,r11
80005a40:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a42:	58 0c       	cp.w	r12,0
80005a44:	c0 30       	breq	80005a4a <_read+0xe>
80005a46:	3f f7       	mov	r7,-1
80005a48:	c1 48       	rjmp	80005a70 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a4a:	58 0a       	cp.w	r10,0
80005a4c:	e0 89 00 04 	brgt	80005a54 <_read+0x18>
80005a50:	30 07       	mov	r7,0
80005a52:	c0 f8       	rjmp	80005a70 <_read+0x34>
80005a54:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a56:	48 84       	lddpc	r4,80005a74 <_read+0x38>
80005a58:	68 0c       	ld.w	r12,r4[0x0]
80005a5a:	f0 1f 00 08 	mcall	80005a78 <_read+0x3c>
    if (c < 0)
80005a5e:	c0 95       	brlt	80005a70 <_read+0x34>
      break;

    *ptr++ = c;
80005a60:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a64:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a66:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a6a:	58 08       	cp.w	r8,0
80005a6c:	fe 99 ff f6 	brgt	80005a58 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a70:	0e 9c       	mov	r12,r7
80005a72:	d8 22       	popm	r4-r7,pc
80005a74:	00 00       	add	r0,r0
80005a76:	51 14       	stdsp	sp[0x44],r4
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	55 c8       	stdsp	sp[0x170],r8

80005a7c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a7c:	d4 21       	pushm	r4-r7,lr
80005a7e:	16 95       	mov	r5,r11
80005a80:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a82:	20 1c       	sub	r12,1
80005a84:	58 2c       	cp.w	r12,2
80005a86:	e0 8b 00 12 	brhi	80005aaa <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a8a:	58 0a       	cp.w	r10,0
80005a8c:	c0 31       	brne	80005a92 <_write+0x16>
80005a8e:	30 07       	mov	r7,0
80005a90:	c0 e8       	rjmp	80005aac <_write+0x30>
80005a92:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005a94:	48 74       	lddpc	r4,80005ab0 <_write+0x34>
80005a96:	68 0c       	ld.w	r12,r4[0x0]
80005a98:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005a9c:	f0 1f 00 06 	mcall	80005ab4 <_write+0x38>
80005aa0:	c0 55       	brlt	80005aaa <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005aa2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005aa4:	0e 36       	cp.w	r6,r7
80005aa6:	cf 81       	brne	80005a96 <_write+0x1a>
80005aa8:	c0 28       	rjmp	80005aac <_write+0x30>
80005aaa:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005aac:	0e 9c       	mov	r12,r7
80005aae:	d8 22       	popm	r4-r7,pc
80005ab0:	00 00       	add	r0,r0
80005ab2:	51 14       	stdsp	sp[0x44],r4
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	55 78       	stdsp	sp[0x15c],r8

80005ab8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005ab8:	eb cd 40 80 	pushm	r7,lr
80005abc:	18 97       	mov	r7,r12
	if( pv )
80005abe:	58 0c       	cp.w	r12,0
80005ac0:	c0 80       	breq	80005ad0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005ac2:	f0 1f 00 05 	mcall	80005ad4 <vPortFree+0x1c>
		{
			free( pv );
80005ac6:	0e 9c       	mov	r12,r7
80005ac8:	f0 1f 00 04 	mcall	80005ad8 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005acc:	f0 1f 00 04 	mcall	80005adc <vPortFree+0x24>
80005ad0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	5f a8       	srle	r8
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	6e 34       	ld.w	r4,r7[0xc]
80005adc:	80 00       	ld.sh	r0,r0[0x0]
80005ade:	63 64       	ld.w	r4,r1[0x58]

80005ae0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ae0:	eb cd 40 80 	pushm	r7,lr
80005ae4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005ae6:	f0 1f 00 06 	mcall	80005afc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005aea:	0e 9c       	mov	r12,r7
80005aec:	f0 1f 00 05 	mcall	80005b00 <pvPortMalloc+0x20>
80005af0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005af2:	f0 1f 00 05 	mcall	80005b04 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005af6:	0e 9c       	mov	r12,r7
80005af8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	5f a8       	srle	r8
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	6e 44       	ld.w	r4,r7[0x10]
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	63 64       	ld.w	r4,r1[0x58]

80005b08 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005b08:	d4 01       	pushm	lr
80005b0a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005b0c:	78 09       	ld.w	r9,r12[0x0]
80005b0e:	58 09       	cp.w	r9,0
80005b10:	c1 10       	breq	80005b32 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005b12:	78 3a       	ld.w	r10,r12[0xc]
80005b14:	79 09       	ld.w	r9,r12[0x40]
80005b16:	f4 09 00 09 	add	r9,r10,r9
80005b1a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005b1c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005b1e:	14 39       	cp.w	r9,r10
80005b20:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005b24:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005b28:	79 0a       	ld.w	r10,r12[0x40]
80005b2a:	78 3b       	ld.w	r11,r12[0xc]
80005b2c:	10 9c       	mov	r12,r8
80005b2e:	f0 1f 00 02 	mcall	80005b34 <prvCopyDataFromQueue+0x2c>
80005b32:	d8 02       	popm	pc
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	72 8c       	ld.w	r12,r9[0x20]

80005b38 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b38:	eb cd 40 c0 	pushm	r6-r7,lr
80005b3c:	18 97       	mov	r7,r12
80005b3e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b40:	78 e8       	ld.w	r8,r12[0x38]
80005b42:	58 08       	cp.w	r8,0
80005b44:	c0 31       	brne	80005b4a <xQueueReceiveFromISR+0x12>
80005b46:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b4a:	f0 1f 00 0e 	mcall	80005b80 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b4e:	6e e8       	ld.w	r8,r7[0x38]
80005b50:	20 18       	sub	r8,1
80005b52:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b54:	6f 18       	ld.w	r8,r7[0x44]
80005b56:	5b f8       	cp.w	r8,-1
80005b58:	c0 d1       	brne	80005b72 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b5a:	6e 48       	ld.w	r8,r7[0x10]
80005b5c:	58 08       	cp.w	r8,0
80005b5e:	c0 f0       	breq	80005b7c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b60:	ee cc ff f0 	sub	r12,r7,-16
80005b64:	f0 1f 00 08 	mcall	80005b84 <xQueueReceiveFromISR+0x4c>
80005b68:	c0 a0       	breq	80005b7c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b6a:	30 1c       	mov	r12,1
80005b6c:	8d 0c       	st.w	r6[0x0],r12
80005b6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b72:	2f f8       	sub	r8,-1
80005b74:	ef 48 00 44 	st.w	r7[68],r8
80005b78:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b7c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b80:	80 00       	ld.sh	r0,r0[0x0]
80005b82:	5b 08       	cp.w	r8,-16
80005b84:	80 00       	ld.sh	r0,r0[0x0]
80005b86:	61 40       	ld.w	r0,r0[0x50]

80005b88 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b88:	eb cd 40 c0 	pushm	r6-r7,lr
80005b8c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005b8e:	f0 1f 00 23 	mcall	80005c18 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b92:	6f 28       	ld.w	r8,r7[0x48]
80005b94:	58 08       	cp.w	r8,0
80005b96:	e0 8a 00 18 	brle	80005bc6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b9a:	6e 98       	ld.w	r8,r7[0x24]
80005b9c:	58 08       	cp.w	r8,0
80005b9e:	c1 40       	breq	80005bc6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ba0:	ee c6 ff dc 	sub	r6,r7,-36
80005ba4:	c0 48       	rjmp	80005bac <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ba6:	6e 98       	ld.w	r8,r7[0x24]
80005ba8:	58 08       	cp.w	r8,0
80005baa:	c0 e0       	breq	80005bc6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005bac:	0c 9c       	mov	r12,r6
80005bae:	f0 1f 00 1c 	mcall	80005c1c <prvUnlockQueue+0x94>
80005bb2:	c0 30       	breq	80005bb8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005bb4:	f0 1f 00 1b 	mcall	80005c20 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005bb8:	6f 28       	ld.w	r8,r7[0x48]
80005bba:	20 18       	sub	r8,1
80005bbc:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005bc0:	58 08       	cp.w	r8,0
80005bc2:	fe 99 ff f2 	brgt	80005ba6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005bc6:	3f f8       	mov	r8,-1
80005bc8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005bcc:	f0 1f 00 16 	mcall	80005c24 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005bd0:	f0 1f 00 12 	mcall	80005c18 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bd4:	6f 18       	ld.w	r8,r7[0x44]
80005bd6:	58 08       	cp.w	r8,0
80005bd8:	e0 8a 00 18 	brle	80005c08 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bdc:	6e 48       	ld.w	r8,r7[0x10]
80005bde:	58 08       	cp.w	r8,0
80005be0:	c1 40       	breq	80005c08 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005be2:	ee c6 ff f0 	sub	r6,r7,-16
80005be6:	c0 48       	rjmp	80005bee <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005be8:	6e 48       	ld.w	r8,r7[0x10]
80005bea:	58 08       	cp.w	r8,0
80005bec:	c0 e0       	breq	80005c08 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bee:	0c 9c       	mov	r12,r6
80005bf0:	f0 1f 00 0b 	mcall	80005c1c <prvUnlockQueue+0x94>
80005bf4:	c0 30       	breq	80005bfa <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005bf6:	f0 1f 00 0b 	mcall	80005c20 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005bfa:	6f 18       	ld.w	r8,r7[0x44]
80005bfc:	20 18       	sub	r8,1
80005bfe:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c02:	58 08       	cp.w	r8,0
80005c04:	fe 99 ff f2 	brgt	80005be8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005c08:	3f f8       	mov	r8,-1
80005c0a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005c0e:	f0 1f 00 06 	mcall	80005c24 <prvUnlockQueue+0x9c>
}
80005c12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c16:	00 00       	add	r0,r0
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	58 74       	cp.w	r4,7
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	61 40       	ld.w	r0,r0[0x50]
80005c20:	80 00       	ld.sh	r0,r0[0x0]
80005c22:	60 4c       	ld.w	r12,r0[0x10]
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	59 80       	cp.w	r0,24

80005c28 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005c28:	d4 31       	pushm	r0-r7,lr
80005c2a:	20 5d       	sub	sp,20
80005c2c:	18 97       	mov	r7,r12
80005c2e:	50 0b       	stdsp	sp[0x0],r11
80005c30:	50 2a       	stdsp	sp[0x8],r10
80005c32:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c34:	f8 c2 ff dc 	sub	r2,r12,-36
80005c38:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c3a:	fa c4 ff f4 	sub	r4,sp,-12
80005c3e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c40:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c42:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c46:	f0 1f 00 3e 	mcall	80005d3c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c4a:	6e e8       	ld.w	r8,r7[0x38]
80005c4c:	58 08       	cp.w	r8,0
80005c4e:	c2 a0       	breq	80005ca2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c50:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c52:	40 0b       	lddsp	r11,sp[0x0]
80005c54:	0e 9c       	mov	r12,r7
80005c56:	f0 1f 00 3b 	mcall	80005d40 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c5a:	40 18       	lddsp	r8,sp[0x4]
80005c5c:	58 08       	cp.w	r8,0
80005c5e:	c1 51       	brne	80005c88 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c60:	6e e8       	ld.w	r8,r7[0x38]
80005c62:	20 18       	sub	r8,1
80005c64:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c66:	6e 08       	ld.w	r8,r7[0x0]
80005c68:	58 08       	cp.w	r8,0
80005c6a:	c0 41       	brne	80005c72 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c6c:	f0 1f 00 36 	mcall	80005d44 <xQueueGenericReceive+0x11c>
80005c70:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c72:	6e 48       	ld.w	r8,r7[0x10]
80005c74:	58 08       	cp.w	r8,0
80005c76:	c1 20       	breq	80005c9a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c78:	ee cc ff f0 	sub	r12,r7,-16
80005c7c:	f0 1f 00 33 	mcall	80005d48 <xQueueGenericReceive+0x120>
80005c80:	58 1c       	cp.w	r12,1
80005c82:	c0 c1       	brne	80005c9a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c84:	d7 33       	scall
80005c86:	c0 a8       	rjmp	80005c9a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c88:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c8a:	6e 98       	ld.w	r8,r7[0x24]
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c0 60       	breq	80005c9a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c90:	04 9c       	mov	r12,r2
80005c92:	f0 1f 00 2e 	mcall	80005d48 <xQueueGenericReceive+0x120>
80005c96:	c0 20       	breq	80005c9a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005c98:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005c9a:	f0 1f 00 2d 	mcall	80005d4c <xQueueGenericReceive+0x124>
80005c9e:	30 1c       	mov	r12,1
				return pdPASS;
80005ca0:	c4 c8       	rjmp	80005d38 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005ca2:	40 28       	lddsp	r8,sp[0x8]
80005ca4:	58 08       	cp.w	r8,0
80005ca6:	c0 51       	brne	80005cb0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005ca8:	f0 1f 00 29 	mcall	80005d4c <xQueueGenericReceive+0x124>
80005cac:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005cae:	c4 58       	rjmp	80005d38 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005cb0:	58 05       	cp.w	r5,0
80005cb2:	c0 51       	brne	80005cbc <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005cb4:	08 9c       	mov	r12,r4
80005cb6:	f0 1f 00 27 	mcall	80005d50 <xQueueGenericReceive+0x128>
80005cba:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005cbc:	f0 1f 00 24 	mcall	80005d4c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005cc0:	f0 1f 00 25 	mcall	80005d54 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005cc4:	f0 1f 00 1e 	mcall	80005d3c <xQueueGenericReceive+0x114>
80005cc8:	6f 18       	ld.w	r8,r7[0x44]
80005cca:	5b f8       	cp.w	r8,-1
80005ccc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005cd0:	6f 28       	ld.w	r8,r7[0x48]
80005cd2:	5b f8       	cp.w	r8,-1
80005cd4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005cd8:	f0 1f 00 1d 	mcall	80005d4c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cdc:	06 9b       	mov	r11,r3
80005cde:	08 9c       	mov	r12,r4
80005ce0:	f0 1f 00 1e 	mcall	80005d58 <xQueueGenericReceive+0x130>
80005ce4:	c2 41       	brne	80005d2c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005ce6:	f0 1f 00 16 	mcall	80005d3c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cea:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005cec:	f0 1f 00 18 	mcall	80005d4c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005cf0:	58 06       	cp.w	r6,0
80005cf2:	c1 71       	brne	80005d20 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cf4:	6e 08       	ld.w	r8,r7[0x0]
80005cf6:	58 08       	cp.w	r8,0
80005cf8:	c0 81       	brne	80005d08 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005cfa:	f0 1f 00 11 	mcall	80005d3c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005cfe:	6e 1c       	ld.w	r12,r7[0x4]
80005d00:	f0 1f 00 17 	mcall	80005d5c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005d04:	f0 1f 00 12 	mcall	80005d4c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005d08:	40 2b       	lddsp	r11,sp[0x8]
80005d0a:	04 9c       	mov	r12,r2
80005d0c:	f0 1f 00 15 	mcall	80005d60 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005d10:	0e 9c       	mov	r12,r7
80005d12:	f0 1f 00 15 	mcall	80005d64 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005d16:	f0 1f 00 15 	mcall	80005d68 <xQueueGenericReceive+0x140>
80005d1a:	c9 61       	brne	80005c46 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005d1c:	d7 33       	scall
80005d1e:	c9 4b       	rjmp	80005c46 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005d20:	0e 9c       	mov	r12,r7
80005d22:	f0 1f 00 11 	mcall	80005d64 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005d26:	f0 1f 00 11 	mcall	80005d68 <xQueueGenericReceive+0x140>
80005d2a:	c8 eb       	rjmp	80005c46 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005d2c:	0e 9c       	mov	r12,r7
80005d2e:	f0 1f 00 0e 	mcall	80005d64 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005d32:	f0 1f 00 0e 	mcall	80005d68 <xQueueGenericReceive+0x140>
80005d36:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d38:	2f bd       	sub	sp,-20
80005d3a:	d8 32       	popm	r0-r7,pc
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	58 74       	cp.w	r4,7
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	5b 08       	cp.w	r8,-16
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	60 58       	ld.w	r8,r0[0x14]
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	61 40       	ld.w	r0,r0[0x50]
80005d4c:	80 00       	ld.sh	r0,r0[0x0]
80005d4e:	59 80       	cp.w	r0,24
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	60 34       	ld.w	r4,r0[0xc]
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	5f a8       	srle	r8
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	62 d0       	ld.w	r0,r1[0x34]
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	60 bc       	ld.w	r12,r0[0x2c]
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	65 70       	ld.w	r0,r2[0x5c]
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	5b 88       	cp.w	r8,-8
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	63 64       	ld.w	r4,r1[0x58]

80005d6c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d6c:	eb cd 40 80 	pushm	r7,lr
80005d70:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d72:	79 08       	ld.w	r8,r12[0x40]
80005d74:	58 08       	cp.w	r8,0
80005d76:	c0 a1       	brne	80005d8a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d78:	78 08       	ld.w	r8,r12[0x0]
80005d7a:	58 08       	cp.w	r8,0
80005d7c:	c2 b1       	brne	80005dd2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d7e:	78 1c       	ld.w	r12,r12[0x4]
80005d80:	f0 1f 00 17 	mcall	80005ddc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d84:	30 08       	mov	r8,0
80005d86:	8f 18       	st.w	r7[0x4],r8
80005d88:	c2 58       	rjmp	80005dd2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d8a:	58 0a       	cp.w	r10,0
80005d8c:	c1 01       	brne	80005dac <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d8e:	10 9a       	mov	r10,r8
80005d90:	78 2c       	ld.w	r12,r12[0x8]
80005d92:	f0 1f 00 14 	mcall	80005de0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005d96:	6e 29       	ld.w	r9,r7[0x8]
80005d98:	6f 08       	ld.w	r8,r7[0x40]
80005d9a:	f2 08 00 08 	add	r8,r9,r8
80005d9e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005da0:	6e 19       	ld.w	r9,r7[0x4]
80005da2:	12 38       	cp.w	r8,r9
80005da4:	c1 73       	brcs	80005dd2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005da6:	6e 08       	ld.w	r8,r7[0x0]
80005da8:	8f 28       	st.w	r7[0x8],r8
80005daa:	c1 48       	rjmp	80005dd2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005dac:	10 9a       	mov	r10,r8
80005dae:	78 3c       	ld.w	r12,r12[0xc]
80005db0:	f0 1f 00 0c 	mcall	80005de0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005db4:	6f 08       	ld.w	r8,r7[0x40]
80005db6:	6e 39       	ld.w	r9,r7[0xc]
80005db8:	f2 08 01 08 	sub	r8,r9,r8
80005dbc:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005dbe:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005dc0:	12 38       	cp.w	r8,r9
80005dc2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005dc6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005dca:	f3 d8 e3 19 	subcs	r9,r9,r8
80005dce:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005dd2:	6e e8       	ld.w	r8,r7[0x38]
80005dd4:	2f f8       	sub	r8,-1
80005dd6:	8f e8       	st.w	r7[0x38],r8
}
80005dd8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	60 64       	ld.w	r4,r0[0x18]
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	72 8c       	ld.w	r12,r9[0x20]

80005de4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005de4:	eb cd 40 c0 	pushm	r6-r7,lr
80005de8:	18 97       	mov	r7,r12
80005dea:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005dec:	78 ec       	ld.w	r12,r12[0x38]
80005dee:	6e f8       	ld.w	r8,r7[0x3c]
80005df0:	10 3c       	cp.w	r12,r8
80005df2:	c0 33       	brcs	80005df8 <xQueueGenericSendFromISR+0x14>
80005df4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005df8:	12 9a       	mov	r10,r9
80005dfa:	0e 9c       	mov	r12,r7
80005dfc:	f0 1f 00 0c 	mcall	80005e2c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005e00:	6f 28       	ld.w	r8,r7[0x48]
80005e02:	5b f8       	cp.w	r8,-1
80005e04:	c0 d1       	brne	80005e1e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e06:	6e 98       	ld.w	r8,r7[0x24]
80005e08:	58 08       	cp.w	r8,0
80005e0a:	c0 f0       	breq	80005e28 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005e0c:	ee cc ff dc 	sub	r12,r7,-36
80005e10:	f0 1f 00 08 	mcall	80005e30 <xQueueGenericSendFromISR+0x4c>
80005e14:	c0 a0       	breq	80005e28 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005e16:	30 1c       	mov	r12,1
80005e18:	8d 0c       	st.w	r6[0x0],r12
80005e1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005e1e:	2f f8       	sub	r8,-1
80005e20:	ef 48 00 48 	st.w	r7[72],r8
80005e24:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e28:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	5d 6c       	*unknown*
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	61 40       	ld.w	r0,r0[0x50]

80005e34 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e34:	d4 31       	pushm	r0-r7,lr
80005e36:	20 5d       	sub	sp,20
80005e38:	18 97       	mov	r7,r12
80005e3a:	50 0b       	stdsp	sp[0x0],r11
80005e3c:	50 2a       	stdsp	sp[0x8],r10
80005e3e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e40:	f8 c0 ff f0 	sub	r0,r12,-16
80005e44:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e46:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e4a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e4c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e50:	f0 1f 00 2f 	mcall	80005f0c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e54:	6e e9       	ld.w	r9,r7[0x38]
80005e56:	6e f8       	ld.w	r8,r7[0x3c]
80005e58:	10 39       	cp.w	r9,r8
80005e5a:	c1 42       	brcc	80005e82 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e5c:	40 1a       	lddsp	r10,sp[0x4]
80005e5e:	40 0b       	lddsp	r11,sp[0x0]
80005e60:	0e 9c       	mov	r12,r7
80005e62:	f0 1f 00 2c 	mcall	80005f10 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e66:	6e 98       	ld.w	r8,r7[0x24]
80005e68:	58 08       	cp.w	r8,0
80005e6a:	c0 80       	breq	80005e7a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e6c:	ee cc ff dc 	sub	r12,r7,-36
80005e70:	f0 1f 00 29 	mcall	80005f14 <xQueueGenericSend+0xe0>
80005e74:	58 1c       	cp.w	r12,1
80005e76:	c0 21       	brne	80005e7a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e78:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e7a:	f0 1f 00 28 	mcall	80005f18 <xQueueGenericSend+0xe4>
80005e7e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e80:	c4 38       	rjmp	80005f06 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e82:	40 28       	lddsp	r8,sp[0x8]
80005e84:	58 08       	cp.w	r8,0
80005e86:	c0 51       	brne	80005e90 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e88:	f0 1f 00 24 	mcall	80005f18 <xQueueGenericSend+0xe4>
80005e8c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005e8e:	c3 c8       	rjmp	80005f06 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005e90:	58 04       	cp.w	r4,0
80005e92:	c0 51       	brne	80005e9c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e94:	06 9c       	mov	r12,r3
80005e96:	f0 1f 00 22 	mcall	80005f1c <xQueueGenericSend+0xe8>
80005e9a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005e9c:	f0 1f 00 1f 	mcall	80005f18 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005ea0:	f0 1f 00 20 	mcall	80005f20 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005ea4:	f0 1f 00 1a 	mcall	80005f0c <xQueueGenericSend+0xd8>
80005ea8:	6f 18       	ld.w	r8,r7[0x44]
80005eaa:	5b f8       	cp.w	r8,-1
80005eac:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005eb0:	6f 28       	ld.w	r8,r7[0x48]
80005eb2:	5b f8       	cp.w	r8,-1
80005eb4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005eb8:	f0 1f 00 18 	mcall	80005f18 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ebc:	04 9b       	mov	r11,r2
80005ebe:	06 9c       	mov	r12,r3
80005ec0:	f0 1f 00 19 	mcall	80005f24 <xQueueGenericSend+0xf0>
80005ec4:	c1 b1       	brne	80005efa <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005ec6:	f0 1f 00 12 	mcall	80005f0c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005eca:	6e e5       	ld.w	r5,r7[0x38]
80005ecc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005ece:	f0 1f 00 13 	mcall	80005f18 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005ed2:	0c 35       	cp.w	r5,r6
80005ed4:	c0 d1       	brne	80005eee <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ed6:	40 2b       	lddsp	r11,sp[0x8]
80005ed8:	00 9c       	mov	r12,r0
80005eda:	f0 1f 00 14 	mcall	80005f28 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005ede:	0e 9c       	mov	r12,r7
80005ee0:	f0 1f 00 13 	mcall	80005f2c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005ee4:	f0 1f 00 13 	mcall	80005f30 <xQueueGenericSend+0xfc>
80005ee8:	cb 41       	brne	80005e50 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005eea:	d7 33       	scall
80005eec:	cb 2b       	rjmp	80005e50 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005eee:	0e 9c       	mov	r12,r7
80005ef0:	f0 1f 00 0f 	mcall	80005f2c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005ef4:	f0 1f 00 0f 	mcall	80005f30 <xQueueGenericSend+0xfc>
80005ef8:	ca cb       	rjmp	80005e50 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005efa:	0e 9c       	mov	r12,r7
80005efc:	f0 1f 00 0c 	mcall	80005f2c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005f00:	f0 1f 00 0c 	mcall	80005f30 <xQueueGenericSend+0xfc>
80005f04:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005f06:	2f bd       	sub	sp,-20
80005f08:	d8 32       	popm	r0-r7,pc
80005f0a:	00 00       	add	r0,r0
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	58 74       	cp.w	r4,7
80005f10:	80 00       	ld.sh	r0,r0[0x0]
80005f12:	5d 6c       	*unknown*
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	61 40       	ld.w	r0,r0[0x50]
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	59 80       	cp.w	r0,24
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	60 34       	ld.w	r4,r0[0xc]
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	5f a8       	srle	r8
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	62 d0       	ld.w	r0,r1[0x34]
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	65 70       	ld.w	r0,r2[0x5c]
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	5b 88       	cp.w	r8,-8
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	63 64       	ld.w	r4,r1[0x58]

80005f34 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f34:	d4 21       	pushm	r4-r7,lr
80005f36:	18 97       	mov	r7,r12
80005f38:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f3a:	58 0c       	cp.w	r12,0
80005f3c:	c2 f0       	breq	80005f9a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f3e:	34 cc       	mov	r12,76
80005f40:	f0 1f 00 17 	mcall	80005f9c <xQueueCreate+0x68>
80005f44:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f46:	c2 a0       	breq	80005f9a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f48:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f4c:	e8 cc ff ff 	sub	r12,r4,-1
80005f50:	f0 1f 00 13 	mcall	80005f9c <xQueueCreate+0x68>
80005f54:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f56:	c1 e0       	breq	80005f92 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f58:	f8 04 00 04 	add	r4,r12,r4
80005f5c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f5e:	30 08       	mov	r8,0
80005f60:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f62:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f64:	ee c8 00 01 	sub	r8,r7,1
80005f68:	ad 38       	mul	r8,r6
80005f6a:	10 0c       	add	r12,r8
80005f6c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f6e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f70:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f74:	3f f8       	mov	r8,-1
80005f76:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f7a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f7e:	ea cc ff f0 	sub	r12,r5,-16
80005f82:	f0 1f 00 08 	mcall	80005fa0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f86:	ea cc ff dc 	sub	r12,r5,-36
80005f8a:	f0 1f 00 06 	mcall	80005fa0 <xQueueCreate+0x6c>
80005f8e:	0a 9c       	mov	r12,r5
80005f90:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005f92:	0a 9c       	mov	r12,r5
80005f94:	f0 1f 00 04 	mcall	80005fa4 <xQueueCreate+0x70>
80005f98:	d8 2a       	popm	r4-r7,pc,r12=0
80005f9a:	d8 2a       	popm	r4-r7,pc,r12=0
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	5a e0       	cp.w	r0,-18
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	57 50       	stdsp	sp[0x1d4],r0
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	5a b8       	cp.w	r8,-21

80005fa8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005fa8:	48 38       	lddpc	r8,80005fb4 <vTaskSuspendAll+0xc>
80005faa:	70 09       	ld.w	r9,r8[0x0]
80005fac:	2f f9       	sub	r9,-1
80005fae:	91 09       	st.w	r8[0x0],r9
}
80005fb0:	5e fc       	retal	r12
80005fb2:	00 00       	add	r0,r0
80005fb4:	00 00       	add	r0,r0
80005fb6:	0d 04       	ld.w	r4,r6++

80005fb8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005fb8:	49 a8       	lddpc	r8,80006020 <vTaskSwitchContext+0x68>
80005fba:	70 08       	ld.w	r8,r8[0x0]
80005fbc:	58 08       	cp.w	r8,0
80005fbe:	c0 b1       	brne	80005fd4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fc0:	49 98       	lddpc	r8,80006024 <vTaskSwitchContext+0x6c>
80005fc2:	70 08       	ld.w	r8,r8[0x0]
80005fc4:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fc8:	49 89       	lddpc	r9,80006028 <vTaskSwitchContext+0x70>
80005fca:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005fce:	58 08       	cp.w	r8,0
80005fd0:	c0 60       	breq	80005fdc <vTaskSwitchContext+0x24>
80005fd2:	c1 18       	rjmp	80005ff4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005fd4:	30 19       	mov	r9,1
80005fd6:	49 68       	lddpc	r8,8000602c <vTaskSwitchContext+0x74>
80005fd8:	91 09       	st.w	r8[0x0],r9
80005fda:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fdc:	49 28       	lddpc	r8,80006024 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fde:	49 3a       	lddpc	r10,80006028 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fe0:	70 09       	ld.w	r9,r8[0x0]
80005fe2:	20 19       	sub	r9,1
80005fe4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fe6:	70 09       	ld.w	r9,r8[0x0]
80005fe8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fec:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005ff0:	58 09       	cp.w	r9,0
80005ff2:	cf 70       	breq	80005fe0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005ff4:	48 c8       	lddpc	r8,80006024 <vTaskSwitchContext+0x6c>
80005ff6:	70 08       	ld.w	r8,r8[0x0]
80005ff8:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005ffc:	48 b9       	lddpc	r9,80006028 <vTaskSwitchContext+0x70>
80005ffe:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006002:	70 19       	ld.w	r9,r8[0x4]
80006004:	72 19       	ld.w	r9,r9[0x4]
80006006:	91 19       	st.w	r8[0x4],r9
80006008:	f0 ca ff f8 	sub	r10,r8,-8
8000600c:	14 39       	cp.w	r9,r10
8000600e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006012:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006016:	70 18       	ld.w	r8,r8[0x4]
80006018:	70 39       	ld.w	r9,r8[0xc]
8000601a:	48 68       	lddpc	r8,80006030 <vTaskSwitchContext+0x78>
8000601c:	91 09       	st.w	r8[0x0],r9
8000601e:	5e fc       	retal	r12
80006020:	00 00       	add	r0,r0
80006022:	0d 04       	ld.w	r4,r6++
80006024:	00 00       	add	r0,r0
80006026:	0d 3c       	ld.ub	r12,r6++
80006028:	00 00       	add	r0,r0
8000602a:	0c 20       	rsub	r0,r6
8000602c:	00 00       	add	r0,r0
8000602e:	0d 24       	ld.uh	r4,r6++
80006030:	00 00       	add	r0,r0
80006032:	0c d4       	st.w	--r6,r4

80006034 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006034:	48 48       	lddpc	r8,80006044 <vTaskSetTimeOutState+0x10>
80006036:	70 08       	ld.w	r8,r8[0x0]
80006038:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000603a:	48 48       	lddpc	r8,80006048 <vTaskSetTimeOutState+0x14>
8000603c:	70 08       	ld.w	r8,r8[0x0]
8000603e:	99 18       	st.w	r12[0x4],r8
}
80006040:	5e fc       	retal	r12
80006042:	00 00       	add	r0,r0
80006044:	00 00       	add	r0,r0
80006046:	0c 18       	sub	r8,r6
80006048:	00 00       	add	r0,r0
8000604a:	0d 00       	ld.w	r0,r6++

8000604c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000604c:	30 19       	mov	r9,1
8000604e:	48 28       	lddpc	r8,80006054 <vTaskMissedYield+0x8>
80006050:	91 09       	st.w	r8[0x0],r9
}
80006052:	5e fc       	retal	r12
80006054:	00 00       	add	r0,r0
80006056:	0d 24       	ld.uh	r4,r6++

80006058 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006058:	48 28       	lddpc	r8,80006060 <xTaskGetCurrentTaskHandle+0x8>
8000605a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000605c:	5e fc       	retal	r12
8000605e:	00 00       	add	r0,r0
80006060:	00 00       	add	r0,r0
80006062:	0c d4       	st.w	--r6,r4

80006064 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006064:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006068:	58 0c       	cp.w	r12,0
8000606a:	c1 f0       	breq	800060a8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000606c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000606e:	78 b9       	ld.w	r9,r12[0x2c]
80006070:	79 18       	ld.w	r8,r12[0x44]
80006072:	10 39       	cp.w	r9,r8
80006074:	c1 a0       	breq	800060a8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006076:	f8 c6 ff fc 	sub	r6,r12,-4
8000607a:	0c 9c       	mov	r12,r6
8000607c:	f0 1f 00 0c 	mcall	800060ac <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006080:	6f 1c       	ld.w	r12,r7[0x44]
80006082:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006084:	f8 08 11 08 	rsub	r8,r12,8
80006088:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000608a:	48 a8       	lddpc	r8,800060b0 <vTaskPriorityDisinherit+0x4c>
8000608c:	70 08       	ld.w	r8,r8[0x0]
8000608e:	10 3c       	cp.w	r12,r8
80006090:	e0 88 00 04 	brls	80006098 <vTaskPriorityDisinherit+0x34>
80006094:	48 78       	lddpc	r8,800060b0 <vTaskPriorityDisinherit+0x4c>
80006096:	91 0c       	st.w	r8[0x0],r12
80006098:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000609c:	0c 9b       	mov	r11,r6
8000609e:	48 68       	lddpc	r8,800060b4 <vTaskPriorityDisinherit+0x50>
800060a0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060a4:	f0 1f 00 05 	mcall	800060b8 <vTaskPriorityDisinherit+0x54>
800060a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	57 ba       	stdsp	sp[0x1ec],r10
800060b0:	00 00       	add	r0,r0
800060b2:	0d 3c       	ld.ub	r12,r6++
800060b4:	00 00       	add	r0,r0
800060b6:	0c 20       	rsub	r0,r6
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	57 6a       	stdsp	sp[0x1d8],r10

800060bc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800060bc:	eb cd 40 c0 	pushm	r6-r7,lr
800060c0:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800060c2:	49 b8       	lddpc	r8,8000612c <vTaskPriorityInherit+0x70>
800060c4:	70 08       	ld.w	r8,r8[0x0]
800060c6:	78 b9       	ld.w	r9,r12[0x2c]
800060c8:	70 b8       	ld.w	r8,r8[0x2c]
800060ca:	10 39       	cp.w	r9,r8
800060cc:	c2 d2       	brcc	80006126 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060ce:	49 88       	lddpc	r8,8000612c <vTaskPriorityInherit+0x70>
800060d0:	70 08       	ld.w	r8,r8[0x0]
800060d2:	70 b8       	ld.w	r8,r8[0x2c]
800060d4:	f0 08 11 08 	rsub	r8,r8,8
800060d8:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060da:	f2 09 00 28 	add	r8,r9,r9<<0x2
800060de:	49 59       	lddpc	r9,80006130 <vTaskPriorityInherit+0x74>
800060e0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800060e4:	78 59       	ld.w	r9,r12[0x14]
800060e6:	10 39       	cp.w	r9,r8
800060e8:	c1 b1       	brne	8000611e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800060ea:	f8 c6 ff fc 	sub	r6,r12,-4
800060ee:	0c 9c       	mov	r12,r6
800060f0:	f0 1f 00 11 	mcall	80006134 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800060f4:	48 e8       	lddpc	r8,8000612c <vTaskPriorityInherit+0x70>
800060f6:	70 08       	ld.w	r8,r8[0x0]
800060f8:	70 bc       	ld.w	r12,r8[0x2c]
800060fa:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800060fc:	48 f8       	lddpc	r8,80006138 <vTaskPriorityInherit+0x7c>
800060fe:	70 08       	ld.w	r8,r8[0x0]
80006100:	10 3c       	cp.w	r12,r8
80006102:	e0 88 00 04 	brls	8000610a <vTaskPriorityInherit+0x4e>
80006106:	48 d8       	lddpc	r8,80006138 <vTaskPriorityInherit+0x7c>
80006108:	91 0c       	st.w	r8[0x0],r12
8000610a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000610e:	0c 9b       	mov	r11,r6
80006110:	48 88       	lddpc	r8,80006130 <vTaskPriorityInherit+0x74>
80006112:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006116:	f0 1f 00 0a 	mcall	8000613c <vTaskPriorityInherit+0x80>
8000611a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000611e:	48 48       	lddpc	r8,8000612c <vTaskPriorityInherit+0x70>
80006120:	70 08       	ld.w	r8,r8[0x0]
80006122:	70 b8       	ld.w	r8,r8[0x2c]
80006124:	99 b8       	st.w	r12[0x2c],r8
80006126:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000612a:	00 00       	add	r0,r0
8000612c:	00 00       	add	r0,r0
8000612e:	0c d4       	st.w	--r6,r4
80006130:	00 00       	add	r0,r0
80006132:	0c 20       	rsub	r0,r6
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	57 ba       	stdsp	sp[0x1ec],r10
80006138:	00 00       	add	r0,r0
8000613a:	0d 3c       	ld.ub	r12,r6++
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	57 6a       	stdsp	sp[0x1d8],r10

80006140 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006140:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006144:	78 38       	ld.w	r8,r12[0xc]
80006146:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006148:	ee c6 ff e8 	sub	r6,r7,-24
8000614c:	0c 9c       	mov	r12,r6
8000614e:	f0 1f 00 15 	mcall	800061a0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006152:	49 58       	lddpc	r8,800061a4 <xTaskRemoveFromEventList+0x64>
80006154:	70 08       	ld.w	r8,r8[0x0]
80006156:	58 08       	cp.w	r8,0
80006158:	c1 71       	brne	80006186 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000615a:	ee c6 ff fc 	sub	r6,r7,-4
8000615e:	0c 9c       	mov	r12,r6
80006160:	f0 1f 00 10 	mcall	800061a0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006164:	6e bc       	ld.w	r12,r7[0x2c]
80006166:	49 18       	lddpc	r8,800061a8 <xTaskRemoveFromEventList+0x68>
80006168:	70 08       	ld.w	r8,r8[0x0]
8000616a:	10 3c       	cp.w	r12,r8
8000616c:	e0 88 00 04 	brls	80006174 <xTaskRemoveFromEventList+0x34>
80006170:	48 e8       	lddpc	r8,800061a8 <xTaskRemoveFromEventList+0x68>
80006172:	91 0c       	st.w	r8[0x0],r12
80006174:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006178:	0c 9b       	mov	r11,r6
8000617a:	48 d8       	lddpc	r8,800061ac <xTaskRemoveFromEventList+0x6c>
8000617c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006180:	f0 1f 00 0c 	mcall	800061b0 <xTaskRemoveFromEventList+0x70>
80006184:	c0 58       	rjmp	8000618e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006186:	0c 9b       	mov	r11,r6
80006188:	48 bc       	lddpc	r12,800061b4 <xTaskRemoveFromEventList+0x74>
8000618a:	f0 1f 00 0a 	mcall	800061b0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000618e:	48 b8       	lddpc	r8,800061b8 <xTaskRemoveFromEventList+0x78>
80006190:	70 08       	ld.w	r8,r8[0x0]
80006192:	6e b9       	ld.w	r9,r7[0x2c]
80006194:	70 b8       	ld.w	r8,r8[0x2c]
80006196:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006198:	5f 2c       	srhs	r12
8000619a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000619e:	00 00       	add	r0,r0
800061a0:	80 00       	ld.sh	r0,r0[0x0]
800061a2:	57 ba       	stdsp	sp[0x1ec],r10
800061a4:	00 00       	add	r0,r0
800061a6:	0d 04       	ld.w	r4,r6++
800061a8:	00 00       	add	r0,r0
800061aa:	0d 3c       	ld.ub	r12,r6++
800061ac:	00 00       	add	r0,r0
800061ae:	0c 20       	rsub	r0,r6
800061b0:	80 00       	ld.sh	r0,r0[0x0]
800061b2:	57 6a       	stdsp	sp[0x1d8],r10
800061b4:	00 00       	add	r0,r0
800061b6:	0c d8       	st.w	--r6,r8
800061b8:	00 00       	add	r0,r0
800061ba:	0c d4       	st.w	--r6,r4

800061bc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800061bc:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061c0:	4b 98       	lddpc	r8,800062a4 <vTaskIncrementTick+0xe8>
800061c2:	70 08       	ld.w	r8,r8[0x0]
800061c4:	58 08       	cp.w	r8,0
800061c6:	c6 91       	brne	80006298 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800061c8:	4b 88       	lddpc	r8,800062a8 <vTaskIncrementTick+0xec>
800061ca:	70 09       	ld.w	r9,r8[0x0]
800061cc:	2f f9       	sub	r9,-1
800061ce:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061d0:	70 08       	ld.w	r8,r8[0x0]
800061d2:	58 08       	cp.w	r8,0
800061d4:	c1 a1       	brne	80006208 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061d6:	4b 68       	lddpc	r8,800062ac <vTaskIncrementTick+0xf0>
800061d8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061da:	4b 69       	lddpc	r9,800062b0 <vTaskIncrementTick+0xf4>
800061dc:	72 0b       	ld.w	r11,r9[0x0]
800061de:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800061e0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800061e2:	4b 59       	lddpc	r9,800062b4 <vTaskIncrementTick+0xf8>
800061e4:	72 0a       	ld.w	r10,r9[0x0]
800061e6:	2f fa       	sub	r10,-1
800061e8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800061ea:	70 08       	ld.w	r8,r8[0x0]
800061ec:	70 08       	ld.w	r8,r8[0x0]
800061ee:	58 08       	cp.w	r8,0
800061f0:	c0 51       	brne	800061fa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800061f2:	3f f9       	mov	r9,-1
800061f4:	4b 18       	lddpc	r8,800062b8 <vTaskIncrementTick+0xfc>
800061f6:	91 09       	st.w	r8[0x0],r9
800061f8:	c0 88       	rjmp	80006208 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800061fa:	4a d8       	lddpc	r8,800062ac <vTaskIncrementTick+0xf0>
800061fc:	70 08       	ld.w	r8,r8[0x0]
800061fe:	70 38       	ld.w	r8,r8[0xc]
80006200:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006202:	70 19       	ld.w	r9,r8[0x4]
80006204:	4a d8       	lddpc	r8,800062b8 <vTaskIncrementTick+0xfc>
80006206:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006208:	4a 88       	lddpc	r8,800062a8 <vTaskIncrementTick+0xec>
8000620a:	70 09       	ld.w	r9,r8[0x0]
8000620c:	4a b8       	lddpc	r8,800062b8 <vTaskIncrementTick+0xfc>
8000620e:	70 08       	ld.w	r8,r8[0x0]
80006210:	10 39       	cp.w	r9,r8
80006212:	c4 73       	brcs	800062a0 <vTaskIncrementTick+0xe4>
80006214:	4a 68       	lddpc	r8,800062ac <vTaskIncrementTick+0xf0>
80006216:	70 08       	ld.w	r8,r8[0x0]
80006218:	70 08       	ld.w	r8,r8[0x0]
8000621a:	58 08       	cp.w	r8,0
8000621c:	c0 c0       	breq	80006234 <vTaskIncrementTick+0x78>
8000621e:	4a 48       	lddpc	r8,800062ac <vTaskIncrementTick+0xf0>
80006220:	70 08       	ld.w	r8,r8[0x0]
80006222:	70 38       	ld.w	r8,r8[0xc]
80006224:	70 37       	ld.w	r7,r8[0xc]
80006226:	6e 18       	ld.w	r8,r7[0x4]
80006228:	4a 09       	lddpc	r9,800062a8 <vTaskIncrementTick+0xec>
8000622a:	72 09       	ld.w	r9,r9[0x0]
8000622c:	12 38       	cp.w	r8,r9
8000622e:	e0 88 00 14 	brls	80006256 <vTaskIncrementTick+0x9a>
80006232:	c0 e8       	rjmp	8000624e <vTaskIncrementTick+0x92>
80006234:	3f f9       	mov	r9,-1
80006236:	4a 18       	lddpc	r8,800062b8 <vTaskIncrementTick+0xfc>
80006238:	91 09       	st.w	r8[0x0],r9
8000623a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000623e:	6a 08       	ld.w	r8,r5[0x0]
80006240:	70 38       	ld.w	r8,r8[0xc]
80006242:	70 37       	ld.w	r7,r8[0xc]
80006244:	6e 18       	ld.w	r8,r7[0x4]
80006246:	64 09       	ld.w	r9,r2[0x0]
80006248:	12 38       	cp.w	r8,r9
8000624a:	e0 88 00 0a 	brls	8000625e <vTaskIncrementTick+0xa2>
8000624e:	49 b9       	lddpc	r9,800062b8 <vTaskIncrementTick+0xfc>
80006250:	93 08       	st.w	r9[0x0],r8
80006252:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006256:	49 a4       	lddpc	r4,800062bc <vTaskIncrementTick+0x100>
80006258:	49 a3       	lddpc	r3,800062c0 <vTaskIncrementTick+0x104>
8000625a:	49 55       	lddpc	r5,800062ac <vTaskIncrementTick+0xf0>
8000625c:	49 32       	lddpc	r2,800062a8 <vTaskIncrementTick+0xec>
8000625e:	ee c6 ff fc 	sub	r6,r7,-4
80006262:	0c 9c       	mov	r12,r6
80006264:	f0 1f 00 18 	mcall	800062c4 <vTaskIncrementTick+0x108>
80006268:	6e a8       	ld.w	r8,r7[0x28]
8000626a:	58 08       	cp.w	r8,0
8000626c:	c0 50       	breq	80006276 <vTaskIncrementTick+0xba>
8000626e:	ee cc ff e8 	sub	r12,r7,-24
80006272:	f0 1f 00 15 	mcall	800062c4 <vTaskIncrementTick+0x108>
80006276:	6e bc       	ld.w	r12,r7[0x2c]
80006278:	68 08       	ld.w	r8,r4[0x0]
8000627a:	10 3c       	cp.w	r12,r8
8000627c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006280:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006284:	0c 9b       	mov	r11,r6
80006286:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000628a:	f0 1f 00 10 	mcall	800062c8 <vTaskIncrementTick+0x10c>
8000628e:	6a 08       	ld.w	r8,r5[0x0]
80006290:	70 08       	ld.w	r8,r8[0x0]
80006292:	58 08       	cp.w	r8,0
80006294:	cd 51       	brne	8000623e <vTaskIncrementTick+0x82>
80006296:	cc fb       	rjmp	80006234 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006298:	48 d8       	lddpc	r8,800062cc <vTaskIncrementTick+0x110>
8000629a:	70 09       	ld.w	r9,r8[0x0]
8000629c:	2f f9       	sub	r9,-1
8000629e:	91 09       	st.w	r8[0x0],r9
800062a0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062a4:	00 00       	add	r0,r0
800062a6:	0d 04       	ld.w	r4,r6++
800062a8:	00 00       	add	r0,r0
800062aa:	0d 00       	ld.w	r0,r6++
800062ac:	00 00       	add	r0,r0
800062ae:	0c 0c       	add	r12,r6
800062b0:	00 00       	add	r0,r0
800062b2:	0c 1c       	sub	r12,r6
800062b4:	00 00       	add	r0,r0
800062b6:	0c 18       	sub	r8,r6
800062b8:	00 00       	add	r0,r0
800062ba:	05 34       	ld.ub	r4,r2++
800062bc:	00 00       	add	r0,r0
800062be:	0d 3c       	ld.ub	r12,r6++
800062c0:	00 00       	add	r0,r0
800062c2:	0c 20       	rsub	r0,r6
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	57 ba       	stdsp	sp[0x1ec],r10
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	57 6a       	stdsp	sp[0x1d8],r10
800062cc:	00 00       	add	r0,r0
800062ce:	0c 04       	add	r4,r6

800062d0 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062d0:	eb cd 40 c0 	pushm	r6-r7,lr
800062d4:	18 97       	mov	r7,r12
800062d6:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062d8:	f0 1f 00 15 	mcall	8000632c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062dc:	6c 08       	ld.w	r8,r6[0x0]
800062de:	5b f8       	cp.w	r8,-1
800062e0:	c0 31       	brne	800062e6 <xTaskCheckForTimeOut+0x16>
800062e2:	30 07       	mov	r7,0
800062e4:	c1 f8       	rjmp	80006322 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062e6:	49 39       	lddpc	r9,80006330 <xTaskCheckForTimeOut+0x60>
800062e8:	72 09       	ld.w	r9,r9[0x0]
800062ea:	6e 0a       	ld.w	r10,r7[0x0]
800062ec:	12 3a       	cp.w	r10,r9
800062ee:	c0 70       	breq	800062fc <xTaskCheckForTimeOut+0x2c>
800062f0:	49 19       	lddpc	r9,80006334 <xTaskCheckForTimeOut+0x64>
800062f2:	72 09       	ld.w	r9,r9[0x0]
800062f4:	6e 1a       	ld.w	r10,r7[0x4]
800062f6:	12 3a       	cp.w	r10,r9
800062f8:	e0 88 00 14 	brls	80006320 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800062fc:	48 e9       	lddpc	r9,80006334 <xTaskCheckForTimeOut+0x64>
800062fe:	72 0a       	ld.w	r10,r9[0x0]
80006300:	6e 19       	ld.w	r9,r7[0x4]
80006302:	12 1a       	sub	r10,r9
80006304:	14 38       	cp.w	r8,r10
80006306:	e0 88 00 0d 	brls	80006320 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000630a:	48 ba       	lddpc	r10,80006334 <xTaskCheckForTimeOut+0x64>
8000630c:	74 0a       	ld.w	r10,r10[0x0]
8000630e:	14 19       	sub	r9,r10
80006310:	f2 08 00 08 	add	r8,r9,r8
80006314:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006316:	0e 9c       	mov	r12,r7
80006318:	f0 1f 00 08 	mcall	80006338 <xTaskCheckForTimeOut+0x68>
8000631c:	30 07       	mov	r7,0
8000631e:	c0 28       	rjmp	80006322 <xTaskCheckForTimeOut+0x52>
80006320:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006322:	f0 1f 00 07 	mcall	8000633c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006326:	0e 9c       	mov	r12,r7
80006328:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	58 74       	cp.w	r4,7
80006330:	00 00       	add	r0,r0
80006332:	0c 18       	sub	r8,r6
80006334:	00 00       	add	r0,r0
80006336:	0d 00       	ld.w	r0,r6++
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	60 34       	ld.w	r4,r0[0xc]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	59 80       	cp.w	r0,24

80006340 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006340:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006344:	f0 1f 00 05 	mcall	80006358 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006348:	48 58       	lddpc	r8,8000635c <xTaskGetTickCount+0x1c>
8000634a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000634c:	f0 1f 00 05 	mcall	80006360 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006350:	0e 9c       	mov	r12,r7
80006352:	e3 cd 80 80 	ldm	sp++,r7,pc
80006356:	00 00       	add	r0,r0
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	58 74       	cp.w	r4,7
8000635c:	00 00       	add	r0,r0
8000635e:	0d 00       	ld.w	r0,r6++
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	59 80       	cp.w	r0,24

80006364 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006364:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006368:	f0 1f 00 2c 	mcall	80006418 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000636c:	4a c8       	lddpc	r8,8000641c <xTaskResumeAll+0xb8>
8000636e:	70 09       	ld.w	r9,r8[0x0]
80006370:	20 19       	sub	r9,1
80006372:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006374:	70 08       	ld.w	r8,r8[0x0]
80006376:	58 08       	cp.w	r8,0
80006378:	c4 91       	brne	8000640a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000637a:	4a a8       	lddpc	r8,80006420 <xTaskResumeAll+0xbc>
8000637c:	70 08       	ld.w	r8,r8[0x0]
8000637e:	58 08       	cp.w	r8,0
80006380:	c4 50       	breq	8000640a <xTaskResumeAll+0xa6>
80006382:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006384:	4a 85       	lddpc	r5,80006424 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006386:	4a 93       	lddpc	r3,80006428 <xTaskResumeAll+0xc4>
80006388:	4a 92       	lddpc	r2,8000642c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000638a:	4a a1       	lddpc	r1,80006430 <xTaskResumeAll+0xcc>
8000638c:	c1 e8       	rjmp	800063c8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000638e:	6a 38       	ld.w	r8,r5[0xc]
80006390:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006392:	ee cc ff e8 	sub	r12,r7,-24
80006396:	f0 1f 00 28 	mcall	80006434 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000639a:	ee c6 ff fc 	sub	r6,r7,-4
8000639e:	0c 9c       	mov	r12,r6
800063a0:	f0 1f 00 25 	mcall	80006434 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800063a4:	6e bc       	ld.w	r12,r7[0x2c]
800063a6:	66 08       	ld.w	r8,r3[0x0]
800063a8:	10 3c       	cp.w	r12,r8
800063aa:	e7 fc ba 00 	st.whi	r3[0x0],r12
800063ae:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063b2:	0c 9b       	mov	r11,r6
800063b4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800063b8:	f0 1f 00 20 	mcall	80006438 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063bc:	62 08       	ld.w	r8,r1[0x0]
800063be:	6e b9       	ld.w	r9,r7[0x2c]
800063c0:	70 b8       	ld.w	r8,r8[0x2c]
800063c2:	10 39       	cp.w	r9,r8
800063c4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063c8:	6a 08       	ld.w	r8,r5[0x0]
800063ca:	58 08       	cp.w	r8,0
800063cc:	ce 11       	brne	8000638e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063ce:	49 c8       	lddpc	r8,8000643c <xTaskResumeAll+0xd8>
800063d0:	70 08       	ld.w	r8,r8[0x0]
800063d2:	58 08       	cp.w	r8,0
800063d4:	c0 f0       	breq	800063f2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063d6:	49 a8       	lddpc	r8,8000643c <xTaskResumeAll+0xd8>
800063d8:	70 08       	ld.w	r8,r8[0x0]
800063da:	58 08       	cp.w	r8,0
800063dc:	c1 10       	breq	800063fe <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800063de:	49 87       	lddpc	r7,8000643c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800063e0:	f0 1f 00 18 	mcall	80006440 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800063e4:	6e 08       	ld.w	r8,r7[0x0]
800063e6:	20 18       	sub	r8,1
800063e8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063ea:	6e 08       	ld.w	r8,r7[0x0]
800063ec:	58 08       	cp.w	r8,0
800063ee:	cf 91       	brne	800063e0 <xTaskResumeAll+0x7c>
800063f0:	c0 78       	rjmp	800063fe <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800063f2:	58 14       	cp.w	r4,1
800063f4:	c0 50       	breq	800063fe <xTaskResumeAll+0x9a>
800063f6:	49 48       	lddpc	r8,80006444 <xTaskResumeAll+0xe0>
800063f8:	70 08       	ld.w	r8,r8[0x0]
800063fa:	58 18       	cp.w	r8,1
800063fc:	c0 71       	brne	8000640a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800063fe:	30 09       	mov	r9,0
80006400:	49 18       	lddpc	r8,80006444 <xTaskResumeAll+0xe0>
80006402:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006404:	d7 33       	scall
80006406:	30 17       	mov	r7,1
80006408:	c0 28       	rjmp	8000640c <xTaskResumeAll+0xa8>
8000640a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000640c:	f0 1f 00 0f 	mcall	80006448 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006410:	0e 9c       	mov	r12,r7
80006412:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006416:	00 00       	add	r0,r0
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	58 74       	cp.w	r4,7
8000641c:	00 00       	add	r0,r0
8000641e:	0d 04       	ld.w	r4,r6++
80006420:	00 00       	add	r0,r0
80006422:	0d 20       	ld.uh	r0,r6++
80006424:	00 00       	add	r0,r0
80006426:	0c d8       	st.w	--r6,r8
80006428:	00 00       	add	r0,r0
8000642a:	0d 3c       	ld.ub	r12,r6++
8000642c:	00 00       	add	r0,r0
8000642e:	0c 20       	rsub	r0,r6
80006430:	00 00       	add	r0,r0
80006432:	0c d4       	st.w	--r6,r4
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	57 ba       	stdsp	sp[0x1ec],r10
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	57 6a       	stdsp	sp[0x1d8],r10
8000643c:	00 00       	add	r0,r0
8000643e:	0c 04       	add	r4,r6
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	61 bc       	ld.w	r12,r0[0x6c]
80006444:	00 00       	add	r0,r0
80006446:	0d 24       	ld.uh	r4,r6++
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	59 80       	cp.w	r0,24

8000644c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000644c:	eb cd 40 80 	pushm	r7,lr
80006450:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006452:	49 08       	lddpc	r8,80006490 <prvAddCurrentTaskToDelayedList+0x44>
80006454:	70 08       	ld.w	r8,r8[0x0]
80006456:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006458:	48 f8       	lddpc	r8,80006494 <prvAddCurrentTaskToDelayedList+0x48>
8000645a:	70 08       	ld.w	r8,r8[0x0]
8000645c:	10 3c       	cp.w	r12,r8
8000645e:	c0 a2       	brcc	80006472 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006460:	48 c8       	lddpc	r8,80006490 <prvAddCurrentTaskToDelayedList+0x44>
80006462:	70 0b       	ld.w	r11,r8[0x0]
80006464:	48 d8       	lddpc	r8,80006498 <prvAddCurrentTaskToDelayedList+0x4c>
80006466:	70 0c       	ld.w	r12,r8[0x0]
80006468:	2f cb       	sub	r11,-4
8000646a:	f0 1f 00 0d 	mcall	8000649c <prvAddCurrentTaskToDelayedList+0x50>
8000646e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006472:	48 88       	lddpc	r8,80006490 <prvAddCurrentTaskToDelayedList+0x44>
80006474:	70 0b       	ld.w	r11,r8[0x0]
80006476:	48 b8       	lddpc	r8,800064a0 <prvAddCurrentTaskToDelayedList+0x54>
80006478:	70 0c       	ld.w	r12,r8[0x0]
8000647a:	2f cb       	sub	r11,-4
8000647c:	f0 1f 00 08 	mcall	8000649c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006480:	48 98       	lddpc	r8,800064a4 <prvAddCurrentTaskToDelayedList+0x58>
80006482:	70 08       	ld.w	r8,r8[0x0]
80006484:	10 37       	cp.w	r7,r8
80006486:	c0 32       	brcc	8000648c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006488:	48 78       	lddpc	r8,800064a4 <prvAddCurrentTaskToDelayedList+0x58>
8000648a:	91 07       	st.w	r8[0x0],r7
8000648c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006490:	00 00       	add	r0,r0
80006492:	0c d4       	st.w	--r6,r4
80006494:	00 00       	add	r0,r0
80006496:	0d 00       	ld.w	r0,r6++
80006498:	00 00       	add	r0,r0
8000649a:	0c 1c       	sub	r12,r6
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	57 86       	stdsp	sp[0x1e0],r6
800064a0:	00 00       	add	r0,r0
800064a2:	0c 0c       	add	r12,r6
800064a4:	00 00       	add	r0,r0
800064a6:	05 34       	ld.ub	r4,r2++

800064a8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800064a8:	eb cd 40 c0 	pushm	r6-r7,lr
800064ac:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800064ae:	58 0c       	cp.w	r12,0
800064b0:	c1 10       	breq	800064d2 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800064b2:	f0 1f 00 0a 	mcall	800064d8 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800064b6:	48 a8       	lddpc	r8,800064dc <vTaskDelay+0x34>
800064b8:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064ba:	48 a8       	lddpc	r8,800064e0 <vTaskDelay+0x38>
800064bc:	70 0c       	ld.w	r12,r8[0x0]
800064be:	2f cc       	sub	r12,-4
800064c0:	f0 1f 00 09 	mcall	800064e4 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800064c4:	ee 06 00 0c 	add	r12,r7,r6
800064c8:	f0 1f 00 08 	mcall	800064e8 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800064cc:	f0 1f 00 08 	mcall	800064ec <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800064d0:	c0 21       	brne	800064d4 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800064d2:	d7 33       	scall
800064d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	5f a8       	srle	r8
800064dc:	00 00       	add	r0,r0
800064de:	0d 00       	ld.w	r0,r6++
800064e0:	00 00       	add	r0,r0
800064e2:	0c d4       	st.w	--r6,r4
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	57 ba       	stdsp	sp[0x1ec],r10
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	64 4c       	ld.w	r12,r2[0x10]
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	63 64       	ld.w	r4,r1[0x58]

800064f0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800064f0:	eb cd 40 c0 	pushm	r6-r7,lr
800064f4:	18 96       	mov	r6,r12
800064f6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800064f8:	f0 1f 00 18 	mcall	80006558 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800064fc:	6c 08       	ld.w	r8,r6[0x0]
800064fe:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006500:	49 79       	lddpc	r9,8000655c <vTaskDelayUntil+0x6c>
80006502:	72 09       	ld.w	r9,r9[0x0]
80006504:	12 38       	cp.w	r8,r9
80006506:	e0 88 00 0c 	brls	8000651e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000650a:	0e 38       	cp.w	r8,r7
8000650c:	e0 88 00 22 	brls	80006550 <vTaskDelayUntil+0x60>
80006510:	49 38       	lddpc	r8,8000655c <vTaskDelayUntil+0x6c>
80006512:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006514:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006516:	10 37       	cp.w	r7,r8
80006518:	e0 88 00 14 	brls	80006540 <vTaskDelayUntil+0x50>
8000651c:	c0 a8       	rjmp	80006530 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000651e:	0e 38       	cp.w	r8,r7
80006520:	e0 8b 00 16 	brhi	8000654c <vTaskDelayUntil+0x5c>
80006524:	48 e8       	lddpc	r8,8000655c <vTaskDelayUntil+0x6c>
80006526:	70 08       	ld.w	r8,r8[0x0]
80006528:	10 37       	cp.w	r7,r8
8000652a:	e0 8b 00 11 	brhi	8000654c <vTaskDelayUntil+0x5c>
8000652e:	c1 18       	rjmp	80006550 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006530:	48 c8       	lddpc	r8,80006560 <vTaskDelayUntil+0x70>
80006532:	70 0c       	ld.w	r12,r8[0x0]
80006534:	2f cc       	sub	r12,-4
80006536:	f0 1f 00 0c 	mcall	80006564 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000653a:	0e 9c       	mov	r12,r7
8000653c:	f0 1f 00 0b 	mcall	80006568 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006540:	f0 1f 00 0b 	mcall	8000656c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006544:	c0 81       	brne	80006554 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006546:	d7 33       	scall
80006548:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000654c:	8d 07       	st.w	r6[0x0],r7
8000654e:	cf 1b       	rjmp	80006530 <vTaskDelayUntil+0x40>
80006550:	8d 07       	st.w	r6[0x0],r7
80006552:	cf 7b       	rjmp	80006540 <vTaskDelayUntil+0x50>
80006554:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	5f a8       	srle	r8
8000655c:	00 00       	add	r0,r0
8000655e:	0d 00       	ld.w	r0,r6++
80006560:	00 00       	add	r0,r0
80006562:	0c d4       	st.w	--r6,r4
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	57 ba       	stdsp	sp[0x1ec],r10
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	64 4c       	ld.w	r12,r2[0x10]
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	63 64       	ld.w	r4,r1[0x58]

80006570 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006570:	eb cd 40 c0 	pushm	r6-r7,lr
80006574:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006576:	48 e7       	lddpc	r7,800065ac <vTaskPlaceOnEventList+0x3c>
80006578:	6e 0b       	ld.w	r11,r7[0x0]
8000657a:	2e 8b       	sub	r11,-24
8000657c:	f0 1f 00 0d 	mcall	800065b0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006580:	6e 0c       	ld.w	r12,r7[0x0]
80006582:	2f cc       	sub	r12,-4
80006584:	f0 1f 00 0c 	mcall	800065b4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006588:	5b f6       	cp.w	r6,-1
8000658a:	c0 81       	brne	8000659a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000658c:	6e 0b       	ld.w	r11,r7[0x0]
8000658e:	2f cb       	sub	r11,-4
80006590:	48 ac       	lddpc	r12,800065b8 <vTaskPlaceOnEventList+0x48>
80006592:	f0 1f 00 0b 	mcall	800065bc <vTaskPlaceOnEventList+0x4c>
80006596:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000659a:	48 a8       	lddpc	r8,800065c0 <vTaskPlaceOnEventList+0x50>
8000659c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000659e:	ec 0c 00 0c 	add	r12,r6,r12
800065a2:	f0 1f 00 09 	mcall	800065c4 <vTaskPlaceOnEventList+0x54>
800065a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065aa:	00 00       	add	r0,r0
800065ac:	00 00       	add	r0,r0
800065ae:	0c d4       	st.w	--r6,r4
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	57 86       	stdsp	sp[0x1e0],r6
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	57 ba       	stdsp	sp[0x1ec],r10
800065b8:	00 00       	add	r0,r0
800065ba:	0d 28       	ld.uh	r8,r6++
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	57 6a       	stdsp	sp[0x1d8],r10
800065c0:	00 00       	add	r0,r0
800065c2:	0d 00       	ld.w	r0,r6++
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	64 4c       	ld.w	r12,r2[0x10]

800065c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800065c8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800065cc:	49 67       	lddpc	r7,80006624 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800065ce:	49 74       	lddpc	r4,80006628 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800065d0:	49 73       	lddpc	r3,8000662c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065d2:	49 85       	lddpc	r5,80006630 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800065d4:	6e 08       	ld.w	r8,r7[0x0]
800065d6:	58 08       	cp.w	r8,0
800065d8:	c1 e0       	breq	80006614 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800065da:	f0 1f 00 17 	mcall	80006634 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800065de:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800065e0:	f0 1f 00 16 	mcall	80006638 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800065e4:	58 06       	cp.w	r6,0
800065e6:	c1 70       	breq	80006614 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800065e8:	f0 1f 00 15 	mcall	8000663c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800065ec:	68 38       	ld.w	r8,r4[0xc]
800065ee:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800065f0:	ec cc ff fc 	sub	r12,r6,-4
800065f4:	f0 1f 00 13 	mcall	80006640 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800065f8:	66 08       	ld.w	r8,r3[0x0]
800065fa:	20 18       	sub	r8,1
800065fc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800065fe:	6e 08       	ld.w	r8,r7[0x0]
80006600:	20 18       	sub	r8,1
80006602:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006604:	f0 1f 00 10 	mcall	80006644 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006608:	6c cc       	ld.w	r12,r6[0x30]
8000660a:	f0 1f 00 10 	mcall	80006648 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000660e:	0c 9c       	mov	r12,r6
80006610:	f0 1f 00 0e 	mcall	80006648 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006614:	6a 08       	ld.w	r8,r5[0x0]
80006616:	58 18       	cp.w	r8,1
80006618:	e0 88 00 03 	brls	8000661e <prvIdleTask+0x56>
			{
				taskYIELD();
8000661c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000661e:	f0 1f 00 0c 	mcall	8000664c <prvIdleTask+0x84>
		}
		#endif
	}
80006622:	cd 9b       	rjmp	800065d4 <prvIdleTask+0xc>
80006624:	00 00       	add	r0,r0
80006626:	0c 14       	sub	r4,r6
80006628:	00 00       	add	r0,r0
8000662a:	0c c0       	st.b	r6++,r0
8000662c:	00 00       	add	r0,r0
8000662e:	0d 20       	ld.uh	r0,r6++
80006630:	00 00       	add	r0,r0
80006632:	0c 20       	rsub	r0,r6
80006634:	80 00       	ld.sh	r0,r0[0x0]
80006636:	5f a8       	srle	r8
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	63 64       	ld.w	r4,r1[0x58]
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	58 74       	cp.w	r4,7
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	57 ba       	stdsp	sp[0x1ec],r10
80006644:	80 00       	ld.sh	r0,r0[0x0]
80006646:	59 80       	cp.w	r0,24
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	5a b8       	cp.w	r8,-21
8000664c:	80 00       	ld.sh	r0,r0[0x0]
8000664e:	20 2c       	sub	r12,2

80006650 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006650:	d4 31       	pushm	r0-r7,lr
80006652:	20 1d       	sub	sp,4
80006654:	fa c4 ff d8 	sub	r4,sp,-40
80006658:	50 0c       	stdsp	sp[0x0],r12
8000665a:	16 91       	mov	r1,r11
8000665c:	14 97       	mov	r7,r10
8000665e:	12 90       	mov	r0,r9
80006660:	10 93       	mov	r3,r8
80006662:	68 02       	ld.w	r2,r4[0x0]
80006664:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006666:	34 8c       	mov	r12,72
80006668:	f0 1f 00 5c 	mcall	800067d8 <xTaskGenericCreate+0x188>
8000666c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000666e:	c0 31       	brne	80006674 <xTaskGenericCreate+0x24>
80006670:	3f fc       	mov	r12,-1
80006672:	ca f8       	rjmp	800067d0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006674:	58 06       	cp.w	r6,0
80006676:	e0 81 00 af 	brne	800067d4 <xTaskGenericCreate+0x184>
8000667a:	0e 9c       	mov	r12,r7
8000667c:	5c 7c       	castu.h	r12
8000667e:	a3 6c       	lsl	r12,0x2
80006680:	f0 1f 00 56 	mcall	800067d8 <xTaskGenericCreate+0x188>
80006684:	18 96       	mov	r6,r12
80006686:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006688:	c0 61       	brne	80006694 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000668a:	0a 9c       	mov	r12,r5
8000668c:	f0 1f 00 54 	mcall	800067dc <xTaskGenericCreate+0x18c>
80006690:	3f fc       	mov	r12,-1
80006692:	c9 f8       	rjmp	800067d0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006694:	5c 77       	castu.h	r7
80006696:	ee 0a 15 02 	lsl	r10,r7,0x2
8000669a:	e0 6b 00 a5 	mov	r11,165
8000669e:	0c 9c       	mov	r12,r6
800066a0:	f0 1f 00 50 	mcall	800067e0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800066a4:	ee c6 00 01 	sub	r6,r7,1
800066a8:	6a c8       	ld.w	r8,r5[0x30]
800066aa:	f0 06 00 26 	add	r6,r8,r6<<0x2
800066ae:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800066b2:	31 0a       	mov	r10,16
800066b4:	02 9b       	mov	r11,r1
800066b6:	ea cc ff cc 	sub	r12,r5,-52
800066ba:	f0 1f 00 4b 	mcall	800067e4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800066be:	30 08       	mov	r8,0
800066c0:	eb 68 00 43 	st.b	r5[67],r8
800066c4:	58 73       	cp.w	r3,7
800066c6:	e6 07 17 80 	movls	r7,r3
800066ca:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800066ce:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800066d0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800066d4:	ea c4 ff fc 	sub	r4,r5,-4
800066d8:	08 9c       	mov	r12,r4
800066da:	f0 1f 00 44 	mcall	800067e8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800066de:	ea cc ff e8 	sub	r12,r5,-24
800066e2:	f0 1f 00 42 	mcall	800067e8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800066e6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800066e8:	ee 07 11 08 	rsub	r7,r7,8
800066ec:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800066ee:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800066f0:	00 9a       	mov	r10,r0
800066f2:	40 0b       	lddsp	r11,sp[0x0]
800066f4:	0c 9c       	mov	r12,r6
800066f6:	f0 1f 00 3e 	mcall	800067ec <xTaskGenericCreate+0x19c>
800066fa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800066fc:	58 02       	cp.w	r2,0
800066fe:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006702:	f0 1f 00 3c 	mcall	800067f0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006706:	4b c8       	lddpc	r8,800067f4 <xTaskGenericCreate+0x1a4>
80006708:	70 09       	ld.w	r9,r8[0x0]
8000670a:	2f f9       	sub	r9,-1
8000670c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000670e:	4b b8       	lddpc	r8,800067f8 <xTaskGenericCreate+0x1a8>
80006710:	70 08       	ld.w	r8,r8[0x0]
80006712:	58 08       	cp.w	r8,0
80006714:	c2 61       	brne	80006760 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006716:	4b 98       	lddpc	r8,800067f8 <xTaskGenericCreate+0x1a8>
80006718:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000671a:	4b 78       	lddpc	r8,800067f4 <xTaskGenericCreate+0x1a4>
8000671c:	70 08       	ld.w	r8,r8[0x0]
8000671e:	58 18       	cp.w	r8,1
80006720:	c2 b1       	brne	80006776 <xTaskGenericCreate+0x126>
80006722:	4b 77       	lddpc	r7,800067fc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006724:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006728:	0e 9c       	mov	r12,r7
8000672a:	f0 1f 00 36 	mcall	80006800 <xTaskGenericCreate+0x1b0>
8000672e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006730:	0c 37       	cp.w	r7,r6
80006732:	cf b1       	brne	80006728 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006734:	4b 47       	lddpc	r7,80006804 <xTaskGenericCreate+0x1b4>
80006736:	0e 9c       	mov	r12,r7
80006738:	f0 1f 00 32 	mcall	80006800 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000673c:	4b 36       	lddpc	r6,80006808 <xTaskGenericCreate+0x1b8>
8000673e:	0c 9c       	mov	r12,r6
80006740:	f0 1f 00 30 	mcall	80006800 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006744:	4b 2c       	lddpc	r12,8000680c <xTaskGenericCreate+0x1bc>
80006746:	f0 1f 00 2f 	mcall	80006800 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000674a:	4b 2c       	lddpc	r12,80006810 <xTaskGenericCreate+0x1c0>
8000674c:	f0 1f 00 2d 	mcall	80006800 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006750:	4b 1c       	lddpc	r12,80006814 <xTaskGenericCreate+0x1c4>
80006752:	f0 1f 00 2c 	mcall	80006800 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006756:	4b 18       	lddpc	r8,80006818 <xTaskGenericCreate+0x1c8>
80006758:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000675a:	4b 18       	lddpc	r8,8000681c <xTaskGenericCreate+0x1cc>
8000675c:	91 06       	st.w	r8[0x0],r6
8000675e:	c0 c8       	rjmp	80006776 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006760:	4b 08       	lddpc	r8,80006820 <xTaskGenericCreate+0x1d0>
80006762:	70 08       	ld.w	r8,r8[0x0]
80006764:	58 08       	cp.w	r8,0
80006766:	c0 81       	brne	80006776 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006768:	4a 48       	lddpc	r8,800067f8 <xTaskGenericCreate+0x1a8>
8000676a:	70 08       	ld.w	r8,r8[0x0]
8000676c:	70 b8       	ld.w	r8,r8[0x2c]
8000676e:	10 33       	cp.w	r3,r8
80006770:	c0 33       	brcs	80006776 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006772:	4a 28       	lddpc	r8,800067f8 <xTaskGenericCreate+0x1a8>
80006774:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006776:	6a b8       	ld.w	r8,r5[0x2c]
80006778:	4a b9       	lddpc	r9,80006824 <xTaskGenericCreate+0x1d4>
8000677a:	72 09       	ld.w	r9,r9[0x0]
8000677c:	12 38       	cp.w	r8,r9
8000677e:	e0 88 00 04 	brls	80006786 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006782:	4a 99       	lddpc	r9,80006824 <xTaskGenericCreate+0x1d4>
80006784:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006786:	4a 98       	lddpc	r8,80006828 <xTaskGenericCreate+0x1d8>
80006788:	70 09       	ld.w	r9,r8[0x0]
8000678a:	2f f9       	sub	r9,-1
8000678c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000678e:	6a b8       	ld.w	r8,r5[0x2c]
80006790:	4a 79       	lddpc	r9,8000682c <xTaskGenericCreate+0x1dc>
80006792:	72 09       	ld.w	r9,r9[0x0]
80006794:	12 38       	cp.w	r8,r9
80006796:	e0 88 00 04 	brls	8000679e <xTaskGenericCreate+0x14e>
8000679a:	4a 59       	lddpc	r9,8000682c <xTaskGenericCreate+0x1dc>
8000679c:	93 08       	st.w	r9[0x0],r8
8000679e:	6a bc       	ld.w	r12,r5[0x2c]
800067a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067a4:	08 9b       	mov	r11,r4
800067a6:	49 68       	lddpc	r8,800067fc <xTaskGenericCreate+0x1ac>
800067a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067ac:	f0 1f 00 21 	mcall	80006830 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800067b0:	f0 1f 00 21 	mcall	80006834 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800067b4:	49 b8       	lddpc	r8,80006820 <xTaskGenericCreate+0x1d0>
800067b6:	70 08       	ld.w	r8,r8[0x0]
800067b8:	58 08       	cp.w	r8,0
800067ba:	c0 a0       	breq	800067ce <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800067bc:	48 f8       	lddpc	r8,800067f8 <xTaskGenericCreate+0x1a8>
800067be:	70 08       	ld.w	r8,r8[0x0]
800067c0:	70 b8       	ld.w	r8,r8[0x2c]
800067c2:	10 33       	cp.w	r3,r8
800067c4:	e0 88 00 05 	brls	800067ce <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800067c8:	d7 33       	scall
800067ca:	30 1c       	mov	r12,1
800067cc:	c0 28       	rjmp	800067d0 <xTaskGenericCreate+0x180>
800067ce:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800067d0:	2f fd       	sub	sp,-4
800067d2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800067d4:	99 c6       	st.w	r12[0x30],r6
800067d6:	c5 fb       	rjmp	80006694 <xTaskGenericCreate+0x44>
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	5a e0       	cp.w	r0,-18
800067dc:	80 00       	ld.sh	r0,r0[0x0]
800067de:	5a b8       	cp.w	r8,-21
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	73 d4       	ld.w	r4,r9[0x74]
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	77 00       	ld.w	r0,r11[0x40]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	57 64       	stdsp	sp[0x1d8],r4
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	57 e0       	stdsp	sp[0x1f8],r0
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	58 74       	cp.w	r4,7
800067f4:	00 00       	add	r0,r0
800067f6:	0d 20       	ld.uh	r0,r6++
800067f8:	00 00       	add	r0,r0
800067fa:	0c d4       	st.w	--r6,r4
800067fc:	00 00       	add	r0,r0
800067fe:	0c 20       	rsub	r0,r6
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	57 50       	stdsp	sp[0x1d4],r0
80006804:	00 00       	add	r0,r0
80006806:	0c ec       	st.h	--r6,r12
80006808:	00 00       	add	r0,r0
8000680a:	0d 08       	ld.w	r8,r6++
8000680c:	00 00       	add	r0,r0
8000680e:	0c d8       	st.w	--r6,r8
80006810:	00 00       	add	r0,r0
80006812:	0c c0       	st.b	r6++,r0
80006814:	00 00       	add	r0,r0
80006816:	0d 28       	ld.uh	r8,r6++
80006818:	00 00       	add	r0,r0
8000681a:	0c 0c       	add	r12,r6
8000681c:	00 00       	add	r0,r0
8000681e:	0c 1c       	sub	r12,r6
80006820:	00 00       	add	r0,r0
80006822:	0c 10       	sub	r0,r6
80006824:	00 00       	add	r0,r0
80006826:	0c 08       	add	r8,r6
80006828:	00 00       	add	r0,r0
8000682a:	0d 1c       	ld.sh	r12,r6++
8000682c:	00 00       	add	r0,r0
8000682e:	0d 3c       	ld.ub	r12,r6++
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	57 6a       	stdsp	sp[0x1d8],r10
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	59 80       	cp.w	r0,24

80006838 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006838:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000683a:	30 09       	mov	r9,0
8000683c:	1a d9       	st.w	--sp,r9
8000683e:	1a d9       	st.w	--sp,r9
80006840:	1a d9       	st.w	--sp,r9
80006842:	12 98       	mov	r8,r9
80006844:	e0 6a 01 00 	mov	r10,256
80006848:	48 9b       	lddpc	r11,8000686c <vTaskStartScheduler+0x34>
8000684a:	48 ac       	lddpc	r12,80006870 <vTaskStartScheduler+0x38>
8000684c:	f0 1f 00 0a 	mcall	80006874 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006850:	2f dd       	sub	sp,-12
80006852:	58 1c       	cp.w	r12,1
80006854:	c0 a1       	brne	80006868 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006856:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006858:	30 19       	mov	r9,1
8000685a:	48 88       	lddpc	r8,80006878 <vTaskStartScheduler+0x40>
8000685c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000685e:	30 09       	mov	r9,0
80006860:	48 78       	lddpc	r8,8000687c <vTaskStartScheduler+0x44>
80006862:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006864:	f0 1f 00 07 	mcall	80006880 <vTaskStartScheduler+0x48>
80006868:	d8 02       	popm	pc
8000686a:	00 00       	add	r0,r0
8000686c:	80 00       	ld.sh	r0,r0[0x0]
8000686e:	d2 bc       	*unknown*
80006870:	80 00       	ld.sh	r0,r0[0x0]
80006872:	65 c8       	ld.w	r8,r2[0x70]
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	66 50       	ld.w	r0,r3[0x14]
80006878:	00 00       	add	r0,r0
8000687a:	0c 10       	sub	r0,r6
8000687c:	00 00       	add	r0,r0
8000687e:	0d 00       	ld.w	r0,r6++
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	58 84       	cp.w	r4,8

80006884 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006884:	16 cc       	st.b	r11++,r12
	return str;
}
80006886:	5e fb       	retal	r11

80006888 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006888:	eb cd 40 c0 	pushm	r6-r7,lr
8000688c:	20 3d       	sub	sp,12
8000688e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006890:	30 06       	mov	r6,0
80006892:	30 07       	mov	r7,0
80006894:	fa e7 00 00 	st.d	sp[0],r6
80006898:	30 0c       	mov	r12,0
8000689a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000689c:	58 08       	cp.w	r8,0
8000689e:	c1 30       	breq	800068c4 <PrintHex+0x3c>
800068a0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800068a2:	1a 9c       	mov	r12,sp
800068a4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068a8:	58 9e       	cp.w	lr,9
800068aa:	e0 8a 00 04 	brle	800068b2 <PrintHex+0x2a>
800068ae:	2c 9e       	sub	lr,-55
800068b0:	c0 48       	rjmp	800068b8 <PrintHex+0x30>
800068b2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068b6:	2d 0e       	sub	lr,-48
800068b8:	f8 09 0b 0e 	st.b	r12[r9],lr
800068bc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800068be:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800068c0:	cf 21       	brne	800068a4 <PrintHex+0x1c>
800068c2:	c0 48       	rjmp	800068ca <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800068c4:	33 08       	mov	r8,48
800068c6:	ba 88       	st.b	sp[0x0],r8
800068c8:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800068ca:	f6 09 01 08 	sub	r8,r11,r9
800068ce:	58 08       	cp.w	r8,0
800068d0:	e0 8a 00 13 	brle	800068f6 <PrintHex+0x6e>
	{
		char num = len - cnt;
800068d4:	12 1b       	sub	r11,r9
800068d6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800068da:	18 9e       	mov	lr,r12
800068dc:	58 0c       	cp.w	r12,0
800068de:	e0 8a 00 0c 	brle	800068f6 <PrintHex+0x6e>
800068e2:	1a 9b       	mov	r11,sp
800068e4:	12 0b       	add	r11,r9
800068e6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800068e8:	33 07       	mov	r7,48
800068ea:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800068ec:	2f f8       	sub	r8,-1
800068ee:	1c 38       	cp.w	r8,lr
800068f0:	cf d5       	brlt	800068ea <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068f2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068f6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800068fa:	f0 cb ff ff 	sub	r11,r8,-1
800068fe:	58 0b       	cp.w	r11,0
80006900:	e0 8a 00 19 	brle	80006932 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006904:	fa cb ff f4 	sub	r11,sp,-12
80006908:	f6 09 00 09 	add	r9,r11,r9
8000690c:	37 8b       	mov	r11,120
8000690e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006912:	fa c9 ff f4 	sub	r9,sp,-12
80006916:	10 09       	add	r9,r8
80006918:	33 0b       	mov	r11,48
8000691a:	f3 6b ff f4 	st.b	r9[-12],r11
8000691e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006922:	fa ce 00 01 	sub	lr,sp,1
80006926:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006928:	11 8b       	ld.ub	r11,r8[0x0]
8000692a:	12 cb       	st.b	r9++,r11
8000692c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000692e:	1c 38       	cp.w	r8,lr
80006930:	cf c1       	brne	80006928 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006932:	14 9c       	mov	r12,r10
80006934:	2f dd       	sub	sp,-12
80006936:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000693a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000693a:	d4 21       	pushm	r4-r7,lr
8000693c:	20 3d       	sub	sp,12
8000693e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006940:	30 06       	mov	r6,0
80006942:	30 07       	mov	r7,0
80006944:	fa e7 00 00 	st.d	sp[0],r6
80006948:	30 0c       	mov	r12,0
8000694a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000694c:	58 08       	cp.w	r8,0
8000694e:	c0 35       	brlt	80006954 <PrintDec+0x1a>
80006950:	14 97       	mov	r7,r10
80006952:	c0 58       	rjmp	8000695c <PrintDec+0x22>
	{
		*p++ = '-';
80006954:	14 97       	mov	r7,r10
80006956:	32 d9       	mov	r9,45
80006958:	0e c9       	st.b	r7++,r9
		i = -i;
8000695a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000695c:	58 08       	cp.w	r8,0
8000695e:	c0 51       	brne	80006968 <PrintDec+0x2e>
80006960:	33 08       	mov	r8,48
80006962:	ba 88       	st.b	sp[0x0],r8
80006964:	30 1e       	mov	lr,1
80006966:	c2 f8       	rjmp	800069c4 <PrintDec+0x8a>
	
	int ten = i%10;
80006968:	e0 65 66 67 	mov	r5,26215
8000696c:	ea 15 66 66 	orh	r5,0x6666
80006970:	f0 05 04 44 	muls.d	r4,r8,r5
80006974:	ea 0c 14 02 	asr	r12,r5,0x2
80006978:	f0 09 14 1f 	asr	r9,r8,0x1f
8000697c:	f8 09 01 09 	sub	r9,r12,r9
80006980:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006984:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006988:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000698a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000698c:	e0 66 66 67 	mov	r6,26215
80006990:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006994:	2d 09       	sub	r9,-48
80006996:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000699a:	2f fe       	sub	lr,-1
		i /= 10;
8000699c:	f0 06 04 44 	muls.d	r4,r8,r6
800069a0:	ea 09 14 02 	asr	r9,r5,0x2
800069a4:	bf 58       	asr	r8,0x1f
800069a6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800069aa:	f0 06 04 44 	muls.d	r4,r8,r6
800069ae:	ea 09 14 02 	asr	r9,r5,0x2
800069b2:	f0 05 14 1f 	asr	r5,r8,0x1f
800069b6:	0a 19       	sub	r9,r5
800069b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800069bc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800069c0:	58 08       	cp.w	r8,0
800069c2:	ce 91       	brne	80006994 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800069c4:	f6 0e 01 08 	sub	r8,r11,lr
800069c8:	58 08       	cp.w	r8,0
800069ca:	e0 89 00 06 	brgt	800069d6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800069ce:	58 0e       	cp.w	lr,0
800069d0:	e0 89 00 14 	brgt	800069f8 <PrintDec+0xbe>
800069d4:	c1 d8       	rjmp	80006a0e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800069d6:	1c 1b       	sub	r11,lr
800069d8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800069da:	16 9c       	mov	r12,r11
800069dc:	58 0b       	cp.w	r11,0
800069de:	fe 9a ff f8 	brle	800069ce <PrintDec+0x94>
800069e2:	1a 99       	mov	r9,sp
800069e4:	1c 09       	add	r9,lr
800069e6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800069e8:	33 06       	mov	r6,48
800069ea:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800069ec:	2f f8       	sub	r8,-1
800069ee:	18 38       	cp.w	r8,r12
800069f0:	cf d5       	brlt	800069ea <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800069f2:	f6 0e 00 0e 	add	lr,r11,lr
800069f6:	ce cb       	rjmp	800069ce <PrintDec+0x94>
800069f8:	fa c8 ff f4 	sub	r8,sp,-12
800069fc:	1c 08       	add	r8,lr
800069fe:	20 d8       	sub	r8,13
80006a00:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006a04:	11 89       	ld.ub	r9,r8[0x0]
80006a06:	0e c9       	st.b	r7++,r9
80006a08:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006a0a:	16 38       	cp.w	r8,r11
80006a0c:	cf c1       	brne	80006a04 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006a0e:	14 9c       	mov	r12,r10
80006a10:	2f dd       	sub	sp,-12
80006a12:	d8 22       	popm	r4-r7,pc

80006a14 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006a14:	d4 31       	pushm	r0-r7,lr
80006a16:	fa cd 02 08 	sub	sp,sp,520
80006a1a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006a1c:	e0 6a 01 00 	mov	r10,256
80006a20:	30 0b       	mov	r11,0
80006a22:	fa cc fe f8 	sub	r12,sp,-264
80006a26:	f0 1f 00 4e 	mcall	80006b5c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006a2a:	fa c4 fd d4 	sub	r4,sp,-556
80006a2e:	30 0a       	mov	r10,0
80006a30:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a32:	fa c3 ff fc 	sub	r3,sp,-4
80006a36:	e0 61 01 00 	mov	r1,256
80006a3a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006a3c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a3e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a42:	02 9a       	mov	r10,r1
80006a44:	00 9b       	mov	r11,r0
80006a46:	06 9c       	mov	r12,r3
80006a48:	f0 1f 00 45 	mcall	80006b5c <log+0x148>
			
					if(*str == '%')
80006a4c:	0f 88       	ld.ub	r8,r7[0x0]
80006a4e:	e4 08 18 00 	cp.b	r8,r2
80006a52:	c5 71       	brne	80006b00 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006a54:	ee c8 ff ff 	sub	r8,r7,-1
80006a58:	11 89       	ld.ub	r9,r8[0x0]
80006a5a:	4c 2a       	lddpc	r10,80006b60 <log+0x14c>
80006a5c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006a5e:	23 09       	sub	r9,48
80006a60:	30 9a       	mov	r10,9
80006a62:	f4 09 18 00 	cp.b	r9,r10
80006a66:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006a6a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006a6e:	f7 b9 08 30 	subls	r9,48
80006a72:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a76:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a7a:	0f 88       	ld.ub	r8,r7[0x0]
80006a7c:	22 58       	sub	r8,37
80006a7e:	e0 48 00 53 	cp.w	r8,83
80006a82:	e0 8b 00 31 	brhi	80006ae4 <log+0xd0>
80006a86:	4b 89       	lddpc	r9,80006b64 <log+0x150>
80006a88:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006a8c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006a90:	06 9a       	mov	r10,r3
80006a92:	40 0b       	lddsp	r11,sp[0x0]
80006a94:	5c 5b       	castu.b	r11
80006a96:	68 0c       	ld.w	r12,r4[0x0]
80006a98:	f0 1f 00 34 	mcall	80006b68 <log+0x154>
							break;
80006a9c:	c2 98       	rjmp	80006aee <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006a9e:	4b 4c       	lddpc	r12,80006b6c <log+0x158>
80006aa0:	f0 1f 00 34 	mcall	80006b70 <log+0x15c>
80006aa4:	08 95       	mov	r5,r4
80006aa6:	06 9c       	mov	r12,r3
							break;
80006aa8:	c2 38       	rjmp	80006aee <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006aaa:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006aae:	06 9a       	mov	r10,r3
80006ab0:	40 0b       	lddsp	r11,sp[0x0]
80006ab2:	5c 5b       	castu.b	r11
80006ab4:	68 0c       	ld.w	r12,r4[0x0]
80006ab6:	f0 1f 00 30 	mcall	80006b74 <log+0x160>
80006aba:	06 9c       	mov	r12,r3
							break;
80006abc:	c1 98       	rjmp	80006aee <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006abe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006ac2:	06 9b       	mov	r11,r3
80006ac4:	09 bc       	ld.ub	r12,r4[0x3]
80006ac6:	f0 1f 00 2d 	mcall	80006b78 <log+0x164>
80006aca:	06 9c       	mov	r12,r3
							break;
80006acc:	c1 18       	rjmp	80006aee <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006ace:	e8 c5 ff fc 	sub	r5,r4,-4
80006ad2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006ad4:	c0 d8       	rjmp	80006aee <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006ad6:	06 9b       	mov	r11,r3
80006ad8:	32 5c       	mov	r12,37
80006ada:	f0 1f 00 28 	mcall	80006b78 <log+0x164>
80006ade:	08 95       	mov	r5,r4
80006ae0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006ae2:	c0 68       	rjmp	80006aee <log+0xda>
							
							default:
							log("I need relax.");
80006ae4:	4a 6c       	lddpc	r12,80006b7c <log+0x168>
80006ae6:	f0 1f 00 23 	mcall	80006b70 <log+0x15c>
80006aea:	08 95       	mov	r5,r4
80006aec:	06 9c       	mov	r12,r3
						}
						str++;
80006aee:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006af0:	1a dc       	st.w	--sp,r12
80006af2:	1a d6       	st.w	--sp,r6
80006af4:	4a 3b       	lddpc	r11,80006b80 <log+0x16c>
80006af6:	0c 9c       	mov	r12,r6
80006af8:	f0 1f 00 23 	mcall	80006b84 <log+0x170>
80006afc:	2f ed       	sub	sp,-8
80006afe:	c0 a8       	rjmp	80006b12 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b00:	2f f7       	sub	r7,-1
80006b02:	1a d8       	st.w	--sp,r8
80006b04:	1a d6       	st.w	--sp,r6
80006b06:	4a 1b       	lddpc	r11,80006b88 <log+0x174>
80006b08:	0c 9c       	mov	r12,r6
80006b0a:	f0 1f 00 1f 	mcall	80006b84 <log+0x170>
80006b0e:	08 95       	mov	r5,r4
80006b10:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006b12:	0f 89       	ld.ub	r9,r7[0x0]
80006b14:	30 08       	mov	r8,0
80006b16:	f0 09 18 00 	cp.b	r9,r8
80006b1a:	c0 30       	breq	80006b20 <log+0x10c>
80006b1c:	0a 94       	mov	r4,r5
80006b1e:	c9 2b       	rjmp	80006a42 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006b20:	fa c7 fe f8 	sub	r7,sp,-264
80006b24:	1a d7       	st.w	--sp,r7
80006b26:	49 ab       	lddpc	r11,80006b8c <log+0x178>
80006b28:	0e 9c       	mov	r12,r7
80006b2a:	f0 1f 00 17 	mcall	80006b84 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006b2e:	5c 5c       	castu.b	r12
80006b30:	f8 c6 ff ff 	sub	r6,r12,-1
80006b34:	0c 9c       	mov	r12,r6
80006b36:	f0 1f 00 17 	mcall	80006b90 <log+0x17c>
80006b3a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006b3c:	0c 9a       	mov	r10,r6
80006b3e:	0e 9b       	mov	r11,r7
80006b40:	f0 1f 00 15 	mcall	80006b94 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006b44:	30 09       	mov	r9,0
80006b46:	30 5a       	mov	r10,5
80006b48:	fa cb fe f8 	sub	r11,sp,-264
80006b4c:	49 38       	lddpc	r8,80006b98 <log+0x184>
80006b4e:	70 0c       	ld.w	r12,r8[0x0]
80006b50:	f0 1f 00 13 	mcall	80006b9c <log+0x188>
80006b54:	2f fd       	sub	sp,-4
	
	
}
80006b56:	fe 3d fd f8 	sub	sp,-520
80006b5a:	d8 32       	popm	r0-r7,pc
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	73 d4       	ld.w	r4,r9[0x74]
80006b60:	00 00       	add	r0,r0
80006b62:	0d 40       	ld.w	r0,--r6
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	d2 c4       	*unknown*
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	69 3a       	ld.w	r10,r4[0x4c]
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	d5 70       	acall	0x57
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	6a 14       	ld.w	r4,r5[0x4]
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	68 88       	ld.w	r8,r4[0x20]
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	68 84       	ld.w	r4,r4[0x20]
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	d5 80       	acall	0x58
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	d5 90       	acall	0x59
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	76 c4       	ld.w	r4,r11[0x30]
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	d5 98       	*unknown*
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	d5 a0       	acall	0x5a
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	5a e0       	cp.w	r0,-18
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	72 8c       	ld.w	r12,r9[0x20]
80006b98:	00 00       	add	r0,r0
80006b9a:	51 18       	stdsp	sp[0x44],r8
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	5e 34       	retlo	r4

80006ba0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006ba0:	d4 31       	pushm	r0-r7,lr
80006ba2:	fa cd 02 0c 	sub	sp,sp,524
80006ba6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006ba8:	e0 6a 01 00 	mov	r10,256
80006bac:	30 0b       	mov	r11,0
80006bae:	fa cc fe f4 	sub	r12,sp,-268
80006bb2:	f0 1f 00 4c 	mcall	80006ce0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006bb6:	fa c4 fd d0 	sub	r4,sp,-560
80006bba:	30 0a       	mov	r10,0
80006bbc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006bbe:	fa c3 ff fc 	sub	r3,sp,-4
80006bc2:	e0 61 01 00 	mov	r1,256
80006bc6:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006bc8:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006bca:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006bce:	02 9a       	mov	r10,r1
80006bd0:	00 9b       	mov	r11,r0
80006bd2:	06 9c       	mov	r12,r3
80006bd4:	f0 1f 00 43 	mcall	80006ce0 <logFromISR+0x140>
			
			if(*str == '%')
80006bd8:	0f 88       	ld.ub	r8,r7[0x0]
80006bda:	e4 08 18 00 	cp.b	r8,r2
80006bde:	c5 11       	brne	80006c80 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006be0:	ee c8 ff ff 	sub	r8,r7,-1
80006be4:	11 89       	ld.ub	r9,r8[0x0]
80006be6:	4c 0a       	lddpc	r10,80006ce4 <logFromISR+0x144>
80006be8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006bea:	23 09       	sub	r9,48
80006bec:	30 9a       	mov	r10,9
80006bee:	f4 09 18 00 	cp.b	r9,r10
80006bf2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006bf6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006bfa:	f7 b9 08 30 	subls	r9,48
80006bfe:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006c02:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006c06:	0f 88       	ld.ub	r8,r7[0x0]
80006c08:	22 58       	sub	r8,37
80006c0a:	e0 48 00 53 	cp.w	r8,83
80006c0e:	e0 8b 00 2b 	brhi	80006c64 <logFromISR+0xc4>
80006c12:	4b 69       	lddpc	r9,80006ce8 <logFromISR+0x148>
80006c14:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006c18:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006c1c:	06 9a       	mov	r10,r3
80006c1e:	40 0b       	lddsp	r11,sp[0x0]
80006c20:	5c 5b       	castu.b	r11
80006c22:	68 0c       	ld.w	r12,r4[0x0]
80006c24:	f0 1f 00 32 	mcall	80006cec <logFromISR+0x14c>
					break;
80006c28:	c2 38       	rjmp	80006c6e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006c2a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006c2e:	06 9a       	mov	r10,r3
80006c30:	40 0b       	lddsp	r11,sp[0x0]
80006c32:	5c 5b       	castu.b	r11
80006c34:	68 0c       	ld.w	r12,r4[0x0]
80006c36:	f0 1f 00 2f 	mcall	80006cf0 <logFromISR+0x150>
80006c3a:	06 9c       	mov	r12,r3
					break;
80006c3c:	c1 98       	rjmp	80006c6e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006c3e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006c42:	06 9b       	mov	r11,r3
80006c44:	09 bc       	ld.ub	r12,r4[0x3]
80006c46:	f0 1f 00 2c 	mcall	80006cf4 <logFromISR+0x154>
80006c4a:	06 9c       	mov	r12,r3
					break;
80006c4c:	c1 18       	rjmp	80006c6e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006c4e:	e8 c5 ff fc 	sub	r5,r4,-4
80006c52:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006c54:	c0 d8       	rjmp	80006c6e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006c56:	06 9b       	mov	r11,r3
80006c58:	32 5c       	mov	r12,37
80006c5a:	f0 1f 00 27 	mcall	80006cf4 <logFromISR+0x154>
80006c5e:	08 95       	mov	r5,r4
80006c60:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006c62:	c0 68       	rjmp	80006c6e <logFromISR+0xce>
					default:
					log("I need relax.");
80006c64:	4a 5c       	lddpc	r12,80006cf8 <logFromISR+0x158>
80006c66:	f0 1f 00 26 	mcall	80006cfc <logFromISR+0x15c>
80006c6a:	08 95       	mov	r5,r4
80006c6c:	06 9c       	mov	r12,r3
				}
				str++;
80006c6e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006c70:	1a dc       	st.w	--sp,r12
80006c72:	1a d6       	st.w	--sp,r6
80006c74:	4a 3b       	lddpc	r11,80006d00 <logFromISR+0x160>
80006c76:	0c 9c       	mov	r12,r6
80006c78:	f0 1f 00 23 	mcall	80006d04 <logFromISR+0x164>
80006c7c:	2f ed       	sub	sp,-8
80006c7e:	c0 a8       	rjmp	80006c92 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c80:	2f f7       	sub	r7,-1
80006c82:	1a d8       	st.w	--sp,r8
80006c84:	1a d6       	st.w	--sp,r6
80006c86:	4a 1b       	lddpc	r11,80006d08 <logFromISR+0x168>
80006c88:	0c 9c       	mov	r12,r6
80006c8a:	f0 1f 00 1f 	mcall	80006d04 <logFromISR+0x164>
80006c8e:	08 95       	mov	r5,r4
80006c90:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006c92:	0f 89       	ld.ub	r9,r7[0x0]
80006c94:	30 08       	mov	r8,0
80006c96:	f0 09 18 00 	cp.b	r9,r8
80006c9a:	c0 30       	breq	80006ca0 <logFromISR+0x100>
80006c9c:	0a 94       	mov	r4,r5
80006c9e:	c9 8b       	rjmp	80006bce <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006ca0:	fa c7 fe f4 	sub	r7,sp,-268
80006ca4:	1a d7       	st.w	--sp,r7
80006ca6:	49 ab       	lddpc	r11,80006d0c <logFromISR+0x16c>
80006ca8:	0e 9c       	mov	r12,r7
80006caa:	f0 1f 00 17 	mcall	80006d04 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006cae:	5c 5c       	castu.b	r12
80006cb0:	f8 c6 ff ff 	sub	r6,r12,-1
80006cb4:	0c 9c       	mov	r12,r6
80006cb6:	f0 1f 00 17 	mcall	80006d10 <logFromISR+0x170>
80006cba:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006cbc:	0c 9a       	mov	r10,r6
80006cbe:	0e 9b       	mov	r11,r7
80006cc0:	f0 1f 00 15 	mcall	80006d14 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006cc4:	30 09       	mov	r9,0
80006cc6:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006cc8:	fa ca fe f8 	sub	r10,sp,-264
80006ccc:	fa cb fe f4 	sub	r11,sp,-268
80006cd0:	49 28       	lddpc	r8,80006d18 <logFromISR+0x178>
80006cd2:	70 0c       	ld.w	r12,r8[0x0]
80006cd4:	f0 1f 00 12 	mcall	80006d1c <logFromISR+0x17c>
80006cd8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006cda:	fe 3d fd f4 	sub	sp,-524
80006cde:	d8 32       	popm	r0-r7,pc
80006ce0:	80 00       	ld.sh	r0,r0[0x0]
80006ce2:	73 d4       	ld.w	r4,r9[0x74]
80006ce4:	00 00       	add	r0,r0
80006ce6:	0d 41       	ld.w	r1,--r6
80006ce8:	80 00       	ld.sh	r0,r0[0x0]
80006cea:	d4 14       	*unknown*
80006cec:	80 00       	ld.sh	r0,r0[0x0]
80006cee:	69 3a       	ld.w	r10,r4[0x4c]
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	68 88       	ld.w	r8,r4[0x20]
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	68 84       	ld.w	r4,r4[0x20]
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	d5 80       	acall	0x58
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	6a 14       	ld.w	r4,r5[0x4]
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	d5 90       	acall	0x59
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	76 c4       	ld.w	r4,r11[0x30]
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	d5 98       	*unknown*
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	d5 a0       	acall	0x5a
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	5a e0       	cp.w	r0,-18
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	72 8c       	ld.w	r12,r9[0x20]
80006d18:	00 00       	add	r0,r0
80006d1a:	51 18       	stdsp	sp[0x44],r8
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	5d e4       	*unknown*

80006d20 <log_init>:
		
	return str;
}

void log_init(void)
{
80006d20:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006d22:	30 2b       	mov	r11,2
80006d24:	49 0c       	lddpc	r12,80006d64 <log_init+0x44>
80006d26:	f0 1f 00 11 	mcall	80006d68 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006d2a:	e0 6a 36 00 	mov	r10,13824
80006d2e:	ea 1a 01 6e 	orh	r10,0x16e
80006d32:	48 fb       	lddpc	r11,80006d6c <log_init+0x4c>
80006d34:	fe 7c 18 00 	mov	r12,-59392
80006d38:	f0 1f 00 0e 	mcall	80006d70 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006d3c:	30 4b       	mov	r11,4
80006d3e:	33 2c       	mov	r12,50
80006d40:	f0 1f 00 0d 	mcall	80006d74 <log_init+0x54>
80006d44:	48 d8       	lddpc	r8,80006d78 <log_init+0x58>
80006d46:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006d48:	30 09       	mov	r9,0
80006d4a:	1a d9       	st.w	--sp,r9
80006d4c:	1a d9       	st.w	--sp,r9
80006d4e:	1a d9       	st.w	--sp,r9
80006d50:	30 28       	mov	r8,2
80006d52:	e0 6a 01 80 	mov	r10,384
80006d56:	48 ab       	lddpc	r11,80006d7c <log_init+0x5c>
80006d58:	48 ac       	lddpc	r12,80006d80 <log_init+0x60>
80006d5a:	f0 1f 00 0b 	mcall	80006d84 <log_init+0x64>
80006d5e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006d60:	d8 02       	popm	pc
80006d62:	00 00       	add	r0,r0
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	d5 ac       	*unknown*
80006d68:	80 00       	ld.sh	r0,r0[0x0]
80006d6a:	51 10       	stdsp	sp[0x44],r0
80006d6c:	80 00       	ld.sh	r0,r0[0x0]
80006d6e:	d5 64       	*unknown*
80006d70:	80 00       	ld.sh	r0,r0[0x0]
80006d72:	56 44       	stdsp	sp[0x190],r4
80006d74:	80 00       	ld.sh	r0,r0[0x0]
80006d76:	5f 34       	srlo	r4
80006d78:	00 00       	add	r0,r0
80006d7a:	51 18       	stdsp	sp[0x44],r8
80006d7c:	80 00       	ld.sh	r0,r0[0x0]
80006d7e:	d5 a8       	*unknown*
80006d80:	80 00       	ld.sh	r0,r0[0x0]
80006d82:	6d 88       	ld.w	r8,r6[0x60]
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	66 50       	ld.w	r0,r3[0x14]

80006d88 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006d88:	eb cd 40 f8 	pushm	r3-r7,lr
80006d8c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d8e:	48 c7       	lddpc	r7,80006dbc <task_log+0x34>
80006d90:	30 05       	mov	r5,0
80006d92:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006d94:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d98:	0a 99       	mov	r9,r5
80006d9a:	08 9a       	mov	r10,r4
80006d9c:	1a 9b       	mov	r11,sp
80006d9e:	6e 0c       	ld.w	r12,r7[0x0]
80006da0:	f0 1f 00 08 	mcall	80006dc0 <task_log+0x38>
80006da4:	58 1c       	cp.w	r12,1
80006da6:	cf 91       	brne	80006d98 <task_log+0x10>
		{
			if( NULL != str)
80006da8:	40 0b       	lddsp	r11,sp[0x0]
80006daa:	58 0b       	cp.w	r11,0
80006dac:	cf 60       	breq	80006d98 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006dae:	06 9c       	mov	r12,r3
80006db0:	f0 1f 00 05 	mcall	80006dc4 <task_log+0x3c>
				vPortFree(str);
80006db4:	40 0c       	lddsp	r12,sp[0x0]
80006db6:	f0 1f 00 05 	mcall	80006dc8 <task_log+0x40>
80006dba:	ce fb       	rjmp	80006d98 <task_log+0x10>
80006dbc:	00 00       	add	r0,r0
80006dbe:	51 18       	stdsp	sp[0x44],r8
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	5c 28       	cpc	r8
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	55 f4       	stdsp	sp[0x17c],r4
80006dc8:	80 00       	ld.sh	r0,r0[0x0]
80006dca:	5a b8       	cp.w	r8,-21

80006dcc <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006dcc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006dce:	fe 78 10 00 	mov	r8,-61440
80006dd2:	30 19       	mov	r9,1
80006dd4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006dd8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006ddc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006de0:	d3 03       	ssrf	0x10
	local_start_pll0();
80006de2:	f0 1f 00 0b 	mcall	80006e0c <main+0x40>
		
	INTC_init_interrupts();
80006de6:	f0 1f 00 0b 	mcall	80006e10 <main+0x44>
		
	log_init();
80006dea:	f0 1f 00 0b 	mcall	80006e14 <main+0x48>
	log("----start debug----");
80006dee:	48 bc       	lddpc	r12,80006e18 <main+0x4c>
80006df0:	f0 1f 00 0b 	mcall	80006e1c <main+0x50>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006df4:	f0 1f 00 0b 	mcall	80006e20 <main+0x54>
		
	app_init();
80006df8:	f0 1f 00 0b 	mcall	80006e24 <main+0x58>
		
	xcmp_init();
80006dfc:	f0 1f 00 0b 	mcall	80006e28 <main+0x5c>

	local_start_timer();
80006e00:	f0 1f 00 0b 	mcall	80006e2c <main+0x60>
		
	vTaskStartScheduler();
80006e04:	f0 1f 00 0b 	mcall	80006e30 <main+0x64>
	return 0;
	
}
80006e08:	d8 0a       	popm	pc,r12=0
80006e0a:	00 00       	add	r0,r0
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	4f d8       	lddpc	r8,80007000 <_malloc_r+0x1ac>
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	52 14       	stdsp	sp[0x84],r4
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	6d 20       	ld.w	r0,r6[0x48]
80006e18:	80 00       	ld.sh	r0,r0[0x0]
80006e1a:	d5 bc       	*unknown*
80006e1c:	80 00       	ld.sh	r0,r0[0x0]
80006e1e:	6a 14       	ld.w	r4,r5[0x4]
80006e20:	80 00       	ld.sh	r0,r0[0x0]
80006e22:	4f cc       	lddpc	r12,80007010 <_malloc_r+0x1bc>
80006e24:	80 00       	ld.sh	r0,r0[0x0]
80006e26:	20 3c       	sub	r12,3
80006e28:	80 00       	ld.sh	r0,r0[0x0]
80006e2a:	3e f0       	mov	r0,-17
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	50 90       	stdsp	sp[0x24],r0
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	68 38       	ld.w	r8,r4[0xc]

80006e34 <free>:
80006e34:	d4 01       	pushm	lr
80006e36:	e0 68 0a 38 	mov	r8,2616
80006e3a:	18 9b       	mov	r11,r12
80006e3c:	70 0c       	ld.w	r12,r8[0x0]
80006e3e:	e0 a0 1e 61 	rcall	8000ab00 <_free_r>
80006e42:	d8 02       	popm	pc

80006e44 <malloc>:
80006e44:	d4 01       	pushm	lr
80006e46:	e0 68 0a 38 	mov	r8,2616
80006e4a:	18 9b       	mov	r11,r12
80006e4c:	70 0c       	ld.w	r12,r8[0x0]
80006e4e:	c0 3c       	rcall	80006e54 <_malloc_r>
80006e50:	d8 02       	popm	pc
80006e52:	d7 03       	nop

80006e54 <_malloc_r>:
80006e54:	d4 31       	pushm	r0-r7,lr
80006e56:	f6 c8 ff f5 	sub	r8,r11,-11
80006e5a:	18 95       	mov	r5,r12
80006e5c:	10 97       	mov	r7,r8
80006e5e:	e0 17 ff f8 	andl	r7,0xfff8
80006e62:	59 68       	cp.w	r8,22
80006e64:	f9 b7 08 10 	movls	r7,16
80006e68:	16 37       	cp.w	r7,r11
80006e6a:	5f 38       	srlo	r8
80006e6c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006e70:	c0 50       	breq	80006e7a <_malloc_r+0x26>
80006e72:	30 c8       	mov	r8,12
80006e74:	99 38       	st.w	r12[0xc],r8
80006e76:	e0 8f 01 fa 	bral	8000726a <_malloc_r+0x416>
80006e7a:	fe b0 f5 d5 	rcall	80005a24 <__malloc_lock>
80006e7e:	e0 47 01 f7 	cp.w	r7,503
80006e82:	e0 8b 00 1d 	brhi	80006ebc <_malloc_r+0x68>
80006e86:	ee 03 16 03 	lsr	r3,r7,0x3
80006e8a:	e0 68 05 38 	mov	r8,1336
80006e8e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006e92:	70 36       	ld.w	r6,r8[0xc]
80006e94:	10 36       	cp.w	r6,r8
80006e96:	c0 61       	brne	80006ea2 <_malloc_r+0x4e>
80006e98:	ec c8 ff f8 	sub	r8,r6,-8
80006e9c:	70 36       	ld.w	r6,r8[0xc]
80006e9e:	10 36       	cp.w	r6,r8
80006ea0:	c0 c0       	breq	80006eb8 <_malloc_r+0x64>
80006ea2:	6c 18       	ld.w	r8,r6[0x4]
80006ea4:	e0 18 ff fc 	andl	r8,0xfffc
80006ea8:	6c 3a       	ld.w	r10,r6[0xc]
80006eaa:	ec 08 00 09 	add	r9,r6,r8
80006eae:	0a 9c       	mov	r12,r5
80006eb0:	6c 28       	ld.w	r8,r6[0x8]
80006eb2:	95 28       	st.w	r10[0x8],r8
80006eb4:	91 3a       	st.w	r8[0xc],r10
80006eb6:	c4 78       	rjmp	80006f44 <_malloc_r+0xf0>
80006eb8:	2f e3       	sub	r3,-2
80006eba:	c4 d8       	rjmp	80006f54 <_malloc_r+0x100>
80006ebc:	ee 03 16 09 	lsr	r3,r7,0x9
80006ec0:	c0 41       	brne	80006ec8 <_malloc_r+0x74>
80006ec2:	ee 03 16 03 	lsr	r3,r7,0x3
80006ec6:	c2 68       	rjmp	80006f12 <_malloc_r+0xbe>
80006ec8:	58 43       	cp.w	r3,4
80006eca:	e0 8b 00 06 	brhi	80006ed6 <_malloc_r+0x82>
80006ece:	ee 03 16 06 	lsr	r3,r7,0x6
80006ed2:	2c 83       	sub	r3,-56
80006ed4:	c1 f8       	rjmp	80006f12 <_malloc_r+0xbe>
80006ed6:	59 43       	cp.w	r3,20
80006ed8:	e0 8b 00 04 	brhi	80006ee0 <_malloc_r+0x8c>
80006edc:	2a 53       	sub	r3,-91
80006ede:	c1 a8       	rjmp	80006f12 <_malloc_r+0xbe>
80006ee0:	e0 43 00 54 	cp.w	r3,84
80006ee4:	e0 8b 00 06 	brhi	80006ef0 <_malloc_r+0x9c>
80006ee8:	ee 03 16 0c 	lsr	r3,r7,0xc
80006eec:	29 23       	sub	r3,-110
80006eee:	c1 28       	rjmp	80006f12 <_malloc_r+0xbe>
80006ef0:	e0 43 01 54 	cp.w	r3,340
80006ef4:	e0 8b 00 06 	brhi	80006f00 <_malloc_r+0xac>
80006ef8:	ee 03 16 0f 	lsr	r3,r7,0xf
80006efc:	28 93       	sub	r3,-119
80006efe:	c0 a8       	rjmp	80006f12 <_malloc_r+0xbe>
80006f00:	e0 43 05 54 	cp.w	r3,1364
80006f04:	e0 88 00 04 	brls	80006f0c <_malloc_r+0xb8>
80006f08:	37 e3       	mov	r3,126
80006f0a:	c0 48       	rjmp	80006f12 <_malloc_r+0xbe>
80006f0c:	ee 03 16 12 	lsr	r3,r7,0x12
80006f10:	28 43       	sub	r3,-124
80006f12:	e0 6a 05 38 	mov	r10,1336
80006f16:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006f1a:	74 36       	ld.w	r6,r10[0xc]
80006f1c:	c1 98       	rjmp	80006f4e <_malloc_r+0xfa>
80006f1e:	6c 19       	ld.w	r9,r6[0x4]
80006f20:	e0 19 ff fc 	andl	r9,0xfffc
80006f24:	f2 07 01 0b 	sub	r11,r9,r7
80006f28:	58 fb       	cp.w	r11,15
80006f2a:	e0 8a 00 04 	brle	80006f32 <_malloc_r+0xde>
80006f2e:	20 13       	sub	r3,1
80006f30:	c1 18       	rjmp	80006f52 <_malloc_r+0xfe>
80006f32:	6c 38       	ld.w	r8,r6[0xc]
80006f34:	58 0b       	cp.w	r11,0
80006f36:	c0 b5       	brlt	80006f4c <_malloc_r+0xf8>
80006f38:	6c 2a       	ld.w	r10,r6[0x8]
80006f3a:	ec 09 00 09 	add	r9,r6,r9
80006f3e:	0a 9c       	mov	r12,r5
80006f40:	91 2a       	st.w	r8[0x8],r10
80006f42:	95 38       	st.w	r10[0xc],r8
80006f44:	72 18       	ld.w	r8,r9[0x4]
80006f46:	a1 a8       	sbr	r8,0x0
80006f48:	93 18       	st.w	r9[0x4],r8
80006f4a:	cb c8       	rjmp	800070c2 <_malloc_r+0x26e>
80006f4c:	10 96       	mov	r6,r8
80006f4e:	14 36       	cp.w	r6,r10
80006f50:	ce 71       	brne	80006f1e <_malloc_r+0xca>
80006f52:	2f f3       	sub	r3,-1
80006f54:	e0 6a 05 38 	mov	r10,1336
80006f58:	f4 cc ff f8 	sub	r12,r10,-8
80006f5c:	78 26       	ld.w	r6,r12[0x8]
80006f5e:	18 36       	cp.w	r6,r12
80006f60:	c6 c0       	breq	80007038 <_malloc_r+0x1e4>
80006f62:	6c 19       	ld.w	r9,r6[0x4]
80006f64:	e0 19 ff fc 	andl	r9,0xfffc
80006f68:	f2 07 01 08 	sub	r8,r9,r7
80006f6c:	58 f8       	cp.w	r8,15
80006f6e:	e0 89 00 8f 	brgt	8000708c <_malloc_r+0x238>
80006f72:	99 3c       	st.w	r12[0xc],r12
80006f74:	99 2c       	st.w	r12[0x8],r12
80006f76:	58 08       	cp.w	r8,0
80006f78:	c0 55       	brlt	80006f82 <_malloc_r+0x12e>
80006f7a:	ec 09 00 09 	add	r9,r6,r9
80006f7e:	0a 9c       	mov	r12,r5
80006f80:	ce 2b       	rjmp	80006f44 <_malloc_r+0xf0>
80006f82:	e0 49 01 ff 	cp.w	r9,511
80006f86:	e0 8b 00 13 	brhi	80006fac <_malloc_r+0x158>
80006f8a:	a3 99       	lsr	r9,0x3
80006f8c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006f90:	70 2b       	ld.w	r11,r8[0x8]
80006f92:	8d 38       	st.w	r6[0xc],r8
80006f94:	8d 2b       	st.w	r6[0x8],r11
80006f96:	97 36       	st.w	r11[0xc],r6
80006f98:	91 26       	st.w	r8[0x8],r6
80006f9a:	a3 49       	asr	r9,0x2
80006f9c:	74 18       	ld.w	r8,r10[0x4]
80006f9e:	30 1b       	mov	r11,1
80006fa0:	f6 09 09 49 	lsl	r9,r11,r9
80006fa4:	f1 e9 10 09 	or	r9,r8,r9
80006fa8:	95 19       	st.w	r10[0x4],r9
80006faa:	c4 78       	rjmp	80007038 <_malloc_r+0x1e4>
80006fac:	f2 0a 16 09 	lsr	r10,r9,0x9
80006fb0:	58 4a       	cp.w	r10,4
80006fb2:	e0 8b 00 07 	brhi	80006fc0 <_malloc_r+0x16c>
80006fb6:	f2 0a 16 06 	lsr	r10,r9,0x6
80006fba:	2c 8a       	sub	r10,-56
80006fbc:	c2 08       	rjmp	80006ffc <_malloc_r+0x1a8>
80006fbe:	d7 03       	nop
80006fc0:	59 4a       	cp.w	r10,20
80006fc2:	e0 8b 00 04 	brhi	80006fca <_malloc_r+0x176>
80006fc6:	2a 5a       	sub	r10,-91
80006fc8:	c1 a8       	rjmp	80006ffc <_malloc_r+0x1a8>
80006fca:	e0 4a 00 54 	cp.w	r10,84
80006fce:	e0 8b 00 06 	brhi	80006fda <_malloc_r+0x186>
80006fd2:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006fd6:	29 2a       	sub	r10,-110
80006fd8:	c1 28       	rjmp	80006ffc <_malloc_r+0x1a8>
80006fda:	e0 4a 01 54 	cp.w	r10,340
80006fde:	e0 8b 00 06 	brhi	80006fea <_malloc_r+0x196>
80006fe2:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006fe6:	28 9a       	sub	r10,-119
80006fe8:	c0 a8       	rjmp	80006ffc <_malloc_r+0x1a8>
80006fea:	e0 4a 05 54 	cp.w	r10,1364
80006fee:	e0 88 00 04 	brls	80006ff6 <_malloc_r+0x1a2>
80006ff2:	37 ea       	mov	r10,126
80006ff4:	c0 48       	rjmp	80006ffc <_malloc_r+0x1a8>
80006ff6:	f2 0a 16 12 	lsr	r10,r9,0x12
80006ffa:	28 4a       	sub	r10,-124
80006ffc:	e0 6b 05 38 	mov	r11,1336
80007000:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007004:	68 28       	ld.w	r8,r4[0x8]
80007006:	08 38       	cp.w	r8,r4
80007008:	c0 e1       	brne	80007024 <_malloc_r+0x1d0>
8000700a:	76 19       	ld.w	r9,r11[0x4]
8000700c:	a3 4a       	asr	r10,0x2
8000700e:	30 1e       	mov	lr,1
80007010:	fc 0a 09 4a 	lsl	r10,lr,r10
80007014:	f3 ea 10 0a 	or	r10,r9,r10
80007018:	10 99       	mov	r9,r8
8000701a:	97 1a       	st.w	r11[0x4],r10
8000701c:	c0 a8       	rjmp	80007030 <_malloc_r+0x1dc>
8000701e:	70 28       	ld.w	r8,r8[0x8]
80007020:	08 38       	cp.w	r8,r4
80007022:	c0 60       	breq	8000702e <_malloc_r+0x1da>
80007024:	70 1a       	ld.w	r10,r8[0x4]
80007026:	e0 1a ff fc 	andl	r10,0xfffc
8000702a:	14 39       	cp.w	r9,r10
8000702c:	cf 93       	brcs	8000701e <_malloc_r+0x1ca>
8000702e:	70 39       	ld.w	r9,r8[0xc]
80007030:	8d 39       	st.w	r6[0xc],r9
80007032:	8d 28       	st.w	r6[0x8],r8
80007034:	91 36       	st.w	r8[0xc],r6
80007036:	93 26       	st.w	r9[0x8],r6
80007038:	e6 08 14 02 	asr	r8,r3,0x2
8000703c:	30 1b       	mov	r11,1
8000703e:	e0 64 05 38 	mov	r4,1336
80007042:	f6 08 09 4b 	lsl	r11,r11,r8
80007046:	68 18       	ld.w	r8,r4[0x4]
80007048:	10 3b       	cp.w	r11,r8
8000704a:	e0 8b 00 6b 	brhi	80007120 <_malloc_r+0x2cc>
8000704e:	f7 e8 00 09 	and	r9,r11,r8
80007052:	c0 b1       	brne	80007068 <_malloc_r+0x214>
80007054:	e0 13 ff fc 	andl	r3,0xfffc
80007058:	a1 7b       	lsl	r11,0x1
8000705a:	2f c3       	sub	r3,-4
8000705c:	c0 38       	rjmp	80007062 <_malloc_r+0x20e>
8000705e:	2f c3       	sub	r3,-4
80007060:	a1 7b       	lsl	r11,0x1
80007062:	f7 e8 00 09 	and	r9,r11,r8
80007066:	cf c0       	breq	8000705e <_malloc_r+0x20a>
80007068:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000706c:	06 92       	mov	r2,r3
8000706e:	1c 91       	mov	r1,lr
80007070:	62 36       	ld.w	r6,r1[0xc]
80007072:	c2 e8       	rjmp	800070ce <_malloc_r+0x27a>
80007074:	6c 1a       	ld.w	r10,r6[0x4]
80007076:	e0 1a ff fc 	andl	r10,0xfffc
8000707a:	f4 07 01 08 	sub	r8,r10,r7
8000707e:	58 f8       	cp.w	r8,15
80007080:	e0 8a 00 15 	brle	800070aa <_malloc_r+0x256>
80007084:	6c 3a       	ld.w	r10,r6[0xc]
80007086:	6c 29       	ld.w	r9,r6[0x8]
80007088:	95 29       	st.w	r10[0x8],r9
8000708a:	93 3a       	st.w	r9[0xc],r10
8000708c:	0e 99       	mov	r9,r7
8000708e:	ec 07 00 07 	add	r7,r6,r7
80007092:	a1 a9       	sbr	r9,0x0
80007094:	99 37       	st.w	r12[0xc],r7
80007096:	99 27       	st.w	r12[0x8],r7
80007098:	8d 19       	st.w	r6[0x4],r9
8000709a:	ee 08 09 08 	st.w	r7[r8],r8
8000709e:	8f 2c       	st.w	r7[0x8],r12
800070a0:	8f 3c       	st.w	r7[0xc],r12
800070a2:	a1 a8       	sbr	r8,0x0
800070a4:	0a 9c       	mov	r12,r5
800070a6:	8f 18       	st.w	r7[0x4],r8
800070a8:	c0 d8       	rjmp	800070c2 <_malloc_r+0x26e>
800070aa:	6c 39       	ld.w	r9,r6[0xc]
800070ac:	58 08       	cp.w	r8,0
800070ae:	c0 f5       	brlt	800070cc <_malloc_r+0x278>
800070b0:	ec 0a 00 0a 	add	r10,r6,r10
800070b4:	74 18       	ld.w	r8,r10[0x4]
800070b6:	a1 a8       	sbr	r8,0x0
800070b8:	0a 9c       	mov	r12,r5
800070ba:	95 18       	st.w	r10[0x4],r8
800070bc:	6c 28       	ld.w	r8,r6[0x8]
800070be:	93 28       	st.w	r9[0x8],r8
800070c0:	91 39       	st.w	r8[0xc],r9
800070c2:	fe b0 f4 b7 	rcall	80005a30 <__malloc_unlock>
800070c6:	ec cc ff f8 	sub	r12,r6,-8
800070ca:	d8 32       	popm	r0-r7,pc
800070cc:	12 96       	mov	r6,r9
800070ce:	02 36       	cp.w	r6,r1
800070d0:	cd 21       	brne	80007074 <_malloc_r+0x220>
800070d2:	2f f2       	sub	r2,-1
800070d4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800070d8:	c0 30       	breq	800070de <_malloc_r+0x28a>
800070da:	2f 81       	sub	r1,-8
800070dc:	cc ab       	rjmp	80007070 <_malloc_r+0x21c>
800070de:	1c 98       	mov	r8,lr
800070e0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800070e4:	c0 81       	brne	800070f4 <_malloc_r+0x2a0>
800070e6:	68 19       	ld.w	r9,r4[0x4]
800070e8:	f6 08 11 ff 	rsub	r8,r11,-1
800070ec:	f3 e8 00 08 	and	r8,r9,r8
800070f0:	89 18       	st.w	r4[0x4],r8
800070f2:	c0 78       	rjmp	80007100 <_malloc_r+0x2ac>
800070f4:	f0 c9 00 08 	sub	r9,r8,8
800070f8:	20 13       	sub	r3,1
800070fa:	70 08       	ld.w	r8,r8[0x0]
800070fc:	12 38       	cp.w	r8,r9
800070fe:	cf 10       	breq	800070e0 <_malloc_r+0x28c>
80007100:	a1 7b       	lsl	r11,0x1
80007102:	68 18       	ld.w	r8,r4[0x4]
80007104:	10 3b       	cp.w	r11,r8
80007106:	e0 8b 00 0d 	brhi	80007120 <_malloc_r+0x2cc>
8000710a:	58 0b       	cp.w	r11,0
8000710c:	c0 a0       	breq	80007120 <_malloc_r+0x2cc>
8000710e:	04 93       	mov	r3,r2
80007110:	c0 38       	rjmp	80007116 <_malloc_r+0x2c2>
80007112:	2f c3       	sub	r3,-4
80007114:	a1 7b       	lsl	r11,0x1
80007116:	f7 e8 00 09 	and	r9,r11,r8
8000711a:	ca 71       	brne	80007068 <_malloc_r+0x214>
8000711c:	cf bb       	rjmp	80007112 <_malloc_r+0x2be>
8000711e:	d7 03       	nop
80007120:	68 23       	ld.w	r3,r4[0x8]
80007122:	66 12       	ld.w	r2,r3[0x4]
80007124:	e0 12 ff fc 	andl	r2,0xfffc
80007128:	0e 32       	cp.w	r2,r7
8000712a:	5f 39       	srlo	r9
8000712c:	e4 07 01 08 	sub	r8,r2,r7
80007130:	58 f8       	cp.w	r8,15
80007132:	5f aa       	srle	r10
80007134:	f5 e9 10 09 	or	r9,r10,r9
80007138:	e0 80 00 9a 	breq	8000726c <_malloc_r+0x418>
8000713c:	e0 68 0d 4c 	mov	r8,3404
80007140:	70 01       	ld.w	r1,r8[0x0]
80007142:	e0 68 09 44 	mov	r8,2372
80007146:	2f 01       	sub	r1,-16
80007148:	70 08       	ld.w	r8,r8[0x0]
8000714a:	0e 01       	add	r1,r7
8000714c:	5b f8       	cp.w	r8,-1
8000714e:	c0 40       	breq	80007156 <_malloc_r+0x302>
80007150:	28 11       	sub	r1,-127
80007152:	e0 11 ff 80 	andl	r1,0xff80
80007156:	02 9b       	mov	r11,r1
80007158:	0a 9c       	mov	r12,r5
8000715a:	e0 a0 02 a5 	rcall	800076a4 <_sbrk_r>
8000715e:	18 96       	mov	r6,r12
80007160:	5b fc       	cp.w	r12,-1
80007162:	c7 50       	breq	8000724c <_malloc_r+0x3f8>
80007164:	e6 02 00 08 	add	r8,r3,r2
80007168:	10 3c       	cp.w	r12,r8
8000716a:	c0 32       	brcc	80007170 <_malloc_r+0x31c>
8000716c:	08 33       	cp.w	r3,r4
8000716e:	c6 f1       	brne	8000724c <_malloc_r+0x3f8>
80007170:	e0 6a 0d 50 	mov	r10,3408
80007174:	74 09       	ld.w	r9,r10[0x0]
80007176:	e2 09 00 09 	add	r9,r1,r9
8000717a:	95 09       	st.w	r10[0x0],r9
8000717c:	10 36       	cp.w	r6,r8
8000717e:	c0 a1       	brne	80007192 <_malloc_r+0x33e>
80007180:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007184:	c0 71       	brne	80007192 <_malloc_r+0x33e>
80007186:	e2 02 00 02 	add	r2,r1,r2
8000718a:	68 28       	ld.w	r8,r4[0x8]
8000718c:	a1 a2       	sbr	r2,0x0
8000718e:	91 12       	st.w	r8[0x4],r2
80007190:	c4 f8       	rjmp	8000722e <_malloc_r+0x3da>
80007192:	e0 6a 09 44 	mov	r10,2372
80007196:	74 0b       	ld.w	r11,r10[0x0]
80007198:	5b fb       	cp.w	r11,-1
8000719a:	c0 31       	brne	800071a0 <_malloc_r+0x34c>
8000719c:	95 06       	st.w	r10[0x0],r6
8000719e:	c0 78       	rjmp	800071ac <_malloc_r+0x358>
800071a0:	ec 09 00 09 	add	r9,r6,r9
800071a4:	e0 6a 0d 50 	mov	r10,3408
800071a8:	10 19       	sub	r9,r8
800071aa:	95 09       	st.w	r10[0x0],r9
800071ac:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800071b0:	f0 09 11 08 	rsub	r9,r8,8
800071b4:	58 08       	cp.w	r8,0
800071b6:	f2 08 17 10 	movne	r8,r9
800071ba:	ed d8 e1 06 	addne	r6,r6,r8
800071be:	28 08       	sub	r8,-128
800071c0:	ec 01 00 01 	add	r1,r6,r1
800071c4:	0a 9c       	mov	r12,r5
800071c6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800071ca:	f0 01 01 01 	sub	r1,r8,r1
800071ce:	02 9b       	mov	r11,r1
800071d0:	e0 a0 02 6a 	rcall	800076a4 <_sbrk_r>
800071d4:	e0 68 0d 50 	mov	r8,3408
800071d8:	5b fc       	cp.w	r12,-1
800071da:	ec 0c 17 00 	moveq	r12,r6
800071de:	f9 b1 00 00 	moveq	r1,0
800071e2:	70 09       	ld.w	r9,r8[0x0]
800071e4:	0c 1c       	sub	r12,r6
800071e6:	89 26       	st.w	r4[0x8],r6
800071e8:	02 0c       	add	r12,r1
800071ea:	12 01       	add	r1,r9
800071ec:	a1 ac       	sbr	r12,0x0
800071ee:	91 01       	st.w	r8[0x0],r1
800071f0:	8d 1c       	st.w	r6[0x4],r12
800071f2:	08 33       	cp.w	r3,r4
800071f4:	c1 d0       	breq	8000722e <_malloc_r+0x3da>
800071f6:	58 f2       	cp.w	r2,15
800071f8:	e0 8b 00 05 	brhi	80007202 <_malloc_r+0x3ae>
800071fc:	30 18       	mov	r8,1
800071fe:	8d 18       	st.w	r6[0x4],r8
80007200:	c2 68       	rjmp	8000724c <_malloc_r+0x3f8>
80007202:	30 59       	mov	r9,5
80007204:	20 c2       	sub	r2,12
80007206:	e0 12 ff f8 	andl	r2,0xfff8
8000720a:	e6 02 00 08 	add	r8,r3,r2
8000720e:	91 29       	st.w	r8[0x8],r9
80007210:	91 19       	st.w	r8[0x4],r9
80007212:	66 18       	ld.w	r8,r3[0x4]
80007214:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007218:	e5 e8 10 08 	or	r8,r2,r8
8000721c:	87 18       	st.w	r3[0x4],r8
8000721e:	58 f2       	cp.w	r2,15
80007220:	e0 88 00 07 	brls	8000722e <_malloc_r+0x3da>
80007224:	e6 cb ff f8 	sub	r11,r3,-8
80007228:	0a 9c       	mov	r12,r5
8000722a:	e0 a0 1c 6b 	rcall	8000ab00 <_free_r>
8000722e:	e0 69 0d 48 	mov	r9,3400
80007232:	72 0a       	ld.w	r10,r9[0x0]
80007234:	e0 68 0d 50 	mov	r8,3408
80007238:	70 08       	ld.w	r8,r8[0x0]
8000723a:	14 38       	cp.w	r8,r10
8000723c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007240:	e0 69 0d 44 	mov	r9,3396
80007244:	72 0a       	ld.w	r10,r9[0x0]
80007246:	14 38       	cp.w	r8,r10
80007248:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000724c:	68 28       	ld.w	r8,r4[0x8]
8000724e:	70 18       	ld.w	r8,r8[0x4]
80007250:	e0 18 ff fc 	andl	r8,0xfffc
80007254:	0e 38       	cp.w	r8,r7
80007256:	5f 39       	srlo	r9
80007258:	0e 18       	sub	r8,r7
8000725a:	58 f8       	cp.w	r8,15
8000725c:	5f aa       	srle	r10
8000725e:	f5 e9 10 09 	or	r9,r10,r9
80007262:	c0 50       	breq	8000726c <_malloc_r+0x418>
80007264:	0a 9c       	mov	r12,r5
80007266:	fe b0 f3 e5 	rcall	80005a30 <__malloc_unlock>
8000726a:	d8 3a       	popm	r0-r7,pc,r12=0
8000726c:	68 26       	ld.w	r6,r4[0x8]
8000726e:	a1 a8       	sbr	r8,0x0
80007270:	0e 99       	mov	r9,r7
80007272:	a1 a9       	sbr	r9,0x0
80007274:	8d 19       	st.w	r6[0x4],r9
80007276:	ec 07 00 07 	add	r7,r6,r7
8000727a:	0a 9c       	mov	r12,r5
8000727c:	89 27       	st.w	r4[0x8],r7
8000727e:	8f 18       	st.w	r7[0x4],r8
80007280:	fe b0 f3 d8 	rcall	80005a30 <__malloc_unlock>
80007284:	ec cc ff f8 	sub	r12,r6,-8
80007288:	d8 32       	popm	r0-r7,pc
8000728a:	d7 03       	nop

8000728c <memcpy>:
8000728c:	58 8a       	cp.w	r10,8
8000728e:	c2 f5       	brlt	800072ec <memcpy+0x60>
80007290:	f9 eb 10 09 	or	r9,r12,r11
80007294:	e2 19 00 03 	andl	r9,0x3,COH
80007298:	e0 81 00 97 	brne	800073c6 <memcpy+0x13a>
8000729c:	e0 4a 00 20 	cp.w	r10,32
800072a0:	c3 b4       	brge	80007316 <memcpy+0x8a>
800072a2:	f4 08 14 02 	asr	r8,r10,0x2
800072a6:	f0 09 11 08 	rsub	r9,r8,8
800072aa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800072ae:	76 69       	ld.w	r9,r11[0x18]
800072b0:	99 69       	st.w	r12[0x18],r9
800072b2:	76 59       	ld.w	r9,r11[0x14]
800072b4:	99 59       	st.w	r12[0x14],r9
800072b6:	76 49       	ld.w	r9,r11[0x10]
800072b8:	99 49       	st.w	r12[0x10],r9
800072ba:	76 39       	ld.w	r9,r11[0xc]
800072bc:	99 39       	st.w	r12[0xc],r9
800072be:	76 29       	ld.w	r9,r11[0x8]
800072c0:	99 29       	st.w	r12[0x8],r9
800072c2:	76 19       	ld.w	r9,r11[0x4]
800072c4:	99 19       	st.w	r12[0x4],r9
800072c6:	76 09       	ld.w	r9,r11[0x0]
800072c8:	99 09       	st.w	r12[0x0],r9
800072ca:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800072ce:	f8 08 00 28 	add	r8,r12,r8<<0x2
800072d2:	e0 1a 00 03 	andl	r10,0x3
800072d6:	f4 0a 11 04 	rsub	r10,r10,4
800072da:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072de:	17 a9       	ld.ub	r9,r11[0x2]
800072e0:	b0 a9       	st.b	r8[0x2],r9
800072e2:	17 99       	ld.ub	r9,r11[0x1]
800072e4:	b0 99       	st.b	r8[0x1],r9
800072e6:	17 89       	ld.ub	r9,r11[0x0]
800072e8:	b0 89       	st.b	r8[0x0],r9
800072ea:	5e fc       	retal	r12
800072ec:	f4 0a 11 09 	rsub	r10,r10,9
800072f0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072f4:	17 f9       	ld.ub	r9,r11[0x7]
800072f6:	b8 f9       	st.b	r12[0x7],r9
800072f8:	17 e9       	ld.ub	r9,r11[0x6]
800072fa:	b8 e9       	st.b	r12[0x6],r9
800072fc:	17 d9       	ld.ub	r9,r11[0x5]
800072fe:	b8 d9       	st.b	r12[0x5],r9
80007300:	17 c9       	ld.ub	r9,r11[0x4]
80007302:	b8 c9       	st.b	r12[0x4],r9
80007304:	17 b9       	ld.ub	r9,r11[0x3]
80007306:	b8 b9       	st.b	r12[0x3],r9
80007308:	17 a9       	ld.ub	r9,r11[0x2]
8000730a:	b8 a9       	st.b	r12[0x2],r9
8000730c:	17 99       	ld.ub	r9,r11[0x1]
8000730e:	b8 99       	st.b	r12[0x1],r9
80007310:	17 89       	ld.ub	r9,r11[0x0]
80007312:	b8 89       	st.b	r12[0x0],r9
80007314:	5e fc       	retal	r12
80007316:	eb cd 40 c0 	pushm	r6-r7,lr
8000731a:	18 99       	mov	r9,r12
8000731c:	22 0a       	sub	r10,32
8000731e:	b7 07       	ld.d	r6,r11++
80007320:	b3 26       	st.d	r9++,r6
80007322:	b7 07       	ld.d	r6,r11++
80007324:	b3 26       	st.d	r9++,r6
80007326:	b7 07       	ld.d	r6,r11++
80007328:	b3 26       	st.d	r9++,r6
8000732a:	b7 07       	ld.d	r6,r11++
8000732c:	b3 26       	st.d	r9++,r6
8000732e:	22 0a       	sub	r10,32
80007330:	cf 74       	brge	8000731e <memcpy+0x92>
80007332:	2f 0a       	sub	r10,-16
80007334:	c0 65       	brlt	80007340 <memcpy+0xb4>
80007336:	b7 07       	ld.d	r6,r11++
80007338:	b3 26       	st.d	r9++,r6
8000733a:	b7 07       	ld.d	r6,r11++
8000733c:	b3 26       	st.d	r9++,r6
8000733e:	21 0a       	sub	r10,16
80007340:	5c 3a       	neg	r10
80007342:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007346:	d7 03       	nop
80007348:	d7 03       	nop
8000734a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000734e:	f3 66 00 0e 	st.b	r9[14],r6
80007352:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007356:	f3 66 00 0d 	st.b	r9[13],r6
8000735a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000735e:	f3 66 00 0c 	st.b	r9[12],r6
80007362:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007366:	f3 66 00 0b 	st.b	r9[11],r6
8000736a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000736e:	f3 66 00 0a 	st.b	r9[10],r6
80007372:	f7 36 00 09 	ld.ub	r6,r11[9]
80007376:	f3 66 00 09 	st.b	r9[9],r6
8000737a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000737e:	f3 66 00 08 	st.b	r9[8],r6
80007382:	f7 36 00 07 	ld.ub	r6,r11[7]
80007386:	f3 66 00 07 	st.b	r9[7],r6
8000738a:	f7 36 00 06 	ld.ub	r6,r11[6]
8000738e:	f3 66 00 06 	st.b	r9[6],r6
80007392:	f7 36 00 05 	ld.ub	r6,r11[5]
80007396:	f3 66 00 05 	st.b	r9[5],r6
8000739a:	f7 36 00 04 	ld.ub	r6,r11[4]
8000739e:	f3 66 00 04 	st.b	r9[4],r6
800073a2:	f7 36 00 03 	ld.ub	r6,r11[3]
800073a6:	f3 66 00 03 	st.b	r9[3],r6
800073aa:	f7 36 00 02 	ld.ub	r6,r11[2]
800073ae:	f3 66 00 02 	st.b	r9[2],r6
800073b2:	f7 36 00 01 	ld.ub	r6,r11[1]
800073b6:	f3 66 00 01 	st.b	r9[1],r6
800073ba:	f7 36 00 00 	ld.ub	r6,r11[0]
800073be:	f3 66 00 00 	st.b	r9[0],r6
800073c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073c6:	20 1a       	sub	r10,1
800073c8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800073cc:	f8 0a 0b 09 	st.b	r12[r10],r9
800073d0:	cf b1       	brne	800073c6 <memcpy+0x13a>
800073d2:	5e fc       	retal	r12

800073d4 <memset>:
800073d4:	18 98       	mov	r8,r12
800073d6:	c0 38       	rjmp	800073dc <memset+0x8>
800073d8:	10 cb       	st.b	r8++,r11
800073da:	20 1a       	sub	r10,1
800073dc:	58 0a       	cp.w	r10,0
800073de:	cf d1       	brne	800073d8 <memset+0x4>
800073e0:	5e fc       	retal	r12
800073e2:	d7 03       	nop

800073e4 <_realloc_r>:
800073e4:	d4 31       	pushm	r0-r7,lr
800073e6:	20 1d       	sub	sp,4
800073e8:	16 94       	mov	r4,r11
800073ea:	18 92       	mov	r2,r12
800073ec:	14 9b       	mov	r11,r10
800073ee:	58 04       	cp.w	r4,0
800073f0:	c0 51       	brne	800073fa <_realloc_r+0x16>
800073f2:	fe b0 fd 31 	rcall	80006e54 <_malloc_r>
800073f6:	18 95       	mov	r5,r12
800073f8:	c5 39       	rjmp	8000769e <_realloc_r+0x2ba>
800073fa:	50 0a       	stdsp	sp[0x0],r10
800073fc:	fe b0 f3 14 	rcall	80005a24 <__malloc_lock>
80007400:	40 0b       	lddsp	r11,sp[0x0]
80007402:	f6 c8 ff f5 	sub	r8,r11,-11
80007406:	e8 c1 00 08 	sub	r1,r4,8
8000740a:	10 96       	mov	r6,r8
8000740c:	62 1c       	ld.w	r12,r1[0x4]
8000740e:	e0 16 ff f8 	andl	r6,0xfff8
80007412:	59 68       	cp.w	r8,22
80007414:	f9 b6 08 10 	movls	r6,16
80007418:	16 36       	cp.w	r6,r11
8000741a:	5f 38       	srlo	r8
8000741c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007420:	c0 50       	breq	8000742a <_realloc_r+0x46>
80007422:	30 c8       	mov	r8,12
80007424:	30 05       	mov	r5,0
80007426:	85 38       	st.w	r2[0xc],r8
80007428:	c3 b9       	rjmp	8000769e <_realloc_r+0x2ba>
8000742a:	18 90       	mov	r0,r12
8000742c:	e0 10 ff fc 	andl	r0,0xfffc
80007430:	0c 30       	cp.w	r0,r6
80007432:	e0 84 01 0b 	brge	80007648 <_realloc_r+0x264>
80007436:	e0 68 05 38 	mov	r8,1336
8000743a:	e2 00 00 09 	add	r9,r1,r0
8000743e:	70 25       	ld.w	r5,r8[0x8]
80007440:	0a 39       	cp.w	r9,r5
80007442:	c0 90       	breq	80007454 <_realloc_r+0x70>
80007444:	72 1a       	ld.w	r10,r9[0x4]
80007446:	a1 ca       	cbr	r10,0x0
80007448:	f2 0a 00 0a 	add	r10,r9,r10
8000744c:	74 1a       	ld.w	r10,r10[0x4]
8000744e:	ed ba 00 00 	bld	r10,0x0
80007452:	c2 20       	breq	80007496 <_realloc_r+0xb2>
80007454:	72 1a       	ld.w	r10,r9[0x4]
80007456:	e0 1a ff fc 	andl	r10,0xfffc
8000745a:	f4 00 00 03 	add	r3,r10,r0
8000745e:	0a 39       	cp.w	r9,r5
80007460:	c1 31       	brne	80007486 <_realloc_r+0xa2>
80007462:	ec c7 ff f0 	sub	r7,r6,-16
80007466:	0e 33       	cp.w	r3,r7
80007468:	c1 95       	brlt	8000749a <_realloc_r+0xb6>
8000746a:	e2 06 00 09 	add	r9,r1,r6
8000746e:	0c 13       	sub	r3,r6
80007470:	a1 a3       	sbr	r3,0x0
80007472:	93 13       	st.w	r9[0x4],r3
80007474:	91 29       	st.w	r8[0x8],r9
80007476:	04 9c       	mov	r12,r2
80007478:	62 18       	ld.w	r8,r1[0x4]
8000747a:	08 95       	mov	r5,r4
8000747c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007480:	10 46       	or	r6,r8
80007482:	83 16       	st.w	r1[0x4],r6
80007484:	c0 b9       	rjmp	8000769a <_realloc_r+0x2b6>
80007486:	0c 33       	cp.w	r3,r6
80007488:	c0 95       	brlt	8000749a <_realloc_r+0xb6>
8000748a:	72 28       	ld.w	r8,r9[0x8]
8000748c:	02 97       	mov	r7,r1
8000748e:	72 39       	ld.w	r9,r9[0xc]
80007490:	93 28       	st.w	r9[0x8],r8
80007492:	91 39       	st.w	r8[0xc],r9
80007494:	cd c8       	rjmp	8000764c <_realloc_r+0x268>
80007496:	30 0a       	mov	r10,0
80007498:	14 99       	mov	r9,r10
8000749a:	ed bc 00 00 	bld	r12,0x0
8000749e:	e0 80 00 95 	breq	800075c8 <_realloc_r+0x1e4>
800074a2:	62 07       	ld.w	r7,r1[0x0]
800074a4:	e2 07 01 07 	sub	r7,r1,r7
800074a8:	6e 1c       	ld.w	r12,r7[0x4]
800074aa:	e0 1c ff fc 	andl	r12,0xfffc
800074ae:	58 09       	cp.w	r9,0
800074b0:	c5 60       	breq	8000755c <_realloc_r+0x178>
800074b2:	f8 00 00 03 	add	r3,r12,r0
800074b6:	0a 39       	cp.w	r9,r5
800074b8:	c4 81       	brne	80007548 <_realloc_r+0x164>
800074ba:	14 03       	add	r3,r10
800074bc:	ec c9 ff f0 	sub	r9,r6,-16
800074c0:	12 33       	cp.w	r3,r9
800074c2:	c4 d5       	brlt	8000755c <_realloc_r+0x178>
800074c4:	6e 3a       	ld.w	r10,r7[0xc]
800074c6:	6e 29       	ld.w	r9,r7[0x8]
800074c8:	95 29       	st.w	r10[0x8],r9
800074ca:	93 3a       	st.w	r9[0xc],r10
800074cc:	ee c5 ff f8 	sub	r5,r7,-8
800074d0:	e0 ca 00 04 	sub	r10,r0,4
800074d4:	e0 4a 00 24 	cp.w	r10,36
800074d8:	e0 8b 00 25 	brhi	80007522 <_realloc_r+0x13e>
800074dc:	0a 99       	mov	r9,r5
800074de:	59 3a       	cp.w	r10,19
800074e0:	e0 88 00 1a 	brls	80007514 <_realloc_r+0x130>
800074e4:	09 09       	ld.w	r9,r4++
800074e6:	8b 09       	st.w	r5[0x0],r9
800074e8:	09 09       	ld.w	r9,r4++
800074ea:	8f 39       	st.w	r7[0xc],r9
800074ec:	ee c9 ff f0 	sub	r9,r7,-16
800074f0:	59 ba       	cp.w	r10,27
800074f2:	e0 88 00 11 	brls	80007514 <_realloc_r+0x130>
800074f6:	09 0b       	ld.w	r11,r4++
800074f8:	93 0b       	st.w	r9[0x0],r11
800074fa:	09 09       	ld.w	r9,r4++
800074fc:	8f 59       	st.w	r7[0x14],r9
800074fe:	ee c9 ff e8 	sub	r9,r7,-24
80007502:	e0 4a 00 24 	cp.w	r10,36
80007506:	c0 71       	brne	80007514 <_realloc_r+0x130>
80007508:	09 0a       	ld.w	r10,r4++
8000750a:	93 0a       	st.w	r9[0x0],r10
8000750c:	ee c9 ff e0 	sub	r9,r7,-32
80007510:	09 0a       	ld.w	r10,r4++
80007512:	8f 7a       	st.w	r7[0x1c],r10
80007514:	09 0a       	ld.w	r10,r4++
80007516:	12 aa       	st.w	r9++,r10
80007518:	68 0a       	ld.w	r10,r4[0x0]
8000751a:	93 0a       	st.w	r9[0x0],r10
8000751c:	68 1a       	ld.w	r10,r4[0x4]
8000751e:	93 1a       	st.w	r9[0x4],r10
80007520:	c0 78       	rjmp	8000752e <_realloc_r+0x14a>
80007522:	50 08       	stdsp	sp[0x0],r8
80007524:	08 9b       	mov	r11,r4
80007526:	0a 9c       	mov	r12,r5
80007528:	e0 a0 1d 8f 	rcall	8000b046 <memmove>
8000752c:	40 08       	lddsp	r8,sp[0x0]
8000752e:	ee 06 00 09 	add	r9,r7,r6
80007532:	0c 13       	sub	r3,r6
80007534:	a1 a3       	sbr	r3,0x0
80007536:	93 13       	st.w	r9[0x4],r3
80007538:	91 29       	st.w	r8[0x8],r9
8000753a:	04 9c       	mov	r12,r2
8000753c:	6e 18       	ld.w	r8,r7[0x4]
8000753e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007542:	10 46       	or	r6,r8
80007544:	8f 16       	st.w	r7[0x4],r6
80007546:	ca a8       	rjmp	8000769a <_realloc_r+0x2b6>
80007548:	14 03       	add	r3,r10
8000754a:	0c 33       	cp.w	r3,r6
8000754c:	c0 85       	brlt	8000755c <_realloc_r+0x178>
8000754e:	72 28       	ld.w	r8,r9[0x8]
80007550:	72 39       	ld.w	r9,r9[0xc]
80007552:	93 28       	st.w	r9[0x8],r8
80007554:	91 39       	st.w	r8[0xc],r9
80007556:	6e 28       	ld.w	r8,r7[0x8]
80007558:	6e 39       	ld.w	r9,r7[0xc]
8000755a:	c0 78       	rjmp	80007568 <_realloc_r+0x184>
8000755c:	f8 00 00 03 	add	r3,r12,r0
80007560:	0c 33       	cp.w	r3,r6
80007562:	c3 35       	brlt	800075c8 <_realloc_r+0x1e4>
80007564:	6e 39       	ld.w	r9,r7[0xc]
80007566:	6e 28       	ld.w	r8,r7[0x8]
80007568:	93 28       	st.w	r9[0x8],r8
8000756a:	91 39       	st.w	r8[0xc],r9
8000756c:	e0 ca 00 04 	sub	r10,r0,4
80007570:	ee cc ff f8 	sub	r12,r7,-8
80007574:	e0 4a 00 24 	cp.w	r10,36
80007578:	e0 8b 00 24 	brhi	800075c0 <_realloc_r+0x1dc>
8000757c:	59 3a       	cp.w	r10,19
8000757e:	e0 88 00 1a 	brls	800075b2 <_realloc_r+0x1ce>
80007582:	09 08       	ld.w	r8,r4++
80007584:	99 08       	st.w	r12[0x0],r8
80007586:	09 08       	ld.w	r8,r4++
80007588:	8f 38       	st.w	r7[0xc],r8
8000758a:	ee cc ff f0 	sub	r12,r7,-16
8000758e:	59 ba       	cp.w	r10,27
80007590:	e0 88 00 11 	brls	800075b2 <_realloc_r+0x1ce>
80007594:	09 08       	ld.w	r8,r4++
80007596:	99 08       	st.w	r12[0x0],r8
80007598:	09 08       	ld.w	r8,r4++
8000759a:	8f 58       	st.w	r7[0x14],r8
8000759c:	ee cc ff e8 	sub	r12,r7,-24
800075a0:	e0 4a 00 24 	cp.w	r10,36
800075a4:	c0 71       	brne	800075b2 <_realloc_r+0x1ce>
800075a6:	09 08       	ld.w	r8,r4++
800075a8:	99 08       	st.w	r12[0x0],r8
800075aa:	ee cc ff e0 	sub	r12,r7,-32
800075ae:	09 08       	ld.w	r8,r4++
800075b0:	8f 78       	st.w	r7[0x1c],r8
800075b2:	09 08       	ld.w	r8,r4++
800075b4:	18 a8       	st.w	r12++,r8
800075b6:	68 08       	ld.w	r8,r4[0x0]
800075b8:	99 08       	st.w	r12[0x0],r8
800075ba:	68 18       	ld.w	r8,r4[0x4]
800075bc:	99 18       	st.w	r12[0x4],r8
800075be:	c4 78       	rjmp	8000764c <_realloc_r+0x268>
800075c0:	08 9b       	mov	r11,r4
800075c2:	e0 a0 1d 42 	rcall	8000b046 <memmove>
800075c6:	c4 38       	rjmp	8000764c <_realloc_r+0x268>
800075c8:	04 9c       	mov	r12,r2
800075ca:	fe b0 fc 45 	rcall	80006e54 <_malloc_r>
800075ce:	18 95       	mov	r5,r12
800075d0:	c3 a0       	breq	80007644 <_realloc_r+0x260>
800075d2:	62 18       	ld.w	r8,r1[0x4]
800075d4:	f8 c9 00 08 	sub	r9,r12,8
800075d8:	a1 c8       	cbr	r8,0x0
800075da:	e2 08 00 08 	add	r8,r1,r8
800075de:	10 39       	cp.w	r9,r8
800075e0:	c0 71       	brne	800075ee <_realloc_r+0x20a>
800075e2:	72 13       	ld.w	r3,r9[0x4]
800075e4:	02 97       	mov	r7,r1
800075e6:	e0 13 ff fc 	andl	r3,0xfffc
800075ea:	00 03       	add	r3,r0
800075ec:	c3 08       	rjmp	8000764c <_realloc_r+0x268>
800075ee:	e0 ca 00 04 	sub	r10,r0,4
800075f2:	e0 4a 00 24 	cp.w	r10,36
800075f6:	e0 8b 00 20 	brhi	80007636 <_realloc_r+0x252>
800075fa:	08 99       	mov	r9,r4
800075fc:	18 98       	mov	r8,r12
800075fe:	59 3a       	cp.w	r10,19
80007600:	e0 88 00 14 	brls	80007628 <_realloc_r+0x244>
80007604:	13 0b       	ld.w	r11,r9++
80007606:	10 ab       	st.w	r8++,r11
80007608:	13 0b       	ld.w	r11,r9++
8000760a:	10 ab       	st.w	r8++,r11
8000760c:	59 ba       	cp.w	r10,27
8000760e:	e0 88 00 0d 	brls	80007628 <_realloc_r+0x244>
80007612:	13 0b       	ld.w	r11,r9++
80007614:	10 ab       	st.w	r8++,r11
80007616:	13 0b       	ld.w	r11,r9++
80007618:	10 ab       	st.w	r8++,r11
8000761a:	e0 4a 00 24 	cp.w	r10,36
8000761e:	c0 51       	brne	80007628 <_realloc_r+0x244>
80007620:	13 0a       	ld.w	r10,r9++
80007622:	10 aa       	st.w	r8++,r10
80007624:	13 0a       	ld.w	r10,r9++
80007626:	10 aa       	st.w	r8++,r10
80007628:	13 0a       	ld.w	r10,r9++
8000762a:	10 aa       	st.w	r8++,r10
8000762c:	72 0a       	ld.w	r10,r9[0x0]
8000762e:	91 0a       	st.w	r8[0x0],r10
80007630:	72 19       	ld.w	r9,r9[0x4]
80007632:	91 19       	st.w	r8[0x4],r9
80007634:	c0 48       	rjmp	8000763c <_realloc_r+0x258>
80007636:	08 9b       	mov	r11,r4
80007638:	e0 a0 1d 07 	rcall	8000b046 <memmove>
8000763c:	08 9b       	mov	r11,r4
8000763e:	04 9c       	mov	r12,r2
80007640:	e0 a0 1a 60 	rcall	8000ab00 <_free_r>
80007644:	04 9c       	mov	r12,r2
80007646:	c2 a8       	rjmp	8000769a <_realloc_r+0x2b6>
80007648:	00 93       	mov	r3,r0
8000764a:	02 97       	mov	r7,r1
8000764c:	e6 06 01 09 	sub	r9,r3,r6
80007650:	6e 18       	ld.w	r8,r7[0x4]
80007652:	58 f9       	cp.w	r9,15
80007654:	e0 88 00 16 	brls	80007680 <_realloc_r+0x29c>
80007658:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000765c:	ed e8 10 08 	or	r8,r6,r8
80007660:	8f 18       	st.w	r7[0x4],r8
80007662:	12 98       	mov	r8,r9
80007664:	a1 a8       	sbr	r8,0x0
80007666:	ee 06 00 0b 	add	r11,r7,r6
8000766a:	f6 09 00 09 	add	r9,r11,r9
8000766e:	97 18       	st.w	r11[0x4],r8
80007670:	72 18       	ld.w	r8,r9[0x4]
80007672:	a1 a8       	sbr	r8,0x0
80007674:	2f 8b       	sub	r11,-8
80007676:	93 18       	st.w	r9[0x4],r8
80007678:	04 9c       	mov	r12,r2
8000767a:	e0 a0 1a 43 	rcall	8000ab00 <_free_r>
8000767e:	c0 b8       	rjmp	80007694 <_realloc_r+0x2b0>
80007680:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007684:	e7 e8 10 08 	or	r8,r3,r8
80007688:	8f 18       	st.w	r7[0x4],r8
8000768a:	ee 03 00 03 	add	r3,r7,r3
8000768e:	66 18       	ld.w	r8,r3[0x4]
80007690:	a1 a8       	sbr	r8,0x0
80007692:	87 18       	st.w	r3[0x4],r8
80007694:	04 9c       	mov	r12,r2
80007696:	ee c5 ff f8 	sub	r5,r7,-8
8000769a:	fe b0 f1 cb 	rcall	80005a30 <__malloc_unlock>
8000769e:	0a 9c       	mov	r12,r5
800076a0:	2f fd       	sub	sp,-4
800076a2:	d8 32       	popm	r0-r7,pc

800076a4 <_sbrk_r>:
800076a4:	d4 21       	pushm	r4-r7,lr
800076a6:	30 08       	mov	r8,0
800076a8:	18 97       	mov	r7,r12
800076aa:	e0 66 51 1c 	mov	r6,20764
800076ae:	16 9c       	mov	r12,r11
800076b0:	8d 08       	st.w	r6[0x0],r8
800076b2:	c8 5c       	rcall	800077bc <_sbrk>
800076b4:	5b fc       	cp.w	r12,-1
800076b6:	c0 51       	brne	800076c0 <_sbrk_r+0x1c>
800076b8:	6c 08       	ld.w	r8,r6[0x0]
800076ba:	58 08       	cp.w	r8,0
800076bc:	ef f8 1a 03 	st.wne	r7[0xc],r8
800076c0:	d8 22       	popm	r4-r7,pc
800076c2:	d7 03       	nop

800076c4 <sprintf>:
800076c4:	d4 01       	pushm	lr
800076c6:	21 7d       	sub	sp,92
800076c8:	e0 68 ff ff 	mov	r8,65535
800076cc:	ea 18 7f ff 	orh	r8,0x7fff
800076d0:	50 58       	stdsp	sp[0x14],r8
800076d2:	50 28       	stdsp	sp[0x8],r8
800076d4:	e0 68 02 08 	mov	r8,520
800076d8:	ba 68       	st.h	sp[0xc],r8
800076da:	3f f8       	mov	r8,-1
800076dc:	ba 78       	st.h	sp[0xe],r8
800076de:	e0 68 0a 38 	mov	r8,2616
800076e2:	50 4c       	stdsp	sp[0x10],r12
800076e4:	16 9a       	mov	r10,r11
800076e6:	50 0c       	stdsp	sp[0x0],r12
800076e8:	fa c9 ff a0 	sub	r9,sp,-96
800076ec:	70 0c       	ld.w	r12,r8[0x0]
800076ee:	1a 9b       	mov	r11,sp
800076f0:	e0 a0 02 1a 	rcall	80007b24 <_vfprintf_r>
800076f4:	30 09       	mov	r9,0
800076f6:	40 08       	lddsp	r8,sp[0x0]
800076f8:	b0 89       	st.b	r8[0x0],r9
800076fa:	2e 9d       	sub	sp,-92
800076fc:	d8 02       	popm	pc
800076fe:	d7 03       	nop

80007700 <strncpy>:
80007700:	30 08       	mov	r8,0
80007702:	10 3a       	cp.w	r10,r8
80007704:	5e 0c       	reteq	r12
80007706:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000770a:	f8 08 0b 09 	st.b	r12[r8],r9
8000770e:	2f f8       	sub	r8,-1
80007710:	58 09       	cp.w	r9,0
80007712:	cf 81       	brne	80007702 <strncpy+0x2>
80007714:	10 3a       	cp.w	r10,r8
80007716:	5e 0c       	reteq	r12
80007718:	f8 08 0b 09 	st.b	r12[r8],r9
8000771c:	2f f8       	sub	r8,-1
8000771e:	cf bb       	rjmp	80007714 <strncpy+0x14>

80007720 <_close>:
80007720:	30 28       	mov	r8,2
80007722:	d6 73       	breakpoint
80007724:	3f fc       	mov	r12,-1
80007726:	35 8b       	mov	r11,88
80007728:	58 0c       	cp.w	r12,0
8000772a:	5e 4c       	retge	r12
8000772c:	e0 6a 51 1c 	mov	r10,20764
80007730:	95 0b       	st.w	r10[0x0],r11
80007732:	5e fc       	retal	r12

80007734 <_lseek>:
80007734:	30 58       	mov	r8,5
80007736:	d6 73       	breakpoint
80007738:	3f fc       	mov	r12,-1
8000773a:	35 8b       	mov	r11,88
8000773c:	58 0c       	cp.w	r12,0
8000773e:	5e 4c       	retge	r12
80007740:	e0 6a 51 1c 	mov	r10,20764
80007744:	95 0b       	st.w	r10[0x0],r11
80007746:	5e fc       	retal	r12

80007748 <isatty>:
80007748:	30 b8       	mov	r8,11
8000774a:	d6 73       	breakpoint
8000774c:	3f fc       	mov	r12,-1
8000774e:	35 8b       	mov	r11,88
80007750:	58 0c       	cp.w	r12,0
80007752:	5e 4c       	retge	r12
80007754:	e0 6a 51 1c 	mov	r10,20764
80007758:	95 0b       	st.w	r10[0x0],r11
8000775a:	5e fc       	retal	r12

8000775c <_fstat_host>:
8000775c:	30 98       	mov	r8,9
8000775e:	d6 73       	breakpoint
80007760:	3f fc       	mov	r12,-1
80007762:	35 8b       	mov	r11,88
80007764:	58 0c       	cp.w	r12,0
80007766:	5e 4c       	retge	r12
80007768:	e0 6a 51 1c 	mov	r10,20764
8000776c:	95 0b       	st.w	r10[0x0],r11
8000776e:	5e fc       	retal	r12

80007770 <_fstat>:
80007770:	d4 21       	pushm	r4-r7,lr
80007772:	21 0d       	sub	sp,64
80007774:	16 97       	mov	r7,r11
80007776:	1a 9b       	mov	r11,sp
80007778:	cf 2f       	rcall	8000775c <_fstat_host>
8000777a:	c0 34       	brge	80007780 <_fstat+0x10>
8000777c:	3f fc       	mov	r12,-1
8000777e:	c1 c8       	rjmp	800077b6 <_fstat+0x46>
80007780:	40 08       	lddsp	r8,sp[0x0]
80007782:	ae 08       	st.h	r7[0x0],r8
80007784:	40 18       	lddsp	r8,sp[0x4]
80007786:	ae 18       	st.h	r7[0x2],r8
80007788:	40 28       	lddsp	r8,sp[0x8]
8000778a:	8f 18       	st.w	r7[0x4],r8
8000778c:	40 38       	lddsp	r8,sp[0xc]
8000778e:	ae 48       	st.h	r7[0x8],r8
80007790:	40 48       	lddsp	r8,sp[0x10]
80007792:	ae 58       	st.h	r7[0xa],r8
80007794:	40 58       	lddsp	r8,sp[0x14]
80007796:	ae 68       	st.h	r7[0xc],r8
80007798:	40 68       	lddsp	r8,sp[0x18]
8000779a:	ae 78       	st.h	r7[0xe],r8
8000779c:	40 88       	lddsp	r8,sp[0x20]
8000779e:	8f 48       	st.w	r7[0x10],r8
800077a0:	40 a8       	lddsp	r8,sp[0x28]
800077a2:	8f b8       	st.w	r7[0x2c],r8
800077a4:	40 c8       	lddsp	r8,sp[0x30]
800077a6:	8f c8       	st.w	r7[0x30],r8
800077a8:	40 d8       	lddsp	r8,sp[0x34]
800077aa:	8f 58       	st.w	r7[0x14],r8
800077ac:	40 e8       	lddsp	r8,sp[0x38]
800077ae:	30 0c       	mov	r12,0
800077b0:	8f 78       	st.w	r7[0x1c],r8
800077b2:	40 f8       	lddsp	r8,sp[0x3c]
800077b4:	8f 98       	st.w	r7[0x24],r8
800077b6:	2f 0d       	sub	sp,-64
800077b8:	d8 22       	popm	r4-r7,pc
800077ba:	d7 03       	nop

800077bc <_sbrk>:
800077bc:	d4 01       	pushm	lr
800077be:	e0 68 0d 78 	mov	r8,3448
800077c2:	70 09       	ld.w	r9,r8[0x0]
800077c4:	58 09       	cp.w	r9,0
800077c6:	c0 41       	brne	800077ce <_sbrk+0x12>
800077c8:	e0 69 51 20 	mov	r9,20768
800077cc:	91 09       	st.w	r8[0x0],r9
800077ce:	e0 69 0d 78 	mov	r9,3448
800077d2:	e0 7a 70 00 	mov	r10,94208
800077d6:	72 08       	ld.w	r8,r9[0x0]
800077d8:	f0 0c 00 0c 	add	r12,r8,r12
800077dc:	14 3c       	cp.w	r12,r10
800077de:	e0 8b 00 04 	brhi	800077e6 <_sbrk+0x2a>
800077e2:	93 0c       	st.w	r9[0x0],r12
800077e4:	c0 68       	rjmp	800077f0 <_sbrk+0x34>
800077e6:	e0 a0 18 15 	rcall	8000a810 <__errno>
800077ea:	30 c8       	mov	r8,12
800077ec:	99 08       	st.w	r12[0x0],r8
800077ee:	3f f8       	mov	r8,-1
800077f0:	10 9c       	mov	r12,r8
800077f2:	d8 02       	popm	pc

800077f4 <get_arg>:
800077f4:	d4 31       	pushm	r0-r7,lr
800077f6:	20 8d       	sub	sp,32
800077f8:	fa c4 ff bc 	sub	r4,sp,-68
800077fc:	50 4b       	stdsp	sp[0x10],r11
800077fe:	68 2e       	ld.w	lr,r4[0x8]
80007800:	50 58       	stdsp	sp[0x14],r8
80007802:	12 96       	mov	r6,r9
80007804:	7c 0b       	ld.w	r11,lr[0x0]
80007806:	70 05       	ld.w	r5,r8[0x0]
80007808:	50 6e       	stdsp	sp[0x18],lr
8000780a:	58 0b       	cp.w	r11,0
8000780c:	f4 0b 17 00 	moveq	r11,r10
80007810:	68 03       	ld.w	r3,r4[0x0]
80007812:	68 11       	ld.w	r1,r4[0x4]
80007814:	40 49       	lddsp	r9,sp[0x10]
80007816:	30 08       	mov	r8,0
80007818:	c2 89       	rjmp	80007a68 <get_arg+0x274>
8000781a:	2f fb       	sub	r11,-1
8000781c:	32 5c       	mov	r12,37
8000781e:	17 8a       	ld.ub	r10,r11[0x0]
80007820:	f8 0a 18 00 	cp.b	r10,r12
80007824:	5f 1e       	srne	lr
80007826:	f0 0a 18 00 	cp.b	r10,r8
8000782a:	5f 1c       	srne	r12
8000782c:	fd ec 00 0c 	and	r12,lr,r12
80007830:	f0 0c 18 00 	cp.b	r12,r8
80007834:	cf 31       	brne	8000781a <get_arg+0x26>
80007836:	58 0a       	cp.w	r10,0
80007838:	e0 80 01 25 	breq	80007a82 <get_arg+0x28e>
8000783c:	30 0c       	mov	r12,0
8000783e:	3f fa       	mov	r10,-1
80007840:	18 90       	mov	r0,r12
80007842:	50 3a       	stdsp	sp[0xc],r10
80007844:	18 94       	mov	r4,r12
80007846:	18 92       	mov	r2,r12
80007848:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000784c:	16 97       	mov	r7,r11
8000784e:	50 7c       	stdsp	sp[0x1c],r12
80007850:	fe cc 9f ac 	sub	r12,pc,-24660
80007854:	0f 3a       	ld.ub	r10,r7++
80007856:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000785a:	40 7c       	lddsp	r12,sp[0x1c]
8000785c:	1c 0c       	add	r12,lr
8000785e:	fe ce a0 82 	sub	lr,pc,-24446
80007862:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007866:	20 1e       	sub	lr,1
80007868:	50 0e       	stdsp	sp[0x0],lr
8000786a:	fe ce a0 fa 	sub	lr,pc,-24326
8000786e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007872:	50 7c       	stdsp	sp[0x1c],r12
80007874:	40 0c       	lddsp	r12,sp[0x0]
80007876:	58 7c       	cp.w	r12,7
80007878:	e0 8b 00 f1 	brhi	80007a5a <get_arg+0x266>
8000787c:	fe ce a2 ac 	sub	lr,pc,-23892
80007880:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007884:	36 8b       	mov	r11,104
80007886:	f6 0a 18 00 	cp.b	r10,r11
8000788a:	e0 80 00 e8 	breq	80007a5a <get_arg+0x266>
8000788e:	37 1b       	mov	r11,113
80007890:	f6 0a 18 00 	cp.b	r10,r11
80007894:	c0 70       	breq	800078a2 <get_arg+0xae>
80007896:	34 cb       	mov	r11,76
80007898:	f6 0a 18 00 	cp.b	r10,r11
8000789c:	c0 51       	brne	800078a6 <get_arg+0xb2>
8000789e:	a3 b4       	sbr	r4,0x3
800078a0:	cd d8       	rjmp	80007a5a <get_arg+0x266>
800078a2:	a5 b4       	sbr	r4,0x5
800078a4:	cd b8       	rjmp	80007a5a <get_arg+0x266>
800078a6:	08 9a       	mov	r10,r4
800078a8:	0e 9b       	mov	r11,r7
800078aa:	a5 aa       	sbr	r10,0x4
800078ac:	17 3c       	ld.ub	r12,r11++
800078ae:	a5 b4       	sbr	r4,0x5
800078b0:	36 ce       	mov	lr,108
800078b2:	fc 0c 18 00 	cp.b	r12,lr
800078b6:	e0 80 00 d3 	breq	80007a5c <get_arg+0x268>
800078ba:	14 94       	mov	r4,r10
800078bc:	cc f8       	rjmp	80007a5a <get_arg+0x266>
800078be:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800078c2:	36 7c       	mov	r12,103
800078c4:	f8 0a 18 00 	cp.b	r10,r12
800078c8:	e0 8b 00 27 	brhi	80007916 <get_arg+0x122>
800078cc:	36 5b       	mov	r11,101
800078ce:	f6 0a 18 00 	cp.b	r10,r11
800078d2:	c4 82       	brcc	80007962 <get_arg+0x16e>
800078d4:	34 fb       	mov	r11,79
800078d6:	f6 0a 18 00 	cp.b	r10,r11
800078da:	c4 80       	breq	8000796a <get_arg+0x176>
800078dc:	e0 8b 00 0c 	brhi	800078f4 <get_arg+0x100>
800078e0:	34 5b       	mov	r11,69
800078e2:	f6 0a 18 00 	cp.b	r10,r11
800078e6:	c3 e0       	breq	80007962 <get_arg+0x16e>
800078e8:	34 7b       	mov	r11,71
800078ea:	f6 0a 18 00 	cp.b	r10,r11
800078ee:	c3 a0       	breq	80007962 <get_arg+0x16e>
800078f0:	34 4b       	mov	r11,68
800078f2:	c0 88       	rjmp	80007902 <get_arg+0x10e>
800078f4:	35 8b       	mov	r11,88
800078f6:	f6 0a 18 00 	cp.b	r10,r11
800078fa:	c2 c0       	breq	80007952 <get_arg+0x15e>
800078fc:	e0 8b 00 07 	brhi	8000790a <get_arg+0x116>
80007900:	35 5b       	mov	r11,85
80007902:	f6 0a 18 00 	cp.b	r10,r11
80007906:	c3 51       	brne	80007970 <get_arg+0x17c>
80007908:	c3 18       	rjmp	8000796a <get_arg+0x176>
8000790a:	36 3b       	mov	r11,99
8000790c:	f6 0a 18 00 	cp.b	r10,r11
80007910:	c2 f0       	breq	8000796e <get_arg+0x17a>
80007912:	36 4b       	mov	r11,100
80007914:	c0 e8       	rjmp	80007930 <get_arg+0x13c>
80007916:	37 0b       	mov	r11,112
80007918:	f6 0a 18 00 	cp.b	r10,r11
8000791c:	c2 50       	breq	80007966 <get_arg+0x172>
8000791e:	e0 8b 00 0d 	brhi	80007938 <get_arg+0x144>
80007922:	36 eb       	mov	r11,110
80007924:	f6 0a 18 00 	cp.b	r10,r11
80007928:	c1 f0       	breq	80007966 <get_arg+0x172>
8000792a:	e0 8b 00 14 	brhi	80007952 <get_arg+0x15e>
8000792e:	36 9b       	mov	r11,105
80007930:	f6 0a 18 00 	cp.b	r10,r11
80007934:	c1 e1       	brne	80007970 <get_arg+0x17c>
80007936:	c0 e8       	rjmp	80007952 <get_arg+0x15e>
80007938:	37 5b       	mov	r11,117
8000793a:	f6 0a 18 00 	cp.b	r10,r11
8000793e:	c0 a0       	breq	80007952 <get_arg+0x15e>
80007940:	37 8b       	mov	r11,120
80007942:	f6 0a 18 00 	cp.b	r10,r11
80007946:	c0 60       	breq	80007952 <get_arg+0x15e>
80007948:	37 3b       	mov	r11,115
8000794a:	f6 0a 18 00 	cp.b	r10,r11
8000794e:	c1 11       	brne	80007970 <get_arg+0x17c>
80007950:	c0 b8       	rjmp	80007966 <get_arg+0x172>
80007952:	ed b4 00 04 	bld	r4,0x4
80007956:	c0 a0       	breq	8000796a <get_arg+0x176>
80007958:	ed b4 00 05 	bld	r4,0x5
8000795c:	c0 91       	brne	8000796e <get_arg+0x17a>
8000795e:	30 20       	mov	r0,2
80007960:	c0 88       	rjmp	80007970 <get_arg+0x17c>
80007962:	30 40       	mov	r0,4
80007964:	c0 68       	rjmp	80007970 <get_arg+0x17c>
80007966:	30 30       	mov	r0,3
80007968:	c0 48       	rjmp	80007970 <get_arg+0x17c>
8000796a:	30 10       	mov	r0,1
8000796c:	c0 28       	rjmp	80007970 <get_arg+0x17c>
8000796e:	30 00       	mov	r0,0
80007970:	40 3b       	lddsp	r11,sp[0xc]
80007972:	5b fb       	cp.w	r11,-1
80007974:	c0 40       	breq	8000797c <get_arg+0x188>
80007976:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000797a:	c7 08       	rjmp	80007a5a <get_arg+0x266>
8000797c:	58 60       	cp.w	r0,6
8000797e:	e0 8b 00 6e 	brhi	80007a5a <get_arg+0x266>
80007982:	6c 0a       	ld.w	r10,r6[0x0]
80007984:	ea cc ff ff 	sub	r12,r5,-1
80007988:	fe ce a3 98 	sub	lr,pc,-23656
8000798c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007990:	f4 cb ff f8 	sub	r11,r10,-8
80007994:	8d 0b       	st.w	r6[0x0],r11
80007996:	f4 ea 00 00 	ld.d	r10,r10[0]
8000799a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000799e:	c0 f8       	rjmp	800079bc <get_arg+0x1c8>
800079a0:	f4 cb ff fc 	sub	r11,r10,-4
800079a4:	8d 0b       	st.w	r6[0x0],r11
800079a6:	74 0a       	ld.w	r10,r10[0x0]
800079a8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800079ac:	c0 88       	rjmp	800079bc <get_arg+0x1c8>
800079ae:	f4 cb ff f8 	sub	r11,r10,-8
800079b2:	8d 0b       	st.w	r6[0x0],r11
800079b4:	f4 ea 00 00 	ld.d	r10,r10[0]
800079b8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800079bc:	0e 9b       	mov	r11,r7
800079be:	18 95       	mov	r5,r12
800079c0:	c4 e8       	rjmp	80007a5c <get_arg+0x268>
800079c2:	62 0a       	ld.w	r10,r1[0x0]
800079c4:	5b fa       	cp.w	r10,-1
800079c6:	c0 b1       	brne	800079dc <get_arg+0x1e8>
800079c8:	50 19       	stdsp	sp[0x4],r9
800079ca:	50 28       	stdsp	sp[0x8],r8
800079cc:	e0 6a 00 80 	mov	r10,128
800079d0:	30 0b       	mov	r11,0
800079d2:	02 9c       	mov	r12,r1
800079d4:	fe b0 fd 00 	rcall	800073d4 <memset>
800079d8:	40 28       	lddsp	r8,sp[0x8]
800079da:	40 19       	lddsp	r9,sp[0x4]
800079dc:	e4 cc 00 01 	sub	r12,r2,1
800079e0:	0e 9b       	mov	r11,r7
800079e2:	50 3c       	stdsp	sp[0xc],r12
800079e4:	f2 0c 0c 49 	max	r9,r9,r12
800079e8:	c3 a8       	rjmp	80007a5c <get_arg+0x268>
800079ea:	62 0a       	ld.w	r10,r1[0x0]
800079ec:	5b fa       	cp.w	r10,-1
800079ee:	c0 b1       	brne	80007a04 <get_arg+0x210>
800079f0:	50 19       	stdsp	sp[0x4],r9
800079f2:	50 28       	stdsp	sp[0x8],r8
800079f4:	e0 6a 00 80 	mov	r10,128
800079f8:	30 0b       	mov	r11,0
800079fa:	02 9c       	mov	r12,r1
800079fc:	fe b0 fc ec 	rcall	800073d4 <memset>
80007a00:	40 28       	lddsp	r8,sp[0x8]
80007a02:	40 19       	lddsp	r9,sp[0x4]
80007a04:	20 12       	sub	r2,1
80007a06:	30 0a       	mov	r10,0
80007a08:	0e 9b       	mov	r11,r7
80007a0a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007a0e:	f2 02 0c 49 	max	r9,r9,r2
80007a12:	c2 58       	rjmp	80007a5c <get_arg+0x268>
80007a14:	16 97       	mov	r7,r11
80007a16:	6c 0a       	ld.w	r10,r6[0x0]
80007a18:	f4 cb ff fc 	sub	r11,r10,-4
80007a1c:	8d 0b       	st.w	r6[0x0],r11
80007a1e:	74 0a       	ld.w	r10,r10[0x0]
80007a20:	0e 9b       	mov	r11,r7
80007a22:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a26:	2f f5       	sub	r5,-1
80007a28:	c1 a8       	rjmp	80007a5c <get_arg+0x268>
80007a2a:	f4 c2 00 30 	sub	r2,r10,48
80007a2e:	c0 68       	rjmp	80007a3a <get_arg+0x246>
80007a30:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007a34:	2f f7       	sub	r7,-1
80007a36:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007a3a:	0f 8a       	ld.ub	r10,r7[0x0]
80007a3c:	58 0a       	cp.w	r10,0
80007a3e:	c0 e0       	breq	80007a5a <get_arg+0x266>
80007a40:	23 0a       	sub	r10,48
80007a42:	58 9a       	cp.w	r10,9
80007a44:	fe 98 ff f6 	brls	80007a30 <get_arg+0x23c>
80007a48:	c0 98       	rjmp	80007a5a <get_arg+0x266>
80007a4a:	2f f7       	sub	r7,-1
80007a4c:	0f 8a       	ld.ub	r10,r7[0x0]
80007a4e:	58 0a       	cp.w	r10,0
80007a50:	c0 50       	breq	80007a5a <get_arg+0x266>
80007a52:	23 0a       	sub	r10,48
80007a54:	58 9a       	cp.w	r10,9
80007a56:	fe 98 ff fa 	brls	80007a4a <get_arg+0x256>
80007a5a:	0e 9b       	mov	r11,r7
80007a5c:	40 7c       	lddsp	r12,sp[0x1c]
80007a5e:	30 ba       	mov	r10,11
80007a60:	f4 0c 18 00 	cp.b	r12,r10
80007a64:	fe 91 fe f2 	brne	80007848 <get_arg+0x54>
80007a68:	40 42       	lddsp	r2,sp[0x10]
80007a6a:	17 8c       	ld.ub	r12,r11[0x0]
80007a6c:	0a 32       	cp.w	r2,r5
80007a6e:	5f 4a       	srge	r10
80007a70:	f0 0c 18 00 	cp.b	r12,r8
80007a74:	5f 1c       	srne	r12
80007a76:	f9 ea 00 0a 	and	r10,r12,r10
80007a7a:	f0 0a 18 00 	cp.b	r10,r8
80007a7e:	fe 91 fe cf 	brne	8000781c <get_arg+0x28>
80007a82:	30 08       	mov	r8,0
80007a84:	40 4e       	lddsp	lr,sp[0x10]
80007a86:	17 8a       	ld.ub	r10,r11[0x0]
80007a88:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007a8c:	f0 0a 18 00 	cp.b	r10,r8
80007a90:	fc 09 17 10 	movne	r9,lr
80007a94:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007a98:	06 9e       	mov	lr,r3
80007a9a:	c2 a8       	rjmp	80007aee <get_arg+0x2fa>
80007a9c:	62 0a       	ld.w	r10,r1[0x0]
80007a9e:	58 3a       	cp.w	r10,3
80007aa0:	c1 e0       	breq	80007adc <get_arg+0x2e8>
80007aa2:	e0 89 00 07 	brgt	80007ab0 <get_arg+0x2bc>
80007aa6:	58 1a       	cp.w	r10,1
80007aa8:	c1 a0       	breq	80007adc <get_arg+0x2e8>
80007aaa:	58 2a       	cp.w	r10,2
80007aac:	c1 81       	brne	80007adc <get_arg+0x2e8>
80007aae:	c0 58       	rjmp	80007ab8 <get_arg+0x2c4>
80007ab0:	58 5a       	cp.w	r10,5
80007ab2:	c0 c0       	breq	80007aca <get_arg+0x2d6>
80007ab4:	c0 b5       	brlt	80007aca <get_arg+0x2d6>
80007ab6:	c1 38       	rjmp	80007adc <get_arg+0x2e8>
80007ab8:	6c 0a       	ld.w	r10,r6[0x0]
80007aba:	f4 cc ff f8 	sub	r12,r10,-8
80007abe:	8d 0c       	st.w	r6[0x0],r12
80007ac0:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ac4:	f0 e3 00 00 	st.d	r8[0],r2
80007ac8:	c1 08       	rjmp	80007ae8 <get_arg+0x2f4>
80007aca:	6c 0a       	ld.w	r10,r6[0x0]
80007acc:	f4 cc ff f8 	sub	r12,r10,-8
80007ad0:	8d 0c       	st.w	r6[0x0],r12
80007ad2:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ad6:	f0 e3 00 00 	st.d	r8[0],r2
80007ada:	c0 78       	rjmp	80007ae8 <get_arg+0x2f4>
80007adc:	6c 0a       	ld.w	r10,r6[0x0]
80007ade:	f4 cc ff fc 	sub	r12,r10,-4
80007ae2:	8d 0c       	st.w	r6[0x0],r12
80007ae4:	74 0a       	ld.w	r10,r10[0x0]
80007ae6:	91 0a       	st.w	r8[0x0],r10
80007ae8:	2f f5       	sub	r5,-1
80007aea:	2f 88       	sub	r8,-8
80007aec:	2f c1       	sub	r1,-4
80007aee:	12 35       	cp.w	r5,r9
80007af0:	fe 9a ff d6 	brle	80007a9c <get_arg+0x2a8>
80007af4:	1c 93       	mov	r3,lr
80007af6:	40 52       	lddsp	r2,sp[0x14]
80007af8:	40 6e       	lddsp	lr,sp[0x18]
80007afa:	85 05       	st.w	r2[0x0],r5
80007afc:	9d 0b       	st.w	lr[0x0],r11
80007afe:	40 4b       	lddsp	r11,sp[0x10]
80007b00:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007b04:	2f 8d       	sub	sp,-32
80007b06:	d8 32       	popm	r0-r7,pc

80007b08 <__sprint_r>:
80007b08:	d4 21       	pushm	r4-r7,lr
80007b0a:	14 97       	mov	r7,r10
80007b0c:	74 28       	ld.w	r8,r10[0x8]
80007b0e:	58 08       	cp.w	r8,0
80007b10:	c0 41       	brne	80007b18 <__sprint_r+0x10>
80007b12:	95 18       	st.w	r10[0x4],r8
80007b14:	10 9c       	mov	r12,r8
80007b16:	d8 22       	popm	r4-r7,pc
80007b18:	e0 a0 18 ba 	rcall	8000ac8c <__sfvwrite_r>
80007b1c:	30 08       	mov	r8,0
80007b1e:	8f 18       	st.w	r7[0x4],r8
80007b20:	8f 28       	st.w	r7[0x8],r8
80007b22:	d8 22       	popm	r4-r7,pc

80007b24 <_vfprintf_r>:
80007b24:	d4 31       	pushm	r0-r7,lr
80007b26:	fa cd 06 bc 	sub	sp,sp,1724
80007b2a:	51 09       	stdsp	sp[0x40],r9
80007b2c:	16 91       	mov	r1,r11
80007b2e:	14 97       	mov	r7,r10
80007b30:	18 95       	mov	r5,r12
80007b32:	e0 a0 1a 1d 	rcall	8000af6c <_localeconv_r>
80007b36:	78 0c       	ld.w	r12,r12[0x0]
80007b38:	50 cc       	stdsp	sp[0x30],r12
80007b3a:	58 05       	cp.w	r5,0
80007b3c:	c0 70       	breq	80007b4a <_vfprintf_r+0x26>
80007b3e:	6a 68       	ld.w	r8,r5[0x18]
80007b40:	58 08       	cp.w	r8,0
80007b42:	c0 41       	brne	80007b4a <_vfprintf_r+0x26>
80007b44:	0a 9c       	mov	r12,r5
80007b46:	e0 a0 17 43 	rcall	8000a9cc <__sinit>
80007b4a:	fe c8 a1 96 	sub	r8,pc,-24170
80007b4e:	10 31       	cp.w	r1,r8
80007b50:	c0 31       	brne	80007b56 <_vfprintf_r+0x32>
80007b52:	6a 01       	ld.w	r1,r5[0x0]
80007b54:	c0 c8       	rjmp	80007b6c <_vfprintf_r+0x48>
80007b56:	fe c8 a1 82 	sub	r8,pc,-24190
80007b5a:	10 31       	cp.w	r1,r8
80007b5c:	c0 31       	brne	80007b62 <_vfprintf_r+0x3e>
80007b5e:	6a 11       	ld.w	r1,r5[0x4]
80007b60:	c0 68       	rjmp	80007b6c <_vfprintf_r+0x48>
80007b62:	fe c8 a1 6e 	sub	r8,pc,-24210
80007b66:	10 31       	cp.w	r1,r8
80007b68:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007b6c:	82 68       	ld.sh	r8,r1[0xc]
80007b6e:	ed b8 00 03 	bld	r8,0x3
80007b72:	c0 41       	brne	80007b7a <_vfprintf_r+0x56>
80007b74:	62 48       	ld.w	r8,r1[0x10]
80007b76:	58 08       	cp.w	r8,0
80007b78:	c0 71       	brne	80007b86 <_vfprintf_r+0x62>
80007b7a:	02 9b       	mov	r11,r1
80007b7c:	0a 9c       	mov	r12,r5
80007b7e:	e0 a0 0f 5d 	rcall	80009a38 <__swsetup_r>
80007b82:	e0 81 0f 54 	brne	80009a2a <_vfprintf_r+0x1f06>
80007b86:	82 68       	ld.sh	r8,r1[0xc]
80007b88:	10 99       	mov	r9,r8
80007b8a:	e2 19 00 1a 	andl	r9,0x1a,COH
80007b8e:	58 a9       	cp.w	r9,10
80007b90:	c3 c1       	brne	80007c08 <_vfprintf_r+0xe4>
80007b92:	82 79       	ld.sh	r9,r1[0xe]
80007b94:	30 0a       	mov	r10,0
80007b96:	f4 09 19 00 	cp.h	r9,r10
80007b9a:	c3 75       	brlt	80007c08 <_vfprintf_r+0xe4>
80007b9c:	a1 d8       	cbr	r8,0x1
80007b9e:	fb 58 05 d0 	st.h	sp[1488],r8
80007ba2:	62 88       	ld.w	r8,r1[0x20]
80007ba4:	fb 48 05 e4 	st.w	sp[1508],r8
80007ba8:	62 a8       	ld.w	r8,r1[0x28]
80007baa:	fb 48 05 ec 	st.w	sp[1516],r8
80007bae:	fa c8 ff bc 	sub	r8,sp,-68
80007bb2:	fb 48 05 d4 	st.w	sp[1492],r8
80007bb6:	fb 48 05 c4 	st.w	sp[1476],r8
80007bba:	e0 68 04 00 	mov	r8,1024
80007bbe:	fb 48 05 d8 	st.w	sp[1496],r8
80007bc2:	fb 48 05 cc 	st.w	sp[1484],r8
80007bc6:	30 08       	mov	r8,0
80007bc8:	fb 59 05 d2 	st.h	sp[1490],r9
80007bcc:	0e 9a       	mov	r10,r7
80007bce:	41 09       	lddsp	r9,sp[0x40]
80007bd0:	fa c7 fa 3c 	sub	r7,sp,-1476
80007bd4:	fb 48 05 dc 	st.w	sp[1500],r8
80007bd8:	0a 9c       	mov	r12,r5
80007bda:	0e 9b       	mov	r11,r7
80007bdc:	ca 4f       	rcall	80007b24 <_vfprintf_r>
80007bde:	50 bc       	stdsp	sp[0x2c],r12
80007be0:	c0 95       	brlt	80007bf2 <_vfprintf_r+0xce>
80007be2:	0e 9b       	mov	r11,r7
80007be4:	0a 9c       	mov	r12,r5
80007be6:	e0 a0 16 1b 	rcall	8000a81c <_fflush_r>
80007bea:	40 be       	lddsp	lr,sp[0x2c]
80007bec:	f9 be 01 ff 	movne	lr,-1
80007bf0:	50 be       	stdsp	sp[0x2c],lr
80007bf2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007bf6:	ed b8 00 06 	bld	r8,0x6
80007bfa:	e0 81 0f 1a 	brne	80009a2e <_vfprintf_r+0x1f0a>
80007bfe:	82 68       	ld.sh	r8,r1[0xc]
80007c00:	a7 a8       	sbr	r8,0x6
80007c02:	a2 68       	st.h	r1[0xc],r8
80007c04:	e0 8f 0f 15 	bral	80009a2e <_vfprintf_r+0x1f0a>
80007c08:	30 08       	mov	r8,0
80007c0a:	fb 48 06 b4 	st.w	sp[1716],r8
80007c0e:	fb 48 06 90 	st.w	sp[1680],r8
80007c12:	fb 48 06 8c 	st.w	sp[1676],r8
80007c16:	fb 48 06 b0 	st.w	sp[1712],r8
80007c1a:	30 08       	mov	r8,0
80007c1c:	30 09       	mov	r9,0
80007c1e:	50 a7       	stdsp	sp[0x28],r7
80007c20:	50 78       	stdsp	sp[0x1c],r8
80007c22:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c26:	3f f8       	mov	r8,-1
80007c28:	50 59       	stdsp	sp[0x14],r9
80007c2a:	fb 43 06 88 	st.w	sp[1672],r3
80007c2e:	fb 48 05 44 	st.w	sp[1348],r8
80007c32:	12 9c       	mov	r12,r9
80007c34:	50 69       	stdsp	sp[0x18],r9
80007c36:	50 d9       	stdsp	sp[0x34],r9
80007c38:	50 e9       	stdsp	sp[0x38],r9
80007c3a:	50 b9       	stdsp	sp[0x2c],r9
80007c3c:	12 97       	mov	r7,r9
80007c3e:	0a 94       	mov	r4,r5
80007c40:	40 a2       	lddsp	r2,sp[0x28]
80007c42:	32 5a       	mov	r10,37
80007c44:	30 08       	mov	r8,0
80007c46:	c0 28       	rjmp	80007c4a <_vfprintf_r+0x126>
80007c48:	2f f2       	sub	r2,-1
80007c4a:	05 89       	ld.ub	r9,r2[0x0]
80007c4c:	f0 09 18 00 	cp.b	r9,r8
80007c50:	5f 1b       	srne	r11
80007c52:	f4 09 18 00 	cp.b	r9,r10
80007c56:	5f 19       	srne	r9
80007c58:	f3 eb 00 0b 	and	r11,r9,r11
80007c5c:	f0 0b 18 00 	cp.b	r11,r8
80007c60:	cf 41       	brne	80007c48 <_vfprintf_r+0x124>
80007c62:	40 ab       	lddsp	r11,sp[0x28]
80007c64:	e4 0b 01 06 	sub	r6,r2,r11
80007c68:	c1 e0       	breq	80007ca4 <_vfprintf_r+0x180>
80007c6a:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c6e:	0c 08       	add	r8,r6
80007c70:	87 0b       	st.w	r3[0x0],r11
80007c72:	fb 48 06 90 	st.w	sp[1680],r8
80007c76:	87 16       	st.w	r3[0x4],r6
80007c78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c7c:	2f f8       	sub	r8,-1
80007c7e:	fb 48 06 8c 	st.w	sp[1676],r8
80007c82:	58 78       	cp.w	r8,7
80007c84:	e0 89 00 04 	brgt	80007c8c <_vfprintf_r+0x168>
80007c88:	2f 83       	sub	r3,-8
80007c8a:	c0 a8       	rjmp	80007c9e <_vfprintf_r+0x17a>
80007c8c:	fa ca f9 78 	sub	r10,sp,-1672
80007c90:	02 9b       	mov	r11,r1
80007c92:	08 9c       	mov	r12,r4
80007c94:	c3 af       	rcall	80007b08 <__sprint_r>
80007c96:	e0 81 0e c6 	brne	80009a22 <_vfprintf_r+0x1efe>
80007c9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c9e:	40 ba       	lddsp	r10,sp[0x2c]
80007ca0:	0c 0a       	add	r10,r6
80007ca2:	50 ba       	stdsp	sp[0x2c],r10
80007ca4:	05 89       	ld.ub	r9,r2[0x0]
80007ca6:	30 08       	mov	r8,0
80007ca8:	f0 09 18 00 	cp.b	r9,r8
80007cac:	e0 80 0e aa 	breq	80009a00 <_vfprintf_r+0x1edc>
80007cb0:	30 09       	mov	r9,0
80007cb2:	fb 68 06 bb 	st.b	sp[1723],r8
80007cb6:	0e 96       	mov	r6,r7
80007cb8:	e4 c8 ff ff 	sub	r8,r2,-1
80007cbc:	3f fe       	mov	lr,-1
80007cbe:	50 93       	stdsp	sp[0x24],r3
80007cc0:	50 41       	stdsp	sp[0x10],r1
80007cc2:	0e 93       	mov	r3,r7
80007cc4:	04 91       	mov	r1,r2
80007cc6:	50 89       	stdsp	sp[0x20],r9
80007cc8:	50 a8       	stdsp	sp[0x28],r8
80007cca:	50 2e       	stdsp	sp[0x8],lr
80007ccc:	50 39       	stdsp	sp[0xc],r9
80007cce:	12 95       	mov	r5,r9
80007cd0:	12 90       	mov	r0,r9
80007cd2:	10 97       	mov	r7,r8
80007cd4:	08 92       	mov	r2,r4
80007cd6:	c0 78       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007cd8:	3f fc       	mov	r12,-1
80007cda:	08 97       	mov	r7,r4
80007cdc:	50 2c       	stdsp	sp[0x8],r12
80007cde:	c0 38       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007ce0:	30 0b       	mov	r11,0
80007ce2:	50 3b       	stdsp	sp[0xc],r11
80007ce4:	0f 38       	ld.ub	r8,r7++
80007ce6:	c0 28       	rjmp	80007cea <_vfprintf_r+0x1c6>
80007ce8:	12 90       	mov	r0,r9
80007cea:	f0 c9 00 20 	sub	r9,r8,32
80007cee:	e0 49 00 58 	cp.w	r9,88
80007cf2:	e0 8b 0a 30 	brhi	80009152 <_vfprintf_r+0x162e>
80007cf6:	fe ca a6 ea 	sub	r10,pc,-22806
80007cfa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007cfe:	50 a7       	stdsp	sp[0x28],r7
80007d00:	50 80       	stdsp	sp[0x20],r0
80007d02:	0c 97       	mov	r7,r6
80007d04:	04 94       	mov	r4,r2
80007d06:	06 96       	mov	r6,r3
80007d08:	02 92       	mov	r2,r1
80007d0a:	fe c9 a4 c2 	sub	r9,pc,-23358
80007d0e:	40 93       	lddsp	r3,sp[0x24]
80007d10:	10 90       	mov	r0,r8
80007d12:	40 41       	lddsp	r1,sp[0x10]
80007d14:	50 d9       	stdsp	sp[0x34],r9
80007d16:	e0 8f 08 8e 	bral	80008e32 <_vfprintf_r+0x130e>
80007d1a:	30 08       	mov	r8,0
80007d1c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007d20:	f0 09 18 00 	cp.b	r9,r8
80007d24:	ce 01       	brne	80007ce4 <_vfprintf_r+0x1c0>
80007d26:	32 08       	mov	r8,32
80007d28:	c6 e8       	rjmp	80007e04 <_vfprintf_r+0x2e0>
80007d2a:	a1 a5       	sbr	r5,0x0
80007d2c:	cd cb       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007d2e:	0f 89       	ld.ub	r9,r7[0x0]
80007d30:	f2 c8 00 30 	sub	r8,r9,48
80007d34:	58 98       	cp.w	r8,9
80007d36:	e0 8b 00 1d 	brhi	80007d70 <_vfprintf_r+0x24c>
80007d3a:	ee c8 ff ff 	sub	r8,r7,-1
80007d3e:	30 0b       	mov	r11,0
80007d40:	23 09       	sub	r9,48
80007d42:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d46:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007d4a:	11 39       	ld.ub	r9,r8++
80007d4c:	f2 ca 00 30 	sub	r10,r9,48
80007d50:	58 9a       	cp.w	r10,9
80007d52:	fe 98 ff f7 	brls	80007d40 <_vfprintf_r+0x21c>
80007d56:	e0 49 00 24 	cp.w	r9,36
80007d5a:	cc 31       	brne	80007ce0 <_vfprintf_r+0x1bc>
80007d5c:	e0 4b 00 20 	cp.w	r11,32
80007d60:	e0 89 0e 60 	brgt	80009a20 <_vfprintf_r+0x1efc>
80007d64:	20 1b       	sub	r11,1
80007d66:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d6a:	12 3b       	cp.w	r11,r9
80007d6c:	c0 95       	brlt	80007d7e <_vfprintf_r+0x25a>
80007d6e:	c1 08       	rjmp	80007d8e <_vfprintf_r+0x26a>
80007d70:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d74:	ec ca ff ff 	sub	r10,r6,-1
80007d78:	12 36       	cp.w	r6,r9
80007d7a:	c1 f5       	brlt	80007db8 <_vfprintf_r+0x294>
80007d7c:	c2 68       	rjmp	80007dc8 <_vfprintf_r+0x2a4>
80007d7e:	fa ce f9 44 	sub	lr,sp,-1724
80007d82:	10 97       	mov	r7,r8
80007d84:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007d88:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007d8c:	c3 58       	rjmp	80007df6 <_vfprintf_r+0x2d2>
80007d8e:	10 97       	mov	r7,r8
80007d90:	fa c8 f9 50 	sub	r8,sp,-1712
80007d94:	1a d8       	st.w	--sp,r8
80007d96:	fa c8 fa b8 	sub	r8,sp,-1352
80007d9a:	1a d8       	st.w	--sp,r8
80007d9c:	fa c8 fb b4 	sub	r8,sp,-1100
80007da0:	02 9a       	mov	r10,r1
80007da2:	1a d8       	st.w	--sp,r8
80007da4:	04 9c       	mov	r12,r2
80007da6:	fa c8 f9 40 	sub	r8,sp,-1728
80007daa:	fa c9 ff b4 	sub	r9,sp,-76
80007dae:	fe b0 fd 23 	rcall	800077f4 <get_arg>
80007db2:	2f dd       	sub	sp,-12
80007db4:	78 00       	ld.w	r0,r12[0x0]
80007db6:	c2 08       	rjmp	80007df6 <_vfprintf_r+0x2d2>
80007db8:	fa cc f9 44 	sub	r12,sp,-1724
80007dbc:	14 96       	mov	r6,r10
80007dbe:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007dc2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007dc6:	c1 88       	rjmp	80007df6 <_vfprintf_r+0x2d2>
80007dc8:	41 08       	lddsp	r8,sp[0x40]
80007dca:	59 f9       	cp.w	r9,31
80007dcc:	e0 89 00 11 	brgt	80007dee <_vfprintf_r+0x2ca>
80007dd0:	f0 cb ff fc 	sub	r11,r8,-4
80007dd4:	51 0b       	stdsp	sp[0x40],r11
80007dd6:	70 00       	ld.w	r0,r8[0x0]
80007dd8:	fa cb f9 44 	sub	r11,sp,-1724
80007ddc:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007de0:	f1 40 fd 88 	st.w	r8[-632],r0
80007de4:	2f f9       	sub	r9,-1
80007de6:	14 96       	mov	r6,r10
80007de8:	fb 49 06 b4 	st.w	sp[1716],r9
80007dec:	c0 58       	rjmp	80007df6 <_vfprintf_r+0x2d2>
80007dee:	70 00       	ld.w	r0,r8[0x0]
80007df0:	14 96       	mov	r6,r10
80007df2:	2f c8       	sub	r8,-4
80007df4:	51 08       	stdsp	sp[0x40],r8
80007df6:	58 00       	cp.w	r0,0
80007df8:	fe 94 ff 76 	brge	80007ce4 <_vfprintf_r+0x1c0>
80007dfc:	5c 30       	neg	r0
80007dfe:	a3 a5       	sbr	r5,0x2
80007e00:	c7 2b       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007e02:	32 b8       	mov	r8,43
80007e04:	fb 68 06 bb 	st.b	sp[1723],r8
80007e08:	c6 eb       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007e0a:	0f 38       	ld.ub	r8,r7++
80007e0c:	e0 48 00 2a 	cp.w	r8,42
80007e10:	c0 30       	breq	80007e16 <_vfprintf_r+0x2f2>
80007e12:	30 09       	mov	r9,0
80007e14:	c7 98       	rjmp	80007f06 <_vfprintf_r+0x3e2>
80007e16:	0f 88       	ld.ub	r8,r7[0x0]
80007e18:	f0 c9 00 30 	sub	r9,r8,48
80007e1c:	58 99       	cp.w	r9,9
80007e1e:	e0 8b 00 1f 	brhi	80007e5c <_vfprintf_r+0x338>
80007e22:	ee c4 ff ff 	sub	r4,r7,-1
80007e26:	30 0b       	mov	r11,0
80007e28:	23 08       	sub	r8,48
80007e2a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007e2e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007e32:	09 38       	ld.ub	r8,r4++
80007e34:	f0 c9 00 30 	sub	r9,r8,48
80007e38:	58 99       	cp.w	r9,9
80007e3a:	fe 98 ff f7 	brls	80007e28 <_vfprintf_r+0x304>
80007e3e:	e0 48 00 24 	cp.w	r8,36
80007e42:	fe 91 ff 4f 	brne	80007ce0 <_vfprintf_r+0x1bc>
80007e46:	e0 4b 00 20 	cp.w	r11,32
80007e4a:	e0 89 0d eb 	brgt	80009a20 <_vfprintf_r+0x1efc>
80007e4e:	20 1b       	sub	r11,1
80007e50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e54:	10 3b       	cp.w	r11,r8
80007e56:	c0 a5       	brlt	80007e6a <_vfprintf_r+0x346>
80007e58:	c1 18       	rjmp	80007e7a <_vfprintf_r+0x356>
80007e5a:	d7 03       	nop
80007e5c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007e60:	ec c9 ff ff 	sub	r9,r6,-1
80007e64:	14 36       	cp.w	r6,r10
80007e66:	c1 f5       	brlt	80007ea4 <_vfprintf_r+0x380>
80007e68:	c2 88       	rjmp	80007eb8 <_vfprintf_r+0x394>
80007e6a:	fa ca f9 44 	sub	r10,sp,-1724
80007e6e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007e72:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007e76:	50 2b       	stdsp	sp[0x8],r11
80007e78:	c3 c8       	rjmp	80007ef0 <_vfprintf_r+0x3cc>
80007e7a:	fa c8 f9 50 	sub	r8,sp,-1712
80007e7e:	1a d8       	st.w	--sp,r8
80007e80:	fa c8 fa b8 	sub	r8,sp,-1352
80007e84:	1a d8       	st.w	--sp,r8
80007e86:	fa c8 fb b4 	sub	r8,sp,-1100
80007e8a:	02 9a       	mov	r10,r1
80007e8c:	1a d8       	st.w	--sp,r8
80007e8e:	04 9c       	mov	r12,r2
80007e90:	fa c8 f9 40 	sub	r8,sp,-1728
80007e94:	fa c9 ff b4 	sub	r9,sp,-76
80007e98:	fe b0 fc ae 	rcall	800077f4 <get_arg>
80007e9c:	2f dd       	sub	sp,-12
80007e9e:	78 0c       	ld.w	r12,r12[0x0]
80007ea0:	50 2c       	stdsp	sp[0x8],r12
80007ea2:	c2 78       	rjmp	80007ef0 <_vfprintf_r+0x3cc>
80007ea4:	12 96       	mov	r6,r9
80007ea6:	0e 94       	mov	r4,r7
80007ea8:	fa c9 f9 44 	sub	r9,sp,-1724
80007eac:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007eb0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007eb4:	50 28       	stdsp	sp[0x8],r8
80007eb6:	c1 d8       	rjmp	80007ef0 <_vfprintf_r+0x3cc>
80007eb8:	41 08       	lddsp	r8,sp[0x40]
80007eba:	59 fa       	cp.w	r10,31
80007ebc:	e0 89 00 14 	brgt	80007ee4 <_vfprintf_r+0x3c0>
80007ec0:	f0 cb ff fc 	sub	r11,r8,-4
80007ec4:	70 08       	ld.w	r8,r8[0x0]
80007ec6:	51 0b       	stdsp	sp[0x40],r11
80007ec8:	50 28       	stdsp	sp[0x8],r8
80007eca:	fa c6 f9 44 	sub	r6,sp,-1724
80007ece:	40 2e       	lddsp	lr,sp[0x8]
80007ed0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007ed4:	f1 4e fd 88 	st.w	r8[-632],lr
80007ed8:	2f fa       	sub	r10,-1
80007eda:	0e 94       	mov	r4,r7
80007edc:	fb 4a 06 b4 	st.w	sp[1716],r10
80007ee0:	12 96       	mov	r6,r9
80007ee2:	c0 78       	rjmp	80007ef0 <_vfprintf_r+0x3cc>
80007ee4:	70 0c       	ld.w	r12,r8[0x0]
80007ee6:	0e 94       	mov	r4,r7
80007ee8:	2f c8       	sub	r8,-4
80007eea:	50 2c       	stdsp	sp[0x8],r12
80007eec:	12 96       	mov	r6,r9
80007eee:	51 08       	stdsp	sp[0x40],r8
80007ef0:	40 2b       	lddsp	r11,sp[0x8]
80007ef2:	58 0b       	cp.w	r11,0
80007ef4:	fe 95 fe f2 	brlt	80007cd8 <_vfprintf_r+0x1b4>
80007ef8:	08 97       	mov	r7,r4
80007efa:	cf 5a       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007efc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f00:	0f 38       	ld.ub	r8,r7++
80007f02:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007f06:	f0 ca 00 30 	sub	r10,r8,48
80007f0a:	58 9a       	cp.w	r10,9
80007f0c:	fe 98 ff f8 	brls	80007efc <_vfprintf_r+0x3d8>
80007f10:	3f fa       	mov	r10,-1
80007f12:	f2 0a 0c 49 	max	r9,r9,r10
80007f16:	50 29       	stdsp	sp[0x8],r9
80007f18:	ce 9a       	rjmp	80007cea <_vfprintf_r+0x1c6>
80007f1a:	a7 b5       	sbr	r5,0x7
80007f1c:	ce 4a       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f1e:	30 09       	mov	r9,0
80007f20:	23 08       	sub	r8,48
80007f22:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f26:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007f2a:	0f 38       	ld.ub	r8,r7++
80007f2c:	f0 ca 00 30 	sub	r10,r8,48
80007f30:	58 9a       	cp.w	r10,9
80007f32:	fe 98 ff f7 	brls	80007f20 <_vfprintf_r+0x3fc>
80007f36:	e0 48 00 24 	cp.w	r8,36
80007f3a:	fe 91 fe d7 	brne	80007ce8 <_vfprintf_r+0x1c4>
80007f3e:	e0 49 00 20 	cp.w	r9,32
80007f42:	e0 89 0d 6f 	brgt	80009a20 <_vfprintf_r+0x1efc>
80007f46:	f2 c3 00 01 	sub	r3,r9,1
80007f4a:	30 19       	mov	r9,1
80007f4c:	50 39       	stdsp	sp[0xc],r9
80007f4e:	cc ba       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f50:	a3 b5       	sbr	r5,0x3
80007f52:	cc 9a       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f54:	a7 a5       	sbr	r5,0x6
80007f56:	cc 7a       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f58:	0a 98       	mov	r8,r5
80007f5a:	a5 b5       	sbr	r5,0x5
80007f5c:	a5 a8       	sbr	r8,0x4
80007f5e:	0f 89       	ld.ub	r9,r7[0x0]
80007f60:	36 ce       	mov	lr,108
80007f62:	fc 09 18 00 	cp.b	r9,lr
80007f66:	f7 b7 00 ff 	subeq	r7,-1
80007f6a:	f0 05 17 10 	movne	r5,r8
80007f6e:	cb ba       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f70:	a5 b5       	sbr	r5,0x5
80007f72:	cb 9a       	rjmp	80007ce4 <_vfprintf_r+0x1c0>
80007f74:	50 a7       	stdsp	sp[0x28],r7
80007f76:	50 80       	stdsp	sp[0x20],r0
80007f78:	0c 97       	mov	r7,r6
80007f7a:	10 90       	mov	r0,r8
80007f7c:	06 96       	mov	r6,r3
80007f7e:	04 94       	mov	r4,r2
80007f80:	40 93       	lddsp	r3,sp[0x24]
80007f82:	02 92       	mov	r2,r1
80007f84:	0e 99       	mov	r9,r7
80007f86:	40 41       	lddsp	r1,sp[0x10]
80007f88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f8c:	40 3c       	lddsp	r12,sp[0xc]
80007f8e:	58 0c       	cp.w	r12,0
80007f90:	c1 d0       	breq	80007fca <_vfprintf_r+0x4a6>
80007f92:	10 36       	cp.w	r6,r8
80007f94:	c0 64       	brge	80007fa0 <_vfprintf_r+0x47c>
80007f96:	fa cb f9 44 	sub	r11,sp,-1724
80007f9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f9e:	c1 d8       	rjmp	80007fd8 <_vfprintf_r+0x4b4>
80007fa0:	fa c8 f9 50 	sub	r8,sp,-1712
80007fa4:	1a d8       	st.w	--sp,r8
80007fa6:	fa c8 fa b8 	sub	r8,sp,-1352
80007faa:	1a d8       	st.w	--sp,r8
80007fac:	fa c8 fb b4 	sub	r8,sp,-1100
80007fb0:	1a d8       	st.w	--sp,r8
80007fb2:	fa c8 f9 40 	sub	r8,sp,-1728
80007fb6:	fa c9 ff b4 	sub	r9,sp,-76
80007fba:	04 9a       	mov	r10,r2
80007fbc:	0c 9b       	mov	r11,r6
80007fbe:	08 9c       	mov	r12,r4
80007fc0:	fe b0 fc 1a 	rcall	800077f4 <get_arg>
80007fc4:	2f dd       	sub	sp,-12
80007fc6:	19 b8       	ld.ub	r8,r12[0x3]
80007fc8:	c2 28       	rjmp	8000800c <_vfprintf_r+0x4e8>
80007fca:	2f f7       	sub	r7,-1
80007fcc:	10 39       	cp.w	r9,r8
80007fce:	c0 84       	brge	80007fde <_vfprintf_r+0x4ba>
80007fd0:	fa ca f9 44 	sub	r10,sp,-1724
80007fd4:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007fd8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007fdc:	c1 88       	rjmp	8000800c <_vfprintf_r+0x4e8>
80007fde:	41 09       	lddsp	r9,sp[0x40]
80007fe0:	59 f8       	cp.w	r8,31
80007fe2:	e0 89 00 12 	brgt	80008006 <_vfprintf_r+0x4e2>
80007fe6:	f2 ca ff fc 	sub	r10,r9,-4
80007fea:	51 0a       	stdsp	sp[0x40],r10
80007fec:	72 09       	ld.w	r9,r9[0x0]
80007fee:	fa c6 f9 44 	sub	r6,sp,-1724
80007ff2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007ff6:	2f f8       	sub	r8,-1
80007ff8:	f5 49 fd 88 	st.w	r10[-632],r9
80007ffc:	fb 48 06 b4 	st.w	sp[1716],r8
80008000:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008004:	c0 48       	rjmp	8000800c <_vfprintf_r+0x4e8>
80008006:	13 b8       	ld.ub	r8,r9[0x3]
80008008:	2f c9       	sub	r9,-4
8000800a:	51 09       	stdsp	sp[0x40],r9
8000800c:	fb 68 06 60 	st.b	sp[1632],r8
80008010:	30 0e       	mov	lr,0
80008012:	30 08       	mov	r8,0
80008014:	30 12       	mov	r2,1
80008016:	fb 68 06 bb 	st.b	sp[1723],r8
8000801a:	50 2e       	stdsp	sp[0x8],lr
8000801c:	e0 8f 08 ad 	bral	80009176 <_vfprintf_r+0x1652>
80008020:	50 a7       	stdsp	sp[0x28],r7
80008022:	50 80       	stdsp	sp[0x20],r0
80008024:	0c 97       	mov	r7,r6
80008026:	04 94       	mov	r4,r2
80008028:	06 96       	mov	r6,r3
8000802a:	02 92       	mov	r2,r1
8000802c:	40 93       	lddsp	r3,sp[0x24]
8000802e:	10 90       	mov	r0,r8
80008030:	40 41       	lddsp	r1,sp[0x10]
80008032:	a5 a5       	sbr	r5,0x4
80008034:	c0 a8       	rjmp	80008048 <_vfprintf_r+0x524>
80008036:	50 a7       	stdsp	sp[0x28],r7
80008038:	50 80       	stdsp	sp[0x20],r0
8000803a:	0c 97       	mov	r7,r6
8000803c:	04 94       	mov	r4,r2
8000803e:	06 96       	mov	r6,r3
80008040:	02 92       	mov	r2,r1
80008042:	40 93       	lddsp	r3,sp[0x24]
80008044:	10 90       	mov	r0,r8
80008046:	40 41       	lddsp	r1,sp[0x10]
80008048:	ed b5 00 05 	bld	r5,0x5
8000804c:	c5 11       	brne	800080ee <_vfprintf_r+0x5ca>
8000804e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008052:	40 3c       	lddsp	r12,sp[0xc]
80008054:	58 0c       	cp.w	r12,0
80008056:	c1 e0       	breq	80008092 <_vfprintf_r+0x56e>
80008058:	10 36       	cp.w	r6,r8
8000805a:	c0 64       	brge	80008066 <_vfprintf_r+0x542>
8000805c:	fa cb f9 44 	sub	r11,sp,-1724
80008060:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008064:	c2 08       	rjmp	800080a4 <_vfprintf_r+0x580>
80008066:	fa c8 f9 50 	sub	r8,sp,-1712
8000806a:	1a d8       	st.w	--sp,r8
8000806c:	fa c8 fa b8 	sub	r8,sp,-1352
80008070:	0c 9b       	mov	r11,r6
80008072:	1a d8       	st.w	--sp,r8
80008074:	fa c8 fb b4 	sub	r8,sp,-1100
80008078:	1a d8       	st.w	--sp,r8
8000807a:	fa c9 ff b4 	sub	r9,sp,-76
8000807e:	fa c8 f9 40 	sub	r8,sp,-1728
80008082:	04 9a       	mov	r10,r2
80008084:	08 9c       	mov	r12,r4
80008086:	fe b0 fb b7 	rcall	800077f4 <get_arg>
8000808a:	2f dd       	sub	sp,-12
8000808c:	78 1b       	ld.w	r11,r12[0x4]
8000808e:	78 09       	ld.w	r9,r12[0x0]
80008090:	c2 b8       	rjmp	800080e6 <_vfprintf_r+0x5c2>
80008092:	ee ca ff ff 	sub	r10,r7,-1
80008096:	10 37       	cp.w	r7,r8
80008098:	c0 b4       	brge	800080ae <_vfprintf_r+0x58a>
8000809a:	fa c9 f9 44 	sub	r9,sp,-1724
8000809e:	14 97       	mov	r7,r10
800080a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080a4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800080a8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800080ac:	c1 d8       	rjmp	800080e6 <_vfprintf_r+0x5c2>
800080ae:	41 09       	lddsp	r9,sp[0x40]
800080b0:	59 f8       	cp.w	r8,31
800080b2:	e0 89 00 14 	brgt	800080da <_vfprintf_r+0x5b6>
800080b6:	f2 cb ff f8 	sub	r11,r9,-8
800080ba:	51 0b       	stdsp	sp[0x40],r11
800080bc:	fa c6 f9 44 	sub	r6,sp,-1724
800080c0:	72 1b       	ld.w	r11,r9[0x4]
800080c2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800080c6:	72 09       	ld.w	r9,r9[0x0]
800080c8:	f9 4b fd 8c 	st.w	r12[-628],r11
800080cc:	f9 49 fd 88 	st.w	r12[-632],r9
800080d0:	2f f8       	sub	r8,-1
800080d2:	14 97       	mov	r7,r10
800080d4:	fb 48 06 b4 	st.w	sp[1716],r8
800080d8:	c0 78       	rjmp	800080e6 <_vfprintf_r+0x5c2>
800080da:	f2 c8 ff f8 	sub	r8,r9,-8
800080de:	72 1b       	ld.w	r11,r9[0x4]
800080e0:	14 97       	mov	r7,r10
800080e2:	51 08       	stdsp	sp[0x40],r8
800080e4:	72 09       	ld.w	r9,r9[0x0]
800080e6:	16 98       	mov	r8,r11
800080e8:	fa e9 00 00 	st.d	sp[0],r8
800080ec:	ca e8       	rjmp	80008248 <_vfprintf_r+0x724>
800080ee:	ed b5 00 04 	bld	r5,0x4
800080f2:	c1 71       	brne	80008120 <_vfprintf_r+0x5fc>
800080f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080f8:	40 3e       	lddsp	lr,sp[0xc]
800080fa:	58 0e       	cp.w	lr,0
800080fc:	c0 80       	breq	8000810c <_vfprintf_r+0x5e8>
800080fe:	10 36       	cp.w	r6,r8
80008100:	c6 94       	brge	800081d2 <_vfprintf_r+0x6ae>
80008102:	fa cc f9 44 	sub	r12,sp,-1724
80008106:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000810a:	c8 28       	rjmp	8000820e <_vfprintf_r+0x6ea>
8000810c:	ee ca ff ff 	sub	r10,r7,-1
80008110:	10 37       	cp.w	r7,r8
80008112:	e0 84 00 81 	brge	80008214 <_vfprintf_r+0x6f0>
80008116:	fa cb f9 44 	sub	r11,sp,-1724
8000811a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000811e:	c7 78       	rjmp	8000820c <_vfprintf_r+0x6e8>
80008120:	ed b5 00 06 	bld	r5,0x6
80008124:	c4 b1       	brne	800081ba <_vfprintf_r+0x696>
80008126:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000812a:	40 3c       	lddsp	r12,sp[0xc]
8000812c:	58 0c       	cp.w	r12,0
8000812e:	c1 d0       	breq	80008168 <_vfprintf_r+0x644>
80008130:	10 36       	cp.w	r6,r8
80008132:	c0 64       	brge	8000813e <_vfprintf_r+0x61a>
80008134:	fa cb f9 44 	sub	r11,sp,-1724
80008138:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000813c:	c1 f8       	rjmp	8000817a <_vfprintf_r+0x656>
8000813e:	fa c8 f9 50 	sub	r8,sp,-1712
80008142:	1a d8       	st.w	--sp,r8
80008144:	fa c8 fa b8 	sub	r8,sp,-1352
80008148:	1a d8       	st.w	--sp,r8
8000814a:	fa c8 fb b4 	sub	r8,sp,-1100
8000814e:	1a d8       	st.w	--sp,r8
80008150:	fa c8 f9 40 	sub	r8,sp,-1728
80008154:	fa c9 ff b4 	sub	r9,sp,-76
80008158:	04 9a       	mov	r10,r2
8000815a:	0c 9b       	mov	r11,r6
8000815c:	08 9c       	mov	r12,r4
8000815e:	fe b0 fb 4b 	rcall	800077f4 <get_arg>
80008162:	2f dd       	sub	sp,-12
80008164:	98 18       	ld.sh	r8,r12[0x2]
80008166:	c2 68       	rjmp	800081b2 <_vfprintf_r+0x68e>
80008168:	ee ca ff ff 	sub	r10,r7,-1
8000816c:	10 37       	cp.w	r7,r8
8000816e:	c0 94       	brge	80008180 <_vfprintf_r+0x65c>
80008170:	fa c9 f9 44 	sub	r9,sp,-1724
80008174:	14 97       	mov	r7,r10
80008176:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000817a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000817e:	c1 a8       	rjmp	800081b2 <_vfprintf_r+0x68e>
80008180:	41 09       	lddsp	r9,sp[0x40]
80008182:	59 f8       	cp.w	r8,31
80008184:	e0 89 00 13 	brgt	800081aa <_vfprintf_r+0x686>
80008188:	f2 cb ff fc 	sub	r11,r9,-4
8000818c:	51 0b       	stdsp	sp[0x40],r11
8000818e:	72 09       	ld.w	r9,r9[0x0]
80008190:	fa c6 f9 44 	sub	r6,sp,-1724
80008194:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008198:	2f f8       	sub	r8,-1
8000819a:	f7 49 fd 88 	st.w	r11[-632],r9
8000819e:	fb 48 06 b4 	st.w	sp[1716],r8
800081a2:	14 97       	mov	r7,r10
800081a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800081a8:	c0 58       	rjmp	800081b2 <_vfprintf_r+0x68e>
800081aa:	92 18       	ld.sh	r8,r9[0x2]
800081ac:	14 97       	mov	r7,r10
800081ae:	2f c9       	sub	r9,-4
800081b0:	51 09       	stdsp	sp[0x40],r9
800081b2:	50 18       	stdsp	sp[0x4],r8
800081b4:	bf 58       	asr	r8,0x1f
800081b6:	50 08       	stdsp	sp[0x0],r8
800081b8:	c4 88       	rjmp	80008248 <_vfprintf_r+0x724>
800081ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081be:	40 3c       	lddsp	r12,sp[0xc]
800081c0:	58 0c       	cp.w	r12,0
800081c2:	c1 d0       	breq	800081fc <_vfprintf_r+0x6d8>
800081c4:	10 36       	cp.w	r6,r8
800081c6:	c0 64       	brge	800081d2 <_vfprintf_r+0x6ae>
800081c8:	fa cb f9 44 	sub	r11,sp,-1724
800081cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081d0:	c1 f8       	rjmp	8000820e <_vfprintf_r+0x6ea>
800081d2:	fa c8 f9 50 	sub	r8,sp,-1712
800081d6:	1a d8       	st.w	--sp,r8
800081d8:	fa c8 fa b8 	sub	r8,sp,-1352
800081dc:	0c 9b       	mov	r11,r6
800081de:	1a d8       	st.w	--sp,r8
800081e0:	fa c8 fb b4 	sub	r8,sp,-1100
800081e4:	04 9a       	mov	r10,r2
800081e6:	1a d8       	st.w	--sp,r8
800081e8:	08 9c       	mov	r12,r4
800081ea:	fa c8 f9 40 	sub	r8,sp,-1728
800081ee:	fa c9 ff b4 	sub	r9,sp,-76
800081f2:	fe b0 fb 01 	rcall	800077f4 <get_arg>
800081f6:	2f dd       	sub	sp,-12
800081f8:	78 0b       	ld.w	r11,r12[0x0]
800081fa:	c2 48       	rjmp	80008242 <_vfprintf_r+0x71e>
800081fc:	ee ca ff ff 	sub	r10,r7,-1
80008200:	10 37       	cp.w	r7,r8
80008202:	c0 94       	brge	80008214 <_vfprintf_r+0x6f0>
80008204:	fa c9 f9 44 	sub	r9,sp,-1724
80008208:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000820c:	14 97       	mov	r7,r10
8000820e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008212:	c1 88       	rjmp	80008242 <_vfprintf_r+0x71e>
80008214:	41 09       	lddsp	r9,sp[0x40]
80008216:	59 f8       	cp.w	r8,31
80008218:	e0 89 00 11 	brgt	8000823a <_vfprintf_r+0x716>
8000821c:	f2 cb ff fc 	sub	r11,r9,-4
80008220:	51 0b       	stdsp	sp[0x40],r11
80008222:	fa c6 f9 44 	sub	r6,sp,-1724
80008226:	72 0b       	ld.w	r11,r9[0x0]
80008228:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000822c:	f3 4b fd 88 	st.w	r9[-632],r11
80008230:	2f f8       	sub	r8,-1
80008232:	14 97       	mov	r7,r10
80008234:	fb 48 06 b4 	st.w	sp[1716],r8
80008238:	c0 58       	rjmp	80008242 <_vfprintf_r+0x71e>
8000823a:	72 0b       	ld.w	r11,r9[0x0]
8000823c:	14 97       	mov	r7,r10
8000823e:	2f c9       	sub	r9,-4
80008240:	51 09       	stdsp	sp[0x40],r9
80008242:	50 1b       	stdsp	sp[0x4],r11
80008244:	bf 5b       	asr	r11,0x1f
80008246:	50 0b       	stdsp	sp[0x0],r11
80008248:	fa ea 00 00 	ld.d	r10,sp[0]
8000824c:	58 0a       	cp.w	r10,0
8000824e:	5c 2b       	cpc	r11
80008250:	c0 e4       	brge	8000826c <_vfprintf_r+0x748>
80008252:	30 08       	mov	r8,0
80008254:	fa ea 00 00 	ld.d	r10,sp[0]
80008258:	30 09       	mov	r9,0
8000825a:	f0 0a 01 0a 	sub	r10,r8,r10
8000825e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008262:	32 d8       	mov	r8,45
80008264:	fa eb 00 00 	st.d	sp[0],r10
80008268:	fb 68 06 bb 	st.b	sp[1723],r8
8000826c:	30 18       	mov	r8,1
8000826e:	e0 8f 06 fa 	bral	80009062 <_vfprintf_r+0x153e>
80008272:	50 a7       	stdsp	sp[0x28],r7
80008274:	50 80       	stdsp	sp[0x20],r0
80008276:	0c 97       	mov	r7,r6
80008278:	04 94       	mov	r4,r2
8000827a:	06 96       	mov	r6,r3
8000827c:	02 92       	mov	r2,r1
8000827e:	40 93       	lddsp	r3,sp[0x24]
80008280:	10 90       	mov	r0,r8
80008282:	40 41       	lddsp	r1,sp[0x10]
80008284:	0e 99       	mov	r9,r7
80008286:	ed b5 00 03 	bld	r5,0x3
8000828a:	c4 11       	brne	8000830c <_vfprintf_r+0x7e8>
8000828c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008290:	40 3a       	lddsp	r10,sp[0xc]
80008292:	58 0a       	cp.w	r10,0
80008294:	c1 90       	breq	800082c6 <_vfprintf_r+0x7a2>
80008296:	10 36       	cp.w	r6,r8
80008298:	c6 45       	brlt	80008360 <_vfprintf_r+0x83c>
8000829a:	fa c8 f9 50 	sub	r8,sp,-1712
8000829e:	1a d8       	st.w	--sp,r8
800082a0:	fa c8 fa b8 	sub	r8,sp,-1352
800082a4:	1a d8       	st.w	--sp,r8
800082a6:	fa c8 fb b4 	sub	r8,sp,-1100
800082aa:	0c 9b       	mov	r11,r6
800082ac:	1a d8       	st.w	--sp,r8
800082ae:	04 9a       	mov	r10,r2
800082b0:	fa c8 f9 40 	sub	r8,sp,-1728
800082b4:	fa c9 ff b4 	sub	r9,sp,-76
800082b8:	08 9c       	mov	r12,r4
800082ba:	fe b0 fa 9d 	rcall	800077f4 <get_arg>
800082be:	2f dd       	sub	sp,-12
800082c0:	78 16       	ld.w	r6,r12[0x4]
800082c2:	50 76       	stdsp	sp[0x1c],r6
800082c4:	c4 88       	rjmp	80008354 <_vfprintf_r+0x830>
800082c6:	2f f7       	sub	r7,-1
800082c8:	10 39       	cp.w	r9,r8
800082ca:	c0 c4       	brge	800082e2 <_vfprintf_r+0x7be>
800082cc:	fa ce f9 44 	sub	lr,sp,-1724
800082d0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800082d4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800082d8:	50 7c       	stdsp	sp[0x1c],r12
800082da:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082de:	50 56       	stdsp	sp[0x14],r6
800082e0:	c6 68       	rjmp	800083ac <_vfprintf_r+0x888>
800082e2:	41 09       	lddsp	r9,sp[0x40]
800082e4:	59 f8       	cp.w	r8,31
800082e6:	e0 89 00 10 	brgt	80008306 <_vfprintf_r+0x7e2>
800082ea:	f2 ca ff f8 	sub	r10,r9,-8
800082ee:	72 1b       	ld.w	r11,r9[0x4]
800082f0:	51 0a       	stdsp	sp[0x40],r10
800082f2:	72 09       	ld.w	r9,r9[0x0]
800082f4:	fa ca f9 44 	sub	r10,sp,-1724
800082f8:	50 7b       	stdsp	sp[0x1c],r11
800082fa:	50 59       	stdsp	sp[0x14],r9
800082fc:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008300:	40 5b       	lddsp	r11,sp[0x14]
80008302:	40 7a       	lddsp	r10,sp[0x1c]
80008304:	c4 78       	rjmp	80008392 <_vfprintf_r+0x86e>
80008306:	72 18       	ld.w	r8,r9[0x4]
80008308:	50 78       	stdsp	sp[0x1c],r8
8000830a:	c4 c8       	rjmp	800083a2 <_vfprintf_r+0x87e>
8000830c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008310:	40 3e       	lddsp	lr,sp[0xc]
80008312:	58 0e       	cp.w	lr,0
80008314:	c2 30       	breq	8000835a <_vfprintf_r+0x836>
80008316:	10 36       	cp.w	r6,r8
80008318:	c0 94       	brge	8000832a <_vfprintf_r+0x806>
8000831a:	fa cc f9 44 	sub	r12,sp,-1724
8000831e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008322:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008326:	50 7b       	stdsp	sp[0x1c],r11
80008328:	cd 9b       	rjmp	800082da <_vfprintf_r+0x7b6>
8000832a:	fa c8 f9 50 	sub	r8,sp,-1712
8000832e:	1a d8       	st.w	--sp,r8
80008330:	fa c8 fa b8 	sub	r8,sp,-1352
80008334:	04 9a       	mov	r10,r2
80008336:	1a d8       	st.w	--sp,r8
80008338:	fa c8 fb b4 	sub	r8,sp,-1100
8000833c:	0c 9b       	mov	r11,r6
8000833e:	1a d8       	st.w	--sp,r8
80008340:	08 9c       	mov	r12,r4
80008342:	fa c8 f9 40 	sub	r8,sp,-1728
80008346:	fa c9 ff b4 	sub	r9,sp,-76
8000834a:	fe b0 fa 55 	rcall	800077f4 <get_arg>
8000834e:	2f dd       	sub	sp,-12
80008350:	78 1a       	ld.w	r10,r12[0x4]
80008352:	50 7a       	stdsp	sp[0x1c],r10
80008354:	78 0c       	ld.w	r12,r12[0x0]
80008356:	50 5c       	stdsp	sp[0x14],r12
80008358:	c2 a8       	rjmp	800083ac <_vfprintf_r+0x888>
8000835a:	2f f7       	sub	r7,-1
8000835c:	10 39       	cp.w	r9,r8
8000835e:	c0 94       	brge	80008370 <_vfprintf_r+0x84c>
80008360:	fa c9 f9 44 	sub	r9,sp,-1724
80008364:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008368:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000836c:	50 78       	stdsp	sp[0x1c],r8
8000836e:	cb 6b       	rjmp	800082da <_vfprintf_r+0x7b6>
80008370:	41 09       	lddsp	r9,sp[0x40]
80008372:	59 f8       	cp.w	r8,31
80008374:	e0 89 00 15 	brgt	8000839e <_vfprintf_r+0x87a>
80008378:	f2 ca ff f8 	sub	r10,r9,-8
8000837c:	72 16       	ld.w	r6,r9[0x4]
8000837e:	72 09       	ld.w	r9,r9[0x0]
80008380:	51 0a       	stdsp	sp[0x40],r10
80008382:	50 59       	stdsp	sp[0x14],r9
80008384:	fa ce f9 44 	sub	lr,sp,-1724
80008388:	50 76       	stdsp	sp[0x1c],r6
8000838a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000838e:	40 5b       	lddsp	r11,sp[0x14]
80008390:	0c 9a       	mov	r10,r6
80008392:	f2 eb fd 88 	st.d	r9[-632],r10
80008396:	2f f8       	sub	r8,-1
80008398:	fb 48 06 b4 	st.w	sp[1716],r8
8000839c:	c0 88       	rjmp	800083ac <_vfprintf_r+0x888>
8000839e:	72 1c       	ld.w	r12,r9[0x4]
800083a0:	50 7c       	stdsp	sp[0x1c],r12
800083a2:	f2 c8 ff f8 	sub	r8,r9,-8
800083a6:	51 08       	stdsp	sp[0x40],r8
800083a8:	72 09       	ld.w	r9,r9[0x0]
800083aa:	50 59       	stdsp	sp[0x14],r9
800083ac:	40 5b       	lddsp	r11,sp[0x14]
800083ae:	40 7a       	lddsp	r10,sp[0x1c]
800083b0:	e0 a0 19 54 	rcall	8000b658 <__isinfd>
800083b4:	18 96       	mov	r6,r12
800083b6:	c1 70       	breq	800083e4 <_vfprintf_r+0x8c0>
800083b8:	30 08       	mov	r8,0
800083ba:	30 09       	mov	r9,0
800083bc:	40 5b       	lddsp	r11,sp[0x14]
800083be:	40 7a       	lddsp	r10,sp[0x1c]
800083c0:	e0 a0 1d b4 	rcall	8000bf28 <__avr32_f64_cmp_lt>
800083c4:	c0 40       	breq	800083cc <_vfprintf_r+0x8a8>
800083c6:	32 d8       	mov	r8,45
800083c8:	fb 68 06 bb 	st.b	sp[1723],r8
800083cc:	fe c8 ab 70 	sub	r8,pc,-21648
800083d0:	fe c6 ab 70 	sub	r6,pc,-21648
800083d4:	a7 d5       	cbr	r5,0x7
800083d6:	e0 40 00 47 	cp.w	r0,71
800083da:	f0 06 17 a0 	movle	r6,r8
800083de:	30 32       	mov	r2,3
800083e0:	e0 8f 06 ce 	bral	8000917c <_vfprintf_r+0x1658>
800083e4:	40 5b       	lddsp	r11,sp[0x14]
800083e6:	40 7a       	lddsp	r10,sp[0x1c]
800083e8:	e0 a0 19 4d 	rcall	8000b682 <__isnand>
800083ec:	c0 e0       	breq	80008408 <_vfprintf_r+0x8e4>
800083ee:	50 26       	stdsp	sp[0x8],r6
800083f0:	fe c8 ab 8c 	sub	r8,pc,-21620
800083f4:	fe c6 ab 8c 	sub	r6,pc,-21620
800083f8:	a7 d5       	cbr	r5,0x7
800083fa:	e0 40 00 47 	cp.w	r0,71
800083fe:	f0 06 17 a0 	movle	r6,r8
80008402:	30 32       	mov	r2,3
80008404:	e0 8f 06 c2 	bral	80009188 <_vfprintf_r+0x1664>
80008408:	40 2a       	lddsp	r10,sp[0x8]
8000840a:	5b fa       	cp.w	r10,-1
8000840c:	c0 41       	brne	80008414 <_vfprintf_r+0x8f0>
8000840e:	30 69       	mov	r9,6
80008410:	50 29       	stdsp	sp[0x8],r9
80008412:	c1 18       	rjmp	80008434 <_vfprintf_r+0x910>
80008414:	e0 40 00 47 	cp.w	r0,71
80008418:	5f 09       	sreq	r9
8000841a:	e0 40 00 67 	cp.w	r0,103
8000841e:	5f 08       	sreq	r8
80008420:	f3 e8 10 08 	or	r8,r9,r8
80008424:	f8 08 18 00 	cp.b	r8,r12
80008428:	c0 60       	breq	80008434 <_vfprintf_r+0x910>
8000842a:	40 28       	lddsp	r8,sp[0x8]
8000842c:	58 08       	cp.w	r8,0
8000842e:	f9 b8 00 01 	moveq	r8,1
80008432:	50 28       	stdsp	sp[0x8],r8
80008434:	40 78       	lddsp	r8,sp[0x1c]
80008436:	40 59       	lddsp	r9,sp[0x14]
80008438:	fa e9 06 94 	st.d	sp[1684],r8
8000843c:	a9 a5       	sbr	r5,0x8
8000843e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008442:	58 08       	cp.w	r8,0
80008444:	c0 65       	brlt	80008450 <_vfprintf_r+0x92c>
80008446:	40 5e       	lddsp	lr,sp[0x14]
80008448:	30 0c       	mov	r12,0
8000844a:	50 6e       	stdsp	sp[0x18],lr
8000844c:	50 9c       	stdsp	sp[0x24],r12
8000844e:	c0 78       	rjmp	8000845c <_vfprintf_r+0x938>
80008450:	40 5b       	lddsp	r11,sp[0x14]
80008452:	32 da       	mov	r10,45
80008454:	ee 1b 80 00 	eorh	r11,0x8000
80008458:	50 9a       	stdsp	sp[0x24],r10
8000845a:	50 6b       	stdsp	sp[0x18],r11
8000845c:	e0 40 00 46 	cp.w	r0,70
80008460:	5f 09       	sreq	r9
80008462:	e0 40 00 66 	cp.w	r0,102
80008466:	5f 08       	sreq	r8
80008468:	f3 e8 10 08 	or	r8,r9,r8
8000846c:	50 48       	stdsp	sp[0x10],r8
8000846e:	c0 40       	breq	80008476 <_vfprintf_r+0x952>
80008470:	40 22       	lddsp	r2,sp[0x8]
80008472:	30 39       	mov	r9,3
80008474:	c1 08       	rjmp	80008494 <_vfprintf_r+0x970>
80008476:	e0 40 00 45 	cp.w	r0,69
8000847a:	5f 09       	sreq	r9
8000847c:	e0 40 00 65 	cp.w	r0,101
80008480:	5f 08       	sreq	r8
80008482:	40 22       	lddsp	r2,sp[0x8]
80008484:	10 49       	or	r9,r8
80008486:	2f f2       	sub	r2,-1
80008488:	40 46       	lddsp	r6,sp[0x10]
8000848a:	ec 09 18 00 	cp.b	r9,r6
8000848e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008492:	30 29       	mov	r9,2
80008494:	fa c8 f9 5c 	sub	r8,sp,-1700
80008498:	1a d8       	st.w	--sp,r8
8000849a:	fa c8 f9 54 	sub	r8,sp,-1708
8000849e:	1a d8       	st.w	--sp,r8
800084a0:	fa c8 f9 4c 	sub	r8,sp,-1716
800084a4:	08 9c       	mov	r12,r4
800084a6:	1a d8       	st.w	--sp,r8
800084a8:	04 98       	mov	r8,r2
800084aa:	40 9b       	lddsp	r11,sp[0x24]
800084ac:	40 aa       	lddsp	r10,sp[0x28]
800084ae:	e0 a0 0b c3 	rcall	80009c34 <_dtoa_r>
800084b2:	e0 40 00 47 	cp.w	r0,71
800084b6:	5f 19       	srne	r9
800084b8:	e0 40 00 67 	cp.w	r0,103
800084bc:	5f 18       	srne	r8
800084be:	18 96       	mov	r6,r12
800084c0:	2f dd       	sub	sp,-12
800084c2:	f3 e8 00 08 	and	r8,r9,r8
800084c6:	c0 41       	brne	800084ce <_vfprintf_r+0x9aa>
800084c8:	ed b5 00 00 	bld	r5,0x0
800084cc:	c3 01       	brne	8000852c <_vfprintf_r+0xa08>
800084ce:	ec 02 00 0e 	add	lr,r6,r2
800084d2:	50 3e       	stdsp	sp[0xc],lr
800084d4:	40 4c       	lddsp	r12,sp[0x10]
800084d6:	58 0c       	cp.w	r12,0
800084d8:	c1 50       	breq	80008502 <_vfprintf_r+0x9de>
800084da:	0d 89       	ld.ub	r9,r6[0x0]
800084dc:	33 08       	mov	r8,48
800084de:	f0 09 18 00 	cp.b	r9,r8
800084e2:	c0 b1       	brne	800084f8 <_vfprintf_r+0x9d4>
800084e4:	30 08       	mov	r8,0
800084e6:	30 09       	mov	r9,0
800084e8:	40 6b       	lddsp	r11,sp[0x18]
800084ea:	40 7a       	lddsp	r10,sp[0x1c]
800084ec:	e0 a0 1c d7 	rcall	8000be9a <__avr32_f64_cmp_eq>
800084f0:	fb b2 00 01 	rsubeq	r2,1
800084f4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800084f8:	40 3b       	lddsp	r11,sp[0xc]
800084fa:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084fe:	10 0b       	add	r11,r8
80008500:	50 3b       	stdsp	sp[0xc],r11
80008502:	40 6b       	lddsp	r11,sp[0x18]
80008504:	30 08       	mov	r8,0
80008506:	30 09       	mov	r9,0
80008508:	40 7a       	lddsp	r10,sp[0x1c]
8000850a:	e0 a0 1c c8 	rcall	8000be9a <__avr32_f64_cmp_eq>
8000850e:	c0 90       	breq	80008520 <_vfprintf_r+0x9fc>
80008510:	40 3a       	lddsp	r10,sp[0xc]
80008512:	fb 4a 06 a4 	st.w	sp[1700],r10
80008516:	c0 58       	rjmp	80008520 <_vfprintf_r+0x9fc>
80008518:	10 c9       	st.b	r8++,r9
8000851a:	fb 48 06 a4 	st.w	sp[1700],r8
8000851e:	c0 28       	rjmp	80008522 <_vfprintf_r+0x9fe>
80008520:	33 09       	mov	r9,48
80008522:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008526:	40 3e       	lddsp	lr,sp[0xc]
80008528:	1c 38       	cp.w	r8,lr
8000852a:	cf 73       	brcs	80008518 <_vfprintf_r+0x9f4>
8000852c:	e0 40 00 47 	cp.w	r0,71
80008530:	5f 09       	sreq	r9
80008532:	e0 40 00 67 	cp.w	r0,103
80008536:	5f 08       	sreq	r8
80008538:	f3 e8 10 08 	or	r8,r9,r8
8000853c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008540:	0c 19       	sub	r9,r6
80008542:	50 69       	stdsp	sp[0x18],r9
80008544:	58 08       	cp.w	r8,0
80008546:	c0 b0       	breq	8000855c <_vfprintf_r+0xa38>
80008548:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000854c:	5b d8       	cp.w	r8,-3
8000854e:	c0 55       	brlt	80008558 <_vfprintf_r+0xa34>
80008550:	40 2c       	lddsp	r12,sp[0x8]
80008552:	18 38       	cp.w	r8,r12
80008554:	e0 8a 00 6a 	brle	80008628 <_vfprintf_r+0xb04>
80008558:	20 20       	sub	r0,2
8000855a:	c0 58       	rjmp	80008564 <_vfprintf_r+0xa40>
8000855c:	e0 40 00 65 	cp.w	r0,101
80008560:	e0 89 00 46 	brgt	800085ec <_vfprintf_r+0xac8>
80008564:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008568:	fb 60 06 9c 	st.b	sp[1692],r0
8000856c:	20 1b       	sub	r11,1
8000856e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008572:	c0 47       	brpl	8000857a <_vfprintf_r+0xa56>
80008574:	5c 3b       	neg	r11
80008576:	32 d8       	mov	r8,45
80008578:	c0 28       	rjmp	8000857c <_vfprintf_r+0xa58>
8000857a:	32 b8       	mov	r8,43
8000857c:	fb 68 06 9d 	st.b	sp[1693],r8
80008580:	58 9b       	cp.w	r11,9
80008582:	e0 8a 00 1d 	brle	800085bc <_vfprintf_r+0xa98>
80008586:	fa c9 fa 35 	sub	r9,sp,-1483
8000858a:	30 aa       	mov	r10,10
8000858c:	12 98       	mov	r8,r9
8000858e:	0e 9c       	mov	r12,r7
80008590:	0c 92       	mov	r2,r6
80008592:	f6 0a 0c 06 	divs	r6,r11,r10
80008596:	0e 9b       	mov	r11,r7
80008598:	2d 0b       	sub	r11,-48
8000859a:	10 fb       	st.b	--r8,r11
8000859c:	0c 9b       	mov	r11,r6
8000859e:	58 96       	cp.w	r6,9
800085a0:	fe 99 ff f9 	brgt	80008592 <_vfprintf_r+0xa6e>
800085a4:	2d 0b       	sub	r11,-48
800085a6:	18 97       	mov	r7,r12
800085a8:	04 96       	mov	r6,r2
800085aa:	10 fb       	st.b	--r8,r11
800085ac:	fa ca f9 62 	sub	r10,sp,-1694
800085b0:	c0 38       	rjmp	800085b6 <_vfprintf_r+0xa92>
800085b2:	11 3b       	ld.ub	r11,r8++
800085b4:	14 cb       	st.b	r10++,r11
800085b6:	12 38       	cp.w	r8,r9
800085b8:	cf d3       	brcs	800085b2 <_vfprintf_r+0xa8e>
800085ba:	c0 98       	rjmp	800085cc <_vfprintf_r+0xaa8>
800085bc:	2d 0b       	sub	r11,-48
800085be:	33 08       	mov	r8,48
800085c0:	fb 6b 06 9f 	st.b	sp[1695],r11
800085c4:	fb 68 06 9e 	st.b	sp[1694],r8
800085c8:	fa ca f9 60 	sub	r10,sp,-1696
800085cc:	fa c8 f9 64 	sub	r8,sp,-1692
800085d0:	f4 08 01 08 	sub	r8,r10,r8
800085d4:	50 e8       	stdsp	sp[0x38],r8
800085d6:	10 92       	mov	r2,r8
800085d8:	40 6b       	lddsp	r11,sp[0x18]
800085da:	16 02       	add	r2,r11
800085dc:	58 1b       	cp.w	r11,1
800085de:	e0 89 00 05 	brgt	800085e8 <_vfprintf_r+0xac4>
800085e2:	ed b5 00 00 	bld	r5,0x0
800085e6:	c3 51       	brne	80008650 <_vfprintf_r+0xb2c>
800085e8:	2f f2       	sub	r2,-1
800085ea:	c3 38       	rjmp	80008650 <_vfprintf_r+0xb2c>
800085ec:	e0 40 00 66 	cp.w	r0,102
800085f0:	c1 c1       	brne	80008628 <_vfprintf_r+0xb04>
800085f2:	fa f2 06 ac 	ld.w	r2,sp[1708]
800085f6:	58 02       	cp.w	r2,0
800085f8:	e0 8a 00 0c 	brle	80008610 <_vfprintf_r+0xaec>
800085fc:	40 2a       	lddsp	r10,sp[0x8]
800085fe:	58 0a       	cp.w	r10,0
80008600:	c0 41       	brne	80008608 <_vfprintf_r+0xae4>
80008602:	ed b5 00 00 	bld	r5,0x0
80008606:	c2 51       	brne	80008650 <_vfprintf_r+0xb2c>
80008608:	2f f2       	sub	r2,-1
8000860a:	40 29       	lddsp	r9,sp[0x8]
8000860c:	12 02       	add	r2,r9
8000860e:	c0 b8       	rjmp	80008624 <_vfprintf_r+0xb00>
80008610:	40 28       	lddsp	r8,sp[0x8]
80008612:	58 08       	cp.w	r8,0
80008614:	c0 61       	brne	80008620 <_vfprintf_r+0xafc>
80008616:	ed b5 00 00 	bld	r5,0x0
8000861a:	c0 30       	breq	80008620 <_vfprintf_r+0xafc>
8000861c:	30 12       	mov	r2,1
8000861e:	c1 98       	rjmp	80008650 <_vfprintf_r+0xb2c>
80008620:	40 22       	lddsp	r2,sp[0x8]
80008622:	2f e2       	sub	r2,-2
80008624:	36 60       	mov	r0,102
80008626:	c1 58       	rjmp	80008650 <_vfprintf_r+0xb2c>
80008628:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000862c:	40 6e       	lddsp	lr,sp[0x18]
8000862e:	1c 32       	cp.w	r2,lr
80008630:	c0 65       	brlt	8000863c <_vfprintf_r+0xb18>
80008632:	ed b5 00 00 	bld	r5,0x0
80008636:	f7 b2 00 ff 	subeq	r2,-1
8000863a:	c0 a8       	rjmp	8000864e <_vfprintf_r+0xb2a>
8000863c:	e4 08 11 02 	rsub	r8,r2,2
80008640:	40 6c       	lddsp	r12,sp[0x18]
80008642:	58 02       	cp.w	r2,0
80008644:	f0 02 17 a0 	movle	r2,r8
80008648:	f9 b2 09 01 	movgt	r2,1
8000864c:	18 02       	add	r2,r12
8000864e:	36 70       	mov	r0,103
80008650:	40 9b       	lddsp	r11,sp[0x24]
80008652:	58 0b       	cp.w	r11,0
80008654:	e0 80 05 94 	breq	8000917c <_vfprintf_r+0x1658>
80008658:	32 d8       	mov	r8,45
8000865a:	fb 68 06 bb 	st.b	sp[1723],r8
8000865e:	e0 8f 05 93 	bral	80009184 <_vfprintf_r+0x1660>
80008662:	50 a7       	stdsp	sp[0x28],r7
80008664:	04 94       	mov	r4,r2
80008666:	0c 97       	mov	r7,r6
80008668:	02 92       	mov	r2,r1
8000866a:	06 96       	mov	r6,r3
8000866c:	40 41       	lddsp	r1,sp[0x10]
8000866e:	40 93       	lddsp	r3,sp[0x24]
80008670:	0e 99       	mov	r9,r7
80008672:	ed b5 00 05 	bld	r5,0x5
80008676:	c4 81       	brne	80008706 <_vfprintf_r+0xbe2>
80008678:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000867c:	40 3e       	lddsp	lr,sp[0xc]
8000867e:	58 0e       	cp.w	lr,0
80008680:	c1 d0       	breq	800086ba <_vfprintf_r+0xb96>
80008682:	10 36       	cp.w	r6,r8
80008684:	c0 64       	brge	80008690 <_vfprintf_r+0xb6c>
80008686:	fa cc f9 44 	sub	r12,sp,-1724
8000868a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000868e:	c1 d8       	rjmp	800086c8 <_vfprintf_r+0xba4>
80008690:	fa c8 f9 50 	sub	r8,sp,-1712
80008694:	1a d8       	st.w	--sp,r8
80008696:	fa c8 fa b8 	sub	r8,sp,-1352
8000869a:	04 9a       	mov	r10,r2
8000869c:	1a d8       	st.w	--sp,r8
8000869e:	fa c8 fb b4 	sub	r8,sp,-1100
800086a2:	0c 9b       	mov	r11,r6
800086a4:	1a d8       	st.w	--sp,r8
800086a6:	08 9c       	mov	r12,r4
800086a8:	fa c8 f9 40 	sub	r8,sp,-1728
800086ac:	fa c9 ff b4 	sub	r9,sp,-76
800086b0:	fe b0 f8 a2 	rcall	800077f4 <get_arg>
800086b4:	2f dd       	sub	sp,-12
800086b6:	78 0a       	ld.w	r10,r12[0x0]
800086b8:	c2 08       	rjmp	800086f8 <_vfprintf_r+0xbd4>
800086ba:	2f f7       	sub	r7,-1
800086bc:	10 39       	cp.w	r9,r8
800086be:	c0 84       	brge	800086ce <_vfprintf_r+0xbaa>
800086c0:	fa cb f9 44 	sub	r11,sp,-1724
800086c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086c8:	ec fa fd 88 	ld.w	r10,r6[-632]
800086cc:	c1 68       	rjmp	800086f8 <_vfprintf_r+0xbd4>
800086ce:	41 09       	lddsp	r9,sp[0x40]
800086d0:	59 f8       	cp.w	r8,31
800086d2:	e0 89 00 10 	brgt	800086f2 <_vfprintf_r+0xbce>
800086d6:	f2 ca ff fc 	sub	r10,r9,-4
800086da:	51 0a       	stdsp	sp[0x40],r10
800086dc:	fa c6 f9 44 	sub	r6,sp,-1724
800086e0:	72 0a       	ld.w	r10,r9[0x0]
800086e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086e6:	f3 4a fd 88 	st.w	r9[-632],r10
800086ea:	2f f8       	sub	r8,-1
800086ec:	fb 48 06 b4 	st.w	sp[1716],r8
800086f0:	c0 48       	rjmp	800086f8 <_vfprintf_r+0xbd4>
800086f2:	72 0a       	ld.w	r10,r9[0x0]
800086f4:	2f c9       	sub	r9,-4
800086f6:	51 09       	stdsp	sp[0x40],r9
800086f8:	40 be       	lddsp	lr,sp[0x2c]
800086fa:	1c 98       	mov	r8,lr
800086fc:	95 1e       	st.w	r10[0x4],lr
800086fe:	bf 58       	asr	r8,0x1f
80008700:	95 08       	st.w	r10[0x0],r8
80008702:	fe 9f fa 9f 	bral	80007c40 <_vfprintf_r+0x11c>
80008706:	ed b5 00 04 	bld	r5,0x4
8000870a:	c4 80       	breq	8000879a <_vfprintf_r+0xc76>
8000870c:	e2 15 00 40 	andl	r5,0x40,COH
80008710:	c4 50       	breq	8000879a <_vfprintf_r+0xc76>
80008712:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008716:	40 3c       	lddsp	r12,sp[0xc]
80008718:	58 0c       	cp.w	r12,0
8000871a:	c1 d0       	breq	80008754 <_vfprintf_r+0xc30>
8000871c:	10 36       	cp.w	r6,r8
8000871e:	c0 64       	brge	8000872a <_vfprintf_r+0xc06>
80008720:	fa cb f9 44 	sub	r11,sp,-1724
80008724:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008728:	c1 d8       	rjmp	80008762 <_vfprintf_r+0xc3e>
8000872a:	fa c8 f9 50 	sub	r8,sp,-1712
8000872e:	1a d8       	st.w	--sp,r8
80008730:	fa c8 fa b8 	sub	r8,sp,-1352
80008734:	04 9a       	mov	r10,r2
80008736:	1a d8       	st.w	--sp,r8
80008738:	fa c8 fb b4 	sub	r8,sp,-1100
8000873c:	0c 9b       	mov	r11,r6
8000873e:	1a d8       	st.w	--sp,r8
80008740:	08 9c       	mov	r12,r4
80008742:	fa c8 f9 40 	sub	r8,sp,-1728
80008746:	fa c9 ff b4 	sub	r9,sp,-76
8000874a:	fe b0 f8 55 	rcall	800077f4 <get_arg>
8000874e:	2f dd       	sub	sp,-12
80008750:	78 0a       	ld.w	r10,r12[0x0]
80008752:	c2 08       	rjmp	80008792 <_vfprintf_r+0xc6e>
80008754:	2f f7       	sub	r7,-1
80008756:	10 39       	cp.w	r9,r8
80008758:	c0 84       	brge	80008768 <_vfprintf_r+0xc44>
8000875a:	fa ca f9 44 	sub	r10,sp,-1724
8000875e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008762:	ec fa fd 88 	ld.w	r10,r6[-632]
80008766:	c1 68       	rjmp	80008792 <_vfprintf_r+0xc6e>
80008768:	41 09       	lddsp	r9,sp[0x40]
8000876a:	59 f8       	cp.w	r8,31
8000876c:	e0 89 00 10 	brgt	8000878c <_vfprintf_r+0xc68>
80008770:	f2 ca ff fc 	sub	r10,r9,-4
80008774:	51 0a       	stdsp	sp[0x40],r10
80008776:	fa c6 f9 44 	sub	r6,sp,-1724
8000877a:	72 0a       	ld.w	r10,r9[0x0]
8000877c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008780:	f3 4a fd 88 	st.w	r9[-632],r10
80008784:	2f f8       	sub	r8,-1
80008786:	fb 48 06 b4 	st.w	sp[1716],r8
8000878a:	c0 48       	rjmp	80008792 <_vfprintf_r+0xc6e>
8000878c:	72 0a       	ld.w	r10,r9[0x0]
8000878e:	2f c9       	sub	r9,-4
80008790:	51 09       	stdsp	sp[0x40],r9
80008792:	40 be       	lddsp	lr,sp[0x2c]
80008794:	b4 0e       	st.h	r10[0x0],lr
80008796:	fe 9f fa 55 	bral	80007c40 <_vfprintf_r+0x11c>
8000879a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879e:	40 3c       	lddsp	r12,sp[0xc]
800087a0:	58 0c       	cp.w	r12,0
800087a2:	c1 d0       	breq	800087dc <_vfprintf_r+0xcb8>
800087a4:	10 36       	cp.w	r6,r8
800087a6:	c0 64       	brge	800087b2 <_vfprintf_r+0xc8e>
800087a8:	fa cb f9 44 	sub	r11,sp,-1724
800087ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087b0:	c1 d8       	rjmp	800087ea <_vfprintf_r+0xcc6>
800087b2:	fa c8 f9 50 	sub	r8,sp,-1712
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fa b8 	sub	r8,sp,-1352
800087bc:	04 9a       	mov	r10,r2
800087be:	1a d8       	st.w	--sp,r8
800087c0:	fa c8 fb b4 	sub	r8,sp,-1100
800087c4:	0c 9b       	mov	r11,r6
800087c6:	1a d8       	st.w	--sp,r8
800087c8:	08 9c       	mov	r12,r4
800087ca:	fa c8 f9 40 	sub	r8,sp,-1728
800087ce:	fa c9 ff b4 	sub	r9,sp,-76
800087d2:	fe b0 f8 11 	rcall	800077f4 <get_arg>
800087d6:	2f dd       	sub	sp,-12
800087d8:	78 0a       	ld.w	r10,r12[0x0]
800087da:	c2 08       	rjmp	8000881a <_vfprintf_r+0xcf6>
800087dc:	2f f7       	sub	r7,-1
800087de:	10 39       	cp.w	r9,r8
800087e0:	c0 84       	brge	800087f0 <_vfprintf_r+0xccc>
800087e2:	fa ca f9 44 	sub	r10,sp,-1724
800087e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087ea:	ec fa fd 88 	ld.w	r10,r6[-632]
800087ee:	c1 68       	rjmp	8000881a <_vfprintf_r+0xcf6>
800087f0:	41 09       	lddsp	r9,sp[0x40]
800087f2:	59 f8       	cp.w	r8,31
800087f4:	e0 89 00 10 	brgt	80008814 <_vfprintf_r+0xcf0>
800087f8:	f2 ca ff fc 	sub	r10,r9,-4
800087fc:	51 0a       	stdsp	sp[0x40],r10
800087fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008802:	72 0a       	ld.w	r10,r9[0x0]
80008804:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008808:	f3 4a fd 88 	st.w	r9[-632],r10
8000880c:	2f f8       	sub	r8,-1
8000880e:	fb 48 06 b4 	st.w	sp[1716],r8
80008812:	c0 48       	rjmp	8000881a <_vfprintf_r+0xcf6>
80008814:	72 0a       	ld.w	r10,r9[0x0]
80008816:	2f c9       	sub	r9,-4
80008818:	51 09       	stdsp	sp[0x40],r9
8000881a:	40 be       	lddsp	lr,sp[0x2c]
8000881c:	95 0e       	st.w	r10[0x0],lr
8000881e:	fe 9f fa 11 	bral	80007c40 <_vfprintf_r+0x11c>
80008822:	50 a7       	stdsp	sp[0x28],r7
80008824:	50 80       	stdsp	sp[0x20],r0
80008826:	0c 97       	mov	r7,r6
80008828:	04 94       	mov	r4,r2
8000882a:	06 96       	mov	r6,r3
8000882c:	02 92       	mov	r2,r1
8000882e:	40 93       	lddsp	r3,sp[0x24]
80008830:	10 90       	mov	r0,r8
80008832:	40 41       	lddsp	r1,sp[0x10]
80008834:	a5 a5       	sbr	r5,0x4
80008836:	c0 a8       	rjmp	8000884a <_vfprintf_r+0xd26>
80008838:	50 a7       	stdsp	sp[0x28],r7
8000883a:	50 80       	stdsp	sp[0x20],r0
8000883c:	0c 97       	mov	r7,r6
8000883e:	04 94       	mov	r4,r2
80008840:	06 96       	mov	r6,r3
80008842:	02 92       	mov	r2,r1
80008844:	40 93       	lddsp	r3,sp[0x24]
80008846:	10 90       	mov	r0,r8
80008848:	40 41       	lddsp	r1,sp[0x10]
8000884a:	ed b5 00 05 	bld	r5,0x5
8000884e:	c5 d1       	brne	80008908 <_vfprintf_r+0xde4>
80008850:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008854:	40 3c       	lddsp	r12,sp[0xc]
80008856:	58 0c       	cp.w	r12,0
80008858:	c2 60       	breq	800088a4 <_vfprintf_r+0xd80>
8000885a:	10 36       	cp.w	r6,r8
8000885c:	c0 a4       	brge	80008870 <_vfprintf_r+0xd4c>
8000885e:	fa cb f9 44 	sub	r11,sp,-1724
80008862:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008866:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000886a:	fa e9 00 00 	st.d	sp[0],r8
8000886e:	c1 88       	rjmp	8000889e <_vfprintf_r+0xd7a>
80008870:	fa c8 f9 50 	sub	r8,sp,-1712
80008874:	1a d8       	st.w	--sp,r8
80008876:	fa c8 fa b8 	sub	r8,sp,-1352
8000887a:	04 9a       	mov	r10,r2
8000887c:	1a d8       	st.w	--sp,r8
8000887e:	0c 9b       	mov	r11,r6
80008880:	fa c8 fb b4 	sub	r8,sp,-1100
80008884:	08 9c       	mov	r12,r4
80008886:	1a d8       	st.w	--sp,r8
80008888:	fa c8 f9 40 	sub	r8,sp,-1728
8000888c:	fa c9 ff b4 	sub	r9,sp,-76
80008890:	fe b0 f7 b2 	rcall	800077f4 <get_arg>
80008894:	2f dd       	sub	sp,-12
80008896:	f8 ea 00 00 	ld.d	r10,r12[0]
8000889a:	fa eb 00 00 	st.d	sp[0],r10
8000889e:	30 08       	mov	r8,0
800088a0:	e0 8f 03 de 	bral	8000905c <_vfprintf_r+0x1538>
800088a4:	ee ca ff ff 	sub	r10,r7,-1
800088a8:	10 37       	cp.w	r7,r8
800088aa:	c0 b4       	brge	800088c0 <_vfprintf_r+0xd9c>
800088ac:	fa c9 f9 44 	sub	r9,sp,-1724
800088b0:	14 97       	mov	r7,r10
800088b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088b6:	ec ea fd 88 	ld.d	r10,r6[-632]
800088ba:	fa eb 00 00 	st.d	sp[0],r10
800088be:	c1 88       	rjmp	800088ee <_vfprintf_r+0xdca>
800088c0:	41 09       	lddsp	r9,sp[0x40]
800088c2:	59 f8       	cp.w	r8,31
800088c4:	e0 89 00 18 	brgt	800088f4 <_vfprintf_r+0xdd0>
800088c8:	f2 e6 00 00 	ld.d	r6,r9[0]
800088cc:	f2 cb ff f8 	sub	r11,r9,-8
800088d0:	fa e7 00 00 	st.d	sp[0],r6
800088d4:	51 0b       	stdsp	sp[0x40],r11
800088d6:	fa c6 f9 44 	sub	r6,sp,-1724
800088da:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088de:	fa e6 00 00 	ld.d	r6,sp[0]
800088e2:	f2 e7 fd 88 	st.d	r9[-632],r6
800088e6:	2f f8       	sub	r8,-1
800088e8:	14 97       	mov	r7,r10
800088ea:	fb 48 06 b4 	st.w	sp[1716],r8
800088ee:	40 38       	lddsp	r8,sp[0xc]
800088f0:	e0 8f 03 b6 	bral	8000905c <_vfprintf_r+0x1538>
800088f4:	f2 e6 00 00 	ld.d	r6,r9[0]
800088f8:	40 38       	lddsp	r8,sp[0xc]
800088fa:	fa e7 00 00 	st.d	sp[0],r6
800088fe:	2f 89       	sub	r9,-8
80008900:	14 97       	mov	r7,r10
80008902:	51 09       	stdsp	sp[0x40],r9
80008904:	e0 8f 03 ac 	bral	8000905c <_vfprintf_r+0x1538>
80008908:	ed b5 00 04 	bld	r5,0x4
8000890c:	c1 61       	brne	80008938 <_vfprintf_r+0xe14>
8000890e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008912:	40 3e       	lddsp	lr,sp[0xc]
80008914:	58 0e       	cp.w	lr,0
80008916:	c0 80       	breq	80008926 <_vfprintf_r+0xe02>
80008918:	10 36       	cp.w	r6,r8
8000891a:	c6 74       	brge	800089e8 <_vfprintf_r+0xec4>
8000891c:	fa cc f9 44 	sub	r12,sp,-1724
80008920:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008924:	c8 08       	rjmp	80008a24 <_vfprintf_r+0xf00>
80008926:	ee ca ff ff 	sub	r10,r7,-1
8000892a:	10 37       	cp.w	r7,r8
8000892c:	c7 f4       	brge	80008a2a <_vfprintf_r+0xf06>
8000892e:	fa cb f9 44 	sub	r11,sp,-1724
80008932:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008936:	c7 68       	rjmp	80008a22 <_vfprintf_r+0xefe>
80008938:	ed b5 00 06 	bld	r5,0x6
8000893c:	c4 a1       	brne	800089d0 <_vfprintf_r+0xeac>
8000893e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008942:	40 3c       	lddsp	r12,sp[0xc]
80008944:	58 0c       	cp.w	r12,0
80008946:	c1 d0       	breq	80008980 <_vfprintf_r+0xe5c>
80008948:	10 36       	cp.w	r6,r8
8000894a:	c0 64       	brge	80008956 <_vfprintf_r+0xe32>
8000894c:	fa cb f9 44 	sub	r11,sp,-1724
80008950:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008954:	c1 f8       	rjmp	80008992 <_vfprintf_r+0xe6e>
80008956:	fa c8 f9 50 	sub	r8,sp,-1712
8000895a:	1a d8       	st.w	--sp,r8
8000895c:	fa c8 fa b8 	sub	r8,sp,-1352
80008960:	1a d8       	st.w	--sp,r8
80008962:	fa c8 fb b4 	sub	r8,sp,-1100
80008966:	1a d8       	st.w	--sp,r8
80008968:	fa c8 f9 40 	sub	r8,sp,-1728
8000896c:	fa c9 ff b4 	sub	r9,sp,-76
80008970:	04 9a       	mov	r10,r2
80008972:	0c 9b       	mov	r11,r6
80008974:	08 9c       	mov	r12,r4
80008976:	fe b0 f7 3f 	rcall	800077f4 <get_arg>
8000897a:	2f dd       	sub	sp,-12
8000897c:	98 18       	ld.sh	r8,r12[0x2]
8000897e:	c2 68       	rjmp	800089ca <_vfprintf_r+0xea6>
80008980:	ee ca ff ff 	sub	r10,r7,-1
80008984:	10 37       	cp.w	r7,r8
80008986:	c0 94       	brge	80008998 <_vfprintf_r+0xe74>
80008988:	fa c9 f9 44 	sub	r9,sp,-1724
8000898c:	14 97       	mov	r7,r10
8000898e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008992:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008996:	c1 a8       	rjmp	800089ca <_vfprintf_r+0xea6>
80008998:	41 09       	lddsp	r9,sp[0x40]
8000899a:	59 f8       	cp.w	r8,31
8000899c:	e0 89 00 13 	brgt	800089c2 <_vfprintf_r+0xe9e>
800089a0:	f2 cb ff fc 	sub	r11,r9,-4
800089a4:	51 0b       	stdsp	sp[0x40],r11
800089a6:	72 09       	ld.w	r9,r9[0x0]
800089a8:	fa c6 f9 44 	sub	r6,sp,-1724
800089ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800089b0:	2f f8       	sub	r8,-1
800089b2:	f7 49 fd 88 	st.w	r11[-632],r9
800089b6:	fb 48 06 b4 	st.w	sp[1716],r8
800089ba:	14 97       	mov	r7,r10
800089bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800089c0:	c0 58       	rjmp	800089ca <_vfprintf_r+0xea6>
800089c2:	92 18       	ld.sh	r8,r9[0x2]
800089c4:	14 97       	mov	r7,r10
800089c6:	2f c9       	sub	r9,-4
800089c8:	51 09       	stdsp	sp[0x40],r9
800089ca:	5c 78       	castu.h	r8
800089cc:	50 18       	stdsp	sp[0x4],r8
800089ce:	c4 68       	rjmp	80008a5a <_vfprintf_r+0xf36>
800089d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089d4:	40 3c       	lddsp	r12,sp[0xc]
800089d6:	58 0c       	cp.w	r12,0
800089d8:	c1 d0       	breq	80008a12 <_vfprintf_r+0xeee>
800089da:	10 36       	cp.w	r6,r8
800089dc:	c0 64       	brge	800089e8 <_vfprintf_r+0xec4>
800089de:	fa cb f9 44 	sub	r11,sp,-1724
800089e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089e6:	c1 f8       	rjmp	80008a24 <_vfprintf_r+0xf00>
800089e8:	fa c8 f9 50 	sub	r8,sp,-1712
800089ec:	1a d8       	st.w	--sp,r8
800089ee:	fa c8 fa b8 	sub	r8,sp,-1352
800089f2:	0c 9b       	mov	r11,r6
800089f4:	1a d8       	st.w	--sp,r8
800089f6:	fa c8 fb b4 	sub	r8,sp,-1100
800089fa:	04 9a       	mov	r10,r2
800089fc:	1a d8       	st.w	--sp,r8
800089fe:	08 9c       	mov	r12,r4
80008a00:	fa c8 f9 40 	sub	r8,sp,-1728
80008a04:	fa c9 ff b4 	sub	r9,sp,-76
80008a08:	fe b0 f6 f6 	rcall	800077f4 <get_arg>
80008a0c:	2f dd       	sub	sp,-12
80008a0e:	78 0b       	ld.w	r11,r12[0x0]
80008a10:	c2 48       	rjmp	80008a58 <_vfprintf_r+0xf34>
80008a12:	ee ca ff ff 	sub	r10,r7,-1
80008a16:	10 37       	cp.w	r7,r8
80008a18:	c0 94       	brge	80008a2a <_vfprintf_r+0xf06>
80008a1a:	fa c9 f9 44 	sub	r9,sp,-1724
80008a1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a22:	14 97       	mov	r7,r10
80008a24:	ec fb fd 88 	ld.w	r11,r6[-632]
80008a28:	c1 88       	rjmp	80008a58 <_vfprintf_r+0xf34>
80008a2a:	41 09       	lddsp	r9,sp[0x40]
80008a2c:	59 f8       	cp.w	r8,31
80008a2e:	e0 89 00 11 	brgt	80008a50 <_vfprintf_r+0xf2c>
80008a32:	f2 cb ff fc 	sub	r11,r9,-4
80008a36:	51 0b       	stdsp	sp[0x40],r11
80008a38:	fa c6 f9 44 	sub	r6,sp,-1724
80008a3c:	72 0b       	ld.w	r11,r9[0x0]
80008a3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a42:	f3 4b fd 88 	st.w	r9[-632],r11
80008a46:	2f f8       	sub	r8,-1
80008a48:	14 97       	mov	r7,r10
80008a4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008a4e:	c0 58       	rjmp	80008a58 <_vfprintf_r+0xf34>
80008a50:	72 0b       	ld.w	r11,r9[0x0]
80008a52:	14 97       	mov	r7,r10
80008a54:	2f c9       	sub	r9,-4
80008a56:	51 09       	stdsp	sp[0x40],r9
80008a58:	50 1b       	stdsp	sp[0x4],r11
80008a5a:	30 0e       	mov	lr,0
80008a5c:	50 0e       	stdsp	sp[0x0],lr
80008a5e:	1c 98       	mov	r8,lr
80008a60:	e0 8f 02 fe 	bral	8000905c <_vfprintf_r+0x1538>
80008a64:	50 a7       	stdsp	sp[0x28],r7
80008a66:	50 80       	stdsp	sp[0x20],r0
80008a68:	0c 97       	mov	r7,r6
80008a6a:	04 94       	mov	r4,r2
80008a6c:	06 96       	mov	r6,r3
80008a6e:	02 92       	mov	r2,r1
80008a70:	40 93       	lddsp	r3,sp[0x24]
80008a72:	40 41       	lddsp	r1,sp[0x10]
80008a74:	0e 99       	mov	r9,r7
80008a76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a7a:	40 3c       	lddsp	r12,sp[0xc]
80008a7c:	58 0c       	cp.w	r12,0
80008a7e:	c1 d0       	breq	80008ab8 <_vfprintf_r+0xf94>
80008a80:	10 36       	cp.w	r6,r8
80008a82:	c0 64       	brge	80008a8e <_vfprintf_r+0xf6a>
80008a84:	fa cb f9 44 	sub	r11,sp,-1724
80008a88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a8c:	c1 d8       	rjmp	80008ac6 <_vfprintf_r+0xfa2>
80008a8e:	fa c8 f9 50 	sub	r8,sp,-1712
80008a92:	1a d8       	st.w	--sp,r8
80008a94:	fa c8 fa b8 	sub	r8,sp,-1352
80008a98:	1a d8       	st.w	--sp,r8
80008a9a:	fa c8 fb b4 	sub	r8,sp,-1100
80008a9e:	1a d8       	st.w	--sp,r8
80008aa0:	fa c9 ff b4 	sub	r9,sp,-76
80008aa4:	fa c8 f9 40 	sub	r8,sp,-1728
80008aa8:	04 9a       	mov	r10,r2
80008aaa:	0c 9b       	mov	r11,r6
80008aac:	08 9c       	mov	r12,r4
80008aae:	fe b0 f6 a3 	rcall	800077f4 <get_arg>
80008ab2:	2f dd       	sub	sp,-12
80008ab4:	78 09       	ld.w	r9,r12[0x0]
80008ab6:	c2 18       	rjmp	80008af8 <_vfprintf_r+0xfd4>
80008ab8:	2f f7       	sub	r7,-1
80008aba:	10 39       	cp.w	r9,r8
80008abc:	c0 84       	brge	80008acc <_vfprintf_r+0xfa8>
80008abe:	fa ca f9 44 	sub	r10,sp,-1724
80008ac2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ac6:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008aca:	c1 78       	rjmp	80008af8 <_vfprintf_r+0xfd4>
80008acc:	41 09       	lddsp	r9,sp[0x40]
80008ace:	59 f8       	cp.w	r8,31
80008ad0:	e0 89 00 10 	brgt	80008af0 <_vfprintf_r+0xfcc>
80008ad4:	f2 ca ff fc 	sub	r10,r9,-4
80008ad8:	51 0a       	stdsp	sp[0x40],r10
80008ada:	fa c6 f9 44 	sub	r6,sp,-1724
80008ade:	72 09       	ld.w	r9,r9[0x0]
80008ae0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008ae4:	f5 49 fd 88 	st.w	r10[-632],r9
80008ae8:	2f f8       	sub	r8,-1
80008aea:	fb 48 06 b4 	st.w	sp[1716],r8
80008aee:	c0 58       	rjmp	80008af8 <_vfprintf_r+0xfd4>
80008af0:	f2 c8 ff fc 	sub	r8,r9,-4
80008af4:	51 08       	stdsp	sp[0x40],r8
80008af6:	72 09       	ld.w	r9,r9[0x0]
80008af8:	33 08       	mov	r8,48
80008afa:	fb 68 06 b8 	st.b	sp[1720],r8
80008afe:	37 88       	mov	r8,120
80008b00:	30 0e       	mov	lr,0
80008b02:	fb 68 06 b9 	st.b	sp[1721],r8
80008b06:	fe cc b2 9a 	sub	r12,pc,-19814
80008b0a:	50 19       	stdsp	sp[0x4],r9
80008b0c:	a1 b5       	sbr	r5,0x1
80008b0e:	50 0e       	stdsp	sp[0x0],lr
80008b10:	50 dc       	stdsp	sp[0x34],r12
80008b12:	30 28       	mov	r8,2
80008b14:	37 80       	mov	r0,120
80008b16:	e0 8f 02 a3 	bral	8000905c <_vfprintf_r+0x1538>
80008b1a:	50 a7       	stdsp	sp[0x28],r7
80008b1c:	50 80       	stdsp	sp[0x20],r0
80008b1e:	10 90       	mov	r0,r8
80008b20:	30 08       	mov	r8,0
80008b22:	fb 68 06 bb 	st.b	sp[1723],r8
80008b26:	0c 97       	mov	r7,r6
80008b28:	04 94       	mov	r4,r2
80008b2a:	06 96       	mov	r6,r3
80008b2c:	02 92       	mov	r2,r1
80008b2e:	40 93       	lddsp	r3,sp[0x24]
80008b30:	40 41       	lddsp	r1,sp[0x10]
80008b32:	0e 99       	mov	r9,r7
80008b34:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b38:	40 3b       	lddsp	r11,sp[0xc]
80008b3a:	58 0b       	cp.w	r11,0
80008b3c:	c1 d0       	breq	80008b76 <_vfprintf_r+0x1052>
80008b3e:	10 36       	cp.w	r6,r8
80008b40:	c0 64       	brge	80008b4c <_vfprintf_r+0x1028>
80008b42:	fa ca f9 44 	sub	r10,sp,-1724
80008b46:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b4a:	c1 d8       	rjmp	80008b84 <_vfprintf_r+0x1060>
80008b4c:	fa c8 f9 50 	sub	r8,sp,-1712
80008b50:	1a d8       	st.w	--sp,r8
80008b52:	fa c8 fa b8 	sub	r8,sp,-1352
80008b56:	1a d8       	st.w	--sp,r8
80008b58:	fa c8 fb b4 	sub	r8,sp,-1100
80008b5c:	0c 9b       	mov	r11,r6
80008b5e:	1a d8       	st.w	--sp,r8
80008b60:	04 9a       	mov	r10,r2
80008b62:	fa c8 f9 40 	sub	r8,sp,-1728
80008b66:	fa c9 ff b4 	sub	r9,sp,-76
80008b6a:	08 9c       	mov	r12,r4
80008b6c:	fe b0 f6 44 	rcall	800077f4 <get_arg>
80008b70:	2f dd       	sub	sp,-12
80008b72:	78 06       	ld.w	r6,r12[0x0]
80008b74:	c2 08       	rjmp	80008bb4 <_vfprintf_r+0x1090>
80008b76:	2f f7       	sub	r7,-1
80008b78:	10 39       	cp.w	r9,r8
80008b7a:	c0 84       	brge	80008b8a <_vfprintf_r+0x1066>
80008b7c:	fa c9 f9 44 	sub	r9,sp,-1724
80008b80:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b84:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008b88:	c1 68       	rjmp	80008bb4 <_vfprintf_r+0x1090>
80008b8a:	41 09       	lddsp	r9,sp[0x40]
80008b8c:	59 f8       	cp.w	r8,31
80008b8e:	e0 89 00 10 	brgt	80008bae <_vfprintf_r+0x108a>
80008b92:	f2 ca ff fc 	sub	r10,r9,-4
80008b96:	51 0a       	stdsp	sp[0x40],r10
80008b98:	72 06       	ld.w	r6,r9[0x0]
80008b9a:	fa ce f9 44 	sub	lr,sp,-1724
80008b9e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008ba2:	f3 46 fd 88 	st.w	r9[-632],r6
80008ba6:	2f f8       	sub	r8,-1
80008ba8:	fb 48 06 b4 	st.w	sp[1716],r8
80008bac:	c0 48       	rjmp	80008bb4 <_vfprintf_r+0x1090>
80008bae:	72 06       	ld.w	r6,r9[0x0]
80008bb0:	2f c9       	sub	r9,-4
80008bb2:	51 09       	stdsp	sp[0x40],r9
80008bb4:	40 2c       	lddsp	r12,sp[0x8]
80008bb6:	58 0c       	cp.w	r12,0
80008bb8:	c1 05       	brlt	80008bd8 <_vfprintf_r+0x10b4>
80008bba:	18 9a       	mov	r10,r12
80008bbc:	30 0b       	mov	r11,0
80008bbe:	0c 9c       	mov	r12,r6
80008bc0:	e0 a0 12 38 	rcall	8000b030 <memchr>
80008bc4:	e0 80 02 df 	breq	80009182 <_vfprintf_r+0x165e>
80008bc8:	f8 06 01 02 	sub	r2,r12,r6
80008bcc:	40 2b       	lddsp	r11,sp[0x8]
80008bce:	16 32       	cp.w	r2,r11
80008bd0:	e0 89 02 d9 	brgt	80009182 <_vfprintf_r+0x165e>
80008bd4:	e0 8f 02 d4 	bral	8000917c <_vfprintf_r+0x1658>
80008bd8:	30 0a       	mov	r10,0
80008bda:	0c 9c       	mov	r12,r6
80008bdc:	50 2a       	stdsp	sp[0x8],r10
80008bde:	e0 a0 15 99 	rcall	8000b710 <strlen>
80008be2:	18 92       	mov	r2,r12
80008be4:	e0 8f 02 d2 	bral	80009188 <_vfprintf_r+0x1664>
80008be8:	50 a7       	stdsp	sp[0x28],r7
80008bea:	50 80       	stdsp	sp[0x20],r0
80008bec:	0c 97       	mov	r7,r6
80008bee:	04 94       	mov	r4,r2
80008bf0:	06 96       	mov	r6,r3
80008bf2:	02 92       	mov	r2,r1
80008bf4:	40 93       	lddsp	r3,sp[0x24]
80008bf6:	10 90       	mov	r0,r8
80008bf8:	40 41       	lddsp	r1,sp[0x10]
80008bfa:	a5 a5       	sbr	r5,0x4
80008bfc:	c0 a8       	rjmp	80008c10 <_vfprintf_r+0x10ec>
80008bfe:	50 a7       	stdsp	sp[0x28],r7
80008c00:	50 80       	stdsp	sp[0x20],r0
80008c02:	0c 97       	mov	r7,r6
80008c04:	04 94       	mov	r4,r2
80008c06:	06 96       	mov	r6,r3
80008c08:	02 92       	mov	r2,r1
80008c0a:	40 93       	lddsp	r3,sp[0x24]
80008c0c:	10 90       	mov	r0,r8
80008c0e:	40 41       	lddsp	r1,sp[0x10]
80008c10:	ed b5 00 05 	bld	r5,0x5
80008c14:	c5 61       	brne	80008cc0 <_vfprintf_r+0x119c>
80008c16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c1a:	40 39       	lddsp	r9,sp[0xc]
80008c1c:	58 09       	cp.w	r9,0
80008c1e:	c2 10       	breq	80008c60 <_vfprintf_r+0x113c>
80008c20:	10 36       	cp.w	r6,r8
80008c22:	c0 74       	brge	80008c30 <_vfprintf_r+0x110c>
80008c24:	fa c8 f9 44 	sub	r8,sp,-1724
80008c28:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c2c:	c2 38       	rjmp	80008c72 <_vfprintf_r+0x114e>
80008c2e:	d7 03       	nop
80008c30:	fa c8 f9 50 	sub	r8,sp,-1712
80008c34:	1a d8       	st.w	--sp,r8
80008c36:	fa c8 fa b8 	sub	r8,sp,-1352
80008c3a:	1a d8       	st.w	--sp,r8
80008c3c:	fa c8 fb b4 	sub	r8,sp,-1100
80008c40:	1a d8       	st.w	--sp,r8
80008c42:	fa c8 f9 40 	sub	r8,sp,-1728
80008c46:	fa c9 ff b4 	sub	r9,sp,-76
80008c4a:	04 9a       	mov	r10,r2
80008c4c:	0c 9b       	mov	r11,r6
80008c4e:	08 9c       	mov	r12,r4
80008c50:	fe b0 f5 d2 	rcall	800077f4 <get_arg>
80008c54:	2f dd       	sub	sp,-12
80008c56:	f8 e8 00 00 	ld.d	r8,r12[0]
80008c5a:	fa e9 00 00 	st.d	sp[0],r8
80008c5e:	c2 e8       	rjmp	80008cba <_vfprintf_r+0x1196>
80008c60:	ee ca ff ff 	sub	r10,r7,-1
80008c64:	10 37       	cp.w	r7,r8
80008c66:	c0 b4       	brge	80008c7c <_vfprintf_r+0x1158>
80008c68:	fa c8 f9 44 	sub	r8,sp,-1724
80008c6c:	14 97       	mov	r7,r10
80008c6e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c72:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c76:	fa eb 00 00 	st.d	sp[0],r10
80008c7a:	c2 08       	rjmp	80008cba <_vfprintf_r+0x1196>
80008c7c:	41 09       	lddsp	r9,sp[0x40]
80008c7e:	59 f8       	cp.w	r8,31
80008c80:	e0 89 00 16 	brgt	80008cac <_vfprintf_r+0x1188>
80008c84:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c88:	f2 cb ff f8 	sub	r11,r9,-8
80008c8c:	fa e7 00 00 	st.d	sp[0],r6
80008c90:	51 0b       	stdsp	sp[0x40],r11
80008c92:	fa c6 f9 44 	sub	r6,sp,-1724
80008c96:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c9a:	fa e6 00 00 	ld.d	r6,sp[0]
80008c9e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ca2:	2f f8       	sub	r8,-1
80008ca4:	14 97       	mov	r7,r10
80008ca6:	fb 48 06 b4 	st.w	sp[1716],r8
80008caa:	c0 88       	rjmp	80008cba <_vfprintf_r+0x1196>
80008cac:	f2 e6 00 00 	ld.d	r6,r9[0]
80008cb0:	2f 89       	sub	r9,-8
80008cb2:	fa e7 00 00 	st.d	sp[0],r6
80008cb6:	51 09       	stdsp	sp[0x40],r9
80008cb8:	14 97       	mov	r7,r10
80008cba:	30 18       	mov	r8,1
80008cbc:	e0 8f 01 d0 	bral	8000905c <_vfprintf_r+0x1538>
80008cc0:	ed b5 00 04 	bld	r5,0x4
80008cc4:	c1 61       	brne	80008cf0 <_vfprintf_r+0x11cc>
80008cc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cca:	40 3e       	lddsp	lr,sp[0xc]
80008ccc:	58 0e       	cp.w	lr,0
80008cce:	c0 80       	breq	80008cde <_vfprintf_r+0x11ba>
80008cd0:	10 36       	cp.w	r6,r8
80008cd2:	c6 74       	brge	80008da0 <_vfprintf_r+0x127c>
80008cd4:	fa cc f9 44 	sub	r12,sp,-1724
80008cd8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cdc:	c8 08       	rjmp	80008ddc <_vfprintf_r+0x12b8>
80008cde:	ee ca ff ff 	sub	r10,r7,-1
80008ce2:	10 37       	cp.w	r7,r8
80008ce4:	c7 f4       	brge	80008de2 <_vfprintf_r+0x12be>
80008ce6:	fa cb f9 44 	sub	r11,sp,-1724
80008cea:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cee:	c7 68       	rjmp	80008dda <_vfprintf_r+0x12b6>
80008cf0:	ed b5 00 06 	bld	r5,0x6
80008cf4:	c4 a1       	brne	80008d88 <_vfprintf_r+0x1264>
80008cf6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cfa:	40 3c       	lddsp	r12,sp[0xc]
80008cfc:	58 0c       	cp.w	r12,0
80008cfe:	c1 d0       	breq	80008d38 <_vfprintf_r+0x1214>
80008d00:	10 36       	cp.w	r6,r8
80008d02:	c0 64       	brge	80008d0e <_vfprintf_r+0x11ea>
80008d04:	fa cb f9 44 	sub	r11,sp,-1724
80008d08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d0c:	c1 f8       	rjmp	80008d4a <_vfprintf_r+0x1226>
80008d0e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d12:	1a d8       	st.w	--sp,r8
80008d14:	fa c8 fa b8 	sub	r8,sp,-1352
80008d18:	1a d8       	st.w	--sp,r8
80008d1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d1e:	1a d8       	st.w	--sp,r8
80008d20:	fa c8 f9 40 	sub	r8,sp,-1728
80008d24:	fa c9 ff b4 	sub	r9,sp,-76
80008d28:	04 9a       	mov	r10,r2
80008d2a:	0c 9b       	mov	r11,r6
80008d2c:	08 9c       	mov	r12,r4
80008d2e:	fe b0 f5 63 	rcall	800077f4 <get_arg>
80008d32:	2f dd       	sub	sp,-12
80008d34:	98 18       	ld.sh	r8,r12[0x2]
80008d36:	c2 68       	rjmp	80008d82 <_vfprintf_r+0x125e>
80008d38:	ee ca ff ff 	sub	r10,r7,-1
80008d3c:	10 37       	cp.w	r7,r8
80008d3e:	c0 94       	brge	80008d50 <_vfprintf_r+0x122c>
80008d40:	fa c9 f9 44 	sub	r9,sp,-1724
80008d44:	14 97       	mov	r7,r10
80008d46:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d4a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d4e:	c1 a8       	rjmp	80008d82 <_vfprintf_r+0x125e>
80008d50:	41 09       	lddsp	r9,sp[0x40]
80008d52:	59 f8       	cp.w	r8,31
80008d54:	e0 89 00 13 	brgt	80008d7a <_vfprintf_r+0x1256>
80008d58:	f2 cb ff fc 	sub	r11,r9,-4
80008d5c:	51 0b       	stdsp	sp[0x40],r11
80008d5e:	72 09       	ld.w	r9,r9[0x0]
80008d60:	fa c6 f9 44 	sub	r6,sp,-1724
80008d64:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d68:	2f f8       	sub	r8,-1
80008d6a:	f7 49 fd 88 	st.w	r11[-632],r9
80008d6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d72:	14 97       	mov	r7,r10
80008d74:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d78:	c0 58       	rjmp	80008d82 <_vfprintf_r+0x125e>
80008d7a:	92 18       	ld.sh	r8,r9[0x2]
80008d7c:	14 97       	mov	r7,r10
80008d7e:	2f c9       	sub	r9,-4
80008d80:	51 09       	stdsp	sp[0x40],r9
80008d82:	5c 78       	castu.h	r8
80008d84:	50 18       	stdsp	sp[0x4],r8
80008d86:	c4 68       	rjmp	80008e12 <_vfprintf_r+0x12ee>
80008d88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d8c:	40 3c       	lddsp	r12,sp[0xc]
80008d8e:	58 0c       	cp.w	r12,0
80008d90:	c1 d0       	breq	80008dca <_vfprintf_r+0x12a6>
80008d92:	10 36       	cp.w	r6,r8
80008d94:	c0 64       	brge	80008da0 <_vfprintf_r+0x127c>
80008d96:	fa cb f9 44 	sub	r11,sp,-1724
80008d9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d9e:	c1 f8       	rjmp	80008ddc <_vfprintf_r+0x12b8>
80008da0:	fa c8 f9 50 	sub	r8,sp,-1712
80008da4:	1a d8       	st.w	--sp,r8
80008da6:	fa c8 fa b8 	sub	r8,sp,-1352
80008daa:	0c 9b       	mov	r11,r6
80008dac:	1a d8       	st.w	--sp,r8
80008dae:	fa c8 fb b4 	sub	r8,sp,-1100
80008db2:	04 9a       	mov	r10,r2
80008db4:	1a d8       	st.w	--sp,r8
80008db6:	08 9c       	mov	r12,r4
80008db8:	fa c8 f9 40 	sub	r8,sp,-1728
80008dbc:	fa c9 ff b4 	sub	r9,sp,-76
80008dc0:	fe b0 f5 1a 	rcall	800077f4 <get_arg>
80008dc4:	2f dd       	sub	sp,-12
80008dc6:	78 0b       	ld.w	r11,r12[0x0]
80008dc8:	c2 48       	rjmp	80008e10 <_vfprintf_r+0x12ec>
80008dca:	ee ca ff ff 	sub	r10,r7,-1
80008dce:	10 37       	cp.w	r7,r8
80008dd0:	c0 94       	brge	80008de2 <_vfprintf_r+0x12be>
80008dd2:	fa c9 f9 44 	sub	r9,sp,-1724
80008dd6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dda:	14 97       	mov	r7,r10
80008ddc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008de0:	c1 88       	rjmp	80008e10 <_vfprintf_r+0x12ec>
80008de2:	41 09       	lddsp	r9,sp[0x40]
80008de4:	59 f8       	cp.w	r8,31
80008de6:	e0 89 00 11 	brgt	80008e08 <_vfprintf_r+0x12e4>
80008dea:	f2 cb ff fc 	sub	r11,r9,-4
80008dee:	51 0b       	stdsp	sp[0x40],r11
80008df0:	fa c6 f9 44 	sub	r6,sp,-1724
80008df4:	72 0b       	ld.w	r11,r9[0x0]
80008df6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dfa:	f3 4b fd 88 	st.w	r9[-632],r11
80008dfe:	2f f8       	sub	r8,-1
80008e00:	14 97       	mov	r7,r10
80008e02:	fb 48 06 b4 	st.w	sp[1716],r8
80008e06:	c0 58       	rjmp	80008e10 <_vfprintf_r+0x12ec>
80008e08:	72 0b       	ld.w	r11,r9[0x0]
80008e0a:	14 97       	mov	r7,r10
80008e0c:	2f c9       	sub	r9,-4
80008e0e:	51 09       	stdsp	sp[0x40],r9
80008e10:	50 1b       	stdsp	sp[0x4],r11
80008e12:	30 0e       	mov	lr,0
80008e14:	30 18       	mov	r8,1
80008e16:	50 0e       	stdsp	sp[0x0],lr
80008e18:	c2 29       	rjmp	8000905c <_vfprintf_r+0x1538>
80008e1a:	50 a7       	stdsp	sp[0x28],r7
80008e1c:	50 80       	stdsp	sp[0x20],r0
80008e1e:	0c 97       	mov	r7,r6
80008e20:	04 94       	mov	r4,r2
80008e22:	06 96       	mov	r6,r3
80008e24:	02 92       	mov	r2,r1
80008e26:	fe cc b5 ba 	sub	r12,pc,-19014
80008e2a:	40 93       	lddsp	r3,sp[0x24]
80008e2c:	10 90       	mov	r0,r8
80008e2e:	40 41       	lddsp	r1,sp[0x10]
80008e30:	50 dc       	stdsp	sp[0x34],r12
80008e32:	ed b5 00 05 	bld	r5,0x5
80008e36:	c5 51       	brne	80008ee0 <_vfprintf_r+0x13bc>
80008e38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e3c:	40 3b       	lddsp	r11,sp[0xc]
80008e3e:	58 0b       	cp.w	r11,0
80008e40:	c2 20       	breq	80008e84 <_vfprintf_r+0x1360>
80008e42:	10 36       	cp.w	r6,r8
80008e44:	c0 a4       	brge	80008e58 <_vfprintf_r+0x1334>
80008e46:	fa ca f9 44 	sub	r10,sp,-1724
80008e4a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e4e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e52:	fa e9 00 00 	st.d	sp[0],r8
80008e56:	cf 28       	rjmp	8000903a <_vfprintf_r+0x1516>
80008e58:	fa c8 f9 50 	sub	r8,sp,-1712
80008e5c:	1a d8       	st.w	--sp,r8
80008e5e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e62:	04 9a       	mov	r10,r2
80008e64:	1a d8       	st.w	--sp,r8
80008e66:	0c 9b       	mov	r11,r6
80008e68:	fa c8 fb b4 	sub	r8,sp,-1100
80008e6c:	08 9c       	mov	r12,r4
80008e6e:	1a d8       	st.w	--sp,r8
80008e70:	fa c8 f9 40 	sub	r8,sp,-1728
80008e74:	fa c9 ff b4 	sub	r9,sp,-76
80008e78:	fe b0 f4 be 	rcall	800077f4 <get_arg>
80008e7c:	2f dd       	sub	sp,-12
80008e7e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e82:	c0 c8       	rjmp	80008e9a <_vfprintf_r+0x1376>
80008e84:	ee ca ff ff 	sub	r10,r7,-1
80008e88:	10 37       	cp.w	r7,r8
80008e8a:	c0 b4       	brge	80008ea0 <_vfprintf_r+0x137c>
80008e8c:	fa c9 f9 44 	sub	r9,sp,-1724
80008e90:	14 97       	mov	r7,r10
80008e92:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e96:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e9a:	fa eb 00 00 	st.d	sp[0],r10
80008e9e:	cc e8       	rjmp	8000903a <_vfprintf_r+0x1516>
80008ea0:	41 09       	lddsp	r9,sp[0x40]
80008ea2:	59 f8       	cp.w	r8,31
80008ea4:	e0 89 00 16 	brgt	80008ed0 <_vfprintf_r+0x13ac>
80008ea8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008eac:	f2 cb ff f8 	sub	r11,r9,-8
80008eb0:	fa e7 00 00 	st.d	sp[0],r6
80008eb4:	51 0b       	stdsp	sp[0x40],r11
80008eb6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eba:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ebe:	fa e6 00 00 	ld.d	r6,sp[0]
80008ec2:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ec6:	2f f8       	sub	r8,-1
80008ec8:	14 97       	mov	r7,r10
80008eca:	fb 48 06 b4 	st.w	sp[1716],r8
80008ece:	cb 68       	rjmp	8000903a <_vfprintf_r+0x1516>
80008ed0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ed4:	2f 89       	sub	r9,-8
80008ed6:	fa e7 00 00 	st.d	sp[0],r6
80008eda:	51 09       	stdsp	sp[0x40],r9
80008edc:	14 97       	mov	r7,r10
80008ede:	ca e8       	rjmp	8000903a <_vfprintf_r+0x1516>
80008ee0:	ed b5 00 04 	bld	r5,0x4
80008ee4:	c1 71       	brne	80008f12 <_vfprintf_r+0x13ee>
80008ee6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eea:	40 3e       	lddsp	lr,sp[0xc]
80008eec:	58 0e       	cp.w	lr,0
80008eee:	c0 80       	breq	80008efe <_vfprintf_r+0x13da>
80008ef0:	10 36       	cp.w	r6,r8
80008ef2:	c6 94       	brge	80008fc4 <_vfprintf_r+0x14a0>
80008ef4:	fa cc f9 44 	sub	r12,sp,-1724
80008ef8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008efc:	c8 28       	rjmp	80009000 <_vfprintf_r+0x14dc>
80008efe:	ee ca ff ff 	sub	r10,r7,-1
80008f02:	10 37       	cp.w	r7,r8
80008f04:	e0 84 00 81 	brge	80009006 <_vfprintf_r+0x14e2>
80008f08:	fa cb f9 44 	sub	r11,sp,-1724
80008f0c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f10:	c7 78       	rjmp	80008ffe <_vfprintf_r+0x14da>
80008f12:	ed b5 00 06 	bld	r5,0x6
80008f16:	c4 b1       	brne	80008fac <_vfprintf_r+0x1488>
80008f18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f1c:	40 3c       	lddsp	r12,sp[0xc]
80008f1e:	58 0c       	cp.w	r12,0
80008f20:	c1 d0       	breq	80008f5a <_vfprintf_r+0x1436>
80008f22:	10 36       	cp.w	r6,r8
80008f24:	c0 64       	brge	80008f30 <_vfprintf_r+0x140c>
80008f26:	fa cb f9 44 	sub	r11,sp,-1724
80008f2a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f2e:	c1 f8       	rjmp	80008f6c <_vfprintf_r+0x1448>
80008f30:	fa c8 f9 50 	sub	r8,sp,-1712
80008f34:	1a d8       	st.w	--sp,r8
80008f36:	fa c8 fa b8 	sub	r8,sp,-1352
80008f3a:	1a d8       	st.w	--sp,r8
80008f3c:	fa c8 fb b4 	sub	r8,sp,-1100
80008f40:	1a d8       	st.w	--sp,r8
80008f42:	fa c8 f9 40 	sub	r8,sp,-1728
80008f46:	fa c9 ff b4 	sub	r9,sp,-76
80008f4a:	04 9a       	mov	r10,r2
80008f4c:	0c 9b       	mov	r11,r6
80008f4e:	08 9c       	mov	r12,r4
80008f50:	fe b0 f4 52 	rcall	800077f4 <get_arg>
80008f54:	2f dd       	sub	sp,-12
80008f56:	98 18       	ld.sh	r8,r12[0x2]
80008f58:	c2 78       	rjmp	80008fa6 <_vfprintf_r+0x1482>
80008f5a:	ee ca ff ff 	sub	r10,r7,-1
80008f5e:	10 37       	cp.w	r7,r8
80008f60:	c0 a4       	brge	80008f74 <_vfprintf_r+0x1450>
80008f62:	fa c9 f9 44 	sub	r9,sp,-1724
80008f66:	14 97       	mov	r7,r10
80008f68:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f6c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f70:	c1 b8       	rjmp	80008fa6 <_vfprintf_r+0x1482>
80008f72:	d7 03       	nop
80008f74:	41 09       	lddsp	r9,sp[0x40]
80008f76:	59 f8       	cp.w	r8,31
80008f78:	e0 89 00 13 	brgt	80008f9e <_vfprintf_r+0x147a>
80008f7c:	f2 cb ff fc 	sub	r11,r9,-4
80008f80:	51 0b       	stdsp	sp[0x40],r11
80008f82:	72 09       	ld.w	r9,r9[0x0]
80008f84:	fa c6 f9 44 	sub	r6,sp,-1724
80008f88:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f8c:	2f f8       	sub	r8,-1
80008f8e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f92:	fb 48 06 b4 	st.w	sp[1716],r8
80008f96:	14 97       	mov	r7,r10
80008f98:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f9c:	c0 58       	rjmp	80008fa6 <_vfprintf_r+0x1482>
80008f9e:	92 18       	ld.sh	r8,r9[0x2]
80008fa0:	14 97       	mov	r7,r10
80008fa2:	2f c9       	sub	r9,-4
80008fa4:	51 09       	stdsp	sp[0x40],r9
80008fa6:	5c 78       	castu.h	r8
80008fa8:	50 18       	stdsp	sp[0x4],r8
80008faa:	c4 68       	rjmp	80009036 <_vfprintf_r+0x1512>
80008fac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fb0:	40 3c       	lddsp	r12,sp[0xc]
80008fb2:	58 0c       	cp.w	r12,0
80008fb4:	c1 d0       	breq	80008fee <_vfprintf_r+0x14ca>
80008fb6:	10 36       	cp.w	r6,r8
80008fb8:	c0 64       	brge	80008fc4 <_vfprintf_r+0x14a0>
80008fba:	fa cb f9 44 	sub	r11,sp,-1724
80008fbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fc2:	c1 f8       	rjmp	80009000 <_vfprintf_r+0x14dc>
80008fc4:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	fa c8 fa b8 	sub	r8,sp,-1352
80008fce:	0c 9b       	mov	r11,r6
80008fd0:	1a d8       	st.w	--sp,r8
80008fd2:	fa c8 fb b4 	sub	r8,sp,-1100
80008fd6:	04 9a       	mov	r10,r2
80008fd8:	1a d8       	st.w	--sp,r8
80008fda:	08 9c       	mov	r12,r4
80008fdc:	fa c8 f9 40 	sub	r8,sp,-1728
80008fe0:	fa c9 ff b4 	sub	r9,sp,-76
80008fe4:	fe b0 f4 08 	rcall	800077f4 <get_arg>
80008fe8:	2f dd       	sub	sp,-12
80008fea:	78 0b       	ld.w	r11,r12[0x0]
80008fec:	c2 48       	rjmp	80009034 <_vfprintf_r+0x1510>
80008fee:	ee ca ff ff 	sub	r10,r7,-1
80008ff2:	10 37       	cp.w	r7,r8
80008ff4:	c0 94       	brge	80009006 <_vfprintf_r+0x14e2>
80008ff6:	fa c9 f9 44 	sub	r9,sp,-1724
80008ffa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffe:	14 97       	mov	r7,r10
80009000:	ec fb fd 88 	ld.w	r11,r6[-632]
80009004:	c1 88       	rjmp	80009034 <_vfprintf_r+0x1510>
80009006:	41 09       	lddsp	r9,sp[0x40]
80009008:	59 f8       	cp.w	r8,31
8000900a:	e0 89 00 11 	brgt	8000902c <_vfprintf_r+0x1508>
8000900e:	f2 cb ff fc 	sub	r11,r9,-4
80009012:	51 0b       	stdsp	sp[0x40],r11
80009014:	fa c6 f9 44 	sub	r6,sp,-1724
80009018:	72 0b       	ld.w	r11,r9[0x0]
8000901a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000901e:	f3 4b fd 88 	st.w	r9[-632],r11
80009022:	2f f8       	sub	r8,-1
80009024:	14 97       	mov	r7,r10
80009026:	fb 48 06 b4 	st.w	sp[1716],r8
8000902a:	c0 58       	rjmp	80009034 <_vfprintf_r+0x1510>
8000902c:	72 0b       	ld.w	r11,r9[0x0]
8000902e:	14 97       	mov	r7,r10
80009030:	2f c9       	sub	r9,-4
80009032:	51 09       	stdsp	sp[0x40],r9
80009034:	50 1b       	stdsp	sp[0x4],r11
80009036:	30 0e       	mov	lr,0
80009038:	50 0e       	stdsp	sp[0x0],lr
8000903a:	40 08       	lddsp	r8,sp[0x0]
8000903c:	40 1c       	lddsp	r12,sp[0x4]
8000903e:	18 48       	or	r8,r12
80009040:	5f 19       	srne	r9
80009042:	0a 98       	mov	r8,r5
80009044:	eb e9 00 09 	and	r9,r5,r9
80009048:	a1 b8       	sbr	r8,0x1
8000904a:	58 09       	cp.w	r9,0
8000904c:	c0 70       	breq	8000905a <_vfprintf_r+0x1536>
8000904e:	10 95       	mov	r5,r8
80009050:	fb 60 06 b9 	st.b	sp[1721],r0
80009054:	33 08       	mov	r8,48
80009056:	fb 68 06 b8 	st.b	sp[1720],r8
8000905a:	30 28       	mov	r8,2
8000905c:	30 09       	mov	r9,0
8000905e:	fb 69 06 bb 	st.b	sp[1723],r9
80009062:	0a 99       	mov	r9,r5
80009064:	a7 d9       	cbr	r9,0x7
80009066:	40 2b       	lddsp	r11,sp[0x8]
80009068:	40 16       	lddsp	r6,sp[0x4]
8000906a:	58 0b       	cp.w	r11,0
8000906c:	5f 1a       	srne	r10
8000906e:	f2 05 17 40 	movge	r5,r9
80009072:	fa c2 f9 78 	sub	r2,sp,-1672
80009076:	40 09       	lddsp	r9,sp[0x0]
80009078:	0c 49       	or	r9,r6
8000907a:	5f 19       	srne	r9
8000907c:	f5 e9 10 09 	or	r9,r10,r9
80009080:	c5 c0       	breq	80009138 <_vfprintf_r+0x1614>
80009082:	30 19       	mov	r9,1
80009084:	f2 08 18 00 	cp.b	r8,r9
80009088:	c0 60       	breq	80009094 <_vfprintf_r+0x1570>
8000908a:	30 29       	mov	r9,2
8000908c:	f2 08 18 00 	cp.b	r8,r9
80009090:	c0 41       	brne	80009098 <_vfprintf_r+0x1574>
80009092:	c3 c8       	rjmp	8000910a <_vfprintf_r+0x15e6>
80009094:	04 96       	mov	r6,r2
80009096:	c3 08       	rjmp	800090f6 <_vfprintf_r+0x15d2>
80009098:	04 96       	mov	r6,r2
8000909a:	fa e8 00 00 	ld.d	r8,sp[0]
8000909e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800090a2:	2d 0a       	sub	r10,-48
800090a4:	0c fa       	st.b	--r6,r10
800090a6:	f0 0b 16 03 	lsr	r11,r8,0x3
800090aa:	f2 0c 16 03 	lsr	r12,r9,0x3
800090ae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800090b2:	18 99       	mov	r9,r12
800090b4:	16 98       	mov	r8,r11
800090b6:	58 08       	cp.w	r8,0
800090b8:	5c 29       	cpc	r9
800090ba:	cf 21       	brne	8000909e <_vfprintf_r+0x157a>
800090bc:	fa e9 00 00 	st.d	sp[0],r8
800090c0:	ed b5 00 00 	bld	r5,0x0
800090c4:	c4 51       	brne	8000914e <_vfprintf_r+0x162a>
800090c6:	33 09       	mov	r9,48
800090c8:	f2 0a 18 00 	cp.b	r10,r9
800090cc:	c4 10       	breq	8000914e <_vfprintf_r+0x162a>
800090ce:	0c f9       	st.b	--r6,r9
800090d0:	c3 f8       	rjmp	8000914e <_vfprintf_r+0x162a>
800090d2:	fa ea 00 00 	ld.d	r10,sp[0]
800090d6:	30 a8       	mov	r8,10
800090d8:	30 09       	mov	r9,0
800090da:	e0 a0 1a 19 	rcall	8000c50c <__avr32_umod64>
800090de:	30 a8       	mov	r8,10
800090e0:	2d 0a       	sub	r10,-48
800090e2:	30 09       	mov	r9,0
800090e4:	ac 8a       	st.b	r6[0x0],r10
800090e6:	fa ea 00 00 	ld.d	r10,sp[0]
800090ea:	e0 a0 18 df 	rcall	8000c2a8 <__avr32_udiv64>
800090ee:	16 99       	mov	r9,r11
800090f0:	14 98       	mov	r8,r10
800090f2:	fa e9 00 00 	st.d	sp[0],r8
800090f6:	20 16       	sub	r6,1
800090f8:	fa ea 00 00 	ld.d	r10,sp[0]
800090fc:	58 9a       	cp.w	r10,9
800090fe:	5c 2b       	cpc	r11
80009100:	fe 9b ff e9 	brhi	800090d2 <_vfprintf_r+0x15ae>
80009104:	1b f8       	ld.ub	r8,sp[0x7]
80009106:	2d 08       	sub	r8,-48
80009108:	c2 08       	rjmp	80009148 <_vfprintf_r+0x1624>
8000910a:	04 96       	mov	r6,r2
8000910c:	fa e8 00 00 	ld.d	r8,sp[0]
80009110:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009114:	40 de       	lddsp	lr,sp[0x34]
80009116:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000911a:	0c fa       	st.b	--r6,r10
8000911c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009120:	f0 0a 16 04 	lsr	r10,r8,0x4
80009124:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009128:	16 99       	mov	r9,r11
8000912a:	14 98       	mov	r8,r10
8000912c:	58 08       	cp.w	r8,0
8000912e:	5c 29       	cpc	r9
80009130:	cf 01       	brne	80009110 <_vfprintf_r+0x15ec>
80009132:	fa e9 00 00 	st.d	sp[0],r8
80009136:	c0 c8       	rjmp	8000914e <_vfprintf_r+0x162a>
80009138:	58 08       	cp.w	r8,0
8000913a:	c0 91       	brne	8000914c <_vfprintf_r+0x1628>
8000913c:	ed b5 00 00 	bld	r5,0x0
80009140:	c0 61       	brne	8000914c <_vfprintf_r+0x1628>
80009142:	fa c6 f9 79 	sub	r6,sp,-1671
80009146:	33 08       	mov	r8,48
80009148:	ac 88       	st.b	r6[0x0],r8
8000914a:	c0 28       	rjmp	8000914e <_vfprintf_r+0x162a>
8000914c:	04 96       	mov	r6,r2
8000914e:	0c 12       	sub	r2,r6
80009150:	c1 c8       	rjmp	80009188 <_vfprintf_r+0x1664>
80009152:	50 a7       	stdsp	sp[0x28],r7
80009154:	50 80       	stdsp	sp[0x20],r0
80009156:	40 93       	lddsp	r3,sp[0x24]
80009158:	0c 97       	mov	r7,r6
8000915a:	10 90       	mov	r0,r8
8000915c:	04 94       	mov	r4,r2
8000915e:	40 41       	lddsp	r1,sp[0x10]
80009160:	58 08       	cp.w	r8,0
80009162:	e0 80 04 4f 	breq	80009a00 <_vfprintf_r+0x1edc>
80009166:	fb 68 06 60 	st.b	sp[1632],r8
8000916a:	30 0c       	mov	r12,0
8000916c:	30 08       	mov	r8,0
8000916e:	30 12       	mov	r2,1
80009170:	fb 68 06 bb 	st.b	sp[1723],r8
80009174:	50 2c       	stdsp	sp[0x8],r12
80009176:	fa c6 f9 a0 	sub	r6,sp,-1632
8000917a:	c0 78       	rjmp	80009188 <_vfprintf_r+0x1664>
8000917c:	30 0b       	mov	r11,0
8000917e:	50 2b       	stdsp	sp[0x8],r11
80009180:	c0 48       	rjmp	80009188 <_vfprintf_r+0x1664>
80009182:	40 22       	lddsp	r2,sp[0x8]
80009184:	30 0a       	mov	r10,0
80009186:	50 2a       	stdsp	sp[0x8],r10
80009188:	40 29       	lddsp	r9,sp[0x8]
8000918a:	e4 09 0c 49 	max	r9,r2,r9
8000918e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009192:	50 39       	stdsp	sp[0xc],r9
80009194:	0a 9e       	mov	lr,r5
80009196:	30 09       	mov	r9,0
80009198:	e2 1e 00 02 	andl	lr,0x2,COH
8000919c:	f2 08 18 00 	cp.b	r8,r9
800091a0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800091a4:	f7 b8 01 ff 	subne	r8,-1
800091a8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800091ac:	0a 9b       	mov	r11,r5
800091ae:	58 0e       	cp.w	lr,0
800091b0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800091b4:	f7 bc 01 fe 	subne	r12,-2
800091b8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800091bc:	e2 1b 00 84 	andl	r11,0x84,COH
800091c0:	50 fe       	stdsp	sp[0x3c],lr
800091c2:	50 9b       	stdsp	sp[0x24],r11
800091c4:	c4 71       	brne	80009252 <_vfprintf_r+0x172e>
800091c6:	40 8a       	lddsp	r10,sp[0x20]
800091c8:	40 39       	lddsp	r9,sp[0xc]
800091ca:	12 1a       	sub	r10,r9
800091cc:	50 4a       	stdsp	sp[0x10],r10
800091ce:	58 0a       	cp.w	r10,0
800091d0:	e0 89 00 20 	brgt	80009210 <_vfprintf_r+0x16ec>
800091d4:	c3 f8       	rjmp	80009252 <_vfprintf_r+0x172e>
800091d6:	2f 09       	sub	r9,-16
800091d8:	2f f8       	sub	r8,-1
800091da:	fe ce b9 56 	sub	lr,pc,-18090
800091de:	31 0c       	mov	r12,16
800091e0:	fb 49 06 90 	st.w	sp[1680],r9
800091e4:	87 0e       	st.w	r3[0x0],lr
800091e6:	87 1c       	st.w	r3[0x4],r12
800091e8:	fb 48 06 8c 	st.w	sp[1676],r8
800091ec:	58 78       	cp.w	r8,7
800091ee:	e0 89 00 04 	brgt	800091f6 <_vfprintf_r+0x16d2>
800091f2:	2f 83       	sub	r3,-8
800091f4:	c0 b8       	rjmp	8000920a <_vfprintf_r+0x16e6>
800091f6:	fa ca f9 78 	sub	r10,sp,-1672
800091fa:	02 9b       	mov	r11,r1
800091fc:	08 9c       	mov	r12,r4
800091fe:	fe b0 f4 85 	rcall	80007b08 <__sprint_r>
80009202:	e0 81 04 10 	brne	80009a22 <_vfprintf_r+0x1efe>
80009206:	fa c3 f9 e0 	sub	r3,sp,-1568
8000920a:	40 4b       	lddsp	r11,sp[0x10]
8000920c:	21 0b       	sub	r11,16
8000920e:	50 4b       	stdsp	sp[0x10],r11
80009210:	fa f9 06 90 	ld.w	r9,sp[1680]
80009214:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009218:	fe ca b9 94 	sub	r10,pc,-18028
8000921c:	40 4e       	lddsp	lr,sp[0x10]
8000921e:	59 0e       	cp.w	lr,16
80009220:	fe 99 ff db 	brgt	800091d6 <_vfprintf_r+0x16b2>
80009224:	1c 09       	add	r9,lr
80009226:	2f f8       	sub	r8,-1
80009228:	87 0a       	st.w	r3[0x0],r10
8000922a:	fb 49 06 90 	st.w	sp[1680],r9
8000922e:	87 1e       	st.w	r3[0x4],lr
80009230:	fb 48 06 8c 	st.w	sp[1676],r8
80009234:	58 78       	cp.w	r8,7
80009236:	e0 89 00 04 	brgt	8000923e <_vfprintf_r+0x171a>
8000923a:	2f 83       	sub	r3,-8
8000923c:	c0 b8       	rjmp	80009252 <_vfprintf_r+0x172e>
8000923e:	fa ca f9 78 	sub	r10,sp,-1672
80009242:	02 9b       	mov	r11,r1
80009244:	08 9c       	mov	r12,r4
80009246:	fe b0 f4 61 	rcall	80007b08 <__sprint_r>
8000924a:	e0 81 03 ec 	brne	80009a22 <_vfprintf_r+0x1efe>
8000924e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009252:	30 09       	mov	r9,0
80009254:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009258:	f2 08 18 00 	cp.b	r8,r9
8000925c:	c1 f0       	breq	8000929a <_vfprintf_r+0x1776>
8000925e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009262:	fa c9 f9 45 	sub	r9,sp,-1723
80009266:	2f f8       	sub	r8,-1
80009268:	87 09       	st.w	r3[0x0],r9
8000926a:	fb 48 06 90 	st.w	sp[1680],r8
8000926e:	30 19       	mov	r9,1
80009270:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009274:	87 19       	st.w	r3[0x4],r9
80009276:	2f f8       	sub	r8,-1
80009278:	fb 48 06 8c 	st.w	sp[1676],r8
8000927c:	58 78       	cp.w	r8,7
8000927e:	e0 89 00 04 	brgt	80009286 <_vfprintf_r+0x1762>
80009282:	2f 83       	sub	r3,-8
80009284:	c0 b8       	rjmp	8000929a <_vfprintf_r+0x1776>
80009286:	fa ca f9 78 	sub	r10,sp,-1672
8000928a:	02 9b       	mov	r11,r1
8000928c:	08 9c       	mov	r12,r4
8000928e:	fe b0 f4 3d 	rcall	80007b08 <__sprint_r>
80009292:	e0 81 03 c8 	brne	80009a22 <_vfprintf_r+0x1efe>
80009296:	fa c3 f9 e0 	sub	r3,sp,-1568
8000929a:	40 fc       	lddsp	r12,sp[0x3c]
8000929c:	58 0c       	cp.w	r12,0
8000929e:	c1 f0       	breq	800092dc <_vfprintf_r+0x17b8>
800092a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800092a4:	fa c9 f9 48 	sub	r9,sp,-1720
800092a8:	2f e8       	sub	r8,-2
800092aa:	87 09       	st.w	r3[0x0],r9
800092ac:	fb 48 06 90 	st.w	sp[1680],r8
800092b0:	30 29       	mov	r9,2
800092b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092b6:	87 19       	st.w	r3[0x4],r9
800092b8:	2f f8       	sub	r8,-1
800092ba:	fb 48 06 8c 	st.w	sp[1676],r8
800092be:	58 78       	cp.w	r8,7
800092c0:	e0 89 00 04 	brgt	800092c8 <_vfprintf_r+0x17a4>
800092c4:	2f 83       	sub	r3,-8
800092c6:	c0 b8       	rjmp	800092dc <_vfprintf_r+0x17b8>
800092c8:	fa ca f9 78 	sub	r10,sp,-1672
800092cc:	02 9b       	mov	r11,r1
800092ce:	08 9c       	mov	r12,r4
800092d0:	fe b0 f4 1c 	rcall	80007b08 <__sprint_r>
800092d4:	e0 81 03 a7 	brne	80009a22 <_vfprintf_r+0x1efe>
800092d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800092dc:	40 9b       	lddsp	r11,sp[0x24]
800092de:	e0 4b 00 80 	cp.w	r11,128
800092e2:	c4 71       	brne	80009370 <_vfprintf_r+0x184c>
800092e4:	40 8a       	lddsp	r10,sp[0x20]
800092e6:	40 39       	lddsp	r9,sp[0xc]
800092e8:	12 1a       	sub	r10,r9
800092ea:	50 4a       	stdsp	sp[0x10],r10
800092ec:	58 0a       	cp.w	r10,0
800092ee:	e0 89 00 20 	brgt	8000932e <_vfprintf_r+0x180a>
800092f2:	c3 f8       	rjmp	80009370 <_vfprintf_r+0x184c>
800092f4:	2f 09       	sub	r9,-16
800092f6:	2f f8       	sub	r8,-1
800092f8:	fe ce ba 64 	sub	lr,pc,-17820
800092fc:	31 0c       	mov	r12,16
800092fe:	fb 49 06 90 	st.w	sp[1680],r9
80009302:	87 0e       	st.w	r3[0x0],lr
80009304:	87 1c       	st.w	r3[0x4],r12
80009306:	fb 48 06 8c 	st.w	sp[1676],r8
8000930a:	58 78       	cp.w	r8,7
8000930c:	e0 89 00 04 	brgt	80009314 <_vfprintf_r+0x17f0>
80009310:	2f 83       	sub	r3,-8
80009312:	c0 b8       	rjmp	80009328 <_vfprintf_r+0x1804>
80009314:	fa ca f9 78 	sub	r10,sp,-1672
80009318:	02 9b       	mov	r11,r1
8000931a:	08 9c       	mov	r12,r4
8000931c:	fe b0 f3 f6 	rcall	80007b08 <__sprint_r>
80009320:	e0 81 03 81 	brne	80009a22 <_vfprintf_r+0x1efe>
80009324:	fa c3 f9 e0 	sub	r3,sp,-1568
80009328:	40 4b       	lddsp	r11,sp[0x10]
8000932a:	21 0b       	sub	r11,16
8000932c:	50 4b       	stdsp	sp[0x10],r11
8000932e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009332:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009336:	fe ca ba a2 	sub	r10,pc,-17758
8000933a:	40 4e       	lddsp	lr,sp[0x10]
8000933c:	59 0e       	cp.w	lr,16
8000933e:	fe 99 ff db 	brgt	800092f4 <_vfprintf_r+0x17d0>
80009342:	1c 09       	add	r9,lr
80009344:	2f f8       	sub	r8,-1
80009346:	87 0a       	st.w	r3[0x0],r10
80009348:	fb 49 06 90 	st.w	sp[1680],r9
8000934c:	87 1e       	st.w	r3[0x4],lr
8000934e:	fb 48 06 8c 	st.w	sp[1676],r8
80009352:	58 78       	cp.w	r8,7
80009354:	e0 89 00 04 	brgt	8000935c <_vfprintf_r+0x1838>
80009358:	2f 83       	sub	r3,-8
8000935a:	c0 b8       	rjmp	80009370 <_vfprintf_r+0x184c>
8000935c:	fa ca f9 78 	sub	r10,sp,-1672
80009360:	02 9b       	mov	r11,r1
80009362:	08 9c       	mov	r12,r4
80009364:	fe b0 f3 d2 	rcall	80007b08 <__sprint_r>
80009368:	e0 81 03 5d 	brne	80009a22 <_vfprintf_r+0x1efe>
8000936c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009370:	40 2c       	lddsp	r12,sp[0x8]
80009372:	04 1c       	sub	r12,r2
80009374:	50 2c       	stdsp	sp[0x8],r12
80009376:	58 0c       	cp.w	r12,0
80009378:	e0 89 00 20 	brgt	800093b8 <_vfprintf_r+0x1894>
8000937c:	c3 f8       	rjmp	800093fa <_vfprintf_r+0x18d6>
8000937e:	2f 09       	sub	r9,-16
80009380:	2f f8       	sub	r8,-1
80009382:	fe cb ba ee 	sub	r11,pc,-17682
80009386:	31 0a       	mov	r10,16
80009388:	fb 49 06 90 	st.w	sp[1680],r9
8000938c:	87 0b       	st.w	r3[0x0],r11
8000938e:	87 1a       	st.w	r3[0x4],r10
80009390:	fb 48 06 8c 	st.w	sp[1676],r8
80009394:	58 78       	cp.w	r8,7
80009396:	e0 89 00 04 	brgt	8000939e <_vfprintf_r+0x187a>
8000939a:	2f 83       	sub	r3,-8
8000939c:	c0 b8       	rjmp	800093b2 <_vfprintf_r+0x188e>
8000939e:	fa ca f9 78 	sub	r10,sp,-1672
800093a2:	02 9b       	mov	r11,r1
800093a4:	08 9c       	mov	r12,r4
800093a6:	fe b0 f3 b1 	rcall	80007b08 <__sprint_r>
800093aa:	e0 81 03 3c 	brne	80009a22 <_vfprintf_r+0x1efe>
800093ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800093b2:	40 29       	lddsp	r9,sp[0x8]
800093b4:	21 09       	sub	r9,16
800093b6:	50 29       	stdsp	sp[0x8],r9
800093b8:	fa f9 06 90 	ld.w	r9,sp[1680]
800093bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093c0:	fe ca bb 2c 	sub	r10,pc,-17620
800093c4:	40 2e       	lddsp	lr,sp[0x8]
800093c6:	59 0e       	cp.w	lr,16
800093c8:	fe 99 ff db 	brgt	8000937e <_vfprintf_r+0x185a>
800093cc:	1c 09       	add	r9,lr
800093ce:	2f f8       	sub	r8,-1
800093d0:	87 0a       	st.w	r3[0x0],r10
800093d2:	fb 49 06 90 	st.w	sp[1680],r9
800093d6:	87 1e       	st.w	r3[0x4],lr
800093d8:	fb 48 06 8c 	st.w	sp[1676],r8
800093dc:	58 78       	cp.w	r8,7
800093de:	e0 89 00 04 	brgt	800093e6 <_vfprintf_r+0x18c2>
800093e2:	2f 83       	sub	r3,-8
800093e4:	c0 b8       	rjmp	800093fa <_vfprintf_r+0x18d6>
800093e6:	fa ca f9 78 	sub	r10,sp,-1672
800093ea:	02 9b       	mov	r11,r1
800093ec:	08 9c       	mov	r12,r4
800093ee:	fe b0 f3 8d 	rcall	80007b08 <__sprint_r>
800093f2:	e0 81 03 18 	brne	80009a22 <_vfprintf_r+0x1efe>
800093f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800093fa:	ed b5 00 08 	bld	r5,0x8
800093fe:	c0 b0       	breq	80009414 <_vfprintf_r+0x18f0>
80009400:	fa f8 06 90 	ld.w	r8,sp[1680]
80009404:	87 12       	st.w	r3[0x4],r2
80009406:	87 06       	st.w	r3[0x0],r6
80009408:	f0 02 00 02 	add	r2,r8,r2
8000940c:	fb 42 06 90 	st.w	sp[1680],r2
80009410:	e0 8f 01 d4 	bral	800097b8 <_vfprintf_r+0x1c94>
80009414:	e0 40 00 65 	cp.w	r0,101
80009418:	e0 8a 01 d6 	brle	800097c4 <_vfprintf_r+0x1ca0>
8000941c:	30 08       	mov	r8,0
8000941e:	30 09       	mov	r9,0
80009420:	40 5b       	lddsp	r11,sp[0x14]
80009422:	40 7a       	lddsp	r10,sp[0x1c]
80009424:	e0 a0 15 3b 	rcall	8000be9a <__avr32_f64_cmp_eq>
80009428:	c7 90       	breq	8000951a <_vfprintf_r+0x19f6>
8000942a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000942e:	fe c9 bb ae 	sub	r9,pc,-17490
80009432:	2f f8       	sub	r8,-1
80009434:	87 09       	st.w	r3[0x0],r9
80009436:	fb 48 06 90 	st.w	sp[1680],r8
8000943a:	30 19       	mov	r9,1
8000943c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009440:	87 19       	st.w	r3[0x4],r9
80009442:	2f f8       	sub	r8,-1
80009444:	fb 48 06 8c 	st.w	sp[1676],r8
80009448:	58 78       	cp.w	r8,7
8000944a:	e0 89 00 05 	brgt	80009454 <_vfprintf_r+0x1930>
8000944e:	2f 83       	sub	r3,-8
80009450:	c0 c8       	rjmp	80009468 <_vfprintf_r+0x1944>
80009452:	d7 03       	nop
80009454:	fa ca f9 78 	sub	r10,sp,-1672
80009458:	02 9b       	mov	r11,r1
8000945a:	08 9c       	mov	r12,r4
8000945c:	fe b0 f3 56 	rcall	80007b08 <__sprint_r>
80009460:	e0 81 02 e1 	brne	80009a22 <_vfprintf_r+0x1efe>
80009464:	fa c3 f9 e0 	sub	r3,sp,-1568
80009468:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000946c:	40 6c       	lddsp	r12,sp[0x18]
8000946e:	18 38       	cp.w	r8,r12
80009470:	c0 55       	brlt	8000947a <_vfprintf_r+0x1956>
80009472:	ed b5 00 00 	bld	r5,0x0
80009476:	e0 81 02 6b 	brne	8000994c <_vfprintf_r+0x1e28>
8000947a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000947e:	2f f8       	sub	r8,-1
80009480:	40 cb       	lddsp	r11,sp[0x30]
80009482:	fb 48 06 90 	st.w	sp[1680],r8
80009486:	30 19       	mov	r9,1
80009488:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000948c:	87 0b       	st.w	r3[0x0],r11
8000948e:	2f f8       	sub	r8,-1
80009490:	87 19       	st.w	r3[0x4],r9
80009492:	fb 48 06 8c 	st.w	sp[1676],r8
80009496:	58 78       	cp.w	r8,7
80009498:	e0 89 00 04 	brgt	800094a0 <_vfprintf_r+0x197c>
8000949c:	2f 83       	sub	r3,-8
8000949e:	c0 b8       	rjmp	800094b4 <_vfprintf_r+0x1990>
800094a0:	fa ca f9 78 	sub	r10,sp,-1672
800094a4:	02 9b       	mov	r11,r1
800094a6:	08 9c       	mov	r12,r4
800094a8:	fe b0 f3 30 	rcall	80007b08 <__sprint_r>
800094ac:	e0 81 02 bb 	brne	80009a22 <_vfprintf_r+0x1efe>
800094b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094b4:	40 66       	lddsp	r6,sp[0x18]
800094b6:	20 16       	sub	r6,1
800094b8:	58 06       	cp.w	r6,0
800094ba:	e0 89 00 1d 	brgt	800094f4 <_vfprintf_r+0x19d0>
800094be:	e0 8f 02 47 	bral	8000994c <_vfprintf_r+0x1e28>
800094c2:	2f 09       	sub	r9,-16
800094c4:	2f f8       	sub	r8,-1
800094c6:	fb 49 06 90 	st.w	sp[1680],r9
800094ca:	87 02       	st.w	r3[0x0],r2
800094cc:	87 10       	st.w	r3[0x4],r0
800094ce:	fb 48 06 8c 	st.w	sp[1676],r8
800094d2:	58 78       	cp.w	r8,7
800094d4:	e0 89 00 04 	brgt	800094dc <_vfprintf_r+0x19b8>
800094d8:	2f 83       	sub	r3,-8
800094da:	c0 b8       	rjmp	800094f0 <_vfprintf_r+0x19cc>
800094dc:	fa ca f9 78 	sub	r10,sp,-1672
800094e0:	02 9b       	mov	r11,r1
800094e2:	08 9c       	mov	r12,r4
800094e4:	fe b0 f3 12 	rcall	80007b08 <__sprint_r>
800094e8:	e0 81 02 9d 	brne	80009a22 <_vfprintf_r+0x1efe>
800094ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f0:	21 06       	sub	r6,16
800094f2:	c0 48       	rjmp	800094fa <_vfprintf_r+0x19d6>
800094f4:	fe c2 bc 60 	sub	r2,pc,-17312
800094f8:	31 00       	mov	r0,16
800094fa:	fa f9 06 90 	ld.w	r9,sp[1680]
800094fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009502:	fe ca bc 6e 	sub	r10,pc,-17298
80009506:	59 06       	cp.w	r6,16
80009508:	fe 99 ff dd 	brgt	800094c2 <_vfprintf_r+0x199e>
8000950c:	0c 09       	add	r9,r6
8000950e:	87 0a       	st.w	r3[0x0],r10
80009510:	fb 49 06 90 	st.w	sp[1680],r9
80009514:	2f f8       	sub	r8,-1
80009516:	87 16       	st.w	r3[0x4],r6
80009518:	c5 39       	rjmp	800097be <_vfprintf_r+0x1c9a>
8000951a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000951e:	58 0a       	cp.w	r10,0
80009520:	e0 89 00 92 	brgt	80009644 <_vfprintf_r+0x1b20>
80009524:	fa f8 06 90 	ld.w	r8,sp[1680]
80009528:	fe c9 bc a8 	sub	r9,pc,-17240
8000952c:	2f f8       	sub	r8,-1
8000952e:	87 09       	st.w	r3[0x0],r9
80009530:	fb 48 06 90 	st.w	sp[1680],r8
80009534:	30 19       	mov	r9,1
80009536:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000953a:	87 19       	st.w	r3[0x4],r9
8000953c:	2f f8       	sub	r8,-1
8000953e:	fb 48 06 8c 	st.w	sp[1676],r8
80009542:	58 78       	cp.w	r8,7
80009544:	e0 89 00 04 	brgt	8000954c <_vfprintf_r+0x1a28>
80009548:	2f 83       	sub	r3,-8
8000954a:	c0 b8       	rjmp	80009560 <_vfprintf_r+0x1a3c>
8000954c:	fa ca f9 78 	sub	r10,sp,-1672
80009550:	02 9b       	mov	r11,r1
80009552:	08 9c       	mov	r12,r4
80009554:	fe b0 f2 da 	rcall	80007b08 <__sprint_r>
80009558:	e0 81 02 65 	brne	80009a22 <_vfprintf_r+0x1efe>
8000955c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009560:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009564:	58 08       	cp.w	r8,0
80009566:	c0 81       	brne	80009576 <_vfprintf_r+0x1a52>
80009568:	40 6a       	lddsp	r10,sp[0x18]
8000956a:	58 0a       	cp.w	r10,0
8000956c:	c0 51       	brne	80009576 <_vfprintf_r+0x1a52>
8000956e:	ed b5 00 00 	bld	r5,0x0
80009572:	e0 81 01 ed 	brne	8000994c <_vfprintf_r+0x1e28>
80009576:	40 c9       	lddsp	r9,sp[0x30]
80009578:	fa f8 06 90 	ld.w	r8,sp[1680]
8000957c:	2f f8       	sub	r8,-1
8000957e:	87 09       	st.w	r3[0x0],r9
80009580:	fb 48 06 90 	st.w	sp[1680],r8
80009584:	30 19       	mov	r9,1
80009586:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000958a:	87 19       	st.w	r3[0x4],r9
8000958c:	2f f8       	sub	r8,-1
8000958e:	fb 48 06 8c 	st.w	sp[1676],r8
80009592:	58 78       	cp.w	r8,7
80009594:	e0 89 00 04 	brgt	8000959c <_vfprintf_r+0x1a78>
80009598:	2f 83       	sub	r3,-8
8000959a:	c0 b8       	rjmp	800095b0 <_vfprintf_r+0x1a8c>
8000959c:	fa ca f9 78 	sub	r10,sp,-1672
800095a0:	02 9b       	mov	r11,r1
800095a2:	08 9c       	mov	r12,r4
800095a4:	fe b0 f2 b2 	rcall	80007b08 <__sprint_r>
800095a8:	e0 81 02 3d 	brne	80009a22 <_vfprintf_r+0x1efe>
800095ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800095b0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800095b4:	5c 32       	neg	r2
800095b6:	58 02       	cp.w	r2,0
800095b8:	e0 89 00 1d 	brgt	800095f2 <_vfprintf_r+0x1ace>
800095bc:	c3 d8       	rjmp	80009636 <_vfprintf_r+0x1b12>
800095be:	2f 09       	sub	r9,-16
800095c0:	2f f8       	sub	r8,-1
800095c2:	31 0e       	mov	lr,16
800095c4:	fb 49 06 90 	st.w	sp[1680],r9
800095c8:	87 00       	st.w	r3[0x0],r0
800095ca:	87 1e       	st.w	r3[0x4],lr
800095cc:	fb 48 06 8c 	st.w	sp[1676],r8
800095d0:	58 78       	cp.w	r8,7
800095d2:	e0 89 00 04 	brgt	800095da <_vfprintf_r+0x1ab6>
800095d6:	2f 83       	sub	r3,-8
800095d8:	c0 b8       	rjmp	800095ee <_vfprintf_r+0x1aca>
800095da:	fa ca f9 78 	sub	r10,sp,-1672
800095de:	02 9b       	mov	r11,r1
800095e0:	08 9c       	mov	r12,r4
800095e2:	fe b0 f2 93 	rcall	80007b08 <__sprint_r>
800095e6:	e0 81 02 1e 	brne	80009a22 <_vfprintf_r+0x1efe>
800095ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ee:	21 02       	sub	r2,16
800095f0:	c0 38       	rjmp	800095f6 <_vfprintf_r+0x1ad2>
800095f2:	fe c0 bd 5e 	sub	r0,pc,-17058
800095f6:	fa f9 06 90 	ld.w	r9,sp[1680]
800095fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095fe:	fe ca bd 6a 	sub	r10,pc,-17046
80009602:	59 02       	cp.w	r2,16
80009604:	fe 99 ff dd 	brgt	800095be <_vfprintf_r+0x1a9a>
80009608:	04 09       	add	r9,r2
8000960a:	2f f8       	sub	r8,-1
8000960c:	87 0a       	st.w	r3[0x0],r10
8000960e:	fb 49 06 90 	st.w	sp[1680],r9
80009612:	87 12       	st.w	r3[0x4],r2
80009614:	fb 48 06 8c 	st.w	sp[1676],r8
80009618:	58 78       	cp.w	r8,7
8000961a:	e0 89 00 04 	brgt	80009622 <_vfprintf_r+0x1afe>
8000961e:	2f 83       	sub	r3,-8
80009620:	c0 b8       	rjmp	80009636 <_vfprintf_r+0x1b12>
80009622:	fa ca f9 78 	sub	r10,sp,-1672
80009626:	02 9b       	mov	r11,r1
80009628:	08 9c       	mov	r12,r4
8000962a:	fe b0 f2 6f 	rcall	80007b08 <__sprint_r>
8000962e:	e0 81 01 fa 	brne	80009a22 <_vfprintf_r+0x1efe>
80009632:	fa c3 f9 e0 	sub	r3,sp,-1568
80009636:	40 6c       	lddsp	r12,sp[0x18]
80009638:	fa f8 06 90 	ld.w	r8,sp[1680]
8000963c:	87 06       	st.w	r3[0x0],r6
8000963e:	87 1c       	st.w	r3[0x4],r12
80009640:	18 08       	add	r8,r12
80009642:	cb 98       	rjmp	800097b4 <_vfprintf_r+0x1c90>
80009644:	fa f9 06 90 	ld.w	r9,sp[1680]
80009648:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000964c:	40 6b       	lddsp	r11,sp[0x18]
8000964e:	16 3a       	cp.w	r10,r11
80009650:	c6 f5       	brlt	8000972e <_vfprintf_r+0x1c0a>
80009652:	16 09       	add	r9,r11
80009654:	2f f8       	sub	r8,-1
80009656:	87 06       	st.w	r3[0x0],r6
80009658:	fb 49 06 90 	st.w	sp[1680],r9
8000965c:	87 1b       	st.w	r3[0x4],r11
8000965e:	fb 48 06 8c 	st.w	sp[1676],r8
80009662:	58 78       	cp.w	r8,7
80009664:	e0 89 00 04 	brgt	8000966c <_vfprintf_r+0x1b48>
80009668:	2f 83       	sub	r3,-8
8000966a:	c0 b8       	rjmp	80009680 <_vfprintf_r+0x1b5c>
8000966c:	fa ca f9 78 	sub	r10,sp,-1672
80009670:	02 9b       	mov	r11,r1
80009672:	08 9c       	mov	r12,r4
80009674:	fe b0 f2 4a 	rcall	80007b08 <__sprint_r>
80009678:	e0 81 01 d5 	brne	80009a22 <_vfprintf_r+0x1efe>
8000967c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009680:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009684:	40 6a       	lddsp	r10,sp[0x18]
80009686:	14 16       	sub	r6,r10
80009688:	58 06       	cp.w	r6,0
8000968a:	e0 89 00 1c 	brgt	800096c2 <_vfprintf_r+0x1b9e>
8000968e:	c3 d8       	rjmp	80009708 <_vfprintf_r+0x1be4>
80009690:	2f 09       	sub	r9,-16
80009692:	2f f8       	sub	r8,-1
80009694:	fb 49 06 90 	st.w	sp[1680],r9
80009698:	87 02       	st.w	r3[0x0],r2
8000969a:	87 10       	st.w	r3[0x4],r0
8000969c:	fb 48 06 8c 	st.w	sp[1676],r8
800096a0:	58 78       	cp.w	r8,7
800096a2:	e0 89 00 04 	brgt	800096aa <_vfprintf_r+0x1b86>
800096a6:	2f 83       	sub	r3,-8
800096a8:	c0 b8       	rjmp	800096be <_vfprintf_r+0x1b9a>
800096aa:	fa ca f9 78 	sub	r10,sp,-1672
800096ae:	02 9b       	mov	r11,r1
800096b0:	08 9c       	mov	r12,r4
800096b2:	fe b0 f2 2b 	rcall	80007b08 <__sprint_r>
800096b6:	e0 81 01 b6 	brne	80009a22 <_vfprintf_r+0x1efe>
800096ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800096be:	21 06       	sub	r6,16
800096c0:	c0 48       	rjmp	800096c8 <_vfprintf_r+0x1ba4>
800096c2:	fe c2 be 2e 	sub	r2,pc,-16850
800096c6:	31 00       	mov	r0,16
800096c8:	fa f9 06 90 	ld.w	r9,sp[1680]
800096cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096d0:	fe ca be 3c 	sub	r10,pc,-16836
800096d4:	59 06       	cp.w	r6,16
800096d6:	fe 99 ff dd 	brgt	80009690 <_vfprintf_r+0x1b6c>
800096da:	0c 09       	add	r9,r6
800096dc:	2f f8       	sub	r8,-1
800096de:	87 0a       	st.w	r3[0x0],r10
800096e0:	fb 49 06 90 	st.w	sp[1680],r9
800096e4:	87 16       	st.w	r3[0x4],r6
800096e6:	fb 48 06 8c 	st.w	sp[1676],r8
800096ea:	58 78       	cp.w	r8,7
800096ec:	e0 89 00 04 	brgt	800096f4 <_vfprintf_r+0x1bd0>
800096f0:	2f 83       	sub	r3,-8
800096f2:	c0 b8       	rjmp	80009708 <_vfprintf_r+0x1be4>
800096f4:	fa ca f9 78 	sub	r10,sp,-1672
800096f8:	02 9b       	mov	r11,r1
800096fa:	08 9c       	mov	r12,r4
800096fc:	fe b0 f2 06 	rcall	80007b08 <__sprint_r>
80009700:	e0 81 01 91 	brne	80009a22 <_vfprintf_r+0x1efe>
80009704:	fa c3 f9 e0 	sub	r3,sp,-1568
80009708:	ed b5 00 00 	bld	r5,0x0
8000970c:	e0 81 01 20 	brne	8000994c <_vfprintf_r+0x1e28>
80009710:	40 c9       	lddsp	r9,sp[0x30]
80009712:	fa f8 06 90 	ld.w	r8,sp[1680]
80009716:	2f f8       	sub	r8,-1
80009718:	87 09       	st.w	r3[0x0],r9
8000971a:	fb 48 06 90 	st.w	sp[1680],r8
8000971e:	30 19       	mov	r9,1
80009720:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009724:	87 19       	st.w	r3[0x4],r9
80009726:	2f f8       	sub	r8,-1
80009728:	fb 48 06 8c 	st.w	sp[1676],r8
8000972c:	c0 29       	rjmp	80009930 <_vfprintf_r+0x1e0c>
8000972e:	14 09       	add	r9,r10
80009730:	2f f8       	sub	r8,-1
80009732:	fb 49 06 90 	st.w	sp[1680],r9
80009736:	87 06       	st.w	r3[0x0],r6
80009738:	87 1a       	st.w	r3[0x4],r10
8000973a:	fb 48 06 8c 	st.w	sp[1676],r8
8000973e:	58 78       	cp.w	r8,7
80009740:	e0 89 00 04 	brgt	80009748 <_vfprintf_r+0x1c24>
80009744:	2f 83       	sub	r3,-8
80009746:	c0 b8       	rjmp	8000975c <_vfprintf_r+0x1c38>
80009748:	fa ca f9 78 	sub	r10,sp,-1672
8000974c:	02 9b       	mov	r11,r1
8000974e:	08 9c       	mov	r12,r4
80009750:	fe b0 f1 dc 	rcall	80007b08 <__sprint_r>
80009754:	e0 81 01 67 	brne	80009a22 <_vfprintf_r+0x1efe>
80009758:	fa c3 f9 e0 	sub	r3,sp,-1568
8000975c:	40 c8       	lddsp	r8,sp[0x30]
8000975e:	87 08       	st.w	r3[0x0],r8
80009760:	fa f8 06 90 	ld.w	r8,sp[1680]
80009764:	2f f8       	sub	r8,-1
80009766:	30 19       	mov	r9,1
80009768:	fb 48 06 90 	st.w	sp[1680],r8
8000976c:	87 19       	st.w	r3[0x4],r9
8000976e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009772:	2f f8       	sub	r8,-1
80009774:	fb 48 06 8c 	st.w	sp[1676],r8
80009778:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000977c:	58 78       	cp.w	r8,7
8000977e:	e0 89 00 04 	brgt	80009786 <_vfprintf_r+0x1c62>
80009782:	2f 83       	sub	r3,-8
80009784:	c0 b8       	rjmp	8000979a <_vfprintf_r+0x1c76>
80009786:	fa ca f9 78 	sub	r10,sp,-1672
8000978a:	02 9b       	mov	r11,r1
8000978c:	08 9c       	mov	r12,r4
8000978e:	fe b0 f1 bd 	rcall	80007b08 <__sprint_r>
80009792:	e0 81 01 48 	brne	80009a22 <_vfprintf_r+0x1efe>
80009796:	fa c3 f9 e0 	sub	r3,sp,-1568
8000979a:	04 06       	add	r6,r2
8000979c:	fa f8 06 ac 	ld.w	r8,sp[1708]
800097a0:	87 06       	st.w	r3[0x0],r6
800097a2:	fa f9 06 90 	ld.w	r9,sp[1680]
800097a6:	40 66       	lddsp	r6,sp[0x18]
800097a8:	40 6e       	lddsp	lr,sp[0x18]
800097aa:	10 16       	sub	r6,r8
800097ac:	f2 08 01 08 	sub	r8,r9,r8
800097b0:	87 16       	st.w	r3[0x4],r6
800097b2:	1c 08       	add	r8,lr
800097b4:	fb 48 06 90 	st.w	sp[1680],r8
800097b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097bc:	2f f8       	sub	r8,-1
800097be:	fb 48 06 8c 	st.w	sp[1676],r8
800097c2:	cb 78       	rjmp	80009930 <_vfprintf_r+0x1e0c>
800097c4:	40 6c       	lddsp	r12,sp[0x18]
800097c6:	58 1c       	cp.w	r12,1
800097c8:	e0 89 00 06 	brgt	800097d4 <_vfprintf_r+0x1cb0>
800097cc:	ed b5 00 00 	bld	r5,0x0
800097d0:	e0 81 00 85 	brne	800098da <_vfprintf_r+0x1db6>
800097d4:	fa f8 06 90 	ld.w	r8,sp[1680]
800097d8:	2f f8       	sub	r8,-1
800097da:	30 19       	mov	r9,1
800097dc:	fb 48 06 90 	st.w	sp[1680],r8
800097e0:	87 06       	st.w	r3[0x0],r6
800097e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097e6:	87 19       	st.w	r3[0x4],r9
800097e8:	2f f8       	sub	r8,-1
800097ea:	fb 48 06 8c 	st.w	sp[1676],r8
800097ee:	58 78       	cp.w	r8,7
800097f0:	e0 89 00 04 	brgt	800097f8 <_vfprintf_r+0x1cd4>
800097f4:	2f 83       	sub	r3,-8
800097f6:	c0 b8       	rjmp	8000980c <_vfprintf_r+0x1ce8>
800097f8:	fa ca f9 78 	sub	r10,sp,-1672
800097fc:	02 9b       	mov	r11,r1
800097fe:	08 9c       	mov	r12,r4
80009800:	fe b0 f1 84 	rcall	80007b08 <__sprint_r>
80009804:	e0 81 01 0f 	brne	80009a22 <_vfprintf_r+0x1efe>
80009808:	fa c3 f9 e0 	sub	r3,sp,-1568
8000980c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009810:	2f f8       	sub	r8,-1
80009812:	40 cb       	lddsp	r11,sp[0x30]
80009814:	fb 48 06 90 	st.w	sp[1680],r8
80009818:	30 19       	mov	r9,1
8000981a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000981e:	87 0b       	st.w	r3[0x0],r11
80009820:	2f f8       	sub	r8,-1
80009822:	87 19       	st.w	r3[0x4],r9
80009824:	fb 48 06 8c 	st.w	sp[1676],r8
80009828:	58 78       	cp.w	r8,7
8000982a:	e0 89 00 05 	brgt	80009834 <_vfprintf_r+0x1d10>
8000982e:	2f 83       	sub	r3,-8
80009830:	c0 c8       	rjmp	80009848 <_vfprintf_r+0x1d24>
80009832:	d7 03       	nop
80009834:	fa ca f9 78 	sub	r10,sp,-1672
80009838:	02 9b       	mov	r11,r1
8000983a:	08 9c       	mov	r12,r4
8000983c:	fe b0 f1 66 	rcall	80007b08 <__sprint_r>
80009840:	e0 81 00 f1 	brne	80009a22 <_vfprintf_r+0x1efe>
80009844:	fa c3 f9 e0 	sub	r3,sp,-1568
80009848:	30 08       	mov	r8,0
8000984a:	30 09       	mov	r9,0
8000984c:	40 5b       	lddsp	r11,sp[0x14]
8000984e:	40 7a       	lddsp	r10,sp[0x1c]
80009850:	e0 a0 13 25 	rcall	8000be9a <__avr32_f64_cmp_eq>
80009854:	40 68       	lddsp	r8,sp[0x18]
80009856:	20 18       	sub	r8,1
80009858:	58 0c       	cp.w	r12,0
8000985a:	c0 d1       	brne	80009874 <_vfprintf_r+0x1d50>
8000985c:	2f f6       	sub	r6,-1
8000985e:	87 18       	st.w	r3[0x4],r8
80009860:	87 06       	st.w	r3[0x0],r6
80009862:	fa f6 06 90 	ld.w	r6,sp[1680]
80009866:	10 06       	add	r6,r8
80009868:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000986c:	fb 46 06 90 	st.w	sp[1680],r6
80009870:	2f f8       	sub	r8,-1
80009872:	c3 18       	rjmp	800098d4 <_vfprintf_r+0x1db0>
80009874:	10 96       	mov	r6,r8
80009876:	58 08       	cp.w	r8,0
80009878:	e0 89 00 1c 	brgt	800098b0 <_vfprintf_r+0x1d8c>
8000987c:	c4 b8       	rjmp	80009912 <_vfprintf_r+0x1dee>
8000987e:	2f 09       	sub	r9,-16
80009880:	2f f8       	sub	r8,-1
80009882:	fb 49 06 90 	st.w	sp[1680],r9
80009886:	87 02       	st.w	r3[0x0],r2
80009888:	87 10       	st.w	r3[0x4],r0
8000988a:	fb 48 06 8c 	st.w	sp[1676],r8
8000988e:	58 78       	cp.w	r8,7
80009890:	e0 89 00 04 	brgt	80009898 <_vfprintf_r+0x1d74>
80009894:	2f 83       	sub	r3,-8
80009896:	c0 b8       	rjmp	800098ac <_vfprintf_r+0x1d88>
80009898:	fa ca f9 78 	sub	r10,sp,-1672
8000989c:	02 9b       	mov	r11,r1
8000989e:	08 9c       	mov	r12,r4
800098a0:	fe b0 f1 34 	rcall	80007b08 <__sprint_r>
800098a4:	e0 81 00 bf 	brne	80009a22 <_vfprintf_r+0x1efe>
800098a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098ac:	21 06       	sub	r6,16
800098ae:	c0 48       	rjmp	800098b6 <_vfprintf_r+0x1d92>
800098b0:	fe c2 c0 1c 	sub	r2,pc,-16356
800098b4:	31 00       	mov	r0,16
800098b6:	fa f9 06 90 	ld.w	r9,sp[1680]
800098ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098be:	fe ca c0 2a 	sub	r10,pc,-16342
800098c2:	59 06       	cp.w	r6,16
800098c4:	fe 99 ff dd 	brgt	8000987e <_vfprintf_r+0x1d5a>
800098c8:	0c 09       	add	r9,r6
800098ca:	87 0a       	st.w	r3[0x0],r10
800098cc:	fb 49 06 90 	st.w	sp[1680],r9
800098d0:	2f f8       	sub	r8,-1
800098d2:	87 16       	st.w	r3[0x4],r6
800098d4:	fb 48 06 8c 	st.w	sp[1676],r8
800098d8:	c0 e8       	rjmp	800098f4 <_vfprintf_r+0x1dd0>
800098da:	fa f8 06 90 	ld.w	r8,sp[1680]
800098de:	2f f8       	sub	r8,-1
800098e0:	30 19       	mov	r9,1
800098e2:	fb 48 06 90 	st.w	sp[1680],r8
800098e6:	87 06       	st.w	r3[0x0],r6
800098e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ec:	87 19       	st.w	r3[0x4],r9
800098ee:	2f f8       	sub	r8,-1
800098f0:	fb 48 06 8c 	st.w	sp[1676],r8
800098f4:	58 78       	cp.w	r8,7
800098f6:	e0 89 00 04 	brgt	800098fe <_vfprintf_r+0x1dda>
800098fa:	2f 83       	sub	r3,-8
800098fc:	c0 b8       	rjmp	80009912 <_vfprintf_r+0x1dee>
800098fe:	fa ca f9 78 	sub	r10,sp,-1672
80009902:	02 9b       	mov	r11,r1
80009904:	08 9c       	mov	r12,r4
80009906:	fe b0 f1 01 	rcall	80007b08 <__sprint_r>
8000990a:	e0 81 00 8c 	brne	80009a22 <_vfprintf_r+0x1efe>
8000990e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009912:	40 ea       	lddsp	r10,sp[0x38]
80009914:	fa f8 06 90 	ld.w	r8,sp[1680]
80009918:	14 08       	add	r8,r10
8000991a:	fa c9 f9 64 	sub	r9,sp,-1692
8000991e:	fb 48 06 90 	st.w	sp[1680],r8
80009922:	87 1a       	st.w	r3[0x4],r10
80009924:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009928:	87 09       	st.w	r3[0x0],r9
8000992a:	2f f8       	sub	r8,-1
8000992c:	fb 48 06 8c 	st.w	sp[1676],r8
80009930:	58 78       	cp.w	r8,7
80009932:	e0 89 00 04 	brgt	8000993a <_vfprintf_r+0x1e16>
80009936:	2f 83       	sub	r3,-8
80009938:	c0 a8       	rjmp	8000994c <_vfprintf_r+0x1e28>
8000993a:	fa ca f9 78 	sub	r10,sp,-1672
8000993e:	02 9b       	mov	r11,r1
80009940:	08 9c       	mov	r12,r4
80009942:	fe b0 f0 e3 	rcall	80007b08 <__sprint_r>
80009946:	c6 e1       	brne	80009a22 <_vfprintf_r+0x1efe>
80009948:	fa c3 f9 e0 	sub	r3,sp,-1568
8000994c:	e2 15 00 04 	andl	r5,0x4,COH
80009950:	c3 f0       	breq	800099ce <_vfprintf_r+0x1eaa>
80009952:	40 86       	lddsp	r6,sp[0x20]
80009954:	40 39       	lddsp	r9,sp[0xc]
80009956:	12 16       	sub	r6,r9
80009958:	58 06       	cp.w	r6,0
8000995a:	e0 89 00 1a 	brgt	8000998e <_vfprintf_r+0x1e6a>
8000995e:	c3 88       	rjmp	800099ce <_vfprintf_r+0x1eaa>
80009960:	2f 09       	sub	r9,-16
80009962:	2f f8       	sub	r8,-1
80009964:	fb 49 06 90 	st.w	sp[1680],r9
80009968:	87 05       	st.w	r3[0x0],r5
8000996a:	87 12       	st.w	r3[0x4],r2
8000996c:	fb 48 06 8c 	st.w	sp[1676],r8
80009970:	58 78       	cp.w	r8,7
80009972:	e0 89 00 04 	brgt	8000997a <_vfprintf_r+0x1e56>
80009976:	2f 83       	sub	r3,-8
80009978:	c0 98       	rjmp	8000998a <_vfprintf_r+0x1e66>
8000997a:	00 9a       	mov	r10,r0
8000997c:	02 9b       	mov	r11,r1
8000997e:	08 9c       	mov	r12,r4
80009980:	fe b0 f0 c4 	rcall	80007b08 <__sprint_r>
80009984:	c4 f1       	brne	80009a22 <_vfprintf_r+0x1efe>
80009986:	fa c3 f9 e0 	sub	r3,sp,-1568
8000998a:	21 06       	sub	r6,16
8000998c:	c0 68       	rjmp	80009998 <_vfprintf_r+0x1e74>
8000998e:	fe c5 c1 0a 	sub	r5,pc,-16118
80009992:	31 02       	mov	r2,16
80009994:	fa c0 f9 78 	sub	r0,sp,-1672
80009998:	fa f9 06 90 	ld.w	r9,sp[1680]
8000999c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099a0:	fe ca c1 1c 	sub	r10,pc,-16100
800099a4:	59 06       	cp.w	r6,16
800099a6:	fe 99 ff dd 	brgt	80009960 <_vfprintf_r+0x1e3c>
800099aa:	0c 09       	add	r9,r6
800099ac:	2f f8       	sub	r8,-1
800099ae:	87 0a       	st.w	r3[0x0],r10
800099b0:	87 16       	st.w	r3[0x4],r6
800099b2:	fb 49 06 90 	st.w	sp[1680],r9
800099b6:	fb 48 06 8c 	st.w	sp[1676],r8
800099ba:	58 78       	cp.w	r8,7
800099bc:	e0 8a 00 09 	brle	800099ce <_vfprintf_r+0x1eaa>
800099c0:	fa ca f9 78 	sub	r10,sp,-1672
800099c4:	02 9b       	mov	r11,r1
800099c6:	08 9c       	mov	r12,r4
800099c8:	fe b0 f0 a0 	rcall	80007b08 <__sprint_r>
800099cc:	c2 b1       	brne	80009a22 <_vfprintf_r+0x1efe>
800099ce:	40 bc       	lddsp	r12,sp[0x2c]
800099d0:	40 36       	lddsp	r6,sp[0xc]
800099d2:	40 8e       	lddsp	lr,sp[0x20]
800099d4:	ec 0e 0c 48 	max	r8,r6,lr
800099d8:	10 0c       	add	r12,r8
800099da:	50 bc       	stdsp	sp[0x2c],r12
800099dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e0:	58 08       	cp.w	r8,0
800099e2:	c0 80       	breq	800099f2 <_vfprintf_r+0x1ece>
800099e4:	fa ca f9 78 	sub	r10,sp,-1672
800099e8:	02 9b       	mov	r11,r1
800099ea:	08 9c       	mov	r12,r4
800099ec:	fe b0 f0 8e 	rcall	80007b08 <__sprint_r>
800099f0:	c1 91       	brne	80009a22 <_vfprintf_r+0x1efe>
800099f2:	30 0b       	mov	r11,0
800099f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099f8:	fb 4b 06 8c 	st.w	sp[1676],r11
800099fc:	fe 9f f1 22 	bral	80007c40 <_vfprintf_r+0x11c>
80009a00:	08 95       	mov	r5,r4
80009a02:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a06:	58 08       	cp.w	r8,0
80009a08:	c0 80       	breq	80009a18 <_vfprintf_r+0x1ef4>
80009a0a:	08 9c       	mov	r12,r4
80009a0c:	fa ca f9 78 	sub	r10,sp,-1672
80009a10:	02 9b       	mov	r11,r1
80009a12:	fe b0 f0 7b 	rcall	80007b08 <__sprint_r>
80009a16:	c0 61       	brne	80009a22 <_vfprintf_r+0x1efe>
80009a18:	30 08       	mov	r8,0
80009a1a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a1e:	c0 28       	rjmp	80009a22 <_vfprintf_r+0x1efe>
80009a20:	40 41       	lddsp	r1,sp[0x10]
80009a22:	82 68       	ld.sh	r8,r1[0xc]
80009a24:	ed b8 00 06 	bld	r8,0x6
80009a28:	c0 31       	brne	80009a2e <_vfprintf_r+0x1f0a>
80009a2a:	3f fa       	mov	r10,-1
80009a2c:	50 ba       	stdsp	sp[0x2c],r10
80009a2e:	40 bc       	lddsp	r12,sp[0x2c]
80009a30:	fe 3d f9 44 	sub	sp,-1724
80009a34:	d8 32       	popm	r0-r7,pc
80009a36:	d7 03       	nop

80009a38 <__swsetup_r>:
80009a38:	d4 21       	pushm	r4-r7,lr
80009a3a:	e0 68 0a 38 	mov	r8,2616
80009a3e:	18 96       	mov	r6,r12
80009a40:	16 97       	mov	r7,r11
80009a42:	70 0c       	ld.w	r12,r8[0x0]
80009a44:	58 0c       	cp.w	r12,0
80009a46:	c0 60       	breq	80009a52 <__swsetup_r+0x1a>
80009a48:	78 68       	ld.w	r8,r12[0x18]
80009a4a:	58 08       	cp.w	r8,0
80009a4c:	c0 31       	brne	80009a52 <__swsetup_r+0x1a>
80009a4e:	e0 a0 07 bf 	rcall	8000a9cc <__sinit>
80009a52:	fe c8 c0 9e 	sub	r8,pc,-16226
80009a56:	10 37       	cp.w	r7,r8
80009a58:	c0 61       	brne	80009a64 <__swsetup_r+0x2c>
80009a5a:	e0 68 0a 38 	mov	r8,2616
80009a5e:	70 08       	ld.w	r8,r8[0x0]
80009a60:	70 07       	ld.w	r7,r8[0x0]
80009a62:	c1 28       	rjmp	80009a86 <__swsetup_r+0x4e>
80009a64:	fe c8 c0 90 	sub	r8,pc,-16240
80009a68:	10 37       	cp.w	r7,r8
80009a6a:	c0 61       	brne	80009a76 <__swsetup_r+0x3e>
80009a6c:	e0 68 0a 38 	mov	r8,2616
80009a70:	70 08       	ld.w	r8,r8[0x0]
80009a72:	70 17       	ld.w	r7,r8[0x4]
80009a74:	c0 98       	rjmp	80009a86 <__swsetup_r+0x4e>
80009a76:	fe c8 c0 82 	sub	r8,pc,-16254
80009a7a:	10 37       	cp.w	r7,r8
80009a7c:	c0 51       	brne	80009a86 <__swsetup_r+0x4e>
80009a7e:	e0 68 0a 38 	mov	r8,2616
80009a82:	70 08       	ld.w	r8,r8[0x0]
80009a84:	70 27       	ld.w	r7,r8[0x8]
80009a86:	8e 68       	ld.sh	r8,r7[0xc]
80009a88:	ed b8 00 03 	bld	r8,0x3
80009a8c:	c1 e0       	breq	80009ac8 <__swsetup_r+0x90>
80009a8e:	ed b8 00 04 	bld	r8,0x4
80009a92:	c3 e1       	brne	80009b0e <__swsetup_r+0xd6>
80009a94:	ed b8 00 02 	bld	r8,0x2
80009a98:	c1 51       	brne	80009ac2 <__swsetup_r+0x8a>
80009a9a:	6e db       	ld.w	r11,r7[0x34]
80009a9c:	58 0b       	cp.w	r11,0
80009a9e:	c0 a0       	breq	80009ab2 <__swsetup_r+0x7a>
80009aa0:	ee c8 ff bc 	sub	r8,r7,-68
80009aa4:	10 3b       	cp.w	r11,r8
80009aa6:	c0 40       	breq	80009aae <__swsetup_r+0x76>
80009aa8:	0c 9c       	mov	r12,r6
80009aaa:	e0 a0 08 2b 	rcall	8000ab00 <_free_r>
80009aae:	30 08       	mov	r8,0
80009ab0:	8f d8       	st.w	r7[0x34],r8
80009ab2:	8e 68       	ld.sh	r8,r7[0xc]
80009ab4:	e0 18 ff db 	andl	r8,0xffdb
80009ab8:	ae 68       	st.h	r7[0xc],r8
80009aba:	30 08       	mov	r8,0
80009abc:	8f 18       	st.w	r7[0x4],r8
80009abe:	6e 48       	ld.w	r8,r7[0x10]
80009ac0:	8f 08       	st.w	r7[0x0],r8
80009ac2:	8e 68       	ld.sh	r8,r7[0xc]
80009ac4:	a3 b8       	sbr	r8,0x3
80009ac6:	ae 68       	st.h	r7[0xc],r8
80009ac8:	6e 48       	ld.w	r8,r7[0x10]
80009aca:	58 08       	cp.w	r8,0
80009acc:	c0 b1       	brne	80009ae2 <__swsetup_r+0xaa>
80009ace:	8e 68       	ld.sh	r8,r7[0xc]
80009ad0:	e2 18 02 80 	andl	r8,0x280,COH
80009ad4:	e0 48 02 00 	cp.w	r8,512
80009ad8:	c0 50       	breq	80009ae2 <__swsetup_r+0xaa>
80009ada:	0c 9c       	mov	r12,r6
80009adc:	0e 9b       	mov	r11,r7
80009ade:	e0 a0 0a 4b 	rcall	8000af74 <__smakebuf_r>
80009ae2:	8e 69       	ld.sh	r9,r7[0xc]
80009ae4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ae8:	c0 70       	breq	80009af6 <__swsetup_r+0xbe>
80009aea:	30 08       	mov	r8,0
80009aec:	8f 28       	st.w	r7[0x8],r8
80009aee:	6e 58       	ld.w	r8,r7[0x14]
80009af0:	5c 38       	neg	r8
80009af2:	8f 68       	st.w	r7[0x18],r8
80009af4:	c0 68       	rjmp	80009b00 <__swsetup_r+0xc8>
80009af6:	ed b9 00 01 	bld	r9,0x1
80009afa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009afe:	8f 28       	st.w	r7[0x8],r8
80009b00:	6e 48       	ld.w	r8,r7[0x10]
80009b02:	58 08       	cp.w	r8,0
80009b04:	c0 61       	brne	80009b10 <__swsetup_r+0xd8>
80009b06:	8e 68       	ld.sh	r8,r7[0xc]
80009b08:	ed b8 00 07 	bld	r8,0x7
80009b0c:	c0 21       	brne	80009b10 <__swsetup_r+0xd8>
80009b0e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009b10:	d8 2a       	popm	r4-r7,pc,r12=0
80009b12:	d7 03       	nop

80009b14 <quorem>:
80009b14:	d4 31       	pushm	r0-r7,lr
80009b16:	20 2d       	sub	sp,8
80009b18:	18 97       	mov	r7,r12
80009b1a:	78 48       	ld.w	r8,r12[0x10]
80009b1c:	76 46       	ld.w	r6,r11[0x10]
80009b1e:	0c 38       	cp.w	r8,r6
80009b20:	c0 34       	brge	80009b26 <quorem+0x12>
80009b22:	30 0c       	mov	r12,0
80009b24:	c8 58       	rjmp	80009c2e <quorem+0x11a>
80009b26:	ec c2 ff fc 	sub	r2,r6,-4
80009b2a:	f6 c3 ff ec 	sub	r3,r11,-20
80009b2e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009b32:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009b36:	2f f9       	sub	r9,-1
80009b38:	20 16       	sub	r6,1
80009b3a:	f8 09 0d 08 	divu	r8,r12,r9
80009b3e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009b42:	ee c4 ff ec 	sub	r4,r7,-20
80009b46:	10 95       	mov	r5,r8
80009b48:	58 08       	cp.w	r8,0
80009b4a:	c4 10       	breq	80009bcc <quorem+0xb8>
80009b4c:	30 09       	mov	r9,0
80009b4e:	06 9a       	mov	r10,r3
80009b50:	08 98       	mov	r8,r4
80009b52:	12 91       	mov	r1,r9
80009b54:	50 0b       	stdsp	sp[0x0],r11
80009b56:	70 0e       	ld.w	lr,r8[0x0]
80009b58:	b1 8e       	lsr	lr,0x10
80009b5a:	50 1e       	stdsp	sp[0x4],lr
80009b5c:	15 0e       	ld.w	lr,r10++
80009b5e:	fc 00 16 10 	lsr	r0,lr,0x10
80009b62:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b66:	ea 0e 03 41 	mac	r1,r5,lr
80009b6a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009b6e:	b1 81       	lsr	r1,0x10
80009b70:	40 1b       	lddsp	r11,sp[0x4]
80009b72:	ea 00 02 40 	mul	r0,r5,r0
80009b76:	e2 00 00 00 	add	r0,r1,r0
80009b7a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009b7e:	02 1b       	sub	r11,r1
80009b80:	50 1b       	stdsp	sp[0x4],r11
80009b82:	70 0b       	ld.w	r11,r8[0x0]
80009b84:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009b88:	02 09       	add	r9,r1
80009b8a:	f2 0e 01 0e 	sub	lr,r9,lr
80009b8e:	b0 1e       	st.h	r8[0x2],lr
80009b90:	fc 09 14 10 	asr	r9,lr,0x10
80009b94:	40 1e       	lddsp	lr,sp[0x4]
80009b96:	fc 09 00 09 	add	r9,lr,r9
80009b9a:	b0 09       	st.h	r8[0x0],r9
80009b9c:	e0 01 16 10 	lsr	r1,r0,0x10
80009ba0:	2f c8       	sub	r8,-4
80009ba2:	b1 49       	asr	r9,0x10
80009ba4:	04 3a       	cp.w	r10,r2
80009ba6:	fe 98 ff d8 	brls	80009b56 <quorem+0x42>
80009baa:	40 0b       	lddsp	r11,sp[0x0]
80009bac:	58 0c       	cp.w	r12,0
80009bae:	c0 f1       	brne	80009bcc <quorem+0xb8>
80009bb0:	ec c8 ff fb 	sub	r8,r6,-5
80009bb4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009bb8:	c0 28       	rjmp	80009bbc <quorem+0xa8>
80009bba:	20 16       	sub	r6,1
80009bbc:	20 48       	sub	r8,4
80009bbe:	08 38       	cp.w	r8,r4
80009bc0:	e0 88 00 05 	brls	80009bca <quorem+0xb6>
80009bc4:	70 09       	ld.w	r9,r8[0x0]
80009bc6:	58 09       	cp.w	r9,0
80009bc8:	cf 90       	breq	80009bba <quorem+0xa6>
80009bca:	8f 46       	st.w	r7[0x10],r6
80009bcc:	0e 9c       	mov	r12,r7
80009bce:	e0 a0 0a d2 	rcall	8000b172 <__mcmp>
80009bd2:	c2 d5       	brlt	80009c2c <quorem+0x118>
80009bd4:	2f f5       	sub	r5,-1
80009bd6:	08 98       	mov	r8,r4
80009bd8:	30 09       	mov	r9,0
80009bda:	07 0b       	ld.w	r11,r3++
80009bdc:	f6 0a 16 10 	lsr	r10,r11,0x10
80009be0:	70 0c       	ld.w	r12,r8[0x0]
80009be2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009be6:	f8 0e 16 10 	lsr	lr,r12,0x10
80009bea:	14 1e       	sub	lr,r10
80009bec:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009bf0:	16 1a       	sub	r10,r11
80009bf2:	12 0a       	add	r10,r9
80009bf4:	b0 1a       	st.h	r8[0x2],r10
80009bf6:	b1 4a       	asr	r10,0x10
80009bf8:	fc 0a 00 09 	add	r9,lr,r10
80009bfc:	b0 09       	st.h	r8[0x0],r9
80009bfe:	2f c8       	sub	r8,-4
80009c00:	b1 49       	asr	r9,0x10
80009c02:	04 33       	cp.w	r3,r2
80009c04:	fe 98 ff eb 	brls	80009bda <quorem+0xc6>
80009c08:	ec c8 ff fb 	sub	r8,r6,-5
80009c0c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009c10:	58 09       	cp.w	r9,0
80009c12:	c0 d1       	brne	80009c2c <quorem+0x118>
80009c14:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c18:	c0 28       	rjmp	80009c1c <quorem+0x108>
80009c1a:	20 16       	sub	r6,1
80009c1c:	20 48       	sub	r8,4
80009c1e:	08 38       	cp.w	r8,r4
80009c20:	e0 88 00 05 	brls	80009c2a <quorem+0x116>
80009c24:	70 09       	ld.w	r9,r8[0x0]
80009c26:	58 09       	cp.w	r9,0
80009c28:	cf 90       	breq	80009c1a <quorem+0x106>
80009c2a:	8f 46       	st.w	r7[0x10],r6
80009c2c:	0a 9c       	mov	r12,r5
80009c2e:	2f ed       	sub	sp,-8
80009c30:	d8 32       	popm	r0-r7,pc
80009c32:	d7 03       	nop

80009c34 <_dtoa_r>:
80009c34:	d4 31       	pushm	r0-r7,lr
80009c36:	21 ad       	sub	sp,104
80009c38:	fa c4 ff 74 	sub	r4,sp,-140
80009c3c:	18 97       	mov	r7,r12
80009c3e:	16 95       	mov	r5,r11
80009c40:	68 2c       	ld.w	r12,r4[0x8]
80009c42:	50 c9       	stdsp	sp[0x30],r9
80009c44:	68 16       	ld.w	r6,r4[0x4]
80009c46:	68 09       	ld.w	r9,r4[0x0]
80009c48:	50 e8       	stdsp	sp[0x38],r8
80009c4a:	14 94       	mov	r4,r10
80009c4c:	51 2c       	stdsp	sp[0x48],r12
80009c4e:	fa e5 00 08 	st.d	sp[8],r4
80009c52:	51 59       	stdsp	sp[0x54],r9
80009c54:	6e 95       	ld.w	r5,r7[0x24]
80009c56:	58 05       	cp.w	r5,0
80009c58:	c0 91       	brne	80009c6a <_dtoa_r+0x36>
80009c5a:	31 0c       	mov	r12,16
80009c5c:	fe b0 e8 f4 	rcall	80006e44 <malloc>
80009c60:	99 35       	st.w	r12[0xc],r5
80009c62:	8f 9c       	st.w	r7[0x24],r12
80009c64:	99 15       	st.w	r12[0x4],r5
80009c66:	99 25       	st.w	r12[0x8],r5
80009c68:	99 05       	st.w	r12[0x0],r5
80009c6a:	6e 99       	ld.w	r9,r7[0x24]
80009c6c:	72 08       	ld.w	r8,r9[0x0]
80009c6e:	58 08       	cp.w	r8,0
80009c70:	c0 f0       	breq	80009c8e <_dtoa_r+0x5a>
80009c72:	72 1a       	ld.w	r10,r9[0x4]
80009c74:	91 1a       	st.w	r8[0x4],r10
80009c76:	30 1a       	mov	r10,1
80009c78:	72 19       	ld.w	r9,r9[0x4]
80009c7a:	f4 09 09 49 	lsl	r9,r10,r9
80009c7e:	10 9b       	mov	r11,r8
80009c80:	91 29       	st.w	r8[0x8],r9
80009c82:	0e 9c       	mov	r12,r7
80009c84:	e0 a0 0a 90 	rcall	8000b1a4 <_Bfree>
80009c88:	6e 98       	ld.w	r8,r7[0x24]
80009c8a:	30 09       	mov	r9,0
80009c8c:	91 09       	st.w	r8[0x0],r9
80009c8e:	40 28       	lddsp	r8,sp[0x8]
80009c90:	10 94       	mov	r4,r8
80009c92:	58 08       	cp.w	r8,0
80009c94:	c0 64       	brge	80009ca0 <_dtoa_r+0x6c>
80009c96:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009c9a:	50 28       	stdsp	sp[0x8],r8
80009c9c:	30 18       	mov	r8,1
80009c9e:	c0 28       	rjmp	80009ca2 <_dtoa_r+0x6e>
80009ca0:	30 08       	mov	r8,0
80009ca2:	8d 08       	st.w	r6[0x0],r8
80009ca4:	fc 1c 7f f0 	movh	r12,0x7ff0
80009ca8:	40 26       	lddsp	r6,sp[0x8]
80009caa:	0c 98       	mov	r8,r6
80009cac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009cb0:	18 38       	cp.w	r8,r12
80009cb2:	c2 01       	brne	80009cf2 <_dtoa_r+0xbe>
80009cb4:	e0 68 27 0f 	mov	r8,9999
80009cb8:	41 5b       	lddsp	r11,sp[0x54]
80009cba:	97 08       	st.w	r11[0x0],r8
80009cbc:	40 3a       	lddsp	r10,sp[0xc]
80009cbe:	58 0a       	cp.w	r10,0
80009cc0:	c0 71       	brne	80009cce <_dtoa_r+0x9a>
80009cc2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009cc6:	c0 41       	brne	80009cce <_dtoa_r+0x9a>
80009cc8:	fe cc c3 24 	sub	r12,pc,-15580
80009ccc:	c0 38       	rjmp	80009cd2 <_dtoa_r+0x9e>
80009cce:	fe cc c3 1e 	sub	r12,pc,-15586
80009cd2:	41 29       	lddsp	r9,sp[0x48]
80009cd4:	58 09       	cp.w	r9,0
80009cd6:	e0 80 05 9a 	breq	8000a80a <_dtoa_r+0xbd6>
80009cda:	f8 c8 ff fd 	sub	r8,r12,-3
80009cde:	f8 c9 ff f8 	sub	r9,r12,-8
80009ce2:	11 8b       	ld.ub	r11,r8[0x0]
80009ce4:	30 0a       	mov	r10,0
80009ce6:	41 25       	lddsp	r5,sp[0x48]
80009ce8:	f4 0b 18 00 	cp.b	r11,r10
80009cec:	f2 08 17 10 	movne	r8,r9
80009cf0:	c1 68       	rjmp	80009d1c <_dtoa_r+0xe8>
80009cf2:	fa ea 00 08 	ld.d	r10,sp[8]
80009cf6:	30 08       	mov	r8,0
80009cf8:	fa eb 00 3c 	st.d	sp[60],r10
80009cfc:	30 09       	mov	r9,0
80009cfe:	e0 a0 10 ce 	rcall	8000be9a <__avr32_f64_cmp_eq>
80009d02:	c1 00       	breq	80009d22 <_dtoa_r+0xee>
80009d04:	30 18       	mov	r8,1
80009d06:	41 5a       	lddsp	r10,sp[0x54]
80009d08:	95 08       	st.w	r10[0x0],r8
80009d0a:	fe cc c4 8a 	sub	r12,pc,-15222
80009d0e:	41 29       	lddsp	r9,sp[0x48]
80009d10:	f8 08 00 08 	add	r8,r12,r8
80009d14:	58 09       	cp.w	r9,0
80009d16:	e0 80 05 7a 	breq	8000a80a <_dtoa_r+0xbd6>
80009d1a:	12 95       	mov	r5,r9
80009d1c:	8b 08       	st.w	r5[0x0],r8
80009d1e:	e0 8f 05 76 	bral	8000a80a <_dtoa_r+0xbd6>
80009d22:	fa c8 ff 9c 	sub	r8,sp,-100
80009d26:	fa c9 ff a0 	sub	r9,sp,-96
80009d2a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d2e:	0e 9c       	mov	r12,r7
80009d30:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009d34:	e0 a0 0a 8a 	rcall	8000b248 <__d2b>
80009d38:	18 93       	mov	r3,r12
80009d3a:	58 05       	cp.w	r5,0
80009d3c:	c0 d0       	breq	80009d56 <_dtoa_r+0x122>
80009d3e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d42:	30 04       	mov	r4,0
80009d44:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009d48:	ea c5 03 ff 	sub	r5,r5,1023
80009d4c:	10 9b       	mov	r11,r8
80009d4e:	51 74       	stdsp	sp[0x5c],r4
80009d50:	ea 1b 3f f0 	orh	r11,0x3ff0
80009d54:	c2 58       	rjmp	80009d9e <_dtoa_r+0x16a>
80009d56:	41 88       	lddsp	r8,sp[0x60]
80009d58:	41 9c       	lddsp	r12,sp[0x64]
80009d5a:	10 0c       	add	r12,r8
80009d5c:	f8 c5 fb ce 	sub	r5,r12,-1074
80009d60:	e0 45 00 20 	cp.w	r5,32
80009d64:	e0 8a 00 0e 	brle	80009d80 <_dtoa_r+0x14c>
80009d68:	f8 cc fb ee 	sub	r12,r12,-1042
80009d6c:	40 3b       	lddsp	r11,sp[0xc]
80009d6e:	ea 08 11 40 	rsub	r8,r5,64
80009d72:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009d76:	ec 08 09 46 	lsl	r6,r6,r8
80009d7a:	0c 4c       	or	r12,r6
80009d7c:	c0 78       	rjmp	80009d8a <_dtoa_r+0x156>
80009d7e:	d7 03       	nop
80009d80:	ea 0c 11 20 	rsub	r12,r5,32
80009d84:	40 3a       	lddsp	r10,sp[0xc]
80009d86:	f4 0c 09 4c 	lsl	r12,r10,r12
80009d8a:	e0 a0 10 14 	rcall	8000bdb2 <__avr32_u32_to_f64>
80009d8e:	fc 18 fe 10 	movh	r8,0xfe10
80009d92:	30 19       	mov	r9,1
80009d94:	ea c5 04 33 	sub	r5,r5,1075
80009d98:	f0 0b 00 0b 	add	r11,r8,r11
80009d9c:	51 79       	stdsp	sp[0x5c],r9
80009d9e:	30 08       	mov	r8,0
80009da0:	fc 19 3f f8 	movh	r9,0x3ff8
80009da4:	e0 a0 0e 9c 	rcall	8000badc <__avr32_f64_sub>
80009da8:	e0 68 43 61 	mov	r8,17249
80009dac:	ea 18 63 6f 	orh	r8,0x636f
80009db0:	e0 69 87 a7 	mov	r9,34727
80009db4:	ea 19 3f d2 	orh	r9,0x3fd2
80009db8:	e0 a0 0d a6 	rcall	8000b904 <__avr32_f64_mul>
80009dbc:	e0 68 c8 b3 	mov	r8,51379
80009dc0:	ea 18 8b 60 	orh	r8,0x8b60
80009dc4:	e0 69 8a 28 	mov	r9,35368
80009dc8:	ea 19 3f c6 	orh	r9,0x3fc6
80009dcc:	e0 a0 0f 56 	rcall	8000bc78 <__avr32_f64_add>
80009dd0:	0a 9c       	mov	r12,r5
80009dd2:	14 90       	mov	r0,r10
80009dd4:	16 91       	mov	r1,r11
80009dd6:	e0 a0 0f f2 	rcall	8000bdba <__avr32_s32_to_f64>
80009dda:	e0 68 79 fb 	mov	r8,31227
80009dde:	ea 18 50 9f 	orh	r8,0x509f
80009de2:	e0 69 44 13 	mov	r9,17427
80009de6:	ea 19 3f d3 	orh	r9,0x3fd3
80009dea:	e0 a0 0d 8d 	rcall	8000b904 <__avr32_f64_mul>
80009dee:	14 98       	mov	r8,r10
80009df0:	16 99       	mov	r9,r11
80009df2:	00 9a       	mov	r10,r0
80009df4:	02 9b       	mov	r11,r1
80009df6:	e0 a0 0f 41 	rcall	8000bc78 <__avr32_f64_add>
80009dfa:	14 90       	mov	r0,r10
80009dfc:	16 91       	mov	r1,r11
80009dfe:	e0 a0 0f c7 	rcall	8000bd8c <__avr32_f64_to_s32>
80009e02:	30 08       	mov	r8,0
80009e04:	18 96       	mov	r6,r12
80009e06:	30 09       	mov	r9,0
80009e08:	00 9a       	mov	r10,r0
80009e0a:	02 9b       	mov	r11,r1
80009e0c:	e0 a0 10 8e 	rcall	8000bf28 <__avr32_f64_cmp_lt>
80009e10:	c0 c0       	breq	80009e28 <_dtoa_r+0x1f4>
80009e12:	0c 9c       	mov	r12,r6
80009e14:	e0 a0 0f d3 	rcall	8000bdba <__avr32_s32_to_f64>
80009e18:	14 98       	mov	r8,r10
80009e1a:	16 99       	mov	r9,r11
80009e1c:	00 9a       	mov	r10,r0
80009e1e:	02 9b       	mov	r11,r1
80009e20:	e0 a0 10 3d 	rcall	8000be9a <__avr32_f64_cmp_eq>
80009e24:	f7 b6 00 01 	subeq	r6,1
80009e28:	59 66       	cp.w	r6,22
80009e2a:	e0 88 00 05 	brls	80009e34 <_dtoa_r+0x200>
80009e2e:	30 18       	mov	r8,1
80009e30:	51 48       	stdsp	sp[0x50],r8
80009e32:	c1 38       	rjmp	80009e58 <_dtoa_r+0x224>
80009e34:	fe c8 c3 d0 	sub	r8,pc,-15408
80009e38:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e3c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009e40:	e0 a0 10 74 	rcall	8000bf28 <__avr32_f64_cmp_lt>
80009e44:	f9 b4 00 00 	moveq	r4,0
80009e48:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009e4c:	f7 b6 01 01 	subne	r6,1
80009e50:	f9 bc 01 00 	movne	r12,0
80009e54:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009e58:	41 90       	lddsp	r0,sp[0x64]
80009e5a:	20 10       	sub	r0,1
80009e5c:	0a 10       	sub	r0,r5
80009e5e:	c0 46       	brmi	80009e66 <_dtoa_r+0x232>
80009e60:	50 40       	stdsp	sp[0x10],r0
80009e62:	30 00       	mov	r0,0
80009e64:	c0 48       	rjmp	80009e6c <_dtoa_r+0x238>
80009e66:	30 0b       	mov	r11,0
80009e68:	5c 30       	neg	r0
80009e6a:	50 4b       	stdsp	sp[0x10],r11
80009e6c:	ec 02 11 00 	rsub	r2,r6,0
80009e70:	58 06       	cp.w	r6,0
80009e72:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009e76:	f5 d6 e4 0a 	addge	r10,r10,r6
80009e7a:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009e7e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009e82:	f9 b2 04 00 	movge	r2,0
80009e86:	e1 d6 e5 10 	sublt	r0,r0,r6
80009e8a:	f9 b9 05 00 	movlt	r9,0
80009e8e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009e92:	40 c8       	lddsp	r8,sp[0x30]
80009e94:	58 98       	cp.w	r8,9
80009e96:	e0 8b 00 20 	brhi	80009ed6 <_dtoa_r+0x2a2>
80009e9a:	58 58       	cp.w	r8,5
80009e9c:	f9 b4 0a 01 	movle	r4,1
80009ea0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009ea4:	f7 b5 09 04 	subgt	r5,4
80009ea8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009eac:	f9 b4 09 00 	movgt	r4,0
80009eb0:	40 cc       	lddsp	r12,sp[0x30]
80009eb2:	58 3c       	cp.w	r12,3
80009eb4:	c2 d0       	breq	80009f0e <_dtoa_r+0x2da>
80009eb6:	e0 89 00 05 	brgt	80009ec0 <_dtoa_r+0x28c>
80009eba:	58 2c       	cp.w	r12,2
80009ebc:	c1 01       	brne	80009edc <_dtoa_r+0x2a8>
80009ebe:	c1 88       	rjmp	80009eee <_dtoa_r+0x2ba>
80009ec0:	40 cb       	lddsp	r11,sp[0x30]
80009ec2:	58 4b       	cp.w	r11,4
80009ec4:	c0 60       	breq	80009ed0 <_dtoa_r+0x29c>
80009ec6:	58 5b       	cp.w	r11,5
80009ec8:	c0 a1       	brne	80009edc <_dtoa_r+0x2a8>
80009eca:	30 1a       	mov	r10,1
80009ecc:	50 da       	stdsp	sp[0x34],r10
80009ece:	c2 28       	rjmp	80009f12 <_dtoa_r+0x2de>
80009ed0:	30 19       	mov	r9,1
80009ed2:	50 d9       	stdsp	sp[0x34],r9
80009ed4:	c0 f8       	rjmp	80009ef2 <_dtoa_r+0x2be>
80009ed6:	30 08       	mov	r8,0
80009ed8:	30 14       	mov	r4,1
80009eda:	50 c8       	stdsp	sp[0x30],r8
80009edc:	3f f5       	mov	r5,-1
80009ede:	30 1c       	mov	r12,1
80009ee0:	30 0b       	mov	r11,0
80009ee2:	50 95       	stdsp	sp[0x24],r5
80009ee4:	50 dc       	stdsp	sp[0x34],r12
80009ee6:	0a 91       	mov	r1,r5
80009ee8:	31 28       	mov	r8,18
80009eea:	50 eb       	stdsp	sp[0x38],r11
80009eec:	c2 08       	rjmp	80009f2c <_dtoa_r+0x2f8>
80009eee:	30 0a       	mov	r10,0
80009ef0:	50 da       	stdsp	sp[0x34],r10
80009ef2:	40 e9       	lddsp	r9,sp[0x38]
80009ef4:	58 09       	cp.w	r9,0
80009ef6:	e0 89 00 07 	brgt	80009f04 <_dtoa_r+0x2d0>
80009efa:	30 18       	mov	r8,1
80009efc:	50 98       	stdsp	sp[0x24],r8
80009efe:	10 91       	mov	r1,r8
80009f00:	50 e8       	stdsp	sp[0x38],r8
80009f02:	c1 58       	rjmp	80009f2c <_dtoa_r+0x2f8>
80009f04:	40 e5       	lddsp	r5,sp[0x38]
80009f06:	50 95       	stdsp	sp[0x24],r5
80009f08:	0a 91       	mov	r1,r5
80009f0a:	0a 98       	mov	r8,r5
80009f0c:	c1 08       	rjmp	80009f2c <_dtoa_r+0x2f8>
80009f0e:	30 0c       	mov	r12,0
80009f10:	50 dc       	stdsp	sp[0x34],r12
80009f12:	40 eb       	lddsp	r11,sp[0x38]
80009f14:	ec 0b 00 0b 	add	r11,r6,r11
80009f18:	50 9b       	stdsp	sp[0x24],r11
80009f1a:	16 98       	mov	r8,r11
80009f1c:	2f f8       	sub	r8,-1
80009f1e:	58 08       	cp.w	r8,0
80009f20:	e0 89 00 05 	brgt	80009f2a <_dtoa_r+0x2f6>
80009f24:	10 91       	mov	r1,r8
80009f26:	30 18       	mov	r8,1
80009f28:	c0 28       	rjmp	80009f2c <_dtoa_r+0x2f8>
80009f2a:	10 91       	mov	r1,r8
80009f2c:	30 09       	mov	r9,0
80009f2e:	6e 9a       	ld.w	r10,r7[0x24]
80009f30:	95 19       	st.w	r10[0x4],r9
80009f32:	30 49       	mov	r9,4
80009f34:	c0 68       	rjmp	80009f40 <_dtoa_r+0x30c>
80009f36:	d7 03       	nop
80009f38:	6a 1a       	ld.w	r10,r5[0x4]
80009f3a:	a1 79       	lsl	r9,0x1
80009f3c:	2f fa       	sub	r10,-1
80009f3e:	8b 1a       	st.w	r5[0x4],r10
80009f40:	6e 95       	ld.w	r5,r7[0x24]
80009f42:	f2 ca ff ec 	sub	r10,r9,-20
80009f46:	10 3a       	cp.w	r10,r8
80009f48:	fe 98 ff f8 	brls	80009f38 <_dtoa_r+0x304>
80009f4c:	6a 1b       	ld.w	r11,r5[0x4]
80009f4e:	0e 9c       	mov	r12,r7
80009f50:	e0 a0 09 44 	rcall	8000b1d8 <_Balloc>
80009f54:	58 e1       	cp.w	r1,14
80009f56:	5f 88       	srls	r8
80009f58:	8b 0c       	st.w	r5[0x0],r12
80009f5a:	f1 e4 00 04 	and	r4,r8,r4
80009f5e:	6e 98       	ld.w	r8,r7[0x24]
80009f60:	70 08       	ld.w	r8,r8[0x0]
80009f62:	50 88       	stdsp	sp[0x20],r8
80009f64:	e0 80 01 82 	breq	8000a268 <_dtoa_r+0x634>
80009f68:	58 06       	cp.w	r6,0
80009f6a:	e0 8a 00 43 	brle	80009ff0 <_dtoa_r+0x3bc>
80009f6e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009f72:	fe c8 c5 0e 	sub	r8,pc,-15090
80009f76:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009f7a:	fa e5 00 18 	st.d	sp[24],r4
80009f7e:	ec 04 14 04 	asr	r4,r6,0x4
80009f82:	ed b4 00 04 	bld	r4,0x4
80009f86:	c0 30       	breq	80009f8c <_dtoa_r+0x358>
80009f88:	30 25       	mov	r5,2
80009f8a:	c1 08       	rjmp	80009faa <_dtoa_r+0x376>
80009f8c:	fe c8 c4 60 	sub	r8,pc,-15264
80009f90:	f0 e8 00 20 	ld.d	r8,r8[32]
80009f94:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f98:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009f9c:	e0 a0 0f fa 	rcall	8000bf90 <__avr32_f64_div>
80009fa0:	30 35       	mov	r5,3
80009fa2:	14 98       	mov	r8,r10
80009fa4:	16 99       	mov	r9,r11
80009fa6:	fa e9 00 08 	st.d	sp[8],r8
80009faa:	fe cc c4 7e 	sub	r12,pc,-15234
80009fae:	50 a3       	stdsp	sp[0x28],r3
80009fb0:	0c 93       	mov	r3,r6
80009fb2:	18 96       	mov	r6,r12
80009fb4:	c0 f8       	rjmp	80009fd2 <_dtoa_r+0x39e>
80009fb6:	fa ea 00 18 	ld.d	r10,sp[24]
80009fba:	ed b4 00 00 	bld	r4,0x0
80009fbe:	c0 81       	brne	80009fce <_dtoa_r+0x39a>
80009fc0:	ec e8 00 00 	ld.d	r8,r6[0]
80009fc4:	2f f5       	sub	r5,-1
80009fc6:	e0 a0 0c 9f 	rcall	8000b904 <__avr32_f64_mul>
80009fca:	fa eb 00 18 	st.d	sp[24],r10
80009fce:	a1 54       	asr	r4,0x1
80009fd0:	2f 86       	sub	r6,-8
80009fd2:	58 04       	cp.w	r4,0
80009fd4:	cf 11       	brne	80009fb6 <_dtoa_r+0x382>
80009fd6:	fa e8 00 18 	ld.d	r8,sp[24]
80009fda:	fa ea 00 08 	ld.d	r10,sp[8]
80009fde:	06 96       	mov	r6,r3
80009fe0:	e0 a0 0f d8 	rcall	8000bf90 <__avr32_f64_div>
80009fe4:	40 a3       	lddsp	r3,sp[0x28]
80009fe6:	14 98       	mov	r8,r10
80009fe8:	16 99       	mov	r9,r11
80009fea:	fa e9 00 08 	st.d	sp[8],r8
80009fee:	c2 f8       	rjmp	8000a04c <_dtoa_r+0x418>
80009ff0:	ec 08 11 00 	rsub	r8,r6,0
80009ff4:	c0 31       	brne	80009ffa <_dtoa_r+0x3c6>
80009ff6:	30 25       	mov	r5,2
80009ff8:	c2 a8       	rjmp	8000a04c <_dtoa_r+0x418>
80009ffa:	fe cc c4 ce 	sub	r12,pc,-15154
80009ffe:	f0 04 14 04 	asr	r4,r8,0x4
8000a002:	50 1c       	stdsp	sp[0x4],r12
8000a004:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a008:	fe c9 c5 a4 	sub	r9,pc,-14940
8000a00c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a010:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a014:	e0 a0 0c 78 	rcall	8000b904 <__avr32_f64_mul>
8000a018:	40 1c       	lddsp	r12,sp[0x4]
8000a01a:	50 63       	stdsp	sp[0x18],r3
8000a01c:	30 25       	mov	r5,2
8000a01e:	0c 93       	mov	r3,r6
8000a020:	fa eb 00 08 	st.d	sp[8],r10
8000a024:	18 96       	mov	r6,r12
8000a026:	c0 f8       	rjmp	8000a044 <_dtoa_r+0x410>
8000a028:	fa ea 00 08 	ld.d	r10,sp[8]
8000a02c:	ed b4 00 00 	bld	r4,0x0
8000a030:	c0 81       	brne	8000a040 <_dtoa_r+0x40c>
8000a032:	ec e8 00 00 	ld.d	r8,r6[0]
8000a036:	2f f5       	sub	r5,-1
8000a038:	e0 a0 0c 66 	rcall	8000b904 <__avr32_f64_mul>
8000a03c:	fa eb 00 08 	st.d	sp[8],r10
8000a040:	a1 54       	asr	r4,0x1
8000a042:	2f 86       	sub	r6,-8
8000a044:	58 04       	cp.w	r4,0
8000a046:	cf 11       	brne	8000a028 <_dtoa_r+0x3f4>
8000a048:	06 96       	mov	r6,r3
8000a04a:	40 63       	lddsp	r3,sp[0x18]
8000a04c:	41 4a       	lddsp	r10,sp[0x50]
8000a04e:	58 0a       	cp.w	r10,0
8000a050:	c2 a0       	breq	8000a0a4 <_dtoa_r+0x470>
8000a052:	fa e8 00 08 	ld.d	r8,sp[8]
8000a056:	58 01       	cp.w	r1,0
8000a058:	5f 94       	srgt	r4
8000a05a:	fa e9 00 18 	st.d	sp[24],r8
8000a05e:	30 08       	mov	r8,0
8000a060:	fc 19 3f f0 	movh	r9,0x3ff0
8000a064:	fa ea 00 18 	ld.d	r10,sp[24]
8000a068:	e0 a0 0f 60 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a06c:	f9 bc 00 00 	moveq	r12,0
8000a070:	f9 bc 01 01 	movne	r12,1
8000a074:	e9 ec 00 0c 	and	r12,r4,r12
8000a078:	c1 60       	breq	8000a0a4 <_dtoa_r+0x470>
8000a07a:	40 98       	lddsp	r8,sp[0x24]
8000a07c:	58 08       	cp.w	r8,0
8000a07e:	e0 8a 00 f1 	brle	8000a260 <_dtoa_r+0x62c>
8000a082:	30 08       	mov	r8,0
8000a084:	fc 19 40 24 	movh	r9,0x4024
8000a088:	ec c4 00 01 	sub	r4,r6,1
8000a08c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a090:	2f f5       	sub	r5,-1
8000a092:	50 64       	stdsp	sp[0x18],r4
8000a094:	e0 a0 0c 38 	rcall	8000b904 <__avr32_f64_mul>
8000a098:	40 94       	lddsp	r4,sp[0x24]
8000a09a:	14 98       	mov	r8,r10
8000a09c:	16 99       	mov	r9,r11
8000a09e:	fa e9 00 08 	st.d	sp[8],r8
8000a0a2:	c0 38       	rjmp	8000a0a8 <_dtoa_r+0x474>
8000a0a4:	50 66       	stdsp	sp[0x18],r6
8000a0a6:	02 94       	mov	r4,r1
8000a0a8:	0a 9c       	mov	r12,r5
8000a0aa:	e0 a0 0e 88 	rcall	8000bdba <__avr32_s32_to_f64>
8000a0ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0b2:	e0 a0 0c 29 	rcall	8000b904 <__avr32_f64_mul>
8000a0b6:	30 08       	mov	r8,0
8000a0b8:	fc 19 40 1c 	movh	r9,0x401c
8000a0bc:	e0 a0 0d de 	rcall	8000bc78 <__avr32_f64_add>
8000a0c0:	14 98       	mov	r8,r10
8000a0c2:	16 99       	mov	r9,r11
8000a0c4:	fa e9 00 28 	st.d	sp[40],r8
8000a0c8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a0cc:	40 a5       	lddsp	r5,sp[0x28]
8000a0ce:	10 05       	add	r5,r8
8000a0d0:	50 a5       	stdsp	sp[0x28],r5
8000a0d2:	58 04       	cp.w	r4,0
8000a0d4:	c2 11       	brne	8000a116 <_dtoa_r+0x4e2>
8000a0d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0da:	30 08       	mov	r8,0
8000a0dc:	fc 19 40 14 	movh	r9,0x4014
8000a0e0:	e0 a0 0c fe 	rcall	8000badc <__avr32_f64_sub>
8000a0e4:	40 bc       	lddsp	r12,sp[0x2c]
8000a0e6:	fa eb 00 08 	st.d	sp[8],r10
8000a0ea:	14 98       	mov	r8,r10
8000a0ec:	16 99       	mov	r9,r11
8000a0ee:	18 9a       	mov	r10,r12
8000a0f0:	0a 9b       	mov	r11,r5
8000a0f2:	e0 a0 0f 1b 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a0f6:	e0 81 02 54 	brne	8000a59e <_dtoa_r+0x96a>
8000a0fa:	0a 98       	mov	r8,r5
8000a0fc:	40 b9       	lddsp	r9,sp[0x2c]
8000a0fe:	ee 18 80 00 	eorh	r8,0x8000
8000a102:	fa ea 00 08 	ld.d	r10,sp[8]
8000a106:	10 95       	mov	r5,r8
8000a108:	12 98       	mov	r8,r9
8000a10a:	0a 99       	mov	r9,r5
8000a10c:	e0 a0 0f 0e 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a110:	e0 81 02 3e 	brne	8000a58c <_dtoa_r+0x958>
8000a114:	ca 68       	rjmp	8000a260 <_dtoa_r+0x62c>
8000a116:	fe c9 c6 b2 	sub	r9,pc,-14670
8000a11a:	e8 c8 00 01 	sub	r8,r4,1
8000a11e:	40 d5       	lddsp	r5,sp[0x34]
8000a120:	58 05       	cp.w	r5,0
8000a122:	c4 f0       	breq	8000a1c0 <_dtoa_r+0x58c>
8000a124:	30 0c       	mov	r12,0
8000a126:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a12a:	51 3c       	stdsp	sp[0x4c],r12
8000a12c:	30 0a       	mov	r10,0
8000a12e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a132:	e0 a0 0f 2f 	rcall	8000bf90 <__avr32_f64_div>
8000a136:	fa e8 00 28 	ld.d	r8,sp[40]
8000a13a:	40 85       	lddsp	r5,sp[0x20]
8000a13c:	e0 a0 0c d0 	rcall	8000badc <__avr32_f64_sub>
8000a140:	fa eb 00 28 	st.d	sp[40],r10
8000a144:	fa ea 00 08 	ld.d	r10,sp[8]
8000a148:	e0 a0 0e 22 	rcall	8000bd8c <__avr32_f64_to_s32>
8000a14c:	51 6c       	stdsp	sp[0x58],r12
8000a14e:	e0 a0 0e 36 	rcall	8000bdba <__avr32_s32_to_f64>
8000a152:	14 98       	mov	r8,r10
8000a154:	16 99       	mov	r9,r11
8000a156:	fa ea 00 08 	ld.d	r10,sp[8]
8000a15a:	e0 a0 0c c1 	rcall	8000badc <__avr32_f64_sub>
8000a15e:	fa eb 00 08 	st.d	sp[8],r10
8000a162:	41 68       	lddsp	r8,sp[0x58]
8000a164:	2d 08       	sub	r8,-48
8000a166:	0a c8       	st.b	r5++,r8
8000a168:	41 39       	lddsp	r9,sp[0x4c]
8000a16a:	2f f9       	sub	r9,-1
8000a16c:	51 39       	stdsp	sp[0x4c],r9
8000a16e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a172:	e0 a0 0e db 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a176:	e0 81 03 39 	brne	8000a7e8 <_dtoa_r+0xbb4>
8000a17a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a17e:	30 0a       	mov	r10,0
8000a180:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a184:	e0 a0 0c ac 	rcall	8000badc <__avr32_f64_sub>
8000a188:	fa e8 00 28 	ld.d	r8,sp[40]
8000a18c:	e0 a0 0e ce 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a190:	fa ea 00 28 	ld.d	r10,sp[40]
8000a194:	30 08       	mov	r8,0
8000a196:	fc 19 40 24 	movh	r9,0x4024
8000a19a:	e0 81 00 da 	brne	8000a34e <_dtoa_r+0x71a>
8000a19e:	41 3c       	lddsp	r12,sp[0x4c]
8000a1a0:	08 3c       	cp.w	r12,r4
8000a1a2:	c5 f4       	brge	8000a260 <_dtoa_r+0x62c>
8000a1a4:	e0 a0 0b b0 	rcall	8000b904 <__avr32_f64_mul>
8000a1a8:	30 08       	mov	r8,0
8000a1aa:	fa eb 00 28 	st.d	sp[40],r10
8000a1ae:	fc 19 40 24 	movh	r9,0x4024
8000a1b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1b6:	e0 a0 0b a7 	rcall	8000b904 <__avr32_f64_mul>
8000a1ba:	fa eb 00 08 	st.d	sp[8],r10
8000a1be:	cc 3b       	rjmp	8000a144 <_dtoa_r+0x510>
8000a1c0:	40 85       	lddsp	r5,sp[0x20]
8000a1c2:	08 05       	add	r5,r4
8000a1c4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a1c8:	51 35       	stdsp	sp[0x4c],r5
8000a1ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1ce:	40 85       	lddsp	r5,sp[0x20]
8000a1d0:	e0 a0 0b 9a 	rcall	8000b904 <__avr32_f64_mul>
8000a1d4:	fa eb 00 28 	st.d	sp[40],r10
8000a1d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1dc:	e0 a0 0d d8 	rcall	8000bd8c <__avr32_f64_to_s32>
8000a1e0:	51 6c       	stdsp	sp[0x58],r12
8000a1e2:	e0 a0 0d ec 	rcall	8000bdba <__avr32_s32_to_f64>
8000a1e6:	14 98       	mov	r8,r10
8000a1e8:	16 99       	mov	r9,r11
8000a1ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1ee:	e0 a0 0c 77 	rcall	8000badc <__avr32_f64_sub>
8000a1f2:	fa eb 00 08 	st.d	sp[8],r10
8000a1f6:	41 68       	lddsp	r8,sp[0x58]
8000a1f8:	2d 08       	sub	r8,-48
8000a1fa:	0a c8       	st.b	r5++,r8
8000a1fc:	41 3c       	lddsp	r12,sp[0x4c]
8000a1fe:	18 35       	cp.w	r5,r12
8000a200:	c2 81       	brne	8000a250 <_dtoa_r+0x61c>
8000a202:	30 08       	mov	r8,0
8000a204:	fc 19 3f e0 	movh	r9,0x3fe0
8000a208:	fa ea 00 28 	ld.d	r10,sp[40]
8000a20c:	e0 a0 0d 36 	rcall	8000bc78 <__avr32_f64_add>
8000a210:	40 85       	lddsp	r5,sp[0x20]
8000a212:	fa e8 00 08 	ld.d	r8,sp[8]
8000a216:	08 05       	add	r5,r4
8000a218:	e0 a0 0e 88 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a21c:	e0 81 00 99 	brne	8000a34e <_dtoa_r+0x71a>
8000a220:	fa e8 00 28 	ld.d	r8,sp[40]
8000a224:	30 0a       	mov	r10,0
8000a226:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a22a:	e0 a0 0c 59 	rcall	8000badc <__avr32_f64_sub>
8000a22e:	14 98       	mov	r8,r10
8000a230:	16 99       	mov	r9,r11
8000a232:	fa ea 00 08 	ld.d	r10,sp[8]
8000a236:	e0 a0 0e 79 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a23a:	c1 30       	breq	8000a260 <_dtoa_r+0x62c>
8000a23c:	33 09       	mov	r9,48
8000a23e:	0a 98       	mov	r8,r5
8000a240:	11 7a       	ld.ub	r10,--r8
8000a242:	f2 0a 18 00 	cp.b	r10,r9
8000a246:	e0 81 02 d1 	brne	8000a7e8 <_dtoa_r+0xbb4>
8000a24a:	10 95       	mov	r5,r8
8000a24c:	cf 9b       	rjmp	8000a23e <_dtoa_r+0x60a>
8000a24e:	d7 03       	nop
8000a250:	30 08       	mov	r8,0
8000a252:	fc 19 40 24 	movh	r9,0x4024
8000a256:	e0 a0 0b 57 	rcall	8000b904 <__avr32_f64_mul>
8000a25a:	fa eb 00 08 	st.d	sp[8],r10
8000a25e:	cb db       	rjmp	8000a1d8 <_dtoa_r+0x5a4>
8000a260:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a264:	fa eb 00 08 	st.d	sp[8],r10
8000a268:	58 e6       	cp.w	r6,14
8000a26a:	5f ab       	srle	r11
8000a26c:	41 8a       	lddsp	r10,sp[0x60]
8000a26e:	30 08       	mov	r8,0
8000a270:	f4 09 11 ff 	rsub	r9,r10,-1
8000a274:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a278:	f0 09 18 00 	cp.b	r9,r8
8000a27c:	e0 80 00 82 	breq	8000a380 <_dtoa_r+0x74c>
8000a280:	40 ea       	lddsp	r10,sp[0x38]
8000a282:	58 01       	cp.w	r1,0
8000a284:	5f a9       	srle	r9
8000a286:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a28a:	fe ca c8 26 	sub	r10,pc,-14298
8000a28e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a292:	fa e5 00 10 	st.d	sp[16],r4
8000a296:	f0 09 18 00 	cp.b	r9,r8
8000a29a:	c1 40       	breq	8000a2c2 <_dtoa_r+0x68e>
8000a29c:	58 01       	cp.w	r1,0
8000a29e:	e0 81 01 77 	brne	8000a58c <_dtoa_r+0x958>
8000a2a2:	30 08       	mov	r8,0
8000a2a4:	fc 19 40 14 	movh	r9,0x4014
8000a2a8:	08 9a       	mov	r10,r4
8000a2aa:	0a 9b       	mov	r11,r5
8000a2ac:	e0 a0 0b 2c 	rcall	8000b904 <__avr32_f64_mul>
8000a2b0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2b4:	e0 a0 0e 06 	rcall	8000bec0 <__avr32_f64_cmp_ge>
8000a2b8:	e0 81 01 6a 	brne	8000a58c <_dtoa_r+0x958>
8000a2bc:	02 92       	mov	r2,r1
8000a2be:	e0 8f 01 72 	bral	8000a5a2 <_dtoa_r+0x96e>
8000a2c2:	40 85       	lddsp	r5,sp[0x20]
8000a2c4:	30 14       	mov	r4,1
8000a2c6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2ce:	e0 a0 0e 61 	rcall	8000bf90 <__avr32_f64_div>
8000a2d2:	e0 a0 0d 5d 	rcall	8000bd8c <__avr32_f64_to_s32>
8000a2d6:	18 92       	mov	r2,r12
8000a2d8:	e0 a0 0d 71 	rcall	8000bdba <__avr32_s32_to_f64>
8000a2dc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2e0:	e0 a0 0b 12 	rcall	8000b904 <__avr32_f64_mul>
8000a2e4:	14 98       	mov	r8,r10
8000a2e6:	16 99       	mov	r9,r11
8000a2e8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2ec:	e0 a0 0b f8 	rcall	8000badc <__avr32_f64_sub>
8000a2f0:	fa eb 00 08 	st.d	sp[8],r10
8000a2f4:	e4 c8 ff d0 	sub	r8,r2,-48
8000a2f8:	0a c8       	st.b	r5++,r8
8000a2fa:	fc 19 40 24 	movh	r9,0x4024
8000a2fe:	30 08       	mov	r8,0
8000a300:	02 34       	cp.w	r4,r1
8000a302:	c3 31       	brne	8000a368 <_dtoa_r+0x734>
8000a304:	fa e8 00 08 	ld.d	r8,sp[8]
8000a308:	e0 a0 0c b8 	rcall	8000bc78 <__avr32_f64_add>
8000a30c:	16 91       	mov	r1,r11
8000a30e:	14 90       	mov	r0,r10
8000a310:	14 98       	mov	r8,r10
8000a312:	02 99       	mov	r9,r1
8000a314:	fa ea 00 10 	ld.d	r10,sp[16]
8000a318:	e0 a0 0e 08 	rcall	8000bf28 <__avr32_f64_cmp_lt>
8000a31c:	c1 a1       	brne	8000a350 <_dtoa_r+0x71c>
8000a31e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a322:	00 9a       	mov	r10,r0
8000a324:	02 9b       	mov	r11,r1
8000a326:	e0 a0 0d ba 	rcall	8000be9a <__avr32_f64_cmp_eq>
8000a32a:	e0 80 02 5e 	breq	8000a7e6 <_dtoa_r+0xbb2>
8000a32e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a332:	c0 f1       	brne	8000a350 <_dtoa_r+0x71c>
8000a334:	e0 8f 02 59 	bral	8000a7e6 <_dtoa_r+0xbb2>
8000a338:	40 8a       	lddsp	r10,sp[0x20]
8000a33a:	14 38       	cp.w	r8,r10
8000a33c:	c0 30       	breq	8000a342 <_dtoa_r+0x70e>
8000a33e:	10 95       	mov	r5,r8
8000a340:	c0 98       	rjmp	8000a352 <_dtoa_r+0x71e>
8000a342:	33 08       	mov	r8,48
8000a344:	40 89       	lddsp	r9,sp[0x20]
8000a346:	2f f6       	sub	r6,-1
8000a348:	b2 88       	st.b	r9[0x0],r8
8000a34a:	40 88       	lddsp	r8,sp[0x20]
8000a34c:	c0 88       	rjmp	8000a35c <_dtoa_r+0x728>
8000a34e:	40 66       	lddsp	r6,sp[0x18]
8000a350:	33 99       	mov	r9,57
8000a352:	0a 98       	mov	r8,r5
8000a354:	11 7a       	ld.ub	r10,--r8
8000a356:	f2 0a 18 00 	cp.b	r10,r9
8000a35a:	ce f0       	breq	8000a338 <_dtoa_r+0x704>
8000a35c:	50 66       	stdsp	sp[0x18],r6
8000a35e:	11 89       	ld.ub	r9,r8[0x0]
8000a360:	2f f9       	sub	r9,-1
8000a362:	b0 89       	st.b	r8[0x0],r9
8000a364:	e0 8f 02 42 	bral	8000a7e8 <_dtoa_r+0xbb4>
8000a368:	e0 a0 0a ce 	rcall	8000b904 <__avr32_f64_mul>
8000a36c:	2f f4       	sub	r4,-1
8000a36e:	fa eb 00 08 	st.d	sp[8],r10
8000a372:	30 08       	mov	r8,0
8000a374:	30 09       	mov	r9,0
8000a376:	e0 a0 0d 92 	rcall	8000be9a <__avr32_f64_cmp_eq>
8000a37a:	ca 60       	breq	8000a2c6 <_dtoa_r+0x692>
8000a37c:	e0 8f 02 35 	bral	8000a7e6 <_dtoa_r+0xbb2>
8000a380:	40 d8       	lddsp	r8,sp[0x34]
8000a382:	58 08       	cp.w	r8,0
8000a384:	c0 51       	brne	8000a38e <_dtoa_r+0x75a>
8000a386:	04 98       	mov	r8,r2
8000a388:	00 95       	mov	r5,r0
8000a38a:	40 d4       	lddsp	r4,sp[0x34]
8000a38c:	c3 78       	rjmp	8000a3fa <_dtoa_r+0x7c6>
8000a38e:	40 c5       	lddsp	r5,sp[0x30]
8000a390:	58 15       	cp.w	r5,1
8000a392:	e0 89 00 0f 	brgt	8000a3b0 <_dtoa_r+0x77c>
8000a396:	41 74       	lddsp	r4,sp[0x5c]
8000a398:	58 04       	cp.w	r4,0
8000a39a:	c0 40       	breq	8000a3a2 <_dtoa_r+0x76e>
8000a39c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a3a0:	c0 48       	rjmp	8000a3a8 <_dtoa_r+0x774>
8000a3a2:	41 99       	lddsp	r9,sp[0x64]
8000a3a4:	f2 09 11 36 	rsub	r9,r9,54
8000a3a8:	04 98       	mov	r8,r2
8000a3aa:	00 95       	mov	r5,r0
8000a3ac:	c1 c8       	rjmp	8000a3e4 <_dtoa_r+0x7b0>
8000a3ae:	d7 03       	nop
8000a3b0:	e2 c8 00 01 	sub	r8,r1,1
8000a3b4:	58 01       	cp.w	r1,0
8000a3b6:	e0 05 17 40 	movge	r5,r0
8000a3ba:	e2 09 17 40 	movge	r9,r1
8000a3be:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a3c2:	f9 b9 05 00 	movlt	r9,0
8000a3c6:	10 32       	cp.w	r2,r8
8000a3c8:	e5 d8 e4 18 	subge	r8,r2,r8
8000a3cc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a3d0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a3d4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a3d8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a3dc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a3e0:	f9 b8 05 00 	movlt	r8,0
8000a3e4:	40 4b       	lddsp	r11,sp[0x10]
8000a3e6:	12 0b       	add	r11,r9
8000a3e8:	50 08       	stdsp	sp[0x0],r8
8000a3ea:	50 4b       	stdsp	sp[0x10],r11
8000a3ec:	12 00       	add	r0,r9
8000a3ee:	30 1b       	mov	r11,1
8000a3f0:	0e 9c       	mov	r12,r7
8000a3f2:	e0 a0 08 a7 	rcall	8000b540 <__i2b>
8000a3f6:	40 08       	lddsp	r8,sp[0x0]
8000a3f8:	18 94       	mov	r4,r12
8000a3fa:	40 4a       	lddsp	r10,sp[0x10]
8000a3fc:	58 05       	cp.w	r5,0
8000a3fe:	5f 99       	srgt	r9
8000a400:	58 0a       	cp.w	r10,0
8000a402:	5f 9a       	srgt	r10
8000a404:	f5 e9 00 09 	and	r9,r10,r9
8000a408:	c0 80       	breq	8000a418 <_dtoa_r+0x7e4>
8000a40a:	40 4c       	lddsp	r12,sp[0x10]
8000a40c:	f8 05 0d 49 	min	r9,r12,r5
8000a410:	12 1c       	sub	r12,r9
8000a412:	12 10       	sub	r0,r9
8000a414:	50 4c       	stdsp	sp[0x10],r12
8000a416:	12 15       	sub	r5,r9
8000a418:	58 02       	cp.w	r2,0
8000a41a:	e0 8a 00 27 	brle	8000a468 <_dtoa_r+0x834>
8000a41e:	40 db       	lddsp	r11,sp[0x34]
8000a420:	58 0b       	cp.w	r11,0
8000a422:	c1 d0       	breq	8000a45c <_dtoa_r+0x828>
8000a424:	58 08       	cp.w	r8,0
8000a426:	e0 8a 00 17 	brle	8000a454 <_dtoa_r+0x820>
8000a42a:	10 9a       	mov	r10,r8
8000a42c:	50 08       	stdsp	sp[0x0],r8
8000a42e:	08 9b       	mov	r11,r4
8000a430:	0e 9c       	mov	r12,r7
8000a432:	e0 a0 08 cd 	rcall	8000b5cc <__pow5mult>
8000a436:	06 9a       	mov	r10,r3
8000a438:	18 9b       	mov	r11,r12
8000a43a:	18 94       	mov	r4,r12
8000a43c:	0e 9c       	mov	r12,r7
8000a43e:	e0 a0 08 01 	rcall	8000b440 <__multiply>
8000a442:	18 99       	mov	r9,r12
8000a444:	06 9b       	mov	r11,r3
8000a446:	50 19       	stdsp	sp[0x4],r9
8000a448:	0e 9c       	mov	r12,r7
8000a44a:	e0 a0 06 ad 	rcall	8000b1a4 <_Bfree>
8000a44e:	40 19       	lddsp	r9,sp[0x4]
8000a450:	40 08       	lddsp	r8,sp[0x0]
8000a452:	12 93       	mov	r3,r9
8000a454:	e4 08 01 0a 	sub	r10,r2,r8
8000a458:	c0 80       	breq	8000a468 <_dtoa_r+0x834>
8000a45a:	c0 28       	rjmp	8000a45e <_dtoa_r+0x82a>
8000a45c:	04 9a       	mov	r10,r2
8000a45e:	06 9b       	mov	r11,r3
8000a460:	0e 9c       	mov	r12,r7
8000a462:	e0 a0 08 b5 	rcall	8000b5cc <__pow5mult>
8000a466:	18 93       	mov	r3,r12
8000a468:	30 1b       	mov	r11,1
8000a46a:	0e 9c       	mov	r12,r7
8000a46c:	e0 a0 08 6a 	rcall	8000b540 <__i2b>
8000a470:	41 1a       	lddsp	r10,sp[0x44]
8000a472:	18 92       	mov	r2,r12
8000a474:	58 0a       	cp.w	r10,0
8000a476:	e0 8a 00 07 	brle	8000a484 <_dtoa_r+0x850>
8000a47a:	18 9b       	mov	r11,r12
8000a47c:	0e 9c       	mov	r12,r7
8000a47e:	e0 a0 08 a7 	rcall	8000b5cc <__pow5mult>
8000a482:	18 92       	mov	r2,r12
8000a484:	40 c9       	lddsp	r9,sp[0x30]
8000a486:	58 19       	cp.w	r9,1
8000a488:	e0 89 00 14 	brgt	8000a4b0 <_dtoa_r+0x87c>
8000a48c:	40 38       	lddsp	r8,sp[0xc]
8000a48e:	58 08       	cp.w	r8,0
8000a490:	c1 01       	brne	8000a4b0 <_dtoa_r+0x87c>
8000a492:	40 29       	lddsp	r9,sp[0x8]
8000a494:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a498:	c0 c1       	brne	8000a4b0 <_dtoa_r+0x87c>
8000a49a:	12 98       	mov	r8,r9
8000a49c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a4a0:	c0 80       	breq	8000a4b0 <_dtoa_r+0x87c>
8000a4a2:	40 4c       	lddsp	r12,sp[0x10]
8000a4a4:	30 1b       	mov	r11,1
8000a4a6:	2f fc       	sub	r12,-1
8000a4a8:	2f f0       	sub	r0,-1
8000a4aa:	50 4c       	stdsp	sp[0x10],r12
8000a4ac:	50 6b       	stdsp	sp[0x18],r11
8000a4ae:	c0 38       	rjmp	8000a4b4 <_dtoa_r+0x880>
8000a4b0:	30 0a       	mov	r10,0
8000a4b2:	50 6a       	stdsp	sp[0x18],r10
8000a4b4:	41 19       	lddsp	r9,sp[0x44]
8000a4b6:	58 09       	cp.w	r9,0
8000a4b8:	c0 31       	brne	8000a4be <_dtoa_r+0x88a>
8000a4ba:	30 1c       	mov	r12,1
8000a4bc:	c0 98       	rjmp	8000a4ce <_dtoa_r+0x89a>
8000a4be:	64 48       	ld.w	r8,r2[0x10]
8000a4c0:	2f c8       	sub	r8,-4
8000a4c2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a4c6:	e0 a0 05 df 	rcall	8000b084 <__hi0bits>
8000a4ca:	f8 0c 11 20 	rsub	r12,r12,32
8000a4ce:	40 4b       	lddsp	r11,sp[0x10]
8000a4d0:	f8 0b 00 08 	add	r8,r12,r11
8000a4d4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a4d8:	c0 c0       	breq	8000a4f0 <_dtoa_r+0x8bc>
8000a4da:	f0 08 11 20 	rsub	r8,r8,32
8000a4de:	58 48       	cp.w	r8,4
8000a4e0:	e0 8a 00 06 	brle	8000a4ec <_dtoa_r+0x8b8>
8000a4e4:	20 48       	sub	r8,4
8000a4e6:	10 0b       	add	r11,r8
8000a4e8:	50 4b       	stdsp	sp[0x10],r11
8000a4ea:	c0 78       	rjmp	8000a4f8 <_dtoa_r+0x8c4>
8000a4ec:	58 48       	cp.w	r8,4
8000a4ee:	c0 70       	breq	8000a4fc <_dtoa_r+0x8c8>
8000a4f0:	40 4a       	lddsp	r10,sp[0x10]
8000a4f2:	2e 48       	sub	r8,-28
8000a4f4:	10 0a       	add	r10,r8
8000a4f6:	50 4a       	stdsp	sp[0x10],r10
8000a4f8:	10 00       	add	r0,r8
8000a4fa:	10 05       	add	r5,r8
8000a4fc:	58 00       	cp.w	r0,0
8000a4fe:	e0 8a 00 08 	brle	8000a50e <_dtoa_r+0x8da>
8000a502:	06 9b       	mov	r11,r3
8000a504:	00 9a       	mov	r10,r0
8000a506:	0e 9c       	mov	r12,r7
8000a508:	e0 a0 07 58 	rcall	8000b3b8 <__lshift>
8000a50c:	18 93       	mov	r3,r12
8000a50e:	40 49       	lddsp	r9,sp[0x10]
8000a510:	58 09       	cp.w	r9,0
8000a512:	e0 8a 00 08 	brle	8000a522 <_dtoa_r+0x8ee>
8000a516:	04 9b       	mov	r11,r2
8000a518:	12 9a       	mov	r10,r9
8000a51a:	0e 9c       	mov	r12,r7
8000a51c:	e0 a0 07 4e 	rcall	8000b3b8 <__lshift>
8000a520:	18 92       	mov	r2,r12
8000a522:	41 48       	lddsp	r8,sp[0x50]
8000a524:	58 08       	cp.w	r8,0
8000a526:	c1 b0       	breq	8000a55c <_dtoa_r+0x928>
8000a528:	04 9b       	mov	r11,r2
8000a52a:	06 9c       	mov	r12,r3
8000a52c:	e0 a0 06 23 	rcall	8000b172 <__mcmp>
8000a530:	c1 64       	brge	8000a55c <_dtoa_r+0x928>
8000a532:	06 9b       	mov	r11,r3
8000a534:	30 09       	mov	r9,0
8000a536:	30 aa       	mov	r10,10
8000a538:	0e 9c       	mov	r12,r7
8000a53a:	e0 a0 08 0b 	rcall	8000b550 <__multadd>
8000a53e:	20 16       	sub	r6,1
8000a540:	18 93       	mov	r3,r12
8000a542:	40 dc       	lddsp	r12,sp[0x34]
8000a544:	58 0c       	cp.w	r12,0
8000a546:	c0 31       	brne	8000a54c <_dtoa_r+0x918>
8000a548:	40 91       	lddsp	r1,sp[0x24]
8000a54a:	c0 98       	rjmp	8000a55c <_dtoa_r+0x928>
8000a54c:	08 9b       	mov	r11,r4
8000a54e:	40 91       	lddsp	r1,sp[0x24]
8000a550:	30 09       	mov	r9,0
8000a552:	30 aa       	mov	r10,10
8000a554:	0e 9c       	mov	r12,r7
8000a556:	e0 a0 07 fd 	rcall	8000b550 <__multadd>
8000a55a:	18 94       	mov	r4,r12
8000a55c:	58 01       	cp.w	r1,0
8000a55e:	5f a9       	srle	r9
8000a560:	40 cb       	lddsp	r11,sp[0x30]
8000a562:	58 2b       	cp.w	r11,2
8000a564:	5f 98       	srgt	r8
8000a566:	f3 e8 00 08 	and	r8,r9,r8
8000a56a:	c2 50       	breq	8000a5b4 <_dtoa_r+0x980>
8000a56c:	58 01       	cp.w	r1,0
8000a56e:	c1 11       	brne	8000a590 <_dtoa_r+0x95c>
8000a570:	04 9b       	mov	r11,r2
8000a572:	02 99       	mov	r9,r1
8000a574:	30 5a       	mov	r10,5
8000a576:	0e 9c       	mov	r12,r7
8000a578:	e0 a0 07 ec 	rcall	8000b550 <__multadd>
8000a57c:	18 92       	mov	r2,r12
8000a57e:	18 9b       	mov	r11,r12
8000a580:	06 9c       	mov	r12,r3
8000a582:	e0 a0 05 f8 	rcall	8000b172 <__mcmp>
8000a586:	e0 89 00 0f 	brgt	8000a5a4 <_dtoa_r+0x970>
8000a58a:	c0 38       	rjmp	8000a590 <_dtoa_r+0x95c>
8000a58c:	30 02       	mov	r2,0
8000a58e:	04 94       	mov	r4,r2
8000a590:	40 ea       	lddsp	r10,sp[0x38]
8000a592:	30 09       	mov	r9,0
8000a594:	5c da       	com	r10
8000a596:	40 85       	lddsp	r5,sp[0x20]
8000a598:	50 6a       	stdsp	sp[0x18],r10
8000a59a:	50 49       	stdsp	sp[0x10],r9
8000a59c:	c0 f9       	rjmp	8000a7ba <_dtoa_r+0xb86>
8000a59e:	08 92       	mov	r2,r4
8000a5a0:	40 66       	lddsp	r6,sp[0x18]
8000a5a2:	04 94       	mov	r4,r2
8000a5a4:	2f f6       	sub	r6,-1
8000a5a6:	50 66       	stdsp	sp[0x18],r6
8000a5a8:	33 18       	mov	r8,49
8000a5aa:	40 85       	lddsp	r5,sp[0x20]
8000a5ac:	0a c8       	st.b	r5++,r8
8000a5ae:	30 08       	mov	r8,0
8000a5b0:	50 48       	stdsp	sp[0x10],r8
8000a5b2:	c0 49       	rjmp	8000a7ba <_dtoa_r+0xb86>
8000a5b4:	40 dc       	lddsp	r12,sp[0x34]
8000a5b6:	58 0c       	cp.w	r12,0
8000a5b8:	e0 80 00 b5 	breq	8000a722 <_dtoa_r+0xaee>
8000a5bc:	58 05       	cp.w	r5,0
8000a5be:	e0 8a 00 08 	brle	8000a5ce <_dtoa_r+0x99a>
8000a5c2:	08 9b       	mov	r11,r4
8000a5c4:	0a 9a       	mov	r10,r5
8000a5c6:	0e 9c       	mov	r12,r7
8000a5c8:	e0 a0 06 f8 	rcall	8000b3b8 <__lshift>
8000a5cc:	18 94       	mov	r4,r12
8000a5ce:	40 6b       	lddsp	r11,sp[0x18]
8000a5d0:	58 0b       	cp.w	r11,0
8000a5d2:	c0 31       	brne	8000a5d8 <_dtoa_r+0x9a4>
8000a5d4:	08 9c       	mov	r12,r4
8000a5d6:	c1 38       	rjmp	8000a5fc <_dtoa_r+0x9c8>
8000a5d8:	68 1b       	ld.w	r11,r4[0x4]
8000a5da:	0e 9c       	mov	r12,r7
8000a5dc:	e0 a0 05 fe 	rcall	8000b1d8 <_Balloc>
8000a5e0:	68 4a       	ld.w	r10,r4[0x10]
8000a5e2:	18 95       	mov	r5,r12
8000a5e4:	e8 cb ff f4 	sub	r11,r4,-12
8000a5e8:	2f ea       	sub	r10,-2
8000a5ea:	2f 4c       	sub	r12,-12
8000a5ec:	a3 6a       	lsl	r10,0x2
8000a5ee:	fe b0 e6 4f 	rcall	8000728c <memcpy>
8000a5f2:	0a 9b       	mov	r11,r5
8000a5f4:	30 1a       	mov	r10,1
8000a5f6:	0e 9c       	mov	r12,r7
8000a5f8:	e0 a0 06 e0 	rcall	8000b3b8 <__lshift>
8000a5fc:	50 44       	stdsp	sp[0x10],r4
8000a5fe:	40 3a       	lddsp	r10,sp[0xc]
8000a600:	30 19       	mov	r9,1
8000a602:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a606:	18 94       	mov	r4,r12
8000a608:	50 da       	stdsp	sp[0x34],r10
8000a60a:	40 85       	lddsp	r5,sp[0x20]
8000a60c:	50 99       	stdsp	sp[0x24],r9
8000a60e:	50 26       	stdsp	sp[0x8],r6
8000a610:	50 e1       	stdsp	sp[0x38],r1
8000a612:	04 9b       	mov	r11,r2
8000a614:	06 9c       	mov	r12,r3
8000a616:	fe b0 fa 7f 	rcall	80009b14 <quorem>
8000a61a:	40 4b       	lddsp	r11,sp[0x10]
8000a61c:	f8 c0 ff d0 	sub	r0,r12,-48
8000a620:	06 9c       	mov	r12,r3
8000a622:	e0 a0 05 a8 	rcall	8000b172 <__mcmp>
8000a626:	08 9a       	mov	r10,r4
8000a628:	50 6c       	stdsp	sp[0x18],r12
8000a62a:	04 9b       	mov	r11,r2
8000a62c:	0e 9c       	mov	r12,r7
8000a62e:	e0 a0 06 5d 	rcall	8000b2e8 <__mdiff>
8000a632:	18 91       	mov	r1,r12
8000a634:	78 38       	ld.w	r8,r12[0xc]
8000a636:	58 08       	cp.w	r8,0
8000a638:	c0 30       	breq	8000a63e <_dtoa_r+0xa0a>
8000a63a:	30 16       	mov	r6,1
8000a63c:	c0 68       	rjmp	8000a648 <_dtoa_r+0xa14>
8000a63e:	18 9b       	mov	r11,r12
8000a640:	06 9c       	mov	r12,r3
8000a642:	e0 a0 05 98 	rcall	8000b172 <__mcmp>
8000a646:	18 96       	mov	r6,r12
8000a648:	0e 9c       	mov	r12,r7
8000a64a:	02 9b       	mov	r11,r1
8000a64c:	e0 a0 05 ac 	rcall	8000b1a4 <_Bfree>
8000a650:	40 cc       	lddsp	r12,sp[0x30]
8000a652:	ed ec 10 08 	or	r8,r6,r12
8000a656:	c0 d1       	brne	8000a670 <_dtoa_r+0xa3c>
8000a658:	40 db       	lddsp	r11,sp[0x34]
8000a65a:	58 0b       	cp.w	r11,0
8000a65c:	c0 a1       	brne	8000a670 <_dtoa_r+0xa3c>
8000a65e:	40 26       	lddsp	r6,sp[0x8]
8000a660:	e0 40 00 39 	cp.w	r0,57
8000a664:	c3 00       	breq	8000a6c4 <_dtoa_r+0xa90>
8000a666:	40 6a       	lddsp	r10,sp[0x18]
8000a668:	58 0a       	cp.w	r10,0
8000a66a:	e0 89 00 24 	brgt	8000a6b2 <_dtoa_r+0xa7e>
8000a66e:	c2 f8       	rjmp	8000a6cc <_dtoa_r+0xa98>
8000a670:	40 69       	lddsp	r9,sp[0x18]
8000a672:	58 09       	cp.w	r9,0
8000a674:	c0 85       	brlt	8000a684 <_dtoa_r+0xa50>
8000a676:	12 98       	mov	r8,r9
8000a678:	40 cc       	lddsp	r12,sp[0x30]
8000a67a:	18 48       	or	r8,r12
8000a67c:	c1 d1       	brne	8000a6b6 <_dtoa_r+0xa82>
8000a67e:	40 db       	lddsp	r11,sp[0x34]
8000a680:	58 0b       	cp.w	r11,0
8000a682:	c1 a1       	brne	8000a6b6 <_dtoa_r+0xa82>
8000a684:	0c 99       	mov	r9,r6
8000a686:	40 26       	lddsp	r6,sp[0x8]
8000a688:	58 09       	cp.w	r9,0
8000a68a:	e0 8a 00 21 	brle	8000a6cc <_dtoa_r+0xa98>
8000a68e:	06 9b       	mov	r11,r3
8000a690:	30 1a       	mov	r10,1
8000a692:	0e 9c       	mov	r12,r7
8000a694:	e0 a0 06 92 	rcall	8000b3b8 <__lshift>
8000a698:	04 9b       	mov	r11,r2
8000a69a:	18 93       	mov	r3,r12
8000a69c:	e0 a0 05 6b 	rcall	8000b172 <__mcmp>
8000a6a0:	e0 89 00 06 	brgt	8000a6ac <_dtoa_r+0xa78>
8000a6a4:	c1 41       	brne	8000a6cc <_dtoa_r+0xa98>
8000a6a6:	ed b0 00 00 	bld	r0,0x0
8000a6aa:	c1 11       	brne	8000a6cc <_dtoa_r+0xa98>
8000a6ac:	e0 40 00 39 	cp.w	r0,57
8000a6b0:	c0 a0       	breq	8000a6c4 <_dtoa_r+0xa90>
8000a6b2:	2f f0       	sub	r0,-1
8000a6b4:	c0 c8       	rjmp	8000a6cc <_dtoa_r+0xa98>
8000a6b6:	58 06       	cp.w	r6,0
8000a6b8:	e0 8a 00 0c 	brle	8000a6d0 <_dtoa_r+0xa9c>
8000a6bc:	40 26       	lddsp	r6,sp[0x8]
8000a6be:	e0 40 00 39 	cp.w	r0,57
8000a6c2:	c0 41       	brne	8000a6ca <_dtoa_r+0xa96>
8000a6c4:	33 98       	mov	r8,57
8000a6c6:	0a c8       	st.b	r5++,r8
8000a6c8:	c6 78       	rjmp	8000a796 <_dtoa_r+0xb62>
8000a6ca:	2f f0       	sub	r0,-1
8000a6cc:	0a c0       	st.b	r5++,r0
8000a6ce:	c7 58       	rjmp	8000a7b8 <_dtoa_r+0xb84>
8000a6d0:	0a c0       	st.b	r5++,r0
8000a6d2:	40 9a       	lddsp	r10,sp[0x24]
8000a6d4:	40 e9       	lddsp	r9,sp[0x38]
8000a6d6:	12 3a       	cp.w	r10,r9
8000a6d8:	c4 30       	breq	8000a75e <_dtoa_r+0xb2a>
8000a6da:	06 9b       	mov	r11,r3
8000a6dc:	30 09       	mov	r9,0
8000a6de:	30 aa       	mov	r10,10
8000a6e0:	0e 9c       	mov	r12,r7
8000a6e2:	e0 a0 07 37 	rcall	8000b550 <__multadd>
8000a6e6:	40 48       	lddsp	r8,sp[0x10]
8000a6e8:	18 93       	mov	r3,r12
8000a6ea:	08 38       	cp.w	r8,r4
8000a6ec:	c0 91       	brne	8000a6fe <_dtoa_r+0xaca>
8000a6ee:	10 9b       	mov	r11,r8
8000a6f0:	30 09       	mov	r9,0
8000a6f2:	30 aa       	mov	r10,10
8000a6f4:	0e 9c       	mov	r12,r7
8000a6f6:	e0 a0 07 2d 	rcall	8000b550 <__multadd>
8000a6fa:	50 4c       	stdsp	sp[0x10],r12
8000a6fc:	c0 e8       	rjmp	8000a718 <_dtoa_r+0xae4>
8000a6fe:	40 4b       	lddsp	r11,sp[0x10]
8000a700:	30 09       	mov	r9,0
8000a702:	30 aa       	mov	r10,10
8000a704:	0e 9c       	mov	r12,r7
8000a706:	e0 a0 07 25 	rcall	8000b550 <__multadd>
8000a70a:	08 9b       	mov	r11,r4
8000a70c:	50 4c       	stdsp	sp[0x10],r12
8000a70e:	30 09       	mov	r9,0
8000a710:	30 aa       	mov	r10,10
8000a712:	0e 9c       	mov	r12,r7
8000a714:	e0 a0 07 1e 	rcall	8000b550 <__multadd>
8000a718:	18 94       	mov	r4,r12
8000a71a:	40 9c       	lddsp	r12,sp[0x24]
8000a71c:	2f fc       	sub	r12,-1
8000a71e:	50 9c       	stdsp	sp[0x24],r12
8000a720:	c7 9b       	rjmp	8000a612 <_dtoa_r+0x9de>
8000a722:	30 18       	mov	r8,1
8000a724:	06 90       	mov	r0,r3
8000a726:	40 85       	lddsp	r5,sp[0x20]
8000a728:	08 93       	mov	r3,r4
8000a72a:	0c 94       	mov	r4,r6
8000a72c:	10 96       	mov	r6,r8
8000a72e:	04 9b       	mov	r11,r2
8000a730:	00 9c       	mov	r12,r0
8000a732:	fe b0 f9 f1 	rcall	80009b14 <quorem>
8000a736:	2d 0c       	sub	r12,-48
8000a738:	0a cc       	st.b	r5++,r12
8000a73a:	02 36       	cp.w	r6,r1
8000a73c:	c0 a4       	brge	8000a750 <_dtoa_r+0xb1c>
8000a73e:	00 9b       	mov	r11,r0
8000a740:	30 09       	mov	r9,0
8000a742:	30 aa       	mov	r10,10
8000a744:	0e 9c       	mov	r12,r7
8000a746:	2f f6       	sub	r6,-1
8000a748:	e0 a0 07 04 	rcall	8000b550 <__multadd>
8000a74c:	18 90       	mov	r0,r12
8000a74e:	cf 0b       	rjmp	8000a72e <_dtoa_r+0xafa>
8000a750:	08 96       	mov	r6,r4
8000a752:	30 0b       	mov	r11,0
8000a754:	06 94       	mov	r4,r3
8000a756:	50 4b       	stdsp	sp[0x10],r11
8000a758:	00 93       	mov	r3,r0
8000a75a:	18 90       	mov	r0,r12
8000a75c:	c0 28       	rjmp	8000a760 <_dtoa_r+0xb2c>
8000a75e:	40 26       	lddsp	r6,sp[0x8]
8000a760:	06 9b       	mov	r11,r3
8000a762:	30 1a       	mov	r10,1
8000a764:	0e 9c       	mov	r12,r7
8000a766:	e0 a0 06 29 	rcall	8000b3b8 <__lshift>
8000a76a:	04 9b       	mov	r11,r2
8000a76c:	18 93       	mov	r3,r12
8000a76e:	e0 a0 05 02 	rcall	8000b172 <__mcmp>
8000a772:	e0 89 00 12 	brgt	8000a796 <_dtoa_r+0xb62>
8000a776:	c1 b1       	brne	8000a7ac <_dtoa_r+0xb78>
8000a778:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a77c:	c0 d1       	brne	8000a796 <_dtoa_r+0xb62>
8000a77e:	c1 78       	rjmp	8000a7ac <_dtoa_r+0xb78>
8000a780:	40 89       	lddsp	r9,sp[0x20]
8000a782:	12 38       	cp.w	r8,r9
8000a784:	c0 30       	breq	8000a78a <_dtoa_r+0xb56>
8000a786:	10 95       	mov	r5,r8
8000a788:	c0 88       	rjmp	8000a798 <_dtoa_r+0xb64>
8000a78a:	2f f6       	sub	r6,-1
8000a78c:	50 66       	stdsp	sp[0x18],r6
8000a78e:	33 18       	mov	r8,49
8000a790:	40 8c       	lddsp	r12,sp[0x20]
8000a792:	b8 88       	st.b	r12[0x0],r8
8000a794:	c1 38       	rjmp	8000a7ba <_dtoa_r+0xb86>
8000a796:	33 9a       	mov	r10,57
8000a798:	0a 98       	mov	r8,r5
8000a79a:	11 79       	ld.ub	r9,--r8
8000a79c:	f4 09 18 00 	cp.b	r9,r10
8000a7a0:	cf 00       	breq	8000a780 <_dtoa_r+0xb4c>
8000a7a2:	2f f9       	sub	r9,-1
8000a7a4:	b0 89       	st.b	r8[0x0],r9
8000a7a6:	c0 98       	rjmp	8000a7b8 <_dtoa_r+0xb84>
8000a7a8:	10 95       	mov	r5,r8
8000a7aa:	c0 28       	rjmp	8000a7ae <_dtoa_r+0xb7a>
8000a7ac:	33 09       	mov	r9,48
8000a7ae:	0a 98       	mov	r8,r5
8000a7b0:	11 7a       	ld.ub	r10,--r8
8000a7b2:	f2 0a 18 00 	cp.b	r10,r9
8000a7b6:	cf 90       	breq	8000a7a8 <_dtoa_r+0xb74>
8000a7b8:	50 66       	stdsp	sp[0x18],r6
8000a7ba:	04 9b       	mov	r11,r2
8000a7bc:	0e 9c       	mov	r12,r7
8000a7be:	e0 a0 04 f3 	rcall	8000b1a4 <_Bfree>
8000a7c2:	58 04       	cp.w	r4,0
8000a7c4:	c1 20       	breq	8000a7e8 <_dtoa_r+0xbb4>
8000a7c6:	40 4b       	lddsp	r11,sp[0x10]
8000a7c8:	08 3b       	cp.w	r11,r4
8000a7ca:	5f 19       	srne	r9
8000a7cc:	58 0b       	cp.w	r11,0
8000a7ce:	5f 18       	srne	r8
8000a7d0:	f3 e8 00 08 	and	r8,r9,r8
8000a7d4:	c0 40       	breq	8000a7dc <_dtoa_r+0xba8>
8000a7d6:	0e 9c       	mov	r12,r7
8000a7d8:	e0 a0 04 e6 	rcall	8000b1a4 <_Bfree>
8000a7dc:	08 9b       	mov	r11,r4
8000a7de:	0e 9c       	mov	r12,r7
8000a7e0:	e0 a0 04 e2 	rcall	8000b1a4 <_Bfree>
8000a7e4:	c0 28       	rjmp	8000a7e8 <_dtoa_r+0xbb4>
8000a7e6:	50 66       	stdsp	sp[0x18],r6
8000a7e8:	0e 9c       	mov	r12,r7
8000a7ea:	06 9b       	mov	r11,r3
8000a7ec:	e0 a0 04 dc 	rcall	8000b1a4 <_Bfree>
8000a7f0:	30 08       	mov	r8,0
8000a7f2:	aa 88       	st.b	r5[0x0],r8
8000a7f4:	40 68       	lddsp	r8,sp[0x18]
8000a7f6:	41 5a       	lddsp	r10,sp[0x54]
8000a7f8:	2f f8       	sub	r8,-1
8000a7fa:	41 29       	lddsp	r9,sp[0x48]
8000a7fc:	95 08       	st.w	r10[0x0],r8
8000a7fe:	40 8c       	lddsp	r12,sp[0x20]
8000a800:	58 09       	cp.w	r9,0
8000a802:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a806:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a80a:	2e 6d       	sub	sp,-104
8000a80c:	d8 32       	popm	r0-r7,pc
8000a80e:	d7 03       	nop

8000a810 <__errno>:
8000a810:	e0 68 0a 38 	mov	r8,2616
8000a814:	70 0c       	ld.w	r12,r8[0x0]
8000a816:	2f 4c       	sub	r12,-12
8000a818:	5e fc       	retal	r12
8000a81a:	d7 03       	nop

8000a81c <_fflush_r>:
8000a81c:	d4 21       	pushm	r4-r7,lr
8000a81e:	16 97       	mov	r7,r11
8000a820:	18 96       	mov	r6,r12
8000a822:	76 48       	ld.w	r8,r11[0x10]
8000a824:	58 08       	cp.w	r8,0
8000a826:	c7 f0       	breq	8000a924 <_fflush_r+0x108>
8000a828:	58 0c       	cp.w	r12,0
8000a82a:	c0 50       	breq	8000a834 <_fflush_r+0x18>
8000a82c:	78 68       	ld.w	r8,r12[0x18]
8000a82e:	58 08       	cp.w	r8,0
8000a830:	c0 21       	brne	8000a834 <_fflush_r+0x18>
8000a832:	cc dc       	rcall	8000a9cc <__sinit>
8000a834:	fe c8 ce 80 	sub	r8,pc,-12672
8000a838:	10 37       	cp.w	r7,r8
8000a83a:	c0 31       	brne	8000a840 <_fflush_r+0x24>
8000a83c:	6c 07       	ld.w	r7,r6[0x0]
8000a83e:	c0 c8       	rjmp	8000a856 <_fflush_r+0x3a>
8000a840:	fe c8 ce 6c 	sub	r8,pc,-12692
8000a844:	10 37       	cp.w	r7,r8
8000a846:	c0 31       	brne	8000a84c <_fflush_r+0x30>
8000a848:	6c 17       	ld.w	r7,r6[0x4]
8000a84a:	c0 68       	rjmp	8000a856 <_fflush_r+0x3a>
8000a84c:	fe c8 ce 58 	sub	r8,pc,-12712
8000a850:	10 37       	cp.w	r7,r8
8000a852:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a856:	8e 6a       	ld.sh	r10,r7[0xc]
8000a858:	14 98       	mov	r8,r10
8000a85a:	ed ba 00 03 	bld	r10,0x3
8000a85e:	c4 20       	breq	8000a8e2 <_fflush_r+0xc6>
8000a860:	ab ba       	sbr	r10,0xb
8000a862:	ae 6a       	st.h	r7[0xc],r10
8000a864:	6e 18       	ld.w	r8,r7[0x4]
8000a866:	58 08       	cp.w	r8,0
8000a868:	e0 89 00 06 	brgt	8000a874 <_fflush_r+0x58>
8000a86c:	6f 08       	ld.w	r8,r7[0x40]
8000a86e:	58 08       	cp.w	r8,0
8000a870:	e0 8a 00 5a 	brle	8000a924 <_fflush_r+0x108>
8000a874:	6e b8       	ld.w	r8,r7[0x2c]
8000a876:	58 08       	cp.w	r8,0
8000a878:	c5 60       	breq	8000a924 <_fflush_r+0x108>
8000a87a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a87e:	c0 30       	breq	8000a884 <_fflush_r+0x68>
8000a880:	6f 55       	ld.w	r5,r7[0x54]
8000a882:	c0 f8       	rjmp	8000a8a0 <_fflush_r+0x84>
8000a884:	30 19       	mov	r9,1
8000a886:	6e 8b       	ld.w	r11,r7[0x20]
8000a888:	0c 9c       	mov	r12,r6
8000a88a:	5d 18       	icall	r8
8000a88c:	18 95       	mov	r5,r12
8000a88e:	5b fc       	cp.w	r12,-1
8000a890:	c0 81       	brne	8000a8a0 <_fflush_r+0x84>
8000a892:	6c 38       	ld.w	r8,r6[0xc]
8000a894:	59 d8       	cp.w	r8,29
8000a896:	c4 70       	breq	8000a924 <_fflush_r+0x108>
8000a898:	8e 68       	ld.sh	r8,r7[0xc]
8000a89a:	a7 a8       	sbr	r8,0x6
8000a89c:	ae 68       	st.h	r7[0xc],r8
8000a89e:	d8 22       	popm	r4-r7,pc
8000a8a0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8a2:	ed b8 00 02 	bld	r8,0x2
8000a8a6:	c0 91       	brne	8000a8b8 <_fflush_r+0x9c>
8000a8a8:	6e 18       	ld.w	r8,r7[0x4]
8000a8aa:	10 15       	sub	r5,r8
8000a8ac:	6e d8       	ld.w	r8,r7[0x34]
8000a8ae:	58 08       	cp.w	r8,0
8000a8b0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a8b4:	eb d8 e1 15 	subne	r5,r5,r8
8000a8b8:	6e b8       	ld.w	r8,r7[0x2c]
8000a8ba:	0c 9c       	mov	r12,r6
8000a8bc:	30 09       	mov	r9,0
8000a8be:	0a 9a       	mov	r10,r5
8000a8c0:	6e 8b       	ld.w	r11,r7[0x20]
8000a8c2:	5d 18       	icall	r8
8000a8c4:	8e 68       	ld.sh	r8,r7[0xc]
8000a8c6:	0a 3c       	cp.w	r12,r5
8000a8c8:	c2 61       	brne	8000a914 <_fflush_r+0xf8>
8000a8ca:	ab d8       	cbr	r8,0xb
8000a8cc:	30 0c       	mov	r12,0
8000a8ce:	6e 49       	ld.w	r9,r7[0x10]
8000a8d0:	ae 68       	st.h	r7[0xc],r8
8000a8d2:	8f 1c       	st.w	r7[0x4],r12
8000a8d4:	8f 09       	st.w	r7[0x0],r9
8000a8d6:	ed b8 00 0c 	bld	r8,0xc
8000a8da:	c2 51       	brne	8000a924 <_fflush_r+0x108>
8000a8dc:	ef 45 00 54 	st.w	r7[84],r5
8000a8e0:	d8 22       	popm	r4-r7,pc
8000a8e2:	6e 45       	ld.w	r5,r7[0x10]
8000a8e4:	58 05       	cp.w	r5,0
8000a8e6:	c1 f0       	breq	8000a924 <_fflush_r+0x108>
8000a8e8:	6e 04       	ld.w	r4,r7[0x0]
8000a8ea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a8ee:	8f 05       	st.w	r7[0x0],r5
8000a8f0:	f9 b8 01 00 	movne	r8,0
8000a8f4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a8f8:	0a 14       	sub	r4,r5
8000a8fa:	8f 28       	st.w	r7[0x8],r8
8000a8fc:	c1 18       	rjmp	8000a91e <_fflush_r+0x102>
8000a8fe:	08 99       	mov	r9,r4
8000a900:	0a 9a       	mov	r10,r5
8000a902:	6e a8       	ld.w	r8,r7[0x28]
8000a904:	6e 8b       	ld.w	r11,r7[0x20]
8000a906:	0c 9c       	mov	r12,r6
8000a908:	5d 18       	icall	r8
8000a90a:	18 14       	sub	r4,r12
8000a90c:	58 0c       	cp.w	r12,0
8000a90e:	e0 89 00 07 	brgt	8000a91c <_fflush_r+0x100>
8000a912:	8e 68       	ld.sh	r8,r7[0xc]
8000a914:	a7 a8       	sbr	r8,0x6
8000a916:	3f fc       	mov	r12,-1
8000a918:	ae 68       	st.h	r7[0xc],r8
8000a91a:	d8 22       	popm	r4-r7,pc
8000a91c:	18 05       	add	r5,r12
8000a91e:	58 04       	cp.w	r4,0
8000a920:	fe 99 ff ef 	brgt	8000a8fe <_fflush_r+0xe2>
8000a924:	d8 2a       	popm	r4-r7,pc,r12=0
8000a926:	d7 03       	nop

8000a928 <__sfp_lock_acquire>:
8000a928:	5e fc       	retal	r12

8000a92a <__sfp_lock_release>:
8000a92a:	5e fc       	retal	r12

8000a92c <_cleanup_r>:
8000a92c:	d4 01       	pushm	lr
8000a92e:	fe cb f0 ae 	sub	r11,pc,-3922
8000a932:	e0 a0 02 f7 	rcall	8000af20 <_fwalk>
8000a936:	d8 02       	popm	pc

8000a938 <__sfmoreglue>:
8000a938:	d4 21       	pushm	r4-r7,lr
8000a93a:	16 95       	mov	r5,r11
8000a93c:	f6 06 10 5c 	mul	r6,r11,92
8000a940:	ec cb ff f4 	sub	r11,r6,-12
8000a944:	fe b0 e2 88 	rcall	80006e54 <_malloc_r>
8000a948:	18 97       	mov	r7,r12
8000a94a:	c0 90       	breq	8000a95c <__sfmoreglue+0x24>
8000a94c:	99 15       	st.w	r12[0x4],r5
8000a94e:	30 0b       	mov	r11,0
8000a950:	2f 4c       	sub	r12,-12
8000a952:	0c 9a       	mov	r10,r6
8000a954:	8f 2c       	st.w	r7[0x8],r12
8000a956:	8f 0b       	st.w	r7[0x0],r11
8000a958:	fe b0 e5 3e 	rcall	800073d4 <memset>
8000a95c:	0e 9c       	mov	r12,r7
8000a95e:	d8 22       	popm	r4-r7,pc

8000a960 <__sfp>:
8000a960:	d4 21       	pushm	r4-r7,lr
8000a962:	fe c8 cf 4a 	sub	r8,pc,-12470
8000a966:	18 96       	mov	r6,r12
8000a968:	70 07       	ld.w	r7,r8[0x0]
8000a96a:	6e 68       	ld.w	r8,r7[0x18]
8000a96c:	58 08       	cp.w	r8,0
8000a96e:	c0 31       	brne	8000a974 <__sfp+0x14>
8000a970:	0e 9c       	mov	r12,r7
8000a972:	c2 dc       	rcall	8000a9cc <__sinit>
8000a974:	ee c7 ff 28 	sub	r7,r7,-216
8000a978:	30 05       	mov	r5,0
8000a97a:	6e 2c       	ld.w	r12,r7[0x8]
8000a97c:	6e 18       	ld.w	r8,r7[0x4]
8000a97e:	c0 68       	rjmp	8000a98a <__sfp+0x2a>
8000a980:	98 69       	ld.sh	r9,r12[0xc]
8000a982:	ea 09 19 00 	cp.h	r9,r5
8000a986:	c1 10       	breq	8000a9a8 <__sfp+0x48>
8000a988:	2a 4c       	sub	r12,-92
8000a98a:	20 18       	sub	r8,1
8000a98c:	cf a7       	brpl	8000a980 <__sfp+0x20>
8000a98e:	6e 08       	ld.w	r8,r7[0x0]
8000a990:	58 08       	cp.w	r8,0
8000a992:	c0 61       	brne	8000a99e <__sfp+0x3e>
8000a994:	30 4b       	mov	r11,4
8000a996:	0c 9c       	mov	r12,r6
8000a998:	cd 0f       	rcall	8000a938 <__sfmoreglue>
8000a99a:	8f 0c       	st.w	r7[0x0],r12
8000a99c:	c0 30       	breq	8000a9a2 <__sfp+0x42>
8000a99e:	6e 07       	ld.w	r7,r7[0x0]
8000a9a0:	ce db       	rjmp	8000a97a <__sfp+0x1a>
8000a9a2:	30 c8       	mov	r8,12
8000a9a4:	8d 38       	st.w	r6[0xc],r8
8000a9a6:	d8 22       	popm	r4-r7,pc
8000a9a8:	30 08       	mov	r8,0
8000a9aa:	f9 48 00 4c 	st.w	r12[76],r8
8000a9ae:	99 08       	st.w	r12[0x0],r8
8000a9b0:	99 28       	st.w	r12[0x8],r8
8000a9b2:	99 18       	st.w	r12[0x4],r8
8000a9b4:	99 48       	st.w	r12[0x10],r8
8000a9b6:	99 58       	st.w	r12[0x14],r8
8000a9b8:	99 68       	st.w	r12[0x18],r8
8000a9ba:	99 d8       	st.w	r12[0x34],r8
8000a9bc:	99 e8       	st.w	r12[0x38],r8
8000a9be:	f9 48 00 48 	st.w	r12[72],r8
8000a9c2:	3f f8       	mov	r8,-1
8000a9c4:	b8 78       	st.h	r12[0xe],r8
8000a9c6:	30 18       	mov	r8,1
8000a9c8:	b8 68       	st.h	r12[0xc],r8
8000a9ca:	d8 22       	popm	r4-r7,pc

8000a9cc <__sinit>:
8000a9cc:	d4 21       	pushm	r4-r7,lr
8000a9ce:	18 96       	mov	r6,r12
8000a9d0:	78 67       	ld.w	r7,r12[0x18]
8000a9d2:	58 07       	cp.w	r7,0
8000a9d4:	c4 91       	brne	8000aa66 <__sinit+0x9a>
8000a9d6:	fe c8 00 aa 	sub	r8,pc,170
8000a9da:	30 15       	mov	r5,1
8000a9dc:	99 a8       	st.w	r12[0x28],r8
8000a9de:	f9 47 00 d8 	st.w	r12[216],r7
8000a9e2:	f9 47 00 dc 	st.w	r12[220],r7
8000a9e6:	f9 47 00 e0 	st.w	r12[224],r7
8000a9ea:	99 65       	st.w	r12[0x18],r5
8000a9ec:	cb af       	rcall	8000a960 <__sfp>
8000a9ee:	8d 0c       	st.w	r6[0x0],r12
8000a9f0:	0c 9c       	mov	r12,r6
8000a9f2:	cb 7f       	rcall	8000a960 <__sfp>
8000a9f4:	8d 1c       	st.w	r6[0x4],r12
8000a9f6:	0c 9c       	mov	r12,r6
8000a9f8:	cb 4f       	rcall	8000a960 <__sfp>
8000a9fa:	6c 09       	ld.w	r9,r6[0x0]
8000a9fc:	30 48       	mov	r8,4
8000a9fe:	93 07       	st.w	r9[0x0],r7
8000aa00:	b2 68       	st.h	r9[0xc],r8
8000aa02:	93 17       	st.w	r9[0x4],r7
8000aa04:	93 27       	st.w	r9[0x8],r7
8000aa06:	6c 18       	ld.w	r8,r6[0x4]
8000aa08:	b2 77       	st.h	r9[0xe],r7
8000aa0a:	93 47       	st.w	r9[0x10],r7
8000aa0c:	93 57       	st.w	r9[0x14],r7
8000aa0e:	93 67       	st.w	r9[0x18],r7
8000aa10:	93 89       	st.w	r9[0x20],r9
8000aa12:	91 07       	st.w	r8[0x0],r7
8000aa14:	91 17       	st.w	r8[0x4],r7
8000aa16:	91 27       	st.w	r8[0x8],r7
8000aa18:	fe ce f3 24 	sub	lr,pc,-3292
8000aa1c:	fe cb f3 54 	sub	r11,pc,-3244
8000aa20:	93 9e       	st.w	r9[0x24],lr
8000aa22:	93 ab       	st.w	r9[0x28],r11
8000aa24:	fe ca f3 7c 	sub	r10,pc,-3204
8000aa28:	fe c4 f3 88 	sub	r4,pc,-3192
8000aa2c:	93 ba       	st.w	r9[0x2c],r10
8000aa2e:	93 c4       	st.w	r9[0x30],r4
8000aa30:	30 99       	mov	r9,9
8000aa32:	b0 69       	st.h	r8[0xc],r9
8000aa34:	b0 75       	st.h	r8[0xe],r5
8000aa36:	91 c4       	st.w	r8[0x30],r4
8000aa38:	91 47       	st.w	r8[0x10],r7
8000aa3a:	91 57       	st.w	r8[0x14],r7
8000aa3c:	91 67       	st.w	r8[0x18],r7
8000aa3e:	91 88       	st.w	r8[0x20],r8
8000aa40:	91 9e       	st.w	r8[0x24],lr
8000aa42:	91 ab       	st.w	r8[0x28],r11
8000aa44:	91 ba       	st.w	r8[0x2c],r10
8000aa46:	8d 2c       	st.w	r6[0x8],r12
8000aa48:	31 28       	mov	r8,18
8000aa4a:	99 07       	st.w	r12[0x0],r7
8000aa4c:	b8 68       	st.h	r12[0xc],r8
8000aa4e:	99 17       	st.w	r12[0x4],r7
8000aa50:	99 27       	st.w	r12[0x8],r7
8000aa52:	30 28       	mov	r8,2
8000aa54:	b8 78       	st.h	r12[0xe],r8
8000aa56:	99 c4       	st.w	r12[0x30],r4
8000aa58:	99 67       	st.w	r12[0x18],r7
8000aa5a:	99 9e       	st.w	r12[0x24],lr
8000aa5c:	99 ab       	st.w	r12[0x28],r11
8000aa5e:	99 ba       	st.w	r12[0x2c],r10
8000aa60:	99 47       	st.w	r12[0x10],r7
8000aa62:	99 57       	st.w	r12[0x14],r7
8000aa64:	99 8c       	st.w	r12[0x20],r12
8000aa66:	d8 22       	popm	r4-r7,pc

8000aa68 <_malloc_trim_r>:
8000aa68:	d4 21       	pushm	r4-r7,lr
8000aa6a:	16 95       	mov	r5,r11
8000aa6c:	18 97       	mov	r7,r12
8000aa6e:	fe b0 d7 db 	rcall	80005a24 <__malloc_lock>
8000aa72:	e0 64 05 38 	mov	r4,1336
8000aa76:	68 28       	ld.w	r8,r4[0x8]
8000aa78:	70 16       	ld.w	r6,r8[0x4]
8000aa7a:	e0 16 ff fc 	andl	r6,0xfffc
8000aa7e:	ec c8 ff 91 	sub	r8,r6,-111
8000aa82:	f0 05 01 05 	sub	r5,r8,r5
8000aa86:	e0 15 ff 80 	andl	r5,0xff80
8000aa8a:	ea c5 00 80 	sub	r5,r5,128
8000aa8e:	e0 45 00 7f 	cp.w	r5,127
8000aa92:	e0 8a 00 25 	brle	8000aadc <_malloc_trim_r+0x74>
8000aa96:	30 0b       	mov	r11,0
8000aa98:	0e 9c       	mov	r12,r7
8000aa9a:	fe b0 e6 05 	rcall	800076a4 <_sbrk_r>
8000aa9e:	68 28       	ld.w	r8,r4[0x8]
8000aaa0:	0c 08       	add	r8,r6
8000aaa2:	10 3c       	cp.w	r12,r8
8000aaa4:	c1 c1       	brne	8000aadc <_malloc_trim_r+0x74>
8000aaa6:	ea 0b 11 00 	rsub	r11,r5,0
8000aaaa:	0e 9c       	mov	r12,r7
8000aaac:	fe b0 e5 fc 	rcall	800076a4 <_sbrk_r>
8000aab0:	5b fc       	cp.w	r12,-1
8000aab2:	c1 91       	brne	8000aae4 <_malloc_trim_r+0x7c>
8000aab4:	30 0b       	mov	r11,0
8000aab6:	0e 9c       	mov	r12,r7
8000aab8:	fe b0 e5 f6 	rcall	800076a4 <_sbrk_r>
8000aabc:	68 28       	ld.w	r8,r4[0x8]
8000aabe:	f8 08 01 09 	sub	r9,r12,r8
8000aac2:	58 f9       	cp.w	r9,15
8000aac4:	e0 8a 00 0c 	brle	8000aadc <_malloc_trim_r+0x74>
8000aac8:	a1 a9       	sbr	r9,0x0
8000aaca:	91 19       	st.w	r8[0x4],r9
8000aacc:	e0 68 09 44 	mov	r8,2372
8000aad0:	70 09       	ld.w	r9,r8[0x0]
8000aad2:	e0 68 0d 50 	mov	r8,3408
8000aad6:	f8 09 01 09 	sub	r9,r12,r9
8000aada:	91 09       	st.w	r8[0x0],r9
8000aadc:	0e 9c       	mov	r12,r7
8000aade:	fe b0 d7 a9 	rcall	80005a30 <__malloc_unlock>
8000aae2:	d8 2a       	popm	r4-r7,pc,r12=0
8000aae4:	68 28       	ld.w	r8,r4[0x8]
8000aae6:	0a 16       	sub	r6,r5
8000aae8:	a1 a6       	sbr	r6,0x0
8000aaea:	91 16       	st.w	r8[0x4],r6
8000aaec:	e0 68 0d 50 	mov	r8,3408
8000aaf0:	70 09       	ld.w	r9,r8[0x0]
8000aaf2:	0a 19       	sub	r9,r5
8000aaf4:	0e 9c       	mov	r12,r7
8000aaf6:	91 09       	st.w	r8[0x0],r9
8000aaf8:	fe b0 d7 9c 	rcall	80005a30 <__malloc_unlock>
8000aafc:	da 2a       	popm	r4-r7,pc,r12=1
8000aafe:	d7 03       	nop

8000ab00 <_free_r>:
8000ab00:	d4 21       	pushm	r4-r7,lr
8000ab02:	16 96       	mov	r6,r11
8000ab04:	18 97       	mov	r7,r12
8000ab06:	58 0b       	cp.w	r11,0
8000ab08:	e0 80 00 c0 	breq	8000ac88 <_free_r+0x188>
8000ab0c:	fe b0 d7 8c 	rcall	80005a24 <__malloc_lock>
8000ab10:	20 86       	sub	r6,8
8000ab12:	e0 6a 05 38 	mov	r10,1336
8000ab16:	6c 18       	ld.w	r8,r6[0x4]
8000ab18:	74 2e       	ld.w	lr,r10[0x8]
8000ab1a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ab1e:	a1 c8       	cbr	r8,0x0
8000ab20:	ec 08 00 09 	add	r9,r6,r8
8000ab24:	72 1b       	ld.w	r11,r9[0x4]
8000ab26:	e0 1b ff fc 	andl	r11,0xfffc
8000ab2a:	1c 39       	cp.w	r9,lr
8000ab2c:	c1 e1       	brne	8000ab68 <_free_r+0x68>
8000ab2e:	f6 08 00 08 	add	r8,r11,r8
8000ab32:	58 0c       	cp.w	r12,0
8000ab34:	c0 81       	brne	8000ab44 <_free_r+0x44>
8000ab36:	6c 09       	ld.w	r9,r6[0x0]
8000ab38:	12 16       	sub	r6,r9
8000ab3a:	12 08       	add	r8,r9
8000ab3c:	6c 3b       	ld.w	r11,r6[0xc]
8000ab3e:	6c 29       	ld.w	r9,r6[0x8]
8000ab40:	97 29       	st.w	r11[0x8],r9
8000ab42:	93 3b       	st.w	r9[0xc],r11
8000ab44:	10 99       	mov	r9,r8
8000ab46:	95 26       	st.w	r10[0x8],r6
8000ab48:	a1 a9       	sbr	r9,0x0
8000ab4a:	8d 19       	st.w	r6[0x4],r9
8000ab4c:	e0 69 09 40 	mov	r9,2368
8000ab50:	72 09       	ld.w	r9,r9[0x0]
8000ab52:	12 38       	cp.w	r8,r9
8000ab54:	c0 63       	brcs	8000ab60 <_free_r+0x60>
8000ab56:	e0 68 0d 4c 	mov	r8,3404
8000ab5a:	0e 9c       	mov	r12,r7
8000ab5c:	70 0b       	ld.w	r11,r8[0x0]
8000ab5e:	c8 5f       	rcall	8000aa68 <_malloc_trim_r>
8000ab60:	0e 9c       	mov	r12,r7
8000ab62:	fe b0 d7 67 	rcall	80005a30 <__malloc_unlock>
8000ab66:	d8 22       	popm	r4-r7,pc
8000ab68:	93 1b       	st.w	r9[0x4],r11
8000ab6a:	58 0c       	cp.w	r12,0
8000ab6c:	c0 30       	breq	8000ab72 <_free_r+0x72>
8000ab6e:	30 0c       	mov	r12,0
8000ab70:	c1 08       	rjmp	8000ab90 <_free_r+0x90>
8000ab72:	6c 0e       	ld.w	lr,r6[0x0]
8000ab74:	f4 c5 ff f8 	sub	r5,r10,-8
8000ab78:	1c 16       	sub	r6,lr
8000ab7a:	1c 08       	add	r8,lr
8000ab7c:	6c 2e       	ld.w	lr,r6[0x8]
8000ab7e:	0a 3e       	cp.w	lr,r5
8000ab80:	f9 bc 00 01 	moveq	r12,1
8000ab84:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ab88:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ab8c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ab90:	f2 0b 00 0e 	add	lr,r9,r11
8000ab94:	7c 1e       	ld.w	lr,lr[0x4]
8000ab96:	ed be 00 00 	bld	lr,0x0
8000ab9a:	c1 40       	breq	8000abc2 <_free_r+0xc2>
8000ab9c:	16 08       	add	r8,r11
8000ab9e:	58 0c       	cp.w	r12,0
8000aba0:	c0 d1       	brne	8000abba <_free_r+0xba>
8000aba2:	e0 6e 05 38 	mov	lr,1336
8000aba6:	72 2b       	ld.w	r11,r9[0x8]
8000aba8:	2f 8e       	sub	lr,-8
8000abaa:	1c 3b       	cp.w	r11,lr
8000abac:	c0 71       	brne	8000abba <_free_r+0xba>
8000abae:	97 36       	st.w	r11[0xc],r6
8000abb0:	97 26       	st.w	r11[0x8],r6
8000abb2:	8d 2b       	st.w	r6[0x8],r11
8000abb4:	8d 3b       	st.w	r6[0xc],r11
8000abb6:	30 1c       	mov	r12,1
8000abb8:	c0 58       	rjmp	8000abc2 <_free_r+0xc2>
8000abba:	72 2b       	ld.w	r11,r9[0x8]
8000abbc:	72 39       	ld.w	r9,r9[0xc]
8000abbe:	93 2b       	st.w	r9[0x8],r11
8000abc0:	97 39       	st.w	r11[0xc],r9
8000abc2:	10 99       	mov	r9,r8
8000abc4:	ec 08 09 08 	st.w	r6[r8],r8
8000abc8:	a1 a9       	sbr	r9,0x0
8000abca:	8d 19       	st.w	r6[0x4],r9
8000abcc:	58 0c       	cp.w	r12,0
8000abce:	c5 a1       	brne	8000ac82 <_free_r+0x182>
8000abd0:	e0 48 01 ff 	cp.w	r8,511
8000abd4:	e0 8b 00 13 	brhi	8000abfa <_free_r+0xfa>
8000abd8:	a3 98       	lsr	r8,0x3
8000abda:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000abde:	72 2b       	ld.w	r11,r9[0x8]
8000abe0:	8d 39       	st.w	r6[0xc],r9
8000abe2:	8d 2b       	st.w	r6[0x8],r11
8000abe4:	97 36       	st.w	r11[0xc],r6
8000abe6:	93 26       	st.w	r9[0x8],r6
8000abe8:	a3 48       	asr	r8,0x2
8000abea:	74 19       	ld.w	r9,r10[0x4]
8000abec:	30 1b       	mov	r11,1
8000abee:	f6 08 09 48 	lsl	r8,r11,r8
8000abf2:	f3 e8 10 08 	or	r8,r9,r8
8000abf6:	95 18       	st.w	r10[0x4],r8
8000abf8:	c4 58       	rjmp	8000ac82 <_free_r+0x182>
8000abfa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000abfe:	58 4b       	cp.w	r11,4
8000ac00:	e0 8b 00 06 	brhi	8000ac0c <_free_r+0x10c>
8000ac04:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ac08:	2c 8b       	sub	r11,-56
8000ac0a:	c2 08       	rjmp	8000ac4a <_free_r+0x14a>
8000ac0c:	59 4b       	cp.w	r11,20
8000ac0e:	e0 8b 00 04 	brhi	8000ac16 <_free_r+0x116>
8000ac12:	2a 5b       	sub	r11,-91
8000ac14:	c1 b8       	rjmp	8000ac4a <_free_r+0x14a>
8000ac16:	e0 4b 00 54 	cp.w	r11,84
8000ac1a:	e0 8b 00 06 	brhi	8000ac26 <_free_r+0x126>
8000ac1e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ac22:	29 2b       	sub	r11,-110
8000ac24:	c1 38       	rjmp	8000ac4a <_free_r+0x14a>
8000ac26:	e0 4b 01 54 	cp.w	r11,340
8000ac2a:	e0 8b 00 06 	brhi	8000ac36 <_free_r+0x136>
8000ac2e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ac32:	28 9b       	sub	r11,-119
8000ac34:	c0 b8       	rjmp	8000ac4a <_free_r+0x14a>
8000ac36:	e0 4b 05 54 	cp.w	r11,1364
8000ac3a:	e0 88 00 05 	brls	8000ac44 <_free_r+0x144>
8000ac3e:	37 eb       	mov	r11,126
8000ac40:	c0 58       	rjmp	8000ac4a <_free_r+0x14a>
8000ac42:	d7 03       	nop
8000ac44:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ac48:	28 4b       	sub	r11,-124
8000ac4a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ac4e:	78 29       	ld.w	r9,r12[0x8]
8000ac50:	18 39       	cp.w	r9,r12
8000ac52:	c0 e1       	brne	8000ac6e <_free_r+0x16e>
8000ac54:	74 18       	ld.w	r8,r10[0x4]
8000ac56:	a3 4b       	asr	r11,0x2
8000ac58:	30 1c       	mov	r12,1
8000ac5a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ac5e:	f1 eb 10 0b 	or	r11,r8,r11
8000ac62:	12 98       	mov	r8,r9
8000ac64:	95 1b       	st.w	r10[0x4],r11
8000ac66:	c0 a8       	rjmp	8000ac7a <_free_r+0x17a>
8000ac68:	72 29       	ld.w	r9,r9[0x8]
8000ac6a:	18 39       	cp.w	r9,r12
8000ac6c:	c0 60       	breq	8000ac78 <_free_r+0x178>
8000ac6e:	72 1a       	ld.w	r10,r9[0x4]
8000ac70:	e0 1a ff fc 	andl	r10,0xfffc
8000ac74:	14 38       	cp.w	r8,r10
8000ac76:	cf 93       	brcs	8000ac68 <_free_r+0x168>
8000ac78:	72 38       	ld.w	r8,r9[0xc]
8000ac7a:	8d 38       	st.w	r6[0xc],r8
8000ac7c:	8d 29       	st.w	r6[0x8],r9
8000ac7e:	93 36       	st.w	r9[0xc],r6
8000ac80:	91 26       	st.w	r8[0x8],r6
8000ac82:	0e 9c       	mov	r12,r7
8000ac84:	fe b0 d6 d6 	rcall	80005a30 <__malloc_unlock>
8000ac88:	d8 22       	popm	r4-r7,pc
8000ac8a:	d7 03       	nop

8000ac8c <__sfvwrite_r>:
8000ac8c:	d4 31       	pushm	r0-r7,lr
8000ac8e:	20 3d       	sub	sp,12
8000ac90:	14 94       	mov	r4,r10
8000ac92:	18 95       	mov	r5,r12
8000ac94:	16 97       	mov	r7,r11
8000ac96:	74 28       	ld.w	r8,r10[0x8]
8000ac98:	58 08       	cp.w	r8,0
8000ac9a:	e0 80 01 40 	breq	8000af1a <__sfvwrite_r+0x28e>
8000ac9e:	96 68       	ld.sh	r8,r11[0xc]
8000aca0:	ed b8 00 03 	bld	r8,0x3
8000aca4:	c0 41       	brne	8000acac <__sfvwrite_r+0x20>
8000aca6:	76 48       	ld.w	r8,r11[0x10]
8000aca8:	58 08       	cp.w	r8,0
8000acaa:	c0 c1       	brne	8000acc2 <__sfvwrite_r+0x36>
8000acac:	0e 9b       	mov	r11,r7
8000acae:	0a 9c       	mov	r12,r5
8000acb0:	fe b0 f6 c4 	rcall	80009a38 <__swsetup_r>
8000acb4:	c0 70       	breq	8000acc2 <__sfvwrite_r+0x36>
8000acb6:	8e 68       	ld.sh	r8,r7[0xc]
8000acb8:	a7 a8       	sbr	r8,0x6
8000acba:	ae 68       	st.h	r7[0xc],r8
8000acbc:	30 98       	mov	r8,9
8000acbe:	8b 38       	st.w	r5[0xc],r8
8000acc0:	c2 b9       	rjmp	8000af16 <__sfvwrite_r+0x28a>
8000acc2:	8e 63       	ld.sh	r3,r7[0xc]
8000acc4:	68 00       	ld.w	r0,r4[0x0]
8000acc6:	06 96       	mov	r6,r3
8000acc8:	e2 16 00 02 	andl	r6,0x2,COH
8000accc:	c2 10       	breq	8000ad0e <__sfvwrite_r+0x82>
8000acce:	30 03       	mov	r3,0
8000acd0:	e0 62 04 00 	mov	r2,1024
8000acd4:	06 96       	mov	r6,r3
8000acd6:	c0 48       	rjmp	8000acde <__sfvwrite_r+0x52>
8000acd8:	60 03       	ld.w	r3,r0[0x0]
8000acda:	60 16       	ld.w	r6,r0[0x4]
8000acdc:	2f 80       	sub	r0,-8
8000acde:	58 06       	cp.w	r6,0
8000ace0:	cf c0       	breq	8000acd8 <__sfvwrite_r+0x4c>
8000ace2:	e0 46 04 00 	cp.w	r6,1024
8000ace6:	ec 09 17 80 	movls	r9,r6
8000acea:	e4 09 17 b0 	movhi	r9,r2
8000acee:	06 9a       	mov	r10,r3
8000acf0:	6e a8       	ld.w	r8,r7[0x28]
8000acf2:	6e 8b       	ld.w	r11,r7[0x20]
8000acf4:	0a 9c       	mov	r12,r5
8000acf6:	5d 18       	icall	r8
8000acf8:	18 16       	sub	r6,r12
8000acfa:	58 0c       	cp.w	r12,0
8000acfc:	e0 8a 01 0a 	brle	8000af10 <__sfvwrite_r+0x284>
8000ad00:	68 28       	ld.w	r8,r4[0x8]
8000ad02:	18 18       	sub	r8,r12
8000ad04:	89 28       	st.w	r4[0x8],r8
8000ad06:	e0 80 01 0a 	breq	8000af1a <__sfvwrite_r+0x28e>
8000ad0a:	18 03       	add	r3,r12
8000ad0c:	ce 9b       	rjmp	8000acde <__sfvwrite_r+0x52>
8000ad0e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ad12:	c0 70       	breq	8000ad20 <__sfvwrite_r+0x94>
8000ad14:	50 06       	stdsp	sp[0x0],r6
8000ad16:	0c 93       	mov	r3,r6
8000ad18:	0c 91       	mov	r1,r6
8000ad1a:	50 15       	stdsp	sp[0x4],r5
8000ad1c:	08 92       	mov	r2,r4
8000ad1e:	c9 c8       	rjmp	8000ae56 <__sfvwrite_r+0x1ca>
8000ad20:	06 96       	mov	r6,r3
8000ad22:	08 91       	mov	r1,r4
8000ad24:	c0 48       	rjmp	8000ad2c <__sfvwrite_r+0xa0>
8000ad26:	60 03       	ld.w	r3,r0[0x0]
8000ad28:	60 16       	ld.w	r6,r0[0x4]
8000ad2a:	2f 80       	sub	r0,-8
8000ad2c:	58 06       	cp.w	r6,0
8000ad2e:	cf c0       	breq	8000ad26 <__sfvwrite_r+0x9a>
8000ad30:	8e 68       	ld.sh	r8,r7[0xc]
8000ad32:	6e 24       	ld.w	r4,r7[0x8]
8000ad34:	10 99       	mov	r9,r8
8000ad36:	e2 19 02 00 	andl	r9,0x200,COH
8000ad3a:	c5 50       	breq	8000ade4 <__sfvwrite_r+0x158>
8000ad3c:	08 36       	cp.w	r6,r4
8000ad3e:	c4 43       	brcs	8000adc6 <__sfvwrite_r+0x13a>
8000ad40:	10 99       	mov	r9,r8
8000ad42:	e2 19 04 80 	andl	r9,0x480,COH
8000ad46:	c4 00       	breq	8000adc6 <__sfvwrite_r+0x13a>
8000ad48:	6e 4b       	ld.w	r11,r7[0x10]
8000ad4a:	6e 09       	ld.w	r9,r7[0x0]
8000ad4c:	16 19       	sub	r9,r11
8000ad4e:	50 09       	stdsp	sp[0x0],r9
8000ad50:	6e 59       	ld.w	r9,r7[0x14]
8000ad52:	10 9c       	mov	r12,r8
8000ad54:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ad58:	30 28       	mov	r8,2
8000ad5a:	f4 08 0c 08 	divs	r8,r10,r8
8000ad5e:	fa e9 00 04 	st.d	sp[4],r8
8000ad62:	10 94       	mov	r4,r8
8000ad64:	40 09       	lddsp	r9,sp[0x0]
8000ad66:	e2 1c 04 00 	andl	r12,0x400,COH
8000ad6a:	2f f9       	sub	r9,-1
8000ad6c:	0c 09       	add	r9,r6
8000ad6e:	12 38       	cp.w	r8,r9
8000ad70:	f2 04 17 30 	movlo	r4,r9
8000ad74:	58 0c       	cp.w	r12,0
8000ad76:	c1 10       	breq	8000ad98 <__sfvwrite_r+0x10c>
8000ad78:	08 9b       	mov	r11,r4
8000ad7a:	0a 9c       	mov	r12,r5
8000ad7c:	fe b0 e0 6c 	rcall	80006e54 <_malloc_r>
8000ad80:	18 92       	mov	r2,r12
8000ad82:	c1 40       	breq	8000adaa <__sfvwrite_r+0x11e>
8000ad84:	40 0a       	lddsp	r10,sp[0x0]
8000ad86:	6e 4b       	ld.w	r11,r7[0x10]
8000ad88:	fe b0 e2 82 	rcall	8000728c <memcpy>
8000ad8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad8e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ad92:	a7 b8       	sbr	r8,0x7
8000ad94:	ae 68       	st.h	r7[0xc],r8
8000ad96:	c0 d8       	rjmp	8000adb0 <__sfvwrite_r+0x124>
8000ad98:	08 9a       	mov	r10,r4
8000ad9a:	0a 9c       	mov	r12,r5
8000ad9c:	fe b0 e3 24 	rcall	800073e4 <_realloc_r>
8000ada0:	18 92       	mov	r2,r12
8000ada2:	c0 71       	brne	8000adb0 <__sfvwrite_r+0x124>
8000ada4:	6e 4b       	ld.w	r11,r7[0x10]
8000ada6:	0a 9c       	mov	r12,r5
8000ada8:	ca ce       	rcall	8000ab00 <_free_r>
8000adaa:	30 c8       	mov	r8,12
8000adac:	8b 38       	st.w	r5[0xc],r8
8000adae:	cb 18       	rjmp	8000af10 <__sfvwrite_r+0x284>
8000adb0:	40 0a       	lddsp	r10,sp[0x0]
8000adb2:	40 09       	lddsp	r9,sp[0x0]
8000adb4:	e8 0a 01 0a 	sub	r10,r4,r10
8000adb8:	e4 09 00 08 	add	r8,r2,r9
8000adbc:	8f 54       	st.w	r7[0x14],r4
8000adbe:	8f 2a       	st.w	r7[0x8],r10
8000adc0:	8f 08       	st.w	r7[0x0],r8
8000adc2:	8f 42       	st.w	r7[0x10],r2
8000adc4:	0c 94       	mov	r4,r6
8000adc6:	08 36       	cp.w	r6,r4
8000adc8:	ec 04 17 30 	movlo	r4,r6
8000adcc:	06 9b       	mov	r11,r3
8000adce:	08 9a       	mov	r10,r4
8000add0:	6e 0c       	ld.w	r12,r7[0x0]
8000add2:	c3 ad       	rcall	8000b046 <memmove>
8000add4:	6e 08       	ld.w	r8,r7[0x0]
8000add6:	08 08       	add	r8,r4
8000add8:	8f 08       	st.w	r7[0x0],r8
8000adda:	6e 28       	ld.w	r8,r7[0x8]
8000addc:	08 18       	sub	r8,r4
8000adde:	0c 94       	mov	r4,r6
8000ade0:	8f 28       	st.w	r7[0x8],r8
8000ade2:	c2 e8       	rjmp	8000ae3e <__sfvwrite_r+0x1b2>
8000ade4:	08 36       	cp.w	r6,r4
8000ade6:	5f ba       	srhi	r10
8000ade8:	6e 0c       	ld.w	r12,r7[0x0]
8000adea:	6e 48       	ld.w	r8,r7[0x10]
8000adec:	10 3c       	cp.w	r12,r8
8000adee:	5f b8       	srhi	r8
8000adf0:	f5 e8 00 08 	and	r8,r10,r8
8000adf4:	f2 08 18 00 	cp.b	r8,r9
8000adf8:	c0 d0       	breq	8000ae12 <__sfvwrite_r+0x186>
8000adfa:	06 9b       	mov	r11,r3
8000adfc:	08 9a       	mov	r10,r4
8000adfe:	c2 4d       	rcall	8000b046 <memmove>
8000ae00:	6e 08       	ld.w	r8,r7[0x0]
8000ae02:	08 08       	add	r8,r4
8000ae04:	0e 9b       	mov	r11,r7
8000ae06:	8f 08       	st.w	r7[0x0],r8
8000ae08:	0a 9c       	mov	r12,r5
8000ae0a:	fe b0 fd 09 	rcall	8000a81c <_fflush_r>
8000ae0e:	c1 80       	breq	8000ae3e <__sfvwrite_r+0x1b2>
8000ae10:	c8 08       	rjmp	8000af10 <__sfvwrite_r+0x284>
8000ae12:	6e 59       	ld.w	r9,r7[0x14]
8000ae14:	12 36       	cp.w	r6,r9
8000ae16:	c0 a3       	brcs	8000ae2a <__sfvwrite_r+0x19e>
8000ae18:	6e a8       	ld.w	r8,r7[0x28]
8000ae1a:	06 9a       	mov	r10,r3
8000ae1c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae1e:	0a 9c       	mov	r12,r5
8000ae20:	5d 18       	icall	r8
8000ae22:	18 94       	mov	r4,r12
8000ae24:	e0 89 00 0d 	brgt	8000ae3e <__sfvwrite_r+0x1b2>
8000ae28:	c7 48       	rjmp	8000af10 <__sfvwrite_r+0x284>
8000ae2a:	0c 9a       	mov	r10,r6
8000ae2c:	06 9b       	mov	r11,r3
8000ae2e:	c0 cd       	rcall	8000b046 <memmove>
8000ae30:	6e 08       	ld.w	r8,r7[0x0]
8000ae32:	0c 08       	add	r8,r6
8000ae34:	0c 94       	mov	r4,r6
8000ae36:	8f 08       	st.w	r7[0x0],r8
8000ae38:	6e 28       	ld.w	r8,r7[0x8]
8000ae3a:	0c 18       	sub	r8,r6
8000ae3c:	8f 28       	st.w	r7[0x8],r8
8000ae3e:	62 28       	ld.w	r8,r1[0x8]
8000ae40:	08 18       	sub	r8,r4
8000ae42:	83 28       	st.w	r1[0x8],r8
8000ae44:	c6 b0       	breq	8000af1a <__sfvwrite_r+0x28e>
8000ae46:	08 16       	sub	r6,r4
8000ae48:	08 03       	add	r3,r4
8000ae4a:	c7 1b       	rjmp	8000ad2c <__sfvwrite_r+0xa0>
8000ae4c:	60 03       	ld.w	r3,r0[0x0]
8000ae4e:	60 11       	ld.w	r1,r0[0x4]
8000ae50:	30 08       	mov	r8,0
8000ae52:	2f 80       	sub	r0,-8
8000ae54:	50 08       	stdsp	sp[0x0],r8
8000ae56:	58 01       	cp.w	r1,0
8000ae58:	cf a0       	breq	8000ae4c <__sfvwrite_r+0x1c0>
8000ae5a:	40 0a       	lddsp	r10,sp[0x0]
8000ae5c:	58 0a       	cp.w	r10,0
8000ae5e:	c1 41       	brne	8000ae86 <__sfvwrite_r+0x1fa>
8000ae60:	e2 c6 ff ff 	sub	r6,r1,-1
8000ae64:	02 9a       	mov	r10,r1
8000ae66:	30 ab       	mov	r11,10
8000ae68:	06 9c       	mov	r12,r3
8000ae6a:	ce 3c       	rcall	8000b030 <memchr>
8000ae6c:	f8 c8 ff ff 	sub	r8,r12,-1
8000ae70:	58 0c       	cp.w	r12,0
8000ae72:	f1 d3 e1 16 	subne	r6,r8,r3
8000ae76:	f9 b9 01 01 	movne	r9,1
8000ae7a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae7e:	f9 b8 00 01 	moveq	r8,1
8000ae82:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ae86:	02 36       	cp.w	r6,r1
8000ae88:	ec 04 17 80 	movls	r4,r6
8000ae8c:	e2 04 17 b0 	movhi	r4,r1
8000ae90:	6e 59       	ld.w	r9,r7[0x14]
8000ae92:	6e 25       	ld.w	r5,r7[0x8]
8000ae94:	f2 05 00 05 	add	r5,r9,r5
8000ae98:	0a 34       	cp.w	r4,r5
8000ae9a:	5f 9a       	srgt	r10
8000ae9c:	6e 0c       	ld.w	r12,r7[0x0]
8000ae9e:	6e 48       	ld.w	r8,r7[0x10]
8000aea0:	10 3c       	cp.w	r12,r8
8000aea2:	5f b8       	srhi	r8
8000aea4:	f5 e8 00 08 	and	r8,r10,r8
8000aea8:	30 0a       	mov	r10,0
8000aeaa:	f4 08 18 00 	cp.b	r8,r10
8000aeae:	c0 d0       	breq	8000aec8 <__sfvwrite_r+0x23c>
8000aeb0:	06 9b       	mov	r11,r3
8000aeb2:	0a 9a       	mov	r10,r5
8000aeb4:	cc 9c       	rcall	8000b046 <memmove>
8000aeb6:	6e 08       	ld.w	r8,r7[0x0]
8000aeb8:	0a 08       	add	r8,r5
8000aeba:	0e 9b       	mov	r11,r7
8000aebc:	8f 08       	st.w	r7[0x0],r8
8000aebe:	40 1c       	lddsp	r12,sp[0x4]
8000aec0:	fe b0 fc ae 	rcall	8000a81c <_fflush_r>
8000aec4:	c1 70       	breq	8000aef2 <__sfvwrite_r+0x266>
8000aec6:	c2 58       	rjmp	8000af10 <__sfvwrite_r+0x284>
8000aec8:	12 34       	cp.w	r4,r9
8000aeca:	c0 a5       	brlt	8000aede <__sfvwrite_r+0x252>
8000aecc:	6e a8       	ld.w	r8,r7[0x28]
8000aece:	06 9a       	mov	r10,r3
8000aed0:	6e 8b       	ld.w	r11,r7[0x20]
8000aed2:	40 1c       	lddsp	r12,sp[0x4]
8000aed4:	5d 18       	icall	r8
8000aed6:	18 95       	mov	r5,r12
8000aed8:	e0 89 00 0d 	brgt	8000aef2 <__sfvwrite_r+0x266>
8000aedc:	c1 a8       	rjmp	8000af10 <__sfvwrite_r+0x284>
8000aede:	08 9a       	mov	r10,r4
8000aee0:	06 9b       	mov	r11,r3
8000aee2:	cb 2c       	rcall	8000b046 <memmove>
8000aee4:	6e 08       	ld.w	r8,r7[0x0]
8000aee6:	08 08       	add	r8,r4
8000aee8:	08 95       	mov	r5,r4
8000aeea:	8f 08       	st.w	r7[0x0],r8
8000aeec:	6e 28       	ld.w	r8,r7[0x8]
8000aeee:	08 18       	sub	r8,r4
8000aef0:	8f 28       	st.w	r7[0x8],r8
8000aef2:	0a 16       	sub	r6,r5
8000aef4:	c0 71       	brne	8000af02 <__sfvwrite_r+0x276>
8000aef6:	0e 9b       	mov	r11,r7
8000aef8:	40 1c       	lddsp	r12,sp[0x4]
8000aefa:	fe b0 fc 91 	rcall	8000a81c <_fflush_r>
8000aefe:	c0 91       	brne	8000af10 <__sfvwrite_r+0x284>
8000af00:	50 06       	stdsp	sp[0x0],r6
8000af02:	64 28       	ld.w	r8,r2[0x8]
8000af04:	0a 18       	sub	r8,r5
8000af06:	85 28       	st.w	r2[0x8],r8
8000af08:	c0 90       	breq	8000af1a <__sfvwrite_r+0x28e>
8000af0a:	0a 11       	sub	r1,r5
8000af0c:	0a 03       	add	r3,r5
8000af0e:	ca 4b       	rjmp	8000ae56 <__sfvwrite_r+0x1ca>
8000af10:	8e 68       	ld.sh	r8,r7[0xc]
8000af12:	a7 a8       	sbr	r8,0x6
8000af14:	ae 68       	st.h	r7[0xc],r8
8000af16:	3f fc       	mov	r12,-1
8000af18:	c0 28       	rjmp	8000af1c <__sfvwrite_r+0x290>
8000af1a:	30 0c       	mov	r12,0
8000af1c:	2f dd       	sub	sp,-12
8000af1e:	d8 32       	popm	r0-r7,pc

8000af20 <_fwalk>:
8000af20:	d4 31       	pushm	r0-r7,lr
8000af22:	30 05       	mov	r5,0
8000af24:	16 91       	mov	r1,r11
8000af26:	f8 c7 ff 28 	sub	r7,r12,-216
8000af2a:	0a 92       	mov	r2,r5
8000af2c:	fe b0 fc fe 	rcall	8000a928 <__sfp_lock_acquire>
8000af30:	3f f3       	mov	r3,-1
8000af32:	c1 68       	rjmp	8000af5e <_fwalk+0x3e>
8000af34:	6e 26       	ld.w	r6,r7[0x8]
8000af36:	6e 14       	ld.w	r4,r7[0x4]
8000af38:	2f 46       	sub	r6,-12
8000af3a:	c0 c8       	rjmp	8000af52 <_fwalk+0x32>
8000af3c:	8c 08       	ld.sh	r8,r6[0x0]
8000af3e:	e4 08 19 00 	cp.h	r8,r2
8000af42:	c0 70       	breq	8000af50 <_fwalk+0x30>
8000af44:	8c 18       	ld.sh	r8,r6[0x2]
8000af46:	e6 08 19 00 	cp.h	r8,r3
8000af4a:	c0 30       	breq	8000af50 <_fwalk+0x30>
8000af4c:	5d 11       	icall	r1
8000af4e:	18 45       	or	r5,r12
8000af50:	2a 46       	sub	r6,-92
8000af52:	20 14       	sub	r4,1
8000af54:	ec cc 00 0c 	sub	r12,r6,12
8000af58:	58 04       	cp.w	r4,0
8000af5a:	cf 14       	brge	8000af3c <_fwalk+0x1c>
8000af5c:	6e 07       	ld.w	r7,r7[0x0]
8000af5e:	58 07       	cp.w	r7,0
8000af60:	ce a1       	brne	8000af34 <_fwalk+0x14>
8000af62:	fe b0 fc e4 	rcall	8000a92a <__sfp_lock_release>
8000af66:	0a 9c       	mov	r12,r5
8000af68:	d8 32       	popm	r0-r7,pc
8000af6a:	d7 03       	nop

8000af6c <_localeconv_r>:
8000af6c:	fe cc d5 50 	sub	r12,pc,-10928
8000af70:	5e fc       	retal	r12
8000af72:	d7 03       	nop

8000af74 <__smakebuf_r>:
8000af74:	d4 21       	pushm	r4-r7,lr
8000af76:	20 fd       	sub	sp,60
8000af78:	96 68       	ld.sh	r8,r11[0xc]
8000af7a:	16 97       	mov	r7,r11
8000af7c:	18 96       	mov	r6,r12
8000af7e:	e2 18 00 02 	andl	r8,0x2,COH
8000af82:	c3 d1       	brne	8000affc <__smakebuf_r+0x88>
8000af84:	96 7b       	ld.sh	r11,r11[0xe]
8000af86:	f0 0b 19 00 	cp.h	r11,r8
8000af8a:	c0 55       	brlt	8000af94 <__smakebuf_r+0x20>
8000af8c:	1a 9a       	mov	r10,sp
8000af8e:	e0 a0 04 81 	rcall	8000b890 <_fstat_r>
8000af92:	c0 f4       	brge	8000afb0 <__smakebuf_r+0x3c>
8000af94:	8e 65       	ld.sh	r5,r7[0xc]
8000af96:	0a 98       	mov	r8,r5
8000af98:	ab b8       	sbr	r8,0xb
8000af9a:	e2 15 00 80 	andl	r5,0x80,COH
8000af9e:	ae 68       	st.h	r7[0xc],r8
8000afa0:	30 04       	mov	r4,0
8000afa2:	e0 68 04 00 	mov	r8,1024
8000afa6:	f9 b5 01 40 	movne	r5,64
8000afaa:	f0 05 17 00 	moveq	r5,r8
8000afae:	c1 c8       	rjmp	8000afe6 <__smakebuf_r+0x72>
8000afb0:	40 18       	lddsp	r8,sp[0x4]
8000afb2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000afb6:	e0 48 20 00 	cp.w	r8,8192
8000afba:	5f 04       	sreq	r4
8000afbc:	e0 48 80 00 	cp.w	r8,32768
8000afc0:	c0 e1       	brne	8000afdc <__smakebuf_r+0x68>
8000afc2:	6e b9       	ld.w	r9,r7[0x2c]
8000afc4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000afc8:	10 39       	cp.w	r9,r8
8000afca:	c0 91       	brne	8000afdc <__smakebuf_r+0x68>
8000afcc:	8e 68       	ld.sh	r8,r7[0xc]
8000afce:	e0 65 04 00 	mov	r5,1024
8000afd2:	ab a8       	sbr	r8,0xa
8000afd4:	ef 45 00 50 	st.w	r7[80],r5
8000afd8:	ae 68       	st.h	r7[0xc],r8
8000afda:	c0 68       	rjmp	8000afe6 <__smakebuf_r+0x72>
8000afdc:	8e 68       	ld.sh	r8,r7[0xc]
8000afde:	e0 65 04 00 	mov	r5,1024
8000afe2:	ab b8       	sbr	r8,0xb
8000afe4:	ae 68       	st.h	r7[0xc],r8
8000afe6:	0a 9b       	mov	r11,r5
8000afe8:	0c 9c       	mov	r12,r6
8000afea:	fe b0 df 35 	rcall	80006e54 <_malloc_r>
8000afee:	8e 68       	ld.sh	r8,r7[0xc]
8000aff0:	c0 d1       	brne	8000b00a <__smakebuf_r+0x96>
8000aff2:	ed b8 00 09 	bld	r8,0x9
8000aff6:	c1 b0       	breq	8000b02c <__smakebuf_r+0xb8>
8000aff8:	a1 b8       	sbr	r8,0x1
8000affa:	ae 68       	st.h	r7[0xc],r8
8000affc:	ee c8 ff b9 	sub	r8,r7,-71
8000b000:	8f 48       	st.w	r7[0x10],r8
8000b002:	8f 08       	st.w	r7[0x0],r8
8000b004:	30 18       	mov	r8,1
8000b006:	8f 58       	st.w	r7[0x14],r8
8000b008:	c1 28       	rjmp	8000b02c <__smakebuf_r+0xb8>
8000b00a:	a7 b8       	sbr	r8,0x7
8000b00c:	8f 4c       	st.w	r7[0x10],r12
8000b00e:	ae 68       	st.h	r7[0xc],r8
8000b010:	8f 55       	st.w	r7[0x14],r5
8000b012:	fe c8 06 e6 	sub	r8,pc,1766
8000b016:	8f 0c       	st.w	r7[0x0],r12
8000b018:	8d a8       	st.w	r6[0x28],r8
8000b01a:	58 04       	cp.w	r4,0
8000b01c:	c0 80       	breq	8000b02c <__smakebuf_r+0xb8>
8000b01e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b020:	fe b0 e3 94 	rcall	80007748 <isatty>
8000b024:	c0 40       	breq	8000b02c <__smakebuf_r+0xb8>
8000b026:	8e 68       	ld.sh	r8,r7[0xc]
8000b028:	a1 a8       	sbr	r8,0x0
8000b02a:	ae 68       	st.h	r7[0xc],r8
8000b02c:	2f 1d       	sub	sp,-60
8000b02e:	d8 22       	popm	r4-r7,pc

8000b030 <memchr>:
8000b030:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b034:	c0 68       	rjmp	8000b040 <memchr+0x10>
8000b036:	20 1a       	sub	r10,1
8000b038:	19 88       	ld.ub	r8,r12[0x0]
8000b03a:	16 38       	cp.w	r8,r11
8000b03c:	5e 0c       	reteq	r12
8000b03e:	2f fc       	sub	r12,-1
8000b040:	58 0a       	cp.w	r10,0
8000b042:	cf a1       	brne	8000b036 <memchr+0x6>
8000b044:	5e fa       	retal	r10

8000b046 <memmove>:
8000b046:	d4 01       	pushm	lr
8000b048:	18 3b       	cp.w	r11,r12
8000b04a:	c1 92       	brcc	8000b07c <memmove+0x36>
8000b04c:	f6 0a 00 09 	add	r9,r11,r10
8000b050:	12 3c       	cp.w	r12,r9
8000b052:	c1 52       	brcc	8000b07c <memmove+0x36>
8000b054:	f8 0a 00 0b 	add	r11,r12,r10
8000b058:	30 08       	mov	r8,0
8000b05a:	c0 68       	rjmp	8000b066 <memmove+0x20>
8000b05c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b060:	20 1a       	sub	r10,1
8000b062:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b066:	20 18       	sub	r8,1
8000b068:	58 0a       	cp.w	r10,0
8000b06a:	cf 91       	brne	8000b05c <memmove+0x16>
8000b06c:	d8 02       	popm	pc
8000b06e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b072:	20 1a       	sub	r10,1
8000b074:	f8 08 0b 09 	st.b	r12[r8],r9
8000b078:	2f f8       	sub	r8,-1
8000b07a:	c0 28       	rjmp	8000b07e <memmove+0x38>
8000b07c:	30 08       	mov	r8,0
8000b07e:	58 0a       	cp.w	r10,0
8000b080:	cf 71       	brne	8000b06e <memmove+0x28>
8000b082:	d8 02       	popm	pc

8000b084 <__hi0bits>:
8000b084:	18 98       	mov	r8,r12
8000b086:	e0 1c 00 00 	andl	r12,0x0
8000b08a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b08e:	58 0c       	cp.w	r12,0
8000b090:	f2 08 17 00 	moveq	r8,r9
8000b094:	f9 bc 00 10 	moveq	r12,16
8000b098:	f9 bc 01 00 	movne	r12,0
8000b09c:	10 9a       	mov	r10,r8
8000b09e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b0a2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b0a6:	f7 bc 00 f8 	subeq	r12,-8
8000b0aa:	f2 08 17 00 	moveq	r8,r9
8000b0ae:	10 9a       	mov	r10,r8
8000b0b0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b0b4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b0b8:	f7 bc 00 fc 	subeq	r12,-4
8000b0bc:	f2 08 17 00 	moveq	r8,r9
8000b0c0:	10 9a       	mov	r10,r8
8000b0c2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b0c6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b0ca:	f7 bc 00 fe 	subeq	r12,-2
8000b0ce:	f2 08 17 00 	moveq	r8,r9
8000b0d2:	58 08       	cp.w	r8,0
8000b0d4:	5e 5c       	retlt	r12
8000b0d6:	ed b8 00 1e 	bld	r8,0x1e
8000b0da:	f9 bc 01 20 	movne	r12,32
8000b0de:	f7 bc 00 ff 	subeq	r12,-1
8000b0e2:	5e fc       	retal	r12

8000b0e4 <__lo0bits>:
8000b0e4:	18 99       	mov	r9,r12
8000b0e6:	78 08       	ld.w	r8,r12[0x0]
8000b0e8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b0ec:	c1 50       	breq	8000b116 <__lo0bits+0x32>
8000b0ee:	ed b8 00 00 	bld	r8,0x0
8000b0f2:	c0 21       	brne	8000b0f6 <__lo0bits+0x12>
8000b0f4:	5e fd       	retal	0
8000b0f6:	10 9b       	mov	r11,r8
8000b0f8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b0fc:	e2 1b 00 02 	andl	r11,0x2,COH
8000b100:	a3 88       	lsr	r8,0x2
8000b102:	58 0b       	cp.w	r11,0
8000b104:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b108:	f9 bc 01 01 	movne	r12,1
8000b10c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b110:	f9 bc 00 02 	moveq	r12,2
8000b114:	5e fc       	retal	r12
8000b116:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b11a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b11e:	58 0a       	cp.w	r10,0
8000b120:	f6 08 17 00 	moveq	r8,r11
8000b124:	f9 bc 00 10 	moveq	r12,16
8000b128:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b12c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b130:	58 0b       	cp.w	r11,0
8000b132:	f7 bc 00 f8 	subeq	r12,-8
8000b136:	f4 08 17 00 	moveq	r8,r10
8000b13a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b13e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b142:	58 0b       	cp.w	r11,0
8000b144:	f7 bc 00 fc 	subeq	r12,-4
8000b148:	f4 08 17 00 	moveq	r8,r10
8000b14c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b150:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b154:	58 0b       	cp.w	r11,0
8000b156:	f7 bc 00 fe 	subeq	r12,-2
8000b15a:	f4 08 17 00 	moveq	r8,r10
8000b15e:	ed b8 00 00 	bld	r8,0x0
8000b162:	c0 60       	breq	8000b16e <__lo0bits+0x8a>
8000b164:	a1 98       	lsr	r8,0x1
8000b166:	c0 31       	brne	8000b16c <__lo0bits+0x88>
8000b168:	32 0c       	mov	r12,32
8000b16a:	5e fc       	retal	r12
8000b16c:	2f fc       	sub	r12,-1
8000b16e:	93 08       	st.w	r9[0x0],r8
8000b170:	5e fc       	retal	r12

8000b172 <__mcmp>:
8000b172:	d4 01       	pushm	lr
8000b174:	18 98       	mov	r8,r12
8000b176:	76 49       	ld.w	r9,r11[0x10]
8000b178:	78 4c       	ld.w	r12,r12[0x10]
8000b17a:	12 1c       	sub	r12,r9
8000b17c:	c1 31       	brne	8000b1a2 <__mcmp+0x30>
8000b17e:	2f b9       	sub	r9,-5
8000b180:	a3 69       	lsl	r9,0x2
8000b182:	12 0b       	add	r11,r9
8000b184:	f0 09 00 09 	add	r9,r8,r9
8000b188:	2e c8       	sub	r8,-20
8000b18a:	13 4e       	ld.w	lr,--r9
8000b18c:	17 4a       	ld.w	r10,--r11
8000b18e:	14 3e       	cp.w	lr,r10
8000b190:	c0 60       	breq	8000b19c <__mcmp+0x2a>
8000b192:	f9 bc 03 ff 	movlo	r12,-1
8000b196:	f9 bc 02 01 	movhs	r12,1
8000b19a:	d8 02       	popm	pc
8000b19c:	10 39       	cp.w	r9,r8
8000b19e:	fe 9b ff f6 	brhi	8000b18a <__mcmp+0x18>
8000b1a2:	d8 02       	popm	pc

8000b1a4 <_Bfree>:
8000b1a4:	d4 21       	pushm	r4-r7,lr
8000b1a6:	18 97       	mov	r7,r12
8000b1a8:	16 95       	mov	r5,r11
8000b1aa:	78 96       	ld.w	r6,r12[0x24]
8000b1ac:	58 06       	cp.w	r6,0
8000b1ae:	c0 91       	brne	8000b1c0 <_Bfree+0x1c>
8000b1b0:	31 0c       	mov	r12,16
8000b1b2:	fe b0 de 49 	rcall	80006e44 <malloc>
8000b1b6:	99 36       	st.w	r12[0xc],r6
8000b1b8:	8f 9c       	st.w	r7[0x24],r12
8000b1ba:	99 16       	st.w	r12[0x4],r6
8000b1bc:	99 26       	st.w	r12[0x8],r6
8000b1be:	99 06       	st.w	r12[0x0],r6
8000b1c0:	58 05       	cp.w	r5,0
8000b1c2:	c0 90       	breq	8000b1d4 <_Bfree+0x30>
8000b1c4:	6a 19       	ld.w	r9,r5[0x4]
8000b1c6:	6e 98       	ld.w	r8,r7[0x24]
8000b1c8:	70 38       	ld.w	r8,r8[0xc]
8000b1ca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b1ce:	8b 0a       	st.w	r5[0x0],r10
8000b1d0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b1d4:	d8 22       	popm	r4-r7,pc
8000b1d6:	d7 03       	nop

8000b1d8 <_Balloc>:
8000b1d8:	d4 21       	pushm	r4-r7,lr
8000b1da:	18 97       	mov	r7,r12
8000b1dc:	16 96       	mov	r6,r11
8000b1de:	78 95       	ld.w	r5,r12[0x24]
8000b1e0:	58 05       	cp.w	r5,0
8000b1e2:	c0 91       	brne	8000b1f4 <_Balloc+0x1c>
8000b1e4:	31 0c       	mov	r12,16
8000b1e6:	fe b0 de 2f 	rcall	80006e44 <malloc>
8000b1ea:	99 35       	st.w	r12[0xc],r5
8000b1ec:	8f 9c       	st.w	r7[0x24],r12
8000b1ee:	99 15       	st.w	r12[0x4],r5
8000b1f0:	99 25       	st.w	r12[0x8],r5
8000b1f2:	99 05       	st.w	r12[0x0],r5
8000b1f4:	6e 95       	ld.w	r5,r7[0x24]
8000b1f6:	6a 38       	ld.w	r8,r5[0xc]
8000b1f8:	58 08       	cp.w	r8,0
8000b1fa:	c0 b1       	brne	8000b210 <_Balloc+0x38>
8000b1fc:	31 0a       	mov	r10,16
8000b1fe:	30 4b       	mov	r11,4
8000b200:	0e 9c       	mov	r12,r7
8000b202:	e0 a0 02 a7 	rcall	8000b750 <_calloc_r>
8000b206:	8b 3c       	st.w	r5[0xc],r12
8000b208:	6e 98       	ld.w	r8,r7[0x24]
8000b20a:	70 3c       	ld.w	r12,r8[0xc]
8000b20c:	58 0c       	cp.w	r12,0
8000b20e:	c1 b0       	breq	8000b244 <_Balloc+0x6c>
8000b210:	6e 98       	ld.w	r8,r7[0x24]
8000b212:	70 38       	ld.w	r8,r8[0xc]
8000b214:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b218:	70 0c       	ld.w	r12,r8[0x0]
8000b21a:	58 0c       	cp.w	r12,0
8000b21c:	c0 40       	breq	8000b224 <_Balloc+0x4c>
8000b21e:	78 09       	ld.w	r9,r12[0x0]
8000b220:	91 09       	st.w	r8[0x0],r9
8000b222:	c0 e8       	rjmp	8000b23e <_Balloc+0x66>
8000b224:	0e 9c       	mov	r12,r7
8000b226:	30 17       	mov	r7,1
8000b228:	0e 9b       	mov	r11,r7
8000b22a:	ee 06 09 47 	lsl	r7,r7,r6
8000b22e:	ee ca ff fb 	sub	r10,r7,-5
8000b232:	a3 6a       	lsl	r10,0x2
8000b234:	e0 a0 02 8e 	rcall	8000b750 <_calloc_r>
8000b238:	c0 60       	breq	8000b244 <_Balloc+0x6c>
8000b23a:	99 16       	st.w	r12[0x4],r6
8000b23c:	99 27       	st.w	r12[0x8],r7
8000b23e:	30 08       	mov	r8,0
8000b240:	99 38       	st.w	r12[0xc],r8
8000b242:	99 48       	st.w	r12[0x10],r8
8000b244:	d8 22       	popm	r4-r7,pc
8000b246:	d7 03       	nop

8000b248 <__d2b>:
8000b248:	d4 31       	pushm	r0-r7,lr
8000b24a:	20 2d       	sub	sp,8
8000b24c:	16 93       	mov	r3,r11
8000b24e:	12 96       	mov	r6,r9
8000b250:	10 95       	mov	r5,r8
8000b252:	14 92       	mov	r2,r10
8000b254:	30 1b       	mov	r11,1
8000b256:	cc 1f       	rcall	8000b1d8 <_Balloc>
8000b258:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b25c:	50 09       	stdsp	sp[0x0],r9
8000b25e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b262:	b5 a9       	sbr	r9,0x14
8000b264:	f0 01 16 14 	lsr	r1,r8,0x14
8000b268:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b26c:	18 94       	mov	r4,r12
8000b26e:	58 02       	cp.w	r2,0
8000b270:	c1 d0       	breq	8000b2aa <__d2b+0x62>
8000b272:	fa cc ff f8 	sub	r12,sp,-8
8000b276:	18 d2       	st.w	--r12,r2
8000b278:	c3 6f       	rcall	8000b0e4 <__lo0bits>
8000b27a:	40 18       	lddsp	r8,sp[0x4]
8000b27c:	c0 d0       	breq	8000b296 <__d2b+0x4e>
8000b27e:	40 09       	lddsp	r9,sp[0x0]
8000b280:	f8 0a 11 20 	rsub	r10,r12,32
8000b284:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b288:	f5 e8 10 08 	or	r8,r10,r8
8000b28c:	89 58       	st.w	r4[0x14],r8
8000b28e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b292:	50 09       	stdsp	sp[0x0],r9
8000b294:	c0 28       	rjmp	8000b298 <__d2b+0x50>
8000b296:	89 58       	st.w	r4[0x14],r8
8000b298:	40 08       	lddsp	r8,sp[0x0]
8000b29a:	58 08       	cp.w	r8,0
8000b29c:	f9 b3 01 02 	movne	r3,2
8000b2a0:	f9 b3 00 01 	moveq	r3,1
8000b2a4:	89 68       	st.w	r4[0x18],r8
8000b2a6:	89 43       	st.w	r4[0x10],r3
8000b2a8:	c0 88       	rjmp	8000b2b8 <__d2b+0x70>
8000b2aa:	1a 9c       	mov	r12,sp
8000b2ac:	c1 cf       	rcall	8000b0e4 <__lo0bits>
8000b2ae:	30 13       	mov	r3,1
8000b2b0:	40 08       	lddsp	r8,sp[0x0]
8000b2b2:	2e 0c       	sub	r12,-32
8000b2b4:	89 43       	st.w	r4[0x10],r3
8000b2b6:	89 58       	st.w	r4[0x14],r8
8000b2b8:	58 01       	cp.w	r1,0
8000b2ba:	c0 90       	breq	8000b2cc <__d2b+0x84>
8000b2bc:	e2 c1 04 33 	sub	r1,r1,1075
8000b2c0:	18 01       	add	r1,r12
8000b2c2:	8d 01       	st.w	r6[0x0],r1
8000b2c4:	f8 0c 11 35 	rsub	r12,r12,53
8000b2c8:	8b 0c       	st.w	r5[0x0],r12
8000b2ca:	c0 c8       	rjmp	8000b2e2 <__d2b+0x9a>
8000b2cc:	e6 c8 ff fc 	sub	r8,r3,-4
8000b2d0:	f8 cc 04 32 	sub	r12,r12,1074
8000b2d4:	a5 73       	lsl	r3,0x5
8000b2d6:	8d 0c       	st.w	r6[0x0],r12
8000b2d8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b2dc:	cd 4e       	rcall	8000b084 <__hi0bits>
8000b2de:	18 13       	sub	r3,r12
8000b2e0:	8b 03       	st.w	r5[0x0],r3
8000b2e2:	08 9c       	mov	r12,r4
8000b2e4:	2f ed       	sub	sp,-8
8000b2e6:	d8 32       	popm	r0-r7,pc

8000b2e8 <__mdiff>:
8000b2e8:	d4 31       	pushm	r0-r7,lr
8000b2ea:	74 48       	ld.w	r8,r10[0x10]
8000b2ec:	76 45       	ld.w	r5,r11[0x10]
8000b2ee:	16 97       	mov	r7,r11
8000b2f0:	14 96       	mov	r6,r10
8000b2f2:	10 15       	sub	r5,r8
8000b2f4:	c1 31       	brne	8000b31a <__mdiff+0x32>
8000b2f6:	2f b8       	sub	r8,-5
8000b2f8:	ee ce ff ec 	sub	lr,r7,-20
8000b2fc:	a3 68       	lsl	r8,0x2
8000b2fe:	f4 08 00 0b 	add	r11,r10,r8
8000b302:	ee 08 00 08 	add	r8,r7,r8
8000b306:	11 4a       	ld.w	r10,--r8
8000b308:	17 49       	ld.w	r9,--r11
8000b30a:	12 3a       	cp.w	r10,r9
8000b30c:	c0 30       	breq	8000b312 <__mdiff+0x2a>
8000b30e:	c0 e2       	brcc	8000b32a <__mdiff+0x42>
8000b310:	c0 78       	rjmp	8000b31e <__mdiff+0x36>
8000b312:	1c 38       	cp.w	r8,lr
8000b314:	fe 9b ff f9 	brhi	8000b306 <__mdiff+0x1e>
8000b318:	c4 98       	rjmp	8000b3aa <__mdiff+0xc2>
8000b31a:	58 05       	cp.w	r5,0
8000b31c:	c0 64       	brge	8000b328 <__mdiff+0x40>
8000b31e:	0e 98       	mov	r8,r7
8000b320:	30 15       	mov	r5,1
8000b322:	0c 97       	mov	r7,r6
8000b324:	10 96       	mov	r6,r8
8000b326:	c0 28       	rjmp	8000b32a <__mdiff+0x42>
8000b328:	30 05       	mov	r5,0
8000b32a:	6e 1b       	ld.w	r11,r7[0x4]
8000b32c:	c5 6f       	rcall	8000b1d8 <_Balloc>
8000b32e:	6e 49       	ld.w	r9,r7[0x10]
8000b330:	6c 44       	ld.w	r4,r6[0x10]
8000b332:	99 35       	st.w	r12[0xc],r5
8000b334:	2f b4       	sub	r4,-5
8000b336:	f2 c5 ff fb 	sub	r5,r9,-5
8000b33a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b33e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b342:	2e c6       	sub	r6,-20
8000b344:	2e c7       	sub	r7,-20
8000b346:	f8 c8 ff ec 	sub	r8,r12,-20
8000b34a:	30 0a       	mov	r10,0
8000b34c:	0f 0e       	ld.w	lr,r7++
8000b34e:	0d 0b       	ld.w	r11,r6++
8000b350:	fc 02 16 10 	lsr	r2,lr,0x10
8000b354:	f6 03 16 10 	lsr	r3,r11,0x10
8000b358:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b35c:	e4 03 01 03 	sub	r3,r2,r3
8000b360:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b364:	fc 0b 01 0b 	sub	r11,lr,r11
8000b368:	f6 0a 00 0a 	add	r10,r11,r10
8000b36c:	b0 1a       	st.h	r8[0x2],r10
8000b36e:	b1 4a       	asr	r10,0x10
8000b370:	e6 0a 00 0a 	add	r10,r3,r10
8000b374:	b0 0a       	st.h	r8[0x0],r10
8000b376:	2f c8       	sub	r8,-4
8000b378:	b1 4a       	asr	r10,0x10
8000b37a:	08 36       	cp.w	r6,r4
8000b37c:	ce 83       	brcs	8000b34c <__mdiff+0x64>
8000b37e:	c0 d8       	rjmp	8000b398 <__mdiff+0xb0>
8000b380:	0f 0b       	ld.w	r11,r7++
8000b382:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b386:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b38a:	16 0a       	add	r10,r11
8000b38c:	b0 1a       	st.h	r8[0x2],r10
8000b38e:	b1 4a       	asr	r10,0x10
8000b390:	1c 0a       	add	r10,lr
8000b392:	b0 0a       	st.h	r8[0x0],r10
8000b394:	2f c8       	sub	r8,-4
8000b396:	b1 4a       	asr	r10,0x10
8000b398:	0a 37       	cp.w	r7,r5
8000b39a:	cf 33       	brcs	8000b380 <__mdiff+0x98>
8000b39c:	c0 28       	rjmp	8000b3a0 <__mdiff+0xb8>
8000b39e:	20 19       	sub	r9,1
8000b3a0:	11 4a       	ld.w	r10,--r8
8000b3a2:	58 0a       	cp.w	r10,0
8000b3a4:	cf d0       	breq	8000b39e <__mdiff+0xb6>
8000b3a6:	99 49       	st.w	r12[0x10],r9
8000b3a8:	d8 32       	popm	r0-r7,pc
8000b3aa:	30 0b       	mov	r11,0
8000b3ac:	c1 6f       	rcall	8000b1d8 <_Balloc>
8000b3ae:	30 18       	mov	r8,1
8000b3b0:	99 48       	st.w	r12[0x10],r8
8000b3b2:	30 08       	mov	r8,0
8000b3b4:	99 58       	st.w	r12[0x14],r8
8000b3b6:	d8 32       	popm	r0-r7,pc

8000b3b8 <__lshift>:
8000b3b8:	d4 31       	pushm	r0-r7,lr
8000b3ba:	16 97       	mov	r7,r11
8000b3bc:	76 46       	ld.w	r6,r11[0x10]
8000b3be:	f4 02 14 05 	asr	r2,r10,0x5
8000b3c2:	2f f6       	sub	r6,-1
8000b3c4:	14 93       	mov	r3,r10
8000b3c6:	18 94       	mov	r4,r12
8000b3c8:	04 06       	add	r6,r2
8000b3ca:	76 1b       	ld.w	r11,r11[0x4]
8000b3cc:	6e 28       	ld.w	r8,r7[0x8]
8000b3ce:	c0 38       	rjmp	8000b3d4 <__lshift+0x1c>
8000b3d0:	2f fb       	sub	r11,-1
8000b3d2:	a1 78       	lsl	r8,0x1
8000b3d4:	10 36       	cp.w	r6,r8
8000b3d6:	fe 99 ff fd 	brgt	8000b3d0 <__lshift+0x18>
8000b3da:	08 9c       	mov	r12,r4
8000b3dc:	cf ee       	rcall	8000b1d8 <_Balloc>
8000b3de:	30 09       	mov	r9,0
8000b3e0:	18 95       	mov	r5,r12
8000b3e2:	f8 c8 ff ec 	sub	r8,r12,-20
8000b3e6:	12 9a       	mov	r10,r9
8000b3e8:	c0 38       	rjmp	8000b3ee <__lshift+0x36>
8000b3ea:	10 aa       	st.w	r8++,r10
8000b3ec:	2f f9       	sub	r9,-1
8000b3ee:	04 39       	cp.w	r9,r2
8000b3f0:	cf d5       	brlt	8000b3ea <__lshift+0x32>
8000b3f2:	6e 4b       	ld.w	r11,r7[0x10]
8000b3f4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b3f8:	2f bb       	sub	r11,-5
8000b3fa:	ee c9 ff ec 	sub	r9,r7,-20
8000b3fe:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b402:	58 03       	cp.w	r3,0
8000b404:	c1 30       	breq	8000b42a <__lshift+0x72>
8000b406:	e6 0c 11 20 	rsub	r12,r3,32
8000b40a:	30 0a       	mov	r10,0
8000b40c:	72 02       	ld.w	r2,r9[0x0]
8000b40e:	e4 03 09 42 	lsl	r2,r2,r3
8000b412:	04 4a       	or	r10,r2
8000b414:	10 aa       	st.w	r8++,r10
8000b416:	13 0a       	ld.w	r10,r9++
8000b418:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b41c:	16 39       	cp.w	r9,r11
8000b41e:	cf 73       	brcs	8000b40c <__lshift+0x54>
8000b420:	91 0a       	st.w	r8[0x0],r10
8000b422:	58 0a       	cp.w	r10,0
8000b424:	c0 70       	breq	8000b432 <__lshift+0x7a>
8000b426:	2f f6       	sub	r6,-1
8000b428:	c0 58       	rjmp	8000b432 <__lshift+0x7a>
8000b42a:	13 0a       	ld.w	r10,r9++
8000b42c:	10 aa       	st.w	r8++,r10
8000b42e:	16 39       	cp.w	r9,r11
8000b430:	cf d3       	brcs	8000b42a <__lshift+0x72>
8000b432:	08 9c       	mov	r12,r4
8000b434:	20 16       	sub	r6,1
8000b436:	0e 9b       	mov	r11,r7
8000b438:	8b 46       	st.w	r5[0x10],r6
8000b43a:	cb 5e       	rcall	8000b1a4 <_Bfree>
8000b43c:	0a 9c       	mov	r12,r5
8000b43e:	d8 32       	popm	r0-r7,pc

8000b440 <__multiply>:
8000b440:	d4 31       	pushm	r0-r7,lr
8000b442:	20 2d       	sub	sp,8
8000b444:	76 49       	ld.w	r9,r11[0x10]
8000b446:	74 48       	ld.w	r8,r10[0x10]
8000b448:	16 96       	mov	r6,r11
8000b44a:	14 95       	mov	r5,r10
8000b44c:	10 39       	cp.w	r9,r8
8000b44e:	ec 08 17 50 	movlt	r8,r6
8000b452:	ea 06 17 50 	movlt	r6,r5
8000b456:	f0 05 17 50 	movlt	r5,r8
8000b45a:	6c 28       	ld.w	r8,r6[0x8]
8000b45c:	76 43       	ld.w	r3,r11[0x10]
8000b45e:	74 42       	ld.w	r2,r10[0x10]
8000b460:	76 1b       	ld.w	r11,r11[0x4]
8000b462:	e4 03 00 07 	add	r7,r2,r3
8000b466:	10 37       	cp.w	r7,r8
8000b468:	f7 bb 09 ff 	subgt	r11,-1
8000b46c:	cb 6e       	rcall	8000b1d8 <_Balloc>
8000b46e:	ee c4 ff fb 	sub	r4,r7,-5
8000b472:	f8 c9 ff ec 	sub	r9,r12,-20
8000b476:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b47a:	30 0a       	mov	r10,0
8000b47c:	12 98       	mov	r8,r9
8000b47e:	c0 28       	rjmp	8000b482 <__multiply+0x42>
8000b480:	10 aa       	st.w	r8++,r10
8000b482:	08 38       	cp.w	r8,r4
8000b484:	cf e3       	brcs	8000b480 <__multiply+0x40>
8000b486:	2f b3       	sub	r3,-5
8000b488:	2f b2       	sub	r2,-5
8000b48a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b48e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b492:	ec cb ff ec 	sub	r11,r6,-20
8000b496:	50 12       	stdsp	sp[0x4],r2
8000b498:	ea ca ff ec 	sub	r10,r5,-20
8000b49c:	c4 48       	rjmp	8000b524 <__multiply+0xe4>
8000b49e:	94 95       	ld.uh	r5,r10[0x2]
8000b4a0:	58 05       	cp.w	r5,0
8000b4a2:	c2 00       	breq	8000b4e2 <__multiply+0xa2>
8000b4a4:	12 98       	mov	r8,r9
8000b4a6:	16 96       	mov	r6,r11
8000b4a8:	30 0e       	mov	lr,0
8000b4aa:	50 09       	stdsp	sp[0x0],r9
8000b4ac:	0d 02       	ld.w	r2,r6++
8000b4ae:	e4 00 16 10 	lsr	r0,r2,0x10
8000b4b2:	70 01       	ld.w	r1,r8[0x0]
8000b4b4:	70 09       	ld.w	r9,r8[0x0]
8000b4b6:	b1 81       	lsr	r1,0x10
8000b4b8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b4bc:	e0 05 03 41 	mac	r1,r0,r5
8000b4c0:	ab 32       	mul	r2,r5
8000b4c2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b4c6:	00 02       	add	r2,r0
8000b4c8:	e4 0e 00 0e 	add	lr,r2,lr
8000b4cc:	b0 1e       	st.h	r8[0x2],lr
8000b4ce:	b1 8e       	lsr	lr,0x10
8000b4d0:	1c 01       	add	r1,lr
8000b4d2:	b0 01       	st.h	r8[0x0],r1
8000b4d4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b4d8:	2f c8       	sub	r8,-4
8000b4da:	06 36       	cp.w	r6,r3
8000b4dc:	ce 83       	brcs	8000b4ac <__multiply+0x6c>
8000b4de:	40 09       	lddsp	r9,sp[0x0]
8000b4e0:	91 0e       	st.w	r8[0x0],lr
8000b4e2:	94 86       	ld.uh	r6,r10[0x0]
8000b4e4:	58 06       	cp.w	r6,0
8000b4e6:	c1 d0       	breq	8000b520 <__multiply+0xe0>
8000b4e8:	72 02       	ld.w	r2,r9[0x0]
8000b4ea:	12 98       	mov	r8,r9
8000b4ec:	16 9e       	mov	lr,r11
8000b4ee:	30 05       	mov	r5,0
8000b4f0:	b0 12       	st.h	r8[0x2],r2
8000b4f2:	1d 01       	ld.w	r1,lr++
8000b4f4:	90 82       	ld.uh	r2,r8[0x0]
8000b4f6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b4fa:	ad 30       	mul	r0,r6
8000b4fc:	e0 02 00 02 	add	r2,r0,r2
8000b500:	e4 05 00 05 	add	r5,r2,r5
8000b504:	b0 05       	st.h	r8[0x0],r5
8000b506:	b1 85       	lsr	r5,0x10
8000b508:	b1 81       	lsr	r1,0x10
8000b50a:	2f c8       	sub	r8,-4
8000b50c:	ad 31       	mul	r1,r6
8000b50e:	90 92       	ld.uh	r2,r8[0x2]
8000b510:	e2 02 00 02 	add	r2,r1,r2
8000b514:	0a 02       	add	r2,r5
8000b516:	e4 05 16 10 	lsr	r5,r2,0x10
8000b51a:	06 3e       	cp.w	lr,r3
8000b51c:	ce a3       	brcs	8000b4f0 <__multiply+0xb0>
8000b51e:	91 02       	st.w	r8[0x0],r2
8000b520:	2f ca       	sub	r10,-4
8000b522:	2f c9       	sub	r9,-4
8000b524:	40 18       	lddsp	r8,sp[0x4]
8000b526:	10 3a       	cp.w	r10,r8
8000b528:	cb b3       	brcs	8000b49e <__multiply+0x5e>
8000b52a:	c0 28       	rjmp	8000b52e <__multiply+0xee>
8000b52c:	20 17       	sub	r7,1
8000b52e:	58 07       	cp.w	r7,0
8000b530:	e0 8a 00 05 	brle	8000b53a <__multiply+0xfa>
8000b534:	09 48       	ld.w	r8,--r4
8000b536:	58 08       	cp.w	r8,0
8000b538:	cf a0       	breq	8000b52c <__multiply+0xec>
8000b53a:	99 47       	st.w	r12[0x10],r7
8000b53c:	2f ed       	sub	sp,-8
8000b53e:	d8 32       	popm	r0-r7,pc

8000b540 <__i2b>:
8000b540:	d4 21       	pushm	r4-r7,lr
8000b542:	16 97       	mov	r7,r11
8000b544:	30 1b       	mov	r11,1
8000b546:	c4 9e       	rcall	8000b1d8 <_Balloc>
8000b548:	30 19       	mov	r9,1
8000b54a:	99 57       	st.w	r12[0x14],r7
8000b54c:	99 49       	st.w	r12[0x10],r9
8000b54e:	d8 22       	popm	r4-r7,pc

8000b550 <__multadd>:
8000b550:	d4 31       	pushm	r0-r7,lr
8000b552:	30 08       	mov	r8,0
8000b554:	12 95       	mov	r5,r9
8000b556:	16 97       	mov	r7,r11
8000b558:	18 96       	mov	r6,r12
8000b55a:	76 44       	ld.w	r4,r11[0x10]
8000b55c:	f6 c9 ff ec 	sub	r9,r11,-20
8000b560:	72 0b       	ld.w	r11,r9[0x0]
8000b562:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b566:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b56a:	f4 0c 02 4c 	mul	r12,r10,r12
8000b56e:	f4 0b 03 45 	mac	r5,r10,r11
8000b572:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b576:	b1 85       	lsr	r5,0x10
8000b578:	18 05       	add	r5,r12
8000b57a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b57e:	f8 0b 00 0b 	add	r11,r12,r11
8000b582:	12 ab       	st.w	r9++,r11
8000b584:	2f f8       	sub	r8,-1
8000b586:	b1 85       	lsr	r5,0x10
8000b588:	08 38       	cp.w	r8,r4
8000b58a:	ce b5       	brlt	8000b560 <__multadd+0x10>
8000b58c:	58 05       	cp.w	r5,0
8000b58e:	c1 c0       	breq	8000b5c6 <__multadd+0x76>
8000b590:	6e 28       	ld.w	r8,r7[0x8]
8000b592:	10 34       	cp.w	r4,r8
8000b594:	c1 35       	brlt	8000b5ba <__multadd+0x6a>
8000b596:	6e 1b       	ld.w	r11,r7[0x4]
8000b598:	0c 9c       	mov	r12,r6
8000b59a:	2f fb       	sub	r11,-1
8000b59c:	c1 ee       	rcall	8000b1d8 <_Balloc>
8000b59e:	6e 4a       	ld.w	r10,r7[0x10]
8000b5a0:	ee cb ff f4 	sub	r11,r7,-12
8000b5a4:	18 93       	mov	r3,r12
8000b5a6:	2f ea       	sub	r10,-2
8000b5a8:	2f 4c       	sub	r12,-12
8000b5aa:	a3 6a       	lsl	r10,0x2
8000b5ac:	fe b0 de 70 	rcall	8000728c <memcpy>
8000b5b0:	0e 9b       	mov	r11,r7
8000b5b2:	0c 9c       	mov	r12,r6
8000b5b4:	fe b0 fd f8 	rcall	8000b1a4 <_Bfree>
8000b5b8:	06 97       	mov	r7,r3
8000b5ba:	e8 c8 ff ff 	sub	r8,r4,-1
8000b5be:	2f b4       	sub	r4,-5
8000b5c0:	8f 48       	st.w	r7[0x10],r8
8000b5c2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b5c6:	0e 9c       	mov	r12,r7
8000b5c8:	d8 32       	popm	r0-r7,pc
8000b5ca:	d7 03       	nop

8000b5cc <__pow5mult>:
8000b5cc:	d4 31       	pushm	r0-r7,lr
8000b5ce:	14 96       	mov	r6,r10
8000b5d0:	18 97       	mov	r7,r12
8000b5d2:	16 94       	mov	r4,r11
8000b5d4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b5d8:	c0 90       	breq	8000b5ea <__pow5mult+0x1e>
8000b5da:	20 18       	sub	r8,1
8000b5dc:	fe c9 db 84 	sub	r9,pc,-9340
8000b5e0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b5e4:	30 09       	mov	r9,0
8000b5e6:	cb 5f       	rcall	8000b550 <__multadd>
8000b5e8:	18 94       	mov	r4,r12
8000b5ea:	a3 46       	asr	r6,0x2
8000b5ec:	c3 40       	breq	8000b654 <__pow5mult+0x88>
8000b5ee:	6e 95       	ld.w	r5,r7[0x24]
8000b5f0:	58 05       	cp.w	r5,0
8000b5f2:	c0 91       	brne	8000b604 <__pow5mult+0x38>
8000b5f4:	31 0c       	mov	r12,16
8000b5f6:	fe b0 dc 27 	rcall	80006e44 <malloc>
8000b5fa:	99 35       	st.w	r12[0xc],r5
8000b5fc:	8f 9c       	st.w	r7[0x24],r12
8000b5fe:	99 15       	st.w	r12[0x4],r5
8000b600:	99 25       	st.w	r12[0x8],r5
8000b602:	99 05       	st.w	r12[0x0],r5
8000b604:	6e 93       	ld.w	r3,r7[0x24]
8000b606:	66 25       	ld.w	r5,r3[0x8]
8000b608:	58 05       	cp.w	r5,0
8000b60a:	c0 c1       	brne	8000b622 <__pow5mult+0x56>
8000b60c:	e0 6b 02 71 	mov	r11,625
8000b610:	0e 9c       	mov	r12,r7
8000b612:	c9 7f       	rcall	8000b540 <__i2b>
8000b614:	87 2c       	st.w	r3[0x8],r12
8000b616:	30 08       	mov	r8,0
8000b618:	18 95       	mov	r5,r12
8000b61a:	99 08       	st.w	r12[0x0],r8
8000b61c:	c0 38       	rjmp	8000b622 <__pow5mult+0x56>
8000b61e:	06 9c       	mov	r12,r3
8000b620:	18 95       	mov	r5,r12
8000b622:	ed b6 00 00 	bld	r6,0x0
8000b626:	c0 b1       	brne	8000b63c <__pow5mult+0x70>
8000b628:	08 9b       	mov	r11,r4
8000b62a:	0a 9a       	mov	r10,r5
8000b62c:	0e 9c       	mov	r12,r7
8000b62e:	c0 9f       	rcall	8000b440 <__multiply>
8000b630:	08 9b       	mov	r11,r4
8000b632:	18 93       	mov	r3,r12
8000b634:	0e 9c       	mov	r12,r7
8000b636:	06 94       	mov	r4,r3
8000b638:	fe b0 fd b6 	rcall	8000b1a4 <_Bfree>
8000b63c:	a1 56       	asr	r6,0x1
8000b63e:	c0 b0       	breq	8000b654 <__pow5mult+0x88>
8000b640:	6a 03       	ld.w	r3,r5[0x0]
8000b642:	58 03       	cp.w	r3,0
8000b644:	ce d1       	brne	8000b61e <__pow5mult+0x52>
8000b646:	0a 9a       	mov	r10,r5
8000b648:	0a 9b       	mov	r11,r5
8000b64a:	0e 9c       	mov	r12,r7
8000b64c:	cf ae       	rcall	8000b440 <__multiply>
8000b64e:	8b 0c       	st.w	r5[0x0],r12
8000b650:	99 03       	st.w	r12[0x0],r3
8000b652:	ce 7b       	rjmp	8000b620 <__pow5mult+0x54>
8000b654:	08 9c       	mov	r12,r4
8000b656:	d8 32       	popm	r0-r7,pc

8000b658 <__isinfd>:
8000b658:	14 98       	mov	r8,r10
8000b65a:	fc 19 7f f0 	movh	r9,0x7ff0
8000b65e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b662:	f0 0b 11 00 	rsub	r11,r8,0
8000b666:	f7 e8 10 08 	or	r8,r11,r8
8000b66a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b66e:	f2 08 01 08 	sub	r8,r9,r8
8000b672:	f0 0c 11 00 	rsub	r12,r8,0
8000b676:	f9 e8 10 08 	or	r8,r12,r8
8000b67a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b67e:	2f fc       	sub	r12,-1
8000b680:	5e fc       	retal	r12

8000b682 <__isnand>:
8000b682:	14 98       	mov	r8,r10
8000b684:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b688:	f0 0c 11 00 	rsub	r12,r8,0
8000b68c:	10 4c       	or	r12,r8
8000b68e:	fc 18 7f f0 	movh	r8,0x7ff0
8000b692:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b696:	f0 0c 01 0c 	sub	r12,r8,r12
8000b69a:	bf 9c       	lsr	r12,0x1f
8000b69c:	5e fc       	retal	r12
8000b69e:	d7 03       	nop

8000b6a0 <__sclose>:
8000b6a0:	d4 01       	pushm	lr
8000b6a2:	96 7b       	ld.sh	r11,r11[0xe]
8000b6a4:	c8 2c       	rcall	8000b7a8 <_close_r>
8000b6a6:	d8 02       	popm	pc

8000b6a8 <__sseek>:
8000b6a8:	d4 21       	pushm	r4-r7,lr
8000b6aa:	16 97       	mov	r7,r11
8000b6ac:	96 7b       	ld.sh	r11,r11[0xe]
8000b6ae:	c0 3d       	rcall	8000b8b4 <_lseek_r>
8000b6b0:	8e 68       	ld.sh	r8,r7[0xc]
8000b6b2:	10 99       	mov	r9,r8
8000b6b4:	ad c8       	cbr	r8,0xc
8000b6b6:	ad a9       	sbr	r9,0xc
8000b6b8:	5b fc       	cp.w	r12,-1
8000b6ba:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b6be:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b6c2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b6c6:	d8 22       	popm	r4-r7,pc

8000b6c8 <__swrite>:
8000b6c8:	d4 21       	pushm	r4-r7,lr
8000b6ca:	96 68       	ld.sh	r8,r11[0xc]
8000b6cc:	16 97       	mov	r7,r11
8000b6ce:	14 95       	mov	r5,r10
8000b6d0:	12 94       	mov	r4,r9
8000b6d2:	e2 18 01 00 	andl	r8,0x100,COH
8000b6d6:	18 96       	mov	r6,r12
8000b6d8:	c0 50       	breq	8000b6e2 <__swrite+0x1a>
8000b6da:	30 29       	mov	r9,2
8000b6dc:	30 0a       	mov	r10,0
8000b6de:	96 7b       	ld.sh	r11,r11[0xe]
8000b6e0:	ce ac       	rcall	8000b8b4 <_lseek_r>
8000b6e2:	8e 68       	ld.sh	r8,r7[0xc]
8000b6e4:	ad c8       	cbr	r8,0xc
8000b6e6:	08 99       	mov	r9,r4
8000b6e8:	0a 9a       	mov	r10,r5
8000b6ea:	8e 7b       	ld.sh	r11,r7[0xe]
8000b6ec:	0c 9c       	mov	r12,r6
8000b6ee:	ae 68       	st.h	r7[0xc],r8
8000b6f0:	c1 cc       	rcall	8000b728 <_write_r>
8000b6f2:	d8 22       	popm	r4-r7,pc

8000b6f4 <__sread>:
8000b6f4:	d4 21       	pushm	r4-r7,lr
8000b6f6:	16 97       	mov	r7,r11
8000b6f8:	96 7b       	ld.sh	r11,r11[0xe]
8000b6fa:	cf 1c       	rcall	8000b8dc <_read_r>
8000b6fc:	c0 65       	brlt	8000b708 <__sread+0x14>
8000b6fe:	6f 58       	ld.w	r8,r7[0x54]
8000b700:	18 08       	add	r8,r12
8000b702:	ef 48 00 54 	st.w	r7[84],r8
8000b706:	d8 22       	popm	r4-r7,pc
8000b708:	8e 68       	ld.sh	r8,r7[0xc]
8000b70a:	ad c8       	cbr	r8,0xc
8000b70c:	ae 68       	st.h	r7[0xc],r8
8000b70e:	d8 22       	popm	r4-r7,pc

8000b710 <strlen>:
8000b710:	30 09       	mov	r9,0
8000b712:	18 98       	mov	r8,r12
8000b714:	c0 28       	rjmp	8000b718 <strlen+0x8>
8000b716:	2f f8       	sub	r8,-1
8000b718:	11 8a       	ld.ub	r10,r8[0x0]
8000b71a:	f2 0a 18 00 	cp.b	r10,r9
8000b71e:	cf c1       	brne	8000b716 <strlen+0x6>
8000b720:	f0 0c 01 0c 	sub	r12,r8,r12
8000b724:	5e fc       	retal	r12
8000b726:	d7 03       	nop

8000b728 <_write_r>:
8000b728:	d4 21       	pushm	r4-r7,lr
8000b72a:	16 98       	mov	r8,r11
8000b72c:	18 97       	mov	r7,r12
8000b72e:	10 9c       	mov	r12,r8
8000b730:	30 08       	mov	r8,0
8000b732:	14 9b       	mov	r11,r10
8000b734:	e0 66 51 1c 	mov	r6,20764
8000b738:	12 9a       	mov	r10,r9
8000b73a:	8d 08       	st.w	r6[0x0],r8
8000b73c:	fe b0 d1 a0 	rcall	80005a7c <_write>
8000b740:	5b fc       	cp.w	r12,-1
8000b742:	c0 51       	brne	8000b74c <_write_r+0x24>
8000b744:	6c 08       	ld.w	r8,r6[0x0]
8000b746:	58 08       	cp.w	r8,0
8000b748:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b74c:	d8 22       	popm	r4-r7,pc
8000b74e:	d7 03       	nop

8000b750 <_calloc_r>:
8000b750:	d4 21       	pushm	r4-r7,lr
8000b752:	f4 0b 02 4b 	mul	r11,r10,r11
8000b756:	fe b0 db 7f 	rcall	80006e54 <_malloc_r>
8000b75a:	18 97       	mov	r7,r12
8000b75c:	c2 30       	breq	8000b7a2 <_calloc_r+0x52>
8000b75e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b762:	e0 1a ff fc 	andl	r10,0xfffc
8000b766:	20 4a       	sub	r10,4
8000b768:	e0 4a 00 24 	cp.w	r10,36
8000b76c:	e0 8b 00 18 	brhi	8000b79c <_calloc_r+0x4c>
8000b770:	18 98       	mov	r8,r12
8000b772:	59 3a       	cp.w	r10,19
8000b774:	e0 88 00 0f 	brls	8000b792 <_calloc_r+0x42>
8000b778:	30 09       	mov	r9,0
8000b77a:	10 a9       	st.w	r8++,r9
8000b77c:	10 a9       	st.w	r8++,r9
8000b77e:	59 ba       	cp.w	r10,27
8000b780:	e0 88 00 09 	brls	8000b792 <_calloc_r+0x42>
8000b784:	10 a9       	st.w	r8++,r9
8000b786:	10 a9       	st.w	r8++,r9
8000b788:	e0 4a 00 24 	cp.w	r10,36
8000b78c:	c0 31       	brne	8000b792 <_calloc_r+0x42>
8000b78e:	10 a9       	st.w	r8++,r9
8000b790:	10 a9       	st.w	r8++,r9
8000b792:	30 09       	mov	r9,0
8000b794:	10 a9       	st.w	r8++,r9
8000b796:	91 19       	st.w	r8[0x4],r9
8000b798:	91 09       	st.w	r8[0x0],r9
8000b79a:	c0 48       	rjmp	8000b7a2 <_calloc_r+0x52>
8000b79c:	30 0b       	mov	r11,0
8000b79e:	fe b0 de 1b 	rcall	800073d4 <memset>
8000b7a2:	0e 9c       	mov	r12,r7
8000b7a4:	d8 22       	popm	r4-r7,pc
8000b7a6:	d7 03       	nop

8000b7a8 <_close_r>:
8000b7a8:	d4 21       	pushm	r4-r7,lr
8000b7aa:	30 08       	mov	r8,0
8000b7ac:	18 97       	mov	r7,r12
8000b7ae:	e0 66 51 1c 	mov	r6,20764
8000b7b2:	16 9c       	mov	r12,r11
8000b7b4:	8d 08       	st.w	r6[0x0],r8
8000b7b6:	fe b0 df b5 	rcall	80007720 <_close>
8000b7ba:	5b fc       	cp.w	r12,-1
8000b7bc:	c0 51       	brne	8000b7c6 <_close_r+0x1e>
8000b7be:	6c 08       	ld.w	r8,r6[0x0]
8000b7c0:	58 08       	cp.w	r8,0
8000b7c2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7c6:	d8 22       	popm	r4-r7,pc

8000b7c8 <_fclose_r>:
8000b7c8:	d4 21       	pushm	r4-r7,lr
8000b7ca:	18 96       	mov	r6,r12
8000b7cc:	16 97       	mov	r7,r11
8000b7ce:	58 0b       	cp.w	r11,0
8000b7d0:	c0 31       	brne	8000b7d6 <_fclose_r+0xe>
8000b7d2:	16 95       	mov	r5,r11
8000b7d4:	c5 38       	rjmp	8000b87a <_fclose_r+0xb2>
8000b7d6:	fe b0 f8 a9 	rcall	8000a928 <__sfp_lock_acquire>
8000b7da:	58 06       	cp.w	r6,0
8000b7dc:	c0 70       	breq	8000b7ea <_fclose_r+0x22>
8000b7de:	6c 68       	ld.w	r8,r6[0x18]
8000b7e0:	58 08       	cp.w	r8,0
8000b7e2:	c0 41       	brne	8000b7ea <_fclose_r+0x22>
8000b7e4:	0c 9c       	mov	r12,r6
8000b7e6:	fe b0 f8 f3 	rcall	8000a9cc <__sinit>
8000b7ea:	fe c8 de 36 	sub	r8,pc,-8650
8000b7ee:	10 37       	cp.w	r7,r8
8000b7f0:	c0 31       	brne	8000b7f6 <_fclose_r+0x2e>
8000b7f2:	6c 07       	ld.w	r7,r6[0x0]
8000b7f4:	c0 c8       	rjmp	8000b80c <_fclose_r+0x44>
8000b7f6:	fe c8 de 22 	sub	r8,pc,-8670
8000b7fa:	10 37       	cp.w	r7,r8
8000b7fc:	c0 31       	brne	8000b802 <_fclose_r+0x3a>
8000b7fe:	6c 17       	ld.w	r7,r6[0x4]
8000b800:	c0 68       	rjmp	8000b80c <_fclose_r+0x44>
8000b802:	fe c8 de 0e 	sub	r8,pc,-8690
8000b806:	10 37       	cp.w	r7,r8
8000b808:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b80c:	8e 69       	ld.sh	r9,r7[0xc]
8000b80e:	30 08       	mov	r8,0
8000b810:	f0 09 19 00 	cp.h	r9,r8
8000b814:	c0 51       	brne	8000b81e <_fclose_r+0x56>
8000b816:	fe b0 f8 8a 	rcall	8000a92a <__sfp_lock_release>
8000b81a:	30 05       	mov	r5,0
8000b81c:	c2 f8       	rjmp	8000b87a <_fclose_r+0xb2>
8000b81e:	0e 9b       	mov	r11,r7
8000b820:	0c 9c       	mov	r12,r6
8000b822:	fe b0 f7 fd 	rcall	8000a81c <_fflush_r>
8000b826:	6e c8       	ld.w	r8,r7[0x30]
8000b828:	18 95       	mov	r5,r12
8000b82a:	58 08       	cp.w	r8,0
8000b82c:	c0 60       	breq	8000b838 <_fclose_r+0x70>
8000b82e:	6e 8b       	ld.w	r11,r7[0x20]
8000b830:	0c 9c       	mov	r12,r6
8000b832:	5d 18       	icall	r8
8000b834:	f9 b5 05 ff 	movlt	r5,-1
8000b838:	8e 68       	ld.sh	r8,r7[0xc]
8000b83a:	ed b8 00 07 	bld	r8,0x7
8000b83e:	c0 51       	brne	8000b848 <_fclose_r+0x80>
8000b840:	6e 4b       	ld.w	r11,r7[0x10]
8000b842:	0c 9c       	mov	r12,r6
8000b844:	fe b0 f9 5e 	rcall	8000ab00 <_free_r>
8000b848:	6e db       	ld.w	r11,r7[0x34]
8000b84a:	58 0b       	cp.w	r11,0
8000b84c:	c0 a0       	breq	8000b860 <_fclose_r+0x98>
8000b84e:	ee c8 ff bc 	sub	r8,r7,-68
8000b852:	10 3b       	cp.w	r11,r8
8000b854:	c0 40       	breq	8000b85c <_fclose_r+0x94>
8000b856:	0c 9c       	mov	r12,r6
8000b858:	fe b0 f9 54 	rcall	8000ab00 <_free_r>
8000b85c:	30 08       	mov	r8,0
8000b85e:	8f d8       	st.w	r7[0x34],r8
8000b860:	6f 2b       	ld.w	r11,r7[0x48]
8000b862:	58 0b       	cp.w	r11,0
8000b864:	c0 70       	breq	8000b872 <_fclose_r+0xaa>
8000b866:	0c 9c       	mov	r12,r6
8000b868:	fe b0 f9 4c 	rcall	8000ab00 <_free_r>
8000b86c:	30 08       	mov	r8,0
8000b86e:	ef 48 00 48 	st.w	r7[72],r8
8000b872:	30 08       	mov	r8,0
8000b874:	ae 68       	st.h	r7[0xc],r8
8000b876:	fe b0 f8 5a 	rcall	8000a92a <__sfp_lock_release>
8000b87a:	0a 9c       	mov	r12,r5
8000b87c:	d8 22       	popm	r4-r7,pc
8000b87e:	d7 03       	nop

8000b880 <fclose>:
8000b880:	d4 01       	pushm	lr
8000b882:	e0 68 0a 38 	mov	r8,2616
8000b886:	18 9b       	mov	r11,r12
8000b888:	70 0c       	ld.w	r12,r8[0x0]
8000b88a:	c9 ff       	rcall	8000b7c8 <_fclose_r>
8000b88c:	d8 02       	popm	pc
8000b88e:	d7 03       	nop

8000b890 <_fstat_r>:
8000b890:	d4 21       	pushm	r4-r7,lr
8000b892:	16 98       	mov	r8,r11
8000b894:	18 97       	mov	r7,r12
8000b896:	10 9c       	mov	r12,r8
8000b898:	30 08       	mov	r8,0
8000b89a:	e0 66 51 1c 	mov	r6,20764
8000b89e:	14 9b       	mov	r11,r10
8000b8a0:	8d 08       	st.w	r6[0x0],r8
8000b8a2:	fe b0 df 67 	rcall	80007770 <_fstat>
8000b8a6:	5b fc       	cp.w	r12,-1
8000b8a8:	c0 51       	brne	8000b8b2 <_fstat_r+0x22>
8000b8aa:	6c 08       	ld.w	r8,r6[0x0]
8000b8ac:	58 08       	cp.w	r8,0
8000b8ae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8b2:	d8 22       	popm	r4-r7,pc

8000b8b4 <_lseek_r>:
8000b8b4:	d4 21       	pushm	r4-r7,lr
8000b8b6:	16 98       	mov	r8,r11
8000b8b8:	18 97       	mov	r7,r12
8000b8ba:	10 9c       	mov	r12,r8
8000b8bc:	30 08       	mov	r8,0
8000b8be:	14 9b       	mov	r11,r10
8000b8c0:	e0 66 51 1c 	mov	r6,20764
8000b8c4:	12 9a       	mov	r10,r9
8000b8c6:	8d 08       	st.w	r6[0x0],r8
8000b8c8:	fe b0 df 36 	rcall	80007734 <_lseek>
8000b8cc:	5b fc       	cp.w	r12,-1
8000b8ce:	c0 51       	brne	8000b8d8 <_lseek_r+0x24>
8000b8d0:	6c 08       	ld.w	r8,r6[0x0]
8000b8d2:	58 08       	cp.w	r8,0
8000b8d4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8d8:	d8 22       	popm	r4-r7,pc
8000b8da:	d7 03       	nop

8000b8dc <_read_r>:
8000b8dc:	d4 21       	pushm	r4-r7,lr
8000b8de:	16 98       	mov	r8,r11
8000b8e0:	18 97       	mov	r7,r12
8000b8e2:	10 9c       	mov	r12,r8
8000b8e4:	30 08       	mov	r8,0
8000b8e6:	14 9b       	mov	r11,r10
8000b8e8:	e0 66 51 1c 	mov	r6,20764
8000b8ec:	12 9a       	mov	r10,r9
8000b8ee:	8d 08       	st.w	r6[0x0],r8
8000b8f0:	fe b0 d0 a6 	rcall	80005a3c <_read>
8000b8f4:	5b fc       	cp.w	r12,-1
8000b8f6:	c0 51       	brne	8000b900 <_read_r+0x24>
8000b8f8:	6c 08       	ld.w	r8,r6[0x0]
8000b8fa:	58 08       	cp.w	r8,0
8000b8fc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b900:	d8 22       	popm	r4-r7,pc
8000b902:	d7 03       	nop

8000b904 <__avr32_f64_mul>:
8000b904:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b908:	e0 80 00 dc 	breq	8000bac0 <__avr32_f64_mul_op1_zero>
8000b90c:	d4 21       	pushm	r4-r7,lr
8000b90e:	f7 e9 20 0e 	eor	lr,r11,r9
8000b912:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b916:	30 15       	mov	r5,1
8000b918:	c4 30       	breq	8000b99e <__avr32_f64_mul_op1_subnormal>
8000b91a:	ab 6b       	lsl	r11,0xa
8000b91c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b920:	ab 6a       	lsl	r10,0xa
8000b922:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b926:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b92a:	c5 c0       	breq	8000b9e2 <__avr32_f64_mul_op2_subnormal>
8000b92c:	a1 78       	lsl	r8,0x1
8000b92e:	5c f9       	rol	r9
8000b930:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b934:	e0 47 07 ff 	cp.w	r7,2047
8000b938:	c7 70       	breq	8000ba26 <__avr32_f64_mul_op_nan_or_inf>
8000b93a:	e0 46 07 ff 	cp.w	r6,2047
8000b93e:	c7 40       	breq	8000ba26 <__avr32_f64_mul_op_nan_or_inf>
8000b940:	ee 06 00 0c 	add	r12,r7,r6
8000b944:	e0 2c 03 fe 	sub	r12,1022
8000b948:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b94c:	f4 09 07 44 	macu.d	r4,r10,r9
8000b950:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b954:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b958:	08 07       	add	r7,r4
8000b95a:	f4 05 00 4a 	adc	r10,r10,r5
8000b95e:	5c 0b       	acr	r11
8000b960:	ed bb 00 14 	bld	r11,0x14
8000b964:	c0 50       	breq	8000b96e <__avr32_f64_mul+0x6a>
8000b966:	a1 77       	lsl	r7,0x1
8000b968:	5c fa       	rol	r10
8000b96a:	5c fb       	rol	r11
8000b96c:	20 1c       	sub	r12,1
8000b96e:	58 0c       	cp.w	r12,0
8000b970:	e0 8a 00 6f 	brle	8000ba4e <__avr32_f64_mul_res_subnormal>
8000b974:	e0 4c 07 ff 	cp.w	r12,2047
8000b978:	e0 84 00 9c 	brge	8000bab0 <__avr32_f64_mul_res_inf>
8000b97c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b980:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b984:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b988:	ee 17 80 00 	eorh	r7,0x8000
8000b98c:	f1 b7 04 20 	satu	r7,0x1
8000b990:	0e 0a       	add	r10,r7
8000b992:	5c 0b       	acr	r11
8000b994:	ed be 00 1f 	bld	lr,0x1f
8000b998:	ef bb 00 1f 	bst	r11,0x1f
8000b99c:	d8 22       	popm	r4-r7,pc

8000b99e <__avr32_f64_mul_op1_subnormal>:
8000b99e:	e4 1b 00 0f 	andh	r11,0xf
8000b9a2:	f4 0c 12 00 	clz	r12,r10
8000b9a6:	f6 06 12 00 	clz	r6,r11
8000b9aa:	f7 bc 03 e1 	sublo	r12,-31
8000b9ae:	f8 06 17 30 	movlo	r6,r12
8000b9b2:	f7 b6 02 01 	subhs	r6,1
8000b9b6:	e0 46 00 20 	cp.w	r6,32
8000b9ba:	c0 d4       	brge	8000b9d4 <__avr32_f64_mul_op1_subnormal+0x36>
8000b9bc:	ec 0c 11 20 	rsub	r12,r6,32
8000b9c0:	f6 06 09 4b 	lsl	r11,r11,r6
8000b9c4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b9c8:	18 4b       	or	r11,r12
8000b9ca:	f4 06 09 4a 	lsl	r10,r10,r6
8000b9ce:	20 b6       	sub	r6,11
8000b9d0:	0c 17       	sub	r7,r6
8000b9d2:	ca ab       	rjmp	8000b926 <__avr32_f64_mul+0x22>
8000b9d4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9d8:	c6 40       	breq	8000baa0 <__avr32_f64_mul_res_zero>
8000b9da:	30 0a       	mov	r10,0
8000b9dc:	20 b6       	sub	r6,11
8000b9de:	0c 17       	sub	r7,r6
8000b9e0:	ca 3b       	rjmp	8000b926 <__avr32_f64_mul+0x22>

8000b9e2 <__avr32_f64_mul_op2_subnormal>:
8000b9e2:	e4 19 00 0f 	andh	r9,0xf
8000b9e6:	f0 0c 12 00 	clz	r12,r8
8000b9ea:	f2 05 12 00 	clz	r5,r9
8000b9ee:	f7 bc 03 ea 	sublo	r12,-22
8000b9f2:	f8 05 17 30 	movlo	r5,r12
8000b9f6:	f7 b5 02 0a 	subhs	r5,10
8000b9fa:	e0 45 00 20 	cp.w	r5,32
8000b9fe:	c0 d4       	brge	8000ba18 <__avr32_f64_mul_op2_subnormal+0x36>
8000ba00:	ea 0c 11 20 	rsub	r12,r5,32
8000ba04:	f2 05 09 49 	lsl	r9,r9,r5
8000ba08:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ba0c:	18 49       	or	r9,r12
8000ba0e:	f0 05 09 48 	lsl	r8,r8,r5
8000ba12:	20 25       	sub	r5,2
8000ba14:	0a 16       	sub	r6,r5
8000ba16:	c8 fb       	rjmp	8000b934 <__avr32_f64_mul+0x30>
8000ba18:	f0 05 09 49 	lsl	r9,r8,r5
8000ba1c:	c4 20       	breq	8000baa0 <__avr32_f64_mul_res_zero>
8000ba1e:	30 08       	mov	r8,0
8000ba20:	20 25       	sub	r5,2
8000ba22:	0a 16       	sub	r6,r5
8000ba24:	c8 8b       	rjmp	8000b934 <__avr32_f64_mul+0x30>

8000ba26 <__avr32_f64_mul_op_nan_or_inf>:
8000ba26:	e4 19 00 0f 	andh	r9,0xf
8000ba2a:	e4 1b 00 0f 	andh	r11,0xf
8000ba2e:	14 4b       	or	r11,r10
8000ba30:	10 49       	or	r9,r8
8000ba32:	e0 47 07 ff 	cp.w	r7,2047
8000ba36:	c0 91       	brne	8000ba48 <__avr32_f64_mul_op1_not_naninf>
8000ba38:	58 0b       	cp.w	r11,0
8000ba3a:	c3 81       	brne	8000baaa <__avr32_f64_mul_res_nan>
8000ba3c:	e0 46 07 ff 	cp.w	r6,2047
8000ba40:	c3 81       	brne	8000bab0 <__avr32_f64_mul_res_inf>
8000ba42:	58 09       	cp.w	r9,0
8000ba44:	c3 60       	breq	8000bab0 <__avr32_f64_mul_res_inf>
8000ba46:	c3 28       	rjmp	8000baaa <__avr32_f64_mul_res_nan>

8000ba48 <__avr32_f64_mul_op1_not_naninf>:
8000ba48:	58 09       	cp.w	r9,0
8000ba4a:	c3 30       	breq	8000bab0 <__avr32_f64_mul_res_inf>
8000ba4c:	c2 f8       	rjmp	8000baaa <__avr32_f64_mul_res_nan>

8000ba4e <__avr32_f64_mul_res_subnormal>:
8000ba4e:	5c 3c       	neg	r12
8000ba50:	2f fc       	sub	r12,-1
8000ba52:	f1 bc 04 c0 	satu	r12,0x6
8000ba56:	e0 4c 00 20 	cp.w	r12,32
8000ba5a:	c1 14       	brge	8000ba7c <__avr32_f64_mul_res_subnormal+0x2e>
8000ba5c:	f8 08 11 20 	rsub	r8,r12,32
8000ba60:	0e 46       	or	r6,r7
8000ba62:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ba66:	f4 08 09 49 	lsl	r9,r10,r8
8000ba6a:	12 47       	or	r7,r9
8000ba6c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba70:	f6 08 09 49 	lsl	r9,r11,r8
8000ba74:	12 4a       	or	r10,r9
8000ba76:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba7a:	c8 3b       	rjmp	8000b980 <__avr32_f64_mul+0x7c>
8000ba7c:	f8 08 11 20 	rsub	r8,r12,32
8000ba80:	f9 b9 00 00 	moveq	r9,0
8000ba84:	c0 30       	breq	8000ba8a <__avr32_f64_mul_res_subnormal+0x3c>
8000ba86:	f6 08 09 49 	lsl	r9,r11,r8
8000ba8a:	0e 46       	or	r6,r7
8000ba8c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ba90:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba94:	f3 ea 10 07 	or	r7,r9,r10
8000ba98:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ba9c:	30 0b       	mov	r11,0
8000ba9e:	c7 1b       	rjmp	8000b980 <__avr32_f64_mul+0x7c>

8000baa0 <__avr32_f64_mul_res_zero>:
8000baa0:	1c 9b       	mov	r11,lr
8000baa2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000baa6:	30 0a       	mov	r10,0
8000baa8:	d8 22       	popm	r4-r7,pc

8000baaa <__avr32_f64_mul_res_nan>:
8000baaa:	3f fb       	mov	r11,-1
8000baac:	3f fa       	mov	r10,-1
8000baae:	d8 22       	popm	r4-r7,pc

8000bab0 <__avr32_f64_mul_res_inf>:
8000bab0:	f0 6b 00 00 	mov	r11,-1048576
8000bab4:	ed be 00 1f 	bld	lr,0x1f
8000bab8:	ef bb 00 1f 	bst	r11,0x1f
8000babc:	30 0a       	mov	r10,0
8000babe:	d8 22       	popm	r4-r7,pc

8000bac0 <__avr32_f64_mul_op1_zero>:
8000bac0:	f7 e9 20 0b 	eor	r11,r11,r9
8000bac4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bac8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bacc:	e0 4c 07 ff 	cp.w	r12,2047
8000bad0:	5e 1c       	retne	r12
8000bad2:	3f fa       	mov	r10,-1
8000bad4:	3f fb       	mov	r11,-1
8000bad6:	5e fc       	retal	r12

8000bad8 <__avr32_f64_sub_from_add>:
8000bad8:	ee 19 80 00 	eorh	r9,0x8000

8000badc <__avr32_f64_sub>:
8000badc:	f7 e9 20 0c 	eor	r12,r11,r9
8000bae0:	e0 86 00 ca 	brmi	8000bc74 <__avr32_f64_add_from_sub>
8000bae4:	eb cd 40 e0 	pushm	r5-r7,lr
8000bae8:	16 9c       	mov	r12,r11
8000baea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000baee:	bf db       	cbr	r11,0x1f
8000baf0:	bf d9       	cbr	r9,0x1f
8000baf2:	10 3a       	cp.w	r10,r8
8000baf4:	f2 0b 13 00 	cpc	r11,r9
8000baf8:	c0 92       	brcc	8000bb0a <__avr32_f64_sub+0x2e>
8000bafa:	16 97       	mov	r7,r11
8000bafc:	12 9b       	mov	r11,r9
8000bafe:	0e 99       	mov	r9,r7
8000bb00:	14 97       	mov	r7,r10
8000bb02:	10 9a       	mov	r10,r8
8000bb04:	0e 98       	mov	r8,r7
8000bb06:	ee 1c 80 00 	eorh	r12,0x8000
8000bb0a:	f6 07 16 14 	lsr	r7,r11,0x14
8000bb0e:	ab 7b       	lsl	r11,0xb
8000bb10:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb14:	ab 7a       	lsl	r10,0xb
8000bb16:	bf bb       	sbr	r11,0x1f
8000bb18:	f2 06 16 14 	lsr	r6,r9,0x14
8000bb1c:	c4 40       	breq	8000bba4 <__avr32_f64_sub_opL_subnormal>
8000bb1e:	ab 79       	lsl	r9,0xb
8000bb20:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb24:	ab 78       	lsl	r8,0xb
8000bb26:	bf b9       	sbr	r9,0x1f

8000bb28 <__avr32_f64_sub_opL_subnormal_done>:
8000bb28:	e0 47 07 ff 	cp.w	r7,2047
8000bb2c:	c4 f0       	breq	8000bbca <__avr32_f64_sub_opH_nan_or_inf>
8000bb2e:	0e 26       	rsub	r6,r7
8000bb30:	c1 20       	breq	8000bb54 <__avr32_f64_sub_shift_done>
8000bb32:	ec 05 11 20 	rsub	r5,r6,32
8000bb36:	e0 46 00 20 	cp.w	r6,32
8000bb3a:	c7 c2       	brcc	8000bc32 <__avr32_f64_sub_longshift>
8000bb3c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bb40:	f2 05 09 45 	lsl	r5,r9,r5
8000bb44:	f0 06 0a 48 	lsr	r8,r8,r6
8000bb48:	f2 06 0a 49 	lsr	r9,r9,r6
8000bb4c:	0a 48       	or	r8,r5
8000bb4e:	58 0e       	cp.w	lr,0
8000bb50:	5f 1e       	srne	lr
8000bb52:	1c 48       	or	r8,lr

8000bb54 <__avr32_f64_sub_shift_done>:
8000bb54:	10 1a       	sub	r10,r8
8000bb56:	f6 09 01 4b 	sbc	r11,r11,r9
8000bb5a:	f6 06 12 00 	clz	r6,r11
8000bb5e:	c0 e0       	breq	8000bb7a <__avr32_f64_sub_longnormalize_done>
8000bb60:	c7 83       	brcs	8000bc50 <__avr32_f64_sub_longnormalize>
8000bb62:	ec 0e 11 20 	rsub	lr,r6,32
8000bb66:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb6a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb6e:	1c 4b       	or	r11,lr
8000bb70:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb74:	0c 17       	sub	r7,r6
8000bb76:	e0 8a 00 39 	brle	8000bbe8 <__avr32_f64_sub_subnormal_result>

8000bb7a <__avr32_f64_sub_longnormalize_done>:
8000bb7a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bb7e:	ab 9a       	lsr	r10,0xb
8000bb80:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb84:	ab 9b       	lsr	r11,0xb
8000bb86:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bb8a:	18 4b       	or	r11,r12

8000bb8c <__avr32_f64_sub_round>:
8000bb8c:	fc 17 80 00 	movh	r7,0x8000
8000bb90:	ed ba 00 00 	bld	r10,0x0
8000bb94:	f7 b7 01 ff 	subne	r7,-1
8000bb98:	0e 39       	cp.w	r9,r7
8000bb9a:	5f 29       	srhs	r9
8000bb9c:	12 0a       	add	r10,r9
8000bb9e:	5c 0b       	acr	r11
8000bba0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bba4 <__avr32_f64_sub_opL_subnormal>:
8000bba4:	ab 79       	lsl	r9,0xb
8000bba6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bbaa:	ab 78       	lsl	r8,0xb
8000bbac:	f3 e8 10 0e 	or	lr,r9,r8
8000bbb0:	f9 b6 01 01 	movne	r6,1
8000bbb4:	ee 0e 11 00 	rsub	lr,r7,0
8000bbb8:	f9 b7 00 01 	moveq	r7,1
8000bbbc:	ef bb 00 1f 	bst	r11,0x1f
8000bbc0:	f7 ea 10 0e 	or	lr,r11,r10
8000bbc4:	f9 b7 00 00 	moveq	r7,0
8000bbc8:	cb 0b       	rjmp	8000bb28 <__avr32_f64_sub_opL_subnormal_done>

8000bbca <__avr32_f64_sub_opH_nan_or_inf>:
8000bbca:	bf db       	cbr	r11,0x1f
8000bbcc:	f7 ea 10 0e 	or	lr,r11,r10
8000bbd0:	c0 81       	brne	8000bbe0 <__avr32_f64_sub_return_nan>
8000bbd2:	e0 46 07 ff 	cp.w	r6,2047
8000bbd6:	c0 50       	breq	8000bbe0 <__avr32_f64_sub_return_nan>
8000bbd8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bbdc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbe0 <__avr32_f64_sub_return_nan>:
8000bbe0:	3f fa       	mov	r10,-1
8000bbe2:	3f fb       	mov	r11,-1
8000bbe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbe8 <__avr32_f64_sub_subnormal_result>:
8000bbe8:	5c 37       	neg	r7
8000bbea:	2f f7       	sub	r7,-1
8000bbec:	f1 b7 04 c0 	satu	r7,0x6
8000bbf0:	e0 47 00 20 	cp.w	r7,32
8000bbf4:	c1 14       	brge	8000bc16 <__avr32_f64_sub_subnormal_result+0x2e>
8000bbf6:	ee 08 11 20 	rsub	r8,r7,32
8000bbfa:	f4 08 09 49 	lsl	r9,r10,r8
8000bbfe:	5f 16       	srne	r6
8000bc00:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bc04:	0c 4a       	or	r10,r6
8000bc06:	f6 08 09 49 	lsl	r9,r11,r8
8000bc0a:	f5 e9 10 0a 	or	r10,r10,r9
8000bc0e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bc12:	30 07       	mov	r7,0
8000bc14:	cb 3b       	rjmp	8000bb7a <__avr32_f64_sub_longnormalize_done>
8000bc16:	ee 08 11 40 	rsub	r8,r7,64
8000bc1a:	f6 08 09 49 	lsl	r9,r11,r8
8000bc1e:	14 49       	or	r9,r10
8000bc20:	5f 16       	srne	r6
8000bc22:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bc26:	0c 4a       	or	r10,r6
8000bc28:	30 0b       	mov	r11,0
8000bc2a:	30 07       	mov	r7,0
8000bc2c:	ca 7b       	rjmp	8000bb7a <__avr32_f64_sub_longnormalize_done>
8000bc2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc32 <__avr32_f64_sub_longshift>:
8000bc32:	f1 b6 04 c0 	satu	r6,0x6
8000bc36:	f0 0e 17 00 	moveq	lr,r8
8000bc3a:	c0 40       	breq	8000bc42 <__avr32_f64_sub_longshift+0x10>
8000bc3c:	f2 05 09 4e 	lsl	lr,r9,r5
8000bc40:	10 4e       	or	lr,r8
8000bc42:	f2 06 0a 48 	lsr	r8,r9,r6
8000bc46:	30 09       	mov	r9,0
8000bc48:	58 0e       	cp.w	lr,0
8000bc4a:	5f 1e       	srne	lr
8000bc4c:	1c 48       	or	r8,lr
8000bc4e:	c8 3b       	rjmp	8000bb54 <__avr32_f64_sub_shift_done>

8000bc50 <__avr32_f64_sub_longnormalize>:
8000bc50:	f4 06 12 00 	clz	r6,r10
8000bc54:	f9 b7 03 00 	movlo	r7,0
8000bc58:	f9 b6 03 00 	movlo	r6,0
8000bc5c:	f9 bc 03 00 	movlo	r12,0
8000bc60:	f7 b6 02 e0 	subhs	r6,-32
8000bc64:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc68:	30 0a       	mov	r10,0
8000bc6a:	0c 17       	sub	r7,r6
8000bc6c:	fe 9a ff be 	brle	8000bbe8 <__avr32_f64_sub_subnormal_result>
8000bc70:	c8 5b       	rjmp	8000bb7a <__avr32_f64_sub_longnormalize_done>
8000bc72:	d7 03       	nop

8000bc74 <__avr32_f64_add_from_sub>:
8000bc74:	ee 19 80 00 	eorh	r9,0x8000

8000bc78 <__avr32_f64_add>:
8000bc78:	f7 e9 20 0c 	eor	r12,r11,r9
8000bc7c:	fe 96 ff 2e 	brmi	8000bad8 <__avr32_f64_sub_from_add>
8000bc80:	eb cd 40 e0 	pushm	r5-r7,lr
8000bc84:	16 9c       	mov	r12,r11
8000bc86:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bc8a:	bf db       	cbr	r11,0x1f
8000bc8c:	bf d9       	cbr	r9,0x1f
8000bc8e:	12 3b       	cp.w	r11,r9
8000bc90:	c0 72       	brcc	8000bc9e <__avr32_f64_add+0x26>
8000bc92:	16 97       	mov	r7,r11
8000bc94:	12 9b       	mov	r11,r9
8000bc96:	0e 99       	mov	r9,r7
8000bc98:	14 97       	mov	r7,r10
8000bc9a:	10 9a       	mov	r10,r8
8000bc9c:	0e 98       	mov	r8,r7
8000bc9e:	30 0e       	mov	lr,0
8000bca0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bca4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bca8:	b5 ab       	sbr	r11,0x14
8000bcaa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bcae:	c6 20       	breq	8000bd72 <__avr32_f64_add_op2_subnormal>
8000bcb0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bcb4:	b5 a9       	sbr	r9,0x14
8000bcb6:	e0 47 07 ff 	cp.w	r7,2047
8000bcba:	c2 80       	breq	8000bd0a <__avr32_f64_add_opH_nan_or_inf>
8000bcbc:	0e 26       	rsub	r6,r7
8000bcbe:	c1 20       	breq	8000bce2 <__avr32_f64_add_shift_done>
8000bcc0:	e0 46 00 36 	cp.w	r6,54
8000bcc4:	c1 52       	brcc	8000bcee <__avr32_f64_add_res_of_done>
8000bcc6:	ec 05 11 20 	rsub	r5,r6,32
8000bcca:	e0 46 00 20 	cp.w	r6,32
8000bcce:	c3 52       	brcc	8000bd38 <__avr32_f64_add_longshift>
8000bcd0:	f0 05 09 4e 	lsl	lr,r8,r5
8000bcd4:	f2 05 09 45 	lsl	r5,r9,r5
8000bcd8:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcdc:	f2 06 0a 49 	lsr	r9,r9,r6
8000bce0:	0a 48       	or	r8,r5

8000bce2 <__avr32_f64_add_shift_done>:
8000bce2:	10 0a       	add	r10,r8
8000bce4:	f6 09 00 4b 	adc	r11,r11,r9
8000bce8:	ed bb 00 15 	bld	r11,0x15
8000bcec:	c3 40       	breq	8000bd54 <__avr32_f64_add_res_of>

8000bcee <__avr32_f64_add_res_of_done>:
8000bcee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bcf2:	18 4b       	or	r11,r12

8000bcf4 <__avr32_f64_add_round>:
8000bcf4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bcf8:	18 4e       	or	lr,r12
8000bcfa:	ee 1e 80 00 	eorh	lr,0x8000
8000bcfe:	f1 be 04 20 	satu	lr,0x1
8000bd02:	1c 0a       	add	r10,lr
8000bd04:	5c 0b       	acr	r11
8000bd06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd0a <__avr32_f64_add_opH_nan_or_inf>:
8000bd0a:	b5 cb       	cbr	r11,0x14
8000bd0c:	f7 ea 10 0e 	or	lr,r11,r10
8000bd10:	c1 01       	brne	8000bd30 <__avr32_f64_add_return_nan>
8000bd12:	e0 46 07 ff 	cp.w	r6,2047
8000bd16:	c0 30       	breq	8000bd1c <__avr32_f64_add_opL_nan_or_inf>
8000bd18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd1c <__avr32_f64_add_opL_nan_or_inf>:
8000bd1c:	b5 c9       	cbr	r9,0x14
8000bd1e:	f3 e8 10 0e 	or	lr,r9,r8
8000bd22:	c0 71       	brne	8000bd30 <__avr32_f64_add_return_nan>
8000bd24:	30 0a       	mov	r10,0
8000bd26:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bd2a:	18 4b       	or	r11,r12
8000bd2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd30 <__avr32_f64_add_return_nan>:
8000bd30:	3f fa       	mov	r10,-1
8000bd32:	3f fb       	mov	r11,-1
8000bd34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd38 <__avr32_f64_add_longshift>:
8000bd38:	f1 b6 04 c0 	satu	r6,0x6
8000bd3c:	f0 0e 17 00 	moveq	lr,r8
8000bd40:	c0 60       	breq	8000bd4c <__avr32_f64_add_longshift+0x14>
8000bd42:	f2 05 09 4e 	lsl	lr,r9,r5
8000bd46:	58 08       	cp.w	r8,0
8000bd48:	5f 18       	srne	r8
8000bd4a:	10 4e       	or	lr,r8
8000bd4c:	f2 06 0a 48 	lsr	r8,r9,r6
8000bd50:	30 09       	mov	r9,0
8000bd52:	cc 8b       	rjmp	8000bce2 <__avr32_f64_add_shift_done>

8000bd54 <__avr32_f64_add_res_of>:
8000bd54:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bd58:	a1 9b       	lsr	r11,0x1
8000bd5a:	5d 0a       	ror	r10
8000bd5c:	5d 0e       	ror	lr
8000bd5e:	2f f7       	sub	r7,-1
8000bd60:	e0 47 07 ff 	cp.w	r7,2047
8000bd64:	f9 ba 00 00 	moveq	r10,0
8000bd68:	f9 bb 00 00 	moveq	r11,0
8000bd6c:	f9 be 00 00 	moveq	lr,0
8000bd70:	cb fb       	rjmp	8000bcee <__avr32_f64_add_res_of_done>

8000bd72 <__avr32_f64_add_op2_subnormal>:
8000bd72:	30 16       	mov	r6,1
8000bd74:	58 07       	cp.w	r7,0
8000bd76:	ca 01       	brne	8000bcb6 <__avr32_f64_add+0x3e>
8000bd78:	b5 cb       	cbr	r11,0x14
8000bd7a:	10 0a       	add	r10,r8
8000bd7c:	f6 09 00 4b 	adc	r11,r11,r9
8000bd80:	18 4b       	or	r11,r12
8000bd82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bd86:	d7 03       	nop

8000bd88 <__avr32_f64_to_u32>:
8000bd88:	58 0b       	cp.w	r11,0
8000bd8a:	5e 6d       	retmi	0

8000bd8c <__avr32_f64_to_s32>:
8000bd8c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bd90:	b5 9c       	lsr	r12,0x15
8000bd92:	e0 2c 03 ff 	sub	r12,1023
8000bd96:	5e 3d       	retlo	0
8000bd98:	f8 0c 11 1f 	rsub	r12,r12,31
8000bd9c:	16 99       	mov	r9,r11
8000bd9e:	ab 7b       	lsl	r11,0xb
8000bda0:	bf bb       	sbr	r11,0x1f
8000bda2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bda6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bdaa:	a1 79       	lsl	r9,0x1
8000bdac:	5e 2b       	reths	r11
8000bdae:	5c 3b       	neg	r11
8000bdb0:	5e fb       	retal	r11

8000bdb2 <__avr32_u32_to_f64>:
8000bdb2:	f8 cb 00 00 	sub	r11,r12,0
8000bdb6:	30 0c       	mov	r12,0
8000bdb8:	c0 38       	rjmp	8000bdbe <__avr32_s32_to_f64+0x4>

8000bdba <__avr32_s32_to_f64>:
8000bdba:	18 9b       	mov	r11,r12
8000bdbc:	5c 4b       	abs	r11
8000bdbe:	30 0a       	mov	r10,0
8000bdc0:	5e 0b       	reteq	r11
8000bdc2:	d4 01       	pushm	lr
8000bdc4:	e0 69 04 1e 	mov	r9,1054
8000bdc8:	f6 08 12 00 	clz	r8,r11
8000bdcc:	c1 70       	breq	8000bdfa <__avr32_s32_to_f64+0x40>
8000bdce:	c0 c3       	brcs	8000bde6 <__avr32_s32_to_f64+0x2c>
8000bdd0:	f0 0e 11 20 	rsub	lr,r8,32
8000bdd4:	f6 08 09 4b 	lsl	r11,r11,r8
8000bdd8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bddc:	1c 4b       	or	r11,lr
8000bdde:	f4 08 09 4a 	lsl	r10,r10,r8
8000bde2:	10 19       	sub	r9,r8
8000bde4:	c0 b8       	rjmp	8000bdfa <__avr32_s32_to_f64+0x40>
8000bde6:	f4 08 12 00 	clz	r8,r10
8000bdea:	f9 b8 03 00 	movlo	r8,0
8000bdee:	f7 b8 02 e0 	subhs	r8,-32
8000bdf2:	f4 08 09 4b 	lsl	r11,r10,r8
8000bdf6:	30 0a       	mov	r10,0
8000bdf8:	10 19       	sub	r9,r8
8000bdfa:	58 09       	cp.w	r9,0
8000bdfc:	e0 89 00 30 	brgt	8000be5c <__avr32_s32_to_f64+0xa2>
8000be00:	5c 39       	neg	r9
8000be02:	2f f9       	sub	r9,-1
8000be04:	e0 49 00 36 	cp.w	r9,54
8000be08:	c0 43       	brcs	8000be10 <__avr32_s32_to_f64+0x56>
8000be0a:	30 0b       	mov	r11,0
8000be0c:	30 0a       	mov	r10,0
8000be0e:	c2 68       	rjmp	8000be5a <__avr32_s32_to_f64+0xa0>
8000be10:	2f 69       	sub	r9,-10
8000be12:	f2 08 11 20 	rsub	r8,r9,32
8000be16:	e0 49 00 20 	cp.w	r9,32
8000be1a:	c0 b2       	brcc	8000be30 <__avr32_s32_to_f64+0x76>
8000be1c:	f4 08 09 4e 	lsl	lr,r10,r8
8000be20:	f6 08 09 48 	lsl	r8,r11,r8
8000be24:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be28:	f6 09 0a 4b 	lsr	r11,r11,r9
8000be2c:	10 4b       	or	r11,r8
8000be2e:	c0 88       	rjmp	8000be3e <__avr32_s32_to_f64+0x84>
8000be30:	f6 08 09 4e 	lsl	lr,r11,r8
8000be34:	14 4e       	or	lr,r10
8000be36:	16 9a       	mov	r10,r11
8000be38:	30 0b       	mov	r11,0
8000be3a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be3e:	ed ba 00 00 	bld	r10,0x0
8000be42:	c0 92       	brcc	8000be54 <__avr32_s32_to_f64+0x9a>
8000be44:	1c 7e       	tst	lr,lr
8000be46:	c0 41       	brne	8000be4e <__avr32_s32_to_f64+0x94>
8000be48:	ed ba 00 01 	bld	r10,0x1
8000be4c:	c0 42       	brcc	8000be54 <__avr32_s32_to_f64+0x9a>
8000be4e:	2f fa       	sub	r10,-1
8000be50:	f7 bb 02 ff 	subhs	r11,-1
8000be54:	5c fc       	rol	r12
8000be56:	5d 0b       	ror	r11
8000be58:	5d 0a       	ror	r10
8000be5a:	d8 02       	popm	pc
8000be5c:	e0 68 03 ff 	mov	r8,1023
8000be60:	ed ba 00 0b 	bld	r10,0xb
8000be64:	f7 b8 00 ff 	subeq	r8,-1
8000be68:	10 0a       	add	r10,r8
8000be6a:	5c 0b       	acr	r11
8000be6c:	f7 b9 03 fe 	sublo	r9,-2
8000be70:	e0 49 07 ff 	cp.w	r9,2047
8000be74:	c0 55       	brlt	8000be7e <__avr32_s32_to_f64+0xc4>
8000be76:	30 0a       	mov	r10,0
8000be78:	fc 1b ff e0 	movh	r11,0xffe0
8000be7c:	c0 c8       	rjmp	8000be94 <__floatsidf_return_op1>
8000be7e:	ed bb 00 1f 	bld	r11,0x1f
8000be82:	f7 b9 01 01 	subne	r9,1
8000be86:	ab 9a       	lsr	r10,0xb
8000be88:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000be8c:	a1 7b       	lsl	r11,0x1
8000be8e:	ab 9b       	lsr	r11,0xb
8000be90:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000be94 <__floatsidf_return_op1>:
8000be94:	a1 7c       	lsl	r12,0x1
8000be96:	5d 0b       	ror	r11
8000be98:	d8 02       	popm	pc

8000be9a <__avr32_f64_cmp_eq>:
8000be9a:	10 3a       	cp.w	r10,r8
8000be9c:	f2 0b 13 00 	cpc	r11,r9
8000bea0:	c0 80       	breq	8000beb0 <__avr32_f64_cmp_eq+0x16>
8000bea2:	a1 7b       	lsl	r11,0x1
8000bea4:	a1 79       	lsl	r9,0x1
8000bea6:	14 4b       	or	r11,r10
8000bea8:	12 4b       	or	r11,r9
8000beaa:	10 4b       	or	r11,r8
8000beac:	5e 0f       	reteq	1
8000beae:	5e fd       	retal	0
8000beb0:	a1 7b       	lsl	r11,0x1
8000beb2:	fc 1c ff e0 	movh	r12,0xffe0
8000beb6:	58 0a       	cp.w	r10,0
8000beb8:	f8 0b 13 00 	cpc	r11,r12
8000bebc:	5e 8f       	retls	1
8000bebe:	5e fd       	retal	0

8000bec0 <__avr32_f64_cmp_ge>:
8000bec0:	1a de       	st.w	--sp,lr
8000bec2:	1a d7       	st.w	--sp,r7
8000bec4:	a1 7b       	lsl	r11,0x1
8000bec6:	5f 3c       	srlo	r12
8000bec8:	a1 79       	lsl	r9,0x1
8000beca:	5f 37       	srlo	r7
8000becc:	5c fc       	rol	r12
8000bece:	fc 1e ff e0 	movh	lr,0xffe0
8000bed2:	58 0a       	cp.w	r10,0
8000bed4:	fc 0b 13 00 	cpc	r11,lr
8000bed8:	e0 8b 00 1d 	brhi	8000bf12 <__avr32_f64_cmp_ge+0x52>
8000bedc:	58 08       	cp.w	r8,0
8000bede:	fc 09 13 00 	cpc	r9,lr
8000bee2:	e0 8b 00 18 	brhi	8000bf12 <__avr32_f64_cmp_ge+0x52>
8000bee6:	58 0b       	cp.w	r11,0
8000bee8:	f5 ba 00 00 	subfeq	r10,0
8000beec:	c1 50       	breq	8000bf16 <__avr32_f64_cmp_ge+0x56>
8000beee:	1b 07       	ld.w	r7,sp++
8000bef0:	1b 0e       	ld.w	lr,sp++
8000bef2:	58 3c       	cp.w	r12,3
8000bef4:	c0 a0       	breq	8000bf08 <__avr32_f64_cmp_ge+0x48>
8000bef6:	58 1c       	cp.w	r12,1
8000bef8:	c0 33       	brcs	8000befe <__avr32_f64_cmp_ge+0x3e>
8000befa:	5e 0f       	reteq	1
8000befc:	5e 1d       	retne	0
8000befe:	10 3a       	cp.w	r10,r8
8000bf00:	f2 0b 13 00 	cpc	r11,r9
8000bf04:	5e 2f       	reths	1
8000bf06:	5e 3d       	retlo	0
8000bf08:	14 38       	cp.w	r8,r10
8000bf0a:	f6 09 13 00 	cpc	r9,r11
8000bf0e:	5e 2f       	reths	1
8000bf10:	5e 3d       	retlo	0
8000bf12:	1b 07       	ld.w	r7,sp++
8000bf14:	d8 0a       	popm	pc,r12=0
8000bf16:	58 17       	cp.w	r7,1
8000bf18:	5f 0c       	sreq	r12
8000bf1a:	58 09       	cp.w	r9,0
8000bf1c:	f5 b8 00 00 	subfeq	r8,0
8000bf20:	1b 07       	ld.w	r7,sp++
8000bf22:	1b 0e       	ld.w	lr,sp++
8000bf24:	5e 0f       	reteq	1
8000bf26:	5e fc       	retal	r12

8000bf28 <__avr32_f64_cmp_lt>:
8000bf28:	1a de       	st.w	--sp,lr
8000bf2a:	1a d7       	st.w	--sp,r7
8000bf2c:	a1 7b       	lsl	r11,0x1
8000bf2e:	5f 3c       	srlo	r12
8000bf30:	a1 79       	lsl	r9,0x1
8000bf32:	5f 37       	srlo	r7
8000bf34:	5c fc       	rol	r12
8000bf36:	fc 1e ff e0 	movh	lr,0xffe0
8000bf3a:	58 0a       	cp.w	r10,0
8000bf3c:	fc 0b 13 00 	cpc	r11,lr
8000bf40:	e0 8b 00 1d 	brhi	8000bf7a <__avr32_f64_cmp_lt+0x52>
8000bf44:	58 08       	cp.w	r8,0
8000bf46:	fc 09 13 00 	cpc	r9,lr
8000bf4a:	e0 8b 00 18 	brhi	8000bf7a <__avr32_f64_cmp_lt+0x52>
8000bf4e:	58 0b       	cp.w	r11,0
8000bf50:	f5 ba 00 00 	subfeq	r10,0
8000bf54:	c1 50       	breq	8000bf7e <__avr32_f64_cmp_lt+0x56>
8000bf56:	1b 07       	ld.w	r7,sp++
8000bf58:	1b 0e       	ld.w	lr,sp++
8000bf5a:	58 3c       	cp.w	r12,3
8000bf5c:	c0 a0       	breq	8000bf70 <__avr32_f64_cmp_lt+0x48>
8000bf5e:	58 1c       	cp.w	r12,1
8000bf60:	c0 33       	brcs	8000bf66 <__avr32_f64_cmp_lt+0x3e>
8000bf62:	5e 0d       	reteq	0
8000bf64:	5e 1f       	retne	1
8000bf66:	10 3a       	cp.w	r10,r8
8000bf68:	f2 0b 13 00 	cpc	r11,r9
8000bf6c:	5e 2d       	reths	0
8000bf6e:	5e 3f       	retlo	1
8000bf70:	14 38       	cp.w	r8,r10
8000bf72:	f6 09 13 00 	cpc	r9,r11
8000bf76:	5e 2d       	reths	0
8000bf78:	5e 3f       	retlo	1
8000bf7a:	1b 07       	ld.w	r7,sp++
8000bf7c:	d8 0a       	popm	pc,r12=0
8000bf7e:	58 17       	cp.w	r7,1
8000bf80:	5f 1c       	srne	r12
8000bf82:	58 09       	cp.w	r9,0
8000bf84:	f5 b8 00 00 	subfeq	r8,0
8000bf88:	1b 07       	ld.w	r7,sp++
8000bf8a:	1b 0e       	ld.w	lr,sp++
8000bf8c:	5e 0d       	reteq	0
8000bf8e:	5e fc       	retal	r12

8000bf90 <__avr32_f64_div>:
8000bf90:	eb cd 40 ff 	pushm	r0-r7,lr
8000bf94:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf98:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf9c:	a9 7b       	lsl	r11,0x9
8000bf9e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bfa2:	a9 7a       	lsl	r10,0x9
8000bfa4:	bd bb       	sbr	r11,0x1d
8000bfa6:	e4 1b 3f ff 	andh	r11,0x3fff
8000bfaa:	ab d7       	cbr	r7,0xb
8000bfac:	e0 80 00 cc 	breq	8000c144 <__avr32_f64_div_round_subnormal+0x54>
8000bfb0:	e0 47 07 ff 	cp.w	r7,2047
8000bfb4:	e0 84 00 b5 	brge	8000c11e <__avr32_f64_div_round_subnormal+0x2e>
8000bfb8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfbc:	a9 79       	lsl	r9,0x9
8000bfbe:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bfc2:	a9 78       	lsl	r8,0x9
8000bfc4:	bd b9       	sbr	r9,0x1d
8000bfc6:	e4 19 3f ff 	andh	r9,0x3fff
8000bfca:	ab d6       	cbr	r6,0xb
8000bfcc:	e0 80 00 e2 	breq	8000c190 <__avr32_f64_div_round_subnormal+0xa0>
8000bfd0:	e0 46 07 ff 	cp.w	r6,2047
8000bfd4:	e0 84 00 b2 	brge	8000c138 <__avr32_f64_div_round_subnormal+0x48>
8000bfd8:	0c 17       	sub	r7,r6
8000bfda:	fe 37 fc 01 	sub	r7,-1023
8000bfde:	fc 1c 80 00 	movh	r12,0x8000
8000bfe2:	f8 03 16 01 	lsr	r3,r12,0x1
8000bfe6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bfea:	5c d4       	com	r4
8000bfec:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bff0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bff4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bff8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bffc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c000:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c004:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c008:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c00c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c010:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c014:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c018:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c01c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c020:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c024:	e4 09 07 40 	macu.d	r0,r2,r9
8000c028:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c02c:	02 04       	add	r4,r1
8000c02e:	5c 05       	acr	r5
8000c030:	a3 65       	lsl	r5,0x2
8000c032:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c036:	a3 64       	lsl	r4,0x2
8000c038:	5c 34       	neg	r4
8000c03a:	f8 05 01 45 	sbc	r5,r12,r5
8000c03e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c042:	e4 05 07 40 	macu.d	r0,r2,r5
8000c046:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c04a:	02 04       	add	r4,r1
8000c04c:	5c 05       	acr	r5
8000c04e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c052:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c056:	e8 02 15 02 	lsl	r2,r4,0x2
8000c05a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c05e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c062:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c066:	02 04       	add	r4,r1
8000c068:	5c 05       	acr	r5
8000c06a:	a3 65       	lsl	r5,0x2
8000c06c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c070:	a3 64       	lsl	r4,0x2
8000c072:	5c 34       	neg	r4
8000c074:	f8 05 01 45 	sbc	r5,r12,r5
8000c078:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c07c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c080:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c084:	02 04       	add	r4,r1
8000c086:	5c 05       	acr	r5
8000c088:	ea 03 15 02 	lsl	r3,r5,0x2
8000c08c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c090:	e8 02 15 02 	lsl	r2,r4,0x2
8000c094:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c098:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c09c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c0a0:	02 02       	add	r2,r1
8000c0a2:	5c 03       	acr	r3
8000c0a4:	ed b3 00 1c 	bld	r3,0x1c
8000c0a8:	c0 90       	breq	8000c0ba <__avr32_f64_div+0x12a>
8000c0aa:	a1 72       	lsl	r2,0x1
8000c0ac:	5c f3       	rol	r3
8000c0ae:	20 17       	sub	r7,1
8000c0b0:	a3 9a       	lsr	r10,0x3
8000c0b2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c0b6:	a3 9b       	lsr	r11,0x3
8000c0b8:	c0 58       	rjmp	8000c0c2 <__avr32_f64_div+0x132>
8000c0ba:	a5 8a       	lsr	r10,0x4
8000c0bc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c0c0:	a5 8b       	lsr	r11,0x4
8000c0c2:	58 07       	cp.w	r7,0
8000c0c4:	e0 8a 00 8b 	brle	8000c1da <__avr32_f64_div_res_subnormal>
8000c0c8:	e0 12 ff 00 	andl	r2,0xff00
8000c0cc:	e8 12 00 80 	orl	r2,0x80
8000c0d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c0dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c0e0:	00 05       	add	r5,r0
8000c0e2:	f0 01 00 48 	adc	r8,r8,r1
8000c0e6:	5c 09       	acr	r9
8000c0e8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c0ec:	58 04       	cp.w	r4,0
8000c0ee:	5c 25       	cpc	r5

8000c0f0 <__avr32_f64_div_round_subnormal>:
8000c0f0:	f4 08 13 00 	cpc	r8,r10
8000c0f4:	f6 09 13 00 	cpc	r9,r11
8000c0f8:	5f 36       	srlo	r6
8000c0fa:	f8 06 17 00 	moveq	r6,r12
8000c0fe:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c102:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c106:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c10a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c10e:	ed be 00 1f 	bld	lr,0x1f
8000c112:	ef bb 00 1f 	bst	r11,0x1f
8000c116:	0c 0a       	add	r10,r6
8000c118:	5c 0b       	acr	r11
8000c11a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c11e:	e4 1b 00 0f 	andh	r11,0xf
8000c122:	14 4b       	or	r11,r10
8000c124:	e0 81 00 a7 	brne	8000c272 <__avr32_f64_div_res_subnormal+0x98>
8000c128:	f2 06 16 14 	lsr	r6,r9,0x14
8000c12c:	ab d6       	cbr	r6,0xb
8000c12e:	e0 46 07 ff 	cp.w	r6,2047
8000c132:	e0 81 00 a4 	brne	8000c27a <__avr32_f64_div_res_subnormal+0xa0>
8000c136:	c9 e8       	rjmp	8000c272 <__avr32_f64_div_res_subnormal+0x98>
8000c138:	e4 19 00 0f 	andh	r9,0xf
8000c13c:	10 49       	or	r9,r8
8000c13e:	e0 81 00 9a 	brne	8000c272 <__avr32_f64_div_res_subnormal+0x98>
8000c142:	c9 28       	rjmp	8000c266 <__avr32_f64_div_res_subnormal+0x8c>
8000c144:	a3 7b       	lsl	r11,0x3
8000c146:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c14a:	a3 7a       	lsl	r10,0x3
8000c14c:	f5 eb 10 04 	or	r4,r10,r11
8000c150:	e0 80 00 a0 	breq	8000c290 <__avr32_f64_div_op1_zero>
8000c154:	f6 04 12 00 	clz	r4,r11
8000c158:	c1 70       	breq	8000c186 <__avr32_f64_div_round_subnormal+0x96>
8000c15a:	c0 c3       	brcs	8000c172 <__avr32_f64_div_round_subnormal+0x82>
8000c15c:	e8 05 11 20 	rsub	r5,r4,32
8000c160:	f6 04 09 4b 	lsl	r11,r11,r4
8000c164:	f4 05 0a 45 	lsr	r5,r10,r5
8000c168:	0a 4b       	or	r11,r5
8000c16a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c16e:	08 17       	sub	r7,r4
8000c170:	c0 b8       	rjmp	8000c186 <__avr32_f64_div_round_subnormal+0x96>
8000c172:	f4 04 12 00 	clz	r4,r10
8000c176:	f9 b4 03 00 	movlo	r4,0
8000c17a:	f7 b4 02 e0 	subhs	r4,-32
8000c17e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c182:	30 0a       	mov	r10,0
8000c184:	08 17       	sub	r7,r4
8000c186:	a3 8a       	lsr	r10,0x2
8000c188:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c18c:	a3 8b       	lsr	r11,0x2
8000c18e:	c1 1b       	rjmp	8000bfb0 <__avr32_f64_div+0x20>
8000c190:	a3 79       	lsl	r9,0x3
8000c192:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c196:	a3 78       	lsl	r8,0x3
8000c198:	f3 e8 10 04 	or	r4,r9,r8
8000c19c:	c6 f0       	breq	8000c27a <__avr32_f64_div_res_subnormal+0xa0>
8000c19e:	f2 04 12 00 	clz	r4,r9
8000c1a2:	c1 70       	breq	8000c1d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c1a4:	c0 c3       	brcs	8000c1bc <__avr32_f64_div_round_subnormal+0xcc>
8000c1a6:	e8 05 11 20 	rsub	r5,r4,32
8000c1aa:	f2 04 09 49 	lsl	r9,r9,r4
8000c1ae:	f0 05 0a 45 	lsr	r5,r8,r5
8000c1b2:	0a 49       	or	r9,r5
8000c1b4:	f0 04 09 48 	lsl	r8,r8,r4
8000c1b8:	08 16       	sub	r6,r4
8000c1ba:	c0 b8       	rjmp	8000c1d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c1bc:	f0 04 12 00 	clz	r4,r8
8000c1c0:	f9 b4 03 00 	movlo	r4,0
8000c1c4:	f7 b4 02 e0 	subhs	r4,-32
8000c1c8:	f0 04 09 49 	lsl	r9,r8,r4
8000c1cc:	30 08       	mov	r8,0
8000c1ce:	08 16       	sub	r6,r4
8000c1d0:	a3 88       	lsr	r8,0x2
8000c1d2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c1d6:	a3 89       	lsr	r9,0x2
8000c1d8:	cf ca       	rjmp	8000bfd0 <__avr32_f64_div+0x40>

8000c1da <__avr32_f64_div_res_subnormal>:
8000c1da:	5c 37       	neg	r7
8000c1dc:	2f f7       	sub	r7,-1
8000c1de:	f1 b7 04 c0 	satu	r7,0x6
8000c1e2:	e0 47 00 20 	cp.w	r7,32
8000c1e6:	c1 54       	brge	8000c210 <__avr32_f64_div_res_subnormal+0x36>
8000c1e8:	ee 06 11 20 	rsub	r6,r7,32
8000c1ec:	e4 07 0a 42 	lsr	r2,r2,r7
8000c1f0:	e6 06 09 4c 	lsl	r12,r3,r6
8000c1f4:	18 42       	or	r2,r12
8000c1f6:	e6 07 0a 43 	lsr	r3,r3,r7
8000c1fa:	f4 06 09 41 	lsl	r1,r10,r6
8000c1fe:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c202:	f6 06 09 4c 	lsl	r12,r11,r6
8000c206:	18 4a       	or	r10,r12
8000c208:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c20c:	30 00       	mov	r0,0
8000c20e:	c1 58       	rjmp	8000c238 <__avr32_f64_div_res_subnormal+0x5e>
8000c210:	ee 06 11 20 	rsub	r6,r7,32
8000c214:	f9 b0 00 00 	moveq	r0,0
8000c218:	f9 bc 00 00 	moveq	r12,0
8000c21c:	c0 50       	breq	8000c226 <__avr32_f64_div_res_subnormal+0x4c>
8000c21e:	f4 06 09 40 	lsl	r0,r10,r6
8000c222:	f6 06 09 4c 	lsl	r12,r11,r6
8000c226:	e6 07 0a 42 	lsr	r2,r3,r7
8000c22a:	30 03       	mov	r3,0
8000c22c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c230:	18 41       	or	r1,r12
8000c232:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c236:	30 0b       	mov	r11,0
8000c238:	e0 12 ff 00 	andl	r2,0xff00
8000c23c:	e8 12 00 80 	orl	r2,0x80
8000c240:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c244:	e4 09 07 46 	macu.d	r6,r2,r9
8000c248:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c24c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c250:	0c 05       	add	r5,r6
8000c252:	f0 07 00 48 	adc	r8,r8,r7
8000c256:	5c 09       	acr	r9
8000c258:	30 07       	mov	r7,0
8000c25a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c25e:	00 34       	cp.w	r4,r0
8000c260:	e2 05 13 00 	cpc	r5,r1
8000c264:	c4 6b       	rjmp	8000c0f0 <__avr32_f64_div_round_subnormal>
8000c266:	1c 9b       	mov	r11,lr
8000c268:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c26c:	30 0a       	mov	r10,0
8000c26e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c272:	3f fb       	mov	r11,-1
8000c274:	30 0a       	mov	r10,0
8000c276:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c27a:	f5 eb 10 04 	or	r4,r10,r11
8000c27e:	c0 90       	breq	8000c290 <__avr32_f64_div_op1_zero>
8000c280:	1c 9b       	mov	r11,lr
8000c282:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c286:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c28a:	30 0a       	mov	r10,0
8000c28c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c290 <__avr32_f64_div_op1_zero>:
8000c290:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c294:	ce f0       	breq	8000c272 <__avr32_f64_div_res_subnormal+0x98>
8000c296:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c29a:	e0 44 07 ff 	cp.w	r4,2047
8000c29e:	ce 41       	brne	8000c266 <__avr32_f64_div_res_subnormal+0x8c>
8000c2a0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c2a4:	ce 10       	breq	8000c266 <__avr32_f64_div_res_subnormal+0x8c>
8000c2a6:	ce 6b       	rjmp	8000c272 <__avr32_f64_div_res_subnormal+0x98>

8000c2a8 <__avr32_udiv64>:
8000c2a8:	d4 31       	pushm	r0-r7,lr
8000c2aa:	1a 97       	mov	r7,sp
8000c2ac:	20 3d       	sub	sp,12
8000c2ae:	10 9c       	mov	r12,r8
8000c2b0:	12 9e       	mov	lr,r9
8000c2b2:	14 93       	mov	r3,r10
8000c2b4:	58 09       	cp.w	r9,0
8000c2b6:	e0 81 00 bd 	brne	8000c430 <__avr32_udiv64+0x188>
8000c2ba:	16 38       	cp.w	r8,r11
8000c2bc:	e0 88 00 40 	brls	8000c33c <__avr32_udiv64+0x94>
8000c2c0:	f0 08 12 00 	clz	r8,r8
8000c2c4:	c0 d0       	breq	8000c2de <__avr32_udiv64+0x36>
8000c2c6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c2ca:	f0 09 11 20 	rsub	r9,r8,32
8000c2ce:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2d2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c2d6:	f4 08 09 43 	lsl	r3,r10,r8
8000c2da:	f3 eb 10 0b 	or	r11,r9,r11
8000c2de:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c2e2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c2e6:	f6 0e 0d 00 	divu	r0,r11,lr
8000c2ea:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c2ee:	00 99       	mov	r9,r0
8000c2f0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c2f4:	e0 0a 02 48 	mul	r8,r0,r10
8000c2f8:	10 3b       	cp.w	r11,r8
8000c2fa:	c0 a2       	brcc	8000c30e <__avr32_udiv64+0x66>
8000c2fc:	20 19       	sub	r9,1
8000c2fe:	18 0b       	add	r11,r12
8000c300:	18 3b       	cp.w	r11,r12
8000c302:	c0 63       	brcs	8000c30e <__avr32_udiv64+0x66>
8000c304:	10 3b       	cp.w	r11,r8
8000c306:	f7 b9 03 01 	sublo	r9,1
8000c30a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c30e:	f6 08 01 01 	sub	r1,r11,r8
8000c312:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c316:	e2 0e 0d 00 	divu	r0,r1,lr
8000c31a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c31e:	00 98       	mov	r8,r0
8000c320:	e0 0a 02 4a 	mul	r10,r0,r10
8000c324:	14 33       	cp.w	r3,r10
8000c326:	c0 82       	brcc	8000c336 <__avr32_udiv64+0x8e>
8000c328:	20 18       	sub	r8,1
8000c32a:	18 03       	add	r3,r12
8000c32c:	18 33       	cp.w	r3,r12
8000c32e:	c0 43       	brcs	8000c336 <__avr32_udiv64+0x8e>
8000c330:	14 33       	cp.w	r3,r10
8000c332:	f7 b8 03 01 	sublo	r8,1
8000c336:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c33a:	cd f8       	rjmp	8000c4f8 <__avr32_udiv64+0x250>
8000c33c:	58 08       	cp.w	r8,0
8000c33e:	c0 51       	brne	8000c348 <__avr32_udiv64+0xa0>
8000c340:	30 19       	mov	r9,1
8000c342:	f2 08 0d 08 	divu	r8,r9,r8
8000c346:	10 9c       	mov	r12,r8
8000c348:	f8 06 12 00 	clz	r6,r12
8000c34c:	c0 41       	brne	8000c354 <__avr32_udiv64+0xac>
8000c34e:	18 1b       	sub	r11,r12
8000c350:	30 19       	mov	r9,1
8000c352:	c4 08       	rjmp	8000c3d2 <__avr32_udiv64+0x12a>
8000c354:	ec 01 11 20 	rsub	r1,r6,32
8000c358:	f4 01 0a 49 	lsr	r9,r10,r1
8000c35c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c360:	f6 06 09 48 	lsl	r8,r11,r6
8000c364:	f6 01 0a 41 	lsr	r1,r11,r1
8000c368:	f3 e8 10 08 	or	r8,r9,r8
8000c36c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c370:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c374:	e2 03 0d 00 	divu	r0,r1,r3
8000c378:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c37c:	00 9e       	mov	lr,r0
8000c37e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c382:	e0 05 02 49 	mul	r9,r0,r5
8000c386:	12 3b       	cp.w	r11,r9
8000c388:	c0 a2       	brcc	8000c39c <__avr32_udiv64+0xf4>
8000c38a:	20 1e       	sub	lr,1
8000c38c:	18 0b       	add	r11,r12
8000c38e:	18 3b       	cp.w	r11,r12
8000c390:	c0 63       	brcs	8000c39c <__avr32_udiv64+0xf4>
8000c392:	12 3b       	cp.w	r11,r9
8000c394:	f7 be 03 01 	sublo	lr,1
8000c398:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c39c:	12 1b       	sub	r11,r9
8000c39e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c3a2:	f6 03 0d 02 	divu	r2,r11,r3
8000c3a6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c3aa:	04 99       	mov	r9,r2
8000c3ac:	e4 05 02 4b 	mul	r11,r2,r5
8000c3b0:	16 38       	cp.w	r8,r11
8000c3b2:	c0 a2       	brcc	8000c3c6 <__avr32_udiv64+0x11e>
8000c3b4:	20 19       	sub	r9,1
8000c3b6:	18 08       	add	r8,r12
8000c3b8:	18 38       	cp.w	r8,r12
8000c3ba:	c0 63       	brcs	8000c3c6 <__avr32_udiv64+0x11e>
8000c3bc:	16 38       	cp.w	r8,r11
8000c3be:	f7 b9 03 01 	sublo	r9,1
8000c3c2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c3c6:	f4 06 09 43 	lsl	r3,r10,r6
8000c3ca:	f0 0b 01 0b 	sub	r11,r8,r11
8000c3ce:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c3d2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c3d6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c3da:	f6 06 0d 00 	divu	r0,r11,r6
8000c3de:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c3e2:	00 9a       	mov	r10,r0
8000c3e4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c3e8:	e0 0e 02 48 	mul	r8,r0,lr
8000c3ec:	10 3b       	cp.w	r11,r8
8000c3ee:	c0 a2       	brcc	8000c402 <__avr32_udiv64+0x15a>
8000c3f0:	20 1a       	sub	r10,1
8000c3f2:	18 0b       	add	r11,r12
8000c3f4:	18 3b       	cp.w	r11,r12
8000c3f6:	c0 63       	brcs	8000c402 <__avr32_udiv64+0x15a>
8000c3f8:	10 3b       	cp.w	r11,r8
8000c3fa:	f7 ba 03 01 	sublo	r10,1
8000c3fe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c402:	f6 08 01 01 	sub	r1,r11,r8
8000c406:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c40a:	e2 06 0d 00 	divu	r0,r1,r6
8000c40e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c412:	00 98       	mov	r8,r0
8000c414:	e0 0e 02 4b 	mul	r11,r0,lr
8000c418:	16 33       	cp.w	r3,r11
8000c41a:	c0 82       	brcc	8000c42a <__avr32_udiv64+0x182>
8000c41c:	20 18       	sub	r8,1
8000c41e:	18 03       	add	r3,r12
8000c420:	18 33       	cp.w	r3,r12
8000c422:	c0 43       	brcs	8000c42a <__avr32_udiv64+0x182>
8000c424:	16 33       	cp.w	r3,r11
8000c426:	f7 b8 03 01 	sublo	r8,1
8000c42a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c42e:	c6 98       	rjmp	8000c500 <__avr32_udiv64+0x258>
8000c430:	16 39       	cp.w	r9,r11
8000c432:	e0 8b 00 65 	brhi	8000c4fc <__avr32_udiv64+0x254>
8000c436:	f2 09 12 00 	clz	r9,r9
8000c43a:	c0 b1       	brne	8000c450 <__avr32_udiv64+0x1a8>
8000c43c:	10 3a       	cp.w	r10,r8
8000c43e:	5f 2a       	srhs	r10
8000c440:	1c 3b       	cp.w	r11,lr
8000c442:	5f b8       	srhi	r8
8000c444:	10 4a       	or	r10,r8
8000c446:	f2 0a 18 00 	cp.b	r10,r9
8000c44a:	c5 90       	breq	8000c4fc <__avr32_udiv64+0x254>
8000c44c:	30 18       	mov	r8,1
8000c44e:	c5 98       	rjmp	8000c500 <__avr32_udiv64+0x258>
8000c450:	f0 09 09 46 	lsl	r6,r8,r9
8000c454:	f2 03 11 20 	rsub	r3,r9,32
8000c458:	fc 09 09 4e 	lsl	lr,lr,r9
8000c45c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c460:	f6 09 09 4c 	lsl	r12,r11,r9
8000c464:	f4 03 0a 42 	lsr	r2,r10,r3
8000c468:	ef 46 ff f4 	st.w	r7[-12],r6
8000c46c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c470:	18 42       	or	r2,r12
8000c472:	f1 ee 10 0c 	or	r12,r8,lr
8000c476:	f8 01 16 10 	lsr	r1,r12,0x10
8000c47a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c47e:	e6 01 0d 04 	divu	r4,r3,r1
8000c482:	e4 03 16 10 	lsr	r3,r2,0x10
8000c486:	08 9e       	mov	lr,r4
8000c488:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c48c:	e8 06 02 48 	mul	r8,r4,r6
8000c490:	10 33       	cp.w	r3,r8
8000c492:	c0 a2       	brcc	8000c4a6 <__avr32_udiv64+0x1fe>
8000c494:	20 1e       	sub	lr,1
8000c496:	18 03       	add	r3,r12
8000c498:	18 33       	cp.w	r3,r12
8000c49a:	c0 63       	brcs	8000c4a6 <__avr32_udiv64+0x1fe>
8000c49c:	10 33       	cp.w	r3,r8
8000c49e:	f7 be 03 01 	sublo	lr,1
8000c4a2:	e7 dc e3 03 	addcs	r3,r3,r12
8000c4a6:	10 13       	sub	r3,r8
8000c4a8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c4ac:	e6 01 0d 00 	divu	r0,r3,r1
8000c4b0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c4b4:	00 98       	mov	r8,r0
8000c4b6:	e0 06 02 46 	mul	r6,r0,r6
8000c4ba:	0c 3b       	cp.w	r11,r6
8000c4bc:	c0 a2       	brcc	8000c4d0 <__avr32_udiv64+0x228>
8000c4be:	20 18       	sub	r8,1
8000c4c0:	18 0b       	add	r11,r12
8000c4c2:	18 3b       	cp.w	r11,r12
8000c4c4:	c0 63       	brcs	8000c4d0 <__avr32_udiv64+0x228>
8000c4c6:	0c 3b       	cp.w	r11,r6
8000c4c8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4cc:	f7 b8 03 01 	sublo	r8,1
8000c4d0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c4d4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c4d8:	0c 1b       	sub	r11,r6
8000c4da:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c4de:	06 95       	mov	r5,r3
8000c4e0:	16 35       	cp.w	r5,r11
8000c4e2:	e0 8b 00 0a 	brhi	8000c4f6 <__avr32_udiv64+0x24e>
8000c4e6:	5f 0b       	sreq	r11
8000c4e8:	f4 09 09 49 	lsl	r9,r10,r9
8000c4ec:	12 32       	cp.w	r2,r9
8000c4ee:	5f b9       	srhi	r9
8000c4f0:	f7 e9 00 09 	and	r9,r11,r9
8000c4f4:	c0 60       	breq	8000c500 <__avr32_udiv64+0x258>
8000c4f6:	20 18       	sub	r8,1
8000c4f8:	30 09       	mov	r9,0
8000c4fa:	c0 38       	rjmp	8000c500 <__avr32_udiv64+0x258>
8000c4fc:	30 09       	mov	r9,0
8000c4fe:	12 98       	mov	r8,r9
8000c500:	10 9a       	mov	r10,r8
8000c502:	12 93       	mov	r3,r9
8000c504:	10 92       	mov	r2,r8
8000c506:	12 9b       	mov	r11,r9
8000c508:	2f dd       	sub	sp,-12
8000c50a:	d8 32       	popm	r0-r7,pc

8000c50c <__avr32_umod64>:
8000c50c:	d4 31       	pushm	r0-r7,lr
8000c50e:	1a 97       	mov	r7,sp
8000c510:	20 3d       	sub	sp,12
8000c512:	10 9c       	mov	r12,r8
8000c514:	12 95       	mov	r5,r9
8000c516:	14 9e       	mov	lr,r10
8000c518:	16 91       	mov	r1,r11
8000c51a:	16 96       	mov	r6,r11
8000c51c:	58 09       	cp.w	r9,0
8000c51e:	e0 81 00 81 	brne	8000c620 <__avr32_umod64+0x114>
8000c522:	16 38       	cp.w	r8,r11
8000c524:	e0 88 00 12 	brls	8000c548 <__avr32_umod64+0x3c>
8000c528:	f0 08 12 00 	clz	r8,r8
8000c52c:	c4 e0       	breq	8000c5c8 <__avr32_umod64+0xbc>
8000c52e:	f6 08 09 46 	lsl	r6,r11,r8
8000c532:	f8 08 09 4c 	lsl	r12,r12,r8
8000c536:	f0 0b 11 20 	rsub	r11,r8,32
8000c53a:	f4 08 09 4e 	lsl	lr,r10,r8
8000c53e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c542:	f7 e6 10 06 	or	r6,r11,r6
8000c546:	c4 18       	rjmp	8000c5c8 <__avr32_umod64+0xbc>
8000c548:	58 08       	cp.w	r8,0
8000c54a:	c0 51       	brne	8000c554 <__avr32_umod64+0x48>
8000c54c:	30 19       	mov	r9,1
8000c54e:	f2 08 0d 08 	divu	r8,r9,r8
8000c552:	10 9c       	mov	r12,r8
8000c554:	f8 08 12 00 	clz	r8,r12
8000c558:	c0 31       	brne	8000c55e <__avr32_umod64+0x52>
8000c55a:	18 16       	sub	r6,r12
8000c55c:	c3 68       	rjmp	8000c5c8 <__avr32_umod64+0xbc>
8000c55e:	f0 03 11 20 	rsub	r3,r8,32
8000c562:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c566:	f8 08 09 4c 	lsl	r12,r12,r8
8000c56a:	ec 08 09 49 	lsl	r9,r6,r8
8000c56e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c572:	f7 e9 10 09 	or	r9,r11,r9
8000c576:	f8 05 16 10 	lsr	r5,r12,0x10
8000c57a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c57e:	e6 05 0d 02 	divu	r2,r3,r5
8000c582:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c586:	ec 02 02 4b 	mul	r11,r6,r2
8000c58a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c58e:	16 3e       	cp.w	lr,r11
8000c590:	c0 72       	brcc	8000c59e <__avr32_umod64+0x92>
8000c592:	18 0e       	add	lr,r12
8000c594:	18 3e       	cp.w	lr,r12
8000c596:	c0 43       	brcs	8000c59e <__avr32_umod64+0x92>
8000c598:	16 3e       	cp.w	lr,r11
8000c59a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c59e:	fc 0b 01 03 	sub	r3,lr,r11
8000c5a2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c5a6:	e6 05 0d 02 	divu	r2,r3,r5
8000c5aa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c5ae:	a5 36       	mul	r6,r2
8000c5b0:	0c 39       	cp.w	r9,r6
8000c5b2:	c0 72       	brcc	8000c5c0 <__avr32_umod64+0xb4>
8000c5b4:	18 09       	add	r9,r12
8000c5b6:	18 39       	cp.w	r9,r12
8000c5b8:	c0 43       	brcs	8000c5c0 <__avr32_umod64+0xb4>
8000c5ba:	0c 39       	cp.w	r9,r6
8000c5bc:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5c0:	f2 06 01 06 	sub	r6,r9,r6
8000c5c4:	f4 08 09 4e 	lsl	lr,r10,r8
8000c5c8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c5cc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c5d0:	ec 0a 0d 02 	divu	r2,r6,r10
8000c5d4:	fc 09 16 10 	lsr	r9,lr,0x10
8000c5d8:	ea 02 02 4b 	mul	r11,r5,r2
8000c5dc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c5e0:	16 39       	cp.w	r9,r11
8000c5e2:	c0 72       	brcc	8000c5f0 <__avr32_umod64+0xe4>
8000c5e4:	18 09       	add	r9,r12
8000c5e6:	18 39       	cp.w	r9,r12
8000c5e8:	c0 43       	brcs	8000c5f0 <__avr32_umod64+0xe4>
8000c5ea:	16 39       	cp.w	r9,r11
8000c5ec:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5f0:	f2 0b 01 0b 	sub	r11,r9,r11
8000c5f4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c5f8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c5fc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c600:	ea 0a 02 4a 	mul	r10,r5,r10
8000c604:	14 3e       	cp.w	lr,r10
8000c606:	c0 72       	brcc	8000c614 <__avr32_umod64+0x108>
8000c608:	18 0e       	add	lr,r12
8000c60a:	18 3e       	cp.w	lr,r12
8000c60c:	c0 43       	brcs	8000c614 <__avr32_umod64+0x108>
8000c60e:	14 3e       	cp.w	lr,r10
8000c610:	fd dc e3 0e 	addcs	lr,lr,r12
8000c614:	fc 0a 01 0a 	sub	r10,lr,r10
8000c618:	30 0b       	mov	r11,0
8000c61a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c61e:	c7 b8       	rjmp	8000c714 <__avr32_umod64+0x208>
8000c620:	16 39       	cp.w	r9,r11
8000c622:	e0 8b 00 79 	brhi	8000c714 <__avr32_umod64+0x208>
8000c626:	f2 09 12 00 	clz	r9,r9
8000c62a:	c1 21       	brne	8000c64e <__avr32_umod64+0x142>
8000c62c:	10 3a       	cp.w	r10,r8
8000c62e:	5f 2b       	srhs	r11
8000c630:	0a 31       	cp.w	r1,r5
8000c632:	5f ba       	srhi	r10
8000c634:	f7 ea 10 0a 	or	r10,r11,r10
8000c638:	f2 0a 18 00 	cp.b	r10,r9
8000c63c:	c0 60       	breq	8000c648 <__avr32_umod64+0x13c>
8000c63e:	fc 08 01 0c 	sub	r12,lr,r8
8000c642:	e2 05 01 46 	sbc	r6,r1,r5
8000c646:	18 9e       	mov	lr,r12
8000c648:	0c 9b       	mov	r11,r6
8000c64a:	1c 9a       	mov	r10,lr
8000c64c:	c6 48       	rjmp	8000c714 <__avr32_umod64+0x208>
8000c64e:	ea 09 09 4c 	lsl	r12,r5,r9
8000c652:	f2 06 11 20 	rsub	r6,r9,32
8000c656:	f6 09 09 4b 	lsl	r11,r11,r9
8000c65a:	f0 09 09 42 	lsl	r2,r8,r9
8000c65e:	ef 46 ff f4 	st.w	r7[-12],r6
8000c662:	f0 06 0a 48 	lsr	r8,r8,r6
8000c666:	18 48       	or	r8,r12
8000c668:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c66c:	f4 09 09 43 	lsl	r3,r10,r9
8000c670:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c674:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c678:	16 4a       	or	r10,r11
8000c67a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c67e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c682:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c686:	08 91       	mov	r1,r4
8000c688:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c68c:	e8 0e 02 46 	mul	r6,r4,lr
8000c690:	0c 3c       	cp.w	r12,r6
8000c692:	c0 a2       	brcc	8000c6a6 <__avr32_umod64+0x19a>
8000c694:	20 11       	sub	r1,1
8000c696:	10 0c       	add	r12,r8
8000c698:	10 3c       	cp.w	r12,r8
8000c69a:	c0 63       	brcs	8000c6a6 <__avr32_umod64+0x19a>
8000c69c:	0c 3c       	cp.w	r12,r6
8000c69e:	f7 b1 03 01 	sublo	r1,1
8000c6a2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c6a6:	0c 1c       	sub	r12,r6
8000c6a8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c6ac:	f8 0b 0d 04 	divu	r4,r12,r11
8000c6b0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c6b4:	08 96       	mov	r6,r4
8000c6b6:	e8 0e 02 4e 	mul	lr,r4,lr
8000c6ba:	1c 3b       	cp.w	r11,lr
8000c6bc:	c0 a2       	brcc	8000c6d0 <__avr32_umod64+0x1c4>
8000c6be:	20 16       	sub	r6,1
8000c6c0:	10 0b       	add	r11,r8
8000c6c2:	10 3b       	cp.w	r11,r8
8000c6c4:	c0 63       	brcs	8000c6d0 <__avr32_umod64+0x1c4>
8000c6c6:	1c 3b       	cp.w	r11,lr
8000c6c8:	f7 b6 03 01 	sublo	r6,1
8000c6cc:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c6d0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c6d4:	1c 1b       	sub	r11,lr
8000c6d6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c6da:	00 9e       	mov	lr,r0
8000c6dc:	02 9c       	mov	r12,r1
8000c6de:	16 3c       	cp.w	r12,r11
8000c6e0:	e0 8b 00 08 	brhi	8000c6f0 <__avr32_umod64+0x1e4>
8000c6e4:	5f 06       	sreq	r6
8000c6e6:	06 30       	cp.w	r0,r3
8000c6e8:	5f ba       	srhi	r10
8000c6ea:	ed ea 00 0a 	and	r10,r6,r10
8000c6ee:	c0 60       	breq	8000c6fa <__avr32_umod64+0x1ee>
8000c6f0:	fc 02 01 04 	sub	r4,lr,r2
8000c6f4:	f8 08 01 4c 	sbc	r12,r12,r8
8000c6f8:	08 9e       	mov	lr,r4
8000c6fa:	e6 0e 01 0a 	sub	r10,r3,lr
8000c6fe:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c702:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c706:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c70a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c70e:	f8 01 09 4c 	lsl	r12,r12,r1
8000c712:	18 4a       	or	r10,r12
8000c714:	2f dd       	sub	sp,-12
8000c716:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 24 	sub	pc,pc,28708

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c4 b1 	rcall	80005268 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c4 aa 	rcall	80005268 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c4 a3 	rcall	80005268 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c4 9c 	rcall	80005268 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
