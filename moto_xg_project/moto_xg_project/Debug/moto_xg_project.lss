
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ace0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000127c  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e27c  8000e27c  0000e67c  2**0
                  ALLOC
  6 .data         00000a40  00000004  8000e280  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a44  8000ecc0  0000f244  2**0
                  ALLOC
  8 .bss          00004988  00000a48  8000ecc0  0000f248  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000f244  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001720  00000000  00000000  0000f278  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 0000371f  00000000  00000000  00010998  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002dbf5  00000000  00000000  000140b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000076d3  00000000  00000000  00041cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000d8b7  00000000  00000000  0004937f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003e38  00000000  00000000  00056c38  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000080b5  00000000  00000000  0005aa70  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000f6d2  00000000  00000000  00062b25  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000017d8  00000000  00000000  000721f8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 88 	sub	pc,pc,-15480

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e bc       	mov	r12,-21
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 58       	sub	r8,-75
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6c 10       	ld.w	r0,r6[0x4]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 54       	eor	r4,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6f d4       	ld.w	r4,r7[0x74]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 62       	and	r2,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f d4       	ld.w	r4,r7[0x74]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 64       	and	r4,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6f d4       	ld.w	r4,r7[0x74]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6f d4       	ld.w	r4,r7[0x74]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6f d4       	ld.w	r4,r7[0x74]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6f d4       	ld.w	r4,r7[0x74]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6f d4       	ld.w	r4,r7[0x74]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d1 00       	acall	0x10
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6f d4       	ld.w	r4,r7[0x74]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d1 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d1 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d1 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6f d4       	ld.w	r4,r7[0x74]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d1 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d1 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d1 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d1 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d1 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d2 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 40       	acall	0x24

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d2 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6f d4       	ld.w	r4,r7[0x74]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d1 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d2 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	6f d4       	ld.w	r4,r7[0x74]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c0       	acall	0x2c
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d2 d0       	acall	0x2d
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 e0       	acall	0x2e
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	d2 f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	6f d4       	ld.w	r4,r7[0x74]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 59       	eor	r9,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d3 10       	acall	0x31
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	6f d4       	ld.w	r4,r7[0x74]
80002404:	00 00       	add	r0,r0
80002406:	0a 58       	eor	r8,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d3 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	6f d4       	ld.w	r4,r7[0x74]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 b0       	acall	0x3b
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	6f d4       	ld.w	r4,r7[0x74]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c0       	acall	0x3c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d3 d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	6f d4       	ld.w	r4,r7[0x74]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d4 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	6f d4       	ld.w	r4,r7[0x74]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 50       	acall	0x45
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	6f d4       	ld.w	r4,r7[0x74]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 60       	acall	0x46

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d4 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	6f d4       	ld.w	r4,r7[0x74]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 63       	and	r3,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d4 80       	acall	0x48
800025cc:	00 00       	add	r0,r0
800025ce:	0a 59       	eor	r9,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	6f d4       	ld.w	r4,r7[0x74]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d4 b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 00       	acall	0x50
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 30       	acall	0x53

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 40       	acall	0x54
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	6f d4       	ld.w	r4,r7[0x74]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	d5 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 80       	acall	0x58

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	6f d4       	ld.w	r4,r7[0x74]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b0       	acall	0x5b
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d5 c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d5 f0       	acall	0x5f
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	6f d4       	ld.w	r4,r7[0x74]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d5 fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 2f 	mcall	800027fc <app_cfg+0xc0>
80002744:	4a f8       	lddpc	r8,80002800 <app_cfg+0xc4>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4a f7       	lddpc	r7,80002804 <app_cfg+0xc8>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b 05       	lddpc	r5,80002808 <app_cfg+0xcc>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4a e4       	lddpc	r4,8000280c <app_cfg+0xd0>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c2 30       	breq	800027a0 <app_cfg+0x64>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c2 f0       	breq	800027bc <app_cfg+0x80>
80002760:	58 08       	cp.w	r8,0
80002762:	c4 61       	brne	800027ee <app_cfg+0xb2>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4a b8       	lddpc	r8,80002810 <app_cfg+0xd4>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4a 98       	lddpc	r8,80002814 <app_cfg+0xd8>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4a 78       	lddpc	r8,80002814 <app_cfg+0xd8>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 26 	mcall	80002818 <app_cfg+0xdc>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a 5c       	lddpc	r12,8000281c <app_cfg+0xe0>
8000278c:	f0 1f 00 25 	mcall	80002820 <app_cfg+0xe4>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c2 f8       	rjmp	800027ee <app_cfg+0xb2>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a 3c       	lddpc	r12,80002824 <app_cfg+0xe8>
8000279a:	f0 1f 00 22 	mcall	80002820 <app_cfg+0xe4>
8000279e:	c2 88       	rjmp	800027ee <app_cfg+0xb2>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027a0:	0b 88       	ld.ub	r8,r5[0x0]
800027a2:	58 08       	cp.w	r8,0
800027a4:	c0 60       	breq	800027b0 <app_cfg+0x74>
							
							OB_State = OB_WAITINGAPPTASK;
800027a6:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027a8:	4a 0c       	lddpc	r12,80002828 <app_cfg+0xec>
800027aa:	f0 1f 00 1e 	mcall	80002820 <app_cfg+0xe4>
800027ae:	c2 08       	rjmp	800027ee <app_cfg+0xb2>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027b0:	04 9a       	mov	r10,r2
800027b2:	02 9b       	mov	r11,r1
800027b4:	0c 9c       	mov	r12,r6
800027b6:	f0 1f 00 1e 	mcall	8000282c <app_cfg+0xf0>
800027ba:	c1 a8       	rjmp	800027ee <app_cfg+0xb2>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027bc:	68 0c       	ld.w	r12,r4[0x0]
800027be:	0c 99       	mov	r9,r6
800027c0:	e0 6a 0f a0 	mov	r10,4000
800027c4:	1a 9b       	mov	r11,sp
800027c6:	f0 1f 00 1b 	mcall	80002830 <app_cfg+0xf4>
800027ca:	58 1c       	cp.w	r12,1
800027cc:	c0 d1       	brne	800027e6 <app_cfg+0xaa>
					{
						if(data_ptr!=NULL){//Resend message
800027ce:	40 0c       	lddsp	r12,sp[0x0]
800027d0:	58 0c       	cp.w	r12,0
800027d2:	c0 a0       	breq	800027e6 <app_cfg+0xaa>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027d4:	04 9a       	mov	r10,r2
800027d6:	02 9b       	mov	r11,r1
800027d8:	f0 1f 00 15 	mcall	8000282c <app_cfg+0xf0>
							set_message_store(data_ptr);
800027dc:	49 68       	lddpc	r8,80002834 <app_cfg+0xf8>
800027de:	70 0c       	ld.w	r12,r8[0x0]
800027e0:	40 0b       	lddsp	r11,sp[0x0]
800027e2:	f0 1f 00 16 	mcall	80002838 <app_cfg+0xfc>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
800027e6:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
800027e8:	49 5c       	lddpc	r12,8000283c <app_cfg+0x100>
800027ea:	f0 1f 00 0e 	mcall	80002820 <app_cfg+0xe4>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ee:	e0 6b 0f a0 	mov	r11,4000
800027f2:	48 4c       	lddpc	r12,80002800 <app_cfg+0xc4>
800027f4:	f0 1f 00 13 	mcall	80002840 <app_cfg+0x104>
	}
800027f8:	ca fb       	rjmp	80002756 <app_cfg+0x1a>
800027fa:	00 00       	add	r0,r0
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	69 00       	ld.w	r0,r4[0x40]
80002800:	00 00       	add	r0,r0
80002802:	0a 4c       	or	r12,r5
80002804:	00 00       	add	r0,r0
80002806:	0a 5c       	eor	r12,r5
80002808:	00 00       	add	r0,r0
8000280a:	00 04       	add	r4,r0
8000280c:	00 00       	add	r0,r0
8000280e:	0b 6c       	ld.uh	r12,--r5
80002810:	00 00       	add	r0,r0
80002812:	0d 98       	ld.ub	r8,r6[0x1]
80002814:	00 00       	add	r0,r0
80002816:	0a 61       	and	r1,r5
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	40 48       	lddsp	r8,sp[0x10]
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	d6 08       	*unknown*
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	6f d4       	ld.w	r4,r7[0x74]
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	d6 1c       	*unknown*
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	d6 2c       	*unknown*
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	3f 10       	mov	r0,-15
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	61 90       	ld.w	r0,r0[0x64]
80002834:	00 00       	add	r0,r0
80002836:	0b 74       	ld.ub	r4,--r5
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	2b d8       	sub	r8,-67
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	d6 3c       	*unknown*
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	6a b0       	ld.w	r0,r5[0x2c]

80002844 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002844:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002848:	19 c7       	ld.ub	r7,r12[0x4]
8000284a:	19 d8       	ld.ub	r8,r12[0x5]
8000284c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002850:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002852:	48 dc       	lddpc	r12,80002884 <Phyuserinput_brdcst_func+0x40>
80002854:	f0 1f 00 0d 	mcall	80002888 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002858:	36 08       	mov	r8,96
8000285a:	f0 07 19 00 	cp.h	r7,r8
8000285e:	c1 11       	brne	80002880 <Phyuserinput_brdcst_func+0x3c>
80002860:	48 b8       	lddpc	r8,8000288c <Phyuserinput_brdcst_func+0x48>
80002862:	11 89       	ld.ub	r9,r8[0x0]
80002864:	30 18       	mov	r8,1
80002866:	f0 09 18 00 	cp.b	r9,r8
8000286a:	c0 b1       	brne	80002880 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
8000286c:	31 4b       	mov	r11,20
8000286e:	30 1c       	mov	r12,1
80002870:	f0 1f 00 08 	mcall	80002890 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
80002874:	e0 6c 03 20 	mov	r12,800
80002878:	f0 1f 00 07 	mcall	80002894 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
8000287c:	f0 1f 00 07 	mcall	80002898 <Phyuserinput_brdcst_func+0x54>
80002880:	e3 cd 80 80 	ldm	sp++,r7,pc
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	d6 4c       	*unknown*
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	6f d4       	ld.w	r4,r7[0x74]
8000288c:	00 00       	add	r0,r0
8000288e:	0a 61       	and	r1,r5
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	40 48       	lddsp	r8,sp[0x10]
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	6a 68       	ld.w	r8,r5[0x18]
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	50 1c       	stdsp	sp[0x4],r12

8000289c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000289c:	d4 21       	pushm	r4-r7,lr
8000289e:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028a0:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028a4:	0d 88       	ld.ub	r8,r6[0x0]
800028a6:	32 49       	mov	r9,36
800028a8:	f2 08 18 00 	cp.b	r8,r9
800028ac:	c2 91       	brne	800028fe <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028ae:	4a dc       	lddpc	r12,80002960 <DataSession_brdcst_func+0xc4>
800028b0:	f0 1f 00 2d 	mcall	80002964 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028b4:	0d a5       	ld.ub	r5,r6[0x2]
800028b6:	0d b8       	ld.ub	r8,r6[0x3]
800028b8:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028bc:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028be:	0d 98       	ld.ub	r8,r6[0x1]
800028c0:	1a d8       	st.w	--sp,r8
800028c2:	4a ac       	lddpc	r12,80002968 <DataSession_brdcst_func+0xcc>
800028c4:	f0 1f 00 28 	mcall	80002964 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028c8:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800028cc:	1a d8       	st.w	--sp,r8
800028ce:	4a 8c       	lddpc	r12,8000296c <DataSession_brdcst_func+0xd0>
800028d0:	f0 1f 00 25 	mcall	80002964 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800028d4:	2f ed       	sub	sp,-8
800028d6:	58 05       	cp.w	r5,0
800028d8:	c4 10       	breq	8000295a <DataSession_brdcst_func+0xbe>
800028da:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800028dc:	4a 54       	lddpc	r4,80002970 <DataSession_brdcst_func+0xd4>
800028de:	ec 07 00 08 	add	r8,r6,r7
800028e2:	11 c8       	ld.ub	r8,r8[0x4]
800028e4:	1a d8       	st.w	--sp,r8
800028e6:	1a d7       	st.w	--sp,r7
800028e8:	08 9c       	mov	r12,r4
800028ea:	f0 1f 00 1f 	mcall	80002964 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800028ee:	2f f7       	sub	r7,-1
800028f0:	5c 57       	castu.b	r7
800028f2:	2f ed       	sub	sp,-8
800028f4:	ee 05 19 00 	cp.h	r5,r7
800028f8:	fe 9b ff f3 	brhi	800028de <DataSession_brdcst_func+0x42>
800028fc:	c2 f8       	rjmp	8000295a <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
800028fe:	1a d8       	st.w	--sp,r8
80002900:	49 dc       	lddpc	r12,80002974 <DataSession_brdcst_func+0xd8>
80002902:	f0 1f 00 19 	mcall	80002964 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002906:	0d 88       	ld.ub	r8,r6[0x0]
80002908:	2f fd       	sub	sp,-4
8000290a:	30 39       	mov	r9,3
8000290c:	f2 08 18 00 	cp.b	r8,r9
80002910:	c0 51       	brne	8000291a <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002912:	49 ac       	lddpc	r12,80002978 <DataSession_brdcst_func+0xdc>
80002914:	f0 1f 00 14 	mcall	80002964 <DataSession_brdcst_func+0xc8>
80002918:	c2 18       	rjmp	8000295a <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000291a:	30 49       	mov	r9,4
8000291c:	f2 08 18 00 	cp.b	r8,r9
80002920:	c1 d1       	brne	8000295a <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002922:	32 0a       	mov	r10,32
80002924:	ec cb ff fc 	sub	r11,r6,-4
80002928:	1a 9c       	mov	r12,sp
8000292a:	f0 1f 00 15 	mcall	8000297c <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
8000292e:	49 58       	lddpc	r8,80002980 <DataSession_brdcst_func+0xe4>
80002930:	70 0c       	ld.w	r12,r8[0x0]
80002932:	f0 1f 00 15 	mcall	80002984 <DataSession_brdcst_func+0xe8>
80002936:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002938:	c0 e0       	breq	80002954 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000293a:	32 0a       	mov	r10,32
8000293c:	1a 9b       	mov	r11,sp
8000293e:	f0 1f 00 10 	mcall	8000297c <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002942:	49 28       	lddpc	r8,80002988 <DataSession_brdcst_func+0xec>
80002944:	70 0c       	ld.w	r12,r8[0x0]
80002946:	30 09       	mov	r9,0
80002948:	12 9a       	mov	r10,r9
8000294a:	fa cb ff e0 	sub	r11,sp,-32
8000294e:	f0 1f 00 10 	mcall	8000298c <DataSession_brdcst_func+0xf0>
80002952:	c0 48       	rjmp	8000295a <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002954:	48 fc       	lddpc	r12,80002990 <DataSession_brdcst_func+0xf4>
80002956:	f0 1f 00 04 	mcall	80002964 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000295a:	2f 7d       	sub	sp,-36
8000295c:	d8 22       	popm	r4-r7,pc
8000295e:	00 00       	add	r0,r0
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	d6 6c       	*unknown*
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	6f d4       	ld.w	r4,r7[0x74]
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	d6 80       	acall	0x68
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	d6 98       	*unknown*
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d6 b4       	*unknown*
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d6 cc       	*unknown*
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	d6 d8       	*unknown*
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	78 58       	ld.w	r8,r12[0x14]
80002980:	00 00       	add	r0,r0
80002982:	0b 74       	ld.ub	r4,--r5
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	2d 84       	sub	r4,-40
80002988:	00 00       	add	r0,r0
8000298a:	0b 6c       	ld.uh	r12,--r5
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	63 9c       	ld.w	r12,r1[0x64]
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	d6 f0       	acall	0x6f

80002994 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002994:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002996:	19 e8       	ld.ub	r8,r12[0x6]
80002998:	30 19       	mov	r9,1
8000299a:	f2 08 18 00 	cp.b	r8,r9
8000299e:	c0 61       	brne	800029aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029a0:	48 98       	lddpc	r8,800029c4 <DeviceInitializationStatus_brdcst_func+0x30>
800029a2:	70 09       	ld.w	r9,r8[0x0]
800029a4:	a1 a9       	sbr	r9,0x0
800029a6:	91 09       	st.w	r8[0x0],r9
800029a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029aa:	30 29       	mov	r9,2
800029ac:	f2 08 18 00 	cp.b	r8,r9
800029b0:	c0 80       	breq	800029c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029b2:	48 58       	lddpc	r8,800029c4 <DeviceInitializationStatus_brdcst_func+0x30>
800029b4:	70 09       	ld.w	r9,r8[0x0]
800029b6:	e0 19 ff fc 	andl	r9,0xfffc
800029ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029bc:	f0 1f 00 03 	mcall	800029c8 <DeviceInitializationStatus_brdcst_func+0x34>
800029c0:	d8 02       	popm	pc
800029c2:	00 00       	add	r0,r0
800029c4:	00 00       	add	r0,r0
800029c6:	0d 98       	ld.ub	r8,r6[0x1]
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	3f 9c       	mov	r12,-7

800029cc <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800029cc:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
800029ce:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800029d0:	30 0a       	mov	r10,0
800029d2:	32 8b       	mov	r11,40
800029d4:	49 5c       	lddpc	r12,80002a28 <xg_rtc_init+0x5c>
800029d6:	f0 1f 00 16 	mcall	80002a2c <xg_rtc_init+0x60>

	// Initialize the RTC
	if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
800029da:	30 fa       	mov	r10,15
800029dc:	30 0b       	mov	r11,0
800029de:	fe 7c 0d 00 	mov	r12,-62208
800029e2:	f0 1f 00 14 	mcall	80002a30 <xg_rtc_init+0x64>
800029e6:	c0 41       	brne	800029ee <xg_rtc_init+0x22>
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	{
		log("Error initializing the RTC\r\n");
800029e8:	49 3c       	lddpc	r12,80002a34 <xg_rtc_init+0x68>
800029ea:	f0 1f 00 14 	mcall	80002a38 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800029ee:	30 0b       	mov	r11,0
800029f0:	fe 7c 0d 00 	mov	r12,-62208
800029f4:	f0 1f 00 12 	mcall	80002a3c <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800029f8:	fe 7c 0d 00 	mov	r12,-62208
800029fc:	f0 1f 00 11 	mcall	80002a40 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002a00:	fe 7c 0d 00 	mov	r12,-62208
80002a04:	f0 1f 00 10 	mcall	80002a44 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002a08:	49 08       	lddpc	r8,80002a48 <xg_rtc_init+0x7c>
80002a0a:	31 09       	mov	r9,16
80002a0c:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002a0e:	30 29       	mov	r9,2
80002a10:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002a12:	31 d9       	mov	r9,29
80002a14:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a16:	31 79       	mov	r9,23
80002a18:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a1a:	33 b9       	mov	r9,59
80002a1c:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a1e:	32 89       	mov	r9,40
80002a20:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002a22:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a24:	d8 02       	popm	pc
80002a26:	00 00       	add	r0,r0
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	2a 4c       	sub	r12,-92
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	54 3c       	stdsp	sp[0x10c],r12
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	57 88       	stdsp	sp[0x1e0],r8
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	d7 00       	acall	0x70
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	6f d4       	ld.w	r4,r7[0x74]
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	57 44       	stdsp	sp[0x1d0],r4
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	57 3c       	stdsp	sp[0x1cc],r12
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	57 18       	stdsp	sp[0x1c4],r8
80002a48:	00 00       	add	r0,r0
80002a4a:	0d 9c       	ld.ub	r12,r6[0x1]

80002a4c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a4c:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a4e:	4b 98       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002a50:	11 d9       	ld.ub	r9,r8[0x5]
80002a52:	2f f9       	sub	r9,-1
80002a54:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a56:	11 d9       	ld.ub	r9,r8[0x5]
80002a58:	33 b8       	mov	r8,59
80002a5a:	f0 09 18 00 	cp.b	r9,r8
80002a5e:	e0 88 00 5f 	brls	80002b1c <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a62:	4b 48       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002a64:	30 09       	mov	r9,0
80002a66:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a68:	11 c9       	ld.ub	r9,r8[0x4]
80002a6a:	2f f9       	sub	r9,-1
80002a6c:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002a6e:	11 c9       	ld.ub	r9,r8[0x4]
80002a70:	33 b8       	mov	r8,59
80002a72:	f0 09 18 00 	cp.b	r9,r8
80002a76:	e0 88 00 53 	brls	80002b1c <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002a7a:	4a e8       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002a7c:	30 09       	mov	r9,0
80002a7e:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002a80:	11 b9       	ld.ub	r9,r8[0x3]
80002a82:	2f f9       	sub	r9,-1
80002a84:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002a86:	11 b9       	ld.ub	r9,r8[0x3]
80002a88:	31 78       	mov	r8,23
80002a8a:	f0 09 18 00 	cp.b	r9,r8
80002a8e:	e0 88 00 47 	brls	80002b1c <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002a92:	4a 88       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002a94:	30 09       	mov	r9,0
80002a96:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002a98:	11 88       	ld.ub	r8,r8[0x0]
80002a9a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002a9e:	e0 69 01 6e 	mov	r9,366
80002aa2:	e0 6a 01 6d 	mov	r10,365
80002aa6:	f4 08 17 10 	movne	r8,r10
80002aaa:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002aae:	4a 19       	lddpc	r9,80002b30 <rtc_irq+0xe4>
80002ab0:	13 9a       	ld.ub	r10,r9[0x1]
80002ab2:	30 29       	mov	r9,2
80002ab4:	f2 0a 18 00 	cp.b	r10,r9
80002ab8:	c0 b0       	breq	80002ace <rtc_irq+0x82>
80002aba:	49 e8       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002abc:	11 99       	ld.ub	r9,r8[0x1]
80002abe:	11 9a       	ld.ub	r10,r8[0x1]
80002ac0:	a3 9a       	lsr	r10,0x3
80002ac2:	12 0a       	add	r10,r9
80002ac4:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002ac8:	2e 2a       	sub	r10,-30
80002aca:	5c 5a       	castu.b	r10
80002acc:	c0 58       	rjmp	80002ad6 <rtc_irq+0x8a>
80002ace:	f0 c8 01 51 	sub	r8,r8,337
80002ad2:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002ad6:	49 78       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002ad8:	11 a9       	ld.ub	r9,r8[0x2]
80002ada:	2f f9       	sub	r9,-1
80002adc:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002ade:	11 a8       	ld.ub	r8,r8[0x2]
80002ae0:	f0 0a 18 00 	cp.b	r10,r8
80002ae4:	c1 c2       	brcc	80002b1c <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002ae6:	49 38       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002ae8:	30 19       	mov	r9,1
80002aea:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002aec:	11 99       	ld.ub	r9,r8[0x1]
80002aee:	2f f9       	sub	r9,-1
80002af0:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002af2:	11 99       	ld.ub	r9,r8[0x1]
80002af4:	30 c8       	mov	r8,12
80002af6:	f0 09 18 00 	cp.b	r9,r8
80002afa:	e0 88 00 11 	brls	80002b1c <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002afe:	48 d8       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002b00:	30 19       	mov	r9,1
80002b02:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002b04:	11 89       	ld.ub	r9,r8[0x0]
80002b06:	2f f9       	sub	r9,-1
80002b08:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002b0a:	11 89       	ld.ub	r9,r8[0x0]
80002b0c:	39 68       	mov	r8,-106
80002b0e:	f0 09 18 00 	cp.b	r9,r8
80002b12:	e0 88 00 05 	brls	80002b1c <rtc_irq+0xd0>
80002b16:	30 09       	mov	r9,0
80002b18:	48 68       	lddpc	r8,80002b30 <rtc_irq+0xe4>
80002b1a:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b1c:	fe 7c 0d 00 	mov	r12,-62208
80002b20:	f0 1f 00 05 	mcall	80002b34 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b24:	30 19       	mov	r9,1
80002b26:	48 58       	lddpc	r8,80002b38 <rtc_irq+0xec>
80002b28:	91 09       	st.w	r8[0x0],r9
}
80002b2a:	d4 02       	popm	lr
80002b2c:	d6 03       	rete
80002b2e:	00 00       	add	r0,r0
80002b30:	00 00       	add	r0,r0
80002b32:	0d 9c       	ld.ub	r12,r6[0x1]
80002b34:	80 00       	ld.sh	r0,r0[0x0]
80002b36:	57 68       	stdsp	sp[0x1d8],r8
80002b38:	00 00       	add	r0,r0
80002b3a:	04 f4       	st.b	--r2,r4

80002b3c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b3c:	20 1c       	sub	r12,1
80002b3e:	5c 5c       	castu.b	r12
80002b40:	31 18       	mov	r8,17
80002b42:	f0 0c 18 00 	cp.b	r12,r8
80002b46:	e0 88 00 03 	brls	80002b4c <CalculateBurst+0x10>
80002b4a:	5e fd       	retal	0
80002b4c:	48 28       	lddpc	r8,80002b54 <CalculateBurst+0x18>
80002b4e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b52:	5e fc       	retal	r12
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	d7 20       	acall	0x72

80002b58 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b58:	48 38       	lddpc	r8,80002b64 <payload_init+0xc>
80002b5a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b5c:	48 38       	lddpc	r8,80002b68 <payload_init+0x10>
80002b5e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b60:	5e fc       	retal	r12
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0a 6c       	and	r12,r5
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 70       	tst	r0,r5

80002b6c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002b6c:	d4 01       	pushm	lr
80002b6e:	20 2d       	sub	sp,8
80002b70:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b72:	30 09       	mov	r9,0
80002b74:	fa ca ff f8 	sub	r10,sp,-8
80002b78:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002b7a:	1a 9b       	mov	r11,sp
80002b7c:	f0 1f 00 02 	mcall	80002b84 <set_idle_store_isr+0x18>
}
80002b80:	2f ed       	sub	sp,-8
80002b82:	d8 02       	popm	pc
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	63 4c       	ld.w	r12,r1[0x50]

80002b88 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002b88:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002b8a:	48 48       	lddpc	r8,80002b98 <payload_rx+0x10>
80002b8c:	70 08       	ld.w	r8,r8[0x0]
80002b8e:	18 9b       	mov	r11,r12
80002b90:	10 9c       	mov	r12,r8
80002b92:	f0 1f 00 03 	mcall	80002b9c <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002b96:	d8 02       	popm	pc
80002b98:	00 00       	add	r0,r0
80002b9a:	0a a8       	st.w	r5++,r8
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	2b 6c       	sub	r12,-74

80002ba0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
80002ba4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002ba6:	58 0c       	cp.w	r12,0
80002ba8:	c1 10       	breq	80002bca <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002baa:	30 08       	mov	r8,0
80002bac:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002bae:	98 88       	ld.uh	r8,r12[0x0]
80002bb0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002bb4:	e0 48 40 00 	cp.w	r8,16384
80002bb8:	c0 91       	brne	80002bca <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bba:	48 68       	lddpc	r8,80002bd0 <phy_rx+0x30>
80002bbc:	70 0c       	ld.w	r12,r8[0x0]
80002bbe:	30 09       	mov	r9,0
80002bc0:	fa ca ff fc 	sub	r10,sp,-4
80002bc4:	1a 9b       	mov	r11,sp
80002bc6:	f0 1f 00 04 	mcall	80002bd4 <phy_rx+0x34>
		}	

    }
		
 
}
80002bca:	2f ed       	sub	sp,-8
80002bcc:	d8 02       	popm	pc
80002bce:	00 00       	add	r0,r0
80002bd0:	00 00       	add	r0,r0
80002bd2:	0a b4       	st.h	r5++,r4
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	63 4c       	ld.w	r12,r1[0x50]

80002bd8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002bd8:	eb cd 40 80 	pushm	r7,lr
80002bdc:	20 1d       	sub	sp,4
80002bde:	fa c7 ff fc 	sub	r7,sp,-4
80002be2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002be4:	30 09       	mov	r9,0
80002be6:	12 9a       	mov	r10,r9
80002be8:	1a 9b       	mov	r11,sp
80002bea:	f0 1f 00 03 	mcall	80002bf4 <set_idle_store+0x1c>
}
80002bee:	2f fd       	sub	sp,-4
80002bf0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	63 9c       	ld.w	r12,r1[0x64]

80002bf8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002bf8:	d4 01       	pushm	lr
80002bfa:	20 1d       	sub	sp,4
80002bfc:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002bfe:	98 88       	ld.uh	r8,r12[0x0]
80002c00:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c04:	e0 48 40 00 	cp.w	r8,16384
80002c08:	c0 d1       	brne	80002c22 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c0a:	49 08       	lddpc	r8,80002c48 <phy_tx+0x50>
80002c0c:	70 08       	ld.w	r8,r8[0x0]
80002c0e:	58 08       	cp.w	r8,0
80002c10:	c1 a0       	breq	80002c44 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c12:	48 e8       	lddpc	r8,80002c48 <phy_tx+0x50>
80002c14:	70 0c       	ld.w	r12,r8[0x0]
80002c16:	30 09       	mov	r9,0
80002c18:	12 9a       	mov	r10,r9
80002c1a:	1a 9b       	mov	r11,sp
80002c1c:	f0 1f 00 0c 	mcall	80002c4c <phy_tx+0x54>
80002c20:	c1 28       	rjmp	80002c44 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c22:	e0 48 10 00 	cp.w	r8,4096
80002c26:	5f 0a       	sreq	r10
80002c28:	e0 48 20 00 	cp.w	r8,8192
80002c2c:	5f 09       	sreq	r9
80002c2e:	f5 e9 10 09 	or	r9,r10,r9
80002c32:	c0 71       	brne	80002c40 <phy_tx+0x48>
80002c34:	e0 48 50 00 	cp.w	r8,20480
80002c38:	c0 40       	breq	80002c40 <phy_tx+0x48>
80002c3a:	e0 48 60 00 	cp.w	r8,24576
80002c3e:	c0 31       	brne	80002c44 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c40:	48 48       	lddpc	r8,80002c50 <phy_tx+0x58>
80002c42:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c44:	2f fd       	sub	sp,-4
80002c46:	d8 02       	popm	pc
80002c48:	00 00       	add	r0,r0
80002c4a:	0a d4       	st.w	--r5,r4
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	63 9c       	ld.w	r12,r1[0x64]
80002c50:	00 00       	add	r0,r0
80002c52:	0a c8       	st.b	r5++,r8

80002c54 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c54:	d4 01       	pushm	lr
80002c56:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c58:	30 08       	mov	r8,0
80002c5a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c5c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c5e:	1a 9a       	mov	r10,sp
80002c60:	fa cb ff fc 	sub	r11,sp,-4
80002c64:	f0 1f 00 05 	mcall	80002c78 <get_idle_store_isr+0x24>
80002c68:	58 1c       	cp.w	r12,1
80002c6a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c6e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002c72:	2f ed       	sub	sp,-8
80002c74:	d8 02       	popm	pc
80002c76:	00 00       	add	r0,r0
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	60 a0       	ld.w	r0,r0[0x28]

80002c7c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002c7c:	eb cd 40 c0 	pushm	r6-r7,lr
80002c80:	20 1d       	sub	sp,4
80002c82:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002c84:	4b a8       	lddpc	r8,80002d6c <phy_tx_func+0xf0>
80002c86:	70 08       	ld.w	r8,r8[0x0]
80002c88:	58 08       	cp.w	r8,0
80002c8a:	c6 60       	breq	80002d56 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002c8c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c8e:	30 08       	mov	r8,0
80002c90:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002c92:	4b 88       	lddpc	r8,80002d70 <phy_tx_func+0xf4>
80002c94:	70 08       	ld.w	r8,r8[0x0]
80002c96:	58 18       	cp.w	r8,1
80002c98:	c2 60       	breq	80002ce4 <phy_tx_func+0x68>
80002c9a:	c0 43       	brcs	80002ca2 <phy_tx_func+0x26>
80002c9c:	58 28       	cp.w	r8,2
80002c9e:	c5 c1       	brne	80002d56 <phy_tx_func+0xda>
80002ca0:	c5 58       	rjmp	80002d4a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ca2:	4b 38       	lddpc	r8,80002d6c <phy_tx_func+0xf0>
80002ca4:	70 0c       	ld.w	r12,r8[0x0]
80002ca6:	1a 9a       	mov	r10,sp
80002ca8:	4b 3b       	lddpc	r11,80002d74 <phy_tx_func+0xf8>
80002caa:	f0 1f 00 34 	mcall	80002d78 <phy_tx_func+0xfc>
80002cae:	58 1c       	cp.w	r12,1
80002cb0:	c1 41       	brne	80002cd8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002cb2:	4b 18       	lddpc	r8,80002d74 <phy_tx_func+0xf8>
80002cb4:	70 08       	ld.w	r8,r8[0x0]
80002cb6:	90 08       	ld.sh	r8,r8[0x0]
80002cb8:	10 9a       	mov	r10,r8
80002cba:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cbe:	4b 09       	lddpc	r9,80002d7c <phy_tx_func+0x100>
80002cc0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cc2:	5c 78       	castu.h	r8
80002cc4:	ea 18 ab cd 	orh	r8,0xabcd
80002cc8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cca:	30 19       	mov	r9,1
80002ccc:	4a d8       	lddpc	r8,80002d80 <phy_tx_func+0x104>
80002cce:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002cd0:	30 19       	mov	r9,1
80002cd2:	4a 88       	lddpc	r8,80002d70 <phy_tx_func+0xf4>
80002cd4:	91 09       	st.w	r8[0x0],r9
80002cd6:	c4 08       	rjmp	80002d56 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002cd8:	e0 68 5a 5a 	mov	r8,23130
80002cdc:	ea 18 ab cd 	orh	r8,0xabcd
80002ce0:	8f 18       	st.w	r7[0x4],r8
80002ce2:	c3 a8       	rjmp	80002d56 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ce4:	4a 7a       	lddpc	r10,80002d80 <phy_tx_func+0x104>
80002ce6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ce8:	4a 39       	lddpc	r9,80002d74 <phy_tx_func+0xf8>
80002cea:	72 09       	ld.w	r9,r9[0x0]
80002cec:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002cf0:	b1 69       	lsl	r9,0x10
80002cf2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002cf4:	2f f8       	sub	r8,-1
80002cf6:	5c 58       	castu.b	r8
80002cf8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002cfa:	4a 1b       	lddpc	r11,80002d7c <phy_tx_func+0x100>
80002cfc:	96 0c       	ld.sh	r12,r11[0x0]
80002cfe:	20 2c       	sub	r12,2
80002d00:	5c 8c       	casts.h	r12
80002d02:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d06:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d08:	30 0b       	mov	r11,0
80002d0a:	f6 0a 19 00 	cp.h	r10,r11
80002d0e:	e0 89 00 09 	brgt	80002d20 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d12:	e8 19 00 ba 	orl	r9,0xba
80002d16:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d18:	30 09       	mov	r9,0
80002d1a:	49 68       	lddpc	r8,80002d70 <phy_tx_func+0xf4>
80002d1c:	91 09       	st.w	r8[0x0],r9
80002d1e:	c1 c8       	rjmp	80002d56 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d20:	49 5a       	lddpc	r10,80002d74 <phy_tx_func+0xf8>
80002d22:	74 0a       	ld.w	r10,r10[0x0]
80002d24:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d28:	14 49       	or	r9,r10
80002d2a:	8f 19       	st.w	r7[0x4],r9
80002d2c:	2f f8       	sub	r8,-1
80002d2e:	49 59       	lddpc	r9,80002d80 <phy_tx_func+0x104>
80002d30:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d32:	20 2c       	sub	r12,2
80002d34:	49 28       	lddpc	r8,80002d7c <phy_tx_func+0x100>
80002d36:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d38:	30 08       	mov	r8,0
80002d3a:	f0 0c 19 00 	cp.h	r12,r8
80002d3e:	e0 89 00 0c 	brgt	80002d56 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d42:	30 29       	mov	r9,2
80002d44:	48 b8       	lddpc	r8,80002d70 <phy_tx_func+0xf4>
80002d46:	91 09       	st.w	r8[0x0],r9
80002d48:	c0 78       	rjmp	80002d56 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d4a:	fc 18 00 ba 	movh	r8,0xba
80002d4e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d50:	30 09       	mov	r9,0
80002d52:	48 88       	lddpc	r8,80002d70 <phy_tx_func+0xf4>
80002d54:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d56:	e0 68 5a 5a 	mov	r8,23130
80002d5a:	ea 18 ab cd 	orh	r8,0xabcd
80002d5e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d60:	30 08       	mov	r8,0
80002d62:	8f 38       	st.w	r7[0xc],r8
}
80002d64:	2f fd       	sub	sp,-4
80002d66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d6a:	00 00       	add	r0,r0
80002d6c:	00 00       	add	r0,r0
80002d6e:	0a d4       	st.w	--r5,r4
80002d70:	00 00       	add	r0,r0
80002d72:	0a 94       	mov	r4,r5
80002d74:	00 00       	add	r0,r0
80002d76:	0a a0       	st.w	r5++,r0
80002d78:	80 00       	ld.sh	r0,r0[0x0]
80002d7a:	60 a0       	ld.w	r0,r0[0x28]
80002d7c:	00 00       	add	r0,r0
80002d7e:	0a bc       	st.h	r5++,r12
80002d80:	00 00       	add	r0,r0
80002d82:	0a 74       	tst	r4,r5

80002d84 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d84:	d4 01       	pushm	lr
80002d86:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d88:	30 0a       	mov	r10,0
80002d8a:	fa cb ff fc 	sub	r11,sp,-4
80002d8e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d90:	14 99       	mov	r9,r10
80002d92:	1a 9b       	mov	r11,sp
80002d94:	f0 1f 00 05 	mcall	80002da8 <get_idle_store+0x24>
80002d98:	58 1c       	cp.w	r12,1
80002d9a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d9e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002da2:	2f fd       	sub	sp,-4
80002da4:	d8 02       	popm	pc
80002da6:	00 00       	add	r0,r0
80002da8:	80 00       	ld.sh	r0,r0[0x0]
80002daa:	61 90       	ld.w	r0,r0[0x64]

80002dac <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002dac:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002dae:	48 5b       	lddpc	r11,80002dc0 <phy_init+0x14>
80002db0:	48 5c       	lddpc	r12,80002dc4 <phy_init+0x18>
80002db2:	f0 1f 00 06 	mcall	80002dc8 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002db6:	f0 1f 00 06 	mcall	80002dcc <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dba:	f0 1f 00 06 	mcall	80002dd0 <phy_init+0x24>
	
}
80002dbe:	d8 02       	popm	pc
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2c 7c       	sub	r12,-57
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	2d d4       	sub	r4,-35
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	3e 34       	mov	r4,-29
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	3e 48       	mov	r8,-28
80002dd0:	80 00       	ld.sh	r0,r0[0x0]
80002dd2:	47 f4       	lddsp	r4,sp[0x1fc]

80002dd4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002dd4:	eb cd 40 e0 	pushm	r5-r7,lr
80002dd8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002dda:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002dde:	70 08       	ld.w	r8,r8[0x0]
80002de0:	58 08       	cp.w	r8,0
80002de2:	e0 80 01 08 	breq	80002ff2 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002de6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002de8:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002dec:	70 09       	ld.w	r9,r8[0x0]
80002dee:	2f f9       	sub	r9,-1
80002df0:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002df2:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002df6:	70 08       	ld.w	r8,r8[0x0]
80002df8:	58 18       	cp.w	r8,1
80002dfa:	e0 80 00 85 	breq	80002f04 <phy_rx_func+0x130>
80002dfe:	c0 73       	brcs	80002e0c <phy_rx_func+0x38>
80002e00:	58 28       	cp.w	r8,2
80002e02:	c5 c0       	breq	80002eba <phy_rx_func+0xe6>
80002e04:	58 38       	cp.w	r8,3
80002e06:	e0 81 00 f6 	brne	80002ff2 <phy_rx_func+0x21e>
80002e0a:	cd 58       	rjmp	80002fb4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e0c:	e0 6a 5a 5a 	mov	r10,23130
80002e10:	ea 1a ab cd 	orh	r10,0xabcd
80002e14:	14 36       	cp.w	r6,r10
80002e16:	e0 80 00 ee 	breq	80002ff2 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e1a:	ec 08 16 10 	lsr	r8,r6,0x10
80002e1e:	e0 48 ab cd 	cp.w	r8,43981
80002e22:	e0 81 00 e8 	brne	80002ff2 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e26:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e2a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e2e:	20 28       	sub	r8,2
80002e30:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e34:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e36:	30 09       	mov	r9,0
80002e38:	f2 08 19 00 	cp.h	r8,r9
80002e3c:	e0 8a 00 db 	brle	80002ff2 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e40:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e44:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e46:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e4a:	70 0c       	ld.w	r12,r8[0x0]
80002e4c:	f0 1f 03 88 	mcall	80003c6c <phy_rx_func+0xe98>
80002e50:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e54:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e56:	58 0c       	cp.w	r12,0
80002e58:	e0 80 00 cd 	breq	80002ff2 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e5c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e60:	90 09       	ld.sh	r9,r8[0x0]
80002e62:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e66:	2f f9       	sub	r9,-1
80002e68:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e6a:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002e6e:	74 0a       	ld.w	r10,r10[0x0]
80002e70:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002e74:	76 0b       	ld.w	r11,r11[0x0]
80002e76:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002e7a:	2f f9       	sub	r9,-1
80002e7c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002e7e:	e2 16 0f 00 	andl	r6,0xf00,COH
80002e82:	e0 46 01 00 	cp.w	r6,256
80002e86:	c0 c0       	breq	80002e9e <phy_rx_func+0xca>
80002e88:	e0 8b 00 05 	brhi	80002e92 <phy_rx_func+0xbe>
80002e8c:	58 06       	cp.w	r6,0
80002e8e:	c0 80       	breq	80002e9e <phy_rx_func+0xca>
80002e90:	c0 c8       	rjmp	80002ea8 <phy_rx_func+0xd4>
80002e92:	e0 46 02 00 	cp.w	r6,512
80002e96:	c0 40       	breq	80002e9e <phy_rx_func+0xca>
80002e98:	e0 46 03 00 	cp.w	r6,768
80002e9c:	c0 61       	brne	80002ea8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002e9e:	30 29       	mov	r9,2
80002ea0:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002ea4:	91 09       	st.w	r8[0x0],r9
80002ea6:	ca 68       	rjmp	80002ff2 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002ea8:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002eac:	70 0c       	ld.w	r12,r8[0x0]
80002eae:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002eb2:	70 0b       	ld.w	r11,r8[0x0]
80002eb4:	f0 1f 03 70 	mcall	80003c74 <phy_rx_func+0xea0>
80002eb8:	c9 d8       	rjmp	80002ff2 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eba:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002ebe:	b1 86       	lsr	r6,0x10
80002ec0:	14 06       	add	r6,r10
80002ec2:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002ec6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ec8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ecc:	90 09       	ld.sh	r9,r8[0x0]
80002ece:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002ed2:	76 0b       	ld.w	r11,r11[0x0]
80002ed4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ed8:	2f f9       	sub	r9,-1
80002eda:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002edc:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002ee0:	92 08       	ld.sh	r8,r9[0x0]
80002ee2:	20 28       	sub	r8,2
80002ee4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002ee6:	30 09       	mov	r9,0
80002ee8:	f2 08 19 00 	cp.h	r8,r9
80002eec:	e0 8a 00 07 	brle	80002efa <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002ef0:	30 19       	mov	r9,1
80002ef2:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002ef6:	91 09       	st.w	r8[0x0],r9
80002ef8:	c7 d8       	rjmp	80002ff2 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002efa:	30 39       	mov	r9,3
80002efc:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f00:	91 09       	st.w	r8[0x0],r9
80002f02:	c7 88       	rjmp	80002ff2 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f04:	ec 0a 14 10 	asr	r10,r6,0x10
80002f08:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f0c:	90 09       	ld.sh	r9,r8[0x0]
80002f0e:	14 09       	add	r9,r10
80002f10:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f12:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f16:	92 08       	ld.sh	r8,r9[0x0]
80002f18:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f1c:	76 0b       	ld.w	r11,r11[0x0]
80002f1e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f22:	2f f8       	sub	r8,-1
80002f24:	5c 88       	casts.h	r8
80002f26:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f28:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f2c:	94 09       	ld.sh	r9,r10[0x0]
80002f2e:	20 29       	sub	r9,2
80002f30:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f32:	30 0a       	mov	r10,0
80002f34:	f4 09 19 00 	cp.h	r9,r10
80002f38:	e0 89 00 20 	brgt	80002f78 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f3c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f40:	e0 46 00 ba 	cp.w	r6,186
80002f44:	c0 d1       	brne	80002f5e <phy_rx_func+0x18a>
80002f46:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f4a:	90 09       	ld.sh	r9,r8[0x0]
80002f4c:	f4 09 19 00 	cp.h	r9,r10
80002f50:	c0 71       	brne	80002f5e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f52:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f56:	70 0c       	ld.w	r12,r8[0x0]
80002f58:	f0 1f 03 49 	mcall	80003c7c <phy_rx_func+0xea8>
80002f5c:	c0 98       	rjmp	80002f6e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f5e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f62:	70 0c       	ld.w	r12,r8[0x0]
80002f64:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f68:	70 0b       	ld.w	r11,r8[0x0]
80002f6a:	f0 1f 03 43 	mcall	80003c74 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002f6e:	30 09       	mov	r9,0
80002f70:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002f74:	91 09       	st.w	r8[0x0],r9
80002f76:	c3 e8       	rjmp	80002ff2 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002f78:	5c 86       	casts.h	r6
80002f7a:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002f7e:	92 0a       	ld.sh	r10,r9[0x0]
80002f80:	0c 0a       	add	r10,r6
80002f82:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f84:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002f88:	72 09       	ld.w	r9,r9[0x0]
80002f8a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002f8e:	2f f8       	sub	r8,-1
80002f90:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002f94:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002f96:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002f9a:	92 08       	ld.sh	r8,r9[0x0]
80002f9c:	20 28       	sub	r8,2
80002f9e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fa0:	30 09       	mov	r9,0
80002fa2:	f2 08 19 00 	cp.h	r8,r9
80002fa6:	e0 89 00 26 	brgt	80002ff2 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002faa:	30 39       	mov	r9,3
80002fac:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fb0:	91 09       	st.w	r8[0x0],r9
80002fb2:	c2 08       	rjmp	80002ff2 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fb4:	e6 16 00 ff 	andh	r6,0xff,COH
80002fb8:	fc 19 00 ba 	movh	r9,0xba
80002fbc:	12 36       	cp.w	r6,r9
80002fbe:	c0 e1       	brne	80002fda <phy_rx_func+0x206>
80002fc0:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002fc4:	90 09       	ld.sh	r9,r8[0x0]
80002fc6:	30 08       	mov	r8,0
80002fc8:	f0 09 19 00 	cp.h	r9,r8
80002fcc:	c0 71       	brne	80002fda <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002fce:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002fd2:	70 0c       	ld.w	r12,r8[0x0]
80002fd4:	f0 1f 03 2a 	mcall	80003c7c <phy_rx_func+0xea8>
80002fd8:	c0 98       	rjmp	80002fea <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002fda:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fde:	70 0c       	ld.w	r12,r8[0x0]
80002fe0:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002fe4:	70 0b       	ld.w	r11,r8[0x0]
80002fe6:	f0 1f 03 24 	mcall	80003c74 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002fea:	30 09       	mov	r9,0
80002fec:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ff0:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002ff2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ff6:	11 89       	ld.ub	r9,r8[0x0]
80002ff8:	30 08       	mov	r8,0
80002ffa:	f0 09 18 00 	cp.b	r9,r8
80002ffe:	c1 31       	brne	80003024 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003000:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003004:	6c 0c       	ld.w	r12,r6[0x0]
80003006:	f0 1f 03 1a 	mcall	80003c6c <phy_rx_func+0xe98>
8000300a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000300e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003010:	6c 0c       	ld.w	r12,r6[0x0]
80003012:	f0 1f 03 17 	mcall	80003c6c <phy_rx_func+0xe98>
80003016:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000301a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000301c:	30 19       	mov	r9,1
8000301e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003022:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003024:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003028:	70 08       	ld.w	r8,r8[0x0]
8000302a:	58 28       	cp.w	r8,2
8000302c:	e0 80 01 98 	breq	8000335c <phy_rx_func+0x588>
80003030:	e0 8b 00 06 	brhi	8000303c <phy_rx_func+0x268>
80003034:	58 08       	cp.w	r8,0
80003036:	c0 b0       	breq	8000304c <phy_rx_func+0x278>
80003038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000303c:	58 38       	cp.w	r8,3
8000303e:	e0 80 05 c5 	breq	80003bc8 <phy_rx_func+0xdf4>
80003042:	58 48       	cp.w	r8,4
80003044:	e0 81 06 05 	brne	80003c4e <phy_rx_func+0xe7a>
80003048:	e0 8f 02 4b 	bral	800034de <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000304c:	6e 28       	ld.w	r8,r7[0x8]
8000304e:	e0 6a 5a 5a 	mov	r10,23130
80003052:	ea 1a ab cd 	orh	r10,0xabcd
80003056:	14 38       	cp.w	r8,r10
80003058:	c0 71       	brne	80003066 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000305a:	30 09       	mov	r9,0
8000305c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003060:	91 09       	st.w	r8[0x0],r9
80003062:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003066:	10 99       	mov	r9,r8
80003068:	e0 19 00 00 	andl	r9,0x0
8000306c:	fc 1a ab cd 	movh	r10,0xabcd
80003070:	14 39       	cp.w	r9,r10
80003072:	e0 81 05 ee 	brne	80003c4e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003076:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000307a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000307e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003080:	6e 29       	ld.w	r9,r7[0x8]
80003082:	e2 19 f0 00 	andl	r9,0xf000,COH
80003086:	e0 49 c0 00 	cp.w	r9,49152
8000308a:	e0 81 00 ce 	brne	80003226 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000308e:	30 1a       	mov	r10,1
80003090:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003094:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003096:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000309a:	72 09       	ld.w	r9,r9[0x0]
8000309c:	58 09       	cp.w	r9,0
8000309e:	c0 71       	brne	800030ac <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030a0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030a4:	f0 1f 03 00 	mcall	80003ca4 <phy_rx_func+0xed0>
800030a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030ac:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030b0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030b4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030b6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030ba:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030be:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030c2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030c4:	13 89       	ld.ub	r9,r9[0x0]
800030c6:	37 fa       	mov	r10,127
800030c8:	f4 09 18 00 	cp.b	r9,r10
800030cc:	c6 d0       	breq	800031a6 <phy_rx_func+0x3d2>
800030ce:	e0 8b 00 0c 	brhi	800030e6 <phy_rx_func+0x312>
800030d2:	31 2a       	mov	r10,18
800030d4:	f4 09 18 00 	cp.b	r9,r10
800030d8:	c4 20       	breq	8000315c <phy_rx_func+0x388>
800030da:	31 3a       	mov	r10,19
800030dc:	f4 09 18 00 	cp.b	r9,r10
800030e0:	e0 81 00 83 	brne	800031e6 <phy_rx_func+0x412>
800030e4:	c5 b8       	rjmp	8000319a <phy_rx_func+0x3c6>
800030e6:	2f 09       	sub	r9,-16
800030e8:	30 1a       	mov	r10,1
800030ea:	f4 09 18 00 	cp.b	r9,r10
800030ee:	e0 8b 00 7c 	brhi	800031e6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800030f2:	ef 38 00 0e 	ld.ub	r8,r7[14]
800030f6:	e2 18 00 f0 	andl	r8,0xf0,COH
800030fa:	59 08       	cp.w	r8,16
800030fc:	c0 71       	brne	8000310a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800030fe:	30 19       	mov	r9,1
80003100:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003104:	91 09       	st.w	r8[0x0],r9
80003106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000310a:	e0 48 00 20 	cp.w	r8,32
8000310e:	c2 11       	brne	80003150 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003110:	30 a9       	mov	r9,10
80003112:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003116:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003118:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000311c:	6c 08       	ld.w	r8,r6[0x0]
8000311e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003122:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003126:	2f f8       	sub	r8,-1
80003128:	6e 0c       	ld.w	r12,r7[0x0]
8000312a:	f4 ca fe 00 	sub	r10,r10,-512
8000312e:	30 0b       	mov	r11,0
80003130:	10 0c       	add	r12,r8
80003132:	f0 1f 02 e1 	mcall	80003cb4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003136:	30 08       	mov	r8,0
80003138:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000313a:	6e 0c       	ld.w	r12,r7[0x0]
8000313c:	f0 1f 02 df 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003140:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003144:	70 0c       	ld.w	r12,r8[0x0]
80003146:	f0 1f 02 ca 	mcall	80003c6c <phy_rx_func+0xe98>
8000314a:	8f 0c       	st.w	r7[0x0],r12
8000314c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003150:	30 09       	mov	r9,0
80003152:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003156:	91 09       	st.w	r8[0x0],r9
80003158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000315c:	20 48       	sub	r8,4
8000315e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003162:	93 08       	st.w	r9[0x0],r8
80003164:	58 08       	cp.w	r8,0
80003166:	e0 80 05 74 	breq	80003c4e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000316a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000316e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003172:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003176:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003178:	8e 69       	ld.sh	r9,r7[0xc]
8000317a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000317e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003180:	8e 79       	ld.sh	r9,r7[0xe]
80003182:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003184:	f0 1f 02 d0 	mcall	80003cc4 <phy_rx_func+0xef0>
80003188:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000318c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000318e:	30 49       	mov	r9,4
80003190:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003194:	91 09       	st.w	r8[0x0],r9
80003196:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000319a:	30 09       	mov	r9,0
8000319c:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031a0:	91 09       	st.w	r8[0x0],r9
800031a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031a6:	20 48       	sub	r8,4
800031a8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031ac:	93 08       	st.w	r9[0x0],r8
800031ae:	58 08       	cp.w	r8,0
800031b0:	e0 80 05 4f 	breq	80003c4e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031b4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031b8:	70 09       	ld.w	r9,r8[0x0]
800031ba:	8e 7b       	ld.sh	r11,r7[0xe]
800031bc:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031c0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031c4:	2f f9       	sub	r9,-1
800031c6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031c8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800031cc:	70 09       	ld.w	r9,r8[0x0]
800031ce:	20 29       	sub	r9,2
800031d0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800031d2:	30 29       	mov	r9,2
800031d4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800031d8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800031da:	30 39       	mov	r9,3
800031dc:	fe f8 0a b4 	ld.w	r8,pc[2740]
800031e0:	91 09       	st.w	r8[0x0],r9
800031e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800031e6:	30 3a       	mov	r10,3
800031e8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800031ec:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800031ee:	6e 2a       	ld.w	r10,r7[0x8]
800031f0:	fe f9 0a e0 	ld.w	r9,pc[2784]
800031f4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800031f6:	6e 3a       	ld.w	r10,r7[0xc]
800031f8:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800031fa:	59 48       	cp.w	r8,20
800031fc:	c0 61       	brne	80003208 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800031fe:	31 89       	mov	r9,24
80003200:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003204:	91 09       	st.w	r8[0x0],r9
80003206:	c0 a8       	rjmp	8000321a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003208:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000320c:	70 08       	ld.w	r8,r8[0x0]
8000320e:	59 08       	cp.w	r8,16
80003210:	c0 51       	brne	8000321a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003212:	31 09       	mov	r9,16
80003214:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003218:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000321a:	30 49       	mov	r9,4
8000321c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003220:	91 09       	st.w	r8[0x0],r9
80003222:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003226:	e0 49 10 00 	cp.w	r9,4096
8000322a:	5f 1a       	srne	r10
8000322c:	e0 49 20 00 	cp.w	r9,8192
80003230:	5f 19       	srne	r9
80003232:	f5 e9 00 09 	and	r9,r10,r9
80003236:	e0 81 05 0c 	brne	80003c4e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000323a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000323e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003240:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003244:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003246:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000324a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000324c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003250:	72 09       	ld.w	r9,r9[0x0]
80003252:	58 09       	cp.w	r9,0
80003254:	c0 71       	brne	80003262 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003256:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000325a:	f0 1f 02 93 	mcall	80003ca4 <phy_rx_func+0xed0>
8000325e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003262:	6e 2a       	ld.w	r10,r7[0x8]
80003264:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003268:	58 1a       	cp.w	r10,1
8000326a:	e0 8b 00 4d 	brhi	80003304 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000326e:	20 48       	sub	r8,4
80003270:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003274:	93 08       	st.w	r9[0x0],r8
80003276:	58 08       	cp.w	r8,0
80003278:	e0 80 04 eb 	breq	80003c4e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
8000327c:	8e 68       	ld.sh	r8,r7[0xc]
8000327e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003282:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003286:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003288:	30 09       	mov	r9,0
8000328a:	f2 08 19 00 	cp.h	r8,r9
8000328e:	c0 70       	breq	8000329c <phy_rx_func+0x4c8>
80003290:	30 19       	mov	r9,1
80003292:	f2 08 19 00 	cp.h	r8,r9
80003296:	e0 81 04 dc 	brne	80003c4e <phy_rx_func+0xe7a>
8000329a:	c2 68       	rjmp	800032e6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000329c:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032a0:	70 0a       	ld.w	r10,r8[0x0]
800032a2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032a6:	72 09       	ld.w	r9,r9[0x0]
800032a8:	8e 7b       	ld.sh	r11,r7[0xe]
800032aa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032ae:	70 09       	ld.w	r9,r8[0x0]
800032b0:	2f f9       	sub	r9,-1
800032b2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032b4:	e0 49 00 ff 	cp.w	r9,255
800032b8:	e0 88 00 11 	brls	800032da <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032bc:	30 09       	mov	r9,0
800032be:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032c0:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032c4:	6e 0c       	ld.w	r12,r7[0x0]
800032c6:	f0 1f 02 7d 	mcall	80003cb8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032ca:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032ce:	70 0c       	ld.w	r12,r8[0x0]
800032d0:	f0 1f 02 67 	mcall	80003c6c <phy_rx_func+0xe98>
800032d4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800032d6:	e0 80 04 bc 	breq	80003c4e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800032da:	30 29       	mov	r9,2
800032dc:	fe f8 09 b4 	ld.w	r8,pc[2484]
800032e0:	91 09       	st.w	r8[0x0],r9
800032e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032e6:	8e 79       	ld.sh	r9,r7[0xe]
800032e8:	30 38       	mov	r8,3
800032ea:	f0 09 19 00 	cp.h	r9,r8
800032ee:	c0 51       	brne	800032f8 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800032f0:	30 19       	mov	r9,1
800032f2:	fe f8 09 f2 	ld.w	r8,pc[2546]
800032f6:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800032f8:	30 29       	mov	r9,2
800032fa:	fe f8 09 96 	ld.w	r8,pc[2454]
800032fe:	91 09       	st.w	r8[0x0],r9
80003300:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003304:	58 18       	cp.w	r8,1
80003306:	e0 88 04 a4 	brls	80003c4e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000330a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000330e:	70 0a       	ld.w	r10,r8[0x0]
80003310:	6e 3b       	ld.w	r11,r7[0xc]
80003312:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003316:	70 09       	ld.w	r9,r8[0x0]
80003318:	2f f9       	sub	r9,-1
8000331a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000331c:	e0 49 00 ff 	cp.w	r9,255
80003320:	e0 88 00 11 	brls	80003342 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003324:	30 09       	mov	r9,0
80003326:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003328:	fe f7 09 60 	ld.w	r7,pc[2400]
8000332c:	6e 0c       	ld.w	r12,r7[0x0]
8000332e:	f0 1f 02 63 	mcall	80003cb8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003332:	fe f8 09 52 	ld.w	r8,pc[2386]
80003336:	70 0c       	ld.w	r12,r8[0x0]
80003338:	f0 1f 02 4d 	mcall	80003c6c <phy_rx_func+0xe98>
8000333c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000333e:	e0 80 04 88 	breq	80003c4e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003342:	fe f9 09 56 	ld.w	r9,pc[2390]
80003346:	72 08       	ld.w	r8,r9[0x0]
80003348:	20 28       	sub	r8,2
8000334a:	93 08       	st.w	r9[0x0],r8
8000334c:	e0 80 04 81 	breq	80003c4e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003350:	30 29       	mov	r9,2
80003352:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003356:	91 09       	st.w	r8[0x0],r9
80003358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000335c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003360:	70 0a       	ld.w	r10,r8[0x0]
80003362:	fe f9 09 26 	ld.w	r9,pc[2342]
80003366:	72 09       	ld.w	r9,r9[0x0]
80003368:	8e 4b       	ld.sh	r11,r7[0x8]
8000336a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000336e:	70 09       	ld.w	r9,r8[0x0]
80003370:	2f f9       	sub	r9,-1
80003372:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003374:	e0 49 00 ff 	cp.w	r9,255
80003378:	e0 88 00 16 	brls	800033a4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
8000337c:	30 09       	mov	r9,0
8000337e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003380:	fe f6 09 08 	ld.w	r6,pc[2312]
80003384:	6c 0c       	ld.w	r12,r6[0x0]
80003386:	f0 1f 02 4d 	mcall	80003cb8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000338a:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000338e:	70 0c       	ld.w	r12,r8[0x0]
80003390:	f0 1f 02 37 	mcall	80003c6c <phy_rx_func+0xe98>
80003394:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003396:	c0 71       	brne	800033a4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003398:	30 09       	mov	r9,0
8000339a:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000339e:	91 09       	st.w	r8[0x0],r9
800033a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033a4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033a8:	72 08       	ld.w	r8,r9[0x0]
800033aa:	20 28       	sub	r8,2
800033ac:	93 08       	st.w	r9[0x0],r8
800033ae:	c0 71       	brne	800033bc <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033b0:	30 09       	mov	r9,0
800033b2:	fe f8 08 de 	ld.w	r8,pc[2270]
800033b6:	91 09       	st.w	r8[0x0],r9
800033b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033bc:	fe f8 09 24 	ld.w	r8,pc[2340]
800033c0:	70 0a       	ld.w	r10,r8[0x0]
800033c2:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033c6:	72 09       	ld.w	r9,r9[0x0]
800033c8:	8e 5b       	ld.sh	r11,r7[0xa]
800033ca:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033ce:	70 09       	ld.w	r9,r8[0x0]
800033d0:	2f f9       	sub	r9,-1
800033d2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033d4:	e0 49 00 ff 	cp.w	r9,255
800033d8:	e0 88 00 16 	brls	80003404 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800033dc:	30 09       	mov	r9,0
800033de:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033e0:	fe f6 08 a8 	ld.w	r6,pc[2216]
800033e4:	6c 0c       	ld.w	r12,r6[0x0]
800033e6:	f0 1f 02 35 	mcall	80003cb8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033ea:	fe f8 08 9a 	ld.w	r8,pc[2202]
800033ee:	70 0c       	ld.w	r12,r8[0x0]
800033f0:	f0 1f 02 1f 	mcall	80003c6c <phy_rx_func+0xe98>
800033f4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033f6:	c0 71       	brne	80003404 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800033f8:	30 09       	mov	r9,0
800033fa:	fe f8 08 96 	ld.w	r8,pc[2198]
800033fe:	91 09       	st.w	r8[0x0],r9
80003400:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003404:	fe f9 08 94 	ld.w	r9,pc[2196]
80003408:	72 08       	ld.w	r8,r9[0x0]
8000340a:	20 28       	sub	r8,2
8000340c:	93 08       	st.w	r9[0x0],r8
8000340e:	c0 71       	brne	8000341c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003410:	30 09       	mov	r9,0
80003412:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003416:	91 09       	st.w	r8[0x0],r9
80003418:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000341c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003420:	70 0a       	ld.w	r10,r8[0x0]
80003422:	fe f9 08 66 	ld.w	r9,pc[2150]
80003426:	72 09       	ld.w	r9,r9[0x0]
80003428:	8e 6b       	ld.sh	r11,r7[0xc]
8000342a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000342e:	70 09       	ld.w	r9,r8[0x0]
80003430:	2f f9       	sub	r9,-1
80003432:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003434:	e0 49 00 ff 	cp.w	r9,255
80003438:	e0 88 00 16 	brls	80003464 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000343c:	30 09       	mov	r9,0
8000343e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003440:	fe f6 08 48 	ld.w	r6,pc[2120]
80003444:	6c 0c       	ld.w	r12,r6[0x0]
80003446:	f0 1f 02 1d 	mcall	80003cb8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000344a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000344e:	70 0c       	ld.w	r12,r8[0x0]
80003450:	f0 1f 02 07 	mcall	80003c6c <phy_rx_func+0xe98>
80003454:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003456:	c0 71       	brne	80003464 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003458:	30 09       	mov	r9,0
8000345a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000345e:	91 09       	st.w	r8[0x0],r9
80003460:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003464:	fe f9 08 34 	ld.w	r9,pc[2100]
80003468:	72 08       	ld.w	r8,r9[0x0]
8000346a:	20 28       	sub	r8,2
8000346c:	93 08       	st.w	r9[0x0],r8
8000346e:	c0 71       	brne	8000347c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003470:	30 09       	mov	r9,0
80003472:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003476:	91 09       	st.w	r8[0x0],r9
80003478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000347c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003480:	70 0a       	ld.w	r10,r8[0x0]
80003482:	fe f9 08 06 	ld.w	r9,pc[2054]
80003486:	72 09       	ld.w	r9,r9[0x0]
80003488:	8e 7b       	ld.sh	r11,r7[0xe]
8000348a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000348e:	70 09       	ld.w	r9,r8[0x0]
80003490:	2f f9       	sub	r9,-1
80003492:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003494:	e0 49 00 ff 	cp.w	r9,255
80003498:	e0 88 00 16 	brls	800034c4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
8000349c:	30 09       	mov	r9,0
8000349e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034a0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034a4:	6e 0c       	ld.w	r12,r7[0x0]
800034a6:	f0 1f 02 05 	mcall	80003cb8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034aa:	fe f8 07 da 	ld.w	r8,pc[2010]
800034ae:	70 0c       	ld.w	r12,r8[0x0]
800034b0:	f0 1f 01 ef 	mcall	80003c6c <phy_rx_func+0xe98>
800034b4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034b6:	c0 71       	brne	800034c4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034b8:	30 09       	mov	r9,0
800034ba:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034be:	91 09       	st.w	r8[0x0],r9
800034c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034c4:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034c8:	72 08       	ld.w	r8,r9[0x0]
800034ca:	20 28       	sub	r8,2
800034cc:	93 08       	st.w	r9[0x0],r8
800034ce:	e0 81 03 c0 	brne	80003c4e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800034d2:	30 09       	mov	r9,0
800034d4:	fe f8 07 bc 	ld.w	r8,pc[1980]
800034d8:	91 09       	st.w	r8[0x0],r9
800034da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034de:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034e2:	11 89       	ld.ub	r9,r8[0x0]
800034e4:	31 28       	mov	r8,18
800034e6:	f0 09 18 00 	cp.b	r9,r8
800034ea:	e0 81 01 4c 	brne	80003782 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800034ee:	ef 39 00 09 	ld.ub	r9,r7[9]
800034f2:	fe f8 07 b6 	ld.w	r8,pc[1974]
800034f6:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034f8:	11 89       	ld.ub	r9,r8[0x0]
800034fa:	3f 28       	mov	r8,-14
800034fc:	f0 09 18 00 	cp.b	r9,r8
80003500:	e0 81 01 3b 	brne	80003776 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003504:	30 19       	mov	r9,1
80003506:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000350a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000350c:	6e 29       	ld.w	r9,r7[0x8]
8000350e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003512:	fe f8 07 86 	ld.w	r8,pc[1926]
80003516:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003518:	8e 59       	ld.sh	r9,r7[0xa]
8000351a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000351e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003520:	8e 69       	ld.sh	r9,r7[0xc]
80003522:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003524:	8e 79       	ld.sh	r9,r7[0xe]
80003526:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003528:	fe f8 07 88 	ld.w	r8,pc[1928]
8000352c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003530:	72 0a       	ld.w	r10,r9[0x0]
80003532:	70 09       	ld.w	r9,r8[0x0]
80003534:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003538:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000353c:	70 09       	ld.w	r9,r8[0x0]
8000353e:	2f f9       	sub	r9,-1
80003540:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003542:	e0 49 01 ff 	cp.w	r9,511
80003546:	e0 88 00 16 	brls	80003572 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000354a:	30 09       	mov	r9,0
8000354c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000354e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003552:	6c 0c       	ld.w	r12,r6[0x0]
80003554:	f0 1f 01 d9 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003558:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000355c:	70 0c       	ld.w	r12,r8[0x0]
8000355e:	f0 1f 01 c4 	mcall	80003c6c <phy_rx_func+0xe98>
80003562:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003564:	c0 71       	brne	80003572 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003566:	30 09       	mov	r9,0
80003568:	fe f8 07 28 	ld.w	r8,pc[1832]
8000356c:	91 09       	st.w	r8[0x0],r9
8000356e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003572:	fe f9 07 26 	ld.w	r9,pc[1830]
80003576:	72 08       	ld.w	r8,r9[0x0]
80003578:	20 18       	sub	r8,1
8000357a:	93 08       	st.w	r9[0x0],r8
8000357c:	c0 71       	brne	8000358a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000357e:	30 09       	mov	r9,0
80003580:	fe f8 07 10 	ld.w	r8,pc[1808]
80003584:	91 09       	st.w	r8[0x0],r9
80003586:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000358a:	fe f8 07 26 	ld.w	r8,pc[1830]
8000358e:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003592:	72 0a       	ld.w	r10,r9[0x0]
80003594:	70 09       	ld.w	r9,r8[0x0]
80003596:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000359a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000359e:	70 09       	ld.w	r9,r8[0x0]
800035a0:	2f f9       	sub	r9,-1
800035a2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035a4:	e0 49 01 ff 	cp.w	r9,511
800035a8:	e0 88 00 16 	brls	800035d4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ac:	30 09       	mov	r9,0
800035ae:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035b0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035b4:	6c 0c       	ld.w	r12,r6[0x0]
800035b6:	f0 1f 01 c1 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ba:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035be:	70 0c       	ld.w	r12,r8[0x0]
800035c0:	f0 1f 01 ab 	mcall	80003c6c <phy_rx_func+0xe98>
800035c4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035c6:	c0 71       	brne	800035d4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035c8:	30 09       	mov	r9,0
800035ca:	fe f8 06 c6 	ld.w	r8,pc[1734]
800035ce:	91 09       	st.w	r8[0x0],r9
800035d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035d4:	fe f9 06 c4 	ld.w	r9,pc[1732]
800035d8:	72 08       	ld.w	r8,r9[0x0]
800035da:	20 18       	sub	r8,1
800035dc:	93 08       	st.w	r9[0x0],r8
800035de:	c0 71       	brne	800035ec <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800035e0:	30 09       	mov	r9,0
800035e2:	fe f8 06 ae 	ld.w	r8,pc[1710]
800035e6:	91 09       	st.w	r8[0x0],r9
800035e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035ec:	fe f8 06 c4 	ld.w	r8,pc[1732]
800035f0:	fe f9 06 9c 	ld.w	r9,pc[1692]
800035f4:	72 0a       	ld.w	r10,r9[0x0]
800035f6:	70 09       	ld.w	r9,r8[0x0]
800035f8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035fc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003600:	70 09       	ld.w	r9,r8[0x0]
80003602:	2f f9       	sub	r9,-1
80003604:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003606:	e0 49 01 ff 	cp.w	r9,511
8000360a:	e0 88 00 16 	brls	80003636 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000360e:	30 09       	mov	r9,0
80003610:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003612:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003616:	6c 0c       	ld.w	r12,r6[0x0]
80003618:	f0 1f 01 a8 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000361c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003620:	70 0c       	ld.w	r12,r8[0x0]
80003622:	f0 1f 01 93 	mcall	80003c6c <phy_rx_func+0xe98>
80003626:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003628:	c0 71       	brne	80003636 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000362a:	30 09       	mov	r9,0
8000362c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003630:	91 09       	st.w	r8[0x0],r9
80003632:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003636:	fe f9 06 62 	ld.w	r9,pc[1634]
8000363a:	72 08       	ld.w	r8,r9[0x0]
8000363c:	20 18       	sub	r8,1
8000363e:	93 08       	st.w	r9[0x0],r8
80003640:	c0 71       	brne	8000364e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003642:	30 09       	mov	r9,0
80003644:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003648:	91 09       	st.w	r8[0x0],r9
8000364a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000364e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003652:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003656:	72 0a       	ld.w	r10,r9[0x0]
80003658:	70 09       	ld.w	r9,r8[0x0]
8000365a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000365e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003662:	70 09       	ld.w	r9,r8[0x0]
80003664:	2f f9       	sub	r9,-1
80003666:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003668:	e0 49 01 ff 	cp.w	r9,511
8000366c:	e0 88 00 16 	brls	80003698 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003670:	30 09       	mov	r9,0
80003672:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003674:	fe f6 06 18 	ld.w	r6,pc[1560]
80003678:	6c 0c       	ld.w	r12,r6[0x0]
8000367a:	f0 1f 01 90 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000367e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003682:	70 0c       	ld.w	r12,r8[0x0]
80003684:	f0 1f 01 7a 	mcall	80003c6c <phy_rx_func+0xe98>
80003688:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000368a:	c0 71       	brne	80003698 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
8000368c:	30 09       	mov	r9,0
8000368e:	fe f8 06 02 	ld.w	r8,pc[1538]
80003692:	91 09       	st.w	r8[0x0],r9
80003694:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003698:	fe f9 06 00 	ld.w	r9,pc[1536]
8000369c:	72 08       	ld.w	r8,r9[0x0]
8000369e:	20 18       	sub	r8,1
800036a0:	93 08       	st.w	r9[0x0],r8
800036a2:	c0 71       	brne	800036b0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036a4:	30 09       	mov	r9,0
800036a6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036aa:	91 09       	st.w	r8[0x0],r9
800036ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036b0:	fe f8 06 00 	ld.w	r8,pc[1536]
800036b4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036b8:	72 0a       	ld.w	r10,r9[0x0]
800036ba:	70 09       	ld.w	r9,r8[0x0]
800036bc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036c0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036c4:	70 09       	ld.w	r9,r8[0x0]
800036c6:	2f f9       	sub	r9,-1
800036c8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036ca:	e0 49 01 ff 	cp.w	r9,511
800036ce:	e0 88 00 16 	brls	800036fa <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800036d2:	30 09       	mov	r9,0
800036d4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036d6:	fe f6 05 b6 	ld.w	r6,pc[1462]
800036da:	6c 0c       	ld.w	r12,r6[0x0]
800036dc:	f0 1f 01 77 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036e0:	fe f8 05 a4 	ld.w	r8,pc[1444]
800036e4:	70 0c       	ld.w	r12,r8[0x0]
800036e6:	f0 1f 01 62 	mcall	80003c6c <phy_rx_func+0xe98>
800036ea:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ec:	c0 71       	brne	800036fa <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800036ee:	30 09       	mov	r9,0
800036f0:	fe f8 05 a0 	ld.w	r8,pc[1440]
800036f4:	91 09       	st.w	r8[0x0],r9
800036f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036fa:	fe f9 05 9e 	ld.w	r9,pc[1438]
800036fe:	72 08       	ld.w	r8,r9[0x0]
80003700:	20 18       	sub	r8,1
80003702:	93 08       	st.w	r9[0x0],r8
80003704:	c0 71       	brne	80003712 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003706:	30 09       	mov	r9,0
80003708:	fe f8 05 88 	ld.w	r8,pc[1416]
8000370c:	91 09       	st.w	r8[0x0],r9
8000370e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003712:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003716:	fe f9 05 76 	ld.w	r9,pc[1398]
8000371a:	72 0a       	ld.w	r10,r9[0x0]
8000371c:	70 09       	ld.w	r9,r8[0x0]
8000371e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003722:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003726:	70 09       	ld.w	r9,r8[0x0]
80003728:	2f f9       	sub	r9,-1
8000372a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000372c:	e0 49 01 ff 	cp.w	r9,511
80003730:	e0 88 00 16 	brls	8000375c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003734:	30 09       	mov	r9,0
80003736:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003738:	fe f7 05 54 	ld.w	r7,pc[1364]
8000373c:	6e 0c       	ld.w	r12,r7[0x0]
8000373e:	f0 1f 01 5f 	mcall	80003cb8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003742:	fe f8 05 42 	ld.w	r8,pc[1346]
80003746:	70 0c       	ld.w	r12,r8[0x0]
80003748:	f0 1f 01 49 	mcall	80003c6c <phy_rx_func+0xe98>
8000374c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000374e:	c0 71       	brne	8000375c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003750:	30 09       	mov	r9,0
80003752:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003756:	91 09       	st.w	r8[0x0],r9
80003758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000375c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003760:	72 08       	ld.w	r8,r9[0x0]
80003762:	20 18       	sub	r8,1
80003764:	93 08       	st.w	r9[0x0],r8
80003766:	e0 81 02 74 	brne	80003c4e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003776:	30 09       	mov	r9,0
80003778:	fe f8 05 18 	ld.w	r8,pc[1304]
8000377c:	91 09       	st.w	r8[0x0],r9
8000377e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003782:	fe f8 05 26 	ld.w	r8,pc[1318]
80003786:	11 89       	ld.ub	r9,r8[0x0]
80003788:	3f 28       	mov	r8,-14
8000378a:	f0 09 18 00 	cp.b	r9,r8
8000378e:	c4 31       	brne	80003814 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003790:	8e 49       	ld.sh	r9,r7[0x8]
80003792:	fe f8 05 56 	ld.w	r8,pc[1366]
80003796:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003798:	fe f8 05 18 	ld.w	r8,pc[1304]
8000379c:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037a0:	72 0a       	ld.w	r10,r9[0x0]
800037a2:	70 09       	ld.w	r9,r8[0x0]
800037a4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037a8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037ac:	70 09       	ld.w	r9,r8[0x0]
800037ae:	2f f9       	sub	r9,-1
800037b0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037b2:	e0 49 01 ff 	cp.w	r9,511
800037b6:	e0 88 00 16 	brls	800037e2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ba:	30 09       	mov	r9,0
800037bc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037be:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037c2:	6e 0c       	ld.w	r12,r7[0x0]
800037c4:	f0 1f 01 3d 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037c8:	fe f8 04 bc 	ld.w	r8,pc[1212]
800037cc:	70 0c       	ld.w	r12,r8[0x0]
800037ce:	f0 1f 01 28 	mcall	80003c6c <phy_rx_func+0xe98>
800037d2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037d4:	c0 71       	brne	800037e2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800037d6:	30 09       	mov	r9,0
800037d8:	fe f8 04 b8 	ld.w	r8,pc[1208]
800037dc:	91 09       	st.w	r8[0x0],r9
800037de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037e2:	fe f9 04 b6 	ld.w	r9,pc[1206]
800037e6:	72 08       	ld.w	r8,r9[0x0]
800037e8:	20 18       	sub	r8,1
800037ea:	93 08       	st.w	r9[0x0],r8
800037ec:	c0 71       	brne	800037fa <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800037ee:	30 09       	mov	r9,0
800037f0:	fe f8 04 a0 	ld.w	r8,pc[1184]
800037f4:	91 09       	st.w	r8[0x0],r9
800037f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037fa:	20 18       	sub	r8,1
800037fc:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003800:	93 08       	st.w	r9[0x0],r8
80003802:	58 08       	cp.w	r8,0
80003804:	e0 81 02 25 	brne	80003c4e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003808:	30 09       	mov	r9,0
8000380a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000380e:	91 09       	st.w	r8[0x0],r9
80003810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003814:	fe f8 04 94 	ld.w	r8,pc[1172]
80003818:	11 89       	ld.ub	r9,r8[0x0]
8000381a:	3f 38       	mov	r8,-13
8000381c:	f0 09 18 00 	cp.b	r9,r8
80003820:	e0 81 01 0c 	brne	80003a38 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003824:	8e 49       	ld.sh	r9,r7[0x8]
80003826:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000382a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000382c:	8e 59       	ld.sh	r9,r7[0xa]
8000382e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003830:	8e 69       	ld.sh	r9,r7[0xc]
80003832:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003834:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003838:	fe f9 04 54 	ld.w	r9,pc[1108]
8000383c:	72 0a       	ld.w	r10,r9[0x0]
8000383e:	70 09       	ld.w	r9,r8[0x0]
80003840:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003844:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003848:	70 09       	ld.w	r9,r8[0x0]
8000384a:	2f f9       	sub	r9,-1
8000384c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000384e:	e0 49 01 ff 	cp.w	r9,511
80003852:	e0 88 00 16 	brls	8000387e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003856:	30 09       	mov	r9,0
80003858:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000385a:	fe f6 04 32 	ld.w	r6,pc[1074]
8000385e:	6c 0c       	ld.w	r12,r6[0x0]
80003860:	f0 1f 01 16 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003864:	fe f8 04 20 	ld.w	r8,pc[1056]
80003868:	70 0c       	ld.w	r12,r8[0x0]
8000386a:	f0 1f 01 01 	mcall	80003c6c <phy_rx_func+0xe98>
8000386e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003870:	c0 71       	brne	8000387e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003872:	30 09       	mov	r9,0
80003874:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003878:	91 09       	st.w	r8[0x0],r9
8000387a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000387e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003882:	72 08       	ld.w	r8,r9[0x0]
80003884:	20 18       	sub	r8,1
80003886:	93 08       	st.w	r9[0x0],r8
80003888:	c0 71       	brne	80003896 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000388a:	30 09       	mov	r9,0
8000388c:	fe f8 04 04 	ld.w	r8,pc[1028]
80003890:	91 09       	st.w	r8[0x0],r9
80003892:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003896:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000389a:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000389e:	72 0a       	ld.w	r10,r9[0x0]
800038a0:	70 09       	ld.w	r9,r8[0x0]
800038a2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038a6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038aa:	70 09       	ld.w	r9,r8[0x0]
800038ac:	2f f9       	sub	r9,-1
800038ae:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038b0:	e0 49 01 ff 	cp.w	r9,511
800038b4:	e0 88 00 16 	brls	800038e0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038b8:	30 09       	mov	r9,0
800038ba:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038bc:	fe f6 03 d0 	ld.w	r6,pc[976]
800038c0:	6c 0c       	ld.w	r12,r6[0x0]
800038c2:	f0 1f 00 fe 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038c6:	fe f8 03 be 	ld.w	r8,pc[958]
800038ca:	70 0c       	ld.w	r12,r8[0x0]
800038cc:	f0 1f 00 e8 	mcall	80003c6c <phy_rx_func+0xe98>
800038d0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038d2:	c0 71       	brne	800038e0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800038d4:	30 09       	mov	r9,0
800038d6:	fe f8 03 ba 	ld.w	r8,pc[954]
800038da:	91 09       	st.w	r8[0x0],r9
800038dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038e0:	fe f9 03 b8 	ld.w	r9,pc[952]
800038e4:	72 08       	ld.w	r8,r9[0x0]
800038e6:	20 18       	sub	r8,1
800038e8:	93 08       	st.w	r9[0x0],r8
800038ea:	c0 71       	brne	800038f8 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800038ec:	30 09       	mov	r9,0
800038ee:	fe f8 03 a2 	ld.w	r8,pc[930]
800038f2:	91 09       	st.w	r8[0x0],r9
800038f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038f8:	fe f8 03 b8 	ld.w	r8,pc[952]
800038fc:	fe f9 03 90 	ld.w	r9,pc[912]
80003900:	72 0a       	ld.w	r10,r9[0x0]
80003902:	70 09       	ld.w	r9,r8[0x0]
80003904:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003908:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000390c:	70 09       	ld.w	r9,r8[0x0]
8000390e:	2f f9       	sub	r9,-1
80003910:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003912:	e0 49 01 ff 	cp.w	r9,511
80003916:	e0 88 00 16 	brls	80003942 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000391a:	30 09       	mov	r9,0
8000391c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000391e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003922:	6c 0c       	ld.w	r12,r6[0x0]
80003924:	f0 1f 00 e5 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003928:	fe f8 03 5c 	ld.w	r8,pc[860]
8000392c:	70 0c       	ld.w	r12,r8[0x0]
8000392e:	f0 1f 00 d0 	mcall	80003c6c <phy_rx_func+0xe98>
80003932:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003934:	c0 71       	brne	80003942 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003936:	30 09       	mov	r9,0
80003938:	fe f8 03 58 	ld.w	r8,pc[856]
8000393c:	91 09       	st.w	r8[0x0],r9
8000393e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003942:	fe f9 03 56 	ld.w	r9,pc[854]
80003946:	72 08       	ld.w	r8,r9[0x0]
80003948:	20 18       	sub	r8,1
8000394a:	93 08       	st.w	r9[0x0],r8
8000394c:	c0 71       	brne	8000395a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000394e:	30 09       	mov	r9,0
80003950:	fe f8 03 40 	ld.w	r8,pc[832]
80003954:	91 09       	st.w	r8[0x0],r9
80003956:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000395a:	fe f8 03 56 	ld.w	r8,pc[854]
8000395e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003962:	72 0a       	ld.w	r10,r9[0x0]
80003964:	70 09       	ld.w	r9,r8[0x0]
80003966:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000396a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000396e:	70 09       	ld.w	r9,r8[0x0]
80003970:	2f f9       	sub	r9,-1
80003972:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003974:	e0 49 01 ff 	cp.w	r9,511
80003978:	e0 88 00 16 	brls	800039a4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
8000397c:	30 09       	mov	r9,0
8000397e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003980:	fe f6 03 0c 	ld.w	r6,pc[780]
80003984:	6c 0c       	ld.w	r12,r6[0x0]
80003986:	f0 1f 00 cd 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000398a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000398e:	70 0c       	ld.w	r12,r8[0x0]
80003990:	f0 1f 00 b7 	mcall	80003c6c <phy_rx_func+0xe98>
80003994:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003996:	c0 71       	brne	800039a4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003998:	30 09       	mov	r9,0
8000399a:	fe f8 02 f6 	ld.w	r8,pc[758]
8000399e:	91 09       	st.w	r8[0x0],r9
800039a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039a4:	fe f9 02 f4 	ld.w	r9,pc[756]
800039a8:	72 08       	ld.w	r8,r9[0x0]
800039aa:	20 18       	sub	r8,1
800039ac:	93 08       	st.w	r9[0x0],r8
800039ae:	c0 71       	brne	800039bc <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039b0:	30 09       	mov	r9,0
800039b2:	fe f8 02 de 	ld.w	r8,pc[734]
800039b6:	91 09       	st.w	r8[0x0],r9
800039b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039bc:	fe f8 02 f4 	ld.w	r8,pc[756]
800039c0:	fe f9 02 cc 	ld.w	r9,pc[716]
800039c4:	72 0a       	ld.w	r10,r9[0x0]
800039c6:	70 09       	ld.w	r9,r8[0x0]
800039c8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039cc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039d0:	70 09       	ld.w	r9,r8[0x0]
800039d2:	2f f9       	sub	r9,-1
800039d4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039d6:	e0 49 01 ff 	cp.w	r9,511
800039da:	e0 88 00 16 	brls	80003a06 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800039de:	30 09       	mov	r9,0
800039e0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039e2:	fe f7 02 aa 	ld.w	r7,pc[682]
800039e6:	6e 0c       	ld.w	r12,r7[0x0]
800039e8:	f0 1f 00 b4 	mcall	80003cb8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ec:	fe f8 02 98 	ld.w	r8,pc[664]
800039f0:	70 0c       	ld.w	r12,r8[0x0]
800039f2:	f0 1f 00 9f 	mcall	80003c6c <phy_rx_func+0xe98>
800039f6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039f8:	c0 71       	brne	80003a06 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800039fa:	30 09       	mov	r9,0
800039fc:	fe f8 02 94 	ld.w	r8,pc[660]
80003a00:	91 09       	st.w	r8[0x0],r9
80003a02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a06:	fe f9 02 92 	ld.w	r9,pc[658]
80003a0a:	72 08       	ld.w	r8,r9[0x0]
80003a0c:	20 18       	sub	r8,1
80003a0e:	93 08       	st.w	r9[0x0],r8
80003a10:	c0 71       	brne	80003a1e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a12:	30 09       	mov	r9,0
80003a14:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a18:	91 09       	st.w	r8[0x0],r9
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a1e:	20 18       	sub	r8,1
80003a20:	fe f9 02 78 	ld.w	r9,pc[632]
80003a24:	93 08       	st.w	r9[0x0],r8
80003a26:	58 08       	cp.w	r8,0
80003a28:	e0 81 01 13 	brne	80003c4e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a2c:	30 09       	mov	r9,0
80003a2e:	fe f8 02 62 	ld.w	r8,pc[610]
80003a32:	91 09       	st.w	r8[0x0],r9
80003a34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a38:	fe f8 02 70 	ld.w	r8,pc[624]
80003a3c:	11 89       	ld.ub	r9,r8[0x0]
80003a3e:	30 48       	mov	r8,4
80003a40:	f0 09 18 00 	cp.b	r9,r8
80003a44:	c0 80       	breq	80003a54 <phy_rx_func+0xc80>
80003a46:	fe f8 02 62 	ld.w	r8,pc[610]
80003a4a:	11 89       	ld.ub	r9,r8[0x0]
80003a4c:	30 38       	mov	r8,3
80003a4e:	f0 09 18 00 	cp.b	r9,r8
80003a52:	c1 41       	brne	80003a7a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a54:	6e 29       	ld.w	r9,r7[0x8]
80003a56:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a5a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a5c:	6e 39       	ld.w	r9,r7[0xc]
80003a5e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a60:	fe f9 02 38 	ld.w	r9,pc[568]
80003a64:	72 08       	ld.w	r8,r9[0x0]
80003a66:	20 88       	sub	r8,8
80003a68:	93 08       	st.w	r9[0x0],r8
80003a6a:	e0 81 00 f2 	brne	80003c4e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003a6e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a70:	fe f9 02 20 	ld.w	r9,pc[544]
80003a74:	93 08       	st.w	r9[0x0],r8
80003a76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a7a:	fe f8 02 2e 	ld.w	r8,pc[558]
80003a7e:	11 89       	ld.ub	r9,r8[0x0]
80003a80:	31 38       	mov	r8,19
80003a82:	f0 09 18 00 	cp.b	r9,r8
80003a86:	e0 81 00 9c 	brne	80003bbe <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003a8a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a8e:	11 88       	ld.ub	r8,r8[0x0]
80003a90:	30 c9       	mov	r9,12
80003a92:	f2 08 18 00 	cp.b	r8,r9
80003a96:	e0 81 00 7b 	brne	80003b8c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a9a:	8e 49       	ld.sh	r9,r7[0x8]
80003a9c:	fe f8 02 54 	ld.w	r8,pc[596]
80003aa0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003aa4:	30 09       	mov	r9,0
80003aa6:	fe f8 02 46 	ld.w	r8,pc[582]
80003aaa:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aac:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ab0:	3f 38       	mov	r8,-13
80003ab2:	f0 09 18 00 	cp.b	r9,r8
80003ab6:	c6 61       	brne	80003b82 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ab8:	10 99       	mov	r9,r8
80003aba:	4f c8       	lddpc	r8,80003ca8 <phy_rx_func+0xed4>
80003abc:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003abe:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003ac2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ac6:	4f 58       	lddpc	r8,80003c98 <phy_rx_func+0xec4>
80003ac8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003aca:	30 19       	mov	r9,1
80003acc:	fe f8 02 0c 	ld.w	r8,pc[524]
80003ad0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ad2:	8e 79       	ld.sh	r9,r7[0xe]
80003ad4:	fe f8 02 14 	ld.w	r8,pc[532]
80003ad8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ada:	4f 68       	lddpc	r8,80003cb0 <phy_rx_func+0xedc>
80003adc:	4e c9       	lddpc	r9,80003c8c <phy_rx_func+0xeb8>
80003ade:	72 0a       	ld.w	r10,r9[0x0]
80003ae0:	70 09       	ld.w	r9,r8[0x0]
80003ae2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ae6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003aea:	70 09       	ld.w	r9,r8[0x0]
80003aec:	2f f9       	sub	r9,-1
80003aee:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003af0:	e0 49 01 ff 	cp.w	r9,511
80003af4:	e0 88 00 13 	brls	80003b1a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003af8:	30 09       	mov	r9,0
80003afa:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003afc:	4e 46       	lddpc	r6,80003c8c <phy_rx_func+0xeb8>
80003afe:	6c 0c       	ld.w	r12,r6[0x0]
80003b00:	f0 1f 00 6e 	mcall	80003cb8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b04:	4e 08       	lddpc	r8,80003c84 <phy_rx_func+0xeb0>
80003b06:	70 0c       	ld.w	r12,r8[0x0]
80003b08:	f0 1f 00 59 	mcall	80003c6c <phy_rx_func+0xe98>
80003b0c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b0e:	c0 61       	brne	80003b1a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b10:	30 09       	mov	r9,0
80003b12:	4e 08       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003b14:	91 09       	st.w	r8[0x0],r9
80003b16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b1a:	4e 09       	lddpc	r9,80003c98 <phy_rx_func+0xec4>
80003b1c:	72 08       	ld.w	r8,r9[0x0]
80003b1e:	20 18       	sub	r8,1
80003b20:	93 08       	st.w	r9[0x0],r8
80003b22:	c0 61       	brne	80003b2e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b24:	30 09       	mov	r9,0
80003b26:	4d b8       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003b28:	91 09       	st.w	r8[0x0],r9
80003b2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b2e:	4e 18       	lddpc	r8,80003cb0 <phy_rx_func+0xedc>
80003b30:	4d 79       	lddpc	r9,80003c8c <phy_rx_func+0xeb8>
80003b32:	72 0a       	ld.w	r10,r9[0x0]
80003b34:	70 09       	ld.w	r9,r8[0x0]
80003b36:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b3a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b3e:	70 09       	ld.w	r9,r8[0x0]
80003b40:	2f f9       	sub	r9,-1
80003b42:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b44:	e0 49 01 ff 	cp.w	r9,511
80003b48:	e0 88 00 13 	brls	80003b6e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b4c:	30 09       	mov	r9,0
80003b4e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b50:	4c f7       	lddpc	r7,80003c8c <phy_rx_func+0xeb8>
80003b52:	6e 0c       	ld.w	r12,r7[0x0]
80003b54:	f0 1f 00 59 	mcall	80003cb8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b58:	4c b8       	lddpc	r8,80003c84 <phy_rx_func+0xeb0>
80003b5a:	70 0c       	ld.w	r12,r8[0x0]
80003b5c:	f0 1f 00 44 	mcall	80003c6c <phy_rx_func+0xe98>
80003b60:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b62:	c0 61       	brne	80003b6e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b64:	30 09       	mov	r9,0
80003b66:	4c b8       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003b68:	91 09       	st.w	r8[0x0],r9
80003b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b6e:	4c b9       	lddpc	r9,80003c98 <phy_rx_func+0xec4>
80003b70:	72 08       	ld.w	r8,r9[0x0]
80003b72:	20 18       	sub	r8,1
80003b74:	93 08       	st.w	r9[0x0],r8
80003b76:	c6 c1       	brne	80003c4e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003b78:	30 09       	mov	r9,0
80003b7a:	4c 68       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003b7c:	91 09       	st.w	r8[0x0],r9
80003b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b82:	30 09       	mov	r9,0
80003b84:	4c 38       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003b86:	91 09       	st.w	r8[0x0],r9
80003b88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b8c:	8e 4a       	ld.sh	r10,r7[0x8]
80003b8e:	4d 99       	lddpc	r9,80003cf0 <phy_rx_func+0xf1c>
80003b90:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b94:	4d 6a       	lddpc	r10,80003cec <phy_rx_func+0xf18>
80003b96:	15 88       	ld.ub	r8,r10[0x0]
80003b98:	f0 cb ff ff 	sub	r11,r8,-1
80003b9c:	8e 5c       	ld.sh	r12,r7[0xa]
80003b9e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003ba2:	f0 cb ff fe 	sub	r11,r8,-2
80003ba6:	8e 6c       	ld.sh	r12,r7[0xc]
80003ba8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003bac:	f0 cb ff fd 	sub	r11,r8,-3
80003bb0:	8e 7c       	ld.sh	r12,r7[0xe]
80003bb2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bb6:	2f c8       	sub	r8,-4
80003bb8:	b4 88       	st.b	r10[0x0],r8
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bbe:	30 09       	mov	r9,0
80003bc0:	4b 48       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003bc2:	91 09       	st.w	r8[0x0],r9
80003bc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bc8:	4c 08       	lddpc	r8,80003cc8 <phy_rx_func+0xef4>
80003bca:	70 09       	ld.w	r9,r8[0x0]
80003bcc:	8e 4b       	ld.sh	r11,r7[0x8]
80003bce:	4c 0a       	lddpc	r10,80003ccc <phy_rx_func+0xef8>
80003bd0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bd4:	2f f9       	sub	r9,-1
80003bd6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bd8:	4b 58       	lddpc	r8,80003cac <phy_rx_func+0xed8>
80003bda:	70 09       	ld.w	r9,r8[0x0]
80003bdc:	20 29       	sub	r9,2
80003bde:	91 09       	st.w	r8[0x0],r9
80003be0:	70 08       	ld.w	r8,r8[0x0]
80003be2:	58 08       	cp.w	r8,0
80003be4:	c2 f1       	brne	80003c42 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003be6:	30 09       	mov	r9,0
80003be8:	4b 88       	lddpc	r8,80003cc8 <phy_rx_func+0xef4>
80003bea:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bec:	8e 59       	ld.sh	r9,r7[0xa]
80003bee:	fe 78 82 12 	mov	r8,-32238
80003bf2:	f0 09 19 00 	cp.h	r9,r8
80003bf6:	c2 11       	brne	80003c38 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bf8:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bfc:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c00:	4a f8       	lddpc	r8,80003cbc <phy_rx_func+0xee8>
80003c02:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c04:	8e 59       	ld.sh	r9,r7[0xa]
80003c06:	4a f8       	lddpc	r8,80003cc0 <phy_rx_func+0xeec>
80003c08:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c0a:	8e 69       	ld.sh	r9,r7[0xc]
80003c0c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c0e:	f0 1f 00 2e 	mcall	80003cc4 <phy_rx_func+0xef0>
80003c12:	4a 18       	lddpc	r8,80003c94 <phy_rx_func+0xec0>
80003c14:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c16:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c1a:	31 38       	mov	r8,19
80003c1c:	f0 09 18 00 	cp.b	r9,r8
80003c20:	c0 71       	brne	80003c2e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c22:	10 99       	mov	r9,r8
80003c24:	4a 18       	lddpc	r8,80003ca8 <phy_rx_func+0xed4>
80003c26:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c28:	30 09       	mov	r9,0
80003c2a:	49 c8       	lddpc	r8,80003c98 <phy_rx_func+0xec4>
80003c2c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c2e:	30 49       	mov	r9,4
80003c30:	49 88       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003c32:	91 09       	st.w	r8[0x0],r9
80003c34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c38:	30 09       	mov	r9,0
80003c3a:	49 68       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003c3c:	91 09       	st.w	r8[0x0],r9
80003c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c42:	4a dc       	lddpc	r12,80003cf4 <phy_rx_func+0xf20>
80003c44:	f0 1f 00 18 	mcall	80003ca4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c48:	30 09       	mov	r9,0
80003c4a:	49 28       	lddpc	r8,80003c90 <phy_rx_func+0xebc>
80003c4c:	91 09       	st.w	r8[0x0],r9
80003c4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c52:	00 00       	add	r0,r0
80003c54:	00 00       	add	r0,r0
80003c56:	0a b4       	st.h	r5++,r4
80003c58:	00 00       	add	r0,r0
80003c5a:	0a cc       	st.b	r5++,r12
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a ac       	st.w	r5++,r12
80003c60:	00 00       	add	r0,r0
80003c62:	0a 8e       	andn	lr,r5
80003c64:	00 00       	add	r0,r0
80003c66:	0a 7c       	tst	r12,r5
80003c68:	00 00       	add	r0,r0
80003c6a:	0a a4       	st.w	r5++,r4
80003c6c:	80 00       	ld.sh	r0,r0[0x0]
80003c6e:	2c 54       	sub	r4,-59
80003c70:	00 00       	add	r0,r0
80003c72:	0a 9c       	mov	r12,r5
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	2b 6c       	sub	r12,-74
80003c78:	00 00       	add	r0,r0
80003c7a:	0a b0       	st.h	r5++,r0
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	2b a0       	sub	r0,-70
80003c80:	00 00       	add	r0,r0
80003c82:	0a 8d       	andn	sp,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a a8       	st.w	r5++,r8
80003c88:	00 00       	add	r0,r0
80003c8a:	0a b8       	st.h	r5++,r8
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a 90       	mov	r0,r5
80003c90:	00 00       	add	r0,r0
80003c92:	0a d8       	st.w	--r5,r8
80003c94:	00 00       	add	r0,r0
80003c96:	0a c0       	st.b	r5++,r0
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 78       	tst	r8,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a 60       	and	r0,r5
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	d7 68       	*unknown*
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	71 60       	ld.w	r0,r8[0x58]
80003ca8:	00 00       	add	r0,r0
80003caa:	0a 8c       	andn	r12,r5
80003cac:	00 00       	add	r0,r0
80003cae:	0a e4       	st.h	--r5,r4
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a c4       	st.b	r5++,r4
80003cb4:	80 00       	ld.sh	r0,r0[0x0]
80003cb6:	79 a0       	ld.w	r0,r12[0x68]
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	2b 88       	sub	r8,-72
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a 50       	eor	r0,r5
80003cc0:	00 00       	add	r0,r0
80003cc2:	21 2c       	sub	r12,18
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	2b 3c       	sub	r12,-77
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 80       	andn	r0,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	20 30       	sub	r0,3
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 84       	andn	r4,r5
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 64       	and	r4,r5
80003cd8:	00 00       	add	r0,r0
80003cda:	0a 49       	or	r9,r5
80003cdc:	00 00       	add	r0,r0
80003cde:	0a dc       	st.w	--r5,r12
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a 98       	mov	r8,r5
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a 65       	and	r5,r5
80003ce8:	00 00       	add	r0,r0
80003cea:	20 28       	sub	r8,2
80003cec:	00 00       	add	r0,r0
80003cee:	0a d0       	st.w	--r5,r0
80003cf0:	00 00       	add	r0,r0
80003cf2:	21 30       	sub	r0,19
80003cf4:	80 00       	ld.sh	r0,r0[0x0]
80003cf6:	d7 80       	acall	0x78

80003cf8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cf8:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003cfa:	30 09       	mov	r9,0
80003cfc:	49 b8       	lddpc	r8,80003d68 <pdca_int_handler+0x70>
80003cfe:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d00:	49 b8       	lddpc	r8,80003d6c <pdca_int_handler+0x74>
80003d02:	70 09       	ld.w	r9,r8[0x0]
80003d04:	2f f9       	sub	r9,-1
80003d06:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d08:	49 a8       	lddpc	r8,80003d70 <pdca_int_handler+0x78>
80003d0a:	11 89       	ld.ub	r9,r8[0x0]
80003d0c:	ec 19 00 01 	eorl	r9,0x1
80003d10:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d12:	11 89       	ld.ub	r9,r8[0x0]
80003d14:	a5 69       	lsl	r9,0x4
80003d16:	2f c9       	sub	r9,-4
80003d18:	49 7a       	lddpc	r10,80003d74 <pdca_int_handler+0x7c>
80003d1a:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d1c:	fe 7a 00 40 	mov	r10,-65472
80003d20:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d22:	30 39       	mov	r9,3
80003d24:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d26:	11 8a       	ld.ub	r10,r8[0x0]
80003d28:	a5 6a       	lsl	r10,0x4
80003d2a:	2f ca       	sub	r10,-4
80003d2c:	49 38       	lddpc	r8,80003d78 <pdca_int_handler+0x80>
80003d2e:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d30:	fe 78 00 00 	mov	r8,-65536
80003d34:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d36:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d38:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d3a:	49 18       	lddpc	r8,80003d7c <pdca_int_handler+0x84>
80003d3c:	70 08       	ld.w	r8,r8[0x0]
80003d3e:	58 08       	cp.w	r8,0
80003d40:	c0 70       	breq	80003d4e <pdca_int_handler+0x56>
80003d42:	48 c9       	lddpc	r9,80003d70 <pdca_int_handler+0x78>
80003d44:	13 89       	ld.ub	r9,r9[0x0]
80003d46:	a5 69       	lsl	r9,0x4
80003d48:	48 cc       	lddpc	r12,80003d78 <pdca_int_handler+0x80>
80003d4a:	12 0c       	add	r12,r9
80003d4c:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d4e:	48 d8       	lddpc	r8,80003d80 <pdca_int_handler+0x88>
80003d50:	70 08       	ld.w	r8,r8[0x0]
80003d52:	58 08       	cp.w	r8,0
80003d54:	c0 70       	breq	80003d62 <pdca_int_handler+0x6a>
80003d56:	48 79       	lddpc	r9,80003d70 <pdca_int_handler+0x78>
80003d58:	13 89       	ld.ub	r9,r9[0x0]
80003d5a:	a5 69       	lsl	r9,0x4
80003d5c:	48 6c       	lddpc	r12,80003d74 <pdca_int_handler+0x7c>
80003d5e:	12 0c       	add	r12,r9
80003d60:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d62:	d4 02       	popm	lr
80003d64:	d6 03       	rete
80003d66:	00 00       	add	r0,r0
80003d68:	00 00       	add	r0,r0
80003d6a:	0a ec       	st.h	--r5,r12
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a f0       	st.b	--r5,r0
80003d70:	00 00       	add	r0,r0
80003d72:	53 50       	stdsp	sp[0xd4],r0
80003d74:	00 00       	add	r0,r0
80003d76:	53 78       	stdsp	sp[0xdc],r8
80003d78:	00 00       	add	r0,r0
80003d7a:	53 58       	stdsp	sp[0xd4],r8
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a e8       	st.h	--r5,r8
80003d80:	00 00       	add	r0,r0
80003d82:	0a f4       	st.b	--r5,r4

80003d84 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d84:	fe 78 10 00 	mov	r8,-61440
80003d88:	e0 69 0d c0 	mov	r9,3520
80003d8c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d90:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d94:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d98:	fe 78 34 00 	mov	r8,-52224
80003d9c:	e0 69 80 00 	mov	r9,32768
80003da0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003da2:	30 09       	mov	r9,0
80003da4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003da6:	e0 69 04 21 	mov	r9,1057
80003daa:	ea 19 3f 20 	orh	r9,0x3f20
80003dae:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003db0:	e0 69 02 9f 	mov	r9,671
80003db4:	ea 19 01 00 	orh	r9,0x100
80003db8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003dba:	e0 6a 04 02 	mov	r10,1026
80003dbe:	ea 1a 3f 20 	orh	r10,0x3f20
80003dc2:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003dc4:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dc6:	5e fc       	retal	r12

80003dc8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dc8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dca:	30 19       	mov	r9,1
80003dcc:	49 78       	lddpc	r8,80003e28 <local_start_PDC+0x60>
80003dce:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dd0:	fe 78 00 00 	mov	r8,-65536
80003dd4:	30 7b       	mov	r11,7
80003dd6:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003dd8:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003dda:	49 59       	lddpc	r9,80003e2c <local_start_PDC+0x64>
80003ddc:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003de0:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003de2:	30 3a       	mov	r10,3
80003de4:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003de6:	30 1c       	mov	r12,1
80003de8:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003dea:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003dec:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dee:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003df0:	30 2c       	mov	r12,2
80003df2:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003df4:	48 f9       	lddpc	r9,80003e30 <local_start_PDC+0x68>
80003df6:	e0 68 5a 5a 	mov	r8,23130
80003dfa:	ea 18 ab cd 	orh	r8,0xabcd
80003dfe:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e00:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e02:	30 0e       	mov	lr,0
80003e04:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e06:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e08:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e0a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e0c:	fe 78 00 40 	mov	r8,-65472
80003e10:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e12:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e14:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e18:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e1a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e1c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e1e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e20:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e22:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e24:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e26:	d8 02       	popm	pc
80003e28:	00 00       	add	r0,r0
80003e2a:	53 50       	stdsp	sp[0xd4],r0
80003e2c:	00 00       	add	r0,r0
80003e2e:	53 58       	stdsp	sp[0xd4],r8
80003e30:	00 00       	add	r0,r0
80003e32:	53 78       	stdsp	sp[0xdc],r8

80003e34 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e34:	48 38       	lddpc	r8,80003e40 <register_rx_tx_func+0xc>
80003e36:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e38:	48 38       	lddpc	r8,80003e44 <register_rx_tx_func+0x10>
80003e3a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e3c:	5e fc       	retal	r12
80003e3e:	00 00       	add	r0,r0
80003e40:	00 00       	add	r0,r0
80003e42:	0a e8       	st.h	--r5,r8
80003e44:	00 00       	add	r0,r0
80003e46:	0a f4       	st.b	--r5,r4

80003e48 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e48:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e4a:	fe 78 10 00 	mov	r8,-61440
80003e4e:	30 29       	mov	r9,2
80003e50:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e54:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e58:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e5a:	30 3a       	mov	r10,3
80003e5c:	36 0b       	mov	r11,96
80003e5e:	49 4c       	lddpc	r12,80003eac <ssc_init+0x64>
80003e60:	f0 1f 00 14 	mcall	80003eb0 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e64:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e66:	fe 79 10 00 	mov	r9,-61440
80003e6a:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e6e:	e2 18 00 02 	andl	r8,0x2,COH
80003e72:	cf c0       	breq	80003e6a <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e74:	fe 79 10 00 	mov	r9,-61440
80003e78:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e7c:	e2 18 00 02 	andl	r8,0x2,COH
80003e80:	cf c1       	brne	80003e78 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003e82:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003e84:	f0 1f 00 0c 	mcall	80003eb4 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003e88:	f0 1f 00 0c 	mcall	80003eb8 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e8c:	fe 79 00 00 	mov	r9,-65536
80003e90:	30 18       	mov	r8,1
80003e92:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e94:	fe 7a 00 40 	mov	r10,-65472
80003e98:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e9a:	e0 6b 01 01 	mov	r11,257
80003e9e:	fe 7a 34 00 	mov	r10,-52224
80003ea2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ea4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ea6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ea8:	d8 02       	popm	pc
80003eaa:	00 00       	add	r0,r0
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3c f8       	mov	r8,-49
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	54 3c       	stdsp	sp[0x10c],r12
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3d 84       	mov	r4,-40
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	3d c8       	mov	r8,-36

80003ebc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ebc:	48 28       	lddpc	r8,80003ec4 <xcmp_register_app_list+0x8>
80003ebe:	91 0c       	st.w	r8[0x0],r12
}
80003ec0:	5e fc       	retal	r12
80003ec2:	00 00       	add	r0,r0
80003ec4:	00 00       	add	r0,r0
80003ec6:	53 98       	stdsp	sp[0xe4],r8

80003ec8 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ec8:	eb cd 40 80 	pushm	r7,lr
80003ecc:	fa cd 01 00 	sub	sp,sp,256
80003ed0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003ed2:	16 98       	mov	r8,r11
80003ed4:	2f 08       	sub	r8,-16
80003ed6:	af a8       	sbr	r8,0xe
80003ed8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003eda:	3f f8       	mov	r8,-1
80003edc:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003ede:	30 b9       	mov	r9,11
80003ee0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003ee2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ee4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ee6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ee8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003eea:	f6 ca ff fe 	sub	r10,r11,-2
80003eee:	18 9b       	mov	r11,r12
80003ef0:	fa cc ff f0 	sub	r12,sp,-16
80003ef4:	f0 1f 00 05 	mcall	80003f08 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ef8:	2f e7       	sub	r7,-2
80003efa:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003efc:	1a 9c       	mov	r12,sp
80003efe:	f0 1f 00 04 	mcall	80003f0c <xcmp_tx+0x44>
}
80003f02:	2c 0d       	sub	sp,-256
80003f04:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	78 58       	ld.w	r8,r12[0x14]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	44 d4       	lddsp	r4,sp[0x134]

80003f10 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f10:	d4 21       	pushm	r4-r7,lr
80003f12:	fa cd 00 d0 	sub	sp,sp,208
80003f16:	18 94       	mov	r4,r12
80003f18:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f1a:	e0 68 01 00 	mov	r8,256
80003f1e:	f0 0b 19 00 	cp.h	r11,r8
80003f22:	e0 8b 00 36 	brhi	80003f8e <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f26:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f2a:	e0 68 04 1d 	mov	r8,1053
80003f2e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f30:	30 18       	mov	r8,1
80003f32:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f34:	32 08       	mov	r8,32
80003f36:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f38:	30 28       	mov	r8,2
80003f3a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f3c:	30 48       	mov	r8,4
80003f3e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f40:	ea 1a 0c 00 	orh	r10,0xc00
80003f44:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f46:	30 4a       	mov	r10,4
80003f48:	1a 9b       	mov	r11,sp
80003f4a:	fa cc ff f4 	sub	r12,sp,-12
80003f4e:	f0 1f 00 12 	mcall	80003f94 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f52:	30 f8       	mov	r8,15
80003f54:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f58:	3a 78       	mov	r8,-89
80003f5a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f5e:	30 08       	mov	r8,0
80003f60:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f64:	0e 9a       	mov	r10,r7
80003f66:	5c 7a       	castu.h	r10
80003f68:	f4 08 16 08 	lsr	r8,r10,0x8
80003f6c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003f70:	0e 96       	mov	r6,r7
80003f72:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003f76:	08 9b       	mov	r11,r4
80003f78:	fa cc ff eb 	sub	r12,sp,-21
80003f7c:	f0 1f 00 06 	mcall	80003f94 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003f80:	ee cb ff f3 	sub	r11,r7,-13
80003f84:	5c 5b       	castu.b	r11
80003f86:	fa cc ff fa 	sub	r12,sp,-6
80003f8a:	f0 1f 00 04 	mcall	80003f98 <xcmp_data_session_req+0x88>
}
80003f8e:	2c cd       	sub	sp,-208
80003f90:	d8 22       	popm	r4-r7,pc
80003f92:	00 00       	add	r0,r0
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	78 58       	ld.w	r8,r12[0x14]
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3e c8       	mov	r8,-20

80003f9c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f9c:	d4 01       	pushm	lr
80003f9e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fa2:	fe 78 b4 00 	mov	r8,-19456
80003fa6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fa8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fac:	30 89       	mov	r9,8
80003fae:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fb0:	30 19       	mov	r9,1
80003fb2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb4:	30 09       	mov	r9,0
80003fb6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fb8:	30 5a       	mov	r10,5
80003fba:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fbc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fbe:	30 7a       	mov	r10,7
80003fc0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fc2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fc6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fca:	30 9b       	mov	r11,9
80003fcc:	fa cc ff fe 	sub	r12,sp,-2
80003fd0:	f0 1f 00 02 	mcall	80003fd8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd4:	2c dd       	sub	sp,-204
80003fd6:	d8 02       	popm	pc
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	3e c8       	mov	r8,-20

80003fdc <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fdc:	d4 01       	pushm	lr
80003fde:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fe2:	fe 78 80 00 	mov	r8,-32768
80003fe6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fe8:	30 38       	mov	r8,3
80003fea:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fec:	30 1b       	mov	r11,1
80003fee:	fa cc ff fe 	sub	r12,sp,-2
80003ff2:	f0 1f 00 03 	mcall	80003ffc <xcmp_opcode_not_supported+0x20>
}
80003ff6:	2c dd       	sub	sp,-204
80003ff8:	d8 02       	popm	pc
80003ffa:	00 00       	add	r0,r0
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	3e c8       	mov	r8,-20

80004000 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004000:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004002:	96 88       	ld.uh	r8,r11[0x0]
80004004:	e2 18 f0 00 	andl	r8,0xf000,COH
80004008:	e0 48 80 00 	cp.w	r8,32768
8000400c:	c0 f0       	breq	8000402a <xcmp_exec_func+0x2a>
8000400e:	e0 48 b0 00 	cp.w	r8,45056
80004012:	c1 20       	breq	80004036 <xcmp_exec_func+0x36>
80004014:	58 08       	cp.w	r8,0
80004016:	c1 51       	brne	80004040 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004018:	78 08       	ld.w	r8,r12[0x0]
8000401a:	58 08       	cp.w	r8,0
8000401c:	c0 40       	breq	80004024 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000401e:	16 9c       	mov	r12,r11
80004020:	5d 18       	icall	r8
80004022:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004024:	f0 1f 00 08 	mcall	80004044 <xcmp_exec_func+0x44>
80004028:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000402a:	78 18       	ld.w	r8,r12[0x4]
8000402c:	58 08       	cp.w	r8,0
8000402e:	c0 90       	breq	80004040 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004030:	16 9c       	mov	r12,r11
80004032:	5d 18       	icall	r8
80004034:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004036:	78 28       	ld.w	r8,r12[0x8]
80004038:	58 08       	cp.w	r8,0
8000403a:	c0 30       	breq	80004040 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000403c:	16 9c       	mov	r12,r11
8000403e:	5d 18       	icall	r8
80004040:	d8 02       	popm	pc
80004042:	00 00       	add	r0,r0
80004044:	80 00       	ld.sh	r0,r0[0x0]
80004046:	3f dc       	mov	r12,-3

80004048 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004048:	d4 01       	pushm	lr
8000404a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000404e:	e0 68 04 09 	mov	r8,1033
80004052:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004054:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004058:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000405a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000405e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004060:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004062:	30 09       	mov	r9,0
80004064:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004066:	fb 69 00 08 	st.b	sp[8],r9
8000406a:	fa c8 ff f7 	sub	r8,sp,-9
8000406e:	b0 89       	st.b	r8[0x0],r9
80004070:	fa c8 ff f6 	sub	r8,sp,-10
80004074:	b0 89       	st.b	r8[0x0],r9
80004076:	fa c8 ff f5 	sub	r8,sp,-11
8000407a:	b0 89       	st.b	r8[0x0],r9
8000407c:	fa c8 ff f4 	sub	r8,sp,-12
80004080:	b0 89       	st.b	r8[0x0],r9
80004082:	fa c8 ff f3 	sub	r8,sp,-13
80004086:	b0 89       	st.b	r8[0x0],r9
80004088:	fa c8 ff f2 	sub	r8,sp,-14
8000408c:	b0 89       	st.b	r8[0x0],r9
8000408e:	fa c8 ff f1 	sub	r8,sp,-15
80004092:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004094:	30 cb       	mov	r11,12
80004096:	fa cc ff fe 	sub	r12,sp,-2
8000409a:	f0 1f 00 03 	mcall	800040a4 <xcmp_IdleTestTone+0x5c>
}
8000409e:	2c dd       	sub	sp,-204
800040a0:	d8 02       	popm	pc
800040a2:	00 00       	add	r0,r0
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	3e c8       	mov	r8,-20

800040a8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040a8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040aa:	48 dc       	lddpc	r12,800040dc <xcmp_init+0x34>
800040ac:	f0 1f 00 0d 	mcall	800040e0 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040b0:	30 4b       	mov	r11,4
800040b2:	31 4c       	mov	r12,20
800040b4:	f0 1f 00 0c 	mcall	800040e4 <xcmp_init+0x3c>
800040b8:	48 c8       	lddpc	r8,800040e8 <xcmp_init+0x40>
800040ba:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040bc:	30 09       	mov	r9,0
800040be:	1a d9       	st.w	--sp,r9
800040c0:	1a d9       	st.w	--sp,r9
800040c2:	1a d9       	st.w	--sp,r9
800040c4:	30 38       	mov	r8,3
800040c6:	e0 6a 04 00 	mov	r10,1024
800040ca:	48 9b       	lddpc	r11,800040ec <xcmp_init+0x44>
800040cc:	48 9c       	lddpc	r12,800040f0 <xcmp_init+0x48>
800040ce:	f0 1f 00 0a 	mcall	800040f4 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040d2:	f0 1f 00 0a 	mcall	800040f8 <xcmp_init+0x50>
800040d6:	2f dd       	sub	sp,-12
	
}
800040d8:	d8 02       	popm	pc
800040da:	00 00       	add	r0,r0
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	41 f8       	lddsp	r8,sp[0x7c]
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	42 44       	lddsp	r4,sp[0x90]
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	64 f4       	ld.w	r4,r2[0x3c]
800040e8:	00 00       	add	r0,r0
800040ea:	0b 10       	ld.sh	r0,r5++
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	d7 ac       	*unknown*
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	40 fc       	lddsp	r12,sp[0x3c]
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	6c 10       	ld.w	r0,r6[0x4]
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	42 7c       	lddsp	r12,sp[0x9c]

800040fc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040fc:	d4 31       	pushm	r0-r7,lr
800040fe:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004100:	4b 16       	lddpc	r6,800041c4 <xcmp_rx_process+0xc8>
80004102:	30 05       	mov	r5,0
80004104:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004106:	4b 13       	lddpc	r3,800041c8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004108:	4b 12       	lddpc	r2,800041cc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000410a:	4b 21       	lddpc	r1,800041d0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000410c:	4b 20       	lddpc	r0,800041d4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000410e:	6c 0c       	ld.w	r12,r6[0x0]
80004110:	0a 99       	mov	r9,r5
80004112:	08 9a       	mov	r10,r4
80004114:	1a 9b       	mov	r11,sp
80004116:	f0 1f 00 31 	mcall	800041d8 <xcmp_rx_process+0xdc>
8000411a:	58 1c       	cp.w	r12,1
8000411c:	cf 91       	brne	8000410e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000411e:	40 0b       	lddsp	r11,sp[0x0]
80004120:	58 0b       	cp.w	r11,0
80004122:	cf 60       	breq	8000410e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004124:	96 0a       	ld.sh	r10,r11[0x0]
80004126:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000412a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000412e:	59 c8       	cp.w	r8,28
80004130:	c1 e0       	breq	8000416c <xcmp_rx_process+0x70>
80004132:	e0 89 00 07 	brgt	80004140 <xcmp_rx_process+0x44>
80004136:	58 e8       	cp.w	r8,14
80004138:	c0 e0       	breq	80004154 <xcmp_rx_process+0x58>
8000413a:	58 f8       	cp.w	r8,15
8000413c:	c2 41       	brne	80004184 <xcmp_rx_process+0x88>
8000413e:	c0 f8       	rjmp	8000415c <xcmp_rx_process+0x60>
80004140:	e0 48 01 09 	cp.w	r8,265
80004144:	c1 80       	breq	80004174 <xcmp_rx_process+0x78>
80004146:	e0 48 01 0a 	cp.w	r8,266
8000414a:	c1 90       	breq	8000417c <xcmp_rx_process+0x80>
8000414c:	e0 48 00 2c 	cp.w	r8,44
80004150:	c1 a1       	brne	80004184 <xcmp_rx_process+0x88>
80004152:	c0 98       	rjmp	80004164 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004154:	4a 2c       	lddpc	r12,800041dc <xcmp_rx_process+0xe0>
80004156:	f0 1f 00 23 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000415a:	c2 f8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000415c:	4a 2c       	lddpc	r12,800041e4 <xcmp_rx_process+0xe8>
8000415e:	f0 1f 00 21 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
80004162:	c2 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004164:	4a 1c       	lddpc	r12,800041e8 <xcmp_rx_process+0xec>
80004166:	f0 1f 00 1f 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000416a:	c2 78       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000416c:	04 9c       	mov	r12,r2
8000416e:	f0 1f 00 1d 	mcall	800041e0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004172:	c2 38       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004174:	02 9c       	mov	r12,r1
80004176:	f0 1f 00 1b 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000417a:	c1 f8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000417c:	00 9c       	mov	r12,r0
8000417e:	f0 1f 00 19 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
80004182:	c1 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004184:	12 98       	mov	r8,r9
80004186:	e2 18 04 00 	andl	r8,0x400,COH
8000418a:	c0 70       	breq	80004198 <xcmp_rx_process+0x9c>
8000418c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004190:	e0 48 00 68 	cp.w	r8,104
80004194:	e0 8a 00 08 	brle	800041a4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004198:	e2 19 f0 00 	andl	r9,0xf000,COH
8000419c:	c0 e1       	brne	800041b8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000419e:	f0 1f 00 14 	mcall	800041ec <xcmp_rx_process+0xf0>
800041a2:	c0 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041a8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041ac:	49 19       	lddpc	r9,800041f0 <xcmp_rx_process+0xf4>
800041ae:	72 08       	ld.w	r8,r9[0x0]
800041b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b4:	f0 1f 00 0b 	mcall	800041e0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041b8:	66 0c       	ld.w	r12,r3[0x0]
800041ba:	40 0b       	lddsp	r11,sp[0x0]
800041bc:	f0 1f 00 0e 	mcall	800041f4 <xcmp_rx_process+0xf8>
800041c0:	ca 7b       	rjmp	8000410e <xcmp_rx_process+0x12>
800041c2:	00 00       	add	r0,r0
800041c4:	00 00       	add	r0,r0
800041c6:	0b 10       	ld.sh	r0,r5++
800041c8:	00 00       	add	r0,r0
800041ca:	0a a4       	st.w	r5++,r4
800041cc:	00 00       	add	r0,r0
800041ce:	0b 20       	ld.uh	r0,r5++
800041d0:	00 00       	add	r0,r0
800041d2:	0b 14       	ld.sh	r4,r5++
800041d4:	00 00       	add	r0,r0
800041d6:	0b 04       	ld.w	r4,r5++
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	61 90       	ld.w	r0,r0[0x64]
800041dc:	00 00       	add	r0,r0
800041de:	0b 38       	ld.ub	r8,r5++
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	40 00       	lddsp	r0,sp[0x0]
800041e4:	00 00       	add	r0,r0
800041e6:	0a f8       	st.b	--r5,r8
800041e8:	00 00       	add	r0,r0
800041ea:	0b 2c       	ld.uh	r12,r5++
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	3f dc       	mov	r12,-3
800041f0:	00 00       	add	r0,r0
800041f2:	53 98       	stdsp	sp[0xe4],r8
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	2b d8       	sub	r8,-67

800041f8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041f8:	eb cd 40 90 	pushm	r4,r7,lr
800041fc:	20 1d       	sub	sp,4
800041fe:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004202:	48 c8       	lddpc	r8,80004230 <xcmp_rx+0x38>
80004204:	70 0c       	ld.w	r12,r8[0x0]
80004206:	f0 1f 00 0c 	mcall	80004234 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000420a:	c1 00       	breq	8000422a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000420c:	fa c7 ff fc 	sub	r7,sp,-4
80004210:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004212:	e0 6a 00 ca 	mov	r10,202
80004216:	08 9b       	mov	r11,r4
80004218:	f0 1f 00 08 	mcall	80004238 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000421c:	48 88       	lddpc	r8,8000423c <xcmp_rx+0x44>
8000421e:	70 0c       	ld.w	r12,r8[0x0]
80004220:	30 09       	mov	r9,0
80004222:	12 9a       	mov	r10,r9
80004224:	1a 9b       	mov	r11,sp
80004226:	f0 1f 00 07 	mcall	80004240 <xcmp_rx+0x48>
	}	
}
8000422a:	2f fd       	sub	sp,-4
8000422c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004230:	00 00       	add	r0,r0
80004232:	0a a4       	st.w	r5++,r4
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	2d 84       	sub	r4,-40
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	78 58       	ld.w	r8,r12[0x14]
8000423c:	00 00       	add	r0,r0
8000423e:	0b 10       	ld.sh	r0,r5++
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	63 9c       	ld.w	r12,r1[0x64]

80004244 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004244:	48 28       	lddpc	r8,8000424c <xnl_register_xcmp_func+0x8>
80004246:	91 0c       	st.w	r8[0x0],r12
}
80004248:	5e fc       	retal	r12
8000424a:	00 00       	add	r0,r0
8000424c:	00 00       	add	r0,r0
8000424e:	0b 64       	ld.uh	r4,--r5

80004250 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004250:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004252:	48 88       	lddpc	r8,80004270 <xnl_get_msg_ack_func+0x20>
80004254:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004256:	98 49       	ld.sh	r9,r12[0x8]
80004258:	f0 09 19 00 	cp.h	r9,r8
8000425c:	c0 81       	brne	8000426c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000425e:	48 68       	lddpc	r8,80004274 <xnl_get_msg_ack_func+0x24>
80004260:	70 0c       	ld.w	r12,r8[0x0]
80004262:	30 09       	mov	r9,0
80004264:	12 9a       	mov	r10,r9
80004266:	12 9b       	mov	r11,r9
80004268:	f0 1f 00 04 	mcall	80004278 <xnl_get_msg_ack_func+0x28>
8000426c:	d8 02       	popm	pc
8000426e:	00 00       	add	r0,r0
80004270:	00 00       	add	r0,r0
80004272:	0b 4a       	ld.w	r10,--r5
80004274:	00 00       	add	r0,r0
80004276:	0b 44       	ld.w	r4,--r5
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	63 9c       	ld.w	r12,r1[0x64]

8000427c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000427c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004280:	30 09       	mov	r9,0
80004282:	4b 78       	lddpc	r8,8000435c <xnl_init+0xe0>
80004284:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004286:	30 0b       	mov	r11,0
80004288:	30 1c       	mov	r12,1
8000428a:	f0 1f 00 36 	mcall	80004360 <xnl_init+0xe4>
8000428e:	4b 68       	lddpc	r8,80004364 <xnl_init+0xe8>
80004290:	91 0c       	st.w	r8[0x0],r12
80004292:	70 08       	ld.w	r8,r8[0x0]
80004294:	58 08       	cp.w	r8,0
80004296:	c0 80       	breq	800042a6 <xnl_init+0x2a>
80004298:	4b 38       	lddpc	r8,80004364 <xnl_init+0xe8>
8000429a:	70 0c       	ld.w	r12,r8[0x0]
8000429c:	30 09       	mov	r9,0
8000429e:	12 9a       	mov	r10,r9
800042a0:	12 9b       	mov	r11,r9
800042a2:	f0 1f 00 32 	mcall	80004368 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042a6:	30 4b       	mov	r11,4
800042a8:	31 4c       	mov	r12,20
800042aa:	f0 1f 00 2e 	mcall	80004360 <xnl_init+0xe4>
800042ae:	4b 08       	lddpc	r8,8000436c <xnl_init+0xf0>
800042b0:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042b2:	30 4b       	mov	r11,4
800042b4:	31 ec       	mov	r12,30
800042b6:	f0 1f 00 2b 	mcall	80004360 <xnl_init+0xe4>
800042ba:	4a e8       	lddpc	r8,80004370 <xnl_init+0xf4>
800042bc:	91 0c       	st.w	r8[0x0],r12
800042be:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042c0:	10 96       	mov	r6,r8
800042c2:	4a d5       	lddpc	r5,80004374 <xnl_init+0xf8>
800042c4:	6c 0c       	ld.w	r12,r6[0x0]
800042c6:	ea 07 00 0b 	add	r11,r5,r7
800042ca:	f0 1f 00 2c 	mcall	80004378 <xnl_init+0xfc>
800042ce:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800042d2:	e0 47 1e 00 	cp.w	r7,7680
800042d6:	cf 71       	brne	800042c4 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042d8:	30 4b       	mov	r11,4
800042da:	31 4c       	mov	r12,20
800042dc:	f0 1f 00 21 	mcall	80004360 <xnl_init+0xe4>
800042e0:	4a 78       	lddpc	r8,8000437c <xnl_init+0x100>
800042e2:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042e4:	30 4b       	mov	r11,4
800042e6:	30 ac       	mov	r12,10
800042e8:	f0 1f 00 1e 	mcall	80004360 <xnl_init+0xe4>
800042ec:	4a 58       	lddpc	r8,80004380 <xnl_init+0x104>
800042ee:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800042f0:	30 4b       	mov	r11,4
800042f2:	30 ac       	mov	r12,10
800042f4:	f0 1f 00 1b 	mcall	80004360 <xnl_init+0xe4>
800042f8:	4a 38       	lddpc	r8,80004384 <xnl_init+0x108>
800042fa:	91 0c       	st.w	r8[0x0],r12
800042fc:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800042fe:	10 96       	mov	r6,r8
80004300:	4a 25       	lddpc	r5,80004388 <xnl_init+0x10c>
80004302:	6c 0c       	ld.w	r12,r6[0x0]
80004304:	ea 07 00 0b 	add	r11,r5,r7
80004308:	f0 1f 00 1c 	mcall	80004378 <xnl_init+0xfc>
8000430c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004310:	e0 47 14 00 	cp.w	r7,5120
80004314:	cf 71       	brne	80004302 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004316:	30 4b       	mov	r11,4
80004318:	30 5c       	mov	r12,5
8000431a:	f0 1f 00 12 	mcall	80004360 <xnl_init+0xe4>
8000431e:	49 c8       	lddpc	r8,8000438c <xnl_init+0x110>
80004320:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004322:	30 07       	mov	r7,0
80004324:	1a d7       	st.w	--sp,r7
80004326:	1a d7       	st.w	--sp,r7
80004328:	1a d7       	st.w	--sp,r7
8000432a:	30 38       	mov	r8,3
8000432c:	0e 99       	mov	r9,r7
8000432e:	e0 6a 00 dc 	mov	r10,220
80004332:	49 8b       	lddpc	r11,80004390 <xnl_init+0x114>
80004334:	49 8c       	lddpc	r12,80004394 <xnl_init+0x118>
80004336:	f0 1f 00 19 	mcall	80004398 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000433a:	1a d7       	st.w	--sp,r7
8000433c:	1a d7       	st.w	--sp,r7
8000433e:	1a d7       	st.w	--sp,r7
80004340:	30 38       	mov	r8,3
80004342:	0e 99       	mov	r9,r7
80004344:	e0 6a 00 82 	mov	r10,130
80004348:	49 5b       	lddpc	r11,8000439c <xnl_init+0x120>
8000434a:	49 6c       	lddpc	r12,800043a0 <xnl_init+0x124>
8000434c:	f0 1f 00 13 	mcall	80004398 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004350:	f0 1f 00 15 	mcall	800043a4 <xnl_init+0x128>
80004354:	2f ad       	sub	sp,-24
}
80004356:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000435a:	00 00       	add	r0,r0
8000435c:	00 00       	add	r0,r0
8000435e:	0b 4a       	ld.w	r10,--r5
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	64 f4       	ld.w	r4,r2[0x3c]
80004364:	00 00       	add	r0,r0
80004366:	0b 44       	ld.w	r4,--r5
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	63 9c       	ld.w	r12,r1[0x64]
8000436c:	00 00       	add	r0,r0
8000436e:	0b 58       	ld.sh	r8,--r5
80004370:	00 00       	add	r0,r0
80004372:	0a a4       	st.w	r5++,r4
80004374:	00 00       	add	r0,r0
80004376:	35 4a       	mov	r10,84
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	2b d8       	sub	r8,-67
8000437c:	00 00       	add	r0,r0
8000437e:	0a d4       	st.w	--r5,r4
80004380:	00 00       	add	r0,r0
80004382:	0a b4       	st.h	r5++,r4
80004384:	00 00       	add	r0,r0
80004386:	0a a8       	st.w	r5++,r8
80004388:	00 00       	add	r0,r0
8000438a:	21 4a       	sub	r10,20
8000438c:	00 00       	add	r0,r0
8000438e:	0a e0       	st.h	--r5,r0
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	d7 b4       	*unknown*
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	43 a8       	lddsp	r8,sp[0xe8]
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	6c 10       	ld.w	r0,r6[0x4]
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	d7 bc       	*unknown*
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	44 08       	lddsp	r8,sp[0x100]
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	2d ac       	sub	r12,-38

800043a8 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043a8:	eb cd 40 fe 	pushm	r1-r7,lr
800043ac:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043ae:	49 26       	lddpc	r6,800043f4 <xnl_rx_process+0x4c>
800043b0:	30 05       	mov	r5,0
800043b2:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043b4:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043b6:	49 11       	lddpc	r1,800043f8 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043b8:	49 12       	lddpc	r2,800043fc <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043ba:	6c 0c       	ld.w	r12,r6[0x0]
800043bc:	0a 99       	mov	r9,r5
800043be:	08 9a       	mov	r10,r4
800043c0:	1a 9b       	mov	r11,sp
800043c2:	f0 1f 00 10 	mcall	80004400 <xnl_rx_process+0x58>
800043c6:	58 1c       	cp.w	r12,1
800043c8:	cf 91       	brne	800043ba <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043ca:	40 0c       	lddsp	r12,sp[0x0]
800043cc:	58 0c       	cp.w	r12,0
800043ce:	cf 60       	breq	800043ba <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043d0:	98 28       	ld.sh	r8,r12[0x4]
800043d2:	e6 08 19 00 	cp.h	r8,r3
800043d6:	e0 8b 00 0a 	brhi	800043ea <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043da:	5c 78       	castu.h	r8
800043dc:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800043e0:	58 09       	cp.w	r9,0
800043e2:	c0 40       	breq	800043ea <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800043e4:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043e8:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ea:	62 0c       	ld.w	r12,r1[0x0]
800043ec:	40 0b       	lddsp	r11,sp[0x0]
800043ee:	f0 1f 00 06 	mcall	80004404 <xnl_rx_process+0x5c>
800043f2:	ce 4b       	rjmp	800043ba <xnl_rx_process+0x12>
800043f4:	00 00       	add	r0,r0
800043f6:	0a b4       	st.h	r5++,r4
800043f8:	00 00       	add	r0,r0
800043fa:	0a a4       	st.w	r5++,r4
800043fc:	00 00       	add	r0,r0
800043fe:	04 f8       	st.b	--r2,r8
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	61 90       	ld.w	r0,r0[0x64]
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	2b d8       	sub	r8,-67

80004408 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004408:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000440a:	4a a6       	lddpc	r6,800044b0 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000440c:	4a a2       	lddpc	r2,800044b4 <xnl_tx_process+0xac>
8000440e:	4a b4       	lddpc	r4,800044b8 <xnl_tx_process+0xb0>
80004410:	30 07       	mov	r7,0
80004412:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004414:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004416:	4a a5       	lddpc	r5,800044bc <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004418:	4a a3       	lddpc	r3,800044c0 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000441a:	6c 08       	ld.w	r8,r6[0x0]
8000441c:	58 08       	cp.w	r8,0
8000441e:	c0 40       	breq	80004426 <xnl_tx_process+0x1e>
80004420:	58 18       	cp.w	r8,1
80004422:	cf d1       	brne	8000441c <xnl_tx_process+0x14>
80004424:	c2 48       	rjmp	8000446c <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004426:	64 0c       	ld.w	r12,r2[0x0]
80004428:	0e 99       	mov	r9,r7
8000442a:	02 9a       	mov	r10,r1
8000442c:	08 9b       	mov	r11,r4
8000442e:	f0 1f 00 26 	mcall	800044c4 <xnl_tx_process+0xbc>
80004432:	58 1c       	cp.w	r12,1
80004434:	cf 31       	brne	8000441a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004436:	68 0b       	ld.w	r11,r4[0x0]
80004438:	58 0b       	cp.w	r11,0
8000443a:	cf 00       	breq	8000441a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000443c:	96 28       	ld.sh	r8,r11[0x4]
8000443e:	e0 08 19 00 	cp.h	r8,r0
80004442:	c0 71       	brne	80004450 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004444:	4a 18       	lddpc	r8,800044c8 <xnl_tx_process+0xc0>
80004446:	70 08       	ld.w	r8,r8[0x0]
80004448:	10 9c       	mov	r12,r8
8000444a:	f0 1f 00 21 	mcall	800044cc <xnl_tx_process+0xc4>
						break;
8000444e:	ce 6b       	rjmp	8000441a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004450:	16 9c       	mov	r12,r11
80004452:	f0 1f 00 20 	mcall	800044d0 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004456:	30 18       	mov	r8,1
80004458:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000445a:	66 0c       	ld.w	r12,r3[0x0]
8000445c:	0e 99       	mov	r9,r7
8000445e:	0e 9a       	mov	r10,r7
80004460:	0e 9b       	mov	r11,r7
80004462:	f0 1f 00 19 	mcall	800044c4 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004466:	30 18       	mov	r8,1
80004468:	8d 08       	st.w	r6[0x0],r8
8000446a:	cd 8b       	rjmp	8000441a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
8000446c:	66 0c       	ld.w	r12,r3[0x0]
8000446e:	0e 99       	mov	r9,r7
80004470:	36 4a       	mov	r10,100
80004472:	0e 9b       	mov	r11,r7
80004474:	f0 1f 00 14 	mcall	800044c4 <xnl_tx_process+0xbc>
80004478:	58 1c       	cp.w	r12,1
8000447a:	c0 81       	brne	8000448a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
8000447c:	49 38       	lddpc	r8,800044c8 <xnl_tx_process+0xc0>
8000447e:	70 0c       	ld.w	r12,r8[0x0]
80004480:	68 0b       	ld.w	r11,r4[0x0]
80004482:	f0 1f 00 13 	mcall	800044cc <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004486:	8d 07       	st.w	r6[0x0],r7
80004488:	cc 9b       	rjmp	8000441a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000448a:	6a 08       	ld.w	r8,r5[0x0]
8000448c:	58 38       	cp.w	r8,3
8000448e:	e0 89 00 09 	brgt	800044a0 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004492:	68 0c       	ld.w	r12,r4[0x0]
80004494:	f0 1f 00 0f 	mcall	800044d0 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004498:	6a 08       	ld.w	r8,r5[0x0]
8000449a:	2f f8       	sub	r8,-1
8000449c:	8b 08       	st.w	r5[0x0],r8
8000449e:	cb eb       	rjmp	8000441a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044a0:	48 a8       	lddpc	r8,800044c8 <xnl_tx_process+0xc0>
800044a2:	70 0c       	ld.w	r12,r8[0x0]
800044a4:	68 0b       	ld.w	r11,r4[0x0]
800044a6:	f0 1f 00 0a 	mcall	800044cc <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044aa:	8d 07       	st.w	r6[0x0],r7
800044ac:	cb 7b       	rjmp	8000441a <xnl_tx_process+0x12>
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	0b 54       	ld.sh	r4,--r5
800044b4:	00 00       	add	r0,r0
800044b6:	0b 58       	ld.sh	r8,--r5
800044b8:	00 00       	add	r0,r0
800044ba:	0b 60       	ld.uh	r0,--r5
800044bc:	00 00       	add	r0,r0
800044be:	0b 5c       	ld.sh	r12,--r5
800044c0:	00 00       	add	r0,r0
800044c2:	0b 44       	ld.w	r4,--r5
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	61 90       	ld.w	r0,r0[0x64]
800044c8:	00 00       	add	r0,r0
800044ca:	0a a4       	st.w	r5++,r4
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	2b d8       	sub	r8,-67
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	2b f8       	sub	r8,-65

800044d4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800044d4:	eb cd 40 c0 	pushm	r6-r7,lr
800044d8:	20 1d       	sub	sp,4
800044da:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800044dc:	98 39       	ld.sh	r9,r12[0x6]
800044de:	3f f8       	mov	r8,-1
800044e0:	f0 09 19 00 	cp.h	r9,r8
800044e4:	c0 a1       	brne	800044f8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800044e6:	4a e9       	lddpc	r9,8000459c <xnl_tx+0xc8>
800044e8:	13 88       	ld.ub	r8,r9[0x0]
800044ea:	2f f8       	sub	r8,-1
800044ec:	5c 58       	castu.b	r8
800044ee:	b2 88       	st.b	r9[0x0],r8
800044f0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800044f4:	a9 a8       	sbr	r8,0x8
800044f6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800044f8:	8c 49       	ld.sh	r9,r6[0x8]
800044fa:	3f f8       	mov	r8,-1
800044fc:	f0 09 19 00 	cp.h	r9,r8
80004500:	c0 41       	brne	80004508 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004502:	4a 88       	lddpc	r8,800045a0 <xnl_tx+0xcc>
80004504:	90 18       	ld.sh	r8,r8[0x2]
80004506:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004508:	8c 59       	ld.sh	r9,r6[0xa]
8000450a:	3f f8       	mov	r8,-1
8000450c:	f0 09 19 00 	cp.h	r9,r8
80004510:	c0 41       	brne	80004518 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004512:	4a 48       	lddpc	r8,800045a0 <xnl_tx+0xcc>
80004514:	90 28       	ld.sh	r8,r8[0x4]
80004516:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004518:	8c 69       	ld.sh	r9,r6[0xc]
8000451a:	3f f8       	mov	r8,-1
8000451c:	f0 09 19 00 	cp.h	r9,r8
80004520:	c0 e1       	brne	8000453c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004522:	4a 08       	lddpc	r8,800045a0 <xnl_tx+0xcc>
80004524:	90 49       	ld.sh	r9,r8[0x8]
80004526:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004528:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000452a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000452c:	90 49       	ld.sh	r9,r8[0x8]
8000452e:	e0 19 ff 00 	andl	r9,0xff00
80004532:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004536:	f3 e8 10 08 	or	r8,r9,r8
8000453a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000453c:	0d 98       	ld.ub	r8,r6[0x1]
8000453e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004540:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004544:	10 0c       	add	r12,r8
80004546:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004548:	58 0c       	cp.w	r12,0
8000454a:	e0 89 00 04 	brgt	80004552 <xnl_tx+0x7e>
8000454e:	30 09       	mov	r9,0
80004550:	c0 d8       	rjmp	8000456a <xnl_tx+0x96>
80004552:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004556:	2f ec       	sub	r12,-2
80004558:	30 09       	mov	r9,0
8000455a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000455c:	15 1b       	ld.sh	r11,r10++
8000455e:	f6 09 00 09 	add	r9,r11,r9
80004562:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004564:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004566:	18 38       	cp.w	r8,r12
80004568:	cf a1       	brne	8000455c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000456a:	5c 39       	neg	r9
8000456c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000456e:	48 e8       	lddpc	r8,800045a4 <xnl_tx+0xd0>
80004570:	70 0c       	ld.w	r12,r8[0x0]
80004572:	f0 1f 00 0e 	mcall	800045a8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004576:	c1 00       	breq	80004596 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004578:	fa c7 ff fc 	sub	r7,sp,-4
8000457c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000457e:	e0 6a 01 00 	mov	r10,256
80004582:	0c 9b       	mov	r11,r6
80004584:	f0 1f 00 0a 	mcall	800045ac <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004588:	48 a8       	lddpc	r8,800045b0 <xnl_tx+0xdc>
8000458a:	70 0c       	ld.w	r12,r8[0x0]
8000458c:	30 09       	mov	r9,0
8000458e:	12 9a       	mov	r10,r9
80004590:	1a 9b       	mov	r11,sp
80004592:	f0 1f 00 09 	mcall	800045b4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004596:	2f fd       	sub	sp,-4
80004598:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000459c:	00 00       	add	r0,r0
8000459e:	0b 48       	ld.w	r8,--r5
800045a0:	00 00       	add	r0,r0
800045a2:	0b 4a       	ld.w	r10,--r5
800045a4:	00 00       	add	r0,r0
800045a6:	0a a4       	st.w	r5++,r4
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	2d 84       	sub	r4,-40
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	78 58       	ld.w	r8,r12[0x14]
800045b0:	00 00       	add	r0,r0
800045b2:	0b 58       	ld.sh	r8,--r5
800045b4:	80 00       	ld.sh	r0,r0[0x0]
800045b6:	63 9c       	ld.w	r12,r1[0x64]

800045b8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045b8:	eb cd 40 80 	pushm	r7,lr
800045bc:	fa cd 01 00 	sub	sp,sp,256
800045c0:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045c2:	e0 68 40 0e 	mov	r8,16398
800045c6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045c8:	3f f8       	mov	r8,-1
800045ca:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800045cc:	30 c8       	mov	r8,12
800045ce:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800045d0:	98 38       	ld.sh	r8,r12[0x6]
800045d2:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800045d4:	98 58       	ld.sh	r8,r12[0xa]
800045d6:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800045d8:	98 48       	ld.sh	r8,r12[0x8]
800045da:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800045dc:	98 68       	ld.sh	r8,r12[0xc]
800045de:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045e0:	30 08       	mov	r8,0
800045e2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045e4:	1a 9c       	mov	r12,sp
800045e6:	f0 1f 00 0a 	mcall	8000460c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045ea:	fa cd 00 cc 	sub	sp,sp,204
800045ee:	e0 6a 00 ca 	mov	r10,202
800045f2:	ee cb ff f0 	sub	r11,r7,-16
800045f6:	1a 9c       	mov	r12,sp
800045f8:	f0 1f 00 06 	mcall	80004610 <xnl_data_msg_func+0x58>
800045fc:	48 68       	lddpc	r8,80004614 <xnl_data_msg_func+0x5c>
800045fe:	70 08       	ld.w	r8,r8[0x0]
80004600:	5d 18       	icall	r8
80004602:	fa cd ff 34 	sub	sp,sp,-204
}
80004606:	2c 0d       	sub	sp,-256
80004608:	e3 cd 80 80 	ldm	sp++,r7,pc
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	44 d4       	lddsp	r4,sp[0x134]
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	78 58       	ld.w	r8,r12[0x14]
80004614:	00 00       	add	r0,r0
80004616:	0b 64       	ld.uh	r4,--r5

80004618 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004618:	d4 21       	pushm	r4-r7,lr
8000461a:	fa cd 01 00 	sub	sp,sp,256
8000461e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004620:	4c 28       	lddpc	r8,80004728 <xnl_device_auth_reply_func+0x110>
80004622:	11 88       	ld.ub	r8,r8[0x0]
80004624:	58 08       	cp.w	r8,0
80004626:	e0 81 00 7f 	brne	80004724 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000462a:	4c 18       	lddpc	r8,8000472c <xnl_device_auth_reply_func+0x114>
8000462c:	70 0c       	ld.w	r12,r8[0x0]
8000462e:	30 09       	mov	r9,0
80004630:	12 9a       	mov	r10,r9
80004632:	12 9b       	mov	r11,r9
80004634:	f0 1f 00 3f 	mcall	80004730 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004638:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000463c:	4b b8       	lddpc	r8,80004728 <xnl_device_auth_reply_func+0x110>
8000463e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004640:	ef 39 00 12 	ld.ub	r9,r7[18]
80004644:	ef 38 00 13 	ld.ub	r8,r7[19]
80004648:	b1 68       	lsl	r8,0x10
8000464a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000464e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004652:	f3 e8 10 08 	or	r8,r9,r8
80004656:	ef 39 00 14 	ld.ub	r9,r7[20]
8000465a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000465e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004662:	ef 38 00 17 	ld.ub	r8,r7[23]
80004666:	b1 68       	lsl	r8,0x10
80004668:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000466c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004670:	f5 e8 10 08 	or	r8,r10,r8
80004674:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004678:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000467c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000467e:	e0 64 79 b9 	mov	r4,31161
80004682:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004686:	e0 65 45 07 	mov	r5,17671
8000468a:	ea 15 8a bd 	orh	r5,0x8abd
8000468e:	e0 66 f9 3d 	mov	r6,63805
80004692:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004696:	e0 6e b8 cf 	mov	lr,47311
8000469a:	ea 1e 36 83 	orh	lr,0x3683
8000469e:	e0 67 aa 1c 	mov	r7,43548
800046a2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046a6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046a8:	f4 08 00 0c 	add	r12,r10,r8
800046ac:	f0 0b 15 04 	lsl	r11,r8,0x4
800046b0:	0a 0b       	add	r11,r5
800046b2:	f9 eb 20 0b 	eor	r11,r12,r11
800046b6:	f0 0c 16 05 	lsr	r12,r8,0x5
800046ba:	0c 0c       	add	r12,r6
800046bc:	18 5b       	eor	r11,r12
800046be:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046c0:	f2 0c 15 04 	lsl	r12,r9,0x4
800046c4:	1c 0c       	add	r12,lr
800046c6:	f2 0b 16 05 	lsr	r11,r9,0x5
800046ca:	0e 0b       	add	r11,r7
800046cc:	f9 eb 20 0b 	eor	r11,r12,r11
800046d0:	f2 0a 00 0c 	add	r12,r9,r10
800046d4:	18 5b       	eor	r11,r12
800046d6:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800046d8:	e0 6b 37 20 	mov	r11,14112
800046dc:	ea 1b c6 ef 	orh	r11,0xc6ef
800046e0:	16 3a       	cp.w	r10,r11
800046e2:	ce 21       	brne	800046a6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046e4:	e0 6a 40 1a 	mov	r10,16410
800046e8:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046ea:	3f fa       	mov	r10,-1
800046ec:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046ee:	30 6b       	mov	r11,6
800046f0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046f2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046f4:	48 db       	lddpc	r11,80004728 <xnl_device_auth_reply_func+0x110>
800046f6:	96 1c       	ld.sh	r12,r11[0x2]
800046f8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046fa:	96 2b       	ld.sh	r11,r11[0x4]
800046fc:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046fe:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004700:	30 ca       	mov	r10,12
80004702:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004704:	30 0a       	mov	r10,0
80004706:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000470a:	30 7a       	mov	r10,7
8000470c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004710:	30 2a       	mov	r10,2
80004712:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004716:	fa ca ff ec 	sub	r10,sp,-20
8000471a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000471c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000471e:	1a 9c       	mov	r12,sp
80004720:	f0 1f 00 05 	mcall	80004734 <xnl_device_auth_reply_func+0x11c>
}
80004724:	2c 0d       	sub	sp,-256
80004726:	d8 22       	popm	r4-r7,pc
80004728:	00 00       	add	r0,r0
8000472a:	0b 4a       	ld.w	r10,--r5
8000472c:	00 00       	add	r0,r0
8000472e:	0b 44       	ld.w	r4,--r5
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	63 9c       	ld.w	r12,r1[0x64]
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	44 d4       	lddsp	r4,sp[0x134]

80004738 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004738:	eb cd 40 80 	pushm	r7,lr
8000473c:	fa cd 01 00 	sub	sp,sp,256
80004740:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004742:	49 28       	lddpc	r8,80004788 <xnl_master_status_brdcst_func+0x50>
80004744:	11 88       	ld.ub	r8,r8[0x0]
80004746:	58 08       	cp.w	r8,0
80004748:	c1 c1       	brne	80004780 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000474a:	49 18       	lddpc	r8,8000478c <xnl_master_status_brdcst_func+0x54>
8000474c:	70 0c       	ld.w	r12,r8[0x0]
8000474e:	30 09       	mov	r9,0
80004750:	12 9a       	mov	r10,r9
80004752:	12 9b       	mov	r11,r9
80004754:	f0 1f 00 0f 	mcall	80004790 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004758:	8e 58       	ld.sh	r8,r7[0xa]
8000475a:	48 c9       	lddpc	r9,80004788 <xnl_master_status_brdcst_func+0x50>
8000475c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000475e:	e0 68 40 0e 	mov	r8,16398
80004762:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004764:	3f f8       	mov	r8,-1
80004766:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004768:	30 4a       	mov	r10,4
8000476a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000476c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000476e:	92 19       	ld.sh	r9,r9[0x2]
80004770:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004772:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004774:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004776:	30 08       	mov	r8,0
80004778:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000477a:	1a 9c       	mov	r12,sp
8000477c:	f0 1f 00 06 	mcall	80004794 <xnl_master_status_brdcst_func+0x5c>
}
80004780:	2c 0d       	sub	sp,-256
80004782:	e3 cd 80 80 	ldm	sp++,r7,pc
80004786:	00 00       	add	r0,r0
80004788:	00 00       	add	r0,r0
8000478a:	0b 4a       	ld.w	r10,--r5
8000478c:	00 00       	add	r0,r0
8000478e:	0b 44       	ld.w	r4,--r5
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	63 9c       	ld.w	r12,r1[0x64]
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	44 d4       	lddsp	r4,sp[0x134]

80004798 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004798:	eb cd 40 80 	pushm	r7,lr
8000479c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000479e:	49 28       	lddpc	r8,800047e4 <xnl_device_conn_reply_func+0x4c>
800047a0:	70 0c       	ld.w	r12,r8[0x0]
800047a2:	30 09       	mov	r9,0
800047a4:	12 9a       	mov	r10,r9
800047a6:	12 9b       	mov	r11,r9
800047a8:	f0 1f 00 10 	mcall	800047e8 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047ac:	ef 18 00 10 	ld.uh	r8,r7[16]
800047b0:	10 99       	mov	r9,r8
800047b2:	e2 19 ff 00 	andl	r9,0xff00,COH
800047b6:	e0 49 01 00 	cp.w	r9,256
800047ba:	c0 60       	breq	800047c6 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047bc:	0e 9c       	mov	r12,r7
800047be:	f0 1f 00 0c 	mcall	800047ec <xnl_device_conn_reply_func+0x54>
800047c2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047c6:	a9 68       	lsl	r8,0x8
800047c8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800047cc:	48 98       	lddpc	r8,800047f0 <xnl_device_conn_reply_func+0x58>
800047ce:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800047d0:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800047d4:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800047d6:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800047da:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800047dc:	30 19       	mov	r9,1
800047de:	b0 89       	st.b	r8[0x0],r9
800047e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e4:	00 00       	add	r0,r0
800047e6:	0b 44       	ld.w	r4,--r5
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	63 9c       	ld.w	r12,r1[0x64]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	47 38       	lddsp	r8,sp[0x1cc]
800047f0:	00 00       	add	r0,r0
800047f2:	0b 4a       	ld.w	r10,--r5

800047f4 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800047f4:	d4 01       	pushm	lr
800047f6:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047fa:	e0 68 40 0e 	mov	r8,16398
800047fe:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004800:	3f f8       	mov	r8,-1
80004802:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004804:	30 38       	mov	r8,3
80004806:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004808:	30 08       	mov	r8,0
8000480a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000480c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000480e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004810:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004812:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004814:	1a 9c       	mov	r12,sp
80004816:	f0 1f 00 03 	mcall	80004820 <xnl_send_device_master_query+0x2c>
}
8000481a:	2c 0d       	sub	sp,-256
8000481c:	d8 02       	popm	pc
8000481e:	00 00       	add	r0,r0
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	44 d4       	lddsp	r4,sp[0x134]

80004824 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004824:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004826:	48 78       	lddpc	r8,80004840 <RC522_SPI_SetSpeed+0x1c>
80004828:	70 09       	ld.w	r9,r8[0x0]
8000482a:	72 ca       	ld.w	r10,r9[0x30]
8000482c:	5c 7c       	castu.h	r12
8000482e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004832:	f9 ea 10 0a 	or	r10,r12,r10
80004836:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004838:	70 0c       	ld.w	r12,r8[0x0]
8000483a:	f0 1f 00 03 	mcall	80004844 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000483e:	d8 02       	popm	pc
80004840:	00 00       	add	r0,r0
80004842:	20 24       	sub	r4,2
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	58 8c       	cp.w	r12,8

80004848 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004848:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000484a:	e0 6c 04 00 	mov	r12,1024
8000484e:	f0 1f 00 02 	mcall	80004854 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004852:	d8 02       	popm	pc
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	48 24       	lddpc	r4,8000485c <RC522_ReadByte+0x4>

80004858 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004858:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
8000485c:	48 b7       	lddpc	r7,80004888 <RC522_ReadByte+0x30>
8000485e:	30 0b       	mov	r11,0
80004860:	6e 0c       	ld.w	r12,r7[0x0]
80004862:	f0 1f 00 0b 	mcall	8000488c <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004866:	e0 6b 00 ff 	mov	r11,255
8000486a:	6e 0c       	ld.w	r12,r7[0x0]
8000486c:	f0 1f 00 09 	mcall	80004890 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004870:	30 06       	mov	r6,0
80004872:	0c 9b       	mov	r11,r6
80004874:	6e 0c       	ld.w	r12,r7[0x0]
80004876:	f0 1f 00 08 	mcall	80004894 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000487a:	0c 9b       	mov	r11,r6
8000487c:	6e 0c       	ld.w	r12,r7[0x0]
8000487e:	f0 1f 00 07 	mcall	80004898 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004882:	0d 9c       	ld.ub	r12,r6[0x1]
80004884:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004888:	00 00       	add	r0,r0
8000488a:	20 24       	sub	r4,2
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	59 f8       	cp.w	r8,31
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	58 92       	cp.w	r2,9
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	58 ae       	cp.w	lr,10
80004898:	80 00       	ld.sh	r0,r0[0x0]
8000489a:	59 b8       	cp.w	r8,27

8000489c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000489c:	eb cd 40 c0 	pushm	r6-r7,lr
800048a0:	20 1d       	sub	sp,4
800048a2:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048a4:	48 c7       	lddpc	r7,800048d4 <RC522_WriteByte+0x38>
800048a6:	30 0b       	mov	r11,0
800048a8:	6e 0c       	ld.w	r12,r7[0x0]
800048aa:	f0 1f 00 0c 	mcall	800048d8 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048ae:	1b 8b       	ld.ub	r11,sp[0x0]
800048b0:	6e 0c       	ld.w	r12,r7[0x0]
800048b2:	f0 1f 00 0b 	mcall	800048dc <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048b6:	1a 9b       	mov	r11,sp
800048b8:	6e 0c       	ld.w	r12,r7[0x0]
800048ba:	f0 1f 00 0a 	mcall	800048e0 <RC522_WriteByte+0x44>
800048be:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048c0:	30 0b       	mov	r11,0
800048c2:	6e 0c       	ld.w	r12,r7[0x0]
800048c4:	f0 1f 00 08 	mcall	800048e4 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048c8:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800048cc:	2f fd       	sub	sp,-4
800048ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048d2:	00 00       	add	r0,r0
800048d4:	00 00       	add	r0,r0
800048d6:	20 24       	sub	r4,2
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	59 f8       	cp.w	r8,31
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	58 92       	cp.w	r2,9
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	58 ae       	cp.w	lr,10
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	59 b8       	cp.w	r8,27

800048e8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048e8:	eb cd 40 c0 	pushm	r6-r7,lr
800048ec:	18 96       	mov	r6,r12
800048ee:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800048f0:	31 8c       	mov	r12,24
800048f2:	f0 1f 00 09 	mcall	80004914 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048f6:	ec 0c 15 01 	lsl	r12,r6,0x1
800048fa:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048fe:	f0 1f 00 07 	mcall	80004918 <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004902:	0e 9c       	mov	r12,r7
80004904:	f0 1f 00 05 	mcall	80004918 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004908:	31 8c       	mov	r12,24
8000490a:	f0 1f 00 05 	mcall	8000491c <WriteRawRC+0x34>

}
8000490e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004912:	00 00       	add	r0,r0
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	54 1c       	stdsp	sp[0x104],r12
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	48 9c       	lddpc	r12,8000493c <PcdReset+0x1c>
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	54 00       	stdsp	sp[0x100],r0

80004920 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004920:	d4 01       	pushm	lr

	SET_RC522RST;
80004922:	31 9c       	mov	r12,25
80004924:	f0 1f 00 1b 	mcall	80004990 <PcdReset+0x70>
	delay_ns(10);
80004928:	30 ac       	mov	r12,10
8000492a:	f0 1f 00 1b 	mcall	80004994 <PcdReset+0x74>

	CLR_RC522RST;
8000492e:	31 9c       	mov	r12,25
80004930:	f0 1f 00 1a 	mcall	80004998 <PcdReset+0x78>
	delay_ns(10);
80004934:	30 ac       	mov	r12,10
80004936:	f0 1f 00 18 	mcall	80004994 <PcdReset+0x74>

	SET_RC522RST;
8000493a:	31 9c       	mov	r12,25
8000493c:	f0 1f 00 15 	mcall	80004990 <PcdReset+0x70>
	delay_ns(10);
80004940:	30 ac       	mov	r12,10
80004942:	f0 1f 00 15 	mcall	80004994 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004946:	30 fb       	mov	r11,15
80004948:	30 1c       	mov	r12,1
8000494a:	f0 1f 00 15 	mcall	8000499c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000494e:	30 fb       	mov	r11,15
80004950:	30 1c       	mov	r12,1
80004952:	f0 1f 00 13 	mcall	8000499c <PcdReset+0x7c>
	delay_ns(10);
80004956:	30 ac       	mov	r12,10
80004958:	f0 1f 00 0f 	mcall	80004994 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
8000495c:	33 db       	mov	r11,61
8000495e:	31 1c       	mov	r12,17
80004960:	f0 1f 00 0f 	mcall	8000499c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004964:	31 eb       	mov	r11,30
80004966:	32 dc       	mov	r12,45
80004968:	f0 1f 00 0d 	mcall	8000499c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
8000496c:	30 0b       	mov	r11,0
8000496e:	32 cc       	mov	r12,44
80004970:	f0 1f 00 0b 	mcall	8000499c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004974:	e0 6b 00 8d 	mov	r11,141
80004978:	32 ac       	mov	r12,42
8000497a:	f0 1f 00 09 	mcall	8000499c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000497e:	33 eb       	mov	r11,62
80004980:	32 bc       	mov	r12,43
80004982:	f0 1f 00 07 	mcall	8000499c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004986:	34 0b       	mov	r11,64
80004988:	31 5c       	mov	r12,21
8000498a:	f0 1f 00 05 	mcall	8000499c <PcdReset+0x7c>
	
	return MI_OK;
}
8000498e:	d8 0a       	popm	pc,r12=0
80004990:	80 00       	ld.sh	r0,r0[0x0]
80004992:	54 00       	stdsp	sp[0x100],r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	51 98       	stdsp	sp[0x64],r8
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	54 1c       	stdsp	sp[0x104],r12
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	48 e8       	lddpc	r8,800049d4 <ReadRawRC+0x34>

800049a0 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049a0:	eb cd 40 80 	pushm	r7,lr
800049a4:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800049a6:	31 8c       	mov	r12,24
800049a8:	f0 1f 00 0a 	mcall	800049d0 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049ac:	ee 08 15 01 	lsl	r8,r7,0x1
800049b0:	10 9c       	mov	r12,r8
800049b2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049b6:	a7 bc       	sbr	r12,0x7
800049b8:	f0 1f 00 07 	mcall	800049d4 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800049bc:	f0 1f 00 07 	mcall	800049d8 <ReadRawRC+0x38>
800049c0:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800049c2:	31 8c       	mov	r12,24
800049c4:	f0 1f 00 06 	mcall	800049dc <ReadRawRC+0x3c>
	return ucResult;
}
800049c8:	0e 9c       	mov	r12,r7
800049ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ce:	00 00       	add	r0,r0
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	54 1c       	stdsp	sp[0x104],r12
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 9c       	lddpc	r12,800049f8 <SetBitMask+0x18>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	48 58       	lddpc	r8,800049ec <SetBitMask+0xc>
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	54 00       	stdsp	sp[0x100],r0

800049e0 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800049e0:	eb cd 40 c0 	pushm	r6-r7,lr
800049e4:	18 97       	mov	r7,r12
800049e6:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800049e8:	f0 1f 00 05 	mcall	800049fc <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800049ec:	f9 e6 10 0b 	or	r11,r12,r6
800049f0:	5c 5b       	castu.b	r11
800049f2:	0e 9c       	mov	r12,r7
800049f4:	f0 1f 00 03 	mcall	80004a00 <SetBitMask+0x20>
}
800049f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	49 a0       	lddpc	r0,80004a64 <M500PcdConfigISOType+0x8>
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	48 e8       	lddpc	r8,80004a38 <ClearBitMask+0x14>

80004a04 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a04:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a06:	31 4c       	mov	r12,20
80004a08:	f0 1f 00 05 	mcall	80004a1c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a0c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a10:	c0 51       	brne	80004a1a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a12:	30 3b       	mov	r11,3
80004a14:	31 4c       	mov	r12,20
80004a16:	f0 1f 00 03 	mcall	80004a20 <PcdAntennaOn+0x1c>
80004a1a:	d8 02       	popm	pc
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	49 a0       	lddpc	r0,80004a84 <M500PcdConfigISOType+0x28>
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	49 e0       	lddpc	r0,80004a98 <M500PcdConfigISOType+0x3c>

80004a24 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a24:	eb cd 40 c0 	pushm	r6-r7,lr
80004a28:	18 97       	mov	r7,r12
80004a2a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a2c:	f0 1f 00 06 	mcall	80004a44 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a30:	5c d6       	com	r6
80004a32:	f9 e6 00 06 	and	r6,r12,r6
80004a36:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a3a:	0e 9c       	mov	r12,r7
80004a3c:	f0 1f 00 03 	mcall	80004a48 <ClearBitMask+0x24>
	
}
80004a40:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	49 a0       	lddpc	r0,80004aac <M500PcdConfigISOType+0x50>
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	48 e8       	lddpc	r8,80004a80 <M500PcdConfigISOType+0x24>

80004a4c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a4c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a4e:	30 3b       	mov	r11,3
80004a50:	31 4c       	mov	r12,20
80004a52:	f0 1f 00 02 	mcall	80004a58 <PcdAntennaOff+0xc>
}
80004a56:	d8 02       	popm	pc
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	4a 24       	lddpc	r4,80004ae0 <rc522_init+0x14>

80004a5c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a5c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a5e:	34 18       	mov	r8,65
80004a60:	f0 0c 18 00 	cp.b	r12,r8
80004a64:	c0 20       	breq	80004a68 <M500PcdConfigISOType+0xc>
80004a66:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a68:	30 8b       	mov	r11,8
80004a6a:	16 9c       	mov	r12,r11
80004a6c:	f0 1f 00 14 	mcall	80004abc <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004a70:	33 db       	mov	r11,61
80004a72:	31 1c       	mov	r12,17
80004a74:	f0 1f 00 13 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004a78:	e0 6b 00 86 	mov	r11,134
80004a7c:	31 7c       	mov	r12,23
80004a7e:	f0 1f 00 11 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004a82:	37 fb       	mov	r11,127
80004a84:	32 6c       	mov	r12,38
80004a86:	f0 1f 00 0f 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a8a:	31 eb       	mov	r11,30
80004a8c:	32 dc       	mov	r12,45
80004a8e:	f0 1f 00 0d 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004a92:	30 0b       	mov	r11,0
80004a94:	32 cc       	mov	r12,44
80004a96:	f0 1f 00 0b 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004a9a:	e0 6b 00 8d 	mov	r11,141
80004a9e:	32 ac       	mov	r12,42
80004aa0:	f0 1f 00 08 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004aa4:	33 eb       	mov	r11,62
80004aa6:	32 bc       	mov	r12,43
80004aa8:	f0 1f 00 06 	mcall	80004ac0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004aac:	e0 6c 03 e8 	mov	r12,1000
80004ab0:	f0 1f 00 05 	mcall	80004ac4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ab4:	f0 1f 00 05 	mcall	80004ac8 <M500PcdConfigISOType+0x6c>
80004ab8:	d8 0a       	popm	pc,r12=0
80004aba:	00 00       	add	r0,r0
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	4a 24       	lddpc	r4,80004b44 <rc522_init+0x78>
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	48 e8       	lddpc	r8,80004af8 <rc522_init+0x2c>
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	51 98       	stdsp	sp[0x64],r8
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	4a 04       	lddpc	r4,80004b48 <rc522_init+0x7c>

80004acc <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004acc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ad0:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004ad2:	4a 28       	lddpc	r8,80004b58 <rc522_init+0x8c>
80004ad4:	1a 96       	mov	r6,sp
80004ad6:	f0 ea 00 00 	ld.d	r10,r8[0]
80004ada:	fa eb 00 00 	st.d	sp[0],r10
80004ade:	f0 e8 00 08 	ld.d	r8,r8[8]
80004ae2:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004ae6:	30 4b       	mov	r11,4
80004ae8:	49 dc       	lddpc	r12,80004b5c <rc522_init+0x90>
80004aea:	f0 1f 00 1e 	mcall	80004b60 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004aee:	31 9c       	mov	r12,25
80004af0:	f0 1f 00 1d 	mcall	80004b64 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004af4:	31 9c       	mov	r12,25
80004af6:	f0 1f 00 1d 	mcall	80004b68 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004afa:	49 d7       	lddpc	r7,80004b6c <rc522_init+0xa0>
80004afc:	fe 7c 24 00 	mov	r12,-56320
80004b00:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b02:	1a 9b       	mov	r11,sp
80004b04:	f0 1f 00 1b 	mcall	80004b70 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b08:	30 09       	mov	r9,0
80004b0a:	12 9a       	mov	r10,r9
80004b0c:	12 9b       	mov	r11,r9
80004b0e:	6e 0c       	ld.w	r12,r7[0x0]
80004b10:	f0 1f 00 19 	mcall	80004b74 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004b14:	6e 0c       	ld.w	r12,r7[0x0]
80004b16:	f0 1f 00 19 	mcall	80004b78 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b1a:	e0 6a 36 00 	mov	r10,13824
80004b1e:	ea 1a 01 6e 	orh	r10,0x16e
80004b22:	1a 9b       	mov	r11,sp
80004b24:	6e 0c       	ld.w	r12,r7[0x0]
80004b26:	f0 1f 00 16 	mcall	80004b7c <rc522_init+0xb0>
80004b2a:	c0 50       	breq	80004b34 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b2c:	30 29       	mov	r9,2
80004b2e:	49 58       	lddpc	r8,80004b80 <rc522_init+0xb4>
80004b30:	b0 89       	st.b	r8[0x0],r9
80004b32:	c0 38       	rjmp	80004b38 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b34:	f0 1f 00 14 	mcall	80004b84 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b38:	f0 1f 00 14 	mcall	80004b88 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004b3c:	f0 1f 00 14 	mcall	80004b8c <rc522_init+0xc0>
	
	delay_ms(2); 
80004b40:	30 2c       	mov	r12,2
80004b42:	f0 1f 00 14 	mcall	80004b90 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004b46:	f0 1f 00 14 	mcall	80004b94 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004b4a:	34 1c       	mov	r12,65
80004b4c:	f0 1f 00 13 	mcall	80004b98 <rc522_init+0xcc>
	

80004b50:	2f cd       	sub	sp,-16
80004b52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b56:	00 00       	add	r0,r0
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	d7 c4       	*unknown*
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	d7 dc       	*unknown*
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	53 b8       	stdsp	sp[0xec],r8
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	53 e8       	stdsp	sp[0xf8],r8
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	54 00       	stdsp	sp[0x100],r0
80004b6c:	00 00       	add	r0,r0
80004b6e:	20 24       	sub	r4,2
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	58 28       	cp.w	r8,2
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	58 60       	cp.w	r0,6
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	58 8c       	cp.w	r12,8
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	58 d0       	cp.w	r0,13
80004b80:	00 00       	add	r0,r0
80004b82:	0b 68       	ld.uh	r8,--r5
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	48 48       	lddpc	r8,80004b94 <rc522_init+0xc8>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	49 20       	lddpc	r0,80004bd0 <PcdComMF522+0x34>
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	4a 4c       	lddpc	r12,80004c1c <PcdComMF522+0x80>
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	51 d8       	stdsp	sp[0x74],r8
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	4a 04       	lddpc	r4,80004c14 <PcdComMF522+0x78>
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	4a 5c       	lddpc	r12,80004c2c <PcdComMF522+0x90>

80004b9c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004b9c:	d4 31       	pushm	r0-r7,lr
80004b9e:	20 1d       	sub	sp,4
80004ba0:	18 92       	mov	r2,r12
80004ba2:	16 95       	mov	r5,r11
80004ba4:	14 96       	mov	r6,r10
80004ba6:	50 09       	stdsp	sp[0x0],r9
80004ba8:	10 90       	mov	r0,r8
80004baa:	f8 c8 00 0c 	sub	r8,r12,12
80004bae:	5c 58       	castu.b	r8
80004bb0:	30 29       	mov	r9,2
80004bb2:	f2 08 18 00 	cp.b	r8,r9
80004bb6:	e0 88 00 05 	brls	80004bc0 <PcdComMF522+0x24>
80004bba:	30 03       	mov	r3,0
80004bbc:	06 91       	mov	r1,r3
80004bbe:	c0 78       	rjmp	80004bcc <PcdComMF522+0x30>
80004bc0:	4c f9       	lddpc	r9,80004cfc <PcdComMF522+0x160>
80004bc2:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004bc6:	4c f9       	lddpc	r9,80004d00 <PcdComMF522+0x164>
80004bc8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004bcc:	02 9b       	mov	r11,r1
80004bce:	a7 bb       	sbr	r11,0x7
80004bd0:	30 2c       	mov	r12,2
80004bd2:	f0 1f 00 4d 	mcall	80004d04 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004bd6:	e0 6b 00 80 	mov	r11,128
80004bda:	30 4c       	mov	r12,4
80004bdc:	f0 1f 00 4b 	mcall	80004d08 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004be0:	30 0b       	mov	r11,0
80004be2:	30 1c       	mov	r12,1
80004be4:	f0 1f 00 48 	mcall	80004d04 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004be8:	e0 6b 00 80 	mov	r11,128
80004bec:	30 ac       	mov	r12,10
80004bee:	f0 1f 00 48 	mcall	80004d0c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004bf2:	58 06       	cp.w	r6,0
80004bf4:	c0 c0       	breq	80004c0c <PcdComMF522+0x70>
80004bf6:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004bf8:	30 94       	mov	r4,9
80004bfa:	0f 3b       	ld.ub	r11,r7++
80004bfc:	08 9c       	mov	r12,r4
80004bfe:	f0 1f 00 42 	mcall	80004d04 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c02:	0e 98       	mov	r8,r7
80004c04:	0a 18       	sub	r8,r5
80004c06:	ec 08 19 00 	cp.h	r8,r6
80004c0a:	cf 83       	brcs	80004bfa <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c0c:	04 9b       	mov	r11,r2
80004c0e:	30 1c       	mov	r12,1
80004c10:	f0 1f 00 3d 	mcall	80004d04 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c14:	30 c8       	mov	r8,12
80004c16:	f0 02 18 00 	cp.b	r2,r8
80004c1a:	c0 61       	brne	80004c26 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c1c:	e0 6b 00 80 	mov	r11,128
80004c20:	30 dc       	mov	r12,13
80004c22:	f0 1f 00 3b 	mcall	80004d0c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c26:	30 4c       	mov	r12,4
80004c28:	f0 1f 00 3a 	mcall	80004d10 <PcdComMF522+0x174>
80004c2c:	18 97       	mov	r7,r12
80004c2e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c32:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c34:	30 44       	mov	r4,4
80004c36:	c0 88       	rjmp	80004c46 <PcdComMF522+0xaa>
80004c38:	08 9c       	mov	r12,r4
80004c3a:	f0 1f 00 36 	mcall	80004d10 <PcdComMF522+0x174>
80004c3e:	18 97       	mov	r7,r12
		i--;
80004c40:	20 16       	sub	r6,1
80004c42:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c44:	c0 a0       	breq	80004c58 <PcdComMF522+0xbc>
80004c46:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c4a:	c4 c1       	brne	80004ce2 <PcdComMF522+0x146>
80004c4c:	ef e3 00 08 	and	r8,r7,r3
80004c50:	ea 08 18 00 	cp.b	r8,r5
80004c54:	cf 20       	breq	80004c38 <PcdComMF522+0x9c>
80004c56:	c4 68       	rjmp	80004ce2 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c58:	e0 6b 00 80 	mov	r11,128
80004c5c:	30 dc       	mov	r12,13
80004c5e:	f0 1f 00 2b 	mcall	80004d08 <PcdComMF522+0x16c>
80004c62:	30 27       	mov	r7,2
80004c64:	c3 38       	rjmp	80004cca <PcdComMF522+0x12e>
80004c66:	02 67       	and	r7,r1
80004c68:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004c6c:	30 c8       	mov	r8,12
80004c6e:	f0 02 18 00 	cp.b	r2,r8
80004c72:	c2 c1       	brne	80004cca <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004c74:	30 ac       	mov	r12,10
80004c76:	f0 1f 00 27 	mcall	80004d10 <PcdComMF522+0x174>
80004c7a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004c7c:	30 cc       	mov	r12,12
80004c7e:	f0 1f 00 25 	mcall	80004d10 <PcdComMF522+0x174>
80004c82:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c86:	c0 70       	breq	80004c94 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c88:	08 98       	mov	r8,r4
80004c8a:	20 18       	sub	r8,1
80004c8c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004c90:	a0 8c       	st.b	r0[0x0],r12
80004c92:	c0 48       	rjmp	80004c9a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004c94:	e8 08 15 03 	lsl	r8,r4,0x3
80004c98:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004c9a:	58 04       	cp.w	r4,0
80004c9c:	c0 61       	brne	80004ca8 <PcdComMF522+0x10c>
80004c9e:	30 14       	mov	r4,1
80004ca0:	40 05       	lddsp	r5,sp[0x0]
80004ca2:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ca4:	30 93       	mov	r3,9
80004ca6:	c0 98       	rjmp	80004cb8 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ca8:	31 28       	mov	r8,18
80004caa:	f0 04 18 00 	cp.b	r4,r8
80004cae:	f9 b4 0b 12 	movhi	r4,18
80004cb2:	58 04       	cp.w	r4,0
80004cb4:	cf 61       	brne	80004ca0 <PcdComMF522+0x104>
80004cb6:	c0 a8       	rjmp	80004cca <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cb8:	06 9c       	mov	r12,r3
80004cba:	f0 1f 00 16 	mcall	80004d10 <PcdComMF522+0x174>
80004cbe:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cc0:	ec 05 01 08 	sub	r8,r6,r5
80004cc4:	e8 08 19 00 	cp.h	r8,r4
80004cc8:	cf 83       	brcs	80004cb8 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004cca:	e0 6b 00 80 	mov	r11,128
80004cce:	30 cc       	mov	r12,12
80004cd0:	f0 1f 00 0f 	mcall	80004d0c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cd4:	30 0b       	mov	r11,0
80004cd6:	30 1c       	mov	r12,1
80004cd8:	f0 1f 00 0b 	mcall	80004d04 <PcdComMF522+0x168>
	return status;
}
80004cdc:	0e 9c       	mov	r12,r7
80004cde:	2f fd       	sub	sp,-4
80004ce0:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004ce2:	e0 6b 00 80 	mov	r11,128
80004ce6:	30 dc       	mov	r12,13
80004ce8:	f0 1f 00 08 	mcall	80004d08 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004cec:	30 6c       	mov	r12,6
80004cee:	f0 1f 00 09 	mcall	80004d10 <PcdComMF522+0x174>
80004cf2:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004cf6:	cb 80       	breq	80004c66 <PcdComMF522+0xca>
80004cf8:	30 27       	mov	r7,2
80004cfa:	ce 8b       	rjmp	80004cca <PcdComMF522+0x12e>
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	d7 d4       	*unknown*
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	d7 d8       	*unknown*
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	48 e8       	lddpc	r8,80004d3c <PcdAnticoll+0x28>
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	4a 24       	lddpc	r4,80004d90 <PcdAnticoll+0x7c>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	49 e0       	lddpc	r0,80004d84 <PcdAnticoll+0x70>
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	49 a0       	lddpc	r0,80004d78 <PcdAnticoll+0x64>

80004d14 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d14:	eb cd 40 c0 	pushm	r6-r7,lr
80004d18:	20 5d       	sub	sp,20
80004d1a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d1c:	30 8b       	mov	r11,8
80004d1e:	16 9c       	mov	r12,r11
80004d20:	f0 1f 00 1a 	mcall	80004d88 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d24:	30 0b       	mov	r11,0
80004d26:	30 dc       	mov	r12,13
80004d28:	f0 1f 00 19 	mcall	80004d8c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d2c:	e0 6b 00 80 	mov	r11,128
80004d30:	30 ec       	mov	r12,14
80004d32:	f0 1f 00 16 	mcall	80004d88 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d36:	39 38       	mov	r8,-109
80004d38:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d3a:	32 08       	mov	r8,32
80004d3c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d3e:	1a 9b       	mov	r11,sp
80004d40:	fa c8 ff ed 	sub	r8,sp,-19
80004d44:	1a 99       	mov	r9,sp
80004d46:	30 2a       	mov	r10,2
80004d48:	30 cc       	mov	r12,12
80004d4a:	f0 1f 00 12 	mcall	80004d90 <PcdAnticoll+0x7c>
80004d4e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d50:	c1 21       	brne	80004d74 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d52:	1b 89       	ld.ub	r9,sp[0x0]
80004d54:	ac 89       	st.b	r6[0x0],r9
80004d56:	1b 98       	ld.ub	r8,sp[0x1]
80004d58:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d5a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d5c:	1b a8       	ld.ub	r8,sp[0x2]
80004d5e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d60:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d64:	1b b9       	ld.ub	r9,sp[0x3]
80004d66:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004d68:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004d6a:	1b c9       	ld.ub	r9,sp[0x4]
80004d6c:	f0 09 18 00 	cp.b	r9,r8
80004d70:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004d74:	e0 6b 00 80 	mov	r11,128
80004d78:	30 ec       	mov	r12,14
80004d7a:	f0 1f 00 07 	mcall	80004d94 <PcdAnticoll+0x80>
	return status;
}
80004d7e:	0e 9c       	mov	r12,r7
80004d80:	2f bd       	sub	sp,-20
80004d82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d86:	00 00       	add	r0,r0
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	4a 24       	lddpc	r4,80004e10 <CalulateCRC+0x14>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	48 e8       	lddpc	r8,80004dc4 <PcdRequest+0x2c>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	4b 9c       	lddpc	r12,80004e74 <CalulateCRC+0x78>
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	49 e0       	lddpc	r0,80004e0c <CalulateCRC+0x10>

80004d98 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004d98:	eb cd 40 c0 	pushm	r6-r7,lr
80004d9c:	20 5d       	sub	sp,20
80004d9e:	18 97       	mov	r7,r12
80004da0:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004da2:	30 8b       	mov	r11,8
80004da4:	16 9c       	mov	r12,r11
80004da6:	f0 1f 00 12 	mcall	80004dec <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004daa:	30 7b       	mov	r11,7
80004dac:	30 dc       	mov	r12,13
80004dae:	f0 1f 00 11 	mcall	80004df0 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004db2:	30 3b       	mov	r11,3
80004db4:	31 4c       	mov	r12,20
80004db6:	f0 1f 00 10 	mcall	80004df4 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004dba:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004dbc:	1a 9b       	mov	r11,sp
80004dbe:	fa c8 ff ed 	sub	r8,sp,-19
80004dc2:	1a 99       	mov	r9,sp
80004dc4:	30 1a       	mov	r10,1
80004dc6:	30 cc       	mov	r12,12
80004dc8:	f0 1f 00 0c 	mcall	80004df8 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004dcc:	c0 c1       	brne	80004de4 <PcdRequest+0x4c>
80004dce:	31 08       	mov	r8,16
80004dd0:	fb 39 00 13 	ld.ub	r9,sp[19]
80004dd4:	f0 09 18 00 	cp.b	r9,r8
80004dd8:	c0 61       	brne	80004de4 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004dda:	1b 88       	ld.ub	r8,sp[0x0]
80004ddc:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004dde:	1b 98       	ld.ub	r8,sp[0x1]
80004de0:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004de2:	c0 28       	rjmp	80004de6 <PcdRequest+0x4e>
80004de4:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004de6:	2f bd       	sub	sp,-20
80004de8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	4a 24       	lddpc	r4,80004e74 <CalulateCRC+0x78>
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	48 e8       	lddpc	r8,80004e28 <CalulateCRC+0x2c>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	49 e0       	lddpc	r0,80004e6c <CalulateCRC+0x70>
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	4b 9c       	lddpc	r12,80004edc <PcdSelect+0x54>

80004dfc <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004dfc:	eb cd 40 f8 	pushm	r3-r7,lr
80004e00:	18 95       	mov	r5,r12
80004e02:	16 96       	mov	r6,r11
80004e04:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e06:	30 4b       	mov	r11,4
80004e08:	30 5c       	mov	r12,5
80004e0a:	f0 1f 00 1c 	mcall	80004e78 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e0e:	30 0b       	mov	r11,0
80004e10:	30 1c       	mov	r12,1
80004e12:	f0 1f 00 1b 	mcall	80004e7c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e16:	e0 6b 00 80 	mov	r11,128
80004e1a:	30 ac       	mov	r12,10
80004e1c:	f0 1f 00 19 	mcall	80004e80 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e20:	58 06       	cp.w	r6,0
80004e22:	c0 c0       	breq	80004e3a <CalulateCRC+0x3e>
80004e24:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e26:	30 94       	mov	r4,9
80004e28:	0f 3b       	ld.ub	r11,r7++
80004e2a:	08 9c       	mov	r12,r4
80004e2c:	f0 1f 00 14 	mcall	80004e7c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e30:	0e 98       	mov	r8,r7
80004e32:	0a 18       	sub	r8,r5
80004e34:	ec 08 18 00 	cp.b	r8,r6
80004e38:	cf 83       	brcs	80004e28 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e3a:	30 3b       	mov	r11,3
80004e3c:	30 1c       	mov	r12,1
80004e3e:	f0 1f 00 10 	mcall	80004e7c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e42:	30 5c       	mov	r12,5
80004e44:	f0 1f 00 10 	mcall	80004e84 <CalulateCRC+0x88>
80004e48:	e0 67 00 fe 	mov	r7,254
80004e4c:	30 56       	mov	r6,5
80004e4e:	c0 78       	rjmp	80004e5c <CalulateCRC+0x60>
80004e50:	0c 9c       	mov	r12,r6
80004e52:	f0 1f 00 0d 	mcall	80004e84 <CalulateCRC+0x88>
		i--;
80004e56:	20 17       	sub	r7,1
80004e58:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e5a:	c0 40       	breq	80004e62 <CalulateCRC+0x66>
80004e5c:	e2 1c 00 04 	andl	r12,0x4,COH
80004e60:	cf 80       	breq	80004e50 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e62:	32 2c       	mov	r12,34
80004e64:	f0 1f 00 08 	mcall	80004e84 <CalulateCRC+0x88>
80004e68:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004e6a:	32 1c       	mov	r12,33
80004e6c:	f0 1f 00 06 	mcall	80004e84 <CalulateCRC+0x88>
80004e70:	a6 9c       	st.b	r3[0x1],r12
}
80004e72:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004e76:	00 00       	add	r0,r0
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	4a 24       	lddpc	r4,80004f00 <rfid_auto_reader+0x4>
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	48 e8       	lddpc	r8,80004eb4 <PcdSelect+0x2c>
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	49 e0       	lddpc	r0,80004ef8 <PcdSelect+0x70>
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	49 a0       	lddpc	r0,80004eec <PcdSelect+0x64>

80004e88 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e88:	eb cd 40 80 	pushm	r7,lr
80004e8c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e8e:	39 38       	mov	r8,-109
80004e90:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004e92:	37 08       	mov	r8,112
80004e94:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004e96:	30 08       	mov	r8,0
80004e98:	ba e8       	st.b	sp[0x6],r8
80004e9a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004e9e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004ea2:	19 89       	ld.ub	r9,r12[0x0]
80004ea4:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004ea6:	19 3a       	ld.ub	r10,r12++
80004ea8:	1b e9       	ld.ub	r9,sp[0x6]
80004eaa:	f5 e9 20 09 	eor	r9,r10,r9
80004eae:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004eb0:	16 38       	cp.w	r8,r11
80004eb2:	cf 81       	brne	80004ea2 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004eb4:	1a 97       	mov	r7,sp
80004eb6:	fa ca ff f9 	sub	r10,sp,-7
80004eba:	30 7b       	mov	r11,7
80004ebc:	1a 9c       	mov	r12,sp
80004ebe:	f0 1f 00 0d 	mcall	80004ef0 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004ec2:	30 8b       	mov	r11,8
80004ec4:	16 9c       	mov	r12,r11
80004ec6:	f0 1f 00 0c 	mcall	80004ef4 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004eca:	fa c8 ff ed 	sub	r8,sp,-19
80004ece:	1a 99       	mov	r9,sp
80004ed0:	30 9a       	mov	r10,9
80004ed2:	1a 9b       	mov	r11,sp
80004ed4:	30 cc       	mov	r12,12
80004ed6:	f0 1f 00 09 	mcall	80004ef8 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004eda:	c0 71       	brne	80004ee8 <PcdSelect+0x60>
80004edc:	31 88       	mov	r8,24
80004ede:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ee2:	f0 09 18 00 	cp.b	r9,r8
80004ee6:	c0 20       	breq	80004eea <PcdSelect+0x62>
80004ee8:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004eea:	2f bd       	sub	sp,-20
80004eec:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	4d fc       	lddpc	r12,8000506c <rfid_sendID_message+0x50>
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4a 24       	lddpc	r4,80004f7c <rfid_auto_reader+0x80>
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	4b 9c       	lddpc	r12,80004fdc <rfid_auto_reader+0xe0>

80004efc <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004efc:	eb cd 40 c0 	pushm	r6-r7,lr
80004f00:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f02:	f0 1f 00 37 	mcall	80004fdc <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f06:	4b 7b       	lddpc	r11,80004fe0 <rfid_auto_reader+0xe4>
80004f08:	35 2c       	mov	r12,82
80004f0a:	f0 1f 00 37 	mcall	80004fe4 <rfid_auto_reader+0xe8>
80004f0e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f10:	c6 31       	brne	80004fd6 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f12:	4b 48       	lddpc	r8,80004fe0 <rfid_auto_reader+0xe4>
80004f14:	11 88       	ld.ub	r8,r8[0x0]
80004f16:	30 49       	mov	r9,4
80004f18:	f2 08 18 00 	cp.b	r8,r9
80004f1c:	c0 b1       	brne	80004f32 <rfid_auto_reader+0x36>
80004f1e:	4b 19       	lddpc	r9,80004fe0 <rfid_auto_reader+0xe4>
80004f20:	13 9a       	ld.ub	r10,r9[0x1]
80004f22:	30 09       	mov	r9,0
80004f24:	f2 0a 18 00 	cp.b	r10,r9
80004f28:	c0 51       	brne	80004f32 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f2a:	4b 0c       	lddpc	r12,80004fe8 <rfid_auto_reader+0xec>
80004f2c:	f0 1f 00 30 	mcall	80004fec <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f30:	c3 c8       	rjmp	80004fa8 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f32:	30 29       	mov	r9,2
80004f34:	f2 08 18 00 	cp.b	r8,r9
80004f38:	c0 b1       	brne	80004f4e <rfid_auto_reader+0x52>
80004f3a:	4a a9       	lddpc	r9,80004fe0 <rfid_auto_reader+0xe4>
80004f3c:	13 9a       	ld.ub	r10,r9[0x1]
80004f3e:	30 09       	mov	r9,0
80004f40:	f2 0a 18 00 	cp.b	r10,r9
80004f44:	c0 51       	brne	80004f4e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f46:	4a bc       	lddpc	r12,80004ff0 <rfid_auto_reader+0xf4>
80004f48:	f0 1f 00 29 	mcall	80004fec <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f4c:	c2 e8       	rjmp	80004fa8 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f4e:	34 49       	mov	r9,68
80004f50:	f2 08 18 00 	cp.b	r8,r9
80004f54:	c0 b1       	brne	80004f6a <rfid_auto_reader+0x6e>
80004f56:	4a 39       	lddpc	r9,80004fe0 <rfid_auto_reader+0xe4>
80004f58:	13 9a       	ld.ub	r10,r9[0x1]
80004f5a:	30 09       	mov	r9,0
80004f5c:	f2 0a 18 00 	cp.b	r10,r9
80004f60:	c0 51       	brne	80004f6a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f62:	4a 5c       	lddpc	r12,80004ff4 <rfid_auto_reader+0xf8>
80004f64:	f0 1f 00 22 	mcall	80004fec <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f68:	c2 08       	rjmp	80004fa8 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f6a:	30 89       	mov	r9,8
80004f6c:	f2 08 18 00 	cp.b	r8,r9
80004f70:	c0 b1       	brne	80004f86 <rfid_auto_reader+0x8a>
80004f72:	49 c9       	lddpc	r9,80004fe0 <rfid_auto_reader+0xe4>
80004f74:	13 9a       	ld.ub	r10,r9[0x1]
80004f76:	30 09       	mov	r9,0
80004f78:	f2 0a 18 00 	cp.b	r10,r9
80004f7c:	c0 51       	brne	80004f86 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004f7e:	49 fc       	lddpc	r12,80004ff8 <rfid_auto_reader+0xfc>
80004f80:	f0 1f 00 1b 	mcall	80004fec <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f84:	c1 28       	rjmp	80004fa8 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f86:	34 49       	mov	r9,68
80004f88:	f2 08 18 00 	cp.b	r8,r9
80004f8c:	c0 b1       	brne	80004fa2 <rfid_auto_reader+0xa6>
80004f8e:	49 58       	lddpc	r8,80004fe0 <rfid_auto_reader+0xe4>
80004f90:	11 99       	ld.ub	r9,r8[0x1]
80004f92:	30 38       	mov	r8,3
80004f94:	f0 09 18 00 	cp.b	r9,r8
80004f98:	c0 51       	brne	80004fa2 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004f9a:	49 9c       	lddpc	r12,80004ffc <rfid_auto_reader+0x100>
80004f9c:	f0 1f 00 14 	mcall	80004fec <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fa0:	c0 48       	rjmp	80004fa8 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004fa2:	49 8c       	lddpc	r12,80005000 <rfid_auto_reader+0x104>
80004fa4:	f0 1f 00 12 	mcall	80004fec <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fa8:	49 7c       	lddpc	r12,80005004 <rfid_auto_reader+0x108>
80004faa:	f0 1f 00 18 	mcall	80005008 <rfid_auto_reader+0x10c>
80004fae:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004fb0:	c0 60       	breq	80004fbc <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004fb2:	37 8b       	mov	r11,120
80004fb4:	30 1c       	mov	r12,1
80004fb6:	f0 1f 00 16 	mcall	8000500c <rfid_auto_reader+0x110>
		return status;
80004fba:	c0 e8       	rjmp	80004fd6 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004fbc:	49 2c       	lddpc	r12,80005004 <rfid_auto_reader+0x108>
80004fbe:	f0 1f 00 15 	mcall	80005010 <rfid_auto_reader+0x114>
80004fc2:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004fc4:	c0 91       	brne	80004fd6 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004fc6:	30 4a       	mov	r10,4
80004fc8:	48 fb       	lddpc	r11,80005004 <rfid_auto_reader+0x108>
80004fca:	0c 9c       	mov	r12,r6
80004fcc:	f0 1f 00 12 	mcall	80005014 <rfid_auto_reader+0x118>
		log("select okay\n");
80004fd0:	49 2c       	lddpc	r12,80005018 <rfid_auto_reader+0x11c>
80004fd2:	f0 1f 00 07 	mcall	80004fec <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004fd6:	0e 9c       	mov	r12,r7
80004fd8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	49 20       	lddpc	r0,80005024 <rfid_sendID_message+0x8>
80004fe0:	00 00       	add	r0,r0
80004fe2:	53 ac       	stdsp	sp[0xe8],r12
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	4d 98       	lddpc	r8,80005148 <rfid_sendID_message+0x12c>
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	d7 fc       	*unknown*
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	6f d4       	ld.w	r4,r7[0x74]
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	d8 08       	*unknown*
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	d8 14       	*unknown*
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	d8 24       	*unknown*
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	d8 2c       	*unknown*
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	d8 38       	*unknown*
80005004:	00 00       	add	r0,r0
80005006:	53 b0       	stdsp	sp[0xec],r0
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	4d 14       	lddpc	r4,8000514c <rfid_sendID_message+0x130>
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	40 48       	lddsp	r8,sp[0x10]
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	4e 88       	lddpc	r8,800051b0 <delay_us>
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	78 58       	ld.w	r8,r12[0x14]
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	d8 44       	*unknown*

8000501c <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
8000501c:	eb cd 40 e0 	pushm	r5-r7,lr
80005020:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005022:	fa cc ff 90 	sub	r12,sp,-112
80005026:	30 08       	mov	r8,0
80005028:	30 09       	mov	r9,0
8000502a:	f8 e9 00 00 	st.d	r12[0],r8
8000502e:	30 0a       	mov	r10,0
80005030:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005032:	fa e9 00 20 	st.d	sp[32],r8
80005036:	fa e9 00 28 	st.d	sp[40],r8
8000503a:	fa e9 00 30 	st.d	sp[48],r8
8000503e:	fa e9 00 38 	st.d	sp[56],r8
80005042:	fa e9 00 40 	st.d	sp[64],r8
80005046:	fa e9 00 48 	st.d	sp[72],r8
8000504a:	fa e9 00 50 	st.d	sp[80],r8
8000504e:	fa e9 00 58 	st.d	sp[88],r8
80005052:	fa e9 00 60 	st.d	sp[96],r8
80005056:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
8000505a:	f0 1f 00 43 	mcall	80005164 <rfid_sendID_message+0x148>
8000505e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005060:	c7 61       	brne	8000514c <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005062:	fb 38 00 73 	ld.ub	r8,sp[115]
80005066:	1a d8       	st.w	--sp,r8
80005068:	fb 38 00 76 	ld.ub	r8,sp[118]
8000506c:	1a d8       	st.w	--sp,r8
8000506e:	fb 38 00 79 	ld.ub	r8,sp[121]
80005072:	1a d8       	st.w	--sp,r8
80005074:	fb 38 00 7c 	ld.ub	r8,sp[124]
80005078:	1a d8       	st.w	--sp,r8
8000507a:	4b cc       	lddpc	r12,80005168 <rfid_sendID_message+0x14c>
8000507c:	f0 1f 00 3c 	mcall	8000516c <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005080:	37 7b       	mov	r11,119
80005082:	30 1c       	mov	r12,1
80005084:	f0 1f 00 3b 	mcall	80005170 <rfid_sendID_message+0x154>
80005088:	fa c9 ff 80 	sub	r9,sp,-128
8000508c:	fa c8 ff f0 	sub	r8,sp,-16
80005090:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80005094:	fa c5 ff 7c 	sub	r5,sp,-132
80005098:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000509a:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
8000509c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000509e:	13 8b       	ld.ub	r11,r9[0x0]
800050a0:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050a4:	fc 0c 18 00 	cp.b	r12,lr
800050a8:	f7 bc 08 d0 	subls	r12,-48
800050ac:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800050b0:	f7 bc 0b a9 	subhi	r12,-87
800050b4:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050b8:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800050ba:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800050be:	fc 0b 18 00 	cp.b	r11,lr
800050c2:	f7 bb 08 d0 	subls	r11,-48
800050c6:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800050ca:	f7 bb 0b a9 	subhi	r11,-87
800050ce:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
800050d2:	b0 b6       	st.b	r8[0x3],r6
800050d4:	2f f9       	sub	r9,-1
800050d6:	2f c8       	sub	r8,-4
800050d8:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800050da:	0a 39       	cp.w	r9,r5
800050dc:	ce 11       	brne	8000509e <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
800050de:	30 6a       	mov	r10,6
800050e0:	4a 5b       	lddpc	r11,80005174 <rfid_sendID_message+0x158>
800050e2:	fa cc ff f0 	sub	r12,sp,-16
800050e6:	f0 1f 00 25 	mcall	80005178 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
800050ea:	4a 58       	lddpc	r8,8000517c <rfid_sendID_message+0x160>
800050ec:	11 89       	ld.ub	r9,r8[0x0]
800050ee:	39 f8       	mov	r8,-97
800050f0:	f0 09 18 00 	cp.b	r9,r8
800050f4:	e0 88 00 05 	brls	800050fe <rfid_sendID_message+0xe2>
800050f8:	38 09       	mov	r9,-128
800050fa:	4a 18       	lddpc	r8,8000517c <rfid_sendID_message+0x160>
800050fc:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800050fe:	4a 08       	lddpc	r8,8000517c <rfid_sendID_message+0x160>
80005100:	11 86       	ld.ub	r6,r8[0x0]
80005102:	2f f6       	sub	r6,-1
80005104:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005106:	30 5a       	mov	r10,5
80005108:	49 eb       	lddpc	r11,80005180 <rfid_sendID_message+0x164>
8000510a:	fa cc ff e5 	sub	r12,sp,-27
8000510e:	f0 1f 00 1b 	mcall	80005178 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005112:	31 e8       	mov	r8,30
80005114:	fb 58 00 16 	st.h	sp[22],r8
80005118:	fb 66 00 1a 	st.b	sp[26],r6
8000511c:	fe 78 e0 00 	mov	r8,-8192
80005120:	fb 58 00 18 	st.h	sp[24],r8
80005124:	fa c6 ff e0 	sub	r6,sp,-32
80005128:	30 aa       	mov	r10,10
8000512a:	fa cb ff ea 	sub	r11,sp,-22
8000512e:	0c 9c       	mov	r12,r6
80005130:	f0 1f 00 12 	mcall	80005178 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005134:	31 6a       	mov	r10,22
80005136:	1a 9b       	mov	r11,sp
80005138:	fa cc ff d6 	sub	r12,sp,-42
8000513c:	f0 1f 00 0f 	mcall	80005178 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80005140:	30 9a       	mov	r10,9
80005142:	32 0b       	mov	r11,32
80005144:	0c 9c       	mov	r12,r6
80005146:	f0 1f 00 10 	mcall	80005184 <rfid_sendID_message+0x168>
8000514a:	c0 88       	rjmp	8000515a <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
8000514c:	37 8b       	mov	r11,120
8000514e:	30 1c       	mov	r12,1
80005150:	f0 1f 00 08 	mcall	80005170 <rfid_sendID_message+0x154>
		log("no card find...\n");
80005154:	48 dc       	lddpc	r12,80005188 <rfid_sendID_message+0x16c>
80005156:	f0 1f 00 06 	mcall	8000516c <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
8000515a:	0e 9c       	mov	r12,r7
8000515c:	2e 1d       	sub	sp,-124
8000515e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005162:	00 00       	add	r0,r0
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	4e fc       	lddpc	r12,80005320 <xg_flashc_init+0x60>
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	d8 54       	*unknown*
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	6f d4       	ld.w	r4,r7[0x74]
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	40 48       	lddsp	r8,sp[0x10]
80005174:	00 00       	add	r0,r0
80005176:	0d 9c       	ld.ub	r12,r6[0x1]
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	78 58       	ld.w	r8,r12[0x14]
8000517c:	00 00       	add	r0,r0
8000517e:	05 34       	ld.ub	r4,r2++
80005180:	00 00       	add	r0,r0
80005182:	05 2c       	ld.uh	r12,r2++
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	3f 10       	mov	r0,-15
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	d8 70       	acall	0x87

8000518c <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
8000518c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000518e:	f0 1f 00 02 	mcall	80005194 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80005192:	d8 02       	popm	pc
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	4a cc       	lddpc	r12,80005244 <local_start_pll0+0x18>

80005198 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005198:	58 0c       	cp.w	r12,0
8000519a:	5e 0c       	reteq	r12
8000519c:	30 08       	mov	r8,0
	{
		nop();
8000519e:	d7 03       	nop
		nop();
800051a0:	d7 03       	nop
		nop();
800051a2:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051a4:	2f f8       	sub	r8,-1
800051a6:	10 3c       	cp.w	r12,r8
800051a8:	fe 9b ff fb 	brhi	8000519e <delay_ns+0x6>
800051ac:	5e fc       	retal	r12
800051ae:	d7 03       	nop

800051b0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051b0:	eb cd 40 e0 	pushm	r5-r7,lr
800051b4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051b6:	58 0c       	cp.w	r12,0
800051b8:	c0 b0       	breq	800051ce <delay_us+0x1e>
800051ba:	30 07       	mov	r7,0
		delay_ns(1000);
800051bc:	e0 65 03 e8 	mov	r5,1000
800051c0:	0a 9c       	mov	r12,r5
800051c2:	f0 1f 00 05 	mcall	800051d4 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051c6:	2f f7       	sub	r7,-1
800051c8:	0e 36       	cp.w	r6,r7
800051ca:	fe 9b ff fb 	brhi	800051c0 <delay_us+0x10>
800051ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051d2:	00 00       	add	r0,r0
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	51 98       	stdsp	sp[0x64],r8

800051d8 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800051d8:	eb cd 40 e0 	pushm	r5-r7,lr
800051dc:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800051de:	58 0c       	cp.w	r12,0
800051e0:	c0 b0       	breq	800051f6 <delay_ms+0x1e>
800051e2:	30 07       	mov	r7,0
		delay_us(1000);
800051e4:	e0 65 03 e8 	mov	r5,1000
800051e8:	0a 9c       	mov	r12,r5
800051ea:	f0 1f 00 05 	mcall	800051fc <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800051ee:	2f f7       	sub	r7,-1
800051f0:	0e 36       	cp.w	r6,r7
800051f2:	fe 9b ff fb 	brhi	800051e8 <delay_ms+0x10>
800051f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051fa:	00 00       	add	r0,r0
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	51 b0       	stdsp	sp[0x6c],r0

80005200 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005200:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005202:	30 3b       	mov	r11,3
80005204:	48 8c       	lddpc	r12,80005224 <local_start_timer+0x24>
80005206:	f0 1f 00 09 	mcall	80005228 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000520a:	fe 78 38 00 	mov	r8,-51200
8000520e:	e0 69 91 0d 	mov	r9,37133
80005212:	ea 19 00 52 	orh	r9,0x52
80005216:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005218:	32 09       	mov	r9,32
8000521a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000521c:	30 59       	mov	r9,5
8000521e:	91 09       	st.w	r8[0x0],r9
}
80005220:	d8 02       	popm	pc
80005222:	00 00       	add	r0,r0
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	d8 84       	*unknown*
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	53 b8       	stdsp	sp[0xec],r8

8000522c <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
8000522c:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000522e:	30 3a       	mov	r10,3
80005230:	e0 6b 1b 00 	mov	r11,6912
80005234:	ea 1b 00 b7 	orh	r11,0xb7
80005238:	fe 7c 0c 00 	mov	r12,-62464
8000523c:	f0 1f 00 19 	mcall	800052a0 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005240:	31 08       	mov	r8,16
80005242:	1a d8       	st.w	--sp,r8
80005244:	30 08       	mov	r8,0
80005246:	30 19       	mov	r9,1
80005248:	30 7a       	mov	r10,7
8000524a:	10 9b       	mov	r11,r8
8000524c:	fe 7c 0c 00 	mov	r12,-62464
80005250:	f0 1f 00 15 	mcall	800052a4 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005254:	30 08       	mov	r8,0
80005256:	30 19       	mov	r9,1
80005258:	12 9a       	mov	r10,r9
8000525a:	10 9b       	mov	r11,r8
8000525c:	fe 7c 0c 00 	mov	r12,-62464
80005260:	f0 1f 00 12 	mcall	800052a8 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005264:	30 0b       	mov	r11,0
80005266:	fe 7c 0c 00 	mov	r12,-62464
8000526a:	f0 1f 00 11 	mcall	800052ac <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000526e:	fe 7c 0c 00 	mov	r12,-62464
80005272:	f0 1f 00 10 	mcall	800052b0 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005276:	30 0a       	mov	r10,0
80005278:	1a da       	st.w	--sp,r10
8000527a:	1a da       	st.w	--sp,r10
8000527c:	14 98       	mov	r8,r10
8000527e:	14 99       	mov	r9,r10
80005280:	30 1b       	mov	r11,1
80005282:	fe 7c 0c 00 	mov	r12,-62464
80005286:	f0 1f 00 0c 	mcall	800052b4 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000528a:	30 1c       	mov	r12,1
8000528c:	f0 1f 00 0b 	mcall	800052b8 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005290:	30 2b       	mov	r11,2
80005292:	fe 7c 0c 00 	mov	r12,-62464
80005296:	f0 1f 00 0a 	mcall	800052bc <local_start_pll0+0x90>
8000529a:	2f dd       	sub	sp,-12
/****/
}
8000529c:	d8 02       	popm	pc
8000529e:	00 00       	add	r0,r0
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	56 c0       	stdsp	sp[0x1b0],r0
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	56 62       	stdsp	sp[0x198],r2
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	56 84       	stdsp	sp[0x1a0],r4
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	56 9e       	stdsp	sp[0x1a4],lr
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	56 ac       	stdsp	sp[0x1a8],r12
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	56 1c       	stdsp	sp[0x184],r12
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	53 58       	stdsp	sp[0xd4],r8
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	56 b6       	stdsp	sp[0x1ac],r6

800052c0 <xg_flashc_init>:
	//
}

//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052c0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800052c4:	f0 1f 00 1a 	mcall	8000532c <xg_flashc_init+0x6c>
800052c8:	49 a8       	lddpc	r8,80005330 <xg_flashc_init+0x70>
800052ca:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800052cc:	70 08       	ld.w	r8,r8[0x0]
800052ce:	58 08       	cp.w	r8,0
800052d0:	c0 41       	brne	800052d8 <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
800052d2:	49 9c       	lddpc	r12,80005334 <xg_flashc_init+0x74>
800052d4:	f0 1f 00 19 	mcall	80005338 <xg_flashc_init+0x78>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800052d8:	30 0b       	mov	r11,0
800052da:	30 1c       	mov	r12,1
800052dc:	f0 1f 00 18 	mcall	8000533c <xg_flashc_init+0x7c>
800052e0:	49 88       	lddpc	r8,80005340 <xg_flashc_init+0x80>
800052e2:	91 0c       	st.w	r8[0x0],r12
800052e4:	70 08       	ld.w	r8,r8[0x0]
800052e6:	58 08       	cp.w	r8,0
800052e8:	c0 80       	breq	800052f8 <xg_flashc_init+0x38>
800052ea:	49 68       	lddpc	r8,80005340 <xg_flashc_init+0x80>
800052ec:	70 0c       	ld.w	r12,r8[0x0]
800052ee:	30 09       	mov	r9,0
800052f0:	12 9a       	mov	r10,r9
800052f2:	12 9b       	mov	r11,r9
800052f4:	f0 1f 00 14 	mcall	80005344 <xg_flashc_init+0x84>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
800052f8:	30 4b       	mov	r11,4
800052fa:	31 4c       	mov	r12,20
800052fc:	f0 1f 00 10 	mcall	8000533c <xg_flashc_init+0x7c>
80005300:	49 28       	lddpc	r8,80005348 <xg_flashc_init+0x88>
80005302:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005304:	30 4b       	mov	r11,4
80005306:	31 4c       	mov	r12,20
80005308:	f0 1f 00 0d 	mcall	8000533c <xg_flashc_init+0x7c>
8000530c:	49 08       	lddpc	r8,8000534c <xg_flashc_init+0x8c>
8000530e:	91 0c       	st.w	r8[0x0],r12
80005310:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005312:	10 96       	mov	r6,r8
80005314:	48 f5       	lddpc	r5,80005350 <xg_flashc_init+0x90>
80005316:	6c 0c       	ld.w	r12,r6[0x0]
80005318:	ea 07 00 0b 	add	r11,r5,r7
8000531c:	f0 1f 00 0e 	mcall	80005354 <xg_flashc_init+0x94>
80005320:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005322:	e0 47 02 80 	cp.w	r7,640
80005326:	cf 81       	brne	80005316 <xg_flashc_init+0x56>
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
80005328:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	64 9c       	ld.w	r12,r2[0x24]
80005330:	00 00       	add	r0,r0
80005332:	0b 70       	ld.ub	r0,--r5
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	d8 9c       	*unknown*
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	6f d4       	ld.w	r4,r7[0x74]
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	64 f4       	ld.w	r4,r2[0x3c]
80005340:	00 00       	add	r0,r0
80005342:	53 b4       	stdsp	sp[0xec],r4
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	63 9c       	ld.w	r12,r1[0x64]
80005348:	00 00       	add	r0,r0
8000534a:	0b 6c       	ld.uh	r12,--r5
8000534c:	00 00       	add	r0,r0
8000534e:	0b 74       	ld.ub	r4,--r5
80005350:	00 00       	add	r0,r0
80005352:	0d a2       	ld.ub	r2,r6[0x2]
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	2b d8       	sub	r8,-67

80005358 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005358:	fe 68 14 00 	mov	r8,-125952
8000535c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000535e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005362:	91 09       	st.w	r8[0x0],r9
}
80005364:	5e fc       	retal	r12

80005366 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005366:	f8 08 16 05 	lsr	r8,r12,0x5
8000536a:	a9 68       	lsl	r8,0x8
8000536c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005370:	58 1b       	cp.w	r11,1
80005372:	c0 d0       	breq	8000538c <gpio_enable_module_pin+0x26>
80005374:	c0 63       	brcs	80005380 <gpio_enable_module_pin+0x1a>
80005376:	58 2b       	cp.w	r11,2
80005378:	c1 00       	breq	80005398 <gpio_enable_module_pin+0x32>
8000537a:	58 3b       	cp.w	r11,3
8000537c:	c1 40       	breq	800053a4 <gpio_enable_module_pin+0x3e>
8000537e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005380:	30 19       	mov	r9,1
80005382:	f2 0c 09 49 	lsl	r9,r9,r12
80005386:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005388:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000538a:	c1 28       	rjmp	800053ae <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000538c:	30 19       	mov	r9,1
8000538e:	f2 0c 09 49 	lsl	r9,r9,r12
80005392:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005394:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005396:	c0 c8       	rjmp	800053ae <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005398:	30 19       	mov	r9,1
8000539a:	f2 0c 09 49 	lsl	r9,r9,r12
8000539e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053a0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053a2:	c0 68       	rjmp	800053ae <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053a4:	30 19       	mov	r9,1
800053a6:	f2 0c 09 49 	lsl	r9,r9,r12
800053aa:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053ac:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053ae:	30 19       	mov	r9,1
800053b0:	f2 0c 09 4c 	lsl	r12,r9,r12
800053b4:	91 2c       	st.w	r8[0x8],r12
800053b6:	5e fd       	retal	0

800053b8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053b8:	d4 21       	pushm	r4-r7,lr
800053ba:	18 97       	mov	r7,r12
800053bc:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053be:	58 0b       	cp.w	r11,0
800053c0:	c0 31       	brne	800053c6 <gpio_enable_module+0xe>
800053c2:	30 05       	mov	r5,0
800053c4:	c0 d8       	rjmp	800053de <gpio_enable_module+0x26>
800053c6:	30 06       	mov	r6,0
800053c8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053ca:	6e 1b       	ld.w	r11,r7[0x4]
800053cc:	6e 0c       	ld.w	r12,r7[0x0]
800053ce:	f0 1f 00 06 	mcall	800053e4 <gpio_enable_module+0x2c>
800053d2:	18 45       	or	r5,r12
		gpiomap++;
800053d4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053d6:	2f f6       	sub	r6,-1
800053d8:	0c 34       	cp.w	r4,r6
800053da:	fe 9b ff f8 	brhi	800053ca <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053de:	0a 9c       	mov	r12,r5
800053e0:	d8 22       	popm	r4-r7,pc
800053e2:	00 00       	add	r0,r0
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	53 66       	stdsp	sp[0xd8],r6

800053e8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053e8:	f8 08 16 05 	lsr	r8,r12,0x5
800053ec:	a9 68       	lsl	r8,0x8
800053ee:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800053f2:	30 19       	mov	r9,1
800053f4:	f2 0c 09 4c 	lsl	r12,r9,r12
800053f8:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800053fc:	91 1c       	st.w	r8[0x4],r12
}
800053fe:	5e fc       	retal	r12

80005400 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005400:	f8 08 16 05 	lsr	r8,r12,0x5
80005404:	a9 68       	lsl	r8,0x8
80005406:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000540a:	30 19       	mov	r9,1
8000540c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005410:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005414:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005418:	91 1c       	st.w	r8[0x4],r12
}
8000541a:	5e fc       	retal	r12

8000541c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000541c:	f8 08 16 05 	lsr	r8,r12,0x5
80005420:	a9 68       	lsl	r8,0x8
80005422:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005426:	30 19       	mov	r9,1
80005428:	f2 0c 09 4c 	lsl	r12,r9,r12
8000542c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005430:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005434:	91 1c       	st.w	r8[0x4],r12
}
80005436:	5e fc       	retal	r12

80005438 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005438:	c0 08       	rjmp	80005438 <_unhandled_interrupt>
8000543a:	d7 03       	nop

8000543c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000543c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005440:	49 99       	lddpc	r9,800054a4 <INTC_register_interrupt+0x68>
80005442:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005446:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000544a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000544c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005450:	58 0a       	cp.w	r10,0
80005452:	c0 91       	brne	80005464 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005454:	49 59       	lddpc	r9,800054a8 <INTC_register_interrupt+0x6c>
80005456:	49 6a       	lddpc	r10,800054ac <INTC_register_interrupt+0x70>
80005458:	12 1a       	sub	r10,r9
8000545a:	fe 79 08 00 	mov	r9,-63488
8000545e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005462:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005464:	58 1a       	cp.w	r10,1
80005466:	c0 a1       	brne	8000547a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005468:	49 09       	lddpc	r9,800054a8 <INTC_register_interrupt+0x6c>
8000546a:	49 2a       	lddpc	r10,800054b0 <INTC_register_interrupt+0x74>
8000546c:	12 1a       	sub	r10,r9
8000546e:	bf aa       	sbr	r10,0x1e
80005470:	fe 79 08 00 	mov	r9,-63488
80005474:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005478:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000547a:	58 2a       	cp.w	r10,2
8000547c:	c0 a1       	brne	80005490 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000547e:	48 b9       	lddpc	r9,800054a8 <INTC_register_interrupt+0x6c>
80005480:	48 da       	lddpc	r10,800054b4 <INTC_register_interrupt+0x78>
80005482:	12 1a       	sub	r10,r9
80005484:	bf ba       	sbr	r10,0x1f
80005486:	fe 79 08 00 	mov	r9,-63488
8000548a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000548e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005490:	48 69       	lddpc	r9,800054a8 <INTC_register_interrupt+0x6c>
80005492:	48 aa       	lddpc	r10,800054b8 <INTC_register_interrupt+0x7c>
80005494:	12 1a       	sub	r10,r9
80005496:	ea 1a c0 00 	orh	r10,0xc000
8000549a:	fe 79 08 00 	mov	r9,-63488
8000549e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054a2:	5e fc       	retal	r12
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	d9 4c       	*unknown*
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	ce 00       	breq	8000546a <INTC_register_interrupt+0x2e>
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	cf 04       	brge	8000548e <INTC_register_interrupt+0x52>
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	cf 12       	brcc	80005494 <INTC_register_interrupt+0x58>
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	cf 20       	breq	8000549a <INTC_register_interrupt+0x5e>
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	cf 2e       	rcall	8000529e <local_start_pll0+0x72>

800054bc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054bc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054be:	49 18       	lddpc	r8,80005500 <INTC_init_interrupts+0x44>
800054c0:	e3 b8 00 01 	mtsr	0x4,r8
800054c4:	49 0e       	lddpc	lr,80005504 <INTC_init_interrupts+0x48>
800054c6:	30 07       	mov	r7,0
800054c8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054ca:	49 0c       	lddpc	r12,80005508 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054cc:	49 05       	lddpc	r5,8000550c <INTC_init_interrupts+0x50>
800054ce:	10 15       	sub	r5,r8
800054d0:	fe 76 08 00 	mov	r6,-63488
800054d4:	c1 08       	rjmp	800054f4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054d6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054d8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054da:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054dc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054e0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054e2:	10 3a       	cp.w	r10,r8
800054e4:	fe 9b ff fc 	brhi	800054dc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054e8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054ec:	2f f7       	sub	r7,-1
800054ee:	2f 8e       	sub	lr,-8
800054f0:	59 37       	cp.w	r7,19
800054f2:	c0 50       	breq	800054fc <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f4:	7c 08       	ld.w	r8,lr[0x0]
800054f6:	58 08       	cp.w	r8,0
800054f8:	ce f1       	brne	800054d6 <INTC_init_interrupts+0x1a>
800054fa:	cf 7b       	rjmp	800054e8 <INTC_init_interrupts+0x2c>
800054fc:	d8 22       	popm	r4-r7,pc
800054fe:	00 00       	add	r0,r0
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	ce 00       	breq	800054c2 <INTC_init_interrupts+0x6>
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	d9 4c       	*unknown*
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	54 38       	stdsp	sp[0x10c],r8
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	cf 04       	brge	800054ee <INTC_init_interrupts+0x32>

80005510 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005510:	fe 78 08 00 	mov	r8,-63488
80005514:	e0 69 00 83 	mov	r9,131
80005518:	f2 0c 01 0c 	sub	r12,r9,r12
8000551c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005520:	f2 ca ff c0 	sub	r10,r9,-64
80005524:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005528:	58 08       	cp.w	r8,0
8000552a:	c0 21       	brne	8000552e <_get_interrupt_handler+0x1e>
8000552c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000552e:	f0 08 12 00 	clz	r8,r8
80005532:	48 5a       	lddpc	r10,80005544 <_get_interrupt_handler+0x34>
80005534:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005538:	f0 08 11 1f 	rsub	r8,r8,31
8000553c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000553e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005542:	5e fc       	retal	r12
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	d9 4c       	*unknown*

80005548 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005548:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000554a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000554e:	99 a8       	st.w	r12[0x28],r8
}
80005550:	5e fc       	retal	r12
80005552:	d7 03       	nop

80005554 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005554:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005556:	ec 5b bb 9f 	cp.w	r11,899999
8000555a:	e0 8b 00 04 	brhi	80005562 <pm_enable_osc0_crystal+0xe>
8000555e:	30 4b       	mov	r11,4
80005560:	c1 38       	rjmp	80005586 <pm_enable_osc0_crystal+0x32>
80005562:	e0 68 c6 bf 	mov	r8,50879
80005566:	ea 18 00 2d 	orh	r8,0x2d
8000556a:	10 3b       	cp.w	r11,r8
8000556c:	e0 8b 00 04 	brhi	80005574 <pm_enable_osc0_crystal+0x20>
80005570:	30 5b       	mov	r11,5
80005572:	c0 a8       	rjmp	80005586 <pm_enable_osc0_crystal+0x32>
80005574:	e0 68 12 00 	mov	r8,4608
80005578:	ea 18 00 7a 	orh	r8,0x7a
8000557c:	10 3b       	cp.w	r11,r8
8000557e:	f9 bb 03 06 	movlo	r11,6
80005582:	f9 bb 02 07 	movhs	r11,7
80005586:	f0 1f 00 02 	mcall	8000558c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000558a:	d8 02       	popm	pc
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	55 48       	stdsp	sp[0x150],r8

80005590 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005590:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005592:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005596:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005598:	78 08       	ld.w	r8,r12[0x0]
8000559a:	a3 a8       	sbr	r8,0x2
8000559c:	99 08       	st.w	r12[0x0],r8
}
8000559e:	5e fc       	retal	r12

800055a0 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800055a0:	79 58       	ld.w	r8,r12[0x54]
800055a2:	e2 18 00 80 	andl	r8,0x80,COH
800055a6:	cf d0       	breq	800055a0 <pm_wait_for_clk0_ready>
}
800055a8:	5e fc       	retal	r12
800055aa:	d7 03       	nop

800055ac <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800055ac:	eb cd 40 80 	pushm	r7,lr
800055b0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055b2:	f0 1f 00 04 	mcall	800055c0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055b6:	0e 9c       	mov	r12,r7
800055b8:	f0 1f 00 03 	mcall	800055c4 <pm_enable_clk0+0x18>
}
800055bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	55 90       	stdsp	sp[0x164],r0
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	55 a0       	stdsp	sp[0x168],r0

800055c8 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055c8:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800055ca:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800055ce:	99 c8       	st.w	r12[0x30],r8
}
800055d0:	5e fc       	retal	r12
800055d2:	d7 03       	nop

800055d4 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800055d4:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800055d6:	30 1b       	mov	r11,1
800055d8:	f0 1f 00 02 	mcall	800055e0 <pm_enable_osc32_crystal+0xc>
}
800055dc:	d8 02       	popm	pc
800055de:	00 00       	add	r0,r0
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	55 c8       	stdsp	sp[0x170],r8

800055e4 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055e4:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800055e6:	30 19       	mov	r9,1
800055e8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800055ec:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800055f0:	99 c8       	st.w	r12[0x30],r8
}
800055f2:	5e fc       	retal	r12

800055f4 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
800055f4:	79 58       	ld.w	r8,r12[0x54]
800055f6:	e2 18 02 00 	andl	r8,0x200,COH
800055fa:	cf d0       	breq	800055f4 <pm_wait_for_clk32_ready>
}
800055fc:	5e fc       	retal	r12
800055fe:	d7 03       	nop

80005600 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005600:	eb cd 40 80 	pushm	r7,lr
80005604:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005606:	f0 1f 00 04 	mcall	80005614 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000560a:	0e 9c       	mov	r12,r7
8000560c:	f0 1f 00 03 	mcall	80005618 <pm_enable_clk32+0x18>
}
80005610:	e3 cd 80 80 	ldm	sp++,r7,pc
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	55 e4       	stdsp	sp[0x178],r4
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	55 f4       	stdsp	sp[0x17c],r4

8000561c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000561c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005620:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005624:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005626:	09 f7       	ld.ub	r7,r4[0x7]
80005628:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000562c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005630:	09 b4       	ld.ub	r4,r4[0x3]
80005632:	08 96       	mov	r6,r4
80005634:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005638:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000563c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005640:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005644:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005648:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000564c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005650:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005654:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005656:	79 58       	ld.w	r8,r12[0x54]
80005658:	e2 18 00 20 	andl	r8,0x20,COH
8000565c:	cf d0       	breq	80005656 <pm_cksel+0x3a>
}
8000565e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005662 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005662:	eb cd 40 80 	pushm	r7,lr
80005666:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005668:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000566a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000566e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005672:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005676:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000567a:	2f 8b       	sub	r11,-8
8000567c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005680:	e3 cd 80 80 	ldm	sp++,r7,pc

80005684 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005684:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005686:	2f 8b       	sub	r11,-8
80005688:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000568c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005690:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005694:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005698:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000569c:	d8 02       	popm	pc

8000569e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000569e:	2f 8b       	sub	r11,-8
800056a0:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800056a4:	a1 a8       	sbr	r8,0x0
800056a6:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800056aa:	5e fc       	retal	r12

800056ac <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056ac:	79 58       	ld.w	r8,r12[0x54]
800056ae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800056b2:	cf d0       	breq	800056ac <pm_wait_for_pll0_locked>
}
800056b4:	5e fc       	retal	r12

800056b6 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800056b6:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800056b8:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800056bc:	99 08       	st.w	r12[0x0],r8
}
800056be:	5e fc       	retal	r12

800056c0 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800056c0:	eb cd 40 c0 	pushm	r6-r7,lr
800056c4:	18 97       	mov	r7,r12
800056c6:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800056c8:	f0 1f 00 06 	mcall	800056e0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800056cc:	0c 9b       	mov	r11,r6
800056ce:	0e 9c       	mov	r12,r7
800056d0:	f0 1f 00 05 	mcall	800056e4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800056d4:	30 1b       	mov	r11,1
800056d6:	0e 9c       	mov	r12,r7
800056d8:	f0 1f 00 04 	mcall	800056e8 <pm_switch_to_osc0+0x28>
}
800056dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	55 54       	stdsp	sp[0x154],r4
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	55 ac       	stdsp	sp[0x168],r12
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	56 b6       	stdsp	sp[0x1ac],r6

800056ec <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800056ec:	78 0c       	ld.w	r12,r12[0x0]
}
800056ee:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800056f2:	5e fc       	retal	r12

800056f4 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
800056f4:	eb cd 40 c0 	pushm	r6-r7,lr
800056f8:	18 97       	mov	r7,r12
800056fa:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800056fc:	0e 9c       	mov	r12,r7
800056fe:	f0 1f 00 06 	mcall	80005714 <rtc_set_value+0x20>
80005702:	cf d1       	brne	800056fc <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005704:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005706:	0e 9c       	mov	r12,r7
80005708:	f0 1f 00 03 	mcall	80005714 <rtc_set_value+0x20>
8000570c:	cf d1       	brne	80005706 <rtc_set_value+0x12>
}
8000570e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005712:	00 00       	add	r0,r0
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	56 ec       	stdsp	sp[0x1b8],r12

80005718 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005718:	eb cd 40 80 	pushm	r7,lr
8000571c:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000571e:	0e 9c       	mov	r12,r7
80005720:	f0 1f 00 06 	mcall	80005738 <rtc_enable+0x20>
80005724:	cf d1       	brne	8000571e <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005726:	6e 08       	ld.w	r8,r7[0x0]
80005728:	a1 a8       	sbr	r8,0x0
8000572a:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000572c:	0e 9c       	mov	r12,r7
8000572e:	f0 1f 00 03 	mcall	80005738 <rtc_enable+0x20>
80005732:	cf d1       	brne	8000572c <rtc_enable+0x14>
}
80005734:	e3 cd 80 80 	ldm	sp++,r7,pc
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	56 ec       	stdsp	sp[0x1b8],r12

8000573c <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
8000573c:	30 18       	mov	r8,1
8000573e:	99 48       	st.w	r12[0x10],r8
}
80005740:	5e fc       	retal	r12
80005742:	d7 03       	nop

80005744 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005744:	eb cd 40 c0 	pushm	r6-r7,lr
80005748:	18 97       	mov	r7,r12
8000574a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000574c:	0e 9c       	mov	r12,r7
8000574e:	f0 1f 00 06 	mcall	80005764 <rtc_set_top_value+0x20>
80005752:	cf d1       	brne	8000574c <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005754:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005756:	0e 9c       	mov	r12,r7
80005758:	f0 1f 00 03 	mcall	80005764 <rtc_set_top_value+0x20>
8000575c:	cf d1       	brne	80005756 <rtc_set_top_value+0x12>
}
8000575e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005762:	00 00       	add	r0,r0
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	56 ec       	stdsp	sp[0x1b8],r12

80005768 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005768:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
8000576c:	e6 18 00 01 	andh	r8,0x1,COH
80005770:	c0 71       	brne	8000577e <rtc_clear_interrupt+0x16>
80005772:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005774:	30 18       	mov	r8,1
80005776:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005778:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000577a:	d5 03       	csrf	0x10
8000577c:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000577e:	30 18       	mov	r8,1
80005780:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005782:	78 78       	ld.w	r8,r12[0x1c]
80005784:	5e fc       	retal	r12
80005786:	d7 03       	nop

80005788 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005788:	eb cd 40 e0 	pushm	r5-r7,lr
8000578c:	18 97       	mov	r7,r12
8000578e:	16 96       	mov	r6,r11
80005790:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80005792:	30 18       	mov	r8,1
80005794:	f0 0b 18 00 	cp.b	r11,r8
80005798:	5f b9       	srhi	r9
8000579a:	30 f8       	mov	r8,15
8000579c:	f0 0a 18 00 	cp.b	r10,r8
800057a0:	5f b8       	srhi	r8
800057a2:	f3 e8 10 08 	or	r8,r9,r8
800057a6:	c0 30       	breq	800057ac <rtc_init+0x24>
800057a8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800057ac:	30 18       	mov	r8,1
800057ae:	f0 0b 18 00 	cp.b	r11,r8
800057b2:	c0 a1       	brne	800057c6 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800057b4:	fe 7c 0c 00 	mov	r12,-62464
800057b8:	f0 1f 00 0f 	mcall	800057f4 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800057bc:	30 0b       	mov	r11,0
800057be:	fe 7c 0c 00 	mov	r12,-62464
800057c2:	f0 1f 00 0e 	mcall	800057f8 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800057c6:	0e 9c       	mov	r12,r7
800057c8:	f0 1f 00 0d 	mcall	800057fc <rtc_init+0x74>
800057cc:	cf d1       	brne	800057c6 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800057ce:	a3 76       	lsl	r6,0x3
800057d0:	b1 a6       	sbr	r6,0x10
800057d2:	ed e5 10 85 	or	r5,r6,r5<<0x8
800057d6:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800057d8:	0e 9c       	mov	r12,r7
800057da:	f0 1f 00 09 	mcall	800057fc <rtc_init+0x74>
800057de:	cf d1       	brne	800057d8 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800057e0:	30 0b       	mov	r11,0
800057e2:	0e 9c       	mov	r12,r7
800057e4:	f0 1f 00 07 	mcall	80005800 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800057e8:	3f fb       	mov	r11,-1
800057ea:	0e 9c       	mov	r12,r7
800057ec:	f0 1f 00 06 	mcall	80005804 <rtc_init+0x7c>
800057f0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	55 d4       	stdsp	sp[0x174],r4
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	56 00       	stdsp	sp[0x180],r0
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	56 ec       	stdsp	sp[0x1b8],r12
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	56 f4       	stdsp	sp[0x1bc],r4
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	57 44       	stdsp	sp[0x1d0],r4

80005808 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005808:	f8 c8 00 01 	sub	r8,r12,1
8000580c:	f0 0b 00 0b 	add	r11,r8,r11
80005810:	f6 0c 0d 0a 	divu	r10,r11,r12
80005814:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005816:	f4 c8 00 01 	sub	r8,r10,1
8000581a:	e0 48 00 fe 	cp.w	r8,254
8000581e:	e0 88 00 03 	brls	80005824 <getBaudDiv+0x1c>
80005822:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005824:	5c 8c       	casts.h	r12
}
80005826:	5e fc       	retal	r12

80005828 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005828:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000582c:	30 18       	mov	r8,1
8000582e:	f0 09 18 00 	cp.b	r9,r8
80005832:	e0 88 00 04 	brls	8000583a <spi_initMaster+0x12>
80005836:	30 2c       	mov	r12,2
80005838:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000583a:	e0 68 00 80 	mov	r8,128
8000583e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005840:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005842:	30 19       	mov	r9,1
80005844:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005848:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000584c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005850:	30 09       	mov	r9,0
80005852:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005856:	30 fa       	mov	r10,15
80005858:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000585c:	99 18       	st.w	r12[0x4],r8
8000585e:	5e f9       	retal	r9

80005860 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005860:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005862:	30 18       	mov	r8,1
80005864:	f0 0b 18 00 	cp.b	r11,r8
80005868:	5f be       	srhi	lr
8000586a:	f0 0a 18 00 	cp.b	r10,r8
8000586e:	5f b8       	srhi	r8
80005870:	fd e8 10 08 	or	r8,lr,r8
80005874:	c0 30       	breq	8000587a <spi_selectionMode+0x1a>
80005876:	30 2c       	mov	r12,2
80005878:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000587a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000587c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005880:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005884:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005888:	99 18       	st.w	r12[0x4],r8
8000588a:	d8 0a       	popm	pc,r12=0

8000588c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000588c:	30 18       	mov	r8,1
8000588e:	99 08       	st.w	r12[0x0],r8
}
80005890:	5e fc       	retal	r12

80005892 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005892:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005896:	c0 58       	rjmp	800058a0 <spi_write+0xe>
		if (!timeout--) {
80005898:	58 08       	cp.w	r8,0
8000589a:	c0 21       	brne	8000589e <spi_write+0xc>
8000589c:	5e ff       	retal	1
8000589e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058a0:	78 49       	ld.w	r9,r12[0x10]
800058a2:	e2 19 00 02 	andl	r9,0x2,COH
800058a6:	cf 90       	breq	80005898 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800058a8:	5c 7b       	castu.h	r11
800058aa:	99 3b       	st.w	r12[0xc],r11
800058ac:	5e fd       	retal	0

800058ae <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800058ae:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058b2:	c0 58       	rjmp	800058bc <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058b4:	58 08       	cp.w	r8,0
800058b6:	c0 21       	brne	800058ba <spi_read+0xc>
800058b8:	5e ff       	retal	1
800058ba:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058bc:	78 49       	ld.w	r9,r12[0x10]
800058be:	e2 19 02 01 	andl	r9,0x201,COH
800058c2:	e0 49 02 01 	cp.w	r9,513
800058c6:	cf 71       	brne	800058b4 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800058c8:	78 28       	ld.w	r8,r12[0x8]
800058ca:	b6 08       	st.h	r11[0x0],r8
800058cc:	5e fd       	retal	0
800058ce:	d7 03       	nop

800058d0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800058d0:	eb cd 40 f8 	pushm	r3-r7,lr
800058d4:	18 95       	mov	r5,r12
800058d6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058d8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800058dc:	30 38       	mov	r8,3
800058de:	f0 06 18 00 	cp.b	r6,r8
800058e2:	e0 8b 00 5e 	brhi	8000599e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800058e6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058ea:	30 18       	mov	r8,1
800058ec:	f0 04 18 00 	cp.b	r4,r8
800058f0:	e0 8b 00 57 	brhi	8000599e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800058f4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058f8:	30 78       	mov	r8,7
800058fa:	f0 03 18 00 	cp.b	r3,r8
800058fe:	e0 88 00 50 	brls	8000599e <spi_setupChipReg+0xce>
80005902:	31 08       	mov	r8,16
80005904:	f0 03 18 00 	cp.b	r3,r8
80005908:	e0 8b 00 4b 	brhi	8000599e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000590c:	14 9b       	mov	r11,r10
8000590e:	6e 1c       	ld.w	r12,r7[0x4]
80005910:	f0 1f 00 26 	mcall	800059a8 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005914:	c4 55       	brlt	8000599e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005916:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005918:	ec 09 16 01 	lsr	r9,r6,0x1
8000591c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005920:	ec 16 00 01 	eorl	r6,0x1
80005924:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005928:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000592c:	20 83       	sub	r3,8
8000592e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005932:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005936:	ef 39 00 09 	ld.ub	r9,r7[9]
8000593a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000593e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005942:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005946:	0f 89       	ld.ub	r9,r7[0x0]
80005948:	30 1a       	mov	r10,1
8000594a:	f4 09 18 00 	cp.b	r9,r10
8000594e:	c0 d0       	breq	80005968 <spi_setupChipReg+0x98>
80005950:	c0 a3       	brcs	80005964 <spi_setupChipReg+0x94>
80005952:	30 2a       	mov	r10,2
80005954:	f4 09 18 00 	cp.b	r9,r10
80005958:	c0 a0       	breq	8000596c <spi_setupChipReg+0x9c>
8000595a:	30 3a       	mov	r10,3
8000595c:	f4 09 18 00 	cp.b	r9,r10
80005960:	c1 f1       	brne	8000599e <spi_setupChipReg+0xce>
80005962:	c0 78       	rjmp	80005970 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005964:	8b c8       	st.w	r5[0x30],r8
		break;
80005966:	c0 68       	rjmp	80005972 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005968:	8b d8       	st.w	r5[0x34],r8
		break;
8000596a:	c0 48       	rjmp	80005972 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000596c:	8b e8       	st.w	r5[0x38],r8
		break;
8000596e:	c0 28       	rjmp	80005972 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005970:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005972:	48 f8       	lddpc	r8,800059ac <spi_setupChipReg+0xdc>
80005974:	70 08       	ld.w	r8,r8[0x0]
80005976:	58 08       	cp.w	r8,0
80005978:	c1 61       	brne	800059a4 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000597a:	30 0b       	mov	r11,0
8000597c:	30 1c       	mov	r12,1
8000597e:	f0 1f 00 0d 	mcall	800059b0 <spi_setupChipReg+0xe0>
80005982:	48 b8       	lddpc	r8,800059ac <spi_setupChipReg+0xdc>
80005984:	91 0c       	st.w	r8[0x0],r12
80005986:	58 0c       	cp.w	r12,0
80005988:	c0 a0       	breq	8000599c <spi_setupChipReg+0xcc>
8000598a:	30 09       	mov	r9,0
8000598c:	12 9a       	mov	r10,r9
8000598e:	12 9b       	mov	r11,r9
80005990:	f0 1f 00 09 	mcall	800059b4 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005994:	48 68       	lddpc	r8,800059ac <spi_setupChipReg+0xdc>
80005996:	70 08       	ld.w	r8,r8[0x0]
80005998:	58 08       	cp.w	r8,0
8000599a:	c0 51       	brne	800059a4 <spi_setupChipReg+0xd4>
8000599c:	c0 08       	rjmp	8000599c <spi_setupChipReg+0xcc>
8000599e:	30 2c       	mov	r12,2
800059a0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059a4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059a8:	80 00       	ld.sh	r0,r0[0x0]
800059aa:	58 08       	cp.w	r8,0
800059ac:	00 00       	add	r0,r0
800059ae:	53 bc       	stdsp	sp[0xec],r12
800059b0:	80 00       	ld.sh	r0,r0[0x0]
800059b2:	64 f4       	ld.w	r4,r2[0x3c]
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	63 9c       	ld.w	r12,r1[0x64]

800059b8 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059b8:	d4 01       	pushm	lr
800059ba:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059be:	c0 58       	rjmp	800059c8 <spi_unselectChip+0x10>
		if (!timeout--) {
800059c0:	58 08       	cp.w	r8,0
800059c2:	c0 21       	brne	800059c6 <spi_unselectChip+0xe>
800059c4:	da 0a       	popm	pc,r12=1
800059c6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059c8:	78 49       	ld.w	r9,r12[0x10]
800059ca:	e2 19 02 00 	andl	r9,0x200,COH
800059ce:	cf 90       	breq	800059c0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059d0:	78 18       	ld.w	r8,r12[0x4]
800059d2:	ea 18 00 0f 	orh	r8,0xf
800059d6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800059d8:	fc 18 01 00 	movh	r8,0x100
800059dc:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800059de:	30 09       	mov	r9,0
800059e0:	12 9a       	mov	r10,r9
800059e2:	12 9b       	mov	r11,r9
800059e4:	48 38       	lddpc	r8,800059f0 <spi_unselectChip+0x38>
800059e6:	70 0c       	ld.w	r12,r8[0x0]
800059e8:	f0 1f 00 03 	mcall	800059f4 <spi_unselectChip+0x3c>
800059ec:	d8 0a       	popm	pc,r12=0
800059ee:	00 00       	add	r0,r0
800059f0:	00 00       	add	r0,r0
800059f2:	53 bc       	stdsp	sp[0xec],r12
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	63 9c       	ld.w	r12,r1[0x64]

800059f8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059f8:	eb cd 40 f8 	pushm	r3-r7,lr
800059fc:	18 94       	mov	r4,r12
800059fe:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a00:	49 a6       	lddpc	r6,80005a68 <spi_selectChip+0x70>
80005a02:	30 07       	mov	r7,0
80005a04:	31 45       	mov	r5,20
80005a06:	0e 99       	mov	r9,r7
80005a08:	0a 9a       	mov	r10,r5
80005a0a:	0e 9b       	mov	r11,r7
80005a0c:	6c 0c       	ld.w	r12,r6[0x0]
80005a0e:	f0 1f 00 18 	mcall	80005a6c <spi_selectChip+0x74>
80005a12:	cf a0       	breq	80005a06 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a14:	68 18       	ld.w	r8,r4[0x4]
80005a16:	ea 18 00 0f 	orh	r8,0xf
80005a1a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a1c:	68 18       	ld.w	r8,r4[0x4]
80005a1e:	e2 18 00 04 	andl	r8,0x4,COH
80005a22:	c1 10       	breq	80005a44 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a24:	30 e8       	mov	r8,14
80005a26:	f0 03 18 00 	cp.b	r3,r8
80005a2a:	e0 8b 00 1c 	brhi	80005a62 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a2e:	68 19       	ld.w	r9,r4[0x4]
80005a30:	e6 08 15 10 	lsl	r8,r3,0x10
80005a34:	ea 18 ff f0 	orh	r8,0xfff0
80005a38:	e8 18 ff ff 	orl	r8,0xffff
80005a3c:	12 68       	and	r8,r9
80005a3e:	89 18       	st.w	r4[0x4],r8
80005a40:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a44:	30 38       	mov	r8,3
80005a46:	f0 03 18 00 	cp.b	r3,r8
80005a4a:	e0 8b 00 0c 	brhi	80005a62 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a4e:	68 19       	ld.w	r9,r4[0x4]
80005a50:	2f 03       	sub	r3,-16
80005a52:	30 18       	mov	r8,1
80005a54:	f0 03 09 48 	lsl	r8,r8,r3
80005a58:	5c d8       	com	r8
80005a5a:	12 68       	and	r8,r9
80005a5c:	89 18       	st.w	r4[0x4],r8
80005a5e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a62:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a64:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a68:	00 00       	add	r0,r0
80005a6a:	53 bc       	stdsp	sp[0xec],r12
80005a6c:	80 00       	ld.sh	r0,r0[0x0]
80005a6e:	61 90       	ld.w	r0,r0[0x64]

80005a70 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a70:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a72:	f6 08 15 04 	lsl	r8,r11,0x4
80005a76:	14 38       	cp.w	r8,r10
80005a78:	f9 b8 08 10 	movls	r8,16
80005a7c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a80:	f0 0b 02 4b 	mul	r11,r8,r11
80005a84:	f6 09 16 01 	lsr	r9,r11,0x1
80005a88:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a8c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005a90:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005a94:	f2 cb 00 01 	sub	r11,r9,1
80005a98:	e0 4b ff fe 	cp.w	r11,65534
80005a9c:	e0 88 00 03 	brls	80005aa2 <usart_set_async_baudrate+0x32>
80005aa0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005aa2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005aa4:	e8 6e 00 00 	mov	lr,524288
80005aa8:	59 08       	cp.w	r8,16
80005aaa:	fc 08 17 10 	movne	r8,lr
80005aae:	f9 b8 00 00 	moveq	r8,0
80005ab2:	e4 1b ff f7 	andh	r11,0xfff7
80005ab6:	e0 1b fe cf 	andl	r11,0xfecf
80005aba:	16 48       	or	r8,r11
80005abc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005abe:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005ac2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005ac6:	99 89       	st.w	r12[0x20],r9
80005ac8:	d8 0a       	popm	pc,r12=0

80005aca <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005aca:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005acc:	e2 18 00 02 	andl	r8,0x2,COH
80005ad0:	c0 31       	brne	80005ad6 <usart_write_char+0xc>
80005ad2:	30 2c       	mov	r12,2
80005ad4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005ad6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005ada:	99 7b       	st.w	r12[0x1c],r11
80005adc:	5e fd       	retal	0
80005ade:	d7 03       	nop

80005ae0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005ae0:	eb cd 40 e0 	pushm	r5-r7,lr
80005ae4:	18 96       	mov	r6,r12
80005ae6:	16 95       	mov	r5,r11
80005ae8:	e0 67 27 0f 	mov	r7,9999
80005aec:	c0 68       	rjmp	80005af8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005aee:	58 07       	cp.w	r7,0
80005af0:	c0 31       	brne	80005af6 <usart_putchar+0x16>
80005af2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005af6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005af8:	0a 9b       	mov	r11,r5
80005afa:	0c 9c       	mov	r12,r6
80005afc:	f0 1f 00 03 	mcall	80005b08 <usart_putchar+0x28>
80005b00:	cf 71       	brne	80005aee <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b06:	00 00       	add	r0,r0
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	5a ca       	cp.w	r10,-20

80005b0c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b0c:	78 58       	ld.w	r8,r12[0x14]
80005b0e:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b12:	c0 30       	breq	80005b18 <usart_read_char+0xc>
80005b14:	30 4c       	mov	r12,4
80005b16:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b18:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b1a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b1e:	c0 31       	brne	80005b24 <usart_read_char+0x18>
80005b20:	30 3c       	mov	r12,3
80005b22:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b24:	78 68       	ld.w	r8,r12[0x18]
80005b26:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b2a:	97 08       	st.w	r11[0x0],r8
80005b2c:	5e fd       	retal	0
80005b2e:	d7 03       	nop

80005b30 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b30:	eb cd 40 c0 	pushm	r6-r7,lr
80005b34:	20 1d       	sub	sp,4
80005b36:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b38:	1a 97       	mov	r7,sp
80005b3a:	1a 9b       	mov	r11,sp
80005b3c:	0c 9c       	mov	r12,r6
80005b3e:	f0 1f 00 07 	mcall	80005b58 <usart_getchar+0x28>
80005b42:	58 3c       	cp.w	r12,3
80005b44:	cf b0       	breq	80005b3a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b46:	58 4c       	cp.w	r12,4
80005b48:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b4c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b50:	2f fd       	sub	sp,-4
80005b52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b56:	00 00       	add	r0,r0
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	5b 0c       	cp.w	r12,-16

80005b5c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b5c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b60:	18 96       	mov	r6,r12
80005b62:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b64:	17 8b       	ld.ub	r11,r11[0x0]
80005b66:	58 0b       	cp.w	r11,0
80005b68:	c0 80       	breq	80005b78 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b6a:	2f f7       	sub	r7,-1
80005b6c:	0c 9c       	mov	r12,r6
80005b6e:	f0 1f 00 04 	mcall	80005b7c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b72:	0f 8b       	ld.ub	r11,r7[0x0]
80005b74:	58 0b       	cp.w	r11,0
80005b76:	cf a1       	brne	80005b6a <usart_write_line+0xe>
80005b78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b7c:	80 00       	ld.sh	r0,r0[0x0]
80005b7e:	5a e0       	cp.w	r0,-18

80005b80 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b80:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b84:	e6 18 00 01 	andh	r8,0x1,COH
80005b88:	c0 71       	brne	80005b96 <usart_reset+0x16>
80005b8a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b8c:	3f f8       	mov	r8,-1
80005b8e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b90:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005b92:	d5 03       	csrf	0x10
80005b94:	c0 48       	rjmp	80005b9c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005b96:	3f f8       	mov	r8,-1
80005b98:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b9a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005b9c:	30 08       	mov	r8,0
80005b9e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005ba0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005ba2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005ba4:	ea 68 61 0c 	mov	r8,680204
80005ba8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005baa:	5e fc       	retal	r12

80005bac <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005bac:	eb cd 40 e0 	pushm	r5-r7,lr
80005bb0:	18 96       	mov	r6,r12
80005bb2:	16 97       	mov	r7,r11
80005bb4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005bb6:	f0 1f 00 2f 	mcall	80005c70 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005bba:	58 07       	cp.w	r7,0
80005bbc:	c5 80       	breq	80005c6c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005bbe:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bc0:	30 49       	mov	r9,4
80005bc2:	f2 08 18 00 	cp.b	r8,r9
80005bc6:	e0 88 00 53 	brls	80005c6c <usart_init_rs232+0xc0>
80005bca:	30 99       	mov	r9,9
80005bcc:	f2 08 18 00 	cp.b	r8,r9
80005bd0:	e0 8b 00 4e 	brhi	80005c6c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005bd4:	0f d9       	ld.ub	r9,r7[0x5]
80005bd6:	30 78       	mov	r8,7
80005bd8:	f0 09 18 00 	cp.b	r9,r8
80005bdc:	e0 8b 00 48 	brhi	80005c6c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005be0:	8e 39       	ld.sh	r9,r7[0x6]
80005be2:	e0 68 01 01 	mov	r8,257
80005be6:	f0 09 19 00 	cp.h	r9,r8
80005bea:	e0 8b 00 41 	brhi	80005c6c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005bee:	ef 39 00 08 	ld.ub	r9,r7[8]
80005bf2:	30 38       	mov	r8,3
80005bf4:	f0 09 18 00 	cp.b	r9,r8
80005bf8:	e0 8b 00 3a 	brhi	80005c6c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005bfc:	0a 9a       	mov	r10,r5
80005bfe:	6e 0b       	ld.w	r11,r7[0x0]
80005c00:	0c 9c       	mov	r12,r6
80005c02:	f0 1f 00 1d 	mcall	80005c74 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c06:	58 1c       	cp.w	r12,1
80005c08:	c3 20       	breq	80005c6c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c0a:	0f c8       	ld.ub	r8,r7[0x4]
80005c0c:	30 99       	mov	r9,9
80005c0e:	f2 08 18 00 	cp.b	r8,r9
80005c12:	c0 51       	brne	80005c1c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c14:	6c 18       	ld.w	r8,r6[0x4]
80005c16:	b1 b8       	sbr	r8,0x11
80005c18:	8d 18       	st.w	r6[0x4],r8
80005c1a:	c0 68       	rjmp	80005c26 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c1c:	6c 19       	ld.w	r9,r6[0x4]
80005c1e:	20 58       	sub	r8,5
80005c20:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c24:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c26:	6c 19       	ld.w	r9,r6[0x4]
80005c28:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c2c:	0f d8       	ld.ub	r8,r7[0x5]
80005c2e:	a9 78       	lsl	r8,0x9
80005c30:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c34:	12 48       	or	r8,r9
80005c36:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c38:	8e 38       	ld.sh	r8,r7[0x6]
80005c3a:	30 29       	mov	r9,2
80005c3c:	f2 08 19 00 	cp.h	r8,r9
80005c40:	e0 88 00 09 	brls	80005c52 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c44:	6c 18       	ld.w	r8,r6[0x4]
80005c46:	ad b8       	sbr	r8,0xd
80005c48:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c4a:	8e b8       	ld.uh	r8,r7[0x6]
80005c4c:	20 28       	sub	r8,2
80005c4e:	8d a8       	st.w	r6[0x28],r8
80005c50:	c0 68       	rjmp	80005c5c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c52:	6c 19       	ld.w	r9,r6[0x4]
80005c54:	5c 78       	castu.h	r8
80005c56:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c5a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c5c:	6c 18       	ld.w	r8,r6[0x4]
80005c5e:	e0 18 ff f0 	andl	r8,0xfff0
80005c62:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c64:	35 08       	mov	r8,80
80005c66:	8d 08       	st.w	r6[0x0],r8
80005c68:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c6c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	5b 80       	cp.w	r0,-8
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	5a 70       	cp.w	r0,-25

80005c78 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c78:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c7c:	fe c0 8e 7c 	sub	r0,pc,-29060

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c80:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c84:	d5 53       	csrf	0x15
  cp      r0, r1
80005c86:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c88:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c8c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c8e:	c0 62       	brcc	80005c9a <idata_load_loop_end>
  cp      r0, r1
80005c90:	48 92       	lddpc	r2,80005cb4 <udata_clear_loop_end+0x4>

80005c92 <idata_load_loop>:
  brlo    idata_load_loop
80005c92:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005c94:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005c96:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005c98:	cf d3       	brcs	80005c92 <idata_load_loop>

80005c9a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005c9a:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80005c9e:	e0 61 53 d0 	mov	r1,21456
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005ca2:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005ca4:	c0 62       	brcc	80005cb0 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005ca6:	30 02       	mov	r2,0
80005ca8:	30 03       	mov	r3,0

80005caa <udata_clear_loop>:
80005caa:	a1 22       	st.d	r0++,r2
80005cac:	02 30       	cp.w	r0,r1
80005cae:	cf e3       	brcs	80005caa <udata_clear_loop>

80005cb0 <udata_clear_loop_end>:
80005cb0:	fe cf e9 28 	sub	pc,pc,-5848
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	e2 80 f8 c8 	breq	80064e46 <_data_lma+0x56bc6>

80005cb8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005cb8:	f8 c8 ff f8 	sub	r8,r12,-8
80005cbc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005cbe:	3f f9       	mov	r9,-1
80005cc0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005cc2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005cc4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005cc6:	30 08       	mov	r8,0
80005cc8:	99 08       	st.w	r12[0x0],r8
}
80005cca:	5e fc       	retal	r12

80005ccc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005ccc:	30 08       	mov	r8,0
80005cce:	99 48       	st.w	r12[0x10],r8
}
80005cd0:	5e fc       	retal	r12

80005cd2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005cd2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005cd4:	70 19       	ld.w	r9,r8[0x4]
80005cd6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005cd8:	78 19       	ld.w	r9,r12[0x4]
80005cda:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005cdc:	70 19       	ld.w	r9,r8[0x4]
80005cde:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005ce0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005ce2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ce4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ce6:	78 08       	ld.w	r8,r12[0x0]
80005ce8:	2f f8       	sub	r8,-1
80005cea:	99 08       	st.w	r12[0x0],r8
}
80005cec:	5e fc       	retal	r12

80005cee <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005cee:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005cf0:	5b fa       	cp.w	r10,-1
80005cf2:	c0 31       	brne	80005cf8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005cf4:	78 48       	ld.w	r8,r12[0x10]
80005cf6:	c0 c8       	rjmp	80005d0e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005cf8:	f8 c8 ff f8 	sub	r8,r12,-8
80005cfc:	70 19       	ld.w	r9,r8[0x4]
80005cfe:	72 09       	ld.w	r9,r9[0x0]
80005d00:	12 3a       	cp.w	r10,r9
80005d02:	c0 63       	brcs	80005d0e <vListInsert+0x20>
80005d04:	70 18       	ld.w	r8,r8[0x4]
80005d06:	70 19       	ld.w	r9,r8[0x4]
80005d08:	72 09       	ld.w	r9,r9[0x0]
80005d0a:	12 3a       	cp.w	r10,r9
80005d0c:	cf c2       	brcc	80005d04 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d0e:	70 19       	ld.w	r9,r8[0x4]
80005d10:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d12:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d14:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d16:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d18:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d1a:	78 08       	ld.w	r8,r12[0x0]
80005d1c:	2f f8       	sub	r8,-1
80005d1e:	99 08       	st.w	r12[0x0],r8
}
80005d20:	5e fc       	retal	r12

80005d22 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d22:	78 18       	ld.w	r8,r12[0x4]
80005d24:	78 29       	ld.w	r9,r12[0x8]
80005d26:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d28:	78 28       	ld.w	r8,r12[0x8]
80005d2a:	78 19       	ld.w	r9,r12[0x4]
80005d2c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d2e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d30:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d32:	18 39       	cp.w	r9,r12
80005d34:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d38:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d3c:	30 09       	mov	r9,0
80005d3e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d40:	70 09       	ld.w	r9,r8[0x0]
80005d42:	20 19       	sub	r9,1
80005d44:	91 09       	st.w	r8[0x0],r9
}
80005d46:	5e fc       	retal	r12

80005d48 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d48:	e0 68 08 08 	mov	r8,2056
80005d4c:	ea 18 08 08 	orh	r8,0x808
80005d50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d52:	e0 68 09 09 	mov	r8,2313
80005d56:	ea 18 09 09 	orh	r8,0x909
80005d5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d5c:	e0 68 0a 0a 	mov	r8,2570
80005d60:	ea 18 0a 0a 	orh	r8,0xa0a
80005d64:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d66:	e0 68 0b 0b 	mov	r8,2827
80005d6a:	ea 18 0b 0b 	orh	r8,0xb0b
80005d6e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d70:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d72:	e0 68 be ef 	mov	r8,48879
80005d76:	ea 18 de ad 	orh	r8,0xdead
80005d7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d7c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d7e:	fc 18 00 40 	movh	r8,0x40
80005d82:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d84:	e0 68 00 ff 	mov	r8,255
80005d88:	ea 18 ff 00 	orh	r8,0xff00
80005d8c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d8e:	e0 68 01 01 	mov	r8,257
80005d92:	ea 18 01 01 	orh	r8,0x101
80005d96:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d98:	e0 68 02 02 	mov	r8,514
80005d9c:	ea 18 02 02 	orh	r8,0x202
80005da0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005da2:	e0 68 03 03 	mov	r8,771
80005da6:	ea 18 03 03 	orh	r8,0x303
80005daa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005dac:	e0 68 04 04 	mov	r8,1028
80005db0:	ea 18 04 04 	orh	r8,0x404
80005db4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005db6:	e0 68 05 05 	mov	r8,1285
80005dba:	ea 18 05 05 	orh	r8,0x505
80005dbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005dc0:	e0 68 06 06 	mov	r8,1542
80005dc4:	ea 18 06 06 	orh	r8,0x606
80005dc8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005dca:	e0 68 07 07 	mov	r8,1799
80005dce:	ea 18 07 07 	orh	r8,0x707
80005dd2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005dd4:	30 08       	mov	r8,0
80005dd6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005dd8:	5e fc       	retal	r12
80005dda:	d7 03       	nop

80005ddc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005ddc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005dde:	48 38       	lddpc	r8,80005de8 <vPortEnterCritical+0xc>
80005de0:	70 09       	ld.w	r9,r8[0x0]
80005de2:	2f f9       	sub	r9,-1
80005de4:	91 09       	st.w	r8[0x0],r9
}
80005de6:	5e fc       	retal	r12
80005de8:	00 00       	add	r0,r0
80005dea:	05 38       	ld.ub	r8,r2++

80005dec <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005dec:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005dee:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005df0:	30 0a       	mov	r10,0
80005df2:	14 9b       	mov	r11,r10
80005df4:	49 2c       	lddpc	r12,80005e3c <xPortStartScheduler+0x50>
80005df6:	f0 1f 00 13 	mcall	80005e40 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005dfa:	e0 68 5d c0 	mov	r8,24000
80005dfe:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e02:	30 08       	mov	r8,0
80005e04:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e08:	e0 68 0c f0 	mov	r8,3312
80005e0c:	ea 18 00 00 	orh	r8,0x0
80005e10:	70 00       	ld.w	r0,r8[0x0]
80005e12:	60 0d       	ld.w	sp,r0[0x0]
80005e14:	1b 00       	ld.w	r0,sp++
80005e16:	e0 68 05 38 	mov	r8,1336
80005e1a:	ea 18 00 00 	orh	r8,0x0
80005e1e:	91 00       	st.w	r8[0x0],r0
80005e20:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e24:	2f ed       	sub	sp,-8
80005e26:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e2a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e2e:	e3 b0 00 00 	mtsr	0x0,r0
80005e32:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e36:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e3a:	d8 0a       	popm	pc,r12=0
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	5f 08       	sreq	r8
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	54 3c       	stdsp	sp[0x10c],r12

80005e44 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e44:	20 6d       	sub	sp,24
80005e46:	eb cd 00 ff 	pushm	r0-r7
80005e4a:	fa c7 ff c0 	sub	r7,sp,-64
80005e4e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e52:	ef 40 ff e0 	st.w	r7[-32],r0
80005e56:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e5a:	ef 40 ff e4 	st.w	r7[-28],r0
80005e5e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e62:	e0 68 05 38 	mov	r8,1336
80005e66:	ea 18 00 00 	orh	r8,0x0
80005e6a:	70 00       	ld.w	r0,r8[0x0]
80005e6c:	1a d0       	st.w	--sp,r0
80005e6e:	f0 1f 00 1a 	mcall	80005ed4 <LABEL_RET_SCALL_263+0x14>
80005e72:	e0 68 0c f0 	mov	r8,3312
80005e76:	ea 18 00 00 	orh	r8,0x0
80005e7a:	70 00       	ld.w	r0,r8[0x0]
80005e7c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e7e:	f0 1f 00 17 	mcall	80005ed8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e82:	e0 68 0c f0 	mov	r8,3312
80005e86:	ea 18 00 00 	orh	r8,0x0
80005e8a:	70 00       	ld.w	r0,r8[0x0]
80005e8c:	60 0d       	ld.w	sp,r0[0x0]
80005e8e:	1b 00       	ld.w	r0,sp++
80005e90:	e0 68 05 38 	mov	r8,1336
80005e94:	ea 18 00 00 	orh	r8,0x0
80005e98:	91 00       	st.w	r8[0x0],r0
80005e9a:	fa c7 ff d8 	sub	r7,sp,-40
80005e9e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005ea2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005ea6:	e0 61 05 38 	mov	r1,1336
80005eaa:	ea 11 00 00 	orh	r1,0x0
80005eae:	62 02       	ld.w	r2,r1[0x0]
80005eb0:	58 02       	cp.w	r2,0
80005eb2:	c0 70       	breq	80005ec0 <LABEL_RET_SCALL_263>
80005eb4:	e4 c2 00 01 	sub	r2,r2,1
80005eb8:	83 02       	st.w	r1[0x0],r2
80005eba:	58 02       	cp.w	r2,0
80005ebc:	c0 21       	brne	80005ec0 <LABEL_RET_SCALL_263>
80005ebe:	b1 c0       	cbr	r0,0x10

80005ec0 <LABEL_RET_SCALL_263>:
80005ec0:	ef 40 ff f8 	st.w	r7[-8],r0
80005ec4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005ec8:	ef 40 ff fc 	st.w	r7[-4],r0
80005ecc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ed0:	2f ad       	sub	sp,-24
80005ed2:	d6 13       	rets
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	5d dc       	*unknown*
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	65 78       	ld.w	r8,r2[0x5c]

80005edc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005edc:	e1 b8 00 43 	mfsr	r8,0x10c
80005ee0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005ee4:	5e fc       	retal	r12
80005ee6:	d7 03       	nop

80005ee8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005ee8:	48 78       	lddpc	r8,80005f04 <vPortExitCritical+0x1c>
80005eea:	70 08       	ld.w	r8,r8[0x0]
80005eec:	58 08       	cp.w	r8,0
80005eee:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005ef0:	48 58       	lddpc	r8,80005f04 <vPortExitCritical+0x1c>
80005ef2:	70 09       	ld.w	r9,r8[0x0]
80005ef4:	20 19       	sub	r9,1
80005ef6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005ef8:	70 08       	ld.w	r8,r8[0x0]
80005efa:	58 08       	cp.w	r8,0
80005efc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005efe:	d5 03       	csrf	0x10
80005f00:	5e fc       	retal	r12
80005f02:	00 00       	add	r0,r0
80005f04:	00 00       	add	r0,r0
80005f06:	05 38       	ld.ub	r8,r2++

80005f08 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f08:	eb cd 00 ff 	pushm	r0-r7
80005f0c:	e0 68 05 38 	mov	r8,1336
80005f10:	ea 18 00 00 	orh	r8,0x0
80005f14:	70 00       	ld.w	r0,r8[0x0]
80005f16:	1a d0       	st.w	--sp,r0
80005f18:	7a 90       	ld.w	r0,sp[0x24]
80005f1a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f1e:	58 10       	cp.w	r0,1
80005f20:	e0 8b 00 08 	brhi	80005f30 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f24:	e0 68 0c f0 	mov	r8,3312
80005f28:	ea 18 00 00 	orh	r8,0x0
80005f2c:	70 00       	ld.w	r0,r8[0x0]
80005f2e:	81 0d       	st.w	r0[0x0],sp

80005f30 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f30:	f0 1f 00 12 	mcall	80005f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f34:	f0 1f 00 12 	mcall	80005f7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f38:	f0 1f 00 12 	mcall	80005f80 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f3c:	f0 1f 00 12 	mcall	80005f84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f40:	7a 90       	ld.w	r0,sp[0x24]
80005f42:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f46:	58 10       	cp.w	r0,1
80005f48:	e0 8b 00 0e 	brhi	80005f64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f4c:	f0 1f 00 0c 	mcall	80005f7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f50:	f0 1f 00 0e 	mcall	80005f88 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f54:	f0 1f 00 0c 	mcall	80005f84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f58:	e0 68 0c f0 	mov	r8,3312
80005f5c:	ea 18 00 00 	orh	r8,0x0
80005f60:	70 00       	ld.w	r0,r8[0x0]
80005f62:	60 0d       	ld.w	sp,r0[0x0]

80005f64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f64:	1b 00       	ld.w	r0,sp++
80005f66:	e0 68 05 38 	mov	r8,1336
80005f6a:	ea 18 00 00 	orh	r8,0x0
80005f6e:	91 00       	st.w	r8[0x0],r0
80005f70:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f74:	d6 03       	rete
80005f76:	00 00       	add	r0,r0
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5e dc       	retvc	r12
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	5d dc       	*unknown*
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	67 7c       	ld.w	r12,r3[0x5c]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	5e e8       	retqs	r8
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	65 78       	ld.w	r8,r2[0x5c]

80005f8c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f8c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f8e:	f0 1f 00 02 	mcall	80005f94 <__malloc_lock+0x8>
}
80005f92:	d8 02       	popm	pc
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	65 68       	ld.w	r8,r2[0x58]

80005f98 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f98:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f9a:	f0 1f 00 02 	mcall	80005fa0 <__malloc_unlock+0x8>
}
80005f9e:	d8 02       	popm	pc
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	69 24       	ld.w	r4,r4[0x48]

80005fa4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005fa4:	d4 21       	pushm	r4-r7,lr
80005fa6:	16 95       	mov	r5,r11
80005fa8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005faa:	58 0c       	cp.w	r12,0
80005fac:	c0 30       	breq	80005fb2 <_read+0xe>
80005fae:	3f f7       	mov	r7,-1
80005fb0:	c1 48       	rjmp	80005fd8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005fb2:	58 0a       	cp.w	r10,0
80005fb4:	e0 89 00 04 	brgt	80005fbc <_read+0x18>
80005fb8:	30 07       	mov	r7,0
80005fba:	c0 f8       	rjmp	80005fd8 <_read+0x34>
80005fbc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005fbe:	48 84       	lddpc	r4,80005fdc <_read+0x38>
80005fc0:	68 0c       	ld.w	r12,r4[0x0]
80005fc2:	f0 1f 00 08 	mcall	80005fe0 <_read+0x3c>
    if (c < 0)
80005fc6:	c0 95       	brlt	80005fd8 <_read+0x34>
      break;

    *ptr++ = c;
80005fc8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005fcc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005fce:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005fd2:	58 08       	cp.w	r8,0
80005fd4:	fe 99 ff f6 	brgt	80005fc0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005fd8:	0e 9c       	mov	r12,r7
80005fda:	d8 22       	popm	r4-r7,pc
80005fdc:	00 00       	add	r0,r0
80005fde:	53 c0       	stdsp	sp[0xf0],r0
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	5b 30       	cp.w	r0,-13

80005fe4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005fe4:	d4 21       	pushm	r4-r7,lr
80005fe6:	16 95       	mov	r5,r11
80005fe8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005fea:	20 1c       	sub	r12,1
80005fec:	58 2c       	cp.w	r12,2
80005fee:	e0 8b 00 12 	brhi	80006012 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ff2:	58 0a       	cp.w	r10,0
80005ff4:	c0 31       	brne	80005ffa <_write+0x16>
80005ff6:	30 07       	mov	r7,0
80005ff8:	c0 e8       	rjmp	80006014 <_write+0x30>
80005ffa:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005ffc:	48 74       	lddpc	r4,80006018 <_write+0x34>
80005ffe:	68 0c       	ld.w	r12,r4[0x0]
80006000:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006004:	f0 1f 00 06 	mcall	8000601c <_write+0x38>
80006008:	c0 55       	brlt	80006012 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000600a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000600c:	0e 36       	cp.w	r6,r7
8000600e:	cf 81       	brne	80005ffe <_write+0x1a>
80006010:	c0 28       	rjmp	80006014 <_write+0x30>
80006012:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006014:	0e 9c       	mov	r12,r7
80006016:	d8 22       	popm	r4-r7,pc
80006018:	00 00       	add	r0,r0
8000601a:	53 c0       	stdsp	sp[0xf0],r0
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	5a e0       	cp.w	r0,-18

80006020 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006020:	eb cd 40 80 	pushm	r7,lr
80006024:	18 97       	mov	r7,r12
	if( pv )
80006026:	58 0c       	cp.w	r12,0
80006028:	c0 80       	breq	80006038 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000602a:	f0 1f 00 05 	mcall	8000603c <vPortFree+0x1c>
		{
			free( pv );
8000602e:	0e 9c       	mov	r12,r7
80006030:	f0 1f 00 04 	mcall	80006040 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006034:	f0 1f 00 04 	mcall	80006044 <vPortFree+0x24>
80006038:	e3 cd 80 80 	ldm	sp++,r7,pc
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	65 68       	ld.w	r8,r2[0x58]
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	74 00       	ld.w	r0,r10[0x0]
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	69 24       	ld.w	r4,r4[0x48]

80006048 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006048:	eb cd 40 80 	pushm	r7,lr
8000604c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000604e:	f0 1f 00 06 	mcall	80006064 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006052:	0e 9c       	mov	r12,r7
80006054:	f0 1f 00 05 	mcall	80006068 <pvPortMalloc+0x20>
80006058:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000605a:	f0 1f 00 05 	mcall	8000606c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000605e:	0e 9c       	mov	r12,r7
80006060:	e3 cd 80 80 	ldm	sp++,r7,pc
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	65 68       	ld.w	r8,r2[0x58]
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	74 10       	ld.w	r0,r10[0x4]
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	69 24       	ld.w	r4,r4[0x48]

80006070 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006070:	d4 01       	pushm	lr
80006072:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006074:	78 09       	ld.w	r9,r12[0x0]
80006076:	58 09       	cp.w	r9,0
80006078:	c1 10       	breq	8000609a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000607a:	78 3a       	ld.w	r10,r12[0xc]
8000607c:	79 09       	ld.w	r9,r12[0x40]
8000607e:	f4 09 00 09 	add	r9,r10,r9
80006082:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006084:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006086:	14 39       	cp.w	r9,r10
80006088:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000608c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006090:	79 0a       	ld.w	r10,r12[0x40]
80006092:	78 3b       	ld.w	r11,r12[0xc]
80006094:	10 9c       	mov	r12,r8
80006096:	f0 1f 00 02 	mcall	8000609c <prvCopyDataFromQueue+0x2c>
8000609a:	d8 02       	popm	pc
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	78 58       	ld.w	r8,r12[0x14]

800060a0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800060a0:	eb cd 40 c0 	pushm	r6-r7,lr
800060a4:	18 97       	mov	r7,r12
800060a6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060a8:	78 e8       	ld.w	r8,r12[0x38]
800060aa:	58 08       	cp.w	r8,0
800060ac:	c0 31       	brne	800060b2 <xQueueReceiveFromISR+0x12>
800060ae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060b2:	f0 1f 00 0e 	mcall	800060e8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060b6:	6e e8       	ld.w	r8,r7[0x38]
800060b8:	20 18       	sub	r8,1
800060ba:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800060bc:	6f 18       	ld.w	r8,r7[0x44]
800060be:	5b f8       	cp.w	r8,-1
800060c0:	c0 d1       	brne	800060da <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060c2:	6e 48       	ld.w	r8,r7[0x10]
800060c4:	58 08       	cp.w	r8,0
800060c6:	c0 f0       	breq	800060e4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060c8:	ee cc ff f0 	sub	r12,r7,-16
800060cc:	f0 1f 00 08 	mcall	800060ec <xQueueReceiveFromISR+0x4c>
800060d0:	c0 a0       	breq	800060e4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800060d2:	30 1c       	mov	r12,1
800060d4:	8d 0c       	st.w	r6[0x0],r12
800060d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800060da:	2f f8       	sub	r8,-1
800060dc:	ef 48 00 44 	st.w	r7[68],r8
800060e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	60 70       	ld.w	r0,r0[0x1c]
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	67 00       	ld.w	r0,r3[0x40]

800060f0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800060f0:	eb cd 40 c0 	pushm	r6-r7,lr
800060f4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800060f6:	f0 1f 00 23 	mcall	80006180 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800060fa:	6f 28       	ld.w	r8,r7[0x48]
800060fc:	58 08       	cp.w	r8,0
800060fe:	e0 8a 00 18 	brle	8000612e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006102:	6e 98       	ld.w	r8,r7[0x24]
80006104:	58 08       	cp.w	r8,0
80006106:	c1 40       	breq	8000612e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006108:	ee c6 ff dc 	sub	r6,r7,-36
8000610c:	c0 48       	rjmp	80006114 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000610e:	6e 98       	ld.w	r8,r7[0x24]
80006110:	58 08       	cp.w	r8,0
80006112:	c0 e0       	breq	8000612e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006114:	0c 9c       	mov	r12,r6
80006116:	f0 1f 00 1c 	mcall	80006184 <prvUnlockQueue+0x94>
8000611a:	c0 30       	breq	80006120 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000611c:	f0 1f 00 1b 	mcall	80006188 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006120:	6f 28       	ld.w	r8,r7[0x48]
80006122:	20 18       	sub	r8,1
80006124:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006128:	58 08       	cp.w	r8,0
8000612a:	fe 99 ff f2 	brgt	8000610e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000612e:	3f f8       	mov	r8,-1
80006130:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006134:	f0 1f 00 16 	mcall	8000618c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006138:	f0 1f 00 12 	mcall	80006180 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000613c:	6f 18       	ld.w	r8,r7[0x44]
8000613e:	58 08       	cp.w	r8,0
80006140:	e0 8a 00 18 	brle	80006170 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006144:	6e 48       	ld.w	r8,r7[0x10]
80006146:	58 08       	cp.w	r8,0
80006148:	c1 40       	breq	80006170 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000614a:	ee c6 ff f0 	sub	r6,r7,-16
8000614e:	c0 48       	rjmp	80006156 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006150:	6e 48       	ld.w	r8,r7[0x10]
80006152:	58 08       	cp.w	r8,0
80006154:	c0 e0       	breq	80006170 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006156:	0c 9c       	mov	r12,r6
80006158:	f0 1f 00 0b 	mcall	80006184 <prvUnlockQueue+0x94>
8000615c:	c0 30       	breq	80006162 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000615e:	f0 1f 00 0b 	mcall	80006188 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006162:	6f 18       	ld.w	r8,r7[0x44]
80006164:	20 18       	sub	r8,1
80006166:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000616a:	58 08       	cp.w	r8,0
8000616c:	fe 99 ff f2 	brgt	80006150 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006170:	3f f8       	mov	r8,-1
80006172:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006176:	f0 1f 00 06 	mcall	8000618c <prvUnlockQueue+0x9c>
}
8000617a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000617e:	00 00       	add	r0,r0
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	5d dc       	*unknown*
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	67 00       	ld.w	r0,r3[0x40]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	66 0c       	ld.w	r12,r3[0x0]
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	5e e8       	retqs	r8

80006190 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006190:	d4 31       	pushm	r0-r7,lr
80006192:	20 5d       	sub	sp,20
80006194:	18 97       	mov	r7,r12
80006196:	50 0b       	stdsp	sp[0x0],r11
80006198:	50 2a       	stdsp	sp[0x8],r10
8000619a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000619c:	f8 c2 ff dc 	sub	r2,r12,-36
800061a0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061a2:	fa c4 ff f4 	sub	r4,sp,-12
800061a6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061a8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061aa:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800061ae:	f0 1f 00 3e 	mcall	800062a4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061b2:	6e e8       	ld.w	r8,r7[0x38]
800061b4:	58 08       	cp.w	r8,0
800061b6:	c2 a0       	breq	8000620a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061b8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061ba:	40 0b       	lddsp	r11,sp[0x0]
800061bc:	0e 9c       	mov	r12,r7
800061be:	f0 1f 00 3b 	mcall	800062a8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800061c2:	40 18       	lddsp	r8,sp[0x4]
800061c4:	58 08       	cp.w	r8,0
800061c6:	c1 51       	brne	800061f0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800061c8:	6e e8       	ld.w	r8,r7[0x38]
800061ca:	20 18       	sub	r8,1
800061cc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061ce:	6e 08       	ld.w	r8,r7[0x0]
800061d0:	58 08       	cp.w	r8,0
800061d2:	c0 41       	brne	800061da <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800061d4:	f0 1f 00 36 	mcall	800062ac <xQueueGenericReceive+0x11c>
800061d8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061da:	6e 48       	ld.w	r8,r7[0x10]
800061dc:	58 08       	cp.w	r8,0
800061de:	c1 20       	breq	80006202 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800061e0:	ee cc ff f0 	sub	r12,r7,-16
800061e4:	f0 1f 00 33 	mcall	800062b0 <xQueueGenericReceive+0x120>
800061e8:	58 1c       	cp.w	r12,1
800061ea:	c0 c1       	brne	80006202 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800061ec:	d7 33       	scall
800061ee:	c0 a8       	rjmp	80006202 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800061f0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061f2:	6e 98       	ld.w	r8,r7[0x24]
800061f4:	58 08       	cp.w	r8,0
800061f6:	c0 60       	breq	80006202 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061f8:	04 9c       	mov	r12,r2
800061fa:	f0 1f 00 2e 	mcall	800062b0 <xQueueGenericReceive+0x120>
800061fe:	c0 20       	breq	80006202 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006200:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006202:	f0 1f 00 2d 	mcall	800062b4 <xQueueGenericReceive+0x124>
80006206:	30 1c       	mov	r12,1
				return pdPASS;
80006208:	c4 c8       	rjmp	800062a0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000620a:	40 28       	lddsp	r8,sp[0x8]
8000620c:	58 08       	cp.w	r8,0
8000620e:	c0 51       	brne	80006218 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006210:	f0 1f 00 29 	mcall	800062b4 <xQueueGenericReceive+0x124>
80006214:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006216:	c4 58       	rjmp	800062a0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006218:	58 05       	cp.w	r5,0
8000621a:	c0 51       	brne	80006224 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000621c:	08 9c       	mov	r12,r4
8000621e:	f0 1f 00 27 	mcall	800062b8 <xQueueGenericReceive+0x128>
80006222:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006224:	f0 1f 00 24 	mcall	800062b4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006228:	f0 1f 00 25 	mcall	800062bc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000622c:	f0 1f 00 1e 	mcall	800062a4 <xQueueGenericReceive+0x114>
80006230:	6f 18       	ld.w	r8,r7[0x44]
80006232:	5b f8       	cp.w	r8,-1
80006234:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006238:	6f 28       	ld.w	r8,r7[0x48]
8000623a:	5b f8       	cp.w	r8,-1
8000623c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006240:	f0 1f 00 1d 	mcall	800062b4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006244:	06 9b       	mov	r11,r3
80006246:	08 9c       	mov	r12,r4
80006248:	f0 1f 00 1e 	mcall	800062c0 <xQueueGenericReceive+0x130>
8000624c:	c2 41       	brne	80006294 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000624e:	f0 1f 00 16 	mcall	800062a4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006252:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006254:	f0 1f 00 18 	mcall	800062b4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006258:	58 06       	cp.w	r6,0
8000625a:	c1 71       	brne	80006288 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000625c:	6e 08       	ld.w	r8,r7[0x0]
8000625e:	58 08       	cp.w	r8,0
80006260:	c0 81       	brne	80006270 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006262:	f0 1f 00 11 	mcall	800062a4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006266:	6e 1c       	ld.w	r12,r7[0x4]
80006268:	f0 1f 00 17 	mcall	800062c4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000626c:	f0 1f 00 12 	mcall	800062b4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006270:	40 2b       	lddsp	r11,sp[0x8]
80006272:	04 9c       	mov	r12,r2
80006274:	f0 1f 00 15 	mcall	800062c8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006278:	0e 9c       	mov	r12,r7
8000627a:	f0 1f 00 15 	mcall	800062cc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000627e:	f0 1f 00 15 	mcall	800062d0 <xQueueGenericReceive+0x140>
80006282:	c9 61       	brne	800061ae <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006284:	d7 33       	scall
80006286:	c9 4b       	rjmp	800061ae <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006288:	0e 9c       	mov	r12,r7
8000628a:	f0 1f 00 11 	mcall	800062cc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000628e:	f0 1f 00 11 	mcall	800062d0 <xQueueGenericReceive+0x140>
80006292:	c8 eb       	rjmp	800061ae <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006294:	0e 9c       	mov	r12,r7
80006296:	f0 1f 00 0e 	mcall	800062cc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000629a:	f0 1f 00 0e 	mcall	800062d0 <xQueueGenericReceive+0x140>
8000629e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800062a0:	2f bd       	sub	sp,-20
800062a2:	d8 32       	popm	r0-r7,pc
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	5d dc       	*unknown*
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	60 70       	ld.w	r0,r0[0x1c]
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	66 18       	ld.w	r8,r3[0x4]
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	67 00       	ld.w	r0,r3[0x40]
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	5e e8       	retqs	r8
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	65 f4       	ld.w	r4,r2[0x7c]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	65 68       	ld.w	r8,r2[0x58]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	68 90       	ld.w	r0,r4[0x24]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	66 7c       	ld.w	r12,r3[0x1c]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	6b 30       	ld.w	r0,r5[0x4c]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	60 f0       	ld.w	r0,r0[0x3c]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	69 24       	ld.w	r4,r4[0x48]

800062d4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800062d4:	eb cd 40 80 	pushm	r7,lr
800062d8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800062da:	79 08       	ld.w	r8,r12[0x40]
800062dc:	58 08       	cp.w	r8,0
800062de:	c0 a1       	brne	800062f2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062e0:	78 08       	ld.w	r8,r12[0x0]
800062e2:	58 08       	cp.w	r8,0
800062e4:	c2 b1       	brne	8000633a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800062e6:	78 1c       	ld.w	r12,r12[0x4]
800062e8:	f0 1f 00 17 	mcall	80006344 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800062ec:	30 08       	mov	r8,0
800062ee:	8f 18       	st.w	r7[0x4],r8
800062f0:	c2 58       	rjmp	8000633a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800062f2:	58 0a       	cp.w	r10,0
800062f4:	c1 01       	brne	80006314 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800062f6:	10 9a       	mov	r10,r8
800062f8:	78 2c       	ld.w	r12,r12[0x8]
800062fa:	f0 1f 00 14 	mcall	80006348 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800062fe:	6e 29       	ld.w	r9,r7[0x8]
80006300:	6f 08       	ld.w	r8,r7[0x40]
80006302:	f2 08 00 08 	add	r8,r9,r8
80006306:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006308:	6e 19       	ld.w	r9,r7[0x4]
8000630a:	12 38       	cp.w	r8,r9
8000630c:	c1 73       	brcs	8000633a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000630e:	6e 08       	ld.w	r8,r7[0x0]
80006310:	8f 28       	st.w	r7[0x8],r8
80006312:	c1 48       	rjmp	8000633a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006314:	10 9a       	mov	r10,r8
80006316:	78 3c       	ld.w	r12,r12[0xc]
80006318:	f0 1f 00 0c 	mcall	80006348 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000631c:	6f 08       	ld.w	r8,r7[0x40]
8000631e:	6e 39       	ld.w	r9,r7[0xc]
80006320:	f2 08 01 08 	sub	r8,r9,r8
80006324:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006326:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006328:	12 38       	cp.w	r8,r9
8000632a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000632e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006332:	f3 d8 e3 19 	subcs	r9,r9,r8
80006336:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000633a:	6e e8       	ld.w	r8,r7[0x38]
8000633c:	2f f8       	sub	r8,-1
8000633e:	8f e8       	st.w	r7[0x38],r8
}
80006340:	e3 cd 80 80 	ldm	sp++,r7,pc
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	66 24       	ld.w	r4,r3[0x8]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	78 58       	ld.w	r8,r12[0x14]

8000634c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000634c:	eb cd 40 c0 	pushm	r6-r7,lr
80006350:	18 97       	mov	r7,r12
80006352:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006354:	78 ec       	ld.w	r12,r12[0x38]
80006356:	6e f8       	ld.w	r8,r7[0x3c]
80006358:	10 3c       	cp.w	r12,r8
8000635a:	c0 33       	brcs	80006360 <xQueueGenericSendFromISR+0x14>
8000635c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006360:	12 9a       	mov	r10,r9
80006362:	0e 9c       	mov	r12,r7
80006364:	f0 1f 00 0c 	mcall	80006394 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006368:	6f 28       	ld.w	r8,r7[0x48]
8000636a:	5b f8       	cp.w	r8,-1
8000636c:	c0 d1       	brne	80006386 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000636e:	6e 98       	ld.w	r8,r7[0x24]
80006370:	58 08       	cp.w	r8,0
80006372:	c0 f0       	breq	80006390 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006374:	ee cc ff dc 	sub	r12,r7,-36
80006378:	f0 1f 00 08 	mcall	80006398 <xQueueGenericSendFromISR+0x4c>
8000637c:	c0 a0       	breq	80006390 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000637e:	30 1c       	mov	r12,1
80006380:	8d 0c       	st.w	r6[0x0],r12
80006382:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006386:	2f f8       	sub	r8,-1
80006388:	ef 48 00 48 	st.w	r7[72],r8
8000638c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006390:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006394:	80 00       	ld.sh	r0,r0[0x0]
80006396:	62 d4       	ld.w	r4,r1[0x34]
80006398:	80 00       	ld.sh	r0,r0[0x0]
8000639a:	67 00       	ld.w	r0,r3[0x40]

8000639c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000639c:	d4 31       	pushm	r0-r7,lr
8000639e:	20 5d       	sub	sp,20
800063a0:	18 97       	mov	r7,r12
800063a2:	50 0b       	stdsp	sp[0x0],r11
800063a4:	50 2a       	stdsp	sp[0x8],r10
800063a6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063a8:	f8 c0 ff f0 	sub	r0,r12,-16
800063ac:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063ae:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063b2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063b4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063b8:	f0 1f 00 2f 	mcall	80006474 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063bc:	6e e9       	ld.w	r9,r7[0x38]
800063be:	6e f8       	ld.w	r8,r7[0x3c]
800063c0:	10 39       	cp.w	r9,r8
800063c2:	c1 42       	brcc	800063ea <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063c4:	40 1a       	lddsp	r10,sp[0x4]
800063c6:	40 0b       	lddsp	r11,sp[0x0]
800063c8:	0e 9c       	mov	r12,r7
800063ca:	f0 1f 00 2c 	mcall	80006478 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063ce:	6e 98       	ld.w	r8,r7[0x24]
800063d0:	58 08       	cp.w	r8,0
800063d2:	c0 80       	breq	800063e2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800063d4:	ee cc ff dc 	sub	r12,r7,-36
800063d8:	f0 1f 00 29 	mcall	8000647c <xQueueGenericSend+0xe0>
800063dc:	58 1c       	cp.w	r12,1
800063de:	c0 21       	brne	800063e2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800063e0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800063e2:	f0 1f 00 28 	mcall	80006480 <xQueueGenericSend+0xe4>
800063e6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800063e8:	c4 38       	rjmp	8000646e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063ea:	40 28       	lddsp	r8,sp[0x8]
800063ec:	58 08       	cp.w	r8,0
800063ee:	c0 51       	brne	800063f8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800063f0:	f0 1f 00 24 	mcall	80006480 <xQueueGenericSend+0xe4>
800063f4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800063f6:	c3 c8       	rjmp	8000646e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800063f8:	58 04       	cp.w	r4,0
800063fa:	c0 51       	brne	80006404 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063fc:	06 9c       	mov	r12,r3
800063fe:	f0 1f 00 22 	mcall	80006484 <xQueueGenericSend+0xe8>
80006402:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006404:	f0 1f 00 1f 	mcall	80006480 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006408:	f0 1f 00 20 	mcall	80006488 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000640c:	f0 1f 00 1a 	mcall	80006474 <xQueueGenericSend+0xd8>
80006410:	6f 18       	ld.w	r8,r7[0x44]
80006412:	5b f8       	cp.w	r8,-1
80006414:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006418:	6f 28       	ld.w	r8,r7[0x48]
8000641a:	5b f8       	cp.w	r8,-1
8000641c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006420:	f0 1f 00 18 	mcall	80006480 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006424:	04 9b       	mov	r11,r2
80006426:	06 9c       	mov	r12,r3
80006428:	f0 1f 00 19 	mcall	8000648c <xQueueGenericSend+0xf0>
8000642c:	c1 b1       	brne	80006462 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000642e:	f0 1f 00 12 	mcall	80006474 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006432:	6e e5       	ld.w	r5,r7[0x38]
80006434:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006436:	f0 1f 00 13 	mcall	80006480 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000643a:	0c 35       	cp.w	r5,r6
8000643c:	c0 d1       	brne	80006456 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000643e:	40 2b       	lddsp	r11,sp[0x8]
80006440:	00 9c       	mov	r12,r0
80006442:	f0 1f 00 14 	mcall	80006490 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006446:	0e 9c       	mov	r12,r7
80006448:	f0 1f 00 13 	mcall	80006494 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000644c:	f0 1f 00 13 	mcall	80006498 <xQueueGenericSend+0xfc>
80006450:	cb 41       	brne	800063b8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006452:	d7 33       	scall
80006454:	cb 2b       	rjmp	800063b8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006456:	0e 9c       	mov	r12,r7
80006458:	f0 1f 00 0f 	mcall	80006494 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000645c:	f0 1f 00 0f 	mcall	80006498 <xQueueGenericSend+0xfc>
80006460:	ca cb       	rjmp	800063b8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006462:	0e 9c       	mov	r12,r7
80006464:	f0 1f 00 0c 	mcall	80006494 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006468:	f0 1f 00 0c 	mcall	80006498 <xQueueGenericSend+0xfc>
8000646c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000646e:	2f bd       	sub	sp,-20
80006470:	d8 32       	popm	r0-r7,pc
80006472:	00 00       	add	r0,r0
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	5d dc       	*unknown*
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	62 d4       	ld.w	r4,r1[0x34]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	67 00       	ld.w	r0,r3[0x40]
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	5e e8       	retqs	r8
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	65 f4       	ld.w	r4,r2[0x7c]
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	65 68       	ld.w	r8,r2[0x58]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	68 90       	ld.w	r0,r4[0x24]
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	6b 30       	ld.w	r0,r5[0x4c]
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	60 f0       	ld.w	r0,r0[0x3c]
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	69 24       	ld.w	r4,r4[0x48]

8000649c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000649c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064a0:	34 cc       	mov	r12,76
800064a2:	f0 1f 00 12 	mcall	800064e8 <xQueueCreateMutex+0x4c>
800064a6:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800064a8:	c1 d0       	breq	800064e2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800064aa:	30 06       	mov	r6,0
800064ac:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800064ae:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064b0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064b2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064b4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064b6:	30 18       	mov	r8,1
800064b8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064ba:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800064be:	3f f8       	mov	r8,-1
800064c0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800064c4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064c8:	2f 0c       	sub	r12,-16
800064ca:	f0 1f 00 09 	mcall	800064ec <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064ce:	ee cc ff dc 	sub	r12,r7,-36
800064d2:	f0 1f 00 07 	mcall	800064ec <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800064d6:	0c 99       	mov	r9,r6
800064d8:	0c 9a       	mov	r10,r6
800064da:	0c 9b       	mov	r11,r6
800064dc:	0e 9c       	mov	r12,r7
800064de:	f0 1f 00 05 	mcall	800064f0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800064e2:	0e 9c       	mov	r12,r7
800064e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	60 48       	ld.w	r8,r0[0x10]
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	5c b8       	swap.b	r8
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	63 9c       	ld.w	r12,r1[0x64]

800064f4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800064f4:	d4 21       	pushm	r4-r7,lr
800064f6:	18 97       	mov	r7,r12
800064f8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800064fa:	58 0c       	cp.w	r12,0
800064fc:	c2 f0       	breq	8000655a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064fe:	34 cc       	mov	r12,76
80006500:	f0 1f 00 17 	mcall	8000655c <xQueueCreate+0x68>
80006504:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006506:	c2 a0       	breq	8000655a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006508:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000650c:	e8 cc ff ff 	sub	r12,r4,-1
80006510:	f0 1f 00 13 	mcall	8000655c <xQueueCreate+0x68>
80006514:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006516:	c1 e0       	breq	80006552 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006518:	f8 04 00 04 	add	r4,r12,r4
8000651c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000651e:	30 08       	mov	r8,0
80006520:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006522:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006524:	ee c8 00 01 	sub	r8,r7,1
80006528:	ad 38       	mul	r8,r6
8000652a:	10 0c       	add	r12,r8
8000652c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000652e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006530:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006534:	3f f8       	mov	r8,-1
80006536:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000653a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000653e:	ea cc ff f0 	sub	r12,r5,-16
80006542:	f0 1f 00 08 	mcall	80006560 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006546:	ea cc ff dc 	sub	r12,r5,-36
8000654a:	f0 1f 00 06 	mcall	80006560 <xQueueCreate+0x6c>
8000654e:	0a 9c       	mov	r12,r5
80006550:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006552:	0a 9c       	mov	r12,r5
80006554:	f0 1f 00 04 	mcall	80006564 <xQueueCreate+0x70>
80006558:	d8 2a       	popm	r4-r7,pc,r12=0
8000655a:	d8 2a       	popm	r4-r7,pc,r12=0
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	60 48       	ld.w	r8,r0[0x10]
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	5c b8       	swap.b	r8
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	60 20       	ld.w	r0,r0[0x8]

80006568 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006568:	48 38       	lddpc	r8,80006574 <vTaskSuspendAll+0xc>
8000656a:	70 09       	ld.w	r9,r8[0x0]
8000656c:	2f f9       	sub	r9,-1
8000656e:	91 09       	st.w	r8[0x0],r9
}
80006570:	5e fc       	retal	r12
80006572:	00 00       	add	r0,r0
80006574:	00 00       	add	r0,r0
80006576:	0d 20       	ld.uh	r0,r6++

80006578 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006578:	49 a8       	lddpc	r8,800065e0 <vTaskSwitchContext+0x68>
8000657a:	70 08       	ld.w	r8,r8[0x0]
8000657c:	58 08       	cp.w	r8,0
8000657e:	c0 b1       	brne	80006594 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006580:	49 98       	lddpc	r8,800065e4 <vTaskSwitchContext+0x6c>
80006582:	70 08       	ld.w	r8,r8[0x0]
80006584:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006588:	49 89       	lddpc	r9,800065e8 <vTaskSwitchContext+0x70>
8000658a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000658e:	58 08       	cp.w	r8,0
80006590:	c0 60       	breq	8000659c <vTaskSwitchContext+0x24>
80006592:	c1 18       	rjmp	800065b4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006594:	30 19       	mov	r9,1
80006596:	49 68       	lddpc	r8,800065ec <vTaskSwitchContext+0x74>
80006598:	91 09       	st.w	r8[0x0],r9
8000659a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000659c:	49 28       	lddpc	r8,800065e4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000659e:	49 3a       	lddpc	r10,800065e8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065a0:	70 09       	ld.w	r9,r8[0x0]
800065a2:	20 19       	sub	r9,1
800065a4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065a6:	70 09       	ld.w	r9,r8[0x0]
800065a8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065ac:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065b0:	58 09       	cp.w	r9,0
800065b2:	cf 70       	breq	800065a0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065b4:	48 c8       	lddpc	r8,800065e4 <vTaskSwitchContext+0x6c>
800065b6:	70 08       	ld.w	r8,r8[0x0]
800065b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065bc:	48 b9       	lddpc	r9,800065e8 <vTaskSwitchContext+0x70>
800065be:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065c2:	70 19       	ld.w	r9,r8[0x4]
800065c4:	72 19       	ld.w	r9,r9[0x4]
800065c6:	91 19       	st.w	r8[0x4],r9
800065c8:	f0 ca ff f8 	sub	r10,r8,-8
800065cc:	14 39       	cp.w	r9,r10
800065ce:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800065d2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800065d6:	70 18       	ld.w	r8,r8[0x4]
800065d8:	70 39       	ld.w	r9,r8[0xc]
800065da:	48 68       	lddpc	r8,800065f0 <vTaskSwitchContext+0x78>
800065dc:	91 09       	st.w	r8[0x0],r9
800065de:	5e fc       	retal	r12
800065e0:	00 00       	add	r0,r0
800065e2:	0d 20       	ld.uh	r0,r6++
800065e4:	00 00       	add	r0,r0
800065e6:	0d 58       	ld.sh	r8,--r6
800065e8:	00 00       	add	r0,r0
800065ea:	0c 3c       	cp.w	r12,r6
800065ec:	00 00       	add	r0,r0
800065ee:	0d 40       	ld.w	r0,--r6
800065f0:	00 00       	add	r0,r0
800065f2:	0c f0       	st.b	--r6,r0

800065f4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800065f4:	48 48       	lddpc	r8,80006604 <vTaskSetTimeOutState+0x10>
800065f6:	70 08       	ld.w	r8,r8[0x0]
800065f8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800065fa:	48 48       	lddpc	r8,80006608 <vTaskSetTimeOutState+0x14>
800065fc:	70 08       	ld.w	r8,r8[0x0]
800065fe:	99 18       	st.w	r12[0x4],r8
}
80006600:	5e fc       	retal	r12
80006602:	00 00       	add	r0,r0
80006604:	00 00       	add	r0,r0
80006606:	0c 34       	cp.w	r4,r6
80006608:	00 00       	add	r0,r0
8000660a:	0d 1c       	ld.sh	r12,r6++

8000660c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000660c:	30 19       	mov	r9,1
8000660e:	48 28       	lddpc	r8,80006614 <vTaskMissedYield+0x8>
80006610:	91 09       	st.w	r8[0x0],r9
}
80006612:	5e fc       	retal	r12
80006614:	00 00       	add	r0,r0
80006616:	0d 40       	ld.w	r0,--r6

80006618 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006618:	48 28       	lddpc	r8,80006620 <xTaskGetCurrentTaskHandle+0x8>
8000661a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000661c:	5e fc       	retal	r12
8000661e:	00 00       	add	r0,r0
80006620:	00 00       	add	r0,r0
80006622:	0c f0       	st.b	--r6,r0

80006624 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006624:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006628:	58 0c       	cp.w	r12,0
8000662a:	c1 f0       	breq	80006668 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000662c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000662e:	78 b9       	ld.w	r9,r12[0x2c]
80006630:	79 18       	ld.w	r8,r12[0x44]
80006632:	10 39       	cp.w	r9,r8
80006634:	c1 a0       	breq	80006668 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006636:	f8 c6 ff fc 	sub	r6,r12,-4
8000663a:	0c 9c       	mov	r12,r6
8000663c:	f0 1f 00 0c 	mcall	8000666c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006640:	6f 1c       	ld.w	r12,r7[0x44]
80006642:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006644:	f8 08 11 08 	rsub	r8,r12,8
80006648:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000664a:	48 a8       	lddpc	r8,80006670 <vTaskPriorityDisinherit+0x4c>
8000664c:	70 08       	ld.w	r8,r8[0x0]
8000664e:	10 3c       	cp.w	r12,r8
80006650:	e0 88 00 04 	brls	80006658 <vTaskPriorityDisinherit+0x34>
80006654:	48 78       	lddpc	r8,80006670 <vTaskPriorityDisinherit+0x4c>
80006656:	91 0c       	st.w	r8[0x0],r12
80006658:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000665c:	0c 9b       	mov	r11,r6
8000665e:	48 68       	lddpc	r8,80006674 <vTaskPriorityDisinherit+0x50>
80006660:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006664:	f0 1f 00 05 	mcall	80006678 <vTaskPriorityDisinherit+0x54>
80006668:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	5d 22       	mustr	r2
80006670:	00 00       	add	r0,r0
80006672:	0d 58       	ld.sh	r8,--r6
80006674:	00 00       	add	r0,r0
80006676:	0c 3c       	cp.w	r12,r6
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	5c d2       	com	r2

8000667c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000667c:	eb cd 40 c0 	pushm	r6-r7,lr
80006680:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006682:	49 b8       	lddpc	r8,800066ec <vTaskPriorityInherit+0x70>
80006684:	70 08       	ld.w	r8,r8[0x0]
80006686:	78 b9       	ld.w	r9,r12[0x2c]
80006688:	70 b8       	ld.w	r8,r8[0x2c]
8000668a:	10 39       	cp.w	r9,r8
8000668c:	c2 d2       	brcc	800066e6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000668e:	49 88       	lddpc	r8,800066ec <vTaskPriorityInherit+0x70>
80006690:	70 08       	ld.w	r8,r8[0x0]
80006692:	70 b8       	ld.w	r8,r8[0x2c]
80006694:	f0 08 11 08 	rsub	r8,r8,8
80006698:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000669a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000669e:	49 59       	lddpc	r9,800066f0 <vTaskPriorityInherit+0x74>
800066a0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066a4:	78 59       	ld.w	r9,r12[0x14]
800066a6:	10 39       	cp.w	r9,r8
800066a8:	c1 b1       	brne	800066de <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800066aa:	f8 c6 ff fc 	sub	r6,r12,-4
800066ae:	0c 9c       	mov	r12,r6
800066b0:	f0 1f 00 11 	mcall	800066f4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066b4:	48 e8       	lddpc	r8,800066ec <vTaskPriorityInherit+0x70>
800066b6:	70 08       	ld.w	r8,r8[0x0]
800066b8:	70 bc       	ld.w	r12,r8[0x2c]
800066ba:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800066bc:	48 f8       	lddpc	r8,800066f8 <vTaskPriorityInherit+0x7c>
800066be:	70 08       	ld.w	r8,r8[0x0]
800066c0:	10 3c       	cp.w	r12,r8
800066c2:	e0 88 00 04 	brls	800066ca <vTaskPriorityInherit+0x4e>
800066c6:	48 d8       	lddpc	r8,800066f8 <vTaskPriorityInherit+0x7c>
800066c8:	91 0c       	st.w	r8[0x0],r12
800066ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066ce:	0c 9b       	mov	r11,r6
800066d0:	48 88       	lddpc	r8,800066f0 <vTaskPriorityInherit+0x74>
800066d2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066d6:	f0 1f 00 0a 	mcall	800066fc <vTaskPriorityInherit+0x80>
800066da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066de:	48 48       	lddpc	r8,800066ec <vTaskPriorityInherit+0x70>
800066e0:	70 08       	ld.w	r8,r8[0x0]
800066e2:	70 b8       	ld.w	r8,r8[0x2c]
800066e4:	99 b8       	st.w	r12[0x2c],r8
800066e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066ea:	00 00       	add	r0,r0
800066ec:	00 00       	add	r0,r0
800066ee:	0c f0       	st.b	--r6,r0
800066f0:	00 00       	add	r0,r0
800066f2:	0c 3c       	cp.w	r12,r6
800066f4:	80 00       	ld.sh	r0,r0[0x0]
800066f6:	5d 22       	mustr	r2
800066f8:	00 00       	add	r0,r0
800066fa:	0d 58       	ld.sh	r8,--r6
800066fc:	80 00       	ld.sh	r0,r0[0x0]
800066fe:	5c d2       	com	r2

80006700 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006700:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006704:	78 38       	ld.w	r8,r12[0xc]
80006706:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006708:	ee c6 ff e8 	sub	r6,r7,-24
8000670c:	0c 9c       	mov	r12,r6
8000670e:	f0 1f 00 15 	mcall	80006760 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006712:	49 58       	lddpc	r8,80006764 <xTaskRemoveFromEventList+0x64>
80006714:	70 08       	ld.w	r8,r8[0x0]
80006716:	58 08       	cp.w	r8,0
80006718:	c1 71       	brne	80006746 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000671a:	ee c6 ff fc 	sub	r6,r7,-4
8000671e:	0c 9c       	mov	r12,r6
80006720:	f0 1f 00 10 	mcall	80006760 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006724:	6e bc       	ld.w	r12,r7[0x2c]
80006726:	49 18       	lddpc	r8,80006768 <xTaskRemoveFromEventList+0x68>
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	10 3c       	cp.w	r12,r8
8000672c:	e0 88 00 04 	brls	80006734 <xTaskRemoveFromEventList+0x34>
80006730:	48 e8       	lddpc	r8,80006768 <xTaskRemoveFromEventList+0x68>
80006732:	91 0c       	st.w	r8[0x0],r12
80006734:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006738:	0c 9b       	mov	r11,r6
8000673a:	48 d8       	lddpc	r8,8000676c <xTaskRemoveFromEventList+0x6c>
8000673c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006740:	f0 1f 00 0c 	mcall	80006770 <xTaskRemoveFromEventList+0x70>
80006744:	c0 58       	rjmp	8000674e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006746:	0c 9b       	mov	r11,r6
80006748:	48 bc       	lddpc	r12,80006774 <xTaskRemoveFromEventList+0x74>
8000674a:	f0 1f 00 0a 	mcall	80006770 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000674e:	48 b8       	lddpc	r8,80006778 <xTaskRemoveFromEventList+0x78>
80006750:	70 08       	ld.w	r8,r8[0x0]
80006752:	6e b9       	ld.w	r9,r7[0x2c]
80006754:	70 b8       	ld.w	r8,r8[0x2c]
80006756:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006758:	5f 2c       	srhs	r12
8000675a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000675e:	00 00       	add	r0,r0
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	5d 22       	mustr	r2
80006764:	00 00       	add	r0,r0
80006766:	0d 20       	ld.uh	r0,r6++
80006768:	00 00       	add	r0,r0
8000676a:	0d 58       	ld.sh	r8,--r6
8000676c:	00 00       	add	r0,r0
8000676e:	0c 3c       	cp.w	r12,r6
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	5c d2       	com	r2
80006774:	00 00       	add	r0,r0
80006776:	0c f4       	st.b	--r6,r4
80006778:	00 00       	add	r0,r0
8000677a:	0c f0       	st.b	--r6,r0

8000677c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000677c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006780:	4b 98       	lddpc	r8,80006864 <vTaskIncrementTick+0xe8>
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	58 08       	cp.w	r8,0
80006786:	c6 91       	brne	80006858 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006788:	4b 88       	lddpc	r8,80006868 <vTaskIncrementTick+0xec>
8000678a:	70 09       	ld.w	r9,r8[0x0]
8000678c:	2f f9       	sub	r9,-1
8000678e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006790:	70 08       	ld.w	r8,r8[0x0]
80006792:	58 08       	cp.w	r8,0
80006794:	c1 a1       	brne	800067c8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006796:	4b 68       	lddpc	r8,8000686c <vTaskIncrementTick+0xf0>
80006798:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000679a:	4b 69       	lddpc	r9,80006870 <vTaskIncrementTick+0xf4>
8000679c:	72 0b       	ld.w	r11,r9[0x0]
8000679e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800067a0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800067a2:	4b 59       	lddpc	r9,80006874 <vTaskIncrementTick+0xf8>
800067a4:	72 0a       	ld.w	r10,r9[0x0]
800067a6:	2f fa       	sub	r10,-1
800067a8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800067aa:	70 08       	ld.w	r8,r8[0x0]
800067ac:	70 08       	ld.w	r8,r8[0x0]
800067ae:	58 08       	cp.w	r8,0
800067b0:	c0 51       	brne	800067ba <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067b2:	3f f9       	mov	r9,-1
800067b4:	4b 18       	lddpc	r8,80006878 <vTaskIncrementTick+0xfc>
800067b6:	91 09       	st.w	r8[0x0],r9
800067b8:	c0 88       	rjmp	800067c8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067ba:	4a d8       	lddpc	r8,8000686c <vTaskIncrementTick+0xf0>
800067bc:	70 08       	ld.w	r8,r8[0x0]
800067be:	70 38       	ld.w	r8,r8[0xc]
800067c0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800067c2:	70 19       	ld.w	r9,r8[0x4]
800067c4:	4a d8       	lddpc	r8,80006878 <vTaskIncrementTick+0xfc>
800067c6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800067c8:	4a 88       	lddpc	r8,80006868 <vTaskIncrementTick+0xec>
800067ca:	70 09       	ld.w	r9,r8[0x0]
800067cc:	4a b8       	lddpc	r8,80006878 <vTaskIncrementTick+0xfc>
800067ce:	70 08       	ld.w	r8,r8[0x0]
800067d0:	10 39       	cp.w	r9,r8
800067d2:	c4 73       	brcs	80006860 <vTaskIncrementTick+0xe4>
800067d4:	4a 68       	lddpc	r8,8000686c <vTaskIncrementTick+0xf0>
800067d6:	70 08       	ld.w	r8,r8[0x0]
800067d8:	70 08       	ld.w	r8,r8[0x0]
800067da:	58 08       	cp.w	r8,0
800067dc:	c0 c0       	breq	800067f4 <vTaskIncrementTick+0x78>
800067de:	4a 48       	lddpc	r8,8000686c <vTaskIncrementTick+0xf0>
800067e0:	70 08       	ld.w	r8,r8[0x0]
800067e2:	70 38       	ld.w	r8,r8[0xc]
800067e4:	70 37       	ld.w	r7,r8[0xc]
800067e6:	6e 18       	ld.w	r8,r7[0x4]
800067e8:	4a 09       	lddpc	r9,80006868 <vTaskIncrementTick+0xec>
800067ea:	72 09       	ld.w	r9,r9[0x0]
800067ec:	12 38       	cp.w	r8,r9
800067ee:	e0 88 00 14 	brls	80006816 <vTaskIncrementTick+0x9a>
800067f2:	c0 e8       	rjmp	8000680e <vTaskIncrementTick+0x92>
800067f4:	3f f9       	mov	r9,-1
800067f6:	4a 18       	lddpc	r8,80006878 <vTaskIncrementTick+0xfc>
800067f8:	91 09       	st.w	r8[0x0],r9
800067fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067fe:	6a 08       	ld.w	r8,r5[0x0]
80006800:	70 38       	ld.w	r8,r8[0xc]
80006802:	70 37       	ld.w	r7,r8[0xc]
80006804:	6e 18       	ld.w	r8,r7[0x4]
80006806:	64 09       	ld.w	r9,r2[0x0]
80006808:	12 38       	cp.w	r8,r9
8000680a:	e0 88 00 0a 	brls	8000681e <vTaskIncrementTick+0xa2>
8000680e:	49 b9       	lddpc	r9,80006878 <vTaskIncrementTick+0xfc>
80006810:	93 08       	st.w	r9[0x0],r8
80006812:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006816:	49 a4       	lddpc	r4,8000687c <vTaskIncrementTick+0x100>
80006818:	49 a3       	lddpc	r3,80006880 <vTaskIncrementTick+0x104>
8000681a:	49 55       	lddpc	r5,8000686c <vTaskIncrementTick+0xf0>
8000681c:	49 32       	lddpc	r2,80006868 <vTaskIncrementTick+0xec>
8000681e:	ee c6 ff fc 	sub	r6,r7,-4
80006822:	0c 9c       	mov	r12,r6
80006824:	f0 1f 00 18 	mcall	80006884 <vTaskIncrementTick+0x108>
80006828:	6e a8       	ld.w	r8,r7[0x28]
8000682a:	58 08       	cp.w	r8,0
8000682c:	c0 50       	breq	80006836 <vTaskIncrementTick+0xba>
8000682e:	ee cc ff e8 	sub	r12,r7,-24
80006832:	f0 1f 00 15 	mcall	80006884 <vTaskIncrementTick+0x108>
80006836:	6e bc       	ld.w	r12,r7[0x2c]
80006838:	68 08       	ld.w	r8,r4[0x0]
8000683a:	10 3c       	cp.w	r12,r8
8000683c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006840:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006844:	0c 9b       	mov	r11,r6
80006846:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000684a:	f0 1f 00 10 	mcall	80006888 <vTaskIncrementTick+0x10c>
8000684e:	6a 08       	ld.w	r8,r5[0x0]
80006850:	70 08       	ld.w	r8,r8[0x0]
80006852:	58 08       	cp.w	r8,0
80006854:	cd 51       	brne	800067fe <vTaskIncrementTick+0x82>
80006856:	cc fb       	rjmp	800067f4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006858:	48 d8       	lddpc	r8,8000688c <vTaskIncrementTick+0x110>
8000685a:	70 09       	ld.w	r9,r8[0x0]
8000685c:	2f f9       	sub	r9,-1
8000685e:	91 09       	st.w	r8[0x0],r9
80006860:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006864:	00 00       	add	r0,r0
80006866:	0d 20       	ld.uh	r0,r6++
80006868:	00 00       	add	r0,r0
8000686a:	0d 1c       	ld.sh	r12,r6++
8000686c:	00 00       	add	r0,r0
8000686e:	0c 28       	rsub	r8,r6
80006870:	00 00       	add	r0,r0
80006872:	0c 38       	cp.w	r8,r6
80006874:	00 00       	add	r0,r0
80006876:	0c 34       	cp.w	r4,r6
80006878:	00 00       	add	r0,r0
8000687a:	05 3c       	ld.ub	r12,r2++
8000687c:	00 00       	add	r0,r0
8000687e:	0d 58       	ld.sh	r8,--r6
80006880:	00 00       	add	r0,r0
80006882:	0c 3c       	cp.w	r12,r6
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	5d 22       	mustr	r2
80006888:	80 00       	ld.sh	r0,r0[0x0]
8000688a:	5c d2       	com	r2
8000688c:	00 00       	add	r0,r0
8000688e:	0c 20       	rsub	r0,r6

80006890 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006890:	eb cd 40 c0 	pushm	r6-r7,lr
80006894:	18 97       	mov	r7,r12
80006896:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006898:	f0 1f 00 15 	mcall	800068ec <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000689c:	6c 08       	ld.w	r8,r6[0x0]
8000689e:	5b f8       	cp.w	r8,-1
800068a0:	c0 31       	brne	800068a6 <xTaskCheckForTimeOut+0x16>
800068a2:	30 07       	mov	r7,0
800068a4:	c1 f8       	rjmp	800068e2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800068a6:	49 39       	lddpc	r9,800068f0 <xTaskCheckForTimeOut+0x60>
800068a8:	72 09       	ld.w	r9,r9[0x0]
800068aa:	6e 0a       	ld.w	r10,r7[0x0]
800068ac:	12 3a       	cp.w	r10,r9
800068ae:	c0 70       	breq	800068bc <xTaskCheckForTimeOut+0x2c>
800068b0:	49 19       	lddpc	r9,800068f4 <xTaskCheckForTimeOut+0x64>
800068b2:	72 09       	ld.w	r9,r9[0x0]
800068b4:	6e 1a       	ld.w	r10,r7[0x4]
800068b6:	12 3a       	cp.w	r10,r9
800068b8:	e0 88 00 14 	brls	800068e0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800068bc:	48 e9       	lddpc	r9,800068f4 <xTaskCheckForTimeOut+0x64>
800068be:	72 0a       	ld.w	r10,r9[0x0]
800068c0:	6e 19       	ld.w	r9,r7[0x4]
800068c2:	12 1a       	sub	r10,r9
800068c4:	14 38       	cp.w	r8,r10
800068c6:	e0 88 00 0d 	brls	800068e0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800068ca:	48 ba       	lddpc	r10,800068f4 <xTaskCheckForTimeOut+0x64>
800068cc:	74 0a       	ld.w	r10,r10[0x0]
800068ce:	14 19       	sub	r9,r10
800068d0:	f2 08 00 08 	add	r8,r9,r8
800068d4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800068d6:	0e 9c       	mov	r12,r7
800068d8:	f0 1f 00 08 	mcall	800068f8 <xTaskCheckForTimeOut+0x68>
800068dc:	30 07       	mov	r7,0
800068de:	c0 28       	rjmp	800068e2 <xTaskCheckForTimeOut+0x52>
800068e0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800068e2:	f0 1f 00 07 	mcall	800068fc <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800068e6:	0e 9c       	mov	r12,r7
800068e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	5d dc       	*unknown*
800068f0:	00 00       	add	r0,r0
800068f2:	0c 34       	cp.w	r4,r6
800068f4:	00 00       	add	r0,r0
800068f6:	0d 1c       	ld.sh	r12,r6++
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	65 f4       	ld.w	r4,r2[0x7c]
800068fc:	80 00       	ld.sh	r0,r0[0x0]
800068fe:	5e e8       	retqs	r8

80006900 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006900:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006904:	f0 1f 00 05 	mcall	80006918 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006908:	48 58       	lddpc	r8,8000691c <xTaskGetTickCount+0x1c>
8000690a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000690c:	f0 1f 00 05 	mcall	80006920 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006910:	0e 9c       	mov	r12,r7
80006912:	e3 cd 80 80 	ldm	sp++,r7,pc
80006916:	00 00       	add	r0,r0
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	5d dc       	*unknown*
8000691c:	00 00       	add	r0,r0
8000691e:	0d 1c       	ld.sh	r12,r6++
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	5e e8       	retqs	r8

80006924 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006924:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006928:	f0 1f 00 2c 	mcall	800069d8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000692c:	4a c8       	lddpc	r8,800069dc <xTaskResumeAll+0xb8>
8000692e:	70 09       	ld.w	r9,r8[0x0]
80006930:	20 19       	sub	r9,1
80006932:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006934:	70 08       	ld.w	r8,r8[0x0]
80006936:	58 08       	cp.w	r8,0
80006938:	c4 91       	brne	800069ca <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000693a:	4a a8       	lddpc	r8,800069e0 <xTaskResumeAll+0xbc>
8000693c:	70 08       	ld.w	r8,r8[0x0]
8000693e:	58 08       	cp.w	r8,0
80006940:	c4 50       	breq	800069ca <xTaskResumeAll+0xa6>
80006942:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006944:	4a 85       	lddpc	r5,800069e4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006946:	4a 93       	lddpc	r3,800069e8 <xTaskResumeAll+0xc4>
80006948:	4a 92       	lddpc	r2,800069ec <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000694a:	4a a1       	lddpc	r1,800069f0 <xTaskResumeAll+0xcc>
8000694c:	c1 e8       	rjmp	80006988 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000694e:	6a 38       	ld.w	r8,r5[0xc]
80006950:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006952:	ee cc ff e8 	sub	r12,r7,-24
80006956:	f0 1f 00 28 	mcall	800069f4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000695a:	ee c6 ff fc 	sub	r6,r7,-4
8000695e:	0c 9c       	mov	r12,r6
80006960:	f0 1f 00 25 	mcall	800069f4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006964:	6e bc       	ld.w	r12,r7[0x2c]
80006966:	66 08       	ld.w	r8,r3[0x0]
80006968:	10 3c       	cp.w	r12,r8
8000696a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000696e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006972:	0c 9b       	mov	r11,r6
80006974:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006978:	f0 1f 00 20 	mcall	800069f8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000697c:	62 08       	ld.w	r8,r1[0x0]
8000697e:	6e b9       	ld.w	r9,r7[0x2c]
80006980:	70 b8       	ld.w	r8,r8[0x2c]
80006982:	10 39       	cp.w	r9,r8
80006984:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006988:	6a 08       	ld.w	r8,r5[0x0]
8000698a:	58 08       	cp.w	r8,0
8000698c:	ce 11       	brne	8000694e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000698e:	49 c8       	lddpc	r8,800069fc <xTaskResumeAll+0xd8>
80006990:	70 08       	ld.w	r8,r8[0x0]
80006992:	58 08       	cp.w	r8,0
80006994:	c0 f0       	breq	800069b2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006996:	49 a8       	lddpc	r8,800069fc <xTaskResumeAll+0xd8>
80006998:	70 08       	ld.w	r8,r8[0x0]
8000699a:	58 08       	cp.w	r8,0
8000699c:	c1 10       	breq	800069be <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000699e:	49 87       	lddpc	r7,800069fc <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800069a0:	f0 1f 00 18 	mcall	80006a00 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800069a4:	6e 08       	ld.w	r8,r7[0x0]
800069a6:	20 18       	sub	r8,1
800069a8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069aa:	6e 08       	ld.w	r8,r7[0x0]
800069ac:	58 08       	cp.w	r8,0
800069ae:	cf 91       	brne	800069a0 <xTaskResumeAll+0x7c>
800069b0:	c0 78       	rjmp	800069be <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069b2:	58 14       	cp.w	r4,1
800069b4:	c0 50       	breq	800069be <xTaskResumeAll+0x9a>
800069b6:	49 48       	lddpc	r8,80006a04 <xTaskResumeAll+0xe0>
800069b8:	70 08       	ld.w	r8,r8[0x0]
800069ba:	58 18       	cp.w	r8,1
800069bc:	c0 71       	brne	800069ca <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800069be:	30 09       	mov	r9,0
800069c0:	49 18       	lddpc	r8,80006a04 <xTaskResumeAll+0xe0>
800069c2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800069c4:	d7 33       	scall
800069c6:	30 17       	mov	r7,1
800069c8:	c0 28       	rjmp	800069cc <xTaskResumeAll+0xa8>
800069ca:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800069cc:	f0 1f 00 0f 	mcall	80006a08 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800069d0:	0e 9c       	mov	r12,r7
800069d2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800069d6:	00 00       	add	r0,r0
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	5d dc       	*unknown*
800069dc:	00 00       	add	r0,r0
800069de:	0d 20       	ld.uh	r0,r6++
800069e0:	00 00       	add	r0,r0
800069e2:	0d 3c       	ld.ub	r12,r6++
800069e4:	00 00       	add	r0,r0
800069e6:	0c f4       	st.b	--r6,r4
800069e8:	00 00       	add	r0,r0
800069ea:	0d 58       	ld.sh	r8,--r6
800069ec:	00 00       	add	r0,r0
800069ee:	0c 3c       	cp.w	r12,r6
800069f0:	00 00       	add	r0,r0
800069f2:	0c f0       	st.b	--r6,r0
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	5d 22       	mustr	r2
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	5c d2       	com	r2
800069fc:	00 00       	add	r0,r0
800069fe:	0c 20       	rsub	r0,r6
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	67 7c       	ld.w	r12,r3[0x5c]
80006a04:	00 00       	add	r0,r0
80006a06:	0d 40       	ld.w	r0,--r6
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	5e e8       	retqs	r8

80006a0c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a0c:	eb cd 40 80 	pushm	r7,lr
80006a10:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a12:	49 08       	lddpc	r8,80006a50 <prvAddCurrentTaskToDelayedList+0x44>
80006a14:	70 08       	ld.w	r8,r8[0x0]
80006a16:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a18:	48 f8       	lddpc	r8,80006a54 <prvAddCurrentTaskToDelayedList+0x48>
80006a1a:	70 08       	ld.w	r8,r8[0x0]
80006a1c:	10 3c       	cp.w	r12,r8
80006a1e:	c0 a2       	brcc	80006a32 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a20:	48 c8       	lddpc	r8,80006a50 <prvAddCurrentTaskToDelayedList+0x44>
80006a22:	70 0b       	ld.w	r11,r8[0x0]
80006a24:	48 d8       	lddpc	r8,80006a58 <prvAddCurrentTaskToDelayedList+0x4c>
80006a26:	70 0c       	ld.w	r12,r8[0x0]
80006a28:	2f cb       	sub	r11,-4
80006a2a:	f0 1f 00 0d 	mcall	80006a5c <prvAddCurrentTaskToDelayedList+0x50>
80006a2e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a32:	48 88       	lddpc	r8,80006a50 <prvAddCurrentTaskToDelayedList+0x44>
80006a34:	70 0b       	ld.w	r11,r8[0x0]
80006a36:	48 b8       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x54>
80006a38:	70 0c       	ld.w	r12,r8[0x0]
80006a3a:	2f cb       	sub	r11,-4
80006a3c:	f0 1f 00 08 	mcall	80006a5c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a40:	48 98       	lddpc	r8,80006a64 <prvAddCurrentTaskToDelayedList+0x58>
80006a42:	70 08       	ld.w	r8,r8[0x0]
80006a44:	10 37       	cp.w	r7,r8
80006a46:	c0 32       	brcc	80006a4c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a48:	48 78       	lddpc	r8,80006a64 <prvAddCurrentTaskToDelayedList+0x58>
80006a4a:	91 07       	st.w	r8[0x0],r7
80006a4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a50:	00 00       	add	r0,r0
80006a52:	0c f0       	st.b	--r6,r0
80006a54:	00 00       	add	r0,r0
80006a56:	0d 1c       	ld.sh	r12,r6++
80006a58:	00 00       	add	r0,r0
80006a5a:	0c 38       	cp.w	r8,r6
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	5c ee       	tnbz	lr
80006a60:	00 00       	add	r0,r0
80006a62:	0c 28       	rsub	r8,r6
80006a64:	00 00       	add	r0,r0
80006a66:	05 3c       	ld.ub	r12,r2++

80006a68 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a68:	eb cd 40 c0 	pushm	r6-r7,lr
80006a6c:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a6e:	58 0c       	cp.w	r12,0
80006a70:	c1 10       	breq	80006a92 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a72:	f0 1f 00 0a 	mcall	80006a98 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a76:	48 a8       	lddpc	r8,80006a9c <vTaskDelay+0x34>
80006a78:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a7a:	48 a8       	lddpc	r8,80006aa0 <vTaskDelay+0x38>
80006a7c:	70 0c       	ld.w	r12,r8[0x0]
80006a7e:	2f cc       	sub	r12,-4
80006a80:	f0 1f 00 09 	mcall	80006aa4 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a84:	ee 06 00 0c 	add	r12,r7,r6
80006a88:	f0 1f 00 08 	mcall	80006aa8 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a8c:	f0 1f 00 08 	mcall	80006aac <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a90:	c0 21       	brne	80006a94 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a92:	d7 33       	scall
80006a94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	65 68       	ld.w	r8,r2[0x58]
80006a9c:	00 00       	add	r0,r0
80006a9e:	0d 1c       	ld.sh	r12,r6++
80006aa0:	00 00       	add	r0,r0
80006aa2:	0c f0       	st.b	--r6,r0
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	5d 22       	mustr	r2
80006aa8:	80 00       	ld.sh	r0,r0[0x0]
80006aaa:	6a 0c       	ld.w	r12,r5[0x0]
80006aac:	80 00       	ld.sh	r0,r0[0x0]
80006aae:	69 24       	ld.w	r4,r4[0x48]

80006ab0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006ab0:	eb cd 40 c0 	pushm	r6-r7,lr
80006ab4:	18 96       	mov	r6,r12
80006ab6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006ab8:	f0 1f 00 18 	mcall	80006b18 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006abc:	6c 08       	ld.w	r8,r6[0x0]
80006abe:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006ac0:	49 79       	lddpc	r9,80006b1c <vTaskDelayUntil+0x6c>
80006ac2:	72 09       	ld.w	r9,r9[0x0]
80006ac4:	12 38       	cp.w	r8,r9
80006ac6:	e0 88 00 0c 	brls	80006ade <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006aca:	0e 38       	cp.w	r8,r7
80006acc:	e0 88 00 22 	brls	80006b10 <vTaskDelayUntil+0x60>
80006ad0:	49 38       	lddpc	r8,80006b1c <vTaskDelayUntil+0x6c>
80006ad2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ad4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006ad6:	10 37       	cp.w	r7,r8
80006ad8:	e0 88 00 14 	brls	80006b00 <vTaskDelayUntil+0x50>
80006adc:	c0 a8       	rjmp	80006af0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006ade:	0e 38       	cp.w	r8,r7
80006ae0:	e0 8b 00 16 	brhi	80006b0c <vTaskDelayUntil+0x5c>
80006ae4:	48 e8       	lddpc	r8,80006b1c <vTaskDelayUntil+0x6c>
80006ae6:	70 08       	ld.w	r8,r8[0x0]
80006ae8:	10 37       	cp.w	r7,r8
80006aea:	e0 8b 00 11 	brhi	80006b0c <vTaskDelayUntil+0x5c>
80006aee:	c1 18       	rjmp	80006b10 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006af0:	48 c8       	lddpc	r8,80006b20 <vTaskDelayUntil+0x70>
80006af2:	70 0c       	ld.w	r12,r8[0x0]
80006af4:	2f cc       	sub	r12,-4
80006af6:	f0 1f 00 0c 	mcall	80006b24 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006afa:	0e 9c       	mov	r12,r7
80006afc:	f0 1f 00 0b 	mcall	80006b28 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b00:	f0 1f 00 0b 	mcall	80006b2c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b04:	c0 81       	brne	80006b14 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b06:	d7 33       	scall
80006b08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b0c:	8d 07       	st.w	r6[0x0],r7
80006b0e:	cf 1b       	rjmp	80006af0 <vTaskDelayUntil+0x40>
80006b10:	8d 07       	st.w	r6[0x0],r7
80006b12:	cf 7b       	rjmp	80006b00 <vTaskDelayUntil+0x50>
80006b14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	65 68       	ld.w	r8,r2[0x58]
80006b1c:	00 00       	add	r0,r0
80006b1e:	0d 1c       	ld.sh	r12,r6++
80006b20:	00 00       	add	r0,r0
80006b22:	0c f0       	st.b	--r6,r0
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	5d 22       	mustr	r2
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	6a 0c       	ld.w	r12,r5[0x0]
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	69 24       	ld.w	r4,r4[0x48]

80006b30 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b30:	eb cd 40 c0 	pushm	r6-r7,lr
80006b34:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b36:	48 e7       	lddpc	r7,80006b6c <vTaskPlaceOnEventList+0x3c>
80006b38:	6e 0b       	ld.w	r11,r7[0x0]
80006b3a:	2e 8b       	sub	r11,-24
80006b3c:	f0 1f 00 0d 	mcall	80006b70 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b40:	6e 0c       	ld.w	r12,r7[0x0]
80006b42:	2f cc       	sub	r12,-4
80006b44:	f0 1f 00 0c 	mcall	80006b74 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b48:	5b f6       	cp.w	r6,-1
80006b4a:	c0 81       	brne	80006b5a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b4c:	6e 0b       	ld.w	r11,r7[0x0]
80006b4e:	2f cb       	sub	r11,-4
80006b50:	48 ac       	lddpc	r12,80006b78 <vTaskPlaceOnEventList+0x48>
80006b52:	f0 1f 00 0b 	mcall	80006b7c <vTaskPlaceOnEventList+0x4c>
80006b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b5a:	48 a8       	lddpc	r8,80006b80 <vTaskPlaceOnEventList+0x50>
80006b5c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b5e:	ec 0c 00 0c 	add	r12,r6,r12
80006b62:	f0 1f 00 09 	mcall	80006b84 <vTaskPlaceOnEventList+0x54>
80006b66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b6a:	00 00       	add	r0,r0
80006b6c:	00 00       	add	r0,r0
80006b6e:	0c f0       	st.b	--r6,r0
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	5c ee       	tnbz	lr
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	5d 22       	mustr	r2
80006b78:	00 00       	add	r0,r0
80006b7a:	0d 44       	ld.w	r4,--r6
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	5c d2       	com	r2
80006b80:	00 00       	add	r0,r0
80006b82:	0d 1c       	ld.sh	r12,r6++
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	6a 0c       	ld.w	r12,r5[0x0]

80006b88 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b88:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b8c:	49 67       	lddpc	r7,80006be4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b8e:	49 74       	lddpc	r4,80006be8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b90:	49 73       	lddpc	r3,80006bec <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b92:	49 85       	lddpc	r5,80006bf0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b94:	6e 08       	ld.w	r8,r7[0x0]
80006b96:	58 08       	cp.w	r8,0
80006b98:	c1 e0       	breq	80006bd4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b9a:	f0 1f 00 17 	mcall	80006bf4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b9e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006ba0:	f0 1f 00 16 	mcall	80006bf8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006ba4:	58 06       	cp.w	r6,0
80006ba6:	c1 70       	breq	80006bd4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006ba8:	f0 1f 00 15 	mcall	80006bfc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006bac:	68 38       	ld.w	r8,r4[0xc]
80006bae:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006bb0:	ec cc ff fc 	sub	r12,r6,-4
80006bb4:	f0 1f 00 13 	mcall	80006c00 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006bb8:	66 08       	ld.w	r8,r3[0x0]
80006bba:	20 18       	sub	r8,1
80006bbc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006bbe:	6e 08       	ld.w	r8,r7[0x0]
80006bc0:	20 18       	sub	r8,1
80006bc2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006bc4:	f0 1f 00 10 	mcall	80006c04 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006bc8:	6c cc       	ld.w	r12,r6[0x30]
80006bca:	f0 1f 00 10 	mcall	80006c08 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006bce:	0c 9c       	mov	r12,r6
80006bd0:	f0 1f 00 0e 	mcall	80006c08 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006bd4:	6a 08       	ld.w	r8,r5[0x0]
80006bd6:	58 18       	cp.w	r8,1
80006bd8:	e0 88 00 03 	brls	80006bde <prvIdleTask+0x56>
			{
				taskYIELD();
80006bdc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006bde:	f0 1f 00 0c 	mcall	80006c0c <prvIdleTask+0x84>
		}
		#endif
	}
80006be2:	cd 9b       	rjmp	80006b94 <prvIdleTask+0xc>
80006be4:	00 00       	add	r0,r0
80006be6:	0c 30       	cp.w	r0,r6
80006be8:	00 00       	add	r0,r0
80006bea:	0c dc       	st.w	--r6,r12
80006bec:	00 00       	add	r0,r0
80006bee:	0d 3c       	ld.ub	r12,r6++
80006bf0:	00 00       	add	r0,r0
80006bf2:	0c 3c       	cp.w	r12,r6
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	65 68       	ld.w	r8,r2[0x58]
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	69 24       	ld.w	r4,r4[0x48]
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	5d dc       	*unknown*
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	5d 22       	mustr	r2
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	5e e8       	retqs	r8
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	60 20       	ld.w	r0,r0[0x8]
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	20 2c       	sub	r12,2

80006c10 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c10:	d4 31       	pushm	r0-r7,lr
80006c12:	20 1d       	sub	sp,4
80006c14:	fa c4 ff d8 	sub	r4,sp,-40
80006c18:	50 0c       	stdsp	sp[0x0],r12
80006c1a:	16 91       	mov	r1,r11
80006c1c:	14 97       	mov	r7,r10
80006c1e:	12 90       	mov	r0,r9
80006c20:	10 93       	mov	r3,r8
80006c22:	68 02       	ld.w	r2,r4[0x0]
80006c24:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c26:	34 8c       	mov	r12,72
80006c28:	f0 1f 00 5c 	mcall	80006d98 <xTaskGenericCreate+0x188>
80006c2c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c2e:	c0 31       	brne	80006c34 <xTaskGenericCreate+0x24>
80006c30:	3f fc       	mov	r12,-1
80006c32:	ca f8       	rjmp	80006d90 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c34:	58 06       	cp.w	r6,0
80006c36:	e0 81 00 af 	brne	80006d94 <xTaskGenericCreate+0x184>
80006c3a:	0e 9c       	mov	r12,r7
80006c3c:	5c 7c       	castu.h	r12
80006c3e:	a3 6c       	lsl	r12,0x2
80006c40:	f0 1f 00 56 	mcall	80006d98 <xTaskGenericCreate+0x188>
80006c44:	18 96       	mov	r6,r12
80006c46:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c48:	c0 61       	brne	80006c54 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c4a:	0a 9c       	mov	r12,r5
80006c4c:	f0 1f 00 54 	mcall	80006d9c <xTaskGenericCreate+0x18c>
80006c50:	3f fc       	mov	r12,-1
80006c52:	c9 f8       	rjmp	80006d90 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c54:	5c 77       	castu.h	r7
80006c56:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c5a:	e0 6b 00 a5 	mov	r11,165
80006c5e:	0c 9c       	mov	r12,r6
80006c60:	f0 1f 00 50 	mcall	80006da0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c64:	ee c6 00 01 	sub	r6,r7,1
80006c68:	6a c8       	ld.w	r8,r5[0x30]
80006c6a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c6e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c72:	31 0a       	mov	r10,16
80006c74:	02 9b       	mov	r11,r1
80006c76:	ea cc ff cc 	sub	r12,r5,-52
80006c7a:	f0 1f 00 4b 	mcall	80006da4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c7e:	30 08       	mov	r8,0
80006c80:	eb 68 00 43 	st.b	r5[67],r8
80006c84:	58 73       	cp.w	r3,7
80006c86:	e6 07 17 80 	movls	r7,r3
80006c8a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c8e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006c90:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c94:	ea c4 ff fc 	sub	r4,r5,-4
80006c98:	08 9c       	mov	r12,r4
80006c9a:	f0 1f 00 44 	mcall	80006da8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c9e:	ea cc ff e8 	sub	r12,r5,-24
80006ca2:	f0 1f 00 42 	mcall	80006da8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006ca6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006ca8:	ee 07 11 08 	rsub	r7,r7,8
80006cac:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006cae:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006cb0:	00 9a       	mov	r10,r0
80006cb2:	40 0b       	lddsp	r11,sp[0x0]
80006cb4:	0c 9c       	mov	r12,r6
80006cb6:	f0 1f 00 3e 	mcall	80006dac <xTaskGenericCreate+0x19c>
80006cba:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006cbc:	58 02       	cp.w	r2,0
80006cbe:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006cc2:	f0 1f 00 3c 	mcall	80006db0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006cc6:	4b c8       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a4>
80006cc8:	70 09       	ld.w	r9,r8[0x0]
80006cca:	2f f9       	sub	r9,-1
80006ccc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006cce:	4b b8       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1a8>
80006cd0:	70 08       	ld.w	r8,r8[0x0]
80006cd2:	58 08       	cp.w	r8,0
80006cd4:	c2 61       	brne	80006d20 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006cd6:	4b 98       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1a8>
80006cd8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006cda:	4b 78       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a4>
80006cdc:	70 08       	ld.w	r8,r8[0x0]
80006cde:	58 18       	cp.w	r8,1
80006ce0:	c2 b1       	brne	80006d36 <xTaskGenericCreate+0x126>
80006ce2:	4b 77       	lddpc	r7,80006dbc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006ce4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006ce8:	0e 9c       	mov	r12,r7
80006cea:	f0 1f 00 36 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>
80006cee:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006cf0:	0c 37       	cp.w	r7,r6
80006cf2:	cf b1       	brne	80006ce8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006cf4:	4b 47       	lddpc	r7,80006dc4 <xTaskGenericCreate+0x1b4>
80006cf6:	0e 9c       	mov	r12,r7
80006cf8:	f0 1f 00 32 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006cfc:	4b 36       	lddpc	r6,80006dc8 <xTaskGenericCreate+0x1b8>
80006cfe:	0c 9c       	mov	r12,r6
80006d00:	f0 1f 00 30 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d04:	4b 2c       	lddpc	r12,80006dcc <xTaskGenericCreate+0x1bc>
80006d06:	f0 1f 00 2f 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d0a:	4b 2c       	lddpc	r12,80006dd0 <xTaskGenericCreate+0x1c0>
80006d0c:	f0 1f 00 2d 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d10:	4b 1c       	lddpc	r12,80006dd4 <xTaskGenericCreate+0x1c4>
80006d12:	f0 1f 00 2c 	mcall	80006dc0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d16:	4b 18       	lddpc	r8,80006dd8 <xTaskGenericCreate+0x1c8>
80006d18:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d1a:	4b 18       	lddpc	r8,80006ddc <xTaskGenericCreate+0x1cc>
80006d1c:	91 06       	st.w	r8[0x0],r6
80006d1e:	c0 c8       	rjmp	80006d36 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d20:	4b 08       	lddpc	r8,80006de0 <xTaskGenericCreate+0x1d0>
80006d22:	70 08       	ld.w	r8,r8[0x0]
80006d24:	58 08       	cp.w	r8,0
80006d26:	c0 81       	brne	80006d36 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d28:	4a 48       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1a8>
80006d2a:	70 08       	ld.w	r8,r8[0x0]
80006d2c:	70 b8       	ld.w	r8,r8[0x2c]
80006d2e:	10 33       	cp.w	r3,r8
80006d30:	c0 33       	brcs	80006d36 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d32:	4a 28       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1a8>
80006d34:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d36:	6a b8       	ld.w	r8,r5[0x2c]
80006d38:	4a b9       	lddpc	r9,80006de4 <xTaskGenericCreate+0x1d4>
80006d3a:	72 09       	ld.w	r9,r9[0x0]
80006d3c:	12 38       	cp.w	r8,r9
80006d3e:	e0 88 00 04 	brls	80006d46 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d42:	4a 99       	lddpc	r9,80006de4 <xTaskGenericCreate+0x1d4>
80006d44:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d46:	4a 98       	lddpc	r8,80006de8 <xTaskGenericCreate+0x1d8>
80006d48:	70 09       	ld.w	r9,r8[0x0]
80006d4a:	2f f9       	sub	r9,-1
80006d4c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d4e:	6a b8       	ld.w	r8,r5[0x2c]
80006d50:	4a 79       	lddpc	r9,80006dec <xTaskGenericCreate+0x1dc>
80006d52:	72 09       	ld.w	r9,r9[0x0]
80006d54:	12 38       	cp.w	r8,r9
80006d56:	e0 88 00 04 	brls	80006d5e <xTaskGenericCreate+0x14e>
80006d5a:	4a 59       	lddpc	r9,80006dec <xTaskGenericCreate+0x1dc>
80006d5c:	93 08       	st.w	r9[0x0],r8
80006d5e:	6a bc       	ld.w	r12,r5[0x2c]
80006d60:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d64:	08 9b       	mov	r11,r4
80006d66:	49 68       	lddpc	r8,80006dbc <xTaskGenericCreate+0x1ac>
80006d68:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d6c:	f0 1f 00 21 	mcall	80006df0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d70:	f0 1f 00 21 	mcall	80006df4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d74:	49 b8       	lddpc	r8,80006de0 <xTaskGenericCreate+0x1d0>
80006d76:	70 08       	ld.w	r8,r8[0x0]
80006d78:	58 08       	cp.w	r8,0
80006d7a:	c0 a0       	breq	80006d8e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d7c:	48 f8       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1a8>
80006d7e:	70 08       	ld.w	r8,r8[0x0]
80006d80:	70 b8       	ld.w	r8,r8[0x2c]
80006d82:	10 33       	cp.w	r3,r8
80006d84:	e0 88 00 05 	brls	80006d8e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d88:	d7 33       	scall
80006d8a:	30 1c       	mov	r12,1
80006d8c:	c0 28       	rjmp	80006d90 <xTaskGenericCreate+0x180>
80006d8e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006d90:	2f fd       	sub	sp,-4
80006d92:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d94:	99 c6       	st.w	r12[0x30],r6
80006d96:	c5 fb       	rjmp	80006c54 <xTaskGenericCreate+0x44>
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	60 48       	ld.w	r8,r0[0x10]
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	60 20       	ld.w	r0,r0[0x8]
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	79 a0       	ld.w	r0,r12[0x68]
80006da4:	80 00       	ld.sh	r0,r0[0x0]
80006da6:	7c cc       	ld.w	r12,lr[0x30]
80006da8:	80 00       	ld.sh	r0,r0[0x0]
80006daa:	5c cc       	swap.bh	r12
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	5d 48       	*unknown*
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	5d dc       	*unknown*
80006db4:	00 00       	add	r0,r0
80006db6:	0d 3c       	ld.ub	r12,r6++
80006db8:	00 00       	add	r0,r0
80006dba:	0c f0       	st.b	--r6,r0
80006dbc:	00 00       	add	r0,r0
80006dbe:	0c 3c       	cp.w	r12,r6
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	5c b8       	swap.b	r8
80006dc4:	00 00       	add	r0,r0
80006dc6:	0d 08       	ld.w	r8,r6++
80006dc8:	00 00       	add	r0,r0
80006dca:	0d 24       	ld.uh	r4,r6++
80006dcc:	00 00       	add	r0,r0
80006dce:	0c f4       	st.b	--r6,r4
80006dd0:	00 00       	add	r0,r0
80006dd2:	0c dc       	st.w	--r6,r12
80006dd4:	00 00       	add	r0,r0
80006dd6:	0d 44       	ld.w	r4,--r6
80006dd8:	00 00       	add	r0,r0
80006dda:	0c 28       	rsub	r8,r6
80006ddc:	00 00       	add	r0,r0
80006dde:	0c 38       	cp.w	r8,r6
80006de0:	00 00       	add	r0,r0
80006de2:	0c 2c       	rsub	r12,r6
80006de4:	00 00       	add	r0,r0
80006de6:	0c 24       	rsub	r4,r6
80006de8:	00 00       	add	r0,r0
80006dea:	0d 38       	ld.ub	r8,r6++
80006dec:	00 00       	add	r0,r0
80006dee:	0d 58       	ld.sh	r8,--r6
80006df0:	80 00       	ld.sh	r0,r0[0x0]
80006df2:	5c d2       	com	r2
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	5e e8       	retqs	r8

80006df8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006df8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006dfa:	30 09       	mov	r9,0
80006dfc:	1a d9       	st.w	--sp,r9
80006dfe:	1a d9       	st.w	--sp,r9
80006e00:	1a d9       	st.w	--sp,r9
80006e02:	12 98       	mov	r8,r9
80006e04:	e0 6a 01 00 	mov	r10,256
80006e08:	48 9b       	lddpc	r11,80006e2c <vTaskStartScheduler+0x34>
80006e0a:	48 ac       	lddpc	r12,80006e30 <vTaskStartScheduler+0x38>
80006e0c:	f0 1f 00 0a 	mcall	80006e34 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e10:	2f dd       	sub	sp,-12
80006e12:	58 1c       	cp.w	r12,1
80006e14:	c0 a1       	brne	80006e28 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e16:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e18:	30 19       	mov	r9,1
80006e1a:	48 88       	lddpc	r8,80006e38 <vTaskStartScheduler+0x40>
80006e1c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e1e:	30 09       	mov	r9,0
80006e20:	48 78       	lddpc	r8,80006e3c <vTaskStartScheduler+0x44>
80006e22:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e24:	f0 1f 00 07 	mcall	80006e40 <vTaskStartScheduler+0x48>
80006e28:	d8 02       	popm	pc
80006e2a:	00 00       	add	r0,r0
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	d9 e4       	*unknown*
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	6b 88       	ld.w	r8,r5[0x60]
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	6c 10       	ld.w	r0,r6[0x4]
80006e38:	00 00       	add	r0,r0
80006e3a:	0c 2c       	rsub	r12,r6
80006e3c:	00 00       	add	r0,r0
80006e3e:	0d 1c       	ld.sh	r12,r6++
80006e40:	80 00       	ld.sh	r0,r0[0x0]
80006e42:	5d ec       	*unknown*

80006e44 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e44:	16 cc       	st.b	r11++,r12
	return str;
}
80006e46:	5e fb       	retal	r11

80006e48 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e48:	eb cd 40 c0 	pushm	r6-r7,lr
80006e4c:	20 3d       	sub	sp,12
80006e4e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e50:	30 06       	mov	r6,0
80006e52:	30 07       	mov	r7,0
80006e54:	fa e7 00 00 	st.d	sp[0],r6
80006e58:	30 0c       	mov	r12,0
80006e5a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e5c:	58 08       	cp.w	r8,0
80006e5e:	c1 30       	breq	80006e84 <PrintHex+0x3c>
80006e60:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e62:	1a 9c       	mov	r12,sp
80006e64:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e68:	58 9e       	cp.w	lr,9
80006e6a:	e0 8a 00 04 	brle	80006e72 <PrintHex+0x2a>
80006e6e:	2c 9e       	sub	lr,-55
80006e70:	c0 48       	rjmp	80006e78 <PrintHex+0x30>
80006e72:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e76:	2d 0e       	sub	lr,-48
80006e78:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e7c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e7e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e80:	cf 21       	brne	80006e64 <PrintHex+0x1c>
80006e82:	c0 48       	rjmp	80006e8a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e84:	33 08       	mov	r8,48
80006e86:	ba 88       	st.b	sp[0x0],r8
80006e88:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e8a:	f6 09 01 08 	sub	r8,r11,r9
80006e8e:	58 08       	cp.w	r8,0
80006e90:	e0 8a 00 13 	brle	80006eb6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006e94:	12 1b       	sub	r11,r9
80006e96:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006e9a:	18 9e       	mov	lr,r12
80006e9c:	58 0c       	cp.w	r12,0
80006e9e:	e0 8a 00 0c 	brle	80006eb6 <PrintHex+0x6e>
80006ea2:	1a 9b       	mov	r11,sp
80006ea4:	12 0b       	add	r11,r9
80006ea6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006ea8:	33 07       	mov	r7,48
80006eaa:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006eac:	2f f8       	sub	r8,-1
80006eae:	1c 38       	cp.w	r8,lr
80006eb0:	cf d5       	brlt	80006eaa <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006eb2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006eb6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006eba:	f0 cb ff ff 	sub	r11,r8,-1
80006ebe:	58 0b       	cp.w	r11,0
80006ec0:	e0 8a 00 19 	brle	80006ef2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ec4:	fa cb ff f4 	sub	r11,sp,-12
80006ec8:	f6 09 00 09 	add	r9,r11,r9
80006ecc:	37 8b       	mov	r11,120
80006ece:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006ed2:	fa c9 ff f4 	sub	r9,sp,-12
80006ed6:	10 09       	add	r9,r8
80006ed8:	33 0b       	mov	r11,48
80006eda:	f3 6b ff f4 	st.b	r9[-12],r11
80006ede:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ee2:	fa ce 00 01 	sub	lr,sp,1
80006ee6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ee8:	11 8b       	ld.ub	r11,r8[0x0]
80006eea:	12 cb       	st.b	r9++,r11
80006eec:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006eee:	1c 38       	cp.w	r8,lr
80006ef0:	cf c1       	brne	80006ee8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006ef2:	14 9c       	mov	r12,r10
80006ef4:	2f dd       	sub	sp,-12
80006ef6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006efa <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006efa:	d4 21       	pushm	r4-r7,lr
80006efc:	20 3d       	sub	sp,12
80006efe:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f00:	30 06       	mov	r6,0
80006f02:	30 07       	mov	r7,0
80006f04:	fa e7 00 00 	st.d	sp[0],r6
80006f08:	30 0c       	mov	r12,0
80006f0a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f0c:	58 08       	cp.w	r8,0
80006f0e:	c0 35       	brlt	80006f14 <PrintDec+0x1a>
80006f10:	14 97       	mov	r7,r10
80006f12:	c0 58       	rjmp	80006f1c <PrintDec+0x22>
	{
		*p++ = '-';
80006f14:	14 97       	mov	r7,r10
80006f16:	32 d9       	mov	r9,45
80006f18:	0e c9       	st.b	r7++,r9
		i = -i;
80006f1a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f1c:	58 08       	cp.w	r8,0
80006f1e:	c0 51       	brne	80006f28 <PrintDec+0x2e>
80006f20:	33 08       	mov	r8,48
80006f22:	ba 88       	st.b	sp[0x0],r8
80006f24:	30 1e       	mov	lr,1
80006f26:	c2 f8       	rjmp	80006f84 <PrintDec+0x8a>
	
	int ten = i%10;
80006f28:	e0 65 66 67 	mov	r5,26215
80006f2c:	ea 15 66 66 	orh	r5,0x6666
80006f30:	f0 05 04 44 	muls.d	r4,r8,r5
80006f34:	ea 0c 14 02 	asr	r12,r5,0x2
80006f38:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f3c:	f8 09 01 09 	sub	r9,r12,r9
80006f40:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f44:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f48:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f4a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f4c:	e0 66 66 67 	mov	r6,26215
80006f50:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f54:	2d 09       	sub	r9,-48
80006f56:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f5a:	2f fe       	sub	lr,-1
		i /= 10;
80006f5c:	f0 06 04 44 	muls.d	r4,r8,r6
80006f60:	ea 09 14 02 	asr	r9,r5,0x2
80006f64:	bf 58       	asr	r8,0x1f
80006f66:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f6a:	f0 06 04 44 	muls.d	r4,r8,r6
80006f6e:	ea 09 14 02 	asr	r9,r5,0x2
80006f72:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f76:	0a 19       	sub	r9,r5
80006f78:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f7c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f80:	58 08       	cp.w	r8,0
80006f82:	ce 91       	brne	80006f54 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f84:	f6 0e 01 08 	sub	r8,r11,lr
80006f88:	58 08       	cp.w	r8,0
80006f8a:	e0 89 00 06 	brgt	80006f96 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f8e:	58 0e       	cp.w	lr,0
80006f90:	e0 89 00 14 	brgt	80006fb8 <PrintDec+0xbe>
80006f94:	c1 d8       	rjmp	80006fce <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006f96:	1c 1b       	sub	r11,lr
80006f98:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006f9a:	16 9c       	mov	r12,r11
80006f9c:	58 0b       	cp.w	r11,0
80006f9e:	fe 9a ff f8 	brle	80006f8e <PrintDec+0x94>
80006fa2:	1a 99       	mov	r9,sp
80006fa4:	1c 09       	add	r9,lr
80006fa6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fa8:	33 06       	mov	r6,48
80006faa:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006fac:	2f f8       	sub	r8,-1
80006fae:	18 38       	cp.w	r8,r12
80006fb0:	cf d5       	brlt	80006faa <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006fb2:	f6 0e 00 0e 	add	lr,r11,lr
80006fb6:	ce cb       	rjmp	80006f8e <PrintDec+0x94>
80006fb8:	fa c8 ff f4 	sub	r8,sp,-12
80006fbc:	1c 08       	add	r8,lr
80006fbe:	20 d8       	sub	r8,13
80006fc0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006fc4:	11 89       	ld.ub	r9,r8[0x0]
80006fc6:	0e c9       	st.b	r7++,r9
80006fc8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fca:	16 38       	cp.w	r8,r11
80006fcc:	cf c1       	brne	80006fc4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006fce:	14 9c       	mov	r12,r10
80006fd0:	2f dd       	sub	sp,-12
80006fd2:	d8 22       	popm	r4-r7,pc

80006fd4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006fd4:	d4 31       	pushm	r0-r7,lr
80006fd6:	fa cd 02 08 	sub	sp,sp,520
80006fda:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006fdc:	e0 6a 01 00 	mov	r10,256
80006fe0:	30 0b       	mov	r11,0
80006fe2:	fa cc fe f8 	sub	r12,sp,-264
80006fe6:	f0 1f 00 4e 	mcall	8000711c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006fea:	fa c4 fd d4 	sub	r4,sp,-556
80006fee:	30 0a       	mov	r10,0
80006ff0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ff2:	fa c3 ff fc 	sub	r3,sp,-4
80006ff6:	e0 61 01 00 	mov	r1,256
80006ffa:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006ffc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ffe:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007002:	02 9a       	mov	r10,r1
80007004:	00 9b       	mov	r11,r0
80007006:	06 9c       	mov	r12,r3
80007008:	f0 1f 00 45 	mcall	8000711c <log+0x148>
			
					if(*str == '%')
8000700c:	0f 88       	ld.ub	r8,r7[0x0]
8000700e:	e4 08 18 00 	cp.b	r8,r2
80007012:	c5 71       	brne	800070c0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007014:	ee c8 ff ff 	sub	r8,r7,-1
80007018:	11 89       	ld.ub	r9,r8[0x0]
8000701a:	4c 2a       	lddpc	r10,80007120 <log+0x14c>
8000701c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000701e:	23 09       	sub	r9,48
80007020:	30 9a       	mov	r10,9
80007022:	f4 09 18 00 	cp.b	r9,r10
80007026:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000702a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000702e:	f7 b9 08 30 	subls	r9,48
80007032:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007036:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000703a:	0f 88       	ld.ub	r8,r7[0x0]
8000703c:	22 58       	sub	r8,37
8000703e:	e0 48 00 53 	cp.w	r8,83
80007042:	e0 8b 00 31 	brhi	800070a4 <log+0xd0>
80007046:	4b 89       	lddpc	r9,80007124 <log+0x150>
80007048:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000704c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007050:	06 9a       	mov	r10,r3
80007052:	40 0b       	lddsp	r11,sp[0x0]
80007054:	5c 5b       	castu.b	r11
80007056:	68 0c       	ld.w	r12,r4[0x0]
80007058:	f0 1f 00 34 	mcall	80007128 <log+0x154>
							break;
8000705c:	c2 98       	rjmp	800070ae <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000705e:	4b 4c       	lddpc	r12,8000712c <log+0x158>
80007060:	f0 1f 00 34 	mcall	80007130 <log+0x15c>
80007064:	08 95       	mov	r5,r4
80007066:	06 9c       	mov	r12,r3
							break;
80007068:	c2 38       	rjmp	800070ae <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000706a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000706e:	06 9a       	mov	r10,r3
80007070:	40 0b       	lddsp	r11,sp[0x0]
80007072:	5c 5b       	castu.b	r11
80007074:	68 0c       	ld.w	r12,r4[0x0]
80007076:	f0 1f 00 30 	mcall	80007134 <log+0x160>
8000707a:	06 9c       	mov	r12,r3
							break;
8000707c:	c1 98       	rjmp	800070ae <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000707e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007082:	06 9b       	mov	r11,r3
80007084:	09 bc       	ld.ub	r12,r4[0x3]
80007086:	f0 1f 00 2d 	mcall	80007138 <log+0x164>
8000708a:	06 9c       	mov	r12,r3
							break;
8000708c:	c1 18       	rjmp	800070ae <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000708e:	e8 c5 ff fc 	sub	r5,r4,-4
80007092:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007094:	c0 d8       	rjmp	800070ae <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007096:	06 9b       	mov	r11,r3
80007098:	32 5c       	mov	r12,37
8000709a:	f0 1f 00 28 	mcall	80007138 <log+0x164>
8000709e:	08 95       	mov	r5,r4
800070a0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800070a2:	c0 68       	rjmp	800070ae <log+0xda>
							
							default:
							log("I need relax.");
800070a4:	4a 6c       	lddpc	r12,8000713c <log+0x168>
800070a6:	f0 1f 00 23 	mcall	80007130 <log+0x15c>
800070aa:	08 95       	mov	r5,r4
800070ac:	06 9c       	mov	r12,r3
						}
						str++;
800070ae:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070b0:	1a dc       	st.w	--sp,r12
800070b2:	1a d6       	st.w	--sp,r6
800070b4:	4a 3b       	lddpc	r11,80007140 <log+0x16c>
800070b6:	0c 9c       	mov	r12,r6
800070b8:	f0 1f 00 23 	mcall	80007144 <log+0x170>
800070bc:	2f ed       	sub	sp,-8
800070be:	c0 a8       	rjmp	800070d2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070c0:	2f f7       	sub	r7,-1
800070c2:	1a d8       	st.w	--sp,r8
800070c4:	1a d6       	st.w	--sp,r6
800070c6:	4a 1b       	lddpc	r11,80007148 <log+0x174>
800070c8:	0c 9c       	mov	r12,r6
800070ca:	f0 1f 00 1f 	mcall	80007144 <log+0x170>
800070ce:	08 95       	mov	r5,r4
800070d0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800070d2:	0f 89       	ld.ub	r9,r7[0x0]
800070d4:	30 08       	mov	r8,0
800070d6:	f0 09 18 00 	cp.b	r9,r8
800070da:	c0 30       	breq	800070e0 <log+0x10c>
800070dc:	0a 94       	mov	r4,r5
800070de:	c9 2b       	rjmp	80007002 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800070e0:	fa c7 fe f8 	sub	r7,sp,-264
800070e4:	1a d7       	st.w	--sp,r7
800070e6:	49 ab       	lddpc	r11,8000714c <log+0x178>
800070e8:	0e 9c       	mov	r12,r7
800070ea:	f0 1f 00 17 	mcall	80007144 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800070ee:	5c 5c       	castu.b	r12
800070f0:	f8 c6 ff ff 	sub	r6,r12,-1
800070f4:	0c 9c       	mov	r12,r6
800070f6:	f0 1f 00 17 	mcall	80007150 <log+0x17c>
800070fa:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800070fc:	0c 9a       	mov	r10,r6
800070fe:	0e 9b       	mov	r11,r7
80007100:	f0 1f 00 15 	mcall	80007154 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007104:	30 09       	mov	r9,0
80007106:	30 5a       	mov	r10,5
80007108:	fa cb fe f8 	sub	r11,sp,-264
8000710c:	49 38       	lddpc	r8,80007158 <log+0x184>
8000710e:	70 0c       	ld.w	r12,r8[0x0]
80007110:	f0 1f 00 13 	mcall	8000715c <log+0x188>
80007114:	2f fd       	sub	sp,-4
	
	
}
80007116:	fe 3d fd f8 	sub	sp,-520
8000711a:	d8 32       	popm	r0-r7,pc
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	79 a0       	ld.w	r0,r12[0x68]
80007120:	00 00       	add	r0,r0
80007122:	0d 5c       	ld.sh	r12,--r6
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	d9 ec       	*unknown*
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	6e fa       	ld.w	r10,r7[0x3c]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	dc 98       	*unknown*
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	6f d4       	ld.w	r4,r7[0x74]
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	6e 48       	ld.w	r8,r7[0x10]
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6e 44       	ld.w	r4,r7[0x10]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	dc a8       	*unknown*
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	dc b8       	*unknown*
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	7c 90       	ld.w	r0,lr[0x24]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	dc c0       	acall	0xcc
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	dc c8       	*unknown*
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	60 48       	ld.w	r8,r0[0x10]
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	78 58       	ld.w	r8,r12[0x14]
80007158:	00 00       	add	r0,r0
8000715a:	53 c4       	stdsp	sp[0xf0],r4
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	63 9c       	ld.w	r12,r1[0x64]

80007160 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007160:	d4 31       	pushm	r0-r7,lr
80007162:	fa cd 02 0c 	sub	sp,sp,524
80007166:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007168:	e0 6a 01 00 	mov	r10,256
8000716c:	30 0b       	mov	r11,0
8000716e:	fa cc fe f4 	sub	r12,sp,-268
80007172:	f0 1f 00 4c 	mcall	800072a0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007176:	fa c4 fd d0 	sub	r4,sp,-560
8000717a:	30 0a       	mov	r10,0
8000717c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000717e:	fa c3 ff fc 	sub	r3,sp,-4
80007182:	e0 61 01 00 	mov	r1,256
80007186:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007188:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000718a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000718e:	02 9a       	mov	r10,r1
80007190:	00 9b       	mov	r11,r0
80007192:	06 9c       	mov	r12,r3
80007194:	f0 1f 00 43 	mcall	800072a0 <logFromISR+0x140>
			
			if(*str == '%')
80007198:	0f 88       	ld.ub	r8,r7[0x0]
8000719a:	e4 08 18 00 	cp.b	r8,r2
8000719e:	c5 11       	brne	80007240 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800071a0:	ee c8 ff ff 	sub	r8,r7,-1
800071a4:	11 89       	ld.ub	r9,r8[0x0]
800071a6:	4c 0a       	lddpc	r10,800072a4 <logFromISR+0x144>
800071a8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800071aa:	23 09       	sub	r9,48
800071ac:	30 9a       	mov	r10,9
800071ae:	f4 09 18 00 	cp.b	r9,r10
800071b2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071b6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071ba:	f7 b9 08 30 	subls	r9,48
800071be:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800071c2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800071c6:	0f 88       	ld.ub	r8,r7[0x0]
800071c8:	22 58       	sub	r8,37
800071ca:	e0 48 00 53 	cp.w	r8,83
800071ce:	e0 8b 00 2b 	brhi	80007224 <logFromISR+0xc4>
800071d2:	4b 69       	lddpc	r9,800072a8 <logFromISR+0x148>
800071d4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800071d8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800071dc:	06 9a       	mov	r10,r3
800071de:	40 0b       	lddsp	r11,sp[0x0]
800071e0:	5c 5b       	castu.b	r11
800071e2:	68 0c       	ld.w	r12,r4[0x0]
800071e4:	f0 1f 00 32 	mcall	800072ac <logFromISR+0x14c>
					break;
800071e8:	c2 38       	rjmp	8000722e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800071ea:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800071ee:	06 9a       	mov	r10,r3
800071f0:	40 0b       	lddsp	r11,sp[0x0]
800071f2:	5c 5b       	castu.b	r11
800071f4:	68 0c       	ld.w	r12,r4[0x0]
800071f6:	f0 1f 00 2f 	mcall	800072b0 <logFromISR+0x150>
800071fa:	06 9c       	mov	r12,r3
					break;
800071fc:	c1 98       	rjmp	8000722e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800071fe:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007202:	06 9b       	mov	r11,r3
80007204:	09 bc       	ld.ub	r12,r4[0x3]
80007206:	f0 1f 00 2c 	mcall	800072b4 <logFromISR+0x154>
8000720a:	06 9c       	mov	r12,r3
					break;
8000720c:	c1 18       	rjmp	8000722e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000720e:	e8 c5 ff fc 	sub	r5,r4,-4
80007212:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007214:	c0 d8       	rjmp	8000722e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007216:	06 9b       	mov	r11,r3
80007218:	32 5c       	mov	r12,37
8000721a:	f0 1f 00 27 	mcall	800072b4 <logFromISR+0x154>
8000721e:	08 95       	mov	r5,r4
80007220:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007222:	c0 68       	rjmp	8000722e <logFromISR+0xce>
					default:
					log("I need relax.");
80007224:	4a 5c       	lddpc	r12,800072b8 <logFromISR+0x158>
80007226:	f0 1f 00 26 	mcall	800072bc <logFromISR+0x15c>
8000722a:	08 95       	mov	r5,r4
8000722c:	06 9c       	mov	r12,r3
				}
				str++;
8000722e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007230:	1a dc       	st.w	--sp,r12
80007232:	1a d6       	st.w	--sp,r6
80007234:	4a 3b       	lddpc	r11,800072c0 <logFromISR+0x160>
80007236:	0c 9c       	mov	r12,r6
80007238:	f0 1f 00 23 	mcall	800072c4 <logFromISR+0x164>
8000723c:	2f ed       	sub	sp,-8
8000723e:	c0 a8       	rjmp	80007252 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007240:	2f f7       	sub	r7,-1
80007242:	1a d8       	st.w	--sp,r8
80007244:	1a d6       	st.w	--sp,r6
80007246:	4a 1b       	lddpc	r11,800072c8 <logFromISR+0x168>
80007248:	0c 9c       	mov	r12,r6
8000724a:	f0 1f 00 1f 	mcall	800072c4 <logFromISR+0x164>
8000724e:	08 95       	mov	r5,r4
80007250:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007252:	0f 89       	ld.ub	r9,r7[0x0]
80007254:	30 08       	mov	r8,0
80007256:	f0 09 18 00 	cp.b	r9,r8
8000725a:	c0 30       	breq	80007260 <logFromISR+0x100>
8000725c:	0a 94       	mov	r4,r5
8000725e:	c9 8b       	rjmp	8000718e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007260:	fa c7 fe f4 	sub	r7,sp,-268
80007264:	1a d7       	st.w	--sp,r7
80007266:	49 ab       	lddpc	r11,800072cc <logFromISR+0x16c>
80007268:	0e 9c       	mov	r12,r7
8000726a:	f0 1f 00 17 	mcall	800072c4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000726e:	5c 5c       	castu.b	r12
80007270:	f8 c6 ff ff 	sub	r6,r12,-1
80007274:	0c 9c       	mov	r12,r6
80007276:	f0 1f 00 17 	mcall	800072d0 <logFromISR+0x170>
8000727a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000727c:	0c 9a       	mov	r10,r6
8000727e:	0e 9b       	mov	r11,r7
80007280:	f0 1f 00 15 	mcall	800072d4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007284:	30 09       	mov	r9,0
80007286:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007288:	fa ca fe f8 	sub	r10,sp,-264
8000728c:	fa cb fe f4 	sub	r11,sp,-268
80007290:	49 28       	lddpc	r8,800072d8 <logFromISR+0x178>
80007292:	70 0c       	ld.w	r12,r8[0x0]
80007294:	f0 1f 00 12 	mcall	800072dc <logFromISR+0x17c>
80007298:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000729a:	fe 3d fd f4 	sub	sp,-524
8000729e:	d8 32       	popm	r0-r7,pc
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	79 a0       	ld.w	r0,r12[0x68]
800072a4:	00 00       	add	r0,r0
800072a6:	0d 5d       	ld.sh	sp,--r6
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	db 3c       	*unknown*
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6e fa       	ld.w	r10,r7[0x3c]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	6e 48       	ld.w	r8,r7[0x10]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	6e 44       	ld.w	r4,r7[0x10]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	dc a8       	*unknown*
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	6f d4       	ld.w	r4,r7[0x74]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	dc b8       	*unknown*
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	7c 90       	ld.w	r0,lr[0x24]
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	dc c0       	acall	0xcc
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	dc c8       	*unknown*
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	60 48       	ld.w	r8,r0[0x10]
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	78 58       	ld.w	r8,r12[0x14]
800072d8:	00 00       	add	r0,r0
800072da:	53 c4       	stdsp	sp[0xf0],r4
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	63 4c       	ld.w	r12,r1[0x50]

800072e0 <log_init>:
		
	return str;
}

void log_init(void)
{
800072e0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800072e2:	30 2b       	mov	r11,2
800072e4:	48 fc       	lddpc	r12,80007320 <log_init+0x40>
800072e6:	f0 1f 00 10 	mcall	80007324 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800072ea:	e0 6a 36 00 	mov	r10,13824
800072ee:	ea 1a 01 6e 	orh	r10,0x16e
800072f2:	48 eb       	lddpc	r11,80007328 <log_init+0x48>
800072f4:	fe 7c 18 00 	mov	r12,-59392
800072f8:	f0 1f 00 0d 	mcall	8000732c <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800072fc:	30 4b       	mov	r11,4
800072fe:	33 2c       	mov	r12,50
80007300:	f0 1f 00 0c 	mcall	80007330 <log_init+0x50>
80007304:	48 c8       	lddpc	r8,80007334 <log_init+0x54>
80007306:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007308:	30 09       	mov	r9,0
8000730a:	1a d9       	st.w	--sp,r9
8000730c:	1a d9       	st.w	--sp,r9
8000730e:	1a d9       	st.w	--sp,r9
80007310:	30 28       	mov	r8,2
80007312:	36 4a       	mov	r10,100
80007314:	48 9b       	lddpc	r11,80007338 <log_init+0x58>
80007316:	48 ac       	lddpc	r12,8000733c <log_init+0x5c>
80007318:	f0 1f 00 0a 	mcall	80007340 <log_init+0x60>
8000731c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000731e:	d8 02       	popm	pc
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	dc d4       	*unknown*
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	53 b8       	stdsp	sp[0xec],r8
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	dc 8c       	*unknown*
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	5b ac       	cp.w	r12,-6
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	64 f4       	ld.w	r4,r2[0x3c]
80007334:	00 00       	add	r0,r0
80007336:	53 c4       	stdsp	sp[0xf0],r4
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	dc d0       	acall	0xcd
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	73 44       	ld.w	r4,r9[0x50]
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	6c 10       	ld.w	r0,r6[0x4]

80007344 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007344:	eb cd 40 f8 	pushm	r3-r7,lr
80007348:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000734a:	48 c7       	lddpc	r7,80007378 <task_log+0x34>
8000734c:	30 05       	mov	r5,0
8000734e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007350:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007354:	0a 99       	mov	r9,r5
80007356:	08 9a       	mov	r10,r4
80007358:	1a 9b       	mov	r11,sp
8000735a:	6e 0c       	ld.w	r12,r7[0x0]
8000735c:	f0 1f 00 08 	mcall	8000737c <task_log+0x38>
80007360:	58 1c       	cp.w	r12,1
80007362:	cf 91       	brne	80007354 <task_log+0x10>
		{
			if( NULL != str)
80007364:	40 0b       	lddsp	r11,sp[0x0]
80007366:	58 0b       	cp.w	r11,0
80007368:	cf 60       	breq	80007354 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000736a:	06 9c       	mov	r12,r3
8000736c:	f0 1f 00 05 	mcall	80007380 <task_log+0x3c>
				vPortFree(str);
80007370:	40 0c       	lddsp	r12,sp[0x0]
80007372:	f0 1f 00 05 	mcall	80007384 <task_log+0x40>
80007376:	ce fb       	rjmp	80007354 <task_log+0x10>
80007378:	00 00       	add	r0,r0
8000737a:	53 c4       	stdsp	sp[0xf0],r4
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	61 90       	ld.w	r0,r0[0x64]
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	5b 5c       	cp.w	r12,-11
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	60 20       	ld.w	r0,r0[0x8]

80007388 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007388:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000738a:	fe 78 10 00 	mov	r8,-61440
8000738e:	30 19       	mov	r9,1
80007390:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007394:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007398:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000739c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000739e:	f0 1f 00 0d 	mcall	800073d0 <main+0x48>
		
	INTC_init_interrupts();
800073a2:	f0 1f 00 0d 	mcall	800073d4 <main+0x4c>
		
	log_init();
800073a6:	f0 1f 00 0d 	mcall	800073d8 <main+0x50>
	log("----start debug----");
800073aa:	48 dc       	lddpc	r12,800073dc <main+0x54>
800073ac:	f0 1f 00 0d 	mcall	800073e0 <main+0x58>
	
	xg_flashc_init();
800073b0:	f0 1f 00 0d 	mcall	800073e4 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073b4:	f0 1f 00 0d 	mcall	800073e8 <main+0x60>
		
	app_init();
800073b8:	f0 1f 00 0d 	mcall	800073ec <main+0x64>
		
	xcmp_init();
800073bc:	f0 1f 00 0d 	mcall	800073f0 <main+0x68>

	local_start_timer();
800073c0:	f0 1f 00 0d 	mcall	800073f4 <main+0x6c>
	
	xg_rtc_init();
800073c4:	f0 1f 00 0d 	mcall	800073f8 <main+0x70>
		
	vTaskStartScheduler();
800073c8:	f0 1f 00 0d 	mcall	800073fc <main+0x74>
	return 0;
	
}
800073cc:	d8 0a       	popm	pc,r12=0
800073ce:	00 00       	add	r0,r0
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	52 2c       	stdsp	sp[0x88],r12
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	54 bc       	stdsp	sp[0x12c],r12
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	72 e0       	ld.w	r0,r9[0x38]
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	dc e4       	*unknown*
800073e0:	80 00       	ld.sh	r0,r0[0x0]
800073e2:	6f d4       	ld.w	r4,r7[0x74]
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	52 c0       	stdsp	sp[0xb0],r0
800073e8:	80 00       	ld.sh	r0,r0[0x0]
800073ea:	51 8c       	stdsp	sp[0x60],r12
800073ec:	80 00       	ld.sh	r0,r0[0x0]
800073ee:	20 3c       	sub	r12,3
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	40 a8       	lddsp	r8,sp[0x28]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	52 00       	stdsp	sp[0x80],r0
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	29 cc       	sub	r12,-100
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	6d f8       	ld.w	r8,r6[0x7c]

80007400 <free>:
80007400:	d4 01       	pushm	lr
80007402:	e0 68 0a 40 	mov	r8,2624
80007406:	18 9b       	mov	r11,r12
80007408:	70 0c       	ld.w	r12,r8[0x0]
8000740a:	e0 a0 1e 61 	rcall	8000b0cc <_free_r>
8000740e:	d8 02       	popm	pc

80007410 <malloc>:
80007410:	d4 01       	pushm	lr
80007412:	e0 68 0a 40 	mov	r8,2624
80007416:	18 9b       	mov	r11,r12
80007418:	70 0c       	ld.w	r12,r8[0x0]
8000741a:	c0 3c       	rcall	80007420 <_malloc_r>
8000741c:	d8 02       	popm	pc
8000741e:	d7 03       	nop

80007420 <_malloc_r>:
80007420:	d4 31       	pushm	r0-r7,lr
80007422:	f6 c8 ff f5 	sub	r8,r11,-11
80007426:	18 95       	mov	r5,r12
80007428:	10 97       	mov	r7,r8
8000742a:	e0 17 ff f8 	andl	r7,0xfff8
8000742e:	59 68       	cp.w	r8,22
80007430:	f9 b7 08 10 	movls	r7,16
80007434:	16 37       	cp.w	r7,r11
80007436:	5f 38       	srlo	r8
80007438:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000743c:	c0 50       	breq	80007446 <_malloc_r+0x26>
8000743e:	30 c8       	mov	r8,12
80007440:	99 38       	st.w	r12[0xc],r8
80007442:	e0 8f 01 fa 	bral	80007836 <_malloc_r+0x416>
80007446:	fe b0 f5 a3 	rcall	80005f8c <__malloc_lock>
8000744a:	e0 47 01 f7 	cp.w	r7,503
8000744e:	e0 8b 00 1d 	brhi	80007488 <_malloc_r+0x68>
80007452:	ee 03 16 03 	lsr	r3,r7,0x3
80007456:	e0 68 05 40 	mov	r8,1344
8000745a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000745e:	70 36       	ld.w	r6,r8[0xc]
80007460:	10 36       	cp.w	r6,r8
80007462:	c0 61       	brne	8000746e <_malloc_r+0x4e>
80007464:	ec c8 ff f8 	sub	r8,r6,-8
80007468:	70 36       	ld.w	r6,r8[0xc]
8000746a:	10 36       	cp.w	r6,r8
8000746c:	c0 c0       	breq	80007484 <_malloc_r+0x64>
8000746e:	6c 18       	ld.w	r8,r6[0x4]
80007470:	e0 18 ff fc 	andl	r8,0xfffc
80007474:	6c 3a       	ld.w	r10,r6[0xc]
80007476:	ec 08 00 09 	add	r9,r6,r8
8000747a:	0a 9c       	mov	r12,r5
8000747c:	6c 28       	ld.w	r8,r6[0x8]
8000747e:	95 28       	st.w	r10[0x8],r8
80007480:	91 3a       	st.w	r8[0xc],r10
80007482:	c4 78       	rjmp	80007510 <_malloc_r+0xf0>
80007484:	2f e3       	sub	r3,-2
80007486:	c4 d8       	rjmp	80007520 <_malloc_r+0x100>
80007488:	ee 03 16 09 	lsr	r3,r7,0x9
8000748c:	c0 41       	brne	80007494 <_malloc_r+0x74>
8000748e:	ee 03 16 03 	lsr	r3,r7,0x3
80007492:	c2 68       	rjmp	800074de <_malloc_r+0xbe>
80007494:	58 43       	cp.w	r3,4
80007496:	e0 8b 00 06 	brhi	800074a2 <_malloc_r+0x82>
8000749a:	ee 03 16 06 	lsr	r3,r7,0x6
8000749e:	2c 83       	sub	r3,-56
800074a0:	c1 f8       	rjmp	800074de <_malloc_r+0xbe>
800074a2:	59 43       	cp.w	r3,20
800074a4:	e0 8b 00 04 	brhi	800074ac <_malloc_r+0x8c>
800074a8:	2a 53       	sub	r3,-91
800074aa:	c1 a8       	rjmp	800074de <_malloc_r+0xbe>
800074ac:	e0 43 00 54 	cp.w	r3,84
800074b0:	e0 8b 00 06 	brhi	800074bc <_malloc_r+0x9c>
800074b4:	ee 03 16 0c 	lsr	r3,r7,0xc
800074b8:	29 23       	sub	r3,-110
800074ba:	c1 28       	rjmp	800074de <_malloc_r+0xbe>
800074bc:	e0 43 01 54 	cp.w	r3,340
800074c0:	e0 8b 00 06 	brhi	800074cc <_malloc_r+0xac>
800074c4:	ee 03 16 0f 	lsr	r3,r7,0xf
800074c8:	28 93       	sub	r3,-119
800074ca:	c0 a8       	rjmp	800074de <_malloc_r+0xbe>
800074cc:	e0 43 05 54 	cp.w	r3,1364
800074d0:	e0 88 00 04 	brls	800074d8 <_malloc_r+0xb8>
800074d4:	37 e3       	mov	r3,126
800074d6:	c0 48       	rjmp	800074de <_malloc_r+0xbe>
800074d8:	ee 03 16 12 	lsr	r3,r7,0x12
800074dc:	28 43       	sub	r3,-124
800074de:	e0 6a 05 40 	mov	r10,1344
800074e2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800074e6:	74 36       	ld.w	r6,r10[0xc]
800074e8:	c1 98       	rjmp	8000751a <_malloc_r+0xfa>
800074ea:	6c 19       	ld.w	r9,r6[0x4]
800074ec:	e0 19 ff fc 	andl	r9,0xfffc
800074f0:	f2 07 01 0b 	sub	r11,r9,r7
800074f4:	58 fb       	cp.w	r11,15
800074f6:	e0 8a 00 04 	brle	800074fe <_malloc_r+0xde>
800074fa:	20 13       	sub	r3,1
800074fc:	c1 18       	rjmp	8000751e <_malloc_r+0xfe>
800074fe:	6c 38       	ld.w	r8,r6[0xc]
80007500:	58 0b       	cp.w	r11,0
80007502:	c0 b5       	brlt	80007518 <_malloc_r+0xf8>
80007504:	6c 2a       	ld.w	r10,r6[0x8]
80007506:	ec 09 00 09 	add	r9,r6,r9
8000750a:	0a 9c       	mov	r12,r5
8000750c:	91 2a       	st.w	r8[0x8],r10
8000750e:	95 38       	st.w	r10[0xc],r8
80007510:	72 18       	ld.w	r8,r9[0x4]
80007512:	a1 a8       	sbr	r8,0x0
80007514:	93 18       	st.w	r9[0x4],r8
80007516:	cb c8       	rjmp	8000768e <_malloc_r+0x26e>
80007518:	10 96       	mov	r6,r8
8000751a:	14 36       	cp.w	r6,r10
8000751c:	ce 71       	brne	800074ea <_malloc_r+0xca>
8000751e:	2f f3       	sub	r3,-1
80007520:	e0 6a 05 40 	mov	r10,1344
80007524:	f4 cc ff f8 	sub	r12,r10,-8
80007528:	78 26       	ld.w	r6,r12[0x8]
8000752a:	18 36       	cp.w	r6,r12
8000752c:	c6 c0       	breq	80007604 <_malloc_r+0x1e4>
8000752e:	6c 19       	ld.w	r9,r6[0x4]
80007530:	e0 19 ff fc 	andl	r9,0xfffc
80007534:	f2 07 01 08 	sub	r8,r9,r7
80007538:	58 f8       	cp.w	r8,15
8000753a:	e0 89 00 8f 	brgt	80007658 <_malloc_r+0x238>
8000753e:	99 3c       	st.w	r12[0xc],r12
80007540:	99 2c       	st.w	r12[0x8],r12
80007542:	58 08       	cp.w	r8,0
80007544:	c0 55       	brlt	8000754e <_malloc_r+0x12e>
80007546:	ec 09 00 09 	add	r9,r6,r9
8000754a:	0a 9c       	mov	r12,r5
8000754c:	ce 2b       	rjmp	80007510 <_malloc_r+0xf0>
8000754e:	e0 49 01 ff 	cp.w	r9,511
80007552:	e0 8b 00 13 	brhi	80007578 <_malloc_r+0x158>
80007556:	a3 99       	lsr	r9,0x3
80007558:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000755c:	70 2b       	ld.w	r11,r8[0x8]
8000755e:	8d 38       	st.w	r6[0xc],r8
80007560:	8d 2b       	st.w	r6[0x8],r11
80007562:	97 36       	st.w	r11[0xc],r6
80007564:	91 26       	st.w	r8[0x8],r6
80007566:	a3 49       	asr	r9,0x2
80007568:	74 18       	ld.w	r8,r10[0x4]
8000756a:	30 1b       	mov	r11,1
8000756c:	f6 09 09 49 	lsl	r9,r11,r9
80007570:	f1 e9 10 09 	or	r9,r8,r9
80007574:	95 19       	st.w	r10[0x4],r9
80007576:	c4 78       	rjmp	80007604 <_malloc_r+0x1e4>
80007578:	f2 0a 16 09 	lsr	r10,r9,0x9
8000757c:	58 4a       	cp.w	r10,4
8000757e:	e0 8b 00 07 	brhi	8000758c <_malloc_r+0x16c>
80007582:	f2 0a 16 06 	lsr	r10,r9,0x6
80007586:	2c 8a       	sub	r10,-56
80007588:	c2 08       	rjmp	800075c8 <_malloc_r+0x1a8>
8000758a:	d7 03       	nop
8000758c:	59 4a       	cp.w	r10,20
8000758e:	e0 8b 00 04 	brhi	80007596 <_malloc_r+0x176>
80007592:	2a 5a       	sub	r10,-91
80007594:	c1 a8       	rjmp	800075c8 <_malloc_r+0x1a8>
80007596:	e0 4a 00 54 	cp.w	r10,84
8000759a:	e0 8b 00 06 	brhi	800075a6 <_malloc_r+0x186>
8000759e:	f2 0a 16 0c 	lsr	r10,r9,0xc
800075a2:	29 2a       	sub	r10,-110
800075a4:	c1 28       	rjmp	800075c8 <_malloc_r+0x1a8>
800075a6:	e0 4a 01 54 	cp.w	r10,340
800075aa:	e0 8b 00 06 	brhi	800075b6 <_malloc_r+0x196>
800075ae:	f2 0a 16 0f 	lsr	r10,r9,0xf
800075b2:	28 9a       	sub	r10,-119
800075b4:	c0 a8       	rjmp	800075c8 <_malloc_r+0x1a8>
800075b6:	e0 4a 05 54 	cp.w	r10,1364
800075ba:	e0 88 00 04 	brls	800075c2 <_malloc_r+0x1a2>
800075be:	37 ea       	mov	r10,126
800075c0:	c0 48       	rjmp	800075c8 <_malloc_r+0x1a8>
800075c2:	f2 0a 16 12 	lsr	r10,r9,0x12
800075c6:	28 4a       	sub	r10,-124
800075c8:	e0 6b 05 40 	mov	r11,1344
800075cc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800075d0:	68 28       	ld.w	r8,r4[0x8]
800075d2:	08 38       	cp.w	r8,r4
800075d4:	c0 e1       	brne	800075f0 <_malloc_r+0x1d0>
800075d6:	76 19       	ld.w	r9,r11[0x4]
800075d8:	a3 4a       	asr	r10,0x2
800075da:	30 1e       	mov	lr,1
800075dc:	fc 0a 09 4a 	lsl	r10,lr,r10
800075e0:	f3 ea 10 0a 	or	r10,r9,r10
800075e4:	10 99       	mov	r9,r8
800075e6:	97 1a       	st.w	r11[0x4],r10
800075e8:	c0 a8       	rjmp	800075fc <_malloc_r+0x1dc>
800075ea:	70 28       	ld.w	r8,r8[0x8]
800075ec:	08 38       	cp.w	r8,r4
800075ee:	c0 60       	breq	800075fa <_malloc_r+0x1da>
800075f0:	70 1a       	ld.w	r10,r8[0x4]
800075f2:	e0 1a ff fc 	andl	r10,0xfffc
800075f6:	14 39       	cp.w	r9,r10
800075f8:	cf 93       	brcs	800075ea <_malloc_r+0x1ca>
800075fa:	70 39       	ld.w	r9,r8[0xc]
800075fc:	8d 39       	st.w	r6[0xc],r9
800075fe:	8d 28       	st.w	r6[0x8],r8
80007600:	91 36       	st.w	r8[0xc],r6
80007602:	93 26       	st.w	r9[0x8],r6
80007604:	e6 08 14 02 	asr	r8,r3,0x2
80007608:	30 1b       	mov	r11,1
8000760a:	e0 64 05 40 	mov	r4,1344
8000760e:	f6 08 09 4b 	lsl	r11,r11,r8
80007612:	68 18       	ld.w	r8,r4[0x4]
80007614:	10 3b       	cp.w	r11,r8
80007616:	e0 8b 00 6b 	brhi	800076ec <_malloc_r+0x2cc>
8000761a:	f7 e8 00 09 	and	r9,r11,r8
8000761e:	c0 b1       	brne	80007634 <_malloc_r+0x214>
80007620:	e0 13 ff fc 	andl	r3,0xfffc
80007624:	a1 7b       	lsl	r11,0x1
80007626:	2f c3       	sub	r3,-4
80007628:	c0 38       	rjmp	8000762e <_malloc_r+0x20e>
8000762a:	2f c3       	sub	r3,-4
8000762c:	a1 7b       	lsl	r11,0x1
8000762e:	f7 e8 00 09 	and	r9,r11,r8
80007632:	cf c0       	breq	8000762a <_malloc_r+0x20a>
80007634:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007638:	06 92       	mov	r2,r3
8000763a:	1c 91       	mov	r1,lr
8000763c:	62 36       	ld.w	r6,r1[0xc]
8000763e:	c2 e8       	rjmp	8000769a <_malloc_r+0x27a>
80007640:	6c 1a       	ld.w	r10,r6[0x4]
80007642:	e0 1a ff fc 	andl	r10,0xfffc
80007646:	f4 07 01 08 	sub	r8,r10,r7
8000764a:	58 f8       	cp.w	r8,15
8000764c:	e0 8a 00 15 	brle	80007676 <_malloc_r+0x256>
80007650:	6c 3a       	ld.w	r10,r6[0xc]
80007652:	6c 29       	ld.w	r9,r6[0x8]
80007654:	95 29       	st.w	r10[0x8],r9
80007656:	93 3a       	st.w	r9[0xc],r10
80007658:	0e 99       	mov	r9,r7
8000765a:	ec 07 00 07 	add	r7,r6,r7
8000765e:	a1 a9       	sbr	r9,0x0
80007660:	99 37       	st.w	r12[0xc],r7
80007662:	99 27       	st.w	r12[0x8],r7
80007664:	8d 19       	st.w	r6[0x4],r9
80007666:	ee 08 09 08 	st.w	r7[r8],r8
8000766a:	8f 2c       	st.w	r7[0x8],r12
8000766c:	8f 3c       	st.w	r7[0xc],r12
8000766e:	a1 a8       	sbr	r8,0x0
80007670:	0a 9c       	mov	r12,r5
80007672:	8f 18       	st.w	r7[0x4],r8
80007674:	c0 d8       	rjmp	8000768e <_malloc_r+0x26e>
80007676:	6c 39       	ld.w	r9,r6[0xc]
80007678:	58 08       	cp.w	r8,0
8000767a:	c0 f5       	brlt	80007698 <_malloc_r+0x278>
8000767c:	ec 0a 00 0a 	add	r10,r6,r10
80007680:	74 18       	ld.w	r8,r10[0x4]
80007682:	a1 a8       	sbr	r8,0x0
80007684:	0a 9c       	mov	r12,r5
80007686:	95 18       	st.w	r10[0x4],r8
80007688:	6c 28       	ld.w	r8,r6[0x8]
8000768a:	93 28       	st.w	r9[0x8],r8
8000768c:	91 39       	st.w	r8[0xc],r9
8000768e:	fe b0 f4 85 	rcall	80005f98 <__malloc_unlock>
80007692:	ec cc ff f8 	sub	r12,r6,-8
80007696:	d8 32       	popm	r0-r7,pc
80007698:	12 96       	mov	r6,r9
8000769a:	02 36       	cp.w	r6,r1
8000769c:	cd 21       	brne	80007640 <_malloc_r+0x220>
8000769e:	2f f2       	sub	r2,-1
800076a0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800076a4:	c0 30       	breq	800076aa <_malloc_r+0x28a>
800076a6:	2f 81       	sub	r1,-8
800076a8:	cc ab       	rjmp	8000763c <_malloc_r+0x21c>
800076aa:	1c 98       	mov	r8,lr
800076ac:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800076b0:	c0 81       	brne	800076c0 <_malloc_r+0x2a0>
800076b2:	68 19       	ld.w	r9,r4[0x4]
800076b4:	f6 08 11 ff 	rsub	r8,r11,-1
800076b8:	f3 e8 00 08 	and	r8,r9,r8
800076bc:	89 18       	st.w	r4[0x4],r8
800076be:	c0 78       	rjmp	800076cc <_malloc_r+0x2ac>
800076c0:	f0 c9 00 08 	sub	r9,r8,8
800076c4:	20 13       	sub	r3,1
800076c6:	70 08       	ld.w	r8,r8[0x0]
800076c8:	12 38       	cp.w	r8,r9
800076ca:	cf 10       	breq	800076ac <_malloc_r+0x28c>
800076cc:	a1 7b       	lsl	r11,0x1
800076ce:	68 18       	ld.w	r8,r4[0x4]
800076d0:	10 3b       	cp.w	r11,r8
800076d2:	e0 8b 00 0d 	brhi	800076ec <_malloc_r+0x2cc>
800076d6:	58 0b       	cp.w	r11,0
800076d8:	c0 a0       	breq	800076ec <_malloc_r+0x2cc>
800076da:	04 93       	mov	r3,r2
800076dc:	c0 38       	rjmp	800076e2 <_malloc_r+0x2c2>
800076de:	2f c3       	sub	r3,-4
800076e0:	a1 7b       	lsl	r11,0x1
800076e2:	f7 e8 00 09 	and	r9,r11,r8
800076e6:	ca 71       	brne	80007634 <_malloc_r+0x214>
800076e8:	cf bb       	rjmp	800076de <_malloc_r+0x2be>
800076ea:	d7 03       	nop
800076ec:	68 23       	ld.w	r3,r4[0x8]
800076ee:	66 12       	ld.w	r2,r3[0x4]
800076f0:	e0 12 ff fc 	andl	r2,0xfffc
800076f4:	0e 32       	cp.w	r2,r7
800076f6:	5f 39       	srlo	r9
800076f8:	e4 07 01 08 	sub	r8,r2,r7
800076fc:	58 f8       	cp.w	r8,15
800076fe:	5f aa       	srle	r10
80007700:	f5 e9 10 09 	or	r9,r10,r9
80007704:	e0 80 00 9a 	breq	80007838 <_malloc_r+0x418>
80007708:	e0 68 0d 68 	mov	r8,3432
8000770c:	70 01       	ld.w	r1,r8[0x0]
8000770e:	e0 68 09 4c 	mov	r8,2380
80007712:	2f 01       	sub	r1,-16
80007714:	70 08       	ld.w	r8,r8[0x0]
80007716:	0e 01       	add	r1,r7
80007718:	5b f8       	cp.w	r8,-1
8000771a:	c0 40       	breq	80007722 <_malloc_r+0x302>
8000771c:	28 11       	sub	r1,-127
8000771e:	e0 11 ff 80 	andl	r1,0xff80
80007722:	02 9b       	mov	r11,r1
80007724:	0a 9c       	mov	r12,r5
80007726:	e0 a0 02 a5 	rcall	80007c70 <_sbrk_r>
8000772a:	18 96       	mov	r6,r12
8000772c:	5b fc       	cp.w	r12,-1
8000772e:	c7 50       	breq	80007818 <_malloc_r+0x3f8>
80007730:	e6 02 00 08 	add	r8,r3,r2
80007734:	10 3c       	cp.w	r12,r8
80007736:	c0 32       	brcc	8000773c <_malloc_r+0x31c>
80007738:	08 33       	cp.w	r3,r4
8000773a:	c6 f1       	brne	80007818 <_malloc_r+0x3f8>
8000773c:	e0 6a 0d 6c 	mov	r10,3436
80007740:	74 09       	ld.w	r9,r10[0x0]
80007742:	e2 09 00 09 	add	r9,r1,r9
80007746:	95 09       	st.w	r10[0x0],r9
80007748:	10 36       	cp.w	r6,r8
8000774a:	c0 a1       	brne	8000775e <_malloc_r+0x33e>
8000774c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007750:	c0 71       	brne	8000775e <_malloc_r+0x33e>
80007752:	e2 02 00 02 	add	r2,r1,r2
80007756:	68 28       	ld.w	r8,r4[0x8]
80007758:	a1 a2       	sbr	r2,0x0
8000775a:	91 12       	st.w	r8[0x4],r2
8000775c:	c4 f8       	rjmp	800077fa <_malloc_r+0x3da>
8000775e:	e0 6a 09 4c 	mov	r10,2380
80007762:	74 0b       	ld.w	r11,r10[0x0]
80007764:	5b fb       	cp.w	r11,-1
80007766:	c0 31       	brne	8000776c <_malloc_r+0x34c>
80007768:	95 06       	st.w	r10[0x0],r6
8000776a:	c0 78       	rjmp	80007778 <_malloc_r+0x358>
8000776c:	ec 09 00 09 	add	r9,r6,r9
80007770:	e0 6a 0d 6c 	mov	r10,3436
80007774:	10 19       	sub	r9,r8
80007776:	95 09       	st.w	r10[0x0],r9
80007778:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000777c:	f0 09 11 08 	rsub	r9,r8,8
80007780:	58 08       	cp.w	r8,0
80007782:	f2 08 17 10 	movne	r8,r9
80007786:	ed d8 e1 06 	addne	r6,r6,r8
8000778a:	28 08       	sub	r8,-128
8000778c:	ec 01 00 01 	add	r1,r6,r1
80007790:	0a 9c       	mov	r12,r5
80007792:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007796:	f0 01 01 01 	sub	r1,r8,r1
8000779a:	02 9b       	mov	r11,r1
8000779c:	e0 a0 02 6a 	rcall	80007c70 <_sbrk_r>
800077a0:	e0 68 0d 6c 	mov	r8,3436
800077a4:	5b fc       	cp.w	r12,-1
800077a6:	ec 0c 17 00 	moveq	r12,r6
800077aa:	f9 b1 00 00 	moveq	r1,0
800077ae:	70 09       	ld.w	r9,r8[0x0]
800077b0:	0c 1c       	sub	r12,r6
800077b2:	89 26       	st.w	r4[0x8],r6
800077b4:	02 0c       	add	r12,r1
800077b6:	12 01       	add	r1,r9
800077b8:	a1 ac       	sbr	r12,0x0
800077ba:	91 01       	st.w	r8[0x0],r1
800077bc:	8d 1c       	st.w	r6[0x4],r12
800077be:	08 33       	cp.w	r3,r4
800077c0:	c1 d0       	breq	800077fa <_malloc_r+0x3da>
800077c2:	58 f2       	cp.w	r2,15
800077c4:	e0 8b 00 05 	brhi	800077ce <_malloc_r+0x3ae>
800077c8:	30 18       	mov	r8,1
800077ca:	8d 18       	st.w	r6[0x4],r8
800077cc:	c2 68       	rjmp	80007818 <_malloc_r+0x3f8>
800077ce:	30 59       	mov	r9,5
800077d0:	20 c2       	sub	r2,12
800077d2:	e0 12 ff f8 	andl	r2,0xfff8
800077d6:	e6 02 00 08 	add	r8,r3,r2
800077da:	91 29       	st.w	r8[0x8],r9
800077dc:	91 19       	st.w	r8[0x4],r9
800077de:	66 18       	ld.w	r8,r3[0x4]
800077e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077e4:	e5 e8 10 08 	or	r8,r2,r8
800077e8:	87 18       	st.w	r3[0x4],r8
800077ea:	58 f2       	cp.w	r2,15
800077ec:	e0 88 00 07 	brls	800077fa <_malloc_r+0x3da>
800077f0:	e6 cb ff f8 	sub	r11,r3,-8
800077f4:	0a 9c       	mov	r12,r5
800077f6:	e0 a0 1c 6b 	rcall	8000b0cc <_free_r>
800077fa:	e0 69 0d 64 	mov	r9,3428
800077fe:	72 0a       	ld.w	r10,r9[0x0]
80007800:	e0 68 0d 6c 	mov	r8,3436
80007804:	70 08       	ld.w	r8,r8[0x0]
80007806:	14 38       	cp.w	r8,r10
80007808:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000780c:	e0 69 0d 60 	mov	r9,3424
80007810:	72 0a       	ld.w	r10,r9[0x0]
80007812:	14 38       	cp.w	r8,r10
80007814:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007818:	68 28       	ld.w	r8,r4[0x8]
8000781a:	70 18       	ld.w	r8,r8[0x4]
8000781c:	e0 18 ff fc 	andl	r8,0xfffc
80007820:	0e 38       	cp.w	r8,r7
80007822:	5f 39       	srlo	r9
80007824:	0e 18       	sub	r8,r7
80007826:	58 f8       	cp.w	r8,15
80007828:	5f aa       	srle	r10
8000782a:	f5 e9 10 09 	or	r9,r10,r9
8000782e:	c0 50       	breq	80007838 <_malloc_r+0x418>
80007830:	0a 9c       	mov	r12,r5
80007832:	fe b0 f3 b3 	rcall	80005f98 <__malloc_unlock>
80007836:	d8 3a       	popm	r0-r7,pc,r12=0
80007838:	68 26       	ld.w	r6,r4[0x8]
8000783a:	a1 a8       	sbr	r8,0x0
8000783c:	0e 99       	mov	r9,r7
8000783e:	a1 a9       	sbr	r9,0x0
80007840:	8d 19       	st.w	r6[0x4],r9
80007842:	ec 07 00 07 	add	r7,r6,r7
80007846:	0a 9c       	mov	r12,r5
80007848:	89 27       	st.w	r4[0x8],r7
8000784a:	8f 18       	st.w	r7[0x4],r8
8000784c:	fe b0 f3 a6 	rcall	80005f98 <__malloc_unlock>
80007850:	ec cc ff f8 	sub	r12,r6,-8
80007854:	d8 32       	popm	r0-r7,pc
80007856:	d7 03       	nop

80007858 <memcpy>:
80007858:	58 8a       	cp.w	r10,8
8000785a:	c2 f5       	brlt	800078b8 <memcpy+0x60>
8000785c:	f9 eb 10 09 	or	r9,r12,r11
80007860:	e2 19 00 03 	andl	r9,0x3,COH
80007864:	e0 81 00 97 	brne	80007992 <memcpy+0x13a>
80007868:	e0 4a 00 20 	cp.w	r10,32
8000786c:	c3 b4       	brge	800078e2 <memcpy+0x8a>
8000786e:	f4 08 14 02 	asr	r8,r10,0x2
80007872:	f0 09 11 08 	rsub	r9,r8,8
80007876:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000787a:	76 69       	ld.w	r9,r11[0x18]
8000787c:	99 69       	st.w	r12[0x18],r9
8000787e:	76 59       	ld.w	r9,r11[0x14]
80007880:	99 59       	st.w	r12[0x14],r9
80007882:	76 49       	ld.w	r9,r11[0x10]
80007884:	99 49       	st.w	r12[0x10],r9
80007886:	76 39       	ld.w	r9,r11[0xc]
80007888:	99 39       	st.w	r12[0xc],r9
8000788a:	76 29       	ld.w	r9,r11[0x8]
8000788c:	99 29       	st.w	r12[0x8],r9
8000788e:	76 19       	ld.w	r9,r11[0x4]
80007890:	99 19       	st.w	r12[0x4],r9
80007892:	76 09       	ld.w	r9,r11[0x0]
80007894:	99 09       	st.w	r12[0x0],r9
80007896:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000789a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000789e:	e0 1a 00 03 	andl	r10,0x3
800078a2:	f4 0a 11 04 	rsub	r10,r10,4
800078a6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078aa:	17 a9       	ld.ub	r9,r11[0x2]
800078ac:	b0 a9       	st.b	r8[0x2],r9
800078ae:	17 99       	ld.ub	r9,r11[0x1]
800078b0:	b0 99       	st.b	r8[0x1],r9
800078b2:	17 89       	ld.ub	r9,r11[0x0]
800078b4:	b0 89       	st.b	r8[0x0],r9
800078b6:	5e fc       	retal	r12
800078b8:	f4 0a 11 09 	rsub	r10,r10,9
800078bc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078c0:	17 f9       	ld.ub	r9,r11[0x7]
800078c2:	b8 f9       	st.b	r12[0x7],r9
800078c4:	17 e9       	ld.ub	r9,r11[0x6]
800078c6:	b8 e9       	st.b	r12[0x6],r9
800078c8:	17 d9       	ld.ub	r9,r11[0x5]
800078ca:	b8 d9       	st.b	r12[0x5],r9
800078cc:	17 c9       	ld.ub	r9,r11[0x4]
800078ce:	b8 c9       	st.b	r12[0x4],r9
800078d0:	17 b9       	ld.ub	r9,r11[0x3]
800078d2:	b8 b9       	st.b	r12[0x3],r9
800078d4:	17 a9       	ld.ub	r9,r11[0x2]
800078d6:	b8 a9       	st.b	r12[0x2],r9
800078d8:	17 99       	ld.ub	r9,r11[0x1]
800078da:	b8 99       	st.b	r12[0x1],r9
800078dc:	17 89       	ld.ub	r9,r11[0x0]
800078de:	b8 89       	st.b	r12[0x0],r9
800078e0:	5e fc       	retal	r12
800078e2:	eb cd 40 c0 	pushm	r6-r7,lr
800078e6:	18 99       	mov	r9,r12
800078e8:	22 0a       	sub	r10,32
800078ea:	b7 07       	ld.d	r6,r11++
800078ec:	b3 26       	st.d	r9++,r6
800078ee:	b7 07       	ld.d	r6,r11++
800078f0:	b3 26       	st.d	r9++,r6
800078f2:	b7 07       	ld.d	r6,r11++
800078f4:	b3 26       	st.d	r9++,r6
800078f6:	b7 07       	ld.d	r6,r11++
800078f8:	b3 26       	st.d	r9++,r6
800078fa:	22 0a       	sub	r10,32
800078fc:	cf 74       	brge	800078ea <memcpy+0x92>
800078fe:	2f 0a       	sub	r10,-16
80007900:	c0 65       	brlt	8000790c <memcpy+0xb4>
80007902:	b7 07       	ld.d	r6,r11++
80007904:	b3 26       	st.d	r9++,r6
80007906:	b7 07       	ld.d	r6,r11++
80007908:	b3 26       	st.d	r9++,r6
8000790a:	21 0a       	sub	r10,16
8000790c:	5c 3a       	neg	r10
8000790e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007912:	d7 03       	nop
80007914:	d7 03       	nop
80007916:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000791a:	f3 66 00 0e 	st.b	r9[14],r6
8000791e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007922:	f3 66 00 0d 	st.b	r9[13],r6
80007926:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000792a:	f3 66 00 0c 	st.b	r9[12],r6
8000792e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007932:	f3 66 00 0b 	st.b	r9[11],r6
80007936:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000793a:	f3 66 00 0a 	st.b	r9[10],r6
8000793e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007942:	f3 66 00 09 	st.b	r9[9],r6
80007946:	f7 36 00 08 	ld.ub	r6,r11[8]
8000794a:	f3 66 00 08 	st.b	r9[8],r6
8000794e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007952:	f3 66 00 07 	st.b	r9[7],r6
80007956:	f7 36 00 06 	ld.ub	r6,r11[6]
8000795a:	f3 66 00 06 	st.b	r9[6],r6
8000795e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007962:	f3 66 00 05 	st.b	r9[5],r6
80007966:	f7 36 00 04 	ld.ub	r6,r11[4]
8000796a:	f3 66 00 04 	st.b	r9[4],r6
8000796e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007972:	f3 66 00 03 	st.b	r9[3],r6
80007976:	f7 36 00 02 	ld.ub	r6,r11[2]
8000797a:	f3 66 00 02 	st.b	r9[2],r6
8000797e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007982:	f3 66 00 01 	st.b	r9[1],r6
80007986:	f7 36 00 00 	ld.ub	r6,r11[0]
8000798a:	f3 66 00 00 	st.b	r9[0],r6
8000798e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007992:	20 1a       	sub	r10,1
80007994:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007998:	f8 0a 0b 09 	st.b	r12[r10],r9
8000799c:	cf b1       	brne	80007992 <memcpy+0x13a>
8000799e:	5e fc       	retal	r12

800079a0 <memset>:
800079a0:	18 98       	mov	r8,r12
800079a2:	c0 38       	rjmp	800079a8 <memset+0x8>
800079a4:	10 cb       	st.b	r8++,r11
800079a6:	20 1a       	sub	r10,1
800079a8:	58 0a       	cp.w	r10,0
800079aa:	cf d1       	brne	800079a4 <memset+0x4>
800079ac:	5e fc       	retal	r12
800079ae:	d7 03       	nop

800079b0 <_realloc_r>:
800079b0:	d4 31       	pushm	r0-r7,lr
800079b2:	20 1d       	sub	sp,4
800079b4:	16 94       	mov	r4,r11
800079b6:	18 92       	mov	r2,r12
800079b8:	14 9b       	mov	r11,r10
800079ba:	58 04       	cp.w	r4,0
800079bc:	c0 51       	brne	800079c6 <_realloc_r+0x16>
800079be:	fe b0 fd 31 	rcall	80007420 <_malloc_r>
800079c2:	18 95       	mov	r5,r12
800079c4:	c5 39       	rjmp	80007c6a <_realloc_r+0x2ba>
800079c6:	50 0a       	stdsp	sp[0x0],r10
800079c8:	fe b0 f2 e2 	rcall	80005f8c <__malloc_lock>
800079cc:	40 0b       	lddsp	r11,sp[0x0]
800079ce:	f6 c8 ff f5 	sub	r8,r11,-11
800079d2:	e8 c1 00 08 	sub	r1,r4,8
800079d6:	10 96       	mov	r6,r8
800079d8:	62 1c       	ld.w	r12,r1[0x4]
800079da:	e0 16 ff f8 	andl	r6,0xfff8
800079de:	59 68       	cp.w	r8,22
800079e0:	f9 b6 08 10 	movls	r6,16
800079e4:	16 36       	cp.w	r6,r11
800079e6:	5f 38       	srlo	r8
800079e8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800079ec:	c0 50       	breq	800079f6 <_realloc_r+0x46>
800079ee:	30 c8       	mov	r8,12
800079f0:	30 05       	mov	r5,0
800079f2:	85 38       	st.w	r2[0xc],r8
800079f4:	c3 b9       	rjmp	80007c6a <_realloc_r+0x2ba>
800079f6:	18 90       	mov	r0,r12
800079f8:	e0 10 ff fc 	andl	r0,0xfffc
800079fc:	0c 30       	cp.w	r0,r6
800079fe:	e0 84 01 0b 	brge	80007c14 <_realloc_r+0x264>
80007a02:	e0 68 05 40 	mov	r8,1344
80007a06:	e2 00 00 09 	add	r9,r1,r0
80007a0a:	70 25       	ld.w	r5,r8[0x8]
80007a0c:	0a 39       	cp.w	r9,r5
80007a0e:	c0 90       	breq	80007a20 <_realloc_r+0x70>
80007a10:	72 1a       	ld.w	r10,r9[0x4]
80007a12:	a1 ca       	cbr	r10,0x0
80007a14:	f2 0a 00 0a 	add	r10,r9,r10
80007a18:	74 1a       	ld.w	r10,r10[0x4]
80007a1a:	ed ba 00 00 	bld	r10,0x0
80007a1e:	c2 20       	breq	80007a62 <_realloc_r+0xb2>
80007a20:	72 1a       	ld.w	r10,r9[0x4]
80007a22:	e0 1a ff fc 	andl	r10,0xfffc
80007a26:	f4 00 00 03 	add	r3,r10,r0
80007a2a:	0a 39       	cp.w	r9,r5
80007a2c:	c1 31       	brne	80007a52 <_realloc_r+0xa2>
80007a2e:	ec c7 ff f0 	sub	r7,r6,-16
80007a32:	0e 33       	cp.w	r3,r7
80007a34:	c1 95       	brlt	80007a66 <_realloc_r+0xb6>
80007a36:	e2 06 00 09 	add	r9,r1,r6
80007a3a:	0c 13       	sub	r3,r6
80007a3c:	a1 a3       	sbr	r3,0x0
80007a3e:	93 13       	st.w	r9[0x4],r3
80007a40:	91 29       	st.w	r8[0x8],r9
80007a42:	04 9c       	mov	r12,r2
80007a44:	62 18       	ld.w	r8,r1[0x4]
80007a46:	08 95       	mov	r5,r4
80007a48:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a4c:	10 46       	or	r6,r8
80007a4e:	83 16       	st.w	r1[0x4],r6
80007a50:	c0 b9       	rjmp	80007c66 <_realloc_r+0x2b6>
80007a52:	0c 33       	cp.w	r3,r6
80007a54:	c0 95       	brlt	80007a66 <_realloc_r+0xb6>
80007a56:	72 28       	ld.w	r8,r9[0x8]
80007a58:	02 97       	mov	r7,r1
80007a5a:	72 39       	ld.w	r9,r9[0xc]
80007a5c:	93 28       	st.w	r9[0x8],r8
80007a5e:	91 39       	st.w	r8[0xc],r9
80007a60:	cd c8       	rjmp	80007c18 <_realloc_r+0x268>
80007a62:	30 0a       	mov	r10,0
80007a64:	14 99       	mov	r9,r10
80007a66:	ed bc 00 00 	bld	r12,0x0
80007a6a:	e0 80 00 95 	breq	80007b94 <_realloc_r+0x1e4>
80007a6e:	62 07       	ld.w	r7,r1[0x0]
80007a70:	e2 07 01 07 	sub	r7,r1,r7
80007a74:	6e 1c       	ld.w	r12,r7[0x4]
80007a76:	e0 1c ff fc 	andl	r12,0xfffc
80007a7a:	58 09       	cp.w	r9,0
80007a7c:	c5 60       	breq	80007b28 <_realloc_r+0x178>
80007a7e:	f8 00 00 03 	add	r3,r12,r0
80007a82:	0a 39       	cp.w	r9,r5
80007a84:	c4 81       	brne	80007b14 <_realloc_r+0x164>
80007a86:	14 03       	add	r3,r10
80007a88:	ec c9 ff f0 	sub	r9,r6,-16
80007a8c:	12 33       	cp.w	r3,r9
80007a8e:	c4 d5       	brlt	80007b28 <_realloc_r+0x178>
80007a90:	6e 3a       	ld.w	r10,r7[0xc]
80007a92:	6e 29       	ld.w	r9,r7[0x8]
80007a94:	95 29       	st.w	r10[0x8],r9
80007a96:	93 3a       	st.w	r9[0xc],r10
80007a98:	ee c5 ff f8 	sub	r5,r7,-8
80007a9c:	e0 ca 00 04 	sub	r10,r0,4
80007aa0:	e0 4a 00 24 	cp.w	r10,36
80007aa4:	e0 8b 00 25 	brhi	80007aee <_realloc_r+0x13e>
80007aa8:	0a 99       	mov	r9,r5
80007aaa:	59 3a       	cp.w	r10,19
80007aac:	e0 88 00 1a 	brls	80007ae0 <_realloc_r+0x130>
80007ab0:	09 09       	ld.w	r9,r4++
80007ab2:	8b 09       	st.w	r5[0x0],r9
80007ab4:	09 09       	ld.w	r9,r4++
80007ab6:	8f 39       	st.w	r7[0xc],r9
80007ab8:	ee c9 ff f0 	sub	r9,r7,-16
80007abc:	59 ba       	cp.w	r10,27
80007abe:	e0 88 00 11 	brls	80007ae0 <_realloc_r+0x130>
80007ac2:	09 0b       	ld.w	r11,r4++
80007ac4:	93 0b       	st.w	r9[0x0],r11
80007ac6:	09 09       	ld.w	r9,r4++
80007ac8:	8f 59       	st.w	r7[0x14],r9
80007aca:	ee c9 ff e8 	sub	r9,r7,-24
80007ace:	e0 4a 00 24 	cp.w	r10,36
80007ad2:	c0 71       	brne	80007ae0 <_realloc_r+0x130>
80007ad4:	09 0a       	ld.w	r10,r4++
80007ad6:	93 0a       	st.w	r9[0x0],r10
80007ad8:	ee c9 ff e0 	sub	r9,r7,-32
80007adc:	09 0a       	ld.w	r10,r4++
80007ade:	8f 7a       	st.w	r7[0x1c],r10
80007ae0:	09 0a       	ld.w	r10,r4++
80007ae2:	12 aa       	st.w	r9++,r10
80007ae4:	68 0a       	ld.w	r10,r4[0x0]
80007ae6:	93 0a       	st.w	r9[0x0],r10
80007ae8:	68 1a       	ld.w	r10,r4[0x4]
80007aea:	93 1a       	st.w	r9[0x4],r10
80007aec:	c0 78       	rjmp	80007afa <_realloc_r+0x14a>
80007aee:	50 08       	stdsp	sp[0x0],r8
80007af0:	08 9b       	mov	r11,r4
80007af2:	0a 9c       	mov	r12,r5
80007af4:	e0 a0 1d 8f 	rcall	8000b612 <memmove>
80007af8:	40 08       	lddsp	r8,sp[0x0]
80007afa:	ee 06 00 09 	add	r9,r7,r6
80007afe:	0c 13       	sub	r3,r6
80007b00:	a1 a3       	sbr	r3,0x0
80007b02:	93 13       	st.w	r9[0x4],r3
80007b04:	91 29       	st.w	r8[0x8],r9
80007b06:	04 9c       	mov	r12,r2
80007b08:	6e 18       	ld.w	r8,r7[0x4]
80007b0a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b0e:	10 46       	or	r6,r8
80007b10:	8f 16       	st.w	r7[0x4],r6
80007b12:	ca a8       	rjmp	80007c66 <_realloc_r+0x2b6>
80007b14:	14 03       	add	r3,r10
80007b16:	0c 33       	cp.w	r3,r6
80007b18:	c0 85       	brlt	80007b28 <_realloc_r+0x178>
80007b1a:	72 28       	ld.w	r8,r9[0x8]
80007b1c:	72 39       	ld.w	r9,r9[0xc]
80007b1e:	93 28       	st.w	r9[0x8],r8
80007b20:	91 39       	st.w	r8[0xc],r9
80007b22:	6e 28       	ld.w	r8,r7[0x8]
80007b24:	6e 39       	ld.w	r9,r7[0xc]
80007b26:	c0 78       	rjmp	80007b34 <_realloc_r+0x184>
80007b28:	f8 00 00 03 	add	r3,r12,r0
80007b2c:	0c 33       	cp.w	r3,r6
80007b2e:	c3 35       	brlt	80007b94 <_realloc_r+0x1e4>
80007b30:	6e 39       	ld.w	r9,r7[0xc]
80007b32:	6e 28       	ld.w	r8,r7[0x8]
80007b34:	93 28       	st.w	r9[0x8],r8
80007b36:	91 39       	st.w	r8[0xc],r9
80007b38:	e0 ca 00 04 	sub	r10,r0,4
80007b3c:	ee cc ff f8 	sub	r12,r7,-8
80007b40:	e0 4a 00 24 	cp.w	r10,36
80007b44:	e0 8b 00 24 	brhi	80007b8c <_realloc_r+0x1dc>
80007b48:	59 3a       	cp.w	r10,19
80007b4a:	e0 88 00 1a 	brls	80007b7e <_realloc_r+0x1ce>
80007b4e:	09 08       	ld.w	r8,r4++
80007b50:	99 08       	st.w	r12[0x0],r8
80007b52:	09 08       	ld.w	r8,r4++
80007b54:	8f 38       	st.w	r7[0xc],r8
80007b56:	ee cc ff f0 	sub	r12,r7,-16
80007b5a:	59 ba       	cp.w	r10,27
80007b5c:	e0 88 00 11 	brls	80007b7e <_realloc_r+0x1ce>
80007b60:	09 08       	ld.w	r8,r4++
80007b62:	99 08       	st.w	r12[0x0],r8
80007b64:	09 08       	ld.w	r8,r4++
80007b66:	8f 58       	st.w	r7[0x14],r8
80007b68:	ee cc ff e8 	sub	r12,r7,-24
80007b6c:	e0 4a 00 24 	cp.w	r10,36
80007b70:	c0 71       	brne	80007b7e <_realloc_r+0x1ce>
80007b72:	09 08       	ld.w	r8,r4++
80007b74:	99 08       	st.w	r12[0x0],r8
80007b76:	ee cc ff e0 	sub	r12,r7,-32
80007b7a:	09 08       	ld.w	r8,r4++
80007b7c:	8f 78       	st.w	r7[0x1c],r8
80007b7e:	09 08       	ld.w	r8,r4++
80007b80:	18 a8       	st.w	r12++,r8
80007b82:	68 08       	ld.w	r8,r4[0x0]
80007b84:	99 08       	st.w	r12[0x0],r8
80007b86:	68 18       	ld.w	r8,r4[0x4]
80007b88:	99 18       	st.w	r12[0x4],r8
80007b8a:	c4 78       	rjmp	80007c18 <_realloc_r+0x268>
80007b8c:	08 9b       	mov	r11,r4
80007b8e:	e0 a0 1d 42 	rcall	8000b612 <memmove>
80007b92:	c4 38       	rjmp	80007c18 <_realloc_r+0x268>
80007b94:	04 9c       	mov	r12,r2
80007b96:	fe b0 fc 45 	rcall	80007420 <_malloc_r>
80007b9a:	18 95       	mov	r5,r12
80007b9c:	c3 a0       	breq	80007c10 <_realloc_r+0x260>
80007b9e:	62 18       	ld.w	r8,r1[0x4]
80007ba0:	f8 c9 00 08 	sub	r9,r12,8
80007ba4:	a1 c8       	cbr	r8,0x0
80007ba6:	e2 08 00 08 	add	r8,r1,r8
80007baa:	10 39       	cp.w	r9,r8
80007bac:	c0 71       	brne	80007bba <_realloc_r+0x20a>
80007bae:	72 13       	ld.w	r3,r9[0x4]
80007bb0:	02 97       	mov	r7,r1
80007bb2:	e0 13 ff fc 	andl	r3,0xfffc
80007bb6:	00 03       	add	r3,r0
80007bb8:	c3 08       	rjmp	80007c18 <_realloc_r+0x268>
80007bba:	e0 ca 00 04 	sub	r10,r0,4
80007bbe:	e0 4a 00 24 	cp.w	r10,36
80007bc2:	e0 8b 00 20 	brhi	80007c02 <_realloc_r+0x252>
80007bc6:	08 99       	mov	r9,r4
80007bc8:	18 98       	mov	r8,r12
80007bca:	59 3a       	cp.w	r10,19
80007bcc:	e0 88 00 14 	brls	80007bf4 <_realloc_r+0x244>
80007bd0:	13 0b       	ld.w	r11,r9++
80007bd2:	10 ab       	st.w	r8++,r11
80007bd4:	13 0b       	ld.w	r11,r9++
80007bd6:	10 ab       	st.w	r8++,r11
80007bd8:	59 ba       	cp.w	r10,27
80007bda:	e0 88 00 0d 	brls	80007bf4 <_realloc_r+0x244>
80007bde:	13 0b       	ld.w	r11,r9++
80007be0:	10 ab       	st.w	r8++,r11
80007be2:	13 0b       	ld.w	r11,r9++
80007be4:	10 ab       	st.w	r8++,r11
80007be6:	e0 4a 00 24 	cp.w	r10,36
80007bea:	c0 51       	brne	80007bf4 <_realloc_r+0x244>
80007bec:	13 0a       	ld.w	r10,r9++
80007bee:	10 aa       	st.w	r8++,r10
80007bf0:	13 0a       	ld.w	r10,r9++
80007bf2:	10 aa       	st.w	r8++,r10
80007bf4:	13 0a       	ld.w	r10,r9++
80007bf6:	10 aa       	st.w	r8++,r10
80007bf8:	72 0a       	ld.w	r10,r9[0x0]
80007bfa:	91 0a       	st.w	r8[0x0],r10
80007bfc:	72 19       	ld.w	r9,r9[0x4]
80007bfe:	91 19       	st.w	r8[0x4],r9
80007c00:	c0 48       	rjmp	80007c08 <_realloc_r+0x258>
80007c02:	08 9b       	mov	r11,r4
80007c04:	e0 a0 1d 07 	rcall	8000b612 <memmove>
80007c08:	08 9b       	mov	r11,r4
80007c0a:	04 9c       	mov	r12,r2
80007c0c:	e0 a0 1a 60 	rcall	8000b0cc <_free_r>
80007c10:	04 9c       	mov	r12,r2
80007c12:	c2 a8       	rjmp	80007c66 <_realloc_r+0x2b6>
80007c14:	00 93       	mov	r3,r0
80007c16:	02 97       	mov	r7,r1
80007c18:	e6 06 01 09 	sub	r9,r3,r6
80007c1c:	6e 18       	ld.w	r8,r7[0x4]
80007c1e:	58 f9       	cp.w	r9,15
80007c20:	e0 88 00 16 	brls	80007c4c <_realloc_r+0x29c>
80007c24:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c28:	ed e8 10 08 	or	r8,r6,r8
80007c2c:	8f 18       	st.w	r7[0x4],r8
80007c2e:	12 98       	mov	r8,r9
80007c30:	a1 a8       	sbr	r8,0x0
80007c32:	ee 06 00 0b 	add	r11,r7,r6
80007c36:	f6 09 00 09 	add	r9,r11,r9
80007c3a:	97 18       	st.w	r11[0x4],r8
80007c3c:	72 18       	ld.w	r8,r9[0x4]
80007c3e:	a1 a8       	sbr	r8,0x0
80007c40:	2f 8b       	sub	r11,-8
80007c42:	93 18       	st.w	r9[0x4],r8
80007c44:	04 9c       	mov	r12,r2
80007c46:	e0 a0 1a 43 	rcall	8000b0cc <_free_r>
80007c4a:	c0 b8       	rjmp	80007c60 <_realloc_r+0x2b0>
80007c4c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c50:	e7 e8 10 08 	or	r8,r3,r8
80007c54:	8f 18       	st.w	r7[0x4],r8
80007c56:	ee 03 00 03 	add	r3,r7,r3
80007c5a:	66 18       	ld.w	r8,r3[0x4]
80007c5c:	a1 a8       	sbr	r8,0x0
80007c5e:	87 18       	st.w	r3[0x4],r8
80007c60:	04 9c       	mov	r12,r2
80007c62:	ee c5 ff f8 	sub	r5,r7,-8
80007c66:	fe b0 f1 99 	rcall	80005f98 <__malloc_unlock>
80007c6a:	0a 9c       	mov	r12,r5
80007c6c:	2f fd       	sub	sp,-4
80007c6e:	d8 32       	popm	r0-r7,pc

80007c70 <_sbrk_r>:
80007c70:	d4 21       	pushm	r4-r7,lr
80007c72:	30 08       	mov	r8,0
80007c74:	18 97       	mov	r7,r12
80007c76:	e0 66 53 c8 	mov	r6,21448
80007c7a:	16 9c       	mov	r12,r11
80007c7c:	8d 08       	st.w	r6[0x0],r8
80007c7e:	c8 5c       	rcall	80007d88 <_sbrk>
80007c80:	5b fc       	cp.w	r12,-1
80007c82:	c0 51       	brne	80007c8c <_sbrk_r+0x1c>
80007c84:	6c 08       	ld.w	r8,r6[0x0]
80007c86:	58 08       	cp.w	r8,0
80007c88:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c8c:	d8 22       	popm	r4-r7,pc
80007c8e:	d7 03       	nop

80007c90 <sprintf>:
80007c90:	d4 01       	pushm	lr
80007c92:	21 7d       	sub	sp,92
80007c94:	e0 68 ff ff 	mov	r8,65535
80007c98:	ea 18 7f ff 	orh	r8,0x7fff
80007c9c:	50 58       	stdsp	sp[0x14],r8
80007c9e:	50 28       	stdsp	sp[0x8],r8
80007ca0:	e0 68 02 08 	mov	r8,520
80007ca4:	ba 68       	st.h	sp[0xc],r8
80007ca6:	3f f8       	mov	r8,-1
80007ca8:	ba 78       	st.h	sp[0xe],r8
80007caa:	e0 68 0a 40 	mov	r8,2624
80007cae:	50 4c       	stdsp	sp[0x10],r12
80007cb0:	16 9a       	mov	r10,r11
80007cb2:	50 0c       	stdsp	sp[0x0],r12
80007cb4:	fa c9 ff a0 	sub	r9,sp,-96
80007cb8:	70 0c       	ld.w	r12,r8[0x0]
80007cba:	1a 9b       	mov	r11,sp
80007cbc:	e0 a0 02 1a 	rcall	800080f0 <_vfprintf_r>
80007cc0:	30 09       	mov	r9,0
80007cc2:	40 08       	lddsp	r8,sp[0x0]
80007cc4:	b0 89       	st.b	r8[0x0],r9
80007cc6:	2e 9d       	sub	sp,-92
80007cc8:	d8 02       	popm	pc
80007cca:	d7 03       	nop

80007ccc <strncpy>:
80007ccc:	30 08       	mov	r8,0
80007cce:	10 3a       	cp.w	r10,r8
80007cd0:	5e 0c       	reteq	r12
80007cd2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007cd6:	f8 08 0b 09 	st.b	r12[r8],r9
80007cda:	2f f8       	sub	r8,-1
80007cdc:	58 09       	cp.w	r9,0
80007cde:	cf 81       	brne	80007cce <strncpy+0x2>
80007ce0:	10 3a       	cp.w	r10,r8
80007ce2:	5e 0c       	reteq	r12
80007ce4:	f8 08 0b 09 	st.b	r12[r8],r9
80007ce8:	2f f8       	sub	r8,-1
80007cea:	cf bb       	rjmp	80007ce0 <strncpy+0x14>

80007cec <_close>:
80007cec:	30 28       	mov	r8,2
80007cee:	d6 73       	breakpoint
80007cf0:	3f fc       	mov	r12,-1
80007cf2:	35 8b       	mov	r11,88
80007cf4:	58 0c       	cp.w	r12,0
80007cf6:	5e 4c       	retge	r12
80007cf8:	e0 6a 53 c8 	mov	r10,21448
80007cfc:	95 0b       	st.w	r10[0x0],r11
80007cfe:	5e fc       	retal	r12

80007d00 <_lseek>:
80007d00:	30 58       	mov	r8,5
80007d02:	d6 73       	breakpoint
80007d04:	3f fc       	mov	r12,-1
80007d06:	35 8b       	mov	r11,88
80007d08:	58 0c       	cp.w	r12,0
80007d0a:	5e 4c       	retge	r12
80007d0c:	e0 6a 53 c8 	mov	r10,21448
80007d10:	95 0b       	st.w	r10[0x0],r11
80007d12:	5e fc       	retal	r12

80007d14 <isatty>:
80007d14:	30 b8       	mov	r8,11
80007d16:	d6 73       	breakpoint
80007d18:	3f fc       	mov	r12,-1
80007d1a:	35 8b       	mov	r11,88
80007d1c:	58 0c       	cp.w	r12,0
80007d1e:	5e 4c       	retge	r12
80007d20:	e0 6a 53 c8 	mov	r10,21448
80007d24:	95 0b       	st.w	r10[0x0],r11
80007d26:	5e fc       	retal	r12

80007d28 <_fstat_host>:
80007d28:	30 98       	mov	r8,9
80007d2a:	d6 73       	breakpoint
80007d2c:	3f fc       	mov	r12,-1
80007d2e:	35 8b       	mov	r11,88
80007d30:	58 0c       	cp.w	r12,0
80007d32:	5e 4c       	retge	r12
80007d34:	e0 6a 53 c8 	mov	r10,21448
80007d38:	95 0b       	st.w	r10[0x0],r11
80007d3a:	5e fc       	retal	r12

80007d3c <_fstat>:
80007d3c:	d4 21       	pushm	r4-r7,lr
80007d3e:	21 0d       	sub	sp,64
80007d40:	16 97       	mov	r7,r11
80007d42:	1a 9b       	mov	r11,sp
80007d44:	cf 2f       	rcall	80007d28 <_fstat_host>
80007d46:	c0 34       	brge	80007d4c <_fstat+0x10>
80007d48:	3f fc       	mov	r12,-1
80007d4a:	c1 c8       	rjmp	80007d82 <_fstat+0x46>
80007d4c:	40 08       	lddsp	r8,sp[0x0]
80007d4e:	ae 08       	st.h	r7[0x0],r8
80007d50:	40 18       	lddsp	r8,sp[0x4]
80007d52:	ae 18       	st.h	r7[0x2],r8
80007d54:	40 28       	lddsp	r8,sp[0x8]
80007d56:	8f 18       	st.w	r7[0x4],r8
80007d58:	40 38       	lddsp	r8,sp[0xc]
80007d5a:	ae 48       	st.h	r7[0x8],r8
80007d5c:	40 48       	lddsp	r8,sp[0x10]
80007d5e:	ae 58       	st.h	r7[0xa],r8
80007d60:	40 58       	lddsp	r8,sp[0x14]
80007d62:	ae 68       	st.h	r7[0xc],r8
80007d64:	40 68       	lddsp	r8,sp[0x18]
80007d66:	ae 78       	st.h	r7[0xe],r8
80007d68:	40 88       	lddsp	r8,sp[0x20]
80007d6a:	8f 48       	st.w	r7[0x10],r8
80007d6c:	40 a8       	lddsp	r8,sp[0x28]
80007d6e:	8f b8       	st.w	r7[0x2c],r8
80007d70:	40 c8       	lddsp	r8,sp[0x30]
80007d72:	8f c8       	st.w	r7[0x30],r8
80007d74:	40 d8       	lddsp	r8,sp[0x34]
80007d76:	8f 58       	st.w	r7[0x14],r8
80007d78:	40 e8       	lddsp	r8,sp[0x38]
80007d7a:	30 0c       	mov	r12,0
80007d7c:	8f 78       	st.w	r7[0x1c],r8
80007d7e:	40 f8       	lddsp	r8,sp[0x3c]
80007d80:	8f 98       	st.w	r7[0x24],r8
80007d82:	2f 0d       	sub	sp,-64
80007d84:	d8 22       	popm	r4-r7,pc
80007d86:	d7 03       	nop

80007d88 <_sbrk>:
80007d88:	d4 01       	pushm	lr
80007d8a:	e0 68 0d 94 	mov	r8,3476
80007d8e:	70 09       	ld.w	r9,r8[0x0]
80007d90:	58 09       	cp.w	r9,0
80007d92:	c0 41       	brne	80007d9a <_sbrk+0x12>
80007d94:	e0 69 53 d0 	mov	r9,21456
80007d98:	91 09       	st.w	r8[0x0],r9
80007d9a:	e0 69 0d 94 	mov	r9,3476
80007d9e:	e0 7a 70 00 	mov	r10,94208
80007da2:	72 08       	ld.w	r8,r9[0x0]
80007da4:	f0 0c 00 0c 	add	r12,r8,r12
80007da8:	14 3c       	cp.w	r12,r10
80007daa:	e0 8b 00 04 	brhi	80007db2 <_sbrk+0x2a>
80007dae:	93 0c       	st.w	r9[0x0],r12
80007db0:	c0 68       	rjmp	80007dbc <_sbrk+0x34>
80007db2:	e0 a0 18 15 	rcall	8000addc <__errno>
80007db6:	30 c8       	mov	r8,12
80007db8:	99 08       	st.w	r12[0x0],r8
80007dba:	3f f8       	mov	r8,-1
80007dbc:	10 9c       	mov	r12,r8
80007dbe:	d8 02       	popm	pc

80007dc0 <get_arg>:
80007dc0:	d4 31       	pushm	r0-r7,lr
80007dc2:	20 8d       	sub	sp,32
80007dc4:	fa c4 ff bc 	sub	r4,sp,-68
80007dc8:	50 4b       	stdsp	sp[0x10],r11
80007dca:	68 2e       	ld.w	lr,r4[0x8]
80007dcc:	50 58       	stdsp	sp[0x14],r8
80007dce:	12 96       	mov	r6,r9
80007dd0:	7c 0b       	ld.w	r11,lr[0x0]
80007dd2:	70 05       	ld.w	r5,r8[0x0]
80007dd4:	50 6e       	stdsp	sp[0x18],lr
80007dd6:	58 0b       	cp.w	r11,0
80007dd8:	f4 0b 17 00 	moveq	r11,r10
80007ddc:	68 03       	ld.w	r3,r4[0x0]
80007dde:	68 11       	ld.w	r1,r4[0x4]
80007de0:	40 49       	lddsp	r9,sp[0x10]
80007de2:	30 08       	mov	r8,0
80007de4:	c2 89       	rjmp	80008034 <get_arg+0x274>
80007de6:	2f fb       	sub	r11,-1
80007de8:	32 5c       	mov	r12,37
80007dea:	17 8a       	ld.ub	r10,r11[0x0]
80007dec:	f8 0a 18 00 	cp.b	r10,r12
80007df0:	5f 1e       	srne	lr
80007df2:	f0 0a 18 00 	cp.b	r10,r8
80007df6:	5f 1c       	srne	r12
80007df8:	fd ec 00 0c 	and	r12,lr,r12
80007dfc:	f0 0c 18 00 	cp.b	r12,r8
80007e00:	cf 31       	brne	80007de6 <get_arg+0x26>
80007e02:	58 0a       	cp.w	r10,0
80007e04:	e0 80 01 25 	breq	8000804e <get_arg+0x28e>
80007e08:	30 0c       	mov	r12,0
80007e0a:	3f fa       	mov	r10,-1
80007e0c:	18 90       	mov	r0,r12
80007e0e:	50 3a       	stdsp	sp[0xc],r10
80007e10:	18 94       	mov	r4,r12
80007e12:	18 92       	mov	r2,r12
80007e14:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e18:	16 97       	mov	r7,r11
80007e1a:	50 7c       	stdsp	sp[0x1c],r12
80007e1c:	fe cc 9e 50 	sub	r12,pc,-25008
80007e20:	0f 3a       	ld.ub	r10,r7++
80007e22:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e26:	40 7c       	lddsp	r12,sp[0x1c]
80007e28:	1c 0c       	add	r12,lr
80007e2a:	fe ce 9f 26 	sub	lr,pc,-24794
80007e2e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e32:	20 1e       	sub	lr,1
80007e34:	50 0e       	stdsp	sp[0x0],lr
80007e36:	fe ce 9f 9e 	sub	lr,pc,-24674
80007e3a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e3e:	50 7c       	stdsp	sp[0x1c],r12
80007e40:	40 0c       	lddsp	r12,sp[0x0]
80007e42:	58 7c       	cp.w	r12,7
80007e44:	e0 8b 00 f1 	brhi	80008026 <get_arg+0x266>
80007e48:	fe ce a1 50 	sub	lr,pc,-24240
80007e4c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e50:	36 8b       	mov	r11,104
80007e52:	f6 0a 18 00 	cp.b	r10,r11
80007e56:	e0 80 00 e8 	breq	80008026 <get_arg+0x266>
80007e5a:	37 1b       	mov	r11,113
80007e5c:	f6 0a 18 00 	cp.b	r10,r11
80007e60:	c0 70       	breq	80007e6e <get_arg+0xae>
80007e62:	34 cb       	mov	r11,76
80007e64:	f6 0a 18 00 	cp.b	r10,r11
80007e68:	c0 51       	brne	80007e72 <get_arg+0xb2>
80007e6a:	a3 b4       	sbr	r4,0x3
80007e6c:	cd d8       	rjmp	80008026 <get_arg+0x266>
80007e6e:	a5 b4       	sbr	r4,0x5
80007e70:	cd b8       	rjmp	80008026 <get_arg+0x266>
80007e72:	08 9a       	mov	r10,r4
80007e74:	0e 9b       	mov	r11,r7
80007e76:	a5 aa       	sbr	r10,0x4
80007e78:	17 3c       	ld.ub	r12,r11++
80007e7a:	a5 b4       	sbr	r4,0x5
80007e7c:	36 ce       	mov	lr,108
80007e7e:	fc 0c 18 00 	cp.b	r12,lr
80007e82:	e0 80 00 d3 	breq	80008028 <get_arg+0x268>
80007e86:	14 94       	mov	r4,r10
80007e88:	cc f8       	rjmp	80008026 <get_arg+0x266>
80007e8a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e8e:	36 7c       	mov	r12,103
80007e90:	f8 0a 18 00 	cp.b	r10,r12
80007e94:	e0 8b 00 27 	brhi	80007ee2 <get_arg+0x122>
80007e98:	36 5b       	mov	r11,101
80007e9a:	f6 0a 18 00 	cp.b	r10,r11
80007e9e:	c4 82       	brcc	80007f2e <get_arg+0x16e>
80007ea0:	34 fb       	mov	r11,79
80007ea2:	f6 0a 18 00 	cp.b	r10,r11
80007ea6:	c4 80       	breq	80007f36 <get_arg+0x176>
80007ea8:	e0 8b 00 0c 	brhi	80007ec0 <get_arg+0x100>
80007eac:	34 5b       	mov	r11,69
80007eae:	f6 0a 18 00 	cp.b	r10,r11
80007eb2:	c3 e0       	breq	80007f2e <get_arg+0x16e>
80007eb4:	34 7b       	mov	r11,71
80007eb6:	f6 0a 18 00 	cp.b	r10,r11
80007eba:	c3 a0       	breq	80007f2e <get_arg+0x16e>
80007ebc:	34 4b       	mov	r11,68
80007ebe:	c0 88       	rjmp	80007ece <get_arg+0x10e>
80007ec0:	35 8b       	mov	r11,88
80007ec2:	f6 0a 18 00 	cp.b	r10,r11
80007ec6:	c2 c0       	breq	80007f1e <get_arg+0x15e>
80007ec8:	e0 8b 00 07 	brhi	80007ed6 <get_arg+0x116>
80007ecc:	35 5b       	mov	r11,85
80007ece:	f6 0a 18 00 	cp.b	r10,r11
80007ed2:	c3 51       	brne	80007f3c <get_arg+0x17c>
80007ed4:	c3 18       	rjmp	80007f36 <get_arg+0x176>
80007ed6:	36 3b       	mov	r11,99
80007ed8:	f6 0a 18 00 	cp.b	r10,r11
80007edc:	c2 f0       	breq	80007f3a <get_arg+0x17a>
80007ede:	36 4b       	mov	r11,100
80007ee0:	c0 e8       	rjmp	80007efc <get_arg+0x13c>
80007ee2:	37 0b       	mov	r11,112
80007ee4:	f6 0a 18 00 	cp.b	r10,r11
80007ee8:	c2 50       	breq	80007f32 <get_arg+0x172>
80007eea:	e0 8b 00 0d 	brhi	80007f04 <get_arg+0x144>
80007eee:	36 eb       	mov	r11,110
80007ef0:	f6 0a 18 00 	cp.b	r10,r11
80007ef4:	c1 f0       	breq	80007f32 <get_arg+0x172>
80007ef6:	e0 8b 00 14 	brhi	80007f1e <get_arg+0x15e>
80007efa:	36 9b       	mov	r11,105
80007efc:	f6 0a 18 00 	cp.b	r10,r11
80007f00:	c1 e1       	brne	80007f3c <get_arg+0x17c>
80007f02:	c0 e8       	rjmp	80007f1e <get_arg+0x15e>
80007f04:	37 5b       	mov	r11,117
80007f06:	f6 0a 18 00 	cp.b	r10,r11
80007f0a:	c0 a0       	breq	80007f1e <get_arg+0x15e>
80007f0c:	37 8b       	mov	r11,120
80007f0e:	f6 0a 18 00 	cp.b	r10,r11
80007f12:	c0 60       	breq	80007f1e <get_arg+0x15e>
80007f14:	37 3b       	mov	r11,115
80007f16:	f6 0a 18 00 	cp.b	r10,r11
80007f1a:	c1 11       	brne	80007f3c <get_arg+0x17c>
80007f1c:	c0 b8       	rjmp	80007f32 <get_arg+0x172>
80007f1e:	ed b4 00 04 	bld	r4,0x4
80007f22:	c0 a0       	breq	80007f36 <get_arg+0x176>
80007f24:	ed b4 00 05 	bld	r4,0x5
80007f28:	c0 91       	brne	80007f3a <get_arg+0x17a>
80007f2a:	30 20       	mov	r0,2
80007f2c:	c0 88       	rjmp	80007f3c <get_arg+0x17c>
80007f2e:	30 40       	mov	r0,4
80007f30:	c0 68       	rjmp	80007f3c <get_arg+0x17c>
80007f32:	30 30       	mov	r0,3
80007f34:	c0 48       	rjmp	80007f3c <get_arg+0x17c>
80007f36:	30 10       	mov	r0,1
80007f38:	c0 28       	rjmp	80007f3c <get_arg+0x17c>
80007f3a:	30 00       	mov	r0,0
80007f3c:	40 3b       	lddsp	r11,sp[0xc]
80007f3e:	5b fb       	cp.w	r11,-1
80007f40:	c0 40       	breq	80007f48 <get_arg+0x188>
80007f42:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f46:	c7 08       	rjmp	80008026 <get_arg+0x266>
80007f48:	58 60       	cp.w	r0,6
80007f4a:	e0 8b 00 6e 	brhi	80008026 <get_arg+0x266>
80007f4e:	6c 0a       	ld.w	r10,r6[0x0]
80007f50:	ea cc ff ff 	sub	r12,r5,-1
80007f54:	fe ce a2 3c 	sub	lr,pc,-24004
80007f58:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f5c:	f4 cb ff f8 	sub	r11,r10,-8
80007f60:	8d 0b       	st.w	r6[0x0],r11
80007f62:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f66:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f6a:	c0 f8       	rjmp	80007f88 <get_arg+0x1c8>
80007f6c:	f4 cb ff fc 	sub	r11,r10,-4
80007f70:	8d 0b       	st.w	r6[0x0],r11
80007f72:	74 0a       	ld.w	r10,r10[0x0]
80007f74:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f78:	c0 88       	rjmp	80007f88 <get_arg+0x1c8>
80007f7a:	f4 cb ff f8 	sub	r11,r10,-8
80007f7e:	8d 0b       	st.w	r6[0x0],r11
80007f80:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f84:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f88:	0e 9b       	mov	r11,r7
80007f8a:	18 95       	mov	r5,r12
80007f8c:	c4 e8       	rjmp	80008028 <get_arg+0x268>
80007f8e:	62 0a       	ld.w	r10,r1[0x0]
80007f90:	5b fa       	cp.w	r10,-1
80007f92:	c0 b1       	brne	80007fa8 <get_arg+0x1e8>
80007f94:	50 19       	stdsp	sp[0x4],r9
80007f96:	50 28       	stdsp	sp[0x8],r8
80007f98:	e0 6a 00 80 	mov	r10,128
80007f9c:	30 0b       	mov	r11,0
80007f9e:	02 9c       	mov	r12,r1
80007fa0:	fe b0 fd 00 	rcall	800079a0 <memset>
80007fa4:	40 28       	lddsp	r8,sp[0x8]
80007fa6:	40 19       	lddsp	r9,sp[0x4]
80007fa8:	e4 cc 00 01 	sub	r12,r2,1
80007fac:	0e 9b       	mov	r11,r7
80007fae:	50 3c       	stdsp	sp[0xc],r12
80007fb0:	f2 0c 0c 49 	max	r9,r9,r12
80007fb4:	c3 a8       	rjmp	80008028 <get_arg+0x268>
80007fb6:	62 0a       	ld.w	r10,r1[0x0]
80007fb8:	5b fa       	cp.w	r10,-1
80007fba:	c0 b1       	brne	80007fd0 <get_arg+0x210>
80007fbc:	50 19       	stdsp	sp[0x4],r9
80007fbe:	50 28       	stdsp	sp[0x8],r8
80007fc0:	e0 6a 00 80 	mov	r10,128
80007fc4:	30 0b       	mov	r11,0
80007fc6:	02 9c       	mov	r12,r1
80007fc8:	fe b0 fc ec 	rcall	800079a0 <memset>
80007fcc:	40 28       	lddsp	r8,sp[0x8]
80007fce:	40 19       	lddsp	r9,sp[0x4]
80007fd0:	20 12       	sub	r2,1
80007fd2:	30 0a       	mov	r10,0
80007fd4:	0e 9b       	mov	r11,r7
80007fd6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007fda:	f2 02 0c 49 	max	r9,r9,r2
80007fde:	c2 58       	rjmp	80008028 <get_arg+0x268>
80007fe0:	16 97       	mov	r7,r11
80007fe2:	6c 0a       	ld.w	r10,r6[0x0]
80007fe4:	f4 cb ff fc 	sub	r11,r10,-4
80007fe8:	8d 0b       	st.w	r6[0x0],r11
80007fea:	74 0a       	ld.w	r10,r10[0x0]
80007fec:	0e 9b       	mov	r11,r7
80007fee:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ff2:	2f f5       	sub	r5,-1
80007ff4:	c1 a8       	rjmp	80008028 <get_arg+0x268>
80007ff6:	f4 c2 00 30 	sub	r2,r10,48
80007ffa:	c0 68       	rjmp	80008006 <get_arg+0x246>
80007ffc:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008000:	2f f7       	sub	r7,-1
80008002:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008006:	0f 8a       	ld.ub	r10,r7[0x0]
80008008:	58 0a       	cp.w	r10,0
8000800a:	c0 e0       	breq	80008026 <get_arg+0x266>
8000800c:	23 0a       	sub	r10,48
8000800e:	58 9a       	cp.w	r10,9
80008010:	fe 98 ff f6 	brls	80007ffc <get_arg+0x23c>
80008014:	c0 98       	rjmp	80008026 <get_arg+0x266>
80008016:	2f f7       	sub	r7,-1
80008018:	0f 8a       	ld.ub	r10,r7[0x0]
8000801a:	58 0a       	cp.w	r10,0
8000801c:	c0 50       	breq	80008026 <get_arg+0x266>
8000801e:	23 0a       	sub	r10,48
80008020:	58 9a       	cp.w	r10,9
80008022:	fe 98 ff fa 	brls	80008016 <get_arg+0x256>
80008026:	0e 9b       	mov	r11,r7
80008028:	40 7c       	lddsp	r12,sp[0x1c]
8000802a:	30 ba       	mov	r10,11
8000802c:	f4 0c 18 00 	cp.b	r12,r10
80008030:	fe 91 fe f2 	brne	80007e14 <get_arg+0x54>
80008034:	40 42       	lddsp	r2,sp[0x10]
80008036:	17 8c       	ld.ub	r12,r11[0x0]
80008038:	0a 32       	cp.w	r2,r5
8000803a:	5f 4a       	srge	r10
8000803c:	f0 0c 18 00 	cp.b	r12,r8
80008040:	5f 1c       	srne	r12
80008042:	f9 ea 00 0a 	and	r10,r12,r10
80008046:	f0 0a 18 00 	cp.b	r10,r8
8000804a:	fe 91 fe cf 	brne	80007de8 <get_arg+0x28>
8000804e:	30 08       	mov	r8,0
80008050:	40 4e       	lddsp	lr,sp[0x10]
80008052:	17 8a       	ld.ub	r10,r11[0x0]
80008054:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008058:	f0 0a 18 00 	cp.b	r10,r8
8000805c:	fc 09 17 10 	movne	r9,lr
80008060:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008064:	06 9e       	mov	lr,r3
80008066:	c2 a8       	rjmp	800080ba <get_arg+0x2fa>
80008068:	62 0a       	ld.w	r10,r1[0x0]
8000806a:	58 3a       	cp.w	r10,3
8000806c:	c1 e0       	breq	800080a8 <get_arg+0x2e8>
8000806e:	e0 89 00 07 	brgt	8000807c <get_arg+0x2bc>
80008072:	58 1a       	cp.w	r10,1
80008074:	c1 a0       	breq	800080a8 <get_arg+0x2e8>
80008076:	58 2a       	cp.w	r10,2
80008078:	c1 81       	brne	800080a8 <get_arg+0x2e8>
8000807a:	c0 58       	rjmp	80008084 <get_arg+0x2c4>
8000807c:	58 5a       	cp.w	r10,5
8000807e:	c0 c0       	breq	80008096 <get_arg+0x2d6>
80008080:	c0 b5       	brlt	80008096 <get_arg+0x2d6>
80008082:	c1 38       	rjmp	800080a8 <get_arg+0x2e8>
80008084:	6c 0a       	ld.w	r10,r6[0x0]
80008086:	f4 cc ff f8 	sub	r12,r10,-8
8000808a:	8d 0c       	st.w	r6[0x0],r12
8000808c:	f4 e2 00 00 	ld.d	r2,r10[0]
80008090:	f0 e3 00 00 	st.d	r8[0],r2
80008094:	c1 08       	rjmp	800080b4 <get_arg+0x2f4>
80008096:	6c 0a       	ld.w	r10,r6[0x0]
80008098:	f4 cc ff f8 	sub	r12,r10,-8
8000809c:	8d 0c       	st.w	r6[0x0],r12
8000809e:	f4 e2 00 00 	ld.d	r2,r10[0]
800080a2:	f0 e3 00 00 	st.d	r8[0],r2
800080a6:	c0 78       	rjmp	800080b4 <get_arg+0x2f4>
800080a8:	6c 0a       	ld.w	r10,r6[0x0]
800080aa:	f4 cc ff fc 	sub	r12,r10,-4
800080ae:	8d 0c       	st.w	r6[0x0],r12
800080b0:	74 0a       	ld.w	r10,r10[0x0]
800080b2:	91 0a       	st.w	r8[0x0],r10
800080b4:	2f f5       	sub	r5,-1
800080b6:	2f 88       	sub	r8,-8
800080b8:	2f c1       	sub	r1,-4
800080ba:	12 35       	cp.w	r5,r9
800080bc:	fe 9a ff d6 	brle	80008068 <get_arg+0x2a8>
800080c0:	1c 93       	mov	r3,lr
800080c2:	40 52       	lddsp	r2,sp[0x14]
800080c4:	40 6e       	lddsp	lr,sp[0x18]
800080c6:	85 05       	st.w	r2[0x0],r5
800080c8:	9d 0b       	st.w	lr[0x0],r11
800080ca:	40 4b       	lddsp	r11,sp[0x10]
800080cc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800080d0:	2f 8d       	sub	sp,-32
800080d2:	d8 32       	popm	r0-r7,pc

800080d4 <__sprint_r>:
800080d4:	d4 21       	pushm	r4-r7,lr
800080d6:	14 97       	mov	r7,r10
800080d8:	74 28       	ld.w	r8,r10[0x8]
800080da:	58 08       	cp.w	r8,0
800080dc:	c0 41       	brne	800080e4 <__sprint_r+0x10>
800080de:	95 18       	st.w	r10[0x4],r8
800080e0:	10 9c       	mov	r12,r8
800080e2:	d8 22       	popm	r4-r7,pc
800080e4:	e0 a0 18 ba 	rcall	8000b258 <__sfvwrite_r>
800080e8:	30 08       	mov	r8,0
800080ea:	8f 18       	st.w	r7[0x4],r8
800080ec:	8f 28       	st.w	r7[0x8],r8
800080ee:	d8 22       	popm	r4-r7,pc

800080f0 <_vfprintf_r>:
800080f0:	d4 31       	pushm	r0-r7,lr
800080f2:	fa cd 06 bc 	sub	sp,sp,1724
800080f6:	51 09       	stdsp	sp[0x40],r9
800080f8:	16 91       	mov	r1,r11
800080fa:	14 97       	mov	r7,r10
800080fc:	18 95       	mov	r5,r12
800080fe:	e0 a0 1a 1d 	rcall	8000b538 <_localeconv_r>
80008102:	78 0c       	ld.w	r12,r12[0x0]
80008104:	50 cc       	stdsp	sp[0x30],r12
80008106:	58 05       	cp.w	r5,0
80008108:	c0 70       	breq	80008116 <_vfprintf_r+0x26>
8000810a:	6a 68       	ld.w	r8,r5[0x18]
8000810c:	58 08       	cp.w	r8,0
8000810e:	c0 41       	brne	80008116 <_vfprintf_r+0x26>
80008110:	0a 9c       	mov	r12,r5
80008112:	e0 a0 17 43 	rcall	8000af98 <__sinit>
80008116:	fe c8 a0 3a 	sub	r8,pc,-24518
8000811a:	10 31       	cp.w	r1,r8
8000811c:	c0 31       	brne	80008122 <_vfprintf_r+0x32>
8000811e:	6a 01       	ld.w	r1,r5[0x0]
80008120:	c0 c8       	rjmp	80008138 <_vfprintf_r+0x48>
80008122:	fe c8 a0 26 	sub	r8,pc,-24538
80008126:	10 31       	cp.w	r1,r8
80008128:	c0 31       	brne	8000812e <_vfprintf_r+0x3e>
8000812a:	6a 11       	ld.w	r1,r5[0x4]
8000812c:	c0 68       	rjmp	80008138 <_vfprintf_r+0x48>
8000812e:	fe c8 a0 12 	sub	r8,pc,-24558
80008132:	10 31       	cp.w	r1,r8
80008134:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008138:	82 68       	ld.sh	r8,r1[0xc]
8000813a:	ed b8 00 03 	bld	r8,0x3
8000813e:	c0 41       	brne	80008146 <_vfprintf_r+0x56>
80008140:	62 48       	ld.w	r8,r1[0x10]
80008142:	58 08       	cp.w	r8,0
80008144:	c0 71       	brne	80008152 <_vfprintf_r+0x62>
80008146:	02 9b       	mov	r11,r1
80008148:	0a 9c       	mov	r12,r5
8000814a:	e0 a0 0f 5d 	rcall	8000a004 <__swsetup_r>
8000814e:	e0 81 0f 54 	brne	80009ff6 <_vfprintf_r+0x1f06>
80008152:	82 68       	ld.sh	r8,r1[0xc]
80008154:	10 99       	mov	r9,r8
80008156:	e2 19 00 1a 	andl	r9,0x1a,COH
8000815a:	58 a9       	cp.w	r9,10
8000815c:	c3 c1       	brne	800081d4 <_vfprintf_r+0xe4>
8000815e:	82 79       	ld.sh	r9,r1[0xe]
80008160:	30 0a       	mov	r10,0
80008162:	f4 09 19 00 	cp.h	r9,r10
80008166:	c3 75       	brlt	800081d4 <_vfprintf_r+0xe4>
80008168:	a1 d8       	cbr	r8,0x1
8000816a:	fb 58 05 d0 	st.h	sp[1488],r8
8000816e:	62 88       	ld.w	r8,r1[0x20]
80008170:	fb 48 05 e4 	st.w	sp[1508],r8
80008174:	62 a8       	ld.w	r8,r1[0x28]
80008176:	fb 48 05 ec 	st.w	sp[1516],r8
8000817a:	fa c8 ff bc 	sub	r8,sp,-68
8000817e:	fb 48 05 d4 	st.w	sp[1492],r8
80008182:	fb 48 05 c4 	st.w	sp[1476],r8
80008186:	e0 68 04 00 	mov	r8,1024
8000818a:	fb 48 05 d8 	st.w	sp[1496],r8
8000818e:	fb 48 05 cc 	st.w	sp[1484],r8
80008192:	30 08       	mov	r8,0
80008194:	fb 59 05 d2 	st.h	sp[1490],r9
80008198:	0e 9a       	mov	r10,r7
8000819a:	41 09       	lddsp	r9,sp[0x40]
8000819c:	fa c7 fa 3c 	sub	r7,sp,-1476
800081a0:	fb 48 05 dc 	st.w	sp[1500],r8
800081a4:	0a 9c       	mov	r12,r5
800081a6:	0e 9b       	mov	r11,r7
800081a8:	ca 4f       	rcall	800080f0 <_vfprintf_r>
800081aa:	50 bc       	stdsp	sp[0x2c],r12
800081ac:	c0 95       	brlt	800081be <_vfprintf_r+0xce>
800081ae:	0e 9b       	mov	r11,r7
800081b0:	0a 9c       	mov	r12,r5
800081b2:	e0 a0 16 1b 	rcall	8000ade8 <_fflush_r>
800081b6:	40 be       	lddsp	lr,sp[0x2c]
800081b8:	f9 be 01 ff 	movne	lr,-1
800081bc:	50 be       	stdsp	sp[0x2c],lr
800081be:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081c2:	ed b8 00 06 	bld	r8,0x6
800081c6:	e0 81 0f 1a 	brne	80009ffa <_vfprintf_r+0x1f0a>
800081ca:	82 68       	ld.sh	r8,r1[0xc]
800081cc:	a7 a8       	sbr	r8,0x6
800081ce:	a2 68       	st.h	r1[0xc],r8
800081d0:	e0 8f 0f 15 	bral	80009ffa <_vfprintf_r+0x1f0a>
800081d4:	30 08       	mov	r8,0
800081d6:	fb 48 06 b4 	st.w	sp[1716],r8
800081da:	fb 48 06 90 	st.w	sp[1680],r8
800081de:	fb 48 06 8c 	st.w	sp[1676],r8
800081e2:	fb 48 06 b0 	st.w	sp[1712],r8
800081e6:	30 08       	mov	r8,0
800081e8:	30 09       	mov	r9,0
800081ea:	50 a7       	stdsp	sp[0x28],r7
800081ec:	50 78       	stdsp	sp[0x1c],r8
800081ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800081f2:	3f f8       	mov	r8,-1
800081f4:	50 59       	stdsp	sp[0x14],r9
800081f6:	fb 43 06 88 	st.w	sp[1672],r3
800081fa:	fb 48 05 44 	st.w	sp[1348],r8
800081fe:	12 9c       	mov	r12,r9
80008200:	50 69       	stdsp	sp[0x18],r9
80008202:	50 d9       	stdsp	sp[0x34],r9
80008204:	50 e9       	stdsp	sp[0x38],r9
80008206:	50 b9       	stdsp	sp[0x2c],r9
80008208:	12 97       	mov	r7,r9
8000820a:	0a 94       	mov	r4,r5
8000820c:	40 a2       	lddsp	r2,sp[0x28]
8000820e:	32 5a       	mov	r10,37
80008210:	30 08       	mov	r8,0
80008212:	c0 28       	rjmp	80008216 <_vfprintf_r+0x126>
80008214:	2f f2       	sub	r2,-1
80008216:	05 89       	ld.ub	r9,r2[0x0]
80008218:	f0 09 18 00 	cp.b	r9,r8
8000821c:	5f 1b       	srne	r11
8000821e:	f4 09 18 00 	cp.b	r9,r10
80008222:	5f 19       	srne	r9
80008224:	f3 eb 00 0b 	and	r11,r9,r11
80008228:	f0 0b 18 00 	cp.b	r11,r8
8000822c:	cf 41       	brne	80008214 <_vfprintf_r+0x124>
8000822e:	40 ab       	lddsp	r11,sp[0x28]
80008230:	e4 0b 01 06 	sub	r6,r2,r11
80008234:	c1 e0       	breq	80008270 <_vfprintf_r+0x180>
80008236:	fa f8 06 90 	ld.w	r8,sp[1680]
8000823a:	0c 08       	add	r8,r6
8000823c:	87 0b       	st.w	r3[0x0],r11
8000823e:	fb 48 06 90 	st.w	sp[1680],r8
80008242:	87 16       	st.w	r3[0x4],r6
80008244:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008248:	2f f8       	sub	r8,-1
8000824a:	fb 48 06 8c 	st.w	sp[1676],r8
8000824e:	58 78       	cp.w	r8,7
80008250:	e0 89 00 04 	brgt	80008258 <_vfprintf_r+0x168>
80008254:	2f 83       	sub	r3,-8
80008256:	c0 a8       	rjmp	8000826a <_vfprintf_r+0x17a>
80008258:	fa ca f9 78 	sub	r10,sp,-1672
8000825c:	02 9b       	mov	r11,r1
8000825e:	08 9c       	mov	r12,r4
80008260:	c3 af       	rcall	800080d4 <__sprint_r>
80008262:	e0 81 0e c6 	brne	80009fee <_vfprintf_r+0x1efe>
80008266:	fa c3 f9 e0 	sub	r3,sp,-1568
8000826a:	40 ba       	lddsp	r10,sp[0x2c]
8000826c:	0c 0a       	add	r10,r6
8000826e:	50 ba       	stdsp	sp[0x2c],r10
80008270:	05 89       	ld.ub	r9,r2[0x0]
80008272:	30 08       	mov	r8,0
80008274:	f0 09 18 00 	cp.b	r9,r8
80008278:	e0 80 0e aa 	breq	80009fcc <_vfprintf_r+0x1edc>
8000827c:	30 09       	mov	r9,0
8000827e:	fb 68 06 bb 	st.b	sp[1723],r8
80008282:	0e 96       	mov	r6,r7
80008284:	e4 c8 ff ff 	sub	r8,r2,-1
80008288:	3f fe       	mov	lr,-1
8000828a:	50 93       	stdsp	sp[0x24],r3
8000828c:	50 41       	stdsp	sp[0x10],r1
8000828e:	0e 93       	mov	r3,r7
80008290:	04 91       	mov	r1,r2
80008292:	50 89       	stdsp	sp[0x20],r9
80008294:	50 a8       	stdsp	sp[0x28],r8
80008296:	50 2e       	stdsp	sp[0x8],lr
80008298:	50 39       	stdsp	sp[0xc],r9
8000829a:	12 95       	mov	r5,r9
8000829c:	12 90       	mov	r0,r9
8000829e:	10 97       	mov	r7,r8
800082a0:	08 92       	mov	r2,r4
800082a2:	c0 78       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800082a4:	3f fc       	mov	r12,-1
800082a6:	08 97       	mov	r7,r4
800082a8:	50 2c       	stdsp	sp[0x8],r12
800082aa:	c0 38       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800082ac:	30 0b       	mov	r11,0
800082ae:	50 3b       	stdsp	sp[0xc],r11
800082b0:	0f 38       	ld.ub	r8,r7++
800082b2:	c0 28       	rjmp	800082b6 <_vfprintf_r+0x1c6>
800082b4:	12 90       	mov	r0,r9
800082b6:	f0 c9 00 20 	sub	r9,r8,32
800082ba:	e0 49 00 58 	cp.w	r9,88
800082be:	e0 8b 0a 30 	brhi	8000971e <_vfprintf_r+0x162e>
800082c2:	fe ca a5 8e 	sub	r10,pc,-23154
800082c6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800082ca:	50 a7       	stdsp	sp[0x28],r7
800082cc:	50 80       	stdsp	sp[0x20],r0
800082ce:	0c 97       	mov	r7,r6
800082d0:	04 94       	mov	r4,r2
800082d2:	06 96       	mov	r6,r3
800082d4:	02 92       	mov	r2,r1
800082d6:	fe c9 a3 66 	sub	r9,pc,-23706
800082da:	40 93       	lddsp	r3,sp[0x24]
800082dc:	10 90       	mov	r0,r8
800082de:	40 41       	lddsp	r1,sp[0x10]
800082e0:	50 d9       	stdsp	sp[0x34],r9
800082e2:	e0 8f 08 8e 	bral	800093fe <_vfprintf_r+0x130e>
800082e6:	30 08       	mov	r8,0
800082e8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800082ec:	f0 09 18 00 	cp.b	r9,r8
800082f0:	ce 01       	brne	800082b0 <_vfprintf_r+0x1c0>
800082f2:	32 08       	mov	r8,32
800082f4:	c6 e8       	rjmp	800083d0 <_vfprintf_r+0x2e0>
800082f6:	a1 a5       	sbr	r5,0x0
800082f8:	cd cb       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800082fa:	0f 89       	ld.ub	r9,r7[0x0]
800082fc:	f2 c8 00 30 	sub	r8,r9,48
80008300:	58 98       	cp.w	r8,9
80008302:	e0 8b 00 1d 	brhi	8000833c <_vfprintf_r+0x24c>
80008306:	ee c8 ff ff 	sub	r8,r7,-1
8000830a:	30 0b       	mov	r11,0
8000830c:	23 09       	sub	r9,48
8000830e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008312:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008316:	11 39       	ld.ub	r9,r8++
80008318:	f2 ca 00 30 	sub	r10,r9,48
8000831c:	58 9a       	cp.w	r10,9
8000831e:	fe 98 ff f7 	brls	8000830c <_vfprintf_r+0x21c>
80008322:	e0 49 00 24 	cp.w	r9,36
80008326:	cc 31       	brne	800082ac <_vfprintf_r+0x1bc>
80008328:	e0 4b 00 20 	cp.w	r11,32
8000832c:	e0 89 0e 60 	brgt	80009fec <_vfprintf_r+0x1efc>
80008330:	20 1b       	sub	r11,1
80008332:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008336:	12 3b       	cp.w	r11,r9
80008338:	c0 95       	brlt	8000834a <_vfprintf_r+0x25a>
8000833a:	c1 08       	rjmp	8000835a <_vfprintf_r+0x26a>
8000833c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008340:	ec ca ff ff 	sub	r10,r6,-1
80008344:	12 36       	cp.w	r6,r9
80008346:	c1 f5       	brlt	80008384 <_vfprintf_r+0x294>
80008348:	c2 68       	rjmp	80008394 <_vfprintf_r+0x2a4>
8000834a:	fa ce f9 44 	sub	lr,sp,-1724
8000834e:	10 97       	mov	r7,r8
80008350:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008354:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008358:	c3 58       	rjmp	800083c2 <_vfprintf_r+0x2d2>
8000835a:	10 97       	mov	r7,r8
8000835c:	fa c8 f9 50 	sub	r8,sp,-1712
80008360:	1a d8       	st.w	--sp,r8
80008362:	fa c8 fa b8 	sub	r8,sp,-1352
80008366:	1a d8       	st.w	--sp,r8
80008368:	fa c8 fb b4 	sub	r8,sp,-1100
8000836c:	02 9a       	mov	r10,r1
8000836e:	1a d8       	st.w	--sp,r8
80008370:	04 9c       	mov	r12,r2
80008372:	fa c8 f9 40 	sub	r8,sp,-1728
80008376:	fa c9 ff b4 	sub	r9,sp,-76
8000837a:	fe b0 fd 23 	rcall	80007dc0 <get_arg>
8000837e:	2f dd       	sub	sp,-12
80008380:	78 00       	ld.w	r0,r12[0x0]
80008382:	c2 08       	rjmp	800083c2 <_vfprintf_r+0x2d2>
80008384:	fa cc f9 44 	sub	r12,sp,-1724
80008388:	14 96       	mov	r6,r10
8000838a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000838e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008392:	c1 88       	rjmp	800083c2 <_vfprintf_r+0x2d2>
80008394:	41 08       	lddsp	r8,sp[0x40]
80008396:	59 f9       	cp.w	r9,31
80008398:	e0 89 00 11 	brgt	800083ba <_vfprintf_r+0x2ca>
8000839c:	f0 cb ff fc 	sub	r11,r8,-4
800083a0:	51 0b       	stdsp	sp[0x40],r11
800083a2:	70 00       	ld.w	r0,r8[0x0]
800083a4:	fa cb f9 44 	sub	r11,sp,-1724
800083a8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800083ac:	f1 40 fd 88 	st.w	r8[-632],r0
800083b0:	2f f9       	sub	r9,-1
800083b2:	14 96       	mov	r6,r10
800083b4:	fb 49 06 b4 	st.w	sp[1716],r9
800083b8:	c0 58       	rjmp	800083c2 <_vfprintf_r+0x2d2>
800083ba:	70 00       	ld.w	r0,r8[0x0]
800083bc:	14 96       	mov	r6,r10
800083be:	2f c8       	sub	r8,-4
800083c0:	51 08       	stdsp	sp[0x40],r8
800083c2:	58 00       	cp.w	r0,0
800083c4:	fe 94 ff 76 	brge	800082b0 <_vfprintf_r+0x1c0>
800083c8:	5c 30       	neg	r0
800083ca:	a3 a5       	sbr	r5,0x2
800083cc:	c7 2b       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800083ce:	32 b8       	mov	r8,43
800083d0:	fb 68 06 bb 	st.b	sp[1723],r8
800083d4:	c6 eb       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800083d6:	0f 38       	ld.ub	r8,r7++
800083d8:	e0 48 00 2a 	cp.w	r8,42
800083dc:	c0 30       	breq	800083e2 <_vfprintf_r+0x2f2>
800083de:	30 09       	mov	r9,0
800083e0:	c7 98       	rjmp	800084d2 <_vfprintf_r+0x3e2>
800083e2:	0f 88       	ld.ub	r8,r7[0x0]
800083e4:	f0 c9 00 30 	sub	r9,r8,48
800083e8:	58 99       	cp.w	r9,9
800083ea:	e0 8b 00 1f 	brhi	80008428 <_vfprintf_r+0x338>
800083ee:	ee c4 ff ff 	sub	r4,r7,-1
800083f2:	30 0b       	mov	r11,0
800083f4:	23 08       	sub	r8,48
800083f6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800083fa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800083fe:	09 38       	ld.ub	r8,r4++
80008400:	f0 c9 00 30 	sub	r9,r8,48
80008404:	58 99       	cp.w	r9,9
80008406:	fe 98 ff f7 	brls	800083f4 <_vfprintf_r+0x304>
8000840a:	e0 48 00 24 	cp.w	r8,36
8000840e:	fe 91 ff 4f 	brne	800082ac <_vfprintf_r+0x1bc>
80008412:	e0 4b 00 20 	cp.w	r11,32
80008416:	e0 89 0d eb 	brgt	80009fec <_vfprintf_r+0x1efc>
8000841a:	20 1b       	sub	r11,1
8000841c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008420:	10 3b       	cp.w	r11,r8
80008422:	c0 a5       	brlt	80008436 <_vfprintf_r+0x346>
80008424:	c1 18       	rjmp	80008446 <_vfprintf_r+0x356>
80008426:	d7 03       	nop
80008428:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000842c:	ec c9 ff ff 	sub	r9,r6,-1
80008430:	14 36       	cp.w	r6,r10
80008432:	c1 f5       	brlt	80008470 <_vfprintf_r+0x380>
80008434:	c2 88       	rjmp	80008484 <_vfprintf_r+0x394>
80008436:	fa ca f9 44 	sub	r10,sp,-1724
8000843a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000843e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008442:	50 2b       	stdsp	sp[0x8],r11
80008444:	c3 c8       	rjmp	800084bc <_vfprintf_r+0x3cc>
80008446:	fa c8 f9 50 	sub	r8,sp,-1712
8000844a:	1a d8       	st.w	--sp,r8
8000844c:	fa c8 fa b8 	sub	r8,sp,-1352
80008450:	1a d8       	st.w	--sp,r8
80008452:	fa c8 fb b4 	sub	r8,sp,-1100
80008456:	02 9a       	mov	r10,r1
80008458:	1a d8       	st.w	--sp,r8
8000845a:	04 9c       	mov	r12,r2
8000845c:	fa c8 f9 40 	sub	r8,sp,-1728
80008460:	fa c9 ff b4 	sub	r9,sp,-76
80008464:	fe b0 fc ae 	rcall	80007dc0 <get_arg>
80008468:	2f dd       	sub	sp,-12
8000846a:	78 0c       	ld.w	r12,r12[0x0]
8000846c:	50 2c       	stdsp	sp[0x8],r12
8000846e:	c2 78       	rjmp	800084bc <_vfprintf_r+0x3cc>
80008470:	12 96       	mov	r6,r9
80008472:	0e 94       	mov	r4,r7
80008474:	fa c9 f9 44 	sub	r9,sp,-1724
80008478:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000847c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008480:	50 28       	stdsp	sp[0x8],r8
80008482:	c1 d8       	rjmp	800084bc <_vfprintf_r+0x3cc>
80008484:	41 08       	lddsp	r8,sp[0x40]
80008486:	59 fa       	cp.w	r10,31
80008488:	e0 89 00 14 	brgt	800084b0 <_vfprintf_r+0x3c0>
8000848c:	f0 cb ff fc 	sub	r11,r8,-4
80008490:	70 08       	ld.w	r8,r8[0x0]
80008492:	51 0b       	stdsp	sp[0x40],r11
80008494:	50 28       	stdsp	sp[0x8],r8
80008496:	fa c6 f9 44 	sub	r6,sp,-1724
8000849a:	40 2e       	lddsp	lr,sp[0x8]
8000849c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800084a0:	f1 4e fd 88 	st.w	r8[-632],lr
800084a4:	2f fa       	sub	r10,-1
800084a6:	0e 94       	mov	r4,r7
800084a8:	fb 4a 06 b4 	st.w	sp[1716],r10
800084ac:	12 96       	mov	r6,r9
800084ae:	c0 78       	rjmp	800084bc <_vfprintf_r+0x3cc>
800084b0:	70 0c       	ld.w	r12,r8[0x0]
800084b2:	0e 94       	mov	r4,r7
800084b4:	2f c8       	sub	r8,-4
800084b6:	50 2c       	stdsp	sp[0x8],r12
800084b8:	12 96       	mov	r6,r9
800084ba:	51 08       	stdsp	sp[0x40],r8
800084bc:	40 2b       	lddsp	r11,sp[0x8]
800084be:	58 0b       	cp.w	r11,0
800084c0:	fe 95 fe f2 	brlt	800082a4 <_vfprintf_r+0x1b4>
800084c4:	08 97       	mov	r7,r4
800084c6:	cf 5a       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800084c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084cc:	0f 38       	ld.ub	r8,r7++
800084ce:	f4 09 00 19 	add	r9,r10,r9<<0x1
800084d2:	f0 ca 00 30 	sub	r10,r8,48
800084d6:	58 9a       	cp.w	r10,9
800084d8:	fe 98 ff f8 	brls	800084c8 <_vfprintf_r+0x3d8>
800084dc:	3f fa       	mov	r10,-1
800084de:	f2 0a 0c 49 	max	r9,r9,r10
800084e2:	50 29       	stdsp	sp[0x8],r9
800084e4:	ce 9a       	rjmp	800082b6 <_vfprintf_r+0x1c6>
800084e6:	a7 b5       	sbr	r5,0x7
800084e8:	ce 4a       	rjmp	800082b0 <_vfprintf_r+0x1c0>
800084ea:	30 09       	mov	r9,0
800084ec:	23 08       	sub	r8,48
800084ee:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084f2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800084f6:	0f 38       	ld.ub	r8,r7++
800084f8:	f0 ca 00 30 	sub	r10,r8,48
800084fc:	58 9a       	cp.w	r10,9
800084fe:	fe 98 ff f7 	brls	800084ec <_vfprintf_r+0x3fc>
80008502:	e0 48 00 24 	cp.w	r8,36
80008506:	fe 91 fe d7 	brne	800082b4 <_vfprintf_r+0x1c4>
8000850a:	e0 49 00 20 	cp.w	r9,32
8000850e:	e0 89 0d 6f 	brgt	80009fec <_vfprintf_r+0x1efc>
80008512:	f2 c3 00 01 	sub	r3,r9,1
80008516:	30 19       	mov	r9,1
80008518:	50 39       	stdsp	sp[0xc],r9
8000851a:	cc ba       	rjmp	800082b0 <_vfprintf_r+0x1c0>
8000851c:	a3 b5       	sbr	r5,0x3
8000851e:	cc 9a       	rjmp	800082b0 <_vfprintf_r+0x1c0>
80008520:	a7 a5       	sbr	r5,0x6
80008522:	cc 7a       	rjmp	800082b0 <_vfprintf_r+0x1c0>
80008524:	0a 98       	mov	r8,r5
80008526:	a5 b5       	sbr	r5,0x5
80008528:	a5 a8       	sbr	r8,0x4
8000852a:	0f 89       	ld.ub	r9,r7[0x0]
8000852c:	36 ce       	mov	lr,108
8000852e:	fc 09 18 00 	cp.b	r9,lr
80008532:	f7 b7 00 ff 	subeq	r7,-1
80008536:	f0 05 17 10 	movne	r5,r8
8000853a:	cb ba       	rjmp	800082b0 <_vfprintf_r+0x1c0>
8000853c:	a5 b5       	sbr	r5,0x5
8000853e:	cb 9a       	rjmp	800082b0 <_vfprintf_r+0x1c0>
80008540:	50 a7       	stdsp	sp[0x28],r7
80008542:	50 80       	stdsp	sp[0x20],r0
80008544:	0c 97       	mov	r7,r6
80008546:	10 90       	mov	r0,r8
80008548:	06 96       	mov	r6,r3
8000854a:	04 94       	mov	r4,r2
8000854c:	40 93       	lddsp	r3,sp[0x24]
8000854e:	02 92       	mov	r2,r1
80008550:	0e 99       	mov	r9,r7
80008552:	40 41       	lddsp	r1,sp[0x10]
80008554:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008558:	40 3c       	lddsp	r12,sp[0xc]
8000855a:	58 0c       	cp.w	r12,0
8000855c:	c1 d0       	breq	80008596 <_vfprintf_r+0x4a6>
8000855e:	10 36       	cp.w	r6,r8
80008560:	c0 64       	brge	8000856c <_vfprintf_r+0x47c>
80008562:	fa cb f9 44 	sub	r11,sp,-1724
80008566:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000856a:	c1 d8       	rjmp	800085a4 <_vfprintf_r+0x4b4>
8000856c:	fa c8 f9 50 	sub	r8,sp,-1712
80008570:	1a d8       	st.w	--sp,r8
80008572:	fa c8 fa b8 	sub	r8,sp,-1352
80008576:	1a d8       	st.w	--sp,r8
80008578:	fa c8 fb b4 	sub	r8,sp,-1100
8000857c:	1a d8       	st.w	--sp,r8
8000857e:	fa c8 f9 40 	sub	r8,sp,-1728
80008582:	fa c9 ff b4 	sub	r9,sp,-76
80008586:	04 9a       	mov	r10,r2
80008588:	0c 9b       	mov	r11,r6
8000858a:	08 9c       	mov	r12,r4
8000858c:	fe b0 fc 1a 	rcall	80007dc0 <get_arg>
80008590:	2f dd       	sub	sp,-12
80008592:	19 b8       	ld.ub	r8,r12[0x3]
80008594:	c2 28       	rjmp	800085d8 <_vfprintf_r+0x4e8>
80008596:	2f f7       	sub	r7,-1
80008598:	10 39       	cp.w	r9,r8
8000859a:	c0 84       	brge	800085aa <_vfprintf_r+0x4ba>
8000859c:	fa ca f9 44 	sub	r10,sp,-1724
800085a0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085a4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800085a8:	c1 88       	rjmp	800085d8 <_vfprintf_r+0x4e8>
800085aa:	41 09       	lddsp	r9,sp[0x40]
800085ac:	59 f8       	cp.w	r8,31
800085ae:	e0 89 00 12 	brgt	800085d2 <_vfprintf_r+0x4e2>
800085b2:	f2 ca ff fc 	sub	r10,r9,-4
800085b6:	51 0a       	stdsp	sp[0x40],r10
800085b8:	72 09       	ld.w	r9,r9[0x0]
800085ba:	fa c6 f9 44 	sub	r6,sp,-1724
800085be:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085c2:	2f f8       	sub	r8,-1
800085c4:	f5 49 fd 88 	st.w	r10[-632],r9
800085c8:	fb 48 06 b4 	st.w	sp[1716],r8
800085cc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800085d0:	c0 48       	rjmp	800085d8 <_vfprintf_r+0x4e8>
800085d2:	13 b8       	ld.ub	r8,r9[0x3]
800085d4:	2f c9       	sub	r9,-4
800085d6:	51 09       	stdsp	sp[0x40],r9
800085d8:	fb 68 06 60 	st.b	sp[1632],r8
800085dc:	30 0e       	mov	lr,0
800085de:	30 08       	mov	r8,0
800085e0:	30 12       	mov	r2,1
800085e2:	fb 68 06 bb 	st.b	sp[1723],r8
800085e6:	50 2e       	stdsp	sp[0x8],lr
800085e8:	e0 8f 08 ad 	bral	80009742 <_vfprintf_r+0x1652>
800085ec:	50 a7       	stdsp	sp[0x28],r7
800085ee:	50 80       	stdsp	sp[0x20],r0
800085f0:	0c 97       	mov	r7,r6
800085f2:	04 94       	mov	r4,r2
800085f4:	06 96       	mov	r6,r3
800085f6:	02 92       	mov	r2,r1
800085f8:	40 93       	lddsp	r3,sp[0x24]
800085fa:	10 90       	mov	r0,r8
800085fc:	40 41       	lddsp	r1,sp[0x10]
800085fe:	a5 a5       	sbr	r5,0x4
80008600:	c0 a8       	rjmp	80008614 <_vfprintf_r+0x524>
80008602:	50 a7       	stdsp	sp[0x28],r7
80008604:	50 80       	stdsp	sp[0x20],r0
80008606:	0c 97       	mov	r7,r6
80008608:	04 94       	mov	r4,r2
8000860a:	06 96       	mov	r6,r3
8000860c:	02 92       	mov	r2,r1
8000860e:	40 93       	lddsp	r3,sp[0x24]
80008610:	10 90       	mov	r0,r8
80008612:	40 41       	lddsp	r1,sp[0x10]
80008614:	ed b5 00 05 	bld	r5,0x5
80008618:	c5 11       	brne	800086ba <_vfprintf_r+0x5ca>
8000861a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000861e:	40 3c       	lddsp	r12,sp[0xc]
80008620:	58 0c       	cp.w	r12,0
80008622:	c1 e0       	breq	8000865e <_vfprintf_r+0x56e>
80008624:	10 36       	cp.w	r6,r8
80008626:	c0 64       	brge	80008632 <_vfprintf_r+0x542>
80008628:	fa cb f9 44 	sub	r11,sp,-1724
8000862c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008630:	c2 08       	rjmp	80008670 <_vfprintf_r+0x580>
80008632:	fa c8 f9 50 	sub	r8,sp,-1712
80008636:	1a d8       	st.w	--sp,r8
80008638:	fa c8 fa b8 	sub	r8,sp,-1352
8000863c:	0c 9b       	mov	r11,r6
8000863e:	1a d8       	st.w	--sp,r8
80008640:	fa c8 fb b4 	sub	r8,sp,-1100
80008644:	1a d8       	st.w	--sp,r8
80008646:	fa c9 ff b4 	sub	r9,sp,-76
8000864a:	fa c8 f9 40 	sub	r8,sp,-1728
8000864e:	04 9a       	mov	r10,r2
80008650:	08 9c       	mov	r12,r4
80008652:	fe b0 fb b7 	rcall	80007dc0 <get_arg>
80008656:	2f dd       	sub	sp,-12
80008658:	78 1b       	ld.w	r11,r12[0x4]
8000865a:	78 09       	ld.w	r9,r12[0x0]
8000865c:	c2 b8       	rjmp	800086b2 <_vfprintf_r+0x5c2>
8000865e:	ee ca ff ff 	sub	r10,r7,-1
80008662:	10 37       	cp.w	r7,r8
80008664:	c0 b4       	brge	8000867a <_vfprintf_r+0x58a>
80008666:	fa c9 f9 44 	sub	r9,sp,-1724
8000866a:	14 97       	mov	r7,r10
8000866c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008670:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008674:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008678:	c1 d8       	rjmp	800086b2 <_vfprintf_r+0x5c2>
8000867a:	41 09       	lddsp	r9,sp[0x40]
8000867c:	59 f8       	cp.w	r8,31
8000867e:	e0 89 00 14 	brgt	800086a6 <_vfprintf_r+0x5b6>
80008682:	f2 cb ff f8 	sub	r11,r9,-8
80008686:	51 0b       	stdsp	sp[0x40],r11
80008688:	fa c6 f9 44 	sub	r6,sp,-1724
8000868c:	72 1b       	ld.w	r11,r9[0x4]
8000868e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008692:	72 09       	ld.w	r9,r9[0x0]
80008694:	f9 4b fd 8c 	st.w	r12[-628],r11
80008698:	f9 49 fd 88 	st.w	r12[-632],r9
8000869c:	2f f8       	sub	r8,-1
8000869e:	14 97       	mov	r7,r10
800086a0:	fb 48 06 b4 	st.w	sp[1716],r8
800086a4:	c0 78       	rjmp	800086b2 <_vfprintf_r+0x5c2>
800086a6:	f2 c8 ff f8 	sub	r8,r9,-8
800086aa:	72 1b       	ld.w	r11,r9[0x4]
800086ac:	14 97       	mov	r7,r10
800086ae:	51 08       	stdsp	sp[0x40],r8
800086b0:	72 09       	ld.w	r9,r9[0x0]
800086b2:	16 98       	mov	r8,r11
800086b4:	fa e9 00 00 	st.d	sp[0],r8
800086b8:	ca e8       	rjmp	80008814 <_vfprintf_r+0x724>
800086ba:	ed b5 00 04 	bld	r5,0x4
800086be:	c1 71       	brne	800086ec <_vfprintf_r+0x5fc>
800086c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086c4:	40 3e       	lddsp	lr,sp[0xc]
800086c6:	58 0e       	cp.w	lr,0
800086c8:	c0 80       	breq	800086d8 <_vfprintf_r+0x5e8>
800086ca:	10 36       	cp.w	r6,r8
800086cc:	c6 94       	brge	8000879e <_vfprintf_r+0x6ae>
800086ce:	fa cc f9 44 	sub	r12,sp,-1724
800086d2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086d6:	c8 28       	rjmp	800087da <_vfprintf_r+0x6ea>
800086d8:	ee ca ff ff 	sub	r10,r7,-1
800086dc:	10 37       	cp.w	r7,r8
800086de:	e0 84 00 81 	brge	800087e0 <_vfprintf_r+0x6f0>
800086e2:	fa cb f9 44 	sub	r11,sp,-1724
800086e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086ea:	c7 78       	rjmp	800087d8 <_vfprintf_r+0x6e8>
800086ec:	ed b5 00 06 	bld	r5,0x6
800086f0:	c4 b1       	brne	80008786 <_vfprintf_r+0x696>
800086f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f6:	40 3c       	lddsp	r12,sp[0xc]
800086f8:	58 0c       	cp.w	r12,0
800086fa:	c1 d0       	breq	80008734 <_vfprintf_r+0x644>
800086fc:	10 36       	cp.w	r6,r8
800086fe:	c0 64       	brge	8000870a <_vfprintf_r+0x61a>
80008700:	fa cb f9 44 	sub	r11,sp,-1724
80008704:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008708:	c1 f8       	rjmp	80008746 <_vfprintf_r+0x656>
8000870a:	fa c8 f9 50 	sub	r8,sp,-1712
8000870e:	1a d8       	st.w	--sp,r8
80008710:	fa c8 fa b8 	sub	r8,sp,-1352
80008714:	1a d8       	st.w	--sp,r8
80008716:	fa c8 fb b4 	sub	r8,sp,-1100
8000871a:	1a d8       	st.w	--sp,r8
8000871c:	fa c8 f9 40 	sub	r8,sp,-1728
80008720:	fa c9 ff b4 	sub	r9,sp,-76
80008724:	04 9a       	mov	r10,r2
80008726:	0c 9b       	mov	r11,r6
80008728:	08 9c       	mov	r12,r4
8000872a:	fe b0 fb 4b 	rcall	80007dc0 <get_arg>
8000872e:	2f dd       	sub	sp,-12
80008730:	98 18       	ld.sh	r8,r12[0x2]
80008732:	c2 68       	rjmp	8000877e <_vfprintf_r+0x68e>
80008734:	ee ca ff ff 	sub	r10,r7,-1
80008738:	10 37       	cp.w	r7,r8
8000873a:	c0 94       	brge	8000874c <_vfprintf_r+0x65c>
8000873c:	fa c9 f9 44 	sub	r9,sp,-1724
80008740:	14 97       	mov	r7,r10
80008742:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008746:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000874a:	c1 a8       	rjmp	8000877e <_vfprintf_r+0x68e>
8000874c:	41 09       	lddsp	r9,sp[0x40]
8000874e:	59 f8       	cp.w	r8,31
80008750:	e0 89 00 13 	brgt	80008776 <_vfprintf_r+0x686>
80008754:	f2 cb ff fc 	sub	r11,r9,-4
80008758:	51 0b       	stdsp	sp[0x40],r11
8000875a:	72 09       	ld.w	r9,r9[0x0]
8000875c:	fa c6 f9 44 	sub	r6,sp,-1724
80008760:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008764:	2f f8       	sub	r8,-1
80008766:	f7 49 fd 88 	st.w	r11[-632],r9
8000876a:	fb 48 06 b4 	st.w	sp[1716],r8
8000876e:	14 97       	mov	r7,r10
80008770:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008774:	c0 58       	rjmp	8000877e <_vfprintf_r+0x68e>
80008776:	92 18       	ld.sh	r8,r9[0x2]
80008778:	14 97       	mov	r7,r10
8000877a:	2f c9       	sub	r9,-4
8000877c:	51 09       	stdsp	sp[0x40],r9
8000877e:	50 18       	stdsp	sp[0x4],r8
80008780:	bf 58       	asr	r8,0x1f
80008782:	50 08       	stdsp	sp[0x0],r8
80008784:	c4 88       	rjmp	80008814 <_vfprintf_r+0x724>
80008786:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000878a:	40 3c       	lddsp	r12,sp[0xc]
8000878c:	58 0c       	cp.w	r12,0
8000878e:	c1 d0       	breq	800087c8 <_vfprintf_r+0x6d8>
80008790:	10 36       	cp.w	r6,r8
80008792:	c0 64       	brge	8000879e <_vfprintf_r+0x6ae>
80008794:	fa cb f9 44 	sub	r11,sp,-1724
80008798:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000879c:	c1 f8       	rjmp	800087da <_vfprintf_r+0x6ea>
8000879e:	fa c8 f9 50 	sub	r8,sp,-1712
800087a2:	1a d8       	st.w	--sp,r8
800087a4:	fa c8 fa b8 	sub	r8,sp,-1352
800087a8:	0c 9b       	mov	r11,r6
800087aa:	1a d8       	st.w	--sp,r8
800087ac:	fa c8 fb b4 	sub	r8,sp,-1100
800087b0:	04 9a       	mov	r10,r2
800087b2:	1a d8       	st.w	--sp,r8
800087b4:	08 9c       	mov	r12,r4
800087b6:	fa c8 f9 40 	sub	r8,sp,-1728
800087ba:	fa c9 ff b4 	sub	r9,sp,-76
800087be:	fe b0 fb 01 	rcall	80007dc0 <get_arg>
800087c2:	2f dd       	sub	sp,-12
800087c4:	78 0b       	ld.w	r11,r12[0x0]
800087c6:	c2 48       	rjmp	8000880e <_vfprintf_r+0x71e>
800087c8:	ee ca ff ff 	sub	r10,r7,-1
800087cc:	10 37       	cp.w	r7,r8
800087ce:	c0 94       	brge	800087e0 <_vfprintf_r+0x6f0>
800087d0:	fa c9 f9 44 	sub	r9,sp,-1724
800087d4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087d8:	14 97       	mov	r7,r10
800087da:	ec fb fd 88 	ld.w	r11,r6[-632]
800087de:	c1 88       	rjmp	8000880e <_vfprintf_r+0x71e>
800087e0:	41 09       	lddsp	r9,sp[0x40]
800087e2:	59 f8       	cp.w	r8,31
800087e4:	e0 89 00 11 	brgt	80008806 <_vfprintf_r+0x716>
800087e8:	f2 cb ff fc 	sub	r11,r9,-4
800087ec:	51 0b       	stdsp	sp[0x40],r11
800087ee:	fa c6 f9 44 	sub	r6,sp,-1724
800087f2:	72 0b       	ld.w	r11,r9[0x0]
800087f4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087f8:	f3 4b fd 88 	st.w	r9[-632],r11
800087fc:	2f f8       	sub	r8,-1
800087fe:	14 97       	mov	r7,r10
80008800:	fb 48 06 b4 	st.w	sp[1716],r8
80008804:	c0 58       	rjmp	8000880e <_vfprintf_r+0x71e>
80008806:	72 0b       	ld.w	r11,r9[0x0]
80008808:	14 97       	mov	r7,r10
8000880a:	2f c9       	sub	r9,-4
8000880c:	51 09       	stdsp	sp[0x40],r9
8000880e:	50 1b       	stdsp	sp[0x4],r11
80008810:	bf 5b       	asr	r11,0x1f
80008812:	50 0b       	stdsp	sp[0x0],r11
80008814:	fa ea 00 00 	ld.d	r10,sp[0]
80008818:	58 0a       	cp.w	r10,0
8000881a:	5c 2b       	cpc	r11
8000881c:	c0 e4       	brge	80008838 <_vfprintf_r+0x748>
8000881e:	30 08       	mov	r8,0
80008820:	fa ea 00 00 	ld.d	r10,sp[0]
80008824:	30 09       	mov	r9,0
80008826:	f0 0a 01 0a 	sub	r10,r8,r10
8000882a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000882e:	32 d8       	mov	r8,45
80008830:	fa eb 00 00 	st.d	sp[0],r10
80008834:	fb 68 06 bb 	st.b	sp[1723],r8
80008838:	30 18       	mov	r8,1
8000883a:	e0 8f 06 fa 	bral	8000962e <_vfprintf_r+0x153e>
8000883e:	50 a7       	stdsp	sp[0x28],r7
80008840:	50 80       	stdsp	sp[0x20],r0
80008842:	0c 97       	mov	r7,r6
80008844:	04 94       	mov	r4,r2
80008846:	06 96       	mov	r6,r3
80008848:	02 92       	mov	r2,r1
8000884a:	40 93       	lddsp	r3,sp[0x24]
8000884c:	10 90       	mov	r0,r8
8000884e:	40 41       	lddsp	r1,sp[0x10]
80008850:	0e 99       	mov	r9,r7
80008852:	ed b5 00 03 	bld	r5,0x3
80008856:	c4 11       	brne	800088d8 <_vfprintf_r+0x7e8>
80008858:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000885c:	40 3a       	lddsp	r10,sp[0xc]
8000885e:	58 0a       	cp.w	r10,0
80008860:	c1 90       	breq	80008892 <_vfprintf_r+0x7a2>
80008862:	10 36       	cp.w	r6,r8
80008864:	c6 45       	brlt	8000892c <_vfprintf_r+0x83c>
80008866:	fa c8 f9 50 	sub	r8,sp,-1712
8000886a:	1a d8       	st.w	--sp,r8
8000886c:	fa c8 fa b8 	sub	r8,sp,-1352
80008870:	1a d8       	st.w	--sp,r8
80008872:	fa c8 fb b4 	sub	r8,sp,-1100
80008876:	0c 9b       	mov	r11,r6
80008878:	1a d8       	st.w	--sp,r8
8000887a:	04 9a       	mov	r10,r2
8000887c:	fa c8 f9 40 	sub	r8,sp,-1728
80008880:	fa c9 ff b4 	sub	r9,sp,-76
80008884:	08 9c       	mov	r12,r4
80008886:	fe b0 fa 9d 	rcall	80007dc0 <get_arg>
8000888a:	2f dd       	sub	sp,-12
8000888c:	78 16       	ld.w	r6,r12[0x4]
8000888e:	50 76       	stdsp	sp[0x1c],r6
80008890:	c4 88       	rjmp	80008920 <_vfprintf_r+0x830>
80008892:	2f f7       	sub	r7,-1
80008894:	10 39       	cp.w	r9,r8
80008896:	c0 c4       	brge	800088ae <_vfprintf_r+0x7be>
80008898:	fa ce f9 44 	sub	lr,sp,-1724
8000889c:	fc 06 00 36 	add	r6,lr,r6<<0x3
800088a0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800088a4:	50 7c       	stdsp	sp[0x1c],r12
800088a6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088aa:	50 56       	stdsp	sp[0x14],r6
800088ac:	c6 68       	rjmp	80008978 <_vfprintf_r+0x888>
800088ae:	41 09       	lddsp	r9,sp[0x40]
800088b0:	59 f8       	cp.w	r8,31
800088b2:	e0 89 00 10 	brgt	800088d2 <_vfprintf_r+0x7e2>
800088b6:	f2 ca ff f8 	sub	r10,r9,-8
800088ba:	72 1b       	ld.w	r11,r9[0x4]
800088bc:	51 0a       	stdsp	sp[0x40],r10
800088be:	72 09       	ld.w	r9,r9[0x0]
800088c0:	fa ca f9 44 	sub	r10,sp,-1724
800088c4:	50 7b       	stdsp	sp[0x1c],r11
800088c6:	50 59       	stdsp	sp[0x14],r9
800088c8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800088cc:	40 5b       	lddsp	r11,sp[0x14]
800088ce:	40 7a       	lddsp	r10,sp[0x1c]
800088d0:	c4 78       	rjmp	8000895e <_vfprintf_r+0x86e>
800088d2:	72 18       	ld.w	r8,r9[0x4]
800088d4:	50 78       	stdsp	sp[0x1c],r8
800088d6:	c4 c8       	rjmp	8000896e <_vfprintf_r+0x87e>
800088d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088dc:	40 3e       	lddsp	lr,sp[0xc]
800088de:	58 0e       	cp.w	lr,0
800088e0:	c2 30       	breq	80008926 <_vfprintf_r+0x836>
800088e2:	10 36       	cp.w	r6,r8
800088e4:	c0 94       	brge	800088f6 <_vfprintf_r+0x806>
800088e6:	fa cc f9 44 	sub	r12,sp,-1724
800088ea:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088ee:	ec fb fd 8c 	ld.w	r11,r6[-628]
800088f2:	50 7b       	stdsp	sp[0x1c],r11
800088f4:	cd 9b       	rjmp	800088a6 <_vfprintf_r+0x7b6>
800088f6:	fa c8 f9 50 	sub	r8,sp,-1712
800088fa:	1a d8       	st.w	--sp,r8
800088fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008900:	04 9a       	mov	r10,r2
80008902:	1a d8       	st.w	--sp,r8
80008904:	fa c8 fb b4 	sub	r8,sp,-1100
80008908:	0c 9b       	mov	r11,r6
8000890a:	1a d8       	st.w	--sp,r8
8000890c:	08 9c       	mov	r12,r4
8000890e:	fa c8 f9 40 	sub	r8,sp,-1728
80008912:	fa c9 ff b4 	sub	r9,sp,-76
80008916:	fe b0 fa 55 	rcall	80007dc0 <get_arg>
8000891a:	2f dd       	sub	sp,-12
8000891c:	78 1a       	ld.w	r10,r12[0x4]
8000891e:	50 7a       	stdsp	sp[0x1c],r10
80008920:	78 0c       	ld.w	r12,r12[0x0]
80008922:	50 5c       	stdsp	sp[0x14],r12
80008924:	c2 a8       	rjmp	80008978 <_vfprintf_r+0x888>
80008926:	2f f7       	sub	r7,-1
80008928:	10 39       	cp.w	r9,r8
8000892a:	c0 94       	brge	8000893c <_vfprintf_r+0x84c>
8000892c:	fa c9 f9 44 	sub	r9,sp,-1724
80008930:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008934:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008938:	50 78       	stdsp	sp[0x1c],r8
8000893a:	cb 6b       	rjmp	800088a6 <_vfprintf_r+0x7b6>
8000893c:	41 09       	lddsp	r9,sp[0x40]
8000893e:	59 f8       	cp.w	r8,31
80008940:	e0 89 00 15 	brgt	8000896a <_vfprintf_r+0x87a>
80008944:	f2 ca ff f8 	sub	r10,r9,-8
80008948:	72 16       	ld.w	r6,r9[0x4]
8000894a:	72 09       	ld.w	r9,r9[0x0]
8000894c:	51 0a       	stdsp	sp[0x40],r10
8000894e:	50 59       	stdsp	sp[0x14],r9
80008950:	fa ce f9 44 	sub	lr,sp,-1724
80008954:	50 76       	stdsp	sp[0x1c],r6
80008956:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000895a:	40 5b       	lddsp	r11,sp[0x14]
8000895c:	0c 9a       	mov	r10,r6
8000895e:	f2 eb fd 88 	st.d	r9[-632],r10
80008962:	2f f8       	sub	r8,-1
80008964:	fb 48 06 b4 	st.w	sp[1716],r8
80008968:	c0 88       	rjmp	80008978 <_vfprintf_r+0x888>
8000896a:	72 1c       	ld.w	r12,r9[0x4]
8000896c:	50 7c       	stdsp	sp[0x1c],r12
8000896e:	f2 c8 ff f8 	sub	r8,r9,-8
80008972:	51 08       	stdsp	sp[0x40],r8
80008974:	72 09       	ld.w	r9,r9[0x0]
80008976:	50 59       	stdsp	sp[0x14],r9
80008978:	40 5b       	lddsp	r11,sp[0x14]
8000897a:	40 7a       	lddsp	r10,sp[0x1c]
8000897c:	e0 a0 19 54 	rcall	8000bc24 <__isinfd>
80008980:	18 96       	mov	r6,r12
80008982:	c1 70       	breq	800089b0 <_vfprintf_r+0x8c0>
80008984:	30 08       	mov	r8,0
80008986:	30 09       	mov	r9,0
80008988:	40 5b       	lddsp	r11,sp[0x14]
8000898a:	40 7a       	lddsp	r10,sp[0x1c]
8000898c:	e0 a0 1d b4 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
80008990:	c0 40       	breq	80008998 <_vfprintf_r+0x8a8>
80008992:	32 d8       	mov	r8,45
80008994:	fb 68 06 bb 	st.b	sp[1723],r8
80008998:	fe c8 aa 14 	sub	r8,pc,-21996
8000899c:	fe c6 aa 14 	sub	r6,pc,-21996
800089a0:	a7 d5       	cbr	r5,0x7
800089a2:	e0 40 00 47 	cp.w	r0,71
800089a6:	f0 06 17 a0 	movle	r6,r8
800089aa:	30 32       	mov	r2,3
800089ac:	e0 8f 06 ce 	bral	80009748 <_vfprintf_r+0x1658>
800089b0:	40 5b       	lddsp	r11,sp[0x14]
800089b2:	40 7a       	lddsp	r10,sp[0x1c]
800089b4:	e0 a0 19 4d 	rcall	8000bc4e <__isnand>
800089b8:	c0 e0       	breq	800089d4 <_vfprintf_r+0x8e4>
800089ba:	50 26       	stdsp	sp[0x8],r6
800089bc:	fe c8 aa 30 	sub	r8,pc,-21968
800089c0:	fe c6 aa 30 	sub	r6,pc,-21968
800089c4:	a7 d5       	cbr	r5,0x7
800089c6:	e0 40 00 47 	cp.w	r0,71
800089ca:	f0 06 17 a0 	movle	r6,r8
800089ce:	30 32       	mov	r2,3
800089d0:	e0 8f 06 c2 	bral	80009754 <_vfprintf_r+0x1664>
800089d4:	40 2a       	lddsp	r10,sp[0x8]
800089d6:	5b fa       	cp.w	r10,-1
800089d8:	c0 41       	brne	800089e0 <_vfprintf_r+0x8f0>
800089da:	30 69       	mov	r9,6
800089dc:	50 29       	stdsp	sp[0x8],r9
800089de:	c1 18       	rjmp	80008a00 <_vfprintf_r+0x910>
800089e0:	e0 40 00 47 	cp.w	r0,71
800089e4:	5f 09       	sreq	r9
800089e6:	e0 40 00 67 	cp.w	r0,103
800089ea:	5f 08       	sreq	r8
800089ec:	f3 e8 10 08 	or	r8,r9,r8
800089f0:	f8 08 18 00 	cp.b	r8,r12
800089f4:	c0 60       	breq	80008a00 <_vfprintf_r+0x910>
800089f6:	40 28       	lddsp	r8,sp[0x8]
800089f8:	58 08       	cp.w	r8,0
800089fa:	f9 b8 00 01 	moveq	r8,1
800089fe:	50 28       	stdsp	sp[0x8],r8
80008a00:	40 78       	lddsp	r8,sp[0x1c]
80008a02:	40 59       	lddsp	r9,sp[0x14]
80008a04:	fa e9 06 94 	st.d	sp[1684],r8
80008a08:	a9 a5       	sbr	r5,0x8
80008a0a:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a0e:	58 08       	cp.w	r8,0
80008a10:	c0 65       	brlt	80008a1c <_vfprintf_r+0x92c>
80008a12:	40 5e       	lddsp	lr,sp[0x14]
80008a14:	30 0c       	mov	r12,0
80008a16:	50 6e       	stdsp	sp[0x18],lr
80008a18:	50 9c       	stdsp	sp[0x24],r12
80008a1a:	c0 78       	rjmp	80008a28 <_vfprintf_r+0x938>
80008a1c:	40 5b       	lddsp	r11,sp[0x14]
80008a1e:	32 da       	mov	r10,45
80008a20:	ee 1b 80 00 	eorh	r11,0x8000
80008a24:	50 9a       	stdsp	sp[0x24],r10
80008a26:	50 6b       	stdsp	sp[0x18],r11
80008a28:	e0 40 00 46 	cp.w	r0,70
80008a2c:	5f 09       	sreq	r9
80008a2e:	e0 40 00 66 	cp.w	r0,102
80008a32:	5f 08       	sreq	r8
80008a34:	f3 e8 10 08 	or	r8,r9,r8
80008a38:	50 48       	stdsp	sp[0x10],r8
80008a3a:	c0 40       	breq	80008a42 <_vfprintf_r+0x952>
80008a3c:	40 22       	lddsp	r2,sp[0x8]
80008a3e:	30 39       	mov	r9,3
80008a40:	c1 08       	rjmp	80008a60 <_vfprintf_r+0x970>
80008a42:	e0 40 00 45 	cp.w	r0,69
80008a46:	5f 09       	sreq	r9
80008a48:	e0 40 00 65 	cp.w	r0,101
80008a4c:	5f 08       	sreq	r8
80008a4e:	40 22       	lddsp	r2,sp[0x8]
80008a50:	10 49       	or	r9,r8
80008a52:	2f f2       	sub	r2,-1
80008a54:	40 46       	lddsp	r6,sp[0x10]
80008a56:	ec 09 18 00 	cp.b	r9,r6
80008a5a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a5e:	30 29       	mov	r9,2
80008a60:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a64:	1a d8       	st.w	--sp,r8
80008a66:	fa c8 f9 54 	sub	r8,sp,-1708
80008a6a:	1a d8       	st.w	--sp,r8
80008a6c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a70:	08 9c       	mov	r12,r4
80008a72:	1a d8       	st.w	--sp,r8
80008a74:	04 98       	mov	r8,r2
80008a76:	40 9b       	lddsp	r11,sp[0x24]
80008a78:	40 aa       	lddsp	r10,sp[0x28]
80008a7a:	e0 a0 0b c3 	rcall	8000a200 <_dtoa_r>
80008a7e:	e0 40 00 47 	cp.w	r0,71
80008a82:	5f 19       	srne	r9
80008a84:	e0 40 00 67 	cp.w	r0,103
80008a88:	5f 18       	srne	r8
80008a8a:	18 96       	mov	r6,r12
80008a8c:	2f dd       	sub	sp,-12
80008a8e:	f3 e8 00 08 	and	r8,r9,r8
80008a92:	c0 41       	brne	80008a9a <_vfprintf_r+0x9aa>
80008a94:	ed b5 00 00 	bld	r5,0x0
80008a98:	c3 01       	brne	80008af8 <_vfprintf_r+0xa08>
80008a9a:	ec 02 00 0e 	add	lr,r6,r2
80008a9e:	50 3e       	stdsp	sp[0xc],lr
80008aa0:	40 4c       	lddsp	r12,sp[0x10]
80008aa2:	58 0c       	cp.w	r12,0
80008aa4:	c1 50       	breq	80008ace <_vfprintf_r+0x9de>
80008aa6:	0d 89       	ld.ub	r9,r6[0x0]
80008aa8:	33 08       	mov	r8,48
80008aaa:	f0 09 18 00 	cp.b	r9,r8
80008aae:	c0 b1       	brne	80008ac4 <_vfprintf_r+0x9d4>
80008ab0:	30 08       	mov	r8,0
80008ab2:	30 09       	mov	r9,0
80008ab4:	40 6b       	lddsp	r11,sp[0x18]
80008ab6:	40 7a       	lddsp	r10,sp[0x1c]
80008ab8:	e0 a0 1c d7 	rcall	8000c466 <__avr32_f64_cmp_eq>
80008abc:	fb b2 00 01 	rsubeq	r2,1
80008ac0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008ac4:	40 3b       	lddsp	r11,sp[0xc]
80008ac6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008aca:	10 0b       	add	r11,r8
80008acc:	50 3b       	stdsp	sp[0xc],r11
80008ace:	40 6b       	lddsp	r11,sp[0x18]
80008ad0:	30 08       	mov	r8,0
80008ad2:	30 09       	mov	r9,0
80008ad4:	40 7a       	lddsp	r10,sp[0x1c]
80008ad6:	e0 a0 1c c8 	rcall	8000c466 <__avr32_f64_cmp_eq>
80008ada:	c0 90       	breq	80008aec <_vfprintf_r+0x9fc>
80008adc:	40 3a       	lddsp	r10,sp[0xc]
80008ade:	fb 4a 06 a4 	st.w	sp[1700],r10
80008ae2:	c0 58       	rjmp	80008aec <_vfprintf_r+0x9fc>
80008ae4:	10 c9       	st.b	r8++,r9
80008ae6:	fb 48 06 a4 	st.w	sp[1700],r8
80008aea:	c0 28       	rjmp	80008aee <_vfprintf_r+0x9fe>
80008aec:	33 09       	mov	r9,48
80008aee:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008af2:	40 3e       	lddsp	lr,sp[0xc]
80008af4:	1c 38       	cp.w	r8,lr
80008af6:	cf 73       	brcs	80008ae4 <_vfprintf_r+0x9f4>
80008af8:	e0 40 00 47 	cp.w	r0,71
80008afc:	5f 09       	sreq	r9
80008afe:	e0 40 00 67 	cp.w	r0,103
80008b02:	5f 08       	sreq	r8
80008b04:	f3 e8 10 08 	or	r8,r9,r8
80008b08:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b0c:	0c 19       	sub	r9,r6
80008b0e:	50 69       	stdsp	sp[0x18],r9
80008b10:	58 08       	cp.w	r8,0
80008b12:	c0 b0       	breq	80008b28 <_vfprintf_r+0xa38>
80008b14:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b18:	5b d8       	cp.w	r8,-3
80008b1a:	c0 55       	brlt	80008b24 <_vfprintf_r+0xa34>
80008b1c:	40 2c       	lddsp	r12,sp[0x8]
80008b1e:	18 38       	cp.w	r8,r12
80008b20:	e0 8a 00 6a 	brle	80008bf4 <_vfprintf_r+0xb04>
80008b24:	20 20       	sub	r0,2
80008b26:	c0 58       	rjmp	80008b30 <_vfprintf_r+0xa40>
80008b28:	e0 40 00 65 	cp.w	r0,101
80008b2c:	e0 89 00 46 	brgt	80008bb8 <_vfprintf_r+0xac8>
80008b30:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b34:	fb 60 06 9c 	st.b	sp[1692],r0
80008b38:	20 1b       	sub	r11,1
80008b3a:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b3e:	c0 47       	brpl	80008b46 <_vfprintf_r+0xa56>
80008b40:	5c 3b       	neg	r11
80008b42:	32 d8       	mov	r8,45
80008b44:	c0 28       	rjmp	80008b48 <_vfprintf_r+0xa58>
80008b46:	32 b8       	mov	r8,43
80008b48:	fb 68 06 9d 	st.b	sp[1693],r8
80008b4c:	58 9b       	cp.w	r11,9
80008b4e:	e0 8a 00 1d 	brle	80008b88 <_vfprintf_r+0xa98>
80008b52:	fa c9 fa 35 	sub	r9,sp,-1483
80008b56:	30 aa       	mov	r10,10
80008b58:	12 98       	mov	r8,r9
80008b5a:	0e 9c       	mov	r12,r7
80008b5c:	0c 92       	mov	r2,r6
80008b5e:	f6 0a 0c 06 	divs	r6,r11,r10
80008b62:	0e 9b       	mov	r11,r7
80008b64:	2d 0b       	sub	r11,-48
80008b66:	10 fb       	st.b	--r8,r11
80008b68:	0c 9b       	mov	r11,r6
80008b6a:	58 96       	cp.w	r6,9
80008b6c:	fe 99 ff f9 	brgt	80008b5e <_vfprintf_r+0xa6e>
80008b70:	2d 0b       	sub	r11,-48
80008b72:	18 97       	mov	r7,r12
80008b74:	04 96       	mov	r6,r2
80008b76:	10 fb       	st.b	--r8,r11
80008b78:	fa ca f9 62 	sub	r10,sp,-1694
80008b7c:	c0 38       	rjmp	80008b82 <_vfprintf_r+0xa92>
80008b7e:	11 3b       	ld.ub	r11,r8++
80008b80:	14 cb       	st.b	r10++,r11
80008b82:	12 38       	cp.w	r8,r9
80008b84:	cf d3       	brcs	80008b7e <_vfprintf_r+0xa8e>
80008b86:	c0 98       	rjmp	80008b98 <_vfprintf_r+0xaa8>
80008b88:	2d 0b       	sub	r11,-48
80008b8a:	33 08       	mov	r8,48
80008b8c:	fb 6b 06 9f 	st.b	sp[1695],r11
80008b90:	fb 68 06 9e 	st.b	sp[1694],r8
80008b94:	fa ca f9 60 	sub	r10,sp,-1696
80008b98:	fa c8 f9 64 	sub	r8,sp,-1692
80008b9c:	f4 08 01 08 	sub	r8,r10,r8
80008ba0:	50 e8       	stdsp	sp[0x38],r8
80008ba2:	10 92       	mov	r2,r8
80008ba4:	40 6b       	lddsp	r11,sp[0x18]
80008ba6:	16 02       	add	r2,r11
80008ba8:	58 1b       	cp.w	r11,1
80008baa:	e0 89 00 05 	brgt	80008bb4 <_vfprintf_r+0xac4>
80008bae:	ed b5 00 00 	bld	r5,0x0
80008bb2:	c3 51       	brne	80008c1c <_vfprintf_r+0xb2c>
80008bb4:	2f f2       	sub	r2,-1
80008bb6:	c3 38       	rjmp	80008c1c <_vfprintf_r+0xb2c>
80008bb8:	e0 40 00 66 	cp.w	r0,102
80008bbc:	c1 c1       	brne	80008bf4 <_vfprintf_r+0xb04>
80008bbe:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bc2:	58 02       	cp.w	r2,0
80008bc4:	e0 8a 00 0c 	brle	80008bdc <_vfprintf_r+0xaec>
80008bc8:	40 2a       	lddsp	r10,sp[0x8]
80008bca:	58 0a       	cp.w	r10,0
80008bcc:	c0 41       	brne	80008bd4 <_vfprintf_r+0xae4>
80008bce:	ed b5 00 00 	bld	r5,0x0
80008bd2:	c2 51       	brne	80008c1c <_vfprintf_r+0xb2c>
80008bd4:	2f f2       	sub	r2,-1
80008bd6:	40 29       	lddsp	r9,sp[0x8]
80008bd8:	12 02       	add	r2,r9
80008bda:	c0 b8       	rjmp	80008bf0 <_vfprintf_r+0xb00>
80008bdc:	40 28       	lddsp	r8,sp[0x8]
80008bde:	58 08       	cp.w	r8,0
80008be0:	c0 61       	brne	80008bec <_vfprintf_r+0xafc>
80008be2:	ed b5 00 00 	bld	r5,0x0
80008be6:	c0 30       	breq	80008bec <_vfprintf_r+0xafc>
80008be8:	30 12       	mov	r2,1
80008bea:	c1 98       	rjmp	80008c1c <_vfprintf_r+0xb2c>
80008bec:	40 22       	lddsp	r2,sp[0x8]
80008bee:	2f e2       	sub	r2,-2
80008bf0:	36 60       	mov	r0,102
80008bf2:	c1 58       	rjmp	80008c1c <_vfprintf_r+0xb2c>
80008bf4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bf8:	40 6e       	lddsp	lr,sp[0x18]
80008bfa:	1c 32       	cp.w	r2,lr
80008bfc:	c0 65       	brlt	80008c08 <_vfprintf_r+0xb18>
80008bfe:	ed b5 00 00 	bld	r5,0x0
80008c02:	f7 b2 00 ff 	subeq	r2,-1
80008c06:	c0 a8       	rjmp	80008c1a <_vfprintf_r+0xb2a>
80008c08:	e4 08 11 02 	rsub	r8,r2,2
80008c0c:	40 6c       	lddsp	r12,sp[0x18]
80008c0e:	58 02       	cp.w	r2,0
80008c10:	f0 02 17 a0 	movle	r2,r8
80008c14:	f9 b2 09 01 	movgt	r2,1
80008c18:	18 02       	add	r2,r12
80008c1a:	36 70       	mov	r0,103
80008c1c:	40 9b       	lddsp	r11,sp[0x24]
80008c1e:	58 0b       	cp.w	r11,0
80008c20:	e0 80 05 94 	breq	80009748 <_vfprintf_r+0x1658>
80008c24:	32 d8       	mov	r8,45
80008c26:	fb 68 06 bb 	st.b	sp[1723],r8
80008c2a:	e0 8f 05 93 	bral	80009750 <_vfprintf_r+0x1660>
80008c2e:	50 a7       	stdsp	sp[0x28],r7
80008c30:	04 94       	mov	r4,r2
80008c32:	0c 97       	mov	r7,r6
80008c34:	02 92       	mov	r2,r1
80008c36:	06 96       	mov	r6,r3
80008c38:	40 41       	lddsp	r1,sp[0x10]
80008c3a:	40 93       	lddsp	r3,sp[0x24]
80008c3c:	0e 99       	mov	r9,r7
80008c3e:	ed b5 00 05 	bld	r5,0x5
80008c42:	c4 81       	brne	80008cd2 <_vfprintf_r+0xbe2>
80008c44:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c48:	40 3e       	lddsp	lr,sp[0xc]
80008c4a:	58 0e       	cp.w	lr,0
80008c4c:	c1 d0       	breq	80008c86 <_vfprintf_r+0xb96>
80008c4e:	10 36       	cp.w	r6,r8
80008c50:	c0 64       	brge	80008c5c <_vfprintf_r+0xb6c>
80008c52:	fa cc f9 44 	sub	r12,sp,-1724
80008c56:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c5a:	c1 d8       	rjmp	80008c94 <_vfprintf_r+0xba4>
80008c5c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c60:	1a d8       	st.w	--sp,r8
80008c62:	fa c8 fa b8 	sub	r8,sp,-1352
80008c66:	04 9a       	mov	r10,r2
80008c68:	1a d8       	st.w	--sp,r8
80008c6a:	fa c8 fb b4 	sub	r8,sp,-1100
80008c6e:	0c 9b       	mov	r11,r6
80008c70:	1a d8       	st.w	--sp,r8
80008c72:	08 9c       	mov	r12,r4
80008c74:	fa c8 f9 40 	sub	r8,sp,-1728
80008c78:	fa c9 ff b4 	sub	r9,sp,-76
80008c7c:	fe b0 f8 a2 	rcall	80007dc0 <get_arg>
80008c80:	2f dd       	sub	sp,-12
80008c82:	78 0a       	ld.w	r10,r12[0x0]
80008c84:	c2 08       	rjmp	80008cc4 <_vfprintf_r+0xbd4>
80008c86:	2f f7       	sub	r7,-1
80008c88:	10 39       	cp.w	r9,r8
80008c8a:	c0 84       	brge	80008c9a <_vfprintf_r+0xbaa>
80008c8c:	fa cb f9 44 	sub	r11,sp,-1724
80008c90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c94:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c98:	c1 68       	rjmp	80008cc4 <_vfprintf_r+0xbd4>
80008c9a:	41 09       	lddsp	r9,sp[0x40]
80008c9c:	59 f8       	cp.w	r8,31
80008c9e:	e0 89 00 10 	brgt	80008cbe <_vfprintf_r+0xbce>
80008ca2:	f2 ca ff fc 	sub	r10,r9,-4
80008ca6:	51 0a       	stdsp	sp[0x40],r10
80008ca8:	fa c6 f9 44 	sub	r6,sp,-1724
80008cac:	72 0a       	ld.w	r10,r9[0x0]
80008cae:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cb2:	f3 4a fd 88 	st.w	r9[-632],r10
80008cb6:	2f f8       	sub	r8,-1
80008cb8:	fb 48 06 b4 	st.w	sp[1716],r8
80008cbc:	c0 48       	rjmp	80008cc4 <_vfprintf_r+0xbd4>
80008cbe:	72 0a       	ld.w	r10,r9[0x0]
80008cc0:	2f c9       	sub	r9,-4
80008cc2:	51 09       	stdsp	sp[0x40],r9
80008cc4:	40 be       	lddsp	lr,sp[0x2c]
80008cc6:	1c 98       	mov	r8,lr
80008cc8:	95 1e       	st.w	r10[0x4],lr
80008cca:	bf 58       	asr	r8,0x1f
80008ccc:	95 08       	st.w	r10[0x0],r8
80008cce:	fe 9f fa 9f 	bral	8000820c <_vfprintf_r+0x11c>
80008cd2:	ed b5 00 04 	bld	r5,0x4
80008cd6:	c4 80       	breq	80008d66 <_vfprintf_r+0xc76>
80008cd8:	e2 15 00 40 	andl	r5,0x40,COH
80008cdc:	c4 50       	breq	80008d66 <_vfprintf_r+0xc76>
80008cde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ce2:	40 3c       	lddsp	r12,sp[0xc]
80008ce4:	58 0c       	cp.w	r12,0
80008ce6:	c1 d0       	breq	80008d20 <_vfprintf_r+0xc30>
80008ce8:	10 36       	cp.w	r6,r8
80008cea:	c0 64       	brge	80008cf6 <_vfprintf_r+0xc06>
80008cec:	fa cb f9 44 	sub	r11,sp,-1724
80008cf0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cf4:	c1 d8       	rjmp	80008d2e <_vfprintf_r+0xc3e>
80008cf6:	fa c8 f9 50 	sub	r8,sp,-1712
80008cfa:	1a d8       	st.w	--sp,r8
80008cfc:	fa c8 fa b8 	sub	r8,sp,-1352
80008d00:	04 9a       	mov	r10,r2
80008d02:	1a d8       	st.w	--sp,r8
80008d04:	fa c8 fb b4 	sub	r8,sp,-1100
80008d08:	0c 9b       	mov	r11,r6
80008d0a:	1a d8       	st.w	--sp,r8
80008d0c:	08 9c       	mov	r12,r4
80008d0e:	fa c8 f9 40 	sub	r8,sp,-1728
80008d12:	fa c9 ff b4 	sub	r9,sp,-76
80008d16:	fe b0 f8 55 	rcall	80007dc0 <get_arg>
80008d1a:	2f dd       	sub	sp,-12
80008d1c:	78 0a       	ld.w	r10,r12[0x0]
80008d1e:	c2 08       	rjmp	80008d5e <_vfprintf_r+0xc6e>
80008d20:	2f f7       	sub	r7,-1
80008d22:	10 39       	cp.w	r9,r8
80008d24:	c0 84       	brge	80008d34 <_vfprintf_r+0xc44>
80008d26:	fa ca f9 44 	sub	r10,sp,-1724
80008d2a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d2e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d32:	c1 68       	rjmp	80008d5e <_vfprintf_r+0xc6e>
80008d34:	41 09       	lddsp	r9,sp[0x40]
80008d36:	59 f8       	cp.w	r8,31
80008d38:	e0 89 00 10 	brgt	80008d58 <_vfprintf_r+0xc68>
80008d3c:	f2 ca ff fc 	sub	r10,r9,-4
80008d40:	51 0a       	stdsp	sp[0x40],r10
80008d42:	fa c6 f9 44 	sub	r6,sp,-1724
80008d46:	72 0a       	ld.w	r10,r9[0x0]
80008d48:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d4c:	f3 4a fd 88 	st.w	r9[-632],r10
80008d50:	2f f8       	sub	r8,-1
80008d52:	fb 48 06 b4 	st.w	sp[1716],r8
80008d56:	c0 48       	rjmp	80008d5e <_vfprintf_r+0xc6e>
80008d58:	72 0a       	ld.w	r10,r9[0x0]
80008d5a:	2f c9       	sub	r9,-4
80008d5c:	51 09       	stdsp	sp[0x40],r9
80008d5e:	40 be       	lddsp	lr,sp[0x2c]
80008d60:	b4 0e       	st.h	r10[0x0],lr
80008d62:	fe 9f fa 55 	bral	8000820c <_vfprintf_r+0x11c>
80008d66:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d6a:	40 3c       	lddsp	r12,sp[0xc]
80008d6c:	58 0c       	cp.w	r12,0
80008d6e:	c1 d0       	breq	80008da8 <_vfprintf_r+0xcb8>
80008d70:	10 36       	cp.w	r6,r8
80008d72:	c0 64       	brge	80008d7e <_vfprintf_r+0xc8e>
80008d74:	fa cb f9 44 	sub	r11,sp,-1724
80008d78:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d7c:	c1 d8       	rjmp	80008db6 <_vfprintf_r+0xcc6>
80008d7e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d82:	1a d8       	st.w	--sp,r8
80008d84:	fa c8 fa b8 	sub	r8,sp,-1352
80008d88:	04 9a       	mov	r10,r2
80008d8a:	1a d8       	st.w	--sp,r8
80008d8c:	fa c8 fb b4 	sub	r8,sp,-1100
80008d90:	0c 9b       	mov	r11,r6
80008d92:	1a d8       	st.w	--sp,r8
80008d94:	08 9c       	mov	r12,r4
80008d96:	fa c8 f9 40 	sub	r8,sp,-1728
80008d9a:	fa c9 ff b4 	sub	r9,sp,-76
80008d9e:	fe b0 f8 11 	rcall	80007dc0 <get_arg>
80008da2:	2f dd       	sub	sp,-12
80008da4:	78 0a       	ld.w	r10,r12[0x0]
80008da6:	c2 08       	rjmp	80008de6 <_vfprintf_r+0xcf6>
80008da8:	2f f7       	sub	r7,-1
80008daa:	10 39       	cp.w	r9,r8
80008dac:	c0 84       	brge	80008dbc <_vfprintf_r+0xccc>
80008dae:	fa ca f9 44 	sub	r10,sp,-1724
80008db2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008db6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008dba:	c1 68       	rjmp	80008de6 <_vfprintf_r+0xcf6>
80008dbc:	41 09       	lddsp	r9,sp[0x40]
80008dbe:	59 f8       	cp.w	r8,31
80008dc0:	e0 89 00 10 	brgt	80008de0 <_vfprintf_r+0xcf0>
80008dc4:	f2 ca ff fc 	sub	r10,r9,-4
80008dc8:	51 0a       	stdsp	sp[0x40],r10
80008dca:	fa c6 f9 44 	sub	r6,sp,-1724
80008dce:	72 0a       	ld.w	r10,r9[0x0]
80008dd0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dd4:	f3 4a fd 88 	st.w	r9[-632],r10
80008dd8:	2f f8       	sub	r8,-1
80008dda:	fb 48 06 b4 	st.w	sp[1716],r8
80008dde:	c0 48       	rjmp	80008de6 <_vfprintf_r+0xcf6>
80008de0:	72 0a       	ld.w	r10,r9[0x0]
80008de2:	2f c9       	sub	r9,-4
80008de4:	51 09       	stdsp	sp[0x40],r9
80008de6:	40 be       	lddsp	lr,sp[0x2c]
80008de8:	95 0e       	st.w	r10[0x0],lr
80008dea:	fe 9f fa 11 	bral	8000820c <_vfprintf_r+0x11c>
80008dee:	50 a7       	stdsp	sp[0x28],r7
80008df0:	50 80       	stdsp	sp[0x20],r0
80008df2:	0c 97       	mov	r7,r6
80008df4:	04 94       	mov	r4,r2
80008df6:	06 96       	mov	r6,r3
80008df8:	02 92       	mov	r2,r1
80008dfa:	40 93       	lddsp	r3,sp[0x24]
80008dfc:	10 90       	mov	r0,r8
80008dfe:	40 41       	lddsp	r1,sp[0x10]
80008e00:	a5 a5       	sbr	r5,0x4
80008e02:	c0 a8       	rjmp	80008e16 <_vfprintf_r+0xd26>
80008e04:	50 a7       	stdsp	sp[0x28],r7
80008e06:	50 80       	stdsp	sp[0x20],r0
80008e08:	0c 97       	mov	r7,r6
80008e0a:	04 94       	mov	r4,r2
80008e0c:	06 96       	mov	r6,r3
80008e0e:	02 92       	mov	r2,r1
80008e10:	40 93       	lddsp	r3,sp[0x24]
80008e12:	10 90       	mov	r0,r8
80008e14:	40 41       	lddsp	r1,sp[0x10]
80008e16:	ed b5 00 05 	bld	r5,0x5
80008e1a:	c5 d1       	brne	80008ed4 <_vfprintf_r+0xde4>
80008e1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e20:	40 3c       	lddsp	r12,sp[0xc]
80008e22:	58 0c       	cp.w	r12,0
80008e24:	c2 60       	breq	80008e70 <_vfprintf_r+0xd80>
80008e26:	10 36       	cp.w	r6,r8
80008e28:	c0 a4       	brge	80008e3c <_vfprintf_r+0xd4c>
80008e2a:	fa cb f9 44 	sub	r11,sp,-1724
80008e2e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e32:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e36:	fa e9 00 00 	st.d	sp[0],r8
80008e3a:	c1 88       	rjmp	80008e6a <_vfprintf_r+0xd7a>
80008e3c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e40:	1a d8       	st.w	--sp,r8
80008e42:	fa c8 fa b8 	sub	r8,sp,-1352
80008e46:	04 9a       	mov	r10,r2
80008e48:	1a d8       	st.w	--sp,r8
80008e4a:	0c 9b       	mov	r11,r6
80008e4c:	fa c8 fb b4 	sub	r8,sp,-1100
80008e50:	08 9c       	mov	r12,r4
80008e52:	1a d8       	st.w	--sp,r8
80008e54:	fa c8 f9 40 	sub	r8,sp,-1728
80008e58:	fa c9 ff b4 	sub	r9,sp,-76
80008e5c:	fe b0 f7 b2 	rcall	80007dc0 <get_arg>
80008e60:	2f dd       	sub	sp,-12
80008e62:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e66:	fa eb 00 00 	st.d	sp[0],r10
80008e6a:	30 08       	mov	r8,0
80008e6c:	e0 8f 03 de 	bral	80009628 <_vfprintf_r+0x1538>
80008e70:	ee ca ff ff 	sub	r10,r7,-1
80008e74:	10 37       	cp.w	r7,r8
80008e76:	c0 b4       	brge	80008e8c <_vfprintf_r+0xd9c>
80008e78:	fa c9 f9 44 	sub	r9,sp,-1724
80008e7c:	14 97       	mov	r7,r10
80008e7e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e82:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e86:	fa eb 00 00 	st.d	sp[0],r10
80008e8a:	c1 88       	rjmp	80008eba <_vfprintf_r+0xdca>
80008e8c:	41 09       	lddsp	r9,sp[0x40]
80008e8e:	59 f8       	cp.w	r8,31
80008e90:	e0 89 00 18 	brgt	80008ec0 <_vfprintf_r+0xdd0>
80008e94:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e98:	f2 cb ff f8 	sub	r11,r9,-8
80008e9c:	fa e7 00 00 	st.d	sp[0],r6
80008ea0:	51 0b       	stdsp	sp[0x40],r11
80008ea2:	fa c6 f9 44 	sub	r6,sp,-1724
80008ea6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008eaa:	fa e6 00 00 	ld.d	r6,sp[0]
80008eae:	f2 e7 fd 88 	st.d	r9[-632],r6
80008eb2:	2f f8       	sub	r8,-1
80008eb4:	14 97       	mov	r7,r10
80008eb6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eba:	40 38       	lddsp	r8,sp[0xc]
80008ebc:	e0 8f 03 b6 	bral	80009628 <_vfprintf_r+0x1538>
80008ec0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ec4:	40 38       	lddsp	r8,sp[0xc]
80008ec6:	fa e7 00 00 	st.d	sp[0],r6
80008eca:	2f 89       	sub	r9,-8
80008ecc:	14 97       	mov	r7,r10
80008ece:	51 09       	stdsp	sp[0x40],r9
80008ed0:	e0 8f 03 ac 	bral	80009628 <_vfprintf_r+0x1538>
80008ed4:	ed b5 00 04 	bld	r5,0x4
80008ed8:	c1 61       	brne	80008f04 <_vfprintf_r+0xe14>
80008eda:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ede:	40 3e       	lddsp	lr,sp[0xc]
80008ee0:	58 0e       	cp.w	lr,0
80008ee2:	c0 80       	breq	80008ef2 <_vfprintf_r+0xe02>
80008ee4:	10 36       	cp.w	r6,r8
80008ee6:	c6 74       	brge	80008fb4 <_vfprintf_r+0xec4>
80008ee8:	fa cc f9 44 	sub	r12,sp,-1724
80008eec:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ef0:	c8 08       	rjmp	80008ff0 <_vfprintf_r+0xf00>
80008ef2:	ee ca ff ff 	sub	r10,r7,-1
80008ef6:	10 37       	cp.w	r7,r8
80008ef8:	c7 f4       	brge	80008ff6 <_vfprintf_r+0xf06>
80008efa:	fa cb f9 44 	sub	r11,sp,-1724
80008efe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f02:	c7 68       	rjmp	80008fee <_vfprintf_r+0xefe>
80008f04:	ed b5 00 06 	bld	r5,0x6
80008f08:	c4 a1       	brne	80008f9c <_vfprintf_r+0xeac>
80008f0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f0e:	40 3c       	lddsp	r12,sp[0xc]
80008f10:	58 0c       	cp.w	r12,0
80008f12:	c1 d0       	breq	80008f4c <_vfprintf_r+0xe5c>
80008f14:	10 36       	cp.w	r6,r8
80008f16:	c0 64       	brge	80008f22 <_vfprintf_r+0xe32>
80008f18:	fa cb f9 44 	sub	r11,sp,-1724
80008f1c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f20:	c1 f8       	rjmp	80008f5e <_vfprintf_r+0xe6e>
80008f22:	fa c8 f9 50 	sub	r8,sp,-1712
80008f26:	1a d8       	st.w	--sp,r8
80008f28:	fa c8 fa b8 	sub	r8,sp,-1352
80008f2c:	1a d8       	st.w	--sp,r8
80008f2e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f32:	1a d8       	st.w	--sp,r8
80008f34:	fa c8 f9 40 	sub	r8,sp,-1728
80008f38:	fa c9 ff b4 	sub	r9,sp,-76
80008f3c:	04 9a       	mov	r10,r2
80008f3e:	0c 9b       	mov	r11,r6
80008f40:	08 9c       	mov	r12,r4
80008f42:	fe b0 f7 3f 	rcall	80007dc0 <get_arg>
80008f46:	2f dd       	sub	sp,-12
80008f48:	98 18       	ld.sh	r8,r12[0x2]
80008f4a:	c2 68       	rjmp	80008f96 <_vfprintf_r+0xea6>
80008f4c:	ee ca ff ff 	sub	r10,r7,-1
80008f50:	10 37       	cp.w	r7,r8
80008f52:	c0 94       	brge	80008f64 <_vfprintf_r+0xe74>
80008f54:	fa c9 f9 44 	sub	r9,sp,-1724
80008f58:	14 97       	mov	r7,r10
80008f5a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f5e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f62:	c1 a8       	rjmp	80008f96 <_vfprintf_r+0xea6>
80008f64:	41 09       	lddsp	r9,sp[0x40]
80008f66:	59 f8       	cp.w	r8,31
80008f68:	e0 89 00 13 	brgt	80008f8e <_vfprintf_r+0xe9e>
80008f6c:	f2 cb ff fc 	sub	r11,r9,-4
80008f70:	51 0b       	stdsp	sp[0x40],r11
80008f72:	72 09       	ld.w	r9,r9[0x0]
80008f74:	fa c6 f9 44 	sub	r6,sp,-1724
80008f78:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f7c:	2f f8       	sub	r8,-1
80008f7e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f82:	fb 48 06 b4 	st.w	sp[1716],r8
80008f86:	14 97       	mov	r7,r10
80008f88:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f8c:	c0 58       	rjmp	80008f96 <_vfprintf_r+0xea6>
80008f8e:	92 18       	ld.sh	r8,r9[0x2]
80008f90:	14 97       	mov	r7,r10
80008f92:	2f c9       	sub	r9,-4
80008f94:	51 09       	stdsp	sp[0x40],r9
80008f96:	5c 78       	castu.h	r8
80008f98:	50 18       	stdsp	sp[0x4],r8
80008f9a:	c4 68       	rjmp	80009026 <_vfprintf_r+0xf36>
80008f9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fa0:	40 3c       	lddsp	r12,sp[0xc]
80008fa2:	58 0c       	cp.w	r12,0
80008fa4:	c1 d0       	breq	80008fde <_vfprintf_r+0xeee>
80008fa6:	10 36       	cp.w	r6,r8
80008fa8:	c0 64       	brge	80008fb4 <_vfprintf_r+0xec4>
80008faa:	fa cb f9 44 	sub	r11,sp,-1724
80008fae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fb2:	c1 f8       	rjmp	80008ff0 <_vfprintf_r+0xf00>
80008fb4:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb8:	1a d8       	st.w	--sp,r8
80008fba:	fa c8 fa b8 	sub	r8,sp,-1352
80008fbe:	0c 9b       	mov	r11,r6
80008fc0:	1a d8       	st.w	--sp,r8
80008fc2:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc6:	04 9a       	mov	r10,r2
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	08 9c       	mov	r12,r4
80008fcc:	fa c8 f9 40 	sub	r8,sp,-1728
80008fd0:	fa c9 ff b4 	sub	r9,sp,-76
80008fd4:	fe b0 f6 f6 	rcall	80007dc0 <get_arg>
80008fd8:	2f dd       	sub	sp,-12
80008fda:	78 0b       	ld.w	r11,r12[0x0]
80008fdc:	c2 48       	rjmp	80009024 <_vfprintf_r+0xf34>
80008fde:	ee ca ff ff 	sub	r10,r7,-1
80008fe2:	10 37       	cp.w	r7,r8
80008fe4:	c0 94       	brge	80008ff6 <_vfprintf_r+0xf06>
80008fe6:	fa c9 f9 44 	sub	r9,sp,-1724
80008fea:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fee:	14 97       	mov	r7,r10
80008ff0:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ff4:	c1 88       	rjmp	80009024 <_vfprintf_r+0xf34>
80008ff6:	41 09       	lddsp	r9,sp[0x40]
80008ff8:	59 f8       	cp.w	r8,31
80008ffa:	e0 89 00 11 	brgt	8000901c <_vfprintf_r+0xf2c>
80008ffe:	f2 cb ff fc 	sub	r11,r9,-4
80009002:	51 0b       	stdsp	sp[0x40],r11
80009004:	fa c6 f9 44 	sub	r6,sp,-1724
80009008:	72 0b       	ld.w	r11,r9[0x0]
8000900a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000900e:	f3 4b fd 88 	st.w	r9[-632],r11
80009012:	2f f8       	sub	r8,-1
80009014:	14 97       	mov	r7,r10
80009016:	fb 48 06 b4 	st.w	sp[1716],r8
8000901a:	c0 58       	rjmp	80009024 <_vfprintf_r+0xf34>
8000901c:	72 0b       	ld.w	r11,r9[0x0]
8000901e:	14 97       	mov	r7,r10
80009020:	2f c9       	sub	r9,-4
80009022:	51 09       	stdsp	sp[0x40],r9
80009024:	50 1b       	stdsp	sp[0x4],r11
80009026:	30 0e       	mov	lr,0
80009028:	50 0e       	stdsp	sp[0x0],lr
8000902a:	1c 98       	mov	r8,lr
8000902c:	e0 8f 02 fe 	bral	80009628 <_vfprintf_r+0x1538>
80009030:	50 a7       	stdsp	sp[0x28],r7
80009032:	50 80       	stdsp	sp[0x20],r0
80009034:	0c 97       	mov	r7,r6
80009036:	04 94       	mov	r4,r2
80009038:	06 96       	mov	r6,r3
8000903a:	02 92       	mov	r2,r1
8000903c:	40 93       	lddsp	r3,sp[0x24]
8000903e:	40 41       	lddsp	r1,sp[0x10]
80009040:	0e 99       	mov	r9,r7
80009042:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009046:	40 3c       	lddsp	r12,sp[0xc]
80009048:	58 0c       	cp.w	r12,0
8000904a:	c1 d0       	breq	80009084 <_vfprintf_r+0xf94>
8000904c:	10 36       	cp.w	r6,r8
8000904e:	c0 64       	brge	8000905a <_vfprintf_r+0xf6a>
80009050:	fa cb f9 44 	sub	r11,sp,-1724
80009054:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009058:	c1 d8       	rjmp	80009092 <_vfprintf_r+0xfa2>
8000905a:	fa c8 f9 50 	sub	r8,sp,-1712
8000905e:	1a d8       	st.w	--sp,r8
80009060:	fa c8 fa b8 	sub	r8,sp,-1352
80009064:	1a d8       	st.w	--sp,r8
80009066:	fa c8 fb b4 	sub	r8,sp,-1100
8000906a:	1a d8       	st.w	--sp,r8
8000906c:	fa c9 ff b4 	sub	r9,sp,-76
80009070:	fa c8 f9 40 	sub	r8,sp,-1728
80009074:	04 9a       	mov	r10,r2
80009076:	0c 9b       	mov	r11,r6
80009078:	08 9c       	mov	r12,r4
8000907a:	fe b0 f6 a3 	rcall	80007dc0 <get_arg>
8000907e:	2f dd       	sub	sp,-12
80009080:	78 09       	ld.w	r9,r12[0x0]
80009082:	c2 18       	rjmp	800090c4 <_vfprintf_r+0xfd4>
80009084:	2f f7       	sub	r7,-1
80009086:	10 39       	cp.w	r9,r8
80009088:	c0 84       	brge	80009098 <_vfprintf_r+0xfa8>
8000908a:	fa ca f9 44 	sub	r10,sp,-1724
8000908e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009092:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009096:	c1 78       	rjmp	800090c4 <_vfprintf_r+0xfd4>
80009098:	41 09       	lddsp	r9,sp[0x40]
8000909a:	59 f8       	cp.w	r8,31
8000909c:	e0 89 00 10 	brgt	800090bc <_vfprintf_r+0xfcc>
800090a0:	f2 ca ff fc 	sub	r10,r9,-4
800090a4:	51 0a       	stdsp	sp[0x40],r10
800090a6:	fa c6 f9 44 	sub	r6,sp,-1724
800090aa:	72 09       	ld.w	r9,r9[0x0]
800090ac:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800090b0:	f5 49 fd 88 	st.w	r10[-632],r9
800090b4:	2f f8       	sub	r8,-1
800090b6:	fb 48 06 b4 	st.w	sp[1716],r8
800090ba:	c0 58       	rjmp	800090c4 <_vfprintf_r+0xfd4>
800090bc:	f2 c8 ff fc 	sub	r8,r9,-4
800090c0:	51 08       	stdsp	sp[0x40],r8
800090c2:	72 09       	ld.w	r9,r9[0x0]
800090c4:	33 08       	mov	r8,48
800090c6:	fb 68 06 b8 	st.b	sp[1720],r8
800090ca:	37 88       	mov	r8,120
800090cc:	30 0e       	mov	lr,0
800090ce:	fb 68 06 b9 	st.b	sp[1721],r8
800090d2:	fe cc b1 3e 	sub	r12,pc,-20162
800090d6:	50 19       	stdsp	sp[0x4],r9
800090d8:	a1 b5       	sbr	r5,0x1
800090da:	50 0e       	stdsp	sp[0x0],lr
800090dc:	50 dc       	stdsp	sp[0x34],r12
800090de:	30 28       	mov	r8,2
800090e0:	37 80       	mov	r0,120
800090e2:	e0 8f 02 a3 	bral	80009628 <_vfprintf_r+0x1538>
800090e6:	50 a7       	stdsp	sp[0x28],r7
800090e8:	50 80       	stdsp	sp[0x20],r0
800090ea:	10 90       	mov	r0,r8
800090ec:	30 08       	mov	r8,0
800090ee:	fb 68 06 bb 	st.b	sp[1723],r8
800090f2:	0c 97       	mov	r7,r6
800090f4:	04 94       	mov	r4,r2
800090f6:	06 96       	mov	r6,r3
800090f8:	02 92       	mov	r2,r1
800090fa:	40 93       	lddsp	r3,sp[0x24]
800090fc:	40 41       	lddsp	r1,sp[0x10]
800090fe:	0e 99       	mov	r9,r7
80009100:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009104:	40 3b       	lddsp	r11,sp[0xc]
80009106:	58 0b       	cp.w	r11,0
80009108:	c1 d0       	breq	80009142 <_vfprintf_r+0x1052>
8000910a:	10 36       	cp.w	r6,r8
8000910c:	c0 64       	brge	80009118 <_vfprintf_r+0x1028>
8000910e:	fa ca f9 44 	sub	r10,sp,-1724
80009112:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009116:	c1 d8       	rjmp	80009150 <_vfprintf_r+0x1060>
80009118:	fa c8 f9 50 	sub	r8,sp,-1712
8000911c:	1a d8       	st.w	--sp,r8
8000911e:	fa c8 fa b8 	sub	r8,sp,-1352
80009122:	1a d8       	st.w	--sp,r8
80009124:	fa c8 fb b4 	sub	r8,sp,-1100
80009128:	0c 9b       	mov	r11,r6
8000912a:	1a d8       	st.w	--sp,r8
8000912c:	04 9a       	mov	r10,r2
8000912e:	fa c8 f9 40 	sub	r8,sp,-1728
80009132:	fa c9 ff b4 	sub	r9,sp,-76
80009136:	08 9c       	mov	r12,r4
80009138:	fe b0 f6 44 	rcall	80007dc0 <get_arg>
8000913c:	2f dd       	sub	sp,-12
8000913e:	78 06       	ld.w	r6,r12[0x0]
80009140:	c2 08       	rjmp	80009180 <_vfprintf_r+0x1090>
80009142:	2f f7       	sub	r7,-1
80009144:	10 39       	cp.w	r9,r8
80009146:	c0 84       	brge	80009156 <_vfprintf_r+0x1066>
80009148:	fa c9 f9 44 	sub	r9,sp,-1724
8000914c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009150:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009154:	c1 68       	rjmp	80009180 <_vfprintf_r+0x1090>
80009156:	41 09       	lddsp	r9,sp[0x40]
80009158:	59 f8       	cp.w	r8,31
8000915a:	e0 89 00 10 	brgt	8000917a <_vfprintf_r+0x108a>
8000915e:	f2 ca ff fc 	sub	r10,r9,-4
80009162:	51 0a       	stdsp	sp[0x40],r10
80009164:	72 06       	ld.w	r6,r9[0x0]
80009166:	fa ce f9 44 	sub	lr,sp,-1724
8000916a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000916e:	f3 46 fd 88 	st.w	r9[-632],r6
80009172:	2f f8       	sub	r8,-1
80009174:	fb 48 06 b4 	st.w	sp[1716],r8
80009178:	c0 48       	rjmp	80009180 <_vfprintf_r+0x1090>
8000917a:	72 06       	ld.w	r6,r9[0x0]
8000917c:	2f c9       	sub	r9,-4
8000917e:	51 09       	stdsp	sp[0x40],r9
80009180:	40 2c       	lddsp	r12,sp[0x8]
80009182:	58 0c       	cp.w	r12,0
80009184:	c1 05       	brlt	800091a4 <_vfprintf_r+0x10b4>
80009186:	18 9a       	mov	r10,r12
80009188:	30 0b       	mov	r11,0
8000918a:	0c 9c       	mov	r12,r6
8000918c:	e0 a0 12 38 	rcall	8000b5fc <memchr>
80009190:	e0 80 02 df 	breq	8000974e <_vfprintf_r+0x165e>
80009194:	f8 06 01 02 	sub	r2,r12,r6
80009198:	40 2b       	lddsp	r11,sp[0x8]
8000919a:	16 32       	cp.w	r2,r11
8000919c:	e0 89 02 d9 	brgt	8000974e <_vfprintf_r+0x165e>
800091a0:	e0 8f 02 d4 	bral	80009748 <_vfprintf_r+0x1658>
800091a4:	30 0a       	mov	r10,0
800091a6:	0c 9c       	mov	r12,r6
800091a8:	50 2a       	stdsp	sp[0x8],r10
800091aa:	e0 a0 15 99 	rcall	8000bcdc <strlen>
800091ae:	18 92       	mov	r2,r12
800091b0:	e0 8f 02 d2 	bral	80009754 <_vfprintf_r+0x1664>
800091b4:	50 a7       	stdsp	sp[0x28],r7
800091b6:	50 80       	stdsp	sp[0x20],r0
800091b8:	0c 97       	mov	r7,r6
800091ba:	04 94       	mov	r4,r2
800091bc:	06 96       	mov	r6,r3
800091be:	02 92       	mov	r2,r1
800091c0:	40 93       	lddsp	r3,sp[0x24]
800091c2:	10 90       	mov	r0,r8
800091c4:	40 41       	lddsp	r1,sp[0x10]
800091c6:	a5 a5       	sbr	r5,0x4
800091c8:	c0 a8       	rjmp	800091dc <_vfprintf_r+0x10ec>
800091ca:	50 a7       	stdsp	sp[0x28],r7
800091cc:	50 80       	stdsp	sp[0x20],r0
800091ce:	0c 97       	mov	r7,r6
800091d0:	04 94       	mov	r4,r2
800091d2:	06 96       	mov	r6,r3
800091d4:	02 92       	mov	r2,r1
800091d6:	40 93       	lddsp	r3,sp[0x24]
800091d8:	10 90       	mov	r0,r8
800091da:	40 41       	lddsp	r1,sp[0x10]
800091dc:	ed b5 00 05 	bld	r5,0x5
800091e0:	c5 61       	brne	8000928c <_vfprintf_r+0x119c>
800091e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091e6:	40 39       	lddsp	r9,sp[0xc]
800091e8:	58 09       	cp.w	r9,0
800091ea:	c2 10       	breq	8000922c <_vfprintf_r+0x113c>
800091ec:	10 36       	cp.w	r6,r8
800091ee:	c0 74       	brge	800091fc <_vfprintf_r+0x110c>
800091f0:	fa c8 f9 44 	sub	r8,sp,-1724
800091f4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800091f8:	c2 38       	rjmp	8000923e <_vfprintf_r+0x114e>
800091fa:	d7 03       	nop
800091fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009200:	1a d8       	st.w	--sp,r8
80009202:	fa c8 fa b8 	sub	r8,sp,-1352
80009206:	1a d8       	st.w	--sp,r8
80009208:	fa c8 fb b4 	sub	r8,sp,-1100
8000920c:	1a d8       	st.w	--sp,r8
8000920e:	fa c8 f9 40 	sub	r8,sp,-1728
80009212:	fa c9 ff b4 	sub	r9,sp,-76
80009216:	04 9a       	mov	r10,r2
80009218:	0c 9b       	mov	r11,r6
8000921a:	08 9c       	mov	r12,r4
8000921c:	fe b0 f5 d2 	rcall	80007dc0 <get_arg>
80009220:	2f dd       	sub	sp,-12
80009222:	f8 e8 00 00 	ld.d	r8,r12[0]
80009226:	fa e9 00 00 	st.d	sp[0],r8
8000922a:	c2 e8       	rjmp	80009286 <_vfprintf_r+0x1196>
8000922c:	ee ca ff ff 	sub	r10,r7,-1
80009230:	10 37       	cp.w	r7,r8
80009232:	c0 b4       	brge	80009248 <_vfprintf_r+0x1158>
80009234:	fa c8 f9 44 	sub	r8,sp,-1724
80009238:	14 97       	mov	r7,r10
8000923a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000923e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009242:	fa eb 00 00 	st.d	sp[0],r10
80009246:	c2 08       	rjmp	80009286 <_vfprintf_r+0x1196>
80009248:	41 09       	lddsp	r9,sp[0x40]
8000924a:	59 f8       	cp.w	r8,31
8000924c:	e0 89 00 16 	brgt	80009278 <_vfprintf_r+0x1188>
80009250:	f2 e6 00 00 	ld.d	r6,r9[0]
80009254:	f2 cb ff f8 	sub	r11,r9,-8
80009258:	fa e7 00 00 	st.d	sp[0],r6
8000925c:	51 0b       	stdsp	sp[0x40],r11
8000925e:	fa c6 f9 44 	sub	r6,sp,-1724
80009262:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009266:	fa e6 00 00 	ld.d	r6,sp[0]
8000926a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000926e:	2f f8       	sub	r8,-1
80009270:	14 97       	mov	r7,r10
80009272:	fb 48 06 b4 	st.w	sp[1716],r8
80009276:	c0 88       	rjmp	80009286 <_vfprintf_r+0x1196>
80009278:	f2 e6 00 00 	ld.d	r6,r9[0]
8000927c:	2f 89       	sub	r9,-8
8000927e:	fa e7 00 00 	st.d	sp[0],r6
80009282:	51 09       	stdsp	sp[0x40],r9
80009284:	14 97       	mov	r7,r10
80009286:	30 18       	mov	r8,1
80009288:	e0 8f 01 d0 	bral	80009628 <_vfprintf_r+0x1538>
8000928c:	ed b5 00 04 	bld	r5,0x4
80009290:	c1 61       	brne	800092bc <_vfprintf_r+0x11cc>
80009292:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009296:	40 3e       	lddsp	lr,sp[0xc]
80009298:	58 0e       	cp.w	lr,0
8000929a:	c0 80       	breq	800092aa <_vfprintf_r+0x11ba>
8000929c:	10 36       	cp.w	r6,r8
8000929e:	c6 74       	brge	8000936c <_vfprintf_r+0x127c>
800092a0:	fa cc f9 44 	sub	r12,sp,-1724
800092a4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092a8:	c8 08       	rjmp	800093a8 <_vfprintf_r+0x12b8>
800092aa:	ee ca ff ff 	sub	r10,r7,-1
800092ae:	10 37       	cp.w	r7,r8
800092b0:	c7 f4       	brge	800093ae <_vfprintf_r+0x12be>
800092b2:	fa cb f9 44 	sub	r11,sp,-1724
800092b6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ba:	c7 68       	rjmp	800093a6 <_vfprintf_r+0x12b6>
800092bc:	ed b5 00 06 	bld	r5,0x6
800092c0:	c4 a1       	brne	80009354 <_vfprintf_r+0x1264>
800092c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092c6:	40 3c       	lddsp	r12,sp[0xc]
800092c8:	58 0c       	cp.w	r12,0
800092ca:	c1 d0       	breq	80009304 <_vfprintf_r+0x1214>
800092cc:	10 36       	cp.w	r6,r8
800092ce:	c0 64       	brge	800092da <_vfprintf_r+0x11ea>
800092d0:	fa cb f9 44 	sub	r11,sp,-1724
800092d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092d8:	c1 f8       	rjmp	80009316 <_vfprintf_r+0x1226>
800092da:	fa c8 f9 50 	sub	r8,sp,-1712
800092de:	1a d8       	st.w	--sp,r8
800092e0:	fa c8 fa b8 	sub	r8,sp,-1352
800092e4:	1a d8       	st.w	--sp,r8
800092e6:	fa c8 fb b4 	sub	r8,sp,-1100
800092ea:	1a d8       	st.w	--sp,r8
800092ec:	fa c8 f9 40 	sub	r8,sp,-1728
800092f0:	fa c9 ff b4 	sub	r9,sp,-76
800092f4:	04 9a       	mov	r10,r2
800092f6:	0c 9b       	mov	r11,r6
800092f8:	08 9c       	mov	r12,r4
800092fa:	fe b0 f5 63 	rcall	80007dc0 <get_arg>
800092fe:	2f dd       	sub	sp,-12
80009300:	98 18       	ld.sh	r8,r12[0x2]
80009302:	c2 68       	rjmp	8000934e <_vfprintf_r+0x125e>
80009304:	ee ca ff ff 	sub	r10,r7,-1
80009308:	10 37       	cp.w	r7,r8
8000930a:	c0 94       	brge	8000931c <_vfprintf_r+0x122c>
8000930c:	fa c9 f9 44 	sub	r9,sp,-1724
80009310:	14 97       	mov	r7,r10
80009312:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009316:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000931a:	c1 a8       	rjmp	8000934e <_vfprintf_r+0x125e>
8000931c:	41 09       	lddsp	r9,sp[0x40]
8000931e:	59 f8       	cp.w	r8,31
80009320:	e0 89 00 13 	brgt	80009346 <_vfprintf_r+0x1256>
80009324:	f2 cb ff fc 	sub	r11,r9,-4
80009328:	51 0b       	stdsp	sp[0x40],r11
8000932a:	72 09       	ld.w	r9,r9[0x0]
8000932c:	fa c6 f9 44 	sub	r6,sp,-1724
80009330:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009334:	2f f8       	sub	r8,-1
80009336:	f7 49 fd 88 	st.w	r11[-632],r9
8000933a:	fb 48 06 b4 	st.w	sp[1716],r8
8000933e:	14 97       	mov	r7,r10
80009340:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009344:	c0 58       	rjmp	8000934e <_vfprintf_r+0x125e>
80009346:	92 18       	ld.sh	r8,r9[0x2]
80009348:	14 97       	mov	r7,r10
8000934a:	2f c9       	sub	r9,-4
8000934c:	51 09       	stdsp	sp[0x40],r9
8000934e:	5c 78       	castu.h	r8
80009350:	50 18       	stdsp	sp[0x4],r8
80009352:	c4 68       	rjmp	800093de <_vfprintf_r+0x12ee>
80009354:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009358:	40 3c       	lddsp	r12,sp[0xc]
8000935a:	58 0c       	cp.w	r12,0
8000935c:	c1 d0       	breq	80009396 <_vfprintf_r+0x12a6>
8000935e:	10 36       	cp.w	r6,r8
80009360:	c0 64       	brge	8000936c <_vfprintf_r+0x127c>
80009362:	fa cb f9 44 	sub	r11,sp,-1724
80009366:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000936a:	c1 f8       	rjmp	800093a8 <_vfprintf_r+0x12b8>
8000936c:	fa c8 f9 50 	sub	r8,sp,-1712
80009370:	1a d8       	st.w	--sp,r8
80009372:	fa c8 fa b8 	sub	r8,sp,-1352
80009376:	0c 9b       	mov	r11,r6
80009378:	1a d8       	st.w	--sp,r8
8000937a:	fa c8 fb b4 	sub	r8,sp,-1100
8000937e:	04 9a       	mov	r10,r2
80009380:	1a d8       	st.w	--sp,r8
80009382:	08 9c       	mov	r12,r4
80009384:	fa c8 f9 40 	sub	r8,sp,-1728
80009388:	fa c9 ff b4 	sub	r9,sp,-76
8000938c:	fe b0 f5 1a 	rcall	80007dc0 <get_arg>
80009390:	2f dd       	sub	sp,-12
80009392:	78 0b       	ld.w	r11,r12[0x0]
80009394:	c2 48       	rjmp	800093dc <_vfprintf_r+0x12ec>
80009396:	ee ca ff ff 	sub	r10,r7,-1
8000939a:	10 37       	cp.w	r7,r8
8000939c:	c0 94       	brge	800093ae <_vfprintf_r+0x12be>
8000939e:	fa c9 f9 44 	sub	r9,sp,-1724
800093a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093a6:	14 97       	mov	r7,r10
800093a8:	ec fb fd 88 	ld.w	r11,r6[-632]
800093ac:	c1 88       	rjmp	800093dc <_vfprintf_r+0x12ec>
800093ae:	41 09       	lddsp	r9,sp[0x40]
800093b0:	59 f8       	cp.w	r8,31
800093b2:	e0 89 00 11 	brgt	800093d4 <_vfprintf_r+0x12e4>
800093b6:	f2 cb ff fc 	sub	r11,r9,-4
800093ba:	51 0b       	stdsp	sp[0x40],r11
800093bc:	fa c6 f9 44 	sub	r6,sp,-1724
800093c0:	72 0b       	ld.w	r11,r9[0x0]
800093c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093c6:	f3 4b fd 88 	st.w	r9[-632],r11
800093ca:	2f f8       	sub	r8,-1
800093cc:	14 97       	mov	r7,r10
800093ce:	fb 48 06 b4 	st.w	sp[1716],r8
800093d2:	c0 58       	rjmp	800093dc <_vfprintf_r+0x12ec>
800093d4:	72 0b       	ld.w	r11,r9[0x0]
800093d6:	14 97       	mov	r7,r10
800093d8:	2f c9       	sub	r9,-4
800093da:	51 09       	stdsp	sp[0x40],r9
800093dc:	50 1b       	stdsp	sp[0x4],r11
800093de:	30 0e       	mov	lr,0
800093e0:	30 18       	mov	r8,1
800093e2:	50 0e       	stdsp	sp[0x0],lr
800093e4:	c2 29       	rjmp	80009628 <_vfprintf_r+0x1538>
800093e6:	50 a7       	stdsp	sp[0x28],r7
800093e8:	50 80       	stdsp	sp[0x20],r0
800093ea:	0c 97       	mov	r7,r6
800093ec:	04 94       	mov	r4,r2
800093ee:	06 96       	mov	r6,r3
800093f0:	02 92       	mov	r2,r1
800093f2:	fe cc b4 5e 	sub	r12,pc,-19362
800093f6:	40 93       	lddsp	r3,sp[0x24]
800093f8:	10 90       	mov	r0,r8
800093fa:	40 41       	lddsp	r1,sp[0x10]
800093fc:	50 dc       	stdsp	sp[0x34],r12
800093fe:	ed b5 00 05 	bld	r5,0x5
80009402:	c5 51       	brne	800094ac <_vfprintf_r+0x13bc>
80009404:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009408:	40 3b       	lddsp	r11,sp[0xc]
8000940a:	58 0b       	cp.w	r11,0
8000940c:	c2 20       	breq	80009450 <_vfprintf_r+0x1360>
8000940e:	10 36       	cp.w	r6,r8
80009410:	c0 a4       	brge	80009424 <_vfprintf_r+0x1334>
80009412:	fa ca f9 44 	sub	r10,sp,-1724
80009416:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000941a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000941e:	fa e9 00 00 	st.d	sp[0],r8
80009422:	cf 28       	rjmp	80009606 <_vfprintf_r+0x1516>
80009424:	fa c8 f9 50 	sub	r8,sp,-1712
80009428:	1a d8       	st.w	--sp,r8
8000942a:	fa c8 fa b8 	sub	r8,sp,-1352
8000942e:	04 9a       	mov	r10,r2
80009430:	1a d8       	st.w	--sp,r8
80009432:	0c 9b       	mov	r11,r6
80009434:	fa c8 fb b4 	sub	r8,sp,-1100
80009438:	08 9c       	mov	r12,r4
8000943a:	1a d8       	st.w	--sp,r8
8000943c:	fa c8 f9 40 	sub	r8,sp,-1728
80009440:	fa c9 ff b4 	sub	r9,sp,-76
80009444:	fe b0 f4 be 	rcall	80007dc0 <get_arg>
80009448:	2f dd       	sub	sp,-12
8000944a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000944e:	c0 c8       	rjmp	80009466 <_vfprintf_r+0x1376>
80009450:	ee ca ff ff 	sub	r10,r7,-1
80009454:	10 37       	cp.w	r7,r8
80009456:	c0 b4       	brge	8000946c <_vfprintf_r+0x137c>
80009458:	fa c9 f9 44 	sub	r9,sp,-1724
8000945c:	14 97       	mov	r7,r10
8000945e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009462:	ec ea fd 88 	ld.d	r10,r6[-632]
80009466:	fa eb 00 00 	st.d	sp[0],r10
8000946a:	cc e8       	rjmp	80009606 <_vfprintf_r+0x1516>
8000946c:	41 09       	lddsp	r9,sp[0x40]
8000946e:	59 f8       	cp.w	r8,31
80009470:	e0 89 00 16 	brgt	8000949c <_vfprintf_r+0x13ac>
80009474:	f2 e6 00 00 	ld.d	r6,r9[0]
80009478:	f2 cb ff f8 	sub	r11,r9,-8
8000947c:	fa e7 00 00 	st.d	sp[0],r6
80009480:	51 0b       	stdsp	sp[0x40],r11
80009482:	fa c6 f9 44 	sub	r6,sp,-1724
80009486:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000948a:	fa e6 00 00 	ld.d	r6,sp[0]
8000948e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009492:	2f f8       	sub	r8,-1
80009494:	14 97       	mov	r7,r10
80009496:	fb 48 06 b4 	st.w	sp[1716],r8
8000949a:	cb 68       	rjmp	80009606 <_vfprintf_r+0x1516>
8000949c:	f2 e6 00 00 	ld.d	r6,r9[0]
800094a0:	2f 89       	sub	r9,-8
800094a2:	fa e7 00 00 	st.d	sp[0],r6
800094a6:	51 09       	stdsp	sp[0x40],r9
800094a8:	14 97       	mov	r7,r10
800094aa:	ca e8       	rjmp	80009606 <_vfprintf_r+0x1516>
800094ac:	ed b5 00 04 	bld	r5,0x4
800094b0:	c1 71       	brne	800094de <_vfprintf_r+0x13ee>
800094b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094b6:	40 3e       	lddsp	lr,sp[0xc]
800094b8:	58 0e       	cp.w	lr,0
800094ba:	c0 80       	breq	800094ca <_vfprintf_r+0x13da>
800094bc:	10 36       	cp.w	r6,r8
800094be:	c6 94       	brge	80009590 <_vfprintf_r+0x14a0>
800094c0:	fa cc f9 44 	sub	r12,sp,-1724
800094c4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094c8:	c8 28       	rjmp	800095cc <_vfprintf_r+0x14dc>
800094ca:	ee ca ff ff 	sub	r10,r7,-1
800094ce:	10 37       	cp.w	r7,r8
800094d0:	e0 84 00 81 	brge	800095d2 <_vfprintf_r+0x14e2>
800094d4:	fa cb f9 44 	sub	r11,sp,-1724
800094d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094dc:	c7 78       	rjmp	800095ca <_vfprintf_r+0x14da>
800094de:	ed b5 00 06 	bld	r5,0x6
800094e2:	c4 b1       	brne	80009578 <_vfprintf_r+0x1488>
800094e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094e8:	40 3c       	lddsp	r12,sp[0xc]
800094ea:	58 0c       	cp.w	r12,0
800094ec:	c1 d0       	breq	80009526 <_vfprintf_r+0x1436>
800094ee:	10 36       	cp.w	r6,r8
800094f0:	c0 64       	brge	800094fc <_vfprintf_r+0x140c>
800094f2:	fa cb f9 44 	sub	r11,sp,-1724
800094f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094fa:	c1 f8       	rjmp	80009538 <_vfprintf_r+0x1448>
800094fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009500:	1a d8       	st.w	--sp,r8
80009502:	fa c8 fa b8 	sub	r8,sp,-1352
80009506:	1a d8       	st.w	--sp,r8
80009508:	fa c8 fb b4 	sub	r8,sp,-1100
8000950c:	1a d8       	st.w	--sp,r8
8000950e:	fa c8 f9 40 	sub	r8,sp,-1728
80009512:	fa c9 ff b4 	sub	r9,sp,-76
80009516:	04 9a       	mov	r10,r2
80009518:	0c 9b       	mov	r11,r6
8000951a:	08 9c       	mov	r12,r4
8000951c:	fe b0 f4 52 	rcall	80007dc0 <get_arg>
80009520:	2f dd       	sub	sp,-12
80009522:	98 18       	ld.sh	r8,r12[0x2]
80009524:	c2 78       	rjmp	80009572 <_vfprintf_r+0x1482>
80009526:	ee ca ff ff 	sub	r10,r7,-1
8000952a:	10 37       	cp.w	r7,r8
8000952c:	c0 a4       	brge	80009540 <_vfprintf_r+0x1450>
8000952e:	fa c9 f9 44 	sub	r9,sp,-1724
80009532:	14 97       	mov	r7,r10
80009534:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009538:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000953c:	c1 b8       	rjmp	80009572 <_vfprintf_r+0x1482>
8000953e:	d7 03       	nop
80009540:	41 09       	lddsp	r9,sp[0x40]
80009542:	59 f8       	cp.w	r8,31
80009544:	e0 89 00 13 	brgt	8000956a <_vfprintf_r+0x147a>
80009548:	f2 cb ff fc 	sub	r11,r9,-4
8000954c:	51 0b       	stdsp	sp[0x40],r11
8000954e:	72 09       	ld.w	r9,r9[0x0]
80009550:	fa c6 f9 44 	sub	r6,sp,-1724
80009554:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009558:	2f f8       	sub	r8,-1
8000955a:	f7 49 fd 88 	st.w	r11[-632],r9
8000955e:	fb 48 06 b4 	st.w	sp[1716],r8
80009562:	14 97       	mov	r7,r10
80009564:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009568:	c0 58       	rjmp	80009572 <_vfprintf_r+0x1482>
8000956a:	92 18       	ld.sh	r8,r9[0x2]
8000956c:	14 97       	mov	r7,r10
8000956e:	2f c9       	sub	r9,-4
80009570:	51 09       	stdsp	sp[0x40],r9
80009572:	5c 78       	castu.h	r8
80009574:	50 18       	stdsp	sp[0x4],r8
80009576:	c4 68       	rjmp	80009602 <_vfprintf_r+0x1512>
80009578:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000957c:	40 3c       	lddsp	r12,sp[0xc]
8000957e:	58 0c       	cp.w	r12,0
80009580:	c1 d0       	breq	800095ba <_vfprintf_r+0x14ca>
80009582:	10 36       	cp.w	r6,r8
80009584:	c0 64       	brge	80009590 <_vfprintf_r+0x14a0>
80009586:	fa cb f9 44 	sub	r11,sp,-1724
8000958a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000958e:	c1 f8       	rjmp	800095cc <_vfprintf_r+0x14dc>
80009590:	fa c8 f9 50 	sub	r8,sp,-1712
80009594:	1a d8       	st.w	--sp,r8
80009596:	fa c8 fa b8 	sub	r8,sp,-1352
8000959a:	0c 9b       	mov	r11,r6
8000959c:	1a d8       	st.w	--sp,r8
8000959e:	fa c8 fb b4 	sub	r8,sp,-1100
800095a2:	04 9a       	mov	r10,r2
800095a4:	1a d8       	st.w	--sp,r8
800095a6:	08 9c       	mov	r12,r4
800095a8:	fa c8 f9 40 	sub	r8,sp,-1728
800095ac:	fa c9 ff b4 	sub	r9,sp,-76
800095b0:	fe b0 f4 08 	rcall	80007dc0 <get_arg>
800095b4:	2f dd       	sub	sp,-12
800095b6:	78 0b       	ld.w	r11,r12[0x0]
800095b8:	c2 48       	rjmp	80009600 <_vfprintf_r+0x1510>
800095ba:	ee ca ff ff 	sub	r10,r7,-1
800095be:	10 37       	cp.w	r7,r8
800095c0:	c0 94       	brge	800095d2 <_vfprintf_r+0x14e2>
800095c2:	fa c9 f9 44 	sub	r9,sp,-1724
800095c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095ca:	14 97       	mov	r7,r10
800095cc:	ec fb fd 88 	ld.w	r11,r6[-632]
800095d0:	c1 88       	rjmp	80009600 <_vfprintf_r+0x1510>
800095d2:	41 09       	lddsp	r9,sp[0x40]
800095d4:	59 f8       	cp.w	r8,31
800095d6:	e0 89 00 11 	brgt	800095f8 <_vfprintf_r+0x1508>
800095da:	f2 cb ff fc 	sub	r11,r9,-4
800095de:	51 0b       	stdsp	sp[0x40],r11
800095e0:	fa c6 f9 44 	sub	r6,sp,-1724
800095e4:	72 0b       	ld.w	r11,r9[0x0]
800095e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095ea:	f3 4b fd 88 	st.w	r9[-632],r11
800095ee:	2f f8       	sub	r8,-1
800095f0:	14 97       	mov	r7,r10
800095f2:	fb 48 06 b4 	st.w	sp[1716],r8
800095f6:	c0 58       	rjmp	80009600 <_vfprintf_r+0x1510>
800095f8:	72 0b       	ld.w	r11,r9[0x0]
800095fa:	14 97       	mov	r7,r10
800095fc:	2f c9       	sub	r9,-4
800095fe:	51 09       	stdsp	sp[0x40],r9
80009600:	50 1b       	stdsp	sp[0x4],r11
80009602:	30 0e       	mov	lr,0
80009604:	50 0e       	stdsp	sp[0x0],lr
80009606:	40 08       	lddsp	r8,sp[0x0]
80009608:	40 1c       	lddsp	r12,sp[0x4]
8000960a:	18 48       	or	r8,r12
8000960c:	5f 19       	srne	r9
8000960e:	0a 98       	mov	r8,r5
80009610:	eb e9 00 09 	and	r9,r5,r9
80009614:	a1 b8       	sbr	r8,0x1
80009616:	58 09       	cp.w	r9,0
80009618:	c0 70       	breq	80009626 <_vfprintf_r+0x1536>
8000961a:	10 95       	mov	r5,r8
8000961c:	fb 60 06 b9 	st.b	sp[1721],r0
80009620:	33 08       	mov	r8,48
80009622:	fb 68 06 b8 	st.b	sp[1720],r8
80009626:	30 28       	mov	r8,2
80009628:	30 09       	mov	r9,0
8000962a:	fb 69 06 bb 	st.b	sp[1723],r9
8000962e:	0a 99       	mov	r9,r5
80009630:	a7 d9       	cbr	r9,0x7
80009632:	40 2b       	lddsp	r11,sp[0x8]
80009634:	40 16       	lddsp	r6,sp[0x4]
80009636:	58 0b       	cp.w	r11,0
80009638:	5f 1a       	srne	r10
8000963a:	f2 05 17 40 	movge	r5,r9
8000963e:	fa c2 f9 78 	sub	r2,sp,-1672
80009642:	40 09       	lddsp	r9,sp[0x0]
80009644:	0c 49       	or	r9,r6
80009646:	5f 19       	srne	r9
80009648:	f5 e9 10 09 	or	r9,r10,r9
8000964c:	c5 c0       	breq	80009704 <_vfprintf_r+0x1614>
8000964e:	30 19       	mov	r9,1
80009650:	f2 08 18 00 	cp.b	r8,r9
80009654:	c0 60       	breq	80009660 <_vfprintf_r+0x1570>
80009656:	30 29       	mov	r9,2
80009658:	f2 08 18 00 	cp.b	r8,r9
8000965c:	c0 41       	brne	80009664 <_vfprintf_r+0x1574>
8000965e:	c3 c8       	rjmp	800096d6 <_vfprintf_r+0x15e6>
80009660:	04 96       	mov	r6,r2
80009662:	c3 08       	rjmp	800096c2 <_vfprintf_r+0x15d2>
80009664:	04 96       	mov	r6,r2
80009666:	fa e8 00 00 	ld.d	r8,sp[0]
8000966a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000966e:	2d 0a       	sub	r10,-48
80009670:	0c fa       	st.b	--r6,r10
80009672:	f0 0b 16 03 	lsr	r11,r8,0x3
80009676:	f2 0c 16 03 	lsr	r12,r9,0x3
8000967a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000967e:	18 99       	mov	r9,r12
80009680:	16 98       	mov	r8,r11
80009682:	58 08       	cp.w	r8,0
80009684:	5c 29       	cpc	r9
80009686:	cf 21       	brne	8000966a <_vfprintf_r+0x157a>
80009688:	fa e9 00 00 	st.d	sp[0],r8
8000968c:	ed b5 00 00 	bld	r5,0x0
80009690:	c4 51       	brne	8000971a <_vfprintf_r+0x162a>
80009692:	33 09       	mov	r9,48
80009694:	f2 0a 18 00 	cp.b	r10,r9
80009698:	c4 10       	breq	8000971a <_vfprintf_r+0x162a>
8000969a:	0c f9       	st.b	--r6,r9
8000969c:	c3 f8       	rjmp	8000971a <_vfprintf_r+0x162a>
8000969e:	fa ea 00 00 	ld.d	r10,sp[0]
800096a2:	30 a8       	mov	r8,10
800096a4:	30 09       	mov	r9,0
800096a6:	e0 a0 1a 19 	rcall	8000cad8 <__avr32_umod64>
800096aa:	30 a8       	mov	r8,10
800096ac:	2d 0a       	sub	r10,-48
800096ae:	30 09       	mov	r9,0
800096b0:	ac 8a       	st.b	r6[0x0],r10
800096b2:	fa ea 00 00 	ld.d	r10,sp[0]
800096b6:	e0 a0 18 df 	rcall	8000c874 <__avr32_udiv64>
800096ba:	16 99       	mov	r9,r11
800096bc:	14 98       	mov	r8,r10
800096be:	fa e9 00 00 	st.d	sp[0],r8
800096c2:	20 16       	sub	r6,1
800096c4:	fa ea 00 00 	ld.d	r10,sp[0]
800096c8:	58 9a       	cp.w	r10,9
800096ca:	5c 2b       	cpc	r11
800096cc:	fe 9b ff e9 	brhi	8000969e <_vfprintf_r+0x15ae>
800096d0:	1b f8       	ld.ub	r8,sp[0x7]
800096d2:	2d 08       	sub	r8,-48
800096d4:	c2 08       	rjmp	80009714 <_vfprintf_r+0x1624>
800096d6:	04 96       	mov	r6,r2
800096d8:	fa e8 00 00 	ld.d	r8,sp[0]
800096dc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800096e0:	40 de       	lddsp	lr,sp[0x34]
800096e2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800096e6:	0c fa       	st.b	--r6,r10
800096e8:	f2 0b 16 04 	lsr	r11,r9,0x4
800096ec:	f0 0a 16 04 	lsr	r10,r8,0x4
800096f0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800096f4:	16 99       	mov	r9,r11
800096f6:	14 98       	mov	r8,r10
800096f8:	58 08       	cp.w	r8,0
800096fa:	5c 29       	cpc	r9
800096fc:	cf 01       	brne	800096dc <_vfprintf_r+0x15ec>
800096fe:	fa e9 00 00 	st.d	sp[0],r8
80009702:	c0 c8       	rjmp	8000971a <_vfprintf_r+0x162a>
80009704:	58 08       	cp.w	r8,0
80009706:	c0 91       	brne	80009718 <_vfprintf_r+0x1628>
80009708:	ed b5 00 00 	bld	r5,0x0
8000970c:	c0 61       	brne	80009718 <_vfprintf_r+0x1628>
8000970e:	fa c6 f9 79 	sub	r6,sp,-1671
80009712:	33 08       	mov	r8,48
80009714:	ac 88       	st.b	r6[0x0],r8
80009716:	c0 28       	rjmp	8000971a <_vfprintf_r+0x162a>
80009718:	04 96       	mov	r6,r2
8000971a:	0c 12       	sub	r2,r6
8000971c:	c1 c8       	rjmp	80009754 <_vfprintf_r+0x1664>
8000971e:	50 a7       	stdsp	sp[0x28],r7
80009720:	50 80       	stdsp	sp[0x20],r0
80009722:	40 93       	lddsp	r3,sp[0x24]
80009724:	0c 97       	mov	r7,r6
80009726:	10 90       	mov	r0,r8
80009728:	04 94       	mov	r4,r2
8000972a:	40 41       	lddsp	r1,sp[0x10]
8000972c:	58 08       	cp.w	r8,0
8000972e:	e0 80 04 4f 	breq	80009fcc <_vfprintf_r+0x1edc>
80009732:	fb 68 06 60 	st.b	sp[1632],r8
80009736:	30 0c       	mov	r12,0
80009738:	30 08       	mov	r8,0
8000973a:	30 12       	mov	r2,1
8000973c:	fb 68 06 bb 	st.b	sp[1723],r8
80009740:	50 2c       	stdsp	sp[0x8],r12
80009742:	fa c6 f9 a0 	sub	r6,sp,-1632
80009746:	c0 78       	rjmp	80009754 <_vfprintf_r+0x1664>
80009748:	30 0b       	mov	r11,0
8000974a:	50 2b       	stdsp	sp[0x8],r11
8000974c:	c0 48       	rjmp	80009754 <_vfprintf_r+0x1664>
8000974e:	40 22       	lddsp	r2,sp[0x8]
80009750:	30 0a       	mov	r10,0
80009752:	50 2a       	stdsp	sp[0x8],r10
80009754:	40 29       	lddsp	r9,sp[0x8]
80009756:	e4 09 0c 49 	max	r9,r2,r9
8000975a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000975e:	50 39       	stdsp	sp[0xc],r9
80009760:	0a 9e       	mov	lr,r5
80009762:	30 09       	mov	r9,0
80009764:	e2 1e 00 02 	andl	lr,0x2,COH
80009768:	f2 08 18 00 	cp.b	r8,r9
8000976c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009770:	f7 b8 01 ff 	subne	r8,-1
80009774:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009778:	0a 9b       	mov	r11,r5
8000977a:	58 0e       	cp.w	lr,0
8000977c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009780:	f7 bc 01 fe 	subne	r12,-2
80009784:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009788:	e2 1b 00 84 	andl	r11,0x84,COH
8000978c:	50 fe       	stdsp	sp[0x3c],lr
8000978e:	50 9b       	stdsp	sp[0x24],r11
80009790:	c4 71       	brne	8000981e <_vfprintf_r+0x172e>
80009792:	40 8a       	lddsp	r10,sp[0x20]
80009794:	40 39       	lddsp	r9,sp[0xc]
80009796:	12 1a       	sub	r10,r9
80009798:	50 4a       	stdsp	sp[0x10],r10
8000979a:	58 0a       	cp.w	r10,0
8000979c:	e0 89 00 20 	brgt	800097dc <_vfprintf_r+0x16ec>
800097a0:	c3 f8       	rjmp	8000981e <_vfprintf_r+0x172e>
800097a2:	2f 09       	sub	r9,-16
800097a4:	2f f8       	sub	r8,-1
800097a6:	fe ce b7 fa 	sub	lr,pc,-18438
800097aa:	31 0c       	mov	r12,16
800097ac:	fb 49 06 90 	st.w	sp[1680],r9
800097b0:	87 0e       	st.w	r3[0x0],lr
800097b2:	87 1c       	st.w	r3[0x4],r12
800097b4:	fb 48 06 8c 	st.w	sp[1676],r8
800097b8:	58 78       	cp.w	r8,7
800097ba:	e0 89 00 04 	brgt	800097c2 <_vfprintf_r+0x16d2>
800097be:	2f 83       	sub	r3,-8
800097c0:	c0 b8       	rjmp	800097d6 <_vfprintf_r+0x16e6>
800097c2:	fa ca f9 78 	sub	r10,sp,-1672
800097c6:	02 9b       	mov	r11,r1
800097c8:	08 9c       	mov	r12,r4
800097ca:	fe b0 f4 85 	rcall	800080d4 <__sprint_r>
800097ce:	e0 81 04 10 	brne	80009fee <_vfprintf_r+0x1efe>
800097d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097d6:	40 4b       	lddsp	r11,sp[0x10]
800097d8:	21 0b       	sub	r11,16
800097da:	50 4b       	stdsp	sp[0x10],r11
800097dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800097e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097e4:	fe ca b8 38 	sub	r10,pc,-18376
800097e8:	40 4e       	lddsp	lr,sp[0x10]
800097ea:	59 0e       	cp.w	lr,16
800097ec:	fe 99 ff db 	brgt	800097a2 <_vfprintf_r+0x16b2>
800097f0:	1c 09       	add	r9,lr
800097f2:	2f f8       	sub	r8,-1
800097f4:	87 0a       	st.w	r3[0x0],r10
800097f6:	fb 49 06 90 	st.w	sp[1680],r9
800097fa:	87 1e       	st.w	r3[0x4],lr
800097fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009800:	58 78       	cp.w	r8,7
80009802:	e0 89 00 04 	brgt	8000980a <_vfprintf_r+0x171a>
80009806:	2f 83       	sub	r3,-8
80009808:	c0 b8       	rjmp	8000981e <_vfprintf_r+0x172e>
8000980a:	fa ca f9 78 	sub	r10,sp,-1672
8000980e:	02 9b       	mov	r11,r1
80009810:	08 9c       	mov	r12,r4
80009812:	fe b0 f4 61 	rcall	800080d4 <__sprint_r>
80009816:	e0 81 03 ec 	brne	80009fee <_vfprintf_r+0x1efe>
8000981a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000981e:	30 09       	mov	r9,0
80009820:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009824:	f2 08 18 00 	cp.b	r8,r9
80009828:	c1 f0       	breq	80009866 <_vfprintf_r+0x1776>
8000982a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000982e:	fa c9 f9 45 	sub	r9,sp,-1723
80009832:	2f f8       	sub	r8,-1
80009834:	87 09       	st.w	r3[0x0],r9
80009836:	fb 48 06 90 	st.w	sp[1680],r8
8000983a:	30 19       	mov	r9,1
8000983c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009840:	87 19       	st.w	r3[0x4],r9
80009842:	2f f8       	sub	r8,-1
80009844:	fb 48 06 8c 	st.w	sp[1676],r8
80009848:	58 78       	cp.w	r8,7
8000984a:	e0 89 00 04 	brgt	80009852 <_vfprintf_r+0x1762>
8000984e:	2f 83       	sub	r3,-8
80009850:	c0 b8       	rjmp	80009866 <_vfprintf_r+0x1776>
80009852:	fa ca f9 78 	sub	r10,sp,-1672
80009856:	02 9b       	mov	r11,r1
80009858:	08 9c       	mov	r12,r4
8000985a:	fe b0 f4 3d 	rcall	800080d4 <__sprint_r>
8000985e:	e0 81 03 c8 	brne	80009fee <_vfprintf_r+0x1efe>
80009862:	fa c3 f9 e0 	sub	r3,sp,-1568
80009866:	40 fc       	lddsp	r12,sp[0x3c]
80009868:	58 0c       	cp.w	r12,0
8000986a:	c1 f0       	breq	800098a8 <_vfprintf_r+0x17b8>
8000986c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009870:	fa c9 f9 48 	sub	r9,sp,-1720
80009874:	2f e8       	sub	r8,-2
80009876:	87 09       	st.w	r3[0x0],r9
80009878:	fb 48 06 90 	st.w	sp[1680],r8
8000987c:	30 29       	mov	r9,2
8000987e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009882:	87 19       	st.w	r3[0x4],r9
80009884:	2f f8       	sub	r8,-1
80009886:	fb 48 06 8c 	st.w	sp[1676],r8
8000988a:	58 78       	cp.w	r8,7
8000988c:	e0 89 00 04 	brgt	80009894 <_vfprintf_r+0x17a4>
80009890:	2f 83       	sub	r3,-8
80009892:	c0 b8       	rjmp	800098a8 <_vfprintf_r+0x17b8>
80009894:	fa ca f9 78 	sub	r10,sp,-1672
80009898:	02 9b       	mov	r11,r1
8000989a:	08 9c       	mov	r12,r4
8000989c:	fe b0 f4 1c 	rcall	800080d4 <__sprint_r>
800098a0:	e0 81 03 a7 	brne	80009fee <_vfprintf_r+0x1efe>
800098a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a8:	40 9b       	lddsp	r11,sp[0x24]
800098aa:	e0 4b 00 80 	cp.w	r11,128
800098ae:	c4 71       	brne	8000993c <_vfprintf_r+0x184c>
800098b0:	40 8a       	lddsp	r10,sp[0x20]
800098b2:	40 39       	lddsp	r9,sp[0xc]
800098b4:	12 1a       	sub	r10,r9
800098b6:	50 4a       	stdsp	sp[0x10],r10
800098b8:	58 0a       	cp.w	r10,0
800098ba:	e0 89 00 20 	brgt	800098fa <_vfprintf_r+0x180a>
800098be:	c3 f8       	rjmp	8000993c <_vfprintf_r+0x184c>
800098c0:	2f 09       	sub	r9,-16
800098c2:	2f f8       	sub	r8,-1
800098c4:	fe ce b9 08 	sub	lr,pc,-18168
800098c8:	31 0c       	mov	r12,16
800098ca:	fb 49 06 90 	st.w	sp[1680],r9
800098ce:	87 0e       	st.w	r3[0x0],lr
800098d0:	87 1c       	st.w	r3[0x4],r12
800098d2:	fb 48 06 8c 	st.w	sp[1676],r8
800098d6:	58 78       	cp.w	r8,7
800098d8:	e0 89 00 04 	brgt	800098e0 <_vfprintf_r+0x17f0>
800098dc:	2f 83       	sub	r3,-8
800098de:	c0 b8       	rjmp	800098f4 <_vfprintf_r+0x1804>
800098e0:	fa ca f9 78 	sub	r10,sp,-1672
800098e4:	02 9b       	mov	r11,r1
800098e6:	08 9c       	mov	r12,r4
800098e8:	fe b0 f3 f6 	rcall	800080d4 <__sprint_r>
800098ec:	e0 81 03 81 	brne	80009fee <_vfprintf_r+0x1efe>
800098f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098f4:	40 4b       	lddsp	r11,sp[0x10]
800098f6:	21 0b       	sub	r11,16
800098f8:	50 4b       	stdsp	sp[0x10],r11
800098fa:	fa f9 06 90 	ld.w	r9,sp[1680]
800098fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009902:	fe ca b9 46 	sub	r10,pc,-18106
80009906:	40 4e       	lddsp	lr,sp[0x10]
80009908:	59 0e       	cp.w	lr,16
8000990a:	fe 99 ff db 	brgt	800098c0 <_vfprintf_r+0x17d0>
8000990e:	1c 09       	add	r9,lr
80009910:	2f f8       	sub	r8,-1
80009912:	87 0a       	st.w	r3[0x0],r10
80009914:	fb 49 06 90 	st.w	sp[1680],r9
80009918:	87 1e       	st.w	r3[0x4],lr
8000991a:	fb 48 06 8c 	st.w	sp[1676],r8
8000991e:	58 78       	cp.w	r8,7
80009920:	e0 89 00 04 	brgt	80009928 <_vfprintf_r+0x1838>
80009924:	2f 83       	sub	r3,-8
80009926:	c0 b8       	rjmp	8000993c <_vfprintf_r+0x184c>
80009928:	fa ca f9 78 	sub	r10,sp,-1672
8000992c:	02 9b       	mov	r11,r1
8000992e:	08 9c       	mov	r12,r4
80009930:	fe b0 f3 d2 	rcall	800080d4 <__sprint_r>
80009934:	e0 81 03 5d 	brne	80009fee <_vfprintf_r+0x1efe>
80009938:	fa c3 f9 e0 	sub	r3,sp,-1568
8000993c:	40 2c       	lddsp	r12,sp[0x8]
8000993e:	04 1c       	sub	r12,r2
80009940:	50 2c       	stdsp	sp[0x8],r12
80009942:	58 0c       	cp.w	r12,0
80009944:	e0 89 00 20 	brgt	80009984 <_vfprintf_r+0x1894>
80009948:	c3 f8       	rjmp	800099c6 <_vfprintf_r+0x18d6>
8000994a:	2f 09       	sub	r9,-16
8000994c:	2f f8       	sub	r8,-1
8000994e:	fe cb b9 92 	sub	r11,pc,-18030
80009952:	31 0a       	mov	r10,16
80009954:	fb 49 06 90 	st.w	sp[1680],r9
80009958:	87 0b       	st.w	r3[0x0],r11
8000995a:	87 1a       	st.w	r3[0x4],r10
8000995c:	fb 48 06 8c 	st.w	sp[1676],r8
80009960:	58 78       	cp.w	r8,7
80009962:	e0 89 00 04 	brgt	8000996a <_vfprintf_r+0x187a>
80009966:	2f 83       	sub	r3,-8
80009968:	c0 b8       	rjmp	8000997e <_vfprintf_r+0x188e>
8000996a:	fa ca f9 78 	sub	r10,sp,-1672
8000996e:	02 9b       	mov	r11,r1
80009970:	08 9c       	mov	r12,r4
80009972:	fe b0 f3 b1 	rcall	800080d4 <__sprint_r>
80009976:	e0 81 03 3c 	brne	80009fee <_vfprintf_r+0x1efe>
8000997a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000997e:	40 29       	lddsp	r9,sp[0x8]
80009980:	21 09       	sub	r9,16
80009982:	50 29       	stdsp	sp[0x8],r9
80009984:	fa f9 06 90 	ld.w	r9,sp[1680]
80009988:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000998c:	fe ca b9 d0 	sub	r10,pc,-17968
80009990:	40 2e       	lddsp	lr,sp[0x8]
80009992:	59 0e       	cp.w	lr,16
80009994:	fe 99 ff db 	brgt	8000994a <_vfprintf_r+0x185a>
80009998:	1c 09       	add	r9,lr
8000999a:	2f f8       	sub	r8,-1
8000999c:	87 0a       	st.w	r3[0x0],r10
8000999e:	fb 49 06 90 	st.w	sp[1680],r9
800099a2:	87 1e       	st.w	r3[0x4],lr
800099a4:	fb 48 06 8c 	st.w	sp[1676],r8
800099a8:	58 78       	cp.w	r8,7
800099aa:	e0 89 00 04 	brgt	800099b2 <_vfprintf_r+0x18c2>
800099ae:	2f 83       	sub	r3,-8
800099b0:	c0 b8       	rjmp	800099c6 <_vfprintf_r+0x18d6>
800099b2:	fa ca f9 78 	sub	r10,sp,-1672
800099b6:	02 9b       	mov	r11,r1
800099b8:	08 9c       	mov	r12,r4
800099ba:	fe b0 f3 8d 	rcall	800080d4 <__sprint_r>
800099be:	e0 81 03 18 	brne	80009fee <_vfprintf_r+0x1efe>
800099c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c6:	ed b5 00 08 	bld	r5,0x8
800099ca:	c0 b0       	breq	800099e0 <_vfprintf_r+0x18f0>
800099cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800099d0:	87 12       	st.w	r3[0x4],r2
800099d2:	87 06       	st.w	r3[0x0],r6
800099d4:	f0 02 00 02 	add	r2,r8,r2
800099d8:	fb 42 06 90 	st.w	sp[1680],r2
800099dc:	e0 8f 01 d4 	bral	80009d84 <_vfprintf_r+0x1c94>
800099e0:	e0 40 00 65 	cp.w	r0,101
800099e4:	e0 8a 01 d6 	brle	80009d90 <_vfprintf_r+0x1ca0>
800099e8:	30 08       	mov	r8,0
800099ea:	30 09       	mov	r9,0
800099ec:	40 5b       	lddsp	r11,sp[0x14]
800099ee:	40 7a       	lddsp	r10,sp[0x1c]
800099f0:	e0 a0 15 3b 	rcall	8000c466 <__avr32_f64_cmp_eq>
800099f4:	c7 90       	breq	80009ae6 <_vfprintf_r+0x19f6>
800099f6:	fa f8 06 90 	ld.w	r8,sp[1680]
800099fa:	fe c9 ba 52 	sub	r9,pc,-17838
800099fe:	2f f8       	sub	r8,-1
80009a00:	87 09       	st.w	r3[0x0],r9
80009a02:	fb 48 06 90 	st.w	sp[1680],r8
80009a06:	30 19       	mov	r9,1
80009a08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a0c:	87 19       	st.w	r3[0x4],r9
80009a0e:	2f f8       	sub	r8,-1
80009a10:	fb 48 06 8c 	st.w	sp[1676],r8
80009a14:	58 78       	cp.w	r8,7
80009a16:	e0 89 00 05 	brgt	80009a20 <_vfprintf_r+0x1930>
80009a1a:	2f 83       	sub	r3,-8
80009a1c:	c0 c8       	rjmp	80009a34 <_vfprintf_r+0x1944>
80009a1e:	d7 03       	nop
80009a20:	fa ca f9 78 	sub	r10,sp,-1672
80009a24:	02 9b       	mov	r11,r1
80009a26:	08 9c       	mov	r12,r4
80009a28:	fe b0 f3 56 	rcall	800080d4 <__sprint_r>
80009a2c:	e0 81 02 e1 	brne	80009fee <_vfprintf_r+0x1efe>
80009a30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a34:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a38:	40 6c       	lddsp	r12,sp[0x18]
80009a3a:	18 38       	cp.w	r8,r12
80009a3c:	c0 55       	brlt	80009a46 <_vfprintf_r+0x1956>
80009a3e:	ed b5 00 00 	bld	r5,0x0
80009a42:	e0 81 02 6b 	brne	80009f18 <_vfprintf_r+0x1e28>
80009a46:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a4a:	2f f8       	sub	r8,-1
80009a4c:	40 cb       	lddsp	r11,sp[0x30]
80009a4e:	fb 48 06 90 	st.w	sp[1680],r8
80009a52:	30 19       	mov	r9,1
80009a54:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a58:	87 0b       	st.w	r3[0x0],r11
80009a5a:	2f f8       	sub	r8,-1
80009a5c:	87 19       	st.w	r3[0x4],r9
80009a5e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a62:	58 78       	cp.w	r8,7
80009a64:	e0 89 00 04 	brgt	80009a6c <_vfprintf_r+0x197c>
80009a68:	2f 83       	sub	r3,-8
80009a6a:	c0 b8       	rjmp	80009a80 <_vfprintf_r+0x1990>
80009a6c:	fa ca f9 78 	sub	r10,sp,-1672
80009a70:	02 9b       	mov	r11,r1
80009a72:	08 9c       	mov	r12,r4
80009a74:	fe b0 f3 30 	rcall	800080d4 <__sprint_r>
80009a78:	e0 81 02 bb 	brne	80009fee <_vfprintf_r+0x1efe>
80009a7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a80:	40 66       	lddsp	r6,sp[0x18]
80009a82:	20 16       	sub	r6,1
80009a84:	58 06       	cp.w	r6,0
80009a86:	e0 89 00 1d 	brgt	80009ac0 <_vfprintf_r+0x19d0>
80009a8a:	e0 8f 02 47 	bral	80009f18 <_vfprintf_r+0x1e28>
80009a8e:	2f 09       	sub	r9,-16
80009a90:	2f f8       	sub	r8,-1
80009a92:	fb 49 06 90 	st.w	sp[1680],r9
80009a96:	87 02       	st.w	r3[0x0],r2
80009a98:	87 10       	st.w	r3[0x4],r0
80009a9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9e:	58 78       	cp.w	r8,7
80009aa0:	e0 89 00 04 	brgt	80009aa8 <_vfprintf_r+0x19b8>
80009aa4:	2f 83       	sub	r3,-8
80009aa6:	c0 b8       	rjmp	80009abc <_vfprintf_r+0x19cc>
80009aa8:	fa ca f9 78 	sub	r10,sp,-1672
80009aac:	02 9b       	mov	r11,r1
80009aae:	08 9c       	mov	r12,r4
80009ab0:	fe b0 f3 12 	rcall	800080d4 <__sprint_r>
80009ab4:	e0 81 02 9d 	brne	80009fee <_vfprintf_r+0x1efe>
80009ab8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009abc:	21 06       	sub	r6,16
80009abe:	c0 48       	rjmp	80009ac6 <_vfprintf_r+0x19d6>
80009ac0:	fe c2 bb 04 	sub	r2,pc,-17660
80009ac4:	31 00       	mov	r0,16
80009ac6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009aca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ace:	fe ca bb 12 	sub	r10,pc,-17646
80009ad2:	59 06       	cp.w	r6,16
80009ad4:	fe 99 ff dd 	brgt	80009a8e <_vfprintf_r+0x199e>
80009ad8:	0c 09       	add	r9,r6
80009ada:	87 0a       	st.w	r3[0x0],r10
80009adc:	fb 49 06 90 	st.w	sp[1680],r9
80009ae0:	2f f8       	sub	r8,-1
80009ae2:	87 16       	st.w	r3[0x4],r6
80009ae4:	c5 39       	rjmp	80009d8a <_vfprintf_r+0x1c9a>
80009ae6:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009aea:	58 0a       	cp.w	r10,0
80009aec:	e0 89 00 92 	brgt	80009c10 <_vfprintf_r+0x1b20>
80009af0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af4:	fe c9 bb 4c 	sub	r9,pc,-17588
80009af8:	2f f8       	sub	r8,-1
80009afa:	87 09       	st.w	r3[0x0],r9
80009afc:	fb 48 06 90 	st.w	sp[1680],r8
80009b00:	30 19       	mov	r9,1
80009b02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b06:	87 19       	st.w	r3[0x4],r9
80009b08:	2f f8       	sub	r8,-1
80009b0a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b0e:	58 78       	cp.w	r8,7
80009b10:	e0 89 00 04 	brgt	80009b18 <_vfprintf_r+0x1a28>
80009b14:	2f 83       	sub	r3,-8
80009b16:	c0 b8       	rjmp	80009b2c <_vfprintf_r+0x1a3c>
80009b18:	fa ca f9 78 	sub	r10,sp,-1672
80009b1c:	02 9b       	mov	r11,r1
80009b1e:	08 9c       	mov	r12,r4
80009b20:	fe b0 f2 da 	rcall	800080d4 <__sprint_r>
80009b24:	e0 81 02 65 	brne	80009fee <_vfprintf_r+0x1efe>
80009b28:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b2c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b30:	58 08       	cp.w	r8,0
80009b32:	c0 81       	brne	80009b42 <_vfprintf_r+0x1a52>
80009b34:	40 6a       	lddsp	r10,sp[0x18]
80009b36:	58 0a       	cp.w	r10,0
80009b38:	c0 51       	brne	80009b42 <_vfprintf_r+0x1a52>
80009b3a:	ed b5 00 00 	bld	r5,0x0
80009b3e:	e0 81 01 ed 	brne	80009f18 <_vfprintf_r+0x1e28>
80009b42:	40 c9       	lddsp	r9,sp[0x30]
80009b44:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b48:	2f f8       	sub	r8,-1
80009b4a:	87 09       	st.w	r3[0x0],r9
80009b4c:	fb 48 06 90 	st.w	sp[1680],r8
80009b50:	30 19       	mov	r9,1
80009b52:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b56:	87 19       	st.w	r3[0x4],r9
80009b58:	2f f8       	sub	r8,-1
80009b5a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b5e:	58 78       	cp.w	r8,7
80009b60:	e0 89 00 04 	brgt	80009b68 <_vfprintf_r+0x1a78>
80009b64:	2f 83       	sub	r3,-8
80009b66:	c0 b8       	rjmp	80009b7c <_vfprintf_r+0x1a8c>
80009b68:	fa ca f9 78 	sub	r10,sp,-1672
80009b6c:	02 9b       	mov	r11,r1
80009b6e:	08 9c       	mov	r12,r4
80009b70:	fe b0 f2 b2 	rcall	800080d4 <__sprint_r>
80009b74:	e0 81 02 3d 	brne	80009fee <_vfprintf_r+0x1efe>
80009b78:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b7c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b80:	5c 32       	neg	r2
80009b82:	58 02       	cp.w	r2,0
80009b84:	e0 89 00 1d 	brgt	80009bbe <_vfprintf_r+0x1ace>
80009b88:	c3 d8       	rjmp	80009c02 <_vfprintf_r+0x1b12>
80009b8a:	2f 09       	sub	r9,-16
80009b8c:	2f f8       	sub	r8,-1
80009b8e:	31 0e       	mov	lr,16
80009b90:	fb 49 06 90 	st.w	sp[1680],r9
80009b94:	87 00       	st.w	r3[0x0],r0
80009b96:	87 1e       	st.w	r3[0x4],lr
80009b98:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9c:	58 78       	cp.w	r8,7
80009b9e:	e0 89 00 04 	brgt	80009ba6 <_vfprintf_r+0x1ab6>
80009ba2:	2f 83       	sub	r3,-8
80009ba4:	c0 b8       	rjmp	80009bba <_vfprintf_r+0x1aca>
80009ba6:	fa ca f9 78 	sub	r10,sp,-1672
80009baa:	02 9b       	mov	r11,r1
80009bac:	08 9c       	mov	r12,r4
80009bae:	fe b0 f2 93 	rcall	800080d4 <__sprint_r>
80009bb2:	e0 81 02 1e 	brne	80009fee <_vfprintf_r+0x1efe>
80009bb6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bba:	21 02       	sub	r2,16
80009bbc:	c0 38       	rjmp	80009bc2 <_vfprintf_r+0x1ad2>
80009bbe:	fe c0 bc 02 	sub	r0,pc,-17406
80009bc2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bc6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bca:	fe ca bc 0e 	sub	r10,pc,-17394
80009bce:	59 02       	cp.w	r2,16
80009bd0:	fe 99 ff dd 	brgt	80009b8a <_vfprintf_r+0x1a9a>
80009bd4:	04 09       	add	r9,r2
80009bd6:	2f f8       	sub	r8,-1
80009bd8:	87 0a       	st.w	r3[0x0],r10
80009bda:	fb 49 06 90 	st.w	sp[1680],r9
80009bde:	87 12       	st.w	r3[0x4],r2
80009be0:	fb 48 06 8c 	st.w	sp[1676],r8
80009be4:	58 78       	cp.w	r8,7
80009be6:	e0 89 00 04 	brgt	80009bee <_vfprintf_r+0x1afe>
80009bea:	2f 83       	sub	r3,-8
80009bec:	c0 b8       	rjmp	80009c02 <_vfprintf_r+0x1b12>
80009bee:	fa ca f9 78 	sub	r10,sp,-1672
80009bf2:	02 9b       	mov	r11,r1
80009bf4:	08 9c       	mov	r12,r4
80009bf6:	fe b0 f2 6f 	rcall	800080d4 <__sprint_r>
80009bfa:	e0 81 01 fa 	brne	80009fee <_vfprintf_r+0x1efe>
80009bfe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c02:	40 6c       	lddsp	r12,sp[0x18]
80009c04:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c08:	87 06       	st.w	r3[0x0],r6
80009c0a:	87 1c       	st.w	r3[0x4],r12
80009c0c:	18 08       	add	r8,r12
80009c0e:	cb 98       	rjmp	80009d80 <_vfprintf_r+0x1c90>
80009c10:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c14:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c18:	40 6b       	lddsp	r11,sp[0x18]
80009c1a:	16 3a       	cp.w	r10,r11
80009c1c:	c6 f5       	brlt	80009cfa <_vfprintf_r+0x1c0a>
80009c1e:	16 09       	add	r9,r11
80009c20:	2f f8       	sub	r8,-1
80009c22:	87 06       	st.w	r3[0x0],r6
80009c24:	fb 49 06 90 	st.w	sp[1680],r9
80009c28:	87 1b       	st.w	r3[0x4],r11
80009c2a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c2e:	58 78       	cp.w	r8,7
80009c30:	e0 89 00 04 	brgt	80009c38 <_vfprintf_r+0x1b48>
80009c34:	2f 83       	sub	r3,-8
80009c36:	c0 b8       	rjmp	80009c4c <_vfprintf_r+0x1b5c>
80009c38:	fa ca f9 78 	sub	r10,sp,-1672
80009c3c:	02 9b       	mov	r11,r1
80009c3e:	08 9c       	mov	r12,r4
80009c40:	fe b0 f2 4a 	rcall	800080d4 <__sprint_r>
80009c44:	e0 81 01 d5 	brne	80009fee <_vfprintf_r+0x1efe>
80009c48:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c4c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c50:	40 6a       	lddsp	r10,sp[0x18]
80009c52:	14 16       	sub	r6,r10
80009c54:	58 06       	cp.w	r6,0
80009c56:	e0 89 00 1c 	brgt	80009c8e <_vfprintf_r+0x1b9e>
80009c5a:	c3 d8       	rjmp	80009cd4 <_vfprintf_r+0x1be4>
80009c5c:	2f 09       	sub	r9,-16
80009c5e:	2f f8       	sub	r8,-1
80009c60:	fb 49 06 90 	st.w	sp[1680],r9
80009c64:	87 02       	st.w	r3[0x0],r2
80009c66:	87 10       	st.w	r3[0x4],r0
80009c68:	fb 48 06 8c 	st.w	sp[1676],r8
80009c6c:	58 78       	cp.w	r8,7
80009c6e:	e0 89 00 04 	brgt	80009c76 <_vfprintf_r+0x1b86>
80009c72:	2f 83       	sub	r3,-8
80009c74:	c0 b8       	rjmp	80009c8a <_vfprintf_r+0x1b9a>
80009c76:	fa ca f9 78 	sub	r10,sp,-1672
80009c7a:	02 9b       	mov	r11,r1
80009c7c:	08 9c       	mov	r12,r4
80009c7e:	fe b0 f2 2b 	rcall	800080d4 <__sprint_r>
80009c82:	e0 81 01 b6 	brne	80009fee <_vfprintf_r+0x1efe>
80009c86:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c8a:	21 06       	sub	r6,16
80009c8c:	c0 48       	rjmp	80009c94 <_vfprintf_r+0x1ba4>
80009c8e:	fe c2 bc d2 	sub	r2,pc,-17198
80009c92:	31 00       	mov	r0,16
80009c94:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c9c:	fe ca bc e0 	sub	r10,pc,-17184
80009ca0:	59 06       	cp.w	r6,16
80009ca2:	fe 99 ff dd 	brgt	80009c5c <_vfprintf_r+0x1b6c>
80009ca6:	0c 09       	add	r9,r6
80009ca8:	2f f8       	sub	r8,-1
80009caa:	87 0a       	st.w	r3[0x0],r10
80009cac:	fb 49 06 90 	st.w	sp[1680],r9
80009cb0:	87 16       	st.w	r3[0x4],r6
80009cb2:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb6:	58 78       	cp.w	r8,7
80009cb8:	e0 89 00 04 	brgt	80009cc0 <_vfprintf_r+0x1bd0>
80009cbc:	2f 83       	sub	r3,-8
80009cbe:	c0 b8       	rjmp	80009cd4 <_vfprintf_r+0x1be4>
80009cc0:	fa ca f9 78 	sub	r10,sp,-1672
80009cc4:	02 9b       	mov	r11,r1
80009cc6:	08 9c       	mov	r12,r4
80009cc8:	fe b0 f2 06 	rcall	800080d4 <__sprint_r>
80009ccc:	e0 81 01 91 	brne	80009fee <_vfprintf_r+0x1efe>
80009cd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cd4:	ed b5 00 00 	bld	r5,0x0
80009cd8:	e0 81 01 20 	brne	80009f18 <_vfprintf_r+0x1e28>
80009cdc:	40 c9       	lddsp	r9,sp[0x30]
80009cde:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ce2:	2f f8       	sub	r8,-1
80009ce4:	87 09       	st.w	r3[0x0],r9
80009ce6:	fb 48 06 90 	st.w	sp[1680],r8
80009cea:	30 19       	mov	r9,1
80009cec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cf0:	87 19       	st.w	r3[0x4],r9
80009cf2:	2f f8       	sub	r8,-1
80009cf4:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf8:	c0 29       	rjmp	80009efc <_vfprintf_r+0x1e0c>
80009cfa:	14 09       	add	r9,r10
80009cfc:	2f f8       	sub	r8,-1
80009cfe:	fb 49 06 90 	st.w	sp[1680],r9
80009d02:	87 06       	st.w	r3[0x0],r6
80009d04:	87 1a       	st.w	r3[0x4],r10
80009d06:	fb 48 06 8c 	st.w	sp[1676],r8
80009d0a:	58 78       	cp.w	r8,7
80009d0c:	e0 89 00 04 	brgt	80009d14 <_vfprintf_r+0x1c24>
80009d10:	2f 83       	sub	r3,-8
80009d12:	c0 b8       	rjmp	80009d28 <_vfprintf_r+0x1c38>
80009d14:	fa ca f9 78 	sub	r10,sp,-1672
80009d18:	02 9b       	mov	r11,r1
80009d1a:	08 9c       	mov	r12,r4
80009d1c:	fe b0 f1 dc 	rcall	800080d4 <__sprint_r>
80009d20:	e0 81 01 67 	brne	80009fee <_vfprintf_r+0x1efe>
80009d24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d28:	40 c8       	lddsp	r8,sp[0x30]
80009d2a:	87 08       	st.w	r3[0x0],r8
80009d2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d30:	2f f8       	sub	r8,-1
80009d32:	30 19       	mov	r9,1
80009d34:	fb 48 06 90 	st.w	sp[1680],r8
80009d38:	87 19       	st.w	r3[0x4],r9
80009d3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d3e:	2f f8       	sub	r8,-1
80009d40:	fb 48 06 8c 	st.w	sp[1676],r8
80009d44:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d48:	58 78       	cp.w	r8,7
80009d4a:	e0 89 00 04 	brgt	80009d52 <_vfprintf_r+0x1c62>
80009d4e:	2f 83       	sub	r3,-8
80009d50:	c0 b8       	rjmp	80009d66 <_vfprintf_r+0x1c76>
80009d52:	fa ca f9 78 	sub	r10,sp,-1672
80009d56:	02 9b       	mov	r11,r1
80009d58:	08 9c       	mov	r12,r4
80009d5a:	fe b0 f1 bd 	rcall	800080d4 <__sprint_r>
80009d5e:	e0 81 01 48 	brne	80009fee <_vfprintf_r+0x1efe>
80009d62:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d66:	04 06       	add	r6,r2
80009d68:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d6c:	87 06       	st.w	r3[0x0],r6
80009d6e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d72:	40 66       	lddsp	r6,sp[0x18]
80009d74:	40 6e       	lddsp	lr,sp[0x18]
80009d76:	10 16       	sub	r6,r8
80009d78:	f2 08 01 08 	sub	r8,r9,r8
80009d7c:	87 16       	st.w	r3[0x4],r6
80009d7e:	1c 08       	add	r8,lr
80009d80:	fb 48 06 90 	st.w	sp[1680],r8
80009d84:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d88:	2f f8       	sub	r8,-1
80009d8a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d8e:	cb 78       	rjmp	80009efc <_vfprintf_r+0x1e0c>
80009d90:	40 6c       	lddsp	r12,sp[0x18]
80009d92:	58 1c       	cp.w	r12,1
80009d94:	e0 89 00 06 	brgt	80009da0 <_vfprintf_r+0x1cb0>
80009d98:	ed b5 00 00 	bld	r5,0x0
80009d9c:	e0 81 00 85 	brne	80009ea6 <_vfprintf_r+0x1db6>
80009da0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009da4:	2f f8       	sub	r8,-1
80009da6:	30 19       	mov	r9,1
80009da8:	fb 48 06 90 	st.w	sp[1680],r8
80009dac:	87 06       	st.w	r3[0x0],r6
80009dae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009db2:	87 19       	st.w	r3[0x4],r9
80009db4:	2f f8       	sub	r8,-1
80009db6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dba:	58 78       	cp.w	r8,7
80009dbc:	e0 89 00 04 	brgt	80009dc4 <_vfprintf_r+0x1cd4>
80009dc0:	2f 83       	sub	r3,-8
80009dc2:	c0 b8       	rjmp	80009dd8 <_vfprintf_r+0x1ce8>
80009dc4:	fa ca f9 78 	sub	r10,sp,-1672
80009dc8:	02 9b       	mov	r11,r1
80009dca:	08 9c       	mov	r12,r4
80009dcc:	fe b0 f1 84 	rcall	800080d4 <__sprint_r>
80009dd0:	e0 81 01 0f 	brne	80009fee <_vfprintf_r+0x1efe>
80009dd4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dd8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ddc:	2f f8       	sub	r8,-1
80009dde:	40 cb       	lddsp	r11,sp[0x30]
80009de0:	fb 48 06 90 	st.w	sp[1680],r8
80009de4:	30 19       	mov	r9,1
80009de6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dea:	87 0b       	st.w	r3[0x0],r11
80009dec:	2f f8       	sub	r8,-1
80009dee:	87 19       	st.w	r3[0x4],r9
80009df0:	fb 48 06 8c 	st.w	sp[1676],r8
80009df4:	58 78       	cp.w	r8,7
80009df6:	e0 89 00 05 	brgt	80009e00 <_vfprintf_r+0x1d10>
80009dfa:	2f 83       	sub	r3,-8
80009dfc:	c0 c8       	rjmp	80009e14 <_vfprintf_r+0x1d24>
80009dfe:	d7 03       	nop
80009e00:	fa ca f9 78 	sub	r10,sp,-1672
80009e04:	02 9b       	mov	r11,r1
80009e06:	08 9c       	mov	r12,r4
80009e08:	fe b0 f1 66 	rcall	800080d4 <__sprint_r>
80009e0c:	e0 81 00 f1 	brne	80009fee <_vfprintf_r+0x1efe>
80009e10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e14:	30 08       	mov	r8,0
80009e16:	30 09       	mov	r9,0
80009e18:	40 5b       	lddsp	r11,sp[0x14]
80009e1a:	40 7a       	lddsp	r10,sp[0x1c]
80009e1c:	e0 a0 13 25 	rcall	8000c466 <__avr32_f64_cmp_eq>
80009e20:	40 68       	lddsp	r8,sp[0x18]
80009e22:	20 18       	sub	r8,1
80009e24:	58 0c       	cp.w	r12,0
80009e26:	c0 d1       	brne	80009e40 <_vfprintf_r+0x1d50>
80009e28:	2f f6       	sub	r6,-1
80009e2a:	87 18       	st.w	r3[0x4],r8
80009e2c:	87 06       	st.w	r3[0x0],r6
80009e2e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e32:	10 06       	add	r6,r8
80009e34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e38:	fb 46 06 90 	st.w	sp[1680],r6
80009e3c:	2f f8       	sub	r8,-1
80009e3e:	c3 18       	rjmp	80009ea0 <_vfprintf_r+0x1db0>
80009e40:	10 96       	mov	r6,r8
80009e42:	58 08       	cp.w	r8,0
80009e44:	e0 89 00 1c 	brgt	80009e7c <_vfprintf_r+0x1d8c>
80009e48:	c4 b8       	rjmp	80009ede <_vfprintf_r+0x1dee>
80009e4a:	2f 09       	sub	r9,-16
80009e4c:	2f f8       	sub	r8,-1
80009e4e:	fb 49 06 90 	st.w	sp[1680],r9
80009e52:	87 02       	st.w	r3[0x0],r2
80009e54:	87 10       	st.w	r3[0x4],r0
80009e56:	fb 48 06 8c 	st.w	sp[1676],r8
80009e5a:	58 78       	cp.w	r8,7
80009e5c:	e0 89 00 04 	brgt	80009e64 <_vfprintf_r+0x1d74>
80009e60:	2f 83       	sub	r3,-8
80009e62:	c0 b8       	rjmp	80009e78 <_vfprintf_r+0x1d88>
80009e64:	fa ca f9 78 	sub	r10,sp,-1672
80009e68:	02 9b       	mov	r11,r1
80009e6a:	08 9c       	mov	r12,r4
80009e6c:	fe b0 f1 34 	rcall	800080d4 <__sprint_r>
80009e70:	e0 81 00 bf 	brne	80009fee <_vfprintf_r+0x1efe>
80009e74:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e78:	21 06       	sub	r6,16
80009e7a:	c0 48       	rjmp	80009e82 <_vfprintf_r+0x1d92>
80009e7c:	fe c2 be c0 	sub	r2,pc,-16704
80009e80:	31 00       	mov	r0,16
80009e82:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e8a:	fe ca be ce 	sub	r10,pc,-16690
80009e8e:	59 06       	cp.w	r6,16
80009e90:	fe 99 ff dd 	brgt	80009e4a <_vfprintf_r+0x1d5a>
80009e94:	0c 09       	add	r9,r6
80009e96:	87 0a       	st.w	r3[0x0],r10
80009e98:	fb 49 06 90 	st.w	sp[1680],r9
80009e9c:	2f f8       	sub	r8,-1
80009e9e:	87 16       	st.w	r3[0x4],r6
80009ea0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ea4:	c0 e8       	rjmp	80009ec0 <_vfprintf_r+0x1dd0>
80009ea6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009eaa:	2f f8       	sub	r8,-1
80009eac:	30 19       	mov	r9,1
80009eae:	fb 48 06 90 	st.w	sp[1680],r8
80009eb2:	87 06       	st.w	r3[0x0],r6
80009eb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eb8:	87 19       	st.w	r3[0x4],r9
80009eba:	2f f8       	sub	r8,-1
80009ebc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ec0:	58 78       	cp.w	r8,7
80009ec2:	e0 89 00 04 	brgt	80009eca <_vfprintf_r+0x1dda>
80009ec6:	2f 83       	sub	r3,-8
80009ec8:	c0 b8       	rjmp	80009ede <_vfprintf_r+0x1dee>
80009eca:	fa ca f9 78 	sub	r10,sp,-1672
80009ece:	02 9b       	mov	r11,r1
80009ed0:	08 9c       	mov	r12,r4
80009ed2:	fe b0 f1 01 	rcall	800080d4 <__sprint_r>
80009ed6:	e0 81 00 8c 	brne	80009fee <_vfprintf_r+0x1efe>
80009eda:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ede:	40 ea       	lddsp	r10,sp[0x38]
80009ee0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ee4:	14 08       	add	r8,r10
80009ee6:	fa c9 f9 64 	sub	r9,sp,-1692
80009eea:	fb 48 06 90 	st.w	sp[1680],r8
80009eee:	87 1a       	st.w	r3[0x4],r10
80009ef0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ef4:	87 09       	st.w	r3[0x0],r9
80009ef6:	2f f8       	sub	r8,-1
80009ef8:	fb 48 06 8c 	st.w	sp[1676],r8
80009efc:	58 78       	cp.w	r8,7
80009efe:	e0 89 00 04 	brgt	80009f06 <_vfprintf_r+0x1e16>
80009f02:	2f 83       	sub	r3,-8
80009f04:	c0 a8       	rjmp	80009f18 <_vfprintf_r+0x1e28>
80009f06:	fa ca f9 78 	sub	r10,sp,-1672
80009f0a:	02 9b       	mov	r11,r1
80009f0c:	08 9c       	mov	r12,r4
80009f0e:	fe b0 f0 e3 	rcall	800080d4 <__sprint_r>
80009f12:	c6 e1       	brne	80009fee <_vfprintf_r+0x1efe>
80009f14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f18:	e2 15 00 04 	andl	r5,0x4,COH
80009f1c:	c3 f0       	breq	80009f9a <_vfprintf_r+0x1eaa>
80009f1e:	40 86       	lddsp	r6,sp[0x20]
80009f20:	40 39       	lddsp	r9,sp[0xc]
80009f22:	12 16       	sub	r6,r9
80009f24:	58 06       	cp.w	r6,0
80009f26:	e0 89 00 1a 	brgt	80009f5a <_vfprintf_r+0x1e6a>
80009f2a:	c3 88       	rjmp	80009f9a <_vfprintf_r+0x1eaa>
80009f2c:	2f 09       	sub	r9,-16
80009f2e:	2f f8       	sub	r8,-1
80009f30:	fb 49 06 90 	st.w	sp[1680],r9
80009f34:	87 05       	st.w	r3[0x0],r5
80009f36:	87 12       	st.w	r3[0x4],r2
80009f38:	fb 48 06 8c 	st.w	sp[1676],r8
80009f3c:	58 78       	cp.w	r8,7
80009f3e:	e0 89 00 04 	brgt	80009f46 <_vfprintf_r+0x1e56>
80009f42:	2f 83       	sub	r3,-8
80009f44:	c0 98       	rjmp	80009f56 <_vfprintf_r+0x1e66>
80009f46:	00 9a       	mov	r10,r0
80009f48:	02 9b       	mov	r11,r1
80009f4a:	08 9c       	mov	r12,r4
80009f4c:	fe b0 f0 c4 	rcall	800080d4 <__sprint_r>
80009f50:	c4 f1       	brne	80009fee <_vfprintf_r+0x1efe>
80009f52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f56:	21 06       	sub	r6,16
80009f58:	c0 68       	rjmp	80009f64 <_vfprintf_r+0x1e74>
80009f5a:	fe c5 bf ae 	sub	r5,pc,-16466
80009f5e:	31 02       	mov	r2,16
80009f60:	fa c0 f9 78 	sub	r0,sp,-1672
80009f64:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f6c:	fe ca bf c0 	sub	r10,pc,-16448
80009f70:	59 06       	cp.w	r6,16
80009f72:	fe 99 ff dd 	brgt	80009f2c <_vfprintf_r+0x1e3c>
80009f76:	0c 09       	add	r9,r6
80009f78:	2f f8       	sub	r8,-1
80009f7a:	87 0a       	st.w	r3[0x0],r10
80009f7c:	87 16       	st.w	r3[0x4],r6
80009f7e:	fb 49 06 90 	st.w	sp[1680],r9
80009f82:	fb 48 06 8c 	st.w	sp[1676],r8
80009f86:	58 78       	cp.w	r8,7
80009f88:	e0 8a 00 09 	brle	80009f9a <_vfprintf_r+0x1eaa>
80009f8c:	fa ca f9 78 	sub	r10,sp,-1672
80009f90:	02 9b       	mov	r11,r1
80009f92:	08 9c       	mov	r12,r4
80009f94:	fe b0 f0 a0 	rcall	800080d4 <__sprint_r>
80009f98:	c2 b1       	brne	80009fee <_vfprintf_r+0x1efe>
80009f9a:	40 bc       	lddsp	r12,sp[0x2c]
80009f9c:	40 36       	lddsp	r6,sp[0xc]
80009f9e:	40 8e       	lddsp	lr,sp[0x20]
80009fa0:	ec 0e 0c 48 	max	r8,r6,lr
80009fa4:	10 0c       	add	r12,r8
80009fa6:	50 bc       	stdsp	sp[0x2c],r12
80009fa8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fac:	58 08       	cp.w	r8,0
80009fae:	c0 80       	breq	80009fbe <_vfprintf_r+0x1ece>
80009fb0:	fa ca f9 78 	sub	r10,sp,-1672
80009fb4:	02 9b       	mov	r11,r1
80009fb6:	08 9c       	mov	r12,r4
80009fb8:	fe b0 f0 8e 	rcall	800080d4 <__sprint_r>
80009fbc:	c1 91       	brne	80009fee <_vfprintf_r+0x1efe>
80009fbe:	30 0b       	mov	r11,0
80009fc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fc4:	fb 4b 06 8c 	st.w	sp[1676],r11
80009fc8:	fe 9f f1 22 	bral	8000820c <_vfprintf_r+0x11c>
80009fcc:	08 95       	mov	r5,r4
80009fce:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fd2:	58 08       	cp.w	r8,0
80009fd4:	c0 80       	breq	80009fe4 <_vfprintf_r+0x1ef4>
80009fd6:	08 9c       	mov	r12,r4
80009fd8:	fa ca f9 78 	sub	r10,sp,-1672
80009fdc:	02 9b       	mov	r11,r1
80009fde:	fe b0 f0 7b 	rcall	800080d4 <__sprint_r>
80009fe2:	c0 61       	brne	80009fee <_vfprintf_r+0x1efe>
80009fe4:	30 08       	mov	r8,0
80009fe6:	fb 48 06 8c 	st.w	sp[1676],r8
80009fea:	c0 28       	rjmp	80009fee <_vfprintf_r+0x1efe>
80009fec:	40 41       	lddsp	r1,sp[0x10]
80009fee:	82 68       	ld.sh	r8,r1[0xc]
80009ff0:	ed b8 00 06 	bld	r8,0x6
80009ff4:	c0 31       	brne	80009ffa <_vfprintf_r+0x1f0a>
80009ff6:	3f fa       	mov	r10,-1
80009ff8:	50 ba       	stdsp	sp[0x2c],r10
80009ffa:	40 bc       	lddsp	r12,sp[0x2c]
80009ffc:	fe 3d f9 44 	sub	sp,-1724
8000a000:	d8 32       	popm	r0-r7,pc
8000a002:	d7 03       	nop

8000a004 <__swsetup_r>:
8000a004:	d4 21       	pushm	r4-r7,lr
8000a006:	e0 68 0a 40 	mov	r8,2624
8000a00a:	18 96       	mov	r6,r12
8000a00c:	16 97       	mov	r7,r11
8000a00e:	70 0c       	ld.w	r12,r8[0x0]
8000a010:	58 0c       	cp.w	r12,0
8000a012:	c0 60       	breq	8000a01e <__swsetup_r+0x1a>
8000a014:	78 68       	ld.w	r8,r12[0x18]
8000a016:	58 08       	cp.w	r8,0
8000a018:	c0 31       	brne	8000a01e <__swsetup_r+0x1a>
8000a01a:	e0 a0 07 bf 	rcall	8000af98 <__sinit>
8000a01e:	fe c8 bf 42 	sub	r8,pc,-16574
8000a022:	10 37       	cp.w	r7,r8
8000a024:	c0 61       	brne	8000a030 <__swsetup_r+0x2c>
8000a026:	e0 68 0a 40 	mov	r8,2624
8000a02a:	70 08       	ld.w	r8,r8[0x0]
8000a02c:	70 07       	ld.w	r7,r8[0x0]
8000a02e:	c1 28       	rjmp	8000a052 <__swsetup_r+0x4e>
8000a030:	fe c8 bf 34 	sub	r8,pc,-16588
8000a034:	10 37       	cp.w	r7,r8
8000a036:	c0 61       	brne	8000a042 <__swsetup_r+0x3e>
8000a038:	e0 68 0a 40 	mov	r8,2624
8000a03c:	70 08       	ld.w	r8,r8[0x0]
8000a03e:	70 17       	ld.w	r7,r8[0x4]
8000a040:	c0 98       	rjmp	8000a052 <__swsetup_r+0x4e>
8000a042:	fe c8 bf 26 	sub	r8,pc,-16602
8000a046:	10 37       	cp.w	r7,r8
8000a048:	c0 51       	brne	8000a052 <__swsetup_r+0x4e>
8000a04a:	e0 68 0a 40 	mov	r8,2624
8000a04e:	70 08       	ld.w	r8,r8[0x0]
8000a050:	70 27       	ld.w	r7,r8[0x8]
8000a052:	8e 68       	ld.sh	r8,r7[0xc]
8000a054:	ed b8 00 03 	bld	r8,0x3
8000a058:	c1 e0       	breq	8000a094 <__swsetup_r+0x90>
8000a05a:	ed b8 00 04 	bld	r8,0x4
8000a05e:	c3 e1       	brne	8000a0da <__swsetup_r+0xd6>
8000a060:	ed b8 00 02 	bld	r8,0x2
8000a064:	c1 51       	brne	8000a08e <__swsetup_r+0x8a>
8000a066:	6e db       	ld.w	r11,r7[0x34]
8000a068:	58 0b       	cp.w	r11,0
8000a06a:	c0 a0       	breq	8000a07e <__swsetup_r+0x7a>
8000a06c:	ee c8 ff bc 	sub	r8,r7,-68
8000a070:	10 3b       	cp.w	r11,r8
8000a072:	c0 40       	breq	8000a07a <__swsetup_r+0x76>
8000a074:	0c 9c       	mov	r12,r6
8000a076:	e0 a0 08 2b 	rcall	8000b0cc <_free_r>
8000a07a:	30 08       	mov	r8,0
8000a07c:	8f d8       	st.w	r7[0x34],r8
8000a07e:	8e 68       	ld.sh	r8,r7[0xc]
8000a080:	e0 18 ff db 	andl	r8,0xffdb
8000a084:	ae 68       	st.h	r7[0xc],r8
8000a086:	30 08       	mov	r8,0
8000a088:	8f 18       	st.w	r7[0x4],r8
8000a08a:	6e 48       	ld.w	r8,r7[0x10]
8000a08c:	8f 08       	st.w	r7[0x0],r8
8000a08e:	8e 68       	ld.sh	r8,r7[0xc]
8000a090:	a3 b8       	sbr	r8,0x3
8000a092:	ae 68       	st.h	r7[0xc],r8
8000a094:	6e 48       	ld.w	r8,r7[0x10]
8000a096:	58 08       	cp.w	r8,0
8000a098:	c0 b1       	brne	8000a0ae <__swsetup_r+0xaa>
8000a09a:	8e 68       	ld.sh	r8,r7[0xc]
8000a09c:	e2 18 02 80 	andl	r8,0x280,COH
8000a0a0:	e0 48 02 00 	cp.w	r8,512
8000a0a4:	c0 50       	breq	8000a0ae <__swsetup_r+0xaa>
8000a0a6:	0c 9c       	mov	r12,r6
8000a0a8:	0e 9b       	mov	r11,r7
8000a0aa:	e0 a0 0a 4b 	rcall	8000b540 <__smakebuf_r>
8000a0ae:	8e 69       	ld.sh	r9,r7[0xc]
8000a0b0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a0b4:	c0 70       	breq	8000a0c2 <__swsetup_r+0xbe>
8000a0b6:	30 08       	mov	r8,0
8000a0b8:	8f 28       	st.w	r7[0x8],r8
8000a0ba:	6e 58       	ld.w	r8,r7[0x14]
8000a0bc:	5c 38       	neg	r8
8000a0be:	8f 68       	st.w	r7[0x18],r8
8000a0c0:	c0 68       	rjmp	8000a0cc <__swsetup_r+0xc8>
8000a0c2:	ed b9 00 01 	bld	r9,0x1
8000a0c6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a0ca:	8f 28       	st.w	r7[0x8],r8
8000a0cc:	6e 48       	ld.w	r8,r7[0x10]
8000a0ce:	58 08       	cp.w	r8,0
8000a0d0:	c0 61       	brne	8000a0dc <__swsetup_r+0xd8>
8000a0d2:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d4:	ed b8 00 07 	bld	r8,0x7
8000a0d8:	c0 21       	brne	8000a0dc <__swsetup_r+0xd8>
8000a0da:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a0dc:	d8 2a       	popm	r4-r7,pc,r12=0
8000a0de:	d7 03       	nop

8000a0e0 <quorem>:
8000a0e0:	d4 31       	pushm	r0-r7,lr
8000a0e2:	20 2d       	sub	sp,8
8000a0e4:	18 97       	mov	r7,r12
8000a0e6:	78 48       	ld.w	r8,r12[0x10]
8000a0e8:	76 46       	ld.w	r6,r11[0x10]
8000a0ea:	0c 38       	cp.w	r8,r6
8000a0ec:	c0 34       	brge	8000a0f2 <quorem+0x12>
8000a0ee:	30 0c       	mov	r12,0
8000a0f0:	c8 58       	rjmp	8000a1fa <quorem+0x11a>
8000a0f2:	ec c2 ff fc 	sub	r2,r6,-4
8000a0f6:	f6 c3 ff ec 	sub	r3,r11,-20
8000a0fa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a0fe:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a102:	2f f9       	sub	r9,-1
8000a104:	20 16       	sub	r6,1
8000a106:	f8 09 0d 08 	divu	r8,r12,r9
8000a10a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a10e:	ee c4 ff ec 	sub	r4,r7,-20
8000a112:	10 95       	mov	r5,r8
8000a114:	58 08       	cp.w	r8,0
8000a116:	c4 10       	breq	8000a198 <quorem+0xb8>
8000a118:	30 09       	mov	r9,0
8000a11a:	06 9a       	mov	r10,r3
8000a11c:	08 98       	mov	r8,r4
8000a11e:	12 91       	mov	r1,r9
8000a120:	50 0b       	stdsp	sp[0x0],r11
8000a122:	70 0e       	ld.w	lr,r8[0x0]
8000a124:	b1 8e       	lsr	lr,0x10
8000a126:	50 1e       	stdsp	sp[0x4],lr
8000a128:	15 0e       	ld.w	lr,r10++
8000a12a:	fc 00 16 10 	lsr	r0,lr,0x10
8000a12e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a132:	ea 0e 03 41 	mac	r1,r5,lr
8000a136:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a13a:	b1 81       	lsr	r1,0x10
8000a13c:	40 1b       	lddsp	r11,sp[0x4]
8000a13e:	ea 00 02 40 	mul	r0,r5,r0
8000a142:	e2 00 00 00 	add	r0,r1,r0
8000a146:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a14a:	02 1b       	sub	r11,r1
8000a14c:	50 1b       	stdsp	sp[0x4],r11
8000a14e:	70 0b       	ld.w	r11,r8[0x0]
8000a150:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a154:	02 09       	add	r9,r1
8000a156:	f2 0e 01 0e 	sub	lr,r9,lr
8000a15a:	b0 1e       	st.h	r8[0x2],lr
8000a15c:	fc 09 14 10 	asr	r9,lr,0x10
8000a160:	40 1e       	lddsp	lr,sp[0x4]
8000a162:	fc 09 00 09 	add	r9,lr,r9
8000a166:	b0 09       	st.h	r8[0x0],r9
8000a168:	e0 01 16 10 	lsr	r1,r0,0x10
8000a16c:	2f c8       	sub	r8,-4
8000a16e:	b1 49       	asr	r9,0x10
8000a170:	04 3a       	cp.w	r10,r2
8000a172:	fe 98 ff d8 	brls	8000a122 <quorem+0x42>
8000a176:	40 0b       	lddsp	r11,sp[0x0]
8000a178:	58 0c       	cp.w	r12,0
8000a17a:	c0 f1       	brne	8000a198 <quorem+0xb8>
8000a17c:	ec c8 ff fb 	sub	r8,r6,-5
8000a180:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a184:	c0 28       	rjmp	8000a188 <quorem+0xa8>
8000a186:	20 16       	sub	r6,1
8000a188:	20 48       	sub	r8,4
8000a18a:	08 38       	cp.w	r8,r4
8000a18c:	e0 88 00 05 	brls	8000a196 <quorem+0xb6>
8000a190:	70 09       	ld.w	r9,r8[0x0]
8000a192:	58 09       	cp.w	r9,0
8000a194:	cf 90       	breq	8000a186 <quorem+0xa6>
8000a196:	8f 46       	st.w	r7[0x10],r6
8000a198:	0e 9c       	mov	r12,r7
8000a19a:	e0 a0 0a d2 	rcall	8000b73e <__mcmp>
8000a19e:	c2 d5       	brlt	8000a1f8 <quorem+0x118>
8000a1a0:	2f f5       	sub	r5,-1
8000a1a2:	08 98       	mov	r8,r4
8000a1a4:	30 09       	mov	r9,0
8000a1a6:	07 0b       	ld.w	r11,r3++
8000a1a8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a1ac:	70 0c       	ld.w	r12,r8[0x0]
8000a1ae:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a1b2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a1b6:	14 1e       	sub	lr,r10
8000a1b8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1bc:	16 1a       	sub	r10,r11
8000a1be:	12 0a       	add	r10,r9
8000a1c0:	b0 1a       	st.h	r8[0x2],r10
8000a1c2:	b1 4a       	asr	r10,0x10
8000a1c4:	fc 0a 00 09 	add	r9,lr,r10
8000a1c8:	b0 09       	st.h	r8[0x0],r9
8000a1ca:	2f c8       	sub	r8,-4
8000a1cc:	b1 49       	asr	r9,0x10
8000a1ce:	04 33       	cp.w	r3,r2
8000a1d0:	fe 98 ff eb 	brls	8000a1a6 <quorem+0xc6>
8000a1d4:	ec c8 ff fb 	sub	r8,r6,-5
8000a1d8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a1dc:	58 09       	cp.w	r9,0
8000a1de:	c0 d1       	brne	8000a1f8 <quorem+0x118>
8000a1e0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1e4:	c0 28       	rjmp	8000a1e8 <quorem+0x108>
8000a1e6:	20 16       	sub	r6,1
8000a1e8:	20 48       	sub	r8,4
8000a1ea:	08 38       	cp.w	r8,r4
8000a1ec:	e0 88 00 05 	brls	8000a1f6 <quorem+0x116>
8000a1f0:	70 09       	ld.w	r9,r8[0x0]
8000a1f2:	58 09       	cp.w	r9,0
8000a1f4:	cf 90       	breq	8000a1e6 <quorem+0x106>
8000a1f6:	8f 46       	st.w	r7[0x10],r6
8000a1f8:	0a 9c       	mov	r12,r5
8000a1fa:	2f ed       	sub	sp,-8
8000a1fc:	d8 32       	popm	r0-r7,pc
8000a1fe:	d7 03       	nop

8000a200 <_dtoa_r>:
8000a200:	d4 31       	pushm	r0-r7,lr
8000a202:	21 ad       	sub	sp,104
8000a204:	fa c4 ff 74 	sub	r4,sp,-140
8000a208:	18 97       	mov	r7,r12
8000a20a:	16 95       	mov	r5,r11
8000a20c:	68 2c       	ld.w	r12,r4[0x8]
8000a20e:	50 c9       	stdsp	sp[0x30],r9
8000a210:	68 16       	ld.w	r6,r4[0x4]
8000a212:	68 09       	ld.w	r9,r4[0x0]
8000a214:	50 e8       	stdsp	sp[0x38],r8
8000a216:	14 94       	mov	r4,r10
8000a218:	51 2c       	stdsp	sp[0x48],r12
8000a21a:	fa e5 00 08 	st.d	sp[8],r4
8000a21e:	51 59       	stdsp	sp[0x54],r9
8000a220:	6e 95       	ld.w	r5,r7[0x24]
8000a222:	58 05       	cp.w	r5,0
8000a224:	c0 91       	brne	8000a236 <_dtoa_r+0x36>
8000a226:	31 0c       	mov	r12,16
8000a228:	fe b0 e8 f4 	rcall	80007410 <malloc>
8000a22c:	99 35       	st.w	r12[0xc],r5
8000a22e:	8f 9c       	st.w	r7[0x24],r12
8000a230:	99 15       	st.w	r12[0x4],r5
8000a232:	99 25       	st.w	r12[0x8],r5
8000a234:	99 05       	st.w	r12[0x0],r5
8000a236:	6e 99       	ld.w	r9,r7[0x24]
8000a238:	72 08       	ld.w	r8,r9[0x0]
8000a23a:	58 08       	cp.w	r8,0
8000a23c:	c0 f0       	breq	8000a25a <_dtoa_r+0x5a>
8000a23e:	72 1a       	ld.w	r10,r9[0x4]
8000a240:	91 1a       	st.w	r8[0x4],r10
8000a242:	30 1a       	mov	r10,1
8000a244:	72 19       	ld.w	r9,r9[0x4]
8000a246:	f4 09 09 49 	lsl	r9,r10,r9
8000a24a:	10 9b       	mov	r11,r8
8000a24c:	91 29       	st.w	r8[0x8],r9
8000a24e:	0e 9c       	mov	r12,r7
8000a250:	e0 a0 0a 90 	rcall	8000b770 <_Bfree>
8000a254:	6e 98       	ld.w	r8,r7[0x24]
8000a256:	30 09       	mov	r9,0
8000a258:	91 09       	st.w	r8[0x0],r9
8000a25a:	40 28       	lddsp	r8,sp[0x8]
8000a25c:	10 94       	mov	r4,r8
8000a25e:	58 08       	cp.w	r8,0
8000a260:	c0 64       	brge	8000a26c <_dtoa_r+0x6c>
8000a262:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a266:	50 28       	stdsp	sp[0x8],r8
8000a268:	30 18       	mov	r8,1
8000a26a:	c0 28       	rjmp	8000a26e <_dtoa_r+0x6e>
8000a26c:	30 08       	mov	r8,0
8000a26e:	8d 08       	st.w	r6[0x0],r8
8000a270:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a274:	40 26       	lddsp	r6,sp[0x8]
8000a276:	0c 98       	mov	r8,r6
8000a278:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a27c:	18 38       	cp.w	r8,r12
8000a27e:	c2 01       	brne	8000a2be <_dtoa_r+0xbe>
8000a280:	e0 68 27 0f 	mov	r8,9999
8000a284:	41 5b       	lddsp	r11,sp[0x54]
8000a286:	97 08       	st.w	r11[0x0],r8
8000a288:	40 3a       	lddsp	r10,sp[0xc]
8000a28a:	58 0a       	cp.w	r10,0
8000a28c:	c0 71       	brne	8000a29a <_dtoa_r+0x9a>
8000a28e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a292:	c0 41       	brne	8000a29a <_dtoa_r+0x9a>
8000a294:	fe cc c1 c8 	sub	r12,pc,-15928
8000a298:	c0 38       	rjmp	8000a29e <_dtoa_r+0x9e>
8000a29a:	fe cc c1 c2 	sub	r12,pc,-15934
8000a29e:	41 29       	lddsp	r9,sp[0x48]
8000a2a0:	58 09       	cp.w	r9,0
8000a2a2:	e0 80 05 9a 	breq	8000add6 <_dtoa_r+0xbd6>
8000a2a6:	f8 c8 ff fd 	sub	r8,r12,-3
8000a2aa:	f8 c9 ff f8 	sub	r9,r12,-8
8000a2ae:	11 8b       	ld.ub	r11,r8[0x0]
8000a2b0:	30 0a       	mov	r10,0
8000a2b2:	41 25       	lddsp	r5,sp[0x48]
8000a2b4:	f4 0b 18 00 	cp.b	r11,r10
8000a2b8:	f2 08 17 10 	movne	r8,r9
8000a2bc:	c1 68       	rjmp	8000a2e8 <_dtoa_r+0xe8>
8000a2be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2c2:	30 08       	mov	r8,0
8000a2c4:	fa eb 00 3c 	st.d	sp[60],r10
8000a2c8:	30 09       	mov	r9,0
8000a2ca:	e0 a0 10 ce 	rcall	8000c466 <__avr32_f64_cmp_eq>
8000a2ce:	c1 00       	breq	8000a2ee <_dtoa_r+0xee>
8000a2d0:	30 18       	mov	r8,1
8000a2d2:	41 5a       	lddsp	r10,sp[0x54]
8000a2d4:	95 08       	st.w	r10[0x0],r8
8000a2d6:	fe cc c3 2e 	sub	r12,pc,-15570
8000a2da:	41 29       	lddsp	r9,sp[0x48]
8000a2dc:	f8 08 00 08 	add	r8,r12,r8
8000a2e0:	58 09       	cp.w	r9,0
8000a2e2:	e0 80 05 7a 	breq	8000add6 <_dtoa_r+0xbd6>
8000a2e6:	12 95       	mov	r5,r9
8000a2e8:	8b 08       	st.w	r5[0x0],r8
8000a2ea:	e0 8f 05 76 	bral	8000add6 <_dtoa_r+0xbd6>
8000a2ee:	fa c8 ff 9c 	sub	r8,sp,-100
8000a2f2:	fa c9 ff a0 	sub	r9,sp,-96
8000a2f6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2fa:	0e 9c       	mov	r12,r7
8000a2fc:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a300:	e0 a0 0a 8a 	rcall	8000b814 <__d2b>
8000a304:	18 93       	mov	r3,r12
8000a306:	58 05       	cp.w	r5,0
8000a308:	c0 d0       	breq	8000a322 <_dtoa_r+0x122>
8000a30a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a30e:	30 04       	mov	r4,0
8000a310:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a314:	ea c5 03 ff 	sub	r5,r5,1023
8000a318:	10 9b       	mov	r11,r8
8000a31a:	51 74       	stdsp	sp[0x5c],r4
8000a31c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a320:	c2 58       	rjmp	8000a36a <_dtoa_r+0x16a>
8000a322:	41 88       	lddsp	r8,sp[0x60]
8000a324:	41 9c       	lddsp	r12,sp[0x64]
8000a326:	10 0c       	add	r12,r8
8000a328:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a32c:	e0 45 00 20 	cp.w	r5,32
8000a330:	e0 8a 00 0e 	brle	8000a34c <_dtoa_r+0x14c>
8000a334:	f8 cc fb ee 	sub	r12,r12,-1042
8000a338:	40 3b       	lddsp	r11,sp[0xc]
8000a33a:	ea 08 11 40 	rsub	r8,r5,64
8000a33e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a342:	ec 08 09 46 	lsl	r6,r6,r8
8000a346:	0c 4c       	or	r12,r6
8000a348:	c0 78       	rjmp	8000a356 <_dtoa_r+0x156>
8000a34a:	d7 03       	nop
8000a34c:	ea 0c 11 20 	rsub	r12,r5,32
8000a350:	40 3a       	lddsp	r10,sp[0xc]
8000a352:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a356:	e0 a0 10 14 	rcall	8000c37e <__avr32_u32_to_f64>
8000a35a:	fc 18 fe 10 	movh	r8,0xfe10
8000a35e:	30 19       	mov	r9,1
8000a360:	ea c5 04 33 	sub	r5,r5,1075
8000a364:	f0 0b 00 0b 	add	r11,r8,r11
8000a368:	51 79       	stdsp	sp[0x5c],r9
8000a36a:	30 08       	mov	r8,0
8000a36c:	fc 19 3f f8 	movh	r9,0x3ff8
8000a370:	e0 a0 0e 9c 	rcall	8000c0a8 <__avr32_f64_sub>
8000a374:	e0 68 43 61 	mov	r8,17249
8000a378:	ea 18 63 6f 	orh	r8,0x636f
8000a37c:	e0 69 87 a7 	mov	r9,34727
8000a380:	ea 19 3f d2 	orh	r9,0x3fd2
8000a384:	e0 a0 0d a6 	rcall	8000bed0 <__avr32_f64_mul>
8000a388:	e0 68 c8 b3 	mov	r8,51379
8000a38c:	ea 18 8b 60 	orh	r8,0x8b60
8000a390:	e0 69 8a 28 	mov	r9,35368
8000a394:	ea 19 3f c6 	orh	r9,0x3fc6
8000a398:	e0 a0 0f 56 	rcall	8000c244 <__avr32_f64_add>
8000a39c:	0a 9c       	mov	r12,r5
8000a39e:	14 90       	mov	r0,r10
8000a3a0:	16 91       	mov	r1,r11
8000a3a2:	e0 a0 0f f2 	rcall	8000c386 <__avr32_s32_to_f64>
8000a3a6:	e0 68 79 fb 	mov	r8,31227
8000a3aa:	ea 18 50 9f 	orh	r8,0x509f
8000a3ae:	e0 69 44 13 	mov	r9,17427
8000a3b2:	ea 19 3f d3 	orh	r9,0x3fd3
8000a3b6:	e0 a0 0d 8d 	rcall	8000bed0 <__avr32_f64_mul>
8000a3ba:	14 98       	mov	r8,r10
8000a3bc:	16 99       	mov	r9,r11
8000a3be:	00 9a       	mov	r10,r0
8000a3c0:	02 9b       	mov	r11,r1
8000a3c2:	e0 a0 0f 41 	rcall	8000c244 <__avr32_f64_add>
8000a3c6:	14 90       	mov	r0,r10
8000a3c8:	16 91       	mov	r1,r11
8000a3ca:	e0 a0 0f c7 	rcall	8000c358 <__avr32_f64_to_s32>
8000a3ce:	30 08       	mov	r8,0
8000a3d0:	18 96       	mov	r6,r12
8000a3d2:	30 09       	mov	r9,0
8000a3d4:	00 9a       	mov	r10,r0
8000a3d6:	02 9b       	mov	r11,r1
8000a3d8:	e0 a0 10 8e 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a3dc:	c0 c0       	breq	8000a3f4 <_dtoa_r+0x1f4>
8000a3de:	0c 9c       	mov	r12,r6
8000a3e0:	e0 a0 0f d3 	rcall	8000c386 <__avr32_s32_to_f64>
8000a3e4:	14 98       	mov	r8,r10
8000a3e6:	16 99       	mov	r9,r11
8000a3e8:	00 9a       	mov	r10,r0
8000a3ea:	02 9b       	mov	r11,r1
8000a3ec:	e0 a0 10 3d 	rcall	8000c466 <__avr32_f64_cmp_eq>
8000a3f0:	f7 b6 00 01 	subeq	r6,1
8000a3f4:	59 66       	cp.w	r6,22
8000a3f6:	e0 88 00 05 	brls	8000a400 <_dtoa_r+0x200>
8000a3fa:	30 18       	mov	r8,1
8000a3fc:	51 48       	stdsp	sp[0x50],r8
8000a3fe:	c1 38       	rjmp	8000a424 <_dtoa_r+0x224>
8000a400:	fe c8 c2 74 	sub	r8,pc,-15756
8000a404:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a408:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a40c:	e0 a0 10 74 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a410:	f9 b4 00 00 	moveq	r4,0
8000a414:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a418:	f7 b6 01 01 	subne	r6,1
8000a41c:	f9 bc 01 00 	movne	r12,0
8000a420:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a424:	41 90       	lddsp	r0,sp[0x64]
8000a426:	20 10       	sub	r0,1
8000a428:	0a 10       	sub	r0,r5
8000a42a:	c0 46       	brmi	8000a432 <_dtoa_r+0x232>
8000a42c:	50 40       	stdsp	sp[0x10],r0
8000a42e:	30 00       	mov	r0,0
8000a430:	c0 48       	rjmp	8000a438 <_dtoa_r+0x238>
8000a432:	30 0b       	mov	r11,0
8000a434:	5c 30       	neg	r0
8000a436:	50 4b       	stdsp	sp[0x10],r11
8000a438:	ec 02 11 00 	rsub	r2,r6,0
8000a43c:	58 06       	cp.w	r6,0
8000a43e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a442:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a446:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a44a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a44e:	f9 b2 04 00 	movge	r2,0
8000a452:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a456:	f9 b9 05 00 	movlt	r9,0
8000a45a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a45e:	40 c8       	lddsp	r8,sp[0x30]
8000a460:	58 98       	cp.w	r8,9
8000a462:	e0 8b 00 20 	brhi	8000a4a2 <_dtoa_r+0x2a2>
8000a466:	58 58       	cp.w	r8,5
8000a468:	f9 b4 0a 01 	movle	r4,1
8000a46c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a470:	f7 b5 09 04 	subgt	r5,4
8000a474:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a478:	f9 b4 09 00 	movgt	r4,0
8000a47c:	40 cc       	lddsp	r12,sp[0x30]
8000a47e:	58 3c       	cp.w	r12,3
8000a480:	c2 d0       	breq	8000a4da <_dtoa_r+0x2da>
8000a482:	e0 89 00 05 	brgt	8000a48c <_dtoa_r+0x28c>
8000a486:	58 2c       	cp.w	r12,2
8000a488:	c1 01       	brne	8000a4a8 <_dtoa_r+0x2a8>
8000a48a:	c1 88       	rjmp	8000a4ba <_dtoa_r+0x2ba>
8000a48c:	40 cb       	lddsp	r11,sp[0x30]
8000a48e:	58 4b       	cp.w	r11,4
8000a490:	c0 60       	breq	8000a49c <_dtoa_r+0x29c>
8000a492:	58 5b       	cp.w	r11,5
8000a494:	c0 a1       	brne	8000a4a8 <_dtoa_r+0x2a8>
8000a496:	30 1a       	mov	r10,1
8000a498:	50 da       	stdsp	sp[0x34],r10
8000a49a:	c2 28       	rjmp	8000a4de <_dtoa_r+0x2de>
8000a49c:	30 19       	mov	r9,1
8000a49e:	50 d9       	stdsp	sp[0x34],r9
8000a4a0:	c0 f8       	rjmp	8000a4be <_dtoa_r+0x2be>
8000a4a2:	30 08       	mov	r8,0
8000a4a4:	30 14       	mov	r4,1
8000a4a6:	50 c8       	stdsp	sp[0x30],r8
8000a4a8:	3f f5       	mov	r5,-1
8000a4aa:	30 1c       	mov	r12,1
8000a4ac:	30 0b       	mov	r11,0
8000a4ae:	50 95       	stdsp	sp[0x24],r5
8000a4b0:	50 dc       	stdsp	sp[0x34],r12
8000a4b2:	0a 91       	mov	r1,r5
8000a4b4:	31 28       	mov	r8,18
8000a4b6:	50 eb       	stdsp	sp[0x38],r11
8000a4b8:	c2 08       	rjmp	8000a4f8 <_dtoa_r+0x2f8>
8000a4ba:	30 0a       	mov	r10,0
8000a4bc:	50 da       	stdsp	sp[0x34],r10
8000a4be:	40 e9       	lddsp	r9,sp[0x38]
8000a4c0:	58 09       	cp.w	r9,0
8000a4c2:	e0 89 00 07 	brgt	8000a4d0 <_dtoa_r+0x2d0>
8000a4c6:	30 18       	mov	r8,1
8000a4c8:	50 98       	stdsp	sp[0x24],r8
8000a4ca:	10 91       	mov	r1,r8
8000a4cc:	50 e8       	stdsp	sp[0x38],r8
8000a4ce:	c1 58       	rjmp	8000a4f8 <_dtoa_r+0x2f8>
8000a4d0:	40 e5       	lddsp	r5,sp[0x38]
8000a4d2:	50 95       	stdsp	sp[0x24],r5
8000a4d4:	0a 91       	mov	r1,r5
8000a4d6:	0a 98       	mov	r8,r5
8000a4d8:	c1 08       	rjmp	8000a4f8 <_dtoa_r+0x2f8>
8000a4da:	30 0c       	mov	r12,0
8000a4dc:	50 dc       	stdsp	sp[0x34],r12
8000a4de:	40 eb       	lddsp	r11,sp[0x38]
8000a4e0:	ec 0b 00 0b 	add	r11,r6,r11
8000a4e4:	50 9b       	stdsp	sp[0x24],r11
8000a4e6:	16 98       	mov	r8,r11
8000a4e8:	2f f8       	sub	r8,-1
8000a4ea:	58 08       	cp.w	r8,0
8000a4ec:	e0 89 00 05 	brgt	8000a4f6 <_dtoa_r+0x2f6>
8000a4f0:	10 91       	mov	r1,r8
8000a4f2:	30 18       	mov	r8,1
8000a4f4:	c0 28       	rjmp	8000a4f8 <_dtoa_r+0x2f8>
8000a4f6:	10 91       	mov	r1,r8
8000a4f8:	30 09       	mov	r9,0
8000a4fa:	6e 9a       	ld.w	r10,r7[0x24]
8000a4fc:	95 19       	st.w	r10[0x4],r9
8000a4fe:	30 49       	mov	r9,4
8000a500:	c0 68       	rjmp	8000a50c <_dtoa_r+0x30c>
8000a502:	d7 03       	nop
8000a504:	6a 1a       	ld.w	r10,r5[0x4]
8000a506:	a1 79       	lsl	r9,0x1
8000a508:	2f fa       	sub	r10,-1
8000a50a:	8b 1a       	st.w	r5[0x4],r10
8000a50c:	6e 95       	ld.w	r5,r7[0x24]
8000a50e:	f2 ca ff ec 	sub	r10,r9,-20
8000a512:	10 3a       	cp.w	r10,r8
8000a514:	fe 98 ff f8 	brls	8000a504 <_dtoa_r+0x304>
8000a518:	6a 1b       	ld.w	r11,r5[0x4]
8000a51a:	0e 9c       	mov	r12,r7
8000a51c:	e0 a0 09 44 	rcall	8000b7a4 <_Balloc>
8000a520:	58 e1       	cp.w	r1,14
8000a522:	5f 88       	srls	r8
8000a524:	8b 0c       	st.w	r5[0x0],r12
8000a526:	f1 e4 00 04 	and	r4,r8,r4
8000a52a:	6e 98       	ld.w	r8,r7[0x24]
8000a52c:	70 08       	ld.w	r8,r8[0x0]
8000a52e:	50 88       	stdsp	sp[0x20],r8
8000a530:	e0 80 01 82 	breq	8000a834 <_dtoa_r+0x634>
8000a534:	58 06       	cp.w	r6,0
8000a536:	e0 8a 00 43 	brle	8000a5bc <_dtoa_r+0x3bc>
8000a53a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a53e:	fe c8 c3 b2 	sub	r8,pc,-15438
8000a542:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a546:	fa e5 00 18 	st.d	sp[24],r4
8000a54a:	ec 04 14 04 	asr	r4,r6,0x4
8000a54e:	ed b4 00 04 	bld	r4,0x4
8000a552:	c0 30       	breq	8000a558 <_dtoa_r+0x358>
8000a554:	30 25       	mov	r5,2
8000a556:	c1 08       	rjmp	8000a576 <_dtoa_r+0x376>
8000a558:	fe c8 c3 04 	sub	r8,pc,-15612
8000a55c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a560:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a564:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a568:	e0 a0 0f fa 	rcall	8000c55c <__avr32_f64_div>
8000a56c:	30 35       	mov	r5,3
8000a56e:	14 98       	mov	r8,r10
8000a570:	16 99       	mov	r9,r11
8000a572:	fa e9 00 08 	st.d	sp[8],r8
8000a576:	fe cc c3 22 	sub	r12,pc,-15582
8000a57a:	50 a3       	stdsp	sp[0x28],r3
8000a57c:	0c 93       	mov	r3,r6
8000a57e:	18 96       	mov	r6,r12
8000a580:	c0 f8       	rjmp	8000a59e <_dtoa_r+0x39e>
8000a582:	fa ea 00 18 	ld.d	r10,sp[24]
8000a586:	ed b4 00 00 	bld	r4,0x0
8000a58a:	c0 81       	brne	8000a59a <_dtoa_r+0x39a>
8000a58c:	ec e8 00 00 	ld.d	r8,r6[0]
8000a590:	2f f5       	sub	r5,-1
8000a592:	e0 a0 0c 9f 	rcall	8000bed0 <__avr32_f64_mul>
8000a596:	fa eb 00 18 	st.d	sp[24],r10
8000a59a:	a1 54       	asr	r4,0x1
8000a59c:	2f 86       	sub	r6,-8
8000a59e:	58 04       	cp.w	r4,0
8000a5a0:	cf 11       	brne	8000a582 <_dtoa_r+0x382>
8000a5a2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a5a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5aa:	06 96       	mov	r6,r3
8000a5ac:	e0 a0 0f d8 	rcall	8000c55c <__avr32_f64_div>
8000a5b0:	40 a3       	lddsp	r3,sp[0x28]
8000a5b2:	14 98       	mov	r8,r10
8000a5b4:	16 99       	mov	r9,r11
8000a5b6:	fa e9 00 08 	st.d	sp[8],r8
8000a5ba:	c2 f8       	rjmp	8000a618 <_dtoa_r+0x418>
8000a5bc:	ec 08 11 00 	rsub	r8,r6,0
8000a5c0:	c0 31       	brne	8000a5c6 <_dtoa_r+0x3c6>
8000a5c2:	30 25       	mov	r5,2
8000a5c4:	c2 a8       	rjmp	8000a618 <_dtoa_r+0x418>
8000a5c6:	fe cc c3 72 	sub	r12,pc,-15502
8000a5ca:	f0 04 14 04 	asr	r4,r8,0x4
8000a5ce:	50 1c       	stdsp	sp[0x4],r12
8000a5d0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a5d4:	fe c9 c4 48 	sub	r9,pc,-15288
8000a5d8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5dc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5e0:	e0 a0 0c 78 	rcall	8000bed0 <__avr32_f64_mul>
8000a5e4:	40 1c       	lddsp	r12,sp[0x4]
8000a5e6:	50 63       	stdsp	sp[0x18],r3
8000a5e8:	30 25       	mov	r5,2
8000a5ea:	0c 93       	mov	r3,r6
8000a5ec:	fa eb 00 08 	st.d	sp[8],r10
8000a5f0:	18 96       	mov	r6,r12
8000a5f2:	c0 f8       	rjmp	8000a610 <_dtoa_r+0x410>
8000a5f4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5f8:	ed b4 00 00 	bld	r4,0x0
8000a5fc:	c0 81       	brne	8000a60c <_dtoa_r+0x40c>
8000a5fe:	ec e8 00 00 	ld.d	r8,r6[0]
8000a602:	2f f5       	sub	r5,-1
8000a604:	e0 a0 0c 66 	rcall	8000bed0 <__avr32_f64_mul>
8000a608:	fa eb 00 08 	st.d	sp[8],r10
8000a60c:	a1 54       	asr	r4,0x1
8000a60e:	2f 86       	sub	r6,-8
8000a610:	58 04       	cp.w	r4,0
8000a612:	cf 11       	brne	8000a5f4 <_dtoa_r+0x3f4>
8000a614:	06 96       	mov	r6,r3
8000a616:	40 63       	lddsp	r3,sp[0x18]
8000a618:	41 4a       	lddsp	r10,sp[0x50]
8000a61a:	58 0a       	cp.w	r10,0
8000a61c:	c2 a0       	breq	8000a670 <_dtoa_r+0x470>
8000a61e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a622:	58 01       	cp.w	r1,0
8000a624:	5f 94       	srgt	r4
8000a626:	fa e9 00 18 	st.d	sp[24],r8
8000a62a:	30 08       	mov	r8,0
8000a62c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a630:	fa ea 00 18 	ld.d	r10,sp[24]
8000a634:	e0 a0 0f 60 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a638:	f9 bc 00 00 	moveq	r12,0
8000a63c:	f9 bc 01 01 	movne	r12,1
8000a640:	e9 ec 00 0c 	and	r12,r4,r12
8000a644:	c1 60       	breq	8000a670 <_dtoa_r+0x470>
8000a646:	40 98       	lddsp	r8,sp[0x24]
8000a648:	58 08       	cp.w	r8,0
8000a64a:	e0 8a 00 f1 	brle	8000a82c <_dtoa_r+0x62c>
8000a64e:	30 08       	mov	r8,0
8000a650:	fc 19 40 24 	movh	r9,0x4024
8000a654:	ec c4 00 01 	sub	r4,r6,1
8000a658:	fa ea 00 18 	ld.d	r10,sp[24]
8000a65c:	2f f5       	sub	r5,-1
8000a65e:	50 64       	stdsp	sp[0x18],r4
8000a660:	e0 a0 0c 38 	rcall	8000bed0 <__avr32_f64_mul>
8000a664:	40 94       	lddsp	r4,sp[0x24]
8000a666:	14 98       	mov	r8,r10
8000a668:	16 99       	mov	r9,r11
8000a66a:	fa e9 00 08 	st.d	sp[8],r8
8000a66e:	c0 38       	rjmp	8000a674 <_dtoa_r+0x474>
8000a670:	50 66       	stdsp	sp[0x18],r6
8000a672:	02 94       	mov	r4,r1
8000a674:	0a 9c       	mov	r12,r5
8000a676:	e0 a0 0e 88 	rcall	8000c386 <__avr32_s32_to_f64>
8000a67a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a67e:	e0 a0 0c 29 	rcall	8000bed0 <__avr32_f64_mul>
8000a682:	30 08       	mov	r8,0
8000a684:	fc 19 40 1c 	movh	r9,0x401c
8000a688:	e0 a0 0d de 	rcall	8000c244 <__avr32_f64_add>
8000a68c:	14 98       	mov	r8,r10
8000a68e:	16 99       	mov	r9,r11
8000a690:	fa e9 00 28 	st.d	sp[40],r8
8000a694:	fc 18 fc c0 	movh	r8,0xfcc0
8000a698:	40 a5       	lddsp	r5,sp[0x28]
8000a69a:	10 05       	add	r5,r8
8000a69c:	50 a5       	stdsp	sp[0x28],r5
8000a69e:	58 04       	cp.w	r4,0
8000a6a0:	c2 11       	brne	8000a6e2 <_dtoa_r+0x4e2>
8000a6a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6a6:	30 08       	mov	r8,0
8000a6a8:	fc 19 40 14 	movh	r9,0x4014
8000a6ac:	e0 a0 0c fe 	rcall	8000c0a8 <__avr32_f64_sub>
8000a6b0:	40 bc       	lddsp	r12,sp[0x2c]
8000a6b2:	fa eb 00 08 	st.d	sp[8],r10
8000a6b6:	14 98       	mov	r8,r10
8000a6b8:	16 99       	mov	r9,r11
8000a6ba:	18 9a       	mov	r10,r12
8000a6bc:	0a 9b       	mov	r11,r5
8000a6be:	e0 a0 0f 1b 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a6c2:	e0 81 02 54 	brne	8000ab6a <_dtoa_r+0x96a>
8000a6c6:	0a 98       	mov	r8,r5
8000a6c8:	40 b9       	lddsp	r9,sp[0x2c]
8000a6ca:	ee 18 80 00 	eorh	r8,0x8000
8000a6ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6d2:	10 95       	mov	r5,r8
8000a6d4:	12 98       	mov	r8,r9
8000a6d6:	0a 99       	mov	r9,r5
8000a6d8:	e0 a0 0f 0e 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a6dc:	e0 81 02 3e 	brne	8000ab58 <_dtoa_r+0x958>
8000a6e0:	ca 68       	rjmp	8000a82c <_dtoa_r+0x62c>
8000a6e2:	fe c9 c5 56 	sub	r9,pc,-15018
8000a6e6:	e8 c8 00 01 	sub	r8,r4,1
8000a6ea:	40 d5       	lddsp	r5,sp[0x34]
8000a6ec:	58 05       	cp.w	r5,0
8000a6ee:	c4 f0       	breq	8000a78c <_dtoa_r+0x58c>
8000a6f0:	30 0c       	mov	r12,0
8000a6f2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a6f6:	51 3c       	stdsp	sp[0x4c],r12
8000a6f8:	30 0a       	mov	r10,0
8000a6fa:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a6fe:	e0 a0 0f 2f 	rcall	8000c55c <__avr32_f64_div>
8000a702:	fa e8 00 28 	ld.d	r8,sp[40]
8000a706:	40 85       	lddsp	r5,sp[0x20]
8000a708:	e0 a0 0c d0 	rcall	8000c0a8 <__avr32_f64_sub>
8000a70c:	fa eb 00 28 	st.d	sp[40],r10
8000a710:	fa ea 00 08 	ld.d	r10,sp[8]
8000a714:	e0 a0 0e 22 	rcall	8000c358 <__avr32_f64_to_s32>
8000a718:	51 6c       	stdsp	sp[0x58],r12
8000a71a:	e0 a0 0e 36 	rcall	8000c386 <__avr32_s32_to_f64>
8000a71e:	14 98       	mov	r8,r10
8000a720:	16 99       	mov	r9,r11
8000a722:	fa ea 00 08 	ld.d	r10,sp[8]
8000a726:	e0 a0 0c c1 	rcall	8000c0a8 <__avr32_f64_sub>
8000a72a:	fa eb 00 08 	st.d	sp[8],r10
8000a72e:	41 68       	lddsp	r8,sp[0x58]
8000a730:	2d 08       	sub	r8,-48
8000a732:	0a c8       	st.b	r5++,r8
8000a734:	41 39       	lddsp	r9,sp[0x4c]
8000a736:	2f f9       	sub	r9,-1
8000a738:	51 39       	stdsp	sp[0x4c],r9
8000a73a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a73e:	e0 a0 0e db 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a742:	e0 81 03 39 	brne	8000adb4 <_dtoa_r+0xbb4>
8000a746:	fa e8 00 08 	ld.d	r8,sp[8]
8000a74a:	30 0a       	mov	r10,0
8000a74c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a750:	e0 a0 0c ac 	rcall	8000c0a8 <__avr32_f64_sub>
8000a754:	fa e8 00 28 	ld.d	r8,sp[40]
8000a758:	e0 a0 0e ce 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a75c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a760:	30 08       	mov	r8,0
8000a762:	fc 19 40 24 	movh	r9,0x4024
8000a766:	e0 81 00 da 	brne	8000a91a <_dtoa_r+0x71a>
8000a76a:	41 3c       	lddsp	r12,sp[0x4c]
8000a76c:	08 3c       	cp.w	r12,r4
8000a76e:	c5 f4       	brge	8000a82c <_dtoa_r+0x62c>
8000a770:	e0 a0 0b b0 	rcall	8000bed0 <__avr32_f64_mul>
8000a774:	30 08       	mov	r8,0
8000a776:	fa eb 00 28 	st.d	sp[40],r10
8000a77a:	fc 19 40 24 	movh	r9,0x4024
8000a77e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a782:	e0 a0 0b a7 	rcall	8000bed0 <__avr32_f64_mul>
8000a786:	fa eb 00 08 	st.d	sp[8],r10
8000a78a:	cc 3b       	rjmp	8000a710 <_dtoa_r+0x510>
8000a78c:	40 85       	lddsp	r5,sp[0x20]
8000a78e:	08 05       	add	r5,r4
8000a790:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a794:	51 35       	stdsp	sp[0x4c],r5
8000a796:	fa e8 00 28 	ld.d	r8,sp[40]
8000a79a:	40 85       	lddsp	r5,sp[0x20]
8000a79c:	e0 a0 0b 9a 	rcall	8000bed0 <__avr32_f64_mul>
8000a7a0:	fa eb 00 28 	st.d	sp[40],r10
8000a7a4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7a8:	e0 a0 0d d8 	rcall	8000c358 <__avr32_f64_to_s32>
8000a7ac:	51 6c       	stdsp	sp[0x58],r12
8000a7ae:	e0 a0 0d ec 	rcall	8000c386 <__avr32_s32_to_f64>
8000a7b2:	14 98       	mov	r8,r10
8000a7b4:	16 99       	mov	r9,r11
8000a7b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ba:	e0 a0 0c 77 	rcall	8000c0a8 <__avr32_f64_sub>
8000a7be:	fa eb 00 08 	st.d	sp[8],r10
8000a7c2:	41 68       	lddsp	r8,sp[0x58]
8000a7c4:	2d 08       	sub	r8,-48
8000a7c6:	0a c8       	st.b	r5++,r8
8000a7c8:	41 3c       	lddsp	r12,sp[0x4c]
8000a7ca:	18 35       	cp.w	r5,r12
8000a7cc:	c2 81       	brne	8000a81c <_dtoa_r+0x61c>
8000a7ce:	30 08       	mov	r8,0
8000a7d0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a7d4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7d8:	e0 a0 0d 36 	rcall	8000c244 <__avr32_f64_add>
8000a7dc:	40 85       	lddsp	r5,sp[0x20]
8000a7de:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7e2:	08 05       	add	r5,r4
8000a7e4:	e0 a0 0e 88 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a7e8:	e0 81 00 99 	brne	8000a91a <_dtoa_r+0x71a>
8000a7ec:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7f0:	30 0a       	mov	r10,0
8000a7f2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a7f6:	e0 a0 0c 59 	rcall	8000c0a8 <__avr32_f64_sub>
8000a7fa:	14 98       	mov	r8,r10
8000a7fc:	16 99       	mov	r9,r11
8000a7fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000a802:	e0 a0 0e 79 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a806:	c1 30       	breq	8000a82c <_dtoa_r+0x62c>
8000a808:	33 09       	mov	r9,48
8000a80a:	0a 98       	mov	r8,r5
8000a80c:	11 7a       	ld.ub	r10,--r8
8000a80e:	f2 0a 18 00 	cp.b	r10,r9
8000a812:	e0 81 02 d1 	brne	8000adb4 <_dtoa_r+0xbb4>
8000a816:	10 95       	mov	r5,r8
8000a818:	cf 9b       	rjmp	8000a80a <_dtoa_r+0x60a>
8000a81a:	d7 03       	nop
8000a81c:	30 08       	mov	r8,0
8000a81e:	fc 19 40 24 	movh	r9,0x4024
8000a822:	e0 a0 0b 57 	rcall	8000bed0 <__avr32_f64_mul>
8000a826:	fa eb 00 08 	st.d	sp[8],r10
8000a82a:	cb db       	rjmp	8000a7a4 <_dtoa_r+0x5a4>
8000a82c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a830:	fa eb 00 08 	st.d	sp[8],r10
8000a834:	58 e6       	cp.w	r6,14
8000a836:	5f ab       	srle	r11
8000a838:	41 8a       	lddsp	r10,sp[0x60]
8000a83a:	30 08       	mov	r8,0
8000a83c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a840:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a844:	f0 09 18 00 	cp.b	r9,r8
8000a848:	e0 80 00 82 	breq	8000a94c <_dtoa_r+0x74c>
8000a84c:	40 ea       	lddsp	r10,sp[0x38]
8000a84e:	58 01       	cp.w	r1,0
8000a850:	5f a9       	srle	r9
8000a852:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a856:	fe ca c6 ca 	sub	r10,pc,-14646
8000a85a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a85e:	fa e5 00 10 	st.d	sp[16],r4
8000a862:	f0 09 18 00 	cp.b	r9,r8
8000a866:	c1 40       	breq	8000a88e <_dtoa_r+0x68e>
8000a868:	58 01       	cp.w	r1,0
8000a86a:	e0 81 01 77 	brne	8000ab58 <_dtoa_r+0x958>
8000a86e:	30 08       	mov	r8,0
8000a870:	fc 19 40 14 	movh	r9,0x4014
8000a874:	08 9a       	mov	r10,r4
8000a876:	0a 9b       	mov	r11,r5
8000a878:	e0 a0 0b 2c 	rcall	8000bed0 <__avr32_f64_mul>
8000a87c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a880:	e0 a0 0e 06 	rcall	8000c48c <__avr32_f64_cmp_ge>
8000a884:	e0 81 01 6a 	brne	8000ab58 <_dtoa_r+0x958>
8000a888:	02 92       	mov	r2,r1
8000a88a:	e0 8f 01 72 	bral	8000ab6e <_dtoa_r+0x96e>
8000a88e:	40 85       	lddsp	r5,sp[0x20]
8000a890:	30 14       	mov	r4,1
8000a892:	fa e8 00 10 	ld.d	r8,sp[16]
8000a896:	fa ea 00 08 	ld.d	r10,sp[8]
8000a89a:	e0 a0 0e 61 	rcall	8000c55c <__avr32_f64_div>
8000a89e:	e0 a0 0d 5d 	rcall	8000c358 <__avr32_f64_to_s32>
8000a8a2:	18 92       	mov	r2,r12
8000a8a4:	e0 a0 0d 71 	rcall	8000c386 <__avr32_s32_to_f64>
8000a8a8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8ac:	e0 a0 0b 12 	rcall	8000bed0 <__avr32_f64_mul>
8000a8b0:	14 98       	mov	r8,r10
8000a8b2:	16 99       	mov	r9,r11
8000a8b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8b8:	e0 a0 0b f8 	rcall	8000c0a8 <__avr32_f64_sub>
8000a8bc:	fa eb 00 08 	st.d	sp[8],r10
8000a8c0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a8c4:	0a c8       	st.b	r5++,r8
8000a8c6:	fc 19 40 24 	movh	r9,0x4024
8000a8ca:	30 08       	mov	r8,0
8000a8cc:	02 34       	cp.w	r4,r1
8000a8ce:	c3 31       	brne	8000a934 <_dtoa_r+0x734>
8000a8d0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8d4:	e0 a0 0c b8 	rcall	8000c244 <__avr32_f64_add>
8000a8d8:	16 91       	mov	r1,r11
8000a8da:	14 90       	mov	r0,r10
8000a8dc:	14 98       	mov	r8,r10
8000a8de:	02 99       	mov	r9,r1
8000a8e0:	fa ea 00 10 	ld.d	r10,sp[16]
8000a8e4:	e0 a0 0e 08 	rcall	8000c4f4 <__avr32_f64_cmp_lt>
8000a8e8:	c1 a1       	brne	8000a91c <_dtoa_r+0x71c>
8000a8ea:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8ee:	00 9a       	mov	r10,r0
8000a8f0:	02 9b       	mov	r11,r1
8000a8f2:	e0 a0 0d ba 	rcall	8000c466 <__avr32_f64_cmp_eq>
8000a8f6:	e0 80 02 5e 	breq	8000adb2 <_dtoa_r+0xbb2>
8000a8fa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a8fe:	c0 f1       	brne	8000a91c <_dtoa_r+0x71c>
8000a900:	e0 8f 02 59 	bral	8000adb2 <_dtoa_r+0xbb2>
8000a904:	40 8a       	lddsp	r10,sp[0x20]
8000a906:	14 38       	cp.w	r8,r10
8000a908:	c0 30       	breq	8000a90e <_dtoa_r+0x70e>
8000a90a:	10 95       	mov	r5,r8
8000a90c:	c0 98       	rjmp	8000a91e <_dtoa_r+0x71e>
8000a90e:	33 08       	mov	r8,48
8000a910:	40 89       	lddsp	r9,sp[0x20]
8000a912:	2f f6       	sub	r6,-1
8000a914:	b2 88       	st.b	r9[0x0],r8
8000a916:	40 88       	lddsp	r8,sp[0x20]
8000a918:	c0 88       	rjmp	8000a928 <_dtoa_r+0x728>
8000a91a:	40 66       	lddsp	r6,sp[0x18]
8000a91c:	33 99       	mov	r9,57
8000a91e:	0a 98       	mov	r8,r5
8000a920:	11 7a       	ld.ub	r10,--r8
8000a922:	f2 0a 18 00 	cp.b	r10,r9
8000a926:	ce f0       	breq	8000a904 <_dtoa_r+0x704>
8000a928:	50 66       	stdsp	sp[0x18],r6
8000a92a:	11 89       	ld.ub	r9,r8[0x0]
8000a92c:	2f f9       	sub	r9,-1
8000a92e:	b0 89       	st.b	r8[0x0],r9
8000a930:	e0 8f 02 42 	bral	8000adb4 <_dtoa_r+0xbb4>
8000a934:	e0 a0 0a ce 	rcall	8000bed0 <__avr32_f64_mul>
8000a938:	2f f4       	sub	r4,-1
8000a93a:	fa eb 00 08 	st.d	sp[8],r10
8000a93e:	30 08       	mov	r8,0
8000a940:	30 09       	mov	r9,0
8000a942:	e0 a0 0d 92 	rcall	8000c466 <__avr32_f64_cmp_eq>
8000a946:	ca 60       	breq	8000a892 <_dtoa_r+0x692>
8000a948:	e0 8f 02 35 	bral	8000adb2 <_dtoa_r+0xbb2>
8000a94c:	40 d8       	lddsp	r8,sp[0x34]
8000a94e:	58 08       	cp.w	r8,0
8000a950:	c0 51       	brne	8000a95a <_dtoa_r+0x75a>
8000a952:	04 98       	mov	r8,r2
8000a954:	00 95       	mov	r5,r0
8000a956:	40 d4       	lddsp	r4,sp[0x34]
8000a958:	c3 78       	rjmp	8000a9c6 <_dtoa_r+0x7c6>
8000a95a:	40 c5       	lddsp	r5,sp[0x30]
8000a95c:	58 15       	cp.w	r5,1
8000a95e:	e0 89 00 0f 	brgt	8000a97c <_dtoa_r+0x77c>
8000a962:	41 74       	lddsp	r4,sp[0x5c]
8000a964:	58 04       	cp.w	r4,0
8000a966:	c0 40       	breq	8000a96e <_dtoa_r+0x76e>
8000a968:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a96c:	c0 48       	rjmp	8000a974 <_dtoa_r+0x774>
8000a96e:	41 99       	lddsp	r9,sp[0x64]
8000a970:	f2 09 11 36 	rsub	r9,r9,54
8000a974:	04 98       	mov	r8,r2
8000a976:	00 95       	mov	r5,r0
8000a978:	c1 c8       	rjmp	8000a9b0 <_dtoa_r+0x7b0>
8000a97a:	d7 03       	nop
8000a97c:	e2 c8 00 01 	sub	r8,r1,1
8000a980:	58 01       	cp.w	r1,0
8000a982:	e0 05 17 40 	movge	r5,r0
8000a986:	e2 09 17 40 	movge	r9,r1
8000a98a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a98e:	f9 b9 05 00 	movlt	r9,0
8000a992:	10 32       	cp.w	r2,r8
8000a994:	e5 d8 e4 18 	subge	r8,r2,r8
8000a998:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a99c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a9a0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a9a4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a9a8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a9ac:	f9 b8 05 00 	movlt	r8,0
8000a9b0:	40 4b       	lddsp	r11,sp[0x10]
8000a9b2:	12 0b       	add	r11,r9
8000a9b4:	50 08       	stdsp	sp[0x0],r8
8000a9b6:	50 4b       	stdsp	sp[0x10],r11
8000a9b8:	12 00       	add	r0,r9
8000a9ba:	30 1b       	mov	r11,1
8000a9bc:	0e 9c       	mov	r12,r7
8000a9be:	e0 a0 08 a7 	rcall	8000bb0c <__i2b>
8000a9c2:	40 08       	lddsp	r8,sp[0x0]
8000a9c4:	18 94       	mov	r4,r12
8000a9c6:	40 4a       	lddsp	r10,sp[0x10]
8000a9c8:	58 05       	cp.w	r5,0
8000a9ca:	5f 99       	srgt	r9
8000a9cc:	58 0a       	cp.w	r10,0
8000a9ce:	5f 9a       	srgt	r10
8000a9d0:	f5 e9 00 09 	and	r9,r10,r9
8000a9d4:	c0 80       	breq	8000a9e4 <_dtoa_r+0x7e4>
8000a9d6:	40 4c       	lddsp	r12,sp[0x10]
8000a9d8:	f8 05 0d 49 	min	r9,r12,r5
8000a9dc:	12 1c       	sub	r12,r9
8000a9de:	12 10       	sub	r0,r9
8000a9e0:	50 4c       	stdsp	sp[0x10],r12
8000a9e2:	12 15       	sub	r5,r9
8000a9e4:	58 02       	cp.w	r2,0
8000a9e6:	e0 8a 00 27 	brle	8000aa34 <_dtoa_r+0x834>
8000a9ea:	40 db       	lddsp	r11,sp[0x34]
8000a9ec:	58 0b       	cp.w	r11,0
8000a9ee:	c1 d0       	breq	8000aa28 <_dtoa_r+0x828>
8000a9f0:	58 08       	cp.w	r8,0
8000a9f2:	e0 8a 00 17 	brle	8000aa20 <_dtoa_r+0x820>
8000a9f6:	10 9a       	mov	r10,r8
8000a9f8:	50 08       	stdsp	sp[0x0],r8
8000a9fa:	08 9b       	mov	r11,r4
8000a9fc:	0e 9c       	mov	r12,r7
8000a9fe:	e0 a0 08 cd 	rcall	8000bb98 <__pow5mult>
8000aa02:	06 9a       	mov	r10,r3
8000aa04:	18 9b       	mov	r11,r12
8000aa06:	18 94       	mov	r4,r12
8000aa08:	0e 9c       	mov	r12,r7
8000aa0a:	e0 a0 08 01 	rcall	8000ba0c <__multiply>
8000aa0e:	18 99       	mov	r9,r12
8000aa10:	06 9b       	mov	r11,r3
8000aa12:	50 19       	stdsp	sp[0x4],r9
8000aa14:	0e 9c       	mov	r12,r7
8000aa16:	e0 a0 06 ad 	rcall	8000b770 <_Bfree>
8000aa1a:	40 19       	lddsp	r9,sp[0x4]
8000aa1c:	40 08       	lddsp	r8,sp[0x0]
8000aa1e:	12 93       	mov	r3,r9
8000aa20:	e4 08 01 0a 	sub	r10,r2,r8
8000aa24:	c0 80       	breq	8000aa34 <_dtoa_r+0x834>
8000aa26:	c0 28       	rjmp	8000aa2a <_dtoa_r+0x82a>
8000aa28:	04 9a       	mov	r10,r2
8000aa2a:	06 9b       	mov	r11,r3
8000aa2c:	0e 9c       	mov	r12,r7
8000aa2e:	e0 a0 08 b5 	rcall	8000bb98 <__pow5mult>
8000aa32:	18 93       	mov	r3,r12
8000aa34:	30 1b       	mov	r11,1
8000aa36:	0e 9c       	mov	r12,r7
8000aa38:	e0 a0 08 6a 	rcall	8000bb0c <__i2b>
8000aa3c:	41 1a       	lddsp	r10,sp[0x44]
8000aa3e:	18 92       	mov	r2,r12
8000aa40:	58 0a       	cp.w	r10,0
8000aa42:	e0 8a 00 07 	brle	8000aa50 <_dtoa_r+0x850>
8000aa46:	18 9b       	mov	r11,r12
8000aa48:	0e 9c       	mov	r12,r7
8000aa4a:	e0 a0 08 a7 	rcall	8000bb98 <__pow5mult>
8000aa4e:	18 92       	mov	r2,r12
8000aa50:	40 c9       	lddsp	r9,sp[0x30]
8000aa52:	58 19       	cp.w	r9,1
8000aa54:	e0 89 00 14 	brgt	8000aa7c <_dtoa_r+0x87c>
8000aa58:	40 38       	lddsp	r8,sp[0xc]
8000aa5a:	58 08       	cp.w	r8,0
8000aa5c:	c1 01       	brne	8000aa7c <_dtoa_r+0x87c>
8000aa5e:	40 29       	lddsp	r9,sp[0x8]
8000aa60:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa64:	c0 c1       	brne	8000aa7c <_dtoa_r+0x87c>
8000aa66:	12 98       	mov	r8,r9
8000aa68:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa6c:	c0 80       	breq	8000aa7c <_dtoa_r+0x87c>
8000aa6e:	40 4c       	lddsp	r12,sp[0x10]
8000aa70:	30 1b       	mov	r11,1
8000aa72:	2f fc       	sub	r12,-1
8000aa74:	2f f0       	sub	r0,-1
8000aa76:	50 4c       	stdsp	sp[0x10],r12
8000aa78:	50 6b       	stdsp	sp[0x18],r11
8000aa7a:	c0 38       	rjmp	8000aa80 <_dtoa_r+0x880>
8000aa7c:	30 0a       	mov	r10,0
8000aa7e:	50 6a       	stdsp	sp[0x18],r10
8000aa80:	41 19       	lddsp	r9,sp[0x44]
8000aa82:	58 09       	cp.w	r9,0
8000aa84:	c0 31       	brne	8000aa8a <_dtoa_r+0x88a>
8000aa86:	30 1c       	mov	r12,1
8000aa88:	c0 98       	rjmp	8000aa9a <_dtoa_r+0x89a>
8000aa8a:	64 48       	ld.w	r8,r2[0x10]
8000aa8c:	2f c8       	sub	r8,-4
8000aa8e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aa92:	e0 a0 05 df 	rcall	8000b650 <__hi0bits>
8000aa96:	f8 0c 11 20 	rsub	r12,r12,32
8000aa9a:	40 4b       	lddsp	r11,sp[0x10]
8000aa9c:	f8 0b 00 08 	add	r8,r12,r11
8000aaa0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aaa4:	c0 c0       	breq	8000aabc <_dtoa_r+0x8bc>
8000aaa6:	f0 08 11 20 	rsub	r8,r8,32
8000aaaa:	58 48       	cp.w	r8,4
8000aaac:	e0 8a 00 06 	brle	8000aab8 <_dtoa_r+0x8b8>
8000aab0:	20 48       	sub	r8,4
8000aab2:	10 0b       	add	r11,r8
8000aab4:	50 4b       	stdsp	sp[0x10],r11
8000aab6:	c0 78       	rjmp	8000aac4 <_dtoa_r+0x8c4>
8000aab8:	58 48       	cp.w	r8,4
8000aaba:	c0 70       	breq	8000aac8 <_dtoa_r+0x8c8>
8000aabc:	40 4a       	lddsp	r10,sp[0x10]
8000aabe:	2e 48       	sub	r8,-28
8000aac0:	10 0a       	add	r10,r8
8000aac2:	50 4a       	stdsp	sp[0x10],r10
8000aac4:	10 00       	add	r0,r8
8000aac6:	10 05       	add	r5,r8
8000aac8:	58 00       	cp.w	r0,0
8000aaca:	e0 8a 00 08 	brle	8000aada <_dtoa_r+0x8da>
8000aace:	06 9b       	mov	r11,r3
8000aad0:	00 9a       	mov	r10,r0
8000aad2:	0e 9c       	mov	r12,r7
8000aad4:	e0 a0 07 58 	rcall	8000b984 <__lshift>
8000aad8:	18 93       	mov	r3,r12
8000aada:	40 49       	lddsp	r9,sp[0x10]
8000aadc:	58 09       	cp.w	r9,0
8000aade:	e0 8a 00 08 	brle	8000aaee <_dtoa_r+0x8ee>
8000aae2:	04 9b       	mov	r11,r2
8000aae4:	12 9a       	mov	r10,r9
8000aae6:	0e 9c       	mov	r12,r7
8000aae8:	e0 a0 07 4e 	rcall	8000b984 <__lshift>
8000aaec:	18 92       	mov	r2,r12
8000aaee:	41 48       	lddsp	r8,sp[0x50]
8000aaf0:	58 08       	cp.w	r8,0
8000aaf2:	c1 b0       	breq	8000ab28 <_dtoa_r+0x928>
8000aaf4:	04 9b       	mov	r11,r2
8000aaf6:	06 9c       	mov	r12,r3
8000aaf8:	e0 a0 06 23 	rcall	8000b73e <__mcmp>
8000aafc:	c1 64       	brge	8000ab28 <_dtoa_r+0x928>
8000aafe:	06 9b       	mov	r11,r3
8000ab00:	30 09       	mov	r9,0
8000ab02:	30 aa       	mov	r10,10
8000ab04:	0e 9c       	mov	r12,r7
8000ab06:	e0 a0 08 0b 	rcall	8000bb1c <__multadd>
8000ab0a:	20 16       	sub	r6,1
8000ab0c:	18 93       	mov	r3,r12
8000ab0e:	40 dc       	lddsp	r12,sp[0x34]
8000ab10:	58 0c       	cp.w	r12,0
8000ab12:	c0 31       	brne	8000ab18 <_dtoa_r+0x918>
8000ab14:	40 91       	lddsp	r1,sp[0x24]
8000ab16:	c0 98       	rjmp	8000ab28 <_dtoa_r+0x928>
8000ab18:	08 9b       	mov	r11,r4
8000ab1a:	40 91       	lddsp	r1,sp[0x24]
8000ab1c:	30 09       	mov	r9,0
8000ab1e:	30 aa       	mov	r10,10
8000ab20:	0e 9c       	mov	r12,r7
8000ab22:	e0 a0 07 fd 	rcall	8000bb1c <__multadd>
8000ab26:	18 94       	mov	r4,r12
8000ab28:	58 01       	cp.w	r1,0
8000ab2a:	5f a9       	srle	r9
8000ab2c:	40 cb       	lddsp	r11,sp[0x30]
8000ab2e:	58 2b       	cp.w	r11,2
8000ab30:	5f 98       	srgt	r8
8000ab32:	f3 e8 00 08 	and	r8,r9,r8
8000ab36:	c2 50       	breq	8000ab80 <_dtoa_r+0x980>
8000ab38:	58 01       	cp.w	r1,0
8000ab3a:	c1 11       	brne	8000ab5c <_dtoa_r+0x95c>
8000ab3c:	04 9b       	mov	r11,r2
8000ab3e:	02 99       	mov	r9,r1
8000ab40:	30 5a       	mov	r10,5
8000ab42:	0e 9c       	mov	r12,r7
8000ab44:	e0 a0 07 ec 	rcall	8000bb1c <__multadd>
8000ab48:	18 92       	mov	r2,r12
8000ab4a:	18 9b       	mov	r11,r12
8000ab4c:	06 9c       	mov	r12,r3
8000ab4e:	e0 a0 05 f8 	rcall	8000b73e <__mcmp>
8000ab52:	e0 89 00 0f 	brgt	8000ab70 <_dtoa_r+0x970>
8000ab56:	c0 38       	rjmp	8000ab5c <_dtoa_r+0x95c>
8000ab58:	30 02       	mov	r2,0
8000ab5a:	04 94       	mov	r4,r2
8000ab5c:	40 ea       	lddsp	r10,sp[0x38]
8000ab5e:	30 09       	mov	r9,0
8000ab60:	5c da       	com	r10
8000ab62:	40 85       	lddsp	r5,sp[0x20]
8000ab64:	50 6a       	stdsp	sp[0x18],r10
8000ab66:	50 49       	stdsp	sp[0x10],r9
8000ab68:	c0 f9       	rjmp	8000ad86 <_dtoa_r+0xb86>
8000ab6a:	08 92       	mov	r2,r4
8000ab6c:	40 66       	lddsp	r6,sp[0x18]
8000ab6e:	04 94       	mov	r4,r2
8000ab70:	2f f6       	sub	r6,-1
8000ab72:	50 66       	stdsp	sp[0x18],r6
8000ab74:	33 18       	mov	r8,49
8000ab76:	40 85       	lddsp	r5,sp[0x20]
8000ab78:	0a c8       	st.b	r5++,r8
8000ab7a:	30 08       	mov	r8,0
8000ab7c:	50 48       	stdsp	sp[0x10],r8
8000ab7e:	c0 49       	rjmp	8000ad86 <_dtoa_r+0xb86>
8000ab80:	40 dc       	lddsp	r12,sp[0x34]
8000ab82:	58 0c       	cp.w	r12,0
8000ab84:	e0 80 00 b5 	breq	8000acee <_dtoa_r+0xaee>
8000ab88:	58 05       	cp.w	r5,0
8000ab8a:	e0 8a 00 08 	brle	8000ab9a <_dtoa_r+0x99a>
8000ab8e:	08 9b       	mov	r11,r4
8000ab90:	0a 9a       	mov	r10,r5
8000ab92:	0e 9c       	mov	r12,r7
8000ab94:	e0 a0 06 f8 	rcall	8000b984 <__lshift>
8000ab98:	18 94       	mov	r4,r12
8000ab9a:	40 6b       	lddsp	r11,sp[0x18]
8000ab9c:	58 0b       	cp.w	r11,0
8000ab9e:	c0 31       	brne	8000aba4 <_dtoa_r+0x9a4>
8000aba0:	08 9c       	mov	r12,r4
8000aba2:	c1 38       	rjmp	8000abc8 <_dtoa_r+0x9c8>
8000aba4:	68 1b       	ld.w	r11,r4[0x4]
8000aba6:	0e 9c       	mov	r12,r7
8000aba8:	e0 a0 05 fe 	rcall	8000b7a4 <_Balloc>
8000abac:	68 4a       	ld.w	r10,r4[0x10]
8000abae:	18 95       	mov	r5,r12
8000abb0:	e8 cb ff f4 	sub	r11,r4,-12
8000abb4:	2f ea       	sub	r10,-2
8000abb6:	2f 4c       	sub	r12,-12
8000abb8:	a3 6a       	lsl	r10,0x2
8000abba:	fe b0 e6 4f 	rcall	80007858 <memcpy>
8000abbe:	0a 9b       	mov	r11,r5
8000abc0:	30 1a       	mov	r10,1
8000abc2:	0e 9c       	mov	r12,r7
8000abc4:	e0 a0 06 e0 	rcall	8000b984 <__lshift>
8000abc8:	50 44       	stdsp	sp[0x10],r4
8000abca:	40 3a       	lddsp	r10,sp[0xc]
8000abcc:	30 19       	mov	r9,1
8000abce:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000abd2:	18 94       	mov	r4,r12
8000abd4:	50 da       	stdsp	sp[0x34],r10
8000abd6:	40 85       	lddsp	r5,sp[0x20]
8000abd8:	50 99       	stdsp	sp[0x24],r9
8000abda:	50 26       	stdsp	sp[0x8],r6
8000abdc:	50 e1       	stdsp	sp[0x38],r1
8000abde:	04 9b       	mov	r11,r2
8000abe0:	06 9c       	mov	r12,r3
8000abe2:	fe b0 fa 7f 	rcall	8000a0e0 <quorem>
8000abe6:	40 4b       	lddsp	r11,sp[0x10]
8000abe8:	f8 c0 ff d0 	sub	r0,r12,-48
8000abec:	06 9c       	mov	r12,r3
8000abee:	e0 a0 05 a8 	rcall	8000b73e <__mcmp>
8000abf2:	08 9a       	mov	r10,r4
8000abf4:	50 6c       	stdsp	sp[0x18],r12
8000abf6:	04 9b       	mov	r11,r2
8000abf8:	0e 9c       	mov	r12,r7
8000abfa:	e0 a0 06 5d 	rcall	8000b8b4 <__mdiff>
8000abfe:	18 91       	mov	r1,r12
8000ac00:	78 38       	ld.w	r8,r12[0xc]
8000ac02:	58 08       	cp.w	r8,0
8000ac04:	c0 30       	breq	8000ac0a <_dtoa_r+0xa0a>
8000ac06:	30 16       	mov	r6,1
8000ac08:	c0 68       	rjmp	8000ac14 <_dtoa_r+0xa14>
8000ac0a:	18 9b       	mov	r11,r12
8000ac0c:	06 9c       	mov	r12,r3
8000ac0e:	e0 a0 05 98 	rcall	8000b73e <__mcmp>
8000ac12:	18 96       	mov	r6,r12
8000ac14:	0e 9c       	mov	r12,r7
8000ac16:	02 9b       	mov	r11,r1
8000ac18:	e0 a0 05 ac 	rcall	8000b770 <_Bfree>
8000ac1c:	40 cc       	lddsp	r12,sp[0x30]
8000ac1e:	ed ec 10 08 	or	r8,r6,r12
8000ac22:	c0 d1       	brne	8000ac3c <_dtoa_r+0xa3c>
8000ac24:	40 db       	lddsp	r11,sp[0x34]
8000ac26:	58 0b       	cp.w	r11,0
8000ac28:	c0 a1       	brne	8000ac3c <_dtoa_r+0xa3c>
8000ac2a:	40 26       	lddsp	r6,sp[0x8]
8000ac2c:	e0 40 00 39 	cp.w	r0,57
8000ac30:	c3 00       	breq	8000ac90 <_dtoa_r+0xa90>
8000ac32:	40 6a       	lddsp	r10,sp[0x18]
8000ac34:	58 0a       	cp.w	r10,0
8000ac36:	e0 89 00 24 	brgt	8000ac7e <_dtoa_r+0xa7e>
8000ac3a:	c2 f8       	rjmp	8000ac98 <_dtoa_r+0xa98>
8000ac3c:	40 69       	lddsp	r9,sp[0x18]
8000ac3e:	58 09       	cp.w	r9,0
8000ac40:	c0 85       	brlt	8000ac50 <_dtoa_r+0xa50>
8000ac42:	12 98       	mov	r8,r9
8000ac44:	40 cc       	lddsp	r12,sp[0x30]
8000ac46:	18 48       	or	r8,r12
8000ac48:	c1 d1       	brne	8000ac82 <_dtoa_r+0xa82>
8000ac4a:	40 db       	lddsp	r11,sp[0x34]
8000ac4c:	58 0b       	cp.w	r11,0
8000ac4e:	c1 a1       	brne	8000ac82 <_dtoa_r+0xa82>
8000ac50:	0c 99       	mov	r9,r6
8000ac52:	40 26       	lddsp	r6,sp[0x8]
8000ac54:	58 09       	cp.w	r9,0
8000ac56:	e0 8a 00 21 	brle	8000ac98 <_dtoa_r+0xa98>
8000ac5a:	06 9b       	mov	r11,r3
8000ac5c:	30 1a       	mov	r10,1
8000ac5e:	0e 9c       	mov	r12,r7
8000ac60:	e0 a0 06 92 	rcall	8000b984 <__lshift>
8000ac64:	04 9b       	mov	r11,r2
8000ac66:	18 93       	mov	r3,r12
8000ac68:	e0 a0 05 6b 	rcall	8000b73e <__mcmp>
8000ac6c:	e0 89 00 06 	brgt	8000ac78 <_dtoa_r+0xa78>
8000ac70:	c1 41       	brne	8000ac98 <_dtoa_r+0xa98>
8000ac72:	ed b0 00 00 	bld	r0,0x0
8000ac76:	c1 11       	brne	8000ac98 <_dtoa_r+0xa98>
8000ac78:	e0 40 00 39 	cp.w	r0,57
8000ac7c:	c0 a0       	breq	8000ac90 <_dtoa_r+0xa90>
8000ac7e:	2f f0       	sub	r0,-1
8000ac80:	c0 c8       	rjmp	8000ac98 <_dtoa_r+0xa98>
8000ac82:	58 06       	cp.w	r6,0
8000ac84:	e0 8a 00 0c 	brle	8000ac9c <_dtoa_r+0xa9c>
8000ac88:	40 26       	lddsp	r6,sp[0x8]
8000ac8a:	e0 40 00 39 	cp.w	r0,57
8000ac8e:	c0 41       	brne	8000ac96 <_dtoa_r+0xa96>
8000ac90:	33 98       	mov	r8,57
8000ac92:	0a c8       	st.b	r5++,r8
8000ac94:	c6 78       	rjmp	8000ad62 <_dtoa_r+0xb62>
8000ac96:	2f f0       	sub	r0,-1
8000ac98:	0a c0       	st.b	r5++,r0
8000ac9a:	c7 58       	rjmp	8000ad84 <_dtoa_r+0xb84>
8000ac9c:	0a c0       	st.b	r5++,r0
8000ac9e:	40 9a       	lddsp	r10,sp[0x24]
8000aca0:	40 e9       	lddsp	r9,sp[0x38]
8000aca2:	12 3a       	cp.w	r10,r9
8000aca4:	c4 30       	breq	8000ad2a <_dtoa_r+0xb2a>
8000aca6:	06 9b       	mov	r11,r3
8000aca8:	30 09       	mov	r9,0
8000acaa:	30 aa       	mov	r10,10
8000acac:	0e 9c       	mov	r12,r7
8000acae:	e0 a0 07 37 	rcall	8000bb1c <__multadd>
8000acb2:	40 48       	lddsp	r8,sp[0x10]
8000acb4:	18 93       	mov	r3,r12
8000acb6:	08 38       	cp.w	r8,r4
8000acb8:	c0 91       	brne	8000acca <_dtoa_r+0xaca>
8000acba:	10 9b       	mov	r11,r8
8000acbc:	30 09       	mov	r9,0
8000acbe:	30 aa       	mov	r10,10
8000acc0:	0e 9c       	mov	r12,r7
8000acc2:	e0 a0 07 2d 	rcall	8000bb1c <__multadd>
8000acc6:	50 4c       	stdsp	sp[0x10],r12
8000acc8:	c0 e8       	rjmp	8000ace4 <_dtoa_r+0xae4>
8000acca:	40 4b       	lddsp	r11,sp[0x10]
8000accc:	30 09       	mov	r9,0
8000acce:	30 aa       	mov	r10,10
8000acd0:	0e 9c       	mov	r12,r7
8000acd2:	e0 a0 07 25 	rcall	8000bb1c <__multadd>
8000acd6:	08 9b       	mov	r11,r4
8000acd8:	50 4c       	stdsp	sp[0x10],r12
8000acda:	30 09       	mov	r9,0
8000acdc:	30 aa       	mov	r10,10
8000acde:	0e 9c       	mov	r12,r7
8000ace0:	e0 a0 07 1e 	rcall	8000bb1c <__multadd>
8000ace4:	18 94       	mov	r4,r12
8000ace6:	40 9c       	lddsp	r12,sp[0x24]
8000ace8:	2f fc       	sub	r12,-1
8000acea:	50 9c       	stdsp	sp[0x24],r12
8000acec:	c7 9b       	rjmp	8000abde <_dtoa_r+0x9de>
8000acee:	30 18       	mov	r8,1
8000acf0:	06 90       	mov	r0,r3
8000acf2:	40 85       	lddsp	r5,sp[0x20]
8000acf4:	08 93       	mov	r3,r4
8000acf6:	0c 94       	mov	r4,r6
8000acf8:	10 96       	mov	r6,r8
8000acfa:	04 9b       	mov	r11,r2
8000acfc:	00 9c       	mov	r12,r0
8000acfe:	fe b0 f9 f1 	rcall	8000a0e0 <quorem>
8000ad02:	2d 0c       	sub	r12,-48
8000ad04:	0a cc       	st.b	r5++,r12
8000ad06:	02 36       	cp.w	r6,r1
8000ad08:	c0 a4       	brge	8000ad1c <_dtoa_r+0xb1c>
8000ad0a:	00 9b       	mov	r11,r0
8000ad0c:	30 09       	mov	r9,0
8000ad0e:	30 aa       	mov	r10,10
8000ad10:	0e 9c       	mov	r12,r7
8000ad12:	2f f6       	sub	r6,-1
8000ad14:	e0 a0 07 04 	rcall	8000bb1c <__multadd>
8000ad18:	18 90       	mov	r0,r12
8000ad1a:	cf 0b       	rjmp	8000acfa <_dtoa_r+0xafa>
8000ad1c:	08 96       	mov	r6,r4
8000ad1e:	30 0b       	mov	r11,0
8000ad20:	06 94       	mov	r4,r3
8000ad22:	50 4b       	stdsp	sp[0x10],r11
8000ad24:	00 93       	mov	r3,r0
8000ad26:	18 90       	mov	r0,r12
8000ad28:	c0 28       	rjmp	8000ad2c <_dtoa_r+0xb2c>
8000ad2a:	40 26       	lddsp	r6,sp[0x8]
8000ad2c:	06 9b       	mov	r11,r3
8000ad2e:	30 1a       	mov	r10,1
8000ad30:	0e 9c       	mov	r12,r7
8000ad32:	e0 a0 06 29 	rcall	8000b984 <__lshift>
8000ad36:	04 9b       	mov	r11,r2
8000ad38:	18 93       	mov	r3,r12
8000ad3a:	e0 a0 05 02 	rcall	8000b73e <__mcmp>
8000ad3e:	e0 89 00 12 	brgt	8000ad62 <_dtoa_r+0xb62>
8000ad42:	c1 b1       	brne	8000ad78 <_dtoa_r+0xb78>
8000ad44:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad48:	c0 d1       	brne	8000ad62 <_dtoa_r+0xb62>
8000ad4a:	c1 78       	rjmp	8000ad78 <_dtoa_r+0xb78>
8000ad4c:	40 89       	lddsp	r9,sp[0x20]
8000ad4e:	12 38       	cp.w	r8,r9
8000ad50:	c0 30       	breq	8000ad56 <_dtoa_r+0xb56>
8000ad52:	10 95       	mov	r5,r8
8000ad54:	c0 88       	rjmp	8000ad64 <_dtoa_r+0xb64>
8000ad56:	2f f6       	sub	r6,-1
8000ad58:	50 66       	stdsp	sp[0x18],r6
8000ad5a:	33 18       	mov	r8,49
8000ad5c:	40 8c       	lddsp	r12,sp[0x20]
8000ad5e:	b8 88       	st.b	r12[0x0],r8
8000ad60:	c1 38       	rjmp	8000ad86 <_dtoa_r+0xb86>
8000ad62:	33 9a       	mov	r10,57
8000ad64:	0a 98       	mov	r8,r5
8000ad66:	11 79       	ld.ub	r9,--r8
8000ad68:	f4 09 18 00 	cp.b	r9,r10
8000ad6c:	cf 00       	breq	8000ad4c <_dtoa_r+0xb4c>
8000ad6e:	2f f9       	sub	r9,-1
8000ad70:	b0 89       	st.b	r8[0x0],r9
8000ad72:	c0 98       	rjmp	8000ad84 <_dtoa_r+0xb84>
8000ad74:	10 95       	mov	r5,r8
8000ad76:	c0 28       	rjmp	8000ad7a <_dtoa_r+0xb7a>
8000ad78:	33 09       	mov	r9,48
8000ad7a:	0a 98       	mov	r8,r5
8000ad7c:	11 7a       	ld.ub	r10,--r8
8000ad7e:	f2 0a 18 00 	cp.b	r10,r9
8000ad82:	cf 90       	breq	8000ad74 <_dtoa_r+0xb74>
8000ad84:	50 66       	stdsp	sp[0x18],r6
8000ad86:	04 9b       	mov	r11,r2
8000ad88:	0e 9c       	mov	r12,r7
8000ad8a:	e0 a0 04 f3 	rcall	8000b770 <_Bfree>
8000ad8e:	58 04       	cp.w	r4,0
8000ad90:	c1 20       	breq	8000adb4 <_dtoa_r+0xbb4>
8000ad92:	40 4b       	lddsp	r11,sp[0x10]
8000ad94:	08 3b       	cp.w	r11,r4
8000ad96:	5f 19       	srne	r9
8000ad98:	58 0b       	cp.w	r11,0
8000ad9a:	5f 18       	srne	r8
8000ad9c:	f3 e8 00 08 	and	r8,r9,r8
8000ada0:	c0 40       	breq	8000ada8 <_dtoa_r+0xba8>
8000ada2:	0e 9c       	mov	r12,r7
8000ada4:	e0 a0 04 e6 	rcall	8000b770 <_Bfree>
8000ada8:	08 9b       	mov	r11,r4
8000adaa:	0e 9c       	mov	r12,r7
8000adac:	e0 a0 04 e2 	rcall	8000b770 <_Bfree>
8000adb0:	c0 28       	rjmp	8000adb4 <_dtoa_r+0xbb4>
8000adb2:	50 66       	stdsp	sp[0x18],r6
8000adb4:	0e 9c       	mov	r12,r7
8000adb6:	06 9b       	mov	r11,r3
8000adb8:	e0 a0 04 dc 	rcall	8000b770 <_Bfree>
8000adbc:	30 08       	mov	r8,0
8000adbe:	aa 88       	st.b	r5[0x0],r8
8000adc0:	40 68       	lddsp	r8,sp[0x18]
8000adc2:	41 5a       	lddsp	r10,sp[0x54]
8000adc4:	2f f8       	sub	r8,-1
8000adc6:	41 29       	lddsp	r9,sp[0x48]
8000adc8:	95 08       	st.w	r10[0x0],r8
8000adca:	40 8c       	lddsp	r12,sp[0x20]
8000adcc:	58 09       	cp.w	r9,0
8000adce:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000add2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000add6:	2e 6d       	sub	sp,-104
8000add8:	d8 32       	popm	r0-r7,pc
8000adda:	d7 03       	nop

8000addc <__errno>:
8000addc:	e0 68 0a 40 	mov	r8,2624
8000ade0:	70 0c       	ld.w	r12,r8[0x0]
8000ade2:	2f 4c       	sub	r12,-12
8000ade4:	5e fc       	retal	r12
8000ade6:	d7 03       	nop

8000ade8 <_fflush_r>:
8000ade8:	d4 21       	pushm	r4-r7,lr
8000adea:	16 97       	mov	r7,r11
8000adec:	18 96       	mov	r6,r12
8000adee:	76 48       	ld.w	r8,r11[0x10]
8000adf0:	58 08       	cp.w	r8,0
8000adf2:	c7 f0       	breq	8000aef0 <_fflush_r+0x108>
8000adf4:	58 0c       	cp.w	r12,0
8000adf6:	c0 50       	breq	8000ae00 <_fflush_r+0x18>
8000adf8:	78 68       	ld.w	r8,r12[0x18]
8000adfa:	58 08       	cp.w	r8,0
8000adfc:	c0 21       	brne	8000ae00 <_fflush_r+0x18>
8000adfe:	cc dc       	rcall	8000af98 <__sinit>
8000ae00:	fe c8 cd 24 	sub	r8,pc,-13020
8000ae04:	10 37       	cp.w	r7,r8
8000ae06:	c0 31       	brne	8000ae0c <_fflush_r+0x24>
8000ae08:	6c 07       	ld.w	r7,r6[0x0]
8000ae0a:	c0 c8       	rjmp	8000ae22 <_fflush_r+0x3a>
8000ae0c:	fe c8 cd 10 	sub	r8,pc,-13040
8000ae10:	10 37       	cp.w	r7,r8
8000ae12:	c0 31       	brne	8000ae18 <_fflush_r+0x30>
8000ae14:	6c 17       	ld.w	r7,r6[0x4]
8000ae16:	c0 68       	rjmp	8000ae22 <_fflush_r+0x3a>
8000ae18:	fe c8 cc fc 	sub	r8,pc,-13060
8000ae1c:	10 37       	cp.w	r7,r8
8000ae1e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae22:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae24:	14 98       	mov	r8,r10
8000ae26:	ed ba 00 03 	bld	r10,0x3
8000ae2a:	c4 20       	breq	8000aeae <_fflush_r+0xc6>
8000ae2c:	ab ba       	sbr	r10,0xb
8000ae2e:	ae 6a       	st.h	r7[0xc],r10
8000ae30:	6e 18       	ld.w	r8,r7[0x4]
8000ae32:	58 08       	cp.w	r8,0
8000ae34:	e0 89 00 06 	brgt	8000ae40 <_fflush_r+0x58>
8000ae38:	6f 08       	ld.w	r8,r7[0x40]
8000ae3a:	58 08       	cp.w	r8,0
8000ae3c:	e0 8a 00 5a 	brle	8000aef0 <_fflush_r+0x108>
8000ae40:	6e b8       	ld.w	r8,r7[0x2c]
8000ae42:	58 08       	cp.w	r8,0
8000ae44:	c5 60       	breq	8000aef0 <_fflush_r+0x108>
8000ae46:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae4a:	c0 30       	breq	8000ae50 <_fflush_r+0x68>
8000ae4c:	6f 55       	ld.w	r5,r7[0x54]
8000ae4e:	c0 f8       	rjmp	8000ae6c <_fflush_r+0x84>
8000ae50:	30 19       	mov	r9,1
8000ae52:	6e 8b       	ld.w	r11,r7[0x20]
8000ae54:	0c 9c       	mov	r12,r6
8000ae56:	5d 18       	icall	r8
8000ae58:	18 95       	mov	r5,r12
8000ae5a:	5b fc       	cp.w	r12,-1
8000ae5c:	c0 81       	brne	8000ae6c <_fflush_r+0x84>
8000ae5e:	6c 38       	ld.w	r8,r6[0xc]
8000ae60:	59 d8       	cp.w	r8,29
8000ae62:	c4 70       	breq	8000aef0 <_fflush_r+0x108>
8000ae64:	8e 68       	ld.sh	r8,r7[0xc]
8000ae66:	a7 a8       	sbr	r8,0x6
8000ae68:	ae 68       	st.h	r7[0xc],r8
8000ae6a:	d8 22       	popm	r4-r7,pc
8000ae6c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae6e:	ed b8 00 02 	bld	r8,0x2
8000ae72:	c0 91       	brne	8000ae84 <_fflush_r+0x9c>
8000ae74:	6e 18       	ld.w	r8,r7[0x4]
8000ae76:	10 15       	sub	r5,r8
8000ae78:	6e d8       	ld.w	r8,r7[0x34]
8000ae7a:	58 08       	cp.w	r8,0
8000ae7c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae80:	eb d8 e1 15 	subne	r5,r5,r8
8000ae84:	6e b8       	ld.w	r8,r7[0x2c]
8000ae86:	0c 9c       	mov	r12,r6
8000ae88:	30 09       	mov	r9,0
8000ae8a:	0a 9a       	mov	r10,r5
8000ae8c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae8e:	5d 18       	icall	r8
8000ae90:	8e 68       	ld.sh	r8,r7[0xc]
8000ae92:	0a 3c       	cp.w	r12,r5
8000ae94:	c2 61       	brne	8000aee0 <_fflush_r+0xf8>
8000ae96:	ab d8       	cbr	r8,0xb
8000ae98:	30 0c       	mov	r12,0
8000ae9a:	6e 49       	ld.w	r9,r7[0x10]
8000ae9c:	ae 68       	st.h	r7[0xc],r8
8000ae9e:	8f 1c       	st.w	r7[0x4],r12
8000aea0:	8f 09       	st.w	r7[0x0],r9
8000aea2:	ed b8 00 0c 	bld	r8,0xc
8000aea6:	c2 51       	brne	8000aef0 <_fflush_r+0x108>
8000aea8:	ef 45 00 54 	st.w	r7[84],r5
8000aeac:	d8 22       	popm	r4-r7,pc
8000aeae:	6e 45       	ld.w	r5,r7[0x10]
8000aeb0:	58 05       	cp.w	r5,0
8000aeb2:	c1 f0       	breq	8000aef0 <_fflush_r+0x108>
8000aeb4:	6e 04       	ld.w	r4,r7[0x0]
8000aeb6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aeba:	8f 05       	st.w	r7[0x0],r5
8000aebc:	f9 b8 01 00 	movne	r8,0
8000aec0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aec4:	0a 14       	sub	r4,r5
8000aec6:	8f 28       	st.w	r7[0x8],r8
8000aec8:	c1 18       	rjmp	8000aeea <_fflush_r+0x102>
8000aeca:	08 99       	mov	r9,r4
8000aecc:	0a 9a       	mov	r10,r5
8000aece:	6e a8       	ld.w	r8,r7[0x28]
8000aed0:	6e 8b       	ld.w	r11,r7[0x20]
8000aed2:	0c 9c       	mov	r12,r6
8000aed4:	5d 18       	icall	r8
8000aed6:	18 14       	sub	r4,r12
8000aed8:	58 0c       	cp.w	r12,0
8000aeda:	e0 89 00 07 	brgt	8000aee8 <_fflush_r+0x100>
8000aede:	8e 68       	ld.sh	r8,r7[0xc]
8000aee0:	a7 a8       	sbr	r8,0x6
8000aee2:	3f fc       	mov	r12,-1
8000aee4:	ae 68       	st.h	r7[0xc],r8
8000aee6:	d8 22       	popm	r4-r7,pc
8000aee8:	18 05       	add	r5,r12
8000aeea:	58 04       	cp.w	r4,0
8000aeec:	fe 99 ff ef 	brgt	8000aeca <_fflush_r+0xe2>
8000aef0:	d8 2a       	popm	r4-r7,pc,r12=0
8000aef2:	d7 03       	nop

8000aef4 <__sfp_lock_acquire>:
8000aef4:	5e fc       	retal	r12

8000aef6 <__sfp_lock_release>:
8000aef6:	5e fc       	retal	r12

8000aef8 <_cleanup_r>:
8000aef8:	d4 01       	pushm	lr
8000aefa:	fe cb f0 ae 	sub	r11,pc,-3922
8000aefe:	e0 a0 02 f7 	rcall	8000b4ec <_fwalk>
8000af02:	d8 02       	popm	pc

8000af04 <__sfmoreglue>:
8000af04:	d4 21       	pushm	r4-r7,lr
8000af06:	16 95       	mov	r5,r11
8000af08:	f6 06 10 5c 	mul	r6,r11,92
8000af0c:	ec cb ff f4 	sub	r11,r6,-12
8000af10:	fe b0 e2 88 	rcall	80007420 <_malloc_r>
8000af14:	18 97       	mov	r7,r12
8000af16:	c0 90       	breq	8000af28 <__sfmoreglue+0x24>
8000af18:	99 15       	st.w	r12[0x4],r5
8000af1a:	30 0b       	mov	r11,0
8000af1c:	2f 4c       	sub	r12,-12
8000af1e:	0c 9a       	mov	r10,r6
8000af20:	8f 2c       	st.w	r7[0x8],r12
8000af22:	8f 0b       	st.w	r7[0x0],r11
8000af24:	fe b0 e5 3e 	rcall	800079a0 <memset>
8000af28:	0e 9c       	mov	r12,r7
8000af2a:	d8 22       	popm	r4-r7,pc

8000af2c <__sfp>:
8000af2c:	d4 21       	pushm	r4-r7,lr
8000af2e:	fe c8 cd ee 	sub	r8,pc,-12818
8000af32:	18 96       	mov	r6,r12
8000af34:	70 07       	ld.w	r7,r8[0x0]
8000af36:	6e 68       	ld.w	r8,r7[0x18]
8000af38:	58 08       	cp.w	r8,0
8000af3a:	c0 31       	brne	8000af40 <__sfp+0x14>
8000af3c:	0e 9c       	mov	r12,r7
8000af3e:	c2 dc       	rcall	8000af98 <__sinit>
8000af40:	ee c7 ff 28 	sub	r7,r7,-216
8000af44:	30 05       	mov	r5,0
8000af46:	6e 2c       	ld.w	r12,r7[0x8]
8000af48:	6e 18       	ld.w	r8,r7[0x4]
8000af4a:	c0 68       	rjmp	8000af56 <__sfp+0x2a>
8000af4c:	98 69       	ld.sh	r9,r12[0xc]
8000af4e:	ea 09 19 00 	cp.h	r9,r5
8000af52:	c1 10       	breq	8000af74 <__sfp+0x48>
8000af54:	2a 4c       	sub	r12,-92
8000af56:	20 18       	sub	r8,1
8000af58:	cf a7       	brpl	8000af4c <__sfp+0x20>
8000af5a:	6e 08       	ld.w	r8,r7[0x0]
8000af5c:	58 08       	cp.w	r8,0
8000af5e:	c0 61       	brne	8000af6a <__sfp+0x3e>
8000af60:	30 4b       	mov	r11,4
8000af62:	0c 9c       	mov	r12,r6
8000af64:	cd 0f       	rcall	8000af04 <__sfmoreglue>
8000af66:	8f 0c       	st.w	r7[0x0],r12
8000af68:	c0 30       	breq	8000af6e <__sfp+0x42>
8000af6a:	6e 07       	ld.w	r7,r7[0x0]
8000af6c:	ce db       	rjmp	8000af46 <__sfp+0x1a>
8000af6e:	30 c8       	mov	r8,12
8000af70:	8d 38       	st.w	r6[0xc],r8
8000af72:	d8 22       	popm	r4-r7,pc
8000af74:	30 08       	mov	r8,0
8000af76:	f9 48 00 4c 	st.w	r12[76],r8
8000af7a:	99 08       	st.w	r12[0x0],r8
8000af7c:	99 28       	st.w	r12[0x8],r8
8000af7e:	99 18       	st.w	r12[0x4],r8
8000af80:	99 48       	st.w	r12[0x10],r8
8000af82:	99 58       	st.w	r12[0x14],r8
8000af84:	99 68       	st.w	r12[0x18],r8
8000af86:	99 d8       	st.w	r12[0x34],r8
8000af88:	99 e8       	st.w	r12[0x38],r8
8000af8a:	f9 48 00 48 	st.w	r12[72],r8
8000af8e:	3f f8       	mov	r8,-1
8000af90:	b8 78       	st.h	r12[0xe],r8
8000af92:	30 18       	mov	r8,1
8000af94:	b8 68       	st.h	r12[0xc],r8
8000af96:	d8 22       	popm	r4-r7,pc

8000af98 <__sinit>:
8000af98:	d4 21       	pushm	r4-r7,lr
8000af9a:	18 96       	mov	r6,r12
8000af9c:	78 67       	ld.w	r7,r12[0x18]
8000af9e:	58 07       	cp.w	r7,0
8000afa0:	c4 91       	brne	8000b032 <__sinit+0x9a>
8000afa2:	fe c8 00 aa 	sub	r8,pc,170
8000afa6:	30 15       	mov	r5,1
8000afa8:	99 a8       	st.w	r12[0x28],r8
8000afaa:	f9 47 00 d8 	st.w	r12[216],r7
8000afae:	f9 47 00 dc 	st.w	r12[220],r7
8000afb2:	f9 47 00 e0 	st.w	r12[224],r7
8000afb6:	99 65       	st.w	r12[0x18],r5
8000afb8:	cb af       	rcall	8000af2c <__sfp>
8000afba:	8d 0c       	st.w	r6[0x0],r12
8000afbc:	0c 9c       	mov	r12,r6
8000afbe:	cb 7f       	rcall	8000af2c <__sfp>
8000afc0:	8d 1c       	st.w	r6[0x4],r12
8000afc2:	0c 9c       	mov	r12,r6
8000afc4:	cb 4f       	rcall	8000af2c <__sfp>
8000afc6:	6c 09       	ld.w	r9,r6[0x0]
8000afc8:	30 48       	mov	r8,4
8000afca:	93 07       	st.w	r9[0x0],r7
8000afcc:	b2 68       	st.h	r9[0xc],r8
8000afce:	93 17       	st.w	r9[0x4],r7
8000afd0:	93 27       	st.w	r9[0x8],r7
8000afd2:	6c 18       	ld.w	r8,r6[0x4]
8000afd4:	b2 77       	st.h	r9[0xe],r7
8000afd6:	93 47       	st.w	r9[0x10],r7
8000afd8:	93 57       	st.w	r9[0x14],r7
8000afda:	93 67       	st.w	r9[0x18],r7
8000afdc:	93 89       	st.w	r9[0x20],r9
8000afde:	91 07       	st.w	r8[0x0],r7
8000afe0:	91 17       	st.w	r8[0x4],r7
8000afe2:	91 27       	st.w	r8[0x8],r7
8000afe4:	fe ce f3 24 	sub	lr,pc,-3292
8000afe8:	fe cb f3 54 	sub	r11,pc,-3244
8000afec:	93 9e       	st.w	r9[0x24],lr
8000afee:	93 ab       	st.w	r9[0x28],r11
8000aff0:	fe ca f3 7c 	sub	r10,pc,-3204
8000aff4:	fe c4 f3 88 	sub	r4,pc,-3192
8000aff8:	93 ba       	st.w	r9[0x2c],r10
8000affa:	93 c4       	st.w	r9[0x30],r4
8000affc:	30 99       	mov	r9,9
8000affe:	b0 69       	st.h	r8[0xc],r9
8000b000:	b0 75       	st.h	r8[0xe],r5
8000b002:	91 c4       	st.w	r8[0x30],r4
8000b004:	91 47       	st.w	r8[0x10],r7
8000b006:	91 57       	st.w	r8[0x14],r7
8000b008:	91 67       	st.w	r8[0x18],r7
8000b00a:	91 88       	st.w	r8[0x20],r8
8000b00c:	91 9e       	st.w	r8[0x24],lr
8000b00e:	91 ab       	st.w	r8[0x28],r11
8000b010:	91 ba       	st.w	r8[0x2c],r10
8000b012:	8d 2c       	st.w	r6[0x8],r12
8000b014:	31 28       	mov	r8,18
8000b016:	99 07       	st.w	r12[0x0],r7
8000b018:	b8 68       	st.h	r12[0xc],r8
8000b01a:	99 17       	st.w	r12[0x4],r7
8000b01c:	99 27       	st.w	r12[0x8],r7
8000b01e:	30 28       	mov	r8,2
8000b020:	b8 78       	st.h	r12[0xe],r8
8000b022:	99 c4       	st.w	r12[0x30],r4
8000b024:	99 67       	st.w	r12[0x18],r7
8000b026:	99 9e       	st.w	r12[0x24],lr
8000b028:	99 ab       	st.w	r12[0x28],r11
8000b02a:	99 ba       	st.w	r12[0x2c],r10
8000b02c:	99 47       	st.w	r12[0x10],r7
8000b02e:	99 57       	st.w	r12[0x14],r7
8000b030:	99 8c       	st.w	r12[0x20],r12
8000b032:	d8 22       	popm	r4-r7,pc

8000b034 <_malloc_trim_r>:
8000b034:	d4 21       	pushm	r4-r7,lr
8000b036:	16 95       	mov	r5,r11
8000b038:	18 97       	mov	r7,r12
8000b03a:	fe b0 d7 a9 	rcall	80005f8c <__malloc_lock>
8000b03e:	e0 64 05 40 	mov	r4,1344
8000b042:	68 28       	ld.w	r8,r4[0x8]
8000b044:	70 16       	ld.w	r6,r8[0x4]
8000b046:	e0 16 ff fc 	andl	r6,0xfffc
8000b04a:	ec c8 ff 91 	sub	r8,r6,-111
8000b04e:	f0 05 01 05 	sub	r5,r8,r5
8000b052:	e0 15 ff 80 	andl	r5,0xff80
8000b056:	ea c5 00 80 	sub	r5,r5,128
8000b05a:	e0 45 00 7f 	cp.w	r5,127
8000b05e:	e0 8a 00 25 	brle	8000b0a8 <_malloc_trim_r+0x74>
8000b062:	30 0b       	mov	r11,0
8000b064:	0e 9c       	mov	r12,r7
8000b066:	fe b0 e6 05 	rcall	80007c70 <_sbrk_r>
8000b06a:	68 28       	ld.w	r8,r4[0x8]
8000b06c:	0c 08       	add	r8,r6
8000b06e:	10 3c       	cp.w	r12,r8
8000b070:	c1 c1       	brne	8000b0a8 <_malloc_trim_r+0x74>
8000b072:	ea 0b 11 00 	rsub	r11,r5,0
8000b076:	0e 9c       	mov	r12,r7
8000b078:	fe b0 e5 fc 	rcall	80007c70 <_sbrk_r>
8000b07c:	5b fc       	cp.w	r12,-1
8000b07e:	c1 91       	brne	8000b0b0 <_malloc_trim_r+0x7c>
8000b080:	30 0b       	mov	r11,0
8000b082:	0e 9c       	mov	r12,r7
8000b084:	fe b0 e5 f6 	rcall	80007c70 <_sbrk_r>
8000b088:	68 28       	ld.w	r8,r4[0x8]
8000b08a:	f8 08 01 09 	sub	r9,r12,r8
8000b08e:	58 f9       	cp.w	r9,15
8000b090:	e0 8a 00 0c 	brle	8000b0a8 <_malloc_trim_r+0x74>
8000b094:	a1 a9       	sbr	r9,0x0
8000b096:	91 19       	st.w	r8[0x4],r9
8000b098:	e0 68 09 4c 	mov	r8,2380
8000b09c:	70 09       	ld.w	r9,r8[0x0]
8000b09e:	e0 68 0d 6c 	mov	r8,3436
8000b0a2:	f8 09 01 09 	sub	r9,r12,r9
8000b0a6:	91 09       	st.w	r8[0x0],r9
8000b0a8:	0e 9c       	mov	r12,r7
8000b0aa:	fe b0 d7 77 	rcall	80005f98 <__malloc_unlock>
8000b0ae:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0b0:	68 28       	ld.w	r8,r4[0x8]
8000b0b2:	0a 16       	sub	r6,r5
8000b0b4:	a1 a6       	sbr	r6,0x0
8000b0b6:	91 16       	st.w	r8[0x4],r6
8000b0b8:	e0 68 0d 6c 	mov	r8,3436
8000b0bc:	70 09       	ld.w	r9,r8[0x0]
8000b0be:	0a 19       	sub	r9,r5
8000b0c0:	0e 9c       	mov	r12,r7
8000b0c2:	91 09       	st.w	r8[0x0],r9
8000b0c4:	fe b0 d7 6a 	rcall	80005f98 <__malloc_unlock>
8000b0c8:	da 2a       	popm	r4-r7,pc,r12=1
8000b0ca:	d7 03       	nop

8000b0cc <_free_r>:
8000b0cc:	d4 21       	pushm	r4-r7,lr
8000b0ce:	16 96       	mov	r6,r11
8000b0d0:	18 97       	mov	r7,r12
8000b0d2:	58 0b       	cp.w	r11,0
8000b0d4:	e0 80 00 c0 	breq	8000b254 <_free_r+0x188>
8000b0d8:	fe b0 d7 5a 	rcall	80005f8c <__malloc_lock>
8000b0dc:	20 86       	sub	r6,8
8000b0de:	e0 6a 05 40 	mov	r10,1344
8000b0e2:	6c 18       	ld.w	r8,r6[0x4]
8000b0e4:	74 2e       	ld.w	lr,r10[0x8]
8000b0e6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b0ea:	a1 c8       	cbr	r8,0x0
8000b0ec:	ec 08 00 09 	add	r9,r6,r8
8000b0f0:	72 1b       	ld.w	r11,r9[0x4]
8000b0f2:	e0 1b ff fc 	andl	r11,0xfffc
8000b0f6:	1c 39       	cp.w	r9,lr
8000b0f8:	c1 e1       	brne	8000b134 <_free_r+0x68>
8000b0fa:	f6 08 00 08 	add	r8,r11,r8
8000b0fe:	58 0c       	cp.w	r12,0
8000b100:	c0 81       	brne	8000b110 <_free_r+0x44>
8000b102:	6c 09       	ld.w	r9,r6[0x0]
8000b104:	12 16       	sub	r6,r9
8000b106:	12 08       	add	r8,r9
8000b108:	6c 3b       	ld.w	r11,r6[0xc]
8000b10a:	6c 29       	ld.w	r9,r6[0x8]
8000b10c:	97 29       	st.w	r11[0x8],r9
8000b10e:	93 3b       	st.w	r9[0xc],r11
8000b110:	10 99       	mov	r9,r8
8000b112:	95 26       	st.w	r10[0x8],r6
8000b114:	a1 a9       	sbr	r9,0x0
8000b116:	8d 19       	st.w	r6[0x4],r9
8000b118:	e0 69 09 48 	mov	r9,2376
8000b11c:	72 09       	ld.w	r9,r9[0x0]
8000b11e:	12 38       	cp.w	r8,r9
8000b120:	c0 63       	brcs	8000b12c <_free_r+0x60>
8000b122:	e0 68 0d 68 	mov	r8,3432
8000b126:	0e 9c       	mov	r12,r7
8000b128:	70 0b       	ld.w	r11,r8[0x0]
8000b12a:	c8 5f       	rcall	8000b034 <_malloc_trim_r>
8000b12c:	0e 9c       	mov	r12,r7
8000b12e:	fe b0 d7 35 	rcall	80005f98 <__malloc_unlock>
8000b132:	d8 22       	popm	r4-r7,pc
8000b134:	93 1b       	st.w	r9[0x4],r11
8000b136:	58 0c       	cp.w	r12,0
8000b138:	c0 30       	breq	8000b13e <_free_r+0x72>
8000b13a:	30 0c       	mov	r12,0
8000b13c:	c1 08       	rjmp	8000b15c <_free_r+0x90>
8000b13e:	6c 0e       	ld.w	lr,r6[0x0]
8000b140:	f4 c5 ff f8 	sub	r5,r10,-8
8000b144:	1c 16       	sub	r6,lr
8000b146:	1c 08       	add	r8,lr
8000b148:	6c 2e       	ld.w	lr,r6[0x8]
8000b14a:	0a 3e       	cp.w	lr,r5
8000b14c:	f9 bc 00 01 	moveq	r12,1
8000b150:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b154:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b158:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b15c:	f2 0b 00 0e 	add	lr,r9,r11
8000b160:	7c 1e       	ld.w	lr,lr[0x4]
8000b162:	ed be 00 00 	bld	lr,0x0
8000b166:	c1 40       	breq	8000b18e <_free_r+0xc2>
8000b168:	16 08       	add	r8,r11
8000b16a:	58 0c       	cp.w	r12,0
8000b16c:	c0 d1       	brne	8000b186 <_free_r+0xba>
8000b16e:	e0 6e 05 40 	mov	lr,1344
8000b172:	72 2b       	ld.w	r11,r9[0x8]
8000b174:	2f 8e       	sub	lr,-8
8000b176:	1c 3b       	cp.w	r11,lr
8000b178:	c0 71       	brne	8000b186 <_free_r+0xba>
8000b17a:	97 36       	st.w	r11[0xc],r6
8000b17c:	97 26       	st.w	r11[0x8],r6
8000b17e:	8d 2b       	st.w	r6[0x8],r11
8000b180:	8d 3b       	st.w	r6[0xc],r11
8000b182:	30 1c       	mov	r12,1
8000b184:	c0 58       	rjmp	8000b18e <_free_r+0xc2>
8000b186:	72 2b       	ld.w	r11,r9[0x8]
8000b188:	72 39       	ld.w	r9,r9[0xc]
8000b18a:	93 2b       	st.w	r9[0x8],r11
8000b18c:	97 39       	st.w	r11[0xc],r9
8000b18e:	10 99       	mov	r9,r8
8000b190:	ec 08 09 08 	st.w	r6[r8],r8
8000b194:	a1 a9       	sbr	r9,0x0
8000b196:	8d 19       	st.w	r6[0x4],r9
8000b198:	58 0c       	cp.w	r12,0
8000b19a:	c5 a1       	brne	8000b24e <_free_r+0x182>
8000b19c:	e0 48 01 ff 	cp.w	r8,511
8000b1a0:	e0 8b 00 13 	brhi	8000b1c6 <_free_r+0xfa>
8000b1a4:	a3 98       	lsr	r8,0x3
8000b1a6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b1aa:	72 2b       	ld.w	r11,r9[0x8]
8000b1ac:	8d 39       	st.w	r6[0xc],r9
8000b1ae:	8d 2b       	st.w	r6[0x8],r11
8000b1b0:	97 36       	st.w	r11[0xc],r6
8000b1b2:	93 26       	st.w	r9[0x8],r6
8000b1b4:	a3 48       	asr	r8,0x2
8000b1b6:	74 19       	ld.w	r9,r10[0x4]
8000b1b8:	30 1b       	mov	r11,1
8000b1ba:	f6 08 09 48 	lsl	r8,r11,r8
8000b1be:	f3 e8 10 08 	or	r8,r9,r8
8000b1c2:	95 18       	st.w	r10[0x4],r8
8000b1c4:	c4 58       	rjmp	8000b24e <_free_r+0x182>
8000b1c6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b1ca:	58 4b       	cp.w	r11,4
8000b1cc:	e0 8b 00 06 	brhi	8000b1d8 <_free_r+0x10c>
8000b1d0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b1d4:	2c 8b       	sub	r11,-56
8000b1d6:	c2 08       	rjmp	8000b216 <_free_r+0x14a>
8000b1d8:	59 4b       	cp.w	r11,20
8000b1da:	e0 8b 00 04 	brhi	8000b1e2 <_free_r+0x116>
8000b1de:	2a 5b       	sub	r11,-91
8000b1e0:	c1 b8       	rjmp	8000b216 <_free_r+0x14a>
8000b1e2:	e0 4b 00 54 	cp.w	r11,84
8000b1e6:	e0 8b 00 06 	brhi	8000b1f2 <_free_r+0x126>
8000b1ea:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b1ee:	29 2b       	sub	r11,-110
8000b1f0:	c1 38       	rjmp	8000b216 <_free_r+0x14a>
8000b1f2:	e0 4b 01 54 	cp.w	r11,340
8000b1f6:	e0 8b 00 06 	brhi	8000b202 <_free_r+0x136>
8000b1fa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b1fe:	28 9b       	sub	r11,-119
8000b200:	c0 b8       	rjmp	8000b216 <_free_r+0x14a>
8000b202:	e0 4b 05 54 	cp.w	r11,1364
8000b206:	e0 88 00 05 	brls	8000b210 <_free_r+0x144>
8000b20a:	37 eb       	mov	r11,126
8000b20c:	c0 58       	rjmp	8000b216 <_free_r+0x14a>
8000b20e:	d7 03       	nop
8000b210:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b214:	28 4b       	sub	r11,-124
8000b216:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b21a:	78 29       	ld.w	r9,r12[0x8]
8000b21c:	18 39       	cp.w	r9,r12
8000b21e:	c0 e1       	brne	8000b23a <_free_r+0x16e>
8000b220:	74 18       	ld.w	r8,r10[0x4]
8000b222:	a3 4b       	asr	r11,0x2
8000b224:	30 1c       	mov	r12,1
8000b226:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b22a:	f1 eb 10 0b 	or	r11,r8,r11
8000b22e:	12 98       	mov	r8,r9
8000b230:	95 1b       	st.w	r10[0x4],r11
8000b232:	c0 a8       	rjmp	8000b246 <_free_r+0x17a>
8000b234:	72 29       	ld.w	r9,r9[0x8]
8000b236:	18 39       	cp.w	r9,r12
8000b238:	c0 60       	breq	8000b244 <_free_r+0x178>
8000b23a:	72 1a       	ld.w	r10,r9[0x4]
8000b23c:	e0 1a ff fc 	andl	r10,0xfffc
8000b240:	14 38       	cp.w	r8,r10
8000b242:	cf 93       	brcs	8000b234 <_free_r+0x168>
8000b244:	72 38       	ld.w	r8,r9[0xc]
8000b246:	8d 38       	st.w	r6[0xc],r8
8000b248:	8d 29       	st.w	r6[0x8],r9
8000b24a:	93 36       	st.w	r9[0xc],r6
8000b24c:	91 26       	st.w	r8[0x8],r6
8000b24e:	0e 9c       	mov	r12,r7
8000b250:	fe b0 d6 a4 	rcall	80005f98 <__malloc_unlock>
8000b254:	d8 22       	popm	r4-r7,pc
8000b256:	d7 03       	nop

8000b258 <__sfvwrite_r>:
8000b258:	d4 31       	pushm	r0-r7,lr
8000b25a:	20 3d       	sub	sp,12
8000b25c:	14 94       	mov	r4,r10
8000b25e:	18 95       	mov	r5,r12
8000b260:	16 97       	mov	r7,r11
8000b262:	74 28       	ld.w	r8,r10[0x8]
8000b264:	58 08       	cp.w	r8,0
8000b266:	e0 80 01 40 	breq	8000b4e6 <__sfvwrite_r+0x28e>
8000b26a:	96 68       	ld.sh	r8,r11[0xc]
8000b26c:	ed b8 00 03 	bld	r8,0x3
8000b270:	c0 41       	brne	8000b278 <__sfvwrite_r+0x20>
8000b272:	76 48       	ld.w	r8,r11[0x10]
8000b274:	58 08       	cp.w	r8,0
8000b276:	c0 c1       	brne	8000b28e <__sfvwrite_r+0x36>
8000b278:	0e 9b       	mov	r11,r7
8000b27a:	0a 9c       	mov	r12,r5
8000b27c:	fe b0 f6 c4 	rcall	8000a004 <__swsetup_r>
8000b280:	c0 70       	breq	8000b28e <__sfvwrite_r+0x36>
8000b282:	8e 68       	ld.sh	r8,r7[0xc]
8000b284:	a7 a8       	sbr	r8,0x6
8000b286:	ae 68       	st.h	r7[0xc],r8
8000b288:	30 98       	mov	r8,9
8000b28a:	8b 38       	st.w	r5[0xc],r8
8000b28c:	c2 b9       	rjmp	8000b4e2 <__sfvwrite_r+0x28a>
8000b28e:	8e 63       	ld.sh	r3,r7[0xc]
8000b290:	68 00       	ld.w	r0,r4[0x0]
8000b292:	06 96       	mov	r6,r3
8000b294:	e2 16 00 02 	andl	r6,0x2,COH
8000b298:	c2 10       	breq	8000b2da <__sfvwrite_r+0x82>
8000b29a:	30 03       	mov	r3,0
8000b29c:	e0 62 04 00 	mov	r2,1024
8000b2a0:	06 96       	mov	r6,r3
8000b2a2:	c0 48       	rjmp	8000b2aa <__sfvwrite_r+0x52>
8000b2a4:	60 03       	ld.w	r3,r0[0x0]
8000b2a6:	60 16       	ld.w	r6,r0[0x4]
8000b2a8:	2f 80       	sub	r0,-8
8000b2aa:	58 06       	cp.w	r6,0
8000b2ac:	cf c0       	breq	8000b2a4 <__sfvwrite_r+0x4c>
8000b2ae:	e0 46 04 00 	cp.w	r6,1024
8000b2b2:	ec 09 17 80 	movls	r9,r6
8000b2b6:	e4 09 17 b0 	movhi	r9,r2
8000b2ba:	06 9a       	mov	r10,r3
8000b2bc:	6e a8       	ld.w	r8,r7[0x28]
8000b2be:	6e 8b       	ld.w	r11,r7[0x20]
8000b2c0:	0a 9c       	mov	r12,r5
8000b2c2:	5d 18       	icall	r8
8000b2c4:	18 16       	sub	r6,r12
8000b2c6:	58 0c       	cp.w	r12,0
8000b2c8:	e0 8a 01 0a 	brle	8000b4dc <__sfvwrite_r+0x284>
8000b2cc:	68 28       	ld.w	r8,r4[0x8]
8000b2ce:	18 18       	sub	r8,r12
8000b2d0:	89 28       	st.w	r4[0x8],r8
8000b2d2:	e0 80 01 0a 	breq	8000b4e6 <__sfvwrite_r+0x28e>
8000b2d6:	18 03       	add	r3,r12
8000b2d8:	ce 9b       	rjmp	8000b2aa <__sfvwrite_r+0x52>
8000b2da:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b2de:	c0 70       	breq	8000b2ec <__sfvwrite_r+0x94>
8000b2e0:	50 06       	stdsp	sp[0x0],r6
8000b2e2:	0c 93       	mov	r3,r6
8000b2e4:	0c 91       	mov	r1,r6
8000b2e6:	50 15       	stdsp	sp[0x4],r5
8000b2e8:	08 92       	mov	r2,r4
8000b2ea:	c9 c8       	rjmp	8000b422 <__sfvwrite_r+0x1ca>
8000b2ec:	06 96       	mov	r6,r3
8000b2ee:	08 91       	mov	r1,r4
8000b2f0:	c0 48       	rjmp	8000b2f8 <__sfvwrite_r+0xa0>
8000b2f2:	60 03       	ld.w	r3,r0[0x0]
8000b2f4:	60 16       	ld.w	r6,r0[0x4]
8000b2f6:	2f 80       	sub	r0,-8
8000b2f8:	58 06       	cp.w	r6,0
8000b2fa:	cf c0       	breq	8000b2f2 <__sfvwrite_r+0x9a>
8000b2fc:	8e 68       	ld.sh	r8,r7[0xc]
8000b2fe:	6e 24       	ld.w	r4,r7[0x8]
8000b300:	10 99       	mov	r9,r8
8000b302:	e2 19 02 00 	andl	r9,0x200,COH
8000b306:	c5 50       	breq	8000b3b0 <__sfvwrite_r+0x158>
8000b308:	08 36       	cp.w	r6,r4
8000b30a:	c4 43       	brcs	8000b392 <__sfvwrite_r+0x13a>
8000b30c:	10 99       	mov	r9,r8
8000b30e:	e2 19 04 80 	andl	r9,0x480,COH
8000b312:	c4 00       	breq	8000b392 <__sfvwrite_r+0x13a>
8000b314:	6e 4b       	ld.w	r11,r7[0x10]
8000b316:	6e 09       	ld.w	r9,r7[0x0]
8000b318:	16 19       	sub	r9,r11
8000b31a:	50 09       	stdsp	sp[0x0],r9
8000b31c:	6e 59       	ld.w	r9,r7[0x14]
8000b31e:	10 9c       	mov	r12,r8
8000b320:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b324:	30 28       	mov	r8,2
8000b326:	f4 08 0c 08 	divs	r8,r10,r8
8000b32a:	fa e9 00 04 	st.d	sp[4],r8
8000b32e:	10 94       	mov	r4,r8
8000b330:	40 09       	lddsp	r9,sp[0x0]
8000b332:	e2 1c 04 00 	andl	r12,0x400,COH
8000b336:	2f f9       	sub	r9,-1
8000b338:	0c 09       	add	r9,r6
8000b33a:	12 38       	cp.w	r8,r9
8000b33c:	f2 04 17 30 	movlo	r4,r9
8000b340:	58 0c       	cp.w	r12,0
8000b342:	c1 10       	breq	8000b364 <__sfvwrite_r+0x10c>
8000b344:	08 9b       	mov	r11,r4
8000b346:	0a 9c       	mov	r12,r5
8000b348:	fe b0 e0 6c 	rcall	80007420 <_malloc_r>
8000b34c:	18 92       	mov	r2,r12
8000b34e:	c1 40       	breq	8000b376 <__sfvwrite_r+0x11e>
8000b350:	40 0a       	lddsp	r10,sp[0x0]
8000b352:	6e 4b       	ld.w	r11,r7[0x10]
8000b354:	fe b0 e2 82 	rcall	80007858 <memcpy>
8000b358:	8e 68       	ld.sh	r8,r7[0xc]
8000b35a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b35e:	a7 b8       	sbr	r8,0x7
8000b360:	ae 68       	st.h	r7[0xc],r8
8000b362:	c0 d8       	rjmp	8000b37c <__sfvwrite_r+0x124>
8000b364:	08 9a       	mov	r10,r4
8000b366:	0a 9c       	mov	r12,r5
8000b368:	fe b0 e3 24 	rcall	800079b0 <_realloc_r>
8000b36c:	18 92       	mov	r2,r12
8000b36e:	c0 71       	brne	8000b37c <__sfvwrite_r+0x124>
8000b370:	6e 4b       	ld.w	r11,r7[0x10]
8000b372:	0a 9c       	mov	r12,r5
8000b374:	ca ce       	rcall	8000b0cc <_free_r>
8000b376:	30 c8       	mov	r8,12
8000b378:	8b 38       	st.w	r5[0xc],r8
8000b37a:	cb 18       	rjmp	8000b4dc <__sfvwrite_r+0x284>
8000b37c:	40 0a       	lddsp	r10,sp[0x0]
8000b37e:	40 09       	lddsp	r9,sp[0x0]
8000b380:	e8 0a 01 0a 	sub	r10,r4,r10
8000b384:	e4 09 00 08 	add	r8,r2,r9
8000b388:	8f 54       	st.w	r7[0x14],r4
8000b38a:	8f 2a       	st.w	r7[0x8],r10
8000b38c:	8f 08       	st.w	r7[0x0],r8
8000b38e:	8f 42       	st.w	r7[0x10],r2
8000b390:	0c 94       	mov	r4,r6
8000b392:	08 36       	cp.w	r6,r4
8000b394:	ec 04 17 30 	movlo	r4,r6
8000b398:	06 9b       	mov	r11,r3
8000b39a:	08 9a       	mov	r10,r4
8000b39c:	6e 0c       	ld.w	r12,r7[0x0]
8000b39e:	c3 ad       	rcall	8000b612 <memmove>
8000b3a0:	6e 08       	ld.w	r8,r7[0x0]
8000b3a2:	08 08       	add	r8,r4
8000b3a4:	8f 08       	st.w	r7[0x0],r8
8000b3a6:	6e 28       	ld.w	r8,r7[0x8]
8000b3a8:	08 18       	sub	r8,r4
8000b3aa:	0c 94       	mov	r4,r6
8000b3ac:	8f 28       	st.w	r7[0x8],r8
8000b3ae:	c2 e8       	rjmp	8000b40a <__sfvwrite_r+0x1b2>
8000b3b0:	08 36       	cp.w	r6,r4
8000b3b2:	5f ba       	srhi	r10
8000b3b4:	6e 0c       	ld.w	r12,r7[0x0]
8000b3b6:	6e 48       	ld.w	r8,r7[0x10]
8000b3b8:	10 3c       	cp.w	r12,r8
8000b3ba:	5f b8       	srhi	r8
8000b3bc:	f5 e8 00 08 	and	r8,r10,r8
8000b3c0:	f2 08 18 00 	cp.b	r8,r9
8000b3c4:	c0 d0       	breq	8000b3de <__sfvwrite_r+0x186>
8000b3c6:	06 9b       	mov	r11,r3
8000b3c8:	08 9a       	mov	r10,r4
8000b3ca:	c2 4d       	rcall	8000b612 <memmove>
8000b3cc:	6e 08       	ld.w	r8,r7[0x0]
8000b3ce:	08 08       	add	r8,r4
8000b3d0:	0e 9b       	mov	r11,r7
8000b3d2:	8f 08       	st.w	r7[0x0],r8
8000b3d4:	0a 9c       	mov	r12,r5
8000b3d6:	fe b0 fd 09 	rcall	8000ade8 <_fflush_r>
8000b3da:	c1 80       	breq	8000b40a <__sfvwrite_r+0x1b2>
8000b3dc:	c8 08       	rjmp	8000b4dc <__sfvwrite_r+0x284>
8000b3de:	6e 59       	ld.w	r9,r7[0x14]
8000b3e0:	12 36       	cp.w	r6,r9
8000b3e2:	c0 a3       	brcs	8000b3f6 <__sfvwrite_r+0x19e>
8000b3e4:	6e a8       	ld.w	r8,r7[0x28]
8000b3e6:	06 9a       	mov	r10,r3
8000b3e8:	6e 8b       	ld.w	r11,r7[0x20]
8000b3ea:	0a 9c       	mov	r12,r5
8000b3ec:	5d 18       	icall	r8
8000b3ee:	18 94       	mov	r4,r12
8000b3f0:	e0 89 00 0d 	brgt	8000b40a <__sfvwrite_r+0x1b2>
8000b3f4:	c7 48       	rjmp	8000b4dc <__sfvwrite_r+0x284>
8000b3f6:	0c 9a       	mov	r10,r6
8000b3f8:	06 9b       	mov	r11,r3
8000b3fa:	c0 cd       	rcall	8000b612 <memmove>
8000b3fc:	6e 08       	ld.w	r8,r7[0x0]
8000b3fe:	0c 08       	add	r8,r6
8000b400:	0c 94       	mov	r4,r6
8000b402:	8f 08       	st.w	r7[0x0],r8
8000b404:	6e 28       	ld.w	r8,r7[0x8]
8000b406:	0c 18       	sub	r8,r6
8000b408:	8f 28       	st.w	r7[0x8],r8
8000b40a:	62 28       	ld.w	r8,r1[0x8]
8000b40c:	08 18       	sub	r8,r4
8000b40e:	83 28       	st.w	r1[0x8],r8
8000b410:	c6 b0       	breq	8000b4e6 <__sfvwrite_r+0x28e>
8000b412:	08 16       	sub	r6,r4
8000b414:	08 03       	add	r3,r4
8000b416:	c7 1b       	rjmp	8000b2f8 <__sfvwrite_r+0xa0>
8000b418:	60 03       	ld.w	r3,r0[0x0]
8000b41a:	60 11       	ld.w	r1,r0[0x4]
8000b41c:	30 08       	mov	r8,0
8000b41e:	2f 80       	sub	r0,-8
8000b420:	50 08       	stdsp	sp[0x0],r8
8000b422:	58 01       	cp.w	r1,0
8000b424:	cf a0       	breq	8000b418 <__sfvwrite_r+0x1c0>
8000b426:	40 0a       	lddsp	r10,sp[0x0]
8000b428:	58 0a       	cp.w	r10,0
8000b42a:	c1 41       	brne	8000b452 <__sfvwrite_r+0x1fa>
8000b42c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b430:	02 9a       	mov	r10,r1
8000b432:	30 ab       	mov	r11,10
8000b434:	06 9c       	mov	r12,r3
8000b436:	ce 3c       	rcall	8000b5fc <memchr>
8000b438:	f8 c8 ff ff 	sub	r8,r12,-1
8000b43c:	58 0c       	cp.w	r12,0
8000b43e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b442:	f9 b9 01 01 	movne	r9,1
8000b446:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b44a:	f9 b8 00 01 	moveq	r8,1
8000b44e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b452:	02 36       	cp.w	r6,r1
8000b454:	ec 04 17 80 	movls	r4,r6
8000b458:	e2 04 17 b0 	movhi	r4,r1
8000b45c:	6e 59       	ld.w	r9,r7[0x14]
8000b45e:	6e 25       	ld.w	r5,r7[0x8]
8000b460:	f2 05 00 05 	add	r5,r9,r5
8000b464:	0a 34       	cp.w	r4,r5
8000b466:	5f 9a       	srgt	r10
8000b468:	6e 0c       	ld.w	r12,r7[0x0]
8000b46a:	6e 48       	ld.w	r8,r7[0x10]
8000b46c:	10 3c       	cp.w	r12,r8
8000b46e:	5f b8       	srhi	r8
8000b470:	f5 e8 00 08 	and	r8,r10,r8
8000b474:	30 0a       	mov	r10,0
8000b476:	f4 08 18 00 	cp.b	r8,r10
8000b47a:	c0 d0       	breq	8000b494 <__sfvwrite_r+0x23c>
8000b47c:	06 9b       	mov	r11,r3
8000b47e:	0a 9a       	mov	r10,r5
8000b480:	cc 9c       	rcall	8000b612 <memmove>
8000b482:	6e 08       	ld.w	r8,r7[0x0]
8000b484:	0a 08       	add	r8,r5
8000b486:	0e 9b       	mov	r11,r7
8000b488:	8f 08       	st.w	r7[0x0],r8
8000b48a:	40 1c       	lddsp	r12,sp[0x4]
8000b48c:	fe b0 fc ae 	rcall	8000ade8 <_fflush_r>
8000b490:	c1 70       	breq	8000b4be <__sfvwrite_r+0x266>
8000b492:	c2 58       	rjmp	8000b4dc <__sfvwrite_r+0x284>
8000b494:	12 34       	cp.w	r4,r9
8000b496:	c0 a5       	brlt	8000b4aa <__sfvwrite_r+0x252>
8000b498:	6e a8       	ld.w	r8,r7[0x28]
8000b49a:	06 9a       	mov	r10,r3
8000b49c:	6e 8b       	ld.w	r11,r7[0x20]
8000b49e:	40 1c       	lddsp	r12,sp[0x4]
8000b4a0:	5d 18       	icall	r8
8000b4a2:	18 95       	mov	r5,r12
8000b4a4:	e0 89 00 0d 	brgt	8000b4be <__sfvwrite_r+0x266>
8000b4a8:	c1 a8       	rjmp	8000b4dc <__sfvwrite_r+0x284>
8000b4aa:	08 9a       	mov	r10,r4
8000b4ac:	06 9b       	mov	r11,r3
8000b4ae:	cb 2c       	rcall	8000b612 <memmove>
8000b4b0:	6e 08       	ld.w	r8,r7[0x0]
8000b4b2:	08 08       	add	r8,r4
8000b4b4:	08 95       	mov	r5,r4
8000b4b6:	8f 08       	st.w	r7[0x0],r8
8000b4b8:	6e 28       	ld.w	r8,r7[0x8]
8000b4ba:	08 18       	sub	r8,r4
8000b4bc:	8f 28       	st.w	r7[0x8],r8
8000b4be:	0a 16       	sub	r6,r5
8000b4c0:	c0 71       	brne	8000b4ce <__sfvwrite_r+0x276>
8000b4c2:	0e 9b       	mov	r11,r7
8000b4c4:	40 1c       	lddsp	r12,sp[0x4]
8000b4c6:	fe b0 fc 91 	rcall	8000ade8 <_fflush_r>
8000b4ca:	c0 91       	brne	8000b4dc <__sfvwrite_r+0x284>
8000b4cc:	50 06       	stdsp	sp[0x0],r6
8000b4ce:	64 28       	ld.w	r8,r2[0x8]
8000b4d0:	0a 18       	sub	r8,r5
8000b4d2:	85 28       	st.w	r2[0x8],r8
8000b4d4:	c0 90       	breq	8000b4e6 <__sfvwrite_r+0x28e>
8000b4d6:	0a 11       	sub	r1,r5
8000b4d8:	0a 03       	add	r3,r5
8000b4da:	ca 4b       	rjmp	8000b422 <__sfvwrite_r+0x1ca>
8000b4dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b4de:	a7 a8       	sbr	r8,0x6
8000b4e0:	ae 68       	st.h	r7[0xc],r8
8000b4e2:	3f fc       	mov	r12,-1
8000b4e4:	c0 28       	rjmp	8000b4e8 <__sfvwrite_r+0x290>
8000b4e6:	30 0c       	mov	r12,0
8000b4e8:	2f dd       	sub	sp,-12
8000b4ea:	d8 32       	popm	r0-r7,pc

8000b4ec <_fwalk>:
8000b4ec:	d4 31       	pushm	r0-r7,lr
8000b4ee:	30 05       	mov	r5,0
8000b4f0:	16 91       	mov	r1,r11
8000b4f2:	f8 c7 ff 28 	sub	r7,r12,-216
8000b4f6:	0a 92       	mov	r2,r5
8000b4f8:	fe b0 fc fe 	rcall	8000aef4 <__sfp_lock_acquire>
8000b4fc:	3f f3       	mov	r3,-1
8000b4fe:	c1 68       	rjmp	8000b52a <_fwalk+0x3e>
8000b500:	6e 26       	ld.w	r6,r7[0x8]
8000b502:	6e 14       	ld.w	r4,r7[0x4]
8000b504:	2f 46       	sub	r6,-12
8000b506:	c0 c8       	rjmp	8000b51e <_fwalk+0x32>
8000b508:	8c 08       	ld.sh	r8,r6[0x0]
8000b50a:	e4 08 19 00 	cp.h	r8,r2
8000b50e:	c0 70       	breq	8000b51c <_fwalk+0x30>
8000b510:	8c 18       	ld.sh	r8,r6[0x2]
8000b512:	e6 08 19 00 	cp.h	r8,r3
8000b516:	c0 30       	breq	8000b51c <_fwalk+0x30>
8000b518:	5d 11       	icall	r1
8000b51a:	18 45       	or	r5,r12
8000b51c:	2a 46       	sub	r6,-92
8000b51e:	20 14       	sub	r4,1
8000b520:	ec cc 00 0c 	sub	r12,r6,12
8000b524:	58 04       	cp.w	r4,0
8000b526:	cf 14       	brge	8000b508 <_fwalk+0x1c>
8000b528:	6e 07       	ld.w	r7,r7[0x0]
8000b52a:	58 07       	cp.w	r7,0
8000b52c:	ce a1       	brne	8000b500 <_fwalk+0x14>
8000b52e:	fe b0 fc e4 	rcall	8000aef6 <__sfp_lock_release>
8000b532:	0a 9c       	mov	r12,r5
8000b534:	d8 32       	popm	r0-r7,pc
8000b536:	d7 03       	nop

8000b538 <_localeconv_r>:
8000b538:	fe cc d3 f4 	sub	r12,pc,-11276
8000b53c:	5e fc       	retal	r12
8000b53e:	d7 03       	nop

8000b540 <__smakebuf_r>:
8000b540:	d4 21       	pushm	r4-r7,lr
8000b542:	20 fd       	sub	sp,60
8000b544:	96 68       	ld.sh	r8,r11[0xc]
8000b546:	16 97       	mov	r7,r11
8000b548:	18 96       	mov	r6,r12
8000b54a:	e2 18 00 02 	andl	r8,0x2,COH
8000b54e:	c3 d1       	brne	8000b5c8 <__smakebuf_r+0x88>
8000b550:	96 7b       	ld.sh	r11,r11[0xe]
8000b552:	f0 0b 19 00 	cp.h	r11,r8
8000b556:	c0 55       	brlt	8000b560 <__smakebuf_r+0x20>
8000b558:	1a 9a       	mov	r10,sp
8000b55a:	e0 a0 04 81 	rcall	8000be5c <_fstat_r>
8000b55e:	c0 f4       	brge	8000b57c <__smakebuf_r+0x3c>
8000b560:	8e 65       	ld.sh	r5,r7[0xc]
8000b562:	0a 98       	mov	r8,r5
8000b564:	ab b8       	sbr	r8,0xb
8000b566:	e2 15 00 80 	andl	r5,0x80,COH
8000b56a:	ae 68       	st.h	r7[0xc],r8
8000b56c:	30 04       	mov	r4,0
8000b56e:	e0 68 04 00 	mov	r8,1024
8000b572:	f9 b5 01 40 	movne	r5,64
8000b576:	f0 05 17 00 	moveq	r5,r8
8000b57a:	c1 c8       	rjmp	8000b5b2 <__smakebuf_r+0x72>
8000b57c:	40 18       	lddsp	r8,sp[0x4]
8000b57e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b582:	e0 48 20 00 	cp.w	r8,8192
8000b586:	5f 04       	sreq	r4
8000b588:	e0 48 80 00 	cp.w	r8,32768
8000b58c:	c0 e1       	brne	8000b5a8 <__smakebuf_r+0x68>
8000b58e:	6e b9       	ld.w	r9,r7[0x2c]
8000b590:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b594:	10 39       	cp.w	r9,r8
8000b596:	c0 91       	brne	8000b5a8 <__smakebuf_r+0x68>
8000b598:	8e 68       	ld.sh	r8,r7[0xc]
8000b59a:	e0 65 04 00 	mov	r5,1024
8000b59e:	ab a8       	sbr	r8,0xa
8000b5a0:	ef 45 00 50 	st.w	r7[80],r5
8000b5a4:	ae 68       	st.h	r7[0xc],r8
8000b5a6:	c0 68       	rjmp	8000b5b2 <__smakebuf_r+0x72>
8000b5a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b5aa:	e0 65 04 00 	mov	r5,1024
8000b5ae:	ab b8       	sbr	r8,0xb
8000b5b0:	ae 68       	st.h	r7[0xc],r8
8000b5b2:	0a 9b       	mov	r11,r5
8000b5b4:	0c 9c       	mov	r12,r6
8000b5b6:	fe b0 df 35 	rcall	80007420 <_malloc_r>
8000b5ba:	8e 68       	ld.sh	r8,r7[0xc]
8000b5bc:	c0 d1       	brne	8000b5d6 <__smakebuf_r+0x96>
8000b5be:	ed b8 00 09 	bld	r8,0x9
8000b5c2:	c1 b0       	breq	8000b5f8 <__smakebuf_r+0xb8>
8000b5c4:	a1 b8       	sbr	r8,0x1
8000b5c6:	ae 68       	st.h	r7[0xc],r8
8000b5c8:	ee c8 ff b9 	sub	r8,r7,-71
8000b5cc:	8f 48       	st.w	r7[0x10],r8
8000b5ce:	8f 08       	st.w	r7[0x0],r8
8000b5d0:	30 18       	mov	r8,1
8000b5d2:	8f 58       	st.w	r7[0x14],r8
8000b5d4:	c1 28       	rjmp	8000b5f8 <__smakebuf_r+0xb8>
8000b5d6:	a7 b8       	sbr	r8,0x7
8000b5d8:	8f 4c       	st.w	r7[0x10],r12
8000b5da:	ae 68       	st.h	r7[0xc],r8
8000b5dc:	8f 55       	st.w	r7[0x14],r5
8000b5de:	fe c8 06 e6 	sub	r8,pc,1766
8000b5e2:	8f 0c       	st.w	r7[0x0],r12
8000b5e4:	8d a8       	st.w	r6[0x28],r8
8000b5e6:	58 04       	cp.w	r4,0
8000b5e8:	c0 80       	breq	8000b5f8 <__smakebuf_r+0xb8>
8000b5ea:	8e 7c       	ld.sh	r12,r7[0xe]
8000b5ec:	fe b0 e3 94 	rcall	80007d14 <isatty>
8000b5f0:	c0 40       	breq	8000b5f8 <__smakebuf_r+0xb8>
8000b5f2:	8e 68       	ld.sh	r8,r7[0xc]
8000b5f4:	a1 a8       	sbr	r8,0x0
8000b5f6:	ae 68       	st.h	r7[0xc],r8
8000b5f8:	2f 1d       	sub	sp,-60
8000b5fa:	d8 22       	popm	r4-r7,pc

8000b5fc <memchr>:
8000b5fc:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b600:	c0 68       	rjmp	8000b60c <memchr+0x10>
8000b602:	20 1a       	sub	r10,1
8000b604:	19 88       	ld.ub	r8,r12[0x0]
8000b606:	16 38       	cp.w	r8,r11
8000b608:	5e 0c       	reteq	r12
8000b60a:	2f fc       	sub	r12,-1
8000b60c:	58 0a       	cp.w	r10,0
8000b60e:	cf a1       	brne	8000b602 <memchr+0x6>
8000b610:	5e fa       	retal	r10

8000b612 <memmove>:
8000b612:	d4 01       	pushm	lr
8000b614:	18 3b       	cp.w	r11,r12
8000b616:	c1 92       	brcc	8000b648 <memmove+0x36>
8000b618:	f6 0a 00 09 	add	r9,r11,r10
8000b61c:	12 3c       	cp.w	r12,r9
8000b61e:	c1 52       	brcc	8000b648 <memmove+0x36>
8000b620:	f8 0a 00 0b 	add	r11,r12,r10
8000b624:	30 08       	mov	r8,0
8000b626:	c0 68       	rjmp	8000b632 <memmove+0x20>
8000b628:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b62c:	20 1a       	sub	r10,1
8000b62e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b632:	20 18       	sub	r8,1
8000b634:	58 0a       	cp.w	r10,0
8000b636:	cf 91       	brne	8000b628 <memmove+0x16>
8000b638:	d8 02       	popm	pc
8000b63a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b63e:	20 1a       	sub	r10,1
8000b640:	f8 08 0b 09 	st.b	r12[r8],r9
8000b644:	2f f8       	sub	r8,-1
8000b646:	c0 28       	rjmp	8000b64a <memmove+0x38>
8000b648:	30 08       	mov	r8,0
8000b64a:	58 0a       	cp.w	r10,0
8000b64c:	cf 71       	brne	8000b63a <memmove+0x28>
8000b64e:	d8 02       	popm	pc

8000b650 <__hi0bits>:
8000b650:	18 98       	mov	r8,r12
8000b652:	e0 1c 00 00 	andl	r12,0x0
8000b656:	f0 09 15 10 	lsl	r9,r8,0x10
8000b65a:	58 0c       	cp.w	r12,0
8000b65c:	f2 08 17 00 	moveq	r8,r9
8000b660:	f9 bc 00 10 	moveq	r12,16
8000b664:	f9 bc 01 00 	movne	r12,0
8000b668:	10 9a       	mov	r10,r8
8000b66a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b66e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b672:	f7 bc 00 f8 	subeq	r12,-8
8000b676:	f2 08 17 00 	moveq	r8,r9
8000b67a:	10 9a       	mov	r10,r8
8000b67c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b680:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b684:	f7 bc 00 fc 	subeq	r12,-4
8000b688:	f2 08 17 00 	moveq	r8,r9
8000b68c:	10 9a       	mov	r10,r8
8000b68e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b692:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b696:	f7 bc 00 fe 	subeq	r12,-2
8000b69a:	f2 08 17 00 	moveq	r8,r9
8000b69e:	58 08       	cp.w	r8,0
8000b6a0:	5e 5c       	retlt	r12
8000b6a2:	ed b8 00 1e 	bld	r8,0x1e
8000b6a6:	f9 bc 01 20 	movne	r12,32
8000b6aa:	f7 bc 00 ff 	subeq	r12,-1
8000b6ae:	5e fc       	retal	r12

8000b6b0 <__lo0bits>:
8000b6b0:	18 99       	mov	r9,r12
8000b6b2:	78 08       	ld.w	r8,r12[0x0]
8000b6b4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6b8:	c1 50       	breq	8000b6e2 <__lo0bits+0x32>
8000b6ba:	ed b8 00 00 	bld	r8,0x0
8000b6be:	c0 21       	brne	8000b6c2 <__lo0bits+0x12>
8000b6c0:	5e fd       	retal	0
8000b6c2:	10 9b       	mov	r11,r8
8000b6c4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b6c8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b6cc:	a3 88       	lsr	r8,0x2
8000b6ce:	58 0b       	cp.w	r11,0
8000b6d0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b6d4:	f9 bc 01 01 	movne	r12,1
8000b6d8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b6dc:	f9 bc 00 02 	moveq	r12,2
8000b6e0:	5e fc       	retal	r12
8000b6e2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b6e6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b6ea:	58 0a       	cp.w	r10,0
8000b6ec:	f6 08 17 00 	moveq	r8,r11
8000b6f0:	f9 bc 00 10 	moveq	r12,16
8000b6f4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b6f8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b6fc:	58 0b       	cp.w	r11,0
8000b6fe:	f7 bc 00 f8 	subeq	r12,-8
8000b702:	f4 08 17 00 	moveq	r8,r10
8000b706:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b70a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b70e:	58 0b       	cp.w	r11,0
8000b710:	f7 bc 00 fc 	subeq	r12,-4
8000b714:	f4 08 17 00 	moveq	r8,r10
8000b718:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b71c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b720:	58 0b       	cp.w	r11,0
8000b722:	f7 bc 00 fe 	subeq	r12,-2
8000b726:	f4 08 17 00 	moveq	r8,r10
8000b72a:	ed b8 00 00 	bld	r8,0x0
8000b72e:	c0 60       	breq	8000b73a <__lo0bits+0x8a>
8000b730:	a1 98       	lsr	r8,0x1
8000b732:	c0 31       	brne	8000b738 <__lo0bits+0x88>
8000b734:	32 0c       	mov	r12,32
8000b736:	5e fc       	retal	r12
8000b738:	2f fc       	sub	r12,-1
8000b73a:	93 08       	st.w	r9[0x0],r8
8000b73c:	5e fc       	retal	r12

8000b73e <__mcmp>:
8000b73e:	d4 01       	pushm	lr
8000b740:	18 98       	mov	r8,r12
8000b742:	76 49       	ld.w	r9,r11[0x10]
8000b744:	78 4c       	ld.w	r12,r12[0x10]
8000b746:	12 1c       	sub	r12,r9
8000b748:	c1 31       	brne	8000b76e <__mcmp+0x30>
8000b74a:	2f b9       	sub	r9,-5
8000b74c:	a3 69       	lsl	r9,0x2
8000b74e:	12 0b       	add	r11,r9
8000b750:	f0 09 00 09 	add	r9,r8,r9
8000b754:	2e c8       	sub	r8,-20
8000b756:	13 4e       	ld.w	lr,--r9
8000b758:	17 4a       	ld.w	r10,--r11
8000b75a:	14 3e       	cp.w	lr,r10
8000b75c:	c0 60       	breq	8000b768 <__mcmp+0x2a>
8000b75e:	f9 bc 03 ff 	movlo	r12,-1
8000b762:	f9 bc 02 01 	movhs	r12,1
8000b766:	d8 02       	popm	pc
8000b768:	10 39       	cp.w	r9,r8
8000b76a:	fe 9b ff f6 	brhi	8000b756 <__mcmp+0x18>
8000b76e:	d8 02       	popm	pc

8000b770 <_Bfree>:
8000b770:	d4 21       	pushm	r4-r7,lr
8000b772:	18 97       	mov	r7,r12
8000b774:	16 95       	mov	r5,r11
8000b776:	78 96       	ld.w	r6,r12[0x24]
8000b778:	58 06       	cp.w	r6,0
8000b77a:	c0 91       	brne	8000b78c <_Bfree+0x1c>
8000b77c:	31 0c       	mov	r12,16
8000b77e:	fe b0 de 49 	rcall	80007410 <malloc>
8000b782:	99 36       	st.w	r12[0xc],r6
8000b784:	8f 9c       	st.w	r7[0x24],r12
8000b786:	99 16       	st.w	r12[0x4],r6
8000b788:	99 26       	st.w	r12[0x8],r6
8000b78a:	99 06       	st.w	r12[0x0],r6
8000b78c:	58 05       	cp.w	r5,0
8000b78e:	c0 90       	breq	8000b7a0 <_Bfree+0x30>
8000b790:	6a 19       	ld.w	r9,r5[0x4]
8000b792:	6e 98       	ld.w	r8,r7[0x24]
8000b794:	70 38       	ld.w	r8,r8[0xc]
8000b796:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b79a:	8b 0a       	st.w	r5[0x0],r10
8000b79c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b7a0:	d8 22       	popm	r4-r7,pc
8000b7a2:	d7 03       	nop

8000b7a4 <_Balloc>:
8000b7a4:	d4 21       	pushm	r4-r7,lr
8000b7a6:	18 97       	mov	r7,r12
8000b7a8:	16 96       	mov	r6,r11
8000b7aa:	78 95       	ld.w	r5,r12[0x24]
8000b7ac:	58 05       	cp.w	r5,0
8000b7ae:	c0 91       	brne	8000b7c0 <_Balloc+0x1c>
8000b7b0:	31 0c       	mov	r12,16
8000b7b2:	fe b0 de 2f 	rcall	80007410 <malloc>
8000b7b6:	99 35       	st.w	r12[0xc],r5
8000b7b8:	8f 9c       	st.w	r7[0x24],r12
8000b7ba:	99 15       	st.w	r12[0x4],r5
8000b7bc:	99 25       	st.w	r12[0x8],r5
8000b7be:	99 05       	st.w	r12[0x0],r5
8000b7c0:	6e 95       	ld.w	r5,r7[0x24]
8000b7c2:	6a 38       	ld.w	r8,r5[0xc]
8000b7c4:	58 08       	cp.w	r8,0
8000b7c6:	c0 b1       	brne	8000b7dc <_Balloc+0x38>
8000b7c8:	31 0a       	mov	r10,16
8000b7ca:	30 4b       	mov	r11,4
8000b7cc:	0e 9c       	mov	r12,r7
8000b7ce:	e0 a0 02 a7 	rcall	8000bd1c <_calloc_r>
8000b7d2:	8b 3c       	st.w	r5[0xc],r12
8000b7d4:	6e 98       	ld.w	r8,r7[0x24]
8000b7d6:	70 3c       	ld.w	r12,r8[0xc]
8000b7d8:	58 0c       	cp.w	r12,0
8000b7da:	c1 b0       	breq	8000b810 <_Balloc+0x6c>
8000b7dc:	6e 98       	ld.w	r8,r7[0x24]
8000b7de:	70 38       	ld.w	r8,r8[0xc]
8000b7e0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b7e4:	70 0c       	ld.w	r12,r8[0x0]
8000b7e6:	58 0c       	cp.w	r12,0
8000b7e8:	c0 40       	breq	8000b7f0 <_Balloc+0x4c>
8000b7ea:	78 09       	ld.w	r9,r12[0x0]
8000b7ec:	91 09       	st.w	r8[0x0],r9
8000b7ee:	c0 e8       	rjmp	8000b80a <_Balloc+0x66>
8000b7f0:	0e 9c       	mov	r12,r7
8000b7f2:	30 17       	mov	r7,1
8000b7f4:	0e 9b       	mov	r11,r7
8000b7f6:	ee 06 09 47 	lsl	r7,r7,r6
8000b7fa:	ee ca ff fb 	sub	r10,r7,-5
8000b7fe:	a3 6a       	lsl	r10,0x2
8000b800:	e0 a0 02 8e 	rcall	8000bd1c <_calloc_r>
8000b804:	c0 60       	breq	8000b810 <_Balloc+0x6c>
8000b806:	99 16       	st.w	r12[0x4],r6
8000b808:	99 27       	st.w	r12[0x8],r7
8000b80a:	30 08       	mov	r8,0
8000b80c:	99 38       	st.w	r12[0xc],r8
8000b80e:	99 48       	st.w	r12[0x10],r8
8000b810:	d8 22       	popm	r4-r7,pc
8000b812:	d7 03       	nop

8000b814 <__d2b>:
8000b814:	d4 31       	pushm	r0-r7,lr
8000b816:	20 2d       	sub	sp,8
8000b818:	16 93       	mov	r3,r11
8000b81a:	12 96       	mov	r6,r9
8000b81c:	10 95       	mov	r5,r8
8000b81e:	14 92       	mov	r2,r10
8000b820:	30 1b       	mov	r11,1
8000b822:	cc 1f       	rcall	8000b7a4 <_Balloc>
8000b824:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b828:	50 09       	stdsp	sp[0x0],r9
8000b82a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b82e:	b5 a9       	sbr	r9,0x14
8000b830:	f0 01 16 14 	lsr	r1,r8,0x14
8000b834:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b838:	18 94       	mov	r4,r12
8000b83a:	58 02       	cp.w	r2,0
8000b83c:	c1 d0       	breq	8000b876 <__d2b+0x62>
8000b83e:	fa cc ff f8 	sub	r12,sp,-8
8000b842:	18 d2       	st.w	--r12,r2
8000b844:	c3 6f       	rcall	8000b6b0 <__lo0bits>
8000b846:	40 18       	lddsp	r8,sp[0x4]
8000b848:	c0 d0       	breq	8000b862 <__d2b+0x4e>
8000b84a:	40 09       	lddsp	r9,sp[0x0]
8000b84c:	f8 0a 11 20 	rsub	r10,r12,32
8000b850:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b854:	f5 e8 10 08 	or	r8,r10,r8
8000b858:	89 58       	st.w	r4[0x14],r8
8000b85a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b85e:	50 09       	stdsp	sp[0x0],r9
8000b860:	c0 28       	rjmp	8000b864 <__d2b+0x50>
8000b862:	89 58       	st.w	r4[0x14],r8
8000b864:	40 08       	lddsp	r8,sp[0x0]
8000b866:	58 08       	cp.w	r8,0
8000b868:	f9 b3 01 02 	movne	r3,2
8000b86c:	f9 b3 00 01 	moveq	r3,1
8000b870:	89 68       	st.w	r4[0x18],r8
8000b872:	89 43       	st.w	r4[0x10],r3
8000b874:	c0 88       	rjmp	8000b884 <__d2b+0x70>
8000b876:	1a 9c       	mov	r12,sp
8000b878:	c1 cf       	rcall	8000b6b0 <__lo0bits>
8000b87a:	30 13       	mov	r3,1
8000b87c:	40 08       	lddsp	r8,sp[0x0]
8000b87e:	2e 0c       	sub	r12,-32
8000b880:	89 43       	st.w	r4[0x10],r3
8000b882:	89 58       	st.w	r4[0x14],r8
8000b884:	58 01       	cp.w	r1,0
8000b886:	c0 90       	breq	8000b898 <__d2b+0x84>
8000b888:	e2 c1 04 33 	sub	r1,r1,1075
8000b88c:	18 01       	add	r1,r12
8000b88e:	8d 01       	st.w	r6[0x0],r1
8000b890:	f8 0c 11 35 	rsub	r12,r12,53
8000b894:	8b 0c       	st.w	r5[0x0],r12
8000b896:	c0 c8       	rjmp	8000b8ae <__d2b+0x9a>
8000b898:	e6 c8 ff fc 	sub	r8,r3,-4
8000b89c:	f8 cc 04 32 	sub	r12,r12,1074
8000b8a0:	a5 73       	lsl	r3,0x5
8000b8a2:	8d 0c       	st.w	r6[0x0],r12
8000b8a4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b8a8:	cd 4e       	rcall	8000b650 <__hi0bits>
8000b8aa:	18 13       	sub	r3,r12
8000b8ac:	8b 03       	st.w	r5[0x0],r3
8000b8ae:	08 9c       	mov	r12,r4
8000b8b0:	2f ed       	sub	sp,-8
8000b8b2:	d8 32       	popm	r0-r7,pc

8000b8b4 <__mdiff>:
8000b8b4:	d4 31       	pushm	r0-r7,lr
8000b8b6:	74 48       	ld.w	r8,r10[0x10]
8000b8b8:	76 45       	ld.w	r5,r11[0x10]
8000b8ba:	16 97       	mov	r7,r11
8000b8bc:	14 96       	mov	r6,r10
8000b8be:	10 15       	sub	r5,r8
8000b8c0:	c1 31       	brne	8000b8e6 <__mdiff+0x32>
8000b8c2:	2f b8       	sub	r8,-5
8000b8c4:	ee ce ff ec 	sub	lr,r7,-20
8000b8c8:	a3 68       	lsl	r8,0x2
8000b8ca:	f4 08 00 0b 	add	r11,r10,r8
8000b8ce:	ee 08 00 08 	add	r8,r7,r8
8000b8d2:	11 4a       	ld.w	r10,--r8
8000b8d4:	17 49       	ld.w	r9,--r11
8000b8d6:	12 3a       	cp.w	r10,r9
8000b8d8:	c0 30       	breq	8000b8de <__mdiff+0x2a>
8000b8da:	c0 e2       	brcc	8000b8f6 <__mdiff+0x42>
8000b8dc:	c0 78       	rjmp	8000b8ea <__mdiff+0x36>
8000b8de:	1c 38       	cp.w	r8,lr
8000b8e0:	fe 9b ff f9 	brhi	8000b8d2 <__mdiff+0x1e>
8000b8e4:	c4 98       	rjmp	8000b976 <__mdiff+0xc2>
8000b8e6:	58 05       	cp.w	r5,0
8000b8e8:	c0 64       	brge	8000b8f4 <__mdiff+0x40>
8000b8ea:	0e 98       	mov	r8,r7
8000b8ec:	30 15       	mov	r5,1
8000b8ee:	0c 97       	mov	r7,r6
8000b8f0:	10 96       	mov	r6,r8
8000b8f2:	c0 28       	rjmp	8000b8f6 <__mdiff+0x42>
8000b8f4:	30 05       	mov	r5,0
8000b8f6:	6e 1b       	ld.w	r11,r7[0x4]
8000b8f8:	c5 6f       	rcall	8000b7a4 <_Balloc>
8000b8fa:	6e 49       	ld.w	r9,r7[0x10]
8000b8fc:	6c 44       	ld.w	r4,r6[0x10]
8000b8fe:	99 35       	st.w	r12[0xc],r5
8000b900:	2f b4       	sub	r4,-5
8000b902:	f2 c5 ff fb 	sub	r5,r9,-5
8000b906:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b90a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b90e:	2e c6       	sub	r6,-20
8000b910:	2e c7       	sub	r7,-20
8000b912:	f8 c8 ff ec 	sub	r8,r12,-20
8000b916:	30 0a       	mov	r10,0
8000b918:	0f 0e       	ld.w	lr,r7++
8000b91a:	0d 0b       	ld.w	r11,r6++
8000b91c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b920:	f6 03 16 10 	lsr	r3,r11,0x10
8000b924:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b928:	e4 03 01 03 	sub	r3,r2,r3
8000b92c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b930:	fc 0b 01 0b 	sub	r11,lr,r11
8000b934:	f6 0a 00 0a 	add	r10,r11,r10
8000b938:	b0 1a       	st.h	r8[0x2],r10
8000b93a:	b1 4a       	asr	r10,0x10
8000b93c:	e6 0a 00 0a 	add	r10,r3,r10
8000b940:	b0 0a       	st.h	r8[0x0],r10
8000b942:	2f c8       	sub	r8,-4
8000b944:	b1 4a       	asr	r10,0x10
8000b946:	08 36       	cp.w	r6,r4
8000b948:	ce 83       	brcs	8000b918 <__mdiff+0x64>
8000b94a:	c0 d8       	rjmp	8000b964 <__mdiff+0xb0>
8000b94c:	0f 0b       	ld.w	r11,r7++
8000b94e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b952:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b956:	16 0a       	add	r10,r11
8000b958:	b0 1a       	st.h	r8[0x2],r10
8000b95a:	b1 4a       	asr	r10,0x10
8000b95c:	1c 0a       	add	r10,lr
8000b95e:	b0 0a       	st.h	r8[0x0],r10
8000b960:	2f c8       	sub	r8,-4
8000b962:	b1 4a       	asr	r10,0x10
8000b964:	0a 37       	cp.w	r7,r5
8000b966:	cf 33       	brcs	8000b94c <__mdiff+0x98>
8000b968:	c0 28       	rjmp	8000b96c <__mdiff+0xb8>
8000b96a:	20 19       	sub	r9,1
8000b96c:	11 4a       	ld.w	r10,--r8
8000b96e:	58 0a       	cp.w	r10,0
8000b970:	cf d0       	breq	8000b96a <__mdiff+0xb6>
8000b972:	99 49       	st.w	r12[0x10],r9
8000b974:	d8 32       	popm	r0-r7,pc
8000b976:	30 0b       	mov	r11,0
8000b978:	c1 6f       	rcall	8000b7a4 <_Balloc>
8000b97a:	30 18       	mov	r8,1
8000b97c:	99 48       	st.w	r12[0x10],r8
8000b97e:	30 08       	mov	r8,0
8000b980:	99 58       	st.w	r12[0x14],r8
8000b982:	d8 32       	popm	r0-r7,pc

8000b984 <__lshift>:
8000b984:	d4 31       	pushm	r0-r7,lr
8000b986:	16 97       	mov	r7,r11
8000b988:	76 46       	ld.w	r6,r11[0x10]
8000b98a:	f4 02 14 05 	asr	r2,r10,0x5
8000b98e:	2f f6       	sub	r6,-1
8000b990:	14 93       	mov	r3,r10
8000b992:	18 94       	mov	r4,r12
8000b994:	04 06       	add	r6,r2
8000b996:	76 1b       	ld.w	r11,r11[0x4]
8000b998:	6e 28       	ld.w	r8,r7[0x8]
8000b99a:	c0 38       	rjmp	8000b9a0 <__lshift+0x1c>
8000b99c:	2f fb       	sub	r11,-1
8000b99e:	a1 78       	lsl	r8,0x1
8000b9a0:	10 36       	cp.w	r6,r8
8000b9a2:	fe 99 ff fd 	brgt	8000b99c <__lshift+0x18>
8000b9a6:	08 9c       	mov	r12,r4
8000b9a8:	cf ee       	rcall	8000b7a4 <_Balloc>
8000b9aa:	30 09       	mov	r9,0
8000b9ac:	18 95       	mov	r5,r12
8000b9ae:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9b2:	12 9a       	mov	r10,r9
8000b9b4:	c0 38       	rjmp	8000b9ba <__lshift+0x36>
8000b9b6:	10 aa       	st.w	r8++,r10
8000b9b8:	2f f9       	sub	r9,-1
8000b9ba:	04 39       	cp.w	r9,r2
8000b9bc:	cf d5       	brlt	8000b9b6 <__lshift+0x32>
8000b9be:	6e 4b       	ld.w	r11,r7[0x10]
8000b9c0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b9c4:	2f bb       	sub	r11,-5
8000b9c6:	ee c9 ff ec 	sub	r9,r7,-20
8000b9ca:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b9ce:	58 03       	cp.w	r3,0
8000b9d0:	c1 30       	breq	8000b9f6 <__lshift+0x72>
8000b9d2:	e6 0c 11 20 	rsub	r12,r3,32
8000b9d6:	30 0a       	mov	r10,0
8000b9d8:	72 02       	ld.w	r2,r9[0x0]
8000b9da:	e4 03 09 42 	lsl	r2,r2,r3
8000b9de:	04 4a       	or	r10,r2
8000b9e0:	10 aa       	st.w	r8++,r10
8000b9e2:	13 0a       	ld.w	r10,r9++
8000b9e4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9e8:	16 39       	cp.w	r9,r11
8000b9ea:	cf 73       	brcs	8000b9d8 <__lshift+0x54>
8000b9ec:	91 0a       	st.w	r8[0x0],r10
8000b9ee:	58 0a       	cp.w	r10,0
8000b9f0:	c0 70       	breq	8000b9fe <__lshift+0x7a>
8000b9f2:	2f f6       	sub	r6,-1
8000b9f4:	c0 58       	rjmp	8000b9fe <__lshift+0x7a>
8000b9f6:	13 0a       	ld.w	r10,r9++
8000b9f8:	10 aa       	st.w	r8++,r10
8000b9fa:	16 39       	cp.w	r9,r11
8000b9fc:	cf d3       	brcs	8000b9f6 <__lshift+0x72>
8000b9fe:	08 9c       	mov	r12,r4
8000ba00:	20 16       	sub	r6,1
8000ba02:	0e 9b       	mov	r11,r7
8000ba04:	8b 46       	st.w	r5[0x10],r6
8000ba06:	cb 5e       	rcall	8000b770 <_Bfree>
8000ba08:	0a 9c       	mov	r12,r5
8000ba0a:	d8 32       	popm	r0-r7,pc

8000ba0c <__multiply>:
8000ba0c:	d4 31       	pushm	r0-r7,lr
8000ba0e:	20 2d       	sub	sp,8
8000ba10:	76 49       	ld.w	r9,r11[0x10]
8000ba12:	74 48       	ld.w	r8,r10[0x10]
8000ba14:	16 96       	mov	r6,r11
8000ba16:	14 95       	mov	r5,r10
8000ba18:	10 39       	cp.w	r9,r8
8000ba1a:	ec 08 17 50 	movlt	r8,r6
8000ba1e:	ea 06 17 50 	movlt	r6,r5
8000ba22:	f0 05 17 50 	movlt	r5,r8
8000ba26:	6c 28       	ld.w	r8,r6[0x8]
8000ba28:	76 43       	ld.w	r3,r11[0x10]
8000ba2a:	74 42       	ld.w	r2,r10[0x10]
8000ba2c:	76 1b       	ld.w	r11,r11[0x4]
8000ba2e:	e4 03 00 07 	add	r7,r2,r3
8000ba32:	10 37       	cp.w	r7,r8
8000ba34:	f7 bb 09 ff 	subgt	r11,-1
8000ba38:	cb 6e       	rcall	8000b7a4 <_Balloc>
8000ba3a:	ee c4 ff fb 	sub	r4,r7,-5
8000ba3e:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba42:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba46:	30 0a       	mov	r10,0
8000ba48:	12 98       	mov	r8,r9
8000ba4a:	c0 28       	rjmp	8000ba4e <__multiply+0x42>
8000ba4c:	10 aa       	st.w	r8++,r10
8000ba4e:	08 38       	cp.w	r8,r4
8000ba50:	cf e3       	brcs	8000ba4c <__multiply+0x40>
8000ba52:	2f b3       	sub	r3,-5
8000ba54:	2f b2       	sub	r2,-5
8000ba56:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba5a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba5e:	ec cb ff ec 	sub	r11,r6,-20
8000ba62:	50 12       	stdsp	sp[0x4],r2
8000ba64:	ea ca ff ec 	sub	r10,r5,-20
8000ba68:	c4 48       	rjmp	8000baf0 <__multiply+0xe4>
8000ba6a:	94 95       	ld.uh	r5,r10[0x2]
8000ba6c:	58 05       	cp.w	r5,0
8000ba6e:	c2 00       	breq	8000baae <__multiply+0xa2>
8000ba70:	12 98       	mov	r8,r9
8000ba72:	16 96       	mov	r6,r11
8000ba74:	30 0e       	mov	lr,0
8000ba76:	50 09       	stdsp	sp[0x0],r9
8000ba78:	0d 02       	ld.w	r2,r6++
8000ba7a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba7e:	70 01       	ld.w	r1,r8[0x0]
8000ba80:	70 09       	ld.w	r9,r8[0x0]
8000ba82:	b1 81       	lsr	r1,0x10
8000ba84:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba88:	e0 05 03 41 	mac	r1,r0,r5
8000ba8c:	ab 32       	mul	r2,r5
8000ba8e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ba92:	00 02       	add	r2,r0
8000ba94:	e4 0e 00 0e 	add	lr,r2,lr
8000ba98:	b0 1e       	st.h	r8[0x2],lr
8000ba9a:	b1 8e       	lsr	lr,0x10
8000ba9c:	1c 01       	add	r1,lr
8000ba9e:	b0 01       	st.h	r8[0x0],r1
8000baa0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000baa4:	2f c8       	sub	r8,-4
8000baa6:	06 36       	cp.w	r6,r3
8000baa8:	ce 83       	brcs	8000ba78 <__multiply+0x6c>
8000baaa:	40 09       	lddsp	r9,sp[0x0]
8000baac:	91 0e       	st.w	r8[0x0],lr
8000baae:	94 86       	ld.uh	r6,r10[0x0]
8000bab0:	58 06       	cp.w	r6,0
8000bab2:	c1 d0       	breq	8000baec <__multiply+0xe0>
8000bab4:	72 02       	ld.w	r2,r9[0x0]
8000bab6:	12 98       	mov	r8,r9
8000bab8:	16 9e       	mov	lr,r11
8000baba:	30 05       	mov	r5,0
8000babc:	b0 12       	st.h	r8[0x2],r2
8000babe:	1d 01       	ld.w	r1,lr++
8000bac0:	90 82       	ld.uh	r2,r8[0x0]
8000bac2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bac6:	ad 30       	mul	r0,r6
8000bac8:	e0 02 00 02 	add	r2,r0,r2
8000bacc:	e4 05 00 05 	add	r5,r2,r5
8000bad0:	b0 05       	st.h	r8[0x0],r5
8000bad2:	b1 85       	lsr	r5,0x10
8000bad4:	b1 81       	lsr	r1,0x10
8000bad6:	2f c8       	sub	r8,-4
8000bad8:	ad 31       	mul	r1,r6
8000bada:	90 92       	ld.uh	r2,r8[0x2]
8000badc:	e2 02 00 02 	add	r2,r1,r2
8000bae0:	0a 02       	add	r2,r5
8000bae2:	e4 05 16 10 	lsr	r5,r2,0x10
8000bae6:	06 3e       	cp.w	lr,r3
8000bae8:	ce a3       	brcs	8000babc <__multiply+0xb0>
8000baea:	91 02       	st.w	r8[0x0],r2
8000baec:	2f ca       	sub	r10,-4
8000baee:	2f c9       	sub	r9,-4
8000baf0:	40 18       	lddsp	r8,sp[0x4]
8000baf2:	10 3a       	cp.w	r10,r8
8000baf4:	cb b3       	brcs	8000ba6a <__multiply+0x5e>
8000baf6:	c0 28       	rjmp	8000bafa <__multiply+0xee>
8000baf8:	20 17       	sub	r7,1
8000bafa:	58 07       	cp.w	r7,0
8000bafc:	e0 8a 00 05 	brle	8000bb06 <__multiply+0xfa>
8000bb00:	09 48       	ld.w	r8,--r4
8000bb02:	58 08       	cp.w	r8,0
8000bb04:	cf a0       	breq	8000baf8 <__multiply+0xec>
8000bb06:	99 47       	st.w	r12[0x10],r7
8000bb08:	2f ed       	sub	sp,-8
8000bb0a:	d8 32       	popm	r0-r7,pc

8000bb0c <__i2b>:
8000bb0c:	d4 21       	pushm	r4-r7,lr
8000bb0e:	16 97       	mov	r7,r11
8000bb10:	30 1b       	mov	r11,1
8000bb12:	c4 9e       	rcall	8000b7a4 <_Balloc>
8000bb14:	30 19       	mov	r9,1
8000bb16:	99 57       	st.w	r12[0x14],r7
8000bb18:	99 49       	st.w	r12[0x10],r9
8000bb1a:	d8 22       	popm	r4-r7,pc

8000bb1c <__multadd>:
8000bb1c:	d4 31       	pushm	r0-r7,lr
8000bb1e:	30 08       	mov	r8,0
8000bb20:	12 95       	mov	r5,r9
8000bb22:	16 97       	mov	r7,r11
8000bb24:	18 96       	mov	r6,r12
8000bb26:	76 44       	ld.w	r4,r11[0x10]
8000bb28:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb2c:	72 0b       	ld.w	r11,r9[0x0]
8000bb2e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb32:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb36:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb3a:	f4 0b 03 45 	mac	r5,r10,r11
8000bb3e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb42:	b1 85       	lsr	r5,0x10
8000bb44:	18 05       	add	r5,r12
8000bb46:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb4a:	f8 0b 00 0b 	add	r11,r12,r11
8000bb4e:	12 ab       	st.w	r9++,r11
8000bb50:	2f f8       	sub	r8,-1
8000bb52:	b1 85       	lsr	r5,0x10
8000bb54:	08 38       	cp.w	r8,r4
8000bb56:	ce b5       	brlt	8000bb2c <__multadd+0x10>
8000bb58:	58 05       	cp.w	r5,0
8000bb5a:	c1 c0       	breq	8000bb92 <__multadd+0x76>
8000bb5c:	6e 28       	ld.w	r8,r7[0x8]
8000bb5e:	10 34       	cp.w	r4,r8
8000bb60:	c1 35       	brlt	8000bb86 <__multadd+0x6a>
8000bb62:	6e 1b       	ld.w	r11,r7[0x4]
8000bb64:	0c 9c       	mov	r12,r6
8000bb66:	2f fb       	sub	r11,-1
8000bb68:	c1 ee       	rcall	8000b7a4 <_Balloc>
8000bb6a:	6e 4a       	ld.w	r10,r7[0x10]
8000bb6c:	ee cb ff f4 	sub	r11,r7,-12
8000bb70:	18 93       	mov	r3,r12
8000bb72:	2f ea       	sub	r10,-2
8000bb74:	2f 4c       	sub	r12,-12
8000bb76:	a3 6a       	lsl	r10,0x2
8000bb78:	fe b0 de 70 	rcall	80007858 <memcpy>
8000bb7c:	0e 9b       	mov	r11,r7
8000bb7e:	0c 9c       	mov	r12,r6
8000bb80:	fe b0 fd f8 	rcall	8000b770 <_Bfree>
8000bb84:	06 97       	mov	r7,r3
8000bb86:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb8a:	2f b4       	sub	r4,-5
8000bb8c:	8f 48       	st.w	r7[0x10],r8
8000bb8e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bb92:	0e 9c       	mov	r12,r7
8000bb94:	d8 32       	popm	r0-r7,pc
8000bb96:	d7 03       	nop

8000bb98 <__pow5mult>:
8000bb98:	d4 31       	pushm	r0-r7,lr
8000bb9a:	14 96       	mov	r6,r10
8000bb9c:	18 97       	mov	r7,r12
8000bb9e:	16 94       	mov	r4,r11
8000bba0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bba4:	c0 90       	breq	8000bbb6 <__pow5mult+0x1e>
8000bba6:	20 18       	sub	r8,1
8000bba8:	fe c9 da 28 	sub	r9,pc,-9688
8000bbac:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bbb0:	30 09       	mov	r9,0
8000bbb2:	cb 5f       	rcall	8000bb1c <__multadd>
8000bbb4:	18 94       	mov	r4,r12
8000bbb6:	a3 46       	asr	r6,0x2
8000bbb8:	c3 40       	breq	8000bc20 <__pow5mult+0x88>
8000bbba:	6e 95       	ld.w	r5,r7[0x24]
8000bbbc:	58 05       	cp.w	r5,0
8000bbbe:	c0 91       	brne	8000bbd0 <__pow5mult+0x38>
8000bbc0:	31 0c       	mov	r12,16
8000bbc2:	fe b0 dc 27 	rcall	80007410 <malloc>
8000bbc6:	99 35       	st.w	r12[0xc],r5
8000bbc8:	8f 9c       	st.w	r7[0x24],r12
8000bbca:	99 15       	st.w	r12[0x4],r5
8000bbcc:	99 25       	st.w	r12[0x8],r5
8000bbce:	99 05       	st.w	r12[0x0],r5
8000bbd0:	6e 93       	ld.w	r3,r7[0x24]
8000bbd2:	66 25       	ld.w	r5,r3[0x8]
8000bbd4:	58 05       	cp.w	r5,0
8000bbd6:	c0 c1       	brne	8000bbee <__pow5mult+0x56>
8000bbd8:	e0 6b 02 71 	mov	r11,625
8000bbdc:	0e 9c       	mov	r12,r7
8000bbde:	c9 7f       	rcall	8000bb0c <__i2b>
8000bbe0:	87 2c       	st.w	r3[0x8],r12
8000bbe2:	30 08       	mov	r8,0
8000bbe4:	18 95       	mov	r5,r12
8000bbe6:	99 08       	st.w	r12[0x0],r8
8000bbe8:	c0 38       	rjmp	8000bbee <__pow5mult+0x56>
8000bbea:	06 9c       	mov	r12,r3
8000bbec:	18 95       	mov	r5,r12
8000bbee:	ed b6 00 00 	bld	r6,0x0
8000bbf2:	c0 b1       	brne	8000bc08 <__pow5mult+0x70>
8000bbf4:	08 9b       	mov	r11,r4
8000bbf6:	0a 9a       	mov	r10,r5
8000bbf8:	0e 9c       	mov	r12,r7
8000bbfa:	c0 9f       	rcall	8000ba0c <__multiply>
8000bbfc:	08 9b       	mov	r11,r4
8000bbfe:	18 93       	mov	r3,r12
8000bc00:	0e 9c       	mov	r12,r7
8000bc02:	06 94       	mov	r4,r3
8000bc04:	fe b0 fd b6 	rcall	8000b770 <_Bfree>
8000bc08:	a1 56       	asr	r6,0x1
8000bc0a:	c0 b0       	breq	8000bc20 <__pow5mult+0x88>
8000bc0c:	6a 03       	ld.w	r3,r5[0x0]
8000bc0e:	58 03       	cp.w	r3,0
8000bc10:	ce d1       	brne	8000bbea <__pow5mult+0x52>
8000bc12:	0a 9a       	mov	r10,r5
8000bc14:	0a 9b       	mov	r11,r5
8000bc16:	0e 9c       	mov	r12,r7
8000bc18:	cf ae       	rcall	8000ba0c <__multiply>
8000bc1a:	8b 0c       	st.w	r5[0x0],r12
8000bc1c:	99 03       	st.w	r12[0x0],r3
8000bc1e:	ce 7b       	rjmp	8000bbec <__pow5mult+0x54>
8000bc20:	08 9c       	mov	r12,r4
8000bc22:	d8 32       	popm	r0-r7,pc

8000bc24 <__isinfd>:
8000bc24:	14 98       	mov	r8,r10
8000bc26:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc2a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc2e:	f0 0b 11 00 	rsub	r11,r8,0
8000bc32:	f7 e8 10 08 	or	r8,r11,r8
8000bc36:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc3a:	f2 08 01 08 	sub	r8,r9,r8
8000bc3e:	f0 0c 11 00 	rsub	r12,r8,0
8000bc42:	f9 e8 10 08 	or	r8,r12,r8
8000bc46:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc4a:	2f fc       	sub	r12,-1
8000bc4c:	5e fc       	retal	r12

8000bc4e <__isnand>:
8000bc4e:	14 98       	mov	r8,r10
8000bc50:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc54:	f0 0c 11 00 	rsub	r12,r8,0
8000bc58:	10 4c       	or	r12,r8
8000bc5a:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc5e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc62:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc66:	bf 9c       	lsr	r12,0x1f
8000bc68:	5e fc       	retal	r12
8000bc6a:	d7 03       	nop

8000bc6c <__sclose>:
8000bc6c:	d4 01       	pushm	lr
8000bc6e:	96 7b       	ld.sh	r11,r11[0xe]
8000bc70:	c8 2c       	rcall	8000bd74 <_close_r>
8000bc72:	d8 02       	popm	pc

8000bc74 <__sseek>:
8000bc74:	d4 21       	pushm	r4-r7,lr
8000bc76:	16 97       	mov	r7,r11
8000bc78:	96 7b       	ld.sh	r11,r11[0xe]
8000bc7a:	c0 3d       	rcall	8000be80 <_lseek_r>
8000bc7c:	8e 68       	ld.sh	r8,r7[0xc]
8000bc7e:	10 99       	mov	r9,r8
8000bc80:	ad c8       	cbr	r8,0xc
8000bc82:	ad a9       	sbr	r9,0xc
8000bc84:	5b fc       	cp.w	r12,-1
8000bc86:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc8a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc8e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bc92:	d8 22       	popm	r4-r7,pc

8000bc94 <__swrite>:
8000bc94:	d4 21       	pushm	r4-r7,lr
8000bc96:	96 68       	ld.sh	r8,r11[0xc]
8000bc98:	16 97       	mov	r7,r11
8000bc9a:	14 95       	mov	r5,r10
8000bc9c:	12 94       	mov	r4,r9
8000bc9e:	e2 18 01 00 	andl	r8,0x100,COH
8000bca2:	18 96       	mov	r6,r12
8000bca4:	c0 50       	breq	8000bcae <__swrite+0x1a>
8000bca6:	30 29       	mov	r9,2
8000bca8:	30 0a       	mov	r10,0
8000bcaa:	96 7b       	ld.sh	r11,r11[0xe]
8000bcac:	ce ac       	rcall	8000be80 <_lseek_r>
8000bcae:	8e 68       	ld.sh	r8,r7[0xc]
8000bcb0:	ad c8       	cbr	r8,0xc
8000bcb2:	08 99       	mov	r9,r4
8000bcb4:	0a 9a       	mov	r10,r5
8000bcb6:	8e 7b       	ld.sh	r11,r7[0xe]
8000bcb8:	0c 9c       	mov	r12,r6
8000bcba:	ae 68       	st.h	r7[0xc],r8
8000bcbc:	c1 cc       	rcall	8000bcf4 <_write_r>
8000bcbe:	d8 22       	popm	r4-r7,pc

8000bcc0 <__sread>:
8000bcc0:	d4 21       	pushm	r4-r7,lr
8000bcc2:	16 97       	mov	r7,r11
8000bcc4:	96 7b       	ld.sh	r11,r11[0xe]
8000bcc6:	cf 1c       	rcall	8000bea8 <_read_r>
8000bcc8:	c0 65       	brlt	8000bcd4 <__sread+0x14>
8000bcca:	6f 58       	ld.w	r8,r7[0x54]
8000bccc:	18 08       	add	r8,r12
8000bcce:	ef 48 00 54 	st.w	r7[84],r8
8000bcd2:	d8 22       	popm	r4-r7,pc
8000bcd4:	8e 68       	ld.sh	r8,r7[0xc]
8000bcd6:	ad c8       	cbr	r8,0xc
8000bcd8:	ae 68       	st.h	r7[0xc],r8
8000bcda:	d8 22       	popm	r4-r7,pc

8000bcdc <strlen>:
8000bcdc:	30 09       	mov	r9,0
8000bcde:	18 98       	mov	r8,r12
8000bce0:	c0 28       	rjmp	8000bce4 <strlen+0x8>
8000bce2:	2f f8       	sub	r8,-1
8000bce4:	11 8a       	ld.ub	r10,r8[0x0]
8000bce6:	f2 0a 18 00 	cp.b	r10,r9
8000bcea:	cf c1       	brne	8000bce2 <strlen+0x6>
8000bcec:	f0 0c 01 0c 	sub	r12,r8,r12
8000bcf0:	5e fc       	retal	r12
8000bcf2:	d7 03       	nop

8000bcf4 <_write_r>:
8000bcf4:	d4 21       	pushm	r4-r7,lr
8000bcf6:	16 98       	mov	r8,r11
8000bcf8:	18 97       	mov	r7,r12
8000bcfa:	10 9c       	mov	r12,r8
8000bcfc:	30 08       	mov	r8,0
8000bcfe:	14 9b       	mov	r11,r10
8000bd00:	e0 66 53 c8 	mov	r6,21448
8000bd04:	12 9a       	mov	r10,r9
8000bd06:	8d 08       	st.w	r6[0x0],r8
8000bd08:	fe b0 d1 6e 	rcall	80005fe4 <_write>
8000bd0c:	5b fc       	cp.w	r12,-1
8000bd0e:	c0 51       	brne	8000bd18 <_write_r+0x24>
8000bd10:	6c 08       	ld.w	r8,r6[0x0]
8000bd12:	58 08       	cp.w	r8,0
8000bd14:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd18:	d8 22       	popm	r4-r7,pc
8000bd1a:	d7 03       	nop

8000bd1c <_calloc_r>:
8000bd1c:	d4 21       	pushm	r4-r7,lr
8000bd1e:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd22:	fe b0 db 7f 	rcall	80007420 <_malloc_r>
8000bd26:	18 97       	mov	r7,r12
8000bd28:	c2 30       	breq	8000bd6e <_calloc_r+0x52>
8000bd2a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd2e:	e0 1a ff fc 	andl	r10,0xfffc
8000bd32:	20 4a       	sub	r10,4
8000bd34:	e0 4a 00 24 	cp.w	r10,36
8000bd38:	e0 8b 00 18 	brhi	8000bd68 <_calloc_r+0x4c>
8000bd3c:	18 98       	mov	r8,r12
8000bd3e:	59 3a       	cp.w	r10,19
8000bd40:	e0 88 00 0f 	brls	8000bd5e <_calloc_r+0x42>
8000bd44:	30 09       	mov	r9,0
8000bd46:	10 a9       	st.w	r8++,r9
8000bd48:	10 a9       	st.w	r8++,r9
8000bd4a:	59 ba       	cp.w	r10,27
8000bd4c:	e0 88 00 09 	brls	8000bd5e <_calloc_r+0x42>
8000bd50:	10 a9       	st.w	r8++,r9
8000bd52:	10 a9       	st.w	r8++,r9
8000bd54:	e0 4a 00 24 	cp.w	r10,36
8000bd58:	c0 31       	brne	8000bd5e <_calloc_r+0x42>
8000bd5a:	10 a9       	st.w	r8++,r9
8000bd5c:	10 a9       	st.w	r8++,r9
8000bd5e:	30 09       	mov	r9,0
8000bd60:	10 a9       	st.w	r8++,r9
8000bd62:	91 19       	st.w	r8[0x4],r9
8000bd64:	91 09       	st.w	r8[0x0],r9
8000bd66:	c0 48       	rjmp	8000bd6e <_calloc_r+0x52>
8000bd68:	30 0b       	mov	r11,0
8000bd6a:	fe b0 de 1b 	rcall	800079a0 <memset>
8000bd6e:	0e 9c       	mov	r12,r7
8000bd70:	d8 22       	popm	r4-r7,pc
8000bd72:	d7 03       	nop

8000bd74 <_close_r>:
8000bd74:	d4 21       	pushm	r4-r7,lr
8000bd76:	30 08       	mov	r8,0
8000bd78:	18 97       	mov	r7,r12
8000bd7a:	e0 66 53 c8 	mov	r6,21448
8000bd7e:	16 9c       	mov	r12,r11
8000bd80:	8d 08       	st.w	r6[0x0],r8
8000bd82:	fe b0 df b5 	rcall	80007cec <_close>
8000bd86:	5b fc       	cp.w	r12,-1
8000bd88:	c0 51       	brne	8000bd92 <_close_r+0x1e>
8000bd8a:	6c 08       	ld.w	r8,r6[0x0]
8000bd8c:	58 08       	cp.w	r8,0
8000bd8e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd92:	d8 22       	popm	r4-r7,pc

8000bd94 <_fclose_r>:
8000bd94:	d4 21       	pushm	r4-r7,lr
8000bd96:	18 96       	mov	r6,r12
8000bd98:	16 97       	mov	r7,r11
8000bd9a:	58 0b       	cp.w	r11,0
8000bd9c:	c0 31       	brne	8000bda2 <_fclose_r+0xe>
8000bd9e:	16 95       	mov	r5,r11
8000bda0:	c5 38       	rjmp	8000be46 <_fclose_r+0xb2>
8000bda2:	fe b0 f8 a9 	rcall	8000aef4 <__sfp_lock_acquire>
8000bda6:	58 06       	cp.w	r6,0
8000bda8:	c0 70       	breq	8000bdb6 <_fclose_r+0x22>
8000bdaa:	6c 68       	ld.w	r8,r6[0x18]
8000bdac:	58 08       	cp.w	r8,0
8000bdae:	c0 41       	brne	8000bdb6 <_fclose_r+0x22>
8000bdb0:	0c 9c       	mov	r12,r6
8000bdb2:	fe b0 f8 f3 	rcall	8000af98 <__sinit>
8000bdb6:	fe c8 dc da 	sub	r8,pc,-8998
8000bdba:	10 37       	cp.w	r7,r8
8000bdbc:	c0 31       	brne	8000bdc2 <_fclose_r+0x2e>
8000bdbe:	6c 07       	ld.w	r7,r6[0x0]
8000bdc0:	c0 c8       	rjmp	8000bdd8 <_fclose_r+0x44>
8000bdc2:	fe c8 dc c6 	sub	r8,pc,-9018
8000bdc6:	10 37       	cp.w	r7,r8
8000bdc8:	c0 31       	brne	8000bdce <_fclose_r+0x3a>
8000bdca:	6c 17       	ld.w	r7,r6[0x4]
8000bdcc:	c0 68       	rjmp	8000bdd8 <_fclose_r+0x44>
8000bdce:	fe c8 dc b2 	sub	r8,pc,-9038
8000bdd2:	10 37       	cp.w	r7,r8
8000bdd4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdd8:	8e 69       	ld.sh	r9,r7[0xc]
8000bdda:	30 08       	mov	r8,0
8000bddc:	f0 09 19 00 	cp.h	r9,r8
8000bde0:	c0 51       	brne	8000bdea <_fclose_r+0x56>
8000bde2:	fe b0 f8 8a 	rcall	8000aef6 <__sfp_lock_release>
8000bde6:	30 05       	mov	r5,0
8000bde8:	c2 f8       	rjmp	8000be46 <_fclose_r+0xb2>
8000bdea:	0e 9b       	mov	r11,r7
8000bdec:	0c 9c       	mov	r12,r6
8000bdee:	fe b0 f7 fd 	rcall	8000ade8 <_fflush_r>
8000bdf2:	6e c8       	ld.w	r8,r7[0x30]
8000bdf4:	18 95       	mov	r5,r12
8000bdf6:	58 08       	cp.w	r8,0
8000bdf8:	c0 60       	breq	8000be04 <_fclose_r+0x70>
8000bdfa:	6e 8b       	ld.w	r11,r7[0x20]
8000bdfc:	0c 9c       	mov	r12,r6
8000bdfe:	5d 18       	icall	r8
8000be00:	f9 b5 05 ff 	movlt	r5,-1
8000be04:	8e 68       	ld.sh	r8,r7[0xc]
8000be06:	ed b8 00 07 	bld	r8,0x7
8000be0a:	c0 51       	brne	8000be14 <_fclose_r+0x80>
8000be0c:	6e 4b       	ld.w	r11,r7[0x10]
8000be0e:	0c 9c       	mov	r12,r6
8000be10:	fe b0 f9 5e 	rcall	8000b0cc <_free_r>
8000be14:	6e db       	ld.w	r11,r7[0x34]
8000be16:	58 0b       	cp.w	r11,0
8000be18:	c0 a0       	breq	8000be2c <_fclose_r+0x98>
8000be1a:	ee c8 ff bc 	sub	r8,r7,-68
8000be1e:	10 3b       	cp.w	r11,r8
8000be20:	c0 40       	breq	8000be28 <_fclose_r+0x94>
8000be22:	0c 9c       	mov	r12,r6
8000be24:	fe b0 f9 54 	rcall	8000b0cc <_free_r>
8000be28:	30 08       	mov	r8,0
8000be2a:	8f d8       	st.w	r7[0x34],r8
8000be2c:	6f 2b       	ld.w	r11,r7[0x48]
8000be2e:	58 0b       	cp.w	r11,0
8000be30:	c0 70       	breq	8000be3e <_fclose_r+0xaa>
8000be32:	0c 9c       	mov	r12,r6
8000be34:	fe b0 f9 4c 	rcall	8000b0cc <_free_r>
8000be38:	30 08       	mov	r8,0
8000be3a:	ef 48 00 48 	st.w	r7[72],r8
8000be3e:	30 08       	mov	r8,0
8000be40:	ae 68       	st.h	r7[0xc],r8
8000be42:	fe b0 f8 5a 	rcall	8000aef6 <__sfp_lock_release>
8000be46:	0a 9c       	mov	r12,r5
8000be48:	d8 22       	popm	r4-r7,pc
8000be4a:	d7 03       	nop

8000be4c <fclose>:
8000be4c:	d4 01       	pushm	lr
8000be4e:	e0 68 0a 40 	mov	r8,2624
8000be52:	18 9b       	mov	r11,r12
8000be54:	70 0c       	ld.w	r12,r8[0x0]
8000be56:	c9 ff       	rcall	8000bd94 <_fclose_r>
8000be58:	d8 02       	popm	pc
8000be5a:	d7 03       	nop

8000be5c <_fstat_r>:
8000be5c:	d4 21       	pushm	r4-r7,lr
8000be5e:	16 98       	mov	r8,r11
8000be60:	18 97       	mov	r7,r12
8000be62:	10 9c       	mov	r12,r8
8000be64:	30 08       	mov	r8,0
8000be66:	e0 66 53 c8 	mov	r6,21448
8000be6a:	14 9b       	mov	r11,r10
8000be6c:	8d 08       	st.w	r6[0x0],r8
8000be6e:	fe b0 df 67 	rcall	80007d3c <_fstat>
8000be72:	5b fc       	cp.w	r12,-1
8000be74:	c0 51       	brne	8000be7e <_fstat_r+0x22>
8000be76:	6c 08       	ld.w	r8,r6[0x0]
8000be78:	58 08       	cp.w	r8,0
8000be7a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be7e:	d8 22       	popm	r4-r7,pc

8000be80 <_lseek_r>:
8000be80:	d4 21       	pushm	r4-r7,lr
8000be82:	16 98       	mov	r8,r11
8000be84:	18 97       	mov	r7,r12
8000be86:	10 9c       	mov	r12,r8
8000be88:	30 08       	mov	r8,0
8000be8a:	14 9b       	mov	r11,r10
8000be8c:	e0 66 53 c8 	mov	r6,21448
8000be90:	12 9a       	mov	r10,r9
8000be92:	8d 08       	st.w	r6[0x0],r8
8000be94:	fe b0 df 36 	rcall	80007d00 <_lseek>
8000be98:	5b fc       	cp.w	r12,-1
8000be9a:	c0 51       	brne	8000bea4 <_lseek_r+0x24>
8000be9c:	6c 08       	ld.w	r8,r6[0x0]
8000be9e:	58 08       	cp.w	r8,0
8000bea0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bea4:	d8 22       	popm	r4-r7,pc
8000bea6:	d7 03       	nop

8000bea8 <_read_r>:
8000bea8:	d4 21       	pushm	r4-r7,lr
8000beaa:	16 98       	mov	r8,r11
8000beac:	18 97       	mov	r7,r12
8000beae:	10 9c       	mov	r12,r8
8000beb0:	30 08       	mov	r8,0
8000beb2:	14 9b       	mov	r11,r10
8000beb4:	e0 66 53 c8 	mov	r6,21448
8000beb8:	12 9a       	mov	r10,r9
8000beba:	8d 08       	st.w	r6[0x0],r8
8000bebc:	fe b0 d0 74 	rcall	80005fa4 <_read>
8000bec0:	5b fc       	cp.w	r12,-1
8000bec2:	c0 51       	brne	8000becc <_read_r+0x24>
8000bec4:	6c 08       	ld.w	r8,r6[0x0]
8000bec6:	58 08       	cp.w	r8,0
8000bec8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000becc:	d8 22       	popm	r4-r7,pc
8000bece:	d7 03       	nop

8000bed0 <__avr32_f64_mul>:
8000bed0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bed4:	e0 80 00 dc 	breq	8000c08c <__avr32_f64_mul_op1_zero>
8000bed8:	d4 21       	pushm	r4-r7,lr
8000beda:	f7 e9 20 0e 	eor	lr,r11,r9
8000bede:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bee2:	30 15       	mov	r5,1
8000bee4:	c4 30       	breq	8000bf6a <__avr32_f64_mul_op1_subnormal>
8000bee6:	ab 6b       	lsl	r11,0xa
8000bee8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000beec:	ab 6a       	lsl	r10,0xa
8000beee:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bef2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bef6:	c5 c0       	breq	8000bfae <__avr32_f64_mul_op2_subnormal>
8000bef8:	a1 78       	lsl	r8,0x1
8000befa:	5c f9       	rol	r9
8000befc:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf00:	e0 47 07 ff 	cp.w	r7,2047
8000bf04:	c7 70       	breq	8000bff2 <__avr32_f64_mul_op_nan_or_inf>
8000bf06:	e0 46 07 ff 	cp.w	r6,2047
8000bf0a:	c7 40       	breq	8000bff2 <__avr32_f64_mul_op_nan_or_inf>
8000bf0c:	ee 06 00 0c 	add	r12,r7,r6
8000bf10:	e0 2c 03 fe 	sub	r12,1022
8000bf14:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf18:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf1c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf20:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf24:	08 07       	add	r7,r4
8000bf26:	f4 05 00 4a 	adc	r10,r10,r5
8000bf2a:	5c 0b       	acr	r11
8000bf2c:	ed bb 00 14 	bld	r11,0x14
8000bf30:	c0 50       	breq	8000bf3a <__avr32_f64_mul+0x6a>
8000bf32:	a1 77       	lsl	r7,0x1
8000bf34:	5c fa       	rol	r10
8000bf36:	5c fb       	rol	r11
8000bf38:	20 1c       	sub	r12,1
8000bf3a:	58 0c       	cp.w	r12,0
8000bf3c:	e0 8a 00 6f 	brle	8000c01a <__avr32_f64_mul_res_subnormal>
8000bf40:	e0 4c 07 ff 	cp.w	r12,2047
8000bf44:	e0 84 00 9c 	brge	8000c07c <__avr32_f64_mul_res_inf>
8000bf48:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf4c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf50:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf54:	ee 17 80 00 	eorh	r7,0x8000
8000bf58:	f1 b7 04 20 	satu	r7,0x1
8000bf5c:	0e 0a       	add	r10,r7
8000bf5e:	5c 0b       	acr	r11
8000bf60:	ed be 00 1f 	bld	lr,0x1f
8000bf64:	ef bb 00 1f 	bst	r11,0x1f
8000bf68:	d8 22       	popm	r4-r7,pc

8000bf6a <__avr32_f64_mul_op1_subnormal>:
8000bf6a:	e4 1b 00 0f 	andh	r11,0xf
8000bf6e:	f4 0c 12 00 	clz	r12,r10
8000bf72:	f6 06 12 00 	clz	r6,r11
8000bf76:	f7 bc 03 e1 	sublo	r12,-31
8000bf7a:	f8 06 17 30 	movlo	r6,r12
8000bf7e:	f7 b6 02 01 	subhs	r6,1
8000bf82:	e0 46 00 20 	cp.w	r6,32
8000bf86:	c0 d4       	brge	8000bfa0 <__avr32_f64_mul_op1_subnormal+0x36>
8000bf88:	ec 0c 11 20 	rsub	r12,r6,32
8000bf8c:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf90:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bf94:	18 4b       	or	r11,r12
8000bf96:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf9a:	20 b6       	sub	r6,11
8000bf9c:	0c 17       	sub	r7,r6
8000bf9e:	ca ab       	rjmp	8000bef2 <__avr32_f64_mul+0x22>
8000bfa0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfa4:	c6 40       	breq	8000c06c <__avr32_f64_mul_res_zero>
8000bfa6:	30 0a       	mov	r10,0
8000bfa8:	20 b6       	sub	r6,11
8000bfaa:	0c 17       	sub	r7,r6
8000bfac:	ca 3b       	rjmp	8000bef2 <__avr32_f64_mul+0x22>

8000bfae <__avr32_f64_mul_op2_subnormal>:
8000bfae:	e4 19 00 0f 	andh	r9,0xf
8000bfb2:	f0 0c 12 00 	clz	r12,r8
8000bfb6:	f2 05 12 00 	clz	r5,r9
8000bfba:	f7 bc 03 ea 	sublo	r12,-22
8000bfbe:	f8 05 17 30 	movlo	r5,r12
8000bfc2:	f7 b5 02 0a 	subhs	r5,10
8000bfc6:	e0 45 00 20 	cp.w	r5,32
8000bfca:	c0 d4       	brge	8000bfe4 <__avr32_f64_mul_op2_subnormal+0x36>
8000bfcc:	ea 0c 11 20 	rsub	r12,r5,32
8000bfd0:	f2 05 09 49 	lsl	r9,r9,r5
8000bfd4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bfd8:	18 49       	or	r9,r12
8000bfda:	f0 05 09 48 	lsl	r8,r8,r5
8000bfde:	20 25       	sub	r5,2
8000bfe0:	0a 16       	sub	r6,r5
8000bfe2:	c8 fb       	rjmp	8000bf00 <__avr32_f64_mul+0x30>
8000bfe4:	f0 05 09 49 	lsl	r9,r8,r5
8000bfe8:	c4 20       	breq	8000c06c <__avr32_f64_mul_res_zero>
8000bfea:	30 08       	mov	r8,0
8000bfec:	20 25       	sub	r5,2
8000bfee:	0a 16       	sub	r6,r5
8000bff0:	c8 8b       	rjmp	8000bf00 <__avr32_f64_mul+0x30>

8000bff2 <__avr32_f64_mul_op_nan_or_inf>:
8000bff2:	e4 19 00 0f 	andh	r9,0xf
8000bff6:	e4 1b 00 0f 	andh	r11,0xf
8000bffa:	14 4b       	or	r11,r10
8000bffc:	10 49       	or	r9,r8
8000bffe:	e0 47 07 ff 	cp.w	r7,2047
8000c002:	c0 91       	brne	8000c014 <__avr32_f64_mul_op1_not_naninf>
8000c004:	58 0b       	cp.w	r11,0
8000c006:	c3 81       	brne	8000c076 <__avr32_f64_mul_res_nan>
8000c008:	e0 46 07 ff 	cp.w	r6,2047
8000c00c:	c3 81       	brne	8000c07c <__avr32_f64_mul_res_inf>
8000c00e:	58 09       	cp.w	r9,0
8000c010:	c3 60       	breq	8000c07c <__avr32_f64_mul_res_inf>
8000c012:	c3 28       	rjmp	8000c076 <__avr32_f64_mul_res_nan>

8000c014 <__avr32_f64_mul_op1_not_naninf>:
8000c014:	58 09       	cp.w	r9,0
8000c016:	c3 30       	breq	8000c07c <__avr32_f64_mul_res_inf>
8000c018:	c2 f8       	rjmp	8000c076 <__avr32_f64_mul_res_nan>

8000c01a <__avr32_f64_mul_res_subnormal>:
8000c01a:	5c 3c       	neg	r12
8000c01c:	2f fc       	sub	r12,-1
8000c01e:	f1 bc 04 c0 	satu	r12,0x6
8000c022:	e0 4c 00 20 	cp.w	r12,32
8000c026:	c1 14       	brge	8000c048 <__avr32_f64_mul_res_subnormal+0x2e>
8000c028:	f8 08 11 20 	rsub	r8,r12,32
8000c02c:	0e 46       	or	r6,r7
8000c02e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c032:	f4 08 09 49 	lsl	r9,r10,r8
8000c036:	12 47       	or	r7,r9
8000c038:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c03c:	f6 08 09 49 	lsl	r9,r11,r8
8000c040:	12 4a       	or	r10,r9
8000c042:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c046:	c8 3b       	rjmp	8000bf4c <__avr32_f64_mul+0x7c>
8000c048:	f8 08 11 20 	rsub	r8,r12,32
8000c04c:	f9 b9 00 00 	moveq	r9,0
8000c050:	c0 30       	breq	8000c056 <__avr32_f64_mul_res_subnormal+0x3c>
8000c052:	f6 08 09 49 	lsl	r9,r11,r8
8000c056:	0e 46       	or	r6,r7
8000c058:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c05c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c060:	f3 ea 10 07 	or	r7,r9,r10
8000c064:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c068:	30 0b       	mov	r11,0
8000c06a:	c7 1b       	rjmp	8000bf4c <__avr32_f64_mul+0x7c>

8000c06c <__avr32_f64_mul_res_zero>:
8000c06c:	1c 9b       	mov	r11,lr
8000c06e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c072:	30 0a       	mov	r10,0
8000c074:	d8 22       	popm	r4-r7,pc

8000c076 <__avr32_f64_mul_res_nan>:
8000c076:	3f fb       	mov	r11,-1
8000c078:	3f fa       	mov	r10,-1
8000c07a:	d8 22       	popm	r4-r7,pc

8000c07c <__avr32_f64_mul_res_inf>:
8000c07c:	f0 6b 00 00 	mov	r11,-1048576
8000c080:	ed be 00 1f 	bld	lr,0x1f
8000c084:	ef bb 00 1f 	bst	r11,0x1f
8000c088:	30 0a       	mov	r10,0
8000c08a:	d8 22       	popm	r4-r7,pc

8000c08c <__avr32_f64_mul_op1_zero>:
8000c08c:	f7 e9 20 0b 	eor	r11,r11,r9
8000c090:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c094:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c098:	e0 4c 07 ff 	cp.w	r12,2047
8000c09c:	5e 1c       	retne	r12
8000c09e:	3f fa       	mov	r10,-1
8000c0a0:	3f fb       	mov	r11,-1
8000c0a2:	5e fc       	retal	r12

8000c0a4 <__avr32_f64_sub_from_add>:
8000c0a4:	ee 19 80 00 	eorh	r9,0x8000

8000c0a8 <__avr32_f64_sub>:
8000c0a8:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0ac:	e0 86 00 ca 	brmi	8000c240 <__avr32_f64_add_from_sub>
8000c0b0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0b4:	16 9c       	mov	r12,r11
8000c0b6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0ba:	bf db       	cbr	r11,0x1f
8000c0bc:	bf d9       	cbr	r9,0x1f
8000c0be:	10 3a       	cp.w	r10,r8
8000c0c0:	f2 0b 13 00 	cpc	r11,r9
8000c0c4:	c0 92       	brcc	8000c0d6 <__avr32_f64_sub+0x2e>
8000c0c6:	16 97       	mov	r7,r11
8000c0c8:	12 9b       	mov	r11,r9
8000c0ca:	0e 99       	mov	r9,r7
8000c0cc:	14 97       	mov	r7,r10
8000c0ce:	10 9a       	mov	r10,r8
8000c0d0:	0e 98       	mov	r8,r7
8000c0d2:	ee 1c 80 00 	eorh	r12,0x8000
8000c0d6:	f6 07 16 14 	lsr	r7,r11,0x14
8000c0da:	ab 7b       	lsl	r11,0xb
8000c0dc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0e0:	ab 7a       	lsl	r10,0xb
8000c0e2:	bf bb       	sbr	r11,0x1f
8000c0e4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c0e8:	c4 40       	breq	8000c170 <__avr32_f64_sub_opL_subnormal>
8000c0ea:	ab 79       	lsl	r9,0xb
8000c0ec:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c0f0:	ab 78       	lsl	r8,0xb
8000c0f2:	bf b9       	sbr	r9,0x1f

8000c0f4 <__avr32_f64_sub_opL_subnormal_done>:
8000c0f4:	e0 47 07 ff 	cp.w	r7,2047
8000c0f8:	c4 f0       	breq	8000c196 <__avr32_f64_sub_opH_nan_or_inf>
8000c0fa:	0e 26       	rsub	r6,r7
8000c0fc:	c1 20       	breq	8000c120 <__avr32_f64_sub_shift_done>
8000c0fe:	ec 05 11 20 	rsub	r5,r6,32
8000c102:	e0 46 00 20 	cp.w	r6,32
8000c106:	c7 c2       	brcc	8000c1fe <__avr32_f64_sub_longshift>
8000c108:	f0 05 09 4e 	lsl	lr,r8,r5
8000c10c:	f2 05 09 45 	lsl	r5,r9,r5
8000c110:	f0 06 0a 48 	lsr	r8,r8,r6
8000c114:	f2 06 0a 49 	lsr	r9,r9,r6
8000c118:	0a 48       	or	r8,r5
8000c11a:	58 0e       	cp.w	lr,0
8000c11c:	5f 1e       	srne	lr
8000c11e:	1c 48       	or	r8,lr

8000c120 <__avr32_f64_sub_shift_done>:
8000c120:	10 1a       	sub	r10,r8
8000c122:	f6 09 01 4b 	sbc	r11,r11,r9
8000c126:	f6 06 12 00 	clz	r6,r11
8000c12a:	c0 e0       	breq	8000c146 <__avr32_f64_sub_longnormalize_done>
8000c12c:	c7 83       	brcs	8000c21c <__avr32_f64_sub_longnormalize>
8000c12e:	ec 0e 11 20 	rsub	lr,r6,32
8000c132:	f6 06 09 4b 	lsl	r11,r11,r6
8000c136:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c13a:	1c 4b       	or	r11,lr
8000c13c:	f4 06 09 4a 	lsl	r10,r10,r6
8000c140:	0c 17       	sub	r7,r6
8000c142:	e0 8a 00 39 	brle	8000c1b4 <__avr32_f64_sub_subnormal_result>

8000c146 <__avr32_f64_sub_longnormalize_done>:
8000c146:	f4 09 15 15 	lsl	r9,r10,0x15
8000c14a:	ab 9a       	lsr	r10,0xb
8000c14c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c150:	ab 9b       	lsr	r11,0xb
8000c152:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c156:	18 4b       	or	r11,r12

8000c158 <__avr32_f64_sub_round>:
8000c158:	fc 17 80 00 	movh	r7,0x8000
8000c15c:	ed ba 00 00 	bld	r10,0x0
8000c160:	f7 b7 01 ff 	subne	r7,-1
8000c164:	0e 39       	cp.w	r9,r7
8000c166:	5f 29       	srhs	r9
8000c168:	12 0a       	add	r10,r9
8000c16a:	5c 0b       	acr	r11
8000c16c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c170 <__avr32_f64_sub_opL_subnormal>:
8000c170:	ab 79       	lsl	r9,0xb
8000c172:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c176:	ab 78       	lsl	r8,0xb
8000c178:	f3 e8 10 0e 	or	lr,r9,r8
8000c17c:	f9 b6 01 01 	movne	r6,1
8000c180:	ee 0e 11 00 	rsub	lr,r7,0
8000c184:	f9 b7 00 01 	moveq	r7,1
8000c188:	ef bb 00 1f 	bst	r11,0x1f
8000c18c:	f7 ea 10 0e 	or	lr,r11,r10
8000c190:	f9 b7 00 00 	moveq	r7,0
8000c194:	cb 0b       	rjmp	8000c0f4 <__avr32_f64_sub_opL_subnormal_done>

8000c196 <__avr32_f64_sub_opH_nan_or_inf>:
8000c196:	bf db       	cbr	r11,0x1f
8000c198:	f7 ea 10 0e 	or	lr,r11,r10
8000c19c:	c0 81       	brne	8000c1ac <__avr32_f64_sub_return_nan>
8000c19e:	e0 46 07 ff 	cp.w	r6,2047
8000c1a2:	c0 50       	breq	8000c1ac <__avr32_f64_sub_return_nan>
8000c1a4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c1a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1ac <__avr32_f64_sub_return_nan>:
8000c1ac:	3f fa       	mov	r10,-1
8000c1ae:	3f fb       	mov	r11,-1
8000c1b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1b4 <__avr32_f64_sub_subnormal_result>:
8000c1b4:	5c 37       	neg	r7
8000c1b6:	2f f7       	sub	r7,-1
8000c1b8:	f1 b7 04 c0 	satu	r7,0x6
8000c1bc:	e0 47 00 20 	cp.w	r7,32
8000c1c0:	c1 14       	brge	8000c1e2 <__avr32_f64_sub_subnormal_result+0x2e>
8000c1c2:	ee 08 11 20 	rsub	r8,r7,32
8000c1c6:	f4 08 09 49 	lsl	r9,r10,r8
8000c1ca:	5f 16       	srne	r6
8000c1cc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1d0:	0c 4a       	or	r10,r6
8000c1d2:	f6 08 09 49 	lsl	r9,r11,r8
8000c1d6:	f5 e9 10 0a 	or	r10,r10,r9
8000c1da:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c1de:	30 07       	mov	r7,0
8000c1e0:	cb 3b       	rjmp	8000c146 <__avr32_f64_sub_longnormalize_done>
8000c1e2:	ee 08 11 40 	rsub	r8,r7,64
8000c1e6:	f6 08 09 49 	lsl	r9,r11,r8
8000c1ea:	14 49       	or	r9,r10
8000c1ec:	5f 16       	srne	r6
8000c1ee:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c1f2:	0c 4a       	or	r10,r6
8000c1f4:	30 0b       	mov	r11,0
8000c1f6:	30 07       	mov	r7,0
8000c1f8:	ca 7b       	rjmp	8000c146 <__avr32_f64_sub_longnormalize_done>
8000c1fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1fe <__avr32_f64_sub_longshift>:
8000c1fe:	f1 b6 04 c0 	satu	r6,0x6
8000c202:	f0 0e 17 00 	moveq	lr,r8
8000c206:	c0 40       	breq	8000c20e <__avr32_f64_sub_longshift+0x10>
8000c208:	f2 05 09 4e 	lsl	lr,r9,r5
8000c20c:	10 4e       	or	lr,r8
8000c20e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c212:	30 09       	mov	r9,0
8000c214:	58 0e       	cp.w	lr,0
8000c216:	5f 1e       	srne	lr
8000c218:	1c 48       	or	r8,lr
8000c21a:	c8 3b       	rjmp	8000c120 <__avr32_f64_sub_shift_done>

8000c21c <__avr32_f64_sub_longnormalize>:
8000c21c:	f4 06 12 00 	clz	r6,r10
8000c220:	f9 b7 03 00 	movlo	r7,0
8000c224:	f9 b6 03 00 	movlo	r6,0
8000c228:	f9 bc 03 00 	movlo	r12,0
8000c22c:	f7 b6 02 e0 	subhs	r6,-32
8000c230:	f4 06 09 4b 	lsl	r11,r10,r6
8000c234:	30 0a       	mov	r10,0
8000c236:	0c 17       	sub	r7,r6
8000c238:	fe 9a ff be 	brle	8000c1b4 <__avr32_f64_sub_subnormal_result>
8000c23c:	c8 5b       	rjmp	8000c146 <__avr32_f64_sub_longnormalize_done>
8000c23e:	d7 03       	nop

8000c240 <__avr32_f64_add_from_sub>:
8000c240:	ee 19 80 00 	eorh	r9,0x8000

8000c244 <__avr32_f64_add>:
8000c244:	f7 e9 20 0c 	eor	r12,r11,r9
8000c248:	fe 96 ff 2e 	brmi	8000c0a4 <__avr32_f64_sub_from_add>
8000c24c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c250:	16 9c       	mov	r12,r11
8000c252:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c256:	bf db       	cbr	r11,0x1f
8000c258:	bf d9       	cbr	r9,0x1f
8000c25a:	12 3b       	cp.w	r11,r9
8000c25c:	c0 72       	brcc	8000c26a <__avr32_f64_add+0x26>
8000c25e:	16 97       	mov	r7,r11
8000c260:	12 9b       	mov	r11,r9
8000c262:	0e 99       	mov	r9,r7
8000c264:	14 97       	mov	r7,r10
8000c266:	10 9a       	mov	r10,r8
8000c268:	0e 98       	mov	r8,r7
8000c26a:	30 0e       	mov	lr,0
8000c26c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c270:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c274:	b5 ab       	sbr	r11,0x14
8000c276:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c27a:	c6 20       	breq	8000c33e <__avr32_f64_add_op2_subnormal>
8000c27c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c280:	b5 a9       	sbr	r9,0x14
8000c282:	e0 47 07 ff 	cp.w	r7,2047
8000c286:	c2 80       	breq	8000c2d6 <__avr32_f64_add_opH_nan_or_inf>
8000c288:	0e 26       	rsub	r6,r7
8000c28a:	c1 20       	breq	8000c2ae <__avr32_f64_add_shift_done>
8000c28c:	e0 46 00 36 	cp.w	r6,54
8000c290:	c1 52       	brcc	8000c2ba <__avr32_f64_add_res_of_done>
8000c292:	ec 05 11 20 	rsub	r5,r6,32
8000c296:	e0 46 00 20 	cp.w	r6,32
8000c29a:	c3 52       	brcc	8000c304 <__avr32_f64_add_longshift>
8000c29c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c2a0:	f2 05 09 45 	lsl	r5,r9,r5
8000c2a4:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2a8:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2ac:	0a 48       	or	r8,r5

8000c2ae <__avr32_f64_add_shift_done>:
8000c2ae:	10 0a       	add	r10,r8
8000c2b0:	f6 09 00 4b 	adc	r11,r11,r9
8000c2b4:	ed bb 00 15 	bld	r11,0x15
8000c2b8:	c3 40       	breq	8000c320 <__avr32_f64_add_res_of>

8000c2ba <__avr32_f64_add_res_of_done>:
8000c2ba:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2be:	18 4b       	or	r11,r12

8000c2c0 <__avr32_f64_add_round>:
8000c2c0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c2c4:	18 4e       	or	lr,r12
8000c2c6:	ee 1e 80 00 	eorh	lr,0x8000
8000c2ca:	f1 be 04 20 	satu	lr,0x1
8000c2ce:	1c 0a       	add	r10,lr
8000c2d0:	5c 0b       	acr	r11
8000c2d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2d6 <__avr32_f64_add_opH_nan_or_inf>:
8000c2d6:	b5 cb       	cbr	r11,0x14
8000c2d8:	f7 ea 10 0e 	or	lr,r11,r10
8000c2dc:	c1 01       	brne	8000c2fc <__avr32_f64_add_return_nan>
8000c2de:	e0 46 07 ff 	cp.w	r6,2047
8000c2e2:	c0 30       	breq	8000c2e8 <__avr32_f64_add_opL_nan_or_inf>
8000c2e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e8 <__avr32_f64_add_opL_nan_or_inf>:
8000c2e8:	b5 c9       	cbr	r9,0x14
8000c2ea:	f3 e8 10 0e 	or	lr,r9,r8
8000c2ee:	c0 71       	brne	8000c2fc <__avr32_f64_add_return_nan>
8000c2f0:	30 0a       	mov	r10,0
8000c2f2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c2f6:	18 4b       	or	r11,r12
8000c2f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2fc <__avr32_f64_add_return_nan>:
8000c2fc:	3f fa       	mov	r10,-1
8000c2fe:	3f fb       	mov	r11,-1
8000c300:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c304 <__avr32_f64_add_longshift>:
8000c304:	f1 b6 04 c0 	satu	r6,0x6
8000c308:	f0 0e 17 00 	moveq	lr,r8
8000c30c:	c0 60       	breq	8000c318 <__avr32_f64_add_longshift+0x14>
8000c30e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c312:	58 08       	cp.w	r8,0
8000c314:	5f 18       	srne	r8
8000c316:	10 4e       	or	lr,r8
8000c318:	f2 06 0a 48 	lsr	r8,r9,r6
8000c31c:	30 09       	mov	r9,0
8000c31e:	cc 8b       	rjmp	8000c2ae <__avr32_f64_add_shift_done>

8000c320 <__avr32_f64_add_res_of>:
8000c320:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c324:	a1 9b       	lsr	r11,0x1
8000c326:	5d 0a       	ror	r10
8000c328:	5d 0e       	ror	lr
8000c32a:	2f f7       	sub	r7,-1
8000c32c:	e0 47 07 ff 	cp.w	r7,2047
8000c330:	f9 ba 00 00 	moveq	r10,0
8000c334:	f9 bb 00 00 	moveq	r11,0
8000c338:	f9 be 00 00 	moveq	lr,0
8000c33c:	cb fb       	rjmp	8000c2ba <__avr32_f64_add_res_of_done>

8000c33e <__avr32_f64_add_op2_subnormal>:
8000c33e:	30 16       	mov	r6,1
8000c340:	58 07       	cp.w	r7,0
8000c342:	ca 01       	brne	8000c282 <__avr32_f64_add+0x3e>
8000c344:	b5 cb       	cbr	r11,0x14
8000c346:	10 0a       	add	r10,r8
8000c348:	f6 09 00 4b 	adc	r11,r11,r9
8000c34c:	18 4b       	or	r11,r12
8000c34e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c352:	d7 03       	nop

8000c354 <__avr32_f64_to_u32>:
8000c354:	58 0b       	cp.w	r11,0
8000c356:	5e 6d       	retmi	0

8000c358 <__avr32_f64_to_s32>:
8000c358:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c35c:	b5 9c       	lsr	r12,0x15
8000c35e:	e0 2c 03 ff 	sub	r12,1023
8000c362:	5e 3d       	retlo	0
8000c364:	f8 0c 11 1f 	rsub	r12,r12,31
8000c368:	16 99       	mov	r9,r11
8000c36a:	ab 7b       	lsl	r11,0xb
8000c36c:	bf bb       	sbr	r11,0x1f
8000c36e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c372:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c376:	a1 79       	lsl	r9,0x1
8000c378:	5e 2b       	reths	r11
8000c37a:	5c 3b       	neg	r11
8000c37c:	5e fb       	retal	r11

8000c37e <__avr32_u32_to_f64>:
8000c37e:	f8 cb 00 00 	sub	r11,r12,0
8000c382:	30 0c       	mov	r12,0
8000c384:	c0 38       	rjmp	8000c38a <__avr32_s32_to_f64+0x4>

8000c386 <__avr32_s32_to_f64>:
8000c386:	18 9b       	mov	r11,r12
8000c388:	5c 4b       	abs	r11
8000c38a:	30 0a       	mov	r10,0
8000c38c:	5e 0b       	reteq	r11
8000c38e:	d4 01       	pushm	lr
8000c390:	e0 69 04 1e 	mov	r9,1054
8000c394:	f6 08 12 00 	clz	r8,r11
8000c398:	c1 70       	breq	8000c3c6 <__avr32_s32_to_f64+0x40>
8000c39a:	c0 c3       	brcs	8000c3b2 <__avr32_s32_to_f64+0x2c>
8000c39c:	f0 0e 11 20 	rsub	lr,r8,32
8000c3a0:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3a4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c3a8:	1c 4b       	or	r11,lr
8000c3aa:	f4 08 09 4a 	lsl	r10,r10,r8
8000c3ae:	10 19       	sub	r9,r8
8000c3b0:	c0 b8       	rjmp	8000c3c6 <__avr32_s32_to_f64+0x40>
8000c3b2:	f4 08 12 00 	clz	r8,r10
8000c3b6:	f9 b8 03 00 	movlo	r8,0
8000c3ba:	f7 b8 02 e0 	subhs	r8,-32
8000c3be:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3c2:	30 0a       	mov	r10,0
8000c3c4:	10 19       	sub	r9,r8
8000c3c6:	58 09       	cp.w	r9,0
8000c3c8:	e0 89 00 30 	brgt	8000c428 <__avr32_s32_to_f64+0xa2>
8000c3cc:	5c 39       	neg	r9
8000c3ce:	2f f9       	sub	r9,-1
8000c3d0:	e0 49 00 36 	cp.w	r9,54
8000c3d4:	c0 43       	brcs	8000c3dc <__avr32_s32_to_f64+0x56>
8000c3d6:	30 0b       	mov	r11,0
8000c3d8:	30 0a       	mov	r10,0
8000c3da:	c2 68       	rjmp	8000c426 <__avr32_s32_to_f64+0xa0>
8000c3dc:	2f 69       	sub	r9,-10
8000c3de:	f2 08 11 20 	rsub	r8,r9,32
8000c3e2:	e0 49 00 20 	cp.w	r9,32
8000c3e6:	c0 b2       	brcc	8000c3fc <__avr32_s32_to_f64+0x76>
8000c3e8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c3ec:	f6 08 09 48 	lsl	r8,r11,r8
8000c3f0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c3f4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c3f8:	10 4b       	or	r11,r8
8000c3fa:	c0 88       	rjmp	8000c40a <__avr32_s32_to_f64+0x84>
8000c3fc:	f6 08 09 4e 	lsl	lr,r11,r8
8000c400:	14 4e       	or	lr,r10
8000c402:	16 9a       	mov	r10,r11
8000c404:	30 0b       	mov	r11,0
8000c406:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c40a:	ed ba 00 00 	bld	r10,0x0
8000c40e:	c0 92       	brcc	8000c420 <__avr32_s32_to_f64+0x9a>
8000c410:	1c 7e       	tst	lr,lr
8000c412:	c0 41       	brne	8000c41a <__avr32_s32_to_f64+0x94>
8000c414:	ed ba 00 01 	bld	r10,0x1
8000c418:	c0 42       	brcc	8000c420 <__avr32_s32_to_f64+0x9a>
8000c41a:	2f fa       	sub	r10,-1
8000c41c:	f7 bb 02 ff 	subhs	r11,-1
8000c420:	5c fc       	rol	r12
8000c422:	5d 0b       	ror	r11
8000c424:	5d 0a       	ror	r10
8000c426:	d8 02       	popm	pc
8000c428:	e0 68 03 ff 	mov	r8,1023
8000c42c:	ed ba 00 0b 	bld	r10,0xb
8000c430:	f7 b8 00 ff 	subeq	r8,-1
8000c434:	10 0a       	add	r10,r8
8000c436:	5c 0b       	acr	r11
8000c438:	f7 b9 03 fe 	sublo	r9,-2
8000c43c:	e0 49 07 ff 	cp.w	r9,2047
8000c440:	c0 55       	brlt	8000c44a <__avr32_s32_to_f64+0xc4>
8000c442:	30 0a       	mov	r10,0
8000c444:	fc 1b ff e0 	movh	r11,0xffe0
8000c448:	c0 c8       	rjmp	8000c460 <__floatsidf_return_op1>
8000c44a:	ed bb 00 1f 	bld	r11,0x1f
8000c44e:	f7 b9 01 01 	subne	r9,1
8000c452:	ab 9a       	lsr	r10,0xb
8000c454:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c458:	a1 7b       	lsl	r11,0x1
8000c45a:	ab 9b       	lsr	r11,0xb
8000c45c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c460 <__floatsidf_return_op1>:
8000c460:	a1 7c       	lsl	r12,0x1
8000c462:	5d 0b       	ror	r11
8000c464:	d8 02       	popm	pc

8000c466 <__avr32_f64_cmp_eq>:
8000c466:	10 3a       	cp.w	r10,r8
8000c468:	f2 0b 13 00 	cpc	r11,r9
8000c46c:	c0 80       	breq	8000c47c <__avr32_f64_cmp_eq+0x16>
8000c46e:	a1 7b       	lsl	r11,0x1
8000c470:	a1 79       	lsl	r9,0x1
8000c472:	14 4b       	or	r11,r10
8000c474:	12 4b       	or	r11,r9
8000c476:	10 4b       	or	r11,r8
8000c478:	5e 0f       	reteq	1
8000c47a:	5e fd       	retal	0
8000c47c:	a1 7b       	lsl	r11,0x1
8000c47e:	fc 1c ff e0 	movh	r12,0xffe0
8000c482:	58 0a       	cp.w	r10,0
8000c484:	f8 0b 13 00 	cpc	r11,r12
8000c488:	5e 8f       	retls	1
8000c48a:	5e fd       	retal	0

8000c48c <__avr32_f64_cmp_ge>:
8000c48c:	1a de       	st.w	--sp,lr
8000c48e:	1a d7       	st.w	--sp,r7
8000c490:	a1 7b       	lsl	r11,0x1
8000c492:	5f 3c       	srlo	r12
8000c494:	a1 79       	lsl	r9,0x1
8000c496:	5f 37       	srlo	r7
8000c498:	5c fc       	rol	r12
8000c49a:	fc 1e ff e0 	movh	lr,0xffe0
8000c49e:	58 0a       	cp.w	r10,0
8000c4a0:	fc 0b 13 00 	cpc	r11,lr
8000c4a4:	e0 8b 00 1d 	brhi	8000c4de <__avr32_f64_cmp_ge+0x52>
8000c4a8:	58 08       	cp.w	r8,0
8000c4aa:	fc 09 13 00 	cpc	r9,lr
8000c4ae:	e0 8b 00 18 	brhi	8000c4de <__avr32_f64_cmp_ge+0x52>
8000c4b2:	58 0b       	cp.w	r11,0
8000c4b4:	f5 ba 00 00 	subfeq	r10,0
8000c4b8:	c1 50       	breq	8000c4e2 <__avr32_f64_cmp_ge+0x56>
8000c4ba:	1b 07       	ld.w	r7,sp++
8000c4bc:	1b 0e       	ld.w	lr,sp++
8000c4be:	58 3c       	cp.w	r12,3
8000c4c0:	c0 a0       	breq	8000c4d4 <__avr32_f64_cmp_ge+0x48>
8000c4c2:	58 1c       	cp.w	r12,1
8000c4c4:	c0 33       	brcs	8000c4ca <__avr32_f64_cmp_ge+0x3e>
8000c4c6:	5e 0f       	reteq	1
8000c4c8:	5e 1d       	retne	0
8000c4ca:	10 3a       	cp.w	r10,r8
8000c4cc:	f2 0b 13 00 	cpc	r11,r9
8000c4d0:	5e 2f       	reths	1
8000c4d2:	5e 3d       	retlo	0
8000c4d4:	14 38       	cp.w	r8,r10
8000c4d6:	f6 09 13 00 	cpc	r9,r11
8000c4da:	5e 2f       	reths	1
8000c4dc:	5e 3d       	retlo	0
8000c4de:	1b 07       	ld.w	r7,sp++
8000c4e0:	d8 0a       	popm	pc,r12=0
8000c4e2:	58 17       	cp.w	r7,1
8000c4e4:	5f 0c       	sreq	r12
8000c4e6:	58 09       	cp.w	r9,0
8000c4e8:	f5 b8 00 00 	subfeq	r8,0
8000c4ec:	1b 07       	ld.w	r7,sp++
8000c4ee:	1b 0e       	ld.w	lr,sp++
8000c4f0:	5e 0f       	reteq	1
8000c4f2:	5e fc       	retal	r12

8000c4f4 <__avr32_f64_cmp_lt>:
8000c4f4:	1a de       	st.w	--sp,lr
8000c4f6:	1a d7       	st.w	--sp,r7
8000c4f8:	a1 7b       	lsl	r11,0x1
8000c4fa:	5f 3c       	srlo	r12
8000c4fc:	a1 79       	lsl	r9,0x1
8000c4fe:	5f 37       	srlo	r7
8000c500:	5c fc       	rol	r12
8000c502:	fc 1e ff e0 	movh	lr,0xffe0
8000c506:	58 0a       	cp.w	r10,0
8000c508:	fc 0b 13 00 	cpc	r11,lr
8000c50c:	e0 8b 00 1d 	brhi	8000c546 <__avr32_f64_cmp_lt+0x52>
8000c510:	58 08       	cp.w	r8,0
8000c512:	fc 09 13 00 	cpc	r9,lr
8000c516:	e0 8b 00 18 	brhi	8000c546 <__avr32_f64_cmp_lt+0x52>
8000c51a:	58 0b       	cp.w	r11,0
8000c51c:	f5 ba 00 00 	subfeq	r10,0
8000c520:	c1 50       	breq	8000c54a <__avr32_f64_cmp_lt+0x56>
8000c522:	1b 07       	ld.w	r7,sp++
8000c524:	1b 0e       	ld.w	lr,sp++
8000c526:	58 3c       	cp.w	r12,3
8000c528:	c0 a0       	breq	8000c53c <__avr32_f64_cmp_lt+0x48>
8000c52a:	58 1c       	cp.w	r12,1
8000c52c:	c0 33       	brcs	8000c532 <__avr32_f64_cmp_lt+0x3e>
8000c52e:	5e 0d       	reteq	0
8000c530:	5e 1f       	retne	1
8000c532:	10 3a       	cp.w	r10,r8
8000c534:	f2 0b 13 00 	cpc	r11,r9
8000c538:	5e 2d       	reths	0
8000c53a:	5e 3f       	retlo	1
8000c53c:	14 38       	cp.w	r8,r10
8000c53e:	f6 09 13 00 	cpc	r9,r11
8000c542:	5e 2d       	reths	0
8000c544:	5e 3f       	retlo	1
8000c546:	1b 07       	ld.w	r7,sp++
8000c548:	d8 0a       	popm	pc,r12=0
8000c54a:	58 17       	cp.w	r7,1
8000c54c:	5f 1c       	srne	r12
8000c54e:	58 09       	cp.w	r9,0
8000c550:	f5 b8 00 00 	subfeq	r8,0
8000c554:	1b 07       	ld.w	r7,sp++
8000c556:	1b 0e       	ld.w	lr,sp++
8000c558:	5e 0d       	reteq	0
8000c55a:	5e fc       	retal	r12

8000c55c <__avr32_f64_div>:
8000c55c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c560:	f7 e9 20 0e 	eor	lr,r11,r9
8000c564:	f6 07 16 14 	lsr	r7,r11,0x14
8000c568:	a9 7b       	lsl	r11,0x9
8000c56a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c56e:	a9 7a       	lsl	r10,0x9
8000c570:	bd bb       	sbr	r11,0x1d
8000c572:	e4 1b 3f ff 	andh	r11,0x3fff
8000c576:	ab d7       	cbr	r7,0xb
8000c578:	e0 80 00 cc 	breq	8000c710 <__avr32_f64_div_round_subnormal+0x54>
8000c57c:	e0 47 07 ff 	cp.w	r7,2047
8000c580:	e0 84 00 b5 	brge	8000c6ea <__avr32_f64_div_round_subnormal+0x2e>
8000c584:	f2 06 16 14 	lsr	r6,r9,0x14
8000c588:	a9 79       	lsl	r9,0x9
8000c58a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c58e:	a9 78       	lsl	r8,0x9
8000c590:	bd b9       	sbr	r9,0x1d
8000c592:	e4 19 3f ff 	andh	r9,0x3fff
8000c596:	ab d6       	cbr	r6,0xb
8000c598:	e0 80 00 e2 	breq	8000c75c <__avr32_f64_div_round_subnormal+0xa0>
8000c59c:	e0 46 07 ff 	cp.w	r6,2047
8000c5a0:	e0 84 00 b2 	brge	8000c704 <__avr32_f64_div_round_subnormal+0x48>
8000c5a4:	0c 17       	sub	r7,r6
8000c5a6:	fe 37 fc 01 	sub	r7,-1023
8000c5aa:	fc 1c 80 00 	movh	r12,0x8000
8000c5ae:	f8 03 16 01 	lsr	r3,r12,0x1
8000c5b2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c5b6:	5c d4       	com	r4
8000c5b8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5bc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5c0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5c8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5cc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5d0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5d4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5e8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5ec:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5f0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5f4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5f8:	02 04       	add	r4,r1
8000c5fa:	5c 05       	acr	r5
8000c5fc:	a3 65       	lsl	r5,0x2
8000c5fe:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c602:	a3 64       	lsl	r4,0x2
8000c604:	5c 34       	neg	r4
8000c606:	f8 05 01 45 	sbc	r5,r12,r5
8000c60a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c60e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c612:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c616:	02 04       	add	r4,r1
8000c618:	5c 05       	acr	r5
8000c61a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c61e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c622:	e8 02 15 02 	lsl	r2,r4,0x2
8000c626:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c62a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c62e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c632:	02 04       	add	r4,r1
8000c634:	5c 05       	acr	r5
8000c636:	a3 65       	lsl	r5,0x2
8000c638:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c63c:	a3 64       	lsl	r4,0x2
8000c63e:	5c 34       	neg	r4
8000c640:	f8 05 01 45 	sbc	r5,r12,r5
8000c644:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c648:	e4 05 07 40 	macu.d	r0,r2,r5
8000c64c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c650:	02 04       	add	r4,r1
8000c652:	5c 05       	acr	r5
8000c654:	ea 03 15 02 	lsl	r3,r5,0x2
8000c658:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c65c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c660:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c664:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c668:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c66c:	02 02       	add	r2,r1
8000c66e:	5c 03       	acr	r3
8000c670:	ed b3 00 1c 	bld	r3,0x1c
8000c674:	c0 90       	breq	8000c686 <__avr32_f64_div+0x12a>
8000c676:	a1 72       	lsl	r2,0x1
8000c678:	5c f3       	rol	r3
8000c67a:	20 17       	sub	r7,1
8000c67c:	a3 9a       	lsr	r10,0x3
8000c67e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c682:	a3 9b       	lsr	r11,0x3
8000c684:	c0 58       	rjmp	8000c68e <__avr32_f64_div+0x132>
8000c686:	a5 8a       	lsr	r10,0x4
8000c688:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c68c:	a5 8b       	lsr	r11,0x4
8000c68e:	58 07       	cp.w	r7,0
8000c690:	e0 8a 00 8b 	brle	8000c7a6 <__avr32_f64_div_res_subnormal>
8000c694:	e0 12 ff 00 	andl	r2,0xff00
8000c698:	e8 12 00 80 	orl	r2,0x80
8000c69c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6a0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6a4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6a8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6ac:	00 05       	add	r5,r0
8000c6ae:	f0 01 00 48 	adc	r8,r8,r1
8000c6b2:	5c 09       	acr	r9
8000c6b4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6b8:	58 04       	cp.w	r4,0
8000c6ba:	5c 25       	cpc	r5

8000c6bc <__avr32_f64_div_round_subnormal>:
8000c6bc:	f4 08 13 00 	cpc	r8,r10
8000c6c0:	f6 09 13 00 	cpc	r9,r11
8000c6c4:	5f 36       	srlo	r6
8000c6c6:	f8 06 17 00 	moveq	r6,r12
8000c6ca:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c6ce:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c6d2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c6d6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c6da:	ed be 00 1f 	bld	lr,0x1f
8000c6de:	ef bb 00 1f 	bst	r11,0x1f
8000c6e2:	0c 0a       	add	r10,r6
8000c6e4:	5c 0b       	acr	r11
8000c6e6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c6ea:	e4 1b 00 0f 	andh	r11,0xf
8000c6ee:	14 4b       	or	r11,r10
8000c6f0:	e0 81 00 a7 	brne	8000c83e <__avr32_f64_div_res_subnormal+0x98>
8000c6f4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c6f8:	ab d6       	cbr	r6,0xb
8000c6fa:	e0 46 07 ff 	cp.w	r6,2047
8000c6fe:	e0 81 00 a4 	brne	8000c846 <__avr32_f64_div_res_subnormal+0xa0>
8000c702:	c9 e8       	rjmp	8000c83e <__avr32_f64_div_res_subnormal+0x98>
8000c704:	e4 19 00 0f 	andh	r9,0xf
8000c708:	10 49       	or	r9,r8
8000c70a:	e0 81 00 9a 	brne	8000c83e <__avr32_f64_div_res_subnormal+0x98>
8000c70e:	c9 28       	rjmp	8000c832 <__avr32_f64_div_res_subnormal+0x8c>
8000c710:	a3 7b       	lsl	r11,0x3
8000c712:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c716:	a3 7a       	lsl	r10,0x3
8000c718:	f5 eb 10 04 	or	r4,r10,r11
8000c71c:	e0 80 00 a0 	breq	8000c85c <__avr32_f64_div_op1_zero>
8000c720:	f6 04 12 00 	clz	r4,r11
8000c724:	c1 70       	breq	8000c752 <__avr32_f64_div_round_subnormal+0x96>
8000c726:	c0 c3       	brcs	8000c73e <__avr32_f64_div_round_subnormal+0x82>
8000c728:	e8 05 11 20 	rsub	r5,r4,32
8000c72c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c730:	f4 05 0a 45 	lsr	r5,r10,r5
8000c734:	0a 4b       	or	r11,r5
8000c736:	f4 04 09 4a 	lsl	r10,r10,r4
8000c73a:	08 17       	sub	r7,r4
8000c73c:	c0 b8       	rjmp	8000c752 <__avr32_f64_div_round_subnormal+0x96>
8000c73e:	f4 04 12 00 	clz	r4,r10
8000c742:	f9 b4 03 00 	movlo	r4,0
8000c746:	f7 b4 02 e0 	subhs	r4,-32
8000c74a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c74e:	30 0a       	mov	r10,0
8000c750:	08 17       	sub	r7,r4
8000c752:	a3 8a       	lsr	r10,0x2
8000c754:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c758:	a3 8b       	lsr	r11,0x2
8000c75a:	c1 1b       	rjmp	8000c57c <__avr32_f64_div+0x20>
8000c75c:	a3 79       	lsl	r9,0x3
8000c75e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c762:	a3 78       	lsl	r8,0x3
8000c764:	f3 e8 10 04 	or	r4,r9,r8
8000c768:	c6 f0       	breq	8000c846 <__avr32_f64_div_res_subnormal+0xa0>
8000c76a:	f2 04 12 00 	clz	r4,r9
8000c76e:	c1 70       	breq	8000c79c <__avr32_f64_div_round_subnormal+0xe0>
8000c770:	c0 c3       	brcs	8000c788 <__avr32_f64_div_round_subnormal+0xcc>
8000c772:	e8 05 11 20 	rsub	r5,r4,32
8000c776:	f2 04 09 49 	lsl	r9,r9,r4
8000c77a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c77e:	0a 49       	or	r9,r5
8000c780:	f0 04 09 48 	lsl	r8,r8,r4
8000c784:	08 16       	sub	r6,r4
8000c786:	c0 b8       	rjmp	8000c79c <__avr32_f64_div_round_subnormal+0xe0>
8000c788:	f0 04 12 00 	clz	r4,r8
8000c78c:	f9 b4 03 00 	movlo	r4,0
8000c790:	f7 b4 02 e0 	subhs	r4,-32
8000c794:	f0 04 09 49 	lsl	r9,r8,r4
8000c798:	30 08       	mov	r8,0
8000c79a:	08 16       	sub	r6,r4
8000c79c:	a3 88       	lsr	r8,0x2
8000c79e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c7a2:	a3 89       	lsr	r9,0x2
8000c7a4:	cf ca       	rjmp	8000c59c <__avr32_f64_div+0x40>

8000c7a6 <__avr32_f64_div_res_subnormal>:
8000c7a6:	5c 37       	neg	r7
8000c7a8:	2f f7       	sub	r7,-1
8000c7aa:	f1 b7 04 c0 	satu	r7,0x6
8000c7ae:	e0 47 00 20 	cp.w	r7,32
8000c7b2:	c1 54       	brge	8000c7dc <__avr32_f64_div_res_subnormal+0x36>
8000c7b4:	ee 06 11 20 	rsub	r6,r7,32
8000c7b8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7bc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7c0:	18 42       	or	r2,r12
8000c7c2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c7c6:	f4 06 09 41 	lsl	r1,r10,r6
8000c7ca:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c7ce:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7d2:	18 4a       	or	r10,r12
8000c7d4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c7d8:	30 00       	mov	r0,0
8000c7da:	c1 58       	rjmp	8000c804 <__avr32_f64_div_res_subnormal+0x5e>
8000c7dc:	ee 06 11 20 	rsub	r6,r7,32
8000c7e0:	f9 b0 00 00 	moveq	r0,0
8000c7e4:	f9 bc 00 00 	moveq	r12,0
8000c7e8:	c0 50       	breq	8000c7f2 <__avr32_f64_div_res_subnormal+0x4c>
8000c7ea:	f4 06 09 40 	lsl	r0,r10,r6
8000c7ee:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7f2:	e6 07 0a 42 	lsr	r2,r3,r7
8000c7f6:	30 03       	mov	r3,0
8000c7f8:	f4 07 0a 41 	lsr	r1,r10,r7
8000c7fc:	18 41       	or	r1,r12
8000c7fe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c802:	30 0b       	mov	r11,0
8000c804:	e0 12 ff 00 	andl	r2,0xff00
8000c808:	e8 12 00 80 	orl	r2,0x80
8000c80c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c810:	e4 09 07 46 	macu.d	r6,r2,r9
8000c814:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c818:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c81c:	0c 05       	add	r5,r6
8000c81e:	f0 07 00 48 	adc	r8,r8,r7
8000c822:	5c 09       	acr	r9
8000c824:	30 07       	mov	r7,0
8000c826:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c82a:	00 34       	cp.w	r4,r0
8000c82c:	e2 05 13 00 	cpc	r5,r1
8000c830:	c4 6b       	rjmp	8000c6bc <__avr32_f64_div_round_subnormal>
8000c832:	1c 9b       	mov	r11,lr
8000c834:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c838:	30 0a       	mov	r10,0
8000c83a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c83e:	3f fb       	mov	r11,-1
8000c840:	30 0a       	mov	r10,0
8000c842:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c846:	f5 eb 10 04 	or	r4,r10,r11
8000c84a:	c0 90       	breq	8000c85c <__avr32_f64_div_op1_zero>
8000c84c:	1c 9b       	mov	r11,lr
8000c84e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c852:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c856:	30 0a       	mov	r10,0
8000c858:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c85c <__avr32_f64_div_op1_zero>:
8000c85c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c860:	ce f0       	breq	8000c83e <__avr32_f64_div_res_subnormal+0x98>
8000c862:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c866:	e0 44 07 ff 	cp.w	r4,2047
8000c86a:	ce 41       	brne	8000c832 <__avr32_f64_div_res_subnormal+0x8c>
8000c86c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c870:	ce 10       	breq	8000c832 <__avr32_f64_div_res_subnormal+0x8c>
8000c872:	ce 6b       	rjmp	8000c83e <__avr32_f64_div_res_subnormal+0x98>

8000c874 <__avr32_udiv64>:
8000c874:	d4 31       	pushm	r0-r7,lr
8000c876:	1a 97       	mov	r7,sp
8000c878:	20 3d       	sub	sp,12
8000c87a:	10 9c       	mov	r12,r8
8000c87c:	12 9e       	mov	lr,r9
8000c87e:	14 93       	mov	r3,r10
8000c880:	58 09       	cp.w	r9,0
8000c882:	e0 81 00 bd 	brne	8000c9fc <__avr32_udiv64+0x188>
8000c886:	16 38       	cp.w	r8,r11
8000c888:	e0 88 00 40 	brls	8000c908 <__avr32_udiv64+0x94>
8000c88c:	f0 08 12 00 	clz	r8,r8
8000c890:	c0 d0       	breq	8000c8aa <__avr32_udiv64+0x36>
8000c892:	f6 08 09 4b 	lsl	r11,r11,r8
8000c896:	f0 09 11 20 	rsub	r9,r8,32
8000c89a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c89e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c8a2:	f4 08 09 43 	lsl	r3,r10,r8
8000c8a6:	f3 eb 10 0b 	or	r11,r9,r11
8000c8aa:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c8ae:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c8b2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c8b6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8ba:	00 99       	mov	r9,r0
8000c8bc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8c0:	e0 0a 02 48 	mul	r8,r0,r10
8000c8c4:	10 3b       	cp.w	r11,r8
8000c8c6:	c0 a2       	brcc	8000c8da <__avr32_udiv64+0x66>
8000c8c8:	20 19       	sub	r9,1
8000c8ca:	18 0b       	add	r11,r12
8000c8cc:	18 3b       	cp.w	r11,r12
8000c8ce:	c0 63       	brcs	8000c8da <__avr32_udiv64+0x66>
8000c8d0:	10 3b       	cp.w	r11,r8
8000c8d2:	f7 b9 03 01 	sublo	r9,1
8000c8d6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8da:	f6 08 01 01 	sub	r1,r11,r8
8000c8de:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8e2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c8e6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8ea:	00 98       	mov	r8,r0
8000c8ec:	e0 0a 02 4a 	mul	r10,r0,r10
8000c8f0:	14 33       	cp.w	r3,r10
8000c8f2:	c0 82       	brcc	8000c902 <__avr32_udiv64+0x8e>
8000c8f4:	20 18       	sub	r8,1
8000c8f6:	18 03       	add	r3,r12
8000c8f8:	18 33       	cp.w	r3,r12
8000c8fa:	c0 43       	brcs	8000c902 <__avr32_udiv64+0x8e>
8000c8fc:	14 33       	cp.w	r3,r10
8000c8fe:	f7 b8 03 01 	sublo	r8,1
8000c902:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c906:	cd f8       	rjmp	8000cac4 <__avr32_udiv64+0x250>
8000c908:	58 08       	cp.w	r8,0
8000c90a:	c0 51       	brne	8000c914 <__avr32_udiv64+0xa0>
8000c90c:	30 19       	mov	r9,1
8000c90e:	f2 08 0d 08 	divu	r8,r9,r8
8000c912:	10 9c       	mov	r12,r8
8000c914:	f8 06 12 00 	clz	r6,r12
8000c918:	c0 41       	brne	8000c920 <__avr32_udiv64+0xac>
8000c91a:	18 1b       	sub	r11,r12
8000c91c:	30 19       	mov	r9,1
8000c91e:	c4 08       	rjmp	8000c99e <__avr32_udiv64+0x12a>
8000c920:	ec 01 11 20 	rsub	r1,r6,32
8000c924:	f4 01 0a 49 	lsr	r9,r10,r1
8000c928:	f8 06 09 4c 	lsl	r12,r12,r6
8000c92c:	f6 06 09 48 	lsl	r8,r11,r6
8000c930:	f6 01 0a 41 	lsr	r1,r11,r1
8000c934:	f3 e8 10 08 	or	r8,r9,r8
8000c938:	f8 03 16 10 	lsr	r3,r12,0x10
8000c93c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c940:	e2 03 0d 00 	divu	r0,r1,r3
8000c944:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c948:	00 9e       	mov	lr,r0
8000c94a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c94e:	e0 05 02 49 	mul	r9,r0,r5
8000c952:	12 3b       	cp.w	r11,r9
8000c954:	c0 a2       	brcc	8000c968 <__avr32_udiv64+0xf4>
8000c956:	20 1e       	sub	lr,1
8000c958:	18 0b       	add	r11,r12
8000c95a:	18 3b       	cp.w	r11,r12
8000c95c:	c0 63       	brcs	8000c968 <__avr32_udiv64+0xf4>
8000c95e:	12 3b       	cp.w	r11,r9
8000c960:	f7 be 03 01 	sublo	lr,1
8000c964:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c968:	12 1b       	sub	r11,r9
8000c96a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c96e:	f6 03 0d 02 	divu	r2,r11,r3
8000c972:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c976:	04 99       	mov	r9,r2
8000c978:	e4 05 02 4b 	mul	r11,r2,r5
8000c97c:	16 38       	cp.w	r8,r11
8000c97e:	c0 a2       	brcc	8000c992 <__avr32_udiv64+0x11e>
8000c980:	20 19       	sub	r9,1
8000c982:	18 08       	add	r8,r12
8000c984:	18 38       	cp.w	r8,r12
8000c986:	c0 63       	brcs	8000c992 <__avr32_udiv64+0x11e>
8000c988:	16 38       	cp.w	r8,r11
8000c98a:	f7 b9 03 01 	sublo	r9,1
8000c98e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c992:	f4 06 09 43 	lsl	r3,r10,r6
8000c996:	f0 0b 01 0b 	sub	r11,r8,r11
8000c99a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c99e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c9a2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c9a6:	f6 06 0d 00 	divu	r0,r11,r6
8000c9aa:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9ae:	00 9a       	mov	r10,r0
8000c9b0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9b4:	e0 0e 02 48 	mul	r8,r0,lr
8000c9b8:	10 3b       	cp.w	r11,r8
8000c9ba:	c0 a2       	brcc	8000c9ce <__avr32_udiv64+0x15a>
8000c9bc:	20 1a       	sub	r10,1
8000c9be:	18 0b       	add	r11,r12
8000c9c0:	18 3b       	cp.w	r11,r12
8000c9c2:	c0 63       	brcs	8000c9ce <__avr32_udiv64+0x15a>
8000c9c4:	10 3b       	cp.w	r11,r8
8000c9c6:	f7 ba 03 01 	sublo	r10,1
8000c9ca:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9ce:	f6 08 01 01 	sub	r1,r11,r8
8000c9d2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c9d6:	e2 06 0d 00 	divu	r0,r1,r6
8000c9da:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c9de:	00 98       	mov	r8,r0
8000c9e0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c9e4:	16 33       	cp.w	r3,r11
8000c9e6:	c0 82       	brcc	8000c9f6 <__avr32_udiv64+0x182>
8000c9e8:	20 18       	sub	r8,1
8000c9ea:	18 03       	add	r3,r12
8000c9ec:	18 33       	cp.w	r3,r12
8000c9ee:	c0 43       	brcs	8000c9f6 <__avr32_udiv64+0x182>
8000c9f0:	16 33       	cp.w	r3,r11
8000c9f2:	f7 b8 03 01 	sublo	r8,1
8000c9f6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c9fa:	c6 98       	rjmp	8000cacc <__avr32_udiv64+0x258>
8000c9fc:	16 39       	cp.w	r9,r11
8000c9fe:	e0 8b 00 65 	brhi	8000cac8 <__avr32_udiv64+0x254>
8000ca02:	f2 09 12 00 	clz	r9,r9
8000ca06:	c0 b1       	brne	8000ca1c <__avr32_udiv64+0x1a8>
8000ca08:	10 3a       	cp.w	r10,r8
8000ca0a:	5f 2a       	srhs	r10
8000ca0c:	1c 3b       	cp.w	r11,lr
8000ca0e:	5f b8       	srhi	r8
8000ca10:	10 4a       	or	r10,r8
8000ca12:	f2 0a 18 00 	cp.b	r10,r9
8000ca16:	c5 90       	breq	8000cac8 <__avr32_udiv64+0x254>
8000ca18:	30 18       	mov	r8,1
8000ca1a:	c5 98       	rjmp	8000cacc <__avr32_udiv64+0x258>
8000ca1c:	f0 09 09 46 	lsl	r6,r8,r9
8000ca20:	f2 03 11 20 	rsub	r3,r9,32
8000ca24:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca28:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca2c:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca30:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca34:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca38:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca3c:	18 42       	or	r2,r12
8000ca3e:	f1 ee 10 0c 	or	r12,r8,lr
8000ca42:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca46:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca4a:	e6 01 0d 04 	divu	r4,r3,r1
8000ca4e:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca52:	08 9e       	mov	lr,r4
8000ca54:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca58:	e8 06 02 48 	mul	r8,r4,r6
8000ca5c:	10 33       	cp.w	r3,r8
8000ca5e:	c0 a2       	brcc	8000ca72 <__avr32_udiv64+0x1fe>
8000ca60:	20 1e       	sub	lr,1
8000ca62:	18 03       	add	r3,r12
8000ca64:	18 33       	cp.w	r3,r12
8000ca66:	c0 63       	brcs	8000ca72 <__avr32_udiv64+0x1fe>
8000ca68:	10 33       	cp.w	r3,r8
8000ca6a:	f7 be 03 01 	sublo	lr,1
8000ca6e:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca72:	10 13       	sub	r3,r8
8000ca74:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca78:	e6 01 0d 00 	divu	r0,r3,r1
8000ca7c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca80:	00 98       	mov	r8,r0
8000ca82:	e0 06 02 46 	mul	r6,r0,r6
8000ca86:	0c 3b       	cp.w	r11,r6
8000ca88:	c0 a2       	brcc	8000ca9c <__avr32_udiv64+0x228>
8000ca8a:	20 18       	sub	r8,1
8000ca8c:	18 0b       	add	r11,r12
8000ca8e:	18 3b       	cp.w	r11,r12
8000ca90:	c0 63       	brcs	8000ca9c <__avr32_udiv64+0x228>
8000ca92:	0c 3b       	cp.w	r11,r6
8000ca94:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca98:	f7 b8 03 01 	sublo	r8,1
8000ca9c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000caa0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000caa4:	0c 1b       	sub	r11,r6
8000caa6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000caaa:	06 95       	mov	r5,r3
8000caac:	16 35       	cp.w	r5,r11
8000caae:	e0 8b 00 0a 	brhi	8000cac2 <__avr32_udiv64+0x24e>
8000cab2:	5f 0b       	sreq	r11
8000cab4:	f4 09 09 49 	lsl	r9,r10,r9
8000cab8:	12 32       	cp.w	r2,r9
8000caba:	5f b9       	srhi	r9
8000cabc:	f7 e9 00 09 	and	r9,r11,r9
8000cac0:	c0 60       	breq	8000cacc <__avr32_udiv64+0x258>
8000cac2:	20 18       	sub	r8,1
8000cac4:	30 09       	mov	r9,0
8000cac6:	c0 38       	rjmp	8000cacc <__avr32_udiv64+0x258>
8000cac8:	30 09       	mov	r9,0
8000caca:	12 98       	mov	r8,r9
8000cacc:	10 9a       	mov	r10,r8
8000cace:	12 93       	mov	r3,r9
8000cad0:	10 92       	mov	r2,r8
8000cad2:	12 9b       	mov	r11,r9
8000cad4:	2f dd       	sub	sp,-12
8000cad6:	d8 32       	popm	r0-r7,pc

8000cad8 <__avr32_umod64>:
8000cad8:	d4 31       	pushm	r0-r7,lr
8000cada:	1a 97       	mov	r7,sp
8000cadc:	20 3d       	sub	sp,12
8000cade:	10 9c       	mov	r12,r8
8000cae0:	12 95       	mov	r5,r9
8000cae2:	14 9e       	mov	lr,r10
8000cae4:	16 91       	mov	r1,r11
8000cae6:	16 96       	mov	r6,r11
8000cae8:	58 09       	cp.w	r9,0
8000caea:	e0 81 00 81 	brne	8000cbec <__avr32_umod64+0x114>
8000caee:	16 38       	cp.w	r8,r11
8000caf0:	e0 88 00 12 	brls	8000cb14 <__avr32_umod64+0x3c>
8000caf4:	f0 08 12 00 	clz	r8,r8
8000caf8:	c4 e0       	breq	8000cb94 <__avr32_umod64+0xbc>
8000cafa:	f6 08 09 46 	lsl	r6,r11,r8
8000cafe:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb02:	f0 0b 11 20 	rsub	r11,r8,32
8000cb06:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb0a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb0e:	f7 e6 10 06 	or	r6,r11,r6
8000cb12:	c4 18       	rjmp	8000cb94 <__avr32_umod64+0xbc>
8000cb14:	58 08       	cp.w	r8,0
8000cb16:	c0 51       	brne	8000cb20 <__avr32_umod64+0x48>
8000cb18:	30 19       	mov	r9,1
8000cb1a:	f2 08 0d 08 	divu	r8,r9,r8
8000cb1e:	10 9c       	mov	r12,r8
8000cb20:	f8 08 12 00 	clz	r8,r12
8000cb24:	c0 31       	brne	8000cb2a <__avr32_umod64+0x52>
8000cb26:	18 16       	sub	r6,r12
8000cb28:	c3 68       	rjmp	8000cb94 <__avr32_umod64+0xbc>
8000cb2a:	f0 03 11 20 	rsub	r3,r8,32
8000cb2e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb32:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb36:	ec 08 09 49 	lsl	r9,r6,r8
8000cb3a:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb3e:	f7 e9 10 09 	or	r9,r11,r9
8000cb42:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb46:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb4a:	e6 05 0d 02 	divu	r2,r3,r5
8000cb4e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb52:	ec 02 02 4b 	mul	r11,r6,r2
8000cb56:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb5a:	16 3e       	cp.w	lr,r11
8000cb5c:	c0 72       	brcc	8000cb6a <__avr32_umod64+0x92>
8000cb5e:	18 0e       	add	lr,r12
8000cb60:	18 3e       	cp.w	lr,r12
8000cb62:	c0 43       	brcs	8000cb6a <__avr32_umod64+0x92>
8000cb64:	16 3e       	cp.w	lr,r11
8000cb66:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb6a:	fc 0b 01 03 	sub	r3,lr,r11
8000cb6e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb72:	e6 05 0d 02 	divu	r2,r3,r5
8000cb76:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb7a:	a5 36       	mul	r6,r2
8000cb7c:	0c 39       	cp.w	r9,r6
8000cb7e:	c0 72       	brcc	8000cb8c <__avr32_umod64+0xb4>
8000cb80:	18 09       	add	r9,r12
8000cb82:	18 39       	cp.w	r9,r12
8000cb84:	c0 43       	brcs	8000cb8c <__avr32_umod64+0xb4>
8000cb86:	0c 39       	cp.w	r9,r6
8000cb88:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb8c:	f2 06 01 06 	sub	r6,r9,r6
8000cb90:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb94:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cb98:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb9c:	ec 0a 0d 02 	divu	r2,r6,r10
8000cba0:	fc 09 16 10 	lsr	r9,lr,0x10
8000cba4:	ea 02 02 4b 	mul	r11,r5,r2
8000cba8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbac:	16 39       	cp.w	r9,r11
8000cbae:	c0 72       	brcc	8000cbbc <__avr32_umod64+0xe4>
8000cbb0:	18 09       	add	r9,r12
8000cbb2:	18 39       	cp.w	r9,r12
8000cbb4:	c0 43       	brcs	8000cbbc <__avr32_umod64+0xe4>
8000cbb6:	16 39       	cp.w	r9,r11
8000cbb8:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbbc:	f2 0b 01 0b 	sub	r11,r9,r11
8000cbc0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cbc4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cbc8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cbcc:	ea 0a 02 4a 	mul	r10,r5,r10
8000cbd0:	14 3e       	cp.w	lr,r10
8000cbd2:	c0 72       	brcc	8000cbe0 <__avr32_umod64+0x108>
8000cbd4:	18 0e       	add	lr,r12
8000cbd6:	18 3e       	cp.w	lr,r12
8000cbd8:	c0 43       	brcs	8000cbe0 <__avr32_umod64+0x108>
8000cbda:	14 3e       	cp.w	lr,r10
8000cbdc:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbe0:	fc 0a 01 0a 	sub	r10,lr,r10
8000cbe4:	30 0b       	mov	r11,0
8000cbe6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cbea:	c7 b8       	rjmp	8000cce0 <__avr32_umod64+0x208>
8000cbec:	16 39       	cp.w	r9,r11
8000cbee:	e0 8b 00 79 	brhi	8000cce0 <__avr32_umod64+0x208>
8000cbf2:	f2 09 12 00 	clz	r9,r9
8000cbf6:	c1 21       	brne	8000cc1a <__avr32_umod64+0x142>
8000cbf8:	10 3a       	cp.w	r10,r8
8000cbfa:	5f 2b       	srhs	r11
8000cbfc:	0a 31       	cp.w	r1,r5
8000cbfe:	5f ba       	srhi	r10
8000cc00:	f7 ea 10 0a 	or	r10,r11,r10
8000cc04:	f2 0a 18 00 	cp.b	r10,r9
8000cc08:	c0 60       	breq	8000cc14 <__avr32_umod64+0x13c>
8000cc0a:	fc 08 01 0c 	sub	r12,lr,r8
8000cc0e:	e2 05 01 46 	sbc	r6,r1,r5
8000cc12:	18 9e       	mov	lr,r12
8000cc14:	0c 9b       	mov	r11,r6
8000cc16:	1c 9a       	mov	r10,lr
8000cc18:	c6 48       	rjmp	8000cce0 <__avr32_umod64+0x208>
8000cc1a:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc1e:	f2 06 11 20 	rsub	r6,r9,32
8000cc22:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc26:	f0 09 09 42 	lsl	r2,r8,r9
8000cc2a:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc2e:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc32:	18 48       	or	r8,r12
8000cc34:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc38:	f4 09 09 43 	lsl	r3,r10,r9
8000cc3c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc40:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc44:	16 4a       	or	r10,r11
8000cc46:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc4a:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc4e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc52:	08 91       	mov	r1,r4
8000cc54:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc58:	e8 0e 02 46 	mul	r6,r4,lr
8000cc5c:	0c 3c       	cp.w	r12,r6
8000cc5e:	c0 a2       	brcc	8000cc72 <__avr32_umod64+0x19a>
8000cc60:	20 11       	sub	r1,1
8000cc62:	10 0c       	add	r12,r8
8000cc64:	10 3c       	cp.w	r12,r8
8000cc66:	c0 63       	brcs	8000cc72 <__avr32_umod64+0x19a>
8000cc68:	0c 3c       	cp.w	r12,r6
8000cc6a:	f7 b1 03 01 	sublo	r1,1
8000cc6e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc72:	0c 1c       	sub	r12,r6
8000cc74:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc78:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc7c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc80:	08 96       	mov	r6,r4
8000cc82:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc86:	1c 3b       	cp.w	r11,lr
8000cc88:	c0 a2       	brcc	8000cc9c <__avr32_umod64+0x1c4>
8000cc8a:	20 16       	sub	r6,1
8000cc8c:	10 0b       	add	r11,r8
8000cc8e:	10 3b       	cp.w	r11,r8
8000cc90:	c0 63       	brcs	8000cc9c <__avr32_umod64+0x1c4>
8000cc92:	1c 3b       	cp.w	r11,lr
8000cc94:	f7 b6 03 01 	sublo	r6,1
8000cc98:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cc9c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cca0:	1c 1b       	sub	r11,lr
8000cca2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cca6:	00 9e       	mov	lr,r0
8000cca8:	02 9c       	mov	r12,r1
8000ccaa:	16 3c       	cp.w	r12,r11
8000ccac:	e0 8b 00 08 	brhi	8000ccbc <__avr32_umod64+0x1e4>
8000ccb0:	5f 06       	sreq	r6
8000ccb2:	06 30       	cp.w	r0,r3
8000ccb4:	5f ba       	srhi	r10
8000ccb6:	ed ea 00 0a 	and	r10,r6,r10
8000ccba:	c0 60       	breq	8000ccc6 <__avr32_umod64+0x1ee>
8000ccbc:	fc 02 01 04 	sub	r4,lr,r2
8000ccc0:	f8 08 01 4c 	sbc	r12,r12,r8
8000ccc4:	08 9e       	mov	lr,r4
8000ccc6:	e6 0e 01 0a 	sub	r10,r3,lr
8000ccca:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ccce:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ccd2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ccd6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ccda:	f8 01 09 4c 	lsl	r12,r12,r1
8000ccde:	18 4a       	or	r10,r12
8000cce0:	2f dd       	sub	sp,-12
8000cce2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 bc 	sub	pc,pc,28860

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 05 	rcall	80005510 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c2 fe 	rcall	80005510 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c2 f7 	rcall	80005510 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c2 f0 	rcall	80005510 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
