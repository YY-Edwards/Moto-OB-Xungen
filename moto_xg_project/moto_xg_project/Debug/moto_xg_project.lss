
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aa94  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000115c  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000df5c  8000df5c  0000e35c  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000df60  0000e404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e998  0000ee3c  2**0
                  ALLOC
  8 .bss          000046e8  00000a40  8000e998  0000ee40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ee3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001290  00000000  00000000  0000ee70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000028a8  00000000  00000000  00010100  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00029e20  00000000  00000000  000129a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006d16  00000000  00000000  0003c7c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0001632b  00000000  00000000  000434de  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000031c8  00000000  00000000  0005980c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000737c  00000000  00000000  0005c9d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000dacb  00000000  00000000  00063d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 0162e0a1  00000000  00000000  0007181b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 20 .debug_ranges 00001368  00000000  00000000  0169f8c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 44 	sub	pc,pc,-15036

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 94       	ld.ub	r4,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	40 c0       	lddsp	r0,sp[0x30]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 fc       	sub	r12,15
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 68       	sub	r8,-122
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 08       	sub	r8,-112
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	69 b4       	ld.w	r4,r4[0x6c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	eb cd 40 fc 	pushm	r2-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002094:	f0 1f 00 13 	mcall	800020e0 <app_cfg+0x50>
80002098:	49 38       	lddpc	r8,800020e4 <app_cfg+0x54>
8000209a:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209c:	49 36       	lddpc	r6,800020e8 <app_cfg+0x58>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000209e:	49 47       	lddpc	r7,800020ec <app_cfg+0x5c>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020a0:	30 c2       	mov	r2,12
			connect_flag=1;	
800020a2:	30 13       	mov	r3,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a4:	10 95       	mov	r5,r8
800020a6:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020aa:	6c 08       	ld.w	r8,r6[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c0 91       	brne	800020c4 <app_cfg+0x34>
800020b4:	0f 88       	ld.ub	r8,r7[0x0]
800020b6:	58 08       	cp.w	r8,0
800020b8:	c0 61       	brne	800020c4 <app_cfg+0x34>
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020ba:	04 9c       	mov	r12,r2
800020bc:	f0 1f 00 0d 	mcall	800020f0 <app_cfg+0x60>
			connect_flag=1;	
800020c0:	ae 83       	st.b	r7[0x0],r3
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c2:	c0 a8       	rjmp	800020d6 <app_cfg+0x46>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
800020c4:	0f 88       	ld.ub	r8,r7[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 40       	breq	800020d0 <app_cfg+0x40>
		{
				
				rfid_sendID_message();
800020ca:	f0 1f 00 0b 	mcall	800020f4 <app_cfg+0x64>
800020ce:	c0 48       	rjmp	800020d6 <app_cfg+0x46>
				//}
				
		}
		else
		{
			nop();
800020d0:	d7 03       	nop
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020d6:	08 9b       	mov	r11,r4
800020d8:	0a 9c       	mov	r12,r5
800020da:	f0 1f 00 08 	mcall	800020f8 <app_cfg+0x68>
	}
800020de:	ce 6b       	rjmp	800020aa <app_cfg+0x1a>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	66 ec       	ld.w	r12,r3[0x38]
800020e4:	00 00       	add	r0,r0
800020e6:	0a 48       	or	r8,r5
800020e8:	00 00       	add	r0,r0
800020ea:	0d 94       	ld.ub	r4,r6[0x1]
800020ec:	00 00       	add	r0,r0
800020ee:	0a 54       	eor	r4,r5
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	42 4c       	lddsp	r12,sp[0x90]
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	52 78       	stdsp	sp[0x9c],r8
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	68 54       	ld.w	r4,r4[0x14]

800020fc <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020fc:	d4 01       	pushm	lr
  log("R");
800020fe:	48 3c       	lddpc	r12,80002108 <app_payload_tx_proc+0xc>
80002100:	f0 1f 00 03 	mcall	8000210c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002104:	d8 02       	popm	pc
80002106:	00 00       	add	r0,r0
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	ce 08       	rjmp	800022ca <Phyuserinput_brdcst_func+0x2>
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	6d 78       	ld.w	r8,r6[0x5c]

80002110 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002110:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002112:	48 3c       	lddpc	r12,8000211c <FD_brdcst_func+0xc>
80002114:	f0 1f 00 03 	mcall	80002120 <FD_brdcst_func+0x10>
	
}
80002118:	d8 02       	popm	pc
8000211a:	00 00       	add	r0,r0
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	ce 0c       	rcall	800022de <Phyuserinput_brdcst_func+0x16>
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	6d 78       	ld.w	r8,r6[0x5c]

80002124 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002124:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002126:	48 3c       	lddpc	r12,80002130 <FD_reply_func+0xc>
80002128:	f0 1f 00 03 	mcall	80002134 <FD_reply_func+0x10>
	
	
}
8000212c:	d8 02       	popm	pc
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	ce 2c       	rcall	800022f6 <Phyuserinput_brdcst_func+0x2e>
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	6d 78       	ld.w	r8,r6[0x5c]

80002138 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002138:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000213a:	48 3c       	lddpc	r12,80002144 <FD_request_func+0xc>
8000213c:	f0 1f 00 03 	mcall	80002148 <FD_request_func+0x10>
	
	
}
80002140:	d8 02       	popm	pc
80002142:	00 00       	add	r0,r0
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	ce 48       	rjmp	8000230e <ButtonConfig_reply_func+0x2>
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	6d 78       	ld.w	r8,r6[0x5c]

8000214c <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <EnOB_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <EnOB_brdcst_func+0x10>
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce 64       	brge	80002126 <FD_reply_func+0x2>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	6d 78       	ld.w	r8,r6[0x5c]

80002160 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	30 08       	mov	r8,0
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c1 91       	brne	800021a0 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002170:	19 b8       	ld.ub	r8,r12[0x3]
80002172:	30 19       	mov	r9,1
80002174:	f2 08 18 00 	cp.b	r8,r9
80002178:	c0 61       	brne	80002184 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000217a:	49 0c       	lddpc	r12,800021b8 <EnOB_reply_func+0x58>
8000217c:	f0 1f 00 10 	mcall	800021bc <EnOB_reply_func+0x5c>
80002180:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002184:	58 08       	cp.w	r8,0
80002186:	c0 61       	brne	80002192 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002188:	48 ec       	lddpc	r12,800021c0 <EnOB_reply_func+0x60>
8000218a:	f0 1f 00 0d 	mcall	800021bc <EnOB_reply_func+0x5c>
8000218e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002192:	1a d8       	st.w	--sp,r8
80002194:	48 cc       	lddpc	r12,800021c4 <EnOB_reply_func+0x64>
80002196:	f0 1f 00 0a 	mcall	800021bc <EnOB_reply_func+0x5c>
8000219a:	2f fd       	sub	sp,-4
8000219c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021a0:	48 ac       	lddpc	r12,800021c8 <EnOB_reply_func+0x68>
800021a2:	f0 1f 00 07 	mcall	800021bc <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021a6:	0f a8       	ld.ub	r8,r7[0x2]
800021a8:	1a d8       	st.w	--sp,r8
800021aa:	48 9c       	lddpc	r12,800021cc <EnOB_reply_func+0x6c>
800021ac:	f0 1f 00 04 	mcall	800021bc <EnOB_reply_func+0x5c>
800021b0:	2f fd       	sub	sp,-4
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800021b6:	00 00       	add	r0,r0
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	ce 7c       	rcall	80002388 <DataSession_brdcst_func+0x38>
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	6d 78       	ld.w	r8,r6[0x5c]
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	ce 94       	brge	80002194 <EnOB_reply_func+0x34>
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	ce a8       	rjmp	8000239a <DataSession_brdcst_func+0x4a>
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	ce c0       	breq	800021a2 <EnOB_reply_func+0x42>
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	ce dc       	rcall	800023a8 <DataSession_brdcst_func+0x58>

800021d0 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021d0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021d2:	19 a9       	ld.ub	r9,r12[0x2]
800021d4:	31 18       	mov	r8,17
800021d6:	f0 09 18 00 	cp.b	r9,r8
800021da:	c0 41       	brne	800021e2 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021dc:	48 2c       	lddpc	r12,800021e4 <SingleDetection_brdcst_func+0x14>
800021de:	f0 1f 00 03 	mcall	800021e8 <SingleDetection_brdcst_func+0x18>
800021e2:	d8 02       	popm	pc
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	ce f4       	brge	800021c4 <EnOB_reply_func+0x64>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	6d 78       	ld.w	r8,r6[0x5c]

800021ec <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ec:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ee:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021f2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021f4:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xb4>
800021f6:	f0 1f 00 2c 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021fa:	0f 88       	ld.ub	r8,r7[0x0]
800021fc:	1a d8       	st.w	--sp,r8
800021fe:	4a bc       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xbc>
80002200:	f0 1f 00 29 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002204:	1a d5       	st.w	--sp,r5
80002206:	4a ac       	lddpc	r12,800022ac <ButtonConfig_brdcst_func+0xc0>
80002208:	f0 1f 00 27 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000220c:	0f a8       	ld.ub	r8,r7[0x2]
8000220e:	1a d8       	st.w	--sp,r8
80002210:	4a 8c       	lddpc	r12,800022b0 <ButtonConfig_brdcst_func+0xc4>
80002212:	f0 1f 00 25 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002216:	2f dd       	sub	sp,-12
80002218:	58 05       	cp.w	r5,0
8000221a:	c4 10       	breq	8000229c <ButtonConfig_brdcst_func+0xb0>
8000221c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000221e:	4a 64       	lddpc	r4,800022b4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002220:	4a 63       	lddpc	r3,800022b8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002222:	4a 72       	lddpc	r2,800022bc <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002224:	4a 71       	lddpc	r1,800022c0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002226:	4a 80       	lddpc	r0,800022c4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002228:	0f b9       	ld.ub	r9,r7[0x3]
8000222a:	0f c8       	ld.ub	r8,r7[0x4]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	08 9c       	mov	r12,r4
80002236:	f0 1f 00 1c 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000223a:	0f d9       	ld.ub	r9,r7[0x5]
8000223c:	0f e8       	ld.ub	r8,r7[0x6]
8000223e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002242:	1a d8       	st.w	--sp,r8
80002244:	1a d6       	st.w	--sp,r6
80002246:	06 9c       	mov	r12,r3
80002248:	f0 1f 00 17 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000224c:	0f f9       	ld.ub	r9,r7[0x7]
8000224e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002252:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002256:	1a d8       	st.w	--sp,r8
80002258:	1a d6       	st.w	--sp,r6
8000225a:	04 9c       	mov	r12,r2
8000225c:	f0 1f 00 12 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	ef 39 00 09 	ld.ub	r9,r7[9]
80002264:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	02 9c       	mov	r12,r1
80002272:	f0 1f 00 0d 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002276:	2f 8d       	sub	sp,-32
80002278:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000227c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002280:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002284:	1a d8       	st.w	--sp,r8
80002286:	1a d6       	st.w	--sp,r6
80002288:	00 9c       	mov	r12,r0
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_brdcst_func+0xb8>
8000228e:	2f f6       	sub	r6,-1
80002290:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002292:	2f ed       	sub	sp,-8
80002294:	ec 05 18 00 	cp.b	r5,r6
80002298:	fe 9b ff c8 	brhi	80002228 <ButtonConfig_brdcst_func+0x3c>
8000229c:	d8 32       	popm	r0-r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	cf 08       	rjmp	80002482 <DataSession_reply_func+0x52>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	6d 78       	ld.w	r8,r6[0x5c]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cf 28       	rjmp	8000248e <DataSession_reply_func+0x5e>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	cf 3c       	rcall	80002494 <DataSession_reply_func+0x64>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cf 54       	brge	8000229c <ButtonConfig_brdcst_func+0xb0>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cf 74       	brge	800022a4 <ButtonConfig_brdcst_func+0xb8>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	cf 9c       	rcall	800024ac <CallControl_brdcst_func>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	cf c4       	brge	800022b6 <ButtonConfig_brdcst_func+0xca>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	cf e8       	rjmp	800024be <CallControl_brdcst_func+0x12>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d0 10       	acall	0x1

800022c8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022c8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022cc:	19 c7       	ld.ub	r7,r12[0x4]
800022ce:	19 d8       	ld.ub	r8,r12[0x5]
800022d0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800022d4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800022d6:	48 ac       	lddpc	r12,800022fc <Phyuserinput_brdcst_func+0x34>
800022d8:	f0 1f 00 0a 	mcall	80002300 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800022dc:	36 08       	mov	r8,96
800022de:	f0 07 19 00 	cp.h	r7,r8
800022e2:	c0 a1       	brne	800022f6 <Phyuserinput_brdcst_func+0x2e>
800022e4:	48 88       	lddpc	r8,80002304 <Phyuserinput_brdcst_func+0x3c>
800022e6:	11 89       	ld.ub	r9,r8[0x0]
800022e8:	30 18       	mov	r8,1
800022ea:	f0 09 18 00 	cp.b	r9,r8
800022ee:	c0 41       	brne	800022f6 <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
800022f0:	48 6c       	lddpc	r12,80002308 <Phyuserinput_brdcst_func+0x40>
800022f2:	f0 1f 00 04 	mcall	80002300 <Phyuserinput_brdcst_func+0x38>
800022f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022fa:	00 00       	add	r0,r0
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d0 34       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	6d 78       	ld.w	r8,r6[0x5c]
80002304:	00 00       	add	r0,r0
80002306:	0a 54       	eor	r4,r5
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	d0 54       	*unknown*

8000230c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000230c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002310:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002314:	0f 89       	ld.ub	r9,r7[0x0]
80002316:	30 08       	mov	r8,0
80002318:	f0 09 18 00 	cp.b	r9,r8
8000231c:	c0 c1       	brne	80002334 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000231e:	48 9c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x34>
80002320:	f0 1f 00 09 	mcall	80002344 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 8c       	lddpc	r12,80002348 <ButtonConfig_reply_func+0x3c>
8000232a:	f0 1f 00 07 	mcall	80002344 <ButtonConfig_reply_func+0x38>
8000232e:	2f fd       	sub	sp,-4
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002334:	48 6c       	lddpc	r12,8000234c <ButtonConfig_reply_func+0x40>
80002336:	f0 1f 00 04 	mcall	80002344 <ButtonConfig_reply_func+0x38>
8000233a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000233e:	00 00       	add	r0,r0
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d0 64       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	6d 78       	ld.w	r8,r6[0x5c]
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	cf 28       	rjmp	8000252e <TransmitControl_brdcst_func+0x3e>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d0 7c       	*unknown*

80002350 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002350:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002352:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002356:	0d 88       	ld.ub	r8,r6[0x0]
80002358:	32 49       	mov	r9,36
8000235a:	f2 08 18 00 	cp.b	r8,r9
8000235e:	c2 91       	brne	800023b0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002360:	4a dc       	lddpc	r12,80002414 <DataSession_brdcst_func+0xc4>
80002362:	f0 1f 00 2e 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002366:	0d a5       	ld.ub	r5,r6[0x2]
80002368:	0d b8       	ld.ub	r8,r6[0x3]
8000236a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000236e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002370:	0d 98       	ld.ub	r8,r6[0x1]
80002372:	1a d8       	st.w	--sp,r8
80002374:	4a ac       	lddpc	r12,8000241c <DataSession_brdcst_func+0xcc>
80002376:	f0 1f 00 29 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000237a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000237e:	1a d8       	st.w	--sp,r8
80002380:	4a 8c       	lddpc	r12,80002420 <DataSession_brdcst_func+0xd0>
80002382:	f0 1f 00 26 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002386:	2f ed       	sub	sp,-8
80002388:	58 05       	cp.w	r5,0
8000238a:	c4 40       	breq	80002412 <DataSession_brdcst_func+0xc2>
8000238c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000238e:	4a 64       	lddpc	r4,80002424 <DataSession_brdcst_func+0xd4>
80002390:	ec 07 00 08 	add	r8,r6,r7
80002394:	11 c8       	ld.ub	r8,r8[0x4]
80002396:	1a d8       	st.w	--sp,r8
80002398:	1a d7       	st.w	--sp,r7
8000239a:	08 9c       	mov	r12,r4
8000239c:	f0 1f 00 1f 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023a0:	2f f7       	sub	r7,-1
800023a2:	5c 57       	castu.b	r7
800023a4:	2f ed       	sub	sp,-8
800023a6:	ee 05 19 00 	cp.h	r5,r7
800023aa:	fe 9b ff f3 	brhi	80002390 <DataSession_brdcst_func+0x40>
800023ae:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
800023b0:	1a d8       	st.w	--sp,r8
800023b2:	49 ec       	lddpc	r12,80002428 <DataSession_brdcst_func+0xd8>
800023b4:	f0 1f 00 19 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		if (ptr->State)
800023b8:	2f fd       	sub	sp,-4
800023ba:	0d 89       	ld.ub	r9,r6[0x0]
800023bc:	30 08       	mov	r8,0
800023be:	f0 09 18 00 	cp.b	r9,r8
800023c2:	c0 40       	breq	800023ca <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
800023c4:	49 ac       	lddpc	r12,8000242c <DataSession_brdcst_func+0xdc>
800023c6:	f0 1f 00 15 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023ca:	0d a5       	ld.ub	r5,r6[0x2]
800023cc:	0d b8       	ld.ub	r8,r6[0x3]
800023ce:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023d2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023d4:	0d 98       	ld.ub	r8,r6[0x1]
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 1c       	lddpc	r12,8000241c <DataSession_brdcst_func+0xcc>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023de:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	48 fc       	lddpc	r12,80002420 <DataSession_brdcst_func+0xd0>
800023e6:	f0 1f 00 0d 	mcall	80002418 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023ea:	2f ed       	sub	sp,-8
800023ec:	58 05       	cp.w	r5,0
800023ee:	c1 20       	breq	80002412 <DataSession_brdcst_func+0xc2>
800023f0:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023f2:	48 d4       	lddpc	r4,80002424 <DataSession_brdcst_func+0xd4>
800023f4:	ec 07 00 08 	add	r8,r6,r7
800023f8:	11 c8       	ld.ub	r8,r8[0x4]
800023fa:	1a d8       	st.w	--sp,r8
800023fc:	1a d7       	st.w	--sp,r7
800023fe:	08 9c       	mov	r12,r4
80002400:	f0 1f 00 06 	mcall	80002418 <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002404:	2f f7       	sub	r7,-1
80002406:	5c 57       	castu.b	r7
80002408:	2f ed       	sub	sp,-8
8000240a:	ee 05 19 00 	cp.h	r5,r7
8000240e:	fe 9b ff f3 	brhi	800023f4 <DataSession_brdcst_func+0xa4>
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	d0 98       	*unknown*
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	6d 78       	ld.w	r8,r6[0x5c]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	d0 ac       	*unknown*
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	d0 c4       	*unknown*
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d0 e0       	acall	0xe
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	d0 f8       	*unknown*
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	d1 08       	*unknown*

80002430 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002430:	eb cd 40 80 	pushm	r7,lr
80002434:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002436:	19 a9       	ld.ub	r9,r12[0x2]
80002438:	30 08       	mov	r8,0
8000243a:	f0 09 18 00 	cp.b	r9,r8
8000243e:	c1 11       	brne	80002460 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002440:	49 3c       	lddpc	r12,8000248c <DataSession_reply_func+0x5c>
80002442:	f0 1f 00 14 	mcall	80002490 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002446:	0f b8       	ld.ub	r8,r7[0x3]
80002448:	1a d8       	st.w	--sp,r8
8000244a:	49 3c       	lddpc	r12,80002494 <DataSession_reply_func+0x64>
8000244c:	f0 1f 00 11 	mcall	80002490 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002450:	0f c8       	ld.ub	r8,r7[0x4]
80002452:	1a d8       	st.w	--sp,r8
80002454:	49 1c       	lddpc	r12,80002498 <DataSession_reply_func+0x68>
80002456:	f0 1f 00 0f 	mcall	80002490 <DataSession_reply_func+0x60>
8000245a:	2f ed       	sub	sp,-8
8000245c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002460:	48 fc       	lddpc	r12,8000249c <DataSession_reply_func+0x6c>
80002462:	f0 1f 00 0c 	mcall	80002490 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
80002466:	0f a8       	ld.ub	r8,r7[0x2]
80002468:	1a d8       	st.w	--sp,r8
8000246a:	48 ec       	lddpc	r12,800024a0 <DataSession_reply_func+0x70>
8000246c:	f0 1f 00 09 	mcall	80002490 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002470:	0f b8       	ld.ub	r8,r7[0x3]
80002472:	1a d8       	st.w	--sp,r8
80002474:	48 cc       	lddpc	r12,800024a4 <DataSession_reply_func+0x74>
80002476:	f0 1f 00 07 	mcall	80002490 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000247a:	0f c8       	ld.ub	r8,r7[0x4]
8000247c:	1a d8       	st.w	--sp,r8
8000247e:	48 bc       	lddpc	r12,800024a8 <DataSession_reply_func+0x78>
80002480:	f0 1f 00 04 	mcall	80002490 <DataSession_reply_func+0x60>
80002484:	2f dd       	sub	sp,-12
80002486:	e3 cd 80 80 	ldm	sp++,r7,pc
8000248a:	00 00       	add	r0,r0
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	d1 20       	acall	0x12
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	6d 78       	ld.w	r8,r6[0x5c]
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	d1 30       	acall	0x13
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d1 3c       	*unknown*
8000249c:	80 00       	ld.sh	r0,r0[0x0]
8000249e:	d1 48       	*unknown*
800024a0:	80 00       	ld.sh	r0,r0[0x0]
800024a2:	d1 58       	*unknown*
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	d1 68       	*unknown*
800024a8:	80 00       	ld.sh	r0,r0[0x0]
800024aa:	d1 74       	*unknown*

800024ac <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024ac:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800024b0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800024b4:	0f 98       	ld.ub	r8,r7[0x1]
800024b6:	1a d8       	st.w	--sp,r8
800024b8:	48 bc       	lddpc	r12,800024e4 <CallControl_brdcst_func+0x38>
800024ba:	f0 1f 00 0c 	mcall	800024e8 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024be:	2f fd       	sub	sp,-4
800024c0:	0f 99       	ld.ub	r9,r7[0x1]
800024c2:	30 38       	mov	r8,3
800024c4:	f0 09 18 00 	cp.b	r9,r8
800024c8:	c0 41       	brne	800024d0 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ca:	30 09       	mov	r9,0
800024cc:	48 88       	lddpc	r8,800024ec <CallControl_brdcst_func+0x40>
800024ce:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 48       	mov	r8,4
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 41       	brne	800024e0 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024da:	30 19       	mov	r9,1
800024dc:	48 48       	lddpc	r8,800024ec <CallControl_brdcst_func+0x40>
800024de:	b0 89       	st.b	r8[0x0],r9
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d1 80       	acall	0x18
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	6d 78       	ld.w	r8,r6[0x5c]
800024ec:	00 00       	add	r0,r0
800024ee:	0a 45       	or	r5,r5

800024f0 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024f4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024f8:	0f 99       	ld.ub	r9,r7[0x1]
800024fa:	30 08       	mov	r8,0
800024fc:	f0 09 18 00 	cp.b	r9,r8
80002500:	c0 71       	brne	8000250e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002502:	48 ac       	lddpc	r12,80002528 <TransmitControl_brdcst_func+0x38>
80002504:	f0 1f 00 0a 	mcall	8000252c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002508:	30 09       	mov	r9,0
8000250a:	48 a8       	lddpc	r8,80002530 <TransmitControl_brdcst_func+0x40>
8000250c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000250e:	0f 99       	ld.ub	r9,r7[0x1]
80002510:	30 18       	mov	r8,1
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 71       	brne	80002524 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002518:	48 7c       	lddpc	r12,80002534 <TransmitControl_brdcst_func+0x44>
8000251a:	f0 1f 00 05 	mcall	8000252c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000251e:	30 19       	mov	r9,1
80002520:	48 48       	lddpc	r8,80002530 <TransmitControl_brdcst_func+0x40>
80002522:	b0 89       	st.b	r8[0x0],r9
80002524:	e3 cd 80 80 	ldm	sp++,r7,pc
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	d1 98       	*unknown*
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	6d 78       	ld.w	r8,r6[0x5c]
80002530:	00 00       	add	r0,r0
80002532:	0a 44       	or	r4,r5
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d1 b0       	acall	0x1b

80002538 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000253c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002540:	0f 89       	ld.ub	r9,r7[0x0]
80002542:	30 08       	mov	r8,0
80002544:	f0 09 18 00 	cp.b	r9,r8
80002548:	c1 61       	brne	80002574 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000254a:	48 ec       	lddpc	r12,80002580 <TransmitControl_reply_func+0x48>
8000254c:	f0 1f 00 0e 	mcall	80002584 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002550:	0f 98       	ld.ub	r8,r7[0x1]
80002552:	1a d8       	st.w	--sp,r8
80002554:	48 dc       	lddpc	r12,80002588 <TransmitControl_reply_func+0x50>
80002556:	f0 1f 00 0c 	mcall	80002584 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000255a:	0f a8       	ld.ub	r8,r7[0x2]
8000255c:	1a d8       	st.w	--sp,r8
8000255e:	48 cc       	lddpc	r12,8000258c <TransmitControl_reply_func+0x54>
80002560:	f0 1f 00 09 	mcall	80002584 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002564:	0f b8       	ld.ub	r8,r7[0x3]
80002566:	1a d8       	st.w	--sp,r8
80002568:	48 ac       	lddpc	r12,80002590 <TransmitControl_reply_func+0x58>
8000256a:	f0 1f 00 07 	mcall	80002584 <TransmitControl_reply_func+0x4c>
8000256e:	2f dd       	sub	sp,-12
80002570:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002574:	48 8c       	lddpc	r12,80002594 <TransmitControl_reply_func+0x5c>
80002576:	f0 1f 00 04 	mcall	80002584 <TransmitControl_reply_func+0x4c>
8000257a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000257e:	00 00       	add	r0,r0
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	d1 c4       	*unknown*
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	6d 78       	ld.w	r8,r6[0x5c]
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	d1 e0       	acall	0x1e
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	d1 f4       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	d2 10       	acall	0x21
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	d2 20       	acall	0x22

80002598 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002598:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000259a:	19 a9       	ld.ub	r9,r12[0x2]
8000259c:	30 08       	mov	r8,0
8000259e:	f0 09 18 00 	cp.b	r9,r8
800025a2:	c0 51       	brne	800025ac <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800025a4:	48 4c       	lddpc	r12,800025b4 <AudioRoutingControl_reply_func+0x1c>
800025a6:	f0 1f 00 05 	mcall	800025b8 <AudioRoutingControl_reply_func+0x20>
800025aa:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800025ac:	48 4c       	lddpc	r12,800025bc <AudioRoutingControl_reply_func+0x24>
800025ae:	f0 1f 00 03 	mcall	800025b8 <AudioRoutingControl_reply_func+0x20>
800025b2:	d8 02       	popm	pc
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d2 38       	*unknown*
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	6d 78       	ld.w	r8,r6[0x5c]
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d2 48       	*unknown*

800025c0 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025c0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025c4:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025c8:	0f 89       	ld.ub	r9,r7[0x0]
800025ca:	30 08       	mov	r8,0
800025cc:	f0 09 18 00 	cp.b	r9,r8
800025d0:	c1 b1       	brne	80002606 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025d2:	0f b8       	ld.ub	r8,r7[0x3]
800025d4:	31 09       	mov	r9,16
800025d6:	f2 08 18 00 	cp.b	r8,r9
800025da:	c0 f1       	brne	800025f8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025dc:	48 dc       	lddpc	r12,80002610 <Volume_reply_func+0x50>
800025de:	f0 1f 00 0e 	mcall	80002614 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025e2:	0f 99       	ld.ub	r9,r7[0x1]
800025e4:	0f a8       	ld.ub	r8,r7[0x2]
800025e6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ea:	1a d8       	st.w	--sp,r8
800025ec:	48 bc       	lddpc	r12,80002618 <Volume_reply_func+0x58>
800025ee:	f0 1f 00 0a 	mcall	80002614 <Volume_reply_func+0x54>
800025f2:	2f fd       	sub	sp,-4
800025f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025f8:	1a d8       	st.w	--sp,r8
800025fa:	48 9c       	lddpc	r12,8000261c <Volume_reply_func+0x5c>
800025fc:	f0 1f 00 06 	mcall	80002614 <Volume_reply_func+0x54>
80002600:	2f fd       	sub	sp,-4
80002602:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002606:	48 7c       	lddpc	r12,80002620 <Volume_reply_func+0x60>
80002608:	f0 1f 00 03 	mcall	80002614 <Volume_reply_func+0x54>
8000260c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	d2 5c       	*unknown*
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	6d 78       	ld.w	r8,r6[0x5c]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	d2 70       	acall	0x27
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	d2 8c       	*unknown*
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	d2 a4       	*unknown*

80002624 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002624:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002626:	19 d9       	ld.ub	r9,r12[0x5]
80002628:	30 08       	mov	r8,0
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 81       	brne	8000263e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002630:	10 99       	mov	r9,r8
80002632:	48 78       	lddpc	r8,8000264c <spk_brdcst_func+0x28>
80002634:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002636:	48 7c       	lddpc	r12,80002650 <spk_brdcst_func+0x2c>
80002638:	f0 1f 00 07 	mcall	80002654 <spk_brdcst_func+0x30>
8000263c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000263e:	30 19       	mov	r9,1
80002640:	48 38       	lddpc	r8,8000264c <spk_brdcst_func+0x28>
80002642:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002644:	48 5c       	lddpc	r12,80002658 <spk_brdcst_func+0x34>
80002646:	f0 1f 00 04 	mcall	80002654 <spk_brdcst_func+0x30>
8000264a:	d8 02       	popm	pc
8000264c:	00 00       	add	r0,r0
8000264e:	0a 40       	or	r0,r5
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d2 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	6d 78       	ld.w	r8,r6[0x5c]
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d2 cc       	*unknown*

8000265c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000265c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000265e:	19 a9       	ld.ub	r9,r12[0x2]
80002660:	30 08       	mov	r8,0
80002662:	f0 09 18 00 	cp.b	r9,r8
80002666:	c0 f1       	brne	80002684 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002668:	19 e9       	ld.ub	r9,r12[0x6]
8000266a:	f0 09 18 00 	cp.b	r9,r8
8000266e:	c0 40       	breq	80002676 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002670:	30 19       	mov	r9,1
80002672:	48 98       	lddpc	r8,80002694 <spk_reply_func+0x38>
80002674:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002676:	19 e8       	ld.ub	r8,r12[0x6]
80002678:	1a d8       	st.w	--sp,r8
8000267a:	48 8c       	lddpc	r12,80002698 <spk_reply_func+0x3c>
8000267c:	f0 1f 00 08 	mcall	8000269c <spk_reply_func+0x40>
80002680:	2f fd       	sub	sp,-4
80002682:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002684:	30 09       	mov	r9,0
80002686:	48 48       	lddpc	r8,80002694 <spk_reply_func+0x38>
80002688:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000268a:	48 6c       	lddpc	r12,800026a0 <spk_reply_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <spk_reply_func+0x40>
80002690:	d8 02       	popm	pc
80002692:	00 00       	add	r0,r0
80002694:	00 00       	add	r0,r0
80002696:	0a 40       	or	r0,r5
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d2 d8       	*unknown*
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	6d 78       	ld.w	r8,r6[0x5c]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d2 e8       	*unknown*

800026a4 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800026a4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800026a8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800026ac:	0f a9       	ld.ub	r9,r7[0x2]
800026ae:	30 08       	mov	r8,0
800026b0:	f0 09 18 00 	cp.b	r9,r8
800026b4:	c0 71       	brne	800026c2 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026b6:	48 dc       	lddpc	r12,800026e8 <mic_brdcst_func+0x44>
800026b8:	f0 1f 00 0d 	mcall	800026ec <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026bc:	30 09       	mov	r9,0
800026be:	48 d8       	lddpc	r8,800026f0 <mic_brdcst_func+0x4c>
800026c0:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026c2:	0f a9       	ld.ub	r9,r7[0x2]
800026c4:	31 18       	mov	r8,17
800026c6:	f0 09 18 00 	cp.b	r9,r8
800026ca:	c0 d1       	brne	800026e4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026cc:	48 ac       	lddpc	r12,800026f4 <mic_brdcst_func+0x50>
800026ce:	f0 1f 00 08 	mcall	800026ec <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026d2:	48 89       	lddpc	r9,800026f0 <mic_brdcst_func+0x4c>
800026d4:	30 18       	mov	r8,1
800026d6:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026d8:	13 89       	ld.ub	r9,r9[0x0]
800026da:	f0 09 18 00 	cp.b	r9,r8
800026de:	c0 31       	brne	800026e4 <mic_brdcst_func+0x40>
800026e0:	48 68       	lddpc	r8,800026f8 <mic_brdcst_func+0x54>
800026e2:	11 88       	ld.ub	r8,r8[0x0]
800026e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	d2 f4       	*unknown*
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	6d 78       	ld.w	r8,r6[0x5c]
800026f0:	00 00       	add	r0,r0
800026f2:	0a 56       	eor	r6,r5
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	d3 08       	*unknown*
800026f8:	00 00       	add	r0,r0
800026fa:	0a 45       	or	r5,r5

800026fc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002700:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002704:	49 ac       	lddpc	r12,8000276c <mic_reply_func+0x70>
80002706:	f0 1f 00 1b 	mcall	80002770 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000270a:	0f 89       	ld.ub	r9,r7[0x0]
8000270c:	30 08       	mov	r8,0
8000270e:	f0 09 18 00 	cp.b	r9,r8
80002712:	c2 71       	brne	80002760 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002714:	0f 98       	ld.ub	r8,r7[0x1]
80002716:	30 29       	mov	r9,2
80002718:	f2 08 18 00 	cp.b	r8,r9
8000271c:	c1 b1       	brne	80002752 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000271e:	49 6c       	lddpc	r12,80002774 <mic_reply_func+0x78>
80002720:	f0 1f 00 14 	mcall	80002770 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002724:	0f a8       	ld.ub	r8,r7[0x2]
80002726:	1a d8       	st.w	--sp,r8
80002728:	49 4c       	lddpc	r12,80002778 <mic_reply_func+0x7c>
8000272a:	f0 1f 00 12 	mcall	80002770 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000272e:	0f b8       	ld.ub	r8,r7[0x3]
80002730:	1a d8       	st.w	--sp,r8
80002732:	49 3c       	lddpc	r12,8000277c <mic_reply_func+0x80>
80002734:	f0 1f 00 0f 	mcall	80002770 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002738:	0f c8       	ld.ub	r8,r7[0x4]
8000273a:	1a d8       	st.w	--sp,r8
8000273c:	49 1c       	lddpc	r12,80002780 <mic_reply_func+0x84>
8000273e:	f0 1f 00 0d 	mcall	80002770 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002742:	0f d8       	ld.ub	r8,r7[0x5]
80002744:	1a d8       	st.w	--sp,r8
80002746:	49 0c       	lddpc	r12,80002784 <mic_reply_func+0x88>
80002748:	f0 1f 00 0a 	mcall	80002770 <mic_reply_func+0x74>
8000274c:	2f cd       	sub	sp,-16
8000274e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002752:	1a d8       	st.w	--sp,r8
80002754:	48 dc       	lddpc	r12,80002788 <mic_reply_func+0x8c>
80002756:	f0 1f 00 07 	mcall	80002770 <mic_reply_func+0x74>
8000275a:	2f fd       	sub	sp,-4
8000275c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002760:	48 bc       	lddpc	r12,8000278c <mic_reply_func+0x90>
80002762:	f0 1f 00 04 	mcall	80002770 <mic_reply_func+0x74>
80002766:	e3 cd 80 80 	ldm	sp++,r7,pc
8000276a:	00 00       	add	r0,r0
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	d3 1c       	*unknown*
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	6d 78       	ld.w	r8,r6[0x5c]
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	d3 2c       	*unknown*
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	d3 40       	acall	0x34
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	d3 54       	*unknown*
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	d3 70       	acall	0x37
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d3 88       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	d3 a0       	acall	0x3a
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d3 b8       	*unknown*

80002790 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002790:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002794:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002798:	48 bc       	lddpc	r12,800027c4 <dcm_brdcst_func+0x34>
8000279a:	f0 1f 00 0c 	mcall	800027c8 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000279e:	0f 88       	ld.ub	r8,r7[0x0]
800027a0:	1a d8       	st.w	--sp,r8
800027a2:	48 bc       	lddpc	r12,800027cc <dcm_brdcst_func+0x3c>
800027a4:	f0 1f 00 09 	mcall	800027c8 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800027a8:	0f a8       	ld.ub	r8,r7[0x2]
800027aa:	1a d8       	st.w	--sp,r8
800027ac:	48 9c       	lddpc	r12,800027d0 <dcm_brdcst_func+0x40>
800027ae:	f0 1f 00 07 	mcall	800027c8 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800027b2:	0f 98       	ld.ub	r8,r7[0x1]
800027b4:	1a d8       	st.w	--sp,r8
800027b6:	48 8c       	lddpc	r12,800027d4 <dcm_brdcst_func+0x44>
800027b8:	f0 1f 00 04 	mcall	800027c8 <dcm_brdcst_func+0x38>
800027bc:	2f dd       	sub	sp,-12
	
	
}
800027be:	e3 cd 80 80 	ldm	sp++,r7,pc
800027c2:	00 00       	add	r0,r0
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	d3 c8       	*unknown*
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	6d 78       	ld.w	r8,r6[0x5c]
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	d3 dc       	*unknown*
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	d3 f0       	acall	0x3f
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	d4 08       	*unknown*

800027d8 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027d8:	eb cd 40 80 	pushm	r7,lr
800027dc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027de:	19 a9       	ld.ub	r9,r12[0x2]
800027e0:	30 08       	mov	r8,0
800027e2:	f0 09 18 00 	cp.b	r9,r8
800027e6:	c1 b1       	brne	8000281c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027e8:	19 b8       	ld.ub	r8,r12[0x3]
800027ea:	30 19       	mov	r9,1
800027ec:	f2 08 18 00 	cp.b	r8,r9
800027f0:	c0 51       	brne	800027fa <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027f2:	48 ec       	lddpc	r12,80002828 <dcm_reply_func+0x50>
800027f4:	f0 1f 00 0e 	mcall	8000282c <dcm_reply_func+0x54>
800027f8:	c0 a8       	rjmp	8000280c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 51       	brne	80002806 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027fe:	48 dc       	lddpc	r12,80002830 <dcm_reply_func+0x58>
80002800:	f0 1f 00 0b 	mcall	8000282c <dcm_reply_func+0x54>
80002804:	c0 48       	rjmp	8000280c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002806:	48 cc       	lddpc	r12,80002834 <dcm_reply_func+0x5c>
80002808:	f0 1f 00 09 	mcall	8000282c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000280c:	0f d8       	ld.ub	r8,r7[0x5]
8000280e:	1a d8       	st.w	--sp,r8
80002810:	48 ac       	lddpc	r12,80002838 <dcm_reply_func+0x60>
80002812:	f0 1f 00 07 	mcall	8000282c <dcm_reply_func+0x54>
80002816:	2f fd       	sub	sp,-4
80002818:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000281c:	48 8c       	lddpc	r12,8000283c <dcm_reply_func+0x64>
8000281e:	f0 1f 00 04 	mcall	8000282c <dcm_reply_func+0x54>
80002822:	e3 cd 80 80 	ldm	sp++,r7,pc
80002826:	00 00       	add	r0,r0
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	d4 24       	*unknown*
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	6d 78       	ld.w	r8,r6[0x5c]
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	d4 38       	*unknown*
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	d4 4c       	*unknown*
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	d4 60       	acall	0x46
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	d4 6c       	*unknown*

80002840 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002840:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002842:	19 a9       	ld.ub	r9,r12[0x2]
80002844:	30 08       	mov	r8,0
80002846:	f0 09 18 00 	cp.b	r9,r8
8000284a:	c0 51       	brne	80002854 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000284c:	48 4c       	lddpc	r12,8000285c <ToneControl_reply_func+0x1c>
8000284e:	f0 1f 00 05 	mcall	80002860 <ToneControl_reply_func+0x20>
80002852:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002854:	48 4c       	lddpc	r12,80002864 <ToneControl_reply_func+0x24>
80002856:	f0 1f 00 03 	mcall	80002860 <ToneControl_reply_func+0x20>
8000285a:	d8 02       	popm	pc
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	d4 78       	*unknown*
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	6d 78       	ld.w	r8,r6[0x5c]
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	d4 84       	*unknown*

80002868 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002868:	eb cd 40 80 	pushm	r7,lr
8000286c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000286e:	48 c9       	lddpc	r9,8000289c <app_payload_rx_proc+0x34>
80002870:	13 88       	ld.ub	r8,r9[0x0]
80002872:	2f f8       	sub	r8,-1
80002874:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002876:	30 39       	mov	r9,3
80002878:	f2 08 18 00 	cp.b	r8,r9
8000287c:	c0 71       	brne	8000288a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000287e:	30 09       	mov	r9,0
80002880:	48 78       	lddpc	r8,8000289c <app_payload_rx_proc+0x34>
80002882:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002884:	48 7c       	lddpc	r12,800028a0 <app_payload_rx_proc+0x38>
80002886:	f0 1f 00 08 	mcall	800028a4 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000288a:	48 88       	lddpc	r8,800028a8 <app_payload_rx_proc+0x40>
8000288c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000288e:	48 88       	lddpc	r8,800028ac <app_payload_rx_proc+0x44>
80002890:	70 0c       	ld.w	r12,r8[0x0]
80002892:	0e 9b       	mov	r11,r7
80002894:	f0 1f 00 07 	mcall	800028b0 <app_payload_rx_proc+0x48>

}
80002898:	e3 cd 80 80 	ldm	sp++,r7,pc
8000289c:	00 00       	add	r0,r0
8000289e:	0a 55       	eor	r5,r5
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	d4 90       	acall	0x49
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	6d 78       	ld.w	r8,r6[0x5c]
800028a8:	00 00       	add	r0,r0
800028aa:	0a 43       	or	r3,r5
800028ac:	00 00       	add	r0,r0
800028ae:	0a a4       	st.w	r5++,r4
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	29 e0       	sub	r0,-98

800028b4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028b4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028b6:	19 e8       	ld.ub	r8,r12[0x6]
800028b8:	30 19       	mov	r9,1
800028ba:	f2 08 18 00 	cp.b	r8,r9
800028be:	c0 61       	brne	800028ca <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028c0:	48 98       	lddpc	r8,800028e4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c2:	70 09       	ld.w	r9,r8[0x0]
800028c4:	a1 a9       	sbr	r9,0x0
800028c6:	91 09       	st.w	r8[0x0],r9
800028c8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ca:	30 29       	mov	r9,2
800028cc:	f2 08 18 00 	cp.b	r8,r9
800028d0:	c0 80       	breq	800028e0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028d2:	48 58       	lddpc	r8,800028e4 <DeviceInitializationStatus_brdcst_func+0x30>
800028d4:	70 09       	ld.w	r9,r8[0x0]
800028d6:	e0 19 ff fc 	andl	r9,0xfffc
800028da:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028dc:	f0 1f 00 03 	mcall	800028e8 <DeviceInitializationStatus_brdcst_func+0x34>
800028e0:	d8 02       	popm	pc
800028e2:	00 00       	add	r0,r0
800028e4:	00 00       	add	r0,r0
800028e6:	0d 94       	ld.ub	r4,r6[0x1]
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	41 a0       	lddsp	r0,sp[0x68]

800028ec <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028ec:	20 1c       	sub	r12,1
800028ee:	5c 5c       	castu.b	r12
800028f0:	31 18       	mov	r8,17
800028f2:	f0 0c 18 00 	cp.b	r12,r8
800028f6:	e0 88 00 03 	brls	800028fc <CalculateBurst+0x10>
800028fa:	5e fd       	retal	0
800028fc:	48 28       	lddpc	r8,80002904 <CalculateBurst+0x18>
800028fe:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002902:	5e fc       	retal	r12
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	d4 a4       	*unknown*

80002908 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002908:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000290a:	48 98       	lddpc	r8,8000292c <payload_init+0x24>
8000290c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000290e:	48 98       	lddpc	r8,80002930 <payload_init+0x28>
80002910:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002912:	30 09       	mov	r9,0
80002914:	1a d9       	st.w	--sp,r9
80002916:	1a d9       	st.w	--sp,r9
80002918:	1a d9       	st.w	--sp,r9
8000291a:	30 28       	mov	r8,2
8000291c:	e0 6a 04 00 	mov	r10,1024
80002920:	48 5b       	lddpc	r11,80002934 <payload_init+0x2c>
80002922:	48 6c       	lddpc	r12,80002938 <payload_init+0x30>
80002924:	f0 1f 00 06 	mcall	8000293c <payload_init+0x34>
80002928:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000292a:	d8 02       	popm	pc
8000292c:	00 00       	add	r0,r0
8000292e:	0a 5c       	eor	r12,r5
80002930:	00 00       	add	r0,r0
80002932:	0a 60       	and	r0,r5
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	d4 ec       	*unknown*
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	29 40       	sub	r0,-108
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	69 b4       	ld.w	r4,r4[0x6c]

80002940 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002940:	eb cd 40 f8 	pushm	r3-r7,lr
80002944:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002946:	48 e8       	lddpc	r8,8000297c <payload_rx_process+0x3c>
80002948:	70 08       	ld.w	r8,r8[0x0]
8000294a:	58 08       	cp.w	r8,0
8000294c:	c0 71       	brne	8000295a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000294e:	30 4b       	mov	r11,4
80002950:	30 5c       	mov	r12,5
80002952:	f0 1f 00 0c 	mcall	80002980 <payload_rx_process+0x40>
80002956:	48 a8       	lddpc	r8,8000297c <payload_rx_process+0x3c>
80002958:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000295a:	48 96       	lddpc	r6,8000297c <payload_rx_process+0x3c>
8000295c:	30 05       	mov	r5,0
8000295e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002960:	48 93       	lddpc	r3,80002984 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002962:	6c 0c       	ld.w	r12,r6[0x0]
80002964:	0a 99       	mov	r9,r5
80002966:	08 9a       	mov	r10,r4
80002968:	1a 9b       	mov	r11,sp
8000296a:	f0 1f 00 08 	mcall	80002988 <payload_rx_process+0x48>
8000296e:	58 1c       	cp.w	r12,1
80002970:	cf 91       	brne	80002962 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002972:	66 08       	ld.w	r8,r3[0x0]
80002974:	40 0c       	lddsp	r12,sp[0x0]
80002976:	5d 18       	icall	r8
80002978:	cf 5b       	rjmp	80002962 <payload_rx_process+0x22>
8000297a:	00 00       	add	r0,r0
8000297c:	00 00       	add	r0,r0
8000297e:	0a 74       	tst	r4,r5
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	62 e0       	ld.w	r0,r1[0x38]
80002984:	00 00       	add	r0,r0
80002986:	0a 5c       	eor	r12,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	5f d4       	srvc	r4

8000298c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000298c:	d4 01       	pushm	lr
8000298e:	20 2d       	sub	sp,8
80002990:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 09       	mov	r9,0
80002994:	fa ca ff f8 	sub	r10,sp,-8
80002998:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000299a:	1a 9b       	mov	r11,sp
8000299c:	f0 1f 00 02 	mcall	800029a4 <set_idle_store_isr+0x18>
}
800029a0:	2f ed       	sub	sp,-8
800029a2:	d8 02       	popm	pc
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	61 90       	ld.w	r0,r0[0x64]

800029a8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029a8:	d4 01       	pushm	lr
800029aa:	20 2d       	sub	sp,8
800029ac:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029ae:	58 0c       	cp.w	r12,0
800029b0:	c1 10       	breq	800029d2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029b2:	30 08       	mov	r8,0
800029b4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029b6:	98 88       	ld.uh	r8,r12[0x0]
800029b8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029bc:	e0 48 40 00 	cp.w	r8,16384
800029c0:	c0 91       	brne	800029d2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029c2:	48 68       	lddpc	r8,800029d8 <phy_rx+0x30>
800029c4:	70 0c       	ld.w	r12,r8[0x0]
800029c6:	30 09       	mov	r9,0
800029c8:	fa ca ff fc 	sub	r10,sp,-4
800029cc:	1a 9b       	mov	r11,sp
800029ce:	f0 1f 00 04 	mcall	800029dc <phy_rx+0x34>
		}	

    }
		
 
}
800029d2:	2f ed       	sub	sp,-8
800029d4:	d8 02       	popm	pc
800029d6:	00 00       	add	r0,r0
800029d8:	00 00       	add	r0,r0
800029da:	0a b8       	st.h	r5++,r8
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	61 90       	ld.w	r0,r0[0x64]

800029e0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029e0:	eb cd 40 80 	pushm	r7,lr
800029e4:	20 1d       	sub	sp,4
800029e6:	fa c7 ff fc 	sub	r7,sp,-4
800029ea:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029ec:	30 09       	mov	r9,0
800029ee:	12 9a       	mov	r10,r9
800029f0:	1a 9b       	mov	r11,sp
800029f2:	f0 1f 00 03 	mcall	800029fc <set_idle_store+0x1c>
}
800029f6:	2f fd       	sub	sp,-4
800029f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	61 e0       	ld.w	r0,r0[0x78]

80002a00 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a00:	d4 01       	pushm	lr
80002a02:	20 1d       	sub	sp,4
80002a04:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a06:	98 88       	ld.uh	r8,r12[0x0]
80002a08:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a0c:	e0 48 40 00 	cp.w	r8,16384
80002a10:	c0 d1       	brne	80002a2a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a12:	49 08       	lddpc	r8,80002a50 <phy_tx+0x50>
80002a14:	70 08       	ld.w	r8,r8[0x0]
80002a16:	58 08       	cp.w	r8,0
80002a18:	c1 a0       	breq	80002a4c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a1a:	48 e8       	lddpc	r8,80002a50 <phy_tx+0x50>
80002a1c:	70 0c       	ld.w	r12,r8[0x0]
80002a1e:	30 09       	mov	r9,0
80002a20:	12 9a       	mov	r10,r9
80002a22:	1a 9b       	mov	r11,sp
80002a24:	f0 1f 00 0c 	mcall	80002a54 <phy_tx+0x54>
80002a28:	c1 28       	rjmp	80002a4c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a2a:	e0 48 10 00 	cp.w	r8,4096
80002a2e:	5f 0a       	sreq	r10
80002a30:	e0 48 20 00 	cp.w	r8,8192
80002a34:	5f 09       	sreq	r9
80002a36:	f5 e9 10 09 	or	r9,r10,r9
80002a3a:	c0 71       	brne	80002a48 <phy_tx+0x48>
80002a3c:	e0 48 50 00 	cp.w	r8,20480
80002a40:	c0 40       	breq	80002a48 <phy_tx+0x48>
80002a42:	e0 48 60 00 	cp.w	r8,24576
80002a46:	c0 31       	brne	80002a4c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a48:	48 48       	lddpc	r8,80002a58 <phy_tx+0x58>
80002a4a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a4c:	2f fd       	sub	sp,-4
80002a4e:	d8 02       	popm	pc
80002a50:	00 00       	add	r0,r0
80002a52:	0a cc       	st.b	r5++,r12
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	61 e0       	ld.w	r0,r0[0x78]
80002a58:	00 00       	add	r0,r0
80002a5a:	0a ac       	st.w	r5++,r12

80002a5c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a5c:	d4 01       	pushm	lr
80002a5e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a60:	30 08       	mov	r8,0
80002a62:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a64:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a66:	1a 9a       	mov	r10,sp
80002a68:	fa cb ff fc 	sub	r11,sp,-4
80002a6c:	f0 1f 00 05 	mcall	80002a80 <get_idle_store_isr+0x24>
80002a70:	58 1c       	cp.w	r12,1
80002a72:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a76:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a7a:	2f ed       	sub	sp,-8
80002a7c:	d8 02       	popm	pc
80002a7e:	00 00       	add	r0,r0
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	5e e4       	retqs	r4

80002a84 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a84:	eb cd 40 c0 	pushm	r6-r7,lr
80002a88:	20 1d       	sub	sp,4
80002a8a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a8c:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a90:	70 08       	ld.w	r8,r8[0x0]
80002a92:	58 08       	cp.w	r8,0
80002a94:	c7 40       	breq	80002b7c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a96:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a98:	30 08       	mov	r8,0
80002a9a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a9c:	fe f8 04 64 	ld.w	r8,pc[1124]
80002aa0:	70 08       	ld.w	r8,r8[0x0]
80002aa2:	58 18       	cp.w	r8,1
80002aa4:	c2 90       	breq	80002af6 <phy_tx_func+0x72>
80002aa6:	c0 43       	brcs	80002aae <phy_tx_func+0x2a>
80002aa8:	58 28       	cp.w	r8,2
80002aaa:	c6 91       	brne	80002b7c <phy_tx_func+0xf8>
80002aac:	c6 18       	rjmp	80002b6e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002aae:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002ab2:	70 0c       	ld.w	r12,r8[0x0]
80002ab4:	1a 9a       	mov	r10,sp
80002ab6:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002aba:	f0 1f 01 14 	mcall	80002f08 <phy_tx_func+0x484>
80002abe:	58 1c       	cp.w	r12,1
80002ac0:	c1 51       	brne	80002aea <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ac2:	fe f8 04 42 	ld.w	r8,pc[1090]
80002ac6:	70 08       	ld.w	r8,r8[0x0]
80002ac8:	11 9a       	ld.ub	r10,r8[0x1]
80002aca:	fe f9 04 42 	ld.w	r9,pc[1090]
80002ace:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ad0:	90 88       	ld.uh	r8,r8[0x0]
80002ad2:	ea 18 ab cd 	orh	r8,0xabcd
80002ad6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ad8:	30 19       	mov	r9,1
80002ada:	fe f8 04 36 	ld.w	r8,pc[1078]
80002ade:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ae0:	30 19       	mov	r9,1
80002ae2:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002ae6:	91 09       	st.w	r8[0x0],r9
80002ae8:	c4 a8       	rjmp	80002b7c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aea:	e0 68 5a 5a 	mov	r8,23130
80002aee:	ea 18 ab cd 	orh	r8,0xabcd
80002af2:	8f 18       	st.w	r7[0x4],r8
80002af4:	c4 48       	rjmp	80002b7c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002af6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002afa:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002afc:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b00:	74 0a       	ld.w	r10,r10[0x0]
80002b02:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b06:	b1 6a       	lsl	r10,0x10
80002b08:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b0a:	2f f8       	sub	r8,-1
80002b0c:	5c 58       	castu.b	r8
80002b0e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b10:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b14:	94 09       	ld.sh	r9,r10[0x0]
80002b16:	20 29       	sub	r9,2
80002b18:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b1a:	30 0a       	mov	r10,0
80002b1c:	f4 09 19 00 	cp.h	r9,r10
80002b20:	e0 89 00 0b 	brgt	80002b36 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b24:	78 18       	ld.w	r8,r12[0x4]
80002b26:	e8 18 00 ba 	orl	r8,0xba
80002b2a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b2c:	30 09       	mov	r9,0
80002b2e:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b32:	91 09       	st.w	r8[0x0],r9
80002b34:	c2 48       	rjmp	80002b7c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b36:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b3a:	72 09       	ld.w	r9,r9[0x0]
80002b3c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b40:	78 1a       	ld.w	r10,r12[0x4]
80002b42:	f5 e9 10 09 	or	r9,r10,r9
80002b46:	99 19       	st.w	r12[0x4],r9
80002b48:	2f f8       	sub	r8,-1
80002b4a:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b4e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b50:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b54:	92 08       	ld.sh	r8,r9[0x0]
80002b56:	20 28       	sub	r8,2
80002b58:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b5a:	30 09       	mov	r9,0
80002b5c:	f2 08 19 00 	cp.h	r8,r9
80002b60:	e0 89 00 0e 	brgt	80002b7c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b64:	30 29       	mov	r9,2
80002b66:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b6a:	91 09       	st.w	r8[0x0],r9
80002b6c:	c0 88       	rjmp	80002b7c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b6e:	fc 18 00 ba 	movh	r8,0xba
80002b72:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b74:	30 09       	mov	r9,0
80002b76:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b7a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b7c:	fe f8 03 98 	ld.w	r8,pc[920]
80002b80:	11 89       	ld.ub	r9,r8[0x0]
80002b82:	30 18       	mov	r8,1
80002b84:	f0 09 18 00 	cp.b	r9,r8
80002b88:	e0 81 01 af 	brne	80002ee6 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b8c:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b90:	70 08       	ld.w	r8,r8[0x0]
80002b92:	e0 48 05 b0 	cp.w	r8,1456
80002b96:	f9 b8 02 00 	movhs	r8,0
80002b9a:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b9e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002ba0:	fe f8 03 7c 	ld.w	r8,pc[892]
80002ba4:	70 08       	ld.w	r8,r8[0x0]
80002ba6:	58 68       	cp.w	r8,6
80002ba8:	e0 8b 01 95 	brhi	80002ed2 <phy_tx_func+0x44e>
80002bac:	fe f9 03 74 	ld.w	r9,pc[884]
80002bb0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002bb4:	fe f8 03 70 	ld.w	r8,pc[880]
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	58 08       	cp.w	r8,0
80002bbc:	c0 b0       	breq	80002bd2 <phy_tx_func+0x14e>
80002bbe:	fe f8 03 66 	ld.w	r8,pc[870]
80002bc2:	70 08       	ld.w	r8,r8[0x0]
80002bc4:	58 a8       	cp.w	r8,10
80002bc6:	c0 60       	breq	80002bd2 <phy_tx_func+0x14e>
80002bc8:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bcc:	70 08       	ld.w	r8,r8[0x0]
80002bce:	58 18       	cp.w	r8,1
80002bd0:	c0 a1       	brne	80002be4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bd2:	e0 68 5a 5a 	mov	r8,23130
80002bd6:	ea 18 ab cd 	orh	r8,0xabcd
80002bda:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bdc:	30 08       	mov	r8,0
80002bde:	8f 38       	st.w	r7[0xc],r8
80002be0:	e0 8f 01 8a 	bral	80002ef4 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002be4:	fe f8 03 40 	ld.w	r8,pc[832]
80002be8:	70 08       	ld.w	r8,r8[0x0]
80002bea:	58 38       	cp.w	r8,3
80002bec:	c0 91       	brne	80002bfe <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bee:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bf2:	70 09       	ld.w	r9,r8[0x0]
80002bf4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bf6:	70 18       	ld.w	r8,r8[0x4]
80002bf8:	8f 38       	st.w	r7[0xc],r8
80002bfa:	e0 8f 01 7d 	bral	80002ef4 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bfe:	fe f8 03 26 	ld.w	r8,pc[806]
80002c02:	70 08       	ld.w	r8,r8[0x0]
80002c04:	58 28       	cp.w	r8,2
80002c06:	c1 31       	brne	80002c2c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c08:	e0 68 c0 32 	mov	r8,49202
80002c0c:	ea 18 ab cd 	orh	r8,0xabcd
80002c10:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c12:	fe 78 84 7f 	mov	r8,-31617
80002c16:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c18:	fe f8 03 14 	ld.w	r8,pc[788]
80002c1c:	90 08       	ld.sh	r8,r8[0x0]
80002c1e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c20:	30 39       	mov	r9,3
80002c22:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c26:	91 09       	st.w	r8[0x0],r9
80002c28:	e0 8f 01 66 	bral	80002ef4 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c2c:	e0 68 c0 0e 	mov	r8,49166
80002c30:	ea 18 ab cd 	orh	r8,0xabcd
80002c34:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c36:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c3a:	90 09       	ld.sh	r9,r8[0x0]
80002c3c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c3e:	90 18       	ld.sh	r8,r8[0x2]
80002c40:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c42:	30 19       	mov	r9,1
80002c44:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c48:	91 09       	st.w	r8[0x0],r9
80002c4a:	e0 8f 01 55 	bral	80002ef4 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c4e:	fe 78 88 f2 	mov	r8,-30478
80002c52:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c54:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c58:	70 08       	ld.w	r8,r8[0x0]
80002c5a:	58 48       	cp.w	r8,4
80002c5c:	c0 60       	breq	80002c68 <phy_tx_func+0x1e4>
80002c5e:	c4 53       	brcs	80002ce8 <phy_tx_func+0x264>
80002c60:	58 98       	cp.w	r8,9
80002c62:	e0 8b 00 43 	brhi	80002ce8 <phy_tx_func+0x264>
80002c66:	c2 98       	rjmp	80002cb8 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c68:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c6c:	11 89       	ld.ub	r9,r8[0x0]
80002c6e:	30 18       	mov	r8,1
80002c70:	f0 09 18 00 	cp.b	r9,r8
80002c74:	c0 a1       	brne	80002c88 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c76:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c7a:	90 09       	ld.sh	r9,r8[0x0]
80002c7c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c7e:	90 19       	ld.sh	r9,r8[0x2]
80002c80:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c82:	90 28       	ld.sh	r8,r8[0x4]
80002c84:	ae 78       	st.h	r7[0xe],r8
80002c86:	c1 48       	rjmp	80002cae <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c88:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c8c:	92 0b       	ld.sh	r11,r9[0x0]
80002c8e:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c92:	90 0a       	ld.sh	r10,r8[0x0]
80002c94:	f7 ea 20 0a 	eor	r10,r11,r10
80002c98:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c9a:	92 1b       	ld.sh	r11,r9[0x2]
80002c9c:	90 1a       	ld.sh	r10,r8[0x2]
80002c9e:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca2:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002ca4:	92 29       	ld.sh	r9,r9[0x4]
80002ca6:	90 28       	ld.sh	r8,r8[0x4]
80002ca8:	f3 e8 20 08 	eor	r8,r9,r8
80002cac:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cae:	30 29       	mov	r9,2
80002cb0:	fe f8 02 6c 	ld.w	r8,pc[620]
80002cb4:	91 09       	st.w	r8[0x0],r9
80002cb6:	c1 f9       	rjmp	80002ef4 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cb8:	fe f9 02 84 	ld.w	r9,pc[644]
80002cbc:	92 0b       	ld.sh	r11,r9[0x0]
80002cbe:	fe f8 02 7a 	ld.w	r8,pc[634]
80002cc2:	90 0a       	ld.sh	r10,r8[0x0]
80002cc4:	f7 ea 20 0a 	eor	r10,r11,r10
80002cc8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cca:	92 1b       	ld.sh	r11,r9[0x2]
80002ccc:	90 1a       	ld.sh	r10,r8[0x2]
80002cce:	f7 ea 20 0a 	eor	r10,r11,r10
80002cd2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cd4:	92 29       	ld.sh	r9,r9[0x4]
80002cd6:	90 28       	ld.sh	r8,r8[0x4]
80002cd8:	f3 e8 20 08 	eor	r8,r9,r8
80002cdc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cde:	30 29       	mov	r9,2
80002ce0:	fe f8 02 3c 	ld.w	r8,pc[572]
80002ce4:	91 09       	st.w	r8[0x0],r9
80002ce6:	c0 79       	rjmp	80002ef4 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ce8:	e0 68 5a 5a 	mov	r8,23130
80002cec:	ea 18 ab cd 	orh	r8,0xabcd
80002cf0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cf2:	30 08       	mov	r8,0
80002cf4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cf6:	fe f9 02 26 	ld.w	r9,pc[550]
80002cfa:	93 08       	st.w	r9[0x0],r8
80002cfc:	cf c8       	rjmp	80002ef4 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cfe:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d02:	90 38       	ld.sh	r8,r8[0x6]
80002d04:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d06:	e0 68 00 ba 	mov	r8,186
80002d0a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d0c:	30 08       	mov	r8,0
80002d0e:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d10:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d12:	30 09       	mov	r9,0
80002d14:	fe f8 02 08 	ld.w	r8,pc[520]
80002d18:	91 09       	st.w	r8[0x0],r9
80002d1a:	ce d8       	rjmp	80002ef4 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d1c:	fe f8 02 10 	ld.w	r8,pc[528]
80002d20:	90 18       	ld.sh	r8,r8[0x2]
80002d22:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d24:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d28:	90 08       	ld.sh	r8,r8[0x0]
80002d2a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d2c:	4f e8       	lddpc	r8,80002f24 <phy_tx_func+0x4a0>
80002d2e:	70 08       	ld.w	r8,r8[0x0]
80002d30:	58 48       	cp.w	r8,4
80002d32:	c0 d1       	brne	80002d4c <phy_tx_func+0x2c8>
80002d34:	fe f8 02 00 	ld.w	r8,pc[512]
80002d38:	11 89       	ld.ub	r9,r8[0x0]
80002d3a:	30 18       	mov	r8,1
80002d3c:	f0 09 18 00 	cp.b	r9,r8
80002d40:	c0 61       	brne	80002d4c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d42:	4f c8       	lddpc	r8,80002f30 <phy_tx_func+0x4ac>
80002d44:	90 18       	ld.sh	r8,r8[0x2]
80002d46:	a9 a8       	sbr	r8,0x8
80002d48:	ae 68       	st.h	r7[0xc],r8
80002d4a:	c0 48       	rjmp	80002d52 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d4c:	4f 98       	lddpc	r8,80002f30 <phy_tx_func+0x4ac>
80002d4e:	90 18       	ld.sh	r8,r8[0x2]
80002d50:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d52:	fe 78 9a 13 	mov	r8,-26093
80002d56:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d58:	30 49       	mov	r9,4
80002d5a:	4f 18       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002d5c:	91 09       	st.w	r8[0x0],r9
80002d5e:	cc b8       	rjmp	80002ef4 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d60:	4f 88       	lddpc	r8,80002f40 <phy_tx_func+0x4bc>
80002d62:	70 0a       	ld.w	r10,r8[0x0]
80002d64:	4f 89       	lddpc	r9,80002f44 <phy_tx_func+0x4c0>
80002d66:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d6a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d6c:	70 0a       	ld.w	r10,r8[0x0]
80002d6e:	2f fa       	sub	r10,-1
80002d70:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d74:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d76:	70 0a       	ld.w	r10,r8[0x0]
80002d78:	2f ea       	sub	r10,-2
80002d7a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d7e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d80:	70 0a       	ld.w	r10,r8[0x0]
80002d82:	2f da       	sub	r10,-3
80002d84:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d88:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d8a:	70 09       	ld.w	r9,r8[0x0]
80002d8c:	2f c9       	sub	r9,-4
80002d8e:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d90:	58 c9       	cp.w	r9,12
80002d92:	c0 51       	brne	80002d9c <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d94:	30 59       	mov	r9,5
80002d96:	4e 28       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002d98:	91 09       	st.w	r8[0x0],r9
80002d9a:	ca d8       	rjmp	80002ef4 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d9c:	30 49       	mov	r9,4
80002d9e:	4e 08       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002da0:	91 09       	st.w	r8[0x0],r9
80002da2:	ca 98       	rjmp	80002ef4 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002da4:	4e 78       	lddpc	r8,80002f40 <phy_tx_func+0x4bc>
80002da6:	70 0a       	ld.w	r10,r8[0x0]
80002da8:	4e 79       	lddpc	r9,80002f44 <phy_tx_func+0x4c0>
80002daa:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dae:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002db0:	30 09       	mov	r9,0
80002db2:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002db4:	fe 78 80 03 	mov	r8,-32765
80002db8:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002dba:	fe 78 88 f3 	mov	r8,-30477
80002dbe:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002dc0:	4d 98       	lddpc	r8,80002f24 <phy_tx_func+0x4a0>
80002dc2:	70 08       	ld.w	r8,r8[0x0]
80002dc4:	58 48       	cp.w	r8,4
80002dc6:	c0 60       	breq	80002dd2 <phy_tx_func+0x34e>
80002dc8:	c2 83       	brcs	80002e18 <phy_tx_func+0x394>
80002dca:	58 98       	cp.w	r8,9
80002dcc:	e0 8b 00 26 	brhi	80002e18 <phy_tx_func+0x394>
80002dd0:	c1 98       	rjmp	80002e02 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dd2:	4d 98       	lddpc	r8,80002f34 <phy_tx_func+0x4b0>
80002dd4:	11 89       	ld.ub	r9,r8[0x0]
80002dd6:	30 18       	mov	r8,1
80002dd8:	f0 09 18 00 	cp.b	r9,r8
80002ddc:	c0 81       	brne	80002dec <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dde:	4d 88       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002de0:	90 0a       	ld.sh	r10,r8[0x0]
80002de2:	4d a9       	lddpc	r9,80002f48 <phy_tx_func+0x4c4>
80002de4:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002de6:	90 08       	ld.sh	r8,r8[0x0]
80002de8:	ae 78       	st.h	r7[0xe],r8
80002dea:	c0 88       	rjmp	80002dfa <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dec:	4d 78       	lddpc	r8,80002f48 <phy_tx_func+0x4c4>
80002dee:	90 08       	ld.sh	r8,r8[0x0]
80002df0:	4d 39       	lddpc	r9,80002f3c <phy_tx_func+0x4b8>
80002df2:	92 09       	ld.sh	r9,r9[0x0]
80002df4:	f3 e8 20 08 	eor	r8,r9,r8
80002df8:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dfa:	30 69       	mov	r9,6
80002dfc:	4c 88       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002dfe:	91 09       	st.w	r8[0x0],r9
80002e00:	c7 a8       	rjmp	80002ef4 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e02:	4d 28       	lddpc	r8,80002f48 <phy_tx_func+0x4c4>
80002e04:	90 08       	ld.sh	r8,r8[0x0]
80002e06:	4c e9       	lddpc	r9,80002f3c <phy_tx_func+0x4b8>
80002e08:	92 09       	ld.sh	r9,r9[0x0]
80002e0a:	f3 e8 20 08 	eor	r8,r9,r8
80002e0e:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e10:	30 69       	mov	r9,6
80002e12:	4c 38       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002e14:	91 09       	st.w	r8[0x0],r9
80002e16:	c6 f8       	rjmp	80002ef4 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e18:	e0 68 5a 5a 	mov	r8,23130
80002e1c:	ea 18 ab cd 	orh	r8,0xabcd
80002e20:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e22:	30 08       	mov	r8,0
80002e24:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e26:	4b e9       	lddpc	r9,80002f1c <phy_tx_func+0x498>
80002e28:	93 08       	st.w	r9[0x0],r8
80002e2a:	c6 58       	rjmp	80002ef4 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e2c:	4b e8       	lddpc	r8,80002f24 <phy_tx_func+0x4a0>
80002e2e:	70 08       	ld.w	r8,r8[0x0]
80002e30:	58 48       	cp.w	r8,4
80002e32:	c0 60       	breq	80002e3e <phy_tx_func+0x3ba>
80002e34:	c4 53       	brcs	80002ebe <phy_tx_func+0x43a>
80002e36:	58 98       	cp.w	r8,9
80002e38:	e0 8b 00 43 	brhi	80002ebe <phy_tx_func+0x43a>
80002e3c:	c2 d8       	rjmp	80002e96 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e3e:	4b e8       	lddpc	r8,80002f34 <phy_tx_func+0x4b0>
80002e40:	11 89       	ld.ub	r9,r8[0x0]
80002e42:	30 18       	mov	r8,1
80002e44:	f0 09 18 00 	cp.b	r9,r8
80002e48:	c1 31       	brne	80002e6e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e4a:	4b d8       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002e4c:	90 1a       	ld.sh	r10,r8[0x2]
80002e4e:	4b f9       	lddpc	r9,80002f48 <phy_tx_func+0x4c4>
80002e50:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e52:	90 2a       	ld.sh	r10,r8[0x4]
80002e54:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e56:	90 3a       	ld.sh	r10,r8[0x6]
80002e58:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e5a:	90 19       	ld.sh	r9,r8[0x2]
80002e5c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e5e:	90 29       	ld.sh	r9,r8[0x4]
80002e60:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e62:	90 38       	ld.sh	r8,r8[0x6]
80002e64:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e66:	e0 68 00 ba 	mov	r8,186
80002e6a:	ae 78       	st.h	r7[0xe],r8
80002e6c:	c1 18       	rjmp	80002e8e <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e6e:	4b 48       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002e70:	90 1a       	ld.sh	r10,r8[0x2]
80002e72:	4b 69       	lddpc	r9,80002f48 <phy_tx_func+0x4c4>
80002e74:	92 1b       	ld.sh	r11,r9[0x2]
80002e76:	f7 ea 20 0a 	eor	r10,r11,r10
80002e7a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e7c:	90 2a       	ld.sh	r10,r8[0x4]
80002e7e:	92 29       	ld.sh	r9,r9[0x4]
80002e80:	14 59       	eor	r9,r10
80002e82:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e84:	90 38       	ld.sh	r8,r8[0x6]
80002e86:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e88:	e0 68 00 ba 	mov	r8,186
80002e8c:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e8e:	30 09       	mov	r9,0
80002e90:	4a 38       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002e92:	91 09       	st.w	r8[0x0],r9
80002e94:	c3 08       	rjmp	80002ef4 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e96:	4a a8       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002e98:	90 1a       	ld.sh	r10,r8[0x2]
80002e9a:	4a c9       	lddpc	r9,80002f48 <phy_tx_func+0x4c4>
80002e9c:	92 1b       	ld.sh	r11,r9[0x2]
80002e9e:	f7 ea 20 0a 	eor	r10,r11,r10
80002ea2:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002ea4:	90 2a       	ld.sh	r10,r8[0x4]
80002ea6:	92 29       	ld.sh	r9,r9[0x4]
80002ea8:	14 59       	eor	r9,r10
80002eaa:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002eac:	90 38       	ld.sh	r8,r8[0x6]
80002eae:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002eb0:	e0 68 00 ba 	mov	r8,186
80002eb4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002eb6:	30 09       	mov	r9,0
80002eb8:	49 98       	lddpc	r8,80002f1c <phy_tx_func+0x498>
80002eba:	91 09       	st.w	r8[0x0],r9
80002ebc:	c1 c8       	rjmp	80002ef4 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ebe:	e0 68 5a 5a 	mov	r8,23130
80002ec2:	ea 18 ab cd 	orh	r8,0xabcd
80002ec6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ec8:	30 08       	mov	r8,0
80002eca:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ecc:	49 49       	lddpc	r9,80002f1c <phy_tx_func+0x498>
80002ece:	93 08       	st.w	r9[0x0],r8
80002ed0:	c1 28       	rjmp	80002ef4 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ed2:	e0 68 5a 5a 	mov	r8,23130
80002ed6:	ea 18 ab cd 	orh	r8,0xabcd
80002eda:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002edc:	30 08       	mov	r8,0
80002ede:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ee0:	48 f9       	lddpc	r9,80002f1c <phy_tx_func+0x498>
80002ee2:	93 08       	st.w	r9[0x0],r8
80002ee4:	c0 88       	rjmp	80002ef4 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ee6:	e0 68 5a 5a 	mov	r8,23130
80002eea:	ea 18 ab cd 	orh	r8,0xabcd
80002eee:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ef0:	30 08       	mov	r8,0
80002ef2:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ef4:	2f fd       	sub	sp,-4
80002ef6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002efa:	00 00       	add	r0,r0
80002efc:	00 00       	add	r0,r0
80002efe:	0a cc       	st.b	r5++,r12
80002f00:	00 00       	add	r0,r0
80002f02:	0a 88       	andn	r8,r5
80002f04:	00 00       	add	r0,r0
80002f06:	0a e0       	st.h	--r5,r0
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	5e e4       	retqs	r4
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a b2       	st.h	r5++,r2
80002f10:	00 00       	add	r0,r0
80002f12:	0a 68       	and	r8,r5
80002f14:	00 00       	add	r0,r0
80002f16:	0a 4c       	or	r12,r5
80002f18:	00 00       	add	r0,r0
80002f1a:	0a dc       	st.w	--r5,r12
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a 78       	tst	r8,r5
80002f20:	80 00       	ld.sh	r0,r0[0x0]
80002f22:	d4 f8       	*unknown*
80002f24:	00 00       	add	r0,r0
80002f26:	0a d0       	st.w	--r5,r0
80002f28:	00 00       	add	r0,r0
80002f2a:	0a 90       	mov	r0,r5
80002f2c:	00 00       	add	r0,r0
80002f2e:	1d ac       	ld.ub	r12,lr[0x2]
80002f30:	00 00       	add	r0,r0
80002f32:	1e a8       	st.w	pc++,r8
80002f34:	00 00       	add	r0,r0
80002f36:	0a 42       	or	r2,r5
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	d4 9a       	popm	r0-r3,r10,lr
80002f3c:	00 00       	add	r0,r0
80002f3e:	1d a4       	ld.ub	r4,lr[0x2]
80002f40:	00 00       	add	r0,r0
80002f42:	0a d4       	st.w	--r5,r4
80002f44:	00 00       	add	r0,r0
80002f46:	1e ac       	st.w	pc++,r12
80002f48:	00 00       	add	r0,r0
80002f4a:	1d b0       	ld.ub	r0,lr[0x3]

80002f4c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f4c:	d4 01       	pushm	lr
80002f4e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f50:	30 0a       	mov	r10,0
80002f52:	fa cb ff fc 	sub	r11,sp,-4
80002f56:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f58:	14 99       	mov	r9,r10
80002f5a:	1a 9b       	mov	r11,sp
80002f5c:	f0 1f 00 05 	mcall	80002f70 <get_idle_store+0x24>
80002f60:	58 1c       	cp.w	r12,1
80002f62:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f66:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f6a:	2f fd       	sub	sp,-4
80002f6c:	d8 02       	popm	pc
80002f6e:	00 00       	add	r0,r0
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	5f d4       	srvc	r4

80002f74 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f74:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f76:	48 5b       	lddpc	r11,80002f88 <phy_init+0x14>
80002f78:	48 5c       	lddpc	r12,80002f8c <phy_init+0x18>
80002f7a:	f0 1f 00 06 	mcall	80002f90 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002f7e:	f0 1f 00 06 	mcall	80002f94 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002f82:	f0 1f 00 06 	mcall	80002f98 <phy_init+0x24>
	
}
80002f86:	d8 02       	popm	pc
80002f88:	80 00       	ld.sh	r0,r0[0x0]
80002f8a:	2a 84       	sub	r4,-88
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	2f fc       	sub	r12,-1
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	40 44       	lddsp	r4,sp[0x10]
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	40 58       	lddsp	r8,sp[0x14]
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	49 f8       	lddpc	r8,80003014 <phy_rx_func+0x18>

80002f9c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002f9c:	d4 01       	pushm	lr
80002f9e:	20 2d       	sub	sp,8
80002fa0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fa2:	30 08       	mov	r8,0
80002fa4:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002fa6:	48 f8       	lddpc	r8,80002fe0 <payload_rx+0x44>
80002fa8:	70 08       	ld.w	r8,r8[0x0]
80002faa:	58 08       	cp.w	r8,0
80002fac:	c0 71       	brne	80002fba <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002fae:	30 4b       	mov	r11,4
80002fb0:	30 5c       	mov	r12,5
80002fb2:	f0 1f 00 0d 	mcall	80002fe4 <payload_rx+0x48>
80002fb6:	48 b8       	lddpc	r8,80002fe0 <payload_rx+0x44>
80002fb8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002fba:	48 a8       	lddpc	r8,80002fe0 <payload_rx+0x44>
80002fbc:	70 0c       	ld.w	r12,r8[0x0]
80002fbe:	30 09       	mov	r9,0
80002fc0:	fa ca ff fc 	sub	r10,sp,-4
80002fc4:	1a 9b       	mov	r11,sp
80002fc6:	f0 1f 00 09 	mcall	80002fe8 <payload_rx+0x4c>
80002fca:	c0 91       	brne	80002fdc <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002fcc:	48 88       	lddpc	r8,80002fec <payload_rx+0x50>
80002fce:	70 0c       	ld.w	r12,r8[0x0]
80002fd0:	40 0b       	lddsp	r11,sp[0x0]
80002fd2:	f0 1f 00 08 	mcall	80002ff0 <payload_rx+0x54>
		logFromISR("mm");
80002fd6:	48 8c       	lddpc	r12,80002ff4 <payload_rx+0x58>
80002fd8:	f0 1f 00 08 	mcall	80002ff8 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002fdc:	2f ed       	sub	sp,-8
80002fde:	d8 02       	popm	pc
80002fe0:	00 00       	add	r0,r0
80002fe2:	0a 74       	tst	r4,r5
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	62 e0       	ld.w	r0,r1[0x38]
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	61 90       	ld.w	r0,r0[0x64]
80002fec:	00 00       	add	r0,r0
80002fee:	0a a4       	st.w	r5++,r4
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	29 8c       	sub	r12,-104
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	d5 14       	*unknown*
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	6f 04       	ld.w	r4,r7[0x40]

80002ffc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ffc:	eb cd 40 e0 	pushm	r5-r7,lr
80003000:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003002:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80003006:	70 08       	ld.w	r8,r8[0x0]
80003008:	58 08       	cp.w	r8,0
8000300a:	e0 80 01 08 	breq	8000321a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000300e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003010:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003014:	70 09       	ld.w	r9,r8[0x0]
80003016:	2f f9       	sub	r9,-1
80003018:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000301a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
8000301e:	70 08       	ld.w	r8,r8[0x0]
80003020:	58 18       	cp.w	r8,1
80003022:	e0 80 00 85 	breq	8000312c <phy_rx_func+0x130>
80003026:	c0 73       	brcs	80003034 <phy_rx_func+0x38>
80003028:	58 28       	cp.w	r8,2
8000302a:	c5 c0       	breq	800030e2 <phy_rx_func+0xe6>
8000302c:	58 38       	cp.w	r8,3
8000302e:	e0 81 00 f6 	brne	8000321a <phy_rx_func+0x21e>
80003032:	cd 58       	rjmp	800031dc <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003034:	e0 6a 5a 5a 	mov	r10,23130
80003038:	ea 1a ab cd 	orh	r10,0xabcd
8000303c:	14 36       	cp.w	r6,r10
8000303e:	e0 80 00 ee 	breq	8000321a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003042:	ec 08 16 10 	lsr	r8,r6,0x10
80003046:	e0 48 ab cd 	cp.w	r8,43981
8000304a:	e0 81 00 e8 	brne	8000321a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000304e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003052:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003056:	20 28       	sub	r8,2
80003058:	fe f9 0e 30 	ld.w	r9,pc[3632]
8000305c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000305e:	30 09       	mov	r9,0
80003060:	f2 08 19 00 	cp.h	r8,r9
80003064:	e0 8a 00 db 	brle	8000321a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003068:	fe f8 0e 24 	ld.w	r8,pc[3620]
8000306c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000306e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80003072:	70 0c       	ld.w	r12,r8[0x0]
80003074:	f0 1f 03 88 	mcall	80003e94 <phy_rx_func+0xe98>
80003078:	fe f8 0e 20 	ld.w	r8,pc[3616]
8000307c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000307e:	58 0c       	cp.w	r12,0
80003080:	e0 80 00 cd 	breq	8000321a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003084:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003088:	90 09       	ld.sh	r9,r8[0x0]
8000308a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000308e:	2f f9       	sub	r9,-1
80003090:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003092:	fe fa 0e 06 	ld.w	r10,pc[3590]
80003096:	74 0a       	ld.w	r10,r10[0x0]
80003098:	fe fb 0d e8 	ld.w	r11,pc[3560]
8000309c:	76 0b       	ld.w	r11,r11[0x0]
8000309e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800030a2:	2f f9       	sub	r9,-1
800030a4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800030a6:	e2 16 0f 00 	andl	r6,0xf00,COH
800030aa:	e0 46 01 00 	cp.w	r6,256
800030ae:	c0 c0       	breq	800030c6 <phy_rx_func+0xca>
800030b0:	e0 8b 00 05 	brhi	800030ba <phy_rx_func+0xbe>
800030b4:	58 06       	cp.w	r6,0
800030b6:	c0 80       	breq	800030c6 <phy_rx_func+0xca>
800030b8:	c0 c8       	rjmp	800030d0 <phy_rx_func+0xd4>
800030ba:	e0 46 02 00 	cp.w	r6,512
800030be:	c0 40       	breq	800030c6 <phy_rx_func+0xca>
800030c0:	e0 46 03 00 	cp.w	r6,768
800030c4:	c0 61       	brne	800030d0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800030c6:	30 29       	mov	r9,2
800030c8:	fe f8 0d bc 	ld.w	r8,pc[3516]
800030cc:	91 09       	st.w	r8[0x0],r9
800030ce:	ca 68       	rjmp	8000321a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800030d0:	fe f8 0d c0 	ld.w	r8,pc[3520]
800030d4:	70 0c       	ld.w	r12,r8[0x0]
800030d6:	fe f8 0d c2 	ld.w	r8,pc[3522]
800030da:	70 0b       	ld.w	r11,r8[0x0]
800030dc:	f0 1f 03 70 	mcall	80003e9c <phy_rx_func+0xea0>
800030e0:	c9 d8       	rjmp	8000321a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800030e2:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800030e6:	b1 86       	lsr	r6,0x10
800030e8:	14 06       	add	r6,r10
800030ea:	fe f8 0d b6 	ld.w	r8,pc[3510]
800030ee:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800030f0:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800030f4:	90 09       	ld.sh	r9,r8[0x0]
800030f6:	fe fb 0d a2 	ld.w	r11,pc[3490]
800030fa:	76 0b       	ld.w	r11,r11[0x0]
800030fc:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003100:	2f f9       	sub	r9,-1
80003102:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003104:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003108:	92 08       	ld.sh	r8,r9[0x0]
8000310a:	20 28       	sub	r8,2
8000310c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000310e:	30 09       	mov	r9,0
80003110:	f2 08 19 00 	cp.h	r8,r9
80003114:	e0 8a 00 07 	brle	80003122 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003118:	30 19       	mov	r9,1
8000311a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
8000311e:	91 09       	st.w	r8[0x0],r9
80003120:	c7 d8       	rjmp	8000321a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003122:	30 39       	mov	r9,3
80003124:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003128:	91 09       	st.w	r8[0x0],r9
8000312a:	c7 88       	rjmp	8000321a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000312c:	ec 0a 14 10 	asr	r10,r6,0x10
80003130:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003134:	90 09       	ld.sh	r9,r8[0x0]
80003136:	14 09       	add	r9,r10
80003138:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000313a:	fe f9 0d 52 	ld.w	r9,pc[3410]
8000313e:	92 08       	ld.sh	r8,r9[0x0]
80003140:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003144:	76 0b       	ld.w	r11,r11[0x0]
80003146:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000314a:	2f f8       	sub	r8,-1
8000314c:	5c 88       	casts.h	r8
8000314e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003150:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003154:	94 09       	ld.sh	r9,r10[0x0]
80003156:	20 29       	sub	r9,2
80003158:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000315a:	30 0a       	mov	r10,0
8000315c:	f4 09 19 00 	cp.h	r9,r10
80003160:	e0 89 00 20 	brgt	800031a0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003164:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003168:	e0 46 00 ba 	cp.w	r6,186
8000316c:	c0 d1       	brne	80003186 <phy_rx_func+0x18a>
8000316e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80003172:	90 09       	ld.sh	r9,r8[0x0]
80003174:	f4 09 19 00 	cp.h	r9,r10
80003178:	c0 71       	brne	80003186 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000317a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000317e:	70 0c       	ld.w	r12,r8[0x0]
80003180:	f0 1f 03 49 	mcall	80003ea4 <phy_rx_func+0xea8>
80003184:	c0 98       	rjmp	80003196 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003186:	fe f8 0d 0a 	ld.w	r8,pc[3338]
8000318a:	70 0c       	ld.w	r12,r8[0x0]
8000318c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003190:	70 0b       	ld.w	r11,r8[0x0]
80003192:	f0 1f 03 43 	mcall	80003e9c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003196:	30 09       	mov	r9,0
80003198:	fe f8 0c ec 	ld.w	r8,pc[3308]
8000319c:	91 09       	st.w	r8[0x0],r9
8000319e:	c3 e8       	rjmp	8000321a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800031a0:	5c 86       	casts.h	r6
800031a2:	fe f9 0c fe 	ld.w	r9,pc[3326]
800031a6:	92 0a       	ld.sh	r10,r9[0x0]
800031a8:	0c 0a       	add	r10,r6
800031aa:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031ac:	fe f9 0c ec 	ld.w	r9,pc[3308]
800031b0:	72 09       	ld.w	r9,r9[0x0]
800031b2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031b6:	2f f8       	sub	r8,-1
800031b8:	fe f9 0c d4 	ld.w	r9,pc[3284]
800031bc:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031be:	fe f9 0c ca 	ld.w	r9,pc[3274]
800031c2:	92 08       	ld.sh	r8,r9[0x0]
800031c4:	20 28       	sub	r8,2
800031c6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800031c8:	30 09       	mov	r9,0
800031ca:	f2 08 19 00 	cp.h	r8,r9
800031ce:	e0 89 00 26 	brgt	8000321a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800031d2:	30 39       	mov	r9,3
800031d4:	fe f8 0c b0 	ld.w	r8,pc[3248]
800031d8:	91 09       	st.w	r8[0x0],r9
800031da:	c2 08       	rjmp	8000321a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800031dc:	e6 16 00 ff 	andh	r6,0xff,COH
800031e0:	fc 19 00 ba 	movh	r9,0xba
800031e4:	12 36       	cp.w	r6,r9
800031e6:	c0 e1       	brne	80003202 <phy_rx_func+0x206>
800031e8:	fe f8 0c b8 	ld.w	r8,pc[3256]
800031ec:	90 09       	ld.sh	r9,r8[0x0]
800031ee:	30 08       	mov	r8,0
800031f0:	f0 09 19 00 	cp.h	r9,r8
800031f4:	c0 71       	brne	80003202 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800031f6:	fe f8 0c a2 	ld.w	r8,pc[3234]
800031fa:	70 0c       	ld.w	r12,r8[0x0]
800031fc:	f0 1f 03 2a 	mcall	80003ea4 <phy_rx_func+0xea8>
80003200:	c0 98       	rjmp	80003212 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003202:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003206:	70 0c       	ld.w	r12,r8[0x0]
80003208:	fe f8 0c 90 	ld.w	r8,pc[3216]
8000320c:	70 0b       	ld.w	r11,r8[0x0]
8000320e:	f0 1f 03 24 	mcall	80003e9c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003212:	30 09       	mov	r9,0
80003214:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003218:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000321a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000321e:	11 89       	ld.ub	r9,r8[0x0]
80003220:	30 08       	mov	r8,0
80003222:	f0 09 18 00 	cp.b	r9,r8
80003226:	c1 31       	brne	8000324c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003228:	fe f6 0c 84 	ld.w	r6,pc[3204]
8000322c:	6c 0c       	ld.w	r12,r6[0x0]
8000322e:	f0 1f 03 1a 	mcall	80003e94 <phy_rx_func+0xe98>
80003232:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003236:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003238:	6c 0c       	ld.w	r12,r6[0x0]
8000323a:	f0 1f 03 17 	mcall	80003e94 <phy_rx_func+0xe98>
8000323e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003242:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003244:	30 19       	mov	r9,1
80003246:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000324a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000324c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003250:	70 08       	ld.w	r8,r8[0x0]
80003252:	58 28       	cp.w	r8,2
80003254:	e0 80 01 98 	breq	80003584 <phy_rx_func+0x588>
80003258:	e0 8b 00 06 	brhi	80003264 <phy_rx_func+0x268>
8000325c:	58 08       	cp.w	r8,0
8000325e:	c0 b0       	breq	80003274 <phy_rx_func+0x278>
80003260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003264:	58 38       	cp.w	r8,3
80003266:	e0 80 05 c5 	breq	80003df0 <phy_rx_func+0xdf4>
8000326a:	58 48       	cp.w	r8,4
8000326c:	e0 81 06 05 	brne	80003e76 <phy_rx_func+0xe7a>
80003270:	e0 8f 02 4b 	bral	80003706 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003274:	6e 28       	ld.w	r8,r7[0x8]
80003276:	e0 6a 5a 5a 	mov	r10,23130
8000327a:	ea 1a ab cd 	orh	r10,0xabcd
8000327e:	14 38       	cp.w	r8,r10
80003280:	c0 71       	brne	8000328e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003282:	30 09       	mov	r9,0
80003284:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003288:	91 09       	st.w	r8[0x0],r9
8000328a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000328e:	10 99       	mov	r9,r8
80003290:	e0 19 00 00 	andl	r9,0x0
80003294:	fc 1a ab cd 	movh	r10,0xabcd
80003298:	14 39       	cp.w	r9,r10
8000329a:	e0 81 05 ee 	brne	80003e76 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000329e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032a2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800032a6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800032a8:	6e 29       	ld.w	r9,r7[0x8]
800032aa:	e2 19 f0 00 	andl	r9,0xf000,COH
800032ae:	e0 49 c0 00 	cp.w	r9,49152
800032b2:	e0 81 00 ce 	brne	8000344e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800032b6:	30 1a       	mov	r10,1
800032b8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800032bc:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800032be:	fe f9 0b f6 	ld.w	r9,pc[3062]
800032c2:	72 09       	ld.w	r9,r9[0x0]
800032c4:	58 09       	cp.w	r9,0
800032c6:	c0 71       	brne	800032d4 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032c8:	fe fc 0c 00 	ld.w	r12,pc[3072]
800032cc:	f0 1f 03 00 	mcall	80003ecc <phy_rx_func+0xed0>
800032d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800032d4:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800032d8:	fe f9 0b f8 	ld.w	r9,pc[3064]
800032dc:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800032de:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800032e2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800032e6:	fe fa 0b ee 	ld.w	r10,pc[3054]
800032ea:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800032ec:	13 89       	ld.ub	r9,r9[0x0]
800032ee:	37 fa       	mov	r10,127
800032f0:	f4 09 18 00 	cp.b	r9,r10
800032f4:	c6 d0       	breq	800033ce <phy_rx_func+0x3d2>
800032f6:	e0 8b 00 0c 	brhi	8000330e <phy_rx_func+0x312>
800032fa:	31 2a       	mov	r10,18
800032fc:	f4 09 18 00 	cp.b	r9,r10
80003300:	c4 20       	breq	80003384 <phy_rx_func+0x388>
80003302:	31 3a       	mov	r10,19
80003304:	f4 09 18 00 	cp.b	r9,r10
80003308:	e0 81 00 83 	brne	8000340e <phy_rx_func+0x412>
8000330c:	c5 b8       	rjmp	800033c2 <phy_rx_func+0x3c6>
8000330e:	2f 09       	sub	r9,-16
80003310:	30 1a       	mov	r10,1
80003312:	f4 09 18 00 	cp.b	r9,r10
80003316:	e0 8b 00 7c 	brhi	8000340e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000331a:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000331e:	e2 18 00 f0 	andl	r8,0xf0,COH
80003322:	59 08       	cp.w	r8,16
80003324:	c0 71       	brne	80003332 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003326:	30 19       	mov	r9,1
80003328:	fe f8 0b 94 	ld.w	r8,pc[2964]
8000332c:	91 09       	st.w	r8[0x0],r9
8000332e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003332:	e0 48 00 20 	cp.w	r8,32
80003336:	c2 11       	brne	80003378 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003338:	30 a9       	mov	r9,10
8000333a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000333e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003340:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003344:	6c 08       	ld.w	r8,r6[0x0]
80003346:	f0 0a 11 ff 	rsub	r10,r8,-1
8000334a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000334e:	2f f8       	sub	r8,-1
80003350:	6e 0c       	ld.w	r12,r7[0x0]
80003352:	f4 ca fe 00 	sub	r10,r10,-512
80003356:	30 0b       	mov	r11,0
80003358:	10 0c       	add	r12,r8
8000335a:	f0 1f 02 e1 	mcall	80003edc <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000335e:	30 08       	mov	r8,0
80003360:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003362:	6e 0c       	ld.w	r12,r7[0x0]
80003364:	f0 1f 02 df 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003368:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000336c:	70 0c       	ld.w	r12,r8[0x0]
8000336e:	f0 1f 02 ca 	mcall	80003e94 <phy_rx_func+0xe98>
80003372:	8f 0c       	st.w	r7[0x0],r12
80003374:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003378:	30 09       	mov	r9,0
8000337a:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000337e:	91 09       	st.w	r8[0x0],r9
80003380:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003384:	20 48       	sub	r8,4
80003386:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000338a:	93 08       	st.w	r9[0x0],r8
8000338c:	58 08       	cp.w	r8,0
8000338e:	e0 80 05 74 	breq	80003e76 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003392:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003396:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000339a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000339e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800033a0:	8e 69       	ld.sh	r9,r7[0xc]
800033a2:	fe f8 0b 46 	ld.w	r8,pc[2886]
800033a6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800033a8:	8e 79       	ld.sh	r9,r7[0xe]
800033aa:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800033ac:	f0 1f 02 d0 	mcall	80003eec <phy_rx_func+0xef0>
800033b0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800033b4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800033b6:	30 49       	mov	r9,4
800033b8:	fe f8 0b 00 	ld.w	r8,pc[2816]
800033bc:	91 09       	st.w	r8[0x0],r9
800033be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800033c2:	30 09       	mov	r9,0
800033c4:	fe f8 0a f8 	ld.w	r8,pc[2808]
800033c8:	91 09       	st.w	r8[0x0],r9
800033ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033ce:	20 48       	sub	r8,4
800033d0:	fe f9 0a f0 	ld.w	r9,pc[2800]
800033d4:	93 08       	st.w	r9[0x0],r8
800033d6:	58 08       	cp.w	r8,0
800033d8:	e0 80 05 4f 	breq	80003e76 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800033dc:	fe f8 0b 14 	ld.w	r8,pc[2836]
800033e0:	70 09       	ld.w	r9,r8[0x0]
800033e2:	8e 7b       	ld.sh	r11,r7[0xe]
800033e4:	fe fa 0b 10 	ld.w	r10,pc[2832]
800033e8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800033ec:	2f f9       	sub	r9,-1
800033ee:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800033f0:	fe f8 0a e4 	ld.w	r8,pc[2788]
800033f4:	70 09       	ld.w	r9,r8[0x0]
800033f6:	20 29       	sub	r9,2
800033f8:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800033fa:	30 29       	mov	r9,2
800033fc:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003400:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003402:	30 39       	mov	r9,3
80003404:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003408:	91 09       	st.w	r8[0x0],r9
8000340a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000340e:	30 3a       	mov	r10,3
80003410:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003414:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003416:	6e 2a       	ld.w	r10,r7[0x8]
80003418:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000341c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000341e:	6e 3a       	ld.w	r10,r7[0xc]
80003420:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003422:	59 48       	cp.w	r8,20
80003424:	c0 61       	brne	80003430 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003426:	31 89       	mov	r9,24
80003428:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	c0 a8       	rjmp	80003442 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003430:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003434:	70 08       	ld.w	r8,r8[0x0]
80003436:	59 08       	cp.w	r8,16
80003438:	c0 51       	brne	80003442 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000343a:	31 09       	mov	r9,16
8000343c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003440:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003442:	30 49       	mov	r9,4
80003444:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003448:	91 09       	st.w	r8[0x0],r9
8000344a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000344e:	e0 49 10 00 	cp.w	r9,4096
80003452:	5f 1a       	srne	r10
80003454:	e0 49 20 00 	cp.w	r9,8192
80003458:	5f 19       	srne	r9
8000345a:	f5 e9 00 09 	and	r9,r10,r9
8000345e:	e0 81 05 0c 	brne	80003e76 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003462:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003466:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003468:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000346c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000346e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003472:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003474:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003478:	72 09       	ld.w	r9,r9[0x0]
8000347a:	58 09       	cp.w	r9,0
8000347c:	c0 71       	brne	8000348a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000347e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003482:	f0 1f 02 93 	mcall	80003ecc <phy_rx_func+0xed0>
80003486:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000348a:	6e 2a       	ld.w	r10,r7[0x8]
8000348c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003490:	58 1a       	cp.w	r10,1
80003492:	e0 8b 00 4d 	brhi	8000352c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003496:	20 48       	sub	r8,4
80003498:	fe f9 0a 28 	ld.w	r9,pc[2600]
8000349c:	93 08       	st.w	r9[0x0],r8
8000349e:	58 08       	cp.w	r8,0
800034a0:	e0 80 04 eb 	breq	80003e76 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800034a4:	8e 68       	ld.sh	r8,r7[0xc]
800034a6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800034aa:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800034ae:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800034b0:	30 09       	mov	r9,0
800034b2:	f2 08 19 00 	cp.h	r8,r9
800034b6:	c0 70       	breq	800034c4 <phy_rx_func+0x4c8>
800034b8:	30 19       	mov	r9,1
800034ba:	f2 08 19 00 	cp.h	r8,r9
800034be:	e0 81 04 dc 	brne	80003e76 <phy_rx_func+0xe7a>
800034c2:	c2 68       	rjmp	8000350e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034c4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800034c8:	70 0a       	ld.w	r10,r8[0x0]
800034ca:	fe f9 09 e6 	ld.w	r9,pc[2534]
800034ce:	72 09       	ld.w	r9,r9[0x0]
800034d0:	8e 7b       	ld.sh	r11,r7[0xe]
800034d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800034d6:	70 09       	ld.w	r9,r8[0x0]
800034d8:	2f f9       	sub	r9,-1
800034da:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034dc:	e0 49 00 ff 	cp.w	r9,255
800034e0:	e0 88 00 11 	brls	80003502 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800034e4:	30 09       	mov	r9,0
800034e6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800034e8:	fe f7 09 c8 	ld.w	r7,pc[2504]
800034ec:	6e 0c       	ld.w	r12,r7[0x0]
800034ee:	f0 1f 02 7d 	mcall	80003ee0 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800034f2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800034f6:	70 0c       	ld.w	r12,r8[0x0]
800034f8:	f0 1f 02 67 	mcall	80003e94 <phy_rx_func+0xe98>
800034fc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800034fe:	e0 80 04 bc 	breq	80003e76 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003502:	30 29       	mov	r9,2
80003504:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003508:	91 09       	st.w	r8[0x0],r9
8000350a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000350e:	8e 79       	ld.sh	r9,r7[0xe]
80003510:	30 38       	mov	r8,3
80003512:	f0 09 19 00 	cp.h	r9,r8
80003516:	c0 51       	brne	80003520 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003518:	30 19       	mov	r9,1
8000351a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000351e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003520:	30 29       	mov	r9,2
80003522:	fe f8 09 96 	ld.w	r8,pc[2454]
80003526:	91 09       	st.w	r8[0x0],r9
80003528:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000352c:	58 18       	cp.w	r8,1
8000352e:	e0 88 04 a4 	brls	80003e76 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003532:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003536:	70 0a       	ld.w	r10,r8[0x0]
80003538:	6e 3b       	ld.w	r11,r7[0xc]
8000353a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000353e:	70 09       	ld.w	r9,r8[0x0]
80003540:	2f f9       	sub	r9,-1
80003542:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003544:	e0 49 00 ff 	cp.w	r9,255
80003548:	e0 88 00 11 	brls	8000356a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000354c:	30 09       	mov	r9,0
8000354e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003550:	fe f7 09 60 	ld.w	r7,pc[2400]
80003554:	6e 0c       	ld.w	r12,r7[0x0]
80003556:	f0 1f 02 63 	mcall	80003ee0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000355a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000355e:	70 0c       	ld.w	r12,r8[0x0]
80003560:	f0 1f 02 4d 	mcall	80003e94 <phy_rx_func+0xe98>
80003564:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003566:	e0 80 04 88 	breq	80003e76 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000356a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000356e:	72 08       	ld.w	r8,r9[0x0]
80003570:	20 28       	sub	r8,2
80003572:	93 08       	st.w	r9[0x0],r8
80003574:	e0 80 04 81 	breq	80003e76 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003578:	30 29       	mov	r9,2
8000357a:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000357e:	91 09       	st.w	r8[0x0],r9
80003580:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003584:	fe f8 09 84 	ld.w	r8,pc[2436]
80003588:	70 0a       	ld.w	r10,r8[0x0]
8000358a:	fe f9 09 26 	ld.w	r9,pc[2342]
8000358e:	72 09       	ld.w	r9,r9[0x0]
80003590:	8e 4b       	ld.sh	r11,r7[0x8]
80003592:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003596:	70 09       	ld.w	r9,r8[0x0]
80003598:	2f f9       	sub	r9,-1
8000359a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000359c:	e0 49 00 ff 	cp.w	r9,255
800035a0:	e0 88 00 16 	brls	800035cc <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800035a4:	30 09       	mov	r9,0
800035a6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035a8:	fe f6 09 08 	ld.w	r6,pc[2312]
800035ac:	6c 0c       	ld.w	r12,r6[0x0]
800035ae:	f0 1f 02 4d 	mcall	80003ee0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035b2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800035b6:	70 0c       	ld.w	r12,r8[0x0]
800035b8:	f0 1f 02 37 	mcall	80003e94 <phy_rx_func+0xe98>
800035bc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800035be:	c0 71       	brne	800035cc <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800035c0:	30 09       	mov	r9,0
800035c2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800035c6:	91 09       	st.w	r8[0x0],r9
800035c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800035cc:	fe f9 08 f4 	ld.w	r9,pc[2292]
800035d0:	72 08       	ld.w	r8,r9[0x0]
800035d2:	20 28       	sub	r8,2
800035d4:	93 08       	st.w	r9[0x0],r8
800035d6:	c0 71       	brne	800035e4 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800035d8:	30 09       	mov	r9,0
800035da:	fe f8 08 de 	ld.w	r8,pc[2270]
800035de:	91 09       	st.w	r8[0x0],r9
800035e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800035e4:	fe f8 09 24 	ld.w	r8,pc[2340]
800035e8:	70 0a       	ld.w	r10,r8[0x0]
800035ea:	fe f9 08 c6 	ld.w	r9,pc[2246]
800035ee:	72 09       	ld.w	r9,r9[0x0]
800035f0:	8e 5b       	ld.sh	r11,r7[0xa]
800035f2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035f6:	70 09       	ld.w	r9,r8[0x0]
800035f8:	2f f9       	sub	r9,-1
800035fa:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035fc:	e0 49 00 ff 	cp.w	r9,255
80003600:	e0 88 00 16 	brls	8000362c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003604:	30 09       	mov	r9,0
80003606:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003608:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000360c:	6c 0c       	ld.w	r12,r6[0x0]
8000360e:	f0 1f 02 35 	mcall	80003ee0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003612:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003616:	70 0c       	ld.w	r12,r8[0x0]
80003618:	f0 1f 02 1f 	mcall	80003e94 <phy_rx_func+0xe98>
8000361c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000361e:	c0 71       	brne	8000362c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003620:	30 09       	mov	r9,0
80003622:	fe f8 08 96 	ld.w	r8,pc[2198]
80003626:	91 09       	st.w	r8[0x0],r9
80003628:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000362c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003630:	72 08       	ld.w	r8,r9[0x0]
80003632:	20 28       	sub	r8,2
80003634:	93 08       	st.w	r9[0x0],r8
80003636:	c0 71       	brne	80003644 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003638:	30 09       	mov	r9,0
8000363a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000363e:	91 09       	st.w	r8[0x0],r9
80003640:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003644:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003648:	70 0a       	ld.w	r10,r8[0x0]
8000364a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000364e:	72 09       	ld.w	r9,r9[0x0]
80003650:	8e 6b       	ld.sh	r11,r7[0xc]
80003652:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003656:	70 09       	ld.w	r9,r8[0x0]
80003658:	2f f9       	sub	r9,-1
8000365a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000365c:	e0 49 00 ff 	cp.w	r9,255
80003660:	e0 88 00 16 	brls	8000368c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003664:	30 09       	mov	r9,0
80003666:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003668:	fe f6 08 48 	ld.w	r6,pc[2120]
8000366c:	6c 0c       	ld.w	r12,r6[0x0]
8000366e:	f0 1f 02 1d 	mcall	80003ee0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003672:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003676:	70 0c       	ld.w	r12,r8[0x0]
80003678:	f0 1f 02 07 	mcall	80003e94 <phy_rx_func+0xe98>
8000367c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000367e:	c0 71       	brne	8000368c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003680:	30 09       	mov	r9,0
80003682:	fe f8 08 36 	ld.w	r8,pc[2102]
80003686:	91 09       	st.w	r8[0x0],r9
80003688:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000368c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003690:	72 08       	ld.w	r8,r9[0x0]
80003692:	20 28       	sub	r8,2
80003694:	93 08       	st.w	r9[0x0],r8
80003696:	c0 71       	brne	800036a4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003698:	30 09       	mov	r9,0
8000369a:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000369e:	91 09       	st.w	r8[0x0],r9
800036a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800036a4:	fe f8 08 64 	ld.w	r8,pc[2148]
800036a8:	70 0a       	ld.w	r10,r8[0x0]
800036aa:	fe f9 08 06 	ld.w	r9,pc[2054]
800036ae:	72 09       	ld.w	r9,r9[0x0]
800036b0:	8e 7b       	ld.sh	r11,r7[0xe]
800036b2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036b6:	70 09       	ld.w	r9,r8[0x0]
800036b8:	2f f9       	sub	r9,-1
800036ba:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036bc:	e0 49 00 ff 	cp.w	r9,255
800036c0:	e0 88 00 16 	brls	800036ec <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800036c4:	30 09       	mov	r9,0
800036c6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036c8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800036cc:	6e 0c       	ld.w	r12,r7[0x0]
800036ce:	f0 1f 02 05 	mcall	80003ee0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036d2:	fe f8 07 da 	ld.w	r8,pc[2010]
800036d6:	70 0c       	ld.w	r12,r8[0x0]
800036d8:	f0 1f 01 ef 	mcall	80003e94 <phy_rx_func+0xe98>
800036dc:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800036de:	c0 71       	brne	800036ec <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800036e0:	30 09       	mov	r9,0
800036e2:	fe f8 07 d6 	ld.w	r8,pc[2006]
800036e6:	91 09       	st.w	r8[0x0],r9
800036e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036ec:	fe f9 07 d4 	ld.w	r9,pc[2004]
800036f0:	72 08       	ld.w	r8,r9[0x0]
800036f2:	20 28       	sub	r8,2
800036f4:	93 08       	st.w	r9[0x0],r8
800036f6:	e0 81 03 c0 	brne	80003e76 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800036fa:	30 09       	mov	r9,0
800036fc:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003700:	91 09       	st.w	r8[0x0],r9
80003702:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003706:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000370a:	11 89       	ld.ub	r9,r8[0x0]
8000370c:	31 28       	mov	r8,18
8000370e:	f0 09 18 00 	cp.b	r9,r8
80003712:	e0 81 01 4c 	brne	800039aa <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003716:	ef 39 00 09 	ld.ub	r9,r7[9]
8000371a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000371e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003720:	11 89       	ld.ub	r9,r8[0x0]
80003722:	3f 28       	mov	r8,-14
80003724:	f0 09 18 00 	cp.b	r9,r8
80003728:	e0 81 01 3b 	brne	8000399e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000372c:	30 19       	mov	r9,1
8000372e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003732:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003734:	6e 29       	ld.w	r9,r7[0x8]
80003736:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000373a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000373e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003740:	8e 59       	ld.sh	r9,r7[0xa]
80003742:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003746:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003748:	8e 69       	ld.sh	r9,r7[0xc]
8000374a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000374c:	8e 79       	ld.sh	r9,r7[0xe]
8000374e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003750:	fe f8 07 88 	ld.w	r8,pc[1928]
80003754:	fe f9 07 60 	ld.w	r9,pc[1888]
80003758:	72 0a       	ld.w	r10,r9[0x0]
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003760:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003764:	70 09       	ld.w	r9,r8[0x0]
80003766:	2f f9       	sub	r9,-1
80003768:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000376a:	e0 49 01 ff 	cp.w	r9,511
8000376e:	e0 88 00 16 	brls	8000379a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003772:	30 09       	mov	r9,0
80003774:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003776:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000377a:	6c 0c       	ld.w	r12,r6[0x0]
8000377c:	f0 1f 01 d9 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003780:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003784:	70 0c       	ld.w	r12,r8[0x0]
80003786:	f0 1f 01 c4 	mcall	80003e94 <phy_rx_func+0xe98>
8000378a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000378c:	c0 71       	brne	8000379a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000378e:	30 09       	mov	r9,0
80003790:	fe f8 07 28 	ld.w	r8,pc[1832]
80003794:	91 09       	st.w	r8[0x0],r9
80003796:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000379a:	fe f9 07 26 	ld.w	r9,pc[1830]
8000379e:	72 08       	ld.w	r8,r9[0x0]
800037a0:	20 18       	sub	r8,1
800037a2:	93 08       	st.w	r9[0x0],r8
800037a4:	c0 71       	brne	800037b2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800037a6:	30 09       	mov	r9,0
800037a8:	fe f8 07 10 	ld.w	r8,pc[1808]
800037ac:	91 09       	st.w	r8[0x0],r9
800037ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800037b2:	fe f8 07 26 	ld.w	r8,pc[1830]
800037b6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800037ba:	72 0a       	ld.w	r10,r9[0x0]
800037bc:	70 09       	ld.w	r9,r8[0x0]
800037be:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037c2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037c6:	70 09       	ld.w	r9,r8[0x0]
800037c8:	2f f9       	sub	r9,-1
800037ca:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037cc:	e0 49 01 ff 	cp.w	r9,511
800037d0:	e0 88 00 16 	brls	800037fc <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800037d4:	30 09       	mov	r9,0
800037d6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037d8:	fe f6 06 dc 	ld.w	r6,pc[1756]
800037dc:	6c 0c       	ld.w	r12,r6[0x0]
800037de:	f0 1f 01 c1 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037e2:	fe f8 06 ca 	ld.w	r8,pc[1738]
800037e6:	70 0c       	ld.w	r12,r8[0x0]
800037e8:	f0 1f 01 ab 	mcall	80003e94 <phy_rx_func+0xe98>
800037ec:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 06 c6 	ld.w	r8,pc[1734]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037fc:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003800:	72 08       	ld.w	r8,r9[0x0]
80003802:	20 18       	sub	r8,1
80003804:	93 08       	st.w	r9[0x0],r8
80003806:	c0 71       	brne	80003814 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003808:	30 09       	mov	r9,0
8000380a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000380e:	91 09       	st.w	r8[0x0],r9
80003810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003814:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003818:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000381c:	72 0a       	ld.w	r10,r9[0x0]
8000381e:	70 09       	ld.w	r9,r8[0x0]
80003820:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003824:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003828:	70 09       	ld.w	r9,r8[0x0]
8000382a:	2f f9       	sub	r9,-1
8000382c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000382e:	e0 49 01 ff 	cp.w	r9,511
80003832:	e0 88 00 16 	brls	8000385e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003836:	30 09       	mov	r9,0
80003838:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000383a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000383e:	6c 0c       	ld.w	r12,r6[0x0]
80003840:	f0 1f 01 a8 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003844:	fe f8 06 68 	ld.w	r8,pc[1640]
80003848:	70 0c       	ld.w	r12,r8[0x0]
8000384a:	f0 1f 01 93 	mcall	80003e94 <phy_rx_func+0xe98>
8000384e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003850:	c0 71       	brne	8000385e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 06 64 	ld.w	r8,pc[1636]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000385e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003862:	72 08       	ld.w	r8,r9[0x0]
80003864:	20 18       	sub	r8,1
80003866:	93 08       	st.w	r9[0x0],r8
80003868:	c0 71       	brne	80003876 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000386a:	30 09       	mov	r9,0
8000386c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003870:	91 09       	st.w	r8[0x0],r9
80003872:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003876:	fe f8 06 62 	ld.w	r8,pc[1634]
8000387a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000387e:	72 0a       	ld.w	r10,r9[0x0]
80003880:	70 09       	ld.w	r9,r8[0x0]
80003882:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003886:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000388a:	70 09       	ld.w	r9,r8[0x0]
8000388c:	2f f9       	sub	r9,-1
8000388e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003890:	e0 49 01 ff 	cp.w	r9,511
80003894:	e0 88 00 16 	brls	800038c0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003898:	30 09       	mov	r9,0
8000389a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000389c:	fe f6 06 18 	ld.w	r6,pc[1560]
800038a0:	6c 0c       	ld.w	r12,r6[0x0]
800038a2:	f0 1f 01 90 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038a6:	fe f8 06 06 	ld.w	r8,pc[1542]
800038aa:	70 0c       	ld.w	r12,r8[0x0]
800038ac:	f0 1f 01 7a 	mcall	80003e94 <phy_rx_func+0xe98>
800038b0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038b2:	c0 71       	brne	800038c0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800038b4:	30 09       	mov	r9,0
800038b6:	fe f8 06 02 	ld.w	r8,pc[1538]
800038ba:	91 09       	st.w	r8[0x0],r9
800038bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038c0:	fe f9 06 00 	ld.w	r9,pc[1536]
800038c4:	72 08       	ld.w	r8,r9[0x0]
800038c6:	20 18       	sub	r8,1
800038c8:	93 08       	st.w	r9[0x0],r8
800038ca:	c0 71       	brne	800038d8 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800038cc:	30 09       	mov	r9,0
800038ce:	fe f8 05 ea 	ld.w	r8,pc[1514]
800038d2:	91 09       	st.w	r8[0x0],r9
800038d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800038d8:	fe f8 06 00 	ld.w	r8,pc[1536]
800038dc:	fe f9 05 d8 	ld.w	r9,pc[1496]
800038e0:	72 0a       	ld.w	r10,r9[0x0]
800038e2:	70 09       	ld.w	r9,r8[0x0]
800038e4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800038e8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038ec:	70 09       	ld.w	r9,r8[0x0]
800038ee:	2f f9       	sub	r9,-1
800038f0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f2:	e0 49 01 ff 	cp.w	r9,511
800038f6:	e0 88 00 16 	brls	80003922 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800038fa:	30 09       	mov	r9,0
800038fc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038fe:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003902:	6c 0c       	ld.w	r12,r6[0x0]
80003904:	f0 1f 01 77 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003908:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000390c:	70 0c       	ld.w	r12,r8[0x0]
8000390e:	f0 1f 01 62 	mcall	80003e94 <phy_rx_func+0xe98>
80003912:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003914:	c0 71       	brne	80003922 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003922:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003926:	72 08       	ld.w	r8,r9[0x0]
80003928:	20 18       	sub	r8,1
8000392a:	93 08       	st.w	r9[0x0],r8
8000392c:	c0 71       	brne	8000393a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000392e:	30 09       	mov	r9,0
80003930:	fe f8 05 88 	ld.w	r8,pc[1416]
80003934:	91 09       	st.w	r8[0x0],r9
80003936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000393a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000393e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003942:	72 0a       	ld.w	r10,r9[0x0]
80003944:	70 09       	ld.w	r9,r8[0x0]
80003946:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000394a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000394e:	70 09       	ld.w	r9,r8[0x0]
80003950:	2f f9       	sub	r9,-1
80003952:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003954:	e0 49 01 ff 	cp.w	r9,511
80003958:	e0 88 00 16 	brls	80003984 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000395c:	30 09       	mov	r9,0
8000395e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003960:	fe f7 05 54 	ld.w	r7,pc[1364]
80003964:	6e 0c       	ld.w	r12,r7[0x0]
80003966:	f0 1f 01 5f 	mcall	80003ee0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000396a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000396e:	70 0c       	ld.w	r12,r8[0x0]
80003970:	f0 1f 01 49 	mcall	80003e94 <phy_rx_func+0xe98>
80003974:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003976:	c0 71       	brne	80003984 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003984:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003988:	72 08       	ld.w	r8,r9[0x0]
8000398a:	20 18       	sub	r8,1
8000398c:	93 08       	st.w	r9[0x0],r8
8000398e:	e0 81 02 74 	brne	80003e76 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003992:	30 09       	mov	r9,0
80003994:	fe f8 05 24 	ld.w	r8,pc[1316]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000399e:	30 09       	mov	r9,0
800039a0:	fe f8 05 18 	ld.w	r8,pc[1304]
800039a4:	91 09       	st.w	r8[0x0],r9
800039a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800039aa:	fe f8 05 26 	ld.w	r8,pc[1318]
800039ae:	11 89       	ld.ub	r9,r8[0x0]
800039b0:	3f 28       	mov	r8,-14
800039b2:	f0 09 18 00 	cp.b	r9,r8
800039b6:	c4 31       	brne	80003a3c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800039b8:	8e 49       	ld.sh	r9,r7[0x8]
800039ba:	fe f8 05 56 	ld.w	r8,pc[1366]
800039be:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800039c0:	fe f8 05 18 	ld.w	r8,pc[1304]
800039c4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800039c8:	72 0a       	ld.w	r10,r9[0x0]
800039ca:	70 09       	ld.w	r9,r8[0x0]
800039cc:	ef 3b 00 08 	ld.ub	r11,r7[8]
800039d0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039d4:	70 09       	ld.w	r9,r8[0x0]
800039d6:	2f f9       	sub	r9,-1
800039d8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039da:	e0 49 01 ff 	cp.w	r9,511
800039de:	e0 88 00 16 	brls	80003a0a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039e2:	30 09       	mov	r9,0
800039e4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039e6:	fe f7 04 ce 	ld.w	r7,pc[1230]
800039ea:	6e 0c       	ld.w	r12,r7[0x0]
800039ec:	f0 1f 01 3d 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f0:	fe f8 04 bc 	ld.w	r8,pc[1212]
800039f4:	70 0c       	ld.w	r12,r8[0x0]
800039f6:	f0 1f 01 28 	mcall	80003e94 <phy_rx_func+0xe98>
800039fa:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039fc:	c0 71       	brne	80003a0a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800039fe:	30 09       	mov	r9,0
80003a00:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003a04:	91 09       	st.w	r8[0x0],r9
80003a06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a0a:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003a0e:	72 08       	ld.w	r8,r9[0x0]
80003a10:	20 18       	sub	r8,1
80003a12:	93 08       	st.w	r9[0x0],r8
80003a14:	c0 71       	brne	80003a22 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003a16:	30 09       	mov	r9,0
80003a18:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003a1c:	91 09       	st.w	r8[0x0],r9
80003a1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003a22:	20 18       	sub	r8,1
80003a24:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003a28:	93 08       	st.w	r9[0x0],r8
80003a2a:	58 08       	cp.w	r8,0
80003a2c:	e0 81 02 25 	brne	80003e76 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003a30:	30 09       	mov	r9,0
80003a32:	fe f8 04 86 	ld.w	r8,pc[1158]
80003a36:	91 09       	st.w	r8[0x0],r9
80003a38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003a3c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003a40:	11 89       	ld.ub	r9,r8[0x0]
80003a42:	3f 38       	mov	r8,-13
80003a44:	f0 09 18 00 	cp.b	r9,r8
80003a48:	e0 81 01 0c 	brne	80003c60 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003a4c:	8e 49       	ld.sh	r9,r7[0x8]
80003a4e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003a52:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003a54:	8e 59       	ld.sh	r9,r7[0xa]
80003a56:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003a58:	8e 69       	ld.sh	r9,r7[0xc]
80003a5a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003a5c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003a60:	fe f9 04 54 	ld.w	r9,pc[1108]
80003a64:	72 0a       	ld.w	r10,r9[0x0]
80003a66:	70 09       	ld.w	r9,r8[0x0]
80003a68:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a6c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a70:	70 09       	ld.w	r9,r8[0x0]
80003a72:	2f f9       	sub	r9,-1
80003a74:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a76:	e0 49 01 ff 	cp.w	r9,511
80003a7a:	e0 88 00 16 	brls	80003aa6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a7e:	30 09       	mov	r9,0
80003a80:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a82:	fe f6 04 32 	ld.w	r6,pc[1074]
80003a86:	6c 0c       	ld.w	r12,r6[0x0]
80003a88:	f0 1f 01 16 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a8c:	fe f8 04 20 	ld.w	r8,pc[1056]
80003a90:	70 0c       	ld.w	r12,r8[0x0]
80003a92:	f0 1f 01 01 	mcall	80003e94 <phy_rx_func+0xe98>
80003a96:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a98:	c0 71       	brne	80003aa6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003a9a:	30 09       	mov	r9,0
80003a9c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003aa0:	91 09       	st.w	r8[0x0],r9
80003aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aa6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003aaa:	72 08       	ld.w	r8,r9[0x0]
80003aac:	20 18       	sub	r8,1
80003aae:	93 08       	st.w	r9[0x0],r8
80003ab0:	c0 71       	brne	80003abe <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003ab2:	30 09       	mov	r9,0
80003ab4:	fe f8 04 04 	ld.w	r8,pc[1028]
80003ab8:	91 09       	st.w	r8[0x0],r9
80003aba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003abe:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003ac2:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003ac6:	72 0a       	ld.w	r10,r9[0x0]
80003ac8:	70 09       	ld.w	r9,r8[0x0]
80003aca:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ace:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ad2:	70 09       	ld.w	r9,r8[0x0]
80003ad4:	2f f9       	sub	r9,-1
80003ad6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ad8:	e0 49 01 ff 	cp.w	r9,511
80003adc:	e0 88 00 16 	brls	80003b08 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ae0:	30 09       	mov	r9,0
80003ae2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ae4:	fe f6 03 d0 	ld.w	r6,pc[976]
80003ae8:	6c 0c       	ld.w	r12,r6[0x0]
80003aea:	f0 1f 00 fe 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003aee:	fe f8 03 be 	ld.w	r8,pc[958]
80003af2:	70 0c       	ld.w	r12,r8[0x0]
80003af4:	f0 1f 00 e8 	mcall	80003e94 <phy_rx_func+0xe98>
80003af8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003afa:	c0 71       	brne	80003b08 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003afc:	30 09       	mov	r9,0
80003afe:	fe f8 03 ba 	ld.w	r8,pc[954]
80003b02:	91 09       	st.w	r8[0x0],r9
80003b04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b08:	fe f9 03 b8 	ld.w	r9,pc[952]
80003b0c:	72 08       	ld.w	r8,r9[0x0]
80003b0e:	20 18       	sub	r8,1
80003b10:	93 08       	st.w	r9[0x0],r8
80003b12:	c0 71       	brne	80003b20 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003b14:	30 09       	mov	r9,0
80003b16:	fe f8 03 a2 	ld.w	r8,pc[930]
80003b1a:	91 09       	st.w	r8[0x0],r9
80003b1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003b20:	fe f8 03 b8 	ld.w	r8,pc[952]
80003b24:	fe f9 03 90 	ld.w	r9,pc[912]
80003b28:	72 0a       	ld.w	r10,r9[0x0]
80003b2a:	70 09       	ld.w	r9,r8[0x0]
80003b2c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b30:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b34:	70 09       	ld.w	r9,r8[0x0]
80003b36:	2f f9       	sub	r9,-1
80003b38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b3a:	e0 49 01 ff 	cp.w	r9,511
80003b3e:	e0 88 00 16 	brls	80003b6a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b42:	30 09       	mov	r9,0
80003b44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b46:	fe f6 03 6e 	ld.w	r6,pc[878]
80003b4a:	6c 0c       	ld.w	r12,r6[0x0]
80003b4c:	f0 1f 00 e5 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b50:	fe f8 03 5c 	ld.w	r8,pc[860]
80003b54:	70 0c       	ld.w	r12,r8[0x0]
80003b56:	f0 1f 00 d0 	mcall	80003e94 <phy_rx_func+0xe98>
80003b5a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b5c:	c0 71       	brne	80003b6a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003b5e:	30 09       	mov	r9,0
80003b60:	fe f8 03 58 	ld.w	r8,pc[856]
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b6a:	fe f9 03 56 	ld.w	r9,pc[854]
80003b6e:	72 08       	ld.w	r8,r9[0x0]
80003b70:	20 18       	sub	r8,1
80003b72:	93 08       	st.w	r9[0x0],r8
80003b74:	c0 71       	brne	80003b82 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003b76:	30 09       	mov	r9,0
80003b78:	fe f8 03 40 	ld.w	r8,pc[832]
80003b7c:	91 09       	st.w	r8[0x0],r9
80003b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003b82:	fe f8 03 56 	ld.w	r8,pc[854]
80003b86:	fe f9 03 2e 	ld.w	r9,pc[814]
80003b8a:	72 0a       	ld.w	r10,r9[0x0]
80003b8c:	70 09       	ld.w	r9,r8[0x0]
80003b8e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b92:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b96:	70 09       	ld.w	r9,r8[0x0]
80003b98:	2f f9       	sub	r9,-1
80003b9a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b9c:	e0 49 01 ff 	cp.w	r9,511
80003ba0:	e0 88 00 16 	brls	80003bcc <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ba4:	30 09       	mov	r9,0
80003ba6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ba8:	fe f6 03 0c 	ld.w	r6,pc[780]
80003bac:	6c 0c       	ld.w	r12,r6[0x0]
80003bae:	f0 1f 00 cd 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bb2:	fe f8 02 fa 	ld.w	r8,pc[762]
80003bb6:	70 0c       	ld.w	r12,r8[0x0]
80003bb8:	f0 1f 00 b7 	mcall	80003e94 <phy_rx_func+0xe98>
80003bbc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bbe:	c0 71       	brne	80003bcc <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003bc0:	30 09       	mov	r9,0
80003bc2:	fe f8 02 f6 	ld.w	r8,pc[758]
80003bc6:	91 09       	st.w	r8[0x0],r9
80003bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bcc:	fe f9 02 f4 	ld.w	r9,pc[756]
80003bd0:	72 08       	ld.w	r8,r9[0x0]
80003bd2:	20 18       	sub	r8,1
80003bd4:	93 08       	st.w	r9[0x0],r8
80003bd6:	c0 71       	brne	80003be4 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003bd8:	30 09       	mov	r9,0
80003bda:	fe f8 02 de 	ld.w	r8,pc[734]
80003bde:	91 09       	st.w	r8[0x0],r9
80003be0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003be4:	fe f8 02 f4 	ld.w	r8,pc[756]
80003be8:	fe f9 02 cc 	ld.w	r9,pc[716]
80003bec:	72 0a       	ld.w	r10,r9[0x0]
80003bee:	70 09       	ld.w	r9,r8[0x0]
80003bf0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003bf4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bf8:	70 09       	ld.w	r9,r8[0x0]
80003bfa:	2f f9       	sub	r9,-1
80003bfc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bfe:	e0 49 01 ff 	cp.w	r9,511
80003c02:	e0 88 00 16 	brls	80003c2e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c06:	30 09       	mov	r9,0
80003c08:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c0a:	fe f7 02 aa 	ld.w	r7,pc[682]
80003c0e:	6e 0c       	ld.w	r12,r7[0x0]
80003c10:	f0 1f 00 b4 	mcall	80003ee0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c14:	fe f8 02 98 	ld.w	r8,pc[664]
80003c18:	70 0c       	ld.w	r12,r8[0x0]
80003c1a:	f0 1f 00 9f 	mcall	80003e94 <phy_rx_func+0xe98>
80003c1e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c20:	c0 71       	brne	80003c2e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003c22:	30 09       	mov	r9,0
80003c24:	fe f8 02 94 	ld.w	r8,pc[660]
80003c28:	91 09       	st.w	r8[0x0],r9
80003c2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c2e:	fe f9 02 92 	ld.w	r9,pc[658]
80003c32:	72 08       	ld.w	r8,r9[0x0]
80003c34:	20 18       	sub	r8,1
80003c36:	93 08       	st.w	r9[0x0],r8
80003c38:	c0 71       	brne	80003c46 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003c3a:	30 09       	mov	r9,0
80003c3c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003c40:	91 09       	st.w	r8[0x0],r9
80003c42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003c46:	20 18       	sub	r8,1
80003c48:	fe f9 02 78 	ld.w	r9,pc[632]
80003c4c:	93 08       	st.w	r9[0x0],r8
80003c4e:	58 08       	cp.w	r8,0
80003c50:	e0 81 01 13 	brne	80003e76 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003c54:	30 09       	mov	r9,0
80003c56:	fe f8 02 62 	ld.w	r8,pc[610]
80003c5a:	91 09       	st.w	r8[0x0],r9
80003c5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003c60:	fe f8 02 70 	ld.w	r8,pc[624]
80003c64:	11 89       	ld.ub	r9,r8[0x0]
80003c66:	30 48       	mov	r8,4
80003c68:	f0 09 18 00 	cp.b	r9,r8
80003c6c:	c0 80       	breq	80003c7c <phy_rx_func+0xc80>
80003c6e:	fe f8 02 62 	ld.w	r8,pc[610]
80003c72:	11 89       	ld.ub	r9,r8[0x0]
80003c74:	30 38       	mov	r8,3
80003c76:	f0 09 18 00 	cp.b	r9,r8
80003c7a:	c1 41       	brne	80003ca2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003c7c:	6e 29       	ld.w	r9,r7[0x8]
80003c7e:	fe f8 02 7a 	ld.w	r8,pc[634]
80003c82:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003c84:	6e 39       	ld.w	r9,r7[0xc]
80003c86:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003c88:	fe f9 02 38 	ld.w	r9,pc[568]
80003c8c:	72 08       	ld.w	r8,r9[0x0]
80003c8e:	20 88       	sub	r8,8
80003c90:	93 08       	st.w	r9[0x0],r8
80003c92:	e0 81 00 f2 	brne	80003e76 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003c96:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003c98:	fe f9 02 20 	ld.w	r9,pc[544]
80003c9c:	93 08       	st.w	r9[0x0],r8
80003c9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003ca2:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ca6:	11 89       	ld.ub	r9,r8[0x0]
80003ca8:	31 38       	mov	r8,19
80003caa:	f0 09 18 00 	cp.b	r9,r8
80003cae:	e0 81 00 9c 	brne	80003de6 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003cb2:	fe f8 02 62 	ld.w	r8,pc[610]
80003cb6:	11 88       	ld.ub	r8,r8[0x0]
80003cb8:	30 c9       	mov	r9,12
80003cba:	f2 08 18 00 	cp.b	r8,r9
80003cbe:	e0 81 00 7b 	brne	80003db4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003cc2:	8e 49       	ld.sh	r9,r7[0x8]
80003cc4:	fe f8 02 54 	ld.w	r8,pc[596]
80003cc8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ccc:	30 09       	mov	r9,0
80003cce:	fe f8 02 46 	ld.w	r8,pc[582]
80003cd2:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cd4:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003cd8:	3f 38       	mov	r8,-13
80003cda:	f0 09 18 00 	cp.b	r9,r8
80003cde:	c6 61       	brne	80003daa <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ce0:	10 99       	mov	r9,r8
80003ce2:	4f c8       	lddpc	r8,80003ed0 <phy_rx_func+0xed4>
80003ce4:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003ce6:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003cea:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003cee:	4f 58       	lddpc	r8,80003ec0 <phy_rx_func+0xec4>
80003cf0:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003cf2:	30 19       	mov	r9,1
80003cf4:	fe f8 02 0c 	ld.w	r8,pc[524]
80003cf8:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003cfa:	8e 79       	ld.sh	r9,r7[0xe]
80003cfc:	fe f8 02 14 	ld.w	r8,pc[532]
80003d00:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003d02:	4f 68       	lddpc	r8,80003ed8 <phy_rx_func+0xedc>
80003d04:	4e c9       	lddpc	r9,80003eb4 <phy_rx_func+0xeb8>
80003d06:	72 0a       	ld.w	r10,r9[0x0]
80003d08:	70 09       	ld.w	r9,r8[0x0]
80003d0a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d0e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d12:	70 09       	ld.w	r9,r8[0x0]
80003d14:	2f f9       	sub	r9,-1
80003d16:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d18:	e0 49 01 ff 	cp.w	r9,511
80003d1c:	e0 88 00 13 	brls	80003d42 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d20:	30 09       	mov	r9,0
80003d22:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d24:	4e 46       	lddpc	r6,80003eb4 <phy_rx_func+0xeb8>
80003d26:	6c 0c       	ld.w	r12,r6[0x0]
80003d28:	f0 1f 00 6e 	mcall	80003ee0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d2c:	4e 08       	lddpc	r8,80003eac <phy_rx_func+0xeb0>
80003d2e:	70 0c       	ld.w	r12,r8[0x0]
80003d30:	f0 1f 00 59 	mcall	80003e94 <phy_rx_func+0xe98>
80003d34:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d36:	c0 61       	brne	80003d42 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003d38:	30 09       	mov	r9,0
80003d3a:	4e 08       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003d3c:	91 09       	st.w	r8[0x0],r9
80003d3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d42:	4e 09       	lddpc	r9,80003ec0 <phy_rx_func+0xec4>
80003d44:	72 08       	ld.w	r8,r9[0x0]
80003d46:	20 18       	sub	r8,1
80003d48:	93 08       	st.w	r9[0x0],r8
80003d4a:	c0 61       	brne	80003d56 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003d4c:	30 09       	mov	r9,0
80003d4e:	4d b8       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003d50:	91 09       	st.w	r8[0x0],r9
80003d52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003d56:	4e 18       	lddpc	r8,80003ed8 <phy_rx_func+0xedc>
80003d58:	4d 79       	lddpc	r9,80003eb4 <phy_rx_func+0xeb8>
80003d5a:	72 0a       	ld.w	r10,r9[0x0]
80003d5c:	70 09       	ld.w	r9,r8[0x0]
80003d5e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d62:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d66:	70 09       	ld.w	r9,r8[0x0]
80003d68:	2f f9       	sub	r9,-1
80003d6a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d6c:	e0 49 01 ff 	cp.w	r9,511
80003d70:	e0 88 00 13 	brls	80003d96 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d74:	30 09       	mov	r9,0
80003d76:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d78:	4c f7       	lddpc	r7,80003eb4 <phy_rx_func+0xeb8>
80003d7a:	6e 0c       	ld.w	r12,r7[0x0]
80003d7c:	f0 1f 00 59 	mcall	80003ee0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d80:	4c b8       	lddpc	r8,80003eac <phy_rx_func+0xeb0>
80003d82:	70 0c       	ld.w	r12,r8[0x0]
80003d84:	f0 1f 00 44 	mcall	80003e94 <phy_rx_func+0xe98>
80003d88:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d8a:	c0 61       	brne	80003d96 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003d8c:	30 09       	mov	r9,0
80003d8e:	4c b8       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003d90:	91 09       	st.w	r8[0x0],r9
80003d92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d96:	4c b9       	lddpc	r9,80003ec0 <phy_rx_func+0xec4>
80003d98:	72 08       	ld.w	r8,r9[0x0]
80003d9a:	20 18       	sub	r8,1
80003d9c:	93 08       	st.w	r9[0x0],r8
80003d9e:	c6 c1       	brne	80003e76 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003da0:	30 09       	mov	r9,0
80003da2:	4c 68       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003da4:	91 09       	st.w	r8[0x0],r9
80003da6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003daa:	30 09       	mov	r9,0
80003dac:	4c 38       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003dae:	91 09       	st.w	r8[0x0],r9
80003db0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003db4:	8e 4a       	ld.sh	r10,r7[0x8]
80003db6:	4d 99       	lddpc	r9,80003f18 <phy_rx_func+0xf1c>
80003db8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003dbc:	4d 6a       	lddpc	r10,80003f14 <phy_rx_func+0xf18>
80003dbe:	15 88       	ld.ub	r8,r10[0x0]
80003dc0:	f0 cb ff ff 	sub	r11,r8,-1
80003dc4:	8e 5c       	ld.sh	r12,r7[0xa]
80003dc6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003dca:	f0 cb ff fe 	sub	r11,r8,-2
80003dce:	8e 6c       	ld.sh	r12,r7[0xc]
80003dd0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003dd4:	f0 cb ff fd 	sub	r11,r8,-3
80003dd8:	8e 7c       	ld.sh	r12,r7[0xe]
80003dda:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003dde:	2f c8       	sub	r8,-4
80003de0:	b4 88       	st.b	r10[0x0],r8
80003de2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003de6:	30 09       	mov	r9,0
80003de8:	4b 48       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003dea:	91 09       	st.w	r8[0x0],r9
80003dec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003df0:	4c 08       	lddpc	r8,80003ef0 <phy_rx_func+0xef4>
80003df2:	70 09       	ld.w	r9,r8[0x0]
80003df4:	8e 4b       	ld.sh	r11,r7[0x8]
80003df6:	4c 0a       	lddpc	r10,80003ef4 <phy_rx_func+0xef8>
80003df8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003dfc:	2f f9       	sub	r9,-1
80003dfe:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e00:	4b 58       	lddpc	r8,80003ed4 <phy_rx_func+0xed8>
80003e02:	70 09       	ld.w	r9,r8[0x0]
80003e04:	20 29       	sub	r9,2
80003e06:	91 09       	st.w	r8[0x0],r9
80003e08:	70 08       	ld.w	r8,r8[0x0]
80003e0a:	58 08       	cp.w	r8,0
80003e0c:	c2 f1       	brne	80003e6a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003e0e:	30 09       	mov	r9,0
80003e10:	4b 88       	lddpc	r8,80003ef0 <phy_rx_func+0xef4>
80003e12:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e14:	8e 59       	ld.sh	r9,r7[0xa]
80003e16:	fe 78 82 12 	mov	r8,-32238
80003e1a:	f0 09 19 00 	cp.h	r9,r8
80003e1e:	c2 11       	brne	80003e60 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003e20:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e24:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003e28:	4a f8       	lddpc	r8,80003ee4 <phy_rx_func+0xee8>
80003e2a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e2c:	8e 59       	ld.sh	r9,r7[0xa]
80003e2e:	4a f8       	lddpc	r8,80003ee8 <phy_rx_func+0xeec>
80003e30:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e32:	8e 69       	ld.sh	r9,r7[0xc]
80003e34:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e36:	f0 1f 00 2e 	mcall	80003eec <phy_rx_func+0xef0>
80003e3a:	4a 18       	lddpc	r8,80003ebc <phy_rx_func+0xec0>
80003e3c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e3e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003e42:	31 38       	mov	r8,19
80003e44:	f0 09 18 00 	cp.b	r9,r8
80003e48:	c0 71       	brne	80003e56 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003e4a:	10 99       	mov	r9,r8
80003e4c:	4a 18       	lddpc	r8,80003ed0 <phy_rx_func+0xed4>
80003e4e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003e50:	30 09       	mov	r9,0
80003e52:	49 c8       	lddpc	r8,80003ec0 <phy_rx_func+0xec4>
80003e54:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003e56:	30 49       	mov	r9,4
80003e58:	49 88       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003e5a:	91 09       	st.w	r8[0x0],r9
80003e5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003e60:	30 09       	mov	r9,0
80003e62:	49 68       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003e64:	91 09       	st.w	r8[0x0],r9
80003e66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003e6a:	4a dc       	lddpc	r12,80003f1c <phy_rx_func+0xf20>
80003e6c:	f0 1f 00 18 	mcall	80003ecc <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003e70:	30 09       	mov	r9,0
80003e72:	49 28       	lddpc	r8,80003eb8 <phy_rx_func+0xebc>
80003e74:	91 09       	st.w	r8[0x0],r9
80003e76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e7a:	00 00       	add	r0,r0
80003e7c:	00 00       	add	r0,r0
80003e7e:	0a b8       	st.h	r5++,r8
80003e80:	00 00       	add	r0,r0
80003e82:	0a c4       	st.b	r5++,r4
80003e84:	00 00       	add	r0,r0
80003e86:	0a a8       	st.w	r5++,r8
80003e88:	00 00       	add	r0,r0
80003e8a:	0a 80       	andn	r0,r5
80003e8c:	00 00       	add	r0,r0
80003e8e:	0a 70       	tst	r0,r5
80003e90:	00 00       	add	r0,r0
80003e92:	0a 9c       	mov	r12,r5
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	2a 5c       	sub	r12,-91
80003e98:	00 00       	add	r0,r0
80003e9a:	0a c8       	st.b	r5++,r8
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	29 8c       	sub	r12,-104
80003ea0:	00 00       	add	r0,r0
80003ea2:	0a b0       	st.h	r5++,r0
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	29 a8       	sub	r8,-102
80003ea8:	00 00       	add	r0,r0
80003eaa:	0a 8d       	andn	sp,r5
80003eac:	00 00       	add	r0,r0
80003eae:	0a a4       	st.w	r5++,r4
80003eb0:	00 00       	add	r0,r0
80003eb2:	0a bc       	st.h	r5++,r12
80003eb4:	00 00       	add	r0,r0
80003eb6:	0a d8       	st.w	--r5,r8
80003eb8:	00 00       	add	r0,r0
80003eba:	0a 98       	mov	r8,r5
80003ebc:	00 00       	add	r0,r0
80003ebe:	0a d0       	st.w	--r5,r0
80003ec0:	00 00       	add	r0,r0
80003ec2:	0a 7c       	tst	r12,r5
80003ec4:	00 00       	add	r0,r0
80003ec6:	0a 4c       	or	r12,r5
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	d5 18       	*unknown*
80003ecc:	80 00       	ld.sh	r0,r0[0x0]
80003ece:	6f 04       	ld.w	r4,r7[0x40]
80003ed0:	00 00       	add	r0,r0
80003ed2:	0a 8c       	andn	r12,r5
80003ed4:	00 00       	add	r0,r0
80003ed6:	0a 6c       	and	r12,r5
80003ed8:	00 00       	add	r0,r0
80003eda:	0a 84       	andn	r4,r5
80003edc:	80 00       	ld.sh	r0,r0[0x0]
80003ede:	77 54       	ld.w	r4,r11[0x54]
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	2f 9c       	sub	r12,-7
80003ee4:	00 00       	add	r0,r0
80003ee6:	0a 42       	or	r2,r5
80003ee8:	00 00       	add	r0,r0
80003eea:	1e a8       	st.w	pc++,r8
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	28 ec       	sub	r12,-114
80003ef0:	00 00       	add	r0,r0
80003ef2:	0a b4       	st.h	r5++,r4
80003ef4:	00 00       	add	r0,r0
80003ef6:	1d ac       	ld.ub	r12,lr[0x2]
80003ef8:	00 00       	add	r0,r0
80003efa:	0a 90       	mov	r0,r5
80003efc:	00 00       	add	r0,r0
80003efe:	0a 43       	or	r3,r5
80003f00:	00 00       	add	r0,r0
80003f02:	0a 41       	or	r1,r5
80003f04:	00 00       	add	r0,r0
80003f06:	0a 64       	and	r4,r5
80003f08:	00 00       	add	r0,r0
80003f0a:	0a a0       	st.w	r5++,r0
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a 57       	eor	r7,r5
80003f10:	00 00       	add	r0,r0
80003f12:	1d a4       	ld.ub	r4,lr[0x2]
80003f14:	00 00       	add	r0,r0
80003f16:	0a c0       	st.b	r5++,r0
80003f18:	00 00       	add	r0,r0
80003f1a:	1e ac       	st.w	pc++,r12
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	d5 30       	acall	0x53

80003f20 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f20:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f22:	49 88       	lddpc	r8,80003f80 <pdca_int_handler+0x60>
80003f24:	11 89       	ld.ub	r9,r8[0x0]
80003f26:	ec 19 00 01 	eorl	r9,0x1
80003f2a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f2c:	11 89       	ld.ub	r9,r8[0x0]
80003f2e:	a5 69       	lsl	r9,0x4
80003f30:	2f c9       	sub	r9,-4
80003f32:	49 5a       	lddpc	r10,80003f84 <pdca_int_handler+0x64>
80003f34:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f36:	fe 7a 00 40 	mov	r10,-65472
80003f3a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f3c:	30 39       	mov	r9,3
80003f3e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003f40:	11 8a       	ld.ub	r10,r8[0x0]
80003f42:	a5 6a       	lsl	r10,0x4
80003f44:	2f ca       	sub	r10,-4
80003f46:	49 18       	lddpc	r8,80003f88 <pdca_int_handler+0x68>
80003f48:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003f4a:	fe 78 00 00 	mov	r8,-65536
80003f4e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003f50:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003f52:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003f54:	48 e8       	lddpc	r8,80003f8c <pdca_int_handler+0x6c>
80003f56:	70 08       	ld.w	r8,r8[0x0]
80003f58:	58 08       	cp.w	r8,0
80003f5a:	c0 70       	breq	80003f68 <pdca_int_handler+0x48>
80003f5c:	48 99       	lddpc	r9,80003f80 <pdca_int_handler+0x60>
80003f5e:	13 89       	ld.ub	r9,r9[0x0]
80003f60:	a5 69       	lsl	r9,0x4
80003f62:	48 ac       	lddpc	r12,80003f88 <pdca_int_handler+0x68>
80003f64:	12 0c       	add	r12,r9
80003f66:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003f68:	48 a8       	lddpc	r8,80003f90 <pdca_int_handler+0x70>
80003f6a:	70 08       	ld.w	r8,r8[0x0]
80003f6c:	58 08       	cp.w	r8,0
80003f6e:	c0 70       	breq	80003f7c <pdca_int_handler+0x5c>
80003f70:	48 49       	lddpc	r9,80003f80 <pdca_int_handler+0x60>
80003f72:	13 89       	ld.ub	r9,r9[0x0]
80003f74:	a5 69       	lsl	r9,0x4
80003f76:	48 4c       	lddpc	r12,80003f84 <pdca_int_handler+0x64>
80003f78:	12 0c       	add	r12,r9
80003f7a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003f7c:	d4 02       	popm	lr
80003f7e:	d6 03       	rete
80003f80:	00 00       	add	r0,r0
80003f82:	50 cc       	stdsp	sp[0x30],r12
80003f84:	00 00       	add	r0,r0
80003f86:	50 f4       	stdsp	sp[0x3c],r4
80003f88:	00 00       	add	r0,r0
80003f8a:	50 d4       	stdsp	sp[0x34],r4
80003f8c:	00 00       	add	r0,r0
80003f8e:	0a e4       	st.h	--r5,r4
80003f90:	00 00       	add	r0,r0
80003f92:	0a e8       	st.h	--r5,r8

80003f94 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003f94:	fe 78 10 00 	mov	r8,-61440
80003f98:	e0 69 0d c0 	mov	r9,3520
80003f9c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003fa0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003fa4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003fa8:	fe 78 34 00 	mov	r8,-52224
80003fac:	e0 69 80 00 	mov	r9,32768
80003fb0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003fb2:	30 09       	mov	r9,0
80003fb4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003fb6:	e0 69 04 21 	mov	r9,1057
80003fba:	ea 19 3f 20 	orh	r9,0x3f20
80003fbe:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003fc0:	e0 69 02 9f 	mov	r9,671
80003fc4:	ea 19 01 00 	orh	r9,0x100
80003fc8:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003fca:	e0 6a 04 02 	mov	r10,1026
80003fce:	ea 1a 3f 20 	orh	r10,0x3f20
80003fd2:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003fd4:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003fd6:	5e fc       	retal	r12

80003fd8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003fd8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003fda:	30 19       	mov	r9,1
80003fdc:	49 78       	lddpc	r8,80004038 <local_start_PDC+0x60>
80003fde:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003fe0:	fe 78 00 00 	mov	r8,-65536
80003fe4:	30 7b       	mov	r11,7
80003fe6:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003fe8:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003fea:	49 59       	lddpc	r9,8000403c <local_start_PDC+0x64>
80003fec:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ff0:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003ff2:	30 3a       	mov	r10,3
80003ff4:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003ff6:	30 1c       	mov	r12,1
80003ff8:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003ffa:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ffc:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ffe:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004000:	30 2c       	mov	r12,2
80004002:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004004:	48 f9       	lddpc	r9,80004040 <local_start_PDC+0x68>
80004006:	e0 68 5a 5a 	mov	r8,23130
8000400a:	ea 18 ab cd 	orh	r8,0xabcd
8000400e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004010:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004012:	30 0e       	mov	lr,0
80004014:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004016:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004018:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000401a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000401c:	fe 78 00 40 	mov	r8,-65472
80004020:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004022:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004024:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004028:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000402a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000402c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000402e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004030:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004032:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004034:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004036:	d8 02       	popm	pc
80004038:	00 00       	add	r0,r0
8000403a:	50 cc       	stdsp	sp[0x30],r12
8000403c:	00 00       	add	r0,r0
8000403e:	50 d4       	stdsp	sp[0x34],r4
80004040:	00 00       	add	r0,r0
80004042:	50 f4       	stdsp	sp[0x3c],r4

80004044 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004044:	48 38       	lddpc	r8,80004050 <register_rx_tx_func+0xc>
80004046:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004048:	48 38       	lddpc	r8,80004054 <register_rx_tx_func+0x10>
8000404a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000404c:	5e fc       	retal	r12
8000404e:	00 00       	add	r0,r0
80004050:	00 00       	add	r0,r0
80004052:	0a e4       	st.h	--r5,r4
80004054:	00 00       	add	r0,r0
80004056:	0a e8       	st.h	--r5,r8

80004058 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004058:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000405a:	fe 78 10 00 	mov	r8,-61440
8000405e:	30 29       	mov	r9,2
80004060:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004064:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004068:	10 99       	mov	r9,r8
8000406a:	f2 f8 01 60 	ld.w	r8,r9[352]
8000406e:	e2 18 00 02 	andl	r8,0x2,COH
80004072:	cf c0       	breq	8000406a <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004074:	fe 79 10 00 	mov	r9,-61440
80004078:	f2 f8 01 60 	ld.w	r8,r9[352]
8000407c:	e2 18 00 02 	andl	r8,0x2,COH
80004080:	cf c1       	brne	80004078 <ssc_init+0x20>
				
    INTC_register_interrupt (
80004082:	30 3a       	mov	r10,3
80004084:	36 0b       	mov	r11,96
80004086:	48 bc       	lddpc	r12,800040b0 <ssc_init+0x58>
80004088:	f0 1f 00 0b 	mcall	800040b4 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
8000408c:	f0 1f 00 0b 	mcall	800040b8 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004090:	f0 1f 00 0b 	mcall	800040bc <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004094:	fe 79 00 00 	mov	r9,-65536
80004098:	30 18       	mov	r8,1
8000409a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000409c:	fe 7a 00 40 	mov	r10,-65472
800040a0:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800040a2:	e0 6b 01 01 	mov	r11,257
800040a6:	fe 7a 34 00 	mov	r10,-52224
800040aa:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800040ac:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800040ae:	d8 02       	popm	pc
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	3f 20       	mov	r0,-14
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	55 40       	stdsp	sp[0x150],r0
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	3f 94       	mov	r4,-7
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	3f d8       	mov	r8,-3

800040c0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800040c0:	48 28       	lddpc	r8,800040c8 <xcmp_register_app_list+0x8>
800040c2:	91 0c       	st.w	r8[0x0],r12
}
800040c4:	5e fc       	retal	r12
800040c6:	00 00       	add	r0,r0
800040c8:	00 00       	add	r0,r0
800040ca:	51 14       	stdsp	sp[0x44],r4

800040cc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800040cc:	eb cd 40 80 	pushm	r7,lr
800040d0:	fa cd 01 00 	sub	sp,sp,256
800040d4:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800040d6:	16 98       	mov	r8,r11
800040d8:	2f 08       	sub	r8,-16
800040da:	af a8       	sbr	r8,0xe
800040dc:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800040de:	3f f8       	mov	r8,-1
800040e0:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800040e2:	30 b9       	mov	r9,11
800040e4:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800040e6:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800040e8:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800040ea:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040ec:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800040ee:	f6 ca ff fe 	sub	r10,r11,-2
800040f2:	18 9b       	mov	r11,r12
800040f4:	fa cc ff f0 	sub	r12,sp,-16
800040f8:	f0 1f 00 05 	mcall	8000410c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800040fc:	2f e7       	sub	r7,-2
800040fe:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004100:	1a 9c       	mov	r12,sp
80004102:	f0 1f 00 04 	mcall	80004110 <xcmp_tx+0x44>
}
80004106:	2c 0d       	sub	sp,-256
80004108:	e3 cd 80 80 	ldm	sp++,r7,pc
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	76 0c       	ld.w	r12,r11[0x0]
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	46 d8       	lddsp	r8,sp[0x1b4]

80004114 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004114:	d4 21       	pushm	r4-r7,lr
80004116:	fa cd 00 d0 	sub	sp,sp,208
8000411a:	18 94       	mov	r4,r12
8000411c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000411e:	e0 68 01 00 	mov	r8,256
80004122:	f0 0b 19 00 	cp.h	r11,r8
80004126:	e0 8b 00 36 	brhi	80004192 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000412a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000412e:	e0 68 04 1d 	mov	r8,1053
80004132:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004134:	30 18       	mov	r8,1
80004136:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004138:	32 08       	mov	r8,32
8000413a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
8000413c:	30 28       	mov	r8,2
8000413e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004140:	30 48       	mov	r8,4
80004142:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004144:	ea 1a 0c 00 	orh	r10,0xc00
80004148:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000414a:	30 4a       	mov	r10,4
8000414c:	1a 9b       	mov	r11,sp
8000414e:	fa cc ff f4 	sub	r12,sp,-12
80004152:	f0 1f 00 12 	mcall	80004198 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004156:	30 f8       	mov	r8,15
80004158:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
8000415c:	3a 78       	mov	r8,-89
8000415e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80004162:	30 08       	mov	r8,0
80004164:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004168:	0e 9a       	mov	r10,r7
8000416a:	5c 7a       	castu.h	r10
8000416c:	f4 08 16 08 	lsr	r8,r10,0x8
80004170:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004174:	0e 96       	mov	r6,r7
80004176:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
8000417a:	08 9b       	mov	r11,r4
8000417c:	fa cc ff eb 	sub	r12,sp,-21
80004180:	f0 1f 00 06 	mcall	80004198 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004184:	ee cb ff f3 	sub	r11,r7,-13
80004188:	5c 5b       	castu.b	r11
8000418a:	fa cc ff fa 	sub	r12,sp,-6
8000418e:	f0 1f 00 04 	mcall	8000419c <xcmp_data_session_req+0x88>
}
80004192:	2c cd       	sub	sp,-208
80004194:	d8 22       	popm	r4-r7,pc
80004196:	00 00       	add	r0,r0
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	76 0c       	ld.w	r12,r11[0x0]
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	40 cc       	lddsp	r12,sp[0x30]

800041a0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800041a0:	d4 01       	pushm	lr
800041a2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800041a6:	fe 78 b4 00 	mov	r8,-19456
800041aa:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800041ac:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800041b0:	30 89       	mov	r9,8
800041b2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800041b4:	30 19       	mov	r9,1
800041b6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800041b8:	30 09       	mov	r9,0
800041ba:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800041bc:	30 5a       	mov	r10,5
800041be:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800041c0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800041c2:	30 7a       	mov	r10,7
800041c4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800041c6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800041c8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800041ca:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800041ce:	30 9b       	mov	r11,9
800041d0:	fa cc ff fe 	sub	r12,sp,-2
800041d4:	f0 1f 00 02 	mcall	800041dc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800041d8:	2c dd       	sub	sp,-204
800041da:	d8 02       	popm	pc
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	40 cc       	lddsp	r12,sp[0x30]

800041e0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800041e0:	d4 01       	pushm	lr
800041e2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800041e6:	fe 78 80 00 	mov	r8,-32768
800041ea:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800041ec:	30 38       	mov	r8,3
800041ee:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800041f0:	30 1b       	mov	r11,1
800041f2:	fa cc ff fe 	sub	r12,sp,-2
800041f6:	f0 1f 00 03 	mcall	80004200 <xcmp_opcode_not_supported+0x20>
}
800041fa:	2c dd       	sub	sp,-204
800041fc:	d8 02       	popm	pc
800041fe:	00 00       	add	r0,r0
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	40 cc       	lddsp	r12,sp[0x30]

80004204 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004204:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004206:	96 88       	ld.uh	r8,r11[0x0]
80004208:	e2 18 f0 00 	andl	r8,0xf000,COH
8000420c:	e0 48 80 00 	cp.w	r8,32768
80004210:	c0 f0       	breq	8000422e <xcmp_exec_func+0x2a>
80004212:	e0 48 b0 00 	cp.w	r8,45056
80004216:	c1 20       	breq	8000423a <xcmp_exec_func+0x36>
80004218:	58 08       	cp.w	r8,0
8000421a:	c1 51       	brne	80004244 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000421c:	78 08       	ld.w	r8,r12[0x0]
8000421e:	58 08       	cp.w	r8,0
80004220:	c0 40       	breq	80004228 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004222:	16 9c       	mov	r12,r11
80004224:	5d 18       	icall	r8
80004226:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004228:	f0 1f 00 08 	mcall	80004248 <xcmp_exec_func+0x44>
8000422c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000422e:	78 18       	ld.w	r8,r12[0x4]
80004230:	58 08       	cp.w	r8,0
80004232:	c0 90       	breq	80004244 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004234:	16 9c       	mov	r12,r11
80004236:	5d 18       	icall	r8
80004238:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000423a:	78 28       	ld.w	r8,r12[0x8]
8000423c:	58 08       	cp.w	r8,0
8000423e:	c0 30       	breq	80004244 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004240:	16 9c       	mov	r12,r11
80004242:	5d 18       	icall	r8
80004244:	d8 02       	popm	pc
80004246:	00 00       	add	r0,r0
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	41 e0       	lddsp	r0,sp[0x78]

8000424c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
8000424c:	d4 01       	pushm	lr
8000424e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004252:	e0 68 04 09 	mov	r8,1033
80004256:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004258:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
8000425c:	30 19       	mov	r9,1
8000425e:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
80004260:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80004264:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
80004266:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004268:	30 09       	mov	r9,0
8000426a:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000426c:	fb 69 00 08 	st.b	sp[8],r9
80004270:	fa c8 ff f7 	sub	r8,sp,-9
80004274:	b0 89       	st.b	r8[0x0],r9
80004276:	fa c8 ff f6 	sub	r8,sp,-10
8000427a:	b0 89       	st.b	r8[0x0],r9
8000427c:	fa c8 ff f5 	sub	r8,sp,-11
80004280:	b0 89       	st.b	r8[0x0],r9
80004282:	fa c8 ff f4 	sub	r8,sp,-12
80004286:	b0 89       	st.b	r8[0x0],r9
80004288:	fa c8 ff f3 	sub	r8,sp,-13
8000428c:	b0 89       	st.b	r8[0x0],r9
8000428e:	fa c8 ff f2 	sub	r8,sp,-14
80004292:	b0 89       	st.b	r8[0x0],r9
80004294:	fa c8 ff f1 	sub	r8,sp,-15
80004298:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000429a:	30 cb       	mov	r11,12
8000429c:	fa cc ff fe 	sub	r12,sp,-2
800042a0:	f0 1f 00 02 	mcall	800042a8 <xcmp_IdleTestTone+0x5c>
}
800042a4:	2c dd       	sub	sp,-204
800042a6:	d8 02       	popm	pc
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	40 cc       	lddsp	r12,sp[0x30]

800042ac <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800042ac:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800042ae:	48 dc       	lddpc	r12,800042e0 <xcmp_init+0x34>
800042b0:	f0 1f 00 0d 	mcall	800042e4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800042b4:	30 4b       	mov	r11,4
800042b6:	31 4c       	mov	r12,20
800042b8:	f0 1f 00 0c 	mcall	800042e8 <xcmp_init+0x3c>
800042bc:	48 c8       	lddpc	r8,800042ec <xcmp_init+0x40>
800042be:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800042c0:	30 09       	mov	r9,0
800042c2:	1a d9       	st.w	--sp,r9
800042c4:	1a d9       	st.w	--sp,r9
800042c6:	1a d9       	st.w	--sp,r9
800042c8:	30 38       	mov	r8,3
800042ca:	e0 6a 01 80 	mov	r10,384
800042ce:	48 9b       	lddpc	r11,800042f0 <xcmp_init+0x44>
800042d0:	48 9c       	lddpc	r12,800042f4 <xcmp_init+0x48>
800042d2:	f0 1f 00 0a 	mcall	800042f8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800042d6:	f0 1f 00 0a 	mcall	800042fc <xcmp_init+0x50>
800042da:	2f dd       	sub	sp,-12
	
}
800042dc:	d8 02       	popm	pc
800042de:	00 00       	add	r0,r0
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	43 fc       	lddsp	r12,sp[0xfc]
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	44 48       	lddsp	r8,sp[0x110]
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	62 e0       	ld.w	r0,r1[0x38]
800042ec:	00 00       	add	r0,r0
800042ee:	0b 04       	ld.w	r4,r5++
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	d5 5c       	*unknown*
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	43 00       	lddsp	r0,sp[0xc0]
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	69 b4       	ld.w	r4,r4[0x6c]
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	44 80       	lddsp	r0,sp[0x120]

80004300 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004300:	d4 31       	pushm	r0-r7,lr
80004302:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004304:	4b 16       	lddpc	r6,800043c8 <xcmp_rx_process+0xc8>
80004306:	30 05       	mov	r5,0
80004308:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000430a:	4b 13       	lddpc	r3,800043cc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000430c:	4b 12       	lddpc	r2,800043d0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000430e:	4b 21       	lddpc	r1,800043d4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004310:	4b 20       	lddpc	r0,800043d8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004312:	6c 0c       	ld.w	r12,r6[0x0]
80004314:	0a 99       	mov	r9,r5
80004316:	08 9a       	mov	r10,r4
80004318:	1a 9b       	mov	r11,sp
8000431a:	f0 1f 00 31 	mcall	800043dc <xcmp_rx_process+0xdc>
8000431e:	58 1c       	cp.w	r12,1
80004320:	cf 91       	brne	80004312 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004322:	40 0b       	lddsp	r11,sp[0x0]
80004324:	58 0b       	cp.w	r11,0
80004326:	cf 60       	breq	80004312 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004328:	96 0a       	ld.sh	r10,r11[0x0]
8000432a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000432e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004332:	59 c8       	cp.w	r8,28
80004334:	c1 e0       	breq	80004370 <xcmp_rx_process+0x70>
80004336:	e0 89 00 07 	brgt	80004344 <xcmp_rx_process+0x44>
8000433a:	58 e8       	cp.w	r8,14
8000433c:	c0 e0       	breq	80004358 <xcmp_rx_process+0x58>
8000433e:	58 f8       	cp.w	r8,15
80004340:	c2 41       	brne	80004388 <xcmp_rx_process+0x88>
80004342:	c0 f8       	rjmp	80004360 <xcmp_rx_process+0x60>
80004344:	e0 48 01 09 	cp.w	r8,265
80004348:	c1 80       	breq	80004378 <xcmp_rx_process+0x78>
8000434a:	e0 48 01 0a 	cp.w	r8,266
8000434e:	c1 90       	breq	80004380 <xcmp_rx_process+0x80>
80004350:	e0 48 00 2c 	cp.w	r8,44
80004354:	c1 a1       	brne	80004388 <xcmp_rx_process+0x88>
80004356:	c0 98       	rjmp	80004368 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004358:	4a 2c       	lddpc	r12,800043e0 <xcmp_rx_process+0xe0>
8000435a:	f0 1f 00 23 	mcall	800043e4 <xcmp_rx_process+0xe4>
					break;
8000435e:	c2 f8       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004360:	4a 2c       	lddpc	r12,800043e8 <xcmp_rx_process+0xe8>
80004362:	f0 1f 00 21 	mcall	800043e4 <xcmp_rx_process+0xe4>
					break;
80004366:	c2 b8       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004368:	4a 1c       	lddpc	r12,800043ec <xcmp_rx_process+0xec>
8000436a:	f0 1f 00 1f 	mcall	800043e4 <xcmp_rx_process+0xe4>
					break;
8000436e:	c2 78       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004370:	04 9c       	mov	r12,r2
80004372:	f0 1f 00 1d 	mcall	800043e4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004376:	c2 38       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004378:	02 9c       	mov	r12,r1
8000437a:	f0 1f 00 1b 	mcall	800043e4 <xcmp_rx_process+0xe4>
					break;
8000437e:	c1 f8       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004380:	00 9c       	mov	r12,r0
80004382:	f0 1f 00 19 	mcall	800043e4 <xcmp_rx_process+0xe4>
					break;
80004386:	c1 b8       	rjmp	800043bc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004388:	12 98       	mov	r8,r9
8000438a:	e2 18 04 00 	andl	r8,0x400,COH
8000438e:	c0 70       	breq	8000439c <xcmp_rx_process+0x9c>
80004390:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004394:	e0 48 00 68 	cp.w	r8,104
80004398:	e0 8a 00 08 	brle	800043a8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000439c:	e2 19 f0 00 	andl	r9,0xf000,COH
800043a0:	c0 e1       	brne	800043bc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800043a2:	f0 1f 00 14 	mcall	800043f0 <xcmp_rx_process+0xf0>
800043a6:	c0 b8       	rjmp	800043bc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800043a8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800043ac:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800043b0:	49 19       	lddpc	r9,800043f4 <xcmp_rx_process+0xf4>
800043b2:	72 08       	ld.w	r8,r9[0x0]
800043b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800043b8:	f0 1f 00 0b 	mcall	800043e4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800043bc:	66 0c       	ld.w	r12,r3[0x0]
800043be:	40 0b       	lddsp	r11,sp[0x0]
800043c0:	f0 1f 00 0e 	mcall	800043f8 <xcmp_rx_process+0xf8>
800043c4:	ca 7b       	rjmp	80004312 <xcmp_rx_process+0x12>
800043c6:	00 00       	add	r0,r0
800043c8:	00 00       	add	r0,r0
800043ca:	0b 04       	ld.w	r4,r5++
800043cc:	00 00       	add	r0,r0
800043ce:	0a 9c       	mov	r12,r5
800043d0:	00 00       	add	r0,r0
800043d2:	0b 14       	ld.sh	r4,r5++
800043d4:	00 00       	add	r0,r0
800043d6:	0b 08       	ld.w	r8,r5++
800043d8:	00 00       	add	r0,r0
800043da:	0a f8       	st.b	--r5,r8
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	5f d4       	srvc	r4
800043e0:	00 00       	add	r0,r0
800043e2:	0b 2c       	ld.uh	r12,r5++
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	42 04       	lddsp	r4,sp[0x80]
800043e8:	00 00       	add	r0,r0
800043ea:	0a ec       	st.h	--r5,r12
800043ec:	00 00       	add	r0,r0
800043ee:	0b 20       	ld.uh	r0,r5++
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	41 e0       	lddsp	r0,sp[0x78]
800043f4:	00 00       	add	r0,r0
800043f6:	51 14       	stdsp	sp[0x44],r4
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	29 e0       	sub	r0,-98

800043fc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800043fc:	eb cd 40 90 	pushm	r4,r7,lr
80004400:	20 1d       	sub	sp,4
80004402:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004406:	48 c8       	lddpc	r8,80004434 <xcmp_rx+0x38>
80004408:	70 0c       	ld.w	r12,r8[0x0]
8000440a:	f0 1f 00 0c 	mcall	80004438 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000440e:	c1 00       	breq	8000442e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004410:	fa c7 ff fc 	sub	r7,sp,-4
80004414:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004416:	e0 6a 00 ca 	mov	r10,202
8000441a:	08 9b       	mov	r11,r4
8000441c:	f0 1f 00 08 	mcall	8000443c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004420:	48 88       	lddpc	r8,80004440 <xcmp_rx+0x44>
80004422:	70 0c       	ld.w	r12,r8[0x0]
80004424:	30 09       	mov	r9,0
80004426:	12 9a       	mov	r10,r9
80004428:	1a 9b       	mov	r11,sp
8000442a:	f0 1f 00 07 	mcall	80004444 <xcmp_rx+0x48>
	}	
}
8000442e:	2f fd       	sub	sp,-4
80004430:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004434:	00 00       	add	r0,r0
80004436:	0a 9c       	mov	r12,r5
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	2f 4c       	sub	r12,-12
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	76 0c       	ld.w	r12,r11[0x0]
80004440:	00 00       	add	r0,r0
80004442:	0b 04       	ld.w	r4,r5++
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	61 e0       	ld.w	r0,r0[0x78]

80004448 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004448:	48 28       	lddpc	r8,80004450 <xnl_register_xcmp_func+0x8>
8000444a:	91 0c       	st.w	r8[0x0],r12
}
8000444c:	5e fc       	retal	r12
8000444e:	00 00       	add	r0,r0
80004450:	00 00       	add	r0,r0
80004452:	0b 5c       	ld.sh	r12,--r5

80004454 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004454:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004456:	48 88       	lddpc	r8,80004474 <xnl_get_msg_ack_func+0x20>
80004458:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000445a:	98 49       	ld.sh	r9,r12[0x8]
8000445c:	f0 09 19 00 	cp.h	r9,r8
80004460:	c0 81       	brne	80004470 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004462:	48 68       	lddpc	r8,80004478 <xnl_get_msg_ack_func+0x24>
80004464:	70 0c       	ld.w	r12,r8[0x0]
80004466:	30 09       	mov	r9,0
80004468:	12 9a       	mov	r10,r9
8000446a:	12 9b       	mov	r11,r9
8000446c:	f0 1f 00 04 	mcall	8000447c <xnl_get_msg_ack_func+0x28>
80004470:	d8 02       	popm	pc
80004472:	00 00       	add	r0,r0
80004474:	00 00       	add	r0,r0
80004476:	0b 3c       	ld.ub	r12,r5++
80004478:	00 00       	add	r0,r0
8000447a:	0b 38       	ld.ub	r8,r5++
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	61 e0       	ld.w	r0,r0[0x78]

80004480 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004480:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004484:	30 09       	mov	r9,0
80004486:	4b 78       	lddpc	r8,80004560 <xnl_init+0xe0>
80004488:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000448a:	30 0b       	mov	r11,0
8000448c:	30 1c       	mov	r12,1
8000448e:	f0 1f 00 36 	mcall	80004564 <xnl_init+0xe4>
80004492:	4b 68       	lddpc	r8,80004568 <xnl_init+0xe8>
80004494:	91 0c       	st.w	r8[0x0],r12
80004496:	70 08       	ld.w	r8,r8[0x0]
80004498:	58 08       	cp.w	r8,0
8000449a:	c0 80       	breq	800044aa <xnl_init+0x2a>
8000449c:	4b 38       	lddpc	r8,80004568 <xnl_init+0xe8>
8000449e:	70 0c       	ld.w	r12,r8[0x0]
800044a0:	30 09       	mov	r9,0
800044a2:	12 9a       	mov	r10,r9
800044a4:	12 9b       	mov	r11,r9
800044a6:	f0 1f 00 32 	mcall	8000456c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800044aa:	30 4b       	mov	r11,4
800044ac:	31 4c       	mov	r12,20
800044ae:	f0 1f 00 2e 	mcall	80004564 <xnl_init+0xe4>
800044b2:	4b 08       	lddpc	r8,80004570 <xnl_init+0xf0>
800044b4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800044b6:	30 4b       	mov	r11,4
800044b8:	31 ec       	mov	r12,30
800044ba:	f0 1f 00 2b 	mcall	80004564 <xnl_init+0xe4>
800044be:	4a e8       	lddpc	r8,80004574 <xnl_init+0xf4>
800044c0:	91 0c       	st.w	r8[0x0],r12
800044c2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800044c4:	10 96       	mov	r6,r8
800044c6:	4a d5       	lddpc	r5,80004578 <xnl_init+0xf8>
800044c8:	6c 0c       	ld.w	r12,r6[0x0]
800044ca:	ea 07 00 0b 	add	r11,r5,r7
800044ce:	f0 1f 00 2c 	mcall	8000457c <xnl_init+0xfc>
800044d2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800044d6:	e0 47 1e 00 	cp.w	r7,7680
800044da:	cf 71       	brne	800044c8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800044dc:	30 4b       	mov	r11,4
800044de:	31 4c       	mov	r12,20
800044e0:	f0 1f 00 21 	mcall	80004564 <xnl_init+0xe4>
800044e4:	4a 78       	lddpc	r8,80004580 <xnl_init+0x100>
800044e6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800044e8:	30 4b       	mov	r11,4
800044ea:	30 ac       	mov	r12,10
800044ec:	f0 1f 00 1e 	mcall	80004564 <xnl_init+0xe4>
800044f0:	4a 58       	lddpc	r8,80004584 <xnl_init+0x104>
800044f2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800044f4:	30 4b       	mov	r11,4
800044f6:	30 ac       	mov	r12,10
800044f8:	f0 1f 00 1b 	mcall	80004564 <xnl_init+0xe4>
800044fc:	4a 38       	lddpc	r8,80004588 <xnl_init+0x108>
800044fe:	91 0c       	st.w	r8[0x0],r12
80004500:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004502:	10 96       	mov	r6,r8
80004504:	4a 25       	lddpc	r5,8000458c <xnl_init+0x10c>
80004506:	6c 0c       	ld.w	r12,r6[0x0]
80004508:	ea 07 00 0b 	add	r11,r5,r7
8000450c:	f0 1f 00 1c 	mcall	8000457c <xnl_init+0xfc>
80004510:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004514:	e0 47 14 00 	cp.w	r7,5120
80004518:	cf 71       	brne	80004506 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000451a:	30 4b       	mov	r11,4
8000451c:	30 5c       	mov	r12,5
8000451e:	f0 1f 00 12 	mcall	80004564 <xnl_init+0xe4>
80004522:	49 c8       	lddpc	r8,80004590 <xnl_init+0x110>
80004524:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004526:	30 07       	mov	r7,0
80004528:	1a d7       	st.w	--sp,r7
8000452a:	1a d7       	st.w	--sp,r7
8000452c:	1a d7       	st.w	--sp,r7
8000452e:	30 38       	mov	r8,3
80004530:	0e 99       	mov	r9,r7
80004532:	e0 6a 02 00 	mov	r10,512
80004536:	49 8b       	lddpc	r11,80004594 <xnl_init+0x114>
80004538:	49 8c       	lddpc	r12,80004598 <xnl_init+0x118>
8000453a:	f0 1f 00 19 	mcall	8000459c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000453e:	1a d7       	st.w	--sp,r7
80004540:	1a d7       	st.w	--sp,r7
80004542:	1a d7       	st.w	--sp,r7
80004544:	30 38       	mov	r8,3
80004546:	0e 99       	mov	r9,r7
80004548:	e0 6a 03 20 	mov	r10,800
8000454c:	49 5b       	lddpc	r11,800045a0 <xnl_init+0x120>
8000454e:	49 6c       	lddpc	r12,800045a4 <xnl_init+0x124>
80004550:	f0 1f 00 13 	mcall	8000459c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004554:	f0 1f 00 15 	mcall	800045a8 <xnl_init+0x128>
80004558:	2f ad       	sub	sp,-24
}
8000455a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000455e:	00 00       	add	r0,r0
80004560:	00 00       	add	r0,r0
80004562:	0b 3c       	ld.ub	r12,r5++
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	62 e0       	ld.w	r0,r1[0x38]
80004568:	00 00       	add	r0,r0
8000456a:	0b 38       	ld.ub	r8,r5++
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	61 e0       	ld.w	r0,r0[0x78]
80004570:	00 00       	add	r0,r0
80004572:	0b 48       	ld.w	r8,--r5
80004574:	00 00       	add	r0,r0
80004576:	0a 9c       	mov	r12,r5
80004578:	00 00       	add	r0,r0
8000457a:	32 c6       	mov	r6,44
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	29 e0       	sub	r0,-98
80004580:	00 00       	add	r0,r0
80004582:	0a cc       	st.b	r5++,r12
80004584:	00 00       	add	r0,r0
80004586:	0a b8       	st.h	r5++,r8
80004588:	00 00       	add	r0,r0
8000458a:	0a a4       	st.w	r5++,r4
8000458c:	00 00       	add	r0,r0
8000458e:	1e c6       	st.b	pc++,r6
80004590:	00 00       	add	r0,r0
80004592:	0a 74       	tst	r4,r5
80004594:	80 00       	ld.sh	r0,r0[0x0]
80004596:	d5 64       	*unknown*
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	45 ac       	lddsp	r12,sp[0x168]
8000459c:	80 00       	ld.sh	r0,r0[0x0]
8000459e:	69 b4       	ld.w	r4,r4[0x6c]
800045a0:	80 00       	ld.sh	r0,r0[0x0]
800045a2:	ce 00       	breq	80004562 <xnl_init+0xe2>
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	46 0c       	lddsp	r12,sp[0x180]
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	2f 74       	sub	r4,-9

800045ac <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800045ac:	eb cd 40 fe 	pushm	r1-r7,lr
800045b0:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800045b2:	49 26       	lddpc	r6,800045f8 <xnl_rx_process+0x4c>
800045b4:	30 05       	mov	r5,0
800045b6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800045b8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800045ba:	49 11       	lddpc	r1,800045fc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800045bc:	49 12       	lddpc	r2,80004600 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800045be:	6c 0c       	ld.w	r12,r6[0x0]
800045c0:	0a 99       	mov	r9,r5
800045c2:	08 9a       	mov	r10,r4
800045c4:	1a 9b       	mov	r11,sp
800045c6:	f0 1f 00 10 	mcall	80004604 <xnl_rx_process+0x58>
800045ca:	58 1c       	cp.w	r12,1
800045cc:	cf 91       	brne	800045be <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800045ce:	40 0c       	lddsp	r12,sp[0x0]
800045d0:	58 0c       	cp.w	r12,0
800045d2:	cf 60       	breq	800045be <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800045d4:	98 28       	ld.sh	r8,r12[0x4]
800045d6:	e6 08 19 00 	cp.h	r8,r3
800045da:	e0 8b 00 0a 	brhi	800045ee <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800045de:	5c 78       	castu.h	r8
800045e0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800045e4:	58 09       	cp.w	r9,0
800045e6:	c0 40       	breq	800045ee <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800045e8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800045ec:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800045ee:	62 0c       	ld.w	r12,r1[0x0]
800045f0:	40 0b       	lddsp	r11,sp[0x0]
800045f2:	f0 1f 00 06 	mcall	80004608 <xnl_rx_process+0x5c>
800045f6:	ce 4b       	rjmp	800045be <xnl_rx_process+0x12>
800045f8:	00 00       	add	r0,r0
800045fa:	0a b8       	st.h	r5++,r8
800045fc:	00 00       	add	r0,r0
800045fe:	0a 9c       	mov	r12,r5
80004600:	00 00       	add	r0,r0
80004602:	04 f0       	st.b	--r2,r0
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	5f d4       	srvc	r4
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	29 e0       	sub	r0,-98

8000460c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000460c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000460e:	4a a6       	lddpc	r6,800046b4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004610:	4a a2       	lddpc	r2,800046b8 <xnl_tx_process+0xac>
80004612:	4a b4       	lddpc	r4,800046bc <xnl_tx_process+0xb0>
80004614:	30 07       	mov	r7,0
80004616:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004618:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000461a:	4a a5       	lddpc	r5,800046c0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000461c:	4a a3       	lddpc	r3,800046c4 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000461e:	6c 08       	ld.w	r8,r6[0x0]
80004620:	58 08       	cp.w	r8,0
80004622:	c0 40       	breq	8000462a <xnl_tx_process+0x1e>
80004624:	58 18       	cp.w	r8,1
80004626:	cf d1       	brne	80004620 <xnl_tx_process+0x14>
80004628:	c2 48       	rjmp	80004670 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000462a:	64 0c       	ld.w	r12,r2[0x0]
8000462c:	0e 99       	mov	r9,r7
8000462e:	02 9a       	mov	r10,r1
80004630:	08 9b       	mov	r11,r4
80004632:	f0 1f 00 26 	mcall	800046c8 <xnl_tx_process+0xbc>
80004636:	58 1c       	cp.w	r12,1
80004638:	cf 31       	brne	8000461e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000463a:	68 0b       	ld.w	r11,r4[0x0]
8000463c:	58 0b       	cp.w	r11,0
8000463e:	cf 00       	breq	8000461e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004640:	96 28       	ld.sh	r8,r11[0x4]
80004642:	e0 08 19 00 	cp.h	r8,r0
80004646:	c0 71       	brne	80004654 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004648:	4a 18       	lddpc	r8,800046cc <xnl_tx_process+0xc0>
8000464a:	70 08       	ld.w	r8,r8[0x0]
8000464c:	10 9c       	mov	r12,r8
8000464e:	f0 1f 00 21 	mcall	800046d0 <xnl_tx_process+0xc4>
						break;
80004652:	ce 6b       	rjmp	8000461e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004654:	16 9c       	mov	r12,r11
80004656:	f0 1f 00 20 	mcall	800046d4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000465a:	30 18       	mov	r8,1
8000465c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000465e:	66 0c       	ld.w	r12,r3[0x0]
80004660:	0e 99       	mov	r9,r7
80004662:	0e 9a       	mov	r10,r7
80004664:	0e 9b       	mov	r11,r7
80004666:	f0 1f 00 19 	mcall	800046c8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000466a:	30 18       	mov	r8,1
8000466c:	8d 08       	st.w	r6[0x0],r8
8000466e:	cd 8b       	rjmp	8000461e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004670:	66 0c       	ld.w	r12,r3[0x0]
80004672:	0e 99       	mov	r9,r7
80004674:	36 4a       	mov	r10,100
80004676:	0e 9b       	mov	r11,r7
80004678:	f0 1f 00 14 	mcall	800046c8 <xnl_tx_process+0xbc>
8000467c:	58 1c       	cp.w	r12,1
8000467e:	c0 81       	brne	8000468e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004680:	49 38       	lddpc	r8,800046cc <xnl_tx_process+0xc0>
80004682:	70 0c       	ld.w	r12,r8[0x0]
80004684:	68 0b       	ld.w	r11,r4[0x0]
80004686:	f0 1f 00 13 	mcall	800046d0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000468a:	8d 07       	st.w	r6[0x0],r7
8000468c:	cc 9b       	rjmp	8000461e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000468e:	6a 08       	ld.w	r8,r5[0x0]
80004690:	58 38       	cp.w	r8,3
80004692:	e0 89 00 09 	brgt	800046a4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004696:	68 0c       	ld.w	r12,r4[0x0]
80004698:	f0 1f 00 0f 	mcall	800046d4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000469c:	6a 08       	ld.w	r8,r5[0x0]
8000469e:	2f f8       	sub	r8,-1
800046a0:	8b 08       	st.w	r5[0x0],r8
800046a2:	cb eb       	rjmp	8000461e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800046a4:	48 a8       	lddpc	r8,800046cc <xnl_tx_process+0xc0>
800046a6:	70 0c       	ld.w	r12,r8[0x0]
800046a8:	68 0b       	ld.w	r11,r4[0x0]
800046aa:	f0 1f 00 0a 	mcall	800046d0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800046ae:	8d 07       	st.w	r6[0x0],r7
800046b0:	cb 7b       	rjmp	8000461e <xnl_tx_process+0x12>
800046b2:	00 00       	add	r0,r0
800046b4:	00 00       	add	r0,r0
800046b6:	0b 58       	ld.sh	r8,--r5
800046b8:	00 00       	add	r0,r0
800046ba:	0b 48       	ld.w	r8,--r5
800046bc:	00 00       	add	r0,r0
800046be:	0b 50       	ld.sh	r0,--r5
800046c0:	00 00       	add	r0,r0
800046c2:	0b 4c       	ld.w	r12,--r5
800046c4:	00 00       	add	r0,r0
800046c6:	0b 38       	ld.ub	r8,r5++
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	5f d4       	srvc	r4
800046cc:	00 00       	add	r0,r0
800046ce:	0a 9c       	mov	r12,r5
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	29 e0       	sub	r0,-98
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	2a 00       	sub	r0,-96

800046d8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800046d8:	eb cd 40 c0 	pushm	r6-r7,lr
800046dc:	20 1d       	sub	sp,4
800046de:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800046e0:	98 39       	ld.sh	r9,r12[0x6]
800046e2:	3f f8       	mov	r8,-1
800046e4:	f0 09 19 00 	cp.h	r9,r8
800046e8:	c0 a1       	brne	800046fc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800046ea:	4a e9       	lddpc	r9,800047a0 <xnl_tx+0xc8>
800046ec:	13 88       	ld.ub	r8,r9[0x0]
800046ee:	2f f8       	sub	r8,-1
800046f0:	5c 58       	castu.b	r8
800046f2:	b2 88       	st.b	r9[0x0],r8
800046f4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800046f8:	a9 a8       	sbr	r8,0x8
800046fa:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800046fc:	8c 49       	ld.sh	r9,r6[0x8]
800046fe:	3f f8       	mov	r8,-1
80004700:	f0 09 19 00 	cp.h	r9,r8
80004704:	c0 41       	brne	8000470c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004706:	4a 88       	lddpc	r8,800047a4 <xnl_tx+0xcc>
80004708:	90 18       	ld.sh	r8,r8[0x2]
8000470a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000470c:	8c 59       	ld.sh	r9,r6[0xa]
8000470e:	3f f8       	mov	r8,-1
80004710:	f0 09 19 00 	cp.h	r9,r8
80004714:	c0 41       	brne	8000471c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004716:	4a 48       	lddpc	r8,800047a4 <xnl_tx+0xcc>
80004718:	90 28       	ld.sh	r8,r8[0x4]
8000471a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000471c:	8c 69       	ld.sh	r9,r6[0xc]
8000471e:	3f f8       	mov	r8,-1
80004720:	f0 09 19 00 	cp.h	r9,r8
80004724:	c0 e1       	brne	80004740 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004726:	4a 08       	lddpc	r8,800047a4 <xnl_tx+0xcc>
80004728:	90 49       	ld.sh	r9,r8[0x8]
8000472a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000472c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000472e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004730:	90 49       	ld.sh	r9,r8[0x8]
80004732:	e0 19 ff 00 	andl	r9,0xff00
80004736:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000473a:	f3 e8 10 08 	or	r8,r9,r8
8000473e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004740:	0d 98       	ld.ub	r8,r6[0x1]
80004742:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004744:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004748:	10 0c       	add	r12,r8
8000474a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000474c:	58 0c       	cp.w	r12,0
8000474e:	e0 89 00 04 	brgt	80004756 <xnl_tx+0x7e>
80004752:	30 09       	mov	r9,0
80004754:	c0 d8       	rjmp	8000476e <xnl_tx+0x96>
80004756:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000475a:	2f ec       	sub	r12,-2
8000475c:	30 09       	mov	r9,0
8000475e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004760:	15 1b       	ld.sh	r11,r10++
80004762:	f6 09 00 09 	add	r9,r11,r9
80004766:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004768:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000476a:	18 38       	cp.w	r8,r12
8000476c:	cf a1       	brne	80004760 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000476e:	5c 39       	neg	r9
80004770:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004772:	48 e8       	lddpc	r8,800047a8 <xnl_tx+0xd0>
80004774:	70 0c       	ld.w	r12,r8[0x0]
80004776:	f0 1f 00 0e 	mcall	800047ac <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000477a:	c1 00       	breq	8000479a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000477c:	fa c7 ff fc 	sub	r7,sp,-4
80004780:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004782:	e0 6a 01 00 	mov	r10,256
80004786:	0c 9b       	mov	r11,r6
80004788:	f0 1f 00 0a 	mcall	800047b0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000478c:	48 a8       	lddpc	r8,800047b4 <xnl_tx+0xdc>
8000478e:	70 0c       	ld.w	r12,r8[0x0]
80004790:	30 09       	mov	r9,0
80004792:	12 9a       	mov	r10,r9
80004794:	1a 9b       	mov	r11,sp
80004796:	f0 1f 00 09 	mcall	800047b8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000479a:	2f fd       	sub	sp,-4
8000479c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047a0:	00 00       	add	r0,r0
800047a2:	0b 54       	ld.sh	r4,--r5
800047a4:	00 00       	add	r0,r0
800047a6:	0b 3c       	ld.ub	r12,r5++
800047a8:	00 00       	add	r0,r0
800047aa:	0a 9c       	mov	r12,r5
800047ac:	80 00       	ld.sh	r0,r0[0x0]
800047ae:	2f 4c       	sub	r12,-12
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	76 0c       	ld.w	r12,r11[0x0]
800047b4:	00 00       	add	r0,r0
800047b6:	0b 48       	ld.w	r8,--r5
800047b8:	80 00       	ld.sh	r0,r0[0x0]
800047ba:	61 e0       	ld.w	r0,r0[0x78]

800047bc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800047bc:	eb cd 40 80 	pushm	r7,lr
800047c0:	fa cd 01 00 	sub	sp,sp,256
800047c4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047c6:	e0 68 40 0e 	mov	r8,16398
800047ca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047cc:	3f f8       	mov	r8,-1
800047ce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800047d0:	30 c8       	mov	r8,12
800047d2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800047d4:	98 38       	ld.sh	r8,r12[0x6]
800047d6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800047d8:	98 58       	ld.sh	r8,r12[0xa]
800047da:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800047dc:	98 48       	ld.sh	r8,r12[0x8]
800047de:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800047e0:	98 68       	ld.sh	r8,r12[0xc]
800047e2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800047e4:	30 08       	mov	r8,0
800047e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047e8:	1a 9c       	mov	r12,sp
800047ea:	f0 1f 00 0a 	mcall	80004810 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800047ee:	fa cd 00 cc 	sub	sp,sp,204
800047f2:	e0 6a 00 ca 	mov	r10,202
800047f6:	ee cb ff f0 	sub	r11,r7,-16
800047fa:	1a 9c       	mov	r12,sp
800047fc:	f0 1f 00 06 	mcall	80004814 <xnl_data_msg_func+0x58>
80004800:	48 68       	lddpc	r8,80004818 <xnl_data_msg_func+0x5c>
80004802:	70 08       	ld.w	r8,r8[0x0]
80004804:	5d 18       	icall	r8
80004806:	fa cd ff 34 	sub	sp,sp,-204
}
8000480a:	2c 0d       	sub	sp,-256
8000480c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	46 d8       	lddsp	r8,sp[0x1b4]
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	76 0c       	ld.w	r12,r11[0x0]
80004818:	00 00       	add	r0,r0
8000481a:	0b 5c       	ld.sh	r12,--r5

8000481c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000481c:	d4 21       	pushm	r4-r7,lr
8000481e:	fa cd 01 00 	sub	sp,sp,256
80004822:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004824:	4c 28       	lddpc	r8,8000492c <xnl_device_auth_reply_func+0x110>
80004826:	11 88       	ld.ub	r8,r8[0x0]
80004828:	58 08       	cp.w	r8,0
8000482a:	c7 e1       	brne	80004926 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000482c:	4c 18       	lddpc	r8,80004930 <xnl_device_auth_reply_func+0x114>
8000482e:	70 0c       	ld.w	r12,r8[0x0]
80004830:	30 09       	mov	r9,0
80004832:	12 9a       	mov	r10,r9
80004834:	12 9b       	mov	r11,r9
80004836:	f0 1f 00 40 	mcall	80004934 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000483a:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000483e:	4b c8       	lddpc	r8,8000492c <xnl_device_auth_reply_func+0x110>
80004840:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004842:	ef 39 00 12 	ld.ub	r9,r7[18]
80004846:	ef 38 00 13 	ld.ub	r8,r7[19]
8000484a:	b1 68       	lsl	r8,0x10
8000484c:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004850:	ef 38 00 15 	ld.ub	r8,r7[21]
80004854:	f3 e8 10 08 	or	r8,r9,r8
80004858:	ef 39 00 14 	ld.ub	r9,r7[20]
8000485c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004860:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004864:	ef 38 00 17 	ld.ub	r8,r7[23]
80004868:	b1 68       	lsl	r8,0x10
8000486a:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000486e:	ef 38 00 19 	ld.ub	r8,r7[25]
80004872:	f5 e8 10 08 	or	r8,r10,r8
80004876:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000487a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000487e:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004880:	e0 64 79 b9 	mov	r4,31161
80004884:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004888:	e0 65 45 07 	mov	r5,17671
8000488c:	ea 15 8a bd 	orh	r5,0x8abd
80004890:	e0 66 f9 3d 	mov	r6,63805
80004894:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004898:	e0 6e b8 cf 	mov	lr,47311
8000489c:	ea 1e 36 83 	orh	lr,0x3683
800048a0:	e0 67 aa 1c 	mov	r7,43548
800048a4:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800048a8:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800048aa:	f4 08 00 0c 	add	r12,r10,r8
800048ae:	f0 0b 15 04 	lsl	r11,r8,0x4
800048b2:	0a 0b       	add	r11,r5
800048b4:	f9 eb 20 0b 	eor	r11,r12,r11
800048b8:	f0 0c 16 05 	lsr	r12,r8,0x5
800048bc:	0c 0c       	add	r12,r6
800048be:	18 5b       	eor	r11,r12
800048c0:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800048c2:	f2 0c 15 04 	lsl	r12,r9,0x4
800048c6:	1c 0c       	add	r12,lr
800048c8:	f2 0b 16 05 	lsr	r11,r9,0x5
800048cc:	0e 0b       	add	r11,r7
800048ce:	f9 eb 20 0b 	eor	r11,r12,r11
800048d2:	f2 0a 00 0c 	add	r12,r9,r10
800048d6:	18 5b       	eor	r11,r12
800048d8:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800048da:	e0 6b 37 20 	mov	r11,14112
800048de:	ea 1b c6 ef 	orh	r11,0xc6ef
800048e2:	16 3a       	cp.w	r10,r11
800048e4:	ce 21       	brne	800048a8 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800048e6:	e0 6a 40 1a 	mov	r10,16410
800048ea:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048ec:	3f fa       	mov	r10,-1
800048ee:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800048f0:	30 6b       	mov	r11,6
800048f2:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048f4:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048f6:	48 eb       	lddpc	r11,8000492c <xnl_device_auth_reply_func+0x110>
800048f8:	96 1c       	ld.sh	r12,r11[0x2]
800048fa:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800048fc:	96 2b       	ld.sh	r11,r11[0x4]
800048fe:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004900:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004902:	30 ca       	mov	r10,12
80004904:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004906:	30 0a       	mov	r10,0
80004908:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000490c:	30 7a       	mov	r10,7
8000490e:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004912:	30 2a       	mov	r10,2
80004914:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004918:	fa ca ff ec 	sub	r10,sp,-20
8000491c:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000491e:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004920:	1a 9c       	mov	r12,sp
80004922:	f0 1f 00 06 	mcall	80004938 <xnl_device_auth_reply_func+0x11c>
}
80004926:	2c 0d       	sub	sp,-256
80004928:	d8 22       	popm	r4-r7,pc
8000492a:	00 00       	add	r0,r0
8000492c:	00 00       	add	r0,r0
8000492e:	0b 3c       	ld.ub	r12,r5++
80004930:	00 00       	add	r0,r0
80004932:	0b 38       	ld.ub	r8,r5++
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	61 e0       	ld.w	r0,r0[0x78]
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	46 d8       	lddsp	r8,sp[0x1b4]

8000493c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000493c:	eb cd 40 80 	pushm	r7,lr
80004940:	fa cd 01 00 	sub	sp,sp,256
80004944:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004946:	49 28       	lddpc	r8,8000498c <xnl_master_status_brdcst_func+0x50>
80004948:	11 88       	ld.ub	r8,r8[0x0]
8000494a:	58 08       	cp.w	r8,0
8000494c:	c1 c1       	brne	80004984 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000494e:	49 18       	lddpc	r8,80004990 <xnl_master_status_brdcst_func+0x54>
80004950:	70 0c       	ld.w	r12,r8[0x0]
80004952:	30 09       	mov	r9,0
80004954:	12 9a       	mov	r10,r9
80004956:	12 9b       	mov	r11,r9
80004958:	f0 1f 00 0f 	mcall	80004994 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000495c:	8e 58       	ld.sh	r8,r7[0xa]
8000495e:	48 c9       	lddpc	r9,8000498c <xnl_master_status_brdcst_func+0x50>
80004960:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004962:	e0 68 40 0e 	mov	r8,16398
80004966:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004968:	3f f8       	mov	r8,-1
8000496a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000496c:	30 4a       	mov	r10,4
8000496e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004970:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004972:	92 19       	ld.sh	r9,r9[0x2]
80004974:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004976:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004978:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000497a:	30 08       	mov	r8,0
8000497c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000497e:	1a 9c       	mov	r12,sp
80004980:	f0 1f 00 06 	mcall	80004998 <xnl_master_status_brdcst_func+0x5c>
}
80004984:	2c 0d       	sub	sp,-256
80004986:	e3 cd 80 80 	ldm	sp++,r7,pc
8000498a:	00 00       	add	r0,r0
8000498c:	00 00       	add	r0,r0
8000498e:	0b 3c       	ld.ub	r12,r5++
80004990:	00 00       	add	r0,r0
80004992:	0b 38       	ld.ub	r8,r5++
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	61 e0       	ld.w	r0,r0[0x78]
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	46 d8       	lddsp	r8,sp[0x1b4]

8000499c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000499c:	eb cd 40 80 	pushm	r7,lr
800049a0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800049a2:	49 28       	lddpc	r8,800049e8 <xnl_device_conn_reply_func+0x4c>
800049a4:	70 0c       	ld.w	r12,r8[0x0]
800049a6:	30 09       	mov	r9,0
800049a8:	12 9a       	mov	r10,r9
800049aa:	12 9b       	mov	r11,r9
800049ac:	f0 1f 00 10 	mcall	800049ec <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800049b0:	ef 18 00 10 	ld.uh	r8,r7[16]
800049b4:	10 99       	mov	r9,r8
800049b6:	e2 19 ff 00 	andl	r9,0xff00,COH
800049ba:	e0 49 01 00 	cp.w	r9,256
800049be:	c0 60       	breq	800049ca <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800049c0:	0e 9c       	mov	r12,r7
800049c2:	f0 1f 00 0c 	mcall	800049f0 <xnl_device_conn_reply_func+0x54>
800049c6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800049ca:	a9 68       	lsl	r8,0x8
800049cc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800049d0:	48 98       	lddpc	r8,800049f4 <xnl_device_conn_reply_func+0x58>
800049d2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800049d4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800049d8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800049da:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800049de:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800049e0:	30 19       	mov	r9,1
800049e2:	b0 89       	st.b	r8[0x0],r9
800049e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800049e8:	00 00       	add	r0,r0
800049ea:	0b 38       	ld.ub	r8,r5++
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	61 e0       	ld.w	r0,r0[0x78]
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	49 3c       	lddpc	r12,80004a3c <delay_ns+0x14>
800049f4:	00 00       	add	r0,r0
800049f6:	0b 3c       	ld.ub	r12,r5++

800049f8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800049f8:	d4 01       	pushm	lr
800049fa:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800049fe:	e0 68 40 0e 	mov	r8,16398
80004a02:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a04:	3f f8       	mov	r8,-1
80004a06:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004a08:	30 38       	mov	r8,3
80004a0a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004a0c:	30 08       	mov	r8,0
80004a0e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004a10:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004a12:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004a14:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004a16:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a18:	1a 9c       	mov	r12,sp
80004a1a:	f0 1f 00 03 	mcall	80004a24 <xnl_send_device_master_query+0x2c>
}
80004a1e:	2c 0d       	sub	sp,-256
80004a20:	d8 02       	popm	pc
80004a22:	00 00       	add	r0,r0
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	46 d8       	lddsp	r8,sp[0x1b4]

80004a28 <delay_ns>:
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004a28:	58 0c       	cp.w	r12,0
80004a2a:	5e 0c       	reteq	r12
80004a2c:	30 08       	mov	r8,0
	{
		nop();
80004a2e:	d7 03       	nop
		nop();
80004a30:	d7 03       	nop
		nop();
80004a32:	d7 03       	nop
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004a34:	2f f8       	sub	r8,-1
80004a36:	10 3c       	cp.w	r12,r8
80004a38:	fe 9b ff fb 	brhi	80004a2e <delay_ns+0x6>
80004a3c:	5e fc       	retal	r12
80004a3e:	d7 03       	nop

80004a40 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80004a40:	eb cd 40 e0 	pushm	r5-r7,lr
80004a44:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80004a46:	58 0c       	cp.w	r12,0
80004a48:	c0 b0       	breq	80004a5e <delay_us+0x1e>
80004a4a:	30 07       	mov	r7,0
		delay_ns(1000);
80004a4c:	e0 65 03 e8 	mov	r5,1000
80004a50:	0a 9c       	mov	r12,r5
80004a52:	f0 1f 00 05 	mcall	80004a64 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80004a56:	2f f7       	sub	r7,-1
80004a58:	0e 36       	cp.w	r6,r7
80004a5a:	fe 9b ff fb 	brhi	80004a50 <delay_us+0x10>
80004a5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004a62:	00 00       	add	r0,r0
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	4a 28       	lddpc	r8,80004aec <RC522_ReadByte+0x28>

80004a68 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80004a68:	eb cd 40 e0 	pushm	r5-r7,lr
80004a6c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80004a6e:	58 0c       	cp.w	r12,0
80004a70:	c0 b0       	breq	80004a86 <delay_ms+0x1e>
80004a72:	30 07       	mov	r7,0
		delay_us(1000);
80004a74:	e0 65 03 e8 	mov	r5,1000
80004a78:	0a 9c       	mov	r12,r5
80004a7a:	f0 1f 00 05 	mcall	80004a8c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80004a7e:	2f f7       	sub	r7,-1
80004a80:	0e 36       	cp.w	r6,r7
80004a82:	fe 9b ff fb 	brhi	80004a78 <delay_ms+0x10>
80004a86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004a8a:	00 00       	add	r0,r0
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	4a 40       	lddpc	r0,80004b1c <RC522_WriteByte+0x14>

80004a90 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004a90:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004a92:	48 78       	lddpc	r8,80004aac <RC522_SPI_SetSpeed+0x1c>
80004a94:	70 09       	ld.w	r9,r8[0x0]
80004a96:	72 ca       	ld.w	r10,r9[0x30]
80004a98:	5c 7c       	castu.h	r12
80004a9a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004a9e:	f9 ea 10 0a 	or	r10,r12,r10
80004aa2:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004aa4:	70 0c       	ld.w	r12,r8[0x0]
80004aa6:	f0 1f 00 03 	mcall	80004ab0 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004aaa:	d8 02       	popm	pc
80004aac:	00 00       	add	r0,r0
80004aae:	1d a0       	ld.ub	r0,lr[0x2]
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	56 d0       	stdsp	sp[0x1b4],r0

80004ab4 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004ab4:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0xFF00);//baudDiv=255
80004ab6:	e0 6c ff 00 	mov	r12,65280
80004aba:	f0 1f 00 02 	mcall	80004ac0 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004abe:	d8 02       	popm	pc
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	4a 90       	lddpc	r0,80004b64 <WriteRawRC+0x10>

80004ac4 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004ac4:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004ac8:	48 b7       	lddpc	r7,80004af4 <RC522_ReadByte+0x30>
80004aca:	30 0b       	mov	r11,0
80004acc:	6e 0c       	ld.w	r12,r7[0x0]
80004ace:	f0 1f 00 0b 	mcall	80004af8 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004ad2:	e0 6b 00 ff 	mov	r11,255
80004ad6:	6e 0c       	ld.w	r12,r7[0x0]
80004ad8:	f0 1f 00 09 	mcall	80004afc <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004adc:	30 06       	mov	r6,0
80004ade:	0c 9b       	mov	r11,r6
80004ae0:	6e 0c       	ld.w	r12,r7[0x0]
80004ae2:	f0 1f 00 08 	mcall	80004b00 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004ae6:	0c 9b       	mov	r11,r6
80004ae8:	6e 0c       	ld.w	r12,r7[0x0]
80004aea:	f0 1f 00 07 	mcall	80004b04 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004aee:	0d 9c       	ld.ub	r12,r6[0x1]
80004af0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004af4:	00 00       	add	r0,r0
80004af6:	1d a0       	ld.ub	r0,lr[0x2]
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	58 3c       	cp.w	r12,3
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	56 d6       	stdsp	sp[0x1b4],r6
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	56 f2       	stdsp	sp[0x1bc],r2
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	57 fc       	stdsp	sp[0x1fc],r12

80004b08 <RC522_WriteByte>:
	
}


U8 RC522_WriteByte(U8 Data)
{
80004b08:	eb cd 40 c0 	pushm	r6-r7,lr
80004b0c:	20 1d       	sub	sp,4
80004b0e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004b10:	48 c7       	lddpc	r7,80004b40 <RC522_WriteByte+0x38>
80004b12:	30 0b       	mov	r11,0
80004b14:	6e 0c       	ld.w	r12,r7[0x0]
80004b16:	f0 1f 00 0c 	mcall	80004b44 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004b1a:	1b 8b       	ld.ub	r11,sp[0x0]
80004b1c:	6e 0c       	ld.w	r12,r7[0x0]
80004b1e:	f0 1f 00 0b 	mcall	80004b48 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004b22:	1a 9b       	mov	r11,sp
80004b24:	6e 0c       	ld.w	r12,r7[0x0]
80004b26:	f0 1f 00 0a 	mcall	80004b4c <RC522_WriteByte+0x44>
80004b2a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004b2c:	30 0b       	mov	r11,0
80004b2e:	6e 0c       	ld.w	r12,r7[0x0]
80004b30:	f0 1f 00 08 	mcall	80004b50 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004b34:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004b38:	2f fd       	sub	sp,-4
80004b3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b3e:	00 00       	add	r0,r0
80004b40:	00 00       	add	r0,r0
80004b42:	1d a0       	ld.ub	r0,lr[0x2]
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	58 3c       	cp.w	r12,3
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	56 d6       	stdsp	sp[0x1b4],r6
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	56 f2       	stdsp	sp[0x1bc],r2
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	57 fc       	stdsp	sp[0x1fc],r12

80004b54 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004b54:	eb cd 40 c0 	pushm	r6-r7,lr
80004b58:	18 96       	mov	r6,r12
80004b5a:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004b5c:	31 8c       	mov	r12,24
80004b5e:	f0 1f 00 09 	mcall	80004b80 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004b62:	ec 0c 15 01 	lsl	r12,r6,0x1
80004b66:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004b6a:	f0 1f 00 07 	mcall	80004b84 <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004b6e:	0e 9c       	mov	r12,r7
80004b70:	f0 1f 00 05 	mcall	80004b84 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004b74:	31 8c       	mov	r12,24
80004b76:	f0 1f 00 05 	mcall	80004b88 <WriteRawRC+0x34>

}
80004b7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b7e:	00 00       	add	r0,r0
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	55 20       	stdsp	sp[0x148],r0
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	4b 08       	lddpc	r8,80004c44 <ReadRawRC+0x38>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	55 04       	stdsp	sp[0x140],r4

80004b8c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004b8c:	d4 01       	pushm	lr

	SET_RC522RST;
80004b8e:	31 9c       	mov	r12,25
80004b90:	f0 1f 00 1b 	mcall	80004bfc <PcdReset+0x70>
	delay_ns(10);
80004b94:	30 ac       	mov	r12,10
80004b96:	f0 1f 00 1b 	mcall	80004c00 <PcdReset+0x74>

	CLR_RC522RST;
80004b9a:	31 9c       	mov	r12,25
80004b9c:	f0 1f 00 1a 	mcall	80004c04 <PcdReset+0x78>
	delay_ns(10);
80004ba0:	30 ac       	mov	r12,10
80004ba2:	f0 1f 00 18 	mcall	80004c00 <PcdReset+0x74>

	SET_RC522RST;
80004ba6:	31 9c       	mov	r12,25
80004ba8:	f0 1f 00 15 	mcall	80004bfc <PcdReset+0x70>
	delay_ns(10);
80004bac:	30 ac       	mov	r12,10
80004bae:	f0 1f 00 15 	mcall	80004c00 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004bb2:	30 fb       	mov	r11,15
80004bb4:	30 1c       	mov	r12,1
80004bb6:	f0 1f 00 15 	mcall	80004c08 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004bba:	30 fb       	mov	r11,15
80004bbc:	30 1c       	mov	r12,1
80004bbe:	f0 1f 00 13 	mcall	80004c08 <PcdReset+0x7c>
	delay_ns(10);
80004bc2:	30 ac       	mov	r12,10
80004bc4:	f0 1f 00 0f 	mcall	80004c00 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004bc8:	33 db       	mov	r11,61
80004bca:	31 1c       	mov	r12,17
80004bcc:	f0 1f 00 0f 	mcall	80004c08 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004bd0:	31 eb       	mov	r11,30
80004bd2:	32 dc       	mov	r12,45
80004bd4:	f0 1f 00 0d 	mcall	80004c08 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004bd8:	30 0b       	mov	r11,0
80004bda:	32 cc       	mov	r12,44
80004bdc:	f0 1f 00 0b 	mcall	80004c08 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004be0:	e0 6b 00 8d 	mov	r11,141
80004be4:	32 ac       	mov	r12,42
80004be6:	f0 1f 00 09 	mcall	80004c08 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004bea:	33 eb       	mov	r11,62
80004bec:	32 bc       	mov	r12,43
80004bee:	f0 1f 00 07 	mcall	80004c08 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004bf2:	34 0b       	mov	r11,64
80004bf4:	31 5c       	mov	r12,21
80004bf6:	f0 1f 00 05 	mcall	80004c08 <PcdReset+0x7c>
	
	return MI_OK;
}
80004bfa:	d8 0a       	popm	pc,r12=0
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	55 04       	stdsp	sp[0x140],r4
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	4a 28       	lddpc	r8,80004c88 <PcdAntennaOn+0x18>
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	55 20       	stdsp	sp[0x148],r0
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	4b 54       	lddpc	r4,80004cdc <M500PcdConfigISOType+0x14>

80004c0c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004c0c:	eb cd 40 80 	pushm	r7,lr
80004c10:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004c12:	31 8c       	mov	r12,24
80004c14:	f0 1f 00 0a 	mcall	80004c3c <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004c18:	ee 08 15 01 	lsl	r8,r7,0x1
80004c1c:	10 9c       	mov	r12,r8
80004c1e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004c22:	a7 bc       	sbr	r12,0x7
80004c24:	f0 1f 00 07 	mcall	80004c40 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004c28:	f0 1f 00 07 	mcall	80004c44 <ReadRawRC+0x38>
80004c2c:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004c2e:	31 8c       	mov	r12,24
80004c30:	f0 1f 00 06 	mcall	80004c48 <ReadRawRC+0x3c>
	return ucResult;
}
80004c34:	0e 9c       	mov	r12,r7
80004c36:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c3a:	00 00       	add	r0,r0
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	55 20       	stdsp	sp[0x148],r0
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	4b 08       	lddpc	r8,80004d00 <M500PcdConfigISOType+0x38>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	4a c4       	lddpc	r4,80004cf4 <M500PcdConfigISOType+0x2c>
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	55 04       	stdsp	sp[0x140],r4

80004c4c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004c4c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c50:	18 97       	mov	r7,r12
80004c52:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004c54:	f0 1f 00 05 	mcall	80004c68 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004c58:	f9 e6 10 0b 	or	r11,r12,r6
80004c5c:	5c 5b       	castu.b	r11
80004c5e:	0e 9c       	mov	r12,r7
80004c60:	f0 1f 00 03 	mcall	80004c6c <SetBitMask+0x20>
}
80004c64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4c 0c       	lddpc	r12,80004d68 <rc522_init+0x30>
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	4b 54       	lddpc	r4,80004d40 <rc522_init+0x8>

80004c70 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004c70:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004c72:	31 4c       	mov	r12,20
80004c74:	f0 1f 00 05 	mcall	80004c88 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004c78:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004c7c:	c0 51       	brne	80004c86 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004c7e:	30 3b       	mov	r11,3
80004c80:	31 4c       	mov	r12,20
80004c82:	f0 1f 00 03 	mcall	80004c8c <PcdAntennaOn+0x1c>
80004c86:	d8 02       	popm	pc
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	4c 0c       	lddpc	r12,80004d88 <rc522_init+0x50>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	4c 4c       	lddpc	r12,80004d9c <rc522_init+0x64>

80004c90 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004c90:	eb cd 40 c0 	pushm	r6-r7,lr
80004c94:	18 97       	mov	r7,r12
80004c96:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004c98:	f0 1f 00 06 	mcall	80004cb0 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004c9c:	5c d6       	com	r6
80004c9e:	f9 e6 00 06 	and	r6,r12,r6
80004ca2:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004ca6:	0e 9c       	mov	r12,r7
80004ca8:	f0 1f 00 03 	mcall	80004cb4 <ClearBitMask+0x24>
	
}
80004cac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	4c 0c       	lddpc	r12,80004db0 <rc522_init+0x78>
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	4b 54       	lddpc	r4,80004d88 <rc522_init+0x50>

80004cb8 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004cb8:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004cba:	30 3b       	mov	r11,3
80004cbc:	31 4c       	mov	r12,20
80004cbe:	f0 1f 00 02 	mcall	80004cc4 <PcdAntennaOff+0xc>
}
80004cc2:	d8 02       	popm	pc
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	4c 90       	lddpc	r0,80004de8 <rc522_init+0xb0>

80004cc8 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004cc8:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004cca:	34 18       	mov	r8,65
80004ccc:	f0 0c 18 00 	cp.b	r12,r8
80004cd0:	c0 20       	breq	80004cd4 <M500PcdConfigISOType+0xc>
80004cd2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004cd4:	30 8b       	mov	r11,8
80004cd6:	16 9c       	mov	r12,r11
80004cd8:	f0 1f 00 14 	mcall	80004d28 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004cdc:	33 db       	mov	r11,61
80004cde:	31 1c       	mov	r12,17
80004ce0:	f0 1f 00 13 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004ce4:	e0 6b 00 86 	mov	r11,134
80004ce8:	31 7c       	mov	r12,23
80004cea:	f0 1f 00 11 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004cee:	37 fb       	mov	r11,127
80004cf0:	32 6c       	mov	r12,38
80004cf2:	f0 1f 00 0f 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004cf6:	31 eb       	mov	r11,30
80004cf8:	32 dc       	mov	r12,45
80004cfa:	f0 1f 00 0d 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004cfe:	30 0b       	mov	r11,0
80004d00:	32 cc       	mov	r12,44
80004d02:	f0 1f 00 0b 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004d06:	e0 6b 00 8d 	mov	r11,141
80004d0a:	32 ac       	mov	r12,42
80004d0c:	f0 1f 00 08 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004d10:	33 eb       	mov	r11,62
80004d12:	32 bc       	mov	r12,43
80004d14:	f0 1f 00 06 	mcall	80004d2c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004d18:	e0 6c 03 e8 	mov	r12,1000
80004d1c:	f0 1f 00 05 	mcall	80004d30 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004d20:	f0 1f 00 05 	mcall	80004d34 <M500PcdConfigISOType+0x6c>
80004d24:	d8 0a       	popm	pc,r12=0
80004d26:	00 00       	add	r0,r0
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	4c 90       	lddpc	r0,80004e4c <PcdComMF522+0x44>
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	4b 54       	lddpc	r4,80004e00 <rc522_init+0xc8>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4a 28       	lddpc	r8,80004db8 <rc522_init+0x80>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	4c 70       	lddpc	r0,80004e50 <PcdComMF522+0x48>

80004d38 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004d38:	eb cd 40 c0 	pushm	r6-r7,lr
80004d3c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004d3e:	4a 28       	lddpc	r8,80004dc4 <rc522_init+0x8c>
80004d40:	1a 96       	mov	r6,sp
80004d42:	f0 ea 00 00 	ld.d	r10,r8[0]
80004d46:	fa eb 00 00 	st.d	sp[0],r10
80004d4a:	f0 e8 00 08 	ld.d	r8,r8[8]
80004d4e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004d52:	30 4b       	mov	r11,4
80004d54:	49 dc       	lddpc	r12,80004dc8 <rc522_init+0x90>
80004d56:	f0 1f 00 1e 	mcall	80004dcc <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004d5a:	31 9c       	mov	r12,25
80004d5c:	f0 1f 00 1d 	mcall	80004dd0 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004d60:	31 9c       	mov	r12,25
80004d62:	f0 1f 00 1d 	mcall	80004dd4 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004d66:	49 d7       	lddpc	r7,80004dd8 <rc522_init+0xa0>
80004d68:	fe 7c 24 00 	mov	r12,-56320
80004d6c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004d6e:	1a 9b       	mov	r11,sp
80004d70:	f0 1f 00 1b 	mcall	80004ddc <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004d74:	30 09       	mov	r9,0
80004d76:	12 9a       	mov	r10,r9
80004d78:	12 9b       	mov	r11,r9
80004d7a:	6e 0c       	ld.w	r12,r7[0x0]
80004d7c:	f0 1f 00 19 	mcall	80004de0 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004d80:	6e 0c       	ld.w	r12,r7[0x0]
80004d82:	f0 1f 00 19 	mcall	80004de4 <rc522_init+0xac>

	// Initialize RC522 with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004d86:	e0 6a 36 00 	mov	r10,13824
80004d8a:	ea 1a 01 6e 	orh	r10,0x16e
80004d8e:	1a 9b       	mov	r11,sp
80004d90:	6e 0c       	ld.w	r12,r7[0x0]
80004d92:	f0 1f 00 16 	mcall	80004de8 <rc522_init+0xb0>
80004d96:	c0 50       	breq	80004da0 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004d98:	30 29       	mov	r9,2
80004d9a:	49 58       	lddpc	r8,80004dec <rc522_init+0xb4>
80004d9c:	b0 89       	st.b	r8[0x0],r9
80004d9e:	c0 38       	rjmp	80004da4 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004da0:	f0 1f 00 14 	mcall	80004df0 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004da4:	f0 1f 00 14 	mcall	80004df4 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004da8:	f0 1f 00 14 	mcall	80004df8 <rc522_init+0xc0>
	
	delay_ms(2); 
80004dac:	30 2c       	mov	r12,2
80004dae:	f0 1f 00 14 	mcall	80004dfc <rc522_init+0xc4>
	
	PcdAntennaOn();
80004db2:	f0 1f 00 14 	mcall	80004e00 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004db6:	34 1c       	mov	r12,65
80004db8:	f0 1f 00 13 	mcall	80004e04 <rc522_init+0xcc>
	

80004dbc:	2f cd       	sub	sp,-16
80004dbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dc2:	00 00       	add	r0,r0
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	d5 70       	acall	0x57
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	d5 84       	*unknown*
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	54 bc       	stdsp	sp[0x12c],r12
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	54 ec       	stdsp	sp[0x138],r12
80004dd4:	80 00       	ld.sh	r0,r0[0x0]
80004dd6:	55 04       	stdsp	sp[0x140],r4
80004dd8:	00 00       	add	r0,r0
80004dda:	1d a0       	ld.ub	r0,lr[0x2]
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	56 6c       	stdsp	sp[0x198],r12
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	56 a4       	stdsp	sp[0x1a8],r4
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	56 d0       	stdsp	sp[0x1b4],r0
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	57 14       	stdsp	sp[0x1c4],r4
80004dec:	00 00       	add	r0,r0
80004dee:	0b 60       	ld.uh	r0,--r5
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4a b4       	lddpc	r4,80004e9c <PcdComMF522+0x94>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4b 8c       	lddpc	r12,80004ed4 <PcdComMF522+0xcc>
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	4c b8       	lddpc	r8,80004f24 <PcdComMF522+0x11c>
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4a 68       	lddpc	r8,80004e94 <PcdComMF522+0x8c>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	4c 70       	lddpc	r0,80004f1c <PcdComMF522+0x114>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	4c c8       	lddpc	r8,80004f34 <PcdComMF522+0x12c>

80004e08 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004e08:	d4 31       	pushm	r0-r7,lr
80004e0a:	20 1d       	sub	sp,4
80004e0c:	18 92       	mov	r2,r12
80004e0e:	16 95       	mov	r5,r11
80004e10:	14 96       	mov	r6,r10
80004e12:	50 09       	stdsp	sp[0x0],r9
80004e14:	10 90       	mov	r0,r8
80004e16:	f8 c8 00 0c 	sub	r8,r12,12
80004e1a:	5c 58       	castu.b	r8
80004e1c:	30 29       	mov	r9,2
80004e1e:	f2 08 18 00 	cp.b	r8,r9
80004e22:	e0 88 00 05 	brls	80004e2c <PcdComMF522+0x24>
80004e26:	30 03       	mov	r3,0
80004e28:	06 91       	mov	r1,r3
80004e2a:	c0 78       	rjmp	80004e38 <PcdComMF522+0x30>
80004e2c:	4c f9       	lddpc	r9,80004f68 <PcdComMF522+0x160>
80004e2e:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004e32:	4c f9       	lddpc	r9,80004f6c <PcdComMF522+0x164>
80004e34:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004e38:	02 9b       	mov	r11,r1
80004e3a:	a7 bb       	sbr	r11,0x7
80004e3c:	30 2c       	mov	r12,2
80004e3e:	f0 1f 00 4d 	mcall	80004f70 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004e42:	e0 6b 00 80 	mov	r11,128
80004e46:	30 4c       	mov	r12,4
80004e48:	f0 1f 00 4b 	mcall	80004f74 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e4c:	30 0b       	mov	r11,0
80004e4e:	30 1c       	mov	r12,1
80004e50:	f0 1f 00 48 	mcall	80004f70 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004e54:	e0 6b 00 80 	mov	r11,128
80004e58:	30 ac       	mov	r12,10
80004e5a:	f0 1f 00 48 	mcall	80004f78 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004e5e:	58 06       	cp.w	r6,0
80004e60:	c0 c0       	breq	80004e78 <PcdComMF522+0x70>
80004e62:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004e64:	30 94       	mov	r4,9
80004e66:	0f 3b       	ld.ub	r11,r7++
80004e68:	08 9c       	mov	r12,r4
80004e6a:	f0 1f 00 42 	mcall	80004f70 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004e6e:	0e 98       	mov	r8,r7
80004e70:	0a 18       	sub	r8,r5
80004e72:	ec 08 19 00 	cp.h	r8,r6
80004e76:	cf 83       	brcs	80004e66 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004e78:	04 9b       	mov	r11,r2
80004e7a:	30 1c       	mov	r12,1
80004e7c:	f0 1f 00 3d 	mcall	80004f70 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004e80:	30 c8       	mov	r8,12
80004e82:	f0 02 18 00 	cp.b	r2,r8
80004e86:	c0 61       	brne	80004e92 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004e88:	e0 6b 00 80 	mov	r11,128
80004e8c:	30 dc       	mov	r12,13
80004e8e:	f0 1f 00 3b 	mcall	80004f78 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004e92:	30 4c       	mov	r12,4
80004e94:	f0 1f 00 3a 	mcall	80004f7c <PcdComMF522+0x174>
80004e98:	18 97       	mov	r7,r12
80004e9a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004e9e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ea0:	30 44       	mov	r4,4
80004ea2:	c0 88       	rjmp	80004eb2 <PcdComMF522+0xaa>
80004ea4:	08 9c       	mov	r12,r4
80004ea6:	f0 1f 00 36 	mcall	80004f7c <PcdComMF522+0x174>
80004eaa:	18 97       	mov	r7,r12
		i--;
80004eac:	20 16       	sub	r6,1
80004eae:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004eb0:	c0 a0       	breq	80004ec4 <PcdComMF522+0xbc>
80004eb2:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004eb6:	c4 c1       	brne	80004f4e <PcdComMF522+0x146>
80004eb8:	ef e3 00 08 	and	r8,r7,r3
80004ebc:	ea 08 18 00 	cp.b	r8,r5
80004ec0:	cf 20       	breq	80004ea4 <PcdComMF522+0x9c>
80004ec2:	c4 68       	rjmp	80004f4e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ec4:	e0 6b 00 80 	mov	r11,128
80004ec8:	30 dc       	mov	r12,13
80004eca:	f0 1f 00 2b 	mcall	80004f74 <PcdComMF522+0x16c>
80004ece:	30 27       	mov	r7,2
80004ed0:	c3 38       	rjmp	80004f36 <PcdComMF522+0x12e>
80004ed2:	02 67       	and	r7,r1
80004ed4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ed8:	30 c8       	mov	r8,12
80004eda:	f0 02 18 00 	cp.b	r2,r8
80004ede:	c2 c1       	brne	80004f36 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ee0:	30 ac       	mov	r12,10
80004ee2:	f0 1f 00 27 	mcall	80004f7c <PcdComMF522+0x174>
80004ee6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004ee8:	30 cc       	mov	r12,12
80004eea:	f0 1f 00 25 	mcall	80004f7c <PcdComMF522+0x174>
80004eee:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004ef2:	c0 70       	breq	80004f00 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004ef4:	08 98       	mov	r8,r4
80004ef6:	20 18       	sub	r8,1
80004ef8:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004efc:	a0 8c       	st.b	r0[0x0],r12
80004efe:	c0 48       	rjmp	80004f06 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004f00:	e8 08 15 03 	lsl	r8,r4,0x3
80004f04:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004f06:	58 04       	cp.w	r4,0
80004f08:	c0 61       	brne	80004f14 <PcdComMF522+0x10c>
80004f0a:	30 14       	mov	r4,1
80004f0c:	40 05       	lddsp	r5,sp[0x0]
80004f0e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004f10:	30 93       	mov	r3,9
80004f12:	c0 98       	rjmp	80004f24 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004f14:	31 28       	mov	r8,18
80004f16:	f0 04 18 00 	cp.b	r4,r8
80004f1a:	f9 b4 0b 12 	movhi	r4,18
80004f1e:	58 04       	cp.w	r4,0
80004f20:	cf 61       	brne	80004f0c <PcdComMF522+0x104>
80004f22:	c0 a8       	rjmp	80004f36 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004f24:	06 9c       	mov	r12,r3
80004f26:	f0 1f 00 16 	mcall	80004f7c <PcdComMF522+0x174>
80004f2a:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004f2c:	ec 05 01 08 	sub	r8,r6,r5
80004f30:	e8 08 19 00 	cp.h	r8,r4
80004f34:	cf 83       	brcs	80004f24 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004f36:	e0 6b 00 80 	mov	r11,128
80004f3a:	30 cc       	mov	r12,12
80004f3c:	f0 1f 00 0f 	mcall	80004f78 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004f40:	30 0b       	mov	r11,0
80004f42:	30 1c       	mov	r12,1
80004f44:	f0 1f 00 0b 	mcall	80004f70 <PcdComMF522+0x168>
	return status;
}
80004f48:	0e 9c       	mov	r12,r7
80004f4a:	2f fd       	sub	sp,-4
80004f4c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004f4e:	e0 6b 00 80 	mov	r11,128
80004f52:	30 dc       	mov	r12,13
80004f54:	f0 1f 00 08 	mcall	80004f74 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004f58:	30 6c       	mov	r12,6
80004f5a:	f0 1f 00 09 	mcall	80004f7c <PcdComMF522+0x174>
80004f5e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004f62:	cb 80       	breq	80004ed2 <PcdComMF522+0xca>
80004f64:	30 27       	mov	r7,2
80004f66:	ce 8b       	rjmp	80004f36 <PcdComMF522+0x12e>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	d5 80       	acall	0x58
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	d5 6c       	*unknown*
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	4b 54       	lddpc	r4,80005044 <PcdRequest+0x40>
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	4c 90       	lddpc	r0,80005098 <CalulateCRC+0x30>
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4c 4c       	lddpc	r12,80005088 <CalulateCRC+0x20>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4c 0c       	lddpc	r12,8000507c <CalulateCRC+0x14>

80004f80 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004f80:	eb cd 40 c0 	pushm	r6-r7,lr
80004f84:	20 5d       	sub	sp,20
80004f86:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004f88:	30 8b       	mov	r11,8
80004f8a:	16 9c       	mov	r12,r11
80004f8c:	f0 1f 00 1a 	mcall	80004ff4 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004f90:	30 0b       	mov	r11,0
80004f92:	30 dc       	mov	r12,13
80004f94:	f0 1f 00 19 	mcall	80004ff8 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004f98:	e0 6b 00 80 	mov	r11,128
80004f9c:	30 ec       	mov	r12,14
80004f9e:	f0 1f 00 16 	mcall	80004ff4 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004fa2:	39 38       	mov	r8,-109
80004fa4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004fa6:	32 08       	mov	r8,32
80004fa8:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004faa:	1a 9b       	mov	r11,sp
80004fac:	fa c8 ff ed 	sub	r8,sp,-19
80004fb0:	1a 99       	mov	r9,sp
80004fb2:	30 2a       	mov	r10,2
80004fb4:	30 cc       	mov	r12,12
80004fb6:	f0 1f 00 12 	mcall	80004ffc <PcdAnticoll+0x7c>
80004fba:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004fbc:	c1 21       	brne	80004fe0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004fbe:	1b 89       	ld.ub	r9,sp[0x0]
80004fc0:	ac 89       	st.b	r6[0x0],r9
80004fc2:	1b 98       	ld.ub	r8,sp[0x1]
80004fc4:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004fc6:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004fc8:	1b a8       	ld.ub	r8,sp[0x2]
80004fca:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004fcc:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004fd0:	1b b9       	ld.ub	r9,sp[0x3]
80004fd2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004fd4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004fd6:	1b c9       	ld.ub	r9,sp[0x4]
80004fd8:	f0 09 18 00 	cp.b	r9,r8
80004fdc:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004fe0:	e0 6b 00 80 	mov	r11,128
80004fe4:	30 ec       	mov	r12,14
80004fe6:	f0 1f 00 07 	mcall	80005000 <PcdAnticoll+0x80>
	return status;
}
80004fea:	0e 9c       	mov	r12,r7
80004fec:	2f bd       	sub	sp,-20
80004fee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ff2:	00 00       	add	r0,r0
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4c 90       	lddpc	r0,80005118 <PcdSelect+0x24>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	4b 54       	lddpc	r4,800050cc <CalulateCRC+0x64>
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	4e 08       	lddpc	r8,8000517c <rfid_auto_reader+0x14>
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	4c 4c       	lddpc	r12,80005110 <PcdSelect+0x1c>

80005004 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005004:	eb cd 40 c0 	pushm	r6-r7,lr
80005008:	20 5d       	sub	sp,20
8000500a:	18 97       	mov	r7,r12
8000500c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
8000500e:	30 8b       	mov	r11,8
80005010:	16 9c       	mov	r12,r11
80005012:	f0 1f 00 12 	mcall	80005058 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80005016:	30 7b       	mov	r11,7
80005018:	30 dc       	mov	r12,13
8000501a:	f0 1f 00 11 	mcall	8000505c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
8000501e:	30 3b       	mov	r11,3
80005020:	31 4c       	mov	r12,20
80005022:	f0 1f 00 10 	mcall	80005060 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80005026:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80005028:	1a 9b       	mov	r11,sp
8000502a:	fa c8 ff ed 	sub	r8,sp,-19
8000502e:	1a 99       	mov	r9,sp
80005030:	30 1a       	mov	r10,1
80005032:	30 cc       	mov	r12,12
80005034:	f0 1f 00 0c 	mcall	80005064 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80005038:	c0 c1       	brne	80005050 <PcdRequest+0x4c>
8000503a:	31 08       	mov	r8,16
8000503c:	fb 39 00 13 	ld.ub	r9,sp[19]
80005040:	f0 09 18 00 	cp.b	r9,r8
80005044:	c0 61       	brne	80005050 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80005046:	1b 88       	ld.ub	r8,sp[0x0]
80005048:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000504a:	1b 98       	ld.ub	r8,sp[0x1]
8000504c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
8000504e:	c0 28       	rjmp	80005052 <PcdRequest+0x4e>
80005050:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80005052:	2f bd       	sub	sp,-20
80005054:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	4c 90       	lddpc	r0,8000517c <rfid_auto_reader+0x14>
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	4b 54       	lddpc	r4,80005130 <PcdSelect+0x3c>
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	4c 4c       	lddpc	r12,80005170 <rfid_auto_reader+0x8>
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	4e 08       	lddpc	r8,800051e4 <rfid_auto_reader+0x7c>

80005068 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80005068:	eb cd 40 f8 	pushm	r3-r7,lr
8000506c:	18 95       	mov	r5,r12
8000506e:	16 96       	mov	r6,r11
80005070:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005072:	30 4b       	mov	r11,4
80005074:	30 5c       	mov	r12,5
80005076:	f0 1f 00 1c 	mcall	800050e4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000507a:	30 0b       	mov	r11,0
8000507c:	30 1c       	mov	r12,1
8000507e:	f0 1f 00 1b 	mcall	800050e8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005082:	e0 6b 00 80 	mov	r11,128
80005086:	30 ac       	mov	r12,10
80005088:	f0 1f 00 19 	mcall	800050ec <CalulateCRC+0x84>
	for (i=0; i<len; i++)
8000508c:	58 06       	cp.w	r6,0
8000508e:	c0 c0       	breq	800050a6 <CalulateCRC+0x3e>
80005090:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80005092:	30 94       	mov	r4,9
80005094:	0f 3b       	ld.ub	r11,r7++
80005096:	08 9c       	mov	r12,r4
80005098:	f0 1f 00 14 	mcall	800050e8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
8000509c:	0e 98       	mov	r8,r7
8000509e:	0a 18       	sub	r8,r5
800050a0:	ec 08 18 00 	cp.b	r8,r6
800050a4:	cf 83       	brcs	80005094 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800050a6:	30 3b       	mov	r11,3
800050a8:	30 1c       	mov	r12,1
800050aa:	f0 1f 00 10 	mcall	800050e8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800050ae:	30 5c       	mov	r12,5
800050b0:	f0 1f 00 10 	mcall	800050f0 <CalulateCRC+0x88>
800050b4:	e0 67 00 fe 	mov	r7,254
800050b8:	30 56       	mov	r6,5
800050ba:	c0 78       	rjmp	800050c8 <CalulateCRC+0x60>
800050bc:	0c 9c       	mov	r12,r6
800050be:	f0 1f 00 0d 	mcall	800050f0 <CalulateCRC+0x88>
		i--;
800050c2:	20 17       	sub	r7,1
800050c4:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800050c6:	c0 40       	breq	800050ce <CalulateCRC+0x66>
800050c8:	e2 1c 00 04 	andl	r12,0x4,COH
800050cc:	cf 80       	breq	800050bc <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800050ce:	32 2c       	mov	r12,34
800050d0:	f0 1f 00 08 	mcall	800050f0 <CalulateCRC+0x88>
800050d4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800050d6:	32 1c       	mov	r12,33
800050d8:	f0 1f 00 06 	mcall	800050f0 <CalulateCRC+0x88>
800050dc:	a6 9c       	st.b	r3[0x1],r12
}
800050de:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800050e2:	00 00       	add	r0,r0
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	4c 90       	lddpc	r0,80005208 <rfid_auto_reader+0xa0>
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4b 54       	lddpc	r4,800051bc <rfid_auto_reader+0x54>
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4c 4c       	lddpc	r12,800051fc <rfid_auto_reader+0x94>
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	4c 0c       	lddpc	r12,800051f0 <rfid_auto_reader+0x88>

800050f4 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
800050f4:	eb cd 40 80 	pushm	r7,lr
800050f8:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800050fa:	39 38       	mov	r8,-109
800050fc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
800050fe:	37 08       	mov	r8,112
80005100:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005102:	30 08       	mov	r8,0
80005104:	ba e8       	st.b	sp[0x6],r8
80005106:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000510a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000510e:	19 89       	ld.ub	r9,r12[0x0]
80005110:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005112:	19 3a       	ld.ub	r10,r12++
80005114:	1b e9       	ld.ub	r9,sp[0x6]
80005116:	f5 e9 20 09 	eor	r9,r10,r9
8000511a:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
8000511c:	16 38       	cp.w	r8,r11
8000511e:	cf 81       	brne	8000510e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005120:	1a 97       	mov	r7,sp
80005122:	fa ca ff f9 	sub	r10,sp,-7
80005126:	30 7b       	mov	r11,7
80005128:	1a 9c       	mov	r12,sp
8000512a:	f0 1f 00 0d 	mcall	8000515c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
8000512e:	30 8b       	mov	r11,8
80005130:	16 9c       	mov	r12,r11
80005132:	f0 1f 00 0c 	mcall	80005160 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80005136:	fa c8 ff ed 	sub	r8,sp,-19
8000513a:	1a 99       	mov	r9,sp
8000513c:	30 9a       	mov	r10,9
8000513e:	1a 9b       	mov	r11,sp
80005140:	30 cc       	mov	r12,12
80005142:	f0 1f 00 09 	mcall	80005164 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80005146:	c0 71       	brne	80005154 <PcdSelect+0x60>
80005148:	31 88       	mov	r8,24
8000514a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000514e:	f0 09 18 00 	cp.b	r9,r8
80005152:	c0 20       	breq	80005156 <PcdSelect+0x62>
80005154:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80005156:	2f bd       	sub	sp,-20
80005158:	e3 cd 80 80 	ldm	sp++,r7,pc
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	50 68       	stdsp	sp[0x18],r8
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	4c 90       	lddpc	r0,80005284 <rfid_sendID_message+0xc>
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	4e 08       	lddpc	r8,800052e4 <rfid_sendID_message+0x6c>

80005168 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005168:	eb cd 40 80 	pushm	r7,lr
8000516c:	18 97       	mov	r7,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000516e:	f0 1f 00 34 	mcall	8000523c <rfid_auto_reader+0xd4>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005172:	4b 4b       	lddpc	r11,80005240 <rfid_auto_reader+0xd8>
80005174:	35 2c       	mov	r12,82
80005176:	f0 1f 00 34 	mcall	80005244 <rfid_auto_reader+0xdc>
	if(status!=MI_OK) return;//continue;
8000517a:	c5 e1       	brne	80005236 <rfid_auto_reader+0xce>
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000517c:	4b 18       	lddpc	r8,80005240 <rfid_auto_reader+0xd8>
8000517e:	11 88       	ld.ub	r8,r8[0x0]
80005180:	30 49       	mov	r9,4
80005182:	f2 08 18 00 	cp.b	r8,r9
80005186:	c0 b1       	brne	8000519c <rfid_auto_reader+0x34>
80005188:	4a e9       	lddpc	r9,80005240 <rfid_auto_reader+0xd8>
8000518a:	13 9a       	ld.ub	r10,r9[0x1]
8000518c:	30 09       	mov	r9,0
8000518e:	f2 0a 18 00 	cp.b	r10,r9
80005192:	c0 51       	brne	8000519c <rfid_auto_reader+0x34>
		log("MFOne-S50\n");
80005194:	4a dc       	lddpc	r12,80005248 <rfid_auto_reader+0xe0>
80005196:	f0 1f 00 2e 	mcall	8000524c <rfid_auto_reader+0xe4>
	PcdReset();
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return;//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000519a:	c3 c8       	rjmp	80005212 <rfid_auto_reader+0xaa>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000519c:	30 29       	mov	r9,2
8000519e:	f2 08 18 00 	cp.b	r8,r9
800051a2:	c0 b1       	brne	800051b8 <rfid_auto_reader+0x50>
800051a4:	4a 79       	lddpc	r9,80005240 <rfid_auto_reader+0xd8>
800051a6:	13 9a       	ld.ub	r10,r9[0x1]
800051a8:	30 09       	mov	r9,0
800051aa:	f2 0a 18 00 	cp.b	r10,r9
800051ae:	c0 51       	brne	800051b8 <rfid_auto_reader+0x50>
		log("MFOne-S70\n");
800051b0:	4a 8c       	lddpc	r12,80005250 <rfid_auto_reader+0xe8>
800051b2:	f0 1f 00 27 	mcall	8000524c <rfid_auto_reader+0xe4>
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return;//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800051b6:	c2 e8       	rjmp	80005212 <rfid_auto_reader+0xaa>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800051b8:	34 49       	mov	r9,68
800051ba:	f2 08 18 00 	cp.b	r8,r9
800051be:	c0 b1       	brne	800051d4 <rfid_auto_reader+0x6c>
800051c0:	4a 09       	lddpc	r9,80005240 <rfid_auto_reader+0xd8>
800051c2:	13 9a       	ld.ub	r10,r9[0x1]
800051c4:	30 09       	mov	r9,0
800051c6:	f2 0a 18 00 	cp.b	r10,r9
800051ca:	c0 51       	brne	800051d4 <rfid_auto_reader+0x6c>
		log("MF-UltraLight\n");
800051cc:	4a 2c       	lddpc	r12,80005254 <rfid_auto_reader+0xec>
800051ce:	f0 1f 00 20 	mcall	8000524c <rfid_auto_reader+0xe4>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800051d2:	c2 08       	rjmp	80005212 <rfid_auto_reader+0xaa>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800051d4:	30 89       	mov	r9,8
800051d6:	f2 08 18 00 	cp.b	r8,r9
800051da:	c0 b1       	brne	800051f0 <rfid_auto_reader+0x88>
800051dc:	49 99       	lddpc	r9,80005240 <rfid_auto_reader+0xd8>
800051de:	13 9a       	ld.ub	r10,r9[0x1]
800051e0:	30 09       	mov	r9,0
800051e2:	f2 0a 18 00 	cp.b	r10,r9
800051e6:	c0 51       	brne	800051f0 <rfid_auto_reader+0x88>
		log("MF-Pro\n");
800051e8:	49 cc       	lddpc	r12,80005258 <rfid_auto_reader+0xf0>
800051ea:	f0 1f 00 19 	mcall	8000524c <rfid_auto_reader+0xe4>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800051ee:	c1 28       	rjmp	80005212 <rfid_auto_reader+0xaa>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800051f0:	34 49       	mov	r9,68
800051f2:	f2 08 18 00 	cp.b	r8,r9
800051f6:	c0 b1       	brne	8000520c <rfid_auto_reader+0xa4>
800051f8:	49 28       	lddpc	r8,80005240 <rfid_auto_reader+0xd8>
800051fa:	11 99       	ld.ub	r9,r8[0x1]
800051fc:	30 38       	mov	r8,3
800051fe:	f0 09 18 00 	cp.b	r9,r8
80005202:	c0 51       	brne	8000520c <rfid_auto_reader+0xa4>
		log("MF Desire\n");
80005204:	49 6c       	lddpc	r12,8000525c <rfid_auto_reader+0xf4>
80005206:	f0 1f 00 12 	mcall	8000524c <rfid_auto_reader+0xe4>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000520a:	c0 48       	rjmp	80005212 <rfid_auto_reader+0xaa>
		log("MF Desire\n");
	else
		log("Unknown\n");
8000520c:	49 5c       	lddpc	r12,80005260 <rfid_auto_reader+0xf8>
8000520e:	f0 1f 00 10 	mcall	8000524c <rfid_auto_reader+0xe4>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005212:	49 5c       	lddpc	r12,80005264 <rfid_auto_reader+0xfc>
80005214:	f0 1f 00 15 	mcall	80005268 <rfid_auto_reader+0x100>
	if(status!=MI_OK)return;//continue;
80005218:	c0 f1       	brne	80005236 <rfid_auto_reader+0xce>
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
8000521a:	49 3c       	lddpc	r12,80005264 <rfid_auto_reader+0xfc>
8000521c:	f0 1f 00 14 	mcall	8000526c <rfid_auto_reader+0x104>
	if(status!=MI_OK)return;//continue;
80005220:	c0 b1       	brne	80005236 <rfid_auto_reader+0xce>
	else{//℃
			
		memcpy(card_id, SN, 4);
80005222:	30 4a       	mov	r10,4
80005224:	49 0b       	lddpc	r11,80005264 <rfid_auto_reader+0xfc>
80005226:	0e 9c       	mov	r12,r7
80005228:	f0 1f 00 12 	mcall	80005270 <rfid_auto_reader+0x108>
		log("select okay\n");
8000522c:	49 2c       	lddpc	r12,80005274 <rfid_auto_reader+0x10c>
8000522e:	f0 1f 00 08 	mcall	8000524c <rfid_auto_reader+0xe4>
		return status;	
	}
	
//}
	
}
80005232:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005236:	e3 cd 80 80 	ldm	sp++,r7,pc
8000523a:	00 00       	add	r0,r0
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	4b 8c       	lddpc	r12,8000531c <rfid_sendID_message+0xa4>
80005240:	00 00       	add	r0,r0
80005242:	0d 98       	ld.ub	r8,r6[0x1]
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	50 04       	stdsp	sp[0x0],r4
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	d5 a4       	*unknown*
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	6d 78       	ld.w	r8,r6[0x5c]
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	d5 b0       	acall	0x5b
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	d5 bc       	*unknown*
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	d5 cc       	*unknown*
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	d5 d4       	*unknown*
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	d5 e0       	acall	0x5e
80005264:	00 00       	add	r0,r0
80005266:	0d 9c       	ld.ub	r12,r6[0x1]
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	4f 80       	lddpc	r0,80005448 <local_start_timer+0x18>
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	50 f4       	stdsp	sp[0x3c],r4
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	76 0c       	ld.w	r12,r11[0x0]
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	d5 ec       	*unknown*

80005278 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80005278:	eb cd 40 e0 	pushm	r5-r7,lr
8000527c:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
8000527e:	fa ca ff a4 	sub	r10,sp,-92
80005282:	30 08       	mov	r8,0
80005284:	30 09       	mov	r9,0
80005286:	f4 e9 00 00 	st.d	r10[0],r8
8000528a:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
8000528e:	fa cc ff 94 	sub	r12,sp,-108
80005292:	f8 e9 00 00 	st.d	r12[0],r8
80005296:	30 0a       	mov	r10,0
80005298:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
8000529a:	fa e9 00 0c 	st.d	sp[12],r8
8000529e:	fa e9 00 14 	st.d	sp[20],r8
800052a2:	fa e9 00 1c 	st.d	sp[28],r8
800052a6:	fa e9 00 24 	st.d	sp[36],r8
800052aa:	fa e9 00 2c 	st.d	sp[44],r8
800052ae:	fa e9 00 34 	st.d	sp[52],r8
800052b2:	fa e9 00 3c 	st.d	sp[60],r8
800052b6:	fa e9 00 44 	st.d	sp[68],r8
800052ba:	fa e9 00 4c 	st.d	sp[76],r8
800052be:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
800052c2:	f0 1f 00 3c 	mcall	800053b0 <rfid_sendID_message+0x138>
800052c6:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800052c8:	c6 d1       	brne	800053a2 <rfid_sendID_message+0x12a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800052ca:	fb 38 00 6f 	ld.ub	r8,sp[111]
800052ce:	1a d8       	st.w	--sp,r8
800052d0:	fb 38 00 72 	ld.ub	r8,sp[114]
800052d4:	1a d8       	st.w	--sp,r8
800052d6:	fb 38 00 75 	ld.ub	r8,sp[117]
800052da:	1a d8       	st.w	--sp,r8
800052dc:	fb 38 00 78 	ld.ub	r8,sp[120]
800052e0:	1a d8       	st.w	--sp,r8
800052e2:	4b 5c       	lddpc	r12,800053b4 <rfid_sendID_message+0x13c>
800052e4:	f0 1f 00 35 	mcall	800053b8 <rfid_sendID_message+0x140>
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
800052e8:	33 7c       	mov	r12,55
800052ea:	f0 1f 00 35 	mcall	800053bc <rfid_sendID_message+0x144>
800052ee:	fa c9 ff 84 	sub	r9,sp,-124
800052f2:	fa c8 ff 94 	sub	r8,sp,-108
800052f6:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
800052fa:	fa c5 ff 80 	sub	r5,sp,-128
800052fe:	2f cd       	sub	sp,-16
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80005300:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80005302:	30 06       	mov	r6,0
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005304:	13 8b       	ld.ub	r11,r9[0x0]
80005306:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
8000530a:	fc 0c 18 00 	cp.b	r12,lr
8000530e:	f7 bc 08 d0 	subls	r12,-48
80005312:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80005316:	f7 bc 0b a9 	subhi	r12,-87
8000531a:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
8000531e:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005320:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80005324:	fc 0b 18 00 	cp.b	r11,lr
80005328:	f7 bb 08 d0 	subls	r11,-48
8000532c:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80005330:	f7 bb 0b a9 	subhi	r11,-87
80005334:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80005338:	b0 b6       	st.b	r8[0x3],r6
8000533a:	2f f9       	sub	r9,-1
8000533c:	2f c8       	sub	r8,-4
8000533e:	2f ca       	sub	r10,-4
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005340:	0a 39       	cp.w	r9,r5
80005342:	ce 11       	brne	80005304 <rfid_sendID_message+0x8c>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80005344:	49 f8       	lddpc	r8,800053c0 <rfid_sendID_message+0x148>
80005346:	11 89       	ld.ub	r9,r8[0x0]
80005348:	39 f8       	mov	r8,-97
8000534a:	f0 09 18 00 	cp.b	r9,r8
8000534e:	e0 88 00 05 	brls	80005358 <rfid_sendID_message+0xe0>
80005352:	38 09       	mov	r9,-128
80005354:	49 b8       	lddpc	r8,800053c0 <rfid_sendID_message+0x148>
80005356:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005358:	49 a8       	lddpc	r8,800053c0 <rfid_sendID_message+0x148>
8000535a:	11 86       	ld.ub	r6,r8[0x0]
8000535c:	2f f6       	sub	r6,-1
8000535e:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005360:	30 5a       	mov	r10,5
80005362:	49 9b       	lddpc	r11,800053c4 <rfid_sendID_message+0x14c>
80005364:	fa cc ff f9 	sub	r12,sp,-7
80005368:	f0 1f 00 18 	mcall	800053c8 <rfid_sendID_message+0x150>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000536c:	31 88       	mov	r8,24
8000536e:	ba 18       	st.h	sp[0x2],r8
80005370:	ba e6       	st.b	sp[0x6],r6
80005372:	fe 78 e0 00 	mov	r8,-8192
80005376:	ba 28       	st.h	sp[0x4],r8
80005378:	fa c6 ff f4 	sub	r6,sp,-12
8000537c:	30 aa       	mov	r10,10
8000537e:	fa cb ff fe 	sub	r11,sp,-2
80005382:	0c 9c       	mov	r12,r6
80005384:	f0 1f 00 11 	mcall	800053c8 <rfid_sendID_message+0x150>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80005388:	31 0a       	mov	r10,16
8000538a:	fa cb ff a4 	sub	r11,sp,-92
8000538e:	fa cc ff ea 	sub	r12,sp,-22
80005392:	f0 1f 00 0e 	mcall	800053c8 <rfid_sendID_message+0x150>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80005396:	30 9a       	mov	r10,9
80005398:	31 ab       	mov	r11,26
8000539a:	0c 9c       	mov	r12,r6
8000539c:	f0 1f 00 0c 	mcall	800053cc <rfid_sendID_message+0x154>
800053a0:	c0 48       	rjmp	800053a8 <rfid_sendID_message+0x130>
		
	}
	else
	{
		log("no card find...\n");
800053a2:	48 cc       	lddpc	r12,800053d0 <rfid_sendID_message+0x158>
800053a4:	f0 1f 00 05 	mcall	800053b8 <rfid_sendID_message+0x140>
	}
	
	return return_err;
	
}
800053a8:	0e 9c       	mov	r12,r7
800053aa:	2e 2d       	sub	sp,-120
800053ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	51 68       	stdsp	sp[0x58],r8
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	d5 fc       	*unknown*
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	6d 78       	ld.w	r8,r6[0x5c]
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	42 4c       	lddsp	r12,sp[0x90]
800053c0:	00 00       	add	r0,r0
800053c2:	05 2c       	ld.uh	r12,r2++
800053c4:	00 00       	add	r0,r0
800053c6:	05 24       	ld.uh	r4,r2++
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	76 0c       	ld.w	r12,r11[0x0]
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	41 14       	lddsp	r4,sp[0x44]
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	d6 18       	*unknown*

800053d4 <rfid_init>:
#include "RFID.h"
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
800053d4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800053d6:	f0 1f 00 02 	mcall	800053dc <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
800053da:	d8 02       	popm	pc
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	4d 38       	lddpc	r8,80005528 <gpio_clr_gpio_pin+0x8>

800053e0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800053e0:	fe 78 0c 00 	mov	r8,-62464
800053e4:	e0 69 03 07 	mov	r9,775
800053e8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800053ea:	30 49       	mov	r9,4
800053ec:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800053ee:	71 59       	ld.w	r9,r8[0x54]
800053f0:	e2 19 00 80 	andl	r9,0x80,COH
800053f4:	cf d0       	breq	800053ee <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800053f6:	fe 78 0c 00 	mov	r8,-62464
800053fa:	30 59       	mov	r9,5
800053fc:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800053fe:	e0 69 01 0d 	mov	r9,269
80005402:	ea 19 10 07 	orh	r9,0x1007
80005406:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005408:	71 59       	ld.w	r9,r8[0x54]
8000540a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000540e:	cf d0       	breq	80005408 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005410:	fe 78 0c 00 	mov	r8,-62464
80005414:	fc 19 00 80 	movh	r9,0x80
80005418:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000541a:	34 0a       	mov	r10,64
8000541c:	fe 69 14 00 	mov	r9,-125952
80005420:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80005422:	30 69       	mov	r9,6
80005424:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005426:	30 19       	mov	r9,1
80005428:	fe 68 10 00 	mov	r8,-126976
8000542c:	91 19       	st.w	r8[0x4],r9
}
8000542e:	5e fc       	retal	r12

80005430 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005430:	fe 78 10 00 	mov	r8,-61440
80005434:	fc 19 00 10 	movh	r9,0x10
80005438:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000543a:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
8000543c:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000543e:	30 39       	mov	r9,3
80005440:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005444:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005448:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
8000544c:	fe 78 38 00 	mov	r8,-51200
80005450:	30 49       	mov	r9,4
80005452:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80005456:	e0 69 91 0d 	mov	r9,37133
8000545a:	ea 19 00 52 	orh	r9,0x52
8000545e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005460:	32 09       	mov	r9,32
80005462:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005464:	30 59       	mov	r9,5
80005466:	91 09       	st.w	r8[0x0],r9
}
80005468:	5e fc       	retal	r12

8000546a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000546a:	f8 08 16 05 	lsr	r8,r12,0x5
8000546e:	a9 68       	lsl	r8,0x8
80005470:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005474:	58 1b       	cp.w	r11,1
80005476:	c0 d0       	breq	80005490 <gpio_enable_module_pin+0x26>
80005478:	c0 63       	brcs	80005484 <gpio_enable_module_pin+0x1a>
8000547a:	58 2b       	cp.w	r11,2
8000547c:	c1 00       	breq	8000549c <gpio_enable_module_pin+0x32>
8000547e:	58 3b       	cp.w	r11,3
80005480:	c1 40       	breq	800054a8 <gpio_enable_module_pin+0x3e>
80005482:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005484:	30 19       	mov	r9,1
80005486:	f2 0c 09 49 	lsl	r9,r9,r12
8000548a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000548c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000548e:	c1 28       	rjmp	800054b2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005490:	30 19       	mov	r9,1
80005492:	f2 0c 09 49 	lsl	r9,r9,r12
80005496:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005498:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000549a:	c0 c8       	rjmp	800054b2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000549c:	30 19       	mov	r9,1
8000549e:	f2 0c 09 49 	lsl	r9,r9,r12
800054a2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054a4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054a6:	c0 68       	rjmp	800054b2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054a8:	30 19       	mov	r9,1
800054aa:	f2 0c 09 49 	lsl	r9,r9,r12
800054ae:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054b0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800054b2:	30 19       	mov	r9,1
800054b4:	f2 0c 09 4c 	lsl	r12,r9,r12
800054b8:	91 2c       	st.w	r8[0x8],r12
800054ba:	5e fd       	retal	0

800054bc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800054bc:	d4 21       	pushm	r4-r7,lr
800054be:	18 97       	mov	r7,r12
800054c0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054c2:	58 0b       	cp.w	r11,0
800054c4:	c0 31       	brne	800054ca <gpio_enable_module+0xe>
800054c6:	30 05       	mov	r5,0
800054c8:	c0 d8       	rjmp	800054e2 <gpio_enable_module+0x26>
800054ca:	30 06       	mov	r6,0
800054cc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800054ce:	6e 1b       	ld.w	r11,r7[0x4]
800054d0:	6e 0c       	ld.w	r12,r7[0x0]
800054d2:	f0 1f 00 06 	mcall	800054e8 <gpio_enable_module+0x2c>
800054d6:	18 45       	or	r5,r12
		gpiomap++;
800054d8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054da:	2f f6       	sub	r6,-1
800054dc:	0c 34       	cp.w	r4,r6
800054de:	fe 9b ff f8 	brhi	800054ce <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800054e2:	0a 9c       	mov	r12,r5
800054e4:	d8 22       	popm	r4-r7,pc
800054e6:	00 00       	add	r0,r0
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 6a       	stdsp	sp[0x118],r10

800054ec <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054ec:	f8 08 16 05 	lsr	r8,r12,0x5
800054f0:	a9 68       	lsl	r8,0x8
800054f2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800054f6:	30 19       	mov	r9,1
800054f8:	f2 0c 09 4c 	lsl	r12,r9,r12
800054fc:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005500:	91 1c       	st.w	r8[0x4],r12
}
80005502:	5e fc       	retal	r12

80005504 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005504:	f8 08 16 05 	lsr	r8,r12,0x5
80005508:	a9 68       	lsl	r8,0x8
8000550a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000550e:	30 19       	mov	r9,1
80005510:	f2 0c 09 4c 	lsl	r12,r9,r12
80005514:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005518:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000551c:	91 1c       	st.w	r8[0x4],r12
}
8000551e:	5e fc       	retal	r12

80005520 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005520:	f8 08 16 05 	lsr	r8,r12,0x5
80005524:	a9 68       	lsl	r8,0x8
80005526:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000552a:	30 19       	mov	r9,1
8000552c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005530:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005534:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005538:	91 1c       	st.w	r8[0x4],r12
}
8000553a:	5e fc       	retal	r12

8000553c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000553c:	c0 08       	rjmp	8000553c <_unhandled_interrupt>
8000553e:	d7 03       	nop

80005540 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005540:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005544:	49 99       	lddpc	r9,800055a8 <INTC_register_interrupt+0x68>
80005546:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000554a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000554e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005550:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005554:	58 0a       	cp.w	r10,0
80005556:	c0 91       	brne	80005568 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005558:	49 59       	lddpc	r9,800055ac <INTC_register_interrupt+0x6c>
8000555a:	49 6a       	lddpc	r10,800055b0 <INTC_register_interrupt+0x70>
8000555c:	12 1a       	sub	r10,r9
8000555e:	fe 79 08 00 	mov	r9,-63488
80005562:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005566:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005568:	58 1a       	cp.w	r10,1
8000556a:	c0 a1       	brne	8000557e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000556c:	49 09       	lddpc	r9,800055ac <INTC_register_interrupt+0x6c>
8000556e:	49 2a       	lddpc	r10,800055b4 <INTC_register_interrupt+0x74>
80005570:	12 1a       	sub	r10,r9
80005572:	bf aa       	sbr	r10,0x1e
80005574:	fe 79 08 00 	mov	r9,-63488
80005578:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000557c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000557e:	58 2a       	cp.w	r10,2
80005580:	c0 a1       	brne	80005594 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005582:	48 b9       	lddpc	r9,800055ac <INTC_register_interrupt+0x6c>
80005584:	48 da       	lddpc	r10,800055b8 <INTC_register_interrupt+0x78>
80005586:	12 1a       	sub	r10,r9
80005588:	bf ba       	sbr	r10,0x1f
8000558a:	fe 79 08 00 	mov	r9,-63488
8000558e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005592:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005594:	48 69       	lddpc	r9,800055ac <INTC_register_interrupt+0x6c>
80005596:	48 aa       	lddpc	r10,800055bc <INTC_register_interrupt+0x7c>
80005598:	12 1a       	sub	r10,r9
8000559a:	ea 1a c0 00 	orh	r10,0xc000
8000559e:	fe 79 08 00 	mov	r9,-63488
800055a2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055a6:	5e fc       	retal	r12
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	d6 2c       	*unknown*
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	cc 00       	breq	8000552e <gpio_clr_gpio_pin+0xe>
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	cd 04       	brge	80005552 <INTC_register_interrupt+0x12>
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	cd 12       	brcc	80005558 <INTC_register_interrupt+0x18>
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	cd 20       	breq	8000555e <INTC_register_interrupt+0x1e>
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	cd 2e       	rcall	80005362 <rfid_sendID_message+0xea>

800055c0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800055c0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055c2:	49 18       	lddpc	r8,80005604 <INTC_init_interrupts+0x44>
800055c4:	e3 b8 00 01 	mtsr	0x4,r8
800055c8:	49 0e       	lddpc	lr,80005608 <INTC_init_interrupts+0x48>
800055ca:	30 07       	mov	r7,0
800055cc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055ce:	49 0c       	lddpc	r12,8000560c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055d0:	49 05       	lddpc	r5,80005610 <INTC_init_interrupts+0x50>
800055d2:	10 15       	sub	r5,r8
800055d4:	fe 76 08 00 	mov	r6,-63488
800055d8:	c1 08       	rjmp	800055f8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055da:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800055dc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055de:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055e0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800055e4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055e6:	10 3a       	cp.w	r10,r8
800055e8:	fe 9b ff fc 	brhi	800055e0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055ec:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800055f0:	2f f7       	sub	r7,-1
800055f2:	2f 8e       	sub	lr,-8
800055f4:	59 37       	cp.w	r7,19
800055f6:	c0 50       	breq	80005600 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055f8:	7c 08       	ld.w	r8,lr[0x0]
800055fa:	58 08       	cp.w	r8,0
800055fc:	ce f1       	brne	800055da <INTC_init_interrupts+0x1a>
800055fe:	cf 7b       	rjmp	800055ec <INTC_init_interrupts+0x2c>
80005600:	d8 22       	popm	r4-r7,pc
80005602:	00 00       	add	r0,r0
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	cc 00       	breq	80005586 <INTC_register_interrupt+0x46>
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	d6 2c       	*unknown*
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	55 3c       	stdsp	sp[0x14c],r12
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	cd 04       	brge	800055b2 <INTC_register_interrupt+0x72>

80005614 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005614:	fe 78 08 00 	mov	r8,-63488
80005618:	e0 69 00 83 	mov	r9,131
8000561c:	f2 0c 01 0c 	sub	r12,r9,r12
80005620:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005624:	f2 ca ff c0 	sub	r10,r9,-64
80005628:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000562c:	58 08       	cp.w	r8,0
8000562e:	c0 21       	brne	80005632 <_get_interrupt_handler+0x1e>
80005630:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005632:	f0 08 12 00 	clz	r8,r8
80005636:	48 5a       	lddpc	r10,80005648 <_get_interrupt_handler+0x34>
80005638:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000563c:	f0 08 11 1f 	rsub	r8,r8,31
80005640:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005642:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005646:	5e fc       	retal	r12
80005648:	80 00       	ld.sh	r0,r0[0x0]
8000564a:	d6 2c       	*unknown*

8000564c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000564c:	f8 c8 00 01 	sub	r8,r12,1
80005650:	f0 0b 00 0b 	add	r11,r8,r11
80005654:	f6 0c 0d 0a 	divu	r10,r11,r12
80005658:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000565a:	f4 c8 00 01 	sub	r8,r10,1
8000565e:	e0 48 00 fe 	cp.w	r8,254
80005662:	e0 88 00 03 	brls	80005668 <getBaudDiv+0x1c>
80005666:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005668:	5c 8c       	casts.h	r12
}
8000566a:	5e fc       	retal	r12

8000566c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000566c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005670:	30 18       	mov	r8,1
80005672:	f0 09 18 00 	cp.b	r9,r8
80005676:	e0 88 00 04 	brls	8000567e <spi_initMaster+0x12>
8000567a:	30 2c       	mov	r12,2
8000567c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000567e:	e0 68 00 80 	mov	r8,128
80005682:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005684:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005686:	30 19       	mov	r9,1
80005688:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000568c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005690:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005694:	30 09       	mov	r9,0
80005696:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000569a:	30 fa       	mov	r10,15
8000569c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800056a0:	99 18       	st.w	r12[0x4],r8
800056a2:	5e f9       	retal	r9

800056a4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800056a4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800056a6:	30 18       	mov	r8,1
800056a8:	f0 0b 18 00 	cp.b	r11,r8
800056ac:	5f be       	srhi	lr
800056ae:	f0 0a 18 00 	cp.b	r10,r8
800056b2:	5f b8       	srhi	r8
800056b4:	fd e8 10 08 	or	r8,lr,r8
800056b8:	c0 30       	breq	800056be <spi_selectionMode+0x1a>
800056ba:	30 2c       	mov	r12,2
800056bc:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800056be:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800056c0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800056c4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800056c8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800056cc:	99 18       	st.w	r12[0x4],r8
800056ce:	d8 0a       	popm	pc,r12=0

800056d0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800056d0:	30 18       	mov	r8,1
800056d2:	99 08       	st.w	r12[0x0],r8
}
800056d4:	5e fc       	retal	r12

800056d6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800056d6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056da:	c0 58       	rjmp	800056e4 <spi_write+0xe>
		if (!timeout--) {
800056dc:	58 08       	cp.w	r8,0
800056de:	c0 21       	brne	800056e2 <spi_write+0xc>
800056e0:	5e ff       	retal	1
800056e2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056e4:	78 49       	ld.w	r9,r12[0x10]
800056e6:	e2 19 00 02 	andl	r9,0x2,COH
800056ea:	cf 90       	breq	800056dc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800056ec:	5c 7b       	castu.h	r11
800056ee:	99 3b       	st.w	r12[0xc],r11
800056f0:	5e fd       	retal	0

800056f2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800056f2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800056f6:	c0 58       	rjmp	80005700 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800056f8:	58 08       	cp.w	r8,0
800056fa:	c0 21       	brne	800056fe <spi_read+0xc>
800056fc:	5e ff       	retal	1
800056fe:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005700:	78 49       	ld.w	r9,r12[0x10]
80005702:	e2 19 02 01 	andl	r9,0x201,COH
80005706:	e0 49 02 01 	cp.w	r9,513
8000570a:	cf 71       	brne	800056f8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000570c:	78 28       	ld.w	r8,r12[0x8]
8000570e:	b6 08       	st.h	r11[0x0],r8
80005710:	5e fd       	retal	0
80005712:	d7 03       	nop

80005714 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005714:	eb cd 40 f8 	pushm	r3-r7,lr
80005718:	18 95       	mov	r5,r12
8000571a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000571c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005720:	30 38       	mov	r8,3
80005722:	f0 06 18 00 	cp.b	r6,r8
80005726:	e0 8b 00 5e 	brhi	800057e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000572a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000572e:	30 18       	mov	r8,1
80005730:	f0 04 18 00 	cp.b	r4,r8
80005734:	e0 8b 00 57 	brhi	800057e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005738:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000573c:	30 78       	mov	r8,7
8000573e:	f0 03 18 00 	cp.b	r3,r8
80005742:	e0 88 00 50 	brls	800057e2 <spi_setupChipReg+0xce>
80005746:	31 08       	mov	r8,16
80005748:	f0 03 18 00 	cp.b	r3,r8
8000574c:	e0 8b 00 4b 	brhi	800057e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005750:	14 9b       	mov	r11,r10
80005752:	6e 1c       	ld.w	r12,r7[0x4]
80005754:	f0 1f 00 26 	mcall	800057ec <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005758:	c4 55       	brlt	800057e2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000575a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000575c:	ec 09 16 01 	lsr	r9,r6,0x1
80005760:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005764:	ec 16 00 01 	eorl	r6,0x1
80005768:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000576c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005770:	20 83       	sub	r3,8
80005772:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005776:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000577a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000577e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005782:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005786:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000578a:	0f 89       	ld.ub	r9,r7[0x0]
8000578c:	30 1a       	mov	r10,1
8000578e:	f4 09 18 00 	cp.b	r9,r10
80005792:	c0 d0       	breq	800057ac <spi_setupChipReg+0x98>
80005794:	c0 a3       	brcs	800057a8 <spi_setupChipReg+0x94>
80005796:	30 2a       	mov	r10,2
80005798:	f4 09 18 00 	cp.b	r9,r10
8000579c:	c0 a0       	breq	800057b0 <spi_setupChipReg+0x9c>
8000579e:	30 3a       	mov	r10,3
800057a0:	f4 09 18 00 	cp.b	r9,r10
800057a4:	c1 f1       	brne	800057e2 <spi_setupChipReg+0xce>
800057a6:	c0 78       	rjmp	800057b4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800057a8:	8b c8       	st.w	r5[0x30],r8
		break;
800057aa:	c0 68       	rjmp	800057b6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800057ac:	8b d8       	st.w	r5[0x34],r8
		break;
800057ae:	c0 48       	rjmp	800057b6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800057b0:	8b e8       	st.w	r5[0x38],r8
		break;
800057b2:	c0 28       	rjmp	800057b6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800057b4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800057b6:	48 f8       	lddpc	r8,800057f0 <spi_setupChipReg+0xdc>
800057b8:	70 08       	ld.w	r8,r8[0x0]
800057ba:	58 08       	cp.w	r8,0
800057bc:	c1 61       	brne	800057e8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800057be:	30 0b       	mov	r11,0
800057c0:	30 1c       	mov	r12,1
800057c2:	f0 1f 00 0d 	mcall	800057f4 <spi_setupChipReg+0xe0>
800057c6:	48 b8       	lddpc	r8,800057f0 <spi_setupChipReg+0xdc>
800057c8:	91 0c       	st.w	r8[0x0],r12
800057ca:	58 0c       	cp.w	r12,0
800057cc:	c0 a0       	breq	800057e0 <spi_setupChipReg+0xcc>
800057ce:	30 09       	mov	r9,0
800057d0:	12 9a       	mov	r10,r9
800057d2:	12 9b       	mov	r11,r9
800057d4:	f0 1f 00 09 	mcall	800057f8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800057d8:	48 68       	lddpc	r8,800057f0 <spi_setupChipReg+0xdc>
800057da:	70 08       	ld.w	r8,r8[0x0]
800057dc:	58 08       	cp.w	r8,0
800057de:	c0 51       	brne	800057e8 <spi_setupChipReg+0xd4>
800057e0:	c0 08       	rjmp	800057e0 <spi_setupChipReg+0xcc>
800057e2:	30 2c       	mov	r12,2
800057e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800057e8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	56 4c       	stdsp	sp[0x190],r12
800057f0:	00 00       	add	r0,r0
800057f2:	51 18       	stdsp	sp[0x44],r8
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	62 e0       	ld.w	r0,r1[0x38]
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	61 e0       	ld.w	r0,r0[0x78]

800057fc <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057fc:	d4 01       	pushm	lr
800057fe:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005802:	c0 58       	rjmp	8000580c <spi_unselectChip+0x10>
		if (!timeout--) {
80005804:	58 08       	cp.w	r8,0
80005806:	c0 21       	brne	8000580a <spi_unselectChip+0xe>
80005808:	da 0a       	popm	pc,r12=1
8000580a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000580c:	78 49       	ld.w	r9,r12[0x10]
8000580e:	e2 19 02 00 	andl	r9,0x200,COH
80005812:	cf 90       	breq	80005804 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005814:	78 18       	ld.w	r8,r12[0x4]
80005816:	ea 18 00 0f 	orh	r8,0xf
8000581a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000581c:	fc 18 01 00 	movh	r8,0x100
80005820:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005822:	30 09       	mov	r9,0
80005824:	12 9a       	mov	r10,r9
80005826:	12 9b       	mov	r11,r9
80005828:	48 38       	lddpc	r8,80005834 <spi_unselectChip+0x38>
8000582a:	70 0c       	ld.w	r12,r8[0x0]
8000582c:	f0 1f 00 03 	mcall	80005838 <spi_unselectChip+0x3c>
80005830:	d8 0a       	popm	pc,r12=0
80005832:	00 00       	add	r0,r0
80005834:	00 00       	add	r0,r0
80005836:	51 18       	stdsp	sp[0x44],r8
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	61 e0       	ld.w	r0,r0[0x78]

8000583c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000583c:	eb cd 40 f8 	pushm	r3-r7,lr
80005840:	18 94       	mov	r4,r12
80005842:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005844:	49 a6       	lddpc	r6,800058ac <spi_selectChip+0x70>
80005846:	30 07       	mov	r7,0
80005848:	31 45       	mov	r5,20
8000584a:	0e 99       	mov	r9,r7
8000584c:	0a 9a       	mov	r10,r5
8000584e:	0e 9b       	mov	r11,r7
80005850:	6c 0c       	ld.w	r12,r6[0x0]
80005852:	f0 1f 00 18 	mcall	800058b0 <spi_selectChip+0x74>
80005856:	cf a0       	breq	8000584a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005858:	68 18       	ld.w	r8,r4[0x4]
8000585a:	ea 18 00 0f 	orh	r8,0xf
8000585e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005860:	68 18       	ld.w	r8,r4[0x4]
80005862:	e2 18 00 04 	andl	r8,0x4,COH
80005866:	c1 10       	breq	80005888 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005868:	30 e8       	mov	r8,14
8000586a:	f0 03 18 00 	cp.b	r3,r8
8000586e:	e0 8b 00 1c 	brhi	800058a6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005872:	68 19       	ld.w	r9,r4[0x4]
80005874:	e6 08 15 10 	lsl	r8,r3,0x10
80005878:	ea 18 ff f0 	orh	r8,0xfff0
8000587c:	e8 18 ff ff 	orl	r8,0xffff
80005880:	12 68       	and	r8,r9
80005882:	89 18       	st.w	r4[0x4],r8
80005884:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005888:	30 38       	mov	r8,3
8000588a:	f0 03 18 00 	cp.b	r3,r8
8000588e:	e0 8b 00 0c 	brhi	800058a6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005892:	68 19       	ld.w	r9,r4[0x4]
80005894:	2f 03       	sub	r3,-16
80005896:	30 18       	mov	r8,1
80005898:	f0 03 09 48 	lsl	r8,r8,r3
8000589c:	5c d8       	com	r8
8000589e:	12 68       	and	r8,r9
800058a0:	89 18       	st.w	r4[0x4],r8
800058a2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800058a6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800058a8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800058ac:	00 00       	add	r0,r0
800058ae:	51 18       	stdsp	sp[0x44],r8
800058b0:	80 00       	ld.sh	r0,r0[0x0]
800058b2:	5f d4       	srvc	r4

800058b4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800058b4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800058b6:	f6 08 15 04 	lsl	r8,r11,0x4
800058ba:	14 38       	cp.w	r8,r10
800058bc:	f9 b8 08 10 	movls	r8,16
800058c0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800058c4:	f0 0b 02 4b 	mul	r11,r8,r11
800058c8:	f6 09 16 01 	lsr	r9,r11,0x1
800058cc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800058d0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800058d4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800058d8:	f2 cb 00 01 	sub	r11,r9,1
800058dc:	e0 4b ff fe 	cp.w	r11,65534
800058e0:	e0 88 00 03 	brls	800058e6 <usart_set_async_baudrate+0x32>
800058e4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800058e6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800058e8:	e8 6e 00 00 	mov	lr,524288
800058ec:	59 08       	cp.w	r8,16
800058ee:	fc 08 17 10 	movne	r8,lr
800058f2:	f9 b8 00 00 	moveq	r8,0
800058f6:	e4 1b ff f7 	andh	r11,0xfff7
800058fa:	e0 1b fe cf 	andl	r11,0xfecf
800058fe:	16 48       	or	r8,r11
80005900:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005902:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005906:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000590a:	99 89       	st.w	r12[0x20],r9
8000590c:	d8 0a       	popm	pc,r12=0

8000590e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000590e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005910:	e2 18 00 02 	andl	r8,0x2,COH
80005914:	c0 31       	brne	8000591a <usart_write_char+0xc>
80005916:	30 2c       	mov	r12,2
80005918:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000591a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000591e:	99 7b       	st.w	r12[0x1c],r11
80005920:	5e fd       	retal	0
80005922:	d7 03       	nop

80005924 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005924:	eb cd 40 e0 	pushm	r5-r7,lr
80005928:	18 96       	mov	r6,r12
8000592a:	16 95       	mov	r5,r11
8000592c:	e0 67 27 0f 	mov	r7,9999
80005930:	c0 68       	rjmp	8000593c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005932:	58 07       	cp.w	r7,0
80005934:	c0 31       	brne	8000593a <usart_putchar+0x16>
80005936:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000593a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000593c:	0a 9b       	mov	r11,r5
8000593e:	0c 9c       	mov	r12,r6
80005940:	f0 1f 00 03 	mcall	8000594c <usart_putchar+0x28>
80005944:	cf 71       	brne	80005932 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005946:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000594a:	00 00       	add	r0,r0
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	59 0e       	cp.w	lr,16

80005950 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005950:	78 58       	ld.w	r8,r12[0x14]
80005952:	e2 18 00 e0 	andl	r8,0xe0,COH
80005956:	c0 30       	breq	8000595c <usart_read_char+0xc>
80005958:	30 4c       	mov	r12,4
8000595a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000595c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000595e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005962:	c0 31       	brne	80005968 <usart_read_char+0x18>
80005964:	30 3c       	mov	r12,3
80005966:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005968:	78 68       	ld.w	r8,r12[0x18]
8000596a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000596e:	97 08       	st.w	r11[0x0],r8
80005970:	5e fd       	retal	0
80005972:	d7 03       	nop

80005974 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005974:	eb cd 40 c0 	pushm	r6-r7,lr
80005978:	20 1d       	sub	sp,4
8000597a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
8000597c:	1a 97       	mov	r7,sp
8000597e:	1a 9b       	mov	r11,sp
80005980:	0c 9c       	mov	r12,r6
80005982:	f0 1f 00 07 	mcall	8000599c <usart_getchar+0x28>
80005986:	58 3c       	cp.w	r12,3
80005988:	cf b0       	breq	8000597e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000598a:	58 4c       	cp.w	r12,4
8000598c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005990:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005994:	2f fd       	sub	sp,-4
80005996:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000599a:	00 00       	add	r0,r0
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	59 50       	cp.w	r0,21

800059a0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800059a0:	eb cd 40 c0 	pushm	r6-r7,lr
800059a4:	18 96       	mov	r6,r12
800059a6:	16 97       	mov	r7,r11
  while (*string != '\0')
800059a8:	17 8b       	ld.ub	r11,r11[0x0]
800059aa:	58 0b       	cp.w	r11,0
800059ac:	c0 80       	breq	800059bc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800059ae:	2f f7       	sub	r7,-1
800059b0:	0c 9c       	mov	r12,r6
800059b2:	f0 1f 00 04 	mcall	800059c0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800059b6:	0f 8b       	ld.ub	r11,r7[0x0]
800059b8:	58 0b       	cp.w	r11,0
800059ba:	cf a1       	brne	800059ae <usart_write_line+0xe>
800059bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059c0:	80 00       	ld.sh	r0,r0[0x0]
800059c2:	59 24       	cp.w	r4,18

800059c4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800059c4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800059c8:	e6 18 00 01 	andh	r8,0x1,COH
800059cc:	c0 71       	brne	800059da <usart_reset+0x16>
800059ce:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800059d0:	3f f8       	mov	r8,-1
800059d2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800059d4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800059d6:	d5 03       	csrf	0x10
800059d8:	c0 48       	rjmp	800059e0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800059da:	3f f8       	mov	r8,-1
800059dc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800059de:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800059e0:	30 08       	mov	r8,0
800059e2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800059e4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800059e6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800059e8:	ea 68 61 0c 	mov	r8,680204
800059ec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800059ee:	5e fc       	retal	r12

800059f0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800059f0:	eb cd 40 e0 	pushm	r5-r7,lr
800059f4:	18 96       	mov	r6,r12
800059f6:	16 97       	mov	r7,r11
800059f8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800059fa:	f0 1f 00 2f 	mcall	80005ab4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800059fe:	58 07       	cp.w	r7,0
80005a00:	c5 80       	breq	80005ab0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a02:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a04:	30 49       	mov	r9,4
80005a06:	f2 08 18 00 	cp.b	r8,r9
80005a0a:	e0 88 00 53 	brls	80005ab0 <usart_init_rs232+0xc0>
80005a0e:	30 99       	mov	r9,9
80005a10:	f2 08 18 00 	cp.b	r8,r9
80005a14:	e0 8b 00 4e 	brhi	80005ab0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a18:	0f d9       	ld.ub	r9,r7[0x5]
80005a1a:	30 78       	mov	r8,7
80005a1c:	f0 09 18 00 	cp.b	r9,r8
80005a20:	e0 8b 00 48 	brhi	80005ab0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a24:	8e 39       	ld.sh	r9,r7[0x6]
80005a26:	e0 68 01 01 	mov	r8,257
80005a2a:	f0 09 19 00 	cp.h	r9,r8
80005a2e:	e0 8b 00 41 	brhi	80005ab0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a32:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a36:	30 38       	mov	r8,3
80005a38:	f0 09 18 00 	cp.b	r9,r8
80005a3c:	e0 8b 00 3a 	brhi	80005ab0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005a40:	0a 9a       	mov	r10,r5
80005a42:	6e 0b       	ld.w	r11,r7[0x0]
80005a44:	0c 9c       	mov	r12,r6
80005a46:	f0 1f 00 1d 	mcall	80005ab8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a4a:	58 1c       	cp.w	r12,1
80005a4c:	c3 20       	breq	80005ab0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005a4e:	0f c8       	ld.ub	r8,r7[0x4]
80005a50:	30 99       	mov	r9,9
80005a52:	f2 08 18 00 	cp.b	r8,r9
80005a56:	c0 51       	brne	80005a60 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005a58:	6c 18       	ld.w	r8,r6[0x4]
80005a5a:	b1 b8       	sbr	r8,0x11
80005a5c:	8d 18       	st.w	r6[0x4],r8
80005a5e:	c0 68       	rjmp	80005a6a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005a60:	6c 19       	ld.w	r9,r6[0x4]
80005a62:	20 58       	sub	r8,5
80005a64:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005a68:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005a6a:	6c 19       	ld.w	r9,r6[0x4]
80005a6c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005a70:	0f d8       	ld.ub	r8,r7[0x5]
80005a72:	a9 78       	lsl	r8,0x9
80005a74:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005a78:	12 48       	or	r8,r9
80005a7a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005a7c:	8e 38       	ld.sh	r8,r7[0x6]
80005a7e:	30 29       	mov	r9,2
80005a80:	f2 08 19 00 	cp.h	r8,r9
80005a84:	e0 88 00 09 	brls	80005a96 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005a88:	6c 18       	ld.w	r8,r6[0x4]
80005a8a:	ad b8       	sbr	r8,0xd
80005a8c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005a8e:	8e b8       	ld.uh	r8,r7[0x6]
80005a90:	20 28       	sub	r8,2
80005a92:	8d a8       	st.w	r6[0x28],r8
80005a94:	c0 68       	rjmp	80005aa0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005a96:	6c 19       	ld.w	r9,r6[0x4]
80005a98:	5c 78       	castu.h	r8
80005a9a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005a9e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005aa0:	6c 18       	ld.w	r8,r6[0x4]
80005aa2:	e0 18 ff f0 	andl	r8,0xfff0
80005aa6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005aa8:	35 08       	mov	r8,80
80005aaa:	8d 08       	st.w	r6[0x0],r8
80005aac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005ab0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	59 c4       	cp.w	r4,28
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	58 b4       	cp.w	r4,11

80005abc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005abc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005ac0:	fe c0 8e c0 	sub	r0,pc,-28992

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005ac4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005ac8:	d5 53       	csrf	0x15
  cp      r0, r1
80005aca:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005acc:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005ad0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005ad2:	c0 62       	brcc	80005ade <idata_load_loop_end>
  cp      r0, r1
80005ad4:	48 92       	lddpc	r2,80005af8 <udata_clear_loop_end+0x4>

80005ad6 <idata_load_loop>:
  brlo    idata_load_loop
80005ad6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005ad8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005ada:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005adc:	cf d3       	brcs	80005ad6 <idata_load_loop>

80005ade <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005ade:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005ae2:	e0 61 51 28 	mov	r1,20776
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005ae6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005ae8:	c0 62       	brcc	80005af4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005aea:	30 02       	mov	r2,0
80005aec:	30 03       	mov	r3,0

80005aee <udata_clear_loop>:
80005aee:	a1 22       	st.d	r0++,r2
80005af0:	02 30       	cp.w	r0,r1
80005af2:	cf e3       	brcs	80005aee <udata_clear_loop>

80005af4 <udata_clear_loop_end>:
80005af4:	fe cf e9 c4 	sub	pc,pc,-5692
80005af8:	80 00       	ld.sh	r0,r0[0x0]
80005afa:	df 60       	acall	0xf6

80005afc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005afc:	f8 c8 ff f8 	sub	r8,r12,-8
80005b00:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005b02:	3f f9       	mov	r9,-1
80005b04:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b06:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b08:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b0a:	30 08       	mov	r8,0
80005b0c:	99 08       	st.w	r12[0x0],r8
}
80005b0e:	5e fc       	retal	r12

80005b10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b10:	30 08       	mov	r8,0
80005b12:	99 48       	st.w	r12[0x10],r8
}
80005b14:	5e fc       	retal	r12

80005b16 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b16:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b18:	70 19       	ld.w	r9,r8[0x4]
80005b1a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b1c:	78 19       	ld.w	r9,r12[0x4]
80005b1e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b20:	70 19       	ld.w	r9,r8[0x4]
80005b22:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b24:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b26:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b28:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b2a:	78 08       	ld.w	r8,r12[0x0]
80005b2c:	2f f8       	sub	r8,-1
80005b2e:	99 08       	st.w	r12[0x0],r8
}
80005b30:	5e fc       	retal	r12

80005b32 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b32:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b34:	5b fa       	cp.w	r10,-1
80005b36:	c0 31       	brne	80005b3c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005b38:	78 48       	ld.w	r8,r12[0x10]
80005b3a:	c0 c8       	rjmp	80005b52 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005b3c:	f8 c8 ff f8 	sub	r8,r12,-8
80005b40:	70 19       	ld.w	r9,r8[0x4]
80005b42:	72 09       	ld.w	r9,r9[0x0]
80005b44:	12 3a       	cp.w	r10,r9
80005b46:	c0 63       	brcs	80005b52 <vListInsert+0x20>
80005b48:	70 18       	ld.w	r8,r8[0x4]
80005b4a:	70 19       	ld.w	r9,r8[0x4]
80005b4c:	72 09       	ld.w	r9,r9[0x0]
80005b4e:	12 3a       	cp.w	r10,r9
80005b50:	cf c2       	brcc	80005b48 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005b52:	70 19       	ld.w	r9,r8[0x4]
80005b54:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b56:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b58:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b5a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b5c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b5e:	78 08       	ld.w	r8,r12[0x0]
80005b60:	2f f8       	sub	r8,-1
80005b62:	99 08       	st.w	r12[0x0],r8
}
80005b64:	5e fc       	retal	r12

80005b66 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005b66:	78 18       	ld.w	r8,r12[0x4]
80005b68:	78 29       	ld.w	r9,r12[0x8]
80005b6a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005b6c:	78 28       	ld.w	r8,r12[0x8]
80005b6e:	78 19       	ld.w	r9,r12[0x4]
80005b70:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005b72:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005b74:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005b76:	18 39       	cp.w	r9,r12
80005b78:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005b7c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005b80:	30 09       	mov	r9,0
80005b82:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b84:	70 09       	ld.w	r9,r8[0x0]
80005b86:	20 19       	sub	r9,1
80005b88:	91 09       	st.w	r8[0x0],r9
}
80005b8a:	5e fc       	retal	r12

80005b8c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b8c:	e0 68 08 08 	mov	r8,2056
80005b90:	ea 18 08 08 	orh	r8,0x808
80005b94:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b96:	e0 68 09 09 	mov	r8,2313
80005b9a:	ea 18 09 09 	orh	r8,0x909
80005b9e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005ba0:	e0 68 0a 0a 	mov	r8,2570
80005ba4:	ea 18 0a 0a 	orh	r8,0xa0a
80005ba8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005baa:	e0 68 0b 0b 	mov	r8,2827
80005bae:	ea 18 0b 0b 	orh	r8,0xb0b
80005bb2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005bb4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005bb6:	e0 68 be ef 	mov	r8,48879
80005bba:	ea 18 de ad 	orh	r8,0xdead
80005bbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005bc0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005bc2:	fc 18 00 40 	movh	r8,0x40
80005bc6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005bc8:	e0 68 00 ff 	mov	r8,255
80005bcc:	ea 18 ff 00 	orh	r8,0xff00
80005bd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005bd2:	e0 68 01 01 	mov	r8,257
80005bd6:	ea 18 01 01 	orh	r8,0x101
80005bda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005bdc:	e0 68 02 02 	mov	r8,514
80005be0:	ea 18 02 02 	orh	r8,0x202
80005be4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005be6:	e0 68 03 03 	mov	r8,771
80005bea:	ea 18 03 03 	orh	r8,0x303
80005bee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005bf0:	e0 68 04 04 	mov	r8,1028
80005bf4:	ea 18 04 04 	orh	r8,0x404
80005bf8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005bfa:	e0 68 05 05 	mov	r8,1285
80005bfe:	ea 18 05 05 	orh	r8,0x505
80005c02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c04:	e0 68 06 06 	mov	r8,1542
80005c08:	ea 18 06 06 	orh	r8,0x606
80005c0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c0e:	e0 68 07 07 	mov	r8,1799
80005c12:	ea 18 07 07 	orh	r8,0x707
80005c16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c18:	30 08       	mov	r8,0
80005c1a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c1c:	5e fc       	retal	r12
80005c1e:	d7 03       	nop

80005c20 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c20:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c22:	48 38       	lddpc	r8,80005c2c <vPortEnterCritical+0xc>
80005c24:	70 09       	ld.w	r9,r8[0x0]
80005c26:	2f f9       	sub	r9,-1
80005c28:	91 09       	st.w	r8[0x0],r9
}
80005c2a:	5e fc       	retal	r12
80005c2c:	00 00       	add	r0,r0
80005c2e:	05 30       	ld.ub	r0,r2++

80005c30 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c30:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c32:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c34:	30 0a       	mov	r10,0
80005c36:	14 9b       	mov	r11,r10
80005c38:	49 2c       	lddpc	r12,80005c80 <xPortStartScheduler+0x50>
80005c3a:	f0 1f 00 13 	mcall	80005c84 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005c3e:	e0 68 5d c0 	mov	r8,24000
80005c42:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005c46:	30 08       	mov	r8,0
80005c48:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005c4c:	e0 68 0c dc 	mov	r8,3292
80005c50:	ea 18 00 00 	orh	r8,0x0
80005c54:	70 00       	ld.w	r0,r8[0x0]
80005c56:	60 0d       	ld.w	sp,r0[0x0]
80005c58:	1b 00       	ld.w	r0,sp++
80005c5a:	e0 68 05 30 	mov	r8,1328
80005c5e:	ea 18 00 00 	orh	r8,0x0
80005c62:	91 00       	st.w	r8[0x0],r0
80005c64:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c68:	2f ed       	sub	sp,-8
80005c6a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005c6e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005c72:	e3 b0 00 00 	mtsr	0x0,r0
80005c76:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005c7a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005c7e:	d8 0a       	popm	pc,r12=0
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	5d 4c       	*unknown*
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	55 40       	stdsp	sp[0x150],r0

80005c88 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c88:	20 6d       	sub	sp,24
80005c8a:	eb cd 00 ff 	pushm	r0-r7
80005c8e:	fa c7 ff c0 	sub	r7,sp,-64
80005c92:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c96:	ef 40 ff e0 	st.w	r7[-32],r0
80005c9a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c9e:	ef 40 ff e4 	st.w	r7[-28],r0
80005ca2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005ca6:	e0 68 05 30 	mov	r8,1328
80005caa:	ea 18 00 00 	orh	r8,0x0
80005cae:	70 00       	ld.w	r0,r8[0x0]
80005cb0:	1a d0       	st.w	--sp,r0
80005cb2:	f0 1f 00 1a 	mcall	80005d18 <LABEL_RET_SCALL_263+0x14>
80005cb6:	e0 68 0c dc 	mov	r8,3292
80005cba:	ea 18 00 00 	orh	r8,0x0
80005cbe:	70 00       	ld.w	r0,r8[0x0]
80005cc0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005cc2:	f0 1f 00 17 	mcall	80005d1c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005cc6:	e0 68 0c dc 	mov	r8,3292
80005cca:	ea 18 00 00 	orh	r8,0x0
80005cce:	70 00       	ld.w	r0,r8[0x0]
80005cd0:	60 0d       	ld.w	sp,r0[0x0]
80005cd2:	1b 00       	ld.w	r0,sp++
80005cd4:	e0 68 05 30 	mov	r8,1328
80005cd8:	ea 18 00 00 	orh	r8,0x0
80005cdc:	91 00       	st.w	r8[0x0],r0
80005cde:	fa c7 ff d8 	sub	r7,sp,-40
80005ce2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005ce6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005cea:	e0 61 05 30 	mov	r1,1328
80005cee:	ea 11 00 00 	orh	r1,0x0
80005cf2:	62 02       	ld.w	r2,r1[0x0]
80005cf4:	58 02       	cp.w	r2,0
80005cf6:	c0 70       	breq	80005d04 <LABEL_RET_SCALL_263>
80005cf8:	e4 c2 00 01 	sub	r2,r2,1
80005cfc:	83 02       	st.w	r1[0x0],r2
80005cfe:	58 02       	cp.w	r2,0
80005d00:	c0 21       	brne	80005d04 <LABEL_RET_SCALL_263>
80005d02:	b1 c0       	cbr	r0,0x10

80005d04 <LABEL_RET_SCALL_263>:
80005d04:	ef 40 ff f8 	st.w	r7[-8],r0
80005d08:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d0c:	ef 40 ff fc 	st.w	r7[-4],r0
80005d10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d14:	2f ad       	sub	sp,-24
80005d16:	d6 13       	rets
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5c 20       	cpc	r0
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	63 64       	ld.w	r4,r1[0x58]

80005d20 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d20:	e1 b8 00 43 	mfsr	r8,0x10c
80005d24:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d28:	5e fc       	retal	r12
80005d2a:	d7 03       	nop

80005d2c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d2c:	48 78       	lddpc	r8,80005d48 <vPortExitCritical+0x1c>
80005d2e:	70 08       	ld.w	r8,r8[0x0]
80005d30:	58 08       	cp.w	r8,0
80005d32:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d34:	48 58       	lddpc	r8,80005d48 <vPortExitCritical+0x1c>
80005d36:	70 09       	ld.w	r9,r8[0x0]
80005d38:	20 19       	sub	r9,1
80005d3a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005d3c:	70 08       	ld.w	r8,r8[0x0]
80005d3e:	58 08       	cp.w	r8,0
80005d40:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005d42:	d5 03       	csrf	0x10
80005d44:	5e fc       	retal	r12
80005d46:	00 00       	add	r0,r0
80005d48:	00 00       	add	r0,r0
80005d4a:	05 30       	ld.ub	r0,r2++

80005d4c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005d4c:	eb cd 00 ff 	pushm	r0-r7
80005d50:	e0 68 05 30 	mov	r8,1328
80005d54:	ea 18 00 00 	orh	r8,0x0
80005d58:	70 00       	ld.w	r0,r8[0x0]
80005d5a:	1a d0       	st.w	--sp,r0
80005d5c:	7a 90       	ld.w	r0,sp[0x24]
80005d5e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d62:	58 10       	cp.w	r0,1
80005d64:	e0 8b 00 08 	brhi	80005d74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005d68:	e0 68 0c dc 	mov	r8,3292
80005d6c:	ea 18 00 00 	orh	r8,0x0
80005d70:	70 00       	ld.w	r0,r8[0x0]
80005d72:	81 0d       	st.w	r0[0x0],sp

80005d74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005d74:	f0 1f 00 12 	mcall	80005dbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005d78:	f0 1f 00 12 	mcall	80005dc0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005d7c:	f0 1f 00 12 	mcall	80005dc4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005d80:	f0 1f 00 12 	mcall	80005dc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d84:	7a 90       	ld.w	r0,sp[0x24]
80005d86:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d8a:	58 10       	cp.w	r0,1
80005d8c:	e0 8b 00 0e 	brhi	80005da8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d90:	f0 1f 00 0c 	mcall	80005dc0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d94:	f0 1f 00 0e 	mcall	80005dcc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d98:	f0 1f 00 0c 	mcall	80005dc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d9c:	e0 68 0c dc 	mov	r8,3292
80005da0:	ea 18 00 00 	orh	r8,0x0
80005da4:	70 00       	ld.w	r0,r8[0x0]
80005da6:	60 0d       	ld.w	sp,r0[0x0]

80005da8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005da8:	1b 00       	ld.w	r0,sp++
80005daa:	e0 68 05 30 	mov	r8,1328
80005dae:	ea 18 00 00 	orh	r8,0x0
80005db2:	91 00       	st.w	r8[0x0],r0
80005db4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005db8:	d6 03       	rete
80005dba:	00 00       	add	r0,r0
80005dbc:	80 00       	ld.sh	r0,r0[0x0]
80005dbe:	5d 20       	mustr	r0
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	5c 20       	cpc	r0
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	65 68       	ld.w	r8,r2[0x58]
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	5d 2c       	mustr	r12
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	63 64       	ld.w	r4,r1[0x58]

80005dd0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005dd0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005dd2:	f0 1f 00 02 	mcall	80005dd8 <__malloc_lock+0x8>
}
80005dd6:	d8 02       	popm	pc
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	63 54       	ld.w	r4,r1[0x54]

80005ddc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005ddc:	d4 01       	pushm	lr
	xTaskResumeAll();
80005dde:	f0 1f 00 02 	mcall	80005de4 <__malloc_unlock+0x8>
}
80005de2:	d8 02       	popm	pc
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	67 10       	ld.w	r0,r3[0x44]

80005de8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005de8:	d4 21       	pushm	r4-r7,lr
80005dea:	16 95       	mov	r5,r11
80005dec:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005dee:	58 0c       	cp.w	r12,0
80005df0:	c0 30       	breq	80005df6 <_read+0xe>
80005df2:	3f f7       	mov	r7,-1
80005df4:	c1 48       	rjmp	80005e1c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005df6:	58 0a       	cp.w	r10,0
80005df8:	e0 89 00 04 	brgt	80005e00 <_read+0x18>
80005dfc:	30 07       	mov	r7,0
80005dfe:	c0 f8       	rjmp	80005e1c <_read+0x34>
80005e00:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005e02:	48 84       	lddpc	r4,80005e20 <_read+0x38>
80005e04:	68 0c       	ld.w	r12,r4[0x0]
80005e06:	f0 1f 00 08 	mcall	80005e24 <_read+0x3c>
    if (c < 0)
80005e0a:	c0 95       	brlt	80005e1c <_read+0x34>
      break;

    *ptr++ = c;
80005e0c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e10:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e12:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e16:	58 08       	cp.w	r8,0
80005e18:	fe 99 ff f6 	brgt	80005e04 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e1c:	0e 9c       	mov	r12,r7
80005e1e:	d8 22       	popm	r4-r7,pc
80005e20:	00 00       	add	r0,r0
80005e22:	51 1c       	stdsp	sp[0x44],r12
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	59 74       	cp.w	r4,23

80005e28 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e28:	d4 21       	pushm	r4-r7,lr
80005e2a:	16 95       	mov	r5,r11
80005e2c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e2e:	20 1c       	sub	r12,1
80005e30:	58 2c       	cp.w	r12,2
80005e32:	e0 8b 00 12 	brhi	80005e56 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e36:	58 0a       	cp.w	r10,0
80005e38:	c0 31       	brne	80005e3e <_write+0x16>
80005e3a:	30 07       	mov	r7,0
80005e3c:	c0 e8       	rjmp	80005e58 <_write+0x30>
80005e3e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005e40:	48 74       	lddpc	r4,80005e5c <_write+0x34>
80005e42:	68 0c       	ld.w	r12,r4[0x0]
80005e44:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005e48:	f0 1f 00 06 	mcall	80005e60 <_write+0x38>
80005e4c:	c0 55       	brlt	80005e56 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005e4e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e50:	0e 36       	cp.w	r6,r7
80005e52:	cf 81       	brne	80005e42 <_write+0x1a>
80005e54:	c0 28       	rjmp	80005e58 <_write+0x30>
80005e56:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e58:	0e 9c       	mov	r12,r7
80005e5a:	d8 22       	popm	r4-r7,pc
80005e5c:	00 00       	add	r0,r0
80005e5e:	51 1c       	stdsp	sp[0x44],r12
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	59 24       	cp.w	r4,18

80005e64 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005e64:	eb cd 40 80 	pushm	r7,lr
80005e68:	18 97       	mov	r7,r12
	if( pv )
80005e6a:	58 0c       	cp.w	r12,0
80005e6c:	c0 80       	breq	80005e7c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005e6e:	f0 1f 00 05 	mcall	80005e80 <vPortFree+0x1c>
		{
			free( pv );
80005e72:	0e 9c       	mov	r12,r7
80005e74:	f0 1f 00 04 	mcall	80005e84 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005e78:	f0 1f 00 04 	mcall	80005e88 <vPortFree+0x24>
80005e7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	63 54       	ld.w	r4,r1[0x54]
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	71 b4       	ld.w	r4,r8[0x6c]
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	67 10       	ld.w	r0,r3[0x44]

80005e8c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e8c:	eb cd 40 80 	pushm	r7,lr
80005e90:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e92:	f0 1f 00 06 	mcall	80005ea8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e96:	0e 9c       	mov	r12,r7
80005e98:	f0 1f 00 05 	mcall	80005eac <pvPortMalloc+0x20>
80005e9c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e9e:	f0 1f 00 05 	mcall	80005eb0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005ea2:	0e 9c       	mov	r12,r7
80005ea4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	63 54       	ld.w	r4,r1[0x54]
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	71 c4       	ld.w	r4,r8[0x70]
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	67 10       	ld.w	r0,r3[0x44]

80005eb4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005eb4:	d4 01       	pushm	lr
80005eb6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005eb8:	78 09       	ld.w	r9,r12[0x0]
80005eba:	58 09       	cp.w	r9,0
80005ebc:	c1 10       	breq	80005ede <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ebe:	78 3a       	ld.w	r10,r12[0xc]
80005ec0:	79 09       	ld.w	r9,r12[0x40]
80005ec2:	f4 09 00 09 	add	r9,r10,r9
80005ec6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005ec8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005eca:	14 39       	cp.w	r9,r10
80005ecc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005ed0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005ed4:	79 0a       	ld.w	r10,r12[0x40]
80005ed6:	78 3b       	ld.w	r11,r12[0xc]
80005ed8:	10 9c       	mov	r12,r8
80005eda:	f0 1f 00 02 	mcall	80005ee0 <prvCopyDataFromQueue+0x2c>
80005ede:	d8 02       	popm	pc
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	76 0c       	ld.w	r12,r11[0x0]

80005ee4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005ee4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ee8:	18 97       	mov	r7,r12
80005eea:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005eec:	78 e8       	ld.w	r8,r12[0x38]
80005eee:	58 08       	cp.w	r8,0
80005ef0:	c0 31       	brne	80005ef6 <xQueueReceiveFromISR+0x12>
80005ef2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ef6:	f0 1f 00 0e 	mcall	80005f2c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005efa:	6e e8       	ld.w	r8,r7[0x38]
80005efc:	20 18       	sub	r8,1
80005efe:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005f00:	6f 18       	ld.w	r8,r7[0x44]
80005f02:	5b f8       	cp.w	r8,-1
80005f04:	c0 d1       	brne	80005f1e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f06:	6e 48       	ld.w	r8,r7[0x10]
80005f08:	58 08       	cp.w	r8,0
80005f0a:	c0 f0       	breq	80005f28 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f0c:	ee cc ff f0 	sub	r12,r7,-16
80005f10:	f0 1f 00 08 	mcall	80005f30 <xQueueReceiveFromISR+0x4c>
80005f14:	c0 a0       	breq	80005f28 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f16:	30 1c       	mov	r12,1
80005f18:	8d 0c       	st.w	r6[0x0],r12
80005f1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f1e:	2f f8       	sub	r8,-1
80005f20:	ef 48 00 44 	st.w	r7[68],r8
80005f24:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f28:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	5e b4       	rethi	r4
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	64 ec       	ld.w	r12,r2[0x38]

80005f34 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f34:	eb cd 40 c0 	pushm	r6-r7,lr
80005f38:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005f3a:	f0 1f 00 23 	mcall	80005fc4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f3e:	6f 28       	ld.w	r8,r7[0x48]
80005f40:	58 08       	cp.w	r8,0
80005f42:	e0 8a 00 18 	brle	80005f72 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f46:	6e 98       	ld.w	r8,r7[0x24]
80005f48:	58 08       	cp.w	r8,0
80005f4a:	c1 40       	breq	80005f72 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f4c:	ee c6 ff dc 	sub	r6,r7,-36
80005f50:	c0 48       	rjmp	80005f58 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f52:	6e 98       	ld.w	r8,r7[0x24]
80005f54:	58 08       	cp.w	r8,0
80005f56:	c0 e0       	breq	80005f72 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f58:	0c 9c       	mov	r12,r6
80005f5a:	f0 1f 00 1c 	mcall	80005fc8 <prvUnlockQueue+0x94>
80005f5e:	c0 30       	breq	80005f64 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f60:	f0 1f 00 1b 	mcall	80005fcc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005f64:	6f 28       	ld.w	r8,r7[0x48]
80005f66:	20 18       	sub	r8,1
80005f68:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f6c:	58 08       	cp.w	r8,0
80005f6e:	fe 99 ff f2 	brgt	80005f52 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005f72:	3f f8       	mov	r8,-1
80005f74:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005f78:	f0 1f 00 16 	mcall	80005fd0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005f7c:	f0 1f 00 12 	mcall	80005fc4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f80:	6f 18       	ld.w	r8,r7[0x44]
80005f82:	58 08       	cp.w	r8,0
80005f84:	e0 8a 00 18 	brle	80005fb4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f88:	6e 48       	ld.w	r8,r7[0x10]
80005f8a:	58 08       	cp.w	r8,0
80005f8c:	c1 40       	breq	80005fb4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f8e:	ee c6 ff f0 	sub	r6,r7,-16
80005f92:	c0 48       	rjmp	80005f9a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f94:	6e 48       	ld.w	r8,r7[0x10]
80005f96:	58 08       	cp.w	r8,0
80005f98:	c0 e0       	breq	80005fb4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f9a:	0c 9c       	mov	r12,r6
80005f9c:	f0 1f 00 0b 	mcall	80005fc8 <prvUnlockQueue+0x94>
80005fa0:	c0 30       	breq	80005fa6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005fa2:	f0 1f 00 0b 	mcall	80005fcc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005fa6:	6f 18       	ld.w	r8,r7[0x44]
80005fa8:	20 18       	sub	r8,1
80005faa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005fae:	58 08       	cp.w	r8,0
80005fb0:	fe 99 ff f2 	brgt	80005f94 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005fb4:	3f f8       	mov	r8,-1
80005fb6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005fba:	f0 1f 00 06 	mcall	80005fd0 <prvUnlockQueue+0x9c>
}
80005fbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fc2:	00 00       	add	r0,r0
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	5c 20       	cpc	r0
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	64 ec       	ld.w	r12,r2[0x38]
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	63 f8       	ld.w	r8,r1[0x7c]
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	5d 2c       	mustr	r12

80005fd4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005fd4:	d4 31       	pushm	r0-r7,lr
80005fd6:	20 5d       	sub	sp,20
80005fd8:	18 97       	mov	r7,r12
80005fda:	50 0b       	stdsp	sp[0x0],r11
80005fdc:	50 2a       	stdsp	sp[0x8],r10
80005fde:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005fe0:	f8 c2 ff dc 	sub	r2,r12,-36
80005fe4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fe6:	fa c4 ff f4 	sub	r4,sp,-12
80005fea:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005fec:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005fee:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005ff2:	f0 1f 00 3e 	mcall	800060e8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ff6:	6e e8       	ld.w	r8,r7[0x38]
80005ff8:	58 08       	cp.w	r8,0
80005ffa:	c2 a0       	breq	8000604e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005ffc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ffe:	40 0b       	lddsp	r11,sp[0x0]
80006000:	0e 9c       	mov	r12,r7
80006002:	f0 1f 00 3b 	mcall	800060ec <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006006:	40 18       	lddsp	r8,sp[0x4]
80006008:	58 08       	cp.w	r8,0
8000600a:	c1 51       	brne	80006034 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000600c:	6e e8       	ld.w	r8,r7[0x38]
8000600e:	20 18       	sub	r8,1
80006010:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006012:	6e 08       	ld.w	r8,r7[0x0]
80006014:	58 08       	cp.w	r8,0
80006016:	c0 41       	brne	8000601e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006018:	f0 1f 00 36 	mcall	800060f0 <xQueueGenericReceive+0x11c>
8000601c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000601e:	6e 48       	ld.w	r8,r7[0x10]
80006020:	58 08       	cp.w	r8,0
80006022:	c1 20       	breq	80006046 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006024:	ee cc ff f0 	sub	r12,r7,-16
80006028:	f0 1f 00 33 	mcall	800060f4 <xQueueGenericReceive+0x120>
8000602c:	58 1c       	cp.w	r12,1
8000602e:	c0 c1       	brne	80006046 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006030:	d7 33       	scall
80006032:	c0 a8       	rjmp	80006046 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006034:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006036:	6e 98       	ld.w	r8,r7[0x24]
80006038:	58 08       	cp.w	r8,0
8000603a:	c0 60       	breq	80006046 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000603c:	04 9c       	mov	r12,r2
8000603e:	f0 1f 00 2e 	mcall	800060f4 <xQueueGenericReceive+0x120>
80006042:	c0 20       	breq	80006046 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006044:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006046:	f0 1f 00 2d 	mcall	800060f8 <xQueueGenericReceive+0x124>
8000604a:	30 1c       	mov	r12,1
				return pdPASS;
8000604c:	c4 c8       	rjmp	800060e4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000604e:	40 28       	lddsp	r8,sp[0x8]
80006050:	58 08       	cp.w	r8,0
80006052:	c0 51       	brne	8000605c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006054:	f0 1f 00 29 	mcall	800060f8 <xQueueGenericReceive+0x124>
80006058:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000605a:	c4 58       	rjmp	800060e4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000605c:	58 05       	cp.w	r5,0
8000605e:	c0 51       	brne	80006068 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006060:	08 9c       	mov	r12,r4
80006062:	f0 1f 00 27 	mcall	800060fc <xQueueGenericReceive+0x128>
80006066:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006068:	f0 1f 00 24 	mcall	800060f8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000606c:	f0 1f 00 25 	mcall	80006100 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006070:	f0 1f 00 1e 	mcall	800060e8 <xQueueGenericReceive+0x114>
80006074:	6f 18       	ld.w	r8,r7[0x44]
80006076:	5b f8       	cp.w	r8,-1
80006078:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000607c:	6f 28       	ld.w	r8,r7[0x48]
8000607e:	5b f8       	cp.w	r8,-1
80006080:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006084:	f0 1f 00 1d 	mcall	800060f8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006088:	06 9b       	mov	r11,r3
8000608a:	08 9c       	mov	r12,r4
8000608c:	f0 1f 00 1e 	mcall	80006104 <xQueueGenericReceive+0x130>
80006090:	c2 41       	brne	800060d8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006092:	f0 1f 00 16 	mcall	800060e8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006096:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006098:	f0 1f 00 18 	mcall	800060f8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000609c:	58 06       	cp.w	r6,0
8000609e:	c1 71       	brne	800060cc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060a0:	6e 08       	ld.w	r8,r7[0x0]
800060a2:	58 08       	cp.w	r8,0
800060a4:	c0 81       	brne	800060b4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800060a6:	f0 1f 00 11 	mcall	800060e8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800060aa:	6e 1c       	ld.w	r12,r7[0x4]
800060ac:	f0 1f 00 17 	mcall	80006108 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800060b0:	f0 1f 00 12 	mcall	800060f8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060b4:	40 2b       	lddsp	r11,sp[0x8]
800060b6:	04 9c       	mov	r12,r2
800060b8:	f0 1f 00 15 	mcall	8000610c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800060bc:	0e 9c       	mov	r12,r7
800060be:	f0 1f 00 15 	mcall	80006110 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800060c2:	f0 1f 00 15 	mcall	80006114 <xQueueGenericReceive+0x140>
800060c6:	c9 61       	brne	80005ff2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800060c8:	d7 33       	scall
800060ca:	c9 4b       	rjmp	80005ff2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800060cc:	0e 9c       	mov	r12,r7
800060ce:	f0 1f 00 11 	mcall	80006110 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800060d2:	f0 1f 00 11 	mcall	80006114 <xQueueGenericReceive+0x140>
800060d6:	c8 eb       	rjmp	80005ff2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800060d8:	0e 9c       	mov	r12,r7
800060da:	f0 1f 00 0e 	mcall	80006110 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800060de:	f0 1f 00 0e 	mcall	80006114 <xQueueGenericReceive+0x140>
800060e2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800060e4:	2f bd       	sub	sp,-20
800060e6:	d8 32       	popm	r0-r7,pc
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	5c 20       	cpc	r0
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	5e b4       	rethi	r4
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	64 04       	ld.w	r4,r2[0x0]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	64 ec       	ld.w	r12,r2[0x38]
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	5d 2c       	mustr	r12
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	63 e0       	ld.w	r0,r1[0x78]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	63 54       	ld.w	r4,r1[0x54]
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	66 7c       	ld.w	r12,r3[0x1c]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	64 68       	ld.w	r8,r2[0x18]
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	68 d4       	ld.w	r4,r4[0x34]
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	5f 34       	srlo	r4
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	67 10       	ld.w	r0,r3[0x44]

80006118 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006118:	eb cd 40 80 	pushm	r7,lr
8000611c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000611e:	79 08       	ld.w	r8,r12[0x40]
80006120:	58 08       	cp.w	r8,0
80006122:	c0 a1       	brne	80006136 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006124:	78 08       	ld.w	r8,r12[0x0]
80006126:	58 08       	cp.w	r8,0
80006128:	c2 b1       	brne	8000617e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000612a:	78 1c       	ld.w	r12,r12[0x4]
8000612c:	f0 1f 00 17 	mcall	80006188 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006130:	30 08       	mov	r8,0
80006132:	8f 18       	st.w	r7[0x4],r8
80006134:	c2 58       	rjmp	8000617e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006136:	58 0a       	cp.w	r10,0
80006138:	c1 01       	brne	80006158 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000613a:	10 9a       	mov	r10,r8
8000613c:	78 2c       	ld.w	r12,r12[0x8]
8000613e:	f0 1f 00 14 	mcall	8000618c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006142:	6e 29       	ld.w	r9,r7[0x8]
80006144:	6f 08       	ld.w	r8,r7[0x40]
80006146:	f2 08 00 08 	add	r8,r9,r8
8000614a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000614c:	6e 19       	ld.w	r9,r7[0x4]
8000614e:	12 38       	cp.w	r8,r9
80006150:	c1 73       	brcs	8000617e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006152:	6e 08       	ld.w	r8,r7[0x0]
80006154:	8f 28       	st.w	r7[0x8],r8
80006156:	c1 48       	rjmp	8000617e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006158:	10 9a       	mov	r10,r8
8000615a:	78 3c       	ld.w	r12,r12[0xc]
8000615c:	f0 1f 00 0c 	mcall	8000618c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006160:	6f 08       	ld.w	r8,r7[0x40]
80006162:	6e 39       	ld.w	r9,r7[0xc]
80006164:	f2 08 01 08 	sub	r8,r9,r8
80006168:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000616a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000616c:	12 38       	cp.w	r8,r9
8000616e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006172:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006176:	f3 d8 e3 19 	subcs	r9,r9,r8
8000617a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000617e:	6e e8       	ld.w	r8,r7[0x38]
80006180:	2f f8       	sub	r8,-1
80006182:	8f e8       	st.w	r7[0x38],r8
}
80006184:	e3 cd 80 80 	ldm	sp++,r7,pc
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	64 10       	ld.w	r0,r2[0x4]
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	76 0c       	ld.w	r12,r11[0x0]

80006190 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006190:	eb cd 40 c0 	pushm	r6-r7,lr
80006194:	18 97       	mov	r7,r12
80006196:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006198:	78 ec       	ld.w	r12,r12[0x38]
8000619a:	6e f8       	ld.w	r8,r7[0x3c]
8000619c:	10 3c       	cp.w	r12,r8
8000619e:	c0 33       	brcs	800061a4 <xQueueGenericSendFromISR+0x14>
800061a0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061a4:	12 9a       	mov	r10,r9
800061a6:	0e 9c       	mov	r12,r7
800061a8:	f0 1f 00 0c 	mcall	800061d8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800061ac:	6f 28       	ld.w	r8,r7[0x48]
800061ae:	5b f8       	cp.w	r8,-1
800061b0:	c0 d1       	brne	800061ca <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061b2:	6e 98       	ld.w	r8,r7[0x24]
800061b4:	58 08       	cp.w	r8,0
800061b6:	c0 f0       	breq	800061d4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061b8:	ee cc ff dc 	sub	r12,r7,-36
800061bc:	f0 1f 00 08 	mcall	800061dc <xQueueGenericSendFromISR+0x4c>
800061c0:	c0 a0       	breq	800061d4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800061c2:	30 1c       	mov	r12,1
800061c4:	8d 0c       	st.w	r6[0x0],r12
800061c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800061ca:	2f f8       	sub	r8,-1
800061cc:	ef 48 00 48 	st.w	r7[72],r8
800061d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061d4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	61 18       	ld.w	r8,r0[0x44]
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	64 ec       	ld.w	r12,r2[0x38]

800061e0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800061e0:	d4 31       	pushm	r0-r7,lr
800061e2:	20 5d       	sub	sp,20
800061e4:	18 97       	mov	r7,r12
800061e6:	50 0b       	stdsp	sp[0x0],r11
800061e8:	50 2a       	stdsp	sp[0x8],r10
800061ea:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061ec:	f8 c0 ff f0 	sub	r0,r12,-16
800061f0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061f2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061f6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061f8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800061fc:	f0 1f 00 2f 	mcall	800062b8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006200:	6e e9       	ld.w	r9,r7[0x38]
80006202:	6e f8       	ld.w	r8,r7[0x3c]
80006204:	10 39       	cp.w	r9,r8
80006206:	c1 42       	brcc	8000622e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006208:	40 1a       	lddsp	r10,sp[0x4]
8000620a:	40 0b       	lddsp	r11,sp[0x0]
8000620c:	0e 9c       	mov	r12,r7
8000620e:	f0 1f 00 2c 	mcall	800062bc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006212:	6e 98       	ld.w	r8,r7[0x24]
80006214:	58 08       	cp.w	r8,0
80006216:	c0 80       	breq	80006226 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006218:	ee cc ff dc 	sub	r12,r7,-36
8000621c:	f0 1f 00 29 	mcall	800062c0 <xQueueGenericSend+0xe0>
80006220:	58 1c       	cp.w	r12,1
80006222:	c0 21       	brne	80006226 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006224:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006226:	f0 1f 00 28 	mcall	800062c4 <xQueueGenericSend+0xe4>
8000622a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000622c:	c4 38       	rjmp	800062b2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000622e:	40 28       	lddsp	r8,sp[0x8]
80006230:	58 08       	cp.w	r8,0
80006232:	c0 51       	brne	8000623c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006234:	f0 1f 00 24 	mcall	800062c4 <xQueueGenericSend+0xe4>
80006238:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000623a:	c3 c8       	rjmp	800062b2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000623c:	58 04       	cp.w	r4,0
8000623e:	c0 51       	brne	80006248 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006240:	06 9c       	mov	r12,r3
80006242:	f0 1f 00 22 	mcall	800062c8 <xQueueGenericSend+0xe8>
80006246:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006248:	f0 1f 00 1f 	mcall	800062c4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000624c:	f0 1f 00 20 	mcall	800062cc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006250:	f0 1f 00 1a 	mcall	800062b8 <xQueueGenericSend+0xd8>
80006254:	6f 18       	ld.w	r8,r7[0x44]
80006256:	5b f8       	cp.w	r8,-1
80006258:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000625c:	6f 28       	ld.w	r8,r7[0x48]
8000625e:	5b f8       	cp.w	r8,-1
80006260:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006264:	f0 1f 00 18 	mcall	800062c4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006268:	04 9b       	mov	r11,r2
8000626a:	06 9c       	mov	r12,r3
8000626c:	f0 1f 00 19 	mcall	800062d0 <xQueueGenericSend+0xf0>
80006270:	c1 b1       	brne	800062a6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006272:	f0 1f 00 12 	mcall	800062b8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006276:	6e e5       	ld.w	r5,r7[0x38]
80006278:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000627a:	f0 1f 00 13 	mcall	800062c4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000627e:	0c 35       	cp.w	r5,r6
80006280:	c0 d1       	brne	8000629a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006282:	40 2b       	lddsp	r11,sp[0x8]
80006284:	00 9c       	mov	r12,r0
80006286:	f0 1f 00 14 	mcall	800062d4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000628a:	0e 9c       	mov	r12,r7
8000628c:	f0 1f 00 13 	mcall	800062d8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006290:	f0 1f 00 13 	mcall	800062dc <xQueueGenericSend+0xfc>
80006294:	cb 41       	brne	800061fc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006296:	d7 33       	scall
80006298:	cb 2b       	rjmp	800061fc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000629a:	0e 9c       	mov	r12,r7
8000629c:	f0 1f 00 0f 	mcall	800062d8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800062a0:	f0 1f 00 0f 	mcall	800062dc <xQueueGenericSend+0xfc>
800062a4:	ca cb       	rjmp	800061fc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800062a6:	0e 9c       	mov	r12,r7
800062a8:	f0 1f 00 0c 	mcall	800062d8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800062ac:	f0 1f 00 0c 	mcall	800062dc <xQueueGenericSend+0xfc>
800062b0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800062b2:	2f bd       	sub	sp,-20
800062b4:	d8 32       	popm	r0-r7,pc
800062b6:	00 00       	add	r0,r0
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	5c 20       	cpc	r0
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	61 18       	ld.w	r8,r0[0x44]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	64 ec       	ld.w	r12,r2[0x38]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	5d 2c       	mustr	r12
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	63 e0       	ld.w	r0,r1[0x78]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	63 54       	ld.w	r4,r1[0x54]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	66 7c       	ld.w	r12,r3[0x1c]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	68 d4       	ld.w	r4,r4[0x34]
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	5f 34       	srlo	r4
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	67 10       	ld.w	r0,r3[0x44]

800062e0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800062e0:	d4 21       	pushm	r4-r7,lr
800062e2:	18 97       	mov	r7,r12
800062e4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800062e6:	58 0c       	cp.w	r12,0
800062e8:	c2 f0       	breq	80006346 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800062ea:	34 cc       	mov	r12,76
800062ec:	f0 1f 00 17 	mcall	80006348 <xQueueCreate+0x68>
800062f0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800062f2:	c2 a0       	breq	80006346 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800062f4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800062f8:	e8 cc ff ff 	sub	r12,r4,-1
800062fc:	f0 1f 00 13 	mcall	80006348 <xQueueCreate+0x68>
80006300:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006302:	c1 e0       	breq	8000633e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006304:	f8 04 00 04 	add	r4,r12,r4
80006308:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000630a:	30 08       	mov	r8,0
8000630c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000630e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006310:	ee c8 00 01 	sub	r8,r7,1
80006314:	ad 38       	mul	r8,r6
80006316:	10 0c       	add	r12,r8
80006318:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000631a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000631c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006320:	3f f8       	mov	r8,-1
80006322:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006326:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000632a:	ea cc ff f0 	sub	r12,r5,-16
8000632e:	f0 1f 00 08 	mcall	8000634c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006332:	ea cc ff dc 	sub	r12,r5,-36
80006336:	f0 1f 00 06 	mcall	8000634c <xQueueCreate+0x6c>
8000633a:	0a 9c       	mov	r12,r5
8000633c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000633e:	0a 9c       	mov	r12,r5
80006340:	f0 1f 00 04 	mcall	80006350 <xQueueCreate+0x70>
80006344:	d8 2a       	popm	r4-r7,pc,r12=0
80006346:	d8 2a       	popm	r4-r7,pc,r12=0
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5e 8c       	retls	r12
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	5a fc       	cp.w	r12,-17
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	5e 64       	retmi	r4

80006354 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006354:	48 38       	lddpc	r8,80006360 <vTaskSuspendAll+0xc>
80006356:	70 09       	ld.w	r9,r8[0x0]
80006358:	2f f9       	sub	r9,-1
8000635a:	91 09       	st.w	r8[0x0],r9
}
8000635c:	5e fc       	retal	r12
8000635e:	00 00       	add	r0,r0
80006360:	00 00       	add	r0,r0
80006362:	0d 0c       	ld.w	r12,r6++

80006364 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006364:	49 a8       	lddpc	r8,800063cc <vTaskSwitchContext+0x68>
80006366:	70 08       	ld.w	r8,r8[0x0]
80006368:	58 08       	cp.w	r8,0
8000636a:	c0 b1       	brne	80006380 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000636c:	49 98       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>
8000636e:	70 08       	ld.w	r8,r8[0x0]
80006370:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006374:	49 89       	lddpc	r9,800063d4 <vTaskSwitchContext+0x70>
80006376:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000637a:	58 08       	cp.w	r8,0
8000637c:	c0 60       	breq	80006388 <vTaskSwitchContext+0x24>
8000637e:	c1 18       	rjmp	800063a0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006380:	30 19       	mov	r9,1
80006382:	49 68       	lddpc	r8,800063d8 <vTaskSwitchContext+0x74>
80006384:	91 09       	st.w	r8[0x0],r9
80006386:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006388:	49 28       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000638a:	49 3a       	lddpc	r10,800063d4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000638c:	70 09       	ld.w	r9,r8[0x0]
8000638e:	20 19       	sub	r9,1
80006390:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006392:	70 09       	ld.w	r9,r8[0x0]
80006394:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006398:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000639c:	58 09       	cp.w	r9,0
8000639e:	cf 70       	breq	8000638c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800063a0:	48 c8       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>
800063a2:	70 08       	ld.w	r8,r8[0x0]
800063a4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063a8:	48 b9       	lddpc	r9,800063d4 <vTaskSwitchContext+0x70>
800063aa:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063ae:	70 19       	ld.w	r9,r8[0x4]
800063b0:	72 19       	ld.w	r9,r9[0x4]
800063b2:	91 19       	st.w	r8[0x4],r9
800063b4:	f0 ca ff f8 	sub	r10,r8,-8
800063b8:	14 39       	cp.w	r9,r10
800063ba:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063be:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063c2:	70 18       	ld.w	r8,r8[0x4]
800063c4:	70 39       	ld.w	r9,r8[0xc]
800063c6:	48 68       	lddpc	r8,800063dc <vTaskSwitchContext+0x78>
800063c8:	91 09       	st.w	r8[0x0],r9
800063ca:	5e fc       	retal	r12
800063cc:	00 00       	add	r0,r0
800063ce:	0d 0c       	ld.w	r12,r6++
800063d0:	00 00       	add	r0,r0
800063d2:	0d 44       	ld.w	r4,--r6
800063d4:	00 00       	add	r0,r0
800063d6:	0c 28       	rsub	r8,r6
800063d8:	00 00       	add	r0,r0
800063da:	0d 2c       	ld.uh	r12,r6++
800063dc:	00 00       	add	r0,r0
800063de:	0c dc       	st.w	--r6,r12

800063e0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800063e0:	48 48       	lddpc	r8,800063f0 <vTaskSetTimeOutState+0x10>
800063e2:	70 08       	ld.w	r8,r8[0x0]
800063e4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800063e6:	48 48       	lddpc	r8,800063f4 <vTaskSetTimeOutState+0x14>
800063e8:	70 08       	ld.w	r8,r8[0x0]
800063ea:	99 18       	st.w	r12[0x4],r8
}
800063ec:	5e fc       	retal	r12
800063ee:	00 00       	add	r0,r0
800063f0:	00 00       	add	r0,r0
800063f2:	0c 20       	rsub	r0,r6
800063f4:	00 00       	add	r0,r0
800063f6:	0d 08       	ld.w	r8,r6++

800063f8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800063f8:	30 19       	mov	r9,1
800063fa:	48 28       	lddpc	r8,80006400 <vTaskMissedYield+0x8>
800063fc:	91 09       	st.w	r8[0x0],r9
}
800063fe:	5e fc       	retal	r12
80006400:	00 00       	add	r0,r0
80006402:	0d 2c       	ld.uh	r12,r6++

80006404 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006404:	48 28       	lddpc	r8,8000640c <xTaskGetCurrentTaskHandle+0x8>
80006406:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006408:	5e fc       	retal	r12
8000640a:	00 00       	add	r0,r0
8000640c:	00 00       	add	r0,r0
8000640e:	0c dc       	st.w	--r6,r12

80006410 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006410:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006414:	58 0c       	cp.w	r12,0
80006416:	c1 f0       	breq	80006454 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006418:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000641a:	78 b9       	ld.w	r9,r12[0x2c]
8000641c:	79 18       	ld.w	r8,r12[0x44]
8000641e:	10 39       	cp.w	r9,r8
80006420:	c1 a0       	breq	80006454 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006422:	f8 c6 ff fc 	sub	r6,r12,-4
80006426:	0c 9c       	mov	r12,r6
80006428:	f0 1f 00 0c 	mcall	80006458 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000642c:	6f 1c       	ld.w	r12,r7[0x44]
8000642e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006430:	f8 08 11 08 	rsub	r8,r12,8
80006434:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006436:	48 a8       	lddpc	r8,8000645c <vTaskPriorityDisinherit+0x4c>
80006438:	70 08       	ld.w	r8,r8[0x0]
8000643a:	10 3c       	cp.w	r12,r8
8000643c:	e0 88 00 04 	brls	80006444 <vTaskPriorityDisinherit+0x34>
80006440:	48 78       	lddpc	r8,8000645c <vTaskPriorityDisinherit+0x4c>
80006442:	91 0c       	st.w	r8[0x0],r12
80006444:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006448:	0c 9b       	mov	r11,r6
8000644a:	48 68       	lddpc	r8,80006460 <vTaskPriorityDisinherit+0x50>
8000644c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006450:	f0 1f 00 05 	mcall	80006464 <vTaskPriorityDisinherit+0x54>
80006454:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	5b 66       	cp.w	r6,-10
8000645c:	00 00       	add	r0,r0
8000645e:	0d 44       	ld.w	r4,--r6
80006460:	00 00       	add	r0,r0
80006462:	0c 28       	rsub	r8,r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	5b 16       	cp.w	r6,-15

80006468 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006468:	eb cd 40 c0 	pushm	r6-r7,lr
8000646c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000646e:	49 b8       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
80006470:	70 08       	ld.w	r8,r8[0x0]
80006472:	78 b9       	ld.w	r9,r12[0x2c]
80006474:	70 b8       	ld.w	r8,r8[0x2c]
80006476:	10 39       	cp.w	r9,r8
80006478:	c2 d2       	brcc	800064d2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000647a:	49 88       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
8000647c:	70 08       	ld.w	r8,r8[0x0]
8000647e:	70 b8       	ld.w	r8,r8[0x2c]
80006480:	f0 08 11 08 	rsub	r8,r8,8
80006484:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006486:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000648a:	49 59       	lddpc	r9,800064dc <vTaskPriorityInherit+0x74>
8000648c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006490:	78 59       	ld.w	r9,r12[0x14]
80006492:	10 39       	cp.w	r9,r8
80006494:	c1 b1       	brne	800064ca <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006496:	f8 c6 ff fc 	sub	r6,r12,-4
8000649a:	0c 9c       	mov	r12,r6
8000649c:	f0 1f 00 11 	mcall	800064e0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064a0:	48 e8       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
800064a2:	70 08       	ld.w	r8,r8[0x0]
800064a4:	70 bc       	ld.w	r12,r8[0x2c]
800064a6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064a8:	48 f8       	lddpc	r8,800064e4 <vTaskPriorityInherit+0x7c>
800064aa:	70 08       	ld.w	r8,r8[0x0]
800064ac:	10 3c       	cp.w	r12,r8
800064ae:	e0 88 00 04 	brls	800064b6 <vTaskPriorityInherit+0x4e>
800064b2:	48 d8       	lddpc	r8,800064e4 <vTaskPriorityInherit+0x7c>
800064b4:	91 0c       	st.w	r8[0x0],r12
800064b6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064ba:	0c 9b       	mov	r11,r6
800064bc:	48 88       	lddpc	r8,800064dc <vTaskPriorityInherit+0x74>
800064be:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064c2:	f0 1f 00 0a 	mcall	800064e8 <vTaskPriorityInherit+0x80>
800064c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064ca:	48 48       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
800064cc:	70 08       	ld.w	r8,r8[0x0]
800064ce:	70 b8       	ld.w	r8,r8[0x2c]
800064d0:	99 b8       	st.w	r12[0x2c],r8
800064d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064d6:	00 00       	add	r0,r0
800064d8:	00 00       	add	r0,r0
800064da:	0c dc       	st.w	--r6,r12
800064dc:	00 00       	add	r0,r0
800064de:	0c 28       	rsub	r8,r6
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	5b 66       	cp.w	r6,-10
800064e4:	00 00       	add	r0,r0
800064e6:	0d 44       	ld.w	r4,--r6
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	5b 16       	cp.w	r6,-15

800064ec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800064ec:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800064f0:	78 38       	ld.w	r8,r12[0xc]
800064f2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800064f4:	ee c6 ff e8 	sub	r6,r7,-24
800064f8:	0c 9c       	mov	r12,r6
800064fa:	f0 1f 00 15 	mcall	8000654c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064fe:	49 58       	lddpc	r8,80006550 <xTaskRemoveFromEventList+0x64>
80006500:	70 08       	ld.w	r8,r8[0x0]
80006502:	58 08       	cp.w	r8,0
80006504:	c1 71       	brne	80006532 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006506:	ee c6 ff fc 	sub	r6,r7,-4
8000650a:	0c 9c       	mov	r12,r6
8000650c:	f0 1f 00 10 	mcall	8000654c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006510:	6e bc       	ld.w	r12,r7[0x2c]
80006512:	49 18       	lddpc	r8,80006554 <xTaskRemoveFromEventList+0x68>
80006514:	70 08       	ld.w	r8,r8[0x0]
80006516:	10 3c       	cp.w	r12,r8
80006518:	e0 88 00 04 	brls	80006520 <xTaskRemoveFromEventList+0x34>
8000651c:	48 e8       	lddpc	r8,80006554 <xTaskRemoveFromEventList+0x68>
8000651e:	91 0c       	st.w	r8[0x0],r12
80006520:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006524:	0c 9b       	mov	r11,r6
80006526:	48 d8       	lddpc	r8,80006558 <xTaskRemoveFromEventList+0x6c>
80006528:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000652c:	f0 1f 00 0c 	mcall	8000655c <xTaskRemoveFromEventList+0x70>
80006530:	c0 58       	rjmp	8000653a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006532:	0c 9b       	mov	r11,r6
80006534:	48 bc       	lddpc	r12,80006560 <xTaskRemoveFromEventList+0x74>
80006536:	f0 1f 00 0a 	mcall	8000655c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000653a:	48 b8       	lddpc	r8,80006564 <xTaskRemoveFromEventList+0x78>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	6e b9       	ld.w	r9,r7[0x2c]
80006540:	70 b8       	ld.w	r8,r8[0x2c]
80006542:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006544:	5f 2c       	srhs	r12
80006546:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000654a:	00 00       	add	r0,r0
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	5b 66       	cp.w	r6,-10
80006550:	00 00       	add	r0,r0
80006552:	0d 0c       	ld.w	r12,r6++
80006554:	00 00       	add	r0,r0
80006556:	0d 44       	ld.w	r4,--r6
80006558:	00 00       	add	r0,r0
8000655a:	0c 28       	rsub	r8,r6
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	5b 16       	cp.w	r6,-15
80006560:	00 00       	add	r0,r0
80006562:	0c e0       	st.h	--r6,r0
80006564:	00 00       	add	r0,r0
80006566:	0c dc       	st.w	--r6,r12

80006568 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006568:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000656c:	4b 98       	lddpc	r8,80006650 <vTaskIncrementTick+0xe8>
8000656e:	70 08       	ld.w	r8,r8[0x0]
80006570:	58 08       	cp.w	r8,0
80006572:	c6 91       	brne	80006644 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006574:	4b 88       	lddpc	r8,80006654 <vTaskIncrementTick+0xec>
80006576:	70 09       	ld.w	r9,r8[0x0]
80006578:	2f f9       	sub	r9,-1
8000657a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000657c:	70 08       	ld.w	r8,r8[0x0]
8000657e:	58 08       	cp.w	r8,0
80006580:	c1 a1       	brne	800065b4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006582:	4b 68       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
80006584:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006586:	4b 69       	lddpc	r9,8000665c <vTaskIncrementTick+0xf4>
80006588:	72 0b       	ld.w	r11,r9[0x0]
8000658a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000658c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000658e:	4b 59       	lddpc	r9,80006660 <vTaskIncrementTick+0xf8>
80006590:	72 0a       	ld.w	r10,r9[0x0]
80006592:	2f fa       	sub	r10,-1
80006594:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006596:	70 08       	ld.w	r8,r8[0x0]
80006598:	70 08       	ld.w	r8,r8[0x0]
8000659a:	58 08       	cp.w	r8,0
8000659c:	c0 51       	brne	800065a6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000659e:	3f f9       	mov	r9,-1
800065a0:	4b 18       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065a2:	91 09       	st.w	r8[0x0],r9
800065a4:	c0 88       	rjmp	800065b4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065a6:	4a d8       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065a8:	70 08       	ld.w	r8,r8[0x0]
800065aa:	70 38       	ld.w	r8,r8[0xc]
800065ac:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065ae:	70 19       	ld.w	r9,r8[0x4]
800065b0:	4a d8       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065b2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065b4:	4a 88       	lddpc	r8,80006654 <vTaskIncrementTick+0xec>
800065b6:	70 09       	ld.w	r9,r8[0x0]
800065b8:	4a b8       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065ba:	70 08       	ld.w	r8,r8[0x0]
800065bc:	10 39       	cp.w	r9,r8
800065be:	c4 73       	brcs	8000664c <vTaskIncrementTick+0xe4>
800065c0:	4a 68       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065c2:	70 08       	ld.w	r8,r8[0x0]
800065c4:	70 08       	ld.w	r8,r8[0x0]
800065c6:	58 08       	cp.w	r8,0
800065c8:	c0 c0       	breq	800065e0 <vTaskIncrementTick+0x78>
800065ca:	4a 48       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065cc:	70 08       	ld.w	r8,r8[0x0]
800065ce:	70 38       	ld.w	r8,r8[0xc]
800065d0:	70 37       	ld.w	r7,r8[0xc]
800065d2:	6e 18       	ld.w	r8,r7[0x4]
800065d4:	4a 09       	lddpc	r9,80006654 <vTaskIncrementTick+0xec>
800065d6:	72 09       	ld.w	r9,r9[0x0]
800065d8:	12 38       	cp.w	r8,r9
800065da:	e0 88 00 14 	brls	80006602 <vTaskIncrementTick+0x9a>
800065de:	c0 e8       	rjmp	800065fa <vTaskIncrementTick+0x92>
800065e0:	3f f9       	mov	r9,-1
800065e2:	4a 18       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065e4:	91 09       	st.w	r8[0x0],r9
800065e6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065ea:	6a 08       	ld.w	r8,r5[0x0]
800065ec:	70 38       	ld.w	r8,r8[0xc]
800065ee:	70 37       	ld.w	r7,r8[0xc]
800065f0:	6e 18       	ld.w	r8,r7[0x4]
800065f2:	64 09       	ld.w	r9,r2[0x0]
800065f4:	12 38       	cp.w	r8,r9
800065f6:	e0 88 00 0a 	brls	8000660a <vTaskIncrementTick+0xa2>
800065fa:	49 b9       	lddpc	r9,80006664 <vTaskIncrementTick+0xfc>
800065fc:	93 08       	st.w	r9[0x0],r8
800065fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006602:	49 a4       	lddpc	r4,80006668 <vTaskIncrementTick+0x100>
80006604:	49 a3       	lddpc	r3,8000666c <vTaskIncrementTick+0x104>
80006606:	49 55       	lddpc	r5,80006658 <vTaskIncrementTick+0xf0>
80006608:	49 32       	lddpc	r2,80006654 <vTaskIncrementTick+0xec>
8000660a:	ee c6 ff fc 	sub	r6,r7,-4
8000660e:	0c 9c       	mov	r12,r6
80006610:	f0 1f 00 18 	mcall	80006670 <vTaskIncrementTick+0x108>
80006614:	6e a8       	ld.w	r8,r7[0x28]
80006616:	58 08       	cp.w	r8,0
80006618:	c0 50       	breq	80006622 <vTaskIncrementTick+0xba>
8000661a:	ee cc ff e8 	sub	r12,r7,-24
8000661e:	f0 1f 00 15 	mcall	80006670 <vTaskIncrementTick+0x108>
80006622:	6e bc       	ld.w	r12,r7[0x2c]
80006624:	68 08       	ld.w	r8,r4[0x0]
80006626:	10 3c       	cp.w	r12,r8
80006628:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000662c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006630:	0c 9b       	mov	r11,r6
80006632:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006636:	f0 1f 00 10 	mcall	80006674 <vTaskIncrementTick+0x10c>
8000663a:	6a 08       	ld.w	r8,r5[0x0]
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	58 08       	cp.w	r8,0
80006640:	cd 51       	brne	800065ea <vTaskIncrementTick+0x82>
80006642:	cc fb       	rjmp	800065e0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006644:	48 d8       	lddpc	r8,80006678 <vTaskIncrementTick+0x110>
80006646:	70 09       	ld.w	r9,r8[0x0]
80006648:	2f f9       	sub	r9,-1
8000664a:	91 09       	st.w	r8[0x0],r9
8000664c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006650:	00 00       	add	r0,r0
80006652:	0d 0c       	ld.w	r12,r6++
80006654:	00 00       	add	r0,r0
80006656:	0d 08       	ld.w	r8,r6++
80006658:	00 00       	add	r0,r0
8000665a:	0c 14       	sub	r4,r6
8000665c:	00 00       	add	r0,r0
8000665e:	0c 24       	rsub	r4,r6
80006660:	00 00       	add	r0,r0
80006662:	0c 20       	rsub	r0,r6
80006664:	00 00       	add	r0,r0
80006666:	05 34       	ld.ub	r4,r2++
80006668:	00 00       	add	r0,r0
8000666a:	0d 44       	ld.w	r4,--r6
8000666c:	00 00       	add	r0,r0
8000666e:	0c 28       	rsub	r8,r6
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	5b 66       	cp.w	r6,-10
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	5b 16       	cp.w	r6,-15
80006678:	00 00       	add	r0,r0
8000667a:	0c 0c       	add	r12,r6

8000667c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000667c:	eb cd 40 c0 	pushm	r6-r7,lr
80006680:	18 97       	mov	r7,r12
80006682:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006684:	f0 1f 00 15 	mcall	800066d8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006688:	6c 08       	ld.w	r8,r6[0x0]
8000668a:	5b f8       	cp.w	r8,-1
8000668c:	c0 31       	brne	80006692 <xTaskCheckForTimeOut+0x16>
8000668e:	30 07       	mov	r7,0
80006690:	c1 f8       	rjmp	800066ce <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006692:	49 39       	lddpc	r9,800066dc <xTaskCheckForTimeOut+0x60>
80006694:	72 09       	ld.w	r9,r9[0x0]
80006696:	6e 0a       	ld.w	r10,r7[0x0]
80006698:	12 3a       	cp.w	r10,r9
8000669a:	c0 70       	breq	800066a8 <xTaskCheckForTimeOut+0x2c>
8000669c:	49 19       	lddpc	r9,800066e0 <xTaskCheckForTimeOut+0x64>
8000669e:	72 09       	ld.w	r9,r9[0x0]
800066a0:	6e 1a       	ld.w	r10,r7[0x4]
800066a2:	12 3a       	cp.w	r10,r9
800066a4:	e0 88 00 14 	brls	800066cc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066a8:	48 e9       	lddpc	r9,800066e0 <xTaskCheckForTimeOut+0x64>
800066aa:	72 0a       	ld.w	r10,r9[0x0]
800066ac:	6e 19       	ld.w	r9,r7[0x4]
800066ae:	12 1a       	sub	r10,r9
800066b0:	14 38       	cp.w	r8,r10
800066b2:	e0 88 00 0d 	brls	800066cc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066b6:	48 ba       	lddpc	r10,800066e0 <xTaskCheckForTimeOut+0x64>
800066b8:	74 0a       	ld.w	r10,r10[0x0]
800066ba:	14 19       	sub	r9,r10
800066bc:	f2 08 00 08 	add	r8,r9,r8
800066c0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066c2:	0e 9c       	mov	r12,r7
800066c4:	f0 1f 00 08 	mcall	800066e4 <xTaskCheckForTimeOut+0x68>
800066c8:	30 07       	mov	r7,0
800066ca:	c0 28       	rjmp	800066ce <xTaskCheckForTimeOut+0x52>
800066cc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800066ce:	f0 1f 00 07 	mcall	800066e8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800066d2:	0e 9c       	mov	r12,r7
800066d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	5c 20       	cpc	r0
800066dc:	00 00       	add	r0,r0
800066de:	0c 20       	rsub	r0,r6
800066e0:	00 00       	add	r0,r0
800066e2:	0d 08       	ld.w	r8,r6++
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	63 e0       	ld.w	r0,r1[0x78]
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	5d 2c       	mustr	r12

800066ec <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800066ec:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800066f0:	f0 1f 00 05 	mcall	80006704 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800066f4:	48 58       	lddpc	r8,80006708 <xTaskGetTickCount+0x1c>
800066f6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800066f8:	f0 1f 00 05 	mcall	8000670c <xTaskGetTickCount+0x20>

	return xTicks;
}
800066fc:	0e 9c       	mov	r12,r7
800066fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006702:	00 00       	add	r0,r0
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5c 20       	cpc	r0
80006708:	00 00       	add	r0,r0
8000670a:	0d 08       	ld.w	r8,r6++
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	5d 2c       	mustr	r12

80006710 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006710:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006714:	f0 1f 00 2c 	mcall	800067c4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006718:	4a c8       	lddpc	r8,800067c8 <xTaskResumeAll+0xb8>
8000671a:	70 09       	ld.w	r9,r8[0x0]
8000671c:	20 19       	sub	r9,1
8000671e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006720:	70 08       	ld.w	r8,r8[0x0]
80006722:	58 08       	cp.w	r8,0
80006724:	c4 91       	brne	800067b6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006726:	4a a8       	lddpc	r8,800067cc <xTaskResumeAll+0xbc>
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	58 08       	cp.w	r8,0
8000672c:	c4 50       	breq	800067b6 <xTaskResumeAll+0xa6>
8000672e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006730:	4a 85       	lddpc	r5,800067d0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006732:	4a 93       	lddpc	r3,800067d4 <xTaskResumeAll+0xc4>
80006734:	4a 92       	lddpc	r2,800067d8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006736:	4a a1       	lddpc	r1,800067dc <xTaskResumeAll+0xcc>
80006738:	c1 e8       	rjmp	80006774 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000673a:	6a 38       	ld.w	r8,r5[0xc]
8000673c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000673e:	ee cc ff e8 	sub	r12,r7,-24
80006742:	f0 1f 00 28 	mcall	800067e0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006746:	ee c6 ff fc 	sub	r6,r7,-4
8000674a:	0c 9c       	mov	r12,r6
8000674c:	f0 1f 00 25 	mcall	800067e0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006750:	6e bc       	ld.w	r12,r7[0x2c]
80006752:	66 08       	ld.w	r8,r3[0x0]
80006754:	10 3c       	cp.w	r12,r8
80006756:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000675a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000675e:	0c 9b       	mov	r11,r6
80006760:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006764:	f0 1f 00 20 	mcall	800067e4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006768:	62 08       	ld.w	r8,r1[0x0]
8000676a:	6e b9       	ld.w	r9,r7[0x2c]
8000676c:	70 b8       	ld.w	r8,r8[0x2c]
8000676e:	10 39       	cp.w	r9,r8
80006770:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006774:	6a 08       	ld.w	r8,r5[0x0]
80006776:	58 08       	cp.w	r8,0
80006778:	ce 11       	brne	8000673a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000677a:	49 c8       	lddpc	r8,800067e8 <xTaskResumeAll+0xd8>
8000677c:	70 08       	ld.w	r8,r8[0x0]
8000677e:	58 08       	cp.w	r8,0
80006780:	c0 f0       	breq	8000679e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006782:	49 a8       	lddpc	r8,800067e8 <xTaskResumeAll+0xd8>
80006784:	70 08       	ld.w	r8,r8[0x0]
80006786:	58 08       	cp.w	r8,0
80006788:	c1 10       	breq	800067aa <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000678a:	49 87       	lddpc	r7,800067e8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000678c:	f0 1f 00 18 	mcall	800067ec <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006790:	6e 08       	ld.w	r8,r7[0x0]
80006792:	20 18       	sub	r8,1
80006794:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006796:	6e 08       	ld.w	r8,r7[0x0]
80006798:	58 08       	cp.w	r8,0
8000679a:	cf 91       	brne	8000678c <xTaskResumeAll+0x7c>
8000679c:	c0 78       	rjmp	800067aa <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000679e:	58 14       	cp.w	r4,1
800067a0:	c0 50       	breq	800067aa <xTaskResumeAll+0x9a>
800067a2:	49 48       	lddpc	r8,800067f0 <xTaskResumeAll+0xe0>
800067a4:	70 08       	ld.w	r8,r8[0x0]
800067a6:	58 18       	cp.w	r8,1
800067a8:	c0 71       	brne	800067b6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067aa:	30 09       	mov	r9,0
800067ac:	49 18       	lddpc	r8,800067f0 <xTaskResumeAll+0xe0>
800067ae:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067b0:	d7 33       	scall
800067b2:	30 17       	mov	r7,1
800067b4:	c0 28       	rjmp	800067b8 <xTaskResumeAll+0xa8>
800067b6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067b8:	f0 1f 00 0f 	mcall	800067f4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067bc:	0e 9c       	mov	r12,r7
800067be:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067c2:	00 00       	add	r0,r0
800067c4:	80 00       	ld.sh	r0,r0[0x0]
800067c6:	5c 20       	cpc	r0
800067c8:	00 00       	add	r0,r0
800067ca:	0d 0c       	ld.w	r12,r6++
800067cc:	00 00       	add	r0,r0
800067ce:	0d 28       	ld.uh	r8,r6++
800067d0:	00 00       	add	r0,r0
800067d2:	0c e0       	st.h	--r6,r0
800067d4:	00 00       	add	r0,r0
800067d6:	0d 44       	ld.w	r4,--r6
800067d8:	00 00       	add	r0,r0
800067da:	0c 28       	rsub	r8,r6
800067dc:	00 00       	add	r0,r0
800067de:	0c dc       	st.w	--r6,r12
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	5b 66       	cp.w	r6,-10
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5b 16       	cp.w	r6,-15
800067e8:	00 00       	add	r0,r0
800067ea:	0c 0c       	add	r12,r6
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	65 68       	ld.w	r8,r2[0x58]
800067f0:	00 00       	add	r0,r0
800067f2:	0d 2c       	ld.uh	r12,r6++
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	5d 2c       	mustr	r12

800067f8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800067f8:	eb cd 40 80 	pushm	r7,lr
800067fc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800067fe:	49 08       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
80006800:	70 08       	ld.w	r8,r8[0x0]
80006802:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006804:	48 f8       	lddpc	r8,80006840 <prvAddCurrentTaskToDelayedList+0x48>
80006806:	70 08       	ld.w	r8,r8[0x0]
80006808:	10 3c       	cp.w	r12,r8
8000680a:	c0 a2       	brcc	8000681e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000680c:	48 c8       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
8000680e:	70 0b       	ld.w	r11,r8[0x0]
80006810:	48 d8       	lddpc	r8,80006844 <prvAddCurrentTaskToDelayedList+0x4c>
80006812:	70 0c       	ld.w	r12,r8[0x0]
80006814:	2f cb       	sub	r11,-4
80006816:	f0 1f 00 0d 	mcall	80006848 <prvAddCurrentTaskToDelayedList+0x50>
8000681a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000681e:	48 88       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
80006820:	70 0b       	ld.w	r11,r8[0x0]
80006822:	48 b8       	lddpc	r8,8000684c <prvAddCurrentTaskToDelayedList+0x54>
80006824:	70 0c       	ld.w	r12,r8[0x0]
80006826:	2f cb       	sub	r11,-4
80006828:	f0 1f 00 08 	mcall	80006848 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000682c:	48 98       	lddpc	r8,80006850 <prvAddCurrentTaskToDelayedList+0x58>
8000682e:	70 08       	ld.w	r8,r8[0x0]
80006830:	10 37       	cp.w	r7,r8
80006832:	c0 32       	brcc	80006838 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006834:	48 78       	lddpc	r8,80006850 <prvAddCurrentTaskToDelayedList+0x58>
80006836:	91 07       	st.w	r8[0x0],r7
80006838:	e3 cd 80 80 	ldm	sp++,r7,pc
8000683c:	00 00       	add	r0,r0
8000683e:	0c dc       	st.w	--r6,r12
80006840:	00 00       	add	r0,r0
80006842:	0d 08       	ld.w	r8,r6++
80006844:	00 00       	add	r0,r0
80006846:	0c 24       	rsub	r4,r6
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	5b 32       	cp.w	r2,-13
8000684c:	00 00       	add	r0,r0
8000684e:	0c 14       	sub	r4,r6
80006850:	00 00       	add	r0,r0
80006852:	05 34       	ld.ub	r4,r2++

80006854 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006854:	eb cd 40 c0 	pushm	r6-r7,lr
80006858:	18 96       	mov	r6,r12
8000685a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000685c:	f0 1f 00 18 	mcall	800068bc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006860:	6c 08       	ld.w	r8,r6[0x0]
80006862:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006864:	49 79       	lddpc	r9,800068c0 <vTaskDelayUntil+0x6c>
80006866:	72 09       	ld.w	r9,r9[0x0]
80006868:	12 38       	cp.w	r8,r9
8000686a:	e0 88 00 0c 	brls	80006882 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000686e:	0e 38       	cp.w	r8,r7
80006870:	e0 88 00 22 	brls	800068b4 <vTaskDelayUntil+0x60>
80006874:	49 38       	lddpc	r8,800068c0 <vTaskDelayUntil+0x6c>
80006876:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006878:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000687a:	10 37       	cp.w	r7,r8
8000687c:	e0 88 00 14 	brls	800068a4 <vTaskDelayUntil+0x50>
80006880:	c0 a8       	rjmp	80006894 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006882:	0e 38       	cp.w	r8,r7
80006884:	e0 8b 00 16 	brhi	800068b0 <vTaskDelayUntil+0x5c>
80006888:	48 e8       	lddpc	r8,800068c0 <vTaskDelayUntil+0x6c>
8000688a:	70 08       	ld.w	r8,r8[0x0]
8000688c:	10 37       	cp.w	r7,r8
8000688e:	e0 8b 00 11 	brhi	800068b0 <vTaskDelayUntil+0x5c>
80006892:	c1 18       	rjmp	800068b4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006894:	48 c8       	lddpc	r8,800068c4 <vTaskDelayUntil+0x70>
80006896:	70 0c       	ld.w	r12,r8[0x0]
80006898:	2f cc       	sub	r12,-4
8000689a:	f0 1f 00 0c 	mcall	800068c8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000689e:	0e 9c       	mov	r12,r7
800068a0:	f0 1f 00 0b 	mcall	800068cc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800068a4:	f0 1f 00 0b 	mcall	800068d0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068a8:	c0 81       	brne	800068b8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800068aa:	d7 33       	scall
800068ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068b0:	8d 07       	st.w	r6[0x0],r7
800068b2:	cf 1b       	rjmp	80006894 <vTaskDelayUntil+0x40>
800068b4:	8d 07       	st.w	r6[0x0],r7
800068b6:	cf 7b       	rjmp	800068a4 <vTaskDelayUntil+0x50>
800068b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	63 54       	ld.w	r4,r1[0x54]
800068c0:	00 00       	add	r0,r0
800068c2:	0d 08       	ld.w	r8,r6++
800068c4:	00 00       	add	r0,r0
800068c6:	0c dc       	st.w	--r6,r12
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	5b 66       	cp.w	r6,-10
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	67 f8       	ld.w	r8,r3[0x7c]
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	67 10       	ld.w	r0,r3[0x44]

800068d4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800068d4:	eb cd 40 c0 	pushm	r6-r7,lr
800068d8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800068da:	48 e7       	lddpc	r7,80006910 <vTaskPlaceOnEventList+0x3c>
800068dc:	6e 0b       	ld.w	r11,r7[0x0]
800068de:	2e 8b       	sub	r11,-24
800068e0:	f0 1f 00 0d 	mcall	80006914 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068e4:	6e 0c       	ld.w	r12,r7[0x0]
800068e6:	2f cc       	sub	r12,-4
800068e8:	f0 1f 00 0c 	mcall	80006918 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800068ec:	5b f6       	cp.w	r6,-1
800068ee:	c0 81       	brne	800068fe <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068f0:	6e 0b       	ld.w	r11,r7[0x0]
800068f2:	2f cb       	sub	r11,-4
800068f4:	48 ac       	lddpc	r12,8000691c <vTaskPlaceOnEventList+0x48>
800068f6:	f0 1f 00 0b 	mcall	80006920 <vTaskPlaceOnEventList+0x4c>
800068fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800068fe:	48 a8       	lddpc	r8,80006924 <vTaskPlaceOnEventList+0x50>
80006900:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006902:	ec 0c 00 0c 	add	r12,r6,r12
80006906:	f0 1f 00 09 	mcall	80006928 <vTaskPlaceOnEventList+0x54>
8000690a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000690e:	00 00       	add	r0,r0
80006910:	00 00       	add	r0,r0
80006912:	0c dc       	st.w	--r6,r12
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	5b 32       	cp.w	r2,-13
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	5b 66       	cp.w	r6,-10
8000691c:	00 00       	add	r0,r0
8000691e:	0d 30       	ld.ub	r0,r6++
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	5b 16       	cp.w	r6,-15
80006924:	00 00       	add	r0,r0
80006926:	0d 08       	ld.w	r8,r6++
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	67 f8       	ld.w	r8,r3[0x7c]

8000692c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000692c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006930:	49 67       	lddpc	r7,80006988 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006932:	49 74       	lddpc	r4,8000698c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006934:	49 73       	lddpc	r3,80006990 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006936:	49 85       	lddpc	r5,80006994 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006938:	6e 08       	ld.w	r8,r7[0x0]
8000693a:	58 08       	cp.w	r8,0
8000693c:	c1 e0       	breq	80006978 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000693e:	f0 1f 00 17 	mcall	80006998 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006942:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006944:	f0 1f 00 16 	mcall	8000699c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006948:	58 06       	cp.w	r6,0
8000694a:	c1 70       	breq	80006978 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000694c:	f0 1f 00 15 	mcall	800069a0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006950:	68 38       	ld.w	r8,r4[0xc]
80006952:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006954:	ec cc ff fc 	sub	r12,r6,-4
80006958:	f0 1f 00 13 	mcall	800069a4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000695c:	66 08       	ld.w	r8,r3[0x0]
8000695e:	20 18       	sub	r8,1
80006960:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006962:	6e 08       	ld.w	r8,r7[0x0]
80006964:	20 18       	sub	r8,1
80006966:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006968:	f0 1f 00 10 	mcall	800069a8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000696c:	6c cc       	ld.w	r12,r6[0x30]
8000696e:	f0 1f 00 10 	mcall	800069ac <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006972:	0c 9c       	mov	r12,r6
80006974:	f0 1f 00 0e 	mcall	800069ac <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006978:	6a 08       	ld.w	r8,r5[0x0]
8000697a:	58 18       	cp.w	r8,1
8000697c:	e0 88 00 03 	brls	80006982 <prvIdleTask+0x56>
			{
				taskYIELD();
80006980:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006982:	f0 1f 00 0c 	mcall	800069b0 <prvIdleTask+0x84>
		}
		#endif
	}
80006986:	cd 9b       	rjmp	80006938 <prvIdleTask+0xc>
80006988:	00 00       	add	r0,r0
8000698a:	0c 1c       	sub	r12,r6
8000698c:	00 00       	add	r0,r0
8000698e:	0c c8       	st.b	r6++,r8
80006990:	00 00       	add	r0,r0
80006992:	0d 28       	ld.uh	r8,r6++
80006994:	00 00       	add	r0,r0
80006996:	0c 28       	rsub	r8,r6
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	63 54       	ld.w	r4,r1[0x54]
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	67 10       	ld.w	r0,r3[0x44]
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	5c 20       	cpc	r0
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	5b 66       	cp.w	r6,-10
800069a8:	80 00       	ld.sh	r0,r0[0x0]
800069aa:	5d 2c       	mustr	r12
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	5e 64       	retmi	r4
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	20 2c       	sub	r12,2

800069b4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800069b4:	d4 31       	pushm	r0-r7,lr
800069b6:	20 1d       	sub	sp,4
800069b8:	fa c4 ff d8 	sub	r4,sp,-40
800069bc:	50 0c       	stdsp	sp[0x0],r12
800069be:	16 91       	mov	r1,r11
800069c0:	14 97       	mov	r7,r10
800069c2:	12 90       	mov	r0,r9
800069c4:	10 93       	mov	r3,r8
800069c6:	68 02       	ld.w	r2,r4[0x0]
800069c8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800069ca:	34 8c       	mov	r12,72
800069cc:	f0 1f 00 5c 	mcall	80006b3c <xTaskGenericCreate+0x188>
800069d0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800069d2:	c0 31       	brne	800069d8 <xTaskGenericCreate+0x24>
800069d4:	3f fc       	mov	r12,-1
800069d6:	ca f8       	rjmp	80006b34 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800069d8:	58 06       	cp.w	r6,0
800069da:	e0 81 00 af 	brne	80006b38 <xTaskGenericCreate+0x184>
800069de:	0e 9c       	mov	r12,r7
800069e0:	5c 7c       	castu.h	r12
800069e2:	a3 6c       	lsl	r12,0x2
800069e4:	f0 1f 00 56 	mcall	80006b3c <xTaskGenericCreate+0x188>
800069e8:	18 96       	mov	r6,r12
800069ea:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800069ec:	c0 61       	brne	800069f8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800069ee:	0a 9c       	mov	r12,r5
800069f0:	f0 1f 00 54 	mcall	80006b40 <xTaskGenericCreate+0x18c>
800069f4:	3f fc       	mov	r12,-1
800069f6:	c9 f8       	rjmp	80006b34 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800069f8:	5c 77       	castu.h	r7
800069fa:	ee 0a 15 02 	lsl	r10,r7,0x2
800069fe:	e0 6b 00 a5 	mov	r11,165
80006a02:	0c 9c       	mov	r12,r6
80006a04:	f0 1f 00 50 	mcall	80006b44 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a08:	ee c6 00 01 	sub	r6,r7,1
80006a0c:	6a c8       	ld.w	r8,r5[0x30]
80006a0e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a12:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a16:	31 0a       	mov	r10,16
80006a18:	02 9b       	mov	r11,r1
80006a1a:	ea cc ff cc 	sub	r12,r5,-52
80006a1e:	f0 1f 00 4b 	mcall	80006b48 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006a22:	30 08       	mov	r8,0
80006a24:	eb 68 00 43 	st.b	r5[67],r8
80006a28:	58 73       	cp.w	r3,7
80006a2a:	e6 07 17 80 	movls	r7,r3
80006a2e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006a32:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006a34:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006a38:	ea c4 ff fc 	sub	r4,r5,-4
80006a3c:	08 9c       	mov	r12,r4
80006a3e:	f0 1f 00 44 	mcall	80006b4c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006a42:	ea cc ff e8 	sub	r12,r5,-24
80006a46:	f0 1f 00 42 	mcall	80006b4c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a4a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a4c:	ee 07 11 08 	rsub	r7,r7,8
80006a50:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a52:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a54:	00 9a       	mov	r10,r0
80006a56:	40 0b       	lddsp	r11,sp[0x0]
80006a58:	0c 9c       	mov	r12,r6
80006a5a:	f0 1f 00 3e 	mcall	80006b50 <xTaskGenericCreate+0x19c>
80006a5e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006a60:	58 02       	cp.w	r2,0
80006a62:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a66:	f0 1f 00 3c 	mcall	80006b54 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a6a:	4b c8       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a4>
80006a6c:	70 09       	ld.w	r9,r8[0x0]
80006a6e:	2f f9       	sub	r9,-1
80006a70:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a72:	4b b8       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1a8>
80006a74:	70 08       	ld.w	r8,r8[0x0]
80006a76:	58 08       	cp.w	r8,0
80006a78:	c2 61       	brne	80006ac4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a7a:	4b 98       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1a8>
80006a7c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a7e:	4b 78       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a4>
80006a80:	70 08       	ld.w	r8,r8[0x0]
80006a82:	58 18       	cp.w	r8,1
80006a84:	c2 b1       	brne	80006ada <xTaskGenericCreate+0x126>
80006a86:	4b 77       	lddpc	r7,80006b60 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a88:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a8c:	0e 9c       	mov	r12,r7
80006a8e:	f0 1f 00 36 	mcall	80006b64 <xTaskGenericCreate+0x1b0>
80006a92:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a94:	0c 37       	cp.w	r7,r6
80006a96:	cf b1       	brne	80006a8c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006a98:	4b 47       	lddpc	r7,80006b68 <xTaskGenericCreate+0x1b4>
80006a9a:	0e 9c       	mov	r12,r7
80006a9c:	f0 1f 00 32 	mcall	80006b64 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006aa0:	4b 36       	lddpc	r6,80006b6c <xTaskGenericCreate+0x1b8>
80006aa2:	0c 9c       	mov	r12,r6
80006aa4:	f0 1f 00 30 	mcall	80006b64 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006aa8:	4b 2c       	lddpc	r12,80006b70 <xTaskGenericCreate+0x1bc>
80006aaa:	f0 1f 00 2f 	mcall	80006b64 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006aae:	4b 2c       	lddpc	r12,80006b74 <xTaskGenericCreate+0x1c0>
80006ab0:	f0 1f 00 2d 	mcall	80006b64 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006ab4:	4b 1c       	lddpc	r12,80006b78 <xTaskGenericCreate+0x1c4>
80006ab6:	f0 1f 00 2c 	mcall	80006b64 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006aba:	4b 18       	lddpc	r8,80006b7c <xTaskGenericCreate+0x1c8>
80006abc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006abe:	4b 18       	lddpc	r8,80006b80 <xTaskGenericCreate+0x1cc>
80006ac0:	91 06       	st.w	r8[0x0],r6
80006ac2:	c0 c8       	rjmp	80006ada <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006ac4:	4b 08       	lddpc	r8,80006b84 <xTaskGenericCreate+0x1d0>
80006ac6:	70 08       	ld.w	r8,r8[0x0]
80006ac8:	58 08       	cp.w	r8,0
80006aca:	c0 81       	brne	80006ada <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006acc:	4a 48       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1a8>
80006ace:	70 08       	ld.w	r8,r8[0x0]
80006ad0:	70 b8       	ld.w	r8,r8[0x2c]
80006ad2:	10 33       	cp.w	r3,r8
80006ad4:	c0 33       	brcs	80006ada <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006ad6:	4a 28       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1a8>
80006ad8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006ada:	6a b8       	ld.w	r8,r5[0x2c]
80006adc:	4a b9       	lddpc	r9,80006b88 <xTaskGenericCreate+0x1d4>
80006ade:	72 09       	ld.w	r9,r9[0x0]
80006ae0:	12 38       	cp.w	r8,r9
80006ae2:	e0 88 00 04 	brls	80006aea <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006ae6:	4a 99       	lddpc	r9,80006b88 <xTaskGenericCreate+0x1d4>
80006ae8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006aea:	4a 98       	lddpc	r8,80006b8c <xTaskGenericCreate+0x1d8>
80006aec:	70 09       	ld.w	r9,r8[0x0]
80006aee:	2f f9       	sub	r9,-1
80006af0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006af2:	6a b8       	ld.w	r8,r5[0x2c]
80006af4:	4a 79       	lddpc	r9,80006b90 <xTaskGenericCreate+0x1dc>
80006af6:	72 09       	ld.w	r9,r9[0x0]
80006af8:	12 38       	cp.w	r8,r9
80006afa:	e0 88 00 04 	brls	80006b02 <xTaskGenericCreate+0x14e>
80006afe:	4a 59       	lddpc	r9,80006b90 <xTaskGenericCreate+0x1dc>
80006b00:	93 08       	st.w	r9[0x0],r8
80006b02:	6a bc       	ld.w	r12,r5[0x2c]
80006b04:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b08:	08 9b       	mov	r11,r4
80006b0a:	49 68       	lddpc	r8,80006b60 <xTaskGenericCreate+0x1ac>
80006b0c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b10:	f0 1f 00 21 	mcall	80006b94 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b14:	f0 1f 00 21 	mcall	80006b98 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b18:	49 b8       	lddpc	r8,80006b84 <xTaskGenericCreate+0x1d0>
80006b1a:	70 08       	ld.w	r8,r8[0x0]
80006b1c:	58 08       	cp.w	r8,0
80006b1e:	c0 a0       	breq	80006b32 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006b20:	48 f8       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1a8>
80006b22:	70 08       	ld.w	r8,r8[0x0]
80006b24:	70 b8       	ld.w	r8,r8[0x2c]
80006b26:	10 33       	cp.w	r3,r8
80006b28:	e0 88 00 05 	brls	80006b32 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006b2c:	d7 33       	scall
80006b2e:	30 1c       	mov	r12,1
80006b30:	c0 28       	rjmp	80006b34 <xTaskGenericCreate+0x180>
80006b32:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006b34:	2f fd       	sub	sp,-4
80006b36:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b38:	99 c6       	st.w	r12[0x30],r6
80006b3a:	c5 fb       	rjmp	800069f8 <xTaskGenericCreate+0x44>
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	5e 8c       	retls	r12
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	5e 64       	retmi	r4
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	77 54       	ld.w	r4,r11[0x54]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	7a 80       	ld.w	r0,sp[0x20]
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	5b 10       	cp.w	r0,-15
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	5b 8c       	cp.w	r12,-8
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	5c 20       	cpc	r0
80006b58:	00 00       	add	r0,r0
80006b5a:	0d 28       	ld.uh	r8,r6++
80006b5c:	00 00       	add	r0,r0
80006b5e:	0c dc       	st.w	--r6,r12
80006b60:	00 00       	add	r0,r0
80006b62:	0c 28       	rsub	r8,r6
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	5a fc       	cp.w	r12,-17
80006b68:	00 00       	add	r0,r0
80006b6a:	0c f4       	st.b	--r6,r4
80006b6c:	00 00       	add	r0,r0
80006b6e:	0d 10       	ld.sh	r0,r6++
80006b70:	00 00       	add	r0,r0
80006b72:	0c e0       	st.h	--r6,r0
80006b74:	00 00       	add	r0,r0
80006b76:	0c c8       	st.b	r6++,r8
80006b78:	00 00       	add	r0,r0
80006b7a:	0d 30       	ld.ub	r0,r6++
80006b7c:	00 00       	add	r0,r0
80006b7e:	0c 14       	sub	r4,r6
80006b80:	00 00       	add	r0,r0
80006b82:	0c 24       	rsub	r4,r6
80006b84:	00 00       	add	r0,r0
80006b86:	0c 18       	sub	r8,r6
80006b88:	00 00       	add	r0,r0
80006b8a:	0c 10       	sub	r0,r6
80006b8c:	00 00       	add	r0,r0
80006b8e:	0d 24       	ld.uh	r4,r6++
80006b90:	00 00       	add	r0,r0
80006b92:	0d 44       	ld.w	r4,--r6
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	5b 16       	cp.w	r6,-15
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	5d 2c       	mustr	r12

80006b9c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006b9c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006b9e:	30 09       	mov	r9,0
80006ba0:	1a d9       	st.w	--sp,r9
80006ba2:	1a d9       	st.w	--sp,r9
80006ba4:	1a d9       	st.w	--sp,r9
80006ba6:	12 98       	mov	r8,r9
80006ba8:	e0 6a 01 00 	mov	r10,256
80006bac:	48 9b       	lddpc	r11,80006bd0 <vTaskStartScheduler+0x34>
80006bae:	48 ac       	lddpc	r12,80006bd4 <vTaskStartScheduler+0x38>
80006bb0:	f0 1f 00 0a 	mcall	80006bd8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006bb4:	2f dd       	sub	sp,-12
80006bb6:	58 1c       	cp.w	r12,1
80006bb8:	c0 a1       	brne	80006bcc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006bba:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006bbc:	30 19       	mov	r9,1
80006bbe:	48 88       	lddpc	r8,80006bdc <vTaskStartScheduler+0x40>
80006bc0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006bc2:	30 09       	mov	r9,0
80006bc4:	48 78       	lddpc	r8,80006be0 <vTaskStartScheduler+0x44>
80006bc6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006bc8:	f0 1f 00 07 	mcall	80006be4 <vTaskStartScheduler+0x48>
80006bcc:	d8 02       	popm	pc
80006bce:	00 00       	add	r0,r0
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	d6 c4       	*unknown*
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	69 2c       	ld.w	r12,r4[0x48]
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	69 b4       	ld.w	r4,r4[0x6c]
80006bdc:	00 00       	add	r0,r0
80006bde:	0c 18       	sub	r8,r6
80006be0:	00 00       	add	r0,r0
80006be2:	0d 08       	ld.w	r8,r6++
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	5c 30       	neg	r0

80006be8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006be8:	16 cc       	st.b	r11++,r12
	return str;
}
80006bea:	5e fb       	retal	r11

80006bec <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006bec:	eb cd 40 c0 	pushm	r6-r7,lr
80006bf0:	20 3d       	sub	sp,12
80006bf2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006bf4:	30 06       	mov	r6,0
80006bf6:	30 07       	mov	r7,0
80006bf8:	fa e7 00 00 	st.d	sp[0],r6
80006bfc:	30 0c       	mov	r12,0
80006bfe:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006c00:	58 08       	cp.w	r8,0
80006c02:	c1 30       	breq	80006c28 <PrintHex+0x3c>
80006c04:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c06:	1a 9c       	mov	r12,sp
80006c08:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c0c:	58 9e       	cp.w	lr,9
80006c0e:	e0 8a 00 04 	brle	80006c16 <PrintHex+0x2a>
80006c12:	2c 9e       	sub	lr,-55
80006c14:	c0 48       	rjmp	80006c1c <PrintHex+0x30>
80006c16:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c1a:	2d 0e       	sub	lr,-48
80006c1c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006c20:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006c22:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006c24:	cf 21       	brne	80006c08 <PrintHex+0x1c>
80006c26:	c0 48       	rjmp	80006c2e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006c28:	33 08       	mov	r8,48
80006c2a:	ba 88       	st.b	sp[0x0],r8
80006c2c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006c2e:	f6 09 01 08 	sub	r8,r11,r9
80006c32:	58 08       	cp.w	r8,0
80006c34:	e0 8a 00 13 	brle	80006c5a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006c38:	12 1b       	sub	r11,r9
80006c3a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006c3e:	18 9e       	mov	lr,r12
80006c40:	58 0c       	cp.w	r12,0
80006c42:	e0 8a 00 0c 	brle	80006c5a <PrintHex+0x6e>
80006c46:	1a 9b       	mov	r11,sp
80006c48:	12 0b       	add	r11,r9
80006c4a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c4c:	33 07       	mov	r7,48
80006c4e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c50:	2f f8       	sub	r8,-1
80006c52:	1c 38       	cp.w	r8,lr
80006c54:	cf d5       	brlt	80006c4e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c56:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c5a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006c5e:	f0 cb ff ff 	sub	r11,r8,-1
80006c62:	58 0b       	cp.w	r11,0
80006c64:	e0 8a 00 19 	brle	80006c96 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c68:	fa cb ff f4 	sub	r11,sp,-12
80006c6c:	f6 09 00 09 	add	r9,r11,r9
80006c70:	37 8b       	mov	r11,120
80006c72:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c76:	fa c9 ff f4 	sub	r9,sp,-12
80006c7a:	10 09       	add	r9,r8
80006c7c:	33 0b       	mov	r11,48
80006c7e:	f3 6b ff f4 	st.b	r9[-12],r11
80006c82:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c86:	fa ce 00 01 	sub	lr,sp,1
80006c8a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c8c:	11 8b       	ld.ub	r11,r8[0x0]
80006c8e:	12 cb       	st.b	r9++,r11
80006c90:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c92:	1c 38       	cp.w	r8,lr
80006c94:	cf c1       	brne	80006c8c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c96:	14 9c       	mov	r12,r10
80006c98:	2f dd       	sub	sp,-12
80006c9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006c9e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006c9e:	d4 21       	pushm	r4-r7,lr
80006ca0:	20 3d       	sub	sp,12
80006ca2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006ca4:	30 06       	mov	r6,0
80006ca6:	30 07       	mov	r7,0
80006ca8:	fa e7 00 00 	st.d	sp[0],r6
80006cac:	30 0c       	mov	r12,0
80006cae:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006cb0:	58 08       	cp.w	r8,0
80006cb2:	c0 35       	brlt	80006cb8 <PrintDec+0x1a>
80006cb4:	14 97       	mov	r7,r10
80006cb6:	c0 58       	rjmp	80006cc0 <PrintDec+0x22>
	{
		*p++ = '-';
80006cb8:	14 97       	mov	r7,r10
80006cba:	32 d9       	mov	r9,45
80006cbc:	0e c9       	st.b	r7++,r9
		i = -i;
80006cbe:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006cc0:	58 08       	cp.w	r8,0
80006cc2:	c0 51       	brne	80006ccc <PrintDec+0x2e>
80006cc4:	33 08       	mov	r8,48
80006cc6:	ba 88       	st.b	sp[0x0],r8
80006cc8:	30 1e       	mov	lr,1
80006cca:	c2 f8       	rjmp	80006d28 <PrintDec+0x8a>
	
	int ten = i%10;
80006ccc:	e0 65 66 67 	mov	r5,26215
80006cd0:	ea 15 66 66 	orh	r5,0x6666
80006cd4:	f0 05 04 44 	muls.d	r4,r8,r5
80006cd8:	ea 0c 14 02 	asr	r12,r5,0x2
80006cdc:	f0 09 14 1f 	asr	r9,r8,0x1f
80006ce0:	f8 09 01 09 	sub	r9,r12,r9
80006ce4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ce8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006cec:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006cee:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006cf0:	e0 66 66 67 	mov	r6,26215
80006cf4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006cf8:	2d 09       	sub	r9,-48
80006cfa:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006cfe:	2f fe       	sub	lr,-1
		i /= 10;
80006d00:	f0 06 04 44 	muls.d	r4,r8,r6
80006d04:	ea 09 14 02 	asr	r9,r5,0x2
80006d08:	bf 58       	asr	r8,0x1f
80006d0a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d0e:	f0 06 04 44 	muls.d	r4,r8,r6
80006d12:	ea 09 14 02 	asr	r9,r5,0x2
80006d16:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d1a:	0a 19       	sub	r9,r5
80006d1c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d20:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006d24:	58 08       	cp.w	r8,0
80006d26:	ce 91       	brne	80006cf8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006d28:	f6 0e 01 08 	sub	r8,r11,lr
80006d2c:	58 08       	cp.w	r8,0
80006d2e:	e0 89 00 06 	brgt	80006d3a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d32:	58 0e       	cp.w	lr,0
80006d34:	e0 89 00 14 	brgt	80006d5c <PrintDec+0xbe>
80006d38:	c1 d8       	rjmp	80006d72 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006d3a:	1c 1b       	sub	r11,lr
80006d3c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006d3e:	16 9c       	mov	r12,r11
80006d40:	58 0b       	cp.w	r11,0
80006d42:	fe 9a ff f8 	brle	80006d32 <PrintDec+0x94>
80006d46:	1a 99       	mov	r9,sp
80006d48:	1c 09       	add	r9,lr
80006d4a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d4c:	33 06       	mov	r6,48
80006d4e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d50:	2f f8       	sub	r8,-1
80006d52:	18 38       	cp.w	r8,r12
80006d54:	cf d5       	brlt	80006d4e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d56:	f6 0e 00 0e 	add	lr,r11,lr
80006d5a:	ce cb       	rjmp	80006d32 <PrintDec+0x94>
80006d5c:	fa c8 ff f4 	sub	r8,sp,-12
80006d60:	1c 08       	add	r8,lr
80006d62:	20 d8       	sub	r8,13
80006d64:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d68:	11 89       	ld.ub	r9,r8[0x0]
80006d6a:	0e c9       	st.b	r7++,r9
80006d6c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d6e:	16 38       	cp.w	r8,r11
80006d70:	cf c1       	brne	80006d68 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d72:	14 9c       	mov	r12,r10
80006d74:	2f dd       	sub	sp,-12
80006d76:	d8 22       	popm	r4-r7,pc

80006d78 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d78:	d4 31       	pushm	r0-r7,lr
80006d7a:	fa cd 02 08 	sub	sp,sp,520
80006d7e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d80:	e0 6a 01 00 	mov	r10,256
80006d84:	30 0b       	mov	r11,0
80006d86:	fa cc fe f8 	sub	r12,sp,-264
80006d8a:	f0 1f 00 4e 	mcall	80006ec0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d8e:	fa c4 fd d4 	sub	r4,sp,-556
80006d92:	30 0a       	mov	r10,0
80006d94:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d96:	fa c3 ff fc 	sub	r3,sp,-4
80006d9a:	e0 61 01 00 	mov	r1,256
80006d9e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006da0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006da2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006da6:	02 9a       	mov	r10,r1
80006da8:	00 9b       	mov	r11,r0
80006daa:	06 9c       	mov	r12,r3
80006dac:	f0 1f 00 45 	mcall	80006ec0 <log+0x148>
			
					if(*str == '%')
80006db0:	0f 88       	ld.ub	r8,r7[0x0]
80006db2:	e4 08 18 00 	cp.b	r8,r2
80006db6:	c5 71       	brne	80006e64 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006db8:	ee c8 ff ff 	sub	r8,r7,-1
80006dbc:	11 89       	ld.ub	r9,r8[0x0]
80006dbe:	4c 2a       	lddpc	r10,80006ec4 <log+0x14c>
80006dc0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006dc2:	23 09       	sub	r9,48
80006dc4:	30 9a       	mov	r10,9
80006dc6:	f4 09 18 00 	cp.b	r9,r10
80006dca:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006dce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006dd2:	f7 b9 08 30 	subls	r9,48
80006dd6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006dda:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006dde:	0f 88       	ld.ub	r8,r7[0x0]
80006de0:	22 58       	sub	r8,37
80006de2:	e0 48 00 53 	cp.w	r8,83
80006de6:	e0 8b 00 31 	brhi	80006e48 <log+0xd0>
80006dea:	4b 89       	lddpc	r9,80006ec8 <log+0x150>
80006dec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006df0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006df4:	06 9a       	mov	r10,r3
80006df6:	40 0b       	lddsp	r11,sp[0x0]
80006df8:	5c 5b       	castu.b	r11
80006dfa:	68 0c       	ld.w	r12,r4[0x0]
80006dfc:	f0 1f 00 34 	mcall	80006ecc <log+0x154>
							break;
80006e00:	c2 98       	rjmp	80006e52 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006e02:	4b 4c       	lddpc	r12,80006ed0 <log+0x158>
80006e04:	f0 1f 00 34 	mcall	80006ed4 <log+0x15c>
80006e08:	08 95       	mov	r5,r4
80006e0a:	06 9c       	mov	r12,r3
							break;
80006e0c:	c2 38       	rjmp	80006e52 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e0e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e12:	06 9a       	mov	r10,r3
80006e14:	40 0b       	lddsp	r11,sp[0x0]
80006e16:	5c 5b       	castu.b	r11
80006e18:	68 0c       	ld.w	r12,r4[0x0]
80006e1a:	f0 1f 00 30 	mcall	80006ed8 <log+0x160>
80006e1e:	06 9c       	mov	r12,r3
							break;
80006e20:	c1 98       	rjmp	80006e52 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006e22:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006e26:	06 9b       	mov	r11,r3
80006e28:	09 bc       	ld.ub	r12,r4[0x3]
80006e2a:	f0 1f 00 2d 	mcall	80006edc <log+0x164>
80006e2e:	06 9c       	mov	r12,r3
							break;
80006e30:	c1 18       	rjmp	80006e52 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006e32:	e8 c5 ff fc 	sub	r5,r4,-4
80006e36:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006e38:	c0 d8       	rjmp	80006e52 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006e3a:	06 9b       	mov	r11,r3
80006e3c:	32 5c       	mov	r12,37
80006e3e:	f0 1f 00 28 	mcall	80006edc <log+0x164>
80006e42:	08 95       	mov	r5,r4
80006e44:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006e46:	c0 68       	rjmp	80006e52 <log+0xda>
							
							default:
							log("I need relax.");
80006e48:	4a 6c       	lddpc	r12,80006ee0 <log+0x168>
80006e4a:	f0 1f 00 23 	mcall	80006ed4 <log+0x15c>
80006e4e:	08 95       	mov	r5,r4
80006e50:	06 9c       	mov	r12,r3
						}
						str++;
80006e52:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e54:	1a dc       	st.w	--sp,r12
80006e56:	1a d6       	st.w	--sp,r6
80006e58:	4a 3b       	lddpc	r11,80006ee4 <log+0x16c>
80006e5a:	0c 9c       	mov	r12,r6
80006e5c:	f0 1f 00 23 	mcall	80006ee8 <log+0x170>
80006e60:	2f ed       	sub	sp,-8
80006e62:	c0 a8       	rjmp	80006e76 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e64:	2f f7       	sub	r7,-1
80006e66:	1a d8       	st.w	--sp,r8
80006e68:	1a d6       	st.w	--sp,r6
80006e6a:	4a 1b       	lddpc	r11,80006eec <log+0x174>
80006e6c:	0c 9c       	mov	r12,r6
80006e6e:	f0 1f 00 1f 	mcall	80006ee8 <log+0x170>
80006e72:	08 95       	mov	r5,r4
80006e74:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e76:	0f 89       	ld.ub	r9,r7[0x0]
80006e78:	30 08       	mov	r8,0
80006e7a:	f0 09 18 00 	cp.b	r9,r8
80006e7e:	c0 30       	breq	80006e84 <log+0x10c>
80006e80:	0a 94       	mov	r4,r5
80006e82:	c9 2b       	rjmp	80006da6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e84:	fa c7 fe f8 	sub	r7,sp,-264
80006e88:	1a d7       	st.w	--sp,r7
80006e8a:	49 ab       	lddpc	r11,80006ef0 <log+0x178>
80006e8c:	0e 9c       	mov	r12,r7
80006e8e:	f0 1f 00 17 	mcall	80006ee8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e92:	5c 5c       	castu.b	r12
80006e94:	f8 c6 ff ff 	sub	r6,r12,-1
80006e98:	0c 9c       	mov	r12,r6
80006e9a:	f0 1f 00 17 	mcall	80006ef4 <log+0x17c>
80006e9e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006ea0:	0c 9a       	mov	r10,r6
80006ea2:	0e 9b       	mov	r11,r7
80006ea4:	f0 1f 00 15 	mcall	80006ef8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006ea8:	30 09       	mov	r9,0
80006eaa:	30 5a       	mov	r10,5
80006eac:	fa cb fe f8 	sub	r11,sp,-264
80006eb0:	49 38       	lddpc	r8,80006efc <log+0x184>
80006eb2:	70 0c       	ld.w	r12,r8[0x0]
80006eb4:	f0 1f 00 13 	mcall	80006f00 <log+0x188>
80006eb8:	2f fd       	sub	sp,-4
	
	
}
80006eba:	fe 3d fd f8 	sub	sp,-520
80006ebe:	d8 32       	popm	r0-r7,pc
80006ec0:	80 00       	ld.sh	r0,r0[0x0]
80006ec2:	77 54       	ld.w	r4,r11[0x54]
80006ec4:	00 00       	add	r0,r0
80006ec6:	0d 48       	ld.w	r8,--r6
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	d6 cc       	*unknown*
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	6c 9e       	ld.w	lr,r6[0x24]
80006ed0:	80 00       	ld.sh	r0,r0[0x0]
80006ed2:	d9 78       	*unknown*
80006ed4:	80 00       	ld.sh	r0,r0[0x0]
80006ed6:	6d 78       	ld.w	r8,r6[0x5c]
80006ed8:	80 00       	ld.sh	r0,r0[0x0]
80006eda:	6b ec       	ld.w	r12,r5[0x78]
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	6b e8       	ld.w	r8,r5[0x78]
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	d9 88       	*unknown*
80006ee4:	80 00       	ld.sh	r0,r0[0x0]
80006ee6:	d9 98       	*unknown*
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	7a 44       	ld.w	r4,sp[0x10]
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	d9 a0       	acall	0x9a
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	d9 a8       	*unknown*
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	5e 8c       	retls	r12
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	76 0c       	ld.w	r12,r11[0x0]
80006efc:	00 00       	add	r0,r0
80006efe:	51 20       	stdsp	sp[0x48],r0
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	61 e0       	ld.w	r0,r0[0x78]

80006f04 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f04:	d4 31       	pushm	r0-r7,lr
80006f06:	fa cd 02 0c 	sub	sp,sp,524
80006f0a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f0c:	e0 6a 01 00 	mov	r10,256
80006f10:	30 0b       	mov	r11,0
80006f12:	fa cc fe f4 	sub	r12,sp,-268
80006f16:	f0 1f 00 4c 	mcall	80007044 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f1a:	fa c4 fd d0 	sub	r4,sp,-560
80006f1e:	30 0a       	mov	r10,0
80006f20:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f22:	fa c3 ff fc 	sub	r3,sp,-4
80006f26:	e0 61 01 00 	mov	r1,256
80006f2a:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006f2c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f2e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f32:	02 9a       	mov	r10,r1
80006f34:	00 9b       	mov	r11,r0
80006f36:	06 9c       	mov	r12,r3
80006f38:	f0 1f 00 43 	mcall	80007044 <logFromISR+0x140>
			
			if(*str == '%')
80006f3c:	0f 88       	ld.ub	r8,r7[0x0]
80006f3e:	e4 08 18 00 	cp.b	r8,r2
80006f42:	c5 11       	brne	80006fe4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006f44:	ee c8 ff ff 	sub	r8,r7,-1
80006f48:	11 89       	ld.ub	r9,r8[0x0]
80006f4a:	4c 0a       	lddpc	r10,80007048 <logFromISR+0x144>
80006f4c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f4e:	23 09       	sub	r9,48
80006f50:	30 9a       	mov	r10,9
80006f52:	f4 09 18 00 	cp.b	r9,r10
80006f56:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006f5a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f5e:	f7 b9 08 30 	subls	r9,48
80006f62:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f66:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f6a:	0f 88       	ld.ub	r8,r7[0x0]
80006f6c:	22 58       	sub	r8,37
80006f6e:	e0 48 00 53 	cp.w	r8,83
80006f72:	e0 8b 00 2b 	brhi	80006fc8 <logFromISR+0xc4>
80006f76:	4b 69       	lddpc	r9,8000704c <logFromISR+0x148>
80006f78:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f7c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f80:	06 9a       	mov	r10,r3
80006f82:	40 0b       	lddsp	r11,sp[0x0]
80006f84:	5c 5b       	castu.b	r11
80006f86:	68 0c       	ld.w	r12,r4[0x0]
80006f88:	f0 1f 00 32 	mcall	80007050 <logFromISR+0x14c>
					break;
80006f8c:	c2 38       	rjmp	80006fd2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f8e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f92:	06 9a       	mov	r10,r3
80006f94:	40 0b       	lddsp	r11,sp[0x0]
80006f96:	5c 5b       	castu.b	r11
80006f98:	68 0c       	ld.w	r12,r4[0x0]
80006f9a:	f0 1f 00 2f 	mcall	80007054 <logFromISR+0x150>
80006f9e:	06 9c       	mov	r12,r3
					break;
80006fa0:	c1 98       	rjmp	80006fd2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006fa2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006fa6:	06 9b       	mov	r11,r3
80006fa8:	09 bc       	ld.ub	r12,r4[0x3]
80006faa:	f0 1f 00 2c 	mcall	80007058 <logFromISR+0x154>
80006fae:	06 9c       	mov	r12,r3
					break;
80006fb0:	c1 18       	rjmp	80006fd2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006fb2:	e8 c5 ff fc 	sub	r5,r4,-4
80006fb6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006fb8:	c0 d8       	rjmp	80006fd2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006fba:	06 9b       	mov	r11,r3
80006fbc:	32 5c       	mov	r12,37
80006fbe:	f0 1f 00 27 	mcall	80007058 <logFromISR+0x154>
80006fc2:	08 95       	mov	r5,r4
80006fc4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006fc6:	c0 68       	rjmp	80006fd2 <logFromISR+0xce>
					default:
					log("I need relax.");
80006fc8:	4a 5c       	lddpc	r12,8000705c <logFromISR+0x158>
80006fca:	f0 1f 00 26 	mcall	80007060 <logFromISR+0x15c>
80006fce:	08 95       	mov	r5,r4
80006fd0:	06 9c       	mov	r12,r3
				}
				str++;
80006fd2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006fd4:	1a dc       	st.w	--sp,r12
80006fd6:	1a d6       	st.w	--sp,r6
80006fd8:	4a 3b       	lddpc	r11,80007064 <logFromISR+0x160>
80006fda:	0c 9c       	mov	r12,r6
80006fdc:	f0 1f 00 23 	mcall	80007068 <logFromISR+0x164>
80006fe0:	2f ed       	sub	sp,-8
80006fe2:	c0 a8       	rjmp	80006ff6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fe4:	2f f7       	sub	r7,-1
80006fe6:	1a d8       	st.w	--sp,r8
80006fe8:	1a d6       	st.w	--sp,r6
80006fea:	4a 1b       	lddpc	r11,8000706c <logFromISR+0x168>
80006fec:	0c 9c       	mov	r12,r6
80006fee:	f0 1f 00 1f 	mcall	80007068 <logFromISR+0x164>
80006ff2:	08 95       	mov	r5,r4
80006ff4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006ff6:	0f 89       	ld.ub	r9,r7[0x0]
80006ff8:	30 08       	mov	r8,0
80006ffa:	f0 09 18 00 	cp.b	r9,r8
80006ffe:	c0 30       	breq	80007004 <logFromISR+0x100>
80007000:	0a 94       	mov	r4,r5
80007002:	c9 8b       	rjmp	80006f32 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007004:	fa c7 fe f4 	sub	r7,sp,-268
80007008:	1a d7       	st.w	--sp,r7
8000700a:	49 ab       	lddpc	r11,80007070 <logFromISR+0x16c>
8000700c:	0e 9c       	mov	r12,r7
8000700e:	f0 1f 00 17 	mcall	80007068 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007012:	5c 5c       	castu.b	r12
80007014:	f8 c6 ff ff 	sub	r6,r12,-1
80007018:	0c 9c       	mov	r12,r6
8000701a:	f0 1f 00 17 	mcall	80007074 <logFromISR+0x170>
8000701e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007020:	0c 9a       	mov	r10,r6
80007022:	0e 9b       	mov	r11,r7
80007024:	f0 1f 00 15 	mcall	80007078 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007028:	30 09       	mov	r9,0
8000702a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000702c:	fa ca fe f8 	sub	r10,sp,-264
80007030:	fa cb fe f4 	sub	r11,sp,-268
80007034:	49 28       	lddpc	r8,8000707c <logFromISR+0x178>
80007036:	70 0c       	ld.w	r12,r8[0x0]
80007038:	f0 1f 00 12 	mcall	80007080 <logFromISR+0x17c>
8000703c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000703e:	fe 3d fd f4 	sub	sp,-524
80007042:	d8 32       	popm	r0-r7,pc
80007044:	80 00       	ld.sh	r0,r0[0x0]
80007046:	77 54       	ld.w	r4,r11[0x54]
80007048:	00 00       	add	r0,r0
8000704a:	0d 49       	ld.w	r9,--r6
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	d8 1c       	*unknown*
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	6c 9e       	ld.w	lr,r6[0x24]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	6b ec       	ld.w	r12,r5[0x78]
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	6b e8       	ld.w	r8,r5[0x78]
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	d9 88       	*unknown*
80007060:	80 00       	ld.sh	r0,r0[0x0]
80007062:	6d 78       	ld.w	r8,r6[0x5c]
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	d9 98       	*unknown*
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	7a 44       	ld.w	r4,sp[0x10]
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	d9 a0       	acall	0x9a
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	d9 a8       	*unknown*
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	5e 8c       	retls	r12
80007078:	80 00       	ld.sh	r0,r0[0x0]
8000707a:	76 0c       	ld.w	r12,r11[0x0]
8000707c:	00 00       	add	r0,r0
8000707e:	51 20       	stdsp	sp[0x48],r0
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	61 90       	ld.w	r0,r0[0x64]

80007084 <log_init>:
		
	return str;
}

void log_init(void)
{
80007084:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007086:	30 2b       	mov	r11,2
80007088:	49 0c       	lddpc	r12,800070c8 <log_init+0x44>
8000708a:	f0 1f 00 11 	mcall	800070cc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000708e:	e0 6a 36 00 	mov	r10,13824
80007092:	ea 1a 01 6e 	orh	r10,0x16e
80007096:	48 fb       	lddpc	r11,800070d0 <log_init+0x4c>
80007098:	fe 7c 18 00 	mov	r12,-59392
8000709c:	f0 1f 00 0e 	mcall	800070d4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800070a0:	30 4b       	mov	r11,4
800070a2:	33 2c       	mov	r12,50
800070a4:	f0 1f 00 0d 	mcall	800070d8 <log_init+0x54>
800070a8:	48 d8       	lddpc	r8,800070dc <log_init+0x58>
800070aa:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800070ac:	30 09       	mov	r9,0
800070ae:	1a d9       	st.w	--sp,r9
800070b0:	1a d9       	st.w	--sp,r9
800070b2:	1a d9       	st.w	--sp,r9
800070b4:	30 28       	mov	r8,2
800070b6:	e0 6a 01 80 	mov	r10,384
800070ba:	48 ab       	lddpc	r11,800070e0 <log_init+0x5c>
800070bc:	48 ac       	lddpc	r12,800070e4 <log_init+0x60>
800070be:	f0 1f 00 0b 	mcall	800070e8 <log_init+0x64>
800070c2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800070c4:	d8 02       	popm	pc
800070c6:	00 00       	add	r0,r0
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	d9 b4       	*unknown*
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	54 bc       	stdsp	sp[0x12c],r12
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	d9 6c       	*unknown*
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	59 f0       	cp.w	r0,31
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	62 e0       	ld.w	r0,r1[0x38]
800070dc:	00 00       	add	r0,r0
800070de:	51 20       	stdsp	sp[0x48],r0
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	d9 b0       	acall	0x9b
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	70 ec       	ld.w	r12,r8[0x38]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	69 b4       	ld.w	r4,r4[0x6c]

800070ec <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800070ec:	eb cd 40 f8 	pushm	r3-r7,lr
800070f0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070f2:	48 c7       	lddpc	r7,80007120 <task_log+0x34>
800070f4:	30 05       	mov	r5,0
800070f6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800070f8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070fc:	0a 99       	mov	r9,r5
800070fe:	08 9a       	mov	r10,r4
80007100:	1a 9b       	mov	r11,sp
80007102:	6e 0c       	ld.w	r12,r7[0x0]
80007104:	f0 1f 00 08 	mcall	80007124 <task_log+0x38>
80007108:	58 1c       	cp.w	r12,1
8000710a:	cf 91       	brne	800070fc <task_log+0x10>
		{
			if( NULL != str)
8000710c:	40 0b       	lddsp	r11,sp[0x0]
8000710e:	58 0b       	cp.w	r11,0
80007110:	cf 60       	breq	800070fc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007112:	06 9c       	mov	r12,r3
80007114:	f0 1f 00 05 	mcall	80007128 <task_log+0x3c>
				vPortFree(str);
80007118:	40 0c       	lddsp	r12,sp[0x0]
8000711a:	f0 1f 00 05 	mcall	8000712c <task_log+0x40>
8000711e:	ce fb       	rjmp	800070fc <task_log+0x10>
80007120:	00 00       	add	r0,r0
80007122:	51 20       	stdsp	sp[0x48],r0
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	5f d4       	srvc	r4
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	59 a0       	cp.w	r0,26
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	5e 64       	retmi	r4

80007130 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80007130:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007132:	fe 78 10 00 	mov	r8,-61440
80007136:	30 19       	mov	r9,1
80007138:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000713c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007140:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007144:	d3 03       	ssrf	0x10
	local_start_pll0();
80007146:	f0 1f 00 12 	mcall	8000718c <main+0x5c>
		
	INTC_init_interrupts();
8000714a:	f0 1f 00 12 	mcall	80007190 <main+0x60>
		
	log_init();
8000714e:	f0 1f 00 12 	mcall	80007194 <main+0x64>
	log("----start debug----");
80007152:	49 2c       	lddpc	r12,80007198 <main+0x68>
80007154:	f0 1f 00 12 	mcall	8000719c <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007158:	f0 1f 00 12 	mcall	800071a0 <main+0x70>
		
	app_init();
8000715c:	f0 1f 00 12 	mcall	800071a4 <main+0x74>
		
	xcmp_init();
80007160:	f0 1f 00 12 	mcall	800071a8 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80007164:	fe 79 10 00 	mov	r9,-61440
80007168:	f2 f8 01 60 	ld.w	r8,r9[352]
8000716c:	e2 18 00 02 	andl	r8,0x2,COH
80007170:	cf c0       	breq	80007168 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80007172:	fe 79 10 00 	mov	r9,-61440
80007176:	f2 f8 01 60 	ld.w	r8,r9[352]
8000717a:	e2 18 00 02 	andl	r8,0x2,COH
8000717e:	cf c1       	brne	80007176 <main+0x46>
	local_start_timer();
80007180:	f0 1f 00 0b 	mcall	800071ac <main+0x7c>
		
	Enable_global_interrupt();
80007184:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80007186:	f0 1f 00 0b 	mcall	800071b0 <main+0x80>
	return 0;
	
}
8000718a:	d8 0a       	popm	pc,r12=0
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	53 e0       	stdsp	sp[0xf8],r0
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	55 c0       	stdsp	sp[0x170],r0
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	70 84       	ld.w	r4,r8[0x20]
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	d9 c4       	*unknown*
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	6d 78       	ld.w	r8,r6[0x5c]
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	53 d4       	stdsp	sp[0xf4],r4
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	20 3c       	sub	r12,3
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	42 ac       	lddsp	r12,sp[0xa8]
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	54 30       	stdsp	sp[0x10c],r0
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	6b 9c       	ld.w	r12,r5[0x64]

800071b4 <free>:
800071b4:	d4 01       	pushm	lr
800071b6:	e0 68 0a 38 	mov	r8,2616
800071ba:	18 9b       	mov	r11,r12
800071bc:	70 0c       	ld.w	r12,r8[0x0]
800071be:	e0 a0 1e 61 	rcall	8000ae80 <_free_r>
800071c2:	d8 02       	popm	pc

800071c4 <malloc>:
800071c4:	d4 01       	pushm	lr
800071c6:	e0 68 0a 38 	mov	r8,2616
800071ca:	18 9b       	mov	r11,r12
800071cc:	70 0c       	ld.w	r12,r8[0x0]
800071ce:	c0 3c       	rcall	800071d4 <_malloc_r>
800071d0:	d8 02       	popm	pc
800071d2:	d7 03       	nop

800071d4 <_malloc_r>:
800071d4:	d4 31       	pushm	r0-r7,lr
800071d6:	f6 c8 ff f5 	sub	r8,r11,-11
800071da:	18 95       	mov	r5,r12
800071dc:	10 97       	mov	r7,r8
800071de:	e0 17 ff f8 	andl	r7,0xfff8
800071e2:	59 68       	cp.w	r8,22
800071e4:	f9 b7 08 10 	movls	r7,16
800071e8:	16 37       	cp.w	r7,r11
800071ea:	5f 38       	srlo	r8
800071ec:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800071f0:	c0 50       	breq	800071fa <_malloc_r+0x26>
800071f2:	30 c8       	mov	r8,12
800071f4:	99 38       	st.w	r12[0xc],r8
800071f6:	e0 8f 01 fa 	bral	800075ea <_malloc_r+0x416>
800071fa:	fe b0 f5 eb 	rcall	80005dd0 <__malloc_lock>
800071fe:	e0 47 01 f7 	cp.w	r7,503
80007202:	e0 8b 00 1d 	brhi	8000723c <_malloc_r+0x68>
80007206:	ee 03 16 03 	lsr	r3,r7,0x3
8000720a:	e0 68 05 38 	mov	r8,1336
8000720e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007212:	70 36       	ld.w	r6,r8[0xc]
80007214:	10 36       	cp.w	r6,r8
80007216:	c0 61       	brne	80007222 <_malloc_r+0x4e>
80007218:	ec c8 ff f8 	sub	r8,r6,-8
8000721c:	70 36       	ld.w	r6,r8[0xc]
8000721e:	10 36       	cp.w	r6,r8
80007220:	c0 c0       	breq	80007238 <_malloc_r+0x64>
80007222:	6c 18       	ld.w	r8,r6[0x4]
80007224:	e0 18 ff fc 	andl	r8,0xfffc
80007228:	6c 3a       	ld.w	r10,r6[0xc]
8000722a:	ec 08 00 09 	add	r9,r6,r8
8000722e:	0a 9c       	mov	r12,r5
80007230:	6c 28       	ld.w	r8,r6[0x8]
80007232:	95 28       	st.w	r10[0x8],r8
80007234:	91 3a       	st.w	r8[0xc],r10
80007236:	c4 78       	rjmp	800072c4 <_malloc_r+0xf0>
80007238:	2f e3       	sub	r3,-2
8000723a:	c4 d8       	rjmp	800072d4 <_malloc_r+0x100>
8000723c:	ee 03 16 09 	lsr	r3,r7,0x9
80007240:	c0 41       	brne	80007248 <_malloc_r+0x74>
80007242:	ee 03 16 03 	lsr	r3,r7,0x3
80007246:	c2 68       	rjmp	80007292 <_malloc_r+0xbe>
80007248:	58 43       	cp.w	r3,4
8000724a:	e0 8b 00 06 	brhi	80007256 <_malloc_r+0x82>
8000724e:	ee 03 16 06 	lsr	r3,r7,0x6
80007252:	2c 83       	sub	r3,-56
80007254:	c1 f8       	rjmp	80007292 <_malloc_r+0xbe>
80007256:	59 43       	cp.w	r3,20
80007258:	e0 8b 00 04 	brhi	80007260 <_malloc_r+0x8c>
8000725c:	2a 53       	sub	r3,-91
8000725e:	c1 a8       	rjmp	80007292 <_malloc_r+0xbe>
80007260:	e0 43 00 54 	cp.w	r3,84
80007264:	e0 8b 00 06 	brhi	80007270 <_malloc_r+0x9c>
80007268:	ee 03 16 0c 	lsr	r3,r7,0xc
8000726c:	29 23       	sub	r3,-110
8000726e:	c1 28       	rjmp	80007292 <_malloc_r+0xbe>
80007270:	e0 43 01 54 	cp.w	r3,340
80007274:	e0 8b 00 06 	brhi	80007280 <_malloc_r+0xac>
80007278:	ee 03 16 0f 	lsr	r3,r7,0xf
8000727c:	28 93       	sub	r3,-119
8000727e:	c0 a8       	rjmp	80007292 <_malloc_r+0xbe>
80007280:	e0 43 05 54 	cp.w	r3,1364
80007284:	e0 88 00 04 	brls	8000728c <_malloc_r+0xb8>
80007288:	37 e3       	mov	r3,126
8000728a:	c0 48       	rjmp	80007292 <_malloc_r+0xbe>
8000728c:	ee 03 16 12 	lsr	r3,r7,0x12
80007290:	28 43       	sub	r3,-124
80007292:	e0 6a 05 38 	mov	r10,1336
80007296:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000729a:	74 36       	ld.w	r6,r10[0xc]
8000729c:	c1 98       	rjmp	800072ce <_malloc_r+0xfa>
8000729e:	6c 19       	ld.w	r9,r6[0x4]
800072a0:	e0 19 ff fc 	andl	r9,0xfffc
800072a4:	f2 07 01 0b 	sub	r11,r9,r7
800072a8:	58 fb       	cp.w	r11,15
800072aa:	e0 8a 00 04 	brle	800072b2 <_malloc_r+0xde>
800072ae:	20 13       	sub	r3,1
800072b0:	c1 18       	rjmp	800072d2 <_malloc_r+0xfe>
800072b2:	6c 38       	ld.w	r8,r6[0xc]
800072b4:	58 0b       	cp.w	r11,0
800072b6:	c0 b5       	brlt	800072cc <_malloc_r+0xf8>
800072b8:	6c 2a       	ld.w	r10,r6[0x8]
800072ba:	ec 09 00 09 	add	r9,r6,r9
800072be:	0a 9c       	mov	r12,r5
800072c0:	91 2a       	st.w	r8[0x8],r10
800072c2:	95 38       	st.w	r10[0xc],r8
800072c4:	72 18       	ld.w	r8,r9[0x4]
800072c6:	a1 a8       	sbr	r8,0x0
800072c8:	93 18       	st.w	r9[0x4],r8
800072ca:	cb c8       	rjmp	80007442 <_malloc_r+0x26e>
800072cc:	10 96       	mov	r6,r8
800072ce:	14 36       	cp.w	r6,r10
800072d0:	ce 71       	brne	8000729e <_malloc_r+0xca>
800072d2:	2f f3       	sub	r3,-1
800072d4:	e0 6a 05 38 	mov	r10,1336
800072d8:	f4 cc ff f8 	sub	r12,r10,-8
800072dc:	78 26       	ld.w	r6,r12[0x8]
800072de:	18 36       	cp.w	r6,r12
800072e0:	c6 c0       	breq	800073b8 <_malloc_r+0x1e4>
800072e2:	6c 19       	ld.w	r9,r6[0x4]
800072e4:	e0 19 ff fc 	andl	r9,0xfffc
800072e8:	f2 07 01 08 	sub	r8,r9,r7
800072ec:	58 f8       	cp.w	r8,15
800072ee:	e0 89 00 8f 	brgt	8000740c <_malloc_r+0x238>
800072f2:	99 3c       	st.w	r12[0xc],r12
800072f4:	99 2c       	st.w	r12[0x8],r12
800072f6:	58 08       	cp.w	r8,0
800072f8:	c0 55       	brlt	80007302 <_malloc_r+0x12e>
800072fa:	ec 09 00 09 	add	r9,r6,r9
800072fe:	0a 9c       	mov	r12,r5
80007300:	ce 2b       	rjmp	800072c4 <_malloc_r+0xf0>
80007302:	e0 49 01 ff 	cp.w	r9,511
80007306:	e0 8b 00 13 	brhi	8000732c <_malloc_r+0x158>
8000730a:	a3 99       	lsr	r9,0x3
8000730c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007310:	70 2b       	ld.w	r11,r8[0x8]
80007312:	8d 38       	st.w	r6[0xc],r8
80007314:	8d 2b       	st.w	r6[0x8],r11
80007316:	97 36       	st.w	r11[0xc],r6
80007318:	91 26       	st.w	r8[0x8],r6
8000731a:	a3 49       	asr	r9,0x2
8000731c:	74 18       	ld.w	r8,r10[0x4]
8000731e:	30 1b       	mov	r11,1
80007320:	f6 09 09 49 	lsl	r9,r11,r9
80007324:	f1 e9 10 09 	or	r9,r8,r9
80007328:	95 19       	st.w	r10[0x4],r9
8000732a:	c4 78       	rjmp	800073b8 <_malloc_r+0x1e4>
8000732c:	f2 0a 16 09 	lsr	r10,r9,0x9
80007330:	58 4a       	cp.w	r10,4
80007332:	e0 8b 00 07 	brhi	80007340 <_malloc_r+0x16c>
80007336:	f2 0a 16 06 	lsr	r10,r9,0x6
8000733a:	2c 8a       	sub	r10,-56
8000733c:	c2 08       	rjmp	8000737c <_malloc_r+0x1a8>
8000733e:	d7 03       	nop
80007340:	59 4a       	cp.w	r10,20
80007342:	e0 8b 00 04 	brhi	8000734a <_malloc_r+0x176>
80007346:	2a 5a       	sub	r10,-91
80007348:	c1 a8       	rjmp	8000737c <_malloc_r+0x1a8>
8000734a:	e0 4a 00 54 	cp.w	r10,84
8000734e:	e0 8b 00 06 	brhi	8000735a <_malloc_r+0x186>
80007352:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007356:	29 2a       	sub	r10,-110
80007358:	c1 28       	rjmp	8000737c <_malloc_r+0x1a8>
8000735a:	e0 4a 01 54 	cp.w	r10,340
8000735e:	e0 8b 00 06 	brhi	8000736a <_malloc_r+0x196>
80007362:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007366:	28 9a       	sub	r10,-119
80007368:	c0 a8       	rjmp	8000737c <_malloc_r+0x1a8>
8000736a:	e0 4a 05 54 	cp.w	r10,1364
8000736e:	e0 88 00 04 	brls	80007376 <_malloc_r+0x1a2>
80007372:	37 ea       	mov	r10,126
80007374:	c0 48       	rjmp	8000737c <_malloc_r+0x1a8>
80007376:	f2 0a 16 12 	lsr	r10,r9,0x12
8000737a:	28 4a       	sub	r10,-124
8000737c:	e0 6b 05 38 	mov	r11,1336
80007380:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007384:	68 28       	ld.w	r8,r4[0x8]
80007386:	08 38       	cp.w	r8,r4
80007388:	c0 e1       	brne	800073a4 <_malloc_r+0x1d0>
8000738a:	76 19       	ld.w	r9,r11[0x4]
8000738c:	a3 4a       	asr	r10,0x2
8000738e:	30 1e       	mov	lr,1
80007390:	fc 0a 09 4a 	lsl	r10,lr,r10
80007394:	f3 ea 10 0a 	or	r10,r9,r10
80007398:	10 99       	mov	r9,r8
8000739a:	97 1a       	st.w	r11[0x4],r10
8000739c:	c0 a8       	rjmp	800073b0 <_malloc_r+0x1dc>
8000739e:	70 28       	ld.w	r8,r8[0x8]
800073a0:	08 38       	cp.w	r8,r4
800073a2:	c0 60       	breq	800073ae <_malloc_r+0x1da>
800073a4:	70 1a       	ld.w	r10,r8[0x4]
800073a6:	e0 1a ff fc 	andl	r10,0xfffc
800073aa:	14 39       	cp.w	r9,r10
800073ac:	cf 93       	brcs	8000739e <_malloc_r+0x1ca>
800073ae:	70 39       	ld.w	r9,r8[0xc]
800073b0:	8d 39       	st.w	r6[0xc],r9
800073b2:	8d 28       	st.w	r6[0x8],r8
800073b4:	91 36       	st.w	r8[0xc],r6
800073b6:	93 26       	st.w	r9[0x8],r6
800073b8:	e6 08 14 02 	asr	r8,r3,0x2
800073bc:	30 1b       	mov	r11,1
800073be:	e0 64 05 38 	mov	r4,1336
800073c2:	f6 08 09 4b 	lsl	r11,r11,r8
800073c6:	68 18       	ld.w	r8,r4[0x4]
800073c8:	10 3b       	cp.w	r11,r8
800073ca:	e0 8b 00 6b 	brhi	800074a0 <_malloc_r+0x2cc>
800073ce:	f7 e8 00 09 	and	r9,r11,r8
800073d2:	c0 b1       	brne	800073e8 <_malloc_r+0x214>
800073d4:	e0 13 ff fc 	andl	r3,0xfffc
800073d8:	a1 7b       	lsl	r11,0x1
800073da:	2f c3       	sub	r3,-4
800073dc:	c0 38       	rjmp	800073e2 <_malloc_r+0x20e>
800073de:	2f c3       	sub	r3,-4
800073e0:	a1 7b       	lsl	r11,0x1
800073e2:	f7 e8 00 09 	and	r9,r11,r8
800073e6:	cf c0       	breq	800073de <_malloc_r+0x20a>
800073e8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800073ec:	06 92       	mov	r2,r3
800073ee:	1c 91       	mov	r1,lr
800073f0:	62 36       	ld.w	r6,r1[0xc]
800073f2:	c2 e8       	rjmp	8000744e <_malloc_r+0x27a>
800073f4:	6c 1a       	ld.w	r10,r6[0x4]
800073f6:	e0 1a ff fc 	andl	r10,0xfffc
800073fa:	f4 07 01 08 	sub	r8,r10,r7
800073fe:	58 f8       	cp.w	r8,15
80007400:	e0 8a 00 15 	brle	8000742a <_malloc_r+0x256>
80007404:	6c 3a       	ld.w	r10,r6[0xc]
80007406:	6c 29       	ld.w	r9,r6[0x8]
80007408:	95 29       	st.w	r10[0x8],r9
8000740a:	93 3a       	st.w	r9[0xc],r10
8000740c:	0e 99       	mov	r9,r7
8000740e:	ec 07 00 07 	add	r7,r6,r7
80007412:	a1 a9       	sbr	r9,0x0
80007414:	99 37       	st.w	r12[0xc],r7
80007416:	99 27       	st.w	r12[0x8],r7
80007418:	8d 19       	st.w	r6[0x4],r9
8000741a:	ee 08 09 08 	st.w	r7[r8],r8
8000741e:	8f 2c       	st.w	r7[0x8],r12
80007420:	8f 3c       	st.w	r7[0xc],r12
80007422:	a1 a8       	sbr	r8,0x0
80007424:	0a 9c       	mov	r12,r5
80007426:	8f 18       	st.w	r7[0x4],r8
80007428:	c0 d8       	rjmp	80007442 <_malloc_r+0x26e>
8000742a:	6c 39       	ld.w	r9,r6[0xc]
8000742c:	58 08       	cp.w	r8,0
8000742e:	c0 f5       	brlt	8000744c <_malloc_r+0x278>
80007430:	ec 0a 00 0a 	add	r10,r6,r10
80007434:	74 18       	ld.w	r8,r10[0x4]
80007436:	a1 a8       	sbr	r8,0x0
80007438:	0a 9c       	mov	r12,r5
8000743a:	95 18       	st.w	r10[0x4],r8
8000743c:	6c 28       	ld.w	r8,r6[0x8]
8000743e:	93 28       	st.w	r9[0x8],r8
80007440:	91 39       	st.w	r8[0xc],r9
80007442:	fe b0 f4 cd 	rcall	80005ddc <__malloc_unlock>
80007446:	ec cc ff f8 	sub	r12,r6,-8
8000744a:	d8 32       	popm	r0-r7,pc
8000744c:	12 96       	mov	r6,r9
8000744e:	02 36       	cp.w	r6,r1
80007450:	cd 21       	brne	800073f4 <_malloc_r+0x220>
80007452:	2f f2       	sub	r2,-1
80007454:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007458:	c0 30       	breq	8000745e <_malloc_r+0x28a>
8000745a:	2f 81       	sub	r1,-8
8000745c:	cc ab       	rjmp	800073f0 <_malloc_r+0x21c>
8000745e:	1c 98       	mov	r8,lr
80007460:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007464:	c0 81       	brne	80007474 <_malloc_r+0x2a0>
80007466:	68 19       	ld.w	r9,r4[0x4]
80007468:	f6 08 11 ff 	rsub	r8,r11,-1
8000746c:	f3 e8 00 08 	and	r8,r9,r8
80007470:	89 18       	st.w	r4[0x4],r8
80007472:	c0 78       	rjmp	80007480 <_malloc_r+0x2ac>
80007474:	f0 c9 00 08 	sub	r9,r8,8
80007478:	20 13       	sub	r3,1
8000747a:	70 08       	ld.w	r8,r8[0x0]
8000747c:	12 38       	cp.w	r8,r9
8000747e:	cf 10       	breq	80007460 <_malloc_r+0x28c>
80007480:	a1 7b       	lsl	r11,0x1
80007482:	68 18       	ld.w	r8,r4[0x4]
80007484:	10 3b       	cp.w	r11,r8
80007486:	e0 8b 00 0d 	brhi	800074a0 <_malloc_r+0x2cc>
8000748a:	58 0b       	cp.w	r11,0
8000748c:	c0 a0       	breq	800074a0 <_malloc_r+0x2cc>
8000748e:	04 93       	mov	r3,r2
80007490:	c0 38       	rjmp	80007496 <_malloc_r+0x2c2>
80007492:	2f c3       	sub	r3,-4
80007494:	a1 7b       	lsl	r11,0x1
80007496:	f7 e8 00 09 	and	r9,r11,r8
8000749a:	ca 71       	brne	800073e8 <_malloc_r+0x214>
8000749c:	cf bb       	rjmp	80007492 <_malloc_r+0x2be>
8000749e:	d7 03       	nop
800074a0:	68 23       	ld.w	r3,r4[0x8]
800074a2:	66 12       	ld.w	r2,r3[0x4]
800074a4:	e0 12 ff fc 	andl	r2,0xfffc
800074a8:	0e 32       	cp.w	r2,r7
800074aa:	5f 39       	srlo	r9
800074ac:	e4 07 01 08 	sub	r8,r2,r7
800074b0:	58 f8       	cp.w	r8,15
800074b2:	5f aa       	srle	r10
800074b4:	f5 e9 10 09 	or	r9,r10,r9
800074b8:	e0 80 00 9a 	breq	800075ec <_malloc_r+0x418>
800074bc:	e0 68 0d 54 	mov	r8,3412
800074c0:	70 01       	ld.w	r1,r8[0x0]
800074c2:	e0 68 09 44 	mov	r8,2372
800074c6:	2f 01       	sub	r1,-16
800074c8:	70 08       	ld.w	r8,r8[0x0]
800074ca:	0e 01       	add	r1,r7
800074cc:	5b f8       	cp.w	r8,-1
800074ce:	c0 40       	breq	800074d6 <_malloc_r+0x302>
800074d0:	28 11       	sub	r1,-127
800074d2:	e0 11 ff 80 	andl	r1,0xff80
800074d6:	02 9b       	mov	r11,r1
800074d8:	0a 9c       	mov	r12,r5
800074da:	e0 a0 02 a5 	rcall	80007a24 <_sbrk_r>
800074de:	18 96       	mov	r6,r12
800074e0:	5b fc       	cp.w	r12,-1
800074e2:	c7 50       	breq	800075cc <_malloc_r+0x3f8>
800074e4:	e6 02 00 08 	add	r8,r3,r2
800074e8:	10 3c       	cp.w	r12,r8
800074ea:	c0 32       	brcc	800074f0 <_malloc_r+0x31c>
800074ec:	08 33       	cp.w	r3,r4
800074ee:	c6 f1       	brne	800075cc <_malloc_r+0x3f8>
800074f0:	e0 6a 0d 58 	mov	r10,3416
800074f4:	74 09       	ld.w	r9,r10[0x0]
800074f6:	e2 09 00 09 	add	r9,r1,r9
800074fa:	95 09       	st.w	r10[0x0],r9
800074fc:	10 36       	cp.w	r6,r8
800074fe:	c0 a1       	brne	80007512 <_malloc_r+0x33e>
80007500:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007504:	c0 71       	brne	80007512 <_malloc_r+0x33e>
80007506:	e2 02 00 02 	add	r2,r1,r2
8000750a:	68 28       	ld.w	r8,r4[0x8]
8000750c:	a1 a2       	sbr	r2,0x0
8000750e:	91 12       	st.w	r8[0x4],r2
80007510:	c4 f8       	rjmp	800075ae <_malloc_r+0x3da>
80007512:	e0 6a 09 44 	mov	r10,2372
80007516:	74 0b       	ld.w	r11,r10[0x0]
80007518:	5b fb       	cp.w	r11,-1
8000751a:	c0 31       	brne	80007520 <_malloc_r+0x34c>
8000751c:	95 06       	st.w	r10[0x0],r6
8000751e:	c0 78       	rjmp	8000752c <_malloc_r+0x358>
80007520:	ec 09 00 09 	add	r9,r6,r9
80007524:	e0 6a 0d 58 	mov	r10,3416
80007528:	10 19       	sub	r9,r8
8000752a:	95 09       	st.w	r10[0x0],r9
8000752c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007530:	f0 09 11 08 	rsub	r9,r8,8
80007534:	58 08       	cp.w	r8,0
80007536:	f2 08 17 10 	movne	r8,r9
8000753a:	ed d8 e1 06 	addne	r6,r6,r8
8000753e:	28 08       	sub	r8,-128
80007540:	ec 01 00 01 	add	r1,r6,r1
80007544:	0a 9c       	mov	r12,r5
80007546:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000754a:	f0 01 01 01 	sub	r1,r8,r1
8000754e:	02 9b       	mov	r11,r1
80007550:	e0 a0 02 6a 	rcall	80007a24 <_sbrk_r>
80007554:	e0 68 0d 58 	mov	r8,3416
80007558:	5b fc       	cp.w	r12,-1
8000755a:	ec 0c 17 00 	moveq	r12,r6
8000755e:	f9 b1 00 00 	moveq	r1,0
80007562:	70 09       	ld.w	r9,r8[0x0]
80007564:	0c 1c       	sub	r12,r6
80007566:	89 26       	st.w	r4[0x8],r6
80007568:	02 0c       	add	r12,r1
8000756a:	12 01       	add	r1,r9
8000756c:	a1 ac       	sbr	r12,0x0
8000756e:	91 01       	st.w	r8[0x0],r1
80007570:	8d 1c       	st.w	r6[0x4],r12
80007572:	08 33       	cp.w	r3,r4
80007574:	c1 d0       	breq	800075ae <_malloc_r+0x3da>
80007576:	58 f2       	cp.w	r2,15
80007578:	e0 8b 00 05 	brhi	80007582 <_malloc_r+0x3ae>
8000757c:	30 18       	mov	r8,1
8000757e:	8d 18       	st.w	r6[0x4],r8
80007580:	c2 68       	rjmp	800075cc <_malloc_r+0x3f8>
80007582:	30 59       	mov	r9,5
80007584:	20 c2       	sub	r2,12
80007586:	e0 12 ff f8 	andl	r2,0xfff8
8000758a:	e6 02 00 08 	add	r8,r3,r2
8000758e:	91 29       	st.w	r8[0x8],r9
80007590:	91 19       	st.w	r8[0x4],r9
80007592:	66 18       	ld.w	r8,r3[0x4]
80007594:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007598:	e5 e8 10 08 	or	r8,r2,r8
8000759c:	87 18       	st.w	r3[0x4],r8
8000759e:	58 f2       	cp.w	r2,15
800075a0:	e0 88 00 07 	brls	800075ae <_malloc_r+0x3da>
800075a4:	e6 cb ff f8 	sub	r11,r3,-8
800075a8:	0a 9c       	mov	r12,r5
800075aa:	e0 a0 1c 6b 	rcall	8000ae80 <_free_r>
800075ae:	e0 69 0d 50 	mov	r9,3408
800075b2:	72 0a       	ld.w	r10,r9[0x0]
800075b4:	e0 68 0d 58 	mov	r8,3416
800075b8:	70 08       	ld.w	r8,r8[0x0]
800075ba:	14 38       	cp.w	r8,r10
800075bc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800075c0:	e0 69 0d 4c 	mov	r9,3404
800075c4:	72 0a       	ld.w	r10,r9[0x0]
800075c6:	14 38       	cp.w	r8,r10
800075c8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800075cc:	68 28       	ld.w	r8,r4[0x8]
800075ce:	70 18       	ld.w	r8,r8[0x4]
800075d0:	e0 18 ff fc 	andl	r8,0xfffc
800075d4:	0e 38       	cp.w	r8,r7
800075d6:	5f 39       	srlo	r9
800075d8:	0e 18       	sub	r8,r7
800075da:	58 f8       	cp.w	r8,15
800075dc:	5f aa       	srle	r10
800075de:	f5 e9 10 09 	or	r9,r10,r9
800075e2:	c0 50       	breq	800075ec <_malloc_r+0x418>
800075e4:	0a 9c       	mov	r12,r5
800075e6:	fe b0 f3 fb 	rcall	80005ddc <__malloc_unlock>
800075ea:	d8 3a       	popm	r0-r7,pc,r12=0
800075ec:	68 26       	ld.w	r6,r4[0x8]
800075ee:	a1 a8       	sbr	r8,0x0
800075f0:	0e 99       	mov	r9,r7
800075f2:	a1 a9       	sbr	r9,0x0
800075f4:	8d 19       	st.w	r6[0x4],r9
800075f6:	ec 07 00 07 	add	r7,r6,r7
800075fa:	0a 9c       	mov	r12,r5
800075fc:	89 27       	st.w	r4[0x8],r7
800075fe:	8f 18       	st.w	r7[0x4],r8
80007600:	fe b0 f3 ee 	rcall	80005ddc <__malloc_unlock>
80007604:	ec cc ff f8 	sub	r12,r6,-8
80007608:	d8 32       	popm	r0-r7,pc
8000760a:	d7 03       	nop

8000760c <memcpy>:
8000760c:	58 8a       	cp.w	r10,8
8000760e:	c2 f5       	brlt	8000766c <memcpy+0x60>
80007610:	f9 eb 10 09 	or	r9,r12,r11
80007614:	e2 19 00 03 	andl	r9,0x3,COH
80007618:	e0 81 00 97 	brne	80007746 <memcpy+0x13a>
8000761c:	e0 4a 00 20 	cp.w	r10,32
80007620:	c3 b4       	brge	80007696 <memcpy+0x8a>
80007622:	f4 08 14 02 	asr	r8,r10,0x2
80007626:	f0 09 11 08 	rsub	r9,r8,8
8000762a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000762e:	76 69       	ld.w	r9,r11[0x18]
80007630:	99 69       	st.w	r12[0x18],r9
80007632:	76 59       	ld.w	r9,r11[0x14]
80007634:	99 59       	st.w	r12[0x14],r9
80007636:	76 49       	ld.w	r9,r11[0x10]
80007638:	99 49       	st.w	r12[0x10],r9
8000763a:	76 39       	ld.w	r9,r11[0xc]
8000763c:	99 39       	st.w	r12[0xc],r9
8000763e:	76 29       	ld.w	r9,r11[0x8]
80007640:	99 29       	st.w	r12[0x8],r9
80007642:	76 19       	ld.w	r9,r11[0x4]
80007644:	99 19       	st.w	r12[0x4],r9
80007646:	76 09       	ld.w	r9,r11[0x0]
80007648:	99 09       	st.w	r12[0x0],r9
8000764a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000764e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007652:	e0 1a 00 03 	andl	r10,0x3
80007656:	f4 0a 11 04 	rsub	r10,r10,4
8000765a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000765e:	17 a9       	ld.ub	r9,r11[0x2]
80007660:	b0 a9       	st.b	r8[0x2],r9
80007662:	17 99       	ld.ub	r9,r11[0x1]
80007664:	b0 99       	st.b	r8[0x1],r9
80007666:	17 89       	ld.ub	r9,r11[0x0]
80007668:	b0 89       	st.b	r8[0x0],r9
8000766a:	5e fc       	retal	r12
8000766c:	f4 0a 11 09 	rsub	r10,r10,9
80007670:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007674:	17 f9       	ld.ub	r9,r11[0x7]
80007676:	b8 f9       	st.b	r12[0x7],r9
80007678:	17 e9       	ld.ub	r9,r11[0x6]
8000767a:	b8 e9       	st.b	r12[0x6],r9
8000767c:	17 d9       	ld.ub	r9,r11[0x5]
8000767e:	b8 d9       	st.b	r12[0x5],r9
80007680:	17 c9       	ld.ub	r9,r11[0x4]
80007682:	b8 c9       	st.b	r12[0x4],r9
80007684:	17 b9       	ld.ub	r9,r11[0x3]
80007686:	b8 b9       	st.b	r12[0x3],r9
80007688:	17 a9       	ld.ub	r9,r11[0x2]
8000768a:	b8 a9       	st.b	r12[0x2],r9
8000768c:	17 99       	ld.ub	r9,r11[0x1]
8000768e:	b8 99       	st.b	r12[0x1],r9
80007690:	17 89       	ld.ub	r9,r11[0x0]
80007692:	b8 89       	st.b	r12[0x0],r9
80007694:	5e fc       	retal	r12
80007696:	eb cd 40 c0 	pushm	r6-r7,lr
8000769a:	18 99       	mov	r9,r12
8000769c:	22 0a       	sub	r10,32
8000769e:	b7 07       	ld.d	r6,r11++
800076a0:	b3 26       	st.d	r9++,r6
800076a2:	b7 07       	ld.d	r6,r11++
800076a4:	b3 26       	st.d	r9++,r6
800076a6:	b7 07       	ld.d	r6,r11++
800076a8:	b3 26       	st.d	r9++,r6
800076aa:	b7 07       	ld.d	r6,r11++
800076ac:	b3 26       	st.d	r9++,r6
800076ae:	22 0a       	sub	r10,32
800076b0:	cf 74       	brge	8000769e <memcpy+0x92>
800076b2:	2f 0a       	sub	r10,-16
800076b4:	c0 65       	brlt	800076c0 <memcpy+0xb4>
800076b6:	b7 07       	ld.d	r6,r11++
800076b8:	b3 26       	st.d	r9++,r6
800076ba:	b7 07       	ld.d	r6,r11++
800076bc:	b3 26       	st.d	r9++,r6
800076be:	21 0a       	sub	r10,16
800076c0:	5c 3a       	neg	r10
800076c2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800076c6:	d7 03       	nop
800076c8:	d7 03       	nop
800076ca:	f7 36 00 0e 	ld.ub	r6,r11[14]
800076ce:	f3 66 00 0e 	st.b	r9[14],r6
800076d2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800076d6:	f3 66 00 0d 	st.b	r9[13],r6
800076da:	f7 36 00 0c 	ld.ub	r6,r11[12]
800076de:	f3 66 00 0c 	st.b	r9[12],r6
800076e2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800076e6:	f3 66 00 0b 	st.b	r9[11],r6
800076ea:	f7 36 00 0a 	ld.ub	r6,r11[10]
800076ee:	f3 66 00 0a 	st.b	r9[10],r6
800076f2:	f7 36 00 09 	ld.ub	r6,r11[9]
800076f6:	f3 66 00 09 	st.b	r9[9],r6
800076fa:	f7 36 00 08 	ld.ub	r6,r11[8]
800076fe:	f3 66 00 08 	st.b	r9[8],r6
80007702:	f7 36 00 07 	ld.ub	r6,r11[7]
80007706:	f3 66 00 07 	st.b	r9[7],r6
8000770a:	f7 36 00 06 	ld.ub	r6,r11[6]
8000770e:	f3 66 00 06 	st.b	r9[6],r6
80007712:	f7 36 00 05 	ld.ub	r6,r11[5]
80007716:	f3 66 00 05 	st.b	r9[5],r6
8000771a:	f7 36 00 04 	ld.ub	r6,r11[4]
8000771e:	f3 66 00 04 	st.b	r9[4],r6
80007722:	f7 36 00 03 	ld.ub	r6,r11[3]
80007726:	f3 66 00 03 	st.b	r9[3],r6
8000772a:	f7 36 00 02 	ld.ub	r6,r11[2]
8000772e:	f3 66 00 02 	st.b	r9[2],r6
80007732:	f7 36 00 01 	ld.ub	r6,r11[1]
80007736:	f3 66 00 01 	st.b	r9[1],r6
8000773a:	f7 36 00 00 	ld.ub	r6,r11[0]
8000773e:	f3 66 00 00 	st.b	r9[0],r6
80007742:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007746:	20 1a       	sub	r10,1
80007748:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000774c:	f8 0a 0b 09 	st.b	r12[r10],r9
80007750:	cf b1       	brne	80007746 <memcpy+0x13a>
80007752:	5e fc       	retal	r12

80007754 <memset>:
80007754:	18 98       	mov	r8,r12
80007756:	c0 38       	rjmp	8000775c <memset+0x8>
80007758:	10 cb       	st.b	r8++,r11
8000775a:	20 1a       	sub	r10,1
8000775c:	58 0a       	cp.w	r10,0
8000775e:	cf d1       	brne	80007758 <memset+0x4>
80007760:	5e fc       	retal	r12
80007762:	d7 03       	nop

80007764 <_realloc_r>:
80007764:	d4 31       	pushm	r0-r7,lr
80007766:	20 1d       	sub	sp,4
80007768:	16 94       	mov	r4,r11
8000776a:	18 92       	mov	r2,r12
8000776c:	14 9b       	mov	r11,r10
8000776e:	58 04       	cp.w	r4,0
80007770:	c0 51       	brne	8000777a <_realloc_r+0x16>
80007772:	fe b0 fd 31 	rcall	800071d4 <_malloc_r>
80007776:	18 95       	mov	r5,r12
80007778:	c5 39       	rjmp	80007a1e <_realloc_r+0x2ba>
8000777a:	50 0a       	stdsp	sp[0x0],r10
8000777c:	fe b0 f3 2a 	rcall	80005dd0 <__malloc_lock>
80007780:	40 0b       	lddsp	r11,sp[0x0]
80007782:	f6 c8 ff f5 	sub	r8,r11,-11
80007786:	e8 c1 00 08 	sub	r1,r4,8
8000778a:	10 96       	mov	r6,r8
8000778c:	62 1c       	ld.w	r12,r1[0x4]
8000778e:	e0 16 ff f8 	andl	r6,0xfff8
80007792:	59 68       	cp.w	r8,22
80007794:	f9 b6 08 10 	movls	r6,16
80007798:	16 36       	cp.w	r6,r11
8000779a:	5f 38       	srlo	r8
8000779c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800077a0:	c0 50       	breq	800077aa <_realloc_r+0x46>
800077a2:	30 c8       	mov	r8,12
800077a4:	30 05       	mov	r5,0
800077a6:	85 38       	st.w	r2[0xc],r8
800077a8:	c3 b9       	rjmp	80007a1e <_realloc_r+0x2ba>
800077aa:	18 90       	mov	r0,r12
800077ac:	e0 10 ff fc 	andl	r0,0xfffc
800077b0:	0c 30       	cp.w	r0,r6
800077b2:	e0 84 01 0b 	brge	800079c8 <_realloc_r+0x264>
800077b6:	e0 68 05 38 	mov	r8,1336
800077ba:	e2 00 00 09 	add	r9,r1,r0
800077be:	70 25       	ld.w	r5,r8[0x8]
800077c0:	0a 39       	cp.w	r9,r5
800077c2:	c0 90       	breq	800077d4 <_realloc_r+0x70>
800077c4:	72 1a       	ld.w	r10,r9[0x4]
800077c6:	a1 ca       	cbr	r10,0x0
800077c8:	f2 0a 00 0a 	add	r10,r9,r10
800077cc:	74 1a       	ld.w	r10,r10[0x4]
800077ce:	ed ba 00 00 	bld	r10,0x0
800077d2:	c2 20       	breq	80007816 <_realloc_r+0xb2>
800077d4:	72 1a       	ld.w	r10,r9[0x4]
800077d6:	e0 1a ff fc 	andl	r10,0xfffc
800077da:	f4 00 00 03 	add	r3,r10,r0
800077de:	0a 39       	cp.w	r9,r5
800077e0:	c1 31       	brne	80007806 <_realloc_r+0xa2>
800077e2:	ec c7 ff f0 	sub	r7,r6,-16
800077e6:	0e 33       	cp.w	r3,r7
800077e8:	c1 95       	brlt	8000781a <_realloc_r+0xb6>
800077ea:	e2 06 00 09 	add	r9,r1,r6
800077ee:	0c 13       	sub	r3,r6
800077f0:	a1 a3       	sbr	r3,0x0
800077f2:	93 13       	st.w	r9[0x4],r3
800077f4:	91 29       	st.w	r8[0x8],r9
800077f6:	04 9c       	mov	r12,r2
800077f8:	62 18       	ld.w	r8,r1[0x4]
800077fa:	08 95       	mov	r5,r4
800077fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007800:	10 46       	or	r6,r8
80007802:	83 16       	st.w	r1[0x4],r6
80007804:	c0 b9       	rjmp	80007a1a <_realloc_r+0x2b6>
80007806:	0c 33       	cp.w	r3,r6
80007808:	c0 95       	brlt	8000781a <_realloc_r+0xb6>
8000780a:	72 28       	ld.w	r8,r9[0x8]
8000780c:	02 97       	mov	r7,r1
8000780e:	72 39       	ld.w	r9,r9[0xc]
80007810:	93 28       	st.w	r9[0x8],r8
80007812:	91 39       	st.w	r8[0xc],r9
80007814:	cd c8       	rjmp	800079cc <_realloc_r+0x268>
80007816:	30 0a       	mov	r10,0
80007818:	14 99       	mov	r9,r10
8000781a:	ed bc 00 00 	bld	r12,0x0
8000781e:	e0 80 00 95 	breq	80007948 <_realloc_r+0x1e4>
80007822:	62 07       	ld.w	r7,r1[0x0]
80007824:	e2 07 01 07 	sub	r7,r1,r7
80007828:	6e 1c       	ld.w	r12,r7[0x4]
8000782a:	e0 1c ff fc 	andl	r12,0xfffc
8000782e:	58 09       	cp.w	r9,0
80007830:	c5 60       	breq	800078dc <_realloc_r+0x178>
80007832:	f8 00 00 03 	add	r3,r12,r0
80007836:	0a 39       	cp.w	r9,r5
80007838:	c4 81       	brne	800078c8 <_realloc_r+0x164>
8000783a:	14 03       	add	r3,r10
8000783c:	ec c9 ff f0 	sub	r9,r6,-16
80007840:	12 33       	cp.w	r3,r9
80007842:	c4 d5       	brlt	800078dc <_realloc_r+0x178>
80007844:	6e 3a       	ld.w	r10,r7[0xc]
80007846:	6e 29       	ld.w	r9,r7[0x8]
80007848:	95 29       	st.w	r10[0x8],r9
8000784a:	93 3a       	st.w	r9[0xc],r10
8000784c:	ee c5 ff f8 	sub	r5,r7,-8
80007850:	e0 ca 00 04 	sub	r10,r0,4
80007854:	e0 4a 00 24 	cp.w	r10,36
80007858:	e0 8b 00 25 	brhi	800078a2 <_realloc_r+0x13e>
8000785c:	0a 99       	mov	r9,r5
8000785e:	59 3a       	cp.w	r10,19
80007860:	e0 88 00 1a 	brls	80007894 <_realloc_r+0x130>
80007864:	09 09       	ld.w	r9,r4++
80007866:	8b 09       	st.w	r5[0x0],r9
80007868:	09 09       	ld.w	r9,r4++
8000786a:	8f 39       	st.w	r7[0xc],r9
8000786c:	ee c9 ff f0 	sub	r9,r7,-16
80007870:	59 ba       	cp.w	r10,27
80007872:	e0 88 00 11 	brls	80007894 <_realloc_r+0x130>
80007876:	09 0b       	ld.w	r11,r4++
80007878:	93 0b       	st.w	r9[0x0],r11
8000787a:	09 09       	ld.w	r9,r4++
8000787c:	8f 59       	st.w	r7[0x14],r9
8000787e:	ee c9 ff e8 	sub	r9,r7,-24
80007882:	e0 4a 00 24 	cp.w	r10,36
80007886:	c0 71       	brne	80007894 <_realloc_r+0x130>
80007888:	09 0a       	ld.w	r10,r4++
8000788a:	93 0a       	st.w	r9[0x0],r10
8000788c:	ee c9 ff e0 	sub	r9,r7,-32
80007890:	09 0a       	ld.w	r10,r4++
80007892:	8f 7a       	st.w	r7[0x1c],r10
80007894:	09 0a       	ld.w	r10,r4++
80007896:	12 aa       	st.w	r9++,r10
80007898:	68 0a       	ld.w	r10,r4[0x0]
8000789a:	93 0a       	st.w	r9[0x0],r10
8000789c:	68 1a       	ld.w	r10,r4[0x4]
8000789e:	93 1a       	st.w	r9[0x4],r10
800078a0:	c0 78       	rjmp	800078ae <_realloc_r+0x14a>
800078a2:	50 08       	stdsp	sp[0x0],r8
800078a4:	08 9b       	mov	r11,r4
800078a6:	0a 9c       	mov	r12,r5
800078a8:	e0 a0 1d 8f 	rcall	8000b3c6 <memmove>
800078ac:	40 08       	lddsp	r8,sp[0x0]
800078ae:	ee 06 00 09 	add	r9,r7,r6
800078b2:	0c 13       	sub	r3,r6
800078b4:	a1 a3       	sbr	r3,0x0
800078b6:	93 13       	st.w	r9[0x4],r3
800078b8:	91 29       	st.w	r8[0x8],r9
800078ba:	04 9c       	mov	r12,r2
800078bc:	6e 18       	ld.w	r8,r7[0x4]
800078be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800078c2:	10 46       	or	r6,r8
800078c4:	8f 16       	st.w	r7[0x4],r6
800078c6:	ca a8       	rjmp	80007a1a <_realloc_r+0x2b6>
800078c8:	14 03       	add	r3,r10
800078ca:	0c 33       	cp.w	r3,r6
800078cc:	c0 85       	brlt	800078dc <_realloc_r+0x178>
800078ce:	72 28       	ld.w	r8,r9[0x8]
800078d0:	72 39       	ld.w	r9,r9[0xc]
800078d2:	93 28       	st.w	r9[0x8],r8
800078d4:	91 39       	st.w	r8[0xc],r9
800078d6:	6e 28       	ld.w	r8,r7[0x8]
800078d8:	6e 39       	ld.w	r9,r7[0xc]
800078da:	c0 78       	rjmp	800078e8 <_realloc_r+0x184>
800078dc:	f8 00 00 03 	add	r3,r12,r0
800078e0:	0c 33       	cp.w	r3,r6
800078e2:	c3 35       	brlt	80007948 <_realloc_r+0x1e4>
800078e4:	6e 39       	ld.w	r9,r7[0xc]
800078e6:	6e 28       	ld.w	r8,r7[0x8]
800078e8:	93 28       	st.w	r9[0x8],r8
800078ea:	91 39       	st.w	r8[0xc],r9
800078ec:	e0 ca 00 04 	sub	r10,r0,4
800078f0:	ee cc ff f8 	sub	r12,r7,-8
800078f4:	e0 4a 00 24 	cp.w	r10,36
800078f8:	e0 8b 00 24 	brhi	80007940 <_realloc_r+0x1dc>
800078fc:	59 3a       	cp.w	r10,19
800078fe:	e0 88 00 1a 	brls	80007932 <_realloc_r+0x1ce>
80007902:	09 08       	ld.w	r8,r4++
80007904:	99 08       	st.w	r12[0x0],r8
80007906:	09 08       	ld.w	r8,r4++
80007908:	8f 38       	st.w	r7[0xc],r8
8000790a:	ee cc ff f0 	sub	r12,r7,-16
8000790e:	59 ba       	cp.w	r10,27
80007910:	e0 88 00 11 	brls	80007932 <_realloc_r+0x1ce>
80007914:	09 08       	ld.w	r8,r4++
80007916:	99 08       	st.w	r12[0x0],r8
80007918:	09 08       	ld.w	r8,r4++
8000791a:	8f 58       	st.w	r7[0x14],r8
8000791c:	ee cc ff e8 	sub	r12,r7,-24
80007920:	e0 4a 00 24 	cp.w	r10,36
80007924:	c0 71       	brne	80007932 <_realloc_r+0x1ce>
80007926:	09 08       	ld.w	r8,r4++
80007928:	99 08       	st.w	r12[0x0],r8
8000792a:	ee cc ff e0 	sub	r12,r7,-32
8000792e:	09 08       	ld.w	r8,r4++
80007930:	8f 78       	st.w	r7[0x1c],r8
80007932:	09 08       	ld.w	r8,r4++
80007934:	18 a8       	st.w	r12++,r8
80007936:	68 08       	ld.w	r8,r4[0x0]
80007938:	99 08       	st.w	r12[0x0],r8
8000793a:	68 18       	ld.w	r8,r4[0x4]
8000793c:	99 18       	st.w	r12[0x4],r8
8000793e:	c4 78       	rjmp	800079cc <_realloc_r+0x268>
80007940:	08 9b       	mov	r11,r4
80007942:	e0 a0 1d 42 	rcall	8000b3c6 <memmove>
80007946:	c4 38       	rjmp	800079cc <_realloc_r+0x268>
80007948:	04 9c       	mov	r12,r2
8000794a:	fe b0 fc 45 	rcall	800071d4 <_malloc_r>
8000794e:	18 95       	mov	r5,r12
80007950:	c3 a0       	breq	800079c4 <_realloc_r+0x260>
80007952:	62 18       	ld.w	r8,r1[0x4]
80007954:	f8 c9 00 08 	sub	r9,r12,8
80007958:	a1 c8       	cbr	r8,0x0
8000795a:	e2 08 00 08 	add	r8,r1,r8
8000795e:	10 39       	cp.w	r9,r8
80007960:	c0 71       	brne	8000796e <_realloc_r+0x20a>
80007962:	72 13       	ld.w	r3,r9[0x4]
80007964:	02 97       	mov	r7,r1
80007966:	e0 13 ff fc 	andl	r3,0xfffc
8000796a:	00 03       	add	r3,r0
8000796c:	c3 08       	rjmp	800079cc <_realloc_r+0x268>
8000796e:	e0 ca 00 04 	sub	r10,r0,4
80007972:	e0 4a 00 24 	cp.w	r10,36
80007976:	e0 8b 00 20 	brhi	800079b6 <_realloc_r+0x252>
8000797a:	08 99       	mov	r9,r4
8000797c:	18 98       	mov	r8,r12
8000797e:	59 3a       	cp.w	r10,19
80007980:	e0 88 00 14 	brls	800079a8 <_realloc_r+0x244>
80007984:	13 0b       	ld.w	r11,r9++
80007986:	10 ab       	st.w	r8++,r11
80007988:	13 0b       	ld.w	r11,r9++
8000798a:	10 ab       	st.w	r8++,r11
8000798c:	59 ba       	cp.w	r10,27
8000798e:	e0 88 00 0d 	brls	800079a8 <_realloc_r+0x244>
80007992:	13 0b       	ld.w	r11,r9++
80007994:	10 ab       	st.w	r8++,r11
80007996:	13 0b       	ld.w	r11,r9++
80007998:	10 ab       	st.w	r8++,r11
8000799a:	e0 4a 00 24 	cp.w	r10,36
8000799e:	c0 51       	brne	800079a8 <_realloc_r+0x244>
800079a0:	13 0a       	ld.w	r10,r9++
800079a2:	10 aa       	st.w	r8++,r10
800079a4:	13 0a       	ld.w	r10,r9++
800079a6:	10 aa       	st.w	r8++,r10
800079a8:	13 0a       	ld.w	r10,r9++
800079aa:	10 aa       	st.w	r8++,r10
800079ac:	72 0a       	ld.w	r10,r9[0x0]
800079ae:	91 0a       	st.w	r8[0x0],r10
800079b0:	72 19       	ld.w	r9,r9[0x4]
800079b2:	91 19       	st.w	r8[0x4],r9
800079b4:	c0 48       	rjmp	800079bc <_realloc_r+0x258>
800079b6:	08 9b       	mov	r11,r4
800079b8:	e0 a0 1d 07 	rcall	8000b3c6 <memmove>
800079bc:	08 9b       	mov	r11,r4
800079be:	04 9c       	mov	r12,r2
800079c0:	e0 a0 1a 60 	rcall	8000ae80 <_free_r>
800079c4:	04 9c       	mov	r12,r2
800079c6:	c2 a8       	rjmp	80007a1a <_realloc_r+0x2b6>
800079c8:	00 93       	mov	r3,r0
800079ca:	02 97       	mov	r7,r1
800079cc:	e6 06 01 09 	sub	r9,r3,r6
800079d0:	6e 18       	ld.w	r8,r7[0x4]
800079d2:	58 f9       	cp.w	r9,15
800079d4:	e0 88 00 16 	brls	80007a00 <_realloc_r+0x29c>
800079d8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079dc:	ed e8 10 08 	or	r8,r6,r8
800079e0:	8f 18       	st.w	r7[0x4],r8
800079e2:	12 98       	mov	r8,r9
800079e4:	a1 a8       	sbr	r8,0x0
800079e6:	ee 06 00 0b 	add	r11,r7,r6
800079ea:	f6 09 00 09 	add	r9,r11,r9
800079ee:	97 18       	st.w	r11[0x4],r8
800079f0:	72 18       	ld.w	r8,r9[0x4]
800079f2:	a1 a8       	sbr	r8,0x0
800079f4:	2f 8b       	sub	r11,-8
800079f6:	93 18       	st.w	r9[0x4],r8
800079f8:	04 9c       	mov	r12,r2
800079fa:	e0 a0 1a 43 	rcall	8000ae80 <_free_r>
800079fe:	c0 b8       	rjmp	80007a14 <_realloc_r+0x2b0>
80007a00:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a04:	e7 e8 10 08 	or	r8,r3,r8
80007a08:	8f 18       	st.w	r7[0x4],r8
80007a0a:	ee 03 00 03 	add	r3,r7,r3
80007a0e:	66 18       	ld.w	r8,r3[0x4]
80007a10:	a1 a8       	sbr	r8,0x0
80007a12:	87 18       	st.w	r3[0x4],r8
80007a14:	04 9c       	mov	r12,r2
80007a16:	ee c5 ff f8 	sub	r5,r7,-8
80007a1a:	fe b0 f1 e1 	rcall	80005ddc <__malloc_unlock>
80007a1e:	0a 9c       	mov	r12,r5
80007a20:	2f fd       	sub	sp,-4
80007a22:	d8 32       	popm	r0-r7,pc

80007a24 <_sbrk_r>:
80007a24:	d4 21       	pushm	r4-r7,lr
80007a26:	30 08       	mov	r8,0
80007a28:	18 97       	mov	r7,r12
80007a2a:	e0 66 51 24 	mov	r6,20772
80007a2e:	16 9c       	mov	r12,r11
80007a30:	8d 08       	st.w	r6[0x0],r8
80007a32:	c8 5c       	rcall	80007b3c <_sbrk>
80007a34:	5b fc       	cp.w	r12,-1
80007a36:	c0 51       	brne	80007a40 <_sbrk_r+0x1c>
80007a38:	6c 08       	ld.w	r8,r6[0x0]
80007a3a:	58 08       	cp.w	r8,0
80007a3c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007a40:	d8 22       	popm	r4-r7,pc
80007a42:	d7 03       	nop

80007a44 <sprintf>:
80007a44:	d4 01       	pushm	lr
80007a46:	21 7d       	sub	sp,92
80007a48:	e0 68 ff ff 	mov	r8,65535
80007a4c:	ea 18 7f ff 	orh	r8,0x7fff
80007a50:	50 58       	stdsp	sp[0x14],r8
80007a52:	50 28       	stdsp	sp[0x8],r8
80007a54:	e0 68 02 08 	mov	r8,520
80007a58:	ba 68       	st.h	sp[0xc],r8
80007a5a:	3f f8       	mov	r8,-1
80007a5c:	ba 78       	st.h	sp[0xe],r8
80007a5e:	e0 68 0a 38 	mov	r8,2616
80007a62:	50 4c       	stdsp	sp[0x10],r12
80007a64:	16 9a       	mov	r10,r11
80007a66:	50 0c       	stdsp	sp[0x0],r12
80007a68:	fa c9 ff a0 	sub	r9,sp,-96
80007a6c:	70 0c       	ld.w	r12,r8[0x0]
80007a6e:	1a 9b       	mov	r11,sp
80007a70:	e0 a0 02 1a 	rcall	80007ea4 <_vfprintf_r>
80007a74:	30 09       	mov	r9,0
80007a76:	40 08       	lddsp	r8,sp[0x0]
80007a78:	b0 89       	st.b	r8[0x0],r9
80007a7a:	2e 9d       	sub	sp,-92
80007a7c:	d8 02       	popm	pc
80007a7e:	d7 03       	nop

80007a80 <strncpy>:
80007a80:	30 08       	mov	r8,0
80007a82:	10 3a       	cp.w	r10,r8
80007a84:	5e 0c       	reteq	r12
80007a86:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007a8a:	f8 08 0b 09 	st.b	r12[r8],r9
80007a8e:	2f f8       	sub	r8,-1
80007a90:	58 09       	cp.w	r9,0
80007a92:	cf 81       	brne	80007a82 <strncpy+0x2>
80007a94:	10 3a       	cp.w	r10,r8
80007a96:	5e 0c       	reteq	r12
80007a98:	f8 08 0b 09 	st.b	r12[r8],r9
80007a9c:	2f f8       	sub	r8,-1
80007a9e:	cf bb       	rjmp	80007a94 <strncpy+0x14>

80007aa0 <_close>:
80007aa0:	30 28       	mov	r8,2
80007aa2:	d6 73       	breakpoint
80007aa4:	3f fc       	mov	r12,-1
80007aa6:	35 8b       	mov	r11,88
80007aa8:	58 0c       	cp.w	r12,0
80007aaa:	5e 4c       	retge	r12
80007aac:	e0 6a 51 24 	mov	r10,20772
80007ab0:	95 0b       	st.w	r10[0x0],r11
80007ab2:	5e fc       	retal	r12

80007ab4 <_lseek>:
80007ab4:	30 58       	mov	r8,5
80007ab6:	d6 73       	breakpoint
80007ab8:	3f fc       	mov	r12,-1
80007aba:	35 8b       	mov	r11,88
80007abc:	58 0c       	cp.w	r12,0
80007abe:	5e 4c       	retge	r12
80007ac0:	e0 6a 51 24 	mov	r10,20772
80007ac4:	95 0b       	st.w	r10[0x0],r11
80007ac6:	5e fc       	retal	r12

80007ac8 <isatty>:
80007ac8:	30 b8       	mov	r8,11
80007aca:	d6 73       	breakpoint
80007acc:	3f fc       	mov	r12,-1
80007ace:	35 8b       	mov	r11,88
80007ad0:	58 0c       	cp.w	r12,0
80007ad2:	5e 4c       	retge	r12
80007ad4:	e0 6a 51 24 	mov	r10,20772
80007ad8:	95 0b       	st.w	r10[0x0],r11
80007ada:	5e fc       	retal	r12

80007adc <_fstat_host>:
80007adc:	30 98       	mov	r8,9
80007ade:	d6 73       	breakpoint
80007ae0:	3f fc       	mov	r12,-1
80007ae2:	35 8b       	mov	r11,88
80007ae4:	58 0c       	cp.w	r12,0
80007ae6:	5e 4c       	retge	r12
80007ae8:	e0 6a 51 24 	mov	r10,20772
80007aec:	95 0b       	st.w	r10[0x0],r11
80007aee:	5e fc       	retal	r12

80007af0 <_fstat>:
80007af0:	d4 21       	pushm	r4-r7,lr
80007af2:	21 0d       	sub	sp,64
80007af4:	16 97       	mov	r7,r11
80007af6:	1a 9b       	mov	r11,sp
80007af8:	cf 2f       	rcall	80007adc <_fstat_host>
80007afa:	c0 34       	brge	80007b00 <_fstat+0x10>
80007afc:	3f fc       	mov	r12,-1
80007afe:	c1 c8       	rjmp	80007b36 <_fstat+0x46>
80007b00:	40 08       	lddsp	r8,sp[0x0]
80007b02:	ae 08       	st.h	r7[0x0],r8
80007b04:	40 18       	lddsp	r8,sp[0x4]
80007b06:	ae 18       	st.h	r7[0x2],r8
80007b08:	40 28       	lddsp	r8,sp[0x8]
80007b0a:	8f 18       	st.w	r7[0x4],r8
80007b0c:	40 38       	lddsp	r8,sp[0xc]
80007b0e:	ae 48       	st.h	r7[0x8],r8
80007b10:	40 48       	lddsp	r8,sp[0x10]
80007b12:	ae 58       	st.h	r7[0xa],r8
80007b14:	40 58       	lddsp	r8,sp[0x14]
80007b16:	ae 68       	st.h	r7[0xc],r8
80007b18:	40 68       	lddsp	r8,sp[0x18]
80007b1a:	ae 78       	st.h	r7[0xe],r8
80007b1c:	40 88       	lddsp	r8,sp[0x20]
80007b1e:	8f 48       	st.w	r7[0x10],r8
80007b20:	40 a8       	lddsp	r8,sp[0x28]
80007b22:	8f b8       	st.w	r7[0x2c],r8
80007b24:	40 c8       	lddsp	r8,sp[0x30]
80007b26:	8f c8       	st.w	r7[0x30],r8
80007b28:	40 d8       	lddsp	r8,sp[0x34]
80007b2a:	8f 58       	st.w	r7[0x14],r8
80007b2c:	40 e8       	lddsp	r8,sp[0x38]
80007b2e:	30 0c       	mov	r12,0
80007b30:	8f 78       	st.w	r7[0x1c],r8
80007b32:	40 f8       	lddsp	r8,sp[0x3c]
80007b34:	8f 98       	st.w	r7[0x24],r8
80007b36:	2f 0d       	sub	sp,-64
80007b38:	d8 22       	popm	r4-r7,pc
80007b3a:	d7 03       	nop

80007b3c <_sbrk>:
80007b3c:	d4 01       	pushm	lr
80007b3e:	e0 68 0d 80 	mov	r8,3456
80007b42:	70 09       	ld.w	r9,r8[0x0]
80007b44:	58 09       	cp.w	r9,0
80007b46:	c0 41       	brne	80007b4e <_sbrk+0x12>
80007b48:	e0 69 51 28 	mov	r9,20776
80007b4c:	91 09       	st.w	r8[0x0],r9
80007b4e:	e0 69 0d 80 	mov	r9,3456
80007b52:	e0 7a 70 00 	mov	r10,94208
80007b56:	72 08       	ld.w	r8,r9[0x0]
80007b58:	f0 0c 00 0c 	add	r12,r8,r12
80007b5c:	14 3c       	cp.w	r12,r10
80007b5e:	e0 8b 00 04 	brhi	80007b66 <_sbrk+0x2a>
80007b62:	93 0c       	st.w	r9[0x0],r12
80007b64:	c0 68       	rjmp	80007b70 <_sbrk+0x34>
80007b66:	e0 a0 18 15 	rcall	8000ab90 <__errno>
80007b6a:	30 c8       	mov	r8,12
80007b6c:	99 08       	st.w	r12[0x0],r8
80007b6e:	3f f8       	mov	r8,-1
80007b70:	10 9c       	mov	r12,r8
80007b72:	d8 02       	popm	pc

80007b74 <get_arg>:
80007b74:	d4 31       	pushm	r0-r7,lr
80007b76:	20 8d       	sub	sp,32
80007b78:	fa c4 ff bc 	sub	r4,sp,-68
80007b7c:	50 4b       	stdsp	sp[0x10],r11
80007b7e:	68 2e       	ld.w	lr,r4[0x8]
80007b80:	50 58       	stdsp	sp[0x14],r8
80007b82:	12 96       	mov	r6,r9
80007b84:	7c 0b       	ld.w	r11,lr[0x0]
80007b86:	70 05       	ld.w	r5,r8[0x0]
80007b88:	50 6e       	stdsp	sp[0x18],lr
80007b8a:	58 0b       	cp.w	r11,0
80007b8c:	f4 0b 17 00 	moveq	r11,r10
80007b90:	68 03       	ld.w	r3,r4[0x0]
80007b92:	68 11       	ld.w	r1,r4[0x4]
80007b94:	40 49       	lddsp	r9,sp[0x10]
80007b96:	30 08       	mov	r8,0
80007b98:	c2 89       	rjmp	80007de8 <get_arg+0x274>
80007b9a:	2f fb       	sub	r11,-1
80007b9c:	32 5c       	mov	r12,37
80007b9e:	17 8a       	ld.ub	r10,r11[0x0]
80007ba0:	f8 0a 18 00 	cp.b	r10,r12
80007ba4:	5f 1e       	srne	lr
80007ba6:	f0 0a 18 00 	cp.b	r10,r8
80007baa:	5f 1c       	srne	r12
80007bac:	fd ec 00 0c 	and	r12,lr,r12
80007bb0:	f0 0c 18 00 	cp.b	r12,r8
80007bb4:	cf 31       	brne	80007b9a <get_arg+0x26>
80007bb6:	58 0a       	cp.w	r10,0
80007bb8:	e0 80 01 25 	breq	80007e02 <get_arg+0x28e>
80007bbc:	30 0c       	mov	r12,0
80007bbe:	3f fa       	mov	r10,-1
80007bc0:	18 90       	mov	r0,r12
80007bc2:	50 3a       	stdsp	sp[0xc],r10
80007bc4:	18 94       	mov	r4,r12
80007bc6:	18 92       	mov	r2,r12
80007bc8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007bcc:	16 97       	mov	r7,r11
80007bce:	50 7c       	stdsp	sp[0x1c],r12
80007bd0:	fe cc 9f 24 	sub	r12,pc,-24796
80007bd4:	0f 3a       	ld.ub	r10,r7++
80007bd6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007bda:	40 7c       	lddsp	r12,sp[0x1c]
80007bdc:	1c 0c       	add	r12,lr
80007bde:	fe ce 9f fa 	sub	lr,pc,-24582
80007be2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007be6:	20 1e       	sub	lr,1
80007be8:	50 0e       	stdsp	sp[0x0],lr
80007bea:	fe ce a0 72 	sub	lr,pc,-24462
80007bee:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007bf2:	50 7c       	stdsp	sp[0x1c],r12
80007bf4:	40 0c       	lddsp	r12,sp[0x0]
80007bf6:	58 7c       	cp.w	r12,7
80007bf8:	e0 8b 00 f1 	brhi	80007dda <get_arg+0x266>
80007bfc:	fe ce a2 24 	sub	lr,pc,-24028
80007c00:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007c04:	36 8b       	mov	r11,104
80007c06:	f6 0a 18 00 	cp.b	r10,r11
80007c0a:	e0 80 00 e8 	breq	80007dda <get_arg+0x266>
80007c0e:	37 1b       	mov	r11,113
80007c10:	f6 0a 18 00 	cp.b	r10,r11
80007c14:	c0 70       	breq	80007c22 <get_arg+0xae>
80007c16:	34 cb       	mov	r11,76
80007c18:	f6 0a 18 00 	cp.b	r10,r11
80007c1c:	c0 51       	brne	80007c26 <get_arg+0xb2>
80007c1e:	a3 b4       	sbr	r4,0x3
80007c20:	cd d8       	rjmp	80007dda <get_arg+0x266>
80007c22:	a5 b4       	sbr	r4,0x5
80007c24:	cd b8       	rjmp	80007dda <get_arg+0x266>
80007c26:	08 9a       	mov	r10,r4
80007c28:	0e 9b       	mov	r11,r7
80007c2a:	a5 aa       	sbr	r10,0x4
80007c2c:	17 3c       	ld.ub	r12,r11++
80007c2e:	a5 b4       	sbr	r4,0x5
80007c30:	36 ce       	mov	lr,108
80007c32:	fc 0c 18 00 	cp.b	r12,lr
80007c36:	e0 80 00 d3 	breq	80007ddc <get_arg+0x268>
80007c3a:	14 94       	mov	r4,r10
80007c3c:	cc f8       	rjmp	80007dda <get_arg+0x266>
80007c3e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007c42:	36 7c       	mov	r12,103
80007c44:	f8 0a 18 00 	cp.b	r10,r12
80007c48:	e0 8b 00 27 	brhi	80007c96 <get_arg+0x122>
80007c4c:	36 5b       	mov	r11,101
80007c4e:	f6 0a 18 00 	cp.b	r10,r11
80007c52:	c4 82       	brcc	80007ce2 <get_arg+0x16e>
80007c54:	34 fb       	mov	r11,79
80007c56:	f6 0a 18 00 	cp.b	r10,r11
80007c5a:	c4 80       	breq	80007cea <get_arg+0x176>
80007c5c:	e0 8b 00 0c 	brhi	80007c74 <get_arg+0x100>
80007c60:	34 5b       	mov	r11,69
80007c62:	f6 0a 18 00 	cp.b	r10,r11
80007c66:	c3 e0       	breq	80007ce2 <get_arg+0x16e>
80007c68:	34 7b       	mov	r11,71
80007c6a:	f6 0a 18 00 	cp.b	r10,r11
80007c6e:	c3 a0       	breq	80007ce2 <get_arg+0x16e>
80007c70:	34 4b       	mov	r11,68
80007c72:	c0 88       	rjmp	80007c82 <get_arg+0x10e>
80007c74:	35 8b       	mov	r11,88
80007c76:	f6 0a 18 00 	cp.b	r10,r11
80007c7a:	c2 c0       	breq	80007cd2 <get_arg+0x15e>
80007c7c:	e0 8b 00 07 	brhi	80007c8a <get_arg+0x116>
80007c80:	35 5b       	mov	r11,85
80007c82:	f6 0a 18 00 	cp.b	r10,r11
80007c86:	c3 51       	brne	80007cf0 <get_arg+0x17c>
80007c88:	c3 18       	rjmp	80007cea <get_arg+0x176>
80007c8a:	36 3b       	mov	r11,99
80007c8c:	f6 0a 18 00 	cp.b	r10,r11
80007c90:	c2 f0       	breq	80007cee <get_arg+0x17a>
80007c92:	36 4b       	mov	r11,100
80007c94:	c0 e8       	rjmp	80007cb0 <get_arg+0x13c>
80007c96:	37 0b       	mov	r11,112
80007c98:	f6 0a 18 00 	cp.b	r10,r11
80007c9c:	c2 50       	breq	80007ce6 <get_arg+0x172>
80007c9e:	e0 8b 00 0d 	brhi	80007cb8 <get_arg+0x144>
80007ca2:	36 eb       	mov	r11,110
80007ca4:	f6 0a 18 00 	cp.b	r10,r11
80007ca8:	c1 f0       	breq	80007ce6 <get_arg+0x172>
80007caa:	e0 8b 00 14 	brhi	80007cd2 <get_arg+0x15e>
80007cae:	36 9b       	mov	r11,105
80007cb0:	f6 0a 18 00 	cp.b	r10,r11
80007cb4:	c1 e1       	brne	80007cf0 <get_arg+0x17c>
80007cb6:	c0 e8       	rjmp	80007cd2 <get_arg+0x15e>
80007cb8:	37 5b       	mov	r11,117
80007cba:	f6 0a 18 00 	cp.b	r10,r11
80007cbe:	c0 a0       	breq	80007cd2 <get_arg+0x15e>
80007cc0:	37 8b       	mov	r11,120
80007cc2:	f6 0a 18 00 	cp.b	r10,r11
80007cc6:	c0 60       	breq	80007cd2 <get_arg+0x15e>
80007cc8:	37 3b       	mov	r11,115
80007cca:	f6 0a 18 00 	cp.b	r10,r11
80007cce:	c1 11       	brne	80007cf0 <get_arg+0x17c>
80007cd0:	c0 b8       	rjmp	80007ce6 <get_arg+0x172>
80007cd2:	ed b4 00 04 	bld	r4,0x4
80007cd6:	c0 a0       	breq	80007cea <get_arg+0x176>
80007cd8:	ed b4 00 05 	bld	r4,0x5
80007cdc:	c0 91       	brne	80007cee <get_arg+0x17a>
80007cde:	30 20       	mov	r0,2
80007ce0:	c0 88       	rjmp	80007cf0 <get_arg+0x17c>
80007ce2:	30 40       	mov	r0,4
80007ce4:	c0 68       	rjmp	80007cf0 <get_arg+0x17c>
80007ce6:	30 30       	mov	r0,3
80007ce8:	c0 48       	rjmp	80007cf0 <get_arg+0x17c>
80007cea:	30 10       	mov	r0,1
80007cec:	c0 28       	rjmp	80007cf0 <get_arg+0x17c>
80007cee:	30 00       	mov	r0,0
80007cf0:	40 3b       	lddsp	r11,sp[0xc]
80007cf2:	5b fb       	cp.w	r11,-1
80007cf4:	c0 40       	breq	80007cfc <get_arg+0x188>
80007cf6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007cfa:	c7 08       	rjmp	80007dda <get_arg+0x266>
80007cfc:	58 60       	cp.w	r0,6
80007cfe:	e0 8b 00 6e 	brhi	80007dda <get_arg+0x266>
80007d02:	6c 0a       	ld.w	r10,r6[0x0]
80007d04:	ea cc ff ff 	sub	r12,r5,-1
80007d08:	fe ce a3 10 	sub	lr,pc,-23792
80007d0c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007d10:	f4 cb ff f8 	sub	r11,r10,-8
80007d14:	8d 0b       	st.w	r6[0x0],r11
80007d16:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d1a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d1e:	c0 f8       	rjmp	80007d3c <get_arg+0x1c8>
80007d20:	f4 cb ff fc 	sub	r11,r10,-4
80007d24:	8d 0b       	st.w	r6[0x0],r11
80007d26:	74 0a       	ld.w	r10,r10[0x0]
80007d28:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d2c:	c0 88       	rjmp	80007d3c <get_arg+0x1c8>
80007d2e:	f4 cb ff f8 	sub	r11,r10,-8
80007d32:	8d 0b       	st.w	r6[0x0],r11
80007d34:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d38:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d3c:	0e 9b       	mov	r11,r7
80007d3e:	18 95       	mov	r5,r12
80007d40:	c4 e8       	rjmp	80007ddc <get_arg+0x268>
80007d42:	62 0a       	ld.w	r10,r1[0x0]
80007d44:	5b fa       	cp.w	r10,-1
80007d46:	c0 b1       	brne	80007d5c <get_arg+0x1e8>
80007d48:	50 19       	stdsp	sp[0x4],r9
80007d4a:	50 28       	stdsp	sp[0x8],r8
80007d4c:	e0 6a 00 80 	mov	r10,128
80007d50:	30 0b       	mov	r11,0
80007d52:	02 9c       	mov	r12,r1
80007d54:	fe b0 fd 00 	rcall	80007754 <memset>
80007d58:	40 28       	lddsp	r8,sp[0x8]
80007d5a:	40 19       	lddsp	r9,sp[0x4]
80007d5c:	e4 cc 00 01 	sub	r12,r2,1
80007d60:	0e 9b       	mov	r11,r7
80007d62:	50 3c       	stdsp	sp[0xc],r12
80007d64:	f2 0c 0c 49 	max	r9,r9,r12
80007d68:	c3 a8       	rjmp	80007ddc <get_arg+0x268>
80007d6a:	62 0a       	ld.w	r10,r1[0x0]
80007d6c:	5b fa       	cp.w	r10,-1
80007d6e:	c0 b1       	brne	80007d84 <get_arg+0x210>
80007d70:	50 19       	stdsp	sp[0x4],r9
80007d72:	50 28       	stdsp	sp[0x8],r8
80007d74:	e0 6a 00 80 	mov	r10,128
80007d78:	30 0b       	mov	r11,0
80007d7a:	02 9c       	mov	r12,r1
80007d7c:	fe b0 fc ec 	rcall	80007754 <memset>
80007d80:	40 28       	lddsp	r8,sp[0x8]
80007d82:	40 19       	lddsp	r9,sp[0x4]
80007d84:	20 12       	sub	r2,1
80007d86:	30 0a       	mov	r10,0
80007d88:	0e 9b       	mov	r11,r7
80007d8a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007d8e:	f2 02 0c 49 	max	r9,r9,r2
80007d92:	c2 58       	rjmp	80007ddc <get_arg+0x268>
80007d94:	16 97       	mov	r7,r11
80007d96:	6c 0a       	ld.w	r10,r6[0x0]
80007d98:	f4 cb ff fc 	sub	r11,r10,-4
80007d9c:	8d 0b       	st.w	r6[0x0],r11
80007d9e:	74 0a       	ld.w	r10,r10[0x0]
80007da0:	0e 9b       	mov	r11,r7
80007da2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007da6:	2f f5       	sub	r5,-1
80007da8:	c1 a8       	rjmp	80007ddc <get_arg+0x268>
80007daa:	f4 c2 00 30 	sub	r2,r10,48
80007dae:	c0 68       	rjmp	80007dba <get_arg+0x246>
80007db0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007db4:	2f f7       	sub	r7,-1
80007db6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007dba:	0f 8a       	ld.ub	r10,r7[0x0]
80007dbc:	58 0a       	cp.w	r10,0
80007dbe:	c0 e0       	breq	80007dda <get_arg+0x266>
80007dc0:	23 0a       	sub	r10,48
80007dc2:	58 9a       	cp.w	r10,9
80007dc4:	fe 98 ff f6 	brls	80007db0 <get_arg+0x23c>
80007dc8:	c0 98       	rjmp	80007dda <get_arg+0x266>
80007dca:	2f f7       	sub	r7,-1
80007dcc:	0f 8a       	ld.ub	r10,r7[0x0]
80007dce:	58 0a       	cp.w	r10,0
80007dd0:	c0 50       	breq	80007dda <get_arg+0x266>
80007dd2:	23 0a       	sub	r10,48
80007dd4:	58 9a       	cp.w	r10,9
80007dd6:	fe 98 ff fa 	brls	80007dca <get_arg+0x256>
80007dda:	0e 9b       	mov	r11,r7
80007ddc:	40 7c       	lddsp	r12,sp[0x1c]
80007dde:	30 ba       	mov	r10,11
80007de0:	f4 0c 18 00 	cp.b	r12,r10
80007de4:	fe 91 fe f2 	brne	80007bc8 <get_arg+0x54>
80007de8:	40 42       	lddsp	r2,sp[0x10]
80007dea:	17 8c       	ld.ub	r12,r11[0x0]
80007dec:	0a 32       	cp.w	r2,r5
80007dee:	5f 4a       	srge	r10
80007df0:	f0 0c 18 00 	cp.b	r12,r8
80007df4:	5f 1c       	srne	r12
80007df6:	f9 ea 00 0a 	and	r10,r12,r10
80007dfa:	f0 0a 18 00 	cp.b	r10,r8
80007dfe:	fe 91 fe cf 	brne	80007b9c <get_arg+0x28>
80007e02:	30 08       	mov	r8,0
80007e04:	40 4e       	lddsp	lr,sp[0x10]
80007e06:	17 8a       	ld.ub	r10,r11[0x0]
80007e08:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007e0c:	f0 0a 18 00 	cp.b	r10,r8
80007e10:	fc 09 17 10 	movne	r9,lr
80007e14:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007e18:	06 9e       	mov	lr,r3
80007e1a:	c2 a8       	rjmp	80007e6e <get_arg+0x2fa>
80007e1c:	62 0a       	ld.w	r10,r1[0x0]
80007e1e:	58 3a       	cp.w	r10,3
80007e20:	c1 e0       	breq	80007e5c <get_arg+0x2e8>
80007e22:	e0 89 00 07 	brgt	80007e30 <get_arg+0x2bc>
80007e26:	58 1a       	cp.w	r10,1
80007e28:	c1 a0       	breq	80007e5c <get_arg+0x2e8>
80007e2a:	58 2a       	cp.w	r10,2
80007e2c:	c1 81       	brne	80007e5c <get_arg+0x2e8>
80007e2e:	c0 58       	rjmp	80007e38 <get_arg+0x2c4>
80007e30:	58 5a       	cp.w	r10,5
80007e32:	c0 c0       	breq	80007e4a <get_arg+0x2d6>
80007e34:	c0 b5       	brlt	80007e4a <get_arg+0x2d6>
80007e36:	c1 38       	rjmp	80007e5c <get_arg+0x2e8>
80007e38:	6c 0a       	ld.w	r10,r6[0x0]
80007e3a:	f4 cc ff f8 	sub	r12,r10,-8
80007e3e:	8d 0c       	st.w	r6[0x0],r12
80007e40:	f4 e2 00 00 	ld.d	r2,r10[0]
80007e44:	f0 e3 00 00 	st.d	r8[0],r2
80007e48:	c1 08       	rjmp	80007e68 <get_arg+0x2f4>
80007e4a:	6c 0a       	ld.w	r10,r6[0x0]
80007e4c:	f4 cc ff f8 	sub	r12,r10,-8
80007e50:	8d 0c       	st.w	r6[0x0],r12
80007e52:	f4 e2 00 00 	ld.d	r2,r10[0]
80007e56:	f0 e3 00 00 	st.d	r8[0],r2
80007e5a:	c0 78       	rjmp	80007e68 <get_arg+0x2f4>
80007e5c:	6c 0a       	ld.w	r10,r6[0x0]
80007e5e:	f4 cc ff fc 	sub	r12,r10,-4
80007e62:	8d 0c       	st.w	r6[0x0],r12
80007e64:	74 0a       	ld.w	r10,r10[0x0]
80007e66:	91 0a       	st.w	r8[0x0],r10
80007e68:	2f f5       	sub	r5,-1
80007e6a:	2f 88       	sub	r8,-8
80007e6c:	2f c1       	sub	r1,-4
80007e6e:	12 35       	cp.w	r5,r9
80007e70:	fe 9a ff d6 	brle	80007e1c <get_arg+0x2a8>
80007e74:	1c 93       	mov	r3,lr
80007e76:	40 52       	lddsp	r2,sp[0x14]
80007e78:	40 6e       	lddsp	lr,sp[0x18]
80007e7a:	85 05       	st.w	r2[0x0],r5
80007e7c:	9d 0b       	st.w	lr[0x0],r11
80007e7e:	40 4b       	lddsp	r11,sp[0x10]
80007e80:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007e84:	2f 8d       	sub	sp,-32
80007e86:	d8 32       	popm	r0-r7,pc

80007e88 <__sprint_r>:
80007e88:	d4 21       	pushm	r4-r7,lr
80007e8a:	14 97       	mov	r7,r10
80007e8c:	74 28       	ld.w	r8,r10[0x8]
80007e8e:	58 08       	cp.w	r8,0
80007e90:	c0 41       	brne	80007e98 <__sprint_r+0x10>
80007e92:	95 18       	st.w	r10[0x4],r8
80007e94:	10 9c       	mov	r12,r8
80007e96:	d8 22       	popm	r4-r7,pc
80007e98:	e0 a0 18 ba 	rcall	8000b00c <__sfvwrite_r>
80007e9c:	30 08       	mov	r8,0
80007e9e:	8f 18       	st.w	r7[0x4],r8
80007ea0:	8f 28       	st.w	r7[0x8],r8
80007ea2:	d8 22       	popm	r4-r7,pc

80007ea4 <_vfprintf_r>:
80007ea4:	d4 31       	pushm	r0-r7,lr
80007ea6:	fa cd 06 bc 	sub	sp,sp,1724
80007eaa:	51 09       	stdsp	sp[0x40],r9
80007eac:	16 91       	mov	r1,r11
80007eae:	14 97       	mov	r7,r10
80007eb0:	18 95       	mov	r5,r12
80007eb2:	e0 a0 1a 1d 	rcall	8000b2ec <_localeconv_r>
80007eb6:	78 0c       	ld.w	r12,r12[0x0]
80007eb8:	50 cc       	stdsp	sp[0x30],r12
80007eba:	58 05       	cp.w	r5,0
80007ebc:	c0 70       	breq	80007eca <_vfprintf_r+0x26>
80007ebe:	6a 68       	ld.w	r8,r5[0x18]
80007ec0:	58 08       	cp.w	r8,0
80007ec2:	c0 41       	brne	80007eca <_vfprintf_r+0x26>
80007ec4:	0a 9c       	mov	r12,r5
80007ec6:	e0 a0 17 43 	rcall	8000ad4c <__sinit>
80007eca:	fe c8 a1 0e 	sub	r8,pc,-24306
80007ece:	10 31       	cp.w	r1,r8
80007ed0:	c0 31       	brne	80007ed6 <_vfprintf_r+0x32>
80007ed2:	6a 01       	ld.w	r1,r5[0x0]
80007ed4:	c0 c8       	rjmp	80007eec <_vfprintf_r+0x48>
80007ed6:	fe c8 a0 fa 	sub	r8,pc,-24326
80007eda:	10 31       	cp.w	r1,r8
80007edc:	c0 31       	brne	80007ee2 <_vfprintf_r+0x3e>
80007ede:	6a 11       	ld.w	r1,r5[0x4]
80007ee0:	c0 68       	rjmp	80007eec <_vfprintf_r+0x48>
80007ee2:	fe c8 a0 e6 	sub	r8,pc,-24346
80007ee6:	10 31       	cp.w	r1,r8
80007ee8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007eec:	82 68       	ld.sh	r8,r1[0xc]
80007eee:	ed b8 00 03 	bld	r8,0x3
80007ef2:	c0 41       	brne	80007efa <_vfprintf_r+0x56>
80007ef4:	62 48       	ld.w	r8,r1[0x10]
80007ef6:	58 08       	cp.w	r8,0
80007ef8:	c0 71       	brne	80007f06 <_vfprintf_r+0x62>
80007efa:	02 9b       	mov	r11,r1
80007efc:	0a 9c       	mov	r12,r5
80007efe:	e0 a0 0f 5d 	rcall	80009db8 <__swsetup_r>
80007f02:	e0 81 0f 54 	brne	80009daa <_vfprintf_r+0x1f06>
80007f06:	82 68       	ld.sh	r8,r1[0xc]
80007f08:	10 99       	mov	r9,r8
80007f0a:	e2 19 00 1a 	andl	r9,0x1a,COH
80007f0e:	58 a9       	cp.w	r9,10
80007f10:	c3 c1       	brne	80007f88 <_vfprintf_r+0xe4>
80007f12:	82 79       	ld.sh	r9,r1[0xe]
80007f14:	30 0a       	mov	r10,0
80007f16:	f4 09 19 00 	cp.h	r9,r10
80007f1a:	c3 75       	brlt	80007f88 <_vfprintf_r+0xe4>
80007f1c:	a1 d8       	cbr	r8,0x1
80007f1e:	fb 58 05 d0 	st.h	sp[1488],r8
80007f22:	62 88       	ld.w	r8,r1[0x20]
80007f24:	fb 48 05 e4 	st.w	sp[1508],r8
80007f28:	62 a8       	ld.w	r8,r1[0x28]
80007f2a:	fb 48 05 ec 	st.w	sp[1516],r8
80007f2e:	fa c8 ff bc 	sub	r8,sp,-68
80007f32:	fb 48 05 d4 	st.w	sp[1492],r8
80007f36:	fb 48 05 c4 	st.w	sp[1476],r8
80007f3a:	e0 68 04 00 	mov	r8,1024
80007f3e:	fb 48 05 d8 	st.w	sp[1496],r8
80007f42:	fb 48 05 cc 	st.w	sp[1484],r8
80007f46:	30 08       	mov	r8,0
80007f48:	fb 59 05 d2 	st.h	sp[1490],r9
80007f4c:	0e 9a       	mov	r10,r7
80007f4e:	41 09       	lddsp	r9,sp[0x40]
80007f50:	fa c7 fa 3c 	sub	r7,sp,-1476
80007f54:	fb 48 05 dc 	st.w	sp[1500],r8
80007f58:	0a 9c       	mov	r12,r5
80007f5a:	0e 9b       	mov	r11,r7
80007f5c:	ca 4f       	rcall	80007ea4 <_vfprintf_r>
80007f5e:	50 bc       	stdsp	sp[0x2c],r12
80007f60:	c0 95       	brlt	80007f72 <_vfprintf_r+0xce>
80007f62:	0e 9b       	mov	r11,r7
80007f64:	0a 9c       	mov	r12,r5
80007f66:	e0 a0 16 1b 	rcall	8000ab9c <_fflush_r>
80007f6a:	40 be       	lddsp	lr,sp[0x2c]
80007f6c:	f9 be 01 ff 	movne	lr,-1
80007f70:	50 be       	stdsp	sp[0x2c],lr
80007f72:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007f76:	ed b8 00 06 	bld	r8,0x6
80007f7a:	e0 81 0f 1a 	brne	80009dae <_vfprintf_r+0x1f0a>
80007f7e:	82 68       	ld.sh	r8,r1[0xc]
80007f80:	a7 a8       	sbr	r8,0x6
80007f82:	a2 68       	st.h	r1[0xc],r8
80007f84:	e0 8f 0f 15 	bral	80009dae <_vfprintf_r+0x1f0a>
80007f88:	30 08       	mov	r8,0
80007f8a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f8e:	fb 48 06 90 	st.w	sp[1680],r8
80007f92:	fb 48 06 8c 	st.w	sp[1676],r8
80007f96:	fb 48 06 b0 	st.w	sp[1712],r8
80007f9a:	30 08       	mov	r8,0
80007f9c:	30 09       	mov	r9,0
80007f9e:	50 a7       	stdsp	sp[0x28],r7
80007fa0:	50 78       	stdsp	sp[0x1c],r8
80007fa2:	fa c3 f9 e0 	sub	r3,sp,-1568
80007fa6:	3f f8       	mov	r8,-1
80007fa8:	50 59       	stdsp	sp[0x14],r9
80007faa:	fb 43 06 88 	st.w	sp[1672],r3
80007fae:	fb 48 05 44 	st.w	sp[1348],r8
80007fb2:	12 9c       	mov	r12,r9
80007fb4:	50 69       	stdsp	sp[0x18],r9
80007fb6:	50 d9       	stdsp	sp[0x34],r9
80007fb8:	50 e9       	stdsp	sp[0x38],r9
80007fba:	50 b9       	stdsp	sp[0x2c],r9
80007fbc:	12 97       	mov	r7,r9
80007fbe:	0a 94       	mov	r4,r5
80007fc0:	40 a2       	lddsp	r2,sp[0x28]
80007fc2:	32 5a       	mov	r10,37
80007fc4:	30 08       	mov	r8,0
80007fc6:	c0 28       	rjmp	80007fca <_vfprintf_r+0x126>
80007fc8:	2f f2       	sub	r2,-1
80007fca:	05 89       	ld.ub	r9,r2[0x0]
80007fcc:	f0 09 18 00 	cp.b	r9,r8
80007fd0:	5f 1b       	srne	r11
80007fd2:	f4 09 18 00 	cp.b	r9,r10
80007fd6:	5f 19       	srne	r9
80007fd8:	f3 eb 00 0b 	and	r11,r9,r11
80007fdc:	f0 0b 18 00 	cp.b	r11,r8
80007fe0:	cf 41       	brne	80007fc8 <_vfprintf_r+0x124>
80007fe2:	40 ab       	lddsp	r11,sp[0x28]
80007fe4:	e4 0b 01 06 	sub	r6,r2,r11
80007fe8:	c1 e0       	breq	80008024 <_vfprintf_r+0x180>
80007fea:	fa f8 06 90 	ld.w	r8,sp[1680]
80007fee:	0c 08       	add	r8,r6
80007ff0:	87 0b       	st.w	r3[0x0],r11
80007ff2:	fb 48 06 90 	st.w	sp[1680],r8
80007ff6:	87 16       	st.w	r3[0x4],r6
80007ff8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007ffc:	2f f8       	sub	r8,-1
80007ffe:	fb 48 06 8c 	st.w	sp[1676],r8
80008002:	58 78       	cp.w	r8,7
80008004:	e0 89 00 04 	brgt	8000800c <_vfprintf_r+0x168>
80008008:	2f 83       	sub	r3,-8
8000800a:	c0 a8       	rjmp	8000801e <_vfprintf_r+0x17a>
8000800c:	fa ca f9 78 	sub	r10,sp,-1672
80008010:	02 9b       	mov	r11,r1
80008012:	08 9c       	mov	r12,r4
80008014:	c3 af       	rcall	80007e88 <__sprint_r>
80008016:	e0 81 0e c6 	brne	80009da2 <_vfprintf_r+0x1efe>
8000801a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000801e:	40 ba       	lddsp	r10,sp[0x2c]
80008020:	0c 0a       	add	r10,r6
80008022:	50 ba       	stdsp	sp[0x2c],r10
80008024:	05 89       	ld.ub	r9,r2[0x0]
80008026:	30 08       	mov	r8,0
80008028:	f0 09 18 00 	cp.b	r9,r8
8000802c:	e0 80 0e aa 	breq	80009d80 <_vfprintf_r+0x1edc>
80008030:	30 09       	mov	r9,0
80008032:	fb 68 06 bb 	st.b	sp[1723],r8
80008036:	0e 96       	mov	r6,r7
80008038:	e4 c8 ff ff 	sub	r8,r2,-1
8000803c:	3f fe       	mov	lr,-1
8000803e:	50 93       	stdsp	sp[0x24],r3
80008040:	50 41       	stdsp	sp[0x10],r1
80008042:	0e 93       	mov	r3,r7
80008044:	04 91       	mov	r1,r2
80008046:	50 89       	stdsp	sp[0x20],r9
80008048:	50 a8       	stdsp	sp[0x28],r8
8000804a:	50 2e       	stdsp	sp[0x8],lr
8000804c:	50 39       	stdsp	sp[0xc],r9
8000804e:	12 95       	mov	r5,r9
80008050:	12 90       	mov	r0,r9
80008052:	10 97       	mov	r7,r8
80008054:	08 92       	mov	r2,r4
80008056:	c0 78       	rjmp	80008064 <_vfprintf_r+0x1c0>
80008058:	3f fc       	mov	r12,-1
8000805a:	08 97       	mov	r7,r4
8000805c:	50 2c       	stdsp	sp[0x8],r12
8000805e:	c0 38       	rjmp	80008064 <_vfprintf_r+0x1c0>
80008060:	30 0b       	mov	r11,0
80008062:	50 3b       	stdsp	sp[0xc],r11
80008064:	0f 38       	ld.ub	r8,r7++
80008066:	c0 28       	rjmp	8000806a <_vfprintf_r+0x1c6>
80008068:	12 90       	mov	r0,r9
8000806a:	f0 c9 00 20 	sub	r9,r8,32
8000806e:	e0 49 00 58 	cp.w	r9,88
80008072:	e0 8b 0a 30 	brhi	800094d2 <_vfprintf_r+0x162e>
80008076:	fe ca a6 62 	sub	r10,pc,-22942
8000807a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000807e:	50 a7       	stdsp	sp[0x28],r7
80008080:	50 80       	stdsp	sp[0x20],r0
80008082:	0c 97       	mov	r7,r6
80008084:	04 94       	mov	r4,r2
80008086:	06 96       	mov	r6,r3
80008088:	02 92       	mov	r2,r1
8000808a:	fe c9 a4 3a 	sub	r9,pc,-23494
8000808e:	40 93       	lddsp	r3,sp[0x24]
80008090:	10 90       	mov	r0,r8
80008092:	40 41       	lddsp	r1,sp[0x10]
80008094:	50 d9       	stdsp	sp[0x34],r9
80008096:	e0 8f 08 8e 	bral	800091b2 <_vfprintf_r+0x130e>
8000809a:	30 08       	mov	r8,0
8000809c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800080a0:	f0 09 18 00 	cp.b	r9,r8
800080a4:	ce 01       	brne	80008064 <_vfprintf_r+0x1c0>
800080a6:	32 08       	mov	r8,32
800080a8:	c6 e8       	rjmp	80008184 <_vfprintf_r+0x2e0>
800080aa:	a1 a5       	sbr	r5,0x0
800080ac:	cd cb       	rjmp	80008064 <_vfprintf_r+0x1c0>
800080ae:	0f 89       	ld.ub	r9,r7[0x0]
800080b0:	f2 c8 00 30 	sub	r8,r9,48
800080b4:	58 98       	cp.w	r8,9
800080b6:	e0 8b 00 1d 	brhi	800080f0 <_vfprintf_r+0x24c>
800080ba:	ee c8 ff ff 	sub	r8,r7,-1
800080be:	30 0b       	mov	r11,0
800080c0:	23 09       	sub	r9,48
800080c2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800080c6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800080ca:	11 39       	ld.ub	r9,r8++
800080cc:	f2 ca 00 30 	sub	r10,r9,48
800080d0:	58 9a       	cp.w	r10,9
800080d2:	fe 98 ff f7 	brls	800080c0 <_vfprintf_r+0x21c>
800080d6:	e0 49 00 24 	cp.w	r9,36
800080da:	cc 31       	brne	80008060 <_vfprintf_r+0x1bc>
800080dc:	e0 4b 00 20 	cp.w	r11,32
800080e0:	e0 89 0e 60 	brgt	80009da0 <_vfprintf_r+0x1efc>
800080e4:	20 1b       	sub	r11,1
800080e6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800080ea:	12 3b       	cp.w	r11,r9
800080ec:	c0 95       	brlt	800080fe <_vfprintf_r+0x25a>
800080ee:	c1 08       	rjmp	8000810e <_vfprintf_r+0x26a>
800080f0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800080f4:	ec ca ff ff 	sub	r10,r6,-1
800080f8:	12 36       	cp.w	r6,r9
800080fa:	c1 f5       	brlt	80008138 <_vfprintf_r+0x294>
800080fc:	c2 68       	rjmp	80008148 <_vfprintf_r+0x2a4>
800080fe:	fa ce f9 44 	sub	lr,sp,-1724
80008102:	10 97       	mov	r7,r8
80008104:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008108:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000810c:	c3 58       	rjmp	80008176 <_vfprintf_r+0x2d2>
8000810e:	10 97       	mov	r7,r8
80008110:	fa c8 f9 50 	sub	r8,sp,-1712
80008114:	1a d8       	st.w	--sp,r8
80008116:	fa c8 fa b8 	sub	r8,sp,-1352
8000811a:	1a d8       	st.w	--sp,r8
8000811c:	fa c8 fb b4 	sub	r8,sp,-1100
80008120:	02 9a       	mov	r10,r1
80008122:	1a d8       	st.w	--sp,r8
80008124:	04 9c       	mov	r12,r2
80008126:	fa c8 f9 40 	sub	r8,sp,-1728
8000812a:	fa c9 ff b4 	sub	r9,sp,-76
8000812e:	fe b0 fd 23 	rcall	80007b74 <get_arg>
80008132:	2f dd       	sub	sp,-12
80008134:	78 00       	ld.w	r0,r12[0x0]
80008136:	c2 08       	rjmp	80008176 <_vfprintf_r+0x2d2>
80008138:	fa cc f9 44 	sub	r12,sp,-1724
8000813c:	14 96       	mov	r6,r10
8000813e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008142:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008146:	c1 88       	rjmp	80008176 <_vfprintf_r+0x2d2>
80008148:	41 08       	lddsp	r8,sp[0x40]
8000814a:	59 f9       	cp.w	r9,31
8000814c:	e0 89 00 11 	brgt	8000816e <_vfprintf_r+0x2ca>
80008150:	f0 cb ff fc 	sub	r11,r8,-4
80008154:	51 0b       	stdsp	sp[0x40],r11
80008156:	70 00       	ld.w	r0,r8[0x0]
80008158:	fa cb f9 44 	sub	r11,sp,-1724
8000815c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008160:	f1 40 fd 88 	st.w	r8[-632],r0
80008164:	2f f9       	sub	r9,-1
80008166:	14 96       	mov	r6,r10
80008168:	fb 49 06 b4 	st.w	sp[1716],r9
8000816c:	c0 58       	rjmp	80008176 <_vfprintf_r+0x2d2>
8000816e:	70 00       	ld.w	r0,r8[0x0]
80008170:	14 96       	mov	r6,r10
80008172:	2f c8       	sub	r8,-4
80008174:	51 08       	stdsp	sp[0x40],r8
80008176:	58 00       	cp.w	r0,0
80008178:	fe 94 ff 76 	brge	80008064 <_vfprintf_r+0x1c0>
8000817c:	5c 30       	neg	r0
8000817e:	a3 a5       	sbr	r5,0x2
80008180:	c7 2b       	rjmp	80008064 <_vfprintf_r+0x1c0>
80008182:	32 b8       	mov	r8,43
80008184:	fb 68 06 bb 	st.b	sp[1723],r8
80008188:	c6 eb       	rjmp	80008064 <_vfprintf_r+0x1c0>
8000818a:	0f 38       	ld.ub	r8,r7++
8000818c:	e0 48 00 2a 	cp.w	r8,42
80008190:	c0 30       	breq	80008196 <_vfprintf_r+0x2f2>
80008192:	30 09       	mov	r9,0
80008194:	c7 98       	rjmp	80008286 <_vfprintf_r+0x3e2>
80008196:	0f 88       	ld.ub	r8,r7[0x0]
80008198:	f0 c9 00 30 	sub	r9,r8,48
8000819c:	58 99       	cp.w	r9,9
8000819e:	e0 8b 00 1f 	brhi	800081dc <_vfprintf_r+0x338>
800081a2:	ee c4 ff ff 	sub	r4,r7,-1
800081a6:	30 0b       	mov	r11,0
800081a8:	23 08       	sub	r8,48
800081aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800081ae:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800081b2:	09 38       	ld.ub	r8,r4++
800081b4:	f0 c9 00 30 	sub	r9,r8,48
800081b8:	58 99       	cp.w	r9,9
800081ba:	fe 98 ff f7 	brls	800081a8 <_vfprintf_r+0x304>
800081be:	e0 48 00 24 	cp.w	r8,36
800081c2:	fe 91 ff 4f 	brne	80008060 <_vfprintf_r+0x1bc>
800081c6:	e0 4b 00 20 	cp.w	r11,32
800081ca:	e0 89 0d eb 	brgt	80009da0 <_vfprintf_r+0x1efc>
800081ce:	20 1b       	sub	r11,1
800081d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081d4:	10 3b       	cp.w	r11,r8
800081d6:	c0 a5       	brlt	800081ea <_vfprintf_r+0x346>
800081d8:	c1 18       	rjmp	800081fa <_vfprintf_r+0x356>
800081da:	d7 03       	nop
800081dc:	fa fa 06 b4 	ld.w	r10,sp[1716]
800081e0:	ec c9 ff ff 	sub	r9,r6,-1
800081e4:	14 36       	cp.w	r6,r10
800081e6:	c1 f5       	brlt	80008224 <_vfprintf_r+0x380>
800081e8:	c2 88       	rjmp	80008238 <_vfprintf_r+0x394>
800081ea:	fa ca f9 44 	sub	r10,sp,-1724
800081ee:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800081f2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800081f6:	50 2b       	stdsp	sp[0x8],r11
800081f8:	c3 c8       	rjmp	80008270 <_vfprintf_r+0x3cc>
800081fa:	fa c8 f9 50 	sub	r8,sp,-1712
800081fe:	1a d8       	st.w	--sp,r8
80008200:	fa c8 fa b8 	sub	r8,sp,-1352
80008204:	1a d8       	st.w	--sp,r8
80008206:	fa c8 fb b4 	sub	r8,sp,-1100
8000820a:	02 9a       	mov	r10,r1
8000820c:	1a d8       	st.w	--sp,r8
8000820e:	04 9c       	mov	r12,r2
80008210:	fa c8 f9 40 	sub	r8,sp,-1728
80008214:	fa c9 ff b4 	sub	r9,sp,-76
80008218:	fe b0 fc ae 	rcall	80007b74 <get_arg>
8000821c:	2f dd       	sub	sp,-12
8000821e:	78 0c       	ld.w	r12,r12[0x0]
80008220:	50 2c       	stdsp	sp[0x8],r12
80008222:	c2 78       	rjmp	80008270 <_vfprintf_r+0x3cc>
80008224:	12 96       	mov	r6,r9
80008226:	0e 94       	mov	r4,r7
80008228:	fa c9 f9 44 	sub	r9,sp,-1724
8000822c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008230:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008234:	50 28       	stdsp	sp[0x8],r8
80008236:	c1 d8       	rjmp	80008270 <_vfprintf_r+0x3cc>
80008238:	41 08       	lddsp	r8,sp[0x40]
8000823a:	59 fa       	cp.w	r10,31
8000823c:	e0 89 00 14 	brgt	80008264 <_vfprintf_r+0x3c0>
80008240:	f0 cb ff fc 	sub	r11,r8,-4
80008244:	70 08       	ld.w	r8,r8[0x0]
80008246:	51 0b       	stdsp	sp[0x40],r11
80008248:	50 28       	stdsp	sp[0x8],r8
8000824a:	fa c6 f9 44 	sub	r6,sp,-1724
8000824e:	40 2e       	lddsp	lr,sp[0x8]
80008250:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008254:	f1 4e fd 88 	st.w	r8[-632],lr
80008258:	2f fa       	sub	r10,-1
8000825a:	0e 94       	mov	r4,r7
8000825c:	fb 4a 06 b4 	st.w	sp[1716],r10
80008260:	12 96       	mov	r6,r9
80008262:	c0 78       	rjmp	80008270 <_vfprintf_r+0x3cc>
80008264:	70 0c       	ld.w	r12,r8[0x0]
80008266:	0e 94       	mov	r4,r7
80008268:	2f c8       	sub	r8,-4
8000826a:	50 2c       	stdsp	sp[0x8],r12
8000826c:	12 96       	mov	r6,r9
8000826e:	51 08       	stdsp	sp[0x40],r8
80008270:	40 2b       	lddsp	r11,sp[0x8]
80008272:	58 0b       	cp.w	r11,0
80008274:	fe 95 fe f2 	brlt	80008058 <_vfprintf_r+0x1b4>
80008278:	08 97       	mov	r7,r4
8000827a:	cf 5a       	rjmp	80008064 <_vfprintf_r+0x1c0>
8000827c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008280:	0f 38       	ld.ub	r8,r7++
80008282:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008286:	f0 ca 00 30 	sub	r10,r8,48
8000828a:	58 9a       	cp.w	r10,9
8000828c:	fe 98 ff f8 	brls	8000827c <_vfprintf_r+0x3d8>
80008290:	3f fa       	mov	r10,-1
80008292:	f2 0a 0c 49 	max	r9,r9,r10
80008296:	50 29       	stdsp	sp[0x8],r9
80008298:	ce 9a       	rjmp	8000806a <_vfprintf_r+0x1c6>
8000829a:	a7 b5       	sbr	r5,0x7
8000829c:	ce 4a       	rjmp	80008064 <_vfprintf_r+0x1c0>
8000829e:	30 09       	mov	r9,0
800082a0:	23 08       	sub	r8,48
800082a2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800082a6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800082aa:	0f 38       	ld.ub	r8,r7++
800082ac:	f0 ca 00 30 	sub	r10,r8,48
800082b0:	58 9a       	cp.w	r10,9
800082b2:	fe 98 ff f7 	brls	800082a0 <_vfprintf_r+0x3fc>
800082b6:	e0 48 00 24 	cp.w	r8,36
800082ba:	fe 91 fe d7 	brne	80008068 <_vfprintf_r+0x1c4>
800082be:	e0 49 00 20 	cp.w	r9,32
800082c2:	e0 89 0d 6f 	brgt	80009da0 <_vfprintf_r+0x1efc>
800082c6:	f2 c3 00 01 	sub	r3,r9,1
800082ca:	30 19       	mov	r9,1
800082cc:	50 39       	stdsp	sp[0xc],r9
800082ce:	cc ba       	rjmp	80008064 <_vfprintf_r+0x1c0>
800082d0:	a3 b5       	sbr	r5,0x3
800082d2:	cc 9a       	rjmp	80008064 <_vfprintf_r+0x1c0>
800082d4:	a7 a5       	sbr	r5,0x6
800082d6:	cc 7a       	rjmp	80008064 <_vfprintf_r+0x1c0>
800082d8:	0a 98       	mov	r8,r5
800082da:	a5 b5       	sbr	r5,0x5
800082dc:	a5 a8       	sbr	r8,0x4
800082de:	0f 89       	ld.ub	r9,r7[0x0]
800082e0:	36 ce       	mov	lr,108
800082e2:	fc 09 18 00 	cp.b	r9,lr
800082e6:	f7 b7 00 ff 	subeq	r7,-1
800082ea:	f0 05 17 10 	movne	r5,r8
800082ee:	cb ba       	rjmp	80008064 <_vfprintf_r+0x1c0>
800082f0:	a5 b5       	sbr	r5,0x5
800082f2:	cb 9a       	rjmp	80008064 <_vfprintf_r+0x1c0>
800082f4:	50 a7       	stdsp	sp[0x28],r7
800082f6:	50 80       	stdsp	sp[0x20],r0
800082f8:	0c 97       	mov	r7,r6
800082fa:	10 90       	mov	r0,r8
800082fc:	06 96       	mov	r6,r3
800082fe:	04 94       	mov	r4,r2
80008300:	40 93       	lddsp	r3,sp[0x24]
80008302:	02 92       	mov	r2,r1
80008304:	0e 99       	mov	r9,r7
80008306:	40 41       	lddsp	r1,sp[0x10]
80008308:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000830c:	40 3c       	lddsp	r12,sp[0xc]
8000830e:	58 0c       	cp.w	r12,0
80008310:	c1 d0       	breq	8000834a <_vfprintf_r+0x4a6>
80008312:	10 36       	cp.w	r6,r8
80008314:	c0 64       	brge	80008320 <_vfprintf_r+0x47c>
80008316:	fa cb f9 44 	sub	r11,sp,-1724
8000831a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000831e:	c1 d8       	rjmp	80008358 <_vfprintf_r+0x4b4>
80008320:	fa c8 f9 50 	sub	r8,sp,-1712
80008324:	1a d8       	st.w	--sp,r8
80008326:	fa c8 fa b8 	sub	r8,sp,-1352
8000832a:	1a d8       	st.w	--sp,r8
8000832c:	fa c8 fb b4 	sub	r8,sp,-1100
80008330:	1a d8       	st.w	--sp,r8
80008332:	fa c8 f9 40 	sub	r8,sp,-1728
80008336:	fa c9 ff b4 	sub	r9,sp,-76
8000833a:	04 9a       	mov	r10,r2
8000833c:	0c 9b       	mov	r11,r6
8000833e:	08 9c       	mov	r12,r4
80008340:	fe b0 fc 1a 	rcall	80007b74 <get_arg>
80008344:	2f dd       	sub	sp,-12
80008346:	19 b8       	ld.ub	r8,r12[0x3]
80008348:	c2 28       	rjmp	8000838c <_vfprintf_r+0x4e8>
8000834a:	2f f7       	sub	r7,-1
8000834c:	10 39       	cp.w	r9,r8
8000834e:	c0 84       	brge	8000835e <_vfprintf_r+0x4ba>
80008350:	fa ca f9 44 	sub	r10,sp,-1724
80008354:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008358:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000835c:	c1 88       	rjmp	8000838c <_vfprintf_r+0x4e8>
8000835e:	41 09       	lddsp	r9,sp[0x40]
80008360:	59 f8       	cp.w	r8,31
80008362:	e0 89 00 12 	brgt	80008386 <_vfprintf_r+0x4e2>
80008366:	f2 ca ff fc 	sub	r10,r9,-4
8000836a:	51 0a       	stdsp	sp[0x40],r10
8000836c:	72 09       	ld.w	r9,r9[0x0]
8000836e:	fa c6 f9 44 	sub	r6,sp,-1724
80008372:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008376:	2f f8       	sub	r8,-1
80008378:	f5 49 fd 88 	st.w	r10[-632],r9
8000837c:	fb 48 06 b4 	st.w	sp[1716],r8
80008380:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008384:	c0 48       	rjmp	8000838c <_vfprintf_r+0x4e8>
80008386:	13 b8       	ld.ub	r8,r9[0x3]
80008388:	2f c9       	sub	r9,-4
8000838a:	51 09       	stdsp	sp[0x40],r9
8000838c:	fb 68 06 60 	st.b	sp[1632],r8
80008390:	30 0e       	mov	lr,0
80008392:	30 08       	mov	r8,0
80008394:	30 12       	mov	r2,1
80008396:	fb 68 06 bb 	st.b	sp[1723],r8
8000839a:	50 2e       	stdsp	sp[0x8],lr
8000839c:	e0 8f 08 ad 	bral	800094f6 <_vfprintf_r+0x1652>
800083a0:	50 a7       	stdsp	sp[0x28],r7
800083a2:	50 80       	stdsp	sp[0x20],r0
800083a4:	0c 97       	mov	r7,r6
800083a6:	04 94       	mov	r4,r2
800083a8:	06 96       	mov	r6,r3
800083aa:	02 92       	mov	r2,r1
800083ac:	40 93       	lddsp	r3,sp[0x24]
800083ae:	10 90       	mov	r0,r8
800083b0:	40 41       	lddsp	r1,sp[0x10]
800083b2:	a5 a5       	sbr	r5,0x4
800083b4:	c0 a8       	rjmp	800083c8 <_vfprintf_r+0x524>
800083b6:	50 a7       	stdsp	sp[0x28],r7
800083b8:	50 80       	stdsp	sp[0x20],r0
800083ba:	0c 97       	mov	r7,r6
800083bc:	04 94       	mov	r4,r2
800083be:	06 96       	mov	r6,r3
800083c0:	02 92       	mov	r2,r1
800083c2:	40 93       	lddsp	r3,sp[0x24]
800083c4:	10 90       	mov	r0,r8
800083c6:	40 41       	lddsp	r1,sp[0x10]
800083c8:	ed b5 00 05 	bld	r5,0x5
800083cc:	c5 11       	brne	8000846e <_vfprintf_r+0x5ca>
800083ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083d2:	40 3c       	lddsp	r12,sp[0xc]
800083d4:	58 0c       	cp.w	r12,0
800083d6:	c1 e0       	breq	80008412 <_vfprintf_r+0x56e>
800083d8:	10 36       	cp.w	r6,r8
800083da:	c0 64       	brge	800083e6 <_vfprintf_r+0x542>
800083dc:	fa cb f9 44 	sub	r11,sp,-1724
800083e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083e4:	c2 08       	rjmp	80008424 <_vfprintf_r+0x580>
800083e6:	fa c8 f9 50 	sub	r8,sp,-1712
800083ea:	1a d8       	st.w	--sp,r8
800083ec:	fa c8 fa b8 	sub	r8,sp,-1352
800083f0:	0c 9b       	mov	r11,r6
800083f2:	1a d8       	st.w	--sp,r8
800083f4:	fa c8 fb b4 	sub	r8,sp,-1100
800083f8:	1a d8       	st.w	--sp,r8
800083fa:	fa c9 ff b4 	sub	r9,sp,-76
800083fe:	fa c8 f9 40 	sub	r8,sp,-1728
80008402:	04 9a       	mov	r10,r2
80008404:	08 9c       	mov	r12,r4
80008406:	fe b0 fb b7 	rcall	80007b74 <get_arg>
8000840a:	2f dd       	sub	sp,-12
8000840c:	78 1b       	ld.w	r11,r12[0x4]
8000840e:	78 09       	ld.w	r9,r12[0x0]
80008410:	c2 b8       	rjmp	80008466 <_vfprintf_r+0x5c2>
80008412:	ee ca ff ff 	sub	r10,r7,-1
80008416:	10 37       	cp.w	r7,r8
80008418:	c0 b4       	brge	8000842e <_vfprintf_r+0x58a>
8000841a:	fa c9 f9 44 	sub	r9,sp,-1724
8000841e:	14 97       	mov	r7,r10
80008420:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008424:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008428:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000842c:	c1 d8       	rjmp	80008466 <_vfprintf_r+0x5c2>
8000842e:	41 09       	lddsp	r9,sp[0x40]
80008430:	59 f8       	cp.w	r8,31
80008432:	e0 89 00 14 	brgt	8000845a <_vfprintf_r+0x5b6>
80008436:	f2 cb ff f8 	sub	r11,r9,-8
8000843a:	51 0b       	stdsp	sp[0x40],r11
8000843c:	fa c6 f9 44 	sub	r6,sp,-1724
80008440:	72 1b       	ld.w	r11,r9[0x4]
80008442:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008446:	72 09       	ld.w	r9,r9[0x0]
80008448:	f9 4b fd 8c 	st.w	r12[-628],r11
8000844c:	f9 49 fd 88 	st.w	r12[-632],r9
80008450:	2f f8       	sub	r8,-1
80008452:	14 97       	mov	r7,r10
80008454:	fb 48 06 b4 	st.w	sp[1716],r8
80008458:	c0 78       	rjmp	80008466 <_vfprintf_r+0x5c2>
8000845a:	f2 c8 ff f8 	sub	r8,r9,-8
8000845e:	72 1b       	ld.w	r11,r9[0x4]
80008460:	14 97       	mov	r7,r10
80008462:	51 08       	stdsp	sp[0x40],r8
80008464:	72 09       	ld.w	r9,r9[0x0]
80008466:	16 98       	mov	r8,r11
80008468:	fa e9 00 00 	st.d	sp[0],r8
8000846c:	ca e8       	rjmp	800085c8 <_vfprintf_r+0x724>
8000846e:	ed b5 00 04 	bld	r5,0x4
80008472:	c1 71       	brne	800084a0 <_vfprintf_r+0x5fc>
80008474:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008478:	40 3e       	lddsp	lr,sp[0xc]
8000847a:	58 0e       	cp.w	lr,0
8000847c:	c0 80       	breq	8000848c <_vfprintf_r+0x5e8>
8000847e:	10 36       	cp.w	r6,r8
80008480:	c6 94       	brge	80008552 <_vfprintf_r+0x6ae>
80008482:	fa cc f9 44 	sub	r12,sp,-1724
80008486:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000848a:	c8 28       	rjmp	8000858e <_vfprintf_r+0x6ea>
8000848c:	ee ca ff ff 	sub	r10,r7,-1
80008490:	10 37       	cp.w	r7,r8
80008492:	e0 84 00 81 	brge	80008594 <_vfprintf_r+0x6f0>
80008496:	fa cb f9 44 	sub	r11,sp,-1724
8000849a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000849e:	c7 78       	rjmp	8000858c <_vfprintf_r+0x6e8>
800084a0:	ed b5 00 06 	bld	r5,0x6
800084a4:	c4 b1       	brne	8000853a <_vfprintf_r+0x696>
800084a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084aa:	40 3c       	lddsp	r12,sp[0xc]
800084ac:	58 0c       	cp.w	r12,0
800084ae:	c1 d0       	breq	800084e8 <_vfprintf_r+0x644>
800084b0:	10 36       	cp.w	r6,r8
800084b2:	c0 64       	brge	800084be <_vfprintf_r+0x61a>
800084b4:	fa cb f9 44 	sub	r11,sp,-1724
800084b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084bc:	c1 f8       	rjmp	800084fa <_vfprintf_r+0x656>
800084be:	fa c8 f9 50 	sub	r8,sp,-1712
800084c2:	1a d8       	st.w	--sp,r8
800084c4:	fa c8 fa b8 	sub	r8,sp,-1352
800084c8:	1a d8       	st.w	--sp,r8
800084ca:	fa c8 fb b4 	sub	r8,sp,-1100
800084ce:	1a d8       	st.w	--sp,r8
800084d0:	fa c8 f9 40 	sub	r8,sp,-1728
800084d4:	fa c9 ff b4 	sub	r9,sp,-76
800084d8:	04 9a       	mov	r10,r2
800084da:	0c 9b       	mov	r11,r6
800084dc:	08 9c       	mov	r12,r4
800084de:	fe b0 fb 4b 	rcall	80007b74 <get_arg>
800084e2:	2f dd       	sub	sp,-12
800084e4:	98 18       	ld.sh	r8,r12[0x2]
800084e6:	c2 68       	rjmp	80008532 <_vfprintf_r+0x68e>
800084e8:	ee ca ff ff 	sub	r10,r7,-1
800084ec:	10 37       	cp.w	r7,r8
800084ee:	c0 94       	brge	80008500 <_vfprintf_r+0x65c>
800084f0:	fa c9 f9 44 	sub	r9,sp,-1724
800084f4:	14 97       	mov	r7,r10
800084f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800084fe:	c1 a8       	rjmp	80008532 <_vfprintf_r+0x68e>
80008500:	41 09       	lddsp	r9,sp[0x40]
80008502:	59 f8       	cp.w	r8,31
80008504:	e0 89 00 13 	brgt	8000852a <_vfprintf_r+0x686>
80008508:	f2 cb ff fc 	sub	r11,r9,-4
8000850c:	51 0b       	stdsp	sp[0x40],r11
8000850e:	72 09       	ld.w	r9,r9[0x0]
80008510:	fa c6 f9 44 	sub	r6,sp,-1724
80008514:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008518:	2f f8       	sub	r8,-1
8000851a:	f7 49 fd 88 	st.w	r11[-632],r9
8000851e:	fb 48 06 b4 	st.w	sp[1716],r8
80008522:	14 97       	mov	r7,r10
80008524:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008528:	c0 58       	rjmp	80008532 <_vfprintf_r+0x68e>
8000852a:	92 18       	ld.sh	r8,r9[0x2]
8000852c:	14 97       	mov	r7,r10
8000852e:	2f c9       	sub	r9,-4
80008530:	51 09       	stdsp	sp[0x40],r9
80008532:	50 18       	stdsp	sp[0x4],r8
80008534:	bf 58       	asr	r8,0x1f
80008536:	50 08       	stdsp	sp[0x0],r8
80008538:	c4 88       	rjmp	800085c8 <_vfprintf_r+0x724>
8000853a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000853e:	40 3c       	lddsp	r12,sp[0xc]
80008540:	58 0c       	cp.w	r12,0
80008542:	c1 d0       	breq	8000857c <_vfprintf_r+0x6d8>
80008544:	10 36       	cp.w	r6,r8
80008546:	c0 64       	brge	80008552 <_vfprintf_r+0x6ae>
80008548:	fa cb f9 44 	sub	r11,sp,-1724
8000854c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008550:	c1 f8       	rjmp	8000858e <_vfprintf_r+0x6ea>
80008552:	fa c8 f9 50 	sub	r8,sp,-1712
80008556:	1a d8       	st.w	--sp,r8
80008558:	fa c8 fa b8 	sub	r8,sp,-1352
8000855c:	0c 9b       	mov	r11,r6
8000855e:	1a d8       	st.w	--sp,r8
80008560:	fa c8 fb b4 	sub	r8,sp,-1100
80008564:	04 9a       	mov	r10,r2
80008566:	1a d8       	st.w	--sp,r8
80008568:	08 9c       	mov	r12,r4
8000856a:	fa c8 f9 40 	sub	r8,sp,-1728
8000856e:	fa c9 ff b4 	sub	r9,sp,-76
80008572:	fe b0 fb 01 	rcall	80007b74 <get_arg>
80008576:	2f dd       	sub	sp,-12
80008578:	78 0b       	ld.w	r11,r12[0x0]
8000857a:	c2 48       	rjmp	800085c2 <_vfprintf_r+0x71e>
8000857c:	ee ca ff ff 	sub	r10,r7,-1
80008580:	10 37       	cp.w	r7,r8
80008582:	c0 94       	brge	80008594 <_vfprintf_r+0x6f0>
80008584:	fa c9 f9 44 	sub	r9,sp,-1724
80008588:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000858c:	14 97       	mov	r7,r10
8000858e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008592:	c1 88       	rjmp	800085c2 <_vfprintf_r+0x71e>
80008594:	41 09       	lddsp	r9,sp[0x40]
80008596:	59 f8       	cp.w	r8,31
80008598:	e0 89 00 11 	brgt	800085ba <_vfprintf_r+0x716>
8000859c:	f2 cb ff fc 	sub	r11,r9,-4
800085a0:	51 0b       	stdsp	sp[0x40],r11
800085a2:	fa c6 f9 44 	sub	r6,sp,-1724
800085a6:	72 0b       	ld.w	r11,r9[0x0]
800085a8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085ac:	f3 4b fd 88 	st.w	r9[-632],r11
800085b0:	2f f8       	sub	r8,-1
800085b2:	14 97       	mov	r7,r10
800085b4:	fb 48 06 b4 	st.w	sp[1716],r8
800085b8:	c0 58       	rjmp	800085c2 <_vfprintf_r+0x71e>
800085ba:	72 0b       	ld.w	r11,r9[0x0]
800085bc:	14 97       	mov	r7,r10
800085be:	2f c9       	sub	r9,-4
800085c0:	51 09       	stdsp	sp[0x40],r9
800085c2:	50 1b       	stdsp	sp[0x4],r11
800085c4:	bf 5b       	asr	r11,0x1f
800085c6:	50 0b       	stdsp	sp[0x0],r11
800085c8:	fa ea 00 00 	ld.d	r10,sp[0]
800085cc:	58 0a       	cp.w	r10,0
800085ce:	5c 2b       	cpc	r11
800085d0:	c0 e4       	brge	800085ec <_vfprintf_r+0x748>
800085d2:	30 08       	mov	r8,0
800085d4:	fa ea 00 00 	ld.d	r10,sp[0]
800085d8:	30 09       	mov	r9,0
800085da:	f0 0a 01 0a 	sub	r10,r8,r10
800085de:	f2 0b 01 4b 	sbc	r11,r9,r11
800085e2:	32 d8       	mov	r8,45
800085e4:	fa eb 00 00 	st.d	sp[0],r10
800085e8:	fb 68 06 bb 	st.b	sp[1723],r8
800085ec:	30 18       	mov	r8,1
800085ee:	e0 8f 06 fa 	bral	800093e2 <_vfprintf_r+0x153e>
800085f2:	50 a7       	stdsp	sp[0x28],r7
800085f4:	50 80       	stdsp	sp[0x20],r0
800085f6:	0c 97       	mov	r7,r6
800085f8:	04 94       	mov	r4,r2
800085fa:	06 96       	mov	r6,r3
800085fc:	02 92       	mov	r2,r1
800085fe:	40 93       	lddsp	r3,sp[0x24]
80008600:	10 90       	mov	r0,r8
80008602:	40 41       	lddsp	r1,sp[0x10]
80008604:	0e 99       	mov	r9,r7
80008606:	ed b5 00 03 	bld	r5,0x3
8000860a:	c4 11       	brne	8000868c <_vfprintf_r+0x7e8>
8000860c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008610:	40 3a       	lddsp	r10,sp[0xc]
80008612:	58 0a       	cp.w	r10,0
80008614:	c1 90       	breq	80008646 <_vfprintf_r+0x7a2>
80008616:	10 36       	cp.w	r6,r8
80008618:	c6 45       	brlt	800086e0 <_vfprintf_r+0x83c>
8000861a:	fa c8 f9 50 	sub	r8,sp,-1712
8000861e:	1a d8       	st.w	--sp,r8
80008620:	fa c8 fa b8 	sub	r8,sp,-1352
80008624:	1a d8       	st.w	--sp,r8
80008626:	fa c8 fb b4 	sub	r8,sp,-1100
8000862a:	0c 9b       	mov	r11,r6
8000862c:	1a d8       	st.w	--sp,r8
8000862e:	04 9a       	mov	r10,r2
80008630:	fa c8 f9 40 	sub	r8,sp,-1728
80008634:	fa c9 ff b4 	sub	r9,sp,-76
80008638:	08 9c       	mov	r12,r4
8000863a:	fe b0 fa 9d 	rcall	80007b74 <get_arg>
8000863e:	2f dd       	sub	sp,-12
80008640:	78 16       	ld.w	r6,r12[0x4]
80008642:	50 76       	stdsp	sp[0x1c],r6
80008644:	c4 88       	rjmp	800086d4 <_vfprintf_r+0x830>
80008646:	2f f7       	sub	r7,-1
80008648:	10 39       	cp.w	r9,r8
8000864a:	c0 c4       	brge	80008662 <_vfprintf_r+0x7be>
8000864c:	fa ce f9 44 	sub	lr,sp,-1724
80008650:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008654:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008658:	50 7c       	stdsp	sp[0x1c],r12
8000865a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000865e:	50 56       	stdsp	sp[0x14],r6
80008660:	c6 68       	rjmp	8000872c <_vfprintf_r+0x888>
80008662:	41 09       	lddsp	r9,sp[0x40]
80008664:	59 f8       	cp.w	r8,31
80008666:	e0 89 00 10 	brgt	80008686 <_vfprintf_r+0x7e2>
8000866a:	f2 ca ff f8 	sub	r10,r9,-8
8000866e:	72 1b       	ld.w	r11,r9[0x4]
80008670:	51 0a       	stdsp	sp[0x40],r10
80008672:	72 09       	ld.w	r9,r9[0x0]
80008674:	fa ca f9 44 	sub	r10,sp,-1724
80008678:	50 7b       	stdsp	sp[0x1c],r11
8000867a:	50 59       	stdsp	sp[0x14],r9
8000867c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008680:	40 5b       	lddsp	r11,sp[0x14]
80008682:	40 7a       	lddsp	r10,sp[0x1c]
80008684:	c4 78       	rjmp	80008712 <_vfprintf_r+0x86e>
80008686:	72 18       	ld.w	r8,r9[0x4]
80008688:	50 78       	stdsp	sp[0x1c],r8
8000868a:	c4 c8       	rjmp	80008722 <_vfprintf_r+0x87e>
8000868c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008690:	40 3e       	lddsp	lr,sp[0xc]
80008692:	58 0e       	cp.w	lr,0
80008694:	c2 30       	breq	800086da <_vfprintf_r+0x836>
80008696:	10 36       	cp.w	r6,r8
80008698:	c0 94       	brge	800086aa <_vfprintf_r+0x806>
8000869a:	fa cc f9 44 	sub	r12,sp,-1724
8000869e:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086a2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086a6:	50 7b       	stdsp	sp[0x1c],r11
800086a8:	cd 9b       	rjmp	8000865a <_vfprintf_r+0x7b6>
800086aa:	fa c8 f9 50 	sub	r8,sp,-1712
800086ae:	1a d8       	st.w	--sp,r8
800086b0:	fa c8 fa b8 	sub	r8,sp,-1352
800086b4:	04 9a       	mov	r10,r2
800086b6:	1a d8       	st.w	--sp,r8
800086b8:	fa c8 fb b4 	sub	r8,sp,-1100
800086bc:	0c 9b       	mov	r11,r6
800086be:	1a d8       	st.w	--sp,r8
800086c0:	08 9c       	mov	r12,r4
800086c2:	fa c8 f9 40 	sub	r8,sp,-1728
800086c6:	fa c9 ff b4 	sub	r9,sp,-76
800086ca:	fe b0 fa 55 	rcall	80007b74 <get_arg>
800086ce:	2f dd       	sub	sp,-12
800086d0:	78 1a       	ld.w	r10,r12[0x4]
800086d2:	50 7a       	stdsp	sp[0x1c],r10
800086d4:	78 0c       	ld.w	r12,r12[0x0]
800086d6:	50 5c       	stdsp	sp[0x14],r12
800086d8:	c2 a8       	rjmp	8000872c <_vfprintf_r+0x888>
800086da:	2f f7       	sub	r7,-1
800086dc:	10 39       	cp.w	r9,r8
800086de:	c0 94       	brge	800086f0 <_vfprintf_r+0x84c>
800086e0:	fa c9 f9 44 	sub	r9,sp,-1724
800086e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086e8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800086ec:	50 78       	stdsp	sp[0x1c],r8
800086ee:	cb 6b       	rjmp	8000865a <_vfprintf_r+0x7b6>
800086f0:	41 09       	lddsp	r9,sp[0x40]
800086f2:	59 f8       	cp.w	r8,31
800086f4:	e0 89 00 15 	brgt	8000871e <_vfprintf_r+0x87a>
800086f8:	f2 ca ff f8 	sub	r10,r9,-8
800086fc:	72 16       	ld.w	r6,r9[0x4]
800086fe:	72 09       	ld.w	r9,r9[0x0]
80008700:	51 0a       	stdsp	sp[0x40],r10
80008702:	50 59       	stdsp	sp[0x14],r9
80008704:	fa ce f9 44 	sub	lr,sp,-1724
80008708:	50 76       	stdsp	sp[0x1c],r6
8000870a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000870e:	40 5b       	lddsp	r11,sp[0x14]
80008710:	0c 9a       	mov	r10,r6
80008712:	f2 eb fd 88 	st.d	r9[-632],r10
80008716:	2f f8       	sub	r8,-1
80008718:	fb 48 06 b4 	st.w	sp[1716],r8
8000871c:	c0 88       	rjmp	8000872c <_vfprintf_r+0x888>
8000871e:	72 1c       	ld.w	r12,r9[0x4]
80008720:	50 7c       	stdsp	sp[0x1c],r12
80008722:	f2 c8 ff f8 	sub	r8,r9,-8
80008726:	51 08       	stdsp	sp[0x40],r8
80008728:	72 09       	ld.w	r9,r9[0x0]
8000872a:	50 59       	stdsp	sp[0x14],r9
8000872c:	40 5b       	lddsp	r11,sp[0x14]
8000872e:	40 7a       	lddsp	r10,sp[0x1c]
80008730:	e0 a0 19 54 	rcall	8000b9d8 <__isinfd>
80008734:	18 96       	mov	r6,r12
80008736:	c1 70       	breq	80008764 <_vfprintf_r+0x8c0>
80008738:	30 08       	mov	r8,0
8000873a:	30 09       	mov	r9,0
8000873c:	40 5b       	lddsp	r11,sp[0x14]
8000873e:	40 7a       	lddsp	r10,sp[0x1c]
80008740:	e0 a0 1d b4 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
80008744:	c0 40       	breq	8000874c <_vfprintf_r+0x8a8>
80008746:	32 d8       	mov	r8,45
80008748:	fb 68 06 bb 	st.b	sp[1723],r8
8000874c:	fe c8 aa e8 	sub	r8,pc,-21784
80008750:	fe c6 aa e8 	sub	r6,pc,-21784
80008754:	a7 d5       	cbr	r5,0x7
80008756:	e0 40 00 47 	cp.w	r0,71
8000875a:	f0 06 17 a0 	movle	r6,r8
8000875e:	30 32       	mov	r2,3
80008760:	e0 8f 06 ce 	bral	800094fc <_vfprintf_r+0x1658>
80008764:	40 5b       	lddsp	r11,sp[0x14]
80008766:	40 7a       	lddsp	r10,sp[0x1c]
80008768:	e0 a0 19 4d 	rcall	8000ba02 <__isnand>
8000876c:	c0 e0       	breq	80008788 <_vfprintf_r+0x8e4>
8000876e:	50 26       	stdsp	sp[0x8],r6
80008770:	fe c8 ab 04 	sub	r8,pc,-21756
80008774:	fe c6 ab 04 	sub	r6,pc,-21756
80008778:	a7 d5       	cbr	r5,0x7
8000877a:	e0 40 00 47 	cp.w	r0,71
8000877e:	f0 06 17 a0 	movle	r6,r8
80008782:	30 32       	mov	r2,3
80008784:	e0 8f 06 c2 	bral	80009508 <_vfprintf_r+0x1664>
80008788:	40 2a       	lddsp	r10,sp[0x8]
8000878a:	5b fa       	cp.w	r10,-1
8000878c:	c0 41       	brne	80008794 <_vfprintf_r+0x8f0>
8000878e:	30 69       	mov	r9,6
80008790:	50 29       	stdsp	sp[0x8],r9
80008792:	c1 18       	rjmp	800087b4 <_vfprintf_r+0x910>
80008794:	e0 40 00 47 	cp.w	r0,71
80008798:	5f 09       	sreq	r9
8000879a:	e0 40 00 67 	cp.w	r0,103
8000879e:	5f 08       	sreq	r8
800087a0:	f3 e8 10 08 	or	r8,r9,r8
800087a4:	f8 08 18 00 	cp.b	r8,r12
800087a8:	c0 60       	breq	800087b4 <_vfprintf_r+0x910>
800087aa:	40 28       	lddsp	r8,sp[0x8]
800087ac:	58 08       	cp.w	r8,0
800087ae:	f9 b8 00 01 	moveq	r8,1
800087b2:	50 28       	stdsp	sp[0x8],r8
800087b4:	40 78       	lddsp	r8,sp[0x1c]
800087b6:	40 59       	lddsp	r9,sp[0x14]
800087b8:	fa e9 06 94 	st.d	sp[1684],r8
800087bc:	a9 a5       	sbr	r5,0x8
800087be:	fa f8 06 94 	ld.w	r8,sp[1684]
800087c2:	58 08       	cp.w	r8,0
800087c4:	c0 65       	brlt	800087d0 <_vfprintf_r+0x92c>
800087c6:	40 5e       	lddsp	lr,sp[0x14]
800087c8:	30 0c       	mov	r12,0
800087ca:	50 6e       	stdsp	sp[0x18],lr
800087cc:	50 9c       	stdsp	sp[0x24],r12
800087ce:	c0 78       	rjmp	800087dc <_vfprintf_r+0x938>
800087d0:	40 5b       	lddsp	r11,sp[0x14]
800087d2:	32 da       	mov	r10,45
800087d4:	ee 1b 80 00 	eorh	r11,0x8000
800087d8:	50 9a       	stdsp	sp[0x24],r10
800087da:	50 6b       	stdsp	sp[0x18],r11
800087dc:	e0 40 00 46 	cp.w	r0,70
800087e0:	5f 09       	sreq	r9
800087e2:	e0 40 00 66 	cp.w	r0,102
800087e6:	5f 08       	sreq	r8
800087e8:	f3 e8 10 08 	or	r8,r9,r8
800087ec:	50 48       	stdsp	sp[0x10],r8
800087ee:	c0 40       	breq	800087f6 <_vfprintf_r+0x952>
800087f0:	40 22       	lddsp	r2,sp[0x8]
800087f2:	30 39       	mov	r9,3
800087f4:	c1 08       	rjmp	80008814 <_vfprintf_r+0x970>
800087f6:	e0 40 00 45 	cp.w	r0,69
800087fa:	5f 09       	sreq	r9
800087fc:	e0 40 00 65 	cp.w	r0,101
80008800:	5f 08       	sreq	r8
80008802:	40 22       	lddsp	r2,sp[0x8]
80008804:	10 49       	or	r9,r8
80008806:	2f f2       	sub	r2,-1
80008808:	40 46       	lddsp	r6,sp[0x10]
8000880a:	ec 09 18 00 	cp.b	r9,r6
8000880e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008812:	30 29       	mov	r9,2
80008814:	fa c8 f9 5c 	sub	r8,sp,-1700
80008818:	1a d8       	st.w	--sp,r8
8000881a:	fa c8 f9 54 	sub	r8,sp,-1708
8000881e:	1a d8       	st.w	--sp,r8
80008820:	fa c8 f9 4c 	sub	r8,sp,-1716
80008824:	08 9c       	mov	r12,r4
80008826:	1a d8       	st.w	--sp,r8
80008828:	04 98       	mov	r8,r2
8000882a:	40 9b       	lddsp	r11,sp[0x24]
8000882c:	40 aa       	lddsp	r10,sp[0x28]
8000882e:	e0 a0 0b c3 	rcall	80009fb4 <_dtoa_r>
80008832:	e0 40 00 47 	cp.w	r0,71
80008836:	5f 19       	srne	r9
80008838:	e0 40 00 67 	cp.w	r0,103
8000883c:	5f 18       	srne	r8
8000883e:	18 96       	mov	r6,r12
80008840:	2f dd       	sub	sp,-12
80008842:	f3 e8 00 08 	and	r8,r9,r8
80008846:	c0 41       	brne	8000884e <_vfprintf_r+0x9aa>
80008848:	ed b5 00 00 	bld	r5,0x0
8000884c:	c3 01       	brne	800088ac <_vfprintf_r+0xa08>
8000884e:	ec 02 00 0e 	add	lr,r6,r2
80008852:	50 3e       	stdsp	sp[0xc],lr
80008854:	40 4c       	lddsp	r12,sp[0x10]
80008856:	58 0c       	cp.w	r12,0
80008858:	c1 50       	breq	80008882 <_vfprintf_r+0x9de>
8000885a:	0d 89       	ld.ub	r9,r6[0x0]
8000885c:	33 08       	mov	r8,48
8000885e:	f0 09 18 00 	cp.b	r9,r8
80008862:	c0 b1       	brne	80008878 <_vfprintf_r+0x9d4>
80008864:	30 08       	mov	r8,0
80008866:	30 09       	mov	r9,0
80008868:	40 6b       	lddsp	r11,sp[0x18]
8000886a:	40 7a       	lddsp	r10,sp[0x1c]
8000886c:	e0 a0 1c d7 	rcall	8000c21a <__avr32_f64_cmp_eq>
80008870:	fb b2 00 01 	rsubeq	r2,1
80008874:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008878:	40 3b       	lddsp	r11,sp[0xc]
8000887a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000887e:	10 0b       	add	r11,r8
80008880:	50 3b       	stdsp	sp[0xc],r11
80008882:	40 6b       	lddsp	r11,sp[0x18]
80008884:	30 08       	mov	r8,0
80008886:	30 09       	mov	r9,0
80008888:	40 7a       	lddsp	r10,sp[0x1c]
8000888a:	e0 a0 1c c8 	rcall	8000c21a <__avr32_f64_cmp_eq>
8000888e:	c0 90       	breq	800088a0 <_vfprintf_r+0x9fc>
80008890:	40 3a       	lddsp	r10,sp[0xc]
80008892:	fb 4a 06 a4 	st.w	sp[1700],r10
80008896:	c0 58       	rjmp	800088a0 <_vfprintf_r+0x9fc>
80008898:	10 c9       	st.b	r8++,r9
8000889a:	fb 48 06 a4 	st.w	sp[1700],r8
8000889e:	c0 28       	rjmp	800088a2 <_vfprintf_r+0x9fe>
800088a0:	33 09       	mov	r9,48
800088a2:	fa f8 06 a4 	ld.w	r8,sp[1700]
800088a6:	40 3e       	lddsp	lr,sp[0xc]
800088a8:	1c 38       	cp.w	r8,lr
800088aa:	cf 73       	brcs	80008898 <_vfprintf_r+0x9f4>
800088ac:	e0 40 00 47 	cp.w	r0,71
800088b0:	5f 09       	sreq	r9
800088b2:	e0 40 00 67 	cp.w	r0,103
800088b6:	5f 08       	sreq	r8
800088b8:	f3 e8 10 08 	or	r8,r9,r8
800088bc:	fa f9 06 a4 	ld.w	r9,sp[1700]
800088c0:	0c 19       	sub	r9,r6
800088c2:	50 69       	stdsp	sp[0x18],r9
800088c4:	58 08       	cp.w	r8,0
800088c6:	c0 b0       	breq	800088dc <_vfprintf_r+0xa38>
800088c8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088cc:	5b d8       	cp.w	r8,-3
800088ce:	c0 55       	brlt	800088d8 <_vfprintf_r+0xa34>
800088d0:	40 2c       	lddsp	r12,sp[0x8]
800088d2:	18 38       	cp.w	r8,r12
800088d4:	e0 8a 00 6a 	brle	800089a8 <_vfprintf_r+0xb04>
800088d8:	20 20       	sub	r0,2
800088da:	c0 58       	rjmp	800088e4 <_vfprintf_r+0xa40>
800088dc:	e0 40 00 65 	cp.w	r0,101
800088e0:	e0 89 00 46 	brgt	8000896c <_vfprintf_r+0xac8>
800088e4:	fa fb 06 ac 	ld.w	r11,sp[1708]
800088e8:	fb 60 06 9c 	st.b	sp[1692],r0
800088ec:	20 1b       	sub	r11,1
800088ee:	fb 4b 06 ac 	st.w	sp[1708],r11
800088f2:	c0 47       	brpl	800088fa <_vfprintf_r+0xa56>
800088f4:	5c 3b       	neg	r11
800088f6:	32 d8       	mov	r8,45
800088f8:	c0 28       	rjmp	800088fc <_vfprintf_r+0xa58>
800088fa:	32 b8       	mov	r8,43
800088fc:	fb 68 06 9d 	st.b	sp[1693],r8
80008900:	58 9b       	cp.w	r11,9
80008902:	e0 8a 00 1d 	brle	8000893c <_vfprintf_r+0xa98>
80008906:	fa c9 fa 35 	sub	r9,sp,-1483
8000890a:	30 aa       	mov	r10,10
8000890c:	12 98       	mov	r8,r9
8000890e:	0e 9c       	mov	r12,r7
80008910:	0c 92       	mov	r2,r6
80008912:	f6 0a 0c 06 	divs	r6,r11,r10
80008916:	0e 9b       	mov	r11,r7
80008918:	2d 0b       	sub	r11,-48
8000891a:	10 fb       	st.b	--r8,r11
8000891c:	0c 9b       	mov	r11,r6
8000891e:	58 96       	cp.w	r6,9
80008920:	fe 99 ff f9 	brgt	80008912 <_vfprintf_r+0xa6e>
80008924:	2d 0b       	sub	r11,-48
80008926:	18 97       	mov	r7,r12
80008928:	04 96       	mov	r6,r2
8000892a:	10 fb       	st.b	--r8,r11
8000892c:	fa ca f9 62 	sub	r10,sp,-1694
80008930:	c0 38       	rjmp	80008936 <_vfprintf_r+0xa92>
80008932:	11 3b       	ld.ub	r11,r8++
80008934:	14 cb       	st.b	r10++,r11
80008936:	12 38       	cp.w	r8,r9
80008938:	cf d3       	brcs	80008932 <_vfprintf_r+0xa8e>
8000893a:	c0 98       	rjmp	8000894c <_vfprintf_r+0xaa8>
8000893c:	2d 0b       	sub	r11,-48
8000893e:	33 08       	mov	r8,48
80008940:	fb 6b 06 9f 	st.b	sp[1695],r11
80008944:	fb 68 06 9e 	st.b	sp[1694],r8
80008948:	fa ca f9 60 	sub	r10,sp,-1696
8000894c:	fa c8 f9 64 	sub	r8,sp,-1692
80008950:	f4 08 01 08 	sub	r8,r10,r8
80008954:	50 e8       	stdsp	sp[0x38],r8
80008956:	10 92       	mov	r2,r8
80008958:	40 6b       	lddsp	r11,sp[0x18]
8000895a:	16 02       	add	r2,r11
8000895c:	58 1b       	cp.w	r11,1
8000895e:	e0 89 00 05 	brgt	80008968 <_vfprintf_r+0xac4>
80008962:	ed b5 00 00 	bld	r5,0x0
80008966:	c3 51       	brne	800089d0 <_vfprintf_r+0xb2c>
80008968:	2f f2       	sub	r2,-1
8000896a:	c3 38       	rjmp	800089d0 <_vfprintf_r+0xb2c>
8000896c:	e0 40 00 66 	cp.w	r0,102
80008970:	c1 c1       	brne	800089a8 <_vfprintf_r+0xb04>
80008972:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008976:	58 02       	cp.w	r2,0
80008978:	e0 8a 00 0c 	brle	80008990 <_vfprintf_r+0xaec>
8000897c:	40 2a       	lddsp	r10,sp[0x8]
8000897e:	58 0a       	cp.w	r10,0
80008980:	c0 41       	brne	80008988 <_vfprintf_r+0xae4>
80008982:	ed b5 00 00 	bld	r5,0x0
80008986:	c2 51       	brne	800089d0 <_vfprintf_r+0xb2c>
80008988:	2f f2       	sub	r2,-1
8000898a:	40 29       	lddsp	r9,sp[0x8]
8000898c:	12 02       	add	r2,r9
8000898e:	c0 b8       	rjmp	800089a4 <_vfprintf_r+0xb00>
80008990:	40 28       	lddsp	r8,sp[0x8]
80008992:	58 08       	cp.w	r8,0
80008994:	c0 61       	brne	800089a0 <_vfprintf_r+0xafc>
80008996:	ed b5 00 00 	bld	r5,0x0
8000899a:	c0 30       	breq	800089a0 <_vfprintf_r+0xafc>
8000899c:	30 12       	mov	r2,1
8000899e:	c1 98       	rjmp	800089d0 <_vfprintf_r+0xb2c>
800089a0:	40 22       	lddsp	r2,sp[0x8]
800089a2:	2f e2       	sub	r2,-2
800089a4:	36 60       	mov	r0,102
800089a6:	c1 58       	rjmp	800089d0 <_vfprintf_r+0xb2c>
800089a8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089ac:	40 6e       	lddsp	lr,sp[0x18]
800089ae:	1c 32       	cp.w	r2,lr
800089b0:	c0 65       	brlt	800089bc <_vfprintf_r+0xb18>
800089b2:	ed b5 00 00 	bld	r5,0x0
800089b6:	f7 b2 00 ff 	subeq	r2,-1
800089ba:	c0 a8       	rjmp	800089ce <_vfprintf_r+0xb2a>
800089bc:	e4 08 11 02 	rsub	r8,r2,2
800089c0:	40 6c       	lddsp	r12,sp[0x18]
800089c2:	58 02       	cp.w	r2,0
800089c4:	f0 02 17 a0 	movle	r2,r8
800089c8:	f9 b2 09 01 	movgt	r2,1
800089cc:	18 02       	add	r2,r12
800089ce:	36 70       	mov	r0,103
800089d0:	40 9b       	lddsp	r11,sp[0x24]
800089d2:	58 0b       	cp.w	r11,0
800089d4:	e0 80 05 94 	breq	800094fc <_vfprintf_r+0x1658>
800089d8:	32 d8       	mov	r8,45
800089da:	fb 68 06 bb 	st.b	sp[1723],r8
800089de:	e0 8f 05 93 	bral	80009504 <_vfprintf_r+0x1660>
800089e2:	50 a7       	stdsp	sp[0x28],r7
800089e4:	04 94       	mov	r4,r2
800089e6:	0c 97       	mov	r7,r6
800089e8:	02 92       	mov	r2,r1
800089ea:	06 96       	mov	r6,r3
800089ec:	40 41       	lddsp	r1,sp[0x10]
800089ee:	40 93       	lddsp	r3,sp[0x24]
800089f0:	0e 99       	mov	r9,r7
800089f2:	ed b5 00 05 	bld	r5,0x5
800089f6:	c4 81       	brne	80008a86 <_vfprintf_r+0xbe2>
800089f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089fc:	40 3e       	lddsp	lr,sp[0xc]
800089fe:	58 0e       	cp.w	lr,0
80008a00:	c1 d0       	breq	80008a3a <_vfprintf_r+0xb96>
80008a02:	10 36       	cp.w	r6,r8
80008a04:	c0 64       	brge	80008a10 <_vfprintf_r+0xb6c>
80008a06:	fa cc f9 44 	sub	r12,sp,-1724
80008a0a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a0e:	c1 d8       	rjmp	80008a48 <_vfprintf_r+0xba4>
80008a10:	fa c8 f9 50 	sub	r8,sp,-1712
80008a14:	1a d8       	st.w	--sp,r8
80008a16:	fa c8 fa b8 	sub	r8,sp,-1352
80008a1a:	04 9a       	mov	r10,r2
80008a1c:	1a d8       	st.w	--sp,r8
80008a1e:	fa c8 fb b4 	sub	r8,sp,-1100
80008a22:	0c 9b       	mov	r11,r6
80008a24:	1a d8       	st.w	--sp,r8
80008a26:	08 9c       	mov	r12,r4
80008a28:	fa c8 f9 40 	sub	r8,sp,-1728
80008a2c:	fa c9 ff b4 	sub	r9,sp,-76
80008a30:	fe b0 f8 a2 	rcall	80007b74 <get_arg>
80008a34:	2f dd       	sub	sp,-12
80008a36:	78 0a       	ld.w	r10,r12[0x0]
80008a38:	c2 08       	rjmp	80008a78 <_vfprintf_r+0xbd4>
80008a3a:	2f f7       	sub	r7,-1
80008a3c:	10 39       	cp.w	r9,r8
80008a3e:	c0 84       	brge	80008a4e <_vfprintf_r+0xbaa>
80008a40:	fa cb f9 44 	sub	r11,sp,-1724
80008a44:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a48:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a4c:	c1 68       	rjmp	80008a78 <_vfprintf_r+0xbd4>
80008a4e:	41 09       	lddsp	r9,sp[0x40]
80008a50:	59 f8       	cp.w	r8,31
80008a52:	e0 89 00 10 	brgt	80008a72 <_vfprintf_r+0xbce>
80008a56:	f2 ca ff fc 	sub	r10,r9,-4
80008a5a:	51 0a       	stdsp	sp[0x40],r10
80008a5c:	fa c6 f9 44 	sub	r6,sp,-1724
80008a60:	72 0a       	ld.w	r10,r9[0x0]
80008a62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a66:	f3 4a fd 88 	st.w	r9[-632],r10
80008a6a:	2f f8       	sub	r8,-1
80008a6c:	fb 48 06 b4 	st.w	sp[1716],r8
80008a70:	c0 48       	rjmp	80008a78 <_vfprintf_r+0xbd4>
80008a72:	72 0a       	ld.w	r10,r9[0x0]
80008a74:	2f c9       	sub	r9,-4
80008a76:	51 09       	stdsp	sp[0x40],r9
80008a78:	40 be       	lddsp	lr,sp[0x2c]
80008a7a:	1c 98       	mov	r8,lr
80008a7c:	95 1e       	st.w	r10[0x4],lr
80008a7e:	bf 58       	asr	r8,0x1f
80008a80:	95 08       	st.w	r10[0x0],r8
80008a82:	fe 9f fa 9f 	bral	80007fc0 <_vfprintf_r+0x11c>
80008a86:	ed b5 00 04 	bld	r5,0x4
80008a8a:	c4 80       	breq	80008b1a <_vfprintf_r+0xc76>
80008a8c:	e2 15 00 40 	andl	r5,0x40,COH
80008a90:	c4 50       	breq	80008b1a <_vfprintf_r+0xc76>
80008a92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a96:	40 3c       	lddsp	r12,sp[0xc]
80008a98:	58 0c       	cp.w	r12,0
80008a9a:	c1 d0       	breq	80008ad4 <_vfprintf_r+0xc30>
80008a9c:	10 36       	cp.w	r6,r8
80008a9e:	c0 64       	brge	80008aaa <_vfprintf_r+0xc06>
80008aa0:	fa cb f9 44 	sub	r11,sp,-1724
80008aa4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aa8:	c1 d8       	rjmp	80008ae2 <_vfprintf_r+0xc3e>
80008aaa:	fa c8 f9 50 	sub	r8,sp,-1712
80008aae:	1a d8       	st.w	--sp,r8
80008ab0:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab4:	04 9a       	mov	r10,r2
80008ab6:	1a d8       	st.w	--sp,r8
80008ab8:	fa c8 fb b4 	sub	r8,sp,-1100
80008abc:	0c 9b       	mov	r11,r6
80008abe:	1a d8       	st.w	--sp,r8
80008ac0:	08 9c       	mov	r12,r4
80008ac2:	fa c8 f9 40 	sub	r8,sp,-1728
80008ac6:	fa c9 ff b4 	sub	r9,sp,-76
80008aca:	fe b0 f8 55 	rcall	80007b74 <get_arg>
80008ace:	2f dd       	sub	sp,-12
80008ad0:	78 0a       	ld.w	r10,r12[0x0]
80008ad2:	c2 08       	rjmp	80008b12 <_vfprintf_r+0xc6e>
80008ad4:	2f f7       	sub	r7,-1
80008ad6:	10 39       	cp.w	r9,r8
80008ad8:	c0 84       	brge	80008ae8 <_vfprintf_r+0xc44>
80008ada:	fa ca f9 44 	sub	r10,sp,-1724
80008ade:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ae2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ae6:	c1 68       	rjmp	80008b12 <_vfprintf_r+0xc6e>
80008ae8:	41 09       	lddsp	r9,sp[0x40]
80008aea:	59 f8       	cp.w	r8,31
80008aec:	e0 89 00 10 	brgt	80008b0c <_vfprintf_r+0xc68>
80008af0:	f2 ca ff fc 	sub	r10,r9,-4
80008af4:	51 0a       	stdsp	sp[0x40],r10
80008af6:	fa c6 f9 44 	sub	r6,sp,-1724
80008afa:	72 0a       	ld.w	r10,r9[0x0]
80008afc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b00:	f3 4a fd 88 	st.w	r9[-632],r10
80008b04:	2f f8       	sub	r8,-1
80008b06:	fb 48 06 b4 	st.w	sp[1716],r8
80008b0a:	c0 48       	rjmp	80008b12 <_vfprintf_r+0xc6e>
80008b0c:	72 0a       	ld.w	r10,r9[0x0]
80008b0e:	2f c9       	sub	r9,-4
80008b10:	51 09       	stdsp	sp[0x40],r9
80008b12:	40 be       	lddsp	lr,sp[0x2c]
80008b14:	b4 0e       	st.h	r10[0x0],lr
80008b16:	fe 9f fa 55 	bral	80007fc0 <_vfprintf_r+0x11c>
80008b1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b1e:	40 3c       	lddsp	r12,sp[0xc]
80008b20:	58 0c       	cp.w	r12,0
80008b22:	c1 d0       	breq	80008b5c <_vfprintf_r+0xcb8>
80008b24:	10 36       	cp.w	r6,r8
80008b26:	c0 64       	brge	80008b32 <_vfprintf_r+0xc8e>
80008b28:	fa cb f9 44 	sub	r11,sp,-1724
80008b2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b30:	c1 d8       	rjmp	80008b6a <_vfprintf_r+0xcc6>
80008b32:	fa c8 f9 50 	sub	r8,sp,-1712
80008b36:	1a d8       	st.w	--sp,r8
80008b38:	fa c8 fa b8 	sub	r8,sp,-1352
80008b3c:	04 9a       	mov	r10,r2
80008b3e:	1a d8       	st.w	--sp,r8
80008b40:	fa c8 fb b4 	sub	r8,sp,-1100
80008b44:	0c 9b       	mov	r11,r6
80008b46:	1a d8       	st.w	--sp,r8
80008b48:	08 9c       	mov	r12,r4
80008b4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b4e:	fa c9 ff b4 	sub	r9,sp,-76
80008b52:	fe b0 f8 11 	rcall	80007b74 <get_arg>
80008b56:	2f dd       	sub	sp,-12
80008b58:	78 0a       	ld.w	r10,r12[0x0]
80008b5a:	c2 08       	rjmp	80008b9a <_vfprintf_r+0xcf6>
80008b5c:	2f f7       	sub	r7,-1
80008b5e:	10 39       	cp.w	r9,r8
80008b60:	c0 84       	brge	80008b70 <_vfprintf_r+0xccc>
80008b62:	fa ca f9 44 	sub	r10,sp,-1724
80008b66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b6a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b6e:	c1 68       	rjmp	80008b9a <_vfprintf_r+0xcf6>
80008b70:	41 09       	lddsp	r9,sp[0x40]
80008b72:	59 f8       	cp.w	r8,31
80008b74:	e0 89 00 10 	brgt	80008b94 <_vfprintf_r+0xcf0>
80008b78:	f2 ca ff fc 	sub	r10,r9,-4
80008b7c:	51 0a       	stdsp	sp[0x40],r10
80008b7e:	fa c6 f9 44 	sub	r6,sp,-1724
80008b82:	72 0a       	ld.w	r10,r9[0x0]
80008b84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b88:	f3 4a fd 88 	st.w	r9[-632],r10
80008b8c:	2f f8       	sub	r8,-1
80008b8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b92:	c0 48       	rjmp	80008b9a <_vfprintf_r+0xcf6>
80008b94:	72 0a       	ld.w	r10,r9[0x0]
80008b96:	2f c9       	sub	r9,-4
80008b98:	51 09       	stdsp	sp[0x40],r9
80008b9a:	40 be       	lddsp	lr,sp[0x2c]
80008b9c:	95 0e       	st.w	r10[0x0],lr
80008b9e:	fe 9f fa 11 	bral	80007fc0 <_vfprintf_r+0x11c>
80008ba2:	50 a7       	stdsp	sp[0x28],r7
80008ba4:	50 80       	stdsp	sp[0x20],r0
80008ba6:	0c 97       	mov	r7,r6
80008ba8:	04 94       	mov	r4,r2
80008baa:	06 96       	mov	r6,r3
80008bac:	02 92       	mov	r2,r1
80008bae:	40 93       	lddsp	r3,sp[0x24]
80008bb0:	10 90       	mov	r0,r8
80008bb2:	40 41       	lddsp	r1,sp[0x10]
80008bb4:	a5 a5       	sbr	r5,0x4
80008bb6:	c0 a8       	rjmp	80008bca <_vfprintf_r+0xd26>
80008bb8:	50 a7       	stdsp	sp[0x28],r7
80008bba:	50 80       	stdsp	sp[0x20],r0
80008bbc:	0c 97       	mov	r7,r6
80008bbe:	04 94       	mov	r4,r2
80008bc0:	06 96       	mov	r6,r3
80008bc2:	02 92       	mov	r2,r1
80008bc4:	40 93       	lddsp	r3,sp[0x24]
80008bc6:	10 90       	mov	r0,r8
80008bc8:	40 41       	lddsp	r1,sp[0x10]
80008bca:	ed b5 00 05 	bld	r5,0x5
80008bce:	c5 d1       	brne	80008c88 <_vfprintf_r+0xde4>
80008bd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bd4:	40 3c       	lddsp	r12,sp[0xc]
80008bd6:	58 0c       	cp.w	r12,0
80008bd8:	c2 60       	breq	80008c24 <_vfprintf_r+0xd80>
80008bda:	10 36       	cp.w	r6,r8
80008bdc:	c0 a4       	brge	80008bf0 <_vfprintf_r+0xd4c>
80008bde:	fa cb f9 44 	sub	r11,sp,-1724
80008be2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008be6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008bea:	fa e9 00 00 	st.d	sp[0],r8
80008bee:	c1 88       	rjmp	80008c1e <_vfprintf_r+0xd7a>
80008bf0:	fa c8 f9 50 	sub	r8,sp,-1712
80008bf4:	1a d8       	st.w	--sp,r8
80008bf6:	fa c8 fa b8 	sub	r8,sp,-1352
80008bfa:	04 9a       	mov	r10,r2
80008bfc:	1a d8       	st.w	--sp,r8
80008bfe:	0c 9b       	mov	r11,r6
80008c00:	fa c8 fb b4 	sub	r8,sp,-1100
80008c04:	08 9c       	mov	r12,r4
80008c06:	1a d8       	st.w	--sp,r8
80008c08:	fa c8 f9 40 	sub	r8,sp,-1728
80008c0c:	fa c9 ff b4 	sub	r9,sp,-76
80008c10:	fe b0 f7 b2 	rcall	80007b74 <get_arg>
80008c14:	2f dd       	sub	sp,-12
80008c16:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c1a:	fa eb 00 00 	st.d	sp[0],r10
80008c1e:	30 08       	mov	r8,0
80008c20:	e0 8f 03 de 	bral	800093dc <_vfprintf_r+0x1538>
80008c24:	ee ca ff ff 	sub	r10,r7,-1
80008c28:	10 37       	cp.w	r7,r8
80008c2a:	c0 b4       	brge	80008c40 <_vfprintf_r+0xd9c>
80008c2c:	fa c9 f9 44 	sub	r9,sp,-1724
80008c30:	14 97       	mov	r7,r10
80008c32:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c36:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c3a:	fa eb 00 00 	st.d	sp[0],r10
80008c3e:	c1 88       	rjmp	80008c6e <_vfprintf_r+0xdca>
80008c40:	41 09       	lddsp	r9,sp[0x40]
80008c42:	59 f8       	cp.w	r8,31
80008c44:	e0 89 00 18 	brgt	80008c74 <_vfprintf_r+0xdd0>
80008c48:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c4c:	f2 cb ff f8 	sub	r11,r9,-8
80008c50:	fa e7 00 00 	st.d	sp[0],r6
80008c54:	51 0b       	stdsp	sp[0x40],r11
80008c56:	fa c6 f9 44 	sub	r6,sp,-1724
80008c5a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c5e:	fa e6 00 00 	ld.d	r6,sp[0]
80008c62:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c66:	2f f8       	sub	r8,-1
80008c68:	14 97       	mov	r7,r10
80008c6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c6e:	40 38       	lddsp	r8,sp[0xc]
80008c70:	e0 8f 03 b6 	bral	800093dc <_vfprintf_r+0x1538>
80008c74:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c78:	40 38       	lddsp	r8,sp[0xc]
80008c7a:	fa e7 00 00 	st.d	sp[0],r6
80008c7e:	2f 89       	sub	r9,-8
80008c80:	14 97       	mov	r7,r10
80008c82:	51 09       	stdsp	sp[0x40],r9
80008c84:	e0 8f 03 ac 	bral	800093dc <_vfprintf_r+0x1538>
80008c88:	ed b5 00 04 	bld	r5,0x4
80008c8c:	c1 61       	brne	80008cb8 <_vfprintf_r+0xe14>
80008c8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c92:	40 3e       	lddsp	lr,sp[0xc]
80008c94:	58 0e       	cp.w	lr,0
80008c96:	c0 80       	breq	80008ca6 <_vfprintf_r+0xe02>
80008c98:	10 36       	cp.w	r6,r8
80008c9a:	c6 74       	brge	80008d68 <_vfprintf_r+0xec4>
80008c9c:	fa cc f9 44 	sub	r12,sp,-1724
80008ca0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ca4:	c8 08       	rjmp	80008da4 <_vfprintf_r+0xf00>
80008ca6:	ee ca ff ff 	sub	r10,r7,-1
80008caa:	10 37       	cp.w	r7,r8
80008cac:	c7 f4       	brge	80008daa <_vfprintf_r+0xf06>
80008cae:	fa cb f9 44 	sub	r11,sp,-1724
80008cb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cb6:	c7 68       	rjmp	80008da2 <_vfprintf_r+0xefe>
80008cb8:	ed b5 00 06 	bld	r5,0x6
80008cbc:	c4 a1       	brne	80008d50 <_vfprintf_r+0xeac>
80008cbe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cc2:	40 3c       	lddsp	r12,sp[0xc]
80008cc4:	58 0c       	cp.w	r12,0
80008cc6:	c1 d0       	breq	80008d00 <_vfprintf_r+0xe5c>
80008cc8:	10 36       	cp.w	r6,r8
80008cca:	c0 64       	brge	80008cd6 <_vfprintf_r+0xe32>
80008ccc:	fa cb f9 44 	sub	r11,sp,-1724
80008cd0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cd4:	c1 f8       	rjmp	80008d12 <_vfprintf_r+0xe6e>
80008cd6:	fa c8 f9 50 	sub	r8,sp,-1712
80008cda:	1a d8       	st.w	--sp,r8
80008cdc:	fa c8 fa b8 	sub	r8,sp,-1352
80008ce0:	1a d8       	st.w	--sp,r8
80008ce2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ce6:	1a d8       	st.w	--sp,r8
80008ce8:	fa c8 f9 40 	sub	r8,sp,-1728
80008cec:	fa c9 ff b4 	sub	r9,sp,-76
80008cf0:	04 9a       	mov	r10,r2
80008cf2:	0c 9b       	mov	r11,r6
80008cf4:	08 9c       	mov	r12,r4
80008cf6:	fe b0 f7 3f 	rcall	80007b74 <get_arg>
80008cfa:	2f dd       	sub	sp,-12
80008cfc:	98 18       	ld.sh	r8,r12[0x2]
80008cfe:	c2 68       	rjmp	80008d4a <_vfprintf_r+0xea6>
80008d00:	ee ca ff ff 	sub	r10,r7,-1
80008d04:	10 37       	cp.w	r7,r8
80008d06:	c0 94       	brge	80008d18 <_vfprintf_r+0xe74>
80008d08:	fa c9 f9 44 	sub	r9,sp,-1724
80008d0c:	14 97       	mov	r7,r10
80008d0e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d12:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d16:	c1 a8       	rjmp	80008d4a <_vfprintf_r+0xea6>
80008d18:	41 09       	lddsp	r9,sp[0x40]
80008d1a:	59 f8       	cp.w	r8,31
80008d1c:	e0 89 00 13 	brgt	80008d42 <_vfprintf_r+0xe9e>
80008d20:	f2 cb ff fc 	sub	r11,r9,-4
80008d24:	51 0b       	stdsp	sp[0x40],r11
80008d26:	72 09       	ld.w	r9,r9[0x0]
80008d28:	fa c6 f9 44 	sub	r6,sp,-1724
80008d2c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d30:	2f f8       	sub	r8,-1
80008d32:	f7 49 fd 88 	st.w	r11[-632],r9
80008d36:	fb 48 06 b4 	st.w	sp[1716],r8
80008d3a:	14 97       	mov	r7,r10
80008d3c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d40:	c0 58       	rjmp	80008d4a <_vfprintf_r+0xea6>
80008d42:	92 18       	ld.sh	r8,r9[0x2]
80008d44:	14 97       	mov	r7,r10
80008d46:	2f c9       	sub	r9,-4
80008d48:	51 09       	stdsp	sp[0x40],r9
80008d4a:	5c 78       	castu.h	r8
80008d4c:	50 18       	stdsp	sp[0x4],r8
80008d4e:	c4 68       	rjmp	80008dda <_vfprintf_r+0xf36>
80008d50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d54:	40 3c       	lddsp	r12,sp[0xc]
80008d56:	58 0c       	cp.w	r12,0
80008d58:	c1 d0       	breq	80008d92 <_vfprintf_r+0xeee>
80008d5a:	10 36       	cp.w	r6,r8
80008d5c:	c0 64       	brge	80008d68 <_vfprintf_r+0xec4>
80008d5e:	fa cb f9 44 	sub	r11,sp,-1724
80008d62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d66:	c1 f8       	rjmp	80008da4 <_vfprintf_r+0xf00>
80008d68:	fa c8 f9 50 	sub	r8,sp,-1712
80008d6c:	1a d8       	st.w	--sp,r8
80008d6e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d72:	0c 9b       	mov	r11,r6
80008d74:	1a d8       	st.w	--sp,r8
80008d76:	fa c8 fb b4 	sub	r8,sp,-1100
80008d7a:	04 9a       	mov	r10,r2
80008d7c:	1a d8       	st.w	--sp,r8
80008d7e:	08 9c       	mov	r12,r4
80008d80:	fa c8 f9 40 	sub	r8,sp,-1728
80008d84:	fa c9 ff b4 	sub	r9,sp,-76
80008d88:	fe b0 f6 f6 	rcall	80007b74 <get_arg>
80008d8c:	2f dd       	sub	sp,-12
80008d8e:	78 0b       	ld.w	r11,r12[0x0]
80008d90:	c2 48       	rjmp	80008dd8 <_vfprintf_r+0xf34>
80008d92:	ee ca ff ff 	sub	r10,r7,-1
80008d96:	10 37       	cp.w	r7,r8
80008d98:	c0 94       	brge	80008daa <_vfprintf_r+0xf06>
80008d9a:	fa c9 f9 44 	sub	r9,sp,-1724
80008d9e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008da2:	14 97       	mov	r7,r10
80008da4:	ec fb fd 88 	ld.w	r11,r6[-632]
80008da8:	c1 88       	rjmp	80008dd8 <_vfprintf_r+0xf34>
80008daa:	41 09       	lddsp	r9,sp[0x40]
80008dac:	59 f8       	cp.w	r8,31
80008dae:	e0 89 00 11 	brgt	80008dd0 <_vfprintf_r+0xf2c>
80008db2:	f2 cb ff fc 	sub	r11,r9,-4
80008db6:	51 0b       	stdsp	sp[0x40],r11
80008db8:	fa c6 f9 44 	sub	r6,sp,-1724
80008dbc:	72 0b       	ld.w	r11,r9[0x0]
80008dbe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dc2:	f3 4b fd 88 	st.w	r9[-632],r11
80008dc6:	2f f8       	sub	r8,-1
80008dc8:	14 97       	mov	r7,r10
80008dca:	fb 48 06 b4 	st.w	sp[1716],r8
80008dce:	c0 58       	rjmp	80008dd8 <_vfprintf_r+0xf34>
80008dd0:	72 0b       	ld.w	r11,r9[0x0]
80008dd2:	14 97       	mov	r7,r10
80008dd4:	2f c9       	sub	r9,-4
80008dd6:	51 09       	stdsp	sp[0x40],r9
80008dd8:	50 1b       	stdsp	sp[0x4],r11
80008dda:	30 0e       	mov	lr,0
80008ddc:	50 0e       	stdsp	sp[0x0],lr
80008dde:	1c 98       	mov	r8,lr
80008de0:	e0 8f 02 fe 	bral	800093dc <_vfprintf_r+0x1538>
80008de4:	50 a7       	stdsp	sp[0x28],r7
80008de6:	50 80       	stdsp	sp[0x20],r0
80008de8:	0c 97       	mov	r7,r6
80008dea:	04 94       	mov	r4,r2
80008dec:	06 96       	mov	r6,r3
80008dee:	02 92       	mov	r2,r1
80008df0:	40 93       	lddsp	r3,sp[0x24]
80008df2:	40 41       	lddsp	r1,sp[0x10]
80008df4:	0e 99       	mov	r9,r7
80008df6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dfa:	40 3c       	lddsp	r12,sp[0xc]
80008dfc:	58 0c       	cp.w	r12,0
80008dfe:	c1 d0       	breq	80008e38 <_vfprintf_r+0xf94>
80008e00:	10 36       	cp.w	r6,r8
80008e02:	c0 64       	brge	80008e0e <_vfprintf_r+0xf6a>
80008e04:	fa cb f9 44 	sub	r11,sp,-1724
80008e08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e0c:	c1 d8       	rjmp	80008e46 <_vfprintf_r+0xfa2>
80008e0e:	fa c8 f9 50 	sub	r8,sp,-1712
80008e12:	1a d8       	st.w	--sp,r8
80008e14:	fa c8 fa b8 	sub	r8,sp,-1352
80008e18:	1a d8       	st.w	--sp,r8
80008e1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008e1e:	1a d8       	st.w	--sp,r8
80008e20:	fa c9 ff b4 	sub	r9,sp,-76
80008e24:	fa c8 f9 40 	sub	r8,sp,-1728
80008e28:	04 9a       	mov	r10,r2
80008e2a:	0c 9b       	mov	r11,r6
80008e2c:	08 9c       	mov	r12,r4
80008e2e:	fe b0 f6 a3 	rcall	80007b74 <get_arg>
80008e32:	2f dd       	sub	sp,-12
80008e34:	78 09       	ld.w	r9,r12[0x0]
80008e36:	c2 18       	rjmp	80008e78 <_vfprintf_r+0xfd4>
80008e38:	2f f7       	sub	r7,-1
80008e3a:	10 39       	cp.w	r9,r8
80008e3c:	c0 84       	brge	80008e4c <_vfprintf_r+0xfa8>
80008e3e:	fa ca f9 44 	sub	r10,sp,-1724
80008e42:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e46:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008e4a:	c1 78       	rjmp	80008e78 <_vfprintf_r+0xfd4>
80008e4c:	41 09       	lddsp	r9,sp[0x40]
80008e4e:	59 f8       	cp.w	r8,31
80008e50:	e0 89 00 10 	brgt	80008e70 <_vfprintf_r+0xfcc>
80008e54:	f2 ca ff fc 	sub	r10,r9,-4
80008e58:	51 0a       	stdsp	sp[0x40],r10
80008e5a:	fa c6 f9 44 	sub	r6,sp,-1724
80008e5e:	72 09       	ld.w	r9,r9[0x0]
80008e60:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e64:	f5 49 fd 88 	st.w	r10[-632],r9
80008e68:	2f f8       	sub	r8,-1
80008e6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e6e:	c0 58       	rjmp	80008e78 <_vfprintf_r+0xfd4>
80008e70:	f2 c8 ff fc 	sub	r8,r9,-4
80008e74:	51 08       	stdsp	sp[0x40],r8
80008e76:	72 09       	ld.w	r9,r9[0x0]
80008e78:	33 08       	mov	r8,48
80008e7a:	fb 68 06 b8 	st.b	sp[1720],r8
80008e7e:	37 88       	mov	r8,120
80008e80:	30 0e       	mov	lr,0
80008e82:	fb 68 06 b9 	st.b	sp[1721],r8
80008e86:	fe cc b2 12 	sub	r12,pc,-19950
80008e8a:	50 19       	stdsp	sp[0x4],r9
80008e8c:	a1 b5       	sbr	r5,0x1
80008e8e:	50 0e       	stdsp	sp[0x0],lr
80008e90:	50 dc       	stdsp	sp[0x34],r12
80008e92:	30 28       	mov	r8,2
80008e94:	37 80       	mov	r0,120
80008e96:	e0 8f 02 a3 	bral	800093dc <_vfprintf_r+0x1538>
80008e9a:	50 a7       	stdsp	sp[0x28],r7
80008e9c:	50 80       	stdsp	sp[0x20],r0
80008e9e:	10 90       	mov	r0,r8
80008ea0:	30 08       	mov	r8,0
80008ea2:	fb 68 06 bb 	st.b	sp[1723],r8
80008ea6:	0c 97       	mov	r7,r6
80008ea8:	04 94       	mov	r4,r2
80008eaa:	06 96       	mov	r6,r3
80008eac:	02 92       	mov	r2,r1
80008eae:	40 93       	lddsp	r3,sp[0x24]
80008eb0:	40 41       	lddsp	r1,sp[0x10]
80008eb2:	0e 99       	mov	r9,r7
80008eb4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eb8:	40 3b       	lddsp	r11,sp[0xc]
80008eba:	58 0b       	cp.w	r11,0
80008ebc:	c1 d0       	breq	80008ef6 <_vfprintf_r+0x1052>
80008ebe:	10 36       	cp.w	r6,r8
80008ec0:	c0 64       	brge	80008ecc <_vfprintf_r+0x1028>
80008ec2:	fa ca f9 44 	sub	r10,sp,-1724
80008ec6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008eca:	c1 d8       	rjmp	80008f04 <_vfprintf_r+0x1060>
80008ecc:	fa c8 f9 50 	sub	r8,sp,-1712
80008ed0:	1a d8       	st.w	--sp,r8
80008ed2:	fa c8 fa b8 	sub	r8,sp,-1352
80008ed6:	1a d8       	st.w	--sp,r8
80008ed8:	fa c8 fb b4 	sub	r8,sp,-1100
80008edc:	0c 9b       	mov	r11,r6
80008ede:	1a d8       	st.w	--sp,r8
80008ee0:	04 9a       	mov	r10,r2
80008ee2:	fa c8 f9 40 	sub	r8,sp,-1728
80008ee6:	fa c9 ff b4 	sub	r9,sp,-76
80008eea:	08 9c       	mov	r12,r4
80008eec:	fe b0 f6 44 	rcall	80007b74 <get_arg>
80008ef0:	2f dd       	sub	sp,-12
80008ef2:	78 06       	ld.w	r6,r12[0x0]
80008ef4:	c2 08       	rjmp	80008f34 <_vfprintf_r+0x1090>
80008ef6:	2f f7       	sub	r7,-1
80008ef8:	10 39       	cp.w	r9,r8
80008efa:	c0 84       	brge	80008f0a <_vfprintf_r+0x1066>
80008efc:	fa c9 f9 44 	sub	r9,sp,-1724
80008f00:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f04:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008f08:	c1 68       	rjmp	80008f34 <_vfprintf_r+0x1090>
80008f0a:	41 09       	lddsp	r9,sp[0x40]
80008f0c:	59 f8       	cp.w	r8,31
80008f0e:	e0 89 00 10 	brgt	80008f2e <_vfprintf_r+0x108a>
80008f12:	f2 ca ff fc 	sub	r10,r9,-4
80008f16:	51 0a       	stdsp	sp[0x40],r10
80008f18:	72 06       	ld.w	r6,r9[0x0]
80008f1a:	fa ce f9 44 	sub	lr,sp,-1724
80008f1e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008f22:	f3 46 fd 88 	st.w	r9[-632],r6
80008f26:	2f f8       	sub	r8,-1
80008f28:	fb 48 06 b4 	st.w	sp[1716],r8
80008f2c:	c0 48       	rjmp	80008f34 <_vfprintf_r+0x1090>
80008f2e:	72 06       	ld.w	r6,r9[0x0]
80008f30:	2f c9       	sub	r9,-4
80008f32:	51 09       	stdsp	sp[0x40],r9
80008f34:	40 2c       	lddsp	r12,sp[0x8]
80008f36:	58 0c       	cp.w	r12,0
80008f38:	c1 05       	brlt	80008f58 <_vfprintf_r+0x10b4>
80008f3a:	18 9a       	mov	r10,r12
80008f3c:	30 0b       	mov	r11,0
80008f3e:	0c 9c       	mov	r12,r6
80008f40:	e0 a0 12 38 	rcall	8000b3b0 <memchr>
80008f44:	e0 80 02 df 	breq	80009502 <_vfprintf_r+0x165e>
80008f48:	f8 06 01 02 	sub	r2,r12,r6
80008f4c:	40 2b       	lddsp	r11,sp[0x8]
80008f4e:	16 32       	cp.w	r2,r11
80008f50:	e0 89 02 d9 	brgt	80009502 <_vfprintf_r+0x165e>
80008f54:	e0 8f 02 d4 	bral	800094fc <_vfprintf_r+0x1658>
80008f58:	30 0a       	mov	r10,0
80008f5a:	0c 9c       	mov	r12,r6
80008f5c:	50 2a       	stdsp	sp[0x8],r10
80008f5e:	e0 a0 15 99 	rcall	8000ba90 <strlen>
80008f62:	18 92       	mov	r2,r12
80008f64:	e0 8f 02 d2 	bral	80009508 <_vfprintf_r+0x1664>
80008f68:	50 a7       	stdsp	sp[0x28],r7
80008f6a:	50 80       	stdsp	sp[0x20],r0
80008f6c:	0c 97       	mov	r7,r6
80008f6e:	04 94       	mov	r4,r2
80008f70:	06 96       	mov	r6,r3
80008f72:	02 92       	mov	r2,r1
80008f74:	40 93       	lddsp	r3,sp[0x24]
80008f76:	10 90       	mov	r0,r8
80008f78:	40 41       	lddsp	r1,sp[0x10]
80008f7a:	a5 a5       	sbr	r5,0x4
80008f7c:	c0 a8       	rjmp	80008f90 <_vfprintf_r+0x10ec>
80008f7e:	50 a7       	stdsp	sp[0x28],r7
80008f80:	50 80       	stdsp	sp[0x20],r0
80008f82:	0c 97       	mov	r7,r6
80008f84:	04 94       	mov	r4,r2
80008f86:	06 96       	mov	r6,r3
80008f88:	02 92       	mov	r2,r1
80008f8a:	40 93       	lddsp	r3,sp[0x24]
80008f8c:	10 90       	mov	r0,r8
80008f8e:	40 41       	lddsp	r1,sp[0x10]
80008f90:	ed b5 00 05 	bld	r5,0x5
80008f94:	c5 61       	brne	80009040 <_vfprintf_r+0x119c>
80008f96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f9a:	40 39       	lddsp	r9,sp[0xc]
80008f9c:	58 09       	cp.w	r9,0
80008f9e:	c2 10       	breq	80008fe0 <_vfprintf_r+0x113c>
80008fa0:	10 36       	cp.w	r6,r8
80008fa2:	c0 74       	brge	80008fb0 <_vfprintf_r+0x110c>
80008fa4:	fa c8 f9 44 	sub	r8,sp,-1724
80008fa8:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008fac:	c2 38       	rjmp	80008ff2 <_vfprintf_r+0x114e>
80008fae:	d7 03       	nop
80008fb0:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb4:	1a d8       	st.w	--sp,r8
80008fb6:	fa c8 fa b8 	sub	r8,sp,-1352
80008fba:	1a d8       	st.w	--sp,r8
80008fbc:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc0:	1a d8       	st.w	--sp,r8
80008fc2:	fa c8 f9 40 	sub	r8,sp,-1728
80008fc6:	fa c9 ff b4 	sub	r9,sp,-76
80008fca:	04 9a       	mov	r10,r2
80008fcc:	0c 9b       	mov	r11,r6
80008fce:	08 9c       	mov	r12,r4
80008fd0:	fe b0 f5 d2 	rcall	80007b74 <get_arg>
80008fd4:	2f dd       	sub	sp,-12
80008fd6:	f8 e8 00 00 	ld.d	r8,r12[0]
80008fda:	fa e9 00 00 	st.d	sp[0],r8
80008fde:	c2 e8       	rjmp	8000903a <_vfprintf_r+0x1196>
80008fe0:	ee ca ff ff 	sub	r10,r7,-1
80008fe4:	10 37       	cp.w	r7,r8
80008fe6:	c0 b4       	brge	80008ffc <_vfprintf_r+0x1158>
80008fe8:	fa c8 f9 44 	sub	r8,sp,-1724
80008fec:	14 97       	mov	r7,r10
80008fee:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008ff2:	ec ea fd 88 	ld.d	r10,r6[-632]
80008ff6:	fa eb 00 00 	st.d	sp[0],r10
80008ffa:	c2 08       	rjmp	8000903a <_vfprintf_r+0x1196>
80008ffc:	41 09       	lddsp	r9,sp[0x40]
80008ffe:	59 f8       	cp.w	r8,31
80009000:	e0 89 00 16 	brgt	8000902c <_vfprintf_r+0x1188>
80009004:	f2 e6 00 00 	ld.d	r6,r9[0]
80009008:	f2 cb ff f8 	sub	r11,r9,-8
8000900c:	fa e7 00 00 	st.d	sp[0],r6
80009010:	51 0b       	stdsp	sp[0x40],r11
80009012:	fa c6 f9 44 	sub	r6,sp,-1724
80009016:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000901a:	fa e6 00 00 	ld.d	r6,sp[0]
8000901e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009022:	2f f8       	sub	r8,-1
80009024:	14 97       	mov	r7,r10
80009026:	fb 48 06 b4 	st.w	sp[1716],r8
8000902a:	c0 88       	rjmp	8000903a <_vfprintf_r+0x1196>
8000902c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009030:	2f 89       	sub	r9,-8
80009032:	fa e7 00 00 	st.d	sp[0],r6
80009036:	51 09       	stdsp	sp[0x40],r9
80009038:	14 97       	mov	r7,r10
8000903a:	30 18       	mov	r8,1
8000903c:	e0 8f 01 d0 	bral	800093dc <_vfprintf_r+0x1538>
80009040:	ed b5 00 04 	bld	r5,0x4
80009044:	c1 61       	brne	80009070 <_vfprintf_r+0x11cc>
80009046:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000904a:	40 3e       	lddsp	lr,sp[0xc]
8000904c:	58 0e       	cp.w	lr,0
8000904e:	c0 80       	breq	8000905e <_vfprintf_r+0x11ba>
80009050:	10 36       	cp.w	r6,r8
80009052:	c6 74       	brge	80009120 <_vfprintf_r+0x127c>
80009054:	fa cc f9 44 	sub	r12,sp,-1724
80009058:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000905c:	c8 08       	rjmp	8000915c <_vfprintf_r+0x12b8>
8000905e:	ee ca ff ff 	sub	r10,r7,-1
80009062:	10 37       	cp.w	r7,r8
80009064:	c7 f4       	brge	80009162 <_vfprintf_r+0x12be>
80009066:	fa cb f9 44 	sub	r11,sp,-1724
8000906a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000906e:	c7 68       	rjmp	8000915a <_vfprintf_r+0x12b6>
80009070:	ed b5 00 06 	bld	r5,0x6
80009074:	c4 a1       	brne	80009108 <_vfprintf_r+0x1264>
80009076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000907a:	40 3c       	lddsp	r12,sp[0xc]
8000907c:	58 0c       	cp.w	r12,0
8000907e:	c1 d0       	breq	800090b8 <_vfprintf_r+0x1214>
80009080:	10 36       	cp.w	r6,r8
80009082:	c0 64       	brge	8000908e <_vfprintf_r+0x11ea>
80009084:	fa cb f9 44 	sub	r11,sp,-1724
80009088:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000908c:	c1 f8       	rjmp	800090ca <_vfprintf_r+0x1226>
8000908e:	fa c8 f9 50 	sub	r8,sp,-1712
80009092:	1a d8       	st.w	--sp,r8
80009094:	fa c8 fa b8 	sub	r8,sp,-1352
80009098:	1a d8       	st.w	--sp,r8
8000909a:	fa c8 fb b4 	sub	r8,sp,-1100
8000909e:	1a d8       	st.w	--sp,r8
800090a0:	fa c8 f9 40 	sub	r8,sp,-1728
800090a4:	fa c9 ff b4 	sub	r9,sp,-76
800090a8:	04 9a       	mov	r10,r2
800090aa:	0c 9b       	mov	r11,r6
800090ac:	08 9c       	mov	r12,r4
800090ae:	fe b0 f5 63 	rcall	80007b74 <get_arg>
800090b2:	2f dd       	sub	sp,-12
800090b4:	98 18       	ld.sh	r8,r12[0x2]
800090b6:	c2 68       	rjmp	80009102 <_vfprintf_r+0x125e>
800090b8:	ee ca ff ff 	sub	r10,r7,-1
800090bc:	10 37       	cp.w	r7,r8
800090be:	c0 94       	brge	800090d0 <_vfprintf_r+0x122c>
800090c0:	fa c9 f9 44 	sub	r9,sp,-1724
800090c4:	14 97       	mov	r7,r10
800090c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090ca:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800090ce:	c1 a8       	rjmp	80009102 <_vfprintf_r+0x125e>
800090d0:	41 09       	lddsp	r9,sp[0x40]
800090d2:	59 f8       	cp.w	r8,31
800090d4:	e0 89 00 13 	brgt	800090fa <_vfprintf_r+0x1256>
800090d8:	f2 cb ff fc 	sub	r11,r9,-4
800090dc:	51 0b       	stdsp	sp[0x40],r11
800090de:	72 09       	ld.w	r9,r9[0x0]
800090e0:	fa c6 f9 44 	sub	r6,sp,-1724
800090e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800090e8:	2f f8       	sub	r8,-1
800090ea:	f7 49 fd 88 	st.w	r11[-632],r9
800090ee:	fb 48 06 b4 	st.w	sp[1716],r8
800090f2:	14 97       	mov	r7,r10
800090f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800090f8:	c0 58       	rjmp	80009102 <_vfprintf_r+0x125e>
800090fa:	92 18       	ld.sh	r8,r9[0x2]
800090fc:	14 97       	mov	r7,r10
800090fe:	2f c9       	sub	r9,-4
80009100:	51 09       	stdsp	sp[0x40],r9
80009102:	5c 78       	castu.h	r8
80009104:	50 18       	stdsp	sp[0x4],r8
80009106:	c4 68       	rjmp	80009192 <_vfprintf_r+0x12ee>
80009108:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000910c:	40 3c       	lddsp	r12,sp[0xc]
8000910e:	58 0c       	cp.w	r12,0
80009110:	c1 d0       	breq	8000914a <_vfprintf_r+0x12a6>
80009112:	10 36       	cp.w	r6,r8
80009114:	c0 64       	brge	80009120 <_vfprintf_r+0x127c>
80009116:	fa cb f9 44 	sub	r11,sp,-1724
8000911a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000911e:	c1 f8       	rjmp	8000915c <_vfprintf_r+0x12b8>
80009120:	fa c8 f9 50 	sub	r8,sp,-1712
80009124:	1a d8       	st.w	--sp,r8
80009126:	fa c8 fa b8 	sub	r8,sp,-1352
8000912a:	0c 9b       	mov	r11,r6
8000912c:	1a d8       	st.w	--sp,r8
8000912e:	fa c8 fb b4 	sub	r8,sp,-1100
80009132:	04 9a       	mov	r10,r2
80009134:	1a d8       	st.w	--sp,r8
80009136:	08 9c       	mov	r12,r4
80009138:	fa c8 f9 40 	sub	r8,sp,-1728
8000913c:	fa c9 ff b4 	sub	r9,sp,-76
80009140:	fe b0 f5 1a 	rcall	80007b74 <get_arg>
80009144:	2f dd       	sub	sp,-12
80009146:	78 0b       	ld.w	r11,r12[0x0]
80009148:	c2 48       	rjmp	80009190 <_vfprintf_r+0x12ec>
8000914a:	ee ca ff ff 	sub	r10,r7,-1
8000914e:	10 37       	cp.w	r7,r8
80009150:	c0 94       	brge	80009162 <_vfprintf_r+0x12be>
80009152:	fa c9 f9 44 	sub	r9,sp,-1724
80009156:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000915a:	14 97       	mov	r7,r10
8000915c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009160:	c1 88       	rjmp	80009190 <_vfprintf_r+0x12ec>
80009162:	41 09       	lddsp	r9,sp[0x40]
80009164:	59 f8       	cp.w	r8,31
80009166:	e0 89 00 11 	brgt	80009188 <_vfprintf_r+0x12e4>
8000916a:	f2 cb ff fc 	sub	r11,r9,-4
8000916e:	51 0b       	stdsp	sp[0x40],r11
80009170:	fa c6 f9 44 	sub	r6,sp,-1724
80009174:	72 0b       	ld.w	r11,r9[0x0]
80009176:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000917a:	f3 4b fd 88 	st.w	r9[-632],r11
8000917e:	2f f8       	sub	r8,-1
80009180:	14 97       	mov	r7,r10
80009182:	fb 48 06 b4 	st.w	sp[1716],r8
80009186:	c0 58       	rjmp	80009190 <_vfprintf_r+0x12ec>
80009188:	72 0b       	ld.w	r11,r9[0x0]
8000918a:	14 97       	mov	r7,r10
8000918c:	2f c9       	sub	r9,-4
8000918e:	51 09       	stdsp	sp[0x40],r9
80009190:	50 1b       	stdsp	sp[0x4],r11
80009192:	30 0e       	mov	lr,0
80009194:	30 18       	mov	r8,1
80009196:	50 0e       	stdsp	sp[0x0],lr
80009198:	c2 29       	rjmp	800093dc <_vfprintf_r+0x1538>
8000919a:	50 a7       	stdsp	sp[0x28],r7
8000919c:	50 80       	stdsp	sp[0x20],r0
8000919e:	0c 97       	mov	r7,r6
800091a0:	04 94       	mov	r4,r2
800091a2:	06 96       	mov	r6,r3
800091a4:	02 92       	mov	r2,r1
800091a6:	fe cc b5 32 	sub	r12,pc,-19150
800091aa:	40 93       	lddsp	r3,sp[0x24]
800091ac:	10 90       	mov	r0,r8
800091ae:	40 41       	lddsp	r1,sp[0x10]
800091b0:	50 dc       	stdsp	sp[0x34],r12
800091b2:	ed b5 00 05 	bld	r5,0x5
800091b6:	c5 51       	brne	80009260 <_vfprintf_r+0x13bc>
800091b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091bc:	40 3b       	lddsp	r11,sp[0xc]
800091be:	58 0b       	cp.w	r11,0
800091c0:	c2 20       	breq	80009204 <_vfprintf_r+0x1360>
800091c2:	10 36       	cp.w	r6,r8
800091c4:	c0 a4       	brge	800091d8 <_vfprintf_r+0x1334>
800091c6:	fa ca f9 44 	sub	r10,sp,-1724
800091ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
800091ce:	ec e8 fd 88 	ld.d	r8,r6[-632]
800091d2:	fa e9 00 00 	st.d	sp[0],r8
800091d6:	cf 28       	rjmp	800093ba <_vfprintf_r+0x1516>
800091d8:	fa c8 f9 50 	sub	r8,sp,-1712
800091dc:	1a d8       	st.w	--sp,r8
800091de:	fa c8 fa b8 	sub	r8,sp,-1352
800091e2:	04 9a       	mov	r10,r2
800091e4:	1a d8       	st.w	--sp,r8
800091e6:	0c 9b       	mov	r11,r6
800091e8:	fa c8 fb b4 	sub	r8,sp,-1100
800091ec:	08 9c       	mov	r12,r4
800091ee:	1a d8       	st.w	--sp,r8
800091f0:	fa c8 f9 40 	sub	r8,sp,-1728
800091f4:	fa c9 ff b4 	sub	r9,sp,-76
800091f8:	fe b0 f4 be 	rcall	80007b74 <get_arg>
800091fc:	2f dd       	sub	sp,-12
800091fe:	f8 ea 00 00 	ld.d	r10,r12[0]
80009202:	c0 c8       	rjmp	8000921a <_vfprintf_r+0x1376>
80009204:	ee ca ff ff 	sub	r10,r7,-1
80009208:	10 37       	cp.w	r7,r8
8000920a:	c0 b4       	brge	80009220 <_vfprintf_r+0x137c>
8000920c:	fa c9 f9 44 	sub	r9,sp,-1724
80009210:	14 97       	mov	r7,r10
80009212:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009216:	ec ea fd 88 	ld.d	r10,r6[-632]
8000921a:	fa eb 00 00 	st.d	sp[0],r10
8000921e:	cc e8       	rjmp	800093ba <_vfprintf_r+0x1516>
80009220:	41 09       	lddsp	r9,sp[0x40]
80009222:	59 f8       	cp.w	r8,31
80009224:	e0 89 00 16 	brgt	80009250 <_vfprintf_r+0x13ac>
80009228:	f2 e6 00 00 	ld.d	r6,r9[0]
8000922c:	f2 cb ff f8 	sub	r11,r9,-8
80009230:	fa e7 00 00 	st.d	sp[0],r6
80009234:	51 0b       	stdsp	sp[0x40],r11
80009236:	fa c6 f9 44 	sub	r6,sp,-1724
8000923a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000923e:	fa e6 00 00 	ld.d	r6,sp[0]
80009242:	f2 e7 fd 88 	st.d	r9[-632],r6
80009246:	2f f8       	sub	r8,-1
80009248:	14 97       	mov	r7,r10
8000924a:	fb 48 06 b4 	st.w	sp[1716],r8
8000924e:	cb 68       	rjmp	800093ba <_vfprintf_r+0x1516>
80009250:	f2 e6 00 00 	ld.d	r6,r9[0]
80009254:	2f 89       	sub	r9,-8
80009256:	fa e7 00 00 	st.d	sp[0],r6
8000925a:	51 09       	stdsp	sp[0x40],r9
8000925c:	14 97       	mov	r7,r10
8000925e:	ca e8       	rjmp	800093ba <_vfprintf_r+0x1516>
80009260:	ed b5 00 04 	bld	r5,0x4
80009264:	c1 71       	brne	80009292 <_vfprintf_r+0x13ee>
80009266:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000926a:	40 3e       	lddsp	lr,sp[0xc]
8000926c:	58 0e       	cp.w	lr,0
8000926e:	c0 80       	breq	8000927e <_vfprintf_r+0x13da>
80009270:	10 36       	cp.w	r6,r8
80009272:	c6 94       	brge	80009344 <_vfprintf_r+0x14a0>
80009274:	fa cc f9 44 	sub	r12,sp,-1724
80009278:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000927c:	c8 28       	rjmp	80009380 <_vfprintf_r+0x14dc>
8000927e:	ee ca ff ff 	sub	r10,r7,-1
80009282:	10 37       	cp.w	r7,r8
80009284:	e0 84 00 81 	brge	80009386 <_vfprintf_r+0x14e2>
80009288:	fa cb f9 44 	sub	r11,sp,-1724
8000928c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009290:	c7 78       	rjmp	8000937e <_vfprintf_r+0x14da>
80009292:	ed b5 00 06 	bld	r5,0x6
80009296:	c4 b1       	brne	8000932c <_vfprintf_r+0x1488>
80009298:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000929c:	40 3c       	lddsp	r12,sp[0xc]
8000929e:	58 0c       	cp.w	r12,0
800092a0:	c1 d0       	breq	800092da <_vfprintf_r+0x1436>
800092a2:	10 36       	cp.w	r6,r8
800092a4:	c0 64       	brge	800092b0 <_vfprintf_r+0x140c>
800092a6:	fa cb f9 44 	sub	r11,sp,-1724
800092aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ae:	c1 f8       	rjmp	800092ec <_vfprintf_r+0x1448>
800092b0:	fa c8 f9 50 	sub	r8,sp,-1712
800092b4:	1a d8       	st.w	--sp,r8
800092b6:	fa c8 fa b8 	sub	r8,sp,-1352
800092ba:	1a d8       	st.w	--sp,r8
800092bc:	fa c8 fb b4 	sub	r8,sp,-1100
800092c0:	1a d8       	st.w	--sp,r8
800092c2:	fa c8 f9 40 	sub	r8,sp,-1728
800092c6:	fa c9 ff b4 	sub	r9,sp,-76
800092ca:	04 9a       	mov	r10,r2
800092cc:	0c 9b       	mov	r11,r6
800092ce:	08 9c       	mov	r12,r4
800092d0:	fe b0 f4 52 	rcall	80007b74 <get_arg>
800092d4:	2f dd       	sub	sp,-12
800092d6:	98 18       	ld.sh	r8,r12[0x2]
800092d8:	c2 78       	rjmp	80009326 <_vfprintf_r+0x1482>
800092da:	ee ca ff ff 	sub	r10,r7,-1
800092de:	10 37       	cp.w	r7,r8
800092e0:	c0 a4       	brge	800092f4 <_vfprintf_r+0x1450>
800092e2:	fa c9 f9 44 	sub	r9,sp,-1724
800092e6:	14 97       	mov	r7,r10
800092e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092ec:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800092f0:	c1 b8       	rjmp	80009326 <_vfprintf_r+0x1482>
800092f2:	d7 03       	nop
800092f4:	41 09       	lddsp	r9,sp[0x40]
800092f6:	59 f8       	cp.w	r8,31
800092f8:	e0 89 00 13 	brgt	8000931e <_vfprintf_r+0x147a>
800092fc:	f2 cb ff fc 	sub	r11,r9,-4
80009300:	51 0b       	stdsp	sp[0x40],r11
80009302:	72 09       	ld.w	r9,r9[0x0]
80009304:	fa c6 f9 44 	sub	r6,sp,-1724
80009308:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000930c:	2f f8       	sub	r8,-1
8000930e:	f7 49 fd 88 	st.w	r11[-632],r9
80009312:	fb 48 06 b4 	st.w	sp[1716],r8
80009316:	14 97       	mov	r7,r10
80009318:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000931c:	c0 58       	rjmp	80009326 <_vfprintf_r+0x1482>
8000931e:	92 18       	ld.sh	r8,r9[0x2]
80009320:	14 97       	mov	r7,r10
80009322:	2f c9       	sub	r9,-4
80009324:	51 09       	stdsp	sp[0x40],r9
80009326:	5c 78       	castu.h	r8
80009328:	50 18       	stdsp	sp[0x4],r8
8000932a:	c4 68       	rjmp	800093b6 <_vfprintf_r+0x1512>
8000932c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009330:	40 3c       	lddsp	r12,sp[0xc]
80009332:	58 0c       	cp.w	r12,0
80009334:	c1 d0       	breq	8000936e <_vfprintf_r+0x14ca>
80009336:	10 36       	cp.w	r6,r8
80009338:	c0 64       	brge	80009344 <_vfprintf_r+0x14a0>
8000933a:	fa cb f9 44 	sub	r11,sp,-1724
8000933e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009342:	c1 f8       	rjmp	80009380 <_vfprintf_r+0x14dc>
80009344:	fa c8 f9 50 	sub	r8,sp,-1712
80009348:	1a d8       	st.w	--sp,r8
8000934a:	fa c8 fa b8 	sub	r8,sp,-1352
8000934e:	0c 9b       	mov	r11,r6
80009350:	1a d8       	st.w	--sp,r8
80009352:	fa c8 fb b4 	sub	r8,sp,-1100
80009356:	04 9a       	mov	r10,r2
80009358:	1a d8       	st.w	--sp,r8
8000935a:	08 9c       	mov	r12,r4
8000935c:	fa c8 f9 40 	sub	r8,sp,-1728
80009360:	fa c9 ff b4 	sub	r9,sp,-76
80009364:	fe b0 f4 08 	rcall	80007b74 <get_arg>
80009368:	2f dd       	sub	sp,-12
8000936a:	78 0b       	ld.w	r11,r12[0x0]
8000936c:	c2 48       	rjmp	800093b4 <_vfprintf_r+0x1510>
8000936e:	ee ca ff ff 	sub	r10,r7,-1
80009372:	10 37       	cp.w	r7,r8
80009374:	c0 94       	brge	80009386 <_vfprintf_r+0x14e2>
80009376:	fa c9 f9 44 	sub	r9,sp,-1724
8000937a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000937e:	14 97       	mov	r7,r10
80009380:	ec fb fd 88 	ld.w	r11,r6[-632]
80009384:	c1 88       	rjmp	800093b4 <_vfprintf_r+0x1510>
80009386:	41 09       	lddsp	r9,sp[0x40]
80009388:	59 f8       	cp.w	r8,31
8000938a:	e0 89 00 11 	brgt	800093ac <_vfprintf_r+0x1508>
8000938e:	f2 cb ff fc 	sub	r11,r9,-4
80009392:	51 0b       	stdsp	sp[0x40],r11
80009394:	fa c6 f9 44 	sub	r6,sp,-1724
80009398:	72 0b       	ld.w	r11,r9[0x0]
8000939a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000939e:	f3 4b fd 88 	st.w	r9[-632],r11
800093a2:	2f f8       	sub	r8,-1
800093a4:	14 97       	mov	r7,r10
800093a6:	fb 48 06 b4 	st.w	sp[1716],r8
800093aa:	c0 58       	rjmp	800093b4 <_vfprintf_r+0x1510>
800093ac:	72 0b       	ld.w	r11,r9[0x0]
800093ae:	14 97       	mov	r7,r10
800093b0:	2f c9       	sub	r9,-4
800093b2:	51 09       	stdsp	sp[0x40],r9
800093b4:	50 1b       	stdsp	sp[0x4],r11
800093b6:	30 0e       	mov	lr,0
800093b8:	50 0e       	stdsp	sp[0x0],lr
800093ba:	40 08       	lddsp	r8,sp[0x0]
800093bc:	40 1c       	lddsp	r12,sp[0x4]
800093be:	18 48       	or	r8,r12
800093c0:	5f 19       	srne	r9
800093c2:	0a 98       	mov	r8,r5
800093c4:	eb e9 00 09 	and	r9,r5,r9
800093c8:	a1 b8       	sbr	r8,0x1
800093ca:	58 09       	cp.w	r9,0
800093cc:	c0 70       	breq	800093da <_vfprintf_r+0x1536>
800093ce:	10 95       	mov	r5,r8
800093d0:	fb 60 06 b9 	st.b	sp[1721],r0
800093d4:	33 08       	mov	r8,48
800093d6:	fb 68 06 b8 	st.b	sp[1720],r8
800093da:	30 28       	mov	r8,2
800093dc:	30 09       	mov	r9,0
800093de:	fb 69 06 bb 	st.b	sp[1723],r9
800093e2:	0a 99       	mov	r9,r5
800093e4:	a7 d9       	cbr	r9,0x7
800093e6:	40 2b       	lddsp	r11,sp[0x8]
800093e8:	40 16       	lddsp	r6,sp[0x4]
800093ea:	58 0b       	cp.w	r11,0
800093ec:	5f 1a       	srne	r10
800093ee:	f2 05 17 40 	movge	r5,r9
800093f2:	fa c2 f9 78 	sub	r2,sp,-1672
800093f6:	40 09       	lddsp	r9,sp[0x0]
800093f8:	0c 49       	or	r9,r6
800093fa:	5f 19       	srne	r9
800093fc:	f5 e9 10 09 	or	r9,r10,r9
80009400:	c5 c0       	breq	800094b8 <_vfprintf_r+0x1614>
80009402:	30 19       	mov	r9,1
80009404:	f2 08 18 00 	cp.b	r8,r9
80009408:	c0 60       	breq	80009414 <_vfprintf_r+0x1570>
8000940a:	30 29       	mov	r9,2
8000940c:	f2 08 18 00 	cp.b	r8,r9
80009410:	c0 41       	brne	80009418 <_vfprintf_r+0x1574>
80009412:	c3 c8       	rjmp	8000948a <_vfprintf_r+0x15e6>
80009414:	04 96       	mov	r6,r2
80009416:	c3 08       	rjmp	80009476 <_vfprintf_r+0x15d2>
80009418:	04 96       	mov	r6,r2
8000941a:	fa e8 00 00 	ld.d	r8,sp[0]
8000941e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009422:	2d 0a       	sub	r10,-48
80009424:	0c fa       	st.b	--r6,r10
80009426:	f0 0b 16 03 	lsr	r11,r8,0x3
8000942a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000942e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009432:	18 99       	mov	r9,r12
80009434:	16 98       	mov	r8,r11
80009436:	58 08       	cp.w	r8,0
80009438:	5c 29       	cpc	r9
8000943a:	cf 21       	brne	8000941e <_vfprintf_r+0x157a>
8000943c:	fa e9 00 00 	st.d	sp[0],r8
80009440:	ed b5 00 00 	bld	r5,0x0
80009444:	c4 51       	brne	800094ce <_vfprintf_r+0x162a>
80009446:	33 09       	mov	r9,48
80009448:	f2 0a 18 00 	cp.b	r10,r9
8000944c:	c4 10       	breq	800094ce <_vfprintf_r+0x162a>
8000944e:	0c f9       	st.b	--r6,r9
80009450:	c3 f8       	rjmp	800094ce <_vfprintf_r+0x162a>
80009452:	fa ea 00 00 	ld.d	r10,sp[0]
80009456:	30 a8       	mov	r8,10
80009458:	30 09       	mov	r9,0
8000945a:	e0 a0 1a 19 	rcall	8000c88c <__avr32_umod64>
8000945e:	30 a8       	mov	r8,10
80009460:	2d 0a       	sub	r10,-48
80009462:	30 09       	mov	r9,0
80009464:	ac 8a       	st.b	r6[0x0],r10
80009466:	fa ea 00 00 	ld.d	r10,sp[0]
8000946a:	e0 a0 18 df 	rcall	8000c628 <__avr32_udiv64>
8000946e:	16 99       	mov	r9,r11
80009470:	14 98       	mov	r8,r10
80009472:	fa e9 00 00 	st.d	sp[0],r8
80009476:	20 16       	sub	r6,1
80009478:	fa ea 00 00 	ld.d	r10,sp[0]
8000947c:	58 9a       	cp.w	r10,9
8000947e:	5c 2b       	cpc	r11
80009480:	fe 9b ff e9 	brhi	80009452 <_vfprintf_r+0x15ae>
80009484:	1b f8       	ld.ub	r8,sp[0x7]
80009486:	2d 08       	sub	r8,-48
80009488:	c2 08       	rjmp	800094c8 <_vfprintf_r+0x1624>
8000948a:	04 96       	mov	r6,r2
8000948c:	fa e8 00 00 	ld.d	r8,sp[0]
80009490:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009494:	40 de       	lddsp	lr,sp[0x34]
80009496:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000949a:	0c fa       	st.b	--r6,r10
8000949c:	f2 0b 16 04 	lsr	r11,r9,0x4
800094a0:	f0 0a 16 04 	lsr	r10,r8,0x4
800094a4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800094a8:	16 99       	mov	r9,r11
800094aa:	14 98       	mov	r8,r10
800094ac:	58 08       	cp.w	r8,0
800094ae:	5c 29       	cpc	r9
800094b0:	cf 01       	brne	80009490 <_vfprintf_r+0x15ec>
800094b2:	fa e9 00 00 	st.d	sp[0],r8
800094b6:	c0 c8       	rjmp	800094ce <_vfprintf_r+0x162a>
800094b8:	58 08       	cp.w	r8,0
800094ba:	c0 91       	brne	800094cc <_vfprintf_r+0x1628>
800094bc:	ed b5 00 00 	bld	r5,0x0
800094c0:	c0 61       	brne	800094cc <_vfprintf_r+0x1628>
800094c2:	fa c6 f9 79 	sub	r6,sp,-1671
800094c6:	33 08       	mov	r8,48
800094c8:	ac 88       	st.b	r6[0x0],r8
800094ca:	c0 28       	rjmp	800094ce <_vfprintf_r+0x162a>
800094cc:	04 96       	mov	r6,r2
800094ce:	0c 12       	sub	r2,r6
800094d0:	c1 c8       	rjmp	80009508 <_vfprintf_r+0x1664>
800094d2:	50 a7       	stdsp	sp[0x28],r7
800094d4:	50 80       	stdsp	sp[0x20],r0
800094d6:	40 93       	lddsp	r3,sp[0x24]
800094d8:	0c 97       	mov	r7,r6
800094da:	10 90       	mov	r0,r8
800094dc:	04 94       	mov	r4,r2
800094de:	40 41       	lddsp	r1,sp[0x10]
800094e0:	58 08       	cp.w	r8,0
800094e2:	e0 80 04 4f 	breq	80009d80 <_vfprintf_r+0x1edc>
800094e6:	fb 68 06 60 	st.b	sp[1632],r8
800094ea:	30 0c       	mov	r12,0
800094ec:	30 08       	mov	r8,0
800094ee:	30 12       	mov	r2,1
800094f0:	fb 68 06 bb 	st.b	sp[1723],r8
800094f4:	50 2c       	stdsp	sp[0x8],r12
800094f6:	fa c6 f9 a0 	sub	r6,sp,-1632
800094fa:	c0 78       	rjmp	80009508 <_vfprintf_r+0x1664>
800094fc:	30 0b       	mov	r11,0
800094fe:	50 2b       	stdsp	sp[0x8],r11
80009500:	c0 48       	rjmp	80009508 <_vfprintf_r+0x1664>
80009502:	40 22       	lddsp	r2,sp[0x8]
80009504:	30 0a       	mov	r10,0
80009506:	50 2a       	stdsp	sp[0x8],r10
80009508:	40 29       	lddsp	r9,sp[0x8]
8000950a:	e4 09 0c 49 	max	r9,r2,r9
8000950e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009512:	50 39       	stdsp	sp[0xc],r9
80009514:	0a 9e       	mov	lr,r5
80009516:	30 09       	mov	r9,0
80009518:	e2 1e 00 02 	andl	lr,0x2,COH
8000951c:	f2 08 18 00 	cp.b	r8,r9
80009520:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009524:	f7 b8 01 ff 	subne	r8,-1
80009528:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000952c:	0a 9b       	mov	r11,r5
8000952e:	58 0e       	cp.w	lr,0
80009530:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009534:	f7 bc 01 fe 	subne	r12,-2
80009538:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000953c:	e2 1b 00 84 	andl	r11,0x84,COH
80009540:	50 fe       	stdsp	sp[0x3c],lr
80009542:	50 9b       	stdsp	sp[0x24],r11
80009544:	c4 71       	brne	800095d2 <_vfprintf_r+0x172e>
80009546:	40 8a       	lddsp	r10,sp[0x20]
80009548:	40 39       	lddsp	r9,sp[0xc]
8000954a:	12 1a       	sub	r10,r9
8000954c:	50 4a       	stdsp	sp[0x10],r10
8000954e:	58 0a       	cp.w	r10,0
80009550:	e0 89 00 20 	brgt	80009590 <_vfprintf_r+0x16ec>
80009554:	c3 f8       	rjmp	800095d2 <_vfprintf_r+0x172e>
80009556:	2f 09       	sub	r9,-16
80009558:	2f f8       	sub	r8,-1
8000955a:	fe ce b8 ce 	sub	lr,pc,-18226
8000955e:	31 0c       	mov	r12,16
80009560:	fb 49 06 90 	st.w	sp[1680],r9
80009564:	87 0e       	st.w	r3[0x0],lr
80009566:	87 1c       	st.w	r3[0x4],r12
80009568:	fb 48 06 8c 	st.w	sp[1676],r8
8000956c:	58 78       	cp.w	r8,7
8000956e:	e0 89 00 04 	brgt	80009576 <_vfprintf_r+0x16d2>
80009572:	2f 83       	sub	r3,-8
80009574:	c0 b8       	rjmp	8000958a <_vfprintf_r+0x16e6>
80009576:	fa ca f9 78 	sub	r10,sp,-1672
8000957a:	02 9b       	mov	r11,r1
8000957c:	08 9c       	mov	r12,r4
8000957e:	fe b0 f4 85 	rcall	80007e88 <__sprint_r>
80009582:	e0 81 04 10 	brne	80009da2 <_vfprintf_r+0x1efe>
80009586:	fa c3 f9 e0 	sub	r3,sp,-1568
8000958a:	40 4b       	lddsp	r11,sp[0x10]
8000958c:	21 0b       	sub	r11,16
8000958e:	50 4b       	stdsp	sp[0x10],r11
80009590:	fa f9 06 90 	ld.w	r9,sp[1680]
80009594:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009598:	fe ca b9 0c 	sub	r10,pc,-18164
8000959c:	40 4e       	lddsp	lr,sp[0x10]
8000959e:	59 0e       	cp.w	lr,16
800095a0:	fe 99 ff db 	brgt	80009556 <_vfprintf_r+0x16b2>
800095a4:	1c 09       	add	r9,lr
800095a6:	2f f8       	sub	r8,-1
800095a8:	87 0a       	st.w	r3[0x0],r10
800095aa:	fb 49 06 90 	st.w	sp[1680],r9
800095ae:	87 1e       	st.w	r3[0x4],lr
800095b0:	fb 48 06 8c 	st.w	sp[1676],r8
800095b4:	58 78       	cp.w	r8,7
800095b6:	e0 89 00 04 	brgt	800095be <_vfprintf_r+0x171a>
800095ba:	2f 83       	sub	r3,-8
800095bc:	c0 b8       	rjmp	800095d2 <_vfprintf_r+0x172e>
800095be:	fa ca f9 78 	sub	r10,sp,-1672
800095c2:	02 9b       	mov	r11,r1
800095c4:	08 9c       	mov	r12,r4
800095c6:	fe b0 f4 61 	rcall	80007e88 <__sprint_r>
800095ca:	e0 81 03 ec 	brne	80009da2 <_vfprintf_r+0x1efe>
800095ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d2:	30 09       	mov	r9,0
800095d4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800095d8:	f2 08 18 00 	cp.b	r8,r9
800095dc:	c1 f0       	breq	8000961a <_vfprintf_r+0x1776>
800095de:	fa f8 06 90 	ld.w	r8,sp[1680]
800095e2:	fa c9 f9 45 	sub	r9,sp,-1723
800095e6:	2f f8       	sub	r8,-1
800095e8:	87 09       	st.w	r3[0x0],r9
800095ea:	fb 48 06 90 	st.w	sp[1680],r8
800095ee:	30 19       	mov	r9,1
800095f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095f4:	87 19       	st.w	r3[0x4],r9
800095f6:	2f f8       	sub	r8,-1
800095f8:	fb 48 06 8c 	st.w	sp[1676],r8
800095fc:	58 78       	cp.w	r8,7
800095fe:	e0 89 00 04 	brgt	80009606 <_vfprintf_r+0x1762>
80009602:	2f 83       	sub	r3,-8
80009604:	c0 b8       	rjmp	8000961a <_vfprintf_r+0x1776>
80009606:	fa ca f9 78 	sub	r10,sp,-1672
8000960a:	02 9b       	mov	r11,r1
8000960c:	08 9c       	mov	r12,r4
8000960e:	fe b0 f4 3d 	rcall	80007e88 <__sprint_r>
80009612:	e0 81 03 c8 	brne	80009da2 <_vfprintf_r+0x1efe>
80009616:	fa c3 f9 e0 	sub	r3,sp,-1568
8000961a:	40 fc       	lddsp	r12,sp[0x3c]
8000961c:	58 0c       	cp.w	r12,0
8000961e:	c1 f0       	breq	8000965c <_vfprintf_r+0x17b8>
80009620:	fa f8 06 90 	ld.w	r8,sp[1680]
80009624:	fa c9 f9 48 	sub	r9,sp,-1720
80009628:	2f e8       	sub	r8,-2
8000962a:	87 09       	st.w	r3[0x0],r9
8000962c:	fb 48 06 90 	st.w	sp[1680],r8
80009630:	30 29       	mov	r9,2
80009632:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009636:	87 19       	st.w	r3[0x4],r9
80009638:	2f f8       	sub	r8,-1
8000963a:	fb 48 06 8c 	st.w	sp[1676],r8
8000963e:	58 78       	cp.w	r8,7
80009640:	e0 89 00 04 	brgt	80009648 <_vfprintf_r+0x17a4>
80009644:	2f 83       	sub	r3,-8
80009646:	c0 b8       	rjmp	8000965c <_vfprintf_r+0x17b8>
80009648:	fa ca f9 78 	sub	r10,sp,-1672
8000964c:	02 9b       	mov	r11,r1
8000964e:	08 9c       	mov	r12,r4
80009650:	fe b0 f4 1c 	rcall	80007e88 <__sprint_r>
80009654:	e0 81 03 a7 	brne	80009da2 <_vfprintf_r+0x1efe>
80009658:	fa c3 f9 e0 	sub	r3,sp,-1568
8000965c:	40 9b       	lddsp	r11,sp[0x24]
8000965e:	e0 4b 00 80 	cp.w	r11,128
80009662:	c4 71       	brne	800096f0 <_vfprintf_r+0x184c>
80009664:	40 8a       	lddsp	r10,sp[0x20]
80009666:	40 39       	lddsp	r9,sp[0xc]
80009668:	12 1a       	sub	r10,r9
8000966a:	50 4a       	stdsp	sp[0x10],r10
8000966c:	58 0a       	cp.w	r10,0
8000966e:	e0 89 00 20 	brgt	800096ae <_vfprintf_r+0x180a>
80009672:	c3 f8       	rjmp	800096f0 <_vfprintf_r+0x184c>
80009674:	2f 09       	sub	r9,-16
80009676:	2f f8       	sub	r8,-1
80009678:	fe ce b9 dc 	sub	lr,pc,-17956
8000967c:	31 0c       	mov	r12,16
8000967e:	fb 49 06 90 	st.w	sp[1680],r9
80009682:	87 0e       	st.w	r3[0x0],lr
80009684:	87 1c       	st.w	r3[0x4],r12
80009686:	fb 48 06 8c 	st.w	sp[1676],r8
8000968a:	58 78       	cp.w	r8,7
8000968c:	e0 89 00 04 	brgt	80009694 <_vfprintf_r+0x17f0>
80009690:	2f 83       	sub	r3,-8
80009692:	c0 b8       	rjmp	800096a8 <_vfprintf_r+0x1804>
80009694:	fa ca f9 78 	sub	r10,sp,-1672
80009698:	02 9b       	mov	r11,r1
8000969a:	08 9c       	mov	r12,r4
8000969c:	fe b0 f3 f6 	rcall	80007e88 <__sprint_r>
800096a0:	e0 81 03 81 	brne	80009da2 <_vfprintf_r+0x1efe>
800096a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a8:	40 4b       	lddsp	r11,sp[0x10]
800096aa:	21 0b       	sub	r11,16
800096ac:	50 4b       	stdsp	sp[0x10],r11
800096ae:	fa f9 06 90 	ld.w	r9,sp[1680]
800096b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096b6:	fe ca ba 1a 	sub	r10,pc,-17894
800096ba:	40 4e       	lddsp	lr,sp[0x10]
800096bc:	59 0e       	cp.w	lr,16
800096be:	fe 99 ff db 	brgt	80009674 <_vfprintf_r+0x17d0>
800096c2:	1c 09       	add	r9,lr
800096c4:	2f f8       	sub	r8,-1
800096c6:	87 0a       	st.w	r3[0x0],r10
800096c8:	fb 49 06 90 	st.w	sp[1680],r9
800096cc:	87 1e       	st.w	r3[0x4],lr
800096ce:	fb 48 06 8c 	st.w	sp[1676],r8
800096d2:	58 78       	cp.w	r8,7
800096d4:	e0 89 00 04 	brgt	800096dc <_vfprintf_r+0x1838>
800096d8:	2f 83       	sub	r3,-8
800096da:	c0 b8       	rjmp	800096f0 <_vfprintf_r+0x184c>
800096dc:	fa ca f9 78 	sub	r10,sp,-1672
800096e0:	02 9b       	mov	r11,r1
800096e2:	08 9c       	mov	r12,r4
800096e4:	fe b0 f3 d2 	rcall	80007e88 <__sprint_r>
800096e8:	e0 81 03 5d 	brne	80009da2 <_vfprintf_r+0x1efe>
800096ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800096f0:	40 2c       	lddsp	r12,sp[0x8]
800096f2:	04 1c       	sub	r12,r2
800096f4:	50 2c       	stdsp	sp[0x8],r12
800096f6:	58 0c       	cp.w	r12,0
800096f8:	e0 89 00 20 	brgt	80009738 <_vfprintf_r+0x1894>
800096fc:	c3 f8       	rjmp	8000977a <_vfprintf_r+0x18d6>
800096fe:	2f 09       	sub	r9,-16
80009700:	2f f8       	sub	r8,-1
80009702:	fe cb ba 66 	sub	r11,pc,-17818
80009706:	31 0a       	mov	r10,16
80009708:	fb 49 06 90 	st.w	sp[1680],r9
8000970c:	87 0b       	st.w	r3[0x0],r11
8000970e:	87 1a       	st.w	r3[0x4],r10
80009710:	fb 48 06 8c 	st.w	sp[1676],r8
80009714:	58 78       	cp.w	r8,7
80009716:	e0 89 00 04 	brgt	8000971e <_vfprintf_r+0x187a>
8000971a:	2f 83       	sub	r3,-8
8000971c:	c0 b8       	rjmp	80009732 <_vfprintf_r+0x188e>
8000971e:	fa ca f9 78 	sub	r10,sp,-1672
80009722:	02 9b       	mov	r11,r1
80009724:	08 9c       	mov	r12,r4
80009726:	fe b0 f3 b1 	rcall	80007e88 <__sprint_r>
8000972a:	e0 81 03 3c 	brne	80009da2 <_vfprintf_r+0x1efe>
8000972e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009732:	40 29       	lddsp	r9,sp[0x8]
80009734:	21 09       	sub	r9,16
80009736:	50 29       	stdsp	sp[0x8],r9
80009738:	fa f9 06 90 	ld.w	r9,sp[1680]
8000973c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009740:	fe ca ba a4 	sub	r10,pc,-17756
80009744:	40 2e       	lddsp	lr,sp[0x8]
80009746:	59 0e       	cp.w	lr,16
80009748:	fe 99 ff db 	brgt	800096fe <_vfprintf_r+0x185a>
8000974c:	1c 09       	add	r9,lr
8000974e:	2f f8       	sub	r8,-1
80009750:	87 0a       	st.w	r3[0x0],r10
80009752:	fb 49 06 90 	st.w	sp[1680],r9
80009756:	87 1e       	st.w	r3[0x4],lr
80009758:	fb 48 06 8c 	st.w	sp[1676],r8
8000975c:	58 78       	cp.w	r8,7
8000975e:	e0 89 00 04 	brgt	80009766 <_vfprintf_r+0x18c2>
80009762:	2f 83       	sub	r3,-8
80009764:	c0 b8       	rjmp	8000977a <_vfprintf_r+0x18d6>
80009766:	fa ca f9 78 	sub	r10,sp,-1672
8000976a:	02 9b       	mov	r11,r1
8000976c:	08 9c       	mov	r12,r4
8000976e:	fe b0 f3 8d 	rcall	80007e88 <__sprint_r>
80009772:	e0 81 03 18 	brne	80009da2 <_vfprintf_r+0x1efe>
80009776:	fa c3 f9 e0 	sub	r3,sp,-1568
8000977a:	ed b5 00 08 	bld	r5,0x8
8000977e:	c0 b0       	breq	80009794 <_vfprintf_r+0x18f0>
80009780:	fa f8 06 90 	ld.w	r8,sp[1680]
80009784:	87 12       	st.w	r3[0x4],r2
80009786:	87 06       	st.w	r3[0x0],r6
80009788:	f0 02 00 02 	add	r2,r8,r2
8000978c:	fb 42 06 90 	st.w	sp[1680],r2
80009790:	e0 8f 01 d4 	bral	80009b38 <_vfprintf_r+0x1c94>
80009794:	e0 40 00 65 	cp.w	r0,101
80009798:	e0 8a 01 d6 	brle	80009b44 <_vfprintf_r+0x1ca0>
8000979c:	30 08       	mov	r8,0
8000979e:	30 09       	mov	r9,0
800097a0:	40 5b       	lddsp	r11,sp[0x14]
800097a2:	40 7a       	lddsp	r10,sp[0x1c]
800097a4:	e0 a0 15 3b 	rcall	8000c21a <__avr32_f64_cmp_eq>
800097a8:	c7 90       	breq	8000989a <_vfprintf_r+0x19f6>
800097aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ae:	fe c9 bb 26 	sub	r9,pc,-17626
800097b2:	2f f8       	sub	r8,-1
800097b4:	87 09       	st.w	r3[0x0],r9
800097b6:	fb 48 06 90 	st.w	sp[1680],r8
800097ba:	30 19       	mov	r9,1
800097bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c0:	87 19       	st.w	r3[0x4],r9
800097c2:	2f f8       	sub	r8,-1
800097c4:	fb 48 06 8c 	st.w	sp[1676],r8
800097c8:	58 78       	cp.w	r8,7
800097ca:	e0 89 00 05 	brgt	800097d4 <_vfprintf_r+0x1930>
800097ce:	2f 83       	sub	r3,-8
800097d0:	c0 c8       	rjmp	800097e8 <_vfprintf_r+0x1944>
800097d2:	d7 03       	nop
800097d4:	fa ca f9 78 	sub	r10,sp,-1672
800097d8:	02 9b       	mov	r11,r1
800097da:	08 9c       	mov	r12,r4
800097dc:	fe b0 f3 56 	rcall	80007e88 <__sprint_r>
800097e0:	e0 81 02 e1 	brne	80009da2 <_vfprintf_r+0x1efe>
800097e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800097ec:	40 6c       	lddsp	r12,sp[0x18]
800097ee:	18 38       	cp.w	r8,r12
800097f0:	c0 55       	brlt	800097fa <_vfprintf_r+0x1956>
800097f2:	ed b5 00 00 	bld	r5,0x0
800097f6:	e0 81 02 6b 	brne	80009ccc <_vfprintf_r+0x1e28>
800097fa:	fa f8 06 90 	ld.w	r8,sp[1680]
800097fe:	2f f8       	sub	r8,-1
80009800:	40 cb       	lddsp	r11,sp[0x30]
80009802:	fb 48 06 90 	st.w	sp[1680],r8
80009806:	30 19       	mov	r9,1
80009808:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000980c:	87 0b       	st.w	r3[0x0],r11
8000980e:	2f f8       	sub	r8,-1
80009810:	87 19       	st.w	r3[0x4],r9
80009812:	fb 48 06 8c 	st.w	sp[1676],r8
80009816:	58 78       	cp.w	r8,7
80009818:	e0 89 00 04 	brgt	80009820 <_vfprintf_r+0x197c>
8000981c:	2f 83       	sub	r3,-8
8000981e:	c0 b8       	rjmp	80009834 <_vfprintf_r+0x1990>
80009820:	fa ca f9 78 	sub	r10,sp,-1672
80009824:	02 9b       	mov	r11,r1
80009826:	08 9c       	mov	r12,r4
80009828:	fe b0 f3 30 	rcall	80007e88 <__sprint_r>
8000982c:	e0 81 02 bb 	brne	80009da2 <_vfprintf_r+0x1efe>
80009830:	fa c3 f9 e0 	sub	r3,sp,-1568
80009834:	40 66       	lddsp	r6,sp[0x18]
80009836:	20 16       	sub	r6,1
80009838:	58 06       	cp.w	r6,0
8000983a:	e0 89 00 1d 	brgt	80009874 <_vfprintf_r+0x19d0>
8000983e:	e0 8f 02 47 	bral	80009ccc <_vfprintf_r+0x1e28>
80009842:	2f 09       	sub	r9,-16
80009844:	2f f8       	sub	r8,-1
80009846:	fb 49 06 90 	st.w	sp[1680],r9
8000984a:	87 02       	st.w	r3[0x0],r2
8000984c:	87 10       	st.w	r3[0x4],r0
8000984e:	fb 48 06 8c 	st.w	sp[1676],r8
80009852:	58 78       	cp.w	r8,7
80009854:	e0 89 00 04 	brgt	8000985c <_vfprintf_r+0x19b8>
80009858:	2f 83       	sub	r3,-8
8000985a:	c0 b8       	rjmp	80009870 <_vfprintf_r+0x19cc>
8000985c:	fa ca f9 78 	sub	r10,sp,-1672
80009860:	02 9b       	mov	r11,r1
80009862:	08 9c       	mov	r12,r4
80009864:	fe b0 f3 12 	rcall	80007e88 <__sprint_r>
80009868:	e0 81 02 9d 	brne	80009da2 <_vfprintf_r+0x1efe>
8000986c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009870:	21 06       	sub	r6,16
80009872:	c0 48       	rjmp	8000987a <_vfprintf_r+0x19d6>
80009874:	fe c2 bb d8 	sub	r2,pc,-17448
80009878:	31 00       	mov	r0,16
8000987a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000987e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009882:	fe ca bb e6 	sub	r10,pc,-17434
80009886:	59 06       	cp.w	r6,16
80009888:	fe 99 ff dd 	brgt	80009842 <_vfprintf_r+0x199e>
8000988c:	0c 09       	add	r9,r6
8000988e:	87 0a       	st.w	r3[0x0],r10
80009890:	fb 49 06 90 	st.w	sp[1680],r9
80009894:	2f f8       	sub	r8,-1
80009896:	87 16       	st.w	r3[0x4],r6
80009898:	c5 39       	rjmp	80009b3e <_vfprintf_r+0x1c9a>
8000989a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000989e:	58 0a       	cp.w	r10,0
800098a0:	e0 89 00 92 	brgt	800099c4 <_vfprintf_r+0x1b20>
800098a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800098a8:	fe c9 bc 20 	sub	r9,pc,-17376
800098ac:	2f f8       	sub	r8,-1
800098ae:	87 09       	st.w	r3[0x0],r9
800098b0:	fb 48 06 90 	st.w	sp[1680],r8
800098b4:	30 19       	mov	r9,1
800098b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ba:	87 19       	st.w	r3[0x4],r9
800098bc:	2f f8       	sub	r8,-1
800098be:	fb 48 06 8c 	st.w	sp[1676],r8
800098c2:	58 78       	cp.w	r8,7
800098c4:	e0 89 00 04 	brgt	800098cc <_vfprintf_r+0x1a28>
800098c8:	2f 83       	sub	r3,-8
800098ca:	c0 b8       	rjmp	800098e0 <_vfprintf_r+0x1a3c>
800098cc:	fa ca f9 78 	sub	r10,sp,-1672
800098d0:	02 9b       	mov	r11,r1
800098d2:	08 9c       	mov	r12,r4
800098d4:	fe b0 f2 da 	rcall	80007e88 <__sprint_r>
800098d8:	e0 81 02 65 	brne	80009da2 <_vfprintf_r+0x1efe>
800098dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800098e0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800098e4:	58 08       	cp.w	r8,0
800098e6:	c0 81       	brne	800098f6 <_vfprintf_r+0x1a52>
800098e8:	40 6a       	lddsp	r10,sp[0x18]
800098ea:	58 0a       	cp.w	r10,0
800098ec:	c0 51       	brne	800098f6 <_vfprintf_r+0x1a52>
800098ee:	ed b5 00 00 	bld	r5,0x0
800098f2:	e0 81 01 ed 	brne	80009ccc <_vfprintf_r+0x1e28>
800098f6:	40 c9       	lddsp	r9,sp[0x30]
800098f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800098fc:	2f f8       	sub	r8,-1
800098fe:	87 09       	st.w	r3[0x0],r9
80009900:	fb 48 06 90 	st.w	sp[1680],r8
80009904:	30 19       	mov	r9,1
80009906:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000990a:	87 19       	st.w	r3[0x4],r9
8000990c:	2f f8       	sub	r8,-1
8000990e:	fb 48 06 8c 	st.w	sp[1676],r8
80009912:	58 78       	cp.w	r8,7
80009914:	e0 89 00 04 	brgt	8000991c <_vfprintf_r+0x1a78>
80009918:	2f 83       	sub	r3,-8
8000991a:	c0 b8       	rjmp	80009930 <_vfprintf_r+0x1a8c>
8000991c:	fa ca f9 78 	sub	r10,sp,-1672
80009920:	02 9b       	mov	r11,r1
80009922:	08 9c       	mov	r12,r4
80009924:	fe b0 f2 b2 	rcall	80007e88 <__sprint_r>
80009928:	e0 81 02 3d 	brne	80009da2 <_vfprintf_r+0x1efe>
8000992c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009930:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009934:	5c 32       	neg	r2
80009936:	58 02       	cp.w	r2,0
80009938:	e0 89 00 1d 	brgt	80009972 <_vfprintf_r+0x1ace>
8000993c:	c3 d8       	rjmp	800099b6 <_vfprintf_r+0x1b12>
8000993e:	2f 09       	sub	r9,-16
80009940:	2f f8       	sub	r8,-1
80009942:	31 0e       	mov	lr,16
80009944:	fb 49 06 90 	st.w	sp[1680],r9
80009948:	87 00       	st.w	r3[0x0],r0
8000994a:	87 1e       	st.w	r3[0x4],lr
8000994c:	fb 48 06 8c 	st.w	sp[1676],r8
80009950:	58 78       	cp.w	r8,7
80009952:	e0 89 00 04 	brgt	8000995a <_vfprintf_r+0x1ab6>
80009956:	2f 83       	sub	r3,-8
80009958:	c0 b8       	rjmp	8000996e <_vfprintf_r+0x1aca>
8000995a:	fa ca f9 78 	sub	r10,sp,-1672
8000995e:	02 9b       	mov	r11,r1
80009960:	08 9c       	mov	r12,r4
80009962:	fe b0 f2 93 	rcall	80007e88 <__sprint_r>
80009966:	e0 81 02 1e 	brne	80009da2 <_vfprintf_r+0x1efe>
8000996a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000996e:	21 02       	sub	r2,16
80009970:	c0 38       	rjmp	80009976 <_vfprintf_r+0x1ad2>
80009972:	fe c0 bc d6 	sub	r0,pc,-17194
80009976:	fa f9 06 90 	ld.w	r9,sp[1680]
8000997a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000997e:	fe ca bc e2 	sub	r10,pc,-17182
80009982:	59 02       	cp.w	r2,16
80009984:	fe 99 ff dd 	brgt	8000993e <_vfprintf_r+0x1a9a>
80009988:	04 09       	add	r9,r2
8000998a:	2f f8       	sub	r8,-1
8000998c:	87 0a       	st.w	r3[0x0],r10
8000998e:	fb 49 06 90 	st.w	sp[1680],r9
80009992:	87 12       	st.w	r3[0x4],r2
80009994:	fb 48 06 8c 	st.w	sp[1676],r8
80009998:	58 78       	cp.w	r8,7
8000999a:	e0 89 00 04 	brgt	800099a2 <_vfprintf_r+0x1afe>
8000999e:	2f 83       	sub	r3,-8
800099a0:	c0 b8       	rjmp	800099b6 <_vfprintf_r+0x1b12>
800099a2:	fa ca f9 78 	sub	r10,sp,-1672
800099a6:	02 9b       	mov	r11,r1
800099a8:	08 9c       	mov	r12,r4
800099aa:	fe b0 f2 6f 	rcall	80007e88 <__sprint_r>
800099ae:	e0 81 01 fa 	brne	80009da2 <_vfprintf_r+0x1efe>
800099b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099b6:	40 6c       	lddsp	r12,sp[0x18]
800099b8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099bc:	87 06       	st.w	r3[0x0],r6
800099be:	87 1c       	st.w	r3[0x4],r12
800099c0:	18 08       	add	r8,r12
800099c2:	cb 98       	rjmp	80009b34 <_vfprintf_r+0x1c90>
800099c4:	fa f9 06 90 	ld.w	r9,sp[1680]
800099c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099cc:	40 6b       	lddsp	r11,sp[0x18]
800099ce:	16 3a       	cp.w	r10,r11
800099d0:	c6 f5       	brlt	80009aae <_vfprintf_r+0x1c0a>
800099d2:	16 09       	add	r9,r11
800099d4:	2f f8       	sub	r8,-1
800099d6:	87 06       	st.w	r3[0x0],r6
800099d8:	fb 49 06 90 	st.w	sp[1680],r9
800099dc:	87 1b       	st.w	r3[0x4],r11
800099de:	fb 48 06 8c 	st.w	sp[1676],r8
800099e2:	58 78       	cp.w	r8,7
800099e4:	e0 89 00 04 	brgt	800099ec <_vfprintf_r+0x1b48>
800099e8:	2f 83       	sub	r3,-8
800099ea:	c0 b8       	rjmp	80009a00 <_vfprintf_r+0x1b5c>
800099ec:	fa ca f9 78 	sub	r10,sp,-1672
800099f0:	02 9b       	mov	r11,r1
800099f2:	08 9c       	mov	r12,r4
800099f4:	fe b0 f2 4a 	rcall	80007e88 <__sprint_r>
800099f8:	e0 81 01 d5 	brne	80009da2 <_vfprintf_r+0x1efe>
800099fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a00:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009a04:	40 6a       	lddsp	r10,sp[0x18]
80009a06:	14 16       	sub	r6,r10
80009a08:	58 06       	cp.w	r6,0
80009a0a:	e0 89 00 1c 	brgt	80009a42 <_vfprintf_r+0x1b9e>
80009a0e:	c3 d8       	rjmp	80009a88 <_vfprintf_r+0x1be4>
80009a10:	2f 09       	sub	r9,-16
80009a12:	2f f8       	sub	r8,-1
80009a14:	fb 49 06 90 	st.w	sp[1680],r9
80009a18:	87 02       	st.w	r3[0x0],r2
80009a1a:	87 10       	st.w	r3[0x4],r0
80009a1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a20:	58 78       	cp.w	r8,7
80009a22:	e0 89 00 04 	brgt	80009a2a <_vfprintf_r+0x1b86>
80009a26:	2f 83       	sub	r3,-8
80009a28:	c0 b8       	rjmp	80009a3e <_vfprintf_r+0x1b9a>
80009a2a:	fa ca f9 78 	sub	r10,sp,-1672
80009a2e:	02 9b       	mov	r11,r1
80009a30:	08 9c       	mov	r12,r4
80009a32:	fe b0 f2 2b 	rcall	80007e88 <__sprint_r>
80009a36:	e0 81 01 b6 	brne	80009da2 <_vfprintf_r+0x1efe>
80009a3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a3e:	21 06       	sub	r6,16
80009a40:	c0 48       	rjmp	80009a48 <_vfprintf_r+0x1ba4>
80009a42:	fe c2 bd a6 	sub	r2,pc,-16986
80009a46:	31 00       	mov	r0,16
80009a48:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a50:	fe ca bd b4 	sub	r10,pc,-16972
80009a54:	59 06       	cp.w	r6,16
80009a56:	fe 99 ff dd 	brgt	80009a10 <_vfprintf_r+0x1b6c>
80009a5a:	0c 09       	add	r9,r6
80009a5c:	2f f8       	sub	r8,-1
80009a5e:	87 0a       	st.w	r3[0x0],r10
80009a60:	fb 49 06 90 	st.w	sp[1680],r9
80009a64:	87 16       	st.w	r3[0x4],r6
80009a66:	fb 48 06 8c 	st.w	sp[1676],r8
80009a6a:	58 78       	cp.w	r8,7
80009a6c:	e0 89 00 04 	brgt	80009a74 <_vfprintf_r+0x1bd0>
80009a70:	2f 83       	sub	r3,-8
80009a72:	c0 b8       	rjmp	80009a88 <_vfprintf_r+0x1be4>
80009a74:	fa ca f9 78 	sub	r10,sp,-1672
80009a78:	02 9b       	mov	r11,r1
80009a7a:	08 9c       	mov	r12,r4
80009a7c:	fe b0 f2 06 	rcall	80007e88 <__sprint_r>
80009a80:	e0 81 01 91 	brne	80009da2 <_vfprintf_r+0x1efe>
80009a84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a88:	ed b5 00 00 	bld	r5,0x0
80009a8c:	e0 81 01 20 	brne	80009ccc <_vfprintf_r+0x1e28>
80009a90:	40 c9       	lddsp	r9,sp[0x30]
80009a92:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a96:	2f f8       	sub	r8,-1
80009a98:	87 09       	st.w	r3[0x0],r9
80009a9a:	fb 48 06 90 	st.w	sp[1680],r8
80009a9e:	30 19       	mov	r9,1
80009aa0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aa4:	87 19       	st.w	r3[0x4],r9
80009aa6:	2f f8       	sub	r8,-1
80009aa8:	fb 48 06 8c 	st.w	sp[1676],r8
80009aac:	c0 29       	rjmp	80009cb0 <_vfprintf_r+0x1e0c>
80009aae:	14 09       	add	r9,r10
80009ab0:	2f f8       	sub	r8,-1
80009ab2:	fb 49 06 90 	st.w	sp[1680],r9
80009ab6:	87 06       	st.w	r3[0x0],r6
80009ab8:	87 1a       	st.w	r3[0x4],r10
80009aba:	fb 48 06 8c 	st.w	sp[1676],r8
80009abe:	58 78       	cp.w	r8,7
80009ac0:	e0 89 00 04 	brgt	80009ac8 <_vfprintf_r+0x1c24>
80009ac4:	2f 83       	sub	r3,-8
80009ac6:	c0 b8       	rjmp	80009adc <_vfprintf_r+0x1c38>
80009ac8:	fa ca f9 78 	sub	r10,sp,-1672
80009acc:	02 9b       	mov	r11,r1
80009ace:	08 9c       	mov	r12,r4
80009ad0:	fe b0 f1 dc 	rcall	80007e88 <__sprint_r>
80009ad4:	e0 81 01 67 	brne	80009da2 <_vfprintf_r+0x1efe>
80009ad8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009adc:	40 c8       	lddsp	r8,sp[0x30]
80009ade:	87 08       	st.w	r3[0x0],r8
80009ae0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ae4:	2f f8       	sub	r8,-1
80009ae6:	30 19       	mov	r9,1
80009ae8:	fb 48 06 90 	st.w	sp[1680],r8
80009aec:	87 19       	st.w	r3[0x4],r9
80009aee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009af2:	2f f8       	sub	r8,-1
80009af4:	fb 48 06 8c 	st.w	sp[1676],r8
80009af8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009afc:	58 78       	cp.w	r8,7
80009afe:	e0 89 00 04 	brgt	80009b06 <_vfprintf_r+0x1c62>
80009b02:	2f 83       	sub	r3,-8
80009b04:	c0 b8       	rjmp	80009b1a <_vfprintf_r+0x1c76>
80009b06:	fa ca f9 78 	sub	r10,sp,-1672
80009b0a:	02 9b       	mov	r11,r1
80009b0c:	08 9c       	mov	r12,r4
80009b0e:	fe b0 f1 bd 	rcall	80007e88 <__sprint_r>
80009b12:	e0 81 01 48 	brne	80009da2 <_vfprintf_r+0x1efe>
80009b16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b1a:	04 06       	add	r6,r2
80009b1c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b20:	87 06       	st.w	r3[0x0],r6
80009b22:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b26:	40 66       	lddsp	r6,sp[0x18]
80009b28:	40 6e       	lddsp	lr,sp[0x18]
80009b2a:	10 16       	sub	r6,r8
80009b2c:	f2 08 01 08 	sub	r8,r9,r8
80009b30:	87 16       	st.w	r3[0x4],r6
80009b32:	1c 08       	add	r8,lr
80009b34:	fb 48 06 90 	st.w	sp[1680],r8
80009b38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3c:	2f f8       	sub	r8,-1
80009b3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b42:	cb 78       	rjmp	80009cb0 <_vfprintf_r+0x1e0c>
80009b44:	40 6c       	lddsp	r12,sp[0x18]
80009b46:	58 1c       	cp.w	r12,1
80009b48:	e0 89 00 06 	brgt	80009b54 <_vfprintf_r+0x1cb0>
80009b4c:	ed b5 00 00 	bld	r5,0x0
80009b50:	e0 81 00 85 	brne	80009c5a <_vfprintf_r+0x1db6>
80009b54:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b58:	2f f8       	sub	r8,-1
80009b5a:	30 19       	mov	r9,1
80009b5c:	fb 48 06 90 	st.w	sp[1680],r8
80009b60:	87 06       	st.w	r3[0x0],r6
80009b62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b66:	87 19       	st.w	r3[0x4],r9
80009b68:	2f f8       	sub	r8,-1
80009b6a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b6e:	58 78       	cp.w	r8,7
80009b70:	e0 89 00 04 	brgt	80009b78 <_vfprintf_r+0x1cd4>
80009b74:	2f 83       	sub	r3,-8
80009b76:	c0 b8       	rjmp	80009b8c <_vfprintf_r+0x1ce8>
80009b78:	fa ca f9 78 	sub	r10,sp,-1672
80009b7c:	02 9b       	mov	r11,r1
80009b7e:	08 9c       	mov	r12,r4
80009b80:	fe b0 f1 84 	rcall	80007e88 <__sprint_r>
80009b84:	e0 81 01 0f 	brne	80009da2 <_vfprintf_r+0x1efe>
80009b88:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b90:	2f f8       	sub	r8,-1
80009b92:	40 cb       	lddsp	r11,sp[0x30]
80009b94:	fb 48 06 90 	st.w	sp[1680],r8
80009b98:	30 19       	mov	r9,1
80009b9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b9e:	87 0b       	st.w	r3[0x0],r11
80009ba0:	2f f8       	sub	r8,-1
80009ba2:	87 19       	st.w	r3[0x4],r9
80009ba4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ba8:	58 78       	cp.w	r8,7
80009baa:	e0 89 00 05 	brgt	80009bb4 <_vfprintf_r+0x1d10>
80009bae:	2f 83       	sub	r3,-8
80009bb0:	c0 c8       	rjmp	80009bc8 <_vfprintf_r+0x1d24>
80009bb2:	d7 03       	nop
80009bb4:	fa ca f9 78 	sub	r10,sp,-1672
80009bb8:	02 9b       	mov	r11,r1
80009bba:	08 9c       	mov	r12,r4
80009bbc:	fe b0 f1 66 	rcall	80007e88 <__sprint_r>
80009bc0:	e0 81 00 f1 	brne	80009da2 <_vfprintf_r+0x1efe>
80009bc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bc8:	30 08       	mov	r8,0
80009bca:	30 09       	mov	r9,0
80009bcc:	40 5b       	lddsp	r11,sp[0x14]
80009bce:	40 7a       	lddsp	r10,sp[0x1c]
80009bd0:	e0 a0 13 25 	rcall	8000c21a <__avr32_f64_cmp_eq>
80009bd4:	40 68       	lddsp	r8,sp[0x18]
80009bd6:	20 18       	sub	r8,1
80009bd8:	58 0c       	cp.w	r12,0
80009bda:	c0 d1       	brne	80009bf4 <_vfprintf_r+0x1d50>
80009bdc:	2f f6       	sub	r6,-1
80009bde:	87 18       	st.w	r3[0x4],r8
80009be0:	87 06       	st.w	r3[0x0],r6
80009be2:	fa f6 06 90 	ld.w	r6,sp[1680]
80009be6:	10 06       	add	r6,r8
80009be8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bec:	fb 46 06 90 	st.w	sp[1680],r6
80009bf0:	2f f8       	sub	r8,-1
80009bf2:	c3 18       	rjmp	80009c54 <_vfprintf_r+0x1db0>
80009bf4:	10 96       	mov	r6,r8
80009bf6:	58 08       	cp.w	r8,0
80009bf8:	e0 89 00 1c 	brgt	80009c30 <_vfprintf_r+0x1d8c>
80009bfc:	c4 b8       	rjmp	80009c92 <_vfprintf_r+0x1dee>
80009bfe:	2f 09       	sub	r9,-16
80009c00:	2f f8       	sub	r8,-1
80009c02:	fb 49 06 90 	st.w	sp[1680],r9
80009c06:	87 02       	st.w	r3[0x0],r2
80009c08:	87 10       	st.w	r3[0x4],r0
80009c0a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c0e:	58 78       	cp.w	r8,7
80009c10:	e0 89 00 04 	brgt	80009c18 <_vfprintf_r+0x1d74>
80009c14:	2f 83       	sub	r3,-8
80009c16:	c0 b8       	rjmp	80009c2c <_vfprintf_r+0x1d88>
80009c18:	fa ca f9 78 	sub	r10,sp,-1672
80009c1c:	02 9b       	mov	r11,r1
80009c1e:	08 9c       	mov	r12,r4
80009c20:	fe b0 f1 34 	rcall	80007e88 <__sprint_r>
80009c24:	e0 81 00 bf 	brne	80009da2 <_vfprintf_r+0x1efe>
80009c28:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c2c:	21 06       	sub	r6,16
80009c2e:	c0 48       	rjmp	80009c36 <_vfprintf_r+0x1d92>
80009c30:	fe c2 bf 94 	sub	r2,pc,-16492
80009c34:	31 00       	mov	r0,16
80009c36:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c3e:	fe ca bf a2 	sub	r10,pc,-16478
80009c42:	59 06       	cp.w	r6,16
80009c44:	fe 99 ff dd 	brgt	80009bfe <_vfprintf_r+0x1d5a>
80009c48:	0c 09       	add	r9,r6
80009c4a:	87 0a       	st.w	r3[0x0],r10
80009c4c:	fb 49 06 90 	st.w	sp[1680],r9
80009c50:	2f f8       	sub	r8,-1
80009c52:	87 16       	st.w	r3[0x4],r6
80009c54:	fb 48 06 8c 	st.w	sp[1676],r8
80009c58:	c0 e8       	rjmp	80009c74 <_vfprintf_r+0x1dd0>
80009c5a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c5e:	2f f8       	sub	r8,-1
80009c60:	30 19       	mov	r9,1
80009c62:	fb 48 06 90 	st.w	sp[1680],r8
80009c66:	87 06       	st.w	r3[0x0],r6
80009c68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c6c:	87 19       	st.w	r3[0x4],r9
80009c6e:	2f f8       	sub	r8,-1
80009c70:	fb 48 06 8c 	st.w	sp[1676],r8
80009c74:	58 78       	cp.w	r8,7
80009c76:	e0 89 00 04 	brgt	80009c7e <_vfprintf_r+0x1dda>
80009c7a:	2f 83       	sub	r3,-8
80009c7c:	c0 b8       	rjmp	80009c92 <_vfprintf_r+0x1dee>
80009c7e:	fa ca f9 78 	sub	r10,sp,-1672
80009c82:	02 9b       	mov	r11,r1
80009c84:	08 9c       	mov	r12,r4
80009c86:	fe b0 f1 01 	rcall	80007e88 <__sprint_r>
80009c8a:	e0 81 00 8c 	brne	80009da2 <_vfprintf_r+0x1efe>
80009c8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c92:	40 ea       	lddsp	r10,sp[0x38]
80009c94:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c98:	14 08       	add	r8,r10
80009c9a:	fa c9 f9 64 	sub	r9,sp,-1692
80009c9e:	fb 48 06 90 	st.w	sp[1680],r8
80009ca2:	87 1a       	st.w	r3[0x4],r10
80009ca4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ca8:	87 09       	st.w	r3[0x0],r9
80009caa:	2f f8       	sub	r8,-1
80009cac:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb0:	58 78       	cp.w	r8,7
80009cb2:	e0 89 00 04 	brgt	80009cba <_vfprintf_r+0x1e16>
80009cb6:	2f 83       	sub	r3,-8
80009cb8:	c0 a8       	rjmp	80009ccc <_vfprintf_r+0x1e28>
80009cba:	fa ca f9 78 	sub	r10,sp,-1672
80009cbe:	02 9b       	mov	r11,r1
80009cc0:	08 9c       	mov	r12,r4
80009cc2:	fe b0 f0 e3 	rcall	80007e88 <__sprint_r>
80009cc6:	c6 e1       	brne	80009da2 <_vfprintf_r+0x1efe>
80009cc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ccc:	e2 15 00 04 	andl	r5,0x4,COH
80009cd0:	c3 f0       	breq	80009d4e <_vfprintf_r+0x1eaa>
80009cd2:	40 86       	lddsp	r6,sp[0x20]
80009cd4:	40 39       	lddsp	r9,sp[0xc]
80009cd6:	12 16       	sub	r6,r9
80009cd8:	58 06       	cp.w	r6,0
80009cda:	e0 89 00 1a 	brgt	80009d0e <_vfprintf_r+0x1e6a>
80009cde:	c3 88       	rjmp	80009d4e <_vfprintf_r+0x1eaa>
80009ce0:	2f 09       	sub	r9,-16
80009ce2:	2f f8       	sub	r8,-1
80009ce4:	fb 49 06 90 	st.w	sp[1680],r9
80009ce8:	87 05       	st.w	r3[0x0],r5
80009cea:	87 12       	st.w	r3[0x4],r2
80009cec:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf0:	58 78       	cp.w	r8,7
80009cf2:	e0 89 00 04 	brgt	80009cfa <_vfprintf_r+0x1e56>
80009cf6:	2f 83       	sub	r3,-8
80009cf8:	c0 98       	rjmp	80009d0a <_vfprintf_r+0x1e66>
80009cfa:	00 9a       	mov	r10,r0
80009cfc:	02 9b       	mov	r11,r1
80009cfe:	08 9c       	mov	r12,r4
80009d00:	fe b0 f0 c4 	rcall	80007e88 <__sprint_r>
80009d04:	c4 f1       	brne	80009da2 <_vfprintf_r+0x1efe>
80009d06:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d0a:	21 06       	sub	r6,16
80009d0c:	c0 68       	rjmp	80009d18 <_vfprintf_r+0x1e74>
80009d0e:	fe c5 c0 82 	sub	r5,pc,-16254
80009d12:	31 02       	mov	r2,16
80009d14:	fa c0 f9 78 	sub	r0,sp,-1672
80009d18:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d20:	fe ca c0 94 	sub	r10,pc,-16236
80009d24:	59 06       	cp.w	r6,16
80009d26:	fe 99 ff dd 	brgt	80009ce0 <_vfprintf_r+0x1e3c>
80009d2a:	0c 09       	add	r9,r6
80009d2c:	2f f8       	sub	r8,-1
80009d2e:	87 0a       	st.w	r3[0x0],r10
80009d30:	87 16       	st.w	r3[0x4],r6
80009d32:	fb 49 06 90 	st.w	sp[1680],r9
80009d36:	fb 48 06 8c 	st.w	sp[1676],r8
80009d3a:	58 78       	cp.w	r8,7
80009d3c:	e0 8a 00 09 	brle	80009d4e <_vfprintf_r+0x1eaa>
80009d40:	fa ca f9 78 	sub	r10,sp,-1672
80009d44:	02 9b       	mov	r11,r1
80009d46:	08 9c       	mov	r12,r4
80009d48:	fe b0 f0 a0 	rcall	80007e88 <__sprint_r>
80009d4c:	c2 b1       	brne	80009da2 <_vfprintf_r+0x1efe>
80009d4e:	40 bc       	lddsp	r12,sp[0x2c]
80009d50:	40 36       	lddsp	r6,sp[0xc]
80009d52:	40 8e       	lddsp	lr,sp[0x20]
80009d54:	ec 0e 0c 48 	max	r8,r6,lr
80009d58:	10 0c       	add	r12,r8
80009d5a:	50 bc       	stdsp	sp[0x2c],r12
80009d5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d60:	58 08       	cp.w	r8,0
80009d62:	c0 80       	breq	80009d72 <_vfprintf_r+0x1ece>
80009d64:	fa ca f9 78 	sub	r10,sp,-1672
80009d68:	02 9b       	mov	r11,r1
80009d6a:	08 9c       	mov	r12,r4
80009d6c:	fe b0 f0 8e 	rcall	80007e88 <__sprint_r>
80009d70:	c1 91       	brne	80009da2 <_vfprintf_r+0x1efe>
80009d72:	30 0b       	mov	r11,0
80009d74:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d78:	fb 4b 06 8c 	st.w	sp[1676],r11
80009d7c:	fe 9f f1 22 	bral	80007fc0 <_vfprintf_r+0x11c>
80009d80:	08 95       	mov	r5,r4
80009d82:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d86:	58 08       	cp.w	r8,0
80009d88:	c0 80       	breq	80009d98 <_vfprintf_r+0x1ef4>
80009d8a:	08 9c       	mov	r12,r4
80009d8c:	fa ca f9 78 	sub	r10,sp,-1672
80009d90:	02 9b       	mov	r11,r1
80009d92:	fe b0 f0 7b 	rcall	80007e88 <__sprint_r>
80009d96:	c0 61       	brne	80009da2 <_vfprintf_r+0x1efe>
80009d98:	30 08       	mov	r8,0
80009d9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d9e:	c0 28       	rjmp	80009da2 <_vfprintf_r+0x1efe>
80009da0:	40 41       	lddsp	r1,sp[0x10]
80009da2:	82 68       	ld.sh	r8,r1[0xc]
80009da4:	ed b8 00 06 	bld	r8,0x6
80009da8:	c0 31       	brne	80009dae <_vfprintf_r+0x1f0a>
80009daa:	3f fa       	mov	r10,-1
80009dac:	50 ba       	stdsp	sp[0x2c],r10
80009dae:	40 bc       	lddsp	r12,sp[0x2c]
80009db0:	fe 3d f9 44 	sub	sp,-1724
80009db4:	d8 32       	popm	r0-r7,pc
80009db6:	d7 03       	nop

80009db8 <__swsetup_r>:
80009db8:	d4 21       	pushm	r4-r7,lr
80009dba:	e0 68 0a 38 	mov	r8,2616
80009dbe:	18 96       	mov	r6,r12
80009dc0:	16 97       	mov	r7,r11
80009dc2:	70 0c       	ld.w	r12,r8[0x0]
80009dc4:	58 0c       	cp.w	r12,0
80009dc6:	c0 60       	breq	80009dd2 <__swsetup_r+0x1a>
80009dc8:	78 68       	ld.w	r8,r12[0x18]
80009dca:	58 08       	cp.w	r8,0
80009dcc:	c0 31       	brne	80009dd2 <__swsetup_r+0x1a>
80009dce:	e0 a0 07 bf 	rcall	8000ad4c <__sinit>
80009dd2:	fe c8 c0 16 	sub	r8,pc,-16362
80009dd6:	10 37       	cp.w	r7,r8
80009dd8:	c0 61       	brne	80009de4 <__swsetup_r+0x2c>
80009dda:	e0 68 0a 38 	mov	r8,2616
80009dde:	70 08       	ld.w	r8,r8[0x0]
80009de0:	70 07       	ld.w	r7,r8[0x0]
80009de2:	c1 28       	rjmp	80009e06 <__swsetup_r+0x4e>
80009de4:	fe c8 c0 08 	sub	r8,pc,-16376
80009de8:	10 37       	cp.w	r7,r8
80009dea:	c0 61       	brne	80009df6 <__swsetup_r+0x3e>
80009dec:	e0 68 0a 38 	mov	r8,2616
80009df0:	70 08       	ld.w	r8,r8[0x0]
80009df2:	70 17       	ld.w	r7,r8[0x4]
80009df4:	c0 98       	rjmp	80009e06 <__swsetup_r+0x4e>
80009df6:	fe c8 bf fa 	sub	r8,pc,-16390
80009dfa:	10 37       	cp.w	r7,r8
80009dfc:	c0 51       	brne	80009e06 <__swsetup_r+0x4e>
80009dfe:	e0 68 0a 38 	mov	r8,2616
80009e02:	70 08       	ld.w	r8,r8[0x0]
80009e04:	70 27       	ld.w	r7,r8[0x8]
80009e06:	8e 68       	ld.sh	r8,r7[0xc]
80009e08:	ed b8 00 03 	bld	r8,0x3
80009e0c:	c1 e0       	breq	80009e48 <__swsetup_r+0x90>
80009e0e:	ed b8 00 04 	bld	r8,0x4
80009e12:	c3 e1       	brne	80009e8e <__swsetup_r+0xd6>
80009e14:	ed b8 00 02 	bld	r8,0x2
80009e18:	c1 51       	brne	80009e42 <__swsetup_r+0x8a>
80009e1a:	6e db       	ld.w	r11,r7[0x34]
80009e1c:	58 0b       	cp.w	r11,0
80009e1e:	c0 a0       	breq	80009e32 <__swsetup_r+0x7a>
80009e20:	ee c8 ff bc 	sub	r8,r7,-68
80009e24:	10 3b       	cp.w	r11,r8
80009e26:	c0 40       	breq	80009e2e <__swsetup_r+0x76>
80009e28:	0c 9c       	mov	r12,r6
80009e2a:	e0 a0 08 2b 	rcall	8000ae80 <_free_r>
80009e2e:	30 08       	mov	r8,0
80009e30:	8f d8       	st.w	r7[0x34],r8
80009e32:	8e 68       	ld.sh	r8,r7[0xc]
80009e34:	e0 18 ff db 	andl	r8,0xffdb
80009e38:	ae 68       	st.h	r7[0xc],r8
80009e3a:	30 08       	mov	r8,0
80009e3c:	8f 18       	st.w	r7[0x4],r8
80009e3e:	6e 48       	ld.w	r8,r7[0x10]
80009e40:	8f 08       	st.w	r7[0x0],r8
80009e42:	8e 68       	ld.sh	r8,r7[0xc]
80009e44:	a3 b8       	sbr	r8,0x3
80009e46:	ae 68       	st.h	r7[0xc],r8
80009e48:	6e 48       	ld.w	r8,r7[0x10]
80009e4a:	58 08       	cp.w	r8,0
80009e4c:	c0 b1       	brne	80009e62 <__swsetup_r+0xaa>
80009e4e:	8e 68       	ld.sh	r8,r7[0xc]
80009e50:	e2 18 02 80 	andl	r8,0x280,COH
80009e54:	e0 48 02 00 	cp.w	r8,512
80009e58:	c0 50       	breq	80009e62 <__swsetup_r+0xaa>
80009e5a:	0c 9c       	mov	r12,r6
80009e5c:	0e 9b       	mov	r11,r7
80009e5e:	e0 a0 0a 4b 	rcall	8000b2f4 <__smakebuf_r>
80009e62:	8e 69       	ld.sh	r9,r7[0xc]
80009e64:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009e68:	c0 70       	breq	80009e76 <__swsetup_r+0xbe>
80009e6a:	30 08       	mov	r8,0
80009e6c:	8f 28       	st.w	r7[0x8],r8
80009e6e:	6e 58       	ld.w	r8,r7[0x14]
80009e70:	5c 38       	neg	r8
80009e72:	8f 68       	st.w	r7[0x18],r8
80009e74:	c0 68       	rjmp	80009e80 <__swsetup_r+0xc8>
80009e76:	ed b9 00 01 	bld	r9,0x1
80009e7a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009e7e:	8f 28       	st.w	r7[0x8],r8
80009e80:	6e 48       	ld.w	r8,r7[0x10]
80009e82:	58 08       	cp.w	r8,0
80009e84:	c0 61       	brne	80009e90 <__swsetup_r+0xd8>
80009e86:	8e 68       	ld.sh	r8,r7[0xc]
80009e88:	ed b8 00 07 	bld	r8,0x7
80009e8c:	c0 21       	brne	80009e90 <__swsetup_r+0xd8>
80009e8e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009e90:	d8 2a       	popm	r4-r7,pc,r12=0
80009e92:	d7 03       	nop

80009e94 <quorem>:
80009e94:	d4 31       	pushm	r0-r7,lr
80009e96:	20 2d       	sub	sp,8
80009e98:	18 97       	mov	r7,r12
80009e9a:	78 48       	ld.w	r8,r12[0x10]
80009e9c:	76 46       	ld.w	r6,r11[0x10]
80009e9e:	0c 38       	cp.w	r8,r6
80009ea0:	c0 34       	brge	80009ea6 <quorem+0x12>
80009ea2:	30 0c       	mov	r12,0
80009ea4:	c8 58       	rjmp	80009fae <quorem+0x11a>
80009ea6:	ec c2 ff fc 	sub	r2,r6,-4
80009eaa:	f6 c3 ff ec 	sub	r3,r11,-20
80009eae:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009eb2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009eb6:	2f f9       	sub	r9,-1
80009eb8:	20 16       	sub	r6,1
80009eba:	f8 09 0d 08 	divu	r8,r12,r9
80009ebe:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009ec2:	ee c4 ff ec 	sub	r4,r7,-20
80009ec6:	10 95       	mov	r5,r8
80009ec8:	58 08       	cp.w	r8,0
80009eca:	c4 10       	breq	80009f4c <quorem+0xb8>
80009ecc:	30 09       	mov	r9,0
80009ece:	06 9a       	mov	r10,r3
80009ed0:	08 98       	mov	r8,r4
80009ed2:	12 91       	mov	r1,r9
80009ed4:	50 0b       	stdsp	sp[0x0],r11
80009ed6:	70 0e       	ld.w	lr,r8[0x0]
80009ed8:	b1 8e       	lsr	lr,0x10
80009eda:	50 1e       	stdsp	sp[0x4],lr
80009edc:	15 0e       	ld.w	lr,r10++
80009ede:	fc 00 16 10 	lsr	r0,lr,0x10
80009ee2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009ee6:	ea 0e 03 41 	mac	r1,r5,lr
80009eea:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009eee:	b1 81       	lsr	r1,0x10
80009ef0:	40 1b       	lddsp	r11,sp[0x4]
80009ef2:	ea 00 02 40 	mul	r0,r5,r0
80009ef6:	e2 00 00 00 	add	r0,r1,r0
80009efa:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009efe:	02 1b       	sub	r11,r1
80009f00:	50 1b       	stdsp	sp[0x4],r11
80009f02:	70 0b       	ld.w	r11,r8[0x0]
80009f04:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009f08:	02 09       	add	r9,r1
80009f0a:	f2 0e 01 0e 	sub	lr,r9,lr
80009f0e:	b0 1e       	st.h	r8[0x2],lr
80009f10:	fc 09 14 10 	asr	r9,lr,0x10
80009f14:	40 1e       	lddsp	lr,sp[0x4]
80009f16:	fc 09 00 09 	add	r9,lr,r9
80009f1a:	b0 09       	st.h	r8[0x0],r9
80009f1c:	e0 01 16 10 	lsr	r1,r0,0x10
80009f20:	2f c8       	sub	r8,-4
80009f22:	b1 49       	asr	r9,0x10
80009f24:	04 3a       	cp.w	r10,r2
80009f26:	fe 98 ff d8 	brls	80009ed6 <quorem+0x42>
80009f2a:	40 0b       	lddsp	r11,sp[0x0]
80009f2c:	58 0c       	cp.w	r12,0
80009f2e:	c0 f1       	brne	80009f4c <quorem+0xb8>
80009f30:	ec c8 ff fb 	sub	r8,r6,-5
80009f34:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f38:	c0 28       	rjmp	80009f3c <quorem+0xa8>
80009f3a:	20 16       	sub	r6,1
80009f3c:	20 48       	sub	r8,4
80009f3e:	08 38       	cp.w	r8,r4
80009f40:	e0 88 00 05 	brls	80009f4a <quorem+0xb6>
80009f44:	70 09       	ld.w	r9,r8[0x0]
80009f46:	58 09       	cp.w	r9,0
80009f48:	cf 90       	breq	80009f3a <quorem+0xa6>
80009f4a:	8f 46       	st.w	r7[0x10],r6
80009f4c:	0e 9c       	mov	r12,r7
80009f4e:	e0 a0 0a d2 	rcall	8000b4f2 <__mcmp>
80009f52:	c2 d5       	brlt	80009fac <quorem+0x118>
80009f54:	2f f5       	sub	r5,-1
80009f56:	08 98       	mov	r8,r4
80009f58:	30 09       	mov	r9,0
80009f5a:	07 0b       	ld.w	r11,r3++
80009f5c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009f60:	70 0c       	ld.w	r12,r8[0x0]
80009f62:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009f66:	f8 0e 16 10 	lsr	lr,r12,0x10
80009f6a:	14 1e       	sub	lr,r10
80009f6c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009f70:	16 1a       	sub	r10,r11
80009f72:	12 0a       	add	r10,r9
80009f74:	b0 1a       	st.h	r8[0x2],r10
80009f76:	b1 4a       	asr	r10,0x10
80009f78:	fc 0a 00 09 	add	r9,lr,r10
80009f7c:	b0 09       	st.h	r8[0x0],r9
80009f7e:	2f c8       	sub	r8,-4
80009f80:	b1 49       	asr	r9,0x10
80009f82:	04 33       	cp.w	r3,r2
80009f84:	fe 98 ff eb 	brls	80009f5a <quorem+0xc6>
80009f88:	ec c8 ff fb 	sub	r8,r6,-5
80009f8c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009f90:	58 09       	cp.w	r9,0
80009f92:	c0 d1       	brne	80009fac <quorem+0x118>
80009f94:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f98:	c0 28       	rjmp	80009f9c <quorem+0x108>
80009f9a:	20 16       	sub	r6,1
80009f9c:	20 48       	sub	r8,4
80009f9e:	08 38       	cp.w	r8,r4
80009fa0:	e0 88 00 05 	brls	80009faa <quorem+0x116>
80009fa4:	70 09       	ld.w	r9,r8[0x0]
80009fa6:	58 09       	cp.w	r9,0
80009fa8:	cf 90       	breq	80009f9a <quorem+0x106>
80009faa:	8f 46       	st.w	r7[0x10],r6
80009fac:	0a 9c       	mov	r12,r5
80009fae:	2f ed       	sub	sp,-8
80009fb0:	d8 32       	popm	r0-r7,pc
80009fb2:	d7 03       	nop

80009fb4 <_dtoa_r>:
80009fb4:	d4 31       	pushm	r0-r7,lr
80009fb6:	21 ad       	sub	sp,104
80009fb8:	fa c4 ff 74 	sub	r4,sp,-140
80009fbc:	18 97       	mov	r7,r12
80009fbe:	16 95       	mov	r5,r11
80009fc0:	68 2c       	ld.w	r12,r4[0x8]
80009fc2:	50 c9       	stdsp	sp[0x30],r9
80009fc4:	68 16       	ld.w	r6,r4[0x4]
80009fc6:	68 09       	ld.w	r9,r4[0x0]
80009fc8:	50 e8       	stdsp	sp[0x38],r8
80009fca:	14 94       	mov	r4,r10
80009fcc:	51 2c       	stdsp	sp[0x48],r12
80009fce:	fa e5 00 08 	st.d	sp[8],r4
80009fd2:	51 59       	stdsp	sp[0x54],r9
80009fd4:	6e 95       	ld.w	r5,r7[0x24]
80009fd6:	58 05       	cp.w	r5,0
80009fd8:	c0 91       	brne	80009fea <_dtoa_r+0x36>
80009fda:	31 0c       	mov	r12,16
80009fdc:	fe b0 e8 f4 	rcall	800071c4 <malloc>
80009fe0:	99 35       	st.w	r12[0xc],r5
80009fe2:	8f 9c       	st.w	r7[0x24],r12
80009fe4:	99 15       	st.w	r12[0x4],r5
80009fe6:	99 25       	st.w	r12[0x8],r5
80009fe8:	99 05       	st.w	r12[0x0],r5
80009fea:	6e 99       	ld.w	r9,r7[0x24]
80009fec:	72 08       	ld.w	r8,r9[0x0]
80009fee:	58 08       	cp.w	r8,0
80009ff0:	c0 f0       	breq	8000a00e <_dtoa_r+0x5a>
80009ff2:	72 1a       	ld.w	r10,r9[0x4]
80009ff4:	91 1a       	st.w	r8[0x4],r10
80009ff6:	30 1a       	mov	r10,1
80009ff8:	72 19       	ld.w	r9,r9[0x4]
80009ffa:	f4 09 09 49 	lsl	r9,r10,r9
80009ffe:	10 9b       	mov	r11,r8
8000a000:	91 29       	st.w	r8[0x8],r9
8000a002:	0e 9c       	mov	r12,r7
8000a004:	e0 a0 0a 90 	rcall	8000b524 <_Bfree>
8000a008:	6e 98       	ld.w	r8,r7[0x24]
8000a00a:	30 09       	mov	r9,0
8000a00c:	91 09       	st.w	r8[0x0],r9
8000a00e:	40 28       	lddsp	r8,sp[0x8]
8000a010:	10 94       	mov	r4,r8
8000a012:	58 08       	cp.w	r8,0
8000a014:	c0 64       	brge	8000a020 <_dtoa_r+0x6c>
8000a016:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a01a:	50 28       	stdsp	sp[0x8],r8
8000a01c:	30 18       	mov	r8,1
8000a01e:	c0 28       	rjmp	8000a022 <_dtoa_r+0x6e>
8000a020:	30 08       	mov	r8,0
8000a022:	8d 08       	st.w	r6[0x0],r8
8000a024:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a028:	40 26       	lddsp	r6,sp[0x8]
8000a02a:	0c 98       	mov	r8,r6
8000a02c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a030:	18 38       	cp.w	r8,r12
8000a032:	c2 01       	brne	8000a072 <_dtoa_r+0xbe>
8000a034:	e0 68 27 0f 	mov	r8,9999
8000a038:	41 5b       	lddsp	r11,sp[0x54]
8000a03a:	97 08       	st.w	r11[0x0],r8
8000a03c:	40 3a       	lddsp	r10,sp[0xc]
8000a03e:	58 0a       	cp.w	r10,0
8000a040:	c0 71       	brne	8000a04e <_dtoa_r+0x9a>
8000a042:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a046:	c0 41       	brne	8000a04e <_dtoa_r+0x9a>
8000a048:	fe cc c2 9c 	sub	r12,pc,-15716
8000a04c:	c0 38       	rjmp	8000a052 <_dtoa_r+0x9e>
8000a04e:	fe cc c2 96 	sub	r12,pc,-15722
8000a052:	41 29       	lddsp	r9,sp[0x48]
8000a054:	58 09       	cp.w	r9,0
8000a056:	e0 80 05 9a 	breq	8000ab8a <_dtoa_r+0xbd6>
8000a05a:	f8 c8 ff fd 	sub	r8,r12,-3
8000a05e:	f8 c9 ff f8 	sub	r9,r12,-8
8000a062:	11 8b       	ld.ub	r11,r8[0x0]
8000a064:	30 0a       	mov	r10,0
8000a066:	41 25       	lddsp	r5,sp[0x48]
8000a068:	f4 0b 18 00 	cp.b	r11,r10
8000a06c:	f2 08 17 10 	movne	r8,r9
8000a070:	c1 68       	rjmp	8000a09c <_dtoa_r+0xe8>
8000a072:	fa ea 00 08 	ld.d	r10,sp[8]
8000a076:	30 08       	mov	r8,0
8000a078:	fa eb 00 3c 	st.d	sp[60],r10
8000a07c:	30 09       	mov	r9,0
8000a07e:	e0 a0 10 ce 	rcall	8000c21a <__avr32_f64_cmp_eq>
8000a082:	c1 00       	breq	8000a0a2 <_dtoa_r+0xee>
8000a084:	30 18       	mov	r8,1
8000a086:	41 5a       	lddsp	r10,sp[0x54]
8000a088:	95 08       	st.w	r10[0x0],r8
8000a08a:	fe cc c4 02 	sub	r12,pc,-15358
8000a08e:	41 29       	lddsp	r9,sp[0x48]
8000a090:	f8 08 00 08 	add	r8,r12,r8
8000a094:	58 09       	cp.w	r9,0
8000a096:	e0 80 05 7a 	breq	8000ab8a <_dtoa_r+0xbd6>
8000a09a:	12 95       	mov	r5,r9
8000a09c:	8b 08       	st.w	r5[0x0],r8
8000a09e:	e0 8f 05 76 	bral	8000ab8a <_dtoa_r+0xbd6>
8000a0a2:	fa c8 ff 9c 	sub	r8,sp,-100
8000a0a6:	fa c9 ff a0 	sub	r9,sp,-96
8000a0aa:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0ae:	0e 9c       	mov	r12,r7
8000a0b0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a0b4:	e0 a0 0a 8a 	rcall	8000b5c8 <__d2b>
8000a0b8:	18 93       	mov	r3,r12
8000a0ba:	58 05       	cp.w	r5,0
8000a0bc:	c0 d0       	breq	8000a0d6 <_dtoa_r+0x122>
8000a0be:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0c2:	30 04       	mov	r4,0
8000a0c4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a0c8:	ea c5 03 ff 	sub	r5,r5,1023
8000a0cc:	10 9b       	mov	r11,r8
8000a0ce:	51 74       	stdsp	sp[0x5c],r4
8000a0d0:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a0d4:	c2 58       	rjmp	8000a11e <_dtoa_r+0x16a>
8000a0d6:	41 88       	lddsp	r8,sp[0x60]
8000a0d8:	41 9c       	lddsp	r12,sp[0x64]
8000a0da:	10 0c       	add	r12,r8
8000a0dc:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a0e0:	e0 45 00 20 	cp.w	r5,32
8000a0e4:	e0 8a 00 0e 	brle	8000a100 <_dtoa_r+0x14c>
8000a0e8:	f8 cc fb ee 	sub	r12,r12,-1042
8000a0ec:	40 3b       	lddsp	r11,sp[0xc]
8000a0ee:	ea 08 11 40 	rsub	r8,r5,64
8000a0f2:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a0f6:	ec 08 09 46 	lsl	r6,r6,r8
8000a0fa:	0c 4c       	or	r12,r6
8000a0fc:	c0 78       	rjmp	8000a10a <_dtoa_r+0x156>
8000a0fe:	d7 03       	nop
8000a100:	ea 0c 11 20 	rsub	r12,r5,32
8000a104:	40 3a       	lddsp	r10,sp[0xc]
8000a106:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a10a:	e0 a0 10 14 	rcall	8000c132 <__avr32_u32_to_f64>
8000a10e:	fc 18 fe 10 	movh	r8,0xfe10
8000a112:	30 19       	mov	r9,1
8000a114:	ea c5 04 33 	sub	r5,r5,1075
8000a118:	f0 0b 00 0b 	add	r11,r8,r11
8000a11c:	51 79       	stdsp	sp[0x5c],r9
8000a11e:	30 08       	mov	r8,0
8000a120:	fc 19 3f f8 	movh	r9,0x3ff8
8000a124:	e0 a0 0e 9c 	rcall	8000be5c <__avr32_f64_sub>
8000a128:	e0 68 43 61 	mov	r8,17249
8000a12c:	ea 18 63 6f 	orh	r8,0x636f
8000a130:	e0 69 87 a7 	mov	r9,34727
8000a134:	ea 19 3f d2 	orh	r9,0x3fd2
8000a138:	e0 a0 0d a6 	rcall	8000bc84 <__avr32_f64_mul>
8000a13c:	e0 68 c8 b3 	mov	r8,51379
8000a140:	ea 18 8b 60 	orh	r8,0x8b60
8000a144:	e0 69 8a 28 	mov	r9,35368
8000a148:	ea 19 3f c6 	orh	r9,0x3fc6
8000a14c:	e0 a0 0f 56 	rcall	8000bff8 <__avr32_f64_add>
8000a150:	0a 9c       	mov	r12,r5
8000a152:	14 90       	mov	r0,r10
8000a154:	16 91       	mov	r1,r11
8000a156:	e0 a0 0f f2 	rcall	8000c13a <__avr32_s32_to_f64>
8000a15a:	e0 68 79 fb 	mov	r8,31227
8000a15e:	ea 18 50 9f 	orh	r8,0x509f
8000a162:	e0 69 44 13 	mov	r9,17427
8000a166:	ea 19 3f d3 	orh	r9,0x3fd3
8000a16a:	e0 a0 0d 8d 	rcall	8000bc84 <__avr32_f64_mul>
8000a16e:	14 98       	mov	r8,r10
8000a170:	16 99       	mov	r9,r11
8000a172:	00 9a       	mov	r10,r0
8000a174:	02 9b       	mov	r11,r1
8000a176:	e0 a0 0f 41 	rcall	8000bff8 <__avr32_f64_add>
8000a17a:	14 90       	mov	r0,r10
8000a17c:	16 91       	mov	r1,r11
8000a17e:	e0 a0 0f c7 	rcall	8000c10c <__avr32_f64_to_s32>
8000a182:	30 08       	mov	r8,0
8000a184:	18 96       	mov	r6,r12
8000a186:	30 09       	mov	r9,0
8000a188:	00 9a       	mov	r10,r0
8000a18a:	02 9b       	mov	r11,r1
8000a18c:	e0 a0 10 8e 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a190:	c0 c0       	breq	8000a1a8 <_dtoa_r+0x1f4>
8000a192:	0c 9c       	mov	r12,r6
8000a194:	e0 a0 0f d3 	rcall	8000c13a <__avr32_s32_to_f64>
8000a198:	14 98       	mov	r8,r10
8000a19a:	16 99       	mov	r9,r11
8000a19c:	00 9a       	mov	r10,r0
8000a19e:	02 9b       	mov	r11,r1
8000a1a0:	e0 a0 10 3d 	rcall	8000c21a <__avr32_f64_cmp_eq>
8000a1a4:	f7 b6 00 01 	subeq	r6,1
8000a1a8:	59 66       	cp.w	r6,22
8000a1aa:	e0 88 00 05 	brls	8000a1b4 <_dtoa_r+0x200>
8000a1ae:	30 18       	mov	r8,1
8000a1b0:	51 48       	stdsp	sp[0x50],r8
8000a1b2:	c1 38       	rjmp	8000a1d8 <_dtoa_r+0x224>
8000a1b4:	fe c8 c3 48 	sub	r8,pc,-15544
8000a1b8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1bc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a1c0:	e0 a0 10 74 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a1c4:	f9 b4 00 00 	moveq	r4,0
8000a1c8:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a1cc:	f7 b6 01 01 	subne	r6,1
8000a1d0:	f9 bc 01 00 	movne	r12,0
8000a1d4:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a1d8:	41 90       	lddsp	r0,sp[0x64]
8000a1da:	20 10       	sub	r0,1
8000a1dc:	0a 10       	sub	r0,r5
8000a1de:	c0 46       	brmi	8000a1e6 <_dtoa_r+0x232>
8000a1e0:	50 40       	stdsp	sp[0x10],r0
8000a1e2:	30 00       	mov	r0,0
8000a1e4:	c0 48       	rjmp	8000a1ec <_dtoa_r+0x238>
8000a1e6:	30 0b       	mov	r11,0
8000a1e8:	5c 30       	neg	r0
8000a1ea:	50 4b       	stdsp	sp[0x10],r11
8000a1ec:	ec 02 11 00 	rsub	r2,r6,0
8000a1f0:	58 06       	cp.w	r6,0
8000a1f2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a1f6:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a1fa:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a1fe:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a202:	f9 b2 04 00 	movge	r2,0
8000a206:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a20a:	f9 b9 05 00 	movlt	r9,0
8000a20e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a212:	40 c8       	lddsp	r8,sp[0x30]
8000a214:	58 98       	cp.w	r8,9
8000a216:	e0 8b 00 20 	brhi	8000a256 <_dtoa_r+0x2a2>
8000a21a:	58 58       	cp.w	r8,5
8000a21c:	f9 b4 0a 01 	movle	r4,1
8000a220:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a224:	f7 b5 09 04 	subgt	r5,4
8000a228:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a22c:	f9 b4 09 00 	movgt	r4,0
8000a230:	40 cc       	lddsp	r12,sp[0x30]
8000a232:	58 3c       	cp.w	r12,3
8000a234:	c2 d0       	breq	8000a28e <_dtoa_r+0x2da>
8000a236:	e0 89 00 05 	brgt	8000a240 <_dtoa_r+0x28c>
8000a23a:	58 2c       	cp.w	r12,2
8000a23c:	c1 01       	brne	8000a25c <_dtoa_r+0x2a8>
8000a23e:	c1 88       	rjmp	8000a26e <_dtoa_r+0x2ba>
8000a240:	40 cb       	lddsp	r11,sp[0x30]
8000a242:	58 4b       	cp.w	r11,4
8000a244:	c0 60       	breq	8000a250 <_dtoa_r+0x29c>
8000a246:	58 5b       	cp.w	r11,5
8000a248:	c0 a1       	brne	8000a25c <_dtoa_r+0x2a8>
8000a24a:	30 1a       	mov	r10,1
8000a24c:	50 da       	stdsp	sp[0x34],r10
8000a24e:	c2 28       	rjmp	8000a292 <_dtoa_r+0x2de>
8000a250:	30 19       	mov	r9,1
8000a252:	50 d9       	stdsp	sp[0x34],r9
8000a254:	c0 f8       	rjmp	8000a272 <_dtoa_r+0x2be>
8000a256:	30 08       	mov	r8,0
8000a258:	30 14       	mov	r4,1
8000a25a:	50 c8       	stdsp	sp[0x30],r8
8000a25c:	3f f5       	mov	r5,-1
8000a25e:	30 1c       	mov	r12,1
8000a260:	30 0b       	mov	r11,0
8000a262:	50 95       	stdsp	sp[0x24],r5
8000a264:	50 dc       	stdsp	sp[0x34],r12
8000a266:	0a 91       	mov	r1,r5
8000a268:	31 28       	mov	r8,18
8000a26a:	50 eb       	stdsp	sp[0x38],r11
8000a26c:	c2 08       	rjmp	8000a2ac <_dtoa_r+0x2f8>
8000a26e:	30 0a       	mov	r10,0
8000a270:	50 da       	stdsp	sp[0x34],r10
8000a272:	40 e9       	lddsp	r9,sp[0x38]
8000a274:	58 09       	cp.w	r9,0
8000a276:	e0 89 00 07 	brgt	8000a284 <_dtoa_r+0x2d0>
8000a27a:	30 18       	mov	r8,1
8000a27c:	50 98       	stdsp	sp[0x24],r8
8000a27e:	10 91       	mov	r1,r8
8000a280:	50 e8       	stdsp	sp[0x38],r8
8000a282:	c1 58       	rjmp	8000a2ac <_dtoa_r+0x2f8>
8000a284:	40 e5       	lddsp	r5,sp[0x38]
8000a286:	50 95       	stdsp	sp[0x24],r5
8000a288:	0a 91       	mov	r1,r5
8000a28a:	0a 98       	mov	r8,r5
8000a28c:	c1 08       	rjmp	8000a2ac <_dtoa_r+0x2f8>
8000a28e:	30 0c       	mov	r12,0
8000a290:	50 dc       	stdsp	sp[0x34],r12
8000a292:	40 eb       	lddsp	r11,sp[0x38]
8000a294:	ec 0b 00 0b 	add	r11,r6,r11
8000a298:	50 9b       	stdsp	sp[0x24],r11
8000a29a:	16 98       	mov	r8,r11
8000a29c:	2f f8       	sub	r8,-1
8000a29e:	58 08       	cp.w	r8,0
8000a2a0:	e0 89 00 05 	brgt	8000a2aa <_dtoa_r+0x2f6>
8000a2a4:	10 91       	mov	r1,r8
8000a2a6:	30 18       	mov	r8,1
8000a2a8:	c0 28       	rjmp	8000a2ac <_dtoa_r+0x2f8>
8000a2aa:	10 91       	mov	r1,r8
8000a2ac:	30 09       	mov	r9,0
8000a2ae:	6e 9a       	ld.w	r10,r7[0x24]
8000a2b0:	95 19       	st.w	r10[0x4],r9
8000a2b2:	30 49       	mov	r9,4
8000a2b4:	c0 68       	rjmp	8000a2c0 <_dtoa_r+0x30c>
8000a2b6:	d7 03       	nop
8000a2b8:	6a 1a       	ld.w	r10,r5[0x4]
8000a2ba:	a1 79       	lsl	r9,0x1
8000a2bc:	2f fa       	sub	r10,-1
8000a2be:	8b 1a       	st.w	r5[0x4],r10
8000a2c0:	6e 95       	ld.w	r5,r7[0x24]
8000a2c2:	f2 ca ff ec 	sub	r10,r9,-20
8000a2c6:	10 3a       	cp.w	r10,r8
8000a2c8:	fe 98 ff f8 	brls	8000a2b8 <_dtoa_r+0x304>
8000a2cc:	6a 1b       	ld.w	r11,r5[0x4]
8000a2ce:	0e 9c       	mov	r12,r7
8000a2d0:	e0 a0 09 44 	rcall	8000b558 <_Balloc>
8000a2d4:	58 e1       	cp.w	r1,14
8000a2d6:	5f 88       	srls	r8
8000a2d8:	8b 0c       	st.w	r5[0x0],r12
8000a2da:	f1 e4 00 04 	and	r4,r8,r4
8000a2de:	6e 98       	ld.w	r8,r7[0x24]
8000a2e0:	70 08       	ld.w	r8,r8[0x0]
8000a2e2:	50 88       	stdsp	sp[0x20],r8
8000a2e4:	e0 80 01 82 	breq	8000a5e8 <_dtoa_r+0x634>
8000a2e8:	58 06       	cp.w	r6,0
8000a2ea:	e0 8a 00 43 	brle	8000a370 <_dtoa_r+0x3bc>
8000a2ee:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a2f2:	fe c8 c4 86 	sub	r8,pc,-15226
8000a2f6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a2fa:	fa e5 00 18 	st.d	sp[24],r4
8000a2fe:	ec 04 14 04 	asr	r4,r6,0x4
8000a302:	ed b4 00 04 	bld	r4,0x4
8000a306:	c0 30       	breq	8000a30c <_dtoa_r+0x358>
8000a308:	30 25       	mov	r5,2
8000a30a:	c1 08       	rjmp	8000a32a <_dtoa_r+0x376>
8000a30c:	fe c8 c3 d8 	sub	r8,pc,-15400
8000a310:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a314:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a318:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a31c:	e0 a0 0f fa 	rcall	8000c310 <__avr32_f64_div>
8000a320:	30 35       	mov	r5,3
8000a322:	14 98       	mov	r8,r10
8000a324:	16 99       	mov	r9,r11
8000a326:	fa e9 00 08 	st.d	sp[8],r8
8000a32a:	fe cc c3 f6 	sub	r12,pc,-15370
8000a32e:	50 a3       	stdsp	sp[0x28],r3
8000a330:	0c 93       	mov	r3,r6
8000a332:	18 96       	mov	r6,r12
8000a334:	c0 f8       	rjmp	8000a352 <_dtoa_r+0x39e>
8000a336:	fa ea 00 18 	ld.d	r10,sp[24]
8000a33a:	ed b4 00 00 	bld	r4,0x0
8000a33e:	c0 81       	brne	8000a34e <_dtoa_r+0x39a>
8000a340:	ec e8 00 00 	ld.d	r8,r6[0]
8000a344:	2f f5       	sub	r5,-1
8000a346:	e0 a0 0c 9f 	rcall	8000bc84 <__avr32_f64_mul>
8000a34a:	fa eb 00 18 	st.d	sp[24],r10
8000a34e:	a1 54       	asr	r4,0x1
8000a350:	2f 86       	sub	r6,-8
8000a352:	58 04       	cp.w	r4,0
8000a354:	cf 11       	brne	8000a336 <_dtoa_r+0x382>
8000a356:	fa e8 00 18 	ld.d	r8,sp[24]
8000a35a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a35e:	06 96       	mov	r6,r3
8000a360:	e0 a0 0f d8 	rcall	8000c310 <__avr32_f64_div>
8000a364:	40 a3       	lddsp	r3,sp[0x28]
8000a366:	14 98       	mov	r8,r10
8000a368:	16 99       	mov	r9,r11
8000a36a:	fa e9 00 08 	st.d	sp[8],r8
8000a36e:	c2 f8       	rjmp	8000a3cc <_dtoa_r+0x418>
8000a370:	ec 08 11 00 	rsub	r8,r6,0
8000a374:	c0 31       	brne	8000a37a <_dtoa_r+0x3c6>
8000a376:	30 25       	mov	r5,2
8000a378:	c2 a8       	rjmp	8000a3cc <_dtoa_r+0x418>
8000a37a:	fe cc c4 46 	sub	r12,pc,-15290
8000a37e:	f0 04 14 04 	asr	r4,r8,0x4
8000a382:	50 1c       	stdsp	sp[0x4],r12
8000a384:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a388:	fe c9 c5 1c 	sub	r9,pc,-15076
8000a38c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a390:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a394:	e0 a0 0c 78 	rcall	8000bc84 <__avr32_f64_mul>
8000a398:	40 1c       	lddsp	r12,sp[0x4]
8000a39a:	50 63       	stdsp	sp[0x18],r3
8000a39c:	30 25       	mov	r5,2
8000a39e:	0c 93       	mov	r3,r6
8000a3a0:	fa eb 00 08 	st.d	sp[8],r10
8000a3a4:	18 96       	mov	r6,r12
8000a3a6:	c0 f8       	rjmp	8000a3c4 <_dtoa_r+0x410>
8000a3a8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3ac:	ed b4 00 00 	bld	r4,0x0
8000a3b0:	c0 81       	brne	8000a3c0 <_dtoa_r+0x40c>
8000a3b2:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3b6:	2f f5       	sub	r5,-1
8000a3b8:	e0 a0 0c 66 	rcall	8000bc84 <__avr32_f64_mul>
8000a3bc:	fa eb 00 08 	st.d	sp[8],r10
8000a3c0:	a1 54       	asr	r4,0x1
8000a3c2:	2f 86       	sub	r6,-8
8000a3c4:	58 04       	cp.w	r4,0
8000a3c6:	cf 11       	brne	8000a3a8 <_dtoa_r+0x3f4>
8000a3c8:	06 96       	mov	r6,r3
8000a3ca:	40 63       	lddsp	r3,sp[0x18]
8000a3cc:	41 4a       	lddsp	r10,sp[0x50]
8000a3ce:	58 0a       	cp.w	r10,0
8000a3d0:	c2 a0       	breq	8000a424 <_dtoa_r+0x470>
8000a3d2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3d6:	58 01       	cp.w	r1,0
8000a3d8:	5f 94       	srgt	r4
8000a3da:	fa e9 00 18 	st.d	sp[24],r8
8000a3de:	30 08       	mov	r8,0
8000a3e0:	fc 19 3f f0 	movh	r9,0x3ff0
8000a3e4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3e8:	e0 a0 0f 60 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a3ec:	f9 bc 00 00 	moveq	r12,0
8000a3f0:	f9 bc 01 01 	movne	r12,1
8000a3f4:	e9 ec 00 0c 	and	r12,r4,r12
8000a3f8:	c1 60       	breq	8000a424 <_dtoa_r+0x470>
8000a3fa:	40 98       	lddsp	r8,sp[0x24]
8000a3fc:	58 08       	cp.w	r8,0
8000a3fe:	e0 8a 00 f1 	brle	8000a5e0 <_dtoa_r+0x62c>
8000a402:	30 08       	mov	r8,0
8000a404:	fc 19 40 24 	movh	r9,0x4024
8000a408:	ec c4 00 01 	sub	r4,r6,1
8000a40c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a410:	2f f5       	sub	r5,-1
8000a412:	50 64       	stdsp	sp[0x18],r4
8000a414:	e0 a0 0c 38 	rcall	8000bc84 <__avr32_f64_mul>
8000a418:	40 94       	lddsp	r4,sp[0x24]
8000a41a:	14 98       	mov	r8,r10
8000a41c:	16 99       	mov	r9,r11
8000a41e:	fa e9 00 08 	st.d	sp[8],r8
8000a422:	c0 38       	rjmp	8000a428 <_dtoa_r+0x474>
8000a424:	50 66       	stdsp	sp[0x18],r6
8000a426:	02 94       	mov	r4,r1
8000a428:	0a 9c       	mov	r12,r5
8000a42a:	e0 a0 0e 88 	rcall	8000c13a <__avr32_s32_to_f64>
8000a42e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a432:	e0 a0 0c 29 	rcall	8000bc84 <__avr32_f64_mul>
8000a436:	30 08       	mov	r8,0
8000a438:	fc 19 40 1c 	movh	r9,0x401c
8000a43c:	e0 a0 0d de 	rcall	8000bff8 <__avr32_f64_add>
8000a440:	14 98       	mov	r8,r10
8000a442:	16 99       	mov	r9,r11
8000a444:	fa e9 00 28 	st.d	sp[40],r8
8000a448:	fc 18 fc c0 	movh	r8,0xfcc0
8000a44c:	40 a5       	lddsp	r5,sp[0x28]
8000a44e:	10 05       	add	r5,r8
8000a450:	50 a5       	stdsp	sp[0x28],r5
8000a452:	58 04       	cp.w	r4,0
8000a454:	c2 11       	brne	8000a496 <_dtoa_r+0x4e2>
8000a456:	fa ea 00 08 	ld.d	r10,sp[8]
8000a45a:	30 08       	mov	r8,0
8000a45c:	fc 19 40 14 	movh	r9,0x4014
8000a460:	e0 a0 0c fe 	rcall	8000be5c <__avr32_f64_sub>
8000a464:	40 bc       	lddsp	r12,sp[0x2c]
8000a466:	fa eb 00 08 	st.d	sp[8],r10
8000a46a:	14 98       	mov	r8,r10
8000a46c:	16 99       	mov	r9,r11
8000a46e:	18 9a       	mov	r10,r12
8000a470:	0a 9b       	mov	r11,r5
8000a472:	e0 a0 0f 1b 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a476:	e0 81 02 54 	brne	8000a91e <_dtoa_r+0x96a>
8000a47a:	0a 98       	mov	r8,r5
8000a47c:	40 b9       	lddsp	r9,sp[0x2c]
8000a47e:	ee 18 80 00 	eorh	r8,0x8000
8000a482:	fa ea 00 08 	ld.d	r10,sp[8]
8000a486:	10 95       	mov	r5,r8
8000a488:	12 98       	mov	r8,r9
8000a48a:	0a 99       	mov	r9,r5
8000a48c:	e0 a0 0f 0e 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a490:	e0 81 02 3e 	brne	8000a90c <_dtoa_r+0x958>
8000a494:	ca 68       	rjmp	8000a5e0 <_dtoa_r+0x62c>
8000a496:	fe c9 c6 2a 	sub	r9,pc,-14806
8000a49a:	e8 c8 00 01 	sub	r8,r4,1
8000a49e:	40 d5       	lddsp	r5,sp[0x34]
8000a4a0:	58 05       	cp.w	r5,0
8000a4a2:	c4 f0       	breq	8000a540 <_dtoa_r+0x58c>
8000a4a4:	30 0c       	mov	r12,0
8000a4a6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a4aa:	51 3c       	stdsp	sp[0x4c],r12
8000a4ac:	30 0a       	mov	r10,0
8000a4ae:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a4b2:	e0 a0 0f 2f 	rcall	8000c310 <__avr32_f64_div>
8000a4b6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4ba:	40 85       	lddsp	r5,sp[0x20]
8000a4bc:	e0 a0 0c d0 	rcall	8000be5c <__avr32_f64_sub>
8000a4c0:	fa eb 00 28 	st.d	sp[40],r10
8000a4c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4c8:	e0 a0 0e 22 	rcall	8000c10c <__avr32_f64_to_s32>
8000a4cc:	51 6c       	stdsp	sp[0x58],r12
8000a4ce:	e0 a0 0e 36 	rcall	8000c13a <__avr32_s32_to_f64>
8000a4d2:	14 98       	mov	r8,r10
8000a4d4:	16 99       	mov	r9,r11
8000a4d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4da:	e0 a0 0c c1 	rcall	8000be5c <__avr32_f64_sub>
8000a4de:	fa eb 00 08 	st.d	sp[8],r10
8000a4e2:	41 68       	lddsp	r8,sp[0x58]
8000a4e4:	2d 08       	sub	r8,-48
8000a4e6:	0a c8       	st.b	r5++,r8
8000a4e8:	41 39       	lddsp	r9,sp[0x4c]
8000a4ea:	2f f9       	sub	r9,-1
8000a4ec:	51 39       	stdsp	sp[0x4c],r9
8000a4ee:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4f2:	e0 a0 0e db 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a4f6:	e0 81 03 39 	brne	8000ab68 <_dtoa_r+0xbb4>
8000a4fa:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4fe:	30 0a       	mov	r10,0
8000a500:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a504:	e0 a0 0c ac 	rcall	8000be5c <__avr32_f64_sub>
8000a508:	fa e8 00 28 	ld.d	r8,sp[40]
8000a50c:	e0 a0 0e ce 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a510:	fa ea 00 28 	ld.d	r10,sp[40]
8000a514:	30 08       	mov	r8,0
8000a516:	fc 19 40 24 	movh	r9,0x4024
8000a51a:	e0 81 00 da 	brne	8000a6ce <_dtoa_r+0x71a>
8000a51e:	41 3c       	lddsp	r12,sp[0x4c]
8000a520:	08 3c       	cp.w	r12,r4
8000a522:	c5 f4       	brge	8000a5e0 <_dtoa_r+0x62c>
8000a524:	e0 a0 0b b0 	rcall	8000bc84 <__avr32_f64_mul>
8000a528:	30 08       	mov	r8,0
8000a52a:	fa eb 00 28 	st.d	sp[40],r10
8000a52e:	fc 19 40 24 	movh	r9,0x4024
8000a532:	fa ea 00 08 	ld.d	r10,sp[8]
8000a536:	e0 a0 0b a7 	rcall	8000bc84 <__avr32_f64_mul>
8000a53a:	fa eb 00 08 	st.d	sp[8],r10
8000a53e:	cc 3b       	rjmp	8000a4c4 <_dtoa_r+0x510>
8000a540:	40 85       	lddsp	r5,sp[0x20]
8000a542:	08 05       	add	r5,r4
8000a544:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a548:	51 35       	stdsp	sp[0x4c],r5
8000a54a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a54e:	40 85       	lddsp	r5,sp[0x20]
8000a550:	e0 a0 0b 9a 	rcall	8000bc84 <__avr32_f64_mul>
8000a554:	fa eb 00 28 	st.d	sp[40],r10
8000a558:	fa ea 00 08 	ld.d	r10,sp[8]
8000a55c:	e0 a0 0d d8 	rcall	8000c10c <__avr32_f64_to_s32>
8000a560:	51 6c       	stdsp	sp[0x58],r12
8000a562:	e0 a0 0d ec 	rcall	8000c13a <__avr32_s32_to_f64>
8000a566:	14 98       	mov	r8,r10
8000a568:	16 99       	mov	r9,r11
8000a56a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a56e:	e0 a0 0c 77 	rcall	8000be5c <__avr32_f64_sub>
8000a572:	fa eb 00 08 	st.d	sp[8],r10
8000a576:	41 68       	lddsp	r8,sp[0x58]
8000a578:	2d 08       	sub	r8,-48
8000a57a:	0a c8       	st.b	r5++,r8
8000a57c:	41 3c       	lddsp	r12,sp[0x4c]
8000a57e:	18 35       	cp.w	r5,r12
8000a580:	c2 81       	brne	8000a5d0 <_dtoa_r+0x61c>
8000a582:	30 08       	mov	r8,0
8000a584:	fc 19 3f e0 	movh	r9,0x3fe0
8000a588:	fa ea 00 28 	ld.d	r10,sp[40]
8000a58c:	e0 a0 0d 36 	rcall	8000bff8 <__avr32_f64_add>
8000a590:	40 85       	lddsp	r5,sp[0x20]
8000a592:	fa e8 00 08 	ld.d	r8,sp[8]
8000a596:	08 05       	add	r5,r4
8000a598:	e0 a0 0e 88 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a59c:	e0 81 00 99 	brne	8000a6ce <_dtoa_r+0x71a>
8000a5a0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5a4:	30 0a       	mov	r10,0
8000a5a6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a5aa:	e0 a0 0c 59 	rcall	8000be5c <__avr32_f64_sub>
8000a5ae:	14 98       	mov	r8,r10
8000a5b0:	16 99       	mov	r9,r11
8000a5b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5b6:	e0 a0 0e 79 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a5ba:	c1 30       	breq	8000a5e0 <_dtoa_r+0x62c>
8000a5bc:	33 09       	mov	r9,48
8000a5be:	0a 98       	mov	r8,r5
8000a5c0:	11 7a       	ld.ub	r10,--r8
8000a5c2:	f2 0a 18 00 	cp.b	r10,r9
8000a5c6:	e0 81 02 d1 	brne	8000ab68 <_dtoa_r+0xbb4>
8000a5ca:	10 95       	mov	r5,r8
8000a5cc:	cf 9b       	rjmp	8000a5be <_dtoa_r+0x60a>
8000a5ce:	d7 03       	nop
8000a5d0:	30 08       	mov	r8,0
8000a5d2:	fc 19 40 24 	movh	r9,0x4024
8000a5d6:	e0 a0 0b 57 	rcall	8000bc84 <__avr32_f64_mul>
8000a5da:	fa eb 00 08 	st.d	sp[8],r10
8000a5de:	cb db       	rjmp	8000a558 <_dtoa_r+0x5a4>
8000a5e0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5e4:	fa eb 00 08 	st.d	sp[8],r10
8000a5e8:	58 e6       	cp.w	r6,14
8000a5ea:	5f ab       	srle	r11
8000a5ec:	41 8a       	lddsp	r10,sp[0x60]
8000a5ee:	30 08       	mov	r8,0
8000a5f0:	f4 09 11 ff 	rsub	r9,r10,-1
8000a5f4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a5f8:	f0 09 18 00 	cp.b	r9,r8
8000a5fc:	e0 80 00 82 	breq	8000a700 <_dtoa_r+0x74c>
8000a600:	40 ea       	lddsp	r10,sp[0x38]
8000a602:	58 01       	cp.w	r1,0
8000a604:	5f a9       	srle	r9
8000a606:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a60a:	fe ca c7 9e 	sub	r10,pc,-14434
8000a60e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a612:	fa e5 00 10 	st.d	sp[16],r4
8000a616:	f0 09 18 00 	cp.b	r9,r8
8000a61a:	c1 40       	breq	8000a642 <_dtoa_r+0x68e>
8000a61c:	58 01       	cp.w	r1,0
8000a61e:	e0 81 01 77 	brne	8000a90c <_dtoa_r+0x958>
8000a622:	30 08       	mov	r8,0
8000a624:	fc 19 40 14 	movh	r9,0x4014
8000a628:	08 9a       	mov	r10,r4
8000a62a:	0a 9b       	mov	r11,r5
8000a62c:	e0 a0 0b 2c 	rcall	8000bc84 <__avr32_f64_mul>
8000a630:	fa e8 00 08 	ld.d	r8,sp[8]
8000a634:	e0 a0 0e 06 	rcall	8000c240 <__avr32_f64_cmp_ge>
8000a638:	e0 81 01 6a 	brne	8000a90c <_dtoa_r+0x958>
8000a63c:	02 92       	mov	r2,r1
8000a63e:	e0 8f 01 72 	bral	8000a922 <_dtoa_r+0x96e>
8000a642:	40 85       	lddsp	r5,sp[0x20]
8000a644:	30 14       	mov	r4,1
8000a646:	fa e8 00 10 	ld.d	r8,sp[16]
8000a64a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a64e:	e0 a0 0e 61 	rcall	8000c310 <__avr32_f64_div>
8000a652:	e0 a0 0d 5d 	rcall	8000c10c <__avr32_f64_to_s32>
8000a656:	18 92       	mov	r2,r12
8000a658:	e0 a0 0d 71 	rcall	8000c13a <__avr32_s32_to_f64>
8000a65c:	fa e8 00 10 	ld.d	r8,sp[16]
8000a660:	e0 a0 0b 12 	rcall	8000bc84 <__avr32_f64_mul>
8000a664:	14 98       	mov	r8,r10
8000a666:	16 99       	mov	r9,r11
8000a668:	fa ea 00 08 	ld.d	r10,sp[8]
8000a66c:	e0 a0 0b f8 	rcall	8000be5c <__avr32_f64_sub>
8000a670:	fa eb 00 08 	st.d	sp[8],r10
8000a674:	e4 c8 ff d0 	sub	r8,r2,-48
8000a678:	0a c8       	st.b	r5++,r8
8000a67a:	fc 19 40 24 	movh	r9,0x4024
8000a67e:	30 08       	mov	r8,0
8000a680:	02 34       	cp.w	r4,r1
8000a682:	c3 31       	brne	8000a6e8 <_dtoa_r+0x734>
8000a684:	fa e8 00 08 	ld.d	r8,sp[8]
8000a688:	e0 a0 0c b8 	rcall	8000bff8 <__avr32_f64_add>
8000a68c:	16 91       	mov	r1,r11
8000a68e:	14 90       	mov	r0,r10
8000a690:	14 98       	mov	r8,r10
8000a692:	02 99       	mov	r9,r1
8000a694:	fa ea 00 10 	ld.d	r10,sp[16]
8000a698:	e0 a0 0e 08 	rcall	8000c2a8 <__avr32_f64_cmp_lt>
8000a69c:	c1 a1       	brne	8000a6d0 <_dtoa_r+0x71c>
8000a69e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6a2:	00 9a       	mov	r10,r0
8000a6a4:	02 9b       	mov	r11,r1
8000a6a6:	e0 a0 0d ba 	rcall	8000c21a <__avr32_f64_cmp_eq>
8000a6aa:	e0 80 02 5e 	breq	8000ab66 <_dtoa_r+0xbb2>
8000a6ae:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a6b2:	c0 f1       	brne	8000a6d0 <_dtoa_r+0x71c>
8000a6b4:	e0 8f 02 59 	bral	8000ab66 <_dtoa_r+0xbb2>
8000a6b8:	40 8a       	lddsp	r10,sp[0x20]
8000a6ba:	14 38       	cp.w	r8,r10
8000a6bc:	c0 30       	breq	8000a6c2 <_dtoa_r+0x70e>
8000a6be:	10 95       	mov	r5,r8
8000a6c0:	c0 98       	rjmp	8000a6d2 <_dtoa_r+0x71e>
8000a6c2:	33 08       	mov	r8,48
8000a6c4:	40 89       	lddsp	r9,sp[0x20]
8000a6c6:	2f f6       	sub	r6,-1
8000a6c8:	b2 88       	st.b	r9[0x0],r8
8000a6ca:	40 88       	lddsp	r8,sp[0x20]
8000a6cc:	c0 88       	rjmp	8000a6dc <_dtoa_r+0x728>
8000a6ce:	40 66       	lddsp	r6,sp[0x18]
8000a6d0:	33 99       	mov	r9,57
8000a6d2:	0a 98       	mov	r8,r5
8000a6d4:	11 7a       	ld.ub	r10,--r8
8000a6d6:	f2 0a 18 00 	cp.b	r10,r9
8000a6da:	ce f0       	breq	8000a6b8 <_dtoa_r+0x704>
8000a6dc:	50 66       	stdsp	sp[0x18],r6
8000a6de:	11 89       	ld.ub	r9,r8[0x0]
8000a6e0:	2f f9       	sub	r9,-1
8000a6e2:	b0 89       	st.b	r8[0x0],r9
8000a6e4:	e0 8f 02 42 	bral	8000ab68 <_dtoa_r+0xbb4>
8000a6e8:	e0 a0 0a ce 	rcall	8000bc84 <__avr32_f64_mul>
8000a6ec:	2f f4       	sub	r4,-1
8000a6ee:	fa eb 00 08 	st.d	sp[8],r10
8000a6f2:	30 08       	mov	r8,0
8000a6f4:	30 09       	mov	r9,0
8000a6f6:	e0 a0 0d 92 	rcall	8000c21a <__avr32_f64_cmp_eq>
8000a6fa:	ca 60       	breq	8000a646 <_dtoa_r+0x692>
8000a6fc:	e0 8f 02 35 	bral	8000ab66 <_dtoa_r+0xbb2>
8000a700:	40 d8       	lddsp	r8,sp[0x34]
8000a702:	58 08       	cp.w	r8,0
8000a704:	c0 51       	brne	8000a70e <_dtoa_r+0x75a>
8000a706:	04 98       	mov	r8,r2
8000a708:	00 95       	mov	r5,r0
8000a70a:	40 d4       	lddsp	r4,sp[0x34]
8000a70c:	c3 78       	rjmp	8000a77a <_dtoa_r+0x7c6>
8000a70e:	40 c5       	lddsp	r5,sp[0x30]
8000a710:	58 15       	cp.w	r5,1
8000a712:	e0 89 00 0f 	brgt	8000a730 <_dtoa_r+0x77c>
8000a716:	41 74       	lddsp	r4,sp[0x5c]
8000a718:	58 04       	cp.w	r4,0
8000a71a:	c0 40       	breq	8000a722 <_dtoa_r+0x76e>
8000a71c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a720:	c0 48       	rjmp	8000a728 <_dtoa_r+0x774>
8000a722:	41 99       	lddsp	r9,sp[0x64]
8000a724:	f2 09 11 36 	rsub	r9,r9,54
8000a728:	04 98       	mov	r8,r2
8000a72a:	00 95       	mov	r5,r0
8000a72c:	c1 c8       	rjmp	8000a764 <_dtoa_r+0x7b0>
8000a72e:	d7 03       	nop
8000a730:	e2 c8 00 01 	sub	r8,r1,1
8000a734:	58 01       	cp.w	r1,0
8000a736:	e0 05 17 40 	movge	r5,r0
8000a73a:	e2 09 17 40 	movge	r9,r1
8000a73e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a742:	f9 b9 05 00 	movlt	r9,0
8000a746:	10 32       	cp.w	r2,r8
8000a748:	e5 d8 e4 18 	subge	r8,r2,r8
8000a74c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a750:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a754:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a758:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a75c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a760:	f9 b8 05 00 	movlt	r8,0
8000a764:	40 4b       	lddsp	r11,sp[0x10]
8000a766:	12 0b       	add	r11,r9
8000a768:	50 08       	stdsp	sp[0x0],r8
8000a76a:	50 4b       	stdsp	sp[0x10],r11
8000a76c:	12 00       	add	r0,r9
8000a76e:	30 1b       	mov	r11,1
8000a770:	0e 9c       	mov	r12,r7
8000a772:	e0 a0 08 a7 	rcall	8000b8c0 <__i2b>
8000a776:	40 08       	lddsp	r8,sp[0x0]
8000a778:	18 94       	mov	r4,r12
8000a77a:	40 4a       	lddsp	r10,sp[0x10]
8000a77c:	58 05       	cp.w	r5,0
8000a77e:	5f 99       	srgt	r9
8000a780:	58 0a       	cp.w	r10,0
8000a782:	5f 9a       	srgt	r10
8000a784:	f5 e9 00 09 	and	r9,r10,r9
8000a788:	c0 80       	breq	8000a798 <_dtoa_r+0x7e4>
8000a78a:	40 4c       	lddsp	r12,sp[0x10]
8000a78c:	f8 05 0d 49 	min	r9,r12,r5
8000a790:	12 1c       	sub	r12,r9
8000a792:	12 10       	sub	r0,r9
8000a794:	50 4c       	stdsp	sp[0x10],r12
8000a796:	12 15       	sub	r5,r9
8000a798:	58 02       	cp.w	r2,0
8000a79a:	e0 8a 00 27 	brle	8000a7e8 <_dtoa_r+0x834>
8000a79e:	40 db       	lddsp	r11,sp[0x34]
8000a7a0:	58 0b       	cp.w	r11,0
8000a7a2:	c1 d0       	breq	8000a7dc <_dtoa_r+0x828>
8000a7a4:	58 08       	cp.w	r8,0
8000a7a6:	e0 8a 00 17 	brle	8000a7d4 <_dtoa_r+0x820>
8000a7aa:	10 9a       	mov	r10,r8
8000a7ac:	50 08       	stdsp	sp[0x0],r8
8000a7ae:	08 9b       	mov	r11,r4
8000a7b0:	0e 9c       	mov	r12,r7
8000a7b2:	e0 a0 08 cd 	rcall	8000b94c <__pow5mult>
8000a7b6:	06 9a       	mov	r10,r3
8000a7b8:	18 9b       	mov	r11,r12
8000a7ba:	18 94       	mov	r4,r12
8000a7bc:	0e 9c       	mov	r12,r7
8000a7be:	e0 a0 08 01 	rcall	8000b7c0 <__multiply>
8000a7c2:	18 99       	mov	r9,r12
8000a7c4:	06 9b       	mov	r11,r3
8000a7c6:	50 19       	stdsp	sp[0x4],r9
8000a7c8:	0e 9c       	mov	r12,r7
8000a7ca:	e0 a0 06 ad 	rcall	8000b524 <_Bfree>
8000a7ce:	40 19       	lddsp	r9,sp[0x4]
8000a7d0:	40 08       	lddsp	r8,sp[0x0]
8000a7d2:	12 93       	mov	r3,r9
8000a7d4:	e4 08 01 0a 	sub	r10,r2,r8
8000a7d8:	c0 80       	breq	8000a7e8 <_dtoa_r+0x834>
8000a7da:	c0 28       	rjmp	8000a7de <_dtoa_r+0x82a>
8000a7dc:	04 9a       	mov	r10,r2
8000a7de:	06 9b       	mov	r11,r3
8000a7e0:	0e 9c       	mov	r12,r7
8000a7e2:	e0 a0 08 b5 	rcall	8000b94c <__pow5mult>
8000a7e6:	18 93       	mov	r3,r12
8000a7e8:	30 1b       	mov	r11,1
8000a7ea:	0e 9c       	mov	r12,r7
8000a7ec:	e0 a0 08 6a 	rcall	8000b8c0 <__i2b>
8000a7f0:	41 1a       	lddsp	r10,sp[0x44]
8000a7f2:	18 92       	mov	r2,r12
8000a7f4:	58 0a       	cp.w	r10,0
8000a7f6:	e0 8a 00 07 	brle	8000a804 <_dtoa_r+0x850>
8000a7fa:	18 9b       	mov	r11,r12
8000a7fc:	0e 9c       	mov	r12,r7
8000a7fe:	e0 a0 08 a7 	rcall	8000b94c <__pow5mult>
8000a802:	18 92       	mov	r2,r12
8000a804:	40 c9       	lddsp	r9,sp[0x30]
8000a806:	58 19       	cp.w	r9,1
8000a808:	e0 89 00 14 	brgt	8000a830 <_dtoa_r+0x87c>
8000a80c:	40 38       	lddsp	r8,sp[0xc]
8000a80e:	58 08       	cp.w	r8,0
8000a810:	c1 01       	brne	8000a830 <_dtoa_r+0x87c>
8000a812:	40 29       	lddsp	r9,sp[0x8]
8000a814:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a818:	c0 c1       	brne	8000a830 <_dtoa_r+0x87c>
8000a81a:	12 98       	mov	r8,r9
8000a81c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a820:	c0 80       	breq	8000a830 <_dtoa_r+0x87c>
8000a822:	40 4c       	lddsp	r12,sp[0x10]
8000a824:	30 1b       	mov	r11,1
8000a826:	2f fc       	sub	r12,-1
8000a828:	2f f0       	sub	r0,-1
8000a82a:	50 4c       	stdsp	sp[0x10],r12
8000a82c:	50 6b       	stdsp	sp[0x18],r11
8000a82e:	c0 38       	rjmp	8000a834 <_dtoa_r+0x880>
8000a830:	30 0a       	mov	r10,0
8000a832:	50 6a       	stdsp	sp[0x18],r10
8000a834:	41 19       	lddsp	r9,sp[0x44]
8000a836:	58 09       	cp.w	r9,0
8000a838:	c0 31       	brne	8000a83e <_dtoa_r+0x88a>
8000a83a:	30 1c       	mov	r12,1
8000a83c:	c0 98       	rjmp	8000a84e <_dtoa_r+0x89a>
8000a83e:	64 48       	ld.w	r8,r2[0x10]
8000a840:	2f c8       	sub	r8,-4
8000a842:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a846:	e0 a0 05 df 	rcall	8000b404 <__hi0bits>
8000a84a:	f8 0c 11 20 	rsub	r12,r12,32
8000a84e:	40 4b       	lddsp	r11,sp[0x10]
8000a850:	f8 0b 00 08 	add	r8,r12,r11
8000a854:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a858:	c0 c0       	breq	8000a870 <_dtoa_r+0x8bc>
8000a85a:	f0 08 11 20 	rsub	r8,r8,32
8000a85e:	58 48       	cp.w	r8,4
8000a860:	e0 8a 00 06 	brle	8000a86c <_dtoa_r+0x8b8>
8000a864:	20 48       	sub	r8,4
8000a866:	10 0b       	add	r11,r8
8000a868:	50 4b       	stdsp	sp[0x10],r11
8000a86a:	c0 78       	rjmp	8000a878 <_dtoa_r+0x8c4>
8000a86c:	58 48       	cp.w	r8,4
8000a86e:	c0 70       	breq	8000a87c <_dtoa_r+0x8c8>
8000a870:	40 4a       	lddsp	r10,sp[0x10]
8000a872:	2e 48       	sub	r8,-28
8000a874:	10 0a       	add	r10,r8
8000a876:	50 4a       	stdsp	sp[0x10],r10
8000a878:	10 00       	add	r0,r8
8000a87a:	10 05       	add	r5,r8
8000a87c:	58 00       	cp.w	r0,0
8000a87e:	e0 8a 00 08 	brle	8000a88e <_dtoa_r+0x8da>
8000a882:	06 9b       	mov	r11,r3
8000a884:	00 9a       	mov	r10,r0
8000a886:	0e 9c       	mov	r12,r7
8000a888:	e0 a0 07 58 	rcall	8000b738 <__lshift>
8000a88c:	18 93       	mov	r3,r12
8000a88e:	40 49       	lddsp	r9,sp[0x10]
8000a890:	58 09       	cp.w	r9,0
8000a892:	e0 8a 00 08 	brle	8000a8a2 <_dtoa_r+0x8ee>
8000a896:	04 9b       	mov	r11,r2
8000a898:	12 9a       	mov	r10,r9
8000a89a:	0e 9c       	mov	r12,r7
8000a89c:	e0 a0 07 4e 	rcall	8000b738 <__lshift>
8000a8a0:	18 92       	mov	r2,r12
8000a8a2:	41 48       	lddsp	r8,sp[0x50]
8000a8a4:	58 08       	cp.w	r8,0
8000a8a6:	c1 b0       	breq	8000a8dc <_dtoa_r+0x928>
8000a8a8:	04 9b       	mov	r11,r2
8000a8aa:	06 9c       	mov	r12,r3
8000a8ac:	e0 a0 06 23 	rcall	8000b4f2 <__mcmp>
8000a8b0:	c1 64       	brge	8000a8dc <_dtoa_r+0x928>
8000a8b2:	06 9b       	mov	r11,r3
8000a8b4:	30 09       	mov	r9,0
8000a8b6:	30 aa       	mov	r10,10
8000a8b8:	0e 9c       	mov	r12,r7
8000a8ba:	e0 a0 08 0b 	rcall	8000b8d0 <__multadd>
8000a8be:	20 16       	sub	r6,1
8000a8c0:	18 93       	mov	r3,r12
8000a8c2:	40 dc       	lddsp	r12,sp[0x34]
8000a8c4:	58 0c       	cp.w	r12,0
8000a8c6:	c0 31       	brne	8000a8cc <_dtoa_r+0x918>
8000a8c8:	40 91       	lddsp	r1,sp[0x24]
8000a8ca:	c0 98       	rjmp	8000a8dc <_dtoa_r+0x928>
8000a8cc:	08 9b       	mov	r11,r4
8000a8ce:	40 91       	lddsp	r1,sp[0x24]
8000a8d0:	30 09       	mov	r9,0
8000a8d2:	30 aa       	mov	r10,10
8000a8d4:	0e 9c       	mov	r12,r7
8000a8d6:	e0 a0 07 fd 	rcall	8000b8d0 <__multadd>
8000a8da:	18 94       	mov	r4,r12
8000a8dc:	58 01       	cp.w	r1,0
8000a8de:	5f a9       	srle	r9
8000a8e0:	40 cb       	lddsp	r11,sp[0x30]
8000a8e2:	58 2b       	cp.w	r11,2
8000a8e4:	5f 98       	srgt	r8
8000a8e6:	f3 e8 00 08 	and	r8,r9,r8
8000a8ea:	c2 50       	breq	8000a934 <_dtoa_r+0x980>
8000a8ec:	58 01       	cp.w	r1,0
8000a8ee:	c1 11       	brne	8000a910 <_dtoa_r+0x95c>
8000a8f0:	04 9b       	mov	r11,r2
8000a8f2:	02 99       	mov	r9,r1
8000a8f4:	30 5a       	mov	r10,5
8000a8f6:	0e 9c       	mov	r12,r7
8000a8f8:	e0 a0 07 ec 	rcall	8000b8d0 <__multadd>
8000a8fc:	18 92       	mov	r2,r12
8000a8fe:	18 9b       	mov	r11,r12
8000a900:	06 9c       	mov	r12,r3
8000a902:	e0 a0 05 f8 	rcall	8000b4f2 <__mcmp>
8000a906:	e0 89 00 0f 	brgt	8000a924 <_dtoa_r+0x970>
8000a90a:	c0 38       	rjmp	8000a910 <_dtoa_r+0x95c>
8000a90c:	30 02       	mov	r2,0
8000a90e:	04 94       	mov	r4,r2
8000a910:	40 ea       	lddsp	r10,sp[0x38]
8000a912:	30 09       	mov	r9,0
8000a914:	5c da       	com	r10
8000a916:	40 85       	lddsp	r5,sp[0x20]
8000a918:	50 6a       	stdsp	sp[0x18],r10
8000a91a:	50 49       	stdsp	sp[0x10],r9
8000a91c:	c0 f9       	rjmp	8000ab3a <_dtoa_r+0xb86>
8000a91e:	08 92       	mov	r2,r4
8000a920:	40 66       	lddsp	r6,sp[0x18]
8000a922:	04 94       	mov	r4,r2
8000a924:	2f f6       	sub	r6,-1
8000a926:	50 66       	stdsp	sp[0x18],r6
8000a928:	33 18       	mov	r8,49
8000a92a:	40 85       	lddsp	r5,sp[0x20]
8000a92c:	0a c8       	st.b	r5++,r8
8000a92e:	30 08       	mov	r8,0
8000a930:	50 48       	stdsp	sp[0x10],r8
8000a932:	c0 49       	rjmp	8000ab3a <_dtoa_r+0xb86>
8000a934:	40 dc       	lddsp	r12,sp[0x34]
8000a936:	58 0c       	cp.w	r12,0
8000a938:	e0 80 00 b5 	breq	8000aaa2 <_dtoa_r+0xaee>
8000a93c:	58 05       	cp.w	r5,0
8000a93e:	e0 8a 00 08 	brle	8000a94e <_dtoa_r+0x99a>
8000a942:	08 9b       	mov	r11,r4
8000a944:	0a 9a       	mov	r10,r5
8000a946:	0e 9c       	mov	r12,r7
8000a948:	e0 a0 06 f8 	rcall	8000b738 <__lshift>
8000a94c:	18 94       	mov	r4,r12
8000a94e:	40 6b       	lddsp	r11,sp[0x18]
8000a950:	58 0b       	cp.w	r11,0
8000a952:	c0 31       	brne	8000a958 <_dtoa_r+0x9a4>
8000a954:	08 9c       	mov	r12,r4
8000a956:	c1 38       	rjmp	8000a97c <_dtoa_r+0x9c8>
8000a958:	68 1b       	ld.w	r11,r4[0x4]
8000a95a:	0e 9c       	mov	r12,r7
8000a95c:	e0 a0 05 fe 	rcall	8000b558 <_Balloc>
8000a960:	68 4a       	ld.w	r10,r4[0x10]
8000a962:	18 95       	mov	r5,r12
8000a964:	e8 cb ff f4 	sub	r11,r4,-12
8000a968:	2f ea       	sub	r10,-2
8000a96a:	2f 4c       	sub	r12,-12
8000a96c:	a3 6a       	lsl	r10,0x2
8000a96e:	fe b0 e6 4f 	rcall	8000760c <memcpy>
8000a972:	0a 9b       	mov	r11,r5
8000a974:	30 1a       	mov	r10,1
8000a976:	0e 9c       	mov	r12,r7
8000a978:	e0 a0 06 e0 	rcall	8000b738 <__lshift>
8000a97c:	50 44       	stdsp	sp[0x10],r4
8000a97e:	40 3a       	lddsp	r10,sp[0xc]
8000a980:	30 19       	mov	r9,1
8000a982:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a986:	18 94       	mov	r4,r12
8000a988:	50 da       	stdsp	sp[0x34],r10
8000a98a:	40 85       	lddsp	r5,sp[0x20]
8000a98c:	50 99       	stdsp	sp[0x24],r9
8000a98e:	50 26       	stdsp	sp[0x8],r6
8000a990:	50 e1       	stdsp	sp[0x38],r1
8000a992:	04 9b       	mov	r11,r2
8000a994:	06 9c       	mov	r12,r3
8000a996:	fe b0 fa 7f 	rcall	80009e94 <quorem>
8000a99a:	40 4b       	lddsp	r11,sp[0x10]
8000a99c:	f8 c0 ff d0 	sub	r0,r12,-48
8000a9a0:	06 9c       	mov	r12,r3
8000a9a2:	e0 a0 05 a8 	rcall	8000b4f2 <__mcmp>
8000a9a6:	08 9a       	mov	r10,r4
8000a9a8:	50 6c       	stdsp	sp[0x18],r12
8000a9aa:	04 9b       	mov	r11,r2
8000a9ac:	0e 9c       	mov	r12,r7
8000a9ae:	e0 a0 06 5d 	rcall	8000b668 <__mdiff>
8000a9b2:	18 91       	mov	r1,r12
8000a9b4:	78 38       	ld.w	r8,r12[0xc]
8000a9b6:	58 08       	cp.w	r8,0
8000a9b8:	c0 30       	breq	8000a9be <_dtoa_r+0xa0a>
8000a9ba:	30 16       	mov	r6,1
8000a9bc:	c0 68       	rjmp	8000a9c8 <_dtoa_r+0xa14>
8000a9be:	18 9b       	mov	r11,r12
8000a9c0:	06 9c       	mov	r12,r3
8000a9c2:	e0 a0 05 98 	rcall	8000b4f2 <__mcmp>
8000a9c6:	18 96       	mov	r6,r12
8000a9c8:	0e 9c       	mov	r12,r7
8000a9ca:	02 9b       	mov	r11,r1
8000a9cc:	e0 a0 05 ac 	rcall	8000b524 <_Bfree>
8000a9d0:	40 cc       	lddsp	r12,sp[0x30]
8000a9d2:	ed ec 10 08 	or	r8,r6,r12
8000a9d6:	c0 d1       	brne	8000a9f0 <_dtoa_r+0xa3c>
8000a9d8:	40 db       	lddsp	r11,sp[0x34]
8000a9da:	58 0b       	cp.w	r11,0
8000a9dc:	c0 a1       	brne	8000a9f0 <_dtoa_r+0xa3c>
8000a9de:	40 26       	lddsp	r6,sp[0x8]
8000a9e0:	e0 40 00 39 	cp.w	r0,57
8000a9e4:	c3 00       	breq	8000aa44 <_dtoa_r+0xa90>
8000a9e6:	40 6a       	lddsp	r10,sp[0x18]
8000a9e8:	58 0a       	cp.w	r10,0
8000a9ea:	e0 89 00 24 	brgt	8000aa32 <_dtoa_r+0xa7e>
8000a9ee:	c2 f8       	rjmp	8000aa4c <_dtoa_r+0xa98>
8000a9f0:	40 69       	lddsp	r9,sp[0x18]
8000a9f2:	58 09       	cp.w	r9,0
8000a9f4:	c0 85       	brlt	8000aa04 <_dtoa_r+0xa50>
8000a9f6:	12 98       	mov	r8,r9
8000a9f8:	40 cc       	lddsp	r12,sp[0x30]
8000a9fa:	18 48       	or	r8,r12
8000a9fc:	c1 d1       	brne	8000aa36 <_dtoa_r+0xa82>
8000a9fe:	40 db       	lddsp	r11,sp[0x34]
8000aa00:	58 0b       	cp.w	r11,0
8000aa02:	c1 a1       	brne	8000aa36 <_dtoa_r+0xa82>
8000aa04:	0c 99       	mov	r9,r6
8000aa06:	40 26       	lddsp	r6,sp[0x8]
8000aa08:	58 09       	cp.w	r9,0
8000aa0a:	e0 8a 00 21 	brle	8000aa4c <_dtoa_r+0xa98>
8000aa0e:	06 9b       	mov	r11,r3
8000aa10:	30 1a       	mov	r10,1
8000aa12:	0e 9c       	mov	r12,r7
8000aa14:	e0 a0 06 92 	rcall	8000b738 <__lshift>
8000aa18:	04 9b       	mov	r11,r2
8000aa1a:	18 93       	mov	r3,r12
8000aa1c:	e0 a0 05 6b 	rcall	8000b4f2 <__mcmp>
8000aa20:	e0 89 00 06 	brgt	8000aa2c <_dtoa_r+0xa78>
8000aa24:	c1 41       	brne	8000aa4c <_dtoa_r+0xa98>
8000aa26:	ed b0 00 00 	bld	r0,0x0
8000aa2a:	c1 11       	brne	8000aa4c <_dtoa_r+0xa98>
8000aa2c:	e0 40 00 39 	cp.w	r0,57
8000aa30:	c0 a0       	breq	8000aa44 <_dtoa_r+0xa90>
8000aa32:	2f f0       	sub	r0,-1
8000aa34:	c0 c8       	rjmp	8000aa4c <_dtoa_r+0xa98>
8000aa36:	58 06       	cp.w	r6,0
8000aa38:	e0 8a 00 0c 	brle	8000aa50 <_dtoa_r+0xa9c>
8000aa3c:	40 26       	lddsp	r6,sp[0x8]
8000aa3e:	e0 40 00 39 	cp.w	r0,57
8000aa42:	c0 41       	brne	8000aa4a <_dtoa_r+0xa96>
8000aa44:	33 98       	mov	r8,57
8000aa46:	0a c8       	st.b	r5++,r8
8000aa48:	c6 78       	rjmp	8000ab16 <_dtoa_r+0xb62>
8000aa4a:	2f f0       	sub	r0,-1
8000aa4c:	0a c0       	st.b	r5++,r0
8000aa4e:	c7 58       	rjmp	8000ab38 <_dtoa_r+0xb84>
8000aa50:	0a c0       	st.b	r5++,r0
8000aa52:	40 9a       	lddsp	r10,sp[0x24]
8000aa54:	40 e9       	lddsp	r9,sp[0x38]
8000aa56:	12 3a       	cp.w	r10,r9
8000aa58:	c4 30       	breq	8000aade <_dtoa_r+0xb2a>
8000aa5a:	06 9b       	mov	r11,r3
8000aa5c:	30 09       	mov	r9,0
8000aa5e:	30 aa       	mov	r10,10
8000aa60:	0e 9c       	mov	r12,r7
8000aa62:	e0 a0 07 37 	rcall	8000b8d0 <__multadd>
8000aa66:	40 48       	lddsp	r8,sp[0x10]
8000aa68:	18 93       	mov	r3,r12
8000aa6a:	08 38       	cp.w	r8,r4
8000aa6c:	c0 91       	brne	8000aa7e <_dtoa_r+0xaca>
8000aa6e:	10 9b       	mov	r11,r8
8000aa70:	30 09       	mov	r9,0
8000aa72:	30 aa       	mov	r10,10
8000aa74:	0e 9c       	mov	r12,r7
8000aa76:	e0 a0 07 2d 	rcall	8000b8d0 <__multadd>
8000aa7a:	50 4c       	stdsp	sp[0x10],r12
8000aa7c:	c0 e8       	rjmp	8000aa98 <_dtoa_r+0xae4>
8000aa7e:	40 4b       	lddsp	r11,sp[0x10]
8000aa80:	30 09       	mov	r9,0
8000aa82:	30 aa       	mov	r10,10
8000aa84:	0e 9c       	mov	r12,r7
8000aa86:	e0 a0 07 25 	rcall	8000b8d0 <__multadd>
8000aa8a:	08 9b       	mov	r11,r4
8000aa8c:	50 4c       	stdsp	sp[0x10],r12
8000aa8e:	30 09       	mov	r9,0
8000aa90:	30 aa       	mov	r10,10
8000aa92:	0e 9c       	mov	r12,r7
8000aa94:	e0 a0 07 1e 	rcall	8000b8d0 <__multadd>
8000aa98:	18 94       	mov	r4,r12
8000aa9a:	40 9c       	lddsp	r12,sp[0x24]
8000aa9c:	2f fc       	sub	r12,-1
8000aa9e:	50 9c       	stdsp	sp[0x24],r12
8000aaa0:	c7 9b       	rjmp	8000a992 <_dtoa_r+0x9de>
8000aaa2:	30 18       	mov	r8,1
8000aaa4:	06 90       	mov	r0,r3
8000aaa6:	40 85       	lddsp	r5,sp[0x20]
8000aaa8:	08 93       	mov	r3,r4
8000aaaa:	0c 94       	mov	r4,r6
8000aaac:	10 96       	mov	r6,r8
8000aaae:	04 9b       	mov	r11,r2
8000aab0:	00 9c       	mov	r12,r0
8000aab2:	fe b0 f9 f1 	rcall	80009e94 <quorem>
8000aab6:	2d 0c       	sub	r12,-48
8000aab8:	0a cc       	st.b	r5++,r12
8000aaba:	02 36       	cp.w	r6,r1
8000aabc:	c0 a4       	brge	8000aad0 <_dtoa_r+0xb1c>
8000aabe:	00 9b       	mov	r11,r0
8000aac0:	30 09       	mov	r9,0
8000aac2:	30 aa       	mov	r10,10
8000aac4:	0e 9c       	mov	r12,r7
8000aac6:	2f f6       	sub	r6,-1
8000aac8:	e0 a0 07 04 	rcall	8000b8d0 <__multadd>
8000aacc:	18 90       	mov	r0,r12
8000aace:	cf 0b       	rjmp	8000aaae <_dtoa_r+0xafa>
8000aad0:	08 96       	mov	r6,r4
8000aad2:	30 0b       	mov	r11,0
8000aad4:	06 94       	mov	r4,r3
8000aad6:	50 4b       	stdsp	sp[0x10],r11
8000aad8:	00 93       	mov	r3,r0
8000aada:	18 90       	mov	r0,r12
8000aadc:	c0 28       	rjmp	8000aae0 <_dtoa_r+0xb2c>
8000aade:	40 26       	lddsp	r6,sp[0x8]
8000aae0:	06 9b       	mov	r11,r3
8000aae2:	30 1a       	mov	r10,1
8000aae4:	0e 9c       	mov	r12,r7
8000aae6:	e0 a0 06 29 	rcall	8000b738 <__lshift>
8000aaea:	04 9b       	mov	r11,r2
8000aaec:	18 93       	mov	r3,r12
8000aaee:	e0 a0 05 02 	rcall	8000b4f2 <__mcmp>
8000aaf2:	e0 89 00 12 	brgt	8000ab16 <_dtoa_r+0xb62>
8000aaf6:	c1 b1       	brne	8000ab2c <_dtoa_r+0xb78>
8000aaf8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aafc:	c0 d1       	brne	8000ab16 <_dtoa_r+0xb62>
8000aafe:	c1 78       	rjmp	8000ab2c <_dtoa_r+0xb78>
8000ab00:	40 89       	lddsp	r9,sp[0x20]
8000ab02:	12 38       	cp.w	r8,r9
8000ab04:	c0 30       	breq	8000ab0a <_dtoa_r+0xb56>
8000ab06:	10 95       	mov	r5,r8
8000ab08:	c0 88       	rjmp	8000ab18 <_dtoa_r+0xb64>
8000ab0a:	2f f6       	sub	r6,-1
8000ab0c:	50 66       	stdsp	sp[0x18],r6
8000ab0e:	33 18       	mov	r8,49
8000ab10:	40 8c       	lddsp	r12,sp[0x20]
8000ab12:	b8 88       	st.b	r12[0x0],r8
8000ab14:	c1 38       	rjmp	8000ab3a <_dtoa_r+0xb86>
8000ab16:	33 9a       	mov	r10,57
8000ab18:	0a 98       	mov	r8,r5
8000ab1a:	11 79       	ld.ub	r9,--r8
8000ab1c:	f4 09 18 00 	cp.b	r9,r10
8000ab20:	cf 00       	breq	8000ab00 <_dtoa_r+0xb4c>
8000ab22:	2f f9       	sub	r9,-1
8000ab24:	b0 89       	st.b	r8[0x0],r9
8000ab26:	c0 98       	rjmp	8000ab38 <_dtoa_r+0xb84>
8000ab28:	10 95       	mov	r5,r8
8000ab2a:	c0 28       	rjmp	8000ab2e <_dtoa_r+0xb7a>
8000ab2c:	33 09       	mov	r9,48
8000ab2e:	0a 98       	mov	r8,r5
8000ab30:	11 7a       	ld.ub	r10,--r8
8000ab32:	f2 0a 18 00 	cp.b	r10,r9
8000ab36:	cf 90       	breq	8000ab28 <_dtoa_r+0xb74>
8000ab38:	50 66       	stdsp	sp[0x18],r6
8000ab3a:	04 9b       	mov	r11,r2
8000ab3c:	0e 9c       	mov	r12,r7
8000ab3e:	e0 a0 04 f3 	rcall	8000b524 <_Bfree>
8000ab42:	58 04       	cp.w	r4,0
8000ab44:	c1 20       	breq	8000ab68 <_dtoa_r+0xbb4>
8000ab46:	40 4b       	lddsp	r11,sp[0x10]
8000ab48:	08 3b       	cp.w	r11,r4
8000ab4a:	5f 19       	srne	r9
8000ab4c:	58 0b       	cp.w	r11,0
8000ab4e:	5f 18       	srne	r8
8000ab50:	f3 e8 00 08 	and	r8,r9,r8
8000ab54:	c0 40       	breq	8000ab5c <_dtoa_r+0xba8>
8000ab56:	0e 9c       	mov	r12,r7
8000ab58:	e0 a0 04 e6 	rcall	8000b524 <_Bfree>
8000ab5c:	08 9b       	mov	r11,r4
8000ab5e:	0e 9c       	mov	r12,r7
8000ab60:	e0 a0 04 e2 	rcall	8000b524 <_Bfree>
8000ab64:	c0 28       	rjmp	8000ab68 <_dtoa_r+0xbb4>
8000ab66:	50 66       	stdsp	sp[0x18],r6
8000ab68:	0e 9c       	mov	r12,r7
8000ab6a:	06 9b       	mov	r11,r3
8000ab6c:	e0 a0 04 dc 	rcall	8000b524 <_Bfree>
8000ab70:	30 08       	mov	r8,0
8000ab72:	aa 88       	st.b	r5[0x0],r8
8000ab74:	40 68       	lddsp	r8,sp[0x18]
8000ab76:	41 5a       	lddsp	r10,sp[0x54]
8000ab78:	2f f8       	sub	r8,-1
8000ab7a:	41 29       	lddsp	r9,sp[0x48]
8000ab7c:	95 08       	st.w	r10[0x0],r8
8000ab7e:	40 8c       	lddsp	r12,sp[0x20]
8000ab80:	58 09       	cp.w	r9,0
8000ab82:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ab86:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ab8a:	2e 6d       	sub	sp,-104
8000ab8c:	d8 32       	popm	r0-r7,pc
8000ab8e:	d7 03       	nop

8000ab90 <__errno>:
8000ab90:	e0 68 0a 38 	mov	r8,2616
8000ab94:	70 0c       	ld.w	r12,r8[0x0]
8000ab96:	2f 4c       	sub	r12,-12
8000ab98:	5e fc       	retal	r12
8000ab9a:	d7 03       	nop

8000ab9c <_fflush_r>:
8000ab9c:	d4 21       	pushm	r4-r7,lr
8000ab9e:	16 97       	mov	r7,r11
8000aba0:	18 96       	mov	r6,r12
8000aba2:	76 48       	ld.w	r8,r11[0x10]
8000aba4:	58 08       	cp.w	r8,0
8000aba6:	c7 f0       	breq	8000aca4 <_fflush_r+0x108>
8000aba8:	58 0c       	cp.w	r12,0
8000abaa:	c0 50       	breq	8000abb4 <_fflush_r+0x18>
8000abac:	78 68       	ld.w	r8,r12[0x18]
8000abae:	58 08       	cp.w	r8,0
8000abb0:	c0 21       	brne	8000abb4 <_fflush_r+0x18>
8000abb2:	cc dc       	rcall	8000ad4c <__sinit>
8000abb4:	fe c8 cd f8 	sub	r8,pc,-12808
8000abb8:	10 37       	cp.w	r7,r8
8000abba:	c0 31       	brne	8000abc0 <_fflush_r+0x24>
8000abbc:	6c 07       	ld.w	r7,r6[0x0]
8000abbe:	c0 c8       	rjmp	8000abd6 <_fflush_r+0x3a>
8000abc0:	fe c8 cd e4 	sub	r8,pc,-12828
8000abc4:	10 37       	cp.w	r7,r8
8000abc6:	c0 31       	brne	8000abcc <_fflush_r+0x30>
8000abc8:	6c 17       	ld.w	r7,r6[0x4]
8000abca:	c0 68       	rjmp	8000abd6 <_fflush_r+0x3a>
8000abcc:	fe c8 cd d0 	sub	r8,pc,-12848
8000abd0:	10 37       	cp.w	r7,r8
8000abd2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000abd6:	8e 6a       	ld.sh	r10,r7[0xc]
8000abd8:	14 98       	mov	r8,r10
8000abda:	ed ba 00 03 	bld	r10,0x3
8000abde:	c4 20       	breq	8000ac62 <_fflush_r+0xc6>
8000abe0:	ab ba       	sbr	r10,0xb
8000abe2:	ae 6a       	st.h	r7[0xc],r10
8000abe4:	6e 18       	ld.w	r8,r7[0x4]
8000abe6:	58 08       	cp.w	r8,0
8000abe8:	e0 89 00 06 	brgt	8000abf4 <_fflush_r+0x58>
8000abec:	6f 08       	ld.w	r8,r7[0x40]
8000abee:	58 08       	cp.w	r8,0
8000abf0:	e0 8a 00 5a 	brle	8000aca4 <_fflush_r+0x108>
8000abf4:	6e b8       	ld.w	r8,r7[0x2c]
8000abf6:	58 08       	cp.w	r8,0
8000abf8:	c5 60       	breq	8000aca4 <_fflush_r+0x108>
8000abfa:	e2 1a 10 00 	andl	r10,0x1000,COH
8000abfe:	c0 30       	breq	8000ac04 <_fflush_r+0x68>
8000ac00:	6f 55       	ld.w	r5,r7[0x54]
8000ac02:	c0 f8       	rjmp	8000ac20 <_fflush_r+0x84>
8000ac04:	30 19       	mov	r9,1
8000ac06:	6e 8b       	ld.w	r11,r7[0x20]
8000ac08:	0c 9c       	mov	r12,r6
8000ac0a:	5d 18       	icall	r8
8000ac0c:	18 95       	mov	r5,r12
8000ac0e:	5b fc       	cp.w	r12,-1
8000ac10:	c0 81       	brne	8000ac20 <_fflush_r+0x84>
8000ac12:	6c 38       	ld.w	r8,r6[0xc]
8000ac14:	59 d8       	cp.w	r8,29
8000ac16:	c4 70       	breq	8000aca4 <_fflush_r+0x108>
8000ac18:	8e 68       	ld.sh	r8,r7[0xc]
8000ac1a:	a7 a8       	sbr	r8,0x6
8000ac1c:	ae 68       	st.h	r7[0xc],r8
8000ac1e:	d8 22       	popm	r4-r7,pc
8000ac20:	8e 68       	ld.sh	r8,r7[0xc]
8000ac22:	ed b8 00 02 	bld	r8,0x2
8000ac26:	c0 91       	brne	8000ac38 <_fflush_r+0x9c>
8000ac28:	6e 18       	ld.w	r8,r7[0x4]
8000ac2a:	10 15       	sub	r5,r8
8000ac2c:	6e d8       	ld.w	r8,r7[0x34]
8000ac2e:	58 08       	cp.w	r8,0
8000ac30:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ac34:	eb d8 e1 15 	subne	r5,r5,r8
8000ac38:	6e b8       	ld.w	r8,r7[0x2c]
8000ac3a:	0c 9c       	mov	r12,r6
8000ac3c:	30 09       	mov	r9,0
8000ac3e:	0a 9a       	mov	r10,r5
8000ac40:	6e 8b       	ld.w	r11,r7[0x20]
8000ac42:	5d 18       	icall	r8
8000ac44:	8e 68       	ld.sh	r8,r7[0xc]
8000ac46:	0a 3c       	cp.w	r12,r5
8000ac48:	c2 61       	brne	8000ac94 <_fflush_r+0xf8>
8000ac4a:	ab d8       	cbr	r8,0xb
8000ac4c:	30 0c       	mov	r12,0
8000ac4e:	6e 49       	ld.w	r9,r7[0x10]
8000ac50:	ae 68       	st.h	r7[0xc],r8
8000ac52:	8f 1c       	st.w	r7[0x4],r12
8000ac54:	8f 09       	st.w	r7[0x0],r9
8000ac56:	ed b8 00 0c 	bld	r8,0xc
8000ac5a:	c2 51       	brne	8000aca4 <_fflush_r+0x108>
8000ac5c:	ef 45 00 54 	st.w	r7[84],r5
8000ac60:	d8 22       	popm	r4-r7,pc
8000ac62:	6e 45       	ld.w	r5,r7[0x10]
8000ac64:	58 05       	cp.w	r5,0
8000ac66:	c1 f0       	breq	8000aca4 <_fflush_r+0x108>
8000ac68:	6e 04       	ld.w	r4,r7[0x0]
8000ac6a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ac6e:	8f 05       	st.w	r7[0x0],r5
8000ac70:	f9 b8 01 00 	movne	r8,0
8000ac74:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ac78:	0a 14       	sub	r4,r5
8000ac7a:	8f 28       	st.w	r7[0x8],r8
8000ac7c:	c1 18       	rjmp	8000ac9e <_fflush_r+0x102>
8000ac7e:	08 99       	mov	r9,r4
8000ac80:	0a 9a       	mov	r10,r5
8000ac82:	6e a8       	ld.w	r8,r7[0x28]
8000ac84:	6e 8b       	ld.w	r11,r7[0x20]
8000ac86:	0c 9c       	mov	r12,r6
8000ac88:	5d 18       	icall	r8
8000ac8a:	18 14       	sub	r4,r12
8000ac8c:	58 0c       	cp.w	r12,0
8000ac8e:	e0 89 00 07 	brgt	8000ac9c <_fflush_r+0x100>
8000ac92:	8e 68       	ld.sh	r8,r7[0xc]
8000ac94:	a7 a8       	sbr	r8,0x6
8000ac96:	3f fc       	mov	r12,-1
8000ac98:	ae 68       	st.h	r7[0xc],r8
8000ac9a:	d8 22       	popm	r4-r7,pc
8000ac9c:	18 05       	add	r5,r12
8000ac9e:	58 04       	cp.w	r4,0
8000aca0:	fe 99 ff ef 	brgt	8000ac7e <_fflush_r+0xe2>
8000aca4:	d8 2a       	popm	r4-r7,pc,r12=0
8000aca6:	d7 03       	nop

8000aca8 <__sfp_lock_acquire>:
8000aca8:	5e fc       	retal	r12

8000acaa <__sfp_lock_release>:
8000acaa:	5e fc       	retal	r12

8000acac <_cleanup_r>:
8000acac:	d4 01       	pushm	lr
8000acae:	fe cb f0 ae 	sub	r11,pc,-3922
8000acb2:	e0 a0 02 f7 	rcall	8000b2a0 <_fwalk>
8000acb6:	d8 02       	popm	pc

8000acb8 <__sfmoreglue>:
8000acb8:	d4 21       	pushm	r4-r7,lr
8000acba:	16 95       	mov	r5,r11
8000acbc:	f6 06 10 5c 	mul	r6,r11,92
8000acc0:	ec cb ff f4 	sub	r11,r6,-12
8000acc4:	fe b0 e2 88 	rcall	800071d4 <_malloc_r>
8000acc8:	18 97       	mov	r7,r12
8000acca:	c0 90       	breq	8000acdc <__sfmoreglue+0x24>
8000accc:	99 15       	st.w	r12[0x4],r5
8000acce:	30 0b       	mov	r11,0
8000acd0:	2f 4c       	sub	r12,-12
8000acd2:	0c 9a       	mov	r10,r6
8000acd4:	8f 2c       	st.w	r7[0x8],r12
8000acd6:	8f 0b       	st.w	r7[0x0],r11
8000acd8:	fe b0 e5 3e 	rcall	80007754 <memset>
8000acdc:	0e 9c       	mov	r12,r7
8000acde:	d8 22       	popm	r4-r7,pc

8000ace0 <__sfp>:
8000ace0:	d4 21       	pushm	r4-r7,lr
8000ace2:	fe c8 ce c2 	sub	r8,pc,-12606
8000ace6:	18 96       	mov	r6,r12
8000ace8:	70 07       	ld.w	r7,r8[0x0]
8000acea:	6e 68       	ld.w	r8,r7[0x18]
8000acec:	58 08       	cp.w	r8,0
8000acee:	c0 31       	brne	8000acf4 <__sfp+0x14>
8000acf0:	0e 9c       	mov	r12,r7
8000acf2:	c2 dc       	rcall	8000ad4c <__sinit>
8000acf4:	ee c7 ff 28 	sub	r7,r7,-216
8000acf8:	30 05       	mov	r5,0
8000acfa:	6e 2c       	ld.w	r12,r7[0x8]
8000acfc:	6e 18       	ld.w	r8,r7[0x4]
8000acfe:	c0 68       	rjmp	8000ad0a <__sfp+0x2a>
8000ad00:	98 69       	ld.sh	r9,r12[0xc]
8000ad02:	ea 09 19 00 	cp.h	r9,r5
8000ad06:	c1 10       	breq	8000ad28 <__sfp+0x48>
8000ad08:	2a 4c       	sub	r12,-92
8000ad0a:	20 18       	sub	r8,1
8000ad0c:	cf a7       	brpl	8000ad00 <__sfp+0x20>
8000ad0e:	6e 08       	ld.w	r8,r7[0x0]
8000ad10:	58 08       	cp.w	r8,0
8000ad12:	c0 61       	brne	8000ad1e <__sfp+0x3e>
8000ad14:	30 4b       	mov	r11,4
8000ad16:	0c 9c       	mov	r12,r6
8000ad18:	cd 0f       	rcall	8000acb8 <__sfmoreglue>
8000ad1a:	8f 0c       	st.w	r7[0x0],r12
8000ad1c:	c0 30       	breq	8000ad22 <__sfp+0x42>
8000ad1e:	6e 07       	ld.w	r7,r7[0x0]
8000ad20:	ce db       	rjmp	8000acfa <__sfp+0x1a>
8000ad22:	30 c8       	mov	r8,12
8000ad24:	8d 38       	st.w	r6[0xc],r8
8000ad26:	d8 22       	popm	r4-r7,pc
8000ad28:	30 08       	mov	r8,0
8000ad2a:	f9 48 00 4c 	st.w	r12[76],r8
8000ad2e:	99 08       	st.w	r12[0x0],r8
8000ad30:	99 28       	st.w	r12[0x8],r8
8000ad32:	99 18       	st.w	r12[0x4],r8
8000ad34:	99 48       	st.w	r12[0x10],r8
8000ad36:	99 58       	st.w	r12[0x14],r8
8000ad38:	99 68       	st.w	r12[0x18],r8
8000ad3a:	99 d8       	st.w	r12[0x34],r8
8000ad3c:	99 e8       	st.w	r12[0x38],r8
8000ad3e:	f9 48 00 48 	st.w	r12[72],r8
8000ad42:	3f f8       	mov	r8,-1
8000ad44:	b8 78       	st.h	r12[0xe],r8
8000ad46:	30 18       	mov	r8,1
8000ad48:	b8 68       	st.h	r12[0xc],r8
8000ad4a:	d8 22       	popm	r4-r7,pc

8000ad4c <__sinit>:
8000ad4c:	d4 21       	pushm	r4-r7,lr
8000ad4e:	18 96       	mov	r6,r12
8000ad50:	78 67       	ld.w	r7,r12[0x18]
8000ad52:	58 07       	cp.w	r7,0
8000ad54:	c4 91       	brne	8000ade6 <__sinit+0x9a>
8000ad56:	fe c8 00 aa 	sub	r8,pc,170
8000ad5a:	30 15       	mov	r5,1
8000ad5c:	99 a8       	st.w	r12[0x28],r8
8000ad5e:	f9 47 00 d8 	st.w	r12[216],r7
8000ad62:	f9 47 00 dc 	st.w	r12[220],r7
8000ad66:	f9 47 00 e0 	st.w	r12[224],r7
8000ad6a:	99 65       	st.w	r12[0x18],r5
8000ad6c:	cb af       	rcall	8000ace0 <__sfp>
8000ad6e:	8d 0c       	st.w	r6[0x0],r12
8000ad70:	0c 9c       	mov	r12,r6
8000ad72:	cb 7f       	rcall	8000ace0 <__sfp>
8000ad74:	8d 1c       	st.w	r6[0x4],r12
8000ad76:	0c 9c       	mov	r12,r6
8000ad78:	cb 4f       	rcall	8000ace0 <__sfp>
8000ad7a:	6c 09       	ld.w	r9,r6[0x0]
8000ad7c:	30 48       	mov	r8,4
8000ad7e:	93 07       	st.w	r9[0x0],r7
8000ad80:	b2 68       	st.h	r9[0xc],r8
8000ad82:	93 17       	st.w	r9[0x4],r7
8000ad84:	93 27       	st.w	r9[0x8],r7
8000ad86:	6c 18       	ld.w	r8,r6[0x4]
8000ad88:	b2 77       	st.h	r9[0xe],r7
8000ad8a:	93 47       	st.w	r9[0x10],r7
8000ad8c:	93 57       	st.w	r9[0x14],r7
8000ad8e:	93 67       	st.w	r9[0x18],r7
8000ad90:	93 89       	st.w	r9[0x20],r9
8000ad92:	91 07       	st.w	r8[0x0],r7
8000ad94:	91 17       	st.w	r8[0x4],r7
8000ad96:	91 27       	st.w	r8[0x8],r7
8000ad98:	fe ce f3 24 	sub	lr,pc,-3292
8000ad9c:	fe cb f3 54 	sub	r11,pc,-3244
8000ada0:	93 9e       	st.w	r9[0x24],lr
8000ada2:	93 ab       	st.w	r9[0x28],r11
8000ada4:	fe ca f3 7c 	sub	r10,pc,-3204
8000ada8:	fe c4 f3 88 	sub	r4,pc,-3192
8000adac:	93 ba       	st.w	r9[0x2c],r10
8000adae:	93 c4       	st.w	r9[0x30],r4
8000adb0:	30 99       	mov	r9,9
8000adb2:	b0 69       	st.h	r8[0xc],r9
8000adb4:	b0 75       	st.h	r8[0xe],r5
8000adb6:	91 c4       	st.w	r8[0x30],r4
8000adb8:	91 47       	st.w	r8[0x10],r7
8000adba:	91 57       	st.w	r8[0x14],r7
8000adbc:	91 67       	st.w	r8[0x18],r7
8000adbe:	91 88       	st.w	r8[0x20],r8
8000adc0:	91 9e       	st.w	r8[0x24],lr
8000adc2:	91 ab       	st.w	r8[0x28],r11
8000adc4:	91 ba       	st.w	r8[0x2c],r10
8000adc6:	8d 2c       	st.w	r6[0x8],r12
8000adc8:	31 28       	mov	r8,18
8000adca:	99 07       	st.w	r12[0x0],r7
8000adcc:	b8 68       	st.h	r12[0xc],r8
8000adce:	99 17       	st.w	r12[0x4],r7
8000add0:	99 27       	st.w	r12[0x8],r7
8000add2:	30 28       	mov	r8,2
8000add4:	b8 78       	st.h	r12[0xe],r8
8000add6:	99 c4       	st.w	r12[0x30],r4
8000add8:	99 67       	st.w	r12[0x18],r7
8000adda:	99 9e       	st.w	r12[0x24],lr
8000addc:	99 ab       	st.w	r12[0x28],r11
8000adde:	99 ba       	st.w	r12[0x2c],r10
8000ade0:	99 47       	st.w	r12[0x10],r7
8000ade2:	99 57       	st.w	r12[0x14],r7
8000ade4:	99 8c       	st.w	r12[0x20],r12
8000ade6:	d8 22       	popm	r4-r7,pc

8000ade8 <_malloc_trim_r>:
8000ade8:	d4 21       	pushm	r4-r7,lr
8000adea:	16 95       	mov	r5,r11
8000adec:	18 97       	mov	r7,r12
8000adee:	fe b0 d7 f1 	rcall	80005dd0 <__malloc_lock>
8000adf2:	e0 64 05 38 	mov	r4,1336
8000adf6:	68 28       	ld.w	r8,r4[0x8]
8000adf8:	70 16       	ld.w	r6,r8[0x4]
8000adfa:	e0 16 ff fc 	andl	r6,0xfffc
8000adfe:	ec c8 ff 91 	sub	r8,r6,-111
8000ae02:	f0 05 01 05 	sub	r5,r8,r5
8000ae06:	e0 15 ff 80 	andl	r5,0xff80
8000ae0a:	ea c5 00 80 	sub	r5,r5,128
8000ae0e:	e0 45 00 7f 	cp.w	r5,127
8000ae12:	e0 8a 00 25 	brle	8000ae5c <_malloc_trim_r+0x74>
8000ae16:	30 0b       	mov	r11,0
8000ae18:	0e 9c       	mov	r12,r7
8000ae1a:	fe b0 e6 05 	rcall	80007a24 <_sbrk_r>
8000ae1e:	68 28       	ld.w	r8,r4[0x8]
8000ae20:	0c 08       	add	r8,r6
8000ae22:	10 3c       	cp.w	r12,r8
8000ae24:	c1 c1       	brne	8000ae5c <_malloc_trim_r+0x74>
8000ae26:	ea 0b 11 00 	rsub	r11,r5,0
8000ae2a:	0e 9c       	mov	r12,r7
8000ae2c:	fe b0 e5 fc 	rcall	80007a24 <_sbrk_r>
8000ae30:	5b fc       	cp.w	r12,-1
8000ae32:	c1 91       	brne	8000ae64 <_malloc_trim_r+0x7c>
8000ae34:	30 0b       	mov	r11,0
8000ae36:	0e 9c       	mov	r12,r7
8000ae38:	fe b0 e5 f6 	rcall	80007a24 <_sbrk_r>
8000ae3c:	68 28       	ld.w	r8,r4[0x8]
8000ae3e:	f8 08 01 09 	sub	r9,r12,r8
8000ae42:	58 f9       	cp.w	r9,15
8000ae44:	e0 8a 00 0c 	brle	8000ae5c <_malloc_trim_r+0x74>
8000ae48:	a1 a9       	sbr	r9,0x0
8000ae4a:	91 19       	st.w	r8[0x4],r9
8000ae4c:	e0 68 09 44 	mov	r8,2372
8000ae50:	70 09       	ld.w	r9,r8[0x0]
8000ae52:	e0 68 0d 58 	mov	r8,3416
8000ae56:	f8 09 01 09 	sub	r9,r12,r9
8000ae5a:	91 09       	st.w	r8[0x0],r9
8000ae5c:	0e 9c       	mov	r12,r7
8000ae5e:	fe b0 d7 bf 	rcall	80005ddc <__malloc_unlock>
8000ae62:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae64:	68 28       	ld.w	r8,r4[0x8]
8000ae66:	0a 16       	sub	r6,r5
8000ae68:	a1 a6       	sbr	r6,0x0
8000ae6a:	91 16       	st.w	r8[0x4],r6
8000ae6c:	e0 68 0d 58 	mov	r8,3416
8000ae70:	70 09       	ld.w	r9,r8[0x0]
8000ae72:	0a 19       	sub	r9,r5
8000ae74:	0e 9c       	mov	r12,r7
8000ae76:	91 09       	st.w	r8[0x0],r9
8000ae78:	fe b0 d7 b2 	rcall	80005ddc <__malloc_unlock>
8000ae7c:	da 2a       	popm	r4-r7,pc,r12=1
8000ae7e:	d7 03       	nop

8000ae80 <_free_r>:
8000ae80:	d4 21       	pushm	r4-r7,lr
8000ae82:	16 96       	mov	r6,r11
8000ae84:	18 97       	mov	r7,r12
8000ae86:	58 0b       	cp.w	r11,0
8000ae88:	e0 80 00 c0 	breq	8000b008 <_free_r+0x188>
8000ae8c:	fe b0 d7 a2 	rcall	80005dd0 <__malloc_lock>
8000ae90:	20 86       	sub	r6,8
8000ae92:	e0 6a 05 38 	mov	r10,1336
8000ae96:	6c 18       	ld.w	r8,r6[0x4]
8000ae98:	74 2e       	ld.w	lr,r10[0x8]
8000ae9a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ae9e:	a1 c8       	cbr	r8,0x0
8000aea0:	ec 08 00 09 	add	r9,r6,r8
8000aea4:	72 1b       	ld.w	r11,r9[0x4]
8000aea6:	e0 1b ff fc 	andl	r11,0xfffc
8000aeaa:	1c 39       	cp.w	r9,lr
8000aeac:	c1 e1       	brne	8000aee8 <_free_r+0x68>
8000aeae:	f6 08 00 08 	add	r8,r11,r8
8000aeb2:	58 0c       	cp.w	r12,0
8000aeb4:	c0 81       	brne	8000aec4 <_free_r+0x44>
8000aeb6:	6c 09       	ld.w	r9,r6[0x0]
8000aeb8:	12 16       	sub	r6,r9
8000aeba:	12 08       	add	r8,r9
8000aebc:	6c 3b       	ld.w	r11,r6[0xc]
8000aebe:	6c 29       	ld.w	r9,r6[0x8]
8000aec0:	97 29       	st.w	r11[0x8],r9
8000aec2:	93 3b       	st.w	r9[0xc],r11
8000aec4:	10 99       	mov	r9,r8
8000aec6:	95 26       	st.w	r10[0x8],r6
8000aec8:	a1 a9       	sbr	r9,0x0
8000aeca:	8d 19       	st.w	r6[0x4],r9
8000aecc:	e0 69 09 40 	mov	r9,2368
8000aed0:	72 09       	ld.w	r9,r9[0x0]
8000aed2:	12 38       	cp.w	r8,r9
8000aed4:	c0 63       	brcs	8000aee0 <_free_r+0x60>
8000aed6:	e0 68 0d 54 	mov	r8,3412
8000aeda:	0e 9c       	mov	r12,r7
8000aedc:	70 0b       	ld.w	r11,r8[0x0]
8000aede:	c8 5f       	rcall	8000ade8 <_malloc_trim_r>
8000aee0:	0e 9c       	mov	r12,r7
8000aee2:	fe b0 d7 7d 	rcall	80005ddc <__malloc_unlock>
8000aee6:	d8 22       	popm	r4-r7,pc
8000aee8:	93 1b       	st.w	r9[0x4],r11
8000aeea:	58 0c       	cp.w	r12,0
8000aeec:	c0 30       	breq	8000aef2 <_free_r+0x72>
8000aeee:	30 0c       	mov	r12,0
8000aef0:	c1 08       	rjmp	8000af10 <_free_r+0x90>
8000aef2:	6c 0e       	ld.w	lr,r6[0x0]
8000aef4:	f4 c5 ff f8 	sub	r5,r10,-8
8000aef8:	1c 16       	sub	r6,lr
8000aefa:	1c 08       	add	r8,lr
8000aefc:	6c 2e       	ld.w	lr,r6[0x8]
8000aefe:	0a 3e       	cp.w	lr,r5
8000af00:	f9 bc 00 01 	moveq	r12,1
8000af04:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000af08:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000af0c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000af10:	f2 0b 00 0e 	add	lr,r9,r11
8000af14:	7c 1e       	ld.w	lr,lr[0x4]
8000af16:	ed be 00 00 	bld	lr,0x0
8000af1a:	c1 40       	breq	8000af42 <_free_r+0xc2>
8000af1c:	16 08       	add	r8,r11
8000af1e:	58 0c       	cp.w	r12,0
8000af20:	c0 d1       	brne	8000af3a <_free_r+0xba>
8000af22:	e0 6e 05 38 	mov	lr,1336
8000af26:	72 2b       	ld.w	r11,r9[0x8]
8000af28:	2f 8e       	sub	lr,-8
8000af2a:	1c 3b       	cp.w	r11,lr
8000af2c:	c0 71       	brne	8000af3a <_free_r+0xba>
8000af2e:	97 36       	st.w	r11[0xc],r6
8000af30:	97 26       	st.w	r11[0x8],r6
8000af32:	8d 2b       	st.w	r6[0x8],r11
8000af34:	8d 3b       	st.w	r6[0xc],r11
8000af36:	30 1c       	mov	r12,1
8000af38:	c0 58       	rjmp	8000af42 <_free_r+0xc2>
8000af3a:	72 2b       	ld.w	r11,r9[0x8]
8000af3c:	72 39       	ld.w	r9,r9[0xc]
8000af3e:	93 2b       	st.w	r9[0x8],r11
8000af40:	97 39       	st.w	r11[0xc],r9
8000af42:	10 99       	mov	r9,r8
8000af44:	ec 08 09 08 	st.w	r6[r8],r8
8000af48:	a1 a9       	sbr	r9,0x0
8000af4a:	8d 19       	st.w	r6[0x4],r9
8000af4c:	58 0c       	cp.w	r12,0
8000af4e:	c5 a1       	brne	8000b002 <_free_r+0x182>
8000af50:	e0 48 01 ff 	cp.w	r8,511
8000af54:	e0 8b 00 13 	brhi	8000af7a <_free_r+0xfa>
8000af58:	a3 98       	lsr	r8,0x3
8000af5a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000af5e:	72 2b       	ld.w	r11,r9[0x8]
8000af60:	8d 39       	st.w	r6[0xc],r9
8000af62:	8d 2b       	st.w	r6[0x8],r11
8000af64:	97 36       	st.w	r11[0xc],r6
8000af66:	93 26       	st.w	r9[0x8],r6
8000af68:	a3 48       	asr	r8,0x2
8000af6a:	74 19       	ld.w	r9,r10[0x4]
8000af6c:	30 1b       	mov	r11,1
8000af6e:	f6 08 09 48 	lsl	r8,r11,r8
8000af72:	f3 e8 10 08 	or	r8,r9,r8
8000af76:	95 18       	st.w	r10[0x4],r8
8000af78:	c4 58       	rjmp	8000b002 <_free_r+0x182>
8000af7a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000af7e:	58 4b       	cp.w	r11,4
8000af80:	e0 8b 00 06 	brhi	8000af8c <_free_r+0x10c>
8000af84:	f0 0b 16 06 	lsr	r11,r8,0x6
8000af88:	2c 8b       	sub	r11,-56
8000af8a:	c2 08       	rjmp	8000afca <_free_r+0x14a>
8000af8c:	59 4b       	cp.w	r11,20
8000af8e:	e0 8b 00 04 	brhi	8000af96 <_free_r+0x116>
8000af92:	2a 5b       	sub	r11,-91
8000af94:	c1 b8       	rjmp	8000afca <_free_r+0x14a>
8000af96:	e0 4b 00 54 	cp.w	r11,84
8000af9a:	e0 8b 00 06 	brhi	8000afa6 <_free_r+0x126>
8000af9e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000afa2:	29 2b       	sub	r11,-110
8000afa4:	c1 38       	rjmp	8000afca <_free_r+0x14a>
8000afa6:	e0 4b 01 54 	cp.w	r11,340
8000afaa:	e0 8b 00 06 	brhi	8000afb6 <_free_r+0x136>
8000afae:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000afb2:	28 9b       	sub	r11,-119
8000afb4:	c0 b8       	rjmp	8000afca <_free_r+0x14a>
8000afb6:	e0 4b 05 54 	cp.w	r11,1364
8000afba:	e0 88 00 05 	brls	8000afc4 <_free_r+0x144>
8000afbe:	37 eb       	mov	r11,126
8000afc0:	c0 58       	rjmp	8000afca <_free_r+0x14a>
8000afc2:	d7 03       	nop
8000afc4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000afc8:	28 4b       	sub	r11,-124
8000afca:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000afce:	78 29       	ld.w	r9,r12[0x8]
8000afd0:	18 39       	cp.w	r9,r12
8000afd2:	c0 e1       	brne	8000afee <_free_r+0x16e>
8000afd4:	74 18       	ld.w	r8,r10[0x4]
8000afd6:	a3 4b       	asr	r11,0x2
8000afd8:	30 1c       	mov	r12,1
8000afda:	f8 0b 09 4b 	lsl	r11,r12,r11
8000afde:	f1 eb 10 0b 	or	r11,r8,r11
8000afe2:	12 98       	mov	r8,r9
8000afe4:	95 1b       	st.w	r10[0x4],r11
8000afe6:	c0 a8       	rjmp	8000affa <_free_r+0x17a>
8000afe8:	72 29       	ld.w	r9,r9[0x8]
8000afea:	18 39       	cp.w	r9,r12
8000afec:	c0 60       	breq	8000aff8 <_free_r+0x178>
8000afee:	72 1a       	ld.w	r10,r9[0x4]
8000aff0:	e0 1a ff fc 	andl	r10,0xfffc
8000aff4:	14 38       	cp.w	r8,r10
8000aff6:	cf 93       	brcs	8000afe8 <_free_r+0x168>
8000aff8:	72 38       	ld.w	r8,r9[0xc]
8000affa:	8d 38       	st.w	r6[0xc],r8
8000affc:	8d 29       	st.w	r6[0x8],r9
8000affe:	93 36       	st.w	r9[0xc],r6
8000b000:	91 26       	st.w	r8[0x8],r6
8000b002:	0e 9c       	mov	r12,r7
8000b004:	fe b0 d6 ec 	rcall	80005ddc <__malloc_unlock>
8000b008:	d8 22       	popm	r4-r7,pc
8000b00a:	d7 03       	nop

8000b00c <__sfvwrite_r>:
8000b00c:	d4 31       	pushm	r0-r7,lr
8000b00e:	20 3d       	sub	sp,12
8000b010:	14 94       	mov	r4,r10
8000b012:	18 95       	mov	r5,r12
8000b014:	16 97       	mov	r7,r11
8000b016:	74 28       	ld.w	r8,r10[0x8]
8000b018:	58 08       	cp.w	r8,0
8000b01a:	e0 80 01 40 	breq	8000b29a <__sfvwrite_r+0x28e>
8000b01e:	96 68       	ld.sh	r8,r11[0xc]
8000b020:	ed b8 00 03 	bld	r8,0x3
8000b024:	c0 41       	brne	8000b02c <__sfvwrite_r+0x20>
8000b026:	76 48       	ld.w	r8,r11[0x10]
8000b028:	58 08       	cp.w	r8,0
8000b02a:	c0 c1       	brne	8000b042 <__sfvwrite_r+0x36>
8000b02c:	0e 9b       	mov	r11,r7
8000b02e:	0a 9c       	mov	r12,r5
8000b030:	fe b0 f6 c4 	rcall	80009db8 <__swsetup_r>
8000b034:	c0 70       	breq	8000b042 <__sfvwrite_r+0x36>
8000b036:	8e 68       	ld.sh	r8,r7[0xc]
8000b038:	a7 a8       	sbr	r8,0x6
8000b03a:	ae 68       	st.h	r7[0xc],r8
8000b03c:	30 98       	mov	r8,9
8000b03e:	8b 38       	st.w	r5[0xc],r8
8000b040:	c2 b9       	rjmp	8000b296 <__sfvwrite_r+0x28a>
8000b042:	8e 63       	ld.sh	r3,r7[0xc]
8000b044:	68 00       	ld.w	r0,r4[0x0]
8000b046:	06 96       	mov	r6,r3
8000b048:	e2 16 00 02 	andl	r6,0x2,COH
8000b04c:	c2 10       	breq	8000b08e <__sfvwrite_r+0x82>
8000b04e:	30 03       	mov	r3,0
8000b050:	e0 62 04 00 	mov	r2,1024
8000b054:	06 96       	mov	r6,r3
8000b056:	c0 48       	rjmp	8000b05e <__sfvwrite_r+0x52>
8000b058:	60 03       	ld.w	r3,r0[0x0]
8000b05a:	60 16       	ld.w	r6,r0[0x4]
8000b05c:	2f 80       	sub	r0,-8
8000b05e:	58 06       	cp.w	r6,0
8000b060:	cf c0       	breq	8000b058 <__sfvwrite_r+0x4c>
8000b062:	e0 46 04 00 	cp.w	r6,1024
8000b066:	ec 09 17 80 	movls	r9,r6
8000b06a:	e4 09 17 b0 	movhi	r9,r2
8000b06e:	06 9a       	mov	r10,r3
8000b070:	6e a8       	ld.w	r8,r7[0x28]
8000b072:	6e 8b       	ld.w	r11,r7[0x20]
8000b074:	0a 9c       	mov	r12,r5
8000b076:	5d 18       	icall	r8
8000b078:	18 16       	sub	r6,r12
8000b07a:	58 0c       	cp.w	r12,0
8000b07c:	e0 8a 01 0a 	brle	8000b290 <__sfvwrite_r+0x284>
8000b080:	68 28       	ld.w	r8,r4[0x8]
8000b082:	18 18       	sub	r8,r12
8000b084:	89 28       	st.w	r4[0x8],r8
8000b086:	e0 80 01 0a 	breq	8000b29a <__sfvwrite_r+0x28e>
8000b08a:	18 03       	add	r3,r12
8000b08c:	ce 9b       	rjmp	8000b05e <__sfvwrite_r+0x52>
8000b08e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b092:	c0 70       	breq	8000b0a0 <__sfvwrite_r+0x94>
8000b094:	50 06       	stdsp	sp[0x0],r6
8000b096:	0c 93       	mov	r3,r6
8000b098:	0c 91       	mov	r1,r6
8000b09a:	50 15       	stdsp	sp[0x4],r5
8000b09c:	08 92       	mov	r2,r4
8000b09e:	c9 c8       	rjmp	8000b1d6 <__sfvwrite_r+0x1ca>
8000b0a0:	06 96       	mov	r6,r3
8000b0a2:	08 91       	mov	r1,r4
8000b0a4:	c0 48       	rjmp	8000b0ac <__sfvwrite_r+0xa0>
8000b0a6:	60 03       	ld.w	r3,r0[0x0]
8000b0a8:	60 16       	ld.w	r6,r0[0x4]
8000b0aa:	2f 80       	sub	r0,-8
8000b0ac:	58 06       	cp.w	r6,0
8000b0ae:	cf c0       	breq	8000b0a6 <__sfvwrite_r+0x9a>
8000b0b0:	8e 68       	ld.sh	r8,r7[0xc]
8000b0b2:	6e 24       	ld.w	r4,r7[0x8]
8000b0b4:	10 99       	mov	r9,r8
8000b0b6:	e2 19 02 00 	andl	r9,0x200,COH
8000b0ba:	c5 50       	breq	8000b164 <__sfvwrite_r+0x158>
8000b0bc:	08 36       	cp.w	r6,r4
8000b0be:	c4 43       	brcs	8000b146 <__sfvwrite_r+0x13a>
8000b0c0:	10 99       	mov	r9,r8
8000b0c2:	e2 19 04 80 	andl	r9,0x480,COH
8000b0c6:	c4 00       	breq	8000b146 <__sfvwrite_r+0x13a>
8000b0c8:	6e 4b       	ld.w	r11,r7[0x10]
8000b0ca:	6e 09       	ld.w	r9,r7[0x0]
8000b0cc:	16 19       	sub	r9,r11
8000b0ce:	50 09       	stdsp	sp[0x0],r9
8000b0d0:	6e 59       	ld.w	r9,r7[0x14]
8000b0d2:	10 9c       	mov	r12,r8
8000b0d4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b0d8:	30 28       	mov	r8,2
8000b0da:	f4 08 0c 08 	divs	r8,r10,r8
8000b0de:	fa e9 00 04 	st.d	sp[4],r8
8000b0e2:	10 94       	mov	r4,r8
8000b0e4:	40 09       	lddsp	r9,sp[0x0]
8000b0e6:	e2 1c 04 00 	andl	r12,0x400,COH
8000b0ea:	2f f9       	sub	r9,-1
8000b0ec:	0c 09       	add	r9,r6
8000b0ee:	12 38       	cp.w	r8,r9
8000b0f0:	f2 04 17 30 	movlo	r4,r9
8000b0f4:	58 0c       	cp.w	r12,0
8000b0f6:	c1 10       	breq	8000b118 <__sfvwrite_r+0x10c>
8000b0f8:	08 9b       	mov	r11,r4
8000b0fa:	0a 9c       	mov	r12,r5
8000b0fc:	fe b0 e0 6c 	rcall	800071d4 <_malloc_r>
8000b100:	18 92       	mov	r2,r12
8000b102:	c1 40       	breq	8000b12a <__sfvwrite_r+0x11e>
8000b104:	40 0a       	lddsp	r10,sp[0x0]
8000b106:	6e 4b       	ld.w	r11,r7[0x10]
8000b108:	fe b0 e2 82 	rcall	8000760c <memcpy>
8000b10c:	8e 68       	ld.sh	r8,r7[0xc]
8000b10e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b112:	a7 b8       	sbr	r8,0x7
8000b114:	ae 68       	st.h	r7[0xc],r8
8000b116:	c0 d8       	rjmp	8000b130 <__sfvwrite_r+0x124>
8000b118:	08 9a       	mov	r10,r4
8000b11a:	0a 9c       	mov	r12,r5
8000b11c:	fe b0 e3 24 	rcall	80007764 <_realloc_r>
8000b120:	18 92       	mov	r2,r12
8000b122:	c0 71       	brne	8000b130 <__sfvwrite_r+0x124>
8000b124:	6e 4b       	ld.w	r11,r7[0x10]
8000b126:	0a 9c       	mov	r12,r5
8000b128:	ca ce       	rcall	8000ae80 <_free_r>
8000b12a:	30 c8       	mov	r8,12
8000b12c:	8b 38       	st.w	r5[0xc],r8
8000b12e:	cb 18       	rjmp	8000b290 <__sfvwrite_r+0x284>
8000b130:	40 0a       	lddsp	r10,sp[0x0]
8000b132:	40 09       	lddsp	r9,sp[0x0]
8000b134:	e8 0a 01 0a 	sub	r10,r4,r10
8000b138:	e4 09 00 08 	add	r8,r2,r9
8000b13c:	8f 54       	st.w	r7[0x14],r4
8000b13e:	8f 2a       	st.w	r7[0x8],r10
8000b140:	8f 08       	st.w	r7[0x0],r8
8000b142:	8f 42       	st.w	r7[0x10],r2
8000b144:	0c 94       	mov	r4,r6
8000b146:	08 36       	cp.w	r6,r4
8000b148:	ec 04 17 30 	movlo	r4,r6
8000b14c:	06 9b       	mov	r11,r3
8000b14e:	08 9a       	mov	r10,r4
8000b150:	6e 0c       	ld.w	r12,r7[0x0]
8000b152:	c3 ad       	rcall	8000b3c6 <memmove>
8000b154:	6e 08       	ld.w	r8,r7[0x0]
8000b156:	08 08       	add	r8,r4
8000b158:	8f 08       	st.w	r7[0x0],r8
8000b15a:	6e 28       	ld.w	r8,r7[0x8]
8000b15c:	08 18       	sub	r8,r4
8000b15e:	0c 94       	mov	r4,r6
8000b160:	8f 28       	st.w	r7[0x8],r8
8000b162:	c2 e8       	rjmp	8000b1be <__sfvwrite_r+0x1b2>
8000b164:	08 36       	cp.w	r6,r4
8000b166:	5f ba       	srhi	r10
8000b168:	6e 0c       	ld.w	r12,r7[0x0]
8000b16a:	6e 48       	ld.w	r8,r7[0x10]
8000b16c:	10 3c       	cp.w	r12,r8
8000b16e:	5f b8       	srhi	r8
8000b170:	f5 e8 00 08 	and	r8,r10,r8
8000b174:	f2 08 18 00 	cp.b	r8,r9
8000b178:	c0 d0       	breq	8000b192 <__sfvwrite_r+0x186>
8000b17a:	06 9b       	mov	r11,r3
8000b17c:	08 9a       	mov	r10,r4
8000b17e:	c2 4d       	rcall	8000b3c6 <memmove>
8000b180:	6e 08       	ld.w	r8,r7[0x0]
8000b182:	08 08       	add	r8,r4
8000b184:	0e 9b       	mov	r11,r7
8000b186:	8f 08       	st.w	r7[0x0],r8
8000b188:	0a 9c       	mov	r12,r5
8000b18a:	fe b0 fd 09 	rcall	8000ab9c <_fflush_r>
8000b18e:	c1 80       	breq	8000b1be <__sfvwrite_r+0x1b2>
8000b190:	c8 08       	rjmp	8000b290 <__sfvwrite_r+0x284>
8000b192:	6e 59       	ld.w	r9,r7[0x14]
8000b194:	12 36       	cp.w	r6,r9
8000b196:	c0 a3       	brcs	8000b1aa <__sfvwrite_r+0x19e>
8000b198:	6e a8       	ld.w	r8,r7[0x28]
8000b19a:	06 9a       	mov	r10,r3
8000b19c:	6e 8b       	ld.w	r11,r7[0x20]
8000b19e:	0a 9c       	mov	r12,r5
8000b1a0:	5d 18       	icall	r8
8000b1a2:	18 94       	mov	r4,r12
8000b1a4:	e0 89 00 0d 	brgt	8000b1be <__sfvwrite_r+0x1b2>
8000b1a8:	c7 48       	rjmp	8000b290 <__sfvwrite_r+0x284>
8000b1aa:	0c 9a       	mov	r10,r6
8000b1ac:	06 9b       	mov	r11,r3
8000b1ae:	c0 cd       	rcall	8000b3c6 <memmove>
8000b1b0:	6e 08       	ld.w	r8,r7[0x0]
8000b1b2:	0c 08       	add	r8,r6
8000b1b4:	0c 94       	mov	r4,r6
8000b1b6:	8f 08       	st.w	r7[0x0],r8
8000b1b8:	6e 28       	ld.w	r8,r7[0x8]
8000b1ba:	0c 18       	sub	r8,r6
8000b1bc:	8f 28       	st.w	r7[0x8],r8
8000b1be:	62 28       	ld.w	r8,r1[0x8]
8000b1c0:	08 18       	sub	r8,r4
8000b1c2:	83 28       	st.w	r1[0x8],r8
8000b1c4:	c6 b0       	breq	8000b29a <__sfvwrite_r+0x28e>
8000b1c6:	08 16       	sub	r6,r4
8000b1c8:	08 03       	add	r3,r4
8000b1ca:	c7 1b       	rjmp	8000b0ac <__sfvwrite_r+0xa0>
8000b1cc:	60 03       	ld.w	r3,r0[0x0]
8000b1ce:	60 11       	ld.w	r1,r0[0x4]
8000b1d0:	30 08       	mov	r8,0
8000b1d2:	2f 80       	sub	r0,-8
8000b1d4:	50 08       	stdsp	sp[0x0],r8
8000b1d6:	58 01       	cp.w	r1,0
8000b1d8:	cf a0       	breq	8000b1cc <__sfvwrite_r+0x1c0>
8000b1da:	40 0a       	lddsp	r10,sp[0x0]
8000b1dc:	58 0a       	cp.w	r10,0
8000b1de:	c1 41       	brne	8000b206 <__sfvwrite_r+0x1fa>
8000b1e0:	e2 c6 ff ff 	sub	r6,r1,-1
8000b1e4:	02 9a       	mov	r10,r1
8000b1e6:	30 ab       	mov	r11,10
8000b1e8:	06 9c       	mov	r12,r3
8000b1ea:	ce 3c       	rcall	8000b3b0 <memchr>
8000b1ec:	f8 c8 ff ff 	sub	r8,r12,-1
8000b1f0:	58 0c       	cp.w	r12,0
8000b1f2:	f1 d3 e1 16 	subne	r6,r8,r3
8000b1f6:	f9 b9 01 01 	movne	r9,1
8000b1fa:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b1fe:	f9 b8 00 01 	moveq	r8,1
8000b202:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b206:	02 36       	cp.w	r6,r1
8000b208:	ec 04 17 80 	movls	r4,r6
8000b20c:	e2 04 17 b0 	movhi	r4,r1
8000b210:	6e 59       	ld.w	r9,r7[0x14]
8000b212:	6e 25       	ld.w	r5,r7[0x8]
8000b214:	f2 05 00 05 	add	r5,r9,r5
8000b218:	0a 34       	cp.w	r4,r5
8000b21a:	5f 9a       	srgt	r10
8000b21c:	6e 0c       	ld.w	r12,r7[0x0]
8000b21e:	6e 48       	ld.w	r8,r7[0x10]
8000b220:	10 3c       	cp.w	r12,r8
8000b222:	5f b8       	srhi	r8
8000b224:	f5 e8 00 08 	and	r8,r10,r8
8000b228:	30 0a       	mov	r10,0
8000b22a:	f4 08 18 00 	cp.b	r8,r10
8000b22e:	c0 d0       	breq	8000b248 <__sfvwrite_r+0x23c>
8000b230:	06 9b       	mov	r11,r3
8000b232:	0a 9a       	mov	r10,r5
8000b234:	cc 9c       	rcall	8000b3c6 <memmove>
8000b236:	6e 08       	ld.w	r8,r7[0x0]
8000b238:	0a 08       	add	r8,r5
8000b23a:	0e 9b       	mov	r11,r7
8000b23c:	8f 08       	st.w	r7[0x0],r8
8000b23e:	40 1c       	lddsp	r12,sp[0x4]
8000b240:	fe b0 fc ae 	rcall	8000ab9c <_fflush_r>
8000b244:	c1 70       	breq	8000b272 <__sfvwrite_r+0x266>
8000b246:	c2 58       	rjmp	8000b290 <__sfvwrite_r+0x284>
8000b248:	12 34       	cp.w	r4,r9
8000b24a:	c0 a5       	brlt	8000b25e <__sfvwrite_r+0x252>
8000b24c:	6e a8       	ld.w	r8,r7[0x28]
8000b24e:	06 9a       	mov	r10,r3
8000b250:	6e 8b       	ld.w	r11,r7[0x20]
8000b252:	40 1c       	lddsp	r12,sp[0x4]
8000b254:	5d 18       	icall	r8
8000b256:	18 95       	mov	r5,r12
8000b258:	e0 89 00 0d 	brgt	8000b272 <__sfvwrite_r+0x266>
8000b25c:	c1 a8       	rjmp	8000b290 <__sfvwrite_r+0x284>
8000b25e:	08 9a       	mov	r10,r4
8000b260:	06 9b       	mov	r11,r3
8000b262:	cb 2c       	rcall	8000b3c6 <memmove>
8000b264:	6e 08       	ld.w	r8,r7[0x0]
8000b266:	08 08       	add	r8,r4
8000b268:	08 95       	mov	r5,r4
8000b26a:	8f 08       	st.w	r7[0x0],r8
8000b26c:	6e 28       	ld.w	r8,r7[0x8]
8000b26e:	08 18       	sub	r8,r4
8000b270:	8f 28       	st.w	r7[0x8],r8
8000b272:	0a 16       	sub	r6,r5
8000b274:	c0 71       	brne	8000b282 <__sfvwrite_r+0x276>
8000b276:	0e 9b       	mov	r11,r7
8000b278:	40 1c       	lddsp	r12,sp[0x4]
8000b27a:	fe b0 fc 91 	rcall	8000ab9c <_fflush_r>
8000b27e:	c0 91       	brne	8000b290 <__sfvwrite_r+0x284>
8000b280:	50 06       	stdsp	sp[0x0],r6
8000b282:	64 28       	ld.w	r8,r2[0x8]
8000b284:	0a 18       	sub	r8,r5
8000b286:	85 28       	st.w	r2[0x8],r8
8000b288:	c0 90       	breq	8000b29a <__sfvwrite_r+0x28e>
8000b28a:	0a 11       	sub	r1,r5
8000b28c:	0a 03       	add	r3,r5
8000b28e:	ca 4b       	rjmp	8000b1d6 <__sfvwrite_r+0x1ca>
8000b290:	8e 68       	ld.sh	r8,r7[0xc]
8000b292:	a7 a8       	sbr	r8,0x6
8000b294:	ae 68       	st.h	r7[0xc],r8
8000b296:	3f fc       	mov	r12,-1
8000b298:	c0 28       	rjmp	8000b29c <__sfvwrite_r+0x290>
8000b29a:	30 0c       	mov	r12,0
8000b29c:	2f dd       	sub	sp,-12
8000b29e:	d8 32       	popm	r0-r7,pc

8000b2a0 <_fwalk>:
8000b2a0:	d4 31       	pushm	r0-r7,lr
8000b2a2:	30 05       	mov	r5,0
8000b2a4:	16 91       	mov	r1,r11
8000b2a6:	f8 c7 ff 28 	sub	r7,r12,-216
8000b2aa:	0a 92       	mov	r2,r5
8000b2ac:	fe b0 fc fe 	rcall	8000aca8 <__sfp_lock_acquire>
8000b2b0:	3f f3       	mov	r3,-1
8000b2b2:	c1 68       	rjmp	8000b2de <_fwalk+0x3e>
8000b2b4:	6e 26       	ld.w	r6,r7[0x8]
8000b2b6:	6e 14       	ld.w	r4,r7[0x4]
8000b2b8:	2f 46       	sub	r6,-12
8000b2ba:	c0 c8       	rjmp	8000b2d2 <_fwalk+0x32>
8000b2bc:	8c 08       	ld.sh	r8,r6[0x0]
8000b2be:	e4 08 19 00 	cp.h	r8,r2
8000b2c2:	c0 70       	breq	8000b2d0 <_fwalk+0x30>
8000b2c4:	8c 18       	ld.sh	r8,r6[0x2]
8000b2c6:	e6 08 19 00 	cp.h	r8,r3
8000b2ca:	c0 30       	breq	8000b2d0 <_fwalk+0x30>
8000b2cc:	5d 11       	icall	r1
8000b2ce:	18 45       	or	r5,r12
8000b2d0:	2a 46       	sub	r6,-92
8000b2d2:	20 14       	sub	r4,1
8000b2d4:	ec cc 00 0c 	sub	r12,r6,12
8000b2d8:	58 04       	cp.w	r4,0
8000b2da:	cf 14       	brge	8000b2bc <_fwalk+0x1c>
8000b2dc:	6e 07       	ld.w	r7,r7[0x0]
8000b2de:	58 07       	cp.w	r7,0
8000b2e0:	ce a1       	brne	8000b2b4 <_fwalk+0x14>
8000b2e2:	fe b0 fc e4 	rcall	8000acaa <__sfp_lock_release>
8000b2e6:	0a 9c       	mov	r12,r5
8000b2e8:	d8 32       	popm	r0-r7,pc
8000b2ea:	d7 03       	nop

8000b2ec <_localeconv_r>:
8000b2ec:	fe cc d4 c8 	sub	r12,pc,-11064
8000b2f0:	5e fc       	retal	r12
8000b2f2:	d7 03       	nop

8000b2f4 <__smakebuf_r>:
8000b2f4:	d4 21       	pushm	r4-r7,lr
8000b2f6:	20 fd       	sub	sp,60
8000b2f8:	96 68       	ld.sh	r8,r11[0xc]
8000b2fa:	16 97       	mov	r7,r11
8000b2fc:	18 96       	mov	r6,r12
8000b2fe:	e2 18 00 02 	andl	r8,0x2,COH
8000b302:	c3 d1       	brne	8000b37c <__smakebuf_r+0x88>
8000b304:	96 7b       	ld.sh	r11,r11[0xe]
8000b306:	f0 0b 19 00 	cp.h	r11,r8
8000b30a:	c0 55       	brlt	8000b314 <__smakebuf_r+0x20>
8000b30c:	1a 9a       	mov	r10,sp
8000b30e:	e0 a0 04 81 	rcall	8000bc10 <_fstat_r>
8000b312:	c0 f4       	brge	8000b330 <__smakebuf_r+0x3c>
8000b314:	8e 65       	ld.sh	r5,r7[0xc]
8000b316:	0a 98       	mov	r8,r5
8000b318:	ab b8       	sbr	r8,0xb
8000b31a:	e2 15 00 80 	andl	r5,0x80,COH
8000b31e:	ae 68       	st.h	r7[0xc],r8
8000b320:	30 04       	mov	r4,0
8000b322:	e0 68 04 00 	mov	r8,1024
8000b326:	f9 b5 01 40 	movne	r5,64
8000b32a:	f0 05 17 00 	moveq	r5,r8
8000b32e:	c1 c8       	rjmp	8000b366 <__smakebuf_r+0x72>
8000b330:	40 18       	lddsp	r8,sp[0x4]
8000b332:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b336:	e0 48 20 00 	cp.w	r8,8192
8000b33a:	5f 04       	sreq	r4
8000b33c:	e0 48 80 00 	cp.w	r8,32768
8000b340:	c0 e1       	brne	8000b35c <__smakebuf_r+0x68>
8000b342:	6e b9       	ld.w	r9,r7[0x2c]
8000b344:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b348:	10 39       	cp.w	r9,r8
8000b34a:	c0 91       	brne	8000b35c <__smakebuf_r+0x68>
8000b34c:	8e 68       	ld.sh	r8,r7[0xc]
8000b34e:	e0 65 04 00 	mov	r5,1024
8000b352:	ab a8       	sbr	r8,0xa
8000b354:	ef 45 00 50 	st.w	r7[80],r5
8000b358:	ae 68       	st.h	r7[0xc],r8
8000b35a:	c0 68       	rjmp	8000b366 <__smakebuf_r+0x72>
8000b35c:	8e 68       	ld.sh	r8,r7[0xc]
8000b35e:	e0 65 04 00 	mov	r5,1024
8000b362:	ab b8       	sbr	r8,0xb
8000b364:	ae 68       	st.h	r7[0xc],r8
8000b366:	0a 9b       	mov	r11,r5
8000b368:	0c 9c       	mov	r12,r6
8000b36a:	fe b0 df 35 	rcall	800071d4 <_malloc_r>
8000b36e:	8e 68       	ld.sh	r8,r7[0xc]
8000b370:	c0 d1       	brne	8000b38a <__smakebuf_r+0x96>
8000b372:	ed b8 00 09 	bld	r8,0x9
8000b376:	c1 b0       	breq	8000b3ac <__smakebuf_r+0xb8>
8000b378:	a1 b8       	sbr	r8,0x1
8000b37a:	ae 68       	st.h	r7[0xc],r8
8000b37c:	ee c8 ff b9 	sub	r8,r7,-71
8000b380:	8f 48       	st.w	r7[0x10],r8
8000b382:	8f 08       	st.w	r7[0x0],r8
8000b384:	30 18       	mov	r8,1
8000b386:	8f 58       	st.w	r7[0x14],r8
8000b388:	c1 28       	rjmp	8000b3ac <__smakebuf_r+0xb8>
8000b38a:	a7 b8       	sbr	r8,0x7
8000b38c:	8f 4c       	st.w	r7[0x10],r12
8000b38e:	ae 68       	st.h	r7[0xc],r8
8000b390:	8f 55       	st.w	r7[0x14],r5
8000b392:	fe c8 06 e6 	sub	r8,pc,1766
8000b396:	8f 0c       	st.w	r7[0x0],r12
8000b398:	8d a8       	st.w	r6[0x28],r8
8000b39a:	58 04       	cp.w	r4,0
8000b39c:	c0 80       	breq	8000b3ac <__smakebuf_r+0xb8>
8000b39e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b3a0:	fe b0 e3 94 	rcall	80007ac8 <isatty>
8000b3a4:	c0 40       	breq	8000b3ac <__smakebuf_r+0xb8>
8000b3a6:	8e 68       	ld.sh	r8,r7[0xc]
8000b3a8:	a1 a8       	sbr	r8,0x0
8000b3aa:	ae 68       	st.h	r7[0xc],r8
8000b3ac:	2f 1d       	sub	sp,-60
8000b3ae:	d8 22       	popm	r4-r7,pc

8000b3b0 <memchr>:
8000b3b0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b3b4:	c0 68       	rjmp	8000b3c0 <memchr+0x10>
8000b3b6:	20 1a       	sub	r10,1
8000b3b8:	19 88       	ld.ub	r8,r12[0x0]
8000b3ba:	16 38       	cp.w	r8,r11
8000b3bc:	5e 0c       	reteq	r12
8000b3be:	2f fc       	sub	r12,-1
8000b3c0:	58 0a       	cp.w	r10,0
8000b3c2:	cf a1       	brne	8000b3b6 <memchr+0x6>
8000b3c4:	5e fa       	retal	r10

8000b3c6 <memmove>:
8000b3c6:	d4 01       	pushm	lr
8000b3c8:	18 3b       	cp.w	r11,r12
8000b3ca:	c1 92       	brcc	8000b3fc <memmove+0x36>
8000b3cc:	f6 0a 00 09 	add	r9,r11,r10
8000b3d0:	12 3c       	cp.w	r12,r9
8000b3d2:	c1 52       	brcc	8000b3fc <memmove+0x36>
8000b3d4:	f8 0a 00 0b 	add	r11,r12,r10
8000b3d8:	30 08       	mov	r8,0
8000b3da:	c0 68       	rjmp	8000b3e6 <memmove+0x20>
8000b3dc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b3e0:	20 1a       	sub	r10,1
8000b3e2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b3e6:	20 18       	sub	r8,1
8000b3e8:	58 0a       	cp.w	r10,0
8000b3ea:	cf 91       	brne	8000b3dc <memmove+0x16>
8000b3ec:	d8 02       	popm	pc
8000b3ee:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b3f2:	20 1a       	sub	r10,1
8000b3f4:	f8 08 0b 09 	st.b	r12[r8],r9
8000b3f8:	2f f8       	sub	r8,-1
8000b3fa:	c0 28       	rjmp	8000b3fe <memmove+0x38>
8000b3fc:	30 08       	mov	r8,0
8000b3fe:	58 0a       	cp.w	r10,0
8000b400:	cf 71       	brne	8000b3ee <memmove+0x28>
8000b402:	d8 02       	popm	pc

8000b404 <__hi0bits>:
8000b404:	18 98       	mov	r8,r12
8000b406:	e0 1c 00 00 	andl	r12,0x0
8000b40a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b40e:	58 0c       	cp.w	r12,0
8000b410:	f2 08 17 00 	moveq	r8,r9
8000b414:	f9 bc 00 10 	moveq	r12,16
8000b418:	f9 bc 01 00 	movne	r12,0
8000b41c:	10 9a       	mov	r10,r8
8000b41e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b422:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b426:	f7 bc 00 f8 	subeq	r12,-8
8000b42a:	f2 08 17 00 	moveq	r8,r9
8000b42e:	10 9a       	mov	r10,r8
8000b430:	f0 09 15 04 	lsl	r9,r8,0x4
8000b434:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b438:	f7 bc 00 fc 	subeq	r12,-4
8000b43c:	f2 08 17 00 	moveq	r8,r9
8000b440:	10 9a       	mov	r10,r8
8000b442:	f0 09 15 02 	lsl	r9,r8,0x2
8000b446:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b44a:	f7 bc 00 fe 	subeq	r12,-2
8000b44e:	f2 08 17 00 	moveq	r8,r9
8000b452:	58 08       	cp.w	r8,0
8000b454:	5e 5c       	retlt	r12
8000b456:	ed b8 00 1e 	bld	r8,0x1e
8000b45a:	f9 bc 01 20 	movne	r12,32
8000b45e:	f7 bc 00 ff 	subeq	r12,-1
8000b462:	5e fc       	retal	r12

8000b464 <__lo0bits>:
8000b464:	18 99       	mov	r9,r12
8000b466:	78 08       	ld.w	r8,r12[0x0]
8000b468:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b46c:	c1 50       	breq	8000b496 <__lo0bits+0x32>
8000b46e:	ed b8 00 00 	bld	r8,0x0
8000b472:	c0 21       	brne	8000b476 <__lo0bits+0x12>
8000b474:	5e fd       	retal	0
8000b476:	10 9b       	mov	r11,r8
8000b478:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b47c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b480:	a3 88       	lsr	r8,0x2
8000b482:	58 0b       	cp.w	r11,0
8000b484:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b488:	f9 bc 01 01 	movne	r12,1
8000b48c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b490:	f9 bc 00 02 	moveq	r12,2
8000b494:	5e fc       	retal	r12
8000b496:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b49a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b49e:	58 0a       	cp.w	r10,0
8000b4a0:	f6 08 17 00 	moveq	r8,r11
8000b4a4:	f9 bc 00 10 	moveq	r12,16
8000b4a8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b4ac:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b4b0:	58 0b       	cp.w	r11,0
8000b4b2:	f7 bc 00 f8 	subeq	r12,-8
8000b4b6:	f4 08 17 00 	moveq	r8,r10
8000b4ba:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b4be:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b4c2:	58 0b       	cp.w	r11,0
8000b4c4:	f7 bc 00 fc 	subeq	r12,-4
8000b4c8:	f4 08 17 00 	moveq	r8,r10
8000b4cc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b4d0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b4d4:	58 0b       	cp.w	r11,0
8000b4d6:	f7 bc 00 fe 	subeq	r12,-2
8000b4da:	f4 08 17 00 	moveq	r8,r10
8000b4de:	ed b8 00 00 	bld	r8,0x0
8000b4e2:	c0 60       	breq	8000b4ee <__lo0bits+0x8a>
8000b4e4:	a1 98       	lsr	r8,0x1
8000b4e6:	c0 31       	brne	8000b4ec <__lo0bits+0x88>
8000b4e8:	32 0c       	mov	r12,32
8000b4ea:	5e fc       	retal	r12
8000b4ec:	2f fc       	sub	r12,-1
8000b4ee:	93 08       	st.w	r9[0x0],r8
8000b4f0:	5e fc       	retal	r12

8000b4f2 <__mcmp>:
8000b4f2:	d4 01       	pushm	lr
8000b4f4:	18 98       	mov	r8,r12
8000b4f6:	76 49       	ld.w	r9,r11[0x10]
8000b4f8:	78 4c       	ld.w	r12,r12[0x10]
8000b4fa:	12 1c       	sub	r12,r9
8000b4fc:	c1 31       	brne	8000b522 <__mcmp+0x30>
8000b4fe:	2f b9       	sub	r9,-5
8000b500:	a3 69       	lsl	r9,0x2
8000b502:	12 0b       	add	r11,r9
8000b504:	f0 09 00 09 	add	r9,r8,r9
8000b508:	2e c8       	sub	r8,-20
8000b50a:	13 4e       	ld.w	lr,--r9
8000b50c:	17 4a       	ld.w	r10,--r11
8000b50e:	14 3e       	cp.w	lr,r10
8000b510:	c0 60       	breq	8000b51c <__mcmp+0x2a>
8000b512:	f9 bc 03 ff 	movlo	r12,-1
8000b516:	f9 bc 02 01 	movhs	r12,1
8000b51a:	d8 02       	popm	pc
8000b51c:	10 39       	cp.w	r9,r8
8000b51e:	fe 9b ff f6 	brhi	8000b50a <__mcmp+0x18>
8000b522:	d8 02       	popm	pc

8000b524 <_Bfree>:
8000b524:	d4 21       	pushm	r4-r7,lr
8000b526:	18 97       	mov	r7,r12
8000b528:	16 95       	mov	r5,r11
8000b52a:	78 96       	ld.w	r6,r12[0x24]
8000b52c:	58 06       	cp.w	r6,0
8000b52e:	c0 91       	brne	8000b540 <_Bfree+0x1c>
8000b530:	31 0c       	mov	r12,16
8000b532:	fe b0 de 49 	rcall	800071c4 <malloc>
8000b536:	99 36       	st.w	r12[0xc],r6
8000b538:	8f 9c       	st.w	r7[0x24],r12
8000b53a:	99 16       	st.w	r12[0x4],r6
8000b53c:	99 26       	st.w	r12[0x8],r6
8000b53e:	99 06       	st.w	r12[0x0],r6
8000b540:	58 05       	cp.w	r5,0
8000b542:	c0 90       	breq	8000b554 <_Bfree+0x30>
8000b544:	6a 19       	ld.w	r9,r5[0x4]
8000b546:	6e 98       	ld.w	r8,r7[0x24]
8000b548:	70 38       	ld.w	r8,r8[0xc]
8000b54a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b54e:	8b 0a       	st.w	r5[0x0],r10
8000b550:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b554:	d8 22       	popm	r4-r7,pc
8000b556:	d7 03       	nop

8000b558 <_Balloc>:
8000b558:	d4 21       	pushm	r4-r7,lr
8000b55a:	18 97       	mov	r7,r12
8000b55c:	16 96       	mov	r6,r11
8000b55e:	78 95       	ld.w	r5,r12[0x24]
8000b560:	58 05       	cp.w	r5,0
8000b562:	c0 91       	brne	8000b574 <_Balloc+0x1c>
8000b564:	31 0c       	mov	r12,16
8000b566:	fe b0 de 2f 	rcall	800071c4 <malloc>
8000b56a:	99 35       	st.w	r12[0xc],r5
8000b56c:	8f 9c       	st.w	r7[0x24],r12
8000b56e:	99 15       	st.w	r12[0x4],r5
8000b570:	99 25       	st.w	r12[0x8],r5
8000b572:	99 05       	st.w	r12[0x0],r5
8000b574:	6e 95       	ld.w	r5,r7[0x24]
8000b576:	6a 38       	ld.w	r8,r5[0xc]
8000b578:	58 08       	cp.w	r8,0
8000b57a:	c0 b1       	brne	8000b590 <_Balloc+0x38>
8000b57c:	31 0a       	mov	r10,16
8000b57e:	30 4b       	mov	r11,4
8000b580:	0e 9c       	mov	r12,r7
8000b582:	e0 a0 02 a7 	rcall	8000bad0 <_calloc_r>
8000b586:	8b 3c       	st.w	r5[0xc],r12
8000b588:	6e 98       	ld.w	r8,r7[0x24]
8000b58a:	70 3c       	ld.w	r12,r8[0xc]
8000b58c:	58 0c       	cp.w	r12,0
8000b58e:	c1 b0       	breq	8000b5c4 <_Balloc+0x6c>
8000b590:	6e 98       	ld.w	r8,r7[0x24]
8000b592:	70 38       	ld.w	r8,r8[0xc]
8000b594:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b598:	70 0c       	ld.w	r12,r8[0x0]
8000b59a:	58 0c       	cp.w	r12,0
8000b59c:	c0 40       	breq	8000b5a4 <_Balloc+0x4c>
8000b59e:	78 09       	ld.w	r9,r12[0x0]
8000b5a0:	91 09       	st.w	r8[0x0],r9
8000b5a2:	c0 e8       	rjmp	8000b5be <_Balloc+0x66>
8000b5a4:	0e 9c       	mov	r12,r7
8000b5a6:	30 17       	mov	r7,1
8000b5a8:	0e 9b       	mov	r11,r7
8000b5aa:	ee 06 09 47 	lsl	r7,r7,r6
8000b5ae:	ee ca ff fb 	sub	r10,r7,-5
8000b5b2:	a3 6a       	lsl	r10,0x2
8000b5b4:	e0 a0 02 8e 	rcall	8000bad0 <_calloc_r>
8000b5b8:	c0 60       	breq	8000b5c4 <_Balloc+0x6c>
8000b5ba:	99 16       	st.w	r12[0x4],r6
8000b5bc:	99 27       	st.w	r12[0x8],r7
8000b5be:	30 08       	mov	r8,0
8000b5c0:	99 38       	st.w	r12[0xc],r8
8000b5c2:	99 48       	st.w	r12[0x10],r8
8000b5c4:	d8 22       	popm	r4-r7,pc
8000b5c6:	d7 03       	nop

8000b5c8 <__d2b>:
8000b5c8:	d4 31       	pushm	r0-r7,lr
8000b5ca:	20 2d       	sub	sp,8
8000b5cc:	16 93       	mov	r3,r11
8000b5ce:	12 96       	mov	r6,r9
8000b5d0:	10 95       	mov	r5,r8
8000b5d2:	14 92       	mov	r2,r10
8000b5d4:	30 1b       	mov	r11,1
8000b5d6:	cc 1f       	rcall	8000b558 <_Balloc>
8000b5d8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b5dc:	50 09       	stdsp	sp[0x0],r9
8000b5de:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b5e2:	b5 a9       	sbr	r9,0x14
8000b5e4:	f0 01 16 14 	lsr	r1,r8,0x14
8000b5e8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b5ec:	18 94       	mov	r4,r12
8000b5ee:	58 02       	cp.w	r2,0
8000b5f0:	c1 d0       	breq	8000b62a <__d2b+0x62>
8000b5f2:	fa cc ff f8 	sub	r12,sp,-8
8000b5f6:	18 d2       	st.w	--r12,r2
8000b5f8:	c3 6f       	rcall	8000b464 <__lo0bits>
8000b5fa:	40 18       	lddsp	r8,sp[0x4]
8000b5fc:	c0 d0       	breq	8000b616 <__d2b+0x4e>
8000b5fe:	40 09       	lddsp	r9,sp[0x0]
8000b600:	f8 0a 11 20 	rsub	r10,r12,32
8000b604:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b608:	f5 e8 10 08 	or	r8,r10,r8
8000b60c:	89 58       	st.w	r4[0x14],r8
8000b60e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b612:	50 09       	stdsp	sp[0x0],r9
8000b614:	c0 28       	rjmp	8000b618 <__d2b+0x50>
8000b616:	89 58       	st.w	r4[0x14],r8
8000b618:	40 08       	lddsp	r8,sp[0x0]
8000b61a:	58 08       	cp.w	r8,0
8000b61c:	f9 b3 01 02 	movne	r3,2
8000b620:	f9 b3 00 01 	moveq	r3,1
8000b624:	89 68       	st.w	r4[0x18],r8
8000b626:	89 43       	st.w	r4[0x10],r3
8000b628:	c0 88       	rjmp	8000b638 <__d2b+0x70>
8000b62a:	1a 9c       	mov	r12,sp
8000b62c:	c1 cf       	rcall	8000b464 <__lo0bits>
8000b62e:	30 13       	mov	r3,1
8000b630:	40 08       	lddsp	r8,sp[0x0]
8000b632:	2e 0c       	sub	r12,-32
8000b634:	89 43       	st.w	r4[0x10],r3
8000b636:	89 58       	st.w	r4[0x14],r8
8000b638:	58 01       	cp.w	r1,0
8000b63a:	c0 90       	breq	8000b64c <__d2b+0x84>
8000b63c:	e2 c1 04 33 	sub	r1,r1,1075
8000b640:	18 01       	add	r1,r12
8000b642:	8d 01       	st.w	r6[0x0],r1
8000b644:	f8 0c 11 35 	rsub	r12,r12,53
8000b648:	8b 0c       	st.w	r5[0x0],r12
8000b64a:	c0 c8       	rjmp	8000b662 <__d2b+0x9a>
8000b64c:	e6 c8 ff fc 	sub	r8,r3,-4
8000b650:	f8 cc 04 32 	sub	r12,r12,1074
8000b654:	a5 73       	lsl	r3,0x5
8000b656:	8d 0c       	st.w	r6[0x0],r12
8000b658:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b65c:	cd 4e       	rcall	8000b404 <__hi0bits>
8000b65e:	18 13       	sub	r3,r12
8000b660:	8b 03       	st.w	r5[0x0],r3
8000b662:	08 9c       	mov	r12,r4
8000b664:	2f ed       	sub	sp,-8
8000b666:	d8 32       	popm	r0-r7,pc

8000b668 <__mdiff>:
8000b668:	d4 31       	pushm	r0-r7,lr
8000b66a:	74 48       	ld.w	r8,r10[0x10]
8000b66c:	76 45       	ld.w	r5,r11[0x10]
8000b66e:	16 97       	mov	r7,r11
8000b670:	14 96       	mov	r6,r10
8000b672:	10 15       	sub	r5,r8
8000b674:	c1 31       	brne	8000b69a <__mdiff+0x32>
8000b676:	2f b8       	sub	r8,-5
8000b678:	ee ce ff ec 	sub	lr,r7,-20
8000b67c:	a3 68       	lsl	r8,0x2
8000b67e:	f4 08 00 0b 	add	r11,r10,r8
8000b682:	ee 08 00 08 	add	r8,r7,r8
8000b686:	11 4a       	ld.w	r10,--r8
8000b688:	17 49       	ld.w	r9,--r11
8000b68a:	12 3a       	cp.w	r10,r9
8000b68c:	c0 30       	breq	8000b692 <__mdiff+0x2a>
8000b68e:	c0 e2       	brcc	8000b6aa <__mdiff+0x42>
8000b690:	c0 78       	rjmp	8000b69e <__mdiff+0x36>
8000b692:	1c 38       	cp.w	r8,lr
8000b694:	fe 9b ff f9 	brhi	8000b686 <__mdiff+0x1e>
8000b698:	c4 98       	rjmp	8000b72a <__mdiff+0xc2>
8000b69a:	58 05       	cp.w	r5,0
8000b69c:	c0 64       	brge	8000b6a8 <__mdiff+0x40>
8000b69e:	0e 98       	mov	r8,r7
8000b6a0:	30 15       	mov	r5,1
8000b6a2:	0c 97       	mov	r7,r6
8000b6a4:	10 96       	mov	r6,r8
8000b6a6:	c0 28       	rjmp	8000b6aa <__mdiff+0x42>
8000b6a8:	30 05       	mov	r5,0
8000b6aa:	6e 1b       	ld.w	r11,r7[0x4]
8000b6ac:	c5 6f       	rcall	8000b558 <_Balloc>
8000b6ae:	6e 49       	ld.w	r9,r7[0x10]
8000b6b0:	6c 44       	ld.w	r4,r6[0x10]
8000b6b2:	99 35       	st.w	r12[0xc],r5
8000b6b4:	2f b4       	sub	r4,-5
8000b6b6:	f2 c5 ff fb 	sub	r5,r9,-5
8000b6ba:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b6be:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b6c2:	2e c6       	sub	r6,-20
8000b6c4:	2e c7       	sub	r7,-20
8000b6c6:	f8 c8 ff ec 	sub	r8,r12,-20
8000b6ca:	30 0a       	mov	r10,0
8000b6cc:	0f 0e       	ld.w	lr,r7++
8000b6ce:	0d 0b       	ld.w	r11,r6++
8000b6d0:	fc 02 16 10 	lsr	r2,lr,0x10
8000b6d4:	f6 03 16 10 	lsr	r3,r11,0x10
8000b6d8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b6dc:	e4 03 01 03 	sub	r3,r2,r3
8000b6e0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b6e4:	fc 0b 01 0b 	sub	r11,lr,r11
8000b6e8:	f6 0a 00 0a 	add	r10,r11,r10
8000b6ec:	b0 1a       	st.h	r8[0x2],r10
8000b6ee:	b1 4a       	asr	r10,0x10
8000b6f0:	e6 0a 00 0a 	add	r10,r3,r10
8000b6f4:	b0 0a       	st.h	r8[0x0],r10
8000b6f6:	2f c8       	sub	r8,-4
8000b6f8:	b1 4a       	asr	r10,0x10
8000b6fa:	08 36       	cp.w	r6,r4
8000b6fc:	ce 83       	brcs	8000b6cc <__mdiff+0x64>
8000b6fe:	c0 d8       	rjmp	8000b718 <__mdiff+0xb0>
8000b700:	0f 0b       	ld.w	r11,r7++
8000b702:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b706:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b70a:	16 0a       	add	r10,r11
8000b70c:	b0 1a       	st.h	r8[0x2],r10
8000b70e:	b1 4a       	asr	r10,0x10
8000b710:	1c 0a       	add	r10,lr
8000b712:	b0 0a       	st.h	r8[0x0],r10
8000b714:	2f c8       	sub	r8,-4
8000b716:	b1 4a       	asr	r10,0x10
8000b718:	0a 37       	cp.w	r7,r5
8000b71a:	cf 33       	brcs	8000b700 <__mdiff+0x98>
8000b71c:	c0 28       	rjmp	8000b720 <__mdiff+0xb8>
8000b71e:	20 19       	sub	r9,1
8000b720:	11 4a       	ld.w	r10,--r8
8000b722:	58 0a       	cp.w	r10,0
8000b724:	cf d0       	breq	8000b71e <__mdiff+0xb6>
8000b726:	99 49       	st.w	r12[0x10],r9
8000b728:	d8 32       	popm	r0-r7,pc
8000b72a:	30 0b       	mov	r11,0
8000b72c:	c1 6f       	rcall	8000b558 <_Balloc>
8000b72e:	30 18       	mov	r8,1
8000b730:	99 48       	st.w	r12[0x10],r8
8000b732:	30 08       	mov	r8,0
8000b734:	99 58       	st.w	r12[0x14],r8
8000b736:	d8 32       	popm	r0-r7,pc

8000b738 <__lshift>:
8000b738:	d4 31       	pushm	r0-r7,lr
8000b73a:	16 97       	mov	r7,r11
8000b73c:	76 46       	ld.w	r6,r11[0x10]
8000b73e:	f4 02 14 05 	asr	r2,r10,0x5
8000b742:	2f f6       	sub	r6,-1
8000b744:	14 93       	mov	r3,r10
8000b746:	18 94       	mov	r4,r12
8000b748:	04 06       	add	r6,r2
8000b74a:	76 1b       	ld.w	r11,r11[0x4]
8000b74c:	6e 28       	ld.w	r8,r7[0x8]
8000b74e:	c0 38       	rjmp	8000b754 <__lshift+0x1c>
8000b750:	2f fb       	sub	r11,-1
8000b752:	a1 78       	lsl	r8,0x1
8000b754:	10 36       	cp.w	r6,r8
8000b756:	fe 99 ff fd 	brgt	8000b750 <__lshift+0x18>
8000b75a:	08 9c       	mov	r12,r4
8000b75c:	cf ee       	rcall	8000b558 <_Balloc>
8000b75e:	30 09       	mov	r9,0
8000b760:	18 95       	mov	r5,r12
8000b762:	f8 c8 ff ec 	sub	r8,r12,-20
8000b766:	12 9a       	mov	r10,r9
8000b768:	c0 38       	rjmp	8000b76e <__lshift+0x36>
8000b76a:	10 aa       	st.w	r8++,r10
8000b76c:	2f f9       	sub	r9,-1
8000b76e:	04 39       	cp.w	r9,r2
8000b770:	cf d5       	brlt	8000b76a <__lshift+0x32>
8000b772:	6e 4b       	ld.w	r11,r7[0x10]
8000b774:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b778:	2f bb       	sub	r11,-5
8000b77a:	ee c9 ff ec 	sub	r9,r7,-20
8000b77e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b782:	58 03       	cp.w	r3,0
8000b784:	c1 30       	breq	8000b7aa <__lshift+0x72>
8000b786:	e6 0c 11 20 	rsub	r12,r3,32
8000b78a:	30 0a       	mov	r10,0
8000b78c:	72 02       	ld.w	r2,r9[0x0]
8000b78e:	e4 03 09 42 	lsl	r2,r2,r3
8000b792:	04 4a       	or	r10,r2
8000b794:	10 aa       	st.w	r8++,r10
8000b796:	13 0a       	ld.w	r10,r9++
8000b798:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b79c:	16 39       	cp.w	r9,r11
8000b79e:	cf 73       	brcs	8000b78c <__lshift+0x54>
8000b7a0:	91 0a       	st.w	r8[0x0],r10
8000b7a2:	58 0a       	cp.w	r10,0
8000b7a4:	c0 70       	breq	8000b7b2 <__lshift+0x7a>
8000b7a6:	2f f6       	sub	r6,-1
8000b7a8:	c0 58       	rjmp	8000b7b2 <__lshift+0x7a>
8000b7aa:	13 0a       	ld.w	r10,r9++
8000b7ac:	10 aa       	st.w	r8++,r10
8000b7ae:	16 39       	cp.w	r9,r11
8000b7b0:	cf d3       	brcs	8000b7aa <__lshift+0x72>
8000b7b2:	08 9c       	mov	r12,r4
8000b7b4:	20 16       	sub	r6,1
8000b7b6:	0e 9b       	mov	r11,r7
8000b7b8:	8b 46       	st.w	r5[0x10],r6
8000b7ba:	cb 5e       	rcall	8000b524 <_Bfree>
8000b7bc:	0a 9c       	mov	r12,r5
8000b7be:	d8 32       	popm	r0-r7,pc

8000b7c0 <__multiply>:
8000b7c0:	d4 31       	pushm	r0-r7,lr
8000b7c2:	20 2d       	sub	sp,8
8000b7c4:	76 49       	ld.w	r9,r11[0x10]
8000b7c6:	74 48       	ld.w	r8,r10[0x10]
8000b7c8:	16 96       	mov	r6,r11
8000b7ca:	14 95       	mov	r5,r10
8000b7cc:	10 39       	cp.w	r9,r8
8000b7ce:	ec 08 17 50 	movlt	r8,r6
8000b7d2:	ea 06 17 50 	movlt	r6,r5
8000b7d6:	f0 05 17 50 	movlt	r5,r8
8000b7da:	6c 28       	ld.w	r8,r6[0x8]
8000b7dc:	76 43       	ld.w	r3,r11[0x10]
8000b7de:	74 42       	ld.w	r2,r10[0x10]
8000b7e0:	76 1b       	ld.w	r11,r11[0x4]
8000b7e2:	e4 03 00 07 	add	r7,r2,r3
8000b7e6:	10 37       	cp.w	r7,r8
8000b7e8:	f7 bb 09 ff 	subgt	r11,-1
8000b7ec:	cb 6e       	rcall	8000b558 <_Balloc>
8000b7ee:	ee c4 ff fb 	sub	r4,r7,-5
8000b7f2:	f8 c9 ff ec 	sub	r9,r12,-20
8000b7f6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b7fa:	30 0a       	mov	r10,0
8000b7fc:	12 98       	mov	r8,r9
8000b7fe:	c0 28       	rjmp	8000b802 <__multiply+0x42>
8000b800:	10 aa       	st.w	r8++,r10
8000b802:	08 38       	cp.w	r8,r4
8000b804:	cf e3       	brcs	8000b800 <__multiply+0x40>
8000b806:	2f b3       	sub	r3,-5
8000b808:	2f b2       	sub	r2,-5
8000b80a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b80e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b812:	ec cb ff ec 	sub	r11,r6,-20
8000b816:	50 12       	stdsp	sp[0x4],r2
8000b818:	ea ca ff ec 	sub	r10,r5,-20
8000b81c:	c4 48       	rjmp	8000b8a4 <__multiply+0xe4>
8000b81e:	94 95       	ld.uh	r5,r10[0x2]
8000b820:	58 05       	cp.w	r5,0
8000b822:	c2 00       	breq	8000b862 <__multiply+0xa2>
8000b824:	12 98       	mov	r8,r9
8000b826:	16 96       	mov	r6,r11
8000b828:	30 0e       	mov	lr,0
8000b82a:	50 09       	stdsp	sp[0x0],r9
8000b82c:	0d 02       	ld.w	r2,r6++
8000b82e:	e4 00 16 10 	lsr	r0,r2,0x10
8000b832:	70 01       	ld.w	r1,r8[0x0]
8000b834:	70 09       	ld.w	r9,r8[0x0]
8000b836:	b1 81       	lsr	r1,0x10
8000b838:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b83c:	e0 05 03 41 	mac	r1,r0,r5
8000b840:	ab 32       	mul	r2,r5
8000b842:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b846:	00 02       	add	r2,r0
8000b848:	e4 0e 00 0e 	add	lr,r2,lr
8000b84c:	b0 1e       	st.h	r8[0x2],lr
8000b84e:	b1 8e       	lsr	lr,0x10
8000b850:	1c 01       	add	r1,lr
8000b852:	b0 01       	st.h	r8[0x0],r1
8000b854:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b858:	2f c8       	sub	r8,-4
8000b85a:	06 36       	cp.w	r6,r3
8000b85c:	ce 83       	brcs	8000b82c <__multiply+0x6c>
8000b85e:	40 09       	lddsp	r9,sp[0x0]
8000b860:	91 0e       	st.w	r8[0x0],lr
8000b862:	94 86       	ld.uh	r6,r10[0x0]
8000b864:	58 06       	cp.w	r6,0
8000b866:	c1 d0       	breq	8000b8a0 <__multiply+0xe0>
8000b868:	72 02       	ld.w	r2,r9[0x0]
8000b86a:	12 98       	mov	r8,r9
8000b86c:	16 9e       	mov	lr,r11
8000b86e:	30 05       	mov	r5,0
8000b870:	b0 12       	st.h	r8[0x2],r2
8000b872:	1d 01       	ld.w	r1,lr++
8000b874:	90 82       	ld.uh	r2,r8[0x0]
8000b876:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b87a:	ad 30       	mul	r0,r6
8000b87c:	e0 02 00 02 	add	r2,r0,r2
8000b880:	e4 05 00 05 	add	r5,r2,r5
8000b884:	b0 05       	st.h	r8[0x0],r5
8000b886:	b1 85       	lsr	r5,0x10
8000b888:	b1 81       	lsr	r1,0x10
8000b88a:	2f c8       	sub	r8,-4
8000b88c:	ad 31       	mul	r1,r6
8000b88e:	90 92       	ld.uh	r2,r8[0x2]
8000b890:	e2 02 00 02 	add	r2,r1,r2
8000b894:	0a 02       	add	r2,r5
8000b896:	e4 05 16 10 	lsr	r5,r2,0x10
8000b89a:	06 3e       	cp.w	lr,r3
8000b89c:	ce a3       	brcs	8000b870 <__multiply+0xb0>
8000b89e:	91 02       	st.w	r8[0x0],r2
8000b8a0:	2f ca       	sub	r10,-4
8000b8a2:	2f c9       	sub	r9,-4
8000b8a4:	40 18       	lddsp	r8,sp[0x4]
8000b8a6:	10 3a       	cp.w	r10,r8
8000b8a8:	cb b3       	brcs	8000b81e <__multiply+0x5e>
8000b8aa:	c0 28       	rjmp	8000b8ae <__multiply+0xee>
8000b8ac:	20 17       	sub	r7,1
8000b8ae:	58 07       	cp.w	r7,0
8000b8b0:	e0 8a 00 05 	brle	8000b8ba <__multiply+0xfa>
8000b8b4:	09 48       	ld.w	r8,--r4
8000b8b6:	58 08       	cp.w	r8,0
8000b8b8:	cf a0       	breq	8000b8ac <__multiply+0xec>
8000b8ba:	99 47       	st.w	r12[0x10],r7
8000b8bc:	2f ed       	sub	sp,-8
8000b8be:	d8 32       	popm	r0-r7,pc

8000b8c0 <__i2b>:
8000b8c0:	d4 21       	pushm	r4-r7,lr
8000b8c2:	16 97       	mov	r7,r11
8000b8c4:	30 1b       	mov	r11,1
8000b8c6:	c4 9e       	rcall	8000b558 <_Balloc>
8000b8c8:	30 19       	mov	r9,1
8000b8ca:	99 57       	st.w	r12[0x14],r7
8000b8cc:	99 49       	st.w	r12[0x10],r9
8000b8ce:	d8 22       	popm	r4-r7,pc

8000b8d0 <__multadd>:
8000b8d0:	d4 31       	pushm	r0-r7,lr
8000b8d2:	30 08       	mov	r8,0
8000b8d4:	12 95       	mov	r5,r9
8000b8d6:	16 97       	mov	r7,r11
8000b8d8:	18 96       	mov	r6,r12
8000b8da:	76 44       	ld.w	r4,r11[0x10]
8000b8dc:	f6 c9 ff ec 	sub	r9,r11,-20
8000b8e0:	72 0b       	ld.w	r11,r9[0x0]
8000b8e2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b8e6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8ea:	f4 0c 02 4c 	mul	r12,r10,r12
8000b8ee:	f4 0b 03 45 	mac	r5,r10,r11
8000b8f2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b8f6:	b1 85       	lsr	r5,0x10
8000b8f8:	18 05       	add	r5,r12
8000b8fa:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b8fe:	f8 0b 00 0b 	add	r11,r12,r11
8000b902:	12 ab       	st.w	r9++,r11
8000b904:	2f f8       	sub	r8,-1
8000b906:	b1 85       	lsr	r5,0x10
8000b908:	08 38       	cp.w	r8,r4
8000b90a:	ce b5       	brlt	8000b8e0 <__multadd+0x10>
8000b90c:	58 05       	cp.w	r5,0
8000b90e:	c1 c0       	breq	8000b946 <__multadd+0x76>
8000b910:	6e 28       	ld.w	r8,r7[0x8]
8000b912:	10 34       	cp.w	r4,r8
8000b914:	c1 35       	brlt	8000b93a <__multadd+0x6a>
8000b916:	6e 1b       	ld.w	r11,r7[0x4]
8000b918:	0c 9c       	mov	r12,r6
8000b91a:	2f fb       	sub	r11,-1
8000b91c:	c1 ee       	rcall	8000b558 <_Balloc>
8000b91e:	6e 4a       	ld.w	r10,r7[0x10]
8000b920:	ee cb ff f4 	sub	r11,r7,-12
8000b924:	18 93       	mov	r3,r12
8000b926:	2f ea       	sub	r10,-2
8000b928:	2f 4c       	sub	r12,-12
8000b92a:	a3 6a       	lsl	r10,0x2
8000b92c:	fe b0 de 70 	rcall	8000760c <memcpy>
8000b930:	0e 9b       	mov	r11,r7
8000b932:	0c 9c       	mov	r12,r6
8000b934:	fe b0 fd f8 	rcall	8000b524 <_Bfree>
8000b938:	06 97       	mov	r7,r3
8000b93a:	e8 c8 ff ff 	sub	r8,r4,-1
8000b93e:	2f b4       	sub	r4,-5
8000b940:	8f 48       	st.w	r7[0x10],r8
8000b942:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b946:	0e 9c       	mov	r12,r7
8000b948:	d8 32       	popm	r0-r7,pc
8000b94a:	d7 03       	nop

8000b94c <__pow5mult>:
8000b94c:	d4 31       	pushm	r0-r7,lr
8000b94e:	14 96       	mov	r6,r10
8000b950:	18 97       	mov	r7,r12
8000b952:	16 94       	mov	r4,r11
8000b954:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b958:	c0 90       	breq	8000b96a <__pow5mult+0x1e>
8000b95a:	20 18       	sub	r8,1
8000b95c:	fe c9 da fc 	sub	r9,pc,-9476
8000b960:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b964:	30 09       	mov	r9,0
8000b966:	cb 5f       	rcall	8000b8d0 <__multadd>
8000b968:	18 94       	mov	r4,r12
8000b96a:	a3 46       	asr	r6,0x2
8000b96c:	c3 40       	breq	8000b9d4 <__pow5mult+0x88>
8000b96e:	6e 95       	ld.w	r5,r7[0x24]
8000b970:	58 05       	cp.w	r5,0
8000b972:	c0 91       	brne	8000b984 <__pow5mult+0x38>
8000b974:	31 0c       	mov	r12,16
8000b976:	fe b0 dc 27 	rcall	800071c4 <malloc>
8000b97a:	99 35       	st.w	r12[0xc],r5
8000b97c:	8f 9c       	st.w	r7[0x24],r12
8000b97e:	99 15       	st.w	r12[0x4],r5
8000b980:	99 25       	st.w	r12[0x8],r5
8000b982:	99 05       	st.w	r12[0x0],r5
8000b984:	6e 93       	ld.w	r3,r7[0x24]
8000b986:	66 25       	ld.w	r5,r3[0x8]
8000b988:	58 05       	cp.w	r5,0
8000b98a:	c0 c1       	brne	8000b9a2 <__pow5mult+0x56>
8000b98c:	e0 6b 02 71 	mov	r11,625
8000b990:	0e 9c       	mov	r12,r7
8000b992:	c9 7f       	rcall	8000b8c0 <__i2b>
8000b994:	87 2c       	st.w	r3[0x8],r12
8000b996:	30 08       	mov	r8,0
8000b998:	18 95       	mov	r5,r12
8000b99a:	99 08       	st.w	r12[0x0],r8
8000b99c:	c0 38       	rjmp	8000b9a2 <__pow5mult+0x56>
8000b99e:	06 9c       	mov	r12,r3
8000b9a0:	18 95       	mov	r5,r12
8000b9a2:	ed b6 00 00 	bld	r6,0x0
8000b9a6:	c0 b1       	brne	8000b9bc <__pow5mult+0x70>
8000b9a8:	08 9b       	mov	r11,r4
8000b9aa:	0a 9a       	mov	r10,r5
8000b9ac:	0e 9c       	mov	r12,r7
8000b9ae:	c0 9f       	rcall	8000b7c0 <__multiply>
8000b9b0:	08 9b       	mov	r11,r4
8000b9b2:	18 93       	mov	r3,r12
8000b9b4:	0e 9c       	mov	r12,r7
8000b9b6:	06 94       	mov	r4,r3
8000b9b8:	fe b0 fd b6 	rcall	8000b524 <_Bfree>
8000b9bc:	a1 56       	asr	r6,0x1
8000b9be:	c0 b0       	breq	8000b9d4 <__pow5mult+0x88>
8000b9c0:	6a 03       	ld.w	r3,r5[0x0]
8000b9c2:	58 03       	cp.w	r3,0
8000b9c4:	ce d1       	brne	8000b99e <__pow5mult+0x52>
8000b9c6:	0a 9a       	mov	r10,r5
8000b9c8:	0a 9b       	mov	r11,r5
8000b9ca:	0e 9c       	mov	r12,r7
8000b9cc:	cf ae       	rcall	8000b7c0 <__multiply>
8000b9ce:	8b 0c       	st.w	r5[0x0],r12
8000b9d0:	99 03       	st.w	r12[0x0],r3
8000b9d2:	ce 7b       	rjmp	8000b9a0 <__pow5mult+0x54>
8000b9d4:	08 9c       	mov	r12,r4
8000b9d6:	d8 32       	popm	r0-r7,pc

8000b9d8 <__isinfd>:
8000b9d8:	14 98       	mov	r8,r10
8000b9da:	fc 19 7f f0 	movh	r9,0x7ff0
8000b9de:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b9e2:	f0 0b 11 00 	rsub	r11,r8,0
8000b9e6:	f7 e8 10 08 	or	r8,r11,r8
8000b9ea:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b9ee:	f2 08 01 08 	sub	r8,r9,r8
8000b9f2:	f0 0c 11 00 	rsub	r12,r8,0
8000b9f6:	f9 e8 10 08 	or	r8,r12,r8
8000b9fa:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b9fe:	2f fc       	sub	r12,-1
8000ba00:	5e fc       	retal	r12

8000ba02 <__isnand>:
8000ba02:	14 98       	mov	r8,r10
8000ba04:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba08:	f0 0c 11 00 	rsub	r12,r8,0
8000ba0c:	10 4c       	or	r12,r8
8000ba0e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ba12:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ba16:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba1a:	bf 9c       	lsr	r12,0x1f
8000ba1c:	5e fc       	retal	r12
8000ba1e:	d7 03       	nop

8000ba20 <__sclose>:
8000ba20:	d4 01       	pushm	lr
8000ba22:	96 7b       	ld.sh	r11,r11[0xe]
8000ba24:	c8 2c       	rcall	8000bb28 <_close_r>
8000ba26:	d8 02       	popm	pc

8000ba28 <__sseek>:
8000ba28:	d4 21       	pushm	r4-r7,lr
8000ba2a:	16 97       	mov	r7,r11
8000ba2c:	96 7b       	ld.sh	r11,r11[0xe]
8000ba2e:	c0 3d       	rcall	8000bc34 <_lseek_r>
8000ba30:	8e 68       	ld.sh	r8,r7[0xc]
8000ba32:	10 99       	mov	r9,r8
8000ba34:	ad c8       	cbr	r8,0xc
8000ba36:	ad a9       	sbr	r9,0xc
8000ba38:	5b fc       	cp.w	r12,-1
8000ba3a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ba3e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ba42:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ba46:	d8 22       	popm	r4-r7,pc

8000ba48 <__swrite>:
8000ba48:	d4 21       	pushm	r4-r7,lr
8000ba4a:	96 68       	ld.sh	r8,r11[0xc]
8000ba4c:	16 97       	mov	r7,r11
8000ba4e:	14 95       	mov	r5,r10
8000ba50:	12 94       	mov	r4,r9
8000ba52:	e2 18 01 00 	andl	r8,0x100,COH
8000ba56:	18 96       	mov	r6,r12
8000ba58:	c0 50       	breq	8000ba62 <__swrite+0x1a>
8000ba5a:	30 29       	mov	r9,2
8000ba5c:	30 0a       	mov	r10,0
8000ba5e:	96 7b       	ld.sh	r11,r11[0xe]
8000ba60:	ce ac       	rcall	8000bc34 <_lseek_r>
8000ba62:	8e 68       	ld.sh	r8,r7[0xc]
8000ba64:	ad c8       	cbr	r8,0xc
8000ba66:	08 99       	mov	r9,r4
8000ba68:	0a 9a       	mov	r10,r5
8000ba6a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ba6c:	0c 9c       	mov	r12,r6
8000ba6e:	ae 68       	st.h	r7[0xc],r8
8000ba70:	c1 cc       	rcall	8000baa8 <_write_r>
8000ba72:	d8 22       	popm	r4-r7,pc

8000ba74 <__sread>:
8000ba74:	d4 21       	pushm	r4-r7,lr
8000ba76:	16 97       	mov	r7,r11
8000ba78:	96 7b       	ld.sh	r11,r11[0xe]
8000ba7a:	cf 1c       	rcall	8000bc5c <_read_r>
8000ba7c:	c0 65       	brlt	8000ba88 <__sread+0x14>
8000ba7e:	6f 58       	ld.w	r8,r7[0x54]
8000ba80:	18 08       	add	r8,r12
8000ba82:	ef 48 00 54 	st.w	r7[84],r8
8000ba86:	d8 22       	popm	r4-r7,pc
8000ba88:	8e 68       	ld.sh	r8,r7[0xc]
8000ba8a:	ad c8       	cbr	r8,0xc
8000ba8c:	ae 68       	st.h	r7[0xc],r8
8000ba8e:	d8 22       	popm	r4-r7,pc

8000ba90 <strlen>:
8000ba90:	30 09       	mov	r9,0
8000ba92:	18 98       	mov	r8,r12
8000ba94:	c0 28       	rjmp	8000ba98 <strlen+0x8>
8000ba96:	2f f8       	sub	r8,-1
8000ba98:	11 8a       	ld.ub	r10,r8[0x0]
8000ba9a:	f2 0a 18 00 	cp.b	r10,r9
8000ba9e:	cf c1       	brne	8000ba96 <strlen+0x6>
8000baa0:	f0 0c 01 0c 	sub	r12,r8,r12
8000baa4:	5e fc       	retal	r12
8000baa6:	d7 03       	nop

8000baa8 <_write_r>:
8000baa8:	d4 21       	pushm	r4-r7,lr
8000baaa:	16 98       	mov	r8,r11
8000baac:	18 97       	mov	r7,r12
8000baae:	10 9c       	mov	r12,r8
8000bab0:	30 08       	mov	r8,0
8000bab2:	14 9b       	mov	r11,r10
8000bab4:	e0 66 51 24 	mov	r6,20772
8000bab8:	12 9a       	mov	r10,r9
8000baba:	8d 08       	st.w	r6[0x0],r8
8000babc:	fe b0 d1 b6 	rcall	80005e28 <_write>
8000bac0:	5b fc       	cp.w	r12,-1
8000bac2:	c0 51       	brne	8000bacc <_write_r+0x24>
8000bac4:	6c 08       	ld.w	r8,r6[0x0]
8000bac6:	58 08       	cp.w	r8,0
8000bac8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bacc:	d8 22       	popm	r4-r7,pc
8000bace:	d7 03       	nop

8000bad0 <_calloc_r>:
8000bad0:	d4 21       	pushm	r4-r7,lr
8000bad2:	f4 0b 02 4b 	mul	r11,r10,r11
8000bad6:	fe b0 db 7f 	rcall	800071d4 <_malloc_r>
8000bada:	18 97       	mov	r7,r12
8000badc:	c2 30       	breq	8000bb22 <_calloc_r+0x52>
8000bade:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bae2:	e0 1a ff fc 	andl	r10,0xfffc
8000bae6:	20 4a       	sub	r10,4
8000bae8:	e0 4a 00 24 	cp.w	r10,36
8000baec:	e0 8b 00 18 	brhi	8000bb1c <_calloc_r+0x4c>
8000baf0:	18 98       	mov	r8,r12
8000baf2:	59 3a       	cp.w	r10,19
8000baf4:	e0 88 00 0f 	brls	8000bb12 <_calloc_r+0x42>
8000baf8:	30 09       	mov	r9,0
8000bafa:	10 a9       	st.w	r8++,r9
8000bafc:	10 a9       	st.w	r8++,r9
8000bafe:	59 ba       	cp.w	r10,27
8000bb00:	e0 88 00 09 	brls	8000bb12 <_calloc_r+0x42>
8000bb04:	10 a9       	st.w	r8++,r9
8000bb06:	10 a9       	st.w	r8++,r9
8000bb08:	e0 4a 00 24 	cp.w	r10,36
8000bb0c:	c0 31       	brne	8000bb12 <_calloc_r+0x42>
8000bb0e:	10 a9       	st.w	r8++,r9
8000bb10:	10 a9       	st.w	r8++,r9
8000bb12:	30 09       	mov	r9,0
8000bb14:	10 a9       	st.w	r8++,r9
8000bb16:	91 19       	st.w	r8[0x4],r9
8000bb18:	91 09       	st.w	r8[0x0],r9
8000bb1a:	c0 48       	rjmp	8000bb22 <_calloc_r+0x52>
8000bb1c:	30 0b       	mov	r11,0
8000bb1e:	fe b0 de 1b 	rcall	80007754 <memset>
8000bb22:	0e 9c       	mov	r12,r7
8000bb24:	d8 22       	popm	r4-r7,pc
8000bb26:	d7 03       	nop

8000bb28 <_close_r>:
8000bb28:	d4 21       	pushm	r4-r7,lr
8000bb2a:	30 08       	mov	r8,0
8000bb2c:	18 97       	mov	r7,r12
8000bb2e:	e0 66 51 24 	mov	r6,20772
8000bb32:	16 9c       	mov	r12,r11
8000bb34:	8d 08       	st.w	r6[0x0],r8
8000bb36:	fe b0 df b5 	rcall	80007aa0 <_close>
8000bb3a:	5b fc       	cp.w	r12,-1
8000bb3c:	c0 51       	brne	8000bb46 <_close_r+0x1e>
8000bb3e:	6c 08       	ld.w	r8,r6[0x0]
8000bb40:	58 08       	cp.w	r8,0
8000bb42:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb46:	d8 22       	popm	r4-r7,pc

8000bb48 <_fclose_r>:
8000bb48:	d4 21       	pushm	r4-r7,lr
8000bb4a:	18 96       	mov	r6,r12
8000bb4c:	16 97       	mov	r7,r11
8000bb4e:	58 0b       	cp.w	r11,0
8000bb50:	c0 31       	brne	8000bb56 <_fclose_r+0xe>
8000bb52:	16 95       	mov	r5,r11
8000bb54:	c5 38       	rjmp	8000bbfa <_fclose_r+0xb2>
8000bb56:	fe b0 f8 a9 	rcall	8000aca8 <__sfp_lock_acquire>
8000bb5a:	58 06       	cp.w	r6,0
8000bb5c:	c0 70       	breq	8000bb6a <_fclose_r+0x22>
8000bb5e:	6c 68       	ld.w	r8,r6[0x18]
8000bb60:	58 08       	cp.w	r8,0
8000bb62:	c0 41       	brne	8000bb6a <_fclose_r+0x22>
8000bb64:	0c 9c       	mov	r12,r6
8000bb66:	fe b0 f8 f3 	rcall	8000ad4c <__sinit>
8000bb6a:	fe c8 dd ae 	sub	r8,pc,-8786
8000bb6e:	10 37       	cp.w	r7,r8
8000bb70:	c0 31       	brne	8000bb76 <_fclose_r+0x2e>
8000bb72:	6c 07       	ld.w	r7,r6[0x0]
8000bb74:	c0 c8       	rjmp	8000bb8c <_fclose_r+0x44>
8000bb76:	fe c8 dd 9a 	sub	r8,pc,-8806
8000bb7a:	10 37       	cp.w	r7,r8
8000bb7c:	c0 31       	brne	8000bb82 <_fclose_r+0x3a>
8000bb7e:	6c 17       	ld.w	r7,r6[0x4]
8000bb80:	c0 68       	rjmp	8000bb8c <_fclose_r+0x44>
8000bb82:	fe c8 dd 86 	sub	r8,pc,-8826
8000bb86:	10 37       	cp.w	r7,r8
8000bb88:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bb8c:	8e 69       	ld.sh	r9,r7[0xc]
8000bb8e:	30 08       	mov	r8,0
8000bb90:	f0 09 19 00 	cp.h	r9,r8
8000bb94:	c0 51       	brne	8000bb9e <_fclose_r+0x56>
8000bb96:	fe b0 f8 8a 	rcall	8000acaa <__sfp_lock_release>
8000bb9a:	30 05       	mov	r5,0
8000bb9c:	c2 f8       	rjmp	8000bbfa <_fclose_r+0xb2>
8000bb9e:	0e 9b       	mov	r11,r7
8000bba0:	0c 9c       	mov	r12,r6
8000bba2:	fe b0 f7 fd 	rcall	8000ab9c <_fflush_r>
8000bba6:	6e c8       	ld.w	r8,r7[0x30]
8000bba8:	18 95       	mov	r5,r12
8000bbaa:	58 08       	cp.w	r8,0
8000bbac:	c0 60       	breq	8000bbb8 <_fclose_r+0x70>
8000bbae:	6e 8b       	ld.w	r11,r7[0x20]
8000bbb0:	0c 9c       	mov	r12,r6
8000bbb2:	5d 18       	icall	r8
8000bbb4:	f9 b5 05 ff 	movlt	r5,-1
8000bbb8:	8e 68       	ld.sh	r8,r7[0xc]
8000bbba:	ed b8 00 07 	bld	r8,0x7
8000bbbe:	c0 51       	brne	8000bbc8 <_fclose_r+0x80>
8000bbc0:	6e 4b       	ld.w	r11,r7[0x10]
8000bbc2:	0c 9c       	mov	r12,r6
8000bbc4:	fe b0 f9 5e 	rcall	8000ae80 <_free_r>
8000bbc8:	6e db       	ld.w	r11,r7[0x34]
8000bbca:	58 0b       	cp.w	r11,0
8000bbcc:	c0 a0       	breq	8000bbe0 <_fclose_r+0x98>
8000bbce:	ee c8 ff bc 	sub	r8,r7,-68
8000bbd2:	10 3b       	cp.w	r11,r8
8000bbd4:	c0 40       	breq	8000bbdc <_fclose_r+0x94>
8000bbd6:	0c 9c       	mov	r12,r6
8000bbd8:	fe b0 f9 54 	rcall	8000ae80 <_free_r>
8000bbdc:	30 08       	mov	r8,0
8000bbde:	8f d8       	st.w	r7[0x34],r8
8000bbe0:	6f 2b       	ld.w	r11,r7[0x48]
8000bbe2:	58 0b       	cp.w	r11,0
8000bbe4:	c0 70       	breq	8000bbf2 <_fclose_r+0xaa>
8000bbe6:	0c 9c       	mov	r12,r6
8000bbe8:	fe b0 f9 4c 	rcall	8000ae80 <_free_r>
8000bbec:	30 08       	mov	r8,0
8000bbee:	ef 48 00 48 	st.w	r7[72],r8
8000bbf2:	30 08       	mov	r8,0
8000bbf4:	ae 68       	st.h	r7[0xc],r8
8000bbf6:	fe b0 f8 5a 	rcall	8000acaa <__sfp_lock_release>
8000bbfa:	0a 9c       	mov	r12,r5
8000bbfc:	d8 22       	popm	r4-r7,pc
8000bbfe:	d7 03       	nop

8000bc00 <fclose>:
8000bc00:	d4 01       	pushm	lr
8000bc02:	e0 68 0a 38 	mov	r8,2616
8000bc06:	18 9b       	mov	r11,r12
8000bc08:	70 0c       	ld.w	r12,r8[0x0]
8000bc0a:	c9 ff       	rcall	8000bb48 <_fclose_r>
8000bc0c:	d8 02       	popm	pc
8000bc0e:	d7 03       	nop

8000bc10 <_fstat_r>:
8000bc10:	d4 21       	pushm	r4-r7,lr
8000bc12:	16 98       	mov	r8,r11
8000bc14:	18 97       	mov	r7,r12
8000bc16:	10 9c       	mov	r12,r8
8000bc18:	30 08       	mov	r8,0
8000bc1a:	e0 66 51 24 	mov	r6,20772
8000bc1e:	14 9b       	mov	r11,r10
8000bc20:	8d 08       	st.w	r6[0x0],r8
8000bc22:	fe b0 df 67 	rcall	80007af0 <_fstat>
8000bc26:	5b fc       	cp.w	r12,-1
8000bc28:	c0 51       	brne	8000bc32 <_fstat_r+0x22>
8000bc2a:	6c 08       	ld.w	r8,r6[0x0]
8000bc2c:	58 08       	cp.w	r8,0
8000bc2e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc32:	d8 22       	popm	r4-r7,pc

8000bc34 <_lseek_r>:
8000bc34:	d4 21       	pushm	r4-r7,lr
8000bc36:	16 98       	mov	r8,r11
8000bc38:	18 97       	mov	r7,r12
8000bc3a:	10 9c       	mov	r12,r8
8000bc3c:	30 08       	mov	r8,0
8000bc3e:	14 9b       	mov	r11,r10
8000bc40:	e0 66 51 24 	mov	r6,20772
8000bc44:	12 9a       	mov	r10,r9
8000bc46:	8d 08       	st.w	r6[0x0],r8
8000bc48:	fe b0 df 36 	rcall	80007ab4 <_lseek>
8000bc4c:	5b fc       	cp.w	r12,-1
8000bc4e:	c0 51       	brne	8000bc58 <_lseek_r+0x24>
8000bc50:	6c 08       	ld.w	r8,r6[0x0]
8000bc52:	58 08       	cp.w	r8,0
8000bc54:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc58:	d8 22       	popm	r4-r7,pc
8000bc5a:	d7 03       	nop

8000bc5c <_read_r>:
8000bc5c:	d4 21       	pushm	r4-r7,lr
8000bc5e:	16 98       	mov	r8,r11
8000bc60:	18 97       	mov	r7,r12
8000bc62:	10 9c       	mov	r12,r8
8000bc64:	30 08       	mov	r8,0
8000bc66:	14 9b       	mov	r11,r10
8000bc68:	e0 66 51 24 	mov	r6,20772
8000bc6c:	12 9a       	mov	r10,r9
8000bc6e:	8d 08       	st.w	r6[0x0],r8
8000bc70:	fe b0 d0 bc 	rcall	80005de8 <_read>
8000bc74:	5b fc       	cp.w	r12,-1
8000bc76:	c0 51       	brne	8000bc80 <_read_r+0x24>
8000bc78:	6c 08       	ld.w	r8,r6[0x0]
8000bc7a:	58 08       	cp.w	r8,0
8000bc7c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc80:	d8 22       	popm	r4-r7,pc
8000bc82:	d7 03       	nop

8000bc84 <__avr32_f64_mul>:
8000bc84:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bc88:	e0 80 00 dc 	breq	8000be40 <__avr32_f64_mul_op1_zero>
8000bc8c:	d4 21       	pushm	r4-r7,lr
8000bc8e:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc92:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc96:	30 15       	mov	r5,1
8000bc98:	c4 30       	breq	8000bd1e <__avr32_f64_mul_op1_subnormal>
8000bc9a:	ab 6b       	lsl	r11,0xa
8000bc9c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bca0:	ab 6a       	lsl	r10,0xa
8000bca2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bca6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bcaa:	c5 c0       	breq	8000bd62 <__avr32_f64_mul_op2_subnormal>
8000bcac:	a1 78       	lsl	r8,0x1
8000bcae:	5c f9       	rol	r9
8000bcb0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bcb4:	e0 47 07 ff 	cp.w	r7,2047
8000bcb8:	c7 70       	breq	8000bda6 <__avr32_f64_mul_op_nan_or_inf>
8000bcba:	e0 46 07 ff 	cp.w	r6,2047
8000bcbe:	c7 40       	breq	8000bda6 <__avr32_f64_mul_op_nan_or_inf>
8000bcc0:	ee 06 00 0c 	add	r12,r7,r6
8000bcc4:	e0 2c 03 fe 	sub	r12,1022
8000bcc8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bccc:	f4 09 07 44 	macu.d	r4,r10,r9
8000bcd0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bcd4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bcd8:	08 07       	add	r7,r4
8000bcda:	f4 05 00 4a 	adc	r10,r10,r5
8000bcde:	5c 0b       	acr	r11
8000bce0:	ed bb 00 14 	bld	r11,0x14
8000bce4:	c0 50       	breq	8000bcee <__avr32_f64_mul+0x6a>
8000bce6:	a1 77       	lsl	r7,0x1
8000bce8:	5c fa       	rol	r10
8000bcea:	5c fb       	rol	r11
8000bcec:	20 1c       	sub	r12,1
8000bcee:	58 0c       	cp.w	r12,0
8000bcf0:	e0 8a 00 6f 	brle	8000bdce <__avr32_f64_mul_res_subnormal>
8000bcf4:	e0 4c 07 ff 	cp.w	r12,2047
8000bcf8:	e0 84 00 9c 	brge	8000be30 <__avr32_f64_mul_res_inf>
8000bcfc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bd00:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bd04:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bd08:	ee 17 80 00 	eorh	r7,0x8000
8000bd0c:	f1 b7 04 20 	satu	r7,0x1
8000bd10:	0e 0a       	add	r10,r7
8000bd12:	5c 0b       	acr	r11
8000bd14:	ed be 00 1f 	bld	lr,0x1f
8000bd18:	ef bb 00 1f 	bst	r11,0x1f
8000bd1c:	d8 22       	popm	r4-r7,pc

8000bd1e <__avr32_f64_mul_op1_subnormal>:
8000bd1e:	e4 1b 00 0f 	andh	r11,0xf
8000bd22:	f4 0c 12 00 	clz	r12,r10
8000bd26:	f6 06 12 00 	clz	r6,r11
8000bd2a:	f7 bc 03 e1 	sublo	r12,-31
8000bd2e:	f8 06 17 30 	movlo	r6,r12
8000bd32:	f7 b6 02 01 	subhs	r6,1
8000bd36:	e0 46 00 20 	cp.w	r6,32
8000bd3a:	c0 d4       	brge	8000bd54 <__avr32_f64_mul_op1_subnormal+0x36>
8000bd3c:	ec 0c 11 20 	rsub	r12,r6,32
8000bd40:	f6 06 09 4b 	lsl	r11,r11,r6
8000bd44:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bd48:	18 4b       	or	r11,r12
8000bd4a:	f4 06 09 4a 	lsl	r10,r10,r6
8000bd4e:	20 b6       	sub	r6,11
8000bd50:	0c 17       	sub	r7,r6
8000bd52:	ca ab       	rjmp	8000bca6 <__avr32_f64_mul+0x22>
8000bd54:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd58:	c6 40       	breq	8000be20 <__avr32_f64_mul_res_zero>
8000bd5a:	30 0a       	mov	r10,0
8000bd5c:	20 b6       	sub	r6,11
8000bd5e:	0c 17       	sub	r7,r6
8000bd60:	ca 3b       	rjmp	8000bca6 <__avr32_f64_mul+0x22>

8000bd62 <__avr32_f64_mul_op2_subnormal>:
8000bd62:	e4 19 00 0f 	andh	r9,0xf
8000bd66:	f0 0c 12 00 	clz	r12,r8
8000bd6a:	f2 05 12 00 	clz	r5,r9
8000bd6e:	f7 bc 03 ea 	sublo	r12,-22
8000bd72:	f8 05 17 30 	movlo	r5,r12
8000bd76:	f7 b5 02 0a 	subhs	r5,10
8000bd7a:	e0 45 00 20 	cp.w	r5,32
8000bd7e:	c0 d4       	brge	8000bd98 <__avr32_f64_mul_op2_subnormal+0x36>
8000bd80:	ea 0c 11 20 	rsub	r12,r5,32
8000bd84:	f2 05 09 49 	lsl	r9,r9,r5
8000bd88:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bd8c:	18 49       	or	r9,r12
8000bd8e:	f0 05 09 48 	lsl	r8,r8,r5
8000bd92:	20 25       	sub	r5,2
8000bd94:	0a 16       	sub	r6,r5
8000bd96:	c8 fb       	rjmp	8000bcb4 <__avr32_f64_mul+0x30>
8000bd98:	f0 05 09 49 	lsl	r9,r8,r5
8000bd9c:	c4 20       	breq	8000be20 <__avr32_f64_mul_res_zero>
8000bd9e:	30 08       	mov	r8,0
8000bda0:	20 25       	sub	r5,2
8000bda2:	0a 16       	sub	r6,r5
8000bda4:	c8 8b       	rjmp	8000bcb4 <__avr32_f64_mul+0x30>

8000bda6 <__avr32_f64_mul_op_nan_or_inf>:
8000bda6:	e4 19 00 0f 	andh	r9,0xf
8000bdaa:	e4 1b 00 0f 	andh	r11,0xf
8000bdae:	14 4b       	or	r11,r10
8000bdb0:	10 49       	or	r9,r8
8000bdb2:	e0 47 07 ff 	cp.w	r7,2047
8000bdb6:	c0 91       	brne	8000bdc8 <__avr32_f64_mul_op1_not_naninf>
8000bdb8:	58 0b       	cp.w	r11,0
8000bdba:	c3 81       	brne	8000be2a <__avr32_f64_mul_res_nan>
8000bdbc:	e0 46 07 ff 	cp.w	r6,2047
8000bdc0:	c3 81       	brne	8000be30 <__avr32_f64_mul_res_inf>
8000bdc2:	58 09       	cp.w	r9,0
8000bdc4:	c3 60       	breq	8000be30 <__avr32_f64_mul_res_inf>
8000bdc6:	c3 28       	rjmp	8000be2a <__avr32_f64_mul_res_nan>

8000bdc8 <__avr32_f64_mul_op1_not_naninf>:
8000bdc8:	58 09       	cp.w	r9,0
8000bdca:	c3 30       	breq	8000be30 <__avr32_f64_mul_res_inf>
8000bdcc:	c2 f8       	rjmp	8000be2a <__avr32_f64_mul_res_nan>

8000bdce <__avr32_f64_mul_res_subnormal>:
8000bdce:	5c 3c       	neg	r12
8000bdd0:	2f fc       	sub	r12,-1
8000bdd2:	f1 bc 04 c0 	satu	r12,0x6
8000bdd6:	e0 4c 00 20 	cp.w	r12,32
8000bdda:	c1 14       	brge	8000bdfc <__avr32_f64_mul_res_subnormal+0x2e>
8000bddc:	f8 08 11 20 	rsub	r8,r12,32
8000bde0:	0e 46       	or	r6,r7
8000bde2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bde6:	f4 08 09 49 	lsl	r9,r10,r8
8000bdea:	12 47       	or	r7,r9
8000bdec:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bdf0:	f6 08 09 49 	lsl	r9,r11,r8
8000bdf4:	12 4a       	or	r10,r9
8000bdf6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bdfa:	c8 3b       	rjmp	8000bd00 <__avr32_f64_mul+0x7c>
8000bdfc:	f8 08 11 20 	rsub	r8,r12,32
8000be00:	f9 b9 00 00 	moveq	r9,0
8000be04:	c0 30       	breq	8000be0a <__avr32_f64_mul_res_subnormal+0x3c>
8000be06:	f6 08 09 49 	lsl	r9,r11,r8
8000be0a:	0e 46       	or	r6,r7
8000be0c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000be10:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be14:	f3 ea 10 07 	or	r7,r9,r10
8000be18:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000be1c:	30 0b       	mov	r11,0
8000be1e:	c7 1b       	rjmp	8000bd00 <__avr32_f64_mul+0x7c>

8000be20 <__avr32_f64_mul_res_zero>:
8000be20:	1c 9b       	mov	r11,lr
8000be22:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be26:	30 0a       	mov	r10,0
8000be28:	d8 22       	popm	r4-r7,pc

8000be2a <__avr32_f64_mul_res_nan>:
8000be2a:	3f fb       	mov	r11,-1
8000be2c:	3f fa       	mov	r10,-1
8000be2e:	d8 22       	popm	r4-r7,pc

8000be30 <__avr32_f64_mul_res_inf>:
8000be30:	f0 6b 00 00 	mov	r11,-1048576
8000be34:	ed be 00 1f 	bld	lr,0x1f
8000be38:	ef bb 00 1f 	bst	r11,0x1f
8000be3c:	30 0a       	mov	r10,0
8000be3e:	d8 22       	popm	r4-r7,pc

8000be40 <__avr32_f64_mul_op1_zero>:
8000be40:	f7 e9 20 0b 	eor	r11,r11,r9
8000be44:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be48:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000be4c:	e0 4c 07 ff 	cp.w	r12,2047
8000be50:	5e 1c       	retne	r12
8000be52:	3f fa       	mov	r10,-1
8000be54:	3f fb       	mov	r11,-1
8000be56:	5e fc       	retal	r12

8000be58 <__avr32_f64_sub_from_add>:
8000be58:	ee 19 80 00 	eorh	r9,0x8000

8000be5c <__avr32_f64_sub>:
8000be5c:	f7 e9 20 0c 	eor	r12,r11,r9
8000be60:	e0 86 00 ca 	brmi	8000bff4 <__avr32_f64_add_from_sub>
8000be64:	eb cd 40 e0 	pushm	r5-r7,lr
8000be68:	16 9c       	mov	r12,r11
8000be6a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000be6e:	bf db       	cbr	r11,0x1f
8000be70:	bf d9       	cbr	r9,0x1f
8000be72:	10 3a       	cp.w	r10,r8
8000be74:	f2 0b 13 00 	cpc	r11,r9
8000be78:	c0 92       	brcc	8000be8a <__avr32_f64_sub+0x2e>
8000be7a:	16 97       	mov	r7,r11
8000be7c:	12 9b       	mov	r11,r9
8000be7e:	0e 99       	mov	r9,r7
8000be80:	14 97       	mov	r7,r10
8000be82:	10 9a       	mov	r10,r8
8000be84:	0e 98       	mov	r8,r7
8000be86:	ee 1c 80 00 	eorh	r12,0x8000
8000be8a:	f6 07 16 14 	lsr	r7,r11,0x14
8000be8e:	ab 7b       	lsl	r11,0xb
8000be90:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be94:	ab 7a       	lsl	r10,0xb
8000be96:	bf bb       	sbr	r11,0x1f
8000be98:	f2 06 16 14 	lsr	r6,r9,0x14
8000be9c:	c4 40       	breq	8000bf24 <__avr32_f64_sub_opL_subnormal>
8000be9e:	ab 79       	lsl	r9,0xb
8000bea0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bea4:	ab 78       	lsl	r8,0xb
8000bea6:	bf b9       	sbr	r9,0x1f

8000bea8 <__avr32_f64_sub_opL_subnormal_done>:
8000bea8:	e0 47 07 ff 	cp.w	r7,2047
8000beac:	c4 f0       	breq	8000bf4a <__avr32_f64_sub_opH_nan_or_inf>
8000beae:	0e 26       	rsub	r6,r7
8000beb0:	c1 20       	breq	8000bed4 <__avr32_f64_sub_shift_done>
8000beb2:	ec 05 11 20 	rsub	r5,r6,32
8000beb6:	e0 46 00 20 	cp.w	r6,32
8000beba:	c7 c2       	brcc	8000bfb2 <__avr32_f64_sub_longshift>
8000bebc:	f0 05 09 4e 	lsl	lr,r8,r5
8000bec0:	f2 05 09 45 	lsl	r5,r9,r5
8000bec4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bec8:	f2 06 0a 49 	lsr	r9,r9,r6
8000becc:	0a 48       	or	r8,r5
8000bece:	58 0e       	cp.w	lr,0
8000bed0:	5f 1e       	srne	lr
8000bed2:	1c 48       	or	r8,lr

8000bed4 <__avr32_f64_sub_shift_done>:
8000bed4:	10 1a       	sub	r10,r8
8000bed6:	f6 09 01 4b 	sbc	r11,r11,r9
8000beda:	f6 06 12 00 	clz	r6,r11
8000bede:	c0 e0       	breq	8000befa <__avr32_f64_sub_longnormalize_done>
8000bee0:	c7 83       	brcs	8000bfd0 <__avr32_f64_sub_longnormalize>
8000bee2:	ec 0e 11 20 	rsub	lr,r6,32
8000bee6:	f6 06 09 4b 	lsl	r11,r11,r6
8000beea:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000beee:	1c 4b       	or	r11,lr
8000bef0:	f4 06 09 4a 	lsl	r10,r10,r6
8000bef4:	0c 17       	sub	r7,r6
8000bef6:	e0 8a 00 39 	brle	8000bf68 <__avr32_f64_sub_subnormal_result>

8000befa <__avr32_f64_sub_longnormalize_done>:
8000befa:	f4 09 15 15 	lsl	r9,r10,0x15
8000befe:	ab 9a       	lsr	r10,0xb
8000bf00:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf04:	ab 9b       	lsr	r11,0xb
8000bf06:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf0a:	18 4b       	or	r11,r12

8000bf0c <__avr32_f64_sub_round>:
8000bf0c:	fc 17 80 00 	movh	r7,0x8000
8000bf10:	ed ba 00 00 	bld	r10,0x0
8000bf14:	f7 b7 01 ff 	subne	r7,-1
8000bf18:	0e 39       	cp.w	r9,r7
8000bf1a:	5f 29       	srhs	r9
8000bf1c:	12 0a       	add	r10,r9
8000bf1e:	5c 0b       	acr	r11
8000bf20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf24 <__avr32_f64_sub_opL_subnormal>:
8000bf24:	ab 79       	lsl	r9,0xb
8000bf26:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf2a:	ab 78       	lsl	r8,0xb
8000bf2c:	f3 e8 10 0e 	or	lr,r9,r8
8000bf30:	f9 b6 01 01 	movne	r6,1
8000bf34:	ee 0e 11 00 	rsub	lr,r7,0
8000bf38:	f9 b7 00 01 	moveq	r7,1
8000bf3c:	ef bb 00 1f 	bst	r11,0x1f
8000bf40:	f7 ea 10 0e 	or	lr,r11,r10
8000bf44:	f9 b7 00 00 	moveq	r7,0
8000bf48:	cb 0b       	rjmp	8000bea8 <__avr32_f64_sub_opL_subnormal_done>

8000bf4a <__avr32_f64_sub_opH_nan_or_inf>:
8000bf4a:	bf db       	cbr	r11,0x1f
8000bf4c:	f7 ea 10 0e 	or	lr,r11,r10
8000bf50:	c0 81       	brne	8000bf60 <__avr32_f64_sub_return_nan>
8000bf52:	e0 46 07 ff 	cp.w	r6,2047
8000bf56:	c0 50       	breq	8000bf60 <__avr32_f64_sub_return_nan>
8000bf58:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bf5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf60 <__avr32_f64_sub_return_nan>:
8000bf60:	3f fa       	mov	r10,-1
8000bf62:	3f fb       	mov	r11,-1
8000bf64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf68 <__avr32_f64_sub_subnormal_result>:
8000bf68:	5c 37       	neg	r7
8000bf6a:	2f f7       	sub	r7,-1
8000bf6c:	f1 b7 04 c0 	satu	r7,0x6
8000bf70:	e0 47 00 20 	cp.w	r7,32
8000bf74:	c1 14       	brge	8000bf96 <__avr32_f64_sub_subnormal_result+0x2e>
8000bf76:	ee 08 11 20 	rsub	r8,r7,32
8000bf7a:	f4 08 09 49 	lsl	r9,r10,r8
8000bf7e:	5f 16       	srne	r6
8000bf80:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf84:	0c 4a       	or	r10,r6
8000bf86:	f6 08 09 49 	lsl	r9,r11,r8
8000bf8a:	f5 e9 10 0a 	or	r10,r10,r9
8000bf8e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bf92:	30 07       	mov	r7,0
8000bf94:	cb 3b       	rjmp	8000befa <__avr32_f64_sub_longnormalize_done>
8000bf96:	ee 08 11 40 	rsub	r8,r7,64
8000bf9a:	f6 08 09 49 	lsl	r9,r11,r8
8000bf9e:	14 49       	or	r9,r10
8000bfa0:	5f 16       	srne	r6
8000bfa2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bfa6:	0c 4a       	or	r10,r6
8000bfa8:	30 0b       	mov	r11,0
8000bfaa:	30 07       	mov	r7,0
8000bfac:	ca 7b       	rjmp	8000befa <__avr32_f64_sub_longnormalize_done>
8000bfae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfb2 <__avr32_f64_sub_longshift>:
8000bfb2:	f1 b6 04 c0 	satu	r6,0x6
8000bfb6:	f0 0e 17 00 	moveq	lr,r8
8000bfba:	c0 40       	breq	8000bfc2 <__avr32_f64_sub_longshift+0x10>
8000bfbc:	f2 05 09 4e 	lsl	lr,r9,r5
8000bfc0:	10 4e       	or	lr,r8
8000bfc2:	f2 06 0a 48 	lsr	r8,r9,r6
8000bfc6:	30 09       	mov	r9,0
8000bfc8:	58 0e       	cp.w	lr,0
8000bfca:	5f 1e       	srne	lr
8000bfcc:	1c 48       	or	r8,lr
8000bfce:	c8 3b       	rjmp	8000bed4 <__avr32_f64_sub_shift_done>

8000bfd0 <__avr32_f64_sub_longnormalize>:
8000bfd0:	f4 06 12 00 	clz	r6,r10
8000bfd4:	f9 b7 03 00 	movlo	r7,0
8000bfd8:	f9 b6 03 00 	movlo	r6,0
8000bfdc:	f9 bc 03 00 	movlo	r12,0
8000bfe0:	f7 b6 02 e0 	subhs	r6,-32
8000bfe4:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfe8:	30 0a       	mov	r10,0
8000bfea:	0c 17       	sub	r7,r6
8000bfec:	fe 9a ff be 	brle	8000bf68 <__avr32_f64_sub_subnormal_result>
8000bff0:	c8 5b       	rjmp	8000befa <__avr32_f64_sub_longnormalize_done>
8000bff2:	d7 03       	nop

8000bff4 <__avr32_f64_add_from_sub>:
8000bff4:	ee 19 80 00 	eorh	r9,0x8000

8000bff8 <__avr32_f64_add>:
8000bff8:	f7 e9 20 0c 	eor	r12,r11,r9
8000bffc:	fe 96 ff 2e 	brmi	8000be58 <__avr32_f64_sub_from_add>
8000c000:	eb cd 40 e0 	pushm	r5-r7,lr
8000c004:	16 9c       	mov	r12,r11
8000c006:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c00a:	bf db       	cbr	r11,0x1f
8000c00c:	bf d9       	cbr	r9,0x1f
8000c00e:	12 3b       	cp.w	r11,r9
8000c010:	c0 72       	brcc	8000c01e <__avr32_f64_add+0x26>
8000c012:	16 97       	mov	r7,r11
8000c014:	12 9b       	mov	r11,r9
8000c016:	0e 99       	mov	r9,r7
8000c018:	14 97       	mov	r7,r10
8000c01a:	10 9a       	mov	r10,r8
8000c01c:	0e 98       	mov	r8,r7
8000c01e:	30 0e       	mov	lr,0
8000c020:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c024:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c028:	b5 ab       	sbr	r11,0x14
8000c02a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c02e:	c6 20       	breq	8000c0f2 <__avr32_f64_add_op2_subnormal>
8000c030:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c034:	b5 a9       	sbr	r9,0x14
8000c036:	e0 47 07 ff 	cp.w	r7,2047
8000c03a:	c2 80       	breq	8000c08a <__avr32_f64_add_opH_nan_or_inf>
8000c03c:	0e 26       	rsub	r6,r7
8000c03e:	c1 20       	breq	8000c062 <__avr32_f64_add_shift_done>
8000c040:	e0 46 00 36 	cp.w	r6,54
8000c044:	c1 52       	brcc	8000c06e <__avr32_f64_add_res_of_done>
8000c046:	ec 05 11 20 	rsub	r5,r6,32
8000c04a:	e0 46 00 20 	cp.w	r6,32
8000c04e:	c3 52       	brcc	8000c0b8 <__avr32_f64_add_longshift>
8000c050:	f0 05 09 4e 	lsl	lr,r8,r5
8000c054:	f2 05 09 45 	lsl	r5,r9,r5
8000c058:	f0 06 0a 48 	lsr	r8,r8,r6
8000c05c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c060:	0a 48       	or	r8,r5

8000c062 <__avr32_f64_add_shift_done>:
8000c062:	10 0a       	add	r10,r8
8000c064:	f6 09 00 4b 	adc	r11,r11,r9
8000c068:	ed bb 00 15 	bld	r11,0x15
8000c06c:	c3 40       	breq	8000c0d4 <__avr32_f64_add_res_of>

8000c06e <__avr32_f64_add_res_of_done>:
8000c06e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c072:	18 4b       	or	r11,r12

8000c074 <__avr32_f64_add_round>:
8000c074:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c078:	18 4e       	or	lr,r12
8000c07a:	ee 1e 80 00 	eorh	lr,0x8000
8000c07e:	f1 be 04 20 	satu	lr,0x1
8000c082:	1c 0a       	add	r10,lr
8000c084:	5c 0b       	acr	r11
8000c086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c08a <__avr32_f64_add_opH_nan_or_inf>:
8000c08a:	b5 cb       	cbr	r11,0x14
8000c08c:	f7 ea 10 0e 	or	lr,r11,r10
8000c090:	c1 01       	brne	8000c0b0 <__avr32_f64_add_return_nan>
8000c092:	e0 46 07 ff 	cp.w	r6,2047
8000c096:	c0 30       	breq	8000c09c <__avr32_f64_add_opL_nan_or_inf>
8000c098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c09c <__avr32_f64_add_opL_nan_or_inf>:
8000c09c:	b5 c9       	cbr	r9,0x14
8000c09e:	f3 e8 10 0e 	or	lr,r9,r8
8000c0a2:	c0 71       	brne	8000c0b0 <__avr32_f64_add_return_nan>
8000c0a4:	30 0a       	mov	r10,0
8000c0a6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c0aa:	18 4b       	or	r11,r12
8000c0ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0b0 <__avr32_f64_add_return_nan>:
8000c0b0:	3f fa       	mov	r10,-1
8000c0b2:	3f fb       	mov	r11,-1
8000c0b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0b8 <__avr32_f64_add_longshift>:
8000c0b8:	f1 b6 04 c0 	satu	r6,0x6
8000c0bc:	f0 0e 17 00 	moveq	lr,r8
8000c0c0:	c0 60       	breq	8000c0cc <__avr32_f64_add_longshift+0x14>
8000c0c2:	f2 05 09 4e 	lsl	lr,r9,r5
8000c0c6:	58 08       	cp.w	r8,0
8000c0c8:	5f 18       	srne	r8
8000c0ca:	10 4e       	or	lr,r8
8000c0cc:	f2 06 0a 48 	lsr	r8,r9,r6
8000c0d0:	30 09       	mov	r9,0
8000c0d2:	cc 8b       	rjmp	8000c062 <__avr32_f64_add_shift_done>

8000c0d4 <__avr32_f64_add_res_of>:
8000c0d4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c0d8:	a1 9b       	lsr	r11,0x1
8000c0da:	5d 0a       	ror	r10
8000c0dc:	5d 0e       	ror	lr
8000c0de:	2f f7       	sub	r7,-1
8000c0e0:	e0 47 07 ff 	cp.w	r7,2047
8000c0e4:	f9 ba 00 00 	moveq	r10,0
8000c0e8:	f9 bb 00 00 	moveq	r11,0
8000c0ec:	f9 be 00 00 	moveq	lr,0
8000c0f0:	cb fb       	rjmp	8000c06e <__avr32_f64_add_res_of_done>

8000c0f2 <__avr32_f64_add_op2_subnormal>:
8000c0f2:	30 16       	mov	r6,1
8000c0f4:	58 07       	cp.w	r7,0
8000c0f6:	ca 01       	brne	8000c036 <__avr32_f64_add+0x3e>
8000c0f8:	b5 cb       	cbr	r11,0x14
8000c0fa:	10 0a       	add	r10,r8
8000c0fc:	f6 09 00 4b 	adc	r11,r11,r9
8000c100:	18 4b       	or	r11,r12
8000c102:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c106:	d7 03       	nop

8000c108 <__avr32_f64_to_u32>:
8000c108:	58 0b       	cp.w	r11,0
8000c10a:	5e 6d       	retmi	0

8000c10c <__avr32_f64_to_s32>:
8000c10c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c110:	b5 9c       	lsr	r12,0x15
8000c112:	e0 2c 03 ff 	sub	r12,1023
8000c116:	5e 3d       	retlo	0
8000c118:	f8 0c 11 1f 	rsub	r12,r12,31
8000c11c:	16 99       	mov	r9,r11
8000c11e:	ab 7b       	lsl	r11,0xb
8000c120:	bf bb       	sbr	r11,0x1f
8000c122:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c126:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c12a:	a1 79       	lsl	r9,0x1
8000c12c:	5e 2b       	reths	r11
8000c12e:	5c 3b       	neg	r11
8000c130:	5e fb       	retal	r11

8000c132 <__avr32_u32_to_f64>:
8000c132:	f8 cb 00 00 	sub	r11,r12,0
8000c136:	30 0c       	mov	r12,0
8000c138:	c0 38       	rjmp	8000c13e <__avr32_s32_to_f64+0x4>

8000c13a <__avr32_s32_to_f64>:
8000c13a:	18 9b       	mov	r11,r12
8000c13c:	5c 4b       	abs	r11
8000c13e:	30 0a       	mov	r10,0
8000c140:	5e 0b       	reteq	r11
8000c142:	d4 01       	pushm	lr
8000c144:	e0 69 04 1e 	mov	r9,1054
8000c148:	f6 08 12 00 	clz	r8,r11
8000c14c:	c1 70       	breq	8000c17a <__avr32_s32_to_f64+0x40>
8000c14e:	c0 c3       	brcs	8000c166 <__avr32_s32_to_f64+0x2c>
8000c150:	f0 0e 11 20 	rsub	lr,r8,32
8000c154:	f6 08 09 4b 	lsl	r11,r11,r8
8000c158:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c15c:	1c 4b       	or	r11,lr
8000c15e:	f4 08 09 4a 	lsl	r10,r10,r8
8000c162:	10 19       	sub	r9,r8
8000c164:	c0 b8       	rjmp	8000c17a <__avr32_s32_to_f64+0x40>
8000c166:	f4 08 12 00 	clz	r8,r10
8000c16a:	f9 b8 03 00 	movlo	r8,0
8000c16e:	f7 b8 02 e0 	subhs	r8,-32
8000c172:	f4 08 09 4b 	lsl	r11,r10,r8
8000c176:	30 0a       	mov	r10,0
8000c178:	10 19       	sub	r9,r8
8000c17a:	58 09       	cp.w	r9,0
8000c17c:	e0 89 00 30 	brgt	8000c1dc <__avr32_s32_to_f64+0xa2>
8000c180:	5c 39       	neg	r9
8000c182:	2f f9       	sub	r9,-1
8000c184:	e0 49 00 36 	cp.w	r9,54
8000c188:	c0 43       	brcs	8000c190 <__avr32_s32_to_f64+0x56>
8000c18a:	30 0b       	mov	r11,0
8000c18c:	30 0a       	mov	r10,0
8000c18e:	c2 68       	rjmp	8000c1da <__avr32_s32_to_f64+0xa0>
8000c190:	2f 69       	sub	r9,-10
8000c192:	f2 08 11 20 	rsub	r8,r9,32
8000c196:	e0 49 00 20 	cp.w	r9,32
8000c19a:	c0 b2       	brcc	8000c1b0 <__avr32_s32_to_f64+0x76>
8000c19c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c1a0:	f6 08 09 48 	lsl	r8,r11,r8
8000c1a4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c1a8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c1ac:	10 4b       	or	r11,r8
8000c1ae:	c0 88       	rjmp	8000c1be <__avr32_s32_to_f64+0x84>
8000c1b0:	f6 08 09 4e 	lsl	lr,r11,r8
8000c1b4:	14 4e       	or	lr,r10
8000c1b6:	16 9a       	mov	r10,r11
8000c1b8:	30 0b       	mov	r11,0
8000c1ba:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c1be:	ed ba 00 00 	bld	r10,0x0
8000c1c2:	c0 92       	brcc	8000c1d4 <__avr32_s32_to_f64+0x9a>
8000c1c4:	1c 7e       	tst	lr,lr
8000c1c6:	c0 41       	brne	8000c1ce <__avr32_s32_to_f64+0x94>
8000c1c8:	ed ba 00 01 	bld	r10,0x1
8000c1cc:	c0 42       	brcc	8000c1d4 <__avr32_s32_to_f64+0x9a>
8000c1ce:	2f fa       	sub	r10,-1
8000c1d0:	f7 bb 02 ff 	subhs	r11,-1
8000c1d4:	5c fc       	rol	r12
8000c1d6:	5d 0b       	ror	r11
8000c1d8:	5d 0a       	ror	r10
8000c1da:	d8 02       	popm	pc
8000c1dc:	e0 68 03 ff 	mov	r8,1023
8000c1e0:	ed ba 00 0b 	bld	r10,0xb
8000c1e4:	f7 b8 00 ff 	subeq	r8,-1
8000c1e8:	10 0a       	add	r10,r8
8000c1ea:	5c 0b       	acr	r11
8000c1ec:	f7 b9 03 fe 	sublo	r9,-2
8000c1f0:	e0 49 07 ff 	cp.w	r9,2047
8000c1f4:	c0 55       	brlt	8000c1fe <__avr32_s32_to_f64+0xc4>
8000c1f6:	30 0a       	mov	r10,0
8000c1f8:	fc 1b ff e0 	movh	r11,0xffe0
8000c1fc:	c0 c8       	rjmp	8000c214 <__floatsidf_return_op1>
8000c1fe:	ed bb 00 1f 	bld	r11,0x1f
8000c202:	f7 b9 01 01 	subne	r9,1
8000c206:	ab 9a       	lsr	r10,0xb
8000c208:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c20c:	a1 7b       	lsl	r11,0x1
8000c20e:	ab 9b       	lsr	r11,0xb
8000c210:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c214 <__floatsidf_return_op1>:
8000c214:	a1 7c       	lsl	r12,0x1
8000c216:	5d 0b       	ror	r11
8000c218:	d8 02       	popm	pc

8000c21a <__avr32_f64_cmp_eq>:
8000c21a:	10 3a       	cp.w	r10,r8
8000c21c:	f2 0b 13 00 	cpc	r11,r9
8000c220:	c0 80       	breq	8000c230 <__avr32_f64_cmp_eq+0x16>
8000c222:	a1 7b       	lsl	r11,0x1
8000c224:	a1 79       	lsl	r9,0x1
8000c226:	14 4b       	or	r11,r10
8000c228:	12 4b       	or	r11,r9
8000c22a:	10 4b       	or	r11,r8
8000c22c:	5e 0f       	reteq	1
8000c22e:	5e fd       	retal	0
8000c230:	a1 7b       	lsl	r11,0x1
8000c232:	fc 1c ff e0 	movh	r12,0xffe0
8000c236:	58 0a       	cp.w	r10,0
8000c238:	f8 0b 13 00 	cpc	r11,r12
8000c23c:	5e 8f       	retls	1
8000c23e:	5e fd       	retal	0

8000c240 <__avr32_f64_cmp_ge>:
8000c240:	1a de       	st.w	--sp,lr
8000c242:	1a d7       	st.w	--sp,r7
8000c244:	a1 7b       	lsl	r11,0x1
8000c246:	5f 3c       	srlo	r12
8000c248:	a1 79       	lsl	r9,0x1
8000c24a:	5f 37       	srlo	r7
8000c24c:	5c fc       	rol	r12
8000c24e:	fc 1e ff e0 	movh	lr,0xffe0
8000c252:	58 0a       	cp.w	r10,0
8000c254:	fc 0b 13 00 	cpc	r11,lr
8000c258:	e0 8b 00 1d 	brhi	8000c292 <__avr32_f64_cmp_ge+0x52>
8000c25c:	58 08       	cp.w	r8,0
8000c25e:	fc 09 13 00 	cpc	r9,lr
8000c262:	e0 8b 00 18 	brhi	8000c292 <__avr32_f64_cmp_ge+0x52>
8000c266:	58 0b       	cp.w	r11,0
8000c268:	f5 ba 00 00 	subfeq	r10,0
8000c26c:	c1 50       	breq	8000c296 <__avr32_f64_cmp_ge+0x56>
8000c26e:	1b 07       	ld.w	r7,sp++
8000c270:	1b 0e       	ld.w	lr,sp++
8000c272:	58 3c       	cp.w	r12,3
8000c274:	c0 a0       	breq	8000c288 <__avr32_f64_cmp_ge+0x48>
8000c276:	58 1c       	cp.w	r12,1
8000c278:	c0 33       	brcs	8000c27e <__avr32_f64_cmp_ge+0x3e>
8000c27a:	5e 0f       	reteq	1
8000c27c:	5e 1d       	retne	0
8000c27e:	10 3a       	cp.w	r10,r8
8000c280:	f2 0b 13 00 	cpc	r11,r9
8000c284:	5e 2f       	reths	1
8000c286:	5e 3d       	retlo	0
8000c288:	14 38       	cp.w	r8,r10
8000c28a:	f6 09 13 00 	cpc	r9,r11
8000c28e:	5e 2f       	reths	1
8000c290:	5e 3d       	retlo	0
8000c292:	1b 07       	ld.w	r7,sp++
8000c294:	d8 0a       	popm	pc,r12=0
8000c296:	58 17       	cp.w	r7,1
8000c298:	5f 0c       	sreq	r12
8000c29a:	58 09       	cp.w	r9,0
8000c29c:	f5 b8 00 00 	subfeq	r8,0
8000c2a0:	1b 07       	ld.w	r7,sp++
8000c2a2:	1b 0e       	ld.w	lr,sp++
8000c2a4:	5e 0f       	reteq	1
8000c2a6:	5e fc       	retal	r12

8000c2a8 <__avr32_f64_cmp_lt>:
8000c2a8:	1a de       	st.w	--sp,lr
8000c2aa:	1a d7       	st.w	--sp,r7
8000c2ac:	a1 7b       	lsl	r11,0x1
8000c2ae:	5f 3c       	srlo	r12
8000c2b0:	a1 79       	lsl	r9,0x1
8000c2b2:	5f 37       	srlo	r7
8000c2b4:	5c fc       	rol	r12
8000c2b6:	fc 1e ff e0 	movh	lr,0xffe0
8000c2ba:	58 0a       	cp.w	r10,0
8000c2bc:	fc 0b 13 00 	cpc	r11,lr
8000c2c0:	e0 8b 00 1d 	brhi	8000c2fa <__avr32_f64_cmp_lt+0x52>
8000c2c4:	58 08       	cp.w	r8,0
8000c2c6:	fc 09 13 00 	cpc	r9,lr
8000c2ca:	e0 8b 00 18 	brhi	8000c2fa <__avr32_f64_cmp_lt+0x52>
8000c2ce:	58 0b       	cp.w	r11,0
8000c2d0:	f5 ba 00 00 	subfeq	r10,0
8000c2d4:	c1 50       	breq	8000c2fe <__avr32_f64_cmp_lt+0x56>
8000c2d6:	1b 07       	ld.w	r7,sp++
8000c2d8:	1b 0e       	ld.w	lr,sp++
8000c2da:	58 3c       	cp.w	r12,3
8000c2dc:	c0 a0       	breq	8000c2f0 <__avr32_f64_cmp_lt+0x48>
8000c2de:	58 1c       	cp.w	r12,1
8000c2e0:	c0 33       	brcs	8000c2e6 <__avr32_f64_cmp_lt+0x3e>
8000c2e2:	5e 0d       	reteq	0
8000c2e4:	5e 1f       	retne	1
8000c2e6:	10 3a       	cp.w	r10,r8
8000c2e8:	f2 0b 13 00 	cpc	r11,r9
8000c2ec:	5e 2d       	reths	0
8000c2ee:	5e 3f       	retlo	1
8000c2f0:	14 38       	cp.w	r8,r10
8000c2f2:	f6 09 13 00 	cpc	r9,r11
8000c2f6:	5e 2d       	reths	0
8000c2f8:	5e 3f       	retlo	1
8000c2fa:	1b 07       	ld.w	r7,sp++
8000c2fc:	d8 0a       	popm	pc,r12=0
8000c2fe:	58 17       	cp.w	r7,1
8000c300:	5f 1c       	srne	r12
8000c302:	58 09       	cp.w	r9,0
8000c304:	f5 b8 00 00 	subfeq	r8,0
8000c308:	1b 07       	ld.w	r7,sp++
8000c30a:	1b 0e       	ld.w	lr,sp++
8000c30c:	5e 0d       	reteq	0
8000c30e:	5e fc       	retal	r12

8000c310 <__avr32_f64_div>:
8000c310:	eb cd 40 ff 	pushm	r0-r7,lr
8000c314:	f7 e9 20 0e 	eor	lr,r11,r9
8000c318:	f6 07 16 14 	lsr	r7,r11,0x14
8000c31c:	a9 7b       	lsl	r11,0x9
8000c31e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c322:	a9 7a       	lsl	r10,0x9
8000c324:	bd bb       	sbr	r11,0x1d
8000c326:	e4 1b 3f ff 	andh	r11,0x3fff
8000c32a:	ab d7       	cbr	r7,0xb
8000c32c:	e0 80 00 cc 	breq	8000c4c4 <__avr32_f64_div_round_subnormal+0x54>
8000c330:	e0 47 07 ff 	cp.w	r7,2047
8000c334:	e0 84 00 b5 	brge	8000c49e <__avr32_f64_div_round_subnormal+0x2e>
8000c338:	f2 06 16 14 	lsr	r6,r9,0x14
8000c33c:	a9 79       	lsl	r9,0x9
8000c33e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c342:	a9 78       	lsl	r8,0x9
8000c344:	bd b9       	sbr	r9,0x1d
8000c346:	e4 19 3f ff 	andh	r9,0x3fff
8000c34a:	ab d6       	cbr	r6,0xb
8000c34c:	e0 80 00 e2 	breq	8000c510 <__avr32_f64_div_round_subnormal+0xa0>
8000c350:	e0 46 07 ff 	cp.w	r6,2047
8000c354:	e0 84 00 b2 	brge	8000c4b8 <__avr32_f64_div_round_subnormal+0x48>
8000c358:	0c 17       	sub	r7,r6
8000c35a:	fe 37 fc 01 	sub	r7,-1023
8000c35e:	fc 1c 80 00 	movh	r12,0x8000
8000c362:	f8 03 16 01 	lsr	r3,r12,0x1
8000c366:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c36a:	5c d4       	com	r4
8000c36c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c370:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c374:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c378:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c37c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c380:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c384:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c388:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c38c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c390:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c394:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c398:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c39c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3a0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c3a4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c3a8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3ac:	02 04       	add	r4,r1
8000c3ae:	5c 05       	acr	r5
8000c3b0:	a3 65       	lsl	r5,0x2
8000c3b2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c3b6:	a3 64       	lsl	r4,0x2
8000c3b8:	5c 34       	neg	r4
8000c3ba:	f8 05 01 45 	sbc	r5,r12,r5
8000c3be:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c3c2:	e4 05 07 40 	macu.d	r0,r2,r5
8000c3c6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3ca:	02 04       	add	r4,r1
8000c3cc:	5c 05       	acr	r5
8000c3ce:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3d2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c3d6:	e8 02 15 02 	lsl	r2,r4,0x2
8000c3da:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c3de:	e4 09 07 40 	macu.d	r0,r2,r9
8000c3e2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3e6:	02 04       	add	r4,r1
8000c3e8:	5c 05       	acr	r5
8000c3ea:	a3 65       	lsl	r5,0x2
8000c3ec:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c3f0:	a3 64       	lsl	r4,0x2
8000c3f2:	5c 34       	neg	r4
8000c3f4:	f8 05 01 45 	sbc	r5,r12,r5
8000c3f8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c3fc:	e4 05 07 40 	macu.d	r0,r2,r5
8000c400:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c404:	02 04       	add	r4,r1
8000c406:	5c 05       	acr	r5
8000c408:	ea 03 15 02 	lsl	r3,r5,0x2
8000c40c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c410:	e8 02 15 02 	lsl	r2,r4,0x2
8000c414:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c418:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c41c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c420:	02 02       	add	r2,r1
8000c422:	5c 03       	acr	r3
8000c424:	ed b3 00 1c 	bld	r3,0x1c
8000c428:	c0 90       	breq	8000c43a <__avr32_f64_div+0x12a>
8000c42a:	a1 72       	lsl	r2,0x1
8000c42c:	5c f3       	rol	r3
8000c42e:	20 17       	sub	r7,1
8000c430:	a3 9a       	lsr	r10,0x3
8000c432:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c436:	a3 9b       	lsr	r11,0x3
8000c438:	c0 58       	rjmp	8000c442 <__avr32_f64_div+0x132>
8000c43a:	a5 8a       	lsr	r10,0x4
8000c43c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c440:	a5 8b       	lsr	r11,0x4
8000c442:	58 07       	cp.w	r7,0
8000c444:	e0 8a 00 8b 	brle	8000c55a <__avr32_f64_div_res_subnormal>
8000c448:	e0 12 ff 00 	andl	r2,0xff00
8000c44c:	e8 12 00 80 	orl	r2,0x80
8000c450:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c454:	e4 09 07 40 	macu.d	r0,r2,r9
8000c458:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c45c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c460:	00 05       	add	r5,r0
8000c462:	f0 01 00 48 	adc	r8,r8,r1
8000c466:	5c 09       	acr	r9
8000c468:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c46c:	58 04       	cp.w	r4,0
8000c46e:	5c 25       	cpc	r5

8000c470 <__avr32_f64_div_round_subnormal>:
8000c470:	f4 08 13 00 	cpc	r8,r10
8000c474:	f6 09 13 00 	cpc	r9,r11
8000c478:	5f 36       	srlo	r6
8000c47a:	f8 06 17 00 	moveq	r6,r12
8000c47e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c482:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c486:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c48a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c48e:	ed be 00 1f 	bld	lr,0x1f
8000c492:	ef bb 00 1f 	bst	r11,0x1f
8000c496:	0c 0a       	add	r10,r6
8000c498:	5c 0b       	acr	r11
8000c49a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c49e:	e4 1b 00 0f 	andh	r11,0xf
8000c4a2:	14 4b       	or	r11,r10
8000c4a4:	e0 81 00 a7 	brne	8000c5f2 <__avr32_f64_div_res_subnormal+0x98>
8000c4a8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c4ac:	ab d6       	cbr	r6,0xb
8000c4ae:	e0 46 07 ff 	cp.w	r6,2047
8000c4b2:	e0 81 00 a4 	brne	8000c5fa <__avr32_f64_div_res_subnormal+0xa0>
8000c4b6:	c9 e8       	rjmp	8000c5f2 <__avr32_f64_div_res_subnormal+0x98>
8000c4b8:	e4 19 00 0f 	andh	r9,0xf
8000c4bc:	10 49       	or	r9,r8
8000c4be:	e0 81 00 9a 	brne	8000c5f2 <__avr32_f64_div_res_subnormal+0x98>
8000c4c2:	c9 28       	rjmp	8000c5e6 <__avr32_f64_div_res_subnormal+0x8c>
8000c4c4:	a3 7b       	lsl	r11,0x3
8000c4c6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c4ca:	a3 7a       	lsl	r10,0x3
8000c4cc:	f5 eb 10 04 	or	r4,r10,r11
8000c4d0:	e0 80 00 a0 	breq	8000c610 <__avr32_f64_div_op1_zero>
8000c4d4:	f6 04 12 00 	clz	r4,r11
8000c4d8:	c1 70       	breq	8000c506 <__avr32_f64_div_round_subnormal+0x96>
8000c4da:	c0 c3       	brcs	8000c4f2 <__avr32_f64_div_round_subnormal+0x82>
8000c4dc:	e8 05 11 20 	rsub	r5,r4,32
8000c4e0:	f6 04 09 4b 	lsl	r11,r11,r4
8000c4e4:	f4 05 0a 45 	lsr	r5,r10,r5
8000c4e8:	0a 4b       	or	r11,r5
8000c4ea:	f4 04 09 4a 	lsl	r10,r10,r4
8000c4ee:	08 17       	sub	r7,r4
8000c4f0:	c0 b8       	rjmp	8000c506 <__avr32_f64_div_round_subnormal+0x96>
8000c4f2:	f4 04 12 00 	clz	r4,r10
8000c4f6:	f9 b4 03 00 	movlo	r4,0
8000c4fa:	f7 b4 02 e0 	subhs	r4,-32
8000c4fe:	f4 04 09 4b 	lsl	r11,r10,r4
8000c502:	30 0a       	mov	r10,0
8000c504:	08 17       	sub	r7,r4
8000c506:	a3 8a       	lsr	r10,0x2
8000c508:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c50c:	a3 8b       	lsr	r11,0x2
8000c50e:	c1 1b       	rjmp	8000c330 <__avr32_f64_div+0x20>
8000c510:	a3 79       	lsl	r9,0x3
8000c512:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c516:	a3 78       	lsl	r8,0x3
8000c518:	f3 e8 10 04 	or	r4,r9,r8
8000c51c:	c6 f0       	breq	8000c5fa <__avr32_f64_div_res_subnormal+0xa0>
8000c51e:	f2 04 12 00 	clz	r4,r9
8000c522:	c1 70       	breq	8000c550 <__avr32_f64_div_round_subnormal+0xe0>
8000c524:	c0 c3       	brcs	8000c53c <__avr32_f64_div_round_subnormal+0xcc>
8000c526:	e8 05 11 20 	rsub	r5,r4,32
8000c52a:	f2 04 09 49 	lsl	r9,r9,r4
8000c52e:	f0 05 0a 45 	lsr	r5,r8,r5
8000c532:	0a 49       	or	r9,r5
8000c534:	f0 04 09 48 	lsl	r8,r8,r4
8000c538:	08 16       	sub	r6,r4
8000c53a:	c0 b8       	rjmp	8000c550 <__avr32_f64_div_round_subnormal+0xe0>
8000c53c:	f0 04 12 00 	clz	r4,r8
8000c540:	f9 b4 03 00 	movlo	r4,0
8000c544:	f7 b4 02 e0 	subhs	r4,-32
8000c548:	f0 04 09 49 	lsl	r9,r8,r4
8000c54c:	30 08       	mov	r8,0
8000c54e:	08 16       	sub	r6,r4
8000c550:	a3 88       	lsr	r8,0x2
8000c552:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c556:	a3 89       	lsr	r9,0x2
8000c558:	cf ca       	rjmp	8000c350 <__avr32_f64_div+0x40>

8000c55a <__avr32_f64_div_res_subnormal>:
8000c55a:	5c 37       	neg	r7
8000c55c:	2f f7       	sub	r7,-1
8000c55e:	f1 b7 04 c0 	satu	r7,0x6
8000c562:	e0 47 00 20 	cp.w	r7,32
8000c566:	c1 54       	brge	8000c590 <__avr32_f64_div_res_subnormal+0x36>
8000c568:	ee 06 11 20 	rsub	r6,r7,32
8000c56c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c570:	e6 06 09 4c 	lsl	r12,r3,r6
8000c574:	18 42       	or	r2,r12
8000c576:	e6 07 0a 43 	lsr	r3,r3,r7
8000c57a:	f4 06 09 41 	lsl	r1,r10,r6
8000c57e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c582:	f6 06 09 4c 	lsl	r12,r11,r6
8000c586:	18 4a       	or	r10,r12
8000c588:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c58c:	30 00       	mov	r0,0
8000c58e:	c1 58       	rjmp	8000c5b8 <__avr32_f64_div_res_subnormal+0x5e>
8000c590:	ee 06 11 20 	rsub	r6,r7,32
8000c594:	f9 b0 00 00 	moveq	r0,0
8000c598:	f9 bc 00 00 	moveq	r12,0
8000c59c:	c0 50       	breq	8000c5a6 <__avr32_f64_div_res_subnormal+0x4c>
8000c59e:	f4 06 09 40 	lsl	r0,r10,r6
8000c5a2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c5a6:	e6 07 0a 42 	lsr	r2,r3,r7
8000c5aa:	30 03       	mov	r3,0
8000c5ac:	f4 07 0a 41 	lsr	r1,r10,r7
8000c5b0:	18 41       	or	r1,r12
8000c5b2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c5b6:	30 0b       	mov	r11,0
8000c5b8:	e0 12 ff 00 	andl	r2,0xff00
8000c5bc:	e8 12 00 80 	orl	r2,0x80
8000c5c0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c5c4:	e4 09 07 46 	macu.d	r6,r2,r9
8000c5c8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c5cc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c5d0:	0c 05       	add	r5,r6
8000c5d2:	f0 07 00 48 	adc	r8,r8,r7
8000c5d6:	5c 09       	acr	r9
8000c5d8:	30 07       	mov	r7,0
8000c5da:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c5de:	00 34       	cp.w	r4,r0
8000c5e0:	e2 05 13 00 	cpc	r5,r1
8000c5e4:	c4 6b       	rjmp	8000c470 <__avr32_f64_div_round_subnormal>
8000c5e6:	1c 9b       	mov	r11,lr
8000c5e8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c5ec:	30 0a       	mov	r10,0
8000c5ee:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c5f2:	3f fb       	mov	r11,-1
8000c5f4:	30 0a       	mov	r10,0
8000c5f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c5fa:	f5 eb 10 04 	or	r4,r10,r11
8000c5fe:	c0 90       	breq	8000c610 <__avr32_f64_div_op1_zero>
8000c600:	1c 9b       	mov	r11,lr
8000c602:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c606:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c60a:	30 0a       	mov	r10,0
8000c60c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c610 <__avr32_f64_div_op1_zero>:
8000c610:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c614:	ce f0       	breq	8000c5f2 <__avr32_f64_div_res_subnormal+0x98>
8000c616:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c61a:	e0 44 07 ff 	cp.w	r4,2047
8000c61e:	ce 41       	brne	8000c5e6 <__avr32_f64_div_res_subnormal+0x8c>
8000c620:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c624:	ce 10       	breq	8000c5e6 <__avr32_f64_div_res_subnormal+0x8c>
8000c626:	ce 6b       	rjmp	8000c5f2 <__avr32_f64_div_res_subnormal+0x98>

8000c628 <__avr32_udiv64>:
8000c628:	d4 31       	pushm	r0-r7,lr
8000c62a:	1a 97       	mov	r7,sp
8000c62c:	20 3d       	sub	sp,12
8000c62e:	10 9c       	mov	r12,r8
8000c630:	12 9e       	mov	lr,r9
8000c632:	14 93       	mov	r3,r10
8000c634:	58 09       	cp.w	r9,0
8000c636:	e0 81 00 bd 	brne	8000c7b0 <__avr32_udiv64+0x188>
8000c63a:	16 38       	cp.w	r8,r11
8000c63c:	e0 88 00 40 	brls	8000c6bc <__avr32_udiv64+0x94>
8000c640:	f0 08 12 00 	clz	r8,r8
8000c644:	c0 d0       	breq	8000c65e <__avr32_udiv64+0x36>
8000c646:	f6 08 09 4b 	lsl	r11,r11,r8
8000c64a:	f0 09 11 20 	rsub	r9,r8,32
8000c64e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c652:	f4 09 0a 49 	lsr	r9,r10,r9
8000c656:	f4 08 09 43 	lsl	r3,r10,r8
8000c65a:	f3 eb 10 0b 	or	r11,r9,r11
8000c65e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c662:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c666:	f6 0e 0d 00 	divu	r0,r11,lr
8000c66a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c66e:	00 99       	mov	r9,r0
8000c670:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c674:	e0 0a 02 48 	mul	r8,r0,r10
8000c678:	10 3b       	cp.w	r11,r8
8000c67a:	c0 a2       	brcc	8000c68e <__avr32_udiv64+0x66>
8000c67c:	20 19       	sub	r9,1
8000c67e:	18 0b       	add	r11,r12
8000c680:	18 3b       	cp.w	r11,r12
8000c682:	c0 63       	brcs	8000c68e <__avr32_udiv64+0x66>
8000c684:	10 3b       	cp.w	r11,r8
8000c686:	f7 b9 03 01 	sublo	r9,1
8000c68a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c68e:	f6 08 01 01 	sub	r1,r11,r8
8000c692:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c696:	e2 0e 0d 00 	divu	r0,r1,lr
8000c69a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c69e:	00 98       	mov	r8,r0
8000c6a0:	e0 0a 02 4a 	mul	r10,r0,r10
8000c6a4:	14 33       	cp.w	r3,r10
8000c6a6:	c0 82       	brcc	8000c6b6 <__avr32_udiv64+0x8e>
8000c6a8:	20 18       	sub	r8,1
8000c6aa:	18 03       	add	r3,r12
8000c6ac:	18 33       	cp.w	r3,r12
8000c6ae:	c0 43       	brcs	8000c6b6 <__avr32_udiv64+0x8e>
8000c6b0:	14 33       	cp.w	r3,r10
8000c6b2:	f7 b8 03 01 	sublo	r8,1
8000c6b6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c6ba:	cd f8       	rjmp	8000c878 <__avr32_udiv64+0x250>
8000c6bc:	58 08       	cp.w	r8,0
8000c6be:	c0 51       	brne	8000c6c8 <__avr32_udiv64+0xa0>
8000c6c0:	30 19       	mov	r9,1
8000c6c2:	f2 08 0d 08 	divu	r8,r9,r8
8000c6c6:	10 9c       	mov	r12,r8
8000c6c8:	f8 06 12 00 	clz	r6,r12
8000c6cc:	c0 41       	brne	8000c6d4 <__avr32_udiv64+0xac>
8000c6ce:	18 1b       	sub	r11,r12
8000c6d0:	30 19       	mov	r9,1
8000c6d2:	c4 08       	rjmp	8000c752 <__avr32_udiv64+0x12a>
8000c6d4:	ec 01 11 20 	rsub	r1,r6,32
8000c6d8:	f4 01 0a 49 	lsr	r9,r10,r1
8000c6dc:	f8 06 09 4c 	lsl	r12,r12,r6
8000c6e0:	f6 06 09 48 	lsl	r8,r11,r6
8000c6e4:	f6 01 0a 41 	lsr	r1,r11,r1
8000c6e8:	f3 e8 10 08 	or	r8,r9,r8
8000c6ec:	f8 03 16 10 	lsr	r3,r12,0x10
8000c6f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c6f4:	e2 03 0d 00 	divu	r0,r1,r3
8000c6f8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c6fc:	00 9e       	mov	lr,r0
8000c6fe:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c702:	e0 05 02 49 	mul	r9,r0,r5
8000c706:	12 3b       	cp.w	r11,r9
8000c708:	c0 a2       	brcc	8000c71c <__avr32_udiv64+0xf4>
8000c70a:	20 1e       	sub	lr,1
8000c70c:	18 0b       	add	r11,r12
8000c70e:	18 3b       	cp.w	r11,r12
8000c710:	c0 63       	brcs	8000c71c <__avr32_udiv64+0xf4>
8000c712:	12 3b       	cp.w	r11,r9
8000c714:	f7 be 03 01 	sublo	lr,1
8000c718:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c71c:	12 1b       	sub	r11,r9
8000c71e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c722:	f6 03 0d 02 	divu	r2,r11,r3
8000c726:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c72a:	04 99       	mov	r9,r2
8000c72c:	e4 05 02 4b 	mul	r11,r2,r5
8000c730:	16 38       	cp.w	r8,r11
8000c732:	c0 a2       	brcc	8000c746 <__avr32_udiv64+0x11e>
8000c734:	20 19       	sub	r9,1
8000c736:	18 08       	add	r8,r12
8000c738:	18 38       	cp.w	r8,r12
8000c73a:	c0 63       	brcs	8000c746 <__avr32_udiv64+0x11e>
8000c73c:	16 38       	cp.w	r8,r11
8000c73e:	f7 b9 03 01 	sublo	r9,1
8000c742:	f1 dc e3 08 	addcs	r8,r8,r12
8000c746:	f4 06 09 43 	lsl	r3,r10,r6
8000c74a:	f0 0b 01 0b 	sub	r11,r8,r11
8000c74e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c752:	f8 06 16 10 	lsr	r6,r12,0x10
8000c756:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c75a:	f6 06 0d 00 	divu	r0,r11,r6
8000c75e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c762:	00 9a       	mov	r10,r0
8000c764:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c768:	e0 0e 02 48 	mul	r8,r0,lr
8000c76c:	10 3b       	cp.w	r11,r8
8000c76e:	c0 a2       	brcc	8000c782 <__avr32_udiv64+0x15a>
8000c770:	20 1a       	sub	r10,1
8000c772:	18 0b       	add	r11,r12
8000c774:	18 3b       	cp.w	r11,r12
8000c776:	c0 63       	brcs	8000c782 <__avr32_udiv64+0x15a>
8000c778:	10 3b       	cp.w	r11,r8
8000c77a:	f7 ba 03 01 	sublo	r10,1
8000c77e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c782:	f6 08 01 01 	sub	r1,r11,r8
8000c786:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c78a:	e2 06 0d 00 	divu	r0,r1,r6
8000c78e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c792:	00 98       	mov	r8,r0
8000c794:	e0 0e 02 4b 	mul	r11,r0,lr
8000c798:	16 33       	cp.w	r3,r11
8000c79a:	c0 82       	brcc	8000c7aa <__avr32_udiv64+0x182>
8000c79c:	20 18       	sub	r8,1
8000c79e:	18 03       	add	r3,r12
8000c7a0:	18 33       	cp.w	r3,r12
8000c7a2:	c0 43       	brcs	8000c7aa <__avr32_udiv64+0x182>
8000c7a4:	16 33       	cp.w	r3,r11
8000c7a6:	f7 b8 03 01 	sublo	r8,1
8000c7aa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c7ae:	c6 98       	rjmp	8000c880 <__avr32_udiv64+0x258>
8000c7b0:	16 39       	cp.w	r9,r11
8000c7b2:	e0 8b 00 65 	brhi	8000c87c <__avr32_udiv64+0x254>
8000c7b6:	f2 09 12 00 	clz	r9,r9
8000c7ba:	c0 b1       	brne	8000c7d0 <__avr32_udiv64+0x1a8>
8000c7bc:	10 3a       	cp.w	r10,r8
8000c7be:	5f 2a       	srhs	r10
8000c7c0:	1c 3b       	cp.w	r11,lr
8000c7c2:	5f b8       	srhi	r8
8000c7c4:	10 4a       	or	r10,r8
8000c7c6:	f2 0a 18 00 	cp.b	r10,r9
8000c7ca:	c5 90       	breq	8000c87c <__avr32_udiv64+0x254>
8000c7cc:	30 18       	mov	r8,1
8000c7ce:	c5 98       	rjmp	8000c880 <__avr32_udiv64+0x258>
8000c7d0:	f0 09 09 46 	lsl	r6,r8,r9
8000c7d4:	f2 03 11 20 	rsub	r3,r9,32
8000c7d8:	fc 09 09 4e 	lsl	lr,lr,r9
8000c7dc:	f0 03 0a 48 	lsr	r8,r8,r3
8000c7e0:	f6 09 09 4c 	lsl	r12,r11,r9
8000c7e4:	f4 03 0a 42 	lsr	r2,r10,r3
8000c7e8:	ef 46 ff f4 	st.w	r7[-12],r6
8000c7ec:	f6 03 0a 43 	lsr	r3,r11,r3
8000c7f0:	18 42       	or	r2,r12
8000c7f2:	f1 ee 10 0c 	or	r12,r8,lr
8000c7f6:	f8 01 16 10 	lsr	r1,r12,0x10
8000c7fa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c7fe:	e6 01 0d 04 	divu	r4,r3,r1
8000c802:	e4 03 16 10 	lsr	r3,r2,0x10
8000c806:	08 9e       	mov	lr,r4
8000c808:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c80c:	e8 06 02 48 	mul	r8,r4,r6
8000c810:	10 33       	cp.w	r3,r8
8000c812:	c0 a2       	brcc	8000c826 <__avr32_udiv64+0x1fe>
8000c814:	20 1e       	sub	lr,1
8000c816:	18 03       	add	r3,r12
8000c818:	18 33       	cp.w	r3,r12
8000c81a:	c0 63       	brcs	8000c826 <__avr32_udiv64+0x1fe>
8000c81c:	10 33       	cp.w	r3,r8
8000c81e:	f7 be 03 01 	sublo	lr,1
8000c822:	e7 dc e3 03 	addcs	r3,r3,r12
8000c826:	10 13       	sub	r3,r8
8000c828:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c82c:	e6 01 0d 00 	divu	r0,r3,r1
8000c830:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c834:	00 98       	mov	r8,r0
8000c836:	e0 06 02 46 	mul	r6,r0,r6
8000c83a:	0c 3b       	cp.w	r11,r6
8000c83c:	c0 a2       	brcc	8000c850 <__avr32_udiv64+0x228>
8000c83e:	20 18       	sub	r8,1
8000c840:	18 0b       	add	r11,r12
8000c842:	18 3b       	cp.w	r11,r12
8000c844:	c0 63       	brcs	8000c850 <__avr32_udiv64+0x228>
8000c846:	0c 3b       	cp.w	r11,r6
8000c848:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c84c:	f7 b8 03 01 	sublo	r8,1
8000c850:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c854:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c858:	0c 1b       	sub	r11,r6
8000c85a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c85e:	06 95       	mov	r5,r3
8000c860:	16 35       	cp.w	r5,r11
8000c862:	e0 8b 00 0a 	brhi	8000c876 <__avr32_udiv64+0x24e>
8000c866:	5f 0b       	sreq	r11
8000c868:	f4 09 09 49 	lsl	r9,r10,r9
8000c86c:	12 32       	cp.w	r2,r9
8000c86e:	5f b9       	srhi	r9
8000c870:	f7 e9 00 09 	and	r9,r11,r9
8000c874:	c0 60       	breq	8000c880 <__avr32_udiv64+0x258>
8000c876:	20 18       	sub	r8,1
8000c878:	30 09       	mov	r9,0
8000c87a:	c0 38       	rjmp	8000c880 <__avr32_udiv64+0x258>
8000c87c:	30 09       	mov	r9,0
8000c87e:	12 98       	mov	r8,r9
8000c880:	10 9a       	mov	r10,r8
8000c882:	12 93       	mov	r3,r9
8000c884:	10 92       	mov	r2,r8
8000c886:	12 9b       	mov	r11,r9
8000c888:	2f dd       	sub	sp,-12
8000c88a:	d8 32       	popm	r0-r7,pc

8000c88c <__avr32_umod64>:
8000c88c:	d4 31       	pushm	r0-r7,lr
8000c88e:	1a 97       	mov	r7,sp
8000c890:	20 3d       	sub	sp,12
8000c892:	10 9c       	mov	r12,r8
8000c894:	12 95       	mov	r5,r9
8000c896:	14 9e       	mov	lr,r10
8000c898:	16 91       	mov	r1,r11
8000c89a:	16 96       	mov	r6,r11
8000c89c:	58 09       	cp.w	r9,0
8000c89e:	e0 81 00 81 	brne	8000c9a0 <__avr32_umod64+0x114>
8000c8a2:	16 38       	cp.w	r8,r11
8000c8a4:	e0 88 00 12 	brls	8000c8c8 <__avr32_umod64+0x3c>
8000c8a8:	f0 08 12 00 	clz	r8,r8
8000c8ac:	c4 e0       	breq	8000c948 <__avr32_umod64+0xbc>
8000c8ae:	f6 08 09 46 	lsl	r6,r11,r8
8000c8b2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8b6:	f0 0b 11 20 	rsub	r11,r8,32
8000c8ba:	f4 08 09 4e 	lsl	lr,r10,r8
8000c8be:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c8c2:	f7 e6 10 06 	or	r6,r11,r6
8000c8c6:	c4 18       	rjmp	8000c948 <__avr32_umod64+0xbc>
8000c8c8:	58 08       	cp.w	r8,0
8000c8ca:	c0 51       	brne	8000c8d4 <__avr32_umod64+0x48>
8000c8cc:	30 19       	mov	r9,1
8000c8ce:	f2 08 0d 08 	divu	r8,r9,r8
8000c8d2:	10 9c       	mov	r12,r8
8000c8d4:	f8 08 12 00 	clz	r8,r12
8000c8d8:	c0 31       	brne	8000c8de <__avr32_umod64+0x52>
8000c8da:	18 16       	sub	r6,r12
8000c8dc:	c3 68       	rjmp	8000c948 <__avr32_umod64+0xbc>
8000c8de:	f0 03 11 20 	rsub	r3,r8,32
8000c8e2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c8e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8ea:	ec 08 09 49 	lsl	r9,r6,r8
8000c8ee:	ec 03 0a 43 	lsr	r3,r6,r3
8000c8f2:	f7 e9 10 09 	or	r9,r11,r9
8000c8f6:	f8 05 16 10 	lsr	r5,r12,0x10
8000c8fa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c8fe:	e6 05 0d 02 	divu	r2,r3,r5
8000c902:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c906:	ec 02 02 4b 	mul	r11,r6,r2
8000c90a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c90e:	16 3e       	cp.w	lr,r11
8000c910:	c0 72       	brcc	8000c91e <__avr32_umod64+0x92>
8000c912:	18 0e       	add	lr,r12
8000c914:	18 3e       	cp.w	lr,r12
8000c916:	c0 43       	brcs	8000c91e <__avr32_umod64+0x92>
8000c918:	16 3e       	cp.w	lr,r11
8000c91a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c91e:	fc 0b 01 03 	sub	r3,lr,r11
8000c922:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c926:	e6 05 0d 02 	divu	r2,r3,r5
8000c92a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c92e:	a5 36       	mul	r6,r2
8000c930:	0c 39       	cp.w	r9,r6
8000c932:	c0 72       	brcc	8000c940 <__avr32_umod64+0xb4>
8000c934:	18 09       	add	r9,r12
8000c936:	18 39       	cp.w	r9,r12
8000c938:	c0 43       	brcs	8000c940 <__avr32_umod64+0xb4>
8000c93a:	0c 39       	cp.w	r9,r6
8000c93c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c940:	f2 06 01 06 	sub	r6,r9,r6
8000c944:	f4 08 09 4e 	lsl	lr,r10,r8
8000c948:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c94c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c950:	ec 0a 0d 02 	divu	r2,r6,r10
8000c954:	fc 09 16 10 	lsr	r9,lr,0x10
8000c958:	ea 02 02 4b 	mul	r11,r5,r2
8000c95c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c960:	16 39       	cp.w	r9,r11
8000c962:	c0 72       	brcc	8000c970 <__avr32_umod64+0xe4>
8000c964:	18 09       	add	r9,r12
8000c966:	18 39       	cp.w	r9,r12
8000c968:	c0 43       	brcs	8000c970 <__avr32_umod64+0xe4>
8000c96a:	16 39       	cp.w	r9,r11
8000c96c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c970:	f2 0b 01 0b 	sub	r11,r9,r11
8000c974:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c978:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c97c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c980:	ea 0a 02 4a 	mul	r10,r5,r10
8000c984:	14 3e       	cp.w	lr,r10
8000c986:	c0 72       	brcc	8000c994 <__avr32_umod64+0x108>
8000c988:	18 0e       	add	lr,r12
8000c98a:	18 3e       	cp.w	lr,r12
8000c98c:	c0 43       	brcs	8000c994 <__avr32_umod64+0x108>
8000c98e:	14 3e       	cp.w	lr,r10
8000c990:	fd dc e3 0e 	addcs	lr,lr,r12
8000c994:	fc 0a 01 0a 	sub	r10,lr,r10
8000c998:	30 0b       	mov	r11,0
8000c99a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c99e:	c7 b8       	rjmp	8000ca94 <__avr32_umod64+0x208>
8000c9a0:	16 39       	cp.w	r9,r11
8000c9a2:	e0 8b 00 79 	brhi	8000ca94 <__avr32_umod64+0x208>
8000c9a6:	f2 09 12 00 	clz	r9,r9
8000c9aa:	c1 21       	brne	8000c9ce <__avr32_umod64+0x142>
8000c9ac:	10 3a       	cp.w	r10,r8
8000c9ae:	5f 2b       	srhs	r11
8000c9b0:	0a 31       	cp.w	r1,r5
8000c9b2:	5f ba       	srhi	r10
8000c9b4:	f7 ea 10 0a 	or	r10,r11,r10
8000c9b8:	f2 0a 18 00 	cp.b	r10,r9
8000c9bc:	c0 60       	breq	8000c9c8 <__avr32_umod64+0x13c>
8000c9be:	fc 08 01 0c 	sub	r12,lr,r8
8000c9c2:	e2 05 01 46 	sbc	r6,r1,r5
8000c9c6:	18 9e       	mov	lr,r12
8000c9c8:	0c 9b       	mov	r11,r6
8000c9ca:	1c 9a       	mov	r10,lr
8000c9cc:	c6 48       	rjmp	8000ca94 <__avr32_umod64+0x208>
8000c9ce:	ea 09 09 4c 	lsl	r12,r5,r9
8000c9d2:	f2 06 11 20 	rsub	r6,r9,32
8000c9d6:	f6 09 09 4b 	lsl	r11,r11,r9
8000c9da:	f0 09 09 42 	lsl	r2,r8,r9
8000c9de:	ef 46 ff f4 	st.w	r7[-12],r6
8000c9e2:	f0 06 0a 48 	lsr	r8,r8,r6
8000c9e6:	18 48       	or	r8,r12
8000c9e8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c9ec:	f4 09 09 43 	lsl	r3,r10,r9
8000c9f0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c9f4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c9f8:	16 4a       	or	r10,r11
8000c9fa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c9fe:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca02:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ca06:	08 91       	mov	r1,r4
8000ca08:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ca0c:	e8 0e 02 46 	mul	r6,r4,lr
8000ca10:	0c 3c       	cp.w	r12,r6
8000ca12:	c0 a2       	brcc	8000ca26 <__avr32_umod64+0x19a>
8000ca14:	20 11       	sub	r1,1
8000ca16:	10 0c       	add	r12,r8
8000ca18:	10 3c       	cp.w	r12,r8
8000ca1a:	c0 63       	brcs	8000ca26 <__avr32_umod64+0x19a>
8000ca1c:	0c 3c       	cp.w	r12,r6
8000ca1e:	f7 b1 03 01 	sublo	r1,1
8000ca22:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ca26:	0c 1c       	sub	r12,r6
8000ca28:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ca2c:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca30:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ca34:	08 96       	mov	r6,r4
8000ca36:	e8 0e 02 4e 	mul	lr,r4,lr
8000ca3a:	1c 3b       	cp.w	r11,lr
8000ca3c:	c0 a2       	brcc	8000ca50 <__avr32_umod64+0x1c4>
8000ca3e:	20 16       	sub	r6,1
8000ca40:	10 0b       	add	r11,r8
8000ca42:	10 3b       	cp.w	r11,r8
8000ca44:	c0 63       	brcs	8000ca50 <__avr32_umod64+0x1c4>
8000ca46:	1c 3b       	cp.w	r11,lr
8000ca48:	f7 b6 03 01 	sublo	r6,1
8000ca4c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ca50:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ca54:	1c 1b       	sub	r11,lr
8000ca56:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ca5a:	00 9e       	mov	lr,r0
8000ca5c:	02 9c       	mov	r12,r1
8000ca5e:	16 3c       	cp.w	r12,r11
8000ca60:	e0 8b 00 08 	brhi	8000ca70 <__avr32_umod64+0x1e4>
8000ca64:	5f 06       	sreq	r6
8000ca66:	06 30       	cp.w	r0,r3
8000ca68:	5f ba       	srhi	r10
8000ca6a:	ed ea 00 0a 	and	r10,r6,r10
8000ca6e:	c0 60       	breq	8000ca7a <__avr32_umod64+0x1ee>
8000ca70:	fc 02 01 04 	sub	r4,lr,r2
8000ca74:	f8 08 01 4c 	sbc	r12,r12,r8
8000ca78:	08 9e       	mov	lr,r4
8000ca7a:	e6 0e 01 0a 	sub	r10,r3,lr
8000ca7e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ca82:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ca86:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ca8a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ca8e:	f8 01 09 4c 	lsl	r12,r12,r1
8000ca92:	18 4a       	or	r10,r12
8000ca94:	2f dd       	sub	sp,-12
8000ca96:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 78 	sub	pc,pc,28792

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c4 87 	rcall	80005614 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c4 80 	rcall	80005614 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c4 79 	rcall	80005614 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c4 72 	rcall	80005614 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
