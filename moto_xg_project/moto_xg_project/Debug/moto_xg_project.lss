
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a79c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000011d4  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000dbd4  8000dbd4  0000dfd4  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000dbd8  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e610  0000ea3c  2**0
                  ALLOC
  8 .bss          00005968  00000a40  8000e610  0000ea40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000011d0  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000026c8  00000000  00000000  0000fc40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000290b9  00000000  00000000  00012308  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006b3c  00000000  00000000  0003b3c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0001586b  00000000  00000000  00041efd  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002ef8  00000000  00000000  00057768  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000073fb  00000000  00000000  0005a660  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d146  00000000  00000000  00061a5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 01543281  00000000  00000000  0006eba1  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 20 .debug_ranges 000012a8  00000000  00000000  015b1e28  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c8 60 	sub	pc,pc,-14240

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 8c       	ld.ub	r12,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
														
		
};

void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	46 a8       	lddsp	r8,sp[0x1a8]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 2c       	sub	r12,-126
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2e f0       	sub	r0,-17
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ca 00       	breq	80001fc2 <_trampoline+0x1fc2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	66 98       	ld.w	r8,r3[0x24]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			{
				xcmp_IdleTestTone();						
				if(isAudioRouting == 0)
8000209c:	49 74       	lddpc	r4,800020f8 <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000209e:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a0:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a2:	30 22       	mov	r2,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a4:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 97       	mov	r7,r8
800020a8:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c1 71       	brne	800020e2 <app_cfg+0x52>
		{	
			{
				xcmp_IdleTestTone();						
800020b6:	f0 1f 00 12 	mcall	800020fc <app_cfg+0x6c>
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 31       	brne	800020c4 <app_cfg+0x34>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c0:	89 03       	st.w	r4[0x0],r3
800020c2:	c1 08       	rjmp	800020e2 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c4:	58 18       	cp.w	r8,1
800020c6:	c0 31       	brne	800020cc <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020c8:	89 02       	st.w	r4[0x0],r2
800020ca:	c0 c8       	rjmp	800020e2 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020cc:	58 28       	cp.w	r8,2
800020ce:	c0 31       	brne	800020d4 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d0:	89 01       	st.w	r4[0x0],r1
800020d2:	c0 88       	rjmp	800020e2 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d4:	58 38       	cp.w	r8,3
800020d6:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020da:	f7 b8 01 ff 	subne	r8,-1
800020de:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e2:	0a 9b       	mov	r11,r5
800020e4:	0e 9c       	mov	r12,r7
800020e6:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020ea:	ce 1b       	rjmp	800020ac <app_cfg+0x1c>
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	63 d0       	ld.w	r0,r1[0x74]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 48       	or	r8,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d 8c       	ld.ub	r12,r6[0x0]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 44       	or	r4,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	47 a8       	lddsp	r8,sp[0x1e8]
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	65 38       	ld.w	r8,r2[0x4c]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	ca 08       	rjmp	80002252 <ButtonConfig_brdcst_func+0x5e>
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	6a 5c       	ld.w	r12,r5[0x14]

80002118 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002118:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211a:	48 3c       	lddpc	r12,80002124 <FD_brdcst_func+0xc>
8000211c:	f0 1f 00 03 	mcall	80002128 <FD_brdcst_func+0x10>
	
}
80002120:	d8 02       	popm	pc
80002122:	00 00       	add	r0,r0
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	ca 0c       	rcall	80002266 <ButtonConfig_brdcst_func+0x72>
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	6a 5c       	ld.w	r12,r5[0x14]

8000212c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000212c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000212e:	48 3c       	lddpc	r12,80002138 <FD_reply_func+0xc>
80002130:	f0 1f 00 03 	mcall	8000213c <FD_reply_func+0x10>
	
	
}
80002134:	d8 02       	popm	pc
80002136:	00 00       	add	r0,r0
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	ca 2c       	rcall	8000227e <ButtonConfig_brdcst_func+0x8a>
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	6a 5c       	ld.w	r12,r5[0x14]

80002140 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002140:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002142:	48 3c       	lddpc	r12,8000214c <FD_request_func+0xc>
80002144:	f0 1f 00 03 	mcall	80002150 <FD_request_func+0x10>
	
	
}
80002148:	d8 02       	popm	pc
8000214a:	00 00       	add	r0,r0
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	ca 48       	rjmp	80002296 <ButtonConfig_brdcst_func+0xa2>
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	6a 5c       	ld.w	r12,r5[0x14]

80002154 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002154:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002156:	48 3c       	lddpc	r12,80002160 <EnOB_brdcst_func+0xc>
80002158:	f0 1f 00 03 	mcall	80002164 <EnOB_brdcst_func+0x10>
}
8000215c:	d8 02       	popm	pc
8000215e:	00 00       	add	r0,r0
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	ca 64       	brge	800020ae <app_cfg+0x1e>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	6a 5c       	ld.w	r12,r5[0x14]

80002168 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	30 08       	mov	r8,0
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c1 91       	brne	800021a8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002178:	19 b8       	ld.ub	r8,r12[0x3]
8000217a:	30 19       	mov	r9,1
8000217c:	f2 08 18 00 	cp.b	r8,r9
80002180:	c0 61       	brne	8000218c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002182:	49 0c       	lddpc	r12,800021c0 <EnOB_reply_func+0x58>
80002184:	f0 1f 00 10 	mcall	800021c4 <EnOB_reply_func+0x5c>
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000218c:	58 08       	cp.w	r8,0
8000218e:	c0 61       	brne	8000219a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002190:	48 ec       	lddpc	r12,800021c8 <EnOB_reply_func+0x60>
80002192:	f0 1f 00 0d 	mcall	800021c4 <EnOB_reply_func+0x5c>
80002196:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219a:	1a d8       	st.w	--sp,r8
8000219c:	48 cc       	lddpc	r12,800021cc <EnOB_reply_func+0x64>
8000219e:	f0 1f 00 0a 	mcall	800021c4 <EnOB_reply_func+0x5c>
800021a2:	2f fd       	sub	sp,-4
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <EnOB_reply_func+0x68>
800021aa:	f0 1f 00 07 	mcall	800021c4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ae:	0f a8       	ld.ub	r8,r7[0x2]
800021b0:	1a d8       	st.w	--sp,r8
800021b2:	48 9c       	lddpc	r12,800021d4 <EnOB_reply_func+0x6c>
800021b4:	f0 1f 00 04 	mcall	800021c4 <EnOB_reply_func+0x5c>
800021b8:	2f fd       	sub	sp,-4
800021ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800021be:	00 00       	add	r0,r0
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	ca 7c       	rcall	80002310 <Phyuserinput_brdcst_func+0x40>
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	6a 5c       	ld.w	r12,r5[0x14]
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	ca 94       	brge	8000211c <FD_brdcst_func+0x4>
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	ca a8       	rjmp	80002322 <Phyuserinput_brdcst_func+0x52>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	ca c0       	breq	8000212a <FD_brdcst_func+0x12>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	ca dc       	rcall	80002330 <Phyuserinput_brdcst_func+0x60>

800021d8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021d8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021da:	19 a9       	ld.ub	r9,r12[0x2]
800021dc:	31 18       	mov	r8,17
800021de:	f0 09 18 00 	cp.b	r9,r8
800021e2:	c0 41       	brne	800021ea <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021e4:	48 2c       	lddpc	r12,800021ec <SingleDetection_brdcst_func+0x14>
800021e6:	f0 1f 00 03 	mcall	800021f0 <SingleDetection_brdcst_func+0x18>
800021ea:	d8 02       	popm	pc
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	ca f4       	brge	8000214c <FD_request_func+0xc>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	6a 5c       	ld.w	r12,r5[0x14]

800021f4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021f6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021fa:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021fc:	4a bc       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xb4>
800021fe:	f0 1f 00 2c 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002202:	0f 88       	ld.ub	r8,r7[0x0]
80002204:	1a d8       	st.w	--sp,r8
80002206:	4a bc       	lddpc	r12,800022b0 <ButtonConfig_brdcst_func+0xbc>
80002208:	f0 1f 00 29 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000220c:	1a d5       	st.w	--sp,r5
8000220e:	4a ac       	lddpc	r12,800022b4 <ButtonConfig_brdcst_func+0xc0>
80002210:	f0 1f 00 27 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002214:	0f a8       	ld.ub	r8,r7[0x2]
80002216:	1a d8       	st.w	--sp,r8
80002218:	4a 8c       	lddpc	r12,800022b8 <ButtonConfig_brdcst_func+0xc4>
8000221a:	f0 1f 00 25 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000221e:	2f dd       	sub	sp,-12
80002220:	58 05       	cp.w	r5,0
80002222:	c4 10       	breq	800022a4 <ButtonConfig_brdcst_func+0xb0>
80002224:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002226:	4a 64       	lddpc	r4,800022bc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002228:	4a 63       	lddpc	r3,800022c0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000222a:	4a 72       	lddpc	r2,800022c4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000222c:	4a 71       	lddpc	r1,800022c8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000222e:	4a 80       	lddpc	r0,800022cc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002230:	0f b9       	ld.ub	r9,r7[0x3]
80002232:	0f c8       	ld.ub	r8,r7[0x4]
80002234:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002238:	1a d8       	st.w	--sp,r8
8000223a:	1a d6       	st.w	--sp,r6
8000223c:	08 9c       	mov	r12,r4
8000223e:	f0 1f 00 1c 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002242:	0f d9       	ld.ub	r9,r7[0x5]
80002244:	0f e8       	ld.ub	r8,r7[0x6]
80002246:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	1a d6       	st.w	--sp,r6
8000224e:	06 9c       	mov	r12,r3
80002250:	f0 1f 00 17 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002254:	0f f9       	ld.ub	r9,r7[0x7]
80002256:	ef 38 00 08 	ld.ub	r8,r7[8]
8000225a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225e:	1a d8       	st.w	--sp,r8
80002260:	1a d6       	st.w	--sp,r6
80002262:	04 9c       	mov	r12,r2
80002264:	f0 1f 00 12 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002268:	ef 39 00 09 	ld.ub	r9,r7[9]
8000226c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002270:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002274:	1a d8       	st.w	--sp,r8
80002276:	1a d6       	st.w	--sp,r6
80002278:	02 9c       	mov	r12,r1
8000227a:	f0 1f 00 0d 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000227e:	2f 8d       	sub	sp,-32
80002280:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002284:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002288:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000228c:	1a d8       	st.w	--sp,r8
8000228e:	1a d6       	st.w	--sp,r6
80002290:	00 9c       	mov	r12,r0
80002292:	f0 1f 00 07 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
80002296:	2f f6       	sub	r6,-1
80002298:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000229a:	2f ed       	sub	sp,-8
8000229c:	ec 05 18 00 	cp.b	r5,r6
800022a0:	fe 9b ff c8 	brhi	80002230 <ButtonConfig_brdcst_func+0x3c>
800022a4:	d8 32       	popm	r0-r7,pc
800022a6:	00 00       	add	r0,r0
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cb 08       	rjmp	8000240a <DataSession_brdcst_func+0x7e>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	6a 5c       	ld.w	r12,r5[0x14]
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cb 28       	rjmp	80002416 <DataSession_reply_func+0x6>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cb 3c       	rcall	8000241c <DataSession_reply_func+0xc>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	cb 54       	brge	80002224 <ButtonConfig_brdcst_func+0x30>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	cb 74       	brge	8000222c <ButtonConfig_brdcst_func+0x38>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	cb 9c       	rcall	80002434 <DataSession_reply_func+0x24>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cb c4       	brge	8000223e <ButtonConfig_brdcst_func+0x4a>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	cb e8       	rjmp	80002446 <DataSession_reply_func+0x36>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	cc 10       	breq	80002250 <ButtonConfig_brdcst_func+0x5c>

800022d0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022d0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022d4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022d6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022d8:	19 c7       	ld.ub	r7,r12[0x4]
800022da:	19 d8       	ld.ub	r8,r12[0x5]
800022dc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022e0:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022e2:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022e4:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022e8:	49 0c       	lddpc	r12,80002328 <Phyuserinput_brdcst_func+0x58>
800022ea:	f0 1f 00 11 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022ee:	1a d6       	st.w	--sp,r6
800022f0:	49 0c       	lddpc	r12,80002330 <Phyuserinput_brdcst_func+0x60>
800022f2:	f0 1f 00 0f 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022f6:	1a d5       	st.w	--sp,r5
800022f8:	48 fc       	lddpc	r12,80002334 <Phyuserinput_brdcst_func+0x64>
800022fa:	f0 1f 00 0d 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022fe:	5c 77       	castu.h	r7
80002300:	1a d7       	st.w	--sp,r7
80002302:	48 ec       	lddpc	r12,80002338 <Phyuserinput_brdcst_func+0x68>
80002304:	f0 1f 00 0a 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002308:	1a d4       	st.w	--sp,r4
8000230a:	48 dc       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x6c>
8000230c:	f0 1f 00 08 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002310:	1a d3       	st.w	--sp,r3
80002312:	48 cc       	lddpc	r12,80002340 <Phyuserinput_brdcst_func+0x70>
80002314:	f0 1f 00 06 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002318:	1a d2       	st.w	--sp,r2
8000231a:	48 bc       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x74>
8000231c:	f0 1f 00 04 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
80002320:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002322:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002326:	00 00       	add	r0,r0
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	cc 34       	brge	800022b0 <ButtonConfig_brdcst_func+0xbc>
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	6a 5c       	ld.w	r12,r5[0x14]
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	cc 58       	rjmp	800024bc <TransmitControl_brdcst_func+0x10>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	cc 70       	breq	800022c4 <ButtonConfig_brdcst_func+0xd0>
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	cc 84       	brge	800022ca <ButtonConfig_brdcst_func+0xd6>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	cc 98       	rjmp	800024d0 <TransmitControl_brdcst_func+0x24>
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	cc ac       	rcall	800024d6 <TransmitControl_brdcst_func+0x2a>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	cc cc       	rcall	800024de <TransmitControl_brdcst_func+0x32>

80002348 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002348:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000234c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002350:	0f 89       	ld.ub	r9,r7[0x0]
80002352:	30 08       	mov	r8,0
80002354:	f0 09 18 00 	cp.b	r9,r8
80002358:	c0 c1       	brne	80002370 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000235a:	48 9c       	lddpc	r12,8000237c <ButtonConfig_reply_func+0x34>
8000235c:	f0 1f 00 09 	mcall	80002380 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002360:	0f 98       	ld.ub	r8,r7[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <ButtonConfig_reply_func+0x3c>
80002366:	f0 1f 00 07 	mcall	80002380 <ButtonConfig_reply_func+0x38>
8000236a:	2f fd       	sub	sp,-4
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002370:	48 6c       	lddpc	r12,80002388 <ButtonConfig_reply_func+0x40>
80002372:	f0 1f 00 04 	mcall	80002380 <ButtonConfig_reply_func+0x38>
80002376:	e3 cd 80 80 	ldm	sp++,r7,pc
8000237a:	00 00       	add	r0,r0
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	cc ec       	rcall	8000251a <TransmitControl_reply_func+0x26>
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	6a 5c       	ld.w	r12,r5[0x14]
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	cb 28       	rjmp	800024ea <TransmitControl_brdcst_func+0x3e>
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	cd 04       	brge	8000232a <Phyuserinput_brdcst_func+0x5a>

8000238c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000238c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000238e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002392:	0d 88       	ld.ub	r8,r6[0x0]
80002394:	32 49       	mov	r9,36
80002396:	f2 08 18 00 	cp.b	r8,r9
8000239a:	c2 91       	brne	800023ec <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000239c:	49 7c       	lddpc	r12,800023f8 <DataSession_brdcst_func+0x6c>
8000239e:	f0 1f 00 18 	mcall	800023fc <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023a2:	0d a5       	ld.ub	r5,r6[0x2]
800023a4:	0d b8       	ld.ub	r8,r6[0x3]
800023a6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023aa:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023ac:	0d 98       	ld.ub	r8,r6[0x1]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 4c       	lddpc	r12,80002400 <DataSession_brdcst_func+0x74>
800023b2:	f0 1f 00 13 	mcall	800023fc <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023b6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ba:	1a d8       	st.w	--sp,r8
800023bc:	49 2c       	lddpc	r12,80002404 <DataSession_brdcst_func+0x78>
800023be:	f0 1f 00 10 	mcall	800023fc <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023c2:	2f ed       	sub	sp,-8
800023c4:	58 05       	cp.w	r5,0
800023c6:	c1 80       	breq	800023f6 <DataSession_brdcst_func+0x6a>
800023c8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023ca:	49 04       	lddpc	r4,80002408 <DataSession_brdcst_func+0x7c>
800023cc:	ec 07 00 08 	add	r8,r6,r7
800023d0:	11 c8       	ld.ub	r8,r8[0x4]
800023d2:	1a d8       	st.w	--sp,r8
800023d4:	1a d7       	st.w	--sp,r7
800023d6:	08 9c       	mov	r12,r4
800023d8:	f0 1f 00 09 	mcall	800023fc <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023dc:	2f f7       	sub	r7,-1
800023de:	5c 57       	castu.b	r7
800023e0:	2f ed       	sub	sp,-8
800023e2:	ee 05 19 00 	cp.h	r5,r7
800023e6:	fe 9b ff f3 	brhi	800023cc <DataSession_brdcst_func+0x40>
800023ea:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023ec:	1a d8       	st.w	--sp,r8
800023ee:	48 8c       	lddpc	r12,8000240c <DataSession_brdcst_func+0x80>
800023f0:	f0 1f 00 03 	mcall	800023fc <DataSession_brdcst_func+0x70>
800023f4:	2f fd       	sub	sp,-4
800023f6:	d8 22       	popm	r4-r7,pc
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	cd 20       	breq	8000239e <DataSession_brdcst_func+0x12>
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	6a 5c       	ld.w	r12,r5[0x14]
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	cd 34       	brge	800023a8 <DataSession_brdcst_func+0x1c>
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	cd 4c       	rcall	800025ae <Volume_reply_func+0x2a>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	cd 68       	rjmp	800025b6 <Volume_reply_func+0x32>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	cd 80       	breq	800023be <DataSession_brdcst_func+0x32>

80002410 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002410:	eb cd 40 80 	pushm	r7,lr
80002414:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002416:	19 a8       	ld.ub	r8,r12[0x2]
80002418:	58 08       	cp.w	r8,0
8000241a:	c0 61       	brne	80002426 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
8000241c:	48 dc       	lddpc	r12,80002450 <DataSession_reply_func+0x40>
8000241e:	f0 1f 00 0e 	mcall	80002454 <DataSession_reply_func+0x44>
80002422:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 cc       	lddpc	r12,80002458 <DataSession_reply_func+0x48>
8000242a:	f0 1f 00 0b 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000242e:	48 cc       	lddpc	r12,8000245c <DataSession_reply_func+0x4c>
80002430:	f0 1f 00 09 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002434:	0f b8       	ld.ub	r8,r7[0x3]
80002436:	1a d8       	st.w	--sp,r8
80002438:	48 ac       	lddpc	r12,80002460 <DataSession_reply_func+0x50>
8000243a:	f0 1f 00 07 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000243e:	0f c8       	ld.ub	r8,r7[0x4]
80002440:	1a d8       	st.w	--sp,r8
80002442:	48 9c       	lddpc	r12,80002464 <DataSession_reply_func+0x54>
80002444:	f0 1f 00 04 	mcall	80002454 <DataSession_reply_func+0x44>
80002448:	2f dd       	sub	sp,-12
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000244e:	00 00       	add	r0,r0
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	cd 94       	brge	80002404 <DataSession_brdcst_func+0x78>
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	6a 5c       	ld.w	r12,r5[0x14]
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	cd a8       	rjmp	8000260e <spk_brdcst_func+0x26>
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	cd bc       	rcall	80002614 <spk_brdcst_func+0x2c>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	cd d0       	breq	8000241c <DataSession_reply_func+0xc>
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	cd e0       	breq	80002422 <DataSession_reply_func+0x12>

80002468 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002468:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000246c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002470:	0f 98       	ld.ub	r8,r7[0x1]
80002472:	1a d8       	st.w	--sp,r8
80002474:	48 bc       	lddpc	r12,800024a0 <CallControl_brdcst_func+0x38>
80002476:	f0 1f 00 0c 	mcall	800024a4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000247a:	2f fd       	sub	sp,-4
8000247c:	0f 99       	ld.ub	r9,r7[0x1]
8000247e:	30 38       	mov	r8,3
80002480:	f0 09 18 00 	cp.b	r9,r8
80002484:	c0 41       	brne	8000248c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002486:	30 09       	mov	r9,0
80002488:	48 88       	lddpc	r8,800024a8 <CallControl_brdcst_func+0x40>
8000248a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 48       	mov	r8,4
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 41       	brne	8000249c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002496:	30 19       	mov	r9,1
80002498:	48 48       	lddpc	r8,800024a8 <CallControl_brdcst_func+0x40>
8000249a:	b0 89       	st.b	r8[0x0],r9
8000249c:	e3 cd 80 80 	ldm	sp++,r7,pc
800024a0:	80 00       	ld.sh	r0,r0[0x0]
800024a2:	cd f0       	breq	80002460 <DataSession_reply_func+0x50>
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	6a 5c       	ld.w	r12,r5[0x14]
800024a8:	00 00       	add	r0,r0
800024aa:	0a 4e       	or	lr,r5

800024ac <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024ac:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024b0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 08       	mov	r8,0
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 71       	brne	800024ca <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024be:	48 ac       	lddpc	r12,800024e4 <TransmitControl_brdcst_func+0x38>
800024c0:	f0 1f 00 0a 	mcall	800024e8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024c4:	30 09       	mov	r9,0
800024c6:	48 a8       	lddpc	r8,800024ec <TransmitControl_brdcst_func+0x40>
800024c8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ca:	0f 99       	ld.ub	r9,r7[0x1]
800024cc:	30 18       	mov	r8,1
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 71       	brne	800024e0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024d4:	48 7c       	lddpc	r12,800024f0 <TransmitControl_brdcst_func+0x44>
800024d6:	f0 1f 00 05 	mcall	800024e8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024da:	30 19       	mov	r9,1
800024dc:	48 48       	lddpc	r8,800024ec <TransmitControl_brdcst_func+0x40>
800024de:	b0 89       	st.b	r8[0x0],r9
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	ce 08       	rjmp	800026a6 <mic_brdcst_func+0x3e>
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	6a 5c       	ld.w	r12,r5[0x14]
800024ec:	00 00       	add	r0,r0
800024ee:	0a 4d       	or	sp,r5
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	ce 20       	breq	800024b6 <TransmitControl_brdcst_func+0xa>

800024f4 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024fc:	0f 89       	ld.ub	r9,r7[0x0]
800024fe:	30 08       	mov	r8,0
80002500:	f0 09 18 00 	cp.b	r9,r8
80002504:	c1 61       	brne	80002530 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002506:	48 ec       	lddpc	r12,8000253c <TransmitControl_reply_func+0x48>
80002508:	f0 1f 00 0e 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000250c:	0f 98       	ld.ub	r8,r7[0x1]
8000250e:	1a d8       	st.w	--sp,r8
80002510:	48 dc       	lddpc	r12,80002544 <TransmitControl_reply_func+0x50>
80002512:	f0 1f 00 0c 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002516:	0f a8       	ld.ub	r8,r7[0x2]
80002518:	1a d8       	st.w	--sp,r8
8000251a:	48 cc       	lddpc	r12,80002548 <TransmitControl_reply_func+0x54>
8000251c:	f0 1f 00 09 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002520:	0f b8       	ld.ub	r8,r7[0x3]
80002522:	1a d8       	st.w	--sp,r8
80002524:	48 ac       	lddpc	r12,8000254c <TransmitControl_reply_func+0x58>
80002526:	f0 1f 00 07 	mcall	80002540 <TransmitControl_reply_func+0x4c>
8000252a:	2f dd       	sub	sp,-12
8000252c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002530:	48 8c       	lddpc	r12,80002550 <TransmitControl_reply_func+0x5c>
80002532:	f0 1f 00 04 	mcall	80002540 <TransmitControl_reply_func+0x4c>
80002536:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253a:	00 00       	add	r0,r0
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	ce 34       	brge	80002504 <TransmitControl_reply_func+0x10>
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	6a 5c       	ld.w	r12,r5[0x14]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	ce 50       	breq	80002510 <TransmitControl_reply_func+0x1c>
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	ce 64       	brge	80002516 <TransmitControl_reply_func+0x22>
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	ce 80       	breq	8000251e <TransmitControl_reply_func+0x2a>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	ce 90       	breq	80002524 <TransmitControl_reply_func+0x30>

80002554 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002556:	19 a9       	ld.ub	r9,r12[0x2]
80002558:	30 08       	mov	r8,0
8000255a:	f0 09 18 00 	cp.b	r9,r8
8000255e:	c0 71       	brne	8000256c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002560:	48 5c       	lddpc	r12,80002574 <AudioRoutingControl_reply_func+0x20>
80002562:	f0 1f 00 06 	mcall	80002578 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002566:	f0 1f 00 06 	mcall	8000257c <AudioRoutingControl_reply_func+0x28>
8000256a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000256c:	48 5c       	lddpc	r12,80002580 <AudioRoutingControl_reply_func+0x2c>
8000256e:	f0 1f 00 03 	mcall	80002578 <AudioRoutingControl_reply_func+0x24>
80002572:	d8 02       	popm	pc
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	ce a8       	rjmp	8000274a <mic_reply_func+0x8a>
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	6a 5c       	ld.w	r12,r5[0x14]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	47 a8       	lddsp	r8,sp[0x1e8]
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	ce b8       	rjmp	80002758 <dcm_brdcst_func+0x4>

80002584 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002584:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002588:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000258c:	0f 89       	ld.ub	r9,r7[0x0]
8000258e:	30 08       	mov	r8,0
80002590:	f0 09 18 00 	cp.b	r9,r8
80002594:	c1 b1       	brne	800025ca <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002596:	0f b8       	ld.ub	r8,r7[0x3]
80002598:	31 09       	mov	r9,16
8000259a:	f2 08 18 00 	cp.b	r8,r9
8000259e:	c0 f1       	brne	800025bc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025a0:	48 dc       	lddpc	r12,800025d4 <Volume_reply_func+0x50>
800025a2:	f0 1f 00 0e 	mcall	800025d8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025a6:	0f 99       	ld.ub	r9,r7[0x1]
800025a8:	0f a8       	ld.ub	r8,r7[0x2]
800025aa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ae:	1a d8       	st.w	--sp,r8
800025b0:	48 bc       	lddpc	r12,800025dc <Volume_reply_func+0x58>
800025b2:	f0 1f 00 0a 	mcall	800025d8 <Volume_reply_func+0x54>
800025b6:	2f fd       	sub	sp,-4
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025bc:	1a d8       	st.w	--sp,r8
800025be:	48 9c       	lddpc	r12,800025e0 <Volume_reply_func+0x5c>
800025c0:	f0 1f 00 06 	mcall	800025d8 <Volume_reply_func+0x54>
800025c4:	2f fd       	sub	sp,-4
800025c6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ca:	48 7c       	lddpc	r12,800025e4 <Volume_reply_func+0x60>
800025cc:	f0 1f 00 03 	mcall	800025d8 <Volume_reply_func+0x54>
800025d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	ce cc       	rcall	800027ae <dcm_reply_func+0x12>
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	6a 5c       	ld.w	r12,r5[0x14]
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	ce e0       	breq	800025ba <Volume_reply_func+0x36>
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	ce fc       	rcall	800027c0 <dcm_reply_func+0x24>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	cf 14       	brge	800025c8 <Volume_reply_func+0x44>

800025e8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ea:	19 d9       	ld.ub	r9,r12[0x5]
800025ec:	30 08       	mov	r8,0
800025ee:	f0 09 18 00 	cp.b	r9,r8
800025f2:	c0 81       	brne	80002602 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025f4:	10 99       	mov	r9,r8
800025f6:	48 78       	lddpc	r8,80002610 <spk_brdcst_func+0x28>
800025f8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025fa:	48 7c       	lddpc	r12,80002614 <spk_brdcst_func+0x2c>
800025fc:	f0 1f 00 07 	mcall	80002618 <spk_brdcst_func+0x30>
80002600:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002602:	30 19       	mov	r9,1
80002604:	48 38       	lddpc	r8,80002610 <spk_brdcst_func+0x28>
80002606:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002608:	48 5c       	lddpc	r12,8000261c <spk_brdcst_func+0x34>
8000260a:	f0 1f 00 04 	mcall	80002618 <spk_brdcst_func+0x30>
8000260e:	d8 02       	popm	pc
80002610:	00 00       	add	r0,r0
80002612:	0a 40       	or	r0,r5
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	cf 2c       	rcall	800027fa <dcm_reply_func+0x5e>
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	6a 5c       	ld.w	r12,r5[0x14]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	cf 3c       	rcall	80002804 <ToneControl_reply_func>

80002620 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002620:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002622:	19 a9       	ld.ub	r9,r12[0x2]
80002624:	30 08       	mov	r8,0
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 f1       	brne	80002648 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000262c:	19 e9       	ld.ub	r9,r12[0x6]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 40       	breq	8000263a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002634:	30 19       	mov	r9,1
80002636:	48 98       	lddpc	r8,80002658 <spk_reply_func+0x38>
80002638:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263a:	19 e8       	ld.ub	r8,r12[0x6]
8000263c:	1a d8       	st.w	--sp,r8
8000263e:	48 8c       	lddpc	r12,8000265c <spk_reply_func+0x3c>
80002640:	f0 1f 00 08 	mcall	80002660 <spk_reply_func+0x40>
80002644:	2f fd       	sub	sp,-4
80002646:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002648:	30 09       	mov	r9,0
8000264a:	48 48       	lddpc	r8,80002658 <spk_reply_func+0x38>
8000264c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000264e:	48 6c       	lddpc	r12,80002664 <spk_reply_func+0x44>
80002650:	f0 1f 00 04 	mcall	80002660 <spk_reply_func+0x40>
80002654:	d8 02       	popm	pc
80002656:	00 00       	add	r0,r0
80002658:	00 00       	add	r0,r0
8000265a:	0a 40       	or	r0,r5
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	cf 48       	rjmp	80002846 <app_payload_rx_proc+0x1a>
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	6a 5c       	ld.w	r12,r5[0x14]
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	cf 58       	rjmp	80002850 <app_payload_rx_proc+0x24>

80002668 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002668:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000266c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002670:	0f a9       	ld.ub	r9,r7[0x2]
80002672:	30 08       	mov	r8,0
80002674:	f0 09 18 00 	cp.b	r9,r8
80002678:	c0 71       	brne	80002686 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000267a:	48 dc       	lddpc	r12,800026ac <mic_brdcst_func+0x44>
8000267c:	f0 1f 00 0d 	mcall	800026b0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002680:	30 09       	mov	r9,0
80002682:	48 d8       	lddpc	r8,800026b4 <mic_brdcst_func+0x4c>
80002684:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002686:	0f a9       	ld.ub	r9,r7[0x2]
80002688:	31 18       	mov	r8,17
8000268a:	f0 09 18 00 	cp.b	r9,r8
8000268e:	c0 d1       	brne	800026a8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002690:	48 ac       	lddpc	r12,800026b8 <mic_brdcst_func+0x50>
80002692:	f0 1f 00 08 	mcall	800026b0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002696:	48 89       	lddpc	r9,800026b4 <mic_brdcst_func+0x4c>
80002698:	30 18       	mov	r8,1
8000269a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000269c:	13 89       	ld.ub	r9,r9[0x0]
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c0 31       	brne	800026a8 <mic_brdcst_func+0x40>
800026a4:	48 68       	lddpc	r8,800026bc <mic_brdcst_func+0x54>
800026a6:	11 88       	ld.ub	r8,r8[0x0]
800026a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	cf 64       	brge	8000269a <mic_brdcst_func+0x32>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	6a 5c       	ld.w	r12,r5[0x14]
800026b4:	00 00       	add	r0,r0
800026b6:	0a 56       	eor	r6,r5
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	cf 78       	rjmp	800028a8 <DeviceInitializationStatus_brdcst_func+0x30>
800026bc:	00 00       	add	r0,r0
800026be:	0a 4e       	or	lr,r5

800026c0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026c4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026c8:	49 ac       	lddpc	r12,80002730 <mic_reply_func+0x70>
800026ca:	f0 1f 00 1b 	mcall	80002734 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ce:	0f 89       	ld.ub	r9,r7[0x0]
800026d0:	30 08       	mov	r8,0
800026d2:	f0 09 18 00 	cp.b	r9,r8
800026d6:	c2 71       	brne	80002724 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026d8:	0f 98       	ld.ub	r8,r7[0x1]
800026da:	30 29       	mov	r9,2
800026dc:	f2 08 18 00 	cp.b	r8,r9
800026e0:	c1 b1       	brne	80002716 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026e2:	49 6c       	lddpc	r12,80002738 <mic_reply_func+0x78>
800026e4:	f0 1f 00 14 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026e8:	0f a8       	ld.ub	r8,r7[0x2]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	49 4c       	lddpc	r12,8000273c <mic_reply_func+0x7c>
800026ee:	f0 1f 00 12 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026f2:	0f b8       	ld.ub	r8,r7[0x3]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	49 3c       	lddpc	r12,80002740 <mic_reply_func+0x80>
800026f8:	f0 1f 00 0f 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026fc:	0f c8       	ld.ub	r8,r7[0x4]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	49 1c       	lddpc	r12,80002744 <mic_reply_func+0x84>
80002702:	f0 1f 00 0d 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002706:	0f d8       	ld.ub	r8,r7[0x5]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	49 0c       	lddpc	r12,80002748 <mic_reply_func+0x88>
8000270c:	f0 1f 00 0a 	mcall	80002734 <mic_reply_func+0x74>
80002710:	2f cd       	sub	sp,-16
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002716:	1a d8       	st.w	--sp,r8
80002718:	48 dc       	lddpc	r12,8000274c <mic_reply_func+0x8c>
8000271a:	f0 1f 00 07 	mcall	80002734 <mic_reply_func+0x74>
8000271e:	2f fd       	sub	sp,-4
80002720:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002724:	48 bc       	lddpc	r12,80002750 <mic_reply_func+0x90>
80002726:	f0 1f 00 04 	mcall	80002734 <mic_reply_func+0x74>
8000272a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272e:	00 00       	add	r0,r0
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	cf 8c       	rcall	80002922 <send_flash_command+0x72>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	6a 5c       	ld.w	r12,r5[0x14]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	cf 9c       	rcall	8000292c <send_flash_command+0x7c>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	cf b0       	breq	80002734 <mic_reply_func+0x74>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	cf c4       	brge	8000273a <mic_reply_func+0x7a>
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	cf e0       	breq	80002742 <mic_reply_func+0x82>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	cf f8       	rjmp	80002948 <send_flash_command+0x98>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	d0 10       	acall	0x1
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	d0 28       	*unknown*

80002754 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002754:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002758:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000275c:	48 bc       	lddpc	r12,80002788 <dcm_brdcst_func+0x34>
8000275e:	f0 1f 00 0c 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002762:	0f 88       	ld.ub	r8,r7[0x0]
80002764:	1a d8       	st.w	--sp,r8
80002766:	48 bc       	lddpc	r12,80002790 <dcm_brdcst_func+0x3c>
80002768:	f0 1f 00 09 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000276c:	0f a8       	ld.ub	r8,r7[0x2]
8000276e:	1a d8       	st.w	--sp,r8
80002770:	48 9c       	lddpc	r12,80002794 <dcm_brdcst_func+0x40>
80002772:	f0 1f 00 07 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002776:	0f 98       	ld.ub	r8,r7[0x1]
80002778:	1a d8       	st.w	--sp,r8
8000277a:	48 8c       	lddpc	r12,80002798 <dcm_brdcst_func+0x44>
8000277c:	f0 1f 00 04 	mcall	8000278c <dcm_brdcst_func+0x38>
80002780:	2f dd       	sub	sp,-12
	
	
}
80002782:	e3 cd 80 80 	ldm	sp++,r7,pc
80002786:	00 00       	add	r0,r0
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	d0 38       	*unknown*
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	6a 5c       	ld.w	r12,r5[0x14]
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d0 4c       	*unknown*
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d0 60       	acall	0x6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d0 78       	*unknown*

8000279c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	eb cd 40 80 	pushm	r7,lr
800027a0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a2:	19 a9       	ld.ub	r9,r12[0x2]
800027a4:	30 08       	mov	r8,0
800027a6:	f0 09 18 00 	cp.b	r9,r8
800027aa:	c1 b1       	brne	800027e0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027ac:	19 b8       	ld.ub	r8,r12[0x3]
800027ae:	30 19       	mov	r9,1
800027b0:	f2 08 18 00 	cp.b	r8,r9
800027b4:	c0 51       	brne	800027be <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027b6:	48 ec       	lddpc	r12,800027ec <dcm_reply_func+0x50>
800027b8:	f0 1f 00 0e 	mcall	800027f0 <dcm_reply_func+0x54>
800027bc:	c0 a8       	rjmp	800027d0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027be:	58 08       	cp.w	r8,0
800027c0:	c0 51       	brne	800027ca <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027c2:	48 dc       	lddpc	r12,800027f4 <dcm_reply_func+0x58>
800027c4:	f0 1f 00 0b 	mcall	800027f0 <dcm_reply_func+0x54>
800027c8:	c0 48       	rjmp	800027d0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ca:	48 cc       	lddpc	r12,800027f8 <dcm_reply_func+0x5c>
800027cc:	f0 1f 00 09 	mcall	800027f0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027d0:	0f d8       	ld.ub	r8,r7[0x5]
800027d2:	1a d8       	st.w	--sp,r8
800027d4:	48 ac       	lddpc	r12,800027fc <dcm_reply_func+0x60>
800027d6:	f0 1f 00 07 	mcall	800027f0 <dcm_reply_func+0x54>
800027da:	2f fd       	sub	sp,-4
800027dc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027e0:	48 8c       	lddpc	r12,80002800 <dcm_reply_func+0x64>
800027e2:	f0 1f 00 04 	mcall	800027f0 <dcm_reply_func+0x54>
800027e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ea:	00 00       	add	r0,r0
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	d0 94       	*unknown*
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	6a 5c       	ld.w	r12,r5[0x14]
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	d0 a8       	*unknown*
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	d0 bc       	*unknown*
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	d0 d0       	acall	0xd
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	d0 dc       	*unknown*

80002804 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002804:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002806:	19 a9       	ld.ub	r9,r12[0x2]
80002808:	30 08       	mov	r8,0
8000280a:	f0 09 18 00 	cp.b	r9,r8
8000280e:	c0 51       	brne	80002818 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002810:	48 4c       	lddpc	r12,80002820 <ToneControl_reply_func+0x1c>
80002812:	f0 1f 00 05 	mcall	80002824 <ToneControl_reply_func+0x20>
80002816:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002818:	48 4c       	lddpc	r12,80002828 <ToneControl_reply_func+0x24>
8000281a:	f0 1f 00 03 	mcall	80002824 <ToneControl_reply_func+0x20>
8000281e:	d8 02       	popm	pc
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	d0 e8       	*unknown*
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	6a 5c       	ld.w	r12,r5[0x14]
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	d0 f4       	*unknown*

8000282c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000282c:	eb cd 40 80 	pushm	r7,lr
80002830:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002832:	48 c9       	lddpc	r9,80002860 <app_payload_rx_proc+0x34>
80002834:	13 88       	ld.ub	r8,r9[0x0]
80002836:	2f f8       	sub	r8,-1
80002838:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000283a:	30 39       	mov	r9,3
8000283c:	f2 08 18 00 	cp.b	r8,r9
80002840:	c0 71       	brne	8000284e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002842:	30 09       	mov	r9,0
80002844:	48 78       	lddpc	r8,80002860 <app_payload_rx_proc+0x34>
80002846:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002848:	48 7c       	lddpc	r12,80002864 <app_payload_rx_proc+0x38>
8000284a:	f0 1f 00 08 	mcall	80002868 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000284e:	48 88       	lddpc	r8,8000286c <app_payload_rx_proc+0x40>
80002850:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002852:	48 88       	lddpc	r8,80002870 <app_payload_rx_proc+0x44>
80002854:	70 0c       	ld.w	r12,r8[0x0]
80002856:	0e 9b       	mov	r11,r7
80002858:	f0 1f 00 07 	mcall	80002874 <app_payload_rx_proc+0x48>

}
8000285c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002860:	00 00       	add	r0,r0
80002862:	0a 54       	eor	r4,r5
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	d1 00       	acall	0x10
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	6a 5c       	ld.w	r12,r5[0x14]
8000286c:	00 00       	add	r0,r0
8000286e:	0a 4c       	or	r12,r5
80002870:	00 00       	add	r0,r0
80002872:	0a a8       	st.w	r5++,r8
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	2f c8       	sub	r8,-4

80002878 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002878:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000287a:	19 e8       	ld.ub	r8,r12[0x6]
8000287c:	30 19       	mov	r9,1
8000287e:	f2 08 18 00 	cp.b	r8,r9
80002882:	c0 61       	brne	8000288e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002884:	48 98       	lddpc	r8,800028a8 <DeviceInitializationStatus_brdcst_func+0x30>
80002886:	70 09       	ld.w	r9,r8[0x0]
80002888:	a1 a9       	sbr	r9,0x0
8000288a:	91 09       	st.w	r8[0x0],r9
8000288c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000288e:	30 29       	mov	r9,2
80002890:	f2 08 18 00 	cp.b	r8,r9
80002894:	c0 80       	breq	800028a4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002896:	48 58       	lddpc	r8,800028a8 <DeviceInitializationStatus_brdcst_func+0x30>
80002898:	70 09       	ld.w	r9,r8[0x0]
8000289a:	e0 19 ff fc 	andl	r9,0xfffc
8000289e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028a0:	f0 1f 00 03 	mcall	800028ac <DeviceInitializationStatus_brdcst_func+0x34>
800028a4:	d8 02       	popm	pc
800028a6:	00 00       	add	r0,r0
800028a8:	00 00       	add	r0,r0
800028aa:	0d 8c       	ld.ub	r12,r6[0x0]
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	46 fc       	lddsp	r12,sp[0x1bc]

800028b0 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028b0:	eb cd 40 fc 	pushm	r2-r7,lr
800028b4:	20 1d       	sub	sp,4
800028b6:	18 97       	mov	r7,r12
800028b8:	14 95       	mov	r5,r10
800028ba:	12 96       	mov	r6,r9
	U16 status = 1;
800028bc:	30 18       	mov	r8,1
800028be:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028c0:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028c4:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028c8:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
800028cc:	30 0b       	mov	r11,0
800028ce:	4e 38       	lddpc	r8,80002a58 <send_flash_command+0x1a8>
800028d0:	70 0c       	ld.w	r12,r8[0x0]
800028d2:	f0 1f 00 63 	mcall	80002a5c <send_flash_command+0x1ac>

    switch (command)
800028d6:	30 58       	mov	r8,5
800028d8:	f0 07 19 00 	cp.h	r7,r8
800028dc:	c3 40       	breq	80002944 <send_flash_command+0x94>
800028de:	e0 8b 00 18 	brhi	8000290e <send_flash_command+0x5e>
800028e2:	30 28       	mov	r8,2
800028e4:	f0 07 19 00 	cp.h	r7,r8
800028e8:	c5 e0       	breq	800029a4 <send_flash_command+0xf4>
800028ea:	e0 8b 00 08 	brhi	800028fa <send_flash_command+0x4a>
800028ee:	30 18       	mov	r8,1
800028f0:	f0 07 19 00 	cp.h	r7,r8
800028f4:	e0 81 00 a9 	brne	80002a46 <send_flash_command+0x196>
800028f8:	c9 e8       	rjmp	80002a34 <send_flash_command+0x184>
800028fa:	30 38       	mov	r8,3
800028fc:	f0 07 19 00 	cp.h	r7,r8
80002900:	c7 20       	breq	800029e4 <send_flash_command+0x134>
80002902:	30 48       	mov	r8,4
80002904:	f0 07 19 00 	cp.h	r7,r8
80002908:	e0 81 00 9f 	brne	80002a46 <send_flash_command+0x196>
8000290c:	c2 c8       	rjmp	80002964 <send_flash_command+0xb4>
8000290e:	35 28       	mov	r8,82
80002910:	f0 07 19 00 	cp.h	r7,r8
80002914:	c2 f0       	breq	80002972 <send_flash_command+0xc2>
80002916:	e0 8b 00 0c 	brhi	8000292e <send_flash_command+0x7e>
8000291a:	30 68       	mov	r8,6
8000291c:	f0 07 19 00 	cp.h	r7,r8
80002920:	c2 20       	breq	80002964 <send_flash_command+0xb4>
80002922:	32 08       	mov	r8,32
80002924:	f0 07 19 00 	cp.h	r7,r8
80002928:	e0 81 00 8f 	brne	80002a46 <send_flash_command+0x196>
8000292c:	c2 38       	rjmp	80002972 <send_flash_command+0xc2>
8000292e:	36 08       	mov	r8,96
80002930:	f0 07 19 00 	cp.h	r7,r8
80002934:	c3 20       	breq	80002998 <send_flash_command+0xe8>
80002936:	e0 68 00 d8 	mov	r8,216
8000293a:	f0 07 19 00 	cp.h	r7,r8
8000293e:	e0 81 00 84 	brne	80002a46 <send_flash_command+0x196>
80002942:	c1 88       	rjmp	80002972 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002944:	4c 57       	lddpc	r7,80002a58 <send_flash_command+0x1a8>
80002946:	30 5b       	mov	r11,5
80002948:	6e 0c       	ld.w	r12,r7[0x0]
8000294a:	f0 1f 00 46 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_dummy();
8000294e:	e0 6b 00 ff 	mov	r11,255
80002952:	6e 0c       	ld.w	r12,r7[0x0]
80002954:	f0 1f 00 43 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002958:	fa cb ff fe 	sub	r11,sp,-2
8000295c:	6e 0c       	ld.w	r12,r7[0x0]
8000295e:	f0 1f 00 42 	mcall	80002a64 <send_flash_command+0x1b4>
			break;
80002962:	c7 28       	rjmp	80002a46 <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002964:	0e 9b       	mov	r11,r7
80002966:	5c 7b       	castu.h	r11
80002968:	4b c8       	lddpc	r8,80002a58 <send_flash_command+0x1a8>
8000296a:	70 0c       	ld.w	r12,r8[0x0]
8000296c:	f0 1f 00 3d 	mcall	80002a60 <send_flash_command+0x1b0>
			break;
80002970:	c6 b8       	rjmp	80002a46 <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002972:	4b a6       	lddpc	r6,80002a58 <send_flash_command+0x1a8>
80002974:	0e 9b       	mov	r11,r7
80002976:	5c 7b       	castu.h	r11
80002978:	6c 0c       	ld.w	r12,r6[0x0]
8000297a:	f0 1f 00 3a 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
8000297e:	08 9b       	mov	r11,r4
80002980:	6c 0c       	ld.w	r12,r6[0x0]
80002982:	f0 1f 00 38 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002986:	06 9b       	mov	r11,r3
80002988:	6c 0c       	ld.w	r12,r6[0x0]
8000298a:	f0 1f 00 36 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
8000298e:	04 9b       	mov	r11,r2
80002990:	6c 0c       	ld.w	r12,r6[0x0]
80002992:	f0 1f 00 34 	mcall	80002a60 <send_flash_command+0x1b0>
			break;
80002996:	c5 88       	rjmp	80002a46 <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
80002998:	36 0b       	mov	r11,96
8000299a:	4b 08       	lddpc	r8,80002a58 <send_flash_command+0x1a8>
8000299c:	70 0c       	ld.w	r12,r8[0x0]
8000299e:	f0 1f 00 31 	mcall	80002a60 <send_flash_command+0x1b0>
			break;
800029a2:	c5 28       	rjmp	80002a46 <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029a4:	4a d7       	lddpc	r7,80002a58 <send_flash_command+0x1a8>
800029a6:	30 2b       	mov	r11,2
800029a8:	6e 0c       	ld.w	r12,r7[0x0]
800029aa:	f0 1f 00 2e 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029ae:	08 9b       	mov	r11,r4
800029b0:	6e 0c       	ld.w	r12,r7[0x0]
800029b2:	f0 1f 00 2c 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029b6:	06 9b       	mov	r11,r3
800029b8:	6e 0c       	ld.w	r12,r7[0x0]
800029ba:	f0 1f 00 2a 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029be:	04 9b       	mov	r11,r2
800029c0:	6e 0c       	ld.w	r12,r7[0x0]
800029c2:	f0 1f 00 28 	mcall	80002a60 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029c6:	58 06       	cp.w	r6,0
800029c8:	c3 f0       	breq	80002a46 <send_flash_command+0x196>
800029ca:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
800029cc:	4a 34       	lddpc	r4,80002a58 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
800029ce:	0f 3b       	ld.ub	r11,r7++
800029d0:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
800029d2:	68 0c       	ld.w	r12,r4[0x0]
800029d4:	f0 1f 00 23 	mcall	80002a60 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800029d8:	0e 98       	mov	r8,r7
800029da:	0a 18       	sub	r8,r5
800029dc:	ec 08 19 00 	cp.h	r8,r6
800029e0:	cf 73       	brcs	800029ce <send_flash_command+0x11e>
800029e2:	c3 28       	rjmp	80002a46 <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
800029e4:	49 d7       	lddpc	r7,80002a58 <send_flash_command+0x1a8>
800029e6:	30 3b       	mov	r11,3
800029e8:	6e 0c       	ld.w	r12,r7[0x0]
800029ea:	f0 1f 00 1e 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029ee:	08 9b       	mov	r11,r4
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 1c 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029f6:	06 9b       	mov	r11,r3
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 1a 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029fe:	04 9b       	mov	r11,r2
80002a00:	6e 0c       	ld.w	r12,r7[0x0]
80002a02:	f0 1f 00 18 	mcall	80002a60 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a06:	58 06       	cp.w	r6,0
80002a08:	c1 f0       	breq	80002a46 <send_flash_command+0x196>
80002a0a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a0c:	49 34       	lddpc	r4,80002a58 <send_flash_command+0x1a8>
80002a0e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a12:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a14:	06 9b       	mov	r11,r3
80002a16:	68 0c       	ld.w	r12,r4[0x0]
80002a18:	f0 1f 00 12 	mcall	80002a60 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a1c:	1a 9b       	mov	r11,sp
80002a1e:	68 0c       	ld.w	r12,r4[0x0]
80002a20:	f0 1f 00 11 	mcall	80002a64 <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a24:	9a 08       	ld.sh	r8,sp[0x0]
80002a26:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a28:	0e 98       	mov	r8,r7
80002a2a:	0a 18       	sub	r8,r5
80002a2c:	ec 08 19 00 	cp.h	r8,r6
80002a30:	cf 23       	brcs	80002a14 <send_flash_command+0x164>
80002a32:	c0 a8       	rjmp	80002a46 <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a34:	48 97       	lddpc	r7,80002a58 <send_flash_command+0x1a8>
80002a36:	30 1b       	mov	r11,1
80002a38:	6e 0c       	ld.w	r12,r7[0x0]
80002a3a:	f0 1f 00 0a 	mcall	80002a60 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a3e:	30 0b       	mov	r11,0
80002a40:	6e 0c       	ld.w	r12,r7[0x0]
80002a42:	f0 1f 00 08 	mcall	80002a60 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a46:	30 0b       	mov	r11,0
80002a48:	48 48       	lddpc	r8,80002a58 <send_flash_command+0x1a8>
80002a4a:	70 0c       	ld.w	r12,r8[0x0]
80002a4c:	f0 1f 00 07 	mcall	80002a68 <send_flash_command+0x1b8>

	return status;
}
80002a50:	9a 1c       	ld.sh	r12,sp[0x2]
80002a52:	2f fd       	sub	sp,-4
80002a54:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a58:	00 00       	add	r0,r0
80002a5a:	1d 90       	ld.ub	r0,lr[0x1]
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	54 2c       	stdsp	sp[0x108],r12
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	55 5e       	stdsp	sp[0x154],lr
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	55 7a       	stdsp	sp[0x15c],r10
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	54 78       	stdsp	sp[0x11c],r8

80002a6c <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002a6c:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002a6e:	58 0a       	cp.w	r10,0
80002a70:	5f 09       	sreq	r9
80002a72:	e0 68 ff fe 	mov	r8,65534
80002a76:	ea 18 00 7f 	orh	r8,0x7f
80002a7a:	10 3c       	cp.w	r12,r8
80002a7c:	5f b8       	srhi	r8
80002a7e:	f3 e8 10 08 	or	r8,r9,r8
80002a82:	c0 e1       	brne	80002a9e <data_flash_read_block+0x32>
80002a84:	e0 68 10 00 	mov	r8,4096
80002a88:	f0 0b 19 00 	cp.h	r11,r8
80002a8c:	e0 8b 00 09 	brhi	80002a9e <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002a90:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002a94:	18 9b       	mov	r11,r12
80002a96:	30 3c       	mov	r12,3
80002a98:	f0 1f 00 02 	mcall	80002aa0 <data_flash_read_block+0x34>
80002a9c:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002a9e:	da 0a       	popm	pc,r12=1
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	28 b0       	sub	r0,-117

80002aa4 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002aa4:	eb cd 40 e0 	pushm	r5-r7,lr
80002aa8:	18 96       	mov	r6,r12
80002aaa:	16 97       	mov	r7,r11
80002aac:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002aae:	58 0c       	cp.w	r12,0
80002ab0:	5f 09       	sreq	r9
80002ab2:	e0 68 ff fe 	mov	r8,65534
80002ab6:	ea 18 00 7f 	orh	r8,0x7f
80002aba:	10 3b       	cp.w	r11,r8
80002abc:	5f b8       	srhi	r8
80002abe:	f3 e8 10 08 	or	r8,r9,r8
80002ac2:	c3 91       	brne	80002b34 <data_flash_write_page+0x90>
80002ac4:	e0 68 01 00 	mov	r8,256
80002ac8:	f0 0a 19 00 	cp.h	r10,r8
80002acc:	e0 8b 00 34 	brhi	80002b34 <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002ad0:	30 09       	mov	r9,0
80002ad2:	12 9a       	mov	r10,r9
80002ad4:	12 9b       	mov	r11,r9
80002ad6:	30 5c       	mov	r12,5
80002ad8:	f0 1f 00 19 	mcall	80002b3c <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002adc:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002ae0:	c0 30       	breq	80002ae6 <data_flash_write_page+0x42>
80002ae2:	30 27       	mov	r7,2
80002ae4:	c2 98       	rjmp	80002b36 <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002ae6:	30 09       	mov	r9,0
80002ae8:	12 9a       	mov	r10,r9
80002aea:	12 9b       	mov	r11,r9
80002aec:	30 6c       	mov	r12,6
80002aee:	f0 1f 00 14 	mcall	80002b3c <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002af2:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002af6:	0c 9a       	mov	r10,r6
80002af8:	0e 9b       	mov	r11,r7
80002afa:	30 2c       	mov	r12,2
80002afc:	f0 1f 00 10 	mcall	80002b3c <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b00:	30 05       	mov	r5,0
80002b02:	30 56       	mov	r6,5
80002b04:	0a 99       	mov	r9,r5
80002b06:	0a 9a       	mov	r10,r5
80002b08:	0a 9b       	mov	r11,r5
80002b0a:	0c 9c       	mov	r12,r6
80002b0c:	f0 1f 00 0c 	mcall	80002b3c <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b10:	5c 7c       	castu.h	r12
80002b12:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b16:	cf 71       	brne	80002b04 <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b18:	18 97       	mov	r7,r12
80002b1a:	e2 17 00 20 	andl	r7,0x20,COH
80002b1e:	f9 b7 01 06 	movne	r7,6
80002b22:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b26:	30 09       	mov	r9,0
80002b28:	12 9a       	mov	r10,r9
80002b2a:	12 9b       	mov	r11,r9
80002b2c:	30 4c       	mov	r12,4
80002b2e:	f0 1f 00 04 	mcall	80002b3c <data_flash_write_page+0x98>

	return return_code;
80002b32:	c0 28       	rjmp	80002b36 <data_flash_write_page+0x92>
80002b34:	30 17       	mov	r7,1
}
80002b36:	0e 9c       	mov	r12,r7
80002b38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	28 b0       	sub	r0,-117

80002b40 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b40:	d4 31       	pushm	r0-r7,lr
80002b42:	18 94       	mov	r4,r12
80002b44:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b48:	16 97       	mov	r7,r11
80002b4a:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b4c:	30 03       	mov	r3,0
80002b4e:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b50:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b54:	c4 98       	rjmp	80002be6 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b56:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b5a:	c1 b1       	brne	80002b90 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b5c:	e0 06 19 00 	cp.h	r6,r0
80002b60:	e0 8b 00 0a 	brhi	80002b74 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b64:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b68:	0e 9b       	mov	r11,r7
80002b6a:	08 9c       	mov	r12,r4
80002b6c:	f0 1f 00 24 	mcall	80002bfc <data_flash_write_block+0xbc>
80002b70:	30 06       	mov	r6,0
80002b72:	c3 a8       	rjmp	80002be6 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002b74:	e0 6a 01 00 	mov	r10,256
80002b78:	0e 9b       	mov	r11,r7
80002b7a:	08 9c       	mov	r12,r4
80002b7c:	f0 1f 00 20 	mcall	80002bfc <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002b80:	ec c6 01 00 	sub	r6,r6,256
80002b84:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002b86:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002b8a:	ee c7 ff 00 	sub	r7,r7,-256
80002b8e:	c2 c8       	rjmp	80002be6 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002b90:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002b94:	0e 09       	add	r9,r7
80002b96:	0e 98       	mov	r8,r7
80002b98:	e4 18 00 7f 	andh	r8,0x7f
80002b9c:	e0 18 ff 00 	andl	r8,0xff00
80002ba0:	f0 c8 ff 00 	sub	r8,r8,-256
80002ba4:	10 39       	cp.w	r9,r8
80002ba6:	e0 88 00 19 	brls	80002bd8 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002baa:	0e 91       	mov	r1,r7
80002bac:	5c 51       	castu.b	r1
80002bae:	e0 6a 01 00 	mov	r10,256
80002bb2:	02 1a       	sub	r10,r1
80002bb4:	5c 7a       	castu.h	r10
80002bb6:	0e 9b       	mov	r11,r7
80002bb8:	08 9c       	mov	r12,r4
80002bba:	f0 1f 00 11 	mcall	80002bfc <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bbe:	ec c6 01 00 	sub	r6,r6,256
80002bc2:	02 06       	add	r6,r1
80002bc4:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bc6:	e0 68 01 00 	mov	r8,256
80002bca:	f0 05 01 05 	sub	r5,r8,r5
80002bce:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002bd0:	e0 17 ff 00 	andl	r7,0xff00
80002bd4:	10 07       	add	r7,r8
80002bd6:	c0 88       	rjmp	80002be6 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002bd8:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002bdc:	0e 9b       	mov	r11,r7
80002bde:	08 9c       	mov	r12,r4
80002be0:	f0 1f 00 07 	mcall	80002bfc <data_flash_write_block+0xbc>
80002be4:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002be6:	e6 06 19 00 	cp.h	r6,r3
80002bea:	5f 19       	srne	r9
80002bec:	58 7c       	cp.w	r12,7
80002bee:	5f 08       	sreq	r8
80002bf0:	f3 e8 00 08 	and	r8,r9,r8
80002bf4:	e4 08 18 00 	cp.b	r8,r2
80002bf8:	ca f1       	brne	80002b56 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002bfa:	d8 32       	popm	r0-r7,pc
80002bfc:	80 00       	ld.sh	r0,r0[0x0]
80002bfe:	2a a4       	sub	r4,-86

80002c00 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c00:	eb cd 40 c0 	pushm	r6-r7,lr
80002c04:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c06:	e0 68 ff fe 	mov	r8,65534
80002c0a:	ea 18 00 7f 	orh	r8,0x7f
80002c0e:	10 3c       	cp.w	r12,r8
80002c10:	e0 88 00 04 	brls	80002c18 <data_flash_erase_block+0x18>
80002c14:	30 17       	mov	r7,1
80002c16:	c3 e8       	rjmp	80002c92 <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c18:	58 1b       	cp.w	r11,1
80002c1a:	c0 31       	brne	80002c20 <data_flash_erase_block+0x20>
80002c1c:	32 06       	mov	r6,32
80002c1e:	c0 a8       	rjmp	80002c32 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c20:	58 2b       	cp.w	r11,2
80002c22:	c0 31       	brne	80002c28 <data_flash_erase_block+0x28>
80002c24:	35 26       	mov	r6,82
80002c26:	c0 68       	rjmp	80002c32 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c28:	e0 66 00 d8 	mov	r6,216
80002c2c:	58 3b       	cp.w	r11,3
80002c2e:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c32:	30 09       	mov	r9,0
80002c34:	12 9a       	mov	r10,r9
80002c36:	12 9b       	mov	r11,r9
80002c38:	30 5c       	mov	r12,5
80002c3a:	f0 1f 00 18 	mcall	80002c98 <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c3e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c42:	c0 30       	breq	80002c48 <data_flash_erase_block+0x48>
80002c44:	30 27       	mov	r7,2
80002c46:	c2 68       	rjmp	80002c92 <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c48:	30 09       	mov	r9,0
80002c4a:	12 9a       	mov	r10,r9
80002c4c:	12 9b       	mov	r11,r9
80002c4e:	30 6c       	mov	r12,6
80002c50:	f0 1f 00 12 	mcall	80002c98 <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c54:	30 09       	mov	r9,0
80002c56:	12 9a       	mov	r10,r9
80002c58:	0e 9b       	mov	r11,r7
80002c5a:	0c 9c       	mov	r12,r6
80002c5c:	f0 1f 00 0f 	mcall	80002c98 <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c60:	30 06       	mov	r6,0
80002c62:	30 57       	mov	r7,5
80002c64:	0c 99       	mov	r9,r6
80002c66:	0c 9a       	mov	r10,r6
80002c68:	0c 9b       	mov	r11,r6
80002c6a:	0e 9c       	mov	r12,r7
80002c6c:	f0 1f 00 0b 	mcall	80002c98 <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c70:	5c 7c       	castu.h	r12
80002c72:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c76:	cf 71       	brne	80002c64 <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c78:	18 97       	mov	r7,r12
80002c7a:	e2 17 00 20 	andl	r7,0x20,COH
80002c7e:	f9 b7 01 04 	movne	r7,4
80002c82:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c86:	30 09       	mov	r9,0
80002c88:	12 9a       	mov	r10,r9
80002c8a:	12 9b       	mov	r11,r9
80002c8c:	30 4c       	mov	r12,4
80002c8e:	f0 1f 00 03 	mcall	80002c98 <data_flash_erase_block+0x98>

	return return_code;
}
80002c92:	0e 9c       	mov	r12,r7
80002c94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	28 b0       	sub	r0,-117

80002c9c <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002c9c:	d4 31       	pushm	r0-r7,lr
80002c9e:	20 3d       	sub	sp,12
80002ca0:	50 0c       	stdsp	sp[0x0],r12
80002ca2:	16 91       	mov	r1,r11
80002ca4:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002ca6:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002caa:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002cac:	e0 69 10 00 	mov	r9,4096
80002cb0:	f2 0a 01 07 	sub	r7,r9,r10
80002cb4:	ea 07 19 00 	cp.h	r7,r5
80002cb8:	ea 07 17 b0 	movhi	r7,r5
80002cbc:	5c 87       	casts.h	r7
80002cbe:	16 92       	mov	r2,r11
80002cc0:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cc4:	4a e4       	lddpc	r4,80002d7c <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cc6:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002cc8:	e8 c8 ff ff 	sub	r8,r4,-1
80002ccc:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002cce:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cd0:	08 9a       	mov	r10,r4
80002cd2:	e0 6b 10 00 	mov	r11,4096
80002cd6:	04 9c       	mov	r12,r2
80002cd8:	f0 1f 00 2a 	mcall	80002d80 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002cdc:	58 07       	cp.w	r7,0
80002cde:	c3 00       	breq	80002d3e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002ce0:	40 13       	lddsp	r3,sp[0x4]
80002ce2:	5c 73       	castu.h	r3
80002ce4:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002ce8:	ec 08 18 00 	cp.b	r8,r6
80002cec:	c1 11       	brne	80002d0e <data_flash_write+0x72>
80002cee:	e6 c9 ff ff 	sub	r9,r3,-1
80002cf2:	08 09       	add	r9,r4
80002cf4:	30 08       	mov	r8,0
80002cf6:	c0 58       	rjmp	80002d00 <data_flash_write+0x64>
80002cf8:	13 3a       	ld.ub	r10,r9++
80002cfa:	ec 0a 18 00 	cp.b	r10,r6
80002cfe:	c0 81       	brne	80002d0e <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d00:	2f f8       	sub	r8,-1
80002d02:	5c 88       	casts.h	r8
80002d04:	f0 07 19 00 	cp.h	r7,r8
80002d08:	fe 9b ff f8 	brhi	80002cf8 <data_flash_write+0x5c>
80002d0c:	c1 98       	rjmp	80002d3e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d0e:	30 1b       	mov	r11,1
80002d10:	04 9c       	mov	r12,r2
80002d12:	f0 1f 00 1d 	mcall	80002d84 <data_flash_write+0xe8>
80002d16:	40 08       	lddsp	r8,sp[0x0]
80002d18:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d1a:	40 2a       	lddsp	r10,sp[0x8]
80002d1c:	40 19       	lddsp	r9,sp[0x4]
80002d1e:	12 0a       	add	r10,r9
80002d20:	0e 99       	mov	r9,r7
80002d22:	20 19       	sub	r9,1
80002d24:	5c 79       	castu.h	r9
80002d26:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d28:	11 39       	ld.ub	r9,r8++
80002d2a:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d2c:	14 33       	cp.w	r3,r10
80002d2e:	cf d1       	brne	80002d28 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d30:	e0 6a 10 00 	mov	r10,4096
80002d34:	04 9b       	mov	r11,r2
80002d36:	08 9c       	mov	r12,r4
80002d38:	f0 1f 00 14 	mcall	80002d88 <data_flash_write+0xec>
80002d3c:	c0 78       	rjmp	80002d4a <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d3e:	0e 9a       	mov	r10,r7
80002d40:	5c 7a       	castu.h	r10
80002d42:	02 9b       	mov	r11,r1
80002d44:	40 0c       	lddsp	r12,sp[0x0]
80002d46:	f0 1f 00 11 	mcall	80002d88 <data_flash_write+0xec>
80002d4a:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d4e:	0e 98       	mov	r8,r7
80002d50:	ee 05 19 00 	cp.h	r5,r7
80002d54:	c1 20       	breq	80002d78 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d56:	5c 78       	castu.h	r8
80002d58:	40 0a       	lddsp	r10,sp[0x0]
80002d5a:	10 0a       	add	r10,r8
80002d5c:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d5e:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d60:	0e 15       	sub	r5,r7
80002d62:	5c 85       	casts.h	r5
80002d64:	e0 05 19 00 	cp.h	r5,r0
80002d68:	ea 07 17 80 	movls	r7,r5
80002d6c:	e0 07 17 b0 	movhi	r7,r0
80002d70:	5c 87       	casts.h	r7
80002d72:	30 09       	mov	r9,0
80002d74:	50 19       	stdsp	sp[0x4],r9
80002d76:	ca db       	rjmp	80002cd0 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002d78:	2f dd       	sub	sp,-12
80002d7a:	d8 32       	popm	r0-r7,pc
80002d7c:	00 00       	add	r0,r0
80002d7e:	0d 90       	ld.ub	r0,r6[0x1]
80002d80:	80 00       	ld.sh	r0,r0[0x0]
80002d82:	2a 6c       	sub	r12,-90
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	2c 00       	sub	r0,-64
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	2b 40       	sub	r0,-76

80002d8c <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002d8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002d90:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002d92:	4b f8       	lddpc	r8,80002e8c <data_flash_init+0x100>
80002d94:	fa c6 ff fc 	sub	r6,sp,-4
80002d98:	f0 ea 00 00 	ld.d	r10,r8[0]
80002d9c:	ec eb 00 00 	st.d	r6[0],r10
80002da0:	f0 e8 00 08 	ld.d	r8,r8[8]
80002da4:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002da8:	30 4b       	mov	r11,4
80002daa:	4b ac       	lddpc	r12,80002e90 <data_flash_init+0x104>
80002dac:	f0 1f 00 3a 	mcall	80002e94 <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002db0:	31 9c       	mov	r12,25
80002db2:	f0 1f 00 3a 	mcall	80002e98 <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002db6:	31 9c       	mov	r12,25
80002db8:	f0 1f 00 39 	mcall	80002e9c <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002dbc:	4b 97       	lddpc	r7,80002ea0 <data_flash_init+0x114>
80002dbe:	fe 7c 24 00 	mov	r12,-56320
80002dc2:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002dc4:	0c 9b       	mov	r11,r6
80002dc6:	f0 1f 00 38 	mcall	80002ea4 <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002dca:	30 09       	mov	r9,0
80002dcc:	12 9a       	mov	r10,r9
80002dce:	12 9b       	mov	r11,r9
80002dd0:	6e 0c       	ld.w	r12,r7[0x0]
80002dd2:	f0 1f 00 36 	mcall	80002ea8 <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002dd6:	6e 0c       	ld.w	r12,r7[0x0]
80002dd8:	f0 1f 00 35 	mcall	80002eac <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002ddc:	e0 6a 36 00 	mov	r10,13824
80002de0:	ea 1a 01 6e 	orh	r10,0x16e
80002de4:	0c 9b       	mov	r11,r6
80002de6:	6e 0c       	ld.w	r12,r7[0x0]
80002de8:	f0 1f 00 32 	mcall	80002eb0 <data_flash_init+0x124>
80002dec:	c0 50       	breq	80002df6 <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002dee:	30 29       	mov	r9,2
80002df0:	4b 18       	lddpc	r8,80002eb4 <data_flash_init+0x128>
80002df2:	b0 89       	st.b	r8[0x0],r9
		return;
80002df4:	c4 88       	rjmp	80002e84 <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002df6:	1a 96       	mov	r6,sp
80002df8:	30 4a       	mov	r10,4
80002dfa:	4b 0b       	lddpc	r11,80002eb8 <data_flash_init+0x12c>
80002dfc:	1a 9c       	mov	r12,sp
80002dfe:	f0 1f 00 30 	mcall	80002ebc <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e02:	4a 87       	lddpc	r7,80002ea0 <data_flash_init+0x114>
80002e04:	30 0b       	mov	r11,0
80002e06:	6e 0c       	ld.w	r12,r7[0x0]
80002e08:	f0 1f 00 2e 	mcall	80002ec0 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e0c:	e0 6b 00 9f 	mov	r11,159
80002e10:	6e 0c       	ld.w	r12,r7[0x0]
80002e12:	f0 1f 00 2d 	mcall	80002ec4 <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e16:	e0 6b 00 ff 	mov	r11,255
80002e1a:	6e 0c       	ld.w	r12,r7[0x0]
80002e1c:	f0 1f 00 2a 	mcall	80002ec4 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e20:	1a 9b       	mov	r11,sp
80002e22:	6e 0c       	ld.w	r12,r7[0x0]
80002e24:	f0 1f 00 29 	mcall	80002ec8 <data_flash_init+0x13c>
	spi_write_dummy();
80002e28:	e0 6b 00 ff 	mov	r11,255
80002e2c:	6e 0c       	ld.w	r12,r7[0x0]
80002e2e:	f0 1f 00 26 	mcall	80002ec4 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e32:	fa cb ff fe 	sub	r11,sp,-2
80002e36:	6e 0c       	ld.w	r12,r7[0x0]
80002e38:	f0 1f 00 24 	mcall	80002ec8 <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e3c:	30 0b       	mov	r11,0
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 23 	mcall	80002ecc <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e44:	31 f8       	mov	r8,31
80002e46:	9a 09       	ld.sh	r9,sp[0x0]
80002e48:	f0 09 19 00 	cp.h	r9,r8
80002e4c:	c0 61       	brne	80002e58 <data_flash_init+0xcc>
80002e4e:	34 88       	mov	r8,72
80002e50:	9a 19       	ld.sh	r9,sp[0x2]
80002e52:	f0 09 19 00 	cp.h	r9,r8
80002e56:	c0 50       	breq	80002e60 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e58:	30 39       	mov	r9,3
80002e5a:	49 78       	lddpc	r8,80002eb4 <data_flash_init+0x128>
80002e5c:	b0 89       	st.b	r8[0x0],r9
		return;
80002e5e:	c1 38       	rjmp	80002e84 <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e60:	30 09       	mov	r9,0
80002e62:	12 9a       	mov	r10,r9
80002e64:	12 9b       	mov	r11,r9
80002e66:	30 6c       	mov	r12,6
80002e68:	f0 1f 00 1a 	mcall	80002ed0 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002e6c:	30 09       	mov	r9,0
80002e6e:	12 9a       	mov	r10,r9
80002e70:	12 9b       	mov	r11,r9
80002e72:	30 1c       	mov	r12,1
80002e74:	f0 1f 00 17 	mcall	80002ed0 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002e78:	30 09       	mov	r9,0
80002e7a:	12 9a       	mov	r10,r9
80002e7c:	12 9b       	mov	r11,r9
80002e7e:	30 5c       	mov	r12,5
80002e80:	f0 1f 00 14 	mcall	80002ed0 <data_flash_init+0x144>
	
	return;
}
80002e84:	2f bd       	sub	sp,-20
80002e86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e8a:	00 00       	add	r0,r0
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	d1 0c       	*unknown*
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	d1 20       	acall	0x12
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	52 34       	stdsp	sp[0x8c],r4
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	52 64       	stdsp	sp[0x98],r4
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	52 7c       	stdsp	sp[0x9c],r12
80002ea0:	00 00       	add	r0,r0
80002ea2:	1d 90       	ld.ub	r0,lr[0x1]
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	53 c8       	stdsp	sp[0xf0],r8
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	54 00       	stdsp	sp[0x100],r0
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	55 58       	stdsp	sp[0x154],r8
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	54 a0       	stdsp	sp[0x128],r0
80002eb4:	00 00       	add	r0,r0
80002eb6:	0a 5c       	eor	r12,r5
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	d1 1c       	*unknown*
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	73 16       	ld.w	r6,r9[0x44]
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	54 2c       	stdsp	sp[0x108],r12
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	55 5e       	stdsp	sp[0x154],lr
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	55 7a       	stdsp	sp[0x15c],r10
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	54 78       	stdsp	sp[0x11c],r8
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	28 b0       	sub	r0,-117

80002ed4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002ed4:	20 1c       	sub	r12,1
80002ed6:	5c 5c       	castu.b	r12
80002ed8:	31 18       	mov	r8,17
80002eda:	f0 0c 18 00 	cp.b	r12,r8
80002ede:	e0 88 00 03 	brls	80002ee4 <CalculateBurst+0x10>
80002ee2:	5e fd       	retal	0
80002ee4:	48 28       	lddpc	r8,80002eec <CalculateBurst+0x18>
80002ee6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002eea:	5e fc       	retal	r12
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	d1 48       	*unknown*

80002ef0 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002ef0:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002ef2:	48 98       	lddpc	r8,80002f14 <payload_init+0x24>
80002ef4:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002ef6:	48 98       	lddpc	r8,80002f18 <payload_init+0x28>
80002ef8:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002efa:	30 09       	mov	r9,0
80002efc:	1a d9       	st.w	--sp,r9
80002efe:	1a d9       	st.w	--sp,r9
80002f00:	1a d9       	st.w	--sp,r9
80002f02:	30 28       	mov	r8,2
80002f04:	e0 6a 04 00 	mov	r10,1024
80002f08:	48 5b       	lddpc	r11,80002f1c <payload_init+0x2c>
80002f0a:	48 6c       	lddpc	r12,80002f20 <payload_init+0x30>
80002f0c:	f0 1f 00 06 	mcall	80002f24 <payload_init+0x34>
80002f10:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f12:	d8 02       	popm	pc
80002f14:	00 00       	add	r0,r0
80002f16:	0a 60       	and	r0,r5
80002f18:	00 00       	add	r0,r0
80002f1a:	0a 64       	and	r4,r5
80002f1c:	80 00       	ld.sh	r0,r0[0x0]
80002f1e:	d1 90       	acall	0x19
80002f20:	80 00       	ld.sh	r0,r0[0x0]
80002f22:	2f 28       	sub	r8,-14
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	66 98       	ld.w	r8,r3[0x24]

80002f28 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f28:	eb cd 40 f8 	pushm	r3-r7,lr
80002f2c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f2e:	48 e8       	lddpc	r8,80002f64 <payload_rx_process+0x3c>
80002f30:	70 08       	ld.w	r8,r8[0x0]
80002f32:	58 08       	cp.w	r8,0
80002f34:	c0 71       	brne	80002f42 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f36:	30 4b       	mov	r11,4
80002f38:	30 5c       	mov	r12,5
80002f3a:	f0 1f 00 0c 	mcall	80002f68 <payload_rx_process+0x40>
80002f3e:	48 a8       	lddpc	r8,80002f64 <payload_rx_process+0x3c>
80002f40:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f42:	48 96       	lddpc	r6,80002f64 <payload_rx_process+0x3c>
80002f44:	30 05       	mov	r5,0
80002f46:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f48:	48 93       	lddpc	r3,80002f6c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f4a:	6c 0c       	ld.w	r12,r6[0x0]
80002f4c:	0a 99       	mov	r9,r5
80002f4e:	08 9a       	mov	r10,r4
80002f50:	1a 9b       	mov	r11,sp
80002f52:	f0 1f 00 08 	mcall	80002f70 <payload_rx_process+0x48>
80002f56:	58 1c       	cp.w	r12,1
80002f58:	cf 91       	brne	80002f4a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f5a:	66 08       	ld.w	r8,r3[0x0]
80002f5c:	40 0c       	lddsp	r12,sp[0x0]
80002f5e:	5d 18       	icall	r8
80002f60:	cf 5b       	rjmp	80002f4a <payload_rx_process+0x22>
80002f62:	00 00       	add	r0,r0
80002f64:	00 00       	add	r0,r0
80002f66:	0a 78       	tst	r8,r5
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	5f c4       	srvs	r4
80002f6c:	00 00       	add	r0,r0
80002f6e:	0a 60       	and	r0,r5
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	5c b8       	swap.b	r8

80002f74 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002f74:	d4 01       	pushm	lr
80002f76:	20 2d       	sub	sp,8
80002f78:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f7a:	30 09       	mov	r9,0
80002f7c:	fa ca ff f8 	sub	r10,sp,-8
80002f80:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002f82:	1a 9b       	mov	r11,sp
80002f84:	f0 1f 00 02 	mcall	80002f8c <set_idle_store_isr+0x18>
}
80002f88:	2f ed       	sub	sp,-8
80002f8a:	d8 02       	popm	pc
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	5e 74       	retpl	r4

80002f90 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002f90:	d4 01       	pushm	lr
80002f92:	20 2d       	sub	sp,8
80002f94:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002f96:	58 0c       	cp.w	r12,0
80002f98:	c1 10       	breq	80002fba <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f9a:	30 08       	mov	r8,0
80002f9c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002f9e:	98 88       	ld.uh	r8,r12[0x0]
80002fa0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fa4:	e0 48 40 00 	cp.w	r8,16384
80002fa8:	c0 91       	brne	80002fba <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002faa:	48 68       	lddpc	r8,80002fc0 <phy_rx+0x30>
80002fac:	70 0c       	ld.w	r12,r8[0x0]
80002fae:	30 09       	mov	r9,0
80002fb0:	fa ca ff fc 	sub	r10,sp,-4
80002fb4:	1a 9b       	mov	r11,sp
80002fb6:	f0 1f 00 04 	mcall	80002fc4 <phy_rx+0x34>
		}	

    }
		
 
}
80002fba:	2f ed       	sub	sp,-8
80002fbc:	d8 02       	popm	pc
80002fbe:	00 00       	add	r0,r0
80002fc0:	00 00       	add	r0,r0
80002fc2:	0a bc       	st.h	r5++,r12
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	5e 74       	retpl	r4

80002fc8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002fc8:	eb cd 40 80 	pushm	r7,lr
80002fcc:	20 1d       	sub	sp,4
80002fce:	fa c7 ff fc 	sub	r7,sp,-4
80002fd2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002fd4:	30 09       	mov	r9,0
80002fd6:	12 9a       	mov	r10,r9
80002fd8:	1a 9b       	mov	r11,sp
80002fda:	f0 1f 00 03 	mcall	80002fe4 <set_idle_store+0x1c>
}
80002fde:	2f fd       	sub	sp,-4
80002fe0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	5e c4       	retvs	r4

80002fe8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002fe8:	d4 01       	pushm	lr
80002fea:	20 1d       	sub	sp,4
80002fec:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002fee:	98 88       	ld.uh	r8,r12[0x0]
80002ff0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ff4:	e0 48 40 00 	cp.w	r8,16384
80002ff8:	c0 d1       	brne	80003012 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002ffa:	49 08       	lddpc	r8,80003038 <phy_tx+0x50>
80002ffc:	70 08       	ld.w	r8,r8[0x0]
80002ffe:	58 08       	cp.w	r8,0
80003000:	c1 a0       	breq	80003034 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003002:	48 e8       	lddpc	r8,80003038 <phy_tx+0x50>
80003004:	70 0c       	ld.w	r12,r8[0x0]
80003006:	30 09       	mov	r9,0
80003008:	12 9a       	mov	r10,r9
8000300a:	1a 9b       	mov	r11,sp
8000300c:	f0 1f 00 0c 	mcall	8000303c <phy_tx+0x54>
80003010:	c1 28       	rjmp	80003034 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003012:	e0 48 10 00 	cp.w	r8,4096
80003016:	5f 0a       	sreq	r10
80003018:	e0 48 20 00 	cp.w	r8,8192
8000301c:	5f 09       	sreq	r9
8000301e:	f5 e9 10 09 	or	r9,r10,r9
80003022:	c0 71       	brne	80003030 <phy_tx+0x48>
80003024:	e0 48 50 00 	cp.w	r8,20480
80003028:	c0 40       	breq	80003030 <phy_tx+0x48>
8000302a:	e0 48 60 00 	cp.w	r8,24576
8000302e:	c0 31       	brne	80003034 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003030:	48 48       	lddpc	r8,80003040 <phy_tx+0x58>
80003032:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003034:	2f fd       	sub	sp,-4
80003036:	d8 02       	popm	pc
80003038:	00 00       	add	r0,r0
8000303a:	0a d0       	st.w	--r5,r0
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	5e c4       	retvs	r4
80003040:	00 00       	add	r0,r0
80003042:	0a b0       	st.h	r5++,r0

80003044 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003044:	d4 01       	pushm	lr
80003046:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003048:	30 08       	mov	r8,0
8000304a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000304c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
8000304e:	1a 9a       	mov	r10,sp
80003050:	fa cb ff fc 	sub	r11,sp,-4
80003054:	f0 1f 00 05 	mcall	80003068 <get_idle_store_isr+0x24>
80003058:	58 1c       	cp.w	r12,1
8000305a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000305e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003062:	2f ed       	sub	sp,-8
80003064:	d8 02       	popm	pc
80003066:	00 00       	add	r0,r0
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	5b c8       	cp.w	r8,-4

8000306c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
8000306c:	eb cd 40 c0 	pushm	r6-r7,lr
80003070:	20 1d       	sub	sp,4
80003072:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003074:	fe f8 04 70 	ld.w	r8,pc[1136]
80003078:	70 08       	ld.w	r8,r8[0x0]
8000307a:	58 08       	cp.w	r8,0
8000307c:	c7 40       	breq	80003164 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
8000307e:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003080:	30 08       	mov	r8,0
80003082:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003084:	fe f8 04 64 	ld.w	r8,pc[1124]
80003088:	70 08       	ld.w	r8,r8[0x0]
8000308a:	58 18       	cp.w	r8,1
8000308c:	c2 90       	breq	800030de <phy_tx_func+0x72>
8000308e:	c0 43       	brcs	80003096 <phy_tx_func+0x2a>
80003090:	58 28       	cp.w	r8,2
80003092:	c6 91       	brne	80003164 <phy_tx_func+0xf8>
80003094:	c6 18       	rjmp	80003156 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003096:	fe f8 04 4e 	ld.w	r8,pc[1102]
8000309a:	70 0c       	ld.w	r12,r8[0x0]
8000309c:	1a 9a       	mov	r10,sp
8000309e:	fe fb 04 4e 	ld.w	r11,pc[1102]
800030a2:	f0 1f 01 14 	mcall	800034f0 <phy_tx_func+0x484>
800030a6:	58 1c       	cp.w	r12,1
800030a8:	c1 51       	brne	800030d2 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030aa:	fe f8 04 42 	ld.w	r8,pc[1090]
800030ae:	70 08       	ld.w	r8,r8[0x0]
800030b0:	11 9a       	ld.ub	r10,r8[0x1]
800030b2:	fe f9 04 42 	ld.w	r9,pc[1090]
800030b6:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030b8:	90 88       	ld.uh	r8,r8[0x0]
800030ba:	ea 18 ab cd 	orh	r8,0xabcd
800030be:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030c0:	30 19       	mov	r9,1
800030c2:	fe f8 04 36 	ld.w	r8,pc[1078]
800030c6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800030c8:	30 19       	mov	r9,1
800030ca:	fe f8 04 1e 	ld.w	r8,pc[1054]
800030ce:	91 09       	st.w	r8[0x0],r9
800030d0:	c4 a8       	rjmp	80003164 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800030d2:	e0 68 5a 5a 	mov	r8,23130
800030d6:	ea 18 ab cd 	orh	r8,0xabcd
800030da:	8f 18       	st.w	r7[0x4],r8
800030dc:	c4 48       	rjmp	80003164 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030de:	fe f9 04 1a 	ld.w	r9,pc[1050]
800030e2:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800030e4:	fe fa 04 08 	ld.w	r10,pc[1032]
800030e8:	74 0a       	ld.w	r10,r10[0x0]
800030ea:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
800030ee:	b1 6a       	lsl	r10,0x10
800030f0:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030f2:	2f f8       	sub	r8,-1
800030f4:	5c 58       	castu.b	r8
800030f6:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
800030f8:	fe fa 03 fc 	ld.w	r10,pc[1020]
800030fc:	94 09       	ld.sh	r9,r10[0x0]
800030fe:	20 29       	sub	r9,2
80003100:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003102:	30 0a       	mov	r10,0
80003104:	f4 09 19 00 	cp.h	r9,r10
80003108:	e0 89 00 0b 	brgt	8000311e <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000310c:	78 18       	ld.w	r8,r12[0x4]
8000310e:	e8 18 00 ba 	orl	r8,0xba
80003112:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003114:	30 09       	mov	r9,0
80003116:	fe f8 03 d2 	ld.w	r8,pc[978]
8000311a:	91 09       	st.w	r8[0x0],r9
8000311c:	c2 48       	rjmp	80003164 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
8000311e:	fe f9 03 ce 	ld.w	r9,pc[974]
80003122:	72 09       	ld.w	r9,r9[0x0]
80003124:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003128:	78 1a       	ld.w	r10,r12[0x4]
8000312a:	f5 e9 10 09 	or	r9,r10,r9
8000312e:	99 19       	st.w	r12[0x4],r9
80003130:	2f f8       	sub	r8,-1
80003132:	fe f9 03 c6 	ld.w	r9,pc[966]
80003136:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003138:	fe f9 03 bc 	ld.w	r9,pc[956]
8000313c:	92 08       	ld.sh	r8,r9[0x0]
8000313e:	20 28       	sub	r8,2
80003140:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003142:	30 09       	mov	r9,0
80003144:	f2 08 19 00 	cp.h	r8,r9
80003148:	e0 89 00 0e 	brgt	80003164 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
8000314c:	30 29       	mov	r9,2
8000314e:	fe f8 03 9a 	ld.w	r8,pc[922]
80003152:	91 09       	st.w	r8[0x0],r9
80003154:	c0 88       	rjmp	80003164 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003156:	fc 18 00 ba 	movh	r8,0xba
8000315a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
8000315c:	30 09       	mov	r9,0
8000315e:	fe f8 03 8a 	ld.w	r8,pc[906]
80003162:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80003164:	fe f8 03 98 	ld.w	r8,pc[920]
80003168:	11 89       	ld.ub	r9,r8[0x0]
8000316a:	30 18       	mov	r8,1
8000316c:	f0 09 18 00 	cp.b	r9,r8
80003170:	e0 81 01 af 	brne	800034ce <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003174:	fe f8 03 8c 	ld.w	r8,pc[908]
80003178:	70 08       	ld.w	r8,r8[0x0]
8000317a:	e0 48 05 b0 	cp.w	r8,1456
8000317e:	f9 b8 02 00 	movhs	r8,0
80003182:	fe f9 03 7e 	ld.w	r9,pc[894]
80003186:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80003188:	fe f8 03 7c 	ld.w	r8,pc[892]
8000318c:	70 08       	ld.w	r8,r8[0x0]
8000318e:	58 68       	cp.w	r8,6
80003190:	e0 8b 01 95 	brhi	800034ba <phy_tx_func+0x44e>
80003194:	fe f9 03 74 	ld.w	r9,pc[884]
80003198:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
8000319c:	fe f8 03 70 	ld.w	r8,pc[880]
800031a0:	70 08       	ld.w	r8,r8[0x0]
800031a2:	58 08       	cp.w	r8,0
800031a4:	c0 b0       	breq	800031ba <phy_tx_func+0x14e>
800031a6:	fe f8 03 66 	ld.w	r8,pc[870]
800031aa:	70 08       	ld.w	r8,r8[0x0]
800031ac:	58 a8       	cp.w	r8,10
800031ae:	c0 60       	breq	800031ba <phy_tx_func+0x14e>
800031b0:	fe f8 03 5c 	ld.w	r8,pc[860]
800031b4:	70 08       	ld.w	r8,r8[0x0]
800031b6:	58 18       	cp.w	r8,1
800031b8:	c0 a1       	brne	800031cc <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031ba:	e0 68 5a 5a 	mov	r8,23130
800031be:	ea 18 ab cd 	orh	r8,0xabcd
800031c2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031c4:	30 08       	mov	r8,0
800031c6:	8f 38       	st.w	r7[0xc],r8
800031c8:	e0 8f 01 8a 	bral	800034dc <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
800031cc:	fe f8 03 40 	ld.w	r8,pc[832]
800031d0:	70 08       	ld.w	r8,r8[0x0]
800031d2:	58 38       	cp.w	r8,3
800031d4:	c0 91       	brne	800031e6 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
800031d6:	fe f8 03 3a 	ld.w	r8,pc[826]
800031da:	70 09       	ld.w	r9,r8[0x0]
800031dc:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
800031de:	70 18       	ld.w	r8,r8[0x4]
800031e0:	8f 38       	st.w	r7[0xc],r8
800031e2:	e0 8f 01 7d 	bral	800034dc <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
800031e6:	fe f8 03 26 	ld.w	r8,pc[806]
800031ea:	70 08       	ld.w	r8,r8[0x0]
800031ec:	58 28       	cp.w	r8,2
800031ee:	c1 31       	brne	80003214 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
800031f0:	e0 68 c0 32 	mov	r8,49202
800031f4:	ea 18 ab cd 	orh	r8,0xabcd
800031f8:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
800031fa:	fe 78 84 7f 	mov	r8,-31617
800031fe:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003200:	fe f8 03 14 	ld.w	r8,pc[788]
80003204:	90 08       	ld.sh	r8,r8[0x0]
80003206:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003208:	30 39       	mov	r9,3
8000320a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000320e:	91 09       	st.w	r8[0x0],r9
80003210:	e0 8f 01 66 	bral	800034dc <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003214:	e0 68 c0 0e 	mov	r8,49166
80003218:	ea 18 ab cd 	orh	r8,0xabcd
8000321c:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
8000321e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003222:	90 09       	ld.sh	r9,r8[0x0]
80003224:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80003226:	90 18       	ld.sh	r8,r8[0x2]
80003228:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
8000322a:	30 19       	mov	r9,1
8000322c:	fe f8 02 d8 	ld.w	r8,pc[728]
80003230:	91 09       	st.w	r8[0x0],r9
80003232:	e0 8f 01 55 	bral	800034dc <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003236:	fe 78 88 f2 	mov	r8,-30478
8000323a:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
8000323c:	fe f8 02 d0 	ld.w	r8,pc[720]
80003240:	70 08       	ld.w	r8,r8[0x0]
80003242:	58 48       	cp.w	r8,4
80003244:	c0 60       	breq	80003250 <phy_tx_func+0x1e4>
80003246:	c4 53       	brcs	800032d0 <phy_tx_func+0x264>
80003248:	58 98       	cp.w	r8,9
8000324a:	e0 8b 00 43 	brhi	800032d0 <phy_tx_func+0x264>
8000324e:	c2 98       	rjmp	800032a0 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003250:	fe f8 02 cc 	ld.w	r8,pc[716]
80003254:	11 89       	ld.ub	r9,r8[0x0]
80003256:	30 18       	mov	r8,1
80003258:	f0 09 18 00 	cp.b	r9,r8
8000325c:	c0 a1       	brne	80003270 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
8000325e:	fe f8 02 c2 	ld.w	r8,pc[706]
80003262:	90 09       	ld.sh	r9,r8[0x0]
80003264:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003266:	90 19       	ld.sh	r9,r8[0x2]
80003268:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
8000326a:	90 28       	ld.sh	r8,r8[0x4]
8000326c:	ae 78       	st.h	r7[0xe],r8
8000326e:	c1 48       	rjmp	80003296 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003270:	fe f9 02 b4 	ld.w	r9,pc[692]
80003274:	92 0b       	ld.sh	r11,r9[0x0]
80003276:	fe f8 02 aa 	ld.w	r8,pc[682]
8000327a:	90 0a       	ld.sh	r10,r8[0x0]
8000327c:	f7 ea 20 0a 	eor	r10,r11,r10
80003280:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003282:	92 1b       	ld.sh	r11,r9[0x2]
80003284:	90 1a       	ld.sh	r10,r8[0x2]
80003286:	f7 ea 20 0a 	eor	r10,r11,r10
8000328a:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
8000328c:	92 29       	ld.sh	r9,r9[0x4]
8000328e:	90 28       	ld.sh	r8,r8[0x4]
80003290:	f3 e8 20 08 	eor	r8,r9,r8
80003294:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80003296:	30 29       	mov	r9,2
80003298:	fe f8 02 6c 	ld.w	r8,pc[620]
8000329c:	91 09       	st.w	r8[0x0],r9
8000329e:	c1 f9       	rjmp	800034dc <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032a0:	fe f9 02 84 	ld.w	r9,pc[644]
800032a4:	92 0b       	ld.sh	r11,r9[0x0]
800032a6:	fe f8 02 7a 	ld.w	r8,pc[634]
800032aa:	90 0a       	ld.sh	r10,r8[0x0]
800032ac:	f7 ea 20 0a 	eor	r10,r11,r10
800032b0:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032b2:	92 1b       	ld.sh	r11,r9[0x2]
800032b4:	90 1a       	ld.sh	r10,r8[0x2]
800032b6:	f7 ea 20 0a 	eor	r10,r11,r10
800032ba:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032bc:	92 29       	ld.sh	r9,r9[0x4]
800032be:	90 28       	ld.sh	r8,r8[0x4]
800032c0:	f3 e8 20 08 	eor	r8,r9,r8
800032c4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032c6:	30 29       	mov	r9,2
800032c8:	fe f8 02 3c 	ld.w	r8,pc[572]
800032cc:	91 09       	st.w	r8[0x0],r9
800032ce:	c0 79       	rjmp	800034dc <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800032d0:	e0 68 5a 5a 	mov	r8,23130
800032d4:	ea 18 ab cd 	orh	r8,0xabcd
800032d8:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800032da:	30 08       	mov	r8,0
800032dc:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
800032de:	fe f9 02 26 	ld.w	r9,pc[550]
800032e2:	93 08       	st.w	r9[0x0],r8
800032e4:	cf c8       	rjmp	800034dc <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
800032e6:	fe f8 02 3e 	ld.w	r8,pc[574]
800032ea:	90 38       	ld.sh	r8,r8[0x6]
800032ec:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
800032ee:	e0 68 00 ba 	mov	r8,186
800032f2:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
800032f4:	30 08       	mov	r8,0
800032f6:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
800032f8:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
800032fa:	30 09       	mov	r9,0
800032fc:	fe f8 02 08 	ld.w	r8,pc[520]
80003300:	91 09       	st.w	r8[0x0],r9
80003302:	ce d8       	rjmp	800034dc <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80003304:	fe f8 02 10 	ld.w	r8,pc[528]
80003308:	90 18       	ld.sh	r8,r8[0x2]
8000330a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
8000330c:	fe f8 02 0c 	ld.w	r8,pc[524]
80003310:	90 08       	ld.sh	r8,r8[0x0]
80003312:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80003314:	4f e8       	lddpc	r8,8000350c <phy_tx_func+0x4a0>
80003316:	70 08       	ld.w	r8,r8[0x0]
80003318:	58 48       	cp.w	r8,4
8000331a:	c0 d1       	brne	80003334 <phy_tx_func+0x2c8>
8000331c:	fe f8 02 00 	ld.w	r8,pc[512]
80003320:	11 89       	ld.ub	r9,r8[0x0]
80003322:	30 18       	mov	r8,1
80003324:	f0 09 18 00 	cp.b	r9,r8
80003328:	c0 61       	brne	80003334 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
8000332a:	4f c8       	lddpc	r8,80003518 <phy_tx_func+0x4ac>
8000332c:	90 18       	ld.sh	r8,r8[0x2]
8000332e:	a9 a8       	sbr	r8,0x8
80003330:	ae 68       	st.h	r7[0xc],r8
80003332:	c0 48       	rjmp	8000333a <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80003334:	4f 98       	lddpc	r8,80003518 <phy_tx_func+0x4ac>
80003336:	90 18       	ld.sh	r8,r8[0x2]
80003338:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
8000333a:	fe 78 9a 13 	mov	r8,-26093
8000333e:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003340:	30 49       	mov	r9,4
80003342:	4f 18       	lddpc	r8,80003504 <phy_tx_func+0x498>
80003344:	91 09       	st.w	r8[0x0],r9
80003346:	cc b8       	rjmp	800034dc <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80003348:	4f 88       	lddpc	r8,80003528 <phy_tx_func+0x4bc>
8000334a:	70 0a       	ld.w	r10,r8[0x0]
8000334c:	4f 89       	lddpc	r9,8000352c <phy_tx_func+0x4c0>
8000334e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003352:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80003354:	70 0a       	ld.w	r10,r8[0x0]
80003356:	2f fa       	sub	r10,-1
80003358:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000335c:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
8000335e:	70 0a       	ld.w	r10,r8[0x0]
80003360:	2f ea       	sub	r10,-2
80003362:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003366:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80003368:	70 0a       	ld.w	r10,r8[0x0]
8000336a:	2f da       	sub	r10,-3
8000336c:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003370:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80003372:	70 09       	ld.w	r9,r8[0x0]
80003374:	2f c9       	sub	r9,-4
80003376:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80003378:	58 c9       	cp.w	r9,12
8000337a:	c0 51       	brne	80003384 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
8000337c:	30 59       	mov	r9,5
8000337e:	4e 28       	lddpc	r8,80003504 <phy_tx_func+0x498>
80003380:	91 09       	st.w	r8[0x0],r9
80003382:	ca d8       	rjmp	800034dc <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80003384:	30 49       	mov	r9,4
80003386:	4e 08       	lddpc	r8,80003504 <phy_tx_func+0x498>
80003388:	91 09       	st.w	r8[0x0],r9
8000338a:	ca 98       	rjmp	800034dc <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
8000338c:	4e 78       	lddpc	r8,80003528 <phy_tx_func+0x4bc>
8000338e:	70 0a       	ld.w	r10,r8[0x0]
80003390:	4e 79       	lddpc	r9,8000352c <phy_tx_func+0x4c0>
80003392:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003396:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80003398:	30 09       	mov	r9,0
8000339a:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
8000339c:	fe 78 80 03 	mov	r8,-32765
800033a0:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800033a2:	fe 78 88 f3 	mov	r8,-30477
800033a6:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800033a8:	4d 98       	lddpc	r8,8000350c <phy_tx_func+0x4a0>
800033aa:	70 08       	ld.w	r8,r8[0x0]
800033ac:	58 48       	cp.w	r8,4
800033ae:	c0 60       	breq	800033ba <phy_tx_func+0x34e>
800033b0:	c2 83       	brcs	80003400 <phy_tx_func+0x394>
800033b2:	58 98       	cp.w	r8,9
800033b4:	e0 8b 00 26 	brhi	80003400 <phy_tx_func+0x394>
800033b8:	c1 98       	rjmp	800033ea <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800033ba:	4d 98       	lddpc	r8,8000351c <phy_tx_func+0x4b0>
800033bc:	11 89       	ld.ub	r9,r8[0x0]
800033be:	30 18       	mov	r8,1
800033c0:	f0 09 18 00 	cp.b	r9,r8
800033c4:	c0 81       	brne	800033d4 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800033c6:	4d 88       	lddpc	r8,80003524 <phy_tx_func+0x4b8>
800033c8:	90 0a       	ld.sh	r10,r8[0x0]
800033ca:	4d a9       	lddpc	r9,80003530 <phy_tx_func+0x4c4>
800033cc:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
800033ce:	90 08       	ld.sh	r8,r8[0x0]
800033d0:	ae 78       	st.h	r7[0xe],r8
800033d2:	c0 88       	rjmp	800033e2 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800033d4:	4d 78       	lddpc	r8,80003530 <phy_tx_func+0x4c4>
800033d6:	90 08       	ld.sh	r8,r8[0x0]
800033d8:	4d 39       	lddpc	r9,80003524 <phy_tx_func+0x4b8>
800033da:	92 09       	ld.sh	r9,r9[0x0]
800033dc:	f3 e8 20 08 	eor	r8,r9,r8
800033e0:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
800033e2:	30 69       	mov	r9,6
800033e4:	4c 88       	lddpc	r8,80003504 <phy_tx_func+0x498>
800033e6:	91 09       	st.w	r8[0x0],r9
800033e8:	c7 a8       	rjmp	800034dc <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800033ea:	4d 28       	lddpc	r8,80003530 <phy_tx_func+0x4c4>
800033ec:	90 08       	ld.sh	r8,r8[0x0]
800033ee:	4c e9       	lddpc	r9,80003524 <phy_tx_func+0x4b8>
800033f0:	92 09       	ld.sh	r9,r9[0x0]
800033f2:	f3 e8 20 08 	eor	r8,r9,r8
800033f6:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
800033f8:	30 69       	mov	r9,6
800033fa:	4c 38       	lddpc	r8,80003504 <phy_tx_func+0x498>
800033fc:	91 09       	st.w	r8[0x0],r9
800033fe:	c6 f8       	rjmp	800034dc <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003400:	e0 68 5a 5a 	mov	r8,23130
80003404:	ea 18 ab cd 	orh	r8,0xabcd
80003408:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000340a:	30 08       	mov	r8,0
8000340c:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
8000340e:	4b e9       	lddpc	r9,80003504 <phy_tx_func+0x498>
80003410:	93 08       	st.w	r9[0x0],r8
80003412:	c6 58       	rjmp	800034dc <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80003414:	4b e8       	lddpc	r8,8000350c <phy_tx_func+0x4a0>
80003416:	70 08       	ld.w	r8,r8[0x0]
80003418:	58 48       	cp.w	r8,4
8000341a:	c0 60       	breq	80003426 <phy_tx_func+0x3ba>
8000341c:	c4 53       	brcs	800034a6 <phy_tx_func+0x43a>
8000341e:	58 98       	cp.w	r8,9
80003420:	e0 8b 00 43 	brhi	800034a6 <phy_tx_func+0x43a>
80003424:	c2 d8       	rjmp	8000347e <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80003426:	4b e8       	lddpc	r8,8000351c <phy_tx_func+0x4b0>
80003428:	11 89       	ld.ub	r9,r8[0x0]
8000342a:	30 18       	mov	r8,1
8000342c:	f0 09 18 00 	cp.b	r9,r8
80003430:	c1 31       	brne	80003456 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80003432:	4b d8       	lddpc	r8,80003524 <phy_tx_func+0x4b8>
80003434:	90 1a       	ld.sh	r10,r8[0x2]
80003436:	4b f9       	lddpc	r9,80003530 <phy_tx_func+0x4c4>
80003438:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
8000343a:	90 2a       	ld.sh	r10,r8[0x4]
8000343c:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
8000343e:	90 3a       	ld.sh	r10,r8[0x6]
80003440:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80003442:	90 19       	ld.sh	r9,r8[0x2]
80003444:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80003446:	90 29       	ld.sh	r9,r8[0x4]
80003448:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
8000344a:	90 38       	ld.sh	r8,r8[0x6]
8000344c:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
8000344e:	e0 68 00 ba 	mov	r8,186
80003452:	ae 78       	st.h	r7[0xe],r8
80003454:	c1 18       	rjmp	80003476 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80003456:	4b 48       	lddpc	r8,80003524 <phy_tx_func+0x4b8>
80003458:	90 1a       	ld.sh	r10,r8[0x2]
8000345a:	4b 69       	lddpc	r9,80003530 <phy_tx_func+0x4c4>
8000345c:	92 1b       	ld.sh	r11,r9[0x2]
8000345e:	f7 ea 20 0a 	eor	r10,r11,r10
80003462:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80003464:	90 2a       	ld.sh	r10,r8[0x4]
80003466:	92 29       	ld.sh	r9,r9[0x4]
80003468:	14 59       	eor	r9,r10
8000346a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
8000346c:	90 38       	ld.sh	r8,r8[0x6]
8000346e:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80003470:	e0 68 00 ba 	mov	r8,186
80003474:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80003476:	30 09       	mov	r9,0
80003478:	4a 38       	lddpc	r8,80003504 <phy_tx_func+0x498>
8000347a:	91 09       	st.w	r8[0x0],r9
8000347c:	c3 08       	rjmp	800034dc <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000347e:	4a a8       	lddpc	r8,80003524 <phy_tx_func+0x4b8>
80003480:	90 1a       	ld.sh	r10,r8[0x2]
80003482:	4a c9       	lddpc	r9,80003530 <phy_tx_func+0x4c4>
80003484:	92 1b       	ld.sh	r11,r9[0x2]
80003486:	f7 ea 20 0a 	eor	r10,r11,r10
8000348a:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
8000348c:	90 2a       	ld.sh	r10,r8[0x4]
8000348e:	92 29       	ld.sh	r9,r9[0x4]
80003490:	14 59       	eor	r9,r10
80003492:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80003494:	90 38       	ld.sh	r8,r8[0x6]
80003496:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80003498:	e0 68 00 ba 	mov	r8,186
8000349c:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
8000349e:	30 09       	mov	r9,0
800034a0:	49 98       	lddpc	r8,80003504 <phy_tx_func+0x498>
800034a2:	91 09       	st.w	r8[0x0],r9
800034a4:	c1 c8       	rjmp	800034dc <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034a6:	e0 68 5a 5a 	mov	r8,23130
800034aa:	ea 18 ab cd 	orh	r8,0xabcd
800034ae:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034b0:	30 08       	mov	r8,0
800034b2:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
800034b4:	49 49       	lddpc	r9,80003504 <phy_tx_func+0x498>
800034b6:	93 08       	st.w	r9[0x0],r8
800034b8:	c1 28       	rjmp	800034dc <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034ba:	e0 68 5a 5a 	mov	r8,23130
800034be:	ea 18 ab cd 	orh	r8,0xabcd
800034c2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034c4:	30 08       	mov	r8,0
800034c6:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
800034c8:	48 f9       	lddpc	r9,80003504 <phy_tx_func+0x498>
800034ca:	93 08       	st.w	r9[0x0],r8
800034cc:	c0 88       	rjmp	800034dc <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034ce:	e0 68 5a 5a 	mov	r8,23130
800034d2:	ea 18 ab cd 	orh	r8,0xabcd
800034d6:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034d8:	30 08       	mov	r8,0
800034da:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
800034dc:	2f fd       	sub	sp,-4
800034de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034e2:	00 00       	add	r0,r0
800034e4:	00 00       	add	r0,r0
800034e6:	0a d0       	st.w	--r5,r0
800034e8:	00 00       	add	r0,r0
800034ea:	0a 8c       	andn	r12,r5
800034ec:	00 00       	add	r0,r0
800034ee:	0a e4       	st.h	--r5,r4
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	5b c8       	cp.w	r8,-4
800034f4:	00 00       	add	r0,r0
800034f6:	0a b6       	st.h	r5++,r6
800034f8:	00 00       	add	r0,r0
800034fa:	0a 6c       	and	r12,r5
800034fc:	00 00       	add	r0,r0
800034fe:	0a 4f       	or	pc,r5
80003500:	00 00       	add	r0,r0
80003502:	0a e0       	st.h	--r5,r0
80003504:	00 00       	add	r0,r0
80003506:	0a 7c       	tst	r12,r5
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	d1 9c       	*unknown*
8000350c:	00 00       	add	r0,r0
8000350e:	0a d4       	st.w	--r5,r4
80003510:	00 00       	add	r0,r0
80003512:	0a 94       	mov	r4,r5
80003514:	00 00       	add	r0,r0
80003516:	1d 9c       	ld.ub	r12,lr[0x1]
80003518:	00 00       	add	r0,r0
8000351a:	1e 98       	mov	r8,pc
8000351c:	00 00       	add	r0,r0
8000351e:	0a 55       	eor	r5,r5
80003520:	80 00       	ld.sh	r0,r0[0x0]
80003522:	d1 40       	acall	0x14
80003524:	00 00       	add	r0,r0
80003526:	1d 94       	ld.ub	r4,lr[0x1]
80003528:	00 00       	add	r0,r0
8000352a:	0a d8       	st.w	--r5,r8
8000352c:	00 00       	add	r0,r0
8000352e:	1e 9c       	mov	r12,pc
80003530:	00 00       	add	r0,r0
80003532:	1d a0       	ld.ub	r0,lr[0x2]

80003534 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003534:	d4 01       	pushm	lr
80003536:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003538:	30 0a       	mov	r10,0
8000353a:	fa cb ff fc 	sub	r11,sp,-4
8000353e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003540:	14 99       	mov	r9,r10
80003542:	1a 9b       	mov	r11,sp
80003544:	f0 1f 00 05 	mcall	80003558 <get_idle_store+0x24>
80003548:	58 1c       	cp.w	r12,1
8000354a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000354e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003552:	2f fd       	sub	sp,-4
80003554:	d8 02       	popm	pc
80003556:	00 00       	add	r0,r0
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	5c b8       	swap.b	r8

8000355c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
8000355c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000355e:	48 5b       	lddpc	r11,80003570 <phy_init+0x14>
80003560:	48 5c       	lddpc	r12,80003574 <phy_init+0x18>
80003562:	f0 1f 00 06 	mcall	80003578 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80003566:	f0 1f 00 06 	mcall	8000357c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
8000356a:	f0 1f 00 06 	mcall	80003580 <phy_init+0x24>
	
}
8000356e:	d8 02       	popm	pc
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	30 6c       	mov	r12,6
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	35 e4       	mov	r4,94
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	46 2c       	lddsp	r12,sp[0x188]
8000357c:	80 00       	ld.sh	r0,r0[0x0]
8000357e:	46 40       	lddsp	r0,sp[0x190]
80003580:	80 00       	ld.sh	r0,r0[0x0]
80003582:	4f 54       	lddpc	r4,80003754 <phy_rx_func+0x170>

80003584 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003584:	d4 01       	pushm	lr
80003586:	20 2d       	sub	sp,8
80003588:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000358a:	30 08       	mov	r8,0
8000358c:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
8000358e:	48 f8       	lddpc	r8,800035c8 <payload_rx+0x44>
80003590:	70 08       	ld.w	r8,r8[0x0]
80003592:	58 08       	cp.w	r8,0
80003594:	c0 71       	brne	800035a2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003596:	30 4b       	mov	r11,4
80003598:	30 5c       	mov	r12,5
8000359a:	f0 1f 00 0d 	mcall	800035cc <payload_rx+0x48>
8000359e:	48 b8       	lddpc	r8,800035c8 <payload_rx+0x44>
800035a0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800035a2:	48 a8       	lddpc	r8,800035c8 <payload_rx+0x44>
800035a4:	70 0c       	ld.w	r12,r8[0x0]
800035a6:	30 09       	mov	r9,0
800035a8:	fa ca ff fc 	sub	r10,sp,-4
800035ac:	1a 9b       	mov	r11,sp
800035ae:	f0 1f 00 09 	mcall	800035d0 <payload_rx+0x4c>
800035b2:	c0 91       	brne	800035c4 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
800035b4:	48 88       	lddpc	r8,800035d4 <payload_rx+0x50>
800035b6:	70 0c       	ld.w	r12,r8[0x0]
800035b8:	40 0b       	lddsp	r11,sp[0x0]
800035ba:	f0 1f 00 08 	mcall	800035d8 <payload_rx+0x54>
		logFromISR("mm");
800035be:	48 8c       	lddpc	r12,800035dc <payload_rx+0x58>
800035c0:	f0 1f 00 08 	mcall	800035e0 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
800035c4:	2f ed       	sub	sp,-8
800035c6:	d8 02       	popm	pc
800035c8:	00 00       	add	r0,r0
800035ca:	0a 78       	tst	r8,r5
800035cc:	80 00       	ld.sh	r0,r0[0x0]
800035ce:	5f c4       	srvs	r4
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	5e 74       	retpl	r4
800035d4:	00 00       	add	r0,r0
800035d6:	0a a8       	st.w	r5++,r8
800035d8:	80 00       	ld.sh	r0,r0[0x0]
800035da:	2f 74       	sub	r4,-9
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	d1 b8       	*unknown*
800035e0:	80 00       	ld.sh	r0,r0[0x0]
800035e2:	6b e8       	ld.w	r8,r5[0x78]

800035e4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800035e4:	eb cd 40 e0 	pushm	r5-r7,lr
800035e8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800035ea:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800035ee:	70 08       	ld.w	r8,r8[0x0]
800035f0:	58 08       	cp.w	r8,0
800035f2:	e0 80 01 08 	breq	80003802 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800035f6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800035f8:	fe f8 0e 70 	ld.w	r8,pc[3696]
800035fc:	70 09       	ld.w	r9,r8[0x0]
800035fe:	2f f9       	sub	r9,-1
80003600:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003602:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003606:	70 08       	ld.w	r8,r8[0x0]
80003608:	58 18       	cp.w	r8,1
8000360a:	e0 80 00 85 	breq	80003714 <phy_rx_func+0x130>
8000360e:	c0 73       	brcs	8000361c <phy_rx_func+0x38>
80003610:	58 28       	cp.w	r8,2
80003612:	c5 c0       	breq	800036ca <phy_rx_func+0xe6>
80003614:	58 38       	cp.w	r8,3
80003616:	e0 81 00 f6 	brne	80003802 <phy_rx_func+0x21e>
8000361a:	cd 58       	rjmp	800037c4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000361c:	e0 6a 5a 5a 	mov	r10,23130
80003620:	ea 1a ab cd 	orh	r10,0xabcd
80003624:	14 36       	cp.w	r6,r10
80003626:	e0 80 00 ee 	breq	80003802 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000362a:	ec 08 16 10 	lsr	r8,r6,0x10
8000362e:	e0 48 ab cd 	cp.w	r8,43981
80003632:	e0 81 00 e8 	brne	80003802 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003636:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000363a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000363e:	20 28       	sub	r8,2
80003640:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003644:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003646:	30 09       	mov	r9,0
80003648:	f2 08 19 00 	cp.h	r8,r9
8000364c:	e0 8a 00 db 	brle	80003802 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003650:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003654:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003656:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000365a:	70 0c       	ld.w	r12,r8[0x0]
8000365c:	f0 1f 03 88 	mcall	8000447c <phy_rx_func+0xe98>
80003660:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003664:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003666:	58 0c       	cp.w	r12,0
80003668:	e0 80 00 cd 	breq	80003802 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000366c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003670:	90 09       	ld.sh	r9,r8[0x0]
80003672:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003676:	2f f9       	sub	r9,-1
80003678:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000367a:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000367e:	74 0a       	ld.w	r10,r10[0x0]
80003680:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003684:	76 0b       	ld.w	r11,r11[0x0]
80003686:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000368a:	2f f9       	sub	r9,-1
8000368c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000368e:	e2 16 0f 00 	andl	r6,0xf00,COH
80003692:	e0 46 01 00 	cp.w	r6,256
80003696:	c0 c0       	breq	800036ae <phy_rx_func+0xca>
80003698:	e0 8b 00 05 	brhi	800036a2 <phy_rx_func+0xbe>
8000369c:	58 06       	cp.w	r6,0
8000369e:	c0 80       	breq	800036ae <phy_rx_func+0xca>
800036a0:	c0 c8       	rjmp	800036b8 <phy_rx_func+0xd4>
800036a2:	e0 46 02 00 	cp.w	r6,512
800036a6:	c0 40       	breq	800036ae <phy_rx_func+0xca>
800036a8:	e0 46 03 00 	cp.w	r6,768
800036ac:	c0 61       	brne	800036b8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800036ae:	30 29       	mov	r9,2
800036b0:	fe f8 0d bc 	ld.w	r8,pc[3516]
800036b4:	91 09       	st.w	r8[0x0],r9
800036b6:	ca 68       	rjmp	80003802 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800036b8:	fe f8 0d c0 	ld.w	r8,pc[3520]
800036bc:	70 0c       	ld.w	r12,r8[0x0]
800036be:	fe f8 0d c2 	ld.w	r8,pc[3522]
800036c2:	70 0b       	ld.w	r11,r8[0x0]
800036c4:	f0 1f 03 70 	mcall	80004484 <phy_rx_func+0xea0>
800036c8:	c9 d8       	rjmp	80003802 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800036ca:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800036ce:	b1 86       	lsr	r6,0x10
800036d0:	14 06       	add	r6,r10
800036d2:	fe f8 0d b6 	ld.w	r8,pc[3510]
800036d6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800036d8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800036dc:	90 09       	ld.sh	r9,r8[0x0]
800036de:	fe fb 0d a2 	ld.w	r11,pc[3490]
800036e2:	76 0b       	ld.w	r11,r11[0x0]
800036e4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800036e8:	2f f9       	sub	r9,-1
800036ea:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800036ec:	fe f9 0d 84 	ld.w	r9,pc[3460]
800036f0:	92 08       	ld.sh	r8,r9[0x0]
800036f2:	20 28       	sub	r8,2
800036f4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800036f6:	30 09       	mov	r9,0
800036f8:	f2 08 19 00 	cp.h	r8,r9
800036fc:	e0 8a 00 07 	brle	8000370a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003700:	30 19       	mov	r9,1
80003702:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003706:	91 09       	st.w	r8[0x0],r9
80003708:	c7 d8       	rjmp	80003802 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000370a:	30 39       	mov	r9,3
8000370c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003710:	91 09       	st.w	r8[0x0],r9
80003712:	c7 88       	rjmp	80003802 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003714:	ec 0a 14 10 	asr	r10,r6,0x10
80003718:	fe f8 0d 70 	ld.w	r8,pc[3440]
8000371c:	90 09       	ld.sh	r9,r8[0x0]
8000371e:	14 09       	add	r9,r10
80003720:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003722:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003726:	92 08       	ld.sh	r8,r9[0x0]
80003728:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000372c:	76 0b       	ld.w	r11,r11[0x0]
8000372e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003732:	2f f8       	sub	r8,-1
80003734:	5c 88       	casts.h	r8
80003736:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003738:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000373c:	94 09       	ld.sh	r9,r10[0x0]
8000373e:	20 29       	sub	r9,2
80003740:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003742:	30 0a       	mov	r10,0
80003744:	f4 09 19 00 	cp.h	r9,r10
80003748:	e0 89 00 20 	brgt	80003788 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000374c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003750:	e0 46 00 ba 	cp.w	r6,186
80003754:	c0 d1       	brne	8000376e <phy_rx_func+0x18a>
80003756:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000375a:	90 09       	ld.sh	r9,r8[0x0]
8000375c:	f4 09 19 00 	cp.h	r9,r10
80003760:	c0 71       	brne	8000376e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003762:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003766:	70 0c       	ld.w	r12,r8[0x0]
80003768:	f0 1f 03 49 	mcall	8000448c <phy_rx_func+0xea8>
8000376c:	c0 98       	rjmp	8000377e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000376e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003772:	70 0c       	ld.w	r12,r8[0x0]
80003774:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003778:	70 0b       	ld.w	r11,r8[0x0]
8000377a:	f0 1f 03 43 	mcall	80004484 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000377e:	30 09       	mov	r9,0
80003780:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003784:	91 09       	st.w	r8[0x0],r9
80003786:	c3 e8       	rjmp	80003802 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003788:	5c 86       	casts.h	r6
8000378a:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000378e:	92 0a       	ld.sh	r10,r9[0x0]
80003790:	0c 0a       	add	r10,r6
80003792:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003794:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003798:	72 09       	ld.w	r9,r9[0x0]
8000379a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000379e:	2f f8       	sub	r8,-1
800037a0:	fe f9 0c d4 	ld.w	r9,pc[3284]
800037a4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800037a6:	fe f9 0c ca 	ld.w	r9,pc[3274]
800037aa:	92 08       	ld.sh	r8,r9[0x0]
800037ac:	20 28       	sub	r8,2
800037ae:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800037b0:	30 09       	mov	r9,0
800037b2:	f2 08 19 00 	cp.h	r8,r9
800037b6:	e0 89 00 26 	brgt	80003802 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800037ba:	30 39       	mov	r9,3
800037bc:	fe f8 0c b0 	ld.w	r8,pc[3248]
800037c0:	91 09       	st.w	r8[0x0],r9
800037c2:	c2 08       	rjmp	80003802 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800037c4:	e6 16 00 ff 	andh	r6,0xff,COH
800037c8:	fc 19 00 ba 	movh	r9,0xba
800037cc:	12 36       	cp.w	r6,r9
800037ce:	c0 e1       	brne	800037ea <phy_rx_func+0x206>
800037d0:	fe f8 0c b8 	ld.w	r8,pc[3256]
800037d4:	90 09       	ld.sh	r9,r8[0x0]
800037d6:	30 08       	mov	r8,0
800037d8:	f0 09 19 00 	cp.h	r9,r8
800037dc:	c0 71       	brne	800037ea <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800037de:	fe f8 0c a2 	ld.w	r8,pc[3234]
800037e2:	70 0c       	ld.w	r12,r8[0x0]
800037e4:	f0 1f 03 2a 	mcall	8000448c <phy_rx_func+0xea8>
800037e8:	c0 98       	rjmp	800037fa <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800037ea:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800037ee:	70 0c       	ld.w	r12,r8[0x0]
800037f0:	fe f8 0c 90 	ld.w	r8,pc[3216]
800037f4:	70 0b       	ld.w	r11,r8[0x0]
800037f6:	f0 1f 03 24 	mcall	80004484 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800037fa:	30 09       	mov	r9,0
800037fc:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003800:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003802:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003806:	11 89       	ld.ub	r9,r8[0x0]
80003808:	30 08       	mov	r8,0
8000380a:	f0 09 18 00 	cp.b	r9,r8
8000380e:	c1 31       	brne	80003834 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003810:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003814:	6c 0c       	ld.w	r12,r6[0x0]
80003816:	f0 1f 03 1a 	mcall	8000447c <phy_rx_func+0xe98>
8000381a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000381e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003820:	6c 0c       	ld.w	r12,r6[0x0]
80003822:	f0 1f 03 17 	mcall	8000447c <phy_rx_func+0xe98>
80003826:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000382a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000382c:	30 19       	mov	r9,1
8000382e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003832:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003834:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003838:	70 08       	ld.w	r8,r8[0x0]
8000383a:	58 28       	cp.w	r8,2
8000383c:	e0 80 01 98 	breq	80003b6c <phy_rx_func+0x588>
80003840:	e0 8b 00 06 	brhi	8000384c <phy_rx_func+0x268>
80003844:	58 08       	cp.w	r8,0
80003846:	c0 b0       	breq	8000385c <phy_rx_func+0x278>
80003848:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000384c:	58 38       	cp.w	r8,3
8000384e:	e0 80 05 c5 	breq	800043d8 <phy_rx_func+0xdf4>
80003852:	58 48       	cp.w	r8,4
80003854:	e0 81 06 05 	brne	8000445e <phy_rx_func+0xe7a>
80003858:	e0 8f 02 4b 	bral	80003cee <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000385c:	6e 28       	ld.w	r8,r7[0x8]
8000385e:	e0 6a 5a 5a 	mov	r10,23130
80003862:	ea 1a ab cd 	orh	r10,0xabcd
80003866:	14 38       	cp.w	r8,r10
80003868:	c0 71       	brne	80003876 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000386a:	30 09       	mov	r9,0
8000386c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003870:	91 09       	st.w	r8[0x0],r9
80003872:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003876:	10 99       	mov	r9,r8
80003878:	e0 19 00 00 	andl	r9,0x0
8000387c:	fc 1a ab cd 	movh	r10,0xabcd
80003880:	14 39       	cp.w	r9,r10
80003882:	e0 81 05 ee 	brne	8000445e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003886:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000388a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000388e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003890:	6e 29       	ld.w	r9,r7[0x8]
80003892:	e2 19 f0 00 	andl	r9,0xf000,COH
80003896:	e0 49 c0 00 	cp.w	r9,49152
8000389a:	e0 81 00 ce 	brne	80003a36 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000389e:	30 1a       	mov	r10,1
800038a0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800038a4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800038a6:	fe f9 0b f6 	ld.w	r9,pc[3062]
800038aa:	72 09       	ld.w	r9,r9[0x0]
800038ac:	58 09       	cp.w	r9,0
800038ae:	c0 71       	brne	800038bc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800038b0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800038b4:	f0 1f 03 00 	mcall	800044b4 <phy_rx_func+0xed0>
800038b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800038bc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800038c0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800038c4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800038c6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038ca:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800038ce:	fe fa 0b ee 	ld.w	r10,pc[3054]
800038d2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800038d4:	13 89       	ld.ub	r9,r9[0x0]
800038d6:	37 fa       	mov	r10,127
800038d8:	f4 09 18 00 	cp.b	r9,r10
800038dc:	c6 d0       	breq	800039b6 <phy_rx_func+0x3d2>
800038de:	e0 8b 00 0c 	brhi	800038f6 <phy_rx_func+0x312>
800038e2:	31 2a       	mov	r10,18
800038e4:	f4 09 18 00 	cp.b	r9,r10
800038e8:	c4 20       	breq	8000396c <phy_rx_func+0x388>
800038ea:	31 3a       	mov	r10,19
800038ec:	f4 09 18 00 	cp.b	r9,r10
800038f0:	e0 81 00 83 	brne	800039f6 <phy_rx_func+0x412>
800038f4:	c5 b8       	rjmp	800039aa <phy_rx_func+0x3c6>
800038f6:	2f 09       	sub	r9,-16
800038f8:	30 1a       	mov	r10,1
800038fa:	f4 09 18 00 	cp.b	r9,r10
800038fe:	e0 8b 00 7c 	brhi	800039f6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003902:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003906:	e2 18 00 f0 	andl	r8,0xf0,COH
8000390a:	59 08       	cp.w	r8,16
8000390c:	c0 71       	brne	8000391a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000390e:	30 19       	mov	r9,1
80003910:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003914:	91 09       	st.w	r8[0x0],r9
80003916:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000391a:	e0 48 00 20 	cp.w	r8,32
8000391e:	c2 11       	brne	80003960 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003920:	30 a9       	mov	r9,10
80003922:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003926:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003928:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000392c:	6c 08       	ld.w	r8,r6[0x0]
8000392e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003932:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003936:	2f f8       	sub	r8,-1
80003938:	6e 0c       	ld.w	r12,r7[0x0]
8000393a:	f4 ca fe 00 	sub	r10,r10,-512
8000393e:	30 0b       	mov	r11,0
80003940:	10 0c       	add	r12,r8
80003942:	f0 1f 02 e1 	mcall	800044c4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003946:	30 08       	mov	r8,0
80003948:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000394a:	6e 0c       	ld.w	r12,r7[0x0]
8000394c:	f0 1f 02 df 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003950:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003954:	70 0c       	ld.w	r12,r8[0x0]
80003956:	f0 1f 02 ca 	mcall	8000447c <phy_rx_func+0xe98>
8000395a:	8f 0c       	st.w	r7[0x0],r12
8000395c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003960:	30 09       	mov	r9,0
80003962:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003966:	91 09       	st.w	r8[0x0],r9
80003968:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000396c:	20 48       	sub	r8,4
8000396e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003972:	93 08       	st.w	r9[0x0],r8
80003974:	58 08       	cp.w	r8,0
80003976:	e0 80 05 74 	breq	8000445e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000397a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000397e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003982:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003986:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003988:	8e 69       	ld.sh	r9,r7[0xc]
8000398a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000398e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003990:	8e 79       	ld.sh	r9,r7[0xe]
80003992:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003994:	f0 1f 02 d0 	mcall	800044d4 <phy_rx_func+0xef0>
80003998:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000399c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000399e:	30 49       	mov	r9,4
800039a0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800039a4:	91 09       	st.w	r8[0x0],r9
800039a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800039aa:	30 09       	mov	r9,0
800039ac:	fe f8 0a f8 	ld.w	r8,pc[2808]
800039b0:	91 09       	st.w	r8[0x0],r9
800039b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800039b6:	20 48       	sub	r8,4
800039b8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800039bc:	93 08       	st.w	r9[0x0],r8
800039be:	58 08       	cp.w	r8,0
800039c0:	e0 80 05 4f 	breq	8000445e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800039c4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800039c8:	70 09       	ld.w	r9,r8[0x0]
800039ca:	8e 7b       	ld.sh	r11,r7[0xe]
800039cc:	fe fa 0b 10 	ld.w	r10,pc[2832]
800039d0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800039d4:	2f f9       	sub	r9,-1
800039d6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800039d8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800039dc:	70 09       	ld.w	r9,r8[0x0]
800039de:	20 29       	sub	r9,2
800039e0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800039e2:	30 29       	mov	r9,2
800039e4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800039e8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800039ea:	30 39       	mov	r9,3
800039ec:	fe f8 0a b4 	ld.w	r8,pc[2740]
800039f0:	91 09       	st.w	r8[0x0],r9
800039f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800039f6:	30 3a       	mov	r10,3
800039f8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800039fc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800039fe:	6e 2a       	ld.w	r10,r7[0x8]
80003a00:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003a04:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003a06:	6e 3a       	ld.w	r10,r7[0xc]
80003a08:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003a0a:	59 48       	cp.w	r8,20
80003a0c:	c0 61       	brne	80003a18 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003a0e:	31 89       	mov	r9,24
80003a10:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003a14:	91 09       	st.w	r8[0x0],r9
80003a16:	c0 a8       	rjmp	80003a2a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003a18:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003a1c:	70 08       	ld.w	r8,r8[0x0]
80003a1e:	59 08       	cp.w	r8,16
80003a20:	c0 51       	brne	80003a2a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003a22:	31 09       	mov	r9,16
80003a24:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003a28:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a2a:	30 49       	mov	r9,4
80003a2c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003a30:	91 09       	st.w	r8[0x0],r9
80003a32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003a36:	e0 49 10 00 	cp.w	r9,4096
80003a3a:	5f 1a       	srne	r10
80003a3c:	e0 49 20 00 	cp.w	r9,8192
80003a40:	5f 19       	srne	r9
80003a42:	f5 e9 00 09 	and	r9,r10,r9
80003a46:	e0 81 05 0c 	brne	8000445e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003a4a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003a4e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003a50:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003a54:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003a56:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003a5a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003a5c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003a60:	72 09       	ld.w	r9,r9[0x0]
80003a62:	58 09       	cp.w	r9,0
80003a64:	c0 71       	brne	80003a72 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a66:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003a6a:	f0 1f 02 93 	mcall	800044b4 <phy_rx_func+0xed0>
80003a6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a72:	6e 2a       	ld.w	r10,r7[0x8]
80003a74:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003a78:	58 1a       	cp.w	r10,1
80003a7a:	e0 8b 00 4d 	brhi	80003b14 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003a7e:	20 48       	sub	r8,4
80003a80:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003a84:	93 08       	st.w	r9[0x0],r8
80003a86:	58 08       	cp.w	r8,0
80003a88:	e0 80 04 eb 	breq	8000445e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003a8c:	8e 68       	ld.sh	r8,r7[0xc]
80003a8e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003a92:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003a96:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003a98:	30 09       	mov	r9,0
80003a9a:	f2 08 19 00 	cp.h	r8,r9
80003a9e:	c0 70       	breq	80003aac <phy_rx_func+0x4c8>
80003aa0:	30 19       	mov	r9,1
80003aa2:	f2 08 19 00 	cp.h	r8,r9
80003aa6:	e0 81 04 dc 	brne	8000445e <phy_rx_func+0xe7a>
80003aaa:	c2 68       	rjmp	80003af6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003aac:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003ab0:	70 0a       	ld.w	r10,r8[0x0]
80003ab2:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003ab6:	72 09       	ld.w	r9,r9[0x0]
80003ab8:	8e 7b       	ld.sh	r11,r7[0xe]
80003aba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003abe:	70 09       	ld.w	r9,r8[0x0]
80003ac0:	2f f9       	sub	r9,-1
80003ac2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ac4:	e0 49 00 ff 	cp.w	r9,255
80003ac8:	e0 88 00 11 	brls	80003aea <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003acc:	30 09       	mov	r9,0
80003ace:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003ad0:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003ad4:	6e 0c       	ld.w	r12,r7[0x0]
80003ad6:	f0 1f 02 7d 	mcall	800044c8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003ada:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003ade:	70 0c       	ld.w	r12,r8[0x0]
80003ae0:	f0 1f 02 67 	mcall	8000447c <phy_rx_func+0xe98>
80003ae4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003ae6:	e0 80 04 bc 	breq	8000445e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003aea:	30 29       	mov	r9,2
80003aec:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003af0:	91 09       	st.w	r8[0x0],r9
80003af2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003af6:	8e 79       	ld.sh	r9,r7[0xe]
80003af8:	30 38       	mov	r8,3
80003afa:	f0 09 19 00 	cp.h	r9,r8
80003afe:	c0 51       	brne	80003b08 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003b00:	30 19       	mov	r9,1
80003b02:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003b06:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003b08:	30 29       	mov	r9,2
80003b0a:	fe f8 09 96 	ld.w	r8,pc[2454]
80003b0e:	91 09       	st.w	r8[0x0],r9
80003b10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003b14:	58 18       	cp.w	r8,1
80003b16:	e0 88 04 a4 	brls	8000445e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003b1a:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003b1e:	70 0a       	ld.w	r10,r8[0x0]
80003b20:	6e 3b       	ld.w	r11,r7[0xc]
80003b22:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003b26:	70 09       	ld.w	r9,r8[0x0]
80003b28:	2f f9       	sub	r9,-1
80003b2a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b2c:	e0 49 00 ff 	cp.w	r9,255
80003b30:	e0 88 00 11 	brls	80003b52 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003b34:	30 09       	mov	r9,0
80003b36:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003b38:	fe f7 09 60 	ld.w	r7,pc[2400]
80003b3c:	6e 0c       	ld.w	r12,r7[0x0]
80003b3e:	f0 1f 02 63 	mcall	800044c8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003b42:	fe f8 09 52 	ld.w	r8,pc[2386]
80003b46:	70 0c       	ld.w	r12,r8[0x0]
80003b48:	f0 1f 02 4d 	mcall	8000447c <phy_rx_func+0xe98>
80003b4c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003b4e:	e0 80 04 88 	breq	8000445e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003b52:	fe f9 09 56 	ld.w	r9,pc[2390]
80003b56:	72 08       	ld.w	r8,r9[0x0]
80003b58:	20 28       	sub	r8,2
80003b5a:	93 08       	st.w	r9[0x0],r8
80003b5c:	e0 80 04 81 	breq	8000445e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003b60:	30 29       	mov	r9,2
80003b62:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003b66:	91 09       	st.w	r8[0x0],r9
80003b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003b6c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003b70:	70 0a       	ld.w	r10,r8[0x0]
80003b72:	fe f9 09 26 	ld.w	r9,pc[2342]
80003b76:	72 09       	ld.w	r9,r9[0x0]
80003b78:	8e 4b       	ld.sh	r11,r7[0x8]
80003b7a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003b7e:	70 09       	ld.w	r9,r8[0x0]
80003b80:	2f f9       	sub	r9,-1
80003b82:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b84:	e0 49 00 ff 	cp.w	r9,255
80003b88:	e0 88 00 16 	brls	80003bb4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003b8c:	30 09       	mov	r9,0
80003b8e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003b90:	fe f6 09 08 	ld.w	r6,pc[2312]
80003b94:	6c 0c       	ld.w	r12,r6[0x0]
80003b96:	f0 1f 02 4d 	mcall	800044c8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003b9a:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003b9e:	70 0c       	ld.w	r12,r8[0x0]
80003ba0:	f0 1f 02 37 	mcall	8000447c <phy_rx_func+0xe98>
80003ba4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003ba6:	c0 71       	brne	80003bb4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003ba8:	30 09       	mov	r9,0
80003baa:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003bae:	91 09       	st.w	r8[0x0],r9
80003bb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003bb4:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003bb8:	72 08       	ld.w	r8,r9[0x0]
80003bba:	20 28       	sub	r8,2
80003bbc:	93 08       	st.w	r9[0x0],r8
80003bbe:	c0 71       	brne	80003bcc <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003bc0:	30 09       	mov	r9,0
80003bc2:	fe f8 08 de 	ld.w	r8,pc[2270]
80003bc6:	91 09       	st.w	r8[0x0],r9
80003bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003bcc:	fe f8 09 24 	ld.w	r8,pc[2340]
80003bd0:	70 0a       	ld.w	r10,r8[0x0]
80003bd2:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003bd6:	72 09       	ld.w	r9,r9[0x0]
80003bd8:	8e 5b       	ld.sh	r11,r7[0xa]
80003bda:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003bde:	70 09       	ld.w	r9,r8[0x0]
80003be0:	2f f9       	sub	r9,-1
80003be2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003be4:	e0 49 00 ff 	cp.w	r9,255
80003be8:	e0 88 00 16 	brls	80003c14 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003bec:	30 09       	mov	r9,0
80003bee:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003bf0:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003bf4:	6c 0c       	ld.w	r12,r6[0x0]
80003bf6:	f0 1f 02 35 	mcall	800044c8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003bfa:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003bfe:	70 0c       	ld.w	r12,r8[0x0]
80003c00:	f0 1f 02 1f 	mcall	8000447c <phy_rx_func+0xe98>
80003c04:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003c06:	c0 71       	brne	80003c14 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003c08:	30 09       	mov	r9,0
80003c0a:	fe f8 08 96 	ld.w	r8,pc[2198]
80003c0e:	91 09       	st.w	r8[0x0],r9
80003c10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003c14:	fe f9 08 94 	ld.w	r9,pc[2196]
80003c18:	72 08       	ld.w	r8,r9[0x0]
80003c1a:	20 28       	sub	r8,2
80003c1c:	93 08       	st.w	r9[0x0],r8
80003c1e:	c0 71       	brne	80003c2c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003c20:	30 09       	mov	r9,0
80003c22:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003c26:	91 09       	st.w	r8[0x0],r9
80003c28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003c2c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003c30:	70 0a       	ld.w	r10,r8[0x0]
80003c32:	fe f9 08 66 	ld.w	r9,pc[2150]
80003c36:	72 09       	ld.w	r9,r9[0x0]
80003c38:	8e 6b       	ld.sh	r11,r7[0xc]
80003c3a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c3e:	70 09       	ld.w	r9,r8[0x0]
80003c40:	2f f9       	sub	r9,-1
80003c42:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c44:	e0 49 00 ff 	cp.w	r9,255
80003c48:	e0 88 00 16 	brls	80003c74 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003c4c:	30 09       	mov	r9,0
80003c4e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c50:	fe f6 08 48 	ld.w	r6,pc[2120]
80003c54:	6c 0c       	ld.w	r12,r6[0x0]
80003c56:	f0 1f 02 1d 	mcall	800044c8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c5a:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003c5e:	70 0c       	ld.w	r12,r8[0x0]
80003c60:	f0 1f 02 07 	mcall	8000447c <phy_rx_func+0xe98>
80003c64:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003c66:	c0 71       	brne	80003c74 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003c68:	30 09       	mov	r9,0
80003c6a:	fe f8 08 36 	ld.w	r8,pc[2102]
80003c6e:	91 09       	st.w	r8[0x0],r9
80003c70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003c74:	fe f9 08 34 	ld.w	r9,pc[2100]
80003c78:	72 08       	ld.w	r8,r9[0x0]
80003c7a:	20 28       	sub	r8,2
80003c7c:	93 08       	st.w	r9[0x0],r8
80003c7e:	c0 71       	brne	80003c8c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003c80:	30 09       	mov	r9,0
80003c82:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003c86:	91 09       	st.w	r8[0x0],r9
80003c88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c8c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003c90:	70 0a       	ld.w	r10,r8[0x0]
80003c92:	fe f9 08 06 	ld.w	r9,pc[2054]
80003c96:	72 09       	ld.w	r9,r9[0x0]
80003c98:	8e 7b       	ld.sh	r11,r7[0xe]
80003c9a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c9e:	70 09       	ld.w	r9,r8[0x0]
80003ca0:	2f f9       	sub	r9,-1
80003ca2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ca4:	e0 49 00 ff 	cp.w	r9,255
80003ca8:	e0 88 00 16 	brls	80003cd4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003cac:	30 09       	mov	r9,0
80003cae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cb0:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003cb4:	6e 0c       	ld.w	r12,r7[0x0]
80003cb6:	f0 1f 02 05 	mcall	800044c8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003cba:	fe f8 07 da 	ld.w	r8,pc[2010]
80003cbe:	70 0c       	ld.w	r12,r8[0x0]
80003cc0:	f0 1f 01 ef 	mcall	8000447c <phy_rx_func+0xe98>
80003cc4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003cc6:	c0 71       	brne	80003cd4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003cc8:	30 09       	mov	r9,0
80003cca:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003cce:	91 09       	st.w	r8[0x0],r9
80003cd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003cd4:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003cd8:	72 08       	ld.w	r8,r9[0x0]
80003cda:	20 28       	sub	r8,2
80003cdc:	93 08       	st.w	r9[0x0],r8
80003cde:	e0 81 03 c0 	brne	8000445e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003ce2:	30 09       	mov	r9,0
80003ce4:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003ce8:	91 09       	st.w	r8[0x0],r9
80003cea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003cee:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003cf2:	11 89       	ld.ub	r9,r8[0x0]
80003cf4:	31 28       	mov	r8,18
80003cf6:	f0 09 18 00 	cp.b	r9,r8
80003cfa:	e0 81 01 4c 	brne	80003f92 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003cfe:	ef 39 00 09 	ld.ub	r9,r7[9]
80003d02:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003d06:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003d08:	11 89       	ld.ub	r9,r8[0x0]
80003d0a:	3f 28       	mov	r8,-14
80003d0c:	f0 09 18 00 	cp.b	r9,r8
80003d10:	e0 81 01 3b 	brne	80003f86 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003d14:	30 19       	mov	r9,1
80003d16:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003d1a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003d1c:	6e 29       	ld.w	r9,r7[0x8]
80003d1e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003d22:	fe f8 07 86 	ld.w	r8,pc[1926]
80003d26:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003d28:	8e 59       	ld.sh	r9,r7[0xa]
80003d2a:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003d2e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003d30:	8e 69       	ld.sh	r9,r7[0xc]
80003d32:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003d34:	8e 79       	ld.sh	r9,r7[0xe]
80003d36:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003d38:	fe f8 07 88 	ld.w	r8,pc[1928]
80003d3c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003d40:	72 0a       	ld.w	r10,r9[0x0]
80003d42:	70 09       	ld.w	r9,r8[0x0]
80003d44:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003d48:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d4c:	70 09       	ld.w	r9,r8[0x0]
80003d4e:	2f f9       	sub	r9,-1
80003d50:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d52:	e0 49 01 ff 	cp.w	r9,511
80003d56:	e0 88 00 16 	brls	80003d82 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d5a:	30 09       	mov	r9,0
80003d5c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d5e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003d62:	6c 0c       	ld.w	r12,r6[0x0]
80003d64:	f0 1f 01 d9 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d68:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003d6c:	70 0c       	ld.w	r12,r8[0x0]
80003d6e:	f0 1f 01 c4 	mcall	8000447c <phy_rx_func+0xe98>
80003d72:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d74:	c0 71       	brne	80003d82 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003d76:	30 09       	mov	r9,0
80003d78:	fe f8 07 28 	ld.w	r8,pc[1832]
80003d7c:	91 09       	st.w	r8[0x0],r9
80003d7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d82:	fe f9 07 26 	ld.w	r9,pc[1830]
80003d86:	72 08       	ld.w	r8,r9[0x0]
80003d88:	20 18       	sub	r8,1
80003d8a:	93 08       	st.w	r9[0x0],r8
80003d8c:	c0 71       	brne	80003d9a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003d8e:	30 09       	mov	r9,0
80003d90:	fe f8 07 10 	ld.w	r8,pc[1808]
80003d94:	91 09       	st.w	r8[0x0],r9
80003d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003d9a:	fe f8 07 26 	ld.w	r8,pc[1830]
80003d9e:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003da2:	72 0a       	ld.w	r10,r9[0x0]
80003da4:	70 09       	ld.w	r9,r8[0x0]
80003da6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003daa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003dae:	70 09       	ld.w	r9,r8[0x0]
80003db0:	2f f9       	sub	r9,-1
80003db2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003db4:	e0 49 01 ff 	cp.w	r9,511
80003db8:	e0 88 00 16 	brls	80003de4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003dbc:	30 09       	mov	r9,0
80003dbe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003dc0:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003dc4:	6c 0c       	ld.w	r12,r6[0x0]
80003dc6:	f0 1f 01 c1 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003dca:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003dce:	70 0c       	ld.w	r12,r8[0x0]
80003dd0:	f0 1f 01 ab 	mcall	8000447c <phy_rx_func+0xe98>
80003dd4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003dd6:	c0 71       	brne	80003de4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003dd8:	30 09       	mov	r9,0
80003dda:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003dde:	91 09       	st.w	r8[0x0],r9
80003de0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003de4:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003de8:	72 08       	ld.w	r8,r9[0x0]
80003dea:	20 18       	sub	r8,1
80003dec:	93 08       	st.w	r9[0x0],r8
80003dee:	c0 71       	brne	80003dfc <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003df0:	30 09       	mov	r9,0
80003df2:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003df6:	91 09       	st.w	r8[0x0],r9
80003df8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003dfc:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003e00:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003e04:	72 0a       	ld.w	r10,r9[0x0]
80003e06:	70 09       	ld.w	r9,r8[0x0]
80003e08:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003e0c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e10:	70 09       	ld.w	r9,r8[0x0]
80003e12:	2f f9       	sub	r9,-1
80003e14:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e16:	e0 49 01 ff 	cp.w	r9,511
80003e1a:	e0 88 00 16 	brls	80003e46 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003e1e:	30 09       	mov	r9,0
80003e20:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e22:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003e26:	6c 0c       	ld.w	r12,r6[0x0]
80003e28:	f0 1f 01 a8 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e2c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003e30:	70 0c       	ld.w	r12,r8[0x0]
80003e32:	f0 1f 01 93 	mcall	8000447c <phy_rx_func+0xe98>
80003e36:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003e38:	c0 71       	brne	80003e46 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003e3a:	30 09       	mov	r9,0
80003e3c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003e40:	91 09       	st.w	r8[0x0],r9
80003e42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003e46:	fe f9 06 62 	ld.w	r9,pc[1634]
80003e4a:	72 08       	ld.w	r8,r9[0x0]
80003e4c:	20 18       	sub	r8,1
80003e4e:	93 08       	st.w	r9[0x0],r8
80003e50:	c0 71       	brne	80003e5e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003e52:	30 09       	mov	r9,0
80003e54:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003e58:	91 09       	st.w	r8[0x0],r9
80003e5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003e5e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003e62:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003e66:	72 0a       	ld.w	r10,r9[0x0]
80003e68:	70 09       	ld.w	r9,r8[0x0]
80003e6a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003e6e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e72:	70 09       	ld.w	r9,r8[0x0]
80003e74:	2f f9       	sub	r9,-1
80003e76:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e78:	e0 49 01 ff 	cp.w	r9,511
80003e7c:	e0 88 00 16 	brls	80003ea8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003e80:	30 09       	mov	r9,0
80003e82:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e84:	fe f6 06 18 	ld.w	r6,pc[1560]
80003e88:	6c 0c       	ld.w	r12,r6[0x0]
80003e8a:	f0 1f 01 90 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e8e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003e92:	70 0c       	ld.w	r12,r8[0x0]
80003e94:	f0 1f 01 7a 	mcall	8000447c <phy_rx_func+0xe98>
80003e98:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003e9a:	c0 71       	brne	80003ea8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003e9c:	30 09       	mov	r9,0
80003e9e:	fe f8 06 02 	ld.w	r8,pc[1538]
80003ea2:	91 09       	st.w	r8[0x0],r9
80003ea4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ea8:	fe f9 06 00 	ld.w	r9,pc[1536]
80003eac:	72 08       	ld.w	r8,r9[0x0]
80003eae:	20 18       	sub	r8,1
80003eb0:	93 08       	st.w	r9[0x0],r8
80003eb2:	c0 71       	brne	80003ec0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003eb4:	30 09       	mov	r9,0
80003eb6:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003eba:	91 09       	st.w	r8[0x0],r9
80003ebc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003ec0:	fe f8 06 00 	ld.w	r8,pc[1536]
80003ec4:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003ec8:	72 0a       	ld.w	r10,r9[0x0]
80003eca:	70 09       	ld.w	r9,r8[0x0]
80003ecc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ed0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ed4:	70 09       	ld.w	r9,r8[0x0]
80003ed6:	2f f9       	sub	r9,-1
80003ed8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eda:	e0 49 01 ff 	cp.w	r9,511
80003ede:	e0 88 00 16 	brls	80003f0a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ee2:	30 09       	mov	r9,0
80003ee4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ee6:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003eea:	6c 0c       	ld.w	r12,r6[0x0]
80003eec:	f0 1f 01 77 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ef0:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003ef4:	70 0c       	ld.w	r12,r8[0x0]
80003ef6:	f0 1f 01 62 	mcall	8000447c <phy_rx_func+0xe98>
80003efa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003efc:	c0 71       	brne	80003f0a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003efe:	30 09       	mov	r9,0
80003f00:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003f04:	91 09       	st.w	r8[0x0],r9
80003f06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f0a:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003f0e:	72 08       	ld.w	r8,r9[0x0]
80003f10:	20 18       	sub	r8,1
80003f12:	93 08       	st.w	r9[0x0],r8
80003f14:	c0 71       	brne	80003f22 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003f16:	30 09       	mov	r9,0
80003f18:	fe f8 05 88 	ld.w	r8,pc[1416]
80003f1c:	91 09       	st.w	r8[0x0],r9
80003f1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003f22:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003f26:	fe f9 05 76 	ld.w	r9,pc[1398]
80003f2a:	72 0a       	ld.w	r10,r9[0x0]
80003f2c:	70 09       	ld.w	r9,r8[0x0]
80003f2e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003f32:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f36:	70 09       	ld.w	r9,r8[0x0]
80003f38:	2f f9       	sub	r9,-1
80003f3a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f3c:	e0 49 01 ff 	cp.w	r9,511
80003f40:	e0 88 00 16 	brls	80003f6c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f44:	30 09       	mov	r9,0
80003f46:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f48:	fe f7 05 54 	ld.w	r7,pc[1364]
80003f4c:	6e 0c       	ld.w	r12,r7[0x0]
80003f4e:	f0 1f 01 5f 	mcall	800044c8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f52:	fe f8 05 42 	ld.w	r8,pc[1346]
80003f56:	70 0c       	ld.w	r12,r8[0x0]
80003f58:	f0 1f 01 49 	mcall	8000447c <phy_rx_func+0xe98>
80003f5c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f5e:	c0 71       	brne	80003f6c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003f60:	30 09       	mov	r9,0
80003f62:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003f66:	91 09       	st.w	r8[0x0],r9
80003f68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f6c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003f70:	72 08       	ld.w	r8,r9[0x0]
80003f72:	20 18       	sub	r8,1
80003f74:	93 08       	st.w	r9[0x0],r8
80003f76:	e0 81 02 74 	brne	8000445e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003f7a:	30 09       	mov	r9,0
80003f7c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003f80:	91 09       	st.w	r8[0x0],r9
80003f82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003f86:	30 09       	mov	r9,0
80003f88:	fe f8 05 18 	ld.w	r8,pc[1304]
80003f8c:	91 09       	st.w	r8[0x0],r9
80003f8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003f92:	fe f8 05 26 	ld.w	r8,pc[1318]
80003f96:	11 89       	ld.ub	r9,r8[0x0]
80003f98:	3f 28       	mov	r8,-14
80003f9a:	f0 09 18 00 	cp.b	r9,r8
80003f9e:	c4 31       	brne	80004024 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003fa0:	8e 49       	ld.sh	r9,r7[0x8]
80003fa2:	fe f8 05 56 	ld.w	r8,pc[1366]
80003fa6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003fa8:	fe f8 05 18 	ld.w	r8,pc[1304]
80003fac:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003fb0:	72 0a       	ld.w	r10,r9[0x0]
80003fb2:	70 09       	ld.w	r9,r8[0x0]
80003fb4:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003fb8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fbc:	70 09       	ld.w	r9,r8[0x0]
80003fbe:	2f f9       	sub	r9,-1
80003fc0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fc2:	e0 49 01 ff 	cp.w	r9,511
80003fc6:	e0 88 00 16 	brls	80003ff2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fca:	30 09       	mov	r9,0
80003fcc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fce:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003fd2:	6e 0c       	ld.w	r12,r7[0x0]
80003fd4:	f0 1f 01 3d 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fd8:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003fdc:	70 0c       	ld.w	r12,r8[0x0]
80003fde:	f0 1f 01 28 	mcall	8000447c <phy_rx_func+0xe98>
80003fe2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fe4:	c0 71       	brne	80003ff2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003fe6:	30 09       	mov	r9,0
80003fe8:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003fec:	91 09       	st.w	r8[0x0],r9
80003fee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ff2:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003ff6:	72 08       	ld.w	r8,r9[0x0]
80003ff8:	20 18       	sub	r8,1
80003ffa:	93 08       	st.w	r9[0x0],r8
80003ffc:	c0 71       	brne	8000400a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003ffe:	30 09       	mov	r9,0
80004000:	fe f8 04 a0 	ld.w	r8,pc[1184]
80004004:	91 09       	st.w	r8[0x0],r9
80004006:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000400a:	20 18       	sub	r8,1
8000400c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80004010:	93 08       	st.w	r9[0x0],r8
80004012:	58 08       	cp.w	r8,0
80004014:	e0 81 02 25 	brne	8000445e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80004018:	30 09       	mov	r9,0
8000401a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000401e:	91 09       	st.w	r8[0x0],r9
80004020:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80004024:	fe f8 04 94 	ld.w	r8,pc[1172]
80004028:	11 89       	ld.ub	r9,r8[0x0]
8000402a:	3f 38       	mov	r8,-13
8000402c:	f0 09 18 00 	cp.b	r9,r8
80004030:	e0 81 01 0c 	brne	80004248 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004034:	8e 49       	ld.sh	r9,r7[0x8]
80004036:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000403a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000403c:	8e 59       	ld.sh	r9,r7[0xa]
8000403e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80004040:	8e 69       	ld.sh	r9,r7[0xc]
80004042:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80004044:	fe f8 04 7c 	ld.w	r8,pc[1148]
80004048:	fe f9 04 54 	ld.w	r9,pc[1108]
8000404c:	72 0a       	ld.w	r10,r9[0x0]
8000404e:	70 09       	ld.w	r9,r8[0x0]
80004050:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004054:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004058:	70 09       	ld.w	r9,r8[0x0]
8000405a:	2f f9       	sub	r9,-1
8000405c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000405e:	e0 49 01 ff 	cp.w	r9,511
80004062:	e0 88 00 16 	brls	8000408e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80004066:	30 09       	mov	r9,0
80004068:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000406a:	fe f6 04 32 	ld.w	r6,pc[1074]
8000406e:	6c 0c       	ld.w	r12,r6[0x0]
80004070:	f0 1f 01 16 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004074:	fe f8 04 20 	ld.w	r8,pc[1056]
80004078:	70 0c       	ld.w	r12,r8[0x0]
8000407a:	f0 1f 01 01 	mcall	8000447c <phy_rx_func+0xe98>
8000407e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004080:	c0 71       	brne	8000408e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80004082:	30 09       	mov	r9,0
80004084:	fe f8 04 1c 	ld.w	r8,pc[1052]
80004088:	91 09       	st.w	r8[0x0],r9
8000408a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000408e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80004092:	72 08       	ld.w	r8,r9[0x0]
80004094:	20 18       	sub	r8,1
80004096:	93 08       	st.w	r9[0x0],r8
80004098:	c0 71       	brne	800040a6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000409a:	30 09       	mov	r9,0
8000409c:	fe f8 04 04 	ld.w	r8,pc[1028]
800040a0:	91 09       	st.w	r8[0x0],r9
800040a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800040a6:	fe f8 04 1a 	ld.w	r8,pc[1050]
800040aa:	fe f9 03 f2 	ld.w	r9,pc[1010]
800040ae:	72 0a       	ld.w	r10,r9[0x0]
800040b0:	70 09       	ld.w	r9,r8[0x0]
800040b2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800040b6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800040ba:	70 09       	ld.w	r9,r8[0x0]
800040bc:	2f f9       	sub	r9,-1
800040be:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040c0:	e0 49 01 ff 	cp.w	r9,511
800040c4:	e0 88 00 16 	brls	800040f0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800040c8:	30 09       	mov	r9,0
800040ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800040cc:	fe f6 03 d0 	ld.w	r6,pc[976]
800040d0:	6c 0c       	ld.w	r12,r6[0x0]
800040d2:	f0 1f 00 fe 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800040d6:	fe f8 03 be 	ld.w	r8,pc[958]
800040da:	70 0c       	ld.w	r12,r8[0x0]
800040dc:	f0 1f 00 e8 	mcall	8000447c <phy_rx_func+0xe98>
800040e0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800040e2:	c0 71       	brne	800040f0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800040e4:	30 09       	mov	r9,0
800040e6:	fe f8 03 ba 	ld.w	r8,pc[954]
800040ea:	91 09       	st.w	r8[0x0],r9
800040ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800040f0:	fe f9 03 b8 	ld.w	r9,pc[952]
800040f4:	72 08       	ld.w	r8,r9[0x0]
800040f6:	20 18       	sub	r8,1
800040f8:	93 08       	st.w	r9[0x0],r8
800040fa:	c0 71       	brne	80004108 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800040fc:	30 09       	mov	r9,0
800040fe:	fe f8 03 a2 	ld.w	r8,pc[930]
80004102:	91 09       	st.w	r8[0x0],r9
80004104:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80004108:	fe f8 03 b8 	ld.w	r8,pc[952]
8000410c:	fe f9 03 90 	ld.w	r9,pc[912]
80004110:	72 0a       	ld.w	r10,r9[0x0]
80004112:	70 09       	ld.w	r9,r8[0x0]
80004114:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004118:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000411c:	70 09       	ld.w	r9,r8[0x0]
8000411e:	2f f9       	sub	r9,-1
80004120:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004122:	e0 49 01 ff 	cp.w	r9,511
80004126:	e0 88 00 16 	brls	80004152 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000412a:	30 09       	mov	r9,0
8000412c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000412e:	fe f6 03 6e 	ld.w	r6,pc[878]
80004132:	6c 0c       	ld.w	r12,r6[0x0]
80004134:	f0 1f 00 e5 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004138:	fe f8 03 5c 	ld.w	r8,pc[860]
8000413c:	70 0c       	ld.w	r12,r8[0x0]
8000413e:	f0 1f 00 d0 	mcall	8000447c <phy_rx_func+0xe98>
80004142:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004144:	c0 71       	brne	80004152 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80004146:	30 09       	mov	r9,0
80004148:	fe f8 03 58 	ld.w	r8,pc[856]
8000414c:	91 09       	st.w	r8[0x0],r9
8000414e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004152:	fe f9 03 56 	ld.w	r9,pc[854]
80004156:	72 08       	ld.w	r8,r9[0x0]
80004158:	20 18       	sub	r8,1
8000415a:	93 08       	st.w	r9[0x0],r8
8000415c:	c0 71       	brne	8000416a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000415e:	30 09       	mov	r9,0
80004160:	fe f8 03 40 	ld.w	r8,pc[832]
80004164:	91 09       	st.w	r8[0x0],r9
80004166:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000416a:	fe f8 03 56 	ld.w	r8,pc[854]
8000416e:	fe f9 03 2e 	ld.w	r9,pc[814]
80004172:	72 0a       	ld.w	r10,r9[0x0]
80004174:	70 09       	ld.w	r9,r8[0x0]
80004176:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000417a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000417e:	70 09       	ld.w	r9,r8[0x0]
80004180:	2f f9       	sub	r9,-1
80004182:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004184:	e0 49 01 ff 	cp.w	r9,511
80004188:	e0 88 00 16 	brls	800041b4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
8000418c:	30 09       	mov	r9,0
8000418e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004190:	fe f6 03 0c 	ld.w	r6,pc[780]
80004194:	6c 0c       	ld.w	r12,r6[0x0]
80004196:	f0 1f 00 cd 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000419a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000419e:	70 0c       	ld.w	r12,r8[0x0]
800041a0:	f0 1f 00 b7 	mcall	8000447c <phy_rx_func+0xe98>
800041a4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041a6:	c0 71       	brne	800041b4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800041a8:	30 09       	mov	r9,0
800041aa:	fe f8 02 f6 	ld.w	r8,pc[758]
800041ae:	91 09       	st.w	r8[0x0],r9
800041b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041b4:	fe f9 02 f4 	ld.w	r9,pc[756]
800041b8:	72 08       	ld.w	r8,r9[0x0]
800041ba:	20 18       	sub	r8,1
800041bc:	93 08       	st.w	r9[0x0],r8
800041be:	c0 71       	brne	800041cc <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800041c0:	30 09       	mov	r9,0
800041c2:	fe f8 02 de 	ld.w	r8,pc[734]
800041c6:	91 09       	st.w	r8[0x0],r9
800041c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800041cc:	fe f8 02 f4 	ld.w	r8,pc[756]
800041d0:	fe f9 02 cc 	ld.w	r9,pc[716]
800041d4:	72 0a       	ld.w	r10,r9[0x0]
800041d6:	70 09       	ld.w	r9,r8[0x0]
800041d8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800041dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041e0:	70 09       	ld.w	r9,r8[0x0]
800041e2:	2f f9       	sub	r9,-1
800041e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041e6:	e0 49 01 ff 	cp.w	r9,511
800041ea:	e0 88 00 16 	brls	80004216 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800041ee:	30 09       	mov	r9,0
800041f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041f2:	fe f7 02 aa 	ld.w	r7,pc[682]
800041f6:	6e 0c       	ld.w	r12,r7[0x0]
800041f8:	f0 1f 00 b4 	mcall	800044c8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041fc:	fe f8 02 98 	ld.w	r8,pc[664]
80004200:	70 0c       	ld.w	r12,r8[0x0]
80004202:	f0 1f 00 9f 	mcall	8000447c <phy_rx_func+0xe98>
80004206:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004208:	c0 71       	brne	80004216 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000420a:	30 09       	mov	r9,0
8000420c:	fe f8 02 94 	ld.w	r8,pc[660]
80004210:	91 09       	st.w	r8[0x0],r9
80004212:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004216:	fe f9 02 92 	ld.w	r9,pc[658]
8000421a:	72 08       	ld.w	r8,r9[0x0]
8000421c:	20 18       	sub	r8,1
8000421e:	93 08       	st.w	r9[0x0],r8
80004220:	c0 71       	brne	8000422e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80004222:	30 09       	mov	r9,0
80004224:	fe f8 02 7c 	ld.w	r8,pc[636]
80004228:	91 09       	st.w	r8[0x0],r9
8000422a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000422e:	20 18       	sub	r8,1
80004230:	fe f9 02 78 	ld.w	r9,pc[632]
80004234:	93 08       	st.w	r9[0x0],r8
80004236:	58 08       	cp.w	r8,0
80004238:	e0 81 01 13 	brne	8000445e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000423c:	30 09       	mov	r9,0
8000423e:	fe f8 02 62 	ld.w	r8,pc[610]
80004242:	91 09       	st.w	r8[0x0],r9
80004244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004248:	fe f8 02 70 	ld.w	r8,pc[624]
8000424c:	11 89       	ld.ub	r9,r8[0x0]
8000424e:	30 48       	mov	r8,4
80004250:	f0 09 18 00 	cp.b	r9,r8
80004254:	c0 80       	breq	80004264 <phy_rx_func+0xc80>
80004256:	fe f8 02 62 	ld.w	r8,pc[610]
8000425a:	11 89       	ld.ub	r9,r8[0x0]
8000425c:	30 38       	mov	r8,3
8000425e:	f0 09 18 00 	cp.b	r9,r8
80004262:	c1 41       	brne	8000428a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004264:	6e 29       	ld.w	r9,r7[0x8]
80004266:	fe f8 02 7a 	ld.w	r8,pc[634]
8000426a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000426c:	6e 39       	ld.w	r9,r7[0xc]
8000426e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004270:	fe f9 02 38 	ld.w	r9,pc[568]
80004274:	72 08       	ld.w	r8,r9[0x0]
80004276:	20 88       	sub	r8,8
80004278:	93 08       	st.w	r9[0x0],r8
8000427a:	e0 81 00 f2 	brne	8000445e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
8000427e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004280:	fe f9 02 20 	ld.w	r9,pc[544]
80004284:	93 08       	st.w	r9[0x0],r8
80004286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000428a:	fe f8 02 2e 	ld.w	r8,pc[558]
8000428e:	11 89       	ld.ub	r9,r8[0x0]
80004290:	31 38       	mov	r8,19
80004292:	f0 09 18 00 	cp.b	r9,r8
80004296:	e0 81 00 9c 	brne	800043ce <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000429a:	fe f8 02 62 	ld.w	r8,pc[610]
8000429e:	11 88       	ld.ub	r8,r8[0x0]
800042a0:	30 c9       	mov	r9,12
800042a2:	f2 08 18 00 	cp.b	r8,r9
800042a6:	e0 81 00 7b 	brne	8000439c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800042aa:	8e 49       	ld.sh	r9,r7[0x8]
800042ac:	fe f8 02 54 	ld.w	r8,pc[596]
800042b0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800042b4:	30 09       	mov	r9,0
800042b6:	fe f8 02 46 	ld.w	r8,pc[582]
800042ba:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800042bc:	ef 39 00 0d 	ld.ub	r9,r7[13]
800042c0:	3f 38       	mov	r8,-13
800042c2:	f0 09 18 00 	cp.b	r9,r8
800042c6:	c6 61       	brne	80004392 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800042c8:	10 99       	mov	r9,r8
800042ca:	4f c8       	lddpc	r8,800044b8 <phy_rx_func+0xed4>
800042cc:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800042ce:	ef 39 00 0c 	ld.ub	r9,r7[12]
800042d2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800042d6:	4f 58       	lddpc	r8,800044a8 <phy_rx_func+0xec4>
800042d8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800042da:	30 19       	mov	r9,1
800042dc:	fe f8 02 0c 	ld.w	r8,pc[524]
800042e0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800042e2:	8e 79       	ld.sh	r9,r7[0xe]
800042e4:	fe f8 02 14 	ld.w	r8,pc[532]
800042e8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800042ea:	4f 68       	lddpc	r8,800044c0 <phy_rx_func+0xedc>
800042ec:	4e c9       	lddpc	r9,8000449c <phy_rx_func+0xeb8>
800042ee:	72 0a       	ld.w	r10,r9[0x0]
800042f0:	70 09       	ld.w	r9,r8[0x0]
800042f2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800042f6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800042fa:	70 09       	ld.w	r9,r8[0x0]
800042fc:	2f f9       	sub	r9,-1
800042fe:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004300:	e0 49 01 ff 	cp.w	r9,511
80004304:	e0 88 00 13 	brls	8000432a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80004308:	30 09       	mov	r9,0
8000430a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000430c:	4e 46       	lddpc	r6,8000449c <phy_rx_func+0xeb8>
8000430e:	6c 0c       	ld.w	r12,r6[0x0]
80004310:	f0 1f 00 6e 	mcall	800044c8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004314:	4e 08       	lddpc	r8,80004494 <phy_rx_func+0xeb0>
80004316:	70 0c       	ld.w	r12,r8[0x0]
80004318:	f0 1f 00 59 	mcall	8000447c <phy_rx_func+0xe98>
8000431c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000431e:	c0 61       	brne	8000432a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80004320:	30 09       	mov	r9,0
80004322:	4e 08       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
80004324:	91 09       	st.w	r8[0x0],r9
80004326:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000432a:	4e 09       	lddpc	r9,800044a8 <phy_rx_func+0xec4>
8000432c:	72 08       	ld.w	r8,r9[0x0]
8000432e:	20 18       	sub	r8,1
80004330:	93 08       	st.w	r9[0x0],r8
80004332:	c0 61       	brne	8000433e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004334:	30 09       	mov	r9,0
80004336:	4d b8       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
80004338:	91 09       	st.w	r8[0x0],r9
8000433a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000433e:	4e 18       	lddpc	r8,800044c0 <phy_rx_func+0xedc>
80004340:	4d 79       	lddpc	r9,8000449c <phy_rx_func+0xeb8>
80004342:	72 0a       	ld.w	r10,r9[0x0]
80004344:	70 09       	ld.w	r9,r8[0x0]
80004346:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000434a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000434e:	70 09       	ld.w	r9,r8[0x0]
80004350:	2f f9       	sub	r9,-1
80004352:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004354:	e0 49 01 ff 	cp.w	r9,511
80004358:	e0 88 00 13 	brls	8000437e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000435c:	30 09       	mov	r9,0
8000435e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004360:	4c f7       	lddpc	r7,8000449c <phy_rx_func+0xeb8>
80004362:	6e 0c       	ld.w	r12,r7[0x0]
80004364:	f0 1f 00 59 	mcall	800044c8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004368:	4c b8       	lddpc	r8,80004494 <phy_rx_func+0xeb0>
8000436a:	70 0c       	ld.w	r12,r8[0x0]
8000436c:	f0 1f 00 44 	mcall	8000447c <phy_rx_func+0xe98>
80004370:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004372:	c0 61       	brne	8000437e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80004374:	30 09       	mov	r9,0
80004376:	4c b8       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
80004378:	91 09       	st.w	r8[0x0],r9
8000437a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000437e:	4c b9       	lddpc	r9,800044a8 <phy_rx_func+0xec4>
80004380:	72 08       	ld.w	r8,r9[0x0]
80004382:	20 18       	sub	r8,1
80004384:	93 08       	st.w	r9[0x0],r8
80004386:	c6 c1       	brne	8000445e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80004388:	30 09       	mov	r9,0
8000438a:	4c 68       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
8000438c:	91 09       	st.w	r8[0x0],r9
8000438e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004392:	30 09       	mov	r9,0
80004394:	4c 38       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
80004396:	91 09       	st.w	r8[0x0],r9
80004398:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
8000439c:	8e 4a       	ld.sh	r10,r7[0x8]
8000439e:	4d 99       	lddpc	r9,80004500 <phy_rx_func+0xf1c>
800043a0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800043a4:	4d 6a       	lddpc	r10,800044fc <phy_rx_func+0xf18>
800043a6:	15 88       	ld.ub	r8,r10[0x0]
800043a8:	f0 cb ff ff 	sub	r11,r8,-1
800043ac:	8e 5c       	ld.sh	r12,r7[0xa]
800043ae:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800043b2:	f0 cb ff fe 	sub	r11,r8,-2
800043b6:	8e 6c       	ld.sh	r12,r7[0xc]
800043b8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800043bc:	f0 cb ff fd 	sub	r11,r8,-3
800043c0:	8e 7c       	ld.sh	r12,r7[0xe]
800043c2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800043c6:	2f c8       	sub	r8,-4
800043c8:	b4 88       	st.b	r10[0x0],r8
800043ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800043ce:	30 09       	mov	r9,0
800043d0:	4b 48       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
800043d2:	91 09       	st.w	r8[0x0],r9
800043d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800043d8:	4c 08       	lddpc	r8,800044d8 <phy_rx_func+0xef4>
800043da:	70 09       	ld.w	r9,r8[0x0]
800043dc:	8e 4b       	ld.sh	r11,r7[0x8]
800043de:	4c 0a       	lddpc	r10,800044dc <phy_rx_func+0xef8>
800043e0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800043e4:	2f f9       	sub	r9,-1
800043e6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800043e8:	4b 58       	lddpc	r8,800044bc <phy_rx_func+0xed8>
800043ea:	70 09       	ld.w	r9,r8[0x0]
800043ec:	20 29       	sub	r9,2
800043ee:	91 09       	st.w	r8[0x0],r9
800043f0:	70 08       	ld.w	r8,r8[0x0]
800043f2:	58 08       	cp.w	r8,0
800043f4:	c2 f1       	brne	80004452 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800043f6:	30 09       	mov	r9,0
800043f8:	4b 88       	lddpc	r8,800044d8 <phy_rx_func+0xef4>
800043fa:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800043fc:	8e 59       	ld.sh	r9,r7[0xa]
800043fe:	fe 78 82 12 	mov	r8,-32238
80004402:	f0 09 19 00 	cp.h	r9,r8
80004406:	c2 11       	brne	80004448 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004408:	ef 3c 00 0d 	ld.ub	r12,r7[13]
8000440c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004410:	4a f8       	lddpc	r8,800044cc <phy_rx_func+0xee8>
80004412:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004414:	8e 59       	ld.sh	r9,r7[0xa]
80004416:	4a f8       	lddpc	r8,800044d0 <phy_rx_func+0xeec>
80004418:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
8000441a:	8e 69       	ld.sh	r9,r7[0xc]
8000441c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
8000441e:	f0 1f 00 2e 	mcall	800044d4 <phy_rx_func+0xef0>
80004422:	4a 18       	lddpc	r8,800044a4 <phy_rx_func+0xec0>
80004424:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004426:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000442a:	31 38       	mov	r8,19
8000442c:	f0 09 18 00 	cp.b	r9,r8
80004430:	c0 71       	brne	8000443e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004432:	10 99       	mov	r9,r8
80004434:	4a 18       	lddpc	r8,800044b8 <phy_rx_func+0xed4>
80004436:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004438:	30 09       	mov	r9,0
8000443a:	49 c8       	lddpc	r8,800044a8 <phy_rx_func+0xec4>
8000443c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000443e:	30 49       	mov	r9,4
80004440:	49 88       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
80004442:	91 09       	st.w	r8[0x0],r9
80004444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004448:	30 09       	mov	r9,0
8000444a:	49 68       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
8000444c:	91 09       	st.w	r8[0x0],r9
8000444e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004452:	4a dc       	lddpc	r12,80004504 <phy_rx_func+0xf20>
80004454:	f0 1f 00 18 	mcall	800044b4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80004458:	30 09       	mov	r9,0
8000445a:	49 28       	lddpc	r8,800044a0 <phy_rx_func+0xebc>
8000445c:	91 09       	st.w	r8[0x0],r9
8000445e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004462:	00 00       	add	r0,r0
80004464:	00 00       	add	r0,r0
80004466:	0a bc       	st.h	r5++,r12
80004468:	00 00       	add	r0,r0
8000446a:	0a c8       	st.b	r5++,r8
8000446c:	00 00       	add	r0,r0
8000446e:	0a ac       	st.w	r5++,r12
80004470:	00 00       	add	r0,r0
80004472:	0a 84       	andn	r4,r5
80004474:	00 00       	add	r0,r0
80004476:	0a 74       	tst	r4,r5
80004478:	00 00       	add	r0,r0
8000447a:	0a a0       	st.w	r5++,r0
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	30 44       	mov	r4,4
80004480:	00 00       	add	r0,r0
80004482:	0a cc       	st.b	r5++,r12
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	2f 74       	sub	r4,-9
80004488:	00 00       	add	r0,r0
8000448a:	0a b4       	st.h	r5++,r4
8000448c:	80 00       	ld.sh	r0,r0[0x0]
8000448e:	2f 90       	sub	r0,-7
80004490:	00 00       	add	r0,r0
80004492:	0a 91       	mov	r1,r5
80004494:	00 00       	add	r0,r0
80004496:	0a a8       	st.w	r5++,r8
80004498:	00 00       	add	r0,r0
8000449a:	0a c0       	st.b	r5++,r0
8000449c:	00 00       	add	r0,r0
8000449e:	0a dc       	st.w	--r5,r12
800044a0:	00 00       	add	r0,r0
800044a2:	0a 9c       	mov	r12,r5
800044a4:	00 00       	add	r0,r0
800044a6:	0a d4       	st.w	--r5,r4
800044a8:	00 00       	add	r0,r0
800044aa:	0a 80       	andn	r0,r5
800044ac:	00 00       	add	r0,r0
800044ae:	0a 4f       	or	pc,r5
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	d1 bc       	*unknown*
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	6b e8       	ld.w	r8,r5[0x78]
800044b8:	00 00       	add	r0,r0
800044ba:	0a 90       	mov	r0,r5
800044bc:	00 00       	add	r0,r0
800044be:	0a 70       	tst	r0,r5
800044c0:	00 00       	add	r0,r0
800044c2:	0a 88       	andn	r8,r5
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	74 5e       	ld.w	lr,r10[0x14]
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	35 84       	mov	r4,88
800044cc:	00 00       	add	r0,r0
800044ce:	0a 55       	eor	r5,r5
800044d0:	00 00       	add	r0,r0
800044d2:	1e 98       	mov	r8,pc
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	2e d4       	sub	r4,-19
800044d8:	00 00       	add	r0,r0
800044da:	0a b8       	st.h	r5++,r8
800044dc:	00 00       	add	r0,r0
800044de:	1d 9c       	ld.ub	r12,lr[0x1]
800044e0:	00 00       	add	r0,r0
800044e2:	0a 94       	mov	r4,r5
800044e4:	00 00       	add	r0,r0
800044e6:	0a 4c       	or	r12,r5
800044e8:	00 00       	add	r0,r0
800044ea:	0a 41       	or	r1,r5
800044ec:	00 00       	add	r0,r0
800044ee:	0a 68       	and	r8,r5
800044f0:	00 00       	add	r0,r0
800044f2:	0a a4       	st.w	r5++,r4
800044f4:	00 00       	add	r0,r0
800044f6:	0a 57       	eor	r7,r5
800044f8:	00 00       	add	r0,r0
800044fa:	1d 94       	ld.ub	r4,lr[0x1]
800044fc:	00 00       	add	r0,r0
800044fe:	0a c4       	st.b	r5++,r4
80004500:	00 00       	add	r0,r0
80004502:	1e 9c       	mov	r12,pc
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	d1 d4       	*unknown*

80004508 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004508:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000450a:	49 88       	lddpc	r8,80004568 <pdca_int_handler+0x60>
8000450c:	11 89       	ld.ub	r9,r8[0x0]
8000450e:	ec 19 00 01 	eorl	r9,0x1
80004512:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004514:	11 89       	ld.ub	r9,r8[0x0]
80004516:	a5 69       	lsl	r9,0x4
80004518:	2f c9       	sub	r9,-4
8000451a:	49 5a       	lddpc	r10,8000456c <pdca_int_handler+0x64>
8000451c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000451e:	fe 7a 00 40 	mov	r10,-65472
80004522:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004524:	30 39       	mov	r9,3
80004526:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004528:	11 8a       	ld.ub	r10,r8[0x0]
8000452a:	a5 6a       	lsl	r10,0x4
8000452c:	2f ca       	sub	r10,-4
8000452e:	49 18       	lddpc	r8,80004570 <pdca_int_handler+0x68>
80004530:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004532:	fe 78 00 00 	mov	r8,-65536
80004536:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004538:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000453a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000453c:	48 e8       	lddpc	r8,80004574 <pdca_int_handler+0x6c>
8000453e:	70 08       	ld.w	r8,r8[0x0]
80004540:	58 08       	cp.w	r8,0
80004542:	c0 70       	breq	80004550 <pdca_int_handler+0x48>
80004544:	48 99       	lddpc	r9,80004568 <pdca_int_handler+0x60>
80004546:	13 89       	ld.ub	r9,r9[0x0]
80004548:	a5 69       	lsl	r9,0x4
8000454a:	48 ac       	lddpc	r12,80004570 <pdca_int_handler+0x68>
8000454c:	12 0c       	add	r12,r9
8000454e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004550:	48 a8       	lddpc	r8,80004578 <pdca_int_handler+0x70>
80004552:	70 08       	ld.w	r8,r8[0x0]
80004554:	58 08       	cp.w	r8,0
80004556:	c0 70       	breq	80004564 <pdca_int_handler+0x5c>
80004558:	48 49       	lddpc	r9,80004568 <pdca_int_handler+0x60>
8000455a:	13 89       	ld.ub	r9,r9[0x0]
8000455c:	a5 69       	lsl	r9,0x4
8000455e:	48 4c       	lddpc	r12,8000456c <pdca_int_handler+0x64>
80004560:	12 0c       	add	r12,r9
80004562:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004564:	d4 02       	popm	lr
80004566:	d6 03       	rete
80004568:	00 00       	add	r0,r0
8000456a:	50 bc       	stdsp	sp[0x2c],r12
8000456c:	00 00       	add	r0,r0
8000456e:	50 e4       	stdsp	sp[0x38],r4
80004570:	00 00       	add	r0,r0
80004572:	50 c4       	stdsp	sp[0x30],r4
80004574:	00 00       	add	r0,r0
80004576:	0a e8       	st.h	--r5,r8
80004578:	00 00       	add	r0,r0
8000457a:	0a ec       	st.h	--r5,r12

8000457c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
8000457c:	fe 78 10 00 	mov	r8,-61440
80004580:	e0 69 0d c0 	mov	r9,3520
80004584:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004588:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000458c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004590:	fe 78 34 00 	mov	r8,-52224
80004594:	e0 69 80 00 	mov	r9,32768
80004598:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000459a:	30 09       	mov	r9,0
8000459c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000459e:	e0 69 04 21 	mov	r9,1057
800045a2:	ea 19 3f 20 	orh	r9,0x3f20
800045a6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
800045a8:	e0 69 02 9f 	mov	r9,671
800045ac:	ea 19 01 00 	orh	r9,0x100
800045b0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
800045b2:	e0 6a 04 02 	mov	r10,1026
800045b6:	ea 1a 3f 20 	orh	r10,0x3f20
800045ba:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800045bc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800045be:	5e fc       	retal	r12

800045c0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800045c0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800045c2:	30 19       	mov	r9,1
800045c4:	49 78       	lddpc	r8,80004620 <local_start_PDC+0x60>
800045c6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800045c8:	fe 78 00 00 	mov	r8,-65536
800045cc:	30 7b       	mov	r11,7
800045ce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800045d0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800045d2:	49 59       	lddpc	r9,80004624 <local_start_PDC+0x64>
800045d4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800045d8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800045da:	30 3a       	mov	r10,3
800045dc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800045de:	30 1c       	mov	r12,1
800045e0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800045e2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800045e4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800045e6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800045e8:	30 2c       	mov	r12,2
800045ea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800045ec:	48 f9       	lddpc	r9,80004628 <local_start_PDC+0x68>
800045ee:	e0 68 5a 5a 	mov	r8,23130
800045f2:	ea 18 ab cd 	orh	r8,0xabcd
800045f6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800045f8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800045fa:	30 0e       	mov	lr,0
800045fc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800045fe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004600:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004602:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004604:	fe 78 00 40 	mov	r8,-65472
80004608:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000460a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000460c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004610:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004612:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004614:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004616:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004618:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000461a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000461c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000461e:	d8 02       	popm	pc
80004620:	00 00       	add	r0,r0
80004622:	50 bc       	stdsp	sp[0x2c],r12
80004624:	00 00       	add	r0,r0
80004626:	50 c4       	stdsp	sp[0x30],r4
80004628:	00 00       	add	r0,r0
8000462a:	50 e4       	stdsp	sp[0x38],r4

8000462c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000462c:	48 38       	lddpc	r8,80004638 <register_rx_tx_func+0xc>
8000462e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004630:	48 38       	lddpc	r8,8000463c <register_rx_tx_func+0x10>
80004632:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004634:	5e fc       	retal	r12
80004636:	00 00       	add	r0,r0
80004638:	00 00       	add	r0,r0
8000463a:	0a e8       	st.h	--r5,r8
8000463c:	00 00       	add	r0,r0
8000463e:	0a ec       	st.h	--r5,r12

80004640 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004640:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004642:	fe 78 10 00 	mov	r8,-61440
80004646:	30 29       	mov	r9,2
80004648:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000464c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004650:	10 99       	mov	r9,r8
80004652:	f2 f8 01 60 	ld.w	r8,r9[352]
80004656:	e2 18 00 02 	andl	r8,0x2,COH
8000465a:	cf c0       	breq	80004652 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000465c:	fe 79 10 00 	mov	r9,-61440
80004660:	f2 f8 01 60 	ld.w	r8,r9[352]
80004664:	e2 18 00 02 	andl	r8,0x2,COH
80004668:	cf c1       	brne	80004660 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000466a:	30 3a       	mov	r10,3
8000466c:	36 0b       	mov	r11,96
8000466e:	48 bc       	lddpc	r12,80004698 <ssc_init+0x58>
80004670:	f0 1f 00 0b 	mcall	8000469c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004674:	f0 1f 00 0b 	mcall	800046a0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004678:	f0 1f 00 0b 	mcall	800046a4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000467c:	fe 79 00 00 	mov	r9,-65536
80004680:	30 18       	mov	r8,1
80004682:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004684:	fe 7a 00 40 	mov	r10,-65472
80004688:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000468a:	e0 6b 01 01 	mov	r11,257
8000468e:	fe 7a 34 00 	mov	r10,-52224
80004692:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004694:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004696:	d8 02       	popm	pc
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	45 08       	lddsp	r8,sp[0x140]
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	52 9c       	stdsp	sp[0xa4],r12
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	45 7c       	lddsp	r12,sp[0x15c]
800046a4:	80 00       	ld.sh	r0,r0[0x0]
800046a6:	45 c0       	lddsp	r0,sp[0x170]

800046a8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800046a8:	48 28       	lddpc	r8,800046b0 <xcmp_register_app_list+0x8>
800046aa:	91 0c       	st.w	r8[0x0],r12
}
800046ac:	5e fc       	retal	r12
800046ae:	00 00       	add	r0,r0
800046b0:	00 00       	add	r0,r0
800046b2:	51 04       	stdsp	sp[0x40],r4

800046b4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800046b4:	eb cd 40 80 	pushm	r7,lr
800046b8:	fa cd 01 00 	sub	sp,sp,256
800046bc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800046be:	16 98       	mov	r8,r11
800046c0:	2f 08       	sub	r8,-16
800046c2:	af a8       	sbr	r8,0xe
800046c4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800046c6:	3f f8       	mov	r8,-1
800046c8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800046ca:	30 b9       	mov	r9,11
800046cc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800046ce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800046d0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800046d2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046d4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800046d6:	f6 ca ff fe 	sub	r10,r11,-2
800046da:	18 9b       	mov	r11,r12
800046dc:	fa cc ff f0 	sub	r12,sp,-16
800046e0:	f0 1f 00 05 	mcall	800046f4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800046e4:	2f e7       	sub	r7,-2
800046e6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800046e8:	1a 9c       	mov	r12,sp
800046ea:	f0 1f 00 04 	mcall	800046f8 <xcmp_tx+0x44>
}
800046ee:	2c 0d       	sub	sp,-256
800046f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	73 16       	ld.w	r6,r9[0x44]
800046f8:	80 00       	ld.sh	r0,r0[0x0]
800046fa:	4c 34       	lddpc	r4,80004804 <xcmp_IdleTestTone+0x5c>

800046fc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800046fc:	d4 01       	pushm	lr
800046fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004702:	fe 78 b4 00 	mov	r8,-19456
80004706:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004708:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000470c:	30 89       	mov	r9,8
8000470e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004710:	30 19       	mov	r9,1
80004712:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004714:	30 09       	mov	r9,0
80004716:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004718:	30 5a       	mov	r10,5
8000471a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000471c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000471e:	30 7a       	mov	r10,7
80004720:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004722:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004724:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004726:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000472a:	30 9b       	mov	r11,9
8000472c:	fa cc ff fe 	sub	r12,sp,-2
80004730:	f0 1f 00 02 	mcall	80004738 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004734:	2c dd       	sub	sp,-204
80004736:	d8 02       	popm	pc
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	46 b4       	lddsp	r4,sp[0x1ac]

8000473c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000473c:	d4 01       	pushm	lr
8000473e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004742:	fe 78 80 00 	mov	r8,-32768
80004746:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004748:	30 38       	mov	r8,3
8000474a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000474c:	30 1b       	mov	r11,1
8000474e:	fa cc ff fe 	sub	r12,sp,-2
80004752:	f0 1f 00 03 	mcall	8000475c <xcmp_opcode_not_supported+0x20>
}
80004756:	2c dd       	sub	sp,-204
80004758:	d8 02       	popm	pc
8000475a:	00 00       	add	r0,r0
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	46 b4       	lddsp	r4,sp[0x1ac]

80004760 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004760:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004762:	96 88       	ld.uh	r8,r11[0x0]
80004764:	e2 18 f0 00 	andl	r8,0xf000,COH
80004768:	e0 48 80 00 	cp.w	r8,32768
8000476c:	c0 f0       	breq	8000478a <xcmp_exec_func+0x2a>
8000476e:	e0 48 b0 00 	cp.w	r8,45056
80004772:	c1 20       	breq	80004796 <xcmp_exec_func+0x36>
80004774:	58 08       	cp.w	r8,0
80004776:	c1 51       	brne	800047a0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004778:	78 08       	ld.w	r8,r12[0x0]
8000477a:	58 08       	cp.w	r8,0
8000477c:	c0 40       	breq	80004784 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000477e:	16 9c       	mov	r12,r11
80004780:	5d 18       	icall	r8
80004782:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004784:	f0 1f 00 08 	mcall	800047a4 <xcmp_exec_func+0x44>
80004788:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000478a:	78 18       	ld.w	r8,r12[0x4]
8000478c:	58 08       	cp.w	r8,0
8000478e:	c0 90       	breq	800047a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004790:	16 9c       	mov	r12,r11
80004792:	5d 18       	icall	r8
80004794:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004796:	78 28       	ld.w	r8,r12[0x8]
80004798:	58 08       	cp.w	r8,0
8000479a:	c0 30       	breq	800047a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000479c:	16 9c       	mov	r12,r11
8000479e:	5d 18       	icall	r8
800047a0:	d8 02       	popm	pc
800047a2:	00 00       	add	r0,r0
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	47 3c       	lddsp	r12,sp[0x1cc]

800047a8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800047a8:	d4 01       	pushm	lr
800047aa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800047ae:	e0 68 04 09 	mov	r8,1033
800047b2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800047b4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800047b8:	30 19       	mov	r9,1
800047ba:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800047bc:	30 09       	mov	r9,0
800047be:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800047c0:	30 ca       	mov	r10,12
800047c2:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800047c4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800047c6:	fb 69 00 08 	st.b	sp[8],r9
800047ca:	fa c8 ff f7 	sub	r8,sp,-9
800047ce:	b0 89       	st.b	r8[0x0],r9
800047d0:	fa c8 ff f6 	sub	r8,sp,-10
800047d4:	b0 89       	st.b	r8[0x0],r9
800047d6:	fa c8 ff f5 	sub	r8,sp,-11
800047da:	b0 89       	st.b	r8[0x0],r9
800047dc:	fa c8 ff f4 	sub	r8,sp,-12
800047e0:	b0 89       	st.b	r8[0x0],r9
800047e2:	fa c8 ff f3 	sub	r8,sp,-13
800047e6:	b0 89       	st.b	r8[0x0],r9
800047e8:	fa c8 ff f2 	sub	r8,sp,-14
800047ec:	b0 89       	st.b	r8[0x0],r9
800047ee:	fa c8 ff f1 	sub	r8,sp,-15
800047f2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800047f4:	30 cb       	mov	r11,12
800047f6:	fa cc ff fe 	sub	r12,sp,-2
800047fa:	f0 1f 00 03 	mcall	80004804 <xcmp_IdleTestTone+0x5c>
}
800047fe:	2c dd       	sub	sp,-204
80004800:	d8 02       	popm	pc
80004802:	00 00       	add	r0,r0
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	46 b4       	lddsp	r4,sp[0x1ac]

80004808 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004808:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000480a:	48 dc       	lddpc	r12,8000483c <xcmp_init+0x34>
8000480c:	f0 1f 00 0d 	mcall	80004840 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004810:	30 4b       	mov	r11,4
80004812:	31 4c       	mov	r12,20
80004814:	f0 1f 00 0c 	mcall	80004844 <xcmp_init+0x3c>
80004818:	48 c8       	lddpc	r8,80004848 <xcmp_init+0x40>
8000481a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000481c:	30 09       	mov	r9,0
8000481e:	1a d9       	st.w	--sp,r9
80004820:	1a d9       	st.w	--sp,r9
80004822:	1a d9       	st.w	--sp,r9
80004824:	30 38       	mov	r8,3
80004826:	e0 6a 01 80 	mov	r10,384
8000482a:	48 9b       	lddpc	r11,8000484c <xcmp_init+0x44>
8000482c:	48 9c       	lddpc	r12,80004850 <xcmp_init+0x48>
8000482e:	f0 1f 00 0a 	mcall	80004854 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004832:	f0 1f 00 0a 	mcall	80004858 <xcmp_init+0x50>
80004836:	2f dd       	sub	sp,-12
	
}
80004838:	d8 02       	popm	pc
8000483a:	00 00       	add	r0,r0
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	49 58       	lddpc	r8,80004890 <xcmp_rx_process+0x34>
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	49 a4       	lddpc	r4,800048a8 <xcmp_rx_process+0x4c>
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	5f c4       	srvs	r4
80004848:	00 00       	add	r0,r0
8000484a:	0a fc       	st.b	--r5,r12
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	d2 00       	acall	0x20
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	48 5c       	lddpc	r12,80004864 <xcmp_rx_process+0x8>
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	66 98       	ld.w	r8,r3[0x24]
80004858:	80 00       	ld.sh	r0,r0[0x0]
8000485a:	49 dc       	lddpc	r12,800048cc <xcmp_rx_process+0x70>

8000485c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000485c:	d4 31       	pushm	r0-r7,lr
8000485e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004860:	4b 16       	lddpc	r6,80004924 <xcmp_rx_process+0xc8>
80004862:	30 05       	mov	r5,0
80004864:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004866:	4b 13       	lddpc	r3,80004928 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004868:	4b 12       	lddpc	r2,8000492c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000486a:	4b 21       	lddpc	r1,80004930 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000486c:	4b 20       	lddpc	r0,80004934 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000486e:	6c 0c       	ld.w	r12,r6[0x0]
80004870:	0a 99       	mov	r9,r5
80004872:	08 9a       	mov	r10,r4
80004874:	1a 9b       	mov	r11,sp
80004876:	f0 1f 00 31 	mcall	80004938 <xcmp_rx_process+0xdc>
8000487a:	58 1c       	cp.w	r12,1
8000487c:	cf 91       	brne	8000486e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000487e:	40 0b       	lddsp	r11,sp[0x0]
80004880:	58 0b       	cp.w	r11,0
80004882:	cf 60       	breq	8000486e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004884:	96 0a       	ld.sh	r10,r11[0x0]
80004886:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000488a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000488e:	59 c8       	cp.w	r8,28
80004890:	c1 e0       	breq	800048cc <xcmp_rx_process+0x70>
80004892:	e0 89 00 07 	brgt	800048a0 <xcmp_rx_process+0x44>
80004896:	58 e8       	cp.w	r8,14
80004898:	c0 e0       	breq	800048b4 <xcmp_rx_process+0x58>
8000489a:	58 f8       	cp.w	r8,15
8000489c:	c2 41       	brne	800048e4 <xcmp_rx_process+0x88>
8000489e:	c0 f8       	rjmp	800048bc <xcmp_rx_process+0x60>
800048a0:	e0 48 01 09 	cp.w	r8,265
800048a4:	c1 80       	breq	800048d4 <xcmp_rx_process+0x78>
800048a6:	e0 48 01 0a 	cp.w	r8,266
800048aa:	c1 90       	breq	800048dc <xcmp_rx_process+0x80>
800048ac:	e0 48 00 2c 	cp.w	r8,44
800048b0:	c1 a1       	brne	800048e4 <xcmp_rx_process+0x88>
800048b2:	c0 98       	rjmp	800048c4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800048b4:	4a 2c       	lddpc	r12,8000493c <xcmp_rx_process+0xe0>
800048b6:	f0 1f 00 23 	mcall	80004940 <xcmp_rx_process+0xe4>
					break;
800048ba:	c2 f8       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800048bc:	4a 2c       	lddpc	r12,80004944 <xcmp_rx_process+0xe8>
800048be:	f0 1f 00 21 	mcall	80004940 <xcmp_rx_process+0xe4>
					break;
800048c2:	c2 b8       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800048c4:	4a 1c       	lddpc	r12,80004948 <xcmp_rx_process+0xec>
800048c6:	f0 1f 00 1f 	mcall	80004940 <xcmp_rx_process+0xe4>
					break;
800048ca:	c2 78       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800048cc:	04 9c       	mov	r12,r2
800048ce:	f0 1f 00 1d 	mcall	80004940 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800048d2:	c2 38       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800048d4:	02 9c       	mov	r12,r1
800048d6:	f0 1f 00 1b 	mcall	80004940 <xcmp_rx_process+0xe4>
					break;
800048da:	c1 f8       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800048dc:	00 9c       	mov	r12,r0
800048de:	f0 1f 00 19 	mcall	80004940 <xcmp_rx_process+0xe4>
					break;
800048e2:	c1 b8       	rjmp	80004918 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800048e4:	12 98       	mov	r8,r9
800048e6:	e2 18 04 00 	andl	r8,0x400,COH
800048ea:	c0 70       	breq	800048f8 <xcmp_rx_process+0x9c>
800048ec:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800048f0:	e0 48 00 68 	cp.w	r8,104
800048f4:	e0 8a 00 08 	brle	80004904 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800048f8:	e2 19 f0 00 	andl	r9,0xf000,COH
800048fc:	c0 e1       	brne	80004918 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800048fe:	f0 1f 00 14 	mcall	8000494c <xcmp_rx_process+0xf0>
80004902:	c0 b8       	rjmp	80004918 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004904:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004908:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000490c:	49 19       	lddpc	r9,80004950 <xcmp_rx_process+0xf4>
8000490e:	72 08       	ld.w	r8,r9[0x0]
80004910:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004914:	f0 1f 00 0b 	mcall	80004940 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004918:	66 0c       	ld.w	r12,r3[0x0]
8000491a:	40 0b       	lddsp	r11,sp[0x0]
8000491c:	f0 1f 00 0e 	mcall	80004954 <xcmp_rx_process+0xf8>
80004920:	ca 7b       	rjmp	8000486e <xcmp_rx_process+0x12>
80004922:	00 00       	add	r0,r0
80004924:	00 00       	add	r0,r0
80004926:	0a fc       	st.b	--r5,r12
80004928:	00 00       	add	r0,r0
8000492a:	0a a0       	st.w	r5++,r0
8000492c:	00 00       	add	r0,r0
8000492e:	0b 0c       	ld.w	r12,r5++
80004930:	00 00       	add	r0,r0
80004932:	0b 00       	ld.w	r0,r5++
80004934:	00 00       	add	r0,r0
80004936:	0b 18       	ld.sh	r8,r5++
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	5c b8       	swap.b	r8
8000493c:	00 00       	add	r0,r0
8000493e:	0b 30       	ld.ub	r0,r5++
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	47 60       	lddsp	r0,sp[0x1d8]
80004944:	00 00       	add	r0,r0
80004946:	0a f0       	st.b	--r5,r0
80004948:	00 00       	add	r0,r0
8000494a:	0b 24       	ld.uh	r4,r5++
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	47 3c       	lddsp	r12,sp[0x1cc]
80004950:	00 00       	add	r0,r0
80004952:	51 04       	stdsp	sp[0x40],r4
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	2f c8       	sub	r8,-4

80004958 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004958:	eb cd 40 90 	pushm	r4,r7,lr
8000495c:	20 1d       	sub	sp,4
8000495e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004962:	48 c8       	lddpc	r8,80004990 <xcmp_rx+0x38>
80004964:	70 0c       	ld.w	r12,r8[0x0]
80004966:	f0 1f 00 0c 	mcall	80004994 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000496a:	c1 00       	breq	8000498a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000496c:	fa c7 ff fc 	sub	r7,sp,-4
80004970:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004972:	e0 6a 00 ca 	mov	r10,202
80004976:	08 9b       	mov	r11,r4
80004978:	f0 1f 00 08 	mcall	80004998 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000497c:	48 88       	lddpc	r8,8000499c <xcmp_rx+0x44>
8000497e:	70 0c       	ld.w	r12,r8[0x0]
80004980:	30 09       	mov	r9,0
80004982:	12 9a       	mov	r10,r9
80004984:	1a 9b       	mov	r11,sp
80004986:	f0 1f 00 07 	mcall	800049a0 <xcmp_rx+0x48>
	}	
}
8000498a:	2f fd       	sub	sp,-4
8000498c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004990:	00 00       	add	r0,r0
80004992:	0a a0       	st.w	r5++,r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	35 34       	mov	r4,83
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	73 16       	ld.w	r6,r9[0x44]
8000499c:	00 00       	add	r0,r0
8000499e:	0a fc       	st.b	--r5,r12
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	5e c4       	retvs	r4

800049a4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800049a4:	48 28       	lddpc	r8,800049ac <xnl_register_xcmp_func+0x8>
800049a6:	91 0c       	st.w	r8[0x0],r12
}
800049a8:	5e fc       	retal	r12
800049aa:	00 00       	add	r0,r0
800049ac:	00 00       	add	r0,r0
800049ae:	0b 60       	ld.uh	r0,--r5

800049b0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800049b0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800049b2:	48 88       	lddpc	r8,800049d0 <xnl_get_msg_ack_func+0x20>
800049b4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800049b6:	98 49       	ld.sh	r9,r12[0x8]
800049b8:	f0 09 19 00 	cp.h	r9,r8
800049bc:	c0 81       	brne	800049cc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800049be:	48 68       	lddpc	r8,800049d4 <xnl_get_msg_ack_func+0x24>
800049c0:	70 0c       	ld.w	r12,r8[0x0]
800049c2:	30 09       	mov	r9,0
800049c4:	12 9a       	mov	r10,r9
800049c6:	12 9b       	mov	r11,r9
800049c8:	f0 1f 00 04 	mcall	800049d8 <xnl_get_msg_ack_func+0x28>
800049cc:	d8 02       	popm	pc
800049ce:	00 00       	add	r0,r0
800049d0:	00 00       	add	r0,r0
800049d2:	0b 40       	ld.w	r0,--r5
800049d4:	00 00       	add	r0,r0
800049d6:	0b 3c       	ld.ub	r12,r5++
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	5e c4       	retvs	r4

800049dc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800049dc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800049e0:	30 09       	mov	r9,0
800049e2:	4b 78       	lddpc	r8,80004abc <xnl_init+0xe0>
800049e4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800049e6:	30 0b       	mov	r11,0
800049e8:	30 1c       	mov	r12,1
800049ea:	f0 1f 00 36 	mcall	80004ac0 <xnl_init+0xe4>
800049ee:	4b 68       	lddpc	r8,80004ac4 <xnl_init+0xe8>
800049f0:	91 0c       	st.w	r8[0x0],r12
800049f2:	70 08       	ld.w	r8,r8[0x0]
800049f4:	58 08       	cp.w	r8,0
800049f6:	c0 80       	breq	80004a06 <xnl_init+0x2a>
800049f8:	4b 38       	lddpc	r8,80004ac4 <xnl_init+0xe8>
800049fa:	70 0c       	ld.w	r12,r8[0x0]
800049fc:	30 09       	mov	r9,0
800049fe:	12 9a       	mov	r10,r9
80004a00:	12 9b       	mov	r11,r9
80004a02:	f0 1f 00 32 	mcall	80004ac8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004a06:	30 4b       	mov	r11,4
80004a08:	31 4c       	mov	r12,20
80004a0a:	f0 1f 00 2e 	mcall	80004ac0 <xnl_init+0xe4>
80004a0e:	4b 08       	lddpc	r8,80004acc <xnl_init+0xf0>
80004a10:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004a12:	30 4b       	mov	r11,4
80004a14:	31 ec       	mov	r12,30
80004a16:	f0 1f 00 2b 	mcall	80004ac0 <xnl_init+0xe4>
80004a1a:	4a e8       	lddpc	r8,80004ad0 <xnl_init+0xf4>
80004a1c:	91 0c       	st.w	r8[0x0],r12
80004a1e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004a20:	10 96       	mov	r6,r8
80004a22:	4a d5       	lddpc	r5,80004ad4 <xnl_init+0xf8>
80004a24:	6c 0c       	ld.w	r12,r6[0x0]
80004a26:	ea 07 00 0b 	add	r11,r5,r7
80004a2a:	f0 1f 00 2c 	mcall	80004ad8 <xnl_init+0xfc>
80004a2e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004a32:	e0 47 1e 00 	cp.w	r7,7680
80004a36:	cf 71       	brne	80004a24 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004a38:	30 4b       	mov	r11,4
80004a3a:	31 4c       	mov	r12,20
80004a3c:	f0 1f 00 21 	mcall	80004ac0 <xnl_init+0xe4>
80004a40:	4a 78       	lddpc	r8,80004adc <xnl_init+0x100>
80004a42:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004a44:	30 4b       	mov	r11,4
80004a46:	30 ac       	mov	r12,10
80004a48:	f0 1f 00 1e 	mcall	80004ac0 <xnl_init+0xe4>
80004a4c:	4a 58       	lddpc	r8,80004ae0 <xnl_init+0x104>
80004a4e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004a50:	30 4b       	mov	r11,4
80004a52:	30 ac       	mov	r12,10
80004a54:	f0 1f 00 1b 	mcall	80004ac0 <xnl_init+0xe4>
80004a58:	4a 38       	lddpc	r8,80004ae4 <xnl_init+0x108>
80004a5a:	91 0c       	st.w	r8[0x0],r12
80004a5c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004a5e:	10 96       	mov	r6,r8
80004a60:	4a 25       	lddpc	r5,80004ae8 <xnl_init+0x10c>
80004a62:	6c 0c       	ld.w	r12,r6[0x0]
80004a64:	ea 07 00 0b 	add	r11,r5,r7
80004a68:	f0 1f 00 1c 	mcall	80004ad8 <xnl_init+0xfc>
80004a6c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004a70:	e0 47 14 00 	cp.w	r7,5120
80004a74:	cf 71       	brne	80004a62 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004a76:	30 4b       	mov	r11,4
80004a78:	30 5c       	mov	r12,5
80004a7a:	f0 1f 00 12 	mcall	80004ac0 <xnl_init+0xe4>
80004a7e:	49 c8       	lddpc	r8,80004aec <xnl_init+0x110>
80004a80:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004a82:	30 07       	mov	r7,0
80004a84:	1a d7       	st.w	--sp,r7
80004a86:	1a d7       	st.w	--sp,r7
80004a88:	1a d7       	st.w	--sp,r7
80004a8a:	30 38       	mov	r8,3
80004a8c:	0e 99       	mov	r9,r7
80004a8e:	e0 6a 02 00 	mov	r10,512
80004a92:	49 8b       	lddpc	r11,80004af0 <xnl_init+0x114>
80004a94:	49 8c       	lddpc	r12,80004af4 <xnl_init+0x118>
80004a96:	f0 1f 00 19 	mcall	80004af8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004a9a:	1a d7       	st.w	--sp,r7
80004a9c:	1a d7       	st.w	--sp,r7
80004a9e:	1a d7       	st.w	--sp,r7
80004aa0:	30 38       	mov	r8,3
80004aa2:	0e 99       	mov	r9,r7
80004aa4:	e0 6a 03 20 	mov	r10,800
80004aa8:	49 5b       	lddpc	r11,80004afc <xnl_init+0x120>
80004aaa:	49 6c       	lddpc	r12,80004b00 <xnl_init+0x124>
80004aac:	f0 1f 00 13 	mcall	80004af8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004ab0:	f0 1f 00 15 	mcall	80004b04 <xnl_init+0x128>
80004ab4:	2f ad       	sub	sp,-24
}
80004ab6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004aba:	00 00       	add	r0,r0
80004abc:	00 00       	add	r0,r0
80004abe:	0b 40       	ld.w	r0,--r5
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	5f c4       	srvs	r4
80004ac4:	00 00       	add	r0,r0
80004ac6:	0b 3c       	ld.ub	r12,r5++
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	5e c4       	retvs	r4
80004acc:	00 00       	add	r0,r0
80004ace:	0b 4c       	ld.w	r12,--r5
80004ad0:	00 00       	add	r0,r0
80004ad2:	0a a0       	st.w	r5++,r0
80004ad4:	00 00       	add	r0,r0
80004ad6:	32 b6       	mov	r6,43
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	2f c8       	sub	r8,-4
80004adc:	00 00       	add	r0,r0
80004ade:	0a d0       	st.w	--r5,r0
80004ae0:	00 00       	add	r0,r0
80004ae2:	0a bc       	st.h	r5++,r12
80004ae4:	00 00       	add	r0,r0
80004ae6:	0a a8       	st.w	r5++,r8
80004ae8:	00 00       	add	r0,r0
80004aea:	1e b6       	st.h	pc++,r6
80004aec:	00 00       	add	r0,r0
80004aee:	0a 78       	tst	r8,r5
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	d2 08       	*unknown*
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	4b 08       	lddpc	r8,80004bb4 <xnl_tx_process+0x4c>
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	66 98       	ld.w	r8,r3[0x24]
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	ca 00       	breq	80004a3e <xnl_init+0x62>
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	4b 68       	lddpc	r8,80004bd8 <xnl_tx_process+0x70>
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	35 5c       	mov	r12,85

80004b08 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004b08:	eb cd 40 fe 	pushm	r1-r7,lr
80004b0c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004b0e:	49 26       	lddpc	r6,80004b54 <xnl_rx_process+0x4c>
80004b10:	30 05       	mov	r5,0
80004b12:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004b14:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004b16:	49 11       	lddpc	r1,80004b58 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004b18:	49 12       	lddpc	r2,80004b5c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004b1a:	6c 0c       	ld.w	r12,r6[0x0]
80004b1c:	0a 99       	mov	r9,r5
80004b1e:	08 9a       	mov	r10,r4
80004b20:	1a 9b       	mov	r11,sp
80004b22:	f0 1f 00 10 	mcall	80004b60 <xnl_rx_process+0x58>
80004b26:	58 1c       	cp.w	r12,1
80004b28:	cf 91       	brne	80004b1a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004b2a:	40 0c       	lddsp	r12,sp[0x0]
80004b2c:	58 0c       	cp.w	r12,0
80004b2e:	cf 60       	breq	80004b1a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004b30:	98 28       	ld.sh	r8,r12[0x4]
80004b32:	e6 08 19 00 	cp.h	r8,r3
80004b36:	e0 8b 00 0a 	brhi	80004b4a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004b3a:	5c 78       	castu.h	r8
80004b3c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004b40:	58 09       	cp.w	r9,0
80004b42:	c0 40       	breq	80004b4a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004b44:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004b48:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004b4a:	62 0c       	ld.w	r12,r1[0x0]
80004b4c:	40 0b       	lddsp	r11,sp[0x0]
80004b4e:	f0 1f 00 06 	mcall	80004b64 <xnl_rx_process+0x5c>
80004b52:	ce 4b       	rjmp	80004b1a <xnl_rx_process+0x12>
80004b54:	00 00       	add	r0,r0
80004b56:	0a bc       	st.h	r5++,r12
80004b58:	00 00       	add	r0,r0
80004b5a:	0a a0       	st.w	r5++,r0
80004b5c:	00 00       	add	r0,r0
80004b5e:	04 f0       	st.b	--r2,r0
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	5c b8       	swap.b	r8
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	2f c8       	sub	r8,-4

80004b68 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004b68:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004b6a:	4a a6       	lddpc	r6,80004c10 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004b6c:	4a a2       	lddpc	r2,80004c14 <xnl_tx_process+0xac>
80004b6e:	4a b4       	lddpc	r4,80004c18 <xnl_tx_process+0xb0>
80004b70:	30 07       	mov	r7,0
80004b72:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004b74:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004b76:	4a a5       	lddpc	r5,80004c1c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004b78:	4a a3       	lddpc	r3,80004c20 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004b7a:	6c 08       	ld.w	r8,r6[0x0]
80004b7c:	58 08       	cp.w	r8,0
80004b7e:	c0 40       	breq	80004b86 <xnl_tx_process+0x1e>
80004b80:	58 18       	cp.w	r8,1
80004b82:	cf d1       	brne	80004b7c <xnl_tx_process+0x14>
80004b84:	c2 48       	rjmp	80004bcc <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004b86:	64 0c       	ld.w	r12,r2[0x0]
80004b88:	0e 99       	mov	r9,r7
80004b8a:	02 9a       	mov	r10,r1
80004b8c:	08 9b       	mov	r11,r4
80004b8e:	f0 1f 00 26 	mcall	80004c24 <xnl_tx_process+0xbc>
80004b92:	58 1c       	cp.w	r12,1
80004b94:	cf 31       	brne	80004b7a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004b96:	68 0b       	ld.w	r11,r4[0x0]
80004b98:	58 0b       	cp.w	r11,0
80004b9a:	cf 00       	breq	80004b7a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004b9c:	96 28       	ld.sh	r8,r11[0x4]
80004b9e:	e0 08 19 00 	cp.h	r8,r0
80004ba2:	c0 71       	brne	80004bb0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004ba4:	4a 18       	lddpc	r8,80004c28 <xnl_tx_process+0xc0>
80004ba6:	70 08       	ld.w	r8,r8[0x0]
80004ba8:	10 9c       	mov	r12,r8
80004baa:	f0 1f 00 21 	mcall	80004c2c <xnl_tx_process+0xc4>
						break;
80004bae:	ce 6b       	rjmp	80004b7a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004bb0:	16 9c       	mov	r12,r11
80004bb2:	f0 1f 00 20 	mcall	80004c30 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004bb6:	30 18       	mov	r8,1
80004bb8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004bba:	66 0c       	ld.w	r12,r3[0x0]
80004bbc:	0e 99       	mov	r9,r7
80004bbe:	0e 9a       	mov	r10,r7
80004bc0:	0e 9b       	mov	r11,r7
80004bc2:	f0 1f 00 19 	mcall	80004c24 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004bc6:	30 18       	mov	r8,1
80004bc8:	8d 08       	st.w	r6[0x0],r8
80004bca:	cd 8b       	rjmp	80004b7a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004bcc:	66 0c       	ld.w	r12,r3[0x0]
80004bce:	0e 99       	mov	r9,r7
80004bd0:	36 4a       	mov	r10,100
80004bd2:	0e 9b       	mov	r11,r7
80004bd4:	f0 1f 00 14 	mcall	80004c24 <xnl_tx_process+0xbc>
80004bd8:	58 1c       	cp.w	r12,1
80004bda:	c0 81       	brne	80004bea <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004bdc:	49 38       	lddpc	r8,80004c28 <xnl_tx_process+0xc0>
80004bde:	70 0c       	ld.w	r12,r8[0x0]
80004be0:	68 0b       	ld.w	r11,r4[0x0]
80004be2:	f0 1f 00 13 	mcall	80004c2c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004be6:	8d 07       	st.w	r6[0x0],r7
80004be8:	cc 9b       	rjmp	80004b7a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004bea:	6a 08       	ld.w	r8,r5[0x0]
80004bec:	58 38       	cp.w	r8,3
80004bee:	e0 89 00 09 	brgt	80004c00 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004bf2:	68 0c       	ld.w	r12,r4[0x0]
80004bf4:	f0 1f 00 0f 	mcall	80004c30 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004bf8:	6a 08       	ld.w	r8,r5[0x0]
80004bfa:	2f f8       	sub	r8,-1
80004bfc:	8b 08       	st.w	r5[0x0],r8
80004bfe:	cb eb       	rjmp	80004b7a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004c00:	48 a8       	lddpc	r8,80004c28 <xnl_tx_process+0xc0>
80004c02:	70 0c       	ld.w	r12,r8[0x0]
80004c04:	68 0b       	ld.w	r11,r4[0x0]
80004c06:	f0 1f 00 0a 	mcall	80004c2c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004c0a:	8d 07       	st.w	r6[0x0],r7
80004c0c:	cb 7b       	rjmp	80004b7a <xnl_tx_process+0x12>
80004c0e:	00 00       	add	r0,r0
80004c10:	00 00       	add	r0,r0
80004c12:	0b 5c       	ld.sh	r12,--r5
80004c14:	00 00       	add	r0,r0
80004c16:	0b 4c       	ld.w	r12,--r5
80004c18:	00 00       	add	r0,r0
80004c1a:	0b 54       	ld.sh	r4,--r5
80004c1c:	00 00       	add	r0,r0
80004c1e:	0b 50       	ld.sh	r0,--r5
80004c20:	00 00       	add	r0,r0
80004c22:	0b 3c       	ld.ub	r12,r5++
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	5c b8       	swap.b	r8
80004c28:	00 00       	add	r0,r0
80004c2a:	0a a0       	st.w	r5++,r0
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	2f c8       	sub	r8,-4
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	2f e8       	sub	r8,-2

80004c34 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004c34:	eb cd 40 c0 	pushm	r6-r7,lr
80004c38:	20 1d       	sub	sp,4
80004c3a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004c3c:	98 39       	ld.sh	r9,r12[0x6]
80004c3e:	3f f8       	mov	r8,-1
80004c40:	f0 09 19 00 	cp.h	r9,r8
80004c44:	c0 a1       	brne	80004c58 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004c46:	4a e9       	lddpc	r9,80004cfc <xnl_tx+0xc8>
80004c48:	13 88       	ld.ub	r8,r9[0x0]
80004c4a:	2f f8       	sub	r8,-1
80004c4c:	5c 58       	castu.b	r8
80004c4e:	b2 88       	st.b	r9[0x0],r8
80004c50:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004c54:	a9 a8       	sbr	r8,0x8
80004c56:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004c58:	8c 49       	ld.sh	r9,r6[0x8]
80004c5a:	3f f8       	mov	r8,-1
80004c5c:	f0 09 19 00 	cp.h	r9,r8
80004c60:	c0 41       	brne	80004c68 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004c62:	4a 88       	lddpc	r8,80004d00 <xnl_tx+0xcc>
80004c64:	90 18       	ld.sh	r8,r8[0x2]
80004c66:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004c68:	8c 59       	ld.sh	r9,r6[0xa]
80004c6a:	3f f8       	mov	r8,-1
80004c6c:	f0 09 19 00 	cp.h	r9,r8
80004c70:	c0 41       	brne	80004c78 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004c72:	4a 48       	lddpc	r8,80004d00 <xnl_tx+0xcc>
80004c74:	90 28       	ld.sh	r8,r8[0x4]
80004c76:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004c78:	8c 69       	ld.sh	r9,r6[0xc]
80004c7a:	3f f8       	mov	r8,-1
80004c7c:	f0 09 19 00 	cp.h	r9,r8
80004c80:	c0 e1       	brne	80004c9c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004c82:	4a 08       	lddpc	r8,80004d00 <xnl_tx+0xcc>
80004c84:	90 49       	ld.sh	r9,r8[0x8]
80004c86:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004c88:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004c8a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004c8c:	90 49       	ld.sh	r9,r8[0x8]
80004c8e:	e0 19 ff 00 	andl	r9,0xff00
80004c92:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004c96:	f3 e8 10 08 	or	r8,r9,r8
80004c9a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004c9c:	0d 98       	ld.ub	r8,r6[0x1]
80004c9e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004ca0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004ca4:	10 0c       	add	r12,r8
80004ca6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004ca8:	58 0c       	cp.w	r12,0
80004caa:	e0 89 00 04 	brgt	80004cb2 <xnl_tx+0x7e>
80004cae:	30 09       	mov	r9,0
80004cb0:	c0 d8       	rjmp	80004cca <xnl_tx+0x96>
80004cb2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004cb6:	2f ec       	sub	r12,-2
80004cb8:	30 09       	mov	r9,0
80004cba:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004cbc:	15 1b       	ld.sh	r11,r10++
80004cbe:	f6 09 00 09 	add	r9,r11,r9
80004cc2:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004cc4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004cc6:	18 38       	cp.w	r8,r12
80004cc8:	cf a1       	brne	80004cbc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004cca:	5c 39       	neg	r9
80004ccc:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004cce:	48 e8       	lddpc	r8,80004d04 <xnl_tx+0xd0>
80004cd0:	70 0c       	ld.w	r12,r8[0x0]
80004cd2:	f0 1f 00 0e 	mcall	80004d08 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004cd6:	c1 00       	breq	80004cf6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004cd8:	fa c7 ff fc 	sub	r7,sp,-4
80004cdc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004cde:	e0 6a 01 00 	mov	r10,256
80004ce2:	0c 9b       	mov	r11,r6
80004ce4:	f0 1f 00 0a 	mcall	80004d0c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004ce8:	48 a8       	lddpc	r8,80004d10 <xnl_tx+0xdc>
80004cea:	70 0c       	ld.w	r12,r8[0x0]
80004cec:	30 09       	mov	r9,0
80004cee:	12 9a       	mov	r10,r9
80004cf0:	1a 9b       	mov	r11,sp
80004cf2:	f0 1f 00 09 	mcall	80004d14 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004cf6:	2f fd       	sub	sp,-4
80004cf8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cfc:	00 00       	add	r0,r0
80004cfe:	0b 58       	ld.sh	r8,--r5
80004d00:	00 00       	add	r0,r0
80004d02:	0b 40       	ld.w	r0,--r5
80004d04:	00 00       	add	r0,r0
80004d06:	0a a0       	st.w	r5++,r0
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	35 34       	mov	r4,83
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	73 16       	ld.w	r6,r9[0x44]
80004d10:	00 00       	add	r0,r0
80004d12:	0b 4c       	ld.w	r12,--r5
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	5e c4       	retvs	r4

80004d18 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004d18:	eb cd 40 80 	pushm	r7,lr
80004d1c:	fa cd 01 00 	sub	sp,sp,256
80004d20:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004d22:	e0 68 40 0e 	mov	r8,16398
80004d26:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d28:	3f f8       	mov	r8,-1
80004d2a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004d2c:	30 c8       	mov	r8,12
80004d2e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004d30:	98 38       	ld.sh	r8,r12[0x6]
80004d32:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004d34:	98 58       	ld.sh	r8,r12[0xa]
80004d36:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004d38:	98 48       	ld.sh	r8,r12[0x8]
80004d3a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004d3c:	98 68       	ld.sh	r8,r12[0xc]
80004d3e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004d40:	30 08       	mov	r8,0
80004d42:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004d44:	1a 9c       	mov	r12,sp
80004d46:	f0 1f 00 0a 	mcall	80004d6c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004d4a:	fa cd 00 cc 	sub	sp,sp,204
80004d4e:	e0 6a 00 ca 	mov	r10,202
80004d52:	ee cb ff f0 	sub	r11,r7,-16
80004d56:	1a 9c       	mov	r12,sp
80004d58:	f0 1f 00 06 	mcall	80004d70 <xnl_data_msg_func+0x58>
80004d5c:	48 68       	lddpc	r8,80004d74 <xnl_data_msg_func+0x5c>
80004d5e:	70 08       	ld.w	r8,r8[0x0]
80004d60:	5d 18       	icall	r8
80004d62:	fa cd ff 34 	sub	sp,sp,-204
}
80004d66:	2c 0d       	sub	sp,-256
80004d68:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	4c 34       	lddpc	r4,80004e78 <xnl_device_auth_reply_func+0x100>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	73 16       	ld.w	r6,r9[0x44]
80004d74:	00 00       	add	r0,r0
80004d76:	0b 60       	ld.uh	r0,--r5

80004d78 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004d78:	d4 21       	pushm	r4-r7,lr
80004d7a:	fa cd 01 00 	sub	sp,sp,256
80004d7e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004d80:	4c 28       	lddpc	r8,80004e88 <xnl_device_auth_reply_func+0x110>
80004d82:	11 88       	ld.ub	r8,r8[0x0]
80004d84:	58 08       	cp.w	r8,0
80004d86:	c7 e1       	brne	80004e82 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004d88:	4c 18       	lddpc	r8,80004e8c <xnl_device_auth_reply_func+0x114>
80004d8a:	70 0c       	ld.w	r12,r8[0x0]
80004d8c:	30 09       	mov	r9,0
80004d8e:	12 9a       	mov	r10,r9
80004d90:	12 9b       	mov	r11,r9
80004d92:	f0 1f 00 40 	mcall	80004e90 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004d96:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004d9a:	4b c8       	lddpc	r8,80004e88 <xnl_device_auth_reply_func+0x110>
80004d9c:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004d9e:	ef 39 00 12 	ld.ub	r9,r7[18]
80004da2:	ef 38 00 13 	ld.ub	r8,r7[19]
80004da6:	b1 68       	lsl	r8,0x10
80004da8:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004dac:	ef 38 00 15 	ld.ub	r8,r7[21]
80004db0:	f3 e8 10 08 	or	r8,r9,r8
80004db4:	ef 39 00 14 	ld.ub	r9,r7[20]
80004db8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004dbc:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004dc0:	ef 38 00 17 	ld.ub	r8,r7[23]
80004dc4:	b1 68       	lsl	r8,0x10
80004dc6:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004dca:	ef 38 00 19 	ld.ub	r8,r7[25]
80004dce:	f5 e8 10 08 	or	r8,r10,r8
80004dd2:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004dd6:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004dda:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004ddc:	e0 64 79 b9 	mov	r4,31161
80004de0:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004de4:	e0 65 45 07 	mov	r5,17671
80004de8:	ea 15 8a bd 	orh	r5,0x8abd
80004dec:	e0 66 f9 3d 	mov	r6,63805
80004df0:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004df4:	e0 6e b8 cf 	mov	lr,47311
80004df8:	ea 1e 36 83 	orh	lr,0x3683
80004dfc:	e0 67 aa 1c 	mov	r7,43548
80004e00:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004e04:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004e06:	f4 08 00 0c 	add	r12,r10,r8
80004e0a:	f0 0b 15 04 	lsl	r11,r8,0x4
80004e0e:	0a 0b       	add	r11,r5
80004e10:	f9 eb 20 0b 	eor	r11,r12,r11
80004e14:	f0 0c 16 05 	lsr	r12,r8,0x5
80004e18:	0c 0c       	add	r12,r6
80004e1a:	18 5b       	eor	r11,r12
80004e1c:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004e1e:	f2 0c 15 04 	lsl	r12,r9,0x4
80004e22:	1c 0c       	add	r12,lr
80004e24:	f2 0b 16 05 	lsr	r11,r9,0x5
80004e28:	0e 0b       	add	r11,r7
80004e2a:	f9 eb 20 0b 	eor	r11,r12,r11
80004e2e:	f2 0a 00 0c 	add	r12,r9,r10
80004e32:	18 5b       	eor	r11,r12
80004e34:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004e36:	e0 6b 37 20 	mov	r11,14112
80004e3a:	ea 1b c6 ef 	orh	r11,0xc6ef
80004e3e:	16 3a       	cp.w	r10,r11
80004e40:	ce 21       	brne	80004e04 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004e42:	e0 6a 40 1a 	mov	r10,16410
80004e46:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004e48:	3f fa       	mov	r10,-1
80004e4a:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004e4c:	30 6b       	mov	r11,6
80004e4e:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004e50:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004e52:	48 eb       	lddpc	r11,80004e88 <xnl_device_auth_reply_func+0x110>
80004e54:	96 1c       	ld.sh	r12,r11[0x2]
80004e56:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004e58:	96 2b       	ld.sh	r11,r11[0x4]
80004e5a:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004e5c:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004e5e:	30 ca       	mov	r10,12
80004e60:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004e62:	30 0a       	mov	r10,0
80004e64:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004e68:	30 7a       	mov	r10,7
80004e6a:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004e6e:	30 2a       	mov	r10,2
80004e70:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004e74:	fa ca ff ec 	sub	r10,sp,-20
80004e78:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004e7a:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004e7c:	1a 9c       	mov	r12,sp
80004e7e:	f0 1f 00 06 	mcall	80004e94 <xnl_device_auth_reply_func+0x11c>
}
80004e82:	2c 0d       	sub	sp,-256
80004e84:	d8 22       	popm	r4-r7,pc
80004e86:	00 00       	add	r0,r0
80004e88:	00 00       	add	r0,r0
80004e8a:	0b 40       	ld.w	r0,--r5
80004e8c:	00 00       	add	r0,r0
80004e8e:	0b 3c       	ld.ub	r12,r5++
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	5e c4       	retvs	r4
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	4c 34       	lddpc	r4,80004fa0 <local_start_pll0+0x1c>

80004e98 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004e98:	eb cd 40 80 	pushm	r7,lr
80004e9c:	fa cd 01 00 	sub	sp,sp,256
80004ea0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004ea2:	49 28       	lddpc	r8,80004ee8 <xnl_master_status_brdcst_func+0x50>
80004ea4:	11 88       	ld.ub	r8,r8[0x0]
80004ea6:	58 08       	cp.w	r8,0
80004ea8:	c1 c1       	brne	80004ee0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004eaa:	49 18       	lddpc	r8,80004eec <xnl_master_status_brdcst_func+0x54>
80004eac:	70 0c       	ld.w	r12,r8[0x0]
80004eae:	30 09       	mov	r9,0
80004eb0:	12 9a       	mov	r10,r9
80004eb2:	12 9b       	mov	r11,r9
80004eb4:	f0 1f 00 0f 	mcall	80004ef0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004eb8:	8e 58       	ld.sh	r8,r7[0xa]
80004eba:	48 c9       	lddpc	r9,80004ee8 <xnl_master_status_brdcst_func+0x50>
80004ebc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004ebe:	e0 68 40 0e 	mov	r8,16398
80004ec2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004ec4:	3f f8       	mov	r8,-1
80004ec6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004ec8:	30 4a       	mov	r10,4
80004eca:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ecc:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ece:	92 19       	ld.sh	r9,r9[0x2]
80004ed0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004ed2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004ed4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004ed6:	30 08       	mov	r8,0
80004ed8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004eda:	1a 9c       	mov	r12,sp
80004edc:	f0 1f 00 06 	mcall	80004ef4 <xnl_master_status_brdcst_func+0x5c>
}
80004ee0:	2c 0d       	sub	sp,-256
80004ee2:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ee6:	00 00       	add	r0,r0
80004ee8:	00 00       	add	r0,r0
80004eea:	0b 40       	ld.w	r0,--r5
80004eec:	00 00       	add	r0,r0
80004eee:	0b 3c       	ld.ub	r12,r5++
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	5e c4       	retvs	r4
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4c 34       	lddpc	r4,80005000 <local_start_timer+0x2c>

80004ef8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004ef8:	eb cd 40 80 	pushm	r7,lr
80004efc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004efe:	49 28       	lddpc	r8,80004f44 <xnl_device_conn_reply_func+0x4c>
80004f00:	70 0c       	ld.w	r12,r8[0x0]
80004f02:	30 09       	mov	r9,0
80004f04:	12 9a       	mov	r10,r9
80004f06:	12 9b       	mov	r11,r9
80004f08:	f0 1f 00 10 	mcall	80004f48 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004f0c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004f10:	10 99       	mov	r9,r8
80004f12:	e2 19 ff 00 	andl	r9,0xff00,COH
80004f16:	e0 49 01 00 	cp.w	r9,256
80004f1a:	c0 60       	breq	80004f26 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004f1c:	0e 9c       	mov	r12,r7
80004f1e:	f0 1f 00 0c 	mcall	80004f4c <xnl_device_conn_reply_func+0x54>
80004f22:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004f26:	a9 68       	lsl	r8,0x8
80004f28:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004f2c:	48 98       	lddpc	r8,80004f50 <xnl_device_conn_reply_func+0x58>
80004f2e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004f30:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004f34:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004f36:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004f3a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004f3c:	30 19       	mov	r9,1
80004f3e:	b0 89       	st.b	r8[0x0],r9
80004f40:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f44:	00 00       	add	r0,r0
80004f46:	0b 3c       	ld.ub	r12,r5++
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	5e c4       	retvs	r4
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	4e 98       	lddpc	r8,800050f0 <voc_init+0xe0>
80004f50:	00 00       	add	r0,r0
80004f52:	0b 40       	ld.w	r0,--r5

80004f54 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004f54:	d4 01       	pushm	lr
80004f56:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f5a:	e0 68 40 0e 	mov	r8,16398
80004f5e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f60:	3f f8       	mov	r8,-1
80004f62:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004f64:	30 38       	mov	r8,3
80004f66:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004f68:	30 08       	mov	r8,0
80004f6a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004f6c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004f6e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004f70:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004f72:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004f74:	1a 9c       	mov	r12,sp
80004f76:	f0 1f 00 03 	mcall	80004f80 <xnl_send_device_master_query+0x2c>
}
80004f7a:	2c 0d       	sub	sp,-256
80004f7c:	d8 02       	popm	pc
80004f7e:	00 00       	add	r0,r0
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4c 34       	lddpc	r4,8000508c <voc_init+0x7c>

80004f84 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004f84:	fe 78 0c 00 	mov	r8,-62464
80004f88:	e0 69 03 07 	mov	r9,775
80004f8c:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004f8e:	30 49       	mov	r9,4
80004f90:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004f92:	71 59       	ld.w	r9,r8[0x54]
80004f94:	e2 19 00 80 	andl	r9,0x80,COH
80004f98:	cf d0       	breq	80004f92 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004f9a:	fe 78 0c 00 	mov	r8,-62464
80004f9e:	30 59       	mov	r9,5
80004fa0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004fa2:	e0 69 01 0d 	mov	r9,269
80004fa6:	ea 19 10 07 	orh	r9,0x1007
80004faa:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004fac:	71 59       	ld.w	r9,r8[0x54]
80004fae:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004fb2:	cf d0       	breq	80004fac <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004fb4:	fe 78 0c 00 	mov	r8,-62464
80004fb8:	fc 19 00 80 	movh	r9,0x80
80004fbc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004fbe:	34 0a       	mov	r10,64
80004fc0:	fe 69 14 00 	mov	r9,-125952
80004fc4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004fc6:	30 69       	mov	r9,6
80004fc8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004fca:	30 19       	mov	r9,1
80004fcc:	fe 68 10 00 	mov	r8,-126976
80004fd0:	91 19       	st.w	r8[0x4],r9
}
80004fd2:	5e fc       	retal	r12

80004fd4 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004fd4:	fe 78 10 00 	mov	r8,-61440
80004fd8:	fc 19 00 10 	movh	r9,0x10
80004fdc:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004fde:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004fe0:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004fe2:	30 39       	mov	r9,3
80004fe4:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004fe8:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004fec:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004ff0:	fe 78 38 00 	mov	r8,-51200
80004ff4:	30 49       	mov	r9,4
80004ff6:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004ffa:	e0 69 91 0d 	mov	r9,37133
80004ffe:	ea 19 00 52 	orh	r9,0x52
80005002:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005004:	32 09       	mov	r9,32
80005006:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005008:	30 59       	mov	r9,5
8000500a:	91 09       	st.w	r8[0x0],r9
}
8000500c:	5e fc       	retal	r12
8000500e:	d7 03       	nop

80005010 <voc_init>:
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
{
80005010:	d4 31       	pushm	r0-r7,lr
80005012:	21 4d       	sub	sp,80
	data_flash_init();
80005014:	f0 1f 00 63 	mcall	800051a0 <voc_init+0x190>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80005018:	30 08       	mov	r8,0
8000501a:	30 09       	mov	r9,0
8000501c:	fa e9 00 00 	st.d	sp[0],r8
80005020:	fa e9 00 08 	st.d	sp[8],r8
80005024:	fa e9 00 10 	st.d	sp[16],r8
80005028:	fa e9 00 18 	st.d	sp[24],r8
8000502c:	fa e9 00 20 	st.d	sp[32],r8
80005030:	fa e9 00 28 	st.d	sp[40],r8
80005034:	fa e9 00 30 	st.d	sp[48],r8
80005038:	fa e9 00 38 	st.d	sp[56],r8
8000503c:	fa e9 00 40 	st.d	sp[64],r8
80005040:	fa e9 00 48 	st.d	sp[72],r8
80005044:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005046:	1a 97       	mov	r7,sp
80005048:	30 73       	mov	r3,7
8000504a:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
8000504c:	4d 62       	lddpc	r2,800051a4 <voc_init+0x194>
			log("\r\n----create voice info okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
8000504e:	4d 76       	lddpc	r6,800051a8 <voc_init+0x198>
80005050:	30 21       	mov	r1,2
80005052:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005054:	1a 9a       	mov	r10,sp
80005056:	06 9b       	mov	r11,r3
80005058:	08 9c       	mov	r12,r4
8000505a:	f0 1f 00 55 	mcall	800051ac <voc_init+0x19c>
	if(return_code == DF_OK)
8000505e:	e0 81 00 9f 	brne	8000519c <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80005062:	06 9a       	mov	r10,r3
80005064:	1a 9b       	mov	r11,sp
80005066:	04 9c       	mov	r12,r2
80005068:	f0 1f 00 52 	mcall	800051b0 <voc_init+0x1a0>
8000506c:	c3 60       	breq	800050d8 <voc_init+0xc8>
8000506e:	c8 78       	rjmp	8000517c <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
80005070:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005074:	0e 9b       	mov	r11,r7
80005076:	0a 9c       	mov	r12,r5
80005078:	f0 1f 00 4f 	mcall	800051b4 <voc_init+0x1a4>
				if(return_code != DF_ERASE_COMPLETED)
8000507c:	58 5c       	cp.w	r12,5
8000507e:	e0 81 00 8f 	brne	8000519c <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80005082:	0c 35       	cp.w	r5,r6
80005084:	cf 61       	brne	80005070 <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005086:	30 7a       	mov	r10,7
80005088:	30 0b       	mov	r11,0
8000508a:	4c 7c       	lddpc	r12,800051a4 <voc_init+0x194>
8000508c:	f0 1f 00 4b 	mcall	800051b8 <voc_init+0x1a8>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005090:	1a 9c       	mov	r12,sp
80005092:	30 08       	mov	r8,0
80005094:	30 09       	mov	r9,0
80005096:	fa e9 00 00 	st.d	sp[0],r8
8000509a:	fa e9 00 08 	st.d	sp[8],r8
8000509e:	fa e9 00 10 	st.d	sp[16],r8
800050a2:	fa e9 00 18 	st.d	sp[24],r8
800050a6:	fa e9 00 20 	st.d	sp[32],r8
800050aa:	fa e9 00 28 	st.d	sp[40],r8
800050ae:	fa e9 00 30 	st.d	sp[48],r8
800050b2:	fa e9 00 38 	st.d	sp[56],r8
800050b6:	fa e9 00 40 	st.d	sp[64],r8
800050ba:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
800050be:	30 2a       	mov	r10,2
800050c0:	30 ab       	mov	r11,10
800050c2:	f0 1f 00 3e 	mcall	800051b8 <voc_init+0x1a8>
			if(return_code != DF_WRITE_COMPLETED)
800050c6:	58 7c       	cp.w	r12,7
800050c8:	c6 a1       	brne	8000519c <voc_init+0x18c>
			{
				return FALSE;
			}
			current_voice_index = 0;
800050ca:	30 09       	mov	r9,0
800050cc:	4b 78       	lddpc	r8,800051a8 <voc_init+0x198>
800050ce:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info okay!----\r\n");
800050d0:	4b bc       	lddpc	r12,800051bc <voc_init+0x1ac>
800050d2:	f0 1f 00 3c 	mcall	800051c0 <voc_init+0x1b0>
800050d6:	c5 c8       	rjmp	8000518e <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
800050d8:	0c 9a       	mov	r10,r6
800050da:	02 9b       	mov	r11,r1
800050dc:	00 9c       	mov	r12,r0
800050de:	f0 1f 00 34 	mcall	800051ac <voc_init+0x19c>
			if(return_code == DF_OK)
800050e2:	c5 d1       	brne	8000519c <voc_init+0x18c>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
800050e4:	8c 08       	ld.sh	r8,r6[0x0]
800050e6:	58 08       	cp.w	r8,0
800050e8:	c5 00       	breq	80005188 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
800050ea:	5c 78       	castu.h	r8
800050ec:	20 18       	sub	r8,1
800050ee:	f0 08 00 38 	add	r8,r8,r8<<0x3
800050f2:	f0 05 15 03 	lsl	r5,r8,0x3
800050f6:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
800050f8:	1a 9a       	mov	r10,sp
800050fa:	34 8b       	mov	r11,72
800050fc:	0a 9c       	mov	r12,r5
800050fe:	f0 1f 00 2c 	mcall	800051ac <voc_init+0x19c>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
80005102:	4b 1a       	lddpc	r10,800051c4 <voc_init+0x1b4>
80005104:	e0 6b 02 00 	mov	r11,512
80005108:	08 9c       	mov	r12,r4
8000510a:	f0 1f 00 29 	mcall	800051ac <voc_init+0x19c>
					if(return_code == DF_OK)
8000510e:	c3 d1       	brne	80005188 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80005110:	0f 89       	ld.ub	r9,r7[0x0]
80005112:	0f 98       	ld.ub	r8,r7[0x1]
80005114:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005118:	8c 09       	ld.sh	r9,r6[0x0]
8000511a:	f0 09 19 00 	cp.h	r9,r8
8000511e:	c2 c1       	brne	80005176 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80005120:	ef 39 00 46 	ld.ub	r9,r7[70]
80005124:	ef 38 00 47 	ld.ub	r8,r7[71]
80005128:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000512c:	ef 3a 00 42 	ld.ub	r10,r7[66]
80005130:	ef 38 00 43 	ld.ub	r8,r7[67]
80005134:	b1 68       	lsl	r8,0x10
80005136:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000513a:	ef 3a 00 44 	ld.ub	r10,r7[68]
8000513e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005142:	ef 3a 00 45 	ld.ub	r10,r7[69]
80005146:	f5 e8 10 08 	or	r8,r10,r8
8000514a:	f2 08 00 08 	add	r8,r9,r8
8000514e:	49 f9       	lddpc	r9,800051c8 <voc_init+0x1b8>
80005150:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80005152:	e0 69 c0 00 	mov	r9,49152
80005156:	ea 19 00 7b 	orh	r9,0x7b
8000515a:	12 38       	cp.w	r8,r9
8000515c:	e0 88 00 16 	brls	80005188 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
80005160:	49 bc       	lddpc	r12,800051cc <voc_init+0x1bc>
80005162:	f0 1f 00 18 	mcall	800051c0 <voc_init+0x1b0>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005166:	30 4b       	mov	r11,4
80005168:	08 9c       	mov	r12,r4
8000516a:	f0 1f 00 13 	mcall	800051b4 <voc_init+0x1a4>
								if(return_code == DF_ERASE_COMPLETED)goto start;
8000516e:	58 5c       	cp.w	r12,5
80005170:	fe 90 ff 72 	breq	80005054 <voc_init+0x44>
80005174:	c1 48       	rjmp	8000519c <voc_init+0x18c>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80005176:	49 7c       	lddpc	r12,800051d0 <voc_init+0x1c0>
80005178:	f0 1f 00 12 	mcall	800051c0 <voc_init+0x1b0>
	
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
8000517c:	e6 78 00 00 	mov	r8,458752
80005180:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005184:	30 37       	mov	r7,3
80005186:	c7 7b       	rjmp	80005074 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info okay!----\r\n");
80005188:	49 3c       	lddpc	r12,800051d4 <voc_init+0x1c4>
8000518a:	f0 1f 00 0e 	mcall	800051c0 <voc_init+0x1b0>
			}
			else
			return FALSE;
		}
		
		memcpy(voice_count_ptr, &current_voice_index, sizeof(current_voice_index));
8000518e:	48 78       	lddpc	r8,800051a8 <voc_init+0x198>
80005190:	90 09       	ld.sh	r9,r8[0x0]
80005192:	49 28       	lddpc	r8,800051d8 <voc_init+0x1c8>
80005194:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
80005196:	30 19       	mov	r9,1
80005198:	49 18       	lddpc	r8,800051dc <voc_init+0x1cc>
8000519a:	b0 89       	st.b	r8[0x0],r9
	//create_data_flash_test_task();
	voice_list_info_init(Current_total_voice);
	
	//voc_read_write_test();

8000519c:	2e cd       	sub	sp,-80
8000519e:	d8 32       	popm	r0-r7,pc
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	2d 8c       	sub	r12,-40
800051a4:	00 00       	add	r0,r0
800051a6:	05 24       	ld.uh	r4,r2++
800051a8:	00 00       	add	r0,r0
800051aa:	0b 64       	ld.uh	r4,--r5
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	2a 6c       	sub	r12,-90
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	72 f0       	ld.w	r0,r9[0x3c]
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	2c 00       	sub	r0,-64
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	2c 9c       	sub	r12,-55
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	d2 10       	acall	0x21
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	6a 5c       	ld.w	r12,r5[0x14]
800051c4:	00 00       	add	r0,r0
800051c6:	51 08       	stdsp	sp[0x40],r8
800051c8:	00 00       	add	r0,r0
800051ca:	05 2c       	ld.uh	r12,r2++
800051cc:	80 00       	ld.sh	r0,r0[0x0]
800051ce:	d2 34       	*unknown*
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	d2 5c       	*unknown*
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	d2 80       	acall	0x28
800051d8:	00 00       	add	r0,r0
800051da:	0b 68       	ld.uh	r8,--r5
800051dc:	00 00       	add	r0,r0
800051de:	0b 66       	ld.uh	r6,--r5

800051e0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800051e0:	f8 08 16 05 	lsr	r8,r12,0x5
800051e4:	a9 68       	lsl	r8,0x8
800051e6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800051ea:	58 1b       	cp.w	r11,1
800051ec:	c0 d0       	breq	80005206 <gpio_enable_module_pin+0x26>
800051ee:	c0 63       	brcs	800051fa <gpio_enable_module_pin+0x1a>
800051f0:	58 2b       	cp.w	r11,2
800051f2:	c1 00       	breq	80005212 <gpio_enable_module_pin+0x32>
800051f4:	58 3b       	cp.w	r11,3
800051f6:	c1 40       	breq	8000521e <gpio_enable_module_pin+0x3e>
800051f8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800051fa:	30 19       	mov	r9,1
800051fc:	f2 0c 09 49 	lsl	r9,r9,r12
80005200:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005202:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005204:	c1 28       	rjmp	80005228 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005206:	30 19       	mov	r9,1
80005208:	f2 0c 09 49 	lsl	r9,r9,r12
8000520c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000520e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005210:	c0 c8       	rjmp	80005228 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005212:	30 19       	mov	r9,1
80005214:	f2 0c 09 49 	lsl	r9,r9,r12
80005218:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000521a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000521c:	c0 68       	rjmp	80005228 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000521e:	30 19       	mov	r9,1
80005220:	f2 0c 09 49 	lsl	r9,r9,r12
80005224:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005226:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005228:	30 19       	mov	r9,1
8000522a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000522e:	91 2c       	st.w	r8[0x8],r12
80005230:	5e fd       	retal	0
80005232:	d7 03       	nop

80005234 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005234:	d4 21       	pushm	r4-r7,lr
80005236:	18 97       	mov	r7,r12
80005238:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000523a:	58 0b       	cp.w	r11,0
8000523c:	c0 31       	brne	80005242 <gpio_enable_module+0xe>
8000523e:	30 05       	mov	r5,0
80005240:	c0 d8       	rjmp	8000525a <gpio_enable_module+0x26>
80005242:	30 06       	mov	r6,0
80005244:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005246:	6e 1b       	ld.w	r11,r7[0x4]
80005248:	6e 0c       	ld.w	r12,r7[0x0]
8000524a:	f0 1f 00 06 	mcall	80005260 <gpio_enable_module+0x2c>
8000524e:	18 45       	or	r5,r12
		gpiomap++;
80005250:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005252:	2f f6       	sub	r6,-1
80005254:	0c 34       	cp.w	r4,r6
80005256:	fe 9b ff f8 	brhi	80005246 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000525a:	0a 9c       	mov	r12,r5
8000525c:	d8 22       	popm	r4-r7,pc
8000525e:	00 00       	add	r0,r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	51 e0       	stdsp	sp[0x78],r0

80005264 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005264:	f8 08 16 05 	lsr	r8,r12,0x5
80005268:	a9 68       	lsl	r8,0x8
8000526a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000526e:	30 19       	mov	r9,1
80005270:	f2 0c 09 4c 	lsl	r12,r9,r12
80005274:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005278:	91 1c       	st.w	r8[0x4],r12
}
8000527a:	5e fc       	retal	r12

8000527c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000527c:	f8 08 16 05 	lsr	r8,r12,0x5
80005280:	a9 68       	lsl	r8,0x8
80005282:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005286:	30 19       	mov	r9,1
80005288:	f2 0c 09 4c 	lsl	r12,r9,r12
8000528c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005290:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005294:	91 1c       	st.w	r8[0x4],r12
}
80005296:	5e fc       	retal	r12

80005298 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005298:	c0 08       	rjmp	80005298 <_unhandled_interrupt>
8000529a:	d7 03       	nop

8000529c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000529c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800052a0:	49 99       	lddpc	r9,80005304 <INTC_register_interrupt+0x68>
800052a2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800052a6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800052aa:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800052ac:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800052b0:	58 0a       	cp.w	r10,0
800052b2:	c0 91       	brne	800052c4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800052b4:	49 59       	lddpc	r9,80005308 <INTC_register_interrupt+0x6c>
800052b6:	49 6a       	lddpc	r10,8000530c <INTC_register_interrupt+0x70>
800052b8:	12 1a       	sub	r10,r9
800052ba:	fe 79 08 00 	mov	r9,-63488
800052be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800052c2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800052c4:	58 1a       	cp.w	r10,1
800052c6:	c0 a1       	brne	800052da <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800052c8:	49 09       	lddpc	r9,80005308 <INTC_register_interrupt+0x6c>
800052ca:	49 2a       	lddpc	r10,80005310 <INTC_register_interrupt+0x74>
800052cc:	12 1a       	sub	r10,r9
800052ce:	bf aa       	sbr	r10,0x1e
800052d0:	fe 79 08 00 	mov	r9,-63488
800052d4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800052d8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800052da:	58 2a       	cp.w	r10,2
800052dc:	c0 a1       	brne	800052f0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800052de:	48 b9       	lddpc	r9,80005308 <INTC_register_interrupt+0x6c>
800052e0:	48 da       	lddpc	r10,80005314 <INTC_register_interrupt+0x78>
800052e2:	12 1a       	sub	r10,r9
800052e4:	bf ba       	sbr	r10,0x1f
800052e6:	fe 79 08 00 	mov	r9,-63488
800052ea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800052ee:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800052f0:	48 69       	lddpc	r9,80005308 <INTC_register_interrupt+0x6c>
800052f2:	48 aa       	lddpc	r10,80005318 <INTC_register_interrupt+0x7c>
800052f4:	12 1a       	sub	r10,r9
800052f6:	ea 1a c0 00 	orh	r10,0xc000
800052fa:	fe 79 08 00 	mov	r9,-63488
800052fe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005302:	5e fc       	retal	r12
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	d2 a4       	*unknown*
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	c8 00       	breq	8000520a <gpio_enable_module_pin+0x2a>
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	c9 04       	brge	8000522e <gpio_enable_module_pin+0x4e>
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	c9 12       	brcc	80005234 <gpio_enable_module>
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	c9 20       	breq	8000523a <gpio_enable_module+0x6>
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	c9 2e       	rcall	8000503e <voc_init+0x2e>

8000531c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000531c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000531e:	49 18       	lddpc	r8,80005360 <INTC_init_interrupts+0x44>
80005320:	e3 b8 00 01 	mtsr	0x4,r8
80005324:	49 0e       	lddpc	lr,80005364 <INTC_init_interrupts+0x48>
80005326:	30 07       	mov	r7,0
80005328:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000532a:	49 0c       	lddpc	r12,80005368 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000532c:	49 05       	lddpc	r5,8000536c <INTC_init_interrupts+0x50>
8000532e:	10 15       	sub	r5,r8
80005330:	fe 76 08 00 	mov	r6,-63488
80005334:	c1 08       	rjmp	80005354 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005336:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005338:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000533a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000533c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005340:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005342:	10 3a       	cp.w	r10,r8
80005344:	fe 9b ff fc 	brhi	8000533c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005348:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000534c:	2f f7       	sub	r7,-1
8000534e:	2f 8e       	sub	lr,-8
80005350:	59 37       	cp.w	r7,19
80005352:	c0 50       	breq	8000535c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005354:	7c 08       	ld.w	r8,lr[0x0]
80005356:	58 08       	cp.w	r8,0
80005358:	ce f1       	brne	80005336 <INTC_init_interrupts+0x1a>
8000535a:	cf 7b       	rjmp	80005348 <INTC_init_interrupts+0x2c>
8000535c:	d8 22       	popm	r4-r7,pc
8000535e:	00 00       	add	r0,r0
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	c8 00       	breq	80005262 <gpio_enable_module+0x2e>
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	d2 a4       	*unknown*
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	52 98       	stdsp	sp[0xa4],r8
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	c9 04       	brge	8000528e <gpio_set_gpio_pin+0x12>

80005370 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005370:	fe 78 08 00 	mov	r8,-63488
80005374:	e0 69 00 83 	mov	r9,131
80005378:	f2 0c 01 0c 	sub	r12,r9,r12
8000537c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005380:	f2 ca ff c0 	sub	r10,r9,-64
80005384:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005388:	58 08       	cp.w	r8,0
8000538a:	c0 21       	brne	8000538e <_get_interrupt_handler+0x1e>
8000538c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000538e:	f0 08 12 00 	clz	r8,r8
80005392:	48 5a       	lddpc	r10,800053a4 <_get_interrupt_handler+0x34>
80005394:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005398:	f0 08 11 1f 	rsub	r8,r8,31
8000539c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000539e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800053a2:	5e fc       	retal	r12
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	d2 a4       	*unknown*

800053a8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800053a8:	f8 c8 00 01 	sub	r8,r12,1
800053ac:	f0 0b 00 0b 	add	r11,r8,r11
800053b0:	f6 0c 0d 0a 	divu	r10,r11,r12
800053b4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800053b6:	f4 c8 00 01 	sub	r8,r10,1
800053ba:	e0 48 00 fe 	cp.w	r8,254
800053be:	e0 88 00 03 	brls	800053c4 <getBaudDiv+0x1c>
800053c2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800053c4:	5c 8c       	casts.h	r12
}
800053c6:	5e fc       	retal	r12

800053c8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800053c8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800053cc:	30 18       	mov	r8,1
800053ce:	f0 09 18 00 	cp.b	r9,r8
800053d2:	e0 88 00 04 	brls	800053da <spi_initMaster+0x12>
800053d6:	30 2c       	mov	r12,2
800053d8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800053da:	e0 68 00 80 	mov	r8,128
800053de:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800053e0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800053e2:	30 19       	mov	r9,1
800053e4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800053e8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800053ec:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800053f0:	30 09       	mov	r9,0
800053f2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800053f6:	30 fa       	mov	r10,15
800053f8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800053fc:	99 18       	st.w	r12[0x4],r8
800053fe:	5e f9       	retal	r9

80005400 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005400:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005402:	30 18       	mov	r8,1
80005404:	f0 0b 18 00 	cp.b	r11,r8
80005408:	5f be       	srhi	lr
8000540a:	f0 0a 18 00 	cp.b	r10,r8
8000540e:	5f b8       	srhi	r8
80005410:	fd e8 10 08 	or	r8,lr,r8
80005414:	c0 30       	breq	8000541a <spi_selectionMode+0x1a>
80005416:	30 2c       	mov	r12,2
80005418:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000541a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000541c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005420:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005424:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005428:	99 18       	st.w	r12[0x4],r8
8000542a:	d8 0a       	popm	pc,r12=0

8000542c <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000542c:	78 18       	ld.w	r8,r12[0x4]
8000542e:	ea 18 00 0f 	orh	r8,0xf
80005432:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005434:	78 18       	ld.w	r8,r12[0x4]
80005436:	e2 18 00 04 	andl	r8,0x4,COH
8000543a:	c0 f0       	breq	80005458 <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000543c:	30 e8       	mov	r8,14
8000543e:	f0 0b 18 00 	cp.b	r11,r8
80005442:	e0 8b 00 19 	brhi	80005474 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005446:	78 18       	ld.w	r8,r12[0x4]
80005448:	b1 6b       	lsl	r11,0x10
8000544a:	ea 1b ff f0 	orh	r11,0xfff0
8000544e:	e8 1b ff ff 	orl	r11,0xffff
80005452:	10 6b       	and	r11,r8
80005454:	99 1b       	st.w	r12[0x4],r11
80005456:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005458:	30 38       	mov	r8,3
8000545a:	f0 0b 18 00 	cp.b	r11,r8
8000545e:	e0 8b 00 0b 	brhi	80005474 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005462:	78 18       	ld.w	r8,r12[0x4]
80005464:	2f 0b       	sub	r11,-16
80005466:	30 19       	mov	r9,1
80005468:	f2 0b 09 4b 	lsl	r11,r9,r11
8000546c:	5c db       	com	r11
8000546e:	10 6b       	and	r11,r8
80005470:	99 1b       	st.w	r12[0x4],r11
80005472:	5e fd       	retal	0
80005474:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005476:	5e fc       	retal	r12

80005478 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005478:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000547c:	c0 58       	rjmp	80005486 <spi_unselectChip+0xe>
		if (!timeout--) {
8000547e:	58 08       	cp.w	r8,0
80005480:	c0 21       	brne	80005484 <spi_unselectChip+0xc>
80005482:	5e ff       	retal	1
80005484:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005486:	78 49       	ld.w	r9,r12[0x10]
80005488:	e2 19 02 00 	andl	r9,0x200,COH
8000548c:	cf 90       	breq	8000547e <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000548e:	78 18       	ld.w	r8,r12[0x4]
80005490:	ea 18 00 0f 	orh	r8,0xf
80005494:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005496:	fc 18 01 00 	movh	r8,0x100
8000549a:	99 08       	st.w	r12[0x0],r8
8000549c:	5e fd       	retal	0
8000549e:	d7 03       	nop

800054a0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800054a0:	eb cd 40 f8 	pushm	r3-r7,lr
800054a4:	18 95       	mov	r5,r12
800054a6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800054a8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800054ac:	30 38       	mov	r8,3
800054ae:	f0 06 18 00 	cp.b	r6,r8
800054b2:	e0 8b 00 4d 	brhi	8000554c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
800054b6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800054ba:	30 18       	mov	r8,1
800054bc:	f0 04 18 00 	cp.b	r4,r8
800054c0:	e0 8b 00 46 	brhi	8000554c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800054c4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800054c8:	30 78       	mov	r8,7
800054ca:	f0 03 18 00 	cp.b	r3,r8
800054ce:	e0 88 00 3f 	brls	8000554c <spi_setupChipReg+0xac>
800054d2:	31 08       	mov	r8,16
800054d4:	f0 03 18 00 	cp.b	r3,r8
800054d8:	e0 8b 00 3a 	brhi	8000554c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800054dc:	14 9b       	mov	r11,r10
800054de:	6e 1c       	ld.w	r12,r7[0x4]
800054e0:	f0 1f 00 1d 	mcall	80005554 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
800054e4:	c3 45       	brlt	8000554c <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800054e6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800054e8:	ec 09 16 01 	lsr	r9,r6,0x1
800054ec:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800054f0:	ec 16 00 01 	eorl	r6,0x1
800054f4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800054f8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800054fc:	20 83       	sub	r3,8
800054fe:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005502:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005506:	ef 39 00 09 	ld.ub	r9,r7[9]
8000550a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000550e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005512:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005516:	0f 89       	ld.ub	r9,r7[0x0]
80005518:	30 1a       	mov	r10,1
8000551a:	f4 09 18 00 	cp.b	r9,r10
8000551e:	c0 e0       	breq	8000553a <spi_setupChipReg+0x9a>
80005520:	c0 a3       	brcs	80005534 <spi_setupChipReg+0x94>
80005522:	30 2a       	mov	r10,2
80005524:	f4 09 18 00 	cp.b	r9,r10
80005528:	c0 c0       	breq	80005540 <spi_setupChipReg+0xa0>
8000552a:	30 3a       	mov	r10,3
8000552c:	f4 09 18 00 	cp.b	r9,r10
80005530:	c0 e1       	brne	8000554c <spi_setupChipReg+0xac>
80005532:	c0 a8       	rjmp	80005546 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005534:	8b c8       	st.w	r5[0x30],r8
80005536:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000553a:	8b d8       	st.w	r5[0x34],r8
8000553c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005540:	8b e8       	st.w	r5[0x38],r8
80005542:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005546:	8b f8       	st.w	r5[0x3c],r8
80005548:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
8000554c:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
8000554e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005552:	00 00       	add	r0,r0
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	53 a8       	stdsp	sp[0xe8],r8

80005558 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005558:	30 18       	mov	r8,1
8000555a:	99 08       	st.w	r12[0x0],r8
}
8000555c:	5e fc       	retal	r12

8000555e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000555e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005562:	c0 58       	rjmp	8000556c <spi_write+0xe>
		if (!timeout--) {
80005564:	58 08       	cp.w	r8,0
80005566:	c0 21       	brne	8000556a <spi_write+0xc>
80005568:	5e ff       	retal	1
8000556a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000556c:	78 49       	ld.w	r9,r12[0x10]
8000556e:	e2 19 00 02 	andl	r9,0x2,COH
80005572:	cf 90       	breq	80005564 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005574:	5c 7b       	castu.h	r11
80005576:	99 3b       	st.w	r12[0xc],r11
80005578:	5e fd       	retal	0

8000557a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000557a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000557e:	c0 58       	rjmp	80005588 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005580:	58 08       	cp.w	r8,0
80005582:	c0 21       	brne	80005586 <spi_read+0xc>
80005584:	5e ff       	retal	1
80005586:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005588:	78 49       	ld.w	r9,r12[0x10]
8000558a:	e2 19 02 01 	andl	r9,0x201,COH
8000558e:	e0 49 02 01 	cp.w	r9,513
80005592:	cf 71       	brne	80005580 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005594:	78 28       	ld.w	r8,r12[0x8]
80005596:	b6 08       	st.h	r11[0x0],r8
80005598:	5e fd       	retal	0

8000559a <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000559a:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000559c:	f6 08 15 04 	lsl	r8,r11,0x4
800055a0:	14 38       	cp.w	r8,r10
800055a2:	f9 b8 08 10 	movls	r8,16
800055a6:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800055aa:	f0 0b 02 4b 	mul	r11,r8,r11
800055ae:	f6 09 16 01 	lsr	r9,r11,0x1
800055b2:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800055b6:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800055ba:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800055be:	f2 cb 00 01 	sub	r11,r9,1
800055c2:	e0 4b ff fe 	cp.w	r11,65534
800055c6:	e0 88 00 03 	brls	800055cc <usart_set_async_baudrate+0x32>
800055ca:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800055cc:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800055ce:	e8 6e 00 00 	mov	lr,524288
800055d2:	59 08       	cp.w	r8,16
800055d4:	fc 08 17 10 	movne	r8,lr
800055d8:	f9 b8 00 00 	moveq	r8,0
800055dc:	e4 1b ff f7 	andh	r11,0xfff7
800055e0:	e0 1b fe cf 	andl	r11,0xfecf
800055e4:	16 48       	or	r8,r11
800055e6:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800055e8:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800055ec:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800055f0:	99 89       	st.w	r12[0x20],r9
800055f2:	d8 0a       	popm	pc,r12=0

800055f4 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800055f4:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800055f6:	e2 18 00 02 	andl	r8,0x2,COH
800055fa:	c0 31       	brne	80005600 <usart_write_char+0xc>
800055fc:	30 2c       	mov	r12,2
800055fe:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005600:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005604:	99 7b       	st.w	r12[0x1c],r11
80005606:	5e fd       	retal	0

80005608 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005608:	eb cd 40 e0 	pushm	r5-r7,lr
8000560c:	18 96       	mov	r6,r12
8000560e:	16 95       	mov	r5,r11
80005610:	e0 67 27 0f 	mov	r7,9999
80005614:	c0 68       	rjmp	80005620 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005616:	58 07       	cp.w	r7,0
80005618:	c0 31       	brne	8000561e <usart_putchar+0x16>
8000561a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000561e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005620:	0a 9b       	mov	r11,r5
80005622:	0c 9c       	mov	r12,r6
80005624:	f0 1f 00 03 	mcall	80005630 <usart_putchar+0x28>
80005628:	cf 71       	brne	80005616 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000562a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000562e:	00 00       	add	r0,r0
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	55 f4       	stdsp	sp[0x17c],r4

80005634 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005634:	78 58       	ld.w	r8,r12[0x14]
80005636:	e2 18 00 e0 	andl	r8,0xe0,COH
8000563a:	c0 30       	breq	80005640 <usart_read_char+0xc>
8000563c:	30 4c       	mov	r12,4
8000563e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005640:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005642:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005646:	c0 31       	brne	8000564c <usart_read_char+0x18>
80005648:	30 3c       	mov	r12,3
8000564a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000564c:	78 68       	ld.w	r8,r12[0x18]
8000564e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005652:	97 08       	st.w	r11[0x0],r8
80005654:	5e fd       	retal	0
80005656:	d7 03       	nop

80005658 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005658:	eb cd 40 c0 	pushm	r6-r7,lr
8000565c:	20 1d       	sub	sp,4
8000565e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005660:	1a 97       	mov	r7,sp
80005662:	1a 9b       	mov	r11,sp
80005664:	0c 9c       	mov	r12,r6
80005666:	f0 1f 00 07 	mcall	80005680 <usart_getchar+0x28>
8000566a:	58 3c       	cp.w	r12,3
8000566c:	cf b0       	breq	80005662 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000566e:	58 4c       	cp.w	r12,4
80005670:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005674:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005678:	2f fd       	sub	sp,-4
8000567a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000567e:	00 00       	add	r0,r0
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	56 34       	stdsp	sp[0x18c],r4

80005684 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005684:	eb cd 40 c0 	pushm	r6-r7,lr
80005688:	18 96       	mov	r6,r12
8000568a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000568c:	17 8b       	ld.ub	r11,r11[0x0]
8000568e:	58 0b       	cp.w	r11,0
80005690:	c0 80       	breq	800056a0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005692:	2f f7       	sub	r7,-1
80005694:	0c 9c       	mov	r12,r6
80005696:	f0 1f 00 04 	mcall	800056a4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000569a:	0f 8b       	ld.ub	r11,r7[0x0]
8000569c:	58 0b       	cp.w	r11,0
8000569e:	cf a1       	brne	80005692 <usart_write_line+0xe>
800056a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	56 08       	stdsp	sp[0x180],r8

800056a8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800056a8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800056ac:	e6 18 00 01 	andh	r8,0x1,COH
800056b0:	c0 71       	brne	800056be <usart_reset+0x16>
800056b2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800056b4:	3f f8       	mov	r8,-1
800056b6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800056b8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800056ba:	d5 03       	csrf	0x10
800056bc:	c0 48       	rjmp	800056c4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800056be:	3f f8       	mov	r8,-1
800056c0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800056c2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800056c4:	30 08       	mov	r8,0
800056c6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800056c8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800056ca:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800056cc:	ea 68 61 0c 	mov	r8,680204
800056d0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800056d2:	5e fc       	retal	r12

800056d4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800056d4:	eb cd 40 e0 	pushm	r5-r7,lr
800056d8:	18 96       	mov	r6,r12
800056da:	16 97       	mov	r7,r11
800056dc:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800056de:	f0 1f 00 2f 	mcall	80005798 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800056e2:	58 07       	cp.w	r7,0
800056e4:	c5 80       	breq	80005794 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800056e6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800056e8:	30 49       	mov	r9,4
800056ea:	f2 08 18 00 	cp.b	r8,r9
800056ee:	e0 88 00 53 	brls	80005794 <usart_init_rs232+0xc0>
800056f2:	30 99       	mov	r9,9
800056f4:	f2 08 18 00 	cp.b	r8,r9
800056f8:	e0 8b 00 4e 	brhi	80005794 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800056fc:	0f d9       	ld.ub	r9,r7[0x5]
800056fe:	30 78       	mov	r8,7
80005700:	f0 09 18 00 	cp.b	r9,r8
80005704:	e0 8b 00 48 	brhi	80005794 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005708:	8e 39       	ld.sh	r9,r7[0x6]
8000570a:	e0 68 01 01 	mov	r8,257
8000570e:	f0 09 19 00 	cp.h	r9,r8
80005712:	e0 8b 00 41 	brhi	80005794 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005716:	ef 39 00 08 	ld.ub	r9,r7[8]
8000571a:	30 38       	mov	r8,3
8000571c:	f0 09 18 00 	cp.b	r9,r8
80005720:	e0 8b 00 3a 	brhi	80005794 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005724:	0a 9a       	mov	r10,r5
80005726:	6e 0b       	ld.w	r11,r7[0x0]
80005728:	0c 9c       	mov	r12,r6
8000572a:	f0 1f 00 1d 	mcall	8000579c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000572e:	58 1c       	cp.w	r12,1
80005730:	c3 20       	breq	80005794 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005732:	0f c8       	ld.ub	r8,r7[0x4]
80005734:	30 99       	mov	r9,9
80005736:	f2 08 18 00 	cp.b	r8,r9
8000573a:	c0 51       	brne	80005744 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000573c:	6c 18       	ld.w	r8,r6[0x4]
8000573e:	b1 b8       	sbr	r8,0x11
80005740:	8d 18       	st.w	r6[0x4],r8
80005742:	c0 68       	rjmp	8000574e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005744:	6c 19       	ld.w	r9,r6[0x4]
80005746:	20 58       	sub	r8,5
80005748:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000574c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000574e:	6c 19       	ld.w	r9,r6[0x4]
80005750:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005754:	0f d8       	ld.ub	r8,r7[0x5]
80005756:	a9 78       	lsl	r8,0x9
80005758:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000575c:	12 48       	or	r8,r9
8000575e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005760:	8e 38       	ld.sh	r8,r7[0x6]
80005762:	30 29       	mov	r9,2
80005764:	f2 08 19 00 	cp.h	r8,r9
80005768:	e0 88 00 09 	brls	8000577a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000576c:	6c 18       	ld.w	r8,r6[0x4]
8000576e:	ad b8       	sbr	r8,0xd
80005770:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005772:	8e b8       	ld.uh	r8,r7[0x6]
80005774:	20 28       	sub	r8,2
80005776:	8d a8       	st.w	r6[0x28],r8
80005778:	c0 68       	rjmp	80005784 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000577a:	6c 19       	ld.w	r9,r6[0x4]
8000577c:	5c 78       	castu.h	r8
8000577e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005782:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005784:	6c 18       	ld.w	r8,r6[0x4]
80005786:	e0 18 ff f0 	andl	r8,0xfff0
8000578a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000578c:	35 08       	mov	r8,80
8000578e:	8d 08       	st.w	r6[0x0],r8
80005790:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005794:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	56 a8       	stdsp	sp[0x1a8],r8
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	55 9a       	stdsp	sp[0x164],r10

800057a0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800057a0:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800057a4:	fe c0 8f a4 	sub	r0,pc,-28764

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800057a8:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800057ac:	d5 53       	csrf	0x15
  cp      r0, r1
800057ae:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
800057b0:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800057b4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800057b6:	c0 62       	brcc	800057c2 <idata_load_loop_end>
  cp      r0, r1
800057b8:	48 92       	lddpc	r2,800057dc <udata_clear_loop_end+0x4>

800057ba <idata_load_loop>:
  brlo    idata_load_loop
800057ba:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800057bc:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
800057be:	02 30       	cp.w	r0,r1
  cp      r0, r1
800057c0:	cf d3       	brcs	800057ba <idata_load_loop>

800057c2 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
800057c2:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
800057c6:	e0 61 63 a8 	mov	r1,25512
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
800057ca:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
800057cc:	c0 62       	brcc	800057d8 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800057ce:	30 02       	mov	r2,0
800057d0:	30 03       	mov	r3,0

800057d2 <udata_clear_loop>:
800057d2:	a1 22       	st.d	r0++,r2
800057d4:	02 30       	cp.w	r0,r1
800057d6:	cf e3       	brcs	800057d2 <udata_clear_loop>

800057d8 <udata_clear_loop_end>:
800057d8:	fe cf e9 c4 	sub	pc,pc,-5692
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	db d8       	*unknown*

800057e0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800057e0:	f8 c8 ff f8 	sub	r8,r12,-8
800057e4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800057e6:	3f f9       	mov	r9,-1
800057e8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800057ea:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800057ec:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800057ee:	30 08       	mov	r8,0
800057f0:	99 08       	st.w	r12[0x0],r8
}
800057f2:	5e fc       	retal	r12

800057f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800057f4:	30 08       	mov	r8,0
800057f6:	99 48       	st.w	r12[0x10],r8
}
800057f8:	5e fc       	retal	r12

800057fa <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800057fa:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800057fc:	70 19       	ld.w	r9,r8[0x4]
800057fe:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005800:	78 19       	ld.w	r9,r12[0x4]
80005802:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005804:	70 19       	ld.w	r9,r8[0x4]
80005806:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005808:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000580a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000580c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000580e:	78 08       	ld.w	r8,r12[0x0]
80005810:	2f f8       	sub	r8,-1
80005812:	99 08       	st.w	r12[0x0],r8
}
80005814:	5e fc       	retal	r12

80005816 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005816:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005818:	5b fa       	cp.w	r10,-1
8000581a:	c0 31       	brne	80005820 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000581c:	78 48       	ld.w	r8,r12[0x10]
8000581e:	c0 c8       	rjmp	80005836 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005820:	f8 c8 ff f8 	sub	r8,r12,-8
80005824:	70 19       	ld.w	r9,r8[0x4]
80005826:	72 09       	ld.w	r9,r9[0x0]
80005828:	12 3a       	cp.w	r10,r9
8000582a:	c0 63       	brcs	80005836 <vListInsert+0x20>
8000582c:	70 18       	ld.w	r8,r8[0x4]
8000582e:	70 19       	ld.w	r9,r8[0x4]
80005830:	72 09       	ld.w	r9,r9[0x0]
80005832:	12 3a       	cp.w	r10,r9
80005834:	cf c2       	brcc	8000582c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005836:	70 19       	ld.w	r9,r8[0x4]
80005838:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000583a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
8000583c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000583e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005840:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005842:	78 08       	ld.w	r8,r12[0x0]
80005844:	2f f8       	sub	r8,-1
80005846:	99 08       	st.w	r12[0x0],r8
}
80005848:	5e fc       	retal	r12

8000584a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000584a:	78 18       	ld.w	r8,r12[0x4]
8000584c:	78 29       	ld.w	r9,r12[0x8]
8000584e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005850:	78 28       	ld.w	r8,r12[0x8]
80005852:	78 19       	ld.w	r9,r12[0x4]
80005854:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005856:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005858:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000585a:	18 39       	cp.w	r9,r12
8000585c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005860:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005864:	30 09       	mov	r9,0
80005866:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005868:	70 09       	ld.w	r9,r8[0x0]
8000586a:	20 19       	sub	r9,1
8000586c:	91 09       	st.w	r8[0x0],r9
}
8000586e:	5e fc       	retal	r12

80005870 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005870:	e0 68 08 08 	mov	r8,2056
80005874:	ea 18 08 08 	orh	r8,0x808
80005878:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000587a:	e0 68 09 09 	mov	r8,2313
8000587e:	ea 18 09 09 	orh	r8,0x909
80005882:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005884:	e0 68 0a 0a 	mov	r8,2570
80005888:	ea 18 0a 0a 	orh	r8,0xa0a
8000588c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000588e:	e0 68 0b 0b 	mov	r8,2827
80005892:	ea 18 0b 0b 	orh	r8,0xb0b
80005896:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005898:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000589a:	e0 68 be ef 	mov	r8,48879
8000589e:	ea 18 de ad 	orh	r8,0xdead
800058a2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800058a4:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800058a6:	fc 18 00 40 	movh	r8,0x40
800058aa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800058ac:	e0 68 00 ff 	mov	r8,255
800058b0:	ea 18 ff 00 	orh	r8,0xff00
800058b4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800058b6:	e0 68 01 01 	mov	r8,257
800058ba:	ea 18 01 01 	orh	r8,0x101
800058be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800058c0:	e0 68 02 02 	mov	r8,514
800058c4:	ea 18 02 02 	orh	r8,0x202
800058c8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800058ca:	e0 68 03 03 	mov	r8,771
800058ce:	ea 18 03 03 	orh	r8,0x303
800058d2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800058d4:	e0 68 04 04 	mov	r8,1028
800058d8:	ea 18 04 04 	orh	r8,0x404
800058dc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800058de:	e0 68 05 05 	mov	r8,1285
800058e2:	ea 18 05 05 	orh	r8,0x505
800058e6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800058e8:	e0 68 06 06 	mov	r8,1542
800058ec:	ea 18 06 06 	orh	r8,0x606
800058f0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800058f2:	e0 68 07 07 	mov	r8,1799
800058f6:	ea 18 07 07 	orh	r8,0x707
800058fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800058fc:	30 08       	mov	r8,0
800058fe:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005900:	5e fc       	retal	r12
80005902:	d7 03       	nop

80005904 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005904:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005906:	48 38       	lddpc	r8,80005910 <vPortEnterCritical+0xc>
80005908:	70 09       	ld.w	r9,r8[0x0]
8000590a:	2f f9       	sub	r9,-1
8000590c:	91 09       	st.w	r8[0x0],r9
}
8000590e:	5e fc       	retal	r12
80005910:	00 00       	add	r0,r0
80005912:	05 30       	ld.ub	r0,r2++

80005914 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005914:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005916:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005918:	30 0a       	mov	r10,0
8000591a:	14 9b       	mov	r11,r10
8000591c:	49 2c       	lddpc	r12,80005964 <xPortStartScheduler+0x50>
8000591e:	f0 1f 00 13 	mcall	80005968 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005922:	e0 68 5d c0 	mov	r8,24000
80005926:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000592a:	30 08       	mov	r8,0
8000592c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005930:	e0 68 0c e4 	mov	r8,3300
80005934:	ea 18 00 00 	orh	r8,0x0
80005938:	70 00       	ld.w	r0,r8[0x0]
8000593a:	60 0d       	ld.w	sp,r0[0x0]
8000593c:	1b 00       	ld.w	r0,sp++
8000593e:	e0 68 05 30 	mov	r8,1328
80005942:	ea 18 00 00 	orh	r8,0x0
80005946:	91 00       	st.w	r8[0x0],r0
80005948:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000594c:	2f ed       	sub	sp,-8
8000594e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005952:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005956:	e3 b0 00 00 	mtsr	0x0,r0
8000595a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000595e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005962:	d8 0a       	popm	pc,r12=0
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	5a 30       	cp.w	r0,-29
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	52 9c       	stdsp	sp[0xa4],r12

8000596c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000596c:	20 6d       	sub	sp,24
8000596e:	eb cd 00 ff 	pushm	r0-r7
80005972:	fa c7 ff c0 	sub	r7,sp,-64
80005976:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000597a:	ef 40 ff e0 	st.w	r7[-32],r0
8000597e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005982:	ef 40 ff e4 	st.w	r7[-28],r0
80005986:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000598a:	e0 68 05 30 	mov	r8,1328
8000598e:	ea 18 00 00 	orh	r8,0x0
80005992:	70 00       	ld.w	r0,r8[0x0]
80005994:	1a d0       	st.w	--sp,r0
80005996:	f0 1f 00 1a 	mcall	800059fc <LABEL_RET_SCALL_263+0x14>
8000599a:	e0 68 0c e4 	mov	r8,3300
8000599e:	ea 18 00 00 	orh	r8,0x0
800059a2:	70 00       	ld.w	r0,r8[0x0]
800059a4:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800059a6:	f0 1f 00 17 	mcall	80005a00 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800059aa:	e0 68 0c e4 	mov	r8,3300
800059ae:	ea 18 00 00 	orh	r8,0x0
800059b2:	70 00       	ld.w	r0,r8[0x0]
800059b4:	60 0d       	ld.w	sp,r0[0x0]
800059b6:	1b 00       	ld.w	r0,sp++
800059b8:	e0 68 05 30 	mov	r8,1328
800059bc:	ea 18 00 00 	orh	r8,0x0
800059c0:	91 00       	st.w	r8[0x0],r0
800059c2:	fa c7 ff d8 	sub	r7,sp,-40
800059c6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800059ca:	ee f0 ff e0 	ld.w	r0,r7[-32]
800059ce:	e0 61 05 30 	mov	r1,1328
800059d2:	ea 11 00 00 	orh	r1,0x0
800059d6:	62 02       	ld.w	r2,r1[0x0]
800059d8:	58 02       	cp.w	r2,0
800059da:	c0 70       	breq	800059e8 <LABEL_RET_SCALL_263>
800059dc:	e4 c2 00 01 	sub	r2,r2,1
800059e0:	83 02       	st.w	r1[0x0],r2
800059e2:	58 02       	cp.w	r2,0
800059e4:	c0 21       	brne	800059e8 <LABEL_RET_SCALL_263>
800059e6:	b1 c0       	cbr	r0,0x10

800059e8 <LABEL_RET_SCALL_263>:
800059e8:	ef 40 ff f8 	st.w	r7[-8],r0
800059ec:	ee f0 ff e4 	ld.w	r0,r7[-28]
800059f0:	ef 40 ff fc 	st.w	r7[-4],r0
800059f4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800059f8:	2f ad       	sub	sp,-24
800059fa:	d6 13       	rets
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	59 04       	cp.w	r4,16
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	60 48       	ld.w	r8,r0[0x10]

80005a04 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005a04:	e1 b8 00 43 	mfsr	r8,0x10c
80005a08:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005a0c:	5e fc       	retal	r12
80005a0e:	d7 03       	nop

80005a10 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005a10:	48 78       	lddpc	r8,80005a2c <vPortExitCritical+0x1c>
80005a12:	70 08       	ld.w	r8,r8[0x0]
80005a14:	58 08       	cp.w	r8,0
80005a16:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005a18:	48 58       	lddpc	r8,80005a2c <vPortExitCritical+0x1c>
80005a1a:	70 09       	ld.w	r9,r8[0x0]
80005a1c:	20 19       	sub	r9,1
80005a1e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005a20:	70 08       	ld.w	r8,r8[0x0]
80005a22:	58 08       	cp.w	r8,0
80005a24:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005a26:	d5 03       	csrf	0x10
80005a28:	5e fc       	retal	r12
80005a2a:	00 00       	add	r0,r0
80005a2c:	00 00       	add	r0,r0
80005a2e:	05 30       	ld.ub	r0,r2++

80005a30 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005a30:	eb cd 00 ff 	pushm	r0-r7
80005a34:	e0 68 05 30 	mov	r8,1328
80005a38:	ea 18 00 00 	orh	r8,0x0
80005a3c:	70 00       	ld.w	r0,r8[0x0]
80005a3e:	1a d0       	st.w	--sp,r0
80005a40:	7a 90       	ld.w	r0,sp[0x24]
80005a42:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005a46:	58 10       	cp.w	r0,1
80005a48:	e0 8b 00 08 	brhi	80005a58 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005a4c:	e0 68 0c e4 	mov	r8,3300
80005a50:	ea 18 00 00 	orh	r8,0x0
80005a54:	70 00       	ld.w	r0,r8[0x0]
80005a56:	81 0d       	st.w	r0[0x0],sp

80005a58 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005a58:	f0 1f 00 12 	mcall	80005aa0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005a5c:	f0 1f 00 12 	mcall	80005aa4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005a60:	f0 1f 00 12 	mcall	80005aa8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005a64:	f0 1f 00 12 	mcall	80005aac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005a68:	7a 90       	ld.w	r0,sp[0x24]
80005a6a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005a6e:	58 10       	cp.w	r0,1
80005a70:	e0 8b 00 0e 	brhi	80005a8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005a74:	f0 1f 00 0c 	mcall	80005aa4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005a78:	f0 1f 00 0e 	mcall	80005ab0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005a7c:	f0 1f 00 0c 	mcall	80005aac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005a80:	e0 68 0c e4 	mov	r8,3300
80005a84:	ea 18 00 00 	orh	r8,0x0
80005a88:	70 00       	ld.w	r0,r8[0x0]
80005a8a:	60 0d       	ld.w	sp,r0[0x0]

80005a8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005a8c:	1b 00       	ld.w	r0,sp++
80005a8e:	e0 68 05 30 	mov	r8,1328
80005a92:	ea 18 00 00 	orh	r8,0x0
80005a96:	91 00       	st.w	r8[0x0],r0
80005a98:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005a9c:	d6 03       	rete
80005a9e:	00 00       	add	r0,r0
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	5a 04       	cp.w	r4,-32
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	59 04       	cp.w	r4,16
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	62 4c       	ld.w	r12,r1[0x10]
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	5a 10       	cp.w	r0,-31
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	60 48       	ld.w	r8,r0[0x10]

80005ab4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005ab4:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005ab6:	f0 1f 00 02 	mcall	80005abc <__malloc_lock+0x8>
}
80005aba:	d8 02       	popm	pc
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	60 38       	ld.w	r8,r0[0xc]

80005ac0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005ac0:	d4 01       	pushm	lr
	xTaskResumeAll();
80005ac2:	f0 1f 00 02 	mcall	80005ac8 <__malloc_unlock+0x8>
}
80005ac6:	d8 02       	popm	pc
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	63 f4       	ld.w	r4,r1[0x7c]

80005acc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005acc:	d4 21       	pushm	r4-r7,lr
80005ace:	16 95       	mov	r5,r11
80005ad0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005ad2:	58 0c       	cp.w	r12,0
80005ad4:	c0 30       	breq	80005ada <_read+0xe>
80005ad6:	3f f7       	mov	r7,-1
80005ad8:	c1 48       	rjmp	80005b00 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005ada:	58 0a       	cp.w	r10,0
80005adc:	e0 89 00 04 	brgt	80005ae4 <_read+0x18>
80005ae0:	30 07       	mov	r7,0
80005ae2:	c0 f8       	rjmp	80005b00 <_read+0x34>
80005ae4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005ae6:	48 84       	lddpc	r4,80005b04 <_read+0x38>
80005ae8:	68 0c       	ld.w	r12,r4[0x0]
80005aea:	f0 1f 00 08 	mcall	80005b08 <_read+0x3c>
    if (c < 0)
80005aee:	c0 95       	brlt	80005b00 <_read+0x34>
      break;

    *ptr++ = c;
80005af0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005af4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005af6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005afa:	58 08       	cp.w	r8,0
80005afc:	fe 99 ff f6 	brgt	80005ae8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005b00:	0e 9c       	mov	r12,r7
80005b02:	d8 22       	popm	r4-r7,pc
80005b04:	00 00       	add	r0,r0
80005b06:	63 98       	ld.w	r8,r1[0x64]
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	56 58       	stdsp	sp[0x194],r8

80005b0c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005b0c:	d4 21       	pushm	r4-r7,lr
80005b0e:	16 95       	mov	r5,r11
80005b10:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005b12:	20 1c       	sub	r12,1
80005b14:	58 2c       	cp.w	r12,2
80005b16:	e0 8b 00 12 	brhi	80005b3a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005b1a:	58 0a       	cp.w	r10,0
80005b1c:	c0 31       	brne	80005b22 <_write+0x16>
80005b1e:	30 07       	mov	r7,0
80005b20:	c0 e8       	rjmp	80005b3c <_write+0x30>
80005b22:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005b24:	48 74       	lddpc	r4,80005b40 <_write+0x34>
80005b26:	68 0c       	ld.w	r12,r4[0x0]
80005b28:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005b2c:	f0 1f 00 06 	mcall	80005b44 <_write+0x38>
80005b30:	c0 55       	brlt	80005b3a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005b32:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005b34:	0e 36       	cp.w	r6,r7
80005b36:	cf 81       	brne	80005b26 <_write+0x1a>
80005b38:	c0 28       	rjmp	80005b3c <_write+0x30>
80005b3a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005b3c:	0e 9c       	mov	r12,r7
80005b3e:	d8 22       	popm	r4-r7,pc
80005b40:	00 00       	add	r0,r0
80005b42:	63 98       	ld.w	r8,r1[0x64]
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	56 08       	stdsp	sp[0x180],r8

80005b48 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005b48:	eb cd 40 80 	pushm	r7,lr
80005b4c:	18 97       	mov	r7,r12
	if( pv )
80005b4e:	58 0c       	cp.w	r12,0
80005b50:	c0 80       	breq	80005b60 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005b52:	f0 1f 00 05 	mcall	80005b64 <vPortFree+0x1c>
		{
			free( pv );
80005b56:	0e 9c       	mov	r12,r7
80005b58:	f0 1f 00 04 	mcall	80005b68 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005b5c:	f0 1f 00 04 	mcall	80005b6c <vPortFree+0x24>
80005b60:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	60 38       	ld.w	r8,r0[0xc]
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	6e 98       	ld.w	r8,r7[0x24]
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	63 f4       	ld.w	r4,r1[0x7c]

80005b70 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005b70:	eb cd 40 80 	pushm	r7,lr
80005b74:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005b76:	f0 1f 00 06 	mcall	80005b8c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005b7a:	0e 9c       	mov	r12,r7
80005b7c:	f0 1f 00 05 	mcall	80005b90 <pvPortMalloc+0x20>
80005b80:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005b82:	f0 1f 00 05 	mcall	80005b94 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005b86:	0e 9c       	mov	r12,r7
80005b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	60 38       	ld.w	r8,r0[0xc]
80005b90:	80 00       	ld.sh	r0,r0[0x0]
80005b92:	6e a8       	ld.w	r8,r7[0x28]
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	63 f4       	ld.w	r4,r1[0x7c]

80005b98 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005b98:	d4 01       	pushm	lr
80005b9a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005b9c:	78 09       	ld.w	r9,r12[0x0]
80005b9e:	58 09       	cp.w	r9,0
80005ba0:	c1 10       	breq	80005bc2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ba2:	78 3a       	ld.w	r10,r12[0xc]
80005ba4:	79 09       	ld.w	r9,r12[0x40]
80005ba6:	f4 09 00 09 	add	r9,r10,r9
80005baa:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005bac:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005bae:	14 39       	cp.w	r9,r10
80005bb0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005bb4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005bb8:	79 0a       	ld.w	r10,r12[0x40]
80005bba:	78 3b       	ld.w	r11,r12[0xc]
80005bbc:	10 9c       	mov	r12,r8
80005bbe:	f0 1f 00 02 	mcall	80005bc4 <prvCopyDataFromQueue+0x2c>
80005bc2:	d8 02       	popm	pc
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	73 16       	ld.w	r6,r9[0x44]

80005bc8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80005bcc:	18 97       	mov	r7,r12
80005bce:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005bd0:	78 e8       	ld.w	r8,r12[0x38]
80005bd2:	58 08       	cp.w	r8,0
80005bd4:	c0 31       	brne	80005bda <xQueueReceiveFromISR+0x12>
80005bd6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005bda:	f0 1f 00 0e 	mcall	80005c10 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005bde:	6e e8       	ld.w	r8,r7[0x38]
80005be0:	20 18       	sub	r8,1
80005be2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005be4:	6f 18       	ld.w	r8,r7[0x44]
80005be6:	5b f8       	cp.w	r8,-1
80005be8:	c0 d1       	brne	80005c02 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bea:	6e 48       	ld.w	r8,r7[0x10]
80005bec:	58 08       	cp.w	r8,0
80005bee:	c0 f0       	breq	80005c0c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bf0:	ee cc ff f0 	sub	r12,r7,-16
80005bf4:	f0 1f 00 08 	mcall	80005c14 <xQueueReceiveFromISR+0x4c>
80005bf8:	c0 a0       	breq	80005c0c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005bfa:	30 1c       	mov	r12,1
80005bfc:	8d 0c       	st.w	r6[0x0],r12
80005bfe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005c02:	2f f8       	sub	r8,-1
80005c04:	ef 48 00 44 	st.w	r7[68],r8
80005c08:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005c0c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	5b 98       	cp.w	r8,-7
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	61 d0       	ld.w	r0,r0[0x74]

80005c18 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005c18:	eb cd 40 c0 	pushm	r6-r7,lr
80005c1c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005c1e:	f0 1f 00 23 	mcall	80005ca8 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005c22:	6f 28       	ld.w	r8,r7[0x48]
80005c24:	58 08       	cp.w	r8,0
80005c26:	e0 8a 00 18 	brle	80005c56 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c2a:	6e 98       	ld.w	r8,r7[0x24]
80005c2c:	58 08       	cp.w	r8,0
80005c2e:	c1 40       	breq	80005c56 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c30:	ee c6 ff dc 	sub	r6,r7,-36
80005c34:	c0 48       	rjmp	80005c3c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c36:	6e 98       	ld.w	r8,r7[0x24]
80005c38:	58 08       	cp.w	r8,0
80005c3a:	c0 e0       	breq	80005c56 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c3c:	0c 9c       	mov	r12,r6
80005c3e:	f0 1f 00 1c 	mcall	80005cac <prvUnlockQueue+0x94>
80005c42:	c0 30       	breq	80005c48 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005c44:	f0 1f 00 1b 	mcall	80005cb0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005c48:	6f 28       	ld.w	r8,r7[0x48]
80005c4a:	20 18       	sub	r8,1
80005c4c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005c50:	58 08       	cp.w	r8,0
80005c52:	fe 99 ff f2 	brgt	80005c36 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005c56:	3f f8       	mov	r8,-1
80005c58:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005c5c:	f0 1f 00 16 	mcall	80005cb4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005c60:	f0 1f 00 12 	mcall	80005ca8 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c64:	6f 18       	ld.w	r8,r7[0x44]
80005c66:	58 08       	cp.w	r8,0
80005c68:	e0 8a 00 18 	brle	80005c98 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c6c:	6e 48       	ld.w	r8,r7[0x10]
80005c6e:	58 08       	cp.w	r8,0
80005c70:	c1 40       	breq	80005c98 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005c72:	ee c6 ff f0 	sub	r6,r7,-16
80005c76:	c0 48       	rjmp	80005c7e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c78:	6e 48       	ld.w	r8,r7[0x10]
80005c7a:	58 08       	cp.w	r8,0
80005c7c:	c0 e0       	breq	80005c98 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005c7e:	0c 9c       	mov	r12,r6
80005c80:	f0 1f 00 0b 	mcall	80005cac <prvUnlockQueue+0x94>
80005c84:	c0 30       	breq	80005c8a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005c86:	f0 1f 00 0b 	mcall	80005cb0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005c8a:	6f 18       	ld.w	r8,r7[0x44]
80005c8c:	20 18       	sub	r8,1
80005c8e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c92:	58 08       	cp.w	r8,0
80005c94:	fe 99 ff f2 	brgt	80005c78 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005c98:	3f f8       	mov	r8,-1
80005c9a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005c9e:	f0 1f 00 06 	mcall	80005cb4 <prvUnlockQueue+0x9c>
}
80005ca2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ca6:	00 00       	add	r0,r0
80005ca8:	80 00       	ld.sh	r0,r0[0x0]
80005caa:	59 04       	cp.w	r4,16
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	61 d0       	ld.w	r0,r0[0x74]
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	60 dc       	ld.w	r12,r0[0x34]
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	5a 10       	cp.w	r0,-31

80005cb8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005cb8:	d4 31       	pushm	r0-r7,lr
80005cba:	20 5d       	sub	sp,20
80005cbc:	18 97       	mov	r7,r12
80005cbe:	50 0b       	stdsp	sp[0x0],r11
80005cc0:	50 2a       	stdsp	sp[0x8],r10
80005cc2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005cc4:	f8 c2 ff dc 	sub	r2,r12,-36
80005cc8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005cca:	fa c4 ff f4 	sub	r4,sp,-12
80005cce:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005cd0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cd2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005cd6:	f0 1f 00 3e 	mcall	80005dcc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005cda:	6e e8       	ld.w	r8,r7[0x38]
80005cdc:	58 08       	cp.w	r8,0
80005cde:	c2 a0       	breq	80005d32 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005ce0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ce2:	40 0b       	lddsp	r11,sp[0x0]
80005ce4:	0e 9c       	mov	r12,r7
80005ce6:	f0 1f 00 3b 	mcall	80005dd0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005cea:	40 18       	lddsp	r8,sp[0x4]
80005cec:	58 08       	cp.w	r8,0
80005cee:	c1 51       	brne	80005d18 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005cf0:	6e e8       	ld.w	r8,r7[0x38]
80005cf2:	20 18       	sub	r8,1
80005cf4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cf6:	6e 08       	ld.w	r8,r7[0x0]
80005cf8:	58 08       	cp.w	r8,0
80005cfa:	c0 41       	brne	80005d02 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005cfc:	f0 1f 00 36 	mcall	80005dd4 <xQueueGenericReceive+0x11c>
80005d00:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005d02:	6e 48       	ld.w	r8,r7[0x10]
80005d04:	58 08       	cp.w	r8,0
80005d06:	c1 20       	breq	80005d2a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005d08:	ee cc ff f0 	sub	r12,r7,-16
80005d0c:	f0 1f 00 33 	mcall	80005dd8 <xQueueGenericReceive+0x120>
80005d10:	58 1c       	cp.w	r12,1
80005d12:	c0 c1       	brne	80005d2a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005d14:	d7 33       	scall
80005d16:	c0 a8       	rjmp	80005d2a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005d18:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005d1a:	6e 98       	ld.w	r8,r7[0x24]
80005d1c:	58 08       	cp.w	r8,0
80005d1e:	c0 60       	breq	80005d2a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005d20:	04 9c       	mov	r12,r2
80005d22:	f0 1f 00 2e 	mcall	80005dd8 <xQueueGenericReceive+0x120>
80005d26:	c0 20       	breq	80005d2a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005d28:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005d2a:	f0 1f 00 2d 	mcall	80005ddc <xQueueGenericReceive+0x124>
80005d2e:	30 1c       	mov	r12,1
				return pdPASS;
80005d30:	c4 c8       	rjmp	80005dc8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005d32:	40 28       	lddsp	r8,sp[0x8]
80005d34:	58 08       	cp.w	r8,0
80005d36:	c0 51       	brne	80005d40 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005d38:	f0 1f 00 29 	mcall	80005ddc <xQueueGenericReceive+0x124>
80005d3c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005d3e:	c4 58       	rjmp	80005dc8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005d40:	58 05       	cp.w	r5,0
80005d42:	c0 51       	brne	80005d4c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005d44:	08 9c       	mov	r12,r4
80005d46:	f0 1f 00 27 	mcall	80005de0 <xQueueGenericReceive+0x128>
80005d4a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005d4c:	f0 1f 00 24 	mcall	80005ddc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005d50:	f0 1f 00 25 	mcall	80005de4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005d54:	f0 1f 00 1e 	mcall	80005dcc <xQueueGenericReceive+0x114>
80005d58:	6f 18       	ld.w	r8,r7[0x44]
80005d5a:	5b f8       	cp.w	r8,-1
80005d5c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005d60:	6f 28       	ld.w	r8,r7[0x48]
80005d62:	5b f8       	cp.w	r8,-1
80005d64:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005d68:	f0 1f 00 1d 	mcall	80005ddc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005d6c:	06 9b       	mov	r11,r3
80005d6e:	08 9c       	mov	r12,r4
80005d70:	f0 1f 00 1e 	mcall	80005de8 <xQueueGenericReceive+0x130>
80005d74:	c2 41       	brne	80005dbc <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005d76:	f0 1f 00 16 	mcall	80005dcc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005d7a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005d7c:	f0 1f 00 18 	mcall	80005ddc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005d80:	58 06       	cp.w	r6,0
80005d82:	c1 71       	brne	80005db0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d84:	6e 08       	ld.w	r8,r7[0x0]
80005d86:	58 08       	cp.w	r8,0
80005d88:	c0 81       	brne	80005d98 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005d8a:	f0 1f 00 11 	mcall	80005dcc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005d8e:	6e 1c       	ld.w	r12,r7[0x4]
80005d90:	f0 1f 00 17 	mcall	80005dec <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005d94:	f0 1f 00 12 	mcall	80005ddc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005d98:	40 2b       	lddsp	r11,sp[0x8]
80005d9a:	04 9c       	mov	r12,r2
80005d9c:	f0 1f 00 15 	mcall	80005df0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005da0:	0e 9c       	mov	r12,r7
80005da2:	f0 1f 00 15 	mcall	80005df4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005da6:	f0 1f 00 15 	mcall	80005df8 <xQueueGenericReceive+0x140>
80005daa:	c9 61       	brne	80005cd6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005dac:	d7 33       	scall
80005dae:	c9 4b       	rjmp	80005cd6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005db0:	0e 9c       	mov	r12,r7
80005db2:	f0 1f 00 11 	mcall	80005df4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005db6:	f0 1f 00 11 	mcall	80005df8 <xQueueGenericReceive+0x140>
80005dba:	c8 eb       	rjmp	80005cd6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005dbc:	0e 9c       	mov	r12,r7
80005dbe:	f0 1f 00 0e 	mcall	80005df4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005dc2:	f0 1f 00 0e 	mcall	80005df8 <xQueueGenericReceive+0x140>
80005dc6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005dc8:	2f bd       	sub	sp,-20
80005dca:	d8 32       	popm	r0-r7,pc
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	59 04       	cp.w	r4,16
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	5b 98       	cp.w	r8,-7
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	60 e8       	ld.w	r8,r0[0x38]
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	61 d0       	ld.w	r0,r0[0x74]
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	5a 10       	cp.w	r0,-31
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	60 c4       	ld.w	r4,r0[0x30]
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	60 38       	ld.w	r8,r0[0xc]
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	63 60       	ld.w	r0,r1[0x58]
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	61 4c       	ld.w	r12,r0[0x50]
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	65 b8       	ld.w	r8,r2[0x6c]
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	5c 18       	scr	r8
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	63 f4       	ld.w	r4,r1[0x7c]

80005dfc <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005dfc:	eb cd 40 80 	pushm	r7,lr
80005e00:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005e02:	79 08       	ld.w	r8,r12[0x40]
80005e04:	58 08       	cp.w	r8,0
80005e06:	c0 a1       	brne	80005e1a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005e08:	78 08       	ld.w	r8,r12[0x0]
80005e0a:	58 08       	cp.w	r8,0
80005e0c:	c2 b1       	brne	80005e62 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005e0e:	78 1c       	ld.w	r12,r12[0x4]
80005e10:	f0 1f 00 17 	mcall	80005e6c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005e14:	30 08       	mov	r8,0
80005e16:	8f 18       	st.w	r7[0x4],r8
80005e18:	c2 58       	rjmp	80005e62 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005e1a:	58 0a       	cp.w	r10,0
80005e1c:	c1 01       	brne	80005e3c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005e1e:	10 9a       	mov	r10,r8
80005e20:	78 2c       	ld.w	r12,r12[0x8]
80005e22:	f0 1f 00 14 	mcall	80005e70 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005e26:	6e 29       	ld.w	r9,r7[0x8]
80005e28:	6f 08       	ld.w	r8,r7[0x40]
80005e2a:	f2 08 00 08 	add	r8,r9,r8
80005e2e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005e30:	6e 19       	ld.w	r9,r7[0x4]
80005e32:	12 38       	cp.w	r8,r9
80005e34:	c1 73       	brcs	80005e62 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005e36:	6e 08       	ld.w	r8,r7[0x0]
80005e38:	8f 28       	st.w	r7[0x8],r8
80005e3a:	c1 48       	rjmp	80005e62 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005e3c:	10 9a       	mov	r10,r8
80005e3e:	78 3c       	ld.w	r12,r12[0xc]
80005e40:	f0 1f 00 0c 	mcall	80005e70 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005e44:	6f 08       	ld.w	r8,r7[0x40]
80005e46:	6e 39       	ld.w	r9,r7[0xc]
80005e48:	f2 08 01 08 	sub	r8,r9,r8
80005e4c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005e4e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005e50:	12 38       	cp.w	r8,r9
80005e52:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005e56:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005e5a:	f3 d8 e3 19 	subcs	r9,r9,r8
80005e5e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005e62:	6e e8       	ld.w	r8,r7[0x38]
80005e64:	2f f8       	sub	r8,-1
80005e66:	8f e8       	st.w	r7[0x38],r8
}
80005e68:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e6c:	80 00       	ld.sh	r0,r0[0x0]
80005e6e:	60 f4       	ld.w	r4,r0[0x3c]
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	73 16       	ld.w	r6,r9[0x44]

80005e74 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005e74:	eb cd 40 c0 	pushm	r6-r7,lr
80005e78:	18 97       	mov	r7,r12
80005e7a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e7c:	78 ec       	ld.w	r12,r12[0x38]
80005e7e:	6e f8       	ld.w	r8,r7[0x3c]
80005e80:	10 3c       	cp.w	r12,r8
80005e82:	c0 33       	brcs	80005e88 <xQueueGenericSendFromISR+0x14>
80005e84:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e88:	12 9a       	mov	r10,r9
80005e8a:	0e 9c       	mov	r12,r7
80005e8c:	f0 1f 00 0c 	mcall	80005ebc <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005e90:	6f 28       	ld.w	r8,r7[0x48]
80005e92:	5b f8       	cp.w	r8,-1
80005e94:	c0 d1       	brne	80005eae <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e96:	6e 98       	ld.w	r8,r7[0x24]
80005e98:	58 08       	cp.w	r8,0
80005e9a:	c0 f0       	breq	80005eb8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005e9c:	ee cc ff dc 	sub	r12,r7,-36
80005ea0:	f0 1f 00 08 	mcall	80005ec0 <xQueueGenericSendFromISR+0x4c>
80005ea4:	c0 a0       	breq	80005eb8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005ea6:	30 1c       	mov	r12,1
80005ea8:	8d 0c       	st.w	r6[0x0],r12
80005eaa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005eae:	2f f8       	sub	r8,-1
80005eb0:	ef 48 00 48 	st.w	r7[72],r8
80005eb4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005eb8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	5d fc       	*unknown*
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	61 d0       	ld.w	r0,r0[0x74]

80005ec4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005ec4:	d4 31       	pushm	r0-r7,lr
80005ec6:	20 5d       	sub	sp,20
80005ec8:	18 97       	mov	r7,r12
80005eca:	50 0b       	stdsp	sp[0x0],r11
80005ecc:	50 2a       	stdsp	sp[0x8],r10
80005ece:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ed0:	f8 c0 ff f0 	sub	r0,r12,-16
80005ed4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005ed6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005eda:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005edc:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005ee0:	f0 1f 00 2f 	mcall	80005f9c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005ee4:	6e e9       	ld.w	r9,r7[0x38]
80005ee6:	6e f8       	ld.w	r8,r7[0x3c]
80005ee8:	10 39       	cp.w	r9,r8
80005eea:	c1 42       	brcc	80005f12 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005eec:	40 1a       	lddsp	r10,sp[0x4]
80005eee:	40 0b       	lddsp	r11,sp[0x0]
80005ef0:	0e 9c       	mov	r12,r7
80005ef2:	f0 1f 00 2c 	mcall	80005fa0 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ef6:	6e 98       	ld.w	r8,r7[0x24]
80005ef8:	58 08       	cp.w	r8,0
80005efa:	c0 80       	breq	80005f0a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005efc:	ee cc ff dc 	sub	r12,r7,-36
80005f00:	f0 1f 00 29 	mcall	80005fa4 <xQueueGenericSend+0xe0>
80005f04:	58 1c       	cp.w	r12,1
80005f06:	c0 21       	brne	80005f0a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005f08:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005f0a:	f0 1f 00 28 	mcall	80005fa8 <xQueueGenericSend+0xe4>
80005f0e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005f10:	c4 38       	rjmp	80005f96 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005f12:	40 28       	lddsp	r8,sp[0x8]
80005f14:	58 08       	cp.w	r8,0
80005f16:	c0 51       	brne	80005f20 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005f18:	f0 1f 00 24 	mcall	80005fa8 <xQueueGenericSend+0xe4>
80005f1c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005f1e:	c3 c8       	rjmp	80005f96 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005f20:	58 04       	cp.w	r4,0
80005f22:	c0 51       	brne	80005f2c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005f24:	06 9c       	mov	r12,r3
80005f26:	f0 1f 00 22 	mcall	80005fac <xQueueGenericSend+0xe8>
80005f2a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005f2c:	f0 1f 00 1f 	mcall	80005fa8 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005f30:	f0 1f 00 20 	mcall	80005fb0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005f34:	f0 1f 00 1a 	mcall	80005f9c <xQueueGenericSend+0xd8>
80005f38:	6f 18       	ld.w	r8,r7[0x44]
80005f3a:	5b f8       	cp.w	r8,-1
80005f3c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005f40:	6f 28       	ld.w	r8,r7[0x48]
80005f42:	5b f8       	cp.w	r8,-1
80005f44:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005f48:	f0 1f 00 18 	mcall	80005fa8 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f4c:	04 9b       	mov	r11,r2
80005f4e:	06 9c       	mov	r12,r3
80005f50:	f0 1f 00 19 	mcall	80005fb4 <xQueueGenericSend+0xf0>
80005f54:	c1 b1       	brne	80005f8a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005f56:	f0 1f 00 12 	mcall	80005f9c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005f5a:	6e e5       	ld.w	r5,r7[0x38]
80005f5c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005f5e:	f0 1f 00 13 	mcall	80005fa8 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005f62:	0c 35       	cp.w	r5,r6
80005f64:	c0 d1       	brne	80005f7e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005f66:	40 2b       	lddsp	r11,sp[0x8]
80005f68:	00 9c       	mov	r12,r0
80005f6a:	f0 1f 00 14 	mcall	80005fb8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005f6e:	0e 9c       	mov	r12,r7
80005f70:	f0 1f 00 13 	mcall	80005fbc <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005f74:	f0 1f 00 13 	mcall	80005fc0 <xQueueGenericSend+0xfc>
80005f78:	cb 41       	brne	80005ee0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005f7a:	d7 33       	scall
80005f7c:	cb 2b       	rjmp	80005ee0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005f7e:	0e 9c       	mov	r12,r7
80005f80:	f0 1f 00 0f 	mcall	80005fbc <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005f84:	f0 1f 00 0f 	mcall	80005fc0 <xQueueGenericSend+0xfc>
80005f88:	ca cb       	rjmp	80005ee0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005f8a:	0e 9c       	mov	r12,r7
80005f8c:	f0 1f 00 0c 	mcall	80005fbc <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005f90:	f0 1f 00 0c 	mcall	80005fc0 <xQueueGenericSend+0xfc>
80005f94:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005f96:	2f bd       	sub	sp,-20
80005f98:	d8 32       	popm	r0-r7,pc
80005f9a:	00 00       	add	r0,r0
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	59 04       	cp.w	r4,16
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	5d fc       	*unknown*
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	61 d0       	ld.w	r0,r0[0x74]
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	5a 10       	cp.w	r0,-31
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	60 c4       	ld.w	r4,r0[0x30]
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	60 38       	ld.w	r8,r0[0xc]
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	63 60       	ld.w	r0,r1[0x58]
80005fb8:	80 00       	ld.sh	r0,r0[0x0]
80005fba:	65 b8       	ld.w	r8,r2[0x6c]
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	5c 18       	scr	r8
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	63 f4       	ld.w	r4,r1[0x7c]

80005fc4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005fc4:	d4 21       	pushm	r4-r7,lr
80005fc6:	18 97       	mov	r7,r12
80005fc8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005fca:	58 0c       	cp.w	r12,0
80005fcc:	c2 f0       	breq	8000602a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005fce:	34 cc       	mov	r12,76
80005fd0:	f0 1f 00 17 	mcall	8000602c <xQueueCreate+0x68>
80005fd4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005fd6:	c2 a0       	breq	8000602a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005fd8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005fdc:	e8 cc ff ff 	sub	r12,r4,-1
80005fe0:	f0 1f 00 13 	mcall	8000602c <xQueueCreate+0x68>
80005fe4:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005fe6:	c1 e0       	breq	80006022 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005fe8:	f8 04 00 04 	add	r4,r12,r4
80005fec:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005fee:	30 08       	mov	r8,0
80005ff0:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005ff2:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005ff4:	ee c8 00 01 	sub	r8,r7,1
80005ff8:	ad 38       	mul	r8,r6
80005ffa:	10 0c       	add	r12,r8
80005ffc:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005ffe:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006000:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006004:	3f f8       	mov	r8,-1
80006006:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000600a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000600e:	ea cc ff f0 	sub	r12,r5,-16
80006012:	f0 1f 00 08 	mcall	80006030 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006016:	ea cc ff dc 	sub	r12,r5,-36
8000601a:	f0 1f 00 06 	mcall	80006030 <xQueueCreate+0x6c>
8000601e:	0a 9c       	mov	r12,r5
80006020:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006022:	0a 9c       	mov	r12,r5
80006024:	f0 1f 00 04 	mcall	80006034 <xQueueCreate+0x70>
80006028:	d8 2a       	popm	r4-r7,pc,r12=0
8000602a:	d8 2a       	popm	r4-r7,pc,r12=0
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	5b 70       	cp.w	r0,-9
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	57 e0       	stdsp	sp[0x1f8],r0
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	5b 48       	cp.w	r8,-12

80006038 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006038:	48 38       	lddpc	r8,80006044 <vTaskSuspendAll+0xc>
8000603a:	70 09       	ld.w	r9,r8[0x0]
8000603c:	2f f9       	sub	r9,-1
8000603e:	91 09       	st.w	r8[0x0],r9
}
80006040:	5e fc       	retal	r12
80006042:	00 00       	add	r0,r0
80006044:	00 00       	add	r0,r0
80006046:	0d 14       	ld.sh	r4,r6++

80006048 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006048:	49 a8       	lddpc	r8,800060b0 <vTaskSwitchContext+0x68>
8000604a:	70 08       	ld.w	r8,r8[0x0]
8000604c:	58 08       	cp.w	r8,0
8000604e:	c0 b1       	brne	80006064 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006050:	49 98       	lddpc	r8,800060b4 <vTaskSwitchContext+0x6c>
80006052:	70 08       	ld.w	r8,r8[0x0]
80006054:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006058:	49 89       	lddpc	r9,800060b8 <vTaskSwitchContext+0x70>
8000605a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000605e:	58 08       	cp.w	r8,0
80006060:	c0 60       	breq	8000606c <vTaskSwitchContext+0x24>
80006062:	c1 18       	rjmp	80006084 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006064:	30 19       	mov	r9,1
80006066:	49 68       	lddpc	r8,800060bc <vTaskSwitchContext+0x74>
80006068:	91 09       	st.w	r8[0x0],r9
8000606a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000606c:	49 28       	lddpc	r8,800060b4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000606e:	49 3a       	lddpc	r10,800060b8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006070:	70 09       	ld.w	r9,r8[0x0]
80006072:	20 19       	sub	r9,1
80006074:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006076:	70 09       	ld.w	r9,r8[0x0]
80006078:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000607c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006080:	58 09       	cp.w	r9,0
80006082:	cf 70       	breq	80006070 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006084:	48 c8       	lddpc	r8,800060b4 <vTaskSwitchContext+0x6c>
80006086:	70 08       	ld.w	r8,r8[0x0]
80006088:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000608c:	48 b9       	lddpc	r9,800060b8 <vTaskSwitchContext+0x70>
8000608e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006092:	70 19       	ld.w	r9,r8[0x4]
80006094:	72 19       	ld.w	r9,r9[0x4]
80006096:	91 19       	st.w	r8[0x4],r9
80006098:	f0 ca ff f8 	sub	r10,r8,-8
8000609c:	14 39       	cp.w	r9,r10
8000609e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800060a2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800060a6:	70 18       	ld.w	r8,r8[0x4]
800060a8:	70 39       	ld.w	r9,r8[0xc]
800060aa:	48 68       	lddpc	r8,800060c0 <vTaskSwitchContext+0x78>
800060ac:	91 09       	st.w	r8[0x0],r9
800060ae:	5e fc       	retal	r12
800060b0:	00 00       	add	r0,r0
800060b2:	0d 14       	ld.sh	r4,r6++
800060b4:	00 00       	add	r0,r0
800060b6:	0d 4c       	ld.w	r12,--r6
800060b8:	00 00       	add	r0,r0
800060ba:	0c 30       	cp.w	r0,r6
800060bc:	00 00       	add	r0,r0
800060be:	0d 34       	ld.ub	r4,r6++
800060c0:	00 00       	add	r0,r0
800060c2:	0c e4       	st.h	--r6,r4

800060c4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800060c4:	48 48       	lddpc	r8,800060d4 <vTaskSetTimeOutState+0x10>
800060c6:	70 08       	ld.w	r8,r8[0x0]
800060c8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800060ca:	48 48       	lddpc	r8,800060d8 <vTaskSetTimeOutState+0x14>
800060cc:	70 08       	ld.w	r8,r8[0x0]
800060ce:	99 18       	st.w	r12[0x4],r8
}
800060d0:	5e fc       	retal	r12
800060d2:	00 00       	add	r0,r0
800060d4:	00 00       	add	r0,r0
800060d6:	0c 28       	rsub	r8,r6
800060d8:	00 00       	add	r0,r0
800060da:	0d 10       	ld.sh	r0,r6++

800060dc <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800060dc:	30 19       	mov	r9,1
800060de:	48 28       	lddpc	r8,800060e4 <vTaskMissedYield+0x8>
800060e0:	91 09       	st.w	r8[0x0],r9
}
800060e2:	5e fc       	retal	r12
800060e4:	00 00       	add	r0,r0
800060e6:	0d 34       	ld.ub	r4,r6++

800060e8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800060e8:	48 28       	lddpc	r8,800060f0 <xTaskGetCurrentTaskHandle+0x8>
800060ea:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800060ec:	5e fc       	retal	r12
800060ee:	00 00       	add	r0,r0
800060f0:	00 00       	add	r0,r0
800060f2:	0c e4       	st.h	--r6,r4

800060f4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800060f4:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800060f8:	58 0c       	cp.w	r12,0
800060fa:	c1 f0       	breq	80006138 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800060fc:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800060fe:	78 b9       	ld.w	r9,r12[0x2c]
80006100:	79 18       	ld.w	r8,r12[0x44]
80006102:	10 39       	cp.w	r9,r8
80006104:	c1 a0       	breq	80006138 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006106:	f8 c6 ff fc 	sub	r6,r12,-4
8000610a:	0c 9c       	mov	r12,r6
8000610c:	f0 1f 00 0c 	mcall	8000613c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006110:	6f 1c       	ld.w	r12,r7[0x44]
80006112:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006114:	f8 08 11 08 	rsub	r8,r12,8
80006118:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000611a:	48 a8       	lddpc	r8,80006140 <vTaskPriorityDisinherit+0x4c>
8000611c:	70 08       	ld.w	r8,r8[0x0]
8000611e:	10 3c       	cp.w	r12,r8
80006120:	e0 88 00 04 	brls	80006128 <vTaskPriorityDisinherit+0x34>
80006124:	48 78       	lddpc	r8,80006140 <vTaskPriorityDisinherit+0x4c>
80006126:	91 0c       	st.w	r8[0x0],r12
80006128:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000612c:	0c 9b       	mov	r11,r6
8000612e:	48 68       	lddpc	r8,80006144 <vTaskPriorityDisinherit+0x50>
80006130:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006134:	f0 1f 00 05 	mcall	80006148 <vTaskPriorityDisinherit+0x54>
80006138:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	58 4a       	cp.w	r10,4
80006140:	00 00       	add	r0,r0
80006142:	0d 4c       	ld.w	r12,--r6
80006144:	00 00       	add	r0,r0
80006146:	0c 30       	cp.w	r0,r6
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	57 fa       	stdsp	sp[0x1fc],r10

8000614c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000614c:	eb cd 40 c0 	pushm	r6-r7,lr
80006150:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006152:	49 b8       	lddpc	r8,800061bc <vTaskPriorityInherit+0x70>
80006154:	70 08       	ld.w	r8,r8[0x0]
80006156:	78 b9       	ld.w	r9,r12[0x2c]
80006158:	70 b8       	ld.w	r8,r8[0x2c]
8000615a:	10 39       	cp.w	r9,r8
8000615c:	c2 d2       	brcc	800061b6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000615e:	49 88       	lddpc	r8,800061bc <vTaskPriorityInherit+0x70>
80006160:	70 08       	ld.w	r8,r8[0x0]
80006162:	70 b8       	ld.w	r8,r8[0x2c]
80006164:	f0 08 11 08 	rsub	r8,r8,8
80006168:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000616a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000616e:	49 59       	lddpc	r9,800061c0 <vTaskPriorityInherit+0x74>
80006170:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006174:	78 59       	ld.w	r9,r12[0x14]
80006176:	10 39       	cp.w	r9,r8
80006178:	c1 b1       	brne	800061ae <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000617a:	f8 c6 ff fc 	sub	r6,r12,-4
8000617e:	0c 9c       	mov	r12,r6
80006180:	f0 1f 00 11 	mcall	800061c4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006184:	48 e8       	lddpc	r8,800061bc <vTaskPriorityInherit+0x70>
80006186:	70 08       	ld.w	r8,r8[0x0]
80006188:	70 bc       	ld.w	r12,r8[0x2c]
8000618a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
8000618c:	48 f8       	lddpc	r8,800061c8 <vTaskPriorityInherit+0x7c>
8000618e:	70 08       	ld.w	r8,r8[0x0]
80006190:	10 3c       	cp.w	r12,r8
80006192:	e0 88 00 04 	brls	8000619a <vTaskPriorityInherit+0x4e>
80006196:	48 d8       	lddpc	r8,800061c8 <vTaskPriorityInherit+0x7c>
80006198:	91 0c       	st.w	r8[0x0],r12
8000619a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000619e:	0c 9b       	mov	r11,r6
800061a0:	48 88       	lddpc	r8,800061c0 <vTaskPriorityInherit+0x74>
800061a2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800061a6:	f0 1f 00 0a 	mcall	800061cc <vTaskPriorityInherit+0x80>
800061aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800061ae:	48 48       	lddpc	r8,800061bc <vTaskPriorityInherit+0x70>
800061b0:	70 08       	ld.w	r8,r8[0x0]
800061b2:	70 b8       	ld.w	r8,r8[0x2c]
800061b4:	99 b8       	st.w	r12[0x2c],r8
800061b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061ba:	00 00       	add	r0,r0
800061bc:	00 00       	add	r0,r0
800061be:	0c e4       	st.h	--r6,r4
800061c0:	00 00       	add	r0,r0
800061c2:	0c 30       	cp.w	r0,r6
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	58 4a       	cp.w	r10,4
800061c8:	00 00       	add	r0,r0
800061ca:	0d 4c       	ld.w	r12,--r6
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	57 fa       	stdsp	sp[0x1fc],r10

800061d0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800061d0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800061d4:	78 38       	ld.w	r8,r12[0xc]
800061d6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800061d8:	ee c6 ff e8 	sub	r6,r7,-24
800061dc:	0c 9c       	mov	r12,r6
800061de:	f0 1f 00 15 	mcall	80006230 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061e2:	49 58       	lddpc	r8,80006234 <xTaskRemoveFromEventList+0x64>
800061e4:	70 08       	ld.w	r8,r8[0x0]
800061e6:	58 08       	cp.w	r8,0
800061e8:	c1 71       	brne	80006216 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800061ea:	ee c6 ff fc 	sub	r6,r7,-4
800061ee:	0c 9c       	mov	r12,r6
800061f0:	f0 1f 00 10 	mcall	80006230 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800061f4:	6e bc       	ld.w	r12,r7[0x2c]
800061f6:	49 18       	lddpc	r8,80006238 <xTaskRemoveFromEventList+0x68>
800061f8:	70 08       	ld.w	r8,r8[0x0]
800061fa:	10 3c       	cp.w	r12,r8
800061fc:	e0 88 00 04 	brls	80006204 <xTaskRemoveFromEventList+0x34>
80006200:	48 e8       	lddpc	r8,80006238 <xTaskRemoveFromEventList+0x68>
80006202:	91 0c       	st.w	r8[0x0],r12
80006204:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006208:	0c 9b       	mov	r11,r6
8000620a:	48 d8       	lddpc	r8,8000623c <xTaskRemoveFromEventList+0x6c>
8000620c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006210:	f0 1f 00 0c 	mcall	80006240 <xTaskRemoveFromEventList+0x70>
80006214:	c0 58       	rjmp	8000621e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006216:	0c 9b       	mov	r11,r6
80006218:	48 bc       	lddpc	r12,80006244 <xTaskRemoveFromEventList+0x74>
8000621a:	f0 1f 00 0a 	mcall	80006240 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000621e:	48 b8       	lddpc	r8,80006248 <xTaskRemoveFromEventList+0x78>
80006220:	70 08       	ld.w	r8,r8[0x0]
80006222:	6e b9       	ld.w	r9,r7[0x2c]
80006224:	70 b8       	ld.w	r8,r8[0x2c]
80006226:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006228:	5f 2c       	srhs	r12
8000622a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000622e:	00 00       	add	r0,r0
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	58 4a       	cp.w	r10,4
80006234:	00 00       	add	r0,r0
80006236:	0d 14       	ld.sh	r4,r6++
80006238:	00 00       	add	r0,r0
8000623a:	0d 4c       	ld.w	r12,--r6
8000623c:	00 00       	add	r0,r0
8000623e:	0c 30       	cp.w	r0,r6
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	57 fa       	stdsp	sp[0x1fc],r10
80006244:	00 00       	add	r0,r0
80006246:	0c e8       	st.h	--r6,r8
80006248:	00 00       	add	r0,r0
8000624a:	0c e4       	st.h	--r6,r4

8000624c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000624c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006250:	4b 98       	lddpc	r8,80006334 <vTaskIncrementTick+0xe8>
80006252:	70 08       	ld.w	r8,r8[0x0]
80006254:	58 08       	cp.w	r8,0
80006256:	c6 91       	brne	80006328 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006258:	4b 88       	lddpc	r8,80006338 <vTaskIncrementTick+0xec>
8000625a:	70 09       	ld.w	r9,r8[0x0]
8000625c:	2f f9       	sub	r9,-1
8000625e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006260:	70 08       	ld.w	r8,r8[0x0]
80006262:	58 08       	cp.w	r8,0
80006264:	c1 a1       	brne	80006298 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006266:	4b 68       	lddpc	r8,8000633c <vTaskIncrementTick+0xf0>
80006268:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000626a:	4b 69       	lddpc	r9,80006340 <vTaskIncrementTick+0xf4>
8000626c:	72 0b       	ld.w	r11,r9[0x0]
8000626e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006270:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006272:	4b 59       	lddpc	r9,80006344 <vTaskIncrementTick+0xf8>
80006274:	72 0a       	ld.w	r10,r9[0x0]
80006276:	2f fa       	sub	r10,-1
80006278:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000627a:	70 08       	ld.w	r8,r8[0x0]
8000627c:	70 08       	ld.w	r8,r8[0x0]
8000627e:	58 08       	cp.w	r8,0
80006280:	c0 51       	brne	8000628a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006282:	3f f9       	mov	r9,-1
80006284:	4b 18       	lddpc	r8,80006348 <vTaskIncrementTick+0xfc>
80006286:	91 09       	st.w	r8[0x0],r9
80006288:	c0 88       	rjmp	80006298 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000628a:	4a d8       	lddpc	r8,8000633c <vTaskIncrementTick+0xf0>
8000628c:	70 08       	ld.w	r8,r8[0x0]
8000628e:	70 38       	ld.w	r8,r8[0xc]
80006290:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006292:	70 19       	ld.w	r9,r8[0x4]
80006294:	4a d8       	lddpc	r8,80006348 <vTaskIncrementTick+0xfc>
80006296:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006298:	4a 88       	lddpc	r8,80006338 <vTaskIncrementTick+0xec>
8000629a:	70 09       	ld.w	r9,r8[0x0]
8000629c:	4a b8       	lddpc	r8,80006348 <vTaskIncrementTick+0xfc>
8000629e:	70 08       	ld.w	r8,r8[0x0]
800062a0:	10 39       	cp.w	r9,r8
800062a2:	c4 73       	brcs	80006330 <vTaskIncrementTick+0xe4>
800062a4:	4a 68       	lddpc	r8,8000633c <vTaskIncrementTick+0xf0>
800062a6:	70 08       	ld.w	r8,r8[0x0]
800062a8:	70 08       	ld.w	r8,r8[0x0]
800062aa:	58 08       	cp.w	r8,0
800062ac:	c0 c0       	breq	800062c4 <vTaskIncrementTick+0x78>
800062ae:	4a 48       	lddpc	r8,8000633c <vTaskIncrementTick+0xf0>
800062b0:	70 08       	ld.w	r8,r8[0x0]
800062b2:	70 38       	ld.w	r8,r8[0xc]
800062b4:	70 37       	ld.w	r7,r8[0xc]
800062b6:	6e 18       	ld.w	r8,r7[0x4]
800062b8:	4a 09       	lddpc	r9,80006338 <vTaskIncrementTick+0xec>
800062ba:	72 09       	ld.w	r9,r9[0x0]
800062bc:	12 38       	cp.w	r8,r9
800062be:	e0 88 00 14 	brls	800062e6 <vTaskIncrementTick+0x9a>
800062c2:	c0 e8       	rjmp	800062de <vTaskIncrementTick+0x92>
800062c4:	3f f9       	mov	r9,-1
800062c6:	4a 18       	lddpc	r8,80006348 <vTaskIncrementTick+0xfc>
800062c8:	91 09       	st.w	r8[0x0],r9
800062ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062ce:	6a 08       	ld.w	r8,r5[0x0]
800062d0:	70 38       	ld.w	r8,r8[0xc]
800062d2:	70 37       	ld.w	r7,r8[0xc]
800062d4:	6e 18       	ld.w	r8,r7[0x4]
800062d6:	64 09       	ld.w	r9,r2[0x0]
800062d8:	12 38       	cp.w	r8,r9
800062da:	e0 88 00 0a 	brls	800062ee <vTaskIncrementTick+0xa2>
800062de:	49 b9       	lddpc	r9,80006348 <vTaskIncrementTick+0xfc>
800062e0:	93 08       	st.w	r9[0x0],r8
800062e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062e6:	49 a4       	lddpc	r4,8000634c <vTaskIncrementTick+0x100>
800062e8:	49 a3       	lddpc	r3,80006350 <vTaskIncrementTick+0x104>
800062ea:	49 55       	lddpc	r5,8000633c <vTaskIncrementTick+0xf0>
800062ec:	49 32       	lddpc	r2,80006338 <vTaskIncrementTick+0xec>
800062ee:	ee c6 ff fc 	sub	r6,r7,-4
800062f2:	0c 9c       	mov	r12,r6
800062f4:	f0 1f 00 18 	mcall	80006354 <vTaskIncrementTick+0x108>
800062f8:	6e a8       	ld.w	r8,r7[0x28]
800062fa:	58 08       	cp.w	r8,0
800062fc:	c0 50       	breq	80006306 <vTaskIncrementTick+0xba>
800062fe:	ee cc ff e8 	sub	r12,r7,-24
80006302:	f0 1f 00 15 	mcall	80006354 <vTaskIncrementTick+0x108>
80006306:	6e bc       	ld.w	r12,r7[0x2c]
80006308:	68 08       	ld.w	r8,r4[0x0]
8000630a:	10 3c       	cp.w	r12,r8
8000630c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006310:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006314:	0c 9b       	mov	r11,r6
80006316:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000631a:	f0 1f 00 10 	mcall	80006358 <vTaskIncrementTick+0x10c>
8000631e:	6a 08       	ld.w	r8,r5[0x0]
80006320:	70 08       	ld.w	r8,r8[0x0]
80006322:	58 08       	cp.w	r8,0
80006324:	cd 51       	brne	800062ce <vTaskIncrementTick+0x82>
80006326:	cc fb       	rjmp	800062c4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006328:	48 d8       	lddpc	r8,8000635c <vTaskIncrementTick+0x110>
8000632a:	70 09       	ld.w	r9,r8[0x0]
8000632c:	2f f9       	sub	r9,-1
8000632e:	91 09       	st.w	r8[0x0],r9
80006330:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006334:	00 00       	add	r0,r0
80006336:	0d 14       	ld.sh	r4,r6++
80006338:	00 00       	add	r0,r0
8000633a:	0d 10       	ld.sh	r0,r6++
8000633c:	00 00       	add	r0,r0
8000633e:	0c 1c       	sub	r12,r6
80006340:	00 00       	add	r0,r0
80006342:	0c 2c       	rsub	r12,r6
80006344:	00 00       	add	r0,r0
80006346:	0c 28       	rsub	r8,r6
80006348:	00 00       	add	r0,r0
8000634a:	05 34       	ld.ub	r4,r2++
8000634c:	00 00       	add	r0,r0
8000634e:	0d 4c       	ld.w	r12,--r6
80006350:	00 00       	add	r0,r0
80006352:	0c 30       	cp.w	r0,r6
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	58 4a       	cp.w	r10,4
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	57 fa       	stdsp	sp[0x1fc],r10
8000635c:	00 00       	add	r0,r0
8000635e:	0c 14       	sub	r4,r6

80006360 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006360:	eb cd 40 c0 	pushm	r6-r7,lr
80006364:	18 97       	mov	r7,r12
80006366:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006368:	f0 1f 00 15 	mcall	800063bc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000636c:	6c 08       	ld.w	r8,r6[0x0]
8000636e:	5b f8       	cp.w	r8,-1
80006370:	c0 31       	brne	80006376 <xTaskCheckForTimeOut+0x16>
80006372:	30 07       	mov	r7,0
80006374:	c1 f8       	rjmp	800063b2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006376:	49 39       	lddpc	r9,800063c0 <xTaskCheckForTimeOut+0x60>
80006378:	72 09       	ld.w	r9,r9[0x0]
8000637a:	6e 0a       	ld.w	r10,r7[0x0]
8000637c:	12 3a       	cp.w	r10,r9
8000637e:	c0 70       	breq	8000638c <xTaskCheckForTimeOut+0x2c>
80006380:	49 19       	lddpc	r9,800063c4 <xTaskCheckForTimeOut+0x64>
80006382:	72 09       	ld.w	r9,r9[0x0]
80006384:	6e 1a       	ld.w	r10,r7[0x4]
80006386:	12 3a       	cp.w	r10,r9
80006388:	e0 88 00 14 	brls	800063b0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000638c:	48 e9       	lddpc	r9,800063c4 <xTaskCheckForTimeOut+0x64>
8000638e:	72 0a       	ld.w	r10,r9[0x0]
80006390:	6e 19       	ld.w	r9,r7[0x4]
80006392:	12 1a       	sub	r10,r9
80006394:	14 38       	cp.w	r8,r10
80006396:	e0 88 00 0d 	brls	800063b0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000639a:	48 ba       	lddpc	r10,800063c4 <xTaskCheckForTimeOut+0x64>
8000639c:	74 0a       	ld.w	r10,r10[0x0]
8000639e:	14 19       	sub	r9,r10
800063a0:	f2 08 00 08 	add	r8,r9,r8
800063a4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800063a6:	0e 9c       	mov	r12,r7
800063a8:	f0 1f 00 08 	mcall	800063c8 <xTaskCheckForTimeOut+0x68>
800063ac:	30 07       	mov	r7,0
800063ae:	c0 28       	rjmp	800063b2 <xTaskCheckForTimeOut+0x52>
800063b0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800063b2:	f0 1f 00 07 	mcall	800063cc <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800063b6:	0e 9c       	mov	r12,r7
800063b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	59 04       	cp.w	r4,16
800063c0:	00 00       	add	r0,r0
800063c2:	0c 28       	rsub	r8,r6
800063c4:	00 00       	add	r0,r0
800063c6:	0d 10       	ld.sh	r0,r6++
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	60 c4       	ld.w	r4,r0[0x30]
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	5a 10       	cp.w	r0,-31

800063d0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800063d0:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800063d4:	f0 1f 00 05 	mcall	800063e8 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800063d8:	48 58       	lddpc	r8,800063ec <xTaskGetTickCount+0x1c>
800063da:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800063dc:	f0 1f 00 05 	mcall	800063f0 <xTaskGetTickCount+0x20>

	return xTicks;
}
800063e0:	0e 9c       	mov	r12,r7
800063e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800063e6:	00 00       	add	r0,r0
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	59 04       	cp.w	r4,16
800063ec:	00 00       	add	r0,r0
800063ee:	0d 10       	ld.sh	r0,r6++
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	5a 10       	cp.w	r0,-31

800063f4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800063f4:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800063f8:	f0 1f 00 2c 	mcall	800064a8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800063fc:	4a c8       	lddpc	r8,800064ac <xTaskResumeAll+0xb8>
800063fe:	70 09       	ld.w	r9,r8[0x0]
80006400:	20 19       	sub	r9,1
80006402:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006404:	70 08       	ld.w	r8,r8[0x0]
80006406:	58 08       	cp.w	r8,0
80006408:	c4 91       	brne	8000649a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000640a:	4a a8       	lddpc	r8,800064b0 <xTaskResumeAll+0xbc>
8000640c:	70 08       	ld.w	r8,r8[0x0]
8000640e:	58 08       	cp.w	r8,0
80006410:	c4 50       	breq	8000649a <xTaskResumeAll+0xa6>
80006412:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006414:	4a 85       	lddpc	r5,800064b4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006416:	4a 93       	lddpc	r3,800064b8 <xTaskResumeAll+0xc4>
80006418:	4a 92       	lddpc	r2,800064bc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000641a:	4a a1       	lddpc	r1,800064c0 <xTaskResumeAll+0xcc>
8000641c:	c1 e8       	rjmp	80006458 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000641e:	6a 38       	ld.w	r8,r5[0xc]
80006420:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006422:	ee cc ff e8 	sub	r12,r7,-24
80006426:	f0 1f 00 28 	mcall	800064c4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000642a:	ee c6 ff fc 	sub	r6,r7,-4
8000642e:	0c 9c       	mov	r12,r6
80006430:	f0 1f 00 25 	mcall	800064c4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006434:	6e bc       	ld.w	r12,r7[0x2c]
80006436:	66 08       	ld.w	r8,r3[0x0]
80006438:	10 3c       	cp.w	r12,r8
8000643a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000643e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006442:	0c 9b       	mov	r11,r6
80006444:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006448:	f0 1f 00 20 	mcall	800064c8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000644c:	62 08       	ld.w	r8,r1[0x0]
8000644e:	6e b9       	ld.w	r9,r7[0x2c]
80006450:	70 b8       	ld.w	r8,r8[0x2c]
80006452:	10 39       	cp.w	r9,r8
80006454:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006458:	6a 08       	ld.w	r8,r5[0x0]
8000645a:	58 08       	cp.w	r8,0
8000645c:	ce 11       	brne	8000641e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000645e:	49 c8       	lddpc	r8,800064cc <xTaskResumeAll+0xd8>
80006460:	70 08       	ld.w	r8,r8[0x0]
80006462:	58 08       	cp.w	r8,0
80006464:	c0 f0       	breq	80006482 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006466:	49 a8       	lddpc	r8,800064cc <xTaskResumeAll+0xd8>
80006468:	70 08       	ld.w	r8,r8[0x0]
8000646a:	58 08       	cp.w	r8,0
8000646c:	c1 10       	breq	8000648e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000646e:	49 87       	lddpc	r7,800064cc <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006470:	f0 1f 00 18 	mcall	800064d0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006474:	6e 08       	ld.w	r8,r7[0x0]
80006476:	20 18       	sub	r8,1
80006478:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000647a:	6e 08       	ld.w	r8,r7[0x0]
8000647c:	58 08       	cp.w	r8,0
8000647e:	cf 91       	brne	80006470 <xTaskResumeAll+0x7c>
80006480:	c0 78       	rjmp	8000648e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006482:	58 14       	cp.w	r4,1
80006484:	c0 50       	breq	8000648e <xTaskResumeAll+0x9a>
80006486:	49 48       	lddpc	r8,800064d4 <xTaskResumeAll+0xe0>
80006488:	70 08       	ld.w	r8,r8[0x0]
8000648a:	58 18       	cp.w	r8,1
8000648c:	c0 71       	brne	8000649a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000648e:	30 09       	mov	r9,0
80006490:	49 18       	lddpc	r8,800064d4 <xTaskResumeAll+0xe0>
80006492:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006494:	d7 33       	scall
80006496:	30 17       	mov	r7,1
80006498:	c0 28       	rjmp	8000649c <xTaskResumeAll+0xa8>
8000649a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000649c:	f0 1f 00 0f 	mcall	800064d8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800064a0:	0e 9c       	mov	r12,r7
800064a2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800064a6:	00 00       	add	r0,r0
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	59 04       	cp.w	r4,16
800064ac:	00 00       	add	r0,r0
800064ae:	0d 14       	ld.sh	r4,r6++
800064b0:	00 00       	add	r0,r0
800064b2:	0d 30       	ld.ub	r0,r6++
800064b4:	00 00       	add	r0,r0
800064b6:	0c e8       	st.h	--r6,r8
800064b8:	00 00       	add	r0,r0
800064ba:	0d 4c       	ld.w	r12,--r6
800064bc:	00 00       	add	r0,r0
800064be:	0c 30       	cp.w	r0,r6
800064c0:	00 00       	add	r0,r0
800064c2:	0c e4       	st.h	--r6,r4
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	58 4a       	cp.w	r10,4
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	57 fa       	stdsp	sp[0x1fc],r10
800064cc:	00 00       	add	r0,r0
800064ce:	0c 14       	sub	r4,r6
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	62 4c       	ld.w	r12,r1[0x10]
800064d4:	00 00       	add	r0,r0
800064d6:	0d 34       	ld.ub	r4,r6++
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	5a 10       	cp.w	r0,-31

800064dc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800064dc:	eb cd 40 80 	pushm	r7,lr
800064e0:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800064e2:	49 08       	lddpc	r8,80006520 <prvAddCurrentTaskToDelayedList+0x44>
800064e4:	70 08       	ld.w	r8,r8[0x0]
800064e6:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800064e8:	48 f8       	lddpc	r8,80006524 <prvAddCurrentTaskToDelayedList+0x48>
800064ea:	70 08       	ld.w	r8,r8[0x0]
800064ec:	10 3c       	cp.w	r12,r8
800064ee:	c0 a2       	brcc	80006502 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064f0:	48 c8       	lddpc	r8,80006520 <prvAddCurrentTaskToDelayedList+0x44>
800064f2:	70 0b       	ld.w	r11,r8[0x0]
800064f4:	48 d8       	lddpc	r8,80006528 <prvAddCurrentTaskToDelayedList+0x4c>
800064f6:	70 0c       	ld.w	r12,r8[0x0]
800064f8:	2f cb       	sub	r11,-4
800064fa:	f0 1f 00 0d 	mcall	8000652c <prvAddCurrentTaskToDelayedList+0x50>
800064fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006502:	48 88       	lddpc	r8,80006520 <prvAddCurrentTaskToDelayedList+0x44>
80006504:	70 0b       	ld.w	r11,r8[0x0]
80006506:	48 b8       	lddpc	r8,80006530 <prvAddCurrentTaskToDelayedList+0x54>
80006508:	70 0c       	ld.w	r12,r8[0x0]
8000650a:	2f cb       	sub	r11,-4
8000650c:	f0 1f 00 08 	mcall	8000652c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006510:	48 98       	lddpc	r8,80006534 <prvAddCurrentTaskToDelayedList+0x58>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	10 37       	cp.w	r7,r8
80006516:	c0 32       	brcc	8000651c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006518:	48 78       	lddpc	r8,80006534 <prvAddCurrentTaskToDelayedList+0x58>
8000651a:	91 07       	st.w	r8[0x0],r7
8000651c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006520:	00 00       	add	r0,r0
80006522:	0c e4       	st.h	--r6,r4
80006524:	00 00       	add	r0,r0
80006526:	0d 10       	ld.sh	r0,r6++
80006528:	00 00       	add	r0,r0
8000652a:	0c 2c       	rsub	r12,r6
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	58 16       	cp.w	r6,1
80006530:	00 00       	add	r0,r0
80006532:	0c 1c       	sub	r12,r6
80006534:	00 00       	add	r0,r0
80006536:	05 34       	ld.ub	r4,r2++

80006538 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006538:	eb cd 40 c0 	pushm	r6-r7,lr
8000653c:	18 96       	mov	r6,r12
8000653e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006540:	f0 1f 00 18 	mcall	800065a0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006544:	6c 08       	ld.w	r8,r6[0x0]
80006546:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006548:	49 79       	lddpc	r9,800065a4 <vTaskDelayUntil+0x6c>
8000654a:	72 09       	ld.w	r9,r9[0x0]
8000654c:	12 38       	cp.w	r8,r9
8000654e:	e0 88 00 0c 	brls	80006566 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006552:	0e 38       	cp.w	r8,r7
80006554:	e0 88 00 22 	brls	80006598 <vTaskDelayUntil+0x60>
80006558:	49 38       	lddpc	r8,800065a4 <vTaskDelayUntil+0x6c>
8000655a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000655c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000655e:	10 37       	cp.w	r7,r8
80006560:	e0 88 00 14 	brls	80006588 <vTaskDelayUntil+0x50>
80006564:	c0 a8       	rjmp	80006578 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006566:	0e 38       	cp.w	r8,r7
80006568:	e0 8b 00 16 	brhi	80006594 <vTaskDelayUntil+0x5c>
8000656c:	48 e8       	lddpc	r8,800065a4 <vTaskDelayUntil+0x6c>
8000656e:	70 08       	ld.w	r8,r8[0x0]
80006570:	10 37       	cp.w	r7,r8
80006572:	e0 8b 00 11 	brhi	80006594 <vTaskDelayUntil+0x5c>
80006576:	c1 18       	rjmp	80006598 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006578:	48 c8       	lddpc	r8,800065a8 <vTaskDelayUntil+0x70>
8000657a:	70 0c       	ld.w	r12,r8[0x0]
8000657c:	2f cc       	sub	r12,-4
8000657e:	f0 1f 00 0c 	mcall	800065ac <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006582:	0e 9c       	mov	r12,r7
80006584:	f0 1f 00 0b 	mcall	800065b0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006588:	f0 1f 00 0b 	mcall	800065b4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000658c:	c0 81       	brne	8000659c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000658e:	d7 33       	scall
80006590:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006594:	8d 07       	st.w	r6[0x0],r7
80006596:	cf 1b       	rjmp	80006578 <vTaskDelayUntil+0x40>
80006598:	8d 07       	st.w	r6[0x0],r7
8000659a:	cf 7b       	rjmp	80006588 <vTaskDelayUntil+0x50>
8000659c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	60 38       	ld.w	r8,r0[0xc]
800065a4:	00 00       	add	r0,r0
800065a6:	0d 10       	ld.sh	r0,r6++
800065a8:	00 00       	add	r0,r0
800065aa:	0c e4       	st.h	--r6,r4
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	58 4a       	cp.w	r10,4
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	64 dc       	ld.w	r12,r2[0x34]
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	63 f4       	ld.w	r4,r1[0x7c]

800065b8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800065b8:	eb cd 40 c0 	pushm	r6-r7,lr
800065bc:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800065be:	48 e7       	lddpc	r7,800065f4 <vTaskPlaceOnEventList+0x3c>
800065c0:	6e 0b       	ld.w	r11,r7[0x0]
800065c2:	2e 8b       	sub	r11,-24
800065c4:	f0 1f 00 0d 	mcall	800065f8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800065c8:	6e 0c       	ld.w	r12,r7[0x0]
800065ca:	2f cc       	sub	r12,-4
800065cc:	f0 1f 00 0c 	mcall	800065fc <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800065d0:	5b f6       	cp.w	r6,-1
800065d2:	c0 81       	brne	800065e2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800065d4:	6e 0b       	ld.w	r11,r7[0x0]
800065d6:	2f cb       	sub	r11,-4
800065d8:	48 ac       	lddpc	r12,80006600 <vTaskPlaceOnEventList+0x48>
800065da:	f0 1f 00 0b 	mcall	80006604 <vTaskPlaceOnEventList+0x4c>
800065de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800065e2:	48 a8       	lddpc	r8,80006608 <vTaskPlaceOnEventList+0x50>
800065e4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800065e6:	ec 0c 00 0c 	add	r12,r6,r12
800065ea:	f0 1f 00 09 	mcall	8000660c <vTaskPlaceOnEventList+0x54>
800065ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065f2:	00 00       	add	r0,r0
800065f4:	00 00       	add	r0,r0
800065f6:	0c e4       	st.h	--r6,r4
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	58 16       	cp.w	r6,1
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	58 4a       	cp.w	r10,4
80006600:	00 00       	add	r0,r0
80006602:	0d 38       	ld.ub	r8,r6++
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	57 fa       	stdsp	sp[0x1fc],r10
80006608:	00 00       	add	r0,r0
8000660a:	0d 10       	ld.sh	r0,r6++
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	64 dc       	ld.w	r12,r2[0x34]

80006610 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006610:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006614:	49 67       	lddpc	r7,8000666c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006616:	49 74       	lddpc	r4,80006670 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006618:	49 73       	lddpc	r3,80006674 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000661a:	49 85       	lddpc	r5,80006678 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000661c:	6e 08       	ld.w	r8,r7[0x0]
8000661e:	58 08       	cp.w	r8,0
80006620:	c1 e0       	breq	8000665c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006622:	f0 1f 00 17 	mcall	8000667c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006626:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006628:	f0 1f 00 16 	mcall	80006680 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
8000662c:	58 06       	cp.w	r6,0
8000662e:	c1 70       	breq	8000665c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006630:	f0 1f 00 15 	mcall	80006684 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006634:	68 38       	ld.w	r8,r4[0xc]
80006636:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006638:	ec cc ff fc 	sub	r12,r6,-4
8000663c:	f0 1f 00 13 	mcall	80006688 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006640:	66 08       	ld.w	r8,r3[0x0]
80006642:	20 18       	sub	r8,1
80006644:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006646:	6e 08       	ld.w	r8,r7[0x0]
80006648:	20 18       	sub	r8,1
8000664a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
8000664c:	f0 1f 00 10 	mcall	8000668c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006650:	6c cc       	ld.w	r12,r6[0x30]
80006652:	f0 1f 00 10 	mcall	80006690 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006656:	0c 9c       	mov	r12,r6
80006658:	f0 1f 00 0e 	mcall	80006690 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000665c:	6a 08       	ld.w	r8,r5[0x0]
8000665e:	58 18       	cp.w	r8,1
80006660:	e0 88 00 03 	brls	80006666 <prvIdleTask+0x56>
			{
				taskYIELD();
80006664:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006666:	f0 1f 00 0c 	mcall	80006694 <prvIdleTask+0x84>
		}
		#endif
	}
8000666a:	cd 9b       	rjmp	8000661c <prvIdleTask+0xc>
8000666c:	00 00       	add	r0,r0
8000666e:	0c 24       	rsub	r4,r6
80006670:	00 00       	add	r0,r0
80006672:	0c d0       	st.w	--r6,r0
80006674:	00 00       	add	r0,r0
80006676:	0d 30       	ld.ub	r0,r6++
80006678:	00 00       	add	r0,r0
8000667a:	0c 30       	cp.w	r0,r6
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	60 38       	ld.w	r8,r0[0xc]
80006680:	80 00       	ld.sh	r0,r0[0x0]
80006682:	63 f4       	ld.w	r4,r1[0x7c]
80006684:	80 00       	ld.sh	r0,r0[0x0]
80006686:	59 04       	cp.w	r4,16
80006688:	80 00       	ld.sh	r0,r0[0x0]
8000668a:	58 4a       	cp.w	r10,4
8000668c:	80 00       	ld.sh	r0,r0[0x0]
8000668e:	5a 10       	cp.w	r0,-31
80006690:	80 00       	ld.sh	r0,r0[0x0]
80006692:	5b 48       	cp.w	r8,-12
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	20 2c       	sub	r12,2

80006698 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006698:	d4 31       	pushm	r0-r7,lr
8000669a:	20 1d       	sub	sp,4
8000669c:	fa c4 ff d8 	sub	r4,sp,-40
800066a0:	50 0c       	stdsp	sp[0x0],r12
800066a2:	16 91       	mov	r1,r11
800066a4:	14 97       	mov	r7,r10
800066a6:	12 90       	mov	r0,r9
800066a8:	10 93       	mov	r3,r8
800066aa:	68 02       	ld.w	r2,r4[0x0]
800066ac:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800066ae:	34 8c       	mov	r12,72
800066b0:	f0 1f 00 5c 	mcall	80006820 <xTaskGenericCreate+0x188>
800066b4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800066b6:	c0 31       	brne	800066bc <xTaskGenericCreate+0x24>
800066b8:	3f fc       	mov	r12,-1
800066ba:	ca f8       	rjmp	80006818 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800066bc:	58 06       	cp.w	r6,0
800066be:	e0 81 00 af 	brne	8000681c <xTaskGenericCreate+0x184>
800066c2:	0e 9c       	mov	r12,r7
800066c4:	5c 7c       	castu.h	r12
800066c6:	a3 6c       	lsl	r12,0x2
800066c8:	f0 1f 00 56 	mcall	80006820 <xTaskGenericCreate+0x188>
800066cc:	18 96       	mov	r6,r12
800066ce:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800066d0:	c0 61       	brne	800066dc <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800066d2:	0a 9c       	mov	r12,r5
800066d4:	f0 1f 00 54 	mcall	80006824 <xTaskGenericCreate+0x18c>
800066d8:	3f fc       	mov	r12,-1
800066da:	c9 f8       	rjmp	80006818 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800066dc:	5c 77       	castu.h	r7
800066de:	ee 0a 15 02 	lsl	r10,r7,0x2
800066e2:	e0 6b 00 a5 	mov	r11,165
800066e6:	0c 9c       	mov	r12,r6
800066e8:	f0 1f 00 50 	mcall	80006828 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800066ec:	ee c6 00 01 	sub	r6,r7,1
800066f0:	6a c8       	ld.w	r8,r5[0x30]
800066f2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800066f6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800066fa:	31 0a       	mov	r10,16
800066fc:	02 9b       	mov	r11,r1
800066fe:	ea cc ff cc 	sub	r12,r5,-52
80006702:	f0 1f 00 4b 	mcall	8000682c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006706:	30 08       	mov	r8,0
80006708:	eb 68 00 43 	st.b	r5[67],r8
8000670c:	58 73       	cp.w	r3,7
8000670e:	e6 07 17 80 	movls	r7,r3
80006712:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006716:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006718:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000671c:	ea c4 ff fc 	sub	r4,r5,-4
80006720:	08 9c       	mov	r12,r4
80006722:	f0 1f 00 44 	mcall	80006830 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006726:	ea cc ff e8 	sub	r12,r5,-24
8000672a:	f0 1f 00 42 	mcall	80006830 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000672e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006730:	ee 07 11 08 	rsub	r7,r7,8
80006734:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006736:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006738:	00 9a       	mov	r10,r0
8000673a:	40 0b       	lddsp	r11,sp[0x0]
8000673c:	0c 9c       	mov	r12,r6
8000673e:	f0 1f 00 3e 	mcall	80006834 <xTaskGenericCreate+0x19c>
80006742:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006744:	58 02       	cp.w	r2,0
80006746:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000674a:	f0 1f 00 3c 	mcall	80006838 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000674e:	4b c8       	lddpc	r8,8000683c <xTaskGenericCreate+0x1a4>
80006750:	70 09       	ld.w	r9,r8[0x0]
80006752:	2f f9       	sub	r9,-1
80006754:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006756:	4b b8       	lddpc	r8,80006840 <xTaskGenericCreate+0x1a8>
80006758:	70 08       	ld.w	r8,r8[0x0]
8000675a:	58 08       	cp.w	r8,0
8000675c:	c2 61       	brne	800067a8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000675e:	4b 98       	lddpc	r8,80006840 <xTaskGenericCreate+0x1a8>
80006760:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006762:	4b 78       	lddpc	r8,8000683c <xTaskGenericCreate+0x1a4>
80006764:	70 08       	ld.w	r8,r8[0x0]
80006766:	58 18       	cp.w	r8,1
80006768:	c2 b1       	brne	800067be <xTaskGenericCreate+0x126>
8000676a:	4b 77       	lddpc	r7,80006844 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000676c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006770:	0e 9c       	mov	r12,r7
80006772:	f0 1f 00 36 	mcall	80006848 <xTaskGenericCreate+0x1b0>
80006776:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006778:	0c 37       	cp.w	r7,r6
8000677a:	cf b1       	brne	80006770 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000677c:	4b 47       	lddpc	r7,8000684c <xTaskGenericCreate+0x1b4>
8000677e:	0e 9c       	mov	r12,r7
80006780:	f0 1f 00 32 	mcall	80006848 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006784:	4b 36       	lddpc	r6,80006850 <xTaskGenericCreate+0x1b8>
80006786:	0c 9c       	mov	r12,r6
80006788:	f0 1f 00 30 	mcall	80006848 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000678c:	4b 2c       	lddpc	r12,80006854 <xTaskGenericCreate+0x1bc>
8000678e:	f0 1f 00 2f 	mcall	80006848 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006792:	4b 2c       	lddpc	r12,80006858 <xTaskGenericCreate+0x1c0>
80006794:	f0 1f 00 2d 	mcall	80006848 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006798:	4b 1c       	lddpc	r12,8000685c <xTaskGenericCreate+0x1c4>
8000679a:	f0 1f 00 2c 	mcall	80006848 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000679e:	4b 18       	lddpc	r8,80006860 <xTaskGenericCreate+0x1c8>
800067a0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800067a2:	4b 18       	lddpc	r8,80006864 <xTaskGenericCreate+0x1cc>
800067a4:	91 06       	st.w	r8[0x0],r6
800067a6:	c0 c8       	rjmp	800067be <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800067a8:	4b 08       	lddpc	r8,80006868 <xTaskGenericCreate+0x1d0>
800067aa:	70 08       	ld.w	r8,r8[0x0]
800067ac:	58 08       	cp.w	r8,0
800067ae:	c0 81       	brne	800067be <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800067b0:	4a 48       	lddpc	r8,80006840 <xTaskGenericCreate+0x1a8>
800067b2:	70 08       	ld.w	r8,r8[0x0]
800067b4:	70 b8       	ld.w	r8,r8[0x2c]
800067b6:	10 33       	cp.w	r3,r8
800067b8:	c0 33       	brcs	800067be <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800067ba:	4a 28       	lddpc	r8,80006840 <xTaskGenericCreate+0x1a8>
800067bc:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800067be:	6a b8       	ld.w	r8,r5[0x2c]
800067c0:	4a b9       	lddpc	r9,8000686c <xTaskGenericCreate+0x1d4>
800067c2:	72 09       	ld.w	r9,r9[0x0]
800067c4:	12 38       	cp.w	r8,r9
800067c6:	e0 88 00 04 	brls	800067ce <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800067ca:	4a 99       	lddpc	r9,8000686c <xTaskGenericCreate+0x1d4>
800067cc:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800067ce:	4a 98       	lddpc	r8,80006870 <xTaskGenericCreate+0x1d8>
800067d0:	70 09       	ld.w	r9,r8[0x0]
800067d2:	2f f9       	sub	r9,-1
800067d4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800067d6:	6a b8       	ld.w	r8,r5[0x2c]
800067d8:	4a 79       	lddpc	r9,80006874 <xTaskGenericCreate+0x1dc>
800067da:	72 09       	ld.w	r9,r9[0x0]
800067dc:	12 38       	cp.w	r8,r9
800067de:	e0 88 00 04 	brls	800067e6 <xTaskGenericCreate+0x14e>
800067e2:	4a 59       	lddpc	r9,80006874 <xTaskGenericCreate+0x1dc>
800067e4:	93 08       	st.w	r9[0x0],r8
800067e6:	6a bc       	ld.w	r12,r5[0x2c]
800067e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067ec:	08 9b       	mov	r11,r4
800067ee:	49 68       	lddpc	r8,80006844 <xTaskGenericCreate+0x1ac>
800067f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067f4:	f0 1f 00 21 	mcall	80006878 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800067f8:	f0 1f 00 21 	mcall	8000687c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800067fc:	49 b8       	lddpc	r8,80006868 <xTaskGenericCreate+0x1d0>
800067fe:	70 08       	ld.w	r8,r8[0x0]
80006800:	58 08       	cp.w	r8,0
80006802:	c0 a0       	breq	80006816 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006804:	48 f8       	lddpc	r8,80006840 <xTaskGenericCreate+0x1a8>
80006806:	70 08       	ld.w	r8,r8[0x0]
80006808:	70 b8       	ld.w	r8,r8[0x2c]
8000680a:	10 33       	cp.w	r3,r8
8000680c:	e0 88 00 05 	brls	80006816 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006810:	d7 33       	scall
80006812:	30 1c       	mov	r12,1
80006814:	c0 28       	rjmp	80006818 <xTaskGenericCreate+0x180>
80006816:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006818:	2f fd       	sub	sp,-4
8000681a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000681c:	99 c6       	st.w	r12[0x30],r6
8000681e:	c5 fb       	rjmp	800066dc <xTaskGenericCreate+0x44>
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	5b 70       	cp.w	r0,-9
80006824:	80 00       	ld.sh	r0,r0[0x0]
80006826:	5b 48       	cp.w	r8,-12
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	74 5e       	ld.w	lr,r10[0x14]
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	77 88       	ld.w	r8,r11[0x60]
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	57 f4       	stdsp	sp[0x1fc],r4
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	58 70       	cp.w	r0,7
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	59 04       	cp.w	r4,16
8000683c:	00 00       	add	r0,r0
8000683e:	0d 30       	ld.ub	r0,r6++
80006840:	00 00       	add	r0,r0
80006842:	0c e4       	st.h	--r6,r4
80006844:	00 00       	add	r0,r0
80006846:	0c 30       	cp.w	r0,r6
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	57 e0       	stdsp	sp[0x1f8],r0
8000684c:	00 00       	add	r0,r0
8000684e:	0c fc       	st.b	--r6,r12
80006850:	00 00       	add	r0,r0
80006852:	0d 18       	ld.sh	r8,r6++
80006854:	00 00       	add	r0,r0
80006856:	0c e8       	st.h	--r6,r8
80006858:	00 00       	add	r0,r0
8000685a:	0c d0       	st.w	--r6,r0
8000685c:	00 00       	add	r0,r0
8000685e:	0d 38       	ld.ub	r8,r6++
80006860:	00 00       	add	r0,r0
80006862:	0c 1c       	sub	r12,r6
80006864:	00 00       	add	r0,r0
80006866:	0c 2c       	rsub	r12,r6
80006868:	00 00       	add	r0,r0
8000686a:	0c 20       	rsub	r0,r6
8000686c:	00 00       	add	r0,r0
8000686e:	0c 18       	sub	r8,r6
80006870:	00 00       	add	r0,r0
80006872:	0d 2c       	ld.uh	r12,r6++
80006874:	00 00       	add	r0,r0
80006876:	0d 4c       	ld.w	r12,--r6
80006878:	80 00       	ld.sh	r0,r0[0x0]
8000687a:	57 fa       	stdsp	sp[0x1fc],r10
8000687c:	80 00       	ld.sh	r0,r0[0x0]
8000687e:	5a 10       	cp.w	r0,-31

80006880 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006880:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006882:	30 09       	mov	r9,0
80006884:	1a d9       	st.w	--sp,r9
80006886:	1a d9       	st.w	--sp,r9
80006888:	1a d9       	st.w	--sp,r9
8000688a:	12 98       	mov	r8,r9
8000688c:	e0 6a 01 00 	mov	r10,256
80006890:	48 9b       	lddpc	r11,800068b4 <vTaskStartScheduler+0x34>
80006892:	48 ac       	lddpc	r12,800068b8 <vTaskStartScheduler+0x38>
80006894:	f0 1f 00 0a 	mcall	800068bc <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006898:	2f dd       	sub	sp,-12
8000689a:	58 1c       	cp.w	r12,1
8000689c:	c0 a1       	brne	800068b0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000689e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800068a0:	30 19       	mov	r9,1
800068a2:	48 88       	lddpc	r8,800068c0 <vTaskStartScheduler+0x40>
800068a4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800068a6:	30 09       	mov	r9,0
800068a8:	48 78       	lddpc	r8,800068c4 <vTaskStartScheduler+0x44>
800068aa:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800068ac:	f0 1f 00 07 	mcall	800068c8 <vTaskStartScheduler+0x48>
800068b0:	d8 02       	popm	pc
800068b2:	00 00       	add	r0,r0
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	d3 3c       	*unknown*
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	66 10       	ld.w	r0,r3[0x4]
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	66 98       	ld.w	r8,r3[0x24]
800068c0:	00 00       	add	r0,r0
800068c2:	0c 20       	rsub	r0,r6
800068c4:	00 00       	add	r0,r0
800068c6:	0d 10       	ld.sh	r0,r6++
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	59 14       	cp.w	r4,17

800068cc <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800068cc:	16 cc       	st.b	r11++,r12
	return str;
}
800068ce:	5e fb       	retal	r11

800068d0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800068d0:	eb cd 40 c0 	pushm	r6-r7,lr
800068d4:	20 3d       	sub	sp,12
800068d6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800068d8:	30 06       	mov	r6,0
800068da:	30 07       	mov	r7,0
800068dc:	fa e7 00 00 	st.d	sp[0],r6
800068e0:	30 0c       	mov	r12,0
800068e2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800068e4:	58 08       	cp.w	r8,0
800068e6:	c1 30       	breq	8000690c <PrintHex+0x3c>
800068e8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800068ea:	1a 9c       	mov	r12,sp
800068ec:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068f0:	58 9e       	cp.w	lr,9
800068f2:	e0 8a 00 04 	brle	800068fa <PrintHex+0x2a>
800068f6:	2c 9e       	sub	lr,-55
800068f8:	c0 48       	rjmp	80006900 <PrintHex+0x30>
800068fa:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068fe:	2d 0e       	sub	lr,-48
80006900:	f8 09 0b 0e 	st.b	r12[r9],lr
80006904:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006906:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006908:	cf 21       	brne	800068ec <PrintHex+0x1c>
8000690a:	c0 48       	rjmp	80006912 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000690c:	33 08       	mov	r8,48
8000690e:	ba 88       	st.b	sp[0x0],r8
80006910:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006912:	f6 09 01 08 	sub	r8,r11,r9
80006916:	58 08       	cp.w	r8,0
80006918:	e0 8a 00 13 	brle	8000693e <PrintHex+0x6e>
	{
		char num = len - cnt;
8000691c:	12 1b       	sub	r11,r9
8000691e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006922:	18 9e       	mov	lr,r12
80006924:	58 0c       	cp.w	r12,0
80006926:	e0 8a 00 0c 	brle	8000693e <PrintHex+0x6e>
8000692a:	1a 9b       	mov	r11,sp
8000692c:	12 0b       	add	r11,r9
8000692e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006930:	33 07       	mov	r7,48
80006932:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006934:	2f f8       	sub	r8,-1
80006936:	1c 38       	cp.w	r8,lr
80006938:	cf d5       	brlt	80006932 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000693a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000693e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006942:	f0 cb ff ff 	sub	r11,r8,-1
80006946:	58 0b       	cp.w	r11,0
80006948:	e0 8a 00 19 	brle	8000697a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000694c:	fa cb ff f4 	sub	r11,sp,-12
80006950:	f6 09 00 09 	add	r9,r11,r9
80006954:	37 8b       	mov	r11,120
80006956:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000695a:	fa c9 ff f4 	sub	r9,sp,-12
8000695e:	10 09       	add	r9,r8
80006960:	33 0b       	mov	r11,48
80006962:	f3 6b ff f4 	st.b	r9[-12],r11
80006966:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000696a:	fa ce 00 01 	sub	lr,sp,1
8000696e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006970:	11 8b       	ld.ub	r11,r8[0x0]
80006972:	12 cb       	st.b	r9++,r11
80006974:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006976:	1c 38       	cp.w	r8,lr
80006978:	cf c1       	brne	80006970 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000697a:	14 9c       	mov	r12,r10
8000697c:	2f dd       	sub	sp,-12
8000697e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006982 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006982:	d4 21       	pushm	r4-r7,lr
80006984:	20 3d       	sub	sp,12
80006986:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006988:	30 06       	mov	r6,0
8000698a:	30 07       	mov	r7,0
8000698c:	fa e7 00 00 	st.d	sp[0],r6
80006990:	30 0c       	mov	r12,0
80006992:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006994:	58 08       	cp.w	r8,0
80006996:	c0 35       	brlt	8000699c <PrintDec+0x1a>
80006998:	14 97       	mov	r7,r10
8000699a:	c0 58       	rjmp	800069a4 <PrintDec+0x22>
	{
		*p++ = '-';
8000699c:	14 97       	mov	r7,r10
8000699e:	32 d9       	mov	r9,45
800069a0:	0e c9       	st.b	r7++,r9
		i = -i;
800069a2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800069a4:	58 08       	cp.w	r8,0
800069a6:	c0 51       	brne	800069b0 <PrintDec+0x2e>
800069a8:	33 08       	mov	r8,48
800069aa:	ba 88       	st.b	sp[0x0],r8
800069ac:	30 1e       	mov	lr,1
800069ae:	c2 f8       	rjmp	80006a0c <PrintDec+0x8a>
	
	int ten = i%10;
800069b0:	e0 65 66 67 	mov	r5,26215
800069b4:	ea 15 66 66 	orh	r5,0x6666
800069b8:	f0 05 04 44 	muls.d	r4,r8,r5
800069bc:	ea 0c 14 02 	asr	r12,r5,0x2
800069c0:	f0 09 14 1f 	asr	r9,r8,0x1f
800069c4:	f8 09 01 09 	sub	r9,r12,r9
800069c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800069cc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800069d0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800069d2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800069d4:	e0 66 66 67 	mov	r6,26215
800069d8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800069dc:	2d 09       	sub	r9,-48
800069de:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800069e2:	2f fe       	sub	lr,-1
		i /= 10;
800069e4:	f0 06 04 44 	muls.d	r4,r8,r6
800069e8:	ea 09 14 02 	asr	r9,r5,0x2
800069ec:	bf 58       	asr	r8,0x1f
800069ee:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800069f2:	f0 06 04 44 	muls.d	r4,r8,r6
800069f6:	ea 09 14 02 	asr	r9,r5,0x2
800069fa:	f0 05 14 1f 	asr	r5,r8,0x1f
800069fe:	0a 19       	sub	r9,r5
80006a00:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006a04:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006a08:	58 08       	cp.w	r8,0
80006a0a:	ce 91       	brne	800069dc <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006a0c:	f6 0e 01 08 	sub	r8,r11,lr
80006a10:	58 08       	cp.w	r8,0
80006a12:	e0 89 00 06 	brgt	80006a1e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006a16:	58 0e       	cp.w	lr,0
80006a18:	e0 89 00 14 	brgt	80006a40 <PrintDec+0xbe>
80006a1c:	c1 d8       	rjmp	80006a56 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006a1e:	1c 1b       	sub	r11,lr
80006a20:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006a22:	16 9c       	mov	r12,r11
80006a24:	58 0b       	cp.w	r11,0
80006a26:	fe 9a ff f8 	brle	80006a16 <PrintDec+0x94>
80006a2a:	1a 99       	mov	r9,sp
80006a2c:	1c 09       	add	r9,lr
80006a2e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006a30:	33 06       	mov	r6,48
80006a32:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006a34:	2f f8       	sub	r8,-1
80006a36:	18 38       	cp.w	r8,r12
80006a38:	cf d5       	brlt	80006a32 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006a3a:	f6 0e 00 0e 	add	lr,r11,lr
80006a3e:	ce cb       	rjmp	80006a16 <PrintDec+0x94>
80006a40:	fa c8 ff f4 	sub	r8,sp,-12
80006a44:	1c 08       	add	r8,lr
80006a46:	20 d8       	sub	r8,13
80006a48:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006a4c:	11 89       	ld.ub	r9,r8[0x0]
80006a4e:	0e c9       	st.b	r7++,r9
80006a50:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006a52:	16 38       	cp.w	r8,r11
80006a54:	cf c1       	brne	80006a4c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006a56:	14 9c       	mov	r12,r10
80006a58:	2f dd       	sub	sp,-12
80006a5a:	d8 22       	popm	r4-r7,pc

80006a5c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006a5c:	d4 31       	pushm	r0-r7,lr
80006a5e:	fa cd 02 08 	sub	sp,sp,520
80006a62:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006a64:	e0 6a 01 00 	mov	r10,256
80006a68:	30 0b       	mov	r11,0
80006a6a:	fa cc fe f8 	sub	r12,sp,-264
80006a6e:	f0 1f 00 4e 	mcall	80006ba4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006a72:	fa c4 fd d4 	sub	r4,sp,-556
80006a76:	30 0a       	mov	r10,0
80006a78:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a7a:	fa c3 ff fc 	sub	r3,sp,-4
80006a7e:	e0 61 01 00 	mov	r1,256
80006a82:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006a84:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a86:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a8a:	02 9a       	mov	r10,r1
80006a8c:	00 9b       	mov	r11,r0
80006a8e:	06 9c       	mov	r12,r3
80006a90:	f0 1f 00 45 	mcall	80006ba4 <log+0x148>
			
					if(*str == '%')
80006a94:	0f 88       	ld.ub	r8,r7[0x0]
80006a96:	e4 08 18 00 	cp.b	r8,r2
80006a9a:	c5 71       	brne	80006b48 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006a9c:	ee c8 ff ff 	sub	r8,r7,-1
80006aa0:	11 89       	ld.ub	r9,r8[0x0]
80006aa2:	4c 2a       	lddpc	r10,80006ba8 <log+0x14c>
80006aa4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006aa6:	23 09       	sub	r9,48
80006aa8:	30 9a       	mov	r10,9
80006aaa:	f4 09 18 00 	cp.b	r9,r10
80006aae:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006ab2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006ab6:	f7 b9 08 30 	subls	r9,48
80006aba:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006abe:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006ac2:	0f 88       	ld.ub	r8,r7[0x0]
80006ac4:	22 58       	sub	r8,37
80006ac6:	e0 48 00 53 	cp.w	r8,83
80006aca:	e0 8b 00 31 	brhi	80006b2c <log+0xd0>
80006ace:	4b 89       	lddpc	r9,80006bac <log+0x150>
80006ad0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006ad4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006ad8:	06 9a       	mov	r10,r3
80006ada:	40 0b       	lddsp	r11,sp[0x0]
80006adc:	5c 5b       	castu.b	r11
80006ade:	68 0c       	ld.w	r12,r4[0x0]
80006ae0:	f0 1f 00 34 	mcall	80006bb0 <log+0x154>
							break;
80006ae4:	c2 98       	rjmp	80006b36 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006ae6:	4b 4c       	lddpc	r12,80006bb4 <log+0x158>
80006ae8:	f0 1f 00 34 	mcall	80006bb8 <log+0x15c>
80006aec:	08 95       	mov	r5,r4
80006aee:	06 9c       	mov	r12,r3
							break;
80006af0:	c2 38       	rjmp	80006b36 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006af2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006af6:	06 9a       	mov	r10,r3
80006af8:	40 0b       	lddsp	r11,sp[0x0]
80006afa:	5c 5b       	castu.b	r11
80006afc:	68 0c       	ld.w	r12,r4[0x0]
80006afe:	f0 1f 00 30 	mcall	80006bbc <log+0x160>
80006b02:	06 9c       	mov	r12,r3
							break;
80006b04:	c1 98       	rjmp	80006b36 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006b06:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006b0a:	06 9b       	mov	r11,r3
80006b0c:	09 bc       	ld.ub	r12,r4[0x3]
80006b0e:	f0 1f 00 2d 	mcall	80006bc0 <log+0x164>
80006b12:	06 9c       	mov	r12,r3
							break;
80006b14:	c1 18       	rjmp	80006b36 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006b16:	e8 c5 ff fc 	sub	r5,r4,-4
80006b1a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006b1c:	c0 d8       	rjmp	80006b36 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006b1e:	06 9b       	mov	r11,r3
80006b20:	32 5c       	mov	r12,37
80006b22:	f0 1f 00 28 	mcall	80006bc0 <log+0x164>
80006b26:	08 95       	mov	r5,r4
80006b28:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006b2a:	c0 68       	rjmp	80006b36 <log+0xda>
							
							default:
							log("I need relax.");
80006b2c:	4a 6c       	lddpc	r12,80006bc4 <log+0x168>
80006b2e:	f0 1f 00 23 	mcall	80006bb8 <log+0x15c>
80006b32:	08 95       	mov	r5,r4
80006b34:	06 9c       	mov	r12,r3
						}
						str++;
80006b36:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006b38:	1a dc       	st.w	--sp,r12
80006b3a:	1a d6       	st.w	--sp,r6
80006b3c:	4a 3b       	lddpc	r11,80006bc8 <log+0x16c>
80006b3e:	0c 9c       	mov	r12,r6
80006b40:	f0 1f 00 23 	mcall	80006bcc <log+0x170>
80006b44:	2f ed       	sub	sp,-8
80006b46:	c0 a8       	rjmp	80006b5a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b48:	2f f7       	sub	r7,-1
80006b4a:	1a d8       	st.w	--sp,r8
80006b4c:	1a d6       	st.w	--sp,r6
80006b4e:	4a 1b       	lddpc	r11,80006bd0 <log+0x174>
80006b50:	0c 9c       	mov	r12,r6
80006b52:	f0 1f 00 1f 	mcall	80006bcc <log+0x170>
80006b56:	08 95       	mov	r5,r4
80006b58:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006b5a:	0f 89       	ld.ub	r9,r7[0x0]
80006b5c:	30 08       	mov	r8,0
80006b5e:	f0 09 18 00 	cp.b	r9,r8
80006b62:	c0 30       	breq	80006b68 <log+0x10c>
80006b64:	0a 94       	mov	r4,r5
80006b66:	c9 2b       	rjmp	80006a8a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006b68:	fa c7 fe f8 	sub	r7,sp,-264
80006b6c:	1a d7       	st.w	--sp,r7
80006b6e:	49 ab       	lddpc	r11,80006bd4 <log+0x178>
80006b70:	0e 9c       	mov	r12,r7
80006b72:	f0 1f 00 17 	mcall	80006bcc <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006b76:	5c 5c       	castu.b	r12
80006b78:	f8 c6 ff ff 	sub	r6,r12,-1
80006b7c:	0c 9c       	mov	r12,r6
80006b7e:	f0 1f 00 17 	mcall	80006bd8 <log+0x17c>
80006b82:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006b84:	0c 9a       	mov	r10,r6
80006b86:	0e 9b       	mov	r11,r7
80006b88:	f0 1f 00 15 	mcall	80006bdc <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006b8c:	30 09       	mov	r9,0
80006b8e:	30 5a       	mov	r10,5
80006b90:	fa cb fe f8 	sub	r11,sp,-264
80006b94:	49 38       	lddpc	r8,80006be0 <log+0x184>
80006b96:	70 0c       	ld.w	r12,r8[0x0]
80006b98:	f0 1f 00 13 	mcall	80006be4 <log+0x188>
80006b9c:	2f fd       	sub	sp,-4
	
	
}
80006b9e:	fe 3d fd f8 	sub	sp,-520
80006ba2:	d8 32       	popm	r0-r7,pc
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	74 5e       	ld.w	lr,r10[0x14]
80006ba8:	00 00       	add	r0,r0
80006baa:	0d 50       	ld.sh	r0,--r6
80006bac:	80 00       	ld.sh	r0,r0[0x0]
80006bae:	d3 44       	*unknown*
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	69 82       	ld.w	r2,r4[0x60]
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	d5 f0       	acall	0x5f
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	6a 5c       	ld.w	r12,r5[0x14]
80006bbc:	80 00       	ld.sh	r0,r0[0x0]
80006bbe:	68 d0       	ld.w	r0,r4[0x34]
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	68 cc       	ld.w	r12,r4[0x30]
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	d6 00       	acall	0x60
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	d6 10       	acall	0x61
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	77 4c       	ld.w	r12,r11[0x50]
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	d6 18       	*unknown*
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	d6 20       	acall	0x62
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	5b 70       	cp.w	r0,-9
80006bdc:	80 00       	ld.sh	r0,r0[0x0]
80006bde:	73 16       	ld.w	r6,r9[0x44]
80006be0:	00 00       	add	r0,r0
80006be2:	63 9c       	ld.w	r12,r1[0x64]
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	5e c4       	retvs	r4

80006be8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006be8:	d4 31       	pushm	r0-r7,lr
80006bea:	fa cd 02 0c 	sub	sp,sp,524
80006bee:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006bf0:	e0 6a 01 00 	mov	r10,256
80006bf4:	30 0b       	mov	r11,0
80006bf6:	fa cc fe f4 	sub	r12,sp,-268
80006bfa:	f0 1f 00 4c 	mcall	80006d28 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006bfe:	fa c4 fd d0 	sub	r4,sp,-560
80006c02:	30 0a       	mov	r10,0
80006c04:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006c06:	fa c3 ff fc 	sub	r3,sp,-4
80006c0a:	e0 61 01 00 	mov	r1,256
80006c0e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006c10:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c12:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006c16:	02 9a       	mov	r10,r1
80006c18:	00 9b       	mov	r11,r0
80006c1a:	06 9c       	mov	r12,r3
80006c1c:	f0 1f 00 43 	mcall	80006d28 <logFromISR+0x140>
			
			if(*str == '%')
80006c20:	0f 88       	ld.ub	r8,r7[0x0]
80006c22:	e4 08 18 00 	cp.b	r8,r2
80006c26:	c5 11       	brne	80006cc8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006c28:	ee c8 ff ff 	sub	r8,r7,-1
80006c2c:	11 89       	ld.ub	r9,r8[0x0]
80006c2e:	4c 0a       	lddpc	r10,80006d2c <logFromISR+0x144>
80006c30:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006c32:	23 09       	sub	r9,48
80006c34:	30 9a       	mov	r10,9
80006c36:	f4 09 18 00 	cp.b	r9,r10
80006c3a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006c3e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006c42:	f7 b9 08 30 	subls	r9,48
80006c46:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006c4a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006c4e:	0f 88       	ld.ub	r8,r7[0x0]
80006c50:	22 58       	sub	r8,37
80006c52:	e0 48 00 53 	cp.w	r8,83
80006c56:	e0 8b 00 2b 	brhi	80006cac <logFromISR+0xc4>
80006c5a:	4b 69       	lddpc	r9,80006d30 <logFromISR+0x148>
80006c5c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006c60:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006c64:	06 9a       	mov	r10,r3
80006c66:	40 0b       	lddsp	r11,sp[0x0]
80006c68:	5c 5b       	castu.b	r11
80006c6a:	68 0c       	ld.w	r12,r4[0x0]
80006c6c:	f0 1f 00 32 	mcall	80006d34 <logFromISR+0x14c>
					break;
80006c70:	c2 38       	rjmp	80006cb6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006c72:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006c76:	06 9a       	mov	r10,r3
80006c78:	40 0b       	lddsp	r11,sp[0x0]
80006c7a:	5c 5b       	castu.b	r11
80006c7c:	68 0c       	ld.w	r12,r4[0x0]
80006c7e:	f0 1f 00 2f 	mcall	80006d38 <logFromISR+0x150>
80006c82:	06 9c       	mov	r12,r3
					break;
80006c84:	c1 98       	rjmp	80006cb6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006c86:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006c8a:	06 9b       	mov	r11,r3
80006c8c:	09 bc       	ld.ub	r12,r4[0x3]
80006c8e:	f0 1f 00 2c 	mcall	80006d3c <logFromISR+0x154>
80006c92:	06 9c       	mov	r12,r3
					break;
80006c94:	c1 18       	rjmp	80006cb6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006c96:	e8 c5 ff fc 	sub	r5,r4,-4
80006c9a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006c9c:	c0 d8       	rjmp	80006cb6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006c9e:	06 9b       	mov	r11,r3
80006ca0:	32 5c       	mov	r12,37
80006ca2:	f0 1f 00 27 	mcall	80006d3c <logFromISR+0x154>
80006ca6:	08 95       	mov	r5,r4
80006ca8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006caa:	c0 68       	rjmp	80006cb6 <logFromISR+0xce>
					default:
					log("I need relax.");
80006cac:	4a 5c       	lddpc	r12,80006d40 <logFromISR+0x158>
80006cae:	f0 1f 00 26 	mcall	80006d44 <logFromISR+0x15c>
80006cb2:	08 95       	mov	r5,r4
80006cb4:	06 9c       	mov	r12,r3
				}
				str++;
80006cb6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006cb8:	1a dc       	st.w	--sp,r12
80006cba:	1a d6       	st.w	--sp,r6
80006cbc:	4a 3b       	lddpc	r11,80006d48 <logFromISR+0x160>
80006cbe:	0c 9c       	mov	r12,r6
80006cc0:	f0 1f 00 23 	mcall	80006d4c <logFromISR+0x164>
80006cc4:	2f ed       	sub	sp,-8
80006cc6:	c0 a8       	rjmp	80006cda <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006cc8:	2f f7       	sub	r7,-1
80006cca:	1a d8       	st.w	--sp,r8
80006ccc:	1a d6       	st.w	--sp,r6
80006cce:	4a 1b       	lddpc	r11,80006d50 <logFromISR+0x168>
80006cd0:	0c 9c       	mov	r12,r6
80006cd2:	f0 1f 00 1f 	mcall	80006d4c <logFromISR+0x164>
80006cd6:	08 95       	mov	r5,r4
80006cd8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006cda:	0f 89       	ld.ub	r9,r7[0x0]
80006cdc:	30 08       	mov	r8,0
80006cde:	f0 09 18 00 	cp.b	r9,r8
80006ce2:	c0 30       	breq	80006ce8 <logFromISR+0x100>
80006ce4:	0a 94       	mov	r4,r5
80006ce6:	c9 8b       	rjmp	80006c16 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006ce8:	fa c7 fe f4 	sub	r7,sp,-268
80006cec:	1a d7       	st.w	--sp,r7
80006cee:	49 ab       	lddpc	r11,80006d54 <logFromISR+0x16c>
80006cf0:	0e 9c       	mov	r12,r7
80006cf2:	f0 1f 00 17 	mcall	80006d4c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006cf6:	5c 5c       	castu.b	r12
80006cf8:	f8 c6 ff ff 	sub	r6,r12,-1
80006cfc:	0c 9c       	mov	r12,r6
80006cfe:	f0 1f 00 17 	mcall	80006d58 <logFromISR+0x170>
80006d02:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006d04:	0c 9a       	mov	r10,r6
80006d06:	0e 9b       	mov	r11,r7
80006d08:	f0 1f 00 15 	mcall	80006d5c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006d0c:	30 09       	mov	r9,0
80006d0e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006d10:	fa ca fe f8 	sub	r10,sp,-264
80006d14:	fa cb fe f4 	sub	r11,sp,-268
80006d18:	49 28       	lddpc	r8,80006d60 <logFromISR+0x178>
80006d1a:	70 0c       	ld.w	r12,r8[0x0]
80006d1c:	f0 1f 00 12 	mcall	80006d64 <logFromISR+0x17c>
80006d20:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006d22:	fe 3d fd f4 	sub	sp,-524
80006d26:	d8 32       	popm	r0-r7,pc
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	74 5e       	ld.w	lr,r10[0x14]
80006d2c:	00 00       	add	r0,r0
80006d2e:	0d 51       	ld.sh	r1,--r6
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	d4 94       	*unknown*
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	69 82       	ld.w	r2,r4[0x60]
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	68 d0       	ld.w	r0,r4[0x34]
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	68 cc       	ld.w	r12,r4[0x30]
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	d6 00       	acall	0x60
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	6a 5c       	ld.w	r12,r5[0x14]
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	d6 10       	acall	0x61
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	77 4c       	ld.w	r12,r11[0x50]
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	d6 18       	*unknown*
80006d54:	80 00       	ld.sh	r0,r0[0x0]
80006d56:	d6 20       	acall	0x62
80006d58:	80 00       	ld.sh	r0,r0[0x0]
80006d5a:	5b 70       	cp.w	r0,-9
80006d5c:	80 00       	ld.sh	r0,r0[0x0]
80006d5e:	73 16       	ld.w	r6,r9[0x44]
80006d60:	00 00       	add	r0,r0
80006d62:	63 9c       	ld.w	r12,r1[0x64]
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	5e 74       	retpl	r4

80006d68 <log_init>:
		
	return str;
}

void log_init(void)
{
80006d68:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006d6a:	30 2b       	mov	r11,2
80006d6c:	49 0c       	lddpc	r12,80006dac <log_init+0x44>
80006d6e:	f0 1f 00 11 	mcall	80006db0 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006d72:	e0 6a 36 00 	mov	r10,13824
80006d76:	ea 1a 01 6e 	orh	r10,0x16e
80006d7a:	48 fb       	lddpc	r11,80006db4 <log_init+0x4c>
80006d7c:	fe 7c 18 00 	mov	r12,-59392
80006d80:	f0 1f 00 0e 	mcall	80006db8 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006d84:	30 4b       	mov	r11,4
80006d86:	33 2c       	mov	r12,50
80006d88:	f0 1f 00 0d 	mcall	80006dbc <log_init+0x54>
80006d8c:	48 d8       	lddpc	r8,80006dc0 <log_init+0x58>
80006d8e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006d90:	30 09       	mov	r9,0
80006d92:	1a d9       	st.w	--sp,r9
80006d94:	1a d9       	st.w	--sp,r9
80006d96:	1a d9       	st.w	--sp,r9
80006d98:	30 28       	mov	r8,2
80006d9a:	e0 6a 01 80 	mov	r10,384
80006d9e:	48 ab       	lddpc	r11,80006dc4 <log_init+0x5c>
80006da0:	48 ac       	lddpc	r12,80006dc8 <log_init+0x60>
80006da2:	f0 1f 00 0b 	mcall	80006dcc <log_init+0x64>
80006da6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006da8:	d8 02       	popm	pc
80006daa:	00 00       	add	r0,r0
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	d6 2c       	*unknown*
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	52 34       	stdsp	sp[0x8c],r4
80006db4:	80 00       	ld.sh	r0,r0[0x0]
80006db6:	d5 e4       	*unknown*
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	56 d4       	stdsp	sp[0x1b4],r4
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	5f c4       	srvs	r4
80006dc0:	00 00       	add	r0,r0
80006dc2:	63 9c       	ld.w	r12,r1[0x64]
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	d6 28       	*unknown*
80006dc8:	80 00       	ld.sh	r0,r0[0x0]
80006dca:	6d d0       	ld.w	r0,r6[0x74]
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	66 98       	ld.w	r8,r3[0x24]

80006dd0 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006dd0:	eb cd 40 f8 	pushm	r3-r7,lr
80006dd4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006dd6:	48 c7       	lddpc	r7,80006e04 <task_log+0x34>
80006dd8:	30 05       	mov	r5,0
80006dda:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006ddc:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006de0:	0a 99       	mov	r9,r5
80006de2:	08 9a       	mov	r10,r4
80006de4:	1a 9b       	mov	r11,sp
80006de6:	6e 0c       	ld.w	r12,r7[0x0]
80006de8:	f0 1f 00 08 	mcall	80006e08 <task_log+0x38>
80006dec:	58 1c       	cp.w	r12,1
80006dee:	cf 91       	brne	80006de0 <task_log+0x10>
		{
			if( NULL != str)
80006df0:	40 0b       	lddsp	r11,sp[0x0]
80006df2:	58 0b       	cp.w	r11,0
80006df4:	cf 60       	breq	80006de0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006df6:	06 9c       	mov	r12,r3
80006df8:	f0 1f 00 05 	mcall	80006e0c <task_log+0x3c>
				vPortFree(str);
80006dfc:	40 0c       	lddsp	r12,sp[0x0]
80006dfe:	f0 1f 00 05 	mcall	80006e10 <task_log+0x40>
80006e02:	ce fb       	rjmp	80006de0 <task_log+0x10>
80006e04:	00 00       	add	r0,r0
80006e06:	63 9c       	ld.w	r12,r1[0x64]
80006e08:	80 00       	ld.sh	r0,r0[0x0]
80006e0a:	5c b8       	swap.b	r8
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	56 84       	stdsp	sp[0x1a0],r4
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	5b 48       	cp.w	r8,-12

80006e14 <main>:
#include "voice.h"
#include "app.h"


int main (void)
{
80006e14:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006e16:	fe 78 10 00 	mov	r8,-61440
80006e1a:	30 19       	mov	r9,1
80006e1c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006e20:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006e24:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006e28:	d3 03       	ssrf	0x10
	local_start_pll0();
80006e2a:	f0 1f 00 12 	mcall	80006e70 <main+0x5c>
		
	INTC_init_interrupts();
80006e2e:	f0 1f 00 12 	mcall	80006e74 <main+0x60>
		
	log_init();
80006e32:	f0 1f 00 12 	mcall	80006e78 <main+0x64>
	log("----start debug----");
80006e36:	49 2c       	lddpc	r12,80006e7c <main+0x68>
80006e38:	f0 1f 00 12 	mcall	80006e80 <main+0x6c>
		
	voc_init();
80006e3c:	f0 1f 00 12 	mcall	80006e84 <main+0x70>

	//tc_init();
		
	app_init();
80006e40:	f0 1f 00 12 	mcall	80006e88 <main+0x74>
		
	xcmp_init();
80006e44:	f0 1f 00 12 	mcall	80006e8c <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006e48:	fe 79 10 00 	mov	r9,-61440
80006e4c:	f2 f8 01 60 	ld.w	r8,r9[352]
80006e50:	e2 18 00 02 	andl	r8,0x2,COH
80006e54:	cf c0       	breq	80006e4c <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006e56:	fe 79 10 00 	mov	r9,-61440
80006e5a:	f2 f8 01 60 	ld.w	r8,r9[352]
80006e5e:	e2 18 00 02 	andl	r8,0x2,COH
80006e62:	cf c1       	brne	80006e5a <main+0x46>
	local_start_timer();
80006e64:	f0 1f 00 0b 	mcall	80006e90 <main+0x7c>
		
	Enable_global_interrupt();
80006e68:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006e6a:	f0 1f 00 0b 	mcall	80006e94 <main+0x80>
	return 0;
	
}
80006e6e:	d8 0a       	popm	pc,r12=0
80006e70:	80 00       	ld.sh	r0,r0[0x0]
80006e72:	4f 84       	lddpc	r4,80007050 <_malloc_r+0x198>
80006e74:	80 00       	ld.sh	r0,r0[0x0]
80006e76:	53 1c       	stdsp	sp[0xc4],r12
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	6d 68       	ld.w	r8,r6[0x58]
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	d6 3c       	*unknown*
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	6a 5c       	ld.w	r12,r5[0x14]
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	50 10       	stdsp	sp[0x4],r0
80006e88:	80 00       	ld.sh	r0,r0[0x0]
80006e8a:	20 3c       	sub	r12,3
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	48 08       	lddpc	r8,80006e8c <main+0x78>
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	4f d4       	lddpc	r4,80007084 <_malloc_r+0x1cc>
80006e94:	80 00       	ld.sh	r0,r0[0x0]
80006e96:	68 80       	ld.w	r0,r4[0x20]

80006e98 <free>:
80006e98:	d4 01       	pushm	lr
80006e9a:	e0 68 0a 38 	mov	r8,2616
80006e9e:	18 9b       	mov	r11,r12
80006ea0:	70 0c       	ld.w	r12,r8[0x0]
80006ea2:	e0 a0 1e 73 	rcall	8000ab88 <_free_r>
80006ea6:	d8 02       	popm	pc

80006ea8 <malloc>:
80006ea8:	d4 01       	pushm	lr
80006eaa:	e0 68 0a 38 	mov	r8,2616
80006eae:	18 9b       	mov	r11,r12
80006eb0:	70 0c       	ld.w	r12,r8[0x0]
80006eb2:	c0 3c       	rcall	80006eb8 <_malloc_r>
80006eb4:	d8 02       	popm	pc
80006eb6:	d7 03       	nop

80006eb8 <_malloc_r>:
80006eb8:	d4 31       	pushm	r0-r7,lr
80006eba:	f6 c8 ff f5 	sub	r8,r11,-11
80006ebe:	18 95       	mov	r5,r12
80006ec0:	10 97       	mov	r7,r8
80006ec2:	e0 17 ff f8 	andl	r7,0xfff8
80006ec6:	59 68       	cp.w	r8,22
80006ec8:	f9 b7 08 10 	movls	r7,16
80006ecc:	16 37       	cp.w	r7,r11
80006ece:	5f 38       	srlo	r8
80006ed0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006ed4:	c0 50       	breq	80006ede <_malloc_r+0x26>
80006ed6:	30 c8       	mov	r8,12
80006ed8:	99 38       	st.w	r12[0xc],r8
80006eda:	e0 8f 01 fa 	bral	800072ce <_malloc_r+0x416>
80006ede:	fe b0 f5 eb 	rcall	80005ab4 <__malloc_lock>
80006ee2:	e0 47 01 f7 	cp.w	r7,503
80006ee6:	e0 8b 00 1d 	brhi	80006f20 <_malloc_r+0x68>
80006eea:	ee 03 16 03 	lsr	r3,r7,0x3
80006eee:	e0 68 05 38 	mov	r8,1336
80006ef2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006ef6:	70 36       	ld.w	r6,r8[0xc]
80006ef8:	10 36       	cp.w	r6,r8
80006efa:	c0 61       	brne	80006f06 <_malloc_r+0x4e>
80006efc:	ec c8 ff f8 	sub	r8,r6,-8
80006f00:	70 36       	ld.w	r6,r8[0xc]
80006f02:	10 36       	cp.w	r6,r8
80006f04:	c0 c0       	breq	80006f1c <_malloc_r+0x64>
80006f06:	6c 18       	ld.w	r8,r6[0x4]
80006f08:	e0 18 ff fc 	andl	r8,0xfffc
80006f0c:	6c 3a       	ld.w	r10,r6[0xc]
80006f0e:	ec 08 00 09 	add	r9,r6,r8
80006f12:	0a 9c       	mov	r12,r5
80006f14:	6c 28       	ld.w	r8,r6[0x8]
80006f16:	95 28       	st.w	r10[0x8],r8
80006f18:	91 3a       	st.w	r8[0xc],r10
80006f1a:	c4 78       	rjmp	80006fa8 <_malloc_r+0xf0>
80006f1c:	2f e3       	sub	r3,-2
80006f1e:	c4 d8       	rjmp	80006fb8 <_malloc_r+0x100>
80006f20:	ee 03 16 09 	lsr	r3,r7,0x9
80006f24:	c0 41       	brne	80006f2c <_malloc_r+0x74>
80006f26:	ee 03 16 03 	lsr	r3,r7,0x3
80006f2a:	c2 68       	rjmp	80006f76 <_malloc_r+0xbe>
80006f2c:	58 43       	cp.w	r3,4
80006f2e:	e0 8b 00 06 	brhi	80006f3a <_malloc_r+0x82>
80006f32:	ee 03 16 06 	lsr	r3,r7,0x6
80006f36:	2c 83       	sub	r3,-56
80006f38:	c1 f8       	rjmp	80006f76 <_malloc_r+0xbe>
80006f3a:	59 43       	cp.w	r3,20
80006f3c:	e0 8b 00 04 	brhi	80006f44 <_malloc_r+0x8c>
80006f40:	2a 53       	sub	r3,-91
80006f42:	c1 a8       	rjmp	80006f76 <_malloc_r+0xbe>
80006f44:	e0 43 00 54 	cp.w	r3,84
80006f48:	e0 8b 00 06 	brhi	80006f54 <_malloc_r+0x9c>
80006f4c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006f50:	29 23       	sub	r3,-110
80006f52:	c1 28       	rjmp	80006f76 <_malloc_r+0xbe>
80006f54:	e0 43 01 54 	cp.w	r3,340
80006f58:	e0 8b 00 06 	brhi	80006f64 <_malloc_r+0xac>
80006f5c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006f60:	28 93       	sub	r3,-119
80006f62:	c0 a8       	rjmp	80006f76 <_malloc_r+0xbe>
80006f64:	e0 43 05 54 	cp.w	r3,1364
80006f68:	e0 88 00 04 	brls	80006f70 <_malloc_r+0xb8>
80006f6c:	37 e3       	mov	r3,126
80006f6e:	c0 48       	rjmp	80006f76 <_malloc_r+0xbe>
80006f70:	ee 03 16 12 	lsr	r3,r7,0x12
80006f74:	28 43       	sub	r3,-124
80006f76:	e0 6a 05 38 	mov	r10,1336
80006f7a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006f7e:	74 36       	ld.w	r6,r10[0xc]
80006f80:	c1 98       	rjmp	80006fb2 <_malloc_r+0xfa>
80006f82:	6c 19       	ld.w	r9,r6[0x4]
80006f84:	e0 19 ff fc 	andl	r9,0xfffc
80006f88:	f2 07 01 0b 	sub	r11,r9,r7
80006f8c:	58 fb       	cp.w	r11,15
80006f8e:	e0 8a 00 04 	brle	80006f96 <_malloc_r+0xde>
80006f92:	20 13       	sub	r3,1
80006f94:	c1 18       	rjmp	80006fb6 <_malloc_r+0xfe>
80006f96:	6c 38       	ld.w	r8,r6[0xc]
80006f98:	58 0b       	cp.w	r11,0
80006f9a:	c0 b5       	brlt	80006fb0 <_malloc_r+0xf8>
80006f9c:	6c 2a       	ld.w	r10,r6[0x8]
80006f9e:	ec 09 00 09 	add	r9,r6,r9
80006fa2:	0a 9c       	mov	r12,r5
80006fa4:	91 2a       	st.w	r8[0x8],r10
80006fa6:	95 38       	st.w	r10[0xc],r8
80006fa8:	72 18       	ld.w	r8,r9[0x4]
80006faa:	a1 a8       	sbr	r8,0x0
80006fac:	93 18       	st.w	r9[0x4],r8
80006fae:	cb c8       	rjmp	80007126 <_malloc_r+0x26e>
80006fb0:	10 96       	mov	r6,r8
80006fb2:	14 36       	cp.w	r6,r10
80006fb4:	ce 71       	brne	80006f82 <_malloc_r+0xca>
80006fb6:	2f f3       	sub	r3,-1
80006fb8:	e0 6a 05 38 	mov	r10,1336
80006fbc:	f4 cc ff f8 	sub	r12,r10,-8
80006fc0:	78 26       	ld.w	r6,r12[0x8]
80006fc2:	18 36       	cp.w	r6,r12
80006fc4:	c6 c0       	breq	8000709c <_malloc_r+0x1e4>
80006fc6:	6c 19       	ld.w	r9,r6[0x4]
80006fc8:	e0 19 ff fc 	andl	r9,0xfffc
80006fcc:	f2 07 01 08 	sub	r8,r9,r7
80006fd0:	58 f8       	cp.w	r8,15
80006fd2:	e0 89 00 8f 	brgt	800070f0 <_malloc_r+0x238>
80006fd6:	99 3c       	st.w	r12[0xc],r12
80006fd8:	99 2c       	st.w	r12[0x8],r12
80006fda:	58 08       	cp.w	r8,0
80006fdc:	c0 55       	brlt	80006fe6 <_malloc_r+0x12e>
80006fde:	ec 09 00 09 	add	r9,r6,r9
80006fe2:	0a 9c       	mov	r12,r5
80006fe4:	ce 2b       	rjmp	80006fa8 <_malloc_r+0xf0>
80006fe6:	e0 49 01 ff 	cp.w	r9,511
80006fea:	e0 8b 00 13 	brhi	80007010 <_malloc_r+0x158>
80006fee:	a3 99       	lsr	r9,0x3
80006ff0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006ff4:	70 2b       	ld.w	r11,r8[0x8]
80006ff6:	8d 38       	st.w	r6[0xc],r8
80006ff8:	8d 2b       	st.w	r6[0x8],r11
80006ffa:	97 36       	st.w	r11[0xc],r6
80006ffc:	91 26       	st.w	r8[0x8],r6
80006ffe:	a3 49       	asr	r9,0x2
80007000:	74 18       	ld.w	r8,r10[0x4]
80007002:	30 1b       	mov	r11,1
80007004:	f6 09 09 49 	lsl	r9,r11,r9
80007008:	f1 e9 10 09 	or	r9,r8,r9
8000700c:	95 19       	st.w	r10[0x4],r9
8000700e:	c4 78       	rjmp	8000709c <_malloc_r+0x1e4>
80007010:	f2 0a 16 09 	lsr	r10,r9,0x9
80007014:	58 4a       	cp.w	r10,4
80007016:	e0 8b 00 07 	brhi	80007024 <_malloc_r+0x16c>
8000701a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000701e:	2c 8a       	sub	r10,-56
80007020:	c2 08       	rjmp	80007060 <_malloc_r+0x1a8>
80007022:	d7 03       	nop
80007024:	59 4a       	cp.w	r10,20
80007026:	e0 8b 00 04 	brhi	8000702e <_malloc_r+0x176>
8000702a:	2a 5a       	sub	r10,-91
8000702c:	c1 a8       	rjmp	80007060 <_malloc_r+0x1a8>
8000702e:	e0 4a 00 54 	cp.w	r10,84
80007032:	e0 8b 00 06 	brhi	8000703e <_malloc_r+0x186>
80007036:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000703a:	29 2a       	sub	r10,-110
8000703c:	c1 28       	rjmp	80007060 <_malloc_r+0x1a8>
8000703e:	e0 4a 01 54 	cp.w	r10,340
80007042:	e0 8b 00 06 	brhi	8000704e <_malloc_r+0x196>
80007046:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000704a:	28 9a       	sub	r10,-119
8000704c:	c0 a8       	rjmp	80007060 <_malloc_r+0x1a8>
8000704e:	e0 4a 05 54 	cp.w	r10,1364
80007052:	e0 88 00 04 	brls	8000705a <_malloc_r+0x1a2>
80007056:	37 ea       	mov	r10,126
80007058:	c0 48       	rjmp	80007060 <_malloc_r+0x1a8>
8000705a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000705e:	28 4a       	sub	r10,-124
80007060:	e0 6b 05 38 	mov	r11,1336
80007064:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007068:	68 28       	ld.w	r8,r4[0x8]
8000706a:	08 38       	cp.w	r8,r4
8000706c:	c0 e1       	brne	80007088 <_malloc_r+0x1d0>
8000706e:	76 19       	ld.w	r9,r11[0x4]
80007070:	a3 4a       	asr	r10,0x2
80007072:	30 1e       	mov	lr,1
80007074:	fc 0a 09 4a 	lsl	r10,lr,r10
80007078:	f3 ea 10 0a 	or	r10,r9,r10
8000707c:	10 99       	mov	r9,r8
8000707e:	97 1a       	st.w	r11[0x4],r10
80007080:	c0 a8       	rjmp	80007094 <_malloc_r+0x1dc>
80007082:	70 28       	ld.w	r8,r8[0x8]
80007084:	08 38       	cp.w	r8,r4
80007086:	c0 60       	breq	80007092 <_malloc_r+0x1da>
80007088:	70 1a       	ld.w	r10,r8[0x4]
8000708a:	e0 1a ff fc 	andl	r10,0xfffc
8000708e:	14 39       	cp.w	r9,r10
80007090:	cf 93       	brcs	80007082 <_malloc_r+0x1ca>
80007092:	70 39       	ld.w	r9,r8[0xc]
80007094:	8d 39       	st.w	r6[0xc],r9
80007096:	8d 28       	st.w	r6[0x8],r8
80007098:	91 36       	st.w	r8[0xc],r6
8000709a:	93 26       	st.w	r9[0x8],r6
8000709c:	e6 08 14 02 	asr	r8,r3,0x2
800070a0:	30 1b       	mov	r11,1
800070a2:	e0 64 05 38 	mov	r4,1336
800070a6:	f6 08 09 4b 	lsl	r11,r11,r8
800070aa:	68 18       	ld.w	r8,r4[0x4]
800070ac:	10 3b       	cp.w	r11,r8
800070ae:	e0 8b 00 6b 	brhi	80007184 <_malloc_r+0x2cc>
800070b2:	f7 e8 00 09 	and	r9,r11,r8
800070b6:	c0 b1       	brne	800070cc <_malloc_r+0x214>
800070b8:	e0 13 ff fc 	andl	r3,0xfffc
800070bc:	a1 7b       	lsl	r11,0x1
800070be:	2f c3       	sub	r3,-4
800070c0:	c0 38       	rjmp	800070c6 <_malloc_r+0x20e>
800070c2:	2f c3       	sub	r3,-4
800070c4:	a1 7b       	lsl	r11,0x1
800070c6:	f7 e8 00 09 	and	r9,r11,r8
800070ca:	cf c0       	breq	800070c2 <_malloc_r+0x20a>
800070cc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800070d0:	06 92       	mov	r2,r3
800070d2:	1c 91       	mov	r1,lr
800070d4:	62 36       	ld.w	r6,r1[0xc]
800070d6:	c2 e8       	rjmp	80007132 <_malloc_r+0x27a>
800070d8:	6c 1a       	ld.w	r10,r6[0x4]
800070da:	e0 1a ff fc 	andl	r10,0xfffc
800070de:	f4 07 01 08 	sub	r8,r10,r7
800070e2:	58 f8       	cp.w	r8,15
800070e4:	e0 8a 00 15 	brle	8000710e <_malloc_r+0x256>
800070e8:	6c 3a       	ld.w	r10,r6[0xc]
800070ea:	6c 29       	ld.w	r9,r6[0x8]
800070ec:	95 29       	st.w	r10[0x8],r9
800070ee:	93 3a       	st.w	r9[0xc],r10
800070f0:	0e 99       	mov	r9,r7
800070f2:	ec 07 00 07 	add	r7,r6,r7
800070f6:	a1 a9       	sbr	r9,0x0
800070f8:	99 37       	st.w	r12[0xc],r7
800070fa:	99 27       	st.w	r12[0x8],r7
800070fc:	8d 19       	st.w	r6[0x4],r9
800070fe:	ee 08 09 08 	st.w	r7[r8],r8
80007102:	8f 2c       	st.w	r7[0x8],r12
80007104:	8f 3c       	st.w	r7[0xc],r12
80007106:	a1 a8       	sbr	r8,0x0
80007108:	0a 9c       	mov	r12,r5
8000710a:	8f 18       	st.w	r7[0x4],r8
8000710c:	c0 d8       	rjmp	80007126 <_malloc_r+0x26e>
8000710e:	6c 39       	ld.w	r9,r6[0xc]
80007110:	58 08       	cp.w	r8,0
80007112:	c0 f5       	brlt	80007130 <_malloc_r+0x278>
80007114:	ec 0a 00 0a 	add	r10,r6,r10
80007118:	74 18       	ld.w	r8,r10[0x4]
8000711a:	a1 a8       	sbr	r8,0x0
8000711c:	0a 9c       	mov	r12,r5
8000711e:	95 18       	st.w	r10[0x4],r8
80007120:	6c 28       	ld.w	r8,r6[0x8]
80007122:	93 28       	st.w	r9[0x8],r8
80007124:	91 39       	st.w	r8[0xc],r9
80007126:	fe b0 f4 cd 	rcall	80005ac0 <__malloc_unlock>
8000712a:	ec cc ff f8 	sub	r12,r6,-8
8000712e:	d8 32       	popm	r0-r7,pc
80007130:	12 96       	mov	r6,r9
80007132:	02 36       	cp.w	r6,r1
80007134:	cd 21       	brne	800070d8 <_malloc_r+0x220>
80007136:	2f f2       	sub	r2,-1
80007138:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000713c:	c0 30       	breq	80007142 <_malloc_r+0x28a>
8000713e:	2f 81       	sub	r1,-8
80007140:	cc ab       	rjmp	800070d4 <_malloc_r+0x21c>
80007142:	1c 98       	mov	r8,lr
80007144:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007148:	c0 81       	brne	80007158 <_malloc_r+0x2a0>
8000714a:	68 19       	ld.w	r9,r4[0x4]
8000714c:	f6 08 11 ff 	rsub	r8,r11,-1
80007150:	f3 e8 00 08 	and	r8,r9,r8
80007154:	89 18       	st.w	r4[0x4],r8
80007156:	c0 78       	rjmp	80007164 <_malloc_r+0x2ac>
80007158:	f0 c9 00 08 	sub	r9,r8,8
8000715c:	20 13       	sub	r3,1
8000715e:	70 08       	ld.w	r8,r8[0x0]
80007160:	12 38       	cp.w	r8,r9
80007162:	cf 10       	breq	80007144 <_malloc_r+0x28c>
80007164:	a1 7b       	lsl	r11,0x1
80007166:	68 18       	ld.w	r8,r4[0x4]
80007168:	10 3b       	cp.w	r11,r8
8000716a:	e0 8b 00 0d 	brhi	80007184 <_malloc_r+0x2cc>
8000716e:	58 0b       	cp.w	r11,0
80007170:	c0 a0       	breq	80007184 <_malloc_r+0x2cc>
80007172:	04 93       	mov	r3,r2
80007174:	c0 38       	rjmp	8000717a <_malloc_r+0x2c2>
80007176:	2f c3       	sub	r3,-4
80007178:	a1 7b       	lsl	r11,0x1
8000717a:	f7 e8 00 09 	and	r9,r11,r8
8000717e:	ca 71       	brne	800070cc <_malloc_r+0x214>
80007180:	cf bb       	rjmp	80007176 <_malloc_r+0x2be>
80007182:	d7 03       	nop
80007184:	68 23       	ld.w	r3,r4[0x8]
80007186:	66 12       	ld.w	r2,r3[0x4]
80007188:	e0 12 ff fc 	andl	r2,0xfffc
8000718c:	0e 32       	cp.w	r2,r7
8000718e:	5f 39       	srlo	r9
80007190:	e4 07 01 08 	sub	r8,r2,r7
80007194:	58 f8       	cp.w	r8,15
80007196:	5f aa       	srle	r10
80007198:	f5 e9 10 09 	or	r9,r10,r9
8000719c:	e0 80 00 9a 	breq	800072d0 <_malloc_r+0x418>
800071a0:	e0 68 0d 5c 	mov	r8,3420
800071a4:	70 01       	ld.w	r1,r8[0x0]
800071a6:	e0 68 09 44 	mov	r8,2372
800071aa:	2f 01       	sub	r1,-16
800071ac:	70 08       	ld.w	r8,r8[0x0]
800071ae:	0e 01       	add	r1,r7
800071b0:	5b f8       	cp.w	r8,-1
800071b2:	c0 40       	breq	800071ba <_malloc_r+0x302>
800071b4:	28 11       	sub	r1,-127
800071b6:	e0 11 ff 80 	andl	r1,0xff80
800071ba:	02 9b       	mov	r11,r1
800071bc:	0a 9c       	mov	r12,r5
800071be:	e0 a0 02 b7 	rcall	8000772c <_sbrk_r>
800071c2:	18 96       	mov	r6,r12
800071c4:	5b fc       	cp.w	r12,-1
800071c6:	c7 50       	breq	800072b0 <_malloc_r+0x3f8>
800071c8:	e6 02 00 08 	add	r8,r3,r2
800071cc:	10 3c       	cp.w	r12,r8
800071ce:	c0 32       	brcc	800071d4 <_malloc_r+0x31c>
800071d0:	08 33       	cp.w	r3,r4
800071d2:	c6 f1       	brne	800072b0 <_malloc_r+0x3f8>
800071d4:	e0 6a 0d 60 	mov	r10,3424
800071d8:	74 09       	ld.w	r9,r10[0x0]
800071da:	e2 09 00 09 	add	r9,r1,r9
800071de:	95 09       	st.w	r10[0x0],r9
800071e0:	10 36       	cp.w	r6,r8
800071e2:	c0 a1       	brne	800071f6 <_malloc_r+0x33e>
800071e4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800071e8:	c0 71       	brne	800071f6 <_malloc_r+0x33e>
800071ea:	e2 02 00 02 	add	r2,r1,r2
800071ee:	68 28       	ld.w	r8,r4[0x8]
800071f0:	a1 a2       	sbr	r2,0x0
800071f2:	91 12       	st.w	r8[0x4],r2
800071f4:	c4 f8       	rjmp	80007292 <_malloc_r+0x3da>
800071f6:	e0 6a 09 44 	mov	r10,2372
800071fa:	74 0b       	ld.w	r11,r10[0x0]
800071fc:	5b fb       	cp.w	r11,-1
800071fe:	c0 31       	brne	80007204 <_malloc_r+0x34c>
80007200:	95 06       	st.w	r10[0x0],r6
80007202:	c0 78       	rjmp	80007210 <_malloc_r+0x358>
80007204:	ec 09 00 09 	add	r9,r6,r9
80007208:	e0 6a 0d 60 	mov	r10,3424
8000720c:	10 19       	sub	r9,r8
8000720e:	95 09       	st.w	r10[0x0],r9
80007210:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007214:	f0 09 11 08 	rsub	r9,r8,8
80007218:	58 08       	cp.w	r8,0
8000721a:	f2 08 17 10 	movne	r8,r9
8000721e:	ed d8 e1 06 	addne	r6,r6,r8
80007222:	28 08       	sub	r8,-128
80007224:	ec 01 00 01 	add	r1,r6,r1
80007228:	0a 9c       	mov	r12,r5
8000722a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000722e:	f0 01 01 01 	sub	r1,r8,r1
80007232:	02 9b       	mov	r11,r1
80007234:	e0 a0 02 7c 	rcall	8000772c <_sbrk_r>
80007238:	e0 68 0d 60 	mov	r8,3424
8000723c:	5b fc       	cp.w	r12,-1
8000723e:	ec 0c 17 00 	moveq	r12,r6
80007242:	f9 b1 00 00 	moveq	r1,0
80007246:	70 09       	ld.w	r9,r8[0x0]
80007248:	0c 1c       	sub	r12,r6
8000724a:	89 26       	st.w	r4[0x8],r6
8000724c:	02 0c       	add	r12,r1
8000724e:	12 01       	add	r1,r9
80007250:	a1 ac       	sbr	r12,0x0
80007252:	91 01       	st.w	r8[0x0],r1
80007254:	8d 1c       	st.w	r6[0x4],r12
80007256:	08 33       	cp.w	r3,r4
80007258:	c1 d0       	breq	80007292 <_malloc_r+0x3da>
8000725a:	58 f2       	cp.w	r2,15
8000725c:	e0 8b 00 05 	brhi	80007266 <_malloc_r+0x3ae>
80007260:	30 18       	mov	r8,1
80007262:	8d 18       	st.w	r6[0x4],r8
80007264:	c2 68       	rjmp	800072b0 <_malloc_r+0x3f8>
80007266:	30 59       	mov	r9,5
80007268:	20 c2       	sub	r2,12
8000726a:	e0 12 ff f8 	andl	r2,0xfff8
8000726e:	e6 02 00 08 	add	r8,r3,r2
80007272:	91 29       	st.w	r8[0x8],r9
80007274:	91 19       	st.w	r8[0x4],r9
80007276:	66 18       	ld.w	r8,r3[0x4]
80007278:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000727c:	e5 e8 10 08 	or	r8,r2,r8
80007280:	87 18       	st.w	r3[0x4],r8
80007282:	58 f2       	cp.w	r2,15
80007284:	e0 88 00 07 	brls	80007292 <_malloc_r+0x3da>
80007288:	e6 cb ff f8 	sub	r11,r3,-8
8000728c:	0a 9c       	mov	r12,r5
8000728e:	e0 a0 1c 7d 	rcall	8000ab88 <_free_r>
80007292:	e0 69 0d 58 	mov	r9,3416
80007296:	72 0a       	ld.w	r10,r9[0x0]
80007298:	e0 68 0d 60 	mov	r8,3424
8000729c:	70 08       	ld.w	r8,r8[0x0]
8000729e:	14 38       	cp.w	r8,r10
800072a0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800072a4:	e0 69 0d 54 	mov	r9,3412
800072a8:	72 0a       	ld.w	r10,r9[0x0]
800072aa:	14 38       	cp.w	r8,r10
800072ac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800072b0:	68 28       	ld.w	r8,r4[0x8]
800072b2:	70 18       	ld.w	r8,r8[0x4]
800072b4:	e0 18 ff fc 	andl	r8,0xfffc
800072b8:	0e 38       	cp.w	r8,r7
800072ba:	5f 39       	srlo	r9
800072bc:	0e 18       	sub	r8,r7
800072be:	58 f8       	cp.w	r8,15
800072c0:	5f aa       	srle	r10
800072c2:	f5 e9 10 09 	or	r9,r10,r9
800072c6:	c0 50       	breq	800072d0 <_malloc_r+0x418>
800072c8:	0a 9c       	mov	r12,r5
800072ca:	fe b0 f3 fb 	rcall	80005ac0 <__malloc_unlock>
800072ce:	d8 3a       	popm	r0-r7,pc,r12=0
800072d0:	68 26       	ld.w	r6,r4[0x8]
800072d2:	a1 a8       	sbr	r8,0x0
800072d4:	0e 99       	mov	r9,r7
800072d6:	a1 a9       	sbr	r9,0x0
800072d8:	8d 19       	st.w	r6[0x4],r9
800072da:	ec 07 00 07 	add	r7,r6,r7
800072de:	0a 9c       	mov	r12,r5
800072e0:	89 27       	st.w	r4[0x8],r7
800072e2:	8f 18       	st.w	r7[0x4],r8
800072e4:	fe b0 f3 ee 	rcall	80005ac0 <__malloc_unlock>
800072e8:	ec cc ff f8 	sub	r12,r6,-8
800072ec:	d8 32       	popm	r0-r7,pc
800072ee:	d7 03       	nop

800072f0 <memcmp>:
800072f0:	d4 01       	pushm	lr
800072f2:	30 08       	mov	r8,0
800072f4:	c0 d8       	rjmp	8000730e <memcmp+0x1e>
800072f6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800072fa:	f6 08 07 09 	ld.ub	r9,r11[r8]
800072fe:	20 1a       	sub	r10,1
80007300:	2f f8       	sub	r8,-1
80007302:	f2 0e 18 00 	cp.b	lr,r9
80007306:	c0 40       	breq	8000730e <memcmp+0x1e>
80007308:	fc 09 01 0c 	sub	r12,lr,r9
8000730c:	d8 02       	popm	pc
8000730e:	58 0a       	cp.w	r10,0
80007310:	cf 31       	brne	800072f6 <memcmp+0x6>
80007312:	14 9c       	mov	r12,r10
80007314:	d8 02       	popm	pc

80007316 <memcpy>:
80007316:	58 8a       	cp.w	r10,8
80007318:	c2 f5       	brlt	80007376 <memcpy+0x60>
8000731a:	f9 eb 10 09 	or	r9,r12,r11
8000731e:	e2 19 00 03 	andl	r9,0x3,COH
80007322:	e0 81 00 97 	brne	80007450 <memcpy+0x13a>
80007326:	e0 4a 00 20 	cp.w	r10,32
8000732a:	c3 b4       	brge	800073a0 <memcpy+0x8a>
8000732c:	f4 08 14 02 	asr	r8,r10,0x2
80007330:	f0 09 11 08 	rsub	r9,r8,8
80007334:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007338:	76 69       	ld.w	r9,r11[0x18]
8000733a:	99 69       	st.w	r12[0x18],r9
8000733c:	76 59       	ld.w	r9,r11[0x14]
8000733e:	99 59       	st.w	r12[0x14],r9
80007340:	76 49       	ld.w	r9,r11[0x10]
80007342:	99 49       	st.w	r12[0x10],r9
80007344:	76 39       	ld.w	r9,r11[0xc]
80007346:	99 39       	st.w	r12[0xc],r9
80007348:	76 29       	ld.w	r9,r11[0x8]
8000734a:	99 29       	st.w	r12[0x8],r9
8000734c:	76 19       	ld.w	r9,r11[0x4]
8000734e:	99 19       	st.w	r12[0x4],r9
80007350:	76 09       	ld.w	r9,r11[0x0]
80007352:	99 09       	st.w	r12[0x0],r9
80007354:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007358:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000735c:	e0 1a 00 03 	andl	r10,0x3
80007360:	f4 0a 11 04 	rsub	r10,r10,4
80007364:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007368:	17 a9       	ld.ub	r9,r11[0x2]
8000736a:	b0 a9       	st.b	r8[0x2],r9
8000736c:	17 99       	ld.ub	r9,r11[0x1]
8000736e:	b0 99       	st.b	r8[0x1],r9
80007370:	17 89       	ld.ub	r9,r11[0x0]
80007372:	b0 89       	st.b	r8[0x0],r9
80007374:	5e fc       	retal	r12
80007376:	f4 0a 11 09 	rsub	r10,r10,9
8000737a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000737e:	17 f9       	ld.ub	r9,r11[0x7]
80007380:	b8 f9       	st.b	r12[0x7],r9
80007382:	17 e9       	ld.ub	r9,r11[0x6]
80007384:	b8 e9       	st.b	r12[0x6],r9
80007386:	17 d9       	ld.ub	r9,r11[0x5]
80007388:	b8 d9       	st.b	r12[0x5],r9
8000738a:	17 c9       	ld.ub	r9,r11[0x4]
8000738c:	b8 c9       	st.b	r12[0x4],r9
8000738e:	17 b9       	ld.ub	r9,r11[0x3]
80007390:	b8 b9       	st.b	r12[0x3],r9
80007392:	17 a9       	ld.ub	r9,r11[0x2]
80007394:	b8 a9       	st.b	r12[0x2],r9
80007396:	17 99       	ld.ub	r9,r11[0x1]
80007398:	b8 99       	st.b	r12[0x1],r9
8000739a:	17 89       	ld.ub	r9,r11[0x0]
8000739c:	b8 89       	st.b	r12[0x0],r9
8000739e:	5e fc       	retal	r12
800073a0:	eb cd 40 c0 	pushm	r6-r7,lr
800073a4:	18 99       	mov	r9,r12
800073a6:	22 0a       	sub	r10,32
800073a8:	b7 07       	ld.d	r6,r11++
800073aa:	b3 26       	st.d	r9++,r6
800073ac:	b7 07       	ld.d	r6,r11++
800073ae:	b3 26       	st.d	r9++,r6
800073b0:	b7 07       	ld.d	r6,r11++
800073b2:	b3 26       	st.d	r9++,r6
800073b4:	b7 07       	ld.d	r6,r11++
800073b6:	b3 26       	st.d	r9++,r6
800073b8:	22 0a       	sub	r10,32
800073ba:	cf 74       	brge	800073a8 <memcpy+0x92>
800073bc:	2f 0a       	sub	r10,-16
800073be:	c0 65       	brlt	800073ca <memcpy+0xb4>
800073c0:	b7 07       	ld.d	r6,r11++
800073c2:	b3 26       	st.d	r9++,r6
800073c4:	b7 07       	ld.d	r6,r11++
800073c6:	b3 26       	st.d	r9++,r6
800073c8:	21 0a       	sub	r10,16
800073ca:	5c 3a       	neg	r10
800073cc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800073d0:	d7 03       	nop
800073d2:	d7 03       	nop
800073d4:	f7 36 00 0e 	ld.ub	r6,r11[14]
800073d8:	f3 66 00 0e 	st.b	r9[14],r6
800073dc:	f7 36 00 0d 	ld.ub	r6,r11[13]
800073e0:	f3 66 00 0d 	st.b	r9[13],r6
800073e4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800073e8:	f3 66 00 0c 	st.b	r9[12],r6
800073ec:	f7 36 00 0b 	ld.ub	r6,r11[11]
800073f0:	f3 66 00 0b 	st.b	r9[11],r6
800073f4:	f7 36 00 0a 	ld.ub	r6,r11[10]
800073f8:	f3 66 00 0a 	st.b	r9[10],r6
800073fc:	f7 36 00 09 	ld.ub	r6,r11[9]
80007400:	f3 66 00 09 	st.b	r9[9],r6
80007404:	f7 36 00 08 	ld.ub	r6,r11[8]
80007408:	f3 66 00 08 	st.b	r9[8],r6
8000740c:	f7 36 00 07 	ld.ub	r6,r11[7]
80007410:	f3 66 00 07 	st.b	r9[7],r6
80007414:	f7 36 00 06 	ld.ub	r6,r11[6]
80007418:	f3 66 00 06 	st.b	r9[6],r6
8000741c:	f7 36 00 05 	ld.ub	r6,r11[5]
80007420:	f3 66 00 05 	st.b	r9[5],r6
80007424:	f7 36 00 04 	ld.ub	r6,r11[4]
80007428:	f3 66 00 04 	st.b	r9[4],r6
8000742c:	f7 36 00 03 	ld.ub	r6,r11[3]
80007430:	f3 66 00 03 	st.b	r9[3],r6
80007434:	f7 36 00 02 	ld.ub	r6,r11[2]
80007438:	f3 66 00 02 	st.b	r9[2],r6
8000743c:	f7 36 00 01 	ld.ub	r6,r11[1]
80007440:	f3 66 00 01 	st.b	r9[1],r6
80007444:	f7 36 00 00 	ld.ub	r6,r11[0]
80007448:	f3 66 00 00 	st.b	r9[0],r6
8000744c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007450:	20 1a       	sub	r10,1
80007452:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007456:	f8 0a 0b 09 	st.b	r12[r10],r9
8000745a:	cf b1       	brne	80007450 <memcpy+0x13a>
8000745c:	5e fc       	retal	r12

8000745e <memset>:
8000745e:	18 98       	mov	r8,r12
80007460:	c0 38       	rjmp	80007466 <memset+0x8>
80007462:	10 cb       	st.b	r8++,r11
80007464:	20 1a       	sub	r10,1
80007466:	58 0a       	cp.w	r10,0
80007468:	cf d1       	brne	80007462 <memset+0x4>
8000746a:	5e fc       	retal	r12

8000746c <_realloc_r>:
8000746c:	d4 31       	pushm	r0-r7,lr
8000746e:	20 1d       	sub	sp,4
80007470:	16 94       	mov	r4,r11
80007472:	18 92       	mov	r2,r12
80007474:	14 9b       	mov	r11,r10
80007476:	58 04       	cp.w	r4,0
80007478:	c0 51       	brne	80007482 <_realloc_r+0x16>
8000747a:	fe b0 fd 1f 	rcall	80006eb8 <_malloc_r>
8000747e:	18 95       	mov	r5,r12
80007480:	c5 39       	rjmp	80007726 <_realloc_r+0x2ba>
80007482:	50 0a       	stdsp	sp[0x0],r10
80007484:	fe b0 f3 18 	rcall	80005ab4 <__malloc_lock>
80007488:	40 0b       	lddsp	r11,sp[0x0]
8000748a:	f6 c8 ff f5 	sub	r8,r11,-11
8000748e:	e8 c1 00 08 	sub	r1,r4,8
80007492:	10 96       	mov	r6,r8
80007494:	62 1c       	ld.w	r12,r1[0x4]
80007496:	e0 16 ff f8 	andl	r6,0xfff8
8000749a:	59 68       	cp.w	r8,22
8000749c:	f9 b6 08 10 	movls	r6,16
800074a0:	16 36       	cp.w	r6,r11
800074a2:	5f 38       	srlo	r8
800074a4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800074a8:	c0 50       	breq	800074b2 <_realloc_r+0x46>
800074aa:	30 c8       	mov	r8,12
800074ac:	30 05       	mov	r5,0
800074ae:	85 38       	st.w	r2[0xc],r8
800074b0:	c3 b9       	rjmp	80007726 <_realloc_r+0x2ba>
800074b2:	18 90       	mov	r0,r12
800074b4:	e0 10 ff fc 	andl	r0,0xfffc
800074b8:	0c 30       	cp.w	r0,r6
800074ba:	e0 84 01 0b 	brge	800076d0 <_realloc_r+0x264>
800074be:	e0 68 05 38 	mov	r8,1336
800074c2:	e2 00 00 09 	add	r9,r1,r0
800074c6:	70 25       	ld.w	r5,r8[0x8]
800074c8:	0a 39       	cp.w	r9,r5
800074ca:	c0 90       	breq	800074dc <_realloc_r+0x70>
800074cc:	72 1a       	ld.w	r10,r9[0x4]
800074ce:	a1 ca       	cbr	r10,0x0
800074d0:	f2 0a 00 0a 	add	r10,r9,r10
800074d4:	74 1a       	ld.w	r10,r10[0x4]
800074d6:	ed ba 00 00 	bld	r10,0x0
800074da:	c2 20       	breq	8000751e <_realloc_r+0xb2>
800074dc:	72 1a       	ld.w	r10,r9[0x4]
800074de:	e0 1a ff fc 	andl	r10,0xfffc
800074e2:	f4 00 00 03 	add	r3,r10,r0
800074e6:	0a 39       	cp.w	r9,r5
800074e8:	c1 31       	brne	8000750e <_realloc_r+0xa2>
800074ea:	ec c7 ff f0 	sub	r7,r6,-16
800074ee:	0e 33       	cp.w	r3,r7
800074f0:	c1 95       	brlt	80007522 <_realloc_r+0xb6>
800074f2:	e2 06 00 09 	add	r9,r1,r6
800074f6:	0c 13       	sub	r3,r6
800074f8:	a1 a3       	sbr	r3,0x0
800074fa:	93 13       	st.w	r9[0x4],r3
800074fc:	91 29       	st.w	r8[0x8],r9
800074fe:	04 9c       	mov	r12,r2
80007500:	62 18       	ld.w	r8,r1[0x4]
80007502:	08 95       	mov	r5,r4
80007504:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007508:	10 46       	or	r6,r8
8000750a:	83 16       	st.w	r1[0x4],r6
8000750c:	c0 b9       	rjmp	80007722 <_realloc_r+0x2b6>
8000750e:	0c 33       	cp.w	r3,r6
80007510:	c0 95       	brlt	80007522 <_realloc_r+0xb6>
80007512:	72 28       	ld.w	r8,r9[0x8]
80007514:	02 97       	mov	r7,r1
80007516:	72 39       	ld.w	r9,r9[0xc]
80007518:	93 28       	st.w	r9[0x8],r8
8000751a:	91 39       	st.w	r8[0xc],r9
8000751c:	cd c8       	rjmp	800076d4 <_realloc_r+0x268>
8000751e:	30 0a       	mov	r10,0
80007520:	14 99       	mov	r9,r10
80007522:	ed bc 00 00 	bld	r12,0x0
80007526:	e0 80 00 95 	breq	80007650 <_realloc_r+0x1e4>
8000752a:	62 07       	ld.w	r7,r1[0x0]
8000752c:	e2 07 01 07 	sub	r7,r1,r7
80007530:	6e 1c       	ld.w	r12,r7[0x4]
80007532:	e0 1c ff fc 	andl	r12,0xfffc
80007536:	58 09       	cp.w	r9,0
80007538:	c5 60       	breq	800075e4 <_realloc_r+0x178>
8000753a:	f8 00 00 03 	add	r3,r12,r0
8000753e:	0a 39       	cp.w	r9,r5
80007540:	c4 81       	brne	800075d0 <_realloc_r+0x164>
80007542:	14 03       	add	r3,r10
80007544:	ec c9 ff f0 	sub	r9,r6,-16
80007548:	12 33       	cp.w	r3,r9
8000754a:	c4 d5       	brlt	800075e4 <_realloc_r+0x178>
8000754c:	6e 3a       	ld.w	r10,r7[0xc]
8000754e:	6e 29       	ld.w	r9,r7[0x8]
80007550:	95 29       	st.w	r10[0x8],r9
80007552:	93 3a       	st.w	r9[0xc],r10
80007554:	ee c5 ff f8 	sub	r5,r7,-8
80007558:	e0 ca 00 04 	sub	r10,r0,4
8000755c:	e0 4a 00 24 	cp.w	r10,36
80007560:	e0 8b 00 25 	brhi	800075aa <_realloc_r+0x13e>
80007564:	0a 99       	mov	r9,r5
80007566:	59 3a       	cp.w	r10,19
80007568:	e0 88 00 1a 	brls	8000759c <_realloc_r+0x130>
8000756c:	09 09       	ld.w	r9,r4++
8000756e:	8b 09       	st.w	r5[0x0],r9
80007570:	09 09       	ld.w	r9,r4++
80007572:	8f 39       	st.w	r7[0xc],r9
80007574:	ee c9 ff f0 	sub	r9,r7,-16
80007578:	59 ba       	cp.w	r10,27
8000757a:	e0 88 00 11 	brls	8000759c <_realloc_r+0x130>
8000757e:	09 0b       	ld.w	r11,r4++
80007580:	93 0b       	st.w	r9[0x0],r11
80007582:	09 09       	ld.w	r9,r4++
80007584:	8f 59       	st.w	r7[0x14],r9
80007586:	ee c9 ff e8 	sub	r9,r7,-24
8000758a:	e0 4a 00 24 	cp.w	r10,36
8000758e:	c0 71       	brne	8000759c <_realloc_r+0x130>
80007590:	09 0a       	ld.w	r10,r4++
80007592:	93 0a       	st.w	r9[0x0],r10
80007594:	ee c9 ff e0 	sub	r9,r7,-32
80007598:	09 0a       	ld.w	r10,r4++
8000759a:	8f 7a       	st.w	r7[0x1c],r10
8000759c:	09 0a       	ld.w	r10,r4++
8000759e:	12 aa       	st.w	r9++,r10
800075a0:	68 0a       	ld.w	r10,r4[0x0]
800075a2:	93 0a       	st.w	r9[0x0],r10
800075a4:	68 1a       	ld.w	r10,r4[0x4]
800075a6:	93 1a       	st.w	r9[0x4],r10
800075a8:	c0 78       	rjmp	800075b6 <_realloc_r+0x14a>
800075aa:	50 08       	stdsp	sp[0x0],r8
800075ac:	08 9b       	mov	r11,r4
800075ae:	0a 9c       	mov	r12,r5
800075b0:	e0 a0 1d 8f 	rcall	8000b0ce <memmove>
800075b4:	40 08       	lddsp	r8,sp[0x0]
800075b6:	ee 06 00 09 	add	r9,r7,r6
800075ba:	0c 13       	sub	r3,r6
800075bc:	a1 a3       	sbr	r3,0x0
800075be:	93 13       	st.w	r9[0x4],r3
800075c0:	91 29       	st.w	r8[0x8],r9
800075c2:	04 9c       	mov	r12,r2
800075c4:	6e 18       	ld.w	r8,r7[0x4]
800075c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800075ca:	10 46       	or	r6,r8
800075cc:	8f 16       	st.w	r7[0x4],r6
800075ce:	ca a8       	rjmp	80007722 <_realloc_r+0x2b6>
800075d0:	14 03       	add	r3,r10
800075d2:	0c 33       	cp.w	r3,r6
800075d4:	c0 85       	brlt	800075e4 <_realloc_r+0x178>
800075d6:	72 28       	ld.w	r8,r9[0x8]
800075d8:	72 39       	ld.w	r9,r9[0xc]
800075da:	93 28       	st.w	r9[0x8],r8
800075dc:	91 39       	st.w	r8[0xc],r9
800075de:	6e 28       	ld.w	r8,r7[0x8]
800075e0:	6e 39       	ld.w	r9,r7[0xc]
800075e2:	c0 78       	rjmp	800075f0 <_realloc_r+0x184>
800075e4:	f8 00 00 03 	add	r3,r12,r0
800075e8:	0c 33       	cp.w	r3,r6
800075ea:	c3 35       	brlt	80007650 <_realloc_r+0x1e4>
800075ec:	6e 39       	ld.w	r9,r7[0xc]
800075ee:	6e 28       	ld.w	r8,r7[0x8]
800075f0:	93 28       	st.w	r9[0x8],r8
800075f2:	91 39       	st.w	r8[0xc],r9
800075f4:	e0 ca 00 04 	sub	r10,r0,4
800075f8:	ee cc ff f8 	sub	r12,r7,-8
800075fc:	e0 4a 00 24 	cp.w	r10,36
80007600:	e0 8b 00 24 	brhi	80007648 <_realloc_r+0x1dc>
80007604:	59 3a       	cp.w	r10,19
80007606:	e0 88 00 1a 	brls	8000763a <_realloc_r+0x1ce>
8000760a:	09 08       	ld.w	r8,r4++
8000760c:	99 08       	st.w	r12[0x0],r8
8000760e:	09 08       	ld.w	r8,r4++
80007610:	8f 38       	st.w	r7[0xc],r8
80007612:	ee cc ff f0 	sub	r12,r7,-16
80007616:	59 ba       	cp.w	r10,27
80007618:	e0 88 00 11 	brls	8000763a <_realloc_r+0x1ce>
8000761c:	09 08       	ld.w	r8,r4++
8000761e:	99 08       	st.w	r12[0x0],r8
80007620:	09 08       	ld.w	r8,r4++
80007622:	8f 58       	st.w	r7[0x14],r8
80007624:	ee cc ff e8 	sub	r12,r7,-24
80007628:	e0 4a 00 24 	cp.w	r10,36
8000762c:	c0 71       	brne	8000763a <_realloc_r+0x1ce>
8000762e:	09 08       	ld.w	r8,r4++
80007630:	99 08       	st.w	r12[0x0],r8
80007632:	ee cc ff e0 	sub	r12,r7,-32
80007636:	09 08       	ld.w	r8,r4++
80007638:	8f 78       	st.w	r7[0x1c],r8
8000763a:	09 08       	ld.w	r8,r4++
8000763c:	18 a8       	st.w	r12++,r8
8000763e:	68 08       	ld.w	r8,r4[0x0]
80007640:	99 08       	st.w	r12[0x0],r8
80007642:	68 18       	ld.w	r8,r4[0x4]
80007644:	99 18       	st.w	r12[0x4],r8
80007646:	c4 78       	rjmp	800076d4 <_realloc_r+0x268>
80007648:	08 9b       	mov	r11,r4
8000764a:	e0 a0 1d 42 	rcall	8000b0ce <memmove>
8000764e:	c4 38       	rjmp	800076d4 <_realloc_r+0x268>
80007650:	04 9c       	mov	r12,r2
80007652:	fe b0 fc 33 	rcall	80006eb8 <_malloc_r>
80007656:	18 95       	mov	r5,r12
80007658:	c3 a0       	breq	800076cc <_realloc_r+0x260>
8000765a:	62 18       	ld.w	r8,r1[0x4]
8000765c:	f8 c9 00 08 	sub	r9,r12,8
80007660:	a1 c8       	cbr	r8,0x0
80007662:	e2 08 00 08 	add	r8,r1,r8
80007666:	10 39       	cp.w	r9,r8
80007668:	c0 71       	brne	80007676 <_realloc_r+0x20a>
8000766a:	72 13       	ld.w	r3,r9[0x4]
8000766c:	02 97       	mov	r7,r1
8000766e:	e0 13 ff fc 	andl	r3,0xfffc
80007672:	00 03       	add	r3,r0
80007674:	c3 08       	rjmp	800076d4 <_realloc_r+0x268>
80007676:	e0 ca 00 04 	sub	r10,r0,4
8000767a:	e0 4a 00 24 	cp.w	r10,36
8000767e:	e0 8b 00 20 	brhi	800076be <_realloc_r+0x252>
80007682:	08 99       	mov	r9,r4
80007684:	18 98       	mov	r8,r12
80007686:	59 3a       	cp.w	r10,19
80007688:	e0 88 00 14 	brls	800076b0 <_realloc_r+0x244>
8000768c:	13 0b       	ld.w	r11,r9++
8000768e:	10 ab       	st.w	r8++,r11
80007690:	13 0b       	ld.w	r11,r9++
80007692:	10 ab       	st.w	r8++,r11
80007694:	59 ba       	cp.w	r10,27
80007696:	e0 88 00 0d 	brls	800076b0 <_realloc_r+0x244>
8000769a:	13 0b       	ld.w	r11,r9++
8000769c:	10 ab       	st.w	r8++,r11
8000769e:	13 0b       	ld.w	r11,r9++
800076a0:	10 ab       	st.w	r8++,r11
800076a2:	e0 4a 00 24 	cp.w	r10,36
800076a6:	c0 51       	brne	800076b0 <_realloc_r+0x244>
800076a8:	13 0a       	ld.w	r10,r9++
800076aa:	10 aa       	st.w	r8++,r10
800076ac:	13 0a       	ld.w	r10,r9++
800076ae:	10 aa       	st.w	r8++,r10
800076b0:	13 0a       	ld.w	r10,r9++
800076b2:	10 aa       	st.w	r8++,r10
800076b4:	72 0a       	ld.w	r10,r9[0x0]
800076b6:	91 0a       	st.w	r8[0x0],r10
800076b8:	72 19       	ld.w	r9,r9[0x4]
800076ba:	91 19       	st.w	r8[0x4],r9
800076bc:	c0 48       	rjmp	800076c4 <_realloc_r+0x258>
800076be:	08 9b       	mov	r11,r4
800076c0:	e0 a0 1d 07 	rcall	8000b0ce <memmove>
800076c4:	08 9b       	mov	r11,r4
800076c6:	04 9c       	mov	r12,r2
800076c8:	e0 a0 1a 60 	rcall	8000ab88 <_free_r>
800076cc:	04 9c       	mov	r12,r2
800076ce:	c2 a8       	rjmp	80007722 <_realloc_r+0x2b6>
800076d0:	00 93       	mov	r3,r0
800076d2:	02 97       	mov	r7,r1
800076d4:	e6 06 01 09 	sub	r9,r3,r6
800076d8:	6e 18       	ld.w	r8,r7[0x4]
800076da:	58 f9       	cp.w	r9,15
800076dc:	e0 88 00 16 	brls	80007708 <_realloc_r+0x29c>
800076e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076e4:	ed e8 10 08 	or	r8,r6,r8
800076e8:	8f 18       	st.w	r7[0x4],r8
800076ea:	12 98       	mov	r8,r9
800076ec:	a1 a8       	sbr	r8,0x0
800076ee:	ee 06 00 0b 	add	r11,r7,r6
800076f2:	f6 09 00 09 	add	r9,r11,r9
800076f6:	97 18       	st.w	r11[0x4],r8
800076f8:	72 18       	ld.w	r8,r9[0x4]
800076fa:	a1 a8       	sbr	r8,0x0
800076fc:	2f 8b       	sub	r11,-8
800076fe:	93 18       	st.w	r9[0x4],r8
80007700:	04 9c       	mov	r12,r2
80007702:	e0 a0 1a 43 	rcall	8000ab88 <_free_r>
80007706:	c0 b8       	rjmp	8000771c <_realloc_r+0x2b0>
80007708:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000770c:	e7 e8 10 08 	or	r8,r3,r8
80007710:	8f 18       	st.w	r7[0x4],r8
80007712:	ee 03 00 03 	add	r3,r7,r3
80007716:	66 18       	ld.w	r8,r3[0x4]
80007718:	a1 a8       	sbr	r8,0x0
8000771a:	87 18       	st.w	r3[0x4],r8
8000771c:	04 9c       	mov	r12,r2
8000771e:	ee c5 ff f8 	sub	r5,r7,-8
80007722:	fe b0 f1 cf 	rcall	80005ac0 <__malloc_unlock>
80007726:	0a 9c       	mov	r12,r5
80007728:	2f fd       	sub	sp,-4
8000772a:	d8 32       	popm	r0-r7,pc

8000772c <_sbrk_r>:
8000772c:	d4 21       	pushm	r4-r7,lr
8000772e:	30 08       	mov	r8,0
80007730:	18 97       	mov	r7,r12
80007732:	e0 66 63 a0 	mov	r6,25504
80007736:	16 9c       	mov	r12,r11
80007738:	8d 08       	st.w	r6[0x0],r8
8000773a:	c8 5c       	rcall	80007844 <_sbrk>
8000773c:	5b fc       	cp.w	r12,-1
8000773e:	c0 51       	brne	80007748 <_sbrk_r+0x1c>
80007740:	6c 08       	ld.w	r8,r6[0x0]
80007742:	58 08       	cp.w	r8,0
80007744:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007748:	d8 22       	popm	r4-r7,pc
8000774a:	d7 03       	nop

8000774c <sprintf>:
8000774c:	d4 01       	pushm	lr
8000774e:	21 7d       	sub	sp,92
80007750:	e0 68 ff ff 	mov	r8,65535
80007754:	ea 18 7f ff 	orh	r8,0x7fff
80007758:	50 58       	stdsp	sp[0x14],r8
8000775a:	50 28       	stdsp	sp[0x8],r8
8000775c:	e0 68 02 08 	mov	r8,520
80007760:	ba 68       	st.h	sp[0xc],r8
80007762:	3f f8       	mov	r8,-1
80007764:	ba 78       	st.h	sp[0xe],r8
80007766:	e0 68 0a 38 	mov	r8,2616
8000776a:	50 4c       	stdsp	sp[0x10],r12
8000776c:	16 9a       	mov	r10,r11
8000776e:	50 0c       	stdsp	sp[0x0],r12
80007770:	fa c9 ff a0 	sub	r9,sp,-96
80007774:	70 0c       	ld.w	r12,r8[0x0]
80007776:	1a 9b       	mov	r11,sp
80007778:	e0 a0 02 1a 	rcall	80007bac <_vfprintf_r>
8000777c:	30 09       	mov	r9,0
8000777e:	40 08       	lddsp	r8,sp[0x0]
80007780:	b0 89       	st.b	r8[0x0],r9
80007782:	2e 9d       	sub	sp,-92
80007784:	d8 02       	popm	pc
80007786:	d7 03       	nop

80007788 <strncpy>:
80007788:	30 08       	mov	r8,0
8000778a:	10 3a       	cp.w	r10,r8
8000778c:	5e 0c       	reteq	r12
8000778e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007792:	f8 08 0b 09 	st.b	r12[r8],r9
80007796:	2f f8       	sub	r8,-1
80007798:	58 09       	cp.w	r9,0
8000779a:	cf 81       	brne	8000778a <strncpy+0x2>
8000779c:	10 3a       	cp.w	r10,r8
8000779e:	5e 0c       	reteq	r12
800077a0:	f8 08 0b 09 	st.b	r12[r8],r9
800077a4:	2f f8       	sub	r8,-1
800077a6:	cf bb       	rjmp	8000779c <strncpy+0x14>

800077a8 <_close>:
800077a8:	30 28       	mov	r8,2
800077aa:	d6 73       	breakpoint
800077ac:	3f fc       	mov	r12,-1
800077ae:	35 8b       	mov	r11,88
800077b0:	58 0c       	cp.w	r12,0
800077b2:	5e 4c       	retge	r12
800077b4:	e0 6a 63 a0 	mov	r10,25504
800077b8:	95 0b       	st.w	r10[0x0],r11
800077ba:	5e fc       	retal	r12

800077bc <_lseek>:
800077bc:	30 58       	mov	r8,5
800077be:	d6 73       	breakpoint
800077c0:	3f fc       	mov	r12,-1
800077c2:	35 8b       	mov	r11,88
800077c4:	58 0c       	cp.w	r12,0
800077c6:	5e 4c       	retge	r12
800077c8:	e0 6a 63 a0 	mov	r10,25504
800077cc:	95 0b       	st.w	r10[0x0],r11
800077ce:	5e fc       	retal	r12

800077d0 <isatty>:
800077d0:	30 b8       	mov	r8,11
800077d2:	d6 73       	breakpoint
800077d4:	3f fc       	mov	r12,-1
800077d6:	35 8b       	mov	r11,88
800077d8:	58 0c       	cp.w	r12,0
800077da:	5e 4c       	retge	r12
800077dc:	e0 6a 63 a0 	mov	r10,25504
800077e0:	95 0b       	st.w	r10[0x0],r11
800077e2:	5e fc       	retal	r12

800077e4 <_fstat_host>:
800077e4:	30 98       	mov	r8,9
800077e6:	d6 73       	breakpoint
800077e8:	3f fc       	mov	r12,-1
800077ea:	35 8b       	mov	r11,88
800077ec:	58 0c       	cp.w	r12,0
800077ee:	5e 4c       	retge	r12
800077f0:	e0 6a 63 a0 	mov	r10,25504
800077f4:	95 0b       	st.w	r10[0x0],r11
800077f6:	5e fc       	retal	r12

800077f8 <_fstat>:
800077f8:	d4 21       	pushm	r4-r7,lr
800077fa:	21 0d       	sub	sp,64
800077fc:	16 97       	mov	r7,r11
800077fe:	1a 9b       	mov	r11,sp
80007800:	cf 2f       	rcall	800077e4 <_fstat_host>
80007802:	c0 34       	brge	80007808 <_fstat+0x10>
80007804:	3f fc       	mov	r12,-1
80007806:	c1 c8       	rjmp	8000783e <_fstat+0x46>
80007808:	40 08       	lddsp	r8,sp[0x0]
8000780a:	ae 08       	st.h	r7[0x0],r8
8000780c:	40 18       	lddsp	r8,sp[0x4]
8000780e:	ae 18       	st.h	r7[0x2],r8
80007810:	40 28       	lddsp	r8,sp[0x8]
80007812:	8f 18       	st.w	r7[0x4],r8
80007814:	40 38       	lddsp	r8,sp[0xc]
80007816:	ae 48       	st.h	r7[0x8],r8
80007818:	40 48       	lddsp	r8,sp[0x10]
8000781a:	ae 58       	st.h	r7[0xa],r8
8000781c:	40 58       	lddsp	r8,sp[0x14]
8000781e:	ae 68       	st.h	r7[0xc],r8
80007820:	40 68       	lddsp	r8,sp[0x18]
80007822:	ae 78       	st.h	r7[0xe],r8
80007824:	40 88       	lddsp	r8,sp[0x20]
80007826:	8f 48       	st.w	r7[0x10],r8
80007828:	40 a8       	lddsp	r8,sp[0x28]
8000782a:	8f b8       	st.w	r7[0x2c],r8
8000782c:	40 c8       	lddsp	r8,sp[0x30]
8000782e:	8f c8       	st.w	r7[0x30],r8
80007830:	40 d8       	lddsp	r8,sp[0x34]
80007832:	8f 58       	st.w	r7[0x14],r8
80007834:	40 e8       	lddsp	r8,sp[0x38]
80007836:	30 0c       	mov	r12,0
80007838:	8f 78       	st.w	r7[0x1c],r8
8000783a:	40 f8       	lddsp	r8,sp[0x3c]
8000783c:	8f 98       	st.w	r7[0x24],r8
8000783e:	2f 0d       	sub	sp,-64
80007840:	d8 22       	popm	r4-r7,pc
80007842:	d7 03       	nop

80007844 <_sbrk>:
80007844:	d4 01       	pushm	lr
80007846:	e0 68 0d 88 	mov	r8,3464
8000784a:	70 09       	ld.w	r9,r8[0x0]
8000784c:	58 09       	cp.w	r9,0
8000784e:	c0 41       	brne	80007856 <_sbrk+0x12>
80007850:	e0 69 63 a8 	mov	r9,25512
80007854:	91 09       	st.w	r8[0x0],r9
80007856:	e0 69 0d 88 	mov	r9,3464
8000785a:	e0 7a 70 00 	mov	r10,94208
8000785e:	72 08       	ld.w	r8,r9[0x0]
80007860:	f0 0c 00 0c 	add	r12,r8,r12
80007864:	14 3c       	cp.w	r12,r10
80007866:	e0 8b 00 04 	brhi	8000786e <_sbrk+0x2a>
8000786a:	93 0c       	st.w	r9[0x0],r12
8000786c:	c0 68       	rjmp	80007878 <_sbrk+0x34>
8000786e:	e0 a0 18 15 	rcall	8000a898 <__errno>
80007872:	30 c8       	mov	r8,12
80007874:	99 08       	st.w	r12[0x0],r8
80007876:	3f f8       	mov	r8,-1
80007878:	10 9c       	mov	r12,r8
8000787a:	d8 02       	popm	pc

8000787c <get_arg>:
8000787c:	d4 31       	pushm	r0-r7,lr
8000787e:	20 8d       	sub	sp,32
80007880:	fa c4 ff bc 	sub	r4,sp,-68
80007884:	50 4b       	stdsp	sp[0x10],r11
80007886:	68 2e       	ld.w	lr,r4[0x8]
80007888:	50 58       	stdsp	sp[0x14],r8
8000788a:	12 96       	mov	r6,r9
8000788c:	7c 0b       	ld.w	r11,lr[0x0]
8000788e:	70 05       	ld.w	r5,r8[0x0]
80007890:	50 6e       	stdsp	sp[0x18],lr
80007892:	58 0b       	cp.w	r11,0
80007894:	f4 0b 17 00 	moveq	r11,r10
80007898:	68 03       	ld.w	r3,r4[0x0]
8000789a:	68 11       	ld.w	r1,r4[0x4]
8000789c:	40 49       	lddsp	r9,sp[0x10]
8000789e:	30 08       	mov	r8,0
800078a0:	c2 89       	rjmp	80007af0 <get_arg+0x274>
800078a2:	2f fb       	sub	r11,-1
800078a4:	32 5c       	mov	r12,37
800078a6:	17 8a       	ld.ub	r10,r11[0x0]
800078a8:	f8 0a 18 00 	cp.b	r10,r12
800078ac:	5f 1e       	srne	lr
800078ae:	f0 0a 18 00 	cp.b	r10,r8
800078b2:	5f 1c       	srne	r12
800078b4:	fd ec 00 0c 	and	r12,lr,r12
800078b8:	f0 0c 18 00 	cp.b	r12,r8
800078bc:	cf 31       	brne	800078a2 <get_arg+0x26>
800078be:	58 0a       	cp.w	r10,0
800078c0:	e0 80 01 25 	breq	80007b0a <get_arg+0x28e>
800078c4:	30 0c       	mov	r12,0
800078c6:	3f fa       	mov	r10,-1
800078c8:	18 90       	mov	r0,r12
800078ca:	50 3a       	stdsp	sp[0xc],r10
800078cc:	18 94       	mov	r4,r12
800078ce:	18 92       	mov	r2,r12
800078d0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800078d4:	16 97       	mov	r7,r11
800078d6:	50 7c       	stdsp	sp[0x1c],r12
800078d8:	fe cc 9f b4 	sub	r12,pc,-24652
800078dc:	0f 3a       	ld.ub	r10,r7++
800078de:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800078e2:	40 7c       	lddsp	r12,sp[0x1c]
800078e4:	1c 0c       	add	r12,lr
800078e6:	fe ce a0 8a 	sub	lr,pc,-24438
800078ea:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800078ee:	20 1e       	sub	lr,1
800078f0:	50 0e       	stdsp	sp[0x0],lr
800078f2:	fe ce a1 02 	sub	lr,pc,-24318
800078f6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800078fa:	50 7c       	stdsp	sp[0x1c],r12
800078fc:	40 0c       	lddsp	r12,sp[0x0]
800078fe:	58 7c       	cp.w	r12,7
80007900:	e0 8b 00 f1 	brhi	80007ae2 <get_arg+0x266>
80007904:	fe ce a2 b4 	sub	lr,pc,-23884
80007908:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000790c:	36 8b       	mov	r11,104
8000790e:	f6 0a 18 00 	cp.b	r10,r11
80007912:	e0 80 00 e8 	breq	80007ae2 <get_arg+0x266>
80007916:	37 1b       	mov	r11,113
80007918:	f6 0a 18 00 	cp.b	r10,r11
8000791c:	c0 70       	breq	8000792a <get_arg+0xae>
8000791e:	34 cb       	mov	r11,76
80007920:	f6 0a 18 00 	cp.b	r10,r11
80007924:	c0 51       	brne	8000792e <get_arg+0xb2>
80007926:	a3 b4       	sbr	r4,0x3
80007928:	cd d8       	rjmp	80007ae2 <get_arg+0x266>
8000792a:	a5 b4       	sbr	r4,0x5
8000792c:	cd b8       	rjmp	80007ae2 <get_arg+0x266>
8000792e:	08 9a       	mov	r10,r4
80007930:	0e 9b       	mov	r11,r7
80007932:	a5 aa       	sbr	r10,0x4
80007934:	17 3c       	ld.ub	r12,r11++
80007936:	a5 b4       	sbr	r4,0x5
80007938:	36 ce       	mov	lr,108
8000793a:	fc 0c 18 00 	cp.b	r12,lr
8000793e:	e0 80 00 d3 	breq	80007ae4 <get_arg+0x268>
80007942:	14 94       	mov	r4,r10
80007944:	cc f8       	rjmp	80007ae2 <get_arg+0x266>
80007946:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000794a:	36 7c       	mov	r12,103
8000794c:	f8 0a 18 00 	cp.b	r10,r12
80007950:	e0 8b 00 27 	brhi	8000799e <get_arg+0x122>
80007954:	36 5b       	mov	r11,101
80007956:	f6 0a 18 00 	cp.b	r10,r11
8000795a:	c4 82       	brcc	800079ea <get_arg+0x16e>
8000795c:	34 fb       	mov	r11,79
8000795e:	f6 0a 18 00 	cp.b	r10,r11
80007962:	c4 80       	breq	800079f2 <get_arg+0x176>
80007964:	e0 8b 00 0c 	brhi	8000797c <get_arg+0x100>
80007968:	34 5b       	mov	r11,69
8000796a:	f6 0a 18 00 	cp.b	r10,r11
8000796e:	c3 e0       	breq	800079ea <get_arg+0x16e>
80007970:	34 7b       	mov	r11,71
80007972:	f6 0a 18 00 	cp.b	r10,r11
80007976:	c3 a0       	breq	800079ea <get_arg+0x16e>
80007978:	34 4b       	mov	r11,68
8000797a:	c0 88       	rjmp	8000798a <get_arg+0x10e>
8000797c:	35 8b       	mov	r11,88
8000797e:	f6 0a 18 00 	cp.b	r10,r11
80007982:	c2 c0       	breq	800079da <get_arg+0x15e>
80007984:	e0 8b 00 07 	brhi	80007992 <get_arg+0x116>
80007988:	35 5b       	mov	r11,85
8000798a:	f6 0a 18 00 	cp.b	r10,r11
8000798e:	c3 51       	brne	800079f8 <get_arg+0x17c>
80007990:	c3 18       	rjmp	800079f2 <get_arg+0x176>
80007992:	36 3b       	mov	r11,99
80007994:	f6 0a 18 00 	cp.b	r10,r11
80007998:	c2 f0       	breq	800079f6 <get_arg+0x17a>
8000799a:	36 4b       	mov	r11,100
8000799c:	c0 e8       	rjmp	800079b8 <get_arg+0x13c>
8000799e:	37 0b       	mov	r11,112
800079a0:	f6 0a 18 00 	cp.b	r10,r11
800079a4:	c2 50       	breq	800079ee <get_arg+0x172>
800079a6:	e0 8b 00 0d 	brhi	800079c0 <get_arg+0x144>
800079aa:	36 eb       	mov	r11,110
800079ac:	f6 0a 18 00 	cp.b	r10,r11
800079b0:	c1 f0       	breq	800079ee <get_arg+0x172>
800079b2:	e0 8b 00 14 	brhi	800079da <get_arg+0x15e>
800079b6:	36 9b       	mov	r11,105
800079b8:	f6 0a 18 00 	cp.b	r10,r11
800079bc:	c1 e1       	brne	800079f8 <get_arg+0x17c>
800079be:	c0 e8       	rjmp	800079da <get_arg+0x15e>
800079c0:	37 5b       	mov	r11,117
800079c2:	f6 0a 18 00 	cp.b	r10,r11
800079c6:	c0 a0       	breq	800079da <get_arg+0x15e>
800079c8:	37 8b       	mov	r11,120
800079ca:	f6 0a 18 00 	cp.b	r10,r11
800079ce:	c0 60       	breq	800079da <get_arg+0x15e>
800079d0:	37 3b       	mov	r11,115
800079d2:	f6 0a 18 00 	cp.b	r10,r11
800079d6:	c1 11       	brne	800079f8 <get_arg+0x17c>
800079d8:	c0 b8       	rjmp	800079ee <get_arg+0x172>
800079da:	ed b4 00 04 	bld	r4,0x4
800079de:	c0 a0       	breq	800079f2 <get_arg+0x176>
800079e0:	ed b4 00 05 	bld	r4,0x5
800079e4:	c0 91       	brne	800079f6 <get_arg+0x17a>
800079e6:	30 20       	mov	r0,2
800079e8:	c0 88       	rjmp	800079f8 <get_arg+0x17c>
800079ea:	30 40       	mov	r0,4
800079ec:	c0 68       	rjmp	800079f8 <get_arg+0x17c>
800079ee:	30 30       	mov	r0,3
800079f0:	c0 48       	rjmp	800079f8 <get_arg+0x17c>
800079f2:	30 10       	mov	r0,1
800079f4:	c0 28       	rjmp	800079f8 <get_arg+0x17c>
800079f6:	30 00       	mov	r0,0
800079f8:	40 3b       	lddsp	r11,sp[0xc]
800079fa:	5b fb       	cp.w	r11,-1
800079fc:	c0 40       	breq	80007a04 <get_arg+0x188>
800079fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007a02:	c7 08       	rjmp	80007ae2 <get_arg+0x266>
80007a04:	58 60       	cp.w	r0,6
80007a06:	e0 8b 00 6e 	brhi	80007ae2 <get_arg+0x266>
80007a0a:	6c 0a       	ld.w	r10,r6[0x0]
80007a0c:	ea cc ff ff 	sub	r12,r5,-1
80007a10:	fe ce a3 a0 	sub	lr,pc,-23648
80007a14:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007a18:	f4 cb ff f8 	sub	r11,r10,-8
80007a1c:	8d 0b       	st.w	r6[0x0],r11
80007a1e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007a22:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007a26:	c0 f8       	rjmp	80007a44 <get_arg+0x1c8>
80007a28:	f4 cb ff fc 	sub	r11,r10,-4
80007a2c:	8d 0b       	st.w	r6[0x0],r11
80007a2e:	74 0a       	ld.w	r10,r10[0x0]
80007a30:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a34:	c0 88       	rjmp	80007a44 <get_arg+0x1c8>
80007a36:	f4 cb ff f8 	sub	r11,r10,-8
80007a3a:	8d 0b       	st.w	r6[0x0],r11
80007a3c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007a40:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007a44:	0e 9b       	mov	r11,r7
80007a46:	18 95       	mov	r5,r12
80007a48:	c4 e8       	rjmp	80007ae4 <get_arg+0x268>
80007a4a:	62 0a       	ld.w	r10,r1[0x0]
80007a4c:	5b fa       	cp.w	r10,-1
80007a4e:	c0 b1       	brne	80007a64 <get_arg+0x1e8>
80007a50:	50 19       	stdsp	sp[0x4],r9
80007a52:	50 28       	stdsp	sp[0x8],r8
80007a54:	e0 6a 00 80 	mov	r10,128
80007a58:	30 0b       	mov	r11,0
80007a5a:	02 9c       	mov	r12,r1
80007a5c:	fe b0 fd 01 	rcall	8000745e <memset>
80007a60:	40 28       	lddsp	r8,sp[0x8]
80007a62:	40 19       	lddsp	r9,sp[0x4]
80007a64:	e4 cc 00 01 	sub	r12,r2,1
80007a68:	0e 9b       	mov	r11,r7
80007a6a:	50 3c       	stdsp	sp[0xc],r12
80007a6c:	f2 0c 0c 49 	max	r9,r9,r12
80007a70:	c3 a8       	rjmp	80007ae4 <get_arg+0x268>
80007a72:	62 0a       	ld.w	r10,r1[0x0]
80007a74:	5b fa       	cp.w	r10,-1
80007a76:	c0 b1       	brne	80007a8c <get_arg+0x210>
80007a78:	50 19       	stdsp	sp[0x4],r9
80007a7a:	50 28       	stdsp	sp[0x8],r8
80007a7c:	e0 6a 00 80 	mov	r10,128
80007a80:	30 0b       	mov	r11,0
80007a82:	02 9c       	mov	r12,r1
80007a84:	fe b0 fc ed 	rcall	8000745e <memset>
80007a88:	40 28       	lddsp	r8,sp[0x8]
80007a8a:	40 19       	lddsp	r9,sp[0x4]
80007a8c:	20 12       	sub	r2,1
80007a8e:	30 0a       	mov	r10,0
80007a90:	0e 9b       	mov	r11,r7
80007a92:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007a96:	f2 02 0c 49 	max	r9,r9,r2
80007a9a:	c2 58       	rjmp	80007ae4 <get_arg+0x268>
80007a9c:	16 97       	mov	r7,r11
80007a9e:	6c 0a       	ld.w	r10,r6[0x0]
80007aa0:	f4 cb ff fc 	sub	r11,r10,-4
80007aa4:	8d 0b       	st.w	r6[0x0],r11
80007aa6:	74 0a       	ld.w	r10,r10[0x0]
80007aa8:	0e 9b       	mov	r11,r7
80007aaa:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007aae:	2f f5       	sub	r5,-1
80007ab0:	c1 a8       	rjmp	80007ae4 <get_arg+0x268>
80007ab2:	f4 c2 00 30 	sub	r2,r10,48
80007ab6:	c0 68       	rjmp	80007ac2 <get_arg+0x246>
80007ab8:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007abc:	2f f7       	sub	r7,-1
80007abe:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007ac2:	0f 8a       	ld.ub	r10,r7[0x0]
80007ac4:	58 0a       	cp.w	r10,0
80007ac6:	c0 e0       	breq	80007ae2 <get_arg+0x266>
80007ac8:	23 0a       	sub	r10,48
80007aca:	58 9a       	cp.w	r10,9
80007acc:	fe 98 ff f6 	brls	80007ab8 <get_arg+0x23c>
80007ad0:	c0 98       	rjmp	80007ae2 <get_arg+0x266>
80007ad2:	2f f7       	sub	r7,-1
80007ad4:	0f 8a       	ld.ub	r10,r7[0x0]
80007ad6:	58 0a       	cp.w	r10,0
80007ad8:	c0 50       	breq	80007ae2 <get_arg+0x266>
80007ada:	23 0a       	sub	r10,48
80007adc:	58 9a       	cp.w	r10,9
80007ade:	fe 98 ff fa 	brls	80007ad2 <get_arg+0x256>
80007ae2:	0e 9b       	mov	r11,r7
80007ae4:	40 7c       	lddsp	r12,sp[0x1c]
80007ae6:	30 ba       	mov	r10,11
80007ae8:	f4 0c 18 00 	cp.b	r12,r10
80007aec:	fe 91 fe f2 	brne	800078d0 <get_arg+0x54>
80007af0:	40 42       	lddsp	r2,sp[0x10]
80007af2:	17 8c       	ld.ub	r12,r11[0x0]
80007af4:	0a 32       	cp.w	r2,r5
80007af6:	5f 4a       	srge	r10
80007af8:	f0 0c 18 00 	cp.b	r12,r8
80007afc:	5f 1c       	srne	r12
80007afe:	f9 ea 00 0a 	and	r10,r12,r10
80007b02:	f0 0a 18 00 	cp.b	r10,r8
80007b06:	fe 91 fe cf 	brne	800078a4 <get_arg+0x28>
80007b0a:	30 08       	mov	r8,0
80007b0c:	40 4e       	lddsp	lr,sp[0x10]
80007b0e:	17 8a       	ld.ub	r10,r11[0x0]
80007b10:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007b14:	f0 0a 18 00 	cp.b	r10,r8
80007b18:	fc 09 17 10 	movne	r9,lr
80007b1c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007b20:	06 9e       	mov	lr,r3
80007b22:	c2 a8       	rjmp	80007b76 <get_arg+0x2fa>
80007b24:	62 0a       	ld.w	r10,r1[0x0]
80007b26:	58 3a       	cp.w	r10,3
80007b28:	c1 e0       	breq	80007b64 <get_arg+0x2e8>
80007b2a:	e0 89 00 07 	brgt	80007b38 <get_arg+0x2bc>
80007b2e:	58 1a       	cp.w	r10,1
80007b30:	c1 a0       	breq	80007b64 <get_arg+0x2e8>
80007b32:	58 2a       	cp.w	r10,2
80007b34:	c1 81       	brne	80007b64 <get_arg+0x2e8>
80007b36:	c0 58       	rjmp	80007b40 <get_arg+0x2c4>
80007b38:	58 5a       	cp.w	r10,5
80007b3a:	c0 c0       	breq	80007b52 <get_arg+0x2d6>
80007b3c:	c0 b5       	brlt	80007b52 <get_arg+0x2d6>
80007b3e:	c1 38       	rjmp	80007b64 <get_arg+0x2e8>
80007b40:	6c 0a       	ld.w	r10,r6[0x0]
80007b42:	f4 cc ff f8 	sub	r12,r10,-8
80007b46:	8d 0c       	st.w	r6[0x0],r12
80007b48:	f4 e2 00 00 	ld.d	r2,r10[0]
80007b4c:	f0 e3 00 00 	st.d	r8[0],r2
80007b50:	c1 08       	rjmp	80007b70 <get_arg+0x2f4>
80007b52:	6c 0a       	ld.w	r10,r6[0x0]
80007b54:	f4 cc ff f8 	sub	r12,r10,-8
80007b58:	8d 0c       	st.w	r6[0x0],r12
80007b5a:	f4 e2 00 00 	ld.d	r2,r10[0]
80007b5e:	f0 e3 00 00 	st.d	r8[0],r2
80007b62:	c0 78       	rjmp	80007b70 <get_arg+0x2f4>
80007b64:	6c 0a       	ld.w	r10,r6[0x0]
80007b66:	f4 cc ff fc 	sub	r12,r10,-4
80007b6a:	8d 0c       	st.w	r6[0x0],r12
80007b6c:	74 0a       	ld.w	r10,r10[0x0]
80007b6e:	91 0a       	st.w	r8[0x0],r10
80007b70:	2f f5       	sub	r5,-1
80007b72:	2f 88       	sub	r8,-8
80007b74:	2f c1       	sub	r1,-4
80007b76:	12 35       	cp.w	r5,r9
80007b78:	fe 9a ff d6 	brle	80007b24 <get_arg+0x2a8>
80007b7c:	1c 93       	mov	r3,lr
80007b7e:	40 52       	lddsp	r2,sp[0x14]
80007b80:	40 6e       	lddsp	lr,sp[0x18]
80007b82:	85 05       	st.w	r2[0x0],r5
80007b84:	9d 0b       	st.w	lr[0x0],r11
80007b86:	40 4b       	lddsp	r11,sp[0x10]
80007b88:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007b8c:	2f 8d       	sub	sp,-32
80007b8e:	d8 32       	popm	r0-r7,pc

80007b90 <__sprint_r>:
80007b90:	d4 21       	pushm	r4-r7,lr
80007b92:	14 97       	mov	r7,r10
80007b94:	74 28       	ld.w	r8,r10[0x8]
80007b96:	58 08       	cp.w	r8,0
80007b98:	c0 41       	brne	80007ba0 <__sprint_r+0x10>
80007b9a:	95 18       	st.w	r10[0x4],r8
80007b9c:	10 9c       	mov	r12,r8
80007b9e:	d8 22       	popm	r4-r7,pc
80007ba0:	e0 a0 18 ba 	rcall	8000ad14 <__sfvwrite_r>
80007ba4:	30 08       	mov	r8,0
80007ba6:	8f 18       	st.w	r7[0x4],r8
80007ba8:	8f 28       	st.w	r7[0x8],r8
80007baa:	d8 22       	popm	r4-r7,pc

80007bac <_vfprintf_r>:
80007bac:	d4 31       	pushm	r0-r7,lr
80007bae:	fa cd 06 bc 	sub	sp,sp,1724
80007bb2:	51 09       	stdsp	sp[0x40],r9
80007bb4:	16 91       	mov	r1,r11
80007bb6:	14 97       	mov	r7,r10
80007bb8:	18 95       	mov	r5,r12
80007bba:	e0 a0 1a 1d 	rcall	8000aff4 <_localeconv_r>
80007bbe:	78 0c       	ld.w	r12,r12[0x0]
80007bc0:	50 cc       	stdsp	sp[0x30],r12
80007bc2:	58 05       	cp.w	r5,0
80007bc4:	c0 70       	breq	80007bd2 <_vfprintf_r+0x26>
80007bc6:	6a 68       	ld.w	r8,r5[0x18]
80007bc8:	58 08       	cp.w	r8,0
80007bca:	c0 41       	brne	80007bd2 <_vfprintf_r+0x26>
80007bcc:	0a 9c       	mov	r12,r5
80007bce:	e0 a0 17 43 	rcall	8000aa54 <__sinit>
80007bd2:	fe c8 a1 9e 	sub	r8,pc,-24162
80007bd6:	10 31       	cp.w	r1,r8
80007bd8:	c0 31       	brne	80007bde <_vfprintf_r+0x32>
80007bda:	6a 01       	ld.w	r1,r5[0x0]
80007bdc:	c0 c8       	rjmp	80007bf4 <_vfprintf_r+0x48>
80007bde:	fe c8 a1 8a 	sub	r8,pc,-24182
80007be2:	10 31       	cp.w	r1,r8
80007be4:	c0 31       	brne	80007bea <_vfprintf_r+0x3e>
80007be6:	6a 11       	ld.w	r1,r5[0x4]
80007be8:	c0 68       	rjmp	80007bf4 <_vfprintf_r+0x48>
80007bea:	fe c8 a1 76 	sub	r8,pc,-24202
80007bee:	10 31       	cp.w	r1,r8
80007bf0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007bf4:	82 68       	ld.sh	r8,r1[0xc]
80007bf6:	ed b8 00 03 	bld	r8,0x3
80007bfa:	c0 41       	brne	80007c02 <_vfprintf_r+0x56>
80007bfc:	62 48       	ld.w	r8,r1[0x10]
80007bfe:	58 08       	cp.w	r8,0
80007c00:	c0 71       	brne	80007c0e <_vfprintf_r+0x62>
80007c02:	02 9b       	mov	r11,r1
80007c04:	0a 9c       	mov	r12,r5
80007c06:	e0 a0 0f 5d 	rcall	80009ac0 <__swsetup_r>
80007c0a:	e0 81 0f 54 	brne	80009ab2 <_vfprintf_r+0x1f06>
80007c0e:	82 68       	ld.sh	r8,r1[0xc]
80007c10:	10 99       	mov	r9,r8
80007c12:	e2 19 00 1a 	andl	r9,0x1a,COH
80007c16:	58 a9       	cp.w	r9,10
80007c18:	c3 c1       	brne	80007c90 <_vfprintf_r+0xe4>
80007c1a:	82 79       	ld.sh	r9,r1[0xe]
80007c1c:	30 0a       	mov	r10,0
80007c1e:	f4 09 19 00 	cp.h	r9,r10
80007c22:	c3 75       	brlt	80007c90 <_vfprintf_r+0xe4>
80007c24:	a1 d8       	cbr	r8,0x1
80007c26:	fb 58 05 d0 	st.h	sp[1488],r8
80007c2a:	62 88       	ld.w	r8,r1[0x20]
80007c2c:	fb 48 05 e4 	st.w	sp[1508],r8
80007c30:	62 a8       	ld.w	r8,r1[0x28]
80007c32:	fb 48 05 ec 	st.w	sp[1516],r8
80007c36:	fa c8 ff bc 	sub	r8,sp,-68
80007c3a:	fb 48 05 d4 	st.w	sp[1492],r8
80007c3e:	fb 48 05 c4 	st.w	sp[1476],r8
80007c42:	e0 68 04 00 	mov	r8,1024
80007c46:	fb 48 05 d8 	st.w	sp[1496],r8
80007c4a:	fb 48 05 cc 	st.w	sp[1484],r8
80007c4e:	30 08       	mov	r8,0
80007c50:	fb 59 05 d2 	st.h	sp[1490],r9
80007c54:	0e 9a       	mov	r10,r7
80007c56:	41 09       	lddsp	r9,sp[0x40]
80007c58:	fa c7 fa 3c 	sub	r7,sp,-1476
80007c5c:	fb 48 05 dc 	st.w	sp[1500],r8
80007c60:	0a 9c       	mov	r12,r5
80007c62:	0e 9b       	mov	r11,r7
80007c64:	ca 4f       	rcall	80007bac <_vfprintf_r>
80007c66:	50 bc       	stdsp	sp[0x2c],r12
80007c68:	c0 95       	brlt	80007c7a <_vfprintf_r+0xce>
80007c6a:	0e 9b       	mov	r11,r7
80007c6c:	0a 9c       	mov	r12,r5
80007c6e:	e0 a0 16 1b 	rcall	8000a8a4 <_fflush_r>
80007c72:	40 be       	lddsp	lr,sp[0x2c]
80007c74:	f9 be 01 ff 	movne	lr,-1
80007c78:	50 be       	stdsp	sp[0x2c],lr
80007c7a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007c7e:	ed b8 00 06 	bld	r8,0x6
80007c82:	e0 81 0f 1a 	brne	80009ab6 <_vfprintf_r+0x1f0a>
80007c86:	82 68       	ld.sh	r8,r1[0xc]
80007c88:	a7 a8       	sbr	r8,0x6
80007c8a:	a2 68       	st.h	r1[0xc],r8
80007c8c:	e0 8f 0f 15 	bral	80009ab6 <_vfprintf_r+0x1f0a>
80007c90:	30 08       	mov	r8,0
80007c92:	fb 48 06 b4 	st.w	sp[1716],r8
80007c96:	fb 48 06 90 	st.w	sp[1680],r8
80007c9a:	fb 48 06 8c 	st.w	sp[1676],r8
80007c9e:	fb 48 06 b0 	st.w	sp[1712],r8
80007ca2:	30 08       	mov	r8,0
80007ca4:	30 09       	mov	r9,0
80007ca6:	50 a7       	stdsp	sp[0x28],r7
80007ca8:	50 78       	stdsp	sp[0x1c],r8
80007caa:	fa c3 f9 e0 	sub	r3,sp,-1568
80007cae:	3f f8       	mov	r8,-1
80007cb0:	50 59       	stdsp	sp[0x14],r9
80007cb2:	fb 43 06 88 	st.w	sp[1672],r3
80007cb6:	fb 48 05 44 	st.w	sp[1348],r8
80007cba:	12 9c       	mov	r12,r9
80007cbc:	50 69       	stdsp	sp[0x18],r9
80007cbe:	50 d9       	stdsp	sp[0x34],r9
80007cc0:	50 e9       	stdsp	sp[0x38],r9
80007cc2:	50 b9       	stdsp	sp[0x2c],r9
80007cc4:	12 97       	mov	r7,r9
80007cc6:	0a 94       	mov	r4,r5
80007cc8:	40 a2       	lddsp	r2,sp[0x28]
80007cca:	32 5a       	mov	r10,37
80007ccc:	30 08       	mov	r8,0
80007cce:	c0 28       	rjmp	80007cd2 <_vfprintf_r+0x126>
80007cd0:	2f f2       	sub	r2,-1
80007cd2:	05 89       	ld.ub	r9,r2[0x0]
80007cd4:	f0 09 18 00 	cp.b	r9,r8
80007cd8:	5f 1b       	srne	r11
80007cda:	f4 09 18 00 	cp.b	r9,r10
80007cde:	5f 19       	srne	r9
80007ce0:	f3 eb 00 0b 	and	r11,r9,r11
80007ce4:	f0 0b 18 00 	cp.b	r11,r8
80007ce8:	cf 41       	brne	80007cd0 <_vfprintf_r+0x124>
80007cea:	40 ab       	lddsp	r11,sp[0x28]
80007cec:	e4 0b 01 06 	sub	r6,r2,r11
80007cf0:	c1 e0       	breq	80007d2c <_vfprintf_r+0x180>
80007cf2:	fa f8 06 90 	ld.w	r8,sp[1680]
80007cf6:	0c 08       	add	r8,r6
80007cf8:	87 0b       	st.w	r3[0x0],r11
80007cfa:	fb 48 06 90 	st.w	sp[1680],r8
80007cfe:	87 16       	st.w	r3[0x4],r6
80007d00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d04:	2f f8       	sub	r8,-1
80007d06:	fb 48 06 8c 	st.w	sp[1676],r8
80007d0a:	58 78       	cp.w	r8,7
80007d0c:	e0 89 00 04 	brgt	80007d14 <_vfprintf_r+0x168>
80007d10:	2f 83       	sub	r3,-8
80007d12:	c0 a8       	rjmp	80007d26 <_vfprintf_r+0x17a>
80007d14:	fa ca f9 78 	sub	r10,sp,-1672
80007d18:	02 9b       	mov	r11,r1
80007d1a:	08 9c       	mov	r12,r4
80007d1c:	c3 af       	rcall	80007b90 <__sprint_r>
80007d1e:	e0 81 0e c6 	brne	80009aaa <_vfprintf_r+0x1efe>
80007d22:	fa c3 f9 e0 	sub	r3,sp,-1568
80007d26:	40 ba       	lddsp	r10,sp[0x2c]
80007d28:	0c 0a       	add	r10,r6
80007d2a:	50 ba       	stdsp	sp[0x2c],r10
80007d2c:	05 89       	ld.ub	r9,r2[0x0]
80007d2e:	30 08       	mov	r8,0
80007d30:	f0 09 18 00 	cp.b	r9,r8
80007d34:	e0 80 0e aa 	breq	80009a88 <_vfprintf_r+0x1edc>
80007d38:	30 09       	mov	r9,0
80007d3a:	fb 68 06 bb 	st.b	sp[1723],r8
80007d3e:	0e 96       	mov	r6,r7
80007d40:	e4 c8 ff ff 	sub	r8,r2,-1
80007d44:	3f fe       	mov	lr,-1
80007d46:	50 93       	stdsp	sp[0x24],r3
80007d48:	50 41       	stdsp	sp[0x10],r1
80007d4a:	0e 93       	mov	r3,r7
80007d4c:	04 91       	mov	r1,r2
80007d4e:	50 89       	stdsp	sp[0x20],r9
80007d50:	50 a8       	stdsp	sp[0x28],r8
80007d52:	50 2e       	stdsp	sp[0x8],lr
80007d54:	50 39       	stdsp	sp[0xc],r9
80007d56:	12 95       	mov	r5,r9
80007d58:	12 90       	mov	r0,r9
80007d5a:	10 97       	mov	r7,r8
80007d5c:	08 92       	mov	r2,r4
80007d5e:	c0 78       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007d60:	3f fc       	mov	r12,-1
80007d62:	08 97       	mov	r7,r4
80007d64:	50 2c       	stdsp	sp[0x8],r12
80007d66:	c0 38       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007d68:	30 0b       	mov	r11,0
80007d6a:	50 3b       	stdsp	sp[0xc],r11
80007d6c:	0f 38       	ld.ub	r8,r7++
80007d6e:	c0 28       	rjmp	80007d72 <_vfprintf_r+0x1c6>
80007d70:	12 90       	mov	r0,r9
80007d72:	f0 c9 00 20 	sub	r9,r8,32
80007d76:	e0 49 00 58 	cp.w	r9,88
80007d7a:	e0 8b 0a 30 	brhi	800091da <_vfprintf_r+0x162e>
80007d7e:	fe ca a6 f2 	sub	r10,pc,-22798
80007d82:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007d86:	50 a7       	stdsp	sp[0x28],r7
80007d88:	50 80       	stdsp	sp[0x20],r0
80007d8a:	0c 97       	mov	r7,r6
80007d8c:	04 94       	mov	r4,r2
80007d8e:	06 96       	mov	r6,r3
80007d90:	02 92       	mov	r2,r1
80007d92:	fe c9 a4 ca 	sub	r9,pc,-23350
80007d96:	40 93       	lddsp	r3,sp[0x24]
80007d98:	10 90       	mov	r0,r8
80007d9a:	40 41       	lddsp	r1,sp[0x10]
80007d9c:	50 d9       	stdsp	sp[0x34],r9
80007d9e:	e0 8f 08 8e 	bral	80008eba <_vfprintf_r+0x130e>
80007da2:	30 08       	mov	r8,0
80007da4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007da8:	f0 09 18 00 	cp.b	r9,r8
80007dac:	ce 01       	brne	80007d6c <_vfprintf_r+0x1c0>
80007dae:	32 08       	mov	r8,32
80007db0:	c6 e8       	rjmp	80007e8c <_vfprintf_r+0x2e0>
80007db2:	a1 a5       	sbr	r5,0x0
80007db4:	cd cb       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007db6:	0f 89       	ld.ub	r9,r7[0x0]
80007db8:	f2 c8 00 30 	sub	r8,r9,48
80007dbc:	58 98       	cp.w	r8,9
80007dbe:	e0 8b 00 1d 	brhi	80007df8 <_vfprintf_r+0x24c>
80007dc2:	ee c8 ff ff 	sub	r8,r7,-1
80007dc6:	30 0b       	mov	r11,0
80007dc8:	23 09       	sub	r9,48
80007dca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007dce:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007dd2:	11 39       	ld.ub	r9,r8++
80007dd4:	f2 ca 00 30 	sub	r10,r9,48
80007dd8:	58 9a       	cp.w	r10,9
80007dda:	fe 98 ff f7 	brls	80007dc8 <_vfprintf_r+0x21c>
80007dde:	e0 49 00 24 	cp.w	r9,36
80007de2:	cc 31       	brne	80007d68 <_vfprintf_r+0x1bc>
80007de4:	e0 4b 00 20 	cp.w	r11,32
80007de8:	e0 89 0e 60 	brgt	80009aa8 <_vfprintf_r+0x1efc>
80007dec:	20 1b       	sub	r11,1
80007dee:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007df2:	12 3b       	cp.w	r11,r9
80007df4:	c0 95       	brlt	80007e06 <_vfprintf_r+0x25a>
80007df6:	c1 08       	rjmp	80007e16 <_vfprintf_r+0x26a>
80007df8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007dfc:	ec ca ff ff 	sub	r10,r6,-1
80007e00:	12 36       	cp.w	r6,r9
80007e02:	c1 f5       	brlt	80007e40 <_vfprintf_r+0x294>
80007e04:	c2 68       	rjmp	80007e50 <_vfprintf_r+0x2a4>
80007e06:	fa ce f9 44 	sub	lr,sp,-1724
80007e0a:	10 97       	mov	r7,r8
80007e0c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007e10:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007e14:	c3 58       	rjmp	80007e7e <_vfprintf_r+0x2d2>
80007e16:	10 97       	mov	r7,r8
80007e18:	fa c8 f9 50 	sub	r8,sp,-1712
80007e1c:	1a d8       	st.w	--sp,r8
80007e1e:	fa c8 fa b8 	sub	r8,sp,-1352
80007e22:	1a d8       	st.w	--sp,r8
80007e24:	fa c8 fb b4 	sub	r8,sp,-1100
80007e28:	02 9a       	mov	r10,r1
80007e2a:	1a d8       	st.w	--sp,r8
80007e2c:	04 9c       	mov	r12,r2
80007e2e:	fa c8 f9 40 	sub	r8,sp,-1728
80007e32:	fa c9 ff b4 	sub	r9,sp,-76
80007e36:	fe b0 fd 23 	rcall	8000787c <get_arg>
80007e3a:	2f dd       	sub	sp,-12
80007e3c:	78 00       	ld.w	r0,r12[0x0]
80007e3e:	c2 08       	rjmp	80007e7e <_vfprintf_r+0x2d2>
80007e40:	fa cc f9 44 	sub	r12,sp,-1724
80007e44:	14 96       	mov	r6,r10
80007e46:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007e4a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007e4e:	c1 88       	rjmp	80007e7e <_vfprintf_r+0x2d2>
80007e50:	41 08       	lddsp	r8,sp[0x40]
80007e52:	59 f9       	cp.w	r9,31
80007e54:	e0 89 00 11 	brgt	80007e76 <_vfprintf_r+0x2ca>
80007e58:	f0 cb ff fc 	sub	r11,r8,-4
80007e5c:	51 0b       	stdsp	sp[0x40],r11
80007e5e:	70 00       	ld.w	r0,r8[0x0]
80007e60:	fa cb f9 44 	sub	r11,sp,-1724
80007e64:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007e68:	f1 40 fd 88 	st.w	r8[-632],r0
80007e6c:	2f f9       	sub	r9,-1
80007e6e:	14 96       	mov	r6,r10
80007e70:	fb 49 06 b4 	st.w	sp[1716],r9
80007e74:	c0 58       	rjmp	80007e7e <_vfprintf_r+0x2d2>
80007e76:	70 00       	ld.w	r0,r8[0x0]
80007e78:	14 96       	mov	r6,r10
80007e7a:	2f c8       	sub	r8,-4
80007e7c:	51 08       	stdsp	sp[0x40],r8
80007e7e:	58 00       	cp.w	r0,0
80007e80:	fe 94 ff 76 	brge	80007d6c <_vfprintf_r+0x1c0>
80007e84:	5c 30       	neg	r0
80007e86:	a3 a5       	sbr	r5,0x2
80007e88:	c7 2b       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007e8a:	32 b8       	mov	r8,43
80007e8c:	fb 68 06 bb 	st.b	sp[1723],r8
80007e90:	c6 eb       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007e92:	0f 38       	ld.ub	r8,r7++
80007e94:	e0 48 00 2a 	cp.w	r8,42
80007e98:	c0 30       	breq	80007e9e <_vfprintf_r+0x2f2>
80007e9a:	30 09       	mov	r9,0
80007e9c:	c7 98       	rjmp	80007f8e <_vfprintf_r+0x3e2>
80007e9e:	0f 88       	ld.ub	r8,r7[0x0]
80007ea0:	f0 c9 00 30 	sub	r9,r8,48
80007ea4:	58 99       	cp.w	r9,9
80007ea6:	e0 8b 00 1f 	brhi	80007ee4 <_vfprintf_r+0x338>
80007eaa:	ee c4 ff ff 	sub	r4,r7,-1
80007eae:	30 0b       	mov	r11,0
80007eb0:	23 08       	sub	r8,48
80007eb2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007eb6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007eba:	09 38       	ld.ub	r8,r4++
80007ebc:	f0 c9 00 30 	sub	r9,r8,48
80007ec0:	58 99       	cp.w	r9,9
80007ec2:	fe 98 ff f7 	brls	80007eb0 <_vfprintf_r+0x304>
80007ec6:	e0 48 00 24 	cp.w	r8,36
80007eca:	fe 91 ff 4f 	brne	80007d68 <_vfprintf_r+0x1bc>
80007ece:	e0 4b 00 20 	cp.w	r11,32
80007ed2:	e0 89 0d eb 	brgt	80009aa8 <_vfprintf_r+0x1efc>
80007ed6:	20 1b       	sub	r11,1
80007ed8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007edc:	10 3b       	cp.w	r11,r8
80007ede:	c0 a5       	brlt	80007ef2 <_vfprintf_r+0x346>
80007ee0:	c1 18       	rjmp	80007f02 <_vfprintf_r+0x356>
80007ee2:	d7 03       	nop
80007ee4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007ee8:	ec c9 ff ff 	sub	r9,r6,-1
80007eec:	14 36       	cp.w	r6,r10
80007eee:	c1 f5       	brlt	80007f2c <_vfprintf_r+0x380>
80007ef0:	c2 88       	rjmp	80007f40 <_vfprintf_r+0x394>
80007ef2:	fa ca f9 44 	sub	r10,sp,-1724
80007ef6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007efa:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007efe:	50 2b       	stdsp	sp[0x8],r11
80007f00:	c3 c8       	rjmp	80007f78 <_vfprintf_r+0x3cc>
80007f02:	fa c8 f9 50 	sub	r8,sp,-1712
80007f06:	1a d8       	st.w	--sp,r8
80007f08:	fa c8 fa b8 	sub	r8,sp,-1352
80007f0c:	1a d8       	st.w	--sp,r8
80007f0e:	fa c8 fb b4 	sub	r8,sp,-1100
80007f12:	02 9a       	mov	r10,r1
80007f14:	1a d8       	st.w	--sp,r8
80007f16:	04 9c       	mov	r12,r2
80007f18:	fa c8 f9 40 	sub	r8,sp,-1728
80007f1c:	fa c9 ff b4 	sub	r9,sp,-76
80007f20:	fe b0 fc ae 	rcall	8000787c <get_arg>
80007f24:	2f dd       	sub	sp,-12
80007f26:	78 0c       	ld.w	r12,r12[0x0]
80007f28:	50 2c       	stdsp	sp[0x8],r12
80007f2a:	c2 78       	rjmp	80007f78 <_vfprintf_r+0x3cc>
80007f2c:	12 96       	mov	r6,r9
80007f2e:	0e 94       	mov	r4,r7
80007f30:	fa c9 f9 44 	sub	r9,sp,-1724
80007f34:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007f38:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007f3c:	50 28       	stdsp	sp[0x8],r8
80007f3e:	c1 d8       	rjmp	80007f78 <_vfprintf_r+0x3cc>
80007f40:	41 08       	lddsp	r8,sp[0x40]
80007f42:	59 fa       	cp.w	r10,31
80007f44:	e0 89 00 14 	brgt	80007f6c <_vfprintf_r+0x3c0>
80007f48:	f0 cb ff fc 	sub	r11,r8,-4
80007f4c:	70 08       	ld.w	r8,r8[0x0]
80007f4e:	51 0b       	stdsp	sp[0x40],r11
80007f50:	50 28       	stdsp	sp[0x8],r8
80007f52:	fa c6 f9 44 	sub	r6,sp,-1724
80007f56:	40 2e       	lddsp	lr,sp[0x8]
80007f58:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007f5c:	f1 4e fd 88 	st.w	r8[-632],lr
80007f60:	2f fa       	sub	r10,-1
80007f62:	0e 94       	mov	r4,r7
80007f64:	fb 4a 06 b4 	st.w	sp[1716],r10
80007f68:	12 96       	mov	r6,r9
80007f6a:	c0 78       	rjmp	80007f78 <_vfprintf_r+0x3cc>
80007f6c:	70 0c       	ld.w	r12,r8[0x0]
80007f6e:	0e 94       	mov	r4,r7
80007f70:	2f c8       	sub	r8,-4
80007f72:	50 2c       	stdsp	sp[0x8],r12
80007f74:	12 96       	mov	r6,r9
80007f76:	51 08       	stdsp	sp[0x40],r8
80007f78:	40 2b       	lddsp	r11,sp[0x8]
80007f7a:	58 0b       	cp.w	r11,0
80007f7c:	fe 95 fe f2 	brlt	80007d60 <_vfprintf_r+0x1b4>
80007f80:	08 97       	mov	r7,r4
80007f82:	cf 5a       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007f84:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f88:	0f 38       	ld.ub	r8,r7++
80007f8a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007f8e:	f0 ca 00 30 	sub	r10,r8,48
80007f92:	58 9a       	cp.w	r10,9
80007f94:	fe 98 ff f8 	brls	80007f84 <_vfprintf_r+0x3d8>
80007f98:	3f fa       	mov	r10,-1
80007f9a:	f2 0a 0c 49 	max	r9,r9,r10
80007f9e:	50 29       	stdsp	sp[0x8],r9
80007fa0:	ce 9a       	rjmp	80007d72 <_vfprintf_r+0x1c6>
80007fa2:	a7 b5       	sbr	r5,0x7
80007fa4:	ce 4a       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007fa6:	30 09       	mov	r9,0
80007fa8:	23 08       	sub	r8,48
80007faa:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007fae:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007fb2:	0f 38       	ld.ub	r8,r7++
80007fb4:	f0 ca 00 30 	sub	r10,r8,48
80007fb8:	58 9a       	cp.w	r10,9
80007fba:	fe 98 ff f7 	brls	80007fa8 <_vfprintf_r+0x3fc>
80007fbe:	e0 48 00 24 	cp.w	r8,36
80007fc2:	fe 91 fe d7 	brne	80007d70 <_vfprintf_r+0x1c4>
80007fc6:	e0 49 00 20 	cp.w	r9,32
80007fca:	e0 89 0d 6f 	brgt	80009aa8 <_vfprintf_r+0x1efc>
80007fce:	f2 c3 00 01 	sub	r3,r9,1
80007fd2:	30 19       	mov	r9,1
80007fd4:	50 39       	stdsp	sp[0xc],r9
80007fd6:	cc ba       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007fd8:	a3 b5       	sbr	r5,0x3
80007fda:	cc 9a       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007fdc:	a7 a5       	sbr	r5,0x6
80007fde:	cc 7a       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007fe0:	0a 98       	mov	r8,r5
80007fe2:	a5 b5       	sbr	r5,0x5
80007fe4:	a5 a8       	sbr	r8,0x4
80007fe6:	0f 89       	ld.ub	r9,r7[0x0]
80007fe8:	36 ce       	mov	lr,108
80007fea:	fc 09 18 00 	cp.b	r9,lr
80007fee:	f7 b7 00 ff 	subeq	r7,-1
80007ff2:	f0 05 17 10 	movne	r5,r8
80007ff6:	cb ba       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007ff8:	a5 b5       	sbr	r5,0x5
80007ffa:	cb 9a       	rjmp	80007d6c <_vfprintf_r+0x1c0>
80007ffc:	50 a7       	stdsp	sp[0x28],r7
80007ffe:	50 80       	stdsp	sp[0x20],r0
80008000:	0c 97       	mov	r7,r6
80008002:	10 90       	mov	r0,r8
80008004:	06 96       	mov	r6,r3
80008006:	04 94       	mov	r4,r2
80008008:	40 93       	lddsp	r3,sp[0x24]
8000800a:	02 92       	mov	r2,r1
8000800c:	0e 99       	mov	r9,r7
8000800e:	40 41       	lddsp	r1,sp[0x10]
80008010:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008014:	40 3c       	lddsp	r12,sp[0xc]
80008016:	58 0c       	cp.w	r12,0
80008018:	c1 d0       	breq	80008052 <_vfprintf_r+0x4a6>
8000801a:	10 36       	cp.w	r6,r8
8000801c:	c0 64       	brge	80008028 <_vfprintf_r+0x47c>
8000801e:	fa cb f9 44 	sub	r11,sp,-1724
80008022:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008026:	c1 d8       	rjmp	80008060 <_vfprintf_r+0x4b4>
80008028:	fa c8 f9 50 	sub	r8,sp,-1712
8000802c:	1a d8       	st.w	--sp,r8
8000802e:	fa c8 fa b8 	sub	r8,sp,-1352
80008032:	1a d8       	st.w	--sp,r8
80008034:	fa c8 fb b4 	sub	r8,sp,-1100
80008038:	1a d8       	st.w	--sp,r8
8000803a:	fa c8 f9 40 	sub	r8,sp,-1728
8000803e:	fa c9 ff b4 	sub	r9,sp,-76
80008042:	04 9a       	mov	r10,r2
80008044:	0c 9b       	mov	r11,r6
80008046:	08 9c       	mov	r12,r4
80008048:	fe b0 fc 1a 	rcall	8000787c <get_arg>
8000804c:	2f dd       	sub	sp,-12
8000804e:	19 b8       	ld.ub	r8,r12[0x3]
80008050:	c2 28       	rjmp	80008094 <_vfprintf_r+0x4e8>
80008052:	2f f7       	sub	r7,-1
80008054:	10 39       	cp.w	r9,r8
80008056:	c0 84       	brge	80008066 <_vfprintf_r+0x4ba>
80008058:	fa ca f9 44 	sub	r10,sp,-1724
8000805c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008060:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008064:	c1 88       	rjmp	80008094 <_vfprintf_r+0x4e8>
80008066:	41 09       	lddsp	r9,sp[0x40]
80008068:	59 f8       	cp.w	r8,31
8000806a:	e0 89 00 12 	brgt	8000808e <_vfprintf_r+0x4e2>
8000806e:	f2 ca ff fc 	sub	r10,r9,-4
80008072:	51 0a       	stdsp	sp[0x40],r10
80008074:	72 09       	ld.w	r9,r9[0x0]
80008076:	fa c6 f9 44 	sub	r6,sp,-1724
8000807a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000807e:	2f f8       	sub	r8,-1
80008080:	f5 49 fd 88 	st.w	r10[-632],r9
80008084:	fb 48 06 b4 	st.w	sp[1716],r8
80008088:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000808c:	c0 48       	rjmp	80008094 <_vfprintf_r+0x4e8>
8000808e:	13 b8       	ld.ub	r8,r9[0x3]
80008090:	2f c9       	sub	r9,-4
80008092:	51 09       	stdsp	sp[0x40],r9
80008094:	fb 68 06 60 	st.b	sp[1632],r8
80008098:	30 0e       	mov	lr,0
8000809a:	30 08       	mov	r8,0
8000809c:	30 12       	mov	r2,1
8000809e:	fb 68 06 bb 	st.b	sp[1723],r8
800080a2:	50 2e       	stdsp	sp[0x8],lr
800080a4:	e0 8f 08 ad 	bral	800091fe <_vfprintf_r+0x1652>
800080a8:	50 a7       	stdsp	sp[0x28],r7
800080aa:	50 80       	stdsp	sp[0x20],r0
800080ac:	0c 97       	mov	r7,r6
800080ae:	04 94       	mov	r4,r2
800080b0:	06 96       	mov	r6,r3
800080b2:	02 92       	mov	r2,r1
800080b4:	40 93       	lddsp	r3,sp[0x24]
800080b6:	10 90       	mov	r0,r8
800080b8:	40 41       	lddsp	r1,sp[0x10]
800080ba:	a5 a5       	sbr	r5,0x4
800080bc:	c0 a8       	rjmp	800080d0 <_vfprintf_r+0x524>
800080be:	50 a7       	stdsp	sp[0x28],r7
800080c0:	50 80       	stdsp	sp[0x20],r0
800080c2:	0c 97       	mov	r7,r6
800080c4:	04 94       	mov	r4,r2
800080c6:	06 96       	mov	r6,r3
800080c8:	02 92       	mov	r2,r1
800080ca:	40 93       	lddsp	r3,sp[0x24]
800080cc:	10 90       	mov	r0,r8
800080ce:	40 41       	lddsp	r1,sp[0x10]
800080d0:	ed b5 00 05 	bld	r5,0x5
800080d4:	c5 11       	brne	80008176 <_vfprintf_r+0x5ca>
800080d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080da:	40 3c       	lddsp	r12,sp[0xc]
800080dc:	58 0c       	cp.w	r12,0
800080de:	c1 e0       	breq	8000811a <_vfprintf_r+0x56e>
800080e0:	10 36       	cp.w	r6,r8
800080e2:	c0 64       	brge	800080ee <_vfprintf_r+0x542>
800080e4:	fa cb f9 44 	sub	r11,sp,-1724
800080e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080ec:	c2 08       	rjmp	8000812c <_vfprintf_r+0x580>
800080ee:	fa c8 f9 50 	sub	r8,sp,-1712
800080f2:	1a d8       	st.w	--sp,r8
800080f4:	fa c8 fa b8 	sub	r8,sp,-1352
800080f8:	0c 9b       	mov	r11,r6
800080fa:	1a d8       	st.w	--sp,r8
800080fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008100:	1a d8       	st.w	--sp,r8
80008102:	fa c9 ff b4 	sub	r9,sp,-76
80008106:	fa c8 f9 40 	sub	r8,sp,-1728
8000810a:	04 9a       	mov	r10,r2
8000810c:	08 9c       	mov	r12,r4
8000810e:	fe b0 fb b7 	rcall	8000787c <get_arg>
80008112:	2f dd       	sub	sp,-12
80008114:	78 1b       	ld.w	r11,r12[0x4]
80008116:	78 09       	ld.w	r9,r12[0x0]
80008118:	c2 b8       	rjmp	8000816e <_vfprintf_r+0x5c2>
8000811a:	ee ca ff ff 	sub	r10,r7,-1
8000811e:	10 37       	cp.w	r7,r8
80008120:	c0 b4       	brge	80008136 <_vfprintf_r+0x58a>
80008122:	fa c9 f9 44 	sub	r9,sp,-1724
80008126:	14 97       	mov	r7,r10
80008128:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000812c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008130:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008134:	c1 d8       	rjmp	8000816e <_vfprintf_r+0x5c2>
80008136:	41 09       	lddsp	r9,sp[0x40]
80008138:	59 f8       	cp.w	r8,31
8000813a:	e0 89 00 14 	brgt	80008162 <_vfprintf_r+0x5b6>
8000813e:	f2 cb ff f8 	sub	r11,r9,-8
80008142:	51 0b       	stdsp	sp[0x40],r11
80008144:	fa c6 f9 44 	sub	r6,sp,-1724
80008148:	72 1b       	ld.w	r11,r9[0x4]
8000814a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000814e:	72 09       	ld.w	r9,r9[0x0]
80008150:	f9 4b fd 8c 	st.w	r12[-628],r11
80008154:	f9 49 fd 88 	st.w	r12[-632],r9
80008158:	2f f8       	sub	r8,-1
8000815a:	14 97       	mov	r7,r10
8000815c:	fb 48 06 b4 	st.w	sp[1716],r8
80008160:	c0 78       	rjmp	8000816e <_vfprintf_r+0x5c2>
80008162:	f2 c8 ff f8 	sub	r8,r9,-8
80008166:	72 1b       	ld.w	r11,r9[0x4]
80008168:	14 97       	mov	r7,r10
8000816a:	51 08       	stdsp	sp[0x40],r8
8000816c:	72 09       	ld.w	r9,r9[0x0]
8000816e:	16 98       	mov	r8,r11
80008170:	fa e9 00 00 	st.d	sp[0],r8
80008174:	ca e8       	rjmp	800082d0 <_vfprintf_r+0x724>
80008176:	ed b5 00 04 	bld	r5,0x4
8000817a:	c1 71       	brne	800081a8 <_vfprintf_r+0x5fc>
8000817c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008180:	40 3e       	lddsp	lr,sp[0xc]
80008182:	58 0e       	cp.w	lr,0
80008184:	c0 80       	breq	80008194 <_vfprintf_r+0x5e8>
80008186:	10 36       	cp.w	r6,r8
80008188:	c6 94       	brge	8000825a <_vfprintf_r+0x6ae>
8000818a:	fa cc f9 44 	sub	r12,sp,-1724
8000818e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008192:	c8 28       	rjmp	80008296 <_vfprintf_r+0x6ea>
80008194:	ee ca ff ff 	sub	r10,r7,-1
80008198:	10 37       	cp.w	r7,r8
8000819a:	e0 84 00 81 	brge	8000829c <_vfprintf_r+0x6f0>
8000819e:	fa cb f9 44 	sub	r11,sp,-1724
800081a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081a6:	c7 78       	rjmp	80008294 <_vfprintf_r+0x6e8>
800081a8:	ed b5 00 06 	bld	r5,0x6
800081ac:	c4 b1       	brne	80008242 <_vfprintf_r+0x696>
800081ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081b2:	40 3c       	lddsp	r12,sp[0xc]
800081b4:	58 0c       	cp.w	r12,0
800081b6:	c1 d0       	breq	800081f0 <_vfprintf_r+0x644>
800081b8:	10 36       	cp.w	r6,r8
800081ba:	c0 64       	brge	800081c6 <_vfprintf_r+0x61a>
800081bc:	fa cb f9 44 	sub	r11,sp,-1724
800081c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081c4:	c1 f8       	rjmp	80008202 <_vfprintf_r+0x656>
800081c6:	fa c8 f9 50 	sub	r8,sp,-1712
800081ca:	1a d8       	st.w	--sp,r8
800081cc:	fa c8 fa b8 	sub	r8,sp,-1352
800081d0:	1a d8       	st.w	--sp,r8
800081d2:	fa c8 fb b4 	sub	r8,sp,-1100
800081d6:	1a d8       	st.w	--sp,r8
800081d8:	fa c8 f9 40 	sub	r8,sp,-1728
800081dc:	fa c9 ff b4 	sub	r9,sp,-76
800081e0:	04 9a       	mov	r10,r2
800081e2:	0c 9b       	mov	r11,r6
800081e4:	08 9c       	mov	r12,r4
800081e6:	fe b0 fb 4b 	rcall	8000787c <get_arg>
800081ea:	2f dd       	sub	sp,-12
800081ec:	98 18       	ld.sh	r8,r12[0x2]
800081ee:	c2 68       	rjmp	8000823a <_vfprintf_r+0x68e>
800081f0:	ee ca ff ff 	sub	r10,r7,-1
800081f4:	10 37       	cp.w	r7,r8
800081f6:	c0 94       	brge	80008208 <_vfprintf_r+0x65c>
800081f8:	fa c9 f9 44 	sub	r9,sp,-1724
800081fc:	14 97       	mov	r7,r10
800081fe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008202:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008206:	c1 a8       	rjmp	8000823a <_vfprintf_r+0x68e>
80008208:	41 09       	lddsp	r9,sp[0x40]
8000820a:	59 f8       	cp.w	r8,31
8000820c:	e0 89 00 13 	brgt	80008232 <_vfprintf_r+0x686>
80008210:	f2 cb ff fc 	sub	r11,r9,-4
80008214:	51 0b       	stdsp	sp[0x40],r11
80008216:	72 09       	ld.w	r9,r9[0x0]
80008218:	fa c6 f9 44 	sub	r6,sp,-1724
8000821c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008220:	2f f8       	sub	r8,-1
80008222:	f7 49 fd 88 	st.w	r11[-632],r9
80008226:	fb 48 06 b4 	st.w	sp[1716],r8
8000822a:	14 97       	mov	r7,r10
8000822c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008230:	c0 58       	rjmp	8000823a <_vfprintf_r+0x68e>
80008232:	92 18       	ld.sh	r8,r9[0x2]
80008234:	14 97       	mov	r7,r10
80008236:	2f c9       	sub	r9,-4
80008238:	51 09       	stdsp	sp[0x40],r9
8000823a:	50 18       	stdsp	sp[0x4],r8
8000823c:	bf 58       	asr	r8,0x1f
8000823e:	50 08       	stdsp	sp[0x0],r8
80008240:	c4 88       	rjmp	800082d0 <_vfprintf_r+0x724>
80008242:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008246:	40 3c       	lddsp	r12,sp[0xc]
80008248:	58 0c       	cp.w	r12,0
8000824a:	c1 d0       	breq	80008284 <_vfprintf_r+0x6d8>
8000824c:	10 36       	cp.w	r6,r8
8000824e:	c0 64       	brge	8000825a <_vfprintf_r+0x6ae>
80008250:	fa cb f9 44 	sub	r11,sp,-1724
80008254:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008258:	c1 f8       	rjmp	80008296 <_vfprintf_r+0x6ea>
8000825a:	fa c8 f9 50 	sub	r8,sp,-1712
8000825e:	1a d8       	st.w	--sp,r8
80008260:	fa c8 fa b8 	sub	r8,sp,-1352
80008264:	0c 9b       	mov	r11,r6
80008266:	1a d8       	st.w	--sp,r8
80008268:	fa c8 fb b4 	sub	r8,sp,-1100
8000826c:	04 9a       	mov	r10,r2
8000826e:	1a d8       	st.w	--sp,r8
80008270:	08 9c       	mov	r12,r4
80008272:	fa c8 f9 40 	sub	r8,sp,-1728
80008276:	fa c9 ff b4 	sub	r9,sp,-76
8000827a:	fe b0 fb 01 	rcall	8000787c <get_arg>
8000827e:	2f dd       	sub	sp,-12
80008280:	78 0b       	ld.w	r11,r12[0x0]
80008282:	c2 48       	rjmp	800082ca <_vfprintf_r+0x71e>
80008284:	ee ca ff ff 	sub	r10,r7,-1
80008288:	10 37       	cp.w	r7,r8
8000828a:	c0 94       	brge	8000829c <_vfprintf_r+0x6f0>
8000828c:	fa c9 f9 44 	sub	r9,sp,-1724
80008290:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008294:	14 97       	mov	r7,r10
80008296:	ec fb fd 88 	ld.w	r11,r6[-632]
8000829a:	c1 88       	rjmp	800082ca <_vfprintf_r+0x71e>
8000829c:	41 09       	lddsp	r9,sp[0x40]
8000829e:	59 f8       	cp.w	r8,31
800082a0:	e0 89 00 11 	brgt	800082c2 <_vfprintf_r+0x716>
800082a4:	f2 cb ff fc 	sub	r11,r9,-4
800082a8:	51 0b       	stdsp	sp[0x40],r11
800082aa:	fa c6 f9 44 	sub	r6,sp,-1724
800082ae:	72 0b       	ld.w	r11,r9[0x0]
800082b0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082b4:	f3 4b fd 88 	st.w	r9[-632],r11
800082b8:	2f f8       	sub	r8,-1
800082ba:	14 97       	mov	r7,r10
800082bc:	fb 48 06 b4 	st.w	sp[1716],r8
800082c0:	c0 58       	rjmp	800082ca <_vfprintf_r+0x71e>
800082c2:	72 0b       	ld.w	r11,r9[0x0]
800082c4:	14 97       	mov	r7,r10
800082c6:	2f c9       	sub	r9,-4
800082c8:	51 09       	stdsp	sp[0x40],r9
800082ca:	50 1b       	stdsp	sp[0x4],r11
800082cc:	bf 5b       	asr	r11,0x1f
800082ce:	50 0b       	stdsp	sp[0x0],r11
800082d0:	fa ea 00 00 	ld.d	r10,sp[0]
800082d4:	58 0a       	cp.w	r10,0
800082d6:	5c 2b       	cpc	r11
800082d8:	c0 e4       	brge	800082f4 <_vfprintf_r+0x748>
800082da:	30 08       	mov	r8,0
800082dc:	fa ea 00 00 	ld.d	r10,sp[0]
800082e0:	30 09       	mov	r9,0
800082e2:	f0 0a 01 0a 	sub	r10,r8,r10
800082e6:	f2 0b 01 4b 	sbc	r11,r9,r11
800082ea:	32 d8       	mov	r8,45
800082ec:	fa eb 00 00 	st.d	sp[0],r10
800082f0:	fb 68 06 bb 	st.b	sp[1723],r8
800082f4:	30 18       	mov	r8,1
800082f6:	e0 8f 06 fa 	bral	800090ea <_vfprintf_r+0x153e>
800082fa:	50 a7       	stdsp	sp[0x28],r7
800082fc:	50 80       	stdsp	sp[0x20],r0
800082fe:	0c 97       	mov	r7,r6
80008300:	04 94       	mov	r4,r2
80008302:	06 96       	mov	r6,r3
80008304:	02 92       	mov	r2,r1
80008306:	40 93       	lddsp	r3,sp[0x24]
80008308:	10 90       	mov	r0,r8
8000830a:	40 41       	lddsp	r1,sp[0x10]
8000830c:	0e 99       	mov	r9,r7
8000830e:	ed b5 00 03 	bld	r5,0x3
80008312:	c4 11       	brne	80008394 <_vfprintf_r+0x7e8>
80008314:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008318:	40 3a       	lddsp	r10,sp[0xc]
8000831a:	58 0a       	cp.w	r10,0
8000831c:	c1 90       	breq	8000834e <_vfprintf_r+0x7a2>
8000831e:	10 36       	cp.w	r6,r8
80008320:	c6 45       	brlt	800083e8 <_vfprintf_r+0x83c>
80008322:	fa c8 f9 50 	sub	r8,sp,-1712
80008326:	1a d8       	st.w	--sp,r8
80008328:	fa c8 fa b8 	sub	r8,sp,-1352
8000832c:	1a d8       	st.w	--sp,r8
8000832e:	fa c8 fb b4 	sub	r8,sp,-1100
80008332:	0c 9b       	mov	r11,r6
80008334:	1a d8       	st.w	--sp,r8
80008336:	04 9a       	mov	r10,r2
80008338:	fa c8 f9 40 	sub	r8,sp,-1728
8000833c:	fa c9 ff b4 	sub	r9,sp,-76
80008340:	08 9c       	mov	r12,r4
80008342:	fe b0 fa 9d 	rcall	8000787c <get_arg>
80008346:	2f dd       	sub	sp,-12
80008348:	78 16       	ld.w	r6,r12[0x4]
8000834a:	50 76       	stdsp	sp[0x1c],r6
8000834c:	c4 88       	rjmp	800083dc <_vfprintf_r+0x830>
8000834e:	2f f7       	sub	r7,-1
80008350:	10 39       	cp.w	r9,r8
80008352:	c0 c4       	brge	8000836a <_vfprintf_r+0x7be>
80008354:	fa ce f9 44 	sub	lr,sp,-1724
80008358:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000835c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008360:	50 7c       	stdsp	sp[0x1c],r12
80008362:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008366:	50 56       	stdsp	sp[0x14],r6
80008368:	c6 68       	rjmp	80008434 <_vfprintf_r+0x888>
8000836a:	41 09       	lddsp	r9,sp[0x40]
8000836c:	59 f8       	cp.w	r8,31
8000836e:	e0 89 00 10 	brgt	8000838e <_vfprintf_r+0x7e2>
80008372:	f2 ca ff f8 	sub	r10,r9,-8
80008376:	72 1b       	ld.w	r11,r9[0x4]
80008378:	51 0a       	stdsp	sp[0x40],r10
8000837a:	72 09       	ld.w	r9,r9[0x0]
8000837c:	fa ca f9 44 	sub	r10,sp,-1724
80008380:	50 7b       	stdsp	sp[0x1c],r11
80008382:	50 59       	stdsp	sp[0x14],r9
80008384:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008388:	40 5b       	lddsp	r11,sp[0x14]
8000838a:	40 7a       	lddsp	r10,sp[0x1c]
8000838c:	c4 78       	rjmp	8000841a <_vfprintf_r+0x86e>
8000838e:	72 18       	ld.w	r8,r9[0x4]
80008390:	50 78       	stdsp	sp[0x1c],r8
80008392:	c4 c8       	rjmp	8000842a <_vfprintf_r+0x87e>
80008394:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008398:	40 3e       	lddsp	lr,sp[0xc]
8000839a:	58 0e       	cp.w	lr,0
8000839c:	c2 30       	breq	800083e2 <_vfprintf_r+0x836>
8000839e:	10 36       	cp.w	r6,r8
800083a0:	c0 94       	brge	800083b2 <_vfprintf_r+0x806>
800083a2:	fa cc f9 44 	sub	r12,sp,-1724
800083a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800083aa:	ec fb fd 8c 	ld.w	r11,r6[-628]
800083ae:	50 7b       	stdsp	sp[0x1c],r11
800083b0:	cd 9b       	rjmp	80008362 <_vfprintf_r+0x7b6>
800083b2:	fa c8 f9 50 	sub	r8,sp,-1712
800083b6:	1a d8       	st.w	--sp,r8
800083b8:	fa c8 fa b8 	sub	r8,sp,-1352
800083bc:	04 9a       	mov	r10,r2
800083be:	1a d8       	st.w	--sp,r8
800083c0:	fa c8 fb b4 	sub	r8,sp,-1100
800083c4:	0c 9b       	mov	r11,r6
800083c6:	1a d8       	st.w	--sp,r8
800083c8:	08 9c       	mov	r12,r4
800083ca:	fa c8 f9 40 	sub	r8,sp,-1728
800083ce:	fa c9 ff b4 	sub	r9,sp,-76
800083d2:	fe b0 fa 55 	rcall	8000787c <get_arg>
800083d6:	2f dd       	sub	sp,-12
800083d8:	78 1a       	ld.w	r10,r12[0x4]
800083da:	50 7a       	stdsp	sp[0x1c],r10
800083dc:	78 0c       	ld.w	r12,r12[0x0]
800083de:	50 5c       	stdsp	sp[0x14],r12
800083e0:	c2 a8       	rjmp	80008434 <_vfprintf_r+0x888>
800083e2:	2f f7       	sub	r7,-1
800083e4:	10 39       	cp.w	r9,r8
800083e6:	c0 94       	brge	800083f8 <_vfprintf_r+0x84c>
800083e8:	fa c9 f9 44 	sub	r9,sp,-1724
800083ec:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083f0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800083f4:	50 78       	stdsp	sp[0x1c],r8
800083f6:	cb 6b       	rjmp	80008362 <_vfprintf_r+0x7b6>
800083f8:	41 09       	lddsp	r9,sp[0x40]
800083fa:	59 f8       	cp.w	r8,31
800083fc:	e0 89 00 15 	brgt	80008426 <_vfprintf_r+0x87a>
80008400:	f2 ca ff f8 	sub	r10,r9,-8
80008404:	72 16       	ld.w	r6,r9[0x4]
80008406:	72 09       	ld.w	r9,r9[0x0]
80008408:	51 0a       	stdsp	sp[0x40],r10
8000840a:	50 59       	stdsp	sp[0x14],r9
8000840c:	fa ce f9 44 	sub	lr,sp,-1724
80008410:	50 76       	stdsp	sp[0x1c],r6
80008412:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008416:	40 5b       	lddsp	r11,sp[0x14]
80008418:	0c 9a       	mov	r10,r6
8000841a:	f2 eb fd 88 	st.d	r9[-632],r10
8000841e:	2f f8       	sub	r8,-1
80008420:	fb 48 06 b4 	st.w	sp[1716],r8
80008424:	c0 88       	rjmp	80008434 <_vfprintf_r+0x888>
80008426:	72 1c       	ld.w	r12,r9[0x4]
80008428:	50 7c       	stdsp	sp[0x1c],r12
8000842a:	f2 c8 ff f8 	sub	r8,r9,-8
8000842e:	51 08       	stdsp	sp[0x40],r8
80008430:	72 09       	ld.w	r9,r9[0x0]
80008432:	50 59       	stdsp	sp[0x14],r9
80008434:	40 5b       	lddsp	r11,sp[0x14]
80008436:	40 7a       	lddsp	r10,sp[0x1c]
80008438:	e0 a0 19 54 	rcall	8000b6e0 <__isinfd>
8000843c:	18 96       	mov	r6,r12
8000843e:	c1 70       	breq	8000846c <_vfprintf_r+0x8c0>
80008440:	30 08       	mov	r8,0
80008442:	30 09       	mov	r9,0
80008444:	40 5b       	lddsp	r11,sp[0x14]
80008446:	40 7a       	lddsp	r10,sp[0x1c]
80008448:	e0 a0 1d b4 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000844c:	c0 40       	breq	80008454 <_vfprintf_r+0x8a8>
8000844e:	32 d8       	mov	r8,45
80008450:	fb 68 06 bb 	st.b	sp[1723],r8
80008454:	fe c8 ab 78 	sub	r8,pc,-21640
80008458:	fe c6 ab 78 	sub	r6,pc,-21640
8000845c:	a7 d5       	cbr	r5,0x7
8000845e:	e0 40 00 47 	cp.w	r0,71
80008462:	f0 06 17 a0 	movle	r6,r8
80008466:	30 32       	mov	r2,3
80008468:	e0 8f 06 ce 	bral	80009204 <_vfprintf_r+0x1658>
8000846c:	40 5b       	lddsp	r11,sp[0x14]
8000846e:	40 7a       	lddsp	r10,sp[0x1c]
80008470:	e0 a0 19 4d 	rcall	8000b70a <__isnand>
80008474:	c0 e0       	breq	80008490 <_vfprintf_r+0x8e4>
80008476:	50 26       	stdsp	sp[0x8],r6
80008478:	fe c8 ab 94 	sub	r8,pc,-21612
8000847c:	fe c6 ab 94 	sub	r6,pc,-21612
80008480:	a7 d5       	cbr	r5,0x7
80008482:	e0 40 00 47 	cp.w	r0,71
80008486:	f0 06 17 a0 	movle	r6,r8
8000848a:	30 32       	mov	r2,3
8000848c:	e0 8f 06 c2 	bral	80009210 <_vfprintf_r+0x1664>
80008490:	40 2a       	lddsp	r10,sp[0x8]
80008492:	5b fa       	cp.w	r10,-1
80008494:	c0 41       	brne	8000849c <_vfprintf_r+0x8f0>
80008496:	30 69       	mov	r9,6
80008498:	50 29       	stdsp	sp[0x8],r9
8000849a:	c1 18       	rjmp	800084bc <_vfprintf_r+0x910>
8000849c:	e0 40 00 47 	cp.w	r0,71
800084a0:	5f 09       	sreq	r9
800084a2:	e0 40 00 67 	cp.w	r0,103
800084a6:	5f 08       	sreq	r8
800084a8:	f3 e8 10 08 	or	r8,r9,r8
800084ac:	f8 08 18 00 	cp.b	r8,r12
800084b0:	c0 60       	breq	800084bc <_vfprintf_r+0x910>
800084b2:	40 28       	lddsp	r8,sp[0x8]
800084b4:	58 08       	cp.w	r8,0
800084b6:	f9 b8 00 01 	moveq	r8,1
800084ba:	50 28       	stdsp	sp[0x8],r8
800084bc:	40 78       	lddsp	r8,sp[0x1c]
800084be:	40 59       	lddsp	r9,sp[0x14]
800084c0:	fa e9 06 94 	st.d	sp[1684],r8
800084c4:	a9 a5       	sbr	r5,0x8
800084c6:	fa f8 06 94 	ld.w	r8,sp[1684]
800084ca:	58 08       	cp.w	r8,0
800084cc:	c0 65       	brlt	800084d8 <_vfprintf_r+0x92c>
800084ce:	40 5e       	lddsp	lr,sp[0x14]
800084d0:	30 0c       	mov	r12,0
800084d2:	50 6e       	stdsp	sp[0x18],lr
800084d4:	50 9c       	stdsp	sp[0x24],r12
800084d6:	c0 78       	rjmp	800084e4 <_vfprintf_r+0x938>
800084d8:	40 5b       	lddsp	r11,sp[0x14]
800084da:	32 da       	mov	r10,45
800084dc:	ee 1b 80 00 	eorh	r11,0x8000
800084e0:	50 9a       	stdsp	sp[0x24],r10
800084e2:	50 6b       	stdsp	sp[0x18],r11
800084e4:	e0 40 00 46 	cp.w	r0,70
800084e8:	5f 09       	sreq	r9
800084ea:	e0 40 00 66 	cp.w	r0,102
800084ee:	5f 08       	sreq	r8
800084f0:	f3 e8 10 08 	or	r8,r9,r8
800084f4:	50 48       	stdsp	sp[0x10],r8
800084f6:	c0 40       	breq	800084fe <_vfprintf_r+0x952>
800084f8:	40 22       	lddsp	r2,sp[0x8]
800084fa:	30 39       	mov	r9,3
800084fc:	c1 08       	rjmp	8000851c <_vfprintf_r+0x970>
800084fe:	e0 40 00 45 	cp.w	r0,69
80008502:	5f 09       	sreq	r9
80008504:	e0 40 00 65 	cp.w	r0,101
80008508:	5f 08       	sreq	r8
8000850a:	40 22       	lddsp	r2,sp[0x8]
8000850c:	10 49       	or	r9,r8
8000850e:	2f f2       	sub	r2,-1
80008510:	40 46       	lddsp	r6,sp[0x10]
80008512:	ec 09 18 00 	cp.b	r9,r6
80008516:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000851a:	30 29       	mov	r9,2
8000851c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008520:	1a d8       	st.w	--sp,r8
80008522:	fa c8 f9 54 	sub	r8,sp,-1708
80008526:	1a d8       	st.w	--sp,r8
80008528:	fa c8 f9 4c 	sub	r8,sp,-1716
8000852c:	08 9c       	mov	r12,r4
8000852e:	1a d8       	st.w	--sp,r8
80008530:	04 98       	mov	r8,r2
80008532:	40 9b       	lddsp	r11,sp[0x24]
80008534:	40 aa       	lddsp	r10,sp[0x28]
80008536:	e0 a0 0b c3 	rcall	80009cbc <_dtoa_r>
8000853a:	e0 40 00 47 	cp.w	r0,71
8000853e:	5f 19       	srne	r9
80008540:	e0 40 00 67 	cp.w	r0,103
80008544:	5f 18       	srne	r8
80008546:	18 96       	mov	r6,r12
80008548:	2f dd       	sub	sp,-12
8000854a:	f3 e8 00 08 	and	r8,r9,r8
8000854e:	c0 41       	brne	80008556 <_vfprintf_r+0x9aa>
80008550:	ed b5 00 00 	bld	r5,0x0
80008554:	c3 01       	brne	800085b4 <_vfprintf_r+0xa08>
80008556:	ec 02 00 0e 	add	lr,r6,r2
8000855a:	50 3e       	stdsp	sp[0xc],lr
8000855c:	40 4c       	lddsp	r12,sp[0x10]
8000855e:	58 0c       	cp.w	r12,0
80008560:	c1 50       	breq	8000858a <_vfprintf_r+0x9de>
80008562:	0d 89       	ld.ub	r9,r6[0x0]
80008564:	33 08       	mov	r8,48
80008566:	f0 09 18 00 	cp.b	r9,r8
8000856a:	c0 b1       	brne	80008580 <_vfprintf_r+0x9d4>
8000856c:	30 08       	mov	r8,0
8000856e:	30 09       	mov	r9,0
80008570:	40 6b       	lddsp	r11,sp[0x18]
80008572:	40 7a       	lddsp	r10,sp[0x1c]
80008574:	e0 a0 1c d7 	rcall	8000bf22 <__avr32_f64_cmp_eq>
80008578:	fb b2 00 01 	rsubeq	r2,1
8000857c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008580:	40 3b       	lddsp	r11,sp[0xc]
80008582:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008586:	10 0b       	add	r11,r8
80008588:	50 3b       	stdsp	sp[0xc],r11
8000858a:	40 6b       	lddsp	r11,sp[0x18]
8000858c:	30 08       	mov	r8,0
8000858e:	30 09       	mov	r9,0
80008590:	40 7a       	lddsp	r10,sp[0x1c]
80008592:	e0 a0 1c c8 	rcall	8000bf22 <__avr32_f64_cmp_eq>
80008596:	c0 90       	breq	800085a8 <_vfprintf_r+0x9fc>
80008598:	40 3a       	lddsp	r10,sp[0xc]
8000859a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000859e:	c0 58       	rjmp	800085a8 <_vfprintf_r+0x9fc>
800085a0:	10 c9       	st.b	r8++,r9
800085a2:	fb 48 06 a4 	st.w	sp[1700],r8
800085a6:	c0 28       	rjmp	800085aa <_vfprintf_r+0x9fe>
800085a8:	33 09       	mov	r9,48
800085aa:	fa f8 06 a4 	ld.w	r8,sp[1700]
800085ae:	40 3e       	lddsp	lr,sp[0xc]
800085b0:	1c 38       	cp.w	r8,lr
800085b2:	cf 73       	brcs	800085a0 <_vfprintf_r+0x9f4>
800085b4:	e0 40 00 47 	cp.w	r0,71
800085b8:	5f 09       	sreq	r9
800085ba:	e0 40 00 67 	cp.w	r0,103
800085be:	5f 08       	sreq	r8
800085c0:	f3 e8 10 08 	or	r8,r9,r8
800085c4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800085c8:	0c 19       	sub	r9,r6
800085ca:	50 69       	stdsp	sp[0x18],r9
800085cc:	58 08       	cp.w	r8,0
800085ce:	c0 b0       	breq	800085e4 <_vfprintf_r+0xa38>
800085d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800085d4:	5b d8       	cp.w	r8,-3
800085d6:	c0 55       	brlt	800085e0 <_vfprintf_r+0xa34>
800085d8:	40 2c       	lddsp	r12,sp[0x8]
800085da:	18 38       	cp.w	r8,r12
800085dc:	e0 8a 00 6a 	brle	800086b0 <_vfprintf_r+0xb04>
800085e0:	20 20       	sub	r0,2
800085e2:	c0 58       	rjmp	800085ec <_vfprintf_r+0xa40>
800085e4:	e0 40 00 65 	cp.w	r0,101
800085e8:	e0 89 00 46 	brgt	80008674 <_vfprintf_r+0xac8>
800085ec:	fa fb 06 ac 	ld.w	r11,sp[1708]
800085f0:	fb 60 06 9c 	st.b	sp[1692],r0
800085f4:	20 1b       	sub	r11,1
800085f6:	fb 4b 06 ac 	st.w	sp[1708],r11
800085fa:	c0 47       	brpl	80008602 <_vfprintf_r+0xa56>
800085fc:	5c 3b       	neg	r11
800085fe:	32 d8       	mov	r8,45
80008600:	c0 28       	rjmp	80008604 <_vfprintf_r+0xa58>
80008602:	32 b8       	mov	r8,43
80008604:	fb 68 06 9d 	st.b	sp[1693],r8
80008608:	58 9b       	cp.w	r11,9
8000860a:	e0 8a 00 1d 	brle	80008644 <_vfprintf_r+0xa98>
8000860e:	fa c9 fa 35 	sub	r9,sp,-1483
80008612:	30 aa       	mov	r10,10
80008614:	12 98       	mov	r8,r9
80008616:	0e 9c       	mov	r12,r7
80008618:	0c 92       	mov	r2,r6
8000861a:	f6 0a 0c 06 	divs	r6,r11,r10
8000861e:	0e 9b       	mov	r11,r7
80008620:	2d 0b       	sub	r11,-48
80008622:	10 fb       	st.b	--r8,r11
80008624:	0c 9b       	mov	r11,r6
80008626:	58 96       	cp.w	r6,9
80008628:	fe 99 ff f9 	brgt	8000861a <_vfprintf_r+0xa6e>
8000862c:	2d 0b       	sub	r11,-48
8000862e:	18 97       	mov	r7,r12
80008630:	04 96       	mov	r6,r2
80008632:	10 fb       	st.b	--r8,r11
80008634:	fa ca f9 62 	sub	r10,sp,-1694
80008638:	c0 38       	rjmp	8000863e <_vfprintf_r+0xa92>
8000863a:	11 3b       	ld.ub	r11,r8++
8000863c:	14 cb       	st.b	r10++,r11
8000863e:	12 38       	cp.w	r8,r9
80008640:	cf d3       	brcs	8000863a <_vfprintf_r+0xa8e>
80008642:	c0 98       	rjmp	80008654 <_vfprintf_r+0xaa8>
80008644:	2d 0b       	sub	r11,-48
80008646:	33 08       	mov	r8,48
80008648:	fb 6b 06 9f 	st.b	sp[1695],r11
8000864c:	fb 68 06 9e 	st.b	sp[1694],r8
80008650:	fa ca f9 60 	sub	r10,sp,-1696
80008654:	fa c8 f9 64 	sub	r8,sp,-1692
80008658:	f4 08 01 08 	sub	r8,r10,r8
8000865c:	50 e8       	stdsp	sp[0x38],r8
8000865e:	10 92       	mov	r2,r8
80008660:	40 6b       	lddsp	r11,sp[0x18]
80008662:	16 02       	add	r2,r11
80008664:	58 1b       	cp.w	r11,1
80008666:	e0 89 00 05 	brgt	80008670 <_vfprintf_r+0xac4>
8000866a:	ed b5 00 00 	bld	r5,0x0
8000866e:	c3 51       	brne	800086d8 <_vfprintf_r+0xb2c>
80008670:	2f f2       	sub	r2,-1
80008672:	c3 38       	rjmp	800086d8 <_vfprintf_r+0xb2c>
80008674:	e0 40 00 66 	cp.w	r0,102
80008678:	c1 c1       	brne	800086b0 <_vfprintf_r+0xb04>
8000867a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000867e:	58 02       	cp.w	r2,0
80008680:	e0 8a 00 0c 	brle	80008698 <_vfprintf_r+0xaec>
80008684:	40 2a       	lddsp	r10,sp[0x8]
80008686:	58 0a       	cp.w	r10,0
80008688:	c0 41       	brne	80008690 <_vfprintf_r+0xae4>
8000868a:	ed b5 00 00 	bld	r5,0x0
8000868e:	c2 51       	brne	800086d8 <_vfprintf_r+0xb2c>
80008690:	2f f2       	sub	r2,-1
80008692:	40 29       	lddsp	r9,sp[0x8]
80008694:	12 02       	add	r2,r9
80008696:	c0 b8       	rjmp	800086ac <_vfprintf_r+0xb00>
80008698:	40 28       	lddsp	r8,sp[0x8]
8000869a:	58 08       	cp.w	r8,0
8000869c:	c0 61       	brne	800086a8 <_vfprintf_r+0xafc>
8000869e:	ed b5 00 00 	bld	r5,0x0
800086a2:	c0 30       	breq	800086a8 <_vfprintf_r+0xafc>
800086a4:	30 12       	mov	r2,1
800086a6:	c1 98       	rjmp	800086d8 <_vfprintf_r+0xb2c>
800086a8:	40 22       	lddsp	r2,sp[0x8]
800086aa:	2f e2       	sub	r2,-2
800086ac:	36 60       	mov	r0,102
800086ae:	c1 58       	rjmp	800086d8 <_vfprintf_r+0xb2c>
800086b0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800086b4:	40 6e       	lddsp	lr,sp[0x18]
800086b6:	1c 32       	cp.w	r2,lr
800086b8:	c0 65       	brlt	800086c4 <_vfprintf_r+0xb18>
800086ba:	ed b5 00 00 	bld	r5,0x0
800086be:	f7 b2 00 ff 	subeq	r2,-1
800086c2:	c0 a8       	rjmp	800086d6 <_vfprintf_r+0xb2a>
800086c4:	e4 08 11 02 	rsub	r8,r2,2
800086c8:	40 6c       	lddsp	r12,sp[0x18]
800086ca:	58 02       	cp.w	r2,0
800086cc:	f0 02 17 a0 	movle	r2,r8
800086d0:	f9 b2 09 01 	movgt	r2,1
800086d4:	18 02       	add	r2,r12
800086d6:	36 70       	mov	r0,103
800086d8:	40 9b       	lddsp	r11,sp[0x24]
800086da:	58 0b       	cp.w	r11,0
800086dc:	e0 80 05 94 	breq	80009204 <_vfprintf_r+0x1658>
800086e0:	32 d8       	mov	r8,45
800086e2:	fb 68 06 bb 	st.b	sp[1723],r8
800086e6:	e0 8f 05 93 	bral	8000920c <_vfprintf_r+0x1660>
800086ea:	50 a7       	stdsp	sp[0x28],r7
800086ec:	04 94       	mov	r4,r2
800086ee:	0c 97       	mov	r7,r6
800086f0:	02 92       	mov	r2,r1
800086f2:	06 96       	mov	r6,r3
800086f4:	40 41       	lddsp	r1,sp[0x10]
800086f6:	40 93       	lddsp	r3,sp[0x24]
800086f8:	0e 99       	mov	r9,r7
800086fa:	ed b5 00 05 	bld	r5,0x5
800086fe:	c4 81       	brne	8000878e <_vfprintf_r+0xbe2>
80008700:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008704:	40 3e       	lddsp	lr,sp[0xc]
80008706:	58 0e       	cp.w	lr,0
80008708:	c1 d0       	breq	80008742 <_vfprintf_r+0xb96>
8000870a:	10 36       	cp.w	r6,r8
8000870c:	c0 64       	brge	80008718 <_vfprintf_r+0xb6c>
8000870e:	fa cc f9 44 	sub	r12,sp,-1724
80008712:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008716:	c1 d8       	rjmp	80008750 <_vfprintf_r+0xba4>
80008718:	fa c8 f9 50 	sub	r8,sp,-1712
8000871c:	1a d8       	st.w	--sp,r8
8000871e:	fa c8 fa b8 	sub	r8,sp,-1352
80008722:	04 9a       	mov	r10,r2
80008724:	1a d8       	st.w	--sp,r8
80008726:	fa c8 fb b4 	sub	r8,sp,-1100
8000872a:	0c 9b       	mov	r11,r6
8000872c:	1a d8       	st.w	--sp,r8
8000872e:	08 9c       	mov	r12,r4
80008730:	fa c8 f9 40 	sub	r8,sp,-1728
80008734:	fa c9 ff b4 	sub	r9,sp,-76
80008738:	fe b0 f8 a2 	rcall	8000787c <get_arg>
8000873c:	2f dd       	sub	sp,-12
8000873e:	78 0a       	ld.w	r10,r12[0x0]
80008740:	c2 08       	rjmp	80008780 <_vfprintf_r+0xbd4>
80008742:	2f f7       	sub	r7,-1
80008744:	10 39       	cp.w	r9,r8
80008746:	c0 84       	brge	80008756 <_vfprintf_r+0xbaa>
80008748:	fa cb f9 44 	sub	r11,sp,-1724
8000874c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008750:	ec fa fd 88 	ld.w	r10,r6[-632]
80008754:	c1 68       	rjmp	80008780 <_vfprintf_r+0xbd4>
80008756:	41 09       	lddsp	r9,sp[0x40]
80008758:	59 f8       	cp.w	r8,31
8000875a:	e0 89 00 10 	brgt	8000877a <_vfprintf_r+0xbce>
8000875e:	f2 ca ff fc 	sub	r10,r9,-4
80008762:	51 0a       	stdsp	sp[0x40],r10
80008764:	fa c6 f9 44 	sub	r6,sp,-1724
80008768:	72 0a       	ld.w	r10,r9[0x0]
8000876a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000876e:	f3 4a fd 88 	st.w	r9[-632],r10
80008772:	2f f8       	sub	r8,-1
80008774:	fb 48 06 b4 	st.w	sp[1716],r8
80008778:	c0 48       	rjmp	80008780 <_vfprintf_r+0xbd4>
8000877a:	72 0a       	ld.w	r10,r9[0x0]
8000877c:	2f c9       	sub	r9,-4
8000877e:	51 09       	stdsp	sp[0x40],r9
80008780:	40 be       	lddsp	lr,sp[0x2c]
80008782:	1c 98       	mov	r8,lr
80008784:	95 1e       	st.w	r10[0x4],lr
80008786:	bf 58       	asr	r8,0x1f
80008788:	95 08       	st.w	r10[0x0],r8
8000878a:	fe 9f fa 9f 	bral	80007cc8 <_vfprintf_r+0x11c>
8000878e:	ed b5 00 04 	bld	r5,0x4
80008792:	c4 80       	breq	80008822 <_vfprintf_r+0xc76>
80008794:	e2 15 00 40 	andl	r5,0x40,COH
80008798:	c4 50       	breq	80008822 <_vfprintf_r+0xc76>
8000879a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879e:	40 3c       	lddsp	r12,sp[0xc]
800087a0:	58 0c       	cp.w	r12,0
800087a2:	c1 d0       	breq	800087dc <_vfprintf_r+0xc30>
800087a4:	10 36       	cp.w	r6,r8
800087a6:	c0 64       	brge	800087b2 <_vfprintf_r+0xc06>
800087a8:	fa cb f9 44 	sub	r11,sp,-1724
800087ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087b0:	c1 d8       	rjmp	800087ea <_vfprintf_r+0xc3e>
800087b2:	fa c8 f9 50 	sub	r8,sp,-1712
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fa b8 	sub	r8,sp,-1352
800087bc:	04 9a       	mov	r10,r2
800087be:	1a d8       	st.w	--sp,r8
800087c0:	fa c8 fb b4 	sub	r8,sp,-1100
800087c4:	0c 9b       	mov	r11,r6
800087c6:	1a d8       	st.w	--sp,r8
800087c8:	08 9c       	mov	r12,r4
800087ca:	fa c8 f9 40 	sub	r8,sp,-1728
800087ce:	fa c9 ff b4 	sub	r9,sp,-76
800087d2:	fe b0 f8 55 	rcall	8000787c <get_arg>
800087d6:	2f dd       	sub	sp,-12
800087d8:	78 0a       	ld.w	r10,r12[0x0]
800087da:	c2 08       	rjmp	8000881a <_vfprintf_r+0xc6e>
800087dc:	2f f7       	sub	r7,-1
800087de:	10 39       	cp.w	r9,r8
800087e0:	c0 84       	brge	800087f0 <_vfprintf_r+0xc44>
800087e2:	fa ca f9 44 	sub	r10,sp,-1724
800087e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087ea:	ec fa fd 88 	ld.w	r10,r6[-632]
800087ee:	c1 68       	rjmp	8000881a <_vfprintf_r+0xc6e>
800087f0:	41 09       	lddsp	r9,sp[0x40]
800087f2:	59 f8       	cp.w	r8,31
800087f4:	e0 89 00 10 	brgt	80008814 <_vfprintf_r+0xc68>
800087f8:	f2 ca ff fc 	sub	r10,r9,-4
800087fc:	51 0a       	stdsp	sp[0x40],r10
800087fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008802:	72 0a       	ld.w	r10,r9[0x0]
80008804:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008808:	f3 4a fd 88 	st.w	r9[-632],r10
8000880c:	2f f8       	sub	r8,-1
8000880e:	fb 48 06 b4 	st.w	sp[1716],r8
80008812:	c0 48       	rjmp	8000881a <_vfprintf_r+0xc6e>
80008814:	72 0a       	ld.w	r10,r9[0x0]
80008816:	2f c9       	sub	r9,-4
80008818:	51 09       	stdsp	sp[0x40],r9
8000881a:	40 be       	lddsp	lr,sp[0x2c]
8000881c:	b4 0e       	st.h	r10[0x0],lr
8000881e:	fe 9f fa 55 	bral	80007cc8 <_vfprintf_r+0x11c>
80008822:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008826:	40 3c       	lddsp	r12,sp[0xc]
80008828:	58 0c       	cp.w	r12,0
8000882a:	c1 d0       	breq	80008864 <_vfprintf_r+0xcb8>
8000882c:	10 36       	cp.w	r6,r8
8000882e:	c0 64       	brge	8000883a <_vfprintf_r+0xc8e>
80008830:	fa cb f9 44 	sub	r11,sp,-1724
80008834:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008838:	c1 d8       	rjmp	80008872 <_vfprintf_r+0xcc6>
8000883a:	fa c8 f9 50 	sub	r8,sp,-1712
8000883e:	1a d8       	st.w	--sp,r8
80008840:	fa c8 fa b8 	sub	r8,sp,-1352
80008844:	04 9a       	mov	r10,r2
80008846:	1a d8       	st.w	--sp,r8
80008848:	fa c8 fb b4 	sub	r8,sp,-1100
8000884c:	0c 9b       	mov	r11,r6
8000884e:	1a d8       	st.w	--sp,r8
80008850:	08 9c       	mov	r12,r4
80008852:	fa c8 f9 40 	sub	r8,sp,-1728
80008856:	fa c9 ff b4 	sub	r9,sp,-76
8000885a:	fe b0 f8 11 	rcall	8000787c <get_arg>
8000885e:	2f dd       	sub	sp,-12
80008860:	78 0a       	ld.w	r10,r12[0x0]
80008862:	c2 08       	rjmp	800088a2 <_vfprintf_r+0xcf6>
80008864:	2f f7       	sub	r7,-1
80008866:	10 39       	cp.w	r9,r8
80008868:	c0 84       	brge	80008878 <_vfprintf_r+0xccc>
8000886a:	fa ca f9 44 	sub	r10,sp,-1724
8000886e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008872:	ec fa fd 88 	ld.w	r10,r6[-632]
80008876:	c1 68       	rjmp	800088a2 <_vfprintf_r+0xcf6>
80008878:	41 09       	lddsp	r9,sp[0x40]
8000887a:	59 f8       	cp.w	r8,31
8000887c:	e0 89 00 10 	brgt	8000889c <_vfprintf_r+0xcf0>
80008880:	f2 ca ff fc 	sub	r10,r9,-4
80008884:	51 0a       	stdsp	sp[0x40],r10
80008886:	fa c6 f9 44 	sub	r6,sp,-1724
8000888a:	72 0a       	ld.w	r10,r9[0x0]
8000888c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008890:	f3 4a fd 88 	st.w	r9[-632],r10
80008894:	2f f8       	sub	r8,-1
80008896:	fb 48 06 b4 	st.w	sp[1716],r8
8000889a:	c0 48       	rjmp	800088a2 <_vfprintf_r+0xcf6>
8000889c:	72 0a       	ld.w	r10,r9[0x0]
8000889e:	2f c9       	sub	r9,-4
800088a0:	51 09       	stdsp	sp[0x40],r9
800088a2:	40 be       	lddsp	lr,sp[0x2c]
800088a4:	95 0e       	st.w	r10[0x0],lr
800088a6:	fe 9f fa 11 	bral	80007cc8 <_vfprintf_r+0x11c>
800088aa:	50 a7       	stdsp	sp[0x28],r7
800088ac:	50 80       	stdsp	sp[0x20],r0
800088ae:	0c 97       	mov	r7,r6
800088b0:	04 94       	mov	r4,r2
800088b2:	06 96       	mov	r6,r3
800088b4:	02 92       	mov	r2,r1
800088b6:	40 93       	lddsp	r3,sp[0x24]
800088b8:	10 90       	mov	r0,r8
800088ba:	40 41       	lddsp	r1,sp[0x10]
800088bc:	a5 a5       	sbr	r5,0x4
800088be:	c0 a8       	rjmp	800088d2 <_vfprintf_r+0xd26>
800088c0:	50 a7       	stdsp	sp[0x28],r7
800088c2:	50 80       	stdsp	sp[0x20],r0
800088c4:	0c 97       	mov	r7,r6
800088c6:	04 94       	mov	r4,r2
800088c8:	06 96       	mov	r6,r3
800088ca:	02 92       	mov	r2,r1
800088cc:	40 93       	lddsp	r3,sp[0x24]
800088ce:	10 90       	mov	r0,r8
800088d0:	40 41       	lddsp	r1,sp[0x10]
800088d2:	ed b5 00 05 	bld	r5,0x5
800088d6:	c5 d1       	brne	80008990 <_vfprintf_r+0xde4>
800088d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088dc:	40 3c       	lddsp	r12,sp[0xc]
800088de:	58 0c       	cp.w	r12,0
800088e0:	c2 60       	breq	8000892c <_vfprintf_r+0xd80>
800088e2:	10 36       	cp.w	r6,r8
800088e4:	c0 a4       	brge	800088f8 <_vfprintf_r+0xd4c>
800088e6:	fa cb f9 44 	sub	r11,sp,-1724
800088ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088ee:	ec e8 fd 88 	ld.d	r8,r6[-632]
800088f2:	fa e9 00 00 	st.d	sp[0],r8
800088f6:	c1 88       	rjmp	80008926 <_vfprintf_r+0xd7a>
800088f8:	fa c8 f9 50 	sub	r8,sp,-1712
800088fc:	1a d8       	st.w	--sp,r8
800088fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008902:	04 9a       	mov	r10,r2
80008904:	1a d8       	st.w	--sp,r8
80008906:	0c 9b       	mov	r11,r6
80008908:	fa c8 fb b4 	sub	r8,sp,-1100
8000890c:	08 9c       	mov	r12,r4
8000890e:	1a d8       	st.w	--sp,r8
80008910:	fa c8 f9 40 	sub	r8,sp,-1728
80008914:	fa c9 ff b4 	sub	r9,sp,-76
80008918:	fe b0 f7 b2 	rcall	8000787c <get_arg>
8000891c:	2f dd       	sub	sp,-12
8000891e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008922:	fa eb 00 00 	st.d	sp[0],r10
80008926:	30 08       	mov	r8,0
80008928:	e0 8f 03 de 	bral	800090e4 <_vfprintf_r+0x1538>
8000892c:	ee ca ff ff 	sub	r10,r7,-1
80008930:	10 37       	cp.w	r7,r8
80008932:	c0 b4       	brge	80008948 <_vfprintf_r+0xd9c>
80008934:	fa c9 f9 44 	sub	r9,sp,-1724
80008938:	14 97       	mov	r7,r10
8000893a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000893e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008942:	fa eb 00 00 	st.d	sp[0],r10
80008946:	c1 88       	rjmp	80008976 <_vfprintf_r+0xdca>
80008948:	41 09       	lddsp	r9,sp[0x40]
8000894a:	59 f8       	cp.w	r8,31
8000894c:	e0 89 00 18 	brgt	8000897c <_vfprintf_r+0xdd0>
80008950:	f2 e6 00 00 	ld.d	r6,r9[0]
80008954:	f2 cb ff f8 	sub	r11,r9,-8
80008958:	fa e7 00 00 	st.d	sp[0],r6
8000895c:	51 0b       	stdsp	sp[0x40],r11
8000895e:	fa c6 f9 44 	sub	r6,sp,-1724
80008962:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008966:	fa e6 00 00 	ld.d	r6,sp[0]
8000896a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000896e:	2f f8       	sub	r8,-1
80008970:	14 97       	mov	r7,r10
80008972:	fb 48 06 b4 	st.w	sp[1716],r8
80008976:	40 38       	lddsp	r8,sp[0xc]
80008978:	e0 8f 03 b6 	bral	800090e4 <_vfprintf_r+0x1538>
8000897c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008980:	40 38       	lddsp	r8,sp[0xc]
80008982:	fa e7 00 00 	st.d	sp[0],r6
80008986:	2f 89       	sub	r9,-8
80008988:	14 97       	mov	r7,r10
8000898a:	51 09       	stdsp	sp[0x40],r9
8000898c:	e0 8f 03 ac 	bral	800090e4 <_vfprintf_r+0x1538>
80008990:	ed b5 00 04 	bld	r5,0x4
80008994:	c1 61       	brne	800089c0 <_vfprintf_r+0xe14>
80008996:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000899a:	40 3e       	lddsp	lr,sp[0xc]
8000899c:	58 0e       	cp.w	lr,0
8000899e:	c0 80       	breq	800089ae <_vfprintf_r+0xe02>
800089a0:	10 36       	cp.w	r6,r8
800089a2:	c6 74       	brge	80008a70 <_vfprintf_r+0xec4>
800089a4:	fa cc f9 44 	sub	r12,sp,-1724
800089a8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089ac:	c8 08       	rjmp	80008aac <_vfprintf_r+0xf00>
800089ae:	ee ca ff ff 	sub	r10,r7,-1
800089b2:	10 37       	cp.w	r7,r8
800089b4:	c7 f4       	brge	80008ab2 <_vfprintf_r+0xf06>
800089b6:	fa cb f9 44 	sub	r11,sp,-1724
800089ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089be:	c7 68       	rjmp	80008aaa <_vfprintf_r+0xefe>
800089c0:	ed b5 00 06 	bld	r5,0x6
800089c4:	c4 a1       	brne	80008a58 <_vfprintf_r+0xeac>
800089c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089ca:	40 3c       	lddsp	r12,sp[0xc]
800089cc:	58 0c       	cp.w	r12,0
800089ce:	c1 d0       	breq	80008a08 <_vfprintf_r+0xe5c>
800089d0:	10 36       	cp.w	r6,r8
800089d2:	c0 64       	brge	800089de <_vfprintf_r+0xe32>
800089d4:	fa cb f9 44 	sub	r11,sp,-1724
800089d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089dc:	c1 f8       	rjmp	80008a1a <_vfprintf_r+0xe6e>
800089de:	fa c8 f9 50 	sub	r8,sp,-1712
800089e2:	1a d8       	st.w	--sp,r8
800089e4:	fa c8 fa b8 	sub	r8,sp,-1352
800089e8:	1a d8       	st.w	--sp,r8
800089ea:	fa c8 fb b4 	sub	r8,sp,-1100
800089ee:	1a d8       	st.w	--sp,r8
800089f0:	fa c8 f9 40 	sub	r8,sp,-1728
800089f4:	fa c9 ff b4 	sub	r9,sp,-76
800089f8:	04 9a       	mov	r10,r2
800089fa:	0c 9b       	mov	r11,r6
800089fc:	08 9c       	mov	r12,r4
800089fe:	fe b0 f7 3f 	rcall	8000787c <get_arg>
80008a02:	2f dd       	sub	sp,-12
80008a04:	98 18       	ld.sh	r8,r12[0x2]
80008a06:	c2 68       	rjmp	80008a52 <_vfprintf_r+0xea6>
80008a08:	ee ca ff ff 	sub	r10,r7,-1
80008a0c:	10 37       	cp.w	r7,r8
80008a0e:	c0 94       	brge	80008a20 <_vfprintf_r+0xe74>
80008a10:	fa c9 f9 44 	sub	r9,sp,-1724
80008a14:	14 97       	mov	r7,r10
80008a16:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a1a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a1e:	c1 a8       	rjmp	80008a52 <_vfprintf_r+0xea6>
80008a20:	41 09       	lddsp	r9,sp[0x40]
80008a22:	59 f8       	cp.w	r8,31
80008a24:	e0 89 00 13 	brgt	80008a4a <_vfprintf_r+0xe9e>
80008a28:	f2 cb ff fc 	sub	r11,r9,-4
80008a2c:	51 0b       	stdsp	sp[0x40],r11
80008a2e:	72 09       	ld.w	r9,r9[0x0]
80008a30:	fa c6 f9 44 	sub	r6,sp,-1724
80008a34:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a38:	2f f8       	sub	r8,-1
80008a3a:	f7 49 fd 88 	st.w	r11[-632],r9
80008a3e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a42:	14 97       	mov	r7,r10
80008a44:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a48:	c0 58       	rjmp	80008a52 <_vfprintf_r+0xea6>
80008a4a:	92 18       	ld.sh	r8,r9[0x2]
80008a4c:	14 97       	mov	r7,r10
80008a4e:	2f c9       	sub	r9,-4
80008a50:	51 09       	stdsp	sp[0x40],r9
80008a52:	5c 78       	castu.h	r8
80008a54:	50 18       	stdsp	sp[0x4],r8
80008a56:	c4 68       	rjmp	80008ae2 <_vfprintf_r+0xf36>
80008a58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a5c:	40 3c       	lddsp	r12,sp[0xc]
80008a5e:	58 0c       	cp.w	r12,0
80008a60:	c1 d0       	breq	80008a9a <_vfprintf_r+0xeee>
80008a62:	10 36       	cp.w	r6,r8
80008a64:	c0 64       	brge	80008a70 <_vfprintf_r+0xec4>
80008a66:	fa cb f9 44 	sub	r11,sp,-1724
80008a6a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a6e:	c1 f8       	rjmp	80008aac <_vfprintf_r+0xf00>
80008a70:	fa c8 f9 50 	sub	r8,sp,-1712
80008a74:	1a d8       	st.w	--sp,r8
80008a76:	fa c8 fa b8 	sub	r8,sp,-1352
80008a7a:	0c 9b       	mov	r11,r6
80008a7c:	1a d8       	st.w	--sp,r8
80008a7e:	fa c8 fb b4 	sub	r8,sp,-1100
80008a82:	04 9a       	mov	r10,r2
80008a84:	1a d8       	st.w	--sp,r8
80008a86:	08 9c       	mov	r12,r4
80008a88:	fa c8 f9 40 	sub	r8,sp,-1728
80008a8c:	fa c9 ff b4 	sub	r9,sp,-76
80008a90:	fe b0 f6 f6 	rcall	8000787c <get_arg>
80008a94:	2f dd       	sub	sp,-12
80008a96:	78 0b       	ld.w	r11,r12[0x0]
80008a98:	c2 48       	rjmp	80008ae0 <_vfprintf_r+0xf34>
80008a9a:	ee ca ff ff 	sub	r10,r7,-1
80008a9e:	10 37       	cp.w	r7,r8
80008aa0:	c0 94       	brge	80008ab2 <_vfprintf_r+0xf06>
80008aa2:	fa c9 f9 44 	sub	r9,sp,-1724
80008aa6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008aaa:	14 97       	mov	r7,r10
80008aac:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ab0:	c1 88       	rjmp	80008ae0 <_vfprintf_r+0xf34>
80008ab2:	41 09       	lddsp	r9,sp[0x40]
80008ab4:	59 f8       	cp.w	r8,31
80008ab6:	e0 89 00 11 	brgt	80008ad8 <_vfprintf_r+0xf2c>
80008aba:	f2 cb ff fc 	sub	r11,r9,-4
80008abe:	51 0b       	stdsp	sp[0x40],r11
80008ac0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ac4:	72 0b       	ld.w	r11,r9[0x0]
80008ac6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aca:	f3 4b fd 88 	st.w	r9[-632],r11
80008ace:	2f f8       	sub	r8,-1
80008ad0:	14 97       	mov	r7,r10
80008ad2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ad6:	c0 58       	rjmp	80008ae0 <_vfprintf_r+0xf34>
80008ad8:	72 0b       	ld.w	r11,r9[0x0]
80008ada:	14 97       	mov	r7,r10
80008adc:	2f c9       	sub	r9,-4
80008ade:	51 09       	stdsp	sp[0x40],r9
80008ae0:	50 1b       	stdsp	sp[0x4],r11
80008ae2:	30 0e       	mov	lr,0
80008ae4:	50 0e       	stdsp	sp[0x0],lr
80008ae6:	1c 98       	mov	r8,lr
80008ae8:	e0 8f 02 fe 	bral	800090e4 <_vfprintf_r+0x1538>
80008aec:	50 a7       	stdsp	sp[0x28],r7
80008aee:	50 80       	stdsp	sp[0x20],r0
80008af0:	0c 97       	mov	r7,r6
80008af2:	04 94       	mov	r4,r2
80008af4:	06 96       	mov	r6,r3
80008af6:	02 92       	mov	r2,r1
80008af8:	40 93       	lddsp	r3,sp[0x24]
80008afa:	40 41       	lddsp	r1,sp[0x10]
80008afc:	0e 99       	mov	r9,r7
80008afe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b02:	40 3c       	lddsp	r12,sp[0xc]
80008b04:	58 0c       	cp.w	r12,0
80008b06:	c1 d0       	breq	80008b40 <_vfprintf_r+0xf94>
80008b08:	10 36       	cp.w	r6,r8
80008b0a:	c0 64       	brge	80008b16 <_vfprintf_r+0xf6a>
80008b0c:	fa cb f9 44 	sub	r11,sp,-1724
80008b10:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b14:	c1 d8       	rjmp	80008b4e <_vfprintf_r+0xfa2>
80008b16:	fa c8 f9 50 	sub	r8,sp,-1712
80008b1a:	1a d8       	st.w	--sp,r8
80008b1c:	fa c8 fa b8 	sub	r8,sp,-1352
80008b20:	1a d8       	st.w	--sp,r8
80008b22:	fa c8 fb b4 	sub	r8,sp,-1100
80008b26:	1a d8       	st.w	--sp,r8
80008b28:	fa c9 ff b4 	sub	r9,sp,-76
80008b2c:	fa c8 f9 40 	sub	r8,sp,-1728
80008b30:	04 9a       	mov	r10,r2
80008b32:	0c 9b       	mov	r11,r6
80008b34:	08 9c       	mov	r12,r4
80008b36:	fe b0 f6 a3 	rcall	8000787c <get_arg>
80008b3a:	2f dd       	sub	sp,-12
80008b3c:	78 09       	ld.w	r9,r12[0x0]
80008b3e:	c2 18       	rjmp	80008b80 <_vfprintf_r+0xfd4>
80008b40:	2f f7       	sub	r7,-1
80008b42:	10 39       	cp.w	r9,r8
80008b44:	c0 84       	brge	80008b54 <_vfprintf_r+0xfa8>
80008b46:	fa ca f9 44 	sub	r10,sp,-1724
80008b4a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b4e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008b52:	c1 78       	rjmp	80008b80 <_vfprintf_r+0xfd4>
80008b54:	41 09       	lddsp	r9,sp[0x40]
80008b56:	59 f8       	cp.w	r8,31
80008b58:	e0 89 00 10 	brgt	80008b78 <_vfprintf_r+0xfcc>
80008b5c:	f2 ca ff fc 	sub	r10,r9,-4
80008b60:	51 0a       	stdsp	sp[0x40],r10
80008b62:	fa c6 f9 44 	sub	r6,sp,-1724
80008b66:	72 09       	ld.w	r9,r9[0x0]
80008b68:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008b6c:	f5 49 fd 88 	st.w	r10[-632],r9
80008b70:	2f f8       	sub	r8,-1
80008b72:	fb 48 06 b4 	st.w	sp[1716],r8
80008b76:	c0 58       	rjmp	80008b80 <_vfprintf_r+0xfd4>
80008b78:	f2 c8 ff fc 	sub	r8,r9,-4
80008b7c:	51 08       	stdsp	sp[0x40],r8
80008b7e:	72 09       	ld.w	r9,r9[0x0]
80008b80:	33 08       	mov	r8,48
80008b82:	fb 68 06 b8 	st.b	sp[1720],r8
80008b86:	37 88       	mov	r8,120
80008b88:	30 0e       	mov	lr,0
80008b8a:	fb 68 06 b9 	st.b	sp[1721],r8
80008b8e:	fe cc b2 a2 	sub	r12,pc,-19806
80008b92:	50 19       	stdsp	sp[0x4],r9
80008b94:	a1 b5       	sbr	r5,0x1
80008b96:	50 0e       	stdsp	sp[0x0],lr
80008b98:	50 dc       	stdsp	sp[0x34],r12
80008b9a:	30 28       	mov	r8,2
80008b9c:	37 80       	mov	r0,120
80008b9e:	e0 8f 02 a3 	bral	800090e4 <_vfprintf_r+0x1538>
80008ba2:	50 a7       	stdsp	sp[0x28],r7
80008ba4:	50 80       	stdsp	sp[0x20],r0
80008ba6:	10 90       	mov	r0,r8
80008ba8:	30 08       	mov	r8,0
80008baa:	fb 68 06 bb 	st.b	sp[1723],r8
80008bae:	0c 97       	mov	r7,r6
80008bb0:	04 94       	mov	r4,r2
80008bb2:	06 96       	mov	r6,r3
80008bb4:	02 92       	mov	r2,r1
80008bb6:	40 93       	lddsp	r3,sp[0x24]
80008bb8:	40 41       	lddsp	r1,sp[0x10]
80008bba:	0e 99       	mov	r9,r7
80008bbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bc0:	40 3b       	lddsp	r11,sp[0xc]
80008bc2:	58 0b       	cp.w	r11,0
80008bc4:	c1 d0       	breq	80008bfe <_vfprintf_r+0x1052>
80008bc6:	10 36       	cp.w	r6,r8
80008bc8:	c0 64       	brge	80008bd4 <_vfprintf_r+0x1028>
80008bca:	fa ca f9 44 	sub	r10,sp,-1724
80008bce:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bd2:	c1 d8       	rjmp	80008c0c <_vfprintf_r+0x1060>
80008bd4:	fa c8 f9 50 	sub	r8,sp,-1712
80008bd8:	1a d8       	st.w	--sp,r8
80008bda:	fa c8 fa b8 	sub	r8,sp,-1352
80008bde:	1a d8       	st.w	--sp,r8
80008be0:	fa c8 fb b4 	sub	r8,sp,-1100
80008be4:	0c 9b       	mov	r11,r6
80008be6:	1a d8       	st.w	--sp,r8
80008be8:	04 9a       	mov	r10,r2
80008bea:	fa c8 f9 40 	sub	r8,sp,-1728
80008bee:	fa c9 ff b4 	sub	r9,sp,-76
80008bf2:	08 9c       	mov	r12,r4
80008bf4:	fe b0 f6 44 	rcall	8000787c <get_arg>
80008bf8:	2f dd       	sub	sp,-12
80008bfa:	78 06       	ld.w	r6,r12[0x0]
80008bfc:	c2 08       	rjmp	80008c3c <_vfprintf_r+0x1090>
80008bfe:	2f f7       	sub	r7,-1
80008c00:	10 39       	cp.w	r9,r8
80008c02:	c0 84       	brge	80008c12 <_vfprintf_r+0x1066>
80008c04:	fa c9 f9 44 	sub	r9,sp,-1724
80008c08:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c0c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008c10:	c1 68       	rjmp	80008c3c <_vfprintf_r+0x1090>
80008c12:	41 09       	lddsp	r9,sp[0x40]
80008c14:	59 f8       	cp.w	r8,31
80008c16:	e0 89 00 10 	brgt	80008c36 <_vfprintf_r+0x108a>
80008c1a:	f2 ca ff fc 	sub	r10,r9,-4
80008c1e:	51 0a       	stdsp	sp[0x40],r10
80008c20:	72 06       	ld.w	r6,r9[0x0]
80008c22:	fa ce f9 44 	sub	lr,sp,-1724
80008c26:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008c2a:	f3 46 fd 88 	st.w	r9[-632],r6
80008c2e:	2f f8       	sub	r8,-1
80008c30:	fb 48 06 b4 	st.w	sp[1716],r8
80008c34:	c0 48       	rjmp	80008c3c <_vfprintf_r+0x1090>
80008c36:	72 06       	ld.w	r6,r9[0x0]
80008c38:	2f c9       	sub	r9,-4
80008c3a:	51 09       	stdsp	sp[0x40],r9
80008c3c:	40 2c       	lddsp	r12,sp[0x8]
80008c3e:	58 0c       	cp.w	r12,0
80008c40:	c1 05       	brlt	80008c60 <_vfprintf_r+0x10b4>
80008c42:	18 9a       	mov	r10,r12
80008c44:	30 0b       	mov	r11,0
80008c46:	0c 9c       	mov	r12,r6
80008c48:	e0 a0 12 38 	rcall	8000b0b8 <memchr>
80008c4c:	e0 80 02 df 	breq	8000920a <_vfprintf_r+0x165e>
80008c50:	f8 06 01 02 	sub	r2,r12,r6
80008c54:	40 2b       	lddsp	r11,sp[0x8]
80008c56:	16 32       	cp.w	r2,r11
80008c58:	e0 89 02 d9 	brgt	8000920a <_vfprintf_r+0x165e>
80008c5c:	e0 8f 02 d4 	bral	80009204 <_vfprintf_r+0x1658>
80008c60:	30 0a       	mov	r10,0
80008c62:	0c 9c       	mov	r12,r6
80008c64:	50 2a       	stdsp	sp[0x8],r10
80008c66:	e0 a0 15 99 	rcall	8000b798 <strlen>
80008c6a:	18 92       	mov	r2,r12
80008c6c:	e0 8f 02 d2 	bral	80009210 <_vfprintf_r+0x1664>
80008c70:	50 a7       	stdsp	sp[0x28],r7
80008c72:	50 80       	stdsp	sp[0x20],r0
80008c74:	0c 97       	mov	r7,r6
80008c76:	04 94       	mov	r4,r2
80008c78:	06 96       	mov	r6,r3
80008c7a:	02 92       	mov	r2,r1
80008c7c:	40 93       	lddsp	r3,sp[0x24]
80008c7e:	10 90       	mov	r0,r8
80008c80:	40 41       	lddsp	r1,sp[0x10]
80008c82:	a5 a5       	sbr	r5,0x4
80008c84:	c0 a8       	rjmp	80008c98 <_vfprintf_r+0x10ec>
80008c86:	50 a7       	stdsp	sp[0x28],r7
80008c88:	50 80       	stdsp	sp[0x20],r0
80008c8a:	0c 97       	mov	r7,r6
80008c8c:	04 94       	mov	r4,r2
80008c8e:	06 96       	mov	r6,r3
80008c90:	02 92       	mov	r2,r1
80008c92:	40 93       	lddsp	r3,sp[0x24]
80008c94:	10 90       	mov	r0,r8
80008c96:	40 41       	lddsp	r1,sp[0x10]
80008c98:	ed b5 00 05 	bld	r5,0x5
80008c9c:	c5 61       	brne	80008d48 <_vfprintf_r+0x119c>
80008c9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ca2:	40 39       	lddsp	r9,sp[0xc]
80008ca4:	58 09       	cp.w	r9,0
80008ca6:	c2 10       	breq	80008ce8 <_vfprintf_r+0x113c>
80008ca8:	10 36       	cp.w	r6,r8
80008caa:	c0 74       	brge	80008cb8 <_vfprintf_r+0x110c>
80008cac:	fa c8 f9 44 	sub	r8,sp,-1724
80008cb0:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008cb4:	c2 38       	rjmp	80008cfa <_vfprintf_r+0x114e>
80008cb6:	d7 03       	nop
80008cb8:	fa c8 f9 50 	sub	r8,sp,-1712
80008cbc:	1a d8       	st.w	--sp,r8
80008cbe:	fa c8 fa b8 	sub	r8,sp,-1352
80008cc2:	1a d8       	st.w	--sp,r8
80008cc4:	fa c8 fb b4 	sub	r8,sp,-1100
80008cc8:	1a d8       	st.w	--sp,r8
80008cca:	fa c8 f9 40 	sub	r8,sp,-1728
80008cce:	fa c9 ff b4 	sub	r9,sp,-76
80008cd2:	04 9a       	mov	r10,r2
80008cd4:	0c 9b       	mov	r11,r6
80008cd6:	08 9c       	mov	r12,r4
80008cd8:	fe b0 f5 d2 	rcall	8000787c <get_arg>
80008cdc:	2f dd       	sub	sp,-12
80008cde:	f8 e8 00 00 	ld.d	r8,r12[0]
80008ce2:	fa e9 00 00 	st.d	sp[0],r8
80008ce6:	c2 e8       	rjmp	80008d42 <_vfprintf_r+0x1196>
80008ce8:	ee ca ff ff 	sub	r10,r7,-1
80008cec:	10 37       	cp.w	r7,r8
80008cee:	c0 b4       	brge	80008d04 <_vfprintf_r+0x1158>
80008cf0:	fa c8 f9 44 	sub	r8,sp,-1724
80008cf4:	14 97       	mov	r7,r10
80008cf6:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008cfa:	ec ea fd 88 	ld.d	r10,r6[-632]
80008cfe:	fa eb 00 00 	st.d	sp[0],r10
80008d02:	c2 08       	rjmp	80008d42 <_vfprintf_r+0x1196>
80008d04:	41 09       	lddsp	r9,sp[0x40]
80008d06:	59 f8       	cp.w	r8,31
80008d08:	e0 89 00 16 	brgt	80008d34 <_vfprintf_r+0x1188>
80008d0c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d10:	f2 cb ff f8 	sub	r11,r9,-8
80008d14:	fa e7 00 00 	st.d	sp[0],r6
80008d18:	51 0b       	stdsp	sp[0x40],r11
80008d1a:	fa c6 f9 44 	sub	r6,sp,-1724
80008d1e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d22:	fa e6 00 00 	ld.d	r6,sp[0]
80008d26:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d2a:	2f f8       	sub	r8,-1
80008d2c:	14 97       	mov	r7,r10
80008d2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d32:	c0 88       	rjmp	80008d42 <_vfprintf_r+0x1196>
80008d34:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d38:	2f 89       	sub	r9,-8
80008d3a:	fa e7 00 00 	st.d	sp[0],r6
80008d3e:	51 09       	stdsp	sp[0x40],r9
80008d40:	14 97       	mov	r7,r10
80008d42:	30 18       	mov	r8,1
80008d44:	e0 8f 01 d0 	bral	800090e4 <_vfprintf_r+0x1538>
80008d48:	ed b5 00 04 	bld	r5,0x4
80008d4c:	c1 61       	brne	80008d78 <_vfprintf_r+0x11cc>
80008d4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d52:	40 3e       	lddsp	lr,sp[0xc]
80008d54:	58 0e       	cp.w	lr,0
80008d56:	c0 80       	breq	80008d66 <_vfprintf_r+0x11ba>
80008d58:	10 36       	cp.w	r6,r8
80008d5a:	c6 74       	brge	80008e28 <_vfprintf_r+0x127c>
80008d5c:	fa cc f9 44 	sub	r12,sp,-1724
80008d60:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d64:	c8 08       	rjmp	80008e64 <_vfprintf_r+0x12b8>
80008d66:	ee ca ff ff 	sub	r10,r7,-1
80008d6a:	10 37       	cp.w	r7,r8
80008d6c:	c7 f4       	brge	80008e6a <_vfprintf_r+0x12be>
80008d6e:	fa cb f9 44 	sub	r11,sp,-1724
80008d72:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d76:	c7 68       	rjmp	80008e62 <_vfprintf_r+0x12b6>
80008d78:	ed b5 00 06 	bld	r5,0x6
80008d7c:	c4 a1       	brne	80008e10 <_vfprintf_r+0x1264>
80008d7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d82:	40 3c       	lddsp	r12,sp[0xc]
80008d84:	58 0c       	cp.w	r12,0
80008d86:	c1 d0       	breq	80008dc0 <_vfprintf_r+0x1214>
80008d88:	10 36       	cp.w	r6,r8
80008d8a:	c0 64       	brge	80008d96 <_vfprintf_r+0x11ea>
80008d8c:	fa cb f9 44 	sub	r11,sp,-1724
80008d90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d94:	c1 f8       	rjmp	80008dd2 <_vfprintf_r+0x1226>
80008d96:	fa c8 f9 50 	sub	r8,sp,-1712
80008d9a:	1a d8       	st.w	--sp,r8
80008d9c:	fa c8 fa b8 	sub	r8,sp,-1352
80008da0:	1a d8       	st.w	--sp,r8
80008da2:	fa c8 fb b4 	sub	r8,sp,-1100
80008da6:	1a d8       	st.w	--sp,r8
80008da8:	fa c8 f9 40 	sub	r8,sp,-1728
80008dac:	fa c9 ff b4 	sub	r9,sp,-76
80008db0:	04 9a       	mov	r10,r2
80008db2:	0c 9b       	mov	r11,r6
80008db4:	08 9c       	mov	r12,r4
80008db6:	fe b0 f5 63 	rcall	8000787c <get_arg>
80008dba:	2f dd       	sub	sp,-12
80008dbc:	98 18       	ld.sh	r8,r12[0x2]
80008dbe:	c2 68       	rjmp	80008e0a <_vfprintf_r+0x125e>
80008dc0:	ee ca ff ff 	sub	r10,r7,-1
80008dc4:	10 37       	cp.w	r7,r8
80008dc6:	c0 94       	brge	80008dd8 <_vfprintf_r+0x122c>
80008dc8:	fa c9 f9 44 	sub	r9,sp,-1724
80008dcc:	14 97       	mov	r7,r10
80008dce:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dd2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008dd6:	c1 a8       	rjmp	80008e0a <_vfprintf_r+0x125e>
80008dd8:	41 09       	lddsp	r9,sp[0x40]
80008dda:	59 f8       	cp.w	r8,31
80008ddc:	e0 89 00 13 	brgt	80008e02 <_vfprintf_r+0x1256>
80008de0:	f2 cb ff fc 	sub	r11,r9,-4
80008de4:	51 0b       	stdsp	sp[0x40],r11
80008de6:	72 09       	ld.w	r9,r9[0x0]
80008de8:	fa c6 f9 44 	sub	r6,sp,-1724
80008dec:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008df0:	2f f8       	sub	r8,-1
80008df2:	f7 49 fd 88 	st.w	r11[-632],r9
80008df6:	fb 48 06 b4 	st.w	sp[1716],r8
80008dfa:	14 97       	mov	r7,r10
80008dfc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e00:	c0 58       	rjmp	80008e0a <_vfprintf_r+0x125e>
80008e02:	92 18       	ld.sh	r8,r9[0x2]
80008e04:	14 97       	mov	r7,r10
80008e06:	2f c9       	sub	r9,-4
80008e08:	51 09       	stdsp	sp[0x40],r9
80008e0a:	5c 78       	castu.h	r8
80008e0c:	50 18       	stdsp	sp[0x4],r8
80008e0e:	c4 68       	rjmp	80008e9a <_vfprintf_r+0x12ee>
80008e10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e14:	40 3c       	lddsp	r12,sp[0xc]
80008e16:	58 0c       	cp.w	r12,0
80008e18:	c1 d0       	breq	80008e52 <_vfprintf_r+0x12a6>
80008e1a:	10 36       	cp.w	r6,r8
80008e1c:	c0 64       	brge	80008e28 <_vfprintf_r+0x127c>
80008e1e:	fa cb f9 44 	sub	r11,sp,-1724
80008e22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e26:	c1 f8       	rjmp	80008e64 <_vfprintf_r+0x12b8>
80008e28:	fa c8 f9 50 	sub	r8,sp,-1712
80008e2c:	1a d8       	st.w	--sp,r8
80008e2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e32:	0c 9b       	mov	r11,r6
80008e34:	1a d8       	st.w	--sp,r8
80008e36:	fa c8 fb b4 	sub	r8,sp,-1100
80008e3a:	04 9a       	mov	r10,r2
80008e3c:	1a d8       	st.w	--sp,r8
80008e3e:	08 9c       	mov	r12,r4
80008e40:	fa c8 f9 40 	sub	r8,sp,-1728
80008e44:	fa c9 ff b4 	sub	r9,sp,-76
80008e48:	fe b0 f5 1a 	rcall	8000787c <get_arg>
80008e4c:	2f dd       	sub	sp,-12
80008e4e:	78 0b       	ld.w	r11,r12[0x0]
80008e50:	c2 48       	rjmp	80008e98 <_vfprintf_r+0x12ec>
80008e52:	ee ca ff ff 	sub	r10,r7,-1
80008e56:	10 37       	cp.w	r7,r8
80008e58:	c0 94       	brge	80008e6a <_vfprintf_r+0x12be>
80008e5a:	fa c9 f9 44 	sub	r9,sp,-1724
80008e5e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e62:	14 97       	mov	r7,r10
80008e64:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e68:	c1 88       	rjmp	80008e98 <_vfprintf_r+0x12ec>
80008e6a:	41 09       	lddsp	r9,sp[0x40]
80008e6c:	59 f8       	cp.w	r8,31
80008e6e:	e0 89 00 11 	brgt	80008e90 <_vfprintf_r+0x12e4>
80008e72:	f2 cb ff fc 	sub	r11,r9,-4
80008e76:	51 0b       	stdsp	sp[0x40],r11
80008e78:	fa c6 f9 44 	sub	r6,sp,-1724
80008e7c:	72 0b       	ld.w	r11,r9[0x0]
80008e7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e82:	f3 4b fd 88 	st.w	r9[-632],r11
80008e86:	2f f8       	sub	r8,-1
80008e88:	14 97       	mov	r7,r10
80008e8a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e8e:	c0 58       	rjmp	80008e98 <_vfprintf_r+0x12ec>
80008e90:	72 0b       	ld.w	r11,r9[0x0]
80008e92:	14 97       	mov	r7,r10
80008e94:	2f c9       	sub	r9,-4
80008e96:	51 09       	stdsp	sp[0x40],r9
80008e98:	50 1b       	stdsp	sp[0x4],r11
80008e9a:	30 0e       	mov	lr,0
80008e9c:	30 18       	mov	r8,1
80008e9e:	50 0e       	stdsp	sp[0x0],lr
80008ea0:	c2 29       	rjmp	800090e4 <_vfprintf_r+0x1538>
80008ea2:	50 a7       	stdsp	sp[0x28],r7
80008ea4:	50 80       	stdsp	sp[0x20],r0
80008ea6:	0c 97       	mov	r7,r6
80008ea8:	04 94       	mov	r4,r2
80008eaa:	06 96       	mov	r6,r3
80008eac:	02 92       	mov	r2,r1
80008eae:	fe cc b5 c2 	sub	r12,pc,-19006
80008eb2:	40 93       	lddsp	r3,sp[0x24]
80008eb4:	10 90       	mov	r0,r8
80008eb6:	40 41       	lddsp	r1,sp[0x10]
80008eb8:	50 dc       	stdsp	sp[0x34],r12
80008eba:	ed b5 00 05 	bld	r5,0x5
80008ebe:	c5 51       	brne	80008f68 <_vfprintf_r+0x13bc>
80008ec0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ec4:	40 3b       	lddsp	r11,sp[0xc]
80008ec6:	58 0b       	cp.w	r11,0
80008ec8:	c2 20       	breq	80008f0c <_vfprintf_r+0x1360>
80008eca:	10 36       	cp.w	r6,r8
80008ecc:	c0 a4       	brge	80008ee0 <_vfprintf_r+0x1334>
80008ece:	fa ca f9 44 	sub	r10,sp,-1724
80008ed2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ed6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008eda:	fa e9 00 00 	st.d	sp[0],r8
80008ede:	cf 28       	rjmp	800090c2 <_vfprintf_r+0x1516>
80008ee0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ee4:	1a d8       	st.w	--sp,r8
80008ee6:	fa c8 fa b8 	sub	r8,sp,-1352
80008eea:	04 9a       	mov	r10,r2
80008eec:	1a d8       	st.w	--sp,r8
80008eee:	0c 9b       	mov	r11,r6
80008ef0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ef4:	08 9c       	mov	r12,r4
80008ef6:	1a d8       	st.w	--sp,r8
80008ef8:	fa c8 f9 40 	sub	r8,sp,-1728
80008efc:	fa c9 ff b4 	sub	r9,sp,-76
80008f00:	fe b0 f4 be 	rcall	8000787c <get_arg>
80008f04:	2f dd       	sub	sp,-12
80008f06:	f8 ea 00 00 	ld.d	r10,r12[0]
80008f0a:	c0 c8       	rjmp	80008f22 <_vfprintf_r+0x1376>
80008f0c:	ee ca ff ff 	sub	r10,r7,-1
80008f10:	10 37       	cp.w	r7,r8
80008f12:	c0 b4       	brge	80008f28 <_vfprintf_r+0x137c>
80008f14:	fa c9 f9 44 	sub	r9,sp,-1724
80008f18:	14 97       	mov	r7,r10
80008f1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f22:	fa eb 00 00 	st.d	sp[0],r10
80008f26:	cc e8       	rjmp	800090c2 <_vfprintf_r+0x1516>
80008f28:	41 09       	lddsp	r9,sp[0x40]
80008f2a:	59 f8       	cp.w	r8,31
80008f2c:	e0 89 00 16 	brgt	80008f58 <_vfprintf_r+0x13ac>
80008f30:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f34:	f2 cb ff f8 	sub	r11,r9,-8
80008f38:	fa e7 00 00 	st.d	sp[0],r6
80008f3c:	51 0b       	stdsp	sp[0x40],r11
80008f3e:	fa c6 f9 44 	sub	r6,sp,-1724
80008f42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f46:	fa e6 00 00 	ld.d	r6,sp[0]
80008f4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008f4e:	2f f8       	sub	r8,-1
80008f50:	14 97       	mov	r7,r10
80008f52:	fb 48 06 b4 	st.w	sp[1716],r8
80008f56:	cb 68       	rjmp	800090c2 <_vfprintf_r+0x1516>
80008f58:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f5c:	2f 89       	sub	r9,-8
80008f5e:	fa e7 00 00 	st.d	sp[0],r6
80008f62:	51 09       	stdsp	sp[0x40],r9
80008f64:	14 97       	mov	r7,r10
80008f66:	ca e8       	rjmp	800090c2 <_vfprintf_r+0x1516>
80008f68:	ed b5 00 04 	bld	r5,0x4
80008f6c:	c1 71       	brne	80008f9a <_vfprintf_r+0x13ee>
80008f6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f72:	40 3e       	lddsp	lr,sp[0xc]
80008f74:	58 0e       	cp.w	lr,0
80008f76:	c0 80       	breq	80008f86 <_vfprintf_r+0x13da>
80008f78:	10 36       	cp.w	r6,r8
80008f7a:	c6 94       	brge	8000904c <_vfprintf_r+0x14a0>
80008f7c:	fa cc f9 44 	sub	r12,sp,-1724
80008f80:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f84:	c8 28       	rjmp	80009088 <_vfprintf_r+0x14dc>
80008f86:	ee ca ff ff 	sub	r10,r7,-1
80008f8a:	10 37       	cp.w	r7,r8
80008f8c:	e0 84 00 81 	brge	8000908e <_vfprintf_r+0x14e2>
80008f90:	fa cb f9 44 	sub	r11,sp,-1724
80008f94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f98:	c7 78       	rjmp	80009086 <_vfprintf_r+0x14da>
80008f9a:	ed b5 00 06 	bld	r5,0x6
80008f9e:	c4 b1       	brne	80009034 <_vfprintf_r+0x1488>
80008fa0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fa4:	40 3c       	lddsp	r12,sp[0xc]
80008fa6:	58 0c       	cp.w	r12,0
80008fa8:	c1 d0       	breq	80008fe2 <_vfprintf_r+0x1436>
80008faa:	10 36       	cp.w	r6,r8
80008fac:	c0 64       	brge	80008fb8 <_vfprintf_r+0x140c>
80008fae:	fa cb f9 44 	sub	r11,sp,-1724
80008fb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fb6:	c1 f8       	rjmp	80008ff4 <_vfprintf_r+0x1448>
80008fb8:	fa c8 f9 50 	sub	r8,sp,-1712
80008fbc:	1a d8       	st.w	--sp,r8
80008fbe:	fa c8 fa b8 	sub	r8,sp,-1352
80008fc2:	1a d8       	st.w	--sp,r8
80008fc4:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	fa c8 f9 40 	sub	r8,sp,-1728
80008fce:	fa c9 ff b4 	sub	r9,sp,-76
80008fd2:	04 9a       	mov	r10,r2
80008fd4:	0c 9b       	mov	r11,r6
80008fd6:	08 9c       	mov	r12,r4
80008fd8:	fe b0 f4 52 	rcall	8000787c <get_arg>
80008fdc:	2f dd       	sub	sp,-12
80008fde:	98 18       	ld.sh	r8,r12[0x2]
80008fe0:	c2 78       	rjmp	8000902e <_vfprintf_r+0x1482>
80008fe2:	ee ca ff ff 	sub	r10,r7,-1
80008fe6:	10 37       	cp.w	r7,r8
80008fe8:	c0 a4       	brge	80008ffc <_vfprintf_r+0x1450>
80008fea:	fa c9 f9 44 	sub	r9,sp,-1724
80008fee:	14 97       	mov	r7,r10
80008ff0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ff4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ff8:	c1 b8       	rjmp	8000902e <_vfprintf_r+0x1482>
80008ffa:	d7 03       	nop
80008ffc:	41 09       	lddsp	r9,sp[0x40]
80008ffe:	59 f8       	cp.w	r8,31
80009000:	e0 89 00 13 	brgt	80009026 <_vfprintf_r+0x147a>
80009004:	f2 cb ff fc 	sub	r11,r9,-4
80009008:	51 0b       	stdsp	sp[0x40],r11
8000900a:	72 09       	ld.w	r9,r9[0x0]
8000900c:	fa c6 f9 44 	sub	r6,sp,-1724
80009010:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009014:	2f f8       	sub	r8,-1
80009016:	f7 49 fd 88 	st.w	r11[-632],r9
8000901a:	fb 48 06 b4 	st.w	sp[1716],r8
8000901e:	14 97       	mov	r7,r10
80009020:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009024:	c0 58       	rjmp	8000902e <_vfprintf_r+0x1482>
80009026:	92 18       	ld.sh	r8,r9[0x2]
80009028:	14 97       	mov	r7,r10
8000902a:	2f c9       	sub	r9,-4
8000902c:	51 09       	stdsp	sp[0x40],r9
8000902e:	5c 78       	castu.h	r8
80009030:	50 18       	stdsp	sp[0x4],r8
80009032:	c4 68       	rjmp	800090be <_vfprintf_r+0x1512>
80009034:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009038:	40 3c       	lddsp	r12,sp[0xc]
8000903a:	58 0c       	cp.w	r12,0
8000903c:	c1 d0       	breq	80009076 <_vfprintf_r+0x14ca>
8000903e:	10 36       	cp.w	r6,r8
80009040:	c0 64       	brge	8000904c <_vfprintf_r+0x14a0>
80009042:	fa cb f9 44 	sub	r11,sp,-1724
80009046:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000904a:	c1 f8       	rjmp	80009088 <_vfprintf_r+0x14dc>
8000904c:	fa c8 f9 50 	sub	r8,sp,-1712
80009050:	1a d8       	st.w	--sp,r8
80009052:	fa c8 fa b8 	sub	r8,sp,-1352
80009056:	0c 9b       	mov	r11,r6
80009058:	1a d8       	st.w	--sp,r8
8000905a:	fa c8 fb b4 	sub	r8,sp,-1100
8000905e:	04 9a       	mov	r10,r2
80009060:	1a d8       	st.w	--sp,r8
80009062:	08 9c       	mov	r12,r4
80009064:	fa c8 f9 40 	sub	r8,sp,-1728
80009068:	fa c9 ff b4 	sub	r9,sp,-76
8000906c:	fe b0 f4 08 	rcall	8000787c <get_arg>
80009070:	2f dd       	sub	sp,-12
80009072:	78 0b       	ld.w	r11,r12[0x0]
80009074:	c2 48       	rjmp	800090bc <_vfprintf_r+0x1510>
80009076:	ee ca ff ff 	sub	r10,r7,-1
8000907a:	10 37       	cp.w	r7,r8
8000907c:	c0 94       	brge	8000908e <_vfprintf_r+0x14e2>
8000907e:	fa c9 f9 44 	sub	r9,sp,-1724
80009082:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009086:	14 97       	mov	r7,r10
80009088:	ec fb fd 88 	ld.w	r11,r6[-632]
8000908c:	c1 88       	rjmp	800090bc <_vfprintf_r+0x1510>
8000908e:	41 09       	lddsp	r9,sp[0x40]
80009090:	59 f8       	cp.w	r8,31
80009092:	e0 89 00 11 	brgt	800090b4 <_vfprintf_r+0x1508>
80009096:	f2 cb ff fc 	sub	r11,r9,-4
8000909a:	51 0b       	stdsp	sp[0x40],r11
8000909c:	fa c6 f9 44 	sub	r6,sp,-1724
800090a0:	72 0b       	ld.w	r11,r9[0x0]
800090a2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090a6:	f3 4b fd 88 	st.w	r9[-632],r11
800090aa:	2f f8       	sub	r8,-1
800090ac:	14 97       	mov	r7,r10
800090ae:	fb 48 06 b4 	st.w	sp[1716],r8
800090b2:	c0 58       	rjmp	800090bc <_vfprintf_r+0x1510>
800090b4:	72 0b       	ld.w	r11,r9[0x0]
800090b6:	14 97       	mov	r7,r10
800090b8:	2f c9       	sub	r9,-4
800090ba:	51 09       	stdsp	sp[0x40],r9
800090bc:	50 1b       	stdsp	sp[0x4],r11
800090be:	30 0e       	mov	lr,0
800090c0:	50 0e       	stdsp	sp[0x0],lr
800090c2:	40 08       	lddsp	r8,sp[0x0]
800090c4:	40 1c       	lddsp	r12,sp[0x4]
800090c6:	18 48       	or	r8,r12
800090c8:	5f 19       	srne	r9
800090ca:	0a 98       	mov	r8,r5
800090cc:	eb e9 00 09 	and	r9,r5,r9
800090d0:	a1 b8       	sbr	r8,0x1
800090d2:	58 09       	cp.w	r9,0
800090d4:	c0 70       	breq	800090e2 <_vfprintf_r+0x1536>
800090d6:	10 95       	mov	r5,r8
800090d8:	fb 60 06 b9 	st.b	sp[1721],r0
800090dc:	33 08       	mov	r8,48
800090de:	fb 68 06 b8 	st.b	sp[1720],r8
800090e2:	30 28       	mov	r8,2
800090e4:	30 09       	mov	r9,0
800090e6:	fb 69 06 bb 	st.b	sp[1723],r9
800090ea:	0a 99       	mov	r9,r5
800090ec:	a7 d9       	cbr	r9,0x7
800090ee:	40 2b       	lddsp	r11,sp[0x8]
800090f0:	40 16       	lddsp	r6,sp[0x4]
800090f2:	58 0b       	cp.w	r11,0
800090f4:	5f 1a       	srne	r10
800090f6:	f2 05 17 40 	movge	r5,r9
800090fa:	fa c2 f9 78 	sub	r2,sp,-1672
800090fe:	40 09       	lddsp	r9,sp[0x0]
80009100:	0c 49       	or	r9,r6
80009102:	5f 19       	srne	r9
80009104:	f5 e9 10 09 	or	r9,r10,r9
80009108:	c5 c0       	breq	800091c0 <_vfprintf_r+0x1614>
8000910a:	30 19       	mov	r9,1
8000910c:	f2 08 18 00 	cp.b	r8,r9
80009110:	c0 60       	breq	8000911c <_vfprintf_r+0x1570>
80009112:	30 29       	mov	r9,2
80009114:	f2 08 18 00 	cp.b	r8,r9
80009118:	c0 41       	brne	80009120 <_vfprintf_r+0x1574>
8000911a:	c3 c8       	rjmp	80009192 <_vfprintf_r+0x15e6>
8000911c:	04 96       	mov	r6,r2
8000911e:	c3 08       	rjmp	8000917e <_vfprintf_r+0x15d2>
80009120:	04 96       	mov	r6,r2
80009122:	fa e8 00 00 	ld.d	r8,sp[0]
80009126:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000912a:	2d 0a       	sub	r10,-48
8000912c:	0c fa       	st.b	--r6,r10
8000912e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009132:	f2 0c 16 03 	lsr	r12,r9,0x3
80009136:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000913a:	18 99       	mov	r9,r12
8000913c:	16 98       	mov	r8,r11
8000913e:	58 08       	cp.w	r8,0
80009140:	5c 29       	cpc	r9
80009142:	cf 21       	brne	80009126 <_vfprintf_r+0x157a>
80009144:	fa e9 00 00 	st.d	sp[0],r8
80009148:	ed b5 00 00 	bld	r5,0x0
8000914c:	c4 51       	brne	800091d6 <_vfprintf_r+0x162a>
8000914e:	33 09       	mov	r9,48
80009150:	f2 0a 18 00 	cp.b	r10,r9
80009154:	c4 10       	breq	800091d6 <_vfprintf_r+0x162a>
80009156:	0c f9       	st.b	--r6,r9
80009158:	c3 f8       	rjmp	800091d6 <_vfprintf_r+0x162a>
8000915a:	fa ea 00 00 	ld.d	r10,sp[0]
8000915e:	30 a8       	mov	r8,10
80009160:	30 09       	mov	r9,0
80009162:	e0 a0 1a 19 	rcall	8000c594 <__avr32_umod64>
80009166:	30 a8       	mov	r8,10
80009168:	2d 0a       	sub	r10,-48
8000916a:	30 09       	mov	r9,0
8000916c:	ac 8a       	st.b	r6[0x0],r10
8000916e:	fa ea 00 00 	ld.d	r10,sp[0]
80009172:	e0 a0 18 df 	rcall	8000c330 <__avr32_udiv64>
80009176:	16 99       	mov	r9,r11
80009178:	14 98       	mov	r8,r10
8000917a:	fa e9 00 00 	st.d	sp[0],r8
8000917e:	20 16       	sub	r6,1
80009180:	fa ea 00 00 	ld.d	r10,sp[0]
80009184:	58 9a       	cp.w	r10,9
80009186:	5c 2b       	cpc	r11
80009188:	fe 9b ff e9 	brhi	8000915a <_vfprintf_r+0x15ae>
8000918c:	1b f8       	ld.ub	r8,sp[0x7]
8000918e:	2d 08       	sub	r8,-48
80009190:	c2 08       	rjmp	800091d0 <_vfprintf_r+0x1624>
80009192:	04 96       	mov	r6,r2
80009194:	fa e8 00 00 	ld.d	r8,sp[0]
80009198:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000919c:	40 de       	lddsp	lr,sp[0x34]
8000919e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800091a2:	0c fa       	st.b	--r6,r10
800091a4:	f2 0b 16 04 	lsr	r11,r9,0x4
800091a8:	f0 0a 16 04 	lsr	r10,r8,0x4
800091ac:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800091b0:	16 99       	mov	r9,r11
800091b2:	14 98       	mov	r8,r10
800091b4:	58 08       	cp.w	r8,0
800091b6:	5c 29       	cpc	r9
800091b8:	cf 01       	brne	80009198 <_vfprintf_r+0x15ec>
800091ba:	fa e9 00 00 	st.d	sp[0],r8
800091be:	c0 c8       	rjmp	800091d6 <_vfprintf_r+0x162a>
800091c0:	58 08       	cp.w	r8,0
800091c2:	c0 91       	brne	800091d4 <_vfprintf_r+0x1628>
800091c4:	ed b5 00 00 	bld	r5,0x0
800091c8:	c0 61       	brne	800091d4 <_vfprintf_r+0x1628>
800091ca:	fa c6 f9 79 	sub	r6,sp,-1671
800091ce:	33 08       	mov	r8,48
800091d0:	ac 88       	st.b	r6[0x0],r8
800091d2:	c0 28       	rjmp	800091d6 <_vfprintf_r+0x162a>
800091d4:	04 96       	mov	r6,r2
800091d6:	0c 12       	sub	r2,r6
800091d8:	c1 c8       	rjmp	80009210 <_vfprintf_r+0x1664>
800091da:	50 a7       	stdsp	sp[0x28],r7
800091dc:	50 80       	stdsp	sp[0x20],r0
800091de:	40 93       	lddsp	r3,sp[0x24]
800091e0:	0c 97       	mov	r7,r6
800091e2:	10 90       	mov	r0,r8
800091e4:	04 94       	mov	r4,r2
800091e6:	40 41       	lddsp	r1,sp[0x10]
800091e8:	58 08       	cp.w	r8,0
800091ea:	e0 80 04 4f 	breq	80009a88 <_vfprintf_r+0x1edc>
800091ee:	fb 68 06 60 	st.b	sp[1632],r8
800091f2:	30 0c       	mov	r12,0
800091f4:	30 08       	mov	r8,0
800091f6:	30 12       	mov	r2,1
800091f8:	fb 68 06 bb 	st.b	sp[1723],r8
800091fc:	50 2c       	stdsp	sp[0x8],r12
800091fe:	fa c6 f9 a0 	sub	r6,sp,-1632
80009202:	c0 78       	rjmp	80009210 <_vfprintf_r+0x1664>
80009204:	30 0b       	mov	r11,0
80009206:	50 2b       	stdsp	sp[0x8],r11
80009208:	c0 48       	rjmp	80009210 <_vfprintf_r+0x1664>
8000920a:	40 22       	lddsp	r2,sp[0x8]
8000920c:	30 0a       	mov	r10,0
8000920e:	50 2a       	stdsp	sp[0x8],r10
80009210:	40 29       	lddsp	r9,sp[0x8]
80009212:	e4 09 0c 49 	max	r9,r2,r9
80009216:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000921a:	50 39       	stdsp	sp[0xc],r9
8000921c:	0a 9e       	mov	lr,r5
8000921e:	30 09       	mov	r9,0
80009220:	e2 1e 00 02 	andl	lr,0x2,COH
80009224:	f2 08 18 00 	cp.b	r8,r9
80009228:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000922c:	f7 b8 01 ff 	subne	r8,-1
80009230:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009234:	0a 9b       	mov	r11,r5
80009236:	58 0e       	cp.w	lr,0
80009238:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000923c:	f7 bc 01 fe 	subne	r12,-2
80009240:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009244:	e2 1b 00 84 	andl	r11,0x84,COH
80009248:	50 fe       	stdsp	sp[0x3c],lr
8000924a:	50 9b       	stdsp	sp[0x24],r11
8000924c:	c4 71       	brne	800092da <_vfprintf_r+0x172e>
8000924e:	40 8a       	lddsp	r10,sp[0x20]
80009250:	40 39       	lddsp	r9,sp[0xc]
80009252:	12 1a       	sub	r10,r9
80009254:	50 4a       	stdsp	sp[0x10],r10
80009256:	58 0a       	cp.w	r10,0
80009258:	e0 89 00 20 	brgt	80009298 <_vfprintf_r+0x16ec>
8000925c:	c3 f8       	rjmp	800092da <_vfprintf_r+0x172e>
8000925e:	2f 09       	sub	r9,-16
80009260:	2f f8       	sub	r8,-1
80009262:	fe ce b9 5e 	sub	lr,pc,-18082
80009266:	31 0c       	mov	r12,16
80009268:	fb 49 06 90 	st.w	sp[1680],r9
8000926c:	87 0e       	st.w	r3[0x0],lr
8000926e:	87 1c       	st.w	r3[0x4],r12
80009270:	fb 48 06 8c 	st.w	sp[1676],r8
80009274:	58 78       	cp.w	r8,7
80009276:	e0 89 00 04 	brgt	8000927e <_vfprintf_r+0x16d2>
8000927a:	2f 83       	sub	r3,-8
8000927c:	c0 b8       	rjmp	80009292 <_vfprintf_r+0x16e6>
8000927e:	fa ca f9 78 	sub	r10,sp,-1672
80009282:	02 9b       	mov	r11,r1
80009284:	08 9c       	mov	r12,r4
80009286:	fe b0 f4 85 	rcall	80007b90 <__sprint_r>
8000928a:	e0 81 04 10 	brne	80009aaa <_vfprintf_r+0x1efe>
8000928e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009292:	40 4b       	lddsp	r11,sp[0x10]
80009294:	21 0b       	sub	r11,16
80009296:	50 4b       	stdsp	sp[0x10],r11
80009298:	fa f9 06 90 	ld.w	r9,sp[1680]
8000929c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092a0:	fe ca b9 9c 	sub	r10,pc,-18020
800092a4:	40 4e       	lddsp	lr,sp[0x10]
800092a6:	59 0e       	cp.w	lr,16
800092a8:	fe 99 ff db 	brgt	8000925e <_vfprintf_r+0x16b2>
800092ac:	1c 09       	add	r9,lr
800092ae:	2f f8       	sub	r8,-1
800092b0:	87 0a       	st.w	r3[0x0],r10
800092b2:	fb 49 06 90 	st.w	sp[1680],r9
800092b6:	87 1e       	st.w	r3[0x4],lr
800092b8:	fb 48 06 8c 	st.w	sp[1676],r8
800092bc:	58 78       	cp.w	r8,7
800092be:	e0 89 00 04 	brgt	800092c6 <_vfprintf_r+0x171a>
800092c2:	2f 83       	sub	r3,-8
800092c4:	c0 b8       	rjmp	800092da <_vfprintf_r+0x172e>
800092c6:	fa ca f9 78 	sub	r10,sp,-1672
800092ca:	02 9b       	mov	r11,r1
800092cc:	08 9c       	mov	r12,r4
800092ce:	fe b0 f4 61 	rcall	80007b90 <__sprint_r>
800092d2:	e0 81 03 ec 	brne	80009aaa <_vfprintf_r+0x1efe>
800092d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800092da:	30 09       	mov	r9,0
800092dc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800092e0:	f2 08 18 00 	cp.b	r8,r9
800092e4:	c1 f0       	breq	80009322 <_vfprintf_r+0x1776>
800092e6:	fa f8 06 90 	ld.w	r8,sp[1680]
800092ea:	fa c9 f9 45 	sub	r9,sp,-1723
800092ee:	2f f8       	sub	r8,-1
800092f0:	87 09       	st.w	r3[0x0],r9
800092f2:	fb 48 06 90 	st.w	sp[1680],r8
800092f6:	30 19       	mov	r9,1
800092f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092fc:	87 19       	st.w	r3[0x4],r9
800092fe:	2f f8       	sub	r8,-1
80009300:	fb 48 06 8c 	st.w	sp[1676],r8
80009304:	58 78       	cp.w	r8,7
80009306:	e0 89 00 04 	brgt	8000930e <_vfprintf_r+0x1762>
8000930a:	2f 83       	sub	r3,-8
8000930c:	c0 b8       	rjmp	80009322 <_vfprintf_r+0x1776>
8000930e:	fa ca f9 78 	sub	r10,sp,-1672
80009312:	02 9b       	mov	r11,r1
80009314:	08 9c       	mov	r12,r4
80009316:	fe b0 f4 3d 	rcall	80007b90 <__sprint_r>
8000931a:	e0 81 03 c8 	brne	80009aaa <_vfprintf_r+0x1efe>
8000931e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009322:	40 fc       	lddsp	r12,sp[0x3c]
80009324:	58 0c       	cp.w	r12,0
80009326:	c1 f0       	breq	80009364 <_vfprintf_r+0x17b8>
80009328:	fa f8 06 90 	ld.w	r8,sp[1680]
8000932c:	fa c9 f9 48 	sub	r9,sp,-1720
80009330:	2f e8       	sub	r8,-2
80009332:	87 09       	st.w	r3[0x0],r9
80009334:	fb 48 06 90 	st.w	sp[1680],r8
80009338:	30 29       	mov	r9,2
8000933a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000933e:	87 19       	st.w	r3[0x4],r9
80009340:	2f f8       	sub	r8,-1
80009342:	fb 48 06 8c 	st.w	sp[1676],r8
80009346:	58 78       	cp.w	r8,7
80009348:	e0 89 00 04 	brgt	80009350 <_vfprintf_r+0x17a4>
8000934c:	2f 83       	sub	r3,-8
8000934e:	c0 b8       	rjmp	80009364 <_vfprintf_r+0x17b8>
80009350:	fa ca f9 78 	sub	r10,sp,-1672
80009354:	02 9b       	mov	r11,r1
80009356:	08 9c       	mov	r12,r4
80009358:	fe b0 f4 1c 	rcall	80007b90 <__sprint_r>
8000935c:	e0 81 03 a7 	brne	80009aaa <_vfprintf_r+0x1efe>
80009360:	fa c3 f9 e0 	sub	r3,sp,-1568
80009364:	40 9b       	lddsp	r11,sp[0x24]
80009366:	e0 4b 00 80 	cp.w	r11,128
8000936a:	c4 71       	brne	800093f8 <_vfprintf_r+0x184c>
8000936c:	40 8a       	lddsp	r10,sp[0x20]
8000936e:	40 39       	lddsp	r9,sp[0xc]
80009370:	12 1a       	sub	r10,r9
80009372:	50 4a       	stdsp	sp[0x10],r10
80009374:	58 0a       	cp.w	r10,0
80009376:	e0 89 00 20 	brgt	800093b6 <_vfprintf_r+0x180a>
8000937a:	c3 f8       	rjmp	800093f8 <_vfprintf_r+0x184c>
8000937c:	2f 09       	sub	r9,-16
8000937e:	2f f8       	sub	r8,-1
80009380:	fe ce ba 6c 	sub	lr,pc,-17812
80009384:	31 0c       	mov	r12,16
80009386:	fb 49 06 90 	st.w	sp[1680],r9
8000938a:	87 0e       	st.w	r3[0x0],lr
8000938c:	87 1c       	st.w	r3[0x4],r12
8000938e:	fb 48 06 8c 	st.w	sp[1676],r8
80009392:	58 78       	cp.w	r8,7
80009394:	e0 89 00 04 	brgt	8000939c <_vfprintf_r+0x17f0>
80009398:	2f 83       	sub	r3,-8
8000939a:	c0 b8       	rjmp	800093b0 <_vfprintf_r+0x1804>
8000939c:	fa ca f9 78 	sub	r10,sp,-1672
800093a0:	02 9b       	mov	r11,r1
800093a2:	08 9c       	mov	r12,r4
800093a4:	fe b0 f3 f6 	rcall	80007b90 <__sprint_r>
800093a8:	e0 81 03 81 	brne	80009aaa <_vfprintf_r+0x1efe>
800093ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800093b0:	40 4b       	lddsp	r11,sp[0x10]
800093b2:	21 0b       	sub	r11,16
800093b4:	50 4b       	stdsp	sp[0x10],r11
800093b6:	fa f9 06 90 	ld.w	r9,sp[1680]
800093ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093be:	fe ca ba aa 	sub	r10,pc,-17750
800093c2:	40 4e       	lddsp	lr,sp[0x10]
800093c4:	59 0e       	cp.w	lr,16
800093c6:	fe 99 ff db 	brgt	8000937c <_vfprintf_r+0x17d0>
800093ca:	1c 09       	add	r9,lr
800093cc:	2f f8       	sub	r8,-1
800093ce:	87 0a       	st.w	r3[0x0],r10
800093d0:	fb 49 06 90 	st.w	sp[1680],r9
800093d4:	87 1e       	st.w	r3[0x4],lr
800093d6:	fb 48 06 8c 	st.w	sp[1676],r8
800093da:	58 78       	cp.w	r8,7
800093dc:	e0 89 00 04 	brgt	800093e4 <_vfprintf_r+0x1838>
800093e0:	2f 83       	sub	r3,-8
800093e2:	c0 b8       	rjmp	800093f8 <_vfprintf_r+0x184c>
800093e4:	fa ca f9 78 	sub	r10,sp,-1672
800093e8:	02 9b       	mov	r11,r1
800093ea:	08 9c       	mov	r12,r4
800093ec:	fe b0 f3 d2 	rcall	80007b90 <__sprint_r>
800093f0:	e0 81 03 5d 	brne	80009aaa <_vfprintf_r+0x1efe>
800093f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800093f8:	40 2c       	lddsp	r12,sp[0x8]
800093fa:	04 1c       	sub	r12,r2
800093fc:	50 2c       	stdsp	sp[0x8],r12
800093fe:	58 0c       	cp.w	r12,0
80009400:	e0 89 00 20 	brgt	80009440 <_vfprintf_r+0x1894>
80009404:	c3 f8       	rjmp	80009482 <_vfprintf_r+0x18d6>
80009406:	2f 09       	sub	r9,-16
80009408:	2f f8       	sub	r8,-1
8000940a:	fe cb ba f6 	sub	r11,pc,-17674
8000940e:	31 0a       	mov	r10,16
80009410:	fb 49 06 90 	st.w	sp[1680],r9
80009414:	87 0b       	st.w	r3[0x0],r11
80009416:	87 1a       	st.w	r3[0x4],r10
80009418:	fb 48 06 8c 	st.w	sp[1676],r8
8000941c:	58 78       	cp.w	r8,7
8000941e:	e0 89 00 04 	brgt	80009426 <_vfprintf_r+0x187a>
80009422:	2f 83       	sub	r3,-8
80009424:	c0 b8       	rjmp	8000943a <_vfprintf_r+0x188e>
80009426:	fa ca f9 78 	sub	r10,sp,-1672
8000942a:	02 9b       	mov	r11,r1
8000942c:	08 9c       	mov	r12,r4
8000942e:	fe b0 f3 b1 	rcall	80007b90 <__sprint_r>
80009432:	e0 81 03 3c 	brne	80009aaa <_vfprintf_r+0x1efe>
80009436:	fa c3 f9 e0 	sub	r3,sp,-1568
8000943a:	40 29       	lddsp	r9,sp[0x8]
8000943c:	21 09       	sub	r9,16
8000943e:	50 29       	stdsp	sp[0x8],r9
80009440:	fa f9 06 90 	ld.w	r9,sp[1680]
80009444:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009448:	fe ca bb 34 	sub	r10,pc,-17612
8000944c:	40 2e       	lddsp	lr,sp[0x8]
8000944e:	59 0e       	cp.w	lr,16
80009450:	fe 99 ff db 	brgt	80009406 <_vfprintf_r+0x185a>
80009454:	1c 09       	add	r9,lr
80009456:	2f f8       	sub	r8,-1
80009458:	87 0a       	st.w	r3[0x0],r10
8000945a:	fb 49 06 90 	st.w	sp[1680],r9
8000945e:	87 1e       	st.w	r3[0x4],lr
80009460:	fb 48 06 8c 	st.w	sp[1676],r8
80009464:	58 78       	cp.w	r8,7
80009466:	e0 89 00 04 	brgt	8000946e <_vfprintf_r+0x18c2>
8000946a:	2f 83       	sub	r3,-8
8000946c:	c0 b8       	rjmp	80009482 <_vfprintf_r+0x18d6>
8000946e:	fa ca f9 78 	sub	r10,sp,-1672
80009472:	02 9b       	mov	r11,r1
80009474:	08 9c       	mov	r12,r4
80009476:	fe b0 f3 8d 	rcall	80007b90 <__sprint_r>
8000947a:	e0 81 03 18 	brne	80009aaa <_vfprintf_r+0x1efe>
8000947e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009482:	ed b5 00 08 	bld	r5,0x8
80009486:	c0 b0       	breq	8000949c <_vfprintf_r+0x18f0>
80009488:	fa f8 06 90 	ld.w	r8,sp[1680]
8000948c:	87 12       	st.w	r3[0x4],r2
8000948e:	87 06       	st.w	r3[0x0],r6
80009490:	f0 02 00 02 	add	r2,r8,r2
80009494:	fb 42 06 90 	st.w	sp[1680],r2
80009498:	e0 8f 01 d4 	bral	80009840 <_vfprintf_r+0x1c94>
8000949c:	e0 40 00 65 	cp.w	r0,101
800094a0:	e0 8a 01 d6 	brle	8000984c <_vfprintf_r+0x1ca0>
800094a4:	30 08       	mov	r8,0
800094a6:	30 09       	mov	r9,0
800094a8:	40 5b       	lddsp	r11,sp[0x14]
800094aa:	40 7a       	lddsp	r10,sp[0x1c]
800094ac:	e0 a0 15 3b 	rcall	8000bf22 <__avr32_f64_cmp_eq>
800094b0:	c7 90       	breq	800095a2 <_vfprintf_r+0x19f6>
800094b2:	fa f8 06 90 	ld.w	r8,sp[1680]
800094b6:	fe c9 bb b6 	sub	r9,pc,-17482
800094ba:	2f f8       	sub	r8,-1
800094bc:	87 09       	st.w	r3[0x0],r9
800094be:	fb 48 06 90 	st.w	sp[1680],r8
800094c2:	30 19       	mov	r9,1
800094c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094c8:	87 19       	st.w	r3[0x4],r9
800094ca:	2f f8       	sub	r8,-1
800094cc:	fb 48 06 8c 	st.w	sp[1676],r8
800094d0:	58 78       	cp.w	r8,7
800094d2:	e0 89 00 05 	brgt	800094dc <_vfprintf_r+0x1930>
800094d6:	2f 83       	sub	r3,-8
800094d8:	c0 c8       	rjmp	800094f0 <_vfprintf_r+0x1944>
800094da:	d7 03       	nop
800094dc:	fa ca f9 78 	sub	r10,sp,-1672
800094e0:	02 9b       	mov	r11,r1
800094e2:	08 9c       	mov	r12,r4
800094e4:	fe b0 f3 56 	rcall	80007b90 <__sprint_r>
800094e8:	e0 81 02 e1 	brne	80009aaa <_vfprintf_r+0x1efe>
800094ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800094f4:	40 6c       	lddsp	r12,sp[0x18]
800094f6:	18 38       	cp.w	r8,r12
800094f8:	c0 55       	brlt	80009502 <_vfprintf_r+0x1956>
800094fa:	ed b5 00 00 	bld	r5,0x0
800094fe:	e0 81 02 6b 	brne	800099d4 <_vfprintf_r+0x1e28>
80009502:	fa f8 06 90 	ld.w	r8,sp[1680]
80009506:	2f f8       	sub	r8,-1
80009508:	40 cb       	lddsp	r11,sp[0x30]
8000950a:	fb 48 06 90 	st.w	sp[1680],r8
8000950e:	30 19       	mov	r9,1
80009510:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009514:	87 0b       	st.w	r3[0x0],r11
80009516:	2f f8       	sub	r8,-1
80009518:	87 19       	st.w	r3[0x4],r9
8000951a:	fb 48 06 8c 	st.w	sp[1676],r8
8000951e:	58 78       	cp.w	r8,7
80009520:	e0 89 00 04 	brgt	80009528 <_vfprintf_r+0x197c>
80009524:	2f 83       	sub	r3,-8
80009526:	c0 b8       	rjmp	8000953c <_vfprintf_r+0x1990>
80009528:	fa ca f9 78 	sub	r10,sp,-1672
8000952c:	02 9b       	mov	r11,r1
8000952e:	08 9c       	mov	r12,r4
80009530:	fe b0 f3 30 	rcall	80007b90 <__sprint_r>
80009534:	e0 81 02 bb 	brne	80009aaa <_vfprintf_r+0x1efe>
80009538:	fa c3 f9 e0 	sub	r3,sp,-1568
8000953c:	40 66       	lddsp	r6,sp[0x18]
8000953e:	20 16       	sub	r6,1
80009540:	58 06       	cp.w	r6,0
80009542:	e0 89 00 1d 	brgt	8000957c <_vfprintf_r+0x19d0>
80009546:	e0 8f 02 47 	bral	800099d4 <_vfprintf_r+0x1e28>
8000954a:	2f 09       	sub	r9,-16
8000954c:	2f f8       	sub	r8,-1
8000954e:	fb 49 06 90 	st.w	sp[1680],r9
80009552:	87 02       	st.w	r3[0x0],r2
80009554:	87 10       	st.w	r3[0x4],r0
80009556:	fb 48 06 8c 	st.w	sp[1676],r8
8000955a:	58 78       	cp.w	r8,7
8000955c:	e0 89 00 04 	brgt	80009564 <_vfprintf_r+0x19b8>
80009560:	2f 83       	sub	r3,-8
80009562:	c0 b8       	rjmp	80009578 <_vfprintf_r+0x19cc>
80009564:	fa ca f9 78 	sub	r10,sp,-1672
80009568:	02 9b       	mov	r11,r1
8000956a:	08 9c       	mov	r12,r4
8000956c:	fe b0 f3 12 	rcall	80007b90 <__sprint_r>
80009570:	e0 81 02 9d 	brne	80009aaa <_vfprintf_r+0x1efe>
80009574:	fa c3 f9 e0 	sub	r3,sp,-1568
80009578:	21 06       	sub	r6,16
8000957a:	c0 48       	rjmp	80009582 <_vfprintf_r+0x19d6>
8000957c:	fe c2 bc 68 	sub	r2,pc,-17304
80009580:	31 00       	mov	r0,16
80009582:	fa f9 06 90 	ld.w	r9,sp[1680]
80009586:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000958a:	fe ca bc 76 	sub	r10,pc,-17290
8000958e:	59 06       	cp.w	r6,16
80009590:	fe 99 ff dd 	brgt	8000954a <_vfprintf_r+0x199e>
80009594:	0c 09       	add	r9,r6
80009596:	87 0a       	st.w	r3[0x0],r10
80009598:	fb 49 06 90 	st.w	sp[1680],r9
8000959c:	2f f8       	sub	r8,-1
8000959e:	87 16       	st.w	r3[0x4],r6
800095a0:	c5 39       	rjmp	80009846 <_vfprintf_r+0x1c9a>
800095a2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800095a6:	58 0a       	cp.w	r10,0
800095a8:	e0 89 00 92 	brgt	800096cc <_vfprintf_r+0x1b20>
800095ac:	fa f8 06 90 	ld.w	r8,sp[1680]
800095b0:	fe c9 bc b0 	sub	r9,pc,-17232
800095b4:	2f f8       	sub	r8,-1
800095b6:	87 09       	st.w	r3[0x0],r9
800095b8:	fb 48 06 90 	st.w	sp[1680],r8
800095bc:	30 19       	mov	r9,1
800095be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095c2:	87 19       	st.w	r3[0x4],r9
800095c4:	2f f8       	sub	r8,-1
800095c6:	fb 48 06 8c 	st.w	sp[1676],r8
800095ca:	58 78       	cp.w	r8,7
800095cc:	e0 89 00 04 	brgt	800095d4 <_vfprintf_r+0x1a28>
800095d0:	2f 83       	sub	r3,-8
800095d2:	c0 b8       	rjmp	800095e8 <_vfprintf_r+0x1a3c>
800095d4:	fa ca f9 78 	sub	r10,sp,-1672
800095d8:	02 9b       	mov	r11,r1
800095da:	08 9c       	mov	r12,r4
800095dc:	fe b0 f2 da 	rcall	80007b90 <__sprint_r>
800095e0:	e0 81 02 65 	brne	80009aaa <_vfprintf_r+0x1efe>
800095e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800095ec:	58 08       	cp.w	r8,0
800095ee:	c0 81       	brne	800095fe <_vfprintf_r+0x1a52>
800095f0:	40 6a       	lddsp	r10,sp[0x18]
800095f2:	58 0a       	cp.w	r10,0
800095f4:	c0 51       	brne	800095fe <_vfprintf_r+0x1a52>
800095f6:	ed b5 00 00 	bld	r5,0x0
800095fa:	e0 81 01 ed 	brne	800099d4 <_vfprintf_r+0x1e28>
800095fe:	40 c9       	lddsp	r9,sp[0x30]
80009600:	fa f8 06 90 	ld.w	r8,sp[1680]
80009604:	2f f8       	sub	r8,-1
80009606:	87 09       	st.w	r3[0x0],r9
80009608:	fb 48 06 90 	st.w	sp[1680],r8
8000960c:	30 19       	mov	r9,1
8000960e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009612:	87 19       	st.w	r3[0x4],r9
80009614:	2f f8       	sub	r8,-1
80009616:	fb 48 06 8c 	st.w	sp[1676],r8
8000961a:	58 78       	cp.w	r8,7
8000961c:	e0 89 00 04 	brgt	80009624 <_vfprintf_r+0x1a78>
80009620:	2f 83       	sub	r3,-8
80009622:	c0 b8       	rjmp	80009638 <_vfprintf_r+0x1a8c>
80009624:	fa ca f9 78 	sub	r10,sp,-1672
80009628:	02 9b       	mov	r11,r1
8000962a:	08 9c       	mov	r12,r4
8000962c:	fe b0 f2 b2 	rcall	80007b90 <__sprint_r>
80009630:	e0 81 02 3d 	brne	80009aaa <_vfprintf_r+0x1efe>
80009634:	fa c3 f9 e0 	sub	r3,sp,-1568
80009638:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000963c:	5c 32       	neg	r2
8000963e:	58 02       	cp.w	r2,0
80009640:	e0 89 00 1d 	brgt	8000967a <_vfprintf_r+0x1ace>
80009644:	c3 d8       	rjmp	800096be <_vfprintf_r+0x1b12>
80009646:	2f 09       	sub	r9,-16
80009648:	2f f8       	sub	r8,-1
8000964a:	31 0e       	mov	lr,16
8000964c:	fb 49 06 90 	st.w	sp[1680],r9
80009650:	87 00       	st.w	r3[0x0],r0
80009652:	87 1e       	st.w	r3[0x4],lr
80009654:	fb 48 06 8c 	st.w	sp[1676],r8
80009658:	58 78       	cp.w	r8,7
8000965a:	e0 89 00 04 	brgt	80009662 <_vfprintf_r+0x1ab6>
8000965e:	2f 83       	sub	r3,-8
80009660:	c0 b8       	rjmp	80009676 <_vfprintf_r+0x1aca>
80009662:	fa ca f9 78 	sub	r10,sp,-1672
80009666:	02 9b       	mov	r11,r1
80009668:	08 9c       	mov	r12,r4
8000966a:	fe b0 f2 93 	rcall	80007b90 <__sprint_r>
8000966e:	e0 81 02 1e 	brne	80009aaa <_vfprintf_r+0x1efe>
80009672:	fa c3 f9 e0 	sub	r3,sp,-1568
80009676:	21 02       	sub	r2,16
80009678:	c0 38       	rjmp	8000967e <_vfprintf_r+0x1ad2>
8000967a:	fe c0 bd 66 	sub	r0,pc,-17050
8000967e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009682:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009686:	fe ca bd 72 	sub	r10,pc,-17038
8000968a:	59 02       	cp.w	r2,16
8000968c:	fe 99 ff dd 	brgt	80009646 <_vfprintf_r+0x1a9a>
80009690:	04 09       	add	r9,r2
80009692:	2f f8       	sub	r8,-1
80009694:	87 0a       	st.w	r3[0x0],r10
80009696:	fb 49 06 90 	st.w	sp[1680],r9
8000969a:	87 12       	st.w	r3[0x4],r2
8000969c:	fb 48 06 8c 	st.w	sp[1676],r8
800096a0:	58 78       	cp.w	r8,7
800096a2:	e0 89 00 04 	brgt	800096aa <_vfprintf_r+0x1afe>
800096a6:	2f 83       	sub	r3,-8
800096a8:	c0 b8       	rjmp	800096be <_vfprintf_r+0x1b12>
800096aa:	fa ca f9 78 	sub	r10,sp,-1672
800096ae:	02 9b       	mov	r11,r1
800096b0:	08 9c       	mov	r12,r4
800096b2:	fe b0 f2 6f 	rcall	80007b90 <__sprint_r>
800096b6:	e0 81 01 fa 	brne	80009aaa <_vfprintf_r+0x1efe>
800096ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800096be:	40 6c       	lddsp	r12,sp[0x18]
800096c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800096c4:	87 06       	st.w	r3[0x0],r6
800096c6:	87 1c       	st.w	r3[0x4],r12
800096c8:	18 08       	add	r8,r12
800096ca:	cb 98       	rjmp	8000983c <_vfprintf_r+0x1c90>
800096cc:	fa f9 06 90 	ld.w	r9,sp[1680]
800096d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096d4:	40 6b       	lddsp	r11,sp[0x18]
800096d6:	16 3a       	cp.w	r10,r11
800096d8:	c6 f5       	brlt	800097b6 <_vfprintf_r+0x1c0a>
800096da:	16 09       	add	r9,r11
800096dc:	2f f8       	sub	r8,-1
800096de:	87 06       	st.w	r3[0x0],r6
800096e0:	fb 49 06 90 	st.w	sp[1680],r9
800096e4:	87 1b       	st.w	r3[0x4],r11
800096e6:	fb 48 06 8c 	st.w	sp[1676],r8
800096ea:	58 78       	cp.w	r8,7
800096ec:	e0 89 00 04 	brgt	800096f4 <_vfprintf_r+0x1b48>
800096f0:	2f 83       	sub	r3,-8
800096f2:	c0 b8       	rjmp	80009708 <_vfprintf_r+0x1b5c>
800096f4:	fa ca f9 78 	sub	r10,sp,-1672
800096f8:	02 9b       	mov	r11,r1
800096fa:	08 9c       	mov	r12,r4
800096fc:	fe b0 f2 4a 	rcall	80007b90 <__sprint_r>
80009700:	e0 81 01 d5 	brne	80009aaa <_vfprintf_r+0x1efe>
80009704:	fa c3 f9 e0 	sub	r3,sp,-1568
80009708:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000970c:	40 6a       	lddsp	r10,sp[0x18]
8000970e:	14 16       	sub	r6,r10
80009710:	58 06       	cp.w	r6,0
80009712:	e0 89 00 1c 	brgt	8000974a <_vfprintf_r+0x1b9e>
80009716:	c3 d8       	rjmp	80009790 <_vfprintf_r+0x1be4>
80009718:	2f 09       	sub	r9,-16
8000971a:	2f f8       	sub	r8,-1
8000971c:	fb 49 06 90 	st.w	sp[1680],r9
80009720:	87 02       	st.w	r3[0x0],r2
80009722:	87 10       	st.w	r3[0x4],r0
80009724:	fb 48 06 8c 	st.w	sp[1676],r8
80009728:	58 78       	cp.w	r8,7
8000972a:	e0 89 00 04 	brgt	80009732 <_vfprintf_r+0x1b86>
8000972e:	2f 83       	sub	r3,-8
80009730:	c0 b8       	rjmp	80009746 <_vfprintf_r+0x1b9a>
80009732:	fa ca f9 78 	sub	r10,sp,-1672
80009736:	02 9b       	mov	r11,r1
80009738:	08 9c       	mov	r12,r4
8000973a:	fe b0 f2 2b 	rcall	80007b90 <__sprint_r>
8000973e:	e0 81 01 b6 	brne	80009aaa <_vfprintf_r+0x1efe>
80009742:	fa c3 f9 e0 	sub	r3,sp,-1568
80009746:	21 06       	sub	r6,16
80009748:	c0 48       	rjmp	80009750 <_vfprintf_r+0x1ba4>
8000974a:	fe c2 be 36 	sub	r2,pc,-16842
8000974e:	31 00       	mov	r0,16
80009750:	fa f9 06 90 	ld.w	r9,sp[1680]
80009754:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009758:	fe ca be 44 	sub	r10,pc,-16828
8000975c:	59 06       	cp.w	r6,16
8000975e:	fe 99 ff dd 	brgt	80009718 <_vfprintf_r+0x1b6c>
80009762:	0c 09       	add	r9,r6
80009764:	2f f8       	sub	r8,-1
80009766:	87 0a       	st.w	r3[0x0],r10
80009768:	fb 49 06 90 	st.w	sp[1680],r9
8000976c:	87 16       	st.w	r3[0x4],r6
8000976e:	fb 48 06 8c 	st.w	sp[1676],r8
80009772:	58 78       	cp.w	r8,7
80009774:	e0 89 00 04 	brgt	8000977c <_vfprintf_r+0x1bd0>
80009778:	2f 83       	sub	r3,-8
8000977a:	c0 b8       	rjmp	80009790 <_vfprintf_r+0x1be4>
8000977c:	fa ca f9 78 	sub	r10,sp,-1672
80009780:	02 9b       	mov	r11,r1
80009782:	08 9c       	mov	r12,r4
80009784:	fe b0 f2 06 	rcall	80007b90 <__sprint_r>
80009788:	e0 81 01 91 	brne	80009aaa <_vfprintf_r+0x1efe>
8000978c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009790:	ed b5 00 00 	bld	r5,0x0
80009794:	e0 81 01 20 	brne	800099d4 <_vfprintf_r+0x1e28>
80009798:	40 c9       	lddsp	r9,sp[0x30]
8000979a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000979e:	2f f8       	sub	r8,-1
800097a0:	87 09       	st.w	r3[0x0],r9
800097a2:	fb 48 06 90 	st.w	sp[1680],r8
800097a6:	30 19       	mov	r9,1
800097a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ac:	87 19       	st.w	r3[0x4],r9
800097ae:	2f f8       	sub	r8,-1
800097b0:	fb 48 06 8c 	st.w	sp[1676],r8
800097b4:	c0 29       	rjmp	800099b8 <_vfprintf_r+0x1e0c>
800097b6:	14 09       	add	r9,r10
800097b8:	2f f8       	sub	r8,-1
800097ba:	fb 49 06 90 	st.w	sp[1680],r9
800097be:	87 06       	st.w	r3[0x0],r6
800097c0:	87 1a       	st.w	r3[0x4],r10
800097c2:	fb 48 06 8c 	st.w	sp[1676],r8
800097c6:	58 78       	cp.w	r8,7
800097c8:	e0 89 00 04 	brgt	800097d0 <_vfprintf_r+0x1c24>
800097cc:	2f 83       	sub	r3,-8
800097ce:	c0 b8       	rjmp	800097e4 <_vfprintf_r+0x1c38>
800097d0:	fa ca f9 78 	sub	r10,sp,-1672
800097d4:	02 9b       	mov	r11,r1
800097d6:	08 9c       	mov	r12,r4
800097d8:	fe b0 f1 dc 	rcall	80007b90 <__sprint_r>
800097dc:	e0 81 01 67 	brne	80009aaa <_vfprintf_r+0x1efe>
800097e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e4:	40 c8       	lddsp	r8,sp[0x30]
800097e6:	87 08       	st.w	r3[0x0],r8
800097e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ec:	2f f8       	sub	r8,-1
800097ee:	30 19       	mov	r9,1
800097f0:	fb 48 06 90 	st.w	sp[1680],r8
800097f4:	87 19       	st.w	r3[0x4],r9
800097f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097fa:	2f f8       	sub	r8,-1
800097fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009800:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009804:	58 78       	cp.w	r8,7
80009806:	e0 89 00 04 	brgt	8000980e <_vfprintf_r+0x1c62>
8000980a:	2f 83       	sub	r3,-8
8000980c:	c0 b8       	rjmp	80009822 <_vfprintf_r+0x1c76>
8000980e:	fa ca f9 78 	sub	r10,sp,-1672
80009812:	02 9b       	mov	r11,r1
80009814:	08 9c       	mov	r12,r4
80009816:	fe b0 f1 bd 	rcall	80007b90 <__sprint_r>
8000981a:	e0 81 01 48 	brne	80009aaa <_vfprintf_r+0x1efe>
8000981e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009822:	04 06       	add	r6,r2
80009824:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009828:	87 06       	st.w	r3[0x0],r6
8000982a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000982e:	40 66       	lddsp	r6,sp[0x18]
80009830:	40 6e       	lddsp	lr,sp[0x18]
80009832:	10 16       	sub	r6,r8
80009834:	f2 08 01 08 	sub	r8,r9,r8
80009838:	87 16       	st.w	r3[0x4],r6
8000983a:	1c 08       	add	r8,lr
8000983c:	fb 48 06 90 	st.w	sp[1680],r8
80009840:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009844:	2f f8       	sub	r8,-1
80009846:	fb 48 06 8c 	st.w	sp[1676],r8
8000984a:	cb 78       	rjmp	800099b8 <_vfprintf_r+0x1e0c>
8000984c:	40 6c       	lddsp	r12,sp[0x18]
8000984e:	58 1c       	cp.w	r12,1
80009850:	e0 89 00 06 	brgt	8000985c <_vfprintf_r+0x1cb0>
80009854:	ed b5 00 00 	bld	r5,0x0
80009858:	e0 81 00 85 	brne	80009962 <_vfprintf_r+0x1db6>
8000985c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009860:	2f f8       	sub	r8,-1
80009862:	30 19       	mov	r9,1
80009864:	fb 48 06 90 	st.w	sp[1680],r8
80009868:	87 06       	st.w	r3[0x0],r6
8000986a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000986e:	87 19       	st.w	r3[0x4],r9
80009870:	2f f8       	sub	r8,-1
80009872:	fb 48 06 8c 	st.w	sp[1676],r8
80009876:	58 78       	cp.w	r8,7
80009878:	e0 89 00 04 	brgt	80009880 <_vfprintf_r+0x1cd4>
8000987c:	2f 83       	sub	r3,-8
8000987e:	c0 b8       	rjmp	80009894 <_vfprintf_r+0x1ce8>
80009880:	fa ca f9 78 	sub	r10,sp,-1672
80009884:	02 9b       	mov	r11,r1
80009886:	08 9c       	mov	r12,r4
80009888:	fe b0 f1 84 	rcall	80007b90 <__sprint_r>
8000988c:	e0 81 01 0f 	brne	80009aaa <_vfprintf_r+0x1efe>
80009890:	fa c3 f9 e0 	sub	r3,sp,-1568
80009894:	fa f8 06 90 	ld.w	r8,sp[1680]
80009898:	2f f8       	sub	r8,-1
8000989a:	40 cb       	lddsp	r11,sp[0x30]
8000989c:	fb 48 06 90 	st.w	sp[1680],r8
800098a0:	30 19       	mov	r9,1
800098a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098a6:	87 0b       	st.w	r3[0x0],r11
800098a8:	2f f8       	sub	r8,-1
800098aa:	87 19       	st.w	r3[0x4],r9
800098ac:	fb 48 06 8c 	st.w	sp[1676],r8
800098b0:	58 78       	cp.w	r8,7
800098b2:	e0 89 00 05 	brgt	800098bc <_vfprintf_r+0x1d10>
800098b6:	2f 83       	sub	r3,-8
800098b8:	c0 c8       	rjmp	800098d0 <_vfprintf_r+0x1d24>
800098ba:	d7 03       	nop
800098bc:	fa ca f9 78 	sub	r10,sp,-1672
800098c0:	02 9b       	mov	r11,r1
800098c2:	08 9c       	mov	r12,r4
800098c4:	fe b0 f1 66 	rcall	80007b90 <__sprint_r>
800098c8:	e0 81 00 f1 	brne	80009aaa <_vfprintf_r+0x1efe>
800098cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d0:	30 08       	mov	r8,0
800098d2:	30 09       	mov	r9,0
800098d4:	40 5b       	lddsp	r11,sp[0x14]
800098d6:	40 7a       	lddsp	r10,sp[0x1c]
800098d8:	e0 a0 13 25 	rcall	8000bf22 <__avr32_f64_cmp_eq>
800098dc:	40 68       	lddsp	r8,sp[0x18]
800098de:	20 18       	sub	r8,1
800098e0:	58 0c       	cp.w	r12,0
800098e2:	c0 d1       	brne	800098fc <_vfprintf_r+0x1d50>
800098e4:	2f f6       	sub	r6,-1
800098e6:	87 18       	st.w	r3[0x4],r8
800098e8:	87 06       	st.w	r3[0x0],r6
800098ea:	fa f6 06 90 	ld.w	r6,sp[1680]
800098ee:	10 06       	add	r6,r8
800098f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098f4:	fb 46 06 90 	st.w	sp[1680],r6
800098f8:	2f f8       	sub	r8,-1
800098fa:	c3 18       	rjmp	8000995c <_vfprintf_r+0x1db0>
800098fc:	10 96       	mov	r6,r8
800098fe:	58 08       	cp.w	r8,0
80009900:	e0 89 00 1c 	brgt	80009938 <_vfprintf_r+0x1d8c>
80009904:	c4 b8       	rjmp	8000999a <_vfprintf_r+0x1dee>
80009906:	2f 09       	sub	r9,-16
80009908:	2f f8       	sub	r8,-1
8000990a:	fb 49 06 90 	st.w	sp[1680],r9
8000990e:	87 02       	st.w	r3[0x0],r2
80009910:	87 10       	st.w	r3[0x4],r0
80009912:	fb 48 06 8c 	st.w	sp[1676],r8
80009916:	58 78       	cp.w	r8,7
80009918:	e0 89 00 04 	brgt	80009920 <_vfprintf_r+0x1d74>
8000991c:	2f 83       	sub	r3,-8
8000991e:	c0 b8       	rjmp	80009934 <_vfprintf_r+0x1d88>
80009920:	fa ca f9 78 	sub	r10,sp,-1672
80009924:	02 9b       	mov	r11,r1
80009926:	08 9c       	mov	r12,r4
80009928:	fe b0 f1 34 	rcall	80007b90 <__sprint_r>
8000992c:	e0 81 00 bf 	brne	80009aaa <_vfprintf_r+0x1efe>
80009930:	fa c3 f9 e0 	sub	r3,sp,-1568
80009934:	21 06       	sub	r6,16
80009936:	c0 48       	rjmp	8000993e <_vfprintf_r+0x1d92>
80009938:	fe c2 c0 24 	sub	r2,pc,-16348
8000993c:	31 00       	mov	r0,16
8000993e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009942:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009946:	fe ca c0 32 	sub	r10,pc,-16334
8000994a:	59 06       	cp.w	r6,16
8000994c:	fe 99 ff dd 	brgt	80009906 <_vfprintf_r+0x1d5a>
80009950:	0c 09       	add	r9,r6
80009952:	87 0a       	st.w	r3[0x0],r10
80009954:	fb 49 06 90 	st.w	sp[1680],r9
80009958:	2f f8       	sub	r8,-1
8000995a:	87 16       	st.w	r3[0x4],r6
8000995c:	fb 48 06 8c 	st.w	sp[1676],r8
80009960:	c0 e8       	rjmp	8000997c <_vfprintf_r+0x1dd0>
80009962:	fa f8 06 90 	ld.w	r8,sp[1680]
80009966:	2f f8       	sub	r8,-1
80009968:	30 19       	mov	r9,1
8000996a:	fb 48 06 90 	st.w	sp[1680],r8
8000996e:	87 06       	st.w	r3[0x0],r6
80009970:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009974:	87 19       	st.w	r3[0x4],r9
80009976:	2f f8       	sub	r8,-1
80009978:	fb 48 06 8c 	st.w	sp[1676],r8
8000997c:	58 78       	cp.w	r8,7
8000997e:	e0 89 00 04 	brgt	80009986 <_vfprintf_r+0x1dda>
80009982:	2f 83       	sub	r3,-8
80009984:	c0 b8       	rjmp	8000999a <_vfprintf_r+0x1dee>
80009986:	fa ca f9 78 	sub	r10,sp,-1672
8000998a:	02 9b       	mov	r11,r1
8000998c:	08 9c       	mov	r12,r4
8000998e:	fe b0 f1 01 	rcall	80007b90 <__sprint_r>
80009992:	e0 81 00 8c 	brne	80009aaa <_vfprintf_r+0x1efe>
80009996:	fa c3 f9 e0 	sub	r3,sp,-1568
8000999a:	40 ea       	lddsp	r10,sp[0x38]
8000999c:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a0:	14 08       	add	r8,r10
800099a2:	fa c9 f9 64 	sub	r9,sp,-1692
800099a6:	fb 48 06 90 	st.w	sp[1680],r8
800099aa:	87 1a       	st.w	r3[0x4],r10
800099ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b0:	87 09       	st.w	r3[0x0],r9
800099b2:	2f f8       	sub	r8,-1
800099b4:	fb 48 06 8c 	st.w	sp[1676],r8
800099b8:	58 78       	cp.w	r8,7
800099ba:	e0 89 00 04 	brgt	800099c2 <_vfprintf_r+0x1e16>
800099be:	2f 83       	sub	r3,-8
800099c0:	c0 a8       	rjmp	800099d4 <_vfprintf_r+0x1e28>
800099c2:	fa ca f9 78 	sub	r10,sp,-1672
800099c6:	02 9b       	mov	r11,r1
800099c8:	08 9c       	mov	r12,r4
800099ca:	fe b0 f0 e3 	rcall	80007b90 <__sprint_r>
800099ce:	c6 e1       	brne	80009aaa <_vfprintf_r+0x1efe>
800099d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d4:	e2 15 00 04 	andl	r5,0x4,COH
800099d8:	c3 f0       	breq	80009a56 <_vfprintf_r+0x1eaa>
800099da:	40 86       	lddsp	r6,sp[0x20]
800099dc:	40 39       	lddsp	r9,sp[0xc]
800099de:	12 16       	sub	r6,r9
800099e0:	58 06       	cp.w	r6,0
800099e2:	e0 89 00 1a 	brgt	80009a16 <_vfprintf_r+0x1e6a>
800099e6:	c3 88       	rjmp	80009a56 <_vfprintf_r+0x1eaa>
800099e8:	2f 09       	sub	r9,-16
800099ea:	2f f8       	sub	r8,-1
800099ec:	fb 49 06 90 	st.w	sp[1680],r9
800099f0:	87 05       	st.w	r3[0x0],r5
800099f2:	87 12       	st.w	r3[0x4],r2
800099f4:	fb 48 06 8c 	st.w	sp[1676],r8
800099f8:	58 78       	cp.w	r8,7
800099fa:	e0 89 00 04 	brgt	80009a02 <_vfprintf_r+0x1e56>
800099fe:	2f 83       	sub	r3,-8
80009a00:	c0 98       	rjmp	80009a12 <_vfprintf_r+0x1e66>
80009a02:	00 9a       	mov	r10,r0
80009a04:	02 9b       	mov	r11,r1
80009a06:	08 9c       	mov	r12,r4
80009a08:	fe b0 f0 c4 	rcall	80007b90 <__sprint_r>
80009a0c:	c4 f1       	brne	80009aaa <_vfprintf_r+0x1efe>
80009a0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a12:	21 06       	sub	r6,16
80009a14:	c0 68       	rjmp	80009a20 <_vfprintf_r+0x1e74>
80009a16:	fe c5 c1 12 	sub	r5,pc,-16110
80009a1a:	31 02       	mov	r2,16
80009a1c:	fa c0 f9 78 	sub	r0,sp,-1672
80009a20:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a28:	fe ca c1 24 	sub	r10,pc,-16092
80009a2c:	59 06       	cp.w	r6,16
80009a2e:	fe 99 ff dd 	brgt	800099e8 <_vfprintf_r+0x1e3c>
80009a32:	0c 09       	add	r9,r6
80009a34:	2f f8       	sub	r8,-1
80009a36:	87 0a       	st.w	r3[0x0],r10
80009a38:	87 16       	st.w	r3[0x4],r6
80009a3a:	fb 49 06 90 	st.w	sp[1680],r9
80009a3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a42:	58 78       	cp.w	r8,7
80009a44:	e0 8a 00 09 	brle	80009a56 <_vfprintf_r+0x1eaa>
80009a48:	fa ca f9 78 	sub	r10,sp,-1672
80009a4c:	02 9b       	mov	r11,r1
80009a4e:	08 9c       	mov	r12,r4
80009a50:	fe b0 f0 a0 	rcall	80007b90 <__sprint_r>
80009a54:	c2 b1       	brne	80009aaa <_vfprintf_r+0x1efe>
80009a56:	40 bc       	lddsp	r12,sp[0x2c]
80009a58:	40 36       	lddsp	r6,sp[0xc]
80009a5a:	40 8e       	lddsp	lr,sp[0x20]
80009a5c:	ec 0e 0c 48 	max	r8,r6,lr
80009a60:	10 0c       	add	r12,r8
80009a62:	50 bc       	stdsp	sp[0x2c],r12
80009a64:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a68:	58 08       	cp.w	r8,0
80009a6a:	c0 80       	breq	80009a7a <_vfprintf_r+0x1ece>
80009a6c:	fa ca f9 78 	sub	r10,sp,-1672
80009a70:	02 9b       	mov	r11,r1
80009a72:	08 9c       	mov	r12,r4
80009a74:	fe b0 f0 8e 	rcall	80007b90 <__sprint_r>
80009a78:	c1 91       	brne	80009aaa <_vfprintf_r+0x1efe>
80009a7a:	30 0b       	mov	r11,0
80009a7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a80:	fb 4b 06 8c 	st.w	sp[1676],r11
80009a84:	fe 9f f1 22 	bral	80007cc8 <_vfprintf_r+0x11c>
80009a88:	08 95       	mov	r5,r4
80009a8a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a8e:	58 08       	cp.w	r8,0
80009a90:	c0 80       	breq	80009aa0 <_vfprintf_r+0x1ef4>
80009a92:	08 9c       	mov	r12,r4
80009a94:	fa ca f9 78 	sub	r10,sp,-1672
80009a98:	02 9b       	mov	r11,r1
80009a9a:	fe b0 f0 7b 	rcall	80007b90 <__sprint_r>
80009a9e:	c0 61       	brne	80009aaa <_vfprintf_r+0x1efe>
80009aa0:	30 08       	mov	r8,0
80009aa2:	fb 48 06 8c 	st.w	sp[1676],r8
80009aa6:	c0 28       	rjmp	80009aaa <_vfprintf_r+0x1efe>
80009aa8:	40 41       	lddsp	r1,sp[0x10]
80009aaa:	82 68       	ld.sh	r8,r1[0xc]
80009aac:	ed b8 00 06 	bld	r8,0x6
80009ab0:	c0 31       	brne	80009ab6 <_vfprintf_r+0x1f0a>
80009ab2:	3f fa       	mov	r10,-1
80009ab4:	50 ba       	stdsp	sp[0x2c],r10
80009ab6:	40 bc       	lddsp	r12,sp[0x2c]
80009ab8:	fe 3d f9 44 	sub	sp,-1724
80009abc:	d8 32       	popm	r0-r7,pc
80009abe:	d7 03       	nop

80009ac0 <__swsetup_r>:
80009ac0:	d4 21       	pushm	r4-r7,lr
80009ac2:	e0 68 0a 38 	mov	r8,2616
80009ac6:	18 96       	mov	r6,r12
80009ac8:	16 97       	mov	r7,r11
80009aca:	70 0c       	ld.w	r12,r8[0x0]
80009acc:	58 0c       	cp.w	r12,0
80009ace:	c0 60       	breq	80009ada <__swsetup_r+0x1a>
80009ad0:	78 68       	ld.w	r8,r12[0x18]
80009ad2:	58 08       	cp.w	r8,0
80009ad4:	c0 31       	brne	80009ada <__swsetup_r+0x1a>
80009ad6:	e0 a0 07 bf 	rcall	8000aa54 <__sinit>
80009ada:	fe c8 c0 a6 	sub	r8,pc,-16218
80009ade:	10 37       	cp.w	r7,r8
80009ae0:	c0 61       	brne	80009aec <__swsetup_r+0x2c>
80009ae2:	e0 68 0a 38 	mov	r8,2616
80009ae6:	70 08       	ld.w	r8,r8[0x0]
80009ae8:	70 07       	ld.w	r7,r8[0x0]
80009aea:	c1 28       	rjmp	80009b0e <__swsetup_r+0x4e>
80009aec:	fe c8 c0 98 	sub	r8,pc,-16232
80009af0:	10 37       	cp.w	r7,r8
80009af2:	c0 61       	brne	80009afe <__swsetup_r+0x3e>
80009af4:	e0 68 0a 38 	mov	r8,2616
80009af8:	70 08       	ld.w	r8,r8[0x0]
80009afa:	70 17       	ld.w	r7,r8[0x4]
80009afc:	c0 98       	rjmp	80009b0e <__swsetup_r+0x4e>
80009afe:	fe c8 c0 8a 	sub	r8,pc,-16246
80009b02:	10 37       	cp.w	r7,r8
80009b04:	c0 51       	brne	80009b0e <__swsetup_r+0x4e>
80009b06:	e0 68 0a 38 	mov	r8,2616
80009b0a:	70 08       	ld.w	r8,r8[0x0]
80009b0c:	70 27       	ld.w	r7,r8[0x8]
80009b0e:	8e 68       	ld.sh	r8,r7[0xc]
80009b10:	ed b8 00 03 	bld	r8,0x3
80009b14:	c1 e0       	breq	80009b50 <__swsetup_r+0x90>
80009b16:	ed b8 00 04 	bld	r8,0x4
80009b1a:	c3 e1       	brne	80009b96 <__swsetup_r+0xd6>
80009b1c:	ed b8 00 02 	bld	r8,0x2
80009b20:	c1 51       	brne	80009b4a <__swsetup_r+0x8a>
80009b22:	6e db       	ld.w	r11,r7[0x34]
80009b24:	58 0b       	cp.w	r11,0
80009b26:	c0 a0       	breq	80009b3a <__swsetup_r+0x7a>
80009b28:	ee c8 ff bc 	sub	r8,r7,-68
80009b2c:	10 3b       	cp.w	r11,r8
80009b2e:	c0 40       	breq	80009b36 <__swsetup_r+0x76>
80009b30:	0c 9c       	mov	r12,r6
80009b32:	e0 a0 08 2b 	rcall	8000ab88 <_free_r>
80009b36:	30 08       	mov	r8,0
80009b38:	8f d8       	st.w	r7[0x34],r8
80009b3a:	8e 68       	ld.sh	r8,r7[0xc]
80009b3c:	e0 18 ff db 	andl	r8,0xffdb
80009b40:	ae 68       	st.h	r7[0xc],r8
80009b42:	30 08       	mov	r8,0
80009b44:	8f 18       	st.w	r7[0x4],r8
80009b46:	6e 48       	ld.w	r8,r7[0x10]
80009b48:	8f 08       	st.w	r7[0x0],r8
80009b4a:	8e 68       	ld.sh	r8,r7[0xc]
80009b4c:	a3 b8       	sbr	r8,0x3
80009b4e:	ae 68       	st.h	r7[0xc],r8
80009b50:	6e 48       	ld.w	r8,r7[0x10]
80009b52:	58 08       	cp.w	r8,0
80009b54:	c0 b1       	brne	80009b6a <__swsetup_r+0xaa>
80009b56:	8e 68       	ld.sh	r8,r7[0xc]
80009b58:	e2 18 02 80 	andl	r8,0x280,COH
80009b5c:	e0 48 02 00 	cp.w	r8,512
80009b60:	c0 50       	breq	80009b6a <__swsetup_r+0xaa>
80009b62:	0c 9c       	mov	r12,r6
80009b64:	0e 9b       	mov	r11,r7
80009b66:	e0 a0 0a 4b 	rcall	8000affc <__smakebuf_r>
80009b6a:	8e 69       	ld.sh	r9,r7[0xc]
80009b6c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009b70:	c0 70       	breq	80009b7e <__swsetup_r+0xbe>
80009b72:	30 08       	mov	r8,0
80009b74:	8f 28       	st.w	r7[0x8],r8
80009b76:	6e 58       	ld.w	r8,r7[0x14]
80009b78:	5c 38       	neg	r8
80009b7a:	8f 68       	st.w	r7[0x18],r8
80009b7c:	c0 68       	rjmp	80009b88 <__swsetup_r+0xc8>
80009b7e:	ed b9 00 01 	bld	r9,0x1
80009b82:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009b86:	8f 28       	st.w	r7[0x8],r8
80009b88:	6e 48       	ld.w	r8,r7[0x10]
80009b8a:	58 08       	cp.w	r8,0
80009b8c:	c0 61       	brne	80009b98 <__swsetup_r+0xd8>
80009b8e:	8e 68       	ld.sh	r8,r7[0xc]
80009b90:	ed b8 00 07 	bld	r8,0x7
80009b94:	c0 21       	brne	80009b98 <__swsetup_r+0xd8>
80009b96:	dc 2a       	popm	r4-r7,pc,r12=-1
80009b98:	d8 2a       	popm	r4-r7,pc,r12=0
80009b9a:	d7 03       	nop

80009b9c <quorem>:
80009b9c:	d4 31       	pushm	r0-r7,lr
80009b9e:	20 2d       	sub	sp,8
80009ba0:	18 97       	mov	r7,r12
80009ba2:	78 48       	ld.w	r8,r12[0x10]
80009ba4:	76 46       	ld.w	r6,r11[0x10]
80009ba6:	0c 38       	cp.w	r8,r6
80009ba8:	c0 34       	brge	80009bae <quorem+0x12>
80009baa:	30 0c       	mov	r12,0
80009bac:	c8 58       	rjmp	80009cb6 <quorem+0x11a>
80009bae:	ec c2 ff fc 	sub	r2,r6,-4
80009bb2:	f6 c3 ff ec 	sub	r3,r11,-20
80009bb6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009bba:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009bbe:	2f f9       	sub	r9,-1
80009bc0:	20 16       	sub	r6,1
80009bc2:	f8 09 0d 08 	divu	r8,r12,r9
80009bc6:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009bca:	ee c4 ff ec 	sub	r4,r7,-20
80009bce:	10 95       	mov	r5,r8
80009bd0:	58 08       	cp.w	r8,0
80009bd2:	c4 10       	breq	80009c54 <quorem+0xb8>
80009bd4:	30 09       	mov	r9,0
80009bd6:	06 9a       	mov	r10,r3
80009bd8:	08 98       	mov	r8,r4
80009bda:	12 91       	mov	r1,r9
80009bdc:	50 0b       	stdsp	sp[0x0],r11
80009bde:	70 0e       	ld.w	lr,r8[0x0]
80009be0:	b1 8e       	lsr	lr,0x10
80009be2:	50 1e       	stdsp	sp[0x4],lr
80009be4:	15 0e       	ld.w	lr,r10++
80009be6:	fc 00 16 10 	lsr	r0,lr,0x10
80009bea:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009bee:	ea 0e 03 41 	mac	r1,r5,lr
80009bf2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009bf6:	b1 81       	lsr	r1,0x10
80009bf8:	40 1b       	lddsp	r11,sp[0x4]
80009bfa:	ea 00 02 40 	mul	r0,r5,r0
80009bfe:	e2 00 00 00 	add	r0,r1,r0
80009c02:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009c06:	02 1b       	sub	r11,r1
80009c08:	50 1b       	stdsp	sp[0x4],r11
80009c0a:	70 0b       	ld.w	r11,r8[0x0]
80009c0c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009c10:	02 09       	add	r9,r1
80009c12:	f2 0e 01 0e 	sub	lr,r9,lr
80009c16:	b0 1e       	st.h	r8[0x2],lr
80009c18:	fc 09 14 10 	asr	r9,lr,0x10
80009c1c:	40 1e       	lddsp	lr,sp[0x4]
80009c1e:	fc 09 00 09 	add	r9,lr,r9
80009c22:	b0 09       	st.h	r8[0x0],r9
80009c24:	e0 01 16 10 	lsr	r1,r0,0x10
80009c28:	2f c8       	sub	r8,-4
80009c2a:	b1 49       	asr	r9,0x10
80009c2c:	04 3a       	cp.w	r10,r2
80009c2e:	fe 98 ff d8 	brls	80009bde <quorem+0x42>
80009c32:	40 0b       	lddsp	r11,sp[0x0]
80009c34:	58 0c       	cp.w	r12,0
80009c36:	c0 f1       	brne	80009c54 <quorem+0xb8>
80009c38:	ec c8 ff fb 	sub	r8,r6,-5
80009c3c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c40:	c0 28       	rjmp	80009c44 <quorem+0xa8>
80009c42:	20 16       	sub	r6,1
80009c44:	20 48       	sub	r8,4
80009c46:	08 38       	cp.w	r8,r4
80009c48:	e0 88 00 05 	brls	80009c52 <quorem+0xb6>
80009c4c:	70 09       	ld.w	r9,r8[0x0]
80009c4e:	58 09       	cp.w	r9,0
80009c50:	cf 90       	breq	80009c42 <quorem+0xa6>
80009c52:	8f 46       	st.w	r7[0x10],r6
80009c54:	0e 9c       	mov	r12,r7
80009c56:	e0 a0 0a d2 	rcall	8000b1fa <__mcmp>
80009c5a:	c2 d5       	brlt	80009cb4 <quorem+0x118>
80009c5c:	2f f5       	sub	r5,-1
80009c5e:	08 98       	mov	r8,r4
80009c60:	30 09       	mov	r9,0
80009c62:	07 0b       	ld.w	r11,r3++
80009c64:	f6 0a 16 10 	lsr	r10,r11,0x10
80009c68:	70 0c       	ld.w	r12,r8[0x0]
80009c6a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009c6e:	f8 0e 16 10 	lsr	lr,r12,0x10
80009c72:	14 1e       	sub	lr,r10
80009c74:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009c78:	16 1a       	sub	r10,r11
80009c7a:	12 0a       	add	r10,r9
80009c7c:	b0 1a       	st.h	r8[0x2],r10
80009c7e:	b1 4a       	asr	r10,0x10
80009c80:	fc 0a 00 09 	add	r9,lr,r10
80009c84:	b0 09       	st.h	r8[0x0],r9
80009c86:	2f c8       	sub	r8,-4
80009c88:	b1 49       	asr	r9,0x10
80009c8a:	04 33       	cp.w	r3,r2
80009c8c:	fe 98 ff eb 	brls	80009c62 <quorem+0xc6>
80009c90:	ec c8 ff fb 	sub	r8,r6,-5
80009c94:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009c98:	58 09       	cp.w	r9,0
80009c9a:	c0 d1       	brne	80009cb4 <quorem+0x118>
80009c9c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ca0:	c0 28       	rjmp	80009ca4 <quorem+0x108>
80009ca2:	20 16       	sub	r6,1
80009ca4:	20 48       	sub	r8,4
80009ca6:	08 38       	cp.w	r8,r4
80009ca8:	e0 88 00 05 	brls	80009cb2 <quorem+0x116>
80009cac:	70 09       	ld.w	r9,r8[0x0]
80009cae:	58 09       	cp.w	r9,0
80009cb0:	cf 90       	breq	80009ca2 <quorem+0x106>
80009cb2:	8f 46       	st.w	r7[0x10],r6
80009cb4:	0a 9c       	mov	r12,r5
80009cb6:	2f ed       	sub	sp,-8
80009cb8:	d8 32       	popm	r0-r7,pc
80009cba:	d7 03       	nop

80009cbc <_dtoa_r>:
80009cbc:	d4 31       	pushm	r0-r7,lr
80009cbe:	21 ad       	sub	sp,104
80009cc0:	fa c4 ff 74 	sub	r4,sp,-140
80009cc4:	18 97       	mov	r7,r12
80009cc6:	16 95       	mov	r5,r11
80009cc8:	68 2c       	ld.w	r12,r4[0x8]
80009cca:	50 c9       	stdsp	sp[0x30],r9
80009ccc:	68 16       	ld.w	r6,r4[0x4]
80009cce:	68 09       	ld.w	r9,r4[0x0]
80009cd0:	50 e8       	stdsp	sp[0x38],r8
80009cd2:	14 94       	mov	r4,r10
80009cd4:	51 2c       	stdsp	sp[0x48],r12
80009cd6:	fa e5 00 08 	st.d	sp[8],r4
80009cda:	51 59       	stdsp	sp[0x54],r9
80009cdc:	6e 95       	ld.w	r5,r7[0x24]
80009cde:	58 05       	cp.w	r5,0
80009ce0:	c0 91       	brne	80009cf2 <_dtoa_r+0x36>
80009ce2:	31 0c       	mov	r12,16
80009ce4:	fe b0 e8 e2 	rcall	80006ea8 <malloc>
80009ce8:	99 35       	st.w	r12[0xc],r5
80009cea:	8f 9c       	st.w	r7[0x24],r12
80009cec:	99 15       	st.w	r12[0x4],r5
80009cee:	99 25       	st.w	r12[0x8],r5
80009cf0:	99 05       	st.w	r12[0x0],r5
80009cf2:	6e 99       	ld.w	r9,r7[0x24]
80009cf4:	72 08       	ld.w	r8,r9[0x0]
80009cf6:	58 08       	cp.w	r8,0
80009cf8:	c0 f0       	breq	80009d16 <_dtoa_r+0x5a>
80009cfa:	72 1a       	ld.w	r10,r9[0x4]
80009cfc:	91 1a       	st.w	r8[0x4],r10
80009cfe:	30 1a       	mov	r10,1
80009d00:	72 19       	ld.w	r9,r9[0x4]
80009d02:	f4 09 09 49 	lsl	r9,r10,r9
80009d06:	10 9b       	mov	r11,r8
80009d08:	91 29       	st.w	r8[0x8],r9
80009d0a:	0e 9c       	mov	r12,r7
80009d0c:	e0 a0 0a 90 	rcall	8000b22c <_Bfree>
80009d10:	6e 98       	ld.w	r8,r7[0x24]
80009d12:	30 09       	mov	r9,0
80009d14:	91 09       	st.w	r8[0x0],r9
80009d16:	40 28       	lddsp	r8,sp[0x8]
80009d18:	10 94       	mov	r4,r8
80009d1a:	58 08       	cp.w	r8,0
80009d1c:	c0 64       	brge	80009d28 <_dtoa_r+0x6c>
80009d1e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009d22:	50 28       	stdsp	sp[0x8],r8
80009d24:	30 18       	mov	r8,1
80009d26:	c0 28       	rjmp	80009d2a <_dtoa_r+0x6e>
80009d28:	30 08       	mov	r8,0
80009d2a:	8d 08       	st.w	r6[0x0],r8
80009d2c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009d30:	40 26       	lddsp	r6,sp[0x8]
80009d32:	0c 98       	mov	r8,r6
80009d34:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009d38:	18 38       	cp.w	r8,r12
80009d3a:	c2 01       	brne	80009d7a <_dtoa_r+0xbe>
80009d3c:	e0 68 27 0f 	mov	r8,9999
80009d40:	41 5b       	lddsp	r11,sp[0x54]
80009d42:	97 08       	st.w	r11[0x0],r8
80009d44:	40 3a       	lddsp	r10,sp[0xc]
80009d46:	58 0a       	cp.w	r10,0
80009d48:	c0 71       	brne	80009d56 <_dtoa_r+0x9a>
80009d4a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009d4e:	c0 41       	brne	80009d56 <_dtoa_r+0x9a>
80009d50:	fe cc c3 2c 	sub	r12,pc,-15572
80009d54:	c0 38       	rjmp	80009d5a <_dtoa_r+0x9e>
80009d56:	fe cc c3 26 	sub	r12,pc,-15578
80009d5a:	41 29       	lddsp	r9,sp[0x48]
80009d5c:	58 09       	cp.w	r9,0
80009d5e:	e0 80 05 9a 	breq	8000a892 <_dtoa_r+0xbd6>
80009d62:	f8 c8 ff fd 	sub	r8,r12,-3
80009d66:	f8 c9 ff f8 	sub	r9,r12,-8
80009d6a:	11 8b       	ld.ub	r11,r8[0x0]
80009d6c:	30 0a       	mov	r10,0
80009d6e:	41 25       	lddsp	r5,sp[0x48]
80009d70:	f4 0b 18 00 	cp.b	r11,r10
80009d74:	f2 08 17 10 	movne	r8,r9
80009d78:	c1 68       	rjmp	80009da4 <_dtoa_r+0xe8>
80009d7a:	fa ea 00 08 	ld.d	r10,sp[8]
80009d7e:	30 08       	mov	r8,0
80009d80:	fa eb 00 3c 	st.d	sp[60],r10
80009d84:	30 09       	mov	r9,0
80009d86:	e0 a0 10 ce 	rcall	8000bf22 <__avr32_f64_cmp_eq>
80009d8a:	c1 00       	breq	80009daa <_dtoa_r+0xee>
80009d8c:	30 18       	mov	r8,1
80009d8e:	41 5a       	lddsp	r10,sp[0x54]
80009d90:	95 08       	st.w	r10[0x0],r8
80009d92:	fe cc c4 92 	sub	r12,pc,-15214
80009d96:	41 29       	lddsp	r9,sp[0x48]
80009d98:	f8 08 00 08 	add	r8,r12,r8
80009d9c:	58 09       	cp.w	r9,0
80009d9e:	e0 80 05 7a 	breq	8000a892 <_dtoa_r+0xbd6>
80009da2:	12 95       	mov	r5,r9
80009da4:	8b 08       	st.w	r5[0x0],r8
80009da6:	e0 8f 05 76 	bral	8000a892 <_dtoa_r+0xbd6>
80009daa:	fa c8 ff 9c 	sub	r8,sp,-100
80009dae:	fa c9 ff a0 	sub	r9,sp,-96
80009db2:	fa ea 00 3c 	ld.d	r10,sp[60]
80009db6:	0e 9c       	mov	r12,r7
80009db8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009dbc:	e0 a0 0a 8a 	rcall	8000b2d0 <__d2b>
80009dc0:	18 93       	mov	r3,r12
80009dc2:	58 05       	cp.w	r5,0
80009dc4:	c0 d0       	breq	80009dde <_dtoa_r+0x122>
80009dc6:	fa ea 00 3c 	ld.d	r10,sp[60]
80009dca:	30 04       	mov	r4,0
80009dcc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009dd0:	ea c5 03 ff 	sub	r5,r5,1023
80009dd4:	10 9b       	mov	r11,r8
80009dd6:	51 74       	stdsp	sp[0x5c],r4
80009dd8:	ea 1b 3f f0 	orh	r11,0x3ff0
80009ddc:	c2 58       	rjmp	80009e26 <_dtoa_r+0x16a>
80009dde:	41 88       	lddsp	r8,sp[0x60]
80009de0:	41 9c       	lddsp	r12,sp[0x64]
80009de2:	10 0c       	add	r12,r8
80009de4:	f8 c5 fb ce 	sub	r5,r12,-1074
80009de8:	e0 45 00 20 	cp.w	r5,32
80009dec:	e0 8a 00 0e 	brle	80009e08 <_dtoa_r+0x14c>
80009df0:	f8 cc fb ee 	sub	r12,r12,-1042
80009df4:	40 3b       	lddsp	r11,sp[0xc]
80009df6:	ea 08 11 40 	rsub	r8,r5,64
80009dfa:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009dfe:	ec 08 09 46 	lsl	r6,r6,r8
80009e02:	0c 4c       	or	r12,r6
80009e04:	c0 78       	rjmp	80009e12 <_dtoa_r+0x156>
80009e06:	d7 03       	nop
80009e08:	ea 0c 11 20 	rsub	r12,r5,32
80009e0c:	40 3a       	lddsp	r10,sp[0xc]
80009e0e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009e12:	e0 a0 10 14 	rcall	8000be3a <__avr32_u32_to_f64>
80009e16:	fc 18 fe 10 	movh	r8,0xfe10
80009e1a:	30 19       	mov	r9,1
80009e1c:	ea c5 04 33 	sub	r5,r5,1075
80009e20:	f0 0b 00 0b 	add	r11,r8,r11
80009e24:	51 79       	stdsp	sp[0x5c],r9
80009e26:	30 08       	mov	r8,0
80009e28:	fc 19 3f f8 	movh	r9,0x3ff8
80009e2c:	e0 a0 0e 9c 	rcall	8000bb64 <__avr32_f64_sub>
80009e30:	e0 68 43 61 	mov	r8,17249
80009e34:	ea 18 63 6f 	orh	r8,0x636f
80009e38:	e0 69 87 a7 	mov	r9,34727
80009e3c:	ea 19 3f d2 	orh	r9,0x3fd2
80009e40:	e0 a0 0d a6 	rcall	8000b98c <__avr32_f64_mul>
80009e44:	e0 68 c8 b3 	mov	r8,51379
80009e48:	ea 18 8b 60 	orh	r8,0x8b60
80009e4c:	e0 69 8a 28 	mov	r9,35368
80009e50:	ea 19 3f c6 	orh	r9,0x3fc6
80009e54:	e0 a0 0f 56 	rcall	8000bd00 <__avr32_f64_add>
80009e58:	0a 9c       	mov	r12,r5
80009e5a:	14 90       	mov	r0,r10
80009e5c:	16 91       	mov	r1,r11
80009e5e:	e0 a0 0f f2 	rcall	8000be42 <__avr32_s32_to_f64>
80009e62:	e0 68 79 fb 	mov	r8,31227
80009e66:	ea 18 50 9f 	orh	r8,0x509f
80009e6a:	e0 69 44 13 	mov	r9,17427
80009e6e:	ea 19 3f d3 	orh	r9,0x3fd3
80009e72:	e0 a0 0d 8d 	rcall	8000b98c <__avr32_f64_mul>
80009e76:	14 98       	mov	r8,r10
80009e78:	16 99       	mov	r9,r11
80009e7a:	00 9a       	mov	r10,r0
80009e7c:	02 9b       	mov	r11,r1
80009e7e:	e0 a0 0f 41 	rcall	8000bd00 <__avr32_f64_add>
80009e82:	14 90       	mov	r0,r10
80009e84:	16 91       	mov	r1,r11
80009e86:	e0 a0 0f c7 	rcall	8000be14 <__avr32_f64_to_s32>
80009e8a:	30 08       	mov	r8,0
80009e8c:	18 96       	mov	r6,r12
80009e8e:	30 09       	mov	r9,0
80009e90:	00 9a       	mov	r10,r0
80009e92:	02 9b       	mov	r11,r1
80009e94:	e0 a0 10 8e 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
80009e98:	c0 c0       	breq	80009eb0 <_dtoa_r+0x1f4>
80009e9a:	0c 9c       	mov	r12,r6
80009e9c:	e0 a0 0f d3 	rcall	8000be42 <__avr32_s32_to_f64>
80009ea0:	14 98       	mov	r8,r10
80009ea2:	16 99       	mov	r9,r11
80009ea4:	00 9a       	mov	r10,r0
80009ea6:	02 9b       	mov	r11,r1
80009ea8:	e0 a0 10 3d 	rcall	8000bf22 <__avr32_f64_cmp_eq>
80009eac:	f7 b6 00 01 	subeq	r6,1
80009eb0:	59 66       	cp.w	r6,22
80009eb2:	e0 88 00 05 	brls	80009ebc <_dtoa_r+0x200>
80009eb6:	30 18       	mov	r8,1
80009eb8:	51 48       	stdsp	sp[0x50],r8
80009eba:	c1 38       	rjmp	80009ee0 <_dtoa_r+0x224>
80009ebc:	fe c8 c3 d8 	sub	r8,pc,-15400
80009ec0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ec4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009ec8:	e0 a0 10 74 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
80009ecc:	f9 b4 00 00 	moveq	r4,0
80009ed0:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009ed4:	f7 b6 01 01 	subne	r6,1
80009ed8:	f9 bc 01 00 	movne	r12,0
80009edc:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009ee0:	41 90       	lddsp	r0,sp[0x64]
80009ee2:	20 10       	sub	r0,1
80009ee4:	0a 10       	sub	r0,r5
80009ee6:	c0 46       	brmi	80009eee <_dtoa_r+0x232>
80009ee8:	50 40       	stdsp	sp[0x10],r0
80009eea:	30 00       	mov	r0,0
80009eec:	c0 48       	rjmp	80009ef4 <_dtoa_r+0x238>
80009eee:	30 0b       	mov	r11,0
80009ef0:	5c 30       	neg	r0
80009ef2:	50 4b       	stdsp	sp[0x10],r11
80009ef4:	ec 02 11 00 	rsub	r2,r6,0
80009ef8:	58 06       	cp.w	r6,0
80009efa:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009efe:	f5 d6 e4 0a 	addge	r10,r10,r6
80009f02:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009f06:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009f0a:	f9 b2 04 00 	movge	r2,0
80009f0e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009f12:	f9 b9 05 00 	movlt	r9,0
80009f16:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009f1a:	40 c8       	lddsp	r8,sp[0x30]
80009f1c:	58 98       	cp.w	r8,9
80009f1e:	e0 8b 00 20 	brhi	80009f5e <_dtoa_r+0x2a2>
80009f22:	58 58       	cp.w	r8,5
80009f24:	f9 b4 0a 01 	movle	r4,1
80009f28:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009f2c:	f7 b5 09 04 	subgt	r5,4
80009f30:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009f34:	f9 b4 09 00 	movgt	r4,0
80009f38:	40 cc       	lddsp	r12,sp[0x30]
80009f3a:	58 3c       	cp.w	r12,3
80009f3c:	c2 d0       	breq	80009f96 <_dtoa_r+0x2da>
80009f3e:	e0 89 00 05 	brgt	80009f48 <_dtoa_r+0x28c>
80009f42:	58 2c       	cp.w	r12,2
80009f44:	c1 01       	brne	80009f64 <_dtoa_r+0x2a8>
80009f46:	c1 88       	rjmp	80009f76 <_dtoa_r+0x2ba>
80009f48:	40 cb       	lddsp	r11,sp[0x30]
80009f4a:	58 4b       	cp.w	r11,4
80009f4c:	c0 60       	breq	80009f58 <_dtoa_r+0x29c>
80009f4e:	58 5b       	cp.w	r11,5
80009f50:	c0 a1       	brne	80009f64 <_dtoa_r+0x2a8>
80009f52:	30 1a       	mov	r10,1
80009f54:	50 da       	stdsp	sp[0x34],r10
80009f56:	c2 28       	rjmp	80009f9a <_dtoa_r+0x2de>
80009f58:	30 19       	mov	r9,1
80009f5a:	50 d9       	stdsp	sp[0x34],r9
80009f5c:	c0 f8       	rjmp	80009f7a <_dtoa_r+0x2be>
80009f5e:	30 08       	mov	r8,0
80009f60:	30 14       	mov	r4,1
80009f62:	50 c8       	stdsp	sp[0x30],r8
80009f64:	3f f5       	mov	r5,-1
80009f66:	30 1c       	mov	r12,1
80009f68:	30 0b       	mov	r11,0
80009f6a:	50 95       	stdsp	sp[0x24],r5
80009f6c:	50 dc       	stdsp	sp[0x34],r12
80009f6e:	0a 91       	mov	r1,r5
80009f70:	31 28       	mov	r8,18
80009f72:	50 eb       	stdsp	sp[0x38],r11
80009f74:	c2 08       	rjmp	80009fb4 <_dtoa_r+0x2f8>
80009f76:	30 0a       	mov	r10,0
80009f78:	50 da       	stdsp	sp[0x34],r10
80009f7a:	40 e9       	lddsp	r9,sp[0x38]
80009f7c:	58 09       	cp.w	r9,0
80009f7e:	e0 89 00 07 	brgt	80009f8c <_dtoa_r+0x2d0>
80009f82:	30 18       	mov	r8,1
80009f84:	50 98       	stdsp	sp[0x24],r8
80009f86:	10 91       	mov	r1,r8
80009f88:	50 e8       	stdsp	sp[0x38],r8
80009f8a:	c1 58       	rjmp	80009fb4 <_dtoa_r+0x2f8>
80009f8c:	40 e5       	lddsp	r5,sp[0x38]
80009f8e:	50 95       	stdsp	sp[0x24],r5
80009f90:	0a 91       	mov	r1,r5
80009f92:	0a 98       	mov	r8,r5
80009f94:	c1 08       	rjmp	80009fb4 <_dtoa_r+0x2f8>
80009f96:	30 0c       	mov	r12,0
80009f98:	50 dc       	stdsp	sp[0x34],r12
80009f9a:	40 eb       	lddsp	r11,sp[0x38]
80009f9c:	ec 0b 00 0b 	add	r11,r6,r11
80009fa0:	50 9b       	stdsp	sp[0x24],r11
80009fa2:	16 98       	mov	r8,r11
80009fa4:	2f f8       	sub	r8,-1
80009fa6:	58 08       	cp.w	r8,0
80009fa8:	e0 89 00 05 	brgt	80009fb2 <_dtoa_r+0x2f6>
80009fac:	10 91       	mov	r1,r8
80009fae:	30 18       	mov	r8,1
80009fb0:	c0 28       	rjmp	80009fb4 <_dtoa_r+0x2f8>
80009fb2:	10 91       	mov	r1,r8
80009fb4:	30 09       	mov	r9,0
80009fb6:	6e 9a       	ld.w	r10,r7[0x24]
80009fb8:	95 19       	st.w	r10[0x4],r9
80009fba:	30 49       	mov	r9,4
80009fbc:	c0 68       	rjmp	80009fc8 <_dtoa_r+0x30c>
80009fbe:	d7 03       	nop
80009fc0:	6a 1a       	ld.w	r10,r5[0x4]
80009fc2:	a1 79       	lsl	r9,0x1
80009fc4:	2f fa       	sub	r10,-1
80009fc6:	8b 1a       	st.w	r5[0x4],r10
80009fc8:	6e 95       	ld.w	r5,r7[0x24]
80009fca:	f2 ca ff ec 	sub	r10,r9,-20
80009fce:	10 3a       	cp.w	r10,r8
80009fd0:	fe 98 ff f8 	brls	80009fc0 <_dtoa_r+0x304>
80009fd4:	6a 1b       	ld.w	r11,r5[0x4]
80009fd6:	0e 9c       	mov	r12,r7
80009fd8:	e0 a0 09 44 	rcall	8000b260 <_Balloc>
80009fdc:	58 e1       	cp.w	r1,14
80009fde:	5f 88       	srls	r8
80009fe0:	8b 0c       	st.w	r5[0x0],r12
80009fe2:	f1 e4 00 04 	and	r4,r8,r4
80009fe6:	6e 98       	ld.w	r8,r7[0x24]
80009fe8:	70 08       	ld.w	r8,r8[0x0]
80009fea:	50 88       	stdsp	sp[0x20],r8
80009fec:	e0 80 01 82 	breq	8000a2f0 <_dtoa_r+0x634>
80009ff0:	58 06       	cp.w	r6,0
80009ff2:	e0 8a 00 43 	brle	8000a078 <_dtoa_r+0x3bc>
80009ff6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009ffa:	fe c8 c5 16 	sub	r8,pc,-15082
80009ffe:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a002:	fa e5 00 18 	st.d	sp[24],r4
8000a006:	ec 04 14 04 	asr	r4,r6,0x4
8000a00a:	ed b4 00 04 	bld	r4,0x4
8000a00e:	c0 30       	breq	8000a014 <_dtoa_r+0x358>
8000a010:	30 25       	mov	r5,2
8000a012:	c1 08       	rjmp	8000a032 <_dtoa_r+0x376>
8000a014:	fe c8 c4 68 	sub	r8,pc,-15256
8000a018:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a01c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a020:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a024:	e0 a0 0f fa 	rcall	8000c018 <__avr32_f64_div>
8000a028:	30 35       	mov	r5,3
8000a02a:	14 98       	mov	r8,r10
8000a02c:	16 99       	mov	r9,r11
8000a02e:	fa e9 00 08 	st.d	sp[8],r8
8000a032:	fe cc c4 86 	sub	r12,pc,-15226
8000a036:	50 a3       	stdsp	sp[0x28],r3
8000a038:	0c 93       	mov	r3,r6
8000a03a:	18 96       	mov	r6,r12
8000a03c:	c0 f8       	rjmp	8000a05a <_dtoa_r+0x39e>
8000a03e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a042:	ed b4 00 00 	bld	r4,0x0
8000a046:	c0 81       	brne	8000a056 <_dtoa_r+0x39a>
8000a048:	ec e8 00 00 	ld.d	r8,r6[0]
8000a04c:	2f f5       	sub	r5,-1
8000a04e:	e0 a0 0c 9f 	rcall	8000b98c <__avr32_f64_mul>
8000a052:	fa eb 00 18 	st.d	sp[24],r10
8000a056:	a1 54       	asr	r4,0x1
8000a058:	2f 86       	sub	r6,-8
8000a05a:	58 04       	cp.w	r4,0
8000a05c:	cf 11       	brne	8000a03e <_dtoa_r+0x382>
8000a05e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a062:	fa ea 00 08 	ld.d	r10,sp[8]
8000a066:	06 96       	mov	r6,r3
8000a068:	e0 a0 0f d8 	rcall	8000c018 <__avr32_f64_div>
8000a06c:	40 a3       	lddsp	r3,sp[0x28]
8000a06e:	14 98       	mov	r8,r10
8000a070:	16 99       	mov	r9,r11
8000a072:	fa e9 00 08 	st.d	sp[8],r8
8000a076:	c2 f8       	rjmp	8000a0d4 <_dtoa_r+0x418>
8000a078:	ec 08 11 00 	rsub	r8,r6,0
8000a07c:	c0 31       	brne	8000a082 <_dtoa_r+0x3c6>
8000a07e:	30 25       	mov	r5,2
8000a080:	c2 a8       	rjmp	8000a0d4 <_dtoa_r+0x418>
8000a082:	fe cc c4 d6 	sub	r12,pc,-15146
8000a086:	f0 04 14 04 	asr	r4,r8,0x4
8000a08a:	50 1c       	stdsp	sp[0x4],r12
8000a08c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a090:	fe c9 c5 ac 	sub	r9,pc,-14932
8000a094:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a098:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a09c:	e0 a0 0c 78 	rcall	8000b98c <__avr32_f64_mul>
8000a0a0:	40 1c       	lddsp	r12,sp[0x4]
8000a0a2:	50 63       	stdsp	sp[0x18],r3
8000a0a4:	30 25       	mov	r5,2
8000a0a6:	0c 93       	mov	r3,r6
8000a0a8:	fa eb 00 08 	st.d	sp[8],r10
8000a0ac:	18 96       	mov	r6,r12
8000a0ae:	c0 f8       	rjmp	8000a0cc <_dtoa_r+0x410>
8000a0b0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0b4:	ed b4 00 00 	bld	r4,0x0
8000a0b8:	c0 81       	brne	8000a0c8 <_dtoa_r+0x40c>
8000a0ba:	ec e8 00 00 	ld.d	r8,r6[0]
8000a0be:	2f f5       	sub	r5,-1
8000a0c0:	e0 a0 0c 66 	rcall	8000b98c <__avr32_f64_mul>
8000a0c4:	fa eb 00 08 	st.d	sp[8],r10
8000a0c8:	a1 54       	asr	r4,0x1
8000a0ca:	2f 86       	sub	r6,-8
8000a0cc:	58 04       	cp.w	r4,0
8000a0ce:	cf 11       	brne	8000a0b0 <_dtoa_r+0x3f4>
8000a0d0:	06 96       	mov	r6,r3
8000a0d2:	40 63       	lddsp	r3,sp[0x18]
8000a0d4:	41 4a       	lddsp	r10,sp[0x50]
8000a0d6:	58 0a       	cp.w	r10,0
8000a0d8:	c2 a0       	breq	8000a12c <_dtoa_r+0x470>
8000a0da:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0de:	58 01       	cp.w	r1,0
8000a0e0:	5f 94       	srgt	r4
8000a0e2:	fa e9 00 18 	st.d	sp[24],r8
8000a0e6:	30 08       	mov	r8,0
8000a0e8:	fc 19 3f f0 	movh	r9,0x3ff0
8000a0ec:	fa ea 00 18 	ld.d	r10,sp[24]
8000a0f0:	e0 a0 0f 60 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a0f4:	f9 bc 00 00 	moveq	r12,0
8000a0f8:	f9 bc 01 01 	movne	r12,1
8000a0fc:	e9 ec 00 0c 	and	r12,r4,r12
8000a100:	c1 60       	breq	8000a12c <_dtoa_r+0x470>
8000a102:	40 98       	lddsp	r8,sp[0x24]
8000a104:	58 08       	cp.w	r8,0
8000a106:	e0 8a 00 f1 	brle	8000a2e8 <_dtoa_r+0x62c>
8000a10a:	30 08       	mov	r8,0
8000a10c:	fc 19 40 24 	movh	r9,0x4024
8000a110:	ec c4 00 01 	sub	r4,r6,1
8000a114:	fa ea 00 18 	ld.d	r10,sp[24]
8000a118:	2f f5       	sub	r5,-1
8000a11a:	50 64       	stdsp	sp[0x18],r4
8000a11c:	e0 a0 0c 38 	rcall	8000b98c <__avr32_f64_mul>
8000a120:	40 94       	lddsp	r4,sp[0x24]
8000a122:	14 98       	mov	r8,r10
8000a124:	16 99       	mov	r9,r11
8000a126:	fa e9 00 08 	st.d	sp[8],r8
8000a12a:	c0 38       	rjmp	8000a130 <_dtoa_r+0x474>
8000a12c:	50 66       	stdsp	sp[0x18],r6
8000a12e:	02 94       	mov	r4,r1
8000a130:	0a 9c       	mov	r12,r5
8000a132:	e0 a0 0e 88 	rcall	8000be42 <__avr32_s32_to_f64>
8000a136:	fa e8 00 08 	ld.d	r8,sp[8]
8000a13a:	e0 a0 0c 29 	rcall	8000b98c <__avr32_f64_mul>
8000a13e:	30 08       	mov	r8,0
8000a140:	fc 19 40 1c 	movh	r9,0x401c
8000a144:	e0 a0 0d de 	rcall	8000bd00 <__avr32_f64_add>
8000a148:	14 98       	mov	r8,r10
8000a14a:	16 99       	mov	r9,r11
8000a14c:	fa e9 00 28 	st.d	sp[40],r8
8000a150:	fc 18 fc c0 	movh	r8,0xfcc0
8000a154:	40 a5       	lddsp	r5,sp[0x28]
8000a156:	10 05       	add	r5,r8
8000a158:	50 a5       	stdsp	sp[0x28],r5
8000a15a:	58 04       	cp.w	r4,0
8000a15c:	c2 11       	brne	8000a19e <_dtoa_r+0x4e2>
8000a15e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a162:	30 08       	mov	r8,0
8000a164:	fc 19 40 14 	movh	r9,0x4014
8000a168:	e0 a0 0c fe 	rcall	8000bb64 <__avr32_f64_sub>
8000a16c:	40 bc       	lddsp	r12,sp[0x2c]
8000a16e:	fa eb 00 08 	st.d	sp[8],r10
8000a172:	14 98       	mov	r8,r10
8000a174:	16 99       	mov	r9,r11
8000a176:	18 9a       	mov	r10,r12
8000a178:	0a 9b       	mov	r11,r5
8000a17a:	e0 a0 0f 1b 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a17e:	e0 81 02 54 	brne	8000a626 <_dtoa_r+0x96a>
8000a182:	0a 98       	mov	r8,r5
8000a184:	40 b9       	lddsp	r9,sp[0x2c]
8000a186:	ee 18 80 00 	eorh	r8,0x8000
8000a18a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a18e:	10 95       	mov	r5,r8
8000a190:	12 98       	mov	r8,r9
8000a192:	0a 99       	mov	r9,r5
8000a194:	e0 a0 0f 0e 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a198:	e0 81 02 3e 	brne	8000a614 <_dtoa_r+0x958>
8000a19c:	ca 68       	rjmp	8000a2e8 <_dtoa_r+0x62c>
8000a19e:	fe c9 c6 ba 	sub	r9,pc,-14662
8000a1a2:	e8 c8 00 01 	sub	r8,r4,1
8000a1a6:	40 d5       	lddsp	r5,sp[0x34]
8000a1a8:	58 05       	cp.w	r5,0
8000a1aa:	c4 f0       	breq	8000a248 <_dtoa_r+0x58c>
8000a1ac:	30 0c       	mov	r12,0
8000a1ae:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a1b2:	51 3c       	stdsp	sp[0x4c],r12
8000a1b4:	30 0a       	mov	r10,0
8000a1b6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a1ba:	e0 a0 0f 2f 	rcall	8000c018 <__avr32_f64_div>
8000a1be:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1c2:	40 85       	lddsp	r5,sp[0x20]
8000a1c4:	e0 a0 0c d0 	rcall	8000bb64 <__avr32_f64_sub>
8000a1c8:	fa eb 00 28 	st.d	sp[40],r10
8000a1cc:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1d0:	e0 a0 0e 22 	rcall	8000be14 <__avr32_f64_to_s32>
8000a1d4:	51 6c       	stdsp	sp[0x58],r12
8000a1d6:	e0 a0 0e 36 	rcall	8000be42 <__avr32_s32_to_f64>
8000a1da:	14 98       	mov	r8,r10
8000a1dc:	16 99       	mov	r9,r11
8000a1de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1e2:	e0 a0 0c c1 	rcall	8000bb64 <__avr32_f64_sub>
8000a1e6:	fa eb 00 08 	st.d	sp[8],r10
8000a1ea:	41 68       	lddsp	r8,sp[0x58]
8000a1ec:	2d 08       	sub	r8,-48
8000a1ee:	0a c8       	st.b	r5++,r8
8000a1f0:	41 39       	lddsp	r9,sp[0x4c]
8000a1f2:	2f f9       	sub	r9,-1
8000a1f4:	51 39       	stdsp	sp[0x4c],r9
8000a1f6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1fa:	e0 a0 0e db 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a1fe:	e0 81 03 39 	brne	8000a870 <_dtoa_r+0xbb4>
8000a202:	fa e8 00 08 	ld.d	r8,sp[8]
8000a206:	30 0a       	mov	r10,0
8000a208:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a20c:	e0 a0 0c ac 	rcall	8000bb64 <__avr32_f64_sub>
8000a210:	fa e8 00 28 	ld.d	r8,sp[40]
8000a214:	e0 a0 0e ce 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a218:	fa ea 00 28 	ld.d	r10,sp[40]
8000a21c:	30 08       	mov	r8,0
8000a21e:	fc 19 40 24 	movh	r9,0x4024
8000a222:	e0 81 00 da 	brne	8000a3d6 <_dtoa_r+0x71a>
8000a226:	41 3c       	lddsp	r12,sp[0x4c]
8000a228:	08 3c       	cp.w	r12,r4
8000a22a:	c5 f4       	brge	8000a2e8 <_dtoa_r+0x62c>
8000a22c:	e0 a0 0b b0 	rcall	8000b98c <__avr32_f64_mul>
8000a230:	30 08       	mov	r8,0
8000a232:	fa eb 00 28 	st.d	sp[40],r10
8000a236:	fc 19 40 24 	movh	r9,0x4024
8000a23a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a23e:	e0 a0 0b a7 	rcall	8000b98c <__avr32_f64_mul>
8000a242:	fa eb 00 08 	st.d	sp[8],r10
8000a246:	cc 3b       	rjmp	8000a1cc <_dtoa_r+0x510>
8000a248:	40 85       	lddsp	r5,sp[0x20]
8000a24a:	08 05       	add	r5,r4
8000a24c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a250:	51 35       	stdsp	sp[0x4c],r5
8000a252:	fa e8 00 28 	ld.d	r8,sp[40]
8000a256:	40 85       	lddsp	r5,sp[0x20]
8000a258:	e0 a0 0b 9a 	rcall	8000b98c <__avr32_f64_mul>
8000a25c:	fa eb 00 28 	st.d	sp[40],r10
8000a260:	fa ea 00 08 	ld.d	r10,sp[8]
8000a264:	e0 a0 0d d8 	rcall	8000be14 <__avr32_f64_to_s32>
8000a268:	51 6c       	stdsp	sp[0x58],r12
8000a26a:	e0 a0 0d ec 	rcall	8000be42 <__avr32_s32_to_f64>
8000a26e:	14 98       	mov	r8,r10
8000a270:	16 99       	mov	r9,r11
8000a272:	fa ea 00 08 	ld.d	r10,sp[8]
8000a276:	e0 a0 0c 77 	rcall	8000bb64 <__avr32_f64_sub>
8000a27a:	fa eb 00 08 	st.d	sp[8],r10
8000a27e:	41 68       	lddsp	r8,sp[0x58]
8000a280:	2d 08       	sub	r8,-48
8000a282:	0a c8       	st.b	r5++,r8
8000a284:	41 3c       	lddsp	r12,sp[0x4c]
8000a286:	18 35       	cp.w	r5,r12
8000a288:	c2 81       	brne	8000a2d8 <_dtoa_r+0x61c>
8000a28a:	30 08       	mov	r8,0
8000a28c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a290:	fa ea 00 28 	ld.d	r10,sp[40]
8000a294:	e0 a0 0d 36 	rcall	8000bd00 <__avr32_f64_add>
8000a298:	40 85       	lddsp	r5,sp[0x20]
8000a29a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a29e:	08 05       	add	r5,r4
8000a2a0:	e0 a0 0e 88 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a2a4:	e0 81 00 99 	brne	8000a3d6 <_dtoa_r+0x71a>
8000a2a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a2ac:	30 0a       	mov	r10,0
8000a2ae:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a2b2:	e0 a0 0c 59 	rcall	8000bb64 <__avr32_f64_sub>
8000a2b6:	14 98       	mov	r8,r10
8000a2b8:	16 99       	mov	r9,r11
8000a2ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2be:	e0 a0 0e 79 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a2c2:	c1 30       	breq	8000a2e8 <_dtoa_r+0x62c>
8000a2c4:	33 09       	mov	r9,48
8000a2c6:	0a 98       	mov	r8,r5
8000a2c8:	11 7a       	ld.ub	r10,--r8
8000a2ca:	f2 0a 18 00 	cp.b	r10,r9
8000a2ce:	e0 81 02 d1 	brne	8000a870 <_dtoa_r+0xbb4>
8000a2d2:	10 95       	mov	r5,r8
8000a2d4:	cf 9b       	rjmp	8000a2c6 <_dtoa_r+0x60a>
8000a2d6:	d7 03       	nop
8000a2d8:	30 08       	mov	r8,0
8000a2da:	fc 19 40 24 	movh	r9,0x4024
8000a2de:	e0 a0 0b 57 	rcall	8000b98c <__avr32_f64_mul>
8000a2e2:	fa eb 00 08 	st.d	sp[8],r10
8000a2e6:	cb db       	rjmp	8000a260 <_dtoa_r+0x5a4>
8000a2e8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2ec:	fa eb 00 08 	st.d	sp[8],r10
8000a2f0:	58 e6       	cp.w	r6,14
8000a2f2:	5f ab       	srle	r11
8000a2f4:	41 8a       	lddsp	r10,sp[0x60]
8000a2f6:	30 08       	mov	r8,0
8000a2f8:	f4 09 11 ff 	rsub	r9,r10,-1
8000a2fc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a300:	f0 09 18 00 	cp.b	r9,r8
8000a304:	e0 80 00 82 	breq	8000a408 <_dtoa_r+0x74c>
8000a308:	40 ea       	lddsp	r10,sp[0x38]
8000a30a:	58 01       	cp.w	r1,0
8000a30c:	5f a9       	srle	r9
8000a30e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a312:	fe ca c8 2e 	sub	r10,pc,-14290
8000a316:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a31a:	fa e5 00 10 	st.d	sp[16],r4
8000a31e:	f0 09 18 00 	cp.b	r9,r8
8000a322:	c1 40       	breq	8000a34a <_dtoa_r+0x68e>
8000a324:	58 01       	cp.w	r1,0
8000a326:	e0 81 01 77 	brne	8000a614 <_dtoa_r+0x958>
8000a32a:	30 08       	mov	r8,0
8000a32c:	fc 19 40 14 	movh	r9,0x4014
8000a330:	08 9a       	mov	r10,r4
8000a332:	0a 9b       	mov	r11,r5
8000a334:	e0 a0 0b 2c 	rcall	8000b98c <__avr32_f64_mul>
8000a338:	fa e8 00 08 	ld.d	r8,sp[8]
8000a33c:	e0 a0 0e 06 	rcall	8000bf48 <__avr32_f64_cmp_ge>
8000a340:	e0 81 01 6a 	brne	8000a614 <_dtoa_r+0x958>
8000a344:	02 92       	mov	r2,r1
8000a346:	e0 8f 01 72 	bral	8000a62a <_dtoa_r+0x96e>
8000a34a:	40 85       	lddsp	r5,sp[0x20]
8000a34c:	30 14       	mov	r4,1
8000a34e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a352:	fa ea 00 08 	ld.d	r10,sp[8]
8000a356:	e0 a0 0e 61 	rcall	8000c018 <__avr32_f64_div>
8000a35a:	e0 a0 0d 5d 	rcall	8000be14 <__avr32_f64_to_s32>
8000a35e:	18 92       	mov	r2,r12
8000a360:	e0 a0 0d 71 	rcall	8000be42 <__avr32_s32_to_f64>
8000a364:	fa e8 00 10 	ld.d	r8,sp[16]
8000a368:	e0 a0 0b 12 	rcall	8000b98c <__avr32_f64_mul>
8000a36c:	14 98       	mov	r8,r10
8000a36e:	16 99       	mov	r9,r11
8000a370:	fa ea 00 08 	ld.d	r10,sp[8]
8000a374:	e0 a0 0b f8 	rcall	8000bb64 <__avr32_f64_sub>
8000a378:	fa eb 00 08 	st.d	sp[8],r10
8000a37c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a380:	0a c8       	st.b	r5++,r8
8000a382:	fc 19 40 24 	movh	r9,0x4024
8000a386:	30 08       	mov	r8,0
8000a388:	02 34       	cp.w	r4,r1
8000a38a:	c3 31       	brne	8000a3f0 <_dtoa_r+0x734>
8000a38c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a390:	e0 a0 0c b8 	rcall	8000bd00 <__avr32_f64_add>
8000a394:	16 91       	mov	r1,r11
8000a396:	14 90       	mov	r0,r10
8000a398:	14 98       	mov	r8,r10
8000a39a:	02 99       	mov	r9,r1
8000a39c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a3a0:	e0 a0 0e 08 	rcall	8000bfb0 <__avr32_f64_cmp_lt>
8000a3a4:	c1 a1       	brne	8000a3d8 <_dtoa_r+0x71c>
8000a3a6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3aa:	00 9a       	mov	r10,r0
8000a3ac:	02 9b       	mov	r11,r1
8000a3ae:	e0 a0 0d ba 	rcall	8000bf22 <__avr32_f64_cmp_eq>
8000a3b2:	e0 80 02 5e 	breq	8000a86e <_dtoa_r+0xbb2>
8000a3b6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a3ba:	c0 f1       	brne	8000a3d8 <_dtoa_r+0x71c>
8000a3bc:	e0 8f 02 59 	bral	8000a86e <_dtoa_r+0xbb2>
8000a3c0:	40 8a       	lddsp	r10,sp[0x20]
8000a3c2:	14 38       	cp.w	r8,r10
8000a3c4:	c0 30       	breq	8000a3ca <_dtoa_r+0x70e>
8000a3c6:	10 95       	mov	r5,r8
8000a3c8:	c0 98       	rjmp	8000a3da <_dtoa_r+0x71e>
8000a3ca:	33 08       	mov	r8,48
8000a3cc:	40 89       	lddsp	r9,sp[0x20]
8000a3ce:	2f f6       	sub	r6,-1
8000a3d0:	b2 88       	st.b	r9[0x0],r8
8000a3d2:	40 88       	lddsp	r8,sp[0x20]
8000a3d4:	c0 88       	rjmp	8000a3e4 <_dtoa_r+0x728>
8000a3d6:	40 66       	lddsp	r6,sp[0x18]
8000a3d8:	33 99       	mov	r9,57
8000a3da:	0a 98       	mov	r8,r5
8000a3dc:	11 7a       	ld.ub	r10,--r8
8000a3de:	f2 0a 18 00 	cp.b	r10,r9
8000a3e2:	ce f0       	breq	8000a3c0 <_dtoa_r+0x704>
8000a3e4:	50 66       	stdsp	sp[0x18],r6
8000a3e6:	11 89       	ld.ub	r9,r8[0x0]
8000a3e8:	2f f9       	sub	r9,-1
8000a3ea:	b0 89       	st.b	r8[0x0],r9
8000a3ec:	e0 8f 02 42 	bral	8000a870 <_dtoa_r+0xbb4>
8000a3f0:	e0 a0 0a ce 	rcall	8000b98c <__avr32_f64_mul>
8000a3f4:	2f f4       	sub	r4,-1
8000a3f6:	fa eb 00 08 	st.d	sp[8],r10
8000a3fa:	30 08       	mov	r8,0
8000a3fc:	30 09       	mov	r9,0
8000a3fe:	e0 a0 0d 92 	rcall	8000bf22 <__avr32_f64_cmp_eq>
8000a402:	ca 60       	breq	8000a34e <_dtoa_r+0x692>
8000a404:	e0 8f 02 35 	bral	8000a86e <_dtoa_r+0xbb2>
8000a408:	40 d8       	lddsp	r8,sp[0x34]
8000a40a:	58 08       	cp.w	r8,0
8000a40c:	c0 51       	brne	8000a416 <_dtoa_r+0x75a>
8000a40e:	04 98       	mov	r8,r2
8000a410:	00 95       	mov	r5,r0
8000a412:	40 d4       	lddsp	r4,sp[0x34]
8000a414:	c3 78       	rjmp	8000a482 <_dtoa_r+0x7c6>
8000a416:	40 c5       	lddsp	r5,sp[0x30]
8000a418:	58 15       	cp.w	r5,1
8000a41a:	e0 89 00 0f 	brgt	8000a438 <_dtoa_r+0x77c>
8000a41e:	41 74       	lddsp	r4,sp[0x5c]
8000a420:	58 04       	cp.w	r4,0
8000a422:	c0 40       	breq	8000a42a <_dtoa_r+0x76e>
8000a424:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a428:	c0 48       	rjmp	8000a430 <_dtoa_r+0x774>
8000a42a:	41 99       	lddsp	r9,sp[0x64]
8000a42c:	f2 09 11 36 	rsub	r9,r9,54
8000a430:	04 98       	mov	r8,r2
8000a432:	00 95       	mov	r5,r0
8000a434:	c1 c8       	rjmp	8000a46c <_dtoa_r+0x7b0>
8000a436:	d7 03       	nop
8000a438:	e2 c8 00 01 	sub	r8,r1,1
8000a43c:	58 01       	cp.w	r1,0
8000a43e:	e0 05 17 40 	movge	r5,r0
8000a442:	e2 09 17 40 	movge	r9,r1
8000a446:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a44a:	f9 b9 05 00 	movlt	r9,0
8000a44e:	10 32       	cp.w	r2,r8
8000a450:	e5 d8 e4 18 	subge	r8,r2,r8
8000a454:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a458:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a45c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a460:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a464:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a468:	f9 b8 05 00 	movlt	r8,0
8000a46c:	40 4b       	lddsp	r11,sp[0x10]
8000a46e:	12 0b       	add	r11,r9
8000a470:	50 08       	stdsp	sp[0x0],r8
8000a472:	50 4b       	stdsp	sp[0x10],r11
8000a474:	12 00       	add	r0,r9
8000a476:	30 1b       	mov	r11,1
8000a478:	0e 9c       	mov	r12,r7
8000a47a:	e0 a0 08 a7 	rcall	8000b5c8 <__i2b>
8000a47e:	40 08       	lddsp	r8,sp[0x0]
8000a480:	18 94       	mov	r4,r12
8000a482:	40 4a       	lddsp	r10,sp[0x10]
8000a484:	58 05       	cp.w	r5,0
8000a486:	5f 99       	srgt	r9
8000a488:	58 0a       	cp.w	r10,0
8000a48a:	5f 9a       	srgt	r10
8000a48c:	f5 e9 00 09 	and	r9,r10,r9
8000a490:	c0 80       	breq	8000a4a0 <_dtoa_r+0x7e4>
8000a492:	40 4c       	lddsp	r12,sp[0x10]
8000a494:	f8 05 0d 49 	min	r9,r12,r5
8000a498:	12 1c       	sub	r12,r9
8000a49a:	12 10       	sub	r0,r9
8000a49c:	50 4c       	stdsp	sp[0x10],r12
8000a49e:	12 15       	sub	r5,r9
8000a4a0:	58 02       	cp.w	r2,0
8000a4a2:	e0 8a 00 27 	brle	8000a4f0 <_dtoa_r+0x834>
8000a4a6:	40 db       	lddsp	r11,sp[0x34]
8000a4a8:	58 0b       	cp.w	r11,0
8000a4aa:	c1 d0       	breq	8000a4e4 <_dtoa_r+0x828>
8000a4ac:	58 08       	cp.w	r8,0
8000a4ae:	e0 8a 00 17 	brle	8000a4dc <_dtoa_r+0x820>
8000a4b2:	10 9a       	mov	r10,r8
8000a4b4:	50 08       	stdsp	sp[0x0],r8
8000a4b6:	08 9b       	mov	r11,r4
8000a4b8:	0e 9c       	mov	r12,r7
8000a4ba:	e0 a0 08 cd 	rcall	8000b654 <__pow5mult>
8000a4be:	06 9a       	mov	r10,r3
8000a4c0:	18 9b       	mov	r11,r12
8000a4c2:	18 94       	mov	r4,r12
8000a4c4:	0e 9c       	mov	r12,r7
8000a4c6:	e0 a0 08 01 	rcall	8000b4c8 <__multiply>
8000a4ca:	18 99       	mov	r9,r12
8000a4cc:	06 9b       	mov	r11,r3
8000a4ce:	50 19       	stdsp	sp[0x4],r9
8000a4d0:	0e 9c       	mov	r12,r7
8000a4d2:	e0 a0 06 ad 	rcall	8000b22c <_Bfree>
8000a4d6:	40 19       	lddsp	r9,sp[0x4]
8000a4d8:	40 08       	lddsp	r8,sp[0x0]
8000a4da:	12 93       	mov	r3,r9
8000a4dc:	e4 08 01 0a 	sub	r10,r2,r8
8000a4e0:	c0 80       	breq	8000a4f0 <_dtoa_r+0x834>
8000a4e2:	c0 28       	rjmp	8000a4e6 <_dtoa_r+0x82a>
8000a4e4:	04 9a       	mov	r10,r2
8000a4e6:	06 9b       	mov	r11,r3
8000a4e8:	0e 9c       	mov	r12,r7
8000a4ea:	e0 a0 08 b5 	rcall	8000b654 <__pow5mult>
8000a4ee:	18 93       	mov	r3,r12
8000a4f0:	30 1b       	mov	r11,1
8000a4f2:	0e 9c       	mov	r12,r7
8000a4f4:	e0 a0 08 6a 	rcall	8000b5c8 <__i2b>
8000a4f8:	41 1a       	lddsp	r10,sp[0x44]
8000a4fa:	18 92       	mov	r2,r12
8000a4fc:	58 0a       	cp.w	r10,0
8000a4fe:	e0 8a 00 07 	brle	8000a50c <_dtoa_r+0x850>
8000a502:	18 9b       	mov	r11,r12
8000a504:	0e 9c       	mov	r12,r7
8000a506:	e0 a0 08 a7 	rcall	8000b654 <__pow5mult>
8000a50a:	18 92       	mov	r2,r12
8000a50c:	40 c9       	lddsp	r9,sp[0x30]
8000a50e:	58 19       	cp.w	r9,1
8000a510:	e0 89 00 14 	brgt	8000a538 <_dtoa_r+0x87c>
8000a514:	40 38       	lddsp	r8,sp[0xc]
8000a516:	58 08       	cp.w	r8,0
8000a518:	c1 01       	brne	8000a538 <_dtoa_r+0x87c>
8000a51a:	40 29       	lddsp	r9,sp[0x8]
8000a51c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a520:	c0 c1       	brne	8000a538 <_dtoa_r+0x87c>
8000a522:	12 98       	mov	r8,r9
8000a524:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a528:	c0 80       	breq	8000a538 <_dtoa_r+0x87c>
8000a52a:	40 4c       	lddsp	r12,sp[0x10]
8000a52c:	30 1b       	mov	r11,1
8000a52e:	2f fc       	sub	r12,-1
8000a530:	2f f0       	sub	r0,-1
8000a532:	50 4c       	stdsp	sp[0x10],r12
8000a534:	50 6b       	stdsp	sp[0x18],r11
8000a536:	c0 38       	rjmp	8000a53c <_dtoa_r+0x880>
8000a538:	30 0a       	mov	r10,0
8000a53a:	50 6a       	stdsp	sp[0x18],r10
8000a53c:	41 19       	lddsp	r9,sp[0x44]
8000a53e:	58 09       	cp.w	r9,0
8000a540:	c0 31       	brne	8000a546 <_dtoa_r+0x88a>
8000a542:	30 1c       	mov	r12,1
8000a544:	c0 98       	rjmp	8000a556 <_dtoa_r+0x89a>
8000a546:	64 48       	ld.w	r8,r2[0x10]
8000a548:	2f c8       	sub	r8,-4
8000a54a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a54e:	e0 a0 05 df 	rcall	8000b10c <__hi0bits>
8000a552:	f8 0c 11 20 	rsub	r12,r12,32
8000a556:	40 4b       	lddsp	r11,sp[0x10]
8000a558:	f8 0b 00 08 	add	r8,r12,r11
8000a55c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a560:	c0 c0       	breq	8000a578 <_dtoa_r+0x8bc>
8000a562:	f0 08 11 20 	rsub	r8,r8,32
8000a566:	58 48       	cp.w	r8,4
8000a568:	e0 8a 00 06 	brle	8000a574 <_dtoa_r+0x8b8>
8000a56c:	20 48       	sub	r8,4
8000a56e:	10 0b       	add	r11,r8
8000a570:	50 4b       	stdsp	sp[0x10],r11
8000a572:	c0 78       	rjmp	8000a580 <_dtoa_r+0x8c4>
8000a574:	58 48       	cp.w	r8,4
8000a576:	c0 70       	breq	8000a584 <_dtoa_r+0x8c8>
8000a578:	40 4a       	lddsp	r10,sp[0x10]
8000a57a:	2e 48       	sub	r8,-28
8000a57c:	10 0a       	add	r10,r8
8000a57e:	50 4a       	stdsp	sp[0x10],r10
8000a580:	10 00       	add	r0,r8
8000a582:	10 05       	add	r5,r8
8000a584:	58 00       	cp.w	r0,0
8000a586:	e0 8a 00 08 	brle	8000a596 <_dtoa_r+0x8da>
8000a58a:	06 9b       	mov	r11,r3
8000a58c:	00 9a       	mov	r10,r0
8000a58e:	0e 9c       	mov	r12,r7
8000a590:	e0 a0 07 58 	rcall	8000b440 <__lshift>
8000a594:	18 93       	mov	r3,r12
8000a596:	40 49       	lddsp	r9,sp[0x10]
8000a598:	58 09       	cp.w	r9,0
8000a59a:	e0 8a 00 08 	brle	8000a5aa <_dtoa_r+0x8ee>
8000a59e:	04 9b       	mov	r11,r2
8000a5a0:	12 9a       	mov	r10,r9
8000a5a2:	0e 9c       	mov	r12,r7
8000a5a4:	e0 a0 07 4e 	rcall	8000b440 <__lshift>
8000a5a8:	18 92       	mov	r2,r12
8000a5aa:	41 48       	lddsp	r8,sp[0x50]
8000a5ac:	58 08       	cp.w	r8,0
8000a5ae:	c1 b0       	breq	8000a5e4 <_dtoa_r+0x928>
8000a5b0:	04 9b       	mov	r11,r2
8000a5b2:	06 9c       	mov	r12,r3
8000a5b4:	e0 a0 06 23 	rcall	8000b1fa <__mcmp>
8000a5b8:	c1 64       	brge	8000a5e4 <_dtoa_r+0x928>
8000a5ba:	06 9b       	mov	r11,r3
8000a5bc:	30 09       	mov	r9,0
8000a5be:	30 aa       	mov	r10,10
8000a5c0:	0e 9c       	mov	r12,r7
8000a5c2:	e0 a0 08 0b 	rcall	8000b5d8 <__multadd>
8000a5c6:	20 16       	sub	r6,1
8000a5c8:	18 93       	mov	r3,r12
8000a5ca:	40 dc       	lddsp	r12,sp[0x34]
8000a5cc:	58 0c       	cp.w	r12,0
8000a5ce:	c0 31       	brne	8000a5d4 <_dtoa_r+0x918>
8000a5d0:	40 91       	lddsp	r1,sp[0x24]
8000a5d2:	c0 98       	rjmp	8000a5e4 <_dtoa_r+0x928>
8000a5d4:	08 9b       	mov	r11,r4
8000a5d6:	40 91       	lddsp	r1,sp[0x24]
8000a5d8:	30 09       	mov	r9,0
8000a5da:	30 aa       	mov	r10,10
8000a5dc:	0e 9c       	mov	r12,r7
8000a5de:	e0 a0 07 fd 	rcall	8000b5d8 <__multadd>
8000a5e2:	18 94       	mov	r4,r12
8000a5e4:	58 01       	cp.w	r1,0
8000a5e6:	5f a9       	srle	r9
8000a5e8:	40 cb       	lddsp	r11,sp[0x30]
8000a5ea:	58 2b       	cp.w	r11,2
8000a5ec:	5f 98       	srgt	r8
8000a5ee:	f3 e8 00 08 	and	r8,r9,r8
8000a5f2:	c2 50       	breq	8000a63c <_dtoa_r+0x980>
8000a5f4:	58 01       	cp.w	r1,0
8000a5f6:	c1 11       	brne	8000a618 <_dtoa_r+0x95c>
8000a5f8:	04 9b       	mov	r11,r2
8000a5fa:	02 99       	mov	r9,r1
8000a5fc:	30 5a       	mov	r10,5
8000a5fe:	0e 9c       	mov	r12,r7
8000a600:	e0 a0 07 ec 	rcall	8000b5d8 <__multadd>
8000a604:	18 92       	mov	r2,r12
8000a606:	18 9b       	mov	r11,r12
8000a608:	06 9c       	mov	r12,r3
8000a60a:	e0 a0 05 f8 	rcall	8000b1fa <__mcmp>
8000a60e:	e0 89 00 0f 	brgt	8000a62c <_dtoa_r+0x970>
8000a612:	c0 38       	rjmp	8000a618 <_dtoa_r+0x95c>
8000a614:	30 02       	mov	r2,0
8000a616:	04 94       	mov	r4,r2
8000a618:	40 ea       	lddsp	r10,sp[0x38]
8000a61a:	30 09       	mov	r9,0
8000a61c:	5c da       	com	r10
8000a61e:	40 85       	lddsp	r5,sp[0x20]
8000a620:	50 6a       	stdsp	sp[0x18],r10
8000a622:	50 49       	stdsp	sp[0x10],r9
8000a624:	c0 f9       	rjmp	8000a842 <_dtoa_r+0xb86>
8000a626:	08 92       	mov	r2,r4
8000a628:	40 66       	lddsp	r6,sp[0x18]
8000a62a:	04 94       	mov	r4,r2
8000a62c:	2f f6       	sub	r6,-1
8000a62e:	50 66       	stdsp	sp[0x18],r6
8000a630:	33 18       	mov	r8,49
8000a632:	40 85       	lddsp	r5,sp[0x20]
8000a634:	0a c8       	st.b	r5++,r8
8000a636:	30 08       	mov	r8,0
8000a638:	50 48       	stdsp	sp[0x10],r8
8000a63a:	c0 49       	rjmp	8000a842 <_dtoa_r+0xb86>
8000a63c:	40 dc       	lddsp	r12,sp[0x34]
8000a63e:	58 0c       	cp.w	r12,0
8000a640:	e0 80 00 b5 	breq	8000a7aa <_dtoa_r+0xaee>
8000a644:	58 05       	cp.w	r5,0
8000a646:	e0 8a 00 08 	brle	8000a656 <_dtoa_r+0x99a>
8000a64a:	08 9b       	mov	r11,r4
8000a64c:	0a 9a       	mov	r10,r5
8000a64e:	0e 9c       	mov	r12,r7
8000a650:	e0 a0 06 f8 	rcall	8000b440 <__lshift>
8000a654:	18 94       	mov	r4,r12
8000a656:	40 6b       	lddsp	r11,sp[0x18]
8000a658:	58 0b       	cp.w	r11,0
8000a65a:	c0 31       	brne	8000a660 <_dtoa_r+0x9a4>
8000a65c:	08 9c       	mov	r12,r4
8000a65e:	c1 38       	rjmp	8000a684 <_dtoa_r+0x9c8>
8000a660:	68 1b       	ld.w	r11,r4[0x4]
8000a662:	0e 9c       	mov	r12,r7
8000a664:	e0 a0 05 fe 	rcall	8000b260 <_Balloc>
8000a668:	68 4a       	ld.w	r10,r4[0x10]
8000a66a:	18 95       	mov	r5,r12
8000a66c:	e8 cb ff f4 	sub	r11,r4,-12
8000a670:	2f ea       	sub	r10,-2
8000a672:	2f 4c       	sub	r12,-12
8000a674:	a3 6a       	lsl	r10,0x2
8000a676:	fe b0 e6 50 	rcall	80007316 <memcpy>
8000a67a:	0a 9b       	mov	r11,r5
8000a67c:	30 1a       	mov	r10,1
8000a67e:	0e 9c       	mov	r12,r7
8000a680:	e0 a0 06 e0 	rcall	8000b440 <__lshift>
8000a684:	50 44       	stdsp	sp[0x10],r4
8000a686:	40 3a       	lddsp	r10,sp[0xc]
8000a688:	30 19       	mov	r9,1
8000a68a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a68e:	18 94       	mov	r4,r12
8000a690:	50 da       	stdsp	sp[0x34],r10
8000a692:	40 85       	lddsp	r5,sp[0x20]
8000a694:	50 99       	stdsp	sp[0x24],r9
8000a696:	50 26       	stdsp	sp[0x8],r6
8000a698:	50 e1       	stdsp	sp[0x38],r1
8000a69a:	04 9b       	mov	r11,r2
8000a69c:	06 9c       	mov	r12,r3
8000a69e:	fe b0 fa 7f 	rcall	80009b9c <quorem>
8000a6a2:	40 4b       	lddsp	r11,sp[0x10]
8000a6a4:	f8 c0 ff d0 	sub	r0,r12,-48
8000a6a8:	06 9c       	mov	r12,r3
8000a6aa:	e0 a0 05 a8 	rcall	8000b1fa <__mcmp>
8000a6ae:	08 9a       	mov	r10,r4
8000a6b0:	50 6c       	stdsp	sp[0x18],r12
8000a6b2:	04 9b       	mov	r11,r2
8000a6b4:	0e 9c       	mov	r12,r7
8000a6b6:	e0 a0 06 5d 	rcall	8000b370 <__mdiff>
8000a6ba:	18 91       	mov	r1,r12
8000a6bc:	78 38       	ld.w	r8,r12[0xc]
8000a6be:	58 08       	cp.w	r8,0
8000a6c0:	c0 30       	breq	8000a6c6 <_dtoa_r+0xa0a>
8000a6c2:	30 16       	mov	r6,1
8000a6c4:	c0 68       	rjmp	8000a6d0 <_dtoa_r+0xa14>
8000a6c6:	18 9b       	mov	r11,r12
8000a6c8:	06 9c       	mov	r12,r3
8000a6ca:	e0 a0 05 98 	rcall	8000b1fa <__mcmp>
8000a6ce:	18 96       	mov	r6,r12
8000a6d0:	0e 9c       	mov	r12,r7
8000a6d2:	02 9b       	mov	r11,r1
8000a6d4:	e0 a0 05 ac 	rcall	8000b22c <_Bfree>
8000a6d8:	40 cc       	lddsp	r12,sp[0x30]
8000a6da:	ed ec 10 08 	or	r8,r6,r12
8000a6de:	c0 d1       	brne	8000a6f8 <_dtoa_r+0xa3c>
8000a6e0:	40 db       	lddsp	r11,sp[0x34]
8000a6e2:	58 0b       	cp.w	r11,0
8000a6e4:	c0 a1       	brne	8000a6f8 <_dtoa_r+0xa3c>
8000a6e6:	40 26       	lddsp	r6,sp[0x8]
8000a6e8:	e0 40 00 39 	cp.w	r0,57
8000a6ec:	c3 00       	breq	8000a74c <_dtoa_r+0xa90>
8000a6ee:	40 6a       	lddsp	r10,sp[0x18]
8000a6f0:	58 0a       	cp.w	r10,0
8000a6f2:	e0 89 00 24 	brgt	8000a73a <_dtoa_r+0xa7e>
8000a6f6:	c2 f8       	rjmp	8000a754 <_dtoa_r+0xa98>
8000a6f8:	40 69       	lddsp	r9,sp[0x18]
8000a6fa:	58 09       	cp.w	r9,0
8000a6fc:	c0 85       	brlt	8000a70c <_dtoa_r+0xa50>
8000a6fe:	12 98       	mov	r8,r9
8000a700:	40 cc       	lddsp	r12,sp[0x30]
8000a702:	18 48       	or	r8,r12
8000a704:	c1 d1       	brne	8000a73e <_dtoa_r+0xa82>
8000a706:	40 db       	lddsp	r11,sp[0x34]
8000a708:	58 0b       	cp.w	r11,0
8000a70a:	c1 a1       	brne	8000a73e <_dtoa_r+0xa82>
8000a70c:	0c 99       	mov	r9,r6
8000a70e:	40 26       	lddsp	r6,sp[0x8]
8000a710:	58 09       	cp.w	r9,0
8000a712:	e0 8a 00 21 	brle	8000a754 <_dtoa_r+0xa98>
8000a716:	06 9b       	mov	r11,r3
8000a718:	30 1a       	mov	r10,1
8000a71a:	0e 9c       	mov	r12,r7
8000a71c:	e0 a0 06 92 	rcall	8000b440 <__lshift>
8000a720:	04 9b       	mov	r11,r2
8000a722:	18 93       	mov	r3,r12
8000a724:	e0 a0 05 6b 	rcall	8000b1fa <__mcmp>
8000a728:	e0 89 00 06 	brgt	8000a734 <_dtoa_r+0xa78>
8000a72c:	c1 41       	brne	8000a754 <_dtoa_r+0xa98>
8000a72e:	ed b0 00 00 	bld	r0,0x0
8000a732:	c1 11       	brne	8000a754 <_dtoa_r+0xa98>
8000a734:	e0 40 00 39 	cp.w	r0,57
8000a738:	c0 a0       	breq	8000a74c <_dtoa_r+0xa90>
8000a73a:	2f f0       	sub	r0,-1
8000a73c:	c0 c8       	rjmp	8000a754 <_dtoa_r+0xa98>
8000a73e:	58 06       	cp.w	r6,0
8000a740:	e0 8a 00 0c 	brle	8000a758 <_dtoa_r+0xa9c>
8000a744:	40 26       	lddsp	r6,sp[0x8]
8000a746:	e0 40 00 39 	cp.w	r0,57
8000a74a:	c0 41       	brne	8000a752 <_dtoa_r+0xa96>
8000a74c:	33 98       	mov	r8,57
8000a74e:	0a c8       	st.b	r5++,r8
8000a750:	c6 78       	rjmp	8000a81e <_dtoa_r+0xb62>
8000a752:	2f f0       	sub	r0,-1
8000a754:	0a c0       	st.b	r5++,r0
8000a756:	c7 58       	rjmp	8000a840 <_dtoa_r+0xb84>
8000a758:	0a c0       	st.b	r5++,r0
8000a75a:	40 9a       	lddsp	r10,sp[0x24]
8000a75c:	40 e9       	lddsp	r9,sp[0x38]
8000a75e:	12 3a       	cp.w	r10,r9
8000a760:	c4 30       	breq	8000a7e6 <_dtoa_r+0xb2a>
8000a762:	06 9b       	mov	r11,r3
8000a764:	30 09       	mov	r9,0
8000a766:	30 aa       	mov	r10,10
8000a768:	0e 9c       	mov	r12,r7
8000a76a:	e0 a0 07 37 	rcall	8000b5d8 <__multadd>
8000a76e:	40 48       	lddsp	r8,sp[0x10]
8000a770:	18 93       	mov	r3,r12
8000a772:	08 38       	cp.w	r8,r4
8000a774:	c0 91       	brne	8000a786 <_dtoa_r+0xaca>
8000a776:	10 9b       	mov	r11,r8
8000a778:	30 09       	mov	r9,0
8000a77a:	30 aa       	mov	r10,10
8000a77c:	0e 9c       	mov	r12,r7
8000a77e:	e0 a0 07 2d 	rcall	8000b5d8 <__multadd>
8000a782:	50 4c       	stdsp	sp[0x10],r12
8000a784:	c0 e8       	rjmp	8000a7a0 <_dtoa_r+0xae4>
8000a786:	40 4b       	lddsp	r11,sp[0x10]
8000a788:	30 09       	mov	r9,0
8000a78a:	30 aa       	mov	r10,10
8000a78c:	0e 9c       	mov	r12,r7
8000a78e:	e0 a0 07 25 	rcall	8000b5d8 <__multadd>
8000a792:	08 9b       	mov	r11,r4
8000a794:	50 4c       	stdsp	sp[0x10],r12
8000a796:	30 09       	mov	r9,0
8000a798:	30 aa       	mov	r10,10
8000a79a:	0e 9c       	mov	r12,r7
8000a79c:	e0 a0 07 1e 	rcall	8000b5d8 <__multadd>
8000a7a0:	18 94       	mov	r4,r12
8000a7a2:	40 9c       	lddsp	r12,sp[0x24]
8000a7a4:	2f fc       	sub	r12,-1
8000a7a6:	50 9c       	stdsp	sp[0x24],r12
8000a7a8:	c7 9b       	rjmp	8000a69a <_dtoa_r+0x9de>
8000a7aa:	30 18       	mov	r8,1
8000a7ac:	06 90       	mov	r0,r3
8000a7ae:	40 85       	lddsp	r5,sp[0x20]
8000a7b0:	08 93       	mov	r3,r4
8000a7b2:	0c 94       	mov	r4,r6
8000a7b4:	10 96       	mov	r6,r8
8000a7b6:	04 9b       	mov	r11,r2
8000a7b8:	00 9c       	mov	r12,r0
8000a7ba:	fe b0 f9 f1 	rcall	80009b9c <quorem>
8000a7be:	2d 0c       	sub	r12,-48
8000a7c0:	0a cc       	st.b	r5++,r12
8000a7c2:	02 36       	cp.w	r6,r1
8000a7c4:	c0 a4       	brge	8000a7d8 <_dtoa_r+0xb1c>
8000a7c6:	00 9b       	mov	r11,r0
8000a7c8:	30 09       	mov	r9,0
8000a7ca:	30 aa       	mov	r10,10
8000a7cc:	0e 9c       	mov	r12,r7
8000a7ce:	2f f6       	sub	r6,-1
8000a7d0:	e0 a0 07 04 	rcall	8000b5d8 <__multadd>
8000a7d4:	18 90       	mov	r0,r12
8000a7d6:	cf 0b       	rjmp	8000a7b6 <_dtoa_r+0xafa>
8000a7d8:	08 96       	mov	r6,r4
8000a7da:	30 0b       	mov	r11,0
8000a7dc:	06 94       	mov	r4,r3
8000a7de:	50 4b       	stdsp	sp[0x10],r11
8000a7e0:	00 93       	mov	r3,r0
8000a7e2:	18 90       	mov	r0,r12
8000a7e4:	c0 28       	rjmp	8000a7e8 <_dtoa_r+0xb2c>
8000a7e6:	40 26       	lddsp	r6,sp[0x8]
8000a7e8:	06 9b       	mov	r11,r3
8000a7ea:	30 1a       	mov	r10,1
8000a7ec:	0e 9c       	mov	r12,r7
8000a7ee:	e0 a0 06 29 	rcall	8000b440 <__lshift>
8000a7f2:	04 9b       	mov	r11,r2
8000a7f4:	18 93       	mov	r3,r12
8000a7f6:	e0 a0 05 02 	rcall	8000b1fa <__mcmp>
8000a7fa:	e0 89 00 12 	brgt	8000a81e <_dtoa_r+0xb62>
8000a7fe:	c1 b1       	brne	8000a834 <_dtoa_r+0xb78>
8000a800:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a804:	c0 d1       	brne	8000a81e <_dtoa_r+0xb62>
8000a806:	c1 78       	rjmp	8000a834 <_dtoa_r+0xb78>
8000a808:	40 89       	lddsp	r9,sp[0x20]
8000a80a:	12 38       	cp.w	r8,r9
8000a80c:	c0 30       	breq	8000a812 <_dtoa_r+0xb56>
8000a80e:	10 95       	mov	r5,r8
8000a810:	c0 88       	rjmp	8000a820 <_dtoa_r+0xb64>
8000a812:	2f f6       	sub	r6,-1
8000a814:	50 66       	stdsp	sp[0x18],r6
8000a816:	33 18       	mov	r8,49
8000a818:	40 8c       	lddsp	r12,sp[0x20]
8000a81a:	b8 88       	st.b	r12[0x0],r8
8000a81c:	c1 38       	rjmp	8000a842 <_dtoa_r+0xb86>
8000a81e:	33 9a       	mov	r10,57
8000a820:	0a 98       	mov	r8,r5
8000a822:	11 79       	ld.ub	r9,--r8
8000a824:	f4 09 18 00 	cp.b	r9,r10
8000a828:	cf 00       	breq	8000a808 <_dtoa_r+0xb4c>
8000a82a:	2f f9       	sub	r9,-1
8000a82c:	b0 89       	st.b	r8[0x0],r9
8000a82e:	c0 98       	rjmp	8000a840 <_dtoa_r+0xb84>
8000a830:	10 95       	mov	r5,r8
8000a832:	c0 28       	rjmp	8000a836 <_dtoa_r+0xb7a>
8000a834:	33 09       	mov	r9,48
8000a836:	0a 98       	mov	r8,r5
8000a838:	11 7a       	ld.ub	r10,--r8
8000a83a:	f2 0a 18 00 	cp.b	r10,r9
8000a83e:	cf 90       	breq	8000a830 <_dtoa_r+0xb74>
8000a840:	50 66       	stdsp	sp[0x18],r6
8000a842:	04 9b       	mov	r11,r2
8000a844:	0e 9c       	mov	r12,r7
8000a846:	e0 a0 04 f3 	rcall	8000b22c <_Bfree>
8000a84a:	58 04       	cp.w	r4,0
8000a84c:	c1 20       	breq	8000a870 <_dtoa_r+0xbb4>
8000a84e:	40 4b       	lddsp	r11,sp[0x10]
8000a850:	08 3b       	cp.w	r11,r4
8000a852:	5f 19       	srne	r9
8000a854:	58 0b       	cp.w	r11,0
8000a856:	5f 18       	srne	r8
8000a858:	f3 e8 00 08 	and	r8,r9,r8
8000a85c:	c0 40       	breq	8000a864 <_dtoa_r+0xba8>
8000a85e:	0e 9c       	mov	r12,r7
8000a860:	e0 a0 04 e6 	rcall	8000b22c <_Bfree>
8000a864:	08 9b       	mov	r11,r4
8000a866:	0e 9c       	mov	r12,r7
8000a868:	e0 a0 04 e2 	rcall	8000b22c <_Bfree>
8000a86c:	c0 28       	rjmp	8000a870 <_dtoa_r+0xbb4>
8000a86e:	50 66       	stdsp	sp[0x18],r6
8000a870:	0e 9c       	mov	r12,r7
8000a872:	06 9b       	mov	r11,r3
8000a874:	e0 a0 04 dc 	rcall	8000b22c <_Bfree>
8000a878:	30 08       	mov	r8,0
8000a87a:	aa 88       	st.b	r5[0x0],r8
8000a87c:	40 68       	lddsp	r8,sp[0x18]
8000a87e:	41 5a       	lddsp	r10,sp[0x54]
8000a880:	2f f8       	sub	r8,-1
8000a882:	41 29       	lddsp	r9,sp[0x48]
8000a884:	95 08       	st.w	r10[0x0],r8
8000a886:	40 8c       	lddsp	r12,sp[0x20]
8000a888:	58 09       	cp.w	r9,0
8000a88a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a88e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a892:	2e 6d       	sub	sp,-104
8000a894:	d8 32       	popm	r0-r7,pc
8000a896:	d7 03       	nop

8000a898 <__errno>:
8000a898:	e0 68 0a 38 	mov	r8,2616
8000a89c:	70 0c       	ld.w	r12,r8[0x0]
8000a89e:	2f 4c       	sub	r12,-12
8000a8a0:	5e fc       	retal	r12
8000a8a2:	d7 03       	nop

8000a8a4 <_fflush_r>:
8000a8a4:	d4 21       	pushm	r4-r7,lr
8000a8a6:	16 97       	mov	r7,r11
8000a8a8:	18 96       	mov	r6,r12
8000a8aa:	76 48       	ld.w	r8,r11[0x10]
8000a8ac:	58 08       	cp.w	r8,0
8000a8ae:	c7 f0       	breq	8000a9ac <_fflush_r+0x108>
8000a8b0:	58 0c       	cp.w	r12,0
8000a8b2:	c0 50       	breq	8000a8bc <_fflush_r+0x18>
8000a8b4:	78 68       	ld.w	r8,r12[0x18]
8000a8b6:	58 08       	cp.w	r8,0
8000a8b8:	c0 21       	brne	8000a8bc <_fflush_r+0x18>
8000a8ba:	cc dc       	rcall	8000aa54 <__sinit>
8000a8bc:	fe c8 ce 88 	sub	r8,pc,-12664
8000a8c0:	10 37       	cp.w	r7,r8
8000a8c2:	c0 31       	brne	8000a8c8 <_fflush_r+0x24>
8000a8c4:	6c 07       	ld.w	r7,r6[0x0]
8000a8c6:	c0 c8       	rjmp	8000a8de <_fflush_r+0x3a>
8000a8c8:	fe c8 ce 74 	sub	r8,pc,-12684
8000a8cc:	10 37       	cp.w	r7,r8
8000a8ce:	c0 31       	brne	8000a8d4 <_fflush_r+0x30>
8000a8d0:	6c 17       	ld.w	r7,r6[0x4]
8000a8d2:	c0 68       	rjmp	8000a8de <_fflush_r+0x3a>
8000a8d4:	fe c8 ce 60 	sub	r8,pc,-12704
8000a8d8:	10 37       	cp.w	r7,r8
8000a8da:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a8de:	8e 6a       	ld.sh	r10,r7[0xc]
8000a8e0:	14 98       	mov	r8,r10
8000a8e2:	ed ba 00 03 	bld	r10,0x3
8000a8e6:	c4 20       	breq	8000a96a <_fflush_r+0xc6>
8000a8e8:	ab ba       	sbr	r10,0xb
8000a8ea:	ae 6a       	st.h	r7[0xc],r10
8000a8ec:	6e 18       	ld.w	r8,r7[0x4]
8000a8ee:	58 08       	cp.w	r8,0
8000a8f0:	e0 89 00 06 	brgt	8000a8fc <_fflush_r+0x58>
8000a8f4:	6f 08       	ld.w	r8,r7[0x40]
8000a8f6:	58 08       	cp.w	r8,0
8000a8f8:	e0 8a 00 5a 	brle	8000a9ac <_fflush_r+0x108>
8000a8fc:	6e b8       	ld.w	r8,r7[0x2c]
8000a8fe:	58 08       	cp.w	r8,0
8000a900:	c5 60       	breq	8000a9ac <_fflush_r+0x108>
8000a902:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a906:	c0 30       	breq	8000a90c <_fflush_r+0x68>
8000a908:	6f 55       	ld.w	r5,r7[0x54]
8000a90a:	c0 f8       	rjmp	8000a928 <_fflush_r+0x84>
8000a90c:	30 19       	mov	r9,1
8000a90e:	6e 8b       	ld.w	r11,r7[0x20]
8000a910:	0c 9c       	mov	r12,r6
8000a912:	5d 18       	icall	r8
8000a914:	18 95       	mov	r5,r12
8000a916:	5b fc       	cp.w	r12,-1
8000a918:	c0 81       	brne	8000a928 <_fflush_r+0x84>
8000a91a:	6c 38       	ld.w	r8,r6[0xc]
8000a91c:	59 d8       	cp.w	r8,29
8000a91e:	c4 70       	breq	8000a9ac <_fflush_r+0x108>
8000a920:	8e 68       	ld.sh	r8,r7[0xc]
8000a922:	a7 a8       	sbr	r8,0x6
8000a924:	ae 68       	st.h	r7[0xc],r8
8000a926:	d8 22       	popm	r4-r7,pc
8000a928:	8e 68       	ld.sh	r8,r7[0xc]
8000a92a:	ed b8 00 02 	bld	r8,0x2
8000a92e:	c0 91       	brne	8000a940 <_fflush_r+0x9c>
8000a930:	6e 18       	ld.w	r8,r7[0x4]
8000a932:	10 15       	sub	r5,r8
8000a934:	6e d8       	ld.w	r8,r7[0x34]
8000a936:	58 08       	cp.w	r8,0
8000a938:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a93c:	eb d8 e1 15 	subne	r5,r5,r8
8000a940:	6e b8       	ld.w	r8,r7[0x2c]
8000a942:	0c 9c       	mov	r12,r6
8000a944:	30 09       	mov	r9,0
8000a946:	0a 9a       	mov	r10,r5
8000a948:	6e 8b       	ld.w	r11,r7[0x20]
8000a94a:	5d 18       	icall	r8
8000a94c:	8e 68       	ld.sh	r8,r7[0xc]
8000a94e:	0a 3c       	cp.w	r12,r5
8000a950:	c2 61       	brne	8000a99c <_fflush_r+0xf8>
8000a952:	ab d8       	cbr	r8,0xb
8000a954:	30 0c       	mov	r12,0
8000a956:	6e 49       	ld.w	r9,r7[0x10]
8000a958:	ae 68       	st.h	r7[0xc],r8
8000a95a:	8f 1c       	st.w	r7[0x4],r12
8000a95c:	8f 09       	st.w	r7[0x0],r9
8000a95e:	ed b8 00 0c 	bld	r8,0xc
8000a962:	c2 51       	brne	8000a9ac <_fflush_r+0x108>
8000a964:	ef 45 00 54 	st.w	r7[84],r5
8000a968:	d8 22       	popm	r4-r7,pc
8000a96a:	6e 45       	ld.w	r5,r7[0x10]
8000a96c:	58 05       	cp.w	r5,0
8000a96e:	c1 f0       	breq	8000a9ac <_fflush_r+0x108>
8000a970:	6e 04       	ld.w	r4,r7[0x0]
8000a972:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a976:	8f 05       	st.w	r7[0x0],r5
8000a978:	f9 b8 01 00 	movne	r8,0
8000a97c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a980:	0a 14       	sub	r4,r5
8000a982:	8f 28       	st.w	r7[0x8],r8
8000a984:	c1 18       	rjmp	8000a9a6 <_fflush_r+0x102>
8000a986:	08 99       	mov	r9,r4
8000a988:	0a 9a       	mov	r10,r5
8000a98a:	6e a8       	ld.w	r8,r7[0x28]
8000a98c:	6e 8b       	ld.w	r11,r7[0x20]
8000a98e:	0c 9c       	mov	r12,r6
8000a990:	5d 18       	icall	r8
8000a992:	18 14       	sub	r4,r12
8000a994:	58 0c       	cp.w	r12,0
8000a996:	e0 89 00 07 	brgt	8000a9a4 <_fflush_r+0x100>
8000a99a:	8e 68       	ld.sh	r8,r7[0xc]
8000a99c:	a7 a8       	sbr	r8,0x6
8000a99e:	3f fc       	mov	r12,-1
8000a9a0:	ae 68       	st.h	r7[0xc],r8
8000a9a2:	d8 22       	popm	r4-r7,pc
8000a9a4:	18 05       	add	r5,r12
8000a9a6:	58 04       	cp.w	r4,0
8000a9a8:	fe 99 ff ef 	brgt	8000a986 <_fflush_r+0xe2>
8000a9ac:	d8 2a       	popm	r4-r7,pc,r12=0
8000a9ae:	d7 03       	nop

8000a9b0 <__sfp_lock_acquire>:
8000a9b0:	5e fc       	retal	r12

8000a9b2 <__sfp_lock_release>:
8000a9b2:	5e fc       	retal	r12

8000a9b4 <_cleanup_r>:
8000a9b4:	d4 01       	pushm	lr
8000a9b6:	fe cb f0 ae 	sub	r11,pc,-3922
8000a9ba:	e0 a0 02 f7 	rcall	8000afa8 <_fwalk>
8000a9be:	d8 02       	popm	pc

8000a9c0 <__sfmoreglue>:
8000a9c0:	d4 21       	pushm	r4-r7,lr
8000a9c2:	16 95       	mov	r5,r11
8000a9c4:	f6 06 10 5c 	mul	r6,r11,92
8000a9c8:	ec cb ff f4 	sub	r11,r6,-12
8000a9cc:	fe b0 e2 76 	rcall	80006eb8 <_malloc_r>
8000a9d0:	18 97       	mov	r7,r12
8000a9d2:	c0 90       	breq	8000a9e4 <__sfmoreglue+0x24>
8000a9d4:	99 15       	st.w	r12[0x4],r5
8000a9d6:	30 0b       	mov	r11,0
8000a9d8:	2f 4c       	sub	r12,-12
8000a9da:	0c 9a       	mov	r10,r6
8000a9dc:	8f 2c       	st.w	r7[0x8],r12
8000a9de:	8f 0b       	st.w	r7[0x0],r11
8000a9e0:	fe b0 e5 3f 	rcall	8000745e <memset>
8000a9e4:	0e 9c       	mov	r12,r7
8000a9e6:	d8 22       	popm	r4-r7,pc

8000a9e8 <__sfp>:
8000a9e8:	d4 21       	pushm	r4-r7,lr
8000a9ea:	fe c8 cf 52 	sub	r8,pc,-12462
8000a9ee:	18 96       	mov	r6,r12
8000a9f0:	70 07       	ld.w	r7,r8[0x0]
8000a9f2:	6e 68       	ld.w	r8,r7[0x18]
8000a9f4:	58 08       	cp.w	r8,0
8000a9f6:	c0 31       	brne	8000a9fc <__sfp+0x14>
8000a9f8:	0e 9c       	mov	r12,r7
8000a9fa:	c2 dc       	rcall	8000aa54 <__sinit>
8000a9fc:	ee c7 ff 28 	sub	r7,r7,-216
8000aa00:	30 05       	mov	r5,0
8000aa02:	6e 2c       	ld.w	r12,r7[0x8]
8000aa04:	6e 18       	ld.w	r8,r7[0x4]
8000aa06:	c0 68       	rjmp	8000aa12 <__sfp+0x2a>
8000aa08:	98 69       	ld.sh	r9,r12[0xc]
8000aa0a:	ea 09 19 00 	cp.h	r9,r5
8000aa0e:	c1 10       	breq	8000aa30 <__sfp+0x48>
8000aa10:	2a 4c       	sub	r12,-92
8000aa12:	20 18       	sub	r8,1
8000aa14:	cf a7       	brpl	8000aa08 <__sfp+0x20>
8000aa16:	6e 08       	ld.w	r8,r7[0x0]
8000aa18:	58 08       	cp.w	r8,0
8000aa1a:	c0 61       	brne	8000aa26 <__sfp+0x3e>
8000aa1c:	30 4b       	mov	r11,4
8000aa1e:	0c 9c       	mov	r12,r6
8000aa20:	cd 0f       	rcall	8000a9c0 <__sfmoreglue>
8000aa22:	8f 0c       	st.w	r7[0x0],r12
8000aa24:	c0 30       	breq	8000aa2a <__sfp+0x42>
8000aa26:	6e 07       	ld.w	r7,r7[0x0]
8000aa28:	ce db       	rjmp	8000aa02 <__sfp+0x1a>
8000aa2a:	30 c8       	mov	r8,12
8000aa2c:	8d 38       	st.w	r6[0xc],r8
8000aa2e:	d8 22       	popm	r4-r7,pc
8000aa30:	30 08       	mov	r8,0
8000aa32:	f9 48 00 4c 	st.w	r12[76],r8
8000aa36:	99 08       	st.w	r12[0x0],r8
8000aa38:	99 28       	st.w	r12[0x8],r8
8000aa3a:	99 18       	st.w	r12[0x4],r8
8000aa3c:	99 48       	st.w	r12[0x10],r8
8000aa3e:	99 58       	st.w	r12[0x14],r8
8000aa40:	99 68       	st.w	r12[0x18],r8
8000aa42:	99 d8       	st.w	r12[0x34],r8
8000aa44:	99 e8       	st.w	r12[0x38],r8
8000aa46:	f9 48 00 48 	st.w	r12[72],r8
8000aa4a:	3f f8       	mov	r8,-1
8000aa4c:	b8 78       	st.h	r12[0xe],r8
8000aa4e:	30 18       	mov	r8,1
8000aa50:	b8 68       	st.h	r12[0xc],r8
8000aa52:	d8 22       	popm	r4-r7,pc

8000aa54 <__sinit>:
8000aa54:	d4 21       	pushm	r4-r7,lr
8000aa56:	18 96       	mov	r6,r12
8000aa58:	78 67       	ld.w	r7,r12[0x18]
8000aa5a:	58 07       	cp.w	r7,0
8000aa5c:	c4 91       	brne	8000aaee <__sinit+0x9a>
8000aa5e:	fe c8 00 aa 	sub	r8,pc,170
8000aa62:	30 15       	mov	r5,1
8000aa64:	99 a8       	st.w	r12[0x28],r8
8000aa66:	f9 47 00 d8 	st.w	r12[216],r7
8000aa6a:	f9 47 00 dc 	st.w	r12[220],r7
8000aa6e:	f9 47 00 e0 	st.w	r12[224],r7
8000aa72:	99 65       	st.w	r12[0x18],r5
8000aa74:	cb af       	rcall	8000a9e8 <__sfp>
8000aa76:	8d 0c       	st.w	r6[0x0],r12
8000aa78:	0c 9c       	mov	r12,r6
8000aa7a:	cb 7f       	rcall	8000a9e8 <__sfp>
8000aa7c:	8d 1c       	st.w	r6[0x4],r12
8000aa7e:	0c 9c       	mov	r12,r6
8000aa80:	cb 4f       	rcall	8000a9e8 <__sfp>
8000aa82:	6c 09       	ld.w	r9,r6[0x0]
8000aa84:	30 48       	mov	r8,4
8000aa86:	93 07       	st.w	r9[0x0],r7
8000aa88:	b2 68       	st.h	r9[0xc],r8
8000aa8a:	93 17       	st.w	r9[0x4],r7
8000aa8c:	93 27       	st.w	r9[0x8],r7
8000aa8e:	6c 18       	ld.w	r8,r6[0x4]
8000aa90:	b2 77       	st.h	r9[0xe],r7
8000aa92:	93 47       	st.w	r9[0x10],r7
8000aa94:	93 57       	st.w	r9[0x14],r7
8000aa96:	93 67       	st.w	r9[0x18],r7
8000aa98:	93 89       	st.w	r9[0x20],r9
8000aa9a:	91 07       	st.w	r8[0x0],r7
8000aa9c:	91 17       	st.w	r8[0x4],r7
8000aa9e:	91 27       	st.w	r8[0x8],r7
8000aaa0:	fe ce f3 24 	sub	lr,pc,-3292
8000aaa4:	fe cb f3 54 	sub	r11,pc,-3244
8000aaa8:	93 9e       	st.w	r9[0x24],lr
8000aaaa:	93 ab       	st.w	r9[0x28],r11
8000aaac:	fe ca f3 7c 	sub	r10,pc,-3204
8000aab0:	fe c4 f3 88 	sub	r4,pc,-3192
8000aab4:	93 ba       	st.w	r9[0x2c],r10
8000aab6:	93 c4       	st.w	r9[0x30],r4
8000aab8:	30 99       	mov	r9,9
8000aaba:	b0 69       	st.h	r8[0xc],r9
8000aabc:	b0 75       	st.h	r8[0xe],r5
8000aabe:	91 c4       	st.w	r8[0x30],r4
8000aac0:	91 47       	st.w	r8[0x10],r7
8000aac2:	91 57       	st.w	r8[0x14],r7
8000aac4:	91 67       	st.w	r8[0x18],r7
8000aac6:	91 88       	st.w	r8[0x20],r8
8000aac8:	91 9e       	st.w	r8[0x24],lr
8000aaca:	91 ab       	st.w	r8[0x28],r11
8000aacc:	91 ba       	st.w	r8[0x2c],r10
8000aace:	8d 2c       	st.w	r6[0x8],r12
8000aad0:	31 28       	mov	r8,18
8000aad2:	99 07       	st.w	r12[0x0],r7
8000aad4:	b8 68       	st.h	r12[0xc],r8
8000aad6:	99 17       	st.w	r12[0x4],r7
8000aad8:	99 27       	st.w	r12[0x8],r7
8000aada:	30 28       	mov	r8,2
8000aadc:	b8 78       	st.h	r12[0xe],r8
8000aade:	99 c4       	st.w	r12[0x30],r4
8000aae0:	99 67       	st.w	r12[0x18],r7
8000aae2:	99 9e       	st.w	r12[0x24],lr
8000aae4:	99 ab       	st.w	r12[0x28],r11
8000aae6:	99 ba       	st.w	r12[0x2c],r10
8000aae8:	99 47       	st.w	r12[0x10],r7
8000aaea:	99 57       	st.w	r12[0x14],r7
8000aaec:	99 8c       	st.w	r12[0x20],r12
8000aaee:	d8 22       	popm	r4-r7,pc

8000aaf0 <_malloc_trim_r>:
8000aaf0:	d4 21       	pushm	r4-r7,lr
8000aaf2:	16 95       	mov	r5,r11
8000aaf4:	18 97       	mov	r7,r12
8000aaf6:	fe b0 d7 df 	rcall	80005ab4 <__malloc_lock>
8000aafa:	e0 64 05 38 	mov	r4,1336
8000aafe:	68 28       	ld.w	r8,r4[0x8]
8000ab00:	70 16       	ld.w	r6,r8[0x4]
8000ab02:	e0 16 ff fc 	andl	r6,0xfffc
8000ab06:	ec c8 ff 91 	sub	r8,r6,-111
8000ab0a:	f0 05 01 05 	sub	r5,r8,r5
8000ab0e:	e0 15 ff 80 	andl	r5,0xff80
8000ab12:	ea c5 00 80 	sub	r5,r5,128
8000ab16:	e0 45 00 7f 	cp.w	r5,127
8000ab1a:	e0 8a 00 25 	brle	8000ab64 <_malloc_trim_r+0x74>
8000ab1e:	30 0b       	mov	r11,0
8000ab20:	0e 9c       	mov	r12,r7
8000ab22:	fe b0 e6 05 	rcall	8000772c <_sbrk_r>
8000ab26:	68 28       	ld.w	r8,r4[0x8]
8000ab28:	0c 08       	add	r8,r6
8000ab2a:	10 3c       	cp.w	r12,r8
8000ab2c:	c1 c1       	brne	8000ab64 <_malloc_trim_r+0x74>
8000ab2e:	ea 0b 11 00 	rsub	r11,r5,0
8000ab32:	0e 9c       	mov	r12,r7
8000ab34:	fe b0 e5 fc 	rcall	8000772c <_sbrk_r>
8000ab38:	5b fc       	cp.w	r12,-1
8000ab3a:	c1 91       	brne	8000ab6c <_malloc_trim_r+0x7c>
8000ab3c:	30 0b       	mov	r11,0
8000ab3e:	0e 9c       	mov	r12,r7
8000ab40:	fe b0 e5 f6 	rcall	8000772c <_sbrk_r>
8000ab44:	68 28       	ld.w	r8,r4[0x8]
8000ab46:	f8 08 01 09 	sub	r9,r12,r8
8000ab4a:	58 f9       	cp.w	r9,15
8000ab4c:	e0 8a 00 0c 	brle	8000ab64 <_malloc_trim_r+0x74>
8000ab50:	a1 a9       	sbr	r9,0x0
8000ab52:	91 19       	st.w	r8[0x4],r9
8000ab54:	e0 68 09 44 	mov	r8,2372
8000ab58:	70 09       	ld.w	r9,r8[0x0]
8000ab5a:	e0 68 0d 60 	mov	r8,3424
8000ab5e:	f8 09 01 09 	sub	r9,r12,r9
8000ab62:	91 09       	st.w	r8[0x0],r9
8000ab64:	0e 9c       	mov	r12,r7
8000ab66:	fe b0 d7 ad 	rcall	80005ac0 <__malloc_unlock>
8000ab6a:	d8 2a       	popm	r4-r7,pc,r12=0
8000ab6c:	68 28       	ld.w	r8,r4[0x8]
8000ab6e:	0a 16       	sub	r6,r5
8000ab70:	a1 a6       	sbr	r6,0x0
8000ab72:	91 16       	st.w	r8[0x4],r6
8000ab74:	e0 68 0d 60 	mov	r8,3424
8000ab78:	70 09       	ld.w	r9,r8[0x0]
8000ab7a:	0a 19       	sub	r9,r5
8000ab7c:	0e 9c       	mov	r12,r7
8000ab7e:	91 09       	st.w	r8[0x0],r9
8000ab80:	fe b0 d7 a0 	rcall	80005ac0 <__malloc_unlock>
8000ab84:	da 2a       	popm	r4-r7,pc,r12=1
8000ab86:	d7 03       	nop

8000ab88 <_free_r>:
8000ab88:	d4 21       	pushm	r4-r7,lr
8000ab8a:	16 96       	mov	r6,r11
8000ab8c:	18 97       	mov	r7,r12
8000ab8e:	58 0b       	cp.w	r11,0
8000ab90:	e0 80 00 c0 	breq	8000ad10 <_free_r+0x188>
8000ab94:	fe b0 d7 90 	rcall	80005ab4 <__malloc_lock>
8000ab98:	20 86       	sub	r6,8
8000ab9a:	e0 6a 05 38 	mov	r10,1336
8000ab9e:	6c 18       	ld.w	r8,r6[0x4]
8000aba0:	74 2e       	ld.w	lr,r10[0x8]
8000aba2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aba6:	a1 c8       	cbr	r8,0x0
8000aba8:	ec 08 00 09 	add	r9,r6,r8
8000abac:	72 1b       	ld.w	r11,r9[0x4]
8000abae:	e0 1b ff fc 	andl	r11,0xfffc
8000abb2:	1c 39       	cp.w	r9,lr
8000abb4:	c1 e1       	brne	8000abf0 <_free_r+0x68>
8000abb6:	f6 08 00 08 	add	r8,r11,r8
8000abba:	58 0c       	cp.w	r12,0
8000abbc:	c0 81       	brne	8000abcc <_free_r+0x44>
8000abbe:	6c 09       	ld.w	r9,r6[0x0]
8000abc0:	12 16       	sub	r6,r9
8000abc2:	12 08       	add	r8,r9
8000abc4:	6c 3b       	ld.w	r11,r6[0xc]
8000abc6:	6c 29       	ld.w	r9,r6[0x8]
8000abc8:	97 29       	st.w	r11[0x8],r9
8000abca:	93 3b       	st.w	r9[0xc],r11
8000abcc:	10 99       	mov	r9,r8
8000abce:	95 26       	st.w	r10[0x8],r6
8000abd0:	a1 a9       	sbr	r9,0x0
8000abd2:	8d 19       	st.w	r6[0x4],r9
8000abd4:	e0 69 09 40 	mov	r9,2368
8000abd8:	72 09       	ld.w	r9,r9[0x0]
8000abda:	12 38       	cp.w	r8,r9
8000abdc:	c0 63       	brcs	8000abe8 <_free_r+0x60>
8000abde:	e0 68 0d 5c 	mov	r8,3420
8000abe2:	0e 9c       	mov	r12,r7
8000abe4:	70 0b       	ld.w	r11,r8[0x0]
8000abe6:	c8 5f       	rcall	8000aaf0 <_malloc_trim_r>
8000abe8:	0e 9c       	mov	r12,r7
8000abea:	fe b0 d7 6b 	rcall	80005ac0 <__malloc_unlock>
8000abee:	d8 22       	popm	r4-r7,pc
8000abf0:	93 1b       	st.w	r9[0x4],r11
8000abf2:	58 0c       	cp.w	r12,0
8000abf4:	c0 30       	breq	8000abfa <_free_r+0x72>
8000abf6:	30 0c       	mov	r12,0
8000abf8:	c1 08       	rjmp	8000ac18 <_free_r+0x90>
8000abfa:	6c 0e       	ld.w	lr,r6[0x0]
8000abfc:	f4 c5 ff f8 	sub	r5,r10,-8
8000ac00:	1c 16       	sub	r6,lr
8000ac02:	1c 08       	add	r8,lr
8000ac04:	6c 2e       	ld.w	lr,r6[0x8]
8000ac06:	0a 3e       	cp.w	lr,r5
8000ac08:	f9 bc 00 01 	moveq	r12,1
8000ac0c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ac10:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ac14:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ac18:	f2 0b 00 0e 	add	lr,r9,r11
8000ac1c:	7c 1e       	ld.w	lr,lr[0x4]
8000ac1e:	ed be 00 00 	bld	lr,0x0
8000ac22:	c1 40       	breq	8000ac4a <_free_r+0xc2>
8000ac24:	16 08       	add	r8,r11
8000ac26:	58 0c       	cp.w	r12,0
8000ac28:	c0 d1       	brne	8000ac42 <_free_r+0xba>
8000ac2a:	e0 6e 05 38 	mov	lr,1336
8000ac2e:	72 2b       	ld.w	r11,r9[0x8]
8000ac30:	2f 8e       	sub	lr,-8
8000ac32:	1c 3b       	cp.w	r11,lr
8000ac34:	c0 71       	brne	8000ac42 <_free_r+0xba>
8000ac36:	97 36       	st.w	r11[0xc],r6
8000ac38:	97 26       	st.w	r11[0x8],r6
8000ac3a:	8d 2b       	st.w	r6[0x8],r11
8000ac3c:	8d 3b       	st.w	r6[0xc],r11
8000ac3e:	30 1c       	mov	r12,1
8000ac40:	c0 58       	rjmp	8000ac4a <_free_r+0xc2>
8000ac42:	72 2b       	ld.w	r11,r9[0x8]
8000ac44:	72 39       	ld.w	r9,r9[0xc]
8000ac46:	93 2b       	st.w	r9[0x8],r11
8000ac48:	97 39       	st.w	r11[0xc],r9
8000ac4a:	10 99       	mov	r9,r8
8000ac4c:	ec 08 09 08 	st.w	r6[r8],r8
8000ac50:	a1 a9       	sbr	r9,0x0
8000ac52:	8d 19       	st.w	r6[0x4],r9
8000ac54:	58 0c       	cp.w	r12,0
8000ac56:	c5 a1       	brne	8000ad0a <_free_r+0x182>
8000ac58:	e0 48 01 ff 	cp.w	r8,511
8000ac5c:	e0 8b 00 13 	brhi	8000ac82 <_free_r+0xfa>
8000ac60:	a3 98       	lsr	r8,0x3
8000ac62:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ac66:	72 2b       	ld.w	r11,r9[0x8]
8000ac68:	8d 39       	st.w	r6[0xc],r9
8000ac6a:	8d 2b       	st.w	r6[0x8],r11
8000ac6c:	97 36       	st.w	r11[0xc],r6
8000ac6e:	93 26       	st.w	r9[0x8],r6
8000ac70:	a3 48       	asr	r8,0x2
8000ac72:	74 19       	ld.w	r9,r10[0x4]
8000ac74:	30 1b       	mov	r11,1
8000ac76:	f6 08 09 48 	lsl	r8,r11,r8
8000ac7a:	f3 e8 10 08 	or	r8,r9,r8
8000ac7e:	95 18       	st.w	r10[0x4],r8
8000ac80:	c4 58       	rjmp	8000ad0a <_free_r+0x182>
8000ac82:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ac86:	58 4b       	cp.w	r11,4
8000ac88:	e0 8b 00 06 	brhi	8000ac94 <_free_r+0x10c>
8000ac8c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ac90:	2c 8b       	sub	r11,-56
8000ac92:	c2 08       	rjmp	8000acd2 <_free_r+0x14a>
8000ac94:	59 4b       	cp.w	r11,20
8000ac96:	e0 8b 00 04 	brhi	8000ac9e <_free_r+0x116>
8000ac9a:	2a 5b       	sub	r11,-91
8000ac9c:	c1 b8       	rjmp	8000acd2 <_free_r+0x14a>
8000ac9e:	e0 4b 00 54 	cp.w	r11,84
8000aca2:	e0 8b 00 06 	brhi	8000acae <_free_r+0x126>
8000aca6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000acaa:	29 2b       	sub	r11,-110
8000acac:	c1 38       	rjmp	8000acd2 <_free_r+0x14a>
8000acae:	e0 4b 01 54 	cp.w	r11,340
8000acb2:	e0 8b 00 06 	brhi	8000acbe <_free_r+0x136>
8000acb6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000acba:	28 9b       	sub	r11,-119
8000acbc:	c0 b8       	rjmp	8000acd2 <_free_r+0x14a>
8000acbe:	e0 4b 05 54 	cp.w	r11,1364
8000acc2:	e0 88 00 05 	brls	8000accc <_free_r+0x144>
8000acc6:	37 eb       	mov	r11,126
8000acc8:	c0 58       	rjmp	8000acd2 <_free_r+0x14a>
8000acca:	d7 03       	nop
8000accc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000acd0:	28 4b       	sub	r11,-124
8000acd2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000acd6:	78 29       	ld.w	r9,r12[0x8]
8000acd8:	18 39       	cp.w	r9,r12
8000acda:	c0 e1       	brne	8000acf6 <_free_r+0x16e>
8000acdc:	74 18       	ld.w	r8,r10[0x4]
8000acde:	a3 4b       	asr	r11,0x2
8000ace0:	30 1c       	mov	r12,1
8000ace2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ace6:	f1 eb 10 0b 	or	r11,r8,r11
8000acea:	12 98       	mov	r8,r9
8000acec:	95 1b       	st.w	r10[0x4],r11
8000acee:	c0 a8       	rjmp	8000ad02 <_free_r+0x17a>
8000acf0:	72 29       	ld.w	r9,r9[0x8]
8000acf2:	18 39       	cp.w	r9,r12
8000acf4:	c0 60       	breq	8000ad00 <_free_r+0x178>
8000acf6:	72 1a       	ld.w	r10,r9[0x4]
8000acf8:	e0 1a ff fc 	andl	r10,0xfffc
8000acfc:	14 38       	cp.w	r8,r10
8000acfe:	cf 93       	brcs	8000acf0 <_free_r+0x168>
8000ad00:	72 38       	ld.w	r8,r9[0xc]
8000ad02:	8d 38       	st.w	r6[0xc],r8
8000ad04:	8d 29       	st.w	r6[0x8],r9
8000ad06:	93 36       	st.w	r9[0xc],r6
8000ad08:	91 26       	st.w	r8[0x8],r6
8000ad0a:	0e 9c       	mov	r12,r7
8000ad0c:	fe b0 d6 da 	rcall	80005ac0 <__malloc_unlock>
8000ad10:	d8 22       	popm	r4-r7,pc
8000ad12:	d7 03       	nop

8000ad14 <__sfvwrite_r>:
8000ad14:	d4 31       	pushm	r0-r7,lr
8000ad16:	20 3d       	sub	sp,12
8000ad18:	14 94       	mov	r4,r10
8000ad1a:	18 95       	mov	r5,r12
8000ad1c:	16 97       	mov	r7,r11
8000ad1e:	74 28       	ld.w	r8,r10[0x8]
8000ad20:	58 08       	cp.w	r8,0
8000ad22:	e0 80 01 40 	breq	8000afa2 <__sfvwrite_r+0x28e>
8000ad26:	96 68       	ld.sh	r8,r11[0xc]
8000ad28:	ed b8 00 03 	bld	r8,0x3
8000ad2c:	c0 41       	brne	8000ad34 <__sfvwrite_r+0x20>
8000ad2e:	76 48       	ld.w	r8,r11[0x10]
8000ad30:	58 08       	cp.w	r8,0
8000ad32:	c0 c1       	brne	8000ad4a <__sfvwrite_r+0x36>
8000ad34:	0e 9b       	mov	r11,r7
8000ad36:	0a 9c       	mov	r12,r5
8000ad38:	fe b0 f6 c4 	rcall	80009ac0 <__swsetup_r>
8000ad3c:	c0 70       	breq	8000ad4a <__sfvwrite_r+0x36>
8000ad3e:	8e 68       	ld.sh	r8,r7[0xc]
8000ad40:	a7 a8       	sbr	r8,0x6
8000ad42:	ae 68       	st.h	r7[0xc],r8
8000ad44:	30 98       	mov	r8,9
8000ad46:	8b 38       	st.w	r5[0xc],r8
8000ad48:	c2 b9       	rjmp	8000af9e <__sfvwrite_r+0x28a>
8000ad4a:	8e 63       	ld.sh	r3,r7[0xc]
8000ad4c:	68 00       	ld.w	r0,r4[0x0]
8000ad4e:	06 96       	mov	r6,r3
8000ad50:	e2 16 00 02 	andl	r6,0x2,COH
8000ad54:	c2 10       	breq	8000ad96 <__sfvwrite_r+0x82>
8000ad56:	30 03       	mov	r3,0
8000ad58:	e0 62 04 00 	mov	r2,1024
8000ad5c:	06 96       	mov	r6,r3
8000ad5e:	c0 48       	rjmp	8000ad66 <__sfvwrite_r+0x52>
8000ad60:	60 03       	ld.w	r3,r0[0x0]
8000ad62:	60 16       	ld.w	r6,r0[0x4]
8000ad64:	2f 80       	sub	r0,-8
8000ad66:	58 06       	cp.w	r6,0
8000ad68:	cf c0       	breq	8000ad60 <__sfvwrite_r+0x4c>
8000ad6a:	e0 46 04 00 	cp.w	r6,1024
8000ad6e:	ec 09 17 80 	movls	r9,r6
8000ad72:	e4 09 17 b0 	movhi	r9,r2
8000ad76:	06 9a       	mov	r10,r3
8000ad78:	6e a8       	ld.w	r8,r7[0x28]
8000ad7a:	6e 8b       	ld.w	r11,r7[0x20]
8000ad7c:	0a 9c       	mov	r12,r5
8000ad7e:	5d 18       	icall	r8
8000ad80:	18 16       	sub	r6,r12
8000ad82:	58 0c       	cp.w	r12,0
8000ad84:	e0 8a 01 0a 	brle	8000af98 <__sfvwrite_r+0x284>
8000ad88:	68 28       	ld.w	r8,r4[0x8]
8000ad8a:	18 18       	sub	r8,r12
8000ad8c:	89 28       	st.w	r4[0x8],r8
8000ad8e:	e0 80 01 0a 	breq	8000afa2 <__sfvwrite_r+0x28e>
8000ad92:	18 03       	add	r3,r12
8000ad94:	ce 9b       	rjmp	8000ad66 <__sfvwrite_r+0x52>
8000ad96:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ad9a:	c0 70       	breq	8000ada8 <__sfvwrite_r+0x94>
8000ad9c:	50 06       	stdsp	sp[0x0],r6
8000ad9e:	0c 93       	mov	r3,r6
8000ada0:	0c 91       	mov	r1,r6
8000ada2:	50 15       	stdsp	sp[0x4],r5
8000ada4:	08 92       	mov	r2,r4
8000ada6:	c9 c8       	rjmp	8000aede <__sfvwrite_r+0x1ca>
8000ada8:	06 96       	mov	r6,r3
8000adaa:	08 91       	mov	r1,r4
8000adac:	c0 48       	rjmp	8000adb4 <__sfvwrite_r+0xa0>
8000adae:	60 03       	ld.w	r3,r0[0x0]
8000adb0:	60 16       	ld.w	r6,r0[0x4]
8000adb2:	2f 80       	sub	r0,-8
8000adb4:	58 06       	cp.w	r6,0
8000adb6:	cf c0       	breq	8000adae <__sfvwrite_r+0x9a>
8000adb8:	8e 68       	ld.sh	r8,r7[0xc]
8000adba:	6e 24       	ld.w	r4,r7[0x8]
8000adbc:	10 99       	mov	r9,r8
8000adbe:	e2 19 02 00 	andl	r9,0x200,COH
8000adc2:	c5 50       	breq	8000ae6c <__sfvwrite_r+0x158>
8000adc4:	08 36       	cp.w	r6,r4
8000adc6:	c4 43       	brcs	8000ae4e <__sfvwrite_r+0x13a>
8000adc8:	10 99       	mov	r9,r8
8000adca:	e2 19 04 80 	andl	r9,0x480,COH
8000adce:	c4 00       	breq	8000ae4e <__sfvwrite_r+0x13a>
8000add0:	6e 4b       	ld.w	r11,r7[0x10]
8000add2:	6e 09       	ld.w	r9,r7[0x0]
8000add4:	16 19       	sub	r9,r11
8000add6:	50 09       	stdsp	sp[0x0],r9
8000add8:	6e 59       	ld.w	r9,r7[0x14]
8000adda:	10 9c       	mov	r12,r8
8000addc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ade0:	30 28       	mov	r8,2
8000ade2:	f4 08 0c 08 	divs	r8,r10,r8
8000ade6:	fa e9 00 04 	st.d	sp[4],r8
8000adea:	10 94       	mov	r4,r8
8000adec:	40 09       	lddsp	r9,sp[0x0]
8000adee:	e2 1c 04 00 	andl	r12,0x400,COH
8000adf2:	2f f9       	sub	r9,-1
8000adf4:	0c 09       	add	r9,r6
8000adf6:	12 38       	cp.w	r8,r9
8000adf8:	f2 04 17 30 	movlo	r4,r9
8000adfc:	58 0c       	cp.w	r12,0
8000adfe:	c1 10       	breq	8000ae20 <__sfvwrite_r+0x10c>
8000ae00:	08 9b       	mov	r11,r4
8000ae02:	0a 9c       	mov	r12,r5
8000ae04:	fe b0 e0 5a 	rcall	80006eb8 <_malloc_r>
8000ae08:	18 92       	mov	r2,r12
8000ae0a:	c1 40       	breq	8000ae32 <__sfvwrite_r+0x11e>
8000ae0c:	40 0a       	lddsp	r10,sp[0x0]
8000ae0e:	6e 4b       	ld.w	r11,r7[0x10]
8000ae10:	fe b0 e2 83 	rcall	80007316 <memcpy>
8000ae14:	8e 68       	ld.sh	r8,r7[0xc]
8000ae16:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ae1a:	a7 b8       	sbr	r8,0x7
8000ae1c:	ae 68       	st.h	r7[0xc],r8
8000ae1e:	c0 d8       	rjmp	8000ae38 <__sfvwrite_r+0x124>
8000ae20:	08 9a       	mov	r10,r4
8000ae22:	0a 9c       	mov	r12,r5
8000ae24:	fe b0 e3 24 	rcall	8000746c <_realloc_r>
8000ae28:	18 92       	mov	r2,r12
8000ae2a:	c0 71       	brne	8000ae38 <__sfvwrite_r+0x124>
8000ae2c:	6e 4b       	ld.w	r11,r7[0x10]
8000ae2e:	0a 9c       	mov	r12,r5
8000ae30:	ca ce       	rcall	8000ab88 <_free_r>
8000ae32:	30 c8       	mov	r8,12
8000ae34:	8b 38       	st.w	r5[0xc],r8
8000ae36:	cb 18       	rjmp	8000af98 <__sfvwrite_r+0x284>
8000ae38:	40 0a       	lddsp	r10,sp[0x0]
8000ae3a:	40 09       	lddsp	r9,sp[0x0]
8000ae3c:	e8 0a 01 0a 	sub	r10,r4,r10
8000ae40:	e4 09 00 08 	add	r8,r2,r9
8000ae44:	8f 54       	st.w	r7[0x14],r4
8000ae46:	8f 2a       	st.w	r7[0x8],r10
8000ae48:	8f 08       	st.w	r7[0x0],r8
8000ae4a:	8f 42       	st.w	r7[0x10],r2
8000ae4c:	0c 94       	mov	r4,r6
8000ae4e:	08 36       	cp.w	r6,r4
8000ae50:	ec 04 17 30 	movlo	r4,r6
8000ae54:	06 9b       	mov	r11,r3
8000ae56:	08 9a       	mov	r10,r4
8000ae58:	6e 0c       	ld.w	r12,r7[0x0]
8000ae5a:	c3 ad       	rcall	8000b0ce <memmove>
8000ae5c:	6e 08       	ld.w	r8,r7[0x0]
8000ae5e:	08 08       	add	r8,r4
8000ae60:	8f 08       	st.w	r7[0x0],r8
8000ae62:	6e 28       	ld.w	r8,r7[0x8]
8000ae64:	08 18       	sub	r8,r4
8000ae66:	0c 94       	mov	r4,r6
8000ae68:	8f 28       	st.w	r7[0x8],r8
8000ae6a:	c2 e8       	rjmp	8000aec6 <__sfvwrite_r+0x1b2>
8000ae6c:	08 36       	cp.w	r6,r4
8000ae6e:	5f ba       	srhi	r10
8000ae70:	6e 0c       	ld.w	r12,r7[0x0]
8000ae72:	6e 48       	ld.w	r8,r7[0x10]
8000ae74:	10 3c       	cp.w	r12,r8
8000ae76:	5f b8       	srhi	r8
8000ae78:	f5 e8 00 08 	and	r8,r10,r8
8000ae7c:	f2 08 18 00 	cp.b	r8,r9
8000ae80:	c0 d0       	breq	8000ae9a <__sfvwrite_r+0x186>
8000ae82:	06 9b       	mov	r11,r3
8000ae84:	08 9a       	mov	r10,r4
8000ae86:	c2 4d       	rcall	8000b0ce <memmove>
8000ae88:	6e 08       	ld.w	r8,r7[0x0]
8000ae8a:	08 08       	add	r8,r4
8000ae8c:	0e 9b       	mov	r11,r7
8000ae8e:	8f 08       	st.w	r7[0x0],r8
8000ae90:	0a 9c       	mov	r12,r5
8000ae92:	fe b0 fd 09 	rcall	8000a8a4 <_fflush_r>
8000ae96:	c1 80       	breq	8000aec6 <__sfvwrite_r+0x1b2>
8000ae98:	c8 08       	rjmp	8000af98 <__sfvwrite_r+0x284>
8000ae9a:	6e 59       	ld.w	r9,r7[0x14]
8000ae9c:	12 36       	cp.w	r6,r9
8000ae9e:	c0 a3       	brcs	8000aeb2 <__sfvwrite_r+0x19e>
8000aea0:	6e a8       	ld.w	r8,r7[0x28]
8000aea2:	06 9a       	mov	r10,r3
8000aea4:	6e 8b       	ld.w	r11,r7[0x20]
8000aea6:	0a 9c       	mov	r12,r5
8000aea8:	5d 18       	icall	r8
8000aeaa:	18 94       	mov	r4,r12
8000aeac:	e0 89 00 0d 	brgt	8000aec6 <__sfvwrite_r+0x1b2>
8000aeb0:	c7 48       	rjmp	8000af98 <__sfvwrite_r+0x284>
8000aeb2:	0c 9a       	mov	r10,r6
8000aeb4:	06 9b       	mov	r11,r3
8000aeb6:	c0 cd       	rcall	8000b0ce <memmove>
8000aeb8:	6e 08       	ld.w	r8,r7[0x0]
8000aeba:	0c 08       	add	r8,r6
8000aebc:	0c 94       	mov	r4,r6
8000aebe:	8f 08       	st.w	r7[0x0],r8
8000aec0:	6e 28       	ld.w	r8,r7[0x8]
8000aec2:	0c 18       	sub	r8,r6
8000aec4:	8f 28       	st.w	r7[0x8],r8
8000aec6:	62 28       	ld.w	r8,r1[0x8]
8000aec8:	08 18       	sub	r8,r4
8000aeca:	83 28       	st.w	r1[0x8],r8
8000aecc:	c6 b0       	breq	8000afa2 <__sfvwrite_r+0x28e>
8000aece:	08 16       	sub	r6,r4
8000aed0:	08 03       	add	r3,r4
8000aed2:	c7 1b       	rjmp	8000adb4 <__sfvwrite_r+0xa0>
8000aed4:	60 03       	ld.w	r3,r0[0x0]
8000aed6:	60 11       	ld.w	r1,r0[0x4]
8000aed8:	30 08       	mov	r8,0
8000aeda:	2f 80       	sub	r0,-8
8000aedc:	50 08       	stdsp	sp[0x0],r8
8000aede:	58 01       	cp.w	r1,0
8000aee0:	cf a0       	breq	8000aed4 <__sfvwrite_r+0x1c0>
8000aee2:	40 0a       	lddsp	r10,sp[0x0]
8000aee4:	58 0a       	cp.w	r10,0
8000aee6:	c1 41       	brne	8000af0e <__sfvwrite_r+0x1fa>
8000aee8:	e2 c6 ff ff 	sub	r6,r1,-1
8000aeec:	02 9a       	mov	r10,r1
8000aeee:	30 ab       	mov	r11,10
8000aef0:	06 9c       	mov	r12,r3
8000aef2:	ce 3c       	rcall	8000b0b8 <memchr>
8000aef4:	f8 c8 ff ff 	sub	r8,r12,-1
8000aef8:	58 0c       	cp.w	r12,0
8000aefa:	f1 d3 e1 16 	subne	r6,r8,r3
8000aefe:	f9 b9 01 01 	movne	r9,1
8000af02:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000af06:	f9 b8 00 01 	moveq	r8,1
8000af0a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000af0e:	02 36       	cp.w	r6,r1
8000af10:	ec 04 17 80 	movls	r4,r6
8000af14:	e2 04 17 b0 	movhi	r4,r1
8000af18:	6e 59       	ld.w	r9,r7[0x14]
8000af1a:	6e 25       	ld.w	r5,r7[0x8]
8000af1c:	f2 05 00 05 	add	r5,r9,r5
8000af20:	0a 34       	cp.w	r4,r5
8000af22:	5f 9a       	srgt	r10
8000af24:	6e 0c       	ld.w	r12,r7[0x0]
8000af26:	6e 48       	ld.w	r8,r7[0x10]
8000af28:	10 3c       	cp.w	r12,r8
8000af2a:	5f b8       	srhi	r8
8000af2c:	f5 e8 00 08 	and	r8,r10,r8
8000af30:	30 0a       	mov	r10,0
8000af32:	f4 08 18 00 	cp.b	r8,r10
8000af36:	c0 d0       	breq	8000af50 <__sfvwrite_r+0x23c>
8000af38:	06 9b       	mov	r11,r3
8000af3a:	0a 9a       	mov	r10,r5
8000af3c:	cc 9c       	rcall	8000b0ce <memmove>
8000af3e:	6e 08       	ld.w	r8,r7[0x0]
8000af40:	0a 08       	add	r8,r5
8000af42:	0e 9b       	mov	r11,r7
8000af44:	8f 08       	st.w	r7[0x0],r8
8000af46:	40 1c       	lddsp	r12,sp[0x4]
8000af48:	fe b0 fc ae 	rcall	8000a8a4 <_fflush_r>
8000af4c:	c1 70       	breq	8000af7a <__sfvwrite_r+0x266>
8000af4e:	c2 58       	rjmp	8000af98 <__sfvwrite_r+0x284>
8000af50:	12 34       	cp.w	r4,r9
8000af52:	c0 a5       	brlt	8000af66 <__sfvwrite_r+0x252>
8000af54:	6e a8       	ld.w	r8,r7[0x28]
8000af56:	06 9a       	mov	r10,r3
8000af58:	6e 8b       	ld.w	r11,r7[0x20]
8000af5a:	40 1c       	lddsp	r12,sp[0x4]
8000af5c:	5d 18       	icall	r8
8000af5e:	18 95       	mov	r5,r12
8000af60:	e0 89 00 0d 	brgt	8000af7a <__sfvwrite_r+0x266>
8000af64:	c1 a8       	rjmp	8000af98 <__sfvwrite_r+0x284>
8000af66:	08 9a       	mov	r10,r4
8000af68:	06 9b       	mov	r11,r3
8000af6a:	cb 2c       	rcall	8000b0ce <memmove>
8000af6c:	6e 08       	ld.w	r8,r7[0x0]
8000af6e:	08 08       	add	r8,r4
8000af70:	08 95       	mov	r5,r4
8000af72:	8f 08       	st.w	r7[0x0],r8
8000af74:	6e 28       	ld.w	r8,r7[0x8]
8000af76:	08 18       	sub	r8,r4
8000af78:	8f 28       	st.w	r7[0x8],r8
8000af7a:	0a 16       	sub	r6,r5
8000af7c:	c0 71       	brne	8000af8a <__sfvwrite_r+0x276>
8000af7e:	0e 9b       	mov	r11,r7
8000af80:	40 1c       	lddsp	r12,sp[0x4]
8000af82:	fe b0 fc 91 	rcall	8000a8a4 <_fflush_r>
8000af86:	c0 91       	brne	8000af98 <__sfvwrite_r+0x284>
8000af88:	50 06       	stdsp	sp[0x0],r6
8000af8a:	64 28       	ld.w	r8,r2[0x8]
8000af8c:	0a 18       	sub	r8,r5
8000af8e:	85 28       	st.w	r2[0x8],r8
8000af90:	c0 90       	breq	8000afa2 <__sfvwrite_r+0x28e>
8000af92:	0a 11       	sub	r1,r5
8000af94:	0a 03       	add	r3,r5
8000af96:	ca 4b       	rjmp	8000aede <__sfvwrite_r+0x1ca>
8000af98:	8e 68       	ld.sh	r8,r7[0xc]
8000af9a:	a7 a8       	sbr	r8,0x6
8000af9c:	ae 68       	st.h	r7[0xc],r8
8000af9e:	3f fc       	mov	r12,-1
8000afa0:	c0 28       	rjmp	8000afa4 <__sfvwrite_r+0x290>
8000afa2:	30 0c       	mov	r12,0
8000afa4:	2f dd       	sub	sp,-12
8000afa6:	d8 32       	popm	r0-r7,pc

8000afa8 <_fwalk>:
8000afa8:	d4 31       	pushm	r0-r7,lr
8000afaa:	30 05       	mov	r5,0
8000afac:	16 91       	mov	r1,r11
8000afae:	f8 c7 ff 28 	sub	r7,r12,-216
8000afb2:	0a 92       	mov	r2,r5
8000afb4:	fe b0 fc fe 	rcall	8000a9b0 <__sfp_lock_acquire>
8000afb8:	3f f3       	mov	r3,-1
8000afba:	c1 68       	rjmp	8000afe6 <_fwalk+0x3e>
8000afbc:	6e 26       	ld.w	r6,r7[0x8]
8000afbe:	6e 14       	ld.w	r4,r7[0x4]
8000afc0:	2f 46       	sub	r6,-12
8000afc2:	c0 c8       	rjmp	8000afda <_fwalk+0x32>
8000afc4:	8c 08       	ld.sh	r8,r6[0x0]
8000afc6:	e4 08 19 00 	cp.h	r8,r2
8000afca:	c0 70       	breq	8000afd8 <_fwalk+0x30>
8000afcc:	8c 18       	ld.sh	r8,r6[0x2]
8000afce:	e6 08 19 00 	cp.h	r8,r3
8000afd2:	c0 30       	breq	8000afd8 <_fwalk+0x30>
8000afd4:	5d 11       	icall	r1
8000afd6:	18 45       	or	r5,r12
8000afd8:	2a 46       	sub	r6,-92
8000afda:	20 14       	sub	r4,1
8000afdc:	ec cc 00 0c 	sub	r12,r6,12
8000afe0:	58 04       	cp.w	r4,0
8000afe2:	cf 14       	brge	8000afc4 <_fwalk+0x1c>
8000afe4:	6e 07       	ld.w	r7,r7[0x0]
8000afe6:	58 07       	cp.w	r7,0
8000afe8:	ce a1       	brne	8000afbc <_fwalk+0x14>
8000afea:	fe b0 fc e4 	rcall	8000a9b2 <__sfp_lock_release>
8000afee:	0a 9c       	mov	r12,r5
8000aff0:	d8 32       	popm	r0-r7,pc
8000aff2:	d7 03       	nop

8000aff4 <_localeconv_r>:
8000aff4:	fe cc d5 58 	sub	r12,pc,-10920
8000aff8:	5e fc       	retal	r12
8000affa:	d7 03       	nop

8000affc <__smakebuf_r>:
8000affc:	d4 21       	pushm	r4-r7,lr
8000affe:	20 fd       	sub	sp,60
8000b000:	96 68       	ld.sh	r8,r11[0xc]
8000b002:	16 97       	mov	r7,r11
8000b004:	18 96       	mov	r6,r12
8000b006:	e2 18 00 02 	andl	r8,0x2,COH
8000b00a:	c3 d1       	brne	8000b084 <__smakebuf_r+0x88>
8000b00c:	96 7b       	ld.sh	r11,r11[0xe]
8000b00e:	f0 0b 19 00 	cp.h	r11,r8
8000b012:	c0 55       	brlt	8000b01c <__smakebuf_r+0x20>
8000b014:	1a 9a       	mov	r10,sp
8000b016:	e0 a0 04 81 	rcall	8000b918 <_fstat_r>
8000b01a:	c0 f4       	brge	8000b038 <__smakebuf_r+0x3c>
8000b01c:	8e 65       	ld.sh	r5,r7[0xc]
8000b01e:	0a 98       	mov	r8,r5
8000b020:	ab b8       	sbr	r8,0xb
8000b022:	e2 15 00 80 	andl	r5,0x80,COH
8000b026:	ae 68       	st.h	r7[0xc],r8
8000b028:	30 04       	mov	r4,0
8000b02a:	e0 68 04 00 	mov	r8,1024
8000b02e:	f9 b5 01 40 	movne	r5,64
8000b032:	f0 05 17 00 	moveq	r5,r8
8000b036:	c1 c8       	rjmp	8000b06e <__smakebuf_r+0x72>
8000b038:	40 18       	lddsp	r8,sp[0x4]
8000b03a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b03e:	e0 48 20 00 	cp.w	r8,8192
8000b042:	5f 04       	sreq	r4
8000b044:	e0 48 80 00 	cp.w	r8,32768
8000b048:	c0 e1       	brne	8000b064 <__smakebuf_r+0x68>
8000b04a:	6e b9       	ld.w	r9,r7[0x2c]
8000b04c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b050:	10 39       	cp.w	r9,r8
8000b052:	c0 91       	brne	8000b064 <__smakebuf_r+0x68>
8000b054:	8e 68       	ld.sh	r8,r7[0xc]
8000b056:	e0 65 04 00 	mov	r5,1024
8000b05a:	ab a8       	sbr	r8,0xa
8000b05c:	ef 45 00 50 	st.w	r7[80],r5
8000b060:	ae 68       	st.h	r7[0xc],r8
8000b062:	c0 68       	rjmp	8000b06e <__smakebuf_r+0x72>
8000b064:	8e 68       	ld.sh	r8,r7[0xc]
8000b066:	e0 65 04 00 	mov	r5,1024
8000b06a:	ab b8       	sbr	r8,0xb
8000b06c:	ae 68       	st.h	r7[0xc],r8
8000b06e:	0a 9b       	mov	r11,r5
8000b070:	0c 9c       	mov	r12,r6
8000b072:	fe b0 df 23 	rcall	80006eb8 <_malloc_r>
8000b076:	8e 68       	ld.sh	r8,r7[0xc]
8000b078:	c0 d1       	brne	8000b092 <__smakebuf_r+0x96>
8000b07a:	ed b8 00 09 	bld	r8,0x9
8000b07e:	c1 b0       	breq	8000b0b4 <__smakebuf_r+0xb8>
8000b080:	a1 b8       	sbr	r8,0x1
8000b082:	ae 68       	st.h	r7[0xc],r8
8000b084:	ee c8 ff b9 	sub	r8,r7,-71
8000b088:	8f 48       	st.w	r7[0x10],r8
8000b08a:	8f 08       	st.w	r7[0x0],r8
8000b08c:	30 18       	mov	r8,1
8000b08e:	8f 58       	st.w	r7[0x14],r8
8000b090:	c1 28       	rjmp	8000b0b4 <__smakebuf_r+0xb8>
8000b092:	a7 b8       	sbr	r8,0x7
8000b094:	8f 4c       	st.w	r7[0x10],r12
8000b096:	ae 68       	st.h	r7[0xc],r8
8000b098:	8f 55       	st.w	r7[0x14],r5
8000b09a:	fe c8 06 e6 	sub	r8,pc,1766
8000b09e:	8f 0c       	st.w	r7[0x0],r12
8000b0a0:	8d a8       	st.w	r6[0x28],r8
8000b0a2:	58 04       	cp.w	r4,0
8000b0a4:	c0 80       	breq	8000b0b4 <__smakebuf_r+0xb8>
8000b0a6:	8e 7c       	ld.sh	r12,r7[0xe]
8000b0a8:	fe b0 e3 94 	rcall	800077d0 <isatty>
8000b0ac:	c0 40       	breq	8000b0b4 <__smakebuf_r+0xb8>
8000b0ae:	8e 68       	ld.sh	r8,r7[0xc]
8000b0b0:	a1 a8       	sbr	r8,0x0
8000b0b2:	ae 68       	st.h	r7[0xc],r8
8000b0b4:	2f 1d       	sub	sp,-60
8000b0b6:	d8 22       	popm	r4-r7,pc

8000b0b8 <memchr>:
8000b0b8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b0bc:	c0 68       	rjmp	8000b0c8 <memchr+0x10>
8000b0be:	20 1a       	sub	r10,1
8000b0c0:	19 88       	ld.ub	r8,r12[0x0]
8000b0c2:	16 38       	cp.w	r8,r11
8000b0c4:	5e 0c       	reteq	r12
8000b0c6:	2f fc       	sub	r12,-1
8000b0c8:	58 0a       	cp.w	r10,0
8000b0ca:	cf a1       	brne	8000b0be <memchr+0x6>
8000b0cc:	5e fa       	retal	r10

8000b0ce <memmove>:
8000b0ce:	d4 01       	pushm	lr
8000b0d0:	18 3b       	cp.w	r11,r12
8000b0d2:	c1 92       	brcc	8000b104 <memmove+0x36>
8000b0d4:	f6 0a 00 09 	add	r9,r11,r10
8000b0d8:	12 3c       	cp.w	r12,r9
8000b0da:	c1 52       	brcc	8000b104 <memmove+0x36>
8000b0dc:	f8 0a 00 0b 	add	r11,r12,r10
8000b0e0:	30 08       	mov	r8,0
8000b0e2:	c0 68       	rjmp	8000b0ee <memmove+0x20>
8000b0e4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b0e8:	20 1a       	sub	r10,1
8000b0ea:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b0ee:	20 18       	sub	r8,1
8000b0f0:	58 0a       	cp.w	r10,0
8000b0f2:	cf 91       	brne	8000b0e4 <memmove+0x16>
8000b0f4:	d8 02       	popm	pc
8000b0f6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b0fa:	20 1a       	sub	r10,1
8000b0fc:	f8 08 0b 09 	st.b	r12[r8],r9
8000b100:	2f f8       	sub	r8,-1
8000b102:	c0 28       	rjmp	8000b106 <memmove+0x38>
8000b104:	30 08       	mov	r8,0
8000b106:	58 0a       	cp.w	r10,0
8000b108:	cf 71       	brne	8000b0f6 <memmove+0x28>
8000b10a:	d8 02       	popm	pc

8000b10c <__hi0bits>:
8000b10c:	18 98       	mov	r8,r12
8000b10e:	e0 1c 00 00 	andl	r12,0x0
8000b112:	f0 09 15 10 	lsl	r9,r8,0x10
8000b116:	58 0c       	cp.w	r12,0
8000b118:	f2 08 17 00 	moveq	r8,r9
8000b11c:	f9 bc 00 10 	moveq	r12,16
8000b120:	f9 bc 01 00 	movne	r12,0
8000b124:	10 9a       	mov	r10,r8
8000b126:	f0 09 15 08 	lsl	r9,r8,0x8
8000b12a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b12e:	f7 bc 00 f8 	subeq	r12,-8
8000b132:	f2 08 17 00 	moveq	r8,r9
8000b136:	10 9a       	mov	r10,r8
8000b138:	f0 09 15 04 	lsl	r9,r8,0x4
8000b13c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b140:	f7 bc 00 fc 	subeq	r12,-4
8000b144:	f2 08 17 00 	moveq	r8,r9
8000b148:	10 9a       	mov	r10,r8
8000b14a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b14e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b152:	f7 bc 00 fe 	subeq	r12,-2
8000b156:	f2 08 17 00 	moveq	r8,r9
8000b15a:	58 08       	cp.w	r8,0
8000b15c:	5e 5c       	retlt	r12
8000b15e:	ed b8 00 1e 	bld	r8,0x1e
8000b162:	f9 bc 01 20 	movne	r12,32
8000b166:	f7 bc 00 ff 	subeq	r12,-1
8000b16a:	5e fc       	retal	r12

8000b16c <__lo0bits>:
8000b16c:	18 99       	mov	r9,r12
8000b16e:	78 08       	ld.w	r8,r12[0x0]
8000b170:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b174:	c1 50       	breq	8000b19e <__lo0bits+0x32>
8000b176:	ed b8 00 00 	bld	r8,0x0
8000b17a:	c0 21       	brne	8000b17e <__lo0bits+0x12>
8000b17c:	5e fd       	retal	0
8000b17e:	10 9b       	mov	r11,r8
8000b180:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b184:	e2 1b 00 02 	andl	r11,0x2,COH
8000b188:	a3 88       	lsr	r8,0x2
8000b18a:	58 0b       	cp.w	r11,0
8000b18c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b190:	f9 bc 01 01 	movne	r12,1
8000b194:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b198:	f9 bc 00 02 	moveq	r12,2
8000b19c:	5e fc       	retal	r12
8000b19e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b1a2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b1a6:	58 0a       	cp.w	r10,0
8000b1a8:	f6 08 17 00 	moveq	r8,r11
8000b1ac:	f9 bc 00 10 	moveq	r12,16
8000b1b0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b1b4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b1b8:	58 0b       	cp.w	r11,0
8000b1ba:	f7 bc 00 f8 	subeq	r12,-8
8000b1be:	f4 08 17 00 	moveq	r8,r10
8000b1c2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b1c6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b1ca:	58 0b       	cp.w	r11,0
8000b1cc:	f7 bc 00 fc 	subeq	r12,-4
8000b1d0:	f4 08 17 00 	moveq	r8,r10
8000b1d4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b1d8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b1dc:	58 0b       	cp.w	r11,0
8000b1de:	f7 bc 00 fe 	subeq	r12,-2
8000b1e2:	f4 08 17 00 	moveq	r8,r10
8000b1e6:	ed b8 00 00 	bld	r8,0x0
8000b1ea:	c0 60       	breq	8000b1f6 <__lo0bits+0x8a>
8000b1ec:	a1 98       	lsr	r8,0x1
8000b1ee:	c0 31       	brne	8000b1f4 <__lo0bits+0x88>
8000b1f0:	32 0c       	mov	r12,32
8000b1f2:	5e fc       	retal	r12
8000b1f4:	2f fc       	sub	r12,-1
8000b1f6:	93 08       	st.w	r9[0x0],r8
8000b1f8:	5e fc       	retal	r12

8000b1fa <__mcmp>:
8000b1fa:	d4 01       	pushm	lr
8000b1fc:	18 98       	mov	r8,r12
8000b1fe:	76 49       	ld.w	r9,r11[0x10]
8000b200:	78 4c       	ld.w	r12,r12[0x10]
8000b202:	12 1c       	sub	r12,r9
8000b204:	c1 31       	brne	8000b22a <__mcmp+0x30>
8000b206:	2f b9       	sub	r9,-5
8000b208:	a3 69       	lsl	r9,0x2
8000b20a:	12 0b       	add	r11,r9
8000b20c:	f0 09 00 09 	add	r9,r8,r9
8000b210:	2e c8       	sub	r8,-20
8000b212:	13 4e       	ld.w	lr,--r9
8000b214:	17 4a       	ld.w	r10,--r11
8000b216:	14 3e       	cp.w	lr,r10
8000b218:	c0 60       	breq	8000b224 <__mcmp+0x2a>
8000b21a:	f9 bc 03 ff 	movlo	r12,-1
8000b21e:	f9 bc 02 01 	movhs	r12,1
8000b222:	d8 02       	popm	pc
8000b224:	10 39       	cp.w	r9,r8
8000b226:	fe 9b ff f6 	brhi	8000b212 <__mcmp+0x18>
8000b22a:	d8 02       	popm	pc

8000b22c <_Bfree>:
8000b22c:	d4 21       	pushm	r4-r7,lr
8000b22e:	18 97       	mov	r7,r12
8000b230:	16 95       	mov	r5,r11
8000b232:	78 96       	ld.w	r6,r12[0x24]
8000b234:	58 06       	cp.w	r6,0
8000b236:	c0 91       	brne	8000b248 <_Bfree+0x1c>
8000b238:	31 0c       	mov	r12,16
8000b23a:	fe b0 de 37 	rcall	80006ea8 <malloc>
8000b23e:	99 36       	st.w	r12[0xc],r6
8000b240:	8f 9c       	st.w	r7[0x24],r12
8000b242:	99 16       	st.w	r12[0x4],r6
8000b244:	99 26       	st.w	r12[0x8],r6
8000b246:	99 06       	st.w	r12[0x0],r6
8000b248:	58 05       	cp.w	r5,0
8000b24a:	c0 90       	breq	8000b25c <_Bfree+0x30>
8000b24c:	6a 19       	ld.w	r9,r5[0x4]
8000b24e:	6e 98       	ld.w	r8,r7[0x24]
8000b250:	70 38       	ld.w	r8,r8[0xc]
8000b252:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b256:	8b 0a       	st.w	r5[0x0],r10
8000b258:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b25c:	d8 22       	popm	r4-r7,pc
8000b25e:	d7 03       	nop

8000b260 <_Balloc>:
8000b260:	d4 21       	pushm	r4-r7,lr
8000b262:	18 97       	mov	r7,r12
8000b264:	16 96       	mov	r6,r11
8000b266:	78 95       	ld.w	r5,r12[0x24]
8000b268:	58 05       	cp.w	r5,0
8000b26a:	c0 91       	brne	8000b27c <_Balloc+0x1c>
8000b26c:	31 0c       	mov	r12,16
8000b26e:	fe b0 de 1d 	rcall	80006ea8 <malloc>
8000b272:	99 35       	st.w	r12[0xc],r5
8000b274:	8f 9c       	st.w	r7[0x24],r12
8000b276:	99 15       	st.w	r12[0x4],r5
8000b278:	99 25       	st.w	r12[0x8],r5
8000b27a:	99 05       	st.w	r12[0x0],r5
8000b27c:	6e 95       	ld.w	r5,r7[0x24]
8000b27e:	6a 38       	ld.w	r8,r5[0xc]
8000b280:	58 08       	cp.w	r8,0
8000b282:	c0 b1       	brne	8000b298 <_Balloc+0x38>
8000b284:	31 0a       	mov	r10,16
8000b286:	30 4b       	mov	r11,4
8000b288:	0e 9c       	mov	r12,r7
8000b28a:	e0 a0 02 a7 	rcall	8000b7d8 <_calloc_r>
8000b28e:	8b 3c       	st.w	r5[0xc],r12
8000b290:	6e 98       	ld.w	r8,r7[0x24]
8000b292:	70 3c       	ld.w	r12,r8[0xc]
8000b294:	58 0c       	cp.w	r12,0
8000b296:	c1 b0       	breq	8000b2cc <_Balloc+0x6c>
8000b298:	6e 98       	ld.w	r8,r7[0x24]
8000b29a:	70 38       	ld.w	r8,r8[0xc]
8000b29c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b2a0:	70 0c       	ld.w	r12,r8[0x0]
8000b2a2:	58 0c       	cp.w	r12,0
8000b2a4:	c0 40       	breq	8000b2ac <_Balloc+0x4c>
8000b2a6:	78 09       	ld.w	r9,r12[0x0]
8000b2a8:	91 09       	st.w	r8[0x0],r9
8000b2aa:	c0 e8       	rjmp	8000b2c6 <_Balloc+0x66>
8000b2ac:	0e 9c       	mov	r12,r7
8000b2ae:	30 17       	mov	r7,1
8000b2b0:	0e 9b       	mov	r11,r7
8000b2b2:	ee 06 09 47 	lsl	r7,r7,r6
8000b2b6:	ee ca ff fb 	sub	r10,r7,-5
8000b2ba:	a3 6a       	lsl	r10,0x2
8000b2bc:	e0 a0 02 8e 	rcall	8000b7d8 <_calloc_r>
8000b2c0:	c0 60       	breq	8000b2cc <_Balloc+0x6c>
8000b2c2:	99 16       	st.w	r12[0x4],r6
8000b2c4:	99 27       	st.w	r12[0x8],r7
8000b2c6:	30 08       	mov	r8,0
8000b2c8:	99 38       	st.w	r12[0xc],r8
8000b2ca:	99 48       	st.w	r12[0x10],r8
8000b2cc:	d8 22       	popm	r4-r7,pc
8000b2ce:	d7 03       	nop

8000b2d0 <__d2b>:
8000b2d0:	d4 31       	pushm	r0-r7,lr
8000b2d2:	20 2d       	sub	sp,8
8000b2d4:	16 93       	mov	r3,r11
8000b2d6:	12 96       	mov	r6,r9
8000b2d8:	10 95       	mov	r5,r8
8000b2da:	14 92       	mov	r2,r10
8000b2dc:	30 1b       	mov	r11,1
8000b2de:	cc 1f       	rcall	8000b260 <_Balloc>
8000b2e0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b2e4:	50 09       	stdsp	sp[0x0],r9
8000b2e6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b2ea:	b5 a9       	sbr	r9,0x14
8000b2ec:	f0 01 16 14 	lsr	r1,r8,0x14
8000b2f0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b2f4:	18 94       	mov	r4,r12
8000b2f6:	58 02       	cp.w	r2,0
8000b2f8:	c1 d0       	breq	8000b332 <__d2b+0x62>
8000b2fa:	fa cc ff f8 	sub	r12,sp,-8
8000b2fe:	18 d2       	st.w	--r12,r2
8000b300:	c3 6f       	rcall	8000b16c <__lo0bits>
8000b302:	40 18       	lddsp	r8,sp[0x4]
8000b304:	c0 d0       	breq	8000b31e <__d2b+0x4e>
8000b306:	40 09       	lddsp	r9,sp[0x0]
8000b308:	f8 0a 11 20 	rsub	r10,r12,32
8000b30c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b310:	f5 e8 10 08 	or	r8,r10,r8
8000b314:	89 58       	st.w	r4[0x14],r8
8000b316:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b31a:	50 09       	stdsp	sp[0x0],r9
8000b31c:	c0 28       	rjmp	8000b320 <__d2b+0x50>
8000b31e:	89 58       	st.w	r4[0x14],r8
8000b320:	40 08       	lddsp	r8,sp[0x0]
8000b322:	58 08       	cp.w	r8,0
8000b324:	f9 b3 01 02 	movne	r3,2
8000b328:	f9 b3 00 01 	moveq	r3,1
8000b32c:	89 68       	st.w	r4[0x18],r8
8000b32e:	89 43       	st.w	r4[0x10],r3
8000b330:	c0 88       	rjmp	8000b340 <__d2b+0x70>
8000b332:	1a 9c       	mov	r12,sp
8000b334:	c1 cf       	rcall	8000b16c <__lo0bits>
8000b336:	30 13       	mov	r3,1
8000b338:	40 08       	lddsp	r8,sp[0x0]
8000b33a:	2e 0c       	sub	r12,-32
8000b33c:	89 43       	st.w	r4[0x10],r3
8000b33e:	89 58       	st.w	r4[0x14],r8
8000b340:	58 01       	cp.w	r1,0
8000b342:	c0 90       	breq	8000b354 <__d2b+0x84>
8000b344:	e2 c1 04 33 	sub	r1,r1,1075
8000b348:	18 01       	add	r1,r12
8000b34a:	8d 01       	st.w	r6[0x0],r1
8000b34c:	f8 0c 11 35 	rsub	r12,r12,53
8000b350:	8b 0c       	st.w	r5[0x0],r12
8000b352:	c0 c8       	rjmp	8000b36a <__d2b+0x9a>
8000b354:	e6 c8 ff fc 	sub	r8,r3,-4
8000b358:	f8 cc 04 32 	sub	r12,r12,1074
8000b35c:	a5 73       	lsl	r3,0x5
8000b35e:	8d 0c       	st.w	r6[0x0],r12
8000b360:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b364:	cd 4e       	rcall	8000b10c <__hi0bits>
8000b366:	18 13       	sub	r3,r12
8000b368:	8b 03       	st.w	r5[0x0],r3
8000b36a:	08 9c       	mov	r12,r4
8000b36c:	2f ed       	sub	sp,-8
8000b36e:	d8 32       	popm	r0-r7,pc

8000b370 <__mdiff>:
8000b370:	d4 31       	pushm	r0-r7,lr
8000b372:	74 48       	ld.w	r8,r10[0x10]
8000b374:	76 45       	ld.w	r5,r11[0x10]
8000b376:	16 97       	mov	r7,r11
8000b378:	14 96       	mov	r6,r10
8000b37a:	10 15       	sub	r5,r8
8000b37c:	c1 31       	brne	8000b3a2 <__mdiff+0x32>
8000b37e:	2f b8       	sub	r8,-5
8000b380:	ee ce ff ec 	sub	lr,r7,-20
8000b384:	a3 68       	lsl	r8,0x2
8000b386:	f4 08 00 0b 	add	r11,r10,r8
8000b38a:	ee 08 00 08 	add	r8,r7,r8
8000b38e:	11 4a       	ld.w	r10,--r8
8000b390:	17 49       	ld.w	r9,--r11
8000b392:	12 3a       	cp.w	r10,r9
8000b394:	c0 30       	breq	8000b39a <__mdiff+0x2a>
8000b396:	c0 e2       	brcc	8000b3b2 <__mdiff+0x42>
8000b398:	c0 78       	rjmp	8000b3a6 <__mdiff+0x36>
8000b39a:	1c 38       	cp.w	r8,lr
8000b39c:	fe 9b ff f9 	brhi	8000b38e <__mdiff+0x1e>
8000b3a0:	c4 98       	rjmp	8000b432 <__mdiff+0xc2>
8000b3a2:	58 05       	cp.w	r5,0
8000b3a4:	c0 64       	brge	8000b3b0 <__mdiff+0x40>
8000b3a6:	0e 98       	mov	r8,r7
8000b3a8:	30 15       	mov	r5,1
8000b3aa:	0c 97       	mov	r7,r6
8000b3ac:	10 96       	mov	r6,r8
8000b3ae:	c0 28       	rjmp	8000b3b2 <__mdiff+0x42>
8000b3b0:	30 05       	mov	r5,0
8000b3b2:	6e 1b       	ld.w	r11,r7[0x4]
8000b3b4:	c5 6f       	rcall	8000b260 <_Balloc>
8000b3b6:	6e 49       	ld.w	r9,r7[0x10]
8000b3b8:	6c 44       	ld.w	r4,r6[0x10]
8000b3ba:	99 35       	st.w	r12[0xc],r5
8000b3bc:	2f b4       	sub	r4,-5
8000b3be:	f2 c5 ff fb 	sub	r5,r9,-5
8000b3c2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b3c6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b3ca:	2e c6       	sub	r6,-20
8000b3cc:	2e c7       	sub	r7,-20
8000b3ce:	f8 c8 ff ec 	sub	r8,r12,-20
8000b3d2:	30 0a       	mov	r10,0
8000b3d4:	0f 0e       	ld.w	lr,r7++
8000b3d6:	0d 0b       	ld.w	r11,r6++
8000b3d8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b3dc:	f6 03 16 10 	lsr	r3,r11,0x10
8000b3e0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b3e4:	e4 03 01 03 	sub	r3,r2,r3
8000b3e8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b3ec:	fc 0b 01 0b 	sub	r11,lr,r11
8000b3f0:	f6 0a 00 0a 	add	r10,r11,r10
8000b3f4:	b0 1a       	st.h	r8[0x2],r10
8000b3f6:	b1 4a       	asr	r10,0x10
8000b3f8:	e6 0a 00 0a 	add	r10,r3,r10
8000b3fc:	b0 0a       	st.h	r8[0x0],r10
8000b3fe:	2f c8       	sub	r8,-4
8000b400:	b1 4a       	asr	r10,0x10
8000b402:	08 36       	cp.w	r6,r4
8000b404:	ce 83       	brcs	8000b3d4 <__mdiff+0x64>
8000b406:	c0 d8       	rjmp	8000b420 <__mdiff+0xb0>
8000b408:	0f 0b       	ld.w	r11,r7++
8000b40a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b40e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b412:	16 0a       	add	r10,r11
8000b414:	b0 1a       	st.h	r8[0x2],r10
8000b416:	b1 4a       	asr	r10,0x10
8000b418:	1c 0a       	add	r10,lr
8000b41a:	b0 0a       	st.h	r8[0x0],r10
8000b41c:	2f c8       	sub	r8,-4
8000b41e:	b1 4a       	asr	r10,0x10
8000b420:	0a 37       	cp.w	r7,r5
8000b422:	cf 33       	brcs	8000b408 <__mdiff+0x98>
8000b424:	c0 28       	rjmp	8000b428 <__mdiff+0xb8>
8000b426:	20 19       	sub	r9,1
8000b428:	11 4a       	ld.w	r10,--r8
8000b42a:	58 0a       	cp.w	r10,0
8000b42c:	cf d0       	breq	8000b426 <__mdiff+0xb6>
8000b42e:	99 49       	st.w	r12[0x10],r9
8000b430:	d8 32       	popm	r0-r7,pc
8000b432:	30 0b       	mov	r11,0
8000b434:	c1 6f       	rcall	8000b260 <_Balloc>
8000b436:	30 18       	mov	r8,1
8000b438:	99 48       	st.w	r12[0x10],r8
8000b43a:	30 08       	mov	r8,0
8000b43c:	99 58       	st.w	r12[0x14],r8
8000b43e:	d8 32       	popm	r0-r7,pc

8000b440 <__lshift>:
8000b440:	d4 31       	pushm	r0-r7,lr
8000b442:	16 97       	mov	r7,r11
8000b444:	76 46       	ld.w	r6,r11[0x10]
8000b446:	f4 02 14 05 	asr	r2,r10,0x5
8000b44a:	2f f6       	sub	r6,-1
8000b44c:	14 93       	mov	r3,r10
8000b44e:	18 94       	mov	r4,r12
8000b450:	04 06       	add	r6,r2
8000b452:	76 1b       	ld.w	r11,r11[0x4]
8000b454:	6e 28       	ld.w	r8,r7[0x8]
8000b456:	c0 38       	rjmp	8000b45c <__lshift+0x1c>
8000b458:	2f fb       	sub	r11,-1
8000b45a:	a1 78       	lsl	r8,0x1
8000b45c:	10 36       	cp.w	r6,r8
8000b45e:	fe 99 ff fd 	brgt	8000b458 <__lshift+0x18>
8000b462:	08 9c       	mov	r12,r4
8000b464:	cf ee       	rcall	8000b260 <_Balloc>
8000b466:	30 09       	mov	r9,0
8000b468:	18 95       	mov	r5,r12
8000b46a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b46e:	12 9a       	mov	r10,r9
8000b470:	c0 38       	rjmp	8000b476 <__lshift+0x36>
8000b472:	10 aa       	st.w	r8++,r10
8000b474:	2f f9       	sub	r9,-1
8000b476:	04 39       	cp.w	r9,r2
8000b478:	cf d5       	brlt	8000b472 <__lshift+0x32>
8000b47a:	6e 4b       	ld.w	r11,r7[0x10]
8000b47c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b480:	2f bb       	sub	r11,-5
8000b482:	ee c9 ff ec 	sub	r9,r7,-20
8000b486:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b48a:	58 03       	cp.w	r3,0
8000b48c:	c1 30       	breq	8000b4b2 <__lshift+0x72>
8000b48e:	e6 0c 11 20 	rsub	r12,r3,32
8000b492:	30 0a       	mov	r10,0
8000b494:	72 02       	ld.w	r2,r9[0x0]
8000b496:	e4 03 09 42 	lsl	r2,r2,r3
8000b49a:	04 4a       	or	r10,r2
8000b49c:	10 aa       	st.w	r8++,r10
8000b49e:	13 0a       	ld.w	r10,r9++
8000b4a0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b4a4:	16 39       	cp.w	r9,r11
8000b4a6:	cf 73       	brcs	8000b494 <__lshift+0x54>
8000b4a8:	91 0a       	st.w	r8[0x0],r10
8000b4aa:	58 0a       	cp.w	r10,0
8000b4ac:	c0 70       	breq	8000b4ba <__lshift+0x7a>
8000b4ae:	2f f6       	sub	r6,-1
8000b4b0:	c0 58       	rjmp	8000b4ba <__lshift+0x7a>
8000b4b2:	13 0a       	ld.w	r10,r9++
8000b4b4:	10 aa       	st.w	r8++,r10
8000b4b6:	16 39       	cp.w	r9,r11
8000b4b8:	cf d3       	brcs	8000b4b2 <__lshift+0x72>
8000b4ba:	08 9c       	mov	r12,r4
8000b4bc:	20 16       	sub	r6,1
8000b4be:	0e 9b       	mov	r11,r7
8000b4c0:	8b 46       	st.w	r5[0x10],r6
8000b4c2:	cb 5e       	rcall	8000b22c <_Bfree>
8000b4c4:	0a 9c       	mov	r12,r5
8000b4c6:	d8 32       	popm	r0-r7,pc

8000b4c8 <__multiply>:
8000b4c8:	d4 31       	pushm	r0-r7,lr
8000b4ca:	20 2d       	sub	sp,8
8000b4cc:	76 49       	ld.w	r9,r11[0x10]
8000b4ce:	74 48       	ld.w	r8,r10[0x10]
8000b4d0:	16 96       	mov	r6,r11
8000b4d2:	14 95       	mov	r5,r10
8000b4d4:	10 39       	cp.w	r9,r8
8000b4d6:	ec 08 17 50 	movlt	r8,r6
8000b4da:	ea 06 17 50 	movlt	r6,r5
8000b4de:	f0 05 17 50 	movlt	r5,r8
8000b4e2:	6c 28       	ld.w	r8,r6[0x8]
8000b4e4:	76 43       	ld.w	r3,r11[0x10]
8000b4e6:	74 42       	ld.w	r2,r10[0x10]
8000b4e8:	76 1b       	ld.w	r11,r11[0x4]
8000b4ea:	e4 03 00 07 	add	r7,r2,r3
8000b4ee:	10 37       	cp.w	r7,r8
8000b4f0:	f7 bb 09 ff 	subgt	r11,-1
8000b4f4:	cb 6e       	rcall	8000b260 <_Balloc>
8000b4f6:	ee c4 ff fb 	sub	r4,r7,-5
8000b4fa:	f8 c9 ff ec 	sub	r9,r12,-20
8000b4fe:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b502:	30 0a       	mov	r10,0
8000b504:	12 98       	mov	r8,r9
8000b506:	c0 28       	rjmp	8000b50a <__multiply+0x42>
8000b508:	10 aa       	st.w	r8++,r10
8000b50a:	08 38       	cp.w	r8,r4
8000b50c:	cf e3       	brcs	8000b508 <__multiply+0x40>
8000b50e:	2f b3       	sub	r3,-5
8000b510:	2f b2       	sub	r2,-5
8000b512:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b516:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b51a:	ec cb ff ec 	sub	r11,r6,-20
8000b51e:	50 12       	stdsp	sp[0x4],r2
8000b520:	ea ca ff ec 	sub	r10,r5,-20
8000b524:	c4 48       	rjmp	8000b5ac <__multiply+0xe4>
8000b526:	94 95       	ld.uh	r5,r10[0x2]
8000b528:	58 05       	cp.w	r5,0
8000b52a:	c2 00       	breq	8000b56a <__multiply+0xa2>
8000b52c:	12 98       	mov	r8,r9
8000b52e:	16 96       	mov	r6,r11
8000b530:	30 0e       	mov	lr,0
8000b532:	50 09       	stdsp	sp[0x0],r9
8000b534:	0d 02       	ld.w	r2,r6++
8000b536:	e4 00 16 10 	lsr	r0,r2,0x10
8000b53a:	70 01       	ld.w	r1,r8[0x0]
8000b53c:	70 09       	ld.w	r9,r8[0x0]
8000b53e:	b1 81       	lsr	r1,0x10
8000b540:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b544:	e0 05 03 41 	mac	r1,r0,r5
8000b548:	ab 32       	mul	r2,r5
8000b54a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b54e:	00 02       	add	r2,r0
8000b550:	e4 0e 00 0e 	add	lr,r2,lr
8000b554:	b0 1e       	st.h	r8[0x2],lr
8000b556:	b1 8e       	lsr	lr,0x10
8000b558:	1c 01       	add	r1,lr
8000b55a:	b0 01       	st.h	r8[0x0],r1
8000b55c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b560:	2f c8       	sub	r8,-4
8000b562:	06 36       	cp.w	r6,r3
8000b564:	ce 83       	brcs	8000b534 <__multiply+0x6c>
8000b566:	40 09       	lddsp	r9,sp[0x0]
8000b568:	91 0e       	st.w	r8[0x0],lr
8000b56a:	94 86       	ld.uh	r6,r10[0x0]
8000b56c:	58 06       	cp.w	r6,0
8000b56e:	c1 d0       	breq	8000b5a8 <__multiply+0xe0>
8000b570:	72 02       	ld.w	r2,r9[0x0]
8000b572:	12 98       	mov	r8,r9
8000b574:	16 9e       	mov	lr,r11
8000b576:	30 05       	mov	r5,0
8000b578:	b0 12       	st.h	r8[0x2],r2
8000b57a:	1d 01       	ld.w	r1,lr++
8000b57c:	90 82       	ld.uh	r2,r8[0x0]
8000b57e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b582:	ad 30       	mul	r0,r6
8000b584:	e0 02 00 02 	add	r2,r0,r2
8000b588:	e4 05 00 05 	add	r5,r2,r5
8000b58c:	b0 05       	st.h	r8[0x0],r5
8000b58e:	b1 85       	lsr	r5,0x10
8000b590:	b1 81       	lsr	r1,0x10
8000b592:	2f c8       	sub	r8,-4
8000b594:	ad 31       	mul	r1,r6
8000b596:	90 92       	ld.uh	r2,r8[0x2]
8000b598:	e2 02 00 02 	add	r2,r1,r2
8000b59c:	0a 02       	add	r2,r5
8000b59e:	e4 05 16 10 	lsr	r5,r2,0x10
8000b5a2:	06 3e       	cp.w	lr,r3
8000b5a4:	ce a3       	brcs	8000b578 <__multiply+0xb0>
8000b5a6:	91 02       	st.w	r8[0x0],r2
8000b5a8:	2f ca       	sub	r10,-4
8000b5aa:	2f c9       	sub	r9,-4
8000b5ac:	40 18       	lddsp	r8,sp[0x4]
8000b5ae:	10 3a       	cp.w	r10,r8
8000b5b0:	cb b3       	brcs	8000b526 <__multiply+0x5e>
8000b5b2:	c0 28       	rjmp	8000b5b6 <__multiply+0xee>
8000b5b4:	20 17       	sub	r7,1
8000b5b6:	58 07       	cp.w	r7,0
8000b5b8:	e0 8a 00 05 	brle	8000b5c2 <__multiply+0xfa>
8000b5bc:	09 48       	ld.w	r8,--r4
8000b5be:	58 08       	cp.w	r8,0
8000b5c0:	cf a0       	breq	8000b5b4 <__multiply+0xec>
8000b5c2:	99 47       	st.w	r12[0x10],r7
8000b5c4:	2f ed       	sub	sp,-8
8000b5c6:	d8 32       	popm	r0-r7,pc

8000b5c8 <__i2b>:
8000b5c8:	d4 21       	pushm	r4-r7,lr
8000b5ca:	16 97       	mov	r7,r11
8000b5cc:	30 1b       	mov	r11,1
8000b5ce:	c4 9e       	rcall	8000b260 <_Balloc>
8000b5d0:	30 19       	mov	r9,1
8000b5d2:	99 57       	st.w	r12[0x14],r7
8000b5d4:	99 49       	st.w	r12[0x10],r9
8000b5d6:	d8 22       	popm	r4-r7,pc

8000b5d8 <__multadd>:
8000b5d8:	d4 31       	pushm	r0-r7,lr
8000b5da:	30 08       	mov	r8,0
8000b5dc:	12 95       	mov	r5,r9
8000b5de:	16 97       	mov	r7,r11
8000b5e0:	18 96       	mov	r6,r12
8000b5e2:	76 44       	ld.w	r4,r11[0x10]
8000b5e4:	f6 c9 ff ec 	sub	r9,r11,-20
8000b5e8:	72 0b       	ld.w	r11,r9[0x0]
8000b5ea:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b5ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b5f2:	f4 0c 02 4c 	mul	r12,r10,r12
8000b5f6:	f4 0b 03 45 	mac	r5,r10,r11
8000b5fa:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b5fe:	b1 85       	lsr	r5,0x10
8000b600:	18 05       	add	r5,r12
8000b602:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b606:	f8 0b 00 0b 	add	r11,r12,r11
8000b60a:	12 ab       	st.w	r9++,r11
8000b60c:	2f f8       	sub	r8,-1
8000b60e:	b1 85       	lsr	r5,0x10
8000b610:	08 38       	cp.w	r8,r4
8000b612:	ce b5       	brlt	8000b5e8 <__multadd+0x10>
8000b614:	58 05       	cp.w	r5,0
8000b616:	c1 c0       	breq	8000b64e <__multadd+0x76>
8000b618:	6e 28       	ld.w	r8,r7[0x8]
8000b61a:	10 34       	cp.w	r4,r8
8000b61c:	c1 35       	brlt	8000b642 <__multadd+0x6a>
8000b61e:	6e 1b       	ld.w	r11,r7[0x4]
8000b620:	0c 9c       	mov	r12,r6
8000b622:	2f fb       	sub	r11,-1
8000b624:	c1 ee       	rcall	8000b260 <_Balloc>
8000b626:	6e 4a       	ld.w	r10,r7[0x10]
8000b628:	ee cb ff f4 	sub	r11,r7,-12
8000b62c:	18 93       	mov	r3,r12
8000b62e:	2f ea       	sub	r10,-2
8000b630:	2f 4c       	sub	r12,-12
8000b632:	a3 6a       	lsl	r10,0x2
8000b634:	fe b0 de 71 	rcall	80007316 <memcpy>
8000b638:	0e 9b       	mov	r11,r7
8000b63a:	0c 9c       	mov	r12,r6
8000b63c:	fe b0 fd f8 	rcall	8000b22c <_Bfree>
8000b640:	06 97       	mov	r7,r3
8000b642:	e8 c8 ff ff 	sub	r8,r4,-1
8000b646:	2f b4       	sub	r4,-5
8000b648:	8f 48       	st.w	r7[0x10],r8
8000b64a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b64e:	0e 9c       	mov	r12,r7
8000b650:	d8 32       	popm	r0-r7,pc
8000b652:	d7 03       	nop

8000b654 <__pow5mult>:
8000b654:	d4 31       	pushm	r0-r7,lr
8000b656:	14 96       	mov	r6,r10
8000b658:	18 97       	mov	r7,r12
8000b65a:	16 94       	mov	r4,r11
8000b65c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b660:	c0 90       	breq	8000b672 <__pow5mult+0x1e>
8000b662:	20 18       	sub	r8,1
8000b664:	fe c9 db 8c 	sub	r9,pc,-9332
8000b668:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b66c:	30 09       	mov	r9,0
8000b66e:	cb 5f       	rcall	8000b5d8 <__multadd>
8000b670:	18 94       	mov	r4,r12
8000b672:	a3 46       	asr	r6,0x2
8000b674:	c3 40       	breq	8000b6dc <__pow5mult+0x88>
8000b676:	6e 95       	ld.w	r5,r7[0x24]
8000b678:	58 05       	cp.w	r5,0
8000b67a:	c0 91       	brne	8000b68c <__pow5mult+0x38>
8000b67c:	31 0c       	mov	r12,16
8000b67e:	fe b0 dc 15 	rcall	80006ea8 <malloc>
8000b682:	99 35       	st.w	r12[0xc],r5
8000b684:	8f 9c       	st.w	r7[0x24],r12
8000b686:	99 15       	st.w	r12[0x4],r5
8000b688:	99 25       	st.w	r12[0x8],r5
8000b68a:	99 05       	st.w	r12[0x0],r5
8000b68c:	6e 93       	ld.w	r3,r7[0x24]
8000b68e:	66 25       	ld.w	r5,r3[0x8]
8000b690:	58 05       	cp.w	r5,0
8000b692:	c0 c1       	brne	8000b6aa <__pow5mult+0x56>
8000b694:	e0 6b 02 71 	mov	r11,625
8000b698:	0e 9c       	mov	r12,r7
8000b69a:	c9 7f       	rcall	8000b5c8 <__i2b>
8000b69c:	87 2c       	st.w	r3[0x8],r12
8000b69e:	30 08       	mov	r8,0
8000b6a0:	18 95       	mov	r5,r12
8000b6a2:	99 08       	st.w	r12[0x0],r8
8000b6a4:	c0 38       	rjmp	8000b6aa <__pow5mult+0x56>
8000b6a6:	06 9c       	mov	r12,r3
8000b6a8:	18 95       	mov	r5,r12
8000b6aa:	ed b6 00 00 	bld	r6,0x0
8000b6ae:	c0 b1       	brne	8000b6c4 <__pow5mult+0x70>
8000b6b0:	08 9b       	mov	r11,r4
8000b6b2:	0a 9a       	mov	r10,r5
8000b6b4:	0e 9c       	mov	r12,r7
8000b6b6:	c0 9f       	rcall	8000b4c8 <__multiply>
8000b6b8:	08 9b       	mov	r11,r4
8000b6ba:	18 93       	mov	r3,r12
8000b6bc:	0e 9c       	mov	r12,r7
8000b6be:	06 94       	mov	r4,r3
8000b6c0:	fe b0 fd b6 	rcall	8000b22c <_Bfree>
8000b6c4:	a1 56       	asr	r6,0x1
8000b6c6:	c0 b0       	breq	8000b6dc <__pow5mult+0x88>
8000b6c8:	6a 03       	ld.w	r3,r5[0x0]
8000b6ca:	58 03       	cp.w	r3,0
8000b6cc:	ce d1       	brne	8000b6a6 <__pow5mult+0x52>
8000b6ce:	0a 9a       	mov	r10,r5
8000b6d0:	0a 9b       	mov	r11,r5
8000b6d2:	0e 9c       	mov	r12,r7
8000b6d4:	cf ae       	rcall	8000b4c8 <__multiply>
8000b6d6:	8b 0c       	st.w	r5[0x0],r12
8000b6d8:	99 03       	st.w	r12[0x0],r3
8000b6da:	ce 7b       	rjmp	8000b6a8 <__pow5mult+0x54>
8000b6dc:	08 9c       	mov	r12,r4
8000b6de:	d8 32       	popm	r0-r7,pc

8000b6e0 <__isinfd>:
8000b6e0:	14 98       	mov	r8,r10
8000b6e2:	fc 19 7f f0 	movh	r9,0x7ff0
8000b6e6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b6ea:	f0 0b 11 00 	rsub	r11,r8,0
8000b6ee:	f7 e8 10 08 	or	r8,r11,r8
8000b6f2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b6f6:	f2 08 01 08 	sub	r8,r9,r8
8000b6fa:	f0 0c 11 00 	rsub	r12,r8,0
8000b6fe:	f9 e8 10 08 	or	r8,r12,r8
8000b702:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b706:	2f fc       	sub	r12,-1
8000b708:	5e fc       	retal	r12

8000b70a <__isnand>:
8000b70a:	14 98       	mov	r8,r10
8000b70c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b710:	f0 0c 11 00 	rsub	r12,r8,0
8000b714:	10 4c       	or	r12,r8
8000b716:	fc 18 7f f0 	movh	r8,0x7ff0
8000b71a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b71e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b722:	bf 9c       	lsr	r12,0x1f
8000b724:	5e fc       	retal	r12
8000b726:	d7 03       	nop

8000b728 <__sclose>:
8000b728:	d4 01       	pushm	lr
8000b72a:	96 7b       	ld.sh	r11,r11[0xe]
8000b72c:	c8 2c       	rcall	8000b830 <_close_r>
8000b72e:	d8 02       	popm	pc

8000b730 <__sseek>:
8000b730:	d4 21       	pushm	r4-r7,lr
8000b732:	16 97       	mov	r7,r11
8000b734:	96 7b       	ld.sh	r11,r11[0xe]
8000b736:	c0 3d       	rcall	8000b93c <_lseek_r>
8000b738:	8e 68       	ld.sh	r8,r7[0xc]
8000b73a:	10 99       	mov	r9,r8
8000b73c:	ad c8       	cbr	r8,0xc
8000b73e:	ad a9       	sbr	r9,0xc
8000b740:	5b fc       	cp.w	r12,-1
8000b742:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b746:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b74a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b74e:	d8 22       	popm	r4-r7,pc

8000b750 <__swrite>:
8000b750:	d4 21       	pushm	r4-r7,lr
8000b752:	96 68       	ld.sh	r8,r11[0xc]
8000b754:	16 97       	mov	r7,r11
8000b756:	14 95       	mov	r5,r10
8000b758:	12 94       	mov	r4,r9
8000b75a:	e2 18 01 00 	andl	r8,0x100,COH
8000b75e:	18 96       	mov	r6,r12
8000b760:	c0 50       	breq	8000b76a <__swrite+0x1a>
8000b762:	30 29       	mov	r9,2
8000b764:	30 0a       	mov	r10,0
8000b766:	96 7b       	ld.sh	r11,r11[0xe]
8000b768:	ce ac       	rcall	8000b93c <_lseek_r>
8000b76a:	8e 68       	ld.sh	r8,r7[0xc]
8000b76c:	ad c8       	cbr	r8,0xc
8000b76e:	08 99       	mov	r9,r4
8000b770:	0a 9a       	mov	r10,r5
8000b772:	8e 7b       	ld.sh	r11,r7[0xe]
8000b774:	0c 9c       	mov	r12,r6
8000b776:	ae 68       	st.h	r7[0xc],r8
8000b778:	c1 cc       	rcall	8000b7b0 <_write_r>
8000b77a:	d8 22       	popm	r4-r7,pc

8000b77c <__sread>:
8000b77c:	d4 21       	pushm	r4-r7,lr
8000b77e:	16 97       	mov	r7,r11
8000b780:	96 7b       	ld.sh	r11,r11[0xe]
8000b782:	cf 1c       	rcall	8000b964 <_read_r>
8000b784:	c0 65       	brlt	8000b790 <__sread+0x14>
8000b786:	6f 58       	ld.w	r8,r7[0x54]
8000b788:	18 08       	add	r8,r12
8000b78a:	ef 48 00 54 	st.w	r7[84],r8
8000b78e:	d8 22       	popm	r4-r7,pc
8000b790:	8e 68       	ld.sh	r8,r7[0xc]
8000b792:	ad c8       	cbr	r8,0xc
8000b794:	ae 68       	st.h	r7[0xc],r8
8000b796:	d8 22       	popm	r4-r7,pc

8000b798 <strlen>:
8000b798:	30 09       	mov	r9,0
8000b79a:	18 98       	mov	r8,r12
8000b79c:	c0 28       	rjmp	8000b7a0 <strlen+0x8>
8000b79e:	2f f8       	sub	r8,-1
8000b7a0:	11 8a       	ld.ub	r10,r8[0x0]
8000b7a2:	f2 0a 18 00 	cp.b	r10,r9
8000b7a6:	cf c1       	brne	8000b79e <strlen+0x6>
8000b7a8:	f0 0c 01 0c 	sub	r12,r8,r12
8000b7ac:	5e fc       	retal	r12
8000b7ae:	d7 03       	nop

8000b7b0 <_write_r>:
8000b7b0:	d4 21       	pushm	r4-r7,lr
8000b7b2:	16 98       	mov	r8,r11
8000b7b4:	18 97       	mov	r7,r12
8000b7b6:	10 9c       	mov	r12,r8
8000b7b8:	30 08       	mov	r8,0
8000b7ba:	14 9b       	mov	r11,r10
8000b7bc:	e0 66 63 a0 	mov	r6,25504
8000b7c0:	12 9a       	mov	r10,r9
8000b7c2:	8d 08       	st.w	r6[0x0],r8
8000b7c4:	fe b0 d1 a4 	rcall	80005b0c <_write>
8000b7c8:	5b fc       	cp.w	r12,-1
8000b7ca:	c0 51       	brne	8000b7d4 <_write_r+0x24>
8000b7cc:	6c 08       	ld.w	r8,r6[0x0]
8000b7ce:	58 08       	cp.w	r8,0
8000b7d0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7d4:	d8 22       	popm	r4-r7,pc
8000b7d6:	d7 03       	nop

8000b7d8 <_calloc_r>:
8000b7d8:	d4 21       	pushm	r4-r7,lr
8000b7da:	f4 0b 02 4b 	mul	r11,r10,r11
8000b7de:	fe b0 db 6d 	rcall	80006eb8 <_malloc_r>
8000b7e2:	18 97       	mov	r7,r12
8000b7e4:	c2 30       	breq	8000b82a <_calloc_r+0x52>
8000b7e6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b7ea:	e0 1a ff fc 	andl	r10,0xfffc
8000b7ee:	20 4a       	sub	r10,4
8000b7f0:	e0 4a 00 24 	cp.w	r10,36
8000b7f4:	e0 8b 00 18 	brhi	8000b824 <_calloc_r+0x4c>
8000b7f8:	18 98       	mov	r8,r12
8000b7fa:	59 3a       	cp.w	r10,19
8000b7fc:	e0 88 00 0f 	brls	8000b81a <_calloc_r+0x42>
8000b800:	30 09       	mov	r9,0
8000b802:	10 a9       	st.w	r8++,r9
8000b804:	10 a9       	st.w	r8++,r9
8000b806:	59 ba       	cp.w	r10,27
8000b808:	e0 88 00 09 	brls	8000b81a <_calloc_r+0x42>
8000b80c:	10 a9       	st.w	r8++,r9
8000b80e:	10 a9       	st.w	r8++,r9
8000b810:	e0 4a 00 24 	cp.w	r10,36
8000b814:	c0 31       	brne	8000b81a <_calloc_r+0x42>
8000b816:	10 a9       	st.w	r8++,r9
8000b818:	10 a9       	st.w	r8++,r9
8000b81a:	30 09       	mov	r9,0
8000b81c:	10 a9       	st.w	r8++,r9
8000b81e:	91 19       	st.w	r8[0x4],r9
8000b820:	91 09       	st.w	r8[0x0],r9
8000b822:	c0 48       	rjmp	8000b82a <_calloc_r+0x52>
8000b824:	30 0b       	mov	r11,0
8000b826:	fe b0 de 1c 	rcall	8000745e <memset>
8000b82a:	0e 9c       	mov	r12,r7
8000b82c:	d8 22       	popm	r4-r7,pc
8000b82e:	d7 03       	nop

8000b830 <_close_r>:
8000b830:	d4 21       	pushm	r4-r7,lr
8000b832:	30 08       	mov	r8,0
8000b834:	18 97       	mov	r7,r12
8000b836:	e0 66 63 a0 	mov	r6,25504
8000b83a:	16 9c       	mov	r12,r11
8000b83c:	8d 08       	st.w	r6[0x0],r8
8000b83e:	fe b0 df b5 	rcall	800077a8 <_close>
8000b842:	5b fc       	cp.w	r12,-1
8000b844:	c0 51       	brne	8000b84e <_close_r+0x1e>
8000b846:	6c 08       	ld.w	r8,r6[0x0]
8000b848:	58 08       	cp.w	r8,0
8000b84a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b84e:	d8 22       	popm	r4-r7,pc

8000b850 <_fclose_r>:
8000b850:	d4 21       	pushm	r4-r7,lr
8000b852:	18 96       	mov	r6,r12
8000b854:	16 97       	mov	r7,r11
8000b856:	58 0b       	cp.w	r11,0
8000b858:	c0 31       	brne	8000b85e <_fclose_r+0xe>
8000b85a:	16 95       	mov	r5,r11
8000b85c:	c5 38       	rjmp	8000b902 <_fclose_r+0xb2>
8000b85e:	fe b0 f8 a9 	rcall	8000a9b0 <__sfp_lock_acquire>
8000b862:	58 06       	cp.w	r6,0
8000b864:	c0 70       	breq	8000b872 <_fclose_r+0x22>
8000b866:	6c 68       	ld.w	r8,r6[0x18]
8000b868:	58 08       	cp.w	r8,0
8000b86a:	c0 41       	brne	8000b872 <_fclose_r+0x22>
8000b86c:	0c 9c       	mov	r12,r6
8000b86e:	fe b0 f8 f3 	rcall	8000aa54 <__sinit>
8000b872:	fe c8 de 3e 	sub	r8,pc,-8642
8000b876:	10 37       	cp.w	r7,r8
8000b878:	c0 31       	brne	8000b87e <_fclose_r+0x2e>
8000b87a:	6c 07       	ld.w	r7,r6[0x0]
8000b87c:	c0 c8       	rjmp	8000b894 <_fclose_r+0x44>
8000b87e:	fe c8 de 2a 	sub	r8,pc,-8662
8000b882:	10 37       	cp.w	r7,r8
8000b884:	c0 31       	brne	8000b88a <_fclose_r+0x3a>
8000b886:	6c 17       	ld.w	r7,r6[0x4]
8000b888:	c0 68       	rjmp	8000b894 <_fclose_r+0x44>
8000b88a:	fe c8 de 16 	sub	r8,pc,-8682
8000b88e:	10 37       	cp.w	r7,r8
8000b890:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b894:	8e 69       	ld.sh	r9,r7[0xc]
8000b896:	30 08       	mov	r8,0
8000b898:	f0 09 19 00 	cp.h	r9,r8
8000b89c:	c0 51       	brne	8000b8a6 <_fclose_r+0x56>
8000b89e:	fe b0 f8 8a 	rcall	8000a9b2 <__sfp_lock_release>
8000b8a2:	30 05       	mov	r5,0
8000b8a4:	c2 f8       	rjmp	8000b902 <_fclose_r+0xb2>
8000b8a6:	0e 9b       	mov	r11,r7
8000b8a8:	0c 9c       	mov	r12,r6
8000b8aa:	fe b0 f7 fd 	rcall	8000a8a4 <_fflush_r>
8000b8ae:	6e c8       	ld.w	r8,r7[0x30]
8000b8b0:	18 95       	mov	r5,r12
8000b8b2:	58 08       	cp.w	r8,0
8000b8b4:	c0 60       	breq	8000b8c0 <_fclose_r+0x70>
8000b8b6:	6e 8b       	ld.w	r11,r7[0x20]
8000b8b8:	0c 9c       	mov	r12,r6
8000b8ba:	5d 18       	icall	r8
8000b8bc:	f9 b5 05 ff 	movlt	r5,-1
8000b8c0:	8e 68       	ld.sh	r8,r7[0xc]
8000b8c2:	ed b8 00 07 	bld	r8,0x7
8000b8c6:	c0 51       	brne	8000b8d0 <_fclose_r+0x80>
8000b8c8:	6e 4b       	ld.w	r11,r7[0x10]
8000b8ca:	0c 9c       	mov	r12,r6
8000b8cc:	fe b0 f9 5e 	rcall	8000ab88 <_free_r>
8000b8d0:	6e db       	ld.w	r11,r7[0x34]
8000b8d2:	58 0b       	cp.w	r11,0
8000b8d4:	c0 a0       	breq	8000b8e8 <_fclose_r+0x98>
8000b8d6:	ee c8 ff bc 	sub	r8,r7,-68
8000b8da:	10 3b       	cp.w	r11,r8
8000b8dc:	c0 40       	breq	8000b8e4 <_fclose_r+0x94>
8000b8de:	0c 9c       	mov	r12,r6
8000b8e0:	fe b0 f9 54 	rcall	8000ab88 <_free_r>
8000b8e4:	30 08       	mov	r8,0
8000b8e6:	8f d8       	st.w	r7[0x34],r8
8000b8e8:	6f 2b       	ld.w	r11,r7[0x48]
8000b8ea:	58 0b       	cp.w	r11,0
8000b8ec:	c0 70       	breq	8000b8fa <_fclose_r+0xaa>
8000b8ee:	0c 9c       	mov	r12,r6
8000b8f0:	fe b0 f9 4c 	rcall	8000ab88 <_free_r>
8000b8f4:	30 08       	mov	r8,0
8000b8f6:	ef 48 00 48 	st.w	r7[72],r8
8000b8fa:	30 08       	mov	r8,0
8000b8fc:	ae 68       	st.h	r7[0xc],r8
8000b8fe:	fe b0 f8 5a 	rcall	8000a9b2 <__sfp_lock_release>
8000b902:	0a 9c       	mov	r12,r5
8000b904:	d8 22       	popm	r4-r7,pc
8000b906:	d7 03       	nop

8000b908 <fclose>:
8000b908:	d4 01       	pushm	lr
8000b90a:	e0 68 0a 38 	mov	r8,2616
8000b90e:	18 9b       	mov	r11,r12
8000b910:	70 0c       	ld.w	r12,r8[0x0]
8000b912:	c9 ff       	rcall	8000b850 <_fclose_r>
8000b914:	d8 02       	popm	pc
8000b916:	d7 03       	nop

8000b918 <_fstat_r>:
8000b918:	d4 21       	pushm	r4-r7,lr
8000b91a:	16 98       	mov	r8,r11
8000b91c:	18 97       	mov	r7,r12
8000b91e:	10 9c       	mov	r12,r8
8000b920:	30 08       	mov	r8,0
8000b922:	e0 66 63 a0 	mov	r6,25504
8000b926:	14 9b       	mov	r11,r10
8000b928:	8d 08       	st.w	r6[0x0],r8
8000b92a:	fe b0 df 67 	rcall	800077f8 <_fstat>
8000b92e:	5b fc       	cp.w	r12,-1
8000b930:	c0 51       	brne	8000b93a <_fstat_r+0x22>
8000b932:	6c 08       	ld.w	r8,r6[0x0]
8000b934:	58 08       	cp.w	r8,0
8000b936:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b93a:	d8 22       	popm	r4-r7,pc

8000b93c <_lseek_r>:
8000b93c:	d4 21       	pushm	r4-r7,lr
8000b93e:	16 98       	mov	r8,r11
8000b940:	18 97       	mov	r7,r12
8000b942:	10 9c       	mov	r12,r8
8000b944:	30 08       	mov	r8,0
8000b946:	14 9b       	mov	r11,r10
8000b948:	e0 66 63 a0 	mov	r6,25504
8000b94c:	12 9a       	mov	r10,r9
8000b94e:	8d 08       	st.w	r6[0x0],r8
8000b950:	fe b0 df 36 	rcall	800077bc <_lseek>
8000b954:	5b fc       	cp.w	r12,-1
8000b956:	c0 51       	brne	8000b960 <_lseek_r+0x24>
8000b958:	6c 08       	ld.w	r8,r6[0x0]
8000b95a:	58 08       	cp.w	r8,0
8000b95c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b960:	d8 22       	popm	r4-r7,pc
8000b962:	d7 03       	nop

8000b964 <_read_r>:
8000b964:	d4 21       	pushm	r4-r7,lr
8000b966:	16 98       	mov	r8,r11
8000b968:	18 97       	mov	r7,r12
8000b96a:	10 9c       	mov	r12,r8
8000b96c:	30 08       	mov	r8,0
8000b96e:	14 9b       	mov	r11,r10
8000b970:	e0 66 63 a0 	mov	r6,25504
8000b974:	12 9a       	mov	r10,r9
8000b976:	8d 08       	st.w	r6[0x0],r8
8000b978:	fe b0 d0 aa 	rcall	80005acc <_read>
8000b97c:	5b fc       	cp.w	r12,-1
8000b97e:	c0 51       	brne	8000b988 <_read_r+0x24>
8000b980:	6c 08       	ld.w	r8,r6[0x0]
8000b982:	58 08       	cp.w	r8,0
8000b984:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b988:	d8 22       	popm	r4-r7,pc
8000b98a:	d7 03       	nop

8000b98c <__avr32_f64_mul>:
8000b98c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b990:	e0 80 00 dc 	breq	8000bb48 <__avr32_f64_mul_op1_zero>
8000b994:	d4 21       	pushm	r4-r7,lr
8000b996:	f7 e9 20 0e 	eor	lr,r11,r9
8000b99a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b99e:	30 15       	mov	r5,1
8000b9a0:	c4 30       	breq	8000ba26 <__avr32_f64_mul_op1_subnormal>
8000b9a2:	ab 6b       	lsl	r11,0xa
8000b9a4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b9a8:	ab 6a       	lsl	r10,0xa
8000b9aa:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b9ae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b9b2:	c5 c0       	breq	8000ba6a <__avr32_f64_mul_op2_subnormal>
8000b9b4:	a1 78       	lsl	r8,0x1
8000b9b6:	5c f9       	rol	r9
8000b9b8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b9bc:	e0 47 07 ff 	cp.w	r7,2047
8000b9c0:	c7 70       	breq	8000baae <__avr32_f64_mul_op_nan_or_inf>
8000b9c2:	e0 46 07 ff 	cp.w	r6,2047
8000b9c6:	c7 40       	breq	8000baae <__avr32_f64_mul_op_nan_or_inf>
8000b9c8:	ee 06 00 0c 	add	r12,r7,r6
8000b9cc:	e0 2c 03 fe 	sub	r12,1022
8000b9d0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b9d4:	f4 09 07 44 	macu.d	r4,r10,r9
8000b9d8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b9dc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b9e0:	08 07       	add	r7,r4
8000b9e2:	f4 05 00 4a 	adc	r10,r10,r5
8000b9e6:	5c 0b       	acr	r11
8000b9e8:	ed bb 00 14 	bld	r11,0x14
8000b9ec:	c0 50       	breq	8000b9f6 <__avr32_f64_mul+0x6a>
8000b9ee:	a1 77       	lsl	r7,0x1
8000b9f0:	5c fa       	rol	r10
8000b9f2:	5c fb       	rol	r11
8000b9f4:	20 1c       	sub	r12,1
8000b9f6:	58 0c       	cp.w	r12,0
8000b9f8:	e0 8a 00 6f 	brle	8000bad6 <__avr32_f64_mul_res_subnormal>
8000b9fc:	e0 4c 07 ff 	cp.w	r12,2047
8000ba00:	e0 84 00 9c 	brge	8000bb38 <__avr32_f64_mul_res_inf>
8000ba04:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ba08:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ba0c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ba10:	ee 17 80 00 	eorh	r7,0x8000
8000ba14:	f1 b7 04 20 	satu	r7,0x1
8000ba18:	0e 0a       	add	r10,r7
8000ba1a:	5c 0b       	acr	r11
8000ba1c:	ed be 00 1f 	bld	lr,0x1f
8000ba20:	ef bb 00 1f 	bst	r11,0x1f
8000ba24:	d8 22       	popm	r4-r7,pc

8000ba26 <__avr32_f64_mul_op1_subnormal>:
8000ba26:	e4 1b 00 0f 	andh	r11,0xf
8000ba2a:	f4 0c 12 00 	clz	r12,r10
8000ba2e:	f6 06 12 00 	clz	r6,r11
8000ba32:	f7 bc 03 e1 	sublo	r12,-31
8000ba36:	f8 06 17 30 	movlo	r6,r12
8000ba3a:	f7 b6 02 01 	subhs	r6,1
8000ba3e:	e0 46 00 20 	cp.w	r6,32
8000ba42:	c0 d4       	brge	8000ba5c <__avr32_f64_mul_op1_subnormal+0x36>
8000ba44:	ec 0c 11 20 	rsub	r12,r6,32
8000ba48:	f6 06 09 4b 	lsl	r11,r11,r6
8000ba4c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ba50:	18 4b       	or	r11,r12
8000ba52:	f4 06 09 4a 	lsl	r10,r10,r6
8000ba56:	20 b6       	sub	r6,11
8000ba58:	0c 17       	sub	r7,r6
8000ba5a:	ca ab       	rjmp	8000b9ae <__avr32_f64_mul+0x22>
8000ba5c:	f4 06 09 4b 	lsl	r11,r10,r6
8000ba60:	c6 40       	breq	8000bb28 <__avr32_f64_mul_res_zero>
8000ba62:	30 0a       	mov	r10,0
8000ba64:	20 b6       	sub	r6,11
8000ba66:	0c 17       	sub	r7,r6
8000ba68:	ca 3b       	rjmp	8000b9ae <__avr32_f64_mul+0x22>

8000ba6a <__avr32_f64_mul_op2_subnormal>:
8000ba6a:	e4 19 00 0f 	andh	r9,0xf
8000ba6e:	f0 0c 12 00 	clz	r12,r8
8000ba72:	f2 05 12 00 	clz	r5,r9
8000ba76:	f7 bc 03 ea 	sublo	r12,-22
8000ba7a:	f8 05 17 30 	movlo	r5,r12
8000ba7e:	f7 b5 02 0a 	subhs	r5,10
8000ba82:	e0 45 00 20 	cp.w	r5,32
8000ba86:	c0 d4       	brge	8000baa0 <__avr32_f64_mul_op2_subnormal+0x36>
8000ba88:	ea 0c 11 20 	rsub	r12,r5,32
8000ba8c:	f2 05 09 49 	lsl	r9,r9,r5
8000ba90:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ba94:	18 49       	or	r9,r12
8000ba96:	f0 05 09 48 	lsl	r8,r8,r5
8000ba9a:	20 25       	sub	r5,2
8000ba9c:	0a 16       	sub	r6,r5
8000ba9e:	c8 fb       	rjmp	8000b9bc <__avr32_f64_mul+0x30>
8000baa0:	f0 05 09 49 	lsl	r9,r8,r5
8000baa4:	c4 20       	breq	8000bb28 <__avr32_f64_mul_res_zero>
8000baa6:	30 08       	mov	r8,0
8000baa8:	20 25       	sub	r5,2
8000baaa:	0a 16       	sub	r6,r5
8000baac:	c8 8b       	rjmp	8000b9bc <__avr32_f64_mul+0x30>

8000baae <__avr32_f64_mul_op_nan_or_inf>:
8000baae:	e4 19 00 0f 	andh	r9,0xf
8000bab2:	e4 1b 00 0f 	andh	r11,0xf
8000bab6:	14 4b       	or	r11,r10
8000bab8:	10 49       	or	r9,r8
8000baba:	e0 47 07 ff 	cp.w	r7,2047
8000babe:	c0 91       	brne	8000bad0 <__avr32_f64_mul_op1_not_naninf>
8000bac0:	58 0b       	cp.w	r11,0
8000bac2:	c3 81       	brne	8000bb32 <__avr32_f64_mul_res_nan>
8000bac4:	e0 46 07 ff 	cp.w	r6,2047
8000bac8:	c3 81       	brne	8000bb38 <__avr32_f64_mul_res_inf>
8000baca:	58 09       	cp.w	r9,0
8000bacc:	c3 60       	breq	8000bb38 <__avr32_f64_mul_res_inf>
8000bace:	c3 28       	rjmp	8000bb32 <__avr32_f64_mul_res_nan>

8000bad0 <__avr32_f64_mul_op1_not_naninf>:
8000bad0:	58 09       	cp.w	r9,0
8000bad2:	c3 30       	breq	8000bb38 <__avr32_f64_mul_res_inf>
8000bad4:	c2 f8       	rjmp	8000bb32 <__avr32_f64_mul_res_nan>

8000bad6 <__avr32_f64_mul_res_subnormal>:
8000bad6:	5c 3c       	neg	r12
8000bad8:	2f fc       	sub	r12,-1
8000bada:	f1 bc 04 c0 	satu	r12,0x6
8000bade:	e0 4c 00 20 	cp.w	r12,32
8000bae2:	c1 14       	brge	8000bb04 <__avr32_f64_mul_res_subnormal+0x2e>
8000bae4:	f8 08 11 20 	rsub	r8,r12,32
8000bae8:	0e 46       	or	r6,r7
8000baea:	ee 0c 0a 47 	lsr	r7,r7,r12
8000baee:	f4 08 09 49 	lsl	r9,r10,r8
8000baf2:	12 47       	or	r7,r9
8000baf4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000baf8:	f6 08 09 49 	lsl	r9,r11,r8
8000bafc:	12 4a       	or	r10,r9
8000bafe:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb02:	c8 3b       	rjmp	8000ba08 <__avr32_f64_mul+0x7c>
8000bb04:	f8 08 11 20 	rsub	r8,r12,32
8000bb08:	f9 b9 00 00 	moveq	r9,0
8000bb0c:	c0 30       	breq	8000bb12 <__avr32_f64_mul_res_subnormal+0x3c>
8000bb0e:	f6 08 09 49 	lsl	r9,r11,r8
8000bb12:	0e 46       	or	r6,r7
8000bb14:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bb18:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb1c:	f3 ea 10 07 	or	r7,r9,r10
8000bb20:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bb24:	30 0b       	mov	r11,0
8000bb26:	c7 1b       	rjmp	8000ba08 <__avr32_f64_mul+0x7c>

8000bb28 <__avr32_f64_mul_res_zero>:
8000bb28:	1c 9b       	mov	r11,lr
8000bb2a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb2e:	30 0a       	mov	r10,0
8000bb30:	d8 22       	popm	r4-r7,pc

8000bb32 <__avr32_f64_mul_res_nan>:
8000bb32:	3f fb       	mov	r11,-1
8000bb34:	3f fa       	mov	r10,-1
8000bb36:	d8 22       	popm	r4-r7,pc

8000bb38 <__avr32_f64_mul_res_inf>:
8000bb38:	f0 6b 00 00 	mov	r11,-1048576
8000bb3c:	ed be 00 1f 	bld	lr,0x1f
8000bb40:	ef bb 00 1f 	bst	r11,0x1f
8000bb44:	30 0a       	mov	r10,0
8000bb46:	d8 22       	popm	r4-r7,pc

8000bb48 <__avr32_f64_mul_op1_zero>:
8000bb48:	f7 e9 20 0b 	eor	r11,r11,r9
8000bb4c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb50:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bb54:	e0 4c 07 ff 	cp.w	r12,2047
8000bb58:	5e 1c       	retne	r12
8000bb5a:	3f fa       	mov	r10,-1
8000bb5c:	3f fb       	mov	r11,-1
8000bb5e:	5e fc       	retal	r12

8000bb60 <__avr32_f64_sub_from_add>:
8000bb60:	ee 19 80 00 	eorh	r9,0x8000

8000bb64 <__avr32_f64_sub>:
8000bb64:	f7 e9 20 0c 	eor	r12,r11,r9
8000bb68:	e0 86 00 ca 	brmi	8000bcfc <__avr32_f64_add_from_sub>
8000bb6c:	eb cd 40 e0 	pushm	r5-r7,lr
8000bb70:	16 9c       	mov	r12,r11
8000bb72:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bb76:	bf db       	cbr	r11,0x1f
8000bb78:	bf d9       	cbr	r9,0x1f
8000bb7a:	10 3a       	cp.w	r10,r8
8000bb7c:	f2 0b 13 00 	cpc	r11,r9
8000bb80:	c0 92       	brcc	8000bb92 <__avr32_f64_sub+0x2e>
8000bb82:	16 97       	mov	r7,r11
8000bb84:	12 9b       	mov	r11,r9
8000bb86:	0e 99       	mov	r9,r7
8000bb88:	14 97       	mov	r7,r10
8000bb8a:	10 9a       	mov	r10,r8
8000bb8c:	0e 98       	mov	r8,r7
8000bb8e:	ee 1c 80 00 	eorh	r12,0x8000
8000bb92:	f6 07 16 14 	lsr	r7,r11,0x14
8000bb96:	ab 7b       	lsl	r11,0xb
8000bb98:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb9c:	ab 7a       	lsl	r10,0xb
8000bb9e:	bf bb       	sbr	r11,0x1f
8000bba0:	f2 06 16 14 	lsr	r6,r9,0x14
8000bba4:	c4 40       	breq	8000bc2c <__avr32_f64_sub_opL_subnormal>
8000bba6:	ab 79       	lsl	r9,0xb
8000bba8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bbac:	ab 78       	lsl	r8,0xb
8000bbae:	bf b9       	sbr	r9,0x1f

8000bbb0 <__avr32_f64_sub_opL_subnormal_done>:
8000bbb0:	e0 47 07 ff 	cp.w	r7,2047
8000bbb4:	c4 f0       	breq	8000bc52 <__avr32_f64_sub_opH_nan_or_inf>
8000bbb6:	0e 26       	rsub	r6,r7
8000bbb8:	c1 20       	breq	8000bbdc <__avr32_f64_sub_shift_done>
8000bbba:	ec 05 11 20 	rsub	r5,r6,32
8000bbbe:	e0 46 00 20 	cp.w	r6,32
8000bbc2:	c7 c2       	brcc	8000bcba <__avr32_f64_sub_longshift>
8000bbc4:	f0 05 09 4e 	lsl	lr,r8,r5
8000bbc8:	f2 05 09 45 	lsl	r5,r9,r5
8000bbcc:	f0 06 0a 48 	lsr	r8,r8,r6
8000bbd0:	f2 06 0a 49 	lsr	r9,r9,r6
8000bbd4:	0a 48       	or	r8,r5
8000bbd6:	58 0e       	cp.w	lr,0
8000bbd8:	5f 1e       	srne	lr
8000bbda:	1c 48       	or	r8,lr

8000bbdc <__avr32_f64_sub_shift_done>:
8000bbdc:	10 1a       	sub	r10,r8
8000bbde:	f6 09 01 4b 	sbc	r11,r11,r9
8000bbe2:	f6 06 12 00 	clz	r6,r11
8000bbe6:	c0 e0       	breq	8000bc02 <__avr32_f64_sub_longnormalize_done>
8000bbe8:	c7 83       	brcs	8000bcd8 <__avr32_f64_sub_longnormalize>
8000bbea:	ec 0e 11 20 	rsub	lr,r6,32
8000bbee:	f6 06 09 4b 	lsl	r11,r11,r6
8000bbf2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bbf6:	1c 4b       	or	r11,lr
8000bbf8:	f4 06 09 4a 	lsl	r10,r10,r6
8000bbfc:	0c 17       	sub	r7,r6
8000bbfe:	e0 8a 00 39 	brle	8000bc70 <__avr32_f64_sub_subnormal_result>

8000bc02 <__avr32_f64_sub_longnormalize_done>:
8000bc02:	f4 09 15 15 	lsl	r9,r10,0x15
8000bc06:	ab 9a       	lsr	r10,0xb
8000bc08:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc0c:	ab 9b       	lsr	r11,0xb
8000bc0e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc12:	18 4b       	or	r11,r12

8000bc14 <__avr32_f64_sub_round>:
8000bc14:	fc 17 80 00 	movh	r7,0x8000
8000bc18:	ed ba 00 00 	bld	r10,0x0
8000bc1c:	f7 b7 01 ff 	subne	r7,-1
8000bc20:	0e 39       	cp.w	r9,r7
8000bc22:	5f 29       	srhs	r9
8000bc24:	12 0a       	add	r10,r9
8000bc26:	5c 0b       	acr	r11
8000bc28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc2c <__avr32_f64_sub_opL_subnormal>:
8000bc2c:	ab 79       	lsl	r9,0xb
8000bc2e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bc32:	ab 78       	lsl	r8,0xb
8000bc34:	f3 e8 10 0e 	or	lr,r9,r8
8000bc38:	f9 b6 01 01 	movne	r6,1
8000bc3c:	ee 0e 11 00 	rsub	lr,r7,0
8000bc40:	f9 b7 00 01 	moveq	r7,1
8000bc44:	ef bb 00 1f 	bst	r11,0x1f
8000bc48:	f7 ea 10 0e 	or	lr,r11,r10
8000bc4c:	f9 b7 00 00 	moveq	r7,0
8000bc50:	cb 0b       	rjmp	8000bbb0 <__avr32_f64_sub_opL_subnormal_done>

8000bc52 <__avr32_f64_sub_opH_nan_or_inf>:
8000bc52:	bf db       	cbr	r11,0x1f
8000bc54:	f7 ea 10 0e 	or	lr,r11,r10
8000bc58:	c0 81       	brne	8000bc68 <__avr32_f64_sub_return_nan>
8000bc5a:	e0 46 07 ff 	cp.w	r6,2047
8000bc5e:	c0 50       	breq	8000bc68 <__avr32_f64_sub_return_nan>
8000bc60:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bc64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc68 <__avr32_f64_sub_return_nan>:
8000bc68:	3f fa       	mov	r10,-1
8000bc6a:	3f fb       	mov	r11,-1
8000bc6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc70 <__avr32_f64_sub_subnormal_result>:
8000bc70:	5c 37       	neg	r7
8000bc72:	2f f7       	sub	r7,-1
8000bc74:	f1 b7 04 c0 	satu	r7,0x6
8000bc78:	e0 47 00 20 	cp.w	r7,32
8000bc7c:	c1 14       	brge	8000bc9e <__avr32_f64_sub_subnormal_result+0x2e>
8000bc7e:	ee 08 11 20 	rsub	r8,r7,32
8000bc82:	f4 08 09 49 	lsl	r9,r10,r8
8000bc86:	5f 16       	srne	r6
8000bc88:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bc8c:	0c 4a       	or	r10,r6
8000bc8e:	f6 08 09 49 	lsl	r9,r11,r8
8000bc92:	f5 e9 10 0a 	or	r10,r10,r9
8000bc96:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bc9a:	30 07       	mov	r7,0
8000bc9c:	cb 3b       	rjmp	8000bc02 <__avr32_f64_sub_longnormalize_done>
8000bc9e:	ee 08 11 40 	rsub	r8,r7,64
8000bca2:	f6 08 09 49 	lsl	r9,r11,r8
8000bca6:	14 49       	or	r9,r10
8000bca8:	5f 16       	srne	r6
8000bcaa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bcae:	0c 4a       	or	r10,r6
8000bcb0:	30 0b       	mov	r11,0
8000bcb2:	30 07       	mov	r7,0
8000bcb4:	ca 7b       	rjmp	8000bc02 <__avr32_f64_sub_longnormalize_done>
8000bcb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcba <__avr32_f64_sub_longshift>:
8000bcba:	f1 b6 04 c0 	satu	r6,0x6
8000bcbe:	f0 0e 17 00 	moveq	lr,r8
8000bcc2:	c0 40       	breq	8000bcca <__avr32_f64_sub_longshift+0x10>
8000bcc4:	f2 05 09 4e 	lsl	lr,r9,r5
8000bcc8:	10 4e       	or	lr,r8
8000bcca:	f2 06 0a 48 	lsr	r8,r9,r6
8000bcce:	30 09       	mov	r9,0
8000bcd0:	58 0e       	cp.w	lr,0
8000bcd2:	5f 1e       	srne	lr
8000bcd4:	1c 48       	or	r8,lr
8000bcd6:	c8 3b       	rjmp	8000bbdc <__avr32_f64_sub_shift_done>

8000bcd8 <__avr32_f64_sub_longnormalize>:
8000bcd8:	f4 06 12 00 	clz	r6,r10
8000bcdc:	f9 b7 03 00 	movlo	r7,0
8000bce0:	f9 b6 03 00 	movlo	r6,0
8000bce4:	f9 bc 03 00 	movlo	r12,0
8000bce8:	f7 b6 02 e0 	subhs	r6,-32
8000bcec:	f4 06 09 4b 	lsl	r11,r10,r6
8000bcf0:	30 0a       	mov	r10,0
8000bcf2:	0c 17       	sub	r7,r6
8000bcf4:	fe 9a ff be 	brle	8000bc70 <__avr32_f64_sub_subnormal_result>
8000bcf8:	c8 5b       	rjmp	8000bc02 <__avr32_f64_sub_longnormalize_done>
8000bcfa:	d7 03       	nop

8000bcfc <__avr32_f64_add_from_sub>:
8000bcfc:	ee 19 80 00 	eorh	r9,0x8000

8000bd00 <__avr32_f64_add>:
8000bd00:	f7 e9 20 0c 	eor	r12,r11,r9
8000bd04:	fe 96 ff 2e 	brmi	8000bb60 <__avr32_f64_sub_from_add>
8000bd08:	eb cd 40 e0 	pushm	r5-r7,lr
8000bd0c:	16 9c       	mov	r12,r11
8000bd0e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bd12:	bf db       	cbr	r11,0x1f
8000bd14:	bf d9       	cbr	r9,0x1f
8000bd16:	12 3b       	cp.w	r11,r9
8000bd18:	c0 72       	brcc	8000bd26 <__avr32_f64_add+0x26>
8000bd1a:	16 97       	mov	r7,r11
8000bd1c:	12 9b       	mov	r11,r9
8000bd1e:	0e 99       	mov	r9,r7
8000bd20:	14 97       	mov	r7,r10
8000bd22:	10 9a       	mov	r10,r8
8000bd24:	0e 98       	mov	r8,r7
8000bd26:	30 0e       	mov	lr,0
8000bd28:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd2c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bd30:	b5 ab       	sbr	r11,0x14
8000bd32:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd36:	c6 20       	breq	8000bdfa <__avr32_f64_add_op2_subnormal>
8000bd38:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bd3c:	b5 a9       	sbr	r9,0x14
8000bd3e:	e0 47 07 ff 	cp.w	r7,2047
8000bd42:	c2 80       	breq	8000bd92 <__avr32_f64_add_opH_nan_or_inf>
8000bd44:	0e 26       	rsub	r6,r7
8000bd46:	c1 20       	breq	8000bd6a <__avr32_f64_add_shift_done>
8000bd48:	e0 46 00 36 	cp.w	r6,54
8000bd4c:	c1 52       	brcc	8000bd76 <__avr32_f64_add_res_of_done>
8000bd4e:	ec 05 11 20 	rsub	r5,r6,32
8000bd52:	e0 46 00 20 	cp.w	r6,32
8000bd56:	c3 52       	brcc	8000bdc0 <__avr32_f64_add_longshift>
8000bd58:	f0 05 09 4e 	lsl	lr,r8,r5
8000bd5c:	f2 05 09 45 	lsl	r5,r9,r5
8000bd60:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd64:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd68:	0a 48       	or	r8,r5

8000bd6a <__avr32_f64_add_shift_done>:
8000bd6a:	10 0a       	add	r10,r8
8000bd6c:	f6 09 00 4b 	adc	r11,r11,r9
8000bd70:	ed bb 00 15 	bld	r11,0x15
8000bd74:	c3 40       	breq	8000bddc <__avr32_f64_add_res_of>

8000bd76 <__avr32_f64_add_res_of_done>:
8000bd76:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd7a:	18 4b       	or	r11,r12

8000bd7c <__avr32_f64_add_round>:
8000bd7c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bd80:	18 4e       	or	lr,r12
8000bd82:	ee 1e 80 00 	eorh	lr,0x8000
8000bd86:	f1 be 04 20 	satu	lr,0x1
8000bd8a:	1c 0a       	add	r10,lr
8000bd8c:	5c 0b       	acr	r11
8000bd8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd92 <__avr32_f64_add_opH_nan_or_inf>:
8000bd92:	b5 cb       	cbr	r11,0x14
8000bd94:	f7 ea 10 0e 	or	lr,r11,r10
8000bd98:	c1 01       	brne	8000bdb8 <__avr32_f64_add_return_nan>
8000bd9a:	e0 46 07 ff 	cp.w	r6,2047
8000bd9e:	c0 30       	breq	8000bda4 <__avr32_f64_add_opL_nan_or_inf>
8000bda0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bda4 <__avr32_f64_add_opL_nan_or_inf>:
8000bda4:	b5 c9       	cbr	r9,0x14
8000bda6:	f3 e8 10 0e 	or	lr,r9,r8
8000bdaa:	c0 71       	brne	8000bdb8 <__avr32_f64_add_return_nan>
8000bdac:	30 0a       	mov	r10,0
8000bdae:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bdb2:	18 4b       	or	r11,r12
8000bdb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdb8 <__avr32_f64_add_return_nan>:
8000bdb8:	3f fa       	mov	r10,-1
8000bdba:	3f fb       	mov	r11,-1
8000bdbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdc0 <__avr32_f64_add_longshift>:
8000bdc0:	f1 b6 04 c0 	satu	r6,0x6
8000bdc4:	f0 0e 17 00 	moveq	lr,r8
8000bdc8:	c0 60       	breq	8000bdd4 <__avr32_f64_add_longshift+0x14>
8000bdca:	f2 05 09 4e 	lsl	lr,r9,r5
8000bdce:	58 08       	cp.w	r8,0
8000bdd0:	5f 18       	srne	r8
8000bdd2:	10 4e       	or	lr,r8
8000bdd4:	f2 06 0a 48 	lsr	r8,r9,r6
8000bdd8:	30 09       	mov	r9,0
8000bdda:	cc 8b       	rjmp	8000bd6a <__avr32_f64_add_shift_done>

8000bddc <__avr32_f64_add_res_of>:
8000bddc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bde0:	a1 9b       	lsr	r11,0x1
8000bde2:	5d 0a       	ror	r10
8000bde4:	5d 0e       	ror	lr
8000bde6:	2f f7       	sub	r7,-1
8000bde8:	e0 47 07 ff 	cp.w	r7,2047
8000bdec:	f9 ba 00 00 	moveq	r10,0
8000bdf0:	f9 bb 00 00 	moveq	r11,0
8000bdf4:	f9 be 00 00 	moveq	lr,0
8000bdf8:	cb fb       	rjmp	8000bd76 <__avr32_f64_add_res_of_done>

8000bdfa <__avr32_f64_add_op2_subnormal>:
8000bdfa:	30 16       	mov	r6,1
8000bdfc:	58 07       	cp.w	r7,0
8000bdfe:	ca 01       	brne	8000bd3e <__avr32_f64_add+0x3e>
8000be00:	b5 cb       	cbr	r11,0x14
8000be02:	10 0a       	add	r10,r8
8000be04:	f6 09 00 4b 	adc	r11,r11,r9
8000be08:	18 4b       	or	r11,r12
8000be0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000be0e:	d7 03       	nop

8000be10 <__avr32_f64_to_u32>:
8000be10:	58 0b       	cp.w	r11,0
8000be12:	5e 6d       	retmi	0

8000be14 <__avr32_f64_to_s32>:
8000be14:	f6 0c 15 01 	lsl	r12,r11,0x1
8000be18:	b5 9c       	lsr	r12,0x15
8000be1a:	e0 2c 03 ff 	sub	r12,1023
8000be1e:	5e 3d       	retlo	0
8000be20:	f8 0c 11 1f 	rsub	r12,r12,31
8000be24:	16 99       	mov	r9,r11
8000be26:	ab 7b       	lsl	r11,0xb
8000be28:	bf bb       	sbr	r11,0x1f
8000be2a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be2e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be32:	a1 79       	lsl	r9,0x1
8000be34:	5e 2b       	reths	r11
8000be36:	5c 3b       	neg	r11
8000be38:	5e fb       	retal	r11

8000be3a <__avr32_u32_to_f64>:
8000be3a:	f8 cb 00 00 	sub	r11,r12,0
8000be3e:	30 0c       	mov	r12,0
8000be40:	c0 38       	rjmp	8000be46 <__avr32_s32_to_f64+0x4>

8000be42 <__avr32_s32_to_f64>:
8000be42:	18 9b       	mov	r11,r12
8000be44:	5c 4b       	abs	r11
8000be46:	30 0a       	mov	r10,0
8000be48:	5e 0b       	reteq	r11
8000be4a:	d4 01       	pushm	lr
8000be4c:	e0 69 04 1e 	mov	r9,1054
8000be50:	f6 08 12 00 	clz	r8,r11
8000be54:	c1 70       	breq	8000be82 <__avr32_s32_to_f64+0x40>
8000be56:	c0 c3       	brcs	8000be6e <__avr32_s32_to_f64+0x2c>
8000be58:	f0 0e 11 20 	rsub	lr,r8,32
8000be5c:	f6 08 09 4b 	lsl	r11,r11,r8
8000be60:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be64:	1c 4b       	or	r11,lr
8000be66:	f4 08 09 4a 	lsl	r10,r10,r8
8000be6a:	10 19       	sub	r9,r8
8000be6c:	c0 b8       	rjmp	8000be82 <__avr32_s32_to_f64+0x40>
8000be6e:	f4 08 12 00 	clz	r8,r10
8000be72:	f9 b8 03 00 	movlo	r8,0
8000be76:	f7 b8 02 e0 	subhs	r8,-32
8000be7a:	f4 08 09 4b 	lsl	r11,r10,r8
8000be7e:	30 0a       	mov	r10,0
8000be80:	10 19       	sub	r9,r8
8000be82:	58 09       	cp.w	r9,0
8000be84:	e0 89 00 30 	brgt	8000bee4 <__avr32_s32_to_f64+0xa2>
8000be88:	5c 39       	neg	r9
8000be8a:	2f f9       	sub	r9,-1
8000be8c:	e0 49 00 36 	cp.w	r9,54
8000be90:	c0 43       	brcs	8000be98 <__avr32_s32_to_f64+0x56>
8000be92:	30 0b       	mov	r11,0
8000be94:	30 0a       	mov	r10,0
8000be96:	c2 68       	rjmp	8000bee2 <__avr32_s32_to_f64+0xa0>
8000be98:	2f 69       	sub	r9,-10
8000be9a:	f2 08 11 20 	rsub	r8,r9,32
8000be9e:	e0 49 00 20 	cp.w	r9,32
8000bea2:	c0 b2       	brcc	8000beb8 <__avr32_s32_to_f64+0x76>
8000bea4:	f4 08 09 4e 	lsl	lr,r10,r8
8000bea8:	f6 08 09 48 	lsl	r8,r11,r8
8000beac:	f4 09 0a 4a 	lsr	r10,r10,r9
8000beb0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000beb4:	10 4b       	or	r11,r8
8000beb6:	c0 88       	rjmp	8000bec6 <__avr32_s32_to_f64+0x84>
8000beb8:	f6 08 09 4e 	lsl	lr,r11,r8
8000bebc:	14 4e       	or	lr,r10
8000bebe:	16 9a       	mov	r10,r11
8000bec0:	30 0b       	mov	r11,0
8000bec2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bec6:	ed ba 00 00 	bld	r10,0x0
8000beca:	c0 92       	brcc	8000bedc <__avr32_s32_to_f64+0x9a>
8000becc:	1c 7e       	tst	lr,lr
8000bece:	c0 41       	brne	8000bed6 <__avr32_s32_to_f64+0x94>
8000bed0:	ed ba 00 01 	bld	r10,0x1
8000bed4:	c0 42       	brcc	8000bedc <__avr32_s32_to_f64+0x9a>
8000bed6:	2f fa       	sub	r10,-1
8000bed8:	f7 bb 02 ff 	subhs	r11,-1
8000bedc:	5c fc       	rol	r12
8000bede:	5d 0b       	ror	r11
8000bee0:	5d 0a       	ror	r10
8000bee2:	d8 02       	popm	pc
8000bee4:	e0 68 03 ff 	mov	r8,1023
8000bee8:	ed ba 00 0b 	bld	r10,0xb
8000beec:	f7 b8 00 ff 	subeq	r8,-1
8000bef0:	10 0a       	add	r10,r8
8000bef2:	5c 0b       	acr	r11
8000bef4:	f7 b9 03 fe 	sublo	r9,-2
8000bef8:	e0 49 07 ff 	cp.w	r9,2047
8000befc:	c0 55       	brlt	8000bf06 <__avr32_s32_to_f64+0xc4>
8000befe:	30 0a       	mov	r10,0
8000bf00:	fc 1b ff e0 	movh	r11,0xffe0
8000bf04:	c0 c8       	rjmp	8000bf1c <__floatsidf_return_op1>
8000bf06:	ed bb 00 1f 	bld	r11,0x1f
8000bf0a:	f7 b9 01 01 	subne	r9,1
8000bf0e:	ab 9a       	lsr	r10,0xb
8000bf10:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf14:	a1 7b       	lsl	r11,0x1
8000bf16:	ab 9b       	lsr	r11,0xb
8000bf18:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bf1c <__floatsidf_return_op1>:
8000bf1c:	a1 7c       	lsl	r12,0x1
8000bf1e:	5d 0b       	ror	r11
8000bf20:	d8 02       	popm	pc

8000bf22 <__avr32_f64_cmp_eq>:
8000bf22:	10 3a       	cp.w	r10,r8
8000bf24:	f2 0b 13 00 	cpc	r11,r9
8000bf28:	c0 80       	breq	8000bf38 <__avr32_f64_cmp_eq+0x16>
8000bf2a:	a1 7b       	lsl	r11,0x1
8000bf2c:	a1 79       	lsl	r9,0x1
8000bf2e:	14 4b       	or	r11,r10
8000bf30:	12 4b       	or	r11,r9
8000bf32:	10 4b       	or	r11,r8
8000bf34:	5e 0f       	reteq	1
8000bf36:	5e fd       	retal	0
8000bf38:	a1 7b       	lsl	r11,0x1
8000bf3a:	fc 1c ff e0 	movh	r12,0xffe0
8000bf3e:	58 0a       	cp.w	r10,0
8000bf40:	f8 0b 13 00 	cpc	r11,r12
8000bf44:	5e 8f       	retls	1
8000bf46:	5e fd       	retal	0

8000bf48 <__avr32_f64_cmp_ge>:
8000bf48:	1a de       	st.w	--sp,lr
8000bf4a:	1a d7       	st.w	--sp,r7
8000bf4c:	a1 7b       	lsl	r11,0x1
8000bf4e:	5f 3c       	srlo	r12
8000bf50:	a1 79       	lsl	r9,0x1
8000bf52:	5f 37       	srlo	r7
8000bf54:	5c fc       	rol	r12
8000bf56:	fc 1e ff e0 	movh	lr,0xffe0
8000bf5a:	58 0a       	cp.w	r10,0
8000bf5c:	fc 0b 13 00 	cpc	r11,lr
8000bf60:	e0 8b 00 1d 	brhi	8000bf9a <__avr32_f64_cmp_ge+0x52>
8000bf64:	58 08       	cp.w	r8,0
8000bf66:	fc 09 13 00 	cpc	r9,lr
8000bf6a:	e0 8b 00 18 	brhi	8000bf9a <__avr32_f64_cmp_ge+0x52>
8000bf6e:	58 0b       	cp.w	r11,0
8000bf70:	f5 ba 00 00 	subfeq	r10,0
8000bf74:	c1 50       	breq	8000bf9e <__avr32_f64_cmp_ge+0x56>
8000bf76:	1b 07       	ld.w	r7,sp++
8000bf78:	1b 0e       	ld.w	lr,sp++
8000bf7a:	58 3c       	cp.w	r12,3
8000bf7c:	c0 a0       	breq	8000bf90 <__avr32_f64_cmp_ge+0x48>
8000bf7e:	58 1c       	cp.w	r12,1
8000bf80:	c0 33       	brcs	8000bf86 <__avr32_f64_cmp_ge+0x3e>
8000bf82:	5e 0f       	reteq	1
8000bf84:	5e 1d       	retne	0
8000bf86:	10 3a       	cp.w	r10,r8
8000bf88:	f2 0b 13 00 	cpc	r11,r9
8000bf8c:	5e 2f       	reths	1
8000bf8e:	5e 3d       	retlo	0
8000bf90:	14 38       	cp.w	r8,r10
8000bf92:	f6 09 13 00 	cpc	r9,r11
8000bf96:	5e 2f       	reths	1
8000bf98:	5e 3d       	retlo	0
8000bf9a:	1b 07       	ld.w	r7,sp++
8000bf9c:	d8 0a       	popm	pc,r12=0
8000bf9e:	58 17       	cp.w	r7,1
8000bfa0:	5f 0c       	sreq	r12
8000bfa2:	58 09       	cp.w	r9,0
8000bfa4:	f5 b8 00 00 	subfeq	r8,0
8000bfa8:	1b 07       	ld.w	r7,sp++
8000bfaa:	1b 0e       	ld.w	lr,sp++
8000bfac:	5e 0f       	reteq	1
8000bfae:	5e fc       	retal	r12

8000bfb0 <__avr32_f64_cmp_lt>:
8000bfb0:	1a de       	st.w	--sp,lr
8000bfb2:	1a d7       	st.w	--sp,r7
8000bfb4:	a1 7b       	lsl	r11,0x1
8000bfb6:	5f 3c       	srlo	r12
8000bfb8:	a1 79       	lsl	r9,0x1
8000bfba:	5f 37       	srlo	r7
8000bfbc:	5c fc       	rol	r12
8000bfbe:	fc 1e ff e0 	movh	lr,0xffe0
8000bfc2:	58 0a       	cp.w	r10,0
8000bfc4:	fc 0b 13 00 	cpc	r11,lr
8000bfc8:	e0 8b 00 1d 	brhi	8000c002 <__avr32_f64_cmp_lt+0x52>
8000bfcc:	58 08       	cp.w	r8,0
8000bfce:	fc 09 13 00 	cpc	r9,lr
8000bfd2:	e0 8b 00 18 	brhi	8000c002 <__avr32_f64_cmp_lt+0x52>
8000bfd6:	58 0b       	cp.w	r11,0
8000bfd8:	f5 ba 00 00 	subfeq	r10,0
8000bfdc:	c1 50       	breq	8000c006 <__avr32_f64_cmp_lt+0x56>
8000bfde:	1b 07       	ld.w	r7,sp++
8000bfe0:	1b 0e       	ld.w	lr,sp++
8000bfe2:	58 3c       	cp.w	r12,3
8000bfe4:	c0 a0       	breq	8000bff8 <__avr32_f64_cmp_lt+0x48>
8000bfe6:	58 1c       	cp.w	r12,1
8000bfe8:	c0 33       	brcs	8000bfee <__avr32_f64_cmp_lt+0x3e>
8000bfea:	5e 0d       	reteq	0
8000bfec:	5e 1f       	retne	1
8000bfee:	10 3a       	cp.w	r10,r8
8000bff0:	f2 0b 13 00 	cpc	r11,r9
8000bff4:	5e 2d       	reths	0
8000bff6:	5e 3f       	retlo	1
8000bff8:	14 38       	cp.w	r8,r10
8000bffa:	f6 09 13 00 	cpc	r9,r11
8000bffe:	5e 2d       	reths	0
8000c000:	5e 3f       	retlo	1
8000c002:	1b 07       	ld.w	r7,sp++
8000c004:	d8 0a       	popm	pc,r12=0
8000c006:	58 17       	cp.w	r7,1
8000c008:	5f 1c       	srne	r12
8000c00a:	58 09       	cp.w	r9,0
8000c00c:	f5 b8 00 00 	subfeq	r8,0
8000c010:	1b 07       	ld.w	r7,sp++
8000c012:	1b 0e       	ld.w	lr,sp++
8000c014:	5e 0d       	reteq	0
8000c016:	5e fc       	retal	r12

8000c018 <__avr32_f64_div>:
8000c018:	eb cd 40 ff 	pushm	r0-r7,lr
8000c01c:	f7 e9 20 0e 	eor	lr,r11,r9
8000c020:	f6 07 16 14 	lsr	r7,r11,0x14
8000c024:	a9 7b       	lsl	r11,0x9
8000c026:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c02a:	a9 7a       	lsl	r10,0x9
8000c02c:	bd bb       	sbr	r11,0x1d
8000c02e:	e4 1b 3f ff 	andh	r11,0x3fff
8000c032:	ab d7       	cbr	r7,0xb
8000c034:	e0 80 00 cc 	breq	8000c1cc <__avr32_f64_div_round_subnormal+0x54>
8000c038:	e0 47 07 ff 	cp.w	r7,2047
8000c03c:	e0 84 00 b5 	brge	8000c1a6 <__avr32_f64_div_round_subnormal+0x2e>
8000c040:	f2 06 16 14 	lsr	r6,r9,0x14
8000c044:	a9 79       	lsl	r9,0x9
8000c046:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c04a:	a9 78       	lsl	r8,0x9
8000c04c:	bd b9       	sbr	r9,0x1d
8000c04e:	e4 19 3f ff 	andh	r9,0x3fff
8000c052:	ab d6       	cbr	r6,0xb
8000c054:	e0 80 00 e2 	breq	8000c218 <__avr32_f64_div_round_subnormal+0xa0>
8000c058:	e0 46 07 ff 	cp.w	r6,2047
8000c05c:	e0 84 00 b2 	brge	8000c1c0 <__avr32_f64_div_round_subnormal+0x48>
8000c060:	0c 17       	sub	r7,r6
8000c062:	fe 37 fc 01 	sub	r7,-1023
8000c066:	fc 1c 80 00 	movh	r12,0x8000
8000c06a:	f8 03 16 01 	lsr	r3,r12,0x1
8000c06e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c072:	5c d4       	com	r4
8000c074:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c078:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c07c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c080:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c084:	ea 03 15 02 	lsl	r3,r5,0x2
8000c088:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c08c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c090:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c094:	ea 03 15 02 	lsl	r3,r5,0x2
8000c098:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c09c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0a4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0a8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0ac:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0b0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0b4:	02 04       	add	r4,r1
8000c0b6:	5c 05       	acr	r5
8000c0b8:	a3 65       	lsl	r5,0x2
8000c0ba:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c0be:	a3 64       	lsl	r4,0x2
8000c0c0:	5c 34       	neg	r4
8000c0c2:	f8 05 01 45 	sbc	r5,r12,r5
8000c0c6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c0ca:	e4 05 07 40 	macu.d	r0,r2,r5
8000c0ce:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0d2:	02 04       	add	r4,r1
8000c0d4:	5c 05       	acr	r5
8000c0d6:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0da:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c0de:	e8 02 15 02 	lsl	r2,r4,0x2
8000c0e2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0e6:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0ea:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0ee:	02 04       	add	r4,r1
8000c0f0:	5c 05       	acr	r5
8000c0f2:	a3 65       	lsl	r5,0x2
8000c0f4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c0f8:	a3 64       	lsl	r4,0x2
8000c0fa:	5c 34       	neg	r4
8000c0fc:	f8 05 01 45 	sbc	r5,r12,r5
8000c100:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c104:	e4 05 07 40 	macu.d	r0,r2,r5
8000c108:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c10c:	02 04       	add	r4,r1
8000c10e:	5c 05       	acr	r5
8000c110:	ea 03 15 02 	lsl	r3,r5,0x2
8000c114:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c118:	e8 02 15 02 	lsl	r2,r4,0x2
8000c11c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c120:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c124:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c128:	02 02       	add	r2,r1
8000c12a:	5c 03       	acr	r3
8000c12c:	ed b3 00 1c 	bld	r3,0x1c
8000c130:	c0 90       	breq	8000c142 <__avr32_f64_div+0x12a>
8000c132:	a1 72       	lsl	r2,0x1
8000c134:	5c f3       	rol	r3
8000c136:	20 17       	sub	r7,1
8000c138:	a3 9a       	lsr	r10,0x3
8000c13a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c13e:	a3 9b       	lsr	r11,0x3
8000c140:	c0 58       	rjmp	8000c14a <__avr32_f64_div+0x132>
8000c142:	a5 8a       	lsr	r10,0x4
8000c144:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c148:	a5 8b       	lsr	r11,0x4
8000c14a:	58 07       	cp.w	r7,0
8000c14c:	e0 8a 00 8b 	brle	8000c262 <__avr32_f64_div_res_subnormal>
8000c150:	e0 12 ff 00 	andl	r2,0xff00
8000c154:	e8 12 00 80 	orl	r2,0x80
8000c158:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c15c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c160:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c164:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c168:	00 05       	add	r5,r0
8000c16a:	f0 01 00 48 	adc	r8,r8,r1
8000c16e:	5c 09       	acr	r9
8000c170:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c174:	58 04       	cp.w	r4,0
8000c176:	5c 25       	cpc	r5

8000c178 <__avr32_f64_div_round_subnormal>:
8000c178:	f4 08 13 00 	cpc	r8,r10
8000c17c:	f6 09 13 00 	cpc	r9,r11
8000c180:	5f 36       	srlo	r6
8000c182:	f8 06 17 00 	moveq	r6,r12
8000c186:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c18a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c18e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c192:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c196:	ed be 00 1f 	bld	lr,0x1f
8000c19a:	ef bb 00 1f 	bst	r11,0x1f
8000c19e:	0c 0a       	add	r10,r6
8000c1a0:	5c 0b       	acr	r11
8000c1a2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c1a6:	e4 1b 00 0f 	andh	r11,0xf
8000c1aa:	14 4b       	or	r11,r10
8000c1ac:	e0 81 00 a7 	brne	8000c2fa <__avr32_f64_div_res_subnormal+0x98>
8000c1b0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c1b4:	ab d6       	cbr	r6,0xb
8000c1b6:	e0 46 07 ff 	cp.w	r6,2047
8000c1ba:	e0 81 00 a4 	brne	8000c302 <__avr32_f64_div_res_subnormal+0xa0>
8000c1be:	c9 e8       	rjmp	8000c2fa <__avr32_f64_div_res_subnormal+0x98>
8000c1c0:	e4 19 00 0f 	andh	r9,0xf
8000c1c4:	10 49       	or	r9,r8
8000c1c6:	e0 81 00 9a 	brne	8000c2fa <__avr32_f64_div_res_subnormal+0x98>
8000c1ca:	c9 28       	rjmp	8000c2ee <__avr32_f64_div_res_subnormal+0x8c>
8000c1cc:	a3 7b       	lsl	r11,0x3
8000c1ce:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c1d2:	a3 7a       	lsl	r10,0x3
8000c1d4:	f5 eb 10 04 	or	r4,r10,r11
8000c1d8:	e0 80 00 a0 	breq	8000c318 <__avr32_f64_div_op1_zero>
8000c1dc:	f6 04 12 00 	clz	r4,r11
8000c1e0:	c1 70       	breq	8000c20e <__avr32_f64_div_round_subnormal+0x96>
8000c1e2:	c0 c3       	brcs	8000c1fa <__avr32_f64_div_round_subnormal+0x82>
8000c1e4:	e8 05 11 20 	rsub	r5,r4,32
8000c1e8:	f6 04 09 4b 	lsl	r11,r11,r4
8000c1ec:	f4 05 0a 45 	lsr	r5,r10,r5
8000c1f0:	0a 4b       	or	r11,r5
8000c1f2:	f4 04 09 4a 	lsl	r10,r10,r4
8000c1f6:	08 17       	sub	r7,r4
8000c1f8:	c0 b8       	rjmp	8000c20e <__avr32_f64_div_round_subnormal+0x96>
8000c1fa:	f4 04 12 00 	clz	r4,r10
8000c1fe:	f9 b4 03 00 	movlo	r4,0
8000c202:	f7 b4 02 e0 	subhs	r4,-32
8000c206:	f4 04 09 4b 	lsl	r11,r10,r4
8000c20a:	30 0a       	mov	r10,0
8000c20c:	08 17       	sub	r7,r4
8000c20e:	a3 8a       	lsr	r10,0x2
8000c210:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c214:	a3 8b       	lsr	r11,0x2
8000c216:	c1 1b       	rjmp	8000c038 <__avr32_f64_div+0x20>
8000c218:	a3 79       	lsl	r9,0x3
8000c21a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c21e:	a3 78       	lsl	r8,0x3
8000c220:	f3 e8 10 04 	or	r4,r9,r8
8000c224:	c6 f0       	breq	8000c302 <__avr32_f64_div_res_subnormal+0xa0>
8000c226:	f2 04 12 00 	clz	r4,r9
8000c22a:	c1 70       	breq	8000c258 <__avr32_f64_div_round_subnormal+0xe0>
8000c22c:	c0 c3       	brcs	8000c244 <__avr32_f64_div_round_subnormal+0xcc>
8000c22e:	e8 05 11 20 	rsub	r5,r4,32
8000c232:	f2 04 09 49 	lsl	r9,r9,r4
8000c236:	f0 05 0a 45 	lsr	r5,r8,r5
8000c23a:	0a 49       	or	r9,r5
8000c23c:	f0 04 09 48 	lsl	r8,r8,r4
8000c240:	08 16       	sub	r6,r4
8000c242:	c0 b8       	rjmp	8000c258 <__avr32_f64_div_round_subnormal+0xe0>
8000c244:	f0 04 12 00 	clz	r4,r8
8000c248:	f9 b4 03 00 	movlo	r4,0
8000c24c:	f7 b4 02 e0 	subhs	r4,-32
8000c250:	f0 04 09 49 	lsl	r9,r8,r4
8000c254:	30 08       	mov	r8,0
8000c256:	08 16       	sub	r6,r4
8000c258:	a3 88       	lsr	r8,0x2
8000c25a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c25e:	a3 89       	lsr	r9,0x2
8000c260:	cf ca       	rjmp	8000c058 <__avr32_f64_div+0x40>

8000c262 <__avr32_f64_div_res_subnormal>:
8000c262:	5c 37       	neg	r7
8000c264:	2f f7       	sub	r7,-1
8000c266:	f1 b7 04 c0 	satu	r7,0x6
8000c26a:	e0 47 00 20 	cp.w	r7,32
8000c26e:	c1 54       	brge	8000c298 <__avr32_f64_div_res_subnormal+0x36>
8000c270:	ee 06 11 20 	rsub	r6,r7,32
8000c274:	e4 07 0a 42 	lsr	r2,r2,r7
8000c278:	e6 06 09 4c 	lsl	r12,r3,r6
8000c27c:	18 42       	or	r2,r12
8000c27e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c282:	f4 06 09 41 	lsl	r1,r10,r6
8000c286:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c28a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c28e:	18 4a       	or	r10,r12
8000c290:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c294:	30 00       	mov	r0,0
8000c296:	c1 58       	rjmp	8000c2c0 <__avr32_f64_div_res_subnormal+0x5e>
8000c298:	ee 06 11 20 	rsub	r6,r7,32
8000c29c:	f9 b0 00 00 	moveq	r0,0
8000c2a0:	f9 bc 00 00 	moveq	r12,0
8000c2a4:	c0 50       	breq	8000c2ae <__avr32_f64_div_res_subnormal+0x4c>
8000c2a6:	f4 06 09 40 	lsl	r0,r10,r6
8000c2aa:	f6 06 09 4c 	lsl	r12,r11,r6
8000c2ae:	e6 07 0a 42 	lsr	r2,r3,r7
8000c2b2:	30 03       	mov	r3,0
8000c2b4:	f4 07 0a 41 	lsr	r1,r10,r7
8000c2b8:	18 41       	or	r1,r12
8000c2ba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c2be:	30 0b       	mov	r11,0
8000c2c0:	e0 12 ff 00 	andl	r2,0xff00
8000c2c4:	e8 12 00 80 	orl	r2,0x80
8000c2c8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c2cc:	e4 09 07 46 	macu.d	r6,r2,r9
8000c2d0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c2d4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c2d8:	0c 05       	add	r5,r6
8000c2da:	f0 07 00 48 	adc	r8,r8,r7
8000c2de:	5c 09       	acr	r9
8000c2e0:	30 07       	mov	r7,0
8000c2e2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c2e6:	00 34       	cp.w	r4,r0
8000c2e8:	e2 05 13 00 	cpc	r5,r1
8000c2ec:	c4 6b       	rjmp	8000c178 <__avr32_f64_div_round_subnormal>
8000c2ee:	1c 9b       	mov	r11,lr
8000c2f0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c2f4:	30 0a       	mov	r10,0
8000c2f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c2fa:	3f fb       	mov	r11,-1
8000c2fc:	30 0a       	mov	r10,0
8000c2fe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c302:	f5 eb 10 04 	or	r4,r10,r11
8000c306:	c0 90       	breq	8000c318 <__avr32_f64_div_op1_zero>
8000c308:	1c 9b       	mov	r11,lr
8000c30a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c30e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c312:	30 0a       	mov	r10,0
8000c314:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c318 <__avr32_f64_div_op1_zero>:
8000c318:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c31c:	ce f0       	breq	8000c2fa <__avr32_f64_div_res_subnormal+0x98>
8000c31e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c322:	e0 44 07 ff 	cp.w	r4,2047
8000c326:	ce 41       	brne	8000c2ee <__avr32_f64_div_res_subnormal+0x8c>
8000c328:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c32c:	ce 10       	breq	8000c2ee <__avr32_f64_div_res_subnormal+0x8c>
8000c32e:	ce 6b       	rjmp	8000c2fa <__avr32_f64_div_res_subnormal+0x98>

8000c330 <__avr32_udiv64>:
8000c330:	d4 31       	pushm	r0-r7,lr
8000c332:	1a 97       	mov	r7,sp
8000c334:	20 3d       	sub	sp,12
8000c336:	10 9c       	mov	r12,r8
8000c338:	12 9e       	mov	lr,r9
8000c33a:	14 93       	mov	r3,r10
8000c33c:	58 09       	cp.w	r9,0
8000c33e:	e0 81 00 bd 	brne	8000c4b8 <__avr32_udiv64+0x188>
8000c342:	16 38       	cp.w	r8,r11
8000c344:	e0 88 00 40 	brls	8000c3c4 <__avr32_udiv64+0x94>
8000c348:	f0 08 12 00 	clz	r8,r8
8000c34c:	c0 d0       	breq	8000c366 <__avr32_udiv64+0x36>
8000c34e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c352:	f0 09 11 20 	rsub	r9,r8,32
8000c356:	f8 08 09 4c 	lsl	r12,r12,r8
8000c35a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c35e:	f4 08 09 43 	lsl	r3,r10,r8
8000c362:	f3 eb 10 0b 	or	r11,r9,r11
8000c366:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c36a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c36e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c372:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c376:	00 99       	mov	r9,r0
8000c378:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c37c:	e0 0a 02 48 	mul	r8,r0,r10
8000c380:	10 3b       	cp.w	r11,r8
8000c382:	c0 a2       	brcc	8000c396 <__avr32_udiv64+0x66>
8000c384:	20 19       	sub	r9,1
8000c386:	18 0b       	add	r11,r12
8000c388:	18 3b       	cp.w	r11,r12
8000c38a:	c0 63       	brcs	8000c396 <__avr32_udiv64+0x66>
8000c38c:	10 3b       	cp.w	r11,r8
8000c38e:	f7 b9 03 01 	sublo	r9,1
8000c392:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c396:	f6 08 01 01 	sub	r1,r11,r8
8000c39a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c39e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c3a2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c3a6:	00 98       	mov	r8,r0
8000c3a8:	e0 0a 02 4a 	mul	r10,r0,r10
8000c3ac:	14 33       	cp.w	r3,r10
8000c3ae:	c0 82       	brcc	8000c3be <__avr32_udiv64+0x8e>
8000c3b0:	20 18       	sub	r8,1
8000c3b2:	18 03       	add	r3,r12
8000c3b4:	18 33       	cp.w	r3,r12
8000c3b6:	c0 43       	brcs	8000c3be <__avr32_udiv64+0x8e>
8000c3b8:	14 33       	cp.w	r3,r10
8000c3ba:	f7 b8 03 01 	sublo	r8,1
8000c3be:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c3c2:	cd f8       	rjmp	8000c580 <__avr32_udiv64+0x250>
8000c3c4:	58 08       	cp.w	r8,0
8000c3c6:	c0 51       	brne	8000c3d0 <__avr32_udiv64+0xa0>
8000c3c8:	30 19       	mov	r9,1
8000c3ca:	f2 08 0d 08 	divu	r8,r9,r8
8000c3ce:	10 9c       	mov	r12,r8
8000c3d0:	f8 06 12 00 	clz	r6,r12
8000c3d4:	c0 41       	brne	8000c3dc <__avr32_udiv64+0xac>
8000c3d6:	18 1b       	sub	r11,r12
8000c3d8:	30 19       	mov	r9,1
8000c3da:	c4 08       	rjmp	8000c45a <__avr32_udiv64+0x12a>
8000c3dc:	ec 01 11 20 	rsub	r1,r6,32
8000c3e0:	f4 01 0a 49 	lsr	r9,r10,r1
8000c3e4:	f8 06 09 4c 	lsl	r12,r12,r6
8000c3e8:	f6 06 09 48 	lsl	r8,r11,r6
8000c3ec:	f6 01 0a 41 	lsr	r1,r11,r1
8000c3f0:	f3 e8 10 08 	or	r8,r9,r8
8000c3f4:	f8 03 16 10 	lsr	r3,r12,0x10
8000c3f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c3fc:	e2 03 0d 00 	divu	r0,r1,r3
8000c400:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c404:	00 9e       	mov	lr,r0
8000c406:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c40a:	e0 05 02 49 	mul	r9,r0,r5
8000c40e:	12 3b       	cp.w	r11,r9
8000c410:	c0 a2       	brcc	8000c424 <__avr32_udiv64+0xf4>
8000c412:	20 1e       	sub	lr,1
8000c414:	18 0b       	add	r11,r12
8000c416:	18 3b       	cp.w	r11,r12
8000c418:	c0 63       	brcs	8000c424 <__avr32_udiv64+0xf4>
8000c41a:	12 3b       	cp.w	r11,r9
8000c41c:	f7 be 03 01 	sublo	lr,1
8000c420:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c424:	12 1b       	sub	r11,r9
8000c426:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c42a:	f6 03 0d 02 	divu	r2,r11,r3
8000c42e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c432:	04 99       	mov	r9,r2
8000c434:	e4 05 02 4b 	mul	r11,r2,r5
8000c438:	16 38       	cp.w	r8,r11
8000c43a:	c0 a2       	brcc	8000c44e <__avr32_udiv64+0x11e>
8000c43c:	20 19       	sub	r9,1
8000c43e:	18 08       	add	r8,r12
8000c440:	18 38       	cp.w	r8,r12
8000c442:	c0 63       	brcs	8000c44e <__avr32_udiv64+0x11e>
8000c444:	16 38       	cp.w	r8,r11
8000c446:	f7 b9 03 01 	sublo	r9,1
8000c44a:	f1 dc e3 08 	addcs	r8,r8,r12
8000c44e:	f4 06 09 43 	lsl	r3,r10,r6
8000c452:	f0 0b 01 0b 	sub	r11,r8,r11
8000c456:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c45a:	f8 06 16 10 	lsr	r6,r12,0x10
8000c45e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c462:	f6 06 0d 00 	divu	r0,r11,r6
8000c466:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c46a:	00 9a       	mov	r10,r0
8000c46c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c470:	e0 0e 02 48 	mul	r8,r0,lr
8000c474:	10 3b       	cp.w	r11,r8
8000c476:	c0 a2       	brcc	8000c48a <__avr32_udiv64+0x15a>
8000c478:	20 1a       	sub	r10,1
8000c47a:	18 0b       	add	r11,r12
8000c47c:	18 3b       	cp.w	r11,r12
8000c47e:	c0 63       	brcs	8000c48a <__avr32_udiv64+0x15a>
8000c480:	10 3b       	cp.w	r11,r8
8000c482:	f7 ba 03 01 	sublo	r10,1
8000c486:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c48a:	f6 08 01 01 	sub	r1,r11,r8
8000c48e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c492:	e2 06 0d 00 	divu	r0,r1,r6
8000c496:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c49a:	00 98       	mov	r8,r0
8000c49c:	e0 0e 02 4b 	mul	r11,r0,lr
8000c4a0:	16 33       	cp.w	r3,r11
8000c4a2:	c0 82       	brcc	8000c4b2 <__avr32_udiv64+0x182>
8000c4a4:	20 18       	sub	r8,1
8000c4a6:	18 03       	add	r3,r12
8000c4a8:	18 33       	cp.w	r3,r12
8000c4aa:	c0 43       	brcs	8000c4b2 <__avr32_udiv64+0x182>
8000c4ac:	16 33       	cp.w	r3,r11
8000c4ae:	f7 b8 03 01 	sublo	r8,1
8000c4b2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c4b6:	c6 98       	rjmp	8000c588 <__avr32_udiv64+0x258>
8000c4b8:	16 39       	cp.w	r9,r11
8000c4ba:	e0 8b 00 65 	brhi	8000c584 <__avr32_udiv64+0x254>
8000c4be:	f2 09 12 00 	clz	r9,r9
8000c4c2:	c0 b1       	brne	8000c4d8 <__avr32_udiv64+0x1a8>
8000c4c4:	10 3a       	cp.w	r10,r8
8000c4c6:	5f 2a       	srhs	r10
8000c4c8:	1c 3b       	cp.w	r11,lr
8000c4ca:	5f b8       	srhi	r8
8000c4cc:	10 4a       	or	r10,r8
8000c4ce:	f2 0a 18 00 	cp.b	r10,r9
8000c4d2:	c5 90       	breq	8000c584 <__avr32_udiv64+0x254>
8000c4d4:	30 18       	mov	r8,1
8000c4d6:	c5 98       	rjmp	8000c588 <__avr32_udiv64+0x258>
8000c4d8:	f0 09 09 46 	lsl	r6,r8,r9
8000c4dc:	f2 03 11 20 	rsub	r3,r9,32
8000c4e0:	fc 09 09 4e 	lsl	lr,lr,r9
8000c4e4:	f0 03 0a 48 	lsr	r8,r8,r3
8000c4e8:	f6 09 09 4c 	lsl	r12,r11,r9
8000c4ec:	f4 03 0a 42 	lsr	r2,r10,r3
8000c4f0:	ef 46 ff f4 	st.w	r7[-12],r6
8000c4f4:	f6 03 0a 43 	lsr	r3,r11,r3
8000c4f8:	18 42       	or	r2,r12
8000c4fa:	f1 ee 10 0c 	or	r12,r8,lr
8000c4fe:	f8 01 16 10 	lsr	r1,r12,0x10
8000c502:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c506:	e6 01 0d 04 	divu	r4,r3,r1
8000c50a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c50e:	08 9e       	mov	lr,r4
8000c510:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c514:	e8 06 02 48 	mul	r8,r4,r6
8000c518:	10 33       	cp.w	r3,r8
8000c51a:	c0 a2       	brcc	8000c52e <__avr32_udiv64+0x1fe>
8000c51c:	20 1e       	sub	lr,1
8000c51e:	18 03       	add	r3,r12
8000c520:	18 33       	cp.w	r3,r12
8000c522:	c0 63       	brcs	8000c52e <__avr32_udiv64+0x1fe>
8000c524:	10 33       	cp.w	r3,r8
8000c526:	f7 be 03 01 	sublo	lr,1
8000c52a:	e7 dc e3 03 	addcs	r3,r3,r12
8000c52e:	10 13       	sub	r3,r8
8000c530:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c534:	e6 01 0d 00 	divu	r0,r3,r1
8000c538:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c53c:	00 98       	mov	r8,r0
8000c53e:	e0 06 02 46 	mul	r6,r0,r6
8000c542:	0c 3b       	cp.w	r11,r6
8000c544:	c0 a2       	brcc	8000c558 <__avr32_udiv64+0x228>
8000c546:	20 18       	sub	r8,1
8000c548:	18 0b       	add	r11,r12
8000c54a:	18 3b       	cp.w	r11,r12
8000c54c:	c0 63       	brcs	8000c558 <__avr32_udiv64+0x228>
8000c54e:	0c 3b       	cp.w	r11,r6
8000c550:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c554:	f7 b8 03 01 	sublo	r8,1
8000c558:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c55c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c560:	0c 1b       	sub	r11,r6
8000c562:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c566:	06 95       	mov	r5,r3
8000c568:	16 35       	cp.w	r5,r11
8000c56a:	e0 8b 00 0a 	brhi	8000c57e <__avr32_udiv64+0x24e>
8000c56e:	5f 0b       	sreq	r11
8000c570:	f4 09 09 49 	lsl	r9,r10,r9
8000c574:	12 32       	cp.w	r2,r9
8000c576:	5f b9       	srhi	r9
8000c578:	f7 e9 00 09 	and	r9,r11,r9
8000c57c:	c0 60       	breq	8000c588 <__avr32_udiv64+0x258>
8000c57e:	20 18       	sub	r8,1
8000c580:	30 09       	mov	r9,0
8000c582:	c0 38       	rjmp	8000c588 <__avr32_udiv64+0x258>
8000c584:	30 09       	mov	r9,0
8000c586:	12 98       	mov	r8,r9
8000c588:	10 9a       	mov	r10,r8
8000c58a:	12 93       	mov	r3,r9
8000c58c:	10 92       	mov	r2,r8
8000c58e:	12 9b       	mov	r11,r9
8000c590:	2f dd       	sub	sp,-12
8000c592:	d8 32       	popm	r0-r7,pc

8000c594 <__avr32_umod64>:
8000c594:	d4 31       	pushm	r0-r7,lr
8000c596:	1a 97       	mov	r7,sp
8000c598:	20 3d       	sub	sp,12
8000c59a:	10 9c       	mov	r12,r8
8000c59c:	12 95       	mov	r5,r9
8000c59e:	14 9e       	mov	lr,r10
8000c5a0:	16 91       	mov	r1,r11
8000c5a2:	16 96       	mov	r6,r11
8000c5a4:	58 09       	cp.w	r9,0
8000c5a6:	e0 81 00 81 	brne	8000c6a8 <__avr32_umod64+0x114>
8000c5aa:	16 38       	cp.w	r8,r11
8000c5ac:	e0 88 00 12 	brls	8000c5d0 <__avr32_umod64+0x3c>
8000c5b0:	f0 08 12 00 	clz	r8,r8
8000c5b4:	c4 e0       	breq	8000c650 <__avr32_umod64+0xbc>
8000c5b6:	f6 08 09 46 	lsl	r6,r11,r8
8000c5ba:	f8 08 09 4c 	lsl	r12,r12,r8
8000c5be:	f0 0b 11 20 	rsub	r11,r8,32
8000c5c2:	f4 08 09 4e 	lsl	lr,r10,r8
8000c5c6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c5ca:	f7 e6 10 06 	or	r6,r11,r6
8000c5ce:	c4 18       	rjmp	8000c650 <__avr32_umod64+0xbc>
8000c5d0:	58 08       	cp.w	r8,0
8000c5d2:	c0 51       	brne	8000c5dc <__avr32_umod64+0x48>
8000c5d4:	30 19       	mov	r9,1
8000c5d6:	f2 08 0d 08 	divu	r8,r9,r8
8000c5da:	10 9c       	mov	r12,r8
8000c5dc:	f8 08 12 00 	clz	r8,r12
8000c5e0:	c0 31       	brne	8000c5e6 <__avr32_umod64+0x52>
8000c5e2:	18 16       	sub	r6,r12
8000c5e4:	c3 68       	rjmp	8000c650 <__avr32_umod64+0xbc>
8000c5e6:	f0 03 11 20 	rsub	r3,r8,32
8000c5ea:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c5ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000c5f2:	ec 08 09 49 	lsl	r9,r6,r8
8000c5f6:	ec 03 0a 43 	lsr	r3,r6,r3
8000c5fa:	f7 e9 10 09 	or	r9,r11,r9
8000c5fe:	f8 05 16 10 	lsr	r5,r12,0x10
8000c602:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c606:	e6 05 0d 02 	divu	r2,r3,r5
8000c60a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c60e:	ec 02 02 4b 	mul	r11,r6,r2
8000c612:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c616:	16 3e       	cp.w	lr,r11
8000c618:	c0 72       	brcc	8000c626 <__avr32_umod64+0x92>
8000c61a:	18 0e       	add	lr,r12
8000c61c:	18 3e       	cp.w	lr,r12
8000c61e:	c0 43       	brcs	8000c626 <__avr32_umod64+0x92>
8000c620:	16 3e       	cp.w	lr,r11
8000c622:	fd dc e3 0e 	addcs	lr,lr,r12
8000c626:	fc 0b 01 03 	sub	r3,lr,r11
8000c62a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c62e:	e6 05 0d 02 	divu	r2,r3,r5
8000c632:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c636:	a5 36       	mul	r6,r2
8000c638:	0c 39       	cp.w	r9,r6
8000c63a:	c0 72       	brcc	8000c648 <__avr32_umod64+0xb4>
8000c63c:	18 09       	add	r9,r12
8000c63e:	18 39       	cp.w	r9,r12
8000c640:	c0 43       	brcs	8000c648 <__avr32_umod64+0xb4>
8000c642:	0c 39       	cp.w	r9,r6
8000c644:	f3 dc e3 09 	addcs	r9,r9,r12
8000c648:	f2 06 01 06 	sub	r6,r9,r6
8000c64c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c650:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c654:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c658:	ec 0a 0d 02 	divu	r2,r6,r10
8000c65c:	fc 09 16 10 	lsr	r9,lr,0x10
8000c660:	ea 02 02 4b 	mul	r11,r5,r2
8000c664:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c668:	16 39       	cp.w	r9,r11
8000c66a:	c0 72       	brcc	8000c678 <__avr32_umod64+0xe4>
8000c66c:	18 09       	add	r9,r12
8000c66e:	18 39       	cp.w	r9,r12
8000c670:	c0 43       	brcs	8000c678 <__avr32_umod64+0xe4>
8000c672:	16 39       	cp.w	r9,r11
8000c674:	f3 dc e3 09 	addcs	r9,r9,r12
8000c678:	f2 0b 01 0b 	sub	r11,r9,r11
8000c67c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c680:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c684:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c688:	ea 0a 02 4a 	mul	r10,r5,r10
8000c68c:	14 3e       	cp.w	lr,r10
8000c68e:	c0 72       	brcc	8000c69c <__avr32_umod64+0x108>
8000c690:	18 0e       	add	lr,r12
8000c692:	18 3e       	cp.w	lr,r12
8000c694:	c0 43       	brcs	8000c69c <__avr32_umod64+0x108>
8000c696:	14 3e       	cp.w	lr,r10
8000c698:	fd dc e3 0e 	addcs	lr,lr,r12
8000c69c:	fc 0a 01 0a 	sub	r10,lr,r10
8000c6a0:	30 0b       	mov	r11,0
8000c6a2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c6a6:	c7 b8       	rjmp	8000c79c <__avr32_umod64+0x208>
8000c6a8:	16 39       	cp.w	r9,r11
8000c6aa:	e0 8b 00 79 	brhi	8000c79c <__avr32_umod64+0x208>
8000c6ae:	f2 09 12 00 	clz	r9,r9
8000c6b2:	c1 21       	brne	8000c6d6 <__avr32_umod64+0x142>
8000c6b4:	10 3a       	cp.w	r10,r8
8000c6b6:	5f 2b       	srhs	r11
8000c6b8:	0a 31       	cp.w	r1,r5
8000c6ba:	5f ba       	srhi	r10
8000c6bc:	f7 ea 10 0a 	or	r10,r11,r10
8000c6c0:	f2 0a 18 00 	cp.b	r10,r9
8000c6c4:	c0 60       	breq	8000c6d0 <__avr32_umod64+0x13c>
8000c6c6:	fc 08 01 0c 	sub	r12,lr,r8
8000c6ca:	e2 05 01 46 	sbc	r6,r1,r5
8000c6ce:	18 9e       	mov	lr,r12
8000c6d0:	0c 9b       	mov	r11,r6
8000c6d2:	1c 9a       	mov	r10,lr
8000c6d4:	c6 48       	rjmp	8000c79c <__avr32_umod64+0x208>
8000c6d6:	ea 09 09 4c 	lsl	r12,r5,r9
8000c6da:	f2 06 11 20 	rsub	r6,r9,32
8000c6de:	f6 09 09 4b 	lsl	r11,r11,r9
8000c6e2:	f0 09 09 42 	lsl	r2,r8,r9
8000c6e6:	ef 46 ff f4 	st.w	r7[-12],r6
8000c6ea:	f0 06 0a 48 	lsr	r8,r8,r6
8000c6ee:	18 48       	or	r8,r12
8000c6f0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c6f4:	f4 09 09 43 	lsl	r3,r10,r9
8000c6f8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c6fc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c700:	16 4a       	or	r10,r11
8000c702:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c706:	f8 0b 0d 04 	divu	r4,r12,r11
8000c70a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c70e:	08 91       	mov	r1,r4
8000c710:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c714:	e8 0e 02 46 	mul	r6,r4,lr
8000c718:	0c 3c       	cp.w	r12,r6
8000c71a:	c0 a2       	brcc	8000c72e <__avr32_umod64+0x19a>
8000c71c:	20 11       	sub	r1,1
8000c71e:	10 0c       	add	r12,r8
8000c720:	10 3c       	cp.w	r12,r8
8000c722:	c0 63       	brcs	8000c72e <__avr32_umod64+0x19a>
8000c724:	0c 3c       	cp.w	r12,r6
8000c726:	f7 b1 03 01 	sublo	r1,1
8000c72a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c72e:	0c 1c       	sub	r12,r6
8000c730:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c734:	f8 0b 0d 04 	divu	r4,r12,r11
8000c738:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c73c:	08 96       	mov	r6,r4
8000c73e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c742:	1c 3b       	cp.w	r11,lr
8000c744:	c0 a2       	brcc	8000c758 <__avr32_umod64+0x1c4>
8000c746:	20 16       	sub	r6,1
8000c748:	10 0b       	add	r11,r8
8000c74a:	10 3b       	cp.w	r11,r8
8000c74c:	c0 63       	brcs	8000c758 <__avr32_umod64+0x1c4>
8000c74e:	1c 3b       	cp.w	r11,lr
8000c750:	f7 b6 03 01 	sublo	r6,1
8000c754:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c758:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c75c:	1c 1b       	sub	r11,lr
8000c75e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c762:	00 9e       	mov	lr,r0
8000c764:	02 9c       	mov	r12,r1
8000c766:	16 3c       	cp.w	r12,r11
8000c768:	e0 8b 00 08 	brhi	8000c778 <__avr32_umod64+0x1e4>
8000c76c:	5f 06       	sreq	r6
8000c76e:	06 30       	cp.w	r0,r3
8000c770:	5f ba       	srhi	r10
8000c772:	ed ea 00 0a 	and	r10,r6,r10
8000c776:	c0 60       	breq	8000c782 <__avr32_umod64+0x1ee>
8000c778:	fc 02 01 04 	sub	r4,lr,r2
8000c77c:	f8 08 01 4c 	sbc	r12,r12,r8
8000c780:	08 9e       	mov	lr,r4
8000c782:	e6 0e 01 0a 	sub	r10,r3,lr
8000c786:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c78a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c78e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c792:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c796:	f8 01 09 4c 	lsl	r12,r12,r1
8000c79a:	18 4a       	or	r10,r12
8000c79c:	2f dd       	sub	sp,-12
8000c79e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 6f 94 	sub	pc,pc,28564

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c5 35 	rcall	80005370 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c5 2e 	rcall	80005370 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c5 27 	rcall	80005370 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c5 20 	rcall	80005370 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
