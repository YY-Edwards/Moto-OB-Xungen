
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bab0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000dc00  8000dc00  0000e000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000158c  8000de00  8000de00  0000e200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000f38c  8000f38c  0000f78c  2**0
                  ALLOC
  6 .data         00000a50  00000004  8000f390  0000f804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a54  8000fde0  00010254  2**0
                  ALLOC
  8 .bss          000049f0  00000a58  8000fde0  00010258  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  00010254  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001790  00000000  00000000  00010288  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 0000382a  00000000  00000000  00011a18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002e123  00000000  00000000  00015242  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00007812  00000000  00000000  00043365  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000dc51  00000000  00000000  0004ab77  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00004094  00000000  00000000  000587c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000082ae  00000000  00000000  0005c85c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000fedc  00000000  00000000  00064b0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001840  00000000  00000000  000749e8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b5 f4 	sub	pc,pc,-18956

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 14       	sub	r4,r7

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 78       	tst	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	46 a0       	lddsp	r0,sp[0x1a8]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	33 48       	mov	r8,52
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	de 00       	acall	0xe0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 c4       	sub	r4,124
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	79 bc       	ld.w	r12,r12[0x6c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 70       	tst	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	de 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	7d 80       	ld.w	r0,lr[0x60]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 75       	tst	r5,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	de 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	7d 80       	ld.w	r0,lr[0x60]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 60       	and	r0,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	de 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	7d 80       	ld.w	r0,lr[0x60]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	de 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	7d 80       	ld.w	r0,lr[0x60]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	de 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	7d 80       	ld.w	r0,lr[0x60]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	de 70       	acall	0xe7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	7d 80       	ld.w	r0,lr[0x60]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	de 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	7d 80       	ld.w	r0,lr[0x60]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	de a0       	acall	0xea
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	de b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	de cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	de e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	df 00       	acall	0xf0
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	7d 80       	ld.w	r0,lr[0x60]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	df 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	df 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	df 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	7d 80       	ld.w	r0,lr[0x60]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	df 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	df 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	df 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	df a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	df cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	df f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	e0 18 80 00 	andl	r8,0x8000
800022be:	e0 40 eb cd 	cp.w	r0,60365

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	e0 64 80 00 	mov	r4,32768
800022fa:	7d 80       	ld.w	r0,lr[0x60]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	df 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	e0 7c eb cd 	mov	r12,125901

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 cc       	lddpc	r12,80002344 <BatteryLevel_brdcst_func+0x40>
80002318:	f0 1f 00 0c 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 cc       	lddpc	r12,8000234c <BatteryLevel_brdcst_func+0x48>
80002320:	f0 1f 00 0a 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 ac       	lddpc	r12,80002350 <BatteryLevel_brdcst_func+0x4c>
8000232a:	f0 1f 00 08 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
8000232e:	8e 98       	ld.uh	r8,r7[0x2]
80002330:	1a d8       	st.w	--sp,r8
80002332:	48 9c       	lddpc	r12,80002354 <BatteryLevel_brdcst_func+0x50>
80002334:	f0 1f 00 05 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
80002338:	0f 89       	ld.ub	r9,r7[0x0]
8000233a:	48 88       	lddpc	r8,80002358 <BatteryLevel_brdcst_func+0x54>
8000233c:	b0 89       	st.b	r8[0x0],r9
8000233e:	2f ed       	sub	sp,-8

}
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	e0 98 80 00 	brls	80032346 <_data_lma+0x22fb6>
8000234a:	7d 80       	ld.w	r0,lr[0x60]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	e0 a8       	*unknown*
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	e0 bc       	*unknown*
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	e0 d4 00 00 	satsub.w	r4,r0,0
8000235a:	0a 59       	eor	r9,r5

8000235c <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
8000235c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
8000235e:	19 a8       	ld.ub	r8,r12[0x2]
80002360:	30 19       	mov	r9,1
80002362:	f2 08 18 00 	cp.b	r8,r9
80002366:	c0 51       	brne	80002370 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002368:	48 6c       	lddpc	r12,80002380 <ShutDown_brdcst_func+0x24>
8000236a:	f0 1f 00 07 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000236e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002370:	30 29       	mov	r9,2
80002372:	f2 08 18 00 	cp.b	r8,r9
80002376:	c0 41       	brne	8000237e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002378:	48 4c       	lddpc	r12,80002388 <ShutDown_brdcst_func+0x2c>
8000237a:	f0 1f 00 03 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000237e:	d8 02       	popm	pc
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	e0 ec 80 00 	ld.d	r12,r0[-32768]
80002386:	7d 80       	ld.w	r0,lr[0x60]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	e1 00 eb cd 	ld.sh	r0,r0[-5171]

8000238c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000238c:	eb cd 40 80 	pushm	r7,lr
80002390:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002392:	19 a9       	ld.ub	r9,r12[0x2]
80002394:	30 08       	mov	r8,0
80002396:	f0 09 18 00 	cp.b	r9,r8
8000239a:	c1 11       	brne	800023bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000239c:	49 3c       	lddpc	r12,800023e8 <DataSession_reply_func+0x5c>
8000239e:	f0 1f 00 14 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023a2:	0f b8       	ld.ub	r8,r7[0x3]
800023a4:	1a d8       	st.w	--sp,r8
800023a6:	49 3c       	lddpc	r12,800023f0 <DataSession_reply_func+0x64>
800023a8:	f0 1f 00 11 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023ac:	0f c8       	ld.ub	r8,r7[0x4]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 1c       	lddpc	r12,800023f4 <DataSession_reply_func+0x68>
800023b2:	f0 1f 00 0f 	mcall	800023ec <DataSession_reply_func+0x60>
800023b6:	2f ed       	sub	sp,-8
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023bc:	48 fc       	lddpc	r12,800023f8 <DataSession_reply_func+0x6c>
800023be:	f0 1f 00 0c 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023c2:	0f a8       	ld.ub	r8,r7[0x2]
800023c4:	1a d8       	st.w	--sp,r8
800023c6:	48 ec       	lddpc	r12,800023fc <DataSession_reply_func+0x70>
800023c8:	f0 1f 00 09 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023cc:	0f b8       	ld.ub	r8,r7[0x3]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x74>
800023d2:	f0 1f 00 07 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023d6:	0f c8       	ld.ub	r8,r7[0x4]
800023d8:	1a d8       	st.w	--sp,r8
800023da:	48 bc       	lddpc	r12,80002404 <DataSession_reply_func+0x78>
800023dc:	f0 1f 00 04 	mcall	800023ec <DataSession_reply_func+0x60>
800023e0:	2f dd       	sub	sp,-12
800023e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e6:	00 00       	add	r0,r0
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	e1 10 80 00 	ld.uh	r0,r0[-32768]
800023ee:	7d 80       	ld.w	r0,lr[0x60]
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	e1 20 80 00 	ld.sb	r0,r0[-32768]
800023f6:	e1 2c 80 00 	ld.sb	r12,r0[-32768]
800023fa:	e1 38 80 00 	ld.ub	r8,r0[-32768]
800023fe:	e1 48 80 00 	st.w	r0[-32768],r8
80002402:	e1 58 80 00 	st.h	r0[-32768],r8
80002406:	e1 64 eb cd 	st.b	r0[-5171],r4

80002408 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000240c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 bc       	lddpc	r12,80002440 <CallControl_brdcst_func+0x38>
80002416:	f0 1f 00 0c 	mcall	80002444 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000241a:	2f fd       	sub	sp,-4
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 38       	mov	r8,3
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002426:	30 09       	mov	r9,0
80002428:	48 88       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000242c:	0f 99       	ld.ub	r9,r7[0x1]
8000242e:	30 48       	mov	r8,4
80002430:	f0 09 18 00 	cp.b	r9,r8
80002434:	c0 41       	brne	8000243c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002436:	30 19       	mov	r9,1
80002438:	48 48       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000243a:	b0 89       	st.b	r8[0x0],r9
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	e1 70 80 00 	stcond	r0[-32768],r0
80002446:	7d 80       	ld.w	r0,lr[0x60]
80002448:	00 00       	add	r0,r0
8000244a:	0a 62       	and	r2,r5

8000244c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000244c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002450:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 08       	mov	r8,0
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 71       	brne	8000246a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000245e:	48 ac       	lddpc	r12,80002484 <TransmitControl_brdcst_func+0x38>
80002460:	f0 1f 00 0a 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002464:	30 09       	mov	r9,0
80002466:	48 a8       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
80002468:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000246a:	0f 99       	ld.ub	r9,r7[0x1]
8000246c:	30 18       	mov	r8,1
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c0 71       	brne	80002480 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002474:	48 7c       	lddpc	r12,80002490 <TransmitControl_brdcst_func+0x44>
80002476:	f0 1f 00 05 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000247a:	30 19       	mov	r9,1
8000247c:	48 48       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
8000247e:	b0 89       	st.b	r8[0x0],r9
80002480:	e3 cd 80 80 	ldm	sp++,r7,pc
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	e1 88       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	7d 80       	ld.w	r0,lr[0x60]
8000248c:	00 00       	add	r0,r0
8000248e:	0a 61       	and	r1,r5
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	e1 a0 eb cd 	cop	cp7,cr11,cr12,cr13,0x0

80002494 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 61       	brne	800024d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024a6:	48 ec       	lddpc	r12,800024dc <TransmitControl_reply_func+0x48>
800024a8:	f0 1f 00 0e 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024ac:	0f 98       	ld.ub	r8,r7[0x1]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	48 dc       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x50>
800024b2:	f0 1f 00 0c 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024b6:	0f a8       	ld.ub	r8,r7[0x2]
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 cc       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x54>
800024bc:	f0 1f 00 09 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024c0:	0f b8       	ld.ub	r8,r7[0x3]
800024c2:	1a d8       	st.w	--sp,r8
800024c4:	48 ac       	lddpc	r12,800024ec <TransmitControl_reply_func+0x58>
800024c6:	f0 1f 00 07 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024ca:	2f dd       	sub	sp,-12
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 8c       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x5c>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	e1 b4       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	7d 80       	ld.w	r0,lr[0x60]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	e1 d0 80 00 	ldswp.w	r0,r0[0]
800024ea:	e1 e4 80 00 	sthh.w	r0[r0],r0:b,r4:b
800024ee:	e2 00       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	e2 10 d4 01 	andl	r0,0xd401,COH

800024f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024f6:	19 a9       	ld.ub	r9,r12[0x2]
800024f8:	30 08       	mov	r8,0
800024fa:	f0 09 18 00 	cp.b	r9,r8
800024fe:	c0 51       	brne	80002508 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002500:	48 4c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x1c>
80002502:	f0 1f 00 05 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
80002506:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002508:	48 4c       	lddpc	r12,80002518 <AudioRoutingControl_reply_func+0x24>
8000250a:	f0 1f 00 03 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
8000250e:	d8 02       	popm	pc
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	e2 28 80 00 	sub	r8,163840
80002516:	7d 80       	ld.w	r0,lr[0x60]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	e2 38 eb cd 	sub	r8,256973

8000251c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 b1       	brne	80002562 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000252e:	0f b8       	ld.ub	r8,r7[0x3]
80002530:	31 09       	mov	r9,16
80002532:	f2 08 18 00 	cp.b	r8,r9
80002536:	c0 f1       	brne	80002554 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002538:	48 dc       	lddpc	r12,8000256c <Volume_reply_func+0x50>
8000253a:	f0 1f 00 0e 	mcall	80002570 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000253e:	0f 99       	ld.ub	r9,r7[0x1]
80002540:	0f a8       	ld.ub	r8,r7[0x2]
80002542:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002546:	1a d8       	st.w	--sp,r8
80002548:	48 bc       	lddpc	r12,80002574 <Volume_reply_func+0x58>
8000254a:	f0 1f 00 0a 	mcall	80002570 <Volume_reply_func+0x54>
8000254e:	2f fd       	sub	sp,-4
80002550:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 9c       	lddpc	r12,80002578 <Volume_reply_func+0x5c>
80002558:	f0 1f 00 06 	mcall	80002570 <Volume_reply_func+0x54>
8000255c:	2f fd       	sub	sp,-4
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002562:	48 7c       	lddpc	r12,8000257c <Volume_reply_func+0x60>
80002564:	f0 1f 00 03 	mcall	80002570 <Volume_reply_func+0x54>
80002568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	e2 4c 80 00 	cp.w	r12,163840
80002572:	7d 80       	ld.w	r0,lr[0x60]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	e2 60 80 00 	mov	r0,163840
8000257a:	e2 7c 80 00 	mov	r12,229376
8000257e:	e2 94 d4 01 	brge	8007cd80 <_data_lma+0x6d9f0>

80002580 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002582:	19 d9       	ld.ub	r9,r12[0x5]
80002584:	30 08       	mov	r8,0
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 81       	brne	8000259a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000258c:	10 99       	mov	r9,r8
8000258e:	48 78       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
80002590:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002592:	48 7c       	lddpc	r12,800025ac <spk_brdcst_func+0x2c>
80002594:	f0 1f 00 07 	mcall	800025b0 <spk_brdcst_func+0x30>
80002598:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000259a:	30 19       	mov	r9,1
8000259c:	48 38       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
8000259e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025a0:	48 5c       	lddpc	r12,800025b4 <spk_brdcst_func+0x34>
800025a2:	f0 1f 00 04 	mcall	800025b0 <spk_brdcst_func+0x30>
800025a6:	d8 02       	popm	pc
800025a8:	00 00       	add	r0,r0
800025aa:	0a 58       	eor	r8,r5
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	e2 ac       	*unknown*
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	7d 80       	ld.w	r0,lr[0x60]
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	e2 bc       	*unknown*

800025b8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ba:	19 a9       	ld.ub	r9,r12[0x2]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 f1       	brne	800025e0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025c4:	19 e9       	ld.ub	r9,r12[0x6]
800025c6:	f0 09 18 00 	cp.b	r9,r8
800025ca:	c0 40       	breq	800025d2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025cc:	30 19       	mov	r9,1
800025ce:	48 98       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025d0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025d2:	19 e8       	ld.ub	r8,r12[0x6]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	48 8c       	lddpc	r12,800025f4 <spk_reply_func+0x3c>
800025d8:	f0 1f 00 08 	mcall	800025f8 <spk_reply_func+0x40>
800025dc:	2f fd       	sub	sp,-4
800025de:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025e0:	30 09       	mov	r9,0
800025e2:	48 48       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025e4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025e6:	48 6c       	lddpc	r12,800025fc <spk_reply_func+0x44>
800025e8:	f0 1f 00 04 	mcall	800025f8 <spk_reply_func+0x40>
800025ec:	d8 02       	popm	pc
800025ee:	00 00       	add	r0,r0
800025f0:	00 00       	add	r0,r0
800025f2:	0a 58       	eor	r8,r5
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	e2 c8 80 00 	sub	r8,r1,-32768
800025fa:	7d 80       	ld.w	r0,lr[0x60]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	e2 d8 eb cd 	satsub.w	r8,r1,-5171

80002600 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002600:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002604:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002608:	0f a9       	ld.ub	r9,r7[0x2]
8000260a:	30 08       	mov	r8,0
8000260c:	f0 09 18 00 	cp.b	r9,r8
80002610:	c0 71       	brne	8000261e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002612:	48 dc       	lddpc	r12,80002644 <mic_brdcst_func+0x44>
80002614:	f0 1f 00 0d 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 d8       	lddpc	r8,8000264c <mic_brdcst_func+0x4c>
8000261c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000261e:	0f a9       	ld.ub	r9,r7[0x2]
80002620:	31 18       	mov	r8,17
80002622:	f0 09 18 00 	cp.b	r9,r8
80002626:	c0 d1       	brne	80002640 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002628:	48 ac       	lddpc	r12,80002650 <mic_brdcst_func+0x50>
8000262a:	f0 1f 00 08 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000262e:	48 89       	lddpc	r9,8000264c <mic_brdcst_func+0x4c>
80002630:	30 18       	mov	r8,1
80002632:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002634:	13 89       	ld.ub	r9,r9[0x0]
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 31       	brne	80002640 <mic_brdcst_func+0x40>
8000263c:	48 68       	lddpc	r8,80002654 <mic_brdcst_func+0x54>
8000263e:	11 88       	ld.ub	r8,r8[0x0]
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	e2 e4 80 00 	ld.d	r4,r1[-32768]
8000264a:	7d 80       	ld.w	r0,lr[0x60]
8000264c:	00 00       	add	r0,r0
8000264e:	0a 74       	tst	r4,r5
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	e2 f8 00 00 	ld.w	r8,r1[0]
80002656:	0a 62       	and	r2,r5

80002658 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002658:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000265c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002660:	49 ac       	lddpc	r12,800026c8 <mic_reply_func+0x70>
80002662:	f0 1f 00 1b 	mcall	800026cc <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002666:	0f 89       	ld.ub	r9,r7[0x0]
80002668:	30 08       	mov	r8,0
8000266a:	f0 09 18 00 	cp.b	r9,r8
8000266e:	c2 71       	brne	800026bc <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002670:	0f 98       	ld.ub	r8,r7[0x1]
80002672:	30 29       	mov	r9,2
80002674:	f2 08 18 00 	cp.b	r8,r9
80002678:	c1 b1       	brne	800026ae <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000267a:	49 6c       	lddpc	r12,800026d0 <mic_reply_func+0x78>
8000267c:	f0 1f 00 14 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002680:	0f a8       	ld.ub	r8,r7[0x2]
80002682:	1a d8       	st.w	--sp,r8
80002684:	49 4c       	lddpc	r12,800026d4 <mic_reply_func+0x7c>
80002686:	f0 1f 00 12 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000268a:	0f b8       	ld.ub	r8,r7[0x3]
8000268c:	1a d8       	st.w	--sp,r8
8000268e:	49 3c       	lddpc	r12,800026d8 <mic_reply_func+0x80>
80002690:	f0 1f 00 0f 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002694:	0f c8       	ld.ub	r8,r7[0x4]
80002696:	1a d8       	st.w	--sp,r8
80002698:	49 1c       	lddpc	r12,800026dc <mic_reply_func+0x84>
8000269a:	f0 1f 00 0d 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000269e:	0f d8       	ld.ub	r8,r7[0x5]
800026a0:	1a d8       	st.w	--sp,r8
800026a2:	49 0c       	lddpc	r12,800026e0 <mic_reply_func+0x88>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_reply_func+0x74>
800026a8:	2f cd       	sub	sp,-16
800026aa:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ae:	1a d8       	st.w	--sp,r8
800026b0:	48 dc       	lddpc	r12,800026e4 <mic_reply_func+0x8c>
800026b2:	f0 1f 00 07 	mcall	800026cc <mic_reply_func+0x74>
800026b6:	2f fd       	sub	sp,-4
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026bc:	48 bc       	lddpc	r12,800026e8 <mic_reply_func+0x90>
800026be:	f0 1f 00 04 	mcall	800026cc <mic_reply_func+0x74>
800026c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c6:	00 00       	add	r0,r0
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	e3 0c 80 00 	ld.sh	r12,r1[-32768]
800026ce:	7d 80       	ld.w	r0,lr[0x60]
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	e3 1c 80 00 	ld.uh	r12,r1[-32768]
800026d6:	e3 30 80 00 	ld.ub	r0,r1[-32768]
800026da:	e3 44 80 00 	st.w	r1[-32768],r4
800026de:	e3 60 80 00 	st.b	r1[-32768],r0
800026e2:	e3 78 80 00 	stcond	r1[-32768],r8
800026e6:	e3 90       	*unknown*
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	e3 a8 eb cd 	cop	cp7,cr11,cr12,cr13,0x30

800026ec <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f4:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x34>
800026f6:	f0 1f 00 0c 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026fa:	0f 88       	ld.ub	r8,r7[0x0]
800026fc:	1a d8       	st.w	--sp,r8
800026fe:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x3c>
80002700:	f0 1f 00 09 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	48 9c       	lddpc	r12,8000272c <dcm_brdcst_func+0x40>
8000270a:	f0 1f 00 07 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000270e:	0f 98       	ld.ub	r8,r7[0x1]
80002710:	1a d8       	st.w	--sp,r8
80002712:	48 8c       	lddpc	r12,80002730 <dcm_brdcst_func+0x44>
80002714:	f0 1f 00 04 	mcall	80002724 <dcm_brdcst_func+0x38>
80002718:	2f dd       	sub	sp,-12
	
	
}
8000271a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271e:	00 00       	add	r0,r0
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	e3 b8       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	7d 80       	ld.w	r0,lr[0x60]
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	e3 cc 80 00 	ldm	r12++,pc
8000272e:	e3 e0 80 00 	sthh.w	r0[r0],r1:b,r0:b
80002732:	e3 f8 eb cd 	st.wqs	r1[0x734],r8

80002734 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002734:	eb cd 40 80 	pushm	r7,lr
80002738:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000273a:	19 a9       	ld.ub	r9,r12[0x2]
8000273c:	30 08       	mov	r8,0
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c1 b1       	brne	80002778 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002744:	19 b8       	ld.ub	r8,r12[0x3]
80002746:	30 19       	mov	r9,1
80002748:	f2 08 18 00 	cp.b	r8,r9
8000274c:	c0 51       	brne	80002756 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000274e:	48 ec       	lddpc	r12,80002784 <dcm_reply_func+0x50>
80002750:	f0 1f 00 0e 	mcall	80002788 <dcm_reply_func+0x54>
80002754:	c0 a8       	rjmp	80002768 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002756:	58 08       	cp.w	r8,0
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000275a:	48 dc       	lddpc	r12,8000278c <dcm_reply_func+0x58>
8000275c:	f0 1f 00 0b 	mcall	80002788 <dcm_reply_func+0x54>
80002760:	c0 48       	rjmp	80002768 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002762:	48 cc       	lddpc	r12,80002790 <dcm_reply_func+0x5c>
80002764:	f0 1f 00 09 	mcall	80002788 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002768:	0f d8       	ld.ub	r8,r7[0x5]
8000276a:	1a d8       	st.w	--sp,r8
8000276c:	48 ac       	lddpc	r12,80002794 <dcm_reply_func+0x60>
8000276e:	f0 1f 00 07 	mcall	80002788 <dcm_reply_func+0x54>
80002772:	2f fd       	sub	sp,-4
80002774:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002778:	48 8c       	lddpc	r12,80002798 <dcm_reply_func+0x64>
8000277a:	f0 1f 00 04 	mcall	80002788 <dcm_reply_func+0x54>
8000277e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002782:	00 00       	add	r0,r0
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	e4 14 80 00 	andh	r4,0x8000
8000278a:	7d 80       	ld.w	r0,lr[0x60]
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	e4 28 80 00 	sub	r8,294912
80002792:	e4 3c 80 00 	sub	r12,360448
80002796:	e4 50 80 00 	cp.w	r0,360448
8000279a:	e4 5c d4 01 	cp.w	r12,381953

8000279c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000279e:	19 a9       	ld.ub	r9,r12[0x2]
800027a0:	30 08       	mov	r8,0
800027a2:	f0 09 18 00 	cp.b	r9,r8
800027a6:	c0 51       	brne	800027b0 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x1c>
800027aa:	f0 1f 00 05 	mcall	800027bc <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x24>
800027b2:	f0 1f 00 03 	mcall	800027bc <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	e4 68 80 00 	mov	r8,294912
800027be:	7d 80       	ld.w	r0,lr[0x60]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	e4 74 d4 31 	mov	r4,382001

800027c4 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027c4:	d4 31       	pushm	r0-r7,lr
800027c6:	20 2d       	sub	sp,8
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c8:	32 0c       	mov	r12,32
800027ca:	f0 1f 00 5c 	mcall	80002938 <app_cfg+0x174>
800027ce:	50 0c       	stdsp	sp[0x0],r12
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027d0:	f0 1f 00 5b 	mcall	8000293c <app_cfg+0x178>
800027d4:	4d b8       	lddpc	r8,80002940 <app_cfg+0x17c>
800027d6:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
800027d8:	4d b7       	lddpc	r7,80002944 <app_cfg+0x180>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027da:	4d c5       	lddpc	r5,80002948 <app_cfg+0x184>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027dc:	30 91       	mov	r1,9
800027de:	32 02       	mov	r2,32
800027e0:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
800027e2:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027e4:	4d a4       	lddpc	r4,8000294c <app_cfg+0x188>
800027e6:	fa c3 ff fc 	sub	r3,sp,-4
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
800027ea:	6e 08       	ld.w	r8,r7[0x0]
800027ec:	58 28       	cp.w	r8,2
800027ee:	c3 50       	breq	80002858 <app_cfg+0x94>
800027f0:	58 38       	cp.w	r8,3
800027f2:	c4 10       	breq	80002874 <app_cfg+0xb0>
800027f4:	58 08       	cp.w	r8,0
800027f6:	e0 81 00 9b 	brne	8000292c <app_cfg+0x168>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027fa:	4d 68       	lddpc	r8,80002950 <app_cfg+0x18c>
800027fc:	70 08       	ld.w	r8,r8[0x0]
800027fe:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002802:	58 38       	cp.w	r8,3
80002804:	c1 21       	brne	80002828 <app_cfg+0x64>
80002806:	4d 48       	lddpc	r8,80002954 <app_cfg+0x190>
80002808:	11 88       	ld.ub	r8,r8[0x0]
8000280a:	58 08       	cp.w	r8,0
8000280c:	c0 e1       	brne	80002828 <app_cfg+0x64>
				{
					connect_flag=1;
8000280e:	30 19       	mov	r9,1
80002810:	4d 18       	lddpc	r8,80002954 <app_cfg+0x190>
80002812:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002814:	30 cb       	mov	r11,12
80002816:	30 1c       	mov	r12,1
80002818:	f0 1f 00 50 	mcall	80002958 <app_cfg+0x194>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
8000281c:	30 28       	mov	r8,2
8000281e:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002820:	4c fc       	lddpc	r12,8000295c <app_cfg+0x198>
80002822:	f0 1f 00 50 	mcall	80002960 <app_cfg+0x19c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002826:	c8 38       	rjmp	8000292c <app_cfg+0x168>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002828:	d7 03       	nop
					nop();
8000282a:	d7 03       	nop
					nop();
8000282c:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
8000282e:	4c ec       	lddpc	r12,80002964 <app_cfg+0x1a0>
80002830:	f0 1f 00 4c 	mcall	80002960 <app_cfg+0x19c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002834:	4c d8       	lddpc	r8,80002968 <app_cfg+0x1a4>
80002836:	11 de       	ld.ub	lr,r8[0x5]
80002838:	11 cc       	ld.ub	r12,r8[0x4]
8000283a:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
8000283c:	11 aa       	ld.ub	r10,r8[0x2]
8000283e:	11 99       	ld.ub	r9,r8[0x1]
80002840:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002842:	1a de       	st.w	--sp,lr
80002844:	1a dc       	st.w	--sp,r12
80002846:	1a db       	st.w	--sp,r11
80002848:	1a da       	st.w	--sp,r10
8000284a:	1a d9       	st.w	--sp,r9
8000284c:	1a d8       	st.w	--sp,r8
8000284e:	4c 8c       	lddpc	r12,8000296c <app_cfg+0x1a8>
80002850:	f0 1f 00 44 	mcall	80002960 <app_cfg+0x19c>
80002854:	2f ad       	sub	sp,-24
80002856:	c6 b8       	rjmp	8000292c <app_cfg+0x168>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
80002858:	0b 88       	ld.ub	r8,r5[0x0]
8000285a:	58 08       	cp.w	r8,0
8000285c:	c0 60       	breq	80002868 <app_cfg+0xa4>
							
							OB_State = OB_WAITINGAPPTASK;
8000285e:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
80002860:	4c 4c       	lddpc	r12,80002970 <app_cfg+0x1ac>
80002862:	f0 1f 00 40 	mcall	80002960 <app_cfg+0x19c>
80002866:	c6 38       	rjmp	8000292c <app_cfg+0x168>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002868:	02 9a       	mov	r10,r1
8000286a:	04 9b       	mov	r11,r2
8000286c:	0c 9c       	mov	r12,r6
8000286e:	f0 1f 00 42 	mcall	80002974 <app_cfg+0x1b0>
80002872:	c5 d8       	rjmp	8000292c <app_cfg+0x168>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002874:	68 0c       	ld.w	r12,r4[0x0]
80002876:	0c 99       	mov	r9,r6
80002878:	e0 6a 0f a0 	mov	r10,4000
8000287c:	06 9b       	mov	r11,r3
8000287e:	f0 1f 00 3f 	mcall	80002978 <app_cfg+0x1b4>
80002882:	58 1c       	cp.w	r12,1
80002884:	c1 01       	brne	800028a4 <app_cfg+0xe0>
					{
						if(data_ptr!=NULL){//save message
80002886:	40 1c       	lddsp	r12,sp[0x4]
80002888:	58 0c       	cp.w	r12,0
8000288a:	c0 d0       	breq	800028a4 <app_cfg+0xe0>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
8000288c:	30 1a       	mov	r10,1
8000288e:	04 9b       	mov	r11,r2
80002890:	f0 1f 00 3b 	mcall	8000297c <app_cfg+0x1b8>
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);		
							
							set_message_store(data_ptr);
80002894:	4b b8       	lddpc	r8,80002980 <app_cfg+0x1bc>
80002896:	70 0c       	ld.w	r12,r8[0x0]
80002898:	40 1b       	lddsp	r11,sp[0x4]
8000289a:	f0 1f 00 3b 	mcall	80002984 <app_cfg+0x1c0>
							log("receive okay!\n");
8000289e:	4b bc       	lddpc	r12,80002988 <app_cfg+0x1c4>
800028a0:	f0 1f 00 30 	mcall	80002960 <app_cfg+0x19c>
							
						}
						
					}
										
					message_count = xgflash_get_message_count();
800028a4:	f0 1f 00 3a 	mcall	8000298c <app_cfg+0x1c8>
800028a8:	5c 8c       	casts.h	r12
800028aa:	4b a8       	lddpc	r8,80002990 <app_cfg+0x1cc>
800028ac:	b0 0c       	st.h	r8[0x0],r12
					if( (message_count!=0) && (Battery_Flag == Battery_Okay) )//有缓存且电量充足，需发送短信
800028ae:	58 0c       	cp.w	r12,0
800028b0:	c3 10       	breq	80002912 <app_cfg+0x14e>
800028b2:	4b 98       	lddpc	r8,80002994 <app_cfg+0x1d0>
800028b4:	11 88       	ld.ub	r8,r8[0x0]
800028b6:	58 08       	cp.w	r8,0
800028b8:	c2 d1       	brne	80002912 <app_cfg+0x14e>
					{
						log("Current_total_message_count: %d\n", message_count);
800028ba:	5c 7c       	castu.h	r12
800028bc:	1a dc       	st.w	--sp,r12
800028be:	4b 7c       	lddpc	r12,80002998 <app_cfg+0x1d4>
800028c0:	f0 1f 00 28 	mcall	80002960 <app_cfg+0x19c>
						if(xSemaphoreTake(SendM_CountingSemaphore, (1000*2) / portTICK_RATE_MS) == pdTRUE)
800028c4:	4b 68       	lddpc	r8,8000299c <app_cfg+0x1d8>
800028c6:	70 0c       	ld.w	r12,r8[0x0]
800028c8:	0c 99       	mov	r9,r6
800028ca:	e0 6a 07 d0 	mov	r10,2000
800028ce:	0c 9b       	mov	r11,r6
800028d0:	f0 1f 00 2a 	mcall	80002978 <app_cfg+0x1b4>
800028d4:	2f fd       	sub	sp,-4
800028d6:	58 1c       	cp.w	r12,1
800028d8:	c2 61       	brne	80002924 <app_cfg+0x160>
						{
							log("xSemaphoreTake okay!\n");
800028da:	4b 2c       	lddpc	r12,800029a0 <app_cfg+0x1dc>
800028dc:	f0 1f 00 21 	mcall	80002960 <app_cfg+0x19c>
							if(m_buff==NULL)break;
800028e0:	40 08       	lddsp	r8,sp[0x0]
800028e2:	58 08       	cp.w	r8,0
800028e4:	c2 40       	breq	8000292c <app_cfg+0x168>
							status = xgflash_get_message_data(message_count, m_buff, TRUE);
800028e6:	30 1a       	mov	r10,1
800028e8:	10 9b       	mov	r11,r8
800028ea:	4a a8       	lddpc	r8,80002990 <app_cfg+0x1cc>
800028ec:	90 8c       	ld.uh	r12,r8[0x0]
800028ee:	f0 1f 00 2e 	mcall	800029a4 <app_cfg+0x1e0>
800028f2:	4a e8       	lddpc	r8,800029a8 <app_cfg+0x1e4>
800028f4:	91 0c       	st.w	r8[0x0],r12
							if(status == XG_OK)
800028f6:	58 0c       	cp.w	r12,0
800028f8:	c0 71       	brne	80002906 <app_cfg+0x142>
							{
								xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
800028fa:	02 9a       	mov	r10,r1
800028fc:	04 9b       	mov	r11,r2
800028fe:	40 0c       	lddsp	r12,sp[0x0]
80002900:	f0 1f 00 1d 	mcall	80002974 <app_cfg+0x1b0>
80002904:	c1 08       	rjmp	80002924 <app_cfg+0x160>
							}
							else
							{
								log("get message err : %d\n", status);
80002906:	1a dc       	st.w	--sp,r12
80002908:	4a 9c       	lddpc	r12,800029ac <app_cfg+0x1e8>
8000290a:	f0 1f 00 16 	mcall	80002960 <app_cfg+0x19c>
8000290e:	2f fd       	sub	sp,-4
80002910:	c0 a8       	rjmp	80002924 <app_cfg+0x160>
							}
									
						}								
					}
					else if (Battery_Flag == Battery_Low)
80002912:	4a 18       	lddpc	r8,80002994 <app_cfg+0x1d0>
80002914:	11 89       	ld.ub	r9,r8[0x0]
80002916:	30 18       	mov	r8,1
80002918:	f0 09 18 00 	cp.b	r9,r8
8000291c:	c0 41       	brne	80002924 <app_cfg+0x160>
					{
						log("The device battery level is low !\n");
8000291e:	4a 5c       	lddpc	r12,800029b0 <app_cfg+0x1ec>
80002920:	f0 1f 00 10 	mcall	80002960 <app_cfg+0x19c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
80002924:	d7 03       	nop
					log("app task run!\n");
80002926:	4a 4c       	lddpc	r12,800029b4 <app_cfg+0x1f0>
80002928:	f0 1f 00 0e 	mcall	80002960 <app_cfg+0x19c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000292c:	e0 6b 0f a0 	mov	r11,4000
80002930:	48 4c       	lddpc	r12,80002940 <app_cfg+0x17c>
80002932:	f0 1f 00 22 	mcall	800029b8 <app_cfg+0x1f4>
	}
80002936:	c5 ab       	rjmp	800027ea <app_cfg+0x26>
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	6d dc       	ld.w	r12,r6[0x74]
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	76 ac       	ld.w	r12,r11[0x28]
80002940:	00 00       	add	r0,r0
80002942:	0a 68       	and	r8,r5
80002944:	00 00       	add	r0,r0
80002946:	0a 5c       	eor	r12,r5
80002948:	00 00       	add	r0,r0
8000294a:	00 04       	add	r4,r0
8000294c:	00 00       	add	r0,r0
8000294e:	0b 88       	ld.ub	r8,r5[0x0]
80002950:	00 00       	add	r0,r0
80002952:	0e 14       	sub	r4,r7
80002954:	00 00       	add	r0,r0
80002956:	0a 5a       	eor	r10,r5
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	48 2c       	lddpc	r12,80002960 <app_cfg+0x19c>
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	e4 80 80 00 	breq	8009295e <_data_lma+0x835ce>
80002962:	7d 80       	ld.w	r0,lr[0x60]
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	e4 94 00 00 	brge	800a2966 <_data_lma+0x935d6>
8000296a:	0e 18       	sub	r8,r7
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	e4 a4       	*unknown*
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	e4 d0 80 00 	satsub.w	r0,r2,-32768
80002976:	46 f4       	lddsp	r4,sp[0x1bc]
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	6f 24       	ld.w	r4,r7[0x48]
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	5f 20       	srhs	r0
80002980:	00 00       	add	r0,r0
80002982:	0b 94       	ld.ub	r4,r5[0x1]
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	33 c8       	mov	r8,60
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	e4 e0 80 00 	ld.d	r0,r2[-32768]
8000298e:	60 a0       	ld.w	r0,r0[0x28]
80002990:	00 00       	add	r0,r0
80002992:	0a 6c       	and	r12,r5
80002994:	00 00       	add	r0,r0
80002996:	0a 59       	eor	r9,r5
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	e4 f0 00 00 	ld.w	r0,r2[0]
8000299e:	0b a0       	ld.ub	r0,r5[0x2]
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	e5 14 80 00 	ld.uh	r4,r2[-32768]
800029a6:	5d c0       	*unknown*
800029a8:	00 00       	add	r0,r0
800029aa:	04 f4       	st.b	--r2,r4
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	e5 2c 80 00 	ld.sb	r12,r2[-32768]
800029b2:	e5 44 80 00 	st.w	r2[-32768],r4
800029b6:	e5 68 80 00 	st.b	r2[-32768],r8
800029ba:	78 5c       	ld.w	r12,r12[0x14]

800029bc <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800029bc:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800029c0:	19 c7       	ld.ub	r7,r12[0x4]
800029c2:	19 d8       	ld.ub	r8,r12[0x5]
800029c4:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029c8:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029ca:	48 dc       	lddpc	r12,800029fc <Phyuserinput_brdcst_func+0x40>
800029cc:	f0 1f 00 0d 	mcall	80002a00 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029d0:	36 08       	mov	r8,96
800029d2:	f0 07 19 00 	cp.h	r7,r8
800029d6:	c1 11       	brne	800029f8 <Phyuserinput_brdcst_func+0x3c>
800029d8:	48 b8       	lddpc	r8,80002a04 <Phyuserinput_brdcst_func+0x48>
800029da:	11 89       	ld.ub	r9,r8[0x0]
800029dc:	30 18       	mov	r8,1
800029de:	f0 09 18 00 	cp.b	r9,r8
800029e2:	c0 b1       	brne	800029f8 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800029e4:	31 4b       	mov	r11,20
800029e6:	30 1c       	mov	r12,1
800029e8:	f0 1f 00 08 	mcall	80002a08 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
800029ec:	e0 6c 01 90 	mov	r12,400
800029f0:	f0 1f 00 07 	mcall	80002a0c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
800029f4:	f0 1f 00 07 	mcall	80002a10 <Phyuserinput_brdcst_func+0x54>
800029f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	e5 78 80 00 	stcond	r2[-32768],r8
80002a02:	7d 80       	ld.w	r0,lr[0x60]
80002a04:	00 00       	add	r0,r0
80002a06:	0a 5a       	eor	r10,r5
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	48 2c       	lddpc	r12,80002a10 <Phyuserinput_brdcst_func+0x54>
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	78 14       	ld.w	r4,r12[0x4]
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	58 6c       	cp.w	r12,6

80002a14 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a14:	d4 21       	pushm	r4-r7,lr
80002a16:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002a18:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002a1c:	0d 88       	ld.ub	r8,r6[0x0]
80002a1e:	32 49       	mov	r9,36
80002a20:	f2 08 18 00 	cp.b	r8,r9
80002a24:	c2 91       	brne	80002a76 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002a26:	4b 6c       	lddpc	r12,80002afc <DataSession_brdcst_func+0xe8>
80002a28:	f0 1f 00 36 	mcall	80002b00 <DataSession_brdcst_func+0xec>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002a2c:	0d a5       	ld.ub	r5,r6[0x2]
80002a2e:	0d b8       	ld.ub	r8,r6[0x3]
80002a30:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002a34:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002a36:	0d 98       	ld.ub	r8,r6[0x1]
80002a38:	1a d8       	st.w	--sp,r8
80002a3a:	4b 3c       	lddpc	r12,80002b04 <DataSession_brdcst_func+0xf0>
80002a3c:	f0 1f 00 31 	mcall	80002b00 <DataSession_brdcst_func+0xec>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a40:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a44:	1a d8       	st.w	--sp,r8
80002a46:	4b 1c       	lddpc	r12,80002b08 <DataSession_brdcst_func+0xf4>
80002a48:	f0 1f 00 2e 	mcall	80002b00 <DataSession_brdcst_func+0xec>
		for(i=0; i<data_length; i++)
80002a4c:	2f ed       	sub	sp,-8
80002a4e:	58 05       	cp.w	r5,0
80002a50:	c5 40       	breq	80002af8 <DataSession_brdcst_func+0xe4>
80002a52:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a54:	4a e4       	lddpc	r4,80002b0c <DataSession_brdcst_func+0xf8>
80002a56:	ec 07 00 08 	add	r8,r6,r7
80002a5a:	11 c8       	ld.ub	r8,r8[0x4]
80002a5c:	1a d8       	st.w	--sp,r8
80002a5e:	1a d7       	st.w	--sp,r7
80002a60:	08 9c       	mov	r12,r4
80002a62:	f0 1f 00 28 	mcall	80002b00 <DataSession_brdcst_func+0xec>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002a66:	2f f7       	sub	r7,-1
80002a68:	5c 57       	castu.b	r7
80002a6a:	2f ed       	sub	sp,-8
80002a6c:	ee 05 19 00 	cp.h	r5,r7
80002a70:	fe 9b ff f3 	brhi	80002a56 <DataSession_brdcst_func+0x42>
80002a74:	c4 28       	rjmp	80002af8 <DataSession_brdcst_func+0xe4>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002a76:	1a d8       	st.w	--sp,r8
80002a78:	4a 6c       	lddpc	r12,80002b10 <DataSession_brdcst_func+0xfc>
80002a7a:	f0 1f 00 22 	mcall	80002b00 <DataSession_brdcst_func+0xec>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002a7e:	0d 88       	ld.ub	r8,r6[0x0]
80002a80:	2f fd       	sub	sp,-4
80002a82:	30 39       	mov	r9,3
80002a84:	f2 08 18 00 	cp.b	r8,r9
80002a88:	c0 51       	brne	80002a92 <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002a8a:	4a 3c       	lddpc	r12,80002b14 <DataSession_brdcst_func+0x100>
80002a8c:	f0 1f 00 1d 	mcall	80002b00 <DataSession_brdcst_func+0xec>
80002a90:	c2 18       	rjmp	80002ad2 <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a92:	30 49       	mov	r9,4
80002a94:	f2 08 18 00 	cp.b	r8,r9
80002a98:	c1 d1       	brne	80002ad2 <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002a9a:	32 0a       	mov	r10,32
80002a9c:	ec cb ff fc 	sub	r11,r6,-4
80002aa0:	1a 9c       	mov	r12,sp
80002aa2:	f0 1f 00 1e 	mcall	80002b18 <DataSession_brdcst_func+0x104>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002aa6:	49 e8       	lddpc	r8,80002b1c <DataSession_brdcst_func+0x108>
80002aa8:	70 0c       	ld.w	r12,r8[0x0]
80002aaa:	f0 1f 00 1e 	mcall	80002b20 <DataSession_brdcst_func+0x10c>
80002aae:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002ab0:	c0 e0       	breq	80002acc <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002ab2:	32 0a       	mov	r10,32
80002ab4:	1a 9b       	mov	r11,sp
80002ab6:	f0 1f 00 19 	mcall	80002b18 <DataSession_brdcst_func+0x104>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002aba:	49 b8       	lddpc	r8,80002b24 <DataSession_brdcst_func+0x110>
80002abc:	70 0c       	ld.w	r12,r8[0x0]
80002abe:	30 09       	mov	r9,0
80002ac0:	12 9a       	mov	r10,r9
80002ac2:	fa cb ff e0 	sub	r11,sp,-32
80002ac6:	f0 1f 00 19 	mcall	80002b28 <DataSession_brdcst_func+0x114>
80002aca:	c0 48       	rjmp	80002ad2 <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002acc:	49 8c       	lddpc	r12,80002b2c <DataSession_brdcst_func+0x118>
80002ace:	f0 1f 00 0d 	mcall	80002b00 <DataSession_brdcst_func+0xec>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002ad2:	0d 89       	ld.ub	r9,r6[0x0]
80002ad4:	20 39       	sub	r9,3
80002ad6:	30 18       	mov	r8,1
80002ad8:	f0 09 18 00 	cp.b	r9,r8
80002adc:	e0 8b 00 0e 	brhi	80002af8 <DataSession_brdcst_func+0xe4>
		{		
			if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
80002ae0:	49 48       	lddpc	r8,80002b30 <DataSession_brdcst_func+0x11c>
80002ae2:	70 0c       	ld.w	r12,r8[0x0]
80002ae4:	30 09       	mov	r9,0
80002ae6:	12 9a       	mov	r10,r9
80002ae8:	12 9b       	mov	r11,r9
80002aea:	f0 1f 00 10 	mcall	80002b28 <DataSession_brdcst_func+0x114>
80002aee:	58 1c       	cp.w	r12,1
80002af0:	c0 40       	breq	80002af8 <DataSession_brdcst_func+0xe4>
			{
				log("xSemaphoreGive: err\n\r" );
80002af2:	49 1c       	lddpc	r12,80002b34 <DataSession_brdcst_func+0x120>
80002af4:	f0 1f 00 03 	mcall	80002b00 <DataSession_brdcst_func+0xec>
				//
		//}
		
	}
	
}
80002af8:	2f 7d       	sub	sp,-36
80002afa:	d8 22       	popm	r4-r7,pc
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	e5 98       	*unknown*
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	7d 80       	ld.w	r0,lr[0x60]
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	e5 ac 80 00 	cop	cp4,cr0,cr0,cr0,0x58
80002b0a:	e5 c4 80 00 	ldmts	r4,pc
80002b0e:	e5 e0 80 00 	sthh.w	r0[r0],r2:b,r0:b
80002b12:	e5 f8 80 00 	ld.wls	r8,r2[0x0]
80002b16:	e6 04       	*unknown*
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	86 2a       	ld.sh	r10,r3[0x4]
80002b1c:	00 00       	add	r0,r0
80002b1e:	0b 94       	ld.ub	r4,r5[0x1]
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	35 74       	mov	r4,87
80002b24:	00 00       	add	r0,r0
80002b26:	0b 88       	ld.ub	r8,r5[0x0]
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	71 30       	ld.w	r0,r8[0x4c]
80002b2c:	80 00       	ld.sh	r0,r0[0x0]
80002b2e:	e6 1c 00 00 	andh	r12,0x0,COH
80002b32:	0b a0       	ld.ub	r0,r5[0x2]
80002b34:	80 00       	ld.sh	r0,r0[0x0]
80002b36:	e6 2c d4 01 	sub	r12,447489

80002b38 <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b38:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002b3a:	19 e8       	ld.ub	r8,r12[0x6]
80002b3c:	30 19       	mov	r9,1
80002b3e:	f2 08 18 00 	cp.b	r8,r9
80002b42:	c0 61       	brne	80002b4e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002b44:	48 98       	lddpc	r8,80002b68 <DeviceInitializationStatus_brdcst_func+0x30>
80002b46:	70 09       	ld.w	r9,r8[0x0]
80002b48:	a1 a9       	sbr	r9,0x0
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002b4e:	30 29       	mov	r9,2
80002b50:	f2 08 18 00 	cp.b	r8,r9
80002b54:	c0 80       	breq	80002b64 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002b56:	48 58       	lddpc	r8,80002b68 <DeviceInitializationStatus_brdcst_func+0x30>
80002b58:	70 09       	ld.w	r9,r8[0x0]
80002b5a:	e0 19 ff fc 	andl	r9,0xfffc
80002b5e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002b60:	f0 1f 00 03 	mcall	80002b6c <DeviceInitializationStatus_brdcst_func+0x34>
80002b64:	d8 02       	popm	pc
80002b66:	00 00       	add	r0,r0
80002b68:	00 00       	add	r0,r0
80002b6a:	0e 14       	sub	r4,r7
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	47 80       	lddsp	r0,sp[0x1e0]

80002b70 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002b70:	eb cd 40 fc 	pushm	r2-r7,lr
80002b74:	20 1d       	sub	sp,4
80002b76:	18 97       	mov	r7,r12
80002b78:	14 95       	mov	r5,r10
80002b7a:	12 96       	mov	r6,r9
	U16 status = 1;
80002b7c:	30 18       	mov	r8,1
80002b7e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002b80:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002b84:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002b88:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002b8c:	30 1b       	mov	r11,1
80002b8e:	4e 58       	lddpc	r8,80002d20 <send_flash_command+0x1b0>
80002b90:	70 0c       	ld.w	r12,r8[0x0]
80002b92:	f0 1f 00 65 	mcall	80002d24 <send_flash_command+0x1b4>

    switch (command)
80002b96:	30 58       	mov	r8,5
80002b98:	f0 07 19 00 	cp.h	r7,r8
80002b9c:	c3 40       	breq	80002c04 <send_flash_command+0x94>
80002b9e:	e0 8b 00 18 	brhi	80002bce <send_flash_command+0x5e>
80002ba2:	30 28       	mov	r8,2
80002ba4:	f0 07 19 00 	cp.h	r7,r8
80002ba8:	c5 e0       	breq	80002c64 <send_flash_command+0xf4>
80002baa:	e0 8b 00 08 	brhi	80002bba <send_flash_command+0x4a>
80002bae:	30 18       	mov	r8,1
80002bb0:	f0 07 19 00 	cp.h	r7,r8
80002bb4:	e0 81 00 ad 	brne	80002d0e <send_flash_command+0x19e>
80002bb8:	c9 e8       	rjmp	80002cf4 <send_flash_command+0x184>
80002bba:	30 38       	mov	r8,3
80002bbc:	f0 07 19 00 	cp.h	r7,r8
80002bc0:	c7 20       	breq	80002ca4 <send_flash_command+0x134>
80002bc2:	30 48       	mov	r8,4
80002bc4:	f0 07 19 00 	cp.h	r7,r8
80002bc8:	e0 81 00 a3 	brne	80002d0e <send_flash_command+0x19e>
80002bcc:	c2 c8       	rjmp	80002c24 <send_flash_command+0xb4>
80002bce:	35 28       	mov	r8,82
80002bd0:	f0 07 19 00 	cp.h	r7,r8
80002bd4:	c2 f0       	breq	80002c32 <send_flash_command+0xc2>
80002bd6:	e0 8b 00 0c 	brhi	80002bee <send_flash_command+0x7e>
80002bda:	30 68       	mov	r8,6
80002bdc:	f0 07 19 00 	cp.h	r7,r8
80002be0:	c2 20       	breq	80002c24 <send_flash_command+0xb4>
80002be2:	32 08       	mov	r8,32
80002be4:	f0 07 19 00 	cp.h	r7,r8
80002be8:	e0 81 00 93 	brne	80002d0e <send_flash_command+0x19e>
80002bec:	c2 38       	rjmp	80002c32 <send_flash_command+0xc2>
80002bee:	36 08       	mov	r8,96
80002bf0:	f0 07 19 00 	cp.h	r7,r8
80002bf4:	c3 20       	breq	80002c58 <send_flash_command+0xe8>
80002bf6:	e0 68 00 d8 	mov	r8,216
80002bfa:	f0 07 19 00 	cp.h	r7,r8
80002bfe:	e0 81 00 88 	brne	80002d0e <send_flash_command+0x19e>
80002c02:	c1 88       	rjmp	80002c32 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002c04:	4c 77       	lddpc	r7,80002d20 <send_flash_command+0x1b0>
80002c06:	30 5b       	mov	r11,5
80002c08:	6e 0c       	ld.w	r12,r7[0x0]
80002c0a:	f0 1f 00 48 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_dummy();
80002c0e:	e0 6b 00 ff 	mov	r11,255
80002c12:	6e 0c       	ld.w	r12,r7[0x0]
80002c14:	f0 1f 00 45 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002c18:	fa cb ff fe 	sub	r11,sp,-2
80002c1c:	6e 0c       	ld.w	r12,r7[0x0]
80002c1e:	f0 1f 00 44 	mcall	80002d2c <send_flash_command+0x1bc>
			break;
80002c22:	c7 68       	rjmp	80002d0e <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002c24:	0e 9b       	mov	r11,r7
80002c26:	5c 7b       	castu.h	r11
80002c28:	4b e8       	lddpc	r8,80002d20 <send_flash_command+0x1b0>
80002c2a:	70 0c       	ld.w	r12,r8[0x0]
80002c2c:	f0 1f 00 3f 	mcall	80002d28 <send_flash_command+0x1b8>
			break;
80002c30:	c6 f8       	rjmp	80002d0e <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002c32:	4b c6       	lddpc	r6,80002d20 <send_flash_command+0x1b0>
80002c34:	0e 9b       	mov	r11,r7
80002c36:	5c 7b       	castu.h	r11
80002c38:	6c 0c       	ld.w	r12,r6[0x0]
80002c3a:	f0 1f 00 3c 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002c3e:	08 9b       	mov	r11,r4
80002c40:	6c 0c       	ld.w	r12,r6[0x0]
80002c42:	f0 1f 00 3a 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002c46:	06 9b       	mov	r11,r3
80002c48:	6c 0c       	ld.w	r12,r6[0x0]
80002c4a:	f0 1f 00 38 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002c4e:	04 9b       	mov	r11,r2
80002c50:	6c 0c       	ld.w	r12,r6[0x0]
80002c52:	f0 1f 00 36 	mcall	80002d28 <send_flash_command+0x1b8>
			break;
80002c56:	c5 c8       	rjmp	80002d0e <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002c58:	36 0b       	mov	r11,96
80002c5a:	4b 28       	lddpc	r8,80002d20 <send_flash_command+0x1b0>
80002c5c:	70 0c       	ld.w	r12,r8[0x0]
80002c5e:	f0 1f 00 33 	mcall	80002d28 <send_flash_command+0x1b8>
			break;
80002c62:	c5 68       	rjmp	80002d0e <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002c64:	4a f7       	lddpc	r7,80002d20 <send_flash_command+0x1b0>
80002c66:	30 2b       	mov	r11,2
80002c68:	6e 0c       	ld.w	r12,r7[0x0]
80002c6a:	f0 1f 00 30 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002c6e:	08 9b       	mov	r11,r4
80002c70:	6e 0c       	ld.w	r12,r7[0x0]
80002c72:	f0 1f 00 2e 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002c76:	06 9b       	mov	r11,r3
80002c78:	6e 0c       	ld.w	r12,r7[0x0]
80002c7a:	f0 1f 00 2c 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002c7e:	04 9b       	mov	r11,r2
80002c80:	6e 0c       	ld.w	r12,r7[0x0]
80002c82:	f0 1f 00 2a 	mcall	80002d28 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002c86:	58 06       	cp.w	r6,0
80002c88:	c4 30       	breq	80002d0e <send_flash_command+0x19e>
80002c8a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002c8c:	4a 54       	lddpc	r4,80002d20 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002c8e:	0f 3b       	ld.ub	r11,r7++
80002c90:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002c92:	68 0c       	ld.w	r12,r4[0x0]
80002c94:	f0 1f 00 25 	mcall	80002d28 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002c98:	0e 98       	mov	r8,r7
80002c9a:	0a 18       	sub	r8,r5
80002c9c:	ec 08 19 00 	cp.h	r8,r6
80002ca0:	cf 73       	brcs	80002c8e <send_flash_command+0x11e>
80002ca2:	c3 68       	rjmp	80002d0e <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002ca4:	49 f7       	lddpc	r7,80002d20 <send_flash_command+0x1b0>
80002ca6:	30 3b       	mov	r11,3
80002ca8:	6e 0c       	ld.w	r12,r7[0x0]
80002caa:	f0 1f 00 20 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002cae:	08 9b       	mov	r11,r4
80002cb0:	6e 0c       	ld.w	r12,r7[0x0]
80002cb2:	f0 1f 00 1e 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002cb6:	06 9b       	mov	r11,r3
80002cb8:	6e 0c       	ld.w	r12,r7[0x0]
80002cba:	f0 1f 00 1c 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002cbe:	04 9b       	mov	r11,r2
80002cc0:	6e 0c       	ld.w	r12,r7[0x0]
80002cc2:	f0 1f 00 1a 	mcall	80002d28 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002cc6:	58 06       	cp.w	r6,0
80002cc8:	c2 30       	breq	80002d0e <send_flash_command+0x19e>
80002cca:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002ccc:	49 54       	lddpc	r4,80002d20 <send_flash_command+0x1b0>
80002cce:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002cd2:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002cd4:	06 9b       	mov	r11,r3
80002cd6:	68 0c       	ld.w	r12,r4[0x0]
80002cd8:	f0 1f 00 14 	mcall	80002d28 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002cdc:	1a 9b       	mov	r11,sp
80002cde:	68 0c       	ld.w	r12,r4[0x0]
80002ce0:	f0 1f 00 13 	mcall	80002d2c <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002ce4:	9a 08       	ld.sh	r8,sp[0x0]
80002ce6:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002ce8:	0e 98       	mov	r8,r7
80002cea:	0a 18       	sub	r8,r5
80002cec:	ec 08 19 00 	cp.h	r8,r6
80002cf0:	cf 23       	brcs	80002cd4 <send_flash_command+0x164>
80002cf2:	c0 e8       	rjmp	80002d0e <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002cf4:	48 b7       	lddpc	r7,80002d20 <send_flash_command+0x1b0>
80002cf6:	30 1b       	mov	r11,1
80002cf8:	6e 0c       	ld.w	r12,r7[0x0]
80002cfa:	f0 1f 00 0c 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002cfe:	30 0b       	mov	r11,0
80002d00:	6e 0c       	ld.w	r12,r7[0x0]
80002d02:	f0 1f 00 0a 	mcall	80002d28 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002d06:	30 0b       	mov	r11,0
80002d08:	6e 0c       	ld.w	r12,r7[0x0]
80002d0a:	f0 1f 00 08 	mcall	80002d28 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002d0e:	30 1b       	mov	r11,1
80002d10:	48 48       	lddpc	r8,80002d20 <send_flash_command+0x1b0>
80002d12:	70 0c       	ld.w	r12,r8[0x0]
80002d14:	f0 1f 00 07 	mcall	80002d30 <send_flash_command+0x1c0>

	return status;
}
80002d18:	9a 1c       	ld.sh	r12,sp[0x2]
80002d1a:	2f fd       	sub	sp,-4
80002d1c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002d20:	00 00       	add	r0,r0
80002d22:	1e 20       	rsub	r0,pc
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	67 8c       	ld.w	r12,r3[0x60]
80002d28:	80 00       	ld.sh	r0,r0[0x0]
80002d2a:	66 26       	ld.w	r6,r3[0x8]
80002d2c:	80 00       	ld.sh	r0,r0[0x0]
80002d2e:	66 42       	ld.w	r2,r3[0x10]
80002d30:	80 00       	ld.sh	r0,r0[0x0]
80002d32:	67 4c       	ld.w	r12,r3[0x50]

80002d34 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002d34:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002d36:	58 0a       	cp.w	r10,0
80002d38:	5f 09       	sreq	r9
80002d3a:	e0 68 ff fe 	mov	r8,65534
80002d3e:	ea 18 00 7f 	orh	r8,0x7f
80002d42:	10 3c       	cp.w	r12,r8
80002d44:	5f b8       	srhi	r8
80002d46:	f3 e8 10 08 	or	r8,r9,r8
80002d4a:	c0 e1       	brne	80002d66 <data_flash_read_block+0x32>
80002d4c:	e0 68 10 00 	mov	r8,4096
80002d50:	f0 0b 19 00 	cp.h	r11,r8
80002d54:	e0 8b 00 09 	brhi	80002d66 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002d58:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002d5c:	18 9b       	mov	r11,r12
80002d5e:	30 3c       	mov	r12,3
80002d60:	f0 1f 00 02 	mcall	80002d68 <data_flash_read_block+0x34>
80002d64:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002d66:	da 0a       	popm	pc,r12=1
80002d68:	80 00       	ld.sh	r0,r0[0x0]
80002d6a:	2b 70       	sub	r0,-73

80002d6c <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002d6c:	eb cd 40 fc 	pushm	r2-r7,lr
80002d70:	18 94       	mov	r4,r12
80002d72:	16 93       	mov	r3,r11
80002d74:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002d76:	58 0c       	cp.w	r12,0
80002d78:	5f 09       	sreq	r9
80002d7a:	e0 68 ff fe 	mov	r8,65534
80002d7e:	ea 18 00 7f 	orh	r8,0x7f
80002d82:	10 3b       	cp.w	r11,r8
80002d84:	5f b8       	srhi	r8
80002d86:	f3 e8 10 08 	or	r8,r9,r8
80002d8a:	c3 a1       	brne	80002dfe <data_flash_write_page+0x92>
80002d8c:	e0 68 01 00 	mov	r8,256
80002d90:	f0 0a 19 00 	cp.h	r10,r8
80002d94:	e0 8b 00 35 	brhi	80002dfe <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d98:	30 06       	mov	r6,0
80002d9a:	30 55       	mov	r5,5
80002d9c:	30 17       	mov	r7,1
80002d9e:	0c 99       	mov	r9,r6
80002da0:	0c 9a       	mov	r10,r6
80002da2:	0c 9b       	mov	r11,r6
80002da4:	0a 9c       	mov	r12,r5
80002da6:	f0 1f 00 19 	mcall	80002e08 <data_flash_write_page+0x9c>
80002daa:	ee 0c 19 00 	cp.h	r12,r7
80002dae:	cf 80       	breq	80002d9e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002db0:	30 09       	mov	r9,0
80002db2:	12 9a       	mov	r10,r9
80002db4:	12 9b       	mov	r11,r9
80002db6:	30 6c       	mov	r12,6
80002db8:	f0 1f 00 14 	mcall	80002e08 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002dbc:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002dc0:	08 9a       	mov	r10,r4
80002dc2:	06 9b       	mov	r11,r3
80002dc4:	30 2c       	mov	r12,2
80002dc6:	f0 1f 00 11 	mcall	80002e08 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002dca:	30 06       	mov	r6,0
80002dcc:	30 57       	mov	r7,5
80002dce:	0c 99       	mov	r9,r6
80002dd0:	0c 9a       	mov	r10,r6
80002dd2:	0c 9b       	mov	r11,r6
80002dd4:	0e 9c       	mov	r12,r7
80002dd6:	f0 1f 00 0d 	mcall	80002e08 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002dda:	5c 7c       	castu.h	r12
80002ddc:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002de0:	cf 71       	brne	80002dce <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002de2:	18 97       	mov	r7,r12
80002de4:	e2 17 00 20 	andl	r7,0x20,COH
80002de8:	f9 b7 01 06 	movne	r7,6
80002dec:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002df0:	30 09       	mov	r9,0
80002df2:	12 9a       	mov	r10,r9
80002df4:	12 9b       	mov	r11,r9
80002df6:	30 4c       	mov	r12,4
80002df8:	f0 1f 00 04 	mcall	80002e08 <data_flash_write_page+0x9c>

	return return_code;
80002dfc:	c0 28       	rjmp	80002e00 <data_flash_write_page+0x94>
80002dfe:	30 17       	mov	r7,1
}
80002e00:	0e 9c       	mov	r12,r7
80002e02:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002e06:	00 00       	add	r0,r0
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2b 70       	sub	r0,-73

80002e0c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002e0c:	d4 31       	pushm	r0-r7,lr
80002e0e:	18 94       	mov	r4,r12
80002e10:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002e14:	16 97       	mov	r7,r11
80002e16:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002e18:	30 03       	mov	r3,0
80002e1a:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002e1c:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002e20:	c4 98       	rjmp	80002eb2 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002e22:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002e26:	c1 b1       	brne	80002e5c <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002e28:	e0 06 19 00 	cp.h	r6,r0
80002e2c:	e0 8b 00 0a 	brhi	80002e40 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002e30:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002e34:	0e 9b       	mov	r11,r7
80002e36:	08 9c       	mov	r12,r4
80002e38:	f0 1f 00 24 	mcall	80002ec8 <data_flash_write_block+0xbc>
80002e3c:	30 06       	mov	r6,0
80002e3e:	c3 a8       	rjmp	80002eb2 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002e40:	e0 6a 01 00 	mov	r10,256
80002e44:	0e 9b       	mov	r11,r7
80002e46:	08 9c       	mov	r12,r4
80002e48:	f0 1f 00 20 	mcall	80002ec8 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002e4c:	ec c6 01 00 	sub	r6,r6,256
80002e50:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002e52:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002e56:	ee c7 ff 00 	sub	r7,r7,-256
80002e5a:	c2 c8       	rjmp	80002eb2 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002e5c:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002e60:	0e 09       	add	r9,r7
80002e62:	0e 98       	mov	r8,r7
80002e64:	e4 18 00 7f 	andh	r8,0x7f
80002e68:	e0 18 ff 00 	andl	r8,0xff00
80002e6c:	f0 c8 ff 00 	sub	r8,r8,-256
80002e70:	10 39       	cp.w	r9,r8
80002e72:	e0 88 00 19 	brls	80002ea4 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002e76:	0e 91       	mov	r1,r7
80002e78:	5c 51       	castu.b	r1
80002e7a:	e0 6a 01 00 	mov	r10,256
80002e7e:	02 1a       	sub	r10,r1
80002e80:	5c 7a       	castu.h	r10
80002e82:	0e 9b       	mov	r11,r7
80002e84:	08 9c       	mov	r12,r4
80002e86:	f0 1f 00 11 	mcall	80002ec8 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002e8a:	ec c6 01 00 	sub	r6,r6,256
80002e8e:	02 06       	add	r6,r1
80002e90:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002e92:	e0 68 01 00 	mov	r8,256
80002e96:	f0 05 01 05 	sub	r5,r8,r5
80002e9a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002e9c:	e0 17 ff 00 	andl	r7,0xff00
80002ea0:	10 07       	add	r7,r8
80002ea2:	c0 88       	rjmp	80002eb2 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002ea4:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002ea8:	0e 9b       	mov	r11,r7
80002eaa:	08 9c       	mov	r12,r4
80002eac:	f0 1f 00 07 	mcall	80002ec8 <data_flash_write_block+0xbc>
80002eb0:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002eb2:	e6 06 19 00 	cp.h	r6,r3
80002eb6:	5f 19       	srne	r9
80002eb8:	58 7c       	cp.w	r12,7
80002eba:	5f 08       	sreq	r8
80002ebc:	f3 e8 00 08 	and	r8,r9,r8
80002ec0:	e4 08 18 00 	cp.b	r8,r2
80002ec4:	ca f1       	brne	80002e22 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002ec6:	d8 32       	popm	r0-r7,pc
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	2d 6c       	sub	r12,-42

80002ecc <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002ecc:	eb cd 40 f8 	pushm	r3-r7,lr
80002ed0:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002ed2:	e0 68 ff fe 	mov	r8,65534
80002ed6:	ea 18 00 7f 	orh	r8,0x7f
80002eda:	10 3c       	cp.w	r12,r8
80002edc:	e0 88 00 04 	brls	80002ee4 <data_flash_erase_block+0x18>
80002ee0:	30 17       	mov	r7,1
80002ee2:	c3 f8       	rjmp	80002f60 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002ee4:	58 1b       	cp.w	r11,1
80002ee6:	c0 31       	brne	80002eec <data_flash_erase_block+0x20>
80002ee8:	32 03       	mov	r3,32
80002eea:	c0 a8       	rjmp	80002efe <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002eec:	58 2b       	cp.w	r11,2
80002eee:	c0 31       	brne	80002ef4 <data_flash_erase_block+0x28>
80002ef0:	35 23       	mov	r3,82
80002ef2:	c0 68       	rjmp	80002efe <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002ef4:	e0 63 00 d8 	mov	r3,216
80002ef8:	58 3b       	cp.w	r11,3
80002efa:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002efe:	30 06       	mov	r6,0
80002f00:	30 55       	mov	r5,5
80002f02:	30 17       	mov	r7,1
80002f04:	0c 99       	mov	r9,r6
80002f06:	0c 9a       	mov	r10,r6
80002f08:	0c 9b       	mov	r11,r6
80002f0a:	0a 9c       	mov	r12,r5
80002f0c:	f0 1f 00 17 	mcall	80002f68 <data_flash_erase_block+0x9c>
80002f10:	ee 0c 19 00 	cp.h	r12,r7
80002f14:	cf 80       	breq	80002f04 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002f16:	30 09       	mov	r9,0
80002f18:	12 9a       	mov	r10,r9
80002f1a:	12 9b       	mov	r11,r9
80002f1c:	30 6c       	mov	r12,6
80002f1e:	f0 1f 00 13 	mcall	80002f68 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002f22:	30 09       	mov	r9,0
80002f24:	12 9a       	mov	r10,r9
80002f26:	08 9b       	mov	r11,r4
80002f28:	06 9c       	mov	r12,r3
80002f2a:	f0 1f 00 10 	mcall	80002f68 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002f2e:	30 06       	mov	r6,0
80002f30:	30 57       	mov	r7,5
80002f32:	0c 99       	mov	r9,r6
80002f34:	0c 9a       	mov	r10,r6
80002f36:	0c 9b       	mov	r11,r6
80002f38:	0e 9c       	mov	r12,r7
80002f3a:	f0 1f 00 0c 	mcall	80002f68 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002f3e:	5c 7c       	castu.h	r12
80002f40:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002f44:	cf 71       	brne	80002f32 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002f46:	18 97       	mov	r7,r12
80002f48:	e2 17 00 20 	andl	r7,0x20,COH
80002f4c:	f9 b7 01 04 	movne	r7,4
80002f50:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002f54:	30 09       	mov	r9,0
80002f56:	12 9a       	mov	r10,r9
80002f58:	12 9b       	mov	r11,r9
80002f5a:	30 4c       	mov	r12,4
80002f5c:	f0 1f 00 03 	mcall	80002f68 <data_flash_erase_block+0x9c>

	return return_code;
}
80002f60:	0e 9c       	mov	r12,r7
80002f62:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002f66:	00 00       	add	r0,r0
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	2b 70       	sub	r0,-73

80002f6c <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002f6c:	d4 31       	pushm	r0-r7,lr
80002f6e:	20 3d       	sub	sp,12
80002f70:	50 0c       	stdsp	sp[0x0],r12
80002f72:	16 91       	mov	r1,r11
80002f74:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002f76:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002f7a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002f7c:	e0 69 10 00 	mov	r9,4096
80002f80:	f2 0a 01 07 	sub	r7,r9,r10
80002f84:	ea 07 19 00 	cp.h	r7,r5
80002f88:	ea 07 17 b0 	movhi	r7,r5
80002f8c:	5c 87       	casts.h	r7
80002f8e:	16 92       	mov	r2,r11
80002f90:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002f94:	4a e4       	lddpc	r4,8000304c <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002f96:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002f98:	e8 c8 ff ff 	sub	r8,r4,-1
80002f9c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002f9e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002fa0:	08 9a       	mov	r10,r4
80002fa2:	e0 6b 10 00 	mov	r11,4096
80002fa6:	04 9c       	mov	r12,r2
80002fa8:	f0 1f 00 2a 	mcall	80003050 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002fac:	58 07       	cp.w	r7,0
80002fae:	c3 00       	breq	8000300e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002fb0:	40 13       	lddsp	r3,sp[0x4]
80002fb2:	5c 73       	castu.h	r3
80002fb4:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002fb8:	ec 08 18 00 	cp.b	r8,r6
80002fbc:	c1 11       	brne	80002fde <data_flash_write+0x72>
80002fbe:	e6 c9 ff ff 	sub	r9,r3,-1
80002fc2:	08 09       	add	r9,r4
80002fc4:	30 08       	mov	r8,0
80002fc6:	c0 58       	rjmp	80002fd0 <data_flash_write+0x64>
80002fc8:	13 3a       	ld.ub	r10,r9++
80002fca:	ec 0a 18 00 	cp.b	r10,r6
80002fce:	c0 81       	brne	80002fde <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002fd0:	2f f8       	sub	r8,-1
80002fd2:	5c 88       	casts.h	r8
80002fd4:	f0 07 19 00 	cp.h	r7,r8
80002fd8:	fe 9b ff f8 	brhi	80002fc8 <data_flash_write+0x5c>
80002fdc:	c1 98       	rjmp	8000300e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002fde:	30 1b       	mov	r11,1
80002fe0:	04 9c       	mov	r12,r2
80002fe2:	f0 1f 00 1d 	mcall	80003054 <data_flash_write+0xe8>
80002fe6:	40 08       	lddsp	r8,sp[0x0]
80002fe8:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002fea:	40 2a       	lddsp	r10,sp[0x8]
80002fec:	40 19       	lddsp	r9,sp[0x4]
80002fee:	12 0a       	add	r10,r9
80002ff0:	0e 99       	mov	r9,r7
80002ff2:	20 19       	sub	r9,1
80002ff4:	5c 79       	castu.h	r9
80002ff6:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002ff8:	11 39       	ld.ub	r9,r8++
80002ffa:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002ffc:	14 33       	cp.w	r3,r10
80002ffe:	cf d1       	brne	80002ff8 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80003000:	e0 6a 10 00 	mov	r10,4096
80003004:	04 9b       	mov	r11,r2
80003006:	08 9c       	mov	r12,r4
80003008:	f0 1f 00 14 	mcall	80003058 <data_flash_write+0xec>
8000300c:	c0 78       	rjmp	8000301a <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
8000300e:	0e 9a       	mov	r10,r7
80003010:	5c 7a       	castu.h	r10
80003012:	02 9b       	mov	r11,r1
80003014:	40 0c       	lddsp	r12,sp[0x0]
80003016:	f0 1f 00 11 	mcall	80003058 <data_flash_write+0xec>
8000301a:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
8000301e:	0e 98       	mov	r8,r7
80003020:	ee 05 19 00 	cp.h	r5,r7
80003024:	c1 20       	breq	80003048 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80003026:	5c 78       	castu.h	r8
80003028:	40 0a       	lddsp	r10,sp[0x0]
8000302a:	10 0a       	add	r10,r8
8000302c:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
8000302e:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80003030:	0e 15       	sub	r5,r7
80003032:	5c 85       	casts.h	r5
80003034:	e0 05 19 00 	cp.h	r5,r0
80003038:	ea 07 17 80 	movls	r7,r5
8000303c:	e0 07 17 b0 	movhi	r7,r0
80003040:	5c 87       	casts.h	r7
80003042:	30 09       	mov	r9,0
80003044:	50 19       	stdsp	sp[0x4],r9
80003046:	ca db       	rjmp	80002fa0 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80003048:	2f dd       	sub	sp,-12
8000304a:	d8 32       	popm	r0-r7,pc
8000304c:	00 00       	add	r0,r0
8000304e:	0e 20       	rsub	r0,r7
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	2d 34       	sub	r4,-45
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	2e cc       	sub	r12,-20
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	2e 0c       	sub	r12,-32

8000305c <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000305c:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000305e:	48 78       	lddpc	r8,80003078 <W25Q64_SPI_SetSpeed+0x1c>
80003060:	70 09       	ld.w	r9,r8[0x0]
80003062:	72 da       	ld.w	r10,r9[0x34]
80003064:	5c 7c       	castu.h	r12
80003066:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000306a:	f9 ea 10 0a 	or	r10,r12,r10
8000306e:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80003070:	70 0c       	ld.w	r12,r8[0x0]
80003072:	f0 1f 00 03 	mcall	8000307c <W25Q64_SPI_SetSpeed+0x20>
	
	
}
80003076:	d8 02       	popm	pc
80003078:	00 00       	add	r0,r0
8000307a:	1e 20       	rsub	r0,pc
8000307c:	80 00       	ld.sh	r0,r0[0x0]
8000307e:	66 20       	ld.w	r0,r3[0x8]

80003080 <W25Q64_SPI_SetSpeedHi>:
{
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
	
}
void W25Q64_SPI_SetSpeedHi(void)
{
80003080:	d4 01       	pushm	lr
	
	W25Q64_SPI_SetSpeed(0x0100);//baudDiv=1
80003082:	e0 6c 01 00 	mov	r12,256
80003086:	f0 1f 00 02 	mcall	8000308c <W25Q64_SPI_SetSpeedHi+0xc>
	
}
8000308a:	d8 02       	popm	pc
8000308c:	80 00       	ld.sh	r0,r0[0x0]
8000308e:	30 5c       	mov	r12,5

80003090 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003090:	eb cd 40 c0 	pushm	r6-r7,lr
80003094:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80003096:	4b a8       	lddpc	r8,8000317c <data_flash_init+0xec>
80003098:	fa c6 ff fc 	sub	r6,sp,-4
8000309c:	f0 ea 00 00 	ld.d	r10,r8[0]
800030a0:	ec eb 00 00 	st.d	r6[0],r10
800030a4:	f0 e8 00 08 	ld.d	r8,r8[8]
800030a8:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
800030ac:	30 4b       	mov	r11,4
800030ae:	4b 5c       	lddpc	r12,80003180 <data_flash_init+0xf0>
800030b0:	f0 1f 00 35 	mcall	80003184 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
800030b4:	4b 57       	lddpc	r7,80003188 <data_flash_init+0xf8>
800030b6:	fe 7c 24 00 	mov	r12,-56320
800030ba:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800030bc:	0c 9b       	mov	r11,r6
800030be:	f0 1f 00 34 	mcall	8000318c <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800030c2:	30 09       	mov	r9,0
800030c4:	12 9a       	mov	r10,r9
800030c6:	12 9b       	mov	r11,r9
800030c8:	6e 0c       	ld.w	r12,r7[0x0]
800030ca:	f0 1f 00 32 	mcall	80003190 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
800030ce:	6e 0c       	ld.w	r12,r7[0x0]
800030d0:	f0 1f 00 31 	mcall	80003194 <data_flash_init+0x104>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800030d4:	e0 6a 36 00 	mov	r10,13824
800030d8:	ea 1a 01 6e 	orh	r10,0x16e
800030dc:	0c 9b       	mov	r11,r6
800030de:	6e 0c       	ld.w	r12,r7[0x0]
800030e0:	f0 1f 00 2e 	mcall	80003198 <data_flash_init+0x108>
800030e4:	c0 50       	breq	800030ee <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
800030e6:	30 29       	mov	r9,2
800030e8:	4a d8       	lddpc	r8,8000319c <data_flash_init+0x10c>
800030ea:	b0 89       	st.b	r8[0x0],r9
		return;
800030ec:	c4 58       	rjmp	80003176 <data_flash_init+0xe6>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800030ee:	1a 96       	mov	r6,sp
800030f0:	30 4a       	mov	r10,4
800030f2:	4a cb       	lddpc	r11,800031a0 <data_flash_init+0x110>
800030f4:	1a 9c       	mov	r12,sp
800030f6:	f0 1f 00 2c 	mcall	800031a4 <data_flash_init+0x114>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
800030fa:	4a 47       	lddpc	r7,80003188 <data_flash_init+0xf8>
800030fc:	30 1b       	mov	r11,1
800030fe:	6e 0c       	ld.w	r12,r7[0x0]
80003100:	f0 1f 00 2a 	mcall	800031a8 <data_flash_init+0x118>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80003104:	e0 6b 00 90 	mov	r11,144
80003108:	6e 0c       	ld.w	r12,r7[0x0]
8000310a:	f0 1f 00 29 	mcall	800031ac <data_flash_init+0x11c>
	spi_write_zero();
8000310e:	30 0b       	mov	r11,0
80003110:	6e 0c       	ld.w	r12,r7[0x0]
80003112:	f0 1f 00 27 	mcall	800031ac <data_flash_init+0x11c>
	spi_write_zero();
80003116:	30 0b       	mov	r11,0
80003118:	6e 0c       	ld.w	r12,r7[0x0]
8000311a:	f0 1f 00 25 	mcall	800031ac <data_flash_init+0x11c>
	spi_write_zero();
8000311e:	30 0b       	mov	r11,0
80003120:	6e 0c       	ld.w	r12,r7[0x0]
80003122:	f0 1f 00 23 	mcall	800031ac <data_flash_init+0x11c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80003126:	e0 6b 00 ff 	mov	r11,255
8000312a:	6e 0c       	ld.w	r12,r7[0x0]
8000312c:	f0 1f 00 20 	mcall	800031ac <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[0]);
80003130:	1a 9b       	mov	r11,sp
80003132:	6e 0c       	ld.w	r12,r7[0x0]
80003134:	f0 1f 00 1f 	mcall	800031b0 <data_flash_init+0x120>
	
	spi_write_dummy();
80003138:	e0 6b 00 ff 	mov	r11,255
8000313c:	6e 0c       	ld.w	r12,r7[0x0]
8000313e:	f0 1f 00 1c 	mcall	800031ac <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[1]);
80003142:	fa cb ff fe 	sub	r11,sp,-2
80003146:	6e 0c       	ld.w	r12,r7[0x0]
80003148:	f0 1f 00 1a 	mcall	800031b0 <data_flash_init+0x120>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
8000314c:	30 1b       	mov	r11,1
8000314e:	6e 0c       	ld.w	r12,r7[0x0]
80003150:	f0 1f 00 19 	mcall	800031b4 <data_flash_init+0x124>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80003154:	e0 68 00 ef 	mov	r8,239
80003158:	9a 09       	ld.sh	r9,sp[0x0]
8000315a:	f0 09 19 00 	cp.h	r9,r8
8000315e:	c0 61       	brne	8000316a <data_flash_init+0xda>
80003160:	31 68       	mov	r8,22
80003162:	9a 19       	ld.sh	r9,sp[0x2]
80003164:	f0 09 19 00 	cp.h	r9,r8
80003168:	c0 50       	breq	80003172 <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
8000316a:	30 39       	mov	r9,3
8000316c:	48 c8       	lddpc	r8,8000319c <data_flash_init+0x10c>
8000316e:	b0 89       	st.b	r8[0x0],r9
		return;
80003170:	c0 38       	rjmp	80003176 <data_flash_init+0xe6>
	}

	W25Q64_SPI_SetSpeedHi();
80003172:	f0 1f 00 12 	mcall	800031b8 <data_flash_init+0x128>
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80003176:	2f bd       	sub	sp,-20
80003178:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000317c:	80 00       	ld.sh	r0,r0[0x0]
8000317e:	e6 68 80 00 	mov	r8,425984
80003182:	e6 44 80 00 	cp.w	r4,425984
80003186:	61 4c       	ld.w	r12,r0[0x50]
80003188:	00 00       	add	r0,r0
8000318a:	1e 20       	rsub	r0,pc
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	65 bc       	ld.w	r12,r2[0x6c]
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	65 f4       	ld.w	r4,r2[0x7c]
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	66 20       	ld.w	r0,r3[0x8]
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	66 64       	ld.w	r4,r3[0x18]
8000319c:	00 00       	add	r0,r0
8000319e:	0a 7c       	tst	r12,r5
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	e6 64 80 00 	mov	r4,425984
800031a6:	86 2a       	ld.sh	r10,r3[0x4]
800031a8:	80 00       	ld.sh	r0,r0[0x0]
800031aa:	67 8c       	ld.w	r12,r3[0x60]
800031ac:	80 00       	ld.sh	r0,r0[0x0]
800031ae:	66 26       	ld.w	r6,r3[0x8]
800031b0:	80 00       	ld.sh	r0,r0[0x0]
800031b2:	66 42       	ld.w	r2,r3[0x10]
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	67 4c       	ld.w	r12,r3[0x50]
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	30 80       	mov	r0,8

800031bc <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800031bc:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
800031be:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800031c0:	30 0a       	mov	r10,0
800031c2:	32 8b       	mov	r11,40
800031c4:	49 5c       	lddpc	r12,80003218 <xg_rtc_init+0x5c>
800031c6:	f0 1f 00 16 	mcall	8000321c <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
800031ca:	30 ea       	mov	r10,14
800031cc:	30 1b       	mov	r11,1
800031ce:	fe 7c 0d 00 	mov	r12,-62208
800031d2:	f0 1f 00 14 	mcall	80003220 <xg_rtc_init+0x64>
800031d6:	c0 41       	brne	800031de <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
800031d8:	49 3c       	lddpc	r12,80003224 <xg_rtc_init+0x68>
800031da:	f0 1f 00 14 	mcall	80003228 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800031de:	30 0b       	mov	r11,0
800031e0:	fe 7c 0d 00 	mov	r12,-62208
800031e4:	f0 1f 00 12 	mcall	8000322c <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800031e8:	fe 7c 0d 00 	mov	r12,-62208
800031ec:	f0 1f 00 11 	mcall	80003230 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
800031f0:	fe 7c 0d 00 	mov	r12,-62208
800031f4:	f0 1f 00 10 	mcall	80003234 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800031f8:	49 08       	lddpc	r8,80003238 <xg_rtc_init+0x7c>
800031fa:	31 09       	mov	r9,16
800031fc:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800031fe:	30 29       	mov	r9,2
80003200:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80003202:	31 d9       	mov	r9,29
80003204:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003206:	31 79       	mov	r9,23
80003208:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
8000320a:	33 b9       	mov	r9,59
8000320c:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000320e:	32 89       	mov	r9,40
80003210:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80003212:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003214:	d8 02       	popm	pc
80003216:	00 00       	add	r0,r0
80003218:	80 00       	ld.sh	r0,r0[0x0]
8000321a:	32 3c       	mov	r12,35
8000321c:	80 00       	ld.sh	r0,r0[0x0]
8000321e:	61 d0       	ld.w	r0,r0[0x74]
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	65 1c       	ld.w	r12,r2[0x44]
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	e6 78 80 00 	mov	r8,491520
8000322a:	7d 80       	ld.w	r0,lr[0x60]
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	64 d8       	ld.w	r8,r2[0x34]
80003230:	80 00       	ld.sh	r0,r0[0x0]
80003232:	64 d0       	ld.w	r0,r2[0x34]
80003234:	80 00       	ld.sh	r0,r0[0x0]
80003236:	64 ac       	ld.w	r12,r2[0x28]
80003238:	00 00       	add	r0,r0
8000323a:	0e 18       	sub	r8,r7

8000323c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
8000323c:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
8000323e:	4b 98       	lddpc	r8,80003320 <rtc_irq+0xe4>
80003240:	11 d9       	ld.ub	r9,r8[0x5]
80003242:	2f f9       	sub	r9,-1
80003244:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80003246:	11 d9       	ld.ub	r9,r8[0x5]
80003248:	33 b8       	mov	r8,59
8000324a:	f0 09 18 00 	cp.b	r9,r8
8000324e:	e0 88 00 5f 	brls	8000330c <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80003252:	4b 48       	lddpc	r8,80003320 <rtc_irq+0xe4>
80003254:	30 09       	mov	r9,0
80003256:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80003258:	11 c9       	ld.ub	r9,r8[0x4]
8000325a:	2f f9       	sub	r9,-1
8000325c:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
8000325e:	11 c9       	ld.ub	r9,r8[0x4]
80003260:	33 b8       	mov	r8,59
80003262:	f0 09 18 00 	cp.b	r9,r8
80003266:	e0 88 00 53 	brls	8000330c <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
8000326a:	4a e8       	lddpc	r8,80003320 <rtc_irq+0xe4>
8000326c:	30 09       	mov	r9,0
8000326e:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003270:	11 b9       	ld.ub	r9,r8[0x3]
80003272:	2f f9       	sub	r9,-1
80003274:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80003276:	11 b9       	ld.ub	r9,r8[0x3]
80003278:	31 78       	mov	r8,23
8000327a:	f0 09 18 00 	cp.b	r9,r8
8000327e:	e0 88 00 47 	brls	8000330c <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003282:	4a 88       	lddpc	r8,80003320 <rtc_irq+0xe4>
80003284:	30 09       	mov	r9,0
80003286:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003288:	11 88       	ld.ub	r8,r8[0x0]
8000328a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000328e:	e0 69 01 6e 	mov	r9,366
80003292:	e0 6a 01 6d 	mov	r10,365
80003296:	f4 08 17 10 	movne	r8,r10
8000329a:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000329e:	4a 19       	lddpc	r9,80003320 <rtc_irq+0xe4>
800032a0:	13 9a       	ld.ub	r10,r9[0x1]
800032a2:	30 29       	mov	r9,2
800032a4:	f2 0a 18 00 	cp.b	r10,r9
800032a8:	c0 b0       	breq	800032be <rtc_irq+0x82>
800032aa:	49 e8       	lddpc	r8,80003320 <rtc_irq+0xe4>
800032ac:	11 99       	ld.ub	r9,r8[0x1]
800032ae:	11 9a       	ld.ub	r10,r8[0x1]
800032b0:	a3 9a       	lsr	r10,0x3
800032b2:	12 0a       	add	r10,r9
800032b4:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800032b8:	2e 2a       	sub	r10,-30
800032ba:	5c 5a       	castu.b	r10
800032bc:	c0 58       	rjmp	800032c6 <rtc_irq+0x8a>
800032be:	f0 c8 01 51 	sub	r8,r8,337
800032c2:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
800032c6:	49 78       	lddpc	r8,80003320 <rtc_irq+0xe4>
800032c8:	11 a9       	ld.ub	r9,r8[0x2]
800032ca:	2f f9       	sub	r9,-1
800032cc:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
800032ce:	11 a8       	ld.ub	r8,r8[0x2]
800032d0:	f0 0a 18 00 	cp.b	r10,r8
800032d4:	c1 c2       	brcc	8000330c <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800032d6:	49 38       	lddpc	r8,80003320 <rtc_irq+0xe4>
800032d8:	30 19       	mov	r9,1
800032da:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800032dc:	11 99       	ld.ub	r9,r8[0x1]
800032de:	2f f9       	sub	r9,-1
800032e0:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800032e2:	11 99       	ld.ub	r9,r8[0x1]
800032e4:	30 c8       	mov	r8,12
800032e6:	f0 09 18 00 	cp.b	r9,r8
800032ea:	e0 88 00 11 	brls	8000330c <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800032ee:	48 d8       	lddpc	r8,80003320 <rtc_irq+0xe4>
800032f0:	30 19       	mov	r9,1
800032f2:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800032f4:	11 89       	ld.ub	r9,r8[0x0]
800032f6:	2f f9       	sub	r9,-1
800032f8:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800032fa:	11 89       	ld.ub	r9,r8[0x0]
800032fc:	39 68       	mov	r8,-106
800032fe:	f0 09 18 00 	cp.b	r9,r8
80003302:	e0 88 00 05 	brls	8000330c <rtc_irq+0xd0>
80003306:	30 09       	mov	r9,0
80003308:	48 68       	lddpc	r8,80003320 <rtc_irq+0xe4>
8000330a:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
8000330c:	fe 7c 0d 00 	mov	r12,-62208
80003310:	f0 1f 00 05 	mcall	80003324 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003314:	30 19       	mov	r9,1
80003316:	48 58       	lddpc	r8,80003328 <rtc_irq+0xec>
80003318:	91 09       	st.w	r8[0x0],r9
}
8000331a:	d4 02       	popm	lr
8000331c:	d6 03       	rete
8000331e:	00 00       	add	r0,r0
80003320:	00 00       	add	r0,r0
80003322:	0e 18       	sub	r8,r7
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	64 fc       	ld.w	r12,r2[0x3c]
80003328:	00 00       	add	r0,r0
8000332a:	04 f8       	st.b	--r2,r8

8000332c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000332c:	20 1c       	sub	r12,1
8000332e:	5c 5c       	castu.b	r12
80003330:	31 18       	mov	r8,17
80003332:	f0 0c 18 00 	cp.b	r12,r8
80003336:	e0 88 00 03 	brls	8000333c <CalculateBurst+0x10>
8000333a:	5e fd       	retal	0
8000333c:	48 28       	lddpc	r8,80003344 <CalculateBurst+0x18>
8000333e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003342:	5e fc       	retal	r12
80003344:	80 00       	ld.sh	r0,r0[0x0]
80003346:	e6 98 48 38 	brls	800ec3b6 <_data_lma+0xdd026>

80003348 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80003348:	48 38       	lddpc	r8,80003354 <payload_init+0xc>
8000334a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000334c:	48 38       	lddpc	r8,80003358 <payload_init+0x10>
8000334e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003350:	5e fc       	retal	r12
80003352:	00 00       	add	r0,r0
80003354:	00 00       	add	r0,r0
80003356:	0a 80       	andn	r0,r5
80003358:	00 00       	add	r0,r0
8000335a:	0a 84       	andn	r4,r5

8000335c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000335c:	d4 01       	pushm	lr
8000335e:	20 2d       	sub	sp,8
80003360:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003362:	30 09       	mov	r9,0
80003364:	fa ca ff f8 	sub	r10,sp,-8
80003368:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000336a:	1a 9b       	mov	r11,sp
8000336c:	f0 1f 00 02 	mcall	80003374 <set_idle_store_isr+0x18>
}
80003370:	2f ed       	sub	sp,-8
80003372:	d8 02       	popm	pc
80003374:	80 00       	ld.sh	r0,r0[0x0]
80003376:	70 e0       	ld.w	r0,r8[0x38]

80003378 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003378:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
8000337a:	48 48       	lddpc	r8,80003388 <payload_rx+0x10>
8000337c:	70 08       	ld.w	r8,r8[0x0]
8000337e:	18 9b       	mov	r11,r12
80003380:	10 9c       	mov	r12,r8
80003382:	f0 1f 00 03 	mcall	8000338c <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80003386:	d8 02       	popm	pc
80003388:	00 00       	add	r0,r0
8000338a:	0a bc       	st.h	r5++,r12
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	33 5c       	mov	r12,53

80003390 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003390:	d4 01       	pushm	lr
80003392:	20 2d       	sub	sp,8
80003394:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003396:	58 0c       	cp.w	r12,0
80003398:	c1 10       	breq	800033ba <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000339a:	30 08       	mov	r8,0
8000339c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000339e:	98 88       	ld.uh	r8,r12[0x0]
800033a0:	e2 18 f0 00 	andl	r8,0xf000,COH
800033a4:	e0 48 40 00 	cp.w	r8,16384
800033a8:	c0 91       	brne	800033ba <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800033aa:	48 68       	lddpc	r8,800033c0 <phy_rx+0x30>
800033ac:	70 0c       	ld.w	r12,r8[0x0]
800033ae:	30 09       	mov	r9,0
800033b0:	fa ca ff fc 	sub	r10,sp,-4
800033b4:	1a 9b       	mov	r11,sp
800033b6:	f0 1f 00 04 	mcall	800033c4 <phy_rx+0x34>
		}	

    }
		
 
}
800033ba:	2f ed       	sub	sp,-8
800033bc:	d8 02       	popm	pc
800033be:	00 00       	add	r0,r0
800033c0:	00 00       	add	r0,r0
800033c2:	0a c8       	st.b	r5++,r8
800033c4:	80 00       	ld.sh	r0,r0[0x0]
800033c6:	70 e0       	ld.w	r0,r8[0x38]

800033c8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800033c8:	eb cd 40 80 	pushm	r7,lr
800033cc:	20 1d       	sub	sp,4
800033ce:	fa c7 ff fc 	sub	r7,sp,-4
800033d2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800033d4:	30 09       	mov	r9,0
800033d6:	12 9a       	mov	r10,r9
800033d8:	1a 9b       	mov	r11,sp
800033da:	f0 1f 00 03 	mcall	800033e4 <set_idle_store+0x1c>
}
800033de:	2f fd       	sub	sp,-4
800033e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800033e4:	80 00       	ld.sh	r0,r0[0x0]
800033e6:	71 30       	ld.w	r0,r8[0x4c]

800033e8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800033e8:	d4 01       	pushm	lr
800033ea:	20 1d       	sub	sp,4
800033ec:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800033ee:	98 88       	ld.uh	r8,r12[0x0]
800033f0:	e2 18 f0 00 	andl	r8,0xf000,COH
800033f4:	e0 48 40 00 	cp.w	r8,16384
800033f8:	c0 d1       	brne	80003412 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800033fa:	49 08       	lddpc	r8,80003438 <phy_tx+0x50>
800033fc:	70 08       	ld.w	r8,r8[0x0]
800033fe:	58 08       	cp.w	r8,0
80003400:	c1 a0       	breq	80003434 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003402:	48 e8       	lddpc	r8,80003438 <phy_tx+0x50>
80003404:	70 0c       	ld.w	r12,r8[0x0]
80003406:	30 09       	mov	r9,0
80003408:	12 9a       	mov	r10,r9
8000340a:	1a 9b       	mov	r11,sp
8000340c:	f0 1f 00 0c 	mcall	8000343c <phy_tx+0x54>
80003410:	c1 28       	rjmp	80003434 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003412:	e0 48 10 00 	cp.w	r8,4096
80003416:	5f 0a       	sreq	r10
80003418:	e0 48 20 00 	cp.w	r8,8192
8000341c:	5f 09       	sreq	r9
8000341e:	f5 e9 10 09 	or	r9,r10,r9
80003422:	c0 71       	brne	80003430 <phy_tx+0x48>
80003424:	e0 48 50 00 	cp.w	r8,20480
80003428:	c0 40       	breq	80003430 <phy_tx+0x48>
8000342a:	e0 48 60 00 	cp.w	r8,24576
8000342e:	c0 31       	brne	80003434 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003430:	48 48       	lddpc	r8,80003440 <phy_tx+0x58>
80003432:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003434:	2f fd       	sub	sp,-4
80003436:	d8 02       	popm	pc
80003438:	00 00       	add	r0,r0
8000343a:	0a e8       	st.h	--r5,r8
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	71 30       	ld.w	r0,r8[0x4c]
80003440:	00 00       	add	r0,r0
80003442:	0a dc       	st.w	--r5,r12

80003444 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003444:	d4 01       	pushm	lr
80003446:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003448:	30 08       	mov	r8,0
8000344a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000344c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
8000344e:	1a 9a       	mov	r10,sp
80003450:	fa cb ff fc 	sub	r11,sp,-4
80003454:	f0 1f 00 05 	mcall	80003468 <get_idle_store_isr+0x24>
80003458:	58 1c       	cp.w	r12,1
8000345a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000345e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003462:	2f ed       	sub	sp,-8
80003464:	d8 02       	popm	pc
80003466:	00 00       	add	r0,r0
80003468:	80 00       	ld.sh	r0,r0[0x0]
8000346a:	6e 34       	ld.w	r4,r7[0xc]

8000346c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
8000346c:	eb cd 40 c0 	pushm	r6-r7,lr
80003470:	20 1d       	sub	sp,4
80003472:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003474:	4b a8       	lddpc	r8,8000355c <phy_tx_func+0xf0>
80003476:	70 08       	ld.w	r8,r8[0x0]
80003478:	58 08       	cp.w	r8,0
8000347a:	c6 60       	breq	80003546 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
8000347c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000347e:	30 08       	mov	r8,0
80003480:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003482:	4b 88       	lddpc	r8,80003560 <phy_tx_func+0xf4>
80003484:	70 08       	ld.w	r8,r8[0x0]
80003486:	58 18       	cp.w	r8,1
80003488:	c2 60       	breq	800034d4 <phy_tx_func+0x68>
8000348a:	c0 43       	brcs	80003492 <phy_tx_func+0x26>
8000348c:	58 28       	cp.w	r8,2
8000348e:	c5 c1       	brne	80003546 <phy_tx_func+0xda>
80003490:	c5 58       	rjmp	8000353a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003492:	4b 38       	lddpc	r8,8000355c <phy_tx_func+0xf0>
80003494:	70 0c       	ld.w	r12,r8[0x0]
80003496:	1a 9a       	mov	r10,sp
80003498:	4b 3b       	lddpc	r11,80003564 <phy_tx_func+0xf8>
8000349a:	f0 1f 00 34 	mcall	80003568 <phy_tx_func+0xfc>
8000349e:	58 1c       	cp.w	r12,1
800034a0:	c1 41       	brne	800034c8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800034a2:	4b 18       	lddpc	r8,80003564 <phy_tx_func+0xf8>
800034a4:	70 08       	ld.w	r8,r8[0x0]
800034a6:	90 08       	ld.sh	r8,r8[0x0]
800034a8:	10 9a       	mov	r10,r8
800034aa:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800034ae:	4b 09       	lddpc	r9,8000356c <phy_tx_func+0x100>
800034b0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800034b2:	5c 78       	castu.h	r8
800034b4:	ea 18 ab cd 	orh	r8,0xabcd
800034b8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800034ba:	30 19       	mov	r9,1
800034bc:	4a d8       	lddpc	r8,80003570 <phy_tx_func+0x104>
800034be:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800034c0:	30 19       	mov	r9,1
800034c2:	4a 88       	lddpc	r8,80003560 <phy_tx_func+0xf4>
800034c4:	91 09       	st.w	r8[0x0],r9
800034c6:	c4 08       	rjmp	80003546 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800034c8:	e0 68 5a 5a 	mov	r8,23130
800034cc:	ea 18 ab cd 	orh	r8,0xabcd
800034d0:	8f 18       	st.w	r7[0x4],r8
800034d2:	c3 a8       	rjmp	80003546 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800034d4:	4a 7a       	lddpc	r10,80003570 <phy_tx_func+0x104>
800034d6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800034d8:	4a 39       	lddpc	r9,80003564 <phy_tx_func+0xf8>
800034da:	72 09       	ld.w	r9,r9[0x0]
800034dc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800034e0:	b1 69       	lsl	r9,0x10
800034e2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800034e4:	2f f8       	sub	r8,-1
800034e6:	5c 58       	castu.b	r8
800034e8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800034ea:	4a 1b       	lddpc	r11,8000356c <phy_tx_func+0x100>
800034ec:	96 0c       	ld.sh	r12,r11[0x0]
800034ee:	20 2c       	sub	r12,2
800034f0:	5c 8c       	casts.h	r12
800034f2:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800034f6:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800034f8:	30 0b       	mov	r11,0
800034fa:	f6 0a 19 00 	cp.h	r10,r11
800034fe:	e0 89 00 09 	brgt	80003510 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003502:	e8 19 00 ba 	orl	r9,0xba
80003506:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003508:	30 09       	mov	r9,0
8000350a:	49 68       	lddpc	r8,80003560 <phy_tx_func+0xf4>
8000350c:	91 09       	st.w	r8[0x0],r9
8000350e:	c1 c8       	rjmp	80003546 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003510:	49 5a       	lddpc	r10,80003564 <phy_tx_func+0xf8>
80003512:	74 0a       	ld.w	r10,r10[0x0]
80003514:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003518:	14 49       	or	r9,r10
8000351a:	8f 19       	st.w	r7[0x4],r9
8000351c:	2f f8       	sub	r8,-1
8000351e:	49 59       	lddpc	r9,80003570 <phy_tx_func+0x104>
80003520:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003522:	20 2c       	sub	r12,2
80003524:	49 28       	lddpc	r8,8000356c <phy_tx_func+0x100>
80003526:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003528:	30 08       	mov	r8,0
8000352a:	f0 0c 19 00 	cp.h	r12,r8
8000352e:	e0 89 00 0c 	brgt	80003546 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003532:	30 29       	mov	r9,2
80003534:	48 b8       	lddpc	r8,80003560 <phy_tx_func+0xf4>
80003536:	91 09       	st.w	r8[0x0],r9
80003538:	c0 78       	rjmp	80003546 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000353a:	fc 18 00 ba 	movh	r8,0xba
8000353e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003540:	30 09       	mov	r9,0
80003542:	48 88       	lddpc	r8,80003560 <phy_tx_func+0xf4>
80003544:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80003546:	e0 68 5a 5a 	mov	r8,23130
8000354a:	ea 18 ab cd 	orh	r8,0xabcd
8000354e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003550:	30 08       	mov	r8,0
80003552:	8f 38       	st.w	r7[0xc],r8
}
80003554:	2f fd       	sub	sp,-4
80003556:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000355a:	00 00       	add	r0,r0
8000355c:	00 00       	add	r0,r0
8000355e:	0a e8       	st.h	--r5,r8
80003560:	00 00       	add	r0,r0
80003562:	0a a8       	st.w	r5++,r8
80003564:	00 00       	add	r0,r0
80003566:	0a b4       	st.h	r5++,r4
80003568:	80 00       	ld.sh	r0,r0[0x0]
8000356a:	6e 34       	ld.w	r4,r7[0xc]
8000356c:	00 00       	add	r0,r0
8000356e:	0a d0       	st.w	--r5,r0
80003570:	00 00       	add	r0,r0
80003572:	0a 88       	andn	r8,r5

80003574 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003574:	d4 01       	pushm	lr
80003576:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003578:	30 0a       	mov	r10,0
8000357a:	fa cb ff fc 	sub	r11,sp,-4
8000357e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003580:	14 99       	mov	r9,r10
80003582:	1a 9b       	mov	r11,sp
80003584:	f0 1f 00 05 	mcall	80003598 <get_idle_store+0x24>
80003588:	58 1c       	cp.w	r12,1
8000358a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000358e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003592:	2f fd       	sub	sp,-4
80003594:	d8 02       	popm	pc
80003596:	00 00       	add	r0,r0
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	6f 24       	ld.w	r4,r7[0x48]

8000359c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
8000359c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000359e:	48 5b       	lddpc	r11,800035b0 <phy_init+0x14>
800035a0:	48 5c       	lddpc	r12,800035b4 <phy_init+0x18>
800035a2:	f0 1f 00 06 	mcall	800035b8 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
800035a6:	f0 1f 00 06 	mcall	800035bc <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800035aa:	f0 1f 00 06 	mcall	800035c0 <phy_init+0x24>
	
}
800035ae:	d8 02       	popm	pc
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	34 6c       	mov	r12,70
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	35 c4       	mov	r4,92
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	46 18       	lddsp	r8,sp[0x184]
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	46 2c       	lddsp	r12,sp[0x188]
800035c0:	80 00       	ld.sh	r0,r0[0x0]
800035c2:	4f d8       	lddpc	r8,800037b4 <phy_rx_func+0x1f0>

800035c4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800035c4:	eb cd 40 e0 	pushm	r5-r7,lr
800035c8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800035ca:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800035ce:	70 08       	ld.w	r8,r8[0x0]
800035d0:	58 08       	cp.w	r8,0
800035d2:	e0 80 01 08 	breq	800037e2 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800035d6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800035d8:	fe f8 0e 70 	ld.w	r8,pc[3696]
800035dc:	70 09       	ld.w	r9,r8[0x0]
800035de:	2f f9       	sub	r9,-1
800035e0:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800035e2:	fe f8 0e 6a 	ld.w	r8,pc[3690]
800035e6:	70 08       	ld.w	r8,r8[0x0]
800035e8:	58 18       	cp.w	r8,1
800035ea:	e0 80 00 85 	breq	800036f4 <phy_rx_func+0x130>
800035ee:	c0 73       	brcs	800035fc <phy_rx_func+0x38>
800035f0:	58 28       	cp.w	r8,2
800035f2:	c5 c0       	breq	800036aa <phy_rx_func+0xe6>
800035f4:	58 38       	cp.w	r8,3
800035f6:	e0 81 00 f6 	brne	800037e2 <phy_rx_func+0x21e>
800035fa:	cd 58       	rjmp	800037a4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800035fc:	e0 6a 5a 5a 	mov	r10,23130
80003600:	ea 1a ab cd 	orh	r10,0xabcd
80003604:	14 36       	cp.w	r6,r10
80003606:	e0 80 00 ee 	breq	800037e2 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000360a:	ec 08 16 10 	lsr	r8,r6,0x10
8000360e:	e0 48 ab cd 	cp.w	r8,43981
80003612:	e0 81 00 e8 	brne	800037e2 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003616:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000361a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000361e:	20 28       	sub	r8,2
80003620:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003624:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003626:	30 09       	mov	r9,0
80003628:	f2 08 19 00 	cp.h	r8,r9
8000362c:	e0 8a 00 db 	brle	800037e2 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003630:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003634:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003636:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000363a:	70 0c       	ld.w	r12,r8[0x0]
8000363c:	f0 1f 03 88 	mcall	8000445c <phy_rx_func+0xe98>
80003640:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003644:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003646:	58 0c       	cp.w	r12,0
80003648:	e0 80 00 cd 	breq	800037e2 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000364c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003650:	90 09       	ld.sh	r9,r8[0x0]
80003652:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003656:	2f f9       	sub	r9,-1
80003658:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000365a:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000365e:	74 0a       	ld.w	r10,r10[0x0]
80003660:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003664:	76 0b       	ld.w	r11,r11[0x0]
80003666:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000366a:	2f f9       	sub	r9,-1
8000366c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000366e:	e2 16 0f 00 	andl	r6,0xf00,COH
80003672:	e0 46 01 00 	cp.w	r6,256
80003676:	c0 c0       	breq	8000368e <phy_rx_func+0xca>
80003678:	e0 8b 00 05 	brhi	80003682 <phy_rx_func+0xbe>
8000367c:	58 06       	cp.w	r6,0
8000367e:	c0 80       	breq	8000368e <phy_rx_func+0xca>
80003680:	c0 c8       	rjmp	80003698 <phy_rx_func+0xd4>
80003682:	e0 46 02 00 	cp.w	r6,512
80003686:	c0 40       	breq	8000368e <phy_rx_func+0xca>
80003688:	e0 46 03 00 	cp.w	r6,768
8000368c:	c0 61       	brne	80003698 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000368e:	30 29       	mov	r9,2
80003690:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003694:	91 09       	st.w	r8[0x0],r9
80003696:	ca 68       	rjmp	800037e2 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003698:	fe f8 0d c0 	ld.w	r8,pc[3520]
8000369c:	70 0c       	ld.w	r12,r8[0x0]
8000369e:	fe f8 0d c2 	ld.w	r8,pc[3522]
800036a2:	70 0b       	ld.w	r11,r8[0x0]
800036a4:	f0 1f 03 70 	mcall	80004464 <phy_rx_func+0xea0>
800036a8:	c9 d8       	rjmp	800037e2 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800036aa:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800036ae:	b1 86       	lsr	r6,0x10
800036b0:	14 06       	add	r6,r10
800036b2:	fe f8 0d b6 	ld.w	r8,pc[3510]
800036b6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800036b8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800036bc:	90 09       	ld.sh	r9,r8[0x0]
800036be:	fe fb 0d a2 	ld.w	r11,pc[3490]
800036c2:	76 0b       	ld.w	r11,r11[0x0]
800036c4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800036c8:	2f f9       	sub	r9,-1
800036ca:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800036cc:	fe f9 0d 84 	ld.w	r9,pc[3460]
800036d0:	92 08       	ld.sh	r8,r9[0x0]
800036d2:	20 28       	sub	r8,2
800036d4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800036d6:	30 09       	mov	r9,0
800036d8:	f2 08 19 00 	cp.h	r8,r9
800036dc:	e0 8a 00 07 	brle	800036ea <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800036e0:	30 19       	mov	r9,1
800036e2:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800036e6:	91 09       	st.w	r8[0x0],r9
800036e8:	c7 d8       	rjmp	800037e2 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800036ea:	30 39       	mov	r9,3
800036ec:	fe f8 0d 60 	ld.w	r8,pc[3424]
800036f0:	91 09       	st.w	r8[0x0],r9
800036f2:	c7 88       	rjmp	800037e2 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800036f4:	ec 0a 14 10 	asr	r10,r6,0x10
800036f8:	fe f8 0d 70 	ld.w	r8,pc[3440]
800036fc:	90 09       	ld.sh	r9,r8[0x0]
800036fe:	14 09       	add	r9,r10
80003700:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003702:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003706:	92 08       	ld.sh	r8,r9[0x0]
80003708:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000370c:	76 0b       	ld.w	r11,r11[0x0]
8000370e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003712:	2f f8       	sub	r8,-1
80003714:	5c 88       	casts.h	r8
80003716:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003718:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000371c:	94 09       	ld.sh	r9,r10[0x0]
8000371e:	20 29       	sub	r9,2
80003720:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003722:	30 0a       	mov	r10,0
80003724:	f4 09 19 00 	cp.h	r9,r10
80003728:	e0 89 00 20 	brgt	80003768 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000372c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003730:	e0 46 00 ba 	cp.w	r6,186
80003734:	c0 d1       	brne	8000374e <phy_rx_func+0x18a>
80003736:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000373a:	90 09       	ld.sh	r9,r8[0x0]
8000373c:	f4 09 19 00 	cp.h	r9,r10
80003740:	c0 71       	brne	8000374e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003742:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003746:	70 0c       	ld.w	r12,r8[0x0]
80003748:	f0 1f 03 49 	mcall	8000446c <phy_rx_func+0xea8>
8000374c:	c0 98       	rjmp	8000375e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000374e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003752:	70 0c       	ld.w	r12,r8[0x0]
80003754:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003758:	70 0b       	ld.w	r11,r8[0x0]
8000375a:	f0 1f 03 43 	mcall	80004464 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000375e:	30 09       	mov	r9,0
80003760:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	c3 e8       	rjmp	800037e2 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003768:	5c 86       	casts.h	r6
8000376a:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000376e:	92 0a       	ld.sh	r10,r9[0x0]
80003770:	0c 0a       	add	r10,r6
80003772:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003774:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003778:	72 09       	ld.w	r9,r9[0x0]
8000377a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000377e:	2f f8       	sub	r8,-1
80003780:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003784:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003786:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000378a:	92 08       	ld.sh	r8,r9[0x0]
8000378c:	20 28       	sub	r8,2
8000378e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003790:	30 09       	mov	r9,0
80003792:	f2 08 19 00 	cp.h	r8,r9
80003796:	e0 89 00 26 	brgt	800037e2 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000379a:	30 39       	mov	r9,3
8000379c:	fe f8 0c b0 	ld.w	r8,pc[3248]
800037a0:	91 09       	st.w	r8[0x0],r9
800037a2:	c2 08       	rjmp	800037e2 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800037a4:	e6 16 00 ff 	andh	r6,0xff,COH
800037a8:	fc 19 00 ba 	movh	r9,0xba
800037ac:	12 36       	cp.w	r6,r9
800037ae:	c0 e1       	brne	800037ca <phy_rx_func+0x206>
800037b0:	fe f8 0c b8 	ld.w	r8,pc[3256]
800037b4:	90 09       	ld.sh	r9,r8[0x0]
800037b6:	30 08       	mov	r8,0
800037b8:	f0 09 19 00 	cp.h	r9,r8
800037bc:	c0 71       	brne	800037ca <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800037be:	fe f8 0c a2 	ld.w	r8,pc[3234]
800037c2:	70 0c       	ld.w	r12,r8[0x0]
800037c4:	f0 1f 03 2a 	mcall	8000446c <phy_rx_func+0xea8>
800037c8:	c0 98       	rjmp	800037da <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800037ca:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800037ce:	70 0c       	ld.w	r12,r8[0x0]
800037d0:	fe f8 0c 90 	ld.w	r8,pc[3216]
800037d4:	70 0b       	ld.w	r11,r8[0x0]
800037d6:	f0 1f 03 24 	mcall	80004464 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800037da:	30 09       	mov	r9,0
800037dc:	fe f8 0c 70 	ld.w	r8,pc[3184]
800037e0:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800037e2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800037e6:	11 89       	ld.ub	r9,r8[0x0]
800037e8:	30 08       	mov	r8,0
800037ea:	f0 09 18 00 	cp.b	r9,r8
800037ee:	c1 31       	brne	80003814 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800037f0:	fe f6 0c 84 	ld.w	r6,pc[3204]
800037f4:	6c 0c       	ld.w	r12,r6[0x0]
800037f6:	f0 1f 03 1a 	mcall	8000445c <phy_rx_func+0xe98>
800037fa:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800037fe:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003800:	6c 0c       	ld.w	r12,r6[0x0]
80003802:	f0 1f 03 17 	mcall	8000445c <phy_rx_func+0xe98>
80003806:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000380a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000380c:	30 19       	mov	r9,1
8000380e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003812:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003814:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003818:	70 08       	ld.w	r8,r8[0x0]
8000381a:	58 28       	cp.w	r8,2
8000381c:	e0 80 01 98 	breq	80003b4c <phy_rx_func+0x588>
80003820:	e0 8b 00 06 	brhi	8000382c <phy_rx_func+0x268>
80003824:	58 08       	cp.w	r8,0
80003826:	c0 b0       	breq	8000383c <phy_rx_func+0x278>
80003828:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000382c:	58 38       	cp.w	r8,3
8000382e:	e0 80 05 c5 	breq	800043b8 <phy_rx_func+0xdf4>
80003832:	58 48       	cp.w	r8,4
80003834:	e0 81 06 05 	brne	8000443e <phy_rx_func+0xe7a>
80003838:	e0 8f 02 4b 	bral	80003cce <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000383c:	6e 28       	ld.w	r8,r7[0x8]
8000383e:	e0 6a 5a 5a 	mov	r10,23130
80003842:	ea 1a ab cd 	orh	r10,0xabcd
80003846:	14 38       	cp.w	r8,r10
80003848:	c0 71       	brne	80003856 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000384a:	30 09       	mov	r9,0
8000384c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003850:	91 09       	st.w	r8[0x0],r9
80003852:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003856:	10 99       	mov	r9,r8
80003858:	e0 19 00 00 	andl	r9,0x0
8000385c:	fc 1a ab cd 	movh	r10,0xabcd
80003860:	14 39       	cp.w	r9,r10
80003862:	e0 81 05 ee 	brne	8000443e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003866:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000386a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000386e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003870:	6e 29       	ld.w	r9,r7[0x8]
80003872:	e2 19 f0 00 	andl	r9,0xf000,COH
80003876:	e0 49 c0 00 	cp.w	r9,49152
8000387a:	e0 81 00 ce 	brne	80003a16 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000387e:	30 1a       	mov	r10,1
80003880:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003884:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003886:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000388a:	72 09       	ld.w	r9,r9[0x0]
8000388c:	58 09       	cp.w	r9,0
8000388e:	c0 71       	brne	8000389c <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003890:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003894:	f0 1f 03 00 	mcall	80004494 <phy_rx_func+0xed0>
80003898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
8000389c:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800038a0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800038a4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800038a6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038aa:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800038ae:	fe fa 0b ee 	ld.w	r10,pc[3054]
800038b2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800038b4:	13 89       	ld.ub	r9,r9[0x0]
800038b6:	37 fa       	mov	r10,127
800038b8:	f4 09 18 00 	cp.b	r9,r10
800038bc:	c6 d0       	breq	80003996 <phy_rx_func+0x3d2>
800038be:	e0 8b 00 0c 	brhi	800038d6 <phy_rx_func+0x312>
800038c2:	31 2a       	mov	r10,18
800038c4:	f4 09 18 00 	cp.b	r9,r10
800038c8:	c4 20       	breq	8000394c <phy_rx_func+0x388>
800038ca:	31 3a       	mov	r10,19
800038cc:	f4 09 18 00 	cp.b	r9,r10
800038d0:	e0 81 00 83 	brne	800039d6 <phy_rx_func+0x412>
800038d4:	c5 b8       	rjmp	8000398a <phy_rx_func+0x3c6>
800038d6:	2f 09       	sub	r9,-16
800038d8:	30 1a       	mov	r10,1
800038da:	f4 09 18 00 	cp.b	r9,r10
800038de:	e0 8b 00 7c 	brhi	800039d6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800038e2:	ef 38 00 0e 	ld.ub	r8,r7[14]
800038e6:	e2 18 00 f0 	andl	r8,0xf0,COH
800038ea:	59 08       	cp.w	r8,16
800038ec:	c0 71       	brne	800038fa <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800038ee:	30 19       	mov	r9,1
800038f0:	fe f8 0b 94 	ld.w	r8,pc[2964]
800038f4:	91 09       	st.w	r8[0x0],r9
800038f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800038fa:	e0 48 00 20 	cp.w	r8,32
800038fe:	c2 11       	brne	80003940 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003900:	30 a9       	mov	r9,10
80003902:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003906:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003908:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000390c:	6c 08       	ld.w	r8,r6[0x0]
8000390e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003912:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003916:	2f f8       	sub	r8,-1
80003918:	6e 0c       	ld.w	r12,r7[0x0]
8000391a:	f4 ca fe 00 	sub	r10,r10,-512
8000391e:	30 0b       	mov	r11,0
80003920:	10 0c       	add	r12,r8
80003922:	f0 1f 02 e1 	mcall	800044a4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003926:	30 08       	mov	r8,0
80003928:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000392a:	6e 0c       	ld.w	r12,r7[0x0]
8000392c:	f0 1f 02 df 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003930:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003934:	70 0c       	ld.w	r12,r8[0x0]
80003936:	f0 1f 02 ca 	mcall	8000445c <phy_rx_func+0xe98>
8000393a:	8f 0c       	st.w	r7[0x0],r12
8000393c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003940:	30 09       	mov	r9,0
80003942:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003946:	91 09       	st.w	r8[0x0],r9
80003948:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000394c:	20 48       	sub	r8,4
8000394e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003952:	93 08       	st.w	r9[0x0],r8
80003954:	58 08       	cp.w	r8,0
80003956:	e0 80 05 74 	breq	8000443e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000395a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000395e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003962:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003966:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003968:	8e 69       	ld.sh	r9,r7[0xc]
8000396a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000396e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003970:	8e 79       	ld.sh	r9,r7[0xe]
80003972:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003974:	f0 1f 02 d0 	mcall	800044b4 <phy_rx_func+0xef0>
80003978:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000397c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000397e:	30 49       	mov	r9,4
80003980:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003984:	91 09       	st.w	r8[0x0],r9
80003986:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000398a:	30 09       	mov	r9,0
8000398c:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003990:	91 09       	st.w	r8[0x0],r9
80003992:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003996:	20 48       	sub	r8,4
80003998:	fe f9 0a f0 	ld.w	r9,pc[2800]
8000399c:	93 08       	st.w	r9[0x0],r8
8000399e:	58 08       	cp.w	r8,0
800039a0:	e0 80 05 4f 	breq	8000443e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800039a4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	8e 7b       	ld.sh	r11,r7[0xe]
800039ac:	fe fa 0b 10 	ld.w	r10,pc[2832]
800039b0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800039b8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800039bc:	70 09       	ld.w	r9,r8[0x0]
800039be:	20 29       	sub	r9,2
800039c0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800039c2:	30 29       	mov	r9,2
800039c4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800039c8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800039ca:	30 39       	mov	r9,3
800039cc:	fe f8 0a b4 	ld.w	r8,pc[2740]
800039d0:	91 09       	st.w	r8[0x0],r9
800039d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800039d6:	30 3a       	mov	r10,3
800039d8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800039dc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800039de:	6e 2a       	ld.w	r10,r7[0x8]
800039e0:	fe f9 0a e0 	ld.w	r9,pc[2784]
800039e4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800039e6:	6e 3a       	ld.w	r10,r7[0xc]
800039e8:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800039ea:	59 48       	cp.w	r8,20
800039ec:	c0 61       	brne	800039f8 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800039ee:	31 89       	mov	r9,24
800039f0:	fe f8 0a 98 	ld.w	r8,pc[2712]
800039f4:	91 09       	st.w	r8[0x0],r9
800039f6:	c0 a8       	rjmp	80003a0a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800039f8:	fe f8 0a 90 	ld.w	r8,pc[2704]
800039fc:	70 08       	ld.w	r8,r8[0x0]
800039fe:	59 08       	cp.w	r8,16
80003a00:	c0 51       	brne	80003a0a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003a02:	31 09       	mov	r9,16
80003a04:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003a08:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a0a:	30 49       	mov	r9,4
80003a0c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003a10:	91 09       	st.w	r8[0x0],r9
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003a16:	e0 49 10 00 	cp.w	r9,4096
80003a1a:	5f 1a       	srne	r10
80003a1c:	e0 49 20 00 	cp.w	r9,8192
80003a20:	5f 19       	srne	r9
80003a22:	f5 e9 00 09 	and	r9,r10,r9
80003a26:	e0 81 05 0c 	brne	8000443e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003a2a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003a2e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003a30:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003a34:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003a36:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003a3a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003a3c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003a40:	72 09       	ld.w	r9,r9[0x0]
80003a42:	58 09       	cp.w	r9,0
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a46:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003a4a:	f0 1f 02 93 	mcall	80004494 <phy_rx_func+0xed0>
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a52:	6e 2a       	ld.w	r10,r7[0x8]
80003a54:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003a58:	58 1a       	cp.w	r10,1
80003a5a:	e0 8b 00 4d 	brhi	80003af4 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003a5e:	20 48       	sub	r8,4
80003a60:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003a64:	93 08       	st.w	r9[0x0],r8
80003a66:	58 08       	cp.w	r8,0
80003a68:	e0 80 04 eb 	breq	8000443e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003a6c:	8e 68       	ld.sh	r8,r7[0xc]
80003a6e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003a72:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003a76:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003a78:	30 09       	mov	r9,0
80003a7a:	f2 08 19 00 	cp.h	r8,r9
80003a7e:	c0 70       	breq	80003a8c <phy_rx_func+0x4c8>
80003a80:	30 19       	mov	r9,1
80003a82:	f2 08 19 00 	cp.h	r8,r9
80003a86:	e0 81 04 dc 	brne	8000443e <phy_rx_func+0xe7a>
80003a8a:	c2 68       	rjmp	80003ad6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003a8c:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003a90:	70 0a       	ld.w	r10,r8[0x0]
80003a92:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003a96:	72 09       	ld.w	r9,r9[0x0]
80003a98:	8e 7b       	ld.sh	r11,r7[0xe]
80003a9a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003a9e:	70 09       	ld.w	r9,r8[0x0]
80003aa0:	2f f9       	sub	r9,-1
80003aa2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003aa4:	e0 49 00 ff 	cp.w	r9,255
80003aa8:	e0 88 00 11 	brls	80003aca <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003aac:	30 09       	mov	r9,0
80003aae:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003ab0:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003ab4:	6e 0c       	ld.w	r12,r7[0x0]
80003ab6:	f0 1f 02 7d 	mcall	800044a8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003aba:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003abe:	70 0c       	ld.w	r12,r8[0x0]
80003ac0:	f0 1f 02 67 	mcall	8000445c <phy_rx_func+0xe98>
80003ac4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003ac6:	e0 80 04 bc 	breq	8000443e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003aca:	30 29       	mov	r9,2
80003acc:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003ad0:	91 09       	st.w	r8[0x0],r9
80003ad2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ad6:	8e 79       	ld.sh	r9,r7[0xe]
80003ad8:	30 38       	mov	r8,3
80003ada:	f0 09 19 00 	cp.h	r9,r8
80003ade:	c0 51       	brne	80003ae8 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003ae0:	30 19       	mov	r9,1
80003ae2:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003ae6:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003ae8:	30 29       	mov	r9,2
80003aea:	fe f8 09 96 	ld.w	r8,pc[2454]
80003aee:	91 09       	st.w	r8[0x0],r9
80003af0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003af4:	58 18       	cp.w	r8,1
80003af6:	e0 88 04 a4 	brls	8000443e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003afa:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003afe:	70 0a       	ld.w	r10,r8[0x0]
80003b00:	6e 3b       	ld.w	r11,r7[0xc]
80003b02:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003b06:	70 09       	ld.w	r9,r8[0x0]
80003b08:	2f f9       	sub	r9,-1
80003b0a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b0c:	e0 49 00 ff 	cp.w	r9,255
80003b10:	e0 88 00 11 	brls	80003b32 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003b14:	30 09       	mov	r9,0
80003b16:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003b18:	fe f7 09 60 	ld.w	r7,pc[2400]
80003b1c:	6e 0c       	ld.w	r12,r7[0x0]
80003b1e:	f0 1f 02 63 	mcall	800044a8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003b22:	fe f8 09 52 	ld.w	r8,pc[2386]
80003b26:	70 0c       	ld.w	r12,r8[0x0]
80003b28:	f0 1f 02 4d 	mcall	8000445c <phy_rx_func+0xe98>
80003b2c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003b2e:	e0 80 04 88 	breq	8000443e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003b32:	fe f9 09 56 	ld.w	r9,pc[2390]
80003b36:	72 08       	ld.w	r8,r9[0x0]
80003b38:	20 28       	sub	r8,2
80003b3a:	93 08       	st.w	r9[0x0],r8
80003b3c:	e0 80 04 81 	breq	8000443e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003b40:	30 29       	mov	r9,2
80003b42:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003b46:	91 09       	st.w	r8[0x0],r9
80003b48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003b4c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003b50:	70 0a       	ld.w	r10,r8[0x0]
80003b52:	fe f9 09 26 	ld.w	r9,pc[2342]
80003b56:	72 09       	ld.w	r9,r9[0x0]
80003b58:	8e 4b       	ld.sh	r11,r7[0x8]
80003b5a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003b5e:	70 09       	ld.w	r9,r8[0x0]
80003b60:	2f f9       	sub	r9,-1
80003b62:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b64:	e0 49 00 ff 	cp.w	r9,255
80003b68:	e0 88 00 16 	brls	80003b94 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003b6c:	30 09       	mov	r9,0
80003b6e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003b70:	fe f6 09 08 	ld.w	r6,pc[2312]
80003b74:	6c 0c       	ld.w	r12,r6[0x0]
80003b76:	f0 1f 02 4d 	mcall	800044a8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003b7a:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003b7e:	70 0c       	ld.w	r12,r8[0x0]
80003b80:	f0 1f 02 37 	mcall	8000445c <phy_rx_func+0xe98>
80003b84:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003b86:	c0 71       	brne	80003b94 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003b88:	30 09       	mov	r9,0
80003b8a:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003b8e:	91 09       	st.w	r8[0x0],r9
80003b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003b94:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003b98:	72 08       	ld.w	r8,r9[0x0]
80003b9a:	20 28       	sub	r8,2
80003b9c:	93 08       	st.w	r9[0x0],r8
80003b9e:	c0 71       	brne	80003bac <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003ba0:	30 09       	mov	r9,0
80003ba2:	fe f8 08 de 	ld.w	r8,pc[2270]
80003ba6:	91 09       	st.w	r8[0x0],r9
80003ba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003bac:	fe f8 09 24 	ld.w	r8,pc[2340]
80003bb0:	70 0a       	ld.w	r10,r8[0x0]
80003bb2:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003bb6:	72 09       	ld.w	r9,r9[0x0]
80003bb8:	8e 5b       	ld.sh	r11,r7[0xa]
80003bba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003bbe:	70 09       	ld.w	r9,r8[0x0]
80003bc0:	2f f9       	sub	r9,-1
80003bc2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003bc4:	e0 49 00 ff 	cp.w	r9,255
80003bc8:	e0 88 00 16 	brls	80003bf4 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003bcc:	30 09       	mov	r9,0
80003bce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003bd0:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003bd4:	6c 0c       	ld.w	r12,r6[0x0]
80003bd6:	f0 1f 02 35 	mcall	800044a8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003bda:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003bde:	70 0c       	ld.w	r12,r8[0x0]
80003be0:	f0 1f 02 1f 	mcall	8000445c <phy_rx_func+0xe98>
80003be4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003be6:	c0 71       	brne	80003bf4 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003be8:	30 09       	mov	r9,0
80003bea:	fe f8 08 96 	ld.w	r8,pc[2198]
80003bee:	91 09       	st.w	r8[0x0],r9
80003bf0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003bf4:	fe f9 08 94 	ld.w	r9,pc[2196]
80003bf8:	72 08       	ld.w	r8,r9[0x0]
80003bfa:	20 28       	sub	r8,2
80003bfc:	93 08       	st.w	r9[0x0],r8
80003bfe:	c0 71       	brne	80003c0c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003c00:	30 09       	mov	r9,0
80003c02:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003c06:	91 09       	st.w	r8[0x0],r9
80003c08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003c0c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003c10:	70 0a       	ld.w	r10,r8[0x0]
80003c12:	fe f9 08 66 	ld.w	r9,pc[2150]
80003c16:	72 09       	ld.w	r9,r9[0x0]
80003c18:	8e 6b       	ld.sh	r11,r7[0xc]
80003c1a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c1e:	70 09       	ld.w	r9,r8[0x0]
80003c20:	2f f9       	sub	r9,-1
80003c22:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c24:	e0 49 00 ff 	cp.w	r9,255
80003c28:	e0 88 00 16 	brls	80003c54 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003c2c:	30 09       	mov	r9,0
80003c2e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c30:	fe f6 08 48 	ld.w	r6,pc[2120]
80003c34:	6c 0c       	ld.w	r12,r6[0x0]
80003c36:	f0 1f 02 1d 	mcall	800044a8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c3a:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003c3e:	70 0c       	ld.w	r12,r8[0x0]
80003c40:	f0 1f 02 07 	mcall	8000445c <phy_rx_func+0xe98>
80003c44:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003c46:	c0 71       	brne	80003c54 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003c48:	30 09       	mov	r9,0
80003c4a:	fe f8 08 36 	ld.w	r8,pc[2102]
80003c4e:	91 09       	st.w	r8[0x0],r9
80003c50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003c54:	fe f9 08 34 	ld.w	r9,pc[2100]
80003c58:	72 08       	ld.w	r8,r9[0x0]
80003c5a:	20 28       	sub	r8,2
80003c5c:	93 08       	st.w	r9[0x0],r8
80003c5e:	c0 71       	brne	80003c6c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003c60:	30 09       	mov	r9,0
80003c62:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c6c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003c70:	70 0a       	ld.w	r10,r8[0x0]
80003c72:	fe f9 08 06 	ld.w	r9,pc[2054]
80003c76:	72 09       	ld.w	r9,r9[0x0]
80003c78:	8e 7b       	ld.sh	r11,r7[0xe]
80003c7a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c7e:	70 09       	ld.w	r9,r8[0x0]
80003c80:	2f f9       	sub	r9,-1
80003c82:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c84:	e0 49 00 ff 	cp.w	r9,255
80003c88:	e0 88 00 16 	brls	80003cb4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003c8c:	30 09       	mov	r9,0
80003c8e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c90:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003c94:	6e 0c       	ld.w	r12,r7[0x0]
80003c96:	f0 1f 02 05 	mcall	800044a8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c9a:	fe f8 07 da 	ld.w	r8,pc[2010]
80003c9e:	70 0c       	ld.w	r12,r8[0x0]
80003ca0:	f0 1f 01 ef 	mcall	8000445c <phy_rx_func+0xe98>
80003ca4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003ca6:	c0 71       	brne	80003cb4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003ca8:	30 09       	mov	r9,0
80003caa:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003cae:	91 09       	st.w	r8[0x0],r9
80003cb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003cb4:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003cb8:	72 08       	ld.w	r8,r9[0x0]
80003cba:	20 28       	sub	r8,2
80003cbc:	93 08       	st.w	r9[0x0],r8
80003cbe:	e0 81 03 c0 	brne	8000443e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003cc2:	30 09       	mov	r9,0
80003cc4:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003cc8:	91 09       	st.w	r8[0x0],r9
80003cca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003cce:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003cd2:	11 89       	ld.ub	r9,r8[0x0]
80003cd4:	31 28       	mov	r8,18
80003cd6:	f0 09 18 00 	cp.b	r9,r8
80003cda:	e0 81 01 4c 	brne	80003f72 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003cde:	ef 39 00 09 	ld.ub	r9,r7[9]
80003ce2:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003ce6:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003ce8:	11 89       	ld.ub	r9,r8[0x0]
80003cea:	3f 28       	mov	r8,-14
80003cec:	f0 09 18 00 	cp.b	r9,r8
80003cf0:	e0 81 01 3b 	brne	80003f66 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003cf4:	30 19       	mov	r9,1
80003cf6:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003cfa:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003cfc:	6e 29       	ld.w	r9,r7[0x8]
80003cfe:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003d02:	fe f8 07 86 	ld.w	r8,pc[1926]
80003d06:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003d08:	8e 59       	ld.sh	r9,r7[0xa]
80003d0a:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003d0e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003d10:	8e 69       	ld.sh	r9,r7[0xc]
80003d12:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003d14:	8e 79       	ld.sh	r9,r7[0xe]
80003d16:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003d18:	fe f8 07 88 	ld.w	r8,pc[1928]
80003d1c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003d20:	72 0a       	ld.w	r10,r9[0x0]
80003d22:	70 09       	ld.w	r9,r8[0x0]
80003d24:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003d28:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d2c:	70 09       	ld.w	r9,r8[0x0]
80003d2e:	2f f9       	sub	r9,-1
80003d30:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d32:	e0 49 01 ff 	cp.w	r9,511
80003d36:	e0 88 00 16 	brls	80003d62 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d3a:	30 09       	mov	r9,0
80003d3c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d3e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003d42:	6c 0c       	ld.w	r12,r6[0x0]
80003d44:	f0 1f 01 d9 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d48:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003d4c:	70 0c       	ld.w	r12,r8[0x0]
80003d4e:	f0 1f 01 c4 	mcall	8000445c <phy_rx_func+0xe98>
80003d52:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d54:	c0 71       	brne	80003d62 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003d56:	30 09       	mov	r9,0
80003d58:	fe f8 07 28 	ld.w	r8,pc[1832]
80003d5c:	91 09       	st.w	r8[0x0],r9
80003d5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d62:	fe f9 07 26 	ld.w	r9,pc[1830]
80003d66:	72 08       	ld.w	r8,r9[0x0]
80003d68:	20 18       	sub	r8,1
80003d6a:	93 08       	st.w	r9[0x0],r8
80003d6c:	c0 71       	brne	80003d7a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003d6e:	30 09       	mov	r9,0
80003d70:	fe f8 07 10 	ld.w	r8,pc[1808]
80003d74:	91 09       	st.w	r8[0x0],r9
80003d76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003d7a:	fe f8 07 26 	ld.w	r8,pc[1830]
80003d7e:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003d82:	72 0a       	ld.w	r10,r9[0x0]
80003d84:	70 09       	ld.w	r9,r8[0x0]
80003d86:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003d8a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d8e:	70 09       	ld.w	r9,r8[0x0]
80003d90:	2f f9       	sub	r9,-1
80003d92:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d94:	e0 49 01 ff 	cp.w	r9,511
80003d98:	e0 88 00 16 	brls	80003dc4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d9c:	30 09       	mov	r9,0
80003d9e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003da0:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003da4:	6c 0c       	ld.w	r12,r6[0x0]
80003da6:	f0 1f 01 c1 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003daa:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003dae:	70 0c       	ld.w	r12,r8[0x0]
80003db0:	f0 1f 01 ab 	mcall	8000445c <phy_rx_func+0xe98>
80003db4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003db6:	c0 71       	brne	80003dc4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003db8:	30 09       	mov	r9,0
80003dba:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003dbe:	91 09       	st.w	r8[0x0],r9
80003dc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003dc4:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003dc8:	72 08       	ld.w	r8,r9[0x0]
80003dca:	20 18       	sub	r8,1
80003dcc:	93 08       	st.w	r9[0x0],r8
80003dce:	c0 71       	brne	80003ddc <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003dd0:	30 09       	mov	r9,0
80003dd2:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003dd6:	91 09       	st.w	r8[0x0],r9
80003dd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003ddc:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003de0:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003de4:	72 0a       	ld.w	r10,r9[0x0]
80003de6:	70 09       	ld.w	r9,r8[0x0]
80003de8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003dec:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003df0:	70 09       	ld.w	r9,r8[0x0]
80003df2:	2f f9       	sub	r9,-1
80003df4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003df6:	e0 49 01 ff 	cp.w	r9,511
80003dfa:	e0 88 00 16 	brls	80003e26 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003dfe:	30 09       	mov	r9,0
80003e00:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e02:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003e06:	6c 0c       	ld.w	r12,r6[0x0]
80003e08:	f0 1f 01 a8 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e0c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003e10:	70 0c       	ld.w	r12,r8[0x0]
80003e12:	f0 1f 01 93 	mcall	8000445c <phy_rx_func+0xe98>
80003e16:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003e18:	c0 71       	brne	80003e26 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003e1a:	30 09       	mov	r9,0
80003e1c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003e20:	91 09       	st.w	r8[0x0],r9
80003e22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003e26:	fe f9 06 62 	ld.w	r9,pc[1634]
80003e2a:	72 08       	ld.w	r8,r9[0x0]
80003e2c:	20 18       	sub	r8,1
80003e2e:	93 08       	st.w	r9[0x0],r8
80003e30:	c0 71       	brne	80003e3e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003e32:	30 09       	mov	r9,0
80003e34:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003e38:	91 09       	st.w	r8[0x0],r9
80003e3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003e3e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003e42:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003e46:	72 0a       	ld.w	r10,r9[0x0]
80003e48:	70 09       	ld.w	r9,r8[0x0]
80003e4a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003e4e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e52:	70 09       	ld.w	r9,r8[0x0]
80003e54:	2f f9       	sub	r9,-1
80003e56:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e58:	e0 49 01 ff 	cp.w	r9,511
80003e5c:	e0 88 00 16 	brls	80003e88 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003e60:	30 09       	mov	r9,0
80003e62:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e64:	fe f6 06 18 	ld.w	r6,pc[1560]
80003e68:	6c 0c       	ld.w	r12,r6[0x0]
80003e6a:	f0 1f 01 90 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e6e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003e72:	70 0c       	ld.w	r12,r8[0x0]
80003e74:	f0 1f 01 7a 	mcall	8000445c <phy_rx_func+0xe98>
80003e78:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003e7a:	c0 71       	brne	80003e88 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003e7c:	30 09       	mov	r9,0
80003e7e:	fe f8 06 02 	ld.w	r8,pc[1538]
80003e82:	91 09       	st.w	r8[0x0],r9
80003e84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003e88:	fe f9 06 00 	ld.w	r9,pc[1536]
80003e8c:	72 08       	ld.w	r8,r9[0x0]
80003e8e:	20 18       	sub	r8,1
80003e90:	93 08       	st.w	r9[0x0],r8
80003e92:	c0 71       	brne	80003ea0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003e94:	30 09       	mov	r9,0
80003e96:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003e9a:	91 09       	st.w	r8[0x0],r9
80003e9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003ea0:	fe f8 06 00 	ld.w	r8,pc[1536]
80003ea4:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003ea8:	72 0a       	ld.w	r10,r9[0x0]
80003eaa:	70 09       	ld.w	r9,r8[0x0]
80003eac:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003eb0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003eb4:	70 09       	ld.w	r9,r8[0x0]
80003eb6:	2f f9       	sub	r9,-1
80003eb8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eba:	e0 49 01 ff 	cp.w	r9,511
80003ebe:	e0 88 00 16 	brls	80003eea <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ec2:	30 09       	mov	r9,0
80003ec4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ec6:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003eca:	6c 0c       	ld.w	r12,r6[0x0]
80003ecc:	f0 1f 01 77 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ed0:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003ed4:	70 0c       	ld.w	r12,r8[0x0]
80003ed6:	f0 1f 01 62 	mcall	8000445c <phy_rx_func+0xe98>
80003eda:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003edc:	c0 71       	brne	80003eea <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003ede:	30 09       	mov	r9,0
80003ee0:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003ee4:	91 09       	st.w	r8[0x0],r9
80003ee6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003eea:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003eee:	72 08       	ld.w	r8,r9[0x0]
80003ef0:	20 18       	sub	r8,1
80003ef2:	93 08       	st.w	r9[0x0],r8
80003ef4:	c0 71       	brne	80003f02 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003ef6:	30 09       	mov	r9,0
80003ef8:	fe f8 05 88 	ld.w	r8,pc[1416]
80003efc:	91 09       	st.w	r8[0x0],r9
80003efe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003f02:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003f06:	fe f9 05 76 	ld.w	r9,pc[1398]
80003f0a:	72 0a       	ld.w	r10,r9[0x0]
80003f0c:	70 09       	ld.w	r9,r8[0x0]
80003f0e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003f12:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f16:	70 09       	ld.w	r9,r8[0x0]
80003f18:	2f f9       	sub	r9,-1
80003f1a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f1c:	e0 49 01 ff 	cp.w	r9,511
80003f20:	e0 88 00 16 	brls	80003f4c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f24:	30 09       	mov	r9,0
80003f26:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f28:	fe f7 05 54 	ld.w	r7,pc[1364]
80003f2c:	6e 0c       	ld.w	r12,r7[0x0]
80003f2e:	f0 1f 01 5f 	mcall	800044a8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f32:	fe f8 05 42 	ld.w	r8,pc[1346]
80003f36:	70 0c       	ld.w	r12,r8[0x0]
80003f38:	f0 1f 01 49 	mcall	8000445c <phy_rx_func+0xe98>
80003f3c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f3e:	c0 71       	brne	80003f4c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003f40:	30 09       	mov	r9,0
80003f42:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003f46:	91 09       	st.w	r8[0x0],r9
80003f48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f4c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003f50:	72 08       	ld.w	r8,r9[0x0]
80003f52:	20 18       	sub	r8,1
80003f54:	93 08       	st.w	r9[0x0],r8
80003f56:	e0 81 02 74 	brne	8000443e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003f5a:	30 09       	mov	r9,0
80003f5c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003f60:	91 09       	st.w	r8[0x0],r9
80003f62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003f66:	30 09       	mov	r9,0
80003f68:	fe f8 05 18 	ld.w	r8,pc[1304]
80003f6c:	91 09       	st.w	r8[0x0],r9
80003f6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003f72:	fe f8 05 26 	ld.w	r8,pc[1318]
80003f76:	11 89       	ld.ub	r9,r8[0x0]
80003f78:	3f 28       	mov	r8,-14
80003f7a:	f0 09 18 00 	cp.b	r9,r8
80003f7e:	c4 31       	brne	80004004 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003f80:	8e 49       	ld.sh	r9,r7[0x8]
80003f82:	fe f8 05 56 	ld.w	r8,pc[1366]
80003f86:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003f88:	fe f8 05 18 	ld.w	r8,pc[1304]
80003f8c:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003f90:	72 0a       	ld.w	r10,r9[0x0]
80003f92:	70 09       	ld.w	r9,r8[0x0]
80003f94:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003f98:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f9c:	70 09       	ld.w	r9,r8[0x0]
80003f9e:	2f f9       	sub	r9,-1
80003fa0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fa2:	e0 49 01 ff 	cp.w	r9,511
80003fa6:	e0 88 00 16 	brls	80003fd2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003faa:	30 09       	mov	r9,0
80003fac:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fae:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003fb2:	6e 0c       	ld.w	r12,r7[0x0]
80003fb4:	f0 1f 01 3d 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fb8:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003fbc:	70 0c       	ld.w	r12,r8[0x0]
80003fbe:	f0 1f 01 28 	mcall	8000445c <phy_rx_func+0xe98>
80003fc2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fc4:	c0 71       	brne	80003fd2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003fc6:	30 09       	mov	r9,0
80003fc8:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003fcc:	91 09       	st.w	r8[0x0],r9
80003fce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fd2:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003fd6:	72 08       	ld.w	r8,r9[0x0]
80003fd8:	20 18       	sub	r8,1
80003fda:	93 08       	st.w	r9[0x0],r8
80003fdc:	c0 71       	brne	80003fea <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003fde:	30 09       	mov	r9,0
80003fe0:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003fe4:	91 09       	st.w	r8[0x0],r9
80003fe6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003fea:	20 18       	sub	r8,1
80003fec:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003ff0:	93 08       	st.w	r9[0x0],r8
80003ff2:	58 08       	cp.w	r8,0
80003ff4:	e0 81 02 25 	brne	8000443e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003ff8:	30 09       	mov	r9,0
80003ffa:	fe f8 04 86 	ld.w	r8,pc[1158]
80003ffe:	91 09       	st.w	r8[0x0],r9
80004000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80004004:	fe f8 04 94 	ld.w	r8,pc[1172]
80004008:	11 89       	ld.ub	r9,r8[0x0]
8000400a:	3f 38       	mov	r8,-13
8000400c:	f0 09 18 00 	cp.b	r9,r8
80004010:	e0 81 01 0c 	brne	80004228 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004014:	8e 49       	ld.sh	r9,r7[0x8]
80004016:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000401a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000401c:	8e 59       	ld.sh	r9,r7[0xa]
8000401e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80004020:	8e 69       	ld.sh	r9,r7[0xc]
80004022:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80004024:	fe f8 04 7c 	ld.w	r8,pc[1148]
80004028:	fe f9 04 54 	ld.w	r9,pc[1108]
8000402c:	72 0a       	ld.w	r10,r9[0x0]
8000402e:	70 09       	ld.w	r9,r8[0x0]
80004030:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004034:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004038:	70 09       	ld.w	r9,r8[0x0]
8000403a:	2f f9       	sub	r9,-1
8000403c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000403e:	e0 49 01 ff 	cp.w	r9,511
80004042:	e0 88 00 16 	brls	8000406e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80004046:	30 09       	mov	r9,0
80004048:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000404a:	fe f6 04 32 	ld.w	r6,pc[1074]
8000404e:	6c 0c       	ld.w	r12,r6[0x0]
80004050:	f0 1f 01 16 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004054:	fe f8 04 20 	ld.w	r8,pc[1056]
80004058:	70 0c       	ld.w	r12,r8[0x0]
8000405a:	f0 1f 01 01 	mcall	8000445c <phy_rx_func+0xe98>
8000405e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004060:	c0 71       	brne	8000406e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80004062:	30 09       	mov	r9,0
80004064:	fe f8 04 1c 	ld.w	r8,pc[1052]
80004068:	91 09       	st.w	r8[0x0],r9
8000406a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000406e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80004072:	72 08       	ld.w	r8,r9[0x0]
80004074:	20 18       	sub	r8,1
80004076:	93 08       	st.w	r9[0x0],r8
80004078:	c0 71       	brne	80004086 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000407a:	30 09       	mov	r9,0
8000407c:	fe f8 04 04 	ld.w	r8,pc[1028]
80004080:	91 09       	st.w	r8[0x0],r9
80004082:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80004086:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000408a:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000408e:	72 0a       	ld.w	r10,r9[0x0]
80004090:	70 09       	ld.w	r9,r8[0x0]
80004092:	ef 3b 00 09 	ld.ub	r11,r7[9]
80004096:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000409a:	70 09       	ld.w	r9,r8[0x0]
8000409c:	2f f9       	sub	r9,-1
8000409e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040a0:	e0 49 01 ff 	cp.w	r9,511
800040a4:	e0 88 00 16 	brls	800040d0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800040a8:	30 09       	mov	r9,0
800040aa:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800040ac:	fe f6 03 d0 	ld.w	r6,pc[976]
800040b0:	6c 0c       	ld.w	r12,r6[0x0]
800040b2:	f0 1f 00 fe 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800040b6:	fe f8 03 be 	ld.w	r8,pc[958]
800040ba:	70 0c       	ld.w	r12,r8[0x0]
800040bc:	f0 1f 00 e8 	mcall	8000445c <phy_rx_func+0xe98>
800040c0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800040c2:	c0 71       	brne	800040d0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800040c4:	30 09       	mov	r9,0
800040c6:	fe f8 03 ba 	ld.w	r8,pc[954]
800040ca:	91 09       	st.w	r8[0x0],r9
800040cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800040d0:	fe f9 03 b8 	ld.w	r9,pc[952]
800040d4:	72 08       	ld.w	r8,r9[0x0]
800040d6:	20 18       	sub	r8,1
800040d8:	93 08       	st.w	r9[0x0],r8
800040da:	c0 71       	brne	800040e8 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800040dc:	30 09       	mov	r9,0
800040de:	fe f8 03 a2 	ld.w	r8,pc[930]
800040e2:	91 09       	st.w	r8[0x0],r9
800040e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800040e8:	fe f8 03 b8 	ld.w	r8,pc[952]
800040ec:	fe f9 03 90 	ld.w	r9,pc[912]
800040f0:	72 0a       	ld.w	r10,r9[0x0]
800040f2:	70 09       	ld.w	r9,r8[0x0]
800040f4:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800040f8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800040fc:	70 09       	ld.w	r9,r8[0x0]
800040fe:	2f f9       	sub	r9,-1
80004100:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004102:	e0 49 01 ff 	cp.w	r9,511
80004106:	e0 88 00 16 	brls	80004132 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000410a:	30 09       	mov	r9,0
8000410c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000410e:	fe f6 03 6e 	ld.w	r6,pc[878]
80004112:	6c 0c       	ld.w	r12,r6[0x0]
80004114:	f0 1f 00 e5 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004118:	fe f8 03 5c 	ld.w	r8,pc[860]
8000411c:	70 0c       	ld.w	r12,r8[0x0]
8000411e:	f0 1f 00 d0 	mcall	8000445c <phy_rx_func+0xe98>
80004122:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004124:	c0 71       	brne	80004132 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80004126:	30 09       	mov	r9,0
80004128:	fe f8 03 58 	ld.w	r8,pc[856]
8000412c:	91 09       	st.w	r8[0x0],r9
8000412e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004132:	fe f9 03 56 	ld.w	r9,pc[854]
80004136:	72 08       	ld.w	r8,r9[0x0]
80004138:	20 18       	sub	r8,1
8000413a:	93 08       	st.w	r9[0x0],r8
8000413c:	c0 71       	brne	8000414a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000413e:	30 09       	mov	r9,0
80004140:	fe f8 03 40 	ld.w	r8,pc[832]
80004144:	91 09       	st.w	r8[0x0],r9
80004146:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000414a:	fe f8 03 56 	ld.w	r8,pc[854]
8000414e:	fe f9 03 2e 	ld.w	r9,pc[814]
80004152:	72 0a       	ld.w	r10,r9[0x0]
80004154:	70 09       	ld.w	r9,r8[0x0]
80004156:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000415a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000415e:	70 09       	ld.w	r9,r8[0x0]
80004160:	2f f9       	sub	r9,-1
80004162:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004164:	e0 49 01 ff 	cp.w	r9,511
80004168:	e0 88 00 16 	brls	80004194 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
8000416c:	30 09       	mov	r9,0
8000416e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004170:	fe f6 03 0c 	ld.w	r6,pc[780]
80004174:	6c 0c       	ld.w	r12,r6[0x0]
80004176:	f0 1f 00 cd 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000417a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000417e:	70 0c       	ld.w	r12,r8[0x0]
80004180:	f0 1f 00 b7 	mcall	8000445c <phy_rx_func+0xe98>
80004184:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004186:	c0 71       	brne	80004194 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80004188:	30 09       	mov	r9,0
8000418a:	fe f8 02 f6 	ld.w	r8,pc[758]
8000418e:	91 09       	st.w	r8[0x0],r9
80004190:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004194:	fe f9 02 f4 	ld.w	r9,pc[756]
80004198:	72 08       	ld.w	r8,r9[0x0]
8000419a:	20 18       	sub	r8,1
8000419c:	93 08       	st.w	r9[0x0],r8
8000419e:	c0 71       	brne	800041ac <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800041a0:	30 09       	mov	r9,0
800041a2:	fe f8 02 de 	ld.w	r8,pc[734]
800041a6:	91 09       	st.w	r8[0x0],r9
800041a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800041ac:	fe f8 02 f4 	ld.w	r8,pc[756]
800041b0:	fe f9 02 cc 	ld.w	r9,pc[716]
800041b4:	72 0a       	ld.w	r10,r9[0x0]
800041b6:	70 09       	ld.w	r9,r8[0x0]
800041b8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800041bc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041c0:	70 09       	ld.w	r9,r8[0x0]
800041c2:	2f f9       	sub	r9,-1
800041c4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041c6:	e0 49 01 ff 	cp.w	r9,511
800041ca:	e0 88 00 16 	brls	800041f6 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800041ce:	30 09       	mov	r9,0
800041d0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041d2:	fe f7 02 aa 	ld.w	r7,pc[682]
800041d6:	6e 0c       	ld.w	r12,r7[0x0]
800041d8:	f0 1f 00 b4 	mcall	800044a8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041dc:	fe f8 02 98 	ld.w	r8,pc[664]
800041e0:	70 0c       	ld.w	r12,r8[0x0]
800041e2:	f0 1f 00 9f 	mcall	8000445c <phy_rx_func+0xe98>
800041e6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041e8:	c0 71       	brne	800041f6 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800041ea:	30 09       	mov	r9,0
800041ec:	fe f8 02 94 	ld.w	r8,pc[660]
800041f0:	91 09       	st.w	r8[0x0],r9
800041f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041f6:	fe f9 02 92 	ld.w	r9,pc[658]
800041fa:	72 08       	ld.w	r8,r9[0x0]
800041fc:	20 18       	sub	r8,1
800041fe:	93 08       	st.w	r9[0x0],r8
80004200:	c0 71       	brne	8000420e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80004202:	30 09       	mov	r9,0
80004204:	fe f8 02 7c 	ld.w	r8,pc[636]
80004208:	91 09       	st.w	r8[0x0],r9
8000420a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000420e:	20 18       	sub	r8,1
80004210:	fe f9 02 78 	ld.w	r9,pc[632]
80004214:	93 08       	st.w	r9[0x0],r8
80004216:	58 08       	cp.w	r8,0
80004218:	e0 81 01 13 	brne	8000443e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000421c:	30 09       	mov	r9,0
8000421e:	fe f8 02 62 	ld.w	r8,pc[610]
80004222:	91 09       	st.w	r8[0x0],r9
80004224:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004228:	fe f8 02 70 	ld.w	r8,pc[624]
8000422c:	11 89       	ld.ub	r9,r8[0x0]
8000422e:	30 48       	mov	r8,4
80004230:	f0 09 18 00 	cp.b	r9,r8
80004234:	c0 80       	breq	80004244 <phy_rx_func+0xc80>
80004236:	fe f8 02 62 	ld.w	r8,pc[610]
8000423a:	11 89       	ld.ub	r9,r8[0x0]
8000423c:	30 38       	mov	r8,3
8000423e:	f0 09 18 00 	cp.b	r9,r8
80004242:	c1 41       	brne	8000426a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004244:	6e 29       	ld.w	r9,r7[0x8]
80004246:	fe f8 02 7a 	ld.w	r8,pc[634]
8000424a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000424c:	6e 39       	ld.w	r9,r7[0xc]
8000424e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004250:	fe f9 02 38 	ld.w	r9,pc[568]
80004254:	72 08       	ld.w	r8,r9[0x0]
80004256:	20 88       	sub	r8,8
80004258:	93 08       	st.w	r9[0x0],r8
8000425a:	e0 81 00 f2 	brne	8000443e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
8000425e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004260:	fe f9 02 20 	ld.w	r9,pc[544]
80004264:	93 08       	st.w	r9[0x0],r8
80004266:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000426a:	fe f8 02 2e 	ld.w	r8,pc[558]
8000426e:	11 89       	ld.ub	r9,r8[0x0]
80004270:	31 38       	mov	r8,19
80004272:	f0 09 18 00 	cp.b	r9,r8
80004276:	e0 81 00 9c 	brne	800043ae <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000427a:	fe f8 02 62 	ld.w	r8,pc[610]
8000427e:	11 88       	ld.ub	r8,r8[0x0]
80004280:	30 c9       	mov	r9,12
80004282:	f2 08 18 00 	cp.b	r8,r9
80004286:	e0 81 00 7b 	brne	8000437c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000428a:	8e 49       	ld.sh	r9,r7[0x8]
8000428c:	fe f8 02 54 	ld.w	r8,pc[596]
80004290:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004294:	30 09       	mov	r9,0
80004296:	fe f8 02 46 	ld.w	r8,pc[582]
8000429a:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000429c:	ef 39 00 0d 	ld.ub	r9,r7[13]
800042a0:	3f 38       	mov	r8,-13
800042a2:	f0 09 18 00 	cp.b	r9,r8
800042a6:	c6 61       	brne	80004372 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800042a8:	10 99       	mov	r9,r8
800042aa:	4f c8       	lddpc	r8,80004498 <phy_rx_func+0xed4>
800042ac:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800042ae:	ef 39 00 0c 	ld.ub	r9,r7[12]
800042b2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800042b6:	4f 58       	lddpc	r8,80004488 <phy_rx_func+0xec4>
800042b8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800042ba:	30 19       	mov	r9,1
800042bc:	fe f8 02 0c 	ld.w	r8,pc[524]
800042c0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800042c2:	8e 79       	ld.sh	r9,r7[0xe]
800042c4:	fe f8 02 14 	ld.w	r8,pc[532]
800042c8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800042ca:	4f 68       	lddpc	r8,800044a0 <phy_rx_func+0xedc>
800042cc:	4e c9       	lddpc	r9,8000447c <phy_rx_func+0xeb8>
800042ce:	72 0a       	ld.w	r10,r9[0x0]
800042d0:	70 09       	ld.w	r9,r8[0x0]
800042d2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800042d6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800042da:	70 09       	ld.w	r9,r8[0x0]
800042dc:	2f f9       	sub	r9,-1
800042de:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042e0:	e0 49 01 ff 	cp.w	r9,511
800042e4:	e0 88 00 13 	brls	8000430a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800042e8:	30 09       	mov	r9,0
800042ea:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800042ec:	4e 46       	lddpc	r6,8000447c <phy_rx_func+0xeb8>
800042ee:	6c 0c       	ld.w	r12,r6[0x0]
800042f0:	f0 1f 00 6e 	mcall	800044a8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800042f4:	4e 08       	lddpc	r8,80004474 <phy_rx_func+0xeb0>
800042f6:	70 0c       	ld.w	r12,r8[0x0]
800042f8:	f0 1f 00 59 	mcall	8000445c <phy_rx_func+0xe98>
800042fc:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800042fe:	c0 61       	brne	8000430a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80004300:	30 09       	mov	r9,0
80004302:	4e 08       	lddpc	r8,80004480 <phy_rx_func+0xebc>
80004304:	91 09       	st.w	r8[0x0],r9
80004306:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000430a:	4e 09       	lddpc	r9,80004488 <phy_rx_func+0xec4>
8000430c:	72 08       	ld.w	r8,r9[0x0]
8000430e:	20 18       	sub	r8,1
80004310:	93 08       	st.w	r9[0x0],r8
80004312:	c0 61       	brne	8000431e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004314:	30 09       	mov	r9,0
80004316:	4d b8       	lddpc	r8,80004480 <phy_rx_func+0xebc>
80004318:	91 09       	st.w	r8[0x0],r9
8000431a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000431e:	4e 18       	lddpc	r8,800044a0 <phy_rx_func+0xedc>
80004320:	4d 79       	lddpc	r9,8000447c <phy_rx_func+0xeb8>
80004322:	72 0a       	ld.w	r10,r9[0x0]
80004324:	70 09       	ld.w	r9,r8[0x0]
80004326:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000432a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000432e:	70 09       	ld.w	r9,r8[0x0]
80004330:	2f f9       	sub	r9,-1
80004332:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004334:	e0 49 01 ff 	cp.w	r9,511
80004338:	e0 88 00 13 	brls	8000435e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000433c:	30 09       	mov	r9,0
8000433e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004340:	4c f7       	lddpc	r7,8000447c <phy_rx_func+0xeb8>
80004342:	6e 0c       	ld.w	r12,r7[0x0]
80004344:	f0 1f 00 59 	mcall	800044a8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004348:	4c b8       	lddpc	r8,80004474 <phy_rx_func+0xeb0>
8000434a:	70 0c       	ld.w	r12,r8[0x0]
8000434c:	f0 1f 00 44 	mcall	8000445c <phy_rx_func+0xe98>
80004350:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004352:	c0 61       	brne	8000435e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80004354:	30 09       	mov	r9,0
80004356:	4c b8       	lddpc	r8,80004480 <phy_rx_func+0xebc>
80004358:	91 09       	st.w	r8[0x0],r9
8000435a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000435e:	4c b9       	lddpc	r9,80004488 <phy_rx_func+0xec4>
80004360:	72 08       	ld.w	r8,r9[0x0]
80004362:	20 18       	sub	r8,1
80004364:	93 08       	st.w	r9[0x0],r8
80004366:	c6 c1       	brne	8000443e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80004368:	30 09       	mov	r9,0
8000436a:	4c 68       	lddpc	r8,80004480 <phy_rx_func+0xebc>
8000436c:	91 09       	st.w	r8[0x0],r9
8000436e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004372:	30 09       	mov	r9,0
80004374:	4c 38       	lddpc	r8,80004480 <phy_rx_func+0xebc>
80004376:	91 09       	st.w	r8[0x0],r9
80004378:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
8000437c:	8e 4a       	ld.sh	r10,r7[0x8]
8000437e:	4d 99       	lddpc	r9,800044e0 <phy_rx_func+0xf1c>
80004380:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004384:	4d 6a       	lddpc	r10,800044dc <phy_rx_func+0xf18>
80004386:	15 88       	ld.ub	r8,r10[0x0]
80004388:	f0 cb ff ff 	sub	r11,r8,-1
8000438c:	8e 5c       	ld.sh	r12,r7[0xa]
8000438e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80004392:	f0 cb ff fe 	sub	r11,r8,-2
80004396:	8e 6c       	ld.sh	r12,r7[0xc]
80004398:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
8000439c:	f0 cb ff fd 	sub	r11,r8,-3
800043a0:	8e 7c       	ld.sh	r12,r7[0xe]
800043a2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800043a6:	2f c8       	sub	r8,-4
800043a8:	b4 88       	st.b	r10[0x0],r8
800043aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800043ae:	30 09       	mov	r9,0
800043b0:	4b 48       	lddpc	r8,80004480 <phy_rx_func+0xebc>
800043b2:	91 09       	st.w	r8[0x0],r9
800043b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800043b8:	4c 08       	lddpc	r8,800044b8 <phy_rx_func+0xef4>
800043ba:	70 09       	ld.w	r9,r8[0x0]
800043bc:	8e 4b       	ld.sh	r11,r7[0x8]
800043be:	4c 0a       	lddpc	r10,800044bc <phy_rx_func+0xef8>
800043c0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800043c4:	2f f9       	sub	r9,-1
800043c6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800043c8:	4b 58       	lddpc	r8,8000449c <phy_rx_func+0xed8>
800043ca:	70 09       	ld.w	r9,r8[0x0]
800043cc:	20 29       	sub	r9,2
800043ce:	91 09       	st.w	r8[0x0],r9
800043d0:	70 08       	ld.w	r8,r8[0x0]
800043d2:	58 08       	cp.w	r8,0
800043d4:	c2 f1       	brne	80004432 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800043d6:	30 09       	mov	r9,0
800043d8:	4b 88       	lddpc	r8,800044b8 <phy_rx_func+0xef4>
800043da:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800043dc:	8e 59       	ld.sh	r9,r7[0xa]
800043de:	fe 78 82 12 	mov	r8,-32238
800043e2:	f0 09 19 00 	cp.h	r9,r8
800043e6:	c2 11       	brne	80004428 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800043e8:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800043ec:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800043f0:	4a f8       	lddpc	r8,800044ac <phy_rx_func+0xee8>
800043f2:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800043f4:	8e 59       	ld.sh	r9,r7[0xa]
800043f6:	4a f8       	lddpc	r8,800044b0 <phy_rx_func+0xeec>
800043f8:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800043fa:	8e 69       	ld.sh	r9,r7[0xc]
800043fc:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800043fe:	f0 1f 00 2e 	mcall	800044b4 <phy_rx_func+0xef0>
80004402:	4a 18       	lddpc	r8,80004484 <phy_rx_func+0xec0>
80004404:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004406:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000440a:	31 38       	mov	r8,19
8000440c:	f0 09 18 00 	cp.b	r9,r8
80004410:	c0 71       	brne	8000441e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004412:	10 99       	mov	r9,r8
80004414:	4a 18       	lddpc	r8,80004498 <phy_rx_func+0xed4>
80004416:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004418:	30 09       	mov	r9,0
8000441a:	49 c8       	lddpc	r8,80004488 <phy_rx_func+0xec4>
8000441c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000441e:	30 49       	mov	r9,4
80004420:	49 88       	lddpc	r8,80004480 <phy_rx_func+0xebc>
80004422:	91 09       	st.w	r8[0x0],r9
80004424:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004428:	30 09       	mov	r9,0
8000442a:	49 68       	lddpc	r8,80004480 <phy_rx_func+0xebc>
8000442c:	91 09       	st.w	r8[0x0],r9
8000442e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004432:	4a dc       	lddpc	r12,800044e4 <phy_rx_func+0xf20>
80004434:	f0 1f 00 18 	mcall	80004494 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80004438:	30 09       	mov	r9,0
8000443a:	49 28       	lddpc	r8,80004480 <phy_rx_func+0xebc>
8000443c:	91 09       	st.w	r8[0x0],r9
8000443e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004442:	00 00       	add	r0,r0
80004444:	00 00       	add	r0,r0
80004446:	0a c8       	st.b	r5++,r8
80004448:	00 00       	add	r0,r0
8000444a:	0a e0       	st.h	--r5,r0
8000444c:	00 00       	add	r0,r0
8000444e:	0a c0       	st.b	r5++,r0
80004450:	00 00       	add	r0,r0
80004452:	0a a2       	st.w	r5++,r2
80004454:	00 00       	add	r0,r0
80004456:	0a 90       	mov	r0,r5
80004458:	00 00       	add	r0,r0
8000445a:	0a b8       	st.h	r5++,r8
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	34 44       	mov	r4,68
80004460:	00 00       	add	r0,r0
80004462:	0a b0       	st.h	r5++,r0
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	33 5c       	mov	r12,53
80004468:	00 00       	add	r0,r0
8000446a:	0a c4       	st.b	r5++,r4
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	33 90       	mov	r0,57
80004470:	00 00       	add	r0,r0
80004472:	0a a1       	st.w	r5++,r1
80004474:	00 00       	add	r0,r0
80004476:	0a bc       	st.h	r5++,r12
80004478:	00 00       	add	r0,r0
8000447a:	0a cc       	st.b	r5++,r12
8000447c:	00 00       	add	r0,r0
8000447e:	0a a4       	st.w	r5++,r4
80004480:	00 00       	add	r0,r0
80004482:	0a ec       	st.h	--r5,r12
80004484:	00 00       	add	r0,r0
80004486:	0a d4       	st.w	--r5,r4
80004488:	00 00       	add	r0,r0
8000448a:	0a 8c       	andn	r12,r5
8000448c:	00 00       	add	r0,r0
8000448e:	0a 64       	and	r4,r5
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	e6 e0 80 00 	ld.d	r0,r3[-32768]
80004496:	7f 0c       	ld.w	r12,pc[0x40]
80004498:	00 00       	add	r0,r0
8000449a:	0a a0       	st.w	r5++,r0
8000449c:	00 00       	add	r0,r0
8000449e:	0a f8       	st.b	--r5,r8
800044a0:	00 00       	add	r0,r0
800044a2:	0a d8       	st.w	--r5,r8
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	87 72       	st.w	r3[0x1c],r2
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	33 78       	mov	r8,55
800044ac:	00 00       	add	r0,r0
800044ae:	0a 5b       	eor	r11,r5
800044b0:	00 00       	add	r0,r0
800044b2:	1f 28       	ld.uh	r8,pc++
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	33 2c       	mov	r12,50
800044b8:	00 00       	add	r0,r0
800044ba:	0a 94       	mov	r4,r5
800044bc:	00 00       	add	r0,r0
800044be:	1e 2c       	rsub	r12,pc
800044c0:	00 00       	add	r0,r0
800044c2:	0a 98       	mov	r8,r5
800044c4:	00 00       	add	r0,r0
800044c6:	0a 60       	and	r0,r5
800044c8:	00 00       	add	r0,r0
800044ca:	0a 63       	and	r3,r5
800044cc:	00 00       	add	r0,r0
800044ce:	0a f0       	st.b	--r5,r0
800044d0:	00 00       	add	r0,r0
800044d2:	0a ac       	st.w	r5++,r12
800044d4:	00 00       	add	r0,r0
800044d6:	0a 76       	tst	r6,r5
800044d8:	00 00       	add	r0,r0
800044da:	1e 24       	rsub	r4,pc
800044dc:	00 00       	add	r0,r0
800044de:	0a e4       	st.h	--r5,r4
800044e0:	00 00       	add	r0,r0
800044e2:	1f 2c       	ld.uh	r12,pc++
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	e6 f8 d4 01 	ld.w	r8,r3[-11263]

800044e8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800044e8:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
800044ea:	49 a8       	lddpc	r8,80004550 <pdca_int_handler+0x68>
800044ec:	70 09       	ld.w	r9,r8[0x0]
800044ee:	2f f9       	sub	r9,-1
800044f0:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800044f2:	49 98       	lddpc	r8,80004554 <pdca_int_handler+0x6c>
800044f4:	11 89       	ld.ub	r9,r8[0x0]
800044f6:	ec 19 00 01 	eorl	r9,0x1
800044fa:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800044fc:	11 89       	ld.ub	r9,r8[0x0]
800044fe:	a5 69       	lsl	r9,0x4
80004500:	2f c9       	sub	r9,-4
80004502:	49 6a       	lddpc	r10,80004558 <pdca_int_handler+0x70>
80004504:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004506:	fe 7a 00 40 	mov	r10,-65472
8000450a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000450c:	30 39       	mov	r9,3
8000450e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004510:	11 8a       	ld.ub	r10,r8[0x0]
80004512:	a5 6a       	lsl	r10,0x4
80004514:	2f ca       	sub	r10,-4
80004516:	49 28       	lddpc	r8,8000455c <pdca_int_handler+0x74>
80004518:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000451a:	fe 78 00 00 	mov	r8,-65536
8000451e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004520:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004522:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004524:	48 f8       	lddpc	r8,80004560 <pdca_int_handler+0x78>
80004526:	70 08       	ld.w	r8,r8[0x0]
80004528:	58 08       	cp.w	r8,0
8000452a:	c0 70       	breq	80004538 <pdca_int_handler+0x50>
8000452c:	48 a9       	lddpc	r9,80004554 <pdca_int_handler+0x6c>
8000452e:	13 89       	ld.ub	r9,r9[0x0]
80004530:	a5 69       	lsl	r9,0x4
80004532:	48 bc       	lddpc	r12,8000455c <pdca_int_handler+0x74>
80004534:	12 0c       	add	r12,r9
80004536:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004538:	48 b8       	lddpc	r8,80004564 <pdca_int_handler+0x7c>
8000453a:	70 08       	ld.w	r8,r8[0x0]
8000453c:	58 08       	cp.w	r8,0
8000453e:	c0 70       	breq	8000454c <pdca_int_handler+0x64>
80004540:	48 59       	lddpc	r9,80004554 <pdca_int_handler+0x6c>
80004542:	13 89       	ld.ub	r9,r9[0x0]
80004544:	a5 69       	lsl	r9,0x4
80004546:	48 5c       	lddpc	r12,80004558 <pdca_int_handler+0x70>
80004548:	12 0c       	add	r12,r9
8000454a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
8000454c:	d4 02       	popm	lr
8000454e:	d6 03       	rete
80004550:	00 00       	add	r0,r0
80004552:	0b 00       	ld.w	r0,r5++
80004554:	00 00       	add	r0,r0
80004556:	51 4c       	stdsp	sp[0x50],r12
80004558:	00 00       	add	r0,r0
8000455a:	51 74       	stdsp	sp[0x5c],r4
8000455c:	00 00       	add	r0,r0
8000455e:	51 54       	stdsp	sp[0x54],r4
80004560:	00 00       	add	r0,r0
80004562:	0a fc       	st.b	--r5,r12
80004564:	00 00       	add	r0,r0
80004566:	0b 04       	ld.w	r4,r5++

80004568 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004568:	fe 78 10 00 	mov	r8,-61440
8000456c:	e0 69 0d c0 	mov	r9,3520
80004570:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004574:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004578:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000457c:	fe 78 34 00 	mov	r8,-52224
80004580:	e0 69 80 00 	mov	r9,32768
80004584:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004586:	30 09       	mov	r9,0
80004588:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000458a:	e0 69 04 21 	mov	r9,1057
8000458e:	ea 19 3f 20 	orh	r9,0x3f20
80004592:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004594:	e0 69 02 9f 	mov	r9,671
80004598:	ea 19 01 00 	orh	r9,0x100
8000459c:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
8000459e:	e0 6a 04 02 	mov	r10,1026
800045a2:	ea 1a 3f 20 	orh	r10,0x3f20
800045a6:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
800045a8:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800045aa:	5e fc       	retal	r12

800045ac <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800045ac:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800045ae:	30 19       	mov	r9,1
800045b0:	49 78       	lddpc	r8,8000460c <local_start_PDC+0x60>
800045b2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800045b4:	fe 78 00 00 	mov	r8,-65536
800045b8:	30 7b       	mov	r11,7
800045ba:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800045bc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800045be:	49 59       	lddpc	r9,80004610 <local_start_PDC+0x64>
800045c0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800045c4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800045c6:	30 3a       	mov	r10,3
800045c8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800045ca:	30 1c       	mov	r12,1
800045cc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800045ce:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800045d0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800045d2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800045d4:	30 2c       	mov	r12,2
800045d6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800045d8:	48 f9       	lddpc	r9,80004614 <local_start_PDC+0x68>
800045da:	e0 68 5a 5a 	mov	r8,23130
800045de:	ea 18 ab cd 	orh	r8,0xabcd
800045e2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800045e4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800045e6:	30 0e       	mov	lr,0
800045e8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800045ea:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800045ec:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800045ee:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800045f0:	fe 78 00 40 	mov	r8,-65472
800045f4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800045f6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800045f8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800045fc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800045fe:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004600:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004602:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004604:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004606:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004608:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000460a:	d8 02       	popm	pc
8000460c:	00 00       	add	r0,r0
8000460e:	51 4c       	stdsp	sp[0x50],r12
80004610:	00 00       	add	r0,r0
80004612:	51 54       	stdsp	sp[0x54],r4
80004614:	00 00       	add	r0,r0
80004616:	51 74       	stdsp	sp[0x5c],r4

80004618 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004618:	48 38       	lddpc	r8,80004624 <register_rx_tx_func+0xc>
8000461a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000461c:	48 38       	lddpc	r8,80004628 <register_rx_tx_func+0x10>
8000461e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004620:	5e fc       	retal	r12
80004622:	00 00       	add	r0,r0
80004624:	00 00       	add	r0,r0
80004626:	0a fc       	st.b	--r5,r12
80004628:	00 00       	add	r0,r0
8000462a:	0b 04       	ld.w	r4,r5++

8000462c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000462c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000462e:	fe 78 10 00 	mov	r8,-61440
80004632:	30 29       	mov	r9,2
80004634:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004638:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000463c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
8000463e:	30 3a       	mov	r10,3
80004640:	36 0b       	mov	r11,96
80004642:	49 4c       	lddpc	r12,80004690 <ssc_init+0x64>
80004644:	f0 1f 00 14 	mcall	80004694 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80004648:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000464a:	fe 79 10 00 	mov	r9,-61440
8000464e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004652:	e2 18 00 02 	andl	r8,0x2,COH
80004656:	cf c0       	breq	8000464e <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004658:	fe 79 10 00 	mov	r9,-61440
8000465c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004660:	e2 18 00 02 	andl	r8,0x2,COH
80004664:	cf c1       	brne	8000465c <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80004666:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80004668:	f0 1f 00 0c 	mcall	80004698 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
8000466c:	f0 1f 00 0c 	mcall	8000469c <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004670:	fe 79 00 00 	mov	r9,-65536
80004674:	30 18       	mov	r8,1
80004676:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004678:	fe 7a 00 40 	mov	r10,-65472
8000467c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000467e:	e0 6b 01 01 	mov	r11,257
80004682:	fe 7a 34 00 	mov	r10,-52224
80004686:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80004688:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
8000468a:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
8000468c:	d8 02       	popm	pc
8000468e:	00 00       	add	r0,r0
80004690:	80 00       	ld.sh	r0,r0[0x0]
80004692:	44 e8       	lddsp	r8,sp[0x138]
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	61 d0       	ld.w	r0,r0[0x74]
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	45 68       	lddsp	r8,sp[0x158]
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	45 ac       	lddsp	r12,sp[0x168]

800046a0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800046a0:	48 28       	lddpc	r8,800046a8 <xcmp_register_app_list+0x8>
800046a2:	91 0c       	st.w	r8[0x0],r12
}
800046a4:	5e fc       	retal	r12
800046a6:	00 00       	add	r0,r0
800046a8:	00 00       	add	r0,r0
800046aa:	51 94       	stdsp	sp[0x64],r4

800046ac <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800046ac:	eb cd 40 80 	pushm	r7,lr
800046b0:	fa cd 01 00 	sub	sp,sp,256
800046b4:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800046b6:	16 98       	mov	r8,r11
800046b8:	2f 08       	sub	r8,-16
800046ba:	af a8       	sbr	r8,0xe
800046bc:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800046be:	3f f8       	mov	r8,-1
800046c0:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800046c2:	30 b9       	mov	r9,11
800046c4:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800046c6:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800046c8:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800046ca:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046cc:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800046ce:	f6 ca ff fe 	sub	r10,r11,-2
800046d2:	18 9b       	mov	r11,r12
800046d4:	fa cc ff f0 	sub	r12,sp,-16
800046d8:	f0 1f 00 05 	mcall	800046ec <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800046dc:	2f e7       	sub	r7,-2
800046de:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800046e0:	1a 9c       	mov	r12,sp
800046e2:	f0 1f 00 04 	mcall	800046f0 <xcmp_tx+0x44>
}
800046e6:	2c 0d       	sub	sp,-256
800046e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	86 2a       	ld.sh	r10,r3[0x4]
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	4c b8       	lddpc	r8,8000481c <xcmp_exec_func+0x38>

800046f4 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
800046f4:	d4 21       	pushm	r4-r7,lr
800046f6:	fa cd 00 d0 	sub	sp,sp,208
800046fa:	18 94       	mov	r4,r12
800046fc:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800046fe:	e0 68 01 00 	mov	r8,256
80004702:	f0 0b 19 00 	cp.h	r11,r8
80004706:	e0 8b 00 36 	brhi	80004772 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000470a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000470e:	e0 68 04 1d 	mov	r8,1053
80004712:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004714:	30 18       	mov	r8,1
80004716:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004718:	32 08       	mov	r8,32
8000471a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
8000471c:	30 28       	mov	r8,2
8000471e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004720:	30 48       	mov	r8,4
80004722:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004724:	ea 1a 0c 00 	orh	r10,0xc00
80004728:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000472a:	30 4a       	mov	r10,4
8000472c:	1a 9b       	mov	r11,sp
8000472e:	fa cc ff f4 	sub	r12,sp,-12
80004732:	f0 1f 00 12 	mcall	80004778 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004736:	30 f8       	mov	r8,15
80004738:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
8000473c:	3a 78       	mov	r8,-89
8000473e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80004742:	30 08       	mov	r8,0
80004744:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004748:	0e 9a       	mov	r10,r7
8000474a:	5c 7a       	castu.h	r10
8000474c:	f4 08 16 08 	lsr	r8,r10,0x8
80004750:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004754:	0e 96       	mov	r6,r7
80004756:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
8000475a:	08 9b       	mov	r11,r4
8000475c:	fa cc ff eb 	sub	r12,sp,-21
80004760:	f0 1f 00 06 	mcall	80004778 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004764:	ee cb ff f3 	sub	r11,r7,-13
80004768:	5c 5b       	castu.b	r11
8000476a:	fa cc ff fa 	sub	r12,sp,-6
8000476e:	f0 1f 00 04 	mcall	8000477c <xcmp_data_session_req+0x88>
}
80004772:	2c cd       	sub	sp,-208
80004774:	d8 22       	popm	r4-r7,pc
80004776:	00 00       	add	r0,r0
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	86 2a       	ld.sh	r10,r3[0x4]
8000477c:	80 00       	ld.sh	r0,r0[0x0]
8000477e:	46 ac       	lddsp	r12,sp[0x1a8]

80004780 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004780:	d4 01       	pushm	lr
80004782:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004786:	fe 78 b4 00 	mov	r8,-19456
8000478a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000478c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004790:	30 89       	mov	r9,8
80004792:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004794:	30 19       	mov	r9,1
80004796:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004798:	30 09       	mov	r9,0
8000479a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000479c:	30 5a       	mov	r10,5
8000479e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800047a0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800047a2:	30 7a       	mov	r10,7
800047a4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800047a6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800047a8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800047aa:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800047ae:	30 9b       	mov	r11,9
800047b0:	fa cc ff fe 	sub	r12,sp,-2
800047b4:	f0 1f 00 02 	mcall	800047bc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800047b8:	2c dd       	sub	sp,-204
800047ba:	d8 02       	popm	pc
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	46 ac       	lddsp	r12,sp[0x1a8]

800047c0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800047c0:	d4 01       	pushm	lr
800047c2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800047c6:	fe 78 80 00 	mov	r8,-32768
800047ca:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800047cc:	30 38       	mov	r8,3
800047ce:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800047d0:	30 1b       	mov	r11,1
800047d2:	fa cc ff fe 	sub	r12,sp,-2
800047d6:	f0 1f 00 03 	mcall	800047e0 <xcmp_opcode_not_supported+0x20>
}
800047da:	2c dd       	sub	sp,-204
800047dc:	d8 02       	popm	pc
800047de:	00 00       	add	r0,r0
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	46 ac       	lddsp	r12,sp[0x1a8]

800047e4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800047e4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800047e6:	96 88       	ld.uh	r8,r11[0x0]
800047e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800047ec:	e0 48 80 00 	cp.w	r8,32768
800047f0:	c0 f0       	breq	8000480e <xcmp_exec_func+0x2a>
800047f2:	e0 48 b0 00 	cp.w	r8,45056
800047f6:	c1 20       	breq	8000481a <xcmp_exec_func+0x36>
800047f8:	58 08       	cp.w	r8,0
800047fa:	c1 51       	brne	80004824 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800047fc:	78 08       	ld.w	r8,r12[0x0]
800047fe:	58 08       	cp.w	r8,0
80004800:	c0 40       	breq	80004808 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004802:	16 9c       	mov	r12,r11
80004804:	5d 18       	icall	r8
80004806:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004808:	f0 1f 00 08 	mcall	80004828 <xcmp_exec_func+0x44>
8000480c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000480e:	78 18       	ld.w	r8,r12[0x4]
80004810:	58 08       	cp.w	r8,0
80004812:	c0 90       	breq	80004824 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004814:	16 9c       	mov	r12,r11
80004816:	5d 18       	icall	r8
80004818:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000481a:	78 28       	ld.w	r8,r12[0x8]
8000481c:	58 08       	cp.w	r8,0
8000481e:	c0 30       	breq	80004824 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004820:	16 9c       	mov	r12,r11
80004822:	5d 18       	icall	r8
80004824:	d8 02       	popm	pc
80004826:	00 00       	add	r0,r0
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	47 c0       	lddsp	r0,sp[0x1f0]

8000482c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000482c:	d4 01       	pushm	lr
8000482e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004832:	e0 68 04 09 	mov	r8,1033
80004836:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004838:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000483c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000483e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004842:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004844:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004846:	30 09       	mov	r9,0
80004848:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000484a:	fb 69 00 08 	st.b	sp[8],r9
8000484e:	fa c8 ff f7 	sub	r8,sp,-9
80004852:	b0 89       	st.b	r8[0x0],r9
80004854:	fa c8 ff f6 	sub	r8,sp,-10
80004858:	b0 89       	st.b	r8[0x0],r9
8000485a:	fa c8 ff f5 	sub	r8,sp,-11
8000485e:	b0 89       	st.b	r8[0x0],r9
80004860:	fa c8 ff f4 	sub	r8,sp,-12
80004864:	b0 89       	st.b	r8[0x0],r9
80004866:	fa c8 ff f3 	sub	r8,sp,-13
8000486a:	b0 89       	st.b	r8[0x0],r9
8000486c:	fa c8 ff f2 	sub	r8,sp,-14
80004870:	b0 89       	st.b	r8[0x0],r9
80004872:	fa c8 ff f1 	sub	r8,sp,-15
80004876:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004878:	30 cb       	mov	r11,12
8000487a:	fa cc ff fe 	sub	r12,sp,-2
8000487e:	f0 1f 00 03 	mcall	80004888 <xcmp_IdleTestTone+0x5c>
}
80004882:	2c dd       	sub	sp,-204
80004884:	d8 02       	popm	pc
80004886:	00 00       	add	r0,r0
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	46 ac       	lddsp	r12,sp[0x1a8]

8000488c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000488c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000488e:	48 dc       	lddpc	r12,800048c0 <xcmp_init+0x34>
80004890:	f0 1f 00 0d 	mcall	800048c4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004894:	30 4b       	mov	r11,4
80004896:	31 4c       	mov	r12,20
80004898:	f0 1f 00 0c 	mcall	800048c8 <xcmp_init+0x3c>
8000489c:	48 c8       	lddpc	r8,800048cc <xcmp_init+0x40>
8000489e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800048a0:	30 09       	mov	r9,0
800048a2:	1a d9       	st.w	--sp,r9
800048a4:	1a d9       	st.w	--sp,r9
800048a6:	1a d9       	st.w	--sp,r9
800048a8:	30 38       	mov	r8,3
800048aa:	e0 6a 04 00 	mov	r10,1024
800048ae:	48 9b       	lddpc	r11,800048d0 <xcmp_init+0x44>
800048b0:	48 9c       	lddpc	r12,800048d4 <xcmp_init+0x48>
800048b2:	f0 1f 00 0a 	mcall	800048d8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800048b6:	f0 1f 00 0a 	mcall	800048dc <xcmp_init+0x50>
800048ba:	2f dd       	sub	sp,-12
	
}
800048bc:	d8 02       	popm	pc
800048be:	00 00       	add	r0,r0
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	49 dc       	lddpc	r12,80004934 <xcmp_rx_process+0x54>
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	4a 28       	lddpc	r8,8000494c <xcmp_rx_process+0x6c>
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	72 88       	ld.w	r8,r9[0x20]
800048cc:	00 00       	add	r0,r0
800048ce:	0b 20       	ld.uh	r0,r5++
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	e7 24 80 00 	ld.sb	r4,r3[-32768]
800048d6:	48 e0       	lddpc	r0,8000490c <xcmp_rx_process+0x2c>
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	79 bc       	ld.w	r12,r12[0x6c]
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	4a 60       	lddpc	r0,80004974 <xcmp_rx_process+0x94>

800048e0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800048e0:	d4 31       	pushm	r0-r7,lr
800048e2:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800048e4:	4b 16       	lddpc	r6,800049a8 <xcmp_rx_process+0xc8>
800048e6:	30 05       	mov	r5,0
800048e8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800048ea:	4b 13       	lddpc	r3,800049ac <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800048ec:	4b 12       	lddpc	r2,800049b0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800048ee:	4b 21       	lddpc	r1,800049b4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800048f0:	4b 20       	lddpc	r0,800049b8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800048f2:	6c 0c       	ld.w	r12,r6[0x0]
800048f4:	0a 99       	mov	r9,r5
800048f6:	08 9a       	mov	r10,r4
800048f8:	1a 9b       	mov	r11,sp
800048fa:	f0 1f 00 31 	mcall	800049bc <xcmp_rx_process+0xdc>
800048fe:	58 1c       	cp.w	r12,1
80004900:	cf 91       	brne	800048f2 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004902:	40 0b       	lddsp	r11,sp[0x0]
80004904:	58 0b       	cp.w	r11,0
80004906:	cf 60       	breq	800048f2 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004908:	96 0a       	ld.sh	r10,r11[0x0]
8000490a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000490e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004912:	59 c8       	cp.w	r8,28
80004914:	c1 e0       	breq	80004950 <xcmp_rx_process+0x70>
80004916:	e0 89 00 07 	brgt	80004924 <xcmp_rx_process+0x44>
8000491a:	58 e8       	cp.w	r8,14
8000491c:	c0 e0       	breq	80004938 <xcmp_rx_process+0x58>
8000491e:	58 f8       	cp.w	r8,15
80004920:	c2 41       	brne	80004968 <xcmp_rx_process+0x88>
80004922:	c0 f8       	rjmp	80004940 <xcmp_rx_process+0x60>
80004924:	e0 48 01 09 	cp.w	r8,265
80004928:	c1 80       	breq	80004958 <xcmp_rx_process+0x78>
8000492a:	e0 48 01 0a 	cp.w	r8,266
8000492e:	c1 90       	breq	80004960 <xcmp_rx_process+0x80>
80004930:	e0 48 00 2c 	cp.w	r8,44
80004934:	c1 a1       	brne	80004968 <xcmp_rx_process+0x88>
80004936:	c0 98       	rjmp	80004948 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004938:	4a 2c       	lddpc	r12,800049c0 <xcmp_rx_process+0xe0>
8000493a:	f0 1f 00 23 	mcall	800049c4 <xcmp_rx_process+0xe4>
					break;
8000493e:	c2 f8       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004940:	4a 2c       	lddpc	r12,800049c8 <xcmp_rx_process+0xe8>
80004942:	f0 1f 00 21 	mcall	800049c4 <xcmp_rx_process+0xe4>
					break;
80004946:	c2 b8       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004948:	4a 1c       	lddpc	r12,800049cc <xcmp_rx_process+0xec>
8000494a:	f0 1f 00 1f 	mcall	800049c4 <xcmp_rx_process+0xe4>
					break;
8000494e:	c2 78       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004950:	04 9c       	mov	r12,r2
80004952:	f0 1f 00 1d 	mcall	800049c4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004956:	c2 38       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004958:	02 9c       	mov	r12,r1
8000495a:	f0 1f 00 1b 	mcall	800049c4 <xcmp_rx_process+0xe4>
					break;
8000495e:	c1 f8       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004960:	00 9c       	mov	r12,r0
80004962:	f0 1f 00 19 	mcall	800049c4 <xcmp_rx_process+0xe4>
					break;
80004966:	c1 b8       	rjmp	8000499c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004968:	12 98       	mov	r8,r9
8000496a:	e2 18 04 00 	andl	r8,0x400,COH
8000496e:	c0 70       	breq	8000497c <xcmp_rx_process+0x9c>
80004970:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004974:	e0 48 00 68 	cp.w	r8,104
80004978:	e0 8a 00 08 	brle	80004988 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000497c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004980:	c0 e1       	brne	8000499c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004982:	f0 1f 00 14 	mcall	800049d0 <xcmp_rx_process+0xf0>
80004986:	c0 b8       	rjmp	8000499c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004988:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000498c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004990:	49 19       	lddpc	r9,800049d4 <xcmp_rx_process+0xf4>
80004992:	72 08       	ld.w	r8,r9[0x0]
80004994:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004998:	f0 1f 00 0b 	mcall	800049c4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000499c:	66 0c       	ld.w	r12,r3[0x0]
8000499e:	40 0b       	lddsp	r11,sp[0x0]
800049a0:	f0 1f 00 0e 	mcall	800049d8 <xcmp_rx_process+0xf8>
800049a4:	ca 7b       	rjmp	800048f2 <xcmp_rx_process+0x12>
800049a6:	00 00       	add	r0,r0
800049a8:	00 00       	add	r0,r0
800049aa:	0b 20       	ld.uh	r0,r5++
800049ac:	00 00       	add	r0,r0
800049ae:	0a b8       	st.h	r5++,r8
800049b0:	00 00       	add	r0,r0
800049b2:	0b 30       	ld.ub	r0,r5++
800049b4:	00 00       	add	r0,r0
800049b6:	0b 24       	ld.uh	r4,r5++
800049b8:	00 00       	add	r0,r0
800049ba:	0b 14       	ld.sh	r4,r5++
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	6f 24       	ld.w	r4,r7[0x48]
800049c0:	00 00       	add	r0,r0
800049c2:	0b 48       	ld.w	r8,--r5
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	47 e4       	lddsp	r4,sp[0x1f8]
800049c8:	00 00       	add	r0,r0
800049ca:	0b 08       	ld.w	r8,r5++
800049cc:	00 00       	add	r0,r0
800049ce:	0b 3c       	ld.ub	r12,r5++
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	47 c0       	lddsp	r0,sp[0x1f0]
800049d4:	00 00       	add	r0,r0
800049d6:	51 94       	stdsp	sp[0x64],r4
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	33 c8       	mov	r8,60

800049dc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800049dc:	eb cd 40 90 	pushm	r4,r7,lr
800049e0:	20 1d       	sub	sp,4
800049e2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800049e6:	48 c8       	lddpc	r8,80004a14 <xcmp_rx+0x38>
800049e8:	70 0c       	ld.w	r12,r8[0x0]
800049ea:	f0 1f 00 0c 	mcall	80004a18 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800049ee:	c1 00       	breq	80004a0e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800049f0:	fa c7 ff fc 	sub	r7,sp,-4
800049f4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800049f6:	e0 6a 00 ca 	mov	r10,202
800049fa:	08 9b       	mov	r11,r4
800049fc:	f0 1f 00 08 	mcall	80004a1c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004a00:	48 88       	lddpc	r8,80004a20 <xcmp_rx+0x44>
80004a02:	70 0c       	ld.w	r12,r8[0x0]
80004a04:	30 09       	mov	r9,0
80004a06:	12 9a       	mov	r10,r9
80004a08:	1a 9b       	mov	r11,sp
80004a0a:	f0 1f 00 07 	mcall	80004a24 <xcmp_rx+0x48>
	}	
}
80004a0e:	2f fd       	sub	sp,-4
80004a10:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004a14:	00 00       	add	r0,r0
80004a16:	0a b8       	st.h	r5++,r8
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	35 74       	mov	r4,87
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	86 2a       	ld.sh	r10,r3[0x4]
80004a20:	00 00       	add	r0,r0
80004a22:	0b 20       	ld.uh	r0,r5++
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	71 30       	ld.w	r0,r8[0x4c]

80004a28 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004a28:	48 28       	lddpc	r8,80004a30 <xnl_register_xcmp_func+0x8>
80004a2a:	91 0c       	st.w	r8[0x0],r12
}
80004a2c:	5e fc       	retal	r12
80004a2e:	00 00       	add	r0,r0
80004a30:	00 00       	add	r0,r0
80004a32:	0b 74       	ld.ub	r4,--r5

80004a34 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004a34:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004a36:	48 88       	lddpc	r8,80004a54 <xnl_get_msg_ack_func+0x20>
80004a38:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004a3a:	98 49       	ld.sh	r9,r12[0x8]
80004a3c:	f0 09 19 00 	cp.h	r9,r8
80004a40:	c0 81       	brne	80004a50 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004a42:	48 68       	lddpc	r8,80004a58 <xnl_get_msg_ack_func+0x24>
80004a44:	70 0c       	ld.w	r12,r8[0x0]
80004a46:	30 09       	mov	r9,0
80004a48:	12 9a       	mov	r10,r9
80004a4a:	12 9b       	mov	r11,r9
80004a4c:	f0 1f 00 04 	mcall	80004a5c <xnl_get_msg_ack_func+0x28>
80004a50:	d8 02       	popm	pc
80004a52:	00 00       	add	r0,r0
80004a54:	00 00       	add	r0,r0
80004a56:	0b 5a       	ld.sh	r10,--r5
80004a58:	00 00       	add	r0,r0
80004a5a:	0b 54       	ld.sh	r4,--r5
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	71 30       	ld.w	r0,r8[0x4c]

80004a60 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a60:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004a64:	30 09       	mov	r9,0
80004a66:	4b 78       	lddpc	r8,80004b40 <xnl_init+0xe0>
80004a68:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004a6a:	30 0b       	mov	r11,0
80004a6c:	30 1c       	mov	r12,1
80004a6e:	f0 1f 00 36 	mcall	80004b44 <xnl_init+0xe4>
80004a72:	4b 68       	lddpc	r8,80004b48 <xnl_init+0xe8>
80004a74:	91 0c       	st.w	r8[0x0],r12
80004a76:	70 08       	ld.w	r8,r8[0x0]
80004a78:	58 08       	cp.w	r8,0
80004a7a:	c0 80       	breq	80004a8a <xnl_init+0x2a>
80004a7c:	4b 38       	lddpc	r8,80004b48 <xnl_init+0xe8>
80004a7e:	70 0c       	ld.w	r12,r8[0x0]
80004a80:	30 09       	mov	r9,0
80004a82:	12 9a       	mov	r10,r9
80004a84:	12 9b       	mov	r11,r9
80004a86:	f0 1f 00 32 	mcall	80004b4c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004a8a:	30 4b       	mov	r11,4
80004a8c:	31 4c       	mov	r12,20
80004a8e:	f0 1f 00 2e 	mcall	80004b44 <xnl_init+0xe4>
80004a92:	4b 08       	lddpc	r8,80004b50 <xnl_init+0xf0>
80004a94:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004a96:	30 4b       	mov	r11,4
80004a98:	31 ec       	mov	r12,30
80004a9a:	f0 1f 00 2b 	mcall	80004b44 <xnl_init+0xe4>
80004a9e:	4a e8       	lddpc	r8,80004b54 <xnl_init+0xf4>
80004aa0:	91 0c       	st.w	r8[0x0],r12
80004aa2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004aa4:	10 96       	mov	r6,r8
80004aa6:	4a d5       	lddpc	r5,80004b58 <xnl_init+0xf8>
80004aa8:	6c 0c       	ld.w	r12,r6[0x0]
80004aaa:	ea 07 00 0b 	add	r11,r5,r7
80004aae:	f0 1f 00 2c 	mcall	80004b5c <xnl_init+0xfc>
80004ab2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004ab6:	e0 47 1e 00 	cp.w	r7,7680
80004aba:	cf 71       	brne	80004aa8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004abc:	30 4b       	mov	r11,4
80004abe:	31 4c       	mov	r12,20
80004ac0:	f0 1f 00 21 	mcall	80004b44 <xnl_init+0xe4>
80004ac4:	4a 78       	lddpc	r8,80004b60 <xnl_init+0x100>
80004ac6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004ac8:	30 4b       	mov	r11,4
80004aca:	30 ac       	mov	r12,10
80004acc:	f0 1f 00 1e 	mcall	80004b44 <xnl_init+0xe4>
80004ad0:	4a 58       	lddpc	r8,80004b64 <xnl_init+0x104>
80004ad2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004ad4:	30 4b       	mov	r11,4
80004ad6:	30 ac       	mov	r12,10
80004ad8:	f0 1f 00 1b 	mcall	80004b44 <xnl_init+0xe4>
80004adc:	4a 38       	lddpc	r8,80004b68 <xnl_init+0x108>
80004ade:	91 0c       	st.w	r8[0x0],r12
80004ae0:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004ae2:	10 96       	mov	r6,r8
80004ae4:	4a 25       	lddpc	r5,80004b6c <xnl_init+0x10c>
80004ae6:	6c 0c       	ld.w	r12,r6[0x0]
80004ae8:	ea 07 00 0b 	add	r11,r5,r7
80004aec:	f0 1f 00 1c 	mcall	80004b5c <xnl_init+0xfc>
80004af0:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004af4:	e0 47 14 00 	cp.w	r7,5120
80004af8:	cf 71       	brne	80004ae6 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004afa:	30 4b       	mov	r11,4
80004afc:	30 5c       	mov	r12,5
80004afe:	f0 1f 00 12 	mcall	80004b44 <xnl_init+0xe4>
80004b02:	49 c8       	lddpc	r8,80004b70 <xnl_init+0x110>
80004b04:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004b06:	30 07       	mov	r7,0
80004b08:	1a d7       	st.w	--sp,r7
80004b0a:	1a d7       	st.w	--sp,r7
80004b0c:	1a d7       	st.w	--sp,r7
80004b0e:	30 38       	mov	r8,3
80004b10:	0e 99       	mov	r9,r7
80004b12:	e0 6a 00 dc 	mov	r10,220
80004b16:	49 8b       	lddpc	r11,80004b74 <xnl_init+0x114>
80004b18:	49 8c       	lddpc	r12,80004b78 <xnl_init+0x118>
80004b1a:	f0 1f 00 19 	mcall	80004b7c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004b1e:	1a d7       	st.w	--sp,r7
80004b20:	1a d7       	st.w	--sp,r7
80004b22:	1a d7       	st.w	--sp,r7
80004b24:	30 38       	mov	r8,3
80004b26:	0e 99       	mov	r9,r7
80004b28:	e0 6a 00 82 	mov	r10,130
80004b2c:	49 5b       	lddpc	r11,80004b80 <xnl_init+0x120>
80004b2e:	49 6c       	lddpc	r12,80004b84 <xnl_init+0x124>
80004b30:	f0 1f 00 13 	mcall	80004b7c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004b34:	f0 1f 00 15 	mcall	80004b88 <xnl_init+0x128>
80004b38:	2f ad       	sub	sp,-24
}
80004b3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b3e:	00 00       	add	r0,r0
80004b40:	00 00       	add	r0,r0
80004b42:	0b 5a       	ld.sh	r10,--r5
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	72 88       	ld.w	r8,r9[0x20]
80004b48:	00 00       	add	r0,r0
80004b4a:	0b 54       	ld.sh	r4,--r5
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	71 30       	ld.w	r0,r8[0x4c]
80004b50:	00 00       	add	r0,r0
80004b52:	0b 68       	ld.uh	r8,--r5
80004b54:	00 00       	add	r0,r0
80004b56:	0a b8       	st.h	r5++,r8
80004b58:	00 00       	add	r0,r0
80004b5a:	33 46       	mov	r6,52
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	33 c8       	mov	r8,60
80004b60:	00 00       	add	r0,r0
80004b62:	0a e8       	st.h	--r5,r8
80004b64:	00 00       	add	r0,r0
80004b66:	0a c8       	st.b	r5++,r8
80004b68:	00 00       	add	r0,r0
80004b6a:	0a bc       	st.h	r5++,r12
80004b6c:	00 00       	add	r0,r0
80004b6e:	1f 46       	ld.w	r6,--pc
80004b70:	00 00       	add	r0,r0
80004b72:	0a f4       	st.b	--r5,r4
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	e7 2c 80 00 	ld.sb	r12,r3[-32768]
80004b7a:	4b 8c       	lddpc	r12,80004c58 <xnl_tx_process+0x6c>
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	79 bc       	ld.w	r12,r12[0x6c]
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	e7 34 80 00 	ld.ub	r4,r3[-32768]
80004b86:	4b ec       	lddpc	r12,80004c7c <xnl_tx_process+0x90>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	35 9c       	mov	r12,89

80004b8c <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004b8c:	eb cd 40 fe 	pushm	r1-r7,lr
80004b90:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004b92:	49 26       	lddpc	r6,80004bd8 <xnl_rx_process+0x4c>
80004b94:	30 05       	mov	r5,0
80004b96:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004b98:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004b9a:	49 11       	lddpc	r1,80004bdc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004b9c:	49 12       	lddpc	r2,80004be0 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004b9e:	6c 0c       	ld.w	r12,r6[0x0]
80004ba0:	0a 99       	mov	r9,r5
80004ba2:	08 9a       	mov	r10,r4
80004ba4:	1a 9b       	mov	r11,sp
80004ba6:	f0 1f 00 10 	mcall	80004be4 <xnl_rx_process+0x58>
80004baa:	58 1c       	cp.w	r12,1
80004bac:	cf 91       	brne	80004b9e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004bae:	40 0c       	lddsp	r12,sp[0x0]
80004bb0:	58 0c       	cp.w	r12,0
80004bb2:	cf 60       	breq	80004b9e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004bb4:	98 28       	ld.sh	r8,r12[0x4]
80004bb6:	e6 08 19 00 	cp.h	r8,r3
80004bba:	e0 8b 00 0a 	brhi	80004bce <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004bbe:	5c 78       	castu.h	r8
80004bc0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004bc4:	58 09       	cp.w	r9,0
80004bc6:	c0 40       	breq	80004bce <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004bc8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004bcc:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004bce:	62 0c       	ld.w	r12,r1[0x0]
80004bd0:	40 0b       	lddsp	r11,sp[0x0]
80004bd2:	f0 1f 00 06 	mcall	80004be8 <xnl_rx_process+0x5c>
80004bd6:	ce 4b       	rjmp	80004b9e <xnl_rx_process+0x12>
80004bd8:	00 00       	add	r0,r0
80004bda:	0a c8       	st.b	r5++,r8
80004bdc:	00 00       	add	r0,r0
80004bde:	0a b8       	st.h	r5++,r8
80004be0:	00 00       	add	r0,r0
80004be2:	04 fc       	st.b	--r2,r12
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	6f 24       	ld.w	r4,r7[0x48]
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	33 c8       	mov	r8,60

80004bec <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004bec:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004bee:	4a a6       	lddpc	r6,80004c94 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004bf0:	4a a2       	lddpc	r2,80004c98 <xnl_tx_process+0xac>
80004bf2:	4a b4       	lddpc	r4,80004c9c <xnl_tx_process+0xb0>
80004bf4:	30 07       	mov	r7,0
80004bf6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004bf8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004bfa:	4a a5       	lddpc	r5,80004ca0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004bfc:	4a a3       	lddpc	r3,80004ca4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004bfe:	6c 08       	ld.w	r8,r6[0x0]
80004c00:	58 08       	cp.w	r8,0
80004c02:	c0 40       	breq	80004c0a <xnl_tx_process+0x1e>
80004c04:	58 18       	cp.w	r8,1
80004c06:	cf d1       	brne	80004c00 <xnl_tx_process+0x14>
80004c08:	c2 48       	rjmp	80004c50 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004c0a:	64 0c       	ld.w	r12,r2[0x0]
80004c0c:	0e 99       	mov	r9,r7
80004c0e:	02 9a       	mov	r10,r1
80004c10:	08 9b       	mov	r11,r4
80004c12:	f0 1f 00 26 	mcall	80004ca8 <xnl_tx_process+0xbc>
80004c16:	58 1c       	cp.w	r12,1
80004c18:	cf 31       	brne	80004bfe <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004c1a:	68 0b       	ld.w	r11,r4[0x0]
80004c1c:	58 0b       	cp.w	r11,0
80004c1e:	cf 00       	breq	80004bfe <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004c20:	96 28       	ld.sh	r8,r11[0x4]
80004c22:	e0 08 19 00 	cp.h	r8,r0
80004c26:	c0 71       	brne	80004c34 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004c28:	4a 18       	lddpc	r8,80004cac <xnl_tx_process+0xc0>
80004c2a:	70 08       	ld.w	r8,r8[0x0]
80004c2c:	10 9c       	mov	r12,r8
80004c2e:	f0 1f 00 21 	mcall	80004cb0 <xnl_tx_process+0xc4>
						break;
80004c32:	ce 6b       	rjmp	80004bfe <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004c34:	16 9c       	mov	r12,r11
80004c36:	f0 1f 00 20 	mcall	80004cb4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004c3a:	30 18       	mov	r8,1
80004c3c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004c3e:	66 0c       	ld.w	r12,r3[0x0]
80004c40:	0e 99       	mov	r9,r7
80004c42:	0e 9a       	mov	r10,r7
80004c44:	0e 9b       	mov	r11,r7
80004c46:	f0 1f 00 19 	mcall	80004ca8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004c4a:	30 18       	mov	r8,1
80004c4c:	8d 08       	st.w	r6[0x0],r8
80004c4e:	cd 8b       	rjmp	80004bfe <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004c50:	66 0c       	ld.w	r12,r3[0x0]
80004c52:	0e 99       	mov	r9,r7
80004c54:	36 4a       	mov	r10,100
80004c56:	0e 9b       	mov	r11,r7
80004c58:	f0 1f 00 14 	mcall	80004ca8 <xnl_tx_process+0xbc>
80004c5c:	58 1c       	cp.w	r12,1
80004c5e:	c0 81       	brne	80004c6e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004c60:	49 38       	lddpc	r8,80004cac <xnl_tx_process+0xc0>
80004c62:	70 0c       	ld.w	r12,r8[0x0]
80004c64:	68 0b       	ld.w	r11,r4[0x0]
80004c66:	f0 1f 00 13 	mcall	80004cb0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004c6a:	8d 07       	st.w	r6[0x0],r7
80004c6c:	cc 9b       	rjmp	80004bfe <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004c6e:	6a 08       	ld.w	r8,r5[0x0]
80004c70:	58 38       	cp.w	r8,3
80004c72:	e0 89 00 09 	brgt	80004c84 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004c76:	68 0c       	ld.w	r12,r4[0x0]
80004c78:	f0 1f 00 0f 	mcall	80004cb4 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004c7c:	6a 08       	ld.w	r8,r5[0x0]
80004c7e:	2f f8       	sub	r8,-1
80004c80:	8b 08       	st.w	r5[0x0],r8
80004c82:	cb eb       	rjmp	80004bfe <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004c84:	48 a8       	lddpc	r8,80004cac <xnl_tx_process+0xc0>
80004c86:	70 0c       	ld.w	r12,r8[0x0]
80004c88:	68 0b       	ld.w	r11,r4[0x0]
80004c8a:	f0 1f 00 0a 	mcall	80004cb0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004c8e:	8d 07       	st.w	r6[0x0],r7
80004c90:	cb 7b       	rjmp	80004bfe <xnl_tx_process+0x12>
80004c92:	00 00       	add	r0,r0
80004c94:	00 00       	add	r0,r0
80004c96:	0b 64       	ld.uh	r4,--r5
80004c98:	00 00       	add	r0,r0
80004c9a:	0b 68       	ld.uh	r8,--r5
80004c9c:	00 00       	add	r0,r0
80004c9e:	0b 70       	ld.ub	r0,--r5
80004ca0:	00 00       	add	r0,r0
80004ca2:	0b 6c       	ld.uh	r12,--r5
80004ca4:	00 00       	add	r0,r0
80004ca6:	0b 54       	ld.sh	r4,--r5
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	6f 24       	ld.w	r4,r7[0x48]
80004cac:	00 00       	add	r0,r0
80004cae:	0a b8       	st.h	r5++,r8
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	33 c8       	mov	r8,60
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	33 e8       	mov	r8,62

80004cb8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004cb8:	eb cd 40 c0 	pushm	r6-r7,lr
80004cbc:	20 1d       	sub	sp,4
80004cbe:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004cc0:	98 39       	ld.sh	r9,r12[0x6]
80004cc2:	3f f8       	mov	r8,-1
80004cc4:	f0 09 19 00 	cp.h	r9,r8
80004cc8:	c0 a1       	brne	80004cdc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004cca:	4a e9       	lddpc	r9,80004d80 <xnl_tx+0xc8>
80004ccc:	13 88       	ld.ub	r8,r9[0x0]
80004cce:	2f f8       	sub	r8,-1
80004cd0:	5c 58       	castu.b	r8
80004cd2:	b2 88       	st.b	r9[0x0],r8
80004cd4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004cd8:	a9 a8       	sbr	r8,0x8
80004cda:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004cdc:	8c 49       	ld.sh	r9,r6[0x8]
80004cde:	3f f8       	mov	r8,-1
80004ce0:	f0 09 19 00 	cp.h	r9,r8
80004ce4:	c0 41       	brne	80004cec <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004ce6:	4a 88       	lddpc	r8,80004d84 <xnl_tx+0xcc>
80004ce8:	90 18       	ld.sh	r8,r8[0x2]
80004cea:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004cec:	8c 59       	ld.sh	r9,r6[0xa]
80004cee:	3f f8       	mov	r8,-1
80004cf0:	f0 09 19 00 	cp.h	r9,r8
80004cf4:	c0 41       	brne	80004cfc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004cf6:	4a 48       	lddpc	r8,80004d84 <xnl_tx+0xcc>
80004cf8:	90 28       	ld.sh	r8,r8[0x4]
80004cfa:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004cfc:	8c 69       	ld.sh	r9,r6[0xc]
80004cfe:	3f f8       	mov	r8,-1
80004d00:	f0 09 19 00 	cp.h	r9,r8
80004d04:	c0 e1       	brne	80004d20 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004d06:	4a 08       	lddpc	r8,80004d84 <xnl_tx+0xcc>
80004d08:	90 49       	ld.sh	r9,r8[0x8]
80004d0a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004d0c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004d0e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004d10:	90 49       	ld.sh	r9,r8[0x8]
80004d12:	e0 19 ff 00 	andl	r9,0xff00
80004d16:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004d1a:	f3 e8 10 08 	or	r8,r9,r8
80004d1e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004d20:	0d 98       	ld.ub	r8,r6[0x1]
80004d22:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004d24:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004d28:	10 0c       	add	r12,r8
80004d2a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004d2c:	58 0c       	cp.w	r12,0
80004d2e:	e0 89 00 04 	brgt	80004d36 <xnl_tx+0x7e>
80004d32:	30 09       	mov	r9,0
80004d34:	c0 d8       	rjmp	80004d4e <xnl_tx+0x96>
80004d36:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004d3a:	2f ec       	sub	r12,-2
80004d3c:	30 09       	mov	r9,0
80004d3e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004d40:	15 1b       	ld.sh	r11,r10++
80004d42:	f6 09 00 09 	add	r9,r11,r9
80004d46:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004d48:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004d4a:	18 38       	cp.w	r8,r12
80004d4c:	cf a1       	brne	80004d40 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004d4e:	5c 39       	neg	r9
80004d50:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004d52:	48 e8       	lddpc	r8,80004d88 <xnl_tx+0xd0>
80004d54:	70 0c       	ld.w	r12,r8[0x0]
80004d56:	f0 1f 00 0e 	mcall	80004d8c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004d5a:	c1 00       	breq	80004d7a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004d5c:	fa c7 ff fc 	sub	r7,sp,-4
80004d60:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004d62:	e0 6a 01 00 	mov	r10,256
80004d66:	0c 9b       	mov	r11,r6
80004d68:	f0 1f 00 0a 	mcall	80004d90 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004d6c:	48 a8       	lddpc	r8,80004d94 <xnl_tx+0xdc>
80004d6e:	70 0c       	ld.w	r12,r8[0x0]
80004d70:	30 09       	mov	r9,0
80004d72:	12 9a       	mov	r10,r9
80004d74:	1a 9b       	mov	r11,sp
80004d76:	f0 1f 00 09 	mcall	80004d98 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004d7a:	2f fd       	sub	sp,-4
80004d7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d80:	00 00       	add	r0,r0
80004d82:	0b 58       	ld.sh	r8,--r5
80004d84:	00 00       	add	r0,r0
80004d86:	0b 5a       	ld.sh	r10,--r5
80004d88:	00 00       	add	r0,r0
80004d8a:	0a b8       	st.h	r5++,r8
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	35 74       	mov	r4,87
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	86 2a       	ld.sh	r10,r3[0x4]
80004d94:	00 00       	add	r0,r0
80004d96:	0b 68       	ld.uh	r8,--r5
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	71 30       	ld.w	r0,r8[0x4c]

80004d9c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004d9c:	eb cd 40 80 	pushm	r7,lr
80004da0:	fa cd 01 00 	sub	sp,sp,256
80004da4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004da6:	e0 68 40 0e 	mov	r8,16398
80004daa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004dac:	3f f8       	mov	r8,-1
80004dae:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004db0:	30 c8       	mov	r8,12
80004db2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004db4:	98 38       	ld.sh	r8,r12[0x6]
80004db6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004db8:	98 58       	ld.sh	r8,r12[0xa]
80004dba:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004dbc:	98 48       	ld.sh	r8,r12[0x8]
80004dbe:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004dc0:	98 68       	ld.sh	r8,r12[0xc]
80004dc2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004dc4:	30 08       	mov	r8,0
80004dc6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004dc8:	1a 9c       	mov	r12,sp
80004dca:	f0 1f 00 0a 	mcall	80004df0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004dce:	fa cd 00 cc 	sub	sp,sp,204
80004dd2:	e0 6a 00 ca 	mov	r10,202
80004dd6:	ee cb ff f0 	sub	r11,r7,-16
80004dda:	1a 9c       	mov	r12,sp
80004ddc:	f0 1f 00 06 	mcall	80004df4 <xnl_data_msg_func+0x58>
80004de0:	48 68       	lddpc	r8,80004df8 <xnl_data_msg_func+0x5c>
80004de2:	70 08       	ld.w	r8,r8[0x0]
80004de4:	5d 18       	icall	r8
80004de6:	fa cd ff 34 	sub	sp,sp,-204
}
80004dea:	2c 0d       	sub	sp,-256
80004dec:	e3 cd 80 80 	ldm	sp++,r7,pc
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4c b8       	lddpc	r8,80004f1c <xnl_master_status_brdcst_func>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	86 2a       	ld.sh	r10,r3[0x4]
80004df8:	00 00       	add	r0,r0
80004dfa:	0b 74       	ld.ub	r4,--r5

80004dfc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004dfc:	d4 21       	pushm	r4-r7,lr
80004dfe:	fa cd 01 00 	sub	sp,sp,256
80004e02:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004e04:	4c 28       	lddpc	r8,80004f0c <xnl_device_auth_reply_func+0x110>
80004e06:	11 88       	ld.ub	r8,r8[0x0]
80004e08:	58 08       	cp.w	r8,0
80004e0a:	e0 81 00 7f 	brne	80004f08 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004e0e:	4c 18       	lddpc	r8,80004f10 <xnl_device_auth_reply_func+0x114>
80004e10:	70 0c       	ld.w	r12,r8[0x0]
80004e12:	30 09       	mov	r9,0
80004e14:	12 9a       	mov	r10,r9
80004e16:	12 9b       	mov	r11,r9
80004e18:	f0 1f 00 3f 	mcall	80004f14 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004e1c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004e20:	4b b8       	lddpc	r8,80004f0c <xnl_device_auth_reply_func+0x110>
80004e22:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004e24:	ef 39 00 12 	ld.ub	r9,r7[18]
80004e28:	ef 38 00 13 	ld.ub	r8,r7[19]
80004e2c:	b1 68       	lsl	r8,0x10
80004e2e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004e32:	ef 38 00 15 	ld.ub	r8,r7[21]
80004e36:	f3 e8 10 08 	or	r8,r9,r8
80004e3a:	ef 39 00 14 	ld.ub	r9,r7[20]
80004e3e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004e42:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004e46:	ef 38 00 17 	ld.ub	r8,r7[23]
80004e4a:	b1 68       	lsl	r8,0x10
80004e4c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004e50:	ef 38 00 19 	ld.ub	r8,r7[25]
80004e54:	f5 e8 10 08 	or	r8,r10,r8
80004e58:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004e5c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004e60:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004e62:	e0 64 79 b9 	mov	r4,31161
80004e66:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004e6a:	e0 65 45 07 	mov	r5,17671
80004e6e:	ea 15 8a bd 	orh	r5,0x8abd
80004e72:	e0 66 f9 3d 	mov	r6,63805
80004e76:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004e7a:	e0 6e b8 cf 	mov	lr,47311
80004e7e:	ea 1e 36 83 	orh	lr,0x3683
80004e82:	e0 67 aa 1c 	mov	r7,43548
80004e86:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004e8a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004e8c:	f4 08 00 0c 	add	r12,r10,r8
80004e90:	f0 0b 15 04 	lsl	r11,r8,0x4
80004e94:	0a 0b       	add	r11,r5
80004e96:	f9 eb 20 0b 	eor	r11,r12,r11
80004e9a:	f0 0c 16 05 	lsr	r12,r8,0x5
80004e9e:	0c 0c       	add	r12,r6
80004ea0:	18 5b       	eor	r11,r12
80004ea2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004ea4:	f2 0c 15 04 	lsl	r12,r9,0x4
80004ea8:	1c 0c       	add	r12,lr
80004eaa:	f2 0b 16 05 	lsr	r11,r9,0x5
80004eae:	0e 0b       	add	r11,r7
80004eb0:	f9 eb 20 0b 	eor	r11,r12,r11
80004eb4:	f2 0a 00 0c 	add	r12,r9,r10
80004eb8:	18 5b       	eor	r11,r12
80004eba:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004ebc:	e0 6b 37 20 	mov	r11,14112
80004ec0:	ea 1b c6 ef 	orh	r11,0xc6ef
80004ec4:	16 3a       	cp.w	r10,r11
80004ec6:	ce 21       	brne	80004e8a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004ec8:	e0 6a 40 1a 	mov	r10,16410
80004ecc:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004ece:	3f fa       	mov	r10,-1
80004ed0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004ed2:	30 6b       	mov	r11,6
80004ed4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ed6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ed8:	48 db       	lddpc	r11,80004f0c <xnl_device_auth_reply_func+0x110>
80004eda:	96 1c       	ld.sh	r12,r11[0x2]
80004edc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004ede:	96 2b       	ld.sh	r11,r11[0x4]
80004ee0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004ee2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004ee4:	30 ca       	mov	r10,12
80004ee6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004ee8:	30 0a       	mov	r10,0
80004eea:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004eee:	30 7a       	mov	r10,7
80004ef0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004ef4:	30 2a       	mov	r10,2
80004ef6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004efa:	fa ca ff ec 	sub	r10,sp,-20
80004efe:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004f00:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004f02:	1a 9c       	mov	r12,sp
80004f04:	f0 1f 00 05 	mcall	80004f18 <xnl_device_auth_reply_func+0x11c>
}
80004f08:	2c 0d       	sub	sp,-256
80004f0a:	d8 22       	popm	r4-r7,pc
80004f0c:	00 00       	add	r0,r0
80004f0e:	0b 5a       	ld.sh	r10,--r5
80004f10:	00 00       	add	r0,r0
80004f12:	0b 54       	ld.sh	r4,--r5
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	71 30       	ld.w	r0,r8[0x4c]
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	4c b8       	lddpc	r8,80005044 <RC522_ReadByte+0x8>

80004f1c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004f1c:	eb cd 40 80 	pushm	r7,lr
80004f20:	fa cd 01 00 	sub	sp,sp,256
80004f24:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004f26:	49 28       	lddpc	r8,80004f6c <xnl_master_status_brdcst_func+0x50>
80004f28:	11 88       	ld.ub	r8,r8[0x0]
80004f2a:	58 08       	cp.w	r8,0
80004f2c:	c1 c1       	brne	80004f64 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004f2e:	49 18       	lddpc	r8,80004f70 <xnl_master_status_brdcst_func+0x54>
80004f30:	70 0c       	ld.w	r12,r8[0x0]
80004f32:	30 09       	mov	r9,0
80004f34:	12 9a       	mov	r10,r9
80004f36:	12 9b       	mov	r11,r9
80004f38:	f0 1f 00 0f 	mcall	80004f74 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004f3c:	8e 58       	ld.sh	r8,r7[0xa]
80004f3e:	48 c9       	lddpc	r9,80004f6c <xnl_master_status_brdcst_func+0x50>
80004f40:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f42:	e0 68 40 0e 	mov	r8,16398
80004f46:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f48:	3f f8       	mov	r8,-1
80004f4a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004f4c:	30 4a       	mov	r10,4
80004f4e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004f50:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004f52:	92 19       	ld.sh	r9,r9[0x2]
80004f54:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004f56:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004f58:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004f5a:	30 08       	mov	r8,0
80004f5c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004f5e:	1a 9c       	mov	r12,sp
80004f60:	f0 1f 00 06 	mcall	80004f78 <xnl_master_status_brdcst_func+0x5c>
}
80004f64:	2c 0d       	sub	sp,-256
80004f66:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f6a:	00 00       	add	r0,r0
80004f6c:	00 00       	add	r0,r0
80004f6e:	0b 5a       	ld.sh	r10,--r5
80004f70:	00 00       	add	r0,r0
80004f72:	0b 54       	ld.sh	r4,--r5
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	71 30       	ld.w	r0,r8[0x4c]
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4c b8       	lddpc	r8,800050a4 <WriteRawRC+0xc>

80004f7c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004f82:	49 28       	lddpc	r8,80004fc8 <xnl_device_conn_reply_func+0x4c>
80004f84:	70 0c       	ld.w	r12,r8[0x0]
80004f86:	30 09       	mov	r9,0
80004f88:	12 9a       	mov	r10,r9
80004f8a:	12 9b       	mov	r11,r9
80004f8c:	f0 1f 00 10 	mcall	80004fcc <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004f90:	ef 18 00 10 	ld.uh	r8,r7[16]
80004f94:	10 99       	mov	r9,r8
80004f96:	e2 19 ff 00 	andl	r9,0xff00,COH
80004f9a:	e0 49 01 00 	cp.w	r9,256
80004f9e:	c0 60       	breq	80004faa <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004fa0:	0e 9c       	mov	r12,r7
80004fa2:	f0 1f 00 0c 	mcall	80004fd0 <xnl_device_conn_reply_func+0x54>
80004fa6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004faa:	a9 68       	lsl	r8,0x8
80004fac:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004fb0:	48 98       	lddpc	r8,80004fd4 <xnl_device_conn_reply_func+0x58>
80004fb2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004fb4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004fb8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004fba:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004fbe:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004fc0:	30 19       	mov	r9,1
80004fc2:	b0 89       	st.b	r8[0x0],r9
80004fc4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fc8:	00 00       	add	r0,r0
80004fca:	0b 54       	ld.sh	r4,--r5
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	71 30       	ld.w	r0,r8[0x4c]
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	4f 1c       	lddpc	r12,80005194 <ReadRawRC+0x3c>
80004fd4:	00 00       	add	r0,r0
80004fd6:	0b 5a       	ld.sh	r10,--r5

80004fd8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004fd8:	d4 01       	pushm	lr
80004fda:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004fde:	e0 68 40 0e 	mov	r8,16398
80004fe2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004fe4:	3f f8       	mov	r8,-1
80004fe6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004fe8:	30 38       	mov	r8,3
80004fea:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004fec:	30 08       	mov	r8,0
80004fee:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004ff0:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004ff2:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004ff4:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004ff6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ff8:	1a 9c       	mov	r12,sp
80004ffa:	f0 1f 00 03 	mcall	80005004 <xnl_send_device_master_query+0x2c>
}
80004ffe:	2c 0d       	sub	sp,-256
80005000:	d8 02       	popm	pc
80005002:	00 00       	add	r0,r0
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	4c b8       	lddpc	r8,80005130 <PcdReset+0x58>

80005008 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80005008:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000500a:	48 78       	lddpc	r8,80005024 <RC522_SPI_SetSpeed+0x1c>
8000500c:	70 09       	ld.w	r9,r8[0x0]
8000500e:	72 ca       	ld.w	r10,r9[0x30]
80005010:	5c 7c       	castu.h	r12
80005012:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80005016:	f9 ea 10 0a 	or	r10,r12,r10
8000501a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000501c:	70 0c       	ld.w	r12,r8[0x0]
8000501e:	f0 1f 00 03 	mcall	80005028 <RC522_SPI_SetSpeed+0x20>
		
	
}
80005022:	d8 02       	popm	pc
80005024:	00 00       	add	r0,r0
80005026:	1e 20       	rsub	r0,pc
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	66 20       	ld.w	r0,r3[0x8]

8000502c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000502c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000502e:	e0 6c 0a 00 	mov	r12,2560
80005032:	f0 1f 00 02 	mcall	80005038 <RC522_SPI_SetSpeedLow+0xc>
	
}
80005036:	d8 02       	popm	pc
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	50 08       	stdsp	sp[0x0],r8

8000503c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000503c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80005040:	48 76       	lddpc	r6,8000505c <RC522_ReadByte+0x20>
80005042:	e0 6b 00 ff 	mov	r11,255
80005046:	6c 0c       	ld.w	r12,r6[0x0]
80005048:	f0 1f 00 06 	mcall	80005060 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000504c:	30 07       	mov	r7,0
8000504e:	0e 9b       	mov	r11,r7
80005050:	6c 0c       	ld.w	r12,r6[0x0]
80005052:	f0 1f 00 05 	mcall	80005064 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80005056:	0f 9c       	ld.ub	r12,r7[0x1]
80005058:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000505c:	00 00       	add	r0,r0
8000505e:	1e 20       	rsub	r0,pc
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	66 26       	ld.w	r6,r3[0x8]
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	66 42       	ld.w	r2,r3[0x10]

80005068 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80005068:	eb cd 40 80 	pushm	r7,lr
8000506c:	20 1d       	sub	sp,4
8000506e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80005070:	48 77       	lddpc	r7,8000508c <RC522_WriteByte+0x24>
80005072:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80005076:	6e 0c       	ld.w	r12,r7[0x0]
80005078:	f0 1f 00 06 	mcall	80005090 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000507c:	1a 9b       	mov	r11,sp
8000507e:	6e 0c       	ld.w	r12,r7[0x0]
80005080:	f0 1f 00 05 	mcall	80005094 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80005084:	5c 5c       	castu.b	r12
80005086:	2f fd       	sub	sp,-4
80005088:	e3 cd 80 80 	ldm	sp++,r7,pc
8000508c:	00 00       	add	r0,r0
8000508e:	1e 20       	rsub	r0,pc
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	66 26       	ld.w	r6,r3[0x8]
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	66 42       	ld.w	r2,r3[0x10]

80005098 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005098:	eb cd 40 e0 	pushm	r5-r7,lr
8000509c:	18 96       	mov	r6,r12
8000509e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800050a0:	48 a7       	lddpc	r7,800050c8 <WriteRawRC+0x30>
800050a2:	30 0b       	mov	r11,0
800050a4:	6e 0c       	ld.w	r12,r7[0x0]
800050a6:	f0 1f 00 0a 	mcall	800050cc <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800050aa:	ec 0c 15 01 	lsl	r12,r6,0x1
800050ae:	e2 1c 00 7e 	andl	r12,0x7e,COH
800050b2:	f0 1f 00 08 	mcall	800050d0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800050b6:	0a 9c       	mov	r12,r5
800050b8:	f0 1f 00 06 	mcall	800050d0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800050bc:	30 0b       	mov	r11,0
800050be:	6e 0c       	ld.w	r12,r7[0x0]
800050c0:	f0 1f 00 05 	mcall	800050d4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800050c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050c8:	00 00       	add	r0,r0
800050ca:	1e 20       	rsub	r0,pc
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	67 8c       	ld.w	r12,r3[0x60]
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	50 68       	stdsp	sp[0x18],r8
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	67 4c       	ld.w	r12,r3[0x50]

800050d8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800050d8:	d4 01       	pushm	lr

	SET_RC522RST;
800050da:	31 9c       	mov	r12,25
800050dc:	f0 1f 00 1b 	mcall	80005148 <PcdReset+0x70>
	delay_ns(10);
800050e0:	30 ac       	mov	r12,10
800050e2:	f0 1f 00 1b 	mcall	8000514c <PcdReset+0x74>

	CLR_RC522RST;
800050e6:	31 9c       	mov	r12,25
800050e8:	f0 1f 00 1a 	mcall	80005150 <PcdReset+0x78>
	delay_ns(10);
800050ec:	30 ac       	mov	r12,10
800050ee:	f0 1f 00 18 	mcall	8000514c <PcdReset+0x74>

	SET_RC522RST;
800050f2:	31 9c       	mov	r12,25
800050f4:	f0 1f 00 15 	mcall	80005148 <PcdReset+0x70>
	delay_ns(10);
800050f8:	30 ac       	mov	r12,10
800050fa:	f0 1f 00 15 	mcall	8000514c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800050fe:	30 fb       	mov	r11,15
80005100:	30 1c       	mov	r12,1
80005102:	f0 1f 00 15 	mcall	80005154 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80005106:	30 fb       	mov	r11,15
80005108:	30 1c       	mov	r12,1
8000510a:	f0 1f 00 13 	mcall	80005154 <PcdReset+0x7c>
	delay_ns(10);
8000510e:	30 ac       	mov	r12,10
80005110:	f0 1f 00 0f 	mcall	8000514c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80005114:	33 db       	mov	r11,61
80005116:	31 1c       	mov	r12,17
80005118:	f0 1f 00 0f 	mcall	80005154 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000511c:	31 eb       	mov	r11,30
8000511e:	32 dc       	mov	r12,45
80005120:	f0 1f 00 0d 	mcall	80005154 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80005124:	30 0b       	mov	r11,0
80005126:	32 cc       	mov	r12,44
80005128:	f0 1f 00 0b 	mcall	80005154 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000512c:	e0 6b 00 8d 	mov	r11,141
80005130:	32 ac       	mov	r12,42
80005132:	f0 1f 00 09 	mcall	80005154 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80005136:	33 eb       	mov	r11,62
80005138:	32 bc       	mov	r12,43
8000513a:	f0 1f 00 07 	mcall	80005154 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000513e:	34 0b       	mov	r11,64
80005140:	31 5c       	mov	r12,21
80005142:	f0 1f 00 05 	mcall	80005154 <PcdReset+0x7c>
	
	return MI_OK;
}
80005146:	d8 0a       	popm	pc,r12=0
80005148:	80 00       	ld.sh	r0,r0[0x0]
8000514a:	61 94       	ld.w	r4,r0[0x64]
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	5a 14       	cp.w	r4,-31
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	61 b0       	ld.w	r0,r0[0x6c]
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	50 98       	stdsp	sp[0x24],r8

80005158 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80005158:	eb cd 40 c0 	pushm	r6-r7,lr
8000515c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000515e:	48 c7       	lddpc	r7,8000518c <ReadRawRC+0x34>
80005160:	30 0b       	mov	r11,0
80005162:	6e 0c       	ld.w	r12,r7[0x0]
80005164:	f0 1f 00 0b 	mcall	80005190 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80005168:	a1 76       	lsl	r6,0x1
8000516a:	0c 9c       	mov	r12,r6
8000516c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005170:	a7 bc       	sbr	r12,0x7
80005172:	f0 1f 00 09 	mcall	80005194 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80005176:	f0 1f 00 09 	mcall	80005198 <ReadRawRC+0x40>
8000517a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000517c:	30 0b       	mov	r11,0
8000517e:	6e 0c       	ld.w	r12,r7[0x0]
80005180:	f0 1f 00 07 	mcall	8000519c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80005184:	0c 9c       	mov	r12,r6
80005186:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000518a:	00 00       	add	r0,r0
8000518c:	00 00       	add	r0,r0
8000518e:	1e 20       	rsub	r0,pc
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	67 8c       	ld.w	r12,r3[0x60]
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	50 68       	stdsp	sp[0x18],r8
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	50 3c       	stdsp	sp[0xc],r12
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	67 4c       	ld.w	r12,r3[0x50]

800051a0 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800051a0:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800051a2:	30 1c       	mov	r12,1
800051a4:	f0 1f 00 02 	mcall	800051ac <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800051a8:	d8 02       	popm	pc
800051aa:	00 00       	add	r0,r0
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	51 58       	stdsp	sp[0x54],r8

800051b0 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800051b0:	eb cd 40 80 	pushm	r7,lr
800051b4:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800051b6:	30 1c       	mov	r12,1
800051b8:	f0 1f 00 0d 	mcall	800051ec <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800051bc:	30 18       	mov	r8,1
800051be:	f0 07 18 00 	cp.b	r7,r8
800051c2:	c0 91       	brne	800051d4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800051c4:	18 9b       	mov	r11,r12
800051c6:	a5 ab       	sbr	r11,0x4
800051c8:	5c 5b       	castu.b	r11
800051ca:	30 1c       	mov	r12,1
800051cc:	f0 1f 00 09 	mcall	800051f0 <Powerdown_RC522+0x40>
800051d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800051d4:	18 9b       	mov	r11,r12
800051d6:	30 1c       	mov	r12,1
800051d8:	f0 1f 00 06 	mcall	800051f0 <Powerdown_RC522+0x40>
		delay_ns(2);
800051dc:	30 2c       	mov	r12,2
800051de:	f0 1f 00 06 	mcall	800051f4 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800051e2:	f0 1f 00 06 	mcall	800051f8 <Powerdown_RC522+0x48>
800051e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800051ea:	00 00       	add	r0,r0
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	51 58       	stdsp	sp[0x54],r8
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	50 98       	stdsp	sp[0x24],r8
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	5a 14       	cp.w	r4,-31
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	51 a0       	stdsp	sp[0x68],r0

800051fc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800051fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005200:	18 97       	mov	r7,r12
80005202:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80005204:	f0 1f 00 05 	mcall	80005218 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005208:	f9 e6 10 0b 	or	r11,r12,r6
8000520c:	5c 5b       	castu.b	r11
8000520e:	0e 9c       	mov	r12,r7
80005210:	f0 1f 00 03 	mcall	8000521c <SetBitMask+0x20>
}
80005214:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	51 58       	stdsp	sp[0x54],r8
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	50 98       	stdsp	sp[0x24],r8

80005220 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80005220:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80005222:	31 4c       	mov	r12,20
80005224:	f0 1f 00 05 	mcall	80005238 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005228:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000522c:	c0 51       	brne	80005236 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000522e:	30 3b       	mov	r11,3
80005230:	31 4c       	mov	r12,20
80005232:	f0 1f 00 03 	mcall	8000523c <PcdAntennaOn+0x1c>
80005236:	d8 02       	popm	pc
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	51 58       	stdsp	sp[0x54],r8
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	51 fc       	stdsp	sp[0x7c],r12

80005240 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80005240:	eb cd 40 c0 	pushm	r6-r7,lr
80005244:	18 97       	mov	r7,r12
80005246:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80005248:	f0 1f 00 06 	mcall	80005260 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
8000524c:	5c d6       	com	r6
8000524e:	f9 e6 00 06 	and	r6,r12,r6
80005252:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80005256:	0e 9c       	mov	r12,r7
80005258:	f0 1f 00 03 	mcall	80005264 <ClearBitMask+0x24>
	
}
8000525c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	51 58       	stdsp	sp[0x54],r8
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	50 98       	stdsp	sp[0x24],r8

80005268 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80005268:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000526a:	30 3b       	mov	r11,3
8000526c:	31 4c       	mov	r12,20
8000526e:	f0 1f 00 02 	mcall	80005274 <PcdAntennaOff+0xc>
}
80005272:	d8 02       	popm	pc
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	52 40       	stdsp	sp[0x90],r0

80005278 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80005278:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000527a:	34 18       	mov	r8,65
8000527c:	f0 0c 18 00 	cp.b	r12,r8
80005280:	c0 20       	breq	80005284 <M500PcdConfigISOType+0xc>
80005282:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80005284:	30 8b       	mov	r11,8
80005286:	16 9c       	mov	r12,r11
80005288:	f0 1f 00 14 	mcall	800052d8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
8000528c:	33 db       	mov	r11,61
8000528e:	31 1c       	mov	r12,17
80005290:	f0 1f 00 13 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005294:	e0 6b 00 86 	mov	r11,134
80005298:	31 7c       	mov	r12,23
8000529a:	f0 1f 00 11 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000529e:	37 fb       	mov	r11,127
800052a0:	32 6c       	mov	r12,38
800052a2:	f0 1f 00 0f 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800052a6:	31 eb       	mov	r11,30
800052a8:	32 dc       	mov	r12,45
800052aa:	f0 1f 00 0d 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800052ae:	30 0b       	mov	r11,0
800052b0:	32 cc       	mov	r12,44
800052b2:	f0 1f 00 0b 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800052b6:	e0 6b 00 8d 	mov	r11,141
800052ba:	32 ac       	mov	r12,42
800052bc:	f0 1f 00 08 	mcall	800052dc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800052c0:	33 eb       	mov	r11,62
800052c2:	32 bc       	mov	r12,43
800052c4:	f0 1f 00 06 	mcall	800052dc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800052c8:	e0 6c 03 e8 	mov	r12,1000
800052cc:	f0 1f 00 05 	mcall	800052e0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800052d0:	f0 1f 00 05 	mcall	800052e4 <M500PcdConfigISOType+0x6c>
800052d4:	d8 0a       	popm	pc,r12=0
800052d6:	00 00       	add	r0,r0
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	52 40       	stdsp	sp[0x90],r0
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	50 98       	stdsp	sp[0x24],r8
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	5a 14       	cp.w	r4,-31
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	52 20       	stdsp	sp[0x88],r0

800052e8 <rc522_init>:


//mfrc522 init

void rc522_init()
{
800052e8:	eb cd 40 80 	pushm	r7,lr
800052ec:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800052ee:	49 d8       	lddpc	r8,80005360 <rc522_init+0x78>
800052f0:	1a 97       	mov	r7,sp
800052f2:	f0 ea 00 00 	ld.d	r10,r8[0]
800052f6:	fa eb 00 00 	st.d	sp[0],r10
800052fa:	f0 e8 00 08 	ld.d	r8,r8[8]
800052fe:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80005302:	30 1b       	mov	r11,1
80005304:	49 8c       	lddpc	r12,80005364 <rc522_init+0x7c>
80005306:	f0 1f 00 19 	mcall	80005368 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000530a:	31 9c       	mov	r12,25
8000530c:	f0 1f 00 18 	mcall	8000536c <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80005310:	31 9c       	mov	r12,25
80005312:	f0 1f 00 18 	mcall	80005370 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80005316:	fe 7c 24 00 	mov	r12,-56320
8000531a:	49 78       	lddpc	r8,80005374 <rc522_init+0x8c>
8000531c:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
8000531e:	e0 6a 36 00 	mov	r10,13824
80005322:	ea 1a 01 6e 	orh	r10,0x16e
80005326:	1a 9b       	mov	r11,sp
80005328:	f0 1f 00 14 	mcall	80005378 <rc522_init+0x90>
8000532c:	c0 50       	breq	80005336 <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
8000532e:	30 29       	mov	r9,2
80005330:	49 38       	lddpc	r8,8000537c <rc522_init+0x94>
80005332:	b0 89       	st.b	r8[0x0],r9
80005334:	c0 38       	rjmp	8000533a <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80005336:	f0 1f 00 13 	mcall	80005380 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
8000533a:	f0 1f 00 13 	mcall	80005384 <rc522_init+0x9c>
	
	PcdAntennaOff();
8000533e:	f0 1f 00 13 	mcall	80005388 <rc522_init+0xa0>
	
	delay_ms(2); 
80005342:	30 2c       	mov	r12,2
80005344:	f0 1f 00 12 	mcall	8000538c <rc522_init+0xa4>
	
	PcdAntennaOn();
80005348:	f0 1f 00 12 	mcall	80005390 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
8000534c:	34 1c       	mov	r12,65
8000534e:	f0 1f 00 12 	mcall	80005394 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80005352:	30 1c       	mov	r12,1
80005354:	f0 1f 00 11 	mcall	80005398 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80005358:	2f cd       	sub	sp,-16
8000535a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000535e:	00 00       	add	r0,r0
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	e7 44 80 00 	st.w	r3[-32768],r4
80005366:	e7 54 80 00 	st.h	r3[-32768],r4
8000536a:	61 4c       	ld.w	r12,r0[0x50]
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	61 7c       	ld.w	r12,r0[0x5c]
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	61 94       	ld.w	r4,r0[0x64]
80005374:	00 00       	add	r0,r0
80005376:	1e 20       	rsub	r0,pc
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	66 64       	ld.w	r4,r3[0x18]
8000537c:	00 00       	add	r0,r0
8000537e:	0b 78       	ld.ub	r8,--r5
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	50 2c       	stdsp	sp[0x8],r12
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	50 d8       	stdsp	sp[0x34],r8
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	52 68       	stdsp	sp[0x98],r8
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	5a 54       	cp.w	r4,-27
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	52 20       	stdsp	sp[0x88],r0
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	52 78       	stdsp	sp[0x9c],r8
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	51 b0       	stdsp	sp[0x6c],r0

8000539c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
8000539c:	d4 31       	pushm	r0-r7,lr
8000539e:	20 1d       	sub	sp,4
800053a0:	18 92       	mov	r2,r12
800053a2:	16 95       	mov	r5,r11
800053a4:	14 96       	mov	r6,r10
800053a6:	50 09       	stdsp	sp[0x0],r9
800053a8:	10 90       	mov	r0,r8
800053aa:	f8 c8 00 0c 	sub	r8,r12,12
800053ae:	5c 58       	castu.b	r8
800053b0:	30 29       	mov	r9,2
800053b2:	f2 08 18 00 	cp.b	r8,r9
800053b6:	e0 88 00 05 	brls	800053c0 <PcdComMF522+0x24>
800053ba:	30 03       	mov	r3,0
800053bc:	06 91       	mov	r1,r3
800053be:	c0 78       	rjmp	800053cc <PcdComMF522+0x30>
800053c0:	4c f9       	lddpc	r9,800054fc <PcdComMF522+0x160>
800053c2:	f2 08 07 01 	ld.ub	r1,r9[r8]
800053c6:	4c f9       	lddpc	r9,80005500 <PcdComMF522+0x164>
800053c8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
800053cc:	02 9b       	mov	r11,r1
800053ce:	a7 bb       	sbr	r11,0x7
800053d0:	30 2c       	mov	r12,2
800053d2:	f0 1f 00 4d 	mcall	80005504 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
800053d6:	e0 6b 00 80 	mov	r11,128
800053da:	30 4c       	mov	r12,4
800053dc:	f0 1f 00 4b 	mcall	80005508 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
800053e0:	30 0b       	mov	r11,0
800053e2:	30 1c       	mov	r12,1
800053e4:	f0 1f 00 48 	mcall	80005504 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
800053e8:	e0 6b 00 80 	mov	r11,128
800053ec:	30 ac       	mov	r12,10
800053ee:	f0 1f 00 48 	mcall	8000550c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
800053f2:	58 06       	cp.w	r6,0
800053f4:	c0 c0       	breq	8000540c <PcdComMF522+0x70>
800053f6:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
800053f8:	30 94       	mov	r4,9
800053fa:	0f 3b       	ld.ub	r11,r7++
800053fc:	08 9c       	mov	r12,r4
800053fe:	f0 1f 00 42 	mcall	80005504 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80005402:	0e 98       	mov	r8,r7
80005404:	0a 18       	sub	r8,r5
80005406:	ec 08 19 00 	cp.h	r8,r6
8000540a:	cf 83       	brcs	800053fa <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
8000540c:	04 9b       	mov	r11,r2
8000540e:	30 1c       	mov	r12,1
80005410:	f0 1f 00 3d 	mcall	80005504 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005414:	30 c8       	mov	r8,12
80005416:	f0 02 18 00 	cp.b	r2,r8
8000541a:	c0 61       	brne	80005426 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
8000541c:	e0 6b 00 80 	mov	r11,128
80005420:	30 dc       	mov	r12,13
80005422:	f0 1f 00 3b 	mcall	8000550c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005426:	30 4c       	mov	r12,4
80005428:	f0 1f 00 3a 	mcall	80005510 <PcdComMF522+0x174>
8000542c:	18 97       	mov	r7,r12
8000542e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005432:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005434:	30 44       	mov	r4,4
80005436:	c0 88       	rjmp	80005446 <PcdComMF522+0xaa>
80005438:	08 9c       	mov	r12,r4
8000543a:	f0 1f 00 36 	mcall	80005510 <PcdComMF522+0x174>
8000543e:	18 97       	mov	r7,r12
		i--;
80005440:	20 16       	sub	r6,1
80005442:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005444:	c0 a0       	breq	80005458 <PcdComMF522+0xbc>
80005446:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
8000544a:	c4 c1       	brne	800054e2 <PcdComMF522+0x146>
8000544c:	ef e3 00 08 	and	r8,r7,r3
80005450:	ea 08 18 00 	cp.b	r8,r5
80005454:	cf 20       	breq	80005438 <PcdComMF522+0x9c>
80005456:	c4 68       	rjmp	800054e2 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80005458:	e0 6b 00 80 	mov	r11,128
8000545c:	30 dc       	mov	r12,13
8000545e:	f0 1f 00 2b 	mcall	80005508 <PcdComMF522+0x16c>
80005462:	30 27       	mov	r7,2
80005464:	c3 38       	rjmp	800054ca <PcdComMF522+0x12e>
80005466:	02 67       	and	r7,r1
80005468:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
8000546c:	30 c8       	mov	r8,12
8000546e:	f0 02 18 00 	cp.b	r2,r8
80005472:	c2 c1       	brne	800054ca <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80005474:	30 ac       	mov	r12,10
80005476:	f0 1f 00 27 	mcall	80005510 <PcdComMF522+0x174>
8000547a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
8000547c:	30 cc       	mov	r12,12
8000547e:	f0 1f 00 25 	mcall	80005510 <PcdComMF522+0x174>
80005482:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005486:	c0 70       	breq	80005494 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005488:	08 98       	mov	r8,r4
8000548a:	20 18       	sub	r8,1
8000548c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005490:	a0 8c       	st.b	r0[0x0],r12
80005492:	c0 48       	rjmp	8000549a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005494:	e8 08 15 03 	lsl	r8,r4,0x3
80005498:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000549a:	58 04       	cp.w	r4,0
8000549c:	c0 61       	brne	800054a8 <PcdComMF522+0x10c>
8000549e:	30 14       	mov	r4,1
800054a0:	40 05       	lddsp	r5,sp[0x0]
800054a2:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800054a4:	30 93       	mov	r3,9
800054a6:	c0 98       	rjmp	800054b8 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800054a8:	31 28       	mov	r8,18
800054aa:	f0 04 18 00 	cp.b	r4,r8
800054ae:	f9 b4 0b 12 	movhi	r4,18
800054b2:	58 04       	cp.w	r4,0
800054b4:	cf 61       	brne	800054a0 <PcdComMF522+0x104>
800054b6:	c0 a8       	rjmp	800054ca <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800054b8:	06 9c       	mov	r12,r3
800054ba:	f0 1f 00 16 	mcall	80005510 <PcdComMF522+0x174>
800054be:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800054c0:	ec 05 01 08 	sub	r8,r6,r5
800054c4:	e8 08 19 00 	cp.h	r8,r4
800054c8:	cf 83       	brcs	800054b8 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
800054ca:	e0 6b 00 80 	mov	r11,128
800054ce:	30 cc       	mov	r12,12
800054d0:	f0 1f 00 0f 	mcall	8000550c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
800054d4:	30 0b       	mov	r11,0
800054d6:	30 1c       	mov	r12,1
800054d8:	f0 1f 00 0b 	mcall	80005504 <PcdComMF522+0x168>
	return status;
}
800054dc:	0e 9c       	mov	r12,r7
800054de:	2f fd       	sub	sp,-4
800054e0:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
800054e2:	e0 6b 00 80 	mov	r11,128
800054e6:	30 dc       	mov	r12,13
800054e8:	f0 1f 00 08 	mcall	80005508 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
800054ec:	30 6c       	mov	r12,6
800054ee:	f0 1f 00 09 	mcall	80005510 <PcdComMF522+0x174>
800054f2:	e2 1c 00 1b 	andl	r12,0x1b,COH
800054f6:	cb 80       	breq	80005466 <PcdComMF522+0xca>
800054f8:	30 27       	mov	r7,2
800054fa:	ce 8b       	rjmp	800054ca <PcdComMF522+0x12e>
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	e7 3c 80 00 	ld.ub	r12,r3[-32768]
80005502:	e7 40 80 00 	st.w	r3[-32768],r0
80005506:	50 98       	stdsp	sp[0x24],r8
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	52 40       	stdsp	sp[0x90],r0
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	51 fc       	stdsp	sp[0x7c],r12
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	51 58       	stdsp	sp[0x54],r8

80005514 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005514:	eb cd 40 c0 	pushm	r6-r7,lr
80005518:	20 5d       	sub	sp,20
8000551a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
8000551c:	30 8b       	mov	r11,8
8000551e:	16 9c       	mov	r12,r11
80005520:	f0 1f 00 1a 	mcall	80005588 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80005524:	30 0b       	mov	r11,0
80005526:	30 dc       	mov	r12,13
80005528:	f0 1f 00 19 	mcall	8000558c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
8000552c:	e0 6b 00 80 	mov	r11,128
80005530:	30 ec       	mov	r12,14
80005532:	f0 1f 00 16 	mcall	80005588 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005536:	39 38       	mov	r8,-109
80005538:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
8000553a:	32 08       	mov	r8,32
8000553c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
8000553e:	1a 9b       	mov	r11,sp
80005540:	fa c8 ff ed 	sub	r8,sp,-19
80005544:	1a 99       	mov	r9,sp
80005546:	30 2a       	mov	r10,2
80005548:	30 cc       	mov	r12,12
8000554a:	f0 1f 00 12 	mcall	80005590 <PcdAnticoll+0x7c>
8000554e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80005550:	c1 21       	brne	80005574 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005552:	1b 89       	ld.ub	r9,sp[0x0]
80005554:	ac 89       	st.b	r6[0x0],r9
80005556:	1b 98       	ld.ub	r8,sp[0x1]
80005558:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
8000555a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000555c:	1b a8       	ld.ub	r8,sp[0x2]
8000555e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80005560:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005564:	1b b9       	ld.ub	r9,sp[0x3]
80005566:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80005568:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
8000556a:	1b c9       	ld.ub	r9,sp[0x4]
8000556c:	f0 09 18 00 	cp.b	r9,r8
80005570:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80005574:	e0 6b 00 80 	mov	r11,128
80005578:	30 ec       	mov	r12,14
8000557a:	f0 1f 00 07 	mcall	80005594 <PcdAnticoll+0x80>
	return status;
}
8000557e:	0e 9c       	mov	r12,r7
80005580:	2f bd       	sub	sp,-20
80005582:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005586:	00 00       	add	r0,r0
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	52 40       	stdsp	sp[0x90],r0
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	50 98       	stdsp	sp[0x24],r8
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	53 9c       	stdsp	sp[0xe4],r12
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	51 fc       	stdsp	sp[0x7c],r12

80005598 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005598:	eb cd 40 c0 	pushm	r6-r7,lr
8000559c:	20 5d       	sub	sp,20
8000559e:	18 97       	mov	r7,r12
800055a0:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
800055a2:	30 8b       	mov	r11,8
800055a4:	16 9c       	mov	r12,r11
800055a6:	f0 1f 00 12 	mcall	800055ec <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
800055aa:	30 7b       	mov	r11,7
800055ac:	30 dc       	mov	r12,13
800055ae:	f0 1f 00 11 	mcall	800055f0 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
800055b2:	30 3b       	mov	r11,3
800055b4:	31 4c       	mov	r12,20
800055b6:	f0 1f 00 10 	mcall	800055f4 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
800055ba:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
800055bc:	1a 9b       	mov	r11,sp
800055be:	fa c8 ff ed 	sub	r8,sp,-19
800055c2:	1a 99       	mov	r9,sp
800055c4:	30 1a       	mov	r10,1
800055c6:	30 cc       	mov	r12,12
800055c8:	f0 1f 00 0c 	mcall	800055f8 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
800055cc:	c0 c1       	brne	800055e4 <PcdRequest+0x4c>
800055ce:	31 08       	mov	r8,16
800055d0:	fb 39 00 13 	ld.ub	r9,sp[19]
800055d4:	f0 09 18 00 	cp.b	r9,r8
800055d8:	c0 61       	brne	800055e4 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
800055da:	1b 88       	ld.ub	r8,sp[0x0]
800055dc:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
800055de:	1b 98       	ld.ub	r8,sp[0x1]
800055e0:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
800055e2:	c0 28       	rjmp	800055e6 <PcdRequest+0x4e>
800055e4:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
800055e6:	2f bd       	sub	sp,-20
800055e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	52 40       	stdsp	sp[0x90],r0
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	50 98       	stdsp	sp[0x24],r8
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	51 fc       	stdsp	sp[0x7c],r12
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	53 9c       	stdsp	sp[0xe4],r12

800055fc <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
800055fc:	eb cd 40 f8 	pushm	r3-r7,lr
80005600:	18 95       	mov	r5,r12
80005602:	16 96       	mov	r6,r11
80005604:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005606:	30 4b       	mov	r11,4
80005608:	30 5c       	mov	r12,5
8000560a:	f0 1f 00 1c 	mcall	80005678 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000560e:	30 0b       	mov	r11,0
80005610:	30 1c       	mov	r12,1
80005612:	f0 1f 00 1b 	mcall	8000567c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005616:	e0 6b 00 80 	mov	r11,128
8000561a:	30 ac       	mov	r12,10
8000561c:	f0 1f 00 19 	mcall	80005680 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005620:	58 06       	cp.w	r6,0
80005622:	c0 c0       	breq	8000563a <CalulateCRC+0x3e>
80005624:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80005626:	30 94       	mov	r4,9
80005628:	0f 3b       	ld.ub	r11,r7++
8000562a:	08 9c       	mov	r12,r4
8000562c:	f0 1f 00 14 	mcall	8000567c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80005630:	0e 98       	mov	r8,r7
80005632:	0a 18       	sub	r8,r5
80005634:	ec 08 18 00 	cp.b	r8,r6
80005638:	cf 83       	brcs	80005628 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
8000563a:	30 3b       	mov	r11,3
8000563c:	30 1c       	mov	r12,1
8000563e:	f0 1f 00 10 	mcall	8000567c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80005642:	30 5c       	mov	r12,5
80005644:	f0 1f 00 10 	mcall	80005684 <CalulateCRC+0x88>
80005648:	e0 67 00 fe 	mov	r7,254
8000564c:	30 56       	mov	r6,5
8000564e:	c0 78       	rjmp	8000565c <CalulateCRC+0x60>
80005650:	0c 9c       	mov	r12,r6
80005652:	f0 1f 00 0d 	mcall	80005684 <CalulateCRC+0x88>
		i--;
80005656:	20 17       	sub	r7,1
80005658:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
8000565a:	c0 40       	breq	80005662 <CalulateCRC+0x66>
8000565c:	e2 1c 00 04 	andl	r12,0x4,COH
80005660:	cf 80       	breq	80005650 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80005662:	32 2c       	mov	r12,34
80005664:	f0 1f 00 08 	mcall	80005684 <CalulateCRC+0x88>
80005668:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
8000566a:	32 1c       	mov	r12,33
8000566c:	f0 1f 00 06 	mcall	80005684 <CalulateCRC+0x88>
80005670:	a6 9c       	st.b	r3[0x1],r12
}
80005672:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005676:	00 00       	add	r0,r0
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	52 40       	stdsp	sp[0x90],r0
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	50 98       	stdsp	sp[0x24],r8
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	51 fc       	stdsp	sp[0x7c],r12
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	51 58       	stdsp	sp[0x54],r8

80005688 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005688:	eb cd 40 80 	pushm	r7,lr
8000568c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000568e:	39 38       	mov	r8,-109
80005690:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80005692:	37 08       	mov	r8,112
80005694:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005696:	30 08       	mov	r8,0
80005698:	ba e8       	st.b	sp[0x6],r8
8000569a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000569e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
800056a2:	19 89       	ld.ub	r9,r12[0x0]
800056a4:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
800056a6:	19 3a       	ld.ub	r10,r12++
800056a8:	1b e9       	ld.ub	r9,sp[0x6]
800056aa:	f5 e9 20 09 	eor	r9,r10,r9
800056ae:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
800056b0:	16 38       	cp.w	r8,r11
800056b2:	cf 81       	brne	800056a2 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
800056b4:	1a 97       	mov	r7,sp
800056b6:	fa ca ff f9 	sub	r10,sp,-7
800056ba:	30 7b       	mov	r11,7
800056bc:	1a 9c       	mov	r12,sp
800056be:	f0 1f 00 0d 	mcall	800056f0 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
800056c2:	30 8b       	mov	r11,8
800056c4:	16 9c       	mov	r12,r11
800056c6:	f0 1f 00 0c 	mcall	800056f4 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
800056ca:	fa c8 ff ed 	sub	r8,sp,-19
800056ce:	1a 99       	mov	r9,sp
800056d0:	30 9a       	mov	r10,9
800056d2:	1a 9b       	mov	r11,sp
800056d4:	30 cc       	mov	r12,12
800056d6:	f0 1f 00 09 	mcall	800056f8 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
800056da:	c0 71       	brne	800056e8 <PcdSelect+0x60>
800056dc:	31 88       	mov	r8,24
800056de:	fb 39 00 13 	ld.ub	r9,sp[19]
800056e2:	f0 09 18 00 	cp.b	r9,r8
800056e6:	c0 20       	breq	800056ea <PcdSelect+0x62>
800056e8:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
800056ea:	2f bd       	sub	sp,-20
800056ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	55 fc       	stdsp	sp[0x17c],r12
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	52 40       	stdsp	sp[0x90],r0
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	53 9c       	stdsp	sp[0xe4],r12

800056fc <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
800056fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005700:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005702:	f0 1f 00 37 	mcall	800057dc <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005706:	4b 7b       	lddpc	r11,800057e0 <rfid_auto_reader+0xe4>
80005708:	35 2c       	mov	r12,82
8000570a:	f0 1f 00 37 	mcall	800057e4 <rfid_auto_reader+0xe8>
8000570e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005710:	c6 31       	brne	800057d6 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005712:	4b 48       	lddpc	r8,800057e0 <rfid_auto_reader+0xe4>
80005714:	11 88       	ld.ub	r8,r8[0x0]
80005716:	30 49       	mov	r9,4
80005718:	f2 08 18 00 	cp.b	r8,r9
8000571c:	c0 b1       	brne	80005732 <rfid_auto_reader+0x36>
8000571e:	4b 19       	lddpc	r9,800057e0 <rfid_auto_reader+0xe4>
80005720:	13 9a       	ld.ub	r10,r9[0x1]
80005722:	30 09       	mov	r9,0
80005724:	f2 0a 18 00 	cp.b	r10,r9
80005728:	c0 51       	brne	80005732 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000572a:	4b 0c       	lddpc	r12,800057e8 <rfid_auto_reader+0xec>
8000572c:	f0 1f 00 30 	mcall	800057ec <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005730:	c3 c8       	rjmp	800057a8 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005732:	30 29       	mov	r9,2
80005734:	f2 08 18 00 	cp.b	r8,r9
80005738:	c0 b1       	brne	8000574e <rfid_auto_reader+0x52>
8000573a:	4a a9       	lddpc	r9,800057e0 <rfid_auto_reader+0xe4>
8000573c:	13 9a       	ld.ub	r10,r9[0x1]
8000573e:	30 09       	mov	r9,0
80005740:	f2 0a 18 00 	cp.b	r10,r9
80005744:	c0 51       	brne	8000574e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80005746:	4a bc       	lddpc	r12,800057f0 <rfid_auto_reader+0xf4>
80005748:	f0 1f 00 29 	mcall	800057ec <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000574c:	c2 e8       	rjmp	800057a8 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000574e:	34 49       	mov	r9,68
80005750:	f2 08 18 00 	cp.b	r8,r9
80005754:	c0 b1       	brne	8000576a <rfid_auto_reader+0x6e>
80005756:	4a 39       	lddpc	r9,800057e0 <rfid_auto_reader+0xe4>
80005758:	13 9a       	ld.ub	r10,r9[0x1]
8000575a:	30 09       	mov	r9,0
8000575c:	f2 0a 18 00 	cp.b	r10,r9
80005760:	c0 51       	brne	8000576a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005762:	4a 5c       	lddpc	r12,800057f4 <rfid_auto_reader+0xf8>
80005764:	f0 1f 00 22 	mcall	800057ec <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005768:	c2 08       	rjmp	800057a8 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000576a:	30 89       	mov	r9,8
8000576c:	f2 08 18 00 	cp.b	r8,r9
80005770:	c0 b1       	brne	80005786 <rfid_auto_reader+0x8a>
80005772:	49 c9       	lddpc	r9,800057e0 <rfid_auto_reader+0xe4>
80005774:	13 9a       	ld.ub	r10,r9[0x1]
80005776:	30 09       	mov	r9,0
80005778:	f2 0a 18 00 	cp.b	r10,r9
8000577c:	c0 51       	brne	80005786 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
8000577e:	49 fc       	lddpc	r12,800057f8 <rfid_auto_reader+0xfc>
80005780:	f0 1f 00 1b 	mcall	800057ec <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005784:	c1 28       	rjmp	800057a8 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005786:	34 49       	mov	r9,68
80005788:	f2 08 18 00 	cp.b	r8,r9
8000578c:	c0 b1       	brne	800057a2 <rfid_auto_reader+0xa6>
8000578e:	49 58       	lddpc	r8,800057e0 <rfid_auto_reader+0xe4>
80005790:	11 99       	ld.ub	r9,r8[0x1]
80005792:	30 38       	mov	r8,3
80005794:	f0 09 18 00 	cp.b	r9,r8
80005798:	c0 51       	brne	800057a2 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000579a:	49 9c       	lddpc	r12,800057fc <rfid_auto_reader+0x100>
8000579c:	f0 1f 00 14 	mcall	800057ec <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800057a0:	c0 48       	rjmp	800057a8 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
800057a2:	49 8c       	lddpc	r12,80005800 <rfid_auto_reader+0x104>
800057a4:	f0 1f 00 12 	mcall	800057ec <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800057a8:	49 7c       	lddpc	r12,80005804 <rfid_auto_reader+0x108>
800057aa:	f0 1f 00 18 	mcall	80005808 <rfid_auto_reader+0x10c>
800057ae:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800057b0:	c0 60       	breq	800057bc <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
800057b2:	37 8b       	mov	r11,120
800057b4:	30 1c       	mov	r12,1
800057b6:	f0 1f 00 16 	mcall	8000580c <rfid_auto_reader+0x110>
		return status;
800057ba:	c0 e8       	rjmp	800057d6 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800057bc:	49 2c       	lddpc	r12,80005804 <rfid_auto_reader+0x108>
800057be:	f0 1f 00 15 	mcall	80005810 <rfid_auto_reader+0x114>
800057c2:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800057c4:	c0 91       	brne	800057d6 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800057c6:	30 4a       	mov	r10,4
800057c8:	48 fb       	lddpc	r11,80005804 <rfid_auto_reader+0x108>
800057ca:	0c 9c       	mov	r12,r6
800057cc:	f0 1f 00 12 	mcall	80005814 <rfid_auto_reader+0x118>
		log("select okay\n");
800057d0:	49 2c       	lddpc	r12,80005818 <rfid_auto_reader+0x11c>
800057d2:	f0 1f 00 07 	mcall	800057ec <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800057d6:	0e 9c       	mov	r12,r7
800057d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	50 d8       	stdsp	sp[0x34],r8
800057e0:	00 00       	add	r0,r0
800057e2:	51 a8       	stdsp	sp[0x68],r8
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	55 98       	stdsp	sp[0x164],r8
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	e7 5c 80 00 	st.h	r3[-32768],r12
800057ee:	7d 80       	ld.w	r0,lr[0x60]
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	e7 68 80 00 	st.b	r3[-32768],r8
800057f6:	e7 74 80 00 	stcond	r3[-32768],r4
800057fa:	e7 84       	*unknown*
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	e7 8c       	*unknown*
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	e7 98       	*unknown*
80005804:	00 00       	add	r0,r0
80005806:	51 ac       	stdsp	sp[0x68],r12
80005808:	80 00       	ld.sh	r0,r0[0x0]
8000580a:	55 14       	stdsp	sp[0x144],r4
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	48 2c       	lddpc	r12,80005814 <rfid_auto_reader+0x118>
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	56 88       	stdsp	sp[0x1a0],r8
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	86 2a       	ld.sh	r10,r3[0x4]
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	e7 a4 eb cd 	cop	cp7,cr11,cr12,cr13,0x68

8000581c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
8000581c:	eb cd 40 80 	pushm	r7,lr
80005820:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005822:	f0 1f 00 0d 	mcall	80005854 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80005826:	30 0c       	mov	r12,0
80005828:	f0 1f 00 0c 	mcall	80005858 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
8000582c:	0e 9c       	mov	r12,r7
8000582e:	f0 1f 00 0c 	mcall	8000585c <scan_patrol+0x40>
80005832:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005834:	30 1c       	mov	r12,1
80005836:	f0 1f 00 09 	mcall	80005858 <scan_patrol+0x3c>
	if(return_err == 0)
8000583a:	58 07       	cp.w	r7,0
8000583c:	c0 51       	brne	80005846 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
8000583e:	48 9c       	lddpc	r12,80005860 <scan_patrol+0x44>
80005840:	f0 1f 00 09 	mcall	80005864 <scan_patrol+0x48>
80005844:	c0 48       	rjmp	8000584c <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80005846:	48 9c       	lddpc	r12,80005868 <scan_patrol+0x4c>
80005848:	f0 1f 00 07 	mcall	80005864 <scan_patrol+0x48>
		
	return return_err;

}
8000584c:	0e 9c       	mov	r12,r7
8000584e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005852:	00 00       	add	r0,r0
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	50 d8       	stdsp	sp[0x34],r8
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	51 b0       	stdsp	sp[0x6c],r0
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	56 fc       	stdsp	sp[0x1bc],r12
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	e7 b4       	*unknown*
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	7d 80       	ld.w	r0,lr[0x60]
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	e7 c8 eb cd 	ldmts	r8++,r0,r2-r3,r6-r9,r11,sp-pc

8000586c <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
8000586c:	eb cd 40 e0 	pushm	r5-r7,lr
80005870:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005872:	4d 7c       	lddpc	r12,800059cc <scan_rfid_save_message+0x160>
80005874:	30 08       	mov	r8,0
80005876:	30 09       	mov	r9,0
80005878:	f8 e9 00 00 	st.d	r12[0],r8
8000587c:	30 0a       	mov	r10,0
8000587e:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005880:	fa e9 00 24 	st.d	sp[36],r8
80005884:	fa e9 00 2c 	st.d	sp[44],r8
80005888:	fa e9 00 34 	st.d	sp[52],r8
8000588c:	fa e9 00 3c 	st.d	sp[60],r8
80005890:	fa e9 00 44 	st.d	sp[68],r8
80005894:	fa e9 00 4c 	st.d	sp[76],r8
80005898:	fa e9 00 54 	st.d	sp[84],r8
8000589c:	fa e9 00 5c 	st.d	sp[92],r8
800058a0:	fa e9 00 64 	st.d	sp[100],r8
800058a4:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
800058a8:	f0 1f 00 4a 	mcall	800059d0 <scan_rfid_save_message+0x164>
800058ac:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800058ae:	e0 81 00 84 	brne	800059b6 <scan_rfid_save_message+0x14a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800058b2:	4c 76       	lddpc	r6,800059cc <scan_rfid_save_message+0x160>
800058b4:	0d b8       	ld.ub	r8,r6[0x3]
800058b6:	1a d8       	st.w	--sp,r8
800058b8:	0d a8       	ld.ub	r8,r6[0x2]
800058ba:	1a d8       	st.w	--sp,r8
800058bc:	0d 98       	ld.ub	r8,r6[0x1]
800058be:	1a d8       	st.w	--sp,r8
800058c0:	0d 88       	ld.ub	r8,r6[0x0]
800058c2:	1a d8       	st.w	--sp,r8
800058c4:	4c 4c       	lddpc	r12,800059d4 <scan_rfid_save_message+0x168>
800058c6:	f0 1f 00 45 	mcall	800059d8 <scan_rfid_save_message+0x16c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
800058ca:	37 7b       	mov	r11,119
800058cc:	30 1c       	mov	r12,1
800058ce:	f0 1f 00 44 	mcall	800059dc <scan_rfid_save_message+0x170>
800058d2:	fa c8 ff ec 	sub	r8,sp,-20
800058d6:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
800058da:	ec c5 ff fc 	sub	r5,r6,-4
800058de:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800058e0:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800058e2:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800058e4:	0d 8a       	ld.ub	r10,r6[0x0]
800058e6:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800058ea:	fc 0b 18 00 	cp.b	r11,lr
800058ee:	f7 bb 08 d0 	subls	r11,-48
800058f2:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800058f6:	f7 bb 0b a9 	subhi	r11,-87
800058fa:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800058fe:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005900:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005904:	fc 0a 18 00 	cp.b	r10,lr
80005908:	f7 ba 08 d0 	subls	r10,-48
8000590c:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005910:	f7 ba 0b a9 	subhi	r10,-87
80005914:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005918:	b0 bc       	st.b	r8[0x3],r12
8000591a:	2f f6       	sub	r6,-1
8000591c:	2f c8       	sub	r8,-4
8000591e:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005920:	0a 36       	cp.w	r6,r5
80005922:	ce 11       	brne	800058e4 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005924:	30 6a       	mov	r10,6
80005926:	4a fb       	lddpc	r11,800059e0 <scan_rfid_save_message+0x174>
80005928:	fa cc ff ec 	sub	r12,sp,-20
8000592c:	f0 1f 00 2e 	mcall	800059e4 <scan_rfid_save_message+0x178>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005930:	4a e8       	lddpc	r8,800059e8 <scan_rfid_save_message+0x17c>
80005932:	11 89       	ld.ub	r9,r8[0x0]
80005934:	39 f8       	mov	r8,-97
80005936:	f0 09 18 00 	cp.b	r9,r8
8000593a:	e0 88 00 05 	brls	80005944 <scan_rfid_save_message+0xd8>
8000593e:	38 09       	mov	r9,-128
80005940:	4a a8       	lddpc	r8,800059e8 <scan_rfid_save_message+0x17c>
80005942:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005944:	4a 98       	lddpc	r8,800059e8 <scan_rfid_save_message+0x17c>
80005946:	11 86       	ld.ub	r6,r8[0x0]
80005948:	2f f6       	sub	r6,-1
8000594a:	5c 56       	castu.b	r6
8000594c:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000594e:	30 5a       	mov	r10,5
80005950:	4a 7b       	lddpc	r11,800059ec <scan_rfid_save_message+0x180>
80005952:	fa cc ff e1 	sub	r12,sp,-31
80005956:	f0 1f 00 24 	mcall	800059e4 <scan_rfid_save_message+0x178>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000595a:	31 e8       	mov	r8,30
8000595c:	fb 58 00 1a 	st.h	sp[26],r8
80005960:	fb 66 00 1e 	st.b	sp[30],r6
80005964:	fe 78 e0 00 	mov	r8,-8192
80005968:	fb 58 00 1c 	st.h	sp[28],r8
8000596c:	30 aa       	mov	r10,10
8000596e:	fa cb ff e6 	sub	r11,sp,-26
80005972:	fa cc ff dc 	sub	r12,sp,-36
80005976:	f0 1f 00 1c 	mcall	800059e4 <scan_rfid_save_message+0x178>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
8000597a:	31 6a       	mov	r10,22
8000597c:	fa cb ff fc 	sub	r11,sp,-4
80005980:	fa cc ff d2 	sub	r12,sp,-46
80005984:	f0 1f 00 18 	mcall	800059e4 <scan_rfid_save_message+0x178>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005988:	49 a8       	lddpc	r8,800059f0 <scan_rfid_save_message+0x184>
8000598a:	70 0c       	ld.w	r12,r8[0x0]
8000598c:	f0 1f 00 1a 	mcall	800059f4 <scan_rfid_save_message+0x188>
80005990:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005992:	c0 e0       	breq	800059ae <scan_rfid_save_message+0x142>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005994:	32 0a       	mov	r10,32
80005996:	fa cb ff dc 	sub	r11,sp,-36
8000599a:	f0 1f 00 13 	mcall	800059e4 <scan_rfid_save_message+0x178>
			xQueueSend(xg_resend_queue, &myptr, 0);
8000599e:	49 78       	lddpc	r8,800059f8 <scan_rfid_save_message+0x18c>
800059a0:	70 0c       	ld.w	r12,r8[0x0]
800059a2:	30 09       	mov	r9,0
800059a4:	12 9a       	mov	r10,r9
800059a6:	1a 9b       	mov	r11,sp
800059a8:	f0 1f 00 15 	mcall	800059fc <scan_rfid_save_message+0x190>
800059ac:	c0 c8       	rjmp	800059c4 <scan_rfid_save_message+0x158>
		}
		else
		{
			log("myptr: err\n\r" );
800059ae:	49 5c       	lddpc	r12,80005a00 <scan_rfid_save_message+0x194>
800059b0:	f0 1f 00 0a 	mcall	800059d8 <scan_rfid_save_message+0x16c>
800059b4:	c0 88       	rjmp	800059c4 <scan_rfid_save_message+0x158>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800059b6:	37 8b       	mov	r11,120
800059b8:	30 1c       	mov	r12,1
800059ba:	f0 1f 00 09 	mcall	800059dc <scan_rfid_save_message+0x170>
		log("no card find...\n");
800059be:	49 2c       	lddpc	r12,80005a04 <scan_rfid_save_message+0x198>
800059c0:	f0 1f 00 06 	mcall	800059d8 <scan_rfid_save_message+0x16c>
	}
	
	return return_err;
	

}
800059c4:	0e 9c       	mov	r12,r7
800059c6:	2e 3d       	sub	sp,-116
800059c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800059cc:	00 00       	add	r0,r0
800059ce:	0b 7c       	ld.ub	r12,--r5
800059d0:	80 00       	ld.sh	r0,r0[0x0]
800059d2:	58 1c       	cp.w	r12,1
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	e7 dc 80 00 	ldswp.w	r12,r3[0]
800059da:	7d 80       	ld.w	r0,lr[0x60]
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	48 2c       	lddpc	r12,800059e4 <scan_rfid_save_message+0x178>
800059e0:	00 00       	add	r0,r0
800059e2:	0e 18       	sub	r8,r7
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	86 2a       	ld.sh	r10,r3[0x4]
800059e8:	00 00       	add	r0,r0
800059ea:	05 38       	ld.ub	r8,r2++
800059ec:	00 00       	add	r0,r0
800059ee:	05 30       	ld.ub	r0,r2++
800059f0:	00 00       	add	r0,r0
800059f2:	0b 94       	ld.ub	r4,r5[0x1]
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	35 74       	mov	r4,87
800059f8:	00 00       	add	r0,r0
800059fa:	0b 88       	ld.ub	r8,r5[0x0]
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	71 30       	ld.w	r0,r8[0x4c]
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	e6 1c 80 00 	andh	r12,0x8000,COH
80005a06:	e7 f8 d4 01 	ld.shvc	r8,r3[0x2]

80005a08 <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80005a08:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005a0a:	f0 1f 00 02 	mcall	80005a10 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005a0e:	d8 02       	popm	pc
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	52 e8       	stdsp	sp[0xb8],r8

80005a14 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005a14:	58 0c       	cp.w	r12,0
80005a16:	5e 0c       	reteq	r12
80005a18:	30 08       	mov	r8,0
	{
		nop();
80005a1a:	d7 03       	nop
		nop();
80005a1c:	d7 03       	nop
		nop();
80005a1e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005a20:	2f f8       	sub	r8,-1
80005a22:	10 3c       	cp.w	r12,r8
80005a24:	fe 9b ff fb 	brhi	80005a1a <delay_ns+0x6>
80005a28:	5e fc       	retal	r12
80005a2a:	d7 03       	nop

80005a2c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005a2c:	eb cd 40 e0 	pushm	r5-r7,lr
80005a30:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005a32:	58 0c       	cp.w	r12,0
80005a34:	c0 b0       	breq	80005a4a <delay_us+0x1e>
80005a36:	30 07       	mov	r7,0
		delay_ns(1000);
80005a38:	e0 65 03 e8 	mov	r5,1000
80005a3c:	0a 9c       	mov	r12,r5
80005a3e:	f0 1f 00 05 	mcall	80005a50 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005a42:	2f f7       	sub	r7,-1
80005a44:	0e 36       	cp.w	r6,r7
80005a46:	fe 9b ff fb 	brhi	80005a3c <delay_us+0x10>
80005a4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005a4e:	00 00       	add	r0,r0
80005a50:	80 00       	ld.sh	r0,r0[0x0]
80005a52:	5a 14       	cp.w	r4,-31

80005a54 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005a54:	eb cd 40 e0 	pushm	r5-r7,lr
80005a58:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005a5a:	58 0c       	cp.w	r12,0
80005a5c:	c0 b0       	breq	80005a72 <delay_ms+0x1e>
80005a5e:	30 07       	mov	r7,0
		delay_us(1000);
80005a60:	e0 65 03 e8 	mov	r5,1000
80005a64:	0a 9c       	mov	r12,r5
80005a66:	f0 1f 00 05 	mcall	80005a78 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005a6a:	2f f7       	sub	r7,-1
80005a6c:	0e 36       	cp.w	r6,r7
80005a6e:	fe 9b ff fb 	brhi	80005a64 <delay_ms+0x10>
80005a72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005a76:	00 00       	add	r0,r0
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	5a 2c       	cp.w	r12,-30

80005a7c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005a7c:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005a7e:	30 3b       	mov	r11,3
80005a80:	48 8c       	lddpc	r12,80005aa0 <local_start_timer+0x24>
80005a82:	f0 1f 00 09 	mcall	80005aa4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005a86:	fe 78 38 00 	mov	r8,-51200
80005a8a:	e0 69 91 0d 	mov	r9,37133
80005a8e:	ea 19 00 52 	orh	r9,0x52
80005a92:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005a94:	32 09       	mov	r9,32
80005a96:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005a98:	30 59       	mov	r9,5
80005a9a:	91 09       	st.w	r8[0x0],r9
}
80005a9c:	d8 02       	popm	pc
80005a9e:	00 00       	add	r0,r0
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	e8 0c       	*unknown*
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	61 4c       	ld.w	r12,r0[0x50]

80005aa8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005aa8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005aaa:	30 3a       	mov	r10,3
80005aac:	e0 6b 1b 00 	mov	r11,6912
80005ab0:	ea 1b 00 b7 	orh	r11,0xb7
80005ab4:	fe 7c 0c 00 	mov	r12,-62464
80005ab8:	f0 1f 00 19 	mcall	80005b1c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005abc:	31 08       	mov	r8,16
80005abe:	1a d8       	st.w	--sp,r8
80005ac0:	30 08       	mov	r8,0
80005ac2:	30 19       	mov	r9,1
80005ac4:	30 7a       	mov	r10,7
80005ac6:	10 9b       	mov	r11,r8
80005ac8:	fe 7c 0c 00 	mov	r12,-62464
80005acc:	f0 1f 00 15 	mcall	80005b20 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005ad0:	30 08       	mov	r8,0
80005ad2:	30 19       	mov	r9,1
80005ad4:	12 9a       	mov	r10,r9
80005ad6:	10 9b       	mov	r11,r8
80005ad8:	fe 7c 0c 00 	mov	r12,-62464
80005adc:	f0 1f 00 12 	mcall	80005b24 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005ae0:	30 0b       	mov	r11,0
80005ae2:	fe 7c 0c 00 	mov	r12,-62464
80005ae6:	f0 1f 00 11 	mcall	80005b28 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005aea:	fe 7c 0c 00 	mov	r12,-62464
80005aee:	f0 1f 00 10 	mcall	80005b2c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005af2:	30 0a       	mov	r10,0
80005af4:	1a da       	st.w	--sp,r10
80005af6:	1a da       	st.w	--sp,r10
80005af8:	14 98       	mov	r8,r10
80005afa:	14 99       	mov	r9,r10
80005afc:	30 1b       	mov	r11,1
80005afe:	fe 7c 0c 00 	mov	r12,-62464
80005b02:	f0 1f 00 0c 	mcall	80005b30 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005b06:	30 1c       	mov	r12,1
80005b08:	f0 1f 00 0b 	mcall	80005b34 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005b0c:	30 2b       	mov	r11,2
80005b0e:	fe 7c 0c 00 	mov	r12,-62464
80005b12:	f0 1f 00 0a 	mcall	80005b38 <local_start_pll0+0x90>
80005b16:	2f dd       	sub	sp,-12
/****/
}
80005b18:	d8 02       	popm	pc
80005b1a:	00 00       	add	r0,r0
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	64 54       	ld.w	r4,r2[0x14]
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	63 f6       	ld.w	r6,r1[0x7c]
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	64 18       	ld.w	r8,r2[0x4]
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	64 32       	ld.w	r2,r2[0xc]
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	64 40       	ld.w	r0,r2[0x10]
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	63 b0       	ld.w	r0,r1[0x6c]
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	60 ec       	ld.w	r12,r0[0x38]
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	64 4a       	ld.w	r10,r2[0x10]

80005b3c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005b3c:	d4 31       	pushm	r0-r7,lr
80005b3e:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005b40:	f0 1f 00 82 	mcall	80005d48 <xg_flashc_init+0x20c>
80005b44:	fe f8 02 08 	ld.w	r8,pc[520]
80005b48:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005b4a:	70 08       	ld.w	r8,r8[0x0]
80005b4c:	58 08       	cp.w	r8,0
80005b4e:	c0 51       	brne	80005b58 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005b50:	fe fc 02 00 	ld.w	r12,pc[512]
80005b54:	f0 1f 00 80 	mcall	80005d54 <xg_flashc_init+0x218>
	//计数最大值为300
	//初始值为1(当flash信息数量为0时：用户扫点 -> flash-save -> flash-count+1 -> take Sem -> send -> wait for give-Sem(success/fail))
	//如果此时反馈成功，则继续查询count值是否等于0/等待用户扫点
	//如果此时反馈失败，则flash-save
	//当flash信息数量！=0时；等待查询count值
	SendM_CountingSemaphore = xSemaphoreCreateCounting(300, 1);
80005b58:	30 1b       	mov	r11,1
80005b5a:	e0 6c 01 2c 	mov	r12,300
80005b5e:	f0 1f 00 7f 	mcall	80005d58 <xg_flashc_init+0x21c>
80005b62:	4f f8       	lddpc	r8,80005d5c <xg_flashc_init+0x220>
80005b64:	91 0c       	st.w	r8[0x0],r12
	if (SendM_CountingSemaphore == NULL)
80005b66:	70 08       	ld.w	r8,r8[0x0]
80005b68:	58 08       	cp.w	r8,0
80005b6a:	c0 41       	brne	80005b72 <xg_flashc_init+0x36>
	{
		log("Create the SendM_Counting semaphore failure\n");
80005b6c:	4f dc       	lddpc	r12,80005d60 <xg_flashc_init+0x224>
80005b6e:	f0 1f 00 7a 	mcall	80005d54 <xg_flashc_init+0x218>
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80005b72:	30 4b       	mov	r11,4
80005b74:	31 4c       	mov	r12,20
80005b76:	f0 1f 00 7c 	mcall	80005d64 <xg_flashc_init+0x228>
80005b7a:	4f c8       	lddpc	r8,80005d68 <xg_flashc_init+0x22c>
80005b7c:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005b7e:	30 4b       	mov	r11,4
80005b80:	31 4c       	mov	r12,20
80005b82:	f0 1f 00 79 	mcall	80005d64 <xg_flashc_init+0x228>
80005b86:	4f a8       	lddpc	r8,80005d6c <xg_flashc_init+0x230>
80005b88:	91 0c       	st.w	r8[0x0],r12
80005b8a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005b8c:	10 96       	mov	r6,r8
80005b8e:	4f 95       	lddpc	r5,80005d70 <xg_flashc_init+0x234>
80005b90:	6c 0c       	ld.w	r12,r6[0x0]
80005b92:	ea 07 00 0b 	add	r11,r5,r7
80005b96:	f0 1f 00 78 	mcall	80005d74 <xg_flashc_init+0x238>
80005b9a:	2e 07       	sub	r7,-32
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005b9c:	e0 47 02 80 	cp.w	r7,640
80005ba0:	cf 81       	brne	80005b90 <xg_flashc_init+0x54>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005ba2:	f0 1f 00 76 	mcall	80005d78 <xg_flashc_init+0x23c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005ba6:	30 0a       	mov	r10,0
80005ba8:	30 0b       	mov	r11,0
80005baa:	4f 58       	lddpc	r8,80005d7c <xg_flashc_init+0x240>
80005bac:	b1 2a       	st.d	r8++,r10
80005bae:	b1 2a       	st.d	r8++,r10
80005bb0:	b1 2a       	st.d	r8++,r10
80005bb2:	b1 2a       	st.d	r8++,r10
80005bb4:	b1 2a       	st.d	r8++,r10
80005bb6:	b1 2a       	st.d	r8++,r10
80005bb8:	b1 2a       	st.d	r8++,r10
80005bba:	b1 2a       	st.d	r8++,r10
80005bbc:	b1 2a       	st.d	r8++,r10
80005bbe:	f0 eb 00 00 	st.d	r8[0],r10
80005bc2:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005bc4:	4e e7       	lddpc	r7,80005d7c <xg_flashc_init+0x240>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005bc6:	ee c4 ff f8 	sub	r4,r7,-8
80005bca:	e8 c3 ff f8 	sub	r3,r4,-8
80005bce:	e6 c2 ff f8 	sub	r2,r3,-8
80005bd2:	e4 c1 ff f8 	sub	r1,r2,-8
80005bd6:	e2 c0 ff f8 	sub	r0,r1,-8
80005bda:	e0 ca ff f8 	sub	r10,r0,-8
80005bde:	50 0a       	stdsp	sp[0x0],r10
80005be0:	2f 8a       	sub	r10,-8
80005be2:	50 1a       	stdsp	sp[0x4],r10
80005be4:	2f 8a       	sub	r10,-8
80005be6:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005be8:	0e 9a       	mov	r10,r7
80005bea:	30 6b       	mov	r11,6
80005bec:	30 0c       	mov	r12,0
80005bee:	f0 1f 00 65 	mcall	80005d80 <xg_flashc_init+0x244>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005bf2:	30 6a       	mov	r10,6
80005bf4:	0e 9b       	mov	r11,r7
80005bf6:	4e 4c       	lddpc	r12,80005d84 <xg_flashc_init+0x248>
80005bf8:	f0 1f 00 64 	mcall	80005d88 <xg_flashc_init+0x24c>
80005bfc:	c1 c0       	breq	80005c34 <xg_flashc_init+0xf8>
80005bfe:	c8 b8       	rjmp	80005d14 <xg_flashc_init+0x1d8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005c00:	30 6a       	mov	r10,6
80005c02:	30 0b       	mov	r11,0
80005c04:	4e 0c       	lddpc	r12,80005d84 <xg_flashc_init+0x248>
80005c06:	f0 1f 00 62 	mcall	80005d8c <xg_flashc_init+0x250>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005c0a:	4d d7       	lddpc	r7,80005d7c <xg_flashc_init+0x240>
80005c0c:	35 0a       	mov	r10,80
80005c0e:	30 0b       	mov	r11,0
80005c10:	0e 9c       	mov	r12,r7
80005c12:	f0 1f 00 60 	mcall	80005d90 <xg_flashc_init+0x254>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005c16:	30 2a       	mov	r10,2
80005c18:	30 6b       	mov	r11,6
80005c1a:	0e 9c       	mov	r12,r7
80005c1c:	f0 1f 00 5c 	mcall	80005d8c <xg_flashc_init+0x250>
			if(return_code != DF_WRITE_COMPLETED)
80005c20:	58 7c       	cp.w	r12,7
80005c22:	e0 81 00 90 	brne	80005d42 <xg_flashc_init+0x206>
			{
				return FALSE;
			}
			current_message_index = 0;
80005c26:	30 09       	mov	r9,0
80005c28:	4d b8       	lddpc	r8,80005d94 <xg_flashc_init+0x258>
80005c2a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005c2c:	4d bc       	lddpc	r12,80005d98 <xg_flashc_init+0x25c>
80005c2e:	f0 1f 00 4a 	mcall	80005d54 <xg_flashc_init+0x218>
80005c32:	c8 58       	rjmp	80005d3c <xg_flashc_init+0x200>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005c34:	1a d7       	st.w	--sp,r7
80005c36:	4d ac       	lddpc	r12,80005d9c <xg_flashc_init+0x260>
80005c38:	f0 1f 00 47 	mcall	80005d54 <xg_flashc_init+0x218>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005c3c:	4d 6a       	lddpc	r10,80005d94 <xg_flashc_init+0x258>
80005c3e:	30 2b       	mov	r11,2
80005c40:	30 6c       	mov	r12,6
80005c42:	f0 1f 00 50 	mcall	80005d80 <xg_flashc_init+0x244>
			if(return_code == DF_OK)
80005c46:	2f fd       	sub	sp,-4
80005c48:	58 0c       	cp.w	r12,0
80005c4a:	e0 81 00 7c 	brne	80005d42 <xg_flashc_init+0x206>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005c4e:	4d 28       	lddpc	r8,80005d94 <xg_flashc_init+0x258>
80005c50:	90 08       	ld.sh	r8,r8[0x0]
80005c52:	58 08       	cp.w	r8,0
80005c54:	c7 10       	breq	80005d36 <xg_flashc_init+0x1fa>
					
					log("current_message_index: %d\n", current_message_index);
80005c56:	5c 78       	castu.h	r8
80005c58:	1a d8       	st.w	--sp,r8
80005c5a:	4d 2c       	lddpc	r12,80005da0 <xg_flashc_init+0x264>
80005c5c:	f0 1f 00 3e 	mcall	80005d54 <xg_flashc_init+0x218>
					memset(str, 0x00, sizeof(str));	
80005c60:	30 08       	mov	r8,0
80005c62:	30 09       	mov	r9,0
80005c64:	ee e9 00 00 	st.d	r7[0],r8
80005c68:	e8 e9 00 00 	st.d	r4[0],r8
80005c6c:	e6 e9 00 00 	st.d	r3[0],r8
80005c70:	e4 e9 00 00 	st.d	r2[0],r8
80005c74:	e2 e9 00 00 	st.d	r1[0],r8
80005c78:	e0 e9 00 00 	st.d	r0[0],r8
80005c7c:	40 1a       	lddsp	r10,sp[0x4]
80005c7e:	f4 e9 00 00 	st.d	r10[0],r8
80005c82:	40 2a       	lddsp	r10,sp[0x8]
80005c84:	f4 e9 00 00 	st.d	r10[0],r8
80005c88:	40 3a       	lddsp	r10,sp[0xc]
80005c8a:	b5 28       	st.d	r10++,r8
80005c8c:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005c90:	4c 18       	lddpc	r8,80005d94 <xg_flashc_init+0x258>
80005c92:	90 85       	ld.uh	r5,r8[0x0]
80005c94:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005c96:	0e 9a       	mov	r10,r7
80005c98:	30 8b       	mov	r11,8
80005c9a:	0a 9c       	mov	r12,r5
80005c9c:	f0 1f 00 39 	mcall	80005d80 <xg_flashc_init+0x244>
					if(return_code == DF_OK)
80005ca0:	2f fd       	sub	sp,-4
80005ca2:	58 0c       	cp.w	r12,0
80005ca4:	c4 91       	brne	80005d36 <xg_flashc_init+0x1fa>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005ca6:	0f 89       	ld.ub	r9,r7[0x0]
80005ca8:	0f 98       	ld.ub	r8,r7[0x1]
80005caa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005cae:	4b a9       	lddpc	r9,80005d94 <xg_flashc_init+0x258>
80005cb0:	92 09       	ld.sh	r9,r9[0x0]
80005cb2:	f0 09 19 00 	cp.h	r9,r8
80005cb6:	c2 c1       	brne	80005d0e <xg_flashc_init+0x1d2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005cb8:	0f e9       	ld.ub	r9,r7[0x6]
80005cba:	0f f8       	ld.ub	r8,r7[0x7]
80005cbc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005cc0:	0f aa       	ld.ub	r10,r7[0x2]
80005cc2:	0f b8       	ld.ub	r8,r7[0x3]
80005cc4:	b1 68       	lsl	r8,0x10
80005cc6:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005cca:	0f ca       	ld.ub	r10,r7[0x4]
80005ccc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005cd0:	0f da       	ld.ub	r10,r7[0x5]
80005cd2:	f5 e8 10 08 	or	r8,r10,r8
80005cd6:	f2 08 00 08 	add	r8,r9,r8
80005cda:	4b 36       	lddpc	r6,80005da4 <xg_flashc_init+0x268>
80005cdc:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005cde:	1a d8       	st.w	--sp,r8
80005ce0:	4b 2c       	lddpc	r12,80005da8 <xg_flashc_init+0x26c>
80005ce2:	f0 1f 00 1d 	mcall	80005d54 <xg_flashc_init+0x218>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005ce6:	2f fd       	sub	sp,-4
80005ce8:	6c 08       	ld.w	r8,r6[0x0]
80005cea:	e0 69 ff ff 	mov	r9,65535
80005cee:	ea 19 00 7f 	orh	r9,0x7f
80005cf2:	12 38       	cp.w	r8,r9
80005cf4:	e0 88 00 21 	brls	80005d36 <xg_flashc_init+0x1fa>
										
								log("\r\n----message storage is full!!!----\r\n");
80005cf8:	4a dc       	lddpc	r12,80005dac <xg_flashc_init+0x270>
80005cfa:	f0 1f 00 17 	mcall	80005d54 <xg_flashc_init+0x218>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005cfe:	30 4b       	mov	r11,4
80005d00:	30 0c       	mov	r12,0
80005d02:	f0 1f 00 2c 	mcall	80005db0 <xg_flashc_init+0x274>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005d06:	58 5c       	cp.w	r12,5
80005d08:	fe 90 ff 70 	breq	80005be8 <xg_flashc_init+0xac>
80005d0c:	c1 b8       	rjmp	80005d42 <xg_flashc_init+0x206>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005d0e:	4a ac       	lddpc	r12,80005db4 <xg_flashc_init+0x278>
80005d10:	f0 1f 00 11 	mcall	80005d54 <xg_flashc_init+0x218>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005d14:	30 3b       	mov	r11,3
80005d16:	0a 9c       	mov	r12,r5
80005d18:	f0 1f 00 26 	mcall	80005db0 <xg_flashc_init+0x274>
				if(return_code != DF_ERASE_COMPLETED)
80005d1c:	58 5c       	cp.w	r12,5
80005d1e:	c1 21       	brne	80005d42 <xg_flashc_init+0x206>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005d20:	30 3b       	mov	r11,3
80005d22:	e0 78 00 00 	mov	r8,65536
80005d26:	ea 08 00 0c 	add	r12,r5,r8
80005d2a:	f0 1f 00 22 	mcall	80005db0 <xg_flashc_init+0x274>
				if(return_code != DF_ERASE_COMPLETED)
80005d2e:	58 5c       	cp.w	r12,5
80005d30:	fe 90 ff 68 	breq	80005c00 <xg_flashc_init+0xc4>
80005d34:	c0 78       	rjmp	80005d42 <xg_flashc_init+0x206>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005d36:	4a 1c       	lddpc	r12,80005db8 <xg_flashc_init+0x27c>
80005d38:	f0 1f 00 07 	mcall	80005d54 <xg_flashc_init+0x218>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005d3c:	30 19       	mov	r9,1
80005d3e:	4a 08       	lddpc	r8,80005dbc <xg_flashc_init+0x280>
80005d40:	b0 89       	st.b	r8[0x0],r9
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005d42:	2f dd       	sub	sp,-12
80005d44:	d8 32       	popm	r0-r7,pc
80005d46:	00 00       	add	r0,r0
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	72 30       	ld.w	r0,r9[0xc]
80005d4c:	00 00       	add	r0,r0
80005d4e:	0b 90       	ld.ub	r0,r5[0x1]
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	e8 24 80 00 	sub	r4,557056
80005d56:	7d 80       	ld.w	r0,lr[0x60]
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	72 fc       	ld.w	r12,r9[0x3c]
80005d5c:	00 00       	add	r0,r0
80005d5e:	0b a0       	ld.ub	r0,r5[0x2]
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	e8 50 80 00 	cp.w	r0,622592
80005d66:	72 88       	ld.w	r8,r9[0x20]
80005d68:	00 00       	add	r0,r0
80005d6a:	0b 88       	ld.ub	r8,r5[0x0]
80005d6c:	00 00       	add	r0,r0
80005d6e:	0b 94       	ld.ub	r4,r5[0x1]
80005d70:	00 00       	add	r0,r0
80005d72:	51 b0       	stdsp	sp[0x6c],r0
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	33 c8       	mov	r8,60
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	30 90       	mov	r0,9
80005d7c:	00 00       	add	r0,r0
80005d7e:	0b a4       	ld.ub	r4,r5[0x2]
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	2d 34       	sub	r4,-45
80005d84:	00 00       	add	r0,r0
80005d86:	05 3c       	ld.ub	r12,r2++
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	86 04       	ld.sh	r4,r3[0x0]
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	2f 6c       	sub	r12,-10
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	87 72       	st.w	r3[0x1c],r2
80005d94:	00 00       	add	r0,r0
80005d96:	0b 9c       	ld.ub	r12,r5[0x1]
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	e8 80 80 00 	breq	80115d9a <_data_lma+0x106a0a>
80005d9e:	e8 ac       	*unknown*
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	e8 b8       	*unknown*
80005da4:	00 00       	add	r0,r0
80005da6:	05 44       	ld.w	r4,--r2
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	e8 d4 80 00 	satsub.w	r4,r4,-32768
80005dae:	e8 f8 80 00 	ld.w	r8,r4[-32768]
80005db2:	2e cc       	sub	r12,-20
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	e9 20 80 00 	ld.sb	r0,r4[-32768]
80005dba:	e9 48 00 00 	st.w	r4[0],r8
80005dbe:	0b 8c       	ld.ub	r12,r5[0x0]

80005dc0 <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005dc0:	d4 31       	pushm	r0-r7,lr
80005dc2:	20 4d       	sub	sp,16
80005dc4:	18 95       	mov	r5,r12
80005dc6:	16 96       	mov	r6,r11
80005dc8:	14 91       	mov	r1,r10
	if(!list_init_success_flag)return XG_ERROR;
80005dca:	4c e8       	lddpc	r8,80005f00 <xgflash_get_message_data+0x140>
80005dcc:	11 89       	ld.ub	r9,r8[0x0]
80005dce:	30 08       	mov	r8,0
80005dd0:	f0 09 18 00 	cp.b	r9,r8
80005dd4:	c0 31       	brne	80005dda <xgflash_get_message_data+0x1a>
80005dd6:	3f fc       	mov	r12,-1
80005dd8:	c9 18       	rjmp	80005efa <xgflash_get_message_data+0x13a>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005dda:	4c b8       	lddpc	r8,80005f04 <xgflash_get_message_data+0x144>
80005ddc:	70 0c       	ld.w	r12,r8[0x0]
80005dde:	30 09       	mov	r9,0
80005de0:	3f fa       	mov	r10,-1
80005de2:	12 9b       	mov	r11,r9
80005de4:	f0 1f 00 49 	mcall	80005f08 <xgflash_get_message_data+0x148>
	/* check input parameter */
	if (message_index > current_message_index)
80005de8:	4c 98       	lddpc	r8,80005f0c <xgflash_get_message_data+0x14c>
80005dea:	90 88       	ld.uh	r8,r8[0x0]
80005dec:	0a 38       	cp.w	r8,r5
80005dee:	c0 a2       	brcc	80005e02 <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005df0:	4c 58       	lddpc	r8,80005f04 <xgflash_get_message_data+0x144>
80005df2:	70 0c       	ld.w	r12,r8[0x0]
80005df4:	30 09       	mov	r9,0
80005df6:	12 9a       	mov	r10,r9
80005df8:	12 9b       	mov	r11,r9
80005dfa:	f0 1f 00 46 	mcall	80005f10 <xgflash_get_message_data+0x150>
80005dfe:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005e00:	c7 d8       	rjmp	80005efa <xgflash_get_message_data+0x13a>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80005e02:	fa ca ff f0 	sub	r10,sp,-16
80005e06:	30 08       	mov	r8,0
80005e08:	30 09       	mov	r9,0
80005e0a:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005e0c:	ea 00 15 03 	lsl	r0,r5,0x3
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80005e10:	30 8b       	mov	r11,8
80005e12:	00 9c       	mov	r12,r0
80005e14:	f0 1f 00 40 	mcall	80005f14 <xgflash_get_message_data+0x154>
	if (return_code == DF_OK)
80005e18:	c6 91       	brne	80005eea <xgflash_get_message_data+0x12a>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80005e1a:	9a c8       	ld.uh	r8,sp[0x8]
80005e1c:	0a 38       	cp.w	r8,r5
80005e1e:	c5 d1       	brne	80005ed8 <xgflash_get_message_data+0x118>
		{
			bytes_remained = ptr->offset;
80005e20:	40 38       	lddsp	r8,sp[0xc]
80005e22:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005e26:	50 09       	stdsp	sp[0x0],r9
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80005e28:	9a d9       	ld.uh	r9,sp[0xa]
80005e2a:	b1 88       	lsr	r8,0x10
80005e2c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80005e30:	50 18       	stdsp	sp[0x4],r8
80005e32:	40 07       	lddsp	r7,sp[0x0]
80005e34:	5c 87       	casts.h	r7
80005e36:	10 95       	mov	r5,r8
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005e38:	30 04       	mov	r4,0
80005e3a:	08 93       	mov	r3,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005e3c:	e0 62 01 ff 	mov	r2,511
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005e40:	c1 a8       	rjmp	80005e74 <xgflash_get_message_data+0xb4>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005e42:	e4 07 19 00 	cp.h	r7,r2
80005e46:	e0 8b 00 0a 	brhi	80005e5a <xgflash_get_message_data+0x9a>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80005e4a:	0c 9a       	mov	r10,r6
80005e4c:	0e 9b       	mov	r11,r7
80005e4e:	5c 7b       	castu.h	r11
80005e50:	0a 9c       	mov	r12,r5
80005e52:	f0 1f 00 31 	mcall	80005f14 <xgflash_get_message_data+0x154>
80005e56:	30 07       	mov	r7,0
80005e58:	c0 e8       	rjmp	80005e74 <xgflash_get_message_data+0xb4>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80005e5a:	0c 9a       	mov	r10,r6
80005e5c:	e0 6b 02 00 	mov	r11,512
80005e60:	0a 9c       	mov	r12,r5
80005e62:	f0 1f 00 2d 	mcall	80005f14 <xgflash_get_message_data+0x154>
					bytes_remained-=DF_DATA_SPACE_SIZE;
80005e66:	ee c7 02 00 	sub	r7,r7,512
80005e6a:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80005e6c:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80005e70:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005e74:	e8 07 19 00 	cp.h	r7,r4
80005e78:	5f 19       	srne	r9
80005e7a:	58 0c       	cp.w	r12,0
80005e7c:	5f 08       	sreq	r8
80005e7e:	f3 e8 00 08 	and	r8,r9,r8
80005e82:	e6 08 18 00 	cp.b	r8,r3
80005e86:	cd e1       	brne	80005e42 <xgflash_get_message_data+0x82>
						
				}
				//memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			
			if(erase)//erase the message
80005e88:	58 01       	cp.w	r1,0
80005e8a:	c1 e0       	breq	80005ec6 <xgflash_get_message_data+0x106>
			{
				memset(str, 0xFF, sizeof(str));
80005e8c:	fa c7 ff f0 	sub	r7,sp,-16
80005e90:	3f f8       	mov	r8,-1
80005e92:	3f f9       	mov	r9,-1
80005e94:	af 29       	st.d	--r7,r8
				//reset:current_message_index and erase info
				current_message_index-=1;
80005e96:	49 ec       	lddpc	r12,80005f0c <xgflash_get_message_data+0x14c>
80005e98:	98 08       	ld.sh	r8,r12[0x0]
80005e9a:	20 18       	sub	r8,1
80005e9c:	b8 08       	st.h	r12[0x0],r8
				return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005e9e:	30 2a       	mov	r10,2
80005ea0:	30 6b       	mov	r11,6
80005ea2:	f0 1f 00 1e 	mcall	80005f18 <xgflash_get_message_data+0x158>
				return_code = data_flash_write((U8 *)str, info_address, XG_MESSAGE_INFO_HEADER_LENGTH);
80005ea6:	30 8a       	mov	r10,8
80005ea8:	00 9b       	mov	r11,r0
80005eaa:	0e 9c       	mov	r12,r7
80005eac:	f0 1f 00 1b 	mcall	80005f18 <xgflash_get_message_data+0x158>
				
				//erase data and reset:current_save_message_offset
				return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
80005eb0:	30 8a       	mov	r10,8
80005eb2:	40 1b       	lddsp	r11,sp[0x4]
80005eb4:	0e 9c       	mov	r12,r7
80005eb6:	f0 1f 00 19 	mcall	80005f18 <xgflash_get_message_data+0x158>
				current_save_message_offset-=erase_length;//出错在这...如果掉线，未执行，则会出现存储碎片
80005eba:	49 98       	lddpc	r8,80005f1c <xgflash_get_message_data+0x15c>
80005ebc:	40 09       	lddsp	r9,sp[0x0]
80005ebe:	5c 79       	castu.h	r9
80005ec0:	70 0a       	ld.w	r10,r8[0x0]
80005ec2:	12 1a       	sub	r10,r9
80005ec4:	91 0a       	st.w	r8[0x0],r10
				
			}
		
			xSemaphoreGive(xgflash_mutex);//unlock
80005ec6:	49 08       	lddpc	r8,80005f04 <xgflash_get_message_data+0x144>
80005ec8:	70 0c       	ld.w	r12,r8[0x0]
80005eca:	30 09       	mov	r9,0
80005ecc:	12 9a       	mov	r10,r9
80005ece:	12 9b       	mov	r11,r9
80005ed0:	f0 1f 00 10 	mcall	80005f10 <xgflash_get_message_data+0x150>
80005ed4:	30 0c       	mov	r12,0
			return XG_OK;
80005ed6:	c1 28       	rjmp	80005efa <xgflash_get_message_data+0x13a>
		}
		xSemaphoreGive(xgflash_mutex);//unlock
80005ed8:	48 b8       	lddpc	r8,80005f04 <xgflash_get_message_data+0x144>
80005eda:	70 0c       	ld.w	r12,r8[0x0]
80005edc:	30 09       	mov	r9,0
80005ede:	12 9a       	mov	r10,r9
80005ee0:	12 9b       	mov	r11,r9
80005ee2:	f0 1f 00 0c 	mcall	80005f10 <xgflash_get_message_data+0x150>
80005ee6:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005ee8:	c0 98       	rjmp	80005efa <xgflash_get_message_data+0x13a>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80005eea:	48 78       	lddpc	r8,80005f04 <xgflash_get_message_data+0x144>
80005eec:	70 0c       	ld.w	r12,r8[0x0]
80005eee:	30 09       	mov	r9,0
80005ef0:	12 9a       	mov	r10,r9
80005ef2:	12 9b       	mov	r11,r9
80005ef4:	f0 1f 00 07 	mcall	80005f10 <xgflash_get_message_data+0x150>
80005ef8:	30 6c       	mov	r12,6
	return XG_FLASH_ACTION_FAIL;
		
}
80005efa:	2f cd       	sub	sp,-16
80005efc:	d8 32       	popm	r0-r7,pc
80005efe:	00 00       	add	r0,r0
80005f00:	00 00       	add	r0,r0
80005f02:	0b 8c       	ld.ub	r12,r5[0x0]
80005f04:	00 00       	add	r0,r0
80005f06:	0b 90       	ld.ub	r0,r5[0x1]
80005f08:	80 00       	ld.sh	r0,r0[0x0]
80005f0a:	6f 24       	ld.w	r4,r7[0x48]
80005f0c:	00 00       	add	r0,r0
80005f0e:	0b 9c       	ld.ub	r12,r5[0x1]
80005f10:	80 00       	ld.sh	r0,r0[0x0]
80005f12:	71 30       	ld.w	r0,r8[0x4c]
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	2d 34       	sub	r4,-45
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	2f 6c       	sub	r12,-10
80005f1c:	00 00       	add	r0,r0
80005f1e:	05 44       	ld.w	r4,--r2

80005f20 <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
80005f20:	d4 21       	pushm	r4-r7,lr
80005f22:	20 2d       	sub	sp,8
80005f24:	18 96       	mov	r6,r12
80005f26:	16 97       	mov	r7,r11
80005f28:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80005f2a:	4d 38       	lddpc	r8,80006074 <xgflash_message_save+0x154>
80005f2c:	11 89       	ld.ub	r9,r8[0x0]
80005f2e:	30 08       	mov	r8,0
80005f30:	f0 09 18 00 	cp.b	r9,r8
80005f34:	c0 31       	brne	80005f3a <xgflash_message_save+0x1a>
80005f36:	3f fc       	mov	r12,-1
80005f38:	c9 b8       	rjmp	8000606e <xgflash_message_save+0x14e>
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
		
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80005f3a:	58 0c       	cp.w	r12,0
80005f3c:	5f 09       	sreq	r9
80005f3e:	e0 68 02 00 	mov	r8,512
80005f42:	f0 0b 19 00 	cp.h	r11,r8
80005f46:	5f b8       	srhi	r8
80005f48:	f3 e8 10 08 	or	r8,r9,r8
80005f4c:	c0 30       	breq	80005f52 <xgflash_message_save+0x32>
80005f4e:	30 1c       	mov	r12,1
80005f50:	c8 f8       	rjmp	8000606e <xgflash_message_save+0x14e>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
80005f52:	16 94       	mov	r4,r11
80005f54:	5c 74       	castu.h	r4
80005f56:	4c 99       	lddpc	r9,80006078 <xgflash_message_save+0x158>
80005f58:	72 08       	ld.w	r8,r9[0x0]
80005f5a:	e8 08 00 08 	add	r8,r4,r8
80005f5e:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
80005f60:	e0 48 f0 00 	cp.w	r8,61440
80005f64:	e0 88 00 07 	brls	80005f72 <xgflash_message_save+0x52>
	{
		current_bytes_remained = 0;
80005f68:	30 09       	mov	r9,0
80005f6a:	4c 48       	lddpc	r8,80006078 <xgflash_message_save+0x158>
80005f6c:	91 09       	st.w	r8[0x0],r9
80005f6e:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005f70:	c7 f8       	rjmp	8000606e <xgflash_message_save+0x14e>
	}
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock
80005f72:	4c 38       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
80005f74:	70 0c       	ld.w	r12,r8[0x0]
80005f76:	30 09       	mov	r9,0
80005f78:	3f fa       	mov	r10,-1
80005f7a:	12 9b       	mov	r11,r9
80005f7c:	f0 1f 00 41 	mcall	80006080 <xgflash_message_save+0x160>
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
80005f80:	4c 18       	lddpc	r8,80006084 <xgflash_message_save+0x164>
80005f82:	70 0b       	ld.w	r11,r8[0x0]
80005f84:	e0 68 ff ff 	mov	r8,65535
80005f88:	ea 18 00 7f 	orh	r8,0x7f
80005f8c:	10 3b       	cp.w	r11,r8
80005f8e:	e0 88 00 10 	brls	80005fae <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
80005f92:	4b ec       	lddpc	r12,80006088 <xgflash_message_save+0x168>
80005f94:	f0 1f 00 3e 	mcall	8000608c <xgflash_message_save+0x16c>
		current_bytes_remained = 0;
80005f98:	30 0b       	mov	r11,0
80005f9a:	4b 88       	lddpc	r8,80006078 <xgflash_message_save+0x158>
80005f9c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
80005f9e:	4b 88       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
80005fa0:	70 0c       	ld.w	r12,r8[0x0]
80005fa2:	16 99       	mov	r9,r11
80005fa4:	16 9a       	mov	r10,r11
80005fa6:	f0 1f 00 3b 	mcall	80006090 <xgflash_message_save+0x170>
80005faa:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80005fac:	c6 18       	rjmp	8000606e <xgflash_message_save+0x14e>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
80005fae:	0e 9a       	mov	r10,r7
80005fb0:	5c 7a       	castu.h	r10
80005fb2:	0c 9c       	mov	r12,r6
80005fb4:	f0 1f 00 38 	mcall	80006094 <xgflash_message_save+0x174>
	if(return_code != DF_WRITE_COMPLETED)
80005fb8:	58 7c       	cp.w	r12,7
80005fba:	c0 c0       	breq	80005fd2 <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
80005fbc:	30 0b       	mov	r11,0
80005fbe:	4a f8       	lddpc	r8,80006078 <xgflash_message_save+0x158>
80005fc0:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
80005fc2:	4a f8       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
80005fc4:	70 0c       	ld.w	r12,r8[0x0]
80005fc6:	16 99       	mov	r9,r11
80005fc8:	16 9a       	mov	r10,r11
80005fca:	f0 1f 00 32 	mcall	80006090 <xgflash_message_save+0x170>
80005fce:	30 6c       	mov	r12,6
		return XG_FLASH_ACTION_FAIL;
80005fd0:	c4 f8       	rjmp	8000606e <xgflash_message_save+0x14e>
	}
	
	current_save_message_offset+=data_len;
80005fd2:	4a d8       	lddpc	r8,80006084 <xgflash_message_save+0x164>
80005fd4:	70 09       	ld.w	r9,r8[0x0]
80005fd6:	12 04       	add	r4,r9
80005fd8:	91 04       	st.w	r8[0x0],r4
	//log("current_save_message_offset : %X\n", current_save_message_offset);
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
80005fda:	30 18       	mov	r8,1
80005fdc:	f0 05 18 00 	cp.b	r5,r8
80005fe0:	c3 f1       	brne	8000605e <xgflash_message_save+0x13e>
	{
		current_message_index++;
80005fe2:	4a e9       	lddpc	r9,80006098 <xgflash_message_save+0x178>
80005fe4:	92 08       	ld.sh	r8,r9[0x0]
80005fe6:	2f f8       	sub	r8,-1
80005fe8:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80005fea:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80005fec:	4a 39       	lddpc	r9,80006078 <xgflash_message_save+0x158>
80005fee:	72 09       	ld.w	r9,r9[0x0]
80005ff0:	12 14       	sub	r4,r9
80005ff2:	40 0a       	lddsp	r10,sp[0x0]
80005ff4:	e0 1a 00 00 	andl	r10,0x0
80005ff8:	f5 e4 13 0a 	or	r10,r10,r4>>0x10
80005ffc:	50 0a       	stdsp	sp[0x0],r10
80005ffe:	ba 24       	st.h	sp[0x4],r4
		ptr.offset		= current_bytes_remained;
80006000:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80006002:	5c 78       	castu.h	r8
80006004:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80006008:	e2 4b 00 00 	cp.w	r11,131072
8000600c:	e0 88 00 10 	brls	8000602c <xgflash_message_save+0x10c>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
80006010:	4a 3c       	lddpc	r12,8000609c <xgflash_message_save+0x17c>
80006012:	f0 1f 00 1f 	mcall	8000608c <xgflash_message_save+0x16c>
			current_bytes_remained = 0;
80006016:	30 0b       	mov	r11,0
80006018:	49 88       	lddpc	r8,80006078 <xgflash_message_save+0x158>
8000601a:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
8000601c:	49 88       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
8000601e:	70 0c       	ld.w	r12,r8[0x0]
80006020:	16 99       	mov	r9,r11
80006022:	16 9a       	mov	r10,r11
80006024:	f0 1f 00 1b 	mcall	80006090 <xgflash_message_save+0x170>
80006028:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
8000602a:	c2 28       	rjmp	8000606e <xgflash_message_save+0x14e>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
8000602c:	30 8a       	mov	r10,8
8000602e:	1a 9c       	mov	r12,sp
80006030:	f0 1f 00 19 	mcall	80006094 <xgflash_message_save+0x174>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80006034:	30 2a       	mov	r10,2
80006036:	30 6b       	mov	r11,6
80006038:	49 8c       	lddpc	r12,80006098 <xgflash_message_save+0x178>
8000603a:	f0 1f 00 17 	mcall	80006094 <xgflash_message_save+0x174>
		if(return_code != DF_WRITE_COMPLETED)
8000603e:	58 7c       	cp.w	r12,7
80006040:	c0 c0       	breq	80006058 <xgflash_message_save+0x138>
		{
			current_bytes_remained = 0;
80006042:	30 0b       	mov	r11,0
80006044:	48 d8       	lddpc	r8,80006078 <xgflash_message_save+0x158>
80006046:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006048:	48 d8       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
8000604a:	70 0c       	ld.w	r12,r8[0x0]
8000604c:	16 99       	mov	r9,r11
8000604e:	16 9a       	mov	r10,r11
80006050:	f0 1f 00 10 	mcall	80006090 <xgflash_message_save+0x170>
80006054:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
80006056:	c0 c8       	rjmp	8000606e <xgflash_message_save+0x14e>
		}
		
		current_bytes_remained = 0;//reset 0
80006058:	30 09       	mov	r9,0
8000605a:	48 88       	lddpc	r8,80006078 <xgflash_message_save+0x158>
8000605c:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
8000605e:	48 88       	lddpc	r8,8000607c <xgflash_message_save+0x15c>
80006060:	70 0c       	ld.w	r12,r8[0x0]
80006062:	30 09       	mov	r9,0
80006064:	12 9a       	mov	r10,r9
80006066:	12 9b       	mov	r11,r9
80006068:	f0 1f 00 0a 	mcall	80006090 <xgflash_message_save+0x170>
8000606c:	30 0c       	mov	r12,0
	return XG_OK;

}
8000606e:	2f ed       	sub	sp,-8
80006070:	d8 22       	popm	r4-r7,pc
80006072:	00 00       	add	r0,r0
80006074:	00 00       	add	r0,r0
80006076:	0b 8c       	ld.ub	r12,r5[0x0]
80006078:	00 00       	add	r0,r0
8000607a:	0b 98       	ld.ub	r8,r5[0x1]
8000607c:	00 00       	add	r0,r0
8000607e:	0b 90       	ld.ub	r0,r5[0x1]
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	6f 24       	ld.w	r4,r7[0x48]
80006084:	00 00       	add	r0,r0
80006086:	05 44       	ld.w	r4,--r2
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	e9 84       	*unknown*
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	7d 80       	ld.w	r0,lr[0x60]
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	71 30       	ld.w	r0,r8[0x4c]
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	2f 6c       	sub	r12,-10
80006098:	00 00       	add	r0,r0
8000609a:	0b 9c       	ld.ub	r12,r5[0x1]
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	e9 b4       	*unknown*

800060a0 <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
800060a0:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
800060a4:	48 d8       	lddpc	r8,800060d8 <xgflash_get_message_count+0x38>
800060a6:	11 89       	ld.ub	r9,r8[0x0]
800060a8:	30 08       	mov	r8,0
800060aa:	f0 09 18 00 	cp.b	r9,r8
800060ae:	c0 31       	brne	800060b4 <xgflash_get_message_count+0x14>
800060b0:	3f f7       	mov	r7,-1
800060b2:	c1 08       	rjmp	800060d2 <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
800060b4:	48 a6       	lddpc	r6,800060dc <xgflash_get_message_count+0x3c>
800060b6:	6c 0c       	ld.w	r12,r6[0x0]
800060b8:	30 09       	mov	r9,0
800060ba:	3f fa       	mov	r10,-1
800060bc:	12 9b       	mov	r11,r9
800060be:	f0 1f 00 09 	mcall	800060e0 <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
800060c2:	48 98       	lddpc	r8,800060e4 <xgflash_get_message_count+0x44>
800060c4:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
800060c6:	6c 0c       	ld.w	r12,r6[0x0]
800060c8:	30 09       	mov	r9,0
800060ca:	12 9a       	mov	r10,r9
800060cc:	12 9b       	mov	r11,r9
800060ce:	f0 1f 00 07 	mcall	800060e8 <xgflash_get_message_count+0x48>

	return return_value;
	
}
800060d2:	0e 9c       	mov	r12,r7
800060d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060d8:	00 00       	add	r0,r0
800060da:	0b 8c       	ld.ub	r12,r5[0x0]
800060dc:	00 00       	add	r0,r0
800060de:	0b 90       	ld.ub	r0,r5[0x1]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	6f 24       	ld.w	r4,r7[0x48]
800060e4:	00 00       	add	r0,r0
800060e6:	0b 9c       	ld.ub	r12,r5[0x1]
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	71 30       	ld.w	r0,r8[0x4c]

800060ec <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800060ec:	fe 68 14 00 	mov	r8,-125952
800060f0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800060f2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800060f6:	91 09       	st.w	r8[0x0],r9
}
800060f8:	5e fc       	retal	r12

800060fa <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800060fa:	f8 08 16 05 	lsr	r8,r12,0x5
800060fe:	a9 68       	lsl	r8,0x8
80006100:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006104:	58 1b       	cp.w	r11,1
80006106:	c0 d0       	breq	80006120 <gpio_enable_module_pin+0x26>
80006108:	c0 63       	brcs	80006114 <gpio_enable_module_pin+0x1a>
8000610a:	58 2b       	cp.w	r11,2
8000610c:	c1 00       	breq	8000612c <gpio_enable_module_pin+0x32>
8000610e:	58 3b       	cp.w	r11,3
80006110:	c1 40       	breq	80006138 <gpio_enable_module_pin+0x3e>
80006112:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006114:	30 19       	mov	r9,1
80006116:	f2 0c 09 49 	lsl	r9,r9,r12
8000611a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000611c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000611e:	c1 28       	rjmp	80006142 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006120:	30 19       	mov	r9,1
80006122:	f2 0c 09 49 	lsl	r9,r9,r12
80006126:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006128:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000612a:	c0 c8       	rjmp	80006142 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000612c:	30 19       	mov	r9,1
8000612e:	f2 0c 09 49 	lsl	r9,r9,r12
80006132:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006134:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006136:	c0 68       	rjmp	80006142 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006138:	30 19       	mov	r9,1
8000613a:	f2 0c 09 49 	lsl	r9,r9,r12
8000613e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006140:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006142:	30 19       	mov	r9,1
80006144:	f2 0c 09 4c 	lsl	r12,r9,r12
80006148:	91 2c       	st.w	r8[0x8],r12
8000614a:	5e fd       	retal	0

8000614c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000614c:	d4 21       	pushm	r4-r7,lr
8000614e:	18 97       	mov	r7,r12
80006150:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006152:	58 0b       	cp.w	r11,0
80006154:	c0 31       	brne	8000615a <gpio_enable_module+0xe>
80006156:	30 05       	mov	r5,0
80006158:	c0 d8       	rjmp	80006172 <gpio_enable_module+0x26>
8000615a:	30 06       	mov	r6,0
8000615c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000615e:	6e 1b       	ld.w	r11,r7[0x4]
80006160:	6e 0c       	ld.w	r12,r7[0x0]
80006162:	f0 1f 00 06 	mcall	80006178 <gpio_enable_module+0x2c>
80006166:	18 45       	or	r5,r12
		gpiomap++;
80006168:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000616a:	2f f6       	sub	r6,-1
8000616c:	0c 34       	cp.w	r4,r6
8000616e:	fe 9b ff f8 	brhi	8000615e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006172:	0a 9c       	mov	r12,r5
80006174:	d8 22       	popm	r4-r7,pc
80006176:	00 00       	add	r0,r0
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	60 fa       	ld.w	r10,r0[0x3c]

8000617c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000617c:	f8 08 16 05 	lsr	r8,r12,0x5
80006180:	a9 68       	lsl	r8,0x8
80006182:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006186:	30 19       	mov	r9,1
80006188:	f2 0c 09 4c 	lsl	r12,r9,r12
8000618c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006190:	91 1c       	st.w	r8[0x4],r12
}
80006192:	5e fc       	retal	r12

80006194 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006194:	f8 08 16 05 	lsr	r8,r12,0x5
80006198:	a9 68       	lsl	r8,0x8
8000619a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000619e:	30 19       	mov	r9,1
800061a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800061a4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800061a8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800061ac:	91 1c       	st.w	r8[0x4],r12
}
800061ae:	5e fc       	retal	r12

800061b0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800061b0:	f8 08 16 05 	lsr	r8,r12,0x5
800061b4:	a9 68       	lsl	r8,0x8
800061b6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800061ba:	30 19       	mov	r9,1
800061bc:	f2 0c 09 4c 	lsl	r12,r9,r12
800061c0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800061c4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800061c8:	91 1c       	st.w	r8[0x4],r12
}
800061ca:	5e fc       	retal	r12

800061cc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800061cc:	c0 08       	rjmp	800061cc <_unhandled_interrupt>
800061ce:	d7 03       	nop

800061d0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800061d0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800061d4:	49 99       	lddpc	r9,80006238 <INTC_register_interrupt+0x68>
800061d6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800061da:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800061de:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800061e0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800061e4:	58 0a       	cp.w	r10,0
800061e6:	c0 91       	brne	800061f8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800061e8:	49 59       	lddpc	r9,8000623c <INTC_register_interrupt+0x6c>
800061ea:	49 6a       	lddpc	r10,80006240 <INTC_register_interrupt+0x70>
800061ec:	12 1a       	sub	r10,r9
800061ee:	fe 79 08 00 	mov	r9,-63488
800061f2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800061f6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800061f8:	58 1a       	cp.w	r10,1
800061fa:	c0 a1       	brne	8000620e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800061fc:	49 09       	lddpc	r9,8000623c <INTC_register_interrupt+0x6c>
800061fe:	49 2a       	lddpc	r10,80006244 <INTC_register_interrupt+0x74>
80006200:	12 1a       	sub	r10,r9
80006202:	bf aa       	sbr	r10,0x1e
80006204:	fe 79 08 00 	mov	r9,-63488
80006208:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000620c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000620e:	58 2a       	cp.w	r10,2
80006210:	c0 a1       	brne	80006224 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80006212:	48 b9       	lddpc	r9,8000623c <INTC_register_interrupt+0x6c>
80006214:	48 da       	lddpc	r10,80006248 <INTC_register_interrupt+0x78>
80006216:	12 1a       	sub	r10,r9
80006218:	bf ba       	sbr	r10,0x1f
8000621a:	fe 79 08 00 	mov	r9,-63488
8000621e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006222:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006224:	48 69       	lddpc	r9,8000623c <INTC_register_interrupt+0x6c>
80006226:	48 aa       	lddpc	r10,8000624c <INTC_register_interrupt+0x7c>
80006228:	12 1a       	sub	r10,r9
8000622a:	ea 1a c0 00 	orh	r10,0xc000
8000622e:	fe 79 08 00 	mov	r9,-63488
80006232:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006236:	5e fc       	retal	r12
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	ea 5c 80 00 	cp.w	r12,753664
8000623e:	dc 00       	acall	0xc0
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	dd 04       	*unknown*
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	dd 12       	popm	r0-r3,r11,lr-pc
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	dd 20       	acall	0xd2
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	dd 2e       	*unknown*

80006250 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006250:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006252:	49 18       	lddpc	r8,80006294 <INTC_init_interrupts+0x44>
80006254:	e3 b8 00 01 	mtsr	0x4,r8
80006258:	49 0e       	lddpc	lr,80006298 <INTC_init_interrupts+0x48>
8000625a:	30 07       	mov	r7,0
8000625c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000625e:	49 0c       	lddpc	r12,8000629c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006260:	49 05       	lddpc	r5,800062a0 <INTC_init_interrupts+0x50>
80006262:	10 15       	sub	r5,r8
80006264:	fe 76 08 00 	mov	r6,-63488
80006268:	c1 08       	rjmp	80006288 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000626a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000626c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000626e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006270:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006274:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006276:	10 3a       	cp.w	r10,r8
80006278:	fe 9b ff fc 	brhi	80006270 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000627c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006280:	2f f7       	sub	r7,-1
80006282:	2f 8e       	sub	lr,-8
80006284:	59 37       	cp.w	r7,19
80006286:	c0 50       	breq	80006290 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006288:	7c 08       	ld.w	r8,lr[0x0]
8000628a:	58 08       	cp.w	r8,0
8000628c:	ce f1       	brne	8000626a <INTC_init_interrupts+0x1a>
8000628e:	cf 7b       	rjmp	8000627c <INTC_init_interrupts+0x2c>
80006290:	d8 22       	popm	r4-r7,pc
80006292:	00 00       	add	r0,r0
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	dc 00       	acall	0xc0
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	ea 5c 80 00 	cp.w	r12,753664
8000629e:	61 cc       	ld.w	r12,r0[0x70]
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	dd 04       	*unknown*

800062a4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800062a4:	fe 78 08 00 	mov	r8,-63488
800062a8:	e0 69 00 83 	mov	r9,131
800062ac:	f2 0c 01 0c 	sub	r12,r9,r12
800062b0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800062b4:	f2 ca ff c0 	sub	r10,r9,-64
800062b8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800062bc:	58 08       	cp.w	r8,0
800062be:	c0 21       	brne	800062c2 <_get_interrupt_handler+0x1e>
800062c0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800062c2:	f0 08 12 00 	clz	r8,r8
800062c6:	48 5a       	lddpc	r10,800062d8 <_get_interrupt_handler+0x34>
800062c8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800062cc:	f0 08 11 1f 	rsub	r8,r8,31
800062d0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800062d2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800062d6:	5e fc       	retal	r12
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	ea 5c 78 a8 	cp.w	r12,751784

800062dc <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800062dc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800062de:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800062e2:	99 a8       	st.w	r12[0x28],r8
}
800062e4:	5e fc       	retal	r12
800062e6:	d7 03       	nop

800062e8 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800062e8:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800062ea:	ec 5b bb 9f 	cp.w	r11,899999
800062ee:	e0 8b 00 04 	brhi	800062f6 <pm_enable_osc0_crystal+0xe>
800062f2:	30 4b       	mov	r11,4
800062f4:	c1 38       	rjmp	8000631a <pm_enable_osc0_crystal+0x32>
800062f6:	e0 68 c6 bf 	mov	r8,50879
800062fa:	ea 18 00 2d 	orh	r8,0x2d
800062fe:	10 3b       	cp.w	r11,r8
80006300:	e0 8b 00 04 	brhi	80006308 <pm_enable_osc0_crystal+0x20>
80006304:	30 5b       	mov	r11,5
80006306:	c0 a8       	rjmp	8000631a <pm_enable_osc0_crystal+0x32>
80006308:	e0 68 12 00 	mov	r8,4608
8000630c:	ea 18 00 7a 	orh	r8,0x7a
80006310:	10 3b       	cp.w	r11,r8
80006312:	f9 bb 03 06 	movlo	r11,6
80006316:	f9 bb 02 07 	movhs	r11,7
8000631a:	f0 1f 00 02 	mcall	80006320 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000631e:	d8 02       	popm	pc
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	62 dc       	ld.w	r12,r1[0x34]

80006324 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006324:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006326:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000632a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000632c:	78 08       	ld.w	r8,r12[0x0]
8000632e:	a3 a8       	sbr	r8,0x2
80006330:	99 08       	st.w	r12[0x0],r8
}
80006332:	5e fc       	retal	r12

80006334 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006334:	79 58       	ld.w	r8,r12[0x54]
80006336:	e2 18 00 80 	andl	r8,0x80,COH
8000633a:	cf d0       	breq	80006334 <pm_wait_for_clk0_ready>
}
8000633c:	5e fc       	retal	r12
8000633e:	d7 03       	nop

80006340 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80006340:	eb cd 40 80 	pushm	r7,lr
80006344:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006346:	f0 1f 00 04 	mcall	80006354 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000634a:	0e 9c       	mov	r12,r7
8000634c:	f0 1f 00 03 	mcall	80006358 <pm_enable_clk0+0x18>
}
80006350:	e3 cd 80 80 	ldm	sp++,r7,pc
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	63 24       	ld.w	r4,r1[0x48]
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	63 34       	ld.w	r4,r1[0x4c]

8000635c <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
8000635c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000635e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006362:	99 c8       	st.w	r12[0x30],r8
}
80006364:	5e fc       	retal	r12
80006366:	d7 03       	nop

80006368 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80006368:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000636a:	30 1b       	mov	r11,1
8000636c:	f0 1f 00 02 	mcall	80006374 <pm_enable_osc32_crystal+0xc>
}
80006370:	d8 02       	popm	pc
80006372:	00 00       	add	r0,r0
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	63 5c       	ld.w	r12,r1[0x54]

80006378 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006378:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000637a:	30 19       	mov	r9,1
8000637c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80006380:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006384:	99 c8       	st.w	r12[0x30],r8
}
80006386:	5e fc       	retal	r12

80006388 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80006388:	79 58       	ld.w	r8,r12[0x54]
8000638a:	e2 18 02 00 	andl	r8,0x200,COH
8000638e:	cf d0       	breq	80006388 <pm_wait_for_clk32_ready>
}
80006390:	5e fc       	retal	r12
80006392:	d7 03       	nop

80006394 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006394:	eb cd 40 80 	pushm	r7,lr
80006398:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000639a:	f0 1f 00 04 	mcall	800063a8 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000639e:	0e 9c       	mov	r12,r7
800063a0:	f0 1f 00 03 	mcall	800063ac <pm_enable_clk32+0x18>
}
800063a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800063a8:	80 00       	ld.sh	r0,r0[0x0]
800063aa:	63 78       	ld.w	r8,r1[0x5c]
800063ac:	80 00       	ld.sh	r0,r0[0x0]
800063ae:	63 88       	ld.w	r8,r1[0x60]

800063b0 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800063b0:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800063b4:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800063b8:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800063ba:	09 f7       	ld.ub	r7,r4[0x7]
800063bc:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800063c0:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800063c4:	09 b4       	ld.ub	r4,r4[0x3]
800063c6:	08 96       	mov	r6,r4
800063c8:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800063cc:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800063d0:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800063d4:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800063d8:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800063dc:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800063e0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800063e4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800063e8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800063ea:	79 58       	ld.w	r8,r12[0x54]
800063ec:	e2 18 00 20 	andl	r8,0x20,COH
800063f0:	cf d0       	breq	800063ea <pm_cksel+0x3a>
}
800063f2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800063f6 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800063f6:	eb cd 40 80 	pushm	r7,lr
800063fa:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800063fc:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800063fe:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006402:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006406:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000640a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000640e:	2f 8b       	sub	r11,-8
80006410:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006414:	e3 cd 80 80 	ldm	sp++,r7,pc

80006418 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006418:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000641a:	2f 8b       	sub	r11,-8
8000641c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80006420:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006424:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006428:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000642c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006430:	d8 02       	popm	pc

80006432 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80006432:	2f 8b       	sub	r11,-8
80006434:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006438:	a1 a8       	sbr	r8,0x0
8000643a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000643e:	5e fc       	retal	r12

80006440 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006440:	79 58       	ld.w	r8,r12[0x54]
80006442:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006446:	cf d0       	breq	80006440 <pm_wait_for_pll0_locked>
}
80006448:	5e fc       	retal	r12

8000644a <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000644a:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000644c:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80006450:	99 08       	st.w	r12[0x0],r8
}
80006452:	5e fc       	retal	r12

80006454 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006454:	eb cd 40 c0 	pushm	r6-r7,lr
80006458:	18 97       	mov	r7,r12
8000645a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000645c:	f0 1f 00 06 	mcall	80006474 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80006460:	0c 9b       	mov	r11,r6
80006462:	0e 9c       	mov	r12,r7
80006464:	f0 1f 00 05 	mcall	80006478 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006468:	30 1b       	mov	r11,1
8000646a:	0e 9c       	mov	r12,r7
8000646c:	f0 1f 00 04 	mcall	8000647c <pm_switch_to_osc0+0x28>
}
80006470:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	62 e8       	ld.w	r8,r1[0x38]
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	63 40       	ld.w	r0,r1[0x50]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	64 4a       	ld.w	r10,r2[0x10]

80006480 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80006480:	78 0c       	ld.w	r12,r12[0x0]
}
80006482:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80006486:	5e fc       	retal	r12

80006488 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80006488:	eb cd 40 c0 	pushm	r6-r7,lr
8000648c:	18 97       	mov	r7,r12
8000648e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80006490:	0e 9c       	mov	r12,r7
80006492:	f0 1f 00 06 	mcall	800064a8 <rtc_set_value+0x20>
80006496:	cf d1       	brne	80006490 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80006498:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000649a:	0e 9c       	mov	r12,r7
8000649c:	f0 1f 00 03 	mcall	800064a8 <rtc_set_value+0x20>
800064a0:	cf d1       	brne	8000649a <rtc_set_value+0x12>
}
800064a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064a6:	00 00       	add	r0,r0
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	64 80       	ld.w	r0,r2[0x20]

800064ac <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800064ac:	eb cd 40 80 	pushm	r7,lr
800064b0:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800064b2:	0e 9c       	mov	r12,r7
800064b4:	f0 1f 00 06 	mcall	800064cc <rtc_enable+0x20>
800064b8:	cf d1       	brne	800064b2 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800064ba:	6e 08       	ld.w	r8,r7[0x0]
800064bc:	a1 a8       	sbr	r8,0x0
800064be:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800064c0:	0e 9c       	mov	r12,r7
800064c2:	f0 1f 00 03 	mcall	800064cc <rtc_enable+0x20>
800064c6:	cf d1       	brne	800064c0 <rtc_enable+0x14>
}
800064c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	64 80       	ld.w	r0,r2[0x20]

800064d0 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800064d0:	30 18       	mov	r8,1
800064d2:	99 48       	st.w	r12[0x10],r8
}
800064d4:	5e fc       	retal	r12
800064d6:	d7 03       	nop

800064d8 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800064d8:	eb cd 40 c0 	pushm	r6-r7,lr
800064dc:	18 97       	mov	r7,r12
800064de:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800064e0:	0e 9c       	mov	r12,r7
800064e2:	f0 1f 00 06 	mcall	800064f8 <rtc_set_top_value+0x20>
800064e6:	cf d1       	brne	800064e0 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800064e8:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800064ea:	0e 9c       	mov	r12,r7
800064ec:	f0 1f 00 03 	mcall	800064f8 <rtc_set_top_value+0x20>
800064f0:	cf d1       	brne	800064ea <rtc_set_top_value+0x12>
}
800064f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064f6:	00 00       	add	r0,r0
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	64 80       	ld.w	r0,r2[0x20]

800064fc <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800064fc:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80006500:	e6 18 00 01 	andh	r8,0x1,COH
80006504:	c0 71       	brne	80006512 <rtc_clear_interrupt+0x16>
80006506:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006508:	30 18       	mov	r8,1
8000650a:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000650c:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000650e:	d5 03       	csrf	0x10
80006510:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006512:	30 18       	mov	r8,1
80006514:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006516:	78 78       	ld.w	r8,r12[0x1c]
80006518:	5e fc       	retal	r12
8000651a:	d7 03       	nop

8000651c <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
8000651c:	eb cd 40 e0 	pushm	r5-r7,lr
80006520:	18 97       	mov	r7,r12
80006522:	16 96       	mov	r6,r11
80006524:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80006526:	30 18       	mov	r8,1
80006528:	f0 0b 18 00 	cp.b	r11,r8
8000652c:	5f b9       	srhi	r9
8000652e:	30 f8       	mov	r8,15
80006530:	f0 0a 18 00 	cp.b	r10,r8
80006534:	5f b8       	srhi	r8
80006536:	f3 e8 10 08 	or	r8,r9,r8
8000653a:	c0 30       	breq	80006540 <rtc_init+0x24>
8000653c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80006540:	30 18       	mov	r8,1
80006542:	f0 0b 18 00 	cp.b	r11,r8
80006546:	c0 a1       	brne	8000655a <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80006548:	fe 7c 0c 00 	mov	r12,-62464
8000654c:	f0 1f 00 0f 	mcall	80006588 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80006550:	30 0b       	mov	r11,0
80006552:	fe 7c 0c 00 	mov	r12,-62464
80006556:	f0 1f 00 0e 	mcall	8000658c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000655a:	0e 9c       	mov	r12,r7
8000655c:	f0 1f 00 0d 	mcall	80006590 <rtc_init+0x74>
80006560:	cf d1       	brne	8000655a <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80006562:	a3 76       	lsl	r6,0x3
80006564:	b1 a6       	sbr	r6,0x10
80006566:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000656a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
8000656c:	0e 9c       	mov	r12,r7
8000656e:	f0 1f 00 09 	mcall	80006590 <rtc_init+0x74>
80006572:	cf d1       	brne	8000656c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006574:	30 0b       	mov	r11,0
80006576:	0e 9c       	mov	r12,r7
80006578:	f0 1f 00 07 	mcall	80006594 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
8000657c:	3f fb       	mov	r11,-1
8000657e:	0e 9c       	mov	r12,r7
80006580:	f0 1f 00 06 	mcall	80006598 <rtc_init+0x7c>
80006584:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	63 68       	ld.w	r8,r1[0x58]
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	63 94       	ld.w	r4,r1[0x64]
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	64 80       	ld.w	r0,r2[0x20]
80006594:	80 00       	ld.sh	r0,r0[0x0]
80006596:	64 88       	ld.w	r8,r2[0x20]
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	64 d8       	ld.w	r8,r2[0x34]

8000659c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000659c:	f8 c8 00 01 	sub	r8,r12,1
800065a0:	f0 0b 00 0b 	add	r11,r8,r11
800065a4:	f6 0c 0d 0a 	divu	r10,r11,r12
800065a8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800065aa:	f4 c8 00 01 	sub	r8,r10,1
800065ae:	e0 48 00 fe 	cp.w	r8,254
800065b2:	e0 88 00 03 	brls	800065b8 <getBaudDiv+0x1c>
800065b6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800065b8:	5c 8c       	casts.h	r12
}
800065ba:	5e fc       	retal	r12

800065bc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800065bc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800065c0:	30 18       	mov	r8,1
800065c2:	f0 09 18 00 	cp.b	r9,r8
800065c6:	e0 88 00 04 	brls	800065ce <spi_initMaster+0x12>
800065ca:	30 2c       	mov	r12,2
800065cc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800065ce:	e0 68 00 80 	mov	r8,128
800065d2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800065d4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800065d6:	30 19       	mov	r9,1
800065d8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800065dc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800065e0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800065e4:	30 09       	mov	r9,0
800065e6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800065ea:	30 fa       	mov	r10,15
800065ec:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800065f0:	99 18       	st.w	r12[0x4],r8
800065f2:	5e f9       	retal	r9

800065f4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800065f4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800065f6:	30 18       	mov	r8,1
800065f8:	f0 0b 18 00 	cp.b	r11,r8
800065fc:	5f be       	srhi	lr
800065fe:	f0 0a 18 00 	cp.b	r10,r8
80006602:	5f b8       	srhi	r8
80006604:	fd e8 10 08 	or	r8,lr,r8
80006608:	c0 30       	breq	8000660e <spi_selectionMode+0x1a>
8000660a:	30 2c       	mov	r12,2
8000660c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000660e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006610:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006614:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006618:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000661c:	99 18       	st.w	r12[0x4],r8
8000661e:	d8 0a       	popm	pc,r12=0

80006620 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006620:	30 18       	mov	r8,1
80006622:	99 08       	st.w	r12[0x0],r8
}
80006624:	5e fc       	retal	r12

80006626 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006626:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000662a:	c0 58       	rjmp	80006634 <spi_write+0xe>
		if (!timeout--) {
8000662c:	58 08       	cp.w	r8,0
8000662e:	c0 21       	brne	80006632 <spi_write+0xc>
80006630:	5e ff       	retal	1
80006632:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006634:	78 49       	ld.w	r9,r12[0x10]
80006636:	e2 19 00 02 	andl	r9,0x2,COH
8000663a:	cf 90       	breq	8000662c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000663c:	5c 7b       	castu.h	r11
8000663e:	99 3b       	st.w	r12[0xc],r11
80006640:	5e fd       	retal	0

80006642 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80006642:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006646:	c0 58       	rjmp	80006650 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80006648:	58 08       	cp.w	r8,0
8000664a:	c0 21       	brne	8000664e <spi_read+0xc>
8000664c:	5e ff       	retal	1
8000664e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006650:	78 49       	ld.w	r9,r12[0x10]
80006652:	e2 19 02 01 	andl	r9,0x201,COH
80006656:	e0 49 02 01 	cp.w	r9,513
8000665a:	cf 71       	brne	80006648 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000665c:	78 28       	ld.w	r8,r12[0x8]
8000665e:	b6 08       	st.h	r11[0x0],r8
80006660:	5e fd       	retal	0
80006662:	d7 03       	nop

80006664 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006664:	eb cd 40 f8 	pushm	r3-r7,lr
80006668:	18 95       	mov	r5,r12
8000666a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000666c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006670:	30 38       	mov	r8,3
80006672:	f0 06 18 00 	cp.b	r6,r8
80006676:	e0 8b 00 5e 	brhi	80006732 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000667a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000667e:	30 18       	mov	r8,1
80006680:	f0 04 18 00 	cp.b	r4,r8
80006684:	e0 8b 00 57 	brhi	80006732 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006688:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000668c:	30 78       	mov	r8,7
8000668e:	f0 03 18 00 	cp.b	r3,r8
80006692:	e0 88 00 50 	brls	80006732 <spi_setupChipReg+0xce>
80006696:	31 08       	mov	r8,16
80006698:	f0 03 18 00 	cp.b	r3,r8
8000669c:	e0 8b 00 4b 	brhi	80006732 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800066a0:	14 9b       	mov	r11,r10
800066a2:	6e 1c       	ld.w	r12,r7[0x4]
800066a4:	f0 1f 00 26 	mcall	8000673c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800066a8:	c4 55       	brlt	80006732 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800066aa:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800066ac:	ec 09 16 01 	lsr	r9,r6,0x1
800066b0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800066b4:	ec 16 00 01 	eorl	r6,0x1
800066b8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800066bc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800066c0:	20 83       	sub	r3,8
800066c2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800066c6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800066ca:	ef 39 00 09 	ld.ub	r9,r7[9]
800066ce:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800066d2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800066d6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800066da:	0f 89       	ld.ub	r9,r7[0x0]
800066dc:	30 1a       	mov	r10,1
800066de:	f4 09 18 00 	cp.b	r9,r10
800066e2:	c0 d0       	breq	800066fc <spi_setupChipReg+0x98>
800066e4:	c0 a3       	brcs	800066f8 <spi_setupChipReg+0x94>
800066e6:	30 2a       	mov	r10,2
800066e8:	f4 09 18 00 	cp.b	r9,r10
800066ec:	c0 a0       	breq	80006700 <spi_setupChipReg+0x9c>
800066ee:	30 3a       	mov	r10,3
800066f0:	f4 09 18 00 	cp.b	r9,r10
800066f4:	c1 f1       	brne	80006732 <spi_setupChipReg+0xce>
800066f6:	c0 78       	rjmp	80006704 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800066f8:	8b c8       	st.w	r5[0x30],r8
		break;
800066fa:	c0 68       	rjmp	80006706 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800066fc:	8b d8       	st.w	r5[0x34],r8
		break;
800066fe:	c0 48       	rjmp	80006706 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80006700:	8b e8       	st.w	r5[0x38],r8
		break;
80006702:	c0 28       	rjmp	80006706 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006704:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006706:	48 f8       	lddpc	r8,80006740 <spi_setupChipReg+0xdc>
80006708:	70 08       	ld.w	r8,r8[0x0]
8000670a:	58 08       	cp.w	r8,0
8000670c:	c1 61       	brne	80006738 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000670e:	30 0b       	mov	r11,0
80006710:	30 1c       	mov	r12,1
80006712:	f0 1f 00 0d 	mcall	80006744 <spi_setupChipReg+0xe0>
80006716:	48 b8       	lddpc	r8,80006740 <spi_setupChipReg+0xdc>
80006718:	91 0c       	st.w	r8[0x0],r12
8000671a:	58 0c       	cp.w	r12,0
8000671c:	c0 a0       	breq	80006730 <spi_setupChipReg+0xcc>
8000671e:	30 09       	mov	r9,0
80006720:	12 9a       	mov	r10,r9
80006722:	12 9b       	mov	r11,r9
80006724:	f0 1f 00 09 	mcall	80006748 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006728:	48 68       	lddpc	r8,80006740 <spi_setupChipReg+0xdc>
8000672a:	70 08       	ld.w	r8,r8[0x0]
8000672c:	58 08       	cp.w	r8,0
8000672e:	c0 51       	brne	80006738 <spi_setupChipReg+0xd4>
80006730:	c0 08       	rjmp	80006730 <spi_setupChipReg+0xcc>
80006732:	30 2c       	mov	r12,2
80006734:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006738:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000673c:	80 00       	ld.sh	r0,r0[0x0]
8000673e:	65 9c       	ld.w	r12,r2[0x64]
80006740:	00 00       	add	r0,r0
80006742:	54 34       	stdsp	sp[0x10c],r4
80006744:	80 00       	ld.sh	r0,r0[0x0]
80006746:	72 88       	ld.w	r8,r9[0x20]
80006748:	80 00       	ld.sh	r0,r0[0x0]
8000674a:	71 30       	ld.w	r0,r8[0x4c]

8000674c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000674c:	d4 01       	pushm	lr
8000674e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006752:	c0 58       	rjmp	8000675c <spi_unselectChip+0x10>
		if (!timeout--) {
80006754:	58 08       	cp.w	r8,0
80006756:	c0 21       	brne	8000675a <spi_unselectChip+0xe>
80006758:	da 0a       	popm	pc,r12=1
8000675a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000675c:	78 49       	ld.w	r9,r12[0x10]
8000675e:	e2 19 02 00 	andl	r9,0x200,COH
80006762:	cf 90       	breq	80006754 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006764:	78 18       	ld.w	r8,r12[0x4]
80006766:	ea 18 00 0f 	orh	r8,0xf
8000676a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000676c:	fc 18 01 00 	movh	r8,0x100
80006770:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80006772:	30 09       	mov	r9,0
80006774:	12 9a       	mov	r10,r9
80006776:	12 9b       	mov	r11,r9
80006778:	48 38       	lddpc	r8,80006784 <spi_unselectChip+0x38>
8000677a:	70 0c       	ld.w	r12,r8[0x0]
8000677c:	f0 1f 00 03 	mcall	80006788 <spi_unselectChip+0x3c>
80006780:	d8 0a       	popm	pc,r12=0
80006782:	00 00       	add	r0,r0
80006784:	00 00       	add	r0,r0
80006786:	54 34       	stdsp	sp[0x10c],r4
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	71 30       	ld.w	r0,r8[0x4c]

8000678c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000678c:	eb cd 40 f8 	pushm	r3-r7,lr
80006790:	18 94       	mov	r4,r12
80006792:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006794:	49 a6       	lddpc	r6,800067fc <spi_selectChip+0x70>
80006796:	30 07       	mov	r7,0
80006798:	31 45       	mov	r5,20
8000679a:	0e 99       	mov	r9,r7
8000679c:	0a 9a       	mov	r10,r5
8000679e:	0e 9b       	mov	r11,r7
800067a0:	6c 0c       	ld.w	r12,r6[0x0]
800067a2:	f0 1f 00 18 	mcall	80006800 <spi_selectChip+0x74>
800067a6:	cf a0       	breq	8000679a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800067a8:	68 18       	ld.w	r8,r4[0x4]
800067aa:	ea 18 00 0f 	orh	r8,0xf
800067ae:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800067b0:	68 18       	ld.w	r8,r4[0x4]
800067b2:	e2 18 00 04 	andl	r8,0x4,COH
800067b6:	c1 10       	breq	800067d8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800067b8:	30 e8       	mov	r8,14
800067ba:	f0 03 18 00 	cp.b	r3,r8
800067be:	e0 8b 00 1c 	brhi	800067f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800067c2:	68 19       	ld.w	r9,r4[0x4]
800067c4:	e6 08 15 10 	lsl	r8,r3,0x10
800067c8:	ea 18 ff f0 	orh	r8,0xfff0
800067cc:	e8 18 ff ff 	orl	r8,0xffff
800067d0:	12 68       	and	r8,r9
800067d2:	89 18       	st.w	r4[0x4],r8
800067d4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800067d8:	30 38       	mov	r8,3
800067da:	f0 03 18 00 	cp.b	r3,r8
800067de:	e0 8b 00 0c 	brhi	800067f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800067e2:	68 19       	ld.w	r9,r4[0x4]
800067e4:	2f 03       	sub	r3,-16
800067e6:	30 18       	mov	r8,1
800067e8:	f0 03 09 48 	lsl	r8,r8,r3
800067ec:	5c d8       	com	r8
800067ee:	12 68       	and	r8,r9
800067f0:	89 18       	st.w	r4[0x4],r8
800067f2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800067f6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800067f8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800067fc:	00 00       	add	r0,r0
800067fe:	54 34       	stdsp	sp[0x10c],r4
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	6f 24       	ld.w	r4,r7[0x48]

80006804 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006804:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006806:	f6 08 15 04 	lsl	r8,r11,0x4
8000680a:	14 38       	cp.w	r8,r10
8000680c:	f9 b8 08 10 	movls	r8,16
80006810:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006814:	f0 0b 02 4b 	mul	r11,r8,r11
80006818:	f6 09 16 01 	lsr	r9,r11,0x1
8000681c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006820:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006824:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006828:	f2 cb 00 01 	sub	r11,r9,1
8000682c:	e0 4b ff fe 	cp.w	r11,65534
80006830:	e0 88 00 03 	brls	80006836 <usart_set_async_baudrate+0x32>
80006834:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006836:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006838:	e8 6e 00 00 	mov	lr,524288
8000683c:	59 08       	cp.w	r8,16
8000683e:	fc 08 17 10 	movne	r8,lr
80006842:	f9 b8 00 00 	moveq	r8,0
80006846:	e4 1b ff f7 	andh	r11,0xfff7
8000684a:	e0 1b fe cf 	andl	r11,0xfecf
8000684e:	16 48       	or	r8,r11
80006850:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006852:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006856:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000685a:	99 89       	st.w	r12[0x20],r9
8000685c:	d8 0a       	popm	pc,r12=0

8000685e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000685e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006860:	e2 18 00 02 	andl	r8,0x2,COH
80006864:	c0 31       	brne	8000686a <usart_write_char+0xc>
80006866:	30 2c       	mov	r12,2
80006868:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000686a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000686e:	99 7b       	st.w	r12[0x1c],r11
80006870:	5e fd       	retal	0
80006872:	d7 03       	nop

80006874 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006874:	eb cd 40 e0 	pushm	r5-r7,lr
80006878:	18 96       	mov	r6,r12
8000687a:	16 95       	mov	r5,r11
8000687c:	e0 67 27 0f 	mov	r7,9999
80006880:	c0 68       	rjmp	8000688c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006882:	58 07       	cp.w	r7,0
80006884:	c0 31       	brne	8000688a <usart_putchar+0x16>
80006886:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000688a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000688c:	0a 9b       	mov	r11,r5
8000688e:	0c 9c       	mov	r12,r6
80006890:	f0 1f 00 03 	mcall	8000689c <usart_putchar+0x28>
80006894:	cf 71       	brne	80006882 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006896:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000689a:	00 00       	add	r0,r0
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	68 5e       	ld.w	lr,r4[0x14]

800068a0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800068a0:	78 58       	ld.w	r8,r12[0x14]
800068a2:	e2 18 00 e0 	andl	r8,0xe0,COH
800068a6:	c0 30       	breq	800068ac <usart_read_char+0xc>
800068a8:	30 4c       	mov	r12,4
800068aa:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800068ac:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800068ae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068b2:	c0 31       	brne	800068b8 <usart_read_char+0x18>
800068b4:	30 3c       	mov	r12,3
800068b6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800068b8:	78 68       	ld.w	r8,r12[0x18]
800068ba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800068be:	97 08       	st.w	r11[0x0],r8
800068c0:	5e fd       	retal	0
800068c2:	d7 03       	nop

800068c4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800068c4:	eb cd 40 c0 	pushm	r6-r7,lr
800068c8:	20 1d       	sub	sp,4
800068ca:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800068cc:	1a 97       	mov	r7,sp
800068ce:	1a 9b       	mov	r11,sp
800068d0:	0c 9c       	mov	r12,r6
800068d2:	f0 1f 00 07 	mcall	800068ec <usart_getchar+0x28>
800068d6:	58 3c       	cp.w	r12,3
800068d8:	cf b0       	breq	800068ce <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800068da:	58 4c       	cp.w	r12,4
800068dc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800068e0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800068e4:	2f fd       	sub	sp,-4
800068e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068ea:	00 00       	add	r0,r0
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	68 a0       	ld.w	r0,r4[0x28]

800068f0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800068f0:	eb cd 40 c0 	pushm	r6-r7,lr
800068f4:	18 96       	mov	r6,r12
800068f6:	16 97       	mov	r7,r11
  while (*string != '\0')
800068f8:	17 8b       	ld.ub	r11,r11[0x0]
800068fa:	58 0b       	cp.w	r11,0
800068fc:	c0 80       	breq	8000690c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800068fe:	2f f7       	sub	r7,-1
80006900:	0c 9c       	mov	r12,r6
80006902:	f0 1f 00 04 	mcall	80006910 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006906:	0f 8b       	ld.ub	r11,r7[0x0]
80006908:	58 0b       	cp.w	r11,0
8000690a:	cf a1       	brne	800068fe <usart_write_line+0xe>
8000690c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006910:	80 00       	ld.sh	r0,r0[0x0]
80006912:	68 74       	ld.w	r4,r4[0x1c]

80006914 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006914:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006918:	e6 18 00 01 	andh	r8,0x1,COH
8000691c:	c0 71       	brne	8000692a <usart_reset+0x16>
8000691e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006920:	3f f8       	mov	r8,-1
80006922:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006924:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006926:	d5 03       	csrf	0x10
80006928:	c0 48       	rjmp	80006930 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000692a:	3f f8       	mov	r8,-1
8000692c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000692e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006930:	30 08       	mov	r8,0
80006932:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006934:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006936:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006938:	ea 68 61 0c 	mov	r8,680204
8000693c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000693e:	5e fc       	retal	r12

80006940 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006940:	eb cd 40 e0 	pushm	r5-r7,lr
80006944:	18 96       	mov	r6,r12
80006946:	16 97       	mov	r7,r11
80006948:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000694a:	f0 1f 00 2f 	mcall	80006a04 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000694e:	58 07       	cp.w	r7,0
80006950:	c5 80       	breq	80006a00 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006952:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006954:	30 49       	mov	r9,4
80006956:	f2 08 18 00 	cp.b	r8,r9
8000695a:	e0 88 00 53 	brls	80006a00 <usart_init_rs232+0xc0>
8000695e:	30 99       	mov	r9,9
80006960:	f2 08 18 00 	cp.b	r8,r9
80006964:	e0 8b 00 4e 	brhi	80006a00 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006968:	0f d9       	ld.ub	r9,r7[0x5]
8000696a:	30 78       	mov	r8,7
8000696c:	f0 09 18 00 	cp.b	r9,r8
80006970:	e0 8b 00 48 	brhi	80006a00 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006974:	8e 39       	ld.sh	r9,r7[0x6]
80006976:	e0 68 01 01 	mov	r8,257
8000697a:	f0 09 19 00 	cp.h	r9,r8
8000697e:	e0 8b 00 41 	brhi	80006a00 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006982:	ef 39 00 08 	ld.ub	r9,r7[8]
80006986:	30 38       	mov	r8,3
80006988:	f0 09 18 00 	cp.b	r9,r8
8000698c:	e0 8b 00 3a 	brhi	80006a00 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006990:	0a 9a       	mov	r10,r5
80006992:	6e 0b       	ld.w	r11,r7[0x0]
80006994:	0c 9c       	mov	r12,r6
80006996:	f0 1f 00 1d 	mcall	80006a08 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000699a:	58 1c       	cp.w	r12,1
8000699c:	c3 20       	breq	80006a00 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000699e:	0f c8       	ld.ub	r8,r7[0x4]
800069a0:	30 99       	mov	r9,9
800069a2:	f2 08 18 00 	cp.b	r8,r9
800069a6:	c0 51       	brne	800069b0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800069a8:	6c 18       	ld.w	r8,r6[0x4]
800069aa:	b1 b8       	sbr	r8,0x11
800069ac:	8d 18       	st.w	r6[0x4],r8
800069ae:	c0 68       	rjmp	800069ba <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800069b0:	6c 19       	ld.w	r9,r6[0x4]
800069b2:	20 58       	sub	r8,5
800069b4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800069b8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800069ba:	6c 19       	ld.w	r9,r6[0x4]
800069bc:	ef 3a 00 08 	ld.ub	r10,r7[8]
800069c0:	0f d8       	ld.ub	r8,r7[0x5]
800069c2:	a9 78       	lsl	r8,0x9
800069c4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800069c8:	12 48       	or	r8,r9
800069ca:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800069cc:	8e 38       	ld.sh	r8,r7[0x6]
800069ce:	30 29       	mov	r9,2
800069d0:	f2 08 19 00 	cp.h	r8,r9
800069d4:	e0 88 00 09 	brls	800069e6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800069d8:	6c 18       	ld.w	r8,r6[0x4]
800069da:	ad b8       	sbr	r8,0xd
800069dc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800069de:	8e b8       	ld.uh	r8,r7[0x6]
800069e0:	20 28       	sub	r8,2
800069e2:	8d a8       	st.w	r6[0x28],r8
800069e4:	c0 68       	rjmp	800069f0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800069e6:	6c 19       	ld.w	r9,r6[0x4]
800069e8:	5c 78       	castu.h	r8
800069ea:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800069ee:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800069f0:	6c 18       	ld.w	r8,r6[0x4]
800069f2:	e0 18 ff f0 	andl	r8,0xfff0
800069f6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800069f8:	35 08       	mov	r8,80
800069fa:	8d 08       	st.w	r6[0x0],r8
800069fc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006a00:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	69 14       	ld.w	r4,r4[0x44]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	68 04       	ld.w	r4,r4[0x0]

80006a0c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006a0c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006a10:	fe c0 8e 10 	sub	r0,pc,-29168

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006a14:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006a18:	d5 53       	csrf	0x15
  cp      r0, r1
80006a1a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006a1c:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006a20:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006a22:	c0 62       	brcc	80006a2e <idata_load_loop_end>
  cp      r0, r1
80006a24:	48 92       	lddpc	r2,80006a48 <udata_clear_loop_end+0x4>

80006a26 <idata_load_loop>:
  brlo    idata_load_loop
80006a26:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006a28:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006a2a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006a2c:	cf d3       	brcs	80006a26 <idata_load_loop>

80006a2e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006a2e:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006a32:	e0 61 54 48 	mov	r1,21576
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006a36:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006a38:	c0 62       	brcc	80006a44 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006a3a:	30 02       	mov	r2,0
80006a3c:	30 03       	mov	r3,0

80006a3e <udata_clear_loop>:
80006a3e:	a1 22       	st.d	r0++,r2
80006a40:	02 30       	cp.w	r0,r1
80006a42:	cf e3       	brcs	80006a3e <udata_clear_loop>

80006a44 <udata_clear_loop_end>:
80006a44:	fe cf e9 10 	sub	pc,pc,-5872
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	f3 90       	*unknown*

80006a4c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006a4c:	f8 c8 ff f8 	sub	r8,r12,-8
80006a50:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006a52:	3f f9       	mov	r9,-1
80006a54:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006a56:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006a58:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006a5a:	30 08       	mov	r8,0
80006a5c:	99 08       	st.w	r12[0x0],r8
}
80006a5e:	5e fc       	retal	r12

80006a60 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006a60:	30 08       	mov	r8,0
80006a62:	99 48       	st.w	r12[0x10],r8
}
80006a64:	5e fc       	retal	r12

80006a66 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006a66:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006a68:	70 19       	ld.w	r9,r8[0x4]
80006a6a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006a6c:	78 19       	ld.w	r9,r12[0x4]
80006a6e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006a70:	70 19       	ld.w	r9,r8[0x4]
80006a72:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006a74:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006a76:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006a78:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006a7a:	78 08       	ld.w	r8,r12[0x0]
80006a7c:	2f f8       	sub	r8,-1
80006a7e:	99 08       	st.w	r12[0x0],r8
}
80006a80:	5e fc       	retal	r12

80006a82 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006a82:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006a84:	5b fa       	cp.w	r10,-1
80006a86:	c0 31       	brne	80006a8c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006a88:	78 48       	ld.w	r8,r12[0x10]
80006a8a:	c0 c8       	rjmp	80006aa2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006a8c:	f8 c8 ff f8 	sub	r8,r12,-8
80006a90:	70 19       	ld.w	r9,r8[0x4]
80006a92:	72 09       	ld.w	r9,r9[0x0]
80006a94:	12 3a       	cp.w	r10,r9
80006a96:	c0 63       	brcs	80006aa2 <vListInsert+0x20>
80006a98:	70 18       	ld.w	r8,r8[0x4]
80006a9a:	70 19       	ld.w	r9,r8[0x4]
80006a9c:	72 09       	ld.w	r9,r9[0x0]
80006a9e:	12 3a       	cp.w	r10,r9
80006aa0:	cf c2       	brcc	80006a98 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006aa2:	70 19       	ld.w	r9,r8[0x4]
80006aa4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006aa6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006aa8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006aaa:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006aac:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006aae:	78 08       	ld.w	r8,r12[0x0]
80006ab0:	2f f8       	sub	r8,-1
80006ab2:	99 08       	st.w	r12[0x0],r8
}
80006ab4:	5e fc       	retal	r12

80006ab6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006ab6:	78 18       	ld.w	r8,r12[0x4]
80006ab8:	78 29       	ld.w	r9,r12[0x8]
80006aba:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006abc:	78 28       	ld.w	r8,r12[0x8]
80006abe:	78 19       	ld.w	r9,r12[0x4]
80006ac0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006ac2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006ac4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006ac6:	18 39       	cp.w	r9,r12
80006ac8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006acc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006ad0:	30 09       	mov	r9,0
80006ad2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006ad4:	70 09       	ld.w	r9,r8[0x0]
80006ad6:	20 19       	sub	r9,1
80006ad8:	91 09       	st.w	r8[0x0],r9
}
80006ada:	5e fc       	retal	r12

80006adc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006adc:	e0 68 08 08 	mov	r8,2056
80006ae0:	ea 18 08 08 	orh	r8,0x808
80006ae4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006ae6:	e0 68 09 09 	mov	r8,2313
80006aea:	ea 18 09 09 	orh	r8,0x909
80006aee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006af0:	e0 68 0a 0a 	mov	r8,2570
80006af4:	ea 18 0a 0a 	orh	r8,0xa0a
80006af8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006afa:	e0 68 0b 0b 	mov	r8,2827
80006afe:	ea 18 0b 0b 	orh	r8,0xb0b
80006b02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006b04:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006b06:	e0 68 be ef 	mov	r8,48879
80006b0a:	ea 18 de ad 	orh	r8,0xdead
80006b0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006b10:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006b12:	fc 18 00 40 	movh	r8,0x40
80006b16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006b18:	e0 68 00 ff 	mov	r8,255
80006b1c:	ea 18 ff 00 	orh	r8,0xff00
80006b20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006b22:	e0 68 01 01 	mov	r8,257
80006b26:	ea 18 01 01 	orh	r8,0x101
80006b2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006b2c:	e0 68 02 02 	mov	r8,514
80006b30:	ea 18 02 02 	orh	r8,0x202
80006b34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006b36:	e0 68 03 03 	mov	r8,771
80006b3a:	ea 18 03 03 	orh	r8,0x303
80006b3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006b40:	e0 68 04 04 	mov	r8,1028
80006b44:	ea 18 04 04 	orh	r8,0x404
80006b48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006b4a:	e0 68 05 05 	mov	r8,1285
80006b4e:	ea 18 05 05 	orh	r8,0x505
80006b52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006b54:	e0 68 06 06 	mov	r8,1542
80006b58:	ea 18 06 06 	orh	r8,0x606
80006b5c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006b5e:	e0 68 07 07 	mov	r8,1799
80006b62:	ea 18 07 07 	orh	r8,0x707
80006b66:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006b68:	30 08       	mov	r8,0
80006b6a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006b6c:	5e fc       	retal	r12
80006b6e:	d7 03       	nop

80006b70 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006b70:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006b72:	48 38       	lddpc	r8,80006b7c <vPortEnterCritical+0xc>
80006b74:	70 09       	ld.w	r9,r8[0x0]
80006b76:	2f f9       	sub	r9,-1
80006b78:	91 09       	st.w	r8[0x0],r9
}
80006b7a:	5e fc       	retal	r12
80006b7c:	00 00       	add	r0,r0
80006b7e:	05 48       	ld.w	r8,--r2

80006b80 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006b80:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006b82:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006b84:	30 0a       	mov	r10,0
80006b86:	14 9b       	mov	r11,r10
80006b88:	49 2c       	lddpc	r12,80006bd0 <xPortStartScheduler+0x50>
80006b8a:	f0 1f 00 13 	mcall	80006bd4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006b8e:	e0 68 5d c0 	mov	r8,24000
80006b92:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006b96:	30 08       	mov	r8,0
80006b98:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006b9c:	e0 68 0d 6c 	mov	r8,3436
80006ba0:	ea 18 00 00 	orh	r8,0x0
80006ba4:	70 00       	ld.w	r0,r8[0x0]
80006ba6:	60 0d       	ld.w	sp,r0[0x0]
80006ba8:	1b 00       	ld.w	r0,sp++
80006baa:	e0 68 05 48 	mov	r8,1352
80006bae:	ea 18 00 00 	orh	r8,0x0
80006bb2:	91 00       	st.w	r8[0x0],r0
80006bb4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006bb8:	2f ed       	sub	sp,-8
80006bba:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006bbe:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006bc2:	e3 b0 00 00 	mtsr	0x0,r0
80006bc6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006bca:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006bce:	d8 0a       	popm	pc,r12=0
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	6c 9c       	ld.w	r12,r6[0x24]
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	61 d0       	ld.w	r0,r0[0x74]

80006bd8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006bd8:	20 6d       	sub	sp,24
80006bda:	eb cd 00 ff 	pushm	r0-r7
80006bde:	fa c7 ff c0 	sub	r7,sp,-64
80006be2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006be6:	ef 40 ff e0 	st.w	r7[-32],r0
80006bea:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006bee:	ef 40 ff e4 	st.w	r7[-28],r0
80006bf2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006bf6:	e0 68 05 48 	mov	r8,1352
80006bfa:	ea 18 00 00 	orh	r8,0x0
80006bfe:	70 00       	ld.w	r0,r8[0x0]
80006c00:	1a d0       	st.w	--sp,r0
80006c02:	f0 1f 00 1a 	mcall	80006c68 <LABEL_RET_SCALL_263+0x14>
80006c06:	e0 68 0d 6c 	mov	r8,3436
80006c0a:	ea 18 00 00 	orh	r8,0x0
80006c0e:	70 00       	ld.w	r0,r8[0x0]
80006c10:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006c12:	f0 1f 00 17 	mcall	80006c6c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006c16:	e0 68 0d 6c 	mov	r8,3436
80006c1a:	ea 18 00 00 	orh	r8,0x0
80006c1e:	70 00       	ld.w	r0,r8[0x0]
80006c20:	60 0d       	ld.w	sp,r0[0x0]
80006c22:	1b 00       	ld.w	r0,sp++
80006c24:	e0 68 05 48 	mov	r8,1352
80006c28:	ea 18 00 00 	orh	r8,0x0
80006c2c:	91 00       	st.w	r8[0x0],r0
80006c2e:	fa c7 ff d8 	sub	r7,sp,-40
80006c32:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006c36:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006c3a:	e0 61 05 48 	mov	r1,1352
80006c3e:	ea 11 00 00 	orh	r1,0x0
80006c42:	62 02       	ld.w	r2,r1[0x0]
80006c44:	58 02       	cp.w	r2,0
80006c46:	c0 70       	breq	80006c54 <LABEL_RET_SCALL_263>
80006c48:	e4 c2 00 01 	sub	r2,r2,1
80006c4c:	83 02       	st.w	r1[0x0],r2
80006c4e:	58 02       	cp.w	r2,0
80006c50:	c0 21       	brne	80006c54 <LABEL_RET_SCALL_263>
80006c52:	b1 c0       	cbr	r0,0x10

80006c54 <LABEL_RET_SCALL_263>:
80006c54:	ef 40 ff f8 	st.w	r7[-8],r0
80006c58:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006c5c:	ef 40 ff fc 	st.w	r7[-4],r0
80006c60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006c64:	2f ad       	sub	sp,-24
80006c66:	d6 13       	rets
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	6b 70       	ld.w	r0,r5[0x5c]
80006c6c:	80 00       	ld.sh	r0,r0[0x0]
80006c6e:	73 24       	ld.w	r4,r9[0x48]

80006c70 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006c70:	e1 b8 00 43 	mfsr	r8,0x10c
80006c74:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006c78:	5e fc       	retal	r12
80006c7a:	d7 03       	nop

80006c7c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006c7c:	48 78       	lddpc	r8,80006c98 <vPortExitCritical+0x1c>
80006c7e:	70 08       	ld.w	r8,r8[0x0]
80006c80:	58 08       	cp.w	r8,0
80006c82:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006c84:	48 58       	lddpc	r8,80006c98 <vPortExitCritical+0x1c>
80006c86:	70 09       	ld.w	r9,r8[0x0]
80006c88:	20 19       	sub	r9,1
80006c8a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006c8c:	70 08       	ld.w	r8,r8[0x0]
80006c8e:	58 08       	cp.w	r8,0
80006c90:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006c92:	d5 03       	csrf	0x10
80006c94:	5e fc       	retal	r12
80006c96:	00 00       	add	r0,r0
80006c98:	00 00       	add	r0,r0
80006c9a:	05 48       	ld.w	r8,--r2

80006c9c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006c9c:	eb cd 00 ff 	pushm	r0-r7
80006ca0:	e0 68 05 48 	mov	r8,1352
80006ca4:	ea 18 00 00 	orh	r8,0x0
80006ca8:	70 00       	ld.w	r0,r8[0x0]
80006caa:	1a d0       	st.w	--sp,r0
80006cac:	7a 90       	ld.w	r0,sp[0x24]
80006cae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006cb2:	58 10       	cp.w	r0,1
80006cb4:	e0 8b 00 08 	brhi	80006cc4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006cb8:	e0 68 0d 6c 	mov	r8,3436
80006cbc:	ea 18 00 00 	orh	r8,0x0
80006cc0:	70 00       	ld.w	r0,r8[0x0]
80006cc2:	81 0d       	st.w	r0[0x0],sp

80006cc4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006cc4:	f0 1f 00 12 	mcall	80006d0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006cc8:	f0 1f 00 12 	mcall	80006d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006ccc:	f0 1f 00 12 	mcall	80006d14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006cd0:	f0 1f 00 12 	mcall	80006d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006cd4:	7a 90       	ld.w	r0,sp[0x24]
80006cd6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006cda:	58 10       	cp.w	r0,1
80006cdc:	e0 8b 00 0e 	brhi	80006cf8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006ce0:	f0 1f 00 0c 	mcall	80006d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006ce4:	f0 1f 00 0e 	mcall	80006d1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006ce8:	f0 1f 00 0c 	mcall	80006d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006cec:	e0 68 0d 6c 	mov	r8,3436
80006cf0:	ea 18 00 00 	orh	r8,0x0
80006cf4:	70 00       	ld.w	r0,r8[0x0]
80006cf6:	60 0d       	ld.w	sp,r0[0x0]

80006cf8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006cf8:	1b 00       	ld.w	r0,sp++
80006cfa:	e0 68 05 48 	mov	r8,1352
80006cfe:	ea 18 00 00 	orh	r8,0x0
80006d02:	91 00       	st.w	r8[0x0],r0
80006d04:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006d08:	d6 03       	rete
80006d0a:	00 00       	add	r0,r0
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	6c 70       	ld.w	r0,r6[0x1c]
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	6b 70       	ld.w	r0,r5[0x5c]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	75 28       	ld.w	r8,r10[0x48]
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	6c 7c       	ld.w	r12,r6[0x1c]
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	73 24       	ld.w	r4,r9[0x48]

80006d20 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006d20:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006d22:	f0 1f 00 02 	mcall	80006d28 <__malloc_lock+0x8>
}
80006d26:	d8 02       	popm	pc
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	73 14       	ld.w	r4,r9[0x44]

80006d2c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006d2c:	d4 01       	pushm	lr
	xTaskResumeAll();
80006d2e:	f0 1f 00 02 	mcall	80006d34 <__malloc_unlock+0x8>
}
80006d32:	d8 02       	popm	pc
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	76 d0       	ld.w	r0,r11[0x34]

80006d38 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006d38:	d4 21       	pushm	r4-r7,lr
80006d3a:	16 95       	mov	r5,r11
80006d3c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006d3e:	58 0c       	cp.w	r12,0
80006d40:	c0 30       	breq	80006d46 <_read+0xe>
80006d42:	3f f7       	mov	r7,-1
80006d44:	c1 48       	rjmp	80006d6c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006d46:	58 0a       	cp.w	r10,0
80006d48:	e0 89 00 04 	brgt	80006d50 <_read+0x18>
80006d4c:	30 07       	mov	r7,0
80006d4e:	c0 f8       	rjmp	80006d6c <_read+0x34>
80006d50:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006d52:	48 84       	lddpc	r4,80006d70 <_read+0x38>
80006d54:	68 0c       	ld.w	r12,r4[0x0]
80006d56:	f0 1f 00 08 	mcall	80006d74 <_read+0x3c>
    if (c < 0)
80006d5a:	c0 95       	brlt	80006d6c <_read+0x34>
      break;

    *ptr++ = c;
80006d5c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006d60:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006d62:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006d66:	58 08       	cp.w	r8,0
80006d68:	fe 99 ff f6 	brgt	80006d54 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006d6c:	0e 9c       	mov	r12,r7
80006d6e:	d8 22       	popm	r4-r7,pc
80006d70:	00 00       	add	r0,r0
80006d72:	54 38       	stdsp	sp[0x10c],r8
80006d74:	80 00       	ld.sh	r0,r0[0x0]
80006d76:	68 c4       	ld.w	r4,r4[0x30]

80006d78 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006d78:	d4 21       	pushm	r4-r7,lr
80006d7a:	16 95       	mov	r5,r11
80006d7c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006d7e:	20 1c       	sub	r12,1
80006d80:	58 2c       	cp.w	r12,2
80006d82:	e0 8b 00 12 	brhi	80006da6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006d86:	58 0a       	cp.w	r10,0
80006d88:	c0 31       	brne	80006d8e <_write+0x16>
80006d8a:	30 07       	mov	r7,0
80006d8c:	c0 e8       	rjmp	80006da8 <_write+0x30>
80006d8e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006d90:	48 74       	lddpc	r4,80006dac <_write+0x34>
80006d92:	68 0c       	ld.w	r12,r4[0x0]
80006d94:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006d98:	f0 1f 00 06 	mcall	80006db0 <_write+0x38>
80006d9c:	c0 55       	brlt	80006da6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006d9e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006da0:	0e 36       	cp.w	r6,r7
80006da2:	cf 81       	brne	80006d92 <_write+0x1a>
80006da4:	c0 28       	rjmp	80006da8 <_write+0x30>
80006da6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006da8:	0e 9c       	mov	r12,r7
80006daa:	d8 22       	popm	r4-r7,pc
80006dac:	00 00       	add	r0,r0
80006dae:	54 38       	stdsp	sp[0x10c],r8
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	68 74       	ld.w	r4,r4[0x1c]

80006db4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006db4:	eb cd 40 80 	pushm	r7,lr
80006db8:	18 97       	mov	r7,r12
	if( pv )
80006dba:	58 0c       	cp.w	r12,0
80006dbc:	c0 80       	breq	80006dcc <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006dbe:	f0 1f 00 05 	mcall	80006dd0 <vPortFree+0x1c>
		{
			free( pv );
80006dc2:	0e 9c       	mov	r12,r7
80006dc4:	f0 1f 00 04 	mcall	80006dd4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006dc8:	f0 1f 00 04 	mcall	80006dd8 <vPortFree+0x24>
80006dcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	73 14       	ld.w	r4,r9[0x44]
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	81 ac       	st.w	r0[0x28],r12
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	76 d0       	ld.w	r0,r11[0x34]

80006ddc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006ddc:	eb cd 40 80 	pushm	r7,lr
80006de0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006de2:	f0 1f 00 06 	mcall	80006df8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006de6:	0e 9c       	mov	r12,r7
80006de8:	f0 1f 00 05 	mcall	80006dfc <pvPortMalloc+0x20>
80006dec:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006dee:	f0 1f 00 05 	mcall	80006e00 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006df2:	0e 9c       	mov	r12,r7
80006df4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006df8:	80 00       	ld.sh	r0,r0[0x0]
80006dfa:	73 14       	ld.w	r4,r9[0x44]
80006dfc:	80 00       	ld.sh	r0,r0[0x0]
80006dfe:	81 bc       	st.w	r0[0x2c],r12
80006e00:	80 00       	ld.sh	r0,r0[0x0]
80006e02:	76 d0       	ld.w	r0,r11[0x34]

80006e04 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006e04:	d4 01       	pushm	lr
80006e06:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006e08:	78 09       	ld.w	r9,r12[0x0]
80006e0a:	58 09       	cp.w	r9,0
80006e0c:	c1 10       	breq	80006e2e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006e0e:	78 3a       	ld.w	r10,r12[0xc]
80006e10:	79 09       	ld.w	r9,r12[0x40]
80006e12:	f4 09 00 09 	add	r9,r10,r9
80006e16:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006e18:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006e1a:	14 39       	cp.w	r9,r10
80006e1c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006e20:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006e24:	79 0a       	ld.w	r10,r12[0x40]
80006e26:	78 3b       	ld.w	r11,r12[0xc]
80006e28:	10 9c       	mov	r12,r8
80006e2a:	f0 1f 00 02 	mcall	80006e30 <prvCopyDataFromQueue+0x2c>
80006e2e:	d8 02       	popm	pc
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	86 2a       	ld.sh	r10,r3[0x4]

80006e34 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006e34:	eb cd 40 c0 	pushm	r6-r7,lr
80006e38:	18 97       	mov	r7,r12
80006e3a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006e3c:	78 e8       	ld.w	r8,r12[0x38]
80006e3e:	58 08       	cp.w	r8,0
80006e40:	c0 31       	brne	80006e46 <xQueueReceiveFromISR+0x12>
80006e42:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006e46:	f0 1f 00 0e 	mcall	80006e7c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006e4a:	6e e8       	ld.w	r8,r7[0x38]
80006e4c:	20 18       	sub	r8,1
80006e4e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006e50:	6f 18       	ld.w	r8,r7[0x44]
80006e52:	5b f8       	cp.w	r8,-1
80006e54:	c0 d1       	brne	80006e6e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006e56:	6e 48       	ld.w	r8,r7[0x10]
80006e58:	58 08       	cp.w	r8,0
80006e5a:	c0 f0       	breq	80006e78 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006e5c:	ee cc ff f0 	sub	r12,r7,-16
80006e60:	f0 1f 00 08 	mcall	80006e80 <xQueueReceiveFromISR+0x4c>
80006e64:	c0 a0       	breq	80006e78 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006e66:	30 1c       	mov	r12,1
80006e68:	8d 0c       	st.w	r6[0x0],r12
80006e6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006e6e:	2f f8       	sub	r8,-1
80006e70:	ef 48 00 44 	st.w	r7[68],r8
80006e74:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006e78:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	6e 04       	ld.w	r4,r7[0x0]
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	74 ac       	ld.w	r12,r10[0x28]

80006e84 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006e84:	eb cd 40 c0 	pushm	r6-r7,lr
80006e88:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006e8a:	f0 1f 00 23 	mcall	80006f14 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006e8e:	6f 28       	ld.w	r8,r7[0x48]
80006e90:	58 08       	cp.w	r8,0
80006e92:	e0 8a 00 18 	brle	80006ec2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006e96:	6e 98       	ld.w	r8,r7[0x24]
80006e98:	58 08       	cp.w	r8,0
80006e9a:	c1 40       	breq	80006ec2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006e9c:	ee c6 ff dc 	sub	r6,r7,-36
80006ea0:	c0 48       	rjmp	80006ea8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006ea2:	6e 98       	ld.w	r8,r7[0x24]
80006ea4:	58 08       	cp.w	r8,0
80006ea6:	c0 e0       	breq	80006ec2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006ea8:	0c 9c       	mov	r12,r6
80006eaa:	f0 1f 00 1c 	mcall	80006f18 <prvUnlockQueue+0x94>
80006eae:	c0 30       	breq	80006eb4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006eb0:	f0 1f 00 1b 	mcall	80006f1c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006eb4:	6f 28       	ld.w	r8,r7[0x48]
80006eb6:	20 18       	sub	r8,1
80006eb8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006ebc:	58 08       	cp.w	r8,0
80006ebe:	fe 99 ff f2 	brgt	80006ea2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006ec2:	3f f8       	mov	r8,-1
80006ec4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006ec8:	f0 1f 00 16 	mcall	80006f20 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006ecc:	f0 1f 00 12 	mcall	80006f14 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006ed0:	6f 18       	ld.w	r8,r7[0x44]
80006ed2:	58 08       	cp.w	r8,0
80006ed4:	e0 8a 00 18 	brle	80006f04 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006ed8:	6e 48       	ld.w	r8,r7[0x10]
80006eda:	58 08       	cp.w	r8,0
80006edc:	c1 40       	breq	80006f04 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006ede:	ee c6 ff f0 	sub	r6,r7,-16
80006ee2:	c0 48       	rjmp	80006eea <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006ee4:	6e 48       	ld.w	r8,r7[0x10]
80006ee6:	58 08       	cp.w	r8,0
80006ee8:	c0 e0       	breq	80006f04 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006eea:	0c 9c       	mov	r12,r6
80006eec:	f0 1f 00 0b 	mcall	80006f18 <prvUnlockQueue+0x94>
80006ef0:	c0 30       	breq	80006ef6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006ef2:	f0 1f 00 0b 	mcall	80006f1c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006ef6:	6f 18       	ld.w	r8,r7[0x44]
80006ef8:	20 18       	sub	r8,1
80006efa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006efe:	58 08       	cp.w	r8,0
80006f00:	fe 99 ff f2 	brgt	80006ee4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006f04:	3f f8       	mov	r8,-1
80006f06:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006f0a:	f0 1f 00 06 	mcall	80006f20 <prvUnlockQueue+0x9c>
}
80006f0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f12:	00 00       	add	r0,r0
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	6b 70       	ld.w	r0,r5[0x5c]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	74 ac       	ld.w	r12,r10[0x28]
80006f1c:	80 00       	ld.sh	r0,r0[0x0]
80006f1e:	73 b8       	ld.w	r8,r9[0x6c]
80006f20:	80 00       	ld.sh	r0,r0[0x0]
80006f22:	6c 7c       	ld.w	r12,r6[0x1c]

80006f24 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006f24:	d4 31       	pushm	r0-r7,lr
80006f26:	20 5d       	sub	sp,20
80006f28:	18 97       	mov	r7,r12
80006f2a:	50 0b       	stdsp	sp[0x0],r11
80006f2c:	50 2a       	stdsp	sp[0x8],r10
80006f2e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006f30:	f8 c2 ff dc 	sub	r2,r12,-36
80006f34:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006f36:	fa c4 ff f4 	sub	r4,sp,-12
80006f3a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006f3c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006f3e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006f42:	f0 1f 00 3e 	mcall	80007038 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006f46:	6e e8       	ld.w	r8,r7[0x38]
80006f48:	58 08       	cp.w	r8,0
80006f4a:	c2 a0       	breq	80006f9e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006f4c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006f4e:	40 0b       	lddsp	r11,sp[0x0]
80006f50:	0e 9c       	mov	r12,r7
80006f52:	f0 1f 00 3b 	mcall	8000703c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006f56:	40 18       	lddsp	r8,sp[0x4]
80006f58:	58 08       	cp.w	r8,0
80006f5a:	c1 51       	brne	80006f84 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006f5c:	6e e8       	ld.w	r8,r7[0x38]
80006f5e:	20 18       	sub	r8,1
80006f60:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006f62:	6e 08       	ld.w	r8,r7[0x0]
80006f64:	58 08       	cp.w	r8,0
80006f66:	c0 41       	brne	80006f6e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006f68:	f0 1f 00 36 	mcall	80007040 <xQueueGenericReceive+0x11c>
80006f6c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006f6e:	6e 48       	ld.w	r8,r7[0x10]
80006f70:	58 08       	cp.w	r8,0
80006f72:	c1 20       	breq	80006f96 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006f74:	ee cc ff f0 	sub	r12,r7,-16
80006f78:	f0 1f 00 33 	mcall	80007044 <xQueueGenericReceive+0x120>
80006f7c:	58 1c       	cp.w	r12,1
80006f7e:	c0 c1       	brne	80006f96 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006f80:	d7 33       	scall
80006f82:	c0 a8       	rjmp	80006f96 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006f84:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006f86:	6e 98       	ld.w	r8,r7[0x24]
80006f88:	58 08       	cp.w	r8,0
80006f8a:	c0 60       	breq	80006f96 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006f8c:	04 9c       	mov	r12,r2
80006f8e:	f0 1f 00 2e 	mcall	80007044 <xQueueGenericReceive+0x120>
80006f92:	c0 20       	breq	80006f96 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006f94:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006f96:	f0 1f 00 2d 	mcall	80007048 <xQueueGenericReceive+0x124>
80006f9a:	30 1c       	mov	r12,1
				return pdPASS;
80006f9c:	c4 c8       	rjmp	80007034 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006f9e:	40 28       	lddsp	r8,sp[0x8]
80006fa0:	58 08       	cp.w	r8,0
80006fa2:	c0 51       	brne	80006fac <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006fa4:	f0 1f 00 29 	mcall	80007048 <xQueueGenericReceive+0x124>
80006fa8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006faa:	c4 58       	rjmp	80007034 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006fac:	58 05       	cp.w	r5,0
80006fae:	c0 51       	brne	80006fb8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006fb0:	08 9c       	mov	r12,r4
80006fb2:	f0 1f 00 27 	mcall	8000704c <xQueueGenericReceive+0x128>
80006fb6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006fb8:	f0 1f 00 24 	mcall	80007048 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006fbc:	f0 1f 00 25 	mcall	80007050 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006fc0:	f0 1f 00 1e 	mcall	80007038 <xQueueGenericReceive+0x114>
80006fc4:	6f 18       	ld.w	r8,r7[0x44]
80006fc6:	5b f8       	cp.w	r8,-1
80006fc8:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006fcc:	6f 28       	ld.w	r8,r7[0x48]
80006fce:	5b f8       	cp.w	r8,-1
80006fd0:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006fd4:	f0 1f 00 1d 	mcall	80007048 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006fd8:	06 9b       	mov	r11,r3
80006fda:	08 9c       	mov	r12,r4
80006fdc:	f0 1f 00 1e 	mcall	80007054 <xQueueGenericReceive+0x130>
80006fe0:	c2 41       	brne	80007028 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006fe2:	f0 1f 00 16 	mcall	80007038 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006fe6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006fe8:	f0 1f 00 18 	mcall	80007048 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006fec:	58 06       	cp.w	r6,0
80006fee:	c1 71       	brne	8000701c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006ff0:	6e 08       	ld.w	r8,r7[0x0]
80006ff2:	58 08       	cp.w	r8,0
80006ff4:	c0 81       	brne	80007004 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006ff6:	f0 1f 00 11 	mcall	80007038 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006ffa:	6e 1c       	ld.w	r12,r7[0x4]
80006ffc:	f0 1f 00 17 	mcall	80007058 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80007000:	f0 1f 00 12 	mcall	80007048 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007004:	40 2b       	lddsp	r11,sp[0x8]
80007006:	04 9c       	mov	r12,r2
80007008:	f0 1f 00 15 	mcall	8000705c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000700c:	0e 9c       	mov	r12,r7
8000700e:	f0 1f 00 15 	mcall	80007060 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80007012:	f0 1f 00 15 	mcall	80007064 <xQueueGenericReceive+0x140>
80007016:	c9 61       	brne	80006f42 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007018:	d7 33       	scall
8000701a:	c9 4b       	rjmp	80006f42 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000701c:	0e 9c       	mov	r12,r7
8000701e:	f0 1f 00 11 	mcall	80007060 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80007022:	f0 1f 00 11 	mcall	80007064 <xQueueGenericReceive+0x140>
80007026:	c8 eb       	rjmp	80006f42 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007028:	0e 9c       	mov	r12,r7
8000702a:	f0 1f 00 0e 	mcall	80007060 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000702e:	f0 1f 00 0e 	mcall	80007064 <xQueueGenericReceive+0x140>
80007032:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80007034:	2f bd       	sub	sp,-20
80007036:	d8 32       	popm	r0-r7,pc
80007038:	80 00       	ld.sh	r0,r0[0x0]
8000703a:	6b 70       	ld.w	r0,r5[0x5c]
8000703c:	80 00       	ld.sh	r0,r0[0x0]
8000703e:	6e 04       	ld.w	r4,r7[0x0]
80007040:	80 00       	ld.sh	r0,r0[0x0]
80007042:	73 c4       	ld.w	r4,r9[0x70]
80007044:	80 00       	ld.sh	r0,r0[0x0]
80007046:	74 ac       	ld.w	r12,r10[0x28]
80007048:	80 00       	ld.sh	r0,r0[0x0]
8000704a:	6c 7c       	ld.w	r12,r6[0x1c]
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	73 a0       	ld.w	r0,r9[0x68]
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	73 14       	ld.w	r4,r9[0x44]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	76 3c       	ld.w	r12,r11[0xc]
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	74 28       	ld.w	r8,r10[0x8]
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	78 dc       	ld.w	r12,r12[0x34]
80007060:	80 00       	ld.sh	r0,r0[0x0]
80007062:	6e 84       	ld.w	r4,r7[0x20]
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	76 d0       	ld.w	r0,r11[0x34]

80007068 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80007068:	eb cd 40 80 	pushm	r7,lr
8000706c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000706e:	79 08       	ld.w	r8,r12[0x40]
80007070:	58 08       	cp.w	r8,0
80007072:	c0 a1       	brne	80007086 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007074:	78 08       	ld.w	r8,r12[0x0]
80007076:	58 08       	cp.w	r8,0
80007078:	c2 b1       	brne	800070ce <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000707a:	78 1c       	ld.w	r12,r12[0x4]
8000707c:	f0 1f 00 17 	mcall	800070d8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80007080:	30 08       	mov	r8,0
80007082:	8f 18       	st.w	r7[0x4],r8
80007084:	c2 58       	rjmp	800070ce <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80007086:	58 0a       	cp.w	r10,0
80007088:	c1 01       	brne	800070a8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000708a:	10 9a       	mov	r10,r8
8000708c:	78 2c       	ld.w	r12,r12[0x8]
8000708e:	f0 1f 00 14 	mcall	800070dc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80007092:	6e 29       	ld.w	r9,r7[0x8]
80007094:	6f 08       	ld.w	r8,r7[0x40]
80007096:	f2 08 00 08 	add	r8,r9,r8
8000709a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000709c:	6e 19       	ld.w	r9,r7[0x4]
8000709e:	12 38       	cp.w	r8,r9
800070a0:	c1 73       	brcs	800070ce <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800070a2:	6e 08       	ld.w	r8,r7[0x0]
800070a4:	8f 28       	st.w	r7[0x8],r8
800070a6:	c1 48       	rjmp	800070ce <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800070a8:	10 9a       	mov	r10,r8
800070aa:	78 3c       	ld.w	r12,r12[0xc]
800070ac:	f0 1f 00 0c 	mcall	800070dc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800070b0:	6f 08       	ld.w	r8,r7[0x40]
800070b2:	6e 39       	ld.w	r9,r7[0xc]
800070b4:	f2 08 01 08 	sub	r8,r9,r8
800070b8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800070ba:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800070bc:	12 38       	cp.w	r8,r9
800070be:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800070c2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800070c6:	f3 d8 e3 19 	subcs	r9,r9,r8
800070ca:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800070ce:	6e e8       	ld.w	r8,r7[0x38]
800070d0:	2f f8       	sub	r8,-1
800070d2:	8f e8       	st.w	r7[0x38],r8
}
800070d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	73 d0       	ld.w	r0,r9[0x74]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	86 2a       	ld.sh	r10,r3[0x4]

800070e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800070e0:	eb cd 40 c0 	pushm	r6-r7,lr
800070e4:	18 97       	mov	r7,r12
800070e6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800070e8:	78 ec       	ld.w	r12,r12[0x38]
800070ea:	6e f8       	ld.w	r8,r7[0x3c]
800070ec:	10 3c       	cp.w	r12,r8
800070ee:	c0 33       	brcs	800070f4 <xQueueGenericSendFromISR+0x14>
800070f0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800070f4:	12 9a       	mov	r10,r9
800070f6:	0e 9c       	mov	r12,r7
800070f8:	f0 1f 00 0c 	mcall	80007128 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800070fc:	6f 28       	ld.w	r8,r7[0x48]
800070fe:	5b f8       	cp.w	r8,-1
80007100:	c0 d1       	brne	8000711a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007102:	6e 98       	ld.w	r8,r7[0x24]
80007104:	58 08       	cp.w	r8,0
80007106:	c0 f0       	breq	80007124 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007108:	ee cc ff dc 	sub	r12,r7,-36
8000710c:	f0 1f 00 08 	mcall	8000712c <xQueueGenericSendFromISR+0x4c>
80007110:	c0 a0       	breq	80007124 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80007112:	30 1c       	mov	r12,1
80007114:	8d 0c       	st.w	r6[0x0],r12
80007116:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000711a:	2f f8       	sub	r8,-1
8000711c:	ef 48 00 48 	st.w	r7[72],r8
80007120:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007124:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	70 68       	ld.w	r8,r8[0x18]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	74 ac       	ld.w	r12,r10[0x28]

80007130 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80007130:	d4 31       	pushm	r0-r7,lr
80007132:	20 5d       	sub	sp,20
80007134:	18 97       	mov	r7,r12
80007136:	50 0b       	stdsp	sp[0x0],r11
80007138:	50 2a       	stdsp	sp[0x8],r10
8000713a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000713c:	f8 c0 ff f0 	sub	r0,r12,-16
80007140:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007142:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007146:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007148:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000714c:	f0 1f 00 2f 	mcall	80007208 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80007150:	6e e9       	ld.w	r9,r7[0x38]
80007152:	6e f8       	ld.w	r8,r7[0x3c]
80007154:	10 39       	cp.w	r9,r8
80007156:	c1 42       	brcc	8000717e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007158:	40 1a       	lddsp	r10,sp[0x4]
8000715a:	40 0b       	lddsp	r11,sp[0x0]
8000715c:	0e 9c       	mov	r12,r7
8000715e:	f0 1f 00 2c 	mcall	8000720c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007162:	6e 98       	ld.w	r8,r7[0x24]
80007164:	58 08       	cp.w	r8,0
80007166:	c0 80       	breq	80007176 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80007168:	ee cc ff dc 	sub	r12,r7,-36
8000716c:	f0 1f 00 29 	mcall	80007210 <xQueueGenericSend+0xe0>
80007170:	58 1c       	cp.w	r12,1
80007172:	c0 21       	brne	80007176 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80007174:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80007176:	f0 1f 00 28 	mcall	80007214 <xQueueGenericSend+0xe4>
8000717a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000717c:	c4 38       	rjmp	80007202 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000717e:	40 28       	lddsp	r8,sp[0x8]
80007180:	58 08       	cp.w	r8,0
80007182:	c0 51       	brne	8000718c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007184:	f0 1f 00 24 	mcall	80007214 <xQueueGenericSend+0xe4>
80007188:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000718a:	c3 c8       	rjmp	80007202 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000718c:	58 04       	cp.w	r4,0
8000718e:	c0 51       	brne	80007198 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007190:	06 9c       	mov	r12,r3
80007192:	f0 1f 00 22 	mcall	80007218 <xQueueGenericSend+0xe8>
80007196:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007198:	f0 1f 00 1f 	mcall	80007214 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000719c:	f0 1f 00 20 	mcall	8000721c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800071a0:	f0 1f 00 1a 	mcall	80007208 <xQueueGenericSend+0xd8>
800071a4:	6f 18       	ld.w	r8,r7[0x44]
800071a6:	5b f8       	cp.w	r8,-1
800071a8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800071ac:	6f 28       	ld.w	r8,r7[0x48]
800071ae:	5b f8       	cp.w	r8,-1
800071b0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800071b4:	f0 1f 00 18 	mcall	80007214 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071b8:	04 9b       	mov	r11,r2
800071ba:	06 9c       	mov	r12,r3
800071bc:	f0 1f 00 19 	mcall	80007220 <xQueueGenericSend+0xf0>
800071c0:	c1 b1       	brne	800071f6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800071c2:	f0 1f 00 12 	mcall	80007208 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800071c6:	6e e5       	ld.w	r5,r7[0x38]
800071c8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800071ca:	f0 1f 00 13 	mcall	80007214 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800071ce:	0c 35       	cp.w	r5,r6
800071d0:	c0 d1       	brne	800071ea <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800071d2:	40 2b       	lddsp	r11,sp[0x8]
800071d4:	00 9c       	mov	r12,r0
800071d6:	f0 1f 00 14 	mcall	80007224 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800071da:	0e 9c       	mov	r12,r7
800071dc:	f0 1f 00 13 	mcall	80007228 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800071e0:	f0 1f 00 13 	mcall	8000722c <xQueueGenericSend+0xfc>
800071e4:	cb 41       	brne	8000714c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800071e6:	d7 33       	scall
800071e8:	cb 2b       	rjmp	8000714c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800071ea:	0e 9c       	mov	r12,r7
800071ec:	f0 1f 00 0f 	mcall	80007228 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800071f0:	f0 1f 00 0f 	mcall	8000722c <xQueueGenericSend+0xfc>
800071f4:	ca cb       	rjmp	8000714c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800071f6:	0e 9c       	mov	r12,r7
800071f8:	f0 1f 00 0c 	mcall	80007228 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800071fc:	f0 1f 00 0c 	mcall	8000722c <xQueueGenericSend+0xfc>
80007200:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80007202:	2f bd       	sub	sp,-20
80007204:	d8 32       	popm	r0-r7,pc
80007206:	00 00       	add	r0,r0
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	6b 70       	ld.w	r0,r5[0x5c]
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	70 68       	ld.w	r8,r8[0x18]
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	74 ac       	ld.w	r12,r10[0x28]
80007214:	80 00       	ld.sh	r0,r0[0x0]
80007216:	6c 7c       	ld.w	r12,r6[0x1c]
80007218:	80 00       	ld.sh	r0,r0[0x0]
8000721a:	73 a0       	ld.w	r0,r9[0x68]
8000721c:	80 00       	ld.sh	r0,r0[0x0]
8000721e:	73 14       	ld.w	r4,r9[0x44]
80007220:	80 00       	ld.sh	r0,r0[0x0]
80007222:	76 3c       	ld.w	r12,r11[0xc]
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	78 dc       	ld.w	r12,r12[0x34]
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	6e 84       	ld.w	r4,r7[0x20]
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	76 d0       	ld.w	r0,r11[0x34]

80007230 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80007230:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007234:	34 cc       	mov	r12,76
80007236:	f0 1f 00 12 	mcall	8000727c <xQueueCreateMutex+0x4c>
8000723a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000723c:	c1 d0       	breq	80007276 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000723e:	30 06       	mov	r6,0
80007240:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80007242:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80007244:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80007246:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80007248:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000724a:	30 18       	mov	r8,1
8000724c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000724e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80007252:	3f f8       	mov	r8,-1
80007254:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80007258:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000725c:	2f 0c       	sub	r12,-16
8000725e:	f0 1f 00 09 	mcall	80007280 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80007262:	ee cc ff dc 	sub	r12,r7,-36
80007266:	f0 1f 00 07 	mcall	80007280 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000726a:	0c 99       	mov	r9,r6
8000726c:	0c 9a       	mov	r10,r6
8000726e:	0c 9b       	mov	r11,r6
80007270:	0e 9c       	mov	r12,r7
80007272:	f0 1f 00 05 	mcall	80007284 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80007276:	0e 9c       	mov	r12,r7
80007278:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	6d dc       	ld.w	r12,r6[0x74]
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	6a 4c       	ld.w	r12,r5[0x10]
80007284:	80 00       	ld.sh	r0,r0[0x0]
80007286:	71 30       	ld.w	r0,r8[0x4c]

80007288 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80007288:	d4 21       	pushm	r4-r7,lr
8000728a:	18 97       	mov	r7,r12
8000728c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000728e:	58 0c       	cp.w	r12,0
80007290:	c2 f0       	breq	800072ee <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007292:	34 cc       	mov	r12,76
80007294:	f0 1f 00 17 	mcall	800072f0 <xQueueCreate+0x68>
80007298:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000729a:	c2 a0       	breq	800072ee <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000729c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800072a0:	e8 cc ff ff 	sub	r12,r4,-1
800072a4:	f0 1f 00 13 	mcall	800072f0 <xQueueCreate+0x68>
800072a8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800072aa:	c1 e0       	breq	800072e6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800072ac:	f8 04 00 04 	add	r4,r12,r4
800072b0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800072b2:	30 08       	mov	r8,0
800072b4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800072b6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800072b8:	ee c8 00 01 	sub	r8,r7,1
800072bc:	ad 38       	mul	r8,r6
800072be:	10 0c       	add	r12,r8
800072c0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800072c2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800072c4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800072c8:	3f f8       	mov	r8,-1
800072ca:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800072ce:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800072d2:	ea cc ff f0 	sub	r12,r5,-16
800072d6:	f0 1f 00 08 	mcall	800072f4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800072da:	ea cc ff dc 	sub	r12,r5,-36
800072de:	f0 1f 00 06 	mcall	800072f4 <xQueueCreate+0x6c>
800072e2:	0a 9c       	mov	r12,r5
800072e4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800072e6:	0a 9c       	mov	r12,r5
800072e8:	f0 1f 00 04 	mcall	800072f8 <xQueueCreate+0x70>
800072ec:	d8 2a       	popm	r4-r7,pc,r12=0
800072ee:	d8 2a       	popm	r4-r7,pc,r12=0
800072f0:	80 00       	ld.sh	r0,r0[0x0]
800072f2:	6d dc       	ld.w	r12,r6[0x74]
800072f4:	80 00       	ld.sh	r0,r0[0x0]
800072f6:	6a 4c       	ld.w	r12,r5[0x10]
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	6d b4       	ld.w	r4,r6[0x6c]

800072fc <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
800072fc:	eb cd 40 80 	pushm	r7,lr
80007300:	16 97       	mov	r7,r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
80007302:	30 0b       	mov	r11,0
80007304:	f0 1f 00 03 	mcall	80007310 <xQueueCreateCountingSemaphore+0x14>

		if( pxHandle != NULL )
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
80007308:	f9 f7 1a 0e 	st.wne	r12[0x38],r7
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
8000730c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007310:	80 00       	ld.sh	r0,r0[0x0]
80007312:	72 88       	ld.w	r8,r9[0x20]

80007314 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80007314:	48 38       	lddpc	r8,80007320 <vTaskSuspendAll+0xc>
80007316:	70 09       	ld.w	r9,r8[0x0]
80007318:	2f f9       	sub	r9,-1
8000731a:	91 09       	st.w	r8[0x0],r9
}
8000731c:	5e fc       	retal	r12
8000731e:	00 00       	add	r0,r0
80007320:	00 00       	add	r0,r0
80007322:	0d 9c       	ld.ub	r12,r6[0x1]

80007324 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80007324:	49 a8       	lddpc	r8,8000738c <vTaskSwitchContext+0x68>
80007326:	70 08       	ld.w	r8,r8[0x0]
80007328:	58 08       	cp.w	r8,0
8000732a:	c0 b1       	brne	80007340 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000732c:	49 98       	lddpc	r8,80007390 <vTaskSwitchContext+0x6c>
8000732e:	70 08       	ld.w	r8,r8[0x0]
80007330:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007334:	49 89       	lddpc	r9,80007394 <vTaskSwitchContext+0x70>
80007336:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000733a:	58 08       	cp.w	r8,0
8000733c:	c0 60       	breq	80007348 <vTaskSwitchContext+0x24>
8000733e:	c1 18       	rjmp	80007360 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80007340:	30 19       	mov	r9,1
80007342:	49 68       	lddpc	r8,80007398 <vTaskSwitchContext+0x74>
80007344:	91 09       	st.w	r8[0x0],r9
80007346:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007348:	49 28       	lddpc	r8,80007390 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000734a:	49 3a       	lddpc	r10,80007394 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000734c:	70 09       	ld.w	r9,r8[0x0]
8000734e:	20 19       	sub	r9,1
80007350:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007352:	70 09       	ld.w	r9,r8[0x0]
80007354:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007358:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000735c:	58 09       	cp.w	r9,0
8000735e:	cf 70       	breq	8000734c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80007360:	48 c8       	lddpc	r8,80007390 <vTaskSwitchContext+0x6c>
80007362:	70 08       	ld.w	r8,r8[0x0]
80007364:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007368:	48 b9       	lddpc	r9,80007394 <vTaskSwitchContext+0x70>
8000736a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000736e:	70 19       	ld.w	r9,r8[0x4]
80007370:	72 19       	ld.w	r9,r9[0x4]
80007372:	91 19       	st.w	r8[0x4],r9
80007374:	f0 ca ff f8 	sub	r10,r8,-8
80007378:	14 39       	cp.w	r9,r10
8000737a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000737e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80007382:	70 18       	ld.w	r8,r8[0x4]
80007384:	70 39       	ld.w	r9,r8[0xc]
80007386:	48 68       	lddpc	r8,8000739c <vTaskSwitchContext+0x78>
80007388:	91 09       	st.w	r8[0x0],r9
8000738a:	5e fc       	retal	r12
8000738c:	00 00       	add	r0,r0
8000738e:	0d 9c       	ld.ub	r12,r6[0x1]
80007390:	00 00       	add	r0,r0
80007392:	0d d4       	ld.ub	r4,r6[0x5]
80007394:	00 00       	add	r0,r0
80007396:	0c b8       	st.h	r6++,r8
80007398:	00 00       	add	r0,r0
8000739a:	0d bc       	ld.ub	r12,r6[0x3]
8000739c:	00 00       	add	r0,r0
8000739e:	0d 6c       	ld.uh	r12,--r6

800073a0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800073a0:	48 48       	lddpc	r8,800073b0 <vTaskSetTimeOutState+0x10>
800073a2:	70 08       	ld.w	r8,r8[0x0]
800073a4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800073a6:	48 48       	lddpc	r8,800073b4 <vTaskSetTimeOutState+0x14>
800073a8:	70 08       	ld.w	r8,r8[0x0]
800073aa:	99 18       	st.w	r12[0x4],r8
}
800073ac:	5e fc       	retal	r12
800073ae:	00 00       	add	r0,r0
800073b0:	00 00       	add	r0,r0
800073b2:	0c b0       	st.h	r6++,r0
800073b4:	00 00       	add	r0,r0
800073b6:	0d 98       	ld.ub	r8,r6[0x1]

800073b8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800073b8:	30 19       	mov	r9,1
800073ba:	48 28       	lddpc	r8,800073c0 <vTaskMissedYield+0x8>
800073bc:	91 09       	st.w	r8[0x0],r9
}
800073be:	5e fc       	retal	r12
800073c0:	00 00       	add	r0,r0
800073c2:	0d bc       	ld.ub	r12,r6[0x3]

800073c4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800073c4:	48 28       	lddpc	r8,800073cc <xTaskGetCurrentTaskHandle+0x8>
800073c6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800073c8:	5e fc       	retal	r12
800073ca:	00 00       	add	r0,r0
800073cc:	00 00       	add	r0,r0
800073ce:	0d 6c       	ld.uh	r12,--r6

800073d0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800073d0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800073d4:	58 0c       	cp.w	r12,0
800073d6:	c1 f0       	breq	80007414 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800073d8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800073da:	78 b9       	ld.w	r9,r12[0x2c]
800073dc:	79 18       	ld.w	r8,r12[0x44]
800073de:	10 39       	cp.w	r9,r8
800073e0:	c1 a0       	breq	80007414 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800073e2:	f8 c6 ff fc 	sub	r6,r12,-4
800073e6:	0c 9c       	mov	r12,r6
800073e8:	f0 1f 00 0c 	mcall	80007418 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800073ec:	6f 1c       	ld.w	r12,r7[0x44]
800073ee:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800073f0:	f8 08 11 08 	rsub	r8,r12,8
800073f4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800073f6:	48 a8       	lddpc	r8,8000741c <vTaskPriorityDisinherit+0x4c>
800073f8:	70 08       	ld.w	r8,r8[0x0]
800073fa:	10 3c       	cp.w	r12,r8
800073fc:	e0 88 00 04 	brls	80007404 <vTaskPriorityDisinherit+0x34>
80007400:	48 78       	lddpc	r8,8000741c <vTaskPriorityDisinherit+0x4c>
80007402:	91 0c       	st.w	r8[0x0],r12
80007404:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007408:	0c 9b       	mov	r11,r6
8000740a:	48 68       	lddpc	r8,80007420 <vTaskPriorityDisinherit+0x50>
8000740c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007410:	f0 1f 00 05 	mcall	80007424 <vTaskPriorityDisinherit+0x54>
80007414:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	6a b6       	ld.w	r6,r5[0x2c]
8000741c:	00 00       	add	r0,r0
8000741e:	0d d4       	ld.ub	r4,r6[0x5]
80007420:	00 00       	add	r0,r0
80007422:	0c b8       	st.h	r6++,r8
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	6a 66       	ld.w	r6,r5[0x18]

80007428 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80007428:	eb cd 40 c0 	pushm	r6-r7,lr
8000742c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000742e:	49 b8       	lddpc	r8,80007498 <vTaskPriorityInherit+0x70>
80007430:	70 08       	ld.w	r8,r8[0x0]
80007432:	78 b9       	ld.w	r9,r12[0x2c]
80007434:	70 b8       	ld.w	r8,r8[0x2c]
80007436:	10 39       	cp.w	r9,r8
80007438:	c2 d2       	brcc	80007492 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000743a:	49 88       	lddpc	r8,80007498 <vTaskPriorityInherit+0x70>
8000743c:	70 08       	ld.w	r8,r8[0x0]
8000743e:	70 b8       	ld.w	r8,r8[0x2c]
80007440:	f0 08 11 08 	rsub	r8,r8,8
80007444:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80007446:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000744a:	49 59       	lddpc	r9,8000749c <vTaskPriorityInherit+0x74>
8000744c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007450:	78 59       	ld.w	r9,r12[0x14]
80007452:	10 39       	cp.w	r9,r8
80007454:	c1 b1       	brne	8000748a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80007456:	f8 c6 ff fc 	sub	r6,r12,-4
8000745a:	0c 9c       	mov	r12,r6
8000745c:	f0 1f 00 11 	mcall	800074a0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007460:	48 e8       	lddpc	r8,80007498 <vTaskPriorityInherit+0x70>
80007462:	70 08       	ld.w	r8,r8[0x0]
80007464:	70 bc       	ld.w	r12,r8[0x2c]
80007466:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80007468:	48 f8       	lddpc	r8,800074a4 <vTaskPriorityInherit+0x7c>
8000746a:	70 08       	ld.w	r8,r8[0x0]
8000746c:	10 3c       	cp.w	r12,r8
8000746e:	e0 88 00 04 	brls	80007476 <vTaskPriorityInherit+0x4e>
80007472:	48 d8       	lddpc	r8,800074a4 <vTaskPriorityInherit+0x7c>
80007474:	91 0c       	st.w	r8[0x0],r12
80007476:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000747a:	0c 9b       	mov	r11,r6
8000747c:	48 88       	lddpc	r8,8000749c <vTaskPriorityInherit+0x74>
8000747e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007482:	f0 1f 00 0a 	mcall	800074a8 <vTaskPriorityInherit+0x80>
80007486:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000748a:	48 48       	lddpc	r8,80007498 <vTaskPriorityInherit+0x70>
8000748c:	70 08       	ld.w	r8,r8[0x0]
8000748e:	70 b8       	ld.w	r8,r8[0x2c]
80007490:	99 b8       	st.w	r12[0x2c],r8
80007492:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007496:	00 00       	add	r0,r0
80007498:	00 00       	add	r0,r0
8000749a:	0d 6c       	ld.uh	r12,--r6
8000749c:	00 00       	add	r0,r0
8000749e:	0c b8       	st.h	r6++,r8
800074a0:	80 00       	ld.sh	r0,r0[0x0]
800074a2:	6a b6       	ld.w	r6,r5[0x2c]
800074a4:	00 00       	add	r0,r0
800074a6:	0d d4       	ld.ub	r4,r6[0x5]
800074a8:	80 00       	ld.sh	r0,r0[0x0]
800074aa:	6a 66       	ld.w	r6,r5[0x18]

800074ac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800074ac:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800074b0:	78 38       	ld.w	r8,r12[0xc]
800074b2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800074b4:	ee c6 ff e8 	sub	r6,r7,-24
800074b8:	0c 9c       	mov	r12,r6
800074ba:	f0 1f 00 15 	mcall	8000750c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800074be:	49 58       	lddpc	r8,80007510 <xTaskRemoveFromEventList+0x64>
800074c0:	70 08       	ld.w	r8,r8[0x0]
800074c2:	58 08       	cp.w	r8,0
800074c4:	c1 71       	brne	800074f2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800074c6:	ee c6 ff fc 	sub	r6,r7,-4
800074ca:	0c 9c       	mov	r12,r6
800074cc:	f0 1f 00 10 	mcall	8000750c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800074d0:	6e bc       	ld.w	r12,r7[0x2c]
800074d2:	49 18       	lddpc	r8,80007514 <xTaskRemoveFromEventList+0x68>
800074d4:	70 08       	ld.w	r8,r8[0x0]
800074d6:	10 3c       	cp.w	r12,r8
800074d8:	e0 88 00 04 	brls	800074e0 <xTaskRemoveFromEventList+0x34>
800074dc:	48 e8       	lddpc	r8,80007514 <xTaskRemoveFromEventList+0x68>
800074de:	91 0c       	st.w	r8[0x0],r12
800074e0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800074e4:	0c 9b       	mov	r11,r6
800074e6:	48 d8       	lddpc	r8,80007518 <xTaskRemoveFromEventList+0x6c>
800074e8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800074ec:	f0 1f 00 0c 	mcall	8000751c <xTaskRemoveFromEventList+0x70>
800074f0:	c0 58       	rjmp	800074fa <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800074f2:	0c 9b       	mov	r11,r6
800074f4:	48 bc       	lddpc	r12,80007520 <xTaskRemoveFromEventList+0x74>
800074f6:	f0 1f 00 0a 	mcall	8000751c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800074fa:	48 b8       	lddpc	r8,80007524 <xTaskRemoveFromEventList+0x78>
800074fc:	70 08       	ld.w	r8,r8[0x0]
800074fe:	6e b9       	ld.w	r9,r7[0x2c]
80007500:	70 b8       	ld.w	r8,r8[0x2c]
80007502:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80007504:	5f 2c       	srhs	r12
80007506:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000750a:	00 00       	add	r0,r0
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	6a b6       	ld.w	r6,r5[0x2c]
80007510:	00 00       	add	r0,r0
80007512:	0d 9c       	ld.ub	r12,r6[0x1]
80007514:	00 00       	add	r0,r0
80007516:	0d d4       	ld.ub	r4,r6[0x5]
80007518:	00 00       	add	r0,r0
8000751a:	0c b8       	st.h	r6++,r8
8000751c:	80 00       	ld.sh	r0,r0[0x0]
8000751e:	6a 66       	ld.w	r6,r5[0x18]
80007520:	00 00       	add	r0,r0
80007522:	0d 70       	ld.ub	r0,--r6
80007524:	00 00       	add	r0,r0
80007526:	0d 6c       	ld.uh	r12,--r6

80007528 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80007528:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000752c:	4b 98       	lddpc	r8,80007610 <vTaskIncrementTick+0xe8>
8000752e:	70 08       	ld.w	r8,r8[0x0]
80007530:	58 08       	cp.w	r8,0
80007532:	c6 91       	brne	80007604 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80007534:	4b 88       	lddpc	r8,80007614 <vTaskIncrementTick+0xec>
80007536:	70 09       	ld.w	r9,r8[0x0]
80007538:	2f f9       	sub	r9,-1
8000753a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000753c:	70 08       	ld.w	r8,r8[0x0]
8000753e:	58 08       	cp.w	r8,0
80007540:	c1 a1       	brne	80007574 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80007542:	4b 68       	lddpc	r8,80007618 <vTaskIncrementTick+0xf0>
80007544:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80007546:	4b 69       	lddpc	r9,8000761c <vTaskIncrementTick+0xf4>
80007548:	72 0b       	ld.w	r11,r9[0x0]
8000754a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000754c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000754e:	4b 59       	lddpc	r9,80007620 <vTaskIncrementTick+0xf8>
80007550:	72 0a       	ld.w	r10,r9[0x0]
80007552:	2f fa       	sub	r10,-1
80007554:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007556:	70 08       	ld.w	r8,r8[0x0]
80007558:	70 08       	ld.w	r8,r8[0x0]
8000755a:	58 08       	cp.w	r8,0
8000755c:	c0 51       	brne	80007566 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000755e:	3f f9       	mov	r9,-1
80007560:	4b 18       	lddpc	r8,80007624 <vTaskIncrementTick+0xfc>
80007562:	91 09       	st.w	r8[0x0],r9
80007564:	c0 88       	rjmp	80007574 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80007566:	4a d8       	lddpc	r8,80007618 <vTaskIncrementTick+0xf0>
80007568:	70 08       	ld.w	r8,r8[0x0]
8000756a:	70 38       	ld.w	r8,r8[0xc]
8000756c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000756e:	70 19       	ld.w	r9,r8[0x4]
80007570:	4a d8       	lddpc	r8,80007624 <vTaskIncrementTick+0xfc>
80007572:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80007574:	4a 88       	lddpc	r8,80007614 <vTaskIncrementTick+0xec>
80007576:	70 09       	ld.w	r9,r8[0x0]
80007578:	4a b8       	lddpc	r8,80007624 <vTaskIncrementTick+0xfc>
8000757a:	70 08       	ld.w	r8,r8[0x0]
8000757c:	10 39       	cp.w	r9,r8
8000757e:	c4 73       	brcs	8000760c <vTaskIncrementTick+0xe4>
80007580:	4a 68       	lddpc	r8,80007618 <vTaskIncrementTick+0xf0>
80007582:	70 08       	ld.w	r8,r8[0x0]
80007584:	70 08       	ld.w	r8,r8[0x0]
80007586:	58 08       	cp.w	r8,0
80007588:	c0 c0       	breq	800075a0 <vTaskIncrementTick+0x78>
8000758a:	4a 48       	lddpc	r8,80007618 <vTaskIncrementTick+0xf0>
8000758c:	70 08       	ld.w	r8,r8[0x0]
8000758e:	70 38       	ld.w	r8,r8[0xc]
80007590:	70 37       	ld.w	r7,r8[0xc]
80007592:	6e 18       	ld.w	r8,r7[0x4]
80007594:	4a 09       	lddpc	r9,80007614 <vTaskIncrementTick+0xec>
80007596:	72 09       	ld.w	r9,r9[0x0]
80007598:	12 38       	cp.w	r8,r9
8000759a:	e0 88 00 14 	brls	800075c2 <vTaskIncrementTick+0x9a>
8000759e:	c0 e8       	rjmp	800075ba <vTaskIncrementTick+0x92>
800075a0:	3f f9       	mov	r9,-1
800075a2:	4a 18       	lddpc	r8,80007624 <vTaskIncrementTick+0xfc>
800075a4:	91 09       	st.w	r8[0x0],r9
800075a6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075aa:	6a 08       	ld.w	r8,r5[0x0]
800075ac:	70 38       	ld.w	r8,r8[0xc]
800075ae:	70 37       	ld.w	r7,r8[0xc]
800075b0:	6e 18       	ld.w	r8,r7[0x4]
800075b2:	64 09       	ld.w	r9,r2[0x0]
800075b4:	12 38       	cp.w	r8,r9
800075b6:	e0 88 00 0a 	brls	800075ca <vTaskIncrementTick+0xa2>
800075ba:	49 b9       	lddpc	r9,80007624 <vTaskIncrementTick+0xfc>
800075bc:	93 08       	st.w	r9[0x0],r8
800075be:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075c2:	49 a4       	lddpc	r4,80007628 <vTaskIncrementTick+0x100>
800075c4:	49 a3       	lddpc	r3,8000762c <vTaskIncrementTick+0x104>
800075c6:	49 55       	lddpc	r5,80007618 <vTaskIncrementTick+0xf0>
800075c8:	49 32       	lddpc	r2,80007614 <vTaskIncrementTick+0xec>
800075ca:	ee c6 ff fc 	sub	r6,r7,-4
800075ce:	0c 9c       	mov	r12,r6
800075d0:	f0 1f 00 18 	mcall	80007630 <vTaskIncrementTick+0x108>
800075d4:	6e a8       	ld.w	r8,r7[0x28]
800075d6:	58 08       	cp.w	r8,0
800075d8:	c0 50       	breq	800075e2 <vTaskIncrementTick+0xba>
800075da:	ee cc ff e8 	sub	r12,r7,-24
800075de:	f0 1f 00 15 	mcall	80007630 <vTaskIncrementTick+0x108>
800075e2:	6e bc       	ld.w	r12,r7[0x2c]
800075e4:	68 08       	ld.w	r8,r4[0x0]
800075e6:	10 3c       	cp.w	r12,r8
800075e8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800075ec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075f0:	0c 9b       	mov	r11,r6
800075f2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800075f6:	f0 1f 00 10 	mcall	80007634 <vTaskIncrementTick+0x10c>
800075fa:	6a 08       	ld.w	r8,r5[0x0]
800075fc:	70 08       	ld.w	r8,r8[0x0]
800075fe:	58 08       	cp.w	r8,0
80007600:	cd 51       	brne	800075aa <vTaskIncrementTick+0x82>
80007602:	cc fb       	rjmp	800075a0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80007604:	48 d8       	lddpc	r8,80007638 <vTaskIncrementTick+0x110>
80007606:	70 09       	ld.w	r9,r8[0x0]
80007608:	2f f9       	sub	r9,-1
8000760a:	91 09       	st.w	r8[0x0],r9
8000760c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007610:	00 00       	add	r0,r0
80007612:	0d 9c       	ld.ub	r12,r6[0x1]
80007614:	00 00       	add	r0,r0
80007616:	0d 98       	ld.ub	r8,r6[0x1]
80007618:	00 00       	add	r0,r0
8000761a:	0c a4       	st.w	r6++,r4
8000761c:	00 00       	add	r0,r0
8000761e:	0c b4       	st.h	r6++,r4
80007620:	00 00       	add	r0,r0
80007622:	0c b0       	st.h	r6++,r0
80007624:	00 00       	add	r0,r0
80007626:	05 4c       	ld.w	r12,--r2
80007628:	00 00       	add	r0,r0
8000762a:	0d d4       	ld.ub	r4,r6[0x5]
8000762c:	00 00       	add	r0,r0
8000762e:	0c b8       	st.h	r6++,r8
80007630:	80 00       	ld.sh	r0,r0[0x0]
80007632:	6a b6       	ld.w	r6,r5[0x2c]
80007634:	80 00       	ld.sh	r0,r0[0x0]
80007636:	6a 66       	ld.w	r6,r5[0x18]
80007638:	00 00       	add	r0,r0
8000763a:	0c 9c       	mov	r12,r6

8000763c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000763c:	eb cd 40 c0 	pushm	r6-r7,lr
80007640:	18 97       	mov	r7,r12
80007642:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80007644:	f0 1f 00 15 	mcall	80007698 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80007648:	6c 08       	ld.w	r8,r6[0x0]
8000764a:	5b f8       	cp.w	r8,-1
8000764c:	c0 31       	brne	80007652 <xTaskCheckForTimeOut+0x16>
8000764e:	30 07       	mov	r7,0
80007650:	c1 f8       	rjmp	8000768e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80007652:	49 39       	lddpc	r9,8000769c <xTaskCheckForTimeOut+0x60>
80007654:	72 09       	ld.w	r9,r9[0x0]
80007656:	6e 0a       	ld.w	r10,r7[0x0]
80007658:	12 3a       	cp.w	r10,r9
8000765a:	c0 70       	breq	80007668 <xTaskCheckForTimeOut+0x2c>
8000765c:	49 19       	lddpc	r9,800076a0 <xTaskCheckForTimeOut+0x64>
8000765e:	72 09       	ld.w	r9,r9[0x0]
80007660:	6e 1a       	ld.w	r10,r7[0x4]
80007662:	12 3a       	cp.w	r10,r9
80007664:	e0 88 00 14 	brls	8000768c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80007668:	48 e9       	lddpc	r9,800076a0 <xTaskCheckForTimeOut+0x64>
8000766a:	72 0a       	ld.w	r10,r9[0x0]
8000766c:	6e 19       	ld.w	r9,r7[0x4]
8000766e:	12 1a       	sub	r10,r9
80007670:	14 38       	cp.w	r8,r10
80007672:	e0 88 00 0d 	brls	8000768c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80007676:	48 ba       	lddpc	r10,800076a0 <xTaskCheckForTimeOut+0x64>
80007678:	74 0a       	ld.w	r10,r10[0x0]
8000767a:	14 19       	sub	r9,r10
8000767c:	f2 08 00 08 	add	r8,r9,r8
80007680:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80007682:	0e 9c       	mov	r12,r7
80007684:	f0 1f 00 08 	mcall	800076a4 <xTaskCheckForTimeOut+0x68>
80007688:	30 07       	mov	r7,0
8000768a:	c0 28       	rjmp	8000768e <xTaskCheckForTimeOut+0x52>
8000768c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000768e:	f0 1f 00 07 	mcall	800076a8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80007692:	0e 9c       	mov	r12,r7
80007694:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	6b 70       	ld.w	r0,r5[0x5c]
8000769c:	00 00       	add	r0,r0
8000769e:	0c b0       	st.h	r6++,r0
800076a0:	00 00       	add	r0,r0
800076a2:	0d 98       	ld.ub	r8,r6[0x1]
800076a4:	80 00       	ld.sh	r0,r0[0x0]
800076a6:	73 a0       	ld.w	r0,r9[0x68]
800076a8:	80 00       	ld.sh	r0,r0[0x0]
800076aa:	6c 7c       	ld.w	r12,r6[0x1c]

800076ac <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800076ac:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800076b0:	f0 1f 00 05 	mcall	800076c4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800076b4:	48 58       	lddpc	r8,800076c8 <xTaskGetTickCount+0x1c>
800076b6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800076b8:	f0 1f 00 05 	mcall	800076cc <xTaskGetTickCount+0x20>

	return xTicks;
}
800076bc:	0e 9c       	mov	r12,r7
800076be:	e3 cd 80 80 	ldm	sp++,r7,pc
800076c2:	00 00       	add	r0,r0
800076c4:	80 00       	ld.sh	r0,r0[0x0]
800076c6:	6b 70       	ld.w	r0,r5[0x5c]
800076c8:	00 00       	add	r0,r0
800076ca:	0d 98       	ld.ub	r8,r6[0x1]
800076cc:	80 00       	ld.sh	r0,r0[0x0]
800076ce:	6c 7c       	ld.w	r12,r6[0x1c]

800076d0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800076d0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800076d4:	f0 1f 00 2c 	mcall	80007784 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800076d8:	4a c8       	lddpc	r8,80007788 <xTaskResumeAll+0xb8>
800076da:	70 09       	ld.w	r9,r8[0x0]
800076dc:	20 19       	sub	r9,1
800076de:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800076e0:	70 08       	ld.w	r8,r8[0x0]
800076e2:	58 08       	cp.w	r8,0
800076e4:	c4 91       	brne	80007776 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800076e6:	4a a8       	lddpc	r8,8000778c <xTaskResumeAll+0xbc>
800076e8:	70 08       	ld.w	r8,r8[0x0]
800076ea:	58 08       	cp.w	r8,0
800076ec:	c4 50       	breq	80007776 <xTaskResumeAll+0xa6>
800076ee:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800076f0:	4a 85       	lddpc	r5,80007790 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800076f2:	4a 93       	lddpc	r3,80007794 <xTaskResumeAll+0xc4>
800076f4:	4a 92       	lddpc	r2,80007798 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800076f6:	4a a1       	lddpc	r1,8000779c <xTaskResumeAll+0xcc>
800076f8:	c1 e8       	rjmp	80007734 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800076fa:	6a 38       	ld.w	r8,r5[0xc]
800076fc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800076fe:	ee cc ff e8 	sub	r12,r7,-24
80007702:	f0 1f 00 28 	mcall	800077a0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80007706:	ee c6 ff fc 	sub	r6,r7,-4
8000770a:	0c 9c       	mov	r12,r6
8000770c:	f0 1f 00 25 	mcall	800077a0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80007710:	6e bc       	ld.w	r12,r7[0x2c]
80007712:	66 08       	ld.w	r8,r3[0x0]
80007714:	10 3c       	cp.w	r12,r8
80007716:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000771a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000771e:	0c 9b       	mov	r11,r6
80007720:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80007724:	f0 1f 00 20 	mcall	800077a4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007728:	62 08       	ld.w	r8,r1[0x0]
8000772a:	6e b9       	ld.w	r9,r7[0x2c]
8000772c:	70 b8       	ld.w	r8,r8[0x2c]
8000772e:	10 39       	cp.w	r9,r8
80007730:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007734:	6a 08       	ld.w	r8,r5[0x0]
80007736:	58 08       	cp.w	r8,0
80007738:	ce 11       	brne	800076fa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000773a:	49 c8       	lddpc	r8,800077a8 <xTaskResumeAll+0xd8>
8000773c:	70 08       	ld.w	r8,r8[0x0]
8000773e:	58 08       	cp.w	r8,0
80007740:	c0 f0       	breq	8000775e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007742:	49 a8       	lddpc	r8,800077a8 <xTaskResumeAll+0xd8>
80007744:	70 08       	ld.w	r8,r8[0x0]
80007746:	58 08       	cp.w	r8,0
80007748:	c1 10       	breq	8000776a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000774a:	49 87       	lddpc	r7,800077a8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000774c:	f0 1f 00 18 	mcall	800077ac <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007750:	6e 08       	ld.w	r8,r7[0x0]
80007752:	20 18       	sub	r8,1
80007754:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007756:	6e 08       	ld.w	r8,r7[0x0]
80007758:	58 08       	cp.w	r8,0
8000775a:	cf 91       	brne	8000774c <xTaskResumeAll+0x7c>
8000775c:	c0 78       	rjmp	8000776a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000775e:	58 14       	cp.w	r4,1
80007760:	c0 50       	breq	8000776a <xTaskResumeAll+0x9a>
80007762:	49 48       	lddpc	r8,800077b0 <xTaskResumeAll+0xe0>
80007764:	70 08       	ld.w	r8,r8[0x0]
80007766:	58 18       	cp.w	r8,1
80007768:	c0 71       	brne	80007776 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000776a:	30 09       	mov	r9,0
8000776c:	49 18       	lddpc	r8,800077b0 <xTaskResumeAll+0xe0>
8000776e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007770:	d7 33       	scall
80007772:	30 17       	mov	r7,1
80007774:	c0 28       	rjmp	80007778 <xTaskResumeAll+0xa8>
80007776:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80007778:	f0 1f 00 0f 	mcall	800077b4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000777c:	0e 9c       	mov	r12,r7
8000777e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007782:	00 00       	add	r0,r0
80007784:	80 00       	ld.sh	r0,r0[0x0]
80007786:	6b 70       	ld.w	r0,r5[0x5c]
80007788:	00 00       	add	r0,r0
8000778a:	0d 9c       	ld.ub	r12,r6[0x1]
8000778c:	00 00       	add	r0,r0
8000778e:	0d b8       	ld.ub	r8,r6[0x3]
80007790:	00 00       	add	r0,r0
80007792:	0d 70       	ld.ub	r0,--r6
80007794:	00 00       	add	r0,r0
80007796:	0d d4       	ld.ub	r4,r6[0x5]
80007798:	00 00       	add	r0,r0
8000779a:	0c b8       	st.h	r6++,r8
8000779c:	00 00       	add	r0,r0
8000779e:	0d 6c       	ld.uh	r12,--r6
800077a0:	80 00       	ld.sh	r0,r0[0x0]
800077a2:	6a b6       	ld.w	r6,r5[0x2c]
800077a4:	80 00       	ld.sh	r0,r0[0x0]
800077a6:	6a 66       	ld.w	r6,r5[0x18]
800077a8:	00 00       	add	r0,r0
800077aa:	0c 9c       	mov	r12,r6
800077ac:	80 00       	ld.sh	r0,r0[0x0]
800077ae:	75 28       	ld.w	r8,r10[0x48]
800077b0:	00 00       	add	r0,r0
800077b2:	0d bc       	ld.ub	r12,r6[0x3]
800077b4:	80 00       	ld.sh	r0,r0[0x0]
800077b6:	6c 7c       	ld.w	r12,r6[0x1c]

800077b8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800077b8:	eb cd 40 80 	pushm	r7,lr
800077bc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800077be:	49 08       	lddpc	r8,800077fc <prvAddCurrentTaskToDelayedList+0x44>
800077c0:	70 08       	ld.w	r8,r8[0x0]
800077c2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800077c4:	48 f8       	lddpc	r8,80007800 <prvAddCurrentTaskToDelayedList+0x48>
800077c6:	70 08       	ld.w	r8,r8[0x0]
800077c8:	10 3c       	cp.w	r12,r8
800077ca:	c0 a2       	brcc	800077de <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800077cc:	48 c8       	lddpc	r8,800077fc <prvAddCurrentTaskToDelayedList+0x44>
800077ce:	70 0b       	ld.w	r11,r8[0x0]
800077d0:	48 d8       	lddpc	r8,80007804 <prvAddCurrentTaskToDelayedList+0x4c>
800077d2:	70 0c       	ld.w	r12,r8[0x0]
800077d4:	2f cb       	sub	r11,-4
800077d6:	f0 1f 00 0d 	mcall	80007808 <prvAddCurrentTaskToDelayedList+0x50>
800077da:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800077de:	48 88       	lddpc	r8,800077fc <prvAddCurrentTaskToDelayedList+0x44>
800077e0:	70 0b       	ld.w	r11,r8[0x0]
800077e2:	48 b8       	lddpc	r8,8000780c <prvAddCurrentTaskToDelayedList+0x54>
800077e4:	70 0c       	ld.w	r12,r8[0x0]
800077e6:	2f cb       	sub	r11,-4
800077e8:	f0 1f 00 08 	mcall	80007808 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800077ec:	48 98       	lddpc	r8,80007810 <prvAddCurrentTaskToDelayedList+0x58>
800077ee:	70 08       	ld.w	r8,r8[0x0]
800077f0:	10 37       	cp.w	r7,r8
800077f2:	c0 32       	brcc	800077f8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800077f4:	48 78       	lddpc	r8,80007810 <prvAddCurrentTaskToDelayedList+0x58>
800077f6:	91 07       	st.w	r8[0x0],r7
800077f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800077fc:	00 00       	add	r0,r0
800077fe:	0d 6c       	ld.uh	r12,--r6
80007800:	00 00       	add	r0,r0
80007802:	0d 98       	ld.ub	r8,r6[0x1]
80007804:	00 00       	add	r0,r0
80007806:	0c b4       	st.h	r6++,r4
80007808:	80 00       	ld.sh	r0,r0[0x0]
8000780a:	6a 82       	ld.w	r2,r5[0x20]
8000780c:	00 00       	add	r0,r0
8000780e:	0c a4       	st.w	r6++,r4
80007810:	00 00       	add	r0,r0
80007812:	05 4c       	ld.w	r12,--r2

80007814 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80007814:	eb cd 40 c0 	pushm	r6-r7,lr
80007818:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
8000781a:	58 0c       	cp.w	r12,0
8000781c:	c1 10       	breq	8000783e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000781e:	f0 1f 00 0a 	mcall	80007844 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80007822:	48 a8       	lddpc	r8,80007848 <vTaskDelay+0x34>
80007824:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007826:	48 a8       	lddpc	r8,8000784c <vTaskDelay+0x38>
80007828:	70 0c       	ld.w	r12,r8[0x0]
8000782a:	2f cc       	sub	r12,-4
8000782c:	f0 1f 00 09 	mcall	80007850 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007830:	ee 06 00 0c 	add	r12,r7,r6
80007834:	f0 1f 00 08 	mcall	80007854 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007838:	f0 1f 00 08 	mcall	80007858 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000783c:	c0 21       	brne	80007840 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000783e:	d7 33       	scall
80007840:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007844:	80 00       	ld.sh	r0,r0[0x0]
80007846:	73 14       	ld.w	r4,r9[0x44]
80007848:	00 00       	add	r0,r0
8000784a:	0d 98       	ld.ub	r8,r6[0x1]
8000784c:	00 00       	add	r0,r0
8000784e:	0d 6c       	ld.uh	r12,--r6
80007850:	80 00       	ld.sh	r0,r0[0x0]
80007852:	6a b6       	ld.w	r6,r5[0x2c]
80007854:	80 00       	ld.sh	r0,r0[0x0]
80007856:	77 b8       	ld.w	r8,r11[0x6c]
80007858:	80 00       	ld.sh	r0,r0[0x0]
8000785a:	76 d0       	ld.w	r0,r11[0x34]

8000785c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000785c:	eb cd 40 c0 	pushm	r6-r7,lr
80007860:	18 96       	mov	r6,r12
80007862:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007864:	f0 1f 00 18 	mcall	800078c4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007868:	6c 08       	ld.w	r8,r6[0x0]
8000786a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000786c:	49 79       	lddpc	r9,800078c8 <vTaskDelayUntil+0x6c>
8000786e:	72 09       	ld.w	r9,r9[0x0]
80007870:	12 38       	cp.w	r8,r9
80007872:	e0 88 00 0c 	brls	8000788a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007876:	0e 38       	cp.w	r8,r7
80007878:	e0 88 00 22 	brls	800078bc <vTaskDelayUntil+0x60>
8000787c:	49 38       	lddpc	r8,800078c8 <vTaskDelayUntil+0x6c>
8000787e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007880:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007882:	10 37       	cp.w	r7,r8
80007884:	e0 88 00 14 	brls	800078ac <vTaskDelayUntil+0x50>
80007888:	c0 a8       	rjmp	8000789c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000788a:	0e 38       	cp.w	r8,r7
8000788c:	e0 8b 00 16 	brhi	800078b8 <vTaskDelayUntil+0x5c>
80007890:	48 e8       	lddpc	r8,800078c8 <vTaskDelayUntil+0x6c>
80007892:	70 08       	ld.w	r8,r8[0x0]
80007894:	10 37       	cp.w	r7,r8
80007896:	e0 8b 00 11 	brhi	800078b8 <vTaskDelayUntil+0x5c>
8000789a:	c1 18       	rjmp	800078bc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000789c:	48 c8       	lddpc	r8,800078cc <vTaskDelayUntil+0x70>
8000789e:	70 0c       	ld.w	r12,r8[0x0]
800078a0:	2f cc       	sub	r12,-4
800078a2:	f0 1f 00 0c 	mcall	800078d0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800078a6:	0e 9c       	mov	r12,r7
800078a8:	f0 1f 00 0b 	mcall	800078d4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800078ac:	f0 1f 00 0b 	mcall	800078d8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800078b0:	c0 81       	brne	800078c0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800078b2:	d7 33       	scall
800078b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800078b8:	8d 07       	st.w	r6[0x0],r7
800078ba:	cf 1b       	rjmp	8000789c <vTaskDelayUntil+0x40>
800078bc:	8d 07       	st.w	r6[0x0],r7
800078be:	cf 7b       	rjmp	800078ac <vTaskDelayUntil+0x50>
800078c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	73 14       	ld.w	r4,r9[0x44]
800078c8:	00 00       	add	r0,r0
800078ca:	0d 98       	ld.ub	r8,r6[0x1]
800078cc:	00 00       	add	r0,r0
800078ce:	0d 6c       	ld.uh	r12,--r6
800078d0:	80 00       	ld.sh	r0,r0[0x0]
800078d2:	6a b6       	ld.w	r6,r5[0x2c]
800078d4:	80 00       	ld.sh	r0,r0[0x0]
800078d6:	77 b8       	ld.w	r8,r11[0x6c]
800078d8:	80 00       	ld.sh	r0,r0[0x0]
800078da:	76 d0       	ld.w	r0,r11[0x34]

800078dc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800078dc:	eb cd 40 c0 	pushm	r6-r7,lr
800078e0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800078e2:	48 e7       	lddpc	r7,80007918 <vTaskPlaceOnEventList+0x3c>
800078e4:	6e 0b       	ld.w	r11,r7[0x0]
800078e6:	2e 8b       	sub	r11,-24
800078e8:	f0 1f 00 0d 	mcall	8000791c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800078ec:	6e 0c       	ld.w	r12,r7[0x0]
800078ee:	2f cc       	sub	r12,-4
800078f0:	f0 1f 00 0c 	mcall	80007920 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800078f4:	5b f6       	cp.w	r6,-1
800078f6:	c0 81       	brne	80007906 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800078f8:	6e 0b       	ld.w	r11,r7[0x0]
800078fa:	2f cb       	sub	r11,-4
800078fc:	48 ac       	lddpc	r12,80007924 <vTaskPlaceOnEventList+0x48>
800078fe:	f0 1f 00 0b 	mcall	80007928 <vTaskPlaceOnEventList+0x4c>
80007902:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007906:	48 a8       	lddpc	r8,8000792c <vTaskPlaceOnEventList+0x50>
80007908:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000790a:	ec 0c 00 0c 	add	r12,r6,r12
8000790e:	f0 1f 00 09 	mcall	80007930 <vTaskPlaceOnEventList+0x54>
80007912:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007916:	00 00       	add	r0,r0
80007918:	00 00       	add	r0,r0
8000791a:	0d 6c       	ld.uh	r12,--r6
8000791c:	80 00       	ld.sh	r0,r0[0x0]
8000791e:	6a 82       	ld.w	r2,r5[0x20]
80007920:	80 00       	ld.sh	r0,r0[0x0]
80007922:	6a b6       	ld.w	r6,r5[0x2c]
80007924:	00 00       	add	r0,r0
80007926:	0d c0       	ld.ub	r0,r6[0x4]
80007928:	80 00       	ld.sh	r0,r0[0x0]
8000792a:	6a 66       	ld.w	r6,r5[0x18]
8000792c:	00 00       	add	r0,r0
8000792e:	0d 98       	ld.ub	r8,r6[0x1]
80007930:	80 00       	ld.sh	r0,r0[0x0]
80007932:	77 b8       	ld.w	r8,r11[0x6c]

80007934 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007934:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007938:	49 67       	lddpc	r7,80007990 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000793a:	49 74       	lddpc	r4,80007994 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000793c:	49 73       	lddpc	r3,80007998 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000793e:	49 85       	lddpc	r5,8000799c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007940:	6e 08       	ld.w	r8,r7[0x0]
80007942:	58 08       	cp.w	r8,0
80007944:	c1 e0       	breq	80007980 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007946:	f0 1f 00 17 	mcall	800079a0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000794a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000794c:	f0 1f 00 16 	mcall	800079a4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007950:	58 06       	cp.w	r6,0
80007952:	c1 70       	breq	80007980 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007954:	f0 1f 00 15 	mcall	800079a8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007958:	68 38       	ld.w	r8,r4[0xc]
8000795a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000795c:	ec cc ff fc 	sub	r12,r6,-4
80007960:	f0 1f 00 13 	mcall	800079ac <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007964:	66 08       	ld.w	r8,r3[0x0]
80007966:	20 18       	sub	r8,1
80007968:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000796a:	6e 08       	ld.w	r8,r7[0x0]
8000796c:	20 18       	sub	r8,1
8000796e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007970:	f0 1f 00 10 	mcall	800079b0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007974:	6c cc       	ld.w	r12,r6[0x30]
80007976:	f0 1f 00 10 	mcall	800079b4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000797a:	0c 9c       	mov	r12,r6
8000797c:	f0 1f 00 0e 	mcall	800079b4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007980:	6a 08       	ld.w	r8,r5[0x0]
80007982:	58 18       	cp.w	r8,1
80007984:	e0 88 00 03 	brls	8000798a <prvIdleTask+0x56>
			{
				taskYIELD();
80007988:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000798a:	f0 1f 00 0c 	mcall	800079b8 <prvIdleTask+0x84>
		}
		#endif
	}
8000798e:	cd 9b       	rjmp	80007940 <prvIdleTask+0xc>
80007990:	00 00       	add	r0,r0
80007992:	0c ac       	st.w	r6++,r12
80007994:	00 00       	add	r0,r0
80007996:	0d 58       	ld.sh	r8,--r6
80007998:	00 00       	add	r0,r0
8000799a:	0d b8       	ld.ub	r8,r6[0x3]
8000799c:	00 00       	add	r0,r0
8000799e:	0c b8       	st.h	r6++,r8
800079a0:	80 00       	ld.sh	r0,r0[0x0]
800079a2:	73 14       	ld.w	r4,r9[0x44]
800079a4:	80 00       	ld.sh	r0,r0[0x0]
800079a6:	76 d0       	ld.w	r0,r11[0x34]
800079a8:	80 00       	ld.sh	r0,r0[0x0]
800079aa:	6b 70       	ld.w	r0,r5[0x5c]
800079ac:	80 00       	ld.sh	r0,r0[0x0]
800079ae:	6a b6       	ld.w	r6,r5[0x2c]
800079b0:	80 00       	ld.sh	r0,r0[0x0]
800079b2:	6c 7c       	ld.w	r12,r6[0x1c]
800079b4:	80 00       	ld.sh	r0,r0[0x0]
800079b6:	6d b4       	ld.w	r4,r6[0x6c]
800079b8:	80 00       	ld.sh	r0,r0[0x0]
800079ba:	20 2c       	sub	r12,2

800079bc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800079bc:	d4 31       	pushm	r0-r7,lr
800079be:	20 1d       	sub	sp,4
800079c0:	fa c4 ff d8 	sub	r4,sp,-40
800079c4:	50 0c       	stdsp	sp[0x0],r12
800079c6:	16 91       	mov	r1,r11
800079c8:	14 97       	mov	r7,r10
800079ca:	12 90       	mov	r0,r9
800079cc:	10 93       	mov	r3,r8
800079ce:	68 02       	ld.w	r2,r4[0x0]
800079d0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800079d2:	34 8c       	mov	r12,72
800079d4:	f0 1f 00 5c 	mcall	80007b44 <xTaskGenericCreate+0x188>
800079d8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800079da:	c0 31       	brne	800079e0 <xTaskGenericCreate+0x24>
800079dc:	3f fc       	mov	r12,-1
800079de:	ca f8       	rjmp	80007b3c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800079e0:	58 06       	cp.w	r6,0
800079e2:	e0 81 00 af 	brne	80007b40 <xTaskGenericCreate+0x184>
800079e6:	0e 9c       	mov	r12,r7
800079e8:	5c 7c       	castu.h	r12
800079ea:	a3 6c       	lsl	r12,0x2
800079ec:	f0 1f 00 56 	mcall	80007b44 <xTaskGenericCreate+0x188>
800079f0:	18 96       	mov	r6,r12
800079f2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800079f4:	c0 61       	brne	80007a00 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800079f6:	0a 9c       	mov	r12,r5
800079f8:	f0 1f 00 54 	mcall	80007b48 <xTaskGenericCreate+0x18c>
800079fc:	3f fc       	mov	r12,-1
800079fe:	c9 f8       	rjmp	80007b3c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007a00:	5c 77       	castu.h	r7
80007a02:	ee 0a 15 02 	lsl	r10,r7,0x2
80007a06:	e0 6b 00 a5 	mov	r11,165
80007a0a:	0c 9c       	mov	r12,r6
80007a0c:	f0 1f 00 50 	mcall	80007b4c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007a10:	ee c6 00 01 	sub	r6,r7,1
80007a14:	6a c8       	ld.w	r8,r5[0x30]
80007a16:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007a1a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007a1e:	31 0a       	mov	r10,16
80007a20:	02 9b       	mov	r11,r1
80007a22:	ea cc ff cc 	sub	r12,r5,-52
80007a26:	f0 1f 00 4b 	mcall	80007b50 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007a2a:	30 08       	mov	r8,0
80007a2c:	eb 68 00 43 	st.b	r5[67],r8
80007a30:	58 73       	cp.w	r3,7
80007a32:	e6 07 17 80 	movls	r7,r3
80007a36:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007a3a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007a3c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007a40:	ea c4 ff fc 	sub	r4,r5,-4
80007a44:	08 9c       	mov	r12,r4
80007a46:	f0 1f 00 44 	mcall	80007b54 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007a4a:	ea cc ff e8 	sub	r12,r5,-24
80007a4e:	f0 1f 00 42 	mcall	80007b54 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007a52:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007a54:	ee 07 11 08 	rsub	r7,r7,8
80007a58:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007a5a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007a5c:	00 9a       	mov	r10,r0
80007a5e:	40 0b       	lddsp	r11,sp[0x0]
80007a60:	0c 9c       	mov	r12,r6
80007a62:	f0 1f 00 3e 	mcall	80007b58 <xTaskGenericCreate+0x19c>
80007a66:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007a68:	58 02       	cp.w	r2,0
80007a6a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007a6e:	f0 1f 00 3c 	mcall	80007b5c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007a72:	4b c8       	lddpc	r8,80007b60 <xTaskGenericCreate+0x1a4>
80007a74:	70 09       	ld.w	r9,r8[0x0]
80007a76:	2f f9       	sub	r9,-1
80007a78:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007a7a:	4b b8       	lddpc	r8,80007b64 <xTaskGenericCreate+0x1a8>
80007a7c:	70 08       	ld.w	r8,r8[0x0]
80007a7e:	58 08       	cp.w	r8,0
80007a80:	c2 61       	brne	80007acc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007a82:	4b 98       	lddpc	r8,80007b64 <xTaskGenericCreate+0x1a8>
80007a84:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007a86:	4b 78       	lddpc	r8,80007b60 <xTaskGenericCreate+0x1a4>
80007a88:	70 08       	ld.w	r8,r8[0x0]
80007a8a:	58 18       	cp.w	r8,1
80007a8c:	c2 b1       	brne	80007ae2 <xTaskGenericCreate+0x126>
80007a8e:	4b 77       	lddpc	r7,80007b68 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007a90:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007a94:	0e 9c       	mov	r12,r7
80007a96:	f0 1f 00 36 	mcall	80007b6c <xTaskGenericCreate+0x1b0>
80007a9a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007a9c:	0c 37       	cp.w	r7,r6
80007a9e:	cf b1       	brne	80007a94 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007aa0:	4b 47       	lddpc	r7,80007b70 <xTaskGenericCreate+0x1b4>
80007aa2:	0e 9c       	mov	r12,r7
80007aa4:	f0 1f 00 32 	mcall	80007b6c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007aa8:	4b 36       	lddpc	r6,80007b74 <xTaskGenericCreate+0x1b8>
80007aaa:	0c 9c       	mov	r12,r6
80007aac:	f0 1f 00 30 	mcall	80007b6c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007ab0:	4b 2c       	lddpc	r12,80007b78 <xTaskGenericCreate+0x1bc>
80007ab2:	f0 1f 00 2f 	mcall	80007b6c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007ab6:	4b 2c       	lddpc	r12,80007b7c <xTaskGenericCreate+0x1c0>
80007ab8:	f0 1f 00 2d 	mcall	80007b6c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007abc:	4b 1c       	lddpc	r12,80007b80 <xTaskGenericCreate+0x1c4>
80007abe:	f0 1f 00 2c 	mcall	80007b6c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007ac2:	4b 18       	lddpc	r8,80007b84 <xTaskGenericCreate+0x1c8>
80007ac4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007ac6:	4b 18       	lddpc	r8,80007b88 <xTaskGenericCreate+0x1cc>
80007ac8:	91 06       	st.w	r8[0x0],r6
80007aca:	c0 c8       	rjmp	80007ae2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007acc:	4b 08       	lddpc	r8,80007b8c <xTaskGenericCreate+0x1d0>
80007ace:	70 08       	ld.w	r8,r8[0x0]
80007ad0:	58 08       	cp.w	r8,0
80007ad2:	c0 81       	brne	80007ae2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007ad4:	4a 48       	lddpc	r8,80007b64 <xTaskGenericCreate+0x1a8>
80007ad6:	70 08       	ld.w	r8,r8[0x0]
80007ad8:	70 b8       	ld.w	r8,r8[0x2c]
80007ada:	10 33       	cp.w	r3,r8
80007adc:	c0 33       	brcs	80007ae2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007ade:	4a 28       	lddpc	r8,80007b64 <xTaskGenericCreate+0x1a8>
80007ae0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007ae2:	6a b8       	ld.w	r8,r5[0x2c]
80007ae4:	4a b9       	lddpc	r9,80007b90 <xTaskGenericCreate+0x1d4>
80007ae6:	72 09       	ld.w	r9,r9[0x0]
80007ae8:	12 38       	cp.w	r8,r9
80007aea:	e0 88 00 04 	brls	80007af2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007aee:	4a 99       	lddpc	r9,80007b90 <xTaskGenericCreate+0x1d4>
80007af0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007af2:	4a 98       	lddpc	r8,80007b94 <xTaskGenericCreate+0x1d8>
80007af4:	70 09       	ld.w	r9,r8[0x0]
80007af6:	2f f9       	sub	r9,-1
80007af8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007afa:	6a b8       	ld.w	r8,r5[0x2c]
80007afc:	4a 79       	lddpc	r9,80007b98 <xTaskGenericCreate+0x1dc>
80007afe:	72 09       	ld.w	r9,r9[0x0]
80007b00:	12 38       	cp.w	r8,r9
80007b02:	e0 88 00 04 	brls	80007b0a <xTaskGenericCreate+0x14e>
80007b06:	4a 59       	lddpc	r9,80007b98 <xTaskGenericCreate+0x1dc>
80007b08:	93 08       	st.w	r9[0x0],r8
80007b0a:	6a bc       	ld.w	r12,r5[0x2c]
80007b0c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007b10:	08 9b       	mov	r11,r4
80007b12:	49 68       	lddpc	r8,80007b68 <xTaskGenericCreate+0x1ac>
80007b14:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007b18:	f0 1f 00 21 	mcall	80007b9c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007b1c:	f0 1f 00 21 	mcall	80007ba0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007b20:	49 b8       	lddpc	r8,80007b8c <xTaskGenericCreate+0x1d0>
80007b22:	70 08       	ld.w	r8,r8[0x0]
80007b24:	58 08       	cp.w	r8,0
80007b26:	c0 a0       	breq	80007b3a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007b28:	48 f8       	lddpc	r8,80007b64 <xTaskGenericCreate+0x1a8>
80007b2a:	70 08       	ld.w	r8,r8[0x0]
80007b2c:	70 b8       	ld.w	r8,r8[0x2c]
80007b2e:	10 33       	cp.w	r3,r8
80007b30:	e0 88 00 05 	brls	80007b3a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007b34:	d7 33       	scall
80007b36:	30 1c       	mov	r12,1
80007b38:	c0 28       	rjmp	80007b3c <xTaskGenericCreate+0x180>
80007b3a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007b3c:	2f fd       	sub	sp,-4
80007b3e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007b40:	99 c6       	st.w	r12[0x30],r6
80007b42:	c5 fb       	rjmp	80007a00 <xTaskGenericCreate+0x44>
80007b44:	80 00       	ld.sh	r0,r0[0x0]
80007b46:	6d dc       	ld.w	r12,r6[0x74]
80007b48:	80 00       	ld.sh	r0,r0[0x0]
80007b4a:	6d b4       	ld.w	r4,r6[0x6c]
80007b4c:	80 00       	ld.sh	r0,r0[0x0]
80007b4e:	87 72       	st.w	r3[0x1c],r2
80007b50:	80 00       	ld.sh	r0,r0[0x0]
80007b52:	8a 9c       	ld.uh	r12,r5[0x2]
80007b54:	80 00       	ld.sh	r0,r0[0x0]
80007b56:	6a 60       	ld.w	r0,r5[0x18]
80007b58:	80 00       	ld.sh	r0,r0[0x0]
80007b5a:	6a dc       	ld.w	r12,r5[0x34]
80007b5c:	80 00       	ld.sh	r0,r0[0x0]
80007b5e:	6b 70       	ld.w	r0,r5[0x5c]
80007b60:	00 00       	add	r0,r0
80007b62:	0d b8       	ld.ub	r8,r6[0x3]
80007b64:	00 00       	add	r0,r0
80007b66:	0d 6c       	ld.uh	r12,--r6
80007b68:	00 00       	add	r0,r0
80007b6a:	0c b8       	st.h	r6++,r8
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	6a 4c       	ld.w	r12,r5[0x10]
80007b70:	00 00       	add	r0,r0
80007b72:	0d 84       	ld.ub	r4,r6[0x0]
80007b74:	00 00       	add	r0,r0
80007b76:	0d a0       	ld.ub	r0,r6[0x2]
80007b78:	00 00       	add	r0,r0
80007b7a:	0d 70       	ld.ub	r0,--r6
80007b7c:	00 00       	add	r0,r0
80007b7e:	0d 58       	ld.sh	r8,--r6
80007b80:	00 00       	add	r0,r0
80007b82:	0d c0       	ld.ub	r0,r6[0x4]
80007b84:	00 00       	add	r0,r0
80007b86:	0c a4       	st.w	r6++,r4
80007b88:	00 00       	add	r0,r0
80007b8a:	0c b4       	st.h	r6++,r4
80007b8c:	00 00       	add	r0,r0
80007b8e:	0c a8       	st.w	r6++,r8
80007b90:	00 00       	add	r0,r0
80007b92:	0c a0       	st.w	r6++,r0
80007b94:	00 00       	add	r0,r0
80007b96:	0d b4       	ld.ub	r4,r6[0x3]
80007b98:	00 00       	add	r0,r0
80007b9a:	0d d4       	ld.ub	r4,r6[0x5]
80007b9c:	80 00       	ld.sh	r0,r0[0x0]
80007b9e:	6a 66       	ld.w	r6,r5[0x18]
80007ba0:	80 00       	ld.sh	r0,r0[0x0]
80007ba2:	6c 7c       	ld.w	r12,r6[0x1c]

80007ba4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007ba4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007ba6:	30 09       	mov	r9,0
80007ba8:	1a d9       	st.w	--sp,r9
80007baa:	1a d9       	st.w	--sp,r9
80007bac:	1a d9       	st.w	--sp,r9
80007bae:	12 98       	mov	r8,r9
80007bb0:	e0 6a 01 00 	mov	r10,256
80007bb4:	48 9b       	lddpc	r11,80007bd8 <vTaskStartScheduler+0x34>
80007bb6:	48 ac       	lddpc	r12,80007bdc <vTaskStartScheduler+0x38>
80007bb8:	f0 1f 00 0a 	mcall	80007be0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007bbc:	2f dd       	sub	sp,-12
80007bbe:	58 1c       	cp.w	r12,1
80007bc0:	c0 a1       	brne	80007bd4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007bc2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007bc4:	30 19       	mov	r9,1
80007bc6:	48 88       	lddpc	r8,80007be4 <vTaskStartScheduler+0x40>
80007bc8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007bca:	30 09       	mov	r9,0
80007bcc:	48 78       	lddpc	r8,80007be8 <vTaskStartScheduler+0x44>
80007bce:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007bd0:	f0 1f 00 07 	mcall	80007bec <vTaskStartScheduler+0x48>
80007bd4:	d8 02       	popm	pc
80007bd6:	00 00       	add	r0,r0
80007bd8:	80 00       	ld.sh	r0,r0[0x0]
80007bda:	ea f4 80 00 	ld.w	r4,r5[-32768]
80007bde:	79 34       	ld.w	r4,r12[0x4c]
80007be0:	80 00       	ld.sh	r0,r0[0x0]
80007be2:	79 bc       	ld.w	r12,r12[0x6c]
80007be4:	00 00       	add	r0,r0
80007be6:	0c a8       	st.w	r6++,r8
80007be8:	00 00       	add	r0,r0
80007bea:	0d 98       	ld.ub	r8,r6[0x1]
80007bec:	80 00       	ld.sh	r0,r0[0x0]
80007bee:	6b 80       	ld.w	r0,r5[0x60]

80007bf0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007bf0:	16 cc       	st.b	r11++,r12
	return str;
}
80007bf2:	5e fb       	retal	r11

80007bf4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007bf4:	eb cd 40 c0 	pushm	r6-r7,lr
80007bf8:	20 3d       	sub	sp,12
80007bfa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007bfc:	30 06       	mov	r6,0
80007bfe:	30 07       	mov	r7,0
80007c00:	fa e7 00 00 	st.d	sp[0],r6
80007c04:	30 0c       	mov	r12,0
80007c06:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007c08:	58 08       	cp.w	r8,0
80007c0a:	c1 30       	breq	80007c30 <PrintHex+0x3c>
80007c0c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007c0e:	1a 9c       	mov	r12,sp
80007c10:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007c14:	58 9e       	cp.w	lr,9
80007c16:	e0 8a 00 04 	brle	80007c1e <PrintHex+0x2a>
80007c1a:	2c 9e       	sub	lr,-55
80007c1c:	c0 48       	rjmp	80007c24 <PrintHex+0x30>
80007c1e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007c22:	2d 0e       	sub	lr,-48
80007c24:	f8 09 0b 0e 	st.b	r12[r9],lr
80007c28:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007c2a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007c2c:	cf 21       	brne	80007c10 <PrintHex+0x1c>
80007c2e:	c0 48       	rjmp	80007c36 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007c30:	33 08       	mov	r8,48
80007c32:	ba 88       	st.b	sp[0x0],r8
80007c34:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007c36:	f6 09 01 08 	sub	r8,r11,r9
80007c3a:	58 08       	cp.w	r8,0
80007c3c:	e0 8a 00 13 	brle	80007c62 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007c40:	12 1b       	sub	r11,r9
80007c42:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007c46:	18 9e       	mov	lr,r12
80007c48:	58 0c       	cp.w	r12,0
80007c4a:	e0 8a 00 0c 	brle	80007c62 <PrintHex+0x6e>
80007c4e:	1a 9b       	mov	r11,sp
80007c50:	12 0b       	add	r11,r9
80007c52:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007c54:	33 07       	mov	r7,48
80007c56:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007c58:	2f f8       	sub	r8,-1
80007c5a:	1c 38       	cp.w	r8,lr
80007c5c:	cf d5       	brlt	80007c56 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007c5e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007c62:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007c66:	f0 cb ff ff 	sub	r11,r8,-1
80007c6a:	58 0b       	cp.w	r11,0
80007c6c:	e0 8a 00 19 	brle	80007c9e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007c70:	fa cb ff f4 	sub	r11,sp,-12
80007c74:	f6 09 00 09 	add	r9,r11,r9
80007c78:	37 8b       	mov	r11,120
80007c7a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007c7e:	fa c9 ff f4 	sub	r9,sp,-12
80007c82:	10 09       	add	r9,r8
80007c84:	33 0b       	mov	r11,48
80007c86:	f3 6b ff f4 	st.b	r9[-12],r11
80007c8a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007c8e:	fa ce 00 01 	sub	lr,sp,1
80007c92:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007c94:	11 8b       	ld.ub	r11,r8[0x0]
80007c96:	12 cb       	st.b	r9++,r11
80007c98:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007c9a:	1c 38       	cp.w	r8,lr
80007c9c:	cf c1       	brne	80007c94 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007c9e:	14 9c       	mov	r12,r10
80007ca0:	2f dd       	sub	sp,-12
80007ca2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007ca6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007ca6:	d4 21       	pushm	r4-r7,lr
80007ca8:	20 3d       	sub	sp,12
80007caa:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007cac:	30 06       	mov	r6,0
80007cae:	30 07       	mov	r7,0
80007cb0:	fa e7 00 00 	st.d	sp[0],r6
80007cb4:	30 0c       	mov	r12,0
80007cb6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007cb8:	58 08       	cp.w	r8,0
80007cba:	c0 35       	brlt	80007cc0 <PrintDec+0x1a>
80007cbc:	14 97       	mov	r7,r10
80007cbe:	c0 58       	rjmp	80007cc8 <PrintDec+0x22>
	{
		*p++ = '-';
80007cc0:	14 97       	mov	r7,r10
80007cc2:	32 d9       	mov	r9,45
80007cc4:	0e c9       	st.b	r7++,r9
		i = -i;
80007cc6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007cc8:	58 08       	cp.w	r8,0
80007cca:	c0 51       	brne	80007cd4 <PrintDec+0x2e>
80007ccc:	33 08       	mov	r8,48
80007cce:	ba 88       	st.b	sp[0x0],r8
80007cd0:	30 1e       	mov	lr,1
80007cd2:	c2 f8       	rjmp	80007d30 <PrintDec+0x8a>
	
	int ten = i%10;
80007cd4:	e0 65 66 67 	mov	r5,26215
80007cd8:	ea 15 66 66 	orh	r5,0x6666
80007cdc:	f0 05 04 44 	muls.d	r4,r8,r5
80007ce0:	ea 0c 14 02 	asr	r12,r5,0x2
80007ce4:	f0 09 14 1f 	asr	r9,r8,0x1f
80007ce8:	f8 09 01 09 	sub	r9,r12,r9
80007cec:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007cf0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007cf4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007cf6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007cf8:	e0 66 66 67 	mov	r6,26215
80007cfc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007d00:	2d 09       	sub	r9,-48
80007d02:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007d06:	2f fe       	sub	lr,-1
		i /= 10;
80007d08:	f0 06 04 44 	muls.d	r4,r8,r6
80007d0c:	ea 09 14 02 	asr	r9,r5,0x2
80007d10:	bf 58       	asr	r8,0x1f
80007d12:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007d16:	f0 06 04 44 	muls.d	r4,r8,r6
80007d1a:	ea 09 14 02 	asr	r9,r5,0x2
80007d1e:	f0 05 14 1f 	asr	r5,r8,0x1f
80007d22:	0a 19       	sub	r9,r5
80007d24:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d28:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007d2c:	58 08       	cp.w	r8,0
80007d2e:	ce 91       	brne	80007d00 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007d30:	f6 0e 01 08 	sub	r8,r11,lr
80007d34:	58 08       	cp.w	r8,0
80007d36:	e0 89 00 06 	brgt	80007d42 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007d3a:	58 0e       	cp.w	lr,0
80007d3c:	e0 89 00 14 	brgt	80007d64 <PrintDec+0xbe>
80007d40:	c1 d8       	rjmp	80007d7a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007d42:	1c 1b       	sub	r11,lr
80007d44:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007d46:	16 9c       	mov	r12,r11
80007d48:	58 0b       	cp.w	r11,0
80007d4a:	fe 9a ff f8 	brle	80007d3a <PrintDec+0x94>
80007d4e:	1a 99       	mov	r9,sp
80007d50:	1c 09       	add	r9,lr
80007d52:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007d54:	33 06       	mov	r6,48
80007d56:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007d58:	2f f8       	sub	r8,-1
80007d5a:	18 38       	cp.w	r8,r12
80007d5c:	cf d5       	brlt	80007d56 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007d5e:	f6 0e 00 0e 	add	lr,r11,lr
80007d62:	ce cb       	rjmp	80007d3a <PrintDec+0x94>
80007d64:	fa c8 ff f4 	sub	r8,sp,-12
80007d68:	1c 08       	add	r8,lr
80007d6a:	20 d8       	sub	r8,13
80007d6c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007d70:	11 89       	ld.ub	r9,r8[0x0]
80007d72:	0e c9       	st.b	r7++,r9
80007d74:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007d76:	16 38       	cp.w	r8,r11
80007d78:	cf c1       	brne	80007d70 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007d7a:	14 9c       	mov	r12,r10
80007d7c:	2f dd       	sub	sp,-12
80007d7e:	d8 22       	popm	r4-r7,pc

80007d80 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007d80:	d4 31       	pushm	r0-r7,lr
80007d82:	fa cd 02 08 	sub	sp,sp,520
80007d86:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007d88:	e0 6a 01 00 	mov	r10,256
80007d8c:	30 0b       	mov	r11,0
80007d8e:	fa cc fe f8 	sub	r12,sp,-264
80007d92:	f0 1f 00 4e 	mcall	80007ec8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007d96:	fa c4 fd d4 	sub	r4,sp,-556
80007d9a:	30 0a       	mov	r10,0
80007d9c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007d9e:	fa c3 ff fc 	sub	r3,sp,-4
80007da2:	e0 61 01 00 	mov	r1,256
80007da6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007da8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007daa:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007dae:	02 9a       	mov	r10,r1
80007db0:	00 9b       	mov	r11,r0
80007db2:	06 9c       	mov	r12,r3
80007db4:	f0 1f 00 45 	mcall	80007ec8 <log+0x148>
			
					if(*str == '%')
80007db8:	0f 88       	ld.ub	r8,r7[0x0]
80007dba:	e4 08 18 00 	cp.b	r8,r2
80007dbe:	c5 71       	brne	80007e6c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007dc0:	ee c8 ff ff 	sub	r8,r7,-1
80007dc4:	11 89       	ld.ub	r9,r8[0x0]
80007dc6:	4c 2a       	lddpc	r10,80007ecc <log+0x14c>
80007dc8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007dca:	23 09       	sub	r9,48
80007dcc:	30 9a       	mov	r10,9
80007dce:	f4 09 18 00 	cp.b	r9,r10
80007dd2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007dd6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007dda:	f7 b9 08 30 	subls	r9,48
80007dde:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007de2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007de6:	0f 88       	ld.ub	r8,r7[0x0]
80007de8:	22 58       	sub	r8,37
80007dea:	e0 48 00 53 	cp.w	r8,83
80007dee:	e0 8b 00 31 	brhi	80007e50 <log+0xd0>
80007df2:	4b 89       	lddpc	r9,80007ed0 <log+0x150>
80007df4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007df8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007dfc:	06 9a       	mov	r10,r3
80007dfe:	40 0b       	lddsp	r11,sp[0x0]
80007e00:	5c 5b       	castu.b	r11
80007e02:	68 0c       	ld.w	r12,r4[0x0]
80007e04:	f0 1f 00 34 	mcall	80007ed4 <log+0x154>
							break;
80007e08:	c2 98       	rjmp	80007e5a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007e0a:	4b 4c       	lddpc	r12,80007ed8 <log+0x158>
80007e0c:	f0 1f 00 34 	mcall	80007edc <log+0x15c>
80007e10:	08 95       	mov	r5,r4
80007e12:	06 9c       	mov	r12,r3
							break;
80007e14:	c2 38       	rjmp	80007e5a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007e16:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007e1a:	06 9a       	mov	r10,r3
80007e1c:	40 0b       	lddsp	r11,sp[0x0]
80007e1e:	5c 5b       	castu.b	r11
80007e20:	68 0c       	ld.w	r12,r4[0x0]
80007e22:	f0 1f 00 30 	mcall	80007ee0 <log+0x160>
80007e26:	06 9c       	mov	r12,r3
							break;
80007e28:	c1 98       	rjmp	80007e5a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007e2a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007e2e:	06 9b       	mov	r11,r3
80007e30:	09 bc       	ld.ub	r12,r4[0x3]
80007e32:	f0 1f 00 2d 	mcall	80007ee4 <log+0x164>
80007e36:	06 9c       	mov	r12,r3
							break;
80007e38:	c1 18       	rjmp	80007e5a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007e3a:	e8 c5 ff fc 	sub	r5,r4,-4
80007e3e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007e40:	c0 d8       	rjmp	80007e5a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007e42:	06 9b       	mov	r11,r3
80007e44:	32 5c       	mov	r12,37
80007e46:	f0 1f 00 28 	mcall	80007ee4 <log+0x164>
80007e4a:	08 95       	mov	r5,r4
80007e4c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007e4e:	c0 68       	rjmp	80007e5a <log+0xda>
							
							default:
							log("I need relax.");
80007e50:	4a 6c       	lddpc	r12,80007ee8 <log+0x168>
80007e52:	f0 1f 00 23 	mcall	80007edc <log+0x15c>
80007e56:	08 95       	mov	r5,r4
80007e58:	06 9c       	mov	r12,r3
						}
						str++;
80007e5a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007e5c:	1a dc       	st.w	--sp,r12
80007e5e:	1a d6       	st.w	--sp,r6
80007e60:	4a 3b       	lddpc	r11,80007eec <log+0x16c>
80007e62:	0c 9c       	mov	r12,r6
80007e64:	f0 1f 00 23 	mcall	80007ef0 <log+0x170>
80007e68:	2f ed       	sub	sp,-8
80007e6a:	c0 a8       	rjmp	80007e7e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007e6c:	2f f7       	sub	r7,-1
80007e6e:	1a d8       	st.w	--sp,r8
80007e70:	1a d6       	st.w	--sp,r6
80007e72:	4a 1b       	lddpc	r11,80007ef4 <log+0x174>
80007e74:	0c 9c       	mov	r12,r6
80007e76:	f0 1f 00 1f 	mcall	80007ef0 <log+0x170>
80007e7a:	08 95       	mov	r5,r4
80007e7c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007e7e:	0f 89       	ld.ub	r9,r7[0x0]
80007e80:	30 08       	mov	r8,0
80007e82:	f0 09 18 00 	cp.b	r9,r8
80007e86:	c0 30       	breq	80007e8c <log+0x10c>
80007e88:	0a 94       	mov	r4,r5
80007e8a:	c9 2b       	rjmp	80007dae <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007e8c:	fa c7 fe f8 	sub	r7,sp,-264
80007e90:	1a d7       	st.w	--sp,r7
80007e92:	49 ab       	lddpc	r11,80007ef8 <log+0x178>
80007e94:	0e 9c       	mov	r12,r7
80007e96:	f0 1f 00 17 	mcall	80007ef0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007e9a:	5c 5c       	castu.b	r12
80007e9c:	f8 c6 ff ff 	sub	r6,r12,-1
80007ea0:	0c 9c       	mov	r12,r6
80007ea2:	f0 1f 00 17 	mcall	80007efc <log+0x17c>
80007ea6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007ea8:	0c 9a       	mov	r10,r6
80007eaa:	0e 9b       	mov	r11,r7
80007eac:	f0 1f 00 15 	mcall	80007f00 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007eb0:	30 09       	mov	r9,0
80007eb2:	30 5a       	mov	r10,5
80007eb4:	fa cb fe f8 	sub	r11,sp,-264
80007eb8:	49 38       	lddpc	r8,80007f04 <log+0x184>
80007eba:	70 0c       	ld.w	r12,r8[0x0]
80007ebc:	f0 1f 00 13 	mcall	80007f08 <log+0x188>
80007ec0:	2f fd       	sub	sp,-4
	
	
}
80007ec2:	fe 3d fd f8 	sub	sp,-520
80007ec6:	d8 32       	popm	r0-r7,pc
80007ec8:	80 00       	ld.sh	r0,r0[0x0]
80007eca:	87 72       	st.w	r3[0x1c],r2
80007ecc:	00 00       	add	r0,r0
80007ece:	0d d8       	ld.ub	r8,r6[0x5]
80007ed0:	80 00       	ld.sh	r0,r0[0x0]
80007ed2:	ea fc 80 00 	ld.w	r12,r5[-32768]
80007ed6:	7c a6       	ld.w	r6,lr[0x28]
80007ed8:	80 00       	ld.sh	r0,r0[0x0]
80007eda:	ed a8 80 00 	ldcm.w	cp4,r8,
80007ede:	7d 80       	ld.w	r0,lr[0x60]
80007ee0:	80 00       	ld.sh	r0,r0[0x0]
80007ee2:	7b f4       	ld.w	r4,sp[0x7c]
80007ee4:	80 00       	ld.sh	r0,r0[0x0]
80007ee6:	7b f0       	ld.w	r0,sp[0x7c]
80007ee8:	80 00       	ld.sh	r0,r0[0x0]
80007eea:	ed b8       	*unknown*
80007eec:	80 00       	ld.sh	r0,r0[0x0]
80007eee:	ed c8 80 00 	stmts	r8,pc
80007ef2:	8a 60       	ld.sh	r0,r5[0xc]
80007ef4:	80 00       	ld.sh	r0,r0[0x0]
80007ef6:	ed d0 80 00 	ldswp.w	r0,r6[0]
80007efa:	ed d8 80 00 	ldswp.w	r8,r6[0]
80007efe:	6d dc       	ld.w	r12,r6[0x74]
80007f00:	80 00       	ld.sh	r0,r0[0x0]
80007f02:	86 2a       	ld.sh	r10,r3[0x4]
80007f04:	00 00       	add	r0,r0
80007f06:	54 3c       	stdsp	sp[0x10c],r12
80007f08:	80 00       	ld.sh	r0,r0[0x0]
80007f0a:	71 30       	ld.w	r0,r8[0x4c]

80007f0c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007f0c:	d4 31       	pushm	r0-r7,lr
80007f0e:	fa cd 02 0c 	sub	sp,sp,524
80007f12:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007f14:	e0 6a 01 00 	mov	r10,256
80007f18:	30 0b       	mov	r11,0
80007f1a:	fa cc fe f4 	sub	r12,sp,-268
80007f1e:	f0 1f 00 4c 	mcall	8000804c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007f22:	fa c4 fd d0 	sub	r4,sp,-560
80007f26:	30 0a       	mov	r10,0
80007f28:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f2a:	fa c3 ff fc 	sub	r3,sp,-4
80007f2e:	e0 61 01 00 	mov	r1,256
80007f32:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007f34:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007f36:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f3a:	02 9a       	mov	r10,r1
80007f3c:	00 9b       	mov	r11,r0
80007f3e:	06 9c       	mov	r12,r3
80007f40:	f0 1f 00 43 	mcall	8000804c <logFromISR+0x140>
			
			if(*str == '%')
80007f44:	0f 88       	ld.ub	r8,r7[0x0]
80007f46:	e4 08 18 00 	cp.b	r8,r2
80007f4a:	c5 11       	brne	80007fec <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007f4c:	ee c8 ff ff 	sub	r8,r7,-1
80007f50:	11 89       	ld.ub	r9,r8[0x0]
80007f52:	4c 0a       	lddpc	r10,80008050 <logFromISR+0x144>
80007f54:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007f56:	23 09       	sub	r9,48
80007f58:	30 9a       	mov	r10,9
80007f5a:	f4 09 18 00 	cp.b	r9,r10
80007f5e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007f62:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007f66:	f7 b9 08 30 	subls	r9,48
80007f6a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007f6e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007f72:	0f 88       	ld.ub	r8,r7[0x0]
80007f74:	22 58       	sub	r8,37
80007f76:	e0 48 00 53 	cp.w	r8,83
80007f7a:	e0 8b 00 2b 	brhi	80007fd0 <logFromISR+0xc4>
80007f7e:	4b 69       	lddpc	r9,80008054 <logFromISR+0x148>
80007f80:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007f84:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007f88:	06 9a       	mov	r10,r3
80007f8a:	40 0b       	lddsp	r11,sp[0x0]
80007f8c:	5c 5b       	castu.b	r11
80007f8e:	68 0c       	ld.w	r12,r4[0x0]
80007f90:	f0 1f 00 32 	mcall	80008058 <logFromISR+0x14c>
					break;
80007f94:	c2 38       	rjmp	80007fda <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007f96:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007f9a:	06 9a       	mov	r10,r3
80007f9c:	40 0b       	lddsp	r11,sp[0x0]
80007f9e:	5c 5b       	castu.b	r11
80007fa0:	68 0c       	ld.w	r12,r4[0x0]
80007fa2:	f0 1f 00 2f 	mcall	8000805c <logFromISR+0x150>
80007fa6:	06 9c       	mov	r12,r3
					break;
80007fa8:	c1 98       	rjmp	80007fda <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007faa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007fae:	06 9b       	mov	r11,r3
80007fb0:	09 bc       	ld.ub	r12,r4[0x3]
80007fb2:	f0 1f 00 2c 	mcall	80008060 <logFromISR+0x154>
80007fb6:	06 9c       	mov	r12,r3
					break;
80007fb8:	c1 18       	rjmp	80007fda <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007fba:	e8 c5 ff fc 	sub	r5,r4,-4
80007fbe:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007fc0:	c0 d8       	rjmp	80007fda <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007fc2:	06 9b       	mov	r11,r3
80007fc4:	32 5c       	mov	r12,37
80007fc6:	f0 1f 00 27 	mcall	80008060 <logFromISR+0x154>
80007fca:	08 95       	mov	r5,r4
80007fcc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007fce:	c0 68       	rjmp	80007fda <logFromISR+0xce>
					default:
					log("I need relax.");
80007fd0:	4a 5c       	lddpc	r12,80008064 <logFromISR+0x158>
80007fd2:	f0 1f 00 26 	mcall	80008068 <logFromISR+0x15c>
80007fd6:	08 95       	mov	r5,r4
80007fd8:	06 9c       	mov	r12,r3
				}
				str++;
80007fda:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007fdc:	1a dc       	st.w	--sp,r12
80007fde:	1a d6       	st.w	--sp,r6
80007fe0:	4a 3b       	lddpc	r11,8000806c <logFromISR+0x160>
80007fe2:	0c 9c       	mov	r12,r6
80007fe4:	f0 1f 00 23 	mcall	80008070 <logFromISR+0x164>
80007fe8:	2f ed       	sub	sp,-8
80007fea:	c0 a8       	rjmp	80007ffe <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007fec:	2f f7       	sub	r7,-1
80007fee:	1a d8       	st.w	--sp,r8
80007ff0:	1a d6       	st.w	--sp,r6
80007ff2:	4a 1b       	lddpc	r11,80008074 <logFromISR+0x168>
80007ff4:	0c 9c       	mov	r12,r6
80007ff6:	f0 1f 00 1f 	mcall	80008070 <logFromISR+0x164>
80007ffa:	08 95       	mov	r5,r4
80007ffc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007ffe:	0f 89       	ld.ub	r9,r7[0x0]
80008000:	30 08       	mov	r8,0
80008002:	f0 09 18 00 	cp.b	r9,r8
80008006:	c0 30       	breq	8000800c <logFromISR+0x100>
80008008:	0a 94       	mov	r4,r5
8000800a:	c9 8b       	rjmp	80007f3a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000800c:	fa c7 fe f4 	sub	r7,sp,-268
80008010:	1a d7       	st.w	--sp,r7
80008012:	49 ab       	lddpc	r11,80008078 <logFromISR+0x16c>
80008014:	0e 9c       	mov	r12,r7
80008016:	f0 1f 00 17 	mcall	80008070 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000801a:	5c 5c       	castu.b	r12
8000801c:	f8 c6 ff ff 	sub	r6,r12,-1
80008020:	0c 9c       	mov	r12,r6
80008022:	f0 1f 00 17 	mcall	8000807c <logFromISR+0x170>
80008026:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80008028:	0c 9a       	mov	r10,r6
8000802a:	0e 9b       	mov	r11,r7
8000802c:	f0 1f 00 15 	mcall	80008080 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80008030:	30 09       	mov	r9,0
80008032:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80008034:	fa ca fe f8 	sub	r10,sp,-264
80008038:	fa cb fe f4 	sub	r11,sp,-268
8000803c:	49 28       	lddpc	r8,80008084 <logFromISR+0x178>
8000803e:	70 0c       	ld.w	r12,r8[0x0]
80008040:	f0 1f 00 12 	mcall	80008088 <logFromISR+0x17c>
80008044:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80008046:	fe 3d fd f4 	sub	sp,-524
8000804a:	d8 32       	popm	r0-r7,pc
8000804c:	80 00       	ld.sh	r0,r0[0x0]
8000804e:	87 72       	st.w	r3[0x1c],r2
80008050:	00 00       	add	r0,r0
80008052:	0d d9       	ld.ub	r9,r6[0x5]
80008054:	80 00       	ld.sh	r0,r0[0x0]
80008056:	ec 4c 80 00 	cp.w	r12,819200
8000805a:	7c a6       	ld.w	r6,lr[0x28]
8000805c:	80 00       	ld.sh	r0,r0[0x0]
8000805e:	7b f4       	ld.w	r4,sp[0x7c]
80008060:	80 00       	ld.sh	r0,r0[0x0]
80008062:	7b f0       	ld.w	r0,sp[0x7c]
80008064:	80 00       	ld.sh	r0,r0[0x0]
80008066:	ed b8       	*unknown*
80008068:	80 00       	ld.sh	r0,r0[0x0]
8000806a:	7d 80       	ld.w	r0,lr[0x60]
8000806c:	80 00       	ld.sh	r0,r0[0x0]
8000806e:	ed c8 80 00 	stmts	r8,pc
80008072:	8a 60       	ld.sh	r0,r5[0xc]
80008074:	80 00       	ld.sh	r0,r0[0x0]
80008076:	ed d0 80 00 	ldswp.w	r0,r6[0]
8000807a:	ed d8 80 00 	ldswp.w	r8,r6[0]
8000807e:	6d dc       	ld.w	r12,r6[0x74]
80008080:	80 00       	ld.sh	r0,r0[0x0]
80008082:	86 2a       	ld.sh	r10,r3[0x4]
80008084:	00 00       	add	r0,r0
80008086:	54 3c       	stdsp	sp[0x10c],r12
80008088:	80 00       	ld.sh	r0,r0[0x0]
8000808a:	70 e0       	ld.w	r0,r8[0x38]

8000808c <log_init>:
		
	return str;
}

void log_init(void)
{
8000808c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000808e:	30 2b       	mov	r11,2
80008090:	48 fc       	lddpc	r12,800080cc <log_init+0x40>
80008092:	f0 1f 00 10 	mcall	800080d0 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80008096:	e0 6a 36 00 	mov	r10,13824
8000809a:	ea 1a 01 6e 	orh	r10,0x16e
8000809e:	48 eb       	lddpc	r11,800080d4 <log_init+0x48>
800080a0:	fe 7c 18 00 	mov	r12,-59392
800080a4:	f0 1f 00 0d 	mcall	800080d8 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800080a8:	30 4b       	mov	r11,4
800080aa:	33 2c       	mov	r12,50
800080ac:	f0 1f 00 0c 	mcall	800080dc <log_init+0x50>
800080b0:	48 c8       	lddpc	r8,800080e0 <log_init+0x54>
800080b2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800080b4:	30 09       	mov	r9,0
800080b6:	1a d9       	st.w	--sp,r9
800080b8:	1a d9       	st.w	--sp,r9
800080ba:	1a d9       	st.w	--sp,r9
800080bc:	30 28       	mov	r8,2
800080be:	36 4a       	mov	r10,100
800080c0:	48 9b       	lddpc	r11,800080e4 <log_init+0x58>
800080c2:	48 ac       	lddpc	r12,800080e8 <log_init+0x5c>
800080c4:	f0 1f 00 0a 	mcall	800080ec <log_init+0x60>
800080c8:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800080ca:	d8 02       	popm	pc
800080cc:	80 00       	ld.sh	r0,r0[0x0]
800080ce:	ed e4 80 00 	sthh.w	r0[r0],r6:b,r4:b
800080d2:	61 4c       	ld.w	r12,r0[0x50]
800080d4:	80 00       	ld.sh	r0,r0[0x0]
800080d6:	ed 9c       	*unknown*
800080d8:	80 00       	ld.sh	r0,r0[0x0]
800080da:	69 40       	ld.w	r0,r4[0x50]
800080dc:	80 00       	ld.sh	r0,r0[0x0]
800080de:	72 88       	ld.w	r8,r9[0x20]
800080e0:	00 00       	add	r0,r0
800080e2:	54 3c       	stdsp	sp[0x10c],r12
800080e4:	80 00       	ld.sh	r0,r0[0x0]
800080e6:	ed e0 80 00 	sthh.w	r0[r0],r6:b,r0:b
800080ea:	80 f0       	ld.uh	r0,r0[0xe]
800080ec:	80 00       	ld.sh	r0,r0[0x0]
800080ee:	79 bc       	ld.w	r12,r12[0x6c]

800080f0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800080f0:	eb cd 40 f8 	pushm	r3-r7,lr
800080f4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800080f6:	48 c7       	lddpc	r7,80008124 <task_log+0x34>
800080f8:	30 05       	mov	r5,0
800080fa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800080fc:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80008100:	0a 99       	mov	r9,r5
80008102:	08 9a       	mov	r10,r4
80008104:	1a 9b       	mov	r11,sp
80008106:	6e 0c       	ld.w	r12,r7[0x0]
80008108:	f0 1f 00 08 	mcall	80008128 <task_log+0x38>
8000810c:	58 1c       	cp.w	r12,1
8000810e:	cf 91       	brne	80008100 <task_log+0x10>
		{
			if( NULL != str)
80008110:	40 0b       	lddsp	r11,sp[0x0]
80008112:	58 0b       	cp.w	r11,0
80008114:	cf 60       	breq	80008100 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80008116:	06 9c       	mov	r12,r3
80008118:	f0 1f 00 05 	mcall	8000812c <task_log+0x3c>
				vPortFree(str);
8000811c:	40 0c       	lddsp	r12,sp[0x0]
8000811e:	f0 1f 00 05 	mcall	80008130 <task_log+0x40>
80008122:	ce fb       	rjmp	80008100 <task_log+0x10>
80008124:	00 00       	add	r0,r0
80008126:	54 3c       	stdsp	sp[0x10c],r12
80008128:	80 00       	ld.sh	r0,r0[0x0]
8000812a:	6f 24       	ld.w	r4,r7[0x48]
8000812c:	80 00       	ld.sh	r0,r0[0x0]
8000812e:	68 f0       	ld.w	r0,r4[0x3c]
80008130:	80 00       	ld.sh	r0,r0[0x0]
80008132:	6d b4       	ld.w	r4,r6[0x6c]

80008134 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80008134:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80008136:	fe 78 10 00 	mov	r8,-61440
8000813a:	30 19       	mov	r9,1
8000813c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80008140:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80008144:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80008148:	d3 03       	ssrf	0x10
	local_start_pll0();
8000814a:	f0 1f 00 0d 	mcall	8000817c <main+0x48>
		
	INTC_init_interrupts();
8000814e:	f0 1f 00 0d 	mcall	80008180 <main+0x4c>
		
	log_init();
80008152:	f0 1f 00 0d 	mcall	80008184 <main+0x50>
	log("----start debug----");
80008156:	48 dc       	lddpc	r12,80008188 <main+0x54>
80008158:	f0 1f 00 0d 	mcall	8000818c <main+0x58>
	
	xg_flashc_init();
8000815c:	f0 1f 00 0d 	mcall	80008190 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80008160:	f0 1f 00 0d 	mcall	80008194 <main+0x60>
		
	app_init();
80008164:	f0 1f 00 0d 	mcall	80008198 <main+0x64>
	
	xg_rtc_init();
80008168:	f0 1f 00 0d 	mcall	8000819c <main+0x68>
		
	xcmp_init();
8000816c:	f0 1f 00 0d 	mcall	800081a0 <main+0x6c>

	local_start_timer();
80008170:	f0 1f 00 0d 	mcall	800081a4 <main+0x70>
		
	vTaskStartScheduler();
80008174:	f0 1f 00 0d 	mcall	800081a8 <main+0x74>
	return 0;
	
}
80008178:	d8 0a       	popm	pc,r12=0
8000817a:	00 00       	add	r0,r0
8000817c:	80 00       	ld.sh	r0,r0[0x0]
8000817e:	5a a8       	cp.w	r8,-22
80008180:	80 00       	ld.sh	r0,r0[0x0]
80008182:	62 50       	ld.w	r0,r1[0x14]
80008184:	80 00       	ld.sh	r0,r0[0x0]
80008186:	80 8c       	ld.uh	r12,r0[0x0]
80008188:	80 00       	ld.sh	r0,r0[0x0]
8000818a:	ed f4 80 00 	ld.wls	r4,r6[0x0]
8000818e:	7d 80       	ld.w	r0,lr[0x60]
80008190:	80 00       	ld.sh	r0,r0[0x0]
80008192:	5b 3c       	cp.w	r12,-13
80008194:	80 00       	ld.sh	r0,r0[0x0]
80008196:	5a 08       	cp.w	r8,-32
80008198:	80 00       	ld.sh	r0,r0[0x0]
8000819a:	20 3c       	sub	r12,3
8000819c:	80 00       	ld.sh	r0,r0[0x0]
8000819e:	31 bc       	mov	r12,27
800081a0:	80 00       	ld.sh	r0,r0[0x0]
800081a2:	48 8c       	lddpc	r12,800081c0 <malloc+0x4>
800081a4:	80 00       	ld.sh	r0,r0[0x0]
800081a6:	5a 7c       	cp.w	r12,-25
800081a8:	80 00       	ld.sh	r0,r0[0x0]
800081aa:	7b a4       	ld.w	r4,sp[0x68]

800081ac <free>:
800081ac:	d4 01       	pushm	lr
800081ae:	e0 68 0a 50 	mov	r8,2640
800081b2:	18 9b       	mov	r11,r12
800081b4:	70 0c       	ld.w	r12,r8[0x0]
800081b6:	e0 a0 1e 73 	rcall	8000be9c <_free_r>
800081ba:	d8 02       	popm	pc

800081bc <malloc>:
800081bc:	d4 01       	pushm	lr
800081be:	e0 68 0a 50 	mov	r8,2640
800081c2:	18 9b       	mov	r11,r12
800081c4:	70 0c       	ld.w	r12,r8[0x0]
800081c6:	c0 3c       	rcall	800081cc <_malloc_r>
800081c8:	d8 02       	popm	pc
800081ca:	d7 03       	nop

800081cc <_malloc_r>:
800081cc:	d4 31       	pushm	r0-r7,lr
800081ce:	f6 c8 ff f5 	sub	r8,r11,-11
800081d2:	18 95       	mov	r5,r12
800081d4:	10 97       	mov	r7,r8
800081d6:	e0 17 ff f8 	andl	r7,0xfff8
800081da:	59 68       	cp.w	r8,22
800081dc:	f9 b7 08 10 	movls	r7,16
800081e0:	16 37       	cp.w	r7,r11
800081e2:	5f 38       	srlo	r8
800081e4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800081e8:	c0 50       	breq	800081f2 <_malloc_r+0x26>
800081ea:	30 c8       	mov	r8,12
800081ec:	99 38       	st.w	r12[0xc],r8
800081ee:	e0 8f 01 fa 	bral	800085e2 <_malloc_r+0x416>
800081f2:	fe b0 f5 97 	rcall	80006d20 <__malloc_lock>
800081f6:	e0 47 01 f7 	cp.w	r7,503
800081fa:	e0 8b 00 1d 	brhi	80008234 <_malloc_r+0x68>
800081fe:	ee 03 16 03 	lsr	r3,r7,0x3
80008202:	e0 68 05 50 	mov	r8,1360
80008206:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000820a:	70 36       	ld.w	r6,r8[0xc]
8000820c:	10 36       	cp.w	r6,r8
8000820e:	c0 61       	brne	8000821a <_malloc_r+0x4e>
80008210:	ec c8 ff f8 	sub	r8,r6,-8
80008214:	70 36       	ld.w	r6,r8[0xc]
80008216:	10 36       	cp.w	r6,r8
80008218:	c0 c0       	breq	80008230 <_malloc_r+0x64>
8000821a:	6c 18       	ld.w	r8,r6[0x4]
8000821c:	e0 18 ff fc 	andl	r8,0xfffc
80008220:	6c 3a       	ld.w	r10,r6[0xc]
80008222:	ec 08 00 09 	add	r9,r6,r8
80008226:	0a 9c       	mov	r12,r5
80008228:	6c 28       	ld.w	r8,r6[0x8]
8000822a:	95 28       	st.w	r10[0x8],r8
8000822c:	91 3a       	st.w	r8[0xc],r10
8000822e:	c4 78       	rjmp	800082bc <_malloc_r+0xf0>
80008230:	2f e3       	sub	r3,-2
80008232:	c4 d8       	rjmp	800082cc <_malloc_r+0x100>
80008234:	ee 03 16 09 	lsr	r3,r7,0x9
80008238:	c0 41       	brne	80008240 <_malloc_r+0x74>
8000823a:	ee 03 16 03 	lsr	r3,r7,0x3
8000823e:	c2 68       	rjmp	8000828a <_malloc_r+0xbe>
80008240:	58 43       	cp.w	r3,4
80008242:	e0 8b 00 06 	brhi	8000824e <_malloc_r+0x82>
80008246:	ee 03 16 06 	lsr	r3,r7,0x6
8000824a:	2c 83       	sub	r3,-56
8000824c:	c1 f8       	rjmp	8000828a <_malloc_r+0xbe>
8000824e:	59 43       	cp.w	r3,20
80008250:	e0 8b 00 04 	brhi	80008258 <_malloc_r+0x8c>
80008254:	2a 53       	sub	r3,-91
80008256:	c1 a8       	rjmp	8000828a <_malloc_r+0xbe>
80008258:	e0 43 00 54 	cp.w	r3,84
8000825c:	e0 8b 00 06 	brhi	80008268 <_malloc_r+0x9c>
80008260:	ee 03 16 0c 	lsr	r3,r7,0xc
80008264:	29 23       	sub	r3,-110
80008266:	c1 28       	rjmp	8000828a <_malloc_r+0xbe>
80008268:	e0 43 01 54 	cp.w	r3,340
8000826c:	e0 8b 00 06 	brhi	80008278 <_malloc_r+0xac>
80008270:	ee 03 16 0f 	lsr	r3,r7,0xf
80008274:	28 93       	sub	r3,-119
80008276:	c0 a8       	rjmp	8000828a <_malloc_r+0xbe>
80008278:	e0 43 05 54 	cp.w	r3,1364
8000827c:	e0 88 00 04 	brls	80008284 <_malloc_r+0xb8>
80008280:	37 e3       	mov	r3,126
80008282:	c0 48       	rjmp	8000828a <_malloc_r+0xbe>
80008284:	ee 03 16 12 	lsr	r3,r7,0x12
80008288:	28 43       	sub	r3,-124
8000828a:	e0 6a 05 50 	mov	r10,1360
8000828e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80008292:	74 36       	ld.w	r6,r10[0xc]
80008294:	c1 98       	rjmp	800082c6 <_malloc_r+0xfa>
80008296:	6c 19       	ld.w	r9,r6[0x4]
80008298:	e0 19 ff fc 	andl	r9,0xfffc
8000829c:	f2 07 01 0b 	sub	r11,r9,r7
800082a0:	58 fb       	cp.w	r11,15
800082a2:	e0 8a 00 04 	brle	800082aa <_malloc_r+0xde>
800082a6:	20 13       	sub	r3,1
800082a8:	c1 18       	rjmp	800082ca <_malloc_r+0xfe>
800082aa:	6c 38       	ld.w	r8,r6[0xc]
800082ac:	58 0b       	cp.w	r11,0
800082ae:	c0 b5       	brlt	800082c4 <_malloc_r+0xf8>
800082b0:	6c 2a       	ld.w	r10,r6[0x8]
800082b2:	ec 09 00 09 	add	r9,r6,r9
800082b6:	0a 9c       	mov	r12,r5
800082b8:	91 2a       	st.w	r8[0x8],r10
800082ba:	95 38       	st.w	r10[0xc],r8
800082bc:	72 18       	ld.w	r8,r9[0x4]
800082be:	a1 a8       	sbr	r8,0x0
800082c0:	93 18       	st.w	r9[0x4],r8
800082c2:	cb c8       	rjmp	8000843a <_malloc_r+0x26e>
800082c4:	10 96       	mov	r6,r8
800082c6:	14 36       	cp.w	r6,r10
800082c8:	ce 71       	brne	80008296 <_malloc_r+0xca>
800082ca:	2f f3       	sub	r3,-1
800082cc:	e0 6a 05 50 	mov	r10,1360
800082d0:	f4 cc ff f8 	sub	r12,r10,-8
800082d4:	78 26       	ld.w	r6,r12[0x8]
800082d6:	18 36       	cp.w	r6,r12
800082d8:	c6 c0       	breq	800083b0 <_malloc_r+0x1e4>
800082da:	6c 19       	ld.w	r9,r6[0x4]
800082dc:	e0 19 ff fc 	andl	r9,0xfffc
800082e0:	f2 07 01 08 	sub	r8,r9,r7
800082e4:	58 f8       	cp.w	r8,15
800082e6:	e0 89 00 8f 	brgt	80008404 <_malloc_r+0x238>
800082ea:	99 3c       	st.w	r12[0xc],r12
800082ec:	99 2c       	st.w	r12[0x8],r12
800082ee:	58 08       	cp.w	r8,0
800082f0:	c0 55       	brlt	800082fa <_malloc_r+0x12e>
800082f2:	ec 09 00 09 	add	r9,r6,r9
800082f6:	0a 9c       	mov	r12,r5
800082f8:	ce 2b       	rjmp	800082bc <_malloc_r+0xf0>
800082fa:	e0 49 01 ff 	cp.w	r9,511
800082fe:	e0 8b 00 13 	brhi	80008324 <_malloc_r+0x158>
80008302:	a3 99       	lsr	r9,0x3
80008304:	f4 09 00 38 	add	r8,r10,r9<<0x3
80008308:	70 2b       	ld.w	r11,r8[0x8]
8000830a:	8d 38       	st.w	r6[0xc],r8
8000830c:	8d 2b       	st.w	r6[0x8],r11
8000830e:	97 36       	st.w	r11[0xc],r6
80008310:	91 26       	st.w	r8[0x8],r6
80008312:	a3 49       	asr	r9,0x2
80008314:	74 18       	ld.w	r8,r10[0x4]
80008316:	30 1b       	mov	r11,1
80008318:	f6 09 09 49 	lsl	r9,r11,r9
8000831c:	f1 e9 10 09 	or	r9,r8,r9
80008320:	95 19       	st.w	r10[0x4],r9
80008322:	c4 78       	rjmp	800083b0 <_malloc_r+0x1e4>
80008324:	f2 0a 16 09 	lsr	r10,r9,0x9
80008328:	58 4a       	cp.w	r10,4
8000832a:	e0 8b 00 07 	brhi	80008338 <_malloc_r+0x16c>
8000832e:	f2 0a 16 06 	lsr	r10,r9,0x6
80008332:	2c 8a       	sub	r10,-56
80008334:	c2 08       	rjmp	80008374 <_malloc_r+0x1a8>
80008336:	d7 03       	nop
80008338:	59 4a       	cp.w	r10,20
8000833a:	e0 8b 00 04 	brhi	80008342 <_malloc_r+0x176>
8000833e:	2a 5a       	sub	r10,-91
80008340:	c1 a8       	rjmp	80008374 <_malloc_r+0x1a8>
80008342:	e0 4a 00 54 	cp.w	r10,84
80008346:	e0 8b 00 06 	brhi	80008352 <_malloc_r+0x186>
8000834a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000834e:	29 2a       	sub	r10,-110
80008350:	c1 28       	rjmp	80008374 <_malloc_r+0x1a8>
80008352:	e0 4a 01 54 	cp.w	r10,340
80008356:	e0 8b 00 06 	brhi	80008362 <_malloc_r+0x196>
8000835a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000835e:	28 9a       	sub	r10,-119
80008360:	c0 a8       	rjmp	80008374 <_malloc_r+0x1a8>
80008362:	e0 4a 05 54 	cp.w	r10,1364
80008366:	e0 88 00 04 	brls	8000836e <_malloc_r+0x1a2>
8000836a:	37 ea       	mov	r10,126
8000836c:	c0 48       	rjmp	80008374 <_malloc_r+0x1a8>
8000836e:	f2 0a 16 12 	lsr	r10,r9,0x12
80008372:	28 4a       	sub	r10,-124
80008374:	e0 6b 05 50 	mov	r11,1360
80008378:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000837c:	68 28       	ld.w	r8,r4[0x8]
8000837e:	08 38       	cp.w	r8,r4
80008380:	c0 e1       	brne	8000839c <_malloc_r+0x1d0>
80008382:	76 19       	ld.w	r9,r11[0x4]
80008384:	a3 4a       	asr	r10,0x2
80008386:	30 1e       	mov	lr,1
80008388:	fc 0a 09 4a 	lsl	r10,lr,r10
8000838c:	f3 ea 10 0a 	or	r10,r9,r10
80008390:	10 99       	mov	r9,r8
80008392:	97 1a       	st.w	r11[0x4],r10
80008394:	c0 a8       	rjmp	800083a8 <_malloc_r+0x1dc>
80008396:	70 28       	ld.w	r8,r8[0x8]
80008398:	08 38       	cp.w	r8,r4
8000839a:	c0 60       	breq	800083a6 <_malloc_r+0x1da>
8000839c:	70 1a       	ld.w	r10,r8[0x4]
8000839e:	e0 1a ff fc 	andl	r10,0xfffc
800083a2:	14 39       	cp.w	r9,r10
800083a4:	cf 93       	brcs	80008396 <_malloc_r+0x1ca>
800083a6:	70 39       	ld.w	r9,r8[0xc]
800083a8:	8d 39       	st.w	r6[0xc],r9
800083aa:	8d 28       	st.w	r6[0x8],r8
800083ac:	91 36       	st.w	r8[0xc],r6
800083ae:	93 26       	st.w	r9[0x8],r6
800083b0:	e6 08 14 02 	asr	r8,r3,0x2
800083b4:	30 1b       	mov	r11,1
800083b6:	e0 64 05 50 	mov	r4,1360
800083ba:	f6 08 09 4b 	lsl	r11,r11,r8
800083be:	68 18       	ld.w	r8,r4[0x4]
800083c0:	10 3b       	cp.w	r11,r8
800083c2:	e0 8b 00 6b 	brhi	80008498 <_malloc_r+0x2cc>
800083c6:	f7 e8 00 09 	and	r9,r11,r8
800083ca:	c0 b1       	brne	800083e0 <_malloc_r+0x214>
800083cc:	e0 13 ff fc 	andl	r3,0xfffc
800083d0:	a1 7b       	lsl	r11,0x1
800083d2:	2f c3       	sub	r3,-4
800083d4:	c0 38       	rjmp	800083da <_malloc_r+0x20e>
800083d6:	2f c3       	sub	r3,-4
800083d8:	a1 7b       	lsl	r11,0x1
800083da:	f7 e8 00 09 	and	r9,r11,r8
800083de:	cf c0       	breq	800083d6 <_malloc_r+0x20a>
800083e0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800083e4:	06 92       	mov	r2,r3
800083e6:	1c 91       	mov	r1,lr
800083e8:	62 36       	ld.w	r6,r1[0xc]
800083ea:	c2 e8       	rjmp	80008446 <_malloc_r+0x27a>
800083ec:	6c 1a       	ld.w	r10,r6[0x4]
800083ee:	e0 1a ff fc 	andl	r10,0xfffc
800083f2:	f4 07 01 08 	sub	r8,r10,r7
800083f6:	58 f8       	cp.w	r8,15
800083f8:	e0 8a 00 15 	brle	80008422 <_malloc_r+0x256>
800083fc:	6c 3a       	ld.w	r10,r6[0xc]
800083fe:	6c 29       	ld.w	r9,r6[0x8]
80008400:	95 29       	st.w	r10[0x8],r9
80008402:	93 3a       	st.w	r9[0xc],r10
80008404:	0e 99       	mov	r9,r7
80008406:	ec 07 00 07 	add	r7,r6,r7
8000840a:	a1 a9       	sbr	r9,0x0
8000840c:	99 37       	st.w	r12[0xc],r7
8000840e:	99 27       	st.w	r12[0x8],r7
80008410:	8d 19       	st.w	r6[0x4],r9
80008412:	ee 08 09 08 	st.w	r7[r8],r8
80008416:	8f 2c       	st.w	r7[0x8],r12
80008418:	8f 3c       	st.w	r7[0xc],r12
8000841a:	a1 a8       	sbr	r8,0x0
8000841c:	0a 9c       	mov	r12,r5
8000841e:	8f 18       	st.w	r7[0x4],r8
80008420:	c0 d8       	rjmp	8000843a <_malloc_r+0x26e>
80008422:	6c 39       	ld.w	r9,r6[0xc]
80008424:	58 08       	cp.w	r8,0
80008426:	c0 f5       	brlt	80008444 <_malloc_r+0x278>
80008428:	ec 0a 00 0a 	add	r10,r6,r10
8000842c:	74 18       	ld.w	r8,r10[0x4]
8000842e:	a1 a8       	sbr	r8,0x0
80008430:	0a 9c       	mov	r12,r5
80008432:	95 18       	st.w	r10[0x4],r8
80008434:	6c 28       	ld.w	r8,r6[0x8]
80008436:	93 28       	st.w	r9[0x8],r8
80008438:	91 39       	st.w	r8[0xc],r9
8000843a:	fe b0 f4 79 	rcall	80006d2c <__malloc_unlock>
8000843e:	ec cc ff f8 	sub	r12,r6,-8
80008442:	d8 32       	popm	r0-r7,pc
80008444:	12 96       	mov	r6,r9
80008446:	02 36       	cp.w	r6,r1
80008448:	cd 21       	brne	800083ec <_malloc_r+0x220>
8000844a:	2f f2       	sub	r2,-1
8000844c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008450:	c0 30       	breq	80008456 <_malloc_r+0x28a>
80008452:	2f 81       	sub	r1,-8
80008454:	cc ab       	rjmp	800083e8 <_malloc_r+0x21c>
80008456:	1c 98       	mov	r8,lr
80008458:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000845c:	c0 81       	brne	8000846c <_malloc_r+0x2a0>
8000845e:	68 19       	ld.w	r9,r4[0x4]
80008460:	f6 08 11 ff 	rsub	r8,r11,-1
80008464:	f3 e8 00 08 	and	r8,r9,r8
80008468:	89 18       	st.w	r4[0x4],r8
8000846a:	c0 78       	rjmp	80008478 <_malloc_r+0x2ac>
8000846c:	f0 c9 00 08 	sub	r9,r8,8
80008470:	20 13       	sub	r3,1
80008472:	70 08       	ld.w	r8,r8[0x0]
80008474:	12 38       	cp.w	r8,r9
80008476:	cf 10       	breq	80008458 <_malloc_r+0x28c>
80008478:	a1 7b       	lsl	r11,0x1
8000847a:	68 18       	ld.w	r8,r4[0x4]
8000847c:	10 3b       	cp.w	r11,r8
8000847e:	e0 8b 00 0d 	brhi	80008498 <_malloc_r+0x2cc>
80008482:	58 0b       	cp.w	r11,0
80008484:	c0 a0       	breq	80008498 <_malloc_r+0x2cc>
80008486:	04 93       	mov	r3,r2
80008488:	c0 38       	rjmp	8000848e <_malloc_r+0x2c2>
8000848a:	2f c3       	sub	r3,-4
8000848c:	a1 7b       	lsl	r11,0x1
8000848e:	f7 e8 00 09 	and	r9,r11,r8
80008492:	ca 71       	brne	800083e0 <_malloc_r+0x214>
80008494:	cf bb       	rjmp	8000848a <_malloc_r+0x2be>
80008496:	d7 03       	nop
80008498:	68 23       	ld.w	r3,r4[0x8]
8000849a:	66 12       	ld.w	r2,r3[0x4]
8000849c:	e0 12 ff fc 	andl	r2,0xfffc
800084a0:	0e 32       	cp.w	r2,r7
800084a2:	5f 39       	srlo	r9
800084a4:	e4 07 01 08 	sub	r8,r2,r7
800084a8:	58 f8       	cp.w	r8,15
800084aa:	5f aa       	srle	r10
800084ac:	f5 e9 10 09 	or	r9,r10,r9
800084b0:	e0 80 00 9a 	breq	800085e4 <_malloc_r+0x418>
800084b4:	e0 68 0d e4 	mov	r8,3556
800084b8:	70 01       	ld.w	r1,r8[0x0]
800084ba:	e0 68 09 5c 	mov	r8,2396
800084be:	2f 01       	sub	r1,-16
800084c0:	70 08       	ld.w	r8,r8[0x0]
800084c2:	0e 01       	add	r1,r7
800084c4:	5b f8       	cp.w	r8,-1
800084c6:	c0 40       	breq	800084ce <_malloc_r+0x302>
800084c8:	28 11       	sub	r1,-127
800084ca:	e0 11 ff 80 	andl	r1,0xff80
800084ce:	02 9b       	mov	r11,r1
800084d0:	0a 9c       	mov	r12,r5
800084d2:	e0 a0 02 b7 	rcall	80008a40 <_sbrk_r>
800084d6:	18 96       	mov	r6,r12
800084d8:	5b fc       	cp.w	r12,-1
800084da:	c7 50       	breq	800085c4 <_malloc_r+0x3f8>
800084dc:	e6 02 00 08 	add	r8,r3,r2
800084e0:	10 3c       	cp.w	r12,r8
800084e2:	c0 32       	brcc	800084e8 <_malloc_r+0x31c>
800084e4:	08 33       	cp.w	r3,r4
800084e6:	c6 f1       	brne	800085c4 <_malloc_r+0x3f8>
800084e8:	e0 6a 0d e8 	mov	r10,3560
800084ec:	74 09       	ld.w	r9,r10[0x0]
800084ee:	e2 09 00 09 	add	r9,r1,r9
800084f2:	95 09       	st.w	r10[0x0],r9
800084f4:	10 36       	cp.w	r6,r8
800084f6:	c0 a1       	brne	8000850a <_malloc_r+0x33e>
800084f8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800084fc:	c0 71       	brne	8000850a <_malloc_r+0x33e>
800084fe:	e2 02 00 02 	add	r2,r1,r2
80008502:	68 28       	ld.w	r8,r4[0x8]
80008504:	a1 a2       	sbr	r2,0x0
80008506:	91 12       	st.w	r8[0x4],r2
80008508:	c4 f8       	rjmp	800085a6 <_malloc_r+0x3da>
8000850a:	e0 6a 09 5c 	mov	r10,2396
8000850e:	74 0b       	ld.w	r11,r10[0x0]
80008510:	5b fb       	cp.w	r11,-1
80008512:	c0 31       	brne	80008518 <_malloc_r+0x34c>
80008514:	95 06       	st.w	r10[0x0],r6
80008516:	c0 78       	rjmp	80008524 <_malloc_r+0x358>
80008518:	ec 09 00 09 	add	r9,r6,r9
8000851c:	e0 6a 0d e8 	mov	r10,3560
80008520:	10 19       	sub	r9,r8
80008522:	95 09       	st.w	r10[0x0],r9
80008524:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80008528:	f0 09 11 08 	rsub	r9,r8,8
8000852c:	58 08       	cp.w	r8,0
8000852e:	f2 08 17 10 	movne	r8,r9
80008532:	ed d8 e1 06 	addne	r6,r6,r8
80008536:	28 08       	sub	r8,-128
80008538:	ec 01 00 01 	add	r1,r6,r1
8000853c:	0a 9c       	mov	r12,r5
8000853e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80008542:	f0 01 01 01 	sub	r1,r8,r1
80008546:	02 9b       	mov	r11,r1
80008548:	e0 a0 02 7c 	rcall	80008a40 <_sbrk_r>
8000854c:	e0 68 0d e8 	mov	r8,3560
80008550:	5b fc       	cp.w	r12,-1
80008552:	ec 0c 17 00 	moveq	r12,r6
80008556:	f9 b1 00 00 	moveq	r1,0
8000855a:	70 09       	ld.w	r9,r8[0x0]
8000855c:	0c 1c       	sub	r12,r6
8000855e:	89 26       	st.w	r4[0x8],r6
80008560:	02 0c       	add	r12,r1
80008562:	12 01       	add	r1,r9
80008564:	a1 ac       	sbr	r12,0x0
80008566:	91 01       	st.w	r8[0x0],r1
80008568:	8d 1c       	st.w	r6[0x4],r12
8000856a:	08 33       	cp.w	r3,r4
8000856c:	c1 d0       	breq	800085a6 <_malloc_r+0x3da>
8000856e:	58 f2       	cp.w	r2,15
80008570:	e0 8b 00 05 	brhi	8000857a <_malloc_r+0x3ae>
80008574:	30 18       	mov	r8,1
80008576:	8d 18       	st.w	r6[0x4],r8
80008578:	c2 68       	rjmp	800085c4 <_malloc_r+0x3f8>
8000857a:	30 59       	mov	r9,5
8000857c:	20 c2       	sub	r2,12
8000857e:	e0 12 ff f8 	andl	r2,0xfff8
80008582:	e6 02 00 08 	add	r8,r3,r2
80008586:	91 29       	st.w	r8[0x8],r9
80008588:	91 19       	st.w	r8[0x4],r9
8000858a:	66 18       	ld.w	r8,r3[0x4]
8000858c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008590:	e5 e8 10 08 	or	r8,r2,r8
80008594:	87 18       	st.w	r3[0x4],r8
80008596:	58 f2       	cp.w	r2,15
80008598:	e0 88 00 07 	brls	800085a6 <_malloc_r+0x3da>
8000859c:	e6 cb ff f8 	sub	r11,r3,-8
800085a0:	0a 9c       	mov	r12,r5
800085a2:	e0 a0 1c 7d 	rcall	8000be9c <_free_r>
800085a6:	e0 69 0d e0 	mov	r9,3552
800085aa:	72 0a       	ld.w	r10,r9[0x0]
800085ac:	e0 68 0d e8 	mov	r8,3560
800085b0:	70 08       	ld.w	r8,r8[0x0]
800085b2:	14 38       	cp.w	r8,r10
800085b4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800085b8:	e0 69 0d dc 	mov	r9,3548
800085bc:	72 0a       	ld.w	r10,r9[0x0]
800085be:	14 38       	cp.w	r8,r10
800085c0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800085c4:	68 28       	ld.w	r8,r4[0x8]
800085c6:	70 18       	ld.w	r8,r8[0x4]
800085c8:	e0 18 ff fc 	andl	r8,0xfffc
800085cc:	0e 38       	cp.w	r8,r7
800085ce:	5f 39       	srlo	r9
800085d0:	0e 18       	sub	r8,r7
800085d2:	58 f8       	cp.w	r8,15
800085d4:	5f aa       	srle	r10
800085d6:	f5 e9 10 09 	or	r9,r10,r9
800085da:	c0 50       	breq	800085e4 <_malloc_r+0x418>
800085dc:	0a 9c       	mov	r12,r5
800085de:	fe b0 f3 a7 	rcall	80006d2c <__malloc_unlock>
800085e2:	d8 3a       	popm	r0-r7,pc,r12=0
800085e4:	68 26       	ld.w	r6,r4[0x8]
800085e6:	a1 a8       	sbr	r8,0x0
800085e8:	0e 99       	mov	r9,r7
800085ea:	a1 a9       	sbr	r9,0x0
800085ec:	8d 19       	st.w	r6[0x4],r9
800085ee:	ec 07 00 07 	add	r7,r6,r7
800085f2:	0a 9c       	mov	r12,r5
800085f4:	89 27       	st.w	r4[0x8],r7
800085f6:	8f 18       	st.w	r7[0x4],r8
800085f8:	fe b0 f3 9a 	rcall	80006d2c <__malloc_unlock>
800085fc:	ec cc ff f8 	sub	r12,r6,-8
80008600:	d8 32       	popm	r0-r7,pc
80008602:	d7 03       	nop

80008604 <memcmp>:
80008604:	d4 01       	pushm	lr
80008606:	30 08       	mov	r8,0
80008608:	c0 d8       	rjmp	80008622 <memcmp+0x1e>
8000860a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000860e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008612:	20 1a       	sub	r10,1
80008614:	2f f8       	sub	r8,-1
80008616:	f2 0e 18 00 	cp.b	lr,r9
8000861a:	c0 40       	breq	80008622 <memcmp+0x1e>
8000861c:	fc 09 01 0c 	sub	r12,lr,r9
80008620:	d8 02       	popm	pc
80008622:	58 0a       	cp.w	r10,0
80008624:	cf 31       	brne	8000860a <memcmp+0x6>
80008626:	14 9c       	mov	r12,r10
80008628:	d8 02       	popm	pc

8000862a <memcpy>:
8000862a:	58 8a       	cp.w	r10,8
8000862c:	c2 f5       	brlt	8000868a <memcpy+0x60>
8000862e:	f9 eb 10 09 	or	r9,r12,r11
80008632:	e2 19 00 03 	andl	r9,0x3,COH
80008636:	e0 81 00 97 	brne	80008764 <memcpy+0x13a>
8000863a:	e0 4a 00 20 	cp.w	r10,32
8000863e:	c3 b4       	brge	800086b4 <memcpy+0x8a>
80008640:	f4 08 14 02 	asr	r8,r10,0x2
80008644:	f0 09 11 08 	rsub	r9,r8,8
80008648:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000864c:	76 69       	ld.w	r9,r11[0x18]
8000864e:	99 69       	st.w	r12[0x18],r9
80008650:	76 59       	ld.w	r9,r11[0x14]
80008652:	99 59       	st.w	r12[0x14],r9
80008654:	76 49       	ld.w	r9,r11[0x10]
80008656:	99 49       	st.w	r12[0x10],r9
80008658:	76 39       	ld.w	r9,r11[0xc]
8000865a:	99 39       	st.w	r12[0xc],r9
8000865c:	76 29       	ld.w	r9,r11[0x8]
8000865e:	99 29       	st.w	r12[0x8],r9
80008660:	76 19       	ld.w	r9,r11[0x4]
80008662:	99 19       	st.w	r12[0x4],r9
80008664:	76 09       	ld.w	r9,r11[0x0]
80008666:	99 09       	st.w	r12[0x0],r9
80008668:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000866c:	f8 08 00 28 	add	r8,r12,r8<<0x2
80008670:	e0 1a 00 03 	andl	r10,0x3
80008674:	f4 0a 11 04 	rsub	r10,r10,4
80008678:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000867c:	17 a9       	ld.ub	r9,r11[0x2]
8000867e:	b0 a9       	st.b	r8[0x2],r9
80008680:	17 99       	ld.ub	r9,r11[0x1]
80008682:	b0 99       	st.b	r8[0x1],r9
80008684:	17 89       	ld.ub	r9,r11[0x0]
80008686:	b0 89       	st.b	r8[0x0],r9
80008688:	5e fc       	retal	r12
8000868a:	f4 0a 11 09 	rsub	r10,r10,9
8000868e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008692:	17 f9       	ld.ub	r9,r11[0x7]
80008694:	b8 f9       	st.b	r12[0x7],r9
80008696:	17 e9       	ld.ub	r9,r11[0x6]
80008698:	b8 e9       	st.b	r12[0x6],r9
8000869a:	17 d9       	ld.ub	r9,r11[0x5]
8000869c:	b8 d9       	st.b	r12[0x5],r9
8000869e:	17 c9       	ld.ub	r9,r11[0x4]
800086a0:	b8 c9       	st.b	r12[0x4],r9
800086a2:	17 b9       	ld.ub	r9,r11[0x3]
800086a4:	b8 b9       	st.b	r12[0x3],r9
800086a6:	17 a9       	ld.ub	r9,r11[0x2]
800086a8:	b8 a9       	st.b	r12[0x2],r9
800086aa:	17 99       	ld.ub	r9,r11[0x1]
800086ac:	b8 99       	st.b	r12[0x1],r9
800086ae:	17 89       	ld.ub	r9,r11[0x0]
800086b0:	b8 89       	st.b	r12[0x0],r9
800086b2:	5e fc       	retal	r12
800086b4:	eb cd 40 c0 	pushm	r6-r7,lr
800086b8:	18 99       	mov	r9,r12
800086ba:	22 0a       	sub	r10,32
800086bc:	b7 07       	ld.d	r6,r11++
800086be:	b3 26       	st.d	r9++,r6
800086c0:	b7 07       	ld.d	r6,r11++
800086c2:	b3 26       	st.d	r9++,r6
800086c4:	b7 07       	ld.d	r6,r11++
800086c6:	b3 26       	st.d	r9++,r6
800086c8:	b7 07       	ld.d	r6,r11++
800086ca:	b3 26       	st.d	r9++,r6
800086cc:	22 0a       	sub	r10,32
800086ce:	cf 74       	brge	800086bc <memcpy+0x92>
800086d0:	2f 0a       	sub	r10,-16
800086d2:	c0 65       	brlt	800086de <memcpy+0xb4>
800086d4:	b7 07       	ld.d	r6,r11++
800086d6:	b3 26       	st.d	r9++,r6
800086d8:	b7 07       	ld.d	r6,r11++
800086da:	b3 26       	st.d	r9++,r6
800086dc:	21 0a       	sub	r10,16
800086de:	5c 3a       	neg	r10
800086e0:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800086e4:	d7 03       	nop
800086e6:	d7 03       	nop
800086e8:	f7 36 00 0e 	ld.ub	r6,r11[14]
800086ec:	f3 66 00 0e 	st.b	r9[14],r6
800086f0:	f7 36 00 0d 	ld.ub	r6,r11[13]
800086f4:	f3 66 00 0d 	st.b	r9[13],r6
800086f8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800086fc:	f3 66 00 0c 	st.b	r9[12],r6
80008700:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008704:	f3 66 00 0b 	st.b	r9[11],r6
80008708:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000870c:	f3 66 00 0a 	st.b	r9[10],r6
80008710:	f7 36 00 09 	ld.ub	r6,r11[9]
80008714:	f3 66 00 09 	st.b	r9[9],r6
80008718:	f7 36 00 08 	ld.ub	r6,r11[8]
8000871c:	f3 66 00 08 	st.b	r9[8],r6
80008720:	f7 36 00 07 	ld.ub	r6,r11[7]
80008724:	f3 66 00 07 	st.b	r9[7],r6
80008728:	f7 36 00 06 	ld.ub	r6,r11[6]
8000872c:	f3 66 00 06 	st.b	r9[6],r6
80008730:	f7 36 00 05 	ld.ub	r6,r11[5]
80008734:	f3 66 00 05 	st.b	r9[5],r6
80008738:	f7 36 00 04 	ld.ub	r6,r11[4]
8000873c:	f3 66 00 04 	st.b	r9[4],r6
80008740:	f7 36 00 03 	ld.ub	r6,r11[3]
80008744:	f3 66 00 03 	st.b	r9[3],r6
80008748:	f7 36 00 02 	ld.ub	r6,r11[2]
8000874c:	f3 66 00 02 	st.b	r9[2],r6
80008750:	f7 36 00 01 	ld.ub	r6,r11[1]
80008754:	f3 66 00 01 	st.b	r9[1],r6
80008758:	f7 36 00 00 	ld.ub	r6,r11[0]
8000875c:	f3 66 00 00 	st.b	r9[0],r6
80008760:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008764:	20 1a       	sub	r10,1
80008766:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000876a:	f8 0a 0b 09 	st.b	r12[r10],r9
8000876e:	cf b1       	brne	80008764 <memcpy+0x13a>
80008770:	5e fc       	retal	r12

80008772 <memset>:
80008772:	18 98       	mov	r8,r12
80008774:	c0 38       	rjmp	8000877a <memset+0x8>
80008776:	10 cb       	st.b	r8++,r11
80008778:	20 1a       	sub	r10,1
8000877a:	58 0a       	cp.w	r10,0
8000877c:	cf d1       	brne	80008776 <memset+0x4>
8000877e:	5e fc       	retal	r12

80008780 <_realloc_r>:
80008780:	d4 31       	pushm	r0-r7,lr
80008782:	20 1d       	sub	sp,4
80008784:	16 94       	mov	r4,r11
80008786:	18 92       	mov	r2,r12
80008788:	14 9b       	mov	r11,r10
8000878a:	58 04       	cp.w	r4,0
8000878c:	c0 51       	brne	80008796 <_realloc_r+0x16>
8000878e:	fe b0 fd 1f 	rcall	800081cc <_malloc_r>
80008792:	18 95       	mov	r5,r12
80008794:	c5 39       	rjmp	80008a3a <_realloc_r+0x2ba>
80008796:	50 0a       	stdsp	sp[0x0],r10
80008798:	fe b0 f2 c4 	rcall	80006d20 <__malloc_lock>
8000879c:	40 0b       	lddsp	r11,sp[0x0]
8000879e:	f6 c8 ff f5 	sub	r8,r11,-11
800087a2:	e8 c1 00 08 	sub	r1,r4,8
800087a6:	10 96       	mov	r6,r8
800087a8:	62 1c       	ld.w	r12,r1[0x4]
800087aa:	e0 16 ff f8 	andl	r6,0xfff8
800087ae:	59 68       	cp.w	r8,22
800087b0:	f9 b6 08 10 	movls	r6,16
800087b4:	16 36       	cp.w	r6,r11
800087b6:	5f 38       	srlo	r8
800087b8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800087bc:	c0 50       	breq	800087c6 <_realloc_r+0x46>
800087be:	30 c8       	mov	r8,12
800087c0:	30 05       	mov	r5,0
800087c2:	85 38       	st.w	r2[0xc],r8
800087c4:	c3 b9       	rjmp	80008a3a <_realloc_r+0x2ba>
800087c6:	18 90       	mov	r0,r12
800087c8:	e0 10 ff fc 	andl	r0,0xfffc
800087cc:	0c 30       	cp.w	r0,r6
800087ce:	e0 84 01 0b 	brge	800089e4 <_realloc_r+0x264>
800087d2:	e0 68 05 50 	mov	r8,1360
800087d6:	e2 00 00 09 	add	r9,r1,r0
800087da:	70 25       	ld.w	r5,r8[0x8]
800087dc:	0a 39       	cp.w	r9,r5
800087de:	c0 90       	breq	800087f0 <_realloc_r+0x70>
800087e0:	72 1a       	ld.w	r10,r9[0x4]
800087e2:	a1 ca       	cbr	r10,0x0
800087e4:	f2 0a 00 0a 	add	r10,r9,r10
800087e8:	74 1a       	ld.w	r10,r10[0x4]
800087ea:	ed ba 00 00 	bld	r10,0x0
800087ee:	c2 20       	breq	80008832 <_realloc_r+0xb2>
800087f0:	72 1a       	ld.w	r10,r9[0x4]
800087f2:	e0 1a ff fc 	andl	r10,0xfffc
800087f6:	f4 00 00 03 	add	r3,r10,r0
800087fa:	0a 39       	cp.w	r9,r5
800087fc:	c1 31       	brne	80008822 <_realloc_r+0xa2>
800087fe:	ec c7 ff f0 	sub	r7,r6,-16
80008802:	0e 33       	cp.w	r3,r7
80008804:	c1 95       	brlt	80008836 <_realloc_r+0xb6>
80008806:	e2 06 00 09 	add	r9,r1,r6
8000880a:	0c 13       	sub	r3,r6
8000880c:	a1 a3       	sbr	r3,0x0
8000880e:	93 13       	st.w	r9[0x4],r3
80008810:	91 29       	st.w	r8[0x8],r9
80008812:	04 9c       	mov	r12,r2
80008814:	62 18       	ld.w	r8,r1[0x4]
80008816:	08 95       	mov	r5,r4
80008818:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000881c:	10 46       	or	r6,r8
8000881e:	83 16       	st.w	r1[0x4],r6
80008820:	c0 b9       	rjmp	80008a36 <_realloc_r+0x2b6>
80008822:	0c 33       	cp.w	r3,r6
80008824:	c0 95       	brlt	80008836 <_realloc_r+0xb6>
80008826:	72 28       	ld.w	r8,r9[0x8]
80008828:	02 97       	mov	r7,r1
8000882a:	72 39       	ld.w	r9,r9[0xc]
8000882c:	93 28       	st.w	r9[0x8],r8
8000882e:	91 39       	st.w	r8[0xc],r9
80008830:	cd c8       	rjmp	800089e8 <_realloc_r+0x268>
80008832:	30 0a       	mov	r10,0
80008834:	14 99       	mov	r9,r10
80008836:	ed bc 00 00 	bld	r12,0x0
8000883a:	e0 80 00 95 	breq	80008964 <_realloc_r+0x1e4>
8000883e:	62 07       	ld.w	r7,r1[0x0]
80008840:	e2 07 01 07 	sub	r7,r1,r7
80008844:	6e 1c       	ld.w	r12,r7[0x4]
80008846:	e0 1c ff fc 	andl	r12,0xfffc
8000884a:	58 09       	cp.w	r9,0
8000884c:	c5 60       	breq	800088f8 <_realloc_r+0x178>
8000884e:	f8 00 00 03 	add	r3,r12,r0
80008852:	0a 39       	cp.w	r9,r5
80008854:	c4 81       	brne	800088e4 <_realloc_r+0x164>
80008856:	14 03       	add	r3,r10
80008858:	ec c9 ff f0 	sub	r9,r6,-16
8000885c:	12 33       	cp.w	r3,r9
8000885e:	c4 d5       	brlt	800088f8 <_realloc_r+0x178>
80008860:	6e 3a       	ld.w	r10,r7[0xc]
80008862:	6e 29       	ld.w	r9,r7[0x8]
80008864:	95 29       	st.w	r10[0x8],r9
80008866:	93 3a       	st.w	r9[0xc],r10
80008868:	ee c5 ff f8 	sub	r5,r7,-8
8000886c:	e0 ca 00 04 	sub	r10,r0,4
80008870:	e0 4a 00 24 	cp.w	r10,36
80008874:	e0 8b 00 25 	brhi	800088be <_realloc_r+0x13e>
80008878:	0a 99       	mov	r9,r5
8000887a:	59 3a       	cp.w	r10,19
8000887c:	e0 88 00 1a 	brls	800088b0 <_realloc_r+0x130>
80008880:	09 09       	ld.w	r9,r4++
80008882:	8b 09       	st.w	r5[0x0],r9
80008884:	09 09       	ld.w	r9,r4++
80008886:	8f 39       	st.w	r7[0xc],r9
80008888:	ee c9 ff f0 	sub	r9,r7,-16
8000888c:	59 ba       	cp.w	r10,27
8000888e:	e0 88 00 11 	brls	800088b0 <_realloc_r+0x130>
80008892:	09 0b       	ld.w	r11,r4++
80008894:	93 0b       	st.w	r9[0x0],r11
80008896:	09 09       	ld.w	r9,r4++
80008898:	8f 59       	st.w	r7[0x14],r9
8000889a:	ee c9 ff e8 	sub	r9,r7,-24
8000889e:	e0 4a 00 24 	cp.w	r10,36
800088a2:	c0 71       	brne	800088b0 <_realloc_r+0x130>
800088a4:	09 0a       	ld.w	r10,r4++
800088a6:	93 0a       	st.w	r9[0x0],r10
800088a8:	ee c9 ff e0 	sub	r9,r7,-32
800088ac:	09 0a       	ld.w	r10,r4++
800088ae:	8f 7a       	st.w	r7[0x1c],r10
800088b0:	09 0a       	ld.w	r10,r4++
800088b2:	12 aa       	st.w	r9++,r10
800088b4:	68 0a       	ld.w	r10,r4[0x0]
800088b6:	93 0a       	st.w	r9[0x0],r10
800088b8:	68 1a       	ld.w	r10,r4[0x4]
800088ba:	93 1a       	st.w	r9[0x4],r10
800088bc:	c0 78       	rjmp	800088ca <_realloc_r+0x14a>
800088be:	50 08       	stdsp	sp[0x0],r8
800088c0:	08 9b       	mov	r11,r4
800088c2:	0a 9c       	mov	r12,r5
800088c4:	e0 a0 1d 8f 	rcall	8000c3e2 <memmove>
800088c8:	40 08       	lddsp	r8,sp[0x0]
800088ca:	ee 06 00 09 	add	r9,r7,r6
800088ce:	0c 13       	sub	r3,r6
800088d0:	a1 a3       	sbr	r3,0x0
800088d2:	93 13       	st.w	r9[0x4],r3
800088d4:	91 29       	st.w	r8[0x8],r9
800088d6:	04 9c       	mov	r12,r2
800088d8:	6e 18       	ld.w	r8,r7[0x4]
800088da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800088de:	10 46       	or	r6,r8
800088e0:	8f 16       	st.w	r7[0x4],r6
800088e2:	ca a8       	rjmp	80008a36 <_realloc_r+0x2b6>
800088e4:	14 03       	add	r3,r10
800088e6:	0c 33       	cp.w	r3,r6
800088e8:	c0 85       	brlt	800088f8 <_realloc_r+0x178>
800088ea:	72 28       	ld.w	r8,r9[0x8]
800088ec:	72 39       	ld.w	r9,r9[0xc]
800088ee:	93 28       	st.w	r9[0x8],r8
800088f0:	91 39       	st.w	r8[0xc],r9
800088f2:	6e 28       	ld.w	r8,r7[0x8]
800088f4:	6e 39       	ld.w	r9,r7[0xc]
800088f6:	c0 78       	rjmp	80008904 <_realloc_r+0x184>
800088f8:	f8 00 00 03 	add	r3,r12,r0
800088fc:	0c 33       	cp.w	r3,r6
800088fe:	c3 35       	brlt	80008964 <_realloc_r+0x1e4>
80008900:	6e 39       	ld.w	r9,r7[0xc]
80008902:	6e 28       	ld.w	r8,r7[0x8]
80008904:	93 28       	st.w	r9[0x8],r8
80008906:	91 39       	st.w	r8[0xc],r9
80008908:	e0 ca 00 04 	sub	r10,r0,4
8000890c:	ee cc ff f8 	sub	r12,r7,-8
80008910:	e0 4a 00 24 	cp.w	r10,36
80008914:	e0 8b 00 24 	brhi	8000895c <_realloc_r+0x1dc>
80008918:	59 3a       	cp.w	r10,19
8000891a:	e0 88 00 1a 	brls	8000894e <_realloc_r+0x1ce>
8000891e:	09 08       	ld.w	r8,r4++
80008920:	99 08       	st.w	r12[0x0],r8
80008922:	09 08       	ld.w	r8,r4++
80008924:	8f 38       	st.w	r7[0xc],r8
80008926:	ee cc ff f0 	sub	r12,r7,-16
8000892a:	59 ba       	cp.w	r10,27
8000892c:	e0 88 00 11 	brls	8000894e <_realloc_r+0x1ce>
80008930:	09 08       	ld.w	r8,r4++
80008932:	99 08       	st.w	r12[0x0],r8
80008934:	09 08       	ld.w	r8,r4++
80008936:	8f 58       	st.w	r7[0x14],r8
80008938:	ee cc ff e8 	sub	r12,r7,-24
8000893c:	e0 4a 00 24 	cp.w	r10,36
80008940:	c0 71       	brne	8000894e <_realloc_r+0x1ce>
80008942:	09 08       	ld.w	r8,r4++
80008944:	99 08       	st.w	r12[0x0],r8
80008946:	ee cc ff e0 	sub	r12,r7,-32
8000894a:	09 08       	ld.w	r8,r4++
8000894c:	8f 78       	st.w	r7[0x1c],r8
8000894e:	09 08       	ld.w	r8,r4++
80008950:	18 a8       	st.w	r12++,r8
80008952:	68 08       	ld.w	r8,r4[0x0]
80008954:	99 08       	st.w	r12[0x0],r8
80008956:	68 18       	ld.w	r8,r4[0x4]
80008958:	99 18       	st.w	r12[0x4],r8
8000895a:	c4 78       	rjmp	800089e8 <_realloc_r+0x268>
8000895c:	08 9b       	mov	r11,r4
8000895e:	e0 a0 1d 42 	rcall	8000c3e2 <memmove>
80008962:	c4 38       	rjmp	800089e8 <_realloc_r+0x268>
80008964:	04 9c       	mov	r12,r2
80008966:	fe b0 fc 33 	rcall	800081cc <_malloc_r>
8000896a:	18 95       	mov	r5,r12
8000896c:	c3 a0       	breq	800089e0 <_realloc_r+0x260>
8000896e:	62 18       	ld.w	r8,r1[0x4]
80008970:	f8 c9 00 08 	sub	r9,r12,8
80008974:	a1 c8       	cbr	r8,0x0
80008976:	e2 08 00 08 	add	r8,r1,r8
8000897a:	10 39       	cp.w	r9,r8
8000897c:	c0 71       	brne	8000898a <_realloc_r+0x20a>
8000897e:	72 13       	ld.w	r3,r9[0x4]
80008980:	02 97       	mov	r7,r1
80008982:	e0 13 ff fc 	andl	r3,0xfffc
80008986:	00 03       	add	r3,r0
80008988:	c3 08       	rjmp	800089e8 <_realloc_r+0x268>
8000898a:	e0 ca 00 04 	sub	r10,r0,4
8000898e:	e0 4a 00 24 	cp.w	r10,36
80008992:	e0 8b 00 20 	brhi	800089d2 <_realloc_r+0x252>
80008996:	08 99       	mov	r9,r4
80008998:	18 98       	mov	r8,r12
8000899a:	59 3a       	cp.w	r10,19
8000899c:	e0 88 00 14 	brls	800089c4 <_realloc_r+0x244>
800089a0:	13 0b       	ld.w	r11,r9++
800089a2:	10 ab       	st.w	r8++,r11
800089a4:	13 0b       	ld.w	r11,r9++
800089a6:	10 ab       	st.w	r8++,r11
800089a8:	59 ba       	cp.w	r10,27
800089aa:	e0 88 00 0d 	brls	800089c4 <_realloc_r+0x244>
800089ae:	13 0b       	ld.w	r11,r9++
800089b0:	10 ab       	st.w	r8++,r11
800089b2:	13 0b       	ld.w	r11,r9++
800089b4:	10 ab       	st.w	r8++,r11
800089b6:	e0 4a 00 24 	cp.w	r10,36
800089ba:	c0 51       	brne	800089c4 <_realloc_r+0x244>
800089bc:	13 0a       	ld.w	r10,r9++
800089be:	10 aa       	st.w	r8++,r10
800089c0:	13 0a       	ld.w	r10,r9++
800089c2:	10 aa       	st.w	r8++,r10
800089c4:	13 0a       	ld.w	r10,r9++
800089c6:	10 aa       	st.w	r8++,r10
800089c8:	72 0a       	ld.w	r10,r9[0x0]
800089ca:	91 0a       	st.w	r8[0x0],r10
800089cc:	72 19       	ld.w	r9,r9[0x4]
800089ce:	91 19       	st.w	r8[0x4],r9
800089d0:	c0 48       	rjmp	800089d8 <_realloc_r+0x258>
800089d2:	08 9b       	mov	r11,r4
800089d4:	e0 a0 1d 07 	rcall	8000c3e2 <memmove>
800089d8:	08 9b       	mov	r11,r4
800089da:	04 9c       	mov	r12,r2
800089dc:	e0 a0 1a 60 	rcall	8000be9c <_free_r>
800089e0:	04 9c       	mov	r12,r2
800089e2:	c2 a8       	rjmp	80008a36 <_realloc_r+0x2b6>
800089e4:	00 93       	mov	r3,r0
800089e6:	02 97       	mov	r7,r1
800089e8:	e6 06 01 09 	sub	r9,r3,r6
800089ec:	6e 18       	ld.w	r8,r7[0x4]
800089ee:	58 f9       	cp.w	r9,15
800089f0:	e0 88 00 16 	brls	80008a1c <_realloc_r+0x29c>
800089f4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800089f8:	ed e8 10 08 	or	r8,r6,r8
800089fc:	8f 18       	st.w	r7[0x4],r8
800089fe:	12 98       	mov	r8,r9
80008a00:	a1 a8       	sbr	r8,0x0
80008a02:	ee 06 00 0b 	add	r11,r7,r6
80008a06:	f6 09 00 09 	add	r9,r11,r9
80008a0a:	97 18       	st.w	r11[0x4],r8
80008a0c:	72 18       	ld.w	r8,r9[0x4]
80008a0e:	a1 a8       	sbr	r8,0x0
80008a10:	2f 8b       	sub	r11,-8
80008a12:	93 18       	st.w	r9[0x4],r8
80008a14:	04 9c       	mov	r12,r2
80008a16:	e0 a0 1a 43 	rcall	8000be9c <_free_r>
80008a1a:	c0 b8       	rjmp	80008a30 <_realloc_r+0x2b0>
80008a1c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a20:	e7 e8 10 08 	or	r8,r3,r8
80008a24:	8f 18       	st.w	r7[0x4],r8
80008a26:	ee 03 00 03 	add	r3,r7,r3
80008a2a:	66 18       	ld.w	r8,r3[0x4]
80008a2c:	a1 a8       	sbr	r8,0x0
80008a2e:	87 18       	st.w	r3[0x4],r8
80008a30:	04 9c       	mov	r12,r2
80008a32:	ee c5 ff f8 	sub	r5,r7,-8
80008a36:	fe b0 f1 7b 	rcall	80006d2c <__malloc_unlock>
80008a3a:	0a 9c       	mov	r12,r5
80008a3c:	2f fd       	sub	sp,-4
80008a3e:	d8 32       	popm	r0-r7,pc

80008a40 <_sbrk_r>:
80008a40:	d4 21       	pushm	r4-r7,lr
80008a42:	30 08       	mov	r8,0
80008a44:	18 97       	mov	r7,r12
80008a46:	e0 66 54 40 	mov	r6,21568
80008a4a:	16 9c       	mov	r12,r11
80008a4c:	8d 08       	st.w	r6[0x0],r8
80008a4e:	c8 5c       	rcall	80008b58 <_sbrk>
80008a50:	5b fc       	cp.w	r12,-1
80008a52:	c0 51       	brne	80008a5c <_sbrk_r+0x1c>
80008a54:	6c 08       	ld.w	r8,r6[0x0]
80008a56:	58 08       	cp.w	r8,0
80008a58:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008a5c:	d8 22       	popm	r4-r7,pc
80008a5e:	d7 03       	nop

80008a60 <sprintf>:
80008a60:	d4 01       	pushm	lr
80008a62:	21 7d       	sub	sp,92
80008a64:	e0 68 ff ff 	mov	r8,65535
80008a68:	ea 18 7f ff 	orh	r8,0x7fff
80008a6c:	50 58       	stdsp	sp[0x14],r8
80008a6e:	50 28       	stdsp	sp[0x8],r8
80008a70:	e0 68 02 08 	mov	r8,520
80008a74:	ba 68       	st.h	sp[0xc],r8
80008a76:	3f f8       	mov	r8,-1
80008a78:	ba 78       	st.h	sp[0xe],r8
80008a7a:	e0 68 0a 50 	mov	r8,2640
80008a7e:	50 4c       	stdsp	sp[0x10],r12
80008a80:	16 9a       	mov	r10,r11
80008a82:	50 0c       	stdsp	sp[0x0],r12
80008a84:	fa c9 ff a0 	sub	r9,sp,-96
80008a88:	70 0c       	ld.w	r12,r8[0x0]
80008a8a:	1a 9b       	mov	r11,sp
80008a8c:	e0 a0 02 1a 	rcall	80008ec0 <_vfprintf_r>
80008a90:	30 09       	mov	r9,0
80008a92:	40 08       	lddsp	r8,sp[0x0]
80008a94:	b0 89       	st.b	r8[0x0],r9
80008a96:	2e 9d       	sub	sp,-92
80008a98:	d8 02       	popm	pc
80008a9a:	d7 03       	nop

80008a9c <strncpy>:
80008a9c:	30 08       	mov	r8,0
80008a9e:	10 3a       	cp.w	r10,r8
80008aa0:	5e 0c       	reteq	r12
80008aa2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008aa6:	f8 08 0b 09 	st.b	r12[r8],r9
80008aaa:	2f f8       	sub	r8,-1
80008aac:	58 09       	cp.w	r9,0
80008aae:	cf 81       	brne	80008a9e <strncpy+0x2>
80008ab0:	10 3a       	cp.w	r10,r8
80008ab2:	5e 0c       	reteq	r12
80008ab4:	f8 08 0b 09 	st.b	r12[r8],r9
80008ab8:	2f f8       	sub	r8,-1
80008aba:	cf bb       	rjmp	80008ab0 <strncpy+0x14>

80008abc <_close>:
80008abc:	30 28       	mov	r8,2
80008abe:	d6 73       	breakpoint
80008ac0:	3f fc       	mov	r12,-1
80008ac2:	35 8b       	mov	r11,88
80008ac4:	58 0c       	cp.w	r12,0
80008ac6:	5e 4c       	retge	r12
80008ac8:	e0 6a 54 40 	mov	r10,21568
80008acc:	95 0b       	st.w	r10[0x0],r11
80008ace:	5e fc       	retal	r12

80008ad0 <_lseek>:
80008ad0:	30 58       	mov	r8,5
80008ad2:	d6 73       	breakpoint
80008ad4:	3f fc       	mov	r12,-1
80008ad6:	35 8b       	mov	r11,88
80008ad8:	58 0c       	cp.w	r12,0
80008ada:	5e 4c       	retge	r12
80008adc:	e0 6a 54 40 	mov	r10,21568
80008ae0:	95 0b       	st.w	r10[0x0],r11
80008ae2:	5e fc       	retal	r12

80008ae4 <isatty>:
80008ae4:	30 b8       	mov	r8,11
80008ae6:	d6 73       	breakpoint
80008ae8:	3f fc       	mov	r12,-1
80008aea:	35 8b       	mov	r11,88
80008aec:	58 0c       	cp.w	r12,0
80008aee:	5e 4c       	retge	r12
80008af0:	e0 6a 54 40 	mov	r10,21568
80008af4:	95 0b       	st.w	r10[0x0],r11
80008af6:	5e fc       	retal	r12

80008af8 <_fstat_host>:
80008af8:	30 98       	mov	r8,9
80008afa:	d6 73       	breakpoint
80008afc:	3f fc       	mov	r12,-1
80008afe:	35 8b       	mov	r11,88
80008b00:	58 0c       	cp.w	r12,0
80008b02:	5e 4c       	retge	r12
80008b04:	e0 6a 54 40 	mov	r10,21568
80008b08:	95 0b       	st.w	r10[0x0],r11
80008b0a:	5e fc       	retal	r12

80008b0c <_fstat>:
80008b0c:	d4 21       	pushm	r4-r7,lr
80008b0e:	21 0d       	sub	sp,64
80008b10:	16 97       	mov	r7,r11
80008b12:	1a 9b       	mov	r11,sp
80008b14:	cf 2f       	rcall	80008af8 <_fstat_host>
80008b16:	c0 34       	brge	80008b1c <_fstat+0x10>
80008b18:	3f fc       	mov	r12,-1
80008b1a:	c1 c8       	rjmp	80008b52 <_fstat+0x46>
80008b1c:	40 08       	lddsp	r8,sp[0x0]
80008b1e:	ae 08       	st.h	r7[0x0],r8
80008b20:	40 18       	lddsp	r8,sp[0x4]
80008b22:	ae 18       	st.h	r7[0x2],r8
80008b24:	40 28       	lddsp	r8,sp[0x8]
80008b26:	8f 18       	st.w	r7[0x4],r8
80008b28:	40 38       	lddsp	r8,sp[0xc]
80008b2a:	ae 48       	st.h	r7[0x8],r8
80008b2c:	40 48       	lddsp	r8,sp[0x10]
80008b2e:	ae 58       	st.h	r7[0xa],r8
80008b30:	40 58       	lddsp	r8,sp[0x14]
80008b32:	ae 68       	st.h	r7[0xc],r8
80008b34:	40 68       	lddsp	r8,sp[0x18]
80008b36:	ae 78       	st.h	r7[0xe],r8
80008b38:	40 88       	lddsp	r8,sp[0x20]
80008b3a:	8f 48       	st.w	r7[0x10],r8
80008b3c:	40 a8       	lddsp	r8,sp[0x28]
80008b3e:	8f b8       	st.w	r7[0x2c],r8
80008b40:	40 c8       	lddsp	r8,sp[0x30]
80008b42:	8f c8       	st.w	r7[0x30],r8
80008b44:	40 d8       	lddsp	r8,sp[0x34]
80008b46:	8f 58       	st.w	r7[0x14],r8
80008b48:	40 e8       	lddsp	r8,sp[0x38]
80008b4a:	30 0c       	mov	r12,0
80008b4c:	8f 78       	st.w	r7[0x1c],r8
80008b4e:	40 f8       	lddsp	r8,sp[0x3c]
80008b50:	8f 98       	st.w	r7[0x24],r8
80008b52:	2f 0d       	sub	sp,-64
80008b54:	d8 22       	popm	r4-r7,pc
80008b56:	d7 03       	nop

80008b58 <_sbrk>:
80008b58:	d4 01       	pushm	lr
80008b5a:	e0 68 0e 10 	mov	r8,3600
80008b5e:	70 09       	ld.w	r9,r8[0x0]
80008b60:	58 09       	cp.w	r9,0
80008b62:	c0 41       	brne	80008b6a <_sbrk+0x12>
80008b64:	e0 69 54 48 	mov	r9,21576
80008b68:	91 09       	st.w	r8[0x0],r9
80008b6a:	e0 69 0e 10 	mov	r9,3600
80008b6e:	e0 7a 70 00 	mov	r10,94208
80008b72:	72 08       	ld.w	r8,r9[0x0]
80008b74:	f0 0c 00 0c 	add	r12,r8,r12
80008b78:	14 3c       	cp.w	r12,r10
80008b7a:	e0 8b 00 04 	brhi	80008b82 <_sbrk+0x2a>
80008b7e:	93 0c       	st.w	r9[0x0],r12
80008b80:	c0 68       	rjmp	80008b8c <_sbrk+0x34>
80008b82:	e0 a0 18 15 	rcall	8000bbac <__errno>
80008b86:	30 c8       	mov	r8,12
80008b88:	99 08       	st.w	r12[0x0],r8
80008b8a:	3f f8       	mov	r8,-1
80008b8c:	10 9c       	mov	r12,r8
80008b8e:	d8 02       	popm	pc

80008b90 <get_arg>:
80008b90:	d4 31       	pushm	r0-r7,lr
80008b92:	20 8d       	sub	sp,32
80008b94:	fa c4 ff bc 	sub	r4,sp,-68
80008b98:	50 4b       	stdsp	sp[0x10],r11
80008b9a:	68 2e       	ld.w	lr,r4[0x8]
80008b9c:	50 58       	stdsp	sp[0x14],r8
80008b9e:	12 96       	mov	r6,r9
80008ba0:	7c 0b       	ld.w	r11,lr[0x0]
80008ba2:	70 05       	ld.w	r5,r8[0x0]
80008ba4:	50 6e       	stdsp	sp[0x18],lr
80008ba6:	58 0b       	cp.w	r11,0
80008ba8:	f4 0b 17 00 	moveq	r11,r10
80008bac:	68 03       	ld.w	r3,r4[0x0]
80008bae:	68 11       	ld.w	r1,r4[0x4]
80008bb0:	40 49       	lddsp	r9,sp[0x10]
80008bb2:	30 08       	mov	r8,0
80008bb4:	c2 89       	rjmp	80008e04 <get_arg+0x274>
80008bb6:	2f fb       	sub	r11,-1
80008bb8:	32 5c       	mov	r12,37
80008bba:	17 8a       	ld.ub	r10,r11[0x0]
80008bbc:	f8 0a 18 00 	cp.b	r10,r12
80008bc0:	5f 1e       	srne	lr
80008bc2:	f0 0a 18 00 	cp.b	r10,r8
80008bc6:	5f 1c       	srne	r12
80008bc8:	fd ec 00 0c 	and	r12,lr,r12
80008bcc:	f0 0c 18 00 	cp.b	r12,r8
80008bd0:	cf 31       	brne	80008bb6 <get_arg+0x26>
80008bd2:	58 0a       	cp.w	r10,0
80008bd4:	e0 80 01 25 	breq	80008e1e <get_arg+0x28e>
80008bd8:	30 0c       	mov	r12,0
80008bda:	3f fa       	mov	r10,-1
80008bdc:	18 90       	mov	r0,r12
80008bde:	50 3a       	stdsp	sp[0xc],r10
80008be0:	18 94       	mov	r4,r12
80008be2:	18 92       	mov	r2,r12
80008be4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008be8:	16 97       	mov	r7,r11
80008bea:	50 7c       	stdsp	sp[0x1c],r12
80008bec:	fe cc 9b 10 	sub	r12,pc,-25840
80008bf0:	0f 3a       	ld.ub	r10,r7++
80008bf2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008bf6:	40 7c       	lddsp	r12,sp[0x1c]
80008bf8:	1c 0c       	add	r12,lr
80008bfa:	fe ce 9b e6 	sub	lr,pc,-25626
80008bfe:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008c02:	20 1e       	sub	lr,1
80008c04:	50 0e       	stdsp	sp[0x0],lr
80008c06:	fe ce 9c 5e 	sub	lr,pc,-25506
80008c0a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008c0e:	50 7c       	stdsp	sp[0x1c],r12
80008c10:	40 0c       	lddsp	r12,sp[0x0]
80008c12:	58 7c       	cp.w	r12,7
80008c14:	e0 8b 00 f1 	brhi	80008df6 <get_arg+0x266>
80008c18:	fe ce 9e 10 	sub	lr,pc,-25072
80008c1c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008c20:	36 8b       	mov	r11,104
80008c22:	f6 0a 18 00 	cp.b	r10,r11
80008c26:	e0 80 00 e8 	breq	80008df6 <get_arg+0x266>
80008c2a:	37 1b       	mov	r11,113
80008c2c:	f6 0a 18 00 	cp.b	r10,r11
80008c30:	c0 70       	breq	80008c3e <get_arg+0xae>
80008c32:	34 cb       	mov	r11,76
80008c34:	f6 0a 18 00 	cp.b	r10,r11
80008c38:	c0 51       	brne	80008c42 <get_arg+0xb2>
80008c3a:	a3 b4       	sbr	r4,0x3
80008c3c:	cd d8       	rjmp	80008df6 <get_arg+0x266>
80008c3e:	a5 b4       	sbr	r4,0x5
80008c40:	cd b8       	rjmp	80008df6 <get_arg+0x266>
80008c42:	08 9a       	mov	r10,r4
80008c44:	0e 9b       	mov	r11,r7
80008c46:	a5 aa       	sbr	r10,0x4
80008c48:	17 3c       	ld.ub	r12,r11++
80008c4a:	a5 b4       	sbr	r4,0x5
80008c4c:	36 ce       	mov	lr,108
80008c4e:	fc 0c 18 00 	cp.b	r12,lr
80008c52:	e0 80 00 d3 	breq	80008df8 <get_arg+0x268>
80008c56:	14 94       	mov	r4,r10
80008c58:	cc f8       	rjmp	80008df6 <get_arg+0x266>
80008c5a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008c5e:	36 7c       	mov	r12,103
80008c60:	f8 0a 18 00 	cp.b	r10,r12
80008c64:	e0 8b 00 27 	brhi	80008cb2 <get_arg+0x122>
80008c68:	36 5b       	mov	r11,101
80008c6a:	f6 0a 18 00 	cp.b	r10,r11
80008c6e:	c4 82       	brcc	80008cfe <get_arg+0x16e>
80008c70:	34 fb       	mov	r11,79
80008c72:	f6 0a 18 00 	cp.b	r10,r11
80008c76:	c4 80       	breq	80008d06 <get_arg+0x176>
80008c78:	e0 8b 00 0c 	brhi	80008c90 <get_arg+0x100>
80008c7c:	34 5b       	mov	r11,69
80008c7e:	f6 0a 18 00 	cp.b	r10,r11
80008c82:	c3 e0       	breq	80008cfe <get_arg+0x16e>
80008c84:	34 7b       	mov	r11,71
80008c86:	f6 0a 18 00 	cp.b	r10,r11
80008c8a:	c3 a0       	breq	80008cfe <get_arg+0x16e>
80008c8c:	34 4b       	mov	r11,68
80008c8e:	c0 88       	rjmp	80008c9e <get_arg+0x10e>
80008c90:	35 8b       	mov	r11,88
80008c92:	f6 0a 18 00 	cp.b	r10,r11
80008c96:	c2 c0       	breq	80008cee <get_arg+0x15e>
80008c98:	e0 8b 00 07 	brhi	80008ca6 <get_arg+0x116>
80008c9c:	35 5b       	mov	r11,85
80008c9e:	f6 0a 18 00 	cp.b	r10,r11
80008ca2:	c3 51       	brne	80008d0c <get_arg+0x17c>
80008ca4:	c3 18       	rjmp	80008d06 <get_arg+0x176>
80008ca6:	36 3b       	mov	r11,99
80008ca8:	f6 0a 18 00 	cp.b	r10,r11
80008cac:	c2 f0       	breq	80008d0a <get_arg+0x17a>
80008cae:	36 4b       	mov	r11,100
80008cb0:	c0 e8       	rjmp	80008ccc <get_arg+0x13c>
80008cb2:	37 0b       	mov	r11,112
80008cb4:	f6 0a 18 00 	cp.b	r10,r11
80008cb8:	c2 50       	breq	80008d02 <get_arg+0x172>
80008cba:	e0 8b 00 0d 	brhi	80008cd4 <get_arg+0x144>
80008cbe:	36 eb       	mov	r11,110
80008cc0:	f6 0a 18 00 	cp.b	r10,r11
80008cc4:	c1 f0       	breq	80008d02 <get_arg+0x172>
80008cc6:	e0 8b 00 14 	brhi	80008cee <get_arg+0x15e>
80008cca:	36 9b       	mov	r11,105
80008ccc:	f6 0a 18 00 	cp.b	r10,r11
80008cd0:	c1 e1       	brne	80008d0c <get_arg+0x17c>
80008cd2:	c0 e8       	rjmp	80008cee <get_arg+0x15e>
80008cd4:	37 5b       	mov	r11,117
80008cd6:	f6 0a 18 00 	cp.b	r10,r11
80008cda:	c0 a0       	breq	80008cee <get_arg+0x15e>
80008cdc:	37 8b       	mov	r11,120
80008cde:	f6 0a 18 00 	cp.b	r10,r11
80008ce2:	c0 60       	breq	80008cee <get_arg+0x15e>
80008ce4:	37 3b       	mov	r11,115
80008ce6:	f6 0a 18 00 	cp.b	r10,r11
80008cea:	c1 11       	brne	80008d0c <get_arg+0x17c>
80008cec:	c0 b8       	rjmp	80008d02 <get_arg+0x172>
80008cee:	ed b4 00 04 	bld	r4,0x4
80008cf2:	c0 a0       	breq	80008d06 <get_arg+0x176>
80008cf4:	ed b4 00 05 	bld	r4,0x5
80008cf8:	c0 91       	brne	80008d0a <get_arg+0x17a>
80008cfa:	30 20       	mov	r0,2
80008cfc:	c0 88       	rjmp	80008d0c <get_arg+0x17c>
80008cfe:	30 40       	mov	r0,4
80008d00:	c0 68       	rjmp	80008d0c <get_arg+0x17c>
80008d02:	30 30       	mov	r0,3
80008d04:	c0 48       	rjmp	80008d0c <get_arg+0x17c>
80008d06:	30 10       	mov	r0,1
80008d08:	c0 28       	rjmp	80008d0c <get_arg+0x17c>
80008d0a:	30 00       	mov	r0,0
80008d0c:	40 3b       	lddsp	r11,sp[0xc]
80008d0e:	5b fb       	cp.w	r11,-1
80008d10:	c0 40       	breq	80008d18 <get_arg+0x188>
80008d12:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008d16:	c7 08       	rjmp	80008df6 <get_arg+0x266>
80008d18:	58 60       	cp.w	r0,6
80008d1a:	e0 8b 00 6e 	brhi	80008df6 <get_arg+0x266>
80008d1e:	6c 0a       	ld.w	r10,r6[0x0]
80008d20:	ea cc ff ff 	sub	r12,r5,-1
80008d24:	fe ce 9e fc 	sub	lr,pc,-24836
80008d28:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008d2c:	f4 cb ff f8 	sub	r11,r10,-8
80008d30:	8d 0b       	st.w	r6[0x0],r11
80008d32:	f4 ea 00 00 	ld.d	r10,r10[0]
80008d36:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008d3a:	c0 f8       	rjmp	80008d58 <get_arg+0x1c8>
80008d3c:	f4 cb ff fc 	sub	r11,r10,-4
80008d40:	8d 0b       	st.w	r6[0x0],r11
80008d42:	74 0a       	ld.w	r10,r10[0x0]
80008d44:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008d48:	c0 88       	rjmp	80008d58 <get_arg+0x1c8>
80008d4a:	f4 cb ff f8 	sub	r11,r10,-8
80008d4e:	8d 0b       	st.w	r6[0x0],r11
80008d50:	f4 ea 00 00 	ld.d	r10,r10[0]
80008d54:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008d58:	0e 9b       	mov	r11,r7
80008d5a:	18 95       	mov	r5,r12
80008d5c:	c4 e8       	rjmp	80008df8 <get_arg+0x268>
80008d5e:	62 0a       	ld.w	r10,r1[0x0]
80008d60:	5b fa       	cp.w	r10,-1
80008d62:	c0 b1       	brne	80008d78 <get_arg+0x1e8>
80008d64:	50 19       	stdsp	sp[0x4],r9
80008d66:	50 28       	stdsp	sp[0x8],r8
80008d68:	e0 6a 00 80 	mov	r10,128
80008d6c:	30 0b       	mov	r11,0
80008d6e:	02 9c       	mov	r12,r1
80008d70:	fe b0 fd 01 	rcall	80008772 <memset>
80008d74:	40 28       	lddsp	r8,sp[0x8]
80008d76:	40 19       	lddsp	r9,sp[0x4]
80008d78:	e4 cc 00 01 	sub	r12,r2,1
80008d7c:	0e 9b       	mov	r11,r7
80008d7e:	50 3c       	stdsp	sp[0xc],r12
80008d80:	f2 0c 0c 49 	max	r9,r9,r12
80008d84:	c3 a8       	rjmp	80008df8 <get_arg+0x268>
80008d86:	62 0a       	ld.w	r10,r1[0x0]
80008d88:	5b fa       	cp.w	r10,-1
80008d8a:	c0 b1       	brne	80008da0 <get_arg+0x210>
80008d8c:	50 19       	stdsp	sp[0x4],r9
80008d8e:	50 28       	stdsp	sp[0x8],r8
80008d90:	e0 6a 00 80 	mov	r10,128
80008d94:	30 0b       	mov	r11,0
80008d96:	02 9c       	mov	r12,r1
80008d98:	fe b0 fc ed 	rcall	80008772 <memset>
80008d9c:	40 28       	lddsp	r8,sp[0x8]
80008d9e:	40 19       	lddsp	r9,sp[0x4]
80008da0:	20 12       	sub	r2,1
80008da2:	30 0a       	mov	r10,0
80008da4:	0e 9b       	mov	r11,r7
80008da6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008daa:	f2 02 0c 49 	max	r9,r9,r2
80008dae:	c2 58       	rjmp	80008df8 <get_arg+0x268>
80008db0:	16 97       	mov	r7,r11
80008db2:	6c 0a       	ld.w	r10,r6[0x0]
80008db4:	f4 cb ff fc 	sub	r11,r10,-4
80008db8:	8d 0b       	st.w	r6[0x0],r11
80008dba:	74 0a       	ld.w	r10,r10[0x0]
80008dbc:	0e 9b       	mov	r11,r7
80008dbe:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008dc2:	2f f5       	sub	r5,-1
80008dc4:	c1 a8       	rjmp	80008df8 <get_arg+0x268>
80008dc6:	f4 c2 00 30 	sub	r2,r10,48
80008dca:	c0 68       	rjmp	80008dd6 <get_arg+0x246>
80008dcc:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008dd0:	2f f7       	sub	r7,-1
80008dd2:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008dd6:	0f 8a       	ld.ub	r10,r7[0x0]
80008dd8:	58 0a       	cp.w	r10,0
80008dda:	c0 e0       	breq	80008df6 <get_arg+0x266>
80008ddc:	23 0a       	sub	r10,48
80008dde:	58 9a       	cp.w	r10,9
80008de0:	fe 98 ff f6 	brls	80008dcc <get_arg+0x23c>
80008de4:	c0 98       	rjmp	80008df6 <get_arg+0x266>
80008de6:	2f f7       	sub	r7,-1
80008de8:	0f 8a       	ld.ub	r10,r7[0x0]
80008dea:	58 0a       	cp.w	r10,0
80008dec:	c0 50       	breq	80008df6 <get_arg+0x266>
80008dee:	23 0a       	sub	r10,48
80008df0:	58 9a       	cp.w	r10,9
80008df2:	fe 98 ff fa 	brls	80008de6 <get_arg+0x256>
80008df6:	0e 9b       	mov	r11,r7
80008df8:	40 7c       	lddsp	r12,sp[0x1c]
80008dfa:	30 ba       	mov	r10,11
80008dfc:	f4 0c 18 00 	cp.b	r12,r10
80008e00:	fe 91 fe f2 	brne	80008be4 <get_arg+0x54>
80008e04:	40 42       	lddsp	r2,sp[0x10]
80008e06:	17 8c       	ld.ub	r12,r11[0x0]
80008e08:	0a 32       	cp.w	r2,r5
80008e0a:	5f 4a       	srge	r10
80008e0c:	f0 0c 18 00 	cp.b	r12,r8
80008e10:	5f 1c       	srne	r12
80008e12:	f9 ea 00 0a 	and	r10,r12,r10
80008e16:	f0 0a 18 00 	cp.b	r10,r8
80008e1a:	fe 91 fe cf 	brne	80008bb8 <get_arg+0x28>
80008e1e:	30 08       	mov	r8,0
80008e20:	40 4e       	lddsp	lr,sp[0x10]
80008e22:	17 8a       	ld.ub	r10,r11[0x0]
80008e24:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008e28:	f0 0a 18 00 	cp.b	r10,r8
80008e2c:	fc 09 17 10 	movne	r9,lr
80008e30:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008e34:	06 9e       	mov	lr,r3
80008e36:	c2 a8       	rjmp	80008e8a <get_arg+0x2fa>
80008e38:	62 0a       	ld.w	r10,r1[0x0]
80008e3a:	58 3a       	cp.w	r10,3
80008e3c:	c1 e0       	breq	80008e78 <get_arg+0x2e8>
80008e3e:	e0 89 00 07 	brgt	80008e4c <get_arg+0x2bc>
80008e42:	58 1a       	cp.w	r10,1
80008e44:	c1 a0       	breq	80008e78 <get_arg+0x2e8>
80008e46:	58 2a       	cp.w	r10,2
80008e48:	c1 81       	brne	80008e78 <get_arg+0x2e8>
80008e4a:	c0 58       	rjmp	80008e54 <get_arg+0x2c4>
80008e4c:	58 5a       	cp.w	r10,5
80008e4e:	c0 c0       	breq	80008e66 <get_arg+0x2d6>
80008e50:	c0 b5       	brlt	80008e66 <get_arg+0x2d6>
80008e52:	c1 38       	rjmp	80008e78 <get_arg+0x2e8>
80008e54:	6c 0a       	ld.w	r10,r6[0x0]
80008e56:	f4 cc ff f8 	sub	r12,r10,-8
80008e5a:	8d 0c       	st.w	r6[0x0],r12
80008e5c:	f4 e2 00 00 	ld.d	r2,r10[0]
80008e60:	f0 e3 00 00 	st.d	r8[0],r2
80008e64:	c1 08       	rjmp	80008e84 <get_arg+0x2f4>
80008e66:	6c 0a       	ld.w	r10,r6[0x0]
80008e68:	f4 cc ff f8 	sub	r12,r10,-8
80008e6c:	8d 0c       	st.w	r6[0x0],r12
80008e6e:	f4 e2 00 00 	ld.d	r2,r10[0]
80008e72:	f0 e3 00 00 	st.d	r8[0],r2
80008e76:	c0 78       	rjmp	80008e84 <get_arg+0x2f4>
80008e78:	6c 0a       	ld.w	r10,r6[0x0]
80008e7a:	f4 cc ff fc 	sub	r12,r10,-4
80008e7e:	8d 0c       	st.w	r6[0x0],r12
80008e80:	74 0a       	ld.w	r10,r10[0x0]
80008e82:	91 0a       	st.w	r8[0x0],r10
80008e84:	2f f5       	sub	r5,-1
80008e86:	2f 88       	sub	r8,-8
80008e88:	2f c1       	sub	r1,-4
80008e8a:	12 35       	cp.w	r5,r9
80008e8c:	fe 9a ff d6 	brle	80008e38 <get_arg+0x2a8>
80008e90:	1c 93       	mov	r3,lr
80008e92:	40 52       	lddsp	r2,sp[0x14]
80008e94:	40 6e       	lddsp	lr,sp[0x18]
80008e96:	85 05       	st.w	r2[0x0],r5
80008e98:	9d 0b       	st.w	lr[0x0],r11
80008e9a:	40 4b       	lddsp	r11,sp[0x10]
80008e9c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008ea0:	2f 8d       	sub	sp,-32
80008ea2:	d8 32       	popm	r0-r7,pc

80008ea4 <__sprint_r>:
80008ea4:	d4 21       	pushm	r4-r7,lr
80008ea6:	14 97       	mov	r7,r10
80008ea8:	74 28       	ld.w	r8,r10[0x8]
80008eaa:	58 08       	cp.w	r8,0
80008eac:	c0 41       	brne	80008eb4 <__sprint_r+0x10>
80008eae:	95 18       	st.w	r10[0x4],r8
80008eb0:	10 9c       	mov	r12,r8
80008eb2:	d8 22       	popm	r4-r7,pc
80008eb4:	e0 a0 18 ba 	rcall	8000c028 <__sfvwrite_r>
80008eb8:	30 08       	mov	r8,0
80008eba:	8f 18       	st.w	r7[0x4],r8
80008ebc:	8f 28       	st.w	r7[0x8],r8
80008ebe:	d8 22       	popm	r4-r7,pc

80008ec0 <_vfprintf_r>:
80008ec0:	d4 31       	pushm	r0-r7,lr
80008ec2:	fa cd 06 bc 	sub	sp,sp,1724
80008ec6:	51 09       	stdsp	sp[0x40],r9
80008ec8:	16 91       	mov	r1,r11
80008eca:	14 97       	mov	r7,r10
80008ecc:	18 95       	mov	r5,r12
80008ece:	e0 a0 1a 1d 	rcall	8000c308 <_localeconv_r>
80008ed2:	78 0c       	ld.w	r12,r12[0x0]
80008ed4:	50 cc       	stdsp	sp[0x30],r12
80008ed6:	58 05       	cp.w	r5,0
80008ed8:	c0 70       	breq	80008ee6 <_vfprintf_r+0x26>
80008eda:	6a 68       	ld.w	r8,r5[0x18]
80008edc:	58 08       	cp.w	r8,0
80008ede:	c0 41       	brne	80008ee6 <_vfprintf_r+0x26>
80008ee0:	0a 9c       	mov	r12,r5
80008ee2:	e0 a0 17 43 	rcall	8000bd68 <__sinit>
80008ee6:	fe c8 9c fa 	sub	r8,pc,-25350
80008eea:	10 31       	cp.w	r1,r8
80008eec:	c0 31       	brne	80008ef2 <_vfprintf_r+0x32>
80008eee:	6a 01       	ld.w	r1,r5[0x0]
80008ef0:	c0 c8       	rjmp	80008f08 <_vfprintf_r+0x48>
80008ef2:	fe c8 9c e6 	sub	r8,pc,-25370
80008ef6:	10 31       	cp.w	r1,r8
80008ef8:	c0 31       	brne	80008efe <_vfprintf_r+0x3e>
80008efa:	6a 11       	ld.w	r1,r5[0x4]
80008efc:	c0 68       	rjmp	80008f08 <_vfprintf_r+0x48>
80008efe:	fe c8 9c d2 	sub	r8,pc,-25390
80008f02:	10 31       	cp.w	r1,r8
80008f04:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008f08:	82 68       	ld.sh	r8,r1[0xc]
80008f0a:	ed b8 00 03 	bld	r8,0x3
80008f0e:	c0 41       	brne	80008f16 <_vfprintf_r+0x56>
80008f10:	62 48       	ld.w	r8,r1[0x10]
80008f12:	58 08       	cp.w	r8,0
80008f14:	c0 71       	brne	80008f22 <_vfprintf_r+0x62>
80008f16:	02 9b       	mov	r11,r1
80008f18:	0a 9c       	mov	r12,r5
80008f1a:	e0 a0 0f 5d 	rcall	8000add4 <__swsetup_r>
80008f1e:	e0 81 0f 54 	brne	8000adc6 <_vfprintf_r+0x1f06>
80008f22:	82 68       	ld.sh	r8,r1[0xc]
80008f24:	10 99       	mov	r9,r8
80008f26:	e2 19 00 1a 	andl	r9,0x1a,COH
80008f2a:	58 a9       	cp.w	r9,10
80008f2c:	c3 c1       	brne	80008fa4 <_vfprintf_r+0xe4>
80008f2e:	82 79       	ld.sh	r9,r1[0xe]
80008f30:	30 0a       	mov	r10,0
80008f32:	f4 09 19 00 	cp.h	r9,r10
80008f36:	c3 75       	brlt	80008fa4 <_vfprintf_r+0xe4>
80008f38:	a1 d8       	cbr	r8,0x1
80008f3a:	fb 58 05 d0 	st.h	sp[1488],r8
80008f3e:	62 88       	ld.w	r8,r1[0x20]
80008f40:	fb 48 05 e4 	st.w	sp[1508],r8
80008f44:	62 a8       	ld.w	r8,r1[0x28]
80008f46:	fb 48 05 ec 	st.w	sp[1516],r8
80008f4a:	fa c8 ff bc 	sub	r8,sp,-68
80008f4e:	fb 48 05 d4 	st.w	sp[1492],r8
80008f52:	fb 48 05 c4 	st.w	sp[1476],r8
80008f56:	e0 68 04 00 	mov	r8,1024
80008f5a:	fb 48 05 d8 	st.w	sp[1496],r8
80008f5e:	fb 48 05 cc 	st.w	sp[1484],r8
80008f62:	30 08       	mov	r8,0
80008f64:	fb 59 05 d2 	st.h	sp[1490],r9
80008f68:	0e 9a       	mov	r10,r7
80008f6a:	41 09       	lddsp	r9,sp[0x40]
80008f6c:	fa c7 fa 3c 	sub	r7,sp,-1476
80008f70:	fb 48 05 dc 	st.w	sp[1500],r8
80008f74:	0a 9c       	mov	r12,r5
80008f76:	0e 9b       	mov	r11,r7
80008f78:	ca 4f       	rcall	80008ec0 <_vfprintf_r>
80008f7a:	50 bc       	stdsp	sp[0x2c],r12
80008f7c:	c0 95       	brlt	80008f8e <_vfprintf_r+0xce>
80008f7e:	0e 9b       	mov	r11,r7
80008f80:	0a 9c       	mov	r12,r5
80008f82:	e0 a0 16 1b 	rcall	8000bbb8 <_fflush_r>
80008f86:	40 be       	lddsp	lr,sp[0x2c]
80008f88:	f9 be 01 ff 	movne	lr,-1
80008f8c:	50 be       	stdsp	sp[0x2c],lr
80008f8e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008f92:	ed b8 00 06 	bld	r8,0x6
80008f96:	e0 81 0f 1a 	brne	8000adca <_vfprintf_r+0x1f0a>
80008f9a:	82 68       	ld.sh	r8,r1[0xc]
80008f9c:	a7 a8       	sbr	r8,0x6
80008f9e:	a2 68       	st.h	r1[0xc],r8
80008fa0:	e0 8f 0f 15 	bral	8000adca <_vfprintf_r+0x1f0a>
80008fa4:	30 08       	mov	r8,0
80008fa6:	fb 48 06 b4 	st.w	sp[1716],r8
80008faa:	fb 48 06 90 	st.w	sp[1680],r8
80008fae:	fb 48 06 8c 	st.w	sp[1676],r8
80008fb2:	fb 48 06 b0 	st.w	sp[1712],r8
80008fb6:	30 08       	mov	r8,0
80008fb8:	30 09       	mov	r9,0
80008fba:	50 a7       	stdsp	sp[0x28],r7
80008fbc:	50 78       	stdsp	sp[0x1c],r8
80008fbe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fc2:	3f f8       	mov	r8,-1
80008fc4:	50 59       	stdsp	sp[0x14],r9
80008fc6:	fb 43 06 88 	st.w	sp[1672],r3
80008fca:	fb 48 05 44 	st.w	sp[1348],r8
80008fce:	12 9c       	mov	r12,r9
80008fd0:	50 69       	stdsp	sp[0x18],r9
80008fd2:	50 d9       	stdsp	sp[0x34],r9
80008fd4:	50 e9       	stdsp	sp[0x38],r9
80008fd6:	50 b9       	stdsp	sp[0x2c],r9
80008fd8:	12 97       	mov	r7,r9
80008fda:	0a 94       	mov	r4,r5
80008fdc:	40 a2       	lddsp	r2,sp[0x28]
80008fde:	32 5a       	mov	r10,37
80008fe0:	30 08       	mov	r8,0
80008fe2:	c0 28       	rjmp	80008fe6 <_vfprintf_r+0x126>
80008fe4:	2f f2       	sub	r2,-1
80008fe6:	05 89       	ld.ub	r9,r2[0x0]
80008fe8:	f0 09 18 00 	cp.b	r9,r8
80008fec:	5f 1b       	srne	r11
80008fee:	f4 09 18 00 	cp.b	r9,r10
80008ff2:	5f 19       	srne	r9
80008ff4:	f3 eb 00 0b 	and	r11,r9,r11
80008ff8:	f0 0b 18 00 	cp.b	r11,r8
80008ffc:	cf 41       	brne	80008fe4 <_vfprintf_r+0x124>
80008ffe:	40 ab       	lddsp	r11,sp[0x28]
80009000:	e4 0b 01 06 	sub	r6,r2,r11
80009004:	c1 e0       	breq	80009040 <_vfprintf_r+0x180>
80009006:	fa f8 06 90 	ld.w	r8,sp[1680]
8000900a:	0c 08       	add	r8,r6
8000900c:	87 0b       	st.w	r3[0x0],r11
8000900e:	fb 48 06 90 	st.w	sp[1680],r8
80009012:	87 16       	st.w	r3[0x4],r6
80009014:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009018:	2f f8       	sub	r8,-1
8000901a:	fb 48 06 8c 	st.w	sp[1676],r8
8000901e:	58 78       	cp.w	r8,7
80009020:	e0 89 00 04 	brgt	80009028 <_vfprintf_r+0x168>
80009024:	2f 83       	sub	r3,-8
80009026:	c0 a8       	rjmp	8000903a <_vfprintf_r+0x17a>
80009028:	fa ca f9 78 	sub	r10,sp,-1672
8000902c:	02 9b       	mov	r11,r1
8000902e:	08 9c       	mov	r12,r4
80009030:	c3 af       	rcall	80008ea4 <__sprint_r>
80009032:	e0 81 0e c6 	brne	8000adbe <_vfprintf_r+0x1efe>
80009036:	fa c3 f9 e0 	sub	r3,sp,-1568
8000903a:	40 ba       	lddsp	r10,sp[0x2c]
8000903c:	0c 0a       	add	r10,r6
8000903e:	50 ba       	stdsp	sp[0x2c],r10
80009040:	05 89       	ld.ub	r9,r2[0x0]
80009042:	30 08       	mov	r8,0
80009044:	f0 09 18 00 	cp.b	r9,r8
80009048:	e0 80 0e aa 	breq	8000ad9c <_vfprintf_r+0x1edc>
8000904c:	30 09       	mov	r9,0
8000904e:	fb 68 06 bb 	st.b	sp[1723],r8
80009052:	0e 96       	mov	r6,r7
80009054:	e4 c8 ff ff 	sub	r8,r2,-1
80009058:	3f fe       	mov	lr,-1
8000905a:	50 93       	stdsp	sp[0x24],r3
8000905c:	50 41       	stdsp	sp[0x10],r1
8000905e:	0e 93       	mov	r3,r7
80009060:	04 91       	mov	r1,r2
80009062:	50 89       	stdsp	sp[0x20],r9
80009064:	50 a8       	stdsp	sp[0x28],r8
80009066:	50 2e       	stdsp	sp[0x8],lr
80009068:	50 39       	stdsp	sp[0xc],r9
8000906a:	12 95       	mov	r5,r9
8000906c:	12 90       	mov	r0,r9
8000906e:	10 97       	mov	r7,r8
80009070:	08 92       	mov	r2,r4
80009072:	c0 78       	rjmp	80009080 <_vfprintf_r+0x1c0>
80009074:	3f fc       	mov	r12,-1
80009076:	08 97       	mov	r7,r4
80009078:	50 2c       	stdsp	sp[0x8],r12
8000907a:	c0 38       	rjmp	80009080 <_vfprintf_r+0x1c0>
8000907c:	30 0b       	mov	r11,0
8000907e:	50 3b       	stdsp	sp[0xc],r11
80009080:	0f 38       	ld.ub	r8,r7++
80009082:	c0 28       	rjmp	80009086 <_vfprintf_r+0x1c6>
80009084:	12 90       	mov	r0,r9
80009086:	f0 c9 00 20 	sub	r9,r8,32
8000908a:	e0 49 00 58 	cp.w	r9,88
8000908e:	e0 8b 0a 30 	brhi	8000a4ee <_vfprintf_r+0x162e>
80009092:	fe ca a2 4e 	sub	r10,pc,-23986
80009096:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000909a:	50 a7       	stdsp	sp[0x28],r7
8000909c:	50 80       	stdsp	sp[0x20],r0
8000909e:	0c 97       	mov	r7,r6
800090a0:	04 94       	mov	r4,r2
800090a2:	06 96       	mov	r6,r3
800090a4:	02 92       	mov	r2,r1
800090a6:	fe c9 a0 26 	sub	r9,pc,-24538
800090aa:	40 93       	lddsp	r3,sp[0x24]
800090ac:	10 90       	mov	r0,r8
800090ae:	40 41       	lddsp	r1,sp[0x10]
800090b0:	50 d9       	stdsp	sp[0x34],r9
800090b2:	e0 8f 08 8e 	bral	8000a1ce <_vfprintf_r+0x130e>
800090b6:	30 08       	mov	r8,0
800090b8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800090bc:	f0 09 18 00 	cp.b	r9,r8
800090c0:	ce 01       	brne	80009080 <_vfprintf_r+0x1c0>
800090c2:	32 08       	mov	r8,32
800090c4:	c6 e8       	rjmp	800091a0 <_vfprintf_r+0x2e0>
800090c6:	a1 a5       	sbr	r5,0x0
800090c8:	cd cb       	rjmp	80009080 <_vfprintf_r+0x1c0>
800090ca:	0f 89       	ld.ub	r9,r7[0x0]
800090cc:	f2 c8 00 30 	sub	r8,r9,48
800090d0:	58 98       	cp.w	r8,9
800090d2:	e0 8b 00 1d 	brhi	8000910c <_vfprintf_r+0x24c>
800090d6:	ee c8 ff ff 	sub	r8,r7,-1
800090da:	30 0b       	mov	r11,0
800090dc:	23 09       	sub	r9,48
800090de:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800090e2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800090e6:	11 39       	ld.ub	r9,r8++
800090e8:	f2 ca 00 30 	sub	r10,r9,48
800090ec:	58 9a       	cp.w	r10,9
800090ee:	fe 98 ff f7 	brls	800090dc <_vfprintf_r+0x21c>
800090f2:	e0 49 00 24 	cp.w	r9,36
800090f6:	cc 31       	brne	8000907c <_vfprintf_r+0x1bc>
800090f8:	e0 4b 00 20 	cp.w	r11,32
800090fc:	e0 89 0e 60 	brgt	8000adbc <_vfprintf_r+0x1efc>
80009100:	20 1b       	sub	r11,1
80009102:	fa f9 06 b4 	ld.w	r9,sp[1716]
80009106:	12 3b       	cp.w	r11,r9
80009108:	c0 95       	brlt	8000911a <_vfprintf_r+0x25a>
8000910a:	c1 08       	rjmp	8000912a <_vfprintf_r+0x26a>
8000910c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80009110:	ec ca ff ff 	sub	r10,r6,-1
80009114:	12 36       	cp.w	r6,r9
80009116:	c1 f5       	brlt	80009154 <_vfprintf_r+0x294>
80009118:	c2 68       	rjmp	80009164 <_vfprintf_r+0x2a4>
8000911a:	fa ce f9 44 	sub	lr,sp,-1724
8000911e:	10 97       	mov	r7,r8
80009120:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80009124:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80009128:	c3 58       	rjmp	80009192 <_vfprintf_r+0x2d2>
8000912a:	10 97       	mov	r7,r8
8000912c:	fa c8 f9 50 	sub	r8,sp,-1712
80009130:	1a d8       	st.w	--sp,r8
80009132:	fa c8 fa b8 	sub	r8,sp,-1352
80009136:	1a d8       	st.w	--sp,r8
80009138:	fa c8 fb b4 	sub	r8,sp,-1100
8000913c:	02 9a       	mov	r10,r1
8000913e:	1a d8       	st.w	--sp,r8
80009140:	04 9c       	mov	r12,r2
80009142:	fa c8 f9 40 	sub	r8,sp,-1728
80009146:	fa c9 ff b4 	sub	r9,sp,-76
8000914a:	fe b0 fd 23 	rcall	80008b90 <get_arg>
8000914e:	2f dd       	sub	sp,-12
80009150:	78 00       	ld.w	r0,r12[0x0]
80009152:	c2 08       	rjmp	80009192 <_vfprintf_r+0x2d2>
80009154:	fa cc f9 44 	sub	r12,sp,-1724
80009158:	14 96       	mov	r6,r10
8000915a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000915e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80009162:	c1 88       	rjmp	80009192 <_vfprintf_r+0x2d2>
80009164:	41 08       	lddsp	r8,sp[0x40]
80009166:	59 f9       	cp.w	r9,31
80009168:	e0 89 00 11 	brgt	8000918a <_vfprintf_r+0x2ca>
8000916c:	f0 cb ff fc 	sub	r11,r8,-4
80009170:	51 0b       	stdsp	sp[0x40],r11
80009172:	70 00       	ld.w	r0,r8[0x0]
80009174:	fa cb f9 44 	sub	r11,sp,-1724
80009178:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000917c:	f1 40 fd 88 	st.w	r8[-632],r0
80009180:	2f f9       	sub	r9,-1
80009182:	14 96       	mov	r6,r10
80009184:	fb 49 06 b4 	st.w	sp[1716],r9
80009188:	c0 58       	rjmp	80009192 <_vfprintf_r+0x2d2>
8000918a:	70 00       	ld.w	r0,r8[0x0]
8000918c:	14 96       	mov	r6,r10
8000918e:	2f c8       	sub	r8,-4
80009190:	51 08       	stdsp	sp[0x40],r8
80009192:	58 00       	cp.w	r0,0
80009194:	fe 94 ff 76 	brge	80009080 <_vfprintf_r+0x1c0>
80009198:	5c 30       	neg	r0
8000919a:	a3 a5       	sbr	r5,0x2
8000919c:	c7 2b       	rjmp	80009080 <_vfprintf_r+0x1c0>
8000919e:	32 b8       	mov	r8,43
800091a0:	fb 68 06 bb 	st.b	sp[1723],r8
800091a4:	c6 eb       	rjmp	80009080 <_vfprintf_r+0x1c0>
800091a6:	0f 38       	ld.ub	r8,r7++
800091a8:	e0 48 00 2a 	cp.w	r8,42
800091ac:	c0 30       	breq	800091b2 <_vfprintf_r+0x2f2>
800091ae:	30 09       	mov	r9,0
800091b0:	c7 98       	rjmp	800092a2 <_vfprintf_r+0x3e2>
800091b2:	0f 88       	ld.ub	r8,r7[0x0]
800091b4:	f0 c9 00 30 	sub	r9,r8,48
800091b8:	58 99       	cp.w	r9,9
800091ba:	e0 8b 00 1f 	brhi	800091f8 <_vfprintf_r+0x338>
800091be:	ee c4 ff ff 	sub	r4,r7,-1
800091c2:	30 0b       	mov	r11,0
800091c4:	23 08       	sub	r8,48
800091c6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800091ca:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800091ce:	09 38       	ld.ub	r8,r4++
800091d0:	f0 c9 00 30 	sub	r9,r8,48
800091d4:	58 99       	cp.w	r9,9
800091d6:	fe 98 ff f7 	brls	800091c4 <_vfprintf_r+0x304>
800091da:	e0 48 00 24 	cp.w	r8,36
800091de:	fe 91 ff 4f 	brne	8000907c <_vfprintf_r+0x1bc>
800091e2:	e0 4b 00 20 	cp.w	r11,32
800091e6:	e0 89 0d eb 	brgt	8000adbc <_vfprintf_r+0x1efc>
800091ea:	20 1b       	sub	r11,1
800091ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091f0:	10 3b       	cp.w	r11,r8
800091f2:	c0 a5       	brlt	80009206 <_vfprintf_r+0x346>
800091f4:	c1 18       	rjmp	80009216 <_vfprintf_r+0x356>
800091f6:	d7 03       	nop
800091f8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800091fc:	ec c9 ff ff 	sub	r9,r6,-1
80009200:	14 36       	cp.w	r6,r10
80009202:	c1 f5       	brlt	80009240 <_vfprintf_r+0x380>
80009204:	c2 88       	rjmp	80009254 <_vfprintf_r+0x394>
80009206:	fa ca f9 44 	sub	r10,sp,-1724
8000920a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000920e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80009212:	50 2b       	stdsp	sp[0x8],r11
80009214:	c3 c8       	rjmp	8000928c <_vfprintf_r+0x3cc>
80009216:	fa c8 f9 50 	sub	r8,sp,-1712
8000921a:	1a d8       	st.w	--sp,r8
8000921c:	fa c8 fa b8 	sub	r8,sp,-1352
80009220:	1a d8       	st.w	--sp,r8
80009222:	fa c8 fb b4 	sub	r8,sp,-1100
80009226:	02 9a       	mov	r10,r1
80009228:	1a d8       	st.w	--sp,r8
8000922a:	04 9c       	mov	r12,r2
8000922c:	fa c8 f9 40 	sub	r8,sp,-1728
80009230:	fa c9 ff b4 	sub	r9,sp,-76
80009234:	fe b0 fc ae 	rcall	80008b90 <get_arg>
80009238:	2f dd       	sub	sp,-12
8000923a:	78 0c       	ld.w	r12,r12[0x0]
8000923c:	50 2c       	stdsp	sp[0x8],r12
8000923e:	c2 78       	rjmp	8000928c <_vfprintf_r+0x3cc>
80009240:	12 96       	mov	r6,r9
80009242:	0e 94       	mov	r4,r7
80009244:	fa c9 f9 44 	sub	r9,sp,-1724
80009248:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000924c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80009250:	50 28       	stdsp	sp[0x8],r8
80009252:	c1 d8       	rjmp	8000928c <_vfprintf_r+0x3cc>
80009254:	41 08       	lddsp	r8,sp[0x40]
80009256:	59 fa       	cp.w	r10,31
80009258:	e0 89 00 14 	brgt	80009280 <_vfprintf_r+0x3c0>
8000925c:	f0 cb ff fc 	sub	r11,r8,-4
80009260:	70 08       	ld.w	r8,r8[0x0]
80009262:	51 0b       	stdsp	sp[0x40],r11
80009264:	50 28       	stdsp	sp[0x8],r8
80009266:	fa c6 f9 44 	sub	r6,sp,-1724
8000926a:	40 2e       	lddsp	lr,sp[0x8]
8000926c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80009270:	f1 4e fd 88 	st.w	r8[-632],lr
80009274:	2f fa       	sub	r10,-1
80009276:	0e 94       	mov	r4,r7
80009278:	fb 4a 06 b4 	st.w	sp[1716],r10
8000927c:	12 96       	mov	r6,r9
8000927e:	c0 78       	rjmp	8000928c <_vfprintf_r+0x3cc>
80009280:	70 0c       	ld.w	r12,r8[0x0]
80009282:	0e 94       	mov	r4,r7
80009284:	2f c8       	sub	r8,-4
80009286:	50 2c       	stdsp	sp[0x8],r12
80009288:	12 96       	mov	r6,r9
8000928a:	51 08       	stdsp	sp[0x40],r8
8000928c:	40 2b       	lddsp	r11,sp[0x8]
8000928e:	58 0b       	cp.w	r11,0
80009290:	fe 95 fe f2 	brlt	80009074 <_vfprintf_r+0x1b4>
80009294:	08 97       	mov	r7,r4
80009296:	cf 5a       	rjmp	80009080 <_vfprintf_r+0x1c0>
80009298:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000929c:	0f 38       	ld.ub	r8,r7++
8000929e:	f4 09 00 19 	add	r9,r10,r9<<0x1
800092a2:	f0 ca 00 30 	sub	r10,r8,48
800092a6:	58 9a       	cp.w	r10,9
800092a8:	fe 98 ff f8 	brls	80009298 <_vfprintf_r+0x3d8>
800092ac:	3f fa       	mov	r10,-1
800092ae:	f2 0a 0c 49 	max	r9,r9,r10
800092b2:	50 29       	stdsp	sp[0x8],r9
800092b4:	ce 9a       	rjmp	80009086 <_vfprintf_r+0x1c6>
800092b6:	a7 b5       	sbr	r5,0x7
800092b8:	ce 4a       	rjmp	80009080 <_vfprintf_r+0x1c0>
800092ba:	30 09       	mov	r9,0
800092bc:	23 08       	sub	r8,48
800092be:	f2 09 00 29 	add	r9,r9,r9<<0x2
800092c2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800092c6:	0f 38       	ld.ub	r8,r7++
800092c8:	f0 ca 00 30 	sub	r10,r8,48
800092cc:	58 9a       	cp.w	r10,9
800092ce:	fe 98 ff f7 	brls	800092bc <_vfprintf_r+0x3fc>
800092d2:	e0 48 00 24 	cp.w	r8,36
800092d6:	fe 91 fe d7 	brne	80009084 <_vfprintf_r+0x1c4>
800092da:	e0 49 00 20 	cp.w	r9,32
800092de:	e0 89 0d 6f 	brgt	8000adbc <_vfprintf_r+0x1efc>
800092e2:	f2 c3 00 01 	sub	r3,r9,1
800092e6:	30 19       	mov	r9,1
800092e8:	50 39       	stdsp	sp[0xc],r9
800092ea:	cc ba       	rjmp	80009080 <_vfprintf_r+0x1c0>
800092ec:	a3 b5       	sbr	r5,0x3
800092ee:	cc 9a       	rjmp	80009080 <_vfprintf_r+0x1c0>
800092f0:	a7 a5       	sbr	r5,0x6
800092f2:	cc 7a       	rjmp	80009080 <_vfprintf_r+0x1c0>
800092f4:	0a 98       	mov	r8,r5
800092f6:	a5 b5       	sbr	r5,0x5
800092f8:	a5 a8       	sbr	r8,0x4
800092fa:	0f 89       	ld.ub	r9,r7[0x0]
800092fc:	36 ce       	mov	lr,108
800092fe:	fc 09 18 00 	cp.b	r9,lr
80009302:	f7 b7 00 ff 	subeq	r7,-1
80009306:	f0 05 17 10 	movne	r5,r8
8000930a:	cb ba       	rjmp	80009080 <_vfprintf_r+0x1c0>
8000930c:	a5 b5       	sbr	r5,0x5
8000930e:	cb 9a       	rjmp	80009080 <_vfprintf_r+0x1c0>
80009310:	50 a7       	stdsp	sp[0x28],r7
80009312:	50 80       	stdsp	sp[0x20],r0
80009314:	0c 97       	mov	r7,r6
80009316:	10 90       	mov	r0,r8
80009318:	06 96       	mov	r6,r3
8000931a:	04 94       	mov	r4,r2
8000931c:	40 93       	lddsp	r3,sp[0x24]
8000931e:	02 92       	mov	r2,r1
80009320:	0e 99       	mov	r9,r7
80009322:	40 41       	lddsp	r1,sp[0x10]
80009324:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009328:	40 3c       	lddsp	r12,sp[0xc]
8000932a:	58 0c       	cp.w	r12,0
8000932c:	c1 d0       	breq	80009366 <_vfprintf_r+0x4a6>
8000932e:	10 36       	cp.w	r6,r8
80009330:	c0 64       	brge	8000933c <_vfprintf_r+0x47c>
80009332:	fa cb f9 44 	sub	r11,sp,-1724
80009336:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000933a:	c1 d8       	rjmp	80009374 <_vfprintf_r+0x4b4>
8000933c:	fa c8 f9 50 	sub	r8,sp,-1712
80009340:	1a d8       	st.w	--sp,r8
80009342:	fa c8 fa b8 	sub	r8,sp,-1352
80009346:	1a d8       	st.w	--sp,r8
80009348:	fa c8 fb b4 	sub	r8,sp,-1100
8000934c:	1a d8       	st.w	--sp,r8
8000934e:	fa c8 f9 40 	sub	r8,sp,-1728
80009352:	fa c9 ff b4 	sub	r9,sp,-76
80009356:	04 9a       	mov	r10,r2
80009358:	0c 9b       	mov	r11,r6
8000935a:	08 9c       	mov	r12,r4
8000935c:	fe b0 fc 1a 	rcall	80008b90 <get_arg>
80009360:	2f dd       	sub	sp,-12
80009362:	19 b8       	ld.ub	r8,r12[0x3]
80009364:	c2 28       	rjmp	800093a8 <_vfprintf_r+0x4e8>
80009366:	2f f7       	sub	r7,-1
80009368:	10 39       	cp.w	r9,r8
8000936a:	c0 84       	brge	8000937a <_vfprintf_r+0x4ba>
8000936c:	fa ca f9 44 	sub	r10,sp,-1724
80009370:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009374:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80009378:	c1 88       	rjmp	800093a8 <_vfprintf_r+0x4e8>
8000937a:	41 09       	lddsp	r9,sp[0x40]
8000937c:	59 f8       	cp.w	r8,31
8000937e:	e0 89 00 12 	brgt	800093a2 <_vfprintf_r+0x4e2>
80009382:	f2 ca ff fc 	sub	r10,r9,-4
80009386:	51 0a       	stdsp	sp[0x40],r10
80009388:	72 09       	ld.w	r9,r9[0x0]
8000938a:	fa c6 f9 44 	sub	r6,sp,-1724
8000938e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009392:	2f f8       	sub	r8,-1
80009394:	f5 49 fd 88 	st.w	r10[-632],r9
80009398:	fb 48 06 b4 	st.w	sp[1716],r8
8000939c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800093a0:	c0 48       	rjmp	800093a8 <_vfprintf_r+0x4e8>
800093a2:	13 b8       	ld.ub	r8,r9[0x3]
800093a4:	2f c9       	sub	r9,-4
800093a6:	51 09       	stdsp	sp[0x40],r9
800093a8:	fb 68 06 60 	st.b	sp[1632],r8
800093ac:	30 0e       	mov	lr,0
800093ae:	30 08       	mov	r8,0
800093b0:	30 12       	mov	r2,1
800093b2:	fb 68 06 bb 	st.b	sp[1723],r8
800093b6:	50 2e       	stdsp	sp[0x8],lr
800093b8:	e0 8f 08 ad 	bral	8000a512 <_vfprintf_r+0x1652>
800093bc:	50 a7       	stdsp	sp[0x28],r7
800093be:	50 80       	stdsp	sp[0x20],r0
800093c0:	0c 97       	mov	r7,r6
800093c2:	04 94       	mov	r4,r2
800093c4:	06 96       	mov	r6,r3
800093c6:	02 92       	mov	r2,r1
800093c8:	40 93       	lddsp	r3,sp[0x24]
800093ca:	10 90       	mov	r0,r8
800093cc:	40 41       	lddsp	r1,sp[0x10]
800093ce:	a5 a5       	sbr	r5,0x4
800093d0:	c0 a8       	rjmp	800093e4 <_vfprintf_r+0x524>
800093d2:	50 a7       	stdsp	sp[0x28],r7
800093d4:	50 80       	stdsp	sp[0x20],r0
800093d6:	0c 97       	mov	r7,r6
800093d8:	04 94       	mov	r4,r2
800093da:	06 96       	mov	r6,r3
800093dc:	02 92       	mov	r2,r1
800093de:	40 93       	lddsp	r3,sp[0x24]
800093e0:	10 90       	mov	r0,r8
800093e2:	40 41       	lddsp	r1,sp[0x10]
800093e4:	ed b5 00 05 	bld	r5,0x5
800093e8:	c5 11       	brne	8000948a <_vfprintf_r+0x5ca>
800093ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093ee:	40 3c       	lddsp	r12,sp[0xc]
800093f0:	58 0c       	cp.w	r12,0
800093f2:	c1 e0       	breq	8000942e <_vfprintf_r+0x56e>
800093f4:	10 36       	cp.w	r6,r8
800093f6:	c0 64       	brge	80009402 <_vfprintf_r+0x542>
800093f8:	fa cb f9 44 	sub	r11,sp,-1724
800093fc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009400:	c2 08       	rjmp	80009440 <_vfprintf_r+0x580>
80009402:	fa c8 f9 50 	sub	r8,sp,-1712
80009406:	1a d8       	st.w	--sp,r8
80009408:	fa c8 fa b8 	sub	r8,sp,-1352
8000940c:	0c 9b       	mov	r11,r6
8000940e:	1a d8       	st.w	--sp,r8
80009410:	fa c8 fb b4 	sub	r8,sp,-1100
80009414:	1a d8       	st.w	--sp,r8
80009416:	fa c9 ff b4 	sub	r9,sp,-76
8000941a:	fa c8 f9 40 	sub	r8,sp,-1728
8000941e:	04 9a       	mov	r10,r2
80009420:	08 9c       	mov	r12,r4
80009422:	fe b0 fb b7 	rcall	80008b90 <get_arg>
80009426:	2f dd       	sub	sp,-12
80009428:	78 1b       	ld.w	r11,r12[0x4]
8000942a:	78 09       	ld.w	r9,r12[0x0]
8000942c:	c2 b8       	rjmp	80009482 <_vfprintf_r+0x5c2>
8000942e:	ee ca ff ff 	sub	r10,r7,-1
80009432:	10 37       	cp.w	r7,r8
80009434:	c0 b4       	brge	8000944a <_vfprintf_r+0x58a>
80009436:	fa c9 f9 44 	sub	r9,sp,-1724
8000943a:	14 97       	mov	r7,r10
8000943c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009440:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009444:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009448:	c1 d8       	rjmp	80009482 <_vfprintf_r+0x5c2>
8000944a:	41 09       	lddsp	r9,sp[0x40]
8000944c:	59 f8       	cp.w	r8,31
8000944e:	e0 89 00 14 	brgt	80009476 <_vfprintf_r+0x5b6>
80009452:	f2 cb ff f8 	sub	r11,r9,-8
80009456:	51 0b       	stdsp	sp[0x40],r11
80009458:	fa c6 f9 44 	sub	r6,sp,-1724
8000945c:	72 1b       	ld.w	r11,r9[0x4]
8000945e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80009462:	72 09       	ld.w	r9,r9[0x0]
80009464:	f9 4b fd 8c 	st.w	r12[-628],r11
80009468:	f9 49 fd 88 	st.w	r12[-632],r9
8000946c:	2f f8       	sub	r8,-1
8000946e:	14 97       	mov	r7,r10
80009470:	fb 48 06 b4 	st.w	sp[1716],r8
80009474:	c0 78       	rjmp	80009482 <_vfprintf_r+0x5c2>
80009476:	f2 c8 ff f8 	sub	r8,r9,-8
8000947a:	72 1b       	ld.w	r11,r9[0x4]
8000947c:	14 97       	mov	r7,r10
8000947e:	51 08       	stdsp	sp[0x40],r8
80009480:	72 09       	ld.w	r9,r9[0x0]
80009482:	16 98       	mov	r8,r11
80009484:	fa e9 00 00 	st.d	sp[0],r8
80009488:	ca e8       	rjmp	800095e4 <_vfprintf_r+0x724>
8000948a:	ed b5 00 04 	bld	r5,0x4
8000948e:	c1 71       	brne	800094bc <_vfprintf_r+0x5fc>
80009490:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009494:	40 3e       	lddsp	lr,sp[0xc]
80009496:	58 0e       	cp.w	lr,0
80009498:	c0 80       	breq	800094a8 <_vfprintf_r+0x5e8>
8000949a:	10 36       	cp.w	r6,r8
8000949c:	c6 94       	brge	8000956e <_vfprintf_r+0x6ae>
8000949e:	fa cc f9 44 	sub	r12,sp,-1724
800094a2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094a6:	c8 28       	rjmp	800095aa <_vfprintf_r+0x6ea>
800094a8:	ee ca ff ff 	sub	r10,r7,-1
800094ac:	10 37       	cp.w	r7,r8
800094ae:	e0 84 00 81 	brge	800095b0 <_vfprintf_r+0x6f0>
800094b2:	fa cb f9 44 	sub	r11,sp,-1724
800094b6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094ba:	c7 78       	rjmp	800095a8 <_vfprintf_r+0x6e8>
800094bc:	ed b5 00 06 	bld	r5,0x6
800094c0:	c4 b1       	brne	80009556 <_vfprintf_r+0x696>
800094c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094c6:	40 3c       	lddsp	r12,sp[0xc]
800094c8:	58 0c       	cp.w	r12,0
800094ca:	c1 d0       	breq	80009504 <_vfprintf_r+0x644>
800094cc:	10 36       	cp.w	r6,r8
800094ce:	c0 64       	brge	800094da <_vfprintf_r+0x61a>
800094d0:	fa cb f9 44 	sub	r11,sp,-1724
800094d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094d8:	c1 f8       	rjmp	80009516 <_vfprintf_r+0x656>
800094da:	fa c8 f9 50 	sub	r8,sp,-1712
800094de:	1a d8       	st.w	--sp,r8
800094e0:	fa c8 fa b8 	sub	r8,sp,-1352
800094e4:	1a d8       	st.w	--sp,r8
800094e6:	fa c8 fb b4 	sub	r8,sp,-1100
800094ea:	1a d8       	st.w	--sp,r8
800094ec:	fa c8 f9 40 	sub	r8,sp,-1728
800094f0:	fa c9 ff b4 	sub	r9,sp,-76
800094f4:	04 9a       	mov	r10,r2
800094f6:	0c 9b       	mov	r11,r6
800094f8:	08 9c       	mov	r12,r4
800094fa:	fe b0 fb 4b 	rcall	80008b90 <get_arg>
800094fe:	2f dd       	sub	sp,-12
80009500:	98 18       	ld.sh	r8,r12[0x2]
80009502:	c2 68       	rjmp	8000954e <_vfprintf_r+0x68e>
80009504:	ee ca ff ff 	sub	r10,r7,-1
80009508:	10 37       	cp.w	r7,r8
8000950a:	c0 94       	brge	8000951c <_vfprintf_r+0x65c>
8000950c:	fa c9 f9 44 	sub	r9,sp,-1724
80009510:	14 97       	mov	r7,r10
80009512:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009516:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000951a:	c1 a8       	rjmp	8000954e <_vfprintf_r+0x68e>
8000951c:	41 09       	lddsp	r9,sp[0x40]
8000951e:	59 f8       	cp.w	r8,31
80009520:	e0 89 00 13 	brgt	80009546 <_vfprintf_r+0x686>
80009524:	f2 cb ff fc 	sub	r11,r9,-4
80009528:	51 0b       	stdsp	sp[0x40],r11
8000952a:	72 09       	ld.w	r9,r9[0x0]
8000952c:	fa c6 f9 44 	sub	r6,sp,-1724
80009530:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009534:	2f f8       	sub	r8,-1
80009536:	f7 49 fd 88 	st.w	r11[-632],r9
8000953a:	fb 48 06 b4 	st.w	sp[1716],r8
8000953e:	14 97       	mov	r7,r10
80009540:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009544:	c0 58       	rjmp	8000954e <_vfprintf_r+0x68e>
80009546:	92 18       	ld.sh	r8,r9[0x2]
80009548:	14 97       	mov	r7,r10
8000954a:	2f c9       	sub	r9,-4
8000954c:	51 09       	stdsp	sp[0x40],r9
8000954e:	50 18       	stdsp	sp[0x4],r8
80009550:	bf 58       	asr	r8,0x1f
80009552:	50 08       	stdsp	sp[0x0],r8
80009554:	c4 88       	rjmp	800095e4 <_vfprintf_r+0x724>
80009556:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000955a:	40 3c       	lddsp	r12,sp[0xc]
8000955c:	58 0c       	cp.w	r12,0
8000955e:	c1 d0       	breq	80009598 <_vfprintf_r+0x6d8>
80009560:	10 36       	cp.w	r6,r8
80009562:	c0 64       	brge	8000956e <_vfprintf_r+0x6ae>
80009564:	fa cb f9 44 	sub	r11,sp,-1724
80009568:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000956c:	c1 f8       	rjmp	800095aa <_vfprintf_r+0x6ea>
8000956e:	fa c8 f9 50 	sub	r8,sp,-1712
80009572:	1a d8       	st.w	--sp,r8
80009574:	fa c8 fa b8 	sub	r8,sp,-1352
80009578:	0c 9b       	mov	r11,r6
8000957a:	1a d8       	st.w	--sp,r8
8000957c:	fa c8 fb b4 	sub	r8,sp,-1100
80009580:	04 9a       	mov	r10,r2
80009582:	1a d8       	st.w	--sp,r8
80009584:	08 9c       	mov	r12,r4
80009586:	fa c8 f9 40 	sub	r8,sp,-1728
8000958a:	fa c9 ff b4 	sub	r9,sp,-76
8000958e:	fe b0 fb 01 	rcall	80008b90 <get_arg>
80009592:	2f dd       	sub	sp,-12
80009594:	78 0b       	ld.w	r11,r12[0x0]
80009596:	c2 48       	rjmp	800095de <_vfprintf_r+0x71e>
80009598:	ee ca ff ff 	sub	r10,r7,-1
8000959c:	10 37       	cp.w	r7,r8
8000959e:	c0 94       	brge	800095b0 <_vfprintf_r+0x6f0>
800095a0:	fa c9 f9 44 	sub	r9,sp,-1724
800095a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095a8:	14 97       	mov	r7,r10
800095aa:	ec fb fd 88 	ld.w	r11,r6[-632]
800095ae:	c1 88       	rjmp	800095de <_vfprintf_r+0x71e>
800095b0:	41 09       	lddsp	r9,sp[0x40]
800095b2:	59 f8       	cp.w	r8,31
800095b4:	e0 89 00 11 	brgt	800095d6 <_vfprintf_r+0x716>
800095b8:	f2 cb ff fc 	sub	r11,r9,-4
800095bc:	51 0b       	stdsp	sp[0x40],r11
800095be:	fa c6 f9 44 	sub	r6,sp,-1724
800095c2:	72 0b       	ld.w	r11,r9[0x0]
800095c4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095c8:	f3 4b fd 88 	st.w	r9[-632],r11
800095cc:	2f f8       	sub	r8,-1
800095ce:	14 97       	mov	r7,r10
800095d0:	fb 48 06 b4 	st.w	sp[1716],r8
800095d4:	c0 58       	rjmp	800095de <_vfprintf_r+0x71e>
800095d6:	72 0b       	ld.w	r11,r9[0x0]
800095d8:	14 97       	mov	r7,r10
800095da:	2f c9       	sub	r9,-4
800095dc:	51 09       	stdsp	sp[0x40],r9
800095de:	50 1b       	stdsp	sp[0x4],r11
800095e0:	bf 5b       	asr	r11,0x1f
800095e2:	50 0b       	stdsp	sp[0x0],r11
800095e4:	fa ea 00 00 	ld.d	r10,sp[0]
800095e8:	58 0a       	cp.w	r10,0
800095ea:	5c 2b       	cpc	r11
800095ec:	c0 e4       	brge	80009608 <_vfprintf_r+0x748>
800095ee:	30 08       	mov	r8,0
800095f0:	fa ea 00 00 	ld.d	r10,sp[0]
800095f4:	30 09       	mov	r9,0
800095f6:	f0 0a 01 0a 	sub	r10,r8,r10
800095fa:	f2 0b 01 4b 	sbc	r11,r9,r11
800095fe:	32 d8       	mov	r8,45
80009600:	fa eb 00 00 	st.d	sp[0],r10
80009604:	fb 68 06 bb 	st.b	sp[1723],r8
80009608:	30 18       	mov	r8,1
8000960a:	e0 8f 06 fa 	bral	8000a3fe <_vfprintf_r+0x153e>
8000960e:	50 a7       	stdsp	sp[0x28],r7
80009610:	50 80       	stdsp	sp[0x20],r0
80009612:	0c 97       	mov	r7,r6
80009614:	04 94       	mov	r4,r2
80009616:	06 96       	mov	r6,r3
80009618:	02 92       	mov	r2,r1
8000961a:	40 93       	lddsp	r3,sp[0x24]
8000961c:	10 90       	mov	r0,r8
8000961e:	40 41       	lddsp	r1,sp[0x10]
80009620:	0e 99       	mov	r9,r7
80009622:	ed b5 00 03 	bld	r5,0x3
80009626:	c4 11       	brne	800096a8 <_vfprintf_r+0x7e8>
80009628:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000962c:	40 3a       	lddsp	r10,sp[0xc]
8000962e:	58 0a       	cp.w	r10,0
80009630:	c1 90       	breq	80009662 <_vfprintf_r+0x7a2>
80009632:	10 36       	cp.w	r6,r8
80009634:	c6 45       	brlt	800096fc <_vfprintf_r+0x83c>
80009636:	fa c8 f9 50 	sub	r8,sp,-1712
8000963a:	1a d8       	st.w	--sp,r8
8000963c:	fa c8 fa b8 	sub	r8,sp,-1352
80009640:	1a d8       	st.w	--sp,r8
80009642:	fa c8 fb b4 	sub	r8,sp,-1100
80009646:	0c 9b       	mov	r11,r6
80009648:	1a d8       	st.w	--sp,r8
8000964a:	04 9a       	mov	r10,r2
8000964c:	fa c8 f9 40 	sub	r8,sp,-1728
80009650:	fa c9 ff b4 	sub	r9,sp,-76
80009654:	08 9c       	mov	r12,r4
80009656:	fe b0 fa 9d 	rcall	80008b90 <get_arg>
8000965a:	2f dd       	sub	sp,-12
8000965c:	78 16       	ld.w	r6,r12[0x4]
8000965e:	50 76       	stdsp	sp[0x1c],r6
80009660:	c4 88       	rjmp	800096f0 <_vfprintf_r+0x830>
80009662:	2f f7       	sub	r7,-1
80009664:	10 39       	cp.w	r9,r8
80009666:	c0 c4       	brge	8000967e <_vfprintf_r+0x7be>
80009668:	fa ce f9 44 	sub	lr,sp,-1724
8000966c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80009670:	ec fc fd 8c 	ld.w	r12,r6[-628]
80009674:	50 7c       	stdsp	sp[0x1c],r12
80009676:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000967a:	50 56       	stdsp	sp[0x14],r6
8000967c:	c6 68       	rjmp	80009748 <_vfprintf_r+0x888>
8000967e:	41 09       	lddsp	r9,sp[0x40]
80009680:	59 f8       	cp.w	r8,31
80009682:	e0 89 00 10 	brgt	800096a2 <_vfprintf_r+0x7e2>
80009686:	f2 ca ff f8 	sub	r10,r9,-8
8000968a:	72 1b       	ld.w	r11,r9[0x4]
8000968c:	51 0a       	stdsp	sp[0x40],r10
8000968e:	72 09       	ld.w	r9,r9[0x0]
80009690:	fa ca f9 44 	sub	r10,sp,-1724
80009694:	50 7b       	stdsp	sp[0x1c],r11
80009696:	50 59       	stdsp	sp[0x14],r9
80009698:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000969c:	40 5b       	lddsp	r11,sp[0x14]
8000969e:	40 7a       	lddsp	r10,sp[0x1c]
800096a0:	c4 78       	rjmp	8000972e <_vfprintf_r+0x86e>
800096a2:	72 18       	ld.w	r8,r9[0x4]
800096a4:	50 78       	stdsp	sp[0x1c],r8
800096a6:	c4 c8       	rjmp	8000973e <_vfprintf_r+0x87e>
800096a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096ac:	40 3e       	lddsp	lr,sp[0xc]
800096ae:	58 0e       	cp.w	lr,0
800096b0:	c2 30       	breq	800096f6 <_vfprintf_r+0x836>
800096b2:	10 36       	cp.w	r6,r8
800096b4:	c0 94       	brge	800096c6 <_vfprintf_r+0x806>
800096b6:	fa cc f9 44 	sub	r12,sp,-1724
800096ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
800096be:	ec fb fd 8c 	ld.w	r11,r6[-628]
800096c2:	50 7b       	stdsp	sp[0x1c],r11
800096c4:	cd 9b       	rjmp	80009676 <_vfprintf_r+0x7b6>
800096c6:	fa c8 f9 50 	sub	r8,sp,-1712
800096ca:	1a d8       	st.w	--sp,r8
800096cc:	fa c8 fa b8 	sub	r8,sp,-1352
800096d0:	04 9a       	mov	r10,r2
800096d2:	1a d8       	st.w	--sp,r8
800096d4:	fa c8 fb b4 	sub	r8,sp,-1100
800096d8:	0c 9b       	mov	r11,r6
800096da:	1a d8       	st.w	--sp,r8
800096dc:	08 9c       	mov	r12,r4
800096de:	fa c8 f9 40 	sub	r8,sp,-1728
800096e2:	fa c9 ff b4 	sub	r9,sp,-76
800096e6:	fe b0 fa 55 	rcall	80008b90 <get_arg>
800096ea:	2f dd       	sub	sp,-12
800096ec:	78 1a       	ld.w	r10,r12[0x4]
800096ee:	50 7a       	stdsp	sp[0x1c],r10
800096f0:	78 0c       	ld.w	r12,r12[0x0]
800096f2:	50 5c       	stdsp	sp[0x14],r12
800096f4:	c2 a8       	rjmp	80009748 <_vfprintf_r+0x888>
800096f6:	2f f7       	sub	r7,-1
800096f8:	10 39       	cp.w	r9,r8
800096fa:	c0 94       	brge	8000970c <_vfprintf_r+0x84c>
800096fc:	fa c9 f9 44 	sub	r9,sp,-1724
80009700:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009704:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009708:	50 78       	stdsp	sp[0x1c],r8
8000970a:	cb 6b       	rjmp	80009676 <_vfprintf_r+0x7b6>
8000970c:	41 09       	lddsp	r9,sp[0x40]
8000970e:	59 f8       	cp.w	r8,31
80009710:	e0 89 00 15 	brgt	8000973a <_vfprintf_r+0x87a>
80009714:	f2 ca ff f8 	sub	r10,r9,-8
80009718:	72 16       	ld.w	r6,r9[0x4]
8000971a:	72 09       	ld.w	r9,r9[0x0]
8000971c:	51 0a       	stdsp	sp[0x40],r10
8000971e:	50 59       	stdsp	sp[0x14],r9
80009720:	fa ce f9 44 	sub	lr,sp,-1724
80009724:	50 76       	stdsp	sp[0x1c],r6
80009726:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000972a:	40 5b       	lddsp	r11,sp[0x14]
8000972c:	0c 9a       	mov	r10,r6
8000972e:	f2 eb fd 88 	st.d	r9[-632],r10
80009732:	2f f8       	sub	r8,-1
80009734:	fb 48 06 b4 	st.w	sp[1716],r8
80009738:	c0 88       	rjmp	80009748 <_vfprintf_r+0x888>
8000973a:	72 1c       	ld.w	r12,r9[0x4]
8000973c:	50 7c       	stdsp	sp[0x1c],r12
8000973e:	f2 c8 ff f8 	sub	r8,r9,-8
80009742:	51 08       	stdsp	sp[0x40],r8
80009744:	72 09       	ld.w	r9,r9[0x0]
80009746:	50 59       	stdsp	sp[0x14],r9
80009748:	40 5b       	lddsp	r11,sp[0x14]
8000974a:	40 7a       	lddsp	r10,sp[0x1c]
8000974c:	e0 a0 19 54 	rcall	8000c9f4 <__isinfd>
80009750:	18 96       	mov	r6,r12
80009752:	c1 70       	breq	80009780 <_vfprintf_r+0x8c0>
80009754:	30 08       	mov	r8,0
80009756:	30 09       	mov	r9,0
80009758:	40 5b       	lddsp	r11,sp[0x14]
8000975a:	40 7a       	lddsp	r10,sp[0x1c]
8000975c:	e0 a0 1d b4 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
80009760:	c0 40       	breq	80009768 <_vfprintf_r+0x8a8>
80009762:	32 d8       	mov	r8,45
80009764:	fb 68 06 bb 	st.b	sp[1723],r8
80009768:	fe c8 a6 d4 	sub	r8,pc,-22828
8000976c:	fe c6 a6 d4 	sub	r6,pc,-22828
80009770:	a7 d5       	cbr	r5,0x7
80009772:	e0 40 00 47 	cp.w	r0,71
80009776:	f0 06 17 a0 	movle	r6,r8
8000977a:	30 32       	mov	r2,3
8000977c:	e0 8f 06 ce 	bral	8000a518 <_vfprintf_r+0x1658>
80009780:	40 5b       	lddsp	r11,sp[0x14]
80009782:	40 7a       	lddsp	r10,sp[0x1c]
80009784:	e0 a0 19 4d 	rcall	8000ca1e <__isnand>
80009788:	c0 e0       	breq	800097a4 <_vfprintf_r+0x8e4>
8000978a:	50 26       	stdsp	sp[0x8],r6
8000978c:	fe c8 a6 f0 	sub	r8,pc,-22800
80009790:	fe c6 a6 f0 	sub	r6,pc,-22800
80009794:	a7 d5       	cbr	r5,0x7
80009796:	e0 40 00 47 	cp.w	r0,71
8000979a:	f0 06 17 a0 	movle	r6,r8
8000979e:	30 32       	mov	r2,3
800097a0:	e0 8f 06 c2 	bral	8000a524 <_vfprintf_r+0x1664>
800097a4:	40 2a       	lddsp	r10,sp[0x8]
800097a6:	5b fa       	cp.w	r10,-1
800097a8:	c0 41       	brne	800097b0 <_vfprintf_r+0x8f0>
800097aa:	30 69       	mov	r9,6
800097ac:	50 29       	stdsp	sp[0x8],r9
800097ae:	c1 18       	rjmp	800097d0 <_vfprintf_r+0x910>
800097b0:	e0 40 00 47 	cp.w	r0,71
800097b4:	5f 09       	sreq	r9
800097b6:	e0 40 00 67 	cp.w	r0,103
800097ba:	5f 08       	sreq	r8
800097bc:	f3 e8 10 08 	or	r8,r9,r8
800097c0:	f8 08 18 00 	cp.b	r8,r12
800097c4:	c0 60       	breq	800097d0 <_vfprintf_r+0x910>
800097c6:	40 28       	lddsp	r8,sp[0x8]
800097c8:	58 08       	cp.w	r8,0
800097ca:	f9 b8 00 01 	moveq	r8,1
800097ce:	50 28       	stdsp	sp[0x8],r8
800097d0:	40 78       	lddsp	r8,sp[0x1c]
800097d2:	40 59       	lddsp	r9,sp[0x14]
800097d4:	fa e9 06 94 	st.d	sp[1684],r8
800097d8:	a9 a5       	sbr	r5,0x8
800097da:	fa f8 06 94 	ld.w	r8,sp[1684]
800097de:	58 08       	cp.w	r8,0
800097e0:	c0 65       	brlt	800097ec <_vfprintf_r+0x92c>
800097e2:	40 5e       	lddsp	lr,sp[0x14]
800097e4:	30 0c       	mov	r12,0
800097e6:	50 6e       	stdsp	sp[0x18],lr
800097e8:	50 9c       	stdsp	sp[0x24],r12
800097ea:	c0 78       	rjmp	800097f8 <_vfprintf_r+0x938>
800097ec:	40 5b       	lddsp	r11,sp[0x14]
800097ee:	32 da       	mov	r10,45
800097f0:	ee 1b 80 00 	eorh	r11,0x8000
800097f4:	50 9a       	stdsp	sp[0x24],r10
800097f6:	50 6b       	stdsp	sp[0x18],r11
800097f8:	e0 40 00 46 	cp.w	r0,70
800097fc:	5f 09       	sreq	r9
800097fe:	e0 40 00 66 	cp.w	r0,102
80009802:	5f 08       	sreq	r8
80009804:	f3 e8 10 08 	or	r8,r9,r8
80009808:	50 48       	stdsp	sp[0x10],r8
8000980a:	c0 40       	breq	80009812 <_vfprintf_r+0x952>
8000980c:	40 22       	lddsp	r2,sp[0x8]
8000980e:	30 39       	mov	r9,3
80009810:	c1 08       	rjmp	80009830 <_vfprintf_r+0x970>
80009812:	e0 40 00 45 	cp.w	r0,69
80009816:	5f 09       	sreq	r9
80009818:	e0 40 00 65 	cp.w	r0,101
8000981c:	5f 08       	sreq	r8
8000981e:	40 22       	lddsp	r2,sp[0x8]
80009820:	10 49       	or	r9,r8
80009822:	2f f2       	sub	r2,-1
80009824:	40 46       	lddsp	r6,sp[0x10]
80009826:	ec 09 18 00 	cp.b	r9,r6
8000982a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000982e:	30 29       	mov	r9,2
80009830:	fa c8 f9 5c 	sub	r8,sp,-1700
80009834:	1a d8       	st.w	--sp,r8
80009836:	fa c8 f9 54 	sub	r8,sp,-1708
8000983a:	1a d8       	st.w	--sp,r8
8000983c:	fa c8 f9 4c 	sub	r8,sp,-1716
80009840:	08 9c       	mov	r12,r4
80009842:	1a d8       	st.w	--sp,r8
80009844:	04 98       	mov	r8,r2
80009846:	40 9b       	lddsp	r11,sp[0x24]
80009848:	40 aa       	lddsp	r10,sp[0x28]
8000984a:	e0 a0 0b c3 	rcall	8000afd0 <_dtoa_r>
8000984e:	e0 40 00 47 	cp.w	r0,71
80009852:	5f 19       	srne	r9
80009854:	e0 40 00 67 	cp.w	r0,103
80009858:	5f 18       	srne	r8
8000985a:	18 96       	mov	r6,r12
8000985c:	2f dd       	sub	sp,-12
8000985e:	f3 e8 00 08 	and	r8,r9,r8
80009862:	c0 41       	brne	8000986a <_vfprintf_r+0x9aa>
80009864:	ed b5 00 00 	bld	r5,0x0
80009868:	c3 01       	brne	800098c8 <_vfprintf_r+0xa08>
8000986a:	ec 02 00 0e 	add	lr,r6,r2
8000986e:	50 3e       	stdsp	sp[0xc],lr
80009870:	40 4c       	lddsp	r12,sp[0x10]
80009872:	58 0c       	cp.w	r12,0
80009874:	c1 50       	breq	8000989e <_vfprintf_r+0x9de>
80009876:	0d 89       	ld.ub	r9,r6[0x0]
80009878:	33 08       	mov	r8,48
8000987a:	f0 09 18 00 	cp.b	r9,r8
8000987e:	c0 b1       	brne	80009894 <_vfprintf_r+0x9d4>
80009880:	30 08       	mov	r8,0
80009882:	30 09       	mov	r9,0
80009884:	40 6b       	lddsp	r11,sp[0x18]
80009886:	40 7a       	lddsp	r10,sp[0x1c]
80009888:	e0 a0 1c d7 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000988c:	fb b2 00 01 	rsubeq	r2,1
80009890:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009894:	40 3b       	lddsp	r11,sp[0xc]
80009896:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000989a:	10 0b       	add	r11,r8
8000989c:	50 3b       	stdsp	sp[0xc],r11
8000989e:	40 6b       	lddsp	r11,sp[0x18]
800098a0:	30 08       	mov	r8,0
800098a2:	30 09       	mov	r9,0
800098a4:	40 7a       	lddsp	r10,sp[0x1c]
800098a6:	e0 a0 1c c8 	rcall	8000d236 <__avr32_f64_cmp_eq>
800098aa:	c0 90       	breq	800098bc <_vfprintf_r+0x9fc>
800098ac:	40 3a       	lddsp	r10,sp[0xc]
800098ae:	fb 4a 06 a4 	st.w	sp[1700],r10
800098b2:	c0 58       	rjmp	800098bc <_vfprintf_r+0x9fc>
800098b4:	10 c9       	st.b	r8++,r9
800098b6:	fb 48 06 a4 	st.w	sp[1700],r8
800098ba:	c0 28       	rjmp	800098be <_vfprintf_r+0x9fe>
800098bc:	33 09       	mov	r9,48
800098be:	fa f8 06 a4 	ld.w	r8,sp[1700]
800098c2:	40 3e       	lddsp	lr,sp[0xc]
800098c4:	1c 38       	cp.w	r8,lr
800098c6:	cf 73       	brcs	800098b4 <_vfprintf_r+0x9f4>
800098c8:	e0 40 00 47 	cp.w	r0,71
800098cc:	5f 09       	sreq	r9
800098ce:	e0 40 00 67 	cp.w	r0,103
800098d2:	5f 08       	sreq	r8
800098d4:	f3 e8 10 08 	or	r8,r9,r8
800098d8:	fa f9 06 a4 	ld.w	r9,sp[1700]
800098dc:	0c 19       	sub	r9,r6
800098de:	50 69       	stdsp	sp[0x18],r9
800098e0:	58 08       	cp.w	r8,0
800098e2:	c0 b0       	breq	800098f8 <_vfprintf_r+0xa38>
800098e4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800098e8:	5b d8       	cp.w	r8,-3
800098ea:	c0 55       	brlt	800098f4 <_vfprintf_r+0xa34>
800098ec:	40 2c       	lddsp	r12,sp[0x8]
800098ee:	18 38       	cp.w	r8,r12
800098f0:	e0 8a 00 6a 	brle	800099c4 <_vfprintf_r+0xb04>
800098f4:	20 20       	sub	r0,2
800098f6:	c0 58       	rjmp	80009900 <_vfprintf_r+0xa40>
800098f8:	e0 40 00 65 	cp.w	r0,101
800098fc:	e0 89 00 46 	brgt	80009988 <_vfprintf_r+0xac8>
80009900:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009904:	fb 60 06 9c 	st.b	sp[1692],r0
80009908:	20 1b       	sub	r11,1
8000990a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000990e:	c0 47       	brpl	80009916 <_vfprintf_r+0xa56>
80009910:	5c 3b       	neg	r11
80009912:	32 d8       	mov	r8,45
80009914:	c0 28       	rjmp	80009918 <_vfprintf_r+0xa58>
80009916:	32 b8       	mov	r8,43
80009918:	fb 68 06 9d 	st.b	sp[1693],r8
8000991c:	58 9b       	cp.w	r11,9
8000991e:	e0 8a 00 1d 	brle	80009958 <_vfprintf_r+0xa98>
80009922:	fa c9 fa 35 	sub	r9,sp,-1483
80009926:	30 aa       	mov	r10,10
80009928:	12 98       	mov	r8,r9
8000992a:	0e 9c       	mov	r12,r7
8000992c:	0c 92       	mov	r2,r6
8000992e:	f6 0a 0c 06 	divs	r6,r11,r10
80009932:	0e 9b       	mov	r11,r7
80009934:	2d 0b       	sub	r11,-48
80009936:	10 fb       	st.b	--r8,r11
80009938:	0c 9b       	mov	r11,r6
8000993a:	58 96       	cp.w	r6,9
8000993c:	fe 99 ff f9 	brgt	8000992e <_vfprintf_r+0xa6e>
80009940:	2d 0b       	sub	r11,-48
80009942:	18 97       	mov	r7,r12
80009944:	04 96       	mov	r6,r2
80009946:	10 fb       	st.b	--r8,r11
80009948:	fa ca f9 62 	sub	r10,sp,-1694
8000994c:	c0 38       	rjmp	80009952 <_vfprintf_r+0xa92>
8000994e:	11 3b       	ld.ub	r11,r8++
80009950:	14 cb       	st.b	r10++,r11
80009952:	12 38       	cp.w	r8,r9
80009954:	cf d3       	brcs	8000994e <_vfprintf_r+0xa8e>
80009956:	c0 98       	rjmp	80009968 <_vfprintf_r+0xaa8>
80009958:	2d 0b       	sub	r11,-48
8000995a:	33 08       	mov	r8,48
8000995c:	fb 6b 06 9f 	st.b	sp[1695],r11
80009960:	fb 68 06 9e 	st.b	sp[1694],r8
80009964:	fa ca f9 60 	sub	r10,sp,-1696
80009968:	fa c8 f9 64 	sub	r8,sp,-1692
8000996c:	f4 08 01 08 	sub	r8,r10,r8
80009970:	50 e8       	stdsp	sp[0x38],r8
80009972:	10 92       	mov	r2,r8
80009974:	40 6b       	lddsp	r11,sp[0x18]
80009976:	16 02       	add	r2,r11
80009978:	58 1b       	cp.w	r11,1
8000997a:	e0 89 00 05 	brgt	80009984 <_vfprintf_r+0xac4>
8000997e:	ed b5 00 00 	bld	r5,0x0
80009982:	c3 51       	brne	800099ec <_vfprintf_r+0xb2c>
80009984:	2f f2       	sub	r2,-1
80009986:	c3 38       	rjmp	800099ec <_vfprintf_r+0xb2c>
80009988:	e0 40 00 66 	cp.w	r0,102
8000998c:	c1 c1       	brne	800099c4 <_vfprintf_r+0xb04>
8000998e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009992:	58 02       	cp.w	r2,0
80009994:	e0 8a 00 0c 	brle	800099ac <_vfprintf_r+0xaec>
80009998:	40 2a       	lddsp	r10,sp[0x8]
8000999a:	58 0a       	cp.w	r10,0
8000999c:	c0 41       	brne	800099a4 <_vfprintf_r+0xae4>
8000999e:	ed b5 00 00 	bld	r5,0x0
800099a2:	c2 51       	brne	800099ec <_vfprintf_r+0xb2c>
800099a4:	2f f2       	sub	r2,-1
800099a6:	40 29       	lddsp	r9,sp[0x8]
800099a8:	12 02       	add	r2,r9
800099aa:	c0 b8       	rjmp	800099c0 <_vfprintf_r+0xb00>
800099ac:	40 28       	lddsp	r8,sp[0x8]
800099ae:	58 08       	cp.w	r8,0
800099b0:	c0 61       	brne	800099bc <_vfprintf_r+0xafc>
800099b2:	ed b5 00 00 	bld	r5,0x0
800099b6:	c0 30       	breq	800099bc <_vfprintf_r+0xafc>
800099b8:	30 12       	mov	r2,1
800099ba:	c1 98       	rjmp	800099ec <_vfprintf_r+0xb2c>
800099bc:	40 22       	lddsp	r2,sp[0x8]
800099be:	2f e2       	sub	r2,-2
800099c0:	36 60       	mov	r0,102
800099c2:	c1 58       	rjmp	800099ec <_vfprintf_r+0xb2c>
800099c4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099c8:	40 6e       	lddsp	lr,sp[0x18]
800099ca:	1c 32       	cp.w	r2,lr
800099cc:	c0 65       	brlt	800099d8 <_vfprintf_r+0xb18>
800099ce:	ed b5 00 00 	bld	r5,0x0
800099d2:	f7 b2 00 ff 	subeq	r2,-1
800099d6:	c0 a8       	rjmp	800099ea <_vfprintf_r+0xb2a>
800099d8:	e4 08 11 02 	rsub	r8,r2,2
800099dc:	40 6c       	lddsp	r12,sp[0x18]
800099de:	58 02       	cp.w	r2,0
800099e0:	f0 02 17 a0 	movle	r2,r8
800099e4:	f9 b2 09 01 	movgt	r2,1
800099e8:	18 02       	add	r2,r12
800099ea:	36 70       	mov	r0,103
800099ec:	40 9b       	lddsp	r11,sp[0x24]
800099ee:	58 0b       	cp.w	r11,0
800099f0:	e0 80 05 94 	breq	8000a518 <_vfprintf_r+0x1658>
800099f4:	32 d8       	mov	r8,45
800099f6:	fb 68 06 bb 	st.b	sp[1723],r8
800099fa:	e0 8f 05 93 	bral	8000a520 <_vfprintf_r+0x1660>
800099fe:	50 a7       	stdsp	sp[0x28],r7
80009a00:	04 94       	mov	r4,r2
80009a02:	0c 97       	mov	r7,r6
80009a04:	02 92       	mov	r2,r1
80009a06:	06 96       	mov	r6,r3
80009a08:	40 41       	lddsp	r1,sp[0x10]
80009a0a:	40 93       	lddsp	r3,sp[0x24]
80009a0c:	0e 99       	mov	r9,r7
80009a0e:	ed b5 00 05 	bld	r5,0x5
80009a12:	c4 81       	brne	80009aa2 <_vfprintf_r+0xbe2>
80009a14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a18:	40 3e       	lddsp	lr,sp[0xc]
80009a1a:	58 0e       	cp.w	lr,0
80009a1c:	c1 d0       	breq	80009a56 <_vfprintf_r+0xb96>
80009a1e:	10 36       	cp.w	r6,r8
80009a20:	c0 64       	brge	80009a2c <_vfprintf_r+0xb6c>
80009a22:	fa cc f9 44 	sub	r12,sp,-1724
80009a26:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009a2a:	c1 d8       	rjmp	80009a64 <_vfprintf_r+0xba4>
80009a2c:	fa c8 f9 50 	sub	r8,sp,-1712
80009a30:	1a d8       	st.w	--sp,r8
80009a32:	fa c8 fa b8 	sub	r8,sp,-1352
80009a36:	04 9a       	mov	r10,r2
80009a38:	1a d8       	st.w	--sp,r8
80009a3a:	fa c8 fb b4 	sub	r8,sp,-1100
80009a3e:	0c 9b       	mov	r11,r6
80009a40:	1a d8       	st.w	--sp,r8
80009a42:	08 9c       	mov	r12,r4
80009a44:	fa c8 f9 40 	sub	r8,sp,-1728
80009a48:	fa c9 ff b4 	sub	r9,sp,-76
80009a4c:	fe b0 f8 a2 	rcall	80008b90 <get_arg>
80009a50:	2f dd       	sub	sp,-12
80009a52:	78 0a       	ld.w	r10,r12[0x0]
80009a54:	c2 08       	rjmp	80009a94 <_vfprintf_r+0xbd4>
80009a56:	2f f7       	sub	r7,-1
80009a58:	10 39       	cp.w	r9,r8
80009a5a:	c0 84       	brge	80009a6a <_vfprintf_r+0xbaa>
80009a5c:	fa cb f9 44 	sub	r11,sp,-1724
80009a60:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009a64:	ec fa fd 88 	ld.w	r10,r6[-632]
80009a68:	c1 68       	rjmp	80009a94 <_vfprintf_r+0xbd4>
80009a6a:	41 09       	lddsp	r9,sp[0x40]
80009a6c:	59 f8       	cp.w	r8,31
80009a6e:	e0 89 00 10 	brgt	80009a8e <_vfprintf_r+0xbce>
80009a72:	f2 ca ff fc 	sub	r10,r9,-4
80009a76:	51 0a       	stdsp	sp[0x40],r10
80009a78:	fa c6 f9 44 	sub	r6,sp,-1724
80009a7c:	72 0a       	ld.w	r10,r9[0x0]
80009a7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009a82:	f3 4a fd 88 	st.w	r9[-632],r10
80009a86:	2f f8       	sub	r8,-1
80009a88:	fb 48 06 b4 	st.w	sp[1716],r8
80009a8c:	c0 48       	rjmp	80009a94 <_vfprintf_r+0xbd4>
80009a8e:	72 0a       	ld.w	r10,r9[0x0]
80009a90:	2f c9       	sub	r9,-4
80009a92:	51 09       	stdsp	sp[0x40],r9
80009a94:	40 be       	lddsp	lr,sp[0x2c]
80009a96:	1c 98       	mov	r8,lr
80009a98:	95 1e       	st.w	r10[0x4],lr
80009a9a:	bf 58       	asr	r8,0x1f
80009a9c:	95 08       	st.w	r10[0x0],r8
80009a9e:	fe 9f fa 9f 	bral	80008fdc <_vfprintf_r+0x11c>
80009aa2:	ed b5 00 04 	bld	r5,0x4
80009aa6:	c4 80       	breq	80009b36 <_vfprintf_r+0xc76>
80009aa8:	e2 15 00 40 	andl	r5,0x40,COH
80009aac:	c4 50       	breq	80009b36 <_vfprintf_r+0xc76>
80009aae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ab2:	40 3c       	lddsp	r12,sp[0xc]
80009ab4:	58 0c       	cp.w	r12,0
80009ab6:	c1 d0       	breq	80009af0 <_vfprintf_r+0xc30>
80009ab8:	10 36       	cp.w	r6,r8
80009aba:	c0 64       	brge	80009ac6 <_vfprintf_r+0xc06>
80009abc:	fa cb f9 44 	sub	r11,sp,-1724
80009ac0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ac4:	c1 d8       	rjmp	80009afe <_vfprintf_r+0xc3e>
80009ac6:	fa c8 f9 50 	sub	r8,sp,-1712
80009aca:	1a d8       	st.w	--sp,r8
80009acc:	fa c8 fa b8 	sub	r8,sp,-1352
80009ad0:	04 9a       	mov	r10,r2
80009ad2:	1a d8       	st.w	--sp,r8
80009ad4:	fa c8 fb b4 	sub	r8,sp,-1100
80009ad8:	0c 9b       	mov	r11,r6
80009ada:	1a d8       	st.w	--sp,r8
80009adc:	08 9c       	mov	r12,r4
80009ade:	fa c8 f9 40 	sub	r8,sp,-1728
80009ae2:	fa c9 ff b4 	sub	r9,sp,-76
80009ae6:	fe b0 f8 55 	rcall	80008b90 <get_arg>
80009aea:	2f dd       	sub	sp,-12
80009aec:	78 0a       	ld.w	r10,r12[0x0]
80009aee:	c2 08       	rjmp	80009b2e <_vfprintf_r+0xc6e>
80009af0:	2f f7       	sub	r7,-1
80009af2:	10 39       	cp.w	r9,r8
80009af4:	c0 84       	brge	80009b04 <_vfprintf_r+0xc44>
80009af6:	fa ca f9 44 	sub	r10,sp,-1724
80009afa:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009afe:	ec fa fd 88 	ld.w	r10,r6[-632]
80009b02:	c1 68       	rjmp	80009b2e <_vfprintf_r+0xc6e>
80009b04:	41 09       	lddsp	r9,sp[0x40]
80009b06:	59 f8       	cp.w	r8,31
80009b08:	e0 89 00 10 	brgt	80009b28 <_vfprintf_r+0xc68>
80009b0c:	f2 ca ff fc 	sub	r10,r9,-4
80009b10:	51 0a       	stdsp	sp[0x40],r10
80009b12:	fa c6 f9 44 	sub	r6,sp,-1724
80009b16:	72 0a       	ld.w	r10,r9[0x0]
80009b18:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009b1c:	f3 4a fd 88 	st.w	r9[-632],r10
80009b20:	2f f8       	sub	r8,-1
80009b22:	fb 48 06 b4 	st.w	sp[1716],r8
80009b26:	c0 48       	rjmp	80009b2e <_vfprintf_r+0xc6e>
80009b28:	72 0a       	ld.w	r10,r9[0x0]
80009b2a:	2f c9       	sub	r9,-4
80009b2c:	51 09       	stdsp	sp[0x40],r9
80009b2e:	40 be       	lddsp	lr,sp[0x2c]
80009b30:	b4 0e       	st.h	r10[0x0],lr
80009b32:	fe 9f fa 55 	bral	80008fdc <_vfprintf_r+0x11c>
80009b36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b3a:	40 3c       	lddsp	r12,sp[0xc]
80009b3c:	58 0c       	cp.w	r12,0
80009b3e:	c1 d0       	breq	80009b78 <_vfprintf_r+0xcb8>
80009b40:	10 36       	cp.w	r6,r8
80009b42:	c0 64       	brge	80009b4e <_vfprintf_r+0xc8e>
80009b44:	fa cb f9 44 	sub	r11,sp,-1724
80009b48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b4c:	c1 d8       	rjmp	80009b86 <_vfprintf_r+0xcc6>
80009b4e:	fa c8 f9 50 	sub	r8,sp,-1712
80009b52:	1a d8       	st.w	--sp,r8
80009b54:	fa c8 fa b8 	sub	r8,sp,-1352
80009b58:	04 9a       	mov	r10,r2
80009b5a:	1a d8       	st.w	--sp,r8
80009b5c:	fa c8 fb b4 	sub	r8,sp,-1100
80009b60:	0c 9b       	mov	r11,r6
80009b62:	1a d8       	st.w	--sp,r8
80009b64:	08 9c       	mov	r12,r4
80009b66:	fa c8 f9 40 	sub	r8,sp,-1728
80009b6a:	fa c9 ff b4 	sub	r9,sp,-76
80009b6e:	fe b0 f8 11 	rcall	80008b90 <get_arg>
80009b72:	2f dd       	sub	sp,-12
80009b74:	78 0a       	ld.w	r10,r12[0x0]
80009b76:	c2 08       	rjmp	80009bb6 <_vfprintf_r+0xcf6>
80009b78:	2f f7       	sub	r7,-1
80009b7a:	10 39       	cp.w	r9,r8
80009b7c:	c0 84       	brge	80009b8c <_vfprintf_r+0xccc>
80009b7e:	fa ca f9 44 	sub	r10,sp,-1724
80009b82:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009b86:	ec fa fd 88 	ld.w	r10,r6[-632]
80009b8a:	c1 68       	rjmp	80009bb6 <_vfprintf_r+0xcf6>
80009b8c:	41 09       	lddsp	r9,sp[0x40]
80009b8e:	59 f8       	cp.w	r8,31
80009b90:	e0 89 00 10 	brgt	80009bb0 <_vfprintf_r+0xcf0>
80009b94:	f2 ca ff fc 	sub	r10,r9,-4
80009b98:	51 0a       	stdsp	sp[0x40],r10
80009b9a:	fa c6 f9 44 	sub	r6,sp,-1724
80009b9e:	72 0a       	ld.w	r10,r9[0x0]
80009ba0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009ba4:	f3 4a fd 88 	st.w	r9[-632],r10
80009ba8:	2f f8       	sub	r8,-1
80009baa:	fb 48 06 b4 	st.w	sp[1716],r8
80009bae:	c0 48       	rjmp	80009bb6 <_vfprintf_r+0xcf6>
80009bb0:	72 0a       	ld.w	r10,r9[0x0]
80009bb2:	2f c9       	sub	r9,-4
80009bb4:	51 09       	stdsp	sp[0x40],r9
80009bb6:	40 be       	lddsp	lr,sp[0x2c]
80009bb8:	95 0e       	st.w	r10[0x0],lr
80009bba:	fe 9f fa 11 	bral	80008fdc <_vfprintf_r+0x11c>
80009bbe:	50 a7       	stdsp	sp[0x28],r7
80009bc0:	50 80       	stdsp	sp[0x20],r0
80009bc2:	0c 97       	mov	r7,r6
80009bc4:	04 94       	mov	r4,r2
80009bc6:	06 96       	mov	r6,r3
80009bc8:	02 92       	mov	r2,r1
80009bca:	40 93       	lddsp	r3,sp[0x24]
80009bcc:	10 90       	mov	r0,r8
80009bce:	40 41       	lddsp	r1,sp[0x10]
80009bd0:	a5 a5       	sbr	r5,0x4
80009bd2:	c0 a8       	rjmp	80009be6 <_vfprintf_r+0xd26>
80009bd4:	50 a7       	stdsp	sp[0x28],r7
80009bd6:	50 80       	stdsp	sp[0x20],r0
80009bd8:	0c 97       	mov	r7,r6
80009bda:	04 94       	mov	r4,r2
80009bdc:	06 96       	mov	r6,r3
80009bde:	02 92       	mov	r2,r1
80009be0:	40 93       	lddsp	r3,sp[0x24]
80009be2:	10 90       	mov	r0,r8
80009be4:	40 41       	lddsp	r1,sp[0x10]
80009be6:	ed b5 00 05 	bld	r5,0x5
80009bea:	c5 d1       	brne	80009ca4 <_vfprintf_r+0xde4>
80009bec:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bf0:	40 3c       	lddsp	r12,sp[0xc]
80009bf2:	58 0c       	cp.w	r12,0
80009bf4:	c2 60       	breq	80009c40 <_vfprintf_r+0xd80>
80009bf6:	10 36       	cp.w	r6,r8
80009bf8:	c0 a4       	brge	80009c0c <_vfprintf_r+0xd4c>
80009bfa:	fa cb f9 44 	sub	r11,sp,-1724
80009bfe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c02:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009c06:	fa e9 00 00 	st.d	sp[0],r8
80009c0a:	c1 88       	rjmp	80009c3a <_vfprintf_r+0xd7a>
80009c0c:	fa c8 f9 50 	sub	r8,sp,-1712
80009c10:	1a d8       	st.w	--sp,r8
80009c12:	fa c8 fa b8 	sub	r8,sp,-1352
80009c16:	04 9a       	mov	r10,r2
80009c18:	1a d8       	st.w	--sp,r8
80009c1a:	0c 9b       	mov	r11,r6
80009c1c:	fa c8 fb b4 	sub	r8,sp,-1100
80009c20:	08 9c       	mov	r12,r4
80009c22:	1a d8       	st.w	--sp,r8
80009c24:	fa c8 f9 40 	sub	r8,sp,-1728
80009c28:	fa c9 ff b4 	sub	r9,sp,-76
80009c2c:	fe b0 f7 b2 	rcall	80008b90 <get_arg>
80009c30:	2f dd       	sub	sp,-12
80009c32:	f8 ea 00 00 	ld.d	r10,r12[0]
80009c36:	fa eb 00 00 	st.d	sp[0],r10
80009c3a:	30 08       	mov	r8,0
80009c3c:	e0 8f 03 de 	bral	8000a3f8 <_vfprintf_r+0x1538>
80009c40:	ee ca ff ff 	sub	r10,r7,-1
80009c44:	10 37       	cp.w	r7,r8
80009c46:	c0 b4       	brge	80009c5c <_vfprintf_r+0xd9c>
80009c48:	fa c9 f9 44 	sub	r9,sp,-1724
80009c4c:	14 97       	mov	r7,r10
80009c4e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c52:	ec ea fd 88 	ld.d	r10,r6[-632]
80009c56:	fa eb 00 00 	st.d	sp[0],r10
80009c5a:	c1 88       	rjmp	80009c8a <_vfprintf_r+0xdca>
80009c5c:	41 09       	lddsp	r9,sp[0x40]
80009c5e:	59 f8       	cp.w	r8,31
80009c60:	e0 89 00 18 	brgt	80009c90 <_vfprintf_r+0xdd0>
80009c64:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c68:	f2 cb ff f8 	sub	r11,r9,-8
80009c6c:	fa e7 00 00 	st.d	sp[0],r6
80009c70:	51 0b       	stdsp	sp[0x40],r11
80009c72:	fa c6 f9 44 	sub	r6,sp,-1724
80009c76:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c7a:	fa e6 00 00 	ld.d	r6,sp[0]
80009c7e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009c82:	2f f8       	sub	r8,-1
80009c84:	14 97       	mov	r7,r10
80009c86:	fb 48 06 b4 	st.w	sp[1716],r8
80009c8a:	40 38       	lddsp	r8,sp[0xc]
80009c8c:	e0 8f 03 b6 	bral	8000a3f8 <_vfprintf_r+0x1538>
80009c90:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c94:	40 38       	lddsp	r8,sp[0xc]
80009c96:	fa e7 00 00 	st.d	sp[0],r6
80009c9a:	2f 89       	sub	r9,-8
80009c9c:	14 97       	mov	r7,r10
80009c9e:	51 09       	stdsp	sp[0x40],r9
80009ca0:	e0 8f 03 ac 	bral	8000a3f8 <_vfprintf_r+0x1538>
80009ca4:	ed b5 00 04 	bld	r5,0x4
80009ca8:	c1 61       	brne	80009cd4 <_vfprintf_r+0xe14>
80009caa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cae:	40 3e       	lddsp	lr,sp[0xc]
80009cb0:	58 0e       	cp.w	lr,0
80009cb2:	c0 80       	breq	80009cc2 <_vfprintf_r+0xe02>
80009cb4:	10 36       	cp.w	r6,r8
80009cb6:	c6 74       	brge	80009d84 <_vfprintf_r+0xec4>
80009cb8:	fa cc f9 44 	sub	r12,sp,-1724
80009cbc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009cc0:	c8 08       	rjmp	80009dc0 <_vfprintf_r+0xf00>
80009cc2:	ee ca ff ff 	sub	r10,r7,-1
80009cc6:	10 37       	cp.w	r7,r8
80009cc8:	c7 f4       	brge	80009dc6 <_vfprintf_r+0xf06>
80009cca:	fa cb f9 44 	sub	r11,sp,-1724
80009cce:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cd2:	c7 68       	rjmp	80009dbe <_vfprintf_r+0xefe>
80009cd4:	ed b5 00 06 	bld	r5,0x6
80009cd8:	c4 a1       	brne	80009d6c <_vfprintf_r+0xeac>
80009cda:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cde:	40 3c       	lddsp	r12,sp[0xc]
80009ce0:	58 0c       	cp.w	r12,0
80009ce2:	c1 d0       	breq	80009d1c <_vfprintf_r+0xe5c>
80009ce4:	10 36       	cp.w	r6,r8
80009ce6:	c0 64       	brge	80009cf2 <_vfprintf_r+0xe32>
80009ce8:	fa cb f9 44 	sub	r11,sp,-1724
80009cec:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cf0:	c1 f8       	rjmp	80009d2e <_vfprintf_r+0xe6e>
80009cf2:	fa c8 f9 50 	sub	r8,sp,-1712
80009cf6:	1a d8       	st.w	--sp,r8
80009cf8:	fa c8 fa b8 	sub	r8,sp,-1352
80009cfc:	1a d8       	st.w	--sp,r8
80009cfe:	fa c8 fb b4 	sub	r8,sp,-1100
80009d02:	1a d8       	st.w	--sp,r8
80009d04:	fa c8 f9 40 	sub	r8,sp,-1728
80009d08:	fa c9 ff b4 	sub	r9,sp,-76
80009d0c:	04 9a       	mov	r10,r2
80009d0e:	0c 9b       	mov	r11,r6
80009d10:	08 9c       	mov	r12,r4
80009d12:	fe b0 f7 3f 	rcall	80008b90 <get_arg>
80009d16:	2f dd       	sub	sp,-12
80009d18:	98 18       	ld.sh	r8,r12[0x2]
80009d1a:	c2 68       	rjmp	80009d66 <_vfprintf_r+0xea6>
80009d1c:	ee ca ff ff 	sub	r10,r7,-1
80009d20:	10 37       	cp.w	r7,r8
80009d22:	c0 94       	brge	80009d34 <_vfprintf_r+0xe74>
80009d24:	fa c9 f9 44 	sub	r9,sp,-1724
80009d28:	14 97       	mov	r7,r10
80009d2a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d2e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009d32:	c1 a8       	rjmp	80009d66 <_vfprintf_r+0xea6>
80009d34:	41 09       	lddsp	r9,sp[0x40]
80009d36:	59 f8       	cp.w	r8,31
80009d38:	e0 89 00 13 	brgt	80009d5e <_vfprintf_r+0xe9e>
80009d3c:	f2 cb ff fc 	sub	r11,r9,-4
80009d40:	51 0b       	stdsp	sp[0x40],r11
80009d42:	72 09       	ld.w	r9,r9[0x0]
80009d44:	fa c6 f9 44 	sub	r6,sp,-1724
80009d48:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009d4c:	2f f8       	sub	r8,-1
80009d4e:	f7 49 fd 88 	st.w	r11[-632],r9
80009d52:	fb 48 06 b4 	st.w	sp[1716],r8
80009d56:	14 97       	mov	r7,r10
80009d58:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009d5c:	c0 58       	rjmp	80009d66 <_vfprintf_r+0xea6>
80009d5e:	92 18       	ld.sh	r8,r9[0x2]
80009d60:	14 97       	mov	r7,r10
80009d62:	2f c9       	sub	r9,-4
80009d64:	51 09       	stdsp	sp[0x40],r9
80009d66:	5c 78       	castu.h	r8
80009d68:	50 18       	stdsp	sp[0x4],r8
80009d6a:	c4 68       	rjmp	80009df6 <_vfprintf_r+0xf36>
80009d6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d70:	40 3c       	lddsp	r12,sp[0xc]
80009d72:	58 0c       	cp.w	r12,0
80009d74:	c1 d0       	breq	80009dae <_vfprintf_r+0xeee>
80009d76:	10 36       	cp.w	r6,r8
80009d78:	c0 64       	brge	80009d84 <_vfprintf_r+0xec4>
80009d7a:	fa cb f9 44 	sub	r11,sp,-1724
80009d7e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d82:	c1 f8       	rjmp	80009dc0 <_vfprintf_r+0xf00>
80009d84:	fa c8 f9 50 	sub	r8,sp,-1712
80009d88:	1a d8       	st.w	--sp,r8
80009d8a:	fa c8 fa b8 	sub	r8,sp,-1352
80009d8e:	0c 9b       	mov	r11,r6
80009d90:	1a d8       	st.w	--sp,r8
80009d92:	fa c8 fb b4 	sub	r8,sp,-1100
80009d96:	04 9a       	mov	r10,r2
80009d98:	1a d8       	st.w	--sp,r8
80009d9a:	08 9c       	mov	r12,r4
80009d9c:	fa c8 f9 40 	sub	r8,sp,-1728
80009da0:	fa c9 ff b4 	sub	r9,sp,-76
80009da4:	fe b0 f6 f6 	rcall	80008b90 <get_arg>
80009da8:	2f dd       	sub	sp,-12
80009daa:	78 0b       	ld.w	r11,r12[0x0]
80009dac:	c2 48       	rjmp	80009df4 <_vfprintf_r+0xf34>
80009dae:	ee ca ff ff 	sub	r10,r7,-1
80009db2:	10 37       	cp.w	r7,r8
80009db4:	c0 94       	brge	80009dc6 <_vfprintf_r+0xf06>
80009db6:	fa c9 f9 44 	sub	r9,sp,-1724
80009dba:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009dbe:	14 97       	mov	r7,r10
80009dc0:	ec fb fd 88 	ld.w	r11,r6[-632]
80009dc4:	c1 88       	rjmp	80009df4 <_vfprintf_r+0xf34>
80009dc6:	41 09       	lddsp	r9,sp[0x40]
80009dc8:	59 f8       	cp.w	r8,31
80009dca:	e0 89 00 11 	brgt	80009dec <_vfprintf_r+0xf2c>
80009dce:	f2 cb ff fc 	sub	r11,r9,-4
80009dd2:	51 0b       	stdsp	sp[0x40],r11
80009dd4:	fa c6 f9 44 	sub	r6,sp,-1724
80009dd8:	72 0b       	ld.w	r11,r9[0x0]
80009dda:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009dde:	f3 4b fd 88 	st.w	r9[-632],r11
80009de2:	2f f8       	sub	r8,-1
80009de4:	14 97       	mov	r7,r10
80009de6:	fb 48 06 b4 	st.w	sp[1716],r8
80009dea:	c0 58       	rjmp	80009df4 <_vfprintf_r+0xf34>
80009dec:	72 0b       	ld.w	r11,r9[0x0]
80009dee:	14 97       	mov	r7,r10
80009df0:	2f c9       	sub	r9,-4
80009df2:	51 09       	stdsp	sp[0x40],r9
80009df4:	50 1b       	stdsp	sp[0x4],r11
80009df6:	30 0e       	mov	lr,0
80009df8:	50 0e       	stdsp	sp[0x0],lr
80009dfa:	1c 98       	mov	r8,lr
80009dfc:	e0 8f 02 fe 	bral	8000a3f8 <_vfprintf_r+0x1538>
80009e00:	50 a7       	stdsp	sp[0x28],r7
80009e02:	50 80       	stdsp	sp[0x20],r0
80009e04:	0c 97       	mov	r7,r6
80009e06:	04 94       	mov	r4,r2
80009e08:	06 96       	mov	r6,r3
80009e0a:	02 92       	mov	r2,r1
80009e0c:	40 93       	lddsp	r3,sp[0x24]
80009e0e:	40 41       	lddsp	r1,sp[0x10]
80009e10:	0e 99       	mov	r9,r7
80009e12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e16:	40 3c       	lddsp	r12,sp[0xc]
80009e18:	58 0c       	cp.w	r12,0
80009e1a:	c1 d0       	breq	80009e54 <_vfprintf_r+0xf94>
80009e1c:	10 36       	cp.w	r6,r8
80009e1e:	c0 64       	brge	80009e2a <_vfprintf_r+0xf6a>
80009e20:	fa cb f9 44 	sub	r11,sp,-1724
80009e24:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e28:	c1 d8       	rjmp	80009e62 <_vfprintf_r+0xfa2>
80009e2a:	fa c8 f9 50 	sub	r8,sp,-1712
80009e2e:	1a d8       	st.w	--sp,r8
80009e30:	fa c8 fa b8 	sub	r8,sp,-1352
80009e34:	1a d8       	st.w	--sp,r8
80009e36:	fa c8 fb b4 	sub	r8,sp,-1100
80009e3a:	1a d8       	st.w	--sp,r8
80009e3c:	fa c9 ff b4 	sub	r9,sp,-76
80009e40:	fa c8 f9 40 	sub	r8,sp,-1728
80009e44:	04 9a       	mov	r10,r2
80009e46:	0c 9b       	mov	r11,r6
80009e48:	08 9c       	mov	r12,r4
80009e4a:	fe b0 f6 a3 	rcall	80008b90 <get_arg>
80009e4e:	2f dd       	sub	sp,-12
80009e50:	78 09       	ld.w	r9,r12[0x0]
80009e52:	c2 18       	rjmp	80009e94 <_vfprintf_r+0xfd4>
80009e54:	2f f7       	sub	r7,-1
80009e56:	10 39       	cp.w	r9,r8
80009e58:	c0 84       	brge	80009e68 <_vfprintf_r+0xfa8>
80009e5a:	fa ca f9 44 	sub	r10,sp,-1724
80009e5e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009e62:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009e66:	c1 78       	rjmp	80009e94 <_vfprintf_r+0xfd4>
80009e68:	41 09       	lddsp	r9,sp[0x40]
80009e6a:	59 f8       	cp.w	r8,31
80009e6c:	e0 89 00 10 	brgt	80009e8c <_vfprintf_r+0xfcc>
80009e70:	f2 ca ff fc 	sub	r10,r9,-4
80009e74:	51 0a       	stdsp	sp[0x40],r10
80009e76:	fa c6 f9 44 	sub	r6,sp,-1724
80009e7a:	72 09       	ld.w	r9,r9[0x0]
80009e7c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009e80:	f5 49 fd 88 	st.w	r10[-632],r9
80009e84:	2f f8       	sub	r8,-1
80009e86:	fb 48 06 b4 	st.w	sp[1716],r8
80009e8a:	c0 58       	rjmp	80009e94 <_vfprintf_r+0xfd4>
80009e8c:	f2 c8 ff fc 	sub	r8,r9,-4
80009e90:	51 08       	stdsp	sp[0x40],r8
80009e92:	72 09       	ld.w	r9,r9[0x0]
80009e94:	33 08       	mov	r8,48
80009e96:	fb 68 06 b8 	st.b	sp[1720],r8
80009e9a:	37 88       	mov	r8,120
80009e9c:	30 0e       	mov	lr,0
80009e9e:	fb 68 06 b9 	st.b	sp[1721],r8
80009ea2:	fe cc ad fe 	sub	r12,pc,-20994
80009ea6:	50 19       	stdsp	sp[0x4],r9
80009ea8:	a1 b5       	sbr	r5,0x1
80009eaa:	50 0e       	stdsp	sp[0x0],lr
80009eac:	50 dc       	stdsp	sp[0x34],r12
80009eae:	30 28       	mov	r8,2
80009eb0:	37 80       	mov	r0,120
80009eb2:	e0 8f 02 a3 	bral	8000a3f8 <_vfprintf_r+0x1538>
80009eb6:	50 a7       	stdsp	sp[0x28],r7
80009eb8:	50 80       	stdsp	sp[0x20],r0
80009eba:	10 90       	mov	r0,r8
80009ebc:	30 08       	mov	r8,0
80009ebe:	fb 68 06 bb 	st.b	sp[1723],r8
80009ec2:	0c 97       	mov	r7,r6
80009ec4:	04 94       	mov	r4,r2
80009ec6:	06 96       	mov	r6,r3
80009ec8:	02 92       	mov	r2,r1
80009eca:	40 93       	lddsp	r3,sp[0x24]
80009ecc:	40 41       	lddsp	r1,sp[0x10]
80009ece:	0e 99       	mov	r9,r7
80009ed0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ed4:	40 3b       	lddsp	r11,sp[0xc]
80009ed6:	58 0b       	cp.w	r11,0
80009ed8:	c1 d0       	breq	80009f12 <_vfprintf_r+0x1052>
80009eda:	10 36       	cp.w	r6,r8
80009edc:	c0 64       	brge	80009ee8 <_vfprintf_r+0x1028>
80009ede:	fa ca f9 44 	sub	r10,sp,-1724
80009ee2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009ee6:	c1 d8       	rjmp	80009f20 <_vfprintf_r+0x1060>
80009ee8:	fa c8 f9 50 	sub	r8,sp,-1712
80009eec:	1a d8       	st.w	--sp,r8
80009eee:	fa c8 fa b8 	sub	r8,sp,-1352
80009ef2:	1a d8       	st.w	--sp,r8
80009ef4:	fa c8 fb b4 	sub	r8,sp,-1100
80009ef8:	0c 9b       	mov	r11,r6
80009efa:	1a d8       	st.w	--sp,r8
80009efc:	04 9a       	mov	r10,r2
80009efe:	fa c8 f9 40 	sub	r8,sp,-1728
80009f02:	fa c9 ff b4 	sub	r9,sp,-76
80009f06:	08 9c       	mov	r12,r4
80009f08:	fe b0 f6 44 	rcall	80008b90 <get_arg>
80009f0c:	2f dd       	sub	sp,-12
80009f0e:	78 06       	ld.w	r6,r12[0x0]
80009f10:	c2 08       	rjmp	80009f50 <_vfprintf_r+0x1090>
80009f12:	2f f7       	sub	r7,-1
80009f14:	10 39       	cp.w	r9,r8
80009f16:	c0 84       	brge	80009f26 <_vfprintf_r+0x1066>
80009f18:	fa c9 f9 44 	sub	r9,sp,-1724
80009f1c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f20:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009f24:	c1 68       	rjmp	80009f50 <_vfprintf_r+0x1090>
80009f26:	41 09       	lddsp	r9,sp[0x40]
80009f28:	59 f8       	cp.w	r8,31
80009f2a:	e0 89 00 10 	brgt	80009f4a <_vfprintf_r+0x108a>
80009f2e:	f2 ca ff fc 	sub	r10,r9,-4
80009f32:	51 0a       	stdsp	sp[0x40],r10
80009f34:	72 06       	ld.w	r6,r9[0x0]
80009f36:	fa ce f9 44 	sub	lr,sp,-1724
80009f3a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009f3e:	f3 46 fd 88 	st.w	r9[-632],r6
80009f42:	2f f8       	sub	r8,-1
80009f44:	fb 48 06 b4 	st.w	sp[1716],r8
80009f48:	c0 48       	rjmp	80009f50 <_vfprintf_r+0x1090>
80009f4a:	72 06       	ld.w	r6,r9[0x0]
80009f4c:	2f c9       	sub	r9,-4
80009f4e:	51 09       	stdsp	sp[0x40],r9
80009f50:	40 2c       	lddsp	r12,sp[0x8]
80009f52:	58 0c       	cp.w	r12,0
80009f54:	c1 05       	brlt	80009f74 <_vfprintf_r+0x10b4>
80009f56:	18 9a       	mov	r10,r12
80009f58:	30 0b       	mov	r11,0
80009f5a:	0c 9c       	mov	r12,r6
80009f5c:	e0 a0 12 38 	rcall	8000c3cc <memchr>
80009f60:	e0 80 02 df 	breq	8000a51e <_vfprintf_r+0x165e>
80009f64:	f8 06 01 02 	sub	r2,r12,r6
80009f68:	40 2b       	lddsp	r11,sp[0x8]
80009f6a:	16 32       	cp.w	r2,r11
80009f6c:	e0 89 02 d9 	brgt	8000a51e <_vfprintf_r+0x165e>
80009f70:	e0 8f 02 d4 	bral	8000a518 <_vfprintf_r+0x1658>
80009f74:	30 0a       	mov	r10,0
80009f76:	0c 9c       	mov	r12,r6
80009f78:	50 2a       	stdsp	sp[0x8],r10
80009f7a:	e0 a0 15 99 	rcall	8000caac <strlen>
80009f7e:	18 92       	mov	r2,r12
80009f80:	e0 8f 02 d2 	bral	8000a524 <_vfprintf_r+0x1664>
80009f84:	50 a7       	stdsp	sp[0x28],r7
80009f86:	50 80       	stdsp	sp[0x20],r0
80009f88:	0c 97       	mov	r7,r6
80009f8a:	04 94       	mov	r4,r2
80009f8c:	06 96       	mov	r6,r3
80009f8e:	02 92       	mov	r2,r1
80009f90:	40 93       	lddsp	r3,sp[0x24]
80009f92:	10 90       	mov	r0,r8
80009f94:	40 41       	lddsp	r1,sp[0x10]
80009f96:	a5 a5       	sbr	r5,0x4
80009f98:	c0 a8       	rjmp	80009fac <_vfprintf_r+0x10ec>
80009f9a:	50 a7       	stdsp	sp[0x28],r7
80009f9c:	50 80       	stdsp	sp[0x20],r0
80009f9e:	0c 97       	mov	r7,r6
80009fa0:	04 94       	mov	r4,r2
80009fa2:	06 96       	mov	r6,r3
80009fa4:	02 92       	mov	r2,r1
80009fa6:	40 93       	lddsp	r3,sp[0x24]
80009fa8:	10 90       	mov	r0,r8
80009faa:	40 41       	lddsp	r1,sp[0x10]
80009fac:	ed b5 00 05 	bld	r5,0x5
80009fb0:	c5 61       	brne	8000a05c <_vfprintf_r+0x119c>
80009fb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009fb6:	40 39       	lddsp	r9,sp[0xc]
80009fb8:	58 09       	cp.w	r9,0
80009fba:	c2 10       	breq	80009ffc <_vfprintf_r+0x113c>
80009fbc:	10 36       	cp.w	r6,r8
80009fbe:	c0 74       	brge	80009fcc <_vfprintf_r+0x110c>
80009fc0:	fa c8 f9 44 	sub	r8,sp,-1724
80009fc4:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009fc8:	c2 38       	rjmp	8000a00e <_vfprintf_r+0x114e>
80009fca:	d7 03       	nop
80009fcc:	fa c8 f9 50 	sub	r8,sp,-1712
80009fd0:	1a d8       	st.w	--sp,r8
80009fd2:	fa c8 fa b8 	sub	r8,sp,-1352
80009fd6:	1a d8       	st.w	--sp,r8
80009fd8:	fa c8 fb b4 	sub	r8,sp,-1100
80009fdc:	1a d8       	st.w	--sp,r8
80009fde:	fa c8 f9 40 	sub	r8,sp,-1728
80009fe2:	fa c9 ff b4 	sub	r9,sp,-76
80009fe6:	04 9a       	mov	r10,r2
80009fe8:	0c 9b       	mov	r11,r6
80009fea:	08 9c       	mov	r12,r4
80009fec:	fe b0 f5 d2 	rcall	80008b90 <get_arg>
80009ff0:	2f dd       	sub	sp,-12
80009ff2:	f8 e8 00 00 	ld.d	r8,r12[0]
80009ff6:	fa e9 00 00 	st.d	sp[0],r8
80009ffa:	c2 e8       	rjmp	8000a056 <_vfprintf_r+0x1196>
80009ffc:	ee ca ff ff 	sub	r10,r7,-1
8000a000:	10 37       	cp.w	r7,r8
8000a002:	c0 b4       	brge	8000a018 <_vfprintf_r+0x1158>
8000a004:	fa c8 f9 44 	sub	r8,sp,-1724
8000a008:	14 97       	mov	r7,r10
8000a00a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a00e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a012:	fa eb 00 00 	st.d	sp[0],r10
8000a016:	c2 08       	rjmp	8000a056 <_vfprintf_r+0x1196>
8000a018:	41 09       	lddsp	r9,sp[0x40]
8000a01a:	59 f8       	cp.w	r8,31
8000a01c:	e0 89 00 16 	brgt	8000a048 <_vfprintf_r+0x1188>
8000a020:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a024:	f2 cb ff f8 	sub	r11,r9,-8
8000a028:	fa e7 00 00 	st.d	sp[0],r6
8000a02c:	51 0b       	stdsp	sp[0x40],r11
8000a02e:	fa c6 f9 44 	sub	r6,sp,-1724
8000a032:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a036:	fa e6 00 00 	ld.d	r6,sp[0]
8000a03a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a03e:	2f f8       	sub	r8,-1
8000a040:	14 97       	mov	r7,r10
8000a042:	fb 48 06 b4 	st.w	sp[1716],r8
8000a046:	c0 88       	rjmp	8000a056 <_vfprintf_r+0x1196>
8000a048:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a04c:	2f 89       	sub	r9,-8
8000a04e:	fa e7 00 00 	st.d	sp[0],r6
8000a052:	51 09       	stdsp	sp[0x40],r9
8000a054:	14 97       	mov	r7,r10
8000a056:	30 18       	mov	r8,1
8000a058:	e0 8f 01 d0 	bral	8000a3f8 <_vfprintf_r+0x1538>
8000a05c:	ed b5 00 04 	bld	r5,0x4
8000a060:	c1 61       	brne	8000a08c <_vfprintf_r+0x11cc>
8000a062:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a066:	40 3e       	lddsp	lr,sp[0xc]
8000a068:	58 0e       	cp.w	lr,0
8000a06a:	c0 80       	breq	8000a07a <_vfprintf_r+0x11ba>
8000a06c:	10 36       	cp.w	r6,r8
8000a06e:	c6 74       	brge	8000a13c <_vfprintf_r+0x127c>
8000a070:	fa cc f9 44 	sub	r12,sp,-1724
8000a074:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a078:	c8 08       	rjmp	8000a178 <_vfprintf_r+0x12b8>
8000a07a:	ee ca ff ff 	sub	r10,r7,-1
8000a07e:	10 37       	cp.w	r7,r8
8000a080:	c7 f4       	brge	8000a17e <_vfprintf_r+0x12be>
8000a082:	fa cb f9 44 	sub	r11,sp,-1724
8000a086:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a08a:	c7 68       	rjmp	8000a176 <_vfprintf_r+0x12b6>
8000a08c:	ed b5 00 06 	bld	r5,0x6
8000a090:	c4 a1       	brne	8000a124 <_vfprintf_r+0x1264>
8000a092:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a096:	40 3c       	lddsp	r12,sp[0xc]
8000a098:	58 0c       	cp.w	r12,0
8000a09a:	c1 d0       	breq	8000a0d4 <_vfprintf_r+0x1214>
8000a09c:	10 36       	cp.w	r6,r8
8000a09e:	c0 64       	brge	8000a0aa <_vfprintf_r+0x11ea>
8000a0a0:	fa cb f9 44 	sub	r11,sp,-1724
8000a0a4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a0a8:	c1 f8       	rjmp	8000a0e6 <_vfprintf_r+0x1226>
8000a0aa:	fa c8 f9 50 	sub	r8,sp,-1712
8000a0ae:	1a d8       	st.w	--sp,r8
8000a0b0:	fa c8 fa b8 	sub	r8,sp,-1352
8000a0b4:	1a d8       	st.w	--sp,r8
8000a0b6:	fa c8 fb b4 	sub	r8,sp,-1100
8000a0ba:	1a d8       	st.w	--sp,r8
8000a0bc:	fa c8 f9 40 	sub	r8,sp,-1728
8000a0c0:	fa c9 ff b4 	sub	r9,sp,-76
8000a0c4:	04 9a       	mov	r10,r2
8000a0c6:	0c 9b       	mov	r11,r6
8000a0c8:	08 9c       	mov	r12,r4
8000a0ca:	fe b0 f5 63 	rcall	80008b90 <get_arg>
8000a0ce:	2f dd       	sub	sp,-12
8000a0d0:	98 18       	ld.sh	r8,r12[0x2]
8000a0d2:	c2 68       	rjmp	8000a11e <_vfprintf_r+0x125e>
8000a0d4:	ee ca ff ff 	sub	r10,r7,-1
8000a0d8:	10 37       	cp.w	r7,r8
8000a0da:	c0 94       	brge	8000a0ec <_vfprintf_r+0x122c>
8000a0dc:	fa c9 f9 44 	sub	r9,sp,-1724
8000a0e0:	14 97       	mov	r7,r10
8000a0e2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a0e6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a0ea:	c1 a8       	rjmp	8000a11e <_vfprintf_r+0x125e>
8000a0ec:	41 09       	lddsp	r9,sp[0x40]
8000a0ee:	59 f8       	cp.w	r8,31
8000a0f0:	e0 89 00 13 	brgt	8000a116 <_vfprintf_r+0x1256>
8000a0f4:	f2 cb ff fc 	sub	r11,r9,-4
8000a0f8:	51 0b       	stdsp	sp[0x40],r11
8000a0fa:	72 09       	ld.w	r9,r9[0x0]
8000a0fc:	fa c6 f9 44 	sub	r6,sp,-1724
8000a100:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a104:	2f f8       	sub	r8,-1
8000a106:	f7 49 fd 88 	st.w	r11[-632],r9
8000a10a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a10e:	14 97       	mov	r7,r10
8000a110:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a114:	c0 58       	rjmp	8000a11e <_vfprintf_r+0x125e>
8000a116:	92 18       	ld.sh	r8,r9[0x2]
8000a118:	14 97       	mov	r7,r10
8000a11a:	2f c9       	sub	r9,-4
8000a11c:	51 09       	stdsp	sp[0x40],r9
8000a11e:	5c 78       	castu.h	r8
8000a120:	50 18       	stdsp	sp[0x4],r8
8000a122:	c4 68       	rjmp	8000a1ae <_vfprintf_r+0x12ee>
8000a124:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a128:	40 3c       	lddsp	r12,sp[0xc]
8000a12a:	58 0c       	cp.w	r12,0
8000a12c:	c1 d0       	breq	8000a166 <_vfprintf_r+0x12a6>
8000a12e:	10 36       	cp.w	r6,r8
8000a130:	c0 64       	brge	8000a13c <_vfprintf_r+0x127c>
8000a132:	fa cb f9 44 	sub	r11,sp,-1724
8000a136:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a13a:	c1 f8       	rjmp	8000a178 <_vfprintf_r+0x12b8>
8000a13c:	fa c8 f9 50 	sub	r8,sp,-1712
8000a140:	1a d8       	st.w	--sp,r8
8000a142:	fa c8 fa b8 	sub	r8,sp,-1352
8000a146:	0c 9b       	mov	r11,r6
8000a148:	1a d8       	st.w	--sp,r8
8000a14a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a14e:	04 9a       	mov	r10,r2
8000a150:	1a d8       	st.w	--sp,r8
8000a152:	08 9c       	mov	r12,r4
8000a154:	fa c8 f9 40 	sub	r8,sp,-1728
8000a158:	fa c9 ff b4 	sub	r9,sp,-76
8000a15c:	fe b0 f5 1a 	rcall	80008b90 <get_arg>
8000a160:	2f dd       	sub	sp,-12
8000a162:	78 0b       	ld.w	r11,r12[0x0]
8000a164:	c2 48       	rjmp	8000a1ac <_vfprintf_r+0x12ec>
8000a166:	ee ca ff ff 	sub	r10,r7,-1
8000a16a:	10 37       	cp.w	r7,r8
8000a16c:	c0 94       	brge	8000a17e <_vfprintf_r+0x12be>
8000a16e:	fa c9 f9 44 	sub	r9,sp,-1724
8000a172:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a176:	14 97       	mov	r7,r10
8000a178:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a17c:	c1 88       	rjmp	8000a1ac <_vfprintf_r+0x12ec>
8000a17e:	41 09       	lddsp	r9,sp[0x40]
8000a180:	59 f8       	cp.w	r8,31
8000a182:	e0 89 00 11 	brgt	8000a1a4 <_vfprintf_r+0x12e4>
8000a186:	f2 cb ff fc 	sub	r11,r9,-4
8000a18a:	51 0b       	stdsp	sp[0x40],r11
8000a18c:	fa c6 f9 44 	sub	r6,sp,-1724
8000a190:	72 0b       	ld.w	r11,r9[0x0]
8000a192:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a196:	f3 4b fd 88 	st.w	r9[-632],r11
8000a19a:	2f f8       	sub	r8,-1
8000a19c:	14 97       	mov	r7,r10
8000a19e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a1a2:	c0 58       	rjmp	8000a1ac <_vfprintf_r+0x12ec>
8000a1a4:	72 0b       	ld.w	r11,r9[0x0]
8000a1a6:	14 97       	mov	r7,r10
8000a1a8:	2f c9       	sub	r9,-4
8000a1aa:	51 09       	stdsp	sp[0x40],r9
8000a1ac:	50 1b       	stdsp	sp[0x4],r11
8000a1ae:	30 0e       	mov	lr,0
8000a1b0:	30 18       	mov	r8,1
8000a1b2:	50 0e       	stdsp	sp[0x0],lr
8000a1b4:	c2 29       	rjmp	8000a3f8 <_vfprintf_r+0x1538>
8000a1b6:	50 a7       	stdsp	sp[0x28],r7
8000a1b8:	50 80       	stdsp	sp[0x20],r0
8000a1ba:	0c 97       	mov	r7,r6
8000a1bc:	04 94       	mov	r4,r2
8000a1be:	06 96       	mov	r6,r3
8000a1c0:	02 92       	mov	r2,r1
8000a1c2:	fe cc b1 1e 	sub	r12,pc,-20194
8000a1c6:	40 93       	lddsp	r3,sp[0x24]
8000a1c8:	10 90       	mov	r0,r8
8000a1ca:	40 41       	lddsp	r1,sp[0x10]
8000a1cc:	50 dc       	stdsp	sp[0x34],r12
8000a1ce:	ed b5 00 05 	bld	r5,0x5
8000a1d2:	c5 51       	brne	8000a27c <_vfprintf_r+0x13bc>
8000a1d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a1d8:	40 3b       	lddsp	r11,sp[0xc]
8000a1da:	58 0b       	cp.w	r11,0
8000a1dc:	c2 20       	breq	8000a220 <_vfprintf_r+0x1360>
8000a1de:	10 36       	cp.w	r6,r8
8000a1e0:	c0 a4       	brge	8000a1f4 <_vfprintf_r+0x1334>
8000a1e2:	fa ca f9 44 	sub	r10,sp,-1724
8000a1e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a1ea:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a1ee:	fa e9 00 00 	st.d	sp[0],r8
8000a1f2:	cf 28       	rjmp	8000a3d6 <_vfprintf_r+0x1516>
8000a1f4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a1f8:	1a d8       	st.w	--sp,r8
8000a1fa:	fa c8 fa b8 	sub	r8,sp,-1352
8000a1fe:	04 9a       	mov	r10,r2
8000a200:	1a d8       	st.w	--sp,r8
8000a202:	0c 9b       	mov	r11,r6
8000a204:	fa c8 fb b4 	sub	r8,sp,-1100
8000a208:	08 9c       	mov	r12,r4
8000a20a:	1a d8       	st.w	--sp,r8
8000a20c:	fa c8 f9 40 	sub	r8,sp,-1728
8000a210:	fa c9 ff b4 	sub	r9,sp,-76
8000a214:	fe b0 f4 be 	rcall	80008b90 <get_arg>
8000a218:	2f dd       	sub	sp,-12
8000a21a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a21e:	c0 c8       	rjmp	8000a236 <_vfprintf_r+0x1376>
8000a220:	ee ca ff ff 	sub	r10,r7,-1
8000a224:	10 37       	cp.w	r7,r8
8000a226:	c0 b4       	brge	8000a23c <_vfprintf_r+0x137c>
8000a228:	fa c9 f9 44 	sub	r9,sp,-1724
8000a22c:	14 97       	mov	r7,r10
8000a22e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a232:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a236:	fa eb 00 00 	st.d	sp[0],r10
8000a23a:	cc e8       	rjmp	8000a3d6 <_vfprintf_r+0x1516>
8000a23c:	41 09       	lddsp	r9,sp[0x40]
8000a23e:	59 f8       	cp.w	r8,31
8000a240:	e0 89 00 16 	brgt	8000a26c <_vfprintf_r+0x13ac>
8000a244:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a248:	f2 cb ff f8 	sub	r11,r9,-8
8000a24c:	fa e7 00 00 	st.d	sp[0],r6
8000a250:	51 0b       	stdsp	sp[0x40],r11
8000a252:	fa c6 f9 44 	sub	r6,sp,-1724
8000a256:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a25a:	fa e6 00 00 	ld.d	r6,sp[0]
8000a25e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a262:	2f f8       	sub	r8,-1
8000a264:	14 97       	mov	r7,r10
8000a266:	fb 48 06 b4 	st.w	sp[1716],r8
8000a26a:	cb 68       	rjmp	8000a3d6 <_vfprintf_r+0x1516>
8000a26c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a270:	2f 89       	sub	r9,-8
8000a272:	fa e7 00 00 	st.d	sp[0],r6
8000a276:	51 09       	stdsp	sp[0x40],r9
8000a278:	14 97       	mov	r7,r10
8000a27a:	ca e8       	rjmp	8000a3d6 <_vfprintf_r+0x1516>
8000a27c:	ed b5 00 04 	bld	r5,0x4
8000a280:	c1 71       	brne	8000a2ae <_vfprintf_r+0x13ee>
8000a282:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a286:	40 3e       	lddsp	lr,sp[0xc]
8000a288:	58 0e       	cp.w	lr,0
8000a28a:	c0 80       	breq	8000a29a <_vfprintf_r+0x13da>
8000a28c:	10 36       	cp.w	r6,r8
8000a28e:	c6 94       	brge	8000a360 <_vfprintf_r+0x14a0>
8000a290:	fa cc f9 44 	sub	r12,sp,-1724
8000a294:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a298:	c8 28       	rjmp	8000a39c <_vfprintf_r+0x14dc>
8000a29a:	ee ca ff ff 	sub	r10,r7,-1
8000a29e:	10 37       	cp.w	r7,r8
8000a2a0:	e0 84 00 81 	brge	8000a3a2 <_vfprintf_r+0x14e2>
8000a2a4:	fa cb f9 44 	sub	r11,sp,-1724
8000a2a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a2ac:	c7 78       	rjmp	8000a39a <_vfprintf_r+0x14da>
8000a2ae:	ed b5 00 06 	bld	r5,0x6
8000a2b2:	c4 b1       	brne	8000a348 <_vfprintf_r+0x1488>
8000a2b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2b8:	40 3c       	lddsp	r12,sp[0xc]
8000a2ba:	58 0c       	cp.w	r12,0
8000a2bc:	c1 d0       	breq	8000a2f6 <_vfprintf_r+0x1436>
8000a2be:	10 36       	cp.w	r6,r8
8000a2c0:	c0 64       	brge	8000a2cc <_vfprintf_r+0x140c>
8000a2c2:	fa cb f9 44 	sub	r11,sp,-1724
8000a2c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a2ca:	c1 f8       	rjmp	8000a308 <_vfprintf_r+0x1448>
8000a2cc:	fa c8 f9 50 	sub	r8,sp,-1712
8000a2d0:	1a d8       	st.w	--sp,r8
8000a2d2:	fa c8 fa b8 	sub	r8,sp,-1352
8000a2d6:	1a d8       	st.w	--sp,r8
8000a2d8:	fa c8 fb b4 	sub	r8,sp,-1100
8000a2dc:	1a d8       	st.w	--sp,r8
8000a2de:	fa c8 f9 40 	sub	r8,sp,-1728
8000a2e2:	fa c9 ff b4 	sub	r9,sp,-76
8000a2e6:	04 9a       	mov	r10,r2
8000a2e8:	0c 9b       	mov	r11,r6
8000a2ea:	08 9c       	mov	r12,r4
8000a2ec:	fe b0 f4 52 	rcall	80008b90 <get_arg>
8000a2f0:	2f dd       	sub	sp,-12
8000a2f2:	98 18       	ld.sh	r8,r12[0x2]
8000a2f4:	c2 78       	rjmp	8000a342 <_vfprintf_r+0x1482>
8000a2f6:	ee ca ff ff 	sub	r10,r7,-1
8000a2fa:	10 37       	cp.w	r7,r8
8000a2fc:	c0 a4       	brge	8000a310 <_vfprintf_r+0x1450>
8000a2fe:	fa c9 f9 44 	sub	r9,sp,-1724
8000a302:	14 97       	mov	r7,r10
8000a304:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a308:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a30c:	c1 b8       	rjmp	8000a342 <_vfprintf_r+0x1482>
8000a30e:	d7 03       	nop
8000a310:	41 09       	lddsp	r9,sp[0x40]
8000a312:	59 f8       	cp.w	r8,31
8000a314:	e0 89 00 13 	brgt	8000a33a <_vfprintf_r+0x147a>
8000a318:	f2 cb ff fc 	sub	r11,r9,-4
8000a31c:	51 0b       	stdsp	sp[0x40],r11
8000a31e:	72 09       	ld.w	r9,r9[0x0]
8000a320:	fa c6 f9 44 	sub	r6,sp,-1724
8000a324:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a328:	2f f8       	sub	r8,-1
8000a32a:	f7 49 fd 88 	st.w	r11[-632],r9
8000a32e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a332:	14 97       	mov	r7,r10
8000a334:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a338:	c0 58       	rjmp	8000a342 <_vfprintf_r+0x1482>
8000a33a:	92 18       	ld.sh	r8,r9[0x2]
8000a33c:	14 97       	mov	r7,r10
8000a33e:	2f c9       	sub	r9,-4
8000a340:	51 09       	stdsp	sp[0x40],r9
8000a342:	5c 78       	castu.h	r8
8000a344:	50 18       	stdsp	sp[0x4],r8
8000a346:	c4 68       	rjmp	8000a3d2 <_vfprintf_r+0x1512>
8000a348:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a34c:	40 3c       	lddsp	r12,sp[0xc]
8000a34e:	58 0c       	cp.w	r12,0
8000a350:	c1 d0       	breq	8000a38a <_vfprintf_r+0x14ca>
8000a352:	10 36       	cp.w	r6,r8
8000a354:	c0 64       	brge	8000a360 <_vfprintf_r+0x14a0>
8000a356:	fa cb f9 44 	sub	r11,sp,-1724
8000a35a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a35e:	c1 f8       	rjmp	8000a39c <_vfprintf_r+0x14dc>
8000a360:	fa c8 f9 50 	sub	r8,sp,-1712
8000a364:	1a d8       	st.w	--sp,r8
8000a366:	fa c8 fa b8 	sub	r8,sp,-1352
8000a36a:	0c 9b       	mov	r11,r6
8000a36c:	1a d8       	st.w	--sp,r8
8000a36e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a372:	04 9a       	mov	r10,r2
8000a374:	1a d8       	st.w	--sp,r8
8000a376:	08 9c       	mov	r12,r4
8000a378:	fa c8 f9 40 	sub	r8,sp,-1728
8000a37c:	fa c9 ff b4 	sub	r9,sp,-76
8000a380:	fe b0 f4 08 	rcall	80008b90 <get_arg>
8000a384:	2f dd       	sub	sp,-12
8000a386:	78 0b       	ld.w	r11,r12[0x0]
8000a388:	c2 48       	rjmp	8000a3d0 <_vfprintf_r+0x1510>
8000a38a:	ee ca ff ff 	sub	r10,r7,-1
8000a38e:	10 37       	cp.w	r7,r8
8000a390:	c0 94       	brge	8000a3a2 <_vfprintf_r+0x14e2>
8000a392:	fa c9 f9 44 	sub	r9,sp,-1724
8000a396:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a39a:	14 97       	mov	r7,r10
8000a39c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a3a0:	c1 88       	rjmp	8000a3d0 <_vfprintf_r+0x1510>
8000a3a2:	41 09       	lddsp	r9,sp[0x40]
8000a3a4:	59 f8       	cp.w	r8,31
8000a3a6:	e0 89 00 11 	brgt	8000a3c8 <_vfprintf_r+0x1508>
8000a3aa:	f2 cb ff fc 	sub	r11,r9,-4
8000a3ae:	51 0b       	stdsp	sp[0x40],r11
8000a3b0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a3b4:	72 0b       	ld.w	r11,r9[0x0]
8000a3b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a3ba:	f3 4b fd 88 	st.w	r9[-632],r11
8000a3be:	2f f8       	sub	r8,-1
8000a3c0:	14 97       	mov	r7,r10
8000a3c2:	fb 48 06 b4 	st.w	sp[1716],r8
8000a3c6:	c0 58       	rjmp	8000a3d0 <_vfprintf_r+0x1510>
8000a3c8:	72 0b       	ld.w	r11,r9[0x0]
8000a3ca:	14 97       	mov	r7,r10
8000a3cc:	2f c9       	sub	r9,-4
8000a3ce:	51 09       	stdsp	sp[0x40],r9
8000a3d0:	50 1b       	stdsp	sp[0x4],r11
8000a3d2:	30 0e       	mov	lr,0
8000a3d4:	50 0e       	stdsp	sp[0x0],lr
8000a3d6:	40 08       	lddsp	r8,sp[0x0]
8000a3d8:	40 1c       	lddsp	r12,sp[0x4]
8000a3da:	18 48       	or	r8,r12
8000a3dc:	5f 19       	srne	r9
8000a3de:	0a 98       	mov	r8,r5
8000a3e0:	eb e9 00 09 	and	r9,r5,r9
8000a3e4:	a1 b8       	sbr	r8,0x1
8000a3e6:	58 09       	cp.w	r9,0
8000a3e8:	c0 70       	breq	8000a3f6 <_vfprintf_r+0x1536>
8000a3ea:	10 95       	mov	r5,r8
8000a3ec:	fb 60 06 b9 	st.b	sp[1721],r0
8000a3f0:	33 08       	mov	r8,48
8000a3f2:	fb 68 06 b8 	st.b	sp[1720],r8
8000a3f6:	30 28       	mov	r8,2
8000a3f8:	30 09       	mov	r9,0
8000a3fa:	fb 69 06 bb 	st.b	sp[1723],r9
8000a3fe:	0a 99       	mov	r9,r5
8000a400:	a7 d9       	cbr	r9,0x7
8000a402:	40 2b       	lddsp	r11,sp[0x8]
8000a404:	40 16       	lddsp	r6,sp[0x4]
8000a406:	58 0b       	cp.w	r11,0
8000a408:	5f 1a       	srne	r10
8000a40a:	f2 05 17 40 	movge	r5,r9
8000a40e:	fa c2 f9 78 	sub	r2,sp,-1672
8000a412:	40 09       	lddsp	r9,sp[0x0]
8000a414:	0c 49       	or	r9,r6
8000a416:	5f 19       	srne	r9
8000a418:	f5 e9 10 09 	or	r9,r10,r9
8000a41c:	c5 c0       	breq	8000a4d4 <_vfprintf_r+0x1614>
8000a41e:	30 19       	mov	r9,1
8000a420:	f2 08 18 00 	cp.b	r8,r9
8000a424:	c0 60       	breq	8000a430 <_vfprintf_r+0x1570>
8000a426:	30 29       	mov	r9,2
8000a428:	f2 08 18 00 	cp.b	r8,r9
8000a42c:	c0 41       	brne	8000a434 <_vfprintf_r+0x1574>
8000a42e:	c3 c8       	rjmp	8000a4a6 <_vfprintf_r+0x15e6>
8000a430:	04 96       	mov	r6,r2
8000a432:	c3 08       	rjmp	8000a492 <_vfprintf_r+0x15d2>
8000a434:	04 96       	mov	r6,r2
8000a436:	fa e8 00 00 	ld.d	r8,sp[0]
8000a43a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a43e:	2d 0a       	sub	r10,-48
8000a440:	0c fa       	st.b	--r6,r10
8000a442:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a446:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a44a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a44e:	18 99       	mov	r9,r12
8000a450:	16 98       	mov	r8,r11
8000a452:	58 08       	cp.w	r8,0
8000a454:	5c 29       	cpc	r9
8000a456:	cf 21       	brne	8000a43a <_vfprintf_r+0x157a>
8000a458:	fa e9 00 00 	st.d	sp[0],r8
8000a45c:	ed b5 00 00 	bld	r5,0x0
8000a460:	c4 51       	brne	8000a4ea <_vfprintf_r+0x162a>
8000a462:	33 09       	mov	r9,48
8000a464:	f2 0a 18 00 	cp.b	r10,r9
8000a468:	c4 10       	breq	8000a4ea <_vfprintf_r+0x162a>
8000a46a:	0c f9       	st.b	--r6,r9
8000a46c:	c3 f8       	rjmp	8000a4ea <_vfprintf_r+0x162a>
8000a46e:	fa ea 00 00 	ld.d	r10,sp[0]
8000a472:	30 a8       	mov	r8,10
8000a474:	30 09       	mov	r9,0
8000a476:	e0 a0 1a 19 	rcall	8000d8a8 <__avr32_umod64>
8000a47a:	30 a8       	mov	r8,10
8000a47c:	2d 0a       	sub	r10,-48
8000a47e:	30 09       	mov	r9,0
8000a480:	ac 8a       	st.b	r6[0x0],r10
8000a482:	fa ea 00 00 	ld.d	r10,sp[0]
8000a486:	e0 a0 18 df 	rcall	8000d644 <__avr32_udiv64>
8000a48a:	16 99       	mov	r9,r11
8000a48c:	14 98       	mov	r8,r10
8000a48e:	fa e9 00 00 	st.d	sp[0],r8
8000a492:	20 16       	sub	r6,1
8000a494:	fa ea 00 00 	ld.d	r10,sp[0]
8000a498:	58 9a       	cp.w	r10,9
8000a49a:	5c 2b       	cpc	r11
8000a49c:	fe 9b ff e9 	brhi	8000a46e <_vfprintf_r+0x15ae>
8000a4a0:	1b f8       	ld.ub	r8,sp[0x7]
8000a4a2:	2d 08       	sub	r8,-48
8000a4a4:	c2 08       	rjmp	8000a4e4 <_vfprintf_r+0x1624>
8000a4a6:	04 96       	mov	r6,r2
8000a4a8:	fa e8 00 00 	ld.d	r8,sp[0]
8000a4ac:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a4b0:	40 de       	lddsp	lr,sp[0x34]
8000a4b2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a4b6:	0c fa       	st.b	--r6,r10
8000a4b8:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a4bc:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a4c0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a4c4:	16 99       	mov	r9,r11
8000a4c6:	14 98       	mov	r8,r10
8000a4c8:	58 08       	cp.w	r8,0
8000a4ca:	5c 29       	cpc	r9
8000a4cc:	cf 01       	brne	8000a4ac <_vfprintf_r+0x15ec>
8000a4ce:	fa e9 00 00 	st.d	sp[0],r8
8000a4d2:	c0 c8       	rjmp	8000a4ea <_vfprintf_r+0x162a>
8000a4d4:	58 08       	cp.w	r8,0
8000a4d6:	c0 91       	brne	8000a4e8 <_vfprintf_r+0x1628>
8000a4d8:	ed b5 00 00 	bld	r5,0x0
8000a4dc:	c0 61       	brne	8000a4e8 <_vfprintf_r+0x1628>
8000a4de:	fa c6 f9 79 	sub	r6,sp,-1671
8000a4e2:	33 08       	mov	r8,48
8000a4e4:	ac 88       	st.b	r6[0x0],r8
8000a4e6:	c0 28       	rjmp	8000a4ea <_vfprintf_r+0x162a>
8000a4e8:	04 96       	mov	r6,r2
8000a4ea:	0c 12       	sub	r2,r6
8000a4ec:	c1 c8       	rjmp	8000a524 <_vfprintf_r+0x1664>
8000a4ee:	50 a7       	stdsp	sp[0x28],r7
8000a4f0:	50 80       	stdsp	sp[0x20],r0
8000a4f2:	40 93       	lddsp	r3,sp[0x24]
8000a4f4:	0c 97       	mov	r7,r6
8000a4f6:	10 90       	mov	r0,r8
8000a4f8:	04 94       	mov	r4,r2
8000a4fa:	40 41       	lddsp	r1,sp[0x10]
8000a4fc:	58 08       	cp.w	r8,0
8000a4fe:	e0 80 04 4f 	breq	8000ad9c <_vfprintf_r+0x1edc>
8000a502:	fb 68 06 60 	st.b	sp[1632],r8
8000a506:	30 0c       	mov	r12,0
8000a508:	30 08       	mov	r8,0
8000a50a:	30 12       	mov	r2,1
8000a50c:	fb 68 06 bb 	st.b	sp[1723],r8
8000a510:	50 2c       	stdsp	sp[0x8],r12
8000a512:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a516:	c0 78       	rjmp	8000a524 <_vfprintf_r+0x1664>
8000a518:	30 0b       	mov	r11,0
8000a51a:	50 2b       	stdsp	sp[0x8],r11
8000a51c:	c0 48       	rjmp	8000a524 <_vfprintf_r+0x1664>
8000a51e:	40 22       	lddsp	r2,sp[0x8]
8000a520:	30 0a       	mov	r10,0
8000a522:	50 2a       	stdsp	sp[0x8],r10
8000a524:	40 29       	lddsp	r9,sp[0x8]
8000a526:	e4 09 0c 49 	max	r9,r2,r9
8000a52a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a52e:	50 39       	stdsp	sp[0xc],r9
8000a530:	0a 9e       	mov	lr,r5
8000a532:	30 09       	mov	r9,0
8000a534:	e2 1e 00 02 	andl	lr,0x2,COH
8000a538:	f2 08 18 00 	cp.b	r8,r9
8000a53c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a540:	f7 b8 01 ff 	subne	r8,-1
8000a544:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a548:	0a 9b       	mov	r11,r5
8000a54a:	58 0e       	cp.w	lr,0
8000a54c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a550:	f7 bc 01 fe 	subne	r12,-2
8000a554:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a558:	e2 1b 00 84 	andl	r11,0x84,COH
8000a55c:	50 fe       	stdsp	sp[0x3c],lr
8000a55e:	50 9b       	stdsp	sp[0x24],r11
8000a560:	c4 71       	brne	8000a5ee <_vfprintf_r+0x172e>
8000a562:	40 8a       	lddsp	r10,sp[0x20]
8000a564:	40 39       	lddsp	r9,sp[0xc]
8000a566:	12 1a       	sub	r10,r9
8000a568:	50 4a       	stdsp	sp[0x10],r10
8000a56a:	58 0a       	cp.w	r10,0
8000a56c:	e0 89 00 20 	brgt	8000a5ac <_vfprintf_r+0x16ec>
8000a570:	c3 f8       	rjmp	8000a5ee <_vfprintf_r+0x172e>
8000a572:	2f 09       	sub	r9,-16
8000a574:	2f f8       	sub	r8,-1
8000a576:	fe ce b4 ba 	sub	lr,pc,-19270
8000a57a:	31 0c       	mov	r12,16
8000a57c:	fb 49 06 90 	st.w	sp[1680],r9
8000a580:	87 0e       	st.w	r3[0x0],lr
8000a582:	87 1c       	st.w	r3[0x4],r12
8000a584:	fb 48 06 8c 	st.w	sp[1676],r8
8000a588:	58 78       	cp.w	r8,7
8000a58a:	e0 89 00 04 	brgt	8000a592 <_vfprintf_r+0x16d2>
8000a58e:	2f 83       	sub	r3,-8
8000a590:	c0 b8       	rjmp	8000a5a6 <_vfprintf_r+0x16e6>
8000a592:	fa ca f9 78 	sub	r10,sp,-1672
8000a596:	02 9b       	mov	r11,r1
8000a598:	08 9c       	mov	r12,r4
8000a59a:	fe b0 f4 85 	rcall	80008ea4 <__sprint_r>
8000a59e:	e0 81 04 10 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a5a2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5a6:	40 4b       	lddsp	r11,sp[0x10]
8000a5a8:	21 0b       	sub	r11,16
8000a5aa:	50 4b       	stdsp	sp[0x10],r11
8000a5ac:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a5b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5b4:	fe ca b4 f8 	sub	r10,pc,-19208
8000a5b8:	40 4e       	lddsp	lr,sp[0x10]
8000a5ba:	59 0e       	cp.w	lr,16
8000a5bc:	fe 99 ff db 	brgt	8000a572 <_vfprintf_r+0x16b2>
8000a5c0:	1c 09       	add	r9,lr
8000a5c2:	2f f8       	sub	r8,-1
8000a5c4:	87 0a       	st.w	r3[0x0],r10
8000a5c6:	fb 49 06 90 	st.w	sp[1680],r9
8000a5ca:	87 1e       	st.w	r3[0x4],lr
8000a5cc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5d0:	58 78       	cp.w	r8,7
8000a5d2:	e0 89 00 04 	brgt	8000a5da <_vfprintf_r+0x171a>
8000a5d6:	2f 83       	sub	r3,-8
8000a5d8:	c0 b8       	rjmp	8000a5ee <_vfprintf_r+0x172e>
8000a5da:	fa ca f9 78 	sub	r10,sp,-1672
8000a5de:	02 9b       	mov	r11,r1
8000a5e0:	08 9c       	mov	r12,r4
8000a5e2:	fe b0 f4 61 	rcall	80008ea4 <__sprint_r>
8000a5e6:	e0 81 03 ec 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a5ea:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5ee:	30 09       	mov	r9,0
8000a5f0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a5f4:	f2 08 18 00 	cp.b	r8,r9
8000a5f8:	c1 f0       	breq	8000a636 <_vfprintf_r+0x1776>
8000a5fa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5fe:	fa c9 f9 45 	sub	r9,sp,-1723
8000a602:	2f f8       	sub	r8,-1
8000a604:	87 09       	st.w	r3[0x0],r9
8000a606:	fb 48 06 90 	st.w	sp[1680],r8
8000a60a:	30 19       	mov	r9,1
8000a60c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a610:	87 19       	st.w	r3[0x4],r9
8000a612:	2f f8       	sub	r8,-1
8000a614:	fb 48 06 8c 	st.w	sp[1676],r8
8000a618:	58 78       	cp.w	r8,7
8000a61a:	e0 89 00 04 	brgt	8000a622 <_vfprintf_r+0x1762>
8000a61e:	2f 83       	sub	r3,-8
8000a620:	c0 b8       	rjmp	8000a636 <_vfprintf_r+0x1776>
8000a622:	fa ca f9 78 	sub	r10,sp,-1672
8000a626:	02 9b       	mov	r11,r1
8000a628:	08 9c       	mov	r12,r4
8000a62a:	fe b0 f4 3d 	rcall	80008ea4 <__sprint_r>
8000a62e:	e0 81 03 c8 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a632:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a636:	40 fc       	lddsp	r12,sp[0x3c]
8000a638:	58 0c       	cp.w	r12,0
8000a63a:	c1 f0       	breq	8000a678 <_vfprintf_r+0x17b8>
8000a63c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a640:	fa c9 f9 48 	sub	r9,sp,-1720
8000a644:	2f e8       	sub	r8,-2
8000a646:	87 09       	st.w	r3[0x0],r9
8000a648:	fb 48 06 90 	st.w	sp[1680],r8
8000a64c:	30 29       	mov	r9,2
8000a64e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a652:	87 19       	st.w	r3[0x4],r9
8000a654:	2f f8       	sub	r8,-1
8000a656:	fb 48 06 8c 	st.w	sp[1676],r8
8000a65a:	58 78       	cp.w	r8,7
8000a65c:	e0 89 00 04 	brgt	8000a664 <_vfprintf_r+0x17a4>
8000a660:	2f 83       	sub	r3,-8
8000a662:	c0 b8       	rjmp	8000a678 <_vfprintf_r+0x17b8>
8000a664:	fa ca f9 78 	sub	r10,sp,-1672
8000a668:	02 9b       	mov	r11,r1
8000a66a:	08 9c       	mov	r12,r4
8000a66c:	fe b0 f4 1c 	rcall	80008ea4 <__sprint_r>
8000a670:	e0 81 03 a7 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a674:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a678:	40 9b       	lddsp	r11,sp[0x24]
8000a67a:	e0 4b 00 80 	cp.w	r11,128
8000a67e:	c4 71       	brne	8000a70c <_vfprintf_r+0x184c>
8000a680:	40 8a       	lddsp	r10,sp[0x20]
8000a682:	40 39       	lddsp	r9,sp[0xc]
8000a684:	12 1a       	sub	r10,r9
8000a686:	50 4a       	stdsp	sp[0x10],r10
8000a688:	58 0a       	cp.w	r10,0
8000a68a:	e0 89 00 20 	brgt	8000a6ca <_vfprintf_r+0x180a>
8000a68e:	c3 f8       	rjmp	8000a70c <_vfprintf_r+0x184c>
8000a690:	2f 09       	sub	r9,-16
8000a692:	2f f8       	sub	r8,-1
8000a694:	fe ce b5 c8 	sub	lr,pc,-19000
8000a698:	31 0c       	mov	r12,16
8000a69a:	fb 49 06 90 	st.w	sp[1680],r9
8000a69e:	87 0e       	st.w	r3[0x0],lr
8000a6a0:	87 1c       	st.w	r3[0x4],r12
8000a6a2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6a6:	58 78       	cp.w	r8,7
8000a6a8:	e0 89 00 04 	brgt	8000a6b0 <_vfprintf_r+0x17f0>
8000a6ac:	2f 83       	sub	r3,-8
8000a6ae:	c0 b8       	rjmp	8000a6c4 <_vfprintf_r+0x1804>
8000a6b0:	fa ca f9 78 	sub	r10,sp,-1672
8000a6b4:	02 9b       	mov	r11,r1
8000a6b6:	08 9c       	mov	r12,r4
8000a6b8:	fe b0 f3 f6 	rcall	80008ea4 <__sprint_r>
8000a6bc:	e0 81 03 81 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a6c0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6c4:	40 4b       	lddsp	r11,sp[0x10]
8000a6c6:	21 0b       	sub	r11,16
8000a6c8:	50 4b       	stdsp	sp[0x10],r11
8000a6ca:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a6ce:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6d2:	fe ca b6 06 	sub	r10,pc,-18938
8000a6d6:	40 4e       	lddsp	lr,sp[0x10]
8000a6d8:	59 0e       	cp.w	lr,16
8000a6da:	fe 99 ff db 	brgt	8000a690 <_vfprintf_r+0x17d0>
8000a6de:	1c 09       	add	r9,lr
8000a6e0:	2f f8       	sub	r8,-1
8000a6e2:	87 0a       	st.w	r3[0x0],r10
8000a6e4:	fb 49 06 90 	st.w	sp[1680],r9
8000a6e8:	87 1e       	st.w	r3[0x4],lr
8000a6ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6ee:	58 78       	cp.w	r8,7
8000a6f0:	e0 89 00 04 	brgt	8000a6f8 <_vfprintf_r+0x1838>
8000a6f4:	2f 83       	sub	r3,-8
8000a6f6:	c0 b8       	rjmp	8000a70c <_vfprintf_r+0x184c>
8000a6f8:	fa ca f9 78 	sub	r10,sp,-1672
8000a6fc:	02 9b       	mov	r11,r1
8000a6fe:	08 9c       	mov	r12,r4
8000a700:	fe b0 f3 d2 	rcall	80008ea4 <__sprint_r>
8000a704:	e0 81 03 5d 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a708:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a70c:	40 2c       	lddsp	r12,sp[0x8]
8000a70e:	04 1c       	sub	r12,r2
8000a710:	50 2c       	stdsp	sp[0x8],r12
8000a712:	58 0c       	cp.w	r12,0
8000a714:	e0 89 00 20 	brgt	8000a754 <_vfprintf_r+0x1894>
8000a718:	c3 f8       	rjmp	8000a796 <_vfprintf_r+0x18d6>
8000a71a:	2f 09       	sub	r9,-16
8000a71c:	2f f8       	sub	r8,-1
8000a71e:	fe cb b6 52 	sub	r11,pc,-18862
8000a722:	31 0a       	mov	r10,16
8000a724:	fb 49 06 90 	st.w	sp[1680],r9
8000a728:	87 0b       	st.w	r3[0x0],r11
8000a72a:	87 1a       	st.w	r3[0x4],r10
8000a72c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a730:	58 78       	cp.w	r8,7
8000a732:	e0 89 00 04 	brgt	8000a73a <_vfprintf_r+0x187a>
8000a736:	2f 83       	sub	r3,-8
8000a738:	c0 b8       	rjmp	8000a74e <_vfprintf_r+0x188e>
8000a73a:	fa ca f9 78 	sub	r10,sp,-1672
8000a73e:	02 9b       	mov	r11,r1
8000a740:	08 9c       	mov	r12,r4
8000a742:	fe b0 f3 b1 	rcall	80008ea4 <__sprint_r>
8000a746:	e0 81 03 3c 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a74a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a74e:	40 29       	lddsp	r9,sp[0x8]
8000a750:	21 09       	sub	r9,16
8000a752:	50 29       	stdsp	sp[0x8],r9
8000a754:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a758:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a75c:	fe ca b6 90 	sub	r10,pc,-18800
8000a760:	40 2e       	lddsp	lr,sp[0x8]
8000a762:	59 0e       	cp.w	lr,16
8000a764:	fe 99 ff db 	brgt	8000a71a <_vfprintf_r+0x185a>
8000a768:	1c 09       	add	r9,lr
8000a76a:	2f f8       	sub	r8,-1
8000a76c:	87 0a       	st.w	r3[0x0],r10
8000a76e:	fb 49 06 90 	st.w	sp[1680],r9
8000a772:	87 1e       	st.w	r3[0x4],lr
8000a774:	fb 48 06 8c 	st.w	sp[1676],r8
8000a778:	58 78       	cp.w	r8,7
8000a77a:	e0 89 00 04 	brgt	8000a782 <_vfprintf_r+0x18c2>
8000a77e:	2f 83       	sub	r3,-8
8000a780:	c0 b8       	rjmp	8000a796 <_vfprintf_r+0x18d6>
8000a782:	fa ca f9 78 	sub	r10,sp,-1672
8000a786:	02 9b       	mov	r11,r1
8000a788:	08 9c       	mov	r12,r4
8000a78a:	fe b0 f3 8d 	rcall	80008ea4 <__sprint_r>
8000a78e:	e0 81 03 18 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a792:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a796:	ed b5 00 08 	bld	r5,0x8
8000a79a:	c0 b0       	breq	8000a7b0 <_vfprintf_r+0x18f0>
8000a79c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7a0:	87 12       	st.w	r3[0x4],r2
8000a7a2:	87 06       	st.w	r3[0x0],r6
8000a7a4:	f0 02 00 02 	add	r2,r8,r2
8000a7a8:	fb 42 06 90 	st.w	sp[1680],r2
8000a7ac:	e0 8f 01 d4 	bral	8000ab54 <_vfprintf_r+0x1c94>
8000a7b0:	e0 40 00 65 	cp.w	r0,101
8000a7b4:	e0 8a 01 d6 	brle	8000ab60 <_vfprintf_r+0x1ca0>
8000a7b8:	30 08       	mov	r8,0
8000a7ba:	30 09       	mov	r9,0
8000a7bc:	40 5b       	lddsp	r11,sp[0x14]
8000a7be:	40 7a       	lddsp	r10,sp[0x1c]
8000a7c0:	e0 a0 15 3b 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000a7c4:	c7 90       	breq	8000a8b6 <_vfprintf_r+0x19f6>
8000a7c6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7ca:	fe c9 b7 12 	sub	r9,pc,-18670
8000a7ce:	2f f8       	sub	r8,-1
8000a7d0:	87 09       	st.w	r3[0x0],r9
8000a7d2:	fb 48 06 90 	st.w	sp[1680],r8
8000a7d6:	30 19       	mov	r9,1
8000a7d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7dc:	87 19       	st.w	r3[0x4],r9
8000a7de:	2f f8       	sub	r8,-1
8000a7e0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7e4:	58 78       	cp.w	r8,7
8000a7e6:	e0 89 00 05 	brgt	8000a7f0 <_vfprintf_r+0x1930>
8000a7ea:	2f 83       	sub	r3,-8
8000a7ec:	c0 c8       	rjmp	8000a804 <_vfprintf_r+0x1944>
8000a7ee:	d7 03       	nop
8000a7f0:	fa ca f9 78 	sub	r10,sp,-1672
8000a7f4:	02 9b       	mov	r11,r1
8000a7f6:	08 9c       	mov	r12,r4
8000a7f8:	fe b0 f3 56 	rcall	80008ea4 <__sprint_r>
8000a7fc:	e0 81 02 e1 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a800:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a804:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a808:	40 6c       	lddsp	r12,sp[0x18]
8000a80a:	18 38       	cp.w	r8,r12
8000a80c:	c0 55       	brlt	8000a816 <_vfprintf_r+0x1956>
8000a80e:	ed b5 00 00 	bld	r5,0x0
8000a812:	e0 81 02 6b 	brne	8000ace8 <_vfprintf_r+0x1e28>
8000a816:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a81a:	2f f8       	sub	r8,-1
8000a81c:	40 cb       	lddsp	r11,sp[0x30]
8000a81e:	fb 48 06 90 	st.w	sp[1680],r8
8000a822:	30 19       	mov	r9,1
8000a824:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a828:	87 0b       	st.w	r3[0x0],r11
8000a82a:	2f f8       	sub	r8,-1
8000a82c:	87 19       	st.w	r3[0x4],r9
8000a82e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a832:	58 78       	cp.w	r8,7
8000a834:	e0 89 00 04 	brgt	8000a83c <_vfprintf_r+0x197c>
8000a838:	2f 83       	sub	r3,-8
8000a83a:	c0 b8       	rjmp	8000a850 <_vfprintf_r+0x1990>
8000a83c:	fa ca f9 78 	sub	r10,sp,-1672
8000a840:	02 9b       	mov	r11,r1
8000a842:	08 9c       	mov	r12,r4
8000a844:	fe b0 f3 30 	rcall	80008ea4 <__sprint_r>
8000a848:	e0 81 02 bb 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a84c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a850:	40 66       	lddsp	r6,sp[0x18]
8000a852:	20 16       	sub	r6,1
8000a854:	58 06       	cp.w	r6,0
8000a856:	e0 89 00 1d 	brgt	8000a890 <_vfprintf_r+0x19d0>
8000a85a:	e0 8f 02 47 	bral	8000ace8 <_vfprintf_r+0x1e28>
8000a85e:	2f 09       	sub	r9,-16
8000a860:	2f f8       	sub	r8,-1
8000a862:	fb 49 06 90 	st.w	sp[1680],r9
8000a866:	87 02       	st.w	r3[0x0],r2
8000a868:	87 10       	st.w	r3[0x4],r0
8000a86a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a86e:	58 78       	cp.w	r8,7
8000a870:	e0 89 00 04 	brgt	8000a878 <_vfprintf_r+0x19b8>
8000a874:	2f 83       	sub	r3,-8
8000a876:	c0 b8       	rjmp	8000a88c <_vfprintf_r+0x19cc>
8000a878:	fa ca f9 78 	sub	r10,sp,-1672
8000a87c:	02 9b       	mov	r11,r1
8000a87e:	08 9c       	mov	r12,r4
8000a880:	fe b0 f3 12 	rcall	80008ea4 <__sprint_r>
8000a884:	e0 81 02 9d 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a888:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a88c:	21 06       	sub	r6,16
8000a88e:	c0 48       	rjmp	8000a896 <_vfprintf_r+0x19d6>
8000a890:	fe c2 b7 c4 	sub	r2,pc,-18492
8000a894:	31 00       	mov	r0,16
8000a896:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a89a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a89e:	fe ca b7 d2 	sub	r10,pc,-18478
8000a8a2:	59 06       	cp.w	r6,16
8000a8a4:	fe 99 ff dd 	brgt	8000a85e <_vfprintf_r+0x199e>
8000a8a8:	0c 09       	add	r9,r6
8000a8aa:	87 0a       	st.w	r3[0x0],r10
8000a8ac:	fb 49 06 90 	st.w	sp[1680],r9
8000a8b0:	2f f8       	sub	r8,-1
8000a8b2:	87 16       	st.w	r3[0x4],r6
8000a8b4:	c5 39       	rjmp	8000ab5a <_vfprintf_r+0x1c9a>
8000a8b6:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a8ba:	58 0a       	cp.w	r10,0
8000a8bc:	e0 89 00 92 	brgt	8000a9e0 <_vfprintf_r+0x1b20>
8000a8c0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a8c4:	fe c9 b8 0c 	sub	r9,pc,-18420
8000a8c8:	2f f8       	sub	r8,-1
8000a8ca:	87 09       	st.w	r3[0x0],r9
8000a8cc:	fb 48 06 90 	st.w	sp[1680],r8
8000a8d0:	30 19       	mov	r9,1
8000a8d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a8d6:	87 19       	st.w	r3[0x4],r9
8000a8d8:	2f f8       	sub	r8,-1
8000a8da:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8de:	58 78       	cp.w	r8,7
8000a8e0:	e0 89 00 04 	brgt	8000a8e8 <_vfprintf_r+0x1a28>
8000a8e4:	2f 83       	sub	r3,-8
8000a8e6:	c0 b8       	rjmp	8000a8fc <_vfprintf_r+0x1a3c>
8000a8e8:	fa ca f9 78 	sub	r10,sp,-1672
8000a8ec:	02 9b       	mov	r11,r1
8000a8ee:	08 9c       	mov	r12,r4
8000a8f0:	fe b0 f2 da 	rcall	80008ea4 <__sprint_r>
8000a8f4:	e0 81 02 65 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a8f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8fc:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a900:	58 08       	cp.w	r8,0
8000a902:	c0 81       	brne	8000a912 <_vfprintf_r+0x1a52>
8000a904:	40 6a       	lddsp	r10,sp[0x18]
8000a906:	58 0a       	cp.w	r10,0
8000a908:	c0 51       	brne	8000a912 <_vfprintf_r+0x1a52>
8000a90a:	ed b5 00 00 	bld	r5,0x0
8000a90e:	e0 81 01 ed 	brne	8000ace8 <_vfprintf_r+0x1e28>
8000a912:	40 c9       	lddsp	r9,sp[0x30]
8000a914:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a918:	2f f8       	sub	r8,-1
8000a91a:	87 09       	st.w	r3[0x0],r9
8000a91c:	fb 48 06 90 	st.w	sp[1680],r8
8000a920:	30 19       	mov	r9,1
8000a922:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a926:	87 19       	st.w	r3[0x4],r9
8000a928:	2f f8       	sub	r8,-1
8000a92a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a92e:	58 78       	cp.w	r8,7
8000a930:	e0 89 00 04 	brgt	8000a938 <_vfprintf_r+0x1a78>
8000a934:	2f 83       	sub	r3,-8
8000a936:	c0 b8       	rjmp	8000a94c <_vfprintf_r+0x1a8c>
8000a938:	fa ca f9 78 	sub	r10,sp,-1672
8000a93c:	02 9b       	mov	r11,r1
8000a93e:	08 9c       	mov	r12,r4
8000a940:	fe b0 f2 b2 	rcall	80008ea4 <__sprint_r>
8000a944:	e0 81 02 3d 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a948:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a94c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a950:	5c 32       	neg	r2
8000a952:	58 02       	cp.w	r2,0
8000a954:	e0 89 00 1d 	brgt	8000a98e <_vfprintf_r+0x1ace>
8000a958:	c3 d8       	rjmp	8000a9d2 <_vfprintf_r+0x1b12>
8000a95a:	2f 09       	sub	r9,-16
8000a95c:	2f f8       	sub	r8,-1
8000a95e:	31 0e       	mov	lr,16
8000a960:	fb 49 06 90 	st.w	sp[1680],r9
8000a964:	87 00       	st.w	r3[0x0],r0
8000a966:	87 1e       	st.w	r3[0x4],lr
8000a968:	fb 48 06 8c 	st.w	sp[1676],r8
8000a96c:	58 78       	cp.w	r8,7
8000a96e:	e0 89 00 04 	brgt	8000a976 <_vfprintf_r+0x1ab6>
8000a972:	2f 83       	sub	r3,-8
8000a974:	c0 b8       	rjmp	8000a98a <_vfprintf_r+0x1aca>
8000a976:	fa ca f9 78 	sub	r10,sp,-1672
8000a97a:	02 9b       	mov	r11,r1
8000a97c:	08 9c       	mov	r12,r4
8000a97e:	fe b0 f2 93 	rcall	80008ea4 <__sprint_r>
8000a982:	e0 81 02 1e 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a986:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a98a:	21 02       	sub	r2,16
8000a98c:	c0 38       	rjmp	8000a992 <_vfprintf_r+0x1ad2>
8000a98e:	fe c0 b8 c2 	sub	r0,pc,-18238
8000a992:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a996:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a99a:	fe ca b8 ce 	sub	r10,pc,-18226
8000a99e:	59 02       	cp.w	r2,16
8000a9a0:	fe 99 ff dd 	brgt	8000a95a <_vfprintf_r+0x1a9a>
8000a9a4:	04 09       	add	r9,r2
8000a9a6:	2f f8       	sub	r8,-1
8000a9a8:	87 0a       	st.w	r3[0x0],r10
8000a9aa:	fb 49 06 90 	st.w	sp[1680],r9
8000a9ae:	87 12       	st.w	r3[0x4],r2
8000a9b0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9b4:	58 78       	cp.w	r8,7
8000a9b6:	e0 89 00 04 	brgt	8000a9be <_vfprintf_r+0x1afe>
8000a9ba:	2f 83       	sub	r3,-8
8000a9bc:	c0 b8       	rjmp	8000a9d2 <_vfprintf_r+0x1b12>
8000a9be:	fa ca f9 78 	sub	r10,sp,-1672
8000a9c2:	02 9b       	mov	r11,r1
8000a9c4:	08 9c       	mov	r12,r4
8000a9c6:	fe b0 f2 6f 	rcall	80008ea4 <__sprint_r>
8000a9ca:	e0 81 01 fa 	brne	8000adbe <_vfprintf_r+0x1efe>
8000a9ce:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9d2:	40 6c       	lddsp	r12,sp[0x18]
8000a9d4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9d8:	87 06       	st.w	r3[0x0],r6
8000a9da:	87 1c       	st.w	r3[0x4],r12
8000a9dc:	18 08       	add	r8,r12
8000a9de:	cb 98       	rjmp	8000ab50 <_vfprintf_r+0x1c90>
8000a9e0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a9e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9e8:	40 6b       	lddsp	r11,sp[0x18]
8000a9ea:	16 3a       	cp.w	r10,r11
8000a9ec:	c6 f5       	brlt	8000aaca <_vfprintf_r+0x1c0a>
8000a9ee:	16 09       	add	r9,r11
8000a9f0:	2f f8       	sub	r8,-1
8000a9f2:	87 06       	st.w	r3[0x0],r6
8000a9f4:	fb 49 06 90 	st.w	sp[1680],r9
8000a9f8:	87 1b       	st.w	r3[0x4],r11
8000a9fa:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9fe:	58 78       	cp.w	r8,7
8000aa00:	e0 89 00 04 	brgt	8000aa08 <_vfprintf_r+0x1b48>
8000aa04:	2f 83       	sub	r3,-8
8000aa06:	c0 b8       	rjmp	8000aa1c <_vfprintf_r+0x1b5c>
8000aa08:	fa ca f9 78 	sub	r10,sp,-1672
8000aa0c:	02 9b       	mov	r11,r1
8000aa0e:	08 9c       	mov	r12,r4
8000aa10:	fe b0 f2 4a 	rcall	80008ea4 <__sprint_r>
8000aa14:	e0 81 01 d5 	brne	8000adbe <_vfprintf_r+0x1efe>
8000aa18:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa1c:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000aa20:	40 6a       	lddsp	r10,sp[0x18]
8000aa22:	14 16       	sub	r6,r10
8000aa24:	58 06       	cp.w	r6,0
8000aa26:	e0 89 00 1c 	brgt	8000aa5e <_vfprintf_r+0x1b9e>
8000aa2a:	c3 d8       	rjmp	8000aaa4 <_vfprintf_r+0x1be4>
8000aa2c:	2f 09       	sub	r9,-16
8000aa2e:	2f f8       	sub	r8,-1
8000aa30:	fb 49 06 90 	st.w	sp[1680],r9
8000aa34:	87 02       	st.w	r3[0x0],r2
8000aa36:	87 10       	st.w	r3[0x4],r0
8000aa38:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa3c:	58 78       	cp.w	r8,7
8000aa3e:	e0 89 00 04 	brgt	8000aa46 <_vfprintf_r+0x1b86>
8000aa42:	2f 83       	sub	r3,-8
8000aa44:	c0 b8       	rjmp	8000aa5a <_vfprintf_r+0x1b9a>
8000aa46:	fa ca f9 78 	sub	r10,sp,-1672
8000aa4a:	02 9b       	mov	r11,r1
8000aa4c:	08 9c       	mov	r12,r4
8000aa4e:	fe b0 f2 2b 	rcall	80008ea4 <__sprint_r>
8000aa52:	e0 81 01 b6 	brne	8000adbe <_vfprintf_r+0x1efe>
8000aa56:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa5a:	21 06       	sub	r6,16
8000aa5c:	c0 48       	rjmp	8000aa64 <_vfprintf_r+0x1ba4>
8000aa5e:	fe c2 b9 92 	sub	r2,pc,-18030
8000aa62:	31 00       	mov	r0,16
8000aa64:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa6c:	fe ca b9 a0 	sub	r10,pc,-18016
8000aa70:	59 06       	cp.w	r6,16
8000aa72:	fe 99 ff dd 	brgt	8000aa2c <_vfprintf_r+0x1b6c>
8000aa76:	0c 09       	add	r9,r6
8000aa78:	2f f8       	sub	r8,-1
8000aa7a:	87 0a       	st.w	r3[0x0],r10
8000aa7c:	fb 49 06 90 	st.w	sp[1680],r9
8000aa80:	87 16       	st.w	r3[0x4],r6
8000aa82:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa86:	58 78       	cp.w	r8,7
8000aa88:	e0 89 00 04 	brgt	8000aa90 <_vfprintf_r+0x1bd0>
8000aa8c:	2f 83       	sub	r3,-8
8000aa8e:	c0 b8       	rjmp	8000aaa4 <_vfprintf_r+0x1be4>
8000aa90:	fa ca f9 78 	sub	r10,sp,-1672
8000aa94:	02 9b       	mov	r11,r1
8000aa96:	08 9c       	mov	r12,r4
8000aa98:	fe b0 f2 06 	rcall	80008ea4 <__sprint_r>
8000aa9c:	e0 81 01 91 	brne	8000adbe <_vfprintf_r+0x1efe>
8000aaa0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aaa4:	ed b5 00 00 	bld	r5,0x0
8000aaa8:	e0 81 01 20 	brne	8000ace8 <_vfprintf_r+0x1e28>
8000aaac:	40 c9       	lddsp	r9,sp[0x30]
8000aaae:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aab2:	2f f8       	sub	r8,-1
8000aab4:	87 09       	st.w	r3[0x0],r9
8000aab6:	fb 48 06 90 	st.w	sp[1680],r8
8000aaba:	30 19       	mov	r9,1
8000aabc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aac0:	87 19       	st.w	r3[0x4],r9
8000aac2:	2f f8       	sub	r8,-1
8000aac4:	fb 48 06 8c 	st.w	sp[1676],r8
8000aac8:	c0 29       	rjmp	8000accc <_vfprintf_r+0x1e0c>
8000aaca:	14 09       	add	r9,r10
8000aacc:	2f f8       	sub	r8,-1
8000aace:	fb 49 06 90 	st.w	sp[1680],r9
8000aad2:	87 06       	st.w	r3[0x0],r6
8000aad4:	87 1a       	st.w	r3[0x4],r10
8000aad6:	fb 48 06 8c 	st.w	sp[1676],r8
8000aada:	58 78       	cp.w	r8,7
8000aadc:	e0 89 00 04 	brgt	8000aae4 <_vfprintf_r+0x1c24>
8000aae0:	2f 83       	sub	r3,-8
8000aae2:	c0 b8       	rjmp	8000aaf8 <_vfprintf_r+0x1c38>
8000aae4:	fa ca f9 78 	sub	r10,sp,-1672
8000aae8:	02 9b       	mov	r11,r1
8000aaea:	08 9c       	mov	r12,r4
8000aaec:	fe b0 f1 dc 	rcall	80008ea4 <__sprint_r>
8000aaf0:	e0 81 01 67 	brne	8000adbe <_vfprintf_r+0x1efe>
8000aaf4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aaf8:	40 c8       	lddsp	r8,sp[0x30]
8000aafa:	87 08       	st.w	r3[0x0],r8
8000aafc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab00:	2f f8       	sub	r8,-1
8000ab02:	30 19       	mov	r9,1
8000ab04:	fb 48 06 90 	st.w	sp[1680],r8
8000ab08:	87 19       	st.w	r3[0x4],r9
8000ab0a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab0e:	2f f8       	sub	r8,-1
8000ab10:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab14:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab18:	58 78       	cp.w	r8,7
8000ab1a:	e0 89 00 04 	brgt	8000ab22 <_vfprintf_r+0x1c62>
8000ab1e:	2f 83       	sub	r3,-8
8000ab20:	c0 b8       	rjmp	8000ab36 <_vfprintf_r+0x1c76>
8000ab22:	fa ca f9 78 	sub	r10,sp,-1672
8000ab26:	02 9b       	mov	r11,r1
8000ab28:	08 9c       	mov	r12,r4
8000ab2a:	fe b0 f1 bd 	rcall	80008ea4 <__sprint_r>
8000ab2e:	e0 81 01 48 	brne	8000adbe <_vfprintf_r+0x1efe>
8000ab32:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab36:	04 06       	add	r6,r2
8000ab38:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ab3c:	87 06       	st.w	r3[0x0],r6
8000ab3e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab42:	40 66       	lddsp	r6,sp[0x18]
8000ab44:	40 6e       	lddsp	lr,sp[0x18]
8000ab46:	10 16       	sub	r6,r8
8000ab48:	f2 08 01 08 	sub	r8,r9,r8
8000ab4c:	87 16       	st.w	r3[0x4],r6
8000ab4e:	1c 08       	add	r8,lr
8000ab50:	fb 48 06 90 	st.w	sp[1680],r8
8000ab54:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab58:	2f f8       	sub	r8,-1
8000ab5a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab5e:	cb 78       	rjmp	8000accc <_vfprintf_r+0x1e0c>
8000ab60:	40 6c       	lddsp	r12,sp[0x18]
8000ab62:	58 1c       	cp.w	r12,1
8000ab64:	e0 89 00 06 	brgt	8000ab70 <_vfprintf_r+0x1cb0>
8000ab68:	ed b5 00 00 	bld	r5,0x0
8000ab6c:	e0 81 00 85 	brne	8000ac76 <_vfprintf_r+0x1db6>
8000ab70:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab74:	2f f8       	sub	r8,-1
8000ab76:	30 19       	mov	r9,1
8000ab78:	fb 48 06 90 	st.w	sp[1680],r8
8000ab7c:	87 06       	st.w	r3[0x0],r6
8000ab7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab82:	87 19       	st.w	r3[0x4],r9
8000ab84:	2f f8       	sub	r8,-1
8000ab86:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab8a:	58 78       	cp.w	r8,7
8000ab8c:	e0 89 00 04 	brgt	8000ab94 <_vfprintf_r+0x1cd4>
8000ab90:	2f 83       	sub	r3,-8
8000ab92:	c0 b8       	rjmp	8000aba8 <_vfprintf_r+0x1ce8>
8000ab94:	fa ca f9 78 	sub	r10,sp,-1672
8000ab98:	02 9b       	mov	r11,r1
8000ab9a:	08 9c       	mov	r12,r4
8000ab9c:	fe b0 f1 84 	rcall	80008ea4 <__sprint_r>
8000aba0:	e0 81 01 0f 	brne	8000adbe <_vfprintf_r+0x1efe>
8000aba4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aba8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000abac:	2f f8       	sub	r8,-1
8000abae:	40 cb       	lddsp	r11,sp[0x30]
8000abb0:	fb 48 06 90 	st.w	sp[1680],r8
8000abb4:	30 19       	mov	r9,1
8000abb6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abba:	87 0b       	st.w	r3[0x0],r11
8000abbc:	2f f8       	sub	r8,-1
8000abbe:	87 19       	st.w	r3[0x4],r9
8000abc0:	fb 48 06 8c 	st.w	sp[1676],r8
8000abc4:	58 78       	cp.w	r8,7
8000abc6:	e0 89 00 05 	brgt	8000abd0 <_vfprintf_r+0x1d10>
8000abca:	2f 83       	sub	r3,-8
8000abcc:	c0 c8       	rjmp	8000abe4 <_vfprintf_r+0x1d24>
8000abce:	d7 03       	nop
8000abd0:	fa ca f9 78 	sub	r10,sp,-1672
8000abd4:	02 9b       	mov	r11,r1
8000abd6:	08 9c       	mov	r12,r4
8000abd8:	fe b0 f1 66 	rcall	80008ea4 <__sprint_r>
8000abdc:	e0 81 00 f1 	brne	8000adbe <_vfprintf_r+0x1efe>
8000abe0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abe4:	30 08       	mov	r8,0
8000abe6:	30 09       	mov	r9,0
8000abe8:	40 5b       	lddsp	r11,sp[0x14]
8000abea:	40 7a       	lddsp	r10,sp[0x1c]
8000abec:	e0 a0 13 25 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000abf0:	40 68       	lddsp	r8,sp[0x18]
8000abf2:	20 18       	sub	r8,1
8000abf4:	58 0c       	cp.w	r12,0
8000abf6:	c0 d1       	brne	8000ac10 <_vfprintf_r+0x1d50>
8000abf8:	2f f6       	sub	r6,-1
8000abfa:	87 18       	st.w	r3[0x4],r8
8000abfc:	87 06       	st.w	r3[0x0],r6
8000abfe:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ac02:	10 06       	add	r6,r8
8000ac04:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac08:	fb 46 06 90 	st.w	sp[1680],r6
8000ac0c:	2f f8       	sub	r8,-1
8000ac0e:	c3 18       	rjmp	8000ac70 <_vfprintf_r+0x1db0>
8000ac10:	10 96       	mov	r6,r8
8000ac12:	58 08       	cp.w	r8,0
8000ac14:	e0 89 00 1c 	brgt	8000ac4c <_vfprintf_r+0x1d8c>
8000ac18:	c4 b8       	rjmp	8000acae <_vfprintf_r+0x1dee>
8000ac1a:	2f 09       	sub	r9,-16
8000ac1c:	2f f8       	sub	r8,-1
8000ac1e:	fb 49 06 90 	st.w	sp[1680],r9
8000ac22:	87 02       	st.w	r3[0x0],r2
8000ac24:	87 10       	st.w	r3[0x4],r0
8000ac26:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac2a:	58 78       	cp.w	r8,7
8000ac2c:	e0 89 00 04 	brgt	8000ac34 <_vfprintf_r+0x1d74>
8000ac30:	2f 83       	sub	r3,-8
8000ac32:	c0 b8       	rjmp	8000ac48 <_vfprintf_r+0x1d88>
8000ac34:	fa ca f9 78 	sub	r10,sp,-1672
8000ac38:	02 9b       	mov	r11,r1
8000ac3a:	08 9c       	mov	r12,r4
8000ac3c:	fe b0 f1 34 	rcall	80008ea4 <__sprint_r>
8000ac40:	e0 81 00 bf 	brne	8000adbe <_vfprintf_r+0x1efe>
8000ac44:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac48:	21 06       	sub	r6,16
8000ac4a:	c0 48       	rjmp	8000ac52 <_vfprintf_r+0x1d92>
8000ac4c:	fe c2 bb 80 	sub	r2,pc,-17536
8000ac50:	31 00       	mov	r0,16
8000ac52:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ac56:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac5a:	fe ca bb 8e 	sub	r10,pc,-17522
8000ac5e:	59 06       	cp.w	r6,16
8000ac60:	fe 99 ff dd 	brgt	8000ac1a <_vfprintf_r+0x1d5a>
8000ac64:	0c 09       	add	r9,r6
8000ac66:	87 0a       	st.w	r3[0x0],r10
8000ac68:	fb 49 06 90 	st.w	sp[1680],r9
8000ac6c:	2f f8       	sub	r8,-1
8000ac6e:	87 16       	st.w	r3[0x4],r6
8000ac70:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac74:	c0 e8       	rjmp	8000ac90 <_vfprintf_r+0x1dd0>
8000ac76:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac7a:	2f f8       	sub	r8,-1
8000ac7c:	30 19       	mov	r9,1
8000ac7e:	fb 48 06 90 	st.w	sp[1680],r8
8000ac82:	87 06       	st.w	r3[0x0],r6
8000ac84:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac88:	87 19       	st.w	r3[0x4],r9
8000ac8a:	2f f8       	sub	r8,-1
8000ac8c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac90:	58 78       	cp.w	r8,7
8000ac92:	e0 89 00 04 	brgt	8000ac9a <_vfprintf_r+0x1dda>
8000ac96:	2f 83       	sub	r3,-8
8000ac98:	c0 b8       	rjmp	8000acae <_vfprintf_r+0x1dee>
8000ac9a:	fa ca f9 78 	sub	r10,sp,-1672
8000ac9e:	02 9b       	mov	r11,r1
8000aca0:	08 9c       	mov	r12,r4
8000aca2:	fe b0 f1 01 	rcall	80008ea4 <__sprint_r>
8000aca6:	e0 81 00 8c 	brne	8000adbe <_vfprintf_r+0x1efe>
8000acaa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000acae:	40 ea       	lddsp	r10,sp[0x38]
8000acb0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000acb4:	14 08       	add	r8,r10
8000acb6:	fa c9 f9 64 	sub	r9,sp,-1692
8000acba:	fb 48 06 90 	st.w	sp[1680],r8
8000acbe:	87 1a       	st.w	r3[0x4],r10
8000acc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acc4:	87 09       	st.w	r3[0x0],r9
8000acc6:	2f f8       	sub	r8,-1
8000acc8:	fb 48 06 8c 	st.w	sp[1676],r8
8000accc:	58 78       	cp.w	r8,7
8000acce:	e0 89 00 04 	brgt	8000acd6 <_vfprintf_r+0x1e16>
8000acd2:	2f 83       	sub	r3,-8
8000acd4:	c0 a8       	rjmp	8000ace8 <_vfprintf_r+0x1e28>
8000acd6:	fa ca f9 78 	sub	r10,sp,-1672
8000acda:	02 9b       	mov	r11,r1
8000acdc:	08 9c       	mov	r12,r4
8000acde:	fe b0 f0 e3 	rcall	80008ea4 <__sprint_r>
8000ace2:	c6 e1       	brne	8000adbe <_vfprintf_r+0x1efe>
8000ace4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ace8:	e2 15 00 04 	andl	r5,0x4,COH
8000acec:	c3 f0       	breq	8000ad6a <_vfprintf_r+0x1eaa>
8000acee:	40 86       	lddsp	r6,sp[0x20]
8000acf0:	40 39       	lddsp	r9,sp[0xc]
8000acf2:	12 16       	sub	r6,r9
8000acf4:	58 06       	cp.w	r6,0
8000acf6:	e0 89 00 1a 	brgt	8000ad2a <_vfprintf_r+0x1e6a>
8000acfa:	c3 88       	rjmp	8000ad6a <_vfprintf_r+0x1eaa>
8000acfc:	2f 09       	sub	r9,-16
8000acfe:	2f f8       	sub	r8,-1
8000ad00:	fb 49 06 90 	st.w	sp[1680],r9
8000ad04:	87 05       	st.w	r3[0x0],r5
8000ad06:	87 12       	st.w	r3[0x4],r2
8000ad08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad0c:	58 78       	cp.w	r8,7
8000ad0e:	e0 89 00 04 	brgt	8000ad16 <_vfprintf_r+0x1e56>
8000ad12:	2f 83       	sub	r3,-8
8000ad14:	c0 98       	rjmp	8000ad26 <_vfprintf_r+0x1e66>
8000ad16:	00 9a       	mov	r10,r0
8000ad18:	02 9b       	mov	r11,r1
8000ad1a:	08 9c       	mov	r12,r4
8000ad1c:	fe b0 f0 c4 	rcall	80008ea4 <__sprint_r>
8000ad20:	c4 f1       	brne	8000adbe <_vfprintf_r+0x1efe>
8000ad22:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad26:	21 06       	sub	r6,16
8000ad28:	c0 68       	rjmp	8000ad34 <_vfprintf_r+0x1e74>
8000ad2a:	fe c5 bc 6e 	sub	r5,pc,-17298
8000ad2e:	31 02       	mov	r2,16
8000ad30:	fa c0 f9 78 	sub	r0,sp,-1672
8000ad34:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad3c:	fe ca bc 80 	sub	r10,pc,-17280
8000ad40:	59 06       	cp.w	r6,16
8000ad42:	fe 99 ff dd 	brgt	8000acfc <_vfprintf_r+0x1e3c>
8000ad46:	0c 09       	add	r9,r6
8000ad48:	2f f8       	sub	r8,-1
8000ad4a:	87 0a       	st.w	r3[0x0],r10
8000ad4c:	87 16       	st.w	r3[0x4],r6
8000ad4e:	fb 49 06 90 	st.w	sp[1680],r9
8000ad52:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad56:	58 78       	cp.w	r8,7
8000ad58:	e0 8a 00 09 	brle	8000ad6a <_vfprintf_r+0x1eaa>
8000ad5c:	fa ca f9 78 	sub	r10,sp,-1672
8000ad60:	02 9b       	mov	r11,r1
8000ad62:	08 9c       	mov	r12,r4
8000ad64:	fe b0 f0 a0 	rcall	80008ea4 <__sprint_r>
8000ad68:	c2 b1       	brne	8000adbe <_vfprintf_r+0x1efe>
8000ad6a:	40 bc       	lddsp	r12,sp[0x2c]
8000ad6c:	40 36       	lddsp	r6,sp[0xc]
8000ad6e:	40 8e       	lddsp	lr,sp[0x20]
8000ad70:	ec 0e 0c 48 	max	r8,r6,lr
8000ad74:	10 0c       	add	r12,r8
8000ad76:	50 bc       	stdsp	sp[0x2c],r12
8000ad78:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad7c:	58 08       	cp.w	r8,0
8000ad7e:	c0 80       	breq	8000ad8e <_vfprintf_r+0x1ece>
8000ad80:	fa ca f9 78 	sub	r10,sp,-1672
8000ad84:	02 9b       	mov	r11,r1
8000ad86:	08 9c       	mov	r12,r4
8000ad88:	fe b0 f0 8e 	rcall	80008ea4 <__sprint_r>
8000ad8c:	c1 91       	brne	8000adbe <_vfprintf_r+0x1efe>
8000ad8e:	30 0b       	mov	r11,0
8000ad90:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad94:	fb 4b 06 8c 	st.w	sp[1676],r11
8000ad98:	fe 9f f1 22 	bral	80008fdc <_vfprintf_r+0x11c>
8000ad9c:	08 95       	mov	r5,r4
8000ad9e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ada2:	58 08       	cp.w	r8,0
8000ada4:	c0 80       	breq	8000adb4 <_vfprintf_r+0x1ef4>
8000ada6:	08 9c       	mov	r12,r4
8000ada8:	fa ca f9 78 	sub	r10,sp,-1672
8000adac:	02 9b       	mov	r11,r1
8000adae:	fe b0 f0 7b 	rcall	80008ea4 <__sprint_r>
8000adb2:	c0 61       	brne	8000adbe <_vfprintf_r+0x1efe>
8000adb4:	30 08       	mov	r8,0
8000adb6:	fb 48 06 8c 	st.w	sp[1676],r8
8000adba:	c0 28       	rjmp	8000adbe <_vfprintf_r+0x1efe>
8000adbc:	40 41       	lddsp	r1,sp[0x10]
8000adbe:	82 68       	ld.sh	r8,r1[0xc]
8000adc0:	ed b8 00 06 	bld	r8,0x6
8000adc4:	c0 31       	brne	8000adca <_vfprintf_r+0x1f0a>
8000adc6:	3f fa       	mov	r10,-1
8000adc8:	50 ba       	stdsp	sp[0x2c],r10
8000adca:	40 bc       	lddsp	r12,sp[0x2c]
8000adcc:	fe 3d f9 44 	sub	sp,-1724
8000add0:	d8 32       	popm	r0-r7,pc
8000add2:	d7 03       	nop

8000add4 <__swsetup_r>:
8000add4:	d4 21       	pushm	r4-r7,lr
8000add6:	e0 68 0a 50 	mov	r8,2640
8000adda:	18 96       	mov	r6,r12
8000addc:	16 97       	mov	r7,r11
8000adde:	70 0c       	ld.w	r12,r8[0x0]
8000ade0:	58 0c       	cp.w	r12,0
8000ade2:	c0 60       	breq	8000adee <__swsetup_r+0x1a>
8000ade4:	78 68       	ld.w	r8,r12[0x18]
8000ade6:	58 08       	cp.w	r8,0
8000ade8:	c0 31       	brne	8000adee <__swsetup_r+0x1a>
8000adea:	e0 a0 07 bf 	rcall	8000bd68 <__sinit>
8000adee:	fe c8 bc 02 	sub	r8,pc,-17406
8000adf2:	10 37       	cp.w	r7,r8
8000adf4:	c0 61       	brne	8000ae00 <__swsetup_r+0x2c>
8000adf6:	e0 68 0a 50 	mov	r8,2640
8000adfa:	70 08       	ld.w	r8,r8[0x0]
8000adfc:	70 07       	ld.w	r7,r8[0x0]
8000adfe:	c1 28       	rjmp	8000ae22 <__swsetup_r+0x4e>
8000ae00:	fe c8 bb f4 	sub	r8,pc,-17420
8000ae04:	10 37       	cp.w	r7,r8
8000ae06:	c0 61       	brne	8000ae12 <__swsetup_r+0x3e>
8000ae08:	e0 68 0a 50 	mov	r8,2640
8000ae0c:	70 08       	ld.w	r8,r8[0x0]
8000ae0e:	70 17       	ld.w	r7,r8[0x4]
8000ae10:	c0 98       	rjmp	8000ae22 <__swsetup_r+0x4e>
8000ae12:	fe c8 bb e6 	sub	r8,pc,-17434
8000ae16:	10 37       	cp.w	r7,r8
8000ae18:	c0 51       	brne	8000ae22 <__swsetup_r+0x4e>
8000ae1a:	e0 68 0a 50 	mov	r8,2640
8000ae1e:	70 08       	ld.w	r8,r8[0x0]
8000ae20:	70 27       	ld.w	r7,r8[0x8]
8000ae22:	8e 68       	ld.sh	r8,r7[0xc]
8000ae24:	ed b8 00 03 	bld	r8,0x3
8000ae28:	c1 e0       	breq	8000ae64 <__swsetup_r+0x90>
8000ae2a:	ed b8 00 04 	bld	r8,0x4
8000ae2e:	c3 e1       	brne	8000aeaa <__swsetup_r+0xd6>
8000ae30:	ed b8 00 02 	bld	r8,0x2
8000ae34:	c1 51       	brne	8000ae5e <__swsetup_r+0x8a>
8000ae36:	6e db       	ld.w	r11,r7[0x34]
8000ae38:	58 0b       	cp.w	r11,0
8000ae3a:	c0 a0       	breq	8000ae4e <__swsetup_r+0x7a>
8000ae3c:	ee c8 ff bc 	sub	r8,r7,-68
8000ae40:	10 3b       	cp.w	r11,r8
8000ae42:	c0 40       	breq	8000ae4a <__swsetup_r+0x76>
8000ae44:	0c 9c       	mov	r12,r6
8000ae46:	e0 a0 08 2b 	rcall	8000be9c <_free_r>
8000ae4a:	30 08       	mov	r8,0
8000ae4c:	8f d8       	st.w	r7[0x34],r8
8000ae4e:	8e 68       	ld.sh	r8,r7[0xc]
8000ae50:	e0 18 ff db 	andl	r8,0xffdb
8000ae54:	ae 68       	st.h	r7[0xc],r8
8000ae56:	30 08       	mov	r8,0
8000ae58:	8f 18       	st.w	r7[0x4],r8
8000ae5a:	6e 48       	ld.w	r8,r7[0x10]
8000ae5c:	8f 08       	st.w	r7[0x0],r8
8000ae5e:	8e 68       	ld.sh	r8,r7[0xc]
8000ae60:	a3 b8       	sbr	r8,0x3
8000ae62:	ae 68       	st.h	r7[0xc],r8
8000ae64:	6e 48       	ld.w	r8,r7[0x10]
8000ae66:	58 08       	cp.w	r8,0
8000ae68:	c0 b1       	brne	8000ae7e <__swsetup_r+0xaa>
8000ae6a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae6c:	e2 18 02 80 	andl	r8,0x280,COH
8000ae70:	e0 48 02 00 	cp.w	r8,512
8000ae74:	c0 50       	breq	8000ae7e <__swsetup_r+0xaa>
8000ae76:	0c 9c       	mov	r12,r6
8000ae78:	0e 9b       	mov	r11,r7
8000ae7a:	e0 a0 0a 4b 	rcall	8000c310 <__smakebuf_r>
8000ae7e:	8e 69       	ld.sh	r9,r7[0xc]
8000ae80:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000ae84:	c0 70       	breq	8000ae92 <__swsetup_r+0xbe>
8000ae86:	30 08       	mov	r8,0
8000ae88:	8f 28       	st.w	r7[0x8],r8
8000ae8a:	6e 58       	ld.w	r8,r7[0x14]
8000ae8c:	5c 38       	neg	r8
8000ae8e:	8f 68       	st.w	r7[0x18],r8
8000ae90:	c0 68       	rjmp	8000ae9c <__swsetup_r+0xc8>
8000ae92:	ed b9 00 01 	bld	r9,0x1
8000ae96:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000ae9a:	8f 28       	st.w	r7[0x8],r8
8000ae9c:	6e 48       	ld.w	r8,r7[0x10]
8000ae9e:	58 08       	cp.w	r8,0
8000aea0:	c0 61       	brne	8000aeac <__swsetup_r+0xd8>
8000aea2:	8e 68       	ld.sh	r8,r7[0xc]
8000aea4:	ed b8 00 07 	bld	r8,0x7
8000aea8:	c0 21       	brne	8000aeac <__swsetup_r+0xd8>
8000aeaa:	dc 2a       	popm	r4-r7,pc,r12=-1
8000aeac:	d8 2a       	popm	r4-r7,pc,r12=0
8000aeae:	d7 03       	nop

8000aeb0 <quorem>:
8000aeb0:	d4 31       	pushm	r0-r7,lr
8000aeb2:	20 2d       	sub	sp,8
8000aeb4:	18 97       	mov	r7,r12
8000aeb6:	78 48       	ld.w	r8,r12[0x10]
8000aeb8:	76 46       	ld.w	r6,r11[0x10]
8000aeba:	0c 38       	cp.w	r8,r6
8000aebc:	c0 34       	brge	8000aec2 <quorem+0x12>
8000aebe:	30 0c       	mov	r12,0
8000aec0:	c8 58       	rjmp	8000afca <quorem+0x11a>
8000aec2:	ec c2 ff fc 	sub	r2,r6,-4
8000aec6:	f6 c3 ff ec 	sub	r3,r11,-20
8000aeca:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000aece:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000aed2:	2f f9       	sub	r9,-1
8000aed4:	20 16       	sub	r6,1
8000aed6:	f8 09 0d 08 	divu	r8,r12,r9
8000aeda:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000aede:	ee c4 ff ec 	sub	r4,r7,-20
8000aee2:	10 95       	mov	r5,r8
8000aee4:	58 08       	cp.w	r8,0
8000aee6:	c4 10       	breq	8000af68 <quorem+0xb8>
8000aee8:	30 09       	mov	r9,0
8000aeea:	06 9a       	mov	r10,r3
8000aeec:	08 98       	mov	r8,r4
8000aeee:	12 91       	mov	r1,r9
8000aef0:	50 0b       	stdsp	sp[0x0],r11
8000aef2:	70 0e       	ld.w	lr,r8[0x0]
8000aef4:	b1 8e       	lsr	lr,0x10
8000aef6:	50 1e       	stdsp	sp[0x4],lr
8000aef8:	15 0e       	ld.w	lr,r10++
8000aefa:	fc 00 16 10 	lsr	r0,lr,0x10
8000aefe:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000af02:	ea 0e 03 41 	mac	r1,r5,lr
8000af06:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000af0a:	b1 81       	lsr	r1,0x10
8000af0c:	40 1b       	lddsp	r11,sp[0x4]
8000af0e:	ea 00 02 40 	mul	r0,r5,r0
8000af12:	e2 00 00 00 	add	r0,r1,r0
8000af16:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000af1a:	02 1b       	sub	r11,r1
8000af1c:	50 1b       	stdsp	sp[0x4],r11
8000af1e:	70 0b       	ld.w	r11,r8[0x0]
8000af20:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000af24:	02 09       	add	r9,r1
8000af26:	f2 0e 01 0e 	sub	lr,r9,lr
8000af2a:	b0 1e       	st.h	r8[0x2],lr
8000af2c:	fc 09 14 10 	asr	r9,lr,0x10
8000af30:	40 1e       	lddsp	lr,sp[0x4]
8000af32:	fc 09 00 09 	add	r9,lr,r9
8000af36:	b0 09       	st.h	r8[0x0],r9
8000af38:	e0 01 16 10 	lsr	r1,r0,0x10
8000af3c:	2f c8       	sub	r8,-4
8000af3e:	b1 49       	asr	r9,0x10
8000af40:	04 3a       	cp.w	r10,r2
8000af42:	fe 98 ff d8 	brls	8000aef2 <quorem+0x42>
8000af46:	40 0b       	lddsp	r11,sp[0x0]
8000af48:	58 0c       	cp.w	r12,0
8000af4a:	c0 f1       	brne	8000af68 <quorem+0xb8>
8000af4c:	ec c8 ff fb 	sub	r8,r6,-5
8000af50:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000af54:	c0 28       	rjmp	8000af58 <quorem+0xa8>
8000af56:	20 16       	sub	r6,1
8000af58:	20 48       	sub	r8,4
8000af5a:	08 38       	cp.w	r8,r4
8000af5c:	e0 88 00 05 	brls	8000af66 <quorem+0xb6>
8000af60:	70 09       	ld.w	r9,r8[0x0]
8000af62:	58 09       	cp.w	r9,0
8000af64:	cf 90       	breq	8000af56 <quorem+0xa6>
8000af66:	8f 46       	st.w	r7[0x10],r6
8000af68:	0e 9c       	mov	r12,r7
8000af6a:	e0 a0 0a d2 	rcall	8000c50e <__mcmp>
8000af6e:	c2 d5       	brlt	8000afc8 <quorem+0x118>
8000af70:	2f f5       	sub	r5,-1
8000af72:	08 98       	mov	r8,r4
8000af74:	30 09       	mov	r9,0
8000af76:	07 0b       	ld.w	r11,r3++
8000af78:	f6 0a 16 10 	lsr	r10,r11,0x10
8000af7c:	70 0c       	ld.w	r12,r8[0x0]
8000af7e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000af82:	f8 0e 16 10 	lsr	lr,r12,0x10
8000af86:	14 1e       	sub	lr,r10
8000af88:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000af8c:	16 1a       	sub	r10,r11
8000af8e:	12 0a       	add	r10,r9
8000af90:	b0 1a       	st.h	r8[0x2],r10
8000af92:	b1 4a       	asr	r10,0x10
8000af94:	fc 0a 00 09 	add	r9,lr,r10
8000af98:	b0 09       	st.h	r8[0x0],r9
8000af9a:	2f c8       	sub	r8,-4
8000af9c:	b1 49       	asr	r9,0x10
8000af9e:	04 33       	cp.w	r3,r2
8000afa0:	fe 98 ff eb 	brls	8000af76 <quorem+0xc6>
8000afa4:	ec c8 ff fb 	sub	r8,r6,-5
8000afa8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000afac:	58 09       	cp.w	r9,0
8000afae:	c0 d1       	brne	8000afc8 <quorem+0x118>
8000afb0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000afb4:	c0 28       	rjmp	8000afb8 <quorem+0x108>
8000afb6:	20 16       	sub	r6,1
8000afb8:	20 48       	sub	r8,4
8000afba:	08 38       	cp.w	r8,r4
8000afbc:	e0 88 00 05 	brls	8000afc6 <quorem+0x116>
8000afc0:	70 09       	ld.w	r9,r8[0x0]
8000afc2:	58 09       	cp.w	r9,0
8000afc4:	cf 90       	breq	8000afb6 <quorem+0x106>
8000afc6:	8f 46       	st.w	r7[0x10],r6
8000afc8:	0a 9c       	mov	r12,r5
8000afca:	2f ed       	sub	sp,-8
8000afcc:	d8 32       	popm	r0-r7,pc
8000afce:	d7 03       	nop

8000afd0 <_dtoa_r>:
8000afd0:	d4 31       	pushm	r0-r7,lr
8000afd2:	21 ad       	sub	sp,104
8000afd4:	fa c4 ff 74 	sub	r4,sp,-140
8000afd8:	18 97       	mov	r7,r12
8000afda:	16 95       	mov	r5,r11
8000afdc:	68 2c       	ld.w	r12,r4[0x8]
8000afde:	50 c9       	stdsp	sp[0x30],r9
8000afe0:	68 16       	ld.w	r6,r4[0x4]
8000afe2:	68 09       	ld.w	r9,r4[0x0]
8000afe4:	50 e8       	stdsp	sp[0x38],r8
8000afe6:	14 94       	mov	r4,r10
8000afe8:	51 2c       	stdsp	sp[0x48],r12
8000afea:	fa e5 00 08 	st.d	sp[8],r4
8000afee:	51 59       	stdsp	sp[0x54],r9
8000aff0:	6e 95       	ld.w	r5,r7[0x24]
8000aff2:	58 05       	cp.w	r5,0
8000aff4:	c0 91       	brne	8000b006 <_dtoa_r+0x36>
8000aff6:	31 0c       	mov	r12,16
8000aff8:	fe b0 e8 e2 	rcall	800081bc <malloc>
8000affc:	99 35       	st.w	r12[0xc],r5
8000affe:	8f 9c       	st.w	r7[0x24],r12
8000b000:	99 15       	st.w	r12[0x4],r5
8000b002:	99 25       	st.w	r12[0x8],r5
8000b004:	99 05       	st.w	r12[0x0],r5
8000b006:	6e 99       	ld.w	r9,r7[0x24]
8000b008:	72 08       	ld.w	r8,r9[0x0]
8000b00a:	58 08       	cp.w	r8,0
8000b00c:	c0 f0       	breq	8000b02a <_dtoa_r+0x5a>
8000b00e:	72 1a       	ld.w	r10,r9[0x4]
8000b010:	91 1a       	st.w	r8[0x4],r10
8000b012:	30 1a       	mov	r10,1
8000b014:	72 19       	ld.w	r9,r9[0x4]
8000b016:	f4 09 09 49 	lsl	r9,r10,r9
8000b01a:	10 9b       	mov	r11,r8
8000b01c:	91 29       	st.w	r8[0x8],r9
8000b01e:	0e 9c       	mov	r12,r7
8000b020:	e0 a0 0a 90 	rcall	8000c540 <_Bfree>
8000b024:	6e 98       	ld.w	r8,r7[0x24]
8000b026:	30 09       	mov	r9,0
8000b028:	91 09       	st.w	r8[0x0],r9
8000b02a:	40 28       	lddsp	r8,sp[0x8]
8000b02c:	10 94       	mov	r4,r8
8000b02e:	58 08       	cp.w	r8,0
8000b030:	c0 64       	brge	8000b03c <_dtoa_r+0x6c>
8000b032:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b036:	50 28       	stdsp	sp[0x8],r8
8000b038:	30 18       	mov	r8,1
8000b03a:	c0 28       	rjmp	8000b03e <_dtoa_r+0x6e>
8000b03c:	30 08       	mov	r8,0
8000b03e:	8d 08       	st.w	r6[0x0],r8
8000b040:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b044:	40 26       	lddsp	r6,sp[0x8]
8000b046:	0c 98       	mov	r8,r6
8000b048:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b04c:	18 38       	cp.w	r8,r12
8000b04e:	c2 01       	brne	8000b08e <_dtoa_r+0xbe>
8000b050:	e0 68 27 0f 	mov	r8,9999
8000b054:	41 5b       	lddsp	r11,sp[0x54]
8000b056:	97 08       	st.w	r11[0x0],r8
8000b058:	40 3a       	lddsp	r10,sp[0xc]
8000b05a:	58 0a       	cp.w	r10,0
8000b05c:	c0 71       	brne	8000b06a <_dtoa_r+0x9a>
8000b05e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b062:	c0 41       	brne	8000b06a <_dtoa_r+0x9a>
8000b064:	fe cc be 88 	sub	r12,pc,-16760
8000b068:	c0 38       	rjmp	8000b06e <_dtoa_r+0x9e>
8000b06a:	fe cc be 82 	sub	r12,pc,-16766
8000b06e:	41 29       	lddsp	r9,sp[0x48]
8000b070:	58 09       	cp.w	r9,0
8000b072:	e0 80 05 9a 	breq	8000bba6 <_dtoa_r+0xbd6>
8000b076:	f8 c8 ff fd 	sub	r8,r12,-3
8000b07a:	f8 c9 ff f8 	sub	r9,r12,-8
8000b07e:	11 8b       	ld.ub	r11,r8[0x0]
8000b080:	30 0a       	mov	r10,0
8000b082:	41 25       	lddsp	r5,sp[0x48]
8000b084:	f4 0b 18 00 	cp.b	r11,r10
8000b088:	f2 08 17 10 	movne	r8,r9
8000b08c:	c1 68       	rjmp	8000b0b8 <_dtoa_r+0xe8>
8000b08e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b092:	30 08       	mov	r8,0
8000b094:	fa eb 00 3c 	st.d	sp[60],r10
8000b098:	30 09       	mov	r9,0
8000b09a:	e0 a0 10 ce 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000b09e:	c1 00       	breq	8000b0be <_dtoa_r+0xee>
8000b0a0:	30 18       	mov	r8,1
8000b0a2:	41 5a       	lddsp	r10,sp[0x54]
8000b0a4:	95 08       	st.w	r10[0x0],r8
8000b0a6:	fe cc bf ee 	sub	r12,pc,-16402
8000b0aa:	41 29       	lddsp	r9,sp[0x48]
8000b0ac:	f8 08 00 08 	add	r8,r12,r8
8000b0b0:	58 09       	cp.w	r9,0
8000b0b2:	e0 80 05 7a 	breq	8000bba6 <_dtoa_r+0xbd6>
8000b0b6:	12 95       	mov	r5,r9
8000b0b8:	8b 08       	st.w	r5[0x0],r8
8000b0ba:	e0 8f 05 76 	bral	8000bba6 <_dtoa_r+0xbd6>
8000b0be:	fa c8 ff 9c 	sub	r8,sp,-100
8000b0c2:	fa c9 ff a0 	sub	r9,sp,-96
8000b0c6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b0ca:	0e 9c       	mov	r12,r7
8000b0cc:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b0d0:	e0 a0 0a 8a 	rcall	8000c5e4 <__d2b>
8000b0d4:	18 93       	mov	r3,r12
8000b0d6:	58 05       	cp.w	r5,0
8000b0d8:	c0 d0       	breq	8000b0f2 <_dtoa_r+0x122>
8000b0da:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b0de:	30 04       	mov	r4,0
8000b0e0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b0e4:	ea c5 03 ff 	sub	r5,r5,1023
8000b0e8:	10 9b       	mov	r11,r8
8000b0ea:	51 74       	stdsp	sp[0x5c],r4
8000b0ec:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b0f0:	c2 58       	rjmp	8000b13a <_dtoa_r+0x16a>
8000b0f2:	41 88       	lddsp	r8,sp[0x60]
8000b0f4:	41 9c       	lddsp	r12,sp[0x64]
8000b0f6:	10 0c       	add	r12,r8
8000b0f8:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b0fc:	e0 45 00 20 	cp.w	r5,32
8000b100:	e0 8a 00 0e 	brle	8000b11c <_dtoa_r+0x14c>
8000b104:	f8 cc fb ee 	sub	r12,r12,-1042
8000b108:	40 3b       	lddsp	r11,sp[0xc]
8000b10a:	ea 08 11 40 	rsub	r8,r5,64
8000b10e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b112:	ec 08 09 46 	lsl	r6,r6,r8
8000b116:	0c 4c       	or	r12,r6
8000b118:	c0 78       	rjmp	8000b126 <_dtoa_r+0x156>
8000b11a:	d7 03       	nop
8000b11c:	ea 0c 11 20 	rsub	r12,r5,32
8000b120:	40 3a       	lddsp	r10,sp[0xc]
8000b122:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b126:	e0 a0 10 14 	rcall	8000d14e <__avr32_u32_to_f64>
8000b12a:	fc 18 fe 10 	movh	r8,0xfe10
8000b12e:	30 19       	mov	r9,1
8000b130:	ea c5 04 33 	sub	r5,r5,1075
8000b134:	f0 0b 00 0b 	add	r11,r8,r11
8000b138:	51 79       	stdsp	sp[0x5c],r9
8000b13a:	30 08       	mov	r8,0
8000b13c:	fc 19 3f f8 	movh	r9,0x3ff8
8000b140:	e0 a0 0e 9c 	rcall	8000ce78 <__avr32_f64_sub>
8000b144:	e0 68 43 61 	mov	r8,17249
8000b148:	ea 18 63 6f 	orh	r8,0x636f
8000b14c:	e0 69 87 a7 	mov	r9,34727
8000b150:	ea 19 3f d2 	orh	r9,0x3fd2
8000b154:	e0 a0 0d a6 	rcall	8000cca0 <__avr32_f64_mul>
8000b158:	e0 68 c8 b3 	mov	r8,51379
8000b15c:	ea 18 8b 60 	orh	r8,0x8b60
8000b160:	e0 69 8a 28 	mov	r9,35368
8000b164:	ea 19 3f c6 	orh	r9,0x3fc6
8000b168:	e0 a0 0f 56 	rcall	8000d014 <__avr32_f64_add>
8000b16c:	0a 9c       	mov	r12,r5
8000b16e:	14 90       	mov	r0,r10
8000b170:	16 91       	mov	r1,r11
8000b172:	e0 a0 0f f2 	rcall	8000d156 <__avr32_s32_to_f64>
8000b176:	e0 68 79 fb 	mov	r8,31227
8000b17a:	ea 18 50 9f 	orh	r8,0x509f
8000b17e:	e0 69 44 13 	mov	r9,17427
8000b182:	ea 19 3f d3 	orh	r9,0x3fd3
8000b186:	e0 a0 0d 8d 	rcall	8000cca0 <__avr32_f64_mul>
8000b18a:	14 98       	mov	r8,r10
8000b18c:	16 99       	mov	r9,r11
8000b18e:	00 9a       	mov	r10,r0
8000b190:	02 9b       	mov	r11,r1
8000b192:	e0 a0 0f 41 	rcall	8000d014 <__avr32_f64_add>
8000b196:	14 90       	mov	r0,r10
8000b198:	16 91       	mov	r1,r11
8000b19a:	e0 a0 0f c7 	rcall	8000d128 <__avr32_f64_to_s32>
8000b19e:	30 08       	mov	r8,0
8000b1a0:	18 96       	mov	r6,r12
8000b1a2:	30 09       	mov	r9,0
8000b1a4:	00 9a       	mov	r10,r0
8000b1a6:	02 9b       	mov	r11,r1
8000b1a8:	e0 a0 10 8e 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b1ac:	c0 c0       	breq	8000b1c4 <_dtoa_r+0x1f4>
8000b1ae:	0c 9c       	mov	r12,r6
8000b1b0:	e0 a0 0f d3 	rcall	8000d156 <__avr32_s32_to_f64>
8000b1b4:	14 98       	mov	r8,r10
8000b1b6:	16 99       	mov	r9,r11
8000b1b8:	00 9a       	mov	r10,r0
8000b1ba:	02 9b       	mov	r11,r1
8000b1bc:	e0 a0 10 3d 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000b1c0:	f7 b6 00 01 	subeq	r6,1
8000b1c4:	59 66       	cp.w	r6,22
8000b1c6:	e0 88 00 05 	brls	8000b1d0 <_dtoa_r+0x200>
8000b1ca:	30 18       	mov	r8,1
8000b1cc:	51 48       	stdsp	sp[0x50],r8
8000b1ce:	c1 38       	rjmp	8000b1f4 <_dtoa_r+0x224>
8000b1d0:	fe c8 bf 34 	sub	r8,pc,-16588
8000b1d4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b1d8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b1dc:	e0 a0 10 74 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b1e0:	f9 b4 00 00 	moveq	r4,0
8000b1e4:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b1e8:	f7 b6 01 01 	subne	r6,1
8000b1ec:	f9 bc 01 00 	movne	r12,0
8000b1f0:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b1f4:	41 90       	lddsp	r0,sp[0x64]
8000b1f6:	20 10       	sub	r0,1
8000b1f8:	0a 10       	sub	r0,r5
8000b1fa:	c0 46       	brmi	8000b202 <_dtoa_r+0x232>
8000b1fc:	50 40       	stdsp	sp[0x10],r0
8000b1fe:	30 00       	mov	r0,0
8000b200:	c0 48       	rjmp	8000b208 <_dtoa_r+0x238>
8000b202:	30 0b       	mov	r11,0
8000b204:	5c 30       	neg	r0
8000b206:	50 4b       	stdsp	sp[0x10],r11
8000b208:	ec 02 11 00 	rsub	r2,r6,0
8000b20c:	58 06       	cp.w	r6,0
8000b20e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b212:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b216:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b21a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b21e:	f9 b2 04 00 	movge	r2,0
8000b222:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b226:	f9 b9 05 00 	movlt	r9,0
8000b22a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b22e:	40 c8       	lddsp	r8,sp[0x30]
8000b230:	58 98       	cp.w	r8,9
8000b232:	e0 8b 00 20 	brhi	8000b272 <_dtoa_r+0x2a2>
8000b236:	58 58       	cp.w	r8,5
8000b238:	f9 b4 0a 01 	movle	r4,1
8000b23c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b240:	f7 b5 09 04 	subgt	r5,4
8000b244:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b248:	f9 b4 09 00 	movgt	r4,0
8000b24c:	40 cc       	lddsp	r12,sp[0x30]
8000b24e:	58 3c       	cp.w	r12,3
8000b250:	c2 d0       	breq	8000b2aa <_dtoa_r+0x2da>
8000b252:	e0 89 00 05 	brgt	8000b25c <_dtoa_r+0x28c>
8000b256:	58 2c       	cp.w	r12,2
8000b258:	c1 01       	brne	8000b278 <_dtoa_r+0x2a8>
8000b25a:	c1 88       	rjmp	8000b28a <_dtoa_r+0x2ba>
8000b25c:	40 cb       	lddsp	r11,sp[0x30]
8000b25e:	58 4b       	cp.w	r11,4
8000b260:	c0 60       	breq	8000b26c <_dtoa_r+0x29c>
8000b262:	58 5b       	cp.w	r11,5
8000b264:	c0 a1       	brne	8000b278 <_dtoa_r+0x2a8>
8000b266:	30 1a       	mov	r10,1
8000b268:	50 da       	stdsp	sp[0x34],r10
8000b26a:	c2 28       	rjmp	8000b2ae <_dtoa_r+0x2de>
8000b26c:	30 19       	mov	r9,1
8000b26e:	50 d9       	stdsp	sp[0x34],r9
8000b270:	c0 f8       	rjmp	8000b28e <_dtoa_r+0x2be>
8000b272:	30 08       	mov	r8,0
8000b274:	30 14       	mov	r4,1
8000b276:	50 c8       	stdsp	sp[0x30],r8
8000b278:	3f f5       	mov	r5,-1
8000b27a:	30 1c       	mov	r12,1
8000b27c:	30 0b       	mov	r11,0
8000b27e:	50 95       	stdsp	sp[0x24],r5
8000b280:	50 dc       	stdsp	sp[0x34],r12
8000b282:	0a 91       	mov	r1,r5
8000b284:	31 28       	mov	r8,18
8000b286:	50 eb       	stdsp	sp[0x38],r11
8000b288:	c2 08       	rjmp	8000b2c8 <_dtoa_r+0x2f8>
8000b28a:	30 0a       	mov	r10,0
8000b28c:	50 da       	stdsp	sp[0x34],r10
8000b28e:	40 e9       	lddsp	r9,sp[0x38]
8000b290:	58 09       	cp.w	r9,0
8000b292:	e0 89 00 07 	brgt	8000b2a0 <_dtoa_r+0x2d0>
8000b296:	30 18       	mov	r8,1
8000b298:	50 98       	stdsp	sp[0x24],r8
8000b29a:	10 91       	mov	r1,r8
8000b29c:	50 e8       	stdsp	sp[0x38],r8
8000b29e:	c1 58       	rjmp	8000b2c8 <_dtoa_r+0x2f8>
8000b2a0:	40 e5       	lddsp	r5,sp[0x38]
8000b2a2:	50 95       	stdsp	sp[0x24],r5
8000b2a4:	0a 91       	mov	r1,r5
8000b2a6:	0a 98       	mov	r8,r5
8000b2a8:	c1 08       	rjmp	8000b2c8 <_dtoa_r+0x2f8>
8000b2aa:	30 0c       	mov	r12,0
8000b2ac:	50 dc       	stdsp	sp[0x34],r12
8000b2ae:	40 eb       	lddsp	r11,sp[0x38]
8000b2b0:	ec 0b 00 0b 	add	r11,r6,r11
8000b2b4:	50 9b       	stdsp	sp[0x24],r11
8000b2b6:	16 98       	mov	r8,r11
8000b2b8:	2f f8       	sub	r8,-1
8000b2ba:	58 08       	cp.w	r8,0
8000b2bc:	e0 89 00 05 	brgt	8000b2c6 <_dtoa_r+0x2f6>
8000b2c0:	10 91       	mov	r1,r8
8000b2c2:	30 18       	mov	r8,1
8000b2c4:	c0 28       	rjmp	8000b2c8 <_dtoa_r+0x2f8>
8000b2c6:	10 91       	mov	r1,r8
8000b2c8:	30 09       	mov	r9,0
8000b2ca:	6e 9a       	ld.w	r10,r7[0x24]
8000b2cc:	95 19       	st.w	r10[0x4],r9
8000b2ce:	30 49       	mov	r9,4
8000b2d0:	c0 68       	rjmp	8000b2dc <_dtoa_r+0x30c>
8000b2d2:	d7 03       	nop
8000b2d4:	6a 1a       	ld.w	r10,r5[0x4]
8000b2d6:	a1 79       	lsl	r9,0x1
8000b2d8:	2f fa       	sub	r10,-1
8000b2da:	8b 1a       	st.w	r5[0x4],r10
8000b2dc:	6e 95       	ld.w	r5,r7[0x24]
8000b2de:	f2 ca ff ec 	sub	r10,r9,-20
8000b2e2:	10 3a       	cp.w	r10,r8
8000b2e4:	fe 98 ff f8 	brls	8000b2d4 <_dtoa_r+0x304>
8000b2e8:	6a 1b       	ld.w	r11,r5[0x4]
8000b2ea:	0e 9c       	mov	r12,r7
8000b2ec:	e0 a0 09 44 	rcall	8000c574 <_Balloc>
8000b2f0:	58 e1       	cp.w	r1,14
8000b2f2:	5f 88       	srls	r8
8000b2f4:	8b 0c       	st.w	r5[0x0],r12
8000b2f6:	f1 e4 00 04 	and	r4,r8,r4
8000b2fa:	6e 98       	ld.w	r8,r7[0x24]
8000b2fc:	70 08       	ld.w	r8,r8[0x0]
8000b2fe:	50 88       	stdsp	sp[0x20],r8
8000b300:	e0 80 01 82 	breq	8000b604 <_dtoa_r+0x634>
8000b304:	58 06       	cp.w	r6,0
8000b306:	e0 8a 00 43 	brle	8000b38c <_dtoa_r+0x3bc>
8000b30a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b30e:	fe c8 c0 72 	sub	r8,pc,-16270
8000b312:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b316:	fa e5 00 18 	st.d	sp[24],r4
8000b31a:	ec 04 14 04 	asr	r4,r6,0x4
8000b31e:	ed b4 00 04 	bld	r4,0x4
8000b322:	c0 30       	breq	8000b328 <_dtoa_r+0x358>
8000b324:	30 25       	mov	r5,2
8000b326:	c1 08       	rjmp	8000b346 <_dtoa_r+0x376>
8000b328:	fe c8 bf c4 	sub	r8,pc,-16444
8000b32c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b330:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b334:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b338:	e0 a0 0f fa 	rcall	8000d32c <__avr32_f64_div>
8000b33c:	30 35       	mov	r5,3
8000b33e:	14 98       	mov	r8,r10
8000b340:	16 99       	mov	r9,r11
8000b342:	fa e9 00 08 	st.d	sp[8],r8
8000b346:	fe cc bf e2 	sub	r12,pc,-16414
8000b34a:	50 a3       	stdsp	sp[0x28],r3
8000b34c:	0c 93       	mov	r3,r6
8000b34e:	18 96       	mov	r6,r12
8000b350:	c0 f8       	rjmp	8000b36e <_dtoa_r+0x39e>
8000b352:	fa ea 00 18 	ld.d	r10,sp[24]
8000b356:	ed b4 00 00 	bld	r4,0x0
8000b35a:	c0 81       	brne	8000b36a <_dtoa_r+0x39a>
8000b35c:	ec e8 00 00 	ld.d	r8,r6[0]
8000b360:	2f f5       	sub	r5,-1
8000b362:	e0 a0 0c 9f 	rcall	8000cca0 <__avr32_f64_mul>
8000b366:	fa eb 00 18 	st.d	sp[24],r10
8000b36a:	a1 54       	asr	r4,0x1
8000b36c:	2f 86       	sub	r6,-8
8000b36e:	58 04       	cp.w	r4,0
8000b370:	cf 11       	brne	8000b352 <_dtoa_r+0x382>
8000b372:	fa e8 00 18 	ld.d	r8,sp[24]
8000b376:	fa ea 00 08 	ld.d	r10,sp[8]
8000b37a:	06 96       	mov	r6,r3
8000b37c:	e0 a0 0f d8 	rcall	8000d32c <__avr32_f64_div>
8000b380:	40 a3       	lddsp	r3,sp[0x28]
8000b382:	14 98       	mov	r8,r10
8000b384:	16 99       	mov	r9,r11
8000b386:	fa e9 00 08 	st.d	sp[8],r8
8000b38a:	c2 f8       	rjmp	8000b3e8 <_dtoa_r+0x418>
8000b38c:	ec 08 11 00 	rsub	r8,r6,0
8000b390:	c0 31       	brne	8000b396 <_dtoa_r+0x3c6>
8000b392:	30 25       	mov	r5,2
8000b394:	c2 a8       	rjmp	8000b3e8 <_dtoa_r+0x418>
8000b396:	fe cc c0 32 	sub	r12,pc,-16334
8000b39a:	f0 04 14 04 	asr	r4,r8,0x4
8000b39e:	50 1c       	stdsp	sp[0x4],r12
8000b3a0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b3a4:	fe c9 c1 08 	sub	r9,pc,-16120
8000b3a8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b3ac:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b3b0:	e0 a0 0c 78 	rcall	8000cca0 <__avr32_f64_mul>
8000b3b4:	40 1c       	lddsp	r12,sp[0x4]
8000b3b6:	50 63       	stdsp	sp[0x18],r3
8000b3b8:	30 25       	mov	r5,2
8000b3ba:	0c 93       	mov	r3,r6
8000b3bc:	fa eb 00 08 	st.d	sp[8],r10
8000b3c0:	18 96       	mov	r6,r12
8000b3c2:	c0 f8       	rjmp	8000b3e0 <_dtoa_r+0x410>
8000b3c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000b3c8:	ed b4 00 00 	bld	r4,0x0
8000b3cc:	c0 81       	brne	8000b3dc <_dtoa_r+0x40c>
8000b3ce:	ec e8 00 00 	ld.d	r8,r6[0]
8000b3d2:	2f f5       	sub	r5,-1
8000b3d4:	e0 a0 0c 66 	rcall	8000cca0 <__avr32_f64_mul>
8000b3d8:	fa eb 00 08 	st.d	sp[8],r10
8000b3dc:	a1 54       	asr	r4,0x1
8000b3de:	2f 86       	sub	r6,-8
8000b3e0:	58 04       	cp.w	r4,0
8000b3e2:	cf 11       	brne	8000b3c4 <_dtoa_r+0x3f4>
8000b3e4:	06 96       	mov	r6,r3
8000b3e6:	40 63       	lddsp	r3,sp[0x18]
8000b3e8:	41 4a       	lddsp	r10,sp[0x50]
8000b3ea:	58 0a       	cp.w	r10,0
8000b3ec:	c2 a0       	breq	8000b440 <_dtoa_r+0x470>
8000b3ee:	fa e8 00 08 	ld.d	r8,sp[8]
8000b3f2:	58 01       	cp.w	r1,0
8000b3f4:	5f 94       	srgt	r4
8000b3f6:	fa e9 00 18 	st.d	sp[24],r8
8000b3fa:	30 08       	mov	r8,0
8000b3fc:	fc 19 3f f0 	movh	r9,0x3ff0
8000b400:	fa ea 00 18 	ld.d	r10,sp[24]
8000b404:	e0 a0 0f 60 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b408:	f9 bc 00 00 	moveq	r12,0
8000b40c:	f9 bc 01 01 	movne	r12,1
8000b410:	e9 ec 00 0c 	and	r12,r4,r12
8000b414:	c1 60       	breq	8000b440 <_dtoa_r+0x470>
8000b416:	40 98       	lddsp	r8,sp[0x24]
8000b418:	58 08       	cp.w	r8,0
8000b41a:	e0 8a 00 f1 	brle	8000b5fc <_dtoa_r+0x62c>
8000b41e:	30 08       	mov	r8,0
8000b420:	fc 19 40 24 	movh	r9,0x4024
8000b424:	ec c4 00 01 	sub	r4,r6,1
8000b428:	fa ea 00 18 	ld.d	r10,sp[24]
8000b42c:	2f f5       	sub	r5,-1
8000b42e:	50 64       	stdsp	sp[0x18],r4
8000b430:	e0 a0 0c 38 	rcall	8000cca0 <__avr32_f64_mul>
8000b434:	40 94       	lddsp	r4,sp[0x24]
8000b436:	14 98       	mov	r8,r10
8000b438:	16 99       	mov	r9,r11
8000b43a:	fa e9 00 08 	st.d	sp[8],r8
8000b43e:	c0 38       	rjmp	8000b444 <_dtoa_r+0x474>
8000b440:	50 66       	stdsp	sp[0x18],r6
8000b442:	02 94       	mov	r4,r1
8000b444:	0a 9c       	mov	r12,r5
8000b446:	e0 a0 0e 88 	rcall	8000d156 <__avr32_s32_to_f64>
8000b44a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b44e:	e0 a0 0c 29 	rcall	8000cca0 <__avr32_f64_mul>
8000b452:	30 08       	mov	r8,0
8000b454:	fc 19 40 1c 	movh	r9,0x401c
8000b458:	e0 a0 0d de 	rcall	8000d014 <__avr32_f64_add>
8000b45c:	14 98       	mov	r8,r10
8000b45e:	16 99       	mov	r9,r11
8000b460:	fa e9 00 28 	st.d	sp[40],r8
8000b464:	fc 18 fc c0 	movh	r8,0xfcc0
8000b468:	40 a5       	lddsp	r5,sp[0x28]
8000b46a:	10 05       	add	r5,r8
8000b46c:	50 a5       	stdsp	sp[0x28],r5
8000b46e:	58 04       	cp.w	r4,0
8000b470:	c2 11       	brne	8000b4b2 <_dtoa_r+0x4e2>
8000b472:	fa ea 00 08 	ld.d	r10,sp[8]
8000b476:	30 08       	mov	r8,0
8000b478:	fc 19 40 14 	movh	r9,0x4014
8000b47c:	e0 a0 0c fe 	rcall	8000ce78 <__avr32_f64_sub>
8000b480:	40 bc       	lddsp	r12,sp[0x2c]
8000b482:	fa eb 00 08 	st.d	sp[8],r10
8000b486:	14 98       	mov	r8,r10
8000b488:	16 99       	mov	r9,r11
8000b48a:	18 9a       	mov	r10,r12
8000b48c:	0a 9b       	mov	r11,r5
8000b48e:	e0 a0 0f 1b 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b492:	e0 81 02 54 	brne	8000b93a <_dtoa_r+0x96a>
8000b496:	0a 98       	mov	r8,r5
8000b498:	40 b9       	lddsp	r9,sp[0x2c]
8000b49a:	ee 18 80 00 	eorh	r8,0x8000
8000b49e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b4a2:	10 95       	mov	r5,r8
8000b4a4:	12 98       	mov	r8,r9
8000b4a6:	0a 99       	mov	r9,r5
8000b4a8:	e0 a0 0f 0e 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b4ac:	e0 81 02 3e 	brne	8000b928 <_dtoa_r+0x958>
8000b4b0:	ca 68       	rjmp	8000b5fc <_dtoa_r+0x62c>
8000b4b2:	fe c9 c2 16 	sub	r9,pc,-15850
8000b4b6:	e8 c8 00 01 	sub	r8,r4,1
8000b4ba:	40 d5       	lddsp	r5,sp[0x34]
8000b4bc:	58 05       	cp.w	r5,0
8000b4be:	c4 f0       	breq	8000b55c <_dtoa_r+0x58c>
8000b4c0:	30 0c       	mov	r12,0
8000b4c2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b4c6:	51 3c       	stdsp	sp[0x4c],r12
8000b4c8:	30 0a       	mov	r10,0
8000b4ca:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b4ce:	e0 a0 0f 2f 	rcall	8000d32c <__avr32_f64_div>
8000b4d2:	fa e8 00 28 	ld.d	r8,sp[40]
8000b4d6:	40 85       	lddsp	r5,sp[0x20]
8000b4d8:	e0 a0 0c d0 	rcall	8000ce78 <__avr32_f64_sub>
8000b4dc:	fa eb 00 28 	st.d	sp[40],r10
8000b4e0:	fa ea 00 08 	ld.d	r10,sp[8]
8000b4e4:	e0 a0 0e 22 	rcall	8000d128 <__avr32_f64_to_s32>
8000b4e8:	51 6c       	stdsp	sp[0x58],r12
8000b4ea:	e0 a0 0e 36 	rcall	8000d156 <__avr32_s32_to_f64>
8000b4ee:	14 98       	mov	r8,r10
8000b4f0:	16 99       	mov	r9,r11
8000b4f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b4f6:	e0 a0 0c c1 	rcall	8000ce78 <__avr32_f64_sub>
8000b4fa:	fa eb 00 08 	st.d	sp[8],r10
8000b4fe:	41 68       	lddsp	r8,sp[0x58]
8000b500:	2d 08       	sub	r8,-48
8000b502:	0a c8       	st.b	r5++,r8
8000b504:	41 39       	lddsp	r9,sp[0x4c]
8000b506:	2f f9       	sub	r9,-1
8000b508:	51 39       	stdsp	sp[0x4c],r9
8000b50a:	fa e8 00 28 	ld.d	r8,sp[40]
8000b50e:	e0 a0 0e db 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b512:	e0 81 03 39 	brne	8000bb84 <_dtoa_r+0xbb4>
8000b516:	fa e8 00 08 	ld.d	r8,sp[8]
8000b51a:	30 0a       	mov	r10,0
8000b51c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b520:	e0 a0 0c ac 	rcall	8000ce78 <__avr32_f64_sub>
8000b524:	fa e8 00 28 	ld.d	r8,sp[40]
8000b528:	e0 a0 0e ce 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b52c:	fa ea 00 28 	ld.d	r10,sp[40]
8000b530:	30 08       	mov	r8,0
8000b532:	fc 19 40 24 	movh	r9,0x4024
8000b536:	e0 81 00 da 	brne	8000b6ea <_dtoa_r+0x71a>
8000b53a:	41 3c       	lddsp	r12,sp[0x4c]
8000b53c:	08 3c       	cp.w	r12,r4
8000b53e:	c5 f4       	brge	8000b5fc <_dtoa_r+0x62c>
8000b540:	e0 a0 0b b0 	rcall	8000cca0 <__avr32_f64_mul>
8000b544:	30 08       	mov	r8,0
8000b546:	fa eb 00 28 	st.d	sp[40],r10
8000b54a:	fc 19 40 24 	movh	r9,0x4024
8000b54e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b552:	e0 a0 0b a7 	rcall	8000cca0 <__avr32_f64_mul>
8000b556:	fa eb 00 08 	st.d	sp[8],r10
8000b55a:	cc 3b       	rjmp	8000b4e0 <_dtoa_r+0x510>
8000b55c:	40 85       	lddsp	r5,sp[0x20]
8000b55e:	08 05       	add	r5,r4
8000b560:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b564:	51 35       	stdsp	sp[0x4c],r5
8000b566:	fa e8 00 28 	ld.d	r8,sp[40]
8000b56a:	40 85       	lddsp	r5,sp[0x20]
8000b56c:	e0 a0 0b 9a 	rcall	8000cca0 <__avr32_f64_mul>
8000b570:	fa eb 00 28 	st.d	sp[40],r10
8000b574:	fa ea 00 08 	ld.d	r10,sp[8]
8000b578:	e0 a0 0d d8 	rcall	8000d128 <__avr32_f64_to_s32>
8000b57c:	51 6c       	stdsp	sp[0x58],r12
8000b57e:	e0 a0 0d ec 	rcall	8000d156 <__avr32_s32_to_f64>
8000b582:	14 98       	mov	r8,r10
8000b584:	16 99       	mov	r9,r11
8000b586:	fa ea 00 08 	ld.d	r10,sp[8]
8000b58a:	e0 a0 0c 77 	rcall	8000ce78 <__avr32_f64_sub>
8000b58e:	fa eb 00 08 	st.d	sp[8],r10
8000b592:	41 68       	lddsp	r8,sp[0x58]
8000b594:	2d 08       	sub	r8,-48
8000b596:	0a c8       	st.b	r5++,r8
8000b598:	41 3c       	lddsp	r12,sp[0x4c]
8000b59a:	18 35       	cp.w	r5,r12
8000b59c:	c2 81       	brne	8000b5ec <_dtoa_r+0x61c>
8000b59e:	30 08       	mov	r8,0
8000b5a0:	fc 19 3f e0 	movh	r9,0x3fe0
8000b5a4:	fa ea 00 28 	ld.d	r10,sp[40]
8000b5a8:	e0 a0 0d 36 	rcall	8000d014 <__avr32_f64_add>
8000b5ac:	40 85       	lddsp	r5,sp[0x20]
8000b5ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000b5b2:	08 05       	add	r5,r4
8000b5b4:	e0 a0 0e 88 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b5b8:	e0 81 00 99 	brne	8000b6ea <_dtoa_r+0x71a>
8000b5bc:	fa e8 00 28 	ld.d	r8,sp[40]
8000b5c0:	30 0a       	mov	r10,0
8000b5c2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b5c6:	e0 a0 0c 59 	rcall	8000ce78 <__avr32_f64_sub>
8000b5ca:	14 98       	mov	r8,r10
8000b5cc:	16 99       	mov	r9,r11
8000b5ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5d2:	e0 a0 0e 79 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b5d6:	c1 30       	breq	8000b5fc <_dtoa_r+0x62c>
8000b5d8:	33 09       	mov	r9,48
8000b5da:	0a 98       	mov	r8,r5
8000b5dc:	11 7a       	ld.ub	r10,--r8
8000b5de:	f2 0a 18 00 	cp.b	r10,r9
8000b5e2:	e0 81 02 d1 	brne	8000bb84 <_dtoa_r+0xbb4>
8000b5e6:	10 95       	mov	r5,r8
8000b5e8:	cf 9b       	rjmp	8000b5da <_dtoa_r+0x60a>
8000b5ea:	d7 03       	nop
8000b5ec:	30 08       	mov	r8,0
8000b5ee:	fc 19 40 24 	movh	r9,0x4024
8000b5f2:	e0 a0 0b 57 	rcall	8000cca0 <__avr32_f64_mul>
8000b5f6:	fa eb 00 08 	st.d	sp[8],r10
8000b5fa:	cb db       	rjmp	8000b574 <_dtoa_r+0x5a4>
8000b5fc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b600:	fa eb 00 08 	st.d	sp[8],r10
8000b604:	58 e6       	cp.w	r6,14
8000b606:	5f ab       	srle	r11
8000b608:	41 8a       	lddsp	r10,sp[0x60]
8000b60a:	30 08       	mov	r8,0
8000b60c:	f4 09 11 ff 	rsub	r9,r10,-1
8000b610:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b614:	f0 09 18 00 	cp.b	r9,r8
8000b618:	e0 80 00 82 	breq	8000b71c <_dtoa_r+0x74c>
8000b61c:	40 ea       	lddsp	r10,sp[0x38]
8000b61e:	58 01       	cp.w	r1,0
8000b620:	5f a9       	srle	r9
8000b622:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b626:	fe ca c3 8a 	sub	r10,pc,-15478
8000b62a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b62e:	fa e5 00 10 	st.d	sp[16],r4
8000b632:	f0 09 18 00 	cp.b	r9,r8
8000b636:	c1 40       	breq	8000b65e <_dtoa_r+0x68e>
8000b638:	58 01       	cp.w	r1,0
8000b63a:	e0 81 01 77 	brne	8000b928 <_dtoa_r+0x958>
8000b63e:	30 08       	mov	r8,0
8000b640:	fc 19 40 14 	movh	r9,0x4014
8000b644:	08 9a       	mov	r10,r4
8000b646:	0a 9b       	mov	r11,r5
8000b648:	e0 a0 0b 2c 	rcall	8000cca0 <__avr32_f64_mul>
8000b64c:	fa e8 00 08 	ld.d	r8,sp[8]
8000b650:	e0 a0 0e 06 	rcall	8000d25c <__avr32_f64_cmp_ge>
8000b654:	e0 81 01 6a 	brne	8000b928 <_dtoa_r+0x958>
8000b658:	02 92       	mov	r2,r1
8000b65a:	e0 8f 01 72 	bral	8000b93e <_dtoa_r+0x96e>
8000b65e:	40 85       	lddsp	r5,sp[0x20]
8000b660:	30 14       	mov	r4,1
8000b662:	fa e8 00 10 	ld.d	r8,sp[16]
8000b666:	fa ea 00 08 	ld.d	r10,sp[8]
8000b66a:	e0 a0 0e 61 	rcall	8000d32c <__avr32_f64_div>
8000b66e:	e0 a0 0d 5d 	rcall	8000d128 <__avr32_f64_to_s32>
8000b672:	18 92       	mov	r2,r12
8000b674:	e0 a0 0d 71 	rcall	8000d156 <__avr32_s32_to_f64>
8000b678:	fa e8 00 10 	ld.d	r8,sp[16]
8000b67c:	e0 a0 0b 12 	rcall	8000cca0 <__avr32_f64_mul>
8000b680:	14 98       	mov	r8,r10
8000b682:	16 99       	mov	r9,r11
8000b684:	fa ea 00 08 	ld.d	r10,sp[8]
8000b688:	e0 a0 0b f8 	rcall	8000ce78 <__avr32_f64_sub>
8000b68c:	fa eb 00 08 	st.d	sp[8],r10
8000b690:	e4 c8 ff d0 	sub	r8,r2,-48
8000b694:	0a c8       	st.b	r5++,r8
8000b696:	fc 19 40 24 	movh	r9,0x4024
8000b69a:	30 08       	mov	r8,0
8000b69c:	02 34       	cp.w	r4,r1
8000b69e:	c3 31       	brne	8000b704 <_dtoa_r+0x734>
8000b6a0:	fa e8 00 08 	ld.d	r8,sp[8]
8000b6a4:	e0 a0 0c b8 	rcall	8000d014 <__avr32_f64_add>
8000b6a8:	16 91       	mov	r1,r11
8000b6aa:	14 90       	mov	r0,r10
8000b6ac:	14 98       	mov	r8,r10
8000b6ae:	02 99       	mov	r9,r1
8000b6b0:	fa ea 00 10 	ld.d	r10,sp[16]
8000b6b4:	e0 a0 0e 08 	rcall	8000d2c4 <__avr32_f64_cmp_lt>
8000b6b8:	c1 a1       	brne	8000b6ec <_dtoa_r+0x71c>
8000b6ba:	fa e8 00 10 	ld.d	r8,sp[16]
8000b6be:	00 9a       	mov	r10,r0
8000b6c0:	02 9b       	mov	r11,r1
8000b6c2:	e0 a0 0d ba 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000b6c6:	e0 80 02 5e 	breq	8000bb82 <_dtoa_r+0xbb2>
8000b6ca:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b6ce:	c0 f1       	brne	8000b6ec <_dtoa_r+0x71c>
8000b6d0:	e0 8f 02 59 	bral	8000bb82 <_dtoa_r+0xbb2>
8000b6d4:	40 8a       	lddsp	r10,sp[0x20]
8000b6d6:	14 38       	cp.w	r8,r10
8000b6d8:	c0 30       	breq	8000b6de <_dtoa_r+0x70e>
8000b6da:	10 95       	mov	r5,r8
8000b6dc:	c0 98       	rjmp	8000b6ee <_dtoa_r+0x71e>
8000b6de:	33 08       	mov	r8,48
8000b6e0:	40 89       	lddsp	r9,sp[0x20]
8000b6e2:	2f f6       	sub	r6,-1
8000b6e4:	b2 88       	st.b	r9[0x0],r8
8000b6e6:	40 88       	lddsp	r8,sp[0x20]
8000b6e8:	c0 88       	rjmp	8000b6f8 <_dtoa_r+0x728>
8000b6ea:	40 66       	lddsp	r6,sp[0x18]
8000b6ec:	33 99       	mov	r9,57
8000b6ee:	0a 98       	mov	r8,r5
8000b6f0:	11 7a       	ld.ub	r10,--r8
8000b6f2:	f2 0a 18 00 	cp.b	r10,r9
8000b6f6:	ce f0       	breq	8000b6d4 <_dtoa_r+0x704>
8000b6f8:	50 66       	stdsp	sp[0x18],r6
8000b6fa:	11 89       	ld.ub	r9,r8[0x0]
8000b6fc:	2f f9       	sub	r9,-1
8000b6fe:	b0 89       	st.b	r8[0x0],r9
8000b700:	e0 8f 02 42 	bral	8000bb84 <_dtoa_r+0xbb4>
8000b704:	e0 a0 0a ce 	rcall	8000cca0 <__avr32_f64_mul>
8000b708:	2f f4       	sub	r4,-1
8000b70a:	fa eb 00 08 	st.d	sp[8],r10
8000b70e:	30 08       	mov	r8,0
8000b710:	30 09       	mov	r9,0
8000b712:	e0 a0 0d 92 	rcall	8000d236 <__avr32_f64_cmp_eq>
8000b716:	ca 60       	breq	8000b662 <_dtoa_r+0x692>
8000b718:	e0 8f 02 35 	bral	8000bb82 <_dtoa_r+0xbb2>
8000b71c:	40 d8       	lddsp	r8,sp[0x34]
8000b71e:	58 08       	cp.w	r8,0
8000b720:	c0 51       	brne	8000b72a <_dtoa_r+0x75a>
8000b722:	04 98       	mov	r8,r2
8000b724:	00 95       	mov	r5,r0
8000b726:	40 d4       	lddsp	r4,sp[0x34]
8000b728:	c3 78       	rjmp	8000b796 <_dtoa_r+0x7c6>
8000b72a:	40 c5       	lddsp	r5,sp[0x30]
8000b72c:	58 15       	cp.w	r5,1
8000b72e:	e0 89 00 0f 	brgt	8000b74c <_dtoa_r+0x77c>
8000b732:	41 74       	lddsp	r4,sp[0x5c]
8000b734:	58 04       	cp.w	r4,0
8000b736:	c0 40       	breq	8000b73e <_dtoa_r+0x76e>
8000b738:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b73c:	c0 48       	rjmp	8000b744 <_dtoa_r+0x774>
8000b73e:	41 99       	lddsp	r9,sp[0x64]
8000b740:	f2 09 11 36 	rsub	r9,r9,54
8000b744:	04 98       	mov	r8,r2
8000b746:	00 95       	mov	r5,r0
8000b748:	c1 c8       	rjmp	8000b780 <_dtoa_r+0x7b0>
8000b74a:	d7 03       	nop
8000b74c:	e2 c8 00 01 	sub	r8,r1,1
8000b750:	58 01       	cp.w	r1,0
8000b752:	e0 05 17 40 	movge	r5,r0
8000b756:	e2 09 17 40 	movge	r9,r1
8000b75a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b75e:	f9 b9 05 00 	movlt	r9,0
8000b762:	10 32       	cp.w	r2,r8
8000b764:	e5 d8 e4 18 	subge	r8,r2,r8
8000b768:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b76c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b770:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b774:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b778:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b77c:	f9 b8 05 00 	movlt	r8,0
8000b780:	40 4b       	lddsp	r11,sp[0x10]
8000b782:	12 0b       	add	r11,r9
8000b784:	50 08       	stdsp	sp[0x0],r8
8000b786:	50 4b       	stdsp	sp[0x10],r11
8000b788:	12 00       	add	r0,r9
8000b78a:	30 1b       	mov	r11,1
8000b78c:	0e 9c       	mov	r12,r7
8000b78e:	e0 a0 08 a7 	rcall	8000c8dc <__i2b>
8000b792:	40 08       	lddsp	r8,sp[0x0]
8000b794:	18 94       	mov	r4,r12
8000b796:	40 4a       	lddsp	r10,sp[0x10]
8000b798:	58 05       	cp.w	r5,0
8000b79a:	5f 99       	srgt	r9
8000b79c:	58 0a       	cp.w	r10,0
8000b79e:	5f 9a       	srgt	r10
8000b7a0:	f5 e9 00 09 	and	r9,r10,r9
8000b7a4:	c0 80       	breq	8000b7b4 <_dtoa_r+0x7e4>
8000b7a6:	40 4c       	lddsp	r12,sp[0x10]
8000b7a8:	f8 05 0d 49 	min	r9,r12,r5
8000b7ac:	12 1c       	sub	r12,r9
8000b7ae:	12 10       	sub	r0,r9
8000b7b0:	50 4c       	stdsp	sp[0x10],r12
8000b7b2:	12 15       	sub	r5,r9
8000b7b4:	58 02       	cp.w	r2,0
8000b7b6:	e0 8a 00 27 	brle	8000b804 <_dtoa_r+0x834>
8000b7ba:	40 db       	lddsp	r11,sp[0x34]
8000b7bc:	58 0b       	cp.w	r11,0
8000b7be:	c1 d0       	breq	8000b7f8 <_dtoa_r+0x828>
8000b7c0:	58 08       	cp.w	r8,0
8000b7c2:	e0 8a 00 17 	brle	8000b7f0 <_dtoa_r+0x820>
8000b7c6:	10 9a       	mov	r10,r8
8000b7c8:	50 08       	stdsp	sp[0x0],r8
8000b7ca:	08 9b       	mov	r11,r4
8000b7cc:	0e 9c       	mov	r12,r7
8000b7ce:	e0 a0 08 cd 	rcall	8000c968 <__pow5mult>
8000b7d2:	06 9a       	mov	r10,r3
8000b7d4:	18 9b       	mov	r11,r12
8000b7d6:	18 94       	mov	r4,r12
8000b7d8:	0e 9c       	mov	r12,r7
8000b7da:	e0 a0 08 01 	rcall	8000c7dc <__multiply>
8000b7de:	18 99       	mov	r9,r12
8000b7e0:	06 9b       	mov	r11,r3
8000b7e2:	50 19       	stdsp	sp[0x4],r9
8000b7e4:	0e 9c       	mov	r12,r7
8000b7e6:	e0 a0 06 ad 	rcall	8000c540 <_Bfree>
8000b7ea:	40 19       	lddsp	r9,sp[0x4]
8000b7ec:	40 08       	lddsp	r8,sp[0x0]
8000b7ee:	12 93       	mov	r3,r9
8000b7f0:	e4 08 01 0a 	sub	r10,r2,r8
8000b7f4:	c0 80       	breq	8000b804 <_dtoa_r+0x834>
8000b7f6:	c0 28       	rjmp	8000b7fa <_dtoa_r+0x82a>
8000b7f8:	04 9a       	mov	r10,r2
8000b7fa:	06 9b       	mov	r11,r3
8000b7fc:	0e 9c       	mov	r12,r7
8000b7fe:	e0 a0 08 b5 	rcall	8000c968 <__pow5mult>
8000b802:	18 93       	mov	r3,r12
8000b804:	30 1b       	mov	r11,1
8000b806:	0e 9c       	mov	r12,r7
8000b808:	e0 a0 08 6a 	rcall	8000c8dc <__i2b>
8000b80c:	41 1a       	lddsp	r10,sp[0x44]
8000b80e:	18 92       	mov	r2,r12
8000b810:	58 0a       	cp.w	r10,0
8000b812:	e0 8a 00 07 	brle	8000b820 <_dtoa_r+0x850>
8000b816:	18 9b       	mov	r11,r12
8000b818:	0e 9c       	mov	r12,r7
8000b81a:	e0 a0 08 a7 	rcall	8000c968 <__pow5mult>
8000b81e:	18 92       	mov	r2,r12
8000b820:	40 c9       	lddsp	r9,sp[0x30]
8000b822:	58 19       	cp.w	r9,1
8000b824:	e0 89 00 14 	brgt	8000b84c <_dtoa_r+0x87c>
8000b828:	40 38       	lddsp	r8,sp[0xc]
8000b82a:	58 08       	cp.w	r8,0
8000b82c:	c1 01       	brne	8000b84c <_dtoa_r+0x87c>
8000b82e:	40 29       	lddsp	r9,sp[0x8]
8000b830:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b834:	c0 c1       	brne	8000b84c <_dtoa_r+0x87c>
8000b836:	12 98       	mov	r8,r9
8000b838:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b83c:	c0 80       	breq	8000b84c <_dtoa_r+0x87c>
8000b83e:	40 4c       	lddsp	r12,sp[0x10]
8000b840:	30 1b       	mov	r11,1
8000b842:	2f fc       	sub	r12,-1
8000b844:	2f f0       	sub	r0,-1
8000b846:	50 4c       	stdsp	sp[0x10],r12
8000b848:	50 6b       	stdsp	sp[0x18],r11
8000b84a:	c0 38       	rjmp	8000b850 <_dtoa_r+0x880>
8000b84c:	30 0a       	mov	r10,0
8000b84e:	50 6a       	stdsp	sp[0x18],r10
8000b850:	41 19       	lddsp	r9,sp[0x44]
8000b852:	58 09       	cp.w	r9,0
8000b854:	c0 31       	brne	8000b85a <_dtoa_r+0x88a>
8000b856:	30 1c       	mov	r12,1
8000b858:	c0 98       	rjmp	8000b86a <_dtoa_r+0x89a>
8000b85a:	64 48       	ld.w	r8,r2[0x10]
8000b85c:	2f c8       	sub	r8,-4
8000b85e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b862:	e0 a0 05 df 	rcall	8000c420 <__hi0bits>
8000b866:	f8 0c 11 20 	rsub	r12,r12,32
8000b86a:	40 4b       	lddsp	r11,sp[0x10]
8000b86c:	f8 0b 00 08 	add	r8,r12,r11
8000b870:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b874:	c0 c0       	breq	8000b88c <_dtoa_r+0x8bc>
8000b876:	f0 08 11 20 	rsub	r8,r8,32
8000b87a:	58 48       	cp.w	r8,4
8000b87c:	e0 8a 00 06 	brle	8000b888 <_dtoa_r+0x8b8>
8000b880:	20 48       	sub	r8,4
8000b882:	10 0b       	add	r11,r8
8000b884:	50 4b       	stdsp	sp[0x10],r11
8000b886:	c0 78       	rjmp	8000b894 <_dtoa_r+0x8c4>
8000b888:	58 48       	cp.w	r8,4
8000b88a:	c0 70       	breq	8000b898 <_dtoa_r+0x8c8>
8000b88c:	40 4a       	lddsp	r10,sp[0x10]
8000b88e:	2e 48       	sub	r8,-28
8000b890:	10 0a       	add	r10,r8
8000b892:	50 4a       	stdsp	sp[0x10],r10
8000b894:	10 00       	add	r0,r8
8000b896:	10 05       	add	r5,r8
8000b898:	58 00       	cp.w	r0,0
8000b89a:	e0 8a 00 08 	brle	8000b8aa <_dtoa_r+0x8da>
8000b89e:	06 9b       	mov	r11,r3
8000b8a0:	00 9a       	mov	r10,r0
8000b8a2:	0e 9c       	mov	r12,r7
8000b8a4:	e0 a0 07 58 	rcall	8000c754 <__lshift>
8000b8a8:	18 93       	mov	r3,r12
8000b8aa:	40 49       	lddsp	r9,sp[0x10]
8000b8ac:	58 09       	cp.w	r9,0
8000b8ae:	e0 8a 00 08 	brle	8000b8be <_dtoa_r+0x8ee>
8000b8b2:	04 9b       	mov	r11,r2
8000b8b4:	12 9a       	mov	r10,r9
8000b8b6:	0e 9c       	mov	r12,r7
8000b8b8:	e0 a0 07 4e 	rcall	8000c754 <__lshift>
8000b8bc:	18 92       	mov	r2,r12
8000b8be:	41 48       	lddsp	r8,sp[0x50]
8000b8c0:	58 08       	cp.w	r8,0
8000b8c2:	c1 b0       	breq	8000b8f8 <_dtoa_r+0x928>
8000b8c4:	04 9b       	mov	r11,r2
8000b8c6:	06 9c       	mov	r12,r3
8000b8c8:	e0 a0 06 23 	rcall	8000c50e <__mcmp>
8000b8cc:	c1 64       	brge	8000b8f8 <_dtoa_r+0x928>
8000b8ce:	06 9b       	mov	r11,r3
8000b8d0:	30 09       	mov	r9,0
8000b8d2:	30 aa       	mov	r10,10
8000b8d4:	0e 9c       	mov	r12,r7
8000b8d6:	e0 a0 08 0b 	rcall	8000c8ec <__multadd>
8000b8da:	20 16       	sub	r6,1
8000b8dc:	18 93       	mov	r3,r12
8000b8de:	40 dc       	lddsp	r12,sp[0x34]
8000b8e0:	58 0c       	cp.w	r12,0
8000b8e2:	c0 31       	brne	8000b8e8 <_dtoa_r+0x918>
8000b8e4:	40 91       	lddsp	r1,sp[0x24]
8000b8e6:	c0 98       	rjmp	8000b8f8 <_dtoa_r+0x928>
8000b8e8:	08 9b       	mov	r11,r4
8000b8ea:	40 91       	lddsp	r1,sp[0x24]
8000b8ec:	30 09       	mov	r9,0
8000b8ee:	30 aa       	mov	r10,10
8000b8f0:	0e 9c       	mov	r12,r7
8000b8f2:	e0 a0 07 fd 	rcall	8000c8ec <__multadd>
8000b8f6:	18 94       	mov	r4,r12
8000b8f8:	58 01       	cp.w	r1,0
8000b8fa:	5f a9       	srle	r9
8000b8fc:	40 cb       	lddsp	r11,sp[0x30]
8000b8fe:	58 2b       	cp.w	r11,2
8000b900:	5f 98       	srgt	r8
8000b902:	f3 e8 00 08 	and	r8,r9,r8
8000b906:	c2 50       	breq	8000b950 <_dtoa_r+0x980>
8000b908:	58 01       	cp.w	r1,0
8000b90a:	c1 11       	brne	8000b92c <_dtoa_r+0x95c>
8000b90c:	04 9b       	mov	r11,r2
8000b90e:	02 99       	mov	r9,r1
8000b910:	30 5a       	mov	r10,5
8000b912:	0e 9c       	mov	r12,r7
8000b914:	e0 a0 07 ec 	rcall	8000c8ec <__multadd>
8000b918:	18 92       	mov	r2,r12
8000b91a:	18 9b       	mov	r11,r12
8000b91c:	06 9c       	mov	r12,r3
8000b91e:	e0 a0 05 f8 	rcall	8000c50e <__mcmp>
8000b922:	e0 89 00 0f 	brgt	8000b940 <_dtoa_r+0x970>
8000b926:	c0 38       	rjmp	8000b92c <_dtoa_r+0x95c>
8000b928:	30 02       	mov	r2,0
8000b92a:	04 94       	mov	r4,r2
8000b92c:	40 ea       	lddsp	r10,sp[0x38]
8000b92e:	30 09       	mov	r9,0
8000b930:	5c da       	com	r10
8000b932:	40 85       	lddsp	r5,sp[0x20]
8000b934:	50 6a       	stdsp	sp[0x18],r10
8000b936:	50 49       	stdsp	sp[0x10],r9
8000b938:	c0 f9       	rjmp	8000bb56 <_dtoa_r+0xb86>
8000b93a:	08 92       	mov	r2,r4
8000b93c:	40 66       	lddsp	r6,sp[0x18]
8000b93e:	04 94       	mov	r4,r2
8000b940:	2f f6       	sub	r6,-1
8000b942:	50 66       	stdsp	sp[0x18],r6
8000b944:	33 18       	mov	r8,49
8000b946:	40 85       	lddsp	r5,sp[0x20]
8000b948:	0a c8       	st.b	r5++,r8
8000b94a:	30 08       	mov	r8,0
8000b94c:	50 48       	stdsp	sp[0x10],r8
8000b94e:	c0 49       	rjmp	8000bb56 <_dtoa_r+0xb86>
8000b950:	40 dc       	lddsp	r12,sp[0x34]
8000b952:	58 0c       	cp.w	r12,0
8000b954:	e0 80 00 b5 	breq	8000babe <_dtoa_r+0xaee>
8000b958:	58 05       	cp.w	r5,0
8000b95a:	e0 8a 00 08 	brle	8000b96a <_dtoa_r+0x99a>
8000b95e:	08 9b       	mov	r11,r4
8000b960:	0a 9a       	mov	r10,r5
8000b962:	0e 9c       	mov	r12,r7
8000b964:	e0 a0 06 f8 	rcall	8000c754 <__lshift>
8000b968:	18 94       	mov	r4,r12
8000b96a:	40 6b       	lddsp	r11,sp[0x18]
8000b96c:	58 0b       	cp.w	r11,0
8000b96e:	c0 31       	brne	8000b974 <_dtoa_r+0x9a4>
8000b970:	08 9c       	mov	r12,r4
8000b972:	c1 38       	rjmp	8000b998 <_dtoa_r+0x9c8>
8000b974:	68 1b       	ld.w	r11,r4[0x4]
8000b976:	0e 9c       	mov	r12,r7
8000b978:	e0 a0 05 fe 	rcall	8000c574 <_Balloc>
8000b97c:	68 4a       	ld.w	r10,r4[0x10]
8000b97e:	18 95       	mov	r5,r12
8000b980:	e8 cb ff f4 	sub	r11,r4,-12
8000b984:	2f ea       	sub	r10,-2
8000b986:	2f 4c       	sub	r12,-12
8000b988:	a3 6a       	lsl	r10,0x2
8000b98a:	fe b0 e6 50 	rcall	8000862a <memcpy>
8000b98e:	0a 9b       	mov	r11,r5
8000b990:	30 1a       	mov	r10,1
8000b992:	0e 9c       	mov	r12,r7
8000b994:	e0 a0 06 e0 	rcall	8000c754 <__lshift>
8000b998:	50 44       	stdsp	sp[0x10],r4
8000b99a:	40 3a       	lddsp	r10,sp[0xc]
8000b99c:	30 19       	mov	r9,1
8000b99e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b9a2:	18 94       	mov	r4,r12
8000b9a4:	50 da       	stdsp	sp[0x34],r10
8000b9a6:	40 85       	lddsp	r5,sp[0x20]
8000b9a8:	50 99       	stdsp	sp[0x24],r9
8000b9aa:	50 26       	stdsp	sp[0x8],r6
8000b9ac:	50 e1       	stdsp	sp[0x38],r1
8000b9ae:	04 9b       	mov	r11,r2
8000b9b0:	06 9c       	mov	r12,r3
8000b9b2:	fe b0 fa 7f 	rcall	8000aeb0 <quorem>
8000b9b6:	40 4b       	lddsp	r11,sp[0x10]
8000b9b8:	f8 c0 ff d0 	sub	r0,r12,-48
8000b9bc:	06 9c       	mov	r12,r3
8000b9be:	e0 a0 05 a8 	rcall	8000c50e <__mcmp>
8000b9c2:	08 9a       	mov	r10,r4
8000b9c4:	50 6c       	stdsp	sp[0x18],r12
8000b9c6:	04 9b       	mov	r11,r2
8000b9c8:	0e 9c       	mov	r12,r7
8000b9ca:	e0 a0 06 5d 	rcall	8000c684 <__mdiff>
8000b9ce:	18 91       	mov	r1,r12
8000b9d0:	78 38       	ld.w	r8,r12[0xc]
8000b9d2:	58 08       	cp.w	r8,0
8000b9d4:	c0 30       	breq	8000b9da <_dtoa_r+0xa0a>
8000b9d6:	30 16       	mov	r6,1
8000b9d8:	c0 68       	rjmp	8000b9e4 <_dtoa_r+0xa14>
8000b9da:	18 9b       	mov	r11,r12
8000b9dc:	06 9c       	mov	r12,r3
8000b9de:	e0 a0 05 98 	rcall	8000c50e <__mcmp>
8000b9e2:	18 96       	mov	r6,r12
8000b9e4:	0e 9c       	mov	r12,r7
8000b9e6:	02 9b       	mov	r11,r1
8000b9e8:	e0 a0 05 ac 	rcall	8000c540 <_Bfree>
8000b9ec:	40 cc       	lddsp	r12,sp[0x30]
8000b9ee:	ed ec 10 08 	or	r8,r6,r12
8000b9f2:	c0 d1       	brne	8000ba0c <_dtoa_r+0xa3c>
8000b9f4:	40 db       	lddsp	r11,sp[0x34]
8000b9f6:	58 0b       	cp.w	r11,0
8000b9f8:	c0 a1       	brne	8000ba0c <_dtoa_r+0xa3c>
8000b9fa:	40 26       	lddsp	r6,sp[0x8]
8000b9fc:	e0 40 00 39 	cp.w	r0,57
8000ba00:	c3 00       	breq	8000ba60 <_dtoa_r+0xa90>
8000ba02:	40 6a       	lddsp	r10,sp[0x18]
8000ba04:	58 0a       	cp.w	r10,0
8000ba06:	e0 89 00 24 	brgt	8000ba4e <_dtoa_r+0xa7e>
8000ba0a:	c2 f8       	rjmp	8000ba68 <_dtoa_r+0xa98>
8000ba0c:	40 69       	lddsp	r9,sp[0x18]
8000ba0e:	58 09       	cp.w	r9,0
8000ba10:	c0 85       	brlt	8000ba20 <_dtoa_r+0xa50>
8000ba12:	12 98       	mov	r8,r9
8000ba14:	40 cc       	lddsp	r12,sp[0x30]
8000ba16:	18 48       	or	r8,r12
8000ba18:	c1 d1       	brne	8000ba52 <_dtoa_r+0xa82>
8000ba1a:	40 db       	lddsp	r11,sp[0x34]
8000ba1c:	58 0b       	cp.w	r11,0
8000ba1e:	c1 a1       	brne	8000ba52 <_dtoa_r+0xa82>
8000ba20:	0c 99       	mov	r9,r6
8000ba22:	40 26       	lddsp	r6,sp[0x8]
8000ba24:	58 09       	cp.w	r9,0
8000ba26:	e0 8a 00 21 	brle	8000ba68 <_dtoa_r+0xa98>
8000ba2a:	06 9b       	mov	r11,r3
8000ba2c:	30 1a       	mov	r10,1
8000ba2e:	0e 9c       	mov	r12,r7
8000ba30:	e0 a0 06 92 	rcall	8000c754 <__lshift>
8000ba34:	04 9b       	mov	r11,r2
8000ba36:	18 93       	mov	r3,r12
8000ba38:	e0 a0 05 6b 	rcall	8000c50e <__mcmp>
8000ba3c:	e0 89 00 06 	brgt	8000ba48 <_dtoa_r+0xa78>
8000ba40:	c1 41       	brne	8000ba68 <_dtoa_r+0xa98>
8000ba42:	ed b0 00 00 	bld	r0,0x0
8000ba46:	c1 11       	brne	8000ba68 <_dtoa_r+0xa98>
8000ba48:	e0 40 00 39 	cp.w	r0,57
8000ba4c:	c0 a0       	breq	8000ba60 <_dtoa_r+0xa90>
8000ba4e:	2f f0       	sub	r0,-1
8000ba50:	c0 c8       	rjmp	8000ba68 <_dtoa_r+0xa98>
8000ba52:	58 06       	cp.w	r6,0
8000ba54:	e0 8a 00 0c 	brle	8000ba6c <_dtoa_r+0xa9c>
8000ba58:	40 26       	lddsp	r6,sp[0x8]
8000ba5a:	e0 40 00 39 	cp.w	r0,57
8000ba5e:	c0 41       	brne	8000ba66 <_dtoa_r+0xa96>
8000ba60:	33 98       	mov	r8,57
8000ba62:	0a c8       	st.b	r5++,r8
8000ba64:	c6 78       	rjmp	8000bb32 <_dtoa_r+0xb62>
8000ba66:	2f f0       	sub	r0,-1
8000ba68:	0a c0       	st.b	r5++,r0
8000ba6a:	c7 58       	rjmp	8000bb54 <_dtoa_r+0xb84>
8000ba6c:	0a c0       	st.b	r5++,r0
8000ba6e:	40 9a       	lddsp	r10,sp[0x24]
8000ba70:	40 e9       	lddsp	r9,sp[0x38]
8000ba72:	12 3a       	cp.w	r10,r9
8000ba74:	c4 30       	breq	8000bafa <_dtoa_r+0xb2a>
8000ba76:	06 9b       	mov	r11,r3
8000ba78:	30 09       	mov	r9,0
8000ba7a:	30 aa       	mov	r10,10
8000ba7c:	0e 9c       	mov	r12,r7
8000ba7e:	e0 a0 07 37 	rcall	8000c8ec <__multadd>
8000ba82:	40 48       	lddsp	r8,sp[0x10]
8000ba84:	18 93       	mov	r3,r12
8000ba86:	08 38       	cp.w	r8,r4
8000ba88:	c0 91       	brne	8000ba9a <_dtoa_r+0xaca>
8000ba8a:	10 9b       	mov	r11,r8
8000ba8c:	30 09       	mov	r9,0
8000ba8e:	30 aa       	mov	r10,10
8000ba90:	0e 9c       	mov	r12,r7
8000ba92:	e0 a0 07 2d 	rcall	8000c8ec <__multadd>
8000ba96:	50 4c       	stdsp	sp[0x10],r12
8000ba98:	c0 e8       	rjmp	8000bab4 <_dtoa_r+0xae4>
8000ba9a:	40 4b       	lddsp	r11,sp[0x10]
8000ba9c:	30 09       	mov	r9,0
8000ba9e:	30 aa       	mov	r10,10
8000baa0:	0e 9c       	mov	r12,r7
8000baa2:	e0 a0 07 25 	rcall	8000c8ec <__multadd>
8000baa6:	08 9b       	mov	r11,r4
8000baa8:	50 4c       	stdsp	sp[0x10],r12
8000baaa:	30 09       	mov	r9,0
8000baac:	30 aa       	mov	r10,10
8000baae:	0e 9c       	mov	r12,r7
8000bab0:	e0 a0 07 1e 	rcall	8000c8ec <__multadd>
8000bab4:	18 94       	mov	r4,r12
8000bab6:	40 9c       	lddsp	r12,sp[0x24]
8000bab8:	2f fc       	sub	r12,-1
8000baba:	50 9c       	stdsp	sp[0x24],r12
8000babc:	c7 9b       	rjmp	8000b9ae <_dtoa_r+0x9de>
8000babe:	30 18       	mov	r8,1
8000bac0:	06 90       	mov	r0,r3
8000bac2:	40 85       	lddsp	r5,sp[0x20]
8000bac4:	08 93       	mov	r3,r4
8000bac6:	0c 94       	mov	r4,r6
8000bac8:	10 96       	mov	r6,r8
8000baca:	04 9b       	mov	r11,r2
8000bacc:	00 9c       	mov	r12,r0
8000bace:	fe b0 f9 f1 	rcall	8000aeb0 <quorem>
8000bad2:	2d 0c       	sub	r12,-48
8000bad4:	0a cc       	st.b	r5++,r12
8000bad6:	02 36       	cp.w	r6,r1
8000bad8:	c0 a4       	brge	8000baec <_dtoa_r+0xb1c>
8000bada:	00 9b       	mov	r11,r0
8000badc:	30 09       	mov	r9,0
8000bade:	30 aa       	mov	r10,10
8000bae0:	0e 9c       	mov	r12,r7
8000bae2:	2f f6       	sub	r6,-1
8000bae4:	e0 a0 07 04 	rcall	8000c8ec <__multadd>
8000bae8:	18 90       	mov	r0,r12
8000baea:	cf 0b       	rjmp	8000baca <_dtoa_r+0xafa>
8000baec:	08 96       	mov	r6,r4
8000baee:	30 0b       	mov	r11,0
8000baf0:	06 94       	mov	r4,r3
8000baf2:	50 4b       	stdsp	sp[0x10],r11
8000baf4:	00 93       	mov	r3,r0
8000baf6:	18 90       	mov	r0,r12
8000baf8:	c0 28       	rjmp	8000bafc <_dtoa_r+0xb2c>
8000bafa:	40 26       	lddsp	r6,sp[0x8]
8000bafc:	06 9b       	mov	r11,r3
8000bafe:	30 1a       	mov	r10,1
8000bb00:	0e 9c       	mov	r12,r7
8000bb02:	e0 a0 06 29 	rcall	8000c754 <__lshift>
8000bb06:	04 9b       	mov	r11,r2
8000bb08:	18 93       	mov	r3,r12
8000bb0a:	e0 a0 05 02 	rcall	8000c50e <__mcmp>
8000bb0e:	e0 89 00 12 	brgt	8000bb32 <_dtoa_r+0xb62>
8000bb12:	c1 b1       	brne	8000bb48 <_dtoa_r+0xb78>
8000bb14:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bb18:	c0 d1       	brne	8000bb32 <_dtoa_r+0xb62>
8000bb1a:	c1 78       	rjmp	8000bb48 <_dtoa_r+0xb78>
8000bb1c:	40 89       	lddsp	r9,sp[0x20]
8000bb1e:	12 38       	cp.w	r8,r9
8000bb20:	c0 30       	breq	8000bb26 <_dtoa_r+0xb56>
8000bb22:	10 95       	mov	r5,r8
8000bb24:	c0 88       	rjmp	8000bb34 <_dtoa_r+0xb64>
8000bb26:	2f f6       	sub	r6,-1
8000bb28:	50 66       	stdsp	sp[0x18],r6
8000bb2a:	33 18       	mov	r8,49
8000bb2c:	40 8c       	lddsp	r12,sp[0x20]
8000bb2e:	b8 88       	st.b	r12[0x0],r8
8000bb30:	c1 38       	rjmp	8000bb56 <_dtoa_r+0xb86>
8000bb32:	33 9a       	mov	r10,57
8000bb34:	0a 98       	mov	r8,r5
8000bb36:	11 79       	ld.ub	r9,--r8
8000bb38:	f4 09 18 00 	cp.b	r9,r10
8000bb3c:	cf 00       	breq	8000bb1c <_dtoa_r+0xb4c>
8000bb3e:	2f f9       	sub	r9,-1
8000bb40:	b0 89       	st.b	r8[0x0],r9
8000bb42:	c0 98       	rjmp	8000bb54 <_dtoa_r+0xb84>
8000bb44:	10 95       	mov	r5,r8
8000bb46:	c0 28       	rjmp	8000bb4a <_dtoa_r+0xb7a>
8000bb48:	33 09       	mov	r9,48
8000bb4a:	0a 98       	mov	r8,r5
8000bb4c:	11 7a       	ld.ub	r10,--r8
8000bb4e:	f2 0a 18 00 	cp.b	r10,r9
8000bb52:	cf 90       	breq	8000bb44 <_dtoa_r+0xb74>
8000bb54:	50 66       	stdsp	sp[0x18],r6
8000bb56:	04 9b       	mov	r11,r2
8000bb58:	0e 9c       	mov	r12,r7
8000bb5a:	e0 a0 04 f3 	rcall	8000c540 <_Bfree>
8000bb5e:	58 04       	cp.w	r4,0
8000bb60:	c1 20       	breq	8000bb84 <_dtoa_r+0xbb4>
8000bb62:	40 4b       	lddsp	r11,sp[0x10]
8000bb64:	08 3b       	cp.w	r11,r4
8000bb66:	5f 19       	srne	r9
8000bb68:	58 0b       	cp.w	r11,0
8000bb6a:	5f 18       	srne	r8
8000bb6c:	f3 e8 00 08 	and	r8,r9,r8
8000bb70:	c0 40       	breq	8000bb78 <_dtoa_r+0xba8>
8000bb72:	0e 9c       	mov	r12,r7
8000bb74:	e0 a0 04 e6 	rcall	8000c540 <_Bfree>
8000bb78:	08 9b       	mov	r11,r4
8000bb7a:	0e 9c       	mov	r12,r7
8000bb7c:	e0 a0 04 e2 	rcall	8000c540 <_Bfree>
8000bb80:	c0 28       	rjmp	8000bb84 <_dtoa_r+0xbb4>
8000bb82:	50 66       	stdsp	sp[0x18],r6
8000bb84:	0e 9c       	mov	r12,r7
8000bb86:	06 9b       	mov	r11,r3
8000bb88:	e0 a0 04 dc 	rcall	8000c540 <_Bfree>
8000bb8c:	30 08       	mov	r8,0
8000bb8e:	aa 88       	st.b	r5[0x0],r8
8000bb90:	40 68       	lddsp	r8,sp[0x18]
8000bb92:	41 5a       	lddsp	r10,sp[0x54]
8000bb94:	2f f8       	sub	r8,-1
8000bb96:	41 29       	lddsp	r9,sp[0x48]
8000bb98:	95 08       	st.w	r10[0x0],r8
8000bb9a:	40 8c       	lddsp	r12,sp[0x20]
8000bb9c:	58 09       	cp.w	r9,0
8000bb9e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bba2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bba6:	2e 6d       	sub	sp,-104
8000bba8:	d8 32       	popm	r0-r7,pc
8000bbaa:	d7 03       	nop

8000bbac <__errno>:
8000bbac:	e0 68 0a 50 	mov	r8,2640
8000bbb0:	70 0c       	ld.w	r12,r8[0x0]
8000bbb2:	2f 4c       	sub	r12,-12
8000bbb4:	5e fc       	retal	r12
8000bbb6:	d7 03       	nop

8000bbb8 <_fflush_r>:
8000bbb8:	d4 21       	pushm	r4-r7,lr
8000bbba:	16 97       	mov	r7,r11
8000bbbc:	18 96       	mov	r6,r12
8000bbbe:	76 48       	ld.w	r8,r11[0x10]
8000bbc0:	58 08       	cp.w	r8,0
8000bbc2:	c7 f0       	breq	8000bcc0 <_fflush_r+0x108>
8000bbc4:	58 0c       	cp.w	r12,0
8000bbc6:	c0 50       	breq	8000bbd0 <_fflush_r+0x18>
8000bbc8:	78 68       	ld.w	r8,r12[0x18]
8000bbca:	58 08       	cp.w	r8,0
8000bbcc:	c0 21       	brne	8000bbd0 <_fflush_r+0x18>
8000bbce:	cc dc       	rcall	8000bd68 <__sinit>
8000bbd0:	fe c8 c9 e4 	sub	r8,pc,-13852
8000bbd4:	10 37       	cp.w	r7,r8
8000bbd6:	c0 31       	brne	8000bbdc <_fflush_r+0x24>
8000bbd8:	6c 07       	ld.w	r7,r6[0x0]
8000bbda:	c0 c8       	rjmp	8000bbf2 <_fflush_r+0x3a>
8000bbdc:	fe c8 c9 d0 	sub	r8,pc,-13872
8000bbe0:	10 37       	cp.w	r7,r8
8000bbe2:	c0 31       	brne	8000bbe8 <_fflush_r+0x30>
8000bbe4:	6c 17       	ld.w	r7,r6[0x4]
8000bbe6:	c0 68       	rjmp	8000bbf2 <_fflush_r+0x3a>
8000bbe8:	fe c8 c9 bc 	sub	r8,pc,-13892
8000bbec:	10 37       	cp.w	r7,r8
8000bbee:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bbf2:	8e 6a       	ld.sh	r10,r7[0xc]
8000bbf4:	14 98       	mov	r8,r10
8000bbf6:	ed ba 00 03 	bld	r10,0x3
8000bbfa:	c4 20       	breq	8000bc7e <_fflush_r+0xc6>
8000bbfc:	ab ba       	sbr	r10,0xb
8000bbfe:	ae 6a       	st.h	r7[0xc],r10
8000bc00:	6e 18       	ld.w	r8,r7[0x4]
8000bc02:	58 08       	cp.w	r8,0
8000bc04:	e0 89 00 06 	brgt	8000bc10 <_fflush_r+0x58>
8000bc08:	6f 08       	ld.w	r8,r7[0x40]
8000bc0a:	58 08       	cp.w	r8,0
8000bc0c:	e0 8a 00 5a 	brle	8000bcc0 <_fflush_r+0x108>
8000bc10:	6e b8       	ld.w	r8,r7[0x2c]
8000bc12:	58 08       	cp.w	r8,0
8000bc14:	c5 60       	breq	8000bcc0 <_fflush_r+0x108>
8000bc16:	e2 1a 10 00 	andl	r10,0x1000,COH
8000bc1a:	c0 30       	breq	8000bc20 <_fflush_r+0x68>
8000bc1c:	6f 55       	ld.w	r5,r7[0x54]
8000bc1e:	c0 f8       	rjmp	8000bc3c <_fflush_r+0x84>
8000bc20:	30 19       	mov	r9,1
8000bc22:	6e 8b       	ld.w	r11,r7[0x20]
8000bc24:	0c 9c       	mov	r12,r6
8000bc26:	5d 18       	icall	r8
8000bc28:	18 95       	mov	r5,r12
8000bc2a:	5b fc       	cp.w	r12,-1
8000bc2c:	c0 81       	brne	8000bc3c <_fflush_r+0x84>
8000bc2e:	6c 38       	ld.w	r8,r6[0xc]
8000bc30:	59 d8       	cp.w	r8,29
8000bc32:	c4 70       	breq	8000bcc0 <_fflush_r+0x108>
8000bc34:	8e 68       	ld.sh	r8,r7[0xc]
8000bc36:	a7 a8       	sbr	r8,0x6
8000bc38:	ae 68       	st.h	r7[0xc],r8
8000bc3a:	d8 22       	popm	r4-r7,pc
8000bc3c:	8e 68       	ld.sh	r8,r7[0xc]
8000bc3e:	ed b8 00 02 	bld	r8,0x2
8000bc42:	c0 91       	brne	8000bc54 <_fflush_r+0x9c>
8000bc44:	6e 18       	ld.w	r8,r7[0x4]
8000bc46:	10 15       	sub	r5,r8
8000bc48:	6e d8       	ld.w	r8,r7[0x34]
8000bc4a:	58 08       	cp.w	r8,0
8000bc4c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000bc50:	eb d8 e1 15 	subne	r5,r5,r8
8000bc54:	6e b8       	ld.w	r8,r7[0x2c]
8000bc56:	0c 9c       	mov	r12,r6
8000bc58:	30 09       	mov	r9,0
8000bc5a:	0a 9a       	mov	r10,r5
8000bc5c:	6e 8b       	ld.w	r11,r7[0x20]
8000bc5e:	5d 18       	icall	r8
8000bc60:	8e 68       	ld.sh	r8,r7[0xc]
8000bc62:	0a 3c       	cp.w	r12,r5
8000bc64:	c2 61       	brne	8000bcb0 <_fflush_r+0xf8>
8000bc66:	ab d8       	cbr	r8,0xb
8000bc68:	30 0c       	mov	r12,0
8000bc6a:	6e 49       	ld.w	r9,r7[0x10]
8000bc6c:	ae 68       	st.h	r7[0xc],r8
8000bc6e:	8f 1c       	st.w	r7[0x4],r12
8000bc70:	8f 09       	st.w	r7[0x0],r9
8000bc72:	ed b8 00 0c 	bld	r8,0xc
8000bc76:	c2 51       	brne	8000bcc0 <_fflush_r+0x108>
8000bc78:	ef 45 00 54 	st.w	r7[84],r5
8000bc7c:	d8 22       	popm	r4-r7,pc
8000bc7e:	6e 45       	ld.w	r5,r7[0x10]
8000bc80:	58 05       	cp.w	r5,0
8000bc82:	c1 f0       	breq	8000bcc0 <_fflush_r+0x108>
8000bc84:	6e 04       	ld.w	r4,r7[0x0]
8000bc86:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000bc8a:	8f 05       	st.w	r7[0x0],r5
8000bc8c:	f9 b8 01 00 	movne	r8,0
8000bc90:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000bc94:	0a 14       	sub	r4,r5
8000bc96:	8f 28       	st.w	r7[0x8],r8
8000bc98:	c1 18       	rjmp	8000bcba <_fflush_r+0x102>
8000bc9a:	08 99       	mov	r9,r4
8000bc9c:	0a 9a       	mov	r10,r5
8000bc9e:	6e a8       	ld.w	r8,r7[0x28]
8000bca0:	6e 8b       	ld.w	r11,r7[0x20]
8000bca2:	0c 9c       	mov	r12,r6
8000bca4:	5d 18       	icall	r8
8000bca6:	18 14       	sub	r4,r12
8000bca8:	58 0c       	cp.w	r12,0
8000bcaa:	e0 89 00 07 	brgt	8000bcb8 <_fflush_r+0x100>
8000bcae:	8e 68       	ld.sh	r8,r7[0xc]
8000bcb0:	a7 a8       	sbr	r8,0x6
8000bcb2:	3f fc       	mov	r12,-1
8000bcb4:	ae 68       	st.h	r7[0xc],r8
8000bcb6:	d8 22       	popm	r4-r7,pc
8000bcb8:	18 05       	add	r5,r12
8000bcba:	58 04       	cp.w	r4,0
8000bcbc:	fe 99 ff ef 	brgt	8000bc9a <_fflush_r+0xe2>
8000bcc0:	d8 2a       	popm	r4-r7,pc,r12=0
8000bcc2:	d7 03       	nop

8000bcc4 <__sfp_lock_acquire>:
8000bcc4:	5e fc       	retal	r12

8000bcc6 <__sfp_lock_release>:
8000bcc6:	5e fc       	retal	r12

8000bcc8 <_cleanup_r>:
8000bcc8:	d4 01       	pushm	lr
8000bcca:	fe cb f0 ae 	sub	r11,pc,-3922
8000bcce:	e0 a0 02 f7 	rcall	8000c2bc <_fwalk>
8000bcd2:	d8 02       	popm	pc

8000bcd4 <__sfmoreglue>:
8000bcd4:	d4 21       	pushm	r4-r7,lr
8000bcd6:	16 95       	mov	r5,r11
8000bcd8:	f6 06 10 5c 	mul	r6,r11,92
8000bcdc:	ec cb ff f4 	sub	r11,r6,-12
8000bce0:	fe b0 e2 76 	rcall	800081cc <_malloc_r>
8000bce4:	18 97       	mov	r7,r12
8000bce6:	c0 90       	breq	8000bcf8 <__sfmoreglue+0x24>
8000bce8:	99 15       	st.w	r12[0x4],r5
8000bcea:	30 0b       	mov	r11,0
8000bcec:	2f 4c       	sub	r12,-12
8000bcee:	0c 9a       	mov	r10,r6
8000bcf0:	8f 2c       	st.w	r7[0x8],r12
8000bcf2:	8f 0b       	st.w	r7[0x0],r11
8000bcf4:	fe b0 e5 3f 	rcall	80008772 <memset>
8000bcf8:	0e 9c       	mov	r12,r7
8000bcfa:	d8 22       	popm	r4-r7,pc

8000bcfc <__sfp>:
8000bcfc:	d4 21       	pushm	r4-r7,lr
8000bcfe:	fe c8 ca ae 	sub	r8,pc,-13650
8000bd02:	18 96       	mov	r6,r12
8000bd04:	70 07       	ld.w	r7,r8[0x0]
8000bd06:	6e 68       	ld.w	r8,r7[0x18]
8000bd08:	58 08       	cp.w	r8,0
8000bd0a:	c0 31       	brne	8000bd10 <__sfp+0x14>
8000bd0c:	0e 9c       	mov	r12,r7
8000bd0e:	c2 dc       	rcall	8000bd68 <__sinit>
8000bd10:	ee c7 ff 28 	sub	r7,r7,-216
8000bd14:	30 05       	mov	r5,0
8000bd16:	6e 2c       	ld.w	r12,r7[0x8]
8000bd18:	6e 18       	ld.w	r8,r7[0x4]
8000bd1a:	c0 68       	rjmp	8000bd26 <__sfp+0x2a>
8000bd1c:	98 69       	ld.sh	r9,r12[0xc]
8000bd1e:	ea 09 19 00 	cp.h	r9,r5
8000bd22:	c1 10       	breq	8000bd44 <__sfp+0x48>
8000bd24:	2a 4c       	sub	r12,-92
8000bd26:	20 18       	sub	r8,1
8000bd28:	cf a7       	brpl	8000bd1c <__sfp+0x20>
8000bd2a:	6e 08       	ld.w	r8,r7[0x0]
8000bd2c:	58 08       	cp.w	r8,0
8000bd2e:	c0 61       	brne	8000bd3a <__sfp+0x3e>
8000bd30:	30 4b       	mov	r11,4
8000bd32:	0c 9c       	mov	r12,r6
8000bd34:	cd 0f       	rcall	8000bcd4 <__sfmoreglue>
8000bd36:	8f 0c       	st.w	r7[0x0],r12
8000bd38:	c0 30       	breq	8000bd3e <__sfp+0x42>
8000bd3a:	6e 07       	ld.w	r7,r7[0x0]
8000bd3c:	ce db       	rjmp	8000bd16 <__sfp+0x1a>
8000bd3e:	30 c8       	mov	r8,12
8000bd40:	8d 38       	st.w	r6[0xc],r8
8000bd42:	d8 22       	popm	r4-r7,pc
8000bd44:	30 08       	mov	r8,0
8000bd46:	f9 48 00 4c 	st.w	r12[76],r8
8000bd4a:	99 08       	st.w	r12[0x0],r8
8000bd4c:	99 28       	st.w	r12[0x8],r8
8000bd4e:	99 18       	st.w	r12[0x4],r8
8000bd50:	99 48       	st.w	r12[0x10],r8
8000bd52:	99 58       	st.w	r12[0x14],r8
8000bd54:	99 68       	st.w	r12[0x18],r8
8000bd56:	99 d8       	st.w	r12[0x34],r8
8000bd58:	99 e8       	st.w	r12[0x38],r8
8000bd5a:	f9 48 00 48 	st.w	r12[72],r8
8000bd5e:	3f f8       	mov	r8,-1
8000bd60:	b8 78       	st.h	r12[0xe],r8
8000bd62:	30 18       	mov	r8,1
8000bd64:	b8 68       	st.h	r12[0xc],r8
8000bd66:	d8 22       	popm	r4-r7,pc

8000bd68 <__sinit>:
8000bd68:	d4 21       	pushm	r4-r7,lr
8000bd6a:	18 96       	mov	r6,r12
8000bd6c:	78 67       	ld.w	r7,r12[0x18]
8000bd6e:	58 07       	cp.w	r7,0
8000bd70:	c4 91       	brne	8000be02 <__sinit+0x9a>
8000bd72:	fe c8 00 aa 	sub	r8,pc,170
8000bd76:	30 15       	mov	r5,1
8000bd78:	99 a8       	st.w	r12[0x28],r8
8000bd7a:	f9 47 00 d8 	st.w	r12[216],r7
8000bd7e:	f9 47 00 dc 	st.w	r12[220],r7
8000bd82:	f9 47 00 e0 	st.w	r12[224],r7
8000bd86:	99 65       	st.w	r12[0x18],r5
8000bd88:	cb af       	rcall	8000bcfc <__sfp>
8000bd8a:	8d 0c       	st.w	r6[0x0],r12
8000bd8c:	0c 9c       	mov	r12,r6
8000bd8e:	cb 7f       	rcall	8000bcfc <__sfp>
8000bd90:	8d 1c       	st.w	r6[0x4],r12
8000bd92:	0c 9c       	mov	r12,r6
8000bd94:	cb 4f       	rcall	8000bcfc <__sfp>
8000bd96:	6c 09       	ld.w	r9,r6[0x0]
8000bd98:	30 48       	mov	r8,4
8000bd9a:	93 07       	st.w	r9[0x0],r7
8000bd9c:	b2 68       	st.h	r9[0xc],r8
8000bd9e:	93 17       	st.w	r9[0x4],r7
8000bda0:	93 27       	st.w	r9[0x8],r7
8000bda2:	6c 18       	ld.w	r8,r6[0x4]
8000bda4:	b2 77       	st.h	r9[0xe],r7
8000bda6:	93 47       	st.w	r9[0x10],r7
8000bda8:	93 57       	st.w	r9[0x14],r7
8000bdaa:	93 67       	st.w	r9[0x18],r7
8000bdac:	93 89       	st.w	r9[0x20],r9
8000bdae:	91 07       	st.w	r8[0x0],r7
8000bdb0:	91 17       	st.w	r8[0x4],r7
8000bdb2:	91 27       	st.w	r8[0x8],r7
8000bdb4:	fe ce f3 24 	sub	lr,pc,-3292
8000bdb8:	fe cb f3 54 	sub	r11,pc,-3244
8000bdbc:	93 9e       	st.w	r9[0x24],lr
8000bdbe:	93 ab       	st.w	r9[0x28],r11
8000bdc0:	fe ca f3 7c 	sub	r10,pc,-3204
8000bdc4:	fe c4 f3 88 	sub	r4,pc,-3192
8000bdc8:	93 ba       	st.w	r9[0x2c],r10
8000bdca:	93 c4       	st.w	r9[0x30],r4
8000bdcc:	30 99       	mov	r9,9
8000bdce:	b0 69       	st.h	r8[0xc],r9
8000bdd0:	b0 75       	st.h	r8[0xe],r5
8000bdd2:	91 c4       	st.w	r8[0x30],r4
8000bdd4:	91 47       	st.w	r8[0x10],r7
8000bdd6:	91 57       	st.w	r8[0x14],r7
8000bdd8:	91 67       	st.w	r8[0x18],r7
8000bdda:	91 88       	st.w	r8[0x20],r8
8000bddc:	91 9e       	st.w	r8[0x24],lr
8000bdde:	91 ab       	st.w	r8[0x28],r11
8000bde0:	91 ba       	st.w	r8[0x2c],r10
8000bde2:	8d 2c       	st.w	r6[0x8],r12
8000bde4:	31 28       	mov	r8,18
8000bde6:	99 07       	st.w	r12[0x0],r7
8000bde8:	b8 68       	st.h	r12[0xc],r8
8000bdea:	99 17       	st.w	r12[0x4],r7
8000bdec:	99 27       	st.w	r12[0x8],r7
8000bdee:	30 28       	mov	r8,2
8000bdf0:	b8 78       	st.h	r12[0xe],r8
8000bdf2:	99 c4       	st.w	r12[0x30],r4
8000bdf4:	99 67       	st.w	r12[0x18],r7
8000bdf6:	99 9e       	st.w	r12[0x24],lr
8000bdf8:	99 ab       	st.w	r12[0x28],r11
8000bdfa:	99 ba       	st.w	r12[0x2c],r10
8000bdfc:	99 47       	st.w	r12[0x10],r7
8000bdfe:	99 57       	st.w	r12[0x14],r7
8000be00:	99 8c       	st.w	r12[0x20],r12
8000be02:	d8 22       	popm	r4-r7,pc

8000be04 <_malloc_trim_r>:
8000be04:	d4 21       	pushm	r4-r7,lr
8000be06:	16 95       	mov	r5,r11
8000be08:	18 97       	mov	r7,r12
8000be0a:	fe b0 d7 8b 	rcall	80006d20 <__malloc_lock>
8000be0e:	e0 64 05 50 	mov	r4,1360
8000be12:	68 28       	ld.w	r8,r4[0x8]
8000be14:	70 16       	ld.w	r6,r8[0x4]
8000be16:	e0 16 ff fc 	andl	r6,0xfffc
8000be1a:	ec c8 ff 91 	sub	r8,r6,-111
8000be1e:	f0 05 01 05 	sub	r5,r8,r5
8000be22:	e0 15 ff 80 	andl	r5,0xff80
8000be26:	ea c5 00 80 	sub	r5,r5,128
8000be2a:	e0 45 00 7f 	cp.w	r5,127
8000be2e:	e0 8a 00 25 	brle	8000be78 <_malloc_trim_r+0x74>
8000be32:	30 0b       	mov	r11,0
8000be34:	0e 9c       	mov	r12,r7
8000be36:	fe b0 e6 05 	rcall	80008a40 <_sbrk_r>
8000be3a:	68 28       	ld.w	r8,r4[0x8]
8000be3c:	0c 08       	add	r8,r6
8000be3e:	10 3c       	cp.w	r12,r8
8000be40:	c1 c1       	brne	8000be78 <_malloc_trim_r+0x74>
8000be42:	ea 0b 11 00 	rsub	r11,r5,0
8000be46:	0e 9c       	mov	r12,r7
8000be48:	fe b0 e5 fc 	rcall	80008a40 <_sbrk_r>
8000be4c:	5b fc       	cp.w	r12,-1
8000be4e:	c1 91       	brne	8000be80 <_malloc_trim_r+0x7c>
8000be50:	30 0b       	mov	r11,0
8000be52:	0e 9c       	mov	r12,r7
8000be54:	fe b0 e5 f6 	rcall	80008a40 <_sbrk_r>
8000be58:	68 28       	ld.w	r8,r4[0x8]
8000be5a:	f8 08 01 09 	sub	r9,r12,r8
8000be5e:	58 f9       	cp.w	r9,15
8000be60:	e0 8a 00 0c 	brle	8000be78 <_malloc_trim_r+0x74>
8000be64:	a1 a9       	sbr	r9,0x0
8000be66:	91 19       	st.w	r8[0x4],r9
8000be68:	e0 68 09 5c 	mov	r8,2396
8000be6c:	70 09       	ld.w	r9,r8[0x0]
8000be6e:	e0 68 0d e8 	mov	r8,3560
8000be72:	f8 09 01 09 	sub	r9,r12,r9
8000be76:	91 09       	st.w	r8[0x0],r9
8000be78:	0e 9c       	mov	r12,r7
8000be7a:	fe b0 d7 59 	rcall	80006d2c <__malloc_unlock>
8000be7e:	d8 2a       	popm	r4-r7,pc,r12=0
8000be80:	68 28       	ld.w	r8,r4[0x8]
8000be82:	0a 16       	sub	r6,r5
8000be84:	a1 a6       	sbr	r6,0x0
8000be86:	91 16       	st.w	r8[0x4],r6
8000be88:	e0 68 0d e8 	mov	r8,3560
8000be8c:	70 09       	ld.w	r9,r8[0x0]
8000be8e:	0a 19       	sub	r9,r5
8000be90:	0e 9c       	mov	r12,r7
8000be92:	91 09       	st.w	r8[0x0],r9
8000be94:	fe b0 d7 4c 	rcall	80006d2c <__malloc_unlock>
8000be98:	da 2a       	popm	r4-r7,pc,r12=1
8000be9a:	d7 03       	nop

8000be9c <_free_r>:
8000be9c:	d4 21       	pushm	r4-r7,lr
8000be9e:	16 96       	mov	r6,r11
8000bea0:	18 97       	mov	r7,r12
8000bea2:	58 0b       	cp.w	r11,0
8000bea4:	e0 80 00 c0 	breq	8000c024 <_free_r+0x188>
8000bea8:	fe b0 d7 3c 	rcall	80006d20 <__malloc_lock>
8000beac:	20 86       	sub	r6,8
8000beae:	e0 6a 05 50 	mov	r10,1360
8000beb2:	6c 18       	ld.w	r8,r6[0x4]
8000beb4:	74 2e       	ld.w	lr,r10[0x8]
8000beb6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000beba:	a1 c8       	cbr	r8,0x0
8000bebc:	ec 08 00 09 	add	r9,r6,r8
8000bec0:	72 1b       	ld.w	r11,r9[0x4]
8000bec2:	e0 1b ff fc 	andl	r11,0xfffc
8000bec6:	1c 39       	cp.w	r9,lr
8000bec8:	c1 e1       	brne	8000bf04 <_free_r+0x68>
8000beca:	f6 08 00 08 	add	r8,r11,r8
8000bece:	58 0c       	cp.w	r12,0
8000bed0:	c0 81       	brne	8000bee0 <_free_r+0x44>
8000bed2:	6c 09       	ld.w	r9,r6[0x0]
8000bed4:	12 16       	sub	r6,r9
8000bed6:	12 08       	add	r8,r9
8000bed8:	6c 3b       	ld.w	r11,r6[0xc]
8000beda:	6c 29       	ld.w	r9,r6[0x8]
8000bedc:	97 29       	st.w	r11[0x8],r9
8000bede:	93 3b       	st.w	r9[0xc],r11
8000bee0:	10 99       	mov	r9,r8
8000bee2:	95 26       	st.w	r10[0x8],r6
8000bee4:	a1 a9       	sbr	r9,0x0
8000bee6:	8d 19       	st.w	r6[0x4],r9
8000bee8:	e0 69 09 58 	mov	r9,2392
8000beec:	72 09       	ld.w	r9,r9[0x0]
8000beee:	12 38       	cp.w	r8,r9
8000bef0:	c0 63       	brcs	8000befc <_free_r+0x60>
8000bef2:	e0 68 0d e4 	mov	r8,3556
8000bef6:	0e 9c       	mov	r12,r7
8000bef8:	70 0b       	ld.w	r11,r8[0x0]
8000befa:	c8 5f       	rcall	8000be04 <_malloc_trim_r>
8000befc:	0e 9c       	mov	r12,r7
8000befe:	fe b0 d7 17 	rcall	80006d2c <__malloc_unlock>
8000bf02:	d8 22       	popm	r4-r7,pc
8000bf04:	93 1b       	st.w	r9[0x4],r11
8000bf06:	58 0c       	cp.w	r12,0
8000bf08:	c0 30       	breq	8000bf0e <_free_r+0x72>
8000bf0a:	30 0c       	mov	r12,0
8000bf0c:	c1 08       	rjmp	8000bf2c <_free_r+0x90>
8000bf0e:	6c 0e       	ld.w	lr,r6[0x0]
8000bf10:	f4 c5 ff f8 	sub	r5,r10,-8
8000bf14:	1c 16       	sub	r6,lr
8000bf16:	1c 08       	add	r8,lr
8000bf18:	6c 2e       	ld.w	lr,r6[0x8]
8000bf1a:	0a 3e       	cp.w	lr,r5
8000bf1c:	f9 bc 00 01 	moveq	r12,1
8000bf20:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000bf24:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000bf28:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000bf2c:	f2 0b 00 0e 	add	lr,r9,r11
8000bf30:	7c 1e       	ld.w	lr,lr[0x4]
8000bf32:	ed be 00 00 	bld	lr,0x0
8000bf36:	c1 40       	breq	8000bf5e <_free_r+0xc2>
8000bf38:	16 08       	add	r8,r11
8000bf3a:	58 0c       	cp.w	r12,0
8000bf3c:	c0 d1       	brne	8000bf56 <_free_r+0xba>
8000bf3e:	e0 6e 05 50 	mov	lr,1360
8000bf42:	72 2b       	ld.w	r11,r9[0x8]
8000bf44:	2f 8e       	sub	lr,-8
8000bf46:	1c 3b       	cp.w	r11,lr
8000bf48:	c0 71       	brne	8000bf56 <_free_r+0xba>
8000bf4a:	97 36       	st.w	r11[0xc],r6
8000bf4c:	97 26       	st.w	r11[0x8],r6
8000bf4e:	8d 2b       	st.w	r6[0x8],r11
8000bf50:	8d 3b       	st.w	r6[0xc],r11
8000bf52:	30 1c       	mov	r12,1
8000bf54:	c0 58       	rjmp	8000bf5e <_free_r+0xc2>
8000bf56:	72 2b       	ld.w	r11,r9[0x8]
8000bf58:	72 39       	ld.w	r9,r9[0xc]
8000bf5a:	93 2b       	st.w	r9[0x8],r11
8000bf5c:	97 39       	st.w	r11[0xc],r9
8000bf5e:	10 99       	mov	r9,r8
8000bf60:	ec 08 09 08 	st.w	r6[r8],r8
8000bf64:	a1 a9       	sbr	r9,0x0
8000bf66:	8d 19       	st.w	r6[0x4],r9
8000bf68:	58 0c       	cp.w	r12,0
8000bf6a:	c5 a1       	brne	8000c01e <_free_r+0x182>
8000bf6c:	e0 48 01 ff 	cp.w	r8,511
8000bf70:	e0 8b 00 13 	brhi	8000bf96 <_free_r+0xfa>
8000bf74:	a3 98       	lsr	r8,0x3
8000bf76:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000bf7a:	72 2b       	ld.w	r11,r9[0x8]
8000bf7c:	8d 39       	st.w	r6[0xc],r9
8000bf7e:	8d 2b       	st.w	r6[0x8],r11
8000bf80:	97 36       	st.w	r11[0xc],r6
8000bf82:	93 26       	st.w	r9[0x8],r6
8000bf84:	a3 48       	asr	r8,0x2
8000bf86:	74 19       	ld.w	r9,r10[0x4]
8000bf88:	30 1b       	mov	r11,1
8000bf8a:	f6 08 09 48 	lsl	r8,r11,r8
8000bf8e:	f3 e8 10 08 	or	r8,r9,r8
8000bf92:	95 18       	st.w	r10[0x4],r8
8000bf94:	c4 58       	rjmp	8000c01e <_free_r+0x182>
8000bf96:	f0 0b 16 09 	lsr	r11,r8,0x9
8000bf9a:	58 4b       	cp.w	r11,4
8000bf9c:	e0 8b 00 06 	brhi	8000bfa8 <_free_r+0x10c>
8000bfa0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000bfa4:	2c 8b       	sub	r11,-56
8000bfa6:	c2 08       	rjmp	8000bfe6 <_free_r+0x14a>
8000bfa8:	59 4b       	cp.w	r11,20
8000bfaa:	e0 8b 00 04 	brhi	8000bfb2 <_free_r+0x116>
8000bfae:	2a 5b       	sub	r11,-91
8000bfb0:	c1 b8       	rjmp	8000bfe6 <_free_r+0x14a>
8000bfb2:	e0 4b 00 54 	cp.w	r11,84
8000bfb6:	e0 8b 00 06 	brhi	8000bfc2 <_free_r+0x126>
8000bfba:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000bfbe:	29 2b       	sub	r11,-110
8000bfc0:	c1 38       	rjmp	8000bfe6 <_free_r+0x14a>
8000bfc2:	e0 4b 01 54 	cp.w	r11,340
8000bfc6:	e0 8b 00 06 	brhi	8000bfd2 <_free_r+0x136>
8000bfca:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000bfce:	28 9b       	sub	r11,-119
8000bfd0:	c0 b8       	rjmp	8000bfe6 <_free_r+0x14a>
8000bfd2:	e0 4b 05 54 	cp.w	r11,1364
8000bfd6:	e0 88 00 05 	brls	8000bfe0 <_free_r+0x144>
8000bfda:	37 eb       	mov	r11,126
8000bfdc:	c0 58       	rjmp	8000bfe6 <_free_r+0x14a>
8000bfde:	d7 03       	nop
8000bfe0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000bfe4:	28 4b       	sub	r11,-124
8000bfe6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000bfea:	78 29       	ld.w	r9,r12[0x8]
8000bfec:	18 39       	cp.w	r9,r12
8000bfee:	c0 e1       	brne	8000c00a <_free_r+0x16e>
8000bff0:	74 18       	ld.w	r8,r10[0x4]
8000bff2:	a3 4b       	asr	r11,0x2
8000bff4:	30 1c       	mov	r12,1
8000bff6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000bffa:	f1 eb 10 0b 	or	r11,r8,r11
8000bffe:	12 98       	mov	r8,r9
8000c000:	95 1b       	st.w	r10[0x4],r11
8000c002:	c0 a8       	rjmp	8000c016 <_free_r+0x17a>
8000c004:	72 29       	ld.w	r9,r9[0x8]
8000c006:	18 39       	cp.w	r9,r12
8000c008:	c0 60       	breq	8000c014 <_free_r+0x178>
8000c00a:	72 1a       	ld.w	r10,r9[0x4]
8000c00c:	e0 1a ff fc 	andl	r10,0xfffc
8000c010:	14 38       	cp.w	r8,r10
8000c012:	cf 93       	brcs	8000c004 <_free_r+0x168>
8000c014:	72 38       	ld.w	r8,r9[0xc]
8000c016:	8d 38       	st.w	r6[0xc],r8
8000c018:	8d 29       	st.w	r6[0x8],r9
8000c01a:	93 36       	st.w	r9[0xc],r6
8000c01c:	91 26       	st.w	r8[0x8],r6
8000c01e:	0e 9c       	mov	r12,r7
8000c020:	fe b0 d6 86 	rcall	80006d2c <__malloc_unlock>
8000c024:	d8 22       	popm	r4-r7,pc
8000c026:	d7 03       	nop

8000c028 <__sfvwrite_r>:
8000c028:	d4 31       	pushm	r0-r7,lr
8000c02a:	20 3d       	sub	sp,12
8000c02c:	14 94       	mov	r4,r10
8000c02e:	18 95       	mov	r5,r12
8000c030:	16 97       	mov	r7,r11
8000c032:	74 28       	ld.w	r8,r10[0x8]
8000c034:	58 08       	cp.w	r8,0
8000c036:	e0 80 01 40 	breq	8000c2b6 <__sfvwrite_r+0x28e>
8000c03a:	96 68       	ld.sh	r8,r11[0xc]
8000c03c:	ed b8 00 03 	bld	r8,0x3
8000c040:	c0 41       	brne	8000c048 <__sfvwrite_r+0x20>
8000c042:	76 48       	ld.w	r8,r11[0x10]
8000c044:	58 08       	cp.w	r8,0
8000c046:	c0 c1       	brne	8000c05e <__sfvwrite_r+0x36>
8000c048:	0e 9b       	mov	r11,r7
8000c04a:	0a 9c       	mov	r12,r5
8000c04c:	fe b0 f6 c4 	rcall	8000add4 <__swsetup_r>
8000c050:	c0 70       	breq	8000c05e <__sfvwrite_r+0x36>
8000c052:	8e 68       	ld.sh	r8,r7[0xc]
8000c054:	a7 a8       	sbr	r8,0x6
8000c056:	ae 68       	st.h	r7[0xc],r8
8000c058:	30 98       	mov	r8,9
8000c05a:	8b 38       	st.w	r5[0xc],r8
8000c05c:	c2 b9       	rjmp	8000c2b2 <__sfvwrite_r+0x28a>
8000c05e:	8e 63       	ld.sh	r3,r7[0xc]
8000c060:	68 00       	ld.w	r0,r4[0x0]
8000c062:	06 96       	mov	r6,r3
8000c064:	e2 16 00 02 	andl	r6,0x2,COH
8000c068:	c2 10       	breq	8000c0aa <__sfvwrite_r+0x82>
8000c06a:	30 03       	mov	r3,0
8000c06c:	e0 62 04 00 	mov	r2,1024
8000c070:	06 96       	mov	r6,r3
8000c072:	c0 48       	rjmp	8000c07a <__sfvwrite_r+0x52>
8000c074:	60 03       	ld.w	r3,r0[0x0]
8000c076:	60 16       	ld.w	r6,r0[0x4]
8000c078:	2f 80       	sub	r0,-8
8000c07a:	58 06       	cp.w	r6,0
8000c07c:	cf c0       	breq	8000c074 <__sfvwrite_r+0x4c>
8000c07e:	e0 46 04 00 	cp.w	r6,1024
8000c082:	ec 09 17 80 	movls	r9,r6
8000c086:	e4 09 17 b0 	movhi	r9,r2
8000c08a:	06 9a       	mov	r10,r3
8000c08c:	6e a8       	ld.w	r8,r7[0x28]
8000c08e:	6e 8b       	ld.w	r11,r7[0x20]
8000c090:	0a 9c       	mov	r12,r5
8000c092:	5d 18       	icall	r8
8000c094:	18 16       	sub	r6,r12
8000c096:	58 0c       	cp.w	r12,0
8000c098:	e0 8a 01 0a 	brle	8000c2ac <__sfvwrite_r+0x284>
8000c09c:	68 28       	ld.w	r8,r4[0x8]
8000c09e:	18 18       	sub	r8,r12
8000c0a0:	89 28       	st.w	r4[0x8],r8
8000c0a2:	e0 80 01 0a 	breq	8000c2b6 <__sfvwrite_r+0x28e>
8000c0a6:	18 03       	add	r3,r12
8000c0a8:	ce 9b       	rjmp	8000c07a <__sfvwrite_r+0x52>
8000c0aa:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c0ae:	c0 70       	breq	8000c0bc <__sfvwrite_r+0x94>
8000c0b0:	50 06       	stdsp	sp[0x0],r6
8000c0b2:	0c 93       	mov	r3,r6
8000c0b4:	0c 91       	mov	r1,r6
8000c0b6:	50 15       	stdsp	sp[0x4],r5
8000c0b8:	08 92       	mov	r2,r4
8000c0ba:	c9 c8       	rjmp	8000c1f2 <__sfvwrite_r+0x1ca>
8000c0bc:	06 96       	mov	r6,r3
8000c0be:	08 91       	mov	r1,r4
8000c0c0:	c0 48       	rjmp	8000c0c8 <__sfvwrite_r+0xa0>
8000c0c2:	60 03       	ld.w	r3,r0[0x0]
8000c0c4:	60 16       	ld.w	r6,r0[0x4]
8000c0c6:	2f 80       	sub	r0,-8
8000c0c8:	58 06       	cp.w	r6,0
8000c0ca:	cf c0       	breq	8000c0c2 <__sfvwrite_r+0x9a>
8000c0cc:	8e 68       	ld.sh	r8,r7[0xc]
8000c0ce:	6e 24       	ld.w	r4,r7[0x8]
8000c0d0:	10 99       	mov	r9,r8
8000c0d2:	e2 19 02 00 	andl	r9,0x200,COH
8000c0d6:	c5 50       	breq	8000c180 <__sfvwrite_r+0x158>
8000c0d8:	08 36       	cp.w	r6,r4
8000c0da:	c4 43       	brcs	8000c162 <__sfvwrite_r+0x13a>
8000c0dc:	10 99       	mov	r9,r8
8000c0de:	e2 19 04 80 	andl	r9,0x480,COH
8000c0e2:	c4 00       	breq	8000c162 <__sfvwrite_r+0x13a>
8000c0e4:	6e 4b       	ld.w	r11,r7[0x10]
8000c0e6:	6e 09       	ld.w	r9,r7[0x0]
8000c0e8:	16 19       	sub	r9,r11
8000c0ea:	50 09       	stdsp	sp[0x0],r9
8000c0ec:	6e 59       	ld.w	r9,r7[0x14]
8000c0ee:	10 9c       	mov	r12,r8
8000c0f0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c0f4:	30 28       	mov	r8,2
8000c0f6:	f4 08 0c 08 	divs	r8,r10,r8
8000c0fa:	fa e9 00 04 	st.d	sp[4],r8
8000c0fe:	10 94       	mov	r4,r8
8000c100:	40 09       	lddsp	r9,sp[0x0]
8000c102:	e2 1c 04 00 	andl	r12,0x400,COH
8000c106:	2f f9       	sub	r9,-1
8000c108:	0c 09       	add	r9,r6
8000c10a:	12 38       	cp.w	r8,r9
8000c10c:	f2 04 17 30 	movlo	r4,r9
8000c110:	58 0c       	cp.w	r12,0
8000c112:	c1 10       	breq	8000c134 <__sfvwrite_r+0x10c>
8000c114:	08 9b       	mov	r11,r4
8000c116:	0a 9c       	mov	r12,r5
8000c118:	fe b0 e0 5a 	rcall	800081cc <_malloc_r>
8000c11c:	18 92       	mov	r2,r12
8000c11e:	c1 40       	breq	8000c146 <__sfvwrite_r+0x11e>
8000c120:	40 0a       	lddsp	r10,sp[0x0]
8000c122:	6e 4b       	ld.w	r11,r7[0x10]
8000c124:	fe b0 e2 83 	rcall	8000862a <memcpy>
8000c128:	8e 68       	ld.sh	r8,r7[0xc]
8000c12a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c12e:	a7 b8       	sbr	r8,0x7
8000c130:	ae 68       	st.h	r7[0xc],r8
8000c132:	c0 d8       	rjmp	8000c14c <__sfvwrite_r+0x124>
8000c134:	08 9a       	mov	r10,r4
8000c136:	0a 9c       	mov	r12,r5
8000c138:	fe b0 e3 24 	rcall	80008780 <_realloc_r>
8000c13c:	18 92       	mov	r2,r12
8000c13e:	c0 71       	brne	8000c14c <__sfvwrite_r+0x124>
8000c140:	6e 4b       	ld.w	r11,r7[0x10]
8000c142:	0a 9c       	mov	r12,r5
8000c144:	ca ce       	rcall	8000be9c <_free_r>
8000c146:	30 c8       	mov	r8,12
8000c148:	8b 38       	st.w	r5[0xc],r8
8000c14a:	cb 18       	rjmp	8000c2ac <__sfvwrite_r+0x284>
8000c14c:	40 0a       	lddsp	r10,sp[0x0]
8000c14e:	40 09       	lddsp	r9,sp[0x0]
8000c150:	e8 0a 01 0a 	sub	r10,r4,r10
8000c154:	e4 09 00 08 	add	r8,r2,r9
8000c158:	8f 54       	st.w	r7[0x14],r4
8000c15a:	8f 2a       	st.w	r7[0x8],r10
8000c15c:	8f 08       	st.w	r7[0x0],r8
8000c15e:	8f 42       	st.w	r7[0x10],r2
8000c160:	0c 94       	mov	r4,r6
8000c162:	08 36       	cp.w	r6,r4
8000c164:	ec 04 17 30 	movlo	r4,r6
8000c168:	06 9b       	mov	r11,r3
8000c16a:	08 9a       	mov	r10,r4
8000c16c:	6e 0c       	ld.w	r12,r7[0x0]
8000c16e:	c3 ad       	rcall	8000c3e2 <memmove>
8000c170:	6e 08       	ld.w	r8,r7[0x0]
8000c172:	08 08       	add	r8,r4
8000c174:	8f 08       	st.w	r7[0x0],r8
8000c176:	6e 28       	ld.w	r8,r7[0x8]
8000c178:	08 18       	sub	r8,r4
8000c17a:	0c 94       	mov	r4,r6
8000c17c:	8f 28       	st.w	r7[0x8],r8
8000c17e:	c2 e8       	rjmp	8000c1da <__sfvwrite_r+0x1b2>
8000c180:	08 36       	cp.w	r6,r4
8000c182:	5f ba       	srhi	r10
8000c184:	6e 0c       	ld.w	r12,r7[0x0]
8000c186:	6e 48       	ld.w	r8,r7[0x10]
8000c188:	10 3c       	cp.w	r12,r8
8000c18a:	5f b8       	srhi	r8
8000c18c:	f5 e8 00 08 	and	r8,r10,r8
8000c190:	f2 08 18 00 	cp.b	r8,r9
8000c194:	c0 d0       	breq	8000c1ae <__sfvwrite_r+0x186>
8000c196:	06 9b       	mov	r11,r3
8000c198:	08 9a       	mov	r10,r4
8000c19a:	c2 4d       	rcall	8000c3e2 <memmove>
8000c19c:	6e 08       	ld.w	r8,r7[0x0]
8000c19e:	08 08       	add	r8,r4
8000c1a0:	0e 9b       	mov	r11,r7
8000c1a2:	8f 08       	st.w	r7[0x0],r8
8000c1a4:	0a 9c       	mov	r12,r5
8000c1a6:	fe b0 fd 09 	rcall	8000bbb8 <_fflush_r>
8000c1aa:	c1 80       	breq	8000c1da <__sfvwrite_r+0x1b2>
8000c1ac:	c8 08       	rjmp	8000c2ac <__sfvwrite_r+0x284>
8000c1ae:	6e 59       	ld.w	r9,r7[0x14]
8000c1b0:	12 36       	cp.w	r6,r9
8000c1b2:	c0 a3       	brcs	8000c1c6 <__sfvwrite_r+0x19e>
8000c1b4:	6e a8       	ld.w	r8,r7[0x28]
8000c1b6:	06 9a       	mov	r10,r3
8000c1b8:	6e 8b       	ld.w	r11,r7[0x20]
8000c1ba:	0a 9c       	mov	r12,r5
8000c1bc:	5d 18       	icall	r8
8000c1be:	18 94       	mov	r4,r12
8000c1c0:	e0 89 00 0d 	brgt	8000c1da <__sfvwrite_r+0x1b2>
8000c1c4:	c7 48       	rjmp	8000c2ac <__sfvwrite_r+0x284>
8000c1c6:	0c 9a       	mov	r10,r6
8000c1c8:	06 9b       	mov	r11,r3
8000c1ca:	c0 cd       	rcall	8000c3e2 <memmove>
8000c1cc:	6e 08       	ld.w	r8,r7[0x0]
8000c1ce:	0c 08       	add	r8,r6
8000c1d0:	0c 94       	mov	r4,r6
8000c1d2:	8f 08       	st.w	r7[0x0],r8
8000c1d4:	6e 28       	ld.w	r8,r7[0x8]
8000c1d6:	0c 18       	sub	r8,r6
8000c1d8:	8f 28       	st.w	r7[0x8],r8
8000c1da:	62 28       	ld.w	r8,r1[0x8]
8000c1dc:	08 18       	sub	r8,r4
8000c1de:	83 28       	st.w	r1[0x8],r8
8000c1e0:	c6 b0       	breq	8000c2b6 <__sfvwrite_r+0x28e>
8000c1e2:	08 16       	sub	r6,r4
8000c1e4:	08 03       	add	r3,r4
8000c1e6:	c7 1b       	rjmp	8000c0c8 <__sfvwrite_r+0xa0>
8000c1e8:	60 03       	ld.w	r3,r0[0x0]
8000c1ea:	60 11       	ld.w	r1,r0[0x4]
8000c1ec:	30 08       	mov	r8,0
8000c1ee:	2f 80       	sub	r0,-8
8000c1f0:	50 08       	stdsp	sp[0x0],r8
8000c1f2:	58 01       	cp.w	r1,0
8000c1f4:	cf a0       	breq	8000c1e8 <__sfvwrite_r+0x1c0>
8000c1f6:	40 0a       	lddsp	r10,sp[0x0]
8000c1f8:	58 0a       	cp.w	r10,0
8000c1fa:	c1 41       	brne	8000c222 <__sfvwrite_r+0x1fa>
8000c1fc:	e2 c6 ff ff 	sub	r6,r1,-1
8000c200:	02 9a       	mov	r10,r1
8000c202:	30 ab       	mov	r11,10
8000c204:	06 9c       	mov	r12,r3
8000c206:	ce 3c       	rcall	8000c3cc <memchr>
8000c208:	f8 c8 ff ff 	sub	r8,r12,-1
8000c20c:	58 0c       	cp.w	r12,0
8000c20e:	f1 d3 e1 16 	subne	r6,r8,r3
8000c212:	f9 b9 01 01 	movne	r9,1
8000c216:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c21a:	f9 b8 00 01 	moveq	r8,1
8000c21e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c222:	02 36       	cp.w	r6,r1
8000c224:	ec 04 17 80 	movls	r4,r6
8000c228:	e2 04 17 b0 	movhi	r4,r1
8000c22c:	6e 59       	ld.w	r9,r7[0x14]
8000c22e:	6e 25       	ld.w	r5,r7[0x8]
8000c230:	f2 05 00 05 	add	r5,r9,r5
8000c234:	0a 34       	cp.w	r4,r5
8000c236:	5f 9a       	srgt	r10
8000c238:	6e 0c       	ld.w	r12,r7[0x0]
8000c23a:	6e 48       	ld.w	r8,r7[0x10]
8000c23c:	10 3c       	cp.w	r12,r8
8000c23e:	5f b8       	srhi	r8
8000c240:	f5 e8 00 08 	and	r8,r10,r8
8000c244:	30 0a       	mov	r10,0
8000c246:	f4 08 18 00 	cp.b	r8,r10
8000c24a:	c0 d0       	breq	8000c264 <__sfvwrite_r+0x23c>
8000c24c:	06 9b       	mov	r11,r3
8000c24e:	0a 9a       	mov	r10,r5
8000c250:	cc 9c       	rcall	8000c3e2 <memmove>
8000c252:	6e 08       	ld.w	r8,r7[0x0]
8000c254:	0a 08       	add	r8,r5
8000c256:	0e 9b       	mov	r11,r7
8000c258:	8f 08       	st.w	r7[0x0],r8
8000c25a:	40 1c       	lddsp	r12,sp[0x4]
8000c25c:	fe b0 fc ae 	rcall	8000bbb8 <_fflush_r>
8000c260:	c1 70       	breq	8000c28e <__sfvwrite_r+0x266>
8000c262:	c2 58       	rjmp	8000c2ac <__sfvwrite_r+0x284>
8000c264:	12 34       	cp.w	r4,r9
8000c266:	c0 a5       	brlt	8000c27a <__sfvwrite_r+0x252>
8000c268:	6e a8       	ld.w	r8,r7[0x28]
8000c26a:	06 9a       	mov	r10,r3
8000c26c:	6e 8b       	ld.w	r11,r7[0x20]
8000c26e:	40 1c       	lddsp	r12,sp[0x4]
8000c270:	5d 18       	icall	r8
8000c272:	18 95       	mov	r5,r12
8000c274:	e0 89 00 0d 	brgt	8000c28e <__sfvwrite_r+0x266>
8000c278:	c1 a8       	rjmp	8000c2ac <__sfvwrite_r+0x284>
8000c27a:	08 9a       	mov	r10,r4
8000c27c:	06 9b       	mov	r11,r3
8000c27e:	cb 2c       	rcall	8000c3e2 <memmove>
8000c280:	6e 08       	ld.w	r8,r7[0x0]
8000c282:	08 08       	add	r8,r4
8000c284:	08 95       	mov	r5,r4
8000c286:	8f 08       	st.w	r7[0x0],r8
8000c288:	6e 28       	ld.w	r8,r7[0x8]
8000c28a:	08 18       	sub	r8,r4
8000c28c:	8f 28       	st.w	r7[0x8],r8
8000c28e:	0a 16       	sub	r6,r5
8000c290:	c0 71       	brne	8000c29e <__sfvwrite_r+0x276>
8000c292:	0e 9b       	mov	r11,r7
8000c294:	40 1c       	lddsp	r12,sp[0x4]
8000c296:	fe b0 fc 91 	rcall	8000bbb8 <_fflush_r>
8000c29a:	c0 91       	brne	8000c2ac <__sfvwrite_r+0x284>
8000c29c:	50 06       	stdsp	sp[0x0],r6
8000c29e:	64 28       	ld.w	r8,r2[0x8]
8000c2a0:	0a 18       	sub	r8,r5
8000c2a2:	85 28       	st.w	r2[0x8],r8
8000c2a4:	c0 90       	breq	8000c2b6 <__sfvwrite_r+0x28e>
8000c2a6:	0a 11       	sub	r1,r5
8000c2a8:	0a 03       	add	r3,r5
8000c2aa:	ca 4b       	rjmp	8000c1f2 <__sfvwrite_r+0x1ca>
8000c2ac:	8e 68       	ld.sh	r8,r7[0xc]
8000c2ae:	a7 a8       	sbr	r8,0x6
8000c2b0:	ae 68       	st.h	r7[0xc],r8
8000c2b2:	3f fc       	mov	r12,-1
8000c2b4:	c0 28       	rjmp	8000c2b8 <__sfvwrite_r+0x290>
8000c2b6:	30 0c       	mov	r12,0
8000c2b8:	2f dd       	sub	sp,-12
8000c2ba:	d8 32       	popm	r0-r7,pc

8000c2bc <_fwalk>:
8000c2bc:	d4 31       	pushm	r0-r7,lr
8000c2be:	30 05       	mov	r5,0
8000c2c0:	16 91       	mov	r1,r11
8000c2c2:	f8 c7 ff 28 	sub	r7,r12,-216
8000c2c6:	0a 92       	mov	r2,r5
8000c2c8:	fe b0 fc fe 	rcall	8000bcc4 <__sfp_lock_acquire>
8000c2cc:	3f f3       	mov	r3,-1
8000c2ce:	c1 68       	rjmp	8000c2fa <_fwalk+0x3e>
8000c2d0:	6e 26       	ld.w	r6,r7[0x8]
8000c2d2:	6e 14       	ld.w	r4,r7[0x4]
8000c2d4:	2f 46       	sub	r6,-12
8000c2d6:	c0 c8       	rjmp	8000c2ee <_fwalk+0x32>
8000c2d8:	8c 08       	ld.sh	r8,r6[0x0]
8000c2da:	e4 08 19 00 	cp.h	r8,r2
8000c2de:	c0 70       	breq	8000c2ec <_fwalk+0x30>
8000c2e0:	8c 18       	ld.sh	r8,r6[0x2]
8000c2e2:	e6 08 19 00 	cp.h	r8,r3
8000c2e6:	c0 30       	breq	8000c2ec <_fwalk+0x30>
8000c2e8:	5d 11       	icall	r1
8000c2ea:	18 45       	or	r5,r12
8000c2ec:	2a 46       	sub	r6,-92
8000c2ee:	20 14       	sub	r4,1
8000c2f0:	ec cc 00 0c 	sub	r12,r6,12
8000c2f4:	58 04       	cp.w	r4,0
8000c2f6:	cf 14       	brge	8000c2d8 <_fwalk+0x1c>
8000c2f8:	6e 07       	ld.w	r7,r7[0x0]
8000c2fa:	58 07       	cp.w	r7,0
8000c2fc:	ce a1       	brne	8000c2d0 <_fwalk+0x14>
8000c2fe:	fe b0 fc e4 	rcall	8000bcc6 <__sfp_lock_release>
8000c302:	0a 9c       	mov	r12,r5
8000c304:	d8 32       	popm	r0-r7,pc
8000c306:	d7 03       	nop

8000c308 <_localeconv_r>:
8000c308:	fe cc d0 b4 	sub	r12,pc,-12108
8000c30c:	5e fc       	retal	r12
8000c30e:	d7 03       	nop

8000c310 <__smakebuf_r>:
8000c310:	d4 21       	pushm	r4-r7,lr
8000c312:	20 fd       	sub	sp,60
8000c314:	96 68       	ld.sh	r8,r11[0xc]
8000c316:	16 97       	mov	r7,r11
8000c318:	18 96       	mov	r6,r12
8000c31a:	e2 18 00 02 	andl	r8,0x2,COH
8000c31e:	c3 d1       	brne	8000c398 <__smakebuf_r+0x88>
8000c320:	96 7b       	ld.sh	r11,r11[0xe]
8000c322:	f0 0b 19 00 	cp.h	r11,r8
8000c326:	c0 55       	brlt	8000c330 <__smakebuf_r+0x20>
8000c328:	1a 9a       	mov	r10,sp
8000c32a:	e0 a0 04 81 	rcall	8000cc2c <_fstat_r>
8000c32e:	c0 f4       	brge	8000c34c <__smakebuf_r+0x3c>
8000c330:	8e 65       	ld.sh	r5,r7[0xc]
8000c332:	0a 98       	mov	r8,r5
8000c334:	ab b8       	sbr	r8,0xb
8000c336:	e2 15 00 80 	andl	r5,0x80,COH
8000c33a:	ae 68       	st.h	r7[0xc],r8
8000c33c:	30 04       	mov	r4,0
8000c33e:	e0 68 04 00 	mov	r8,1024
8000c342:	f9 b5 01 40 	movne	r5,64
8000c346:	f0 05 17 00 	moveq	r5,r8
8000c34a:	c1 c8       	rjmp	8000c382 <__smakebuf_r+0x72>
8000c34c:	40 18       	lddsp	r8,sp[0x4]
8000c34e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c352:	e0 48 20 00 	cp.w	r8,8192
8000c356:	5f 04       	sreq	r4
8000c358:	e0 48 80 00 	cp.w	r8,32768
8000c35c:	c0 e1       	brne	8000c378 <__smakebuf_r+0x68>
8000c35e:	6e b9       	ld.w	r9,r7[0x2c]
8000c360:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c364:	10 39       	cp.w	r9,r8
8000c366:	c0 91       	brne	8000c378 <__smakebuf_r+0x68>
8000c368:	8e 68       	ld.sh	r8,r7[0xc]
8000c36a:	e0 65 04 00 	mov	r5,1024
8000c36e:	ab a8       	sbr	r8,0xa
8000c370:	ef 45 00 50 	st.w	r7[80],r5
8000c374:	ae 68       	st.h	r7[0xc],r8
8000c376:	c0 68       	rjmp	8000c382 <__smakebuf_r+0x72>
8000c378:	8e 68       	ld.sh	r8,r7[0xc]
8000c37a:	e0 65 04 00 	mov	r5,1024
8000c37e:	ab b8       	sbr	r8,0xb
8000c380:	ae 68       	st.h	r7[0xc],r8
8000c382:	0a 9b       	mov	r11,r5
8000c384:	0c 9c       	mov	r12,r6
8000c386:	fe b0 df 23 	rcall	800081cc <_malloc_r>
8000c38a:	8e 68       	ld.sh	r8,r7[0xc]
8000c38c:	c0 d1       	brne	8000c3a6 <__smakebuf_r+0x96>
8000c38e:	ed b8 00 09 	bld	r8,0x9
8000c392:	c1 b0       	breq	8000c3c8 <__smakebuf_r+0xb8>
8000c394:	a1 b8       	sbr	r8,0x1
8000c396:	ae 68       	st.h	r7[0xc],r8
8000c398:	ee c8 ff b9 	sub	r8,r7,-71
8000c39c:	8f 48       	st.w	r7[0x10],r8
8000c39e:	8f 08       	st.w	r7[0x0],r8
8000c3a0:	30 18       	mov	r8,1
8000c3a2:	8f 58       	st.w	r7[0x14],r8
8000c3a4:	c1 28       	rjmp	8000c3c8 <__smakebuf_r+0xb8>
8000c3a6:	a7 b8       	sbr	r8,0x7
8000c3a8:	8f 4c       	st.w	r7[0x10],r12
8000c3aa:	ae 68       	st.h	r7[0xc],r8
8000c3ac:	8f 55       	st.w	r7[0x14],r5
8000c3ae:	fe c8 06 e6 	sub	r8,pc,1766
8000c3b2:	8f 0c       	st.w	r7[0x0],r12
8000c3b4:	8d a8       	st.w	r6[0x28],r8
8000c3b6:	58 04       	cp.w	r4,0
8000c3b8:	c0 80       	breq	8000c3c8 <__smakebuf_r+0xb8>
8000c3ba:	8e 7c       	ld.sh	r12,r7[0xe]
8000c3bc:	fe b0 e3 94 	rcall	80008ae4 <isatty>
8000c3c0:	c0 40       	breq	8000c3c8 <__smakebuf_r+0xb8>
8000c3c2:	8e 68       	ld.sh	r8,r7[0xc]
8000c3c4:	a1 a8       	sbr	r8,0x0
8000c3c6:	ae 68       	st.h	r7[0xc],r8
8000c3c8:	2f 1d       	sub	sp,-60
8000c3ca:	d8 22       	popm	r4-r7,pc

8000c3cc <memchr>:
8000c3cc:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c3d0:	c0 68       	rjmp	8000c3dc <memchr+0x10>
8000c3d2:	20 1a       	sub	r10,1
8000c3d4:	19 88       	ld.ub	r8,r12[0x0]
8000c3d6:	16 38       	cp.w	r8,r11
8000c3d8:	5e 0c       	reteq	r12
8000c3da:	2f fc       	sub	r12,-1
8000c3dc:	58 0a       	cp.w	r10,0
8000c3de:	cf a1       	brne	8000c3d2 <memchr+0x6>
8000c3e0:	5e fa       	retal	r10

8000c3e2 <memmove>:
8000c3e2:	d4 01       	pushm	lr
8000c3e4:	18 3b       	cp.w	r11,r12
8000c3e6:	c1 92       	brcc	8000c418 <memmove+0x36>
8000c3e8:	f6 0a 00 09 	add	r9,r11,r10
8000c3ec:	12 3c       	cp.w	r12,r9
8000c3ee:	c1 52       	brcc	8000c418 <memmove+0x36>
8000c3f0:	f8 0a 00 0b 	add	r11,r12,r10
8000c3f4:	30 08       	mov	r8,0
8000c3f6:	c0 68       	rjmp	8000c402 <memmove+0x20>
8000c3f8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c3fc:	20 1a       	sub	r10,1
8000c3fe:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c402:	20 18       	sub	r8,1
8000c404:	58 0a       	cp.w	r10,0
8000c406:	cf 91       	brne	8000c3f8 <memmove+0x16>
8000c408:	d8 02       	popm	pc
8000c40a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c40e:	20 1a       	sub	r10,1
8000c410:	f8 08 0b 09 	st.b	r12[r8],r9
8000c414:	2f f8       	sub	r8,-1
8000c416:	c0 28       	rjmp	8000c41a <memmove+0x38>
8000c418:	30 08       	mov	r8,0
8000c41a:	58 0a       	cp.w	r10,0
8000c41c:	cf 71       	brne	8000c40a <memmove+0x28>
8000c41e:	d8 02       	popm	pc

8000c420 <__hi0bits>:
8000c420:	18 98       	mov	r8,r12
8000c422:	e0 1c 00 00 	andl	r12,0x0
8000c426:	f0 09 15 10 	lsl	r9,r8,0x10
8000c42a:	58 0c       	cp.w	r12,0
8000c42c:	f2 08 17 00 	moveq	r8,r9
8000c430:	f9 bc 00 10 	moveq	r12,16
8000c434:	f9 bc 01 00 	movne	r12,0
8000c438:	10 9a       	mov	r10,r8
8000c43a:	f0 09 15 08 	lsl	r9,r8,0x8
8000c43e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c442:	f7 bc 00 f8 	subeq	r12,-8
8000c446:	f2 08 17 00 	moveq	r8,r9
8000c44a:	10 9a       	mov	r10,r8
8000c44c:	f0 09 15 04 	lsl	r9,r8,0x4
8000c450:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c454:	f7 bc 00 fc 	subeq	r12,-4
8000c458:	f2 08 17 00 	moveq	r8,r9
8000c45c:	10 9a       	mov	r10,r8
8000c45e:	f0 09 15 02 	lsl	r9,r8,0x2
8000c462:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c466:	f7 bc 00 fe 	subeq	r12,-2
8000c46a:	f2 08 17 00 	moveq	r8,r9
8000c46e:	58 08       	cp.w	r8,0
8000c470:	5e 5c       	retlt	r12
8000c472:	ed b8 00 1e 	bld	r8,0x1e
8000c476:	f9 bc 01 20 	movne	r12,32
8000c47a:	f7 bc 00 ff 	subeq	r12,-1
8000c47e:	5e fc       	retal	r12

8000c480 <__lo0bits>:
8000c480:	18 99       	mov	r9,r12
8000c482:	78 08       	ld.w	r8,r12[0x0]
8000c484:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c488:	c1 50       	breq	8000c4b2 <__lo0bits+0x32>
8000c48a:	ed b8 00 00 	bld	r8,0x0
8000c48e:	c0 21       	brne	8000c492 <__lo0bits+0x12>
8000c490:	5e fd       	retal	0
8000c492:	10 9b       	mov	r11,r8
8000c494:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c498:	e2 1b 00 02 	andl	r11,0x2,COH
8000c49c:	a3 88       	lsr	r8,0x2
8000c49e:	58 0b       	cp.w	r11,0
8000c4a0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c4a4:	f9 bc 01 01 	movne	r12,1
8000c4a8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c4ac:	f9 bc 00 02 	moveq	r12,2
8000c4b0:	5e fc       	retal	r12
8000c4b2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c4b6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c4ba:	58 0a       	cp.w	r10,0
8000c4bc:	f6 08 17 00 	moveq	r8,r11
8000c4c0:	f9 bc 00 10 	moveq	r12,16
8000c4c4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c4c8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c4cc:	58 0b       	cp.w	r11,0
8000c4ce:	f7 bc 00 f8 	subeq	r12,-8
8000c4d2:	f4 08 17 00 	moveq	r8,r10
8000c4d6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c4da:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c4de:	58 0b       	cp.w	r11,0
8000c4e0:	f7 bc 00 fc 	subeq	r12,-4
8000c4e4:	f4 08 17 00 	moveq	r8,r10
8000c4e8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c4ec:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c4f0:	58 0b       	cp.w	r11,0
8000c4f2:	f7 bc 00 fe 	subeq	r12,-2
8000c4f6:	f4 08 17 00 	moveq	r8,r10
8000c4fa:	ed b8 00 00 	bld	r8,0x0
8000c4fe:	c0 60       	breq	8000c50a <__lo0bits+0x8a>
8000c500:	a1 98       	lsr	r8,0x1
8000c502:	c0 31       	brne	8000c508 <__lo0bits+0x88>
8000c504:	32 0c       	mov	r12,32
8000c506:	5e fc       	retal	r12
8000c508:	2f fc       	sub	r12,-1
8000c50a:	93 08       	st.w	r9[0x0],r8
8000c50c:	5e fc       	retal	r12

8000c50e <__mcmp>:
8000c50e:	d4 01       	pushm	lr
8000c510:	18 98       	mov	r8,r12
8000c512:	76 49       	ld.w	r9,r11[0x10]
8000c514:	78 4c       	ld.w	r12,r12[0x10]
8000c516:	12 1c       	sub	r12,r9
8000c518:	c1 31       	brne	8000c53e <__mcmp+0x30>
8000c51a:	2f b9       	sub	r9,-5
8000c51c:	a3 69       	lsl	r9,0x2
8000c51e:	12 0b       	add	r11,r9
8000c520:	f0 09 00 09 	add	r9,r8,r9
8000c524:	2e c8       	sub	r8,-20
8000c526:	13 4e       	ld.w	lr,--r9
8000c528:	17 4a       	ld.w	r10,--r11
8000c52a:	14 3e       	cp.w	lr,r10
8000c52c:	c0 60       	breq	8000c538 <__mcmp+0x2a>
8000c52e:	f9 bc 03 ff 	movlo	r12,-1
8000c532:	f9 bc 02 01 	movhs	r12,1
8000c536:	d8 02       	popm	pc
8000c538:	10 39       	cp.w	r9,r8
8000c53a:	fe 9b ff f6 	brhi	8000c526 <__mcmp+0x18>
8000c53e:	d8 02       	popm	pc

8000c540 <_Bfree>:
8000c540:	d4 21       	pushm	r4-r7,lr
8000c542:	18 97       	mov	r7,r12
8000c544:	16 95       	mov	r5,r11
8000c546:	78 96       	ld.w	r6,r12[0x24]
8000c548:	58 06       	cp.w	r6,0
8000c54a:	c0 91       	brne	8000c55c <_Bfree+0x1c>
8000c54c:	31 0c       	mov	r12,16
8000c54e:	fe b0 de 37 	rcall	800081bc <malloc>
8000c552:	99 36       	st.w	r12[0xc],r6
8000c554:	8f 9c       	st.w	r7[0x24],r12
8000c556:	99 16       	st.w	r12[0x4],r6
8000c558:	99 26       	st.w	r12[0x8],r6
8000c55a:	99 06       	st.w	r12[0x0],r6
8000c55c:	58 05       	cp.w	r5,0
8000c55e:	c0 90       	breq	8000c570 <_Bfree+0x30>
8000c560:	6a 19       	ld.w	r9,r5[0x4]
8000c562:	6e 98       	ld.w	r8,r7[0x24]
8000c564:	70 38       	ld.w	r8,r8[0xc]
8000c566:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c56a:	8b 0a       	st.w	r5[0x0],r10
8000c56c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c570:	d8 22       	popm	r4-r7,pc
8000c572:	d7 03       	nop

8000c574 <_Balloc>:
8000c574:	d4 21       	pushm	r4-r7,lr
8000c576:	18 97       	mov	r7,r12
8000c578:	16 96       	mov	r6,r11
8000c57a:	78 95       	ld.w	r5,r12[0x24]
8000c57c:	58 05       	cp.w	r5,0
8000c57e:	c0 91       	brne	8000c590 <_Balloc+0x1c>
8000c580:	31 0c       	mov	r12,16
8000c582:	fe b0 de 1d 	rcall	800081bc <malloc>
8000c586:	99 35       	st.w	r12[0xc],r5
8000c588:	8f 9c       	st.w	r7[0x24],r12
8000c58a:	99 15       	st.w	r12[0x4],r5
8000c58c:	99 25       	st.w	r12[0x8],r5
8000c58e:	99 05       	st.w	r12[0x0],r5
8000c590:	6e 95       	ld.w	r5,r7[0x24]
8000c592:	6a 38       	ld.w	r8,r5[0xc]
8000c594:	58 08       	cp.w	r8,0
8000c596:	c0 b1       	brne	8000c5ac <_Balloc+0x38>
8000c598:	31 0a       	mov	r10,16
8000c59a:	30 4b       	mov	r11,4
8000c59c:	0e 9c       	mov	r12,r7
8000c59e:	e0 a0 02 a7 	rcall	8000caec <_calloc_r>
8000c5a2:	8b 3c       	st.w	r5[0xc],r12
8000c5a4:	6e 98       	ld.w	r8,r7[0x24]
8000c5a6:	70 3c       	ld.w	r12,r8[0xc]
8000c5a8:	58 0c       	cp.w	r12,0
8000c5aa:	c1 b0       	breq	8000c5e0 <_Balloc+0x6c>
8000c5ac:	6e 98       	ld.w	r8,r7[0x24]
8000c5ae:	70 38       	ld.w	r8,r8[0xc]
8000c5b0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c5b4:	70 0c       	ld.w	r12,r8[0x0]
8000c5b6:	58 0c       	cp.w	r12,0
8000c5b8:	c0 40       	breq	8000c5c0 <_Balloc+0x4c>
8000c5ba:	78 09       	ld.w	r9,r12[0x0]
8000c5bc:	91 09       	st.w	r8[0x0],r9
8000c5be:	c0 e8       	rjmp	8000c5da <_Balloc+0x66>
8000c5c0:	0e 9c       	mov	r12,r7
8000c5c2:	30 17       	mov	r7,1
8000c5c4:	0e 9b       	mov	r11,r7
8000c5c6:	ee 06 09 47 	lsl	r7,r7,r6
8000c5ca:	ee ca ff fb 	sub	r10,r7,-5
8000c5ce:	a3 6a       	lsl	r10,0x2
8000c5d0:	e0 a0 02 8e 	rcall	8000caec <_calloc_r>
8000c5d4:	c0 60       	breq	8000c5e0 <_Balloc+0x6c>
8000c5d6:	99 16       	st.w	r12[0x4],r6
8000c5d8:	99 27       	st.w	r12[0x8],r7
8000c5da:	30 08       	mov	r8,0
8000c5dc:	99 38       	st.w	r12[0xc],r8
8000c5de:	99 48       	st.w	r12[0x10],r8
8000c5e0:	d8 22       	popm	r4-r7,pc
8000c5e2:	d7 03       	nop

8000c5e4 <__d2b>:
8000c5e4:	d4 31       	pushm	r0-r7,lr
8000c5e6:	20 2d       	sub	sp,8
8000c5e8:	16 93       	mov	r3,r11
8000c5ea:	12 96       	mov	r6,r9
8000c5ec:	10 95       	mov	r5,r8
8000c5ee:	14 92       	mov	r2,r10
8000c5f0:	30 1b       	mov	r11,1
8000c5f2:	cc 1f       	rcall	8000c574 <_Balloc>
8000c5f4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c5f8:	50 09       	stdsp	sp[0x0],r9
8000c5fa:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c5fe:	b5 a9       	sbr	r9,0x14
8000c600:	f0 01 16 14 	lsr	r1,r8,0x14
8000c604:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c608:	18 94       	mov	r4,r12
8000c60a:	58 02       	cp.w	r2,0
8000c60c:	c1 d0       	breq	8000c646 <__d2b+0x62>
8000c60e:	fa cc ff f8 	sub	r12,sp,-8
8000c612:	18 d2       	st.w	--r12,r2
8000c614:	c3 6f       	rcall	8000c480 <__lo0bits>
8000c616:	40 18       	lddsp	r8,sp[0x4]
8000c618:	c0 d0       	breq	8000c632 <__d2b+0x4e>
8000c61a:	40 09       	lddsp	r9,sp[0x0]
8000c61c:	f8 0a 11 20 	rsub	r10,r12,32
8000c620:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c624:	f5 e8 10 08 	or	r8,r10,r8
8000c628:	89 58       	st.w	r4[0x14],r8
8000c62a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c62e:	50 09       	stdsp	sp[0x0],r9
8000c630:	c0 28       	rjmp	8000c634 <__d2b+0x50>
8000c632:	89 58       	st.w	r4[0x14],r8
8000c634:	40 08       	lddsp	r8,sp[0x0]
8000c636:	58 08       	cp.w	r8,0
8000c638:	f9 b3 01 02 	movne	r3,2
8000c63c:	f9 b3 00 01 	moveq	r3,1
8000c640:	89 68       	st.w	r4[0x18],r8
8000c642:	89 43       	st.w	r4[0x10],r3
8000c644:	c0 88       	rjmp	8000c654 <__d2b+0x70>
8000c646:	1a 9c       	mov	r12,sp
8000c648:	c1 cf       	rcall	8000c480 <__lo0bits>
8000c64a:	30 13       	mov	r3,1
8000c64c:	40 08       	lddsp	r8,sp[0x0]
8000c64e:	2e 0c       	sub	r12,-32
8000c650:	89 43       	st.w	r4[0x10],r3
8000c652:	89 58       	st.w	r4[0x14],r8
8000c654:	58 01       	cp.w	r1,0
8000c656:	c0 90       	breq	8000c668 <__d2b+0x84>
8000c658:	e2 c1 04 33 	sub	r1,r1,1075
8000c65c:	18 01       	add	r1,r12
8000c65e:	8d 01       	st.w	r6[0x0],r1
8000c660:	f8 0c 11 35 	rsub	r12,r12,53
8000c664:	8b 0c       	st.w	r5[0x0],r12
8000c666:	c0 c8       	rjmp	8000c67e <__d2b+0x9a>
8000c668:	e6 c8 ff fc 	sub	r8,r3,-4
8000c66c:	f8 cc 04 32 	sub	r12,r12,1074
8000c670:	a5 73       	lsl	r3,0x5
8000c672:	8d 0c       	st.w	r6[0x0],r12
8000c674:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c678:	cd 4e       	rcall	8000c420 <__hi0bits>
8000c67a:	18 13       	sub	r3,r12
8000c67c:	8b 03       	st.w	r5[0x0],r3
8000c67e:	08 9c       	mov	r12,r4
8000c680:	2f ed       	sub	sp,-8
8000c682:	d8 32       	popm	r0-r7,pc

8000c684 <__mdiff>:
8000c684:	d4 31       	pushm	r0-r7,lr
8000c686:	74 48       	ld.w	r8,r10[0x10]
8000c688:	76 45       	ld.w	r5,r11[0x10]
8000c68a:	16 97       	mov	r7,r11
8000c68c:	14 96       	mov	r6,r10
8000c68e:	10 15       	sub	r5,r8
8000c690:	c1 31       	brne	8000c6b6 <__mdiff+0x32>
8000c692:	2f b8       	sub	r8,-5
8000c694:	ee ce ff ec 	sub	lr,r7,-20
8000c698:	a3 68       	lsl	r8,0x2
8000c69a:	f4 08 00 0b 	add	r11,r10,r8
8000c69e:	ee 08 00 08 	add	r8,r7,r8
8000c6a2:	11 4a       	ld.w	r10,--r8
8000c6a4:	17 49       	ld.w	r9,--r11
8000c6a6:	12 3a       	cp.w	r10,r9
8000c6a8:	c0 30       	breq	8000c6ae <__mdiff+0x2a>
8000c6aa:	c0 e2       	brcc	8000c6c6 <__mdiff+0x42>
8000c6ac:	c0 78       	rjmp	8000c6ba <__mdiff+0x36>
8000c6ae:	1c 38       	cp.w	r8,lr
8000c6b0:	fe 9b ff f9 	brhi	8000c6a2 <__mdiff+0x1e>
8000c6b4:	c4 98       	rjmp	8000c746 <__mdiff+0xc2>
8000c6b6:	58 05       	cp.w	r5,0
8000c6b8:	c0 64       	brge	8000c6c4 <__mdiff+0x40>
8000c6ba:	0e 98       	mov	r8,r7
8000c6bc:	30 15       	mov	r5,1
8000c6be:	0c 97       	mov	r7,r6
8000c6c0:	10 96       	mov	r6,r8
8000c6c2:	c0 28       	rjmp	8000c6c6 <__mdiff+0x42>
8000c6c4:	30 05       	mov	r5,0
8000c6c6:	6e 1b       	ld.w	r11,r7[0x4]
8000c6c8:	c5 6f       	rcall	8000c574 <_Balloc>
8000c6ca:	6e 49       	ld.w	r9,r7[0x10]
8000c6cc:	6c 44       	ld.w	r4,r6[0x10]
8000c6ce:	99 35       	st.w	r12[0xc],r5
8000c6d0:	2f b4       	sub	r4,-5
8000c6d2:	f2 c5 ff fb 	sub	r5,r9,-5
8000c6d6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c6da:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c6de:	2e c6       	sub	r6,-20
8000c6e0:	2e c7       	sub	r7,-20
8000c6e2:	f8 c8 ff ec 	sub	r8,r12,-20
8000c6e6:	30 0a       	mov	r10,0
8000c6e8:	0f 0e       	ld.w	lr,r7++
8000c6ea:	0d 0b       	ld.w	r11,r6++
8000c6ec:	fc 02 16 10 	lsr	r2,lr,0x10
8000c6f0:	f6 03 16 10 	lsr	r3,r11,0x10
8000c6f4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c6f8:	e4 03 01 03 	sub	r3,r2,r3
8000c6fc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c700:	fc 0b 01 0b 	sub	r11,lr,r11
8000c704:	f6 0a 00 0a 	add	r10,r11,r10
8000c708:	b0 1a       	st.h	r8[0x2],r10
8000c70a:	b1 4a       	asr	r10,0x10
8000c70c:	e6 0a 00 0a 	add	r10,r3,r10
8000c710:	b0 0a       	st.h	r8[0x0],r10
8000c712:	2f c8       	sub	r8,-4
8000c714:	b1 4a       	asr	r10,0x10
8000c716:	08 36       	cp.w	r6,r4
8000c718:	ce 83       	brcs	8000c6e8 <__mdiff+0x64>
8000c71a:	c0 d8       	rjmp	8000c734 <__mdiff+0xb0>
8000c71c:	0f 0b       	ld.w	r11,r7++
8000c71e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c722:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c726:	16 0a       	add	r10,r11
8000c728:	b0 1a       	st.h	r8[0x2],r10
8000c72a:	b1 4a       	asr	r10,0x10
8000c72c:	1c 0a       	add	r10,lr
8000c72e:	b0 0a       	st.h	r8[0x0],r10
8000c730:	2f c8       	sub	r8,-4
8000c732:	b1 4a       	asr	r10,0x10
8000c734:	0a 37       	cp.w	r7,r5
8000c736:	cf 33       	brcs	8000c71c <__mdiff+0x98>
8000c738:	c0 28       	rjmp	8000c73c <__mdiff+0xb8>
8000c73a:	20 19       	sub	r9,1
8000c73c:	11 4a       	ld.w	r10,--r8
8000c73e:	58 0a       	cp.w	r10,0
8000c740:	cf d0       	breq	8000c73a <__mdiff+0xb6>
8000c742:	99 49       	st.w	r12[0x10],r9
8000c744:	d8 32       	popm	r0-r7,pc
8000c746:	30 0b       	mov	r11,0
8000c748:	c1 6f       	rcall	8000c574 <_Balloc>
8000c74a:	30 18       	mov	r8,1
8000c74c:	99 48       	st.w	r12[0x10],r8
8000c74e:	30 08       	mov	r8,0
8000c750:	99 58       	st.w	r12[0x14],r8
8000c752:	d8 32       	popm	r0-r7,pc

8000c754 <__lshift>:
8000c754:	d4 31       	pushm	r0-r7,lr
8000c756:	16 97       	mov	r7,r11
8000c758:	76 46       	ld.w	r6,r11[0x10]
8000c75a:	f4 02 14 05 	asr	r2,r10,0x5
8000c75e:	2f f6       	sub	r6,-1
8000c760:	14 93       	mov	r3,r10
8000c762:	18 94       	mov	r4,r12
8000c764:	04 06       	add	r6,r2
8000c766:	76 1b       	ld.w	r11,r11[0x4]
8000c768:	6e 28       	ld.w	r8,r7[0x8]
8000c76a:	c0 38       	rjmp	8000c770 <__lshift+0x1c>
8000c76c:	2f fb       	sub	r11,-1
8000c76e:	a1 78       	lsl	r8,0x1
8000c770:	10 36       	cp.w	r6,r8
8000c772:	fe 99 ff fd 	brgt	8000c76c <__lshift+0x18>
8000c776:	08 9c       	mov	r12,r4
8000c778:	cf ee       	rcall	8000c574 <_Balloc>
8000c77a:	30 09       	mov	r9,0
8000c77c:	18 95       	mov	r5,r12
8000c77e:	f8 c8 ff ec 	sub	r8,r12,-20
8000c782:	12 9a       	mov	r10,r9
8000c784:	c0 38       	rjmp	8000c78a <__lshift+0x36>
8000c786:	10 aa       	st.w	r8++,r10
8000c788:	2f f9       	sub	r9,-1
8000c78a:	04 39       	cp.w	r9,r2
8000c78c:	cf d5       	brlt	8000c786 <__lshift+0x32>
8000c78e:	6e 4b       	ld.w	r11,r7[0x10]
8000c790:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c794:	2f bb       	sub	r11,-5
8000c796:	ee c9 ff ec 	sub	r9,r7,-20
8000c79a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c79e:	58 03       	cp.w	r3,0
8000c7a0:	c1 30       	breq	8000c7c6 <__lshift+0x72>
8000c7a2:	e6 0c 11 20 	rsub	r12,r3,32
8000c7a6:	30 0a       	mov	r10,0
8000c7a8:	72 02       	ld.w	r2,r9[0x0]
8000c7aa:	e4 03 09 42 	lsl	r2,r2,r3
8000c7ae:	04 4a       	or	r10,r2
8000c7b0:	10 aa       	st.w	r8++,r10
8000c7b2:	13 0a       	ld.w	r10,r9++
8000c7b4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c7b8:	16 39       	cp.w	r9,r11
8000c7ba:	cf 73       	brcs	8000c7a8 <__lshift+0x54>
8000c7bc:	91 0a       	st.w	r8[0x0],r10
8000c7be:	58 0a       	cp.w	r10,0
8000c7c0:	c0 70       	breq	8000c7ce <__lshift+0x7a>
8000c7c2:	2f f6       	sub	r6,-1
8000c7c4:	c0 58       	rjmp	8000c7ce <__lshift+0x7a>
8000c7c6:	13 0a       	ld.w	r10,r9++
8000c7c8:	10 aa       	st.w	r8++,r10
8000c7ca:	16 39       	cp.w	r9,r11
8000c7cc:	cf d3       	brcs	8000c7c6 <__lshift+0x72>
8000c7ce:	08 9c       	mov	r12,r4
8000c7d0:	20 16       	sub	r6,1
8000c7d2:	0e 9b       	mov	r11,r7
8000c7d4:	8b 46       	st.w	r5[0x10],r6
8000c7d6:	cb 5e       	rcall	8000c540 <_Bfree>
8000c7d8:	0a 9c       	mov	r12,r5
8000c7da:	d8 32       	popm	r0-r7,pc

8000c7dc <__multiply>:
8000c7dc:	d4 31       	pushm	r0-r7,lr
8000c7de:	20 2d       	sub	sp,8
8000c7e0:	76 49       	ld.w	r9,r11[0x10]
8000c7e2:	74 48       	ld.w	r8,r10[0x10]
8000c7e4:	16 96       	mov	r6,r11
8000c7e6:	14 95       	mov	r5,r10
8000c7e8:	10 39       	cp.w	r9,r8
8000c7ea:	ec 08 17 50 	movlt	r8,r6
8000c7ee:	ea 06 17 50 	movlt	r6,r5
8000c7f2:	f0 05 17 50 	movlt	r5,r8
8000c7f6:	6c 28       	ld.w	r8,r6[0x8]
8000c7f8:	76 43       	ld.w	r3,r11[0x10]
8000c7fa:	74 42       	ld.w	r2,r10[0x10]
8000c7fc:	76 1b       	ld.w	r11,r11[0x4]
8000c7fe:	e4 03 00 07 	add	r7,r2,r3
8000c802:	10 37       	cp.w	r7,r8
8000c804:	f7 bb 09 ff 	subgt	r11,-1
8000c808:	cb 6e       	rcall	8000c574 <_Balloc>
8000c80a:	ee c4 ff fb 	sub	r4,r7,-5
8000c80e:	f8 c9 ff ec 	sub	r9,r12,-20
8000c812:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c816:	30 0a       	mov	r10,0
8000c818:	12 98       	mov	r8,r9
8000c81a:	c0 28       	rjmp	8000c81e <__multiply+0x42>
8000c81c:	10 aa       	st.w	r8++,r10
8000c81e:	08 38       	cp.w	r8,r4
8000c820:	cf e3       	brcs	8000c81c <__multiply+0x40>
8000c822:	2f b3       	sub	r3,-5
8000c824:	2f b2       	sub	r2,-5
8000c826:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c82a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c82e:	ec cb ff ec 	sub	r11,r6,-20
8000c832:	50 12       	stdsp	sp[0x4],r2
8000c834:	ea ca ff ec 	sub	r10,r5,-20
8000c838:	c4 48       	rjmp	8000c8c0 <__multiply+0xe4>
8000c83a:	94 95       	ld.uh	r5,r10[0x2]
8000c83c:	58 05       	cp.w	r5,0
8000c83e:	c2 00       	breq	8000c87e <__multiply+0xa2>
8000c840:	12 98       	mov	r8,r9
8000c842:	16 96       	mov	r6,r11
8000c844:	30 0e       	mov	lr,0
8000c846:	50 09       	stdsp	sp[0x0],r9
8000c848:	0d 02       	ld.w	r2,r6++
8000c84a:	e4 00 16 10 	lsr	r0,r2,0x10
8000c84e:	70 01       	ld.w	r1,r8[0x0]
8000c850:	70 09       	ld.w	r9,r8[0x0]
8000c852:	b1 81       	lsr	r1,0x10
8000c854:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c858:	e0 05 03 41 	mac	r1,r0,r5
8000c85c:	ab 32       	mul	r2,r5
8000c85e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c862:	00 02       	add	r2,r0
8000c864:	e4 0e 00 0e 	add	lr,r2,lr
8000c868:	b0 1e       	st.h	r8[0x2],lr
8000c86a:	b1 8e       	lsr	lr,0x10
8000c86c:	1c 01       	add	r1,lr
8000c86e:	b0 01       	st.h	r8[0x0],r1
8000c870:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c874:	2f c8       	sub	r8,-4
8000c876:	06 36       	cp.w	r6,r3
8000c878:	ce 83       	brcs	8000c848 <__multiply+0x6c>
8000c87a:	40 09       	lddsp	r9,sp[0x0]
8000c87c:	91 0e       	st.w	r8[0x0],lr
8000c87e:	94 86       	ld.uh	r6,r10[0x0]
8000c880:	58 06       	cp.w	r6,0
8000c882:	c1 d0       	breq	8000c8bc <__multiply+0xe0>
8000c884:	72 02       	ld.w	r2,r9[0x0]
8000c886:	12 98       	mov	r8,r9
8000c888:	16 9e       	mov	lr,r11
8000c88a:	30 05       	mov	r5,0
8000c88c:	b0 12       	st.h	r8[0x2],r2
8000c88e:	1d 01       	ld.w	r1,lr++
8000c890:	90 82       	ld.uh	r2,r8[0x0]
8000c892:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c896:	ad 30       	mul	r0,r6
8000c898:	e0 02 00 02 	add	r2,r0,r2
8000c89c:	e4 05 00 05 	add	r5,r2,r5
8000c8a0:	b0 05       	st.h	r8[0x0],r5
8000c8a2:	b1 85       	lsr	r5,0x10
8000c8a4:	b1 81       	lsr	r1,0x10
8000c8a6:	2f c8       	sub	r8,-4
8000c8a8:	ad 31       	mul	r1,r6
8000c8aa:	90 92       	ld.uh	r2,r8[0x2]
8000c8ac:	e2 02 00 02 	add	r2,r1,r2
8000c8b0:	0a 02       	add	r2,r5
8000c8b2:	e4 05 16 10 	lsr	r5,r2,0x10
8000c8b6:	06 3e       	cp.w	lr,r3
8000c8b8:	ce a3       	brcs	8000c88c <__multiply+0xb0>
8000c8ba:	91 02       	st.w	r8[0x0],r2
8000c8bc:	2f ca       	sub	r10,-4
8000c8be:	2f c9       	sub	r9,-4
8000c8c0:	40 18       	lddsp	r8,sp[0x4]
8000c8c2:	10 3a       	cp.w	r10,r8
8000c8c4:	cb b3       	brcs	8000c83a <__multiply+0x5e>
8000c8c6:	c0 28       	rjmp	8000c8ca <__multiply+0xee>
8000c8c8:	20 17       	sub	r7,1
8000c8ca:	58 07       	cp.w	r7,0
8000c8cc:	e0 8a 00 05 	brle	8000c8d6 <__multiply+0xfa>
8000c8d0:	09 48       	ld.w	r8,--r4
8000c8d2:	58 08       	cp.w	r8,0
8000c8d4:	cf a0       	breq	8000c8c8 <__multiply+0xec>
8000c8d6:	99 47       	st.w	r12[0x10],r7
8000c8d8:	2f ed       	sub	sp,-8
8000c8da:	d8 32       	popm	r0-r7,pc

8000c8dc <__i2b>:
8000c8dc:	d4 21       	pushm	r4-r7,lr
8000c8de:	16 97       	mov	r7,r11
8000c8e0:	30 1b       	mov	r11,1
8000c8e2:	c4 9e       	rcall	8000c574 <_Balloc>
8000c8e4:	30 19       	mov	r9,1
8000c8e6:	99 57       	st.w	r12[0x14],r7
8000c8e8:	99 49       	st.w	r12[0x10],r9
8000c8ea:	d8 22       	popm	r4-r7,pc

8000c8ec <__multadd>:
8000c8ec:	d4 31       	pushm	r0-r7,lr
8000c8ee:	30 08       	mov	r8,0
8000c8f0:	12 95       	mov	r5,r9
8000c8f2:	16 97       	mov	r7,r11
8000c8f4:	18 96       	mov	r6,r12
8000c8f6:	76 44       	ld.w	r4,r11[0x10]
8000c8f8:	f6 c9 ff ec 	sub	r9,r11,-20
8000c8fc:	72 0b       	ld.w	r11,r9[0x0]
8000c8fe:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c902:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c906:	f4 0c 02 4c 	mul	r12,r10,r12
8000c90a:	f4 0b 03 45 	mac	r5,r10,r11
8000c90e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c912:	b1 85       	lsr	r5,0x10
8000c914:	18 05       	add	r5,r12
8000c916:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c91a:	f8 0b 00 0b 	add	r11,r12,r11
8000c91e:	12 ab       	st.w	r9++,r11
8000c920:	2f f8       	sub	r8,-1
8000c922:	b1 85       	lsr	r5,0x10
8000c924:	08 38       	cp.w	r8,r4
8000c926:	ce b5       	brlt	8000c8fc <__multadd+0x10>
8000c928:	58 05       	cp.w	r5,0
8000c92a:	c1 c0       	breq	8000c962 <__multadd+0x76>
8000c92c:	6e 28       	ld.w	r8,r7[0x8]
8000c92e:	10 34       	cp.w	r4,r8
8000c930:	c1 35       	brlt	8000c956 <__multadd+0x6a>
8000c932:	6e 1b       	ld.w	r11,r7[0x4]
8000c934:	0c 9c       	mov	r12,r6
8000c936:	2f fb       	sub	r11,-1
8000c938:	c1 ee       	rcall	8000c574 <_Balloc>
8000c93a:	6e 4a       	ld.w	r10,r7[0x10]
8000c93c:	ee cb ff f4 	sub	r11,r7,-12
8000c940:	18 93       	mov	r3,r12
8000c942:	2f ea       	sub	r10,-2
8000c944:	2f 4c       	sub	r12,-12
8000c946:	a3 6a       	lsl	r10,0x2
8000c948:	fe b0 de 71 	rcall	8000862a <memcpy>
8000c94c:	0e 9b       	mov	r11,r7
8000c94e:	0c 9c       	mov	r12,r6
8000c950:	fe b0 fd f8 	rcall	8000c540 <_Bfree>
8000c954:	06 97       	mov	r7,r3
8000c956:	e8 c8 ff ff 	sub	r8,r4,-1
8000c95a:	2f b4       	sub	r4,-5
8000c95c:	8f 48       	st.w	r7[0x10],r8
8000c95e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c962:	0e 9c       	mov	r12,r7
8000c964:	d8 32       	popm	r0-r7,pc
8000c966:	d7 03       	nop

8000c968 <__pow5mult>:
8000c968:	d4 31       	pushm	r0-r7,lr
8000c96a:	14 96       	mov	r6,r10
8000c96c:	18 97       	mov	r7,r12
8000c96e:	16 94       	mov	r4,r11
8000c970:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c974:	c0 90       	breq	8000c986 <__pow5mult+0x1e>
8000c976:	20 18       	sub	r8,1
8000c978:	fe c9 d6 e8 	sub	r9,pc,-10520
8000c97c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c980:	30 09       	mov	r9,0
8000c982:	cb 5f       	rcall	8000c8ec <__multadd>
8000c984:	18 94       	mov	r4,r12
8000c986:	a3 46       	asr	r6,0x2
8000c988:	c3 40       	breq	8000c9f0 <__pow5mult+0x88>
8000c98a:	6e 95       	ld.w	r5,r7[0x24]
8000c98c:	58 05       	cp.w	r5,0
8000c98e:	c0 91       	brne	8000c9a0 <__pow5mult+0x38>
8000c990:	31 0c       	mov	r12,16
8000c992:	fe b0 dc 15 	rcall	800081bc <malloc>
8000c996:	99 35       	st.w	r12[0xc],r5
8000c998:	8f 9c       	st.w	r7[0x24],r12
8000c99a:	99 15       	st.w	r12[0x4],r5
8000c99c:	99 25       	st.w	r12[0x8],r5
8000c99e:	99 05       	st.w	r12[0x0],r5
8000c9a0:	6e 93       	ld.w	r3,r7[0x24]
8000c9a2:	66 25       	ld.w	r5,r3[0x8]
8000c9a4:	58 05       	cp.w	r5,0
8000c9a6:	c0 c1       	brne	8000c9be <__pow5mult+0x56>
8000c9a8:	e0 6b 02 71 	mov	r11,625
8000c9ac:	0e 9c       	mov	r12,r7
8000c9ae:	c9 7f       	rcall	8000c8dc <__i2b>
8000c9b0:	87 2c       	st.w	r3[0x8],r12
8000c9b2:	30 08       	mov	r8,0
8000c9b4:	18 95       	mov	r5,r12
8000c9b6:	99 08       	st.w	r12[0x0],r8
8000c9b8:	c0 38       	rjmp	8000c9be <__pow5mult+0x56>
8000c9ba:	06 9c       	mov	r12,r3
8000c9bc:	18 95       	mov	r5,r12
8000c9be:	ed b6 00 00 	bld	r6,0x0
8000c9c2:	c0 b1       	brne	8000c9d8 <__pow5mult+0x70>
8000c9c4:	08 9b       	mov	r11,r4
8000c9c6:	0a 9a       	mov	r10,r5
8000c9c8:	0e 9c       	mov	r12,r7
8000c9ca:	c0 9f       	rcall	8000c7dc <__multiply>
8000c9cc:	08 9b       	mov	r11,r4
8000c9ce:	18 93       	mov	r3,r12
8000c9d0:	0e 9c       	mov	r12,r7
8000c9d2:	06 94       	mov	r4,r3
8000c9d4:	fe b0 fd b6 	rcall	8000c540 <_Bfree>
8000c9d8:	a1 56       	asr	r6,0x1
8000c9da:	c0 b0       	breq	8000c9f0 <__pow5mult+0x88>
8000c9dc:	6a 03       	ld.w	r3,r5[0x0]
8000c9de:	58 03       	cp.w	r3,0
8000c9e0:	ce d1       	brne	8000c9ba <__pow5mult+0x52>
8000c9e2:	0a 9a       	mov	r10,r5
8000c9e4:	0a 9b       	mov	r11,r5
8000c9e6:	0e 9c       	mov	r12,r7
8000c9e8:	cf ae       	rcall	8000c7dc <__multiply>
8000c9ea:	8b 0c       	st.w	r5[0x0],r12
8000c9ec:	99 03       	st.w	r12[0x0],r3
8000c9ee:	ce 7b       	rjmp	8000c9bc <__pow5mult+0x54>
8000c9f0:	08 9c       	mov	r12,r4
8000c9f2:	d8 32       	popm	r0-r7,pc

8000c9f4 <__isinfd>:
8000c9f4:	14 98       	mov	r8,r10
8000c9f6:	fc 19 7f f0 	movh	r9,0x7ff0
8000c9fa:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c9fe:	f0 0b 11 00 	rsub	r11,r8,0
8000ca02:	f7 e8 10 08 	or	r8,r11,r8
8000ca06:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ca0a:	f2 08 01 08 	sub	r8,r9,r8
8000ca0e:	f0 0c 11 00 	rsub	r12,r8,0
8000ca12:	f9 e8 10 08 	or	r8,r12,r8
8000ca16:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ca1a:	2f fc       	sub	r12,-1
8000ca1c:	5e fc       	retal	r12

8000ca1e <__isnand>:
8000ca1e:	14 98       	mov	r8,r10
8000ca20:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ca24:	f0 0c 11 00 	rsub	r12,r8,0
8000ca28:	10 4c       	or	r12,r8
8000ca2a:	fc 18 7f f0 	movh	r8,0x7ff0
8000ca2e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ca32:	f0 0c 01 0c 	sub	r12,r8,r12
8000ca36:	bf 9c       	lsr	r12,0x1f
8000ca38:	5e fc       	retal	r12
8000ca3a:	d7 03       	nop

8000ca3c <__sclose>:
8000ca3c:	d4 01       	pushm	lr
8000ca3e:	96 7b       	ld.sh	r11,r11[0xe]
8000ca40:	c8 2c       	rcall	8000cb44 <_close_r>
8000ca42:	d8 02       	popm	pc

8000ca44 <__sseek>:
8000ca44:	d4 21       	pushm	r4-r7,lr
8000ca46:	16 97       	mov	r7,r11
8000ca48:	96 7b       	ld.sh	r11,r11[0xe]
8000ca4a:	c0 3d       	rcall	8000cc50 <_lseek_r>
8000ca4c:	8e 68       	ld.sh	r8,r7[0xc]
8000ca4e:	10 99       	mov	r9,r8
8000ca50:	ad c8       	cbr	r8,0xc
8000ca52:	ad a9       	sbr	r9,0xc
8000ca54:	5b fc       	cp.w	r12,-1
8000ca56:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ca5a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ca5e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ca62:	d8 22       	popm	r4-r7,pc

8000ca64 <__swrite>:
8000ca64:	d4 21       	pushm	r4-r7,lr
8000ca66:	96 68       	ld.sh	r8,r11[0xc]
8000ca68:	16 97       	mov	r7,r11
8000ca6a:	14 95       	mov	r5,r10
8000ca6c:	12 94       	mov	r4,r9
8000ca6e:	e2 18 01 00 	andl	r8,0x100,COH
8000ca72:	18 96       	mov	r6,r12
8000ca74:	c0 50       	breq	8000ca7e <__swrite+0x1a>
8000ca76:	30 29       	mov	r9,2
8000ca78:	30 0a       	mov	r10,0
8000ca7a:	96 7b       	ld.sh	r11,r11[0xe]
8000ca7c:	ce ac       	rcall	8000cc50 <_lseek_r>
8000ca7e:	8e 68       	ld.sh	r8,r7[0xc]
8000ca80:	ad c8       	cbr	r8,0xc
8000ca82:	08 99       	mov	r9,r4
8000ca84:	0a 9a       	mov	r10,r5
8000ca86:	8e 7b       	ld.sh	r11,r7[0xe]
8000ca88:	0c 9c       	mov	r12,r6
8000ca8a:	ae 68       	st.h	r7[0xc],r8
8000ca8c:	c1 cc       	rcall	8000cac4 <_write_r>
8000ca8e:	d8 22       	popm	r4-r7,pc

8000ca90 <__sread>:
8000ca90:	d4 21       	pushm	r4-r7,lr
8000ca92:	16 97       	mov	r7,r11
8000ca94:	96 7b       	ld.sh	r11,r11[0xe]
8000ca96:	cf 1c       	rcall	8000cc78 <_read_r>
8000ca98:	c0 65       	brlt	8000caa4 <__sread+0x14>
8000ca9a:	6f 58       	ld.w	r8,r7[0x54]
8000ca9c:	18 08       	add	r8,r12
8000ca9e:	ef 48 00 54 	st.w	r7[84],r8
8000caa2:	d8 22       	popm	r4-r7,pc
8000caa4:	8e 68       	ld.sh	r8,r7[0xc]
8000caa6:	ad c8       	cbr	r8,0xc
8000caa8:	ae 68       	st.h	r7[0xc],r8
8000caaa:	d8 22       	popm	r4-r7,pc

8000caac <strlen>:
8000caac:	30 09       	mov	r9,0
8000caae:	18 98       	mov	r8,r12
8000cab0:	c0 28       	rjmp	8000cab4 <strlen+0x8>
8000cab2:	2f f8       	sub	r8,-1
8000cab4:	11 8a       	ld.ub	r10,r8[0x0]
8000cab6:	f2 0a 18 00 	cp.b	r10,r9
8000caba:	cf c1       	brne	8000cab2 <strlen+0x6>
8000cabc:	f0 0c 01 0c 	sub	r12,r8,r12
8000cac0:	5e fc       	retal	r12
8000cac2:	d7 03       	nop

8000cac4 <_write_r>:
8000cac4:	d4 21       	pushm	r4-r7,lr
8000cac6:	16 98       	mov	r8,r11
8000cac8:	18 97       	mov	r7,r12
8000caca:	10 9c       	mov	r12,r8
8000cacc:	30 08       	mov	r8,0
8000cace:	14 9b       	mov	r11,r10
8000cad0:	e0 66 54 40 	mov	r6,21568
8000cad4:	12 9a       	mov	r10,r9
8000cad6:	8d 08       	st.w	r6[0x0],r8
8000cad8:	fe b0 d1 50 	rcall	80006d78 <_write>
8000cadc:	5b fc       	cp.w	r12,-1
8000cade:	c0 51       	brne	8000cae8 <_write_r+0x24>
8000cae0:	6c 08       	ld.w	r8,r6[0x0]
8000cae2:	58 08       	cp.w	r8,0
8000cae4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cae8:	d8 22       	popm	r4-r7,pc
8000caea:	d7 03       	nop

8000caec <_calloc_r>:
8000caec:	d4 21       	pushm	r4-r7,lr
8000caee:	f4 0b 02 4b 	mul	r11,r10,r11
8000caf2:	fe b0 db 6d 	rcall	800081cc <_malloc_r>
8000caf6:	18 97       	mov	r7,r12
8000caf8:	c2 30       	breq	8000cb3e <_calloc_r+0x52>
8000cafa:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cafe:	e0 1a ff fc 	andl	r10,0xfffc
8000cb02:	20 4a       	sub	r10,4
8000cb04:	e0 4a 00 24 	cp.w	r10,36
8000cb08:	e0 8b 00 18 	brhi	8000cb38 <_calloc_r+0x4c>
8000cb0c:	18 98       	mov	r8,r12
8000cb0e:	59 3a       	cp.w	r10,19
8000cb10:	e0 88 00 0f 	brls	8000cb2e <_calloc_r+0x42>
8000cb14:	30 09       	mov	r9,0
8000cb16:	10 a9       	st.w	r8++,r9
8000cb18:	10 a9       	st.w	r8++,r9
8000cb1a:	59 ba       	cp.w	r10,27
8000cb1c:	e0 88 00 09 	brls	8000cb2e <_calloc_r+0x42>
8000cb20:	10 a9       	st.w	r8++,r9
8000cb22:	10 a9       	st.w	r8++,r9
8000cb24:	e0 4a 00 24 	cp.w	r10,36
8000cb28:	c0 31       	brne	8000cb2e <_calloc_r+0x42>
8000cb2a:	10 a9       	st.w	r8++,r9
8000cb2c:	10 a9       	st.w	r8++,r9
8000cb2e:	30 09       	mov	r9,0
8000cb30:	10 a9       	st.w	r8++,r9
8000cb32:	91 19       	st.w	r8[0x4],r9
8000cb34:	91 09       	st.w	r8[0x0],r9
8000cb36:	c0 48       	rjmp	8000cb3e <_calloc_r+0x52>
8000cb38:	30 0b       	mov	r11,0
8000cb3a:	fe b0 de 1c 	rcall	80008772 <memset>
8000cb3e:	0e 9c       	mov	r12,r7
8000cb40:	d8 22       	popm	r4-r7,pc
8000cb42:	d7 03       	nop

8000cb44 <_close_r>:
8000cb44:	d4 21       	pushm	r4-r7,lr
8000cb46:	30 08       	mov	r8,0
8000cb48:	18 97       	mov	r7,r12
8000cb4a:	e0 66 54 40 	mov	r6,21568
8000cb4e:	16 9c       	mov	r12,r11
8000cb50:	8d 08       	st.w	r6[0x0],r8
8000cb52:	fe b0 df b5 	rcall	80008abc <_close>
8000cb56:	5b fc       	cp.w	r12,-1
8000cb58:	c0 51       	brne	8000cb62 <_close_r+0x1e>
8000cb5a:	6c 08       	ld.w	r8,r6[0x0]
8000cb5c:	58 08       	cp.w	r8,0
8000cb5e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cb62:	d8 22       	popm	r4-r7,pc

8000cb64 <_fclose_r>:
8000cb64:	d4 21       	pushm	r4-r7,lr
8000cb66:	18 96       	mov	r6,r12
8000cb68:	16 97       	mov	r7,r11
8000cb6a:	58 0b       	cp.w	r11,0
8000cb6c:	c0 31       	brne	8000cb72 <_fclose_r+0xe>
8000cb6e:	16 95       	mov	r5,r11
8000cb70:	c5 38       	rjmp	8000cc16 <_fclose_r+0xb2>
8000cb72:	fe b0 f8 a9 	rcall	8000bcc4 <__sfp_lock_acquire>
8000cb76:	58 06       	cp.w	r6,0
8000cb78:	c0 70       	breq	8000cb86 <_fclose_r+0x22>
8000cb7a:	6c 68       	ld.w	r8,r6[0x18]
8000cb7c:	58 08       	cp.w	r8,0
8000cb7e:	c0 41       	brne	8000cb86 <_fclose_r+0x22>
8000cb80:	0c 9c       	mov	r12,r6
8000cb82:	fe b0 f8 f3 	rcall	8000bd68 <__sinit>
8000cb86:	fe c8 d9 9a 	sub	r8,pc,-9830
8000cb8a:	10 37       	cp.w	r7,r8
8000cb8c:	c0 31       	brne	8000cb92 <_fclose_r+0x2e>
8000cb8e:	6c 07       	ld.w	r7,r6[0x0]
8000cb90:	c0 c8       	rjmp	8000cba8 <_fclose_r+0x44>
8000cb92:	fe c8 d9 86 	sub	r8,pc,-9850
8000cb96:	10 37       	cp.w	r7,r8
8000cb98:	c0 31       	brne	8000cb9e <_fclose_r+0x3a>
8000cb9a:	6c 17       	ld.w	r7,r6[0x4]
8000cb9c:	c0 68       	rjmp	8000cba8 <_fclose_r+0x44>
8000cb9e:	fe c8 d9 72 	sub	r8,pc,-9870
8000cba2:	10 37       	cp.w	r7,r8
8000cba4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cba8:	8e 69       	ld.sh	r9,r7[0xc]
8000cbaa:	30 08       	mov	r8,0
8000cbac:	f0 09 19 00 	cp.h	r9,r8
8000cbb0:	c0 51       	brne	8000cbba <_fclose_r+0x56>
8000cbb2:	fe b0 f8 8a 	rcall	8000bcc6 <__sfp_lock_release>
8000cbb6:	30 05       	mov	r5,0
8000cbb8:	c2 f8       	rjmp	8000cc16 <_fclose_r+0xb2>
8000cbba:	0e 9b       	mov	r11,r7
8000cbbc:	0c 9c       	mov	r12,r6
8000cbbe:	fe b0 f7 fd 	rcall	8000bbb8 <_fflush_r>
8000cbc2:	6e c8       	ld.w	r8,r7[0x30]
8000cbc4:	18 95       	mov	r5,r12
8000cbc6:	58 08       	cp.w	r8,0
8000cbc8:	c0 60       	breq	8000cbd4 <_fclose_r+0x70>
8000cbca:	6e 8b       	ld.w	r11,r7[0x20]
8000cbcc:	0c 9c       	mov	r12,r6
8000cbce:	5d 18       	icall	r8
8000cbd0:	f9 b5 05 ff 	movlt	r5,-1
8000cbd4:	8e 68       	ld.sh	r8,r7[0xc]
8000cbd6:	ed b8 00 07 	bld	r8,0x7
8000cbda:	c0 51       	brne	8000cbe4 <_fclose_r+0x80>
8000cbdc:	6e 4b       	ld.w	r11,r7[0x10]
8000cbde:	0c 9c       	mov	r12,r6
8000cbe0:	fe b0 f9 5e 	rcall	8000be9c <_free_r>
8000cbe4:	6e db       	ld.w	r11,r7[0x34]
8000cbe6:	58 0b       	cp.w	r11,0
8000cbe8:	c0 a0       	breq	8000cbfc <_fclose_r+0x98>
8000cbea:	ee c8 ff bc 	sub	r8,r7,-68
8000cbee:	10 3b       	cp.w	r11,r8
8000cbf0:	c0 40       	breq	8000cbf8 <_fclose_r+0x94>
8000cbf2:	0c 9c       	mov	r12,r6
8000cbf4:	fe b0 f9 54 	rcall	8000be9c <_free_r>
8000cbf8:	30 08       	mov	r8,0
8000cbfa:	8f d8       	st.w	r7[0x34],r8
8000cbfc:	6f 2b       	ld.w	r11,r7[0x48]
8000cbfe:	58 0b       	cp.w	r11,0
8000cc00:	c0 70       	breq	8000cc0e <_fclose_r+0xaa>
8000cc02:	0c 9c       	mov	r12,r6
8000cc04:	fe b0 f9 4c 	rcall	8000be9c <_free_r>
8000cc08:	30 08       	mov	r8,0
8000cc0a:	ef 48 00 48 	st.w	r7[72],r8
8000cc0e:	30 08       	mov	r8,0
8000cc10:	ae 68       	st.h	r7[0xc],r8
8000cc12:	fe b0 f8 5a 	rcall	8000bcc6 <__sfp_lock_release>
8000cc16:	0a 9c       	mov	r12,r5
8000cc18:	d8 22       	popm	r4-r7,pc
8000cc1a:	d7 03       	nop

8000cc1c <fclose>:
8000cc1c:	d4 01       	pushm	lr
8000cc1e:	e0 68 0a 50 	mov	r8,2640
8000cc22:	18 9b       	mov	r11,r12
8000cc24:	70 0c       	ld.w	r12,r8[0x0]
8000cc26:	c9 ff       	rcall	8000cb64 <_fclose_r>
8000cc28:	d8 02       	popm	pc
8000cc2a:	d7 03       	nop

8000cc2c <_fstat_r>:
8000cc2c:	d4 21       	pushm	r4-r7,lr
8000cc2e:	16 98       	mov	r8,r11
8000cc30:	18 97       	mov	r7,r12
8000cc32:	10 9c       	mov	r12,r8
8000cc34:	30 08       	mov	r8,0
8000cc36:	e0 66 54 40 	mov	r6,21568
8000cc3a:	14 9b       	mov	r11,r10
8000cc3c:	8d 08       	st.w	r6[0x0],r8
8000cc3e:	fe b0 df 67 	rcall	80008b0c <_fstat>
8000cc42:	5b fc       	cp.w	r12,-1
8000cc44:	c0 51       	brne	8000cc4e <_fstat_r+0x22>
8000cc46:	6c 08       	ld.w	r8,r6[0x0]
8000cc48:	58 08       	cp.w	r8,0
8000cc4a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cc4e:	d8 22       	popm	r4-r7,pc

8000cc50 <_lseek_r>:
8000cc50:	d4 21       	pushm	r4-r7,lr
8000cc52:	16 98       	mov	r8,r11
8000cc54:	18 97       	mov	r7,r12
8000cc56:	10 9c       	mov	r12,r8
8000cc58:	30 08       	mov	r8,0
8000cc5a:	14 9b       	mov	r11,r10
8000cc5c:	e0 66 54 40 	mov	r6,21568
8000cc60:	12 9a       	mov	r10,r9
8000cc62:	8d 08       	st.w	r6[0x0],r8
8000cc64:	fe b0 df 36 	rcall	80008ad0 <_lseek>
8000cc68:	5b fc       	cp.w	r12,-1
8000cc6a:	c0 51       	brne	8000cc74 <_lseek_r+0x24>
8000cc6c:	6c 08       	ld.w	r8,r6[0x0]
8000cc6e:	58 08       	cp.w	r8,0
8000cc70:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cc74:	d8 22       	popm	r4-r7,pc
8000cc76:	d7 03       	nop

8000cc78 <_read_r>:
8000cc78:	d4 21       	pushm	r4-r7,lr
8000cc7a:	16 98       	mov	r8,r11
8000cc7c:	18 97       	mov	r7,r12
8000cc7e:	10 9c       	mov	r12,r8
8000cc80:	30 08       	mov	r8,0
8000cc82:	14 9b       	mov	r11,r10
8000cc84:	e0 66 54 40 	mov	r6,21568
8000cc88:	12 9a       	mov	r10,r9
8000cc8a:	8d 08       	st.w	r6[0x0],r8
8000cc8c:	fe b0 d0 56 	rcall	80006d38 <_read>
8000cc90:	5b fc       	cp.w	r12,-1
8000cc92:	c0 51       	brne	8000cc9c <_read_r+0x24>
8000cc94:	6c 08       	ld.w	r8,r6[0x0]
8000cc96:	58 08       	cp.w	r8,0
8000cc98:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cc9c:	d8 22       	popm	r4-r7,pc
8000cc9e:	d7 03       	nop

8000cca0 <__avr32_f64_mul>:
8000cca0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000cca4:	e0 80 00 dc 	breq	8000ce5c <__avr32_f64_mul_op1_zero>
8000cca8:	d4 21       	pushm	r4-r7,lr
8000ccaa:	f7 e9 20 0e 	eor	lr,r11,r9
8000ccae:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ccb2:	30 15       	mov	r5,1
8000ccb4:	c4 30       	breq	8000cd3a <__avr32_f64_mul_op1_subnormal>
8000ccb6:	ab 6b       	lsl	r11,0xa
8000ccb8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ccbc:	ab 6a       	lsl	r10,0xa
8000ccbe:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ccc2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ccc6:	c5 c0       	breq	8000cd7e <__avr32_f64_mul_op2_subnormal>
8000ccc8:	a1 78       	lsl	r8,0x1
8000ccca:	5c f9       	rol	r9
8000cccc:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ccd0:	e0 47 07 ff 	cp.w	r7,2047
8000ccd4:	c7 70       	breq	8000cdc2 <__avr32_f64_mul_op_nan_or_inf>
8000ccd6:	e0 46 07 ff 	cp.w	r6,2047
8000ccda:	c7 40       	breq	8000cdc2 <__avr32_f64_mul_op_nan_or_inf>
8000ccdc:	ee 06 00 0c 	add	r12,r7,r6
8000cce0:	e0 2c 03 fe 	sub	r12,1022
8000cce4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000cce8:	f4 09 07 44 	macu.d	r4,r10,r9
8000ccec:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ccf0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ccf4:	08 07       	add	r7,r4
8000ccf6:	f4 05 00 4a 	adc	r10,r10,r5
8000ccfa:	5c 0b       	acr	r11
8000ccfc:	ed bb 00 14 	bld	r11,0x14
8000cd00:	c0 50       	breq	8000cd0a <__avr32_f64_mul+0x6a>
8000cd02:	a1 77       	lsl	r7,0x1
8000cd04:	5c fa       	rol	r10
8000cd06:	5c fb       	rol	r11
8000cd08:	20 1c       	sub	r12,1
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	e0 8a 00 6f 	brle	8000cdea <__avr32_f64_mul_res_subnormal>
8000cd10:	e0 4c 07 ff 	cp.w	r12,2047
8000cd14:	e0 84 00 9c 	brge	8000ce4c <__avr32_f64_mul_res_inf>
8000cd18:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cd1c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cd20:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cd24:	ee 17 80 00 	eorh	r7,0x8000
8000cd28:	f1 b7 04 20 	satu	r7,0x1
8000cd2c:	0e 0a       	add	r10,r7
8000cd2e:	5c 0b       	acr	r11
8000cd30:	ed be 00 1f 	bld	lr,0x1f
8000cd34:	ef bb 00 1f 	bst	r11,0x1f
8000cd38:	d8 22       	popm	r4-r7,pc

8000cd3a <__avr32_f64_mul_op1_subnormal>:
8000cd3a:	e4 1b 00 0f 	andh	r11,0xf
8000cd3e:	f4 0c 12 00 	clz	r12,r10
8000cd42:	f6 06 12 00 	clz	r6,r11
8000cd46:	f7 bc 03 e1 	sublo	r12,-31
8000cd4a:	f8 06 17 30 	movlo	r6,r12
8000cd4e:	f7 b6 02 01 	subhs	r6,1
8000cd52:	e0 46 00 20 	cp.w	r6,32
8000cd56:	c0 d4       	brge	8000cd70 <__avr32_f64_mul_op1_subnormal+0x36>
8000cd58:	ec 0c 11 20 	rsub	r12,r6,32
8000cd5c:	f6 06 09 4b 	lsl	r11,r11,r6
8000cd60:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cd64:	18 4b       	or	r11,r12
8000cd66:	f4 06 09 4a 	lsl	r10,r10,r6
8000cd6a:	20 b6       	sub	r6,11
8000cd6c:	0c 17       	sub	r7,r6
8000cd6e:	ca ab       	rjmp	8000ccc2 <__avr32_f64_mul+0x22>
8000cd70:	f4 06 09 4b 	lsl	r11,r10,r6
8000cd74:	c6 40       	breq	8000ce3c <__avr32_f64_mul_res_zero>
8000cd76:	30 0a       	mov	r10,0
8000cd78:	20 b6       	sub	r6,11
8000cd7a:	0c 17       	sub	r7,r6
8000cd7c:	ca 3b       	rjmp	8000ccc2 <__avr32_f64_mul+0x22>

8000cd7e <__avr32_f64_mul_op2_subnormal>:
8000cd7e:	e4 19 00 0f 	andh	r9,0xf
8000cd82:	f0 0c 12 00 	clz	r12,r8
8000cd86:	f2 05 12 00 	clz	r5,r9
8000cd8a:	f7 bc 03 ea 	sublo	r12,-22
8000cd8e:	f8 05 17 30 	movlo	r5,r12
8000cd92:	f7 b5 02 0a 	subhs	r5,10
8000cd96:	e0 45 00 20 	cp.w	r5,32
8000cd9a:	c0 d4       	brge	8000cdb4 <__avr32_f64_mul_op2_subnormal+0x36>
8000cd9c:	ea 0c 11 20 	rsub	r12,r5,32
8000cda0:	f2 05 09 49 	lsl	r9,r9,r5
8000cda4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cda8:	18 49       	or	r9,r12
8000cdaa:	f0 05 09 48 	lsl	r8,r8,r5
8000cdae:	20 25       	sub	r5,2
8000cdb0:	0a 16       	sub	r6,r5
8000cdb2:	c8 fb       	rjmp	8000ccd0 <__avr32_f64_mul+0x30>
8000cdb4:	f0 05 09 49 	lsl	r9,r8,r5
8000cdb8:	c4 20       	breq	8000ce3c <__avr32_f64_mul_res_zero>
8000cdba:	30 08       	mov	r8,0
8000cdbc:	20 25       	sub	r5,2
8000cdbe:	0a 16       	sub	r6,r5
8000cdc0:	c8 8b       	rjmp	8000ccd0 <__avr32_f64_mul+0x30>

8000cdc2 <__avr32_f64_mul_op_nan_or_inf>:
8000cdc2:	e4 19 00 0f 	andh	r9,0xf
8000cdc6:	e4 1b 00 0f 	andh	r11,0xf
8000cdca:	14 4b       	or	r11,r10
8000cdcc:	10 49       	or	r9,r8
8000cdce:	e0 47 07 ff 	cp.w	r7,2047
8000cdd2:	c0 91       	brne	8000cde4 <__avr32_f64_mul_op1_not_naninf>
8000cdd4:	58 0b       	cp.w	r11,0
8000cdd6:	c3 81       	brne	8000ce46 <__avr32_f64_mul_res_nan>
8000cdd8:	e0 46 07 ff 	cp.w	r6,2047
8000cddc:	c3 81       	brne	8000ce4c <__avr32_f64_mul_res_inf>
8000cdde:	58 09       	cp.w	r9,0
8000cde0:	c3 60       	breq	8000ce4c <__avr32_f64_mul_res_inf>
8000cde2:	c3 28       	rjmp	8000ce46 <__avr32_f64_mul_res_nan>

8000cde4 <__avr32_f64_mul_op1_not_naninf>:
8000cde4:	58 09       	cp.w	r9,0
8000cde6:	c3 30       	breq	8000ce4c <__avr32_f64_mul_res_inf>
8000cde8:	c2 f8       	rjmp	8000ce46 <__avr32_f64_mul_res_nan>

8000cdea <__avr32_f64_mul_res_subnormal>:
8000cdea:	5c 3c       	neg	r12
8000cdec:	2f fc       	sub	r12,-1
8000cdee:	f1 bc 04 c0 	satu	r12,0x6
8000cdf2:	e0 4c 00 20 	cp.w	r12,32
8000cdf6:	c1 14       	brge	8000ce18 <__avr32_f64_mul_res_subnormal+0x2e>
8000cdf8:	f8 08 11 20 	rsub	r8,r12,32
8000cdfc:	0e 46       	or	r6,r7
8000cdfe:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ce02:	f4 08 09 49 	lsl	r9,r10,r8
8000ce06:	12 47       	or	r7,r9
8000ce08:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ce0c:	f6 08 09 49 	lsl	r9,r11,r8
8000ce10:	12 4a       	or	r10,r9
8000ce12:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ce16:	c8 3b       	rjmp	8000cd1c <__avr32_f64_mul+0x7c>
8000ce18:	f8 08 11 20 	rsub	r8,r12,32
8000ce1c:	f9 b9 00 00 	moveq	r9,0
8000ce20:	c0 30       	breq	8000ce26 <__avr32_f64_mul_res_subnormal+0x3c>
8000ce22:	f6 08 09 49 	lsl	r9,r11,r8
8000ce26:	0e 46       	or	r6,r7
8000ce28:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ce2c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ce30:	f3 ea 10 07 	or	r7,r9,r10
8000ce34:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ce38:	30 0b       	mov	r11,0
8000ce3a:	c7 1b       	rjmp	8000cd1c <__avr32_f64_mul+0x7c>

8000ce3c <__avr32_f64_mul_res_zero>:
8000ce3c:	1c 9b       	mov	r11,lr
8000ce3e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ce42:	30 0a       	mov	r10,0
8000ce44:	d8 22       	popm	r4-r7,pc

8000ce46 <__avr32_f64_mul_res_nan>:
8000ce46:	3f fb       	mov	r11,-1
8000ce48:	3f fa       	mov	r10,-1
8000ce4a:	d8 22       	popm	r4-r7,pc

8000ce4c <__avr32_f64_mul_res_inf>:
8000ce4c:	f0 6b 00 00 	mov	r11,-1048576
8000ce50:	ed be 00 1f 	bld	lr,0x1f
8000ce54:	ef bb 00 1f 	bst	r11,0x1f
8000ce58:	30 0a       	mov	r10,0
8000ce5a:	d8 22       	popm	r4-r7,pc

8000ce5c <__avr32_f64_mul_op1_zero>:
8000ce5c:	f7 e9 20 0b 	eor	r11,r11,r9
8000ce60:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ce64:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ce68:	e0 4c 07 ff 	cp.w	r12,2047
8000ce6c:	5e 1c       	retne	r12
8000ce6e:	3f fa       	mov	r10,-1
8000ce70:	3f fb       	mov	r11,-1
8000ce72:	5e fc       	retal	r12

8000ce74 <__avr32_f64_sub_from_add>:
8000ce74:	ee 19 80 00 	eorh	r9,0x8000

8000ce78 <__avr32_f64_sub>:
8000ce78:	f7 e9 20 0c 	eor	r12,r11,r9
8000ce7c:	e0 86 00 ca 	brmi	8000d010 <__avr32_f64_add_from_sub>
8000ce80:	eb cd 40 e0 	pushm	r5-r7,lr
8000ce84:	16 9c       	mov	r12,r11
8000ce86:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ce8a:	bf db       	cbr	r11,0x1f
8000ce8c:	bf d9       	cbr	r9,0x1f
8000ce8e:	10 3a       	cp.w	r10,r8
8000ce90:	f2 0b 13 00 	cpc	r11,r9
8000ce94:	c0 92       	brcc	8000cea6 <__avr32_f64_sub+0x2e>
8000ce96:	16 97       	mov	r7,r11
8000ce98:	12 9b       	mov	r11,r9
8000ce9a:	0e 99       	mov	r9,r7
8000ce9c:	14 97       	mov	r7,r10
8000ce9e:	10 9a       	mov	r10,r8
8000cea0:	0e 98       	mov	r8,r7
8000cea2:	ee 1c 80 00 	eorh	r12,0x8000
8000cea6:	f6 07 16 14 	lsr	r7,r11,0x14
8000ceaa:	ab 7b       	lsl	r11,0xb
8000ceac:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ceb0:	ab 7a       	lsl	r10,0xb
8000ceb2:	bf bb       	sbr	r11,0x1f
8000ceb4:	f2 06 16 14 	lsr	r6,r9,0x14
8000ceb8:	c4 40       	breq	8000cf40 <__avr32_f64_sub_opL_subnormal>
8000ceba:	ab 79       	lsl	r9,0xb
8000cebc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000cec0:	ab 78       	lsl	r8,0xb
8000cec2:	bf b9       	sbr	r9,0x1f

8000cec4 <__avr32_f64_sub_opL_subnormal_done>:
8000cec4:	e0 47 07 ff 	cp.w	r7,2047
8000cec8:	c4 f0       	breq	8000cf66 <__avr32_f64_sub_opH_nan_or_inf>
8000ceca:	0e 26       	rsub	r6,r7
8000cecc:	c1 20       	breq	8000cef0 <__avr32_f64_sub_shift_done>
8000cece:	ec 05 11 20 	rsub	r5,r6,32
8000ced2:	e0 46 00 20 	cp.w	r6,32
8000ced6:	c7 c2       	brcc	8000cfce <__avr32_f64_sub_longshift>
8000ced8:	f0 05 09 4e 	lsl	lr,r8,r5
8000cedc:	f2 05 09 45 	lsl	r5,r9,r5
8000cee0:	f0 06 0a 48 	lsr	r8,r8,r6
8000cee4:	f2 06 0a 49 	lsr	r9,r9,r6
8000cee8:	0a 48       	or	r8,r5
8000ceea:	58 0e       	cp.w	lr,0
8000ceec:	5f 1e       	srne	lr
8000ceee:	1c 48       	or	r8,lr

8000cef0 <__avr32_f64_sub_shift_done>:
8000cef0:	10 1a       	sub	r10,r8
8000cef2:	f6 09 01 4b 	sbc	r11,r11,r9
8000cef6:	f6 06 12 00 	clz	r6,r11
8000cefa:	c0 e0       	breq	8000cf16 <__avr32_f64_sub_longnormalize_done>
8000cefc:	c7 83       	brcs	8000cfec <__avr32_f64_sub_longnormalize>
8000cefe:	ec 0e 11 20 	rsub	lr,r6,32
8000cf02:	f6 06 09 4b 	lsl	r11,r11,r6
8000cf06:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000cf0a:	1c 4b       	or	r11,lr
8000cf0c:	f4 06 09 4a 	lsl	r10,r10,r6
8000cf10:	0c 17       	sub	r7,r6
8000cf12:	e0 8a 00 39 	brle	8000cf84 <__avr32_f64_sub_subnormal_result>

8000cf16 <__avr32_f64_sub_longnormalize_done>:
8000cf16:	f4 09 15 15 	lsl	r9,r10,0x15
8000cf1a:	ab 9a       	lsr	r10,0xb
8000cf1c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000cf20:	ab 9b       	lsr	r11,0xb
8000cf22:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cf26:	18 4b       	or	r11,r12

8000cf28 <__avr32_f64_sub_round>:
8000cf28:	fc 17 80 00 	movh	r7,0x8000
8000cf2c:	ed ba 00 00 	bld	r10,0x0
8000cf30:	f7 b7 01 ff 	subne	r7,-1
8000cf34:	0e 39       	cp.w	r9,r7
8000cf36:	5f 29       	srhs	r9
8000cf38:	12 0a       	add	r10,r9
8000cf3a:	5c 0b       	acr	r11
8000cf3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cf40 <__avr32_f64_sub_opL_subnormal>:
8000cf40:	ab 79       	lsl	r9,0xb
8000cf42:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000cf46:	ab 78       	lsl	r8,0xb
8000cf48:	f3 e8 10 0e 	or	lr,r9,r8
8000cf4c:	f9 b6 01 01 	movne	r6,1
8000cf50:	ee 0e 11 00 	rsub	lr,r7,0
8000cf54:	f9 b7 00 01 	moveq	r7,1
8000cf58:	ef bb 00 1f 	bst	r11,0x1f
8000cf5c:	f7 ea 10 0e 	or	lr,r11,r10
8000cf60:	f9 b7 00 00 	moveq	r7,0
8000cf64:	cb 0b       	rjmp	8000cec4 <__avr32_f64_sub_opL_subnormal_done>

8000cf66 <__avr32_f64_sub_opH_nan_or_inf>:
8000cf66:	bf db       	cbr	r11,0x1f
8000cf68:	f7 ea 10 0e 	or	lr,r11,r10
8000cf6c:	c0 81       	brne	8000cf7c <__avr32_f64_sub_return_nan>
8000cf6e:	e0 46 07 ff 	cp.w	r6,2047
8000cf72:	c0 50       	breq	8000cf7c <__avr32_f64_sub_return_nan>
8000cf74:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000cf78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cf7c <__avr32_f64_sub_return_nan>:
8000cf7c:	3f fa       	mov	r10,-1
8000cf7e:	3f fb       	mov	r11,-1
8000cf80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cf84 <__avr32_f64_sub_subnormal_result>:
8000cf84:	5c 37       	neg	r7
8000cf86:	2f f7       	sub	r7,-1
8000cf88:	f1 b7 04 c0 	satu	r7,0x6
8000cf8c:	e0 47 00 20 	cp.w	r7,32
8000cf90:	c1 14       	brge	8000cfb2 <__avr32_f64_sub_subnormal_result+0x2e>
8000cf92:	ee 08 11 20 	rsub	r8,r7,32
8000cf96:	f4 08 09 49 	lsl	r9,r10,r8
8000cf9a:	5f 16       	srne	r6
8000cf9c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000cfa0:	0c 4a       	or	r10,r6
8000cfa2:	f6 08 09 49 	lsl	r9,r11,r8
8000cfa6:	f5 e9 10 0a 	or	r10,r10,r9
8000cfaa:	f4 07 0a 4b 	lsr	r11,r10,r7
8000cfae:	30 07       	mov	r7,0
8000cfb0:	cb 3b       	rjmp	8000cf16 <__avr32_f64_sub_longnormalize_done>
8000cfb2:	ee 08 11 40 	rsub	r8,r7,64
8000cfb6:	f6 08 09 49 	lsl	r9,r11,r8
8000cfba:	14 49       	or	r9,r10
8000cfbc:	5f 16       	srne	r6
8000cfbe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000cfc2:	0c 4a       	or	r10,r6
8000cfc4:	30 0b       	mov	r11,0
8000cfc6:	30 07       	mov	r7,0
8000cfc8:	ca 7b       	rjmp	8000cf16 <__avr32_f64_sub_longnormalize_done>
8000cfca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cfce <__avr32_f64_sub_longshift>:
8000cfce:	f1 b6 04 c0 	satu	r6,0x6
8000cfd2:	f0 0e 17 00 	moveq	lr,r8
8000cfd6:	c0 40       	breq	8000cfde <__avr32_f64_sub_longshift+0x10>
8000cfd8:	f2 05 09 4e 	lsl	lr,r9,r5
8000cfdc:	10 4e       	or	lr,r8
8000cfde:	f2 06 0a 48 	lsr	r8,r9,r6
8000cfe2:	30 09       	mov	r9,0
8000cfe4:	58 0e       	cp.w	lr,0
8000cfe6:	5f 1e       	srne	lr
8000cfe8:	1c 48       	or	r8,lr
8000cfea:	c8 3b       	rjmp	8000cef0 <__avr32_f64_sub_shift_done>

8000cfec <__avr32_f64_sub_longnormalize>:
8000cfec:	f4 06 12 00 	clz	r6,r10
8000cff0:	f9 b7 03 00 	movlo	r7,0
8000cff4:	f9 b6 03 00 	movlo	r6,0
8000cff8:	f9 bc 03 00 	movlo	r12,0
8000cffc:	f7 b6 02 e0 	subhs	r6,-32
8000d000:	f4 06 09 4b 	lsl	r11,r10,r6
8000d004:	30 0a       	mov	r10,0
8000d006:	0c 17       	sub	r7,r6
8000d008:	fe 9a ff be 	brle	8000cf84 <__avr32_f64_sub_subnormal_result>
8000d00c:	c8 5b       	rjmp	8000cf16 <__avr32_f64_sub_longnormalize_done>
8000d00e:	d7 03       	nop

8000d010 <__avr32_f64_add_from_sub>:
8000d010:	ee 19 80 00 	eorh	r9,0x8000

8000d014 <__avr32_f64_add>:
8000d014:	f7 e9 20 0c 	eor	r12,r11,r9
8000d018:	fe 96 ff 2e 	brmi	8000ce74 <__avr32_f64_sub_from_add>
8000d01c:	eb cd 40 e0 	pushm	r5-r7,lr
8000d020:	16 9c       	mov	r12,r11
8000d022:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d026:	bf db       	cbr	r11,0x1f
8000d028:	bf d9       	cbr	r9,0x1f
8000d02a:	12 3b       	cp.w	r11,r9
8000d02c:	c0 72       	brcc	8000d03a <__avr32_f64_add+0x26>
8000d02e:	16 97       	mov	r7,r11
8000d030:	12 9b       	mov	r11,r9
8000d032:	0e 99       	mov	r9,r7
8000d034:	14 97       	mov	r7,r10
8000d036:	10 9a       	mov	r10,r8
8000d038:	0e 98       	mov	r8,r7
8000d03a:	30 0e       	mov	lr,0
8000d03c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d040:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d044:	b5 ab       	sbr	r11,0x14
8000d046:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d04a:	c6 20       	breq	8000d10e <__avr32_f64_add_op2_subnormal>
8000d04c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d050:	b5 a9       	sbr	r9,0x14
8000d052:	e0 47 07 ff 	cp.w	r7,2047
8000d056:	c2 80       	breq	8000d0a6 <__avr32_f64_add_opH_nan_or_inf>
8000d058:	0e 26       	rsub	r6,r7
8000d05a:	c1 20       	breq	8000d07e <__avr32_f64_add_shift_done>
8000d05c:	e0 46 00 36 	cp.w	r6,54
8000d060:	c1 52       	brcc	8000d08a <__avr32_f64_add_res_of_done>
8000d062:	ec 05 11 20 	rsub	r5,r6,32
8000d066:	e0 46 00 20 	cp.w	r6,32
8000d06a:	c3 52       	brcc	8000d0d4 <__avr32_f64_add_longshift>
8000d06c:	f0 05 09 4e 	lsl	lr,r8,r5
8000d070:	f2 05 09 45 	lsl	r5,r9,r5
8000d074:	f0 06 0a 48 	lsr	r8,r8,r6
8000d078:	f2 06 0a 49 	lsr	r9,r9,r6
8000d07c:	0a 48       	or	r8,r5

8000d07e <__avr32_f64_add_shift_done>:
8000d07e:	10 0a       	add	r10,r8
8000d080:	f6 09 00 4b 	adc	r11,r11,r9
8000d084:	ed bb 00 15 	bld	r11,0x15
8000d088:	c3 40       	breq	8000d0f0 <__avr32_f64_add_res_of>

8000d08a <__avr32_f64_add_res_of_done>:
8000d08a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d08e:	18 4b       	or	r11,r12

8000d090 <__avr32_f64_add_round>:
8000d090:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d094:	18 4e       	or	lr,r12
8000d096:	ee 1e 80 00 	eorh	lr,0x8000
8000d09a:	f1 be 04 20 	satu	lr,0x1
8000d09e:	1c 0a       	add	r10,lr
8000d0a0:	5c 0b       	acr	r11
8000d0a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0a6 <__avr32_f64_add_opH_nan_or_inf>:
8000d0a6:	b5 cb       	cbr	r11,0x14
8000d0a8:	f7 ea 10 0e 	or	lr,r11,r10
8000d0ac:	c1 01       	brne	8000d0cc <__avr32_f64_add_return_nan>
8000d0ae:	e0 46 07 ff 	cp.w	r6,2047
8000d0b2:	c0 30       	breq	8000d0b8 <__avr32_f64_add_opL_nan_or_inf>
8000d0b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0b8 <__avr32_f64_add_opL_nan_or_inf>:
8000d0b8:	b5 c9       	cbr	r9,0x14
8000d0ba:	f3 e8 10 0e 	or	lr,r9,r8
8000d0be:	c0 71       	brne	8000d0cc <__avr32_f64_add_return_nan>
8000d0c0:	30 0a       	mov	r10,0
8000d0c2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d0c6:	18 4b       	or	r11,r12
8000d0c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0cc <__avr32_f64_add_return_nan>:
8000d0cc:	3f fa       	mov	r10,-1
8000d0ce:	3f fb       	mov	r11,-1
8000d0d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0d4 <__avr32_f64_add_longshift>:
8000d0d4:	f1 b6 04 c0 	satu	r6,0x6
8000d0d8:	f0 0e 17 00 	moveq	lr,r8
8000d0dc:	c0 60       	breq	8000d0e8 <__avr32_f64_add_longshift+0x14>
8000d0de:	f2 05 09 4e 	lsl	lr,r9,r5
8000d0e2:	58 08       	cp.w	r8,0
8000d0e4:	5f 18       	srne	r8
8000d0e6:	10 4e       	or	lr,r8
8000d0e8:	f2 06 0a 48 	lsr	r8,r9,r6
8000d0ec:	30 09       	mov	r9,0
8000d0ee:	cc 8b       	rjmp	8000d07e <__avr32_f64_add_shift_done>

8000d0f0 <__avr32_f64_add_res_of>:
8000d0f0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d0f4:	a1 9b       	lsr	r11,0x1
8000d0f6:	5d 0a       	ror	r10
8000d0f8:	5d 0e       	ror	lr
8000d0fa:	2f f7       	sub	r7,-1
8000d0fc:	e0 47 07 ff 	cp.w	r7,2047
8000d100:	f9 ba 00 00 	moveq	r10,0
8000d104:	f9 bb 00 00 	moveq	r11,0
8000d108:	f9 be 00 00 	moveq	lr,0
8000d10c:	cb fb       	rjmp	8000d08a <__avr32_f64_add_res_of_done>

8000d10e <__avr32_f64_add_op2_subnormal>:
8000d10e:	30 16       	mov	r6,1
8000d110:	58 07       	cp.w	r7,0
8000d112:	ca 01       	brne	8000d052 <__avr32_f64_add+0x3e>
8000d114:	b5 cb       	cbr	r11,0x14
8000d116:	10 0a       	add	r10,r8
8000d118:	f6 09 00 4b 	adc	r11,r11,r9
8000d11c:	18 4b       	or	r11,r12
8000d11e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d122:	d7 03       	nop

8000d124 <__avr32_f64_to_u32>:
8000d124:	58 0b       	cp.w	r11,0
8000d126:	5e 6d       	retmi	0

8000d128 <__avr32_f64_to_s32>:
8000d128:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d12c:	b5 9c       	lsr	r12,0x15
8000d12e:	e0 2c 03 ff 	sub	r12,1023
8000d132:	5e 3d       	retlo	0
8000d134:	f8 0c 11 1f 	rsub	r12,r12,31
8000d138:	16 99       	mov	r9,r11
8000d13a:	ab 7b       	lsl	r11,0xb
8000d13c:	bf bb       	sbr	r11,0x1f
8000d13e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d142:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d146:	a1 79       	lsl	r9,0x1
8000d148:	5e 2b       	reths	r11
8000d14a:	5c 3b       	neg	r11
8000d14c:	5e fb       	retal	r11

8000d14e <__avr32_u32_to_f64>:
8000d14e:	f8 cb 00 00 	sub	r11,r12,0
8000d152:	30 0c       	mov	r12,0
8000d154:	c0 38       	rjmp	8000d15a <__avr32_s32_to_f64+0x4>

8000d156 <__avr32_s32_to_f64>:
8000d156:	18 9b       	mov	r11,r12
8000d158:	5c 4b       	abs	r11
8000d15a:	30 0a       	mov	r10,0
8000d15c:	5e 0b       	reteq	r11
8000d15e:	d4 01       	pushm	lr
8000d160:	e0 69 04 1e 	mov	r9,1054
8000d164:	f6 08 12 00 	clz	r8,r11
8000d168:	c1 70       	breq	8000d196 <__avr32_s32_to_f64+0x40>
8000d16a:	c0 c3       	brcs	8000d182 <__avr32_s32_to_f64+0x2c>
8000d16c:	f0 0e 11 20 	rsub	lr,r8,32
8000d170:	f6 08 09 4b 	lsl	r11,r11,r8
8000d174:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d178:	1c 4b       	or	r11,lr
8000d17a:	f4 08 09 4a 	lsl	r10,r10,r8
8000d17e:	10 19       	sub	r9,r8
8000d180:	c0 b8       	rjmp	8000d196 <__avr32_s32_to_f64+0x40>
8000d182:	f4 08 12 00 	clz	r8,r10
8000d186:	f9 b8 03 00 	movlo	r8,0
8000d18a:	f7 b8 02 e0 	subhs	r8,-32
8000d18e:	f4 08 09 4b 	lsl	r11,r10,r8
8000d192:	30 0a       	mov	r10,0
8000d194:	10 19       	sub	r9,r8
8000d196:	58 09       	cp.w	r9,0
8000d198:	e0 89 00 30 	brgt	8000d1f8 <__avr32_s32_to_f64+0xa2>
8000d19c:	5c 39       	neg	r9
8000d19e:	2f f9       	sub	r9,-1
8000d1a0:	e0 49 00 36 	cp.w	r9,54
8000d1a4:	c0 43       	brcs	8000d1ac <__avr32_s32_to_f64+0x56>
8000d1a6:	30 0b       	mov	r11,0
8000d1a8:	30 0a       	mov	r10,0
8000d1aa:	c2 68       	rjmp	8000d1f6 <__avr32_s32_to_f64+0xa0>
8000d1ac:	2f 69       	sub	r9,-10
8000d1ae:	f2 08 11 20 	rsub	r8,r9,32
8000d1b2:	e0 49 00 20 	cp.w	r9,32
8000d1b6:	c0 b2       	brcc	8000d1cc <__avr32_s32_to_f64+0x76>
8000d1b8:	f4 08 09 4e 	lsl	lr,r10,r8
8000d1bc:	f6 08 09 48 	lsl	r8,r11,r8
8000d1c0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d1c4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d1c8:	10 4b       	or	r11,r8
8000d1ca:	c0 88       	rjmp	8000d1da <__avr32_s32_to_f64+0x84>
8000d1cc:	f6 08 09 4e 	lsl	lr,r11,r8
8000d1d0:	14 4e       	or	lr,r10
8000d1d2:	16 9a       	mov	r10,r11
8000d1d4:	30 0b       	mov	r11,0
8000d1d6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d1da:	ed ba 00 00 	bld	r10,0x0
8000d1de:	c0 92       	brcc	8000d1f0 <__avr32_s32_to_f64+0x9a>
8000d1e0:	1c 7e       	tst	lr,lr
8000d1e2:	c0 41       	brne	8000d1ea <__avr32_s32_to_f64+0x94>
8000d1e4:	ed ba 00 01 	bld	r10,0x1
8000d1e8:	c0 42       	brcc	8000d1f0 <__avr32_s32_to_f64+0x9a>
8000d1ea:	2f fa       	sub	r10,-1
8000d1ec:	f7 bb 02 ff 	subhs	r11,-1
8000d1f0:	5c fc       	rol	r12
8000d1f2:	5d 0b       	ror	r11
8000d1f4:	5d 0a       	ror	r10
8000d1f6:	d8 02       	popm	pc
8000d1f8:	e0 68 03 ff 	mov	r8,1023
8000d1fc:	ed ba 00 0b 	bld	r10,0xb
8000d200:	f7 b8 00 ff 	subeq	r8,-1
8000d204:	10 0a       	add	r10,r8
8000d206:	5c 0b       	acr	r11
8000d208:	f7 b9 03 fe 	sublo	r9,-2
8000d20c:	e0 49 07 ff 	cp.w	r9,2047
8000d210:	c0 55       	brlt	8000d21a <__avr32_s32_to_f64+0xc4>
8000d212:	30 0a       	mov	r10,0
8000d214:	fc 1b ff e0 	movh	r11,0xffe0
8000d218:	c0 c8       	rjmp	8000d230 <__floatsidf_return_op1>
8000d21a:	ed bb 00 1f 	bld	r11,0x1f
8000d21e:	f7 b9 01 01 	subne	r9,1
8000d222:	ab 9a       	lsr	r10,0xb
8000d224:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d228:	a1 7b       	lsl	r11,0x1
8000d22a:	ab 9b       	lsr	r11,0xb
8000d22c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d230 <__floatsidf_return_op1>:
8000d230:	a1 7c       	lsl	r12,0x1
8000d232:	5d 0b       	ror	r11
8000d234:	d8 02       	popm	pc

8000d236 <__avr32_f64_cmp_eq>:
8000d236:	10 3a       	cp.w	r10,r8
8000d238:	f2 0b 13 00 	cpc	r11,r9
8000d23c:	c0 80       	breq	8000d24c <__avr32_f64_cmp_eq+0x16>
8000d23e:	a1 7b       	lsl	r11,0x1
8000d240:	a1 79       	lsl	r9,0x1
8000d242:	14 4b       	or	r11,r10
8000d244:	12 4b       	or	r11,r9
8000d246:	10 4b       	or	r11,r8
8000d248:	5e 0f       	reteq	1
8000d24a:	5e fd       	retal	0
8000d24c:	a1 7b       	lsl	r11,0x1
8000d24e:	fc 1c ff e0 	movh	r12,0xffe0
8000d252:	58 0a       	cp.w	r10,0
8000d254:	f8 0b 13 00 	cpc	r11,r12
8000d258:	5e 8f       	retls	1
8000d25a:	5e fd       	retal	0

8000d25c <__avr32_f64_cmp_ge>:
8000d25c:	1a de       	st.w	--sp,lr
8000d25e:	1a d7       	st.w	--sp,r7
8000d260:	a1 7b       	lsl	r11,0x1
8000d262:	5f 3c       	srlo	r12
8000d264:	a1 79       	lsl	r9,0x1
8000d266:	5f 37       	srlo	r7
8000d268:	5c fc       	rol	r12
8000d26a:	fc 1e ff e0 	movh	lr,0xffe0
8000d26e:	58 0a       	cp.w	r10,0
8000d270:	fc 0b 13 00 	cpc	r11,lr
8000d274:	e0 8b 00 1d 	brhi	8000d2ae <__avr32_f64_cmp_ge+0x52>
8000d278:	58 08       	cp.w	r8,0
8000d27a:	fc 09 13 00 	cpc	r9,lr
8000d27e:	e0 8b 00 18 	brhi	8000d2ae <__avr32_f64_cmp_ge+0x52>
8000d282:	58 0b       	cp.w	r11,0
8000d284:	f5 ba 00 00 	subfeq	r10,0
8000d288:	c1 50       	breq	8000d2b2 <__avr32_f64_cmp_ge+0x56>
8000d28a:	1b 07       	ld.w	r7,sp++
8000d28c:	1b 0e       	ld.w	lr,sp++
8000d28e:	58 3c       	cp.w	r12,3
8000d290:	c0 a0       	breq	8000d2a4 <__avr32_f64_cmp_ge+0x48>
8000d292:	58 1c       	cp.w	r12,1
8000d294:	c0 33       	brcs	8000d29a <__avr32_f64_cmp_ge+0x3e>
8000d296:	5e 0f       	reteq	1
8000d298:	5e 1d       	retne	0
8000d29a:	10 3a       	cp.w	r10,r8
8000d29c:	f2 0b 13 00 	cpc	r11,r9
8000d2a0:	5e 2f       	reths	1
8000d2a2:	5e 3d       	retlo	0
8000d2a4:	14 38       	cp.w	r8,r10
8000d2a6:	f6 09 13 00 	cpc	r9,r11
8000d2aa:	5e 2f       	reths	1
8000d2ac:	5e 3d       	retlo	0
8000d2ae:	1b 07       	ld.w	r7,sp++
8000d2b0:	d8 0a       	popm	pc,r12=0
8000d2b2:	58 17       	cp.w	r7,1
8000d2b4:	5f 0c       	sreq	r12
8000d2b6:	58 09       	cp.w	r9,0
8000d2b8:	f5 b8 00 00 	subfeq	r8,0
8000d2bc:	1b 07       	ld.w	r7,sp++
8000d2be:	1b 0e       	ld.w	lr,sp++
8000d2c0:	5e 0f       	reteq	1
8000d2c2:	5e fc       	retal	r12

8000d2c4 <__avr32_f64_cmp_lt>:
8000d2c4:	1a de       	st.w	--sp,lr
8000d2c6:	1a d7       	st.w	--sp,r7
8000d2c8:	a1 7b       	lsl	r11,0x1
8000d2ca:	5f 3c       	srlo	r12
8000d2cc:	a1 79       	lsl	r9,0x1
8000d2ce:	5f 37       	srlo	r7
8000d2d0:	5c fc       	rol	r12
8000d2d2:	fc 1e ff e0 	movh	lr,0xffe0
8000d2d6:	58 0a       	cp.w	r10,0
8000d2d8:	fc 0b 13 00 	cpc	r11,lr
8000d2dc:	e0 8b 00 1d 	brhi	8000d316 <__avr32_f64_cmp_lt+0x52>
8000d2e0:	58 08       	cp.w	r8,0
8000d2e2:	fc 09 13 00 	cpc	r9,lr
8000d2e6:	e0 8b 00 18 	brhi	8000d316 <__avr32_f64_cmp_lt+0x52>
8000d2ea:	58 0b       	cp.w	r11,0
8000d2ec:	f5 ba 00 00 	subfeq	r10,0
8000d2f0:	c1 50       	breq	8000d31a <__avr32_f64_cmp_lt+0x56>
8000d2f2:	1b 07       	ld.w	r7,sp++
8000d2f4:	1b 0e       	ld.w	lr,sp++
8000d2f6:	58 3c       	cp.w	r12,3
8000d2f8:	c0 a0       	breq	8000d30c <__avr32_f64_cmp_lt+0x48>
8000d2fa:	58 1c       	cp.w	r12,1
8000d2fc:	c0 33       	brcs	8000d302 <__avr32_f64_cmp_lt+0x3e>
8000d2fe:	5e 0d       	reteq	0
8000d300:	5e 1f       	retne	1
8000d302:	10 3a       	cp.w	r10,r8
8000d304:	f2 0b 13 00 	cpc	r11,r9
8000d308:	5e 2d       	reths	0
8000d30a:	5e 3f       	retlo	1
8000d30c:	14 38       	cp.w	r8,r10
8000d30e:	f6 09 13 00 	cpc	r9,r11
8000d312:	5e 2d       	reths	0
8000d314:	5e 3f       	retlo	1
8000d316:	1b 07       	ld.w	r7,sp++
8000d318:	d8 0a       	popm	pc,r12=0
8000d31a:	58 17       	cp.w	r7,1
8000d31c:	5f 1c       	srne	r12
8000d31e:	58 09       	cp.w	r9,0
8000d320:	f5 b8 00 00 	subfeq	r8,0
8000d324:	1b 07       	ld.w	r7,sp++
8000d326:	1b 0e       	ld.w	lr,sp++
8000d328:	5e 0d       	reteq	0
8000d32a:	5e fc       	retal	r12

8000d32c <__avr32_f64_div>:
8000d32c:	eb cd 40 ff 	pushm	r0-r7,lr
8000d330:	f7 e9 20 0e 	eor	lr,r11,r9
8000d334:	f6 07 16 14 	lsr	r7,r11,0x14
8000d338:	a9 7b       	lsl	r11,0x9
8000d33a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d33e:	a9 7a       	lsl	r10,0x9
8000d340:	bd bb       	sbr	r11,0x1d
8000d342:	e4 1b 3f ff 	andh	r11,0x3fff
8000d346:	ab d7       	cbr	r7,0xb
8000d348:	e0 80 00 cc 	breq	8000d4e0 <__avr32_f64_div_round_subnormal+0x54>
8000d34c:	e0 47 07 ff 	cp.w	r7,2047
8000d350:	e0 84 00 b5 	brge	8000d4ba <__avr32_f64_div_round_subnormal+0x2e>
8000d354:	f2 06 16 14 	lsr	r6,r9,0x14
8000d358:	a9 79       	lsl	r9,0x9
8000d35a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d35e:	a9 78       	lsl	r8,0x9
8000d360:	bd b9       	sbr	r9,0x1d
8000d362:	e4 19 3f ff 	andh	r9,0x3fff
8000d366:	ab d6       	cbr	r6,0xb
8000d368:	e0 80 00 e2 	breq	8000d52c <__avr32_f64_div_round_subnormal+0xa0>
8000d36c:	e0 46 07 ff 	cp.w	r6,2047
8000d370:	e0 84 00 b2 	brge	8000d4d4 <__avr32_f64_div_round_subnormal+0x48>
8000d374:	0c 17       	sub	r7,r6
8000d376:	fe 37 fc 01 	sub	r7,-1023
8000d37a:	fc 1c 80 00 	movh	r12,0x8000
8000d37e:	f8 03 16 01 	lsr	r3,r12,0x1
8000d382:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d386:	5c d4       	com	r4
8000d388:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d38c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d390:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d394:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d398:	ea 03 15 02 	lsl	r3,r5,0x2
8000d39c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d3a0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d3a4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d3a8:	ea 03 15 02 	lsl	r3,r5,0x2
8000d3ac:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d3b0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d3b4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d3b8:	ea 03 15 02 	lsl	r3,r5,0x2
8000d3bc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d3c0:	e4 09 07 40 	macu.d	r0,r2,r9
8000d3c4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d3c8:	02 04       	add	r4,r1
8000d3ca:	5c 05       	acr	r5
8000d3cc:	a3 65       	lsl	r5,0x2
8000d3ce:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d3d2:	a3 64       	lsl	r4,0x2
8000d3d4:	5c 34       	neg	r4
8000d3d6:	f8 05 01 45 	sbc	r5,r12,r5
8000d3da:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d3de:	e4 05 07 40 	macu.d	r0,r2,r5
8000d3e2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d3e6:	02 04       	add	r4,r1
8000d3e8:	5c 05       	acr	r5
8000d3ea:	ea 03 15 02 	lsl	r3,r5,0x2
8000d3ee:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d3f2:	e8 02 15 02 	lsl	r2,r4,0x2
8000d3f6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d3fa:	e4 09 07 40 	macu.d	r0,r2,r9
8000d3fe:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d402:	02 04       	add	r4,r1
8000d404:	5c 05       	acr	r5
8000d406:	a3 65       	lsl	r5,0x2
8000d408:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d40c:	a3 64       	lsl	r4,0x2
8000d40e:	5c 34       	neg	r4
8000d410:	f8 05 01 45 	sbc	r5,r12,r5
8000d414:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d418:	e4 05 07 40 	macu.d	r0,r2,r5
8000d41c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d420:	02 04       	add	r4,r1
8000d422:	5c 05       	acr	r5
8000d424:	ea 03 15 02 	lsl	r3,r5,0x2
8000d428:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d42c:	e8 02 15 02 	lsl	r2,r4,0x2
8000d430:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d434:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d438:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d43c:	02 02       	add	r2,r1
8000d43e:	5c 03       	acr	r3
8000d440:	ed b3 00 1c 	bld	r3,0x1c
8000d444:	c0 90       	breq	8000d456 <__avr32_f64_div+0x12a>
8000d446:	a1 72       	lsl	r2,0x1
8000d448:	5c f3       	rol	r3
8000d44a:	20 17       	sub	r7,1
8000d44c:	a3 9a       	lsr	r10,0x3
8000d44e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d452:	a3 9b       	lsr	r11,0x3
8000d454:	c0 58       	rjmp	8000d45e <__avr32_f64_div+0x132>
8000d456:	a5 8a       	lsr	r10,0x4
8000d458:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d45c:	a5 8b       	lsr	r11,0x4
8000d45e:	58 07       	cp.w	r7,0
8000d460:	e0 8a 00 8b 	brle	8000d576 <__avr32_f64_div_res_subnormal>
8000d464:	e0 12 ff 00 	andl	r2,0xff00
8000d468:	e8 12 00 80 	orl	r2,0x80
8000d46c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d470:	e4 09 07 40 	macu.d	r0,r2,r9
8000d474:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d478:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d47c:	00 05       	add	r5,r0
8000d47e:	f0 01 00 48 	adc	r8,r8,r1
8000d482:	5c 09       	acr	r9
8000d484:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d488:	58 04       	cp.w	r4,0
8000d48a:	5c 25       	cpc	r5

8000d48c <__avr32_f64_div_round_subnormal>:
8000d48c:	f4 08 13 00 	cpc	r8,r10
8000d490:	f6 09 13 00 	cpc	r9,r11
8000d494:	5f 36       	srlo	r6
8000d496:	f8 06 17 00 	moveq	r6,r12
8000d49a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d49e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d4a2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d4a6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d4aa:	ed be 00 1f 	bld	lr,0x1f
8000d4ae:	ef bb 00 1f 	bst	r11,0x1f
8000d4b2:	0c 0a       	add	r10,r6
8000d4b4:	5c 0b       	acr	r11
8000d4b6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d4ba:	e4 1b 00 0f 	andh	r11,0xf
8000d4be:	14 4b       	or	r11,r10
8000d4c0:	e0 81 00 a7 	brne	8000d60e <__avr32_f64_div_res_subnormal+0x98>
8000d4c4:	f2 06 16 14 	lsr	r6,r9,0x14
8000d4c8:	ab d6       	cbr	r6,0xb
8000d4ca:	e0 46 07 ff 	cp.w	r6,2047
8000d4ce:	e0 81 00 a4 	brne	8000d616 <__avr32_f64_div_res_subnormal+0xa0>
8000d4d2:	c9 e8       	rjmp	8000d60e <__avr32_f64_div_res_subnormal+0x98>
8000d4d4:	e4 19 00 0f 	andh	r9,0xf
8000d4d8:	10 49       	or	r9,r8
8000d4da:	e0 81 00 9a 	brne	8000d60e <__avr32_f64_div_res_subnormal+0x98>
8000d4de:	c9 28       	rjmp	8000d602 <__avr32_f64_div_res_subnormal+0x8c>
8000d4e0:	a3 7b       	lsl	r11,0x3
8000d4e2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d4e6:	a3 7a       	lsl	r10,0x3
8000d4e8:	f5 eb 10 04 	or	r4,r10,r11
8000d4ec:	e0 80 00 a0 	breq	8000d62c <__avr32_f64_div_op1_zero>
8000d4f0:	f6 04 12 00 	clz	r4,r11
8000d4f4:	c1 70       	breq	8000d522 <__avr32_f64_div_round_subnormal+0x96>
8000d4f6:	c0 c3       	brcs	8000d50e <__avr32_f64_div_round_subnormal+0x82>
8000d4f8:	e8 05 11 20 	rsub	r5,r4,32
8000d4fc:	f6 04 09 4b 	lsl	r11,r11,r4
8000d500:	f4 05 0a 45 	lsr	r5,r10,r5
8000d504:	0a 4b       	or	r11,r5
8000d506:	f4 04 09 4a 	lsl	r10,r10,r4
8000d50a:	08 17       	sub	r7,r4
8000d50c:	c0 b8       	rjmp	8000d522 <__avr32_f64_div_round_subnormal+0x96>
8000d50e:	f4 04 12 00 	clz	r4,r10
8000d512:	f9 b4 03 00 	movlo	r4,0
8000d516:	f7 b4 02 e0 	subhs	r4,-32
8000d51a:	f4 04 09 4b 	lsl	r11,r10,r4
8000d51e:	30 0a       	mov	r10,0
8000d520:	08 17       	sub	r7,r4
8000d522:	a3 8a       	lsr	r10,0x2
8000d524:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d528:	a3 8b       	lsr	r11,0x2
8000d52a:	c1 1b       	rjmp	8000d34c <__avr32_f64_div+0x20>
8000d52c:	a3 79       	lsl	r9,0x3
8000d52e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d532:	a3 78       	lsl	r8,0x3
8000d534:	f3 e8 10 04 	or	r4,r9,r8
8000d538:	c6 f0       	breq	8000d616 <__avr32_f64_div_res_subnormal+0xa0>
8000d53a:	f2 04 12 00 	clz	r4,r9
8000d53e:	c1 70       	breq	8000d56c <__avr32_f64_div_round_subnormal+0xe0>
8000d540:	c0 c3       	brcs	8000d558 <__avr32_f64_div_round_subnormal+0xcc>
8000d542:	e8 05 11 20 	rsub	r5,r4,32
8000d546:	f2 04 09 49 	lsl	r9,r9,r4
8000d54a:	f0 05 0a 45 	lsr	r5,r8,r5
8000d54e:	0a 49       	or	r9,r5
8000d550:	f0 04 09 48 	lsl	r8,r8,r4
8000d554:	08 16       	sub	r6,r4
8000d556:	c0 b8       	rjmp	8000d56c <__avr32_f64_div_round_subnormal+0xe0>
8000d558:	f0 04 12 00 	clz	r4,r8
8000d55c:	f9 b4 03 00 	movlo	r4,0
8000d560:	f7 b4 02 e0 	subhs	r4,-32
8000d564:	f0 04 09 49 	lsl	r9,r8,r4
8000d568:	30 08       	mov	r8,0
8000d56a:	08 16       	sub	r6,r4
8000d56c:	a3 88       	lsr	r8,0x2
8000d56e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d572:	a3 89       	lsr	r9,0x2
8000d574:	cf ca       	rjmp	8000d36c <__avr32_f64_div+0x40>

8000d576 <__avr32_f64_div_res_subnormal>:
8000d576:	5c 37       	neg	r7
8000d578:	2f f7       	sub	r7,-1
8000d57a:	f1 b7 04 c0 	satu	r7,0x6
8000d57e:	e0 47 00 20 	cp.w	r7,32
8000d582:	c1 54       	brge	8000d5ac <__avr32_f64_div_res_subnormal+0x36>
8000d584:	ee 06 11 20 	rsub	r6,r7,32
8000d588:	e4 07 0a 42 	lsr	r2,r2,r7
8000d58c:	e6 06 09 4c 	lsl	r12,r3,r6
8000d590:	18 42       	or	r2,r12
8000d592:	e6 07 0a 43 	lsr	r3,r3,r7
8000d596:	f4 06 09 41 	lsl	r1,r10,r6
8000d59a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d59e:	f6 06 09 4c 	lsl	r12,r11,r6
8000d5a2:	18 4a       	or	r10,r12
8000d5a4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d5a8:	30 00       	mov	r0,0
8000d5aa:	c1 58       	rjmp	8000d5d4 <__avr32_f64_div_res_subnormal+0x5e>
8000d5ac:	ee 06 11 20 	rsub	r6,r7,32
8000d5b0:	f9 b0 00 00 	moveq	r0,0
8000d5b4:	f9 bc 00 00 	moveq	r12,0
8000d5b8:	c0 50       	breq	8000d5c2 <__avr32_f64_div_res_subnormal+0x4c>
8000d5ba:	f4 06 09 40 	lsl	r0,r10,r6
8000d5be:	f6 06 09 4c 	lsl	r12,r11,r6
8000d5c2:	e6 07 0a 42 	lsr	r2,r3,r7
8000d5c6:	30 03       	mov	r3,0
8000d5c8:	f4 07 0a 41 	lsr	r1,r10,r7
8000d5cc:	18 41       	or	r1,r12
8000d5ce:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d5d2:	30 0b       	mov	r11,0
8000d5d4:	e0 12 ff 00 	andl	r2,0xff00
8000d5d8:	e8 12 00 80 	orl	r2,0x80
8000d5dc:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d5e0:	e4 09 07 46 	macu.d	r6,r2,r9
8000d5e4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d5e8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d5ec:	0c 05       	add	r5,r6
8000d5ee:	f0 07 00 48 	adc	r8,r8,r7
8000d5f2:	5c 09       	acr	r9
8000d5f4:	30 07       	mov	r7,0
8000d5f6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d5fa:	00 34       	cp.w	r4,r0
8000d5fc:	e2 05 13 00 	cpc	r5,r1
8000d600:	c4 6b       	rjmp	8000d48c <__avr32_f64_div_round_subnormal>
8000d602:	1c 9b       	mov	r11,lr
8000d604:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d608:	30 0a       	mov	r10,0
8000d60a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d60e:	3f fb       	mov	r11,-1
8000d610:	30 0a       	mov	r10,0
8000d612:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d616:	f5 eb 10 04 	or	r4,r10,r11
8000d61a:	c0 90       	breq	8000d62c <__avr32_f64_div_op1_zero>
8000d61c:	1c 9b       	mov	r11,lr
8000d61e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d622:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d626:	30 0a       	mov	r10,0
8000d628:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d62c <__avr32_f64_div_op1_zero>:
8000d62c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d630:	ce f0       	breq	8000d60e <__avr32_f64_div_res_subnormal+0x98>
8000d632:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d636:	e0 44 07 ff 	cp.w	r4,2047
8000d63a:	ce 41       	brne	8000d602 <__avr32_f64_div_res_subnormal+0x8c>
8000d63c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d640:	ce 10       	breq	8000d602 <__avr32_f64_div_res_subnormal+0x8c>
8000d642:	ce 6b       	rjmp	8000d60e <__avr32_f64_div_res_subnormal+0x98>

8000d644 <__avr32_udiv64>:
8000d644:	d4 31       	pushm	r0-r7,lr
8000d646:	1a 97       	mov	r7,sp
8000d648:	20 3d       	sub	sp,12
8000d64a:	10 9c       	mov	r12,r8
8000d64c:	12 9e       	mov	lr,r9
8000d64e:	14 93       	mov	r3,r10
8000d650:	58 09       	cp.w	r9,0
8000d652:	e0 81 00 bd 	brne	8000d7cc <__avr32_udiv64+0x188>
8000d656:	16 38       	cp.w	r8,r11
8000d658:	e0 88 00 40 	brls	8000d6d8 <__avr32_udiv64+0x94>
8000d65c:	f0 08 12 00 	clz	r8,r8
8000d660:	c0 d0       	breq	8000d67a <__avr32_udiv64+0x36>
8000d662:	f6 08 09 4b 	lsl	r11,r11,r8
8000d666:	f0 09 11 20 	rsub	r9,r8,32
8000d66a:	f8 08 09 4c 	lsl	r12,r12,r8
8000d66e:	f4 09 0a 49 	lsr	r9,r10,r9
8000d672:	f4 08 09 43 	lsl	r3,r10,r8
8000d676:	f3 eb 10 0b 	or	r11,r9,r11
8000d67a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d67e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d682:	f6 0e 0d 00 	divu	r0,r11,lr
8000d686:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d68a:	00 99       	mov	r9,r0
8000d68c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d690:	e0 0a 02 48 	mul	r8,r0,r10
8000d694:	10 3b       	cp.w	r11,r8
8000d696:	c0 a2       	brcc	8000d6aa <__avr32_udiv64+0x66>
8000d698:	20 19       	sub	r9,1
8000d69a:	18 0b       	add	r11,r12
8000d69c:	18 3b       	cp.w	r11,r12
8000d69e:	c0 63       	brcs	8000d6aa <__avr32_udiv64+0x66>
8000d6a0:	10 3b       	cp.w	r11,r8
8000d6a2:	f7 b9 03 01 	sublo	r9,1
8000d6a6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d6aa:	f6 08 01 01 	sub	r1,r11,r8
8000d6ae:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d6b2:	e2 0e 0d 00 	divu	r0,r1,lr
8000d6b6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d6ba:	00 98       	mov	r8,r0
8000d6bc:	e0 0a 02 4a 	mul	r10,r0,r10
8000d6c0:	14 33       	cp.w	r3,r10
8000d6c2:	c0 82       	brcc	8000d6d2 <__avr32_udiv64+0x8e>
8000d6c4:	20 18       	sub	r8,1
8000d6c6:	18 03       	add	r3,r12
8000d6c8:	18 33       	cp.w	r3,r12
8000d6ca:	c0 43       	brcs	8000d6d2 <__avr32_udiv64+0x8e>
8000d6cc:	14 33       	cp.w	r3,r10
8000d6ce:	f7 b8 03 01 	sublo	r8,1
8000d6d2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d6d6:	cd f8       	rjmp	8000d894 <__avr32_udiv64+0x250>
8000d6d8:	58 08       	cp.w	r8,0
8000d6da:	c0 51       	brne	8000d6e4 <__avr32_udiv64+0xa0>
8000d6dc:	30 19       	mov	r9,1
8000d6de:	f2 08 0d 08 	divu	r8,r9,r8
8000d6e2:	10 9c       	mov	r12,r8
8000d6e4:	f8 06 12 00 	clz	r6,r12
8000d6e8:	c0 41       	brne	8000d6f0 <__avr32_udiv64+0xac>
8000d6ea:	18 1b       	sub	r11,r12
8000d6ec:	30 19       	mov	r9,1
8000d6ee:	c4 08       	rjmp	8000d76e <__avr32_udiv64+0x12a>
8000d6f0:	ec 01 11 20 	rsub	r1,r6,32
8000d6f4:	f4 01 0a 49 	lsr	r9,r10,r1
8000d6f8:	f8 06 09 4c 	lsl	r12,r12,r6
8000d6fc:	f6 06 09 48 	lsl	r8,r11,r6
8000d700:	f6 01 0a 41 	lsr	r1,r11,r1
8000d704:	f3 e8 10 08 	or	r8,r9,r8
8000d708:	f8 03 16 10 	lsr	r3,r12,0x10
8000d70c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d710:	e2 03 0d 00 	divu	r0,r1,r3
8000d714:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d718:	00 9e       	mov	lr,r0
8000d71a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d71e:	e0 05 02 49 	mul	r9,r0,r5
8000d722:	12 3b       	cp.w	r11,r9
8000d724:	c0 a2       	brcc	8000d738 <__avr32_udiv64+0xf4>
8000d726:	20 1e       	sub	lr,1
8000d728:	18 0b       	add	r11,r12
8000d72a:	18 3b       	cp.w	r11,r12
8000d72c:	c0 63       	brcs	8000d738 <__avr32_udiv64+0xf4>
8000d72e:	12 3b       	cp.w	r11,r9
8000d730:	f7 be 03 01 	sublo	lr,1
8000d734:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d738:	12 1b       	sub	r11,r9
8000d73a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d73e:	f6 03 0d 02 	divu	r2,r11,r3
8000d742:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d746:	04 99       	mov	r9,r2
8000d748:	e4 05 02 4b 	mul	r11,r2,r5
8000d74c:	16 38       	cp.w	r8,r11
8000d74e:	c0 a2       	brcc	8000d762 <__avr32_udiv64+0x11e>
8000d750:	20 19       	sub	r9,1
8000d752:	18 08       	add	r8,r12
8000d754:	18 38       	cp.w	r8,r12
8000d756:	c0 63       	brcs	8000d762 <__avr32_udiv64+0x11e>
8000d758:	16 38       	cp.w	r8,r11
8000d75a:	f7 b9 03 01 	sublo	r9,1
8000d75e:	f1 dc e3 08 	addcs	r8,r8,r12
8000d762:	f4 06 09 43 	lsl	r3,r10,r6
8000d766:	f0 0b 01 0b 	sub	r11,r8,r11
8000d76a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d76e:	f8 06 16 10 	lsr	r6,r12,0x10
8000d772:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d776:	f6 06 0d 00 	divu	r0,r11,r6
8000d77a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d77e:	00 9a       	mov	r10,r0
8000d780:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d784:	e0 0e 02 48 	mul	r8,r0,lr
8000d788:	10 3b       	cp.w	r11,r8
8000d78a:	c0 a2       	brcc	8000d79e <__avr32_udiv64+0x15a>
8000d78c:	20 1a       	sub	r10,1
8000d78e:	18 0b       	add	r11,r12
8000d790:	18 3b       	cp.w	r11,r12
8000d792:	c0 63       	brcs	8000d79e <__avr32_udiv64+0x15a>
8000d794:	10 3b       	cp.w	r11,r8
8000d796:	f7 ba 03 01 	sublo	r10,1
8000d79a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d79e:	f6 08 01 01 	sub	r1,r11,r8
8000d7a2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d7a6:	e2 06 0d 00 	divu	r0,r1,r6
8000d7aa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d7ae:	00 98       	mov	r8,r0
8000d7b0:	e0 0e 02 4b 	mul	r11,r0,lr
8000d7b4:	16 33       	cp.w	r3,r11
8000d7b6:	c0 82       	brcc	8000d7c6 <__avr32_udiv64+0x182>
8000d7b8:	20 18       	sub	r8,1
8000d7ba:	18 03       	add	r3,r12
8000d7bc:	18 33       	cp.w	r3,r12
8000d7be:	c0 43       	brcs	8000d7c6 <__avr32_udiv64+0x182>
8000d7c0:	16 33       	cp.w	r3,r11
8000d7c2:	f7 b8 03 01 	sublo	r8,1
8000d7c6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d7ca:	c6 98       	rjmp	8000d89c <__avr32_udiv64+0x258>
8000d7cc:	16 39       	cp.w	r9,r11
8000d7ce:	e0 8b 00 65 	brhi	8000d898 <__avr32_udiv64+0x254>
8000d7d2:	f2 09 12 00 	clz	r9,r9
8000d7d6:	c0 b1       	brne	8000d7ec <__avr32_udiv64+0x1a8>
8000d7d8:	10 3a       	cp.w	r10,r8
8000d7da:	5f 2a       	srhs	r10
8000d7dc:	1c 3b       	cp.w	r11,lr
8000d7de:	5f b8       	srhi	r8
8000d7e0:	10 4a       	or	r10,r8
8000d7e2:	f2 0a 18 00 	cp.b	r10,r9
8000d7e6:	c5 90       	breq	8000d898 <__avr32_udiv64+0x254>
8000d7e8:	30 18       	mov	r8,1
8000d7ea:	c5 98       	rjmp	8000d89c <__avr32_udiv64+0x258>
8000d7ec:	f0 09 09 46 	lsl	r6,r8,r9
8000d7f0:	f2 03 11 20 	rsub	r3,r9,32
8000d7f4:	fc 09 09 4e 	lsl	lr,lr,r9
8000d7f8:	f0 03 0a 48 	lsr	r8,r8,r3
8000d7fc:	f6 09 09 4c 	lsl	r12,r11,r9
8000d800:	f4 03 0a 42 	lsr	r2,r10,r3
8000d804:	ef 46 ff f4 	st.w	r7[-12],r6
8000d808:	f6 03 0a 43 	lsr	r3,r11,r3
8000d80c:	18 42       	or	r2,r12
8000d80e:	f1 ee 10 0c 	or	r12,r8,lr
8000d812:	f8 01 16 10 	lsr	r1,r12,0x10
8000d816:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d81a:	e6 01 0d 04 	divu	r4,r3,r1
8000d81e:	e4 03 16 10 	lsr	r3,r2,0x10
8000d822:	08 9e       	mov	lr,r4
8000d824:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d828:	e8 06 02 48 	mul	r8,r4,r6
8000d82c:	10 33       	cp.w	r3,r8
8000d82e:	c0 a2       	brcc	8000d842 <__avr32_udiv64+0x1fe>
8000d830:	20 1e       	sub	lr,1
8000d832:	18 03       	add	r3,r12
8000d834:	18 33       	cp.w	r3,r12
8000d836:	c0 63       	brcs	8000d842 <__avr32_udiv64+0x1fe>
8000d838:	10 33       	cp.w	r3,r8
8000d83a:	f7 be 03 01 	sublo	lr,1
8000d83e:	e7 dc e3 03 	addcs	r3,r3,r12
8000d842:	10 13       	sub	r3,r8
8000d844:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d848:	e6 01 0d 00 	divu	r0,r3,r1
8000d84c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d850:	00 98       	mov	r8,r0
8000d852:	e0 06 02 46 	mul	r6,r0,r6
8000d856:	0c 3b       	cp.w	r11,r6
8000d858:	c0 a2       	brcc	8000d86c <__avr32_udiv64+0x228>
8000d85a:	20 18       	sub	r8,1
8000d85c:	18 0b       	add	r11,r12
8000d85e:	18 3b       	cp.w	r11,r12
8000d860:	c0 63       	brcs	8000d86c <__avr32_udiv64+0x228>
8000d862:	0c 3b       	cp.w	r11,r6
8000d864:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d868:	f7 b8 03 01 	sublo	r8,1
8000d86c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d870:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d874:	0c 1b       	sub	r11,r6
8000d876:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d87a:	06 95       	mov	r5,r3
8000d87c:	16 35       	cp.w	r5,r11
8000d87e:	e0 8b 00 0a 	brhi	8000d892 <__avr32_udiv64+0x24e>
8000d882:	5f 0b       	sreq	r11
8000d884:	f4 09 09 49 	lsl	r9,r10,r9
8000d888:	12 32       	cp.w	r2,r9
8000d88a:	5f b9       	srhi	r9
8000d88c:	f7 e9 00 09 	and	r9,r11,r9
8000d890:	c0 60       	breq	8000d89c <__avr32_udiv64+0x258>
8000d892:	20 18       	sub	r8,1
8000d894:	30 09       	mov	r9,0
8000d896:	c0 38       	rjmp	8000d89c <__avr32_udiv64+0x258>
8000d898:	30 09       	mov	r9,0
8000d89a:	12 98       	mov	r8,r9
8000d89c:	10 9a       	mov	r10,r8
8000d89e:	12 93       	mov	r3,r9
8000d8a0:	10 92       	mov	r2,r8
8000d8a2:	12 9b       	mov	r11,r9
8000d8a4:	2f dd       	sub	sp,-12
8000d8a6:	d8 32       	popm	r0-r7,pc

8000d8a8 <__avr32_umod64>:
8000d8a8:	d4 31       	pushm	r0-r7,lr
8000d8aa:	1a 97       	mov	r7,sp
8000d8ac:	20 3d       	sub	sp,12
8000d8ae:	10 9c       	mov	r12,r8
8000d8b0:	12 95       	mov	r5,r9
8000d8b2:	14 9e       	mov	lr,r10
8000d8b4:	16 91       	mov	r1,r11
8000d8b6:	16 96       	mov	r6,r11
8000d8b8:	58 09       	cp.w	r9,0
8000d8ba:	e0 81 00 81 	brne	8000d9bc <__avr32_umod64+0x114>
8000d8be:	16 38       	cp.w	r8,r11
8000d8c0:	e0 88 00 12 	brls	8000d8e4 <__avr32_umod64+0x3c>
8000d8c4:	f0 08 12 00 	clz	r8,r8
8000d8c8:	c4 e0       	breq	8000d964 <__avr32_umod64+0xbc>
8000d8ca:	f6 08 09 46 	lsl	r6,r11,r8
8000d8ce:	f8 08 09 4c 	lsl	r12,r12,r8
8000d8d2:	f0 0b 11 20 	rsub	r11,r8,32
8000d8d6:	f4 08 09 4e 	lsl	lr,r10,r8
8000d8da:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d8de:	f7 e6 10 06 	or	r6,r11,r6
8000d8e2:	c4 18       	rjmp	8000d964 <__avr32_umod64+0xbc>
8000d8e4:	58 08       	cp.w	r8,0
8000d8e6:	c0 51       	brne	8000d8f0 <__avr32_umod64+0x48>
8000d8e8:	30 19       	mov	r9,1
8000d8ea:	f2 08 0d 08 	divu	r8,r9,r8
8000d8ee:	10 9c       	mov	r12,r8
8000d8f0:	f8 08 12 00 	clz	r8,r12
8000d8f4:	c0 31       	brne	8000d8fa <__avr32_umod64+0x52>
8000d8f6:	18 16       	sub	r6,r12
8000d8f8:	c3 68       	rjmp	8000d964 <__avr32_umod64+0xbc>
8000d8fa:	f0 03 11 20 	rsub	r3,r8,32
8000d8fe:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d902:	f8 08 09 4c 	lsl	r12,r12,r8
8000d906:	ec 08 09 49 	lsl	r9,r6,r8
8000d90a:	ec 03 0a 43 	lsr	r3,r6,r3
8000d90e:	f7 e9 10 09 	or	r9,r11,r9
8000d912:	f8 05 16 10 	lsr	r5,r12,0x10
8000d916:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d91a:	e6 05 0d 02 	divu	r2,r3,r5
8000d91e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d922:	ec 02 02 4b 	mul	r11,r6,r2
8000d926:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d92a:	16 3e       	cp.w	lr,r11
8000d92c:	c0 72       	brcc	8000d93a <__avr32_umod64+0x92>
8000d92e:	18 0e       	add	lr,r12
8000d930:	18 3e       	cp.w	lr,r12
8000d932:	c0 43       	brcs	8000d93a <__avr32_umod64+0x92>
8000d934:	16 3e       	cp.w	lr,r11
8000d936:	fd dc e3 0e 	addcs	lr,lr,r12
8000d93a:	fc 0b 01 03 	sub	r3,lr,r11
8000d93e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d942:	e6 05 0d 02 	divu	r2,r3,r5
8000d946:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d94a:	a5 36       	mul	r6,r2
8000d94c:	0c 39       	cp.w	r9,r6
8000d94e:	c0 72       	brcc	8000d95c <__avr32_umod64+0xb4>
8000d950:	18 09       	add	r9,r12
8000d952:	18 39       	cp.w	r9,r12
8000d954:	c0 43       	brcs	8000d95c <__avr32_umod64+0xb4>
8000d956:	0c 39       	cp.w	r9,r6
8000d958:	f3 dc e3 09 	addcs	r9,r9,r12
8000d95c:	f2 06 01 06 	sub	r6,r9,r6
8000d960:	f4 08 09 4e 	lsl	lr,r10,r8
8000d964:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d968:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d96c:	ec 0a 0d 02 	divu	r2,r6,r10
8000d970:	fc 09 16 10 	lsr	r9,lr,0x10
8000d974:	ea 02 02 4b 	mul	r11,r5,r2
8000d978:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d97c:	16 39       	cp.w	r9,r11
8000d97e:	c0 72       	brcc	8000d98c <__avr32_umod64+0xe4>
8000d980:	18 09       	add	r9,r12
8000d982:	18 39       	cp.w	r9,r12
8000d984:	c0 43       	brcs	8000d98c <__avr32_umod64+0xe4>
8000d986:	16 39       	cp.w	r9,r11
8000d988:	f3 dc e3 09 	addcs	r9,r9,r12
8000d98c:	f2 0b 01 0b 	sub	r11,r9,r11
8000d990:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d994:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d998:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000d99c:	ea 0a 02 4a 	mul	r10,r5,r10
8000d9a0:	14 3e       	cp.w	lr,r10
8000d9a2:	c0 72       	brcc	8000d9b0 <__avr32_umod64+0x108>
8000d9a4:	18 0e       	add	lr,r12
8000d9a6:	18 3e       	cp.w	lr,r12
8000d9a8:	c0 43       	brcs	8000d9b0 <__avr32_umod64+0x108>
8000d9aa:	14 3e       	cp.w	lr,r10
8000d9ac:	fd dc e3 0e 	addcs	lr,lr,r12
8000d9b0:	fc 0a 01 0a 	sub	r10,lr,r10
8000d9b4:	30 0b       	mov	r11,0
8000d9b6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000d9ba:	c7 b8       	rjmp	8000dab0 <__avr32_umod64+0x208>
8000d9bc:	16 39       	cp.w	r9,r11
8000d9be:	e0 8b 00 79 	brhi	8000dab0 <__avr32_umod64+0x208>
8000d9c2:	f2 09 12 00 	clz	r9,r9
8000d9c6:	c1 21       	brne	8000d9ea <__avr32_umod64+0x142>
8000d9c8:	10 3a       	cp.w	r10,r8
8000d9ca:	5f 2b       	srhs	r11
8000d9cc:	0a 31       	cp.w	r1,r5
8000d9ce:	5f ba       	srhi	r10
8000d9d0:	f7 ea 10 0a 	or	r10,r11,r10
8000d9d4:	f2 0a 18 00 	cp.b	r10,r9
8000d9d8:	c0 60       	breq	8000d9e4 <__avr32_umod64+0x13c>
8000d9da:	fc 08 01 0c 	sub	r12,lr,r8
8000d9de:	e2 05 01 46 	sbc	r6,r1,r5
8000d9e2:	18 9e       	mov	lr,r12
8000d9e4:	0c 9b       	mov	r11,r6
8000d9e6:	1c 9a       	mov	r10,lr
8000d9e8:	c6 48       	rjmp	8000dab0 <__avr32_umod64+0x208>
8000d9ea:	ea 09 09 4c 	lsl	r12,r5,r9
8000d9ee:	f2 06 11 20 	rsub	r6,r9,32
8000d9f2:	f6 09 09 4b 	lsl	r11,r11,r9
8000d9f6:	f0 09 09 42 	lsl	r2,r8,r9
8000d9fa:	ef 46 ff f4 	st.w	r7[-12],r6
8000d9fe:	f0 06 0a 48 	lsr	r8,r8,r6
8000da02:	18 48       	or	r8,r12
8000da04:	e2 06 0a 4c 	lsr	r12,r1,r6
8000da08:	f4 09 09 43 	lsl	r3,r10,r9
8000da0c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000da10:	f4 06 0a 4a 	lsr	r10,r10,r6
8000da14:	16 4a       	or	r10,r11
8000da16:	f0 0b 16 10 	lsr	r11,r8,0x10
8000da1a:	f8 0b 0d 04 	divu	r4,r12,r11
8000da1e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000da22:	08 91       	mov	r1,r4
8000da24:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000da28:	e8 0e 02 46 	mul	r6,r4,lr
8000da2c:	0c 3c       	cp.w	r12,r6
8000da2e:	c0 a2       	brcc	8000da42 <__avr32_umod64+0x19a>
8000da30:	20 11       	sub	r1,1
8000da32:	10 0c       	add	r12,r8
8000da34:	10 3c       	cp.w	r12,r8
8000da36:	c0 63       	brcs	8000da42 <__avr32_umod64+0x19a>
8000da38:	0c 3c       	cp.w	r12,r6
8000da3a:	f7 b1 03 01 	sublo	r1,1
8000da3e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000da42:	0c 1c       	sub	r12,r6
8000da44:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000da48:	f8 0b 0d 04 	divu	r4,r12,r11
8000da4c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000da50:	08 96       	mov	r6,r4
8000da52:	e8 0e 02 4e 	mul	lr,r4,lr
8000da56:	1c 3b       	cp.w	r11,lr
8000da58:	c0 a2       	brcc	8000da6c <__avr32_umod64+0x1c4>
8000da5a:	20 16       	sub	r6,1
8000da5c:	10 0b       	add	r11,r8
8000da5e:	10 3b       	cp.w	r11,r8
8000da60:	c0 63       	brcs	8000da6c <__avr32_umod64+0x1c4>
8000da62:	1c 3b       	cp.w	r11,lr
8000da64:	f7 b6 03 01 	sublo	r6,1
8000da68:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000da6c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000da70:	1c 1b       	sub	r11,lr
8000da72:	e2 02 06 40 	mulu.d	r0,r1,r2
8000da76:	00 9e       	mov	lr,r0
8000da78:	02 9c       	mov	r12,r1
8000da7a:	16 3c       	cp.w	r12,r11
8000da7c:	e0 8b 00 08 	brhi	8000da8c <__avr32_umod64+0x1e4>
8000da80:	5f 06       	sreq	r6
8000da82:	06 30       	cp.w	r0,r3
8000da84:	5f ba       	srhi	r10
8000da86:	ed ea 00 0a 	and	r10,r6,r10
8000da8a:	c0 60       	breq	8000da96 <__avr32_umod64+0x1ee>
8000da8c:	fc 02 01 04 	sub	r4,lr,r2
8000da90:	f8 08 01 4c 	sbc	r12,r12,r8
8000da94:	08 9e       	mov	lr,r4
8000da96:	e6 0e 01 0a 	sub	r10,r3,lr
8000da9a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000da9e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000daa2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000daa6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000daaa:	f8 01 09 4c 	lsl	r12,r12,r1
8000daae:	18 4a       	or	r10,r12
8000dab0:	2f dd       	sub	sp,-12
8000dab2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000dc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000dc00:	c0 08       	rjmp	8000dc00 <_evba>
	...

8000dc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000dc04:	c0 08       	rjmp	8000dc04 <_handle_TLB_Multiple_Hit>
	...

8000dc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000dc08:	c0 08       	rjmp	8000dc08 <_handle_Bus_Error_Data_Fetch>
	...

8000dc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000dc0c:	c0 08       	rjmp	8000dc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000dc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000dc10:	c0 08       	rjmp	8000dc10 <_handle_NMI>
	...

8000dc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000dc14:	c0 08       	rjmp	8000dc14 <_handle_Instruction_Address>
	...

8000dc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000dc18:	c0 08       	rjmp	8000dc18 <_handle_ITLB_Protection>
	...

8000dc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000dc1c:	c0 08       	rjmp	8000dc1c <_handle_Breakpoint>
	...

8000dc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000dc20:	c0 08       	rjmp	8000dc20 <_handle_Illegal_Opcode>
	...

8000dc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000dc24:	c0 08       	rjmp	8000dc24 <_handle_Unimplemented_Instruction>
	...

8000dc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000dc28:	c0 08       	rjmp	8000dc28 <_handle_Privilege_Violation>
	...

8000dc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000dc2c:	c0 08       	rjmp	8000dc2c <_handle_Floating_Point>
	...

8000dc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000dc30:	c0 08       	rjmp	8000dc30 <_handle_Coprocessor_Absent>
	...

8000dc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000dc34:	c0 08       	rjmp	8000dc34 <_handle_Data_Address_Read>
	...

8000dc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000dc38:	c0 08       	rjmp	8000dc38 <_handle_Data_Address_Write>
	...

8000dc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000dc3c:	c0 08       	rjmp	8000dc3c <_handle_DTLB_Protection_Read>
	...

8000dc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000dc40:	c0 08       	rjmp	8000dc40 <_handle_DTLB_Protection_Write>
	...

8000dc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000dc44:	c0 08       	rjmp	8000dc44 <_handle_DTLB_Modified>
	...

8000dc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000dc50:	c0 08       	rjmp	8000dc50 <_handle_ITLB_Miss>
	...

8000dc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000dc60:	c0 08       	rjmp	8000dc60 <_handle_DTLB_Miss_Read>
	...

8000dc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000dc70:	c0 08       	rjmp	8000dc70 <_handle_DTLB_Miss_Write>
	...

8000dd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000dd00:	fe cf 71 28 	sub	pc,pc,28968

8000dd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000dd04:	30 0c       	mov	r12,0
8000dd06:	fe b0 c2 cf 	rcall	800062a4 <_get_interrupt_handler>
8000dd0a:	58 0c       	cp.w	r12,0
8000dd0c:	f8 0f 17 10 	movne	pc,r12
8000dd10:	d6 03       	rete

8000dd12 <_int1>:
8000dd12:	30 1c       	mov	r12,1
8000dd14:	fe b0 c2 c8 	rcall	800062a4 <_get_interrupt_handler>
8000dd18:	58 0c       	cp.w	r12,0
8000dd1a:	f8 0f 17 10 	movne	pc,r12
8000dd1e:	d6 03       	rete

8000dd20 <_int2>:
8000dd20:	30 2c       	mov	r12,2
8000dd22:	fe b0 c2 c1 	rcall	800062a4 <_get_interrupt_handler>
8000dd26:	58 0c       	cp.w	r12,0
8000dd28:	f8 0f 17 10 	movne	pc,r12
8000dd2c:	d6 03       	rete

8000dd2e <_int3>:
8000dd2e:	30 3c       	mov	r12,3
8000dd30:	fe b0 c2 ba 	rcall	800062a4 <_get_interrupt_handler>
8000dd34:	58 0c       	cp.w	r12,0
8000dd36:	f8 0f 17 10 	movne	pc,r12
8000dd3a:	d6 03       	rete

8000dd3c <ipr_val>:
8000dd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000dd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddfc:	d7 03 d7 03                                         ....
