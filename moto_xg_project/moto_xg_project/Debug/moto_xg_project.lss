
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a8e0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ca00  8000ca00  0000ce00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001154  8000cc00  8000cc00  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000dd54  8000dd54  0000e154  2**0
                  ALLOC
  6 .data         00000a2c  00000004  8000dd58  0000e404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000046e8  00000a30  8000e784  0000ee30  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000ee30  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001290  00000000  00000000  0000ee60  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000028a8  00000000  00000000  000100f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00029e1b  00000000  00000000  00012998  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006cff  00000000  00000000  0003c7b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00016334  00000000  00000000  000434b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000031e0  00000000  00000000  000597e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000737c  00000000  00000000  0005c9c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000da68  00000000  00000000  00063d44  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macinfo 0162e0a1  00000000  00000000  000717ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001368  00000000  00000000  0169f850  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c6 f8 	sub	pc,pc,-14600

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 84       	ld.ub	r4,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 48       	or	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	40 c8       	lddsp	r8,sp[0x30]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 70       	sub	r0,-121
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 10       	sub	r0,-111
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	cc 00       	breq	80002002 <program_start+0x2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 fc       	sub	r12,127
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	68 00       	ld.w	r0,r4[0x0]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 40       	or	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	cc 08       	rjmp	8000221e <ButtonConfig_brdcst_func+0x9e>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6b c4       	ld.w	r4,r5[0x70]

800020a4 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a4:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a6:	48 3c       	lddpc	r12,800020b0 <FD_brdcst_func+0xc>
800020a8:	f0 1f 00 03 	mcall	800020b4 <FD_brdcst_func+0x10>
	
}
800020ac:	d8 02       	popm	pc
800020ae:	00 00       	add	r0,r0
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	cc 0c       	rcall	80002232 <ButtonConfig_brdcst_func+0xb2>
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	6b c4       	ld.w	r4,r5[0x70]

800020b8 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ba:	48 3c       	lddpc	r12,800020c4 <FD_reply_func+0xc>
800020bc:	f0 1f 00 03 	mcall	800020c8 <FD_reply_func+0x10>
	
	
}
800020c0:	d8 02       	popm	pc
800020c2:	00 00       	add	r0,r0
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	cc 2c       	rcall	8000224a <ButtonConfig_brdcst_func+0xca>
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	6b c4       	ld.w	r4,r5[0x70]

800020cc <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020cc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ce:	48 3c       	lddpc	r12,800020d8 <FD_request_func+0xc>
800020d0:	f0 1f 00 03 	mcall	800020dc <FD_request_func+0x10>
	
	
}
800020d4:	d8 02       	popm	pc
800020d6:	00 00       	add	r0,r0
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	cc 48       	rjmp	80002262 <Phyuserinput_brdcst_func+0x6>
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	6b c4       	ld.w	r4,r5[0x70]

800020e0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e2:	48 3c       	lddpc	r12,800020ec <EnOB_brdcst_func+0xc>
800020e4:	f0 1f 00 03 	mcall	800020f0 <EnOB_brdcst_func+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	cc 64       	brge	8000207a <app_init+0x3e>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	6b c4       	ld.w	r4,r5[0x70]

800020f4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f4:	eb cd 40 80 	pushm	r7,lr
800020f8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fa:	19 a9       	ld.ub	r9,r12[0x2]
800020fc:	30 08       	mov	r8,0
800020fe:	f0 09 18 00 	cp.b	r9,r8
80002102:	c1 91       	brne	80002134 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002104:	19 b8       	ld.ub	r8,r12[0x3]
80002106:	30 19       	mov	r9,1
80002108:	f2 08 18 00 	cp.b	r8,r9
8000210c:	c0 61       	brne	80002118 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210e:	49 0c       	lddpc	r12,8000214c <EnOB_reply_func+0x58>
80002110:	f0 1f 00 10 	mcall	80002150 <EnOB_reply_func+0x5c>
80002114:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002118:	58 08       	cp.w	r8,0
8000211a:	c0 61       	brne	80002126 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000211c:	48 ec       	lddpc	r12,80002154 <EnOB_reply_func+0x60>
8000211e:	f0 1f 00 0d 	mcall	80002150 <EnOB_reply_func+0x5c>
80002122:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002126:	1a d8       	st.w	--sp,r8
80002128:	48 cc       	lddpc	r12,80002158 <EnOB_reply_func+0x64>
8000212a:	f0 1f 00 0a 	mcall	80002150 <EnOB_reply_func+0x5c>
8000212e:	2f fd       	sub	sp,-4
80002130:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002134:	48 ac       	lddpc	r12,8000215c <EnOB_reply_func+0x68>
80002136:	f0 1f 00 07 	mcall	80002150 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213a:	0f a8       	ld.ub	r8,r7[0x2]
8000213c:	1a d8       	st.w	--sp,r8
8000213e:	48 9c       	lddpc	r12,80002160 <EnOB_reply_func+0x6c>
80002140:	f0 1f 00 04 	mcall	80002150 <EnOB_reply_func+0x5c>
80002144:	2f fd       	sub	sp,-4
80002146:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214a:	00 00       	add	r0,r0
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	cc 7c       	rcall	800022dc <ButtonConfig_reply_func+0x3c>
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	6b c4       	ld.w	r4,r5[0x70]
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	cc 94       	brge	800020e8 <EnOB_brdcst_func+0x8>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	cc a8       	rjmp	800022ee <DataSession_brdcst_func+0xa>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	cc c0       	breq	800020f6 <EnOB_reply_func+0x2>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	cc dc       	rcall	800022fc <DataSession_brdcst_func+0x18>

80002164 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 41       	brne	80002176 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 2c       	lddpc	r12,80002178 <SingleDetection_brdcst_func+0x14>
80002172:	f0 1f 00 03 	mcall	8000217c <SingleDetection_brdcst_func+0x18>
80002176:	d8 02       	popm	pc
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	cc f4       	brge	80002118 <EnOB_reply_func+0x24>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	6b c4       	ld.w	r4,r5[0x70]

80002180 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002180:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002182:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002186:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002188:	4a bc       	lddpc	r12,80002234 <ButtonConfig_brdcst_func+0xb4>
8000218a:	f0 1f 00 2c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000218e:	0f 88       	ld.ub	r8,r7[0x0]
80002190:	1a d8       	st.w	--sp,r8
80002192:	4a bc       	lddpc	r12,8000223c <ButtonConfig_brdcst_func+0xbc>
80002194:	f0 1f 00 29 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002198:	1a d5       	st.w	--sp,r5
8000219a:	4a ac       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xc0>
8000219c:	f0 1f 00 27 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a0:	0f a8       	ld.ub	r8,r7[0x2]
800021a2:	1a d8       	st.w	--sp,r8
800021a4:	4a 8c       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc4>
800021a6:	f0 1f 00 25 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021aa:	2f dd       	sub	sp,-12
800021ac:	58 05       	cp.w	r5,0
800021ae:	c4 10       	breq	80002230 <ButtonConfig_brdcst_func+0xb0>
800021b0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b2:	4a 64       	lddpc	r4,80002248 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b4:	4a 63       	lddpc	r3,8000224c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021b6:	4a 72       	lddpc	r2,80002250 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021b8:	4a 71       	lddpc	r1,80002254 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ba:	4a 80       	lddpc	r0,80002258 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021bc:	0f b9       	ld.ub	r9,r7[0x3]
800021be:	0f c8       	ld.ub	r8,r7[0x4]
800021c0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	1a d6       	st.w	--sp,r6
800021c8:	08 9c       	mov	r12,r4
800021ca:	f0 1f 00 1c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ce:	0f d9       	ld.ub	r9,r7[0x5]
800021d0:	0f e8       	ld.ub	r8,r7[0x6]
800021d2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	1a d6       	st.w	--sp,r6
800021da:	06 9c       	mov	r12,r3
800021dc:	f0 1f 00 17 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e0:	0f f9       	ld.ub	r9,r7[0x7]
800021e2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021e6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ea:	1a d8       	st.w	--sp,r8
800021ec:	1a d6       	st.w	--sp,r6
800021ee:	04 9c       	mov	r12,r2
800021f0:	f0 1f 00 12 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f4:	ef 39 00 09 	ld.ub	r9,r7[9]
800021f8:	ef 38 00 0a 	ld.ub	r8,r7[10]
800021fc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002200:	1a d8       	st.w	--sp,r8
80002202:	1a d6       	st.w	--sp,r6
80002204:	02 9c       	mov	r12,r1
80002206:	f0 1f 00 0d 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220a:	2f 8d       	sub	sp,-32
8000220c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002210:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	00 9c       	mov	r12,r0
8000221e:	f0 1f 00 07 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
80002222:	2f f6       	sub	r6,-1
80002224:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002226:	2f ed       	sub	sp,-8
80002228:	ec 05 18 00 	cp.b	r5,r6
8000222c:	fe 9b ff c8 	brhi	800021bc <ButtonConfig_brdcst_func+0x3c>
80002230:	d8 32       	popm	r0-r7,pc
80002232:	00 00       	add	r0,r0
80002234:	80 00       	ld.sh	r0,r0[0x0]
80002236:	cd 08       	rjmp	800023d6 <DataSession_reply_func+0x12>
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	6b c4       	ld.w	r4,r5[0x70]
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	cd 28       	rjmp	800023e2 <DataSession_reply_func+0x1e>
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	cd 3c       	rcall	800023e8 <DataSession_reply_func+0x24>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	cd 54       	brge	800021f0 <ButtonConfig_brdcst_func+0x70>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	cd 74       	brge	800021f8 <ButtonConfig_brdcst_func+0x78>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	cd 9c       	rcall	80002400 <DataSession_reply_func+0x3c>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	cd c4       	brge	8000220a <ButtonConfig_brdcst_func+0x8a>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	cd e8       	rjmp	80002412 <DataSession_reply_func+0x4e>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	ce 10       	breq	8000221c <ButtonConfig_brdcst_func+0x9c>

8000225c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000225c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002260:	19 c7       	ld.ub	r7,r12[0x4]
80002262:	19 d8       	ld.ub	r8,r12[0x5]
80002264:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002268:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000226a:	48 ac       	lddpc	r12,80002290 <Phyuserinput_brdcst_func+0x34>
8000226c:	f0 1f 00 0a 	mcall	80002294 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002270:	36 08       	mov	r8,96
80002272:	f0 07 19 00 	cp.h	r7,r8
80002276:	c0 a1       	brne	8000228a <Phyuserinput_brdcst_func+0x2e>
80002278:	48 88       	lddpc	r8,80002298 <Phyuserinput_brdcst_func+0x3c>
8000227a:	11 89       	ld.ub	r9,r8[0x0]
8000227c:	30 18       	mov	r8,1
8000227e:	f0 09 18 00 	cp.b	r9,r8
80002282:	c0 41       	brne	8000228a <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
80002284:	48 6c       	lddpc	r12,8000229c <Phyuserinput_brdcst_func+0x40>
80002286:	f0 1f 00 04 	mcall	80002294 <Phyuserinput_brdcst_func+0x38>
8000228a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000228e:	00 00       	add	r0,r0
80002290:	80 00       	ld.sh	r0,r0[0x0]
80002292:	ce 34       	brge	80002258 <ButtonConfig_brdcst_func+0xd8>
80002294:	80 00       	ld.sh	r0,r0[0x0]
80002296:	6b c4       	ld.w	r4,r5[0x70]
80002298:	00 00       	add	r0,r0
8000229a:	0a 44       	or	r4,r5
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	ce 54       	brge	80002268 <Phyuserinput_brdcst_func+0xc>

800022a0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022a4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022a8:	0f 89       	ld.ub	r9,r7[0x0]
800022aa:	30 08       	mov	r8,0
800022ac:	f0 09 18 00 	cp.b	r9,r8
800022b0:	c0 c1       	brne	800022c8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022b2:	48 9c       	lddpc	r12,800022d4 <ButtonConfig_reply_func+0x34>
800022b4:	f0 1f 00 09 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022b8:	0f 98       	ld.ub	r8,r7[0x1]
800022ba:	1a d8       	st.w	--sp,r8
800022bc:	48 8c       	lddpc	r12,800022dc <ButtonConfig_reply_func+0x3c>
800022be:	f0 1f 00 07 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
800022c2:	2f fd       	sub	sp,-4
800022c4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022c8:	48 6c       	lddpc	r12,800022e0 <ButtonConfig_reply_func+0x40>
800022ca:	f0 1f 00 04 	mcall	800022d8 <ButtonConfig_reply_func+0x38>
800022ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	ce 64       	brge	800022a2 <ButtonConfig_reply_func+0x2>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	6b c4       	ld.w	r4,r5[0x70]
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cd 28       	rjmp	80002482 <CallControl_brdcst_func+0x42>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	ce 7c       	rcall	800024b0 <TransmitControl_brdcst_func+0x2c>

800022e4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800022e6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800022ea:	0d 88       	ld.ub	r8,r6[0x0]
800022ec:	32 49       	mov	r9,36
800022ee:	f2 08 18 00 	cp.b	r8,r9
800022f2:	c2 91       	brne	80002344 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800022f4:	4a dc       	lddpc	r12,800023a8 <DataSession_brdcst_func+0xc4>
800022f6:	f0 1f 00 2e 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800022fa:	0d a5       	ld.ub	r5,r6[0x2]
800022fc:	0d b8       	ld.ub	r8,r6[0x3]
800022fe:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002302:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002304:	0d 98       	ld.ub	r8,r6[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	4a ac       	lddpc	r12,800023b0 <DataSession_brdcst_func+0xcc>
8000230a:	f0 1f 00 29 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000230e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002312:	1a d8       	st.w	--sp,r8
80002314:	4a 8c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0xd0>
80002316:	f0 1f 00 26 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000231a:	2f ed       	sub	sp,-8
8000231c:	58 05       	cp.w	r5,0
8000231e:	c4 40       	breq	800023a6 <DataSession_brdcst_func+0xc2>
80002320:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002322:	4a 64       	lddpc	r4,800023b8 <DataSession_brdcst_func+0xd4>
80002324:	ec 07 00 08 	add	r8,r6,r7
80002328:	11 c8       	ld.ub	r8,r8[0x4]
8000232a:	1a d8       	st.w	--sp,r8
8000232c:	1a d7       	st.w	--sp,r7
8000232e:	08 9c       	mov	r12,r4
80002330:	f0 1f 00 1f 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002334:	2f f7       	sub	r7,-1
80002336:	5c 57       	castu.b	r7
80002338:	2f ed       	sub	sp,-8
8000233a:	ee 05 19 00 	cp.h	r5,r7
8000233e:	fe 9b ff f3 	brhi	80002324 <DataSession_brdcst_func+0x40>
80002342:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
80002344:	1a d8       	st.w	--sp,r8
80002346:	49 ec       	lddpc	r12,800023bc <DataSession_brdcst_func+0xd8>
80002348:	f0 1f 00 19 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		if (ptr->State)
8000234c:	2f fd       	sub	sp,-4
8000234e:	0d 89       	ld.ub	r9,r6[0x0]
80002350:	30 08       	mov	r8,0
80002352:	f0 09 18 00 	cp.b	r9,r8
80002356:	c0 40       	breq	8000235e <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
80002358:	49 ac       	lddpc	r12,800023c0 <DataSession_brdcst_func+0xdc>
8000235a:	f0 1f 00 15 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	49 1c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0xcc>
8000236e:	f0 1f 00 10 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 fc       	lddpc	r12,800023b4 <DataSession_brdcst_func+0xd0>
8000237a:	f0 1f 00 0d 	mcall	800023ac <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c1 20       	breq	800023a6 <DataSession_brdcst_func+0xc2>
80002384:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	48 d4       	lddpc	r4,800023b8 <DataSession_brdcst_func+0xd4>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 06 	mcall	800023ac <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0xa4>
800023a6:	d8 22       	popm	r4-r7,pc
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	ce 98       	rjmp	8000257c <Volume_reply_func+0x28>
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	6b c4       	ld.w	r4,r5[0x70]
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	ce ac       	rcall	80002586 <Volume_reply_func+0x32>
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	ce c4       	brge	8000238e <DataSession_brdcst_func+0xaa>
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	ce e0       	breq	80002396 <DataSession_brdcst_func+0xb2>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	ce f8       	rjmp	8000259c <Volume_reply_func+0x48>
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	cf 08       	rjmp	800025a2 <Volume_reply_func+0x4e>

800023c4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a9       	ld.ub	r9,r12[0x2]
800023cc:	30 08       	mov	r8,0
800023ce:	f0 09 18 00 	cp.b	r9,r8
800023d2:	c1 11       	brne	800023f4 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800023d4:	49 3c       	lddpc	r12,80002420 <DataSession_reply_func+0x5c>
800023d6:	f0 1f 00 14 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023da:	0f b8       	ld.ub	r8,r7[0x3]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	49 3c       	lddpc	r12,80002428 <DataSession_reply_func+0x64>
800023e0:	f0 1f 00 11 	mcall	80002424 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023e4:	0f c8       	ld.ub	r8,r7[0x4]
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	49 1c       	lddpc	r12,8000242c <DataSession_reply_func+0x68>
800023ea:	f0 1f 00 0f 	mcall	80002424 <DataSession_reply_func+0x60>
800023ee:	2f ed       	sub	sp,-8
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023f4:	48 fc       	lddpc	r12,80002430 <DataSession_reply_func+0x6c>
800023f6:	f0 1f 00 0c 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023fa:	0f a8       	ld.ub	r8,r7[0x2]
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	48 ec       	lddpc	r12,80002434 <DataSession_reply_func+0x70>
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002404:	0f b8       	ld.ub	r8,r7[0x3]
80002406:	1a d8       	st.w	--sp,r8
80002408:	48 cc       	lddpc	r12,80002438 <DataSession_reply_func+0x74>
8000240a:	f0 1f 00 07 	mcall	80002424 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000240e:	0f c8       	ld.ub	r8,r7[0x4]
80002410:	1a d8       	st.w	--sp,r8
80002412:	48 bc       	lddpc	r12,8000243c <DataSession_reply_func+0x78>
80002414:	f0 1f 00 04 	mcall	80002424 <DataSession_reply_func+0x60>
80002418:	2f dd       	sub	sp,-12
8000241a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000241e:	00 00       	add	r0,r0
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	cf 20       	breq	80002406 <DataSession_reply_func+0x42>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	6b c4       	ld.w	r4,r5[0x70]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	cf 30       	breq	80002410 <DataSession_reply_func+0x4c>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	cf 3c       	rcall	80002614 <spk_reply_func+0x24>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	cf 48       	rjmp	8000261a <spk_reply_func+0x2a>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	cf 58       	rjmp	80002620 <spk_reply_func+0x30>
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	cf 68       	rjmp	80002626 <spk_reply_func+0x36>
8000243c:	80 00       	ld.sh	r0,r0[0x0]
8000243e:	cf 74       	brge	8000242c <DataSession_reply_func+0x68>

80002440 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002440:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002444:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002448:	0f 98       	ld.ub	r8,r7[0x1]
8000244a:	1a d8       	st.w	--sp,r8
8000244c:	48 bc       	lddpc	r12,80002478 <CallControl_brdcst_func+0x38>
8000244e:	f0 1f 00 0c 	mcall	8000247c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002452:	2f fd       	sub	sp,-4
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 38       	mov	r8,3
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 41       	brne	80002464 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000245e:	30 09       	mov	r9,0
80002460:	48 88       	lddpc	r8,80002480 <CallControl_brdcst_func+0x40>
80002462:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002464:	0f 99       	ld.ub	r9,r7[0x1]
80002466:	30 48       	mov	r8,4
80002468:	f0 09 18 00 	cp.b	r9,r8
8000246c:	c0 41       	brne	80002474 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000246e:	30 19       	mov	r9,1
80002470:	48 48       	lddpc	r8,80002480 <CallControl_brdcst_func+0x40>
80002472:	b0 89       	st.b	r8[0x0],r9
80002474:	e3 cd 80 80 	ldm	sp++,r7,pc
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	cf 80       	breq	8000246a <CallControl_brdcst_func+0x2a>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	6b c4       	ld.w	r4,r5[0x70]
80002480:	00 00       	add	r0,r0
80002482:	0a 35       	cp.w	r5,r5

80002484 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 71       	brne	800024a2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002496:	48 ac       	lddpc	r12,800024bc <TransmitControl_brdcst_func+0x38>
80002498:	f0 1f 00 0a 	mcall	800024c0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
8000249c:	30 09       	mov	r9,0
8000249e:	48 a8       	lddpc	r8,800024c4 <TransmitControl_brdcst_func+0x40>
800024a0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024a2:	0f 99       	ld.ub	r9,r7[0x1]
800024a4:	30 18       	mov	r8,1
800024a6:	f0 09 18 00 	cp.b	r9,r8
800024aa:	c0 71       	brne	800024b8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024ac:	48 7c       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x44>
800024ae:	f0 1f 00 05 	mcall	800024c0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <TransmitControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	cf 98       	rjmp	800026b0 <mic_reply_func+0x20>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	6b c4       	ld.w	r4,r5[0x70]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 34       	cp.w	r4,r5
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cf b0       	breq	800024c0 <TransmitControl_brdcst_func+0x3c>

800024cc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024d0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024d4:	0f 89       	ld.ub	r9,r7[0x0]
800024d6:	30 08       	mov	r8,0
800024d8:	f0 09 18 00 	cp.b	r9,r8
800024dc:	c1 61       	brne	80002508 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024de:	48 ec       	lddpc	r12,80002514 <TransmitControl_reply_func+0x48>
800024e0:	f0 1f 00 0e 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024e4:	0f 98       	ld.ub	r8,r7[0x1]
800024e6:	1a d8       	st.w	--sp,r8
800024e8:	48 dc       	lddpc	r12,8000251c <TransmitControl_reply_func+0x50>
800024ea:	f0 1f 00 0c 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024ee:	0f a8       	ld.ub	r8,r7[0x2]
800024f0:	1a d8       	st.w	--sp,r8
800024f2:	48 cc       	lddpc	r12,80002520 <TransmitControl_reply_func+0x54>
800024f4:	f0 1f 00 09 	mcall	80002518 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024f8:	0f b8       	ld.ub	r8,r7[0x3]
800024fa:	1a d8       	st.w	--sp,r8
800024fc:	48 ac       	lddpc	r12,80002524 <TransmitControl_reply_func+0x58>
800024fe:	f0 1f 00 07 	mcall	80002518 <TransmitControl_reply_func+0x4c>
80002502:	2f dd       	sub	sp,-12
80002504:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002508:	48 8c       	lddpc	r12,80002528 <TransmitControl_reply_func+0x5c>
8000250a:	f0 1f 00 04 	mcall	80002518 <TransmitControl_reply_func+0x4c>
8000250e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002512:	00 00       	add	r0,r0
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	cf c4       	brge	8000250e <TransmitControl_reply_func+0x42>
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	6b c4       	ld.w	r4,r5[0x70]
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	cf e0       	breq	8000251a <TransmitControl_reply_func+0x4e>
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	cf f4       	brge	80002520 <TransmitControl_reply_func+0x54>
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d0 10       	acall	0x1
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	d0 20       	acall	0x2

8000252c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000252c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000252e:	19 a9       	ld.ub	r9,r12[0x2]
80002530:	30 08       	mov	r8,0
80002532:	f0 09 18 00 	cp.b	r9,r8
80002536:	c0 51       	brne	80002540 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002538:	48 4c       	lddpc	r12,80002548 <AudioRoutingControl_reply_func+0x1c>
8000253a:	f0 1f 00 05 	mcall	8000254c <AudioRoutingControl_reply_func+0x20>
8000253e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002540:	48 4c       	lddpc	r12,80002550 <AudioRoutingControl_reply_func+0x24>
80002542:	f0 1f 00 03 	mcall	8000254c <AudioRoutingControl_reply_func+0x20>
80002546:	d8 02       	popm	pc
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	d0 38       	*unknown*
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	6b c4       	ld.w	r4,r5[0x70]
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	d0 48       	*unknown*

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	d0 5c       	*unknown*
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	6b c4       	ld.w	r4,r5[0x70]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d0 70       	acall	0x7
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	d0 8c       	*unknown*
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d0 a4       	*unknown*

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 81       	brne	800025d2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025c4:	10 99       	mov	r9,r8
800025c6:	48 78       	lddpc	r8,800025e0 <spk_brdcst_func+0x28>
800025c8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025ca:	48 7c       	lddpc	r12,800025e4 <spk_brdcst_func+0x2c>
800025cc:	f0 1f 00 07 	mcall	800025e8 <spk_brdcst_func+0x30>
800025d0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800025d2:	30 19       	mov	r9,1
800025d4:	48 38       	lddpc	r8,800025e0 <spk_brdcst_func+0x28>
800025d6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025d8:	48 5c       	lddpc	r12,800025ec <spk_brdcst_func+0x34>
800025da:	f0 1f 00 04 	mcall	800025e8 <spk_brdcst_func+0x30>
800025de:	d8 02       	popm	pc
800025e0:	00 00       	add	r0,r0
800025e2:	0a 30       	cp.w	r0,r5
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	d0 bc       	*unknown*
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	6b c4       	ld.w	r4,r5[0x70]
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	d0 cc       	*unknown*

800025f0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025f2:	19 a9       	ld.ub	r9,r12[0x2]
800025f4:	30 08       	mov	r8,0
800025f6:	f0 09 18 00 	cp.b	r9,r8
800025fa:	c0 f1       	brne	80002618 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025fc:	19 e9       	ld.ub	r9,r12[0x6]
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 40       	breq	8000260a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002604:	30 19       	mov	r9,1
80002606:	48 98       	lddpc	r8,80002628 <spk_reply_func+0x38>
80002608:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000260a:	19 e8       	ld.ub	r8,r12[0x6]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	48 8c       	lddpc	r12,8000262c <spk_reply_func+0x3c>
80002610:	f0 1f 00 08 	mcall	80002630 <spk_reply_func+0x40>
80002614:	2f fd       	sub	sp,-4
80002616:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 48       	lddpc	r8,80002628 <spk_reply_func+0x38>
8000261c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000261e:	48 6c       	lddpc	r12,80002634 <spk_reply_func+0x44>
80002620:	f0 1f 00 04 	mcall	80002630 <spk_reply_func+0x40>
80002624:	d8 02       	popm	pc
80002626:	00 00       	add	r0,r0
80002628:	00 00       	add	r0,r0
8000262a:	0a 30       	cp.w	r0,r5
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	d0 d8       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	6b c4       	ld.w	r4,r5[0x70]
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d0 e8       	*unknown*

80002638 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002638:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000263c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002640:	0f a9       	ld.ub	r9,r7[0x2]
80002642:	30 08       	mov	r8,0
80002644:	f0 09 18 00 	cp.b	r9,r8
80002648:	c0 71       	brne	80002656 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000264a:	48 dc       	lddpc	r12,8000267c <mic_brdcst_func+0x44>
8000264c:	f0 1f 00 0d 	mcall	80002680 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002650:	30 09       	mov	r9,0
80002652:	48 d8       	lddpc	r8,80002684 <mic_brdcst_func+0x4c>
80002654:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002656:	0f a9       	ld.ub	r9,r7[0x2]
80002658:	31 18       	mov	r8,17
8000265a:	f0 09 18 00 	cp.b	r9,r8
8000265e:	c0 d1       	brne	80002678 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002660:	48 ac       	lddpc	r12,80002688 <mic_brdcst_func+0x50>
80002662:	f0 1f 00 08 	mcall	80002680 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002666:	48 89       	lddpc	r9,80002684 <mic_brdcst_func+0x4c>
80002668:	30 18       	mov	r8,1
8000266a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000266c:	13 89       	ld.ub	r9,r9[0x0]
8000266e:	f0 09 18 00 	cp.b	r9,r8
80002672:	c0 31       	brne	80002678 <mic_brdcst_func+0x40>
80002674:	48 68       	lddpc	r8,8000268c <mic_brdcst_func+0x54>
80002676:	11 88       	ld.ub	r8,r8[0x0]
80002678:	e3 cd 80 80 	ldm	sp++,r7,pc
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	d0 f4       	*unknown*
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	6b c4       	ld.w	r4,r5[0x70]
80002684:	00 00       	add	r0,r0
80002686:	0a 46       	or	r6,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	d1 08       	*unknown*
8000268c:	00 00       	add	r0,r0
8000268e:	0a 35       	cp.w	r5,r5

80002690 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002690:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002694:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002698:	49 ac       	lddpc	r12,80002700 <mic_reply_func+0x70>
8000269a:	f0 1f 00 1b 	mcall	80002704 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000269e:	0f 89       	ld.ub	r9,r7[0x0]
800026a0:	30 08       	mov	r8,0
800026a2:	f0 09 18 00 	cp.b	r9,r8
800026a6:	c2 71       	brne	800026f4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026a8:	0f 98       	ld.ub	r8,r7[0x1]
800026aa:	30 29       	mov	r9,2
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c1 b1       	brne	800026e6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026b2:	49 6c       	lddpc	r12,80002708 <mic_reply_func+0x78>
800026b4:	f0 1f 00 14 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026b8:	0f a8       	ld.ub	r8,r7[0x2]
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	49 4c       	lddpc	r12,8000270c <mic_reply_func+0x7c>
800026be:	f0 1f 00 12 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026c2:	0f b8       	ld.ub	r8,r7[0x3]
800026c4:	1a d8       	st.w	--sp,r8
800026c6:	49 3c       	lddpc	r12,80002710 <mic_reply_func+0x80>
800026c8:	f0 1f 00 0f 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026cc:	0f c8       	ld.ub	r8,r7[0x4]
800026ce:	1a d8       	st.w	--sp,r8
800026d0:	49 1c       	lddpc	r12,80002714 <mic_reply_func+0x84>
800026d2:	f0 1f 00 0d 	mcall	80002704 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026d6:	0f d8       	ld.ub	r8,r7[0x5]
800026d8:	1a d8       	st.w	--sp,r8
800026da:	49 0c       	lddpc	r12,80002718 <mic_reply_func+0x88>
800026dc:	f0 1f 00 0a 	mcall	80002704 <mic_reply_func+0x74>
800026e0:	2f cd       	sub	sp,-16
800026e2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026e6:	1a d8       	st.w	--sp,r8
800026e8:	48 dc       	lddpc	r12,8000271c <mic_reply_func+0x8c>
800026ea:	f0 1f 00 07 	mcall	80002704 <mic_reply_func+0x74>
800026ee:	2f fd       	sub	sp,-4
800026f0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026f4:	48 bc       	lddpc	r12,80002720 <mic_reply_func+0x90>
800026f6:	f0 1f 00 04 	mcall	80002704 <mic_reply_func+0x74>
800026fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fe:	00 00       	add	r0,r0
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d1 1c       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	6b c4       	ld.w	r4,r5[0x70]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d1 2c       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d1 40       	acall	0x14
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d1 54       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d1 70       	acall	0x17
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d1 88       	*unknown*
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	d1 a0       	acall	0x1a
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d1 b8       	*unknown*

80002724 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002724:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002728:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000272c:	48 bc       	lddpc	r12,80002758 <dcm_brdcst_func+0x34>
8000272e:	f0 1f 00 0c 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002732:	0f 88       	ld.ub	r8,r7[0x0]
80002734:	1a d8       	st.w	--sp,r8
80002736:	48 bc       	lddpc	r12,80002760 <dcm_brdcst_func+0x3c>
80002738:	f0 1f 00 09 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000273c:	0f a8       	ld.ub	r8,r7[0x2]
8000273e:	1a d8       	st.w	--sp,r8
80002740:	48 9c       	lddpc	r12,80002764 <dcm_brdcst_func+0x40>
80002742:	f0 1f 00 07 	mcall	8000275c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002746:	0f 98       	ld.ub	r8,r7[0x1]
80002748:	1a d8       	st.w	--sp,r8
8000274a:	48 8c       	lddpc	r12,80002768 <dcm_brdcst_func+0x44>
8000274c:	f0 1f 00 04 	mcall	8000275c <dcm_brdcst_func+0x38>
80002750:	2f dd       	sub	sp,-12
	
	
}
80002752:	e3 cd 80 80 	ldm	sp++,r7,pc
80002756:	00 00       	add	r0,r0
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	d1 c8       	*unknown*
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	6b c4       	ld.w	r4,r5[0x70]
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	d1 dc       	*unknown*
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	d1 f0       	acall	0x1f
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d2 08       	*unknown*

8000276c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000276c:	eb cd 40 80 	pushm	r7,lr
80002770:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002772:	19 a9       	ld.ub	r9,r12[0x2]
80002774:	30 08       	mov	r8,0
80002776:	f0 09 18 00 	cp.b	r9,r8
8000277a:	c1 b1       	brne	800027b0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000277c:	19 b8       	ld.ub	r8,r12[0x3]
8000277e:	30 19       	mov	r9,1
80002780:	f2 08 18 00 	cp.b	r8,r9
80002784:	c0 51       	brne	8000278e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002786:	48 ec       	lddpc	r12,800027bc <dcm_reply_func+0x50>
80002788:	f0 1f 00 0e 	mcall	800027c0 <dcm_reply_func+0x54>
8000278c:	c0 a8       	rjmp	800027a0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000278e:	58 08       	cp.w	r8,0
80002790:	c0 51       	brne	8000279a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002792:	48 dc       	lddpc	r12,800027c4 <dcm_reply_func+0x58>
80002794:	f0 1f 00 0b 	mcall	800027c0 <dcm_reply_func+0x54>
80002798:	c0 48       	rjmp	800027a0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000279a:	48 cc       	lddpc	r12,800027c8 <dcm_reply_func+0x5c>
8000279c:	f0 1f 00 09 	mcall	800027c0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027a0:	0f d8       	ld.ub	r8,r7[0x5]
800027a2:	1a d8       	st.w	--sp,r8
800027a4:	48 ac       	lddpc	r12,800027cc <dcm_reply_func+0x60>
800027a6:	f0 1f 00 07 	mcall	800027c0 <dcm_reply_func+0x54>
800027aa:	2f fd       	sub	sp,-4
800027ac:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027b0:	48 8c       	lddpc	r12,800027d0 <dcm_reply_func+0x64>
800027b2:	f0 1f 00 04 	mcall	800027c0 <dcm_reply_func+0x54>
800027b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ba:	00 00       	add	r0,r0
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	d2 24       	*unknown*
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	6b c4       	ld.w	r4,r5[0x70]
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	d2 38       	*unknown*
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	d2 4c       	*unknown*
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	d2 60       	acall	0x26
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	d2 6c       	*unknown*

800027d4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027d4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027d6:	19 a9       	ld.ub	r9,r12[0x2]
800027d8:	30 08       	mov	r8,0
800027da:	f0 09 18 00 	cp.b	r9,r8
800027de:	c0 51       	brne	800027e8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027e0:	48 4c       	lddpc	r12,800027f0 <ToneControl_reply_func+0x1c>
800027e2:	f0 1f 00 05 	mcall	800027f4 <ToneControl_reply_func+0x20>
800027e6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027e8:	48 4c       	lddpc	r12,800027f8 <ToneControl_reply_func+0x24>
800027ea:	f0 1f 00 03 	mcall	800027f4 <ToneControl_reply_func+0x20>
800027ee:	d8 02       	popm	pc
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	d2 78       	*unknown*
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	6b c4       	ld.w	r4,r5[0x70]
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	d2 84       	*unknown*

800027fc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027fc:	eb cd 40 fe 	pushm	r1-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002800:	f0 1f 00 14 	mcall	80002850 <app_cfg+0x54>
80002804:	49 48       	lddpc	r8,80002854 <app_cfg+0x58>
80002806:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002808:	49 46       	lddpc	r6,80002858 <app_cfg+0x5c>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000280a:	49 57       	lddpc	r7,8000285c <app_cfg+0x60>
				//if(rfid_auto_reader(card_id) == 0){
					//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
				//}
				//else
				{
					log("read card err!!!\n");
8000280c:	49 53       	lddpc	r3,80002860 <app_cfg+0x64>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
8000280e:	30 c1       	mov	r1,12
			connect_flag=1;	
80002810:	30 12       	mov	r2,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002812:	10 95       	mov	r5,r8
80002814:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002818:	6c 08       	ld.w	r8,r6[0x0]
8000281a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000281e:	58 38       	cp.w	r8,3
80002820:	c0 91       	brne	80002832 <app_cfg+0x36>
80002822:	0f 88       	ld.ub	r8,r7[0x0]
80002824:	58 08       	cp.w	r8,0
80002826:	c0 61       	brne	80002832 <app_cfg+0x36>
		{	
			xcmp_IdleTestTone(Priority_Beep);
80002828:	02 9c       	mov	r12,r1
8000282a:	f0 1f 00 0f 	mcall	80002864 <app_cfg+0x68>
			connect_flag=1;	
8000282e:	ae 82       	st.b	r7[0x0],r2
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002830:	c0 b8       	rjmp	80002846 <app_cfg+0x4a>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
80002832:	0f 88       	ld.ub	r8,r7[0x0]
80002834:	58 08       	cp.w	r8,0
80002836:	c0 50       	breq	80002840 <app_cfg+0x44>
				//if(rfid_auto_reader(card_id) == 0){
					//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
				//}
				//else
				{
					log("read card err!!!\n");
80002838:	06 9c       	mov	r12,r3
8000283a:	f0 1f 00 0c 	mcall	80002868 <app_cfg+0x6c>
8000283e:	c0 48       	rjmp	80002846 <app_cfg+0x4a>
				}
				
		}
		else
		{
			nop();
80002840:	d7 03       	nop
			nop();
80002842:	d7 03       	nop
			nop();
80002844:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002846:	08 9b       	mov	r11,r4
80002848:	0a 9c       	mov	r12,r5
8000284a:	f0 1f 00 09 	mcall	8000286c <app_cfg+0x70>
	}
8000284e:	ce 5b       	rjmp	80002818 <app_cfg+0x1c>
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	65 38       	ld.w	r8,r2[0x4c]
80002854:	00 00       	add	r0,r0
80002856:	0a 38       	cp.w	r8,r5
80002858:	00 00       	add	r0,r0
8000285a:	0d 84       	ld.ub	r4,r6[0x0]
8000285c:	00 00       	add	r0,r0
8000285e:	0a 44       	or	r4,r5
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	d2 90       	acall	0x29
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	41 c8       	lddsp	r8,sp[0x70]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	6b c4       	ld.w	r4,r5[0x70]
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	66 a0       	ld.w	r0,r3[0x28]

80002870 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002870:	eb cd 40 80 	pushm	r7,lr
80002874:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002876:	48 c9       	lddpc	r9,800028a4 <app_payload_rx_proc+0x34>
80002878:	13 88       	ld.ub	r8,r9[0x0]
8000287a:	2f f8       	sub	r8,-1
8000287c:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000287e:	30 39       	mov	r9,3
80002880:	f2 08 18 00 	cp.b	r8,r9
80002884:	c0 71       	brne	80002892 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002886:	30 09       	mov	r9,0
80002888:	48 78       	lddpc	r8,800028a4 <app_payload_rx_proc+0x34>
8000288a:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
8000288c:	48 7c       	lddpc	r12,800028a8 <app_payload_rx_proc+0x38>
8000288e:	f0 1f 00 08 	mcall	800028ac <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002892:	48 88       	lddpc	r8,800028b0 <app_payload_rx_proc+0x40>
80002894:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002896:	48 88       	lddpc	r8,800028b4 <app_payload_rx_proc+0x44>
80002898:	70 0c       	ld.w	r12,r8[0x0]
8000289a:	0e 9b       	mov	r11,r7
8000289c:	f0 1f 00 07 	mcall	800028b8 <app_payload_rx_proc+0x48>

}
800028a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a4:	00 00       	add	r0,r0
800028a6:	0a 45       	or	r5,r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	d2 a4       	*unknown*
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	6b c4       	ld.w	r4,r5[0x70]
800028b0:	00 00       	add	r0,r0
800028b2:	0a 33       	cp.w	r3,r5
800028b4:	00 00       	add	r0,r0
800028b6:	0a 94       	mov	r4,r5
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	29 e8       	sub	r8,-98

800028bc <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028bc:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028be:	19 e8       	ld.ub	r8,r12[0x6]
800028c0:	30 19       	mov	r9,1
800028c2:	f2 08 18 00 	cp.b	r8,r9
800028c6:	c0 61       	brne	800028d2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028c8:	48 98       	lddpc	r8,800028ec <DeviceInitializationStatus_brdcst_func+0x30>
800028ca:	70 09       	ld.w	r9,r8[0x0]
800028cc:	a1 a9       	sbr	r9,0x0
800028ce:	91 09       	st.w	r8[0x0],r9
800028d0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028d2:	30 29       	mov	r9,2
800028d4:	f2 08 18 00 	cp.b	r8,r9
800028d8:	c0 80       	breq	800028e8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028da:	48 58       	lddpc	r8,800028ec <DeviceInitializationStatus_brdcst_func+0x30>
800028dc:	70 09       	ld.w	r9,r8[0x0]
800028de:	e0 19 ff fc 	andl	r9,0xfffc
800028e2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028e4:	f0 1f 00 03 	mcall	800028f0 <DeviceInitializationStatus_brdcst_func+0x34>
800028e8:	d8 02       	popm	pc
800028ea:	00 00       	add	r0,r0
800028ec:	00 00       	add	r0,r0
800028ee:	0d 84       	ld.ub	r4,r6[0x0]
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	41 1c       	lddsp	r12,sp[0x44]

800028f4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028f4:	20 1c       	sub	r12,1
800028f6:	5c 5c       	castu.b	r12
800028f8:	31 18       	mov	r8,17
800028fa:	f0 0c 18 00 	cp.b	r12,r8
800028fe:	e0 88 00 03 	brls	80002904 <CalculateBurst+0x10>
80002902:	5e fd       	retal	0
80002904:	48 28       	lddpc	r8,8000290c <CalculateBurst+0x18>
80002906:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
8000290a:	5e fc       	retal	r12
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	d2 b8       	*unknown*

80002910 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002910:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002912:	48 98       	lddpc	r8,80002934 <payload_init+0x24>
80002914:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002916:	48 98       	lddpc	r8,80002938 <payload_init+0x28>
80002918:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000291a:	30 09       	mov	r9,0
8000291c:	1a d9       	st.w	--sp,r9
8000291e:	1a d9       	st.w	--sp,r9
80002920:	1a d9       	st.w	--sp,r9
80002922:	30 28       	mov	r8,2
80002924:	e0 6a 04 00 	mov	r10,1024
80002928:	48 5b       	lddpc	r11,8000293c <payload_init+0x2c>
8000292a:	48 6c       	lddpc	r12,80002940 <payload_init+0x30>
8000292c:	f0 1f 00 06 	mcall	80002944 <payload_init+0x34>
80002930:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002932:	d8 02       	popm	pc
80002934:	00 00       	add	r0,r0
80002936:	0a 4c       	or	r12,r5
80002938:	00 00       	add	r0,r0
8000293a:	0a 50       	eor	r0,r5
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	d3 00       	acall	0x30
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	29 48       	sub	r8,-108
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	68 00       	ld.w	r0,r4[0x0]

80002948 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002948:	eb cd 40 f8 	pushm	r3-r7,lr
8000294c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000294e:	48 e8       	lddpc	r8,80002984 <payload_rx_process+0x3c>
80002950:	70 08       	ld.w	r8,r8[0x0]
80002952:	58 08       	cp.w	r8,0
80002954:	c0 71       	brne	80002962 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002956:	30 4b       	mov	r11,4
80002958:	30 5c       	mov	r12,5
8000295a:	f0 1f 00 0c 	mcall	80002988 <payload_rx_process+0x40>
8000295e:	48 a8       	lddpc	r8,80002984 <payload_rx_process+0x3c>
80002960:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002962:	48 96       	lddpc	r6,80002984 <payload_rx_process+0x3c>
80002964:	30 05       	mov	r5,0
80002966:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002968:	48 93       	lddpc	r3,8000298c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000296a:	6c 0c       	ld.w	r12,r6[0x0]
8000296c:	0a 99       	mov	r9,r5
8000296e:	08 9a       	mov	r10,r4
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 08 	mcall	80002990 <payload_rx_process+0x48>
80002976:	58 1c       	cp.w	r12,1
80002978:	cf 91       	brne	8000296a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000297a:	66 08       	ld.w	r8,r3[0x0]
8000297c:	40 0c       	lddsp	r12,sp[0x0]
8000297e:	5d 18       	icall	r8
80002980:	cf 5b       	rjmp	8000296a <payload_rx_process+0x22>
80002982:	00 00       	add	r0,r0
80002984:	00 00       	add	r0,r0
80002986:	0a 64       	and	r4,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	61 2c       	ld.w	r12,r0[0x48]
8000298c:	00 00       	add	r0,r0
8000298e:	0a 4c       	or	r12,r5
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	5e 20       	reths	r0

80002994 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002994:	d4 01       	pushm	lr
80002996:	20 2d       	sub	sp,8
80002998:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000299a:	30 09       	mov	r9,0
8000299c:	fa ca ff f8 	sub	r10,sp,-8
800029a0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029a2:	1a 9b       	mov	r11,sp
800029a4:	f0 1f 00 02 	mcall	800029ac <set_idle_store_isr+0x18>
}
800029a8:	2f ed       	sub	sp,-8
800029aa:	d8 02       	popm	pc
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	5f dc       	srvc	r12

800029b0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029b0:	d4 01       	pushm	lr
800029b2:	20 2d       	sub	sp,8
800029b4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029b6:	58 0c       	cp.w	r12,0
800029b8:	c1 10       	breq	800029da <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029ba:	30 08       	mov	r8,0
800029bc:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029be:	98 88       	ld.uh	r8,r12[0x0]
800029c0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029c4:	e0 48 40 00 	cp.w	r8,16384
800029c8:	c0 91       	brne	800029da <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029ca:	48 68       	lddpc	r8,800029e0 <phy_rx+0x30>
800029cc:	70 0c       	ld.w	r12,r8[0x0]
800029ce:	30 09       	mov	r9,0
800029d0:	fa ca ff fc 	sub	r10,sp,-4
800029d4:	1a 9b       	mov	r11,sp
800029d6:	f0 1f 00 04 	mcall	800029e4 <phy_rx+0x34>
		}	

    }
		
 
}
800029da:	2f ed       	sub	sp,-8
800029dc:	d8 02       	popm	pc
800029de:	00 00       	add	r0,r0
800029e0:	00 00       	add	r0,r0
800029e2:	0a a8       	st.w	r5++,r8
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	5f dc       	srvc	r12

800029e8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029e8:	eb cd 40 80 	pushm	r7,lr
800029ec:	20 1d       	sub	sp,4
800029ee:	fa c7 ff fc 	sub	r7,sp,-4
800029f2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029f4:	30 09       	mov	r9,0
800029f6:	12 9a       	mov	r10,r9
800029f8:	1a 9b       	mov	r11,sp
800029fa:	f0 1f 00 03 	mcall	80002a04 <set_idle_store+0x1c>
}
800029fe:	2f fd       	sub	sp,-4
80002a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	60 2c       	ld.w	r12,r0[0x8]

80002a08 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a08:	d4 01       	pushm	lr
80002a0a:	20 1d       	sub	sp,4
80002a0c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a0e:	98 88       	ld.uh	r8,r12[0x0]
80002a10:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a14:	e0 48 40 00 	cp.w	r8,16384
80002a18:	c0 d1       	brne	80002a32 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a1a:	49 08       	lddpc	r8,80002a58 <phy_tx+0x50>
80002a1c:	70 08       	ld.w	r8,r8[0x0]
80002a1e:	58 08       	cp.w	r8,0
80002a20:	c1 a0       	breq	80002a54 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a22:	48 e8       	lddpc	r8,80002a58 <phy_tx+0x50>
80002a24:	70 0c       	ld.w	r12,r8[0x0]
80002a26:	30 09       	mov	r9,0
80002a28:	12 9a       	mov	r10,r9
80002a2a:	1a 9b       	mov	r11,sp
80002a2c:	f0 1f 00 0c 	mcall	80002a5c <phy_tx+0x54>
80002a30:	c1 28       	rjmp	80002a54 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a32:	e0 48 10 00 	cp.w	r8,4096
80002a36:	5f 0a       	sreq	r10
80002a38:	e0 48 20 00 	cp.w	r8,8192
80002a3c:	5f 09       	sreq	r9
80002a3e:	f5 e9 10 09 	or	r9,r10,r9
80002a42:	c0 71       	brne	80002a50 <phy_tx+0x48>
80002a44:	e0 48 50 00 	cp.w	r8,20480
80002a48:	c0 40       	breq	80002a50 <phy_tx+0x48>
80002a4a:	e0 48 60 00 	cp.w	r8,24576
80002a4e:	c0 31       	brne	80002a54 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a50:	48 48       	lddpc	r8,80002a60 <phy_tx+0x58>
80002a52:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a54:	2f fd       	sub	sp,-4
80002a56:	d8 02       	popm	pc
80002a58:	00 00       	add	r0,r0
80002a5a:	0a bc       	st.h	r5++,r12
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	60 2c       	ld.w	r12,r0[0x8]
80002a60:	00 00       	add	r0,r0
80002a62:	0a 9c       	mov	r12,r5

80002a64 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a64:	d4 01       	pushm	lr
80002a66:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a68:	30 08       	mov	r8,0
80002a6a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a6c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a6e:	1a 9a       	mov	r10,sp
80002a70:	fa cb ff fc 	sub	r11,sp,-4
80002a74:	f0 1f 00 05 	mcall	80002a88 <get_idle_store_isr+0x24>
80002a78:	58 1c       	cp.w	r12,1
80002a7a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a7e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a82:	2f ed       	sub	sp,-8
80002a84:	d8 02       	popm	pc
80002a86:	00 00       	add	r0,r0
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	5d 30       	musfr	r0

80002a8c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a90:	20 1d       	sub	sp,4
80002a92:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a94:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a98:	70 08       	ld.w	r8,r8[0x0]
80002a9a:	58 08       	cp.w	r8,0
80002a9c:	c7 40       	breq	80002b84 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a9e:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aa0:	30 08       	mov	r8,0
80002aa2:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002aa4:	fe f8 04 64 	ld.w	r8,pc[1124]
80002aa8:	70 08       	ld.w	r8,r8[0x0]
80002aaa:	58 18       	cp.w	r8,1
80002aac:	c2 90       	breq	80002afe <phy_tx_func+0x72>
80002aae:	c0 43       	brcs	80002ab6 <phy_tx_func+0x2a>
80002ab0:	58 28       	cp.w	r8,2
80002ab2:	c6 91       	brne	80002b84 <phy_tx_func+0xf8>
80002ab4:	c6 18       	rjmp	80002b76 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ab6:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	1a 9a       	mov	r10,sp
80002abe:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002ac2:	f0 1f 01 14 	mcall	80002f10 <phy_tx_func+0x484>
80002ac6:	58 1c       	cp.w	r12,1
80002ac8:	c1 51       	brne	80002af2 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aca:	fe f8 04 42 	ld.w	r8,pc[1090]
80002ace:	70 08       	ld.w	r8,r8[0x0]
80002ad0:	11 9a       	ld.ub	r10,r8[0x1]
80002ad2:	fe f9 04 42 	ld.w	r9,pc[1090]
80002ad6:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ad8:	90 88       	ld.uh	r8,r8[0x0]
80002ada:	ea 18 ab cd 	orh	r8,0xabcd
80002ade:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ae0:	30 19       	mov	r9,1
80002ae2:	fe f8 04 36 	ld.w	r8,pc[1078]
80002ae6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ae8:	30 19       	mov	r9,1
80002aea:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002aee:	91 09       	st.w	r8[0x0],r9
80002af0:	c4 a8       	rjmp	80002b84 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002af2:	e0 68 5a 5a 	mov	r8,23130
80002af6:	ea 18 ab cd 	orh	r8,0xabcd
80002afa:	8f 18       	st.w	r7[0x4],r8
80002afc:	c4 48       	rjmp	80002b84 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002afe:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002b02:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b04:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b08:	74 0a       	ld.w	r10,r10[0x0]
80002b0a:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b0e:	b1 6a       	lsl	r10,0x10
80002b10:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b12:	2f f8       	sub	r8,-1
80002b14:	5c 58       	castu.b	r8
80002b16:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b18:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b1c:	94 09       	ld.sh	r9,r10[0x0]
80002b1e:	20 29       	sub	r9,2
80002b20:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b22:	30 0a       	mov	r10,0
80002b24:	f4 09 19 00 	cp.h	r9,r10
80002b28:	e0 89 00 0b 	brgt	80002b3e <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b2c:	78 18       	ld.w	r8,r12[0x4]
80002b2e:	e8 18 00 ba 	orl	r8,0xba
80002b32:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b34:	30 09       	mov	r9,0
80002b36:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b3a:	91 09       	st.w	r8[0x0],r9
80002b3c:	c2 48       	rjmp	80002b84 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b3e:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b42:	72 09       	ld.w	r9,r9[0x0]
80002b44:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b48:	78 1a       	ld.w	r10,r12[0x4]
80002b4a:	f5 e9 10 09 	or	r9,r10,r9
80002b4e:	99 19       	st.w	r12[0x4],r9
80002b50:	2f f8       	sub	r8,-1
80002b52:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b56:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b58:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b5c:	92 08       	ld.sh	r8,r9[0x0]
80002b5e:	20 28       	sub	r8,2
80002b60:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b62:	30 09       	mov	r9,0
80002b64:	f2 08 19 00 	cp.h	r8,r9
80002b68:	e0 89 00 0e 	brgt	80002b84 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b6c:	30 29       	mov	r9,2
80002b6e:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b72:	91 09       	st.w	r8[0x0],r9
80002b74:	c0 88       	rjmp	80002b84 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b76:	fc 18 00 ba 	movh	r8,0xba
80002b7a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b7c:	30 09       	mov	r9,0
80002b7e:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b82:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b84:	fe f8 03 98 	ld.w	r8,pc[920]
80002b88:	11 89       	ld.ub	r9,r8[0x0]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f0 09 18 00 	cp.b	r9,r8
80002b90:	e0 81 01 af 	brne	80002eee <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b94:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	e0 48 05 b0 	cp.w	r8,1456
80002b9e:	f9 b8 02 00 	movhs	r8,0
80002ba2:	fe f9 03 7e 	ld.w	r9,pc[894]
80002ba6:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002ba8:	fe f8 03 7c 	ld.w	r8,pc[892]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 68       	cp.w	r8,6
80002bb0:	e0 8b 01 95 	brhi	80002eda <phy_tx_func+0x44e>
80002bb4:	fe f9 03 74 	ld.w	r9,pc[884]
80002bb8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002bbc:	fe f8 03 70 	ld.w	r8,pc[880]
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	58 08       	cp.w	r8,0
80002bc4:	c0 b0       	breq	80002bda <phy_tx_func+0x14e>
80002bc6:	fe f8 03 66 	ld.w	r8,pc[870]
80002bca:	70 08       	ld.w	r8,r8[0x0]
80002bcc:	58 a8       	cp.w	r8,10
80002bce:	c0 60       	breq	80002bda <phy_tx_func+0x14e>
80002bd0:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bd4:	70 08       	ld.w	r8,r8[0x0]
80002bd6:	58 18       	cp.w	r8,1
80002bd8:	c0 a1       	brne	80002bec <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bda:	e0 68 5a 5a 	mov	r8,23130
80002bde:	ea 18 ab cd 	orh	r8,0xabcd
80002be2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002be4:	30 08       	mov	r8,0
80002be6:	8f 38       	st.w	r7[0xc],r8
80002be8:	e0 8f 01 8a 	bral	80002efc <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bec:	fe f8 03 40 	ld.w	r8,pc[832]
80002bf0:	70 08       	ld.w	r8,r8[0x0]
80002bf2:	58 38       	cp.w	r8,3
80002bf4:	c0 91       	brne	80002c06 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bf6:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bfa:	70 09       	ld.w	r9,r8[0x0]
80002bfc:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bfe:	70 18       	ld.w	r8,r8[0x4]
80002c00:	8f 38       	st.w	r7[0xc],r8
80002c02:	e0 8f 01 7d 	bral	80002efc <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c06:	fe f8 03 26 	ld.w	r8,pc[806]
80002c0a:	70 08       	ld.w	r8,r8[0x0]
80002c0c:	58 28       	cp.w	r8,2
80002c0e:	c1 31       	brne	80002c34 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c10:	e0 68 c0 32 	mov	r8,49202
80002c14:	ea 18 ab cd 	orh	r8,0xabcd
80002c18:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c1a:	fe 78 84 7f 	mov	r8,-31617
80002c1e:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c20:	fe f8 03 14 	ld.w	r8,pc[788]
80002c24:	90 08       	ld.sh	r8,r8[0x0]
80002c26:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c28:	30 39       	mov	r9,3
80002c2a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c2e:	91 09       	st.w	r8[0x0],r9
80002c30:	e0 8f 01 66 	bral	80002efc <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c34:	e0 68 c0 0e 	mov	r8,49166
80002c38:	ea 18 ab cd 	orh	r8,0xabcd
80002c3c:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c3e:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c42:	90 09       	ld.sh	r9,r8[0x0]
80002c44:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c46:	90 18       	ld.sh	r8,r8[0x2]
80002c48:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c4a:	30 19       	mov	r9,1
80002c4c:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c50:	91 09       	st.w	r8[0x0],r9
80002c52:	e0 8f 01 55 	bral	80002efc <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c56:	fe 78 88 f2 	mov	r8,-30478
80002c5a:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c5c:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c60:	70 08       	ld.w	r8,r8[0x0]
80002c62:	58 48       	cp.w	r8,4
80002c64:	c0 60       	breq	80002c70 <phy_tx_func+0x1e4>
80002c66:	c4 53       	brcs	80002cf0 <phy_tx_func+0x264>
80002c68:	58 98       	cp.w	r8,9
80002c6a:	e0 8b 00 43 	brhi	80002cf0 <phy_tx_func+0x264>
80002c6e:	c2 98       	rjmp	80002cc0 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c70:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c74:	11 89       	ld.ub	r9,r8[0x0]
80002c76:	30 18       	mov	r8,1
80002c78:	f0 09 18 00 	cp.b	r9,r8
80002c7c:	c0 a1       	brne	80002c90 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c7e:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c82:	90 09       	ld.sh	r9,r8[0x0]
80002c84:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c86:	90 19       	ld.sh	r9,r8[0x2]
80002c88:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c8a:	90 28       	ld.sh	r8,r8[0x4]
80002c8c:	ae 78       	st.h	r7[0xe],r8
80002c8e:	c1 48       	rjmp	80002cb6 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c90:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c94:	92 0b       	ld.sh	r11,r9[0x0]
80002c96:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c9a:	90 0a       	ld.sh	r10,r8[0x0]
80002c9c:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca0:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002ca2:	92 1b       	ld.sh	r11,r9[0x2]
80002ca4:	90 1a       	ld.sh	r10,r8[0x2]
80002ca6:	f7 ea 20 0a 	eor	r10,r11,r10
80002caa:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cac:	92 29       	ld.sh	r9,r9[0x4]
80002cae:	90 28       	ld.sh	r8,r8[0x4]
80002cb0:	f3 e8 20 08 	eor	r8,r9,r8
80002cb4:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cb6:	30 29       	mov	r9,2
80002cb8:	fe f8 02 6c 	ld.w	r8,pc[620]
80002cbc:	91 09       	st.w	r8[0x0],r9
80002cbe:	c1 f9       	rjmp	80002efc <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cc0:	fe f9 02 84 	ld.w	r9,pc[644]
80002cc4:	92 0b       	ld.sh	r11,r9[0x0]
80002cc6:	fe f8 02 7a 	ld.w	r8,pc[634]
80002cca:	90 0a       	ld.sh	r10,r8[0x0]
80002ccc:	f7 ea 20 0a 	eor	r10,r11,r10
80002cd0:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cd2:	92 1b       	ld.sh	r11,r9[0x2]
80002cd4:	90 1a       	ld.sh	r10,r8[0x2]
80002cd6:	f7 ea 20 0a 	eor	r10,r11,r10
80002cda:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cdc:	92 29       	ld.sh	r9,r9[0x4]
80002cde:	90 28       	ld.sh	r8,r8[0x4]
80002ce0:	f3 e8 20 08 	eor	r8,r9,r8
80002ce4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002ce6:	30 29       	mov	r9,2
80002ce8:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cec:	91 09       	st.w	r8[0x0],r9
80002cee:	c0 79       	rjmp	80002efc <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cf0:	e0 68 5a 5a 	mov	r8,23130
80002cf4:	ea 18 ab cd 	orh	r8,0xabcd
80002cf8:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cfa:	30 08       	mov	r8,0
80002cfc:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cfe:	fe f9 02 26 	ld.w	r9,pc[550]
80002d02:	93 08       	st.w	r9[0x0],r8
80002d04:	cf c8       	rjmp	80002efc <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002d06:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d0a:	90 38       	ld.sh	r8,r8[0x6]
80002d0c:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d0e:	e0 68 00 ba 	mov	r8,186
80002d12:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d14:	30 08       	mov	r8,0
80002d16:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d18:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d1a:	30 09       	mov	r9,0
80002d1c:	fe f8 02 08 	ld.w	r8,pc[520]
80002d20:	91 09       	st.w	r8[0x0],r9
80002d22:	ce d8       	rjmp	80002efc <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d24:	fe f8 02 10 	ld.w	r8,pc[528]
80002d28:	90 18       	ld.sh	r8,r8[0x2]
80002d2a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d2c:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d30:	90 08       	ld.sh	r8,r8[0x0]
80002d32:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d34:	4f e8       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002d36:	70 08       	ld.w	r8,r8[0x0]
80002d38:	58 48       	cp.w	r8,4
80002d3a:	c0 d1       	brne	80002d54 <phy_tx_func+0x2c8>
80002d3c:	fe f8 02 00 	ld.w	r8,pc[512]
80002d40:	11 89       	ld.ub	r9,r8[0x0]
80002d42:	30 18       	mov	r8,1
80002d44:	f0 09 18 00 	cp.b	r9,r8
80002d48:	c0 61       	brne	80002d54 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d4a:	4f c8       	lddpc	r8,80002f38 <phy_tx_func+0x4ac>
80002d4c:	90 18       	ld.sh	r8,r8[0x2]
80002d4e:	a9 a8       	sbr	r8,0x8
80002d50:	ae 68       	st.h	r7[0xc],r8
80002d52:	c0 48       	rjmp	80002d5a <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d54:	4f 98       	lddpc	r8,80002f38 <phy_tx_func+0x4ac>
80002d56:	90 18       	ld.sh	r8,r8[0x2]
80002d58:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d5a:	fe 78 9a 13 	mov	r8,-26093
80002d5e:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d60:	30 49       	mov	r9,4
80002d62:	4f 18       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002d64:	91 09       	st.w	r8[0x0],r9
80002d66:	cc b8       	rjmp	80002efc <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d68:	4f 88       	lddpc	r8,80002f48 <phy_tx_func+0x4bc>
80002d6a:	70 0a       	ld.w	r10,r8[0x0]
80002d6c:	4f 89       	lddpc	r9,80002f4c <phy_tx_func+0x4c0>
80002d6e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d72:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d74:	70 0a       	ld.w	r10,r8[0x0]
80002d76:	2f fa       	sub	r10,-1
80002d78:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d7c:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d7e:	70 0a       	ld.w	r10,r8[0x0]
80002d80:	2f ea       	sub	r10,-2
80002d82:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d86:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d88:	70 0a       	ld.w	r10,r8[0x0]
80002d8a:	2f da       	sub	r10,-3
80002d8c:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d90:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d92:	70 09       	ld.w	r9,r8[0x0]
80002d94:	2f c9       	sub	r9,-4
80002d96:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d98:	58 c9       	cp.w	r9,12
80002d9a:	c0 51       	brne	80002da4 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d9c:	30 59       	mov	r9,5
80002d9e:	4e 28       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002da0:	91 09       	st.w	r8[0x0],r9
80002da2:	ca d8       	rjmp	80002efc <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002da4:	30 49       	mov	r9,4
80002da6:	4e 08       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	ca 98       	rjmp	80002efc <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dac:	4e 78       	lddpc	r8,80002f48 <phy_tx_func+0x4bc>
80002dae:	70 0a       	ld.w	r10,r8[0x0]
80002db0:	4e 79       	lddpc	r9,80002f4c <phy_tx_func+0x4c0>
80002db2:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002db6:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002db8:	30 09       	mov	r9,0
80002dba:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002dbc:	fe 78 80 03 	mov	r8,-32765
80002dc0:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002dc2:	fe 78 88 f3 	mov	r8,-30477
80002dc6:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002dc8:	4d 98       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002dca:	70 08       	ld.w	r8,r8[0x0]
80002dcc:	58 48       	cp.w	r8,4
80002dce:	c0 60       	breq	80002dda <phy_tx_func+0x34e>
80002dd0:	c2 83       	brcs	80002e20 <phy_tx_func+0x394>
80002dd2:	58 98       	cp.w	r8,9
80002dd4:	e0 8b 00 26 	brhi	80002e20 <phy_tx_func+0x394>
80002dd8:	c1 98       	rjmp	80002e0a <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dda:	4d 98       	lddpc	r8,80002f3c <phy_tx_func+0x4b0>
80002ddc:	11 89       	ld.ub	r9,r8[0x0]
80002dde:	30 18       	mov	r8,1
80002de0:	f0 09 18 00 	cp.b	r9,r8
80002de4:	c0 81       	brne	80002df4 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002de6:	4d 88       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002de8:	90 0a       	ld.sh	r10,r8[0x0]
80002dea:	4d a9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002dec:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dee:	90 08       	ld.sh	r8,r8[0x0]
80002df0:	ae 78       	st.h	r7[0xe],r8
80002df2:	c0 88       	rjmp	80002e02 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002df4:	4d 78       	lddpc	r8,80002f50 <phy_tx_func+0x4c4>
80002df6:	90 08       	ld.sh	r8,r8[0x0]
80002df8:	4d 39       	lddpc	r9,80002f44 <phy_tx_func+0x4b8>
80002dfa:	92 09       	ld.sh	r9,r9[0x0]
80002dfc:	f3 e8 20 08 	eor	r8,r9,r8
80002e00:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e02:	30 69       	mov	r9,6
80002e04:	4c 88       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e06:	91 09       	st.w	r8[0x0],r9
80002e08:	c7 a8       	rjmp	80002efc <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e0a:	4d 28       	lddpc	r8,80002f50 <phy_tx_func+0x4c4>
80002e0c:	90 08       	ld.sh	r8,r8[0x0]
80002e0e:	4c e9       	lddpc	r9,80002f44 <phy_tx_func+0x4b8>
80002e10:	92 09       	ld.sh	r9,r9[0x0]
80002e12:	f3 e8 20 08 	eor	r8,r9,r8
80002e16:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e18:	30 69       	mov	r9,6
80002e1a:	4c 38       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e1c:	91 09       	st.w	r8[0x0],r9
80002e1e:	c6 f8       	rjmp	80002efc <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e20:	e0 68 5a 5a 	mov	r8,23130
80002e24:	ea 18 ab cd 	orh	r8,0xabcd
80002e28:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e2a:	30 08       	mov	r8,0
80002e2c:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e2e:	4b e9       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002e30:	93 08       	st.w	r9[0x0],r8
80002e32:	c6 58       	rjmp	80002efc <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e34:	4b e8       	lddpc	r8,80002f2c <phy_tx_func+0x4a0>
80002e36:	70 08       	ld.w	r8,r8[0x0]
80002e38:	58 48       	cp.w	r8,4
80002e3a:	c0 60       	breq	80002e46 <phy_tx_func+0x3ba>
80002e3c:	c4 53       	brcs	80002ec6 <phy_tx_func+0x43a>
80002e3e:	58 98       	cp.w	r8,9
80002e40:	e0 8b 00 43 	brhi	80002ec6 <phy_tx_func+0x43a>
80002e44:	c2 d8       	rjmp	80002e9e <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e46:	4b e8       	lddpc	r8,80002f3c <phy_tx_func+0x4b0>
80002e48:	11 89       	ld.ub	r9,r8[0x0]
80002e4a:	30 18       	mov	r8,1
80002e4c:	f0 09 18 00 	cp.b	r9,r8
80002e50:	c1 31       	brne	80002e76 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e52:	4b d8       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002e54:	90 1a       	ld.sh	r10,r8[0x2]
80002e56:	4b f9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002e58:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e5a:	90 2a       	ld.sh	r10,r8[0x4]
80002e5c:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e5e:	90 3a       	ld.sh	r10,r8[0x6]
80002e60:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e62:	90 19       	ld.sh	r9,r8[0x2]
80002e64:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e66:	90 29       	ld.sh	r9,r8[0x4]
80002e68:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e6a:	90 38       	ld.sh	r8,r8[0x6]
80002e6c:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e6e:	e0 68 00 ba 	mov	r8,186
80002e72:	ae 78       	st.h	r7[0xe],r8
80002e74:	c1 18       	rjmp	80002e96 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e76:	4b 48       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002e78:	90 1a       	ld.sh	r10,r8[0x2]
80002e7a:	4b 69       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002e7c:	92 1b       	ld.sh	r11,r9[0x2]
80002e7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e82:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e84:	90 2a       	ld.sh	r10,r8[0x4]
80002e86:	92 29       	ld.sh	r9,r9[0x4]
80002e88:	14 59       	eor	r9,r10
80002e8a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e8c:	90 38       	ld.sh	r8,r8[0x6]
80002e8e:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e90:	e0 68 00 ba 	mov	r8,186
80002e94:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e96:	30 09       	mov	r9,0
80002e98:	4a 38       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002e9a:	91 09       	st.w	r8[0x0],r9
80002e9c:	c3 08       	rjmp	80002efc <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e9e:	4a a8       	lddpc	r8,80002f44 <phy_tx_func+0x4b8>
80002ea0:	90 1a       	ld.sh	r10,r8[0x2]
80002ea2:	4a c9       	lddpc	r9,80002f50 <phy_tx_func+0x4c4>
80002ea4:	92 1b       	ld.sh	r11,r9[0x2]
80002ea6:	f7 ea 20 0a 	eor	r10,r11,r10
80002eaa:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002eac:	90 2a       	ld.sh	r10,r8[0x4]
80002eae:	92 29       	ld.sh	r9,r9[0x4]
80002eb0:	14 59       	eor	r9,r10
80002eb2:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002eb4:	90 38       	ld.sh	r8,r8[0x6]
80002eb6:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002eb8:	e0 68 00 ba 	mov	r8,186
80002ebc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ebe:	30 09       	mov	r9,0
80002ec0:	49 98       	lddpc	r8,80002f24 <phy_tx_func+0x498>
80002ec2:	91 09       	st.w	r8[0x0],r9
80002ec4:	c1 c8       	rjmp	80002efc <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec6:	e0 68 5a 5a 	mov	r8,23130
80002eca:	ea 18 ab cd 	orh	r8,0xabcd
80002ece:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed0:	30 08       	mov	r8,0
80002ed2:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ed4:	49 49       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002ed6:	93 08       	st.w	r9[0x0],r8
80002ed8:	c1 28       	rjmp	80002efc <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eda:	e0 68 5a 5a 	mov	r8,23130
80002ede:	ea 18 ab cd 	orh	r8,0xabcd
80002ee2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ee4:	30 08       	mov	r8,0
80002ee6:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ee8:	48 f9       	lddpc	r9,80002f24 <phy_tx_func+0x498>
80002eea:	93 08       	st.w	r9[0x0],r8
80002eec:	c0 88       	rjmp	80002efc <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eee:	e0 68 5a 5a 	mov	r8,23130
80002ef2:	ea 18 ab cd 	orh	r8,0xabcd
80002ef6:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ef8:	30 08       	mov	r8,0
80002efa:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002efc:	2f fd       	sub	sp,-4
80002efe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f02:	00 00       	add	r0,r0
80002f04:	00 00       	add	r0,r0
80002f06:	0a bc       	st.h	r5++,r12
80002f08:	00 00       	add	r0,r0
80002f0a:	0a 78       	tst	r8,r5
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a d0       	st.w	--r5,r0
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	5d 30       	musfr	r0
80002f14:	00 00       	add	r0,r0
80002f16:	0a a2       	st.w	r5++,r2
80002f18:	00 00       	add	r0,r0
80002f1a:	0a 58       	eor	r8,r5
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a 3c       	cp.w	r12,r5
80002f20:	00 00       	add	r0,r0
80002f22:	0a cc       	st.b	r5++,r12
80002f24:	00 00       	add	r0,r0
80002f26:	0a 68       	and	r8,r5
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	d3 0c       	*unknown*
80002f2c:	00 00       	add	r0,r0
80002f2e:	0a c0       	st.b	r5++,r0
80002f30:	00 00       	add	r0,r0
80002f32:	0a 80       	andn	r0,r5
80002f34:	00 00       	add	r0,r0
80002f36:	1d 9c       	ld.ub	r12,lr[0x1]
80002f38:	00 00       	add	r0,r0
80002f3a:	1e 98       	mov	r8,pc
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 32       	cp.w	r2,r5
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	d2 ae       	*unknown*
80002f44:	00 00       	add	r0,r0
80002f46:	1d 94       	ld.ub	r4,lr[0x1]
80002f48:	00 00       	add	r0,r0
80002f4a:	0a c4       	st.b	r5++,r4
80002f4c:	00 00       	add	r0,r0
80002f4e:	1e 9c       	mov	r12,pc
80002f50:	00 00       	add	r0,r0
80002f52:	1d a0       	ld.ub	r0,lr[0x2]

80002f54 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f54:	d4 01       	pushm	lr
80002f56:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f58:	30 0a       	mov	r10,0
80002f5a:	fa cb ff fc 	sub	r11,sp,-4
80002f5e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f60:	14 99       	mov	r9,r10
80002f62:	1a 9b       	mov	r11,sp
80002f64:	f0 1f 00 05 	mcall	80002f78 <get_idle_store+0x24>
80002f68:	58 1c       	cp.w	r12,1
80002f6a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f6e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f72:	2f fd       	sub	sp,-4
80002f74:	d8 02       	popm	pc
80002f76:	00 00       	add	r0,r0
80002f78:	80 00       	ld.sh	r0,r0[0x0]
80002f7a:	5e 20       	reths	r0

80002f7c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f7c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f7e:	48 5b       	lddpc	r11,80002f90 <phy_init+0x14>
80002f80:	48 5c       	lddpc	r12,80002f94 <phy_init+0x18>
80002f82:	f0 1f 00 06 	mcall	80002f98 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002f86:	f0 1f 00 06 	mcall	80002f9c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002f8a:	f0 1f 00 06 	mcall	80002fa0 <phy_init+0x24>
	
}
80002f8e:	d8 02       	popm	pc
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	2a 8c       	sub	r12,-88
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	30 04       	mov	r4,0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	40 4c       	lddsp	r12,sp[0x10]
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	40 60       	lddsp	r0,sp[0x18]
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	49 74       	lddpc	r4,80002ffc <payload_rx+0x58>

80002fa4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002fa4:	d4 01       	pushm	lr
80002fa6:	20 2d       	sub	sp,8
80002fa8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002faa:	30 08       	mov	r8,0
80002fac:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002fae:	48 f8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fb0:	70 08       	ld.w	r8,r8[0x0]
80002fb2:	58 08       	cp.w	r8,0
80002fb4:	c0 71       	brne	80002fc2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002fb6:	30 4b       	mov	r11,4
80002fb8:	30 5c       	mov	r12,5
80002fba:	f0 1f 00 0d 	mcall	80002fec <payload_rx+0x48>
80002fbe:	48 b8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fc0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002fc2:	48 a8       	lddpc	r8,80002fe8 <payload_rx+0x44>
80002fc4:	70 0c       	ld.w	r12,r8[0x0]
80002fc6:	30 09       	mov	r9,0
80002fc8:	fa ca ff fc 	sub	r10,sp,-4
80002fcc:	1a 9b       	mov	r11,sp
80002fce:	f0 1f 00 09 	mcall	80002ff0 <payload_rx+0x4c>
80002fd2:	c0 91       	brne	80002fe4 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002fd4:	48 88       	lddpc	r8,80002ff4 <payload_rx+0x50>
80002fd6:	70 0c       	ld.w	r12,r8[0x0]
80002fd8:	40 0b       	lddsp	r11,sp[0x0]
80002fda:	f0 1f 00 08 	mcall	80002ff8 <payload_rx+0x54>
		logFromISR("mm");
80002fde:	48 8c       	lddpc	r12,80002ffc <payload_rx+0x58>
80002fe0:	f0 1f 00 08 	mcall	80003000 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002fe4:	2f ed       	sub	sp,-8
80002fe6:	d8 02       	popm	pc
80002fe8:	00 00       	add	r0,r0
80002fea:	0a 64       	and	r4,r5
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	61 2c       	ld.w	r12,r0[0x48]
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	5f dc       	srvc	r12
80002ff4:	00 00       	add	r0,r0
80002ff6:	0a 94       	mov	r4,r5
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	29 94       	sub	r4,-103
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	d3 28       	*unknown*
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	6d 50       	ld.w	r0,r6[0x54]

80003004 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003004:	eb cd 40 e0 	pushm	r5-r7,lr
80003008:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000300a:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000300e:	70 08       	ld.w	r8,r8[0x0]
80003010:	58 08       	cp.w	r8,0
80003012:	e0 80 01 08 	breq	80003222 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003016:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003018:	fe f8 0e 70 	ld.w	r8,pc[3696]
8000301c:	70 09       	ld.w	r9,r8[0x0]
8000301e:	2f f9       	sub	r9,-1
80003020:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003022:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003026:	70 08       	ld.w	r8,r8[0x0]
80003028:	58 18       	cp.w	r8,1
8000302a:	e0 80 00 85 	breq	80003134 <phy_rx_func+0x130>
8000302e:	c0 73       	brcs	8000303c <phy_rx_func+0x38>
80003030:	58 28       	cp.w	r8,2
80003032:	c5 c0       	breq	800030ea <phy_rx_func+0xe6>
80003034:	58 38       	cp.w	r8,3
80003036:	e0 81 00 f6 	brne	80003222 <phy_rx_func+0x21e>
8000303a:	cd 58       	rjmp	800031e4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000303c:	e0 6a 5a 5a 	mov	r10,23130
80003040:	ea 1a ab cd 	orh	r10,0xabcd
80003044:	14 36       	cp.w	r6,r10
80003046:	e0 80 00 ee 	breq	80003222 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000304a:	ec 08 16 10 	lsr	r8,r6,0x10
8000304e:	e0 48 ab cd 	cp.w	r8,43981
80003052:	e0 81 00 e8 	brne	80003222 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003056:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000305a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000305e:	20 28       	sub	r8,2
80003060:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003064:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003066:	30 09       	mov	r9,0
80003068:	f2 08 19 00 	cp.h	r8,r9
8000306c:	e0 8a 00 db 	brle	80003222 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003070:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003074:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003076:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000307a:	70 0c       	ld.w	r12,r8[0x0]
8000307c:	f0 1f 03 88 	mcall	80003e9c <phy_rx_func+0xe98>
80003080:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003084:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003086:	58 0c       	cp.w	r12,0
80003088:	e0 80 00 cd 	breq	80003222 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000308c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003090:	90 09       	ld.sh	r9,r8[0x0]
80003092:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003096:	2f f9       	sub	r9,-1
80003098:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000309a:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000309e:	74 0a       	ld.w	r10,r10[0x0]
800030a0:	fe fb 0d e8 	ld.w	r11,pc[3560]
800030a4:	76 0b       	ld.w	r11,r11[0x0]
800030a6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800030aa:	2f f9       	sub	r9,-1
800030ac:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800030ae:	e2 16 0f 00 	andl	r6,0xf00,COH
800030b2:	e0 46 01 00 	cp.w	r6,256
800030b6:	c0 c0       	breq	800030ce <phy_rx_func+0xca>
800030b8:	e0 8b 00 05 	brhi	800030c2 <phy_rx_func+0xbe>
800030bc:	58 06       	cp.w	r6,0
800030be:	c0 80       	breq	800030ce <phy_rx_func+0xca>
800030c0:	c0 c8       	rjmp	800030d8 <phy_rx_func+0xd4>
800030c2:	e0 46 02 00 	cp.w	r6,512
800030c6:	c0 40       	breq	800030ce <phy_rx_func+0xca>
800030c8:	e0 46 03 00 	cp.w	r6,768
800030cc:	c0 61       	brne	800030d8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800030ce:	30 29       	mov	r9,2
800030d0:	fe f8 0d bc 	ld.w	r8,pc[3516]
800030d4:	91 09       	st.w	r8[0x0],r9
800030d6:	ca 68       	rjmp	80003222 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800030d8:	fe f8 0d c0 	ld.w	r8,pc[3520]
800030dc:	70 0c       	ld.w	r12,r8[0x0]
800030de:	fe f8 0d c2 	ld.w	r8,pc[3522]
800030e2:	70 0b       	ld.w	r11,r8[0x0]
800030e4:	f0 1f 03 70 	mcall	80003ea4 <phy_rx_func+0xea0>
800030e8:	c9 d8       	rjmp	80003222 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800030ea:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800030ee:	b1 86       	lsr	r6,0x10
800030f0:	14 06       	add	r6,r10
800030f2:	fe f8 0d b6 	ld.w	r8,pc[3510]
800030f6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800030f8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800030fc:	90 09       	ld.sh	r9,r8[0x0]
800030fe:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003102:	76 0b       	ld.w	r11,r11[0x0]
80003104:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003108:	2f f9       	sub	r9,-1
8000310a:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000310c:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003110:	92 08       	ld.sh	r8,r9[0x0]
80003112:	20 28       	sub	r8,2
80003114:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003116:	30 09       	mov	r9,0
80003118:	f2 08 19 00 	cp.h	r8,r9
8000311c:	e0 8a 00 07 	brle	8000312a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003120:	30 19       	mov	r9,1
80003122:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003126:	91 09       	st.w	r8[0x0],r9
80003128:	c7 d8       	rjmp	80003222 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000312a:	30 39       	mov	r9,3
8000312c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	c7 88       	rjmp	80003222 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003134:	ec 0a 14 10 	asr	r10,r6,0x10
80003138:	fe f8 0d 70 	ld.w	r8,pc[3440]
8000313c:	90 09       	ld.sh	r9,r8[0x0]
8000313e:	14 09       	add	r9,r10
80003140:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003142:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003146:	92 08       	ld.sh	r8,r9[0x0]
80003148:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000314c:	76 0b       	ld.w	r11,r11[0x0]
8000314e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003152:	2f f8       	sub	r8,-1
80003154:	5c 88       	casts.h	r8
80003156:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003158:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000315c:	94 09       	ld.sh	r9,r10[0x0]
8000315e:	20 29       	sub	r9,2
80003160:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003162:	30 0a       	mov	r10,0
80003164:	f4 09 19 00 	cp.h	r9,r10
80003168:	e0 89 00 20 	brgt	800031a8 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000316c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003170:	e0 46 00 ba 	cp.w	r6,186
80003174:	c0 d1       	brne	8000318e <phy_rx_func+0x18a>
80003176:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000317a:	90 09       	ld.sh	r9,r8[0x0]
8000317c:	f4 09 19 00 	cp.h	r9,r10
80003180:	c0 71       	brne	8000318e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003182:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003186:	70 0c       	ld.w	r12,r8[0x0]
80003188:	f0 1f 03 49 	mcall	80003eac <phy_rx_func+0xea8>
8000318c:	c0 98       	rjmp	8000319e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000318e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003192:	70 0c       	ld.w	r12,r8[0x0]
80003194:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003198:	70 0b       	ld.w	r11,r8[0x0]
8000319a:	f0 1f 03 43 	mcall	80003ea4 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000319e:	30 09       	mov	r9,0
800031a0:	fe f8 0c ec 	ld.w	r8,pc[3308]
800031a4:	91 09       	st.w	r8[0x0],r9
800031a6:	c3 e8       	rjmp	80003222 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800031a8:	5c 86       	casts.h	r6
800031aa:	fe f9 0c fe 	ld.w	r9,pc[3326]
800031ae:	92 0a       	ld.sh	r10,r9[0x0]
800031b0:	0c 0a       	add	r10,r6
800031b2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031b4:	fe f9 0c ec 	ld.w	r9,pc[3308]
800031b8:	72 09       	ld.w	r9,r9[0x0]
800031ba:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031be:	2f f8       	sub	r8,-1
800031c0:	fe f9 0c d4 	ld.w	r9,pc[3284]
800031c4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031c6:	fe f9 0c ca 	ld.w	r9,pc[3274]
800031ca:	92 08       	ld.sh	r8,r9[0x0]
800031cc:	20 28       	sub	r8,2
800031ce:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800031d0:	30 09       	mov	r9,0
800031d2:	f2 08 19 00 	cp.h	r8,r9
800031d6:	e0 89 00 26 	brgt	80003222 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800031da:	30 39       	mov	r9,3
800031dc:	fe f8 0c b0 	ld.w	r8,pc[3248]
800031e0:	91 09       	st.w	r8[0x0],r9
800031e2:	c2 08       	rjmp	80003222 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800031e4:	e6 16 00 ff 	andh	r6,0xff,COH
800031e8:	fc 19 00 ba 	movh	r9,0xba
800031ec:	12 36       	cp.w	r6,r9
800031ee:	c0 e1       	brne	8000320a <phy_rx_func+0x206>
800031f0:	fe f8 0c b8 	ld.w	r8,pc[3256]
800031f4:	90 09       	ld.sh	r9,r8[0x0]
800031f6:	30 08       	mov	r8,0
800031f8:	f0 09 19 00 	cp.h	r9,r8
800031fc:	c0 71       	brne	8000320a <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800031fe:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003202:	70 0c       	ld.w	r12,r8[0x0]
80003204:	f0 1f 03 2a 	mcall	80003eac <phy_rx_func+0xea8>
80003208:	c0 98       	rjmp	8000321a <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000320a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000320e:	70 0c       	ld.w	r12,r8[0x0]
80003210:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003214:	70 0b       	ld.w	r11,r8[0x0]
80003216:	f0 1f 03 24 	mcall	80003ea4 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000321a:	30 09       	mov	r9,0
8000321c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003220:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003222:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003226:	11 89       	ld.ub	r9,r8[0x0]
80003228:	30 08       	mov	r8,0
8000322a:	f0 09 18 00 	cp.b	r9,r8
8000322e:	c1 31       	brne	80003254 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003230:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003234:	6c 0c       	ld.w	r12,r6[0x0]
80003236:	f0 1f 03 1a 	mcall	80003e9c <phy_rx_func+0xe98>
8000323a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000323e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003240:	6c 0c       	ld.w	r12,r6[0x0]
80003242:	f0 1f 03 17 	mcall	80003e9c <phy_rx_func+0xe98>
80003246:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000324a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000324c:	30 19       	mov	r9,1
8000324e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003252:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003254:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003258:	70 08       	ld.w	r8,r8[0x0]
8000325a:	58 28       	cp.w	r8,2
8000325c:	e0 80 01 98 	breq	8000358c <phy_rx_func+0x588>
80003260:	e0 8b 00 06 	brhi	8000326c <phy_rx_func+0x268>
80003264:	58 08       	cp.w	r8,0
80003266:	c0 b0       	breq	8000327c <phy_rx_func+0x278>
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000326c:	58 38       	cp.w	r8,3
8000326e:	e0 80 05 c5 	breq	80003df8 <phy_rx_func+0xdf4>
80003272:	58 48       	cp.w	r8,4
80003274:	e0 81 06 05 	brne	80003e7e <phy_rx_func+0xe7a>
80003278:	e0 8f 02 4b 	bral	8000370e <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000327c:	6e 28       	ld.w	r8,r7[0x8]
8000327e:	e0 6a 5a 5a 	mov	r10,23130
80003282:	ea 1a ab cd 	orh	r10,0xabcd
80003286:	14 38       	cp.w	r8,r10
80003288:	c0 71       	brne	80003296 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000328a:	30 09       	mov	r9,0
8000328c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003290:	91 09       	st.w	r8[0x0],r9
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003296:	10 99       	mov	r9,r8
80003298:	e0 19 00 00 	andl	r9,0x0
8000329c:	fc 1a ab cd 	movh	r10,0xabcd
800032a0:	14 39       	cp.w	r9,r10
800032a2:	e0 81 05 ee 	brne	80003e7e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032a6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032aa:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800032ae:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800032b0:	6e 29       	ld.w	r9,r7[0x8]
800032b2:	e2 19 f0 00 	andl	r9,0xf000,COH
800032b6:	e0 49 c0 00 	cp.w	r9,49152
800032ba:	e0 81 00 ce 	brne	80003456 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800032be:	30 1a       	mov	r10,1
800032c0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800032c4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800032c6:	fe f9 0b f6 	ld.w	r9,pc[3062]
800032ca:	72 09       	ld.w	r9,r9[0x0]
800032cc:	58 09       	cp.w	r9,0
800032ce:	c0 71       	brne	800032dc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032d0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800032d4:	f0 1f 03 00 	mcall	80003ed4 <phy_rx_func+0xed0>
800032d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800032dc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800032e0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800032e4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800032e6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800032ea:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800032ee:	fe fa 0b ee 	ld.w	r10,pc[3054]
800032f2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800032f4:	13 89       	ld.ub	r9,r9[0x0]
800032f6:	37 fa       	mov	r10,127
800032f8:	f4 09 18 00 	cp.b	r9,r10
800032fc:	c6 d0       	breq	800033d6 <phy_rx_func+0x3d2>
800032fe:	e0 8b 00 0c 	brhi	80003316 <phy_rx_func+0x312>
80003302:	31 2a       	mov	r10,18
80003304:	f4 09 18 00 	cp.b	r9,r10
80003308:	c4 20       	breq	8000338c <phy_rx_func+0x388>
8000330a:	31 3a       	mov	r10,19
8000330c:	f4 09 18 00 	cp.b	r9,r10
80003310:	e0 81 00 83 	brne	80003416 <phy_rx_func+0x412>
80003314:	c5 b8       	rjmp	800033ca <phy_rx_func+0x3c6>
80003316:	2f 09       	sub	r9,-16
80003318:	30 1a       	mov	r10,1
8000331a:	f4 09 18 00 	cp.b	r9,r10
8000331e:	e0 8b 00 7c 	brhi	80003416 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003322:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003326:	e2 18 00 f0 	andl	r8,0xf0,COH
8000332a:	59 08       	cp.w	r8,16
8000332c:	c0 71       	brne	8000333a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000332e:	30 19       	mov	r9,1
80003330:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003334:	91 09       	st.w	r8[0x0],r9
80003336:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000333a:	e0 48 00 20 	cp.w	r8,32
8000333e:	c2 11       	brne	80003380 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003340:	30 a9       	mov	r9,10
80003342:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003346:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003348:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000334c:	6c 08       	ld.w	r8,r6[0x0]
8000334e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003352:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003356:	2f f8       	sub	r8,-1
80003358:	6e 0c       	ld.w	r12,r7[0x0]
8000335a:	f4 ca fe 00 	sub	r10,r10,-512
8000335e:	30 0b       	mov	r11,0
80003360:	10 0c       	add	r12,r8
80003362:	f0 1f 02 e1 	mcall	80003ee4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003366:	30 08       	mov	r8,0
80003368:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000336a:	6e 0c       	ld.w	r12,r7[0x0]
8000336c:	f0 1f 02 df 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003370:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003374:	70 0c       	ld.w	r12,r8[0x0]
80003376:	f0 1f 02 ca 	mcall	80003e9c <phy_rx_func+0xe98>
8000337a:	8f 0c       	st.w	r7[0x0],r12
8000337c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003380:	30 09       	mov	r9,0
80003382:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003386:	91 09       	st.w	r8[0x0],r9
80003388:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000338c:	20 48       	sub	r8,4
8000338e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003392:	93 08       	st.w	r9[0x0],r8
80003394:	58 08       	cp.w	r8,0
80003396:	e0 80 05 74 	breq	80003e7e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000339a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000339e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033a2:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800033a6:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800033a8:	8e 69       	ld.sh	r9,r7[0xc]
800033aa:	fe f8 0b 46 	ld.w	r8,pc[2886]
800033ae:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800033b0:	8e 79       	ld.sh	r9,r7[0xe]
800033b2:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800033b4:	f0 1f 02 d0 	mcall	80003ef4 <phy_rx_func+0xef0>
800033b8:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800033bc:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800033be:	30 49       	mov	r9,4
800033c0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800033ca:	30 09       	mov	r9,0
800033cc:	fe f8 0a f8 	ld.w	r8,pc[2808]
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033d6:	20 48       	sub	r8,4
800033d8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800033dc:	93 08       	st.w	r9[0x0],r8
800033de:	58 08       	cp.w	r8,0
800033e0:	e0 80 05 4f 	breq	80003e7e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800033e4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800033e8:	70 09       	ld.w	r9,r8[0x0]
800033ea:	8e 7b       	ld.sh	r11,r7[0xe]
800033ec:	fe fa 0b 10 	ld.w	r10,pc[2832]
800033f0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800033f4:	2f f9       	sub	r9,-1
800033f6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800033f8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800033fc:	70 09       	ld.w	r9,r8[0x0]
800033fe:	20 29       	sub	r9,2
80003400:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003402:	30 29       	mov	r9,2
80003404:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003408:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000340a:	30 39       	mov	r9,3
8000340c:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003410:	91 09       	st.w	r8[0x0],r9
80003412:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003416:	30 3a       	mov	r10,3
80003418:	fe f9 0a ac 	ld.w	r9,pc[2732]
8000341c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000341e:	6e 2a       	ld.w	r10,r7[0x8]
80003420:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003424:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003426:	6e 3a       	ld.w	r10,r7[0xc]
80003428:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000342a:	59 48       	cp.w	r8,20
8000342c:	c0 61       	brne	80003438 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000342e:	31 89       	mov	r9,24
80003430:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003434:	91 09       	st.w	r8[0x0],r9
80003436:	c0 a8       	rjmp	8000344a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003438:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000343c:	70 08       	ld.w	r8,r8[0x0]
8000343e:	59 08       	cp.w	r8,16
80003440:	c0 51       	brne	8000344a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003442:	31 09       	mov	r9,16
80003444:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003448:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000344a:	30 49       	mov	r9,4
8000344c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003450:	91 09       	st.w	r8[0x0],r9
80003452:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003456:	e0 49 10 00 	cp.w	r9,4096
8000345a:	5f 1a       	srne	r10
8000345c:	e0 49 20 00 	cp.w	r9,8192
80003460:	5f 19       	srne	r9
80003462:	f5 e9 00 09 	and	r9,r10,r9
80003466:	e0 81 05 0c 	brne	80003e7e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000346a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000346e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003470:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003474:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003476:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000347a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000347c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003480:	72 09       	ld.w	r9,r9[0x0]
80003482:	58 09       	cp.w	r9,0
80003484:	c0 71       	brne	80003492 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003486:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000348a:	f0 1f 02 93 	mcall	80003ed4 <phy_rx_func+0xed0>
8000348e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003492:	6e 2a       	ld.w	r10,r7[0x8]
80003494:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003498:	58 1a       	cp.w	r10,1
8000349a:	e0 8b 00 4d 	brhi	80003534 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000349e:	20 48       	sub	r8,4
800034a0:	fe f9 0a 28 	ld.w	r9,pc[2600]
800034a4:	93 08       	st.w	r9[0x0],r8
800034a6:	58 08       	cp.w	r8,0
800034a8:	e0 80 04 eb 	breq	80003e7e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800034ac:	8e 68       	ld.sh	r8,r7[0xc]
800034ae:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800034b2:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800034b6:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800034b8:	30 09       	mov	r9,0
800034ba:	f2 08 19 00 	cp.h	r8,r9
800034be:	c0 70       	breq	800034cc <phy_rx_func+0x4c8>
800034c0:	30 19       	mov	r9,1
800034c2:	f2 08 19 00 	cp.h	r8,r9
800034c6:	e0 81 04 dc 	brne	80003e7e <phy_rx_func+0xe7a>
800034ca:	c2 68       	rjmp	80003516 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034cc:	fe f8 0a 44 	ld.w	r8,pc[2628]
800034d0:	70 0a       	ld.w	r10,r8[0x0]
800034d2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800034d6:	72 09       	ld.w	r9,r9[0x0]
800034d8:	8e 7b       	ld.sh	r11,r7[0xe]
800034da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800034de:	70 09       	ld.w	r9,r8[0x0]
800034e0:	2f f9       	sub	r9,-1
800034e2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034e4:	e0 49 00 ff 	cp.w	r9,255
800034e8:	e0 88 00 11 	brls	8000350a <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800034ec:	30 09       	mov	r9,0
800034ee:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800034f0:	fe f7 09 c8 	ld.w	r7,pc[2504]
800034f4:	6e 0c       	ld.w	r12,r7[0x0]
800034f6:	f0 1f 02 7d 	mcall	80003ee8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800034fa:	fe f8 09 ba 	ld.w	r8,pc[2490]
800034fe:	70 0c       	ld.w	r12,r8[0x0]
80003500:	f0 1f 02 67 	mcall	80003e9c <phy_rx_func+0xe98>
80003504:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003506:	e0 80 04 bc 	breq	80003e7e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000350a:	30 29       	mov	r9,2
8000350c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003510:	91 09       	st.w	r8[0x0],r9
80003512:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003516:	8e 79       	ld.sh	r9,r7[0xe]
80003518:	30 38       	mov	r8,3
8000351a:	f0 09 19 00 	cp.h	r9,r8
8000351e:	c0 51       	brne	80003528 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003520:	30 19       	mov	r9,1
80003522:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003526:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003528:	30 29       	mov	r9,2
8000352a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000352e:	91 09       	st.w	r8[0x0],r9
80003530:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003534:	58 18       	cp.w	r8,1
80003536:	e0 88 04 a4 	brls	80003e7e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000353a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000353e:	70 0a       	ld.w	r10,r8[0x0]
80003540:	6e 3b       	ld.w	r11,r7[0xc]
80003542:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003546:	70 09       	ld.w	r9,r8[0x0]
80003548:	2f f9       	sub	r9,-1
8000354a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000354c:	e0 49 00 ff 	cp.w	r9,255
80003550:	e0 88 00 11 	brls	80003572 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003554:	30 09       	mov	r9,0
80003556:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003558:	fe f7 09 60 	ld.w	r7,pc[2400]
8000355c:	6e 0c       	ld.w	r12,r7[0x0]
8000355e:	f0 1f 02 63 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003562:	fe f8 09 52 	ld.w	r8,pc[2386]
80003566:	70 0c       	ld.w	r12,r8[0x0]
80003568:	f0 1f 02 4d 	mcall	80003e9c <phy_rx_func+0xe98>
8000356c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000356e:	e0 80 04 88 	breq	80003e7e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003572:	fe f9 09 56 	ld.w	r9,pc[2390]
80003576:	72 08       	ld.w	r8,r9[0x0]
80003578:	20 28       	sub	r8,2
8000357a:	93 08       	st.w	r9[0x0],r8
8000357c:	e0 80 04 81 	breq	80003e7e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003580:	30 29       	mov	r9,2
80003582:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003586:	91 09       	st.w	r8[0x0],r9
80003588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000358c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003590:	70 0a       	ld.w	r10,r8[0x0]
80003592:	fe f9 09 26 	ld.w	r9,pc[2342]
80003596:	72 09       	ld.w	r9,r9[0x0]
80003598:	8e 4b       	ld.sh	r11,r7[0x8]
8000359a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000359e:	70 09       	ld.w	r9,r8[0x0]
800035a0:	2f f9       	sub	r9,-1
800035a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035a4:	e0 49 00 ff 	cp.w	r9,255
800035a8:	e0 88 00 16 	brls	800035d4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800035ac:	30 09       	mov	r9,0
800035ae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035b0:	fe f6 09 08 	ld.w	r6,pc[2312]
800035b4:	6c 0c       	ld.w	r12,r6[0x0]
800035b6:	f0 1f 02 4d 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035ba:	fe f8 08 fa 	ld.w	r8,pc[2298]
800035be:	70 0c       	ld.w	r12,r8[0x0]
800035c0:	f0 1f 02 37 	mcall	80003e9c <phy_rx_func+0xe98>
800035c4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800035c6:	c0 71       	brne	800035d4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800035c8:	30 09       	mov	r9,0
800035ca:	fe f8 08 f6 	ld.w	r8,pc[2294]
800035ce:	91 09       	st.w	r8[0x0],r9
800035d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800035d4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800035d8:	72 08       	ld.w	r8,r9[0x0]
800035da:	20 28       	sub	r8,2
800035dc:	93 08       	st.w	r9[0x0],r8
800035de:	c0 71       	brne	800035ec <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800035e0:	30 09       	mov	r9,0
800035e2:	fe f8 08 de 	ld.w	r8,pc[2270]
800035e6:	91 09       	st.w	r8[0x0],r9
800035e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800035ec:	fe f8 09 24 	ld.w	r8,pc[2340]
800035f0:	70 0a       	ld.w	r10,r8[0x0]
800035f2:	fe f9 08 c6 	ld.w	r9,pc[2246]
800035f6:	72 09       	ld.w	r9,r9[0x0]
800035f8:	8e 5b       	ld.sh	r11,r7[0xa]
800035fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035fe:	70 09       	ld.w	r9,r8[0x0]
80003600:	2f f9       	sub	r9,-1
80003602:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003604:	e0 49 00 ff 	cp.w	r9,255
80003608:	e0 88 00 16 	brls	80003634 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
8000360c:	30 09       	mov	r9,0
8000360e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003610:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003614:	6c 0c       	ld.w	r12,r6[0x0]
80003616:	f0 1f 02 35 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000361a:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000361e:	70 0c       	ld.w	r12,r8[0x0]
80003620:	f0 1f 02 1f 	mcall	80003e9c <phy_rx_func+0xe98>
80003624:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003626:	c0 71       	brne	80003634 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003628:	30 09       	mov	r9,0
8000362a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000362e:	91 09       	st.w	r8[0x0],r9
80003630:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003634:	fe f9 08 94 	ld.w	r9,pc[2196]
80003638:	72 08       	ld.w	r8,r9[0x0]
8000363a:	20 28       	sub	r8,2
8000363c:	93 08       	st.w	r9[0x0],r8
8000363e:	c0 71       	brne	8000364c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003640:	30 09       	mov	r9,0
80003642:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003646:	91 09       	st.w	r8[0x0],r9
80003648:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000364c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003650:	70 0a       	ld.w	r10,r8[0x0]
80003652:	fe f9 08 66 	ld.w	r9,pc[2150]
80003656:	72 09       	ld.w	r9,r9[0x0]
80003658:	8e 6b       	ld.sh	r11,r7[0xc]
8000365a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000365e:	70 09       	ld.w	r9,r8[0x0]
80003660:	2f f9       	sub	r9,-1
80003662:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003664:	e0 49 00 ff 	cp.w	r9,255
80003668:	e0 88 00 16 	brls	80003694 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000366c:	30 09       	mov	r9,0
8000366e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003670:	fe f6 08 48 	ld.w	r6,pc[2120]
80003674:	6c 0c       	ld.w	r12,r6[0x0]
80003676:	f0 1f 02 1d 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000367a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000367e:	70 0c       	ld.w	r12,r8[0x0]
80003680:	f0 1f 02 07 	mcall	80003e9c <phy_rx_func+0xe98>
80003684:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003686:	c0 71       	brne	80003694 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003688:	30 09       	mov	r9,0
8000368a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000368e:	91 09       	st.w	r8[0x0],r9
80003690:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003694:	fe f9 08 34 	ld.w	r9,pc[2100]
80003698:	72 08       	ld.w	r8,r9[0x0]
8000369a:	20 28       	sub	r8,2
8000369c:	93 08       	st.w	r9[0x0],r8
8000369e:	c0 71       	brne	800036ac <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800036a0:	30 09       	mov	r9,0
800036a2:	fe f8 08 1e 	ld.w	r8,pc[2078]
800036a6:	91 09       	st.w	r8[0x0],r9
800036a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800036ac:	fe f8 08 64 	ld.w	r8,pc[2148]
800036b0:	70 0a       	ld.w	r10,r8[0x0]
800036b2:	fe f9 08 06 	ld.w	r9,pc[2054]
800036b6:	72 09       	ld.w	r9,r9[0x0]
800036b8:	8e 7b       	ld.sh	r11,r7[0xe]
800036ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036be:	70 09       	ld.w	r9,r8[0x0]
800036c0:	2f f9       	sub	r9,-1
800036c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036c4:	e0 49 00 ff 	cp.w	r9,255
800036c8:	e0 88 00 16 	brls	800036f4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800036cc:	30 09       	mov	r9,0
800036ce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036d0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800036d4:	6e 0c       	ld.w	r12,r7[0x0]
800036d6:	f0 1f 02 05 	mcall	80003ee8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036da:	fe f8 07 da 	ld.w	r8,pc[2010]
800036de:	70 0c       	ld.w	r12,r8[0x0]
800036e0:	f0 1f 01 ef 	mcall	80003e9c <phy_rx_func+0xe98>
800036e4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800036e6:	c0 71       	brne	800036f4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800036e8:	30 09       	mov	r9,0
800036ea:	fe f8 07 d6 	ld.w	r8,pc[2006]
800036ee:	91 09       	st.w	r8[0x0],r9
800036f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036f4:	fe f9 07 d4 	ld.w	r9,pc[2004]
800036f8:	72 08       	ld.w	r8,r9[0x0]
800036fa:	20 28       	sub	r8,2
800036fc:	93 08       	st.w	r9[0x0],r8
800036fe:	e0 81 03 c0 	brne	80003e7e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003702:	30 09       	mov	r9,0
80003704:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003708:	91 09       	st.w	r8[0x0],r9
8000370a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000370e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003712:	11 89       	ld.ub	r9,r8[0x0]
80003714:	31 28       	mov	r8,18
80003716:	f0 09 18 00 	cp.b	r9,r8
8000371a:	e0 81 01 4c 	brne	800039b2 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000371e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003722:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003726:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003728:	11 89       	ld.ub	r9,r8[0x0]
8000372a:	3f 28       	mov	r8,-14
8000372c:	f0 09 18 00 	cp.b	r9,r8
80003730:	e0 81 01 3b 	brne	800039a6 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003734:	30 19       	mov	r9,1
80003736:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000373a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000373c:	6e 29       	ld.w	r9,r7[0x8]
8000373e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003742:	fe f8 07 86 	ld.w	r8,pc[1926]
80003746:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003748:	8e 59       	ld.sh	r9,r7[0xa]
8000374a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000374e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003750:	8e 69       	ld.sh	r9,r7[0xc]
80003752:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003754:	8e 79       	ld.sh	r9,r7[0xe]
80003756:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003758:	fe f8 07 88 	ld.w	r8,pc[1928]
8000375c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003760:	72 0a       	ld.w	r10,r9[0x0]
80003762:	70 09       	ld.w	r9,r8[0x0]
80003764:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003768:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000376c:	70 09       	ld.w	r9,r8[0x0]
8000376e:	2f f9       	sub	r9,-1
80003770:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003772:	e0 49 01 ff 	cp.w	r9,511
80003776:	e0 88 00 16 	brls	800037a2 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000377a:	30 09       	mov	r9,0
8000377c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000377e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003782:	6c 0c       	ld.w	r12,r6[0x0]
80003784:	f0 1f 01 d9 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003788:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000378c:	70 0c       	ld.w	r12,r8[0x0]
8000378e:	f0 1f 01 c4 	mcall	80003e9c <phy_rx_func+0xe98>
80003792:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003794:	c0 71       	brne	800037a2 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003796:	30 09       	mov	r9,0
80003798:	fe f8 07 28 	ld.w	r8,pc[1832]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037a2:	fe f9 07 26 	ld.w	r9,pc[1830]
800037a6:	72 08       	ld.w	r8,r9[0x0]
800037a8:	20 18       	sub	r8,1
800037aa:	93 08       	st.w	r9[0x0],r8
800037ac:	c0 71       	brne	800037ba <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800037ae:	30 09       	mov	r9,0
800037b0:	fe f8 07 10 	ld.w	r8,pc[1808]
800037b4:	91 09       	st.w	r8[0x0],r9
800037b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800037ba:	fe f8 07 26 	ld.w	r8,pc[1830]
800037be:	fe f9 06 fe 	ld.w	r9,pc[1790]
800037c2:	72 0a       	ld.w	r10,r9[0x0]
800037c4:	70 09       	ld.w	r9,r8[0x0]
800037c6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037ca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037ce:	70 09       	ld.w	r9,r8[0x0]
800037d0:	2f f9       	sub	r9,-1
800037d2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037d4:	e0 49 01 ff 	cp.w	r9,511
800037d8:	e0 88 00 16 	brls	80003804 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800037dc:	30 09       	mov	r9,0
800037de:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037e0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800037e4:	6c 0c       	ld.w	r12,r6[0x0]
800037e6:	f0 1f 01 c1 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037ea:	fe f8 06 ca 	ld.w	r8,pc[1738]
800037ee:	70 0c       	ld.w	r12,r8[0x0]
800037f0:	f0 1f 01 ab 	mcall	80003e9c <phy_rx_func+0xe98>
800037f4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f6:	c0 71       	brne	80003804 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800037f8:	30 09       	mov	r9,0
800037fa:	fe f8 06 c6 	ld.w	r8,pc[1734]
800037fe:	91 09       	st.w	r8[0x0],r9
80003800:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003804:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003808:	72 08       	ld.w	r8,r9[0x0]
8000380a:	20 18       	sub	r8,1
8000380c:	93 08       	st.w	r9[0x0],r8
8000380e:	c0 71       	brne	8000381c <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003810:	30 09       	mov	r9,0
80003812:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003816:	91 09       	st.w	r8[0x0],r9
80003818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000381c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003820:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003824:	72 0a       	ld.w	r10,r9[0x0]
80003826:	70 09       	ld.w	r9,r8[0x0]
80003828:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000382c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003830:	70 09       	ld.w	r9,r8[0x0]
80003832:	2f f9       	sub	r9,-1
80003834:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003836:	e0 49 01 ff 	cp.w	r9,511
8000383a:	e0 88 00 16 	brls	80003866 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000383e:	30 09       	mov	r9,0
80003840:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003842:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003846:	6c 0c       	ld.w	r12,r6[0x0]
80003848:	f0 1f 01 a8 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000384c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003850:	70 0c       	ld.w	r12,r8[0x0]
80003852:	f0 1f 01 93 	mcall	80003e9c <phy_rx_func+0xe98>
80003856:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003858:	c0 71       	brne	80003866 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000385a:	30 09       	mov	r9,0
8000385c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003860:	91 09       	st.w	r8[0x0],r9
80003862:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003866:	fe f9 06 62 	ld.w	r9,pc[1634]
8000386a:	72 08       	ld.w	r8,r9[0x0]
8000386c:	20 18       	sub	r8,1
8000386e:	93 08       	st.w	r9[0x0],r8
80003870:	c0 71       	brne	8000387e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003872:	30 09       	mov	r9,0
80003874:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003878:	91 09       	st.w	r8[0x0],r9
8000387a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000387e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003882:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003886:	72 0a       	ld.w	r10,r9[0x0]
80003888:	70 09       	ld.w	r9,r8[0x0]
8000388a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000388e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003892:	70 09       	ld.w	r9,r8[0x0]
80003894:	2f f9       	sub	r9,-1
80003896:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003898:	e0 49 01 ff 	cp.w	r9,511
8000389c:	e0 88 00 16 	brls	800038c8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800038a0:	30 09       	mov	r9,0
800038a2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038a4:	fe f6 06 18 	ld.w	r6,pc[1560]
800038a8:	6c 0c       	ld.w	r12,r6[0x0]
800038aa:	f0 1f 01 90 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038ae:	fe f8 06 06 	ld.w	r8,pc[1542]
800038b2:	70 0c       	ld.w	r12,r8[0x0]
800038b4:	f0 1f 01 7a 	mcall	80003e9c <phy_rx_func+0xe98>
800038b8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038ba:	c0 71       	brne	800038c8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800038bc:	30 09       	mov	r9,0
800038be:	fe f8 06 02 	ld.w	r8,pc[1538]
800038c2:	91 09       	st.w	r8[0x0],r9
800038c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038c8:	fe f9 06 00 	ld.w	r9,pc[1536]
800038cc:	72 08       	ld.w	r8,r9[0x0]
800038ce:	20 18       	sub	r8,1
800038d0:	93 08       	st.w	r9[0x0],r8
800038d2:	c0 71       	brne	800038e0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800038d4:	30 09       	mov	r9,0
800038d6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800038da:	91 09       	st.w	r8[0x0],r9
800038dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800038e0:	fe f8 06 00 	ld.w	r8,pc[1536]
800038e4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800038e8:	72 0a       	ld.w	r10,r9[0x0]
800038ea:	70 09       	ld.w	r9,r8[0x0]
800038ec:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800038f0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038f4:	70 09       	ld.w	r9,r8[0x0]
800038f6:	2f f9       	sub	r9,-1
800038f8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038fa:	e0 49 01 ff 	cp.w	r9,511
800038fe:	e0 88 00 16 	brls	8000392a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003902:	30 09       	mov	r9,0
80003904:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003906:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000390a:	6c 0c       	ld.w	r12,r6[0x0]
8000390c:	f0 1f 01 77 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003910:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003914:	70 0c       	ld.w	r12,r8[0x0]
80003916:	f0 1f 01 62 	mcall	80003e9c <phy_rx_func+0xe98>
8000391a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000391c:	c0 71       	brne	8000392a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000391e:	30 09       	mov	r9,0
80003920:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003924:	91 09       	st.w	r8[0x0],r9
80003926:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000392a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000392e:	72 08       	ld.w	r8,r9[0x0]
80003930:	20 18       	sub	r8,1
80003932:	93 08       	st.w	r9[0x0],r8
80003934:	c0 71       	brne	80003942 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003936:	30 09       	mov	r9,0
80003938:	fe f8 05 88 	ld.w	r8,pc[1416]
8000393c:	91 09       	st.w	r8[0x0],r9
8000393e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003942:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003946:	fe f9 05 76 	ld.w	r9,pc[1398]
8000394a:	72 0a       	ld.w	r10,r9[0x0]
8000394c:	70 09       	ld.w	r9,r8[0x0]
8000394e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003952:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003956:	70 09       	ld.w	r9,r8[0x0]
80003958:	2f f9       	sub	r9,-1
8000395a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000395c:	e0 49 01 ff 	cp.w	r9,511
80003960:	e0 88 00 16 	brls	8000398c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003964:	30 09       	mov	r9,0
80003966:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003968:	fe f7 05 54 	ld.w	r7,pc[1364]
8000396c:	6e 0c       	ld.w	r12,r7[0x0]
8000396e:	f0 1f 01 5f 	mcall	80003ee8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003972:	fe f8 05 42 	ld.w	r8,pc[1346]
80003976:	70 0c       	ld.w	r12,r8[0x0]
80003978:	f0 1f 01 49 	mcall	80003e9c <phy_rx_func+0xe98>
8000397c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000397e:	c0 71       	brne	8000398c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003980:	30 09       	mov	r9,0
80003982:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003986:	91 09       	st.w	r8[0x0],r9
80003988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000398c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003990:	72 08       	ld.w	r8,r9[0x0]
80003992:	20 18       	sub	r8,1
80003994:	93 08       	st.w	r9[0x0],r8
80003996:	e0 81 02 74 	brne	80003e7e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000399a:	30 09       	mov	r9,0
8000399c:	fe f8 05 24 	ld.w	r8,pc[1316]
800039a0:	91 09       	st.w	r8[0x0],r9
800039a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800039a6:	30 09       	mov	r9,0
800039a8:	fe f8 05 18 	ld.w	r8,pc[1304]
800039ac:	91 09       	st.w	r8[0x0],r9
800039ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800039b2:	fe f8 05 26 	ld.w	r8,pc[1318]
800039b6:	11 89       	ld.ub	r9,r8[0x0]
800039b8:	3f 28       	mov	r8,-14
800039ba:	f0 09 18 00 	cp.b	r9,r8
800039be:	c4 31       	brne	80003a44 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800039c0:	8e 49       	ld.sh	r9,r7[0x8]
800039c2:	fe f8 05 56 	ld.w	r8,pc[1366]
800039c6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800039c8:	fe f8 05 18 	ld.w	r8,pc[1304]
800039cc:	fe f9 04 f0 	ld.w	r9,pc[1264]
800039d0:	72 0a       	ld.w	r10,r9[0x0]
800039d2:	70 09       	ld.w	r9,r8[0x0]
800039d4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800039d8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039dc:	70 09       	ld.w	r9,r8[0x0]
800039de:	2f f9       	sub	r9,-1
800039e0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e2:	e0 49 01 ff 	cp.w	r9,511
800039e6:	e0 88 00 16 	brls	80003a12 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039ea:	30 09       	mov	r9,0
800039ec:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039ee:	fe f7 04 ce 	ld.w	r7,pc[1230]
800039f2:	6e 0c       	ld.w	r12,r7[0x0]
800039f4:	f0 1f 01 3d 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f8:	fe f8 04 bc 	ld.w	r8,pc[1212]
800039fc:	70 0c       	ld.w	r12,r8[0x0]
800039fe:	f0 1f 01 28 	mcall	80003e9c <phy_rx_func+0xe98>
80003a02:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a04:	c0 71       	brne	80003a12 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003a06:	30 09       	mov	r9,0
80003a08:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a12:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003a16:	72 08       	ld.w	r8,r9[0x0]
80003a18:	20 18       	sub	r8,1
80003a1a:	93 08       	st.w	r9[0x0],r8
80003a1c:	c0 71       	brne	80003a2a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003a2a:	20 18       	sub	r8,1
80003a2c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003a30:	93 08       	st.w	r9[0x0],r8
80003a32:	58 08       	cp.w	r8,0
80003a34:	e0 81 02 25 	brne	80003e7e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003a38:	30 09       	mov	r9,0
80003a3a:	fe f8 04 86 	ld.w	r8,pc[1158]
80003a3e:	91 09       	st.w	r8[0x0],r9
80003a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003a44:	fe f8 04 94 	ld.w	r8,pc[1172]
80003a48:	11 89       	ld.ub	r9,r8[0x0]
80003a4a:	3f 38       	mov	r8,-13
80003a4c:	f0 09 18 00 	cp.b	r9,r8
80003a50:	e0 81 01 0c 	brne	80003c68 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003a54:	8e 49       	ld.sh	r9,r7[0x8]
80003a56:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003a5a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003a5c:	8e 59       	ld.sh	r9,r7[0xa]
80003a5e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003a60:	8e 69       	ld.sh	r9,r7[0xc]
80003a62:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003a64:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003a68:	fe f9 04 54 	ld.w	r9,pc[1108]
80003a6c:	72 0a       	ld.w	r10,r9[0x0]
80003a6e:	70 09       	ld.w	r9,r8[0x0]
80003a70:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a74:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a78:	70 09       	ld.w	r9,r8[0x0]
80003a7a:	2f f9       	sub	r9,-1
80003a7c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a7e:	e0 49 01 ff 	cp.w	r9,511
80003a82:	e0 88 00 16 	brls	80003aae <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a86:	30 09       	mov	r9,0
80003a88:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a8a:	fe f6 04 32 	ld.w	r6,pc[1074]
80003a8e:	6c 0c       	ld.w	r12,r6[0x0]
80003a90:	f0 1f 01 16 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a94:	fe f8 04 20 	ld.w	r8,pc[1056]
80003a98:	70 0c       	ld.w	r12,r8[0x0]
80003a9a:	f0 1f 01 01 	mcall	80003e9c <phy_rx_func+0xe98>
80003a9e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003aa0:	c0 71       	brne	80003aae <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003aa2:	30 09       	mov	r9,0
80003aa4:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003aa8:	91 09       	st.w	r8[0x0],r9
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aae:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003ab2:	72 08       	ld.w	r8,r9[0x0]
80003ab4:	20 18       	sub	r8,1
80003ab6:	93 08       	st.w	r9[0x0],r8
80003ab8:	c0 71       	brne	80003ac6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003aba:	30 09       	mov	r9,0
80003abc:	fe f8 04 04 	ld.w	r8,pc[1028]
80003ac0:	91 09       	st.w	r8[0x0],r9
80003ac2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003ac6:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003aca:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003ace:	72 0a       	ld.w	r10,r9[0x0]
80003ad0:	70 09       	ld.w	r9,r8[0x0]
80003ad2:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ad6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ada:	70 09       	ld.w	r9,r8[0x0]
80003adc:	2f f9       	sub	r9,-1
80003ade:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ae0:	e0 49 01 ff 	cp.w	r9,511
80003ae4:	e0 88 00 16 	brls	80003b10 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ae8:	30 09       	mov	r9,0
80003aea:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003aec:	fe f6 03 d0 	ld.w	r6,pc[976]
80003af0:	6c 0c       	ld.w	r12,r6[0x0]
80003af2:	f0 1f 00 fe 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003af6:	fe f8 03 be 	ld.w	r8,pc[958]
80003afa:	70 0c       	ld.w	r12,r8[0x0]
80003afc:	f0 1f 00 e8 	mcall	80003e9c <phy_rx_func+0xe98>
80003b00:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b02:	c0 71       	brne	80003b10 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003b04:	30 09       	mov	r9,0
80003b06:	fe f8 03 ba 	ld.w	r8,pc[954]
80003b0a:	91 09       	st.w	r8[0x0],r9
80003b0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b10:	fe f9 03 b8 	ld.w	r9,pc[952]
80003b14:	72 08       	ld.w	r8,r9[0x0]
80003b16:	20 18       	sub	r8,1
80003b18:	93 08       	st.w	r9[0x0],r8
80003b1a:	c0 71       	brne	80003b28 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003b1c:	30 09       	mov	r9,0
80003b1e:	fe f8 03 a2 	ld.w	r8,pc[930]
80003b22:	91 09       	st.w	r8[0x0],r9
80003b24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003b28:	fe f8 03 b8 	ld.w	r8,pc[952]
80003b2c:	fe f9 03 90 	ld.w	r9,pc[912]
80003b30:	72 0a       	ld.w	r10,r9[0x0]
80003b32:	70 09       	ld.w	r9,r8[0x0]
80003b34:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b38:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b3c:	70 09       	ld.w	r9,r8[0x0]
80003b3e:	2f f9       	sub	r9,-1
80003b40:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b42:	e0 49 01 ff 	cp.w	r9,511
80003b46:	e0 88 00 16 	brls	80003b72 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b4a:	30 09       	mov	r9,0
80003b4c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b4e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003b52:	6c 0c       	ld.w	r12,r6[0x0]
80003b54:	f0 1f 00 e5 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b58:	fe f8 03 5c 	ld.w	r8,pc[860]
80003b5c:	70 0c       	ld.w	r12,r8[0x0]
80003b5e:	f0 1f 00 d0 	mcall	80003e9c <phy_rx_func+0xe98>
80003b62:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b64:	c0 71       	brne	80003b72 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003b66:	30 09       	mov	r9,0
80003b68:	fe f8 03 58 	ld.w	r8,pc[856]
80003b6c:	91 09       	st.w	r8[0x0],r9
80003b6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b72:	fe f9 03 56 	ld.w	r9,pc[854]
80003b76:	72 08       	ld.w	r8,r9[0x0]
80003b78:	20 18       	sub	r8,1
80003b7a:	93 08       	st.w	r9[0x0],r8
80003b7c:	c0 71       	brne	80003b8a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003b7e:	30 09       	mov	r9,0
80003b80:	fe f8 03 40 	ld.w	r8,pc[832]
80003b84:	91 09       	st.w	r8[0x0],r9
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003b8a:	fe f8 03 56 	ld.w	r8,pc[854]
80003b8e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003b92:	72 0a       	ld.w	r10,r9[0x0]
80003b94:	70 09       	ld.w	r9,r8[0x0]
80003b96:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b9a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b9e:	70 09       	ld.w	r9,r8[0x0]
80003ba0:	2f f9       	sub	r9,-1
80003ba2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ba4:	e0 49 01 ff 	cp.w	r9,511
80003ba8:	e0 88 00 16 	brls	80003bd4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003bac:	30 09       	mov	r9,0
80003bae:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003bb0:	fe f6 03 0c 	ld.w	r6,pc[780]
80003bb4:	6c 0c       	ld.w	r12,r6[0x0]
80003bb6:	f0 1f 00 cd 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bba:	fe f8 02 fa 	ld.w	r8,pc[762]
80003bbe:	70 0c       	ld.w	r12,r8[0x0]
80003bc0:	f0 1f 00 b7 	mcall	80003e9c <phy_rx_func+0xe98>
80003bc4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bc6:	c0 71       	brne	80003bd4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003bc8:	30 09       	mov	r9,0
80003bca:	fe f8 02 f6 	ld.w	r8,pc[758]
80003bce:	91 09       	st.w	r8[0x0],r9
80003bd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bd4:	fe f9 02 f4 	ld.w	r9,pc[756]
80003bd8:	72 08       	ld.w	r8,r9[0x0]
80003bda:	20 18       	sub	r8,1
80003bdc:	93 08       	st.w	r9[0x0],r8
80003bde:	c0 71       	brne	80003bec <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003be0:	30 09       	mov	r9,0
80003be2:	fe f8 02 de 	ld.w	r8,pc[734]
80003be6:	91 09       	st.w	r8[0x0],r9
80003be8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003bec:	fe f8 02 f4 	ld.w	r8,pc[756]
80003bf0:	fe f9 02 cc 	ld.w	r9,pc[716]
80003bf4:	72 0a       	ld.w	r10,r9[0x0]
80003bf6:	70 09       	ld.w	r9,r8[0x0]
80003bf8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003bfc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c00:	70 09       	ld.w	r9,r8[0x0]
80003c02:	2f f9       	sub	r9,-1
80003c04:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c06:	e0 49 01 ff 	cp.w	r9,511
80003c0a:	e0 88 00 16 	brls	80003c36 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c0e:	30 09       	mov	r9,0
80003c10:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c12:	fe f7 02 aa 	ld.w	r7,pc[682]
80003c16:	6e 0c       	ld.w	r12,r7[0x0]
80003c18:	f0 1f 00 b4 	mcall	80003ee8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c1c:	fe f8 02 98 	ld.w	r8,pc[664]
80003c20:	70 0c       	ld.w	r12,r8[0x0]
80003c22:	f0 1f 00 9f 	mcall	80003e9c <phy_rx_func+0xe98>
80003c26:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c28:	c0 71       	brne	80003c36 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003c2a:	30 09       	mov	r9,0
80003c2c:	fe f8 02 94 	ld.w	r8,pc[660]
80003c30:	91 09       	st.w	r8[0x0],r9
80003c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c36:	fe f9 02 92 	ld.w	r9,pc[658]
80003c3a:	72 08       	ld.w	r8,r9[0x0]
80003c3c:	20 18       	sub	r8,1
80003c3e:	93 08       	st.w	r9[0x0],r8
80003c40:	c0 71       	brne	80003c4e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003c42:	30 09       	mov	r9,0
80003c44:	fe f8 02 7c 	ld.w	r8,pc[636]
80003c48:	91 09       	st.w	r8[0x0],r9
80003c4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003c4e:	20 18       	sub	r8,1
80003c50:	fe f9 02 78 	ld.w	r9,pc[632]
80003c54:	93 08       	st.w	r9[0x0],r8
80003c56:	58 08       	cp.w	r8,0
80003c58:	e0 81 01 13 	brne	80003e7e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003c5c:	30 09       	mov	r9,0
80003c5e:	fe f8 02 62 	ld.w	r8,pc[610]
80003c62:	91 09       	st.w	r8[0x0],r9
80003c64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003c68:	fe f8 02 70 	ld.w	r8,pc[624]
80003c6c:	11 89       	ld.ub	r9,r8[0x0]
80003c6e:	30 48       	mov	r8,4
80003c70:	f0 09 18 00 	cp.b	r9,r8
80003c74:	c0 80       	breq	80003c84 <phy_rx_func+0xc80>
80003c76:	fe f8 02 62 	ld.w	r8,pc[610]
80003c7a:	11 89       	ld.ub	r9,r8[0x0]
80003c7c:	30 38       	mov	r8,3
80003c7e:	f0 09 18 00 	cp.b	r9,r8
80003c82:	c1 41       	brne	80003caa <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003c84:	6e 29       	ld.w	r9,r7[0x8]
80003c86:	fe f8 02 7a 	ld.w	r8,pc[634]
80003c8a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003c8c:	6e 39       	ld.w	r9,r7[0xc]
80003c8e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003c90:	fe f9 02 38 	ld.w	r9,pc[568]
80003c94:	72 08       	ld.w	r8,r9[0x0]
80003c96:	20 88       	sub	r8,8
80003c98:	93 08       	st.w	r9[0x0],r8
80003c9a:	e0 81 00 f2 	brne	80003e7e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003c9e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ca0:	fe f9 02 20 	ld.w	r9,pc[544]
80003ca4:	93 08       	st.w	r9[0x0],r8
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003caa:	fe f8 02 2e 	ld.w	r8,pc[558]
80003cae:	11 89       	ld.ub	r9,r8[0x0]
80003cb0:	31 38       	mov	r8,19
80003cb2:	f0 09 18 00 	cp.b	r9,r8
80003cb6:	e0 81 00 9c 	brne	80003dee <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003cba:	fe f8 02 62 	ld.w	r8,pc[610]
80003cbe:	11 88       	ld.ub	r8,r8[0x0]
80003cc0:	30 c9       	mov	r9,12
80003cc2:	f2 08 18 00 	cp.b	r8,r9
80003cc6:	e0 81 00 7b 	brne	80003dbc <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003cca:	8e 49       	ld.sh	r9,r7[0x8]
80003ccc:	fe f8 02 54 	ld.w	r8,pc[596]
80003cd0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003cd4:	30 09       	mov	r9,0
80003cd6:	fe f8 02 46 	ld.w	r8,pc[582]
80003cda:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cdc:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ce0:	3f 38       	mov	r8,-13
80003ce2:	f0 09 18 00 	cp.b	r9,r8
80003ce6:	c6 61       	brne	80003db2 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ce8:	10 99       	mov	r9,r8
80003cea:	4f c8       	lddpc	r8,80003ed8 <phy_rx_func+0xed4>
80003cec:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003cee:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003cf2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003cf6:	4f 58       	lddpc	r8,80003ec8 <phy_rx_func+0xec4>
80003cf8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003cfa:	30 19       	mov	r9,1
80003cfc:	fe f8 02 0c 	ld.w	r8,pc[524]
80003d00:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003d02:	8e 79       	ld.sh	r9,r7[0xe]
80003d04:	fe f8 02 14 	ld.w	r8,pc[532]
80003d08:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003d0a:	4f 68       	lddpc	r8,80003ee0 <phy_rx_func+0xedc>
80003d0c:	4e c9       	lddpc	r9,80003ebc <phy_rx_func+0xeb8>
80003d0e:	72 0a       	ld.w	r10,r9[0x0]
80003d10:	70 09       	ld.w	r9,r8[0x0]
80003d12:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d16:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d1a:	70 09       	ld.w	r9,r8[0x0]
80003d1c:	2f f9       	sub	r9,-1
80003d1e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d20:	e0 49 01 ff 	cp.w	r9,511
80003d24:	e0 88 00 13 	brls	80003d4a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d28:	30 09       	mov	r9,0
80003d2a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d2c:	4e 46       	lddpc	r6,80003ebc <phy_rx_func+0xeb8>
80003d2e:	6c 0c       	ld.w	r12,r6[0x0]
80003d30:	f0 1f 00 6e 	mcall	80003ee8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d34:	4e 08       	lddpc	r8,80003eb4 <phy_rx_func+0xeb0>
80003d36:	70 0c       	ld.w	r12,r8[0x0]
80003d38:	f0 1f 00 59 	mcall	80003e9c <phy_rx_func+0xe98>
80003d3c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d3e:	c0 61       	brne	80003d4a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003d40:	30 09       	mov	r9,0
80003d42:	4e 08       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d44:	91 09       	st.w	r8[0x0],r9
80003d46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d4a:	4e 09       	lddpc	r9,80003ec8 <phy_rx_func+0xec4>
80003d4c:	72 08       	ld.w	r8,r9[0x0]
80003d4e:	20 18       	sub	r8,1
80003d50:	93 08       	st.w	r9[0x0],r8
80003d52:	c0 61       	brne	80003d5e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003d54:	30 09       	mov	r9,0
80003d56:	4d b8       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d58:	91 09       	st.w	r8[0x0],r9
80003d5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003d5e:	4e 18       	lddpc	r8,80003ee0 <phy_rx_func+0xedc>
80003d60:	4d 79       	lddpc	r9,80003ebc <phy_rx_func+0xeb8>
80003d62:	72 0a       	ld.w	r10,r9[0x0]
80003d64:	70 09       	ld.w	r9,r8[0x0]
80003d66:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d6a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d6e:	70 09       	ld.w	r9,r8[0x0]
80003d70:	2f f9       	sub	r9,-1
80003d72:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d74:	e0 49 01 ff 	cp.w	r9,511
80003d78:	e0 88 00 13 	brls	80003d9e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d7c:	30 09       	mov	r9,0
80003d7e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d80:	4c f7       	lddpc	r7,80003ebc <phy_rx_func+0xeb8>
80003d82:	6e 0c       	ld.w	r12,r7[0x0]
80003d84:	f0 1f 00 59 	mcall	80003ee8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d88:	4c b8       	lddpc	r8,80003eb4 <phy_rx_func+0xeb0>
80003d8a:	70 0c       	ld.w	r12,r8[0x0]
80003d8c:	f0 1f 00 44 	mcall	80003e9c <phy_rx_func+0xe98>
80003d90:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d92:	c0 61       	brne	80003d9e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003d94:	30 09       	mov	r9,0
80003d96:	4c b8       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003d98:	91 09       	st.w	r8[0x0],r9
80003d9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d9e:	4c b9       	lddpc	r9,80003ec8 <phy_rx_func+0xec4>
80003da0:	72 08       	ld.w	r8,r9[0x0]
80003da2:	20 18       	sub	r8,1
80003da4:	93 08       	st.w	r9[0x0],r8
80003da6:	c6 c1       	brne	80003e7e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003da8:	30 09       	mov	r9,0
80003daa:	4c 68       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003dac:	91 09       	st.w	r8[0x0],r9
80003dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003db2:	30 09       	mov	r9,0
80003db4:	4c 38       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003db6:	91 09       	st.w	r8[0x0],r9
80003db8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003dbc:	8e 4a       	ld.sh	r10,r7[0x8]
80003dbe:	4d 99       	lddpc	r9,80003f20 <phy_rx_func+0xf1c>
80003dc0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003dc4:	4d 6a       	lddpc	r10,80003f1c <phy_rx_func+0xf18>
80003dc6:	15 88       	ld.ub	r8,r10[0x0]
80003dc8:	f0 cb ff ff 	sub	r11,r8,-1
80003dcc:	8e 5c       	ld.sh	r12,r7[0xa]
80003dce:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003dd2:	f0 cb ff fe 	sub	r11,r8,-2
80003dd6:	8e 6c       	ld.sh	r12,r7[0xc]
80003dd8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ddc:	f0 cb ff fd 	sub	r11,r8,-3
80003de0:	8e 7c       	ld.sh	r12,r7[0xe]
80003de2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003de6:	2f c8       	sub	r8,-4
80003de8:	b4 88       	st.b	r10[0x0],r8
80003dea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003dee:	30 09       	mov	r9,0
80003df0:	4b 48       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003df2:	91 09       	st.w	r8[0x0],r9
80003df4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003df8:	4c 08       	lddpc	r8,80003ef8 <phy_rx_func+0xef4>
80003dfa:	70 09       	ld.w	r9,r8[0x0]
80003dfc:	8e 4b       	ld.sh	r11,r7[0x8]
80003dfe:	4c 0a       	lddpc	r10,80003efc <phy_rx_func+0xef8>
80003e00:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003e04:	2f f9       	sub	r9,-1
80003e06:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e08:	4b 58       	lddpc	r8,80003edc <phy_rx_func+0xed8>
80003e0a:	70 09       	ld.w	r9,r8[0x0]
80003e0c:	20 29       	sub	r9,2
80003e0e:	91 09       	st.w	r8[0x0],r9
80003e10:	70 08       	ld.w	r8,r8[0x0]
80003e12:	58 08       	cp.w	r8,0
80003e14:	c2 f1       	brne	80003e72 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003e16:	30 09       	mov	r9,0
80003e18:	4b 88       	lddpc	r8,80003ef8 <phy_rx_func+0xef4>
80003e1a:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e1c:	8e 59       	ld.sh	r9,r7[0xa]
80003e1e:	fe 78 82 12 	mov	r8,-32238
80003e22:	f0 09 19 00 	cp.h	r9,r8
80003e26:	c2 11       	brne	80003e68 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003e28:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e2c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003e30:	4a f8       	lddpc	r8,80003eec <phy_rx_func+0xee8>
80003e32:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e34:	8e 59       	ld.sh	r9,r7[0xa]
80003e36:	4a f8       	lddpc	r8,80003ef0 <phy_rx_func+0xeec>
80003e38:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e3a:	8e 69       	ld.sh	r9,r7[0xc]
80003e3c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e3e:	f0 1f 00 2e 	mcall	80003ef4 <phy_rx_func+0xef0>
80003e42:	4a 18       	lddpc	r8,80003ec4 <phy_rx_func+0xec0>
80003e44:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e46:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003e4a:	31 38       	mov	r8,19
80003e4c:	f0 09 18 00 	cp.b	r9,r8
80003e50:	c0 71       	brne	80003e5e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003e52:	10 99       	mov	r9,r8
80003e54:	4a 18       	lddpc	r8,80003ed8 <phy_rx_func+0xed4>
80003e56:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003e58:	30 09       	mov	r9,0
80003e5a:	49 c8       	lddpc	r8,80003ec8 <phy_rx_func+0xec4>
80003e5c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003e5e:	30 49       	mov	r9,4
80003e60:	49 88       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e62:	91 09       	st.w	r8[0x0],r9
80003e64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003e68:	30 09       	mov	r9,0
80003e6a:	49 68       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e6c:	91 09       	st.w	r8[0x0],r9
80003e6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003e72:	4a dc       	lddpc	r12,80003f24 <phy_rx_func+0xf20>
80003e74:	f0 1f 00 18 	mcall	80003ed4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003e78:	30 09       	mov	r9,0
80003e7a:	49 28       	lddpc	r8,80003ec0 <phy_rx_func+0xebc>
80003e7c:	91 09       	st.w	r8[0x0],r9
80003e7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e82:	00 00       	add	r0,r0
80003e84:	00 00       	add	r0,r0
80003e86:	0a a8       	st.w	r5++,r8
80003e88:	00 00       	add	r0,r0
80003e8a:	0a b4       	st.h	r5++,r4
80003e8c:	00 00       	add	r0,r0
80003e8e:	0a 98       	mov	r8,r5
80003e90:	00 00       	add	r0,r0
80003e92:	0a 70       	tst	r0,r5
80003e94:	00 00       	add	r0,r0
80003e96:	0a 60       	and	r0,r5
80003e98:	00 00       	add	r0,r0
80003e9a:	0a 8c       	andn	r12,r5
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	2a 64       	sub	r4,-90
80003ea0:	00 00       	add	r0,r0
80003ea2:	0a b8       	st.h	r5++,r8
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	29 94       	sub	r4,-103
80003ea8:	00 00       	add	r0,r0
80003eaa:	0a a0       	st.w	r5++,r0
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	29 b0       	sub	r0,-101
80003eb0:	00 00       	add	r0,r0
80003eb2:	0a 7d       	tst	sp,r5
80003eb4:	00 00       	add	r0,r0
80003eb6:	0a 94       	mov	r4,r5
80003eb8:	00 00       	add	r0,r0
80003eba:	0a ac       	st.w	r5++,r12
80003ebc:	00 00       	add	r0,r0
80003ebe:	0a c8       	st.b	r5++,r8
80003ec0:	00 00       	add	r0,r0
80003ec2:	0a 88       	andn	r8,r5
80003ec4:	00 00       	add	r0,r0
80003ec6:	0a c0       	st.b	r5++,r0
80003ec8:	00 00       	add	r0,r0
80003eca:	0a 6c       	and	r12,r5
80003ecc:	00 00       	add	r0,r0
80003ece:	0a 3c       	cp.w	r12,r5
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	d3 2c       	*unknown*
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	6d 50       	ld.w	r0,r6[0x54]
80003ed8:	00 00       	add	r0,r0
80003eda:	0a 7c       	tst	r12,r5
80003edc:	00 00       	add	r0,r0
80003ede:	0a 5c       	eor	r12,r5
80003ee0:	00 00       	add	r0,r0
80003ee2:	0a 74       	tst	r4,r5
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	75 a0       	ld.w	r0,r10[0x68]
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	2f a4       	sub	r4,-6
80003eec:	00 00       	add	r0,r0
80003eee:	0a 32       	cp.w	r2,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	1e 98       	mov	r8,pc
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	28 f4       	sub	r4,-113
80003ef8:	00 00       	add	r0,r0
80003efa:	0a a4       	st.w	r5++,r4
80003efc:	00 00       	add	r0,r0
80003efe:	1d 9c       	ld.ub	r12,lr[0x1]
80003f00:	00 00       	add	r0,r0
80003f02:	0a 80       	andn	r0,r5
80003f04:	00 00       	add	r0,r0
80003f06:	0a 33       	cp.w	r3,r5
80003f08:	00 00       	add	r0,r0
80003f0a:	0a 31       	cp.w	r1,r5
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a 54       	eor	r4,r5
80003f10:	00 00       	add	r0,r0
80003f12:	0a 90       	mov	r0,r5
80003f14:	00 00       	add	r0,r0
80003f16:	0a 47       	or	r7,r5
80003f18:	00 00       	add	r0,r0
80003f1a:	1d 94       	ld.ub	r4,lr[0x1]
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a b0       	st.h	r5++,r0
80003f20:	00 00       	add	r0,r0
80003f22:	1e 9c       	mov	r12,pc
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	d3 44       	*unknown*

80003f28 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f28:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f2a:	49 88       	lddpc	r8,80003f88 <pdca_int_handler+0x60>
80003f2c:	11 89       	ld.ub	r9,r8[0x0]
80003f2e:	ec 19 00 01 	eorl	r9,0x1
80003f32:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f34:	11 89       	ld.ub	r9,r8[0x0]
80003f36:	a5 69       	lsl	r9,0x4
80003f38:	2f c9       	sub	r9,-4
80003f3a:	49 5a       	lddpc	r10,80003f8c <pdca_int_handler+0x64>
80003f3c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f3e:	fe 7a 00 40 	mov	r10,-65472
80003f42:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f44:	30 39       	mov	r9,3
80003f46:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003f48:	11 8a       	ld.ub	r10,r8[0x0]
80003f4a:	a5 6a       	lsl	r10,0x4
80003f4c:	2f ca       	sub	r10,-4
80003f4e:	49 18       	lddpc	r8,80003f90 <pdca_int_handler+0x68>
80003f50:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003f52:	fe 78 00 00 	mov	r8,-65536
80003f56:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003f58:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003f5a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003f5c:	48 e8       	lddpc	r8,80003f94 <pdca_int_handler+0x6c>
80003f5e:	70 08       	ld.w	r8,r8[0x0]
80003f60:	58 08       	cp.w	r8,0
80003f62:	c0 70       	breq	80003f70 <pdca_int_handler+0x48>
80003f64:	48 99       	lddpc	r9,80003f88 <pdca_int_handler+0x60>
80003f66:	13 89       	ld.ub	r9,r9[0x0]
80003f68:	a5 69       	lsl	r9,0x4
80003f6a:	48 ac       	lddpc	r12,80003f90 <pdca_int_handler+0x68>
80003f6c:	12 0c       	add	r12,r9
80003f6e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003f70:	48 a8       	lddpc	r8,80003f98 <pdca_int_handler+0x70>
80003f72:	70 08       	ld.w	r8,r8[0x0]
80003f74:	58 08       	cp.w	r8,0
80003f76:	c0 70       	breq	80003f84 <pdca_int_handler+0x5c>
80003f78:	48 49       	lddpc	r9,80003f88 <pdca_int_handler+0x60>
80003f7a:	13 89       	ld.ub	r9,r9[0x0]
80003f7c:	a5 69       	lsl	r9,0x4
80003f7e:	48 4c       	lddpc	r12,80003f8c <pdca_int_handler+0x64>
80003f80:	12 0c       	add	r12,r9
80003f82:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003f84:	d4 02       	popm	lr
80003f86:	d6 03       	rete
80003f88:	00 00       	add	r0,r0
80003f8a:	50 bc       	stdsp	sp[0x2c],r12
80003f8c:	00 00       	add	r0,r0
80003f8e:	50 e4       	stdsp	sp[0x38],r4
80003f90:	00 00       	add	r0,r0
80003f92:	50 c4       	stdsp	sp[0x30],r4
80003f94:	00 00       	add	r0,r0
80003f96:	0a d4       	st.w	--r5,r4
80003f98:	00 00       	add	r0,r0
80003f9a:	0a d8       	st.w	--r5,r8

80003f9c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003f9c:	fe 78 10 00 	mov	r8,-61440
80003fa0:	e0 69 0d c0 	mov	r9,3520
80003fa4:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003fa8:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003fac:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003fb0:	fe 78 34 00 	mov	r8,-52224
80003fb4:	e0 69 80 00 	mov	r9,32768
80003fb8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003fba:	30 09       	mov	r9,0
80003fbc:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003fbe:	e0 69 04 21 	mov	r9,1057
80003fc2:	ea 19 3f 20 	orh	r9,0x3f20
80003fc6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003fc8:	e0 69 02 9f 	mov	r9,671
80003fcc:	ea 19 01 00 	orh	r9,0x100
80003fd0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003fd2:	e0 6a 04 02 	mov	r10,1026
80003fd6:	ea 1a 3f 20 	orh	r10,0x3f20
80003fda:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003fdc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003fde:	5e fc       	retal	r12

80003fe0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003fe0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003fe2:	30 19       	mov	r9,1
80003fe4:	49 78       	lddpc	r8,80004040 <local_start_PDC+0x60>
80003fe6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003fe8:	fe 78 00 00 	mov	r8,-65536
80003fec:	30 7b       	mov	r11,7
80003fee:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003ff0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003ff2:	49 59       	lddpc	r9,80004044 <local_start_PDC+0x64>
80003ff4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ff8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003ffa:	30 3a       	mov	r10,3
80003ffc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003ffe:	30 1c       	mov	r12,1
80004000:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004002:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004004:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004006:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004008:	30 2c       	mov	r12,2
8000400a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
8000400c:	48 f9       	lddpc	r9,80004048 <local_start_PDC+0x68>
8000400e:	e0 68 5a 5a 	mov	r8,23130
80004012:	ea 18 ab cd 	orh	r8,0xabcd
80004016:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004018:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000401a:	30 0e       	mov	lr,0
8000401c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000401e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004020:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004022:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004024:	fe 78 00 40 	mov	r8,-65472
80004028:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000402a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000402c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004030:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004032:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004034:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004036:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004038:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000403a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000403c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000403e:	d8 02       	popm	pc
80004040:	00 00       	add	r0,r0
80004042:	50 bc       	stdsp	sp[0x2c],r12
80004044:	00 00       	add	r0,r0
80004046:	50 c4       	stdsp	sp[0x30],r4
80004048:	00 00       	add	r0,r0
8000404a:	50 e4       	stdsp	sp[0x38],r4

8000404c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000404c:	48 38       	lddpc	r8,80004058 <register_rx_tx_func+0xc>
8000404e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004050:	48 38       	lddpc	r8,8000405c <register_rx_tx_func+0x10>
80004052:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004054:	5e fc       	retal	r12
80004056:	00 00       	add	r0,r0
80004058:	00 00       	add	r0,r0
8000405a:	0a d4       	st.w	--r5,r4
8000405c:	00 00       	add	r0,r0
8000405e:	0a d8       	st.w	--r5,r8

80004060 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004060:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004062:	fe 78 10 00 	mov	r8,-61440
80004066:	30 29       	mov	r9,2
80004068:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000406c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004070:	10 99       	mov	r9,r8
80004072:	f2 f8 01 60 	ld.w	r8,r9[352]
80004076:	e2 18 00 02 	andl	r8,0x2,COH
8000407a:	cf c0       	breq	80004072 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000407c:	fe 79 10 00 	mov	r9,-61440
80004080:	f2 f8 01 60 	ld.w	r8,r9[352]
80004084:	e2 18 00 02 	andl	r8,0x2,COH
80004088:	cf c1       	brne	80004080 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000408a:	30 3a       	mov	r10,3
8000408c:	36 0b       	mov	r11,96
8000408e:	48 bc       	lddpc	r12,800040b8 <ssc_init+0x58>
80004090:	f0 1f 00 0b 	mcall	800040bc <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004094:	f0 1f 00 0b 	mcall	800040c0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004098:	f0 1f 00 0b 	mcall	800040c4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000409c:	fe 79 00 00 	mov	r9,-65536
800040a0:	30 18       	mov	r8,1
800040a2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800040a4:	fe 7a 00 40 	mov	r10,-65472
800040a8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800040aa:	e0 6b 01 01 	mov	r11,257
800040ae:	fe 7a 34 00 	mov	r10,-52224
800040b2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800040b4:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800040b6:	d8 02       	popm	pc
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	3f 28       	mov	r8,-14
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	53 8c       	stdsp	sp[0xe0],r12
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	3f 9c       	mov	r12,-7
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	3f e0       	mov	r0,-2

800040c8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800040c8:	48 28       	lddpc	r8,800040d0 <xcmp_register_app_list+0x8>
800040ca:	91 0c       	st.w	r8[0x0],r12
}
800040cc:	5e fc       	retal	r12
800040ce:	00 00       	add	r0,r0
800040d0:	00 00       	add	r0,r0
800040d2:	51 04       	stdsp	sp[0x40],r4

800040d4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800040d4:	eb cd 40 80 	pushm	r7,lr
800040d8:	fa cd 01 00 	sub	sp,sp,256
800040dc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800040de:	16 98       	mov	r8,r11
800040e0:	2f 08       	sub	r8,-16
800040e2:	af a8       	sbr	r8,0xe
800040e4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800040e6:	3f f8       	mov	r8,-1
800040e8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800040ea:	30 b9       	mov	r9,11
800040ec:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800040ee:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800040f0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800040f2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040f4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800040f6:	f6 ca ff fe 	sub	r10,r11,-2
800040fa:	18 9b       	mov	r11,r12
800040fc:	fa cc ff f0 	sub	r12,sp,-16
80004100:	f0 1f 00 05 	mcall	80004114 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004104:	2f e7       	sub	r7,-2
80004106:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004108:	1a 9c       	mov	r12,sp
8000410a:	f0 1f 00 04 	mcall	80004118 <xcmp_tx+0x44>
}
8000410e:	2c 0d       	sub	sp,-256
80004110:	e3 cd 80 80 	ldm	sp++,r7,pc
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	74 58       	ld.w	r8,r10[0x14]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	46 54       	lddsp	r4,sp[0x194]

8000411c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000411c:	d4 01       	pushm	lr
8000411e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004122:	fe 78 b4 00 	mov	r8,-19456
80004126:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004128:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000412c:	30 89       	mov	r9,8
8000412e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004130:	30 19       	mov	r9,1
80004132:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004134:	30 09       	mov	r9,0
80004136:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004138:	30 5a       	mov	r10,5
8000413a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000413c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000413e:	30 7a       	mov	r10,7
80004140:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004142:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004144:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004146:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000414a:	30 9b       	mov	r11,9
8000414c:	fa cc ff fe 	sub	r12,sp,-2
80004150:	f0 1f 00 02 	mcall	80004158 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004154:	2c dd       	sub	sp,-204
80004156:	d8 02       	popm	pc
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	40 d4       	lddsp	r4,sp[0x34]

8000415c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000415c:	d4 01       	pushm	lr
8000415e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004162:	fe 78 80 00 	mov	r8,-32768
80004166:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004168:	30 38       	mov	r8,3
8000416a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000416c:	30 1b       	mov	r11,1
8000416e:	fa cc ff fe 	sub	r12,sp,-2
80004172:	f0 1f 00 03 	mcall	8000417c <xcmp_opcode_not_supported+0x20>
}
80004176:	2c dd       	sub	sp,-204
80004178:	d8 02       	popm	pc
8000417a:	00 00       	add	r0,r0
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	40 d4       	lddsp	r4,sp[0x34]

80004180 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004180:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004182:	96 88       	ld.uh	r8,r11[0x0]
80004184:	e2 18 f0 00 	andl	r8,0xf000,COH
80004188:	e0 48 80 00 	cp.w	r8,32768
8000418c:	c0 f0       	breq	800041aa <xcmp_exec_func+0x2a>
8000418e:	e0 48 b0 00 	cp.w	r8,45056
80004192:	c1 20       	breq	800041b6 <xcmp_exec_func+0x36>
80004194:	58 08       	cp.w	r8,0
80004196:	c1 51       	brne	800041c0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004198:	78 08       	ld.w	r8,r12[0x0]
8000419a:	58 08       	cp.w	r8,0
8000419c:	c0 40       	breq	800041a4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000419e:	16 9c       	mov	r12,r11
800041a0:	5d 18       	icall	r8
800041a2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800041a4:	f0 1f 00 08 	mcall	800041c4 <xcmp_exec_func+0x44>
800041a8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800041aa:	78 18       	ld.w	r8,r12[0x4]
800041ac:	58 08       	cp.w	r8,0
800041ae:	c0 90       	breq	800041c0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800041b0:	16 9c       	mov	r12,r11
800041b2:	5d 18       	icall	r8
800041b4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800041b6:	78 28       	ld.w	r8,r12[0x8]
800041b8:	58 08       	cp.w	r8,0
800041ba:	c0 30       	breq	800041c0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800041bc:	16 9c       	mov	r12,r11
800041be:	5d 18       	icall	r8
800041c0:	d8 02       	popm	pc
800041c2:	00 00       	add	r0,r0
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	41 5c       	lddsp	r12,sp[0x54]

800041c8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
800041c8:	d4 01       	pushm	lr
800041ca:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800041ce:	e0 68 04 09 	mov	r8,1033
800041d2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800041d4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800041d8:	30 19       	mov	r9,1
800041da:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
800041dc:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
800041e0:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
800041e2:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800041e4:	30 09       	mov	r9,0
800041e6:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800041e8:	fb 69 00 08 	st.b	sp[8],r9
800041ec:	fa c8 ff f7 	sub	r8,sp,-9
800041f0:	b0 89       	st.b	r8[0x0],r9
800041f2:	fa c8 ff f6 	sub	r8,sp,-10
800041f6:	b0 89       	st.b	r8[0x0],r9
800041f8:	fa c8 ff f5 	sub	r8,sp,-11
800041fc:	b0 89       	st.b	r8[0x0],r9
800041fe:	fa c8 ff f4 	sub	r8,sp,-12
80004202:	b0 89       	st.b	r8[0x0],r9
80004204:	fa c8 ff f3 	sub	r8,sp,-13
80004208:	b0 89       	st.b	r8[0x0],r9
8000420a:	fa c8 ff f2 	sub	r8,sp,-14
8000420e:	b0 89       	st.b	r8[0x0],r9
80004210:	fa c8 ff f1 	sub	r8,sp,-15
80004214:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004216:	30 cb       	mov	r11,12
80004218:	fa cc ff fe 	sub	r12,sp,-2
8000421c:	f0 1f 00 02 	mcall	80004224 <xcmp_IdleTestTone+0x5c>
}
80004220:	2c dd       	sub	sp,-204
80004222:	d8 02       	popm	pc
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	40 d4       	lddsp	r4,sp[0x34]

80004228 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004228:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000422a:	48 dc       	lddpc	r12,8000425c <xcmp_init+0x34>
8000422c:	f0 1f 00 0d 	mcall	80004260 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004230:	30 4b       	mov	r11,4
80004232:	31 4c       	mov	r12,20
80004234:	f0 1f 00 0c 	mcall	80004264 <xcmp_init+0x3c>
80004238:	48 c8       	lddpc	r8,80004268 <xcmp_init+0x40>
8000423a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000423c:	30 09       	mov	r9,0
8000423e:	1a d9       	st.w	--sp,r9
80004240:	1a d9       	st.w	--sp,r9
80004242:	1a d9       	st.w	--sp,r9
80004244:	30 38       	mov	r8,3
80004246:	e0 6a 01 80 	mov	r10,384
8000424a:	48 9b       	lddpc	r11,8000426c <xcmp_init+0x44>
8000424c:	48 9c       	lddpc	r12,80004270 <xcmp_init+0x48>
8000424e:	f0 1f 00 0a 	mcall	80004274 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004252:	f0 1f 00 0a 	mcall	80004278 <xcmp_init+0x50>
80004256:	2f dd       	sub	sp,-12
	
}
80004258:	d8 02       	popm	pc
8000425a:	00 00       	add	r0,r0
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	43 78       	lddsp	r8,sp[0xdc]
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	43 c4       	lddsp	r4,sp[0xf0]
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	61 2c       	ld.w	r12,r0[0x48]
80004268:	00 00       	add	r0,r0
8000426a:	0a f4       	st.b	--r5,r4
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	d3 70       	acall	0x37
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	42 7c       	lddsp	r12,sp[0x9c]
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	68 00       	ld.w	r0,r4[0x0]
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	43 fc       	lddsp	r12,sp[0xfc]

8000427c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000427c:	d4 31       	pushm	r0-r7,lr
8000427e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004280:	4b 16       	lddpc	r6,80004344 <xcmp_rx_process+0xc8>
80004282:	30 05       	mov	r5,0
80004284:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004286:	4b 13       	lddpc	r3,80004348 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004288:	4b 12       	lddpc	r2,8000434c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000428a:	4b 21       	lddpc	r1,80004350 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000428c:	4b 20       	lddpc	r0,80004354 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000428e:	6c 0c       	ld.w	r12,r6[0x0]
80004290:	0a 99       	mov	r9,r5
80004292:	08 9a       	mov	r10,r4
80004294:	1a 9b       	mov	r11,sp
80004296:	f0 1f 00 31 	mcall	80004358 <xcmp_rx_process+0xdc>
8000429a:	58 1c       	cp.w	r12,1
8000429c:	cf 91       	brne	8000428e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000429e:	40 0b       	lddsp	r11,sp[0x0]
800042a0:	58 0b       	cp.w	r11,0
800042a2:	cf 60       	breq	8000428e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800042a4:	96 0a       	ld.sh	r10,r11[0x0]
800042a6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800042aa:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800042ae:	59 c8       	cp.w	r8,28
800042b0:	c1 e0       	breq	800042ec <xcmp_rx_process+0x70>
800042b2:	e0 89 00 07 	brgt	800042c0 <xcmp_rx_process+0x44>
800042b6:	58 e8       	cp.w	r8,14
800042b8:	c0 e0       	breq	800042d4 <xcmp_rx_process+0x58>
800042ba:	58 f8       	cp.w	r8,15
800042bc:	c2 41       	brne	80004304 <xcmp_rx_process+0x88>
800042be:	c0 f8       	rjmp	800042dc <xcmp_rx_process+0x60>
800042c0:	e0 48 01 09 	cp.w	r8,265
800042c4:	c1 80       	breq	800042f4 <xcmp_rx_process+0x78>
800042c6:	e0 48 01 0a 	cp.w	r8,266
800042ca:	c1 90       	breq	800042fc <xcmp_rx_process+0x80>
800042cc:	e0 48 00 2c 	cp.w	r8,44
800042d0:	c1 a1       	brne	80004304 <xcmp_rx_process+0x88>
800042d2:	c0 98       	rjmp	800042e4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800042d4:	4a 2c       	lddpc	r12,8000435c <xcmp_rx_process+0xe0>
800042d6:	f0 1f 00 23 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042da:	c2 f8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800042dc:	4a 2c       	lddpc	r12,80004364 <xcmp_rx_process+0xe8>
800042de:	f0 1f 00 21 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042e2:	c2 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800042e4:	4a 1c       	lddpc	r12,80004368 <xcmp_rx_process+0xec>
800042e6:	f0 1f 00 1f 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042ea:	c2 78       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800042ec:	04 9c       	mov	r12,r2
800042ee:	f0 1f 00 1d 	mcall	80004360 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800042f2:	c2 38       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800042f4:	02 9c       	mov	r12,r1
800042f6:	f0 1f 00 1b 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
800042fa:	c1 f8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800042fc:	00 9c       	mov	r12,r0
800042fe:	f0 1f 00 19 	mcall	80004360 <xcmp_rx_process+0xe4>
					break;
80004302:	c1 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004304:	12 98       	mov	r8,r9
80004306:	e2 18 04 00 	andl	r8,0x400,COH
8000430a:	c0 70       	breq	80004318 <xcmp_rx_process+0x9c>
8000430c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004310:	e0 48 00 68 	cp.w	r8,104
80004314:	e0 8a 00 08 	brle	80004324 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004318:	e2 19 f0 00 	andl	r9,0xf000,COH
8000431c:	c0 e1       	brne	80004338 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000431e:	f0 1f 00 14 	mcall	8000436c <xcmp_rx_process+0xf0>
80004322:	c0 b8       	rjmp	80004338 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004324:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004328:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000432c:	49 19       	lddpc	r9,80004370 <xcmp_rx_process+0xf4>
8000432e:	72 08       	ld.w	r8,r9[0x0]
80004330:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004334:	f0 1f 00 0b 	mcall	80004360 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004338:	66 0c       	ld.w	r12,r3[0x0]
8000433a:	40 0b       	lddsp	r11,sp[0x0]
8000433c:	f0 1f 00 0e 	mcall	80004374 <xcmp_rx_process+0xf8>
80004340:	ca 7b       	rjmp	8000428e <xcmp_rx_process+0x12>
80004342:	00 00       	add	r0,r0
80004344:	00 00       	add	r0,r0
80004346:	0a f4       	st.b	--r5,r4
80004348:	00 00       	add	r0,r0
8000434a:	0a 8c       	andn	r12,r5
8000434c:	00 00       	add	r0,r0
8000434e:	0b 04       	ld.w	r4,r5++
80004350:	00 00       	add	r0,r0
80004352:	0a f8       	st.b	--r5,r8
80004354:	00 00       	add	r0,r0
80004356:	0a e8       	st.h	--r5,r8
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	5e 20       	reths	r0
8000435c:	00 00       	add	r0,r0
8000435e:	0b 1c       	ld.sh	r12,r5++
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	41 80       	lddsp	r0,sp[0x60]
80004364:	00 00       	add	r0,r0
80004366:	0a dc       	st.w	--r5,r12
80004368:	00 00       	add	r0,r0
8000436a:	0b 10       	ld.sh	r0,r5++
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	41 5c       	lddsp	r12,sp[0x54]
80004370:	00 00       	add	r0,r0
80004372:	51 04       	stdsp	sp[0x40],r4
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	29 e8       	sub	r8,-98

80004378 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004378:	eb cd 40 90 	pushm	r4,r7,lr
8000437c:	20 1d       	sub	sp,4
8000437e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004382:	48 c8       	lddpc	r8,800043b0 <xcmp_rx+0x38>
80004384:	70 0c       	ld.w	r12,r8[0x0]
80004386:	f0 1f 00 0c 	mcall	800043b4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000438a:	c1 00       	breq	800043aa <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000438c:	fa c7 ff fc 	sub	r7,sp,-4
80004390:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004392:	e0 6a 00 ca 	mov	r10,202
80004396:	08 9b       	mov	r11,r4
80004398:	f0 1f 00 08 	mcall	800043b8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000439c:	48 88       	lddpc	r8,800043bc <xcmp_rx+0x44>
8000439e:	70 0c       	ld.w	r12,r8[0x0]
800043a0:	30 09       	mov	r9,0
800043a2:	12 9a       	mov	r10,r9
800043a4:	1a 9b       	mov	r11,sp
800043a6:	f0 1f 00 07 	mcall	800043c0 <xcmp_rx+0x48>
	}	
}
800043aa:	2f fd       	sub	sp,-4
800043ac:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800043b0:	00 00       	add	r0,r0
800043b2:	0a 8c       	andn	r12,r5
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	2f 54       	sub	r4,-11
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	74 58       	ld.w	r8,r10[0x14]
800043bc:	00 00       	add	r0,r0
800043be:	0a f4       	st.b	--r5,r4
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	60 2c       	ld.w	r12,r0[0x8]

800043c4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800043c4:	48 28       	lddpc	r8,800043cc <xnl_register_xcmp_func+0x8>
800043c6:	91 0c       	st.w	r8[0x0],r12
}
800043c8:	5e fc       	retal	r12
800043ca:	00 00       	add	r0,r0
800043cc:	00 00       	add	r0,r0
800043ce:	0b 4c       	ld.w	r12,--r5

800043d0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800043d0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800043d2:	48 88       	lddpc	r8,800043f0 <xnl_get_msg_ack_func+0x20>
800043d4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800043d6:	98 49       	ld.sh	r9,r12[0x8]
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 81       	brne	800043ec <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800043de:	48 68       	lddpc	r8,800043f4 <xnl_get_msg_ack_func+0x24>
800043e0:	70 0c       	ld.w	r12,r8[0x0]
800043e2:	30 09       	mov	r9,0
800043e4:	12 9a       	mov	r10,r9
800043e6:	12 9b       	mov	r11,r9
800043e8:	f0 1f 00 04 	mcall	800043f8 <xnl_get_msg_ack_func+0x28>
800043ec:	d8 02       	popm	pc
800043ee:	00 00       	add	r0,r0
800043f0:	00 00       	add	r0,r0
800043f2:	0b 2c       	ld.uh	r12,r5++
800043f4:	00 00       	add	r0,r0
800043f6:	0b 28       	ld.uh	r8,r5++
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	60 2c       	ld.w	r12,r0[0x8]

800043fc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800043fc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004400:	30 09       	mov	r9,0
80004402:	4b 78       	lddpc	r8,800044dc <xnl_init+0xe0>
80004404:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004406:	30 0b       	mov	r11,0
80004408:	30 1c       	mov	r12,1
8000440a:	f0 1f 00 36 	mcall	800044e0 <xnl_init+0xe4>
8000440e:	4b 68       	lddpc	r8,800044e4 <xnl_init+0xe8>
80004410:	91 0c       	st.w	r8[0x0],r12
80004412:	70 08       	ld.w	r8,r8[0x0]
80004414:	58 08       	cp.w	r8,0
80004416:	c0 80       	breq	80004426 <xnl_init+0x2a>
80004418:	4b 38       	lddpc	r8,800044e4 <xnl_init+0xe8>
8000441a:	70 0c       	ld.w	r12,r8[0x0]
8000441c:	30 09       	mov	r9,0
8000441e:	12 9a       	mov	r10,r9
80004420:	12 9b       	mov	r11,r9
80004422:	f0 1f 00 32 	mcall	800044e8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004426:	30 4b       	mov	r11,4
80004428:	31 4c       	mov	r12,20
8000442a:	f0 1f 00 2e 	mcall	800044e0 <xnl_init+0xe4>
8000442e:	4b 08       	lddpc	r8,800044ec <xnl_init+0xf0>
80004430:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004432:	30 4b       	mov	r11,4
80004434:	31 ec       	mov	r12,30
80004436:	f0 1f 00 2b 	mcall	800044e0 <xnl_init+0xe4>
8000443a:	4a e8       	lddpc	r8,800044f0 <xnl_init+0xf4>
8000443c:	91 0c       	st.w	r8[0x0],r12
8000443e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004440:	10 96       	mov	r6,r8
80004442:	4a d5       	lddpc	r5,800044f4 <xnl_init+0xf8>
80004444:	6c 0c       	ld.w	r12,r6[0x0]
80004446:	ea 07 00 0b 	add	r11,r5,r7
8000444a:	f0 1f 00 2c 	mcall	800044f8 <xnl_init+0xfc>
8000444e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004452:	e0 47 1e 00 	cp.w	r7,7680
80004456:	cf 71       	brne	80004444 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004458:	30 4b       	mov	r11,4
8000445a:	31 4c       	mov	r12,20
8000445c:	f0 1f 00 21 	mcall	800044e0 <xnl_init+0xe4>
80004460:	4a 78       	lddpc	r8,800044fc <xnl_init+0x100>
80004462:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004464:	30 4b       	mov	r11,4
80004466:	30 ac       	mov	r12,10
80004468:	f0 1f 00 1e 	mcall	800044e0 <xnl_init+0xe4>
8000446c:	4a 58       	lddpc	r8,80004500 <xnl_init+0x104>
8000446e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004470:	30 4b       	mov	r11,4
80004472:	30 ac       	mov	r12,10
80004474:	f0 1f 00 1b 	mcall	800044e0 <xnl_init+0xe4>
80004478:	4a 38       	lddpc	r8,80004504 <xnl_init+0x108>
8000447a:	91 0c       	st.w	r8[0x0],r12
8000447c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000447e:	10 96       	mov	r6,r8
80004480:	4a 25       	lddpc	r5,80004508 <xnl_init+0x10c>
80004482:	6c 0c       	ld.w	r12,r6[0x0]
80004484:	ea 07 00 0b 	add	r11,r5,r7
80004488:	f0 1f 00 1c 	mcall	800044f8 <xnl_init+0xfc>
8000448c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004490:	e0 47 14 00 	cp.w	r7,5120
80004494:	cf 71       	brne	80004482 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004496:	30 4b       	mov	r11,4
80004498:	30 5c       	mov	r12,5
8000449a:	f0 1f 00 12 	mcall	800044e0 <xnl_init+0xe4>
8000449e:	49 c8       	lddpc	r8,8000450c <xnl_init+0x110>
800044a0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800044a2:	30 07       	mov	r7,0
800044a4:	1a d7       	st.w	--sp,r7
800044a6:	1a d7       	st.w	--sp,r7
800044a8:	1a d7       	st.w	--sp,r7
800044aa:	30 38       	mov	r8,3
800044ac:	0e 99       	mov	r9,r7
800044ae:	e0 6a 02 00 	mov	r10,512
800044b2:	49 8b       	lddpc	r11,80004510 <xnl_init+0x114>
800044b4:	49 8c       	lddpc	r12,80004514 <xnl_init+0x118>
800044b6:	f0 1f 00 19 	mcall	80004518 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044ba:	1a d7       	st.w	--sp,r7
800044bc:	1a d7       	st.w	--sp,r7
800044be:	1a d7       	st.w	--sp,r7
800044c0:	30 38       	mov	r8,3
800044c2:	0e 99       	mov	r9,r7
800044c4:	e0 6a 03 20 	mov	r10,800
800044c8:	49 5b       	lddpc	r11,8000451c <xnl_init+0x120>
800044ca:	49 6c       	lddpc	r12,80004520 <xnl_init+0x124>
800044cc:	f0 1f 00 13 	mcall	80004518 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800044d0:	f0 1f 00 15 	mcall	80004524 <xnl_init+0x128>
800044d4:	2f ad       	sub	sp,-24
}
800044d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800044da:	00 00       	add	r0,r0
800044dc:	00 00       	add	r0,r0
800044de:	0b 2c       	ld.uh	r12,r5++
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	61 2c       	ld.w	r12,r0[0x48]
800044e4:	00 00       	add	r0,r0
800044e6:	0b 28       	ld.uh	r8,r5++
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	60 2c       	ld.w	r12,r0[0x8]
800044ec:	00 00       	add	r0,r0
800044ee:	0b 38       	ld.ub	r8,r5++
800044f0:	00 00       	add	r0,r0
800044f2:	0a 8c       	andn	r12,r5
800044f4:	00 00       	add	r0,r0
800044f6:	32 b6       	mov	r6,43
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	29 e8       	sub	r8,-98
800044fc:	00 00       	add	r0,r0
800044fe:	0a bc       	st.h	r5++,r12
80004500:	00 00       	add	r0,r0
80004502:	0a a8       	st.w	r5++,r8
80004504:	00 00       	add	r0,r0
80004506:	0a 94       	mov	r4,r5
80004508:	00 00       	add	r0,r0
8000450a:	1e b6       	st.h	pc++,r6
8000450c:	00 00       	add	r0,r0
8000450e:	0a 64       	and	r4,r5
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	d3 78       	*unknown*
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	45 28       	lddsp	r8,sp[0x148]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	68 00       	ld.w	r0,r4[0x0]
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	cc 00       	breq	8000449e <xnl_init+0xa2>
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	45 88       	lddsp	r8,sp[0x160]
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	2f 7c       	sub	r12,-9

80004528 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004528:	eb cd 40 fe 	pushm	r1-r7,lr
8000452c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000452e:	49 26       	lddpc	r6,80004574 <xnl_rx_process+0x4c>
80004530:	30 05       	mov	r5,0
80004532:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004534:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004536:	49 11       	lddpc	r1,80004578 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004538:	49 12       	lddpc	r2,8000457c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000453a:	6c 0c       	ld.w	r12,r6[0x0]
8000453c:	0a 99       	mov	r9,r5
8000453e:	08 9a       	mov	r10,r4
80004540:	1a 9b       	mov	r11,sp
80004542:	f0 1f 00 10 	mcall	80004580 <xnl_rx_process+0x58>
80004546:	58 1c       	cp.w	r12,1
80004548:	cf 91       	brne	8000453a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000454a:	40 0c       	lddsp	r12,sp[0x0]
8000454c:	58 0c       	cp.w	r12,0
8000454e:	cf 60       	breq	8000453a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004550:	98 28       	ld.sh	r8,r12[0x4]
80004552:	e6 08 19 00 	cp.h	r8,r3
80004556:	e0 8b 00 0a 	brhi	8000456a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000455a:	5c 78       	castu.h	r8
8000455c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004560:	58 09       	cp.w	r9,0
80004562:	c0 40       	breq	8000456a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004564:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004568:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000456a:	62 0c       	ld.w	r12,r1[0x0]
8000456c:	40 0b       	lddsp	r11,sp[0x0]
8000456e:	f0 1f 00 06 	mcall	80004584 <xnl_rx_process+0x5c>
80004572:	ce 4b       	rjmp	8000453a <xnl_rx_process+0x12>
80004574:	00 00       	add	r0,r0
80004576:	0a a8       	st.w	r5++,r8
80004578:	00 00       	add	r0,r0
8000457a:	0a 8c       	andn	r12,r5
8000457c:	00 00       	add	r0,r0
8000457e:	04 f0       	st.b	--r2,r0
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	5e 20       	reths	r0
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	29 e8       	sub	r8,-98

80004588 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004588:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000458a:	4a a6       	lddpc	r6,80004630 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000458c:	4a a2       	lddpc	r2,80004634 <xnl_tx_process+0xac>
8000458e:	4a b4       	lddpc	r4,80004638 <xnl_tx_process+0xb0>
80004590:	30 07       	mov	r7,0
80004592:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004594:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004596:	4a a5       	lddpc	r5,8000463c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004598:	4a a3       	lddpc	r3,80004640 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000459a:	6c 08       	ld.w	r8,r6[0x0]
8000459c:	58 08       	cp.w	r8,0
8000459e:	c0 40       	breq	800045a6 <xnl_tx_process+0x1e>
800045a0:	58 18       	cp.w	r8,1
800045a2:	cf d1       	brne	8000459c <xnl_tx_process+0x14>
800045a4:	c2 48       	rjmp	800045ec <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800045a6:	64 0c       	ld.w	r12,r2[0x0]
800045a8:	0e 99       	mov	r9,r7
800045aa:	02 9a       	mov	r10,r1
800045ac:	08 9b       	mov	r11,r4
800045ae:	f0 1f 00 26 	mcall	80004644 <xnl_tx_process+0xbc>
800045b2:	58 1c       	cp.w	r12,1
800045b4:	cf 31       	brne	8000459a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800045b6:	68 0b       	ld.w	r11,r4[0x0]
800045b8:	58 0b       	cp.w	r11,0
800045ba:	cf 00       	breq	8000459a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800045bc:	96 28       	ld.sh	r8,r11[0x4]
800045be:	e0 08 19 00 	cp.h	r8,r0
800045c2:	c0 71       	brne	800045d0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800045c4:	4a 18       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
800045c6:	70 08       	ld.w	r8,r8[0x0]
800045c8:	10 9c       	mov	r12,r8
800045ca:	f0 1f 00 21 	mcall	8000464c <xnl_tx_process+0xc4>
						break;
800045ce:	ce 6b       	rjmp	8000459a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800045d0:	16 9c       	mov	r12,r11
800045d2:	f0 1f 00 20 	mcall	80004650 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800045d6:	30 18       	mov	r8,1
800045d8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800045da:	66 0c       	ld.w	r12,r3[0x0]
800045dc:	0e 99       	mov	r9,r7
800045de:	0e 9a       	mov	r10,r7
800045e0:	0e 9b       	mov	r11,r7
800045e2:	f0 1f 00 19 	mcall	80004644 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800045e6:	30 18       	mov	r8,1
800045e8:	8d 08       	st.w	r6[0x0],r8
800045ea:	cd 8b       	rjmp	8000459a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800045ec:	66 0c       	ld.w	r12,r3[0x0]
800045ee:	0e 99       	mov	r9,r7
800045f0:	36 4a       	mov	r10,100
800045f2:	0e 9b       	mov	r11,r7
800045f4:	f0 1f 00 14 	mcall	80004644 <xnl_tx_process+0xbc>
800045f8:	58 1c       	cp.w	r12,1
800045fa:	c0 81       	brne	8000460a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800045fc:	49 38       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
800045fe:	70 0c       	ld.w	r12,r8[0x0]
80004600:	68 0b       	ld.w	r11,r4[0x0]
80004602:	f0 1f 00 13 	mcall	8000464c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004606:	8d 07       	st.w	r6[0x0],r7
80004608:	cc 9b       	rjmp	8000459a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000460a:	6a 08       	ld.w	r8,r5[0x0]
8000460c:	58 38       	cp.w	r8,3
8000460e:	e0 89 00 09 	brgt	80004620 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004612:	68 0c       	ld.w	r12,r4[0x0]
80004614:	f0 1f 00 0f 	mcall	80004650 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004618:	6a 08       	ld.w	r8,r5[0x0]
8000461a:	2f f8       	sub	r8,-1
8000461c:	8b 08       	st.w	r5[0x0],r8
8000461e:	cb eb       	rjmp	8000459a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004620:	48 a8       	lddpc	r8,80004648 <xnl_tx_process+0xc0>
80004622:	70 0c       	ld.w	r12,r8[0x0]
80004624:	68 0b       	ld.w	r11,r4[0x0]
80004626:	f0 1f 00 0a 	mcall	8000464c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000462a:	8d 07       	st.w	r6[0x0],r7
8000462c:	cb 7b       	rjmp	8000459a <xnl_tx_process+0x12>
8000462e:	00 00       	add	r0,r0
80004630:	00 00       	add	r0,r0
80004632:	0b 48       	ld.w	r8,--r5
80004634:	00 00       	add	r0,r0
80004636:	0b 38       	ld.ub	r8,r5++
80004638:	00 00       	add	r0,r0
8000463a:	0b 40       	ld.w	r0,--r5
8000463c:	00 00       	add	r0,r0
8000463e:	0b 3c       	ld.ub	r12,r5++
80004640:	00 00       	add	r0,r0
80004642:	0b 28       	ld.uh	r8,r5++
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	5e 20       	reths	r0
80004648:	00 00       	add	r0,r0
8000464a:	0a 8c       	andn	r12,r5
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	29 e8       	sub	r8,-98
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	2a 08       	sub	r8,-96

80004654 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004654:	eb cd 40 c0 	pushm	r6-r7,lr
80004658:	20 1d       	sub	sp,4
8000465a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000465c:	98 39       	ld.sh	r9,r12[0x6]
8000465e:	3f f8       	mov	r8,-1
80004660:	f0 09 19 00 	cp.h	r9,r8
80004664:	c0 a1       	brne	80004678 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004666:	4a e9       	lddpc	r9,8000471c <xnl_tx+0xc8>
80004668:	13 88       	ld.ub	r8,r9[0x0]
8000466a:	2f f8       	sub	r8,-1
8000466c:	5c 58       	castu.b	r8
8000466e:	b2 88       	st.b	r9[0x0],r8
80004670:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004674:	a9 a8       	sbr	r8,0x8
80004676:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004678:	8c 49       	ld.sh	r9,r6[0x8]
8000467a:	3f f8       	mov	r8,-1
8000467c:	f0 09 19 00 	cp.h	r9,r8
80004680:	c0 41       	brne	80004688 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004682:	4a 88       	lddpc	r8,80004720 <xnl_tx+0xcc>
80004684:	90 18       	ld.sh	r8,r8[0x2]
80004686:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004688:	8c 59       	ld.sh	r9,r6[0xa]
8000468a:	3f f8       	mov	r8,-1
8000468c:	f0 09 19 00 	cp.h	r9,r8
80004690:	c0 41       	brne	80004698 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004692:	4a 48       	lddpc	r8,80004720 <xnl_tx+0xcc>
80004694:	90 28       	ld.sh	r8,r8[0x4]
80004696:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004698:	8c 69       	ld.sh	r9,r6[0xc]
8000469a:	3f f8       	mov	r8,-1
8000469c:	f0 09 19 00 	cp.h	r9,r8
800046a0:	c0 e1       	brne	800046bc <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800046a2:	4a 08       	lddpc	r8,80004720 <xnl_tx+0xcc>
800046a4:	90 49       	ld.sh	r9,r8[0x8]
800046a6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800046a8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800046aa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800046ac:	90 49       	ld.sh	r9,r8[0x8]
800046ae:	e0 19 ff 00 	andl	r9,0xff00
800046b2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800046b6:	f3 e8 10 08 	or	r8,r9,r8
800046ba:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800046bc:	0d 98       	ld.ub	r8,r6[0x1]
800046be:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800046c0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800046c4:	10 0c       	add	r12,r8
800046c6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046c8:	58 0c       	cp.w	r12,0
800046ca:	e0 89 00 04 	brgt	800046d2 <xnl_tx+0x7e>
800046ce:	30 09       	mov	r9,0
800046d0:	c0 d8       	rjmp	800046ea <xnl_tx+0x96>
800046d2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800046d6:	2f ec       	sub	r12,-2
800046d8:	30 09       	mov	r9,0
800046da:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800046dc:	15 1b       	ld.sh	r11,r10++
800046de:	f6 09 00 09 	add	r9,r11,r9
800046e2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800046e4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046e6:	18 38       	cp.w	r8,r12
800046e8:	cf a1       	brne	800046dc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800046ea:	5c 39       	neg	r9
800046ec:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046ee:	48 e8       	lddpc	r8,80004724 <xnl_tx+0xd0>
800046f0:	70 0c       	ld.w	r12,r8[0x0]
800046f2:	f0 1f 00 0e 	mcall	80004728 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800046f6:	c1 00       	breq	80004716 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046f8:	fa c7 ff fc 	sub	r7,sp,-4
800046fc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800046fe:	e0 6a 01 00 	mov	r10,256
80004702:	0c 9b       	mov	r11,r6
80004704:	f0 1f 00 0a 	mcall	8000472c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004708:	48 a8       	lddpc	r8,80004730 <xnl_tx+0xdc>
8000470a:	70 0c       	ld.w	r12,r8[0x0]
8000470c:	30 09       	mov	r9,0
8000470e:	12 9a       	mov	r10,r9
80004710:	1a 9b       	mov	r11,sp
80004712:	f0 1f 00 09 	mcall	80004734 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004716:	2f fd       	sub	sp,-4
80004718:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000471c:	00 00       	add	r0,r0
8000471e:	0b 44       	ld.w	r4,--r5
80004720:	00 00       	add	r0,r0
80004722:	0b 2c       	ld.uh	r12,r5++
80004724:	00 00       	add	r0,r0
80004726:	0a 8c       	andn	r12,r5
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	2f 54       	sub	r4,-11
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	74 58       	ld.w	r8,r10[0x14]
80004730:	00 00       	add	r0,r0
80004732:	0b 38       	ld.ub	r8,r5++
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	60 2c       	ld.w	r12,r0[0x8]

80004738 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004738:	eb cd 40 80 	pushm	r7,lr
8000473c:	fa cd 01 00 	sub	sp,sp,256
80004740:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004742:	e0 68 40 0e 	mov	r8,16398
80004746:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004748:	3f f8       	mov	r8,-1
8000474a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000474c:	30 c8       	mov	r8,12
8000474e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004750:	98 38       	ld.sh	r8,r12[0x6]
80004752:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004754:	98 58       	ld.sh	r8,r12[0xa]
80004756:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004758:	98 48       	ld.sh	r8,r12[0x8]
8000475a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000475c:	98 68       	ld.sh	r8,r12[0xc]
8000475e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004760:	30 08       	mov	r8,0
80004762:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004764:	1a 9c       	mov	r12,sp
80004766:	f0 1f 00 0a 	mcall	8000478c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000476a:	fa cd 00 cc 	sub	sp,sp,204
8000476e:	e0 6a 00 ca 	mov	r10,202
80004772:	ee cb ff f0 	sub	r11,r7,-16
80004776:	1a 9c       	mov	r12,sp
80004778:	f0 1f 00 06 	mcall	80004790 <xnl_data_msg_func+0x58>
8000477c:	48 68       	lddpc	r8,80004794 <xnl_data_msg_func+0x5c>
8000477e:	70 08       	ld.w	r8,r8[0x0]
80004780:	5d 18       	icall	r8
80004782:	fa cd ff 34 	sub	sp,sp,-204
}
80004786:	2c 0d       	sub	sp,-256
80004788:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	46 54       	lddsp	r4,sp[0x194]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	74 58       	ld.w	r8,r10[0x14]
80004794:	00 00       	add	r0,r0
80004796:	0b 4c       	ld.w	r12,--r5

80004798 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004798:	d4 21       	pushm	r4-r7,lr
8000479a:	fa cd 01 00 	sub	sp,sp,256
8000479e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800047a0:	4c 28       	lddpc	r8,800048a8 <xnl_device_auth_reply_func+0x110>
800047a2:	11 88       	ld.ub	r8,r8[0x0]
800047a4:	58 08       	cp.w	r8,0
800047a6:	c7 e1       	brne	800048a2 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800047a8:	4c 18       	lddpc	r8,800048ac <xnl_device_auth_reply_func+0x114>
800047aa:	70 0c       	ld.w	r12,r8[0x0]
800047ac:	30 09       	mov	r9,0
800047ae:	12 9a       	mov	r10,r9
800047b0:	12 9b       	mov	r11,r9
800047b2:	f0 1f 00 40 	mcall	800048b0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800047b6:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800047ba:	4b c8       	lddpc	r8,800048a8 <xnl_device_auth_reply_func+0x110>
800047bc:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800047be:	ef 39 00 12 	ld.ub	r9,r7[18]
800047c2:	ef 38 00 13 	ld.ub	r8,r7[19]
800047c6:	b1 68       	lsl	r8,0x10
800047c8:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800047cc:	ef 38 00 15 	ld.ub	r8,r7[21]
800047d0:	f3 e8 10 08 	or	r8,r9,r8
800047d4:	ef 39 00 14 	ld.ub	r9,r7[20]
800047d8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800047dc:	ef 3a 00 16 	ld.ub	r10,r7[22]
800047e0:	ef 38 00 17 	ld.ub	r8,r7[23]
800047e4:	b1 68       	lsl	r8,0x10
800047e6:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800047ea:	ef 38 00 19 	ld.ub	r8,r7[25]
800047ee:	f5 e8 10 08 	or	r8,r10,r8
800047f2:	ef 3a 00 18 	ld.ub	r10,r7[24]
800047f6:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800047fa:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047fc:	e0 64 79 b9 	mov	r4,31161
80004800:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004804:	e0 65 45 07 	mov	r5,17671
80004808:	ea 15 8a bd 	orh	r5,0x8abd
8000480c:	e0 66 f9 3d 	mov	r6,63805
80004810:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004814:	e0 6e b8 cf 	mov	lr,47311
80004818:	ea 1e 36 83 	orh	lr,0x3683
8000481c:	e0 67 aa 1c 	mov	r7,43548
80004820:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004824:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004826:	f4 08 00 0c 	add	r12,r10,r8
8000482a:	f0 0b 15 04 	lsl	r11,r8,0x4
8000482e:	0a 0b       	add	r11,r5
80004830:	f9 eb 20 0b 	eor	r11,r12,r11
80004834:	f0 0c 16 05 	lsr	r12,r8,0x5
80004838:	0c 0c       	add	r12,r6
8000483a:	18 5b       	eor	r11,r12
8000483c:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000483e:	f2 0c 15 04 	lsl	r12,r9,0x4
80004842:	1c 0c       	add	r12,lr
80004844:	f2 0b 16 05 	lsr	r11,r9,0x5
80004848:	0e 0b       	add	r11,r7
8000484a:	f9 eb 20 0b 	eor	r11,r12,r11
8000484e:	f2 0a 00 0c 	add	r12,r9,r10
80004852:	18 5b       	eor	r11,r12
80004854:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004856:	e0 6b 37 20 	mov	r11,14112
8000485a:	ea 1b c6 ef 	orh	r11,0xc6ef
8000485e:	16 3a       	cp.w	r10,r11
80004860:	ce 21       	brne	80004824 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004862:	e0 6a 40 1a 	mov	r10,16410
80004866:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004868:	3f fa       	mov	r10,-1
8000486a:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000486c:	30 6b       	mov	r11,6
8000486e:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004870:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004872:	48 eb       	lddpc	r11,800048a8 <xnl_device_auth_reply_func+0x110>
80004874:	96 1c       	ld.sh	r12,r11[0x2]
80004876:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004878:	96 2b       	ld.sh	r11,r11[0x4]
8000487a:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000487c:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000487e:	30 ca       	mov	r10,12
80004880:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004882:	30 0a       	mov	r10,0
80004884:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004888:	30 7a       	mov	r10,7
8000488a:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000488e:	30 2a       	mov	r10,2
80004890:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004894:	fa ca ff ec 	sub	r10,sp,-20
80004898:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000489a:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000489c:	1a 9c       	mov	r12,sp
8000489e:	f0 1f 00 06 	mcall	800048b4 <xnl_device_auth_reply_func+0x11c>
}
800048a2:	2c 0d       	sub	sp,-256
800048a4:	d8 22       	popm	r4-r7,pc
800048a6:	00 00       	add	r0,r0
800048a8:	00 00       	add	r0,r0
800048aa:	0b 2c       	ld.uh	r12,r5++
800048ac:	00 00       	add	r0,r0
800048ae:	0b 28       	ld.uh	r8,r5++
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	60 2c       	ld.w	r12,r0[0x8]
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	46 54       	lddsp	r4,sp[0x194]

800048b8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800048b8:	eb cd 40 80 	pushm	r7,lr
800048bc:	fa cd 01 00 	sub	sp,sp,256
800048c0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800048c2:	49 28       	lddpc	r8,80004908 <xnl_master_status_brdcst_func+0x50>
800048c4:	11 88       	ld.ub	r8,r8[0x0]
800048c6:	58 08       	cp.w	r8,0
800048c8:	c1 c1       	brne	80004900 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800048ca:	49 18       	lddpc	r8,8000490c <xnl_master_status_brdcst_func+0x54>
800048cc:	70 0c       	ld.w	r12,r8[0x0]
800048ce:	30 09       	mov	r9,0
800048d0:	12 9a       	mov	r10,r9
800048d2:	12 9b       	mov	r11,r9
800048d4:	f0 1f 00 0f 	mcall	80004910 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800048d8:	8e 58       	ld.sh	r8,r7[0xa]
800048da:	48 c9       	lddpc	r9,80004908 <xnl_master_status_brdcst_func+0x50>
800048dc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800048de:	e0 68 40 0e 	mov	r8,16398
800048e2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048e4:	3f f8       	mov	r8,-1
800048e6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800048e8:	30 4a       	mov	r10,4
800048ea:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048ec:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048ee:	92 19       	ld.sh	r9,r9[0x2]
800048f0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800048f2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048f4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800048f6:	30 08       	mov	r8,0
800048f8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800048fa:	1a 9c       	mov	r12,sp
800048fc:	f0 1f 00 06 	mcall	80004914 <xnl_master_status_brdcst_func+0x5c>
}
80004900:	2c 0d       	sub	sp,-256
80004902:	e3 cd 80 80 	ldm	sp++,r7,pc
80004906:	00 00       	add	r0,r0
80004908:	00 00       	add	r0,r0
8000490a:	0b 2c       	ld.uh	r12,r5++
8000490c:	00 00       	add	r0,r0
8000490e:	0b 28       	ld.uh	r8,r5++
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	60 2c       	ld.w	r12,r0[0x8]
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	46 54       	lddsp	r4,sp[0x194]

80004918 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004918:	eb cd 40 80 	pushm	r7,lr
8000491c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000491e:	49 28       	lddpc	r8,80004964 <xnl_device_conn_reply_func+0x4c>
80004920:	70 0c       	ld.w	r12,r8[0x0]
80004922:	30 09       	mov	r9,0
80004924:	12 9a       	mov	r10,r9
80004926:	12 9b       	mov	r11,r9
80004928:	f0 1f 00 10 	mcall	80004968 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000492c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004930:	10 99       	mov	r9,r8
80004932:	e2 19 ff 00 	andl	r9,0xff00,COH
80004936:	e0 49 01 00 	cp.w	r9,256
8000493a:	c0 60       	breq	80004946 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000493c:	0e 9c       	mov	r12,r7
8000493e:	f0 1f 00 0c 	mcall	8000496c <xnl_device_conn_reply_func+0x54>
80004942:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004946:	a9 68       	lsl	r8,0x8
80004948:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000494c:	48 98       	lddpc	r8,80004970 <xnl_device_conn_reply_func+0x58>
8000494e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004950:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004954:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004956:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000495a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000495c:	30 19       	mov	r9,1
8000495e:	b0 89       	st.b	r8[0x0],r9
80004960:	e3 cd 80 80 	ldm	sp++,r7,pc
80004964:	00 00       	add	r0,r0
80004966:	0b 28       	ld.uh	r8,r5++
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	60 2c       	ld.w	r12,r0[0x8]
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	48 b8       	lddpc	r8,80004998 <xnl_send_device_master_query+0x24>
80004970:	00 00       	add	r0,r0
80004972:	0b 2c       	ld.uh	r12,r5++

80004974 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004974:	d4 01       	pushm	lr
80004976:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000497a:	e0 68 40 0e 	mov	r8,16398
8000497e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004980:	3f f8       	mov	r8,-1
80004982:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004984:	30 38       	mov	r8,3
80004986:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004988:	30 08       	mov	r8,0
8000498a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000498c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000498e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004990:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004992:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004994:	1a 9c       	mov	r12,sp
80004996:	f0 1f 00 03 	mcall	800049a0 <xnl_send_device_master_query+0x2c>
}
8000499a:	2c 0d       	sub	sp,-256
8000499c:	d8 02       	popm	pc
8000499e:	00 00       	add	r0,r0
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	46 54       	lddsp	r4,sp[0x194]

800049a4 <delay_ns>:
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800049a4:	58 0c       	cp.w	r12,0
800049a6:	5e 0c       	reteq	r12
800049a8:	30 08       	mov	r8,0
	{
		nop();
800049aa:	d7 03       	nop
		nop();
800049ac:	d7 03       	nop
		nop();
800049ae:	d7 03       	nop
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800049b0:	2f f8       	sub	r8,-1
800049b2:	10 3c       	cp.w	r12,r8
800049b4:	fe 9b ff fb 	brhi	800049aa <delay_ns+0x6>
800049b8:	5e fc       	retal	r12
800049ba:	d7 03       	nop

800049bc <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800049bc:	eb cd 40 e0 	pushm	r5-r7,lr
800049c0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800049c2:	58 0c       	cp.w	r12,0
800049c4:	c0 b0       	breq	800049da <delay_us+0x1e>
800049c6:	30 07       	mov	r7,0
		delay_ns(1000);
800049c8:	e0 65 03 e8 	mov	r5,1000
800049cc:	0a 9c       	mov	r12,r5
800049ce:	f0 1f 00 05 	mcall	800049e0 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800049d2:	2f f7       	sub	r7,-1
800049d4:	0e 36       	cp.w	r6,r7
800049d6:	fe 9b ff fb 	brhi	800049cc <delay_us+0x10>
800049da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800049de:	00 00       	add	r0,r0
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	49 a4       	lddpc	r4,80004a48 <RC522_ReadByte+0x8>

800049e4 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800049e4:	eb cd 40 e0 	pushm	r5-r7,lr
800049e8:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800049ea:	58 0c       	cp.w	r12,0
800049ec:	c0 b0       	breq	80004a02 <delay_ms+0x1e>
800049ee:	30 07       	mov	r7,0
		delay_us(1000);
800049f0:	e0 65 03 e8 	mov	r5,1000
800049f4:	0a 9c       	mov	r12,r5
800049f6:	f0 1f 00 05 	mcall	80004a08 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800049fa:	2f f7       	sub	r7,-1
800049fc:	0e 36       	cp.w	r6,r7
800049fe:	fe 9b ff fb 	brhi	800049f4 <delay_ms+0x10>
80004a02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004a06:	00 00       	add	r0,r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	49 bc       	lddpc	r12,80004a74 <RC522_ReadByte+0x34>

80004a0c <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004a0c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004a0e:	48 78       	lddpc	r8,80004a28 <RC522_SPI_SetSpeed+0x1c>
80004a10:	70 09       	ld.w	r9,r8[0x0]
80004a12:	72 ca       	ld.w	r10,r9[0x30]
80004a14:	5c 7c       	castu.h	r12
80004a16:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004a1a:	f9 ea 10 0a 	or	r10,r12,r10
80004a1e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004a20:	70 0c       	ld.w	r12,r8[0x0]
80004a22:	f0 1f 00 03 	mcall	80004a2c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004a26:	d8 02       	popm	pc
80004a28:	00 00       	add	r0,r0
80004a2a:	1d 90       	ld.ub	r0,lr[0x1]
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	55 1c       	stdsp	sp[0x144],r12

80004a30 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004a30:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0xFF00);//baudDiv=255
80004a32:	e0 6c ff 00 	mov	r12,65280
80004a36:	f0 1f 00 02 	mcall	80004a3c <RC522_SPI_SetSpeedLow+0xc>
	
}
80004a3a:	d8 02       	popm	pc
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	4a 0c       	lddpc	r12,80004abc <RC522_WriteByte+0x38>

80004a40 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004a40:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004a44:	48 b7       	lddpc	r7,80004a70 <RC522_ReadByte+0x30>
80004a46:	30 0b       	mov	r11,0
80004a48:	6e 0c       	ld.w	r12,r7[0x0]
80004a4a:	f0 1f 00 0b 	mcall	80004a74 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004a4e:	e0 6b 00 ff 	mov	r11,255
80004a52:	6e 0c       	ld.w	r12,r7[0x0]
80004a54:	f0 1f 00 09 	mcall	80004a78 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004a58:	30 06       	mov	r6,0
80004a5a:	0c 9b       	mov	r11,r6
80004a5c:	6e 0c       	ld.w	r12,r7[0x0]
80004a5e:	f0 1f 00 08 	mcall	80004a7c <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004a62:	0c 9b       	mov	r11,r6
80004a64:	6e 0c       	ld.w	r12,r7[0x0]
80004a66:	f0 1f 00 07 	mcall	80004a80 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004a6a:	0d 9c       	ld.ub	r12,r6[0x1]
80004a6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a70:	00 00       	add	r0,r0
80004a72:	1d 90       	ld.ub	r0,lr[0x1]
80004a74:	80 00       	ld.sh	r0,r0[0x0]
80004a76:	56 88       	stdsp	sp[0x1a0],r8
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	55 22       	stdsp	sp[0x148],r2
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	55 3e       	stdsp	sp[0x14c],lr
80004a80:	80 00       	ld.sh	r0,r0[0x0]
80004a82:	56 48       	stdsp	sp[0x190],r8

80004a84 <RC522_WriteByte>:
	
}


U8 RC522_WriteByte(U8 Data)
{
80004a84:	eb cd 40 c0 	pushm	r6-r7,lr
80004a88:	20 1d       	sub	sp,4
80004a8a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004a8c:	48 c7       	lddpc	r7,80004abc <RC522_WriteByte+0x38>
80004a8e:	30 0b       	mov	r11,0
80004a90:	6e 0c       	ld.w	r12,r7[0x0]
80004a92:	f0 1f 00 0c 	mcall	80004ac0 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004a96:	1b 8b       	ld.ub	r11,sp[0x0]
80004a98:	6e 0c       	ld.w	r12,r7[0x0]
80004a9a:	f0 1f 00 0b 	mcall	80004ac4 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004a9e:	1a 9b       	mov	r11,sp
80004aa0:	6e 0c       	ld.w	r12,r7[0x0]
80004aa2:	f0 1f 00 0a 	mcall	80004ac8 <RC522_WriteByte+0x44>
80004aa6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004aa8:	30 0b       	mov	r11,0
80004aaa:	6e 0c       	ld.w	r12,r7[0x0]
80004aac:	f0 1f 00 08 	mcall	80004acc <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004ab0:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004ab4:	2f fd       	sub	sp,-4
80004ab6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004aba:	00 00       	add	r0,r0
80004abc:	00 00       	add	r0,r0
80004abe:	1d 90       	ld.ub	r0,lr[0x1]
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	56 88       	stdsp	sp[0x1a0],r8
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	55 22       	stdsp	sp[0x148],r2
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	55 3e       	stdsp	sp[0x14c],lr
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	56 48       	stdsp	sp[0x190],r8

80004ad0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004ad0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ad4:	18 96       	mov	r6,r12
80004ad6:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004ad8:	31 8c       	mov	r12,24
80004ada:	f0 1f 00 09 	mcall	80004afc <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004ade:	ec 0c 15 01 	lsl	r12,r6,0x1
80004ae2:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004ae6:	f0 1f 00 07 	mcall	80004b00 <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004aea:	0e 9c       	mov	r12,r7
80004aec:	f0 1f 00 05 	mcall	80004b00 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004af0:	31 8c       	mov	r12,24
80004af2:	f0 1f 00 05 	mcall	80004b04 <WriteRawRC+0x34>

}
80004af6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004afa:	00 00       	add	r0,r0
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	53 6c       	stdsp	sp[0xd8],r12
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	4a 84       	lddpc	r4,80004ba0 <ReadRawRC+0x18>
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	53 50       	stdsp	sp[0xd4],r0

80004b08 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004b08:	d4 01       	pushm	lr

	SET_RC522RST;
80004b0a:	31 9c       	mov	r12,25
80004b0c:	f0 1f 00 1b 	mcall	80004b78 <PcdReset+0x70>
	delay_ns(10);
80004b10:	30 ac       	mov	r12,10
80004b12:	f0 1f 00 1b 	mcall	80004b7c <PcdReset+0x74>

	CLR_RC522RST;
80004b16:	31 9c       	mov	r12,25
80004b18:	f0 1f 00 1a 	mcall	80004b80 <PcdReset+0x78>
	delay_ns(10);
80004b1c:	30 ac       	mov	r12,10
80004b1e:	f0 1f 00 18 	mcall	80004b7c <PcdReset+0x74>

	SET_RC522RST;
80004b22:	31 9c       	mov	r12,25
80004b24:	f0 1f 00 15 	mcall	80004b78 <PcdReset+0x70>
	delay_ns(10);
80004b28:	30 ac       	mov	r12,10
80004b2a:	f0 1f 00 15 	mcall	80004b7c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004b2e:	30 fb       	mov	r11,15
80004b30:	30 1c       	mov	r12,1
80004b32:	f0 1f 00 15 	mcall	80004b84 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004b36:	30 fb       	mov	r11,15
80004b38:	30 1c       	mov	r12,1
80004b3a:	f0 1f 00 13 	mcall	80004b84 <PcdReset+0x7c>
	delay_ns(10);
80004b3e:	30 ac       	mov	r12,10
80004b40:	f0 1f 00 0f 	mcall	80004b7c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004b44:	33 db       	mov	r11,61
80004b46:	31 1c       	mov	r12,17
80004b48:	f0 1f 00 0f 	mcall	80004b84 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004b4c:	31 eb       	mov	r11,30
80004b4e:	32 dc       	mov	r12,45
80004b50:	f0 1f 00 0d 	mcall	80004b84 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004b54:	30 0b       	mov	r11,0
80004b56:	32 cc       	mov	r12,44
80004b58:	f0 1f 00 0b 	mcall	80004b84 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004b5c:	e0 6b 00 8d 	mov	r11,141
80004b60:	32 ac       	mov	r12,42
80004b62:	f0 1f 00 09 	mcall	80004b84 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004b66:	33 eb       	mov	r11,62
80004b68:	32 bc       	mov	r12,43
80004b6a:	f0 1f 00 07 	mcall	80004b84 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004b6e:	34 0b       	mov	r11,64
80004b70:	31 5c       	mov	r12,21
80004b72:	f0 1f 00 05 	mcall	80004b84 <PcdReset+0x7c>
	
	return MI_OK;
}
80004b76:	d8 0a       	popm	pc,r12=0
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	53 50       	stdsp	sp[0xd4],r0
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	49 a4       	lddpc	r4,80004be4 <SetBitMask+0x1c>
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	53 6c       	stdsp	sp[0xd8],r12
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	4a d0       	lddpc	r0,80004c38 <PcdAntennaOff+0x4>

80004b88 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004b88:	eb cd 40 80 	pushm	r7,lr
80004b8c:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004b8e:	31 8c       	mov	r12,24
80004b90:	f0 1f 00 0a 	mcall	80004bb8 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004b94:	ee 08 15 01 	lsl	r8,r7,0x1
80004b98:	10 9c       	mov	r12,r8
80004b9a:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004b9e:	a7 bc       	sbr	r12,0x7
80004ba0:	f0 1f 00 07 	mcall	80004bbc <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004ba4:	f0 1f 00 07 	mcall	80004bc0 <ReadRawRC+0x38>
80004ba8:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004baa:	31 8c       	mov	r12,24
80004bac:	f0 1f 00 06 	mcall	80004bc4 <ReadRawRC+0x3c>
	return ucResult;
}
80004bb0:	0e 9c       	mov	r12,r7
80004bb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bb6:	00 00       	add	r0,r0
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	53 6c       	stdsp	sp[0xd8],r12
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	4a 84       	lddpc	r4,80004c5c <M500PcdConfigISOType+0x18>
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	4a 40       	lddpc	r0,80004c50 <M500PcdConfigISOType+0xc>
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	53 50       	stdsp	sp[0xd4],r0

80004bc8 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bcc:	18 97       	mov	r7,r12
80004bce:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004bd0:	f0 1f 00 05 	mcall	80004be4 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004bd4:	f9 e6 10 0b 	or	r11,r12,r6
80004bd8:	5c 5b       	castu.b	r11
80004bda:	0e 9c       	mov	r12,r7
80004bdc:	f0 1f 00 03 	mcall	80004be8 <SetBitMask+0x20>
}
80004be0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	4b 88       	lddpc	r8,80004cc4 <rc522_init+0x10>
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	4a d0       	lddpc	r0,80004c9c <M500PcdConfigISOType+0x58>

80004bec <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004bec:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004bee:	31 4c       	mov	r12,20
80004bf0:	f0 1f 00 05 	mcall	80004c04 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004bf4:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004bf8:	c0 51       	brne	80004c02 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004bfa:	30 3b       	mov	r11,3
80004bfc:	31 4c       	mov	r12,20
80004bfe:	f0 1f 00 03 	mcall	80004c08 <PcdAntennaOn+0x1c>
80004c02:	d8 02       	popm	pc
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	4b 88       	lddpc	r8,80004ce4 <rc522_init+0x30>
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	4b c8       	lddpc	r8,80004cf8 <rc522_init+0x44>

80004c0c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004c0c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c10:	18 97       	mov	r7,r12
80004c12:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004c14:	f0 1f 00 06 	mcall	80004c2c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004c18:	5c d6       	com	r6
80004c1a:	f9 e6 00 06 	and	r6,r12,r6
80004c1e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004c22:	0e 9c       	mov	r12,r7
80004c24:	f0 1f 00 03 	mcall	80004c30 <ClearBitMask+0x24>
	
}
80004c28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	4b 88       	lddpc	r8,80004d0c <rc522_init+0x58>
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	4a d0       	lddpc	r0,80004ce4 <rc522_init+0x30>

80004c34 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004c34:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004c36:	30 3b       	mov	r11,3
80004c38:	31 4c       	mov	r12,20
80004c3a:	f0 1f 00 02 	mcall	80004c40 <PcdAntennaOff+0xc>
}
80004c3e:	d8 02       	popm	pc
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	4c 0c       	lddpc	r12,80004d40 <rc522_init+0x8c>

80004c44 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004c44:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004c46:	34 18       	mov	r8,65
80004c48:	f0 0c 18 00 	cp.b	r12,r8
80004c4c:	c0 20       	breq	80004c50 <M500PcdConfigISOType+0xc>
80004c4e:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004c50:	30 8b       	mov	r11,8
80004c52:	16 9c       	mov	r12,r11
80004c54:	f0 1f 00 14 	mcall	80004ca4 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004c58:	33 db       	mov	r11,61
80004c5a:	31 1c       	mov	r12,17
80004c5c:	f0 1f 00 13 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004c60:	e0 6b 00 86 	mov	r11,134
80004c64:	31 7c       	mov	r12,23
80004c66:	f0 1f 00 11 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004c6a:	37 fb       	mov	r11,127
80004c6c:	32 6c       	mov	r12,38
80004c6e:	f0 1f 00 0f 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004c72:	31 eb       	mov	r11,30
80004c74:	32 dc       	mov	r12,45
80004c76:	f0 1f 00 0d 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004c7a:	30 0b       	mov	r11,0
80004c7c:	32 cc       	mov	r12,44
80004c7e:	f0 1f 00 0b 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004c82:	e0 6b 00 8d 	mov	r11,141
80004c86:	32 ac       	mov	r12,42
80004c88:	f0 1f 00 08 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004c8c:	33 eb       	mov	r11,62
80004c8e:	32 bc       	mov	r12,43
80004c90:	f0 1f 00 06 	mcall	80004ca8 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004c94:	e0 6c 03 e8 	mov	r12,1000
80004c98:	f0 1f 00 05 	mcall	80004cac <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004c9c:	f0 1f 00 05 	mcall	80004cb0 <M500PcdConfigISOType+0x6c>
80004ca0:	d8 0a       	popm	pc,r12=0
80004ca2:	00 00       	add	r0,r0
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	4c 0c       	lddpc	r12,80004da4 <PcdComMF522+0x20>
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	4a d0       	lddpc	r0,80004d5c <rc522_init+0xa8>
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	49 a4       	lddpc	r4,80004d14 <rc522_init+0x60>
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	4b ec       	lddpc	r12,80004da8 <PcdComMF522+0x24>

80004cb4 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004cb4:	eb cd 40 c0 	pushm	r6-r7,lr
80004cb8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004cba:	4a 28       	lddpc	r8,80004d40 <rc522_init+0x8c>
80004cbc:	1a 96       	mov	r6,sp
80004cbe:	f0 ea 00 00 	ld.d	r10,r8[0]
80004cc2:	fa eb 00 00 	st.d	sp[0],r10
80004cc6:	f0 e8 00 08 	ld.d	r8,r8[8]
80004cca:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004cce:	30 4b       	mov	r11,4
80004cd0:	49 dc       	lddpc	r12,80004d44 <rc522_init+0x90>
80004cd2:	f0 1f 00 1e 	mcall	80004d48 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004cd6:	31 9c       	mov	r12,25
80004cd8:	f0 1f 00 1d 	mcall	80004d4c <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004cdc:	31 9c       	mov	r12,25
80004cde:	f0 1f 00 1d 	mcall	80004d50 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004ce2:	49 d7       	lddpc	r7,80004d54 <rc522_init+0xa0>
80004ce4:	fe 7c 24 00 	mov	r12,-56320
80004ce8:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004cea:	1a 9b       	mov	r11,sp
80004cec:	f0 1f 00 1b 	mcall	80004d58 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004cf0:	30 09       	mov	r9,0
80004cf2:	12 9a       	mov	r10,r9
80004cf4:	12 9b       	mov	r11,r9
80004cf6:	6e 0c       	ld.w	r12,r7[0x0]
80004cf8:	f0 1f 00 19 	mcall	80004d5c <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004cfc:	6e 0c       	ld.w	r12,r7[0x0]
80004cfe:	f0 1f 00 19 	mcall	80004d60 <rc522_init+0xac>

	// Initialize RC522 with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004d02:	e0 6a 36 00 	mov	r10,13824
80004d06:	ea 1a 01 6e 	orh	r10,0x16e
80004d0a:	1a 9b       	mov	r11,sp
80004d0c:	6e 0c       	ld.w	r12,r7[0x0]
80004d0e:	f0 1f 00 16 	mcall	80004d64 <rc522_init+0xb0>
80004d12:	c0 50       	breq	80004d1c <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004d14:	30 29       	mov	r9,2
80004d16:	49 58       	lddpc	r8,80004d68 <rc522_init+0xb4>
80004d18:	b0 89       	st.b	r8[0x0],r9
80004d1a:	c0 38       	rjmp	80004d20 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004d1c:	f0 1f 00 14 	mcall	80004d6c <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004d20:	f0 1f 00 14 	mcall	80004d70 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004d24:	f0 1f 00 14 	mcall	80004d74 <rc522_init+0xc0>
	
	delay_ms(2); 
80004d28:	30 2c       	mov	r12,2
80004d2a:	f0 1f 00 14 	mcall	80004d78 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004d2e:	f0 1f 00 14 	mcall	80004d7c <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004d32:	34 1c       	mov	r12,65
80004d34:	f0 1f 00 13 	mcall	80004d80 <rc522_init+0xcc>
	

80004d38:	2f cd       	sub	sp,-16
80004d3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d3e:	00 00       	add	r0,r0
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	d3 84       	*unknown*
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	d3 98       	*unknown*
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	53 08       	stdsp	sp[0xc0],r8
80004d4c:	80 00       	ld.sh	r0,r0[0x0]
80004d4e:	53 38       	stdsp	sp[0xcc],r8
80004d50:	80 00       	ld.sh	r0,r0[0x0]
80004d52:	53 50       	stdsp	sp[0xd4],r0
80004d54:	00 00       	add	r0,r0
80004d56:	1d 90       	ld.ub	r0,lr[0x1]
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	54 b8       	stdsp	sp[0x12c],r8
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	54 f0       	stdsp	sp[0x13c],r0
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	55 1c       	stdsp	sp[0x144],r12
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	55 60       	stdsp	sp[0x158],r0
80004d68:	00 00       	add	r0,r0
80004d6a:	0b 50       	ld.sh	r0,--r5
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	4a 30       	lddpc	r0,80004df8 <PcdComMF522+0x74>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	4b 08       	lddpc	r8,80004e30 <PcdComMF522+0xac>
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	4c 34       	lddpc	r4,80004e80 <PcdComMF522+0xfc>
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	49 e4       	lddpc	r4,80004df0 <PcdComMF522+0x6c>
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	4b ec       	lddpc	r12,80004e74 <PcdComMF522+0xf0>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4c 44       	lddpc	r4,80004e90 <PcdComMF522+0x10c>

80004d84 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004d84:	d4 31       	pushm	r0-r7,lr
80004d86:	20 1d       	sub	sp,4
80004d88:	18 92       	mov	r2,r12
80004d8a:	16 95       	mov	r5,r11
80004d8c:	14 96       	mov	r6,r10
80004d8e:	50 09       	stdsp	sp[0x0],r9
80004d90:	10 90       	mov	r0,r8
80004d92:	f8 c8 00 0c 	sub	r8,r12,12
80004d96:	5c 58       	castu.b	r8
80004d98:	30 29       	mov	r9,2
80004d9a:	f2 08 18 00 	cp.b	r8,r9
80004d9e:	e0 88 00 05 	brls	80004da8 <PcdComMF522+0x24>
80004da2:	30 03       	mov	r3,0
80004da4:	06 91       	mov	r1,r3
80004da6:	c0 78       	rjmp	80004db4 <PcdComMF522+0x30>
80004da8:	4c f9       	lddpc	r9,80004ee4 <PcdComMF522+0x160>
80004daa:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004dae:	4c f9       	lddpc	r9,80004ee8 <PcdComMF522+0x164>
80004db0:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004db4:	02 9b       	mov	r11,r1
80004db6:	a7 bb       	sbr	r11,0x7
80004db8:	30 2c       	mov	r12,2
80004dba:	f0 1f 00 4d 	mcall	80004eec <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004dbe:	e0 6b 00 80 	mov	r11,128
80004dc2:	30 4c       	mov	r12,4
80004dc4:	f0 1f 00 4b 	mcall	80004ef0 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004dc8:	30 0b       	mov	r11,0
80004dca:	30 1c       	mov	r12,1
80004dcc:	f0 1f 00 48 	mcall	80004eec <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004dd0:	e0 6b 00 80 	mov	r11,128
80004dd4:	30 ac       	mov	r12,10
80004dd6:	f0 1f 00 48 	mcall	80004ef4 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004dda:	58 06       	cp.w	r6,0
80004ddc:	c0 c0       	breq	80004df4 <PcdComMF522+0x70>
80004dde:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004de0:	30 94       	mov	r4,9
80004de2:	0f 3b       	ld.ub	r11,r7++
80004de4:	08 9c       	mov	r12,r4
80004de6:	f0 1f 00 42 	mcall	80004eec <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004dea:	0e 98       	mov	r8,r7
80004dec:	0a 18       	sub	r8,r5
80004dee:	ec 08 19 00 	cp.h	r8,r6
80004df2:	cf 83       	brcs	80004de2 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004df4:	04 9b       	mov	r11,r2
80004df6:	30 1c       	mov	r12,1
80004df8:	f0 1f 00 3d 	mcall	80004eec <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004dfc:	30 c8       	mov	r8,12
80004dfe:	f0 02 18 00 	cp.b	r2,r8
80004e02:	c0 61       	brne	80004e0e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004e04:	e0 6b 00 80 	mov	r11,128
80004e08:	30 dc       	mov	r12,13
80004e0a:	f0 1f 00 3b 	mcall	80004ef4 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004e0e:	30 4c       	mov	r12,4
80004e10:	f0 1f 00 3a 	mcall	80004ef8 <PcdComMF522+0x174>
80004e14:	18 97       	mov	r7,r12
80004e16:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004e1a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004e1c:	30 44       	mov	r4,4
80004e1e:	c0 88       	rjmp	80004e2e <PcdComMF522+0xaa>
80004e20:	08 9c       	mov	r12,r4
80004e22:	f0 1f 00 36 	mcall	80004ef8 <PcdComMF522+0x174>
80004e26:	18 97       	mov	r7,r12
		i--;
80004e28:	20 16       	sub	r6,1
80004e2a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004e2c:	c0 a0       	breq	80004e40 <PcdComMF522+0xbc>
80004e2e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004e32:	c4 c1       	brne	80004eca <PcdComMF522+0x146>
80004e34:	ef e3 00 08 	and	r8,r7,r3
80004e38:	ea 08 18 00 	cp.b	r8,r5
80004e3c:	cf 20       	breq	80004e20 <PcdComMF522+0x9c>
80004e3e:	c4 68       	rjmp	80004eca <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004e40:	e0 6b 00 80 	mov	r11,128
80004e44:	30 dc       	mov	r12,13
80004e46:	f0 1f 00 2b 	mcall	80004ef0 <PcdComMF522+0x16c>
80004e4a:	30 27       	mov	r7,2
80004e4c:	c3 38       	rjmp	80004eb2 <PcdComMF522+0x12e>
80004e4e:	02 67       	and	r7,r1
80004e50:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004e54:	30 c8       	mov	r8,12
80004e56:	f0 02 18 00 	cp.b	r2,r8
80004e5a:	c2 c1       	brne	80004eb2 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004e5c:	30 ac       	mov	r12,10
80004e5e:	f0 1f 00 27 	mcall	80004ef8 <PcdComMF522+0x174>
80004e62:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004e64:	30 cc       	mov	r12,12
80004e66:	f0 1f 00 25 	mcall	80004ef8 <PcdComMF522+0x174>
80004e6a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004e6e:	c0 70       	breq	80004e7c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004e70:	08 98       	mov	r8,r4
80004e72:	20 18       	sub	r8,1
80004e74:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004e78:	a0 8c       	st.b	r0[0x0],r12
80004e7a:	c0 48       	rjmp	80004e82 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004e7c:	e8 08 15 03 	lsl	r8,r4,0x3
80004e80:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004e82:	58 04       	cp.w	r4,0
80004e84:	c0 61       	brne	80004e90 <PcdComMF522+0x10c>
80004e86:	30 14       	mov	r4,1
80004e88:	40 05       	lddsp	r5,sp[0x0]
80004e8a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004e8c:	30 93       	mov	r3,9
80004e8e:	c0 98       	rjmp	80004ea0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004e90:	31 28       	mov	r8,18
80004e92:	f0 04 18 00 	cp.b	r4,r8
80004e96:	f9 b4 0b 12 	movhi	r4,18
80004e9a:	58 04       	cp.w	r4,0
80004e9c:	cf 61       	brne	80004e88 <PcdComMF522+0x104>
80004e9e:	c0 a8       	rjmp	80004eb2 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ea0:	06 9c       	mov	r12,r3
80004ea2:	f0 1f 00 16 	mcall	80004ef8 <PcdComMF522+0x174>
80004ea6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ea8:	ec 05 01 08 	sub	r8,r6,r5
80004eac:	e8 08 19 00 	cp.h	r8,r4
80004eb0:	cf 83       	brcs	80004ea0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004eb2:	e0 6b 00 80 	mov	r11,128
80004eb6:	30 cc       	mov	r12,12
80004eb8:	f0 1f 00 0f 	mcall	80004ef4 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ebc:	30 0b       	mov	r11,0
80004ebe:	30 1c       	mov	r12,1
80004ec0:	f0 1f 00 0b 	mcall	80004eec <PcdComMF522+0x168>
	return status;
}
80004ec4:	0e 9c       	mov	r12,r7
80004ec6:	2f fd       	sub	sp,-4
80004ec8:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004eca:	e0 6b 00 80 	mov	r11,128
80004ece:	30 dc       	mov	r12,13
80004ed0:	f0 1f 00 08 	mcall	80004ef0 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004ed4:	30 6c       	mov	r12,6
80004ed6:	f0 1f 00 09 	mcall	80004ef8 <PcdComMF522+0x174>
80004eda:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004ede:	cb 80       	breq	80004e4e <PcdComMF522+0xca>
80004ee0:	30 27       	mov	r7,2
80004ee2:	ce 8b       	rjmp	80004eb2 <PcdComMF522+0x12e>
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	d3 94       	*unknown*
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	d3 80       	acall	0x38
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	4a d0       	lddpc	r0,80004fa0 <PcdRequest+0x20>
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	4c 0c       	lddpc	r12,80004ff0 <CalulateCRC+0xc>
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4b c8       	lddpc	r8,80004fe4 <CalulateCRC>
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	4b 88       	lddpc	r8,80004fd8 <PcdRequest+0x58>

80004efc <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004efc:	eb cd 40 c0 	pushm	r6-r7,lr
80004f00:	20 5d       	sub	sp,20
80004f02:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004f04:	30 8b       	mov	r11,8
80004f06:	16 9c       	mov	r12,r11
80004f08:	f0 1f 00 1a 	mcall	80004f70 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004f0c:	30 0b       	mov	r11,0
80004f0e:	30 dc       	mov	r12,13
80004f10:	f0 1f 00 19 	mcall	80004f74 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004f14:	e0 6b 00 80 	mov	r11,128
80004f18:	30 ec       	mov	r12,14
80004f1a:	f0 1f 00 16 	mcall	80004f70 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f1e:	39 38       	mov	r8,-109
80004f20:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004f22:	32 08       	mov	r8,32
80004f24:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004f26:	1a 9b       	mov	r11,sp
80004f28:	fa c8 ff ed 	sub	r8,sp,-19
80004f2c:	1a 99       	mov	r9,sp
80004f2e:	30 2a       	mov	r10,2
80004f30:	30 cc       	mov	r12,12
80004f32:	f0 1f 00 12 	mcall	80004f78 <PcdAnticoll+0x7c>
80004f36:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004f38:	c1 21       	brne	80004f5c <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004f3a:	1b 89       	ld.ub	r9,sp[0x0]
80004f3c:	ac 89       	st.b	r6[0x0],r9
80004f3e:	1b 98       	ld.ub	r8,sp[0x1]
80004f40:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004f42:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004f44:	1b a8       	ld.ub	r8,sp[0x2]
80004f46:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004f48:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004f4c:	1b b9       	ld.ub	r9,sp[0x3]
80004f4e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004f50:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004f52:	1b c9       	ld.ub	r9,sp[0x4]
80004f54:	f0 09 18 00 	cp.b	r9,r8
80004f58:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004f5c:	e0 6b 00 80 	mov	r11,128
80004f60:	30 ec       	mov	r12,14
80004f62:	f0 1f 00 07 	mcall	80004f7c <PcdAnticoll+0x80>
	return status;
}
80004f66:	0e 9c       	mov	r12,r7
80004f68:	2f bd       	sub	sp,-20
80004f6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f6e:	00 00       	add	r0,r0
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	4c 0c       	lddpc	r12,80005070 <PcdSelect>
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	4a d0       	lddpc	r0,80005028 <CalulateCRC+0x44>
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4d 84       	lddpc	r4,800050d8 <PcdSelect+0x68>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4b c8       	lddpc	r8,8000506c <CalulateCRC+0x88>

80004f80 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004f80:	eb cd 40 c0 	pushm	r6-r7,lr
80004f84:	20 5d       	sub	sp,20
80004f86:	18 97       	mov	r7,r12
80004f88:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004f8a:	30 8b       	mov	r11,8
80004f8c:	16 9c       	mov	r12,r11
80004f8e:	f0 1f 00 12 	mcall	80004fd4 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004f92:	30 7b       	mov	r11,7
80004f94:	30 dc       	mov	r12,13
80004f96:	f0 1f 00 11 	mcall	80004fd8 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004f9a:	30 3b       	mov	r11,3
80004f9c:	31 4c       	mov	r12,20
80004f9e:	f0 1f 00 10 	mcall	80004fdc <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004fa2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004fa4:	1a 9b       	mov	r11,sp
80004fa6:	fa c8 ff ed 	sub	r8,sp,-19
80004faa:	1a 99       	mov	r9,sp
80004fac:	30 1a       	mov	r10,1
80004fae:	30 cc       	mov	r12,12
80004fb0:	f0 1f 00 0c 	mcall	80004fe0 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004fb4:	c0 c1       	brne	80004fcc <PcdRequest+0x4c>
80004fb6:	31 08       	mov	r8,16
80004fb8:	fb 39 00 13 	ld.ub	r9,sp[19]
80004fbc:	f0 09 18 00 	cp.b	r9,r8
80004fc0:	c0 61       	brne	80004fcc <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004fc2:	1b 88       	ld.ub	r8,sp[0x0]
80004fc4:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004fc6:	1b 98       	ld.ub	r8,sp[0x1]
80004fc8:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004fca:	c0 28       	rjmp	80004fce <PcdRequest+0x4e>
80004fcc:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004fce:	2f bd       	sub	sp,-20
80004fd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	4c 0c       	lddpc	r12,800050d4 <PcdSelect+0x64>
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	4a d0       	lddpc	r0,8000508c <PcdSelect+0x1c>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	4b c8       	lddpc	r8,800050cc <PcdSelect+0x5c>
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	4d 84       	lddpc	r4,80005140 <rfid_auto_reader+0x5c>

80004fe4 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004fe4:	eb cd 40 f8 	pushm	r3-r7,lr
80004fe8:	18 95       	mov	r5,r12
80004fea:	16 96       	mov	r6,r11
80004fec:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004fee:	30 4b       	mov	r11,4
80004ff0:	30 5c       	mov	r12,5
80004ff2:	f0 1f 00 1c 	mcall	80005060 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ff6:	30 0b       	mov	r11,0
80004ff8:	30 1c       	mov	r12,1
80004ffa:	f0 1f 00 1b 	mcall	80005064 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004ffe:	e0 6b 00 80 	mov	r11,128
80005002:	30 ac       	mov	r12,10
80005004:	f0 1f 00 19 	mcall	80005068 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005008:	58 06       	cp.w	r6,0
8000500a:	c0 c0       	breq	80005022 <CalulateCRC+0x3e>
8000500c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
8000500e:	30 94       	mov	r4,9
80005010:	0f 3b       	ld.ub	r11,r7++
80005012:	08 9c       	mov	r12,r4
80005014:	f0 1f 00 14 	mcall	80005064 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80005018:	0e 98       	mov	r8,r7
8000501a:	0a 18       	sub	r8,r5
8000501c:	ec 08 18 00 	cp.b	r8,r6
80005020:	cf 83       	brcs	80005010 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80005022:	30 3b       	mov	r11,3
80005024:	30 1c       	mov	r12,1
80005026:	f0 1f 00 10 	mcall	80005064 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
8000502a:	30 5c       	mov	r12,5
8000502c:	f0 1f 00 10 	mcall	8000506c <CalulateCRC+0x88>
80005030:	e0 67 00 fe 	mov	r7,254
80005034:	30 56       	mov	r6,5
80005036:	c0 78       	rjmp	80005044 <CalulateCRC+0x60>
80005038:	0c 9c       	mov	r12,r6
8000503a:	f0 1f 00 0d 	mcall	8000506c <CalulateCRC+0x88>
		i--;
8000503e:	20 17       	sub	r7,1
80005040:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80005042:	c0 40       	breq	8000504a <CalulateCRC+0x66>
80005044:	e2 1c 00 04 	andl	r12,0x4,COH
80005048:	cf 80       	breq	80005038 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
8000504a:	32 2c       	mov	r12,34
8000504c:	f0 1f 00 08 	mcall	8000506c <CalulateCRC+0x88>
80005050:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80005052:	32 1c       	mov	r12,33
80005054:	f0 1f 00 06 	mcall	8000506c <CalulateCRC+0x88>
80005058:	a6 9c       	st.b	r3[0x1],r12
}
8000505a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000505e:	00 00       	add	r0,r0
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	4c 0c       	lddpc	r12,80005160 <rfid_auto_reader+0x7c>
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	4a d0       	lddpc	r0,80005118 <rfid_auto_reader+0x34>
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	4b c8       	lddpc	r8,80005158 <rfid_auto_reader+0x74>
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	4b 88       	lddpc	r8,8000514c <rfid_auto_reader+0x68>

80005070 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005070:	eb cd 40 80 	pushm	r7,lr
80005074:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005076:	39 38       	mov	r8,-109
80005078:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000507a:	37 08       	mov	r8,112
8000507c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
8000507e:	30 08       	mov	r8,0
80005080:	ba e8       	st.b	sp[0x6],r8
80005082:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80005086:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000508a:	19 89       	ld.ub	r9,r12[0x0]
8000508c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
8000508e:	19 3a       	ld.ub	r10,r12++
80005090:	1b e9       	ld.ub	r9,sp[0x6]
80005092:	f5 e9 20 09 	eor	r9,r10,r9
80005096:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80005098:	16 38       	cp.w	r8,r11
8000509a:	cf 81       	brne	8000508a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
8000509c:	1a 97       	mov	r7,sp
8000509e:	fa ca ff f9 	sub	r10,sp,-7
800050a2:	30 7b       	mov	r11,7
800050a4:	1a 9c       	mov	r12,sp
800050a6:	f0 1f 00 0d 	mcall	800050d8 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
800050aa:	30 8b       	mov	r11,8
800050ac:	16 9c       	mov	r12,r11
800050ae:	f0 1f 00 0c 	mcall	800050dc <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
800050b2:	fa c8 ff ed 	sub	r8,sp,-19
800050b6:	1a 99       	mov	r9,sp
800050b8:	30 9a       	mov	r10,9
800050ba:	1a 9b       	mov	r11,sp
800050bc:	30 cc       	mov	r12,12
800050be:	f0 1f 00 09 	mcall	800050e0 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
800050c2:	c0 71       	brne	800050d0 <PcdSelect+0x60>
800050c4:	31 88       	mov	r8,24
800050c6:	fb 39 00 13 	ld.ub	r9,sp[19]
800050ca:	f0 09 18 00 	cp.b	r9,r8
800050ce:	c0 20       	breq	800050d2 <PcdSelect+0x62>
800050d0:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
800050d2:	2f bd       	sub	sp,-20
800050d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	4f e4       	lddpc	r4,800052d0 <gpio_enable_module_pin+0x1a>
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	4c 0c       	lddpc	r12,800051dc <rfid_init>
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	4d 84       	lddpc	r4,80005240 <local_start_pll0+0x14>

800050e4 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
800050e4:	d4 31       	pushm	r0-r7,lr
800050e6:	20 1d       	sub	sp,4
800050e8:	50 0c       	stdsp	sp[0x0],r12
	U8 status = MI_ERR;
	
	PcdReset();
800050ea:	f0 1f 00 2f 	mcall	800051a4 <rfid_auto_reader+0xc0>
while(1){
		
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800050ee:	4a f7       	lddpc	r7,800051a8 <rfid_auto_reader+0xc4>
800050f0:	35 25       	mov	r5,82
	if(status!=MI_OK) continue;;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800050f2:	30 43       	mov	r3,4
		log("MF Desire\n");
	else
		log("Unknown\n");
		
	   
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800050f4:	4a e4       	lddpc	r4,800051ac <rfid_auto_reader+0xc8>
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) continue;;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800050f6:	30 22       	mov	r2,2
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800050f8:	34 46       	mov	r6,68
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800050fa:	30 81       	mov	r1,8
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
		log("MF Desire\n");
	else
		log("Unknown\n");
800050fc:	4a d0       	lddpc	r0,800051b0 <rfid_auto_reader+0xcc>
	U8 status = MI_ERR;
	
	PcdReset();
while(1){
		
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800050fe:	0e 9b       	mov	r11,r7
80005100:	0a 9c       	mov	r12,r5
80005102:	f0 1f 00 2d 	mcall	800051b4 <rfid_auto_reader+0xd0>
	if(status!=MI_OK) continue;;
80005106:	cf c1       	brne	800050fe <rfid_auto_reader+0x1a>
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005108:	0f 88       	ld.ub	r8,r7[0x0]
8000510a:	e6 08 18 00 	cp.b	r8,r3
8000510e:	c0 a1       	brne	80005122 <rfid_auto_reader+0x3e>
80005110:	0f 9a       	ld.ub	r10,r7[0x1]
80005112:	30 09       	mov	r9,0
80005114:	f2 0a 18 00 	cp.b	r10,r9
80005118:	c0 51       	brne	80005122 <rfid_auto_reader+0x3e>
		log("MFOne-S50\n");
8000511a:	4a 8c       	lddpc	r12,800051b8 <rfid_auto_reader+0xd4>
8000511c:	f0 1f 00 28 	mcall	800051bc <rfid_auto_reader+0xd8>
while(1){
		
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) continue;;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005120:	c3 48       	rjmp	80005188 <rfid_auto_reader+0xa4>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005122:	e4 08 18 00 	cp.b	r8,r2
80005126:	c0 a1       	brne	8000513a <rfid_auto_reader+0x56>
80005128:	0f 9a       	ld.ub	r10,r7[0x1]
8000512a:	30 09       	mov	r9,0
8000512c:	f2 0a 18 00 	cp.b	r10,r9
80005130:	c0 51       	brne	8000513a <rfid_auto_reader+0x56>
		log("MFOne-S70\n");
80005132:	4a 4c       	lddpc	r12,800051c0 <rfid_auto_reader+0xdc>
80005134:	f0 1f 00 22 	mcall	800051bc <rfid_auto_reader+0xd8>
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) continue;;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005138:	c2 88       	rjmp	80005188 <rfid_auto_reader+0xa4>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000513a:	ec 08 18 00 	cp.b	r8,r6
8000513e:	c0 a1       	brne	80005152 <rfid_auto_reader+0x6e>
80005140:	0f 9a       	ld.ub	r10,r7[0x1]
80005142:	30 09       	mov	r9,0
80005144:	f2 0a 18 00 	cp.b	r10,r9
80005148:	c0 51       	brne	80005152 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
8000514a:	49 fc       	lddpc	r12,800051c4 <rfid_auto_reader+0xe0>
8000514c:	f0 1f 00 1c 	mcall	800051bc <rfid_auto_reader+0xd8>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005150:	c1 c8       	rjmp	80005188 <rfid_auto_reader+0xa4>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005152:	e2 08 18 00 	cp.b	r8,r1
80005156:	c0 a1       	brne	8000516a <rfid_auto_reader+0x86>
80005158:	0f 9a       	ld.ub	r10,r7[0x1]
8000515a:	30 09       	mov	r9,0
8000515c:	f2 0a 18 00 	cp.b	r10,r9
80005160:	c0 51       	brne	8000516a <rfid_auto_reader+0x86>
		log("MF-Pro\n");
80005162:	49 ac       	lddpc	r12,800051c8 <rfid_auto_reader+0xe4>
80005164:	f0 1f 00 16 	mcall	800051bc <rfid_auto_reader+0xd8>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005168:	c1 08       	rjmp	80005188 <rfid_auto_reader+0xa4>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000516a:	ec 08 18 00 	cp.b	r8,r6
8000516e:	c0 a1       	brne	80005182 <rfid_auto_reader+0x9e>
80005170:	0f 99       	ld.ub	r9,r7[0x1]
80005172:	30 38       	mov	r8,3
80005174:	f0 09 18 00 	cp.b	r9,r8
80005178:	c0 51       	brne	80005182 <rfid_auto_reader+0x9e>
		log("MF Desire\n");
8000517a:	49 5c       	lddpc	r12,800051cc <rfid_auto_reader+0xe8>
8000517c:	f0 1f 00 10 	mcall	800051bc <rfid_auto_reader+0xd8>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005180:	c0 48       	rjmp	80005188 <rfid_auto_reader+0xa4>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005182:	00 9c       	mov	r12,r0
80005184:	f0 1f 00 0e 	mcall	800051bc <rfid_auto_reader+0xd8>
		
	   
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005188:	08 9c       	mov	r12,r4
8000518a:	f0 1f 00 12 	mcall	800051d0 <rfid_auto_reader+0xec>
	if(status!=MI_OK)continue;
8000518e:	cb 81       	brne	800050fe <rfid_auto_reader+0x1a>
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005190:	08 9c       	mov	r12,r4
80005192:	f0 1f 00 11 	mcall	800051d4 <rfid_auto_reader+0xf0>
	if(status!=MI_OK)continue;
80005196:	cb 41       	brne	800050fe <rfid_auto_reader+0x1a>
	else{//℃
			
		memcpy(card_id, SN, 4);
80005198:	30 4a       	mov	r10,4
8000519a:	08 9b       	mov	r11,r4
8000519c:	40 0c       	lddsp	r12,sp[0x0]
8000519e:	f0 1f 00 0f 	mcall	800051d8 <rfid_auto_reader+0xf4>
800051a2:	ca eb       	rjmp	800050fe <rfid_auto_reader+0x1a>
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	4b 08       	lddpc	r8,80005264 <local_start_pll0+0x38>
800051a8:	00 00       	add	r0,r0
800051aa:	0d 88       	ld.ub	r8,r6[0x0]
800051ac:	00 00       	add	r0,r0
800051ae:	0d 8c       	ld.ub	r12,r6[0x0]
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	d3 f4       	*unknown*
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	4f 80       	lddpc	r0,80005394 <INTC_register_interrupt+0x8>
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	d3 b8       	*unknown*
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	6b c4       	ld.w	r4,r5[0x70]
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	d3 c4       	*unknown*
800051c4:	80 00       	ld.sh	r0,r0[0x0]
800051c6:	d3 d0       	acall	0x3d
800051c8:	80 00       	ld.sh	r0,r0[0x0]
800051ca:	d3 e0       	acall	0x3e
800051cc:	80 00       	ld.sh	r0,r0[0x0]
800051ce:	d3 e8       	*unknown*
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	4e fc       	lddpc	r12,8000538c <INTC_register_interrupt>
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	50 70       	stdsp	sp[0x1c],r0
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	74 58       	ld.w	r8,r10[0x14]

800051dc <rfid_init>:
#include "RFID.h"
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
800051dc:	eb cd 40 80 	pushm	r7,lr
800051e0:	20 1d       	sub	sp,4
	char card_id[4]={0};
800051e2:	fa c7 ff fc 	sub	r7,sp,-4
800051e6:	30 08       	mov	r8,0
800051e8:	0e d8       	st.w	--r7,r8
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800051ea:	f0 1f 00 0d 	mcall	8000521c <rfid_init+0x40>
	
	if(rfid_auto_reader(card_id) == 0){
800051ee:	1a 9c       	mov	r12,sp
800051f0:	f0 1f 00 0c 	mcall	80005220 <rfid_init+0x44>
800051f4:	c1 11       	brne	80005216 <rfid_init+0x3a>
		log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
800051f6:	fa c8 ff fd 	sub	r8,sp,-3
800051fa:	1a d8       	st.w	--sp,r8
800051fc:	fa c8 ff fa 	sub	r8,sp,-6
80005200:	1a d8       	st.w	--sp,r8
80005202:	fa c8 ff f7 	sub	r8,sp,-9
80005206:	1a d8       	st.w	--sp,r8
80005208:	fa c8 ff f4 	sub	r8,sp,-12
8000520c:	1a d8       	st.w	--sp,r8
8000520e:	48 6c       	lddpc	r12,80005224 <rfid_init+0x48>
80005210:	f0 1f 00 06 	mcall	80005228 <rfid_init+0x4c>
80005214:	2f cd       	sub	sp,-16
	}
		
}
80005216:	2f fd       	sub	sp,-4
80005218:	e3 cd 80 80 	ldm	sp++,r7,pc
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	4c b4       	lddpc	r4,80005348 <gpio_enable_gpio_pin+0x10>
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	50 e4       	stdsp	sp[0x38],r4
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	d4 00       	acall	0x40
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	6b c4       	ld.w	r4,r5[0x70]

8000522c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000522c:	fe 78 0c 00 	mov	r8,-62464
80005230:	e0 69 03 07 	mov	r9,775
80005234:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005236:	30 49       	mov	r9,4
80005238:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000523a:	71 59       	ld.w	r9,r8[0x54]
8000523c:	e2 19 00 80 	andl	r9,0x80,COH
80005240:	cf d0       	breq	8000523a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005242:	fe 78 0c 00 	mov	r8,-62464
80005246:	30 59       	mov	r9,5
80005248:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000524a:	e0 69 01 0d 	mov	r9,269
8000524e:	ea 19 10 07 	orh	r9,0x1007
80005252:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005254:	71 59       	ld.w	r9,r8[0x54]
80005256:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000525a:	cf d0       	breq	80005254 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000525c:	fe 78 0c 00 	mov	r8,-62464
80005260:	fc 19 00 80 	movh	r9,0x80
80005264:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005266:	34 0a       	mov	r10,64
80005268:	fe 69 14 00 	mov	r9,-125952
8000526c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000526e:	30 69       	mov	r9,6
80005270:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005272:	30 19       	mov	r9,1
80005274:	fe 68 10 00 	mov	r8,-126976
80005278:	91 19       	st.w	r8[0x4],r9
}
8000527a:	5e fc       	retal	r12

8000527c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000527c:	fe 78 10 00 	mov	r8,-61440
80005280:	fc 19 00 10 	movh	r9,0x10
80005284:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005286:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005288:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000528a:	30 39       	mov	r9,3
8000528c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005290:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005294:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005298:	fe 78 38 00 	mov	r8,-51200
8000529c:	30 49       	mov	r9,4
8000529e:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800052a2:	e0 69 91 0d 	mov	r9,37133
800052a6:	ea 19 00 52 	orh	r9,0x52
800052aa:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800052ac:	32 09       	mov	r9,32
800052ae:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800052b0:	30 59       	mov	r9,5
800052b2:	91 09       	st.w	r8[0x0],r9
}
800052b4:	5e fc       	retal	r12

800052b6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800052b6:	f8 08 16 05 	lsr	r8,r12,0x5
800052ba:	a9 68       	lsl	r8,0x8
800052bc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800052c0:	58 1b       	cp.w	r11,1
800052c2:	c0 d0       	breq	800052dc <gpio_enable_module_pin+0x26>
800052c4:	c0 63       	brcs	800052d0 <gpio_enable_module_pin+0x1a>
800052c6:	58 2b       	cp.w	r11,2
800052c8:	c1 00       	breq	800052e8 <gpio_enable_module_pin+0x32>
800052ca:	58 3b       	cp.w	r11,3
800052cc:	c1 40       	breq	800052f4 <gpio_enable_module_pin+0x3e>
800052ce:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052d0:	30 19       	mov	r9,1
800052d2:	f2 0c 09 49 	lsl	r9,r9,r12
800052d6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052d8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052da:	c1 28       	rjmp	800052fe <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052dc:	30 19       	mov	r9,1
800052de:	f2 0c 09 49 	lsl	r9,r9,r12
800052e2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052e4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052e6:	c0 c8       	rjmp	800052fe <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052e8:	30 19       	mov	r9,1
800052ea:	f2 0c 09 49 	lsl	r9,r9,r12
800052ee:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052f0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052f2:	c0 68       	rjmp	800052fe <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052f4:	30 19       	mov	r9,1
800052f6:	f2 0c 09 49 	lsl	r9,r9,r12
800052fa:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052fc:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800052fe:	30 19       	mov	r9,1
80005300:	f2 0c 09 4c 	lsl	r12,r9,r12
80005304:	91 2c       	st.w	r8[0x8],r12
80005306:	5e fd       	retal	0

80005308 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005308:	d4 21       	pushm	r4-r7,lr
8000530a:	18 97       	mov	r7,r12
8000530c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000530e:	58 0b       	cp.w	r11,0
80005310:	c0 31       	brne	80005316 <gpio_enable_module+0xe>
80005312:	30 05       	mov	r5,0
80005314:	c0 d8       	rjmp	8000532e <gpio_enable_module+0x26>
80005316:	30 06       	mov	r6,0
80005318:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000531a:	6e 1b       	ld.w	r11,r7[0x4]
8000531c:	6e 0c       	ld.w	r12,r7[0x0]
8000531e:	f0 1f 00 06 	mcall	80005334 <gpio_enable_module+0x2c>
80005322:	18 45       	or	r5,r12
		gpiomap++;
80005324:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005326:	2f f6       	sub	r6,-1
80005328:	0c 34       	cp.w	r4,r6
8000532a:	fe 9b ff f8 	brhi	8000531a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000532e:	0a 9c       	mov	r12,r5
80005330:	d8 22       	popm	r4-r7,pc
80005332:	00 00       	add	r0,r0
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	52 b6       	stdsp	sp[0xac],r6

80005338 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005338:	f8 08 16 05 	lsr	r8,r12,0x5
8000533c:	a9 68       	lsl	r8,0x8
8000533e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005342:	30 19       	mov	r9,1
80005344:	f2 0c 09 4c 	lsl	r12,r9,r12
80005348:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000534c:	91 1c       	st.w	r8[0x4],r12
}
8000534e:	5e fc       	retal	r12

80005350 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005350:	f8 08 16 05 	lsr	r8,r12,0x5
80005354:	a9 68       	lsl	r8,0x8
80005356:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000535a:	30 19       	mov	r9,1
8000535c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005360:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005364:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005368:	91 1c       	st.w	r8[0x4],r12
}
8000536a:	5e fc       	retal	r12

8000536c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000536c:	f8 08 16 05 	lsr	r8,r12,0x5
80005370:	a9 68       	lsl	r8,0x8
80005372:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005376:	30 19       	mov	r9,1
80005378:	f2 0c 09 4c 	lsl	r12,r9,r12
8000537c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005380:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005384:	91 1c       	st.w	r8[0x4],r12
}
80005386:	5e fc       	retal	r12

80005388 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005388:	c0 08       	rjmp	80005388 <_unhandled_interrupt>
8000538a:	d7 03       	nop

8000538c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000538c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005390:	49 99       	lddpc	r9,800053f4 <INTC_register_interrupt+0x68>
80005392:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005396:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000539a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000539c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800053a0:	58 0a       	cp.w	r10,0
800053a2:	c0 91       	brne	800053b4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053a4:	49 59       	lddpc	r9,800053f8 <INTC_register_interrupt+0x6c>
800053a6:	49 6a       	lddpc	r10,800053fc <INTC_register_interrupt+0x70>
800053a8:	12 1a       	sub	r10,r9
800053aa:	fe 79 08 00 	mov	r9,-63488
800053ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053b2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800053b4:	58 1a       	cp.w	r10,1
800053b6:	c0 a1       	brne	800053ca <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800053b8:	49 09       	lddpc	r9,800053f8 <INTC_register_interrupt+0x6c>
800053ba:	49 2a       	lddpc	r10,80005400 <INTC_register_interrupt+0x74>
800053bc:	12 1a       	sub	r10,r9
800053be:	bf aa       	sbr	r10,0x1e
800053c0:	fe 79 08 00 	mov	r9,-63488
800053c4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053c8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800053ca:	58 2a       	cp.w	r10,2
800053cc:	c0 a1       	brne	800053e0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800053ce:	48 b9       	lddpc	r9,800053f8 <INTC_register_interrupt+0x6c>
800053d0:	48 da       	lddpc	r10,80005404 <INTC_register_interrupt+0x78>
800053d2:	12 1a       	sub	r10,r9
800053d4:	bf ba       	sbr	r10,0x1f
800053d6:	fe 79 08 00 	mov	r9,-63488
800053da:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053de:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800053e0:	48 69       	lddpc	r9,800053f8 <INTC_register_interrupt+0x6c>
800053e2:	48 aa       	lddpc	r10,80005408 <INTC_register_interrupt+0x7c>
800053e4:	12 1a       	sub	r10,r9
800053e6:	ea 1a c0 00 	orh	r10,0xc000
800053ea:	fe 79 08 00 	mov	r9,-63488
800053ee:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053f2:	5e fc       	retal	r12
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	d4 24       	*unknown*
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	ca 00       	breq	8000533a <gpio_enable_gpio_pin+0x2>
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	cb 04       	brge	8000535e <gpio_set_gpio_pin+0xe>
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	cb 12       	brcc	80005364 <gpio_set_gpio_pin+0x14>
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	cb 20       	breq	8000536a <gpio_set_gpio_pin+0x1a>
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	cb 2e       	rcall	8000516e <rfid_auto_reader+0x8a>

8000540c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000540c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000540e:	49 18       	lddpc	r8,80005450 <INTC_init_interrupts+0x44>
80005410:	e3 b8 00 01 	mtsr	0x4,r8
80005414:	49 0e       	lddpc	lr,80005454 <INTC_init_interrupts+0x48>
80005416:	30 07       	mov	r7,0
80005418:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000541a:	49 0c       	lddpc	r12,80005458 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000541c:	49 05       	lddpc	r5,8000545c <INTC_init_interrupts+0x50>
8000541e:	10 15       	sub	r5,r8
80005420:	fe 76 08 00 	mov	r6,-63488
80005424:	c1 08       	rjmp	80005444 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005426:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005428:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000542a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000542c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005430:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005432:	10 3a       	cp.w	r10,r8
80005434:	fe 9b ff fc 	brhi	8000542c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005438:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000543c:	2f f7       	sub	r7,-1
8000543e:	2f 8e       	sub	lr,-8
80005440:	59 37       	cp.w	r7,19
80005442:	c0 50       	breq	8000544c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005444:	7c 08       	ld.w	r8,lr[0x0]
80005446:	58 08       	cp.w	r8,0
80005448:	ce f1       	brne	80005426 <INTC_init_interrupts+0x1a>
8000544a:	cf 7b       	rjmp	80005438 <INTC_init_interrupts+0x2c>
8000544c:	d8 22       	popm	r4-r7,pc
8000544e:	00 00       	add	r0,r0
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	ca 00       	breq	80005392 <INTC_register_interrupt+0x6>
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	d4 24       	*unknown*
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	53 88       	stdsp	sp[0xe0],r8
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	cb 04       	brge	800053be <INTC_register_interrupt+0x32>

80005460 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005460:	fe 78 08 00 	mov	r8,-63488
80005464:	e0 69 00 83 	mov	r9,131
80005468:	f2 0c 01 0c 	sub	r12,r9,r12
8000546c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005470:	f2 ca ff c0 	sub	r10,r9,-64
80005474:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005478:	58 08       	cp.w	r8,0
8000547a:	c0 21       	brne	8000547e <_get_interrupt_handler+0x1e>
8000547c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000547e:	f0 08 12 00 	clz	r8,r8
80005482:	48 5a       	lddpc	r10,80005494 <_get_interrupt_handler+0x34>
80005484:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005488:	f0 08 11 1f 	rsub	r8,r8,31
8000548c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000548e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005492:	5e fc       	retal	r12
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	d4 24       	*unknown*

80005498 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005498:	f8 c8 00 01 	sub	r8,r12,1
8000549c:	f0 0b 00 0b 	add	r11,r8,r11
800054a0:	f6 0c 0d 0a 	divu	r10,r11,r12
800054a4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800054a6:	f4 c8 00 01 	sub	r8,r10,1
800054aa:	e0 48 00 fe 	cp.w	r8,254
800054ae:	e0 88 00 03 	brls	800054b4 <getBaudDiv+0x1c>
800054b2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800054b4:	5c 8c       	casts.h	r12
}
800054b6:	5e fc       	retal	r12

800054b8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800054b8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800054bc:	30 18       	mov	r8,1
800054be:	f0 09 18 00 	cp.b	r9,r8
800054c2:	e0 88 00 04 	brls	800054ca <spi_initMaster+0x12>
800054c6:	30 2c       	mov	r12,2
800054c8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800054ca:	e0 68 00 80 	mov	r8,128
800054ce:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800054d0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800054d2:	30 19       	mov	r9,1
800054d4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800054d8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800054dc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800054e0:	30 09       	mov	r9,0
800054e2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800054e6:	30 fa       	mov	r10,15
800054e8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800054ec:	99 18       	st.w	r12[0x4],r8
800054ee:	5e f9       	retal	r9

800054f0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800054f0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800054f2:	30 18       	mov	r8,1
800054f4:	f0 0b 18 00 	cp.b	r11,r8
800054f8:	5f be       	srhi	lr
800054fa:	f0 0a 18 00 	cp.b	r10,r8
800054fe:	5f b8       	srhi	r8
80005500:	fd e8 10 08 	or	r8,lr,r8
80005504:	c0 30       	breq	8000550a <spi_selectionMode+0x1a>
80005506:	30 2c       	mov	r12,2
80005508:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000550a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000550c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005510:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005514:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005518:	99 18       	st.w	r12[0x4],r8
8000551a:	d8 0a       	popm	pc,r12=0

8000551c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000551c:	30 18       	mov	r8,1
8000551e:	99 08       	st.w	r12[0x0],r8
}
80005520:	5e fc       	retal	r12

80005522 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005522:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005526:	c0 58       	rjmp	80005530 <spi_write+0xe>
		if (!timeout--) {
80005528:	58 08       	cp.w	r8,0
8000552a:	c0 21       	brne	8000552e <spi_write+0xc>
8000552c:	5e ff       	retal	1
8000552e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005530:	78 49       	ld.w	r9,r12[0x10]
80005532:	e2 19 00 02 	andl	r9,0x2,COH
80005536:	cf 90       	breq	80005528 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005538:	5c 7b       	castu.h	r11
8000553a:	99 3b       	st.w	r12[0xc],r11
8000553c:	5e fd       	retal	0

8000553e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000553e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005542:	c0 58       	rjmp	8000554c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005544:	58 08       	cp.w	r8,0
80005546:	c0 21       	brne	8000554a <spi_read+0xc>
80005548:	5e ff       	retal	1
8000554a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000554c:	78 49       	ld.w	r9,r12[0x10]
8000554e:	e2 19 02 01 	andl	r9,0x201,COH
80005552:	e0 49 02 01 	cp.w	r9,513
80005556:	cf 71       	brne	80005544 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005558:	78 28       	ld.w	r8,r12[0x8]
8000555a:	b6 08       	st.h	r11[0x0],r8
8000555c:	5e fd       	retal	0
8000555e:	d7 03       	nop

80005560 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005560:	eb cd 40 f8 	pushm	r3-r7,lr
80005564:	18 95       	mov	r5,r12
80005566:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005568:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000556c:	30 38       	mov	r8,3
8000556e:	f0 06 18 00 	cp.b	r6,r8
80005572:	e0 8b 00 5e 	brhi	8000562e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005576:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000557a:	30 18       	mov	r8,1
8000557c:	f0 04 18 00 	cp.b	r4,r8
80005580:	e0 8b 00 57 	brhi	8000562e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005584:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005588:	30 78       	mov	r8,7
8000558a:	f0 03 18 00 	cp.b	r3,r8
8000558e:	e0 88 00 50 	brls	8000562e <spi_setupChipReg+0xce>
80005592:	31 08       	mov	r8,16
80005594:	f0 03 18 00 	cp.b	r3,r8
80005598:	e0 8b 00 4b 	brhi	8000562e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000559c:	14 9b       	mov	r11,r10
8000559e:	6e 1c       	ld.w	r12,r7[0x4]
800055a0:	f0 1f 00 26 	mcall	80005638 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800055a4:	c4 55       	brlt	8000562e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800055a6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800055a8:	ec 09 16 01 	lsr	r9,r6,0x1
800055ac:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800055b0:	ec 16 00 01 	eorl	r6,0x1
800055b4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800055b8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800055bc:	20 83       	sub	r3,8
800055be:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800055c2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800055c6:	ef 39 00 09 	ld.ub	r9,r7[9]
800055ca:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800055ce:	ef 39 00 0a 	ld.ub	r9,r7[10]
800055d2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800055d6:	0f 89       	ld.ub	r9,r7[0x0]
800055d8:	30 1a       	mov	r10,1
800055da:	f4 09 18 00 	cp.b	r9,r10
800055de:	c0 d0       	breq	800055f8 <spi_setupChipReg+0x98>
800055e0:	c0 a3       	brcs	800055f4 <spi_setupChipReg+0x94>
800055e2:	30 2a       	mov	r10,2
800055e4:	f4 09 18 00 	cp.b	r9,r10
800055e8:	c0 a0       	breq	800055fc <spi_setupChipReg+0x9c>
800055ea:	30 3a       	mov	r10,3
800055ec:	f4 09 18 00 	cp.b	r9,r10
800055f0:	c1 f1       	brne	8000562e <spi_setupChipReg+0xce>
800055f2:	c0 78       	rjmp	80005600 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800055f4:	8b c8       	st.w	r5[0x30],r8
		break;
800055f6:	c0 68       	rjmp	80005602 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800055f8:	8b d8       	st.w	r5[0x34],r8
		break;
800055fa:	c0 48       	rjmp	80005602 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800055fc:	8b e8       	st.w	r5[0x38],r8
		break;
800055fe:	c0 28       	rjmp	80005602 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005600:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005602:	48 f8       	lddpc	r8,8000563c <spi_setupChipReg+0xdc>
80005604:	70 08       	ld.w	r8,r8[0x0]
80005606:	58 08       	cp.w	r8,0
80005608:	c1 61       	brne	80005634 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000560a:	30 0b       	mov	r11,0
8000560c:	30 1c       	mov	r12,1
8000560e:	f0 1f 00 0d 	mcall	80005640 <spi_setupChipReg+0xe0>
80005612:	48 b8       	lddpc	r8,8000563c <spi_setupChipReg+0xdc>
80005614:	91 0c       	st.w	r8[0x0],r12
80005616:	58 0c       	cp.w	r12,0
80005618:	c0 a0       	breq	8000562c <spi_setupChipReg+0xcc>
8000561a:	30 09       	mov	r9,0
8000561c:	12 9a       	mov	r10,r9
8000561e:	12 9b       	mov	r11,r9
80005620:	f0 1f 00 09 	mcall	80005644 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005624:	48 68       	lddpc	r8,8000563c <spi_setupChipReg+0xdc>
80005626:	70 08       	ld.w	r8,r8[0x0]
80005628:	58 08       	cp.w	r8,0
8000562a:	c0 51       	brne	80005634 <spi_setupChipReg+0xd4>
8000562c:	c0 08       	rjmp	8000562c <spi_setupChipReg+0xcc>
8000562e:	30 2c       	mov	r12,2
80005630:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005634:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005638:	80 00       	ld.sh	r0,r0[0x0]
8000563a:	54 98       	stdsp	sp[0x124],r8
8000563c:	00 00       	add	r0,r0
8000563e:	51 08       	stdsp	sp[0x40],r8
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	61 2c       	ld.w	r12,r0[0x48]
80005644:	80 00       	ld.sh	r0,r0[0x0]
80005646:	60 2c       	ld.w	r12,r0[0x8]

80005648 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005648:	d4 01       	pushm	lr
8000564a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000564e:	c0 58       	rjmp	80005658 <spi_unselectChip+0x10>
		if (!timeout--) {
80005650:	58 08       	cp.w	r8,0
80005652:	c0 21       	brne	80005656 <spi_unselectChip+0xe>
80005654:	da 0a       	popm	pc,r12=1
80005656:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005658:	78 49       	ld.w	r9,r12[0x10]
8000565a:	e2 19 02 00 	andl	r9,0x200,COH
8000565e:	cf 90       	breq	80005650 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005660:	78 18       	ld.w	r8,r12[0x4]
80005662:	ea 18 00 0f 	orh	r8,0xf
80005666:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005668:	fc 18 01 00 	movh	r8,0x100
8000566c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000566e:	30 09       	mov	r9,0
80005670:	12 9a       	mov	r10,r9
80005672:	12 9b       	mov	r11,r9
80005674:	48 38       	lddpc	r8,80005680 <spi_unselectChip+0x38>
80005676:	70 0c       	ld.w	r12,r8[0x0]
80005678:	f0 1f 00 03 	mcall	80005684 <spi_unselectChip+0x3c>
8000567c:	d8 0a       	popm	pc,r12=0
8000567e:	00 00       	add	r0,r0
80005680:	00 00       	add	r0,r0
80005682:	51 08       	stdsp	sp[0x40],r8
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	60 2c       	ld.w	r12,r0[0x8]

80005688 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005688:	eb cd 40 f8 	pushm	r3-r7,lr
8000568c:	18 94       	mov	r4,r12
8000568e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005690:	49 a6       	lddpc	r6,800056f8 <spi_selectChip+0x70>
80005692:	30 07       	mov	r7,0
80005694:	31 45       	mov	r5,20
80005696:	0e 99       	mov	r9,r7
80005698:	0a 9a       	mov	r10,r5
8000569a:	0e 9b       	mov	r11,r7
8000569c:	6c 0c       	ld.w	r12,r6[0x0]
8000569e:	f0 1f 00 18 	mcall	800056fc <spi_selectChip+0x74>
800056a2:	cf a0       	breq	80005696 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800056a4:	68 18       	ld.w	r8,r4[0x4]
800056a6:	ea 18 00 0f 	orh	r8,0xf
800056aa:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800056ac:	68 18       	ld.w	r8,r4[0x4]
800056ae:	e2 18 00 04 	andl	r8,0x4,COH
800056b2:	c1 10       	breq	800056d4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800056b4:	30 e8       	mov	r8,14
800056b6:	f0 03 18 00 	cp.b	r3,r8
800056ba:	e0 8b 00 1c 	brhi	800056f2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800056be:	68 19       	ld.w	r9,r4[0x4]
800056c0:	e6 08 15 10 	lsl	r8,r3,0x10
800056c4:	ea 18 ff f0 	orh	r8,0xfff0
800056c8:	e8 18 ff ff 	orl	r8,0xffff
800056cc:	12 68       	and	r8,r9
800056ce:	89 18       	st.w	r4[0x4],r8
800056d0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800056d4:	30 38       	mov	r8,3
800056d6:	f0 03 18 00 	cp.b	r3,r8
800056da:	e0 8b 00 0c 	brhi	800056f2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800056de:	68 19       	ld.w	r9,r4[0x4]
800056e0:	2f 03       	sub	r3,-16
800056e2:	30 18       	mov	r8,1
800056e4:	f0 03 09 48 	lsl	r8,r8,r3
800056e8:	5c d8       	com	r8
800056ea:	12 68       	and	r8,r9
800056ec:	89 18       	st.w	r4[0x4],r8
800056ee:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800056f2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800056f4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800056f8:	00 00       	add	r0,r0
800056fa:	51 08       	stdsp	sp[0x40],r8
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	5e 20       	reths	r0

80005700 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005700:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005702:	f6 08 15 04 	lsl	r8,r11,0x4
80005706:	14 38       	cp.w	r8,r10
80005708:	f9 b8 08 10 	movls	r8,16
8000570c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005710:	f0 0b 02 4b 	mul	r11,r8,r11
80005714:	f6 09 16 01 	lsr	r9,r11,0x1
80005718:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000571c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005720:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005724:	f2 cb 00 01 	sub	r11,r9,1
80005728:	e0 4b ff fe 	cp.w	r11,65534
8000572c:	e0 88 00 03 	brls	80005732 <usart_set_async_baudrate+0x32>
80005730:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005732:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005734:	e8 6e 00 00 	mov	lr,524288
80005738:	59 08       	cp.w	r8,16
8000573a:	fc 08 17 10 	movne	r8,lr
8000573e:	f9 b8 00 00 	moveq	r8,0
80005742:	e4 1b ff f7 	andh	r11,0xfff7
80005746:	e0 1b fe cf 	andl	r11,0xfecf
8000574a:	16 48       	or	r8,r11
8000574c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000574e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005752:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005756:	99 89       	st.w	r12[0x20],r9
80005758:	d8 0a       	popm	pc,r12=0

8000575a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000575a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000575c:	e2 18 00 02 	andl	r8,0x2,COH
80005760:	c0 31       	brne	80005766 <usart_write_char+0xc>
80005762:	30 2c       	mov	r12,2
80005764:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005766:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000576a:	99 7b       	st.w	r12[0x1c],r11
8000576c:	5e fd       	retal	0
8000576e:	d7 03       	nop

80005770 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005770:	eb cd 40 e0 	pushm	r5-r7,lr
80005774:	18 96       	mov	r6,r12
80005776:	16 95       	mov	r5,r11
80005778:	e0 67 27 0f 	mov	r7,9999
8000577c:	c0 68       	rjmp	80005788 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000577e:	58 07       	cp.w	r7,0
80005780:	c0 31       	brne	80005786 <usart_putchar+0x16>
80005782:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005786:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005788:	0a 9b       	mov	r11,r5
8000578a:	0c 9c       	mov	r12,r6
8000578c:	f0 1f 00 03 	mcall	80005798 <usart_putchar+0x28>
80005790:	cf 71       	brne	8000577e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005792:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005796:	00 00       	add	r0,r0
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	57 5a       	stdsp	sp[0x1d4],r10

8000579c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000579c:	78 58       	ld.w	r8,r12[0x14]
8000579e:	e2 18 00 e0 	andl	r8,0xe0,COH
800057a2:	c0 30       	breq	800057a8 <usart_read_char+0xc>
800057a4:	30 4c       	mov	r12,4
800057a6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800057a8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800057aa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800057ae:	c0 31       	brne	800057b4 <usart_read_char+0x18>
800057b0:	30 3c       	mov	r12,3
800057b2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800057b4:	78 68       	ld.w	r8,r12[0x18]
800057b6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800057ba:	97 08       	st.w	r11[0x0],r8
800057bc:	5e fd       	retal	0
800057be:	d7 03       	nop

800057c0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800057c0:	eb cd 40 c0 	pushm	r6-r7,lr
800057c4:	20 1d       	sub	sp,4
800057c6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800057c8:	1a 97       	mov	r7,sp
800057ca:	1a 9b       	mov	r11,sp
800057cc:	0c 9c       	mov	r12,r6
800057ce:	f0 1f 00 07 	mcall	800057e8 <usart_getchar+0x28>
800057d2:	58 3c       	cp.w	r12,3
800057d4:	cf b0       	breq	800057ca <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800057d6:	58 4c       	cp.w	r12,4
800057d8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800057dc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800057e0:	2f fd       	sub	sp,-4
800057e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057e6:	00 00       	add	r0,r0
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	57 9c       	stdsp	sp[0x1e4],r12

800057ec <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800057ec:	eb cd 40 c0 	pushm	r6-r7,lr
800057f0:	18 96       	mov	r6,r12
800057f2:	16 97       	mov	r7,r11
  while (*string != '\0')
800057f4:	17 8b       	ld.ub	r11,r11[0x0]
800057f6:	58 0b       	cp.w	r11,0
800057f8:	c0 80       	breq	80005808 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800057fa:	2f f7       	sub	r7,-1
800057fc:	0c 9c       	mov	r12,r6
800057fe:	f0 1f 00 04 	mcall	8000580c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005802:	0f 8b       	ld.ub	r11,r7[0x0]
80005804:	58 0b       	cp.w	r11,0
80005806:	cf a1       	brne	800057fa <usart_write_line+0xe>
80005808:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	57 70       	stdsp	sp[0x1dc],r0

80005810 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005810:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005814:	e6 18 00 01 	andh	r8,0x1,COH
80005818:	c0 71       	brne	80005826 <usart_reset+0x16>
8000581a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000581c:	3f f8       	mov	r8,-1
8000581e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005820:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005822:	d5 03       	csrf	0x10
80005824:	c0 48       	rjmp	8000582c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005826:	3f f8       	mov	r8,-1
80005828:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000582a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000582c:	30 08       	mov	r8,0
8000582e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005830:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005832:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005834:	ea 68 61 0c 	mov	r8,680204
80005838:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000583a:	5e fc       	retal	r12

8000583c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000583c:	eb cd 40 e0 	pushm	r5-r7,lr
80005840:	18 96       	mov	r6,r12
80005842:	16 97       	mov	r7,r11
80005844:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005846:	f0 1f 00 2f 	mcall	80005900 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000584a:	58 07       	cp.w	r7,0
8000584c:	c5 80       	breq	800058fc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000584e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005850:	30 49       	mov	r9,4
80005852:	f2 08 18 00 	cp.b	r8,r9
80005856:	e0 88 00 53 	brls	800058fc <usart_init_rs232+0xc0>
8000585a:	30 99       	mov	r9,9
8000585c:	f2 08 18 00 	cp.b	r8,r9
80005860:	e0 8b 00 4e 	brhi	800058fc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005864:	0f d9       	ld.ub	r9,r7[0x5]
80005866:	30 78       	mov	r8,7
80005868:	f0 09 18 00 	cp.b	r9,r8
8000586c:	e0 8b 00 48 	brhi	800058fc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005870:	8e 39       	ld.sh	r9,r7[0x6]
80005872:	e0 68 01 01 	mov	r8,257
80005876:	f0 09 19 00 	cp.h	r9,r8
8000587a:	e0 8b 00 41 	brhi	800058fc <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000587e:	ef 39 00 08 	ld.ub	r9,r7[8]
80005882:	30 38       	mov	r8,3
80005884:	f0 09 18 00 	cp.b	r9,r8
80005888:	e0 8b 00 3a 	brhi	800058fc <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000588c:	0a 9a       	mov	r10,r5
8000588e:	6e 0b       	ld.w	r11,r7[0x0]
80005890:	0c 9c       	mov	r12,r6
80005892:	f0 1f 00 1d 	mcall	80005904 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005896:	58 1c       	cp.w	r12,1
80005898:	c3 20       	breq	800058fc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000589a:	0f c8       	ld.ub	r8,r7[0x4]
8000589c:	30 99       	mov	r9,9
8000589e:	f2 08 18 00 	cp.b	r8,r9
800058a2:	c0 51       	brne	800058ac <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800058a4:	6c 18       	ld.w	r8,r6[0x4]
800058a6:	b1 b8       	sbr	r8,0x11
800058a8:	8d 18       	st.w	r6[0x4],r8
800058aa:	c0 68       	rjmp	800058b6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800058ac:	6c 19       	ld.w	r9,r6[0x4]
800058ae:	20 58       	sub	r8,5
800058b0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800058b4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800058b6:	6c 19       	ld.w	r9,r6[0x4]
800058b8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800058bc:	0f d8       	ld.ub	r8,r7[0x5]
800058be:	a9 78       	lsl	r8,0x9
800058c0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800058c4:	12 48       	or	r8,r9
800058c6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800058c8:	8e 38       	ld.sh	r8,r7[0x6]
800058ca:	30 29       	mov	r9,2
800058cc:	f2 08 19 00 	cp.h	r8,r9
800058d0:	e0 88 00 09 	brls	800058e2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800058d4:	6c 18       	ld.w	r8,r6[0x4]
800058d6:	ad b8       	sbr	r8,0xd
800058d8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800058da:	8e b8       	ld.uh	r8,r7[0x6]
800058dc:	20 28       	sub	r8,2
800058de:	8d a8       	st.w	r6[0x28],r8
800058e0:	c0 68       	rjmp	800058ec <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800058e2:	6c 19       	ld.w	r9,r6[0x4]
800058e4:	5c 78       	castu.h	r8
800058e6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800058ea:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800058ec:	6c 18       	ld.w	r8,r6[0x4]
800058ee:	e0 18 ff f0 	andl	r8,0xfff0
800058f2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800058f4:	35 08       	mov	r8,80
800058f6:	8d 08       	st.w	r6[0x0],r8
800058f8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800058fc:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	58 10       	cp.w	r0,1
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	57 00       	stdsp	sp[0x1c0],r0

80005908 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005908:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000590c:	fe c0 8f 0c 	sub	r0,pc,-28916

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005910:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005914:	d5 53       	csrf	0x15
  cp      r0, r1
80005916:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005918:	e0 61 0a 30 	mov	r1,2608
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000591c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000591e:	c0 62       	brcc	8000592a <idata_load_loop_end>
  cp      r0, r1
80005920:	48 92       	lddpc	r2,80005944 <udata_clear_loop_end+0x4>

80005922 <idata_load_loop>:
  brlo    idata_load_loop
80005922:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005924:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005926:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005928:	cf d3       	brcs	80005922 <idata_load_loop>

8000592a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000592a:	e0 60 0a 30 	mov	r0,2608
  mov     r2, 0
  mov     r3, 0
8000592e:	e0 61 51 18 	mov	r1,20760
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005932:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005934:	c0 62       	brcc	80005940 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005936:	30 02       	mov	r2,0
80005938:	30 03       	mov	r3,0

8000593a <udata_clear_loop>:
8000593a:	a1 22       	st.d	r0++,r2
8000593c:	02 30       	cp.w	r0,r1
8000593e:	cf e3       	brcs	8000593a <udata_clear_loop>

80005940 <udata_clear_loop_end>:
80005940:	fe cf e9 c4 	sub	pc,pc,-5692
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	dd 58       	*unknown*

80005948 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005948:	f8 c8 ff f8 	sub	r8,r12,-8
8000594c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000594e:	3f f9       	mov	r9,-1
80005950:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005952:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005954:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005956:	30 08       	mov	r8,0
80005958:	99 08       	st.w	r12[0x0],r8
}
8000595a:	5e fc       	retal	r12

8000595c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000595c:	30 08       	mov	r8,0
8000595e:	99 48       	st.w	r12[0x10],r8
}
80005960:	5e fc       	retal	r12

80005962 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005962:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005964:	70 19       	ld.w	r9,r8[0x4]
80005966:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005968:	78 19       	ld.w	r9,r12[0x4]
8000596a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000596c:	70 19       	ld.w	r9,r8[0x4]
8000596e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005970:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005972:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005974:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005976:	78 08       	ld.w	r8,r12[0x0]
80005978:	2f f8       	sub	r8,-1
8000597a:	99 08       	st.w	r12[0x0],r8
}
8000597c:	5e fc       	retal	r12

8000597e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000597e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005980:	5b fa       	cp.w	r10,-1
80005982:	c0 31       	brne	80005988 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005984:	78 48       	ld.w	r8,r12[0x10]
80005986:	c0 c8       	rjmp	8000599e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005988:	f8 c8 ff f8 	sub	r8,r12,-8
8000598c:	70 19       	ld.w	r9,r8[0x4]
8000598e:	72 09       	ld.w	r9,r9[0x0]
80005990:	12 3a       	cp.w	r10,r9
80005992:	c0 63       	brcs	8000599e <vListInsert+0x20>
80005994:	70 18       	ld.w	r8,r8[0x4]
80005996:	70 19       	ld.w	r9,r8[0x4]
80005998:	72 09       	ld.w	r9,r9[0x0]
8000599a:	12 3a       	cp.w	r10,r9
8000599c:	cf c2       	brcc	80005994 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000599e:	70 19       	ld.w	r9,r8[0x4]
800059a0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800059a2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800059a4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800059a6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800059a8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800059aa:	78 08       	ld.w	r8,r12[0x0]
800059ac:	2f f8       	sub	r8,-1
800059ae:	99 08       	st.w	r12[0x0],r8
}
800059b0:	5e fc       	retal	r12

800059b2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800059b2:	78 18       	ld.w	r8,r12[0x4]
800059b4:	78 29       	ld.w	r9,r12[0x8]
800059b6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800059b8:	78 28       	ld.w	r8,r12[0x8]
800059ba:	78 19       	ld.w	r9,r12[0x4]
800059bc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800059be:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800059c0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800059c2:	18 39       	cp.w	r9,r12
800059c4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800059c8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800059cc:	30 09       	mov	r9,0
800059ce:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800059d0:	70 09       	ld.w	r9,r8[0x0]
800059d2:	20 19       	sub	r9,1
800059d4:	91 09       	st.w	r8[0x0],r9
}
800059d6:	5e fc       	retal	r12

800059d8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800059d8:	e0 68 08 08 	mov	r8,2056
800059dc:	ea 18 08 08 	orh	r8,0x808
800059e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800059e2:	e0 68 09 09 	mov	r8,2313
800059e6:	ea 18 09 09 	orh	r8,0x909
800059ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800059ec:	e0 68 0a 0a 	mov	r8,2570
800059f0:	ea 18 0a 0a 	orh	r8,0xa0a
800059f4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800059f6:	e0 68 0b 0b 	mov	r8,2827
800059fa:	ea 18 0b 0b 	orh	r8,0xb0b
800059fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005a00:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005a02:	e0 68 be ef 	mov	r8,48879
80005a06:	ea 18 de ad 	orh	r8,0xdead
80005a0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005a0c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005a0e:	fc 18 00 40 	movh	r8,0x40
80005a12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005a14:	e0 68 00 ff 	mov	r8,255
80005a18:	ea 18 ff 00 	orh	r8,0xff00
80005a1c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005a1e:	e0 68 01 01 	mov	r8,257
80005a22:	ea 18 01 01 	orh	r8,0x101
80005a26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005a28:	e0 68 02 02 	mov	r8,514
80005a2c:	ea 18 02 02 	orh	r8,0x202
80005a30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005a32:	e0 68 03 03 	mov	r8,771
80005a36:	ea 18 03 03 	orh	r8,0x303
80005a3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005a3c:	e0 68 04 04 	mov	r8,1028
80005a40:	ea 18 04 04 	orh	r8,0x404
80005a44:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005a46:	e0 68 05 05 	mov	r8,1285
80005a4a:	ea 18 05 05 	orh	r8,0x505
80005a4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005a50:	e0 68 06 06 	mov	r8,1542
80005a54:	ea 18 06 06 	orh	r8,0x606
80005a58:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005a5a:	e0 68 07 07 	mov	r8,1799
80005a5e:	ea 18 07 07 	orh	r8,0x707
80005a62:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005a64:	30 08       	mov	r8,0
80005a66:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005a68:	5e fc       	retal	r12
80005a6a:	d7 03       	nop

80005a6c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005a6c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005a6e:	48 38       	lddpc	r8,80005a78 <vPortEnterCritical+0xc>
80005a70:	70 09       	ld.w	r9,r8[0x0]
80005a72:	2f f9       	sub	r9,-1
80005a74:	91 09       	st.w	r8[0x0],r9
}
80005a76:	5e fc       	retal	r12
80005a78:	00 00       	add	r0,r0
80005a7a:	05 24       	ld.uh	r4,r2++

80005a7c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005a7c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005a7e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005a80:	30 0a       	mov	r10,0
80005a82:	14 9b       	mov	r11,r10
80005a84:	49 2c       	lddpc	r12,80005acc <xPortStartScheduler+0x50>
80005a86:	f0 1f 00 13 	mcall	80005ad0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005a8a:	e0 68 5d c0 	mov	r8,24000
80005a8e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005a92:	30 08       	mov	r8,0
80005a94:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005a98:	e0 68 0c cc 	mov	r8,3276
80005a9c:	ea 18 00 00 	orh	r8,0x0
80005aa0:	70 00       	ld.w	r0,r8[0x0]
80005aa2:	60 0d       	ld.w	sp,r0[0x0]
80005aa4:	1b 00       	ld.w	r0,sp++
80005aa6:	e0 68 05 24 	mov	r8,1316
80005aaa:	ea 18 00 00 	orh	r8,0x0
80005aae:	91 00       	st.w	r8[0x0],r0
80005ab0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ab4:	2f ed       	sub	sp,-8
80005ab6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005aba:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005abe:	e3 b0 00 00 	mtsr	0x0,r0
80005ac2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005ac6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005aca:	d8 0a       	popm	pc,r12=0
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	5b 98       	cp.w	r8,-7
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	53 8c       	stdsp	sp[0xe0],r12

80005ad4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005ad4:	20 6d       	sub	sp,24
80005ad6:	eb cd 00 ff 	pushm	r0-r7
80005ada:	fa c7 ff c0 	sub	r7,sp,-64
80005ade:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005ae2:	ef 40 ff e0 	st.w	r7[-32],r0
80005ae6:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005aea:	ef 40 ff e4 	st.w	r7[-28],r0
80005aee:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005af2:	e0 68 05 24 	mov	r8,1316
80005af6:	ea 18 00 00 	orh	r8,0x0
80005afa:	70 00       	ld.w	r0,r8[0x0]
80005afc:	1a d0       	st.w	--sp,r0
80005afe:	f0 1f 00 1a 	mcall	80005b64 <LABEL_RET_SCALL_263+0x14>
80005b02:	e0 68 0c cc 	mov	r8,3276
80005b06:	ea 18 00 00 	orh	r8,0x0
80005b0a:	70 00       	ld.w	r0,r8[0x0]
80005b0c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005b0e:	f0 1f 00 17 	mcall	80005b68 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005b12:	e0 68 0c cc 	mov	r8,3276
80005b16:	ea 18 00 00 	orh	r8,0x0
80005b1a:	70 00       	ld.w	r0,r8[0x0]
80005b1c:	60 0d       	ld.w	sp,r0[0x0]
80005b1e:	1b 00       	ld.w	r0,sp++
80005b20:	e0 68 05 24 	mov	r8,1316
80005b24:	ea 18 00 00 	orh	r8,0x0
80005b28:	91 00       	st.w	r8[0x0],r0
80005b2a:	fa c7 ff d8 	sub	r7,sp,-40
80005b2e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005b32:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005b36:	e0 61 05 24 	mov	r1,1316
80005b3a:	ea 11 00 00 	orh	r1,0x0
80005b3e:	62 02       	ld.w	r2,r1[0x0]
80005b40:	58 02       	cp.w	r2,0
80005b42:	c0 70       	breq	80005b50 <LABEL_RET_SCALL_263>
80005b44:	e4 c2 00 01 	sub	r2,r2,1
80005b48:	83 02       	st.w	r1[0x0],r2
80005b4a:	58 02       	cp.w	r2,0
80005b4c:	c0 21       	brne	80005b50 <LABEL_RET_SCALL_263>
80005b4e:	b1 c0       	cbr	r0,0x10

80005b50 <LABEL_RET_SCALL_263>:
80005b50:	ef 40 ff f8 	st.w	r7[-8],r0
80005b54:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005b58:	ef 40 ff fc 	st.w	r7[-4],r0
80005b5c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005b60:	2f ad       	sub	sp,-24
80005b62:	d6 13       	rets
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	5a 6c       	cp.w	r12,-26
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	61 b0       	ld.w	r0,r0[0x6c]

80005b6c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005b6c:	e1 b8 00 43 	mfsr	r8,0x10c
80005b70:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005b74:	5e fc       	retal	r12
80005b76:	d7 03       	nop

80005b78 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005b78:	48 78       	lddpc	r8,80005b94 <vPortExitCritical+0x1c>
80005b7a:	70 08       	ld.w	r8,r8[0x0]
80005b7c:	58 08       	cp.w	r8,0
80005b7e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005b80:	48 58       	lddpc	r8,80005b94 <vPortExitCritical+0x1c>
80005b82:	70 09       	ld.w	r9,r8[0x0]
80005b84:	20 19       	sub	r9,1
80005b86:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005b88:	70 08       	ld.w	r8,r8[0x0]
80005b8a:	58 08       	cp.w	r8,0
80005b8c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005b8e:	d5 03       	csrf	0x10
80005b90:	5e fc       	retal	r12
80005b92:	00 00       	add	r0,r0
80005b94:	00 00       	add	r0,r0
80005b96:	05 24       	ld.uh	r4,r2++

80005b98 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005b98:	eb cd 00 ff 	pushm	r0-r7
80005b9c:	e0 68 05 24 	mov	r8,1316
80005ba0:	ea 18 00 00 	orh	r8,0x0
80005ba4:	70 00       	ld.w	r0,r8[0x0]
80005ba6:	1a d0       	st.w	--sp,r0
80005ba8:	7a 90       	ld.w	r0,sp[0x24]
80005baa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005bae:	58 10       	cp.w	r0,1
80005bb0:	e0 8b 00 08 	brhi	80005bc0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005bb4:	e0 68 0c cc 	mov	r8,3276
80005bb8:	ea 18 00 00 	orh	r8,0x0
80005bbc:	70 00       	ld.w	r0,r8[0x0]
80005bbe:	81 0d       	st.w	r0[0x0],sp

80005bc0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005bc0:	f0 1f 00 12 	mcall	80005c08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005bc4:	f0 1f 00 12 	mcall	80005c0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005bc8:	f0 1f 00 12 	mcall	80005c10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005bcc:	f0 1f 00 12 	mcall	80005c14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005bd0:	7a 90       	ld.w	r0,sp[0x24]
80005bd2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005bd6:	58 10       	cp.w	r0,1
80005bd8:	e0 8b 00 0e 	brhi	80005bf4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005bdc:	f0 1f 00 0c 	mcall	80005c0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005be0:	f0 1f 00 0e 	mcall	80005c18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005be4:	f0 1f 00 0c 	mcall	80005c14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005be8:	e0 68 0c cc 	mov	r8,3276
80005bec:	ea 18 00 00 	orh	r8,0x0
80005bf0:	70 00       	ld.w	r0,r8[0x0]
80005bf2:	60 0d       	ld.w	sp,r0[0x0]

80005bf4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005bf4:	1b 00       	ld.w	r0,sp++
80005bf6:	e0 68 05 24 	mov	r8,1316
80005bfa:	ea 18 00 00 	orh	r8,0x0
80005bfe:	91 00       	st.w	r8[0x0],r0
80005c00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c04:	d6 03       	rete
80005c06:	00 00       	add	r0,r0
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	5b 6c       	cp.w	r12,-10
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	5a 6c       	cp.w	r12,-26
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	63 b4       	ld.w	r4,r1[0x6c]
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	5b 78       	cp.w	r8,-9
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	61 b0       	ld.w	r0,r0[0x6c]

80005c1c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005c1c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005c1e:	f0 1f 00 02 	mcall	80005c24 <__malloc_lock+0x8>
}
80005c22:	d8 02       	popm	pc
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	61 a0       	ld.w	r0,r0[0x68]

80005c28 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005c28:	d4 01       	pushm	lr
	xTaskResumeAll();
80005c2a:	f0 1f 00 02 	mcall	80005c30 <__malloc_unlock+0x8>
}
80005c2e:	d8 02       	popm	pc
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	65 5c       	ld.w	r12,r2[0x54]

80005c34 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005c34:	d4 21       	pushm	r4-r7,lr
80005c36:	16 95       	mov	r5,r11
80005c38:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005c3a:	58 0c       	cp.w	r12,0
80005c3c:	c0 30       	breq	80005c42 <_read+0xe>
80005c3e:	3f f7       	mov	r7,-1
80005c40:	c1 48       	rjmp	80005c68 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005c42:	58 0a       	cp.w	r10,0
80005c44:	e0 89 00 04 	brgt	80005c4c <_read+0x18>
80005c48:	30 07       	mov	r7,0
80005c4a:	c0 f8       	rjmp	80005c68 <_read+0x34>
80005c4c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005c4e:	48 84       	lddpc	r4,80005c6c <_read+0x38>
80005c50:	68 0c       	ld.w	r12,r4[0x0]
80005c52:	f0 1f 00 08 	mcall	80005c70 <_read+0x3c>
    if (c < 0)
80005c56:	c0 95       	brlt	80005c68 <_read+0x34>
      break;

    *ptr++ = c;
80005c58:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005c5c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005c5e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005c62:	58 08       	cp.w	r8,0
80005c64:	fe 99 ff f6 	brgt	80005c50 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005c68:	0e 9c       	mov	r12,r7
80005c6a:	d8 22       	popm	r4-r7,pc
80005c6c:	00 00       	add	r0,r0
80005c6e:	51 0c       	stdsp	sp[0x40],r12
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	57 c0       	stdsp	sp[0x1f0],r0

80005c74 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005c74:	d4 21       	pushm	r4-r7,lr
80005c76:	16 95       	mov	r5,r11
80005c78:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005c7a:	20 1c       	sub	r12,1
80005c7c:	58 2c       	cp.w	r12,2
80005c7e:	e0 8b 00 12 	brhi	80005ca2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005c82:	58 0a       	cp.w	r10,0
80005c84:	c0 31       	brne	80005c8a <_write+0x16>
80005c86:	30 07       	mov	r7,0
80005c88:	c0 e8       	rjmp	80005ca4 <_write+0x30>
80005c8a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005c8c:	48 74       	lddpc	r4,80005ca8 <_write+0x34>
80005c8e:	68 0c       	ld.w	r12,r4[0x0]
80005c90:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005c94:	f0 1f 00 06 	mcall	80005cac <_write+0x38>
80005c98:	c0 55       	brlt	80005ca2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005c9a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005c9c:	0e 36       	cp.w	r6,r7
80005c9e:	cf 81       	brne	80005c8e <_write+0x1a>
80005ca0:	c0 28       	rjmp	80005ca4 <_write+0x30>
80005ca2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005ca4:	0e 9c       	mov	r12,r7
80005ca6:	d8 22       	popm	r4-r7,pc
80005ca8:	00 00       	add	r0,r0
80005caa:	51 0c       	stdsp	sp[0x40],r12
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	57 70       	stdsp	sp[0x1dc],r0

80005cb0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005cb0:	eb cd 40 80 	pushm	r7,lr
80005cb4:	18 97       	mov	r7,r12
	if( pv )
80005cb6:	58 0c       	cp.w	r12,0
80005cb8:	c0 80       	breq	80005cc8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005cba:	f0 1f 00 05 	mcall	80005ccc <vPortFree+0x1c>
		{
			free( pv );
80005cbe:	0e 9c       	mov	r12,r7
80005cc0:	f0 1f 00 04 	mcall	80005cd0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005cc4:	f0 1f 00 04 	mcall	80005cd4 <vPortFree+0x24>
80005cc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ccc:	80 00       	ld.sh	r0,r0[0x0]
80005cce:	61 a0       	ld.w	r0,r0[0x68]
80005cd0:	80 00       	ld.sh	r0,r0[0x0]
80005cd2:	70 00       	ld.w	r0,r8[0x0]
80005cd4:	80 00       	ld.sh	r0,r0[0x0]
80005cd6:	65 5c       	ld.w	r12,r2[0x54]

80005cd8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005cd8:	eb cd 40 80 	pushm	r7,lr
80005cdc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005cde:	f0 1f 00 06 	mcall	80005cf4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005ce2:	0e 9c       	mov	r12,r7
80005ce4:	f0 1f 00 05 	mcall	80005cf8 <pvPortMalloc+0x20>
80005ce8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005cea:	f0 1f 00 05 	mcall	80005cfc <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005cee:	0e 9c       	mov	r12,r7
80005cf0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cf4:	80 00       	ld.sh	r0,r0[0x0]
80005cf6:	61 a0       	ld.w	r0,r0[0x68]
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	70 10       	ld.w	r0,r8[0x4]
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	65 5c       	ld.w	r12,r2[0x54]

80005d00 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005d00:	d4 01       	pushm	lr
80005d02:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005d04:	78 09       	ld.w	r9,r12[0x0]
80005d06:	58 09       	cp.w	r9,0
80005d08:	c1 10       	breq	80005d2a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005d0a:	78 3a       	ld.w	r10,r12[0xc]
80005d0c:	79 09       	ld.w	r9,r12[0x40]
80005d0e:	f4 09 00 09 	add	r9,r10,r9
80005d12:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005d14:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005d16:	14 39       	cp.w	r9,r10
80005d18:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005d1c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005d20:	79 0a       	ld.w	r10,r12[0x40]
80005d22:	78 3b       	ld.w	r11,r12[0xc]
80005d24:	10 9c       	mov	r12,r8
80005d26:	f0 1f 00 02 	mcall	80005d2c <prvCopyDataFromQueue+0x2c>
80005d2a:	d8 02       	popm	pc
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	74 58       	ld.w	r8,r10[0x14]

80005d30 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005d30:	eb cd 40 c0 	pushm	r6-r7,lr
80005d34:	18 97       	mov	r7,r12
80005d36:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005d38:	78 e8       	ld.w	r8,r12[0x38]
80005d3a:	58 08       	cp.w	r8,0
80005d3c:	c0 31       	brne	80005d42 <xQueueReceiveFromISR+0x12>
80005d3e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005d42:	f0 1f 00 0e 	mcall	80005d78 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005d46:	6e e8       	ld.w	r8,r7[0x38]
80005d48:	20 18       	sub	r8,1
80005d4a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005d4c:	6f 18       	ld.w	r8,r7[0x44]
80005d4e:	5b f8       	cp.w	r8,-1
80005d50:	c0 d1       	brne	80005d6a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005d52:	6e 48       	ld.w	r8,r7[0x10]
80005d54:	58 08       	cp.w	r8,0
80005d56:	c0 f0       	breq	80005d74 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005d58:	ee cc ff f0 	sub	r12,r7,-16
80005d5c:	f0 1f 00 08 	mcall	80005d7c <xQueueReceiveFromISR+0x4c>
80005d60:	c0 a0       	breq	80005d74 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005d62:	30 1c       	mov	r12,1
80005d64:	8d 0c       	st.w	r6[0x0],r12
80005d66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005d6a:	2f f8       	sub	r8,-1
80005d6c:	ef 48 00 44 	st.w	r7[68],r8
80005d70:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005d74:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	5d 00       	ror	r0
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	63 38       	ld.w	r8,r1[0x4c]

80005d80 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005d80:	eb cd 40 c0 	pushm	r6-r7,lr
80005d84:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005d86:	f0 1f 00 23 	mcall	80005e10 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005d8a:	6f 28       	ld.w	r8,r7[0x48]
80005d8c:	58 08       	cp.w	r8,0
80005d8e:	e0 8a 00 18 	brle	80005dbe <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005d92:	6e 98       	ld.w	r8,r7[0x24]
80005d94:	58 08       	cp.w	r8,0
80005d96:	c1 40       	breq	80005dbe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005d98:	ee c6 ff dc 	sub	r6,r7,-36
80005d9c:	c0 48       	rjmp	80005da4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005d9e:	6e 98       	ld.w	r8,r7[0x24]
80005da0:	58 08       	cp.w	r8,0
80005da2:	c0 e0       	breq	80005dbe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005da4:	0c 9c       	mov	r12,r6
80005da6:	f0 1f 00 1c 	mcall	80005e14 <prvUnlockQueue+0x94>
80005daa:	c0 30       	breq	80005db0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005dac:	f0 1f 00 1b 	mcall	80005e18 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005db0:	6f 28       	ld.w	r8,r7[0x48]
80005db2:	20 18       	sub	r8,1
80005db4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005db8:	58 08       	cp.w	r8,0
80005dba:	fe 99 ff f2 	brgt	80005d9e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005dbe:	3f f8       	mov	r8,-1
80005dc0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005dc4:	f0 1f 00 16 	mcall	80005e1c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005dc8:	f0 1f 00 12 	mcall	80005e10 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005dcc:	6f 18       	ld.w	r8,r7[0x44]
80005dce:	58 08       	cp.w	r8,0
80005dd0:	e0 8a 00 18 	brle	80005e00 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005dd4:	6e 48       	ld.w	r8,r7[0x10]
80005dd6:	58 08       	cp.w	r8,0
80005dd8:	c1 40       	breq	80005e00 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005dda:	ee c6 ff f0 	sub	r6,r7,-16
80005dde:	c0 48       	rjmp	80005de6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005de0:	6e 48       	ld.w	r8,r7[0x10]
80005de2:	58 08       	cp.w	r8,0
80005de4:	c0 e0       	breq	80005e00 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005de6:	0c 9c       	mov	r12,r6
80005de8:	f0 1f 00 0b 	mcall	80005e14 <prvUnlockQueue+0x94>
80005dec:	c0 30       	breq	80005df2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005dee:	f0 1f 00 0b 	mcall	80005e18 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005df2:	6f 18       	ld.w	r8,r7[0x44]
80005df4:	20 18       	sub	r8,1
80005df6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005dfa:	58 08       	cp.w	r8,0
80005dfc:	fe 99 ff f2 	brgt	80005de0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005e00:	3f f8       	mov	r8,-1
80005e02:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005e06:	f0 1f 00 06 	mcall	80005e1c <prvUnlockQueue+0x9c>
}
80005e0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e0e:	00 00       	add	r0,r0
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	5a 6c       	cp.w	r12,-26
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	63 38       	ld.w	r8,r1[0x4c]
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	62 44       	ld.w	r4,r1[0x10]
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	5b 78       	cp.w	r8,-9

80005e20 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005e20:	d4 31       	pushm	r0-r7,lr
80005e22:	20 5d       	sub	sp,20
80005e24:	18 97       	mov	r7,r12
80005e26:	50 0b       	stdsp	sp[0x0],r11
80005e28:	50 2a       	stdsp	sp[0x8],r10
80005e2a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005e2c:	f8 c2 ff dc 	sub	r2,r12,-36
80005e30:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e32:	fa c4 ff f4 	sub	r4,sp,-12
80005e36:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e38:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e3a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005e3e:	f0 1f 00 3e 	mcall	80005f34 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e42:	6e e8       	ld.w	r8,r7[0x38]
80005e44:	58 08       	cp.w	r8,0
80005e46:	c2 a0       	breq	80005e9a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005e48:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e4a:	40 0b       	lddsp	r11,sp[0x0]
80005e4c:	0e 9c       	mov	r12,r7
80005e4e:	f0 1f 00 3b 	mcall	80005f38 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005e52:	40 18       	lddsp	r8,sp[0x4]
80005e54:	58 08       	cp.w	r8,0
80005e56:	c1 51       	brne	80005e80 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005e58:	6e e8       	ld.w	r8,r7[0x38]
80005e5a:	20 18       	sub	r8,1
80005e5c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005e5e:	6e 08       	ld.w	r8,r7[0x0]
80005e60:	58 08       	cp.w	r8,0
80005e62:	c0 41       	brne	80005e6a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005e64:	f0 1f 00 36 	mcall	80005f3c <xQueueGenericReceive+0x11c>
80005e68:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e6a:	6e 48       	ld.w	r8,r7[0x10]
80005e6c:	58 08       	cp.w	r8,0
80005e6e:	c1 20       	breq	80005e92 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005e70:	ee cc ff f0 	sub	r12,r7,-16
80005e74:	f0 1f 00 33 	mcall	80005f40 <xQueueGenericReceive+0x120>
80005e78:	58 1c       	cp.w	r12,1
80005e7a:	c0 c1       	brne	80005e92 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005e7c:	d7 33       	scall
80005e7e:	c0 a8       	rjmp	80005e92 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005e80:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e82:	6e 98       	ld.w	r8,r7[0x24]
80005e84:	58 08       	cp.w	r8,0
80005e86:	c0 60       	breq	80005e92 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005e88:	04 9c       	mov	r12,r2
80005e8a:	f0 1f 00 2e 	mcall	80005f40 <xQueueGenericReceive+0x120>
80005e8e:	c0 20       	breq	80005e92 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005e90:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005e92:	f0 1f 00 2d 	mcall	80005f44 <xQueueGenericReceive+0x124>
80005e96:	30 1c       	mov	r12,1
				return pdPASS;
80005e98:	c4 c8       	rjmp	80005f30 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e9a:	40 28       	lddsp	r8,sp[0x8]
80005e9c:	58 08       	cp.w	r8,0
80005e9e:	c0 51       	brne	80005ea8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005ea0:	f0 1f 00 29 	mcall	80005f44 <xQueueGenericReceive+0x124>
80005ea4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005ea6:	c4 58       	rjmp	80005f30 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005ea8:	58 05       	cp.w	r5,0
80005eaa:	c0 51       	brne	80005eb4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005eac:	08 9c       	mov	r12,r4
80005eae:	f0 1f 00 27 	mcall	80005f48 <xQueueGenericReceive+0x128>
80005eb2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005eb4:	f0 1f 00 24 	mcall	80005f44 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005eb8:	f0 1f 00 25 	mcall	80005f4c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005ebc:	f0 1f 00 1e 	mcall	80005f34 <xQueueGenericReceive+0x114>
80005ec0:	6f 18       	ld.w	r8,r7[0x44]
80005ec2:	5b f8       	cp.w	r8,-1
80005ec4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ec8:	6f 28       	ld.w	r8,r7[0x48]
80005eca:	5b f8       	cp.w	r8,-1
80005ecc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ed0:	f0 1f 00 1d 	mcall	80005f44 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ed4:	06 9b       	mov	r11,r3
80005ed6:	08 9c       	mov	r12,r4
80005ed8:	f0 1f 00 1e 	mcall	80005f50 <xQueueGenericReceive+0x130>
80005edc:	c2 41       	brne	80005f24 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005ede:	f0 1f 00 16 	mcall	80005f34 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005ee2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005ee4:	f0 1f 00 18 	mcall	80005f44 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005ee8:	58 06       	cp.w	r6,0
80005eea:	c1 71       	brne	80005f18 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005eec:	6e 08       	ld.w	r8,r7[0x0]
80005eee:	58 08       	cp.w	r8,0
80005ef0:	c0 81       	brne	80005f00 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005ef2:	f0 1f 00 11 	mcall	80005f34 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005ef6:	6e 1c       	ld.w	r12,r7[0x4]
80005ef8:	f0 1f 00 17 	mcall	80005f54 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005efc:	f0 1f 00 12 	mcall	80005f44 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f00:	40 2b       	lddsp	r11,sp[0x8]
80005f02:	04 9c       	mov	r12,r2
80005f04:	f0 1f 00 15 	mcall	80005f58 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005f08:	0e 9c       	mov	r12,r7
80005f0a:	f0 1f 00 15 	mcall	80005f5c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005f0e:	f0 1f 00 15 	mcall	80005f60 <xQueueGenericReceive+0x140>
80005f12:	c9 61       	brne	80005e3e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005f14:	d7 33       	scall
80005f16:	c9 4b       	rjmp	80005e3e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005f18:	0e 9c       	mov	r12,r7
80005f1a:	f0 1f 00 11 	mcall	80005f5c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005f1e:	f0 1f 00 11 	mcall	80005f60 <xQueueGenericReceive+0x140>
80005f22:	c8 eb       	rjmp	80005e3e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005f24:	0e 9c       	mov	r12,r7
80005f26:	f0 1f 00 0e 	mcall	80005f5c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005f2a:	f0 1f 00 0e 	mcall	80005f60 <xQueueGenericReceive+0x140>
80005f2e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005f30:	2f bd       	sub	sp,-20
80005f32:	d8 32       	popm	r0-r7,pc
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5a 6c       	cp.w	r12,-26
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	5d 00       	ror	r0
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	62 50       	ld.w	r0,r1[0x14]
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	63 38       	ld.w	r8,r1[0x4c]
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	5b 78       	cp.w	r8,-9
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	62 2c       	ld.w	r12,r1[0x8]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	61 a0       	ld.w	r0,r0[0x68]
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	64 c8       	ld.w	r8,r2[0x30]
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	62 b4       	ld.w	r4,r1[0x2c]
80005f58:	80 00       	ld.sh	r0,r0[0x0]
80005f5a:	67 20       	ld.w	r0,r3[0x48]
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	5d 80       	*unknown*
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	65 5c       	ld.w	r12,r2[0x54]

80005f64 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005f64:	eb cd 40 80 	pushm	r7,lr
80005f68:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005f6a:	79 08       	ld.w	r8,r12[0x40]
80005f6c:	58 08       	cp.w	r8,0
80005f6e:	c0 a1       	brne	80005f82 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005f70:	78 08       	ld.w	r8,r12[0x0]
80005f72:	58 08       	cp.w	r8,0
80005f74:	c2 b1       	brne	80005fca <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005f76:	78 1c       	ld.w	r12,r12[0x4]
80005f78:	f0 1f 00 17 	mcall	80005fd4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005f7c:	30 08       	mov	r8,0
80005f7e:	8f 18       	st.w	r7[0x4],r8
80005f80:	c2 58       	rjmp	80005fca <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005f82:	58 0a       	cp.w	r10,0
80005f84:	c1 01       	brne	80005fa4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005f86:	10 9a       	mov	r10,r8
80005f88:	78 2c       	ld.w	r12,r12[0x8]
80005f8a:	f0 1f 00 14 	mcall	80005fd8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005f8e:	6e 29       	ld.w	r9,r7[0x8]
80005f90:	6f 08       	ld.w	r8,r7[0x40]
80005f92:	f2 08 00 08 	add	r8,r9,r8
80005f96:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005f98:	6e 19       	ld.w	r9,r7[0x4]
80005f9a:	12 38       	cp.w	r8,r9
80005f9c:	c1 73       	brcs	80005fca <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005f9e:	6e 08       	ld.w	r8,r7[0x0]
80005fa0:	8f 28       	st.w	r7[0x8],r8
80005fa2:	c1 48       	rjmp	80005fca <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005fa4:	10 9a       	mov	r10,r8
80005fa6:	78 3c       	ld.w	r12,r12[0xc]
80005fa8:	f0 1f 00 0c 	mcall	80005fd8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005fac:	6f 08       	ld.w	r8,r7[0x40]
80005fae:	6e 39       	ld.w	r9,r7[0xc]
80005fb0:	f2 08 01 08 	sub	r8,r9,r8
80005fb4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005fb6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005fb8:	12 38       	cp.w	r8,r9
80005fba:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005fbe:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005fc2:	f3 d8 e3 19 	subcs	r9,r9,r8
80005fc6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005fca:	6e e8       	ld.w	r8,r7[0x38]
80005fcc:	2f f8       	sub	r8,-1
80005fce:	8f e8       	st.w	r7[0x38],r8
}
80005fd0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	62 5c       	ld.w	r12,r1[0x14]
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	74 58       	ld.w	r8,r10[0x14]

80005fdc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005fdc:	eb cd 40 c0 	pushm	r6-r7,lr
80005fe0:	18 97       	mov	r7,r12
80005fe2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005fe4:	78 ec       	ld.w	r12,r12[0x38]
80005fe6:	6e f8       	ld.w	r8,r7[0x3c]
80005fe8:	10 3c       	cp.w	r12,r8
80005fea:	c0 33       	brcs	80005ff0 <xQueueGenericSendFromISR+0x14>
80005fec:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005ff0:	12 9a       	mov	r10,r9
80005ff2:	0e 9c       	mov	r12,r7
80005ff4:	f0 1f 00 0c 	mcall	80006024 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005ff8:	6f 28       	ld.w	r8,r7[0x48]
80005ffa:	5b f8       	cp.w	r8,-1
80005ffc:	c0 d1       	brne	80006016 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ffe:	6e 98       	ld.w	r8,r7[0x24]
80006000:	58 08       	cp.w	r8,0
80006002:	c0 f0       	breq	80006020 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006004:	ee cc ff dc 	sub	r12,r7,-36
80006008:	f0 1f 00 08 	mcall	80006028 <xQueueGenericSendFromISR+0x4c>
8000600c:	c0 a0       	breq	80006020 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000600e:	30 1c       	mov	r12,1
80006010:	8d 0c       	st.w	r6[0x0],r12
80006012:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006016:	2f f8       	sub	r8,-1
80006018:	ef 48 00 48 	st.w	r7[72],r8
8000601c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006020:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	5f 64       	srmi	r4
80006028:	80 00       	ld.sh	r0,r0[0x0]
8000602a:	63 38       	ld.w	r8,r1[0x4c]

8000602c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000602c:	d4 31       	pushm	r0-r7,lr
8000602e:	20 5d       	sub	sp,20
80006030:	18 97       	mov	r7,r12
80006032:	50 0b       	stdsp	sp[0x0],r11
80006034:	50 2a       	stdsp	sp[0x8],r10
80006036:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006038:	f8 c0 ff f0 	sub	r0,r12,-16
8000603c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000603e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006042:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006044:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006048:	f0 1f 00 2f 	mcall	80006104 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000604c:	6e e9       	ld.w	r9,r7[0x38]
8000604e:	6e f8       	ld.w	r8,r7[0x3c]
80006050:	10 39       	cp.w	r9,r8
80006052:	c1 42       	brcc	8000607a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006054:	40 1a       	lddsp	r10,sp[0x4]
80006056:	40 0b       	lddsp	r11,sp[0x0]
80006058:	0e 9c       	mov	r12,r7
8000605a:	f0 1f 00 2c 	mcall	80006108 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000605e:	6e 98       	ld.w	r8,r7[0x24]
80006060:	58 08       	cp.w	r8,0
80006062:	c0 80       	breq	80006072 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006064:	ee cc ff dc 	sub	r12,r7,-36
80006068:	f0 1f 00 29 	mcall	8000610c <xQueueGenericSend+0xe0>
8000606c:	58 1c       	cp.w	r12,1
8000606e:	c0 21       	brne	80006072 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006070:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006072:	f0 1f 00 28 	mcall	80006110 <xQueueGenericSend+0xe4>
80006076:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006078:	c4 38       	rjmp	800060fe <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000607a:	40 28       	lddsp	r8,sp[0x8]
8000607c:	58 08       	cp.w	r8,0
8000607e:	c0 51       	brne	80006088 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006080:	f0 1f 00 24 	mcall	80006110 <xQueueGenericSend+0xe4>
80006084:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006086:	c3 c8       	rjmp	800060fe <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006088:	58 04       	cp.w	r4,0
8000608a:	c0 51       	brne	80006094 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000608c:	06 9c       	mov	r12,r3
8000608e:	f0 1f 00 22 	mcall	80006114 <xQueueGenericSend+0xe8>
80006092:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006094:	f0 1f 00 1f 	mcall	80006110 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006098:	f0 1f 00 20 	mcall	80006118 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000609c:	f0 1f 00 1a 	mcall	80006104 <xQueueGenericSend+0xd8>
800060a0:	6f 18       	ld.w	r8,r7[0x44]
800060a2:	5b f8       	cp.w	r8,-1
800060a4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800060a8:	6f 28       	ld.w	r8,r7[0x48]
800060aa:	5b f8       	cp.w	r8,-1
800060ac:	ef f1 0a 12 	st.weq	r7[0x48],r1
800060b0:	f0 1f 00 18 	mcall	80006110 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060b4:	04 9b       	mov	r11,r2
800060b6:	06 9c       	mov	r12,r3
800060b8:	f0 1f 00 19 	mcall	8000611c <xQueueGenericSend+0xf0>
800060bc:	c1 b1       	brne	800060f2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800060be:	f0 1f 00 12 	mcall	80006104 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800060c2:	6e e5       	ld.w	r5,r7[0x38]
800060c4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800060c6:	f0 1f 00 13 	mcall	80006110 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800060ca:	0c 35       	cp.w	r5,r6
800060cc:	c0 d1       	brne	800060e6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800060ce:	40 2b       	lddsp	r11,sp[0x8]
800060d0:	00 9c       	mov	r12,r0
800060d2:	f0 1f 00 14 	mcall	80006120 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800060d6:	0e 9c       	mov	r12,r7
800060d8:	f0 1f 00 13 	mcall	80006124 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800060dc:	f0 1f 00 13 	mcall	80006128 <xQueueGenericSend+0xfc>
800060e0:	cb 41       	brne	80006048 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800060e2:	d7 33       	scall
800060e4:	cb 2b       	rjmp	80006048 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800060e6:	0e 9c       	mov	r12,r7
800060e8:	f0 1f 00 0f 	mcall	80006124 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800060ec:	f0 1f 00 0f 	mcall	80006128 <xQueueGenericSend+0xfc>
800060f0:	ca cb       	rjmp	80006048 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800060f2:	0e 9c       	mov	r12,r7
800060f4:	f0 1f 00 0c 	mcall	80006124 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800060f8:	f0 1f 00 0c 	mcall	80006128 <xQueueGenericSend+0xfc>
800060fc:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800060fe:	2f bd       	sub	sp,-20
80006100:	d8 32       	popm	r0-r7,pc
80006102:	00 00       	add	r0,r0
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	5a 6c       	cp.w	r12,-26
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	5f 64       	srmi	r4
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	63 38       	ld.w	r8,r1[0x4c]
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	5b 78       	cp.w	r8,-9
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	62 2c       	ld.w	r12,r1[0x8]
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	61 a0       	ld.w	r0,r0[0x68]
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	64 c8       	ld.w	r8,r2[0x30]
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	67 20       	ld.w	r0,r3[0x48]
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	5d 80       	*unknown*
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	65 5c       	ld.w	r12,r2[0x54]

8000612c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000612c:	d4 21       	pushm	r4-r7,lr
8000612e:	18 97       	mov	r7,r12
80006130:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006132:	58 0c       	cp.w	r12,0
80006134:	c2 f0       	breq	80006192 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006136:	34 cc       	mov	r12,76
80006138:	f0 1f 00 17 	mcall	80006194 <xQueueCreate+0x68>
8000613c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000613e:	c2 a0       	breq	80006192 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006140:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006144:	e8 cc ff ff 	sub	r12,r4,-1
80006148:	f0 1f 00 13 	mcall	80006194 <xQueueCreate+0x68>
8000614c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000614e:	c1 e0       	breq	8000618a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006150:	f8 04 00 04 	add	r4,r12,r4
80006154:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006156:	30 08       	mov	r8,0
80006158:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000615a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000615c:	ee c8 00 01 	sub	r8,r7,1
80006160:	ad 38       	mul	r8,r6
80006162:	10 0c       	add	r12,r8
80006164:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006166:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006168:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000616c:	3f f8       	mov	r8,-1
8000616e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006172:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006176:	ea cc ff f0 	sub	r12,r5,-16
8000617a:	f0 1f 00 08 	mcall	80006198 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000617e:	ea cc ff dc 	sub	r12,r5,-36
80006182:	f0 1f 00 06 	mcall	80006198 <xQueueCreate+0x6c>
80006186:	0a 9c       	mov	r12,r5
80006188:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000618a:	0a 9c       	mov	r12,r5
8000618c:	f0 1f 00 04 	mcall	8000619c <xQueueCreate+0x70>
80006190:	d8 2a       	popm	r4-r7,pc,r12=0
80006192:	d8 2a       	popm	r4-r7,pc,r12=0
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	5c d8       	com	r8
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	59 48       	cp.w	r8,20
8000619c:	80 00       	ld.sh	r0,r0[0x0]
8000619e:	5c b0       	swap.b	r0

800061a0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800061a0:	48 38       	lddpc	r8,800061ac <vTaskSuspendAll+0xc>
800061a2:	70 09       	ld.w	r9,r8[0x0]
800061a4:	2f f9       	sub	r9,-1
800061a6:	91 09       	st.w	r8[0x0],r9
}
800061a8:	5e fc       	retal	r12
800061aa:	00 00       	add	r0,r0
800061ac:	00 00       	add	r0,r0
800061ae:	0c fc       	st.b	--r6,r12

800061b0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800061b0:	49 a8       	lddpc	r8,80006218 <vTaskSwitchContext+0x68>
800061b2:	70 08       	ld.w	r8,r8[0x0]
800061b4:	58 08       	cp.w	r8,0
800061b6:	c0 b1       	brne	800061cc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800061b8:	49 98       	lddpc	r8,8000621c <vTaskSwitchContext+0x6c>
800061ba:	70 08       	ld.w	r8,r8[0x0]
800061bc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800061c0:	49 89       	lddpc	r9,80006220 <vTaskSwitchContext+0x70>
800061c2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800061c6:	58 08       	cp.w	r8,0
800061c8:	c0 60       	breq	800061d4 <vTaskSwitchContext+0x24>
800061ca:	c1 18       	rjmp	800061ec <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800061cc:	30 19       	mov	r9,1
800061ce:	49 68       	lddpc	r8,80006224 <vTaskSwitchContext+0x74>
800061d0:	91 09       	st.w	r8[0x0],r9
800061d2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800061d4:	49 28       	lddpc	r8,8000621c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800061d6:	49 3a       	lddpc	r10,80006220 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800061d8:	70 09       	ld.w	r9,r8[0x0]
800061da:	20 19       	sub	r9,1
800061dc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800061de:	70 09       	ld.w	r9,r8[0x0]
800061e0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800061e4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800061e8:	58 09       	cp.w	r9,0
800061ea:	cf 70       	breq	800061d8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800061ec:	48 c8       	lddpc	r8,8000621c <vTaskSwitchContext+0x6c>
800061ee:	70 08       	ld.w	r8,r8[0x0]
800061f0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800061f4:	48 b9       	lddpc	r9,80006220 <vTaskSwitchContext+0x70>
800061f6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800061fa:	70 19       	ld.w	r9,r8[0x4]
800061fc:	72 19       	ld.w	r9,r9[0x4]
800061fe:	91 19       	st.w	r8[0x4],r9
80006200:	f0 ca ff f8 	sub	r10,r8,-8
80006204:	14 39       	cp.w	r9,r10
80006206:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000620a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000620e:	70 18       	ld.w	r8,r8[0x4]
80006210:	70 39       	ld.w	r9,r8[0xc]
80006212:	48 68       	lddpc	r8,80006228 <vTaskSwitchContext+0x78>
80006214:	91 09       	st.w	r8[0x0],r9
80006216:	5e fc       	retal	r12
80006218:	00 00       	add	r0,r0
8000621a:	0c fc       	st.b	--r6,r12
8000621c:	00 00       	add	r0,r0
8000621e:	0d 34       	ld.ub	r4,r6++
80006220:	00 00       	add	r0,r0
80006222:	0c 18       	sub	r8,r6
80006224:	00 00       	add	r0,r0
80006226:	0d 1c       	ld.sh	r12,r6++
80006228:	00 00       	add	r0,r0
8000622a:	0c cc       	st.b	r6++,r12

8000622c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000622c:	48 48       	lddpc	r8,8000623c <vTaskSetTimeOutState+0x10>
8000622e:	70 08       	ld.w	r8,r8[0x0]
80006230:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006232:	48 48       	lddpc	r8,80006240 <vTaskSetTimeOutState+0x14>
80006234:	70 08       	ld.w	r8,r8[0x0]
80006236:	99 18       	st.w	r12[0x4],r8
}
80006238:	5e fc       	retal	r12
8000623a:	00 00       	add	r0,r0
8000623c:	00 00       	add	r0,r0
8000623e:	0c 10       	sub	r0,r6
80006240:	00 00       	add	r0,r0
80006242:	0c f8       	st.b	--r6,r8

80006244 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006244:	30 19       	mov	r9,1
80006246:	48 28       	lddpc	r8,8000624c <vTaskMissedYield+0x8>
80006248:	91 09       	st.w	r8[0x0],r9
}
8000624a:	5e fc       	retal	r12
8000624c:	00 00       	add	r0,r0
8000624e:	0d 1c       	ld.sh	r12,r6++

80006250 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006250:	48 28       	lddpc	r8,80006258 <xTaskGetCurrentTaskHandle+0x8>
80006252:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006254:	5e fc       	retal	r12
80006256:	00 00       	add	r0,r0
80006258:	00 00       	add	r0,r0
8000625a:	0c cc       	st.b	r6++,r12

8000625c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000625c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006260:	58 0c       	cp.w	r12,0
80006262:	c1 f0       	breq	800062a0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006264:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006266:	78 b9       	ld.w	r9,r12[0x2c]
80006268:	79 18       	ld.w	r8,r12[0x44]
8000626a:	10 39       	cp.w	r9,r8
8000626c:	c1 a0       	breq	800062a0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000626e:	f8 c6 ff fc 	sub	r6,r12,-4
80006272:	0c 9c       	mov	r12,r6
80006274:	f0 1f 00 0c 	mcall	800062a4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006278:	6f 1c       	ld.w	r12,r7[0x44]
8000627a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000627c:	f8 08 11 08 	rsub	r8,r12,8
80006280:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006282:	48 a8       	lddpc	r8,800062a8 <vTaskPriorityDisinherit+0x4c>
80006284:	70 08       	ld.w	r8,r8[0x0]
80006286:	10 3c       	cp.w	r12,r8
80006288:	e0 88 00 04 	brls	80006290 <vTaskPriorityDisinherit+0x34>
8000628c:	48 78       	lddpc	r8,800062a8 <vTaskPriorityDisinherit+0x4c>
8000628e:	91 0c       	st.w	r8[0x0],r12
80006290:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006294:	0c 9b       	mov	r11,r6
80006296:	48 68       	lddpc	r8,800062ac <vTaskPriorityDisinherit+0x50>
80006298:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000629c:	f0 1f 00 05 	mcall	800062b0 <vTaskPriorityDisinherit+0x54>
800062a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	59 b2       	cp.w	r2,27
800062a8:	00 00       	add	r0,r0
800062aa:	0d 34       	ld.ub	r4,r6++
800062ac:	00 00       	add	r0,r0
800062ae:	0c 18       	sub	r8,r6
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	59 62       	cp.w	r2,22

800062b4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800062b4:	eb cd 40 c0 	pushm	r6-r7,lr
800062b8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800062ba:	49 b8       	lddpc	r8,80006324 <vTaskPriorityInherit+0x70>
800062bc:	70 08       	ld.w	r8,r8[0x0]
800062be:	78 b9       	ld.w	r9,r12[0x2c]
800062c0:	70 b8       	ld.w	r8,r8[0x2c]
800062c2:	10 39       	cp.w	r9,r8
800062c4:	c2 d2       	brcc	8000631e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800062c6:	49 88       	lddpc	r8,80006324 <vTaskPriorityInherit+0x70>
800062c8:	70 08       	ld.w	r8,r8[0x0]
800062ca:	70 b8       	ld.w	r8,r8[0x2c]
800062cc:	f0 08 11 08 	rsub	r8,r8,8
800062d0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800062d2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800062d6:	49 59       	lddpc	r9,80006328 <vTaskPriorityInherit+0x74>
800062d8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800062dc:	78 59       	ld.w	r9,r12[0x14]
800062de:	10 39       	cp.w	r9,r8
800062e0:	c1 b1       	brne	80006316 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800062e2:	f8 c6 ff fc 	sub	r6,r12,-4
800062e6:	0c 9c       	mov	r12,r6
800062e8:	f0 1f 00 11 	mcall	8000632c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800062ec:	48 e8       	lddpc	r8,80006324 <vTaskPriorityInherit+0x70>
800062ee:	70 08       	ld.w	r8,r8[0x0]
800062f0:	70 bc       	ld.w	r12,r8[0x2c]
800062f2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800062f4:	48 f8       	lddpc	r8,80006330 <vTaskPriorityInherit+0x7c>
800062f6:	70 08       	ld.w	r8,r8[0x0]
800062f8:	10 3c       	cp.w	r12,r8
800062fa:	e0 88 00 04 	brls	80006302 <vTaskPriorityInherit+0x4e>
800062fe:	48 d8       	lddpc	r8,80006330 <vTaskPriorityInherit+0x7c>
80006300:	91 0c       	st.w	r8[0x0],r12
80006302:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006306:	0c 9b       	mov	r11,r6
80006308:	48 88       	lddpc	r8,80006328 <vTaskPriorityInherit+0x74>
8000630a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000630e:	f0 1f 00 0a 	mcall	80006334 <vTaskPriorityInherit+0x80>
80006312:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006316:	48 48       	lddpc	r8,80006324 <vTaskPriorityInherit+0x70>
80006318:	70 08       	ld.w	r8,r8[0x0]
8000631a:	70 b8       	ld.w	r8,r8[0x2c]
8000631c:	99 b8       	st.w	r12[0x2c],r8
8000631e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006322:	00 00       	add	r0,r0
80006324:	00 00       	add	r0,r0
80006326:	0c cc       	st.b	r6++,r12
80006328:	00 00       	add	r0,r0
8000632a:	0c 18       	sub	r8,r6
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	59 b2       	cp.w	r2,27
80006330:	00 00       	add	r0,r0
80006332:	0d 34       	ld.ub	r4,r6++
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	59 62       	cp.w	r2,22

80006338 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006338:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000633c:	78 38       	ld.w	r8,r12[0xc]
8000633e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006340:	ee c6 ff e8 	sub	r6,r7,-24
80006344:	0c 9c       	mov	r12,r6
80006346:	f0 1f 00 15 	mcall	80006398 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000634a:	49 58       	lddpc	r8,8000639c <xTaskRemoveFromEventList+0x64>
8000634c:	70 08       	ld.w	r8,r8[0x0]
8000634e:	58 08       	cp.w	r8,0
80006350:	c1 71       	brne	8000637e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006352:	ee c6 ff fc 	sub	r6,r7,-4
80006356:	0c 9c       	mov	r12,r6
80006358:	f0 1f 00 10 	mcall	80006398 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000635c:	6e bc       	ld.w	r12,r7[0x2c]
8000635e:	49 18       	lddpc	r8,800063a0 <xTaskRemoveFromEventList+0x68>
80006360:	70 08       	ld.w	r8,r8[0x0]
80006362:	10 3c       	cp.w	r12,r8
80006364:	e0 88 00 04 	brls	8000636c <xTaskRemoveFromEventList+0x34>
80006368:	48 e8       	lddpc	r8,800063a0 <xTaskRemoveFromEventList+0x68>
8000636a:	91 0c       	st.w	r8[0x0],r12
8000636c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006370:	0c 9b       	mov	r11,r6
80006372:	48 d8       	lddpc	r8,800063a4 <xTaskRemoveFromEventList+0x6c>
80006374:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006378:	f0 1f 00 0c 	mcall	800063a8 <xTaskRemoveFromEventList+0x70>
8000637c:	c0 58       	rjmp	80006386 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000637e:	0c 9b       	mov	r11,r6
80006380:	48 bc       	lddpc	r12,800063ac <xTaskRemoveFromEventList+0x74>
80006382:	f0 1f 00 0a 	mcall	800063a8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006386:	48 b8       	lddpc	r8,800063b0 <xTaskRemoveFromEventList+0x78>
80006388:	70 08       	ld.w	r8,r8[0x0]
8000638a:	6e b9       	ld.w	r9,r7[0x2c]
8000638c:	70 b8       	ld.w	r8,r8[0x2c]
8000638e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006390:	5f 2c       	srhs	r12
80006392:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006396:	00 00       	add	r0,r0
80006398:	80 00       	ld.sh	r0,r0[0x0]
8000639a:	59 b2       	cp.w	r2,27
8000639c:	00 00       	add	r0,r0
8000639e:	0c fc       	st.b	--r6,r12
800063a0:	00 00       	add	r0,r0
800063a2:	0d 34       	ld.ub	r4,r6++
800063a4:	00 00       	add	r0,r0
800063a6:	0c 18       	sub	r8,r6
800063a8:	80 00       	ld.sh	r0,r0[0x0]
800063aa:	59 62       	cp.w	r2,22
800063ac:	00 00       	add	r0,r0
800063ae:	0c d0       	st.w	--r6,r0
800063b0:	00 00       	add	r0,r0
800063b2:	0c cc       	st.b	r6++,r12

800063b4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800063b4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800063b8:	4b 98       	lddpc	r8,8000649c <vTaskIncrementTick+0xe8>
800063ba:	70 08       	ld.w	r8,r8[0x0]
800063bc:	58 08       	cp.w	r8,0
800063be:	c6 91       	brne	80006490 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800063c0:	4b 88       	lddpc	r8,800064a0 <vTaskIncrementTick+0xec>
800063c2:	70 09       	ld.w	r9,r8[0x0]
800063c4:	2f f9       	sub	r9,-1
800063c6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800063c8:	70 08       	ld.w	r8,r8[0x0]
800063ca:	58 08       	cp.w	r8,0
800063cc:	c1 a1       	brne	80006400 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800063ce:	4b 68       	lddpc	r8,800064a4 <vTaskIncrementTick+0xf0>
800063d0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800063d2:	4b 69       	lddpc	r9,800064a8 <vTaskIncrementTick+0xf4>
800063d4:	72 0b       	ld.w	r11,r9[0x0]
800063d6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800063d8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800063da:	4b 59       	lddpc	r9,800064ac <vTaskIncrementTick+0xf8>
800063dc:	72 0a       	ld.w	r10,r9[0x0]
800063de:	2f fa       	sub	r10,-1
800063e0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800063e2:	70 08       	ld.w	r8,r8[0x0]
800063e4:	70 08       	ld.w	r8,r8[0x0]
800063e6:	58 08       	cp.w	r8,0
800063e8:	c0 51       	brne	800063f2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800063ea:	3f f9       	mov	r9,-1
800063ec:	4b 18       	lddpc	r8,800064b0 <vTaskIncrementTick+0xfc>
800063ee:	91 09       	st.w	r8[0x0],r9
800063f0:	c0 88       	rjmp	80006400 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800063f2:	4a d8       	lddpc	r8,800064a4 <vTaskIncrementTick+0xf0>
800063f4:	70 08       	ld.w	r8,r8[0x0]
800063f6:	70 38       	ld.w	r8,r8[0xc]
800063f8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800063fa:	70 19       	ld.w	r9,r8[0x4]
800063fc:	4a d8       	lddpc	r8,800064b0 <vTaskIncrementTick+0xfc>
800063fe:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006400:	4a 88       	lddpc	r8,800064a0 <vTaskIncrementTick+0xec>
80006402:	70 09       	ld.w	r9,r8[0x0]
80006404:	4a b8       	lddpc	r8,800064b0 <vTaskIncrementTick+0xfc>
80006406:	70 08       	ld.w	r8,r8[0x0]
80006408:	10 39       	cp.w	r9,r8
8000640a:	c4 73       	brcs	80006498 <vTaskIncrementTick+0xe4>
8000640c:	4a 68       	lddpc	r8,800064a4 <vTaskIncrementTick+0xf0>
8000640e:	70 08       	ld.w	r8,r8[0x0]
80006410:	70 08       	ld.w	r8,r8[0x0]
80006412:	58 08       	cp.w	r8,0
80006414:	c0 c0       	breq	8000642c <vTaskIncrementTick+0x78>
80006416:	4a 48       	lddpc	r8,800064a4 <vTaskIncrementTick+0xf0>
80006418:	70 08       	ld.w	r8,r8[0x0]
8000641a:	70 38       	ld.w	r8,r8[0xc]
8000641c:	70 37       	ld.w	r7,r8[0xc]
8000641e:	6e 18       	ld.w	r8,r7[0x4]
80006420:	4a 09       	lddpc	r9,800064a0 <vTaskIncrementTick+0xec>
80006422:	72 09       	ld.w	r9,r9[0x0]
80006424:	12 38       	cp.w	r8,r9
80006426:	e0 88 00 14 	brls	8000644e <vTaskIncrementTick+0x9a>
8000642a:	c0 e8       	rjmp	80006446 <vTaskIncrementTick+0x92>
8000642c:	3f f9       	mov	r9,-1
8000642e:	4a 18       	lddpc	r8,800064b0 <vTaskIncrementTick+0xfc>
80006430:	91 09       	st.w	r8[0x0],r9
80006432:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006436:	6a 08       	ld.w	r8,r5[0x0]
80006438:	70 38       	ld.w	r8,r8[0xc]
8000643a:	70 37       	ld.w	r7,r8[0xc]
8000643c:	6e 18       	ld.w	r8,r7[0x4]
8000643e:	64 09       	ld.w	r9,r2[0x0]
80006440:	12 38       	cp.w	r8,r9
80006442:	e0 88 00 0a 	brls	80006456 <vTaskIncrementTick+0xa2>
80006446:	49 b9       	lddpc	r9,800064b0 <vTaskIncrementTick+0xfc>
80006448:	93 08       	st.w	r9[0x0],r8
8000644a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000644e:	49 a4       	lddpc	r4,800064b4 <vTaskIncrementTick+0x100>
80006450:	49 a3       	lddpc	r3,800064b8 <vTaskIncrementTick+0x104>
80006452:	49 55       	lddpc	r5,800064a4 <vTaskIncrementTick+0xf0>
80006454:	49 32       	lddpc	r2,800064a0 <vTaskIncrementTick+0xec>
80006456:	ee c6 ff fc 	sub	r6,r7,-4
8000645a:	0c 9c       	mov	r12,r6
8000645c:	f0 1f 00 18 	mcall	800064bc <vTaskIncrementTick+0x108>
80006460:	6e a8       	ld.w	r8,r7[0x28]
80006462:	58 08       	cp.w	r8,0
80006464:	c0 50       	breq	8000646e <vTaskIncrementTick+0xba>
80006466:	ee cc ff e8 	sub	r12,r7,-24
8000646a:	f0 1f 00 15 	mcall	800064bc <vTaskIncrementTick+0x108>
8000646e:	6e bc       	ld.w	r12,r7[0x2c]
80006470:	68 08       	ld.w	r8,r4[0x0]
80006472:	10 3c       	cp.w	r12,r8
80006474:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006478:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000647c:	0c 9b       	mov	r11,r6
8000647e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006482:	f0 1f 00 10 	mcall	800064c0 <vTaskIncrementTick+0x10c>
80006486:	6a 08       	ld.w	r8,r5[0x0]
80006488:	70 08       	ld.w	r8,r8[0x0]
8000648a:	58 08       	cp.w	r8,0
8000648c:	cd 51       	brne	80006436 <vTaskIncrementTick+0x82>
8000648e:	cc fb       	rjmp	8000642c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006490:	48 d8       	lddpc	r8,800064c4 <vTaskIncrementTick+0x110>
80006492:	70 09       	ld.w	r9,r8[0x0]
80006494:	2f f9       	sub	r9,-1
80006496:	91 09       	st.w	r8[0x0],r9
80006498:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000649c:	00 00       	add	r0,r0
8000649e:	0c fc       	st.b	--r6,r12
800064a0:	00 00       	add	r0,r0
800064a2:	0c f8       	st.b	--r6,r8
800064a4:	00 00       	add	r0,r0
800064a6:	0c 04       	add	r4,r6
800064a8:	00 00       	add	r0,r0
800064aa:	0c 14       	sub	r4,r6
800064ac:	00 00       	add	r0,r0
800064ae:	0c 10       	sub	r0,r6
800064b0:	00 00       	add	r0,r0
800064b2:	05 28       	ld.uh	r8,r2++
800064b4:	00 00       	add	r0,r0
800064b6:	0d 34       	ld.ub	r4,r6++
800064b8:	00 00       	add	r0,r0
800064ba:	0c 18       	sub	r8,r6
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	59 b2       	cp.w	r2,27
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	59 62       	cp.w	r2,22
800064c4:	00 00       	add	r0,r0
800064c6:	0b fc       	ld.ub	r12,r5[0x7]

800064c8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800064c8:	eb cd 40 c0 	pushm	r6-r7,lr
800064cc:	18 97       	mov	r7,r12
800064ce:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800064d0:	f0 1f 00 15 	mcall	80006524 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800064d4:	6c 08       	ld.w	r8,r6[0x0]
800064d6:	5b f8       	cp.w	r8,-1
800064d8:	c0 31       	brne	800064de <xTaskCheckForTimeOut+0x16>
800064da:	30 07       	mov	r7,0
800064dc:	c1 f8       	rjmp	8000651a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800064de:	49 39       	lddpc	r9,80006528 <xTaskCheckForTimeOut+0x60>
800064e0:	72 09       	ld.w	r9,r9[0x0]
800064e2:	6e 0a       	ld.w	r10,r7[0x0]
800064e4:	12 3a       	cp.w	r10,r9
800064e6:	c0 70       	breq	800064f4 <xTaskCheckForTimeOut+0x2c>
800064e8:	49 19       	lddpc	r9,8000652c <xTaskCheckForTimeOut+0x64>
800064ea:	72 09       	ld.w	r9,r9[0x0]
800064ec:	6e 1a       	ld.w	r10,r7[0x4]
800064ee:	12 3a       	cp.w	r10,r9
800064f0:	e0 88 00 14 	brls	80006518 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800064f4:	48 e9       	lddpc	r9,8000652c <xTaskCheckForTimeOut+0x64>
800064f6:	72 0a       	ld.w	r10,r9[0x0]
800064f8:	6e 19       	ld.w	r9,r7[0x4]
800064fa:	12 1a       	sub	r10,r9
800064fc:	14 38       	cp.w	r8,r10
800064fe:	e0 88 00 0d 	brls	80006518 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006502:	48 ba       	lddpc	r10,8000652c <xTaskCheckForTimeOut+0x64>
80006504:	74 0a       	ld.w	r10,r10[0x0]
80006506:	14 19       	sub	r9,r10
80006508:	f2 08 00 08 	add	r8,r9,r8
8000650c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000650e:	0e 9c       	mov	r12,r7
80006510:	f0 1f 00 08 	mcall	80006530 <xTaskCheckForTimeOut+0x68>
80006514:	30 07       	mov	r7,0
80006516:	c0 28       	rjmp	8000651a <xTaskCheckForTimeOut+0x52>
80006518:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000651a:	f0 1f 00 07 	mcall	80006534 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000651e:	0e 9c       	mov	r12,r7
80006520:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	5a 6c       	cp.w	r12,-26
80006528:	00 00       	add	r0,r0
8000652a:	0c 10       	sub	r0,r6
8000652c:	00 00       	add	r0,r0
8000652e:	0c f8       	st.b	--r6,r8
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	62 2c       	ld.w	r12,r1[0x8]
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	5b 78       	cp.w	r8,-9

80006538 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006538:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000653c:	f0 1f 00 05 	mcall	80006550 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006540:	48 58       	lddpc	r8,80006554 <xTaskGetTickCount+0x1c>
80006542:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006544:	f0 1f 00 05 	mcall	80006558 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006548:	0e 9c       	mov	r12,r7
8000654a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000654e:	00 00       	add	r0,r0
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	5a 6c       	cp.w	r12,-26
80006554:	00 00       	add	r0,r0
80006556:	0c f8       	st.b	--r6,r8
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	5b 78       	cp.w	r8,-9

8000655c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000655c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006560:	f0 1f 00 2c 	mcall	80006610 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006564:	4a c8       	lddpc	r8,80006614 <xTaskResumeAll+0xb8>
80006566:	70 09       	ld.w	r9,r8[0x0]
80006568:	20 19       	sub	r9,1
8000656a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000656c:	70 08       	ld.w	r8,r8[0x0]
8000656e:	58 08       	cp.w	r8,0
80006570:	c4 91       	brne	80006602 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006572:	4a a8       	lddpc	r8,80006618 <xTaskResumeAll+0xbc>
80006574:	70 08       	ld.w	r8,r8[0x0]
80006576:	58 08       	cp.w	r8,0
80006578:	c4 50       	breq	80006602 <xTaskResumeAll+0xa6>
8000657a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000657c:	4a 85       	lddpc	r5,8000661c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000657e:	4a 93       	lddpc	r3,80006620 <xTaskResumeAll+0xc4>
80006580:	4a 92       	lddpc	r2,80006624 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006582:	4a a1       	lddpc	r1,80006628 <xTaskResumeAll+0xcc>
80006584:	c1 e8       	rjmp	800065c0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006586:	6a 38       	ld.w	r8,r5[0xc]
80006588:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000658a:	ee cc ff e8 	sub	r12,r7,-24
8000658e:	f0 1f 00 28 	mcall	8000662c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006592:	ee c6 ff fc 	sub	r6,r7,-4
80006596:	0c 9c       	mov	r12,r6
80006598:	f0 1f 00 25 	mcall	8000662c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000659c:	6e bc       	ld.w	r12,r7[0x2c]
8000659e:	66 08       	ld.w	r8,r3[0x0]
800065a0:	10 3c       	cp.w	r12,r8
800065a2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800065a6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065aa:	0c 9b       	mov	r11,r6
800065ac:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800065b0:	f0 1f 00 20 	mcall	80006630 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800065b4:	62 08       	ld.w	r8,r1[0x0]
800065b6:	6e b9       	ld.w	r9,r7[0x2c]
800065b8:	70 b8       	ld.w	r8,r8[0x2c]
800065ba:	10 39       	cp.w	r9,r8
800065bc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800065c0:	6a 08       	ld.w	r8,r5[0x0]
800065c2:	58 08       	cp.w	r8,0
800065c4:	ce 11       	brne	80006586 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800065c6:	49 c8       	lddpc	r8,80006634 <xTaskResumeAll+0xd8>
800065c8:	70 08       	ld.w	r8,r8[0x0]
800065ca:	58 08       	cp.w	r8,0
800065cc:	c0 f0       	breq	800065ea <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800065ce:	49 a8       	lddpc	r8,80006634 <xTaskResumeAll+0xd8>
800065d0:	70 08       	ld.w	r8,r8[0x0]
800065d2:	58 08       	cp.w	r8,0
800065d4:	c1 10       	breq	800065f6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800065d6:	49 87       	lddpc	r7,80006634 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800065d8:	f0 1f 00 18 	mcall	80006638 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800065dc:	6e 08       	ld.w	r8,r7[0x0]
800065de:	20 18       	sub	r8,1
800065e0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800065e2:	6e 08       	ld.w	r8,r7[0x0]
800065e4:	58 08       	cp.w	r8,0
800065e6:	cf 91       	brne	800065d8 <xTaskResumeAll+0x7c>
800065e8:	c0 78       	rjmp	800065f6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800065ea:	58 14       	cp.w	r4,1
800065ec:	c0 50       	breq	800065f6 <xTaskResumeAll+0x9a>
800065ee:	49 48       	lddpc	r8,8000663c <xTaskResumeAll+0xe0>
800065f0:	70 08       	ld.w	r8,r8[0x0]
800065f2:	58 18       	cp.w	r8,1
800065f4:	c0 71       	brne	80006602 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800065f6:	30 09       	mov	r9,0
800065f8:	49 18       	lddpc	r8,8000663c <xTaskResumeAll+0xe0>
800065fa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800065fc:	d7 33       	scall
800065fe:	30 17       	mov	r7,1
80006600:	c0 28       	rjmp	80006604 <xTaskResumeAll+0xa8>
80006602:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006604:	f0 1f 00 0f 	mcall	80006640 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006608:	0e 9c       	mov	r12,r7
8000660a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000660e:	00 00       	add	r0,r0
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	5a 6c       	cp.w	r12,-26
80006614:	00 00       	add	r0,r0
80006616:	0c fc       	st.b	--r6,r12
80006618:	00 00       	add	r0,r0
8000661a:	0d 18       	ld.sh	r8,r6++
8000661c:	00 00       	add	r0,r0
8000661e:	0c d0       	st.w	--r6,r0
80006620:	00 00       	add	r0,r0
80006622:	0d 34       	ld.ub	r4,r6++
80006624:	00 00       	add	r0,r0
80006626:	0c 18       	sub	r8,r6
80006628:	00 00       	add	r0,r0
8000662a:	0c cc       	st.b	r6++,r12
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	59 b2       	cp.w	r2,27
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	59 62       	cp.w	r2,22
80006634:	00 00       	add	r0,r0
80006636:	0b fc       	ld.ub	r12,r5[0x7]
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	63 b4       	ld.w	r4,r1[0x6c]
8000663c:	00 00       	add	r0,r0
8000663e:	0d 1c       	ld.sh	r12,r6++
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	5b 78       	cp.w	r8,-9

80006644 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006644:	eb cd 40 80 	pushm	r7,lr
80006648:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000664a:	49 08       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x44>
8000664c:	70 08       	ld.w	r8,r8[0x0]
8000664e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006650:	48 f8       	lddpc	r8,8000668c <prvAddCurrentTaskToDelayedList+0x48>
80006652:	70 08       	ld.w	r8,r8[0x0]
80006654:	10 3c       	cp.w	r12,r8
80006656:	c0 a2       	brcc	8000666a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006658:	48 c8       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x44>
8000665a:	70 0b       	ld.w	r11,r8[0x0]
8000665c:	48 d8       	lddpc	r8,80006690 <prvAddCurrentTaskToDelayedList+0x4c>
8000665e:	70 0c       	ld.w	r12,r8[0x0]
80006660:	2f cb       	sub	r11,-4
80006662:	f0 1f 00 0d 	mcall	80006694 <prvAddCurrentTaskToDelayedList+0x50>
80006666:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000666a:	48 88       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x44>
8000666c:	70 0b       	ld.w	r11,r8[0x0]
8000666e:	48 b8       	lddpc	r8,80006698 <prvAddCurrentTaskToDelayedList+0x54>
80006670:	70 0c       	ld.w	r12,r8[0x0]
80006672:	2f cb       	sub	r11,-4
80006674:	f0 1f 00 08 	mcall	80006694 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006678:	48 98       	lddpc	r8,8000669c <prvAddCurrentTaskToDelayedList+0x58>
8000667a:	70 08       	ld.w	r8,r8[0x0]
8000667c:	10 37       	cp.w	r7,r8
8000667e:	c0 32       	brcc	80006684 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006680:	48 78       	lddpc	r8,8000669c <prvAddCurrentTaskToDelayedList+0x58>
80006682:	91 07       	st.w	r8[0x0],r7
80006684:	e3 cd 80 80 	ldm	sp++,r7,pc
80006688:	00 00       	add	r0,r0
8000668a:	0c cc       	st.b	r6++,r12
8000668c:	00 00       	add	r0,r0
8000668e:	0c f8       	st.b	--r6,r8
80006690:	00 00       	add	r0,r0
80006692:	0c 14       	sub	r4,r6
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	59 7e       	cp.w	lr,23
80006698:	00 00       	add	r0,r0
8000669a:	0c 04       	add	r4,r6
8000669c:	00 00       	add	r0,r0
8000669e:	05 28       	ld.uh	r8,r2++

800066a0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800066a0:	eb cd 40 c0 	pushm	r6-r7,lr
800066a4:	18 96       	mov	r6,r12
800066a6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800066a8:	f0 1f 00 18 	mcall	80006708 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800066ac:	6c 08       	ld.w	r8,r6[0x0]
800066ae:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800066b0:	49 79       	lddpc	r9,8000670c <vTaskDelayUntil+0x6c>
800066b2:	72 09       	ld.w	r9,r9[0x0]
800066b4:	12 38       	cp.w	r8,r9
800066b6:	e0 88 00 0c 	brls	800066ce <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800066ba:	0e 38       	cp.w	r8,r7
800066bc:	e0 88 00 22 	brls	80006700 <vTaskDelayUntil+0x60>
800066c0:	49 38       	lddpc	r8,8000670c <vTaskDelayUntil+0x6c>
800066c2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800066c4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800066c6:	10 37       	cp.w	r7,r8
800066c8:	e0 88 00 14 	brls	800066f0 <vTaskDelayUntil+0x50>
800066cc:	c0 a8       	rjmp	800066e0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800066ce:	0e 38       	cp.w	r8,r7
800066d0:	e0 8b 00 16 	brhi	800066fc <vTaskDelayUntil+0x5c>
800066d4:	48 e8       	lddpc	r8,8000670c <vTaskDelayUntil+0x6c>
800066d6:	70 08       	ld.w	r8,r8[0x0]
800066d8:	10 37       	cp.w	r7,r8
800066da:	e0 8b 00 11 	brhi	800066fc <vTaskDelayUntil+0x5c>
800066de:	c1 18       	rjmp	80006700 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800066e0:	48 c8       	lddpc	r8,80006710 <vTaskDelayUntil+0x70>
800066e2:	70 0c       	ld.w	r12,r8[0x0]
800066e4:	2f cc       	sub	r12,-4
800066e6:	f0 1f 00 0c 	mcall	80006714 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800066ea:	0e 9c       	mov	r12,r7
800066ec:	f0 1f 00 0b 	mcall	80006718 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800066f0:	f0 1f 00 0b 	mcall	8000671c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800066f4:	c0 81       	brne	80006704 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800066f6:	d7 33       	scall
800066f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800066fc:	8d 07       	st.w	r6[0x0],r7
800066fe:	cf 1b       	rjmp	800066e0 <vTaskDelayUntil+0x40>
80006700:	8d 07       	st.w	r6[0x0],r7
80006702:	cf 7b       	rjmp	800066f0 <vTaskDelayUntil+0x50>
80006704:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	61 a0       	ld.w	r0,r0[0x68]
8000670c:	00 00       	add	r0,r0
8000670e:	0c f8       	st.b	--r6,r8
80006710:	00 00       	add	r0,r0
80006712:	0c cc       	st.b	r6++,r12
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	59 b2       	cp.w	r2,27
80006718:	80 00       	ld.sh	r0,r0[0x0]
8000671a:	66 44       	ld.w	r4,r3[0x10]
8000671c:	80 00       	ld.sh	r0,r0[0x0]
8000671e:	65 5c       	ld.w	r12,r2[0x54]

80006720 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006720:	eb cd 40 c0 	pushm	r6-r7,lr
80006724:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006726:	48 e7       	lddpc	r7,8000675c <vTaskPlaceOnEventList+0x3c>
80006728:	6e 0b       	ld.w	r11,r7[0x0]
8000672a:	2e 8b       	sub	r11,-24
8000672c:	f0 1f 00 0d 	mcall	80006760 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006730:	6e 0c       	ld.w	r12,r7[0x0]
80006732:	2f cc       	sub	r12,-4
80006734:	f0 1f 00 0c 	mcall	80006764 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006738:	5b f6       	cp.w	r6,-1
8000673a:	c0 81       	brne	8000674a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000673c:	6e 0b       	ld.w	r11,r7[0x0]
8000673e:	2f cb       	sub	r11,-4
80006740:	48 ac       	lddpc	r12,80006768 <vTaskPlaceOnEventList+0x48>
80006742:	f0 1f 00 0b 	mcall	8000676c <vTaskPlaceOnEventList+0x4c>
80006746:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000674a:	48 a8       	lddpc	r8,80006770 <vTaskPlaceOnEventList+0x50>
8000674c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000674e:	ec 0c 00 0c 	add	r12,r6,r12
80006752:	f0 1f 00 09 	mcall	80006774 <vTaskPlaceOnEventList+0x54>
80006756:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000675a:	00 00       	add	r0,r0
8000675c:	00 00       	add	r0,r0
8000675e:	0c cc       	st.b	r6++,r12
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	59 7e       	cp.w	lr,23
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	59 b2       	cp.w	r2,27
80006768:	00 00       	add	r0,r0
8000676a:	0d 20       	ld.uh	r0,r6++
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	59 62       	cp.w	r2,22
80006770:	00 00       	add	r0,r0
80006772:	0c f8       	st.b	--r6,r8
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	66 44       	ld.w	r4,r3[0x10]

80006778 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006778:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000677c:	49 67       	lddpc	r7,800067d4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000677e:	49 74       	lddpc	r4,800067d8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006780:	49 73       	lddpc	r3,800067dc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006782:	49 85       	lddpc	r5,800067e0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006784:	6e 08       	ld.w	r8,r7[0x0]
80006786:	58 08       	cp.w	r8,0
80006788:	c1 e0       	breq	800067c4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000678a:	f0 1f 00 17 	mcall	800067e4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000678e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006790:	f0 1f 00 16 	mcall	800067e8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006794:	58 06       	cp.w	r6,0
80006796:	c1 70       	breq	800067c4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006798:	f0 1f 00 15 	mcall	800067ec <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000679c:	68 38       	ld.w	r8,r4[0xc]
8000679e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800067a0:	ec cc ff fc 	sub	r12,r6,-4
800067a4:	f0 1f 00 13 	mcall	800067f0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800067a8:	66 08       	ld.w	r8,r3[0x0]
800067aa:	20 18       	sub	r8,1
800067ac:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800067ae:	6e 08       	ld.w	r8,r7[0x0]
800067b0:	20 18       	sub	r8,1
800067b2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800067b4:	f0 1f 00 10 	mcall	800067f4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800067b8:	6c cc       	ld.w	r12,r6[0x30]
800067ba:	f0 1f 00 10 	mcall	800067f8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800067be:	0c 9c       	mov	r12,r6
800067c0:	f0 1f 00 0e 	mcall	800067f8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800067c4:	6a 08       	ld.w	r8,r5[0x0]
800067c6:	58 18       	cp.w	r8,1
800067c8:	e0 88 00 03 	brls	800067ce <prvIdleTask+0x56>
			{
				taskYIELD();
800067cc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800067ce:	f0 1f 00 0c 	mcall	800067fc <prvIdleTask+0x84>
		}
		#endif
	}
800067d2:	cd 9b       	rjmp	80006784 <prvIdleTask+0xc>
800067d4:	00 00       	add	r0,r0
800067d6:	0c 0c       	add	r12,r6
800067d8:	00 00       	add	r0,r0
800067da:	0c b8       	st.h	r6++,r8
800067dc:	00 00       	add	r0,r0
800067de:	0d 18       	ld.sh	r8,r6++
800067e0:	00 00       	add	r0,r0
800067e2:	0c 18       	sub	r8,r6
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	61 a0       	ld.w	r0,r0[0x68]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	65 5c       	ld.w	r12,r2[0x54]
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	5a 6c       	cp.w	r12,-26
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	59 b2       	cp.w	r2,27
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	5b 78       	cp.w	r8,-9
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	5c b0       	swap.b	r0
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	20 2c       	sub	r12,2

80006800 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006800:	d4 31       	pushm	r0-r7,lr
80006802:	20 1d       	sub	sp,4
80006804:	fa c4 ff d8 	sub	r4,sp,-40
80006808:	50 0c       	stdsp	sp[0x0],r12
8000680a:	16 91       	mov	r1,r11
8000680c:	14 97       	mov	r7,r10
8000680e:	12 90       	mov	r0,r9
80006810:	10 93       	mov	r3,r8
80006812:	68 02       	ld.w	r2,r4[0x0]
80006814:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006816:	34 8c       	mov	r12,72
80006818:	f0 1f 00 5c 	mcall	80006988 <xTaskGenericCreate+0x188>
8000681c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000681e:	c0 31       	brne	80006824 <xTaskGenericCreate+0x24>
80006820:	3f fc       	mov	r12,-1
80006822:	ca f8       	rjmp	80006980 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006824:	58 06       	cp.w	r6,0
80006826:	e0 81 00 af 	brne	80006984 <xTaskGenericCreate+0x184>
8000682a:	0e 9c       	mov	r12,r7
8000682c:	5c 7c       	castu.h	r12
8000682e:	a3 6c       	lsl	r12,0x2
80006830:	f0 1f 00 56 	mcall	80006988 <xTaskGenericCreate+0x188>
80006834:	18 96       	mov	r6,r12
80006836:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006838:	c0 61       	brne	80006844 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000683a:	0a 9c       	mov	r12,r5
8000683c:	f0 1f 00 54 	mcall	8000698c <xTaskGenericCreate+0x18c>
80006840:	3f fc       	mov	r12,-1
80006842:	c9 f8       	rjmp	80006980 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006844:	5c 77       	castu.h	r7
80006846:	ee 0a 15 02 	lsl	r10,r7,0x2
8000684a:	e0 6b 00 a5 	mov	r11,165
8000684e:	0c 9c       	mov	r12,r6
80006850:	f0 1f 00 50 	mcall	80006990 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006854:	ee c6 00 01 	sub	r6,r7,1
80006858:	6a c8       	ld.w	r8,r5[0x30]
8000685a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000685e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006862:	31 0a       	mov	r10,16
80006864:	02 9b       	mov	r11,r1
80006866:	ea cc ff cc 	sub	r12,r5,-52
8000686a:	f0 1f 00 4b 	mcall	80006994 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000686e:	30 08       	mov	r8,0
80006870:	eb 68 00 43 	st.b	r5[67],r8
80006874:	58 73       	cp.w	r3,7
80006876:	e6 07 17 80 	movls	r7,r3
8000687a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000687e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006880:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006884:	ea c4 ff fc 	sub	r4,r5,-4
80006888:	08 9c       	mov	r12,r4
8000688a:	f0 1f 00 44 	mcall	80006998 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000688e:	ea cc ff e8 	sub	r12,r5,-24
80006892:	f0 1f 00 42 	mcall	80006998 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006896:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006898:	ee 07 11 08 	rsub	r7,r7,8
8000689c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000689e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800068a0:	00 9a       	mov	r10,r0
800068a2:	40 0b       	lddsp	r11,sp[0x0]
800068a4:	0c 9c       	mov	r12,r6
800068a6:	f0 1f 00 3e 	mcall	8000699c <xTaskGenericCreate+0x19c>
800068aa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800068ac:	58 02       	cp.w	r2,0
800068ae:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800068b2:	f0 1f 00 3c 	mcall	800069a0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800068b6:	4b c8       	lddpc	r8,800069a4 <xTaskGenericCreate+0x1a4>
800068b8:	70 09       	ld.w	r9,r8[0x0]
800068ba:	2f f9       	sub	r9,-1
800068bc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800068be:	4b b8       	lddpc	r8,800069a8 <xTaskGenericCreate+0x1a8>
800068c0:	70 08       	ld.w	r8,r8[0x0]
800068c2:	58 08       	cp.w	r8,0
800068c4:	c2 61       	brne	80006910 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800068c6:	4b 98       	lddpc	r8,800069a8 <xTaskGenericCreate+0x1a8>
800068c8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800068ca:	4b 78       	lddpc	r8,800069a4 <xTaskGenericCreate+0x1a4>
800068cc:	70 08       	ld.w	r8,r8[0x0]
800068ce:	58 18       	cp.w	r8,1
800068d0:	c2 b1       	brne	80006926 <xTaskGenericCreate+0x126>
800068d2:	4b 77       	lddpc	r7,800069ac <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800068d4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800068d8:	0e 9c       	mov	r12,r7
800068da:	f0 1f 00 36 	mcall	800069b0 <xTaskGenericCreate+0x1b0>
800068de:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800068e0:	0c 37       	cp.w	r7,r6
800068e2:	cf b1       	brne	800068d8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800068e4:	4b 47       	lddpc	r7,800069b4 <xTaskGenericCreate+0x1b4>
800068e6:	0e 9c       	mov	r12,r7
800068e8:	f0 1f 00 32 	mcall	800069b0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800068ec:	4b 36       	lddpc	r6,800069b8 <xTaskGenericCreate+0x1b8>
800068ee:	0c 9c       	mov	r12,r6
800068f0:	f0 1f 00 30 	mcall	800069b0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800068f4:	4b 2c       	lddpc	r12,800069bc <xTaskGenericCreate+0x1bc>
800068f6:	f0 1f 00 2f 	mcall	800069b0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800068fa:	4b 2c       	lddpc	r12,800069c0 <xTaskGenericCreate+0x1c0>
800068fc:	f0 1f 00 2d 	mcall	800069b0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006900:	4b 1c       	lddpc	r12,800069c4 <xTaskGenericCreate+0x1c4>
80006902:	f0 1f 00 2c 	mcall	800069b0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006906:	4b 18       	lddpc	r8,800069c8 <xTaskGenericCreate+0x1c8>
80006908:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000690a:	4b 18       	lddpc	r8,800069cc <xTaskGenericCreate+0x1cc>
8000690c:	91 06       	st.w	r8[0x0],r6
8000690e:	c0 c8       	rjmp	80006926 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006910:	4b 08       	lddpc	r8,800069d0 <xTaskGenericCreate+0x1d0>
80006912:	70 08       	ld.w	r8,r8[0x0]
80006914:	58 08       	cp.w	r8,0
80006916:	c0 81       	brne	80006926 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006918:	4a 48       	lddpc	r8,800069a8 <xTaskGenericCreate+0x1a8>
8000691a:	70 08       	ld.w	r8,r8[0x0]
8000691c:	70 b8       	ld.w	r8,r8[0x2c]
8000691e:	10 33       	cp.w	r3,r8
80006920:	c0 33       	brcs	80006926 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006922:	4a 28       	lddpc	r8,800069a8 <xTaskGenericCreate+0x1a8>
80006924:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006926:	6a b8       	ld.w	r8,r5[0x2c]
80006928:	4a b9       	lddpc	r9,800069d4 <xTaskGenericCreate+0x1d4>
8000692a:	72 09       	ld.w	r9,r9[0x0]
8000692c:	12 38       	cp.w	r8,r9
8000692e:	e0 88 00 04 	brls	80006936 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006932:	4a 99       	lddpc	r9,800069d4 <xTaskGenericCreate+0x1d4>
80006934:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006936:	4a 98       	lddpc	r8,800069d8 <xTaskGenericCreate+0x1d8>
80006938:	70 09       	ld.w	r9,r8[0x0]
8000693a:	2f f9       	sub	r9,-1
8000693c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000693e:	6a b8       	ld.w	r8,r5[0x2c]
80006940:	4a 79       	lddpc	r9,800069dc <xTaskGenericCreate+0x1dc>
80006942:	72 09       	ld.w	r9,r9[0x0]
80006944:	12 38       	cp.w	r8,r9
80006946:	e0 88 00 04 	brls	8000694e <xTaskGenericCreate+0x14e>
8000694a:	4a 59       	lddpc	r9,800069dc <xTaskGenericCreate+0x1dc>
8000694c:	93 08       	st.w	r9[0x0],r8
8000694e:	6a bc       	ld.w	r12,r5[0x2c]
80006950:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006954:	08 9b       	mov	r11,r4
80006956:	49 68       	lddpc	r8,800069ac <xTaskGenericCreate+0x1ac>
80006958:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000695c:	f0 1f 00 21 	mcall	800069e0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006960:	f0 1f 00 21 	mcall	800069e4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006964:	49 b8       	lddpc	r8,800069d0 <xTaskGenericCreate+0x1d0>
80006966:	70 08       	ld.w	r8,r8[0x0]
80006968:	58 08       	cp.w	r8,0
8000696a:	c0 a0       	breq	8000697e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000696c:	48 f8       	lddpc	r8,800069a8 <xTaskGenericCreate+0x1a8>
8000696e:	70 08       	ld.w	r8,r8[0x0]
80006970:	70 b8       	ld.w	r8,r8[0x2c]
80006972:	10 33       	cp.w	r3,r8
80006974:	e0 88 00 05 	brls	8000697e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006978:	d7 33       	scall
8000697a:	30 1c       	mov	r12,1
8000697c:	c0 28       	rjmp	80006980 <xTaskGenericCreate+0x180>
8000697e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006980:	2f fd       	sub	sp,-4
80006982:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006984:	99 c6       	st.w	r12[0x30],r6
80006986:	c5 fb       	rjmp	80006844 <xTaskGenericCreate+0x44>
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	5c d8       	com	r8
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	5c b0       	swap.b	r0
80006990:	80 00       	ld.sh	r0,r0[0x0]
80006992:	75 a0       	ld.w	r0,r10[0x68]
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	78 cc       	ld.w	r12,r12[0x30]
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	59 5c       	cp.w	r12,21
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	59 d8       	cp.w	r8,29
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	5a 6c       	cp.w	r12,-26
800069a4:	00 00       	add	r0,r0
800069a6:	0d 18       	ld.sh	r8,r6++
800069a8:	00 00       	add	r0,r0
800069aa:	0c cc       	st.b	r6++,r12
800069ac:	00 00       	add	r0,r0
800069ae:	0c 18       	sub	r8,r6
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	59 48       	cp.w	r8,20
800069b4:	00 00       	add	r0,r0
800069b6:	0c e4       	st.h	--r6,r4
800069b8:	00 00       	add	r0,r0
800069ba:	0d 00       	ld.w	r0,r6++
800069bc:	00 00       	add	r0,r0
800069be:	0c d0       	st.w	--r6,r0
800069c0:	00 00       	add	r0,r0
800069c2:	0c b8       	st.h	r6++,r8
800069c4:	00 00       	add	r0,r0
800069c6:	0d 20       	ld.uh	r0,r6++
800069c8:	00 00       	add	r0,r0
800069ca:	0c 04       	add	r4,r6
800069cc:	00 00       	add	r0,r0
800069ce:	0c 14       	sub	r4,r6
800069d0:	00 00       	add	r0,r0
800069d2:	0c 08       	add	r8,r6
800069d4:	00 00       	add	r0,r0
800069d6:	0c 00       	add	r0,r6
800069d8:	00 00       	add	r0,r0
800069da:	0d 14       	ld.sh	r4,r6++
800069dc:	00 00       	add	r0,r0
800069de:	0d 34       	ld.ub	r4,r6++
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	59 62       	cp.w	r2,22
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	5b 78       	cp.w	r8,-9

800069e8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800069e8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800069ea:	30 09       	mov	r9,0
800069ec:	1a d9       	st.w	--sp,r9
800069ee:	1a d9       	st.w	--sp,r9
800069f0:	1a d9       	st.w	--sp,r9
800069f2:	12 98       	mov	r8,r9
800069f4:	e0 6a 01 00 	mov	r10,256
800069f8:	48 9b       	lddpc	r11,80006a1c <vTaskStartScheduler+0x34>
800069fa:	48 ac       	lddpc	r12,80006a20 <vTaskStartScheduler+0x38>
800069fc:	f0 1f 00 0a 	mcall	80006a24 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006a00:	2f dd       	sub	sp,-12
80006a02:	58 1c       	cp.w	r12,1
80006a04:	c0 a1       	brne	80006a18 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006a06:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006a08:	30 19       	mov	r9,1
80006a0a:	48 88       	lddpc	r8,80006a28 <vTaskStartScheduler+0x40>
80006a0c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006a0e:	30 09       	mov	r9,0
80006a10:	48 78       	lddpc	r8,80006a2c <vTaskStartScheduler+0x44>
80006a12:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006a14:	f0 1f 00 07 	mcall	80006a30 <vTaskStartScheduler+0x48>
80006a18:	d8 02       	popm	pc
80006a1a:	00 00       	add	r0,r0
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	d4 bc       	*unknown*
80006a20:	80 00       	ld.sh	r0,r0[0x0]
80006a22:	67 78       	ld.w	r8,r3[0x5c]
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	68 00       	ld.w	r0,r4[0x0]
80006a28:	00 00       	add	r0,r0
80006a2a:	0c 08       	add	r8,r6
80006a2c:	00 00       	add	r0,r0
80006a2e:	0c f8       	st.b	--r6,r8
80006a30:	80 00       	ld.sh	r0,r0[0x0]
80006a32:	5a 7c       	cp.w	r12,-25

80006a34 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006a34:	16 cc       	st.b	r11++,r12
	return str;
}
80006a36:	5e fb       	retal	r11

80006a38 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006a38:	eb cd 40 c0 	pushm	r6-r7,lr
80006a3c:	20 3d       	sub	sp,12
80006a3e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006a40:	30 06       	mov	r6,0
80006a42:	30 07       	mov	r7,0
80006a44:	fa e7 00 00 	st.d	sp[0],r6
80006a48:	30 0c       	mov	r12,0
80006a4a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006a4c:	58 08       	cp.w	r8,0
80006a4e:	c1 30       	breq	80006a74 <PrintHex+0x3c>
80006a50:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006a52:	1a 9c       	mov	r12,sp
80006a54:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006a58:	58 9e       	cp.w	lr,9
80006a5a:	e0 8a 00 04 	brle	80006a62 <PrintHex+0x2a>
80006a5e:	2c 9e       	sub	lr,-55
80006a60:	c0 48       	rjmp	80006a68 <PrintHex+0x30>
80006a62:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006a66:	2d 0e       	sub	lr,-48
80006a68:	f8 09 0b 0e 	st.b	r12[r9],lr
80006a6c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006a6e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006a70:	cf 21       	brne	80006a54 <PrintHex+0x1c>
80006a72:	c0 48       	rjmp	80006a7a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006a74:	33 08       	mov	r8,48
80006a76:	ba 88       	st.b	sp[0x0],r8
80006a78:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006a7a:	f6 09 01 08 	sub	r8,r11,r9
80006a7e:	58 08       	cp.w	r8,0
80006a80:	e0 8a 00 13 	brle	80006aa6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006a84:	12 1b       	sub	r11,r9
80006a86:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006a8a:	18 9e       	mov	lr,r12
80006a8c:	58 0c       	cp.w	r12,0
80006a8e:	e0 8a 00 0c 	brle	80006aa6 <PrintHex+0x6e>
80006a92:	1a 9b       	mov	r11,sp
80006a94:	12 0b       	add	r11,r9
80006a96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006a98:	33 07       	mov	r7,48
80006a9a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006a9c:	2f f8       	sub	r8,-1
80006a9e:	1c 38       	cp.w	r8,lr
80006aa0:	cf d5       	brlt	80006a9a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006aa2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006aa6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006aaa:	f0 cb ff ff 	sub	r11,r8,-1
80006aae:	58 0b       	cp.w	r11,0
80006ab0:	e0 8a 00 19 	brle	80006ae2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ab4:	fa cb ff f4 	sub	r11,sp,-12
80006ab8:	f6 09 00 09 	add	r9,r11,r9
80006abc:	37 8b       	mov	r11,120
80006abe:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006ac2:	fa c9 ff f4 	sub	r9,sp,-12
80006ac6:	10 09       	add	r9,r8
80006ac8:	33 0b       	mov	r11,48
80006aca:	f3 6b ff f4 	st.b	r9[-12],r11
80006ace:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ad2:	fa ce 00 01 	sub	lr,sp,1
80006ad6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ad8:	11 8b       	ld.ub	r11,r8[0x0]
80006ada:	12 cb       	st.b	r9++,r11
80006adc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006ade:	1c 38       	cp.w	r8,lr
80006ae0:	cf c1       	brne	80006ad8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006ae2:	14 9c       	mov	r12,r10
80006ae4:	2f dd       	sub	sp,-12
80006ae6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006aea <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006aea:	d4 21       	pushm	r4-r7,lr
80006aec:	20 3d       	sub	sp,12
80006aee:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006af0:	30 06       	mov	r6,0
80006af2:	30 07       	mov	r7,0
80006af4:	fa e7 00 00 	st.d	sp[0],r6
80006af8:	30 0c       	mov	r12,0
80006afa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006afc:	58 08       	cp.w	r8,0
80006afe:	c0 35       	brlt	80006b04 <PrintDec+0x1a>
80006b00:	14 97       	mov	r7,r10
80006b02:	c0 58       	rjmp	80006b0c <PrintDec+0x22>
	{
		*p++ = '-';
80006b04:	14 97       	mov	r7,r10
80006b06:	32 d9       	mov	r9,45
80006b08:	0e c9       	st.b	r7++,r9
		i = -i;
80006b0a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006b0c:	58 08       	cp.w	r8,0
80006b0e:	c0 51       	brne	80006b18 <PrintDec+0x2e>
80006b10:	33 08       	mov	r8,48
80006b12:	ba 88       	st.b	sp[0x0],r8
80006b14:	30 1e       	mov	lr,1
80006b16:	c2 f8       	rjmp	80006b74 <PrintDec+0x8a>
	
	int ten = i%10;
80006b18:	e0 65 66 67 	mov	r5,26215
80006b1c:	ea 15 66 66 	orh	r5,0x6666
80006b20:	f0 05 04 44 	muls.d	r4,r8,r5
80006b24:	ea 0c 14 02 	asr	r12,r5,0x2
80006b28:	f0 09 14 1f 	asr	r9,r8,0x1f
80006b2c:	f8 09 01 09 	sub	r9,r12,r9
80006b30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006b34:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006b38:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006b3a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006b3c:	e0 66 66 67 	mov	r6,26215
80006b40:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006b44:	2d 09       	sub	r9,-48
80006b46:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006b4a:	2f fe       	sub	lr,-1
		i /= 10;
80006b4c:	f0 06 04 44 	muls.d	r4,r8,r6
80006b50:	ea 09 14 02 	asr	r9,r5,0x2
80006b54:	bf 58       	asr	r8,0x1f
80006b56:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006b5a:	f0 06 04 44 	muls.d	r4,r8,r6
80006b5e:	ea 09 14 02 	asr	r9,r5,0x2
80006b62:	f0 05 14 1f 	asr	r5,r8,0x1f
80006b66:	0a 19       	sub	r9,r5
80006b68:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006b6c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006b70:	58 08       	cp.w	r8,0
80006b72:	ce 91       	brne	80006b44 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006b74:	f6 0e 01 08 	sub	r8,r11,lr
80006b78:	58 08       	cp.w	r8,0
80006b7a:	e0 89 00 06 	brgt	80006b86 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006b7e:	58 0e       	cp.w	lr,0
80006b80:	e0 89 00 14 	brgt	80006ba8 <PrintDec+0xbe>
80006b84:	c1 d8       	rjmp	80006bbe <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006b86:	1c 1b       	sub	r11,lr
80006b88:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006b8a:	16 9c       	mov	r12,r11
80006b8c:	58 0b       	cp.w	r11,0
80006b8e:	fe 9a ff f8 	brle	80006b7e <PrintDec+0x94>
80006b92:	1a 99       	mov	r9,sp
80006b94:	1c 09       	add	r9,lr
80006b96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006b98:	33 06       	mov	r6,48
80006b9a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006b9c:	2f f8       	sub	r8,-1
80006b9e:	18 38       	cp.w	r8,r12
80006ba0:	cf d5       	brlt	80006b9a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006ba2:	f6 0e 00 0e 	add	lr,r11,lr
80006ba6:	ce cb       	rjmp	80006b7e <PrintDec+0x94>
80006ba8:	fa c8 ff f4 	sub	r8,sp,-12
80006bac:	1c 08       	add	r8,lr
80006bae:	20 d8       	sub	r8,13
80006bb0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006bb4:	11 89       	ld.ub	r9,r8[0x0]
80006bb6:	0e c9       	st.b	r7++,r9
80006bb8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006bba:	16 38       	cp.w	r8,r11
80006bbc:	cf c1       	brne	80006bb4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006bbe:	14 9c       	mov	r12,r10
80006bc0:	2f dd       	sub	sp,-12
80006bc2:	d8 22       	popm	r4-r7,pc

80006bc4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006bc4:	d4 31       	pushm	r0-r7,lr
80006bc6:	fa cd 02 08 	sub	sp,sp,520
80006bca:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006bcc:	e0 6a 01 00 	mov	r10,256
80006bd0:	30 0b       	mov	r11,0
80006bd2:	fa cc fe f8 	sub	r12,sp,-264
80006bd6:	f0 1f 00 4e 	mcall	80006d0c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006bda:	fa c4 fd d4 	sub	r4,sp,-556
80006bde:	30 0a       	mov	r10,0
80006be0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006be2:	fa c3 ff fc 	sub	r3,sp,-4
80006be6:	e0 61 01 00 	mov	r1,256
80006bea:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006bec:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006bee:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006bf2:	02 9a       	mov	r10,r1
80006bf4:	00 9b       	mov	r11,r0
80006bf6:	06 9c       	mov	r12,r3
80006bf8:	f0 1f 00 45 	mcall	80006d0c <log+0x148>
			
					if(*str == '%')
80006bfc:	0f 88       	ld.ub	r8,r7[0x0]
80006bfe:	e4 08 18 00 	cp.b	r8,r2
80006c02:	c5 71       	brne	80006cb0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006c04:	ee c8 ff ff 	sub	r8,r7,-1
80006c08:	11 89       	ld.ub	r9,r8[0x0]
80006c0a:	4c 2a       	lddpc	r10,80006d10 <log+0x14c>
80006c0c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006c0e:	23 09       	sub	r9,48
80006c10:	30 9a       	mov	r10,9
80006c12:	f4 09 18 00 	cp.b	r9,r10
80006c16:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006c1a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006c1e:	f7 b9 08 30 	subls	r9,48
80006c22:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006c26:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006c2a:	0f 88       	ld.ub	r8,r7[0x0]
80006c2c:	22 58       	sub	r8,37
80006c2e:	e0 48 00 53 	cp.w	r8,83
80006c32:	e0 8b 00 31 	brhi	80006c94 <log+0xd0>
80006c36:	4b 89       	lddpc	r9,80006d14 <log+0x150>
80006c38:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006c3c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006c40:	06 9a       	mov	r10,r3
80006c42:	40 0b       	lddsp	r11,sp[0x0]
80006c44:	5c 5b       	castu.b	r11
80006c46:	68 0c       	ld.w	r12,r4[0x0]
80006c48:	f0 1f 00 34 	mcall	80006d18 <log+0x154>
							break;
80006c4c:	c2 98       	rjmp	80006c9e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006c4e:	4b 4c       	lddpc	r12,80006d1c <log+0x158>
80006c50:	f0 1f 00 34 	mcall	80006d20 <log+0x15c>
80006c54:	08 95       	mov	r5,r4
80006c56:	06 9c       	mov	r12,r3
							break;
80006c58:	c2 38       	rjmp	80006c9e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006c5a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006c5e:	06 9a       	mov	r10,r3
80006c60:	40 0b       	lddsp	r11,sp[0x0]
80006c62:	5c 5b       	castu.b	r11
80006c64:	68 0c       	ld.w	r12,r4[0x0]
80006c66:	f0 1f 00 30 	mcall	80006d24 <log+0x160>
80006c6a:	06 9c       	mov	r12,r3
							break;
80006c6c:	c1 98       	rjmp	80006c9e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006c6e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006c72:	06 9b       	mov	r11,r3
80006c74:	09 bc       	ld.ub	r12,r4[0x3]
80006c76:	f0 1f 00 2d 	mcall	80006d28 <log+0x164>
80006c7a:	06 9c       	mov	r12,r3
							break;
80006c7c:	c1 18       	rjmp	80006c9e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006c7e:	e8 c5 ff fc 	sub	r5,r4,-4
80006c82:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006c84:	c0 d8       	rjmp	80006c9e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006c86:	06 9b       	mov	r11,r3
80006c88:	32 5c       	mov	r12,37
80006c8a:	f0 1f 00 28 	mcall	80006d28 <log+0x164>
80006c8e:	08 95       	mov	r5,r4
80006c90:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006c92:	c0 68       	rjmp	80006c9e <log+0xda>
							
							default:
							log("I need relax.");
80006c94:	4a 6c       	lddpc	r12,80006d2c <log+0x168>
80006c96:	f0 1f 00 23 	mcall	80006d20 <log+0x15c>
80006c9a:	08 95       	mov	r5,r4
80006c9c:	06 9c       	mov	r12,r3
						}
						str++;
80006c9e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006ca0:	1a dc       	st.w	--sp,r12
80006ca2:	1a d6       	st.w	--sp,r6
80006ca4:	4a 3b       	lddpc	r11,80006d30 <log+0x16c>
80006ca6:	0c 9c       	mov	r12,r6
80006ca8:	f0 1f 00 23 	mcall	80006d34 <log+0x170>
80006cac:	2f ed       	sub	sp,-8
80006cae:	c0 a8       	rjmp	80006cc2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006cb0:	2f f7       	sub	r7,-1
80006cb2:	1a d8       	st.w	--sp,r8
80006cb4:	1a d6       	st.w	--sp,r6
80006cb6:	4a 1b       	lddpc	r11,80006d38 <log+0x174>
80006cb8:	0c 9c       	mov	r12,r6
80006cba:	f0 1f 00 1f 	mcall	80006d34 <log+0x170>
80006cbe:	08 95       	mov	r5,r4
80006cc0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006cc2:	0f 89       	ld.ub	r9,r7[0x0]
80006cc4:	30 08       	mov	r8,0
80006cc6:	f0 09 18 00 	cp.b	r9,r8
80006cca:	c0 30       	breq	80006cd0 <log+0x10c>
80006ccc:	0a 94       	mov	r4,r5
80006cce:	c9 2b       	rjmp	80006bf2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006cd0:	fa c7 fe f8 	sub	r7,sp,-264
80006cd4:	1a d7       	st.w	--sp,r7
80006cd6:	49 ab       	lddpc	r11,80006d3c <log+0x178>
80006cd8:	0e 9c       	mov	r12,r7
80006cda:	f0 1f 00 17 	mcall	80006d34 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006cde:	5c 5c       	castu.b	r12
80006ce0:	f8 c6 ff ff 	sub	r6,r12,-1
80006ce4:	0c 9c       	mov	r12,r6
80006ce6:	f0 1f 00 17 	mcall	80006d40 <log+0x17c>
80006cea:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006cec:	0c 9a       	mov	r10,r6
80006cee:	0e 9b       	mov	r11,r7
80006cf0:	f0 1f 00 15 	mcall	80006d44 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006cf4:	30 09       	mov	r9,0
80006cf6:	30 5a       	mov	r10,5
80006cf8:	fa cb fe f8 	sub	r11,sp,-264
80006cfc:	49 38       	lddpc	r8,80006d48 <log+0x184>
80006cfe:	70 0c       	ld.w	r12,r8[0x0]
80006d00:	f0 1f 00 13 	mcall	80006d4c <log+0x188>
80006d04:	2f fd       	sub	sp,-4
	
	
}
80006d06:	fe 3d fd f8 	sub	sp,-520
80006d0a:	d8 32       	popm	r0-r7,pc
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	75 a0       	ld.w	r0,r10[0x68]
80006d10:	00 00       	add	r0,r0
80006d12:	0d 38       	ld.ub	r8,r6++
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	d4 c4       	*unknown*
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	6a ea       	ld.w	r10,r5[0x38]
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	d7 70       	acall	0x77
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	6b c4       	ld.w	r4,r5[0x70]
80006d24:	80 00       	ld.sh	r0,r0[0x0]
80006d26:	6a 38       	ld.w	r8,r5[0xc]
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	6a 34       	ld.w	r4,r5[0xc]
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	d7 80       	acall	0x78
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	d7 90       	acall	0x79
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	78 90       	ld.w	r0,r12[0x24]
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	d7 98       	*unknown*
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	d7 a0       	acall	0x7a
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	5c d8       	com	r8
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	74 58       	ld.w	r8,r10[0x14]
80006d48:	00 00       	add	r0,r0
80006d4a:	51 10       	stdsp	sp[0x44],r0
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	60 2c       	ld.w	r12,r0[0x8]

80006d50 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006d50:	d4 31       	pushm	r0-r7,lr
80006d52:	fa cd 02 0c 	sub	sp,sp,524
80006d56:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006d58:	e0 6a 01 00 	mov	r10,256
80006d5c:	30 0b       	mov	r11,0
80006d5e:	fa cc fe f4 	sub	r12,sp,-268
80006d62:	f0 1f 00 4c 	mcall	80006e90 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006d66:	fa c4 fd d0 	sub	r4,sp,-560
80006d6a:	30 0a       	mov	r10,0
80006d6c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d6e:	fa c3 ff fc 	sub	r3,sp,-4
80006d72:	e0 61 01 00 	mov	r1,256
80006d76:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006d78:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006d7a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d7e:	02 9a       	mov	r10,r1
80006d80:	00 9b       	mov	r11,r0
80006d82:	06 9c       	mov	r12,r3
80006d84:	f0 1f 00 43 	mcall	80006e90 <logFromISR+0x140>
			
			if(*str == '%')
80006d88:	0f 88       	ld.ub	r8,r7[0x0]
80006d8a:	e4 08 18 00 	cp.b	r8,r2
80006d8e:	c5 11       	brne	80006e30 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006d90:	ee c8 ff ff 	sub	r8,r7,-1
80006d94:	11 89       	ld.ub	r9,r8[0x0]
80006d96:	4c 0a       	lddpc	r10,80006e94 <logFromISR+0x144>
80006d98:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006d9a:	23 09       	sub	r9,48
80006d9c:	30 9a       	mov	r10,9
80006d9e:	f4 09 18 00 	cp.b	r9,r10
80006da2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006da6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006daa:	f7 b9 08 30 	subls	r9,48
80006dae:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006db2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006db6:	0f 88       	ld.ub	r8,r7[0x0]
80006db8:	22 58       	sub	r8,37
80006dba:	e0 48 00 53 	cp.w	r8,83
80006dbe:	e0 8b 00 2b 	brhi	80006e14 <logFromISR+0xc4>
80006dc2:	4b 69       	lddpc	r9,80006e98 <logFromISR+0x148>
80006dc4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006dc8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006dcc:	06 9a       	mov	r10,r3
80006dce:	40 0b       	lddsp	r11,sp[0x0]
80006dd0:	5c 5b       	castu.b	r11
80006dd2:	68 0c       	ld.w	r12,r4[0x0]
80006dd4:	f0 1f 00 32 	mcall	80006e9c <logFromISR+0x14c>
					break;
80006dd8:	c2 38       	rjmp	80006e1e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006dda:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006dde:	06 9a       	mov	r10,r3
80006de0:	40 0b       	lddsp	r11,sp[0x0]
80006de2:	5c 5b       	castu.b	r11
80006de4:	68 0c       	ld.w	r12,r4[0x0]
80006de6:	f0 1f 00 2f 	mcall	80006ea0 <logFromISR+0x150>
80006dea:	06 9c       	mov	r12,r3
					break;
80006dec:	c1 98       	rjmp	80006e1e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006dee:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006df2:	06 9b       	mov	r11,r3
80006df4:	09 bc       	ld.ub	r12,r4[0x3]
80006df6:	f0 1f 00 2c 	mcall	80006ea4 <logFromISR+0x154>
80006dfa:	06 9c       	mov	r12,r3
					break;
80006dfc:	c1 18       	rjmp	80006e1e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006dfe:	e8 c5 ff fc 	sub	r5,r4,-4
80006e02:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006e04:	c0 d8       	rjmp	80006e1e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006e06:	06 9b       	mov	r11,r3
80006e08:	32 5c       	mov	r12,37
80006e0a:	f0 1f 00 27 	mcall	80006ea4 <logFromISR+0x154>
80006e0e:	08 95       	mov	r5,r4
80006e10:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006e12:	c0 68       	rjmp	80006e1e <logFromISR+0xce>
					default:
					log("I need relax.");
80006e14:	4a 5c       	lddpc	r12,80006ea8 <logFromISR+0x158>
80006e16:	f0 1f 00 26 	mcall	80006eac <logFromISR+0x15c>
80006e1a:	08 95       	mov	r5,r4
80006e1c:	06 9c       	mov	r12,r3
				}
				str++;
80006e1e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e20:	1a dc       	st.w	--sp,r12
80006e22:	1a d6       	st.w	--sp,r6
80006e24:	4a 3b       	lddpc	r11,80006eb0 <logFromISR+0x160>
80006e26:	0c 9c       	mov	r12,r6
80006e28:	f0 1f 00 23 	mcall	80006eb4 <logFromISR+0x164>
80006e2c:	2f ed       	sub	sp,-8
80006e2e:	c0 a8       	rjmp	80006e42 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e30:	2f f7       	sub	r7,-1
80006e32:	1a d8       	st.w	--sp,r8
80006e34:	1a d6       	st.w	--sp,r6
80006e36:	4a 1b       	lddpc	r11,80006eb8 <logFromISR+0x168>
80006e38:	0c 9c       	mov	r12,r6
80006e3a:	f0 1f 00 1f 	mcall	80006eb4 <logFromISR+0x164>
80006e3e:	08 95       	mov	r5,r4
80006e40:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006e42:	0f 89       	ld.ub	r9,r7[0x0]
80006e44:	30 08       	mov	r8,0
80006e46:	f0 09 18 00 	cp.b	r9,r8
80006e4a:	c0 30       	breq	80006e50 <logFromISR+0x100>
80006e4c:	0a 94       	mov	r4,r5
80006e4e:	c9 8b       	rjmp	80006d7e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006e50:	fa c7 fe f4 	sub	r7,sp,-268
80006e54:	1a d7       	st.w	--sp,r7
80006e56:	49 ab       	lddpc	r11,80006ebc <logFromISR+0x16c>
80006e58:	0e 9c       	mov	r12,r7
80006e5a:	f0 1f 00 17 	mcall	80006eb4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006e5e:	5c 5c       	castu.b	r12
80006e60:	f8 c6 ff ff 	sub	r6,r12,-1
80006e64:	0c 9c       	mov	r12,r6
80006e66:	f0 1f 00 17 	mcall	80006ec0 <logFromISR+0x170>
80006e6a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006e6c:	0c 9a       	mov	r10,r6
80006e6e:	0e 9b       	mov	r11,r7
80006e70:	f0 1f 00 15 	mcall	80006ec4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006e74:	30 09       	mov	r9,0
80006e76:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006e78:	fa ca fe f8 	sub	r10,sp,-264
80006e7c:	fa cb fe f4 	sub	r11,sp,-268
80006e80:	49 28       	lddpc	r8,80006ec8 <logFromISR+0x178>
80006e82:	70 0c       	ld.w	r12,r8[0x0]
80006e84:	f0 1f 00 12 	mcall	80006ecc <logFromISR+0x17c>
80006e88:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006e8a:	fe 3d fd f4 	sub	sp,-524
80006e8e:	d8 32       	popm	r0-r7,pc
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	75 a0       	ld.w	r0,r10[0x68]
80006e94:	00 00       	add	r0,r0
80006e96:	0d 39       	ld.ub	r9,r6++
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	d6 14       	*unknown*
80006e9c:	80 00       	ld.sh	r0,r0[0x0]
80006e9e:	6a ea       	ld.w	r10,r5[0x38]
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	6a 38       	ld.w	r8,r5[0xc]
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	6a 34       	ld.w	r4,r5[0xc]
80006ea8:	80 00       	ld.sh	r0,r0[0x0]
80006eaa:	d7 80       	acall	0x78
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	6b c4       	ld.w	r4,r5[0x70]
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	d7 90       	acall	0x79
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	78 90       	ld.w	r0,r12[0x24]
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	d7 98       	*unknown*
80006ebc:	80 00       	ld.sh	r0,r0[0x0]
80006ebe:	d7 a0       	acall	0x7a
80006ec0:	80 00       	ld.sh	r0,r0[0x0]
80006ec2:	5c d8       	com	r8
80006ec4:	80 00       	ld.sh	r0,r0[0x0]
80006ec6:	74 58       	ld.w	r8,r10[0x14]
80006ec8:	00 00       	add	r0,r0
80006eca:	51 10       	stdsp	sp[0x44],r0
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	5f dc       	srvc	r12

80006ed0 <log_init>:
		
	return str;
}

void log_init(void)
{
80006ed0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006ed2:	30 2b       	mov	r11,2
80006ed4:	49 0c       	lddpc	r12,80006f14 <log_init+0x44>
80006ed6:	f0 1f 00 11 	mcall	80006f18 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006eda:	e0 6a 36 00 	mov	r10,13824
80006ede:	ea 1a 01 6e 	orh	r10,0x16e
80006ee2:	48 fb       	lddpc	r11,80006f1c <log_init+0x4c>
80006ee4:	fe 7c 18 00 	mov	r12,-59392
80006ee8:	f0 1f 00 0e 	mcall	80006f20 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006eec:	30 4b       	mov	r11,4
80006eee:	33 2c       	mov	r12,50
80006ef0:	f0 1f 00 0d 	mcall	80006f24 <log_init+0x54>
80006ef4:	48 d8       	lddpc	r8,80006f28 <log_init+0x58>
80006ef6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006ef8:	30 09       	mov	r9,0
80006efa:	1a d9       	st.w	--sp,r9
80006efc:	1a d9       	st.w	--sp,r9
80006efe:	1a d9       	st.w	--sp,r9
80006f00:	30 28       	mov	r8,2
80006f02:	e0 6a 01 80 	mov	r10,384
80006f06:	48 ab       	lddpc	r11,80006f2c <log_init+0x5c>
80006f08:	48 ac       	lddpc	r12,80006f30 <log_init+0x60>
80006f0a:	f0 1f 00 0b 	mcall	80006f34 <log_init+0x64>
80006f0e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006f10:	d8 02       	popm	pc
80006f12:	00 00       	add	r0,r0
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	d7 ac       	*unknown*
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	53 08       	stdsp	sp[0xc0],r8
80006f1c:	80 00       	ld.sh	r0,r0[0x0]
80006f1e:	d7 64       	*unknown*
80006f20:	80 00       	ld.sh	r0,r0[0x0]
80006f22:	58 3c       	cp.w	r12,3
80006f24:	80 00       	ld.sh	r0,r0[0x0]
80006f26:	61 2c       	ld.w	r12,r0[0x48]
80006f28:	00 00       	add	r0,r0
80006f2a:	51 10       	stdsp	sp[0x44],r0
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	d7 a8       	*unknown*
80006f30:	80 00       	ld.sh	r0,r0[0x0]
80006f32:	6f 38       	ld.w	r8,r7[0x4c]
80006f34:	80 00       	ld.sh	r0,r0[0x0]
80006f36:	68 00       	ld.w	r0,r4[0x0]

80006f38 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006f38:	eb cd 40 f8 	pushm	r3-r7,lr
80006f3c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006f3e:	48 c7       	lddpc	r7,80006f6c <task_log+0x34>
80006f40:	30 05       	mov	r5,0
80006f42:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006f44:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006f48:	0a 99       	mov	r9,r5
80006f4a:	08 9a       	mov	r10,r4
80006f4c:	1a 9b       	mov	r11,sp
80006f4e:	6e 0c       	ld.w	r12,r7[0x0]
80006f50:	f0 1f 00 08 	mcall	80006f70 <task_log+0x38>
80006f54:	58 1c       	cp.w	r12,1
80006f56:	cf 91       	brne	80006f48 <task_log+0x10>
		{
			if( NULL != str)
80006f58:	40 0b       	lddsp	r11,sp[0x0]
80006f5a:	58 0b       	cp.w	r11,0
80006f5c:	cf 60       	breq	80006f48 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006f5e:	06 9c       	mov	r12,r3
80006f60:	f0 1f 00 05 	mcall	80006f74 <task_log+0x3c>
				vPortFree(str);
80006f64:	40 0c       	lddsp	r12,sp[0x0]
80006f66:	f0 1f 00 05 	mcall	80006f78 <task_log+0x40>
80006f6a:	ce fb       	rjmp	80006f48 <task_log+0x10>
80006f6c:	00 00       	add	r0,r0
80006f6e:	51 10       	stdsp	sp[0x44],r0
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	5e 20       	reths	r0
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	57 ec       	stdsp	sp[0x1f8],r12
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	5c b0       	swap.b	r0

80006f7c <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006f7c:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006f7e:	fe 78 10 00 	mov	r8,-61440
80006f82:	30 19       	mov	r9,1
80006f84:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006f88:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006f8c:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006f90:	d3 03       	ssrf	0x10
	local_start_pll0();
80006f92:	f0 1f 00 12 	mcall	80006fd8 <main+0x5c>
		
	INTC_init_interrupts();
80006f96:	f0 1f 00 12 	mcall	80006fdc <main+0x60>
		
	log_init();
80006f9a:	f0 1f 00 12 	mcall	80006fe0 <main+0x64>
	log("----start debug----");
80006f9e:	49 2c       	lddpc	r12,80006fe4 <main+0x68>
80006fa0:	f0 1f 00 12 	mcall	80006fe8 <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006fa4:	f0 1f 00 12 	mcall	80006fec <main+0x70>
		
	app_init();
80006fa8:	f0 1f 00 12 	mcall	80006ff0 <main+0x74>
		
	xcmp_init();
80006fac:	f0 1f 00 12 	mcall	80006ff4 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006fb0:	fe 79 10 00 	mov	r9,-61440
80006fb4:	f2 f8 01 60 	ld.w	r8,r9[352]
80006fb8:	e2 18 00 02 	andl	r8,0x2,COH
80006fbc:	cf c0       	breq	80006fb4 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006fbe:	fe 79 10 00 	mov	r9,-61440
80006fc2:	f2 f8 01 60 	ld.w	r8,r9[352]
80006fc6:	e2 18 00 02 	andl	r8,0x2,COH
80006fca:	cf c1       	brne	80006fc2 <main+0x46>
	local_start_timer();
80006fcc:	f0 1f 00 0b 	mcall	80006ff8 <main+0x7c>
		
	Enable_global_interrupt();
80006fd0:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006fd2:	f0 1f 00 0b 	mcall	80006ffc <main+0x80>
	return 0;
	
}
80006fd6:	d8 0a       	popm	pc,r12=0
80006fd8:	80 00       	ld.sh	r0,r0[0x0]
80006fda:	52 2c       	stdsp	sp[0x88],r12
80006fdc:	80 00       	ld.sh	r0,r0[0x0]
80006fde:	54 0c       	stdsp	sp[0x100],r12
80006fe0:	80 00       	ld.sh	r0,r0[0x0]
80006fe2:	6e d0       	ld.w	r0,r7[0x34]
80006fe4:	80 00       	ld.sh	r0,r0[0x0]
80006fe6:	d7 bc       	*unknown*
80006fe8:	80 00       	ld.sh	r0,r0[0x0]
80006fea:	6b c4       	ld.w	r4,r5[0x70]
80006fec:	80 00       	ld.sh	r0,r0[0x0]
80006fee:	51 dc       	stdsp	sp[0x74],r12
80006ff0:	80 00       	ld.sh	r0,r0[0x0]
80006ff2:	20 3c       	sub	r12,3
80006ff4:	80 00       	ld.sh	r0,r0[0x0]
80006ff6:	42 28       	lddsp	r8,sp[0x88]
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	52 7c       	stdsp	sp[0x9c],r12
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	69 e8       	ld.w	r8,r4[0x78]

80007000 <free>:
80007000:	d4 01       	pushm	lr
80007002:	e0 68 0a 2c 	mov	r8,2604
80007006:	18 9b       	mov	r11,r12
80007008:	70 0c       	ld.w	r12,r8[0x0]
8000700a:	e0 a0 1e 61 	rcall	8000accc <_free_r>
8000700e:	d8 02       	popm	pc

80007010 <malloc>:
80007010:	d4 01       	pushm	lr
80007012:	e0 68 0a 2c 	mov	r8,2604
80007016:	18 9b       	mov	r11,r12
80007018:	70 0c       	ld.w	r12,r8[0x0]
8000701a:	c0 3c       	rcall	80007020 <_malloc_r>
8000701c:	d8 02       	popm	pc
8000701e:	d7 03       	nop

80007020 <_malloc_r>:
80007020:	d4 31       	pushm	r0-r7,lr
80007022:	f6 c8 ff f5 	sub	r8,r11,-11
80007026:	18 95       	mov	r5,r12
80007028:	10 97       	mov	r7,r8
8000702a:	e0 17 ff f8 	andl	r7,0xfff8
8000702e:	59 68       	cp.w	r8,22
80007030:	f9 b7 08 10 	movls	r7,16
80007034:	16 37       	cp.w	r7,r11
80007036:	5f 38       	srlo	r8
80007038:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000703c:	c0 50       	breq	80007046 <_malloc_r+0x26>
8000703e:	30 c8       	mov	r8,12
80007040:	99 38       	st.w	r12[0xc],r8
80007042:	e0 8f 01 fa 	bral	80007436 <_malloc_r+0x416>
80007046:	fe b0 f5 eb 	rcall	80005c1c <__malloc_lock>
8000704a:	e0 47 01 f7 	cp.w	r7,503
8000704e:	e0 8b 00 1d 	brhi	80007088 <_malloc_r+0x68>
80007052:	ee 03 16 03 	lsr	r3,r7,0x3
80007056:	e0 68 05 2c 	mov	r8,1324
8000705a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000705e:	70 36       	ld.w	r6,r8[0xc]
80007060:	10 36       	cp.w	r6,r8
80007062:	c0 61       	brne	8000706e <_malloc_r+0x4e>
80007064:	ec c8 ff f8 	sub	r8,r6,-8
80007068:	70 36       	ld.w	r6,r8[0xc]
8000706a:	10 36       	cp.w	r6,r8
8000706c:	c0 c0       	breq	80007084 <_malloc_r+0x64>
8000706e:	6c 18       	ld.w	r8,r6[0x4]
80007070:	e0 18 ff fc 	andl	r8,0xfffc
80007074:	6c 3a       	ld.w	r10,r6[0xc]
80007076:	ec 08 00 09 	add	r9,r6,r8
8000707a:	0a 9c       	mov	r12,r5
8000707c:	6c 28       	ld.w	r8,r6[0x8]
8000707e:	95 28       	st.w	r10[0x8],r8
80007080:	91 3a       	st.w	r8[0xc],r10
80007082:	c4 78       	rjmp	80007110 <_malloc_r+0xf0>
80007084:	2f e3       	sub	r3,-2
80007086:	c4 d8       	rjmp	80007120 <_malloc_r+0x100>
80007088:	ee 03 16 09 	lsr	r3,r7,0x9
8000708c:	c0 41       	brne	80007094 <_malloc_r+0x74>
8000708e:	ee 03 16 03 	lsr	r3,r7,0x3
80007092:	c2 68       	rjmp	800070de <_malloc_r+0xbe>
80007094:	58 43       	cp.w	r3,4
80007096:	e0 8b 00 06 	brhi	800070a2 <_malloc_r+0x82>
8000709a:	ee 03 16 06 	lsr	r3,r7,0x6
8000709e:	2c 83       	sub	r3,-56
800070a0:	c1 f8       	rjmp	800070de <_malloc_r+0xbe>
800070a2:	59 43       	cp.w	r3,20
800070a4:	e0 8b 00 04 	brhi	800070ac <_malloc_r+0x8c>
800070a8:	2a 53       	sub	r3,-91
800070aa:	c1 a8       	rjmp	800070de <_malloc_r+0xbe>
800070ac:	e0 43 00 54 	cp.w	r3,84
800070b0:	e0 8b 00 06 	brhi	800070bc <_malloc_r+0x9c>
800070b4:	ee 03 16 0c 	lsr	r3,r7,0xc
800070b8:	29 23       	sub	r3,-110
800070ba:	c1 28       	rjmp	800070de <_malloc_r+0xbe>
800070bc:	e0 43 01 54 	cp.w	r3,340
800070c0:	e0 8b 00 06 	brhi	800070cc <_malloc_r+0xac>
800070c4:	ee 03 16 0f 	lsr	r3,r7,0xf
800070c8:	28 93       	sub	r3,-119
800070ca:	c0 a8       	rjmp	800070de <_malloc_r+0xbe>
800070cc:	e0 43 05 54 	cp.w	r3,1364
800070d0:	e0 88 00 04 	brls	800070d8 <_malloc_r+0xb8>
800070d4:	37 e3       	mov	r3,126
800070d6:	c0 48       	rjmp	800070de <_malloc_r+0xbe>
800070d8:	ee 03 16 12 	lsr	r3,r7,0x12
800070dc:	28 43       	sub	r3,-124
800070de:	e0 6a 05 2c 	mov	r10,1324
800070e2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800070e6:	74 36       	ld.w	r6,r10[0xc]
800070e8:	c1 98       	rjmp	8000711a <_malloc_r+0xfa>
800070ea:	6c 19       	ld.w	r9,r6[0x4]
800070ec:	e0 19 ff fc 	andl	r9,0xfffc
800070f0:	f2 07 01 0b 	sub	r11,r9,r7
800070f4:	58 fb       	cp.w	r11,15
800070f6:	e0 8a 00 04 	brle	800070fe <_malloc_r+0xde>
800070fa:	20 13       	sub	r3,1
800070fc:	c1 18       	rjmp	8000711e <_malloc_r+0xfe>
800070fe:	6c 38       	ld.w	r8,r6[0xc]
80007100:	58 0b       	cp.w	r11,0
80007102:	c0 b5       	brlt	80007118 <_malloc_r+0xf8>
80007104:	6c 2a       	ld.w	r10,r6[0x8]
80007106:	ec 09 00 09 	add	r9,r6,r9
8000710a:	0a 9c       	mov	r12,r5
8000710c:	91 2a       	st.w	r8[0x8],r10
8000710e:	95 38       	st.w	r10[0xc],r8
80007110:	72 18       	ld.w	r8,r9[0x4]
80007112:	a1 a8       	sbr	r8,0x0
80007114:	93 18       	st.w	r9[0x4],r8
80007116:	cb c8       	rjmp	8000728e <_malloc_r+0x26e>
80007118:	10 96       	mov	r6,r8
8000711a:	14 36       	cp.w	r6,r10
8000711c:	ce 71       	brne	800070ea <_malloc_r+0xca>
8000711e:	2f f3       	sub	r3,-1
80007120:	e0 6a 05 2c 	mov	r10,1324
80007124:	f4 cc ff f8 	sub	r12,r10,-8
80007128:	78 26       	ld.w	r6,r12[0x8]
8000712a:	18 36       	cp.w	r6,r12
8000712c:	c6 c0       	breq	80007204 <_malloc_r+0x1e4>
8000712e:	6c 19       	ld.w	r9,r6[0x4]
80007130:	e0 19 ff fc 	andl	r9,0xfffc
80007134:	f2 07 01 08 	sub	r8,r9,r7
80007138:	58 f8       	cp.w	r8,15
8000713a:	e0 89 00 8f 	brgt	80007258 <_malloc_r+0x238>
8000713e:	99 3c       	st.w	r12[0xc],r12
80007140:	99 2c       	st.w	r12[0x8],r12
80007142:	58 08       	cp.w	r8,0
80007144:	c0 55       	brlt	8000714e <_malloc_r+0x12e>
80007146:	ec 09 00 09 	add	r9,r6,r9
8000714a:	0a 9c       	mov	r12,r5
8000714c:	ce 2b       	rjmp	80007110 <_malloc_r+0xf0>
8000714e:	e0 49 01 ff 	cp.w	r9,511
80007152:	e0 8b 00 13 	brhi	80007178 <_malloc_r+0x158>
80007156:	a3 99       	lsr	r9,0x3
80007158:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000715c:	70 2b       	ld.w	r11,r8[0x8]
8000715e:	8d 38       	st.w	r6[0xc],r8
80007160:	8d 2b       	st.w	r6[0x8],r11
80007162:	97 36       	st.w	r11[0xc],r6
80007164:	91 26       	st.w	r8[0x8],r6
80007166:	a3 49       	asr	r9,0x2
80007168:	74 18       	ld.w	r8,r10[0x4]
8000716a:	30 1b       	mov	r11,1
8000716c:	f6 09 09 49 	lsl	r9,r11,r9
80007170:	f1 e9 10 09 	or	r9,r8,r9
80007174:	95 19       	st.w	r10[0x4],r9
80007176:	c4 78       	rjmp	80007204 <_malloc_r+0x1e4>
80007178:	f2 0a 16 09 	lsr	r10,r9,0x9
8000717c:	58 4a       	cp.w	r10,4
8000717e:	e0 8b 00 07 	brhi	8000718c <_malloc_r+0x16c>
80007182:	f2 0a 16 06 	lsr	r10,r9,0x6
80007186:	2c 8a       	sub	r10,-56
80007188:	c2 08       	rjmp	800071c8 <_malloc_r+0x1a8>
8000718a:	d7 03       	nop
8000718c:	59 4a       	cp.w	r10,20
8000718e:	e0 8b 00 04 	brhi	80007196 <_malloc_r+0x176>
80007192:	2a 5a       	sub	r10,-91
80007194:	c1 a8       	rjmp	800071c8 <_malloc_r+0x1a8>
80007196:	e0 4a 00 54 	cp.w	r10,84
8000719a:	e0 8b 00 06 	brhi	800071a6 <_malloc_r+0x186>
8000719e:	f2 0a 16 0c 	lsr	r10,r9,0xc
800071a2:	29 2a       	sub	r10,-110
800071a4:	c1 28       	rjmp	800071c8 <_malloc_r+0x1a8>
800071a6:	e0 4a 01 54 	cp.w	r10,340
800071aa:	e0 8b 00 06 	brhi	800071b6 <_malloc_r+0x196>
800071ae:	f2 0a 16 0f 	lsr	r10,r9,0xf
800071b2:	28 9a       	sub	r10,-119
800071b4:	c0 a8       	rjmp	800071c8 <_malloc_r+0x1a8>
800071b6:	e0 4a 05 54 	cp.w	r10,1364
800071ba:	e0 88 00 04 	brls	800071c2 <_malloc_r+0x1a2>
800071be:	37 ea       	mov	r10,126
800071c0:	c0 48       	rjmp	800071c8 <_malloc_r+0x1a8>
800071c2:	f2 0a 16 12 	lsr	r10,r9,0x12
800071c6:	28 4a       	sub	r10,-124
800071c8:	e0 6b 05 2c 	mov	r11,1324
800071cc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800071d0:	68 28       	ld.w	r8,r4[0x8]
800071d2:	08 38       	cp.w	r8,r4
800071d4:	c0 e1       	brne	800071f0 <_malloc_r+0x1d0>
800071d6:	76 19       	ld.w	r9,r11[0x4]
800071d8:	a3 4a       	asr	r10,0x2
800071da:	30 1e       	mov	lr,1
800071dc:	fc 0a 09 4a 	lsl	r10,lr,r10
800071e0:	f3 ea 10 0a 	or	r10,r9,r10
800071e4:	10 99       	mov	r9,r8
800071e6:	97 1a       	st.w	r11[0x4],r10
800071e8:	c0 a8       	rjmp	800071fc <_malloc_r+0x1dc>
800071ea:	70 28       	ld.w	r8,r8[0x8]
800071ec:	08 38       	cp.w	r8,r4
800071ee:	c0 60       	breq	800071fa <_malloc_r+0x1da>
800071f0:	70 1a       	ld.w	r10,r8[0x4]
800071f2:	e0 1a ff fc 	andl	r10,0xfffc
800071f6:	14 39       	cp.w	r9,r10
800071f8:	cf 93       	brcs	800071ea <_malloc_r+0x1ca>
800071fa:	70 39       	ld.w	r9,r8[0xc]
800071fc:	8d 39       	st.w	r6[0xc],r9
800071fe:	8d 28       	st.w	r6[0x8],r8
80007200:	91 36       	st.w	r8[0xc],r6
80007202:	93 26       	st.w	r9[0x8],r6
80007204:	e6 08 14 02 	asr	r8,r3,0x2
80007208:	30 1b       	mov	r11,1
8000720a:	e0 64 05 2c 	mov	r4,1324
8000720e:	f6 08 09 4b 	lsl	r11,r11,r8
80007212:	68 18       	ld.w	r8,r4[0x4]
80007214:	10 3b       	cp.w	r11,r8
80007216:	e0 8b 00 6b 	brhi	800072ec <_malloc_r+0x2cc>
8000721a:	f7 e8 00 09 	and	r9,r11,r8
8000721e:	c0 b1       	brne	80007234 <_malloc_r+0x214>
80007220:	e0 13 ff fc 	andl	r3,0xfffc
80007224:	a1 7b       	lsl	r11,0x1
80007226:	2f c3       	sub	r3,-4
80007228:	c0 38       	rjmp	8000722e <_malloc_r+0x20e>
8000722a:	2f c3       	sub	r3,-4
8000722c:	a1 7b       	lsl	r11,0x1
8000722e:	f7 e8 00 09 	and	r9,r11,r8
80007232:	cf c0       	breq	8000722a <_malloc_r+0x20a>
80007234:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007238:	06 92       	mov	r2,r3
8000723a:	1c 91       	mov	r1,lr
8000723c:	62 36       	ld.w	r6,r1[0xc]
8000723e:	c2 e8       	rjmp	8000729a <_malloc_r+0x27a>
80007240:	6c 1a       	ld.w	r10,r6[0x4]
80007242:	e0 1a ff fc 	andl	r10,0xfffc
80007246:	f4 07 01 08 	sub	r8,r10,r7
8000724a:	58 f8       	cp.w	r8,15
8000724c:	e0 8a 00 15 	brle	80007276 <_malloc_r+0x256>
80007250:	6c 3a       	ld.w	r10,r6[0xc]
80007252:	6c 29       	ld.w	r9,r6[0x8]
80007254:	95 29       	st.w	r10[0x8],r9
80007256:	93 3a       	st.w	r9[0xc],r10
80007258:	0e 99       	mov	r9,r7
8000725a:	ec 07 00 07 	add	r7,r6,r7
8000725e:	a1 a9       	sbr	r9,0x0
80007260:	99 37       	st.w	r12[0xc],r7
80007262:	99 27       	st.w	r12[0x8],r7
80007264:	8d 19       	st.w	r6[0x4],r9
80007266:	ee 08 09 08 	st.w	r7[r8],r8
8000726a:	8f 2c       	st.w	r7[0x8],r12
8000726c:	8f 3c       	st.w	r7[0xc],r12
8000726e:	a1 a8       	sbr	r8,0x0
80007270:	0a 9c       	mov	r12,r5
80007272:	8f 18       	st.w	r7[0x4],r8
80007274:	c0 d8       	rjmp	8000728e <_malloc_r+0x26e>
80007276:	6c 39       	ld.w	r9,r6[0xc]
80007278:	58 08       	cp.w	r8,0
8000727a:	c0 f5       	brlt	80007298 <_malloc_r+0x278>
8000727c:	ec 0a 00 0a 	add	r10,r6,r10
80007280:	74 18       	ld.w	r8,r10[0x4]
80007282:	a1 a8       	sbr	r8,0x0
80007284:	0a 9c       	mov	r12,r5
80007286:	95 18       	st.w	r10[0x4],r8
80007288:	6c 28       	ld.w	r8,r6[0x8]
8000728a:	93 28       	st.w	r9[0x8],r8
8000728c:	91 39       	st.w	r8[0xc],r9
8000728e:	fe b0 f4 cd 	rcall	80005c28 <__malloc_unlock>
80007292:	ec cc ff f8 	sub	r12,r6,-8
80007296:	d8 32       	popm	r0-r7,pc
80007298:	12 96       	mov	r6,r9
8000729a:	02 36       	cp.w	r6,r1
8000729c:	cd 21       	brne	80007240 <_malloc_r+0x220>
8000729e:	2f f2       	sub	r2,-1
800072a0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800072a4:	c0 30       	breq	800072aa <_malloc_r+0x28a>
800072a6:	2f 81       	sub	r1,-8
800072a8:	cc ab       	rjmp	8000723c <_malloc_r+0x21c>
800072aa:	1c 98       	mov	r8,lr
800072ac:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800072b0:	c0 81       	brne	800072c0 <_malloc_r+0x2a0>
800072b2:	68 19       	ld.w	r9,r4[0x4]
800072b4:	f6 08 11 ff 	rsub	r8,r11,-1
800072b8:	f3 e8 00 08 	and	r8,r9,r8
800072bc:	89 18       	st.w	r4[0x4],r8
800072be:	c0 78       	rjmp	800072cc <_malloc_r+0x2ac>
800072c0:	f0 c9 00 08 	sub	r9,r8,8
800072c4:	20 13       	sub	r3,1
800072c6:	70 08       	ld.w	r8,r8[0x0]
800072c8:	12 38       	cp.w	r8,r9
800072ca:	cf 10       	breq	800072ac <_malloc_r+0x28c>
800072cc:	a1 7b       	lsl	r11,0x1
800072ce:	68 18       	ld.w	r8,r4[0x4]
800072d0:	10 3b       	cp.w	r11,r8
800072d2:	e0 8b 00 0d 	brhi	800072ec <_malloc_r+0x2cc>
800072d6:	58 0b       	cp.w	r11,0
800072d8:	c0 a0       	breq	800072ec <_malloc_r+0x2cc>
800072da:	04 93       	mov	r3,r2
800072dc:	c0 38       	rjmp	800072e2 <_malloc_r+0x2c2>
800072de:	2f c3       	sub	r3,-4
800072e0:	a1 7b       	lsl	r11,0x1
800072e2:	f7 e8 00 09 	and	r9,r11,r8
800072e6:	ca 71       	brne	80007234 <_malloc_r+0x214>
800072e8:	cf bb       	rjmp	800072de <_malloc_r+0x2be>
800072ea:	d7 03       	nop
800072ec:	68 23       	ld.w	r3,r4[0x8]
800072ee:	66 12       	ld.w	r2,r3[0x4]
800072f0:	e0 12 ff fc 	andl	r2,0xfffc
800072f4:	0e 32       	cp.w	r2,r7
800072f6:	5f 39       	srlo	r9
800072f8:	e4 07 01 08 	sub	r8,r2,r7
800072fc:	58 f8       	cp.w	r8,15
800072fe:	5f aa       	srle	r10
80007300:	f5 e9 10 09 	or	r9,r10,r9
80007304:	e0 80 00 9a 	breq	80007438 <_malloc_r+0x418>
80007308:	e0 68 0d 44 	mov	r8,3396
8000730c:	70 01       	ld.w	r1,r8[0x0]
8000730e:	e0 68 09 38 	mov	r8,2360
80007312:	2f 01       	sub	r1,-16
80007314:	70 08       	ld.w	r8,r8[0x0]
80007316:	0e 01       	add	r1,r7
80007318:	5b f8       	cp.w	r8,-1
8000731a:	c0 40       	breq	80007322 <_malloc_r+0x302>
8000731c:	28 11       	sub	r1,-127
8000731e:	e0 11 ff 80 	andl	r1,0xff80
80007322:	02 9b       	mov	r11,r1
80007324:	0a 9c       	mov	r12,r5
80007326:	e0 a0 02 a5 	rcall	80007870 <_sbrk_r>
8000732a:	18 96       	mov	r6,r12
8000732c:	5b fc       	cp.w	r12,-1
8000732e:	c7 50       	breq	80007418 <_malloc_r+0x3f8>
80007330:	e6 02 00 08 	add	r8,r3,r2
80007334:	10 3c       	cp.w	r12,r8
80007336:	c0 32       	brcc	8000733c <_malloc_r+0x31c>
80007338:	08 33       	cp.w	r3,r4
8000733a:	c6 f1       	brne	80007418 <_malloc_r+0x3f8>
8000733c:	e0 6a 0d 48 	mov	r10,3400
80007340:	74 09       	ld.w	r9,r10[0x0]
80007342:	e2 09 00 09 	add	r9,r1,r9
80007346:	95 09       	st.w	r10[0x0],r9
80007348:	10 36       	cp.w	r6,r8
8000734a:	c0 a1       	brne	8000735e <_malloc_r+0x33e>
8000734c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007350:	c0 71       	brne	8000735e <_malloc_r+0x33e>
80007352:	e2 02 00 02 	add	r2,r1,r2
80007356:	68 28       	ld.w	r8,r4[0x8]
80007358:	a1 a2       	sbr	r2,0x0
8000735a:	91 12       	st.w	r8[0x4],r2
8000735c:	c4 f8       	rjmp	800073fa <_malloc_r+0x3da>
8000735e:	e0 6a 09 38 	mov	r10,2360
80007362:	74 0b       	ld.w	r11,r10[0x0]
80007364:	5b fb       	cp.w	r11,-1
80007366:	c0 31       	brne	8000736c <_malloc_r+0x34c>
80007368:	95 06       	st.w	r10[0x0],r6
8000736a:	c0 78       	rjmp	80007378 <_malloc_r+0x358>
8000736c:	ec 09 00 09 	add	r9,r6,r9
80007370:	e0 6a 0d 48 	mov	r10,3400
80007374:	10 19       	sub	r9,r8
80007376:	95 09       	st.w	r10[0x0],r9
80007378:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000737c:	f0 09 11 08 	rsub	r9,r8,8
80007380:	58 08       	cp.w	r8,0
80007382:	f2 08 17 10 	movne	r8,r9
80007386:	ed d8 e1 06 	addne	r6,r6,r8
8000738a:	28 08       	sub	r8,-128
8000738c:	ec 01 00 01 	add	r1,r6,r1
80007390:	0a 9c       	mov	r12,r5
80007392:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007396:	f0 01 01 01 	sub	r1,r8,r1
8000739a:	02 9b       	mov	r11,r1
8000739c:	e0 a0 02 6a 	rcall	80007870 <_sbrk_r>
800073a0:	e0 68 0d 48 	mov	r8,3400
800073a4:	5b fc       	cp.w	r12,-1
800073a6:	ec 0c 17 00 	moveq	r12,r6
800073aa:	f9 b1 00 00 	moveq	r1,0
800073ae:	70 09       	ld.w	r9,r8[0x0]
800073b0:	0c 1c       	sub	r12,r6
800073b2:	89 26       	st.w	r4[0x8],r6
800073b4:	02 0c       	add	r12,r1
800073b6:	12 01       	add	r1,r9
800073b8:	a1 ac       	sbr	r12,0x0
800073ba:	91 01       	st.w	r8[0x0],r1
800073bc:	8d 1c       	st.w	r6[0x4],r12
800073be:	08 33       	cp.w	r3,r4
800073c0:	c1 d0       	breq	800073fa <_malloc_r+0x3da>
800073c2:	58 f2       	cp.w	r2,15
800073c4:	e0 8b 00 05 	brhi	800073ce <_malloc_r+0x3ae>
800073c8:	30 18       	mov	r8,1
800073ca:	8d 18       	st.w	r6[0x4],r8
800073cc:	c2 68       	rjmp	80007418 <_malloc_r+0x3f8>
800073ce:	30 59       	mov	r9,5
800073d0:	20 c2       	sub	r2,12
800073d2:	e0 12 ff f8 	andl	r2,0xfff8
800073d6:	e6 02 00 08 	add	r8,r3,r2
800073da:	91 29       	st.w	r8[0x8],r9
800073dc:	91 19       	st.w	r8[0x4],r9
800073de:	66 18       	ld.w	r8,r3[0x4]
800073e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073e4:	e5 e8 10 08 	or	r8,r2,r8
800073e8:	87 18       	st.w	r3[0x4],r8
800073ea:	58 f2       	cp.w	r2,15
800073ec:	e0 88 00 07 	brls	800073fa <_malloc_r+0x3da>
800073f0:	e6 cb ff f8 	sub	r11,r3,-8
800073f4:	0a 9c       	mov	r12,r5
800073f6:	e0 a0 1c 6b 	rcall	8000accc <_free_r>
800073fa:	e0 69 0d 40 	mov	r9,3392
800073fe:	72 0a       	ld.w	r10,r9[0x0]
80007400:	e0 68 0d 48 	mov	r8,3400
80007404:	70 08       	ld.w	r8,r8[0x0]
80007406:	14 38       	cp.w	r8,r10
80007408:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000740c:	e0 69 0d 3c 	mov	r9,3388
80007410:	72 0a       	ld.w	r10,r9[0x0]
80007412:	14 38       	cp.w	r8,r10
80007414:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007418:	68 28       	ld.w	r8,r4[0x8]
8000741a:	70 18       	ld.w	r8,r8[0x4]
8000741c:	e0 18 ff fc 	andl	r8,0xfffc
80007420:	0e 38       	cp.w	r8,r7
80007422:	5f 39       	srlo	r9
80007424:	0e 18       	sub	r8,r7
80007426:	58 f8       	cp.w	r8,15
80007428:	5f aa       	srle	r10
8000742a:	f5 e9 10 09 	or	r9,r10,r9
8000742e:	c0 50       	breq	80007438 <_malloc_r+0x418>
80007430:	0a 9c       	mov	r12,r5
80007432:	fe b0 f3 fb 	rcall	80005c28 <__malloc_unlock>
80007436:	d8 3a       	popm	r0-r7,pc,r12=0
80007438:	68 26       	ld.w	r6,r4[0x8]
8000743a:	a1 a8       	sbr	r8,0x0
8000743c:	0e 99       	mov	r9,r7
8000743e:	a1 a9       	sbr	r9,0x0
80007440:	8d 19       	st.w	r6[0x4],r9
80007442:	ec 07 00 07 	add	r7,r6,r7
80007446:	0a 9c       	mov	r12,r5
80007448:	89 27       	st.w	r4[0x8],r7
8000744a:	8f 18       	st.w	r7[0x4],r8
8000744c:	fe b0 f3 ee 	rcall	80005c28 <__malloc_unlock>
80007450:	ec cc ff f8 	sub	r12,r6,-8
80007454:	d8 32       	popm	r0-r7,pc
80007456:	d7 03       	nop

80007458 <memcpy>:
80007458:	58 8a       	cp.w	r10,8
8000745a:	c2 f5       	brlt	800074b8 <memcpy+0x60>
8000745c:	f9 eb 10 09 	or	r9,r12,r11
80007460:	e2 19 00 03 	andl	r9,0x3,COH
80007464:	e0 81 00 97 	brne	80007592 <memcpy+0x13a>
80007468:	e0 4a 00 20 	cp.w	r10,32
8000746c:	c3 b4       	brge	800074e2 <memcpy+0x8a>
8000746e:	f4 08 14 02 	asr	r8,r10,0x2
80007472:	f0 09 11 08 	rsub	r9,r8,8
80007476:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000747a:	76 69       	ld.w	r9,r11[0x18]
8000747c:	99 69       	st.w	r12[0x18],r9
8000747e:	76 59       	ld.w	r9,r11[0x14]
80007480:	99 59       	st.w	r12[0x14],r9
80007482:	76 49       	ld.w	r9,r11[0x10]
80007484:	99 49       	st.w	r12[0x10],r9
80007486:	76 39       	ld.w	r9,r11[0xc]
80007488:	99 39       	st.w	r12[0xc],r9
8000748a:	76 29       	ld.w	r9,r11[0x8]
8000748c:	99 29       	st.w	r12[0x8],r9
8000748e:	76 19       	ld.w	r9,r11[0x4]
80007490:	99 19       	st.w	r12[0x4],r9
80007492:	76 09       	ld.w	r9,r11[0x0]
80007494:	99 09       	st.w	r12[0x0],r9
80007496:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000749a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000749e:	e0 1a 00 03 	andl	r10,0x3
800074a2:	f4 0a 11 04 	rsub	r10,r10,4
800074a6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800074aa:	17 a9       	ld.ub	r9,r11[0x2]
800074ac:	b0 a9       	st.b	r8[0x2],r9
800074ae:	17 99       	ld.ub	r9,r11[0x1]
800074b0:	b0 99       	st.b	r8[0x1],r9
800074b2:	17 89       	ld.ub	r9,r11[0x0]
800074b4:	b0 89       	st.b	r8[0x0],r9
800074b6:	5e fc       	retal	r12
800074b8:	f4 0a 11 09 	rsub	r10,r10,9
800074bc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800074c0:	17 f9       	ld.ub	r9,r11[0x7]
800074c2:	b8 f9       	st.b	r12[0x7],r9
800074c4:	17 e9       	ld.ub	r9,r11[0x6]
800074c6:	b8 e9       	st.b	r12[0x6],r9
800074c8:	17 d9       	ld.ub	r9,r11[0x5]
800074ca:	b8 d9       	st.b	r12[0x5],r9
800074cc:	17 c9       	ld.ub	r9,r11[0x4]
800074ce:	b8 c9       	st.b	r12[0x4],r9
800074d0:	17 b9       	ld.ub	r9,r11[0x3]
800074d2:	b8 b9       	st.b	r12[0x3],r9
800074d4:	17 a9       	ld.ub	r9,r11[0x2]
800074d6:	b8 a9       	st.b	r12[0x2],r9
800074d8:	17 99       	ld.ub	r9,r11[0x1]
800074da:	b8 99       	st.b	r12[0x1],r9
800074dc:	17 89       	ld.ub	r9,r11[0x0]
800074de:	b8 89       	st.b	r12[0x0],r9
800074e0:	5e fc       	retal	r12
800074e2:	eb cd 40 c0 	pushm	r6-r7,lr
800074e6:	18 99       	mov	r9,r12
800074e8:	22 0a       	sub	r10,32
800074ea:	b7 07       	ld.d	r6,r11++
800074ec:	b3 26       	st.d	r9++,r6
800074ee:	b7 07       	ld.d	r6,r11++
800074f0:	b3 26       	st.d	r9++,r6
800074f2:	b7 07       	ld.d	r6,r11++
800074f4:	b3 26       	st.d	r9++,r6
800074f6:	b7 07       	ld.d	r6,r11++
800074f8:	b3 26       	st.d	r9++,r6
800074fa:	22 0a       	sub	r10,32
800074fc:	cf 74       	brge	800074ea <memcpy+0x92>
800074fe:	2f 0a       	sub	r10,-16
80007500:	c0 65       	brlt	8000750c <memcpy+0xb4>
80007502:	b7 07       	ld.d	r6,r11++
80007504:	b3 26       	st.d	r9++,r6
80007506:	b7 07       	ld.d	r6,r11++
80007508:	b3 26       	st.d	r9++,r6
8000750a:	21 0a       	sub	r10,16
8000750c:	5c 3a       	neg	r10
8000750e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007512:	d7 03       	nop
80007514:	d7 03       	nop
80007516:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000751a:	f3 66 00 0e 	st.b	r9[14],r6
8000751e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007522:	f3 66 00 0d 	st.b	r9[13],r6
80007526:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000752a:	f3 66 00 0c 	st.b	r9[12],r6
8000752e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007532:	f3 66 00 0b 	st.b	r9[11],r6
80007536:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000753a:	f3 66 00 0a 	st.b	r9[10],r6
8000753e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007542:	f3 66 00 09 	st.b	r9[9],r6
80007546:	f7 36 00 08 	ld.ub	r6,r11[8]
8000754a:	f3 66 00 08 	st.b	r9[8],r6
8000754e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007552:	f3 66 00 07 	st.b	r9[7],r6
80007556:	f7 36 00 06 	ld.ub	r6,r11[6]
8000755a:	f3 66 00 06 	st.b	r9[6],r6
8000755e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007562:	f3 66 00 05 	st.b	r9[5],r6
80007566:	f7 36 00 04 	ld.ub	r6,r11[4]
8000756a:	f3 66 00 04 	st.b	r9[4],r6
8000756e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007572:	f3 66 00 03 	st.b	r9[3],r6
80007576:	f7 36 00 02 	ld.ub	r6,r11[2]
8000757a:	f3 66 00 02 	st.b	r9[2],r6
8000757e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007582:	f3 66 00 01 	st.b	r9[1],r6
80007586:	f7 36 00 00 	ld.ub	r6,r11[0]
8000758a:	f3 66 00 00 	st.b	r9[0],r6
8000758e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007592:	20 1a       	sub	r10,1
80007594:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007598:	f8 0a 0b 09 	st.b	r12[r10],r9
8000759c:	cf b1       	brne	80007592 <memcpy+0x13a>
8000759e:	5e fc       	retal	r12

800075a0 <memset>:
800075a0:	18 98       	mov	r8,r12
800075a2:	c0 38       	rjmp	800075a8 <memset+0x8>
800075a4:	10 cb       	st.b	r8++,r11
800075a6:	20 1a       	sub	r10,1
800075a8:	58 0a       	cp.w	r10,0
800075aa:	cf d1       	brne	800075a4 <memset+0x4>
800075ac:	5e fc       	retal	r12
800075ae:	d7 03       	nop

800075b0 <_realloc_r>:
800075b0:	d4 31       	pushm	r0-r7,lr
800075b2:	20 1d       	sub	sp,4
800075b4:	16 94       	mov	r4,r11
800075b6:	18 92       	mov	r2,r12
800075b8:	14 9b       	mov	r11,r10
800075ba:	58 04       	cp.w	r4,0
800075bc:	c0 51       	brne	800075c6 <_realloc_r+0x16>
800075be:	fe b0 fd 31 	rcall	80007020 <_malloc_r>
800075c2:	18 95       	mov	r5,r12
800075c4:	c5 39       	rjmp	8000786a <_realloc_r+0x2ba>
800075c6:	50 0a       	stdsp	sp[0x0],r10
800075c8:	fe b0 f3 2a 	rcall	80005c1c <__malloc_lock>
800075cc:	40 0b       	lddsp	r11,sp[0x0]
800075ce:	f6 c8 ff f5 	sub	r8,r11,-11
800075d2:	e8 c1 00 08 	sub	r1,r4,8
800075d6:	10 96       	mov	r6,r8
800075d8:	62 1c       	ld.w	r12,r1[0x4]
800075da:	e0 16 ff f8 	andl	r6,0xfff8
800075de:	59 68       	cp.w	r8,22
800075e0:	f9 b6 08 10 	movls	r6,16
800075e4:	16 36       	cp.w	r6,r11
800075e6:	5f 38       	srlo	r8
800075e8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800075ec:	c0 50       	breq	800075f6 <_realloc_r+0x46>
800075ee:	30 c8       	mov	r8,12
800075f0:	30 05       	mov	r5,0
800075f2:	85 38       	st.w	r2[0xc],r8
800075f4:	c3 b9       	rjmp	8000786a <_realloc_r+0x2ba>
800075f6:	18 90       	mov	r0,r12
800075f8:	e0 10 ff fc 	andl	r0,0xfffc
800075fc:	0c 30       	cp.w	r0,r6
800075fe:	e0 84 01 0b 	brge	80007814 <_realloc_r+0x264>
80007602:	e0 68 05 2c 	mov	r8,1324
80007606:	e2 00 00 09 	add	r9,r1,r0
8000760a:	70 25       	ld.w	r5,r8[0x8]
8000760c:	0a 39       	cp.w	r9,r5
8000760e:	c0 90       	breq	80007620 <_realloc_r+0x70>
80007610:	72 1a       	ld.w	r10,r9[0x4]
80007612:	a1 ca       	cbr	r10,0x0
80007614:	f2 0a 00 0a 	add	r10,r9,r10
80007618:	74 1a       	ld.w	r10,r10[0x4]
8000761a:	ed ba 00 00 	bld	r10,0x0
8000761e:	c2 20       	breq	80007662 <_realloc_r+0xb2>
80007620:	72 1a       	ld.w	r10,r9[0x4]
80007622:	e0 1a ff fc 	andl	r10,0xfffc
80007626:	f4 00 00 03 	add	r3,r10,r0
8000762a:	0a 39       	cp.w	r9,r5
8000762c:	c1 31       	brne	80007652 <_realloc_r+0xa2>
8000762e:	ec c7 ff f0 	sub	r7,r6,-16
80007632:	0e 33       	cp.w	r3,r7
80007634:	c1 95       	brlt	80007666 <_realloc_r+0xb6>
80007636:	e2 06 00 09 	add	r9,r1,r6
8000763a:	0c 13       	sub	r3,r6
8000763c:	a1 a3       	sbr	r3,0x0
8000763e:	93 13       	st.w	r9[0x4],r3
80007640:	91 29       	st.w	r8[0x8],r9
80007642:	04 9c       	mov	r12,r2
80007644:	62 18       	ld.w	r8,r1[0x4]
80007646:	08 95       	mov	r5,r4
80007648:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000764c:	10 46       	or	r6,r8
8000764e:	83 16       	st.w	r1[0x4],r6
80007650:	c0 b9       	rjmp	80007866 <_realloc_r+0x2b6>
80007652:	0c 33       	cp.w	r3,r6
80007654:	c0 95       	brlt	80007666 <_realloc_r+0xb6>
80007656:	72 28       	ld.w	r8,r9[0x8]
80007658:	02 97       	mov	r7,r1
8000765a:	72 39       	ld.w	r9,r9[0xc]
8000765c:	93 28       	st.w	r9[0x8],r8
8000765e:	91 39       	st.w	r8[0xc],r9
80007660:	cd c8       	rjmp	80007818 <_realloc_r+0x268>
80007662:	30 0a       	mov	r10,0
80007664:	14 99       	mov	r9,r10
80007666:	ed bc 00 00 	bld	r12,0x0
8000766a:	e0 80 00 95 	breq	80007794 <_realloc_r+0x1e4>
8000766e:	62 07       	ld.w	r7,r1[0x0]
80007670:	e2 07 01 07 	sub	r7,r1,r7
80007674:	6e 1c       	ld.w	r12,r7[0x4]
80007676:	e0 1c ff fc 	andl	r12,0xfffc
8000767a:	58 09       	cp.w	r9,0
8000767c:	c5 60       	breq	80007728 <_realloc_r+0x178>
8000767e:	f8 00 00 03 	add	r3,r12,r0
80007682:	0a 39       	cp.w	r9,r5
80007684:	c4 81       	brne	80007714 <_realloc_r+0x164>
80007686:	14 03       	add	r3,r10
80007688:	ec c9 ff f0 	sub	r9,r6,-16
8000768c:	12 33       	cp.w	r3,r9
8000768e:	c4 d5       	brlt	80007728 <_realloc_r+0x178>
80007690:	6e 3a       	ld.w	r10,r7[0xc]
80007692:	6e 29       	ld.w	r9,r7[0x8]
80007694:	95 29       	st.w	r10[0x8],r9
80007696:	93 3a       	st.w	r9[0xc],r10
80007698:	ee c5 ff f8 	sub	r5,r7,-8
8000769c:	e0 ca 00 04 	sub	r10,r0,4
800076a0:	e0 4a 00 24 	cp.w	r10,36
800076a4:	e0 8b 00 25 	brhi	800076ee <_realloc_r+0x13e>
800076a8:	0a 99       	mov	r9,r5
800076aa:	59 3a       	cp.w	r10,19
800076ac:	e0 88 00 1a 	brls	800076e0 <_realloc_r+0x130>
800076b0:	09 09       	ld.w	r9,r4++
800076b2:	8b 09       	st.w	r5[0x0],r9
800076b4:	09 09       	ld.w	r9,r4++
800076b6:	8f 39       	st.w	r7[0xc],r9
800076b8:	ee c9 ff f0 	sub	r9,r7,-16
800076bc:	59 ba       	cp.w	r10,27
800076be:	e0 88 00 11 	brls	800076e0 <_realloc_r+0x130>
800076c2:	09 0b       	ld.w	r11,r4++
800076c4:	93 0b       	st.w	r9[0x0],r11
800076c6:	09 09       	ld.w	r9,r4++
800076c8:	8f 59       	st.w	r7[0x14],r9
800076ca:	ee c9 ff e8 	sub	r9,r7,-24
800076ce:	e0 4a 00 24 	cp.w	r10,36
800076d2:	c0 71       	brne	800076e0 <_realloc_r+0x130>
800076d4:	09 0a       	ld.w	r10,r4++
800076d6:	93 0a       	st.w	r9[0x0],r10
800076d8:	ee c9 ff e0 	sub	r9,r7,-32
800076dc:	09 0a       	ld.w	r10,r4++
800076de:	8f 7a       	st.w	r7[0x1c],r10
800076e0:	09 0a       	ld.w	r10,r4++
800076e2:	12 aa       	st.w	r9++,r10
800076e4:	68 0a       	ld.w	r10,r4[0x0]
800076e6:	93 0a       	st.w	r9[0x0],r10
800076e8:	68 1a       	ld.w	r10,r4[0x4]
800076ea:	93 1a       	st.w	r9[0x4],r10
800076ec:	c0 78       	rjmp	800076fa <_realloc_r+0x14a>
800076ee:	50 08       	stdsp	sp[0x0],r8
800076f0:	08 9b       	mov	r11,r4
800076f2:	0a 9c       	mov	r12,r5
800076f4:	e0 a0 1d 8f 	rcall	8000b212 <memmove>
800076f8:	40 08       	lddsp	r8,sp[0x0]
800076fa:	ee 06 00 09 	add	r9,r7,r6
800076fe:	0c 13       	sub	r3,r6
80007700:	a1 a3       	sbr	r3,0x0
80007702:	93 13       	st.w	r9[0x4],r3
80007704:	91 29       	st.w	r8[0x8],r9
80007706:	04 9c       	mov	r12,r2
80007708:	6e 18       	ld.w	r8,r7[0x4]
8000770a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000770e:	10 46       	or	r6,r8
80007710:	8f 16       	st.w	r7[0x4],r6
80007712:	ca a8       	rjmp	80007866 <_realloc_r+0x2b6>
80007714:	14 03       	add	r3,r10
80007716:	0c 33       	cp.w	r3,r6
80007718:	c0 85       	brlt	80007728 <_realloc_r+0x178>
8000771a:	72 28       	ld.w	r8,r9[0x8]
8000771c:	72 39       	ld.w	r9,r9[0xc]
8000771e:	93 28       	st.w	r9[0x8],r8
80007720:	91 39       	st.w	r8[0xc],r9
80007722:	6e 28       	ld.w	r8,r7[0x8]
80007724:	6e 39       	ld.w	r9,r7[0xc]
80007726:	c0 78       	rjmp	80007734 <_realloc_r+0x184>
80007728:	f8 00 00 03 	add	r3,r12,r0
8000772c:	0c 33       	cp.w	r3,r6
8000772e:	c3 35       	brlt	80007794 <_realloc_r+0x1e4>
80007730:	6e 39       	ld.w	r9,r7[0xc]
80007732:	6e 28       	ld.w	r8,r7[0x8]
80007734:	93 28       	st.w	r9[0x8],r8
80007736:	91 39       	st.w	r8[0xc],r9
80007738:	e0 ca 00 04 	sub	r10,r0,4
8000773c:	ee cc ff f8 	sub	r12,r7,-8
80007740:	e0 4a 00 24 	cp.w	r10,36
80007744:	e0 8b 00 24 	brhi	8000778c <_realloc_r+0x1dc>
80007748:	59 3a       	cp.w	r10,19
8000774a:	e0 88 00 1a 	brls	8000777e <_realloc_r+0x1ce>
8000774e:	09 08       	ld.w	r8,r4++
80007750:	99 08       	st.w	r12[0x0],r8
80007752:	09 08       	ld.w	r8,r4++
80007754:	8f 38       	st.w	r7[0xc],r8
80007756:	ee cc ff f0 	sub	r12,r7,-16
8000775a:	59 ba       	cp.w	r10,27
8000775c:	e0 88 00 11 	brls	8000777e <_realloc_r+0x1ce>
80007760:	09 08       	ld.w	r8,r4++
80007762:	99 08       	st.w	r12[0x0],r8
80007764:	09 08       	ld.w	r8,r4++
80007766:	8f 58       	st.w	r7[0x14],r8
80007768:	ee cc ff e8 	sub	r12,r7,-24
8000776c:	e0 4a 00 24 	cp.w	r10,36
80007770:	c0 71       	brne	8000777e <_realloc_r+0x1ce>
80007772:	09 08       	ld.w	r8,r4++
80007774:	99 08       	st.w	r12[0x0],r8
80007776:	ee cc ff e0 	sub	r12,r7,-32
8000777a:	09 08       	ld.w	r8,r4++
8000777c:	8f 78       	st.w	r7[0x1c],r8
8000777e:	09 08       	ld.w	r8,r4++
80007780:	18 a8       	st.w	r12++,r8
80007782:	68 08       	ld.w	r8,r4[0x0]
80007784:	99 08       	st.w	r12[0x0],r8
80007786:	68 18       	ld.w	r8,r4[0x4]
80007788:	99 18       	st.w	r12[0x4],r8
8000778a:	c4 78       	rjmp	80007818 <_realloc_r+0x268>
8000778c:	08 9b       	mov	r11,r4
8000778e:	e0 a0 1d 42 	rcall	8000b212 <memmove>
80007792:	c4 38       	rjmp	80007818 <_realloc_r+0x268>
80007794:	04 9c       	mov	r12,r2
80007796:	fe b0 fc 45 	rcall	80007020 <_malloc_r>
8000779a:	18 95       	mov	r5,r12
8000779c:	c3 a0       	breq	80007810 <_realloc_r+0x260>
8000779e:	62 18       	ld.w	r8,r1[0x4]
800077a0:	f8 c9 00 08 	sub	r9,r12,8
800077a4:	a1 c8       	cbr	r8,0x0
800077a6:	e2 08 00 08 	add	r8,r1,r8
800077aa:	10 39       	cp.w	r9,r8
800077ac:	c0 71       	brne	800077ba <_realloc_r+0x20a>
800077ae:	72 13       	ld.w	r3,r9[0x4]
800077b0:	02 97       	mov	r7,r1
800077b2:	e0 13 ff fc 	andl	r3,0xfffc
800077b6:	00 03       	add	r3,r0
800077b8:	c3 08       	rjmp	80007818 <_realloc_r+0x268>
800077ba:	e0 ca 00 04 	sub	r10,r0,4
800077be:	e0 4a 00 24 	cp.w	r10,36
800077c2:	e0 8b 00 20 	brhi	80007802 <_realloc_r+0x252>
800077c6:	08 99       	mov	r9,r4
800077c8:	18 98       	mov	r8,r12
800077ca:	59 3a       	cp.w	r10,19
800077cc:	e0 88 00 14 	brls	800077f4 <_realloc_r+0x244>
800077d0:	13 0b       	ld.w	r11,r9++
800077d2:	10 ab       	st.w	r8++,r11
800077d4:	13 0b       	ld.w	r11,r9++
800077d6:	10 ab       	st.w	r8++,r11
800077d8:	59 ba       	cp.w	r10,27
800077da:	e0 88 00 0d 	brls	800077f4 <_realloc_r+0x244>
800077de:	13 0b       	ld.w	r11,r9++
800077e0:	10 ab       	st.w	r8++,r11
800077e2:	13 0b       	ld.w	r11,r9++
800077e4:	10 ab       	st.w	r8++,r11
800077e6:	e0 4a 00 24 	cp.w	r10,36
800077ea:	c0 51       	brne	800077f4 <_realloc_r+0x244>
800077ec:	13 0a       	ld.w	r10,r9++
800077ee:	10 aa       	st.w	r8++,r10
800077f0:	13 0a       	ld.w	r10,r9++
800077f2:	10 aa       	st.w	r8++,r10
800077f4:	13 0a       	ld.w	r10,r9++
800077f6:	10 aa       	st.w	r8++,r10
800077f8:	72 0a       	ld.w	r10,r9[0x0]
800077fa:	91 0a       	st.w	r8[0x0],r10
800077fc:	72 19       	ld.w	r9,r9[0x4]
800077fe:	91 19       	st.w	r8[0x4],r9
80007800:	c0 48       	rjmp	80007808 <_realloc_r+0x258>
80007802:	08 9b       	mov	r11,r4
80007804:	e0 a0 1d 07 	rcall	8000b212 <memmove>
80007808:	08 9b       	mov	r11,r4
8000780a:	04 9c       	mov	r12,r2
8000780c:	e0 a0 1a 60 	rcall	8000accc <_free_r>
80007810:	04 9c       	mov	r12,r2
80007812:	c2 a8       	rjmp	80007866 <_realloc_r+0x2b6>
80007814:	00 93       	mov	r3,r0
80007816:	02 97       	mov	r7,r1
80007818:	e6 06 01 09 	sub	r9,r3,r6
8000781c:	6e 18       	ld.w	r8,r7[0x4]
8000781e:	58 f9       	cp.w	r9,15
80007820:	e0 88 00 16 	brls	8000784c <_realloc_r+0x29c>
80007824:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007828:	ed e8 10 08 	or	r8,r6,r8
8000782c:	8f 18       	st.w	r7[0x4],r8
8000782e:	12 98       	mov	r8,r9
80007830:	a1 a8       	sbr	r8,0x0
80007832:	ee 06 00 0b 	add	r11,r7,r6
80007836:	f6 09 00 09 	add	r9,r11,r9
8000783a:	97 18       	st.w	r11[0x4],r8
8000783c:	72 18       	ld.w	r8,r9[0x4]
8000783e:	a1 a8       	sbr	r8,0x0
80007840:	2f 8b       	sub	r11,-8
80007842:	93 18       	st.w	r9[0x4],r8
80007844:	04 9c       	mov	r12,r2
80007846:	e0 a0 1a 43 	rcall	8000accc <_free_r>
8000784a:	c0 b8       	rjmp	80007860 <_realloc_r+0x2b0>
8000784c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007850:	e7 e8 10 08 	or	r8,r3,r8
80007854:	8f 18       	st.w	r7[0x4],r8
80007856:	ee 03 00 03 	add	r3,r7,r3
8000785a:	66 18       	ld.w	r8,r3[0x4]
8000785c:	a1 a8       	sbr	r8,0x0
8000785e:	87 18       	st.w	r3[0x4],r8
80007860:	04 9c       	mov	r12,r2
80007862:	ee c5 ff f8 	sub	r5,r7,-8
80007866:	fe b0 f1 e1 	rcall	80005c28 <__malloc_unlock>
8000786a:	0a 9c       	mov	r12,r5
8000786c:	2f fd       	sub	sp,-4
8000786e:	d8 32       	popm	r0-r7,pc

80007870 <_sbrk_r>:
80007870:	d4 21       	pushm	r4-r7,lr
80007872:	30 08       	mov	r8,0
80007874:	18 97       	mov	r7,r12
80007876:	e0 66 51 14 	mov	r6,20756
8000787a:	16 9c       	mov	r12,r11
8000787c:	8d 08       	st.w	r6[0x0],r8
8000787e:	c8 5c       	rcall	80007988 <_sbrk>
80007880:	5b fc       	cp.w	r12,-1
80007882:	c0 51       	brne	8000788c <_sbrk_r+0x1c>
80007884:	6c 08       	ld.w	r8,r6[0x0]
80007886:	58 08       	cp.w	r8,0
80007888:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000788c:	d8 22       	popm	r4-r7,pc
8000788e:	d7 03       	nop

80007890 <sprintf>:
80007890:	d4 01       	pushm	lr
80007892:	21 7d       	sub	sp,92
80007894:	e0 68 ff ff 	mov	r8,65535
80007898:	ea 18 7f ff 	orh	r8,0x7fff
8000789c:	50 58       	stdsp	sp[0x14],r8
8000789e:	50 28       	stdsp	sp[0x8],r8
800078a0:	e0 68 02 08 	mov	r8,520
800078a4:	ba 68       	st.h	sp[0xc],r8
800078a6:	3f f8       	mov	r8,-1
800078a8:	ba 78       	st.h	sp[0xe],r8
800078aa:	e0 68 0a 2c 	mov	r8,2604
800078ae:	50 4c       	stdsp	sp[0x10],r12
800078b0:	16 9a       	mov	r10,r11
800078b2:	50 0c       	stdsp	sp[0x0],r12
800078b4:	fa c9 ff a0 	sub	r9,sp,-96
800078b8:	70 0c       	ld.w	r12,r8[0x0]
800078ba:	1a 9b       	mov	r11,sp
800078bc:	e0 a0 02 1a 	rcall	80007cf0 <_vfprintf_r>
800078c0:	30 09       	mov	r9,0
800078c2:	40 08       	lddsp	r8,sp[0x0]
800078c4:	b0 89       	st.b	r8[0x0],r9
800078c6:	2e 9d       	sub	sp,-92
800078c8:	d8 02       	popm	pc
800078ca:	d7 03       	nop

800078cc <strncpy>:
800078cc:	30 08       	mov	r8,0
800078ce:	10 3a       	cp.w	r10,r8
800078d0:	5e 0c       	reteq	r12
800078d2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800078d6:	f8 08 0b 09 	st.b	r12[r8],r9
800078da:	2f f8       	sub	r8,-1
800078dc:	58 09       	cp.w	r9,0
800078de:	cf 81       	brne	800078ce <strncpy+0x2>
800078e0:	10 3a       	cp.w	r10,r8
800078e2:	5e 0c       	reteq	r12
800078e4:	f8 08 0b 09 	st.b	r12[r8],r9
800078e8:	2f f8       	sub	r8,-1
800078ea:	cf bb       	rjmp	800078e0 <strncpy+0x14>

800078ec <_close>:
800078ec:	30 28       	mov	r8,2
800078ee:	d6 73       	breakpoint
800078f0:	3f fc       	mov	r12,-1
800078f2:	35 8b       	mov	r11,88
800078f4:	58 0c       	cp.w	r12,0
800078f6:	5e 4c       	retge	r12
800078f8:	e0 6a 51 14 	mov	r10,20756
800078fc:	95 0b       	st.w	r10[0x0],r11
800078fe:	5e fc       	retal	r12

80007900 <_lseek>:
80007900:	30 58       	mov	r8,5
80007902:	d6 73       	breakpoint
80007904:	3f fc       	mov	r12,-1
80007906:	35 8b       	mov	r11,88
80007908:	58 0c       	cp.w	r12,0
8000790a:	5e 4c       	retge	r12
8000790c:	e0 6a 51 14 	mov	r10,20756
80007910:	95 0b       	st.w	r10[0x0],r11
80007912:	5e fc       	retal	r12

80007914 <isatty>:
80007914:	30 b8       	mov	r8,11
80007916:	d6 73       	breakpoint
80007918:	3f fc       	mov	r12,-1
8000791a:	35 8b       	mov	r11,88
8000791c:	58 0c       	cp.w	r12,0
8000791e:	5e 4c       	retge	r12
80007920:	e0 6a 51 14 	mov	r10,20756
80007924:	95 0b       	st.w	r10[0x0],r11
80007926:	5e fc       	retal	r12

80007928 <_fstat_host>:
80007928:	30 98       	mov	r8,9
8000792a:	d6 73       	breakpoint
8000792c:	3f fc       	mov	r12,-1
8000792e:	35 8b       	mov	r11,88
80007930:	58 0c       	cp.w	r12,0
80007932:	5e 4c       	retge	r12
80007934:	e0 6a 51 14 	mov	r10,20756
80007938:	95 0b       	st.w	r10[0x0],r11
8000793a:	5e fc       	retal	r12

8000793c <_fstat>:
8000793c:	d4 21       	pushm	r4-r7,lr
8000793e:	21 0d       	sub	sp,64
80007940:	16 97       	mov	r7,r11
80007942:	1a 9b       	mov	r11,sp
80007944:	cf 2f       	rcall	80007928 <_fstat_host>
80007946:	c0 34       	brge	8000794c <_fstat+0x10>
80007948:	3f fc       	mov	r12,-1
8000794a:	c1 c8       	rjmp	80007982 <_fstat+0x46>
8000794c:	40 08       	lddsp	r8,sp[0x0]
8000794e:	ae 08       	st.h	r7[0x0],r8
80007950:	40 18       	lddsp	r8,sp[0x4]
80007952:	ae 18       	st.h	r7[0x2],r8
80007954:	40 28       	lddsp	r8,sp[0x8]
80007956:	8f 18       	st.w	r7[0x4],r8
80007958:	40 38       	lddsp	r8,sp[0xc]
8000795a:	ae 48       	st.h	r7[0x8],r8
8000795c:	40 48       	lddsp	r8,sp[0x10]
8000795e:	ae 58       	st.h	r7[0xa],r8
80007960:	40 58       	lddsp	r8,sp[0x14]
80007962:	ae 68       	st.h	r7[0xc],r8
80007964:	40 68       	lddsp	r8,sp[0x18]
80007966:	ae 78       	st.h	r7[0xe],r8
80007968:	40 88       	lddsp	r8,sp[0x20]
8000796a:	8f 48       	st.w	r7[0x10],r8
8000796c:	40 a8       	lddsp	r8,sp[0x28]
8000796e:	8f b8       	st.w	r7[0x2c],r8
80007970:	40 c8       	lddsp	r8,sp[0x30]
80007972:	8f c8       	st.w	r7[0x30],r8
80007974:	40 d8       	lddsp	r8,sp[0x34]
80007976:	8f 58       	st.w	r7[0x14],r8
80007978:	40 e8       	lddsp	r8,sp[0x38]
8000797a:	30 0c       	mov	r12,0
8000797c:	8f 78       	st.w	r7[0x1c],r8
8000797e:	40 f8       	lddsp	r8,sp[0x3c]
80007980:	8f 98       	st.w	r7[0x24],r8
80007982:	2f 0d       	sub	sp,-64
80007984:	d8 22       	popm	r4-r7,pc
80007986:	d7 03       	nop

80007988 <_sbrk>:
80007988:	d4 01       	pushm	lr
8000798a:	e0 68 0d 70 	mov	r8,3440
8000798e:	70 09       	ld.w	r9,r8[0x0]
80007990:	58 09       	cp.w	r9,0
80007992:	c0 41       	brne	8000799a <_sbrk+0x12>
80007994:	e0 69 51 18 	mov	r9,20760
80007998:	91 09       	st.w	r8[0x0],r9
8000799a:	e0 69 0d 70 	mov	r9,3440
8000799e:	e0 7a 70 00 	mov	r10,94208
800079a2:	72 08       	ld.w	r8,r9[0x0]
800079a4:	f0 0c 00 0c 	add	r12,r8,r12
800079a8:	14 3c       	cp.w	r12,r10
800079aa:	e0 8b 00 04 	brhi	800079b2 <_sbrk+0x2a>
800079ae:	93 0c       	st.w	r9[0x0],r12
800079b0:	c0 68       	rjmp	800079bc <_sbrk+0x34>
800079b2:	e0 a0 18 15 	rcall	8000a9dc <__errno>
800079b6:	30 c8       	mov	r8,12
800079b8:	99 08       	st.w	r12[0x0],r8
800079ba:	3f f8       	mov	r8,-1
800079bc:	10 9c       	mov	r12,r8
800079be:	d8 02       	popm	pc

800079c0 <get_arg>:
800079c0:	d4 31       	pushm	r0-r7,lr
800079c2:	20 8d       	sub	sp,32
800079c4:	fa c4 ff bc 	sub	r4,sp,-68
800079c8:	50 4b       	stdsp	sp[0x10],r11
800079ca:	68 2e       	ld.w	lr,r4[0x8]
800079cc:	50 58       	stdsp	sp[0x14],r8
800079ce:	12 96       	mov	r6,r9
800079d0:	7c 0b       	ld.w	r11,lr[0x0]
800079d2:	70 05       	ld.w	r5,r8[0x0]
800079d4:	50 6e       	stdsp	sp[0x18],lr
800079d6:	58 0b       	cp.w	r11,0
800079d8:	f4 0b 17 00 	moveq	r11,r10
800079dc:	68 03       	ld.w	r3,r4[0x0]
800079de:	68 11       	ld.w	r1,r4[0x4]
800079e0:	40 49       	lddsp	r9,sp[0x10]
800079e2:	30 08       	mov	r8,0
800079e4:	c2 89       	rjmp	80007c34 <get_arg+0x274>
800079e6:	2f fb       	sub	r11,-1
800079e8:	32 5c       	mov	r12,37
800079ea:	17 8a       	ld.ub	r10,r11[0x0]
800079ec:	f8 0a 18 00 	cp.b	r10,r12
800079f0:	5f 1e       	srne	lr
800079f2:	f0 0a 18 00 	cp.b	r10,r8
800079f6:	5f 1c       	srne	r12
800079f8:	fd ec 00 0c 	and	r12,lr,r12
800079fc:	f0 0c 18 00 	cp.b	r12,r8
80007a00:	cf 31       	brne	800079e6 <get_arg+0x26>
80007a02:	58 0a       	cp.w	r10,0
80007a04:	e0 80 01 25 	breq	80007c4e <get_arg+0x28e>
80007a08:	30 0c       	mov	r12,0
80007a0a:	3f fa       	mov	r10,-1
80007a0c:	18 90       	mov	r0,r12
80007a0e:	50 3a       	stdsp	sp[0xc],r10
80007a10:	18 94       	mov	r4,r12
80007a12:	18 92       	mov	r2,r12
80007a14:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007a18:	16 97       	mov	r7,r11
80007a1a:	50 7c       	stdsp	sp[0x1c],r12
80007a1c:	fe cc 9f 78 	sub	r12,pc,-24712
80007a20:	0f 3a       	ld.ub	r10,r7++
80007a22:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007a26:	40 7c       	lddsp	r12,sp[0x1c]
80007a28:	1c 0c       	add	r12,lr
80007a2a:	fe ce a0 4e 	sub	lr,pc,-24498
80007a2e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007a32:	20 1e       	sub	lr,1
80007a34:	50 0e       	stdsp	sp[0x0],lr
80007a36:	fe ce a0 c6 	sub	lr,pc,-24378
80007a3a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007a3e:	50 7c       	stdsp	sp[0x1c],r12
80007a40:	40 0c       	lddsp	r12,sp[0x0]
80007a42:	58 7c       	cp.w	r12,7
80007a44:	e0 8b 00 f1 	brhi	80007c26 <get_arg+0x266>
80007a48:	fe ce a2 78 	sub	lr,pc,-23944
80007a4c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007a50:	36 8b       	mov	r11,104
80007a52:	f6 0a 18 00 	cp.b	r10,r11
80007a56:	e0 80 00 e8 	breq	80007c26 <get_arg+0x266>
80007a5a:	37 1b       	mov	r11,113
80007a5c:	f6 0a 18 00 	cp.b	r10,r11
80007a60:	c0 70       	breq	80007a6e <get_arg+0xae>
80007a62:	34 cb       	mov	r11,76
80007a64:	f6 0a 18 00 	cp.b	r10,r11
80007a68:	c0 51       	brne	80007a72 <get_arg+0xb2>
80007a6a:	a3 b4       	sbr	r4,0x3
80007a6c:	cd d8       	rjmp	80007c26 <get_arg+0x266>
80007a6e:	a5 b4       	sbr	r4,0x5
80007a70:	cd b8       	rjmp	80007c26 <get_arg+0x266>
80007a72:	08 9a       	mov	r10,r4
80007a74:	0e 9b       	mov	r11,r7
80007a76:	a5 aa       	sbr	r10,0x4
80007a78:	17 3c       	ld.ub	r12,r11++
80007a7a:	a5 b4       	sbr	r4,0x5
80007a7c:	36 ce       	mov	lr,108
80007a7e:	fc 0c 18 00 	cp.b	r12,lr
80007a82:	e0 80 00 d3 	breq	80007c28 <get_arg+0x268>
80007a86:	14 94       	mov	r4,r10
80007a88:	cc f8       	rjmp	80007c26 <get_arg+0x266>
80007a8a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007a8e:	36 7c       	mov	r12,103
80007a90:	f8 0a 18 00 	cp.b	r10,r12
80007a94:	e0 8b 00 27 	brhi	80007ae2 <get_arg+0x122>
80007a98:	36 5b       	mov	r11,101
80007a9a:	f6 0a 18 00 	cp.b	r10,r11
80007a9e:	c4 82       	brcc	80007b2e <get_arg+0x16e>
80007aa0:	34 fb       	mov	r11,79
80007aa2:	f6 0a 18 00 	cp.b	r10,r11
80007aa6:	c4 80       	breq	80007b36 <get_arg+0x176>
80007aa8:	e0 8b 00 0c 	brhi	80007ac0 <get_arg+0x100>
80007aac:	34 5b       	mov	r11,69
80007aae:	f6 0a 18 00 	cp.b	r10,r11
80007ab2:	c3 e0       	breq	80007b2e <get_arg+0x16e>
80007ab4:	34 7b       	mov	r11,71
80007ab6:	f6 0a 18 00 	cp.b	r10,r11
80007aba:	c3 a0       	breq	80007b2e <get_arg+0x16e>
80007abc:	34 4b       	mov	r11,68
80007abe:	c0 88       	rjmp	80007ace <get_arg+0x10e>
80007ac0:	35 8b       	mov	r11,88
80007ac2:	f6 0a 18 00 	cp.b	r10,r11
80007ac6:	c2 c0       	breq	80007b1e <get_arg+0x15e>
80007ac8:	e0 8b 00 07 	brhi	80007ad6 <get_arg+0x116>
80007acc:	35 5b       	mov	r11,85
80007ace:	f6 0a 18 00 	cp.b	r10,r11
80007ad2:	c3 51       	brne	80007b3c <get_arg+0x17c>
80007ad4:	c3 18       	rjmp	80007b36 <get_arg+0x176>
80007ad6:	36 3b       	mov	r11,99
80007ad8:	f6 0a 18 00 	cp.b	r10,r11
80007adc:	c2 f0       	breq	80007b3a <get_arg+0x17a>
80007ade:	36 4b       	mov	r11,100
80007ae0:	c0 e8       	rjmp	80007afc <get_arg+0x13c>
80007ae2:	37 0b       	mov	r11,112
80007ae4:	f6 0a 18 00 	cp.b	r10,r11
80007ae8:	c2 50       	breq	80007b32 <get_arg+0x172>
80007aea:	e0 8b 00 0d 	brhi	80007b04 <get_arg+0x144>
80007aee:	36 eb       	mov	r11,110
80007af0:	f6 0a 18 00 	cp.b	r10,r11
80007af4:	c1 f0       	breq	80007b32 <get_arg+0x172>
80007af6:	e0 8b 00 14 	brhi	80007b1e <get_arg+0x15e>
80007afa:	36 9b       	mov	r11,105
80007afc:	f6 0a 18 00 	cp.b	r10,r11
80007b00:	c1 e1       	brne	80007b3c <get_arg+0x17c>
80007b02:	c0 e8       	rjmp	80007b1e <get_arg+0x15e>
80007b04:	37 5b       	mov	r11,117
80007b06:	f6 0a 18 00 	cp.b	r10,r11
80007b0a:	c0 a0       	breq	80007b1e <get_arg+0x15e>
80007b0c:	37 8b       	mov	r11,120
80007b0e:	f6 0a 18 00 	cp.b	r10,r11
80007b12:	c0 60       	breq	80007b1e <get_arg+0x15e>
80007b14:	37 3b       	mov	r11,115
80007b16:	f6 0a 18 00 	cp.b	r10,r11
80007b1a:	c1 11       	brne	80007b3c <get_arg+0x17c>
80007b1c:	c0 b8       	rjmp	80007b32 <get_arg+0x172>
80007b1e:	ed b4 00 04 	bld	r4,0x4
80007b22:	c0 a0       	breq	80007b36 <get_arg+0x176>
80007b24:	ed b4 00 05 	bld	r4,0x5
80007b28:	c0 91       	brne	80007b3a <get_arg+0x17a>
80007b2a:	30 20       	mov	r0,2
80007b2c:	c0 88       	rjmp	80007b3c <get_arg+0x17c>
80007b2e:	30 40       	mov	r0,4
80007b30:	c0 68       	rjmp	80007b3c <get_arg+0x17c>
80007b32:	30 30       	mov	r0,3
80007b34:	c0 48       	rjmp	80007b3c <get_arg+0x17c>
80007b36:	30 10       	mov	r0,1
80007b38:	c0 28       	rjmp	80007b3c <get_arg+0x17c>
80007b3a:	30 00       	mov	r0,0
80007b3c:	40 3b       	lddsp	r11,sp[0xc]
80007b3e:	5b fb       	cp.w	r11,-1
80007b40:	c0 40       	breq	80007b48 <get_arg+0x188>
80007b42:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007b46:	c7 08       	rjmp	80007c26 <get_arg+0x266>
80007b48:	58 60       	cp.w	r0,6
80007b4a:	e0 8b 00 6e 	brhi	80007c26 <get_arg+0x266>
80007b4e:	6c 0a       	ld.w	r10,r6[0x0]
80007b50:	ea cc ff ff 	sub	r12,r5,-1
80007b54:	fe ce a3 64 	sub	lr,pc,-23708
80007b58:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007b5c:	f4 cb ff f8 	sub	r11,r10,-8
80007b60:	8d 0b       	st.w	r6[0x0],r11
80007b62:	f4 ea 00 00 	ld.d	r10,r10[0]
80007b66:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007b6a:	c0 f8       	rjmp	80007b88 <get_arg+0x1c8>
80007b6c:	f4 cb ff fc 	sub	r11,r10,-4
80007b70:	8d 0b       	st.w	r6[0x0],r11
80007b72:	74 0a       	ld.w	r10,r10[0x0]
80007b74:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007b78:	c0 88       	rjmp	80007b88 <get_arg+0x1c8>
80007b7a:	f4 cb ff f8 	sub	r11,r10,-8
80007b7e:	8d 0b       	st.w	r6[0x0],r11
80007b80:	f4 ea 00 00 	ld.d	r10,r10[0]
80007b84:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007b88:	0e 9b       	mov	r11,r7
80007b8a:	18 95       	mov	r5,r12
80007b8c:	c4 e8       	rjmp	80007c28 <get_arg+0x268>
80007b8e:	62 0a       	ld.w	r10,r1[0x0]
80007b90:	5b fa       	cp.w	r10,-1
80007b92:	c0 b1       	brne	80007ba8 <get_arg+0x1e8>
80007b94:	50 19       	stdsp	sp[0x4],r9
80007b96:	50 28       	stdsp	sp[0x8],r8
80007b98:	e0 6a 00 80 	mov	r10,128
80007b9c:	30 0b       	mov	r11,0
80007b9e:	02 9c       	mov	r12,r1
80007ba0:	fe b0 fd 00 	rcall	800075a0 <memset>
80007ba4:	40 28       	lddsp	r8,sp[0x8]
80007ba6:	40 19       	lddsp	r9,sp[0x4]
80007ba8:	e4 cc 00 01 	sub	r12,r2,1
80007bac:	0e 9b       	mov	r11,r7
80007bae:	50 3c       	stdsp	sp[0xc],r12
80007bb0:	f2 0c 0c 49 	max	r9,r9,r12
80007bb4:	c3 a8       	rjmp	80007c28 <get_arg+0x268>
80007bb6:	62 0a       	ld.w	r10,r1[0x0]
80007bb8:	5b fa       	cp.w	r10,-1
80007bba:	c0 b1       	brne	80007bd0 <get_arg+0x210>
80007bbc:	50 19       	stdsp	sp[0x4],r9
80007bbe:	50 28       	stdsp	sp[0x8],r8
80007bc0:	e0 6a 00 80 	mov	r10,128
80007bc4:	30 0b       	mov	r11,0
80007bc6:	02 9c       	mov	r12,r1
80007bc8:	fe b0 fc ec 	rcall	800075a0 <memset>
80007bcc:	40 28       	lddsp	r8,sp[0x8]
80007bce:	40 19       	lddsp	r9,sp[0x4]
80007bd0:	20 12       	sub	r2,1
80007bd2:	30 0a       	mov	r10,0
80007bd4:	0e 9b       	mov	r11,r7
80007bd6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007bda:	f2 02 0c 49 	max	r9,r9,r2
80007bde:	c2 58       	rjmp	80007c28 <get_arg+0x268>
80007be0:	16 97       	mov	r7,r11
80007be2:	6c 0a       	ld.w	r10,r6[0x0]
80007be4:	f4 cb ff fc 	sub	r11,r10,-4
80007be8:	8d 0b       	st.w	r6[0x0],r11
80007bea:	74 0a       	ld.w	r10,r10[0x0]
80007bec:	0e 9b       	mov	r11,r7
80007bee:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007bf2:	2f f5       	sub	r5,-1
80007bf4:	c1 a8       	rjmp	80007c28 <get_arg+0x268>
80007bf6:	f4 c2 00 30 	sub	r2,r10,48
80007bfa:	c0 68       	rjmp	80007c06 <get_arg+0x246>
80007bfc:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007c00:	2f f7       	sub	r7,-1
80007c02:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007c06:	0f 8a       	ld.ub	r10,r7[0x0]
80007c08:	58 0a       	cp.w	r10,0
80007c0a:	c0 e0       	breq	80007c26 <get_arg+0x266>
80007c0c:	23 0a       	sub	r10,48
80007c0e:	58 9a       	cp.w	r10,9
80007c10:	fe 98 ff f6 	brls	80007bfc <get_arg+0x23c>
80007c14:	c0 98       	rjmp	80007c26 <get_arg+0x266>
80007c16:	2f f7       	sub	r7,-1
80007c18:	0f 8a       	ld.ub	r10,r7[0x0]
80007c1a:	58 0a       	cp.w	r10,0
80007c1c:	c0 50       	breq	80007c26 <get_arg+0x266>
80007c1e:	23 0a       	sub	r10,48
80007c20:	58 9a       	cp.w	r10,9
80007c22:	fe 98 ff fa 	brls	80007c16 <get_arg+0x256>
80007c26:	0e 9b       	mov	r11,r7
80007c28:	40 7c       	lddsp	r12,sp[0x1c]
80007c2a:	30 ba       	mov	r10,11
80007c2c:	f4 0c 18 00 	cp.b	r12,r10
80007c30:	fe 91 fe f2 	brne	80007a14 <get_arg+0x54>
80007c34:	40 42       	lddsp	r2,sp[0x10]
80007c36:	17 8c       	ld.ub	r12,r11[0x0]
80007c38:	0a 32       	cp.w	r2,r5
80007c3a:	5f 4a       	srge	r10
80007c3c:	f0 0c 18 00 	cp.b	r12,r8
80007c40:	5f 1c       	srne	r12
80007c42:	f9 ea 00 0a 	and	r10,r12,r10
80007c46:	f0 0a 18 00 	cp.b	r10,r8
80007c4a:	fe 91 fe cf 	brne	800079e8 <get_arg+0x28>
80007c4e:	30 08       	mov	r8,0
80007c50:	40 4e       	lddsp	lr,sp[0x10]
80007c52:	17 8a       	ld.ub	r10,r11[0x0]
80007c54:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007c58:	f0 0a 18 00 	cp.b	r10,r8
80007c5c:	fc 09 17 10 	movne	r9,lr
80007c60:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007c64:	06 9e       	mov	lr,r3
80007c66:	c2 a8       	rjmp	80007cba <get_arg+0x2fa>
80007c68:	62 0a       	ld.w	r10,r1[0x0]
80007c6a:	58 3a       	cp.w	r10,3
80007c6c:	c1 e0       	breq	80007ca8 <get_arg+0x2e8>
80007c6e:	e0 89 00 07 	brgt	80007c7c <get_arg+0x2bc>
80007c72:	58 1a       	cp.w	r10,1
80007c74:	c1 a0       	breq	80007ca8 <get_arg+0x2e8>
80007c76:	58 2a       	cp.w	r10,2
80007c78:	c1 81       	brne	80007ca8 <get_arg+0x2e8>
80007c7a:	c0 58       	rjmp	80007c84 <get_arg+0x2c4>
80007c7c:	58 5a       	cp.w	r10,5
80007c7e:	c0 c0       	breq	80007c96 <get_arg+0x2d6>
80007c80:	c0 b5       	brlt	80007c96 <get_arg+0x2d6>
80007c82:	c1 38       	rjmp	80007ca8 <get_arg+0x2e8>
80007c84:	6c 0a       	ld.w	r10,r6[0x0]
80007c86:	f4 cc ff f8 	sub	r12,r10,-8
80007c8a:	8d 0c       	st.w	r6[0x0],r12
80007c8c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007c90:	f0 e3 00 00 	st.d	r8[0],r2
80007c94:	c1 08       	rjmp	80007cb4 <get_arg+0x2f4>
80007c96:	6c 0a       	ld.w	r10,r6[0x0]
80007c98:	f4 cc ff f8 	sub	r12,r10,-8
80007c9c:	8d 0c       	st.w	r6[0x0],r12
80007c9e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ca2:	f0 e3 00 00 	st.d	r8[0],r2
80007ca6:	c0 78       	rjmp	80007cb4 <get_arg+0x2f4>
80007ca8:	6c 0a       	ld.w	r10,r6[0x0]
80007caa:	f4 cc ff fc 	sub	r12,r10,-4
80007cae:	8d 0c       	st.w	r6[0x0],r12
80007cb0:	74 0a       	ld.w	r10,r10[0x0]
80007cb2:	91 0a       	st.w	r8[0x0],r10
80007cb4:	2f f5       	sub	r5,-1
80007cb6:	2f 88       	sub	r8,-8
80007cb8:	2f c1       	sub	r1,-4
80007cba:	12 35       	cp.w	r5,r9
80007cbc:	fe 9a ff d6 	brle	80007c68 <get_arg+0x2a8>
80007cc0:	1c 93       	mov	r3,lr
80007cc2:	40 52       	lddsp	r2,sp[0x14]
80007cc4:	40 6e       	lddsp	lr,sp[0x18]
80007cc6:	85 05       	st.w	r2[0x0],r5
80007cc8:	9d 0b       	st.w	lr[0x0],r11
80007cca:	40 4b       	lddsp	r11,sp[0x10]
80007ccc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007cd0:	2f 8d       	sub	sp,-32
80007cd2:	d8 32       	popm	r0-r7,pc

80007cd4 <__sprint_r>:
80007cd4:	d4 21       	pushm	r4-r7,lr
80007cd6:	14 97       	mov	r7,r10
80007cd8:	74 28       	ld.w	r8,r10[0x8]
80007cda:	58 08       	cp.w	r8,0
80007cdc:	c0 41       	brne	80007ce4 <__sprint_r+0x10>
80007cde:	95 18       	st.w	r10[0x4],r8
80007ce0:	10 9c       	mov	r12,r8
80007ce2:	d8 22       	popm	r4-r7,pc
80007ce4:	e0 a0 18 ba 	rcall	8000ae58 <__sfvwrite_r>
80007ce8:	30 08       	mov	r8,0
80007cea:	8f 18       	st.w	r7[0x4],r8
80007cec:	8f 28       	st.w	r7[0x8],r8
80007cee:	d8 22       	popm	r4-r7,pc

80007cf0 <_vfprintf_r>:
80007cf0:	d4 31       	pushm	r0-r7,lr
80007cf2:	fa cd 06 bc 	sub	sp,sp,1724
80007cf6:	51 09       	stdsp	sp[0x40],r9
80007cf8:	16 91       	mov	r1,r11
80007cfa:	14 97       	mov	r7,r10
80007cfc:	18 95       	mov	r5,r12
80007cfe:	e0 a0 1a 1d 	rcall	8000b138 <_localeconv_r>
80007d02:	78 0c       	ld.w	r12,r12[0x0]
80007d04:	50 cc       	stdsp	sp[0x30],r12
80007d06:	58 05       	cp.w	r5,0
80007d08:	c0 70       	breq	80007d16 <_vfprintf_r+0x26>
80007d0a:	6a 68       	ld.w	r8,r5[0x18]
80007d0c:	58 08       	cp.w	r8,0
80007d0e:	c0 41       	brne	80007d16 <_vfprintf_r+0x26>
80007d10:	0a 9c       	mov	r12,r5
80007d12:	e0 a0 17 43 	rcall	8000ab98 <__sinit>
80007d16:	fe c8 a1 62 	sub	r8,pc,-24222
80007d1a:	10 31       	cp.w	r1,r8
80007d1c:	c0 31       	brne	80007d22 <_vfprintf_r+0x32>
80007d1e:	6a 01       	ld.w	r1,r5[0x0]
80007d20:	c0 c8       	rjmp	80007d38 <_vfprintf_r+0x48>
80007d22:	fe c8 a1 4e 	sub	r8,pc,-24242
80007d26:	10 31       	cp.w	r1,r8
80007d28:	c0 31       	brne	80007d2e <_vfprintf_r+0x3e>
80007d2a:	6a 11       	ld.w	r1,r5[0x4]
80007d2c:	c0 68       	rjmp	80007d38 <_vfprintf_r+0x48>
80007d2e:	fe c8 a1 3a 	sub	r8,pc,-24262
80007d32:	10 31       	cp.w	r1,r8
80007d34:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007d38:	82 68       	ld.sh	r8,r1[0xc]
80007d3a:	ed b8 00 03 	bld	r8,0x3
80007d3e:	c0 41       	brne	80007d46 <_vfprintf_r+0x56>
80007d40:	62 48       	ld.w	r8,r1[0x10]
80007d42:	58 08       	cp.w	r8,0
80007d44:	c0 71       	brne	80007d52 <_vfprintf_r+0x62>
80007d46:	02 9b       	mov	r11,r1
80007d48:	0a 9c       	mov	r12,r5
80007d4a:	e0 a0 0f 5d 	rcall	80009c04 <__swsetup_r>
80007d4e:	e0 81 0f 54 	brne	80009bf6 <_vfprintf_r+0x1f06>
80007d52:	82 68       	ld.sh	r8,r1[0xc]
80007d54:	10 99       	mov	r9,r8
80007d56:	e2 19 00 1a 	andl	r9,0x1a,COH
80007d5a:	58 a9       	cp.w	r9,10
80007d5c:	c3 c1       	brne	80007dd4 <_vfprintf_r+0xe4>
80007d5e:	82 79       	ld.sh	r9,r1[0xe]
80007d60:	30 0a       	mov	r10,0
80007d62:	f4 09 19 00 	cp.h	r9,r10
80007d66:	c3 75       	brlt	80007dd4 <_vfprintf_r+0xe4>
80007d68:	a1 d8       	cbr	r8,0x1
80007d6a:	fb 58 05 d0 	st.h	sp[1488],r8
80007d6e:	62 88       	ld.w	r8,r1[0x20]
80007d70:	fb 48 05 e4 	st.w	sp[1508],r8
80007d74:	62 a8       	ld.w	r8,r1[0x28]
80007d76:	fb 48 05 ec 	st.w	sp[1516],r8
80007d7a:	fa c8 ff bc 	sub	r8,sp,-68
80007d7e:	fb 48 05 d4 	st.w	sp[1492],r8
80007d82:	fb 48 05 c4 	st.w	sp[1476],r8
80007d86:	e0 68 04 00 	mov	r8,1024
80007d8a:	fb 48 05 d8 	st.w	sp[1496],r8
80007d8e:	fb 48 05 cc 	st.w	sp[1484],r8
80007d92:	30 08       	mov	r8,0
80007d94:	fb 59 05 d2 	st.h	sp[1490],r9
80007d98:	0e 9a       	mov	r10,r7
80007d9a:	41 09       	lddsp	r9,sp[0x40]
80007d9c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007da0:	fb 48 05 dc 	st.w	sp[1500],r8
80007da4:	0a 9c       	mov	r12,r5
80007da6:	0e 9b       	mov	r11,r7
80007da8:	ca 4f       	rcall	80007cf0 <_vfprintf_r>
80007daa:	50 bc       	stdsp	sp[0x2c],r12
80007dac:	c0 95       	brlt	80007dbe <_vfprintf_r+0xce>
80007dae:	0e 9b       	mov	r11,r7
80007db0:	0a 9c       	mov	r12,r5
80007db2:	e0 a0 16 1b 	rcall	8000a9e8 <_fflush_r>
80007db6:	40 be       	lddsp	lr,sp[0x2c]
80007db8:	f9 be 01 ff 	movne	lr,-1
80007dbc:	50 be       	stdsp	sp[0x2c],lr
80007dbe:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007dc2:	ed b8 00 06 	bld	r8,0x6
80007dc6:	e0 81 0f 1a 	brne	80009bfa <_vfprintf_r+0x1f0a>
80007dca:	82 68       	ld.sh	r8,r1[0xc]
80007dcc:	a7 a8       	sbr	r8,0x6
80007dce:	a2 68       	st.h	r1[0xc],r8
80007dd0:	e0 8f 0f 15 	bral	80009bfa <_vfprintf_r+0x1f0a>
80007dd4:	30 08       	mov	r8,0
80007dd6:	fb 48 06 b4 	st.w	sp[1716],r8
80007dda:	fb 48 06 90 	st.w	sp[1680],r8
80007dde:	fb 48 06 8c 	st.w	sp[1676],r8
80007de2:	fb 48 06 b0 	st.w	sp[1712],r8
80007de6:	30 08       	mov	r8,0
80007de8:	30 09       	mov	r9,0
80007dea:	50 a7       	stdsp	sp[0x28],r7
80007dec:	50 78       	stdsp	sp[0x1c],r8
80007dee:	fa c3 f9 e0 	sub	r3,sp,-1568
80007df2:	3f f8       	mov	r8,-1
80007df4:	50 59       	stdsp	sp[0x14],r9
80007df6:	fb 43 06 88 	st.w	sp[1672],r3
80007dfa:	fb 48 05 44 	st.w	sp[1348],r8
80007dfe:	12 9c       	mov	r12,r9
80007e00:	50 69       	stdsp	sp[0x18],r9
80007e02:	50 d9       	stdsp	sp[0x34],r9
80007e04:	50 e9       	stdsp	sp[0x38],r9
80007e06:	50 b9       	stdsp	sp[0x2c],r9
80007e08:	12 97       	mov	r7,r9
80007e0a:	0a 94       	mov	r4,r5
80007e0c:	40 a2       	lddsp	r2,sp[0x28]
80007e0e:	32 5a       	mov	r10,37
80007e10:	30 08       	mov	r8,0
80007e12:	c0 28       	rjmp	80007e16 <_vfprintf_r+0x126>
80007e14:	2f f2       	sub	r2,-1
80007e16:	05 89       	ld.ub	r9,r2[0x0]
80007e18:	f0 09 18 00 	cp.b	r9,r8
80007e1c:	5f 1b       	srne	r11
80007e1e:	f4 09 18 00 	cp.b	r9,r10
80007e22:	5f 19       	srne	r9
80007e24:	f3 eb 00 0b 	and	r11,r9,r11
80007e28:	f0 0b 18 00 	cp.b	r11,r8
80007e2c:	cf 41       	brne	80007e14 <_vfprintf_r+0x124>
80007e2e:	40 ab       	lddsp	r11,sp[0x28]
80007e30:	e4 0b 01 06 	sub	r6,r2,r11
80007e34:	c1 e0       	breq	80007e70 <_vfprintf_r+0x180>
80007e36:	fa f8 06 90 	ld.w	r8,sp[1680]
80007e3a:	0c 08       	add	r8,r6
80007e3c:	87 0b       	st.w	r3[0x0],r11
80007e3e:	fb 48 06 90 	st.w	sp[1680],r8
80007e42:	87 16       	st.w	r3[0x4],r6
80007e44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007e48:	2f f8       	sub	r8,-1
80007e4a:	fb 48 06 8c 	st.w	sp[1676],r8
80007e4e:	58 78       	cp.w	r8,7
80007e50:	e0 89 00 04 	brgt	80007e58 <_vfprintf_r+0x168>
80007e54:	2f 83       	sub	r3,-8
80007e56:	c0 a8       	rjmp	80007e6a <_vfprintf_r+0x17a>
80007e58:	fa ca f9 78 	sub	r10,sp,-1672
80007e5c:	02 9b       	mov	r11,r1
80007e5e:	08 9c       	mov	r12,r4
80007e60:	c3 af       	rcall	80007cd4 <__sprint_r>
80007e62:	e0 81 0e c6 	brne	80009bee <_vfprintf_r+0x1efe>
80007e66:	fa c3 f9 e0 	sub	r3,sp,-1568
80007e6a:	40 ba       	lddsp	r10,sp[0x2c]
80007e6c:	0c 0a       	add	r10,r6
80007e6e:	50 ba       	stdsp	sp[0x2c],r10
80007e70:	05 89       	ld.ub	r9,r2[0x0]
80007e72:	30 08       	mov	r8,0
80007e74:	f0 09 18 00 	cp.b	r9,r8
80007e78:	e0 80 0e aa 	breq	80009bcc <_vfprintf_r+0x1edc>
80007e7c:	30 09       	mov	r9,0
80007e7e:	fb 68 06 bb 	st.b	sp[1723],r8
80007e82:	0e 96       	mov	r6,r7
80007e84:	e4 c8 ff ff 	sub	r8,r2,-1
80007e88:	3f fe       	mov	lr,-1
80007e8a:	50 93       	stdsp	sp[0x24],r3
80007e8c:	50 41       	stdsp	sp[0x10],r1
80007e8e:	0e 93       	mov	r3,r7
80007e90:	04 91       	mov	r1,r2
80007e92:	50 89       	stdsp	sp[0x20],r9
80007e94:	50 a8       	stdsp	sp[0x28],r8
80007e96:	50 2e       	stdsp	sp[0x8],lr
80007e98:	50 39       	stdsp	sp[0xc],r9
80007e9a:	12 95       	mov	r5,r9
80007e9c:	12 90       	mov	r0,r9
80007e9e:	10 97       	mov	r7,r8
80007ea0:	08 92       	mov	r2,r4
80007ea2:	c0 78       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80007ea4:	3f fc       	mov	r12,-1
80007ea6:	08 97       	mov	r7,r4
80007ea8:	50 2c       	stdsp	sp[0x8],r12
80007eaa:	c0 38       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80007eac:	30 0b       	mov	r11,0
80007eae:	50 3b       	stdsp	sp[0xc],r11
80007eb0:	0f 38       	ld.ub	r8,r7++
80007eb2:	c0 28       	rjmp	80007eb6 <_vfprintf_r+0x1c6>
80007eb4:	12 90       	mov	r0,r9
80007eb6:	f0 c9 00 20 	sub	r9,r8,32
80007eba:	e0 49 00 58 	cp.w	r9,88
80007ebe:	e0 8b 0a 30 	brhi	8000931e <_vfprintf_r+0x162e>
80007ec2:	fe ca a6 b6 	sub	r10,pc,-22858
80007ec6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007eca:	50 a7       	stdsp	sp[0x28],r7
80007ecc:	50 80       	stdsp	sp[0x20],r0
80007ece:	0c 97       	mov	r7,r6
80007ed0:	04 94       	mov	r4,r2
80007ed2:	06 96       	mov	r6,r3
80007ed4:	02 92       	mov	r2,r1
80007ed6:	fe c9 a4 8e 	sub	r9,pc,-23410
80007eda:	40 93       	lddsp	r3,sp[0x24]
80007edc:	10 90       	mov	r0,r8
80007ede:	40 41       	lddsp	r1,sp[0x10]
80007ee0:	50 d9       	stdsp	sp[0x34],r9
80007ee2:	e0 8f 08 8e 	bral	80008ffe <_vfprintf_r+0x130e>
80007ee6:	30 08       	mov	r8,0
80007ee8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007eec:	f0 09 18 00 	cp.b	r9,r8
80007ef0:	ce 01       	brne	80007eb0 <_vfprintf_r+0x1c0>
80007ef2:	32 08       	mov	r8,32
80007ef4:	c6 e8       	rjmp	80007fd0 <_vfprintf_r+0x2e0>
80007ef6:	a1 a5       	sbr	r5,0x0
80007ef8:	cd cb       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80007efa:	0f 89       	ld.ub	r9,r7[0x0]
80007efc:	f2 c8 00 30 	sub	r8,r9,48
80007f00:	58 98       	cp.w	r8,9
80007f02:	e0 8b 00 1d 	brhi	80007f3c <_vfprintf_r+0x24c>
80007f06:	ee c8 ff ff 	sub	r8,r7,-1
80007f0a:	30 0b       	mov	r11,0
80007f0c:	23 09       	sub	r9,48
80007f0e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007f12:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007f16:	11 39       	ld.ub	r9,r8++
80007f18:	f2 ca 00 30 	sub	r10,r9,48
80007f1c:	58 9a       	cp.w	r10,9
80007f1e:	fe 98 ff f7 	brls	80007f0c <_vfprintf_r+0x21c>
80007f22:	e0 49 00 24 	cp.w	r9,36
80007f26:	cc 31       	brne	80007eac <_vfprintf_r+0x1bc>
80007f28:	e0 4b 00 20 	cp.w	r11,32
80007f2c:	e0 89 0e 60 	brgt	80009bec <_vfprintf_r+0x1efc>
80007f30:	20 1b       	sub	r11,1
80007f32:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007f36:	12 3b       	cp.w	r11,r9
80007f38:	c0 95       	brlt	80007f4a <_vfprintf_r+0x25a>
80007f3a:	c1 08       	rjmp	80007f5a <_vfprintf_r+0x26a>
80007f3c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007f40:	ec ca ff ff 	sub	r10,r6,-1
80007f44:	12 36       	cp.w	r6,r9
80007f46:	c1 f5       	brlt	80007f84 <_vfprintf_r+0x294>
80007f48:	c2 68       	rjmp	80007f94 <_vfprintf_r+0x2a4>
80007f4a:	fa ce f9 44 	sub	lr,sp,-1724
80007f4e:	10 97       	mov	r7,r8
80007f50:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007f54:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007f58:	c3 58       	rjmp	80007fc2 <_vfprintf_r+0x2d2>
80007f5a:	10 97       	mov	r7,r8
80007f5c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f60:	1a d8       	st.w	--sp,r8
80007f62:	fa c8 fa b8 	sub	r8,sp,-1352
80007f66:	1a d8       	st.w	--sp,r8
80007f68:	fa c8 fb b4 	sub	r8,sp,-1100
80007f6c:	02 9a       	mov	r10,r1
80007f6e:	1a d8       	st.w	--sp,r8
80007f70:	04 9c       	mov	r12,r2
80007f72:	fa c8 f9 40 	sub	r8,sp,-1728
80007f76:	fa c9 ff b4 	sub	r9,sp,-76
80007f7a:	fe b0 fd 23 	rcall	800079c0 <get_arg>
80007f7e:	2f dd       	sub	sp,-12
80007f80:	78 00       	ld.w	r0,r12[0x0]
80007f82:	c2 08       	rjmp	80007fc2 <_vfprintf_r+0x2d2>
80007f84:	fa cc f9 44 	sub	r12,sp,-1724
80007f88:	14 96       	mov	r6,r10
80007f8a:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007f8e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007f92:	c1 88       	rjmp	80007fc2 <_vfprintf_r+0x2d2>
80007f94:	41 08       	lddsp	r8,sp[0x40]
80007f96:	59 f9       	cp.w	r9,31
80007f98:	e0 89 00 11 	brgt	80007fba <_vfprintf_r+0x2ca>
80007f9c:	f0 cb ff fc 	sub	r11,r8,-4
80007fa0:	51 0b       	stdsp	sp[0x40],r11
80007fa2:	70 00       	ld.w	r0,r8[0x0]
80007fa4:	fa cb f9 44 	sub	r11,sp,-1724
80007fa8:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007fac:	f1 40 fd 88 	st.w	r8[-632],r0
80007fb0:	2f f9       	sub	r9,-1
80007fb2:	14 96       	mov	r6,r10
80007fb4:	fb 49 06 b4 	st.w	sp[1716],r9
80007fb8:	c0 58       	rjmp	80007fc2 <_vfprintf_r+0x2d2>
80007fba:	70 00       	ld.w	r0,r8[0x0]
80007fbc:	14 96       	mov	r6,r10
80007fbe:	2f c8       	sub	r8,-4
80007fc0:	51 08       	stdsp	sp[0x40],r8
80007fc2:	58 00       	cp.w	r0,0
80007fc4:	fe 94 ff 76 	brge	80007eb0 <_vfprintf_r+0x1c0>
80007fc8:	5c 30       	neg	r0
80007fca:	a3 a5       	sbr	r5,0x2
80007fcc:	c7 2b       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80007fce:	32 b8       	mov	r8,43
80007fd0:	fb 68 06 bb 	st.b	sp[1723],r8
80007fd4:	c6 eb       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80007fd6:	0f 38       	ld.ub	r8,r7++
80007fd8:	e0 48 00 2a 	cp.w	r8,42
80007fdc:	c0 30       	breq	80007fe2 <_vfprintf_r+0x2f2>
80007fde:	30 09       	mov	r9,0
80007fe0:	c7 98       	rjmp	800080d2 <_vfprintf_r+0x3e2>
80007fe2:	0f 88       	ld.ub	r8,r7[0x0]
80007fe4:	f0 c9 00 30 	sub	r9,r8,48
80007fe8:	58 99       	cp.w	r9,9
80007fea:	e0 8b 00 1f 	brhi	80008028 <_vfprintf_r+0x338>
80007fee:	ee c4 ff ff 	sub	r4,r7,-1
80007ff2:	30 0b       	mov	r11,0
80007ff4:	23 08       	sub	r8,48
80007ff6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ffa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007ffe:	09 38       	ld.ub	r8,r4++
80008000:	f0 c9 00 30 	sub	r9,r8,48
80008004:	58 99       	cp.w	r9,9
80008006:	fe 98 ff f7 	brls	80007ff4 <_vfprintf_r+0x304>
8000800a:	e0 48 00 24 	cp.w	r8,36
8000800e:	fe 91 ff 4f 	brne	80007eac <_vfprintf_r+0x1bc>
80008012:	e0 4b 00 20 	cp.w	r11,32
80008016:	e0 89 0d eb 	brgt	80009bec <_vfprintf_r+0x1efc>
8000801a:	20 1b       	sub	r11,1
8000801c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008020:	10 3b       	cp.w	r11,r8
80008022:	c0 a5       	brlt	80008036 <_vfprintf_r+0x346>
80008024:	c1 18       	rjmp	80008046 <_vfprintf_r+0x356>
80008026:	d7 03       	nop
80008028:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000802c:	ec c9 ff ff 	sub	r9,r6,-1
80008030:	14 36       	cp.w	r6,r10
80008032:	c1 f5       	brlt	80008070 <_vfprintf_r+0x380>
80008034:	c2 88       	rjmp	80008084 <_vfprintf_r+0x394>
80008036:	fa ca f9 44 	sub	r10,sp,-1724
8000803a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000803e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008042:	50 2b       	stdsp	sp[0x8],r11
80008044:	c3 c8       	rjmp	800080bc <_vfprintf_r+0x3cc>
80008046:	fa c8 f9 50 	sub	r8,sp,-1712
8000804a:	1a d8       	st.w	--sp,r8
8000804c:	fa c8 fa b8 	sub	r8,sp,-1352
80008050:	1a d8       	st.w	--sp,r8
80008052:	fa c8 fb b4 	sub	r8,sp,-1100
80008056:	02 9a       	mov	r10,r1
80008058:	1a d8       	st.w	--sp,r8
8000805a:	04 9c       	mov	r12,r2
8000805c:	fa c8 f9 40 	sub	r8,sp,-1728
80008060:	fa c9 ff b4 	sub	r9,sp,-76
80008064:	fe b0 fc ae 	rcall	800079c0 <get_arg>
80008068:	2f dd       	sub	sp,-12
8000806a:	78 0c       	ld.w	r12,r12[0x0]
8000806c:	50 2c       	stdsp	sp[0x8],r12
8000806e:	c2 78       	rjmp	800080bc <_vfprintf_r+0x3cc>
80008070:	12 96       	mov	r6,r9
80008072:	0e 94       	mov	r4,r7
80008074:	fa c9 f9 44 	sub	r9,sp,-1724
80008078:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000807c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008080:	50 28       	stdsp	sp[0x8],r8
80008082:	c1 d8       	rjmp	800080bc <_vfprintf_r+0x3cc>
80008084:	41 08       	lddsp	r8,sp[0x40]
80008086:	59 fa       	cp.w	r10,31
80008088:	e0 89 00 14 	brgt	800080b0 <_vfprintf_r+0x3c0>
8000808c:	f0 cb ff fc 	sub	r11,r8,-4
80008090:	70 08       	ld.w	r8,r8[0x0]
80008092:	51 0b       	stdsp	sp[0x40],r11
80008094:	50 28       	stdsp	sp[0x8],r8
80008096:	fa c6 f9 44 	sub	r6,sp,-1724
8000809a:	40 2e       	lddsp	lr,sp[0x8]
8000809c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800080a0:	f1 4e fd 88 	st.w	r8[-632],lr
800080a4:	2f fa       	sub	r10,-1
800080a6:	0e 94       	mov	r4,r7
800080a8:	fb 4a 06 b4 	st.w	sp[1716],r10
800080ac:	12 96       	mov	r6,r9
800080ae:	c0 78       	rjmp	800080bc <_vfprintf_r+0x3cc>
800080b0:	70 0c       	ld.w	r12,r8[0x0]
800080b2:	0e 94       	mov	r4,r7
800080b4:	2f c8       	sub	r8,-4
800080b6:	50 2c       	stdsp	sp[0x8],r12
800080b8:	12 96       	mov	r6,r9
800080ba:	51 08       	stdsp	sp[0x40],r8
800080bc:	40 2b       	lddsp	r11,sp[0x8]
800080be:	58 0b       	cp.w	r11,0
800080c0:	fe 95 fe f2 	brlt	80007ea4 <_vfprintf_r+0x1b4>
800080c4:	08 97       	mov	r7,r4
800080c6:	cf 5a       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
800080c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800080cc:	0f 38       	ld.ub	r8,r7++
800080ce:	f4 09 00 19 	add	r9,r10,r9<<0x1
800080d2:	f0 ca 00 30 	sub	r10,r8,48
800080d6:	58 9a       	cp.w	r10,9
800080d8:	fe 98 ff f8 	brls	800080c8 <_vfprintf_r+0x3d8>
800080dc:	3f fa       	mov	r10,-1
800080de:	f2 0a 0c 49 	max	r9,r9,r10
800080e2:	50 29       	stdsp	sp[0x8],r9
800080e4:	ce 9a       	rjmp	80007eb6 <_vfprintf_r+0x1c6>
800080e6:	a7 b5       	sbr	r5,0x7
800080e8:	ce 4a       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
800080ea:	30 09       	mov	r9,0
800080ec:	23 08       	sub	r8,48
800080ee:	f2 09 00 29 	add	r9,r9,r9<<0x2
800080f2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800080f6:	0f 38       	ld.ub	r8,r7++
800080f8:	f0 ca 00 30 	sub	r10,r8,48
800080fc:	58 9a       	cp.w	r10,9
800080fe:	fe 98 ff f7 	brls	800080ec <_vfprintf_r+0x3fc>
80008102:	e0 48 00 24 	cp.w	r8,36
80008106:	fe 91 fe d7 	brne	80007eb4 <_vfprintf_r+0x1c4>
8000810a:	e0 49 00 20 	cp.w	r9,32
8000810e:	e0 89 0d 6f 	brgt	80009bec <_vfprintf_r+0x1efc>
80008112:	f2 c3 00 01 	sub	r3,r9,1
80008116:	30 19       	mov	r9,1
80008118:	50 39       	stdsp	sp[0xc],r9
8000811a:	cc ba       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
8000811c:	a3 b5       	sbr	r5,0x3
8000811e:	cc 9a       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80008120:	a7 a5       	sbr	r5,0x6
80008122:	cc 7a       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80008124:	0a 98       	mov	r8,r5
80008126:	a5 b5       	sbr	r5,0x5
80008128:	a5 a8       	sbr	r8,0x4
8000812a:	0f 89       	ld.ub	r9,r7[0x0]
8000812c:	36 ce       	mov	lr,108
8000812e:	fc 09 18 00 	cp.b	r9,lr
80008132:	f7 b7 00 ff 	subeq	r7,-1
80008136:	f0 05 17 10 	movne	r5,r8
8000813a:	cb ba       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
8000813c:	a5 b5       	sbr	r5,0x5
8000813e:	cb 9a       	rjmp	80007eb0 <_vfprintf_r+0x1c0>
80008140:	50 a7       	stdsp	sp[0x28],r7
80008142:	50 80       	stdsp	sp[0x20],r0
80008144:	0c 97       	mov	r7,r6
80008146:	10 90       	mov	r0,r8
80008148:	06 96       	mov	r6,r3
8000814a:	04 94       	mov	r4,r2
8000814c:	40 93       	lddsp	r3,sp[0x24]
8000814e:	02 92       	mov	r2,r1
80008150:	0e 99       	mov	r9,r7
80008152:	40 41       	lddsp	r1,sp[0x10]
80008154:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008158:	40 3c       	lddsp	r12,sp[0xc]
8000815a:	58 0c       	cp.w	r12,0
8000815c:	c1 d0       	breq	80008196 <_vfprintf_r+0x4a6>
8000815e:	10 36       	cp.w	r6,r8
80008160:	c0 64       	brge	8000816c <_vfprintf_r+0x47c>
80008162:	fa cb f9 44 	sub	r11,sp,-1724
80008166:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000816a:	c1 d8       	rjmp	800081a4 <_vfprintf_r+0x4b4>
8000816c:	fa c8 f9 50 	sub	r8,sp,-1712
80008170:	1a d8       	st.w	--sp,r8
80008172:	fa c8 fa b8 	sub	r8,sp,-1352
80008176:	1a d8       	st.w	--sp,r8
80008178:	fa c8 fb b4 	sub	r8,sp,-1100
8000817c:	1a d8       	st.w	--sp,r8
8000817e:	fa c8 f9 40 	sub	r8,sp,-1728
80008182:	fa c9 ff b4 	sub	r9,sp,-76
80008186:	04 9a       	mov	r10,r2
80008188:	0c 9b       	mov	r11,r6
8000818a:	08 9c       	mov	r12,r4
8000818c:	fe b0 fc 1a 	rcall	800079c0 <get_arg>
80008190:	2f dd       	sub	sp,-12
80008192:	19 b8       	ld.ub	r8,r12[0x3]
80008194:	c2 28       	rjmp	800081d8 <_vfprintf_r+0x4e8>
80008196:	2f f7       	sub	r7,-1
80008198:	10 39       	cp.w	r9,r8
8000819a:	c0 84       	brge	800081aa <_vfprintf_r+0x4ba>
8000819c:	fa ca f9 44 	sub	r10,sp,-1724
800081a0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081a4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800081a8:	c1 88       	rjmp	800081d8 <_vfprintf_r+0x4e8>
800081aa:	41 09       	lddsp	r9,sp[0x40]
800081ac:	59 f8       	cp.w	r8,31
800081ae:	e0 89 00 12 	brgt	800081d2 <_vfprintf_r+0x4e2>
800081b2:	f2 ca ff fc 	sub	r10,r9,-4
800081b6:	51 0a       	stdsp	sp[0x40],r10
800081b8:	72 09       	ld.w	r9,r9[0x0]
800081ba:	fa c6 f9 44 	sub	r6,sp,-1724
800081be:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800081c2:	2f f8       	sub	r8,-1
800081c4:	f5 49 fd 88 	st.w	r10[-632],r9
800081c8:	fb 48 06 b4 	st.w	sp[1716],r8
800081cc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800081d0:	c0 48       	rjmp	800081d8 <_vfprintf_r+0x4e8>
800081d2:	13 b8       	ld.ub	r8,r9[0x3]
800081d4:	2f c9       	sub	r9,-4
800081d6:	51 09       	stdsp	sp[0x40],r9
800081d8:	fb 68 06 60 	st.b	sp[1632],r8
800081dc:	30 0e       	mov	lr,0
800081de:	30 08       	mov	r8,0
800081e0:	30 12       	mov	r2,1
800081e2:	fb 68 06 bb 	st.b	sp[1723],r8
800081e6:	50 2e       	stdsp	sp[0x8],lr
800081e8:	e0 8f 08 ad 	bral	80009342 <_vfprintf_r+0x1652>
800081ec:	50 a7       	stdsp	sp[0x28],r7
800081ee:	50 80       	stdsp	sp[0x20],r0
800081f0:	0c 97       	mov	r7,r6
800081f2:	04 94       	mov	r4,r2
800081f4:	06 96       	mov	r6,r3
800081f6:	02 92       	mov	r2,r1
800081f8:	40 93       	lddsp	r3,sp[0x24]
800081fa:	10 90       	mov	r0,r8
800081fc:	40 41       	lddsp	r1,sp[0x10]
800081fe:	a5 a5       	sbr	r5,0x4
80008200:	c0 a8       	rjmp	80008214 <_vfprintf_r+0x524>
80008202:	50 a7       	stdsp	sp[0x28],r7
80008204:	50 80       	stdsp	sp[0x20],r0
80008206:	0c 97       	mov	r7,r6
80008208:	04 94       	mov	r4,r2
8000820a:	06 96       	mov	r6,r3
8000820c:	02 92       	mov	r2,r1
8000820e:	40 93       	lddsp	r3,sp[0x24]
80008210:	10 90       	mov	r0,r8
80008212:	40 41       	lddsp	r1,sp[0x10]
80008214:	ed b5 00 05 	bld	r5,0x5
80008218:	c5 11       	brne	800082ba <_vfprintf_r+0x5ca>
8000821a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000821e:	40 3c       	lddsp	r12,sp[0xc]
80008220:	58 0c       	cp.w	r12,0
80008222:	c1 e0       	breq	8000825e <_vfprintf_r+0x56e>
80008224:	10 36       	cp.w	r6,r8
80008226:	c0 64       	brge	80008232 <_vfprintf_r+0x542>
80008228:	fa cb f9 44 	sub	r11,sp,-1724
8000822c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008230:	c2 08       	rjmp	80008270 <_vfprintf_r+0x580>
80008232:	fa c8 f9 50 	sub	r8,sp,-1712
80008236:	1a d8       	st.w	--sp,r8
80008238:	fa c8 fa b8 	sub	r8,sp,-1352
8000823c:	0c 9b       	mov	r11,r6
8000823e:	1a d8       	st.w	--sp,r8
80008240:	fa c8 fb b4 	sub	r8,sp,-1100
80008244:	1a d8       	st.w	--sp,r8
80008246:	fa c9 ff b4 	sub	r9,sp,-76
8000824a:	fa c8 f9 40 	sub	r8,sp,-1728
8000824e:	04 9a       	mov	r10,r2
80008250:	08 9c       	mov	r12,r4
80008252:	fe b0 fb b7 	rcall	800079c0 <get_arg>
80008256:	2f dd       	sub	sp,-12
80008258:	78 1b       	ld.w	r11,r12[0x4]
8000825a:	78 09       	ld.w	r9,r12[0x0]
8000825c:	c2 b8       	rjmp	800082b2 <_vfprintf_r+0x5c2>
8000825e:	ee ca ff ff 	sub	r10,r7,-1
80008262:	10 37       	cp.w	r7,r8
80008264:	c0 b4       	brge	8000827a <_vfprintf_r+0x58a>
80008266:	fa c9 f9 44 	sub	r9,sp,-1724
8000826a:	14 97       	mov	r7,r10
8000826c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008270:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008274:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008278:	c1 d8       	rjmp	800082b2 <_vfprintf_r+0x5c2>
8000827a:	41 09       	lddsp	r9,sp[0x40]
8000827c:	59 f8       	cp.w	r8,31
8000827e:	e0 89 00 14 	brgt	800082a6 <_vfprintf_r+0x5b6>
80008282:	f2 cb ff f8 	sub	r11,r9,-8
80008286:	51 0b       	stdsp	sp[0x40],r11
80008288:	fa c6 f9 44 	sub	r6,sp,-1724
8000828c:	72 1b       	ld.w	r11,r9[0x4]
8000828e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008292:	72 09       	ld.w	r9,r9[0x0]
80008294:	f9 4b fd 8c 	st.w	r12[-628],r11
80008298:	f9 49 fd 88 	st.w	r12[-632],r9
8000829c:	2f f8       	sub	r8,-1
8000829e:	14 97       	mov	r7,r10
800082a0:	fb 48 06 b4 	st.w	sp[1716],r8
800082a4:	c0 78       	rjmp	800082b2 <_vfprintf_r+0x5c2>
800082a6:	f2 c8 ff f8 	sub	r8,r9,-8
800082aa:	72 1b       	ld.w	r11,r9[0x4]
800082ac:	14 97       	mov	r7,r10
800082ae:	51 08       	stdsp	sp[0x40],r8
800082b0:	72 09       	ld.w	r9,r9[0x0]
800082b2:	16 98       	mov	r8,r11
800082b4:	fa e9 00 00 	st.d	sp[0],r8
800082b8:	ca e8       	rjmp	80008414 <_vfprintf_r+0x724>
800082ba:	ed b5 00 04 	bld	r5,0x4
800082be:	c1 71       	brne	800082ec <_vfprintf_r+0x5fc>
800082c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082c4:	40 3e       	lddsp	lr,sp[0xc]
800082c6:	58 0e       	cp.w	lr,0
800082c8:	c0 80       	breq	800082d8 <_vfprintf_r+0x5e8>
800082ca:	10 36       	cp.w	r6,r8
800082cc:	c6 94       	brge	8000839e <_vfprintf_r+0x6ae>
800082ce:	fa cc f9 44 	sub	r12,sp,-1724
800082d2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800082d6:	c8 28       	rjmp	800083da <_vfprintf_r+0x6ea>
800082d8:	ee ca ff ff 	sub	r10,r7,-1
800082dc:	10 37       	cp.w	r7,r8
800082de:	e0 84 00 81 	brge	800083e0 <_vfprintf_r+0x6f0>
800082e2:	fa cb f9 44 	sub	r11,sp,-1724
800082e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082ea:	c7 78       	rjmp	800083d8 <_vfprintf_r+0x6e8>
800082ec:	ed b5 00 06 	bld	r5,0x6
800082f0:	c4 b1       	brne	80008386 <_vfprintf_r+0x696>
800082f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082f6:	40 3c       	lddsp	r12,sp[0xc]
800082f8:	58 0c       	cp.w	r12,0
800082fa:	c1 d0       	breq	80008334 <_vfprintf_r+0x644>
800082fc:	10 36       	cp.w	r6,r8
800082fe:	c0 64       	brge	8000830a <_vfprintf_r+0x61a>
80008300:	fa cb f9 44 	sub	r11,sp,-1724
80008304:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008308:	c1 f8       	rjmp	80008346 <_vfprintf_r+0x656>
8000830a:	fa c8 f9 50 	sub	r8,sp,-1712
8000830e:	1a d8       	st.w	--sp,r8
80008310:	fa c8 fa b8 	sub	r8,sp,-1352
80008314:	1a d8       	st.w	--sp,r8
80008316:	fa c8 fb b4 	sub	r8,sp,-1100
8000831a:	1a d8       	st.w	--sp,r8
8000831c:	fa c8 f9 40 	sub	r8,sp,-1728
80008320:	fa c9 ff b4 	sub	r9,sp,-76
80008324:	04 9a       	mov	r10,r2
80008326:	0c 9b       	mov	r11,r6
80008328:	08 9c       	mov	r12,r4
8000832a:	fe b0 fb 4b 	rcall	800079c0 <get_arg>
8000832e:	2f dd       	sub	sp,-12
80008330:	98 18       	ld.sh	r8,r12[0x2]
80008332:	c2 68       	rjmp	8000837e <_vfprintf_r+0x68e>
80008334:	ee ca ff ff 	sub	r10,r7,-1
80008338:	10 37       	cp.w	r7,r8
8000833a:	c0 94       	brge	8000834c <_vfprintf_r+0x65c>
8000833c:	fa c9 f9 44 	sub	r9,sp,-1724
80008340:	14 97       	mov	r7,r10
80008342:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008346:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000834a:	c1 a8       	rjmp	8000837e <_vfprintf_r+0x68e>
8000834c:	41 09       	lddsp	r9,sp[0x40]
8000834e:	59 f8       	cp.w	r8,31
80008350:	e0 89 00 13 	brgt	80008376 <_vfprintf_r+0x686>
80008354:	f2 cb ff fc 	sub	r11,r9,-4
80008358:	51 0b       	stdsp	sp[0x40],r11
8000835a:	72 09       	ld.w	r9,r9[0x0]
8000835c:	fa c6 f9 44 	sub	r6,sp,-1724
80008360:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008364:	2f f8       	sub	r8,-1
80008366:	f7 49 fd 88 	st.w	r11[-632],r9
8000836a:	fb 48 06 b4 	st.w	sp[1716],r8
8000836e:	14 97       	mov	r7,r10
80008370:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008374:	c0 58       	rjmp	8000837e <_vfprintf_r+0x68e>
80008376:	92 18       	ld.sh	r8,r9[0x2]
80008378:	14 97       	mov	r7,r10
8000837a:	2f c9       	sub	r9,-4
8000837c:	51 09       	stdsp	sp[0x40],r9
8000837e:	50 18       	stdsp	sp[0x4],r8
80008380:	bf 58       	asr	r8,0x1f
80008382:	50 08       	stdsp	sp[0x0],r8
80008384:	c4 88       	rjmp	80008414 <_vfprintf_r+0x724>
80008386:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000838a:	40 3c       	lddsp	r12,sp[0xc]
8000838c:	58 0c       	cp.w	r12,0
8000838e:	c1 d0       	breq	800083c8 <_vfprintf_r+0x6d8>
80008390:	10 36       	cp.w	r6,r8
80008392:	c0 64       	brge	8000839e <_vfprintf_r+0x6ae>
80008394:	fa cb f9 44 	sub	r11,sp,-1724
80008398:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000839c:	c1 f8       	rjmp	800083da <_vfprintf_r+0x6ea>
8000839e:	fa c8 f9 50 	sub	r8,sp,-1712
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	fa c8 fa b8 	sub	r8,sp,-1352
800083a8:	0c 9b       	mov	r11,r6
800083aa:	1a d8       	st.w	--sp,r8
800083ac:	fa c8 fb b4 	sub	r8,sp,-1100
800083b0:	04 9a       	mov	r10,r2
800083b2:	1a d8       	st.w	--sp,r8
800083b4:	08 9c       	mov	r12,r4
800083b6:	fa c8 f9 40 	sub	r8,sp,-1728
800083ba:	fa c9 ff b4 	sub	r9,sp,-76
800083be:	fe b0 fb 01 	rcall	800079c0 <get_arg>
800083c2:	2f dd       	sub	sp,-12
800083c4:	78 0b       	ld.w	r11,r12[0x0]
800083c6:	c2 48       	rjmp	8000840e <_vfprintf_r+0x71e>
800083c8:	ee ca ff ff 	sub	r10,r7,-1
800083cc:	10 37       	cp.w	r7,r8
800083ce:	c0 94       	brge	800083e0 <_vfprintf_r+0x6f0>
800083d0:	fa c9 f9 44 	sub	r9,sp,-1724
800083d4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083d8:	14 97       	mov	r7,r10
800083da:	ec fb fd 88 	ld.w	r11,r6[-632]
800083de:	c1 88       	rjmp	8000840e <_vfprintf_r+0x71e>
800083e0:	41 09       	lddsp	r9,sp[0x40]
800083e2:	59 f8       	cp.w	r8,31
800083e4:	e0 89 00 11 	brgt	80008406 <_vfprintf_r+0x716>
800083e8:	f2 cb ff fc 	sub	r11,r9,-4
800083ec:	51 0b       	stdsp	sp[0x40],r11
800083ee:	fa c6 f9 44 	sub	r6,sp,-1724
800083f2:	72 0b       	ld.w	r11,r9[0x0]
800083f4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083f8:	f3 4b fd 88 	st.w	r9[-632],r11
800083fc:	2f f8       	sub	r8,-1
800083fe:	14 97       	mov	r7,r10
80008400:	fb 48 06 b4 	st.w	sp[1716],r8
80008404:	c0 58       	rjmp	8000840e <_vfprintf_r+0x71e>
80008406:	72 0b       	ld.w	r11,r9[0x0]
80008408:	14 97       	mov	r7,r10
8000840a:	2f c9       	sub	r9,-4
8000840c:	51 09       	stdsp	sp[0x40],r9
8000840e:	50 1b       	stdsp	sp[0x4],r11
80008410:	bf 5b       	asr	r11,0x1f
80008412:	50 0b       	stdsp	sp[0x0],r11
80008414:	fa ea 00 00 	ld.d	r10,sp[0]
80008418:	58 0a       	cp.w	r10,0
8000841a:	5c 2b       	cpc	r11
8000841c:	c0 e4       	brge	80008438 <_vfprintf_r+0x748>
8000841e:	30 08       	mov	r8,0
80008420:	fa ea 00 00 	ld.d	r10,sp[0]
80008424:	30 09       	mov	r9,0
80008426:	f0 0a 01 0a 	sub	r10,r8,r10
8000842a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000842e:	32 d8       	mov	r8,45
80008430:	fa eb 00 00 	st.d	sp[0],r10
80008434:	fb 68 06 bb 	st.b	sp[1723],r8
80008438:	30 18       	mov	r8,1
8000843a:	e0 8f 06 fa 	bral	8000922e <_vfprintf_r+0x153e>
8000843e:	50 a7       	stdsp	sp[0x28],r7
80008440:	50 80       	stdsp	sp[0x20],r0
80008442:	0c 97       	mov	r7,r6
80008444:	04 94       	mov	r4,r2
80008446:	06 96       	mov	r6,r3
80008448:	02 92       	mov	r2,r1
8000844a:	40 93       	lddsp	r3,sp[0x24]
8000844c:	10 90       	mov	r0,r8
8000844e:	40 41       	lddsp	r1,sp[0x10]
80008450:	0e 99       	mov	r9,r7
80008452:	ed b5 00 03 	bld	r5,0x3
80008456:	c4 11       	brne	800084d8 <_vfprintf_r+0x7e8>
80008458:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000845c:	40 3a       	lddsp	r10,sp[0xc]
8000845e:	58 0a       	cp.w	r10,0
80008460:	c1 90       	breq	80008492 <_vfprintf_r+0x7a2>
80008462:	10 36       	cp.w	r6,r8
80008464:	c6 45       	brlt	8000852c <_vfprintf_r+0x83c>
80008466:	fa c8 f9 50 	sub	r8,sp,-1712
8000846a:	1a d8       	st.w	--sp,r8
8000846c:	fa c8 fa b8 	sub	r8,sp,-1352
80008470:	1a d8       	st.w	--sp,r8
80008472:	fa c8 fb b4 	sub	r8,sp,-1100
80008476:	0c 9b       	mov	r11,r6
80008478:	1a d8       	st.w	--sp,r8
8000847a:	04 9a       	mov	r10,r2
8000847c:	fa c8 f9 40 	sub	r8,sp,-1728
80008480:	fa c9 ff b4 	sub	r9,sp,-76
80008484:	08 9c       	mov	r12,r4
80008486:	fe b0 fa 9d 	rcall	800079c0 <get_arg>
8000848a:	2f dd       	sub	sp,-12
8000848c:	78 16       	ld.w	r6,r12[0x4]
8000848e:	50 76       	stdsp	sp[0x1c],r6
80008490:	c4 88       	rjmp	80008520 <_vfprintf_r+0x830>
80008492:	2f f7       	sub	r7,-1
80008494:	10 39       	cp.w	r9,r8
80008496:	c0 c4       	brge	800084ae <_vfprintf_r+0x7be>
80008498:	fa ce f9 44 	sub	lr,sp,-1724
8000849c:	fc 06 00 36 	add	r6,lr,r6<<0x3
800084a0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800084a4:	50 7c       	stdsp	sp[0x1c],r12
800084a6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800084aa:	50 56       	stdsp	sp[0x14],r6
800084ac:	c6 68       	rjmp	80008578 <_vfprintf_r+0x888>
800084ae:	41 09       	lddsp	r9,sp[0x40]
800084b0:	59 f8       	cp.w	r8,31
800084b2:	e0 89 00 10 	brgt	800084d2 <_vfprintf_r+0x7e2>
800084b6:	f2 ca ff f8 	sub	r10,r9,-8
800084ba:	72 1b       	ld.w	r11,r9[0x4]
800084bc:	51 0a       	stdsp	sp[0x40],r10
800084be:	72 09       	ld.w	r9,r9[0x0]
800084c0:	fa ca f9 44 	sub	r10,sp,-1724
800084c4:	50 7b       	stdsp	sp[0x1c],r11
800084c6:	50 59       	stdsp	sp[0x14],r9
800084c8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800084cc:	40 5b       	lddsp	r11,sp[0x14]
800084ce:	40 7a       	lddsp	r10,sp[0x1c]
800084d0:	c4 78       	rjmp	8000855e <_vfprintf_r+0x86e>
800084d2:	72 18       	ld.w	r8,r9[0x4]
800084d4:	50 78       	stdsp	sp[0x1c],r8
800084d6:	c4 c8       	rjmp	8000856e <_vfprintf_r+0x87e>
800084d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084dc:	40 3e       	lddsp	lr,sp[0xc]
800084de:	58 0e       	cp.w	lr,0
800084e0:	c2 30       	breq	80008526 <_vfprintf_r+0x836>
800084e2:	10 36       	cp.w	r6,r8
800084e4:	c0 94       	brge	800084f6 <_vfprintf_r+0x806>
800084e6:	fa cc f9 44 	sub	r12,sp,-1724
800084ea:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084ee:	ec fb fd 8c 	ld.w	r11,r6[-628]
800084f2:	50 7b       	stdsp	sp[0x1c],r11
800084f4:	cd 9b       	rjmp	800084a6 <_vfprintf_r+0x7b6>
800084f6:	fa c8 f9 50 	sub	r8,sp,-1712
800084fa:	1a d8       	st.w	--sp,r8
800084fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008500:	04 9a       	mov	r10,r2
80008502:	1a d8       	st.w	--sp,r8
80008504:	fa c8 fb b4 	sub	r8,sp,-1100
80008508:	0c 9b       	mov	r11,r6
8000850a:	1a d8       	st.w	--sp,r8
8000850c:	08 9c       	mov	r12,r4
8000850e:	fa c8 f9 40 	sub	r8,sp,-1728
80008512:	fa c9 ff b4 	sub	r9,sp,-76
80008516:	fe b0 fa 55 	rcall	800079c0 <get_arg>
8000851a:	2f dd       	sub	sp,-12
8000851c:	78 1a       	ld.w	r10,r12[0x4]
8000851e:	50 7a       	stdsp	sp[0x1c],r10
80008520:	78 0c       	ld.w	r12,r12[0x0]
80008522:	50 5c       	stdsp	sp[0x14],r12
80008524:	c2 a8       	rjmp	80008578 <_vfprintf_r+0x888>
80008526:	2f f7       	sub	r7,-1
80008528:	10 39       	cp.w	r9,r8
8000852a:	c0 94       	brge	8000853c <_vfprintf_r+0x84c>
8000852c:	fa c9 f9 44 	sub	r9,sp,-1724
80008530:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008534:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008538:	50 78       	stdsp	sp[0x1c],r8
8000853a:	cb 6b       	rjmp	800084a6 <_vfprintf_r+0x7b6>
8000853c:	41 09       	lddsp	r9,sp[0x40]
8000853e:	59 f8       	cp.w	r8,31
80008540:	e0 89 00 15 	brgt	8000856a <_vfprintf_r+0x87a>
80008544:	f2 ca ff f8 	sub	r10,r9,-8
80008548:	72 16       	ld.w	r6,r9[0x4]
8000854a:	72 09       	ld.w	r9,r9[0x0]
8000854c:	51 0a       	stdsp	sp[0x40],r10
8000854e:	50 59       	stdsp	sp[0x14],r9
80008550:	fa ce f9 44 	sub	lr,sp,-1724
80008554:	50 76       	stdsp	sp[0x1c],r6
80008556:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000855a:	40 5b       	lddsp	r11,sp[0x14]
8000855c:	0c 9a       	mov	r10,r6
8000855e:	f2 eb fd 88 	st.d	r9[-632],r10
80008562:	2f f8       	sub	r8,-1
80008564:	fb 48 06 b4 	st.w	sp[1716],r8
80008568:	c0 88       	rjmp	80008578 <_vfprintf_r+0x888>
8000856a:	72 1c       	ld.w	r12,r9[0x4]
8000856c:	50 7c       	stdsp	sp[0x1c],r12
8000856e:	f2 c8 ff f8 	sub	r8,r9,-8
80008572:	51 08       	stdsp	sp[0x40],r8
80008574:	72 09       	ld.w	r9,r9[0x0]
80008576:	50 59       	stdsp	sp[0x14],r9
80008578:	40 5b       	lddsp	r11,sp[0x14]
8000857a:	40 7a       	lddsp	r10,sp[0x1c]
8000857c:	e0 a0 19 54 	rcall	8000b824 <__isinfd>
80008580:	18 96       	mov	r6,r12
80008582:	c1 70       	breq	800085b0 <_vfprintf_r+0x8c0>
80008584:	30 08       	mov	r8,0
80008586:	30 09       	mov	r9,0
80008588:	40 5b       	lddsp	r11,sp[0x14]
8000858a:	40 7a       	lddsp	r10,sp[0x1c]
8000858c:	e0 a0 1d b4 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
80008590:	c0 40       	breq	80008598 <_vfprintf_r+0x8a8>
80008592:	32 d8       	mov	r8,45
80008594:	fb 68 06 bb 	st.b	sp[1723],r8
80008598:	fe c8 ab 3c 	sub	r8,pc,-21700
8000859c:	fe c6 ab 3c 	sub	r6,pc,-21700
800085a0:	a7 d5       	cbr	r5,0x7
800085a2:	e0 40 00 47 	cp.w	r0,71
800085a6:	f0 06 17 a0 	movle	r6,r8
800085aa:	30 32       	mov	r2,3
800085ac:	e0 8f 06 ce 	bral	80009348 <_vfprintf_r+0x1658>
800085b0:	40 5b       	lddsp	r11,sp[0x14]
800085b2:	40 7a       	lddsp	r10,sp[0x1c]
800085b4:	e0 a0 19 4d 	rcall	8000b84e <__isnand>
800085b8:	c0 e0       	breq	800085d4 <_vfprintf_r+0x8e4>
800085ba:	50 26       	stdsp	sp[0x8],r6
800085bc:	fe c8 ab 58 	sub	r8,pc,-21672
800085c0:	fe c6 ab 58 	sub	r6,pc,-21672
800085c4:	a7 d5       	cbr	r5,0x7
800085c6:	e0 40 00 47 	cp.w	r0,71
800085ca:	f0 06 17 a0 	movle	r6,r8
800085ce:	30 32       	mov	r2,3
800085d0:	e0 8f 06 c2 	bral	80009354 <_vfprintf_r+0x1664>
800085d4:	40 2a       	lddsp	r10,sp[0x8]
800085d6:	5b fa       	cp.w	r10,-1
800085d8:	c0 41       	brne	800085e0 <_vfprintf_r+0x8f0>
800085da:	30 69       	mov	r9,6
800085dc:	50 29       	stdsp	sp[0x8],r9
800085de:	c1 18       	rjmp	80008600 <_vfprintf_r+0x910>
800085e0:	e0 40 00 47 	cp.w	r0,71
800085e4:	5f 09       	sreq	r9
800085e6:	e0 40 00 67 	cp.w	r0,103
800085ea:	5f 08       	sreq	r8
800085ec:	f3 e8 10 08 	or	r8,r9,r8
800085f0:	f8 08 18 00 	cp.b	r8,r12
800085f4:	c0 60       	breq	80008600 <_vfprintf_r+0x910>
800085f6:	40 28       	lddsp	r8,sp[0x8]
800085f8:	58 08       	cp.w	r8,0
800085fa:	f9 b8 00 01 	moveq	r8,1
800085fe:	50 28       	stdsp	sp[0x8],r8
80008600:	40 78       	lddsp	r8,sp[0x1c]
80008602:	40 59       	lddsp	r9,sp[0x14]
80008604:	fa e9 06 94 	st.d	sp[1684],r8
80008608:	a9 a5       	sbr	r5,0x8
8000860a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000860e:	58 08       	cp.w	r8,0
80008610:	c0 65       	brlt	8000861c <_vfprintf_r+0x92c>
80008612:	40 5e       	lddsp	lr,sp[0x14]
80008614:	30 0c       	mov	r12,0
80008616:	50 6e       	stdsp	sp[0x18],lr
80008618:	50 9c       	stdsp	sp[0x24],r12
8000861a:	c0 78       	rjmp	80008628 <_vfprintf_r+0x938>
8000861c:	40 5b       	lddsp	r11,sp[0x14]
8000861e:	32 da       	mov	r10,45
80008620:	ee 1b 80 00 	eorh	r11,0x8000
80008624:	50 9a       	stdsp	sp[0x24],r10
80008626:	50 6b       	stdsp	sp[0x18],r11
80008628:	e0 40 00 46 	cp.w	r0,70
8000862c:	5f 09       	sreq	r9
8000862e:	e0 40 00 66 	cp.w	r0,102
80008632:	5f 08       	sreq	r8
80008634:	f3 e8 10 08 	or	r8,r9,r8
80008638:	50 48       	stdsp	sp[0x10],r8
8000863a:	c0 40       	breq	80008642 <_vfprintf_r+0x952>
8000863c:	40 22       	lddsp	r2,sp[0x8]
8000863e:	30 39       	mov	r9,3
80008640:	c1 08       	rjmp	80008660 <_vfprintf_r+0x970>
80008642:	e0 40 00 45 	cp.w	r0,69
80008646:	5f 09       	sreq	r9
80008648:	e0 40 00 65 	cp.w	r0,101
8000864c:	5f 08       	sreq	r8
8000864e:	40 22       	lddsp	r2,sp[0x8]
80008650:	10 49       	or	r9,r8
80008652:	2f f2       	sub	r2,-1
80008654:	40 46       	lddsp	r6,sp[0x10]
80008656:	ec 09 18 00 	cp.b	r9,r6
8000865a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000865e:	30 29       	mov	r9,2
80008660:	fa c8 f9 5c 	sub	r8,sp,-1700
80008664:	1a d8       	st.w	--sp,r8
80008666:	fa c8 f9 54 	sub	r8,sp,-1708
8000866a:	1a d8       	st.w	--sp,r8
8000866c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008670:	08 9c       	mov	r12,r4
80008672:	1a d8       	st.w	--sp,r8
80008674:	04 98       	mov	r8,r2
80008676:	40 9b       	lddsp	r11,sp[0x24]
80008678:	40 aa       	lddsp	r10,sp[0x28]
8000867a:	e0 a0 0b c3 	rcall	80009e00 <_dtoa_r>
8000867e:	e0 40 00 47 	cp.w	r0,71
80008682:	5f 19       	srne	r9
80008684:	e0 40 00 67 	cp.w	r0,103
80008688:	5f 18       	srne	r8
8000868a:	18 96       	mov	r6,r12
8000868c:	2f dd       	sub	sp,-12
8000868e:	f3 e8 00 08 	and	r8,r9,r8
80008692:	c0 41       	brne	8000869a <_vfprintf_r+0x9aa>
80008694:	ed b5 00 00 	bld	r5,0x0
80008698:	c3 01       	brne	800086f8 <_vfprintf_r+0xa08>
8000869a:	ec 02 00 0e 	add	lr,r6,r2
8000869e:	50 3e       	stdsp	sp[0xc],lr
800086a0:	40 4c       	lddsp	r12,sp[0x10]
800086a2:	58 0c       	cp.w	r12,0
800086a4:	c1 50       	breq	800086ce <_vfprintf_r+0x9de>
800086a6:	0d 89       	ld.ub	r9,r6[0x0]
800086a8:	33 08       	mov	r8,48
800086aa:	f0 09 18 00 	cp.b	r9,r8
800086ae:	c0 b1       	brne	800086c4 <_vfprintf_r+0x9d4>
800086b0:	30 08       	mov	r8,0
800086b2:	30 09       	mov	r9,0
800086b4:	40 6b       	lddsp	r11,sp[0x18]
800086b6:	40 7a       	lddsp	r10,sp[0x1c]
800086b8:	e0 a0 1c d7 	rcall	8000c066 <__avr32_f64_cmp_eq>
800086bc:	fb b2 00 01 	rsubeq	r2,1
800086c0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800086c4:	40 3b       	lddsp	r11,sp[0xc]
800086c6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800086ca:	10 0b       	add	r11,r8
800086cc:	50 3b       	stdsp	sp[0xc],r11
800086ce:	40 6b       	lddsp	r11,sp[0x18]
800086d0:	30 08       	mov	r8,0
800086d2:	30 09       	mov	r9,0
800086d4:	40 7a       	lddsp	r10,sp[0x1c]
800086d6:	e0 a0 1c c8 	rcall	8000c066 <__avr32_f64_cmp_eq>
800086da:	c0 90       	breq	800086ec <_vfprintf_r+0x9fc>
800086dc:	40 3a       	lddsp	r10,sp[0xc]
800086de:	fb 4a 06 a4 	st.w	sp[1700],r10
800086e2:	c0 58       	rjmp	800086ec <_vfprintf_r+0x9fc>
800086e4:	10 c9       	st.b	r8++,r9
800086e6:	fb 48 06 a4 	st.w	sp[1700],r8
800086ea:	c0 28       	rjmp	800086ee <_vfprintf_r+0x9fe>
800086ec:	33 09       	mov	r9,48
800086ee:	fa f8 06 a4 	ld.w	r8,sp[1700]
800086f2:	40 3e       	lddsp	lr,sp[0xc]
800086f4:	1c 38       	cp.w	r8,lr
800086f6:	cf 73       	brcs	800086e4 <_vfprintf_r+0x9f4>
800086f8:	e0 40 00 47 	cp.w	r0,71
800086fc:	5f 09       	sreq	r9
800086fe:	e0 40 00 67 	cp.w	r0,103
80008702:	5f 08       	sreq	r8
80008704:	f3 e8 10 08 	or	r8,r9,r8
80008708:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000870c:	0c 19       	sub	r9,r6
8000870e:	50 69       	stdsp	sp[0x18],r9
80008710:	58 08       	cp.w	r8,0
80008712:	c0 b0       	breq	80008728 <_vfprintf_r+0xa38>
80008714:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008718:	5b d8       	cp.w	r8,-3
8000871a:	c0 55       	brlt	80008724 <_vfprintf_r+0xa34>
8000871c:	40 2c       	lddsp	r12,sp[0x8]
8000871e:	18 38       	cp.w	r8,r12
80008720:	e0 8a 00 6a 	brle	800087f4 <_vfprintf_r+0xb04>
80008724:	20 20       	sub	r0,2
80008726:	c0 58       	rjmp	80008730 <_vfprintf_r+0xa40>
80008728:	e0 40 00 65 	cp.w	r0,101
8000872c:	e0 89 00 46 	brgt	800087b8 <_vfprintf_r+0xac8>
80008730:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008734:	fb 60 06 9c 	st.b	sp[1692],r0
80008738:	20 1b       	sub	r11,1
8000873a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000873e:	c0 47       	brpl	80008746 <_vfprintf_r+0xa56>
80008740:	5c 3b       	neg	r11
80008742:	32 d8       	mov	r8,45
80008744:	c0 28       	rjmp	80008748 <_vfprintf_r+0xa58>
80008746:	32 b8       	mov	r8,43
80008748:	fb 68 06 9d 	st.b	sp[1693],r8
8000874c:	58 9b       	cp.w	r11,9
8000874e:	e0 8a 00 1d 	brle	80008788 <_vfprintf_r+0xa98>
80008752:	fa c9 fa 35 	sub	r9,sp,-1483
80008756:	30 aa       	mov	r10,10
80008758:	12 98       	mov	r8,r9
8000875a:	0e 9c       	mov	r12,r7
8000875c:	0c 92       	mov	r2,r6
8000875e:	f6 0a 0c 06 	divs	r6,r11,r10
80008762:	0e 9b       	mov	r11,r7
80008764:	2d 0b       	sub	r11,-48
80008766:	10 fb       	st.b	--r8,r11
80008768:	0c 9b       	mov	r11,r6
8000876a:	58 96       	cp.w	r6,9
8000876c:	fe 99 ff f9 	brgt	8000875e <_vfprintf_r+0xa6e>
80008770:	2d 0b       	sub	r11,-48
80008772:	18 97       	mov	r7,r12
80008774:	04 96       	mov	r6,r2
80008776:	10 fb       	st.b	--r8,r11
80008778:	fa ca f9 62 	sub	r10,sp,-1694
8000877c:	c0 38       	rjmp	80008782 <_vfprintf_r+0xa92>
8000877e:	11 3b       	ld.ub	r11,r8++
80008780:	14 cb       	st.b	r10++,r11
80008782:	12 38       	cp.w	r8,r9
80008784:	cf d3       	brcs	8000877e <_vfprintf_r+0xa8e>
80008786:	c0 98       	rjmp	80008798 <_vfprintf_r+0xaa8>
80008788:	2d 0b       	sub	r11,-48
8000878a:	33 08       	mov	r8,48
8000878c:	fb 6b 06 9f 	st.b	sp[1695],r11
80008790:	fb 68 06 9e 	st.b	sp[1694],r8
80008794:	fa ca f9 60 	sub	r10,sp,-1696
80008798:	fa c8 f9 64 	sub	r8,sp,-1692
8000879c:	f4 08 01 08 	sub	r8,r10,r8
800087a0:	50 e8       	stdsp	sp[0x38],r8
800087a2:	10 92       	mov	r2,r8
800087a4:	40 6b       	lddsp	r11,sp[0x18]
800087a6:	16 02       	add	r2,r11
800087a8:	58 1b       	cp.w	r11,1
800087aa:	e0 89 00 05 	brgt	800087b4 <_vfprintf_r+0xac4>
800087ae:	ed b5 00 00 	bld	r5,0x0
800087b2:	c3 51       	brne	8000881c <_vfprintf_r+0xb2c>
800087b4:	2f f2       	sub	r2,-1
800087b6:	c3 38       	rjmp	8000881c <_vfprintf_r+0xb2c>
800087b8:	e0 40 00 66 	cp.w	r0,102
800087bc:	c1 c1       	brne	800087f4 <_vfprintf_r+0xb04>
800087be:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087c2:	58 02       	cp.w	r2,0
800087c4:	e0 8a 00 0c 	brle	800087dc <_vfprintf_r+0xaec>
800087c8:	40 2a       	lddsp	r10,sp[0x8]
800087ca:	58 0a       	cp.w	r10,0
800087cc:	c0 41       	brne	800087d4 <_vfprintf_r+0xae4>
800087ce:	ed b5 00 00 	bld	r5,0x0
800087d2:	c2 51       	brne	8000881c <_vfprintf_r+0xb2c>
800087d4:	2f f2       	sub	r2,-1
800087d6:	40 29       	lddsp	r9,sp[0x8]
800087d8:	12 02       	add	r2,r9
800087da:	c0 b8       	rjmp	800087f0 <_vfprintf_r+0xb00>
800087dc:	40 28       	lddsp	r8,sp[0x8]
800087de:	58 08       	cp.w	r8,0
800087e0:	c0 61       	brne	800087ec <_vfprintf_r+0xafc>
800087e2:	ed b5 00 00 	bld	r5,0x0
800087e6:	c0 30       	breq	800087ec <_vfprintf_r+0xafc>
800087e8:	30 12       	mov	r2,1
800087ea:	c1 98       	rjmp	8000881c <_vfprintf_r+0xb2c>
800087ec:	40 22       	lddsp	r2,sp[0x8]
800087ee:	2f e2       	sub	r2,-2
800087f0:	36 60       	mov	r0,102
800087f2:	c1 58       	rjmp	8000881c <_vfprintf_r+0xb2c>
800087f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087f8:	40 6e       	lddsp	lr,sp[0x18]
800087fa:	1c 32       	cp.w	r2,lr
800087fc:	c0 65       	brlt	80008808 <_vfprintf_r+0xb18>
800087fe:	ed b5 00 00 	bld	r5,0x0
80008802:	f7 b2 00 ff 	subeq	r2,-1
80008806:	c0 a8       	rjmp	8000881a <_vfprintf_r+0xb2a>
80008808:	e4 08 11 02 	rsub	r8,r2,2
8000880c:	40 6c       	lddsp	r12,sp[0x18]
8000880e:	58 02       	cp.w	r2,0
80008810:	f0 02 17 a0 	movle	r2,r8
80008814:	f9 b2 09 01 	movgt	r2,1
80008818:	18 02       	add	r2,r12
8000881a:	36 70       	mov	r0,103
8000881c:	40 9b       	lddsp	r11,sp[0x24]
8000881e:	58 0b       	cp.w	r11,0
80008820:	e0 80 05 94 	breq	80009348 <_vfprintf_r+0x1658>
80008824:	32 d8       	mov	r8,45
80008826:	fb 68 06 bb 	st.b	sp[1723],r8
8000882a:	e0 8f 05 93 	bral	80009350 <_vfprintf_r+0x1660>
8000882e:	50 a7       	stdsp	sp[0x28],r7
80008830:	04 94       	mov	r4,r2
80008832:	0c 97       	mov	r7,r6
80008834:	02 92       	mov	r2,r1
80008836:	06 96       	mov	r6,r3
80008838:	40 41       	lddsp	r1,sp[0x10]
8000883a:	40 93       	lddsp	r3,sp[0x24]
8000883c:	0e 99       	mov	r9,r7
8000883e:	ed b5 00 05 	bld	r5,0x5
80008842:	c4 81       	brne	800088d2 <_vfprintf_r+0xbe2>
80008844:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008848:	40 3e       	lddsp	lr,sp[0xc]
8000884a:	58 0e       	cp.w	lr,0
8000884c:	c1 d0       	breq	80008886 <_vfprintf_r+0xb96>
8000884e:	10 36       	cp.w	r6,r8
80008850:	c0 64       	brge	8000885c <_vfprintf_r+0xb6c>
80008852:	fa cc f9 44 	sub	r12,sp,-1724
80008856:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000885a:	c1 d8       	rjmp	80008894 <_vfprintf_r+0xba4>
8000885c:	fa c8 f9 50 	sub	r8,sp,-1712
80008860:	1a d8       	st.w	--sp,r8
80008862:	fa c8 fa b8 	sub	r8,sp,-1352
80008866:	04 9a       	mov	r10,r2
80008868:	1a d8       	st.w	--sp,r8
8000886a:	fa c8 fb b4 	sub	r8,sp,-1100
8000886e:	0c 9b       	mov	r11,r6
80008870:	1a d8       	st.w	--sp,r8
80008872:	08 9c       	mov	r12,r4
80008874:	fa c8 f9 40 	sub	r8,sp,-1728
80008878:	fa c9 ff b4 	sub	r9,sp,-76
8000887c:	fe b0 f8 a2 	rcall	800079c0 <get_arg>
80008880:	2f dd       	sub	sp,-12
80008882:	78 0a       	ld.w	r10,r12[0x0]
80008884:	c2 08       	rjmp	800088c4 <_vfprintf_r+0xbd4>
80008886:	2f f7       	sub	r7,-1
80008888:	10 39       	cp.w	r9,r8
8000888a:	c0 84       	brge	8000889a <_vfprintf_r+0xbaa>
8000888c:	fa cb f9 44 	sub	r11,sp,-1724
80008890:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008894:	ec fa fd 88 	ld.w	r10,r6[-632]
80008898:	c1 68       	rjmp	800088c4 <_vfprintf_r+0xbd4>
8000889a:	41 09       	lddsp	r9,sp[0x40]
8000889c:	59 f8       	cp.w	r8,31
8000889e:	e0 89 00 10 	brgt	800088be <_vfprintf_r+0xbce>
800088a2:	f2 ca ff fc 	sub	r10,r9,-4
800088a6:	51 0a       	stdsp	sp[0x40],r10
800088a8:	fa c6 f9 44 	sub	r6,sp,-1724
800088ac:	72 0a       	ld.w	r10,r9[0x0]
800088ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088b2:	f3 4a fd 88 	st.w	r9[-632],r10
800088b6:	2f f8       	sub	r8,-1
800088b8:	fb 48 06 b4 	st.w	sp[1716],r8
800088bc:	c0 48       	rjmp	800088c4 <_vfprintf_r+0xbd4>
800088be:	72 0a       	ld.w	r10,r9[0x0]
800088c0:	2f c9       	sub	r9,-4
800088c2:	51 09       	stdsp	sp[0x40],r9
800088c4:	40 be       	lddsp	lr,sp[0x2c]
800088c6:	1c 98       	mov	r8,lr
800088c8:	95 1e       	st.w	r10[0x4],lr
800088ca:	bf 58       	asr	r8,0x1f
800088cc:	95 08       	st.w	r10[0x0],r8
800088ce:	fe 9f fa 9f 	bral	80007e0c <_vfprintf_r+0x11c>
800088d2:	ed b5 00 04 	bld	r5,0x4
800088d6:	c4 80       	breq	80008966 <_vfprintf_r+0xc76>
800088d8:	e2 15 00 40 	andl	r5,0x40,COH
800088dc:	c4 50       	breq	80008966 <_vfprintf_r+0xc76>
800088de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e2:	40 3c       	lddsp	r12,sp[0xc]
800088e4:	58 0c       	cp.w	r12,0
800088e6:	c1 d0       	breq	80008920 <_vfprintf_r+0xc30>
800088e8:	10 36       	cp.w	r6,r8
800088ea:	c0 64       	brge	800088f6 <_vfprintf_r+0xc06>
800088ec:	fa cb f9 44 	sub	r11,sp,-1724
800088f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088f4:	c1 d8       	rjmp	8000892e <_vfprintf_r+0xc3e>
800088f6:	fa c8 f9 50 	sub	r8,sp,-1712
800088fa:	1a d8       	st.w	--sp,r8
800088fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008900:	04 9a       	mov	r10,r2
80008902:	1a d8       	st.w	--sp,r8
80008904:	fa c8 fb b4 	sub	r8,sp,-1100
80008908:	0c 9b       	mov	r11,r6
8000890a:	1a d8       	st.w	--sp,r8
8000890c:	08 9c       	mov	r12,r4
8000890e:	fa c8 f9 40 	sub	r8,sp,-1728
80008912:	fa c9 ff b4 	sub	r9,sp,-76
80008916:	fe b0 f8 55 	rcall	800079c0 <get_arg>
8000891a:	2f dd       	sub	sp,-12
8000891c:	78 0a       	ld.w	r10,r12[0x0]
8000891e:	c2 08       	rjmp	8000895e <_vfprintf_r+0xc6e>
80008920:	2f f7       	sub	r7,-1
80008922:	10 39       	cp.w	r9,r8
80008924:	c0 84       	brge	80008934 <_vfprintf_r+0xc44>
80008926:	fa ca f9 44 	sub	r10,sp,-1724
8000892a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000892e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008932:	c1 68       	rjmp	8000895e <_vfprintf_r+0xc6e>
80008934:	41 09       	lddsp	r9,sp[0x40]
80008936:	59 f8       	cp.w	r8,31
80008938:	e0 89 00 10 	brgt	80008958 <_vfprintf_r+0xc68>
8000893c:	f2 ca ff fc 	sub	r10,r9,-4
80008940:	51 0a       	stdsp	sp[0x40],r10
80008942:	fa c6 f9 44 	sub	r6,sp,-1724
80008946:	72 0a       	ld.w	r10,r9[0x0]
80008948:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000894c:	f3 4a fd 88 	st.w	r9[-632],r10
80008950:	2f f8       	sub	r8,-1
80008952:	fb 48 06 b4 	st.w	sp[1716],r8
80008956:	c0 48       	rjmp	8000895e <_vfprintf_r+0xc6e>
80008958:	72 0a       	ld.w	r10,r9[0x0]
8000895a:	2f c9       	sub	r9,-4
8000895c:	51 09       	stdsp	sp[0x40],r9
8000895e:	40 be       	lddsp	lr,sp[0x2c]
80008960:	b4 0e       	st.h	r10[0x0],lr
80008962:	fe 9f fa 55 	bral	80007e0c <_vfprintf_r+0x11c>
80008966:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000896a:	40 3c       	lddsp	r12,sp[0xc]
8000896c:	58 0c       	cp.w	r12,0
8000896e:	c1 d0       	breq	800089a8 <_vfprintf_r+0xcb8>
80008970:	10 36       	cp.w	r6,r8
80008972:	c0 64       	brge	8000897e <_vfprintf_r+0xc8e>
80008974:	fa cb f9 44 	sub	r11,sp,-1724
80008978:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000897c:	c1 d8       	rjmp	800089b6 <_vfprintf_r+0xcc6>
8000897e:	fa c8 f9 50 	sub	r8,sp,-1712
80008982:	1a d8       	st.w	--sp,r8
80008984:	fa c8 fa b8 	sub	r8,sp,-1352
80008988:	04 9a       	mov	r10,r2
8000898a:	1a d8       	st.w	--sp,r8
8000898c:	fa c8 fb b4 	sub	r8,sp,-1100
80008990:	0c 9b       	mov	r11,r6
80008992:	1a d8       	st.w	--sp,r8
80008994:	08 9c       	mov	r12,r4
80008996:	fa c8 f9 40 	sub	r8,sp,-1728
8000899a:	fa c9 ff b4 	sub	r9,sp,-76
8000899e:	fe b0 f8 11 	rcall	800079c0 <get_arg>
800089a2:	2f dd       	sub	sp,-12
800089a4:	78 0a       	ld.w	r10,r12[0x0]
800089a6:	c2 08       	rjmp	800089e6 <_vfprintf_r+0xcf6>
800089a8:	2f f7       	sub	r7,-1
800089aa:	10 39       	cp.w	r9,r8
800089ac:	c0 84       	brge	800089bc <_vfprintf_r+0xccc>
800089ae:	fa ca f9 44 	sub	r10,sp,-1724
800089b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800089b6:	ec fa fd 88 	ld.w	r10,r6[-632]
800089ba:	c1 68       	rjmp	800089e6 <_vfprintf_r+0xcf6>
800089bc:	41 09       	lddsp	r9,sp[0x40]
800089be:	59 f8       	cp.w	r8,31
800089c0:	e0 89 00 10 	brgt	800089e0 <_vfprintf_r+0xcf0>
800089c4:	f2 ca ff fc 	sub	r10,r9,-4
800089c8:	51 0a       	stdsp	sp[0x40],r10
800089ca:	fa c6 f9 44 	sub	r6,sp,-1724
800089ce:	72 0a       	ld.w	r10,r9[0x0]
800089d0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089d4:	f3 4a fd 88 	st.w	r9[-632],r10
800089d8:	2f f8       	sub	r8,-1
800089da:	fb 48 06 b4 	st.w	sp[1716],r8
800089de:	c0 48       	rjmp	800089e6 <_vfprintf_r+0xcf6>
800089e0:	72 0a       	ld.w	r10,r9[0x0]
800089e2:	2f c9       	sub	r9,-4
800089e4:	51 09       	stdsp	sp[0x40],r9
800089e6:	40 be       	lddsp	lr,sp[0x2c]
800089e8:	95 0e       	st.w	r10[0x0],lr
800089ea:	fe 9f fa 11 	bral	80007e0c <_vfprintf_r+0x11c>
800089ee:	50 a7       	stdsp	sp[0x28],r7
800089f0:	50 80       	stdsp	sp[0x20],r0
800089f2:	0c 97       	mov	r7,r6
800089f4:	04 94       	mov	r4,r2
800089f6:	06 96       	mov	r6,r3
800089f8:	02 92       	mov	r2,r1
800089fa:	40 93       	lddsp	r3,sp[0x24]
800089fc:	10 90       	mov	r0,r8
800089fe:	40 41       	lddsp	r1,sp[0x10]
80008a00:	a5 a5       	sbr	r5,0x4
80008a02:	c0 a8       	rjmp	80008a16 <_vfprintf_r+0xd26>
80008a04:	50 a7       	stdsp	sp[0x28],r7
80008a06:	50 80       	stdsp	sp[0x20],r0
80008a08:	0c 97       	mov	r7,r6
80008a0a:	04 94       	mov	r4,r2
80008a0c:	06 96       	mov	r6,r3
80008a0e:	02 92       	mov	r2,r1
80008a10:	40 93       	lddsp	r3,sp[0x24]
80008a12:	10 90       	mov	r0,r8
80008a14:	40 41       	lddsp	r1,sp[0x10]
80008a16:	ed b5 00 05 	bld	r5,0x5
80008a1a:	c5 d1       	brne	80008ad4 <_vfprintf_r+0xde4>
80008a1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a20:	40 3c       	lddsp	r12,sp[0xc]
80008a22:	58 0c       	cp.w	r12,0
80008a24:	c2 60       	breq	80008a70 <_vfprintf_r+0xd80>
80008a26:	10 36       	cp.w	r6,r8
80008a28:	c0 a4       	brge	80008a3c <_vfprintf_r+0xd4c>
80008a2a:	fa cb f9 44 	sub	r11,sp,-1724
80008a2e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a32:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008a36:	fa e9 00 00 	st.d	sp[0],r8
80008a3a:	c1 88       	rjmp	80008a6a <_vfprintf_r+0xd7a>
80008a3c:	fa c8 f9 50 	sub	r8,sp,-1712
80008a40:	1a d8       	st.w	--sp,r8
80008a42:	fa c8 fa b8 	sub	r8,sp,-1352
80008a46:	04 9a       	mov	r10,r2
80008a48:	1a d8       	st.w	--sp,r8
80008a4a:	0c 9b       	mov	r11,r6
80008a4c:	fa c8 fb b4 	sub	r8,sp,-1100
80008a50:	08 9c       	mov	r12,r4
80008a52:	1a d8       	st.w	--sp,r8
80008a54:	fa c8 f9 40 	sub	r8,sp,-1728
80008a58:	fa c9 ff b4 	sub	r9,sp,-76
80008a5c:	fe b0 f7 b2 	rcall	800079c0 <get_arg>
80008a60:	2f dd       	sub	sp,-12
80008a62:	f8 ea 00 00 	ld.d	r10,r12[0]
80008a66:	fa eb 00 00 	st.d	sp[0],r10
80008a6a:	30 08       	mov	r8,0
80008a6c:	e0 8f 03 de 	bral	80009228 <_vfprintf_r+0x1538>
80008a70:	ee ca ff ff 	sub	r10,r7,-1
80008a74:	10 37       	cp.w	r7,r8
80008a76:	c0 b4       	brge	80008a8c <_vfprintf_r+0xd9c>
80008a78:	fa c9 f9 44 	sub	r9,sp,-1724
80008a7c:	14 97       	mov	r7,r10
80008a7e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a82:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a86:	fa eb 00 00 	st.d	sp[0],r10
80008a8a:	c1 88       	rjmp	80008aba <_vfprintf_r+0xdca>
80008a8c:	41 09       	lddsp	r9,sp[0x40]
80008a8e:	59 f8       	cp.w	r8,31
80008a90:	e0 89 00 18 	brgt	80008ac0 <_vfprintf_r+0xdd0>
80008a94:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a98:	f2 cb ff f8 	sub	r11,r9,-8
80008a9c:	fa e7 00 00 	st.d	sp[0],r6
80008aa0:	51 0b       	stdsp	sp[0x40],r11
80008aa2:	fa c6 f9 44 	sub	r6,sp,-1724
80008aa6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aaa:	fa e6 00 00 	ld.d	r6,sp[0]
80008aae:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ab2:	2f f8       	sub	r8,-1
80008ab4:	14 97       	mov	r7,r10
80008ab6:	fb 48 06 b4 	st.w	sp[1716],r8
80008aba:	40 38       	lddsp	r8,sp[0xc]
80008abc:	e0 8f 03 b6 	bral	80009228 <_vfprintf_r+0x1538>
80008ac0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ac4:	40 38       	lddsp	r8,sp[0xc]
80008ac6:	fa e7 00 00 	st.d	sp[0],r6
80008aca:	2f 89       	sub	r9,-8
80008acc:	14 97       	mov	r7,r10
80008ace:	51 09       	stdsp	sp[0x40],r9
80008ad0:	e0 8f 03 ac 	bral	80009228 <_vfprintf_r+0x1538>
80008ad4:	ed b5 00 04 	bld	r5,0x4
80008ad8:	c1 61       	brne	80008b04 <_vfprintf_r+0xe14>
80008ada:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ade:	40 3e       	lddsp	lr,sp[0xc]
80008ae0:	58 0e       	cp.w	lr,0
80008ae2:	c0 80       	breq	80008af2 <_vfprintf_r+0xe02>
80008ae4:	10 36       	cp.w	r6,r8
80008ae6:	c6 74       	brge	80008bb4 <_vfprintf_r+0xec4>
80008ae8:	fa cc f9 44 	sub	r12,sp,-1724
80008aec:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008af0:	c8 08       	rjmp	80008bf0 <_vfprintf_r+0xf00>
80008af2:	ee ca ff ff 	sub	r10,r7,-1
80008af6:	10 37       	cp.w	r7,r8
80008af8:	c7 f4       	brge	80008bf6 <_vfprintf_r+0xf06>
80008afa:	fa cb f9 44 	sub	r11,sp,-1724
80008afe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b02:	c7 68       	rjmp	80008bee <_vfprintf_r+0xefe>
80008b04:	ed b5 00 06 	bld	r5,0x6
80008b08:	c4 a1       	brne	80008b9c <_vfprintf_r+0xeac>
80008b0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b0e:	40 3c       	lddsp	r12,sp[0xc]
80008b10:	58 0c       	cp.w	r12,0
80008b12:	c1 d0       	breq	80008b4c <_vfprintf_r+0xe5c>
80008b14:	10 36       	cp.w	r6,r8
80008b16:	c0 64       	brge	80008b22 <_vfprintf_r+0xe32>
80008b18:	fa cb f9 44 	sub	r11,sp,-1724
80008b1c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b20:	c1 f8       	rjmp	80008b5e <_vfprintf_r+0xe6e>
80008b22:	fa c8 f9 50 	sub	r8,sp,-1712
80008b26:	1a d8       	st.w	--sp,r8
80008b28:	fa c8 fa b8 	sub	r8,sp,-1352
80008b2c:	1a d8       	st.w	--sp,r8
80008b2e:	fa c8 fb b4 	sub	r8,sp,-1100
80008b32:	1a d8       	st.w	--sp,r8
80008b34:	fa c8 f9 40 	sub	r8,sp,-1728
80008b38:	fa c9 ff b4 	sub	r9,sp,-76
80008b3c:	04 9a       	mov	r10,r2
80008b3e:	0c 9b       	mov	r11,r6
80008b40:	08 9c       	mov	r12,r4
80008b42:	fe b0 f7 3f 	rcall	800079c0 <get_arg>
80008b46:	2f dd       	sub	sp,-12
80008b48:	98 18       	ld.sh	r8,r12[0x2]
80008b4a:	c2 68       	rjmp	80008b96 <_vfprintf_r+0xea6>
80008b4c:	ee ca ff ff 	sub	r10,r7,-1
80008b50:	10 37       	cp.w	r7,r8
80008b52:	c0 94       	brge	80008b64 <_vfprintf_r+0xe74>
80008b54:	fa c9 f9 44 	sub	r9,sp,-1724
80008b58:	14 97       	mov	r7,r10
80008b5a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b5e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008b62:	c1 a8       	rjmp	80008b96 <_vfprintf_r+0xea6>
80008b64:	41 09       	lddsp	r9,sp[0x40]
80008b66:	59 f8       	cp.w	r8,31
80008b68:	e0 89 00 13 	brgt	80008b8e <_vfprintf_r+0xe9e>
80008b6c:	f2 cb ff fc 	sub	r11,r9,-4
80008b70:	51 0b       	stdsp	sp[0x40],r11
80008b72:	72 09       	ld.w	r9,r9[0x0]
80008b74:	fa c6 f9 44 	sub	r6,sp,-1724
80008b78:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b7c:	2f f8       	sub	r8,-1
80008b7e:	f7 49 fd 88 	st.w	r11[-632],r9
80008b82:	fb 48 06 b4 	st.w	sp[1716],r8
80008b86:	14 97       	mov	r7,r10
80008b88:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b8c:	c0 58       	rjmp	80008b96 <_vfprintf_r+0xea6>
80008b8e:	92 18       	ld.sh	r8,r9[0x2]
80008b90:	14 97       	mov	r7,r10
80008b92:	2f c9       	sub	r9,-4
80008b94:	51 09       	stdsp	sp[0x40],r9
80008b96:	5c 78       	castu.h	r8
80008b98:	50 18       	stdsp	sp[0x4],r8
80008b9a:	c4 68       	rjmp	80008c26 <_vfprintf_r+0xf36>
80008b9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ba0:	40 3c       	lddsp	r12,sp[0xc]
80008ba2:	58 0c       	cp.w	r12,0
80008ba4:	c1 d0       	breq	80008bde <_vfprintf_r+0xeee>
80008ba6:	10 36       	cp.w	r6,r8
80008ba8:	c0 64       	brge	80008bb4 <_vfprintf_r+0xec4>
80008baa:	fa cb f9 44 	sub	r11,sp,-1724
80008bae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bb2:	c1 f8       	rjmp	80008bf0 <_vfprintf_r+0xf00>
80008bb4:	fa c8 f9 50 	sub	r8,sp,-1712
80008bb8:	1a d8       	st.w	--sp,r8
80008bba:	fa c8 fa b8 	sub	r8,sp,-1352
80008bbe:	0c 9b       	mov	r11,r6
80008bc0:	1a d8       	st.w	--sp,r8
80008bc2:	fa c8 fb b4 	sub	r8,sp,-1100
80008bc6:	04 9a       	mov	r10,r2
80008bc8:	1a d8       	st.w	--sp,r8
80008bca:	08 9c       	mov	r12,r4
80008bcc:	fa c8 f9 40 	sub	r8,sp,-1728
80008bd0:	fa c9 ff b4 	sub	r9,sp,-76
80008bd4:	fe b0 f6 f6 	rcall	800079c0 <get_arg>
80008bd8:	2f dd       	sub	sp,-12
80008bda:	78 0b       	ld.w	r11,r12[0x0]
80008bdc:	c2 48       	rjmp	80008c24 <_vfprintf_r+0xf34>
80008bde:	ee ca ff ff 	sub	r10,r7,-1
80008be2:	10 37       	cp.w	r7,r8
80008be4:	c0 94       	brge	80008bf6 <_vfprintf_r+0xf06>
80008be6:	fa c9 f9 44 	sub	r9,sp,-1724
80008bea:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bee:	14 97       	mov	r7,r10
80008bf0:	ec fb fd 88 	ld.w	r11,r6[-632]
80008bf4:	c1 88       	rjmp	80008c24 <_vfprintf_r+0xf34>
80008bf6:	41 09       	lddsp	r9,sp[0x40]
80008bf8:	59 f8       	cp.w	r8,31
80008bfa:	e0 89 00 11 	brgt	80008c1c <_vfprintf_r+0xf2c>
80008bfe:	f2 cb ff fc 	sub	r11,r9,-4
80008c02:	51 0b       	stdsp	sp[0x40],r11
80008c04:	fa c6 f9 44 	sub	r6,sp,-1724
80008c08:	72 0b       	ld.w	r11,r9[0x0]
80008c0a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c0e:	f3 4b fd 88 	st.w	r9[-632],r11
80008c12:	2f f8       	sub	r8,-1
80008c14:	14 97       	mov	r7,r10
80008c16:	fb 48 06 b4 	st.w	sp[1716],r8
80008c1a:	c0 58       	rjmp	80008c24 <_vfprintf_r+0xf34>
80008c1c:	72 0b       	ld.w	r11,r9[0x0]
80008c1e:	14 97       	mov	r7,r10
80008c20:	2f c9       	sub	r9,-4
80008c22:	51 09       	stdsp	sp[0x40],r9
80008c24:	50 1b       	stdsp	sp[0x4],r11
80008c26:	30 0e       	mov	lr,0
80008c28:	50 0e       	stdsp	sp[0x0],lr
80008c2a:	1c 98       	mov	r8,lr
80008c2c:	e0 8f 02 fe 	bral	80009228 <_vfprintf_r+0x1538>
80008c30:	50 a7       	stdsp	sp[0x28],r7
80008c32:	50 80       	stdsp	sp[0x20],r0
80008c34:	0c 97       	mov	r7,r6
80008c36:	04 94       	mov	r4,r2
80008c38:	06 96       	mov	r6,r3
80008c3a:	02 92       	mov	r2,r1
80008c3c:	40 93       	lddsp	r3,sp[0x24]
80008c3e:	40 41       	lddsp	r1,sp[0x10]
80008c40:	0e 99       	mov	r9,r7
80008c42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c46:	40 3c       	lddsp	r12,sp[0xc]
80008c48:	58 0c       	cp.w	r12,0
80008c4a:	c1 d0       	breq	80008c84 <_vfprintf_r+0xf94>
80008c4c:	10 36       	cp.w	r6,r8
80008c4e:	c0 64       	brge	80008c5a <_vfprintf_r+0xf6a>
80008c50:	fa cb f9 44 	sub	r11,sp,-1724
80008c54:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c58:	c1 d8       	rjmp	80008c92 <_vfprintf_r+0xfa2>
80008c5a:	fa c8 f9 50 	sub	r8,sp,-1712
80008c5e:	1a d8       	st.w	--sp,r8
80008c60:	fa c8 fa b8 	sub	r8,sp,-1352
80008c64:	1a d8       	st.w	--sp,r8
80008c66:	fa c8 fb b4 	sub	r8,sp,-1100
80008c6a:	1a d8       	st.w	--sp,r8
80008c6c:	fa c9 ff b4 	sub	r9,sp,-76
80008c70:	fa c8 f9 40 	sub	r8,sp,-1728
80008c74:	04 9a       	mov	r10,r2
80008c76:	0c 9b       	mov	r11,r6
80008c78:	08 9c       	mov	r12,r4
80008c7a:	fe b0 f6 a3 	rcall	800079c0 <get_arg>
80008c7e:	2f dd       	sub	sp,-12
80008c80:	78 09       	ld.w	r9,r12[0x0]
80008c82:	c2 18       	rjmp	80008cc4 <_vfprintf_r+0xfd4>
80008c84:	2f f7       	sub	r7,-1
80008c86:	10 39       	cp.w	r9,r8
80008c88:	c0 84       	brge	80008c98 <_vfprintf_r+0xfa8>
80008c8a:	fa ca f9 44 	sub	r10,sp,-1724
80008c8e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c92:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008c96:	c1 78       	rjmp	80008cc4 <_vfprintf_r+0xfd4>
80008c98:	41 09       	lddsp	r9,sp[0x40]
80008c9a:	59 f8       	cp.w	r8,31
80008c9c:	e0 89 00 10 	brgt	80008cbc <_vfprintf_r+0xfcc>
80008ca0:	f2 ca ff fc 	sub	r10,r9,-4
80008ca4:	51 0a       	stdsp	sp[0x40],r10
80008ca6:	fa c6 f9 44 	sub	r6,sp,-1724
80008caa:	72 09       	ld.w	r9,r9[0x0]
80008cac:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008cb0:	f5 49 fd 88 	st.w	r10[-632],r9
80008cb4:	2f f8       	sub	r8,-1
80008cb6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cba:	c0 58       	rjmp	80008cc4 <_vfprintf_r+0xfd4>
80008cbc:	f2 c8 ff fc 	sub	r8,r9,-4
80008cc0:	51 08       	stdsp	sp[0x40],r8
80008cc2:	72 09       	ld.w	r9,r9[0x0]
80008cc4:	33 08       	mov	r8,48
80008cc6:	fb 68 06 b8 	st.b	sp[1720],r8
80008cca:	37 88       	mov	r8,120
80008ccc:	30 0e       	mov	lr,0
80008cce:	fb 68 06 b9 	st.b	sp[1721],r8
80008cd2:	fe cc b2 66 	sub	r12,pc,-19866
80008cd6:	50 19       	stdsp	sp[0x4],r9
80008cd8:	a1 b5       	sbr	r5,0x1
80008cda:	50 0e       	stdsp	sp[0x0],lr
80008cdc:	50 dc       	stdsp	sp[0x34],r12
80008cde:	30 28       	mov	r8,2
80008ce0:	37 80       	mov	r0,120
80008ce2:	e0 8f 02 a3 	bral	80009228 <_vfprintf_r+0x1538>
80008ce6:	50 a7       	stdsp	sp[0x28],r7
80008ce8:	50 80       	stdsp	sp[0x20],r0
80008cea:	10 90       	mov	r0,r8
80008cec:	30 08       	mov	r8,0
80008cee:	fb 68 06 bb 	st.b	sp[1723],r8
80008cf2:	0c 97       	mov	r7,r6
80008cf4:	04 94       	mov	r4,r2
80008cf6:	06 96       	mov	r6,r3
80008cf8:	02 92       	mov	r2,r1
80008cfa:	40 93       	lddsp	r3,sp[0x24]
80008cfc:	40 41       	lddsp	r1,sp[0x10]
80008cfe:	0e 99       	mov	r9,r7
80008d00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d04:	40 3b       	lddsp	r11,sp[0xc]
80008d06:	58 0b       	cp.w	r11,0
80008d08:	c1 d0       	breq	80008d42 <_vfprintf_r+0x1052>
80008d0a:	10 36       	cp.w	r6,r8
80008d0c:	c0 64       	brge	80008d18 <_vfprintf_r+0x1028>
80008d0e:	fa ca f9 44 	sub	r10,sp,-1724
80008d12:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d16:	c1 d8       	rjmp	80008d50 <_vfprintf_r+0x1060>
80008d18:	fa c8 f9 50 	sub	r8,sp,-1712
80008d1c:	1a d8       	st.w	--sp,r8
80008d1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d22:	1a d8       	st.w	--sp,r8
80008d24:	fa c8 fb b4 	sub	r8,sp,-1100
80008d28:	0c 9b       	mov	r11,r6
80008d2a:	1a d8       	st.w	--sp,r8
80008d2c:	04 9a       	mov	r10,r2
80008d2e:	fa c8 f9 40 	sub	r8,sp,-1728
80008d32:	fa c9 ff b4 	sub	r9,sp,-76
80008d36:	08 9c       	mov	r12,r4
80008d38:	fe b0 f6 44 	rcall	800079c0 <get_arg>
80008d3c:	2f dd       	sub	sp,-12
80008d3e:	78 06       	ld.w	r6,r12[0x0]
80008d40:	c2 08       	rjmp	80008d80 <_vfprintf_r+0x1090>
80008d42:	2f f7       	sub	r7,-1
80008d44:	10 39       	cp.w	r9,r8
80008d46:	c0 84       	brge	80008d56 <_vfprintf_r+0x1066>
80008d48:	fa c9 f9 44 	sub	r9,sp,-1724
80008d4c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d50:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008d54:	c1 68       	rjmp	80008d80 <_vfprintf_r+0x1090>
80008d56:	41 09       	lddsp	r9,sp[0x40]
80008d58:	59 f8       	cp.w	r8,31
80008d5a:	e0 89 00 10 	brgt	80008d7a <_vfprintf_r+0x108a>
80008d5e:	f2 ca ff fc 	sub	r10,r9,-4
80008d62:	51 0a       	stdsp	sp[0x40],r10
80008d64:	72 06       	ld.w	r6,r9[0x0]
80008d66:	fa ce f9 44 	sub	lr,sp,-1724
80008d6a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008d6e:	f3 46 fd 88 	st.w	r9[-632],r6
80008d72:	2f f8       	sub	r8,-1
80008d74:	fb 48 06 b4 	st.w	sp[1716],r8
80008d78:	c0 48       	rjmp	80008d80 <_vfprintf_r+0x1090>
80008d7a:	72 06       	ld.w	r6,r9[0x0]
80008d7c:	2f c9       	sub	r9,-4
80008d7e:	51 09       	stdsp	sp[0x40],r9
80008d80:	40 2c       	lddsp	r12,sp[0x8]
80008d82:	58 0c       	cp.w	r12,0
80008d84:	c1 05       	brlt	80008da4 <_vfprintf_r+0x10b4>
80008d86:	18 9a       	mov	r10,r12
80008d88:	30 0b       	mov	r11,0
80008d8a:	0c 9c       	mov	r12,r6
80008d8c:	e0 a0 12 38 	rcall	8000b1fc <memchr>
80008d90:	e0 80 02 df 	breq	8000934e <_vfprintf_r+0x165e>
80008d94:	f8 06 01 02 	sub	r2,r12,r6
80008d98:	40 2b       	lddsp	r11,sp[0x8]
80008d9a:	16 32       	cp.w	r2,r11
80008d9c:	e0 89 02 d9 	brgt	8000934e <_vfprintf_r+0x165e>
80008da0:	e0 8f 02 d4 	bral	80009348 <_vfprintf_r+0x1658>
80008da4:	30 0a       	mov	r10,0
80008da6:	0c 9c       	mov	r12,r6
80008da8:	50 2a       	stdsp	sp[0x8],r10
80008daa:	e0 a0 15 99 	rcall	8000b8dc <strlen>
80008dae:	18 92       	mov	r2,r12
80008db0:	e0 8f 02 d2 	bral	80009354 <_vfprintf_r+0x1664>
80008db4:	50 a7       	stdsp	sp[0x28],r7
80008db6:	50 80       	stdsp	sp[0x20],r0
80008db8:	0c 97       	mov	r7,r6
80008dba:	04 94       	mov	r4,r2
80008dbc:	06 96       	mov	r6,r3
80008dbe:	02 92       	mov	r2,r1
80008dc0:	40 93       	lddsp	r3,sp[0x24]
80008dc2:	10 90       	mov	r0,r8
80008dc4:	40 41       	lddsp	r1,sp[0x10]
80008dc6:	a5 a5       	sbr	r5,0x4
80008dc8:	c0 a8       	rjmp	80008ddc <_vfprintf_r+0x10ec>
80008dca:	50 a7       	stdsp	sp[0x28],r7
80008dcc:	50 80       	stdsp	sp[0x20],r0
80008dce:	0c 97       	mov	r7,r6
80008dd0:	04 94       	mov	r4,r2
80008dd2:	06 96       	mov	r6,r3
80008dd4:	02 92       	mov	r2,r1
80008dd6:	40 93       	lddsp	r3,sp[0x24]
80008dd8:	10 90       	mov	r0,r8
80008dda:	40 41       	lddsp	r1,sp[0x10]
80008ddc:	ed b5 00 05 	bld	r5,0x5
80008de0:	c5 61       	brne	80008e8c <_vfprintf_r+0x119c>
80008de2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008de6:	40 39       	lddsp	r9,sp[0xc]
80008de8:	58 09       	cp.w	r9,0
80008dea:	c2 10       	breq	80008e2c <_vfprintf_r+0x113c>
80008dec:	10 36       	cp.w	r6,r8
80008dee:	c0 74       	brge	80008dfc <_vfprintf_r+0x110c>
80008df0:	fa c8 f9 44 	sub	r8,sp,-1724
80008df4:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008df8:	c2 38       	rjmp	80008e3e <_vfprintf_r+0x114e>
80008dfa:	d7 03       	nop
80008dfc:	fa c8 f9 50 	sub	r8,sp,-1712
80008e00:	1a d8       	st.w	--sp,r8
80008e02:	fa c8 fa b8 	sub	r8,sp,-1352
80008e06:	1a d8       	st.w	--sp,r8
80008e08:	fa c8 fb b4 	sub	r8,sp,-1100
80008e0c:	1a d8       	st.w	--sp,r8
80008e0e:	fa c8 f9 40 	sub	r8,sp,-1728
80008e12:	fa c9 ff b4 	sub	r9,sp,-76
80008e16:	04 9a       	mov	r10,r2
80008e18:	0c 9b       	mov	r11,r6
80008e1a:	08 9c       	mov	r12,r4
80008e1c:	fe b0 f5 d2 	rcall	800079c0 <get_arg>
80008e20:	2f dd       	sub	sp,-12
80008e22:	f8 e8 00 00 	ld.d	r8,r12[0]
80008e26:	fa e9 00 00 	st.d	sp[0],r8
80008e2a:	c2 e8       	rjmp	80008e86 <_vfprintf_r+0x1196>
80008e2c:	ee ca ff ff 	sub	r10,r7,-1
80008e30:	10 37       	cp.w	r7,r8
80008e32:	c0 b4       	brge	80008e48 <_vfprintf_r+0x1158>
80008e34:	fa c8 f9 44 	sub	r8,sp,-1724
80008e38:	14 97       	mov	r7,r10
80008e3a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008e3e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e42:	fa eb 00 00 	st.d	sp[0],r10
80008e46:	c2 08       	rjmp	80008e86 <_vfprintf_r+0x1196>
80008e48:	41 09       	lddsp	r9,sp[0x40]
80008e4a:	59 f8       	cp.w	r8,31
80008e4c:	e0 89 00 16 	brgt	80008e78 <_vfprintf_r+0x1188>
80008e50:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e54:	f2 cb ff f8 	sub	r11,r9,-8
80008e58:	fa e7 00 00 	st.d	sp[0],r6
80008e5c:	51 0b       	stdsp	sp[0x40],r11
80008e5e:	fa c6 f9 44 	sub	r6,sp,-1724
80008e62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e66:	fa e6 00 00 	ld.d	r6,sp[0]
80008e6a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e6e:	2f f8       	sub	r8,-1
80008e70:	14 97       	mov	r7,r10
80008e72:	fb 48 06 b4 	st.w	sp[1716],r8
80008e76:	c0 88       	rjmp	80008e86 <_vfprintf_r+0x1196>
80008e78:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e7c:	2f 89       	sub	r9,-8
80008e7e:	fa e7 00 00 	st.d	sp[0],r6
80008e82:	51 09       	stdsp	sp[0x40],r9
80008e84:	14 97       	mov	r7,r10
80008e86:	30 18       	mov	r8,1
80008e88:	e0 8f 01 d0 	bral	80009228 <_vfprintf_r+0x1538>
80008e8c:	ed b5 00 04 	bld	r5,0x4
80008e90:	c1 61       	brne	80008ebc <_vfprintf_r+0x11cc>
80008e92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e96:	40 3e       	lddsp	lr,sp[0xc]
80008e98:	58 0e       	cp.w	lr,0
80008e9a:	c0 80       	breq	80008eaa <_vfprintf_r+0x11ba>
80008e9c:	10 36       	cp.w	r6,r8
80008e9e:	c6 74       	brge	80008f6c <_vfprintf_r+0x127c>
80008ea0:	fa cc f9 44 	sub	r12,sp,-1724
80008ea4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ea8:	c8 08       	rjmp	80008fa8 <_vfprintf_r+0x12b8>
80008eaa:	ee ca ff ff 	sub	r10,r7,-1
80008eae:	10 37       	cp.w	r7,r8
80008eb0:	c7 f4       	brge	80008fae <_vfprintf_r+0x12be>
80008eb2:	fa cb f9 44 	sub	r11,sp,-1724
80008eb6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eba:	c7 68       	rjmp	80008fa6 <_vfprintf_r+0x12b6>
80008ebc:	ed b5 00 06 	bld	r5,0x6
80008ec0:	c4 a1       	brne	80008f54 <_vfprintf_r+0x1264>
80008ec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ec6:	40 3c       	lddsp	r12,sp[0xc]
80008ec8:	58 0c       	cp.w	r12,0
80008eca:	c1 d0       	breq	80008f04 <_vfprintf_r+0x1214>
80008ecc:	10 36       	cp.w	r6,r8
80008ece:	c0 64       	brge	80008eda <_vfprintf_r+0x11ea>
80008ed0:	fa cb f9 44 	sub	r11,sp,-1724
80008ed4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ed8:	c1 f8       	rjmp	80008f16 <_vfprintf_r+0x1226>
80008eda:	fa c8 f9 50 	sub	r8,sp,-1712
80008ede:	1a d8       	st.w	--sp,r8
80008ee0:	fa c8 fa b8 	sub	r8,sp,-1352
80008ee4:	1a d8       	st.w	--sp,r8
80008ee6:	fa c8 fb b4 	sub	r8,sp,-1100
80008eea:	1a d8       	st.w	--sp,r8
80008eec:	fa c8 f9 40 	sub	r8,sp,-1728
80008ef0:	fa c9 ff b4 	sub	r9,sp,-76
80008ef4:	04 9a       	mov	r10,r2
80008ef6:	0c 9b       	mov	r11,r6
80008ef8:	08 9c       	mov	r12,r4
80008efa:	fe b0 f5 63 	rcall	800079c0 <get_arg>
80008efe:	2f dd       	sub	sp,-12
80008f00:	98 18       	ld.sh	r8,r12[0x2]
80008f02:	c2 68       	rjmp	80008f4e <_vfprintf_r+0x125e>
80008f04:	ee ca ff ff 	sub	r10,r7,-1
80008f08:	10 37       	cp.w	r7,r8
80008f0a:	c0 94       	brge	80008f1c <_vfprintf_r+0x122c>
80008f0c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f10:	14 97       	mov	r7,r10
80008f12:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f16:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f1a:	c1 a8       	rjmp	80008f4e <_vfprintf_r+0x125e>
80008f1c:	41 09       	lddsp	r9,sp[0x40]
80008f1e:	59 f8       	cp.w	r8,31
80008f20:	e0 89 00 13 	brgt	80008f46 <_vfprintf_r+0x1256>
80008f24:	f2 cb ff fc 	sub	r11,r9,-4
80008f28:	51 0b       	stdsp	sp[0x40],r11
80008f2a:	72 09       	ld.w	r9,r9[0x0]
80008f2c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f30:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f34:	2f f8       	sub	r8,-1
80008f36:	f7 49 fd 88 	st.w	r11[-632],r9
80008f3a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f3e:	14 97       	mov	r7,r10
80008f40:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f44:	c0 58       	rjmp	80008f4e <_vfprintf_r+0x125e>
80008f46:	92 18       	ld.sh	r8,r9[0x2]
80008f48:	14 97       	mov	r7,r10
80008f4a:	2f c9       	sub	r9,-4
80008f4c:	51 09       	stdsp	sp[0x40],r9
80008f4e:	5c 78       	castu.h	r8
80008f50:	50 18       	stdsp	sp[0x4],r8
80008f52:	c4 68       	rjmp	80008fde <_vfprintf_r+0x12ee>
80008f54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f58:	40 3c       	lddsp	r12,sp[0xc]
80008f5a:	58 0c       	cp.w	r12,0
80008f5c:	c1 d0       	breq	80008f96 <_vfprintf_r+0x12a6>
80008f5e:	10 36       	cp.w	r6,r8
80008f60:	c0 64       	brge	80008f6c <_vfprintf_r+0x127c>
80008f62:	fa cb f9 44 	sub	r11,sp,-1724
80008f66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f6a:	c1 f8       	rjmp	80008fa8 <_vfprintf_r+0x12b8>
80008f6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008f70:	1a d8       	st.w	--sp,r8
80008f72:	fa c8 fa b8 	sub	r8,sp,-1352
80008f76:	0c 9b       	mov	r11,r6
80008f78:	1a d8       	st.w	--sp,r8
80008f7a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f7e:	04 9a       	mov	r10,r2
80008f80:	1a d8       	st.w	--sp,r8
80008f82:	08 9c       	mov	r12,r4
80008f84:	fa c8 f9 40 	sub	r8,sp,-1728
80008f88:	fa c9 ff b4 	sub	r9,sp,-76
80008f8c:	fe b0 f5 1a 	rcall	800079c0 <get_arg>
80008f90:	2f dd       	sub	sp,-12
80008f92:	78 0b       	ld.w	r11,r12[0x0]
80008f94:	c2 48       	rjmp	80008fdc <_vfprintf_r+0x12ec>
80008f96:	ee ca ff ff 	sub	r10,r7,-1
80008f9a:	10 37       	cp.w	r7,r8
80008f9c:	c0 94       	brge	80008fae <_vfprintf_r+0x12be>
80008f9e:	fa c9 f9 44 	sub	r9,sp,-1724
80008fa2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fa6:	14 97       	mov	r7,r10
80008fa8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fac:	c1 88       	rjmp	80008fdc <_vfprintf_r+0x12ec>
80008fae:	41 09       	lddsp	r9,sp[0x40]
80008fb0:	59 f8       	cp.w	r8,31
80008fb2:	e0 89 00 11 	brgt	80008fd4 <_vfprintf_r+0x12e4>
80008fb6:	f2 cb ff fc 	sub	r11,r9,-4
80008fba:	51 0b       	stdsp	sp[0x40],r11
80008fbc:	fa c6 f9 44 	sub	r6,sp,-1724
80008fc0:	72 0b       	ld.w	r11,r9[0x0]
80008fc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fc6:	f3 4b fd 88 	st.w	r9[-632],r11
80008fca:	2f f8       	sub	r8,-1
80008fcc:	14 97       	mov	r7,r10
80008fce:	fb 48 06 b4 	st.w	sp[1716],r8
80008fd2:	c0 58       	rjmp	80008fdc <_vfprintf_r+0x12ec>
80008fd4:	72 0b       	ld.w	r11,r9[0x0]
80008fd6:	14 97       	mov	r7,r10
80008fd8:	2f c9       	sub	r9,-4
80008fda:	51 09       	stdsp	sp[0x40],r9
80008fdc:	50 1b       	stdsp	sp[0x4],r11
80008fde:	30 0e       	mov	lr,0
80008fe0:	30 18       	mov	r8,1
80008fe2:	50 0e       	stdsp	sp[0x0],lr
80008fe4:	c2 29       	rjmp	80009228 <_vfprintf_r+0x1538>
80008fe6:	50 a7       	stdsp	sp[0x28],r7
80008fe8:	50 80       	stdsp	sp[0x20],r0
80008fea:	0c 97       	mov	r7,r6
80008fec:	04 94       	mov	r4,r2
80008fee:	06 96       	mov	r6,r3
80008ff0:	02 92       	mov	r2,r1
80008ff2:	fe cc b5 86 	sub	r12,pc,-19066
80008ff6:	40 93       	lddsp	r3,sp[0x24]
80008ff8:	10 90       	mov	r0,r8
80008ffa:	40 41       	lddsp	r1,sp[0x10]
80008ffc:	50 dc       	stdsp	sp[0x34],r12
80008ffe:	ed b5 00 05 	bld	r5,0x5
80009002:	c5 51       	brne	800090ac <_vfprintf_r+0x13bc>
80009004:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009008:	40 3b       	lddsp	r11,sp[0xc]
8000900a:	58 0b       	cp.w	r11,0
8000900c:	c2 20       	breq	80009050 <_vfprintf_r+0x1360>
8000900e:	10 36       	cp.w	r6,r8
80009010:	c0 a4       	brge	80009024 <_vfprintf_r+0x1334>
80009012:	fa ca f9 44 	sub	r10,sp,-1724
80009016:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000901a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000901e:	fa e9 00 00 	st.d	sp[0],r8
80009022:	cf 28       	rjmp	80009206 <_vfprintf_r+0x1516>
80009024:	fa c8 f9 50 	sub	r8,sp,-1712
80009028:	1a d8       	st.w	--sp,r8
8000902a:	fa c8 fa b8 	sub	r8,sp,-1352
8000902e:	04 9a       	mov	r10,r2
80009030:	1a d8       	st.w	--sp,r8
80009032:	0c 9b       	mov	r11,r6
80009034:	fa c8 fb b4 	sub	r8,sp,-1100
80009038:	08 9c       	mov	r12,r4
8000903a:	1a d8       	st.w	--sp,r8
8000903c:	fa c8 f9 40 	sub	r8,sp,-1728
80009040:	fa c9 ff b4 	sub	r9,sp,-76
80009044:	fe b0 f4 be 	rcall	800079c0 <get_arg>
80009048:	2f dd       	sub	sp,-12
8000904a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000904e:	c0 c8       	rjmp	80009066 <_vfprintf_r+0x1376>
80009050:	ee ca ff ff 	sub	r10,r7,-1
80009054:	10 37       	cp.w	r7,r8
80009056:	c0 b4       	brge	8000906c <_vfprintf_r+0x137c>
80009058:	fa c9 f9 44 	sub	r9,sp,-1724
8000905c:	14 97       	mov	r7,r10
8000905e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009062:	ec ea fd 88 	ld.d	r10,r6[-632]
80009066:	fa eb 00 00 	st.d	sp[0],r10
8000906a:	cc e8       	rjmp	80009206 <_vfprintf_r+0x1516>
8000906c:	41 09       	lddsp	r9,sp[0x40]
8000906e:	59 f8       	cp.w	r8,31
80009070:	e0 89 00 16 	brgt	8000909c <_vfprintf_r+0x13ac>
80009074:	f2 e6 00 00 	ld.d	r6,r9[0]
80009078:	f2 cb ff f8 	sub	r11,r9,-8
8000907c:	fa e7 00 00 	st.d	sp[0],r6
80009080:	51 0b       	stdsp	sp[0x40],r11
80009082:	fa c6 f9 44 	sub	r6,sp,-1724
80009086:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000908a:	fa e6 00 00 	ld.d	r6,sp[0]
8000908e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009092:	2f f8       	sub	r8,-1
80009094:	14 97       	mov	r7,r10
80009096:	fb 48 06 b4 	st.w	sp[1716],r8
8000909a:	cb 68       	rjmp	80009206 <_vfprintf_r+0x1516>
8000909c:	f2 e6 00 00 	ld.d	r6,r9[0]
800090a0:	2f 89       	sub	r9,-8
800090a2:	fa e7 00 00 	st.d	sp[0],r6
800090a6:	51 09       	stdsp	sp[0x40],r9
800090a8:	14 97       	mov	r7,r10
800090aa:	ca e8       	rjmp	80009206 <_vfprintf_r+0x1516>
800090ac:	ed b5 00 04 	bld	r5,0x4
800090b0:	c1 71       	brne	800090de <_vfprintf_r+0x13ee>
800090b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090b6:	40 3e       	lddsp	lr,sp[0xc]
800090b8:	58 0e       	cp.w	lr,0
800090ba:	c0 80       	breq	800090ca <_vfprintf_r+0x13da>
800090bc:	10 36       	cp.w	r6,r8
800090be:	c6 94       	brge	80009190 <_vfprintf_r+0x14a0>
800090c0:	fa cc f9 44 	sub	r12,sp,-1724
800090c4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090c8:	c8 28       	rjmp	800091cc <_vfprintf_r+0x14dc>
800090ca:	ee ca ff ff 	sub	r10,r7,-1
800090ce:	10 37       	cp.w	r7,r8
800090d0:	e0 84 00 81 	brge	800091d2 <_vfprintf_r+0x14e2>
800090d4:	fa cb f9 44 	sub	r11,sp,-1724
800090d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090dc:	c7 78       	rjmp	800091ca <_vfprintf_r+0x14da>
800090de:	ed b5 00 06 	bld	r5,0x6
800090e2:	c4 b1       	brne	80009178 <_vfprintf_r+0x1488>
800090e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e8:	40 3c       	lddsp	r12,sp[0xc]
800090ea:	58 0c       	cp.w	r12,0
800090ec:	c1 d0       	breq	80009126 <_vfprintf_r+0x1436>
800090ee:	10 36       	cp.w	r6,r8
800090f0:	c0 64       	brge	800090fc <_vfprintf_r+0x140c>
800090f2:	fa cb f9 44 	sub	r11,sp,-1724
800090f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090fa:	c1 f8       	rjmp	80009138 <_vfprintf_r+0x1448>
800090fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009100:	1a d8       	st.w	--sp,r8
80009102:	fa c8 fa b8 	sub	r8,sp,-1352
80009106:	1a d8       	st.w	--sp,r8
80009108:	fa c8 fb b4 	sub	r8,sp,-1100
8000910c:	1a d8       	st.w	--sp,r8
8000910e:	fa c8 f9 40 	sub	r8,sp,-1728
80009112:	fa c9 ff b4 	sub	r9,sp,-76
80009116:	04 9a       	mov	r10,r2
80009118:	0c 9b       	mov	r11,r6
8000911a:	08 9c       	mov	r12,r4
8000911c:	fe b0 f4 52 	rcall	800079c0 <get_arg>
80009120:	2f dd       	sub	sp,-12
80009122:	98 18       	ld.sh	r8,r12[0x2]
80009124:	c2 78       	rjmp	80009172 <_vfprintf_r+0x1482>
80009126:	ee ca ff ff 	sub	r10,r7,-1
8000912a:	10 37       	cp.w	r7,r8
8000912c:	c0 a4       	brge	80009140 <_vfprintf_r+0x1450>
8000912e:	fa c9 f9 44 	sub	r9,sp,-1724
80009132:	14 97       	mov	r7,r10
80009134:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009138:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000913c:	c1 b8       	rjmp	80009172 <_vfprintf_r+0x1482>
8000913e:	d7 03       	nop
80009140:	41 09       	lddsp	r9,sp[0x40]
80009142:	59 f8       	cp.w	r8,31
80009144:	e0 89 00 13 	brgt	8000916a <_vfprintf_r+0x147a>
80009148:	f2 cb ff fc 	sub	r11,r9,-4
8000914c:	51 0b       	stdsp	sp[0x40],r11
8000914e:	72 09       	ld.w	r9,r9[0x0]
80009150:	fa c6 f9 44 	sub	r6,sp,-1724
80009154:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009158:	2f f8       	sub	r8,-1
8000915a:	f7 49 fd 88 	st.w	r11[-632],r9
8000915e:	fb 48 06 b4 	st.w	sp[1716],r8
80009162:	14 97       	mov	r7,r10
80009164:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009168:	c0 58       	rjmp	80009172 <_vfprintf_r+0x1482>
8000916a:	92 18       	ld.sh	r8,r9[0x2]
8000916c:	14 97       	mov	r7,r10
8000916e:	2f c9       	sub	r9,-4
80009170:	51 09       	stdsp	sp[0x40],r9
80009172:	5c 78       	castu.h	r8
80009174:	50 18       	stdsp	sp[0x4],r8
80009176:	c4 68       	rjmp	80009202 <_vfprintf_r+0x1512>
80009178:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000917c:	40 3c       	lddsp	r12,sp[0xc]
8000917e:	58 0c       	cp.w	r12,0
80009180:	c1 d0       	breq	800091ba <_vfprintf_r+0x14ca>
80009182:	10 36       	cp.w	r6,r8
80009184:	c0 64       	brge	80009190 <_vfprintf_r+0x14a0>
80009186:	fa cb f9 44 	sub	r11,sp,-1724
8000918a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000918e:	c1 f8       	rjmp	800091cc <_vfprintf_r+0x14dc>
80009190:	fa c8 f9 50 	sub	r8,sp,-1712
80009194:	1a d8       	st.w	--sp,r8
80009196:	fa c8 fa b8 	sub	r8,sp,-1352
8000919a:	0c 9b       	mov	r11,r6
8000919c:	1a d8       	st.w	--sp,r8
8000919e:	fa c8 fb b4 	sub	r8,sp,-1100
800091a2:	04 9a       	mov	r10,r2
800091a4:	1a d8       	st.w	--sp,r8
800091a6:	08 9c       	mov	r12,r4
800091a8:	fa c8 f9 40 	sub	r8,sp,-1728
800091ac:	fa c9 ff b4 	sub	r9,sp,-76
800091b0:	fe b0 f4 08 	rcall	800079c0 <get_arg>
800091b4:	2f dd       	sub	sp,-12
800091b6:	78 0b       	ld.w	r11,r12[0x0]
800091b8:	c2 48       	rjmp	80009200 <_vfprintf_r+0x1510>
800091ba:	ee ca ff ff 	sub	r10,r7,-1
800091be:	10 37       	cp.w	r7,r8
800091c0:	c0 94       	brge	800091d2 <_vfprintf_r+0x14e2>
800091c2:	fa c9 f9 44 	sub	r9,sp,-1724
800091c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091ca:	14 97       	mov	r7,r10
800091cc:	ec fb fd 88 	ld.w	r11,r6[-632]
800091d0:	c1 88       	rjmp	80009200 <_vfprintf_r+0x1510>
800091d2:	41 09       	lddsp	r9,sp[0x40]
800091d4:	59 f8       	cp.w	r8,31
800091d6:	e0 89 00 11 	brgt	800091f8 <_vfprintf_r+0x1508>
800091da:	f2 cb ff fc 	sub	r11,r9,-4
800091de:	51 0b       	stdsp	sp[0x40],r11
800091e0:	fa c6 f9 44 	sub	r6,sp,-1724
800091e4:	72 0b       	ld.w	r11,r9[0x0]
800091e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091ea:	f3 4b fd 88 	st.w	r9[-632],r11
800091ee:	2f f8       	sub	r8,-1
800091f0:	14 97       	mov	r7,r10
800091f2:	fb 48 06 b4 	st.w	sp[1716],r8
800091f6:	c0 58       	rjmp	80009200 <_vfprintf_r+0x1510>
800091f8:	72 0b       	ld.w	r11,r9[0x0]
800091fa:	14 97       	mov	r7,r10
800091fc:	2f c9       	sub	r9,-4
800091fe:	51 09       	stdsp	sp[0x40],r9
80009200:	50 1b       	stdsp	sp[0x4],r11
80009202:	30 0e       	mov	lr,0
80009204:	50 0e       	stdsp	sp[0x0],lr
80009206:	40 08       	lddsp	r8,sp[0x0]
80009208:	40 1c       	lddsp	r12,sp[0x4]
8000920a:	18 48       	or	r8,r12
8000920c:	5f 19       	srne	r9
8000920e:	0a 98       	mov	r8,r5
80009210:	eb e9 00 09 	and	r9,r5,r9
80009214:	a1 b8       	sbr	r8,0x1
80009216:	58 09       	cp.w	r9,0
80009218:	c0 70       	breq	80009226 <_vfprintf_r+0x1536>
8000921a:	10 95       	mov	r5,r8
8000921c:	fb 60 06 b9 	st.b	sp[1721],r0
80009220:	33 08       	mov	r8,48
80009222:	fb 68 06 b8 	st.b	sp[1720],r8
80009226:	30 28       	mov	r8,2
80009228:	30 09       	mov	r9,0
8000922a:	fb 69 06 bb 	st.b	sp[1723],r9
8000922e:	0a 99       	mov	r9,r5
80009230:	a7 d9       	cbr	r9,0x7
80009232:	40 2b       	lddsp	r11,sp[0x8]
80009234:	40 16       	lddsp	r6,sp[0x4]
80009236:	58 0b       	cp.w	r11,0
80009238:	5f 1a       	srne	r10
8000923a:	f2 05 17 40 	movge	r5,r9
8000923e:	fa c2 f9 78 	sub	r2,sp,-1672
80009242:	40 09       	lddsp	r9,sp[0x0]
80009244:	0c 49       	or	r9,r6
80009246:	5f 19       	srne	r9
80009248:	f5 e9 10 09 	or	r9,r10,r9
8000924c:	c5 c0       	breq	80009304 <_vfprintf_r+0x1614>
8000924e:	30 19       	mov	r9,1
80009250:	f2 08 18 00 	cp.b	r8,r9
80009254:	c0 60       	breq	80009260 <_vfprintf_r+0x1570>
80009256:	30 29       	mov	r9,2
80009258:	f2 08 18 00 	cp.b	r8,r9
8000925c:	c0 41       	brne	80009264 <_vfprintf_r+0x1574>
8000925e:	c3 c8       	rjmp	800092d6 <_vfprintf_r+0x15e6>
80009260:	04 96       	mov	r6,r2
80009262:	c3 08       	rjmp	800092c2 <_vfprintf_r+0x15d2>
80009264:	04 96       	mov	r6,r2
80009266:	fa e8 00 00 	ld.d	r8,sp[0]
8000926a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000926e:	2d 0a       	sub	r10,-48
80009270:	0c fa       	st.b	--r6,r10
80009272:	f0 0b 16 03 	lsr	r11,r8,0x3
80009276:	f2 0c 16 03 	lsr	r12,r9,0x3
8000927a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000927e:	18 99       	mov	r9,r12
80009280:	16 98       	mov	r8,r11
80009282:	58 08       	cp.w	r8,0
80009284:	5c 29       	cpc	r9
80009286:	cf 21       	brne	8000926a <_vfprintf_r+0x157a>
80009288:	fa e9 00 00 	st.d	sp[0],r8
8000928c:	ed b5 00 00 	bld	r5,0x0
80009290:	c4 51       	brne	8000931a <_vfprintf_r+0x162a>
80009292:	33 09       	mov	r9,48
80009294:	f2 0a 18 00 	cp.b	r10,r9
80009298:	c4 10       	breq	8000931a <_vfprintf_r+0x162a>
8000929a:	0c f9       	st.b	--r6,r9
8000929c:	c3 f8       	rjmp	8000931a <_vfprintf_r+0x162a>
8000929e:	fa ea 00 00 	ld.d	r10,sp[0]
800092a2:	30 a8       	mov	r8,10
800092a4:	30 09       	mov	r9,0
800092a6:	e0 a0 1a 19 	rcall	8000c6d8 <__avr32_umod64>
800092aa:	30 a8       	mov	r8,10
800092ac:	2d 0a       	sub	r10,-48
800092ae:	30 09       	mov	r9,0
800092b0:	ac 8a       	st.b	r6[0x0],r10
800092b2:	fa ea 00 00 	ld.d	r10,sp[0]
800092b6:	e0 a0 18 df 	rcall	8000c474 <__avr32_udiv64>
800092ba:	16 99       	mov	r9,r11
800092bc:	14 98       	mov	r8,r10
800092be:	fa e9 00 00 	st.d	sp[0],r8
800092c2:	20 16       	sub	r6,1
800092c4:	fa ea 00 00 	ld.d	r10,sp[0]
800092c8:	58 9a       	cp.w	r10,9
800092ca:	5c 2b       	cpc	r11
800092cc:	fe 9b ff e9 	brhi	8000929e <_vfprintf_r+0x15ae>
800092d0:	1b f8       	ld.ub	r8,sp[0x7]
800092d2:	2d 08       	sub	r8,-48
800092d4:	c2 08       	rjmp	80009314 <_vfprintf_r+0x1624>
800092d6:	04 96       	mov	r6,r2
800092d8:	fa e8 00 00 	ld.d	r8,sp[0]
800092dc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800092e0:	40 de       	lddsp	lr,sp[0x34]
800092e2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800092e6:	0c fa       	st.b	--r6,r10
800092e8:	f2 0b 16 04 	lsr	r11,r9,0x4
800092ec:	f0 0a 16 04 	lsr	r10,r8,0x4
800092f0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800092f4:	16 99       	mov	r9,r11
800092f6:	14 98       	mov	r8,r10
800092f8:	58 08       	cp.w	r8,0
800092fa:	5c 29       	cpc	r9
800092fc:	cf 01       	brne	800092dc <_vfprintf_r+0x15ec>
800092fe:	fa e9 00 00 	st.d	sp[0],r8
80009302:	c0 c8       	rjmp	8000931a <_vfprintf_r+0x162a>
80009304:	58 08       	cp.w	r8,0
80009306:	c0 91       	brne	80009318 <_vfprintf_r+0x1628>
80009308:	ed b5 00 00 	bld	r5,0x0
8000930c:	c0 61       	brne	80009318 <_vfprintf_r+0x1628>
8000930e:	fa c6 f9 79 	sub	r6,sp,-1671
80009312:	33 08       	mov	r8,48
80009314:	ac 88       	st.b	r6[0x0],r8
80009316:	c0 28       	rjmp	8000931a <_vfprintf_r+0x162a>
80009318:	04 96       	mov	r6,r2
8000931a:	0c 12       	sub	r2,r6
8000931c:	c1 c8       	rjmp	80009354 <_vfprintf_r+0x1664>
8000931e:	50 a7       	stdsp	sp[0x28],r7
80009320:	50 80       	stdsp	sp[0x20],r0
80009322:	40 93       	lddsp	r3,sp[0x24]
80009324:	0c 97       	mov	r7,r6
80009326:	10 90       	mov	r0,r8
80009328:	04 94       	mov	r4,r2
8000932a:	40 41       	lddsp	r1,sp[0x10]
8000932c:	58 08       	cp.w	r8,0
8000932e:	e0 80 04 4f 	breq	80009bcc <_vfprintf_r+0x1edc>
80009332:	fb 68 06 60 	st.b	sp[1632],r8
80009336:	30 0c       	mov	r12,0
80009338:	30 08       	mov	r8,0
8000933a:	30 12       	mov	r2,1
8000933c:	fb 68 06 bb 	st.b	sp[1723],r8
80009340:	50 2c       	stdsp	sp[0x8],r12
80009342:	fa c6 f9 a0 	sub	r6,sp,-1632
80009346:	c0 78       	rjmp	80009354 <_vfprintf_r+0x1664>
80009348:	30 0b       	mov	r11,0
8000934a:	50 2b       	stdsp	sp[0x8],r11
8000934c:	c0 48       	rjmp	80009354 <_vfprintf_r+0x1664>
8000934e:	40 22       	lddsp	r2,sp[0x8]
80009350:	30 0a       	mov	r10,0
80009352:	50 2a       	stdsp	sp[0x8],r10
80009354:	40 29       	lddsp	r9,sp[0x8]
80009356:	e4 09 0c 49 	max	r9,r2,r9
8000935a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000935e:	50 39       	stdsp	sp[0xc],r9
80009360:	0a 9e       	mov	lr,r5
80009362:	30 09       	mov	r9,0
80009364:	e2 1e 00 02 	andl	lr,0x2,COH
80009368:	f2 08 18 00 	cp.b	r8,r9
8000936c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009370:	f7 b8 01 ff 	subne	r8,-1
80009374:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009378:	0a 9b       	mov	r11,r5
8000937a:	58 0e       	cp.w	lr,0
8000937c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009380:	f7 bc 01 fe 	subne	r12,-2
80009384:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009388:	e2 1b 00 84 	andl	r11,0x84,COH
8000938c:	50 fe       	stdsp	sp[0x3c],lr
8000938e:	50 9b       	stdsp	sp[0x24],r11
80009390:	c4 71       	brne	8000941e <_vfprintf_r+0x172e>
80009392:	40 8a       	lddsp	r10,sp[0x20]
80009394:	40 39       	lddsp	r9,sp[0xc]
80009396:	12 1a       	sub	r10,r9
80009398:	50 4a       	stdsp	sp[0x10],r10
8000939a:	58 0a       	cp.w	r10,0
8000939c:	e0 89 00 20 	brgt	800093dc <_vfprintf_r+0x16ec>
800093a0:	c3 f8       	rjmp	8000941e <_vfprintf_r+0x172e>
800093a2:	2f 09       	sub	r9,-16
800093a4:	2f f8       	sub	r8,-1
800093a6:	fe ce b9 22 	sub	lr,pc,-18142
800093aa:	31 0c       	mov	r12,16
800093ac:	fb 49 06 90 	st.w	sp[1680],r9
800093b0:	87 0e       	st.w	r3[0x0],lr
800093b2:	87 1c       	st.w	r3[0x4],r12
800093b4:	fb 48 06 8c 	st.w	sp[1676],r8
800093b8:	58 78       	cp.w	r8,7
800093ba:	e0 89 00 04 	brgt	800093c2 <_vfprintf_r+0x16d2>
800093be:	2f 83       	sub	r3,-8
800093c0:	c0 b8       	rjmp	800093d6 <_vfprintf_r+0x16e6>
800093c2:	fa ca f9 78 	sub	r10,sp,-1672
800093c6:	02 9b       	mov	r11,r1
800093c8:	08 9c       	mov	r12,r4
800093ca:	fe b0 f4 85 	rcall	80007cd4 <__sprint_r>
800093ce:	e0 81 04 10 	brne	80009bee <_vfprintf_r+0x1efe>
800093d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800093d6:	40 4b       	lddsp	r11,sp[0x10]
800093d8:	21 0b       	sub	r11,16
800093da:	50 4b       	stdsp	sp[0x10],r11
800093dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800093e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e4:	fe ca b9 60 	sub	r10,pc,-18080
800093e8:	40 4e       	lddsp	lr,sp[0x10]
800093ea:	59 0e       	cp.w	lr,16
800093ec:	fe 99 ff db 	brgt	800093a2 <_vfprintf_r+0x16b2>
800093f0:	1c 09       	add	r9,lr
800093f2:	2f f8       	sub	r8,-1
800093f4:	87 0a       	st.w	r3[0x0],r10
800093f6:	fb 49 06 90 	st.w	sp[1680],r9
800093fa:	87 1e       	st.w	r3[0x4],lr
800093fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009400:	58 78       	cp.w	r8,7
80009402:	e0 89 00 04 	brgt	8000940a <_vfprintf_r+0x171a>
80009406:	2f 83       	sub	r3,-8
80009408:	c0 b8       	rjmp	8000941e <_vfprintf_r+0x172e>
8000940a:	fa ca f9 78 	sub	r10,sp,-1672
8000940e:	02 9b       	mov	r11,r1
80009410:	08 9c       	mov	r12,r4
80009412:	fe b0 f4 61 	rcall	80007cd4 <__sprint_r>
80009416:	e0 81 03 ec 	brne	80009bee <_vfprintf_r+0x1efe>
8000941a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000941e:	30 09       	mov	r9,0
80009420:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009424:	f2 08 18 00 	cp.b	r8,r9
80009428:	c1 f0       	breq	80009466 <_vfprintf_r+0x1776>
8000942a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000942e:	fa c9 f9 45 	sub	r9,sp,-1723
80009432:	2f f8       	sub	r8,-1
80009434:	87 09       	st.w	r3[0x0],r9
80009436:	fb 48 06 90 	st.w	sp[1680],r8
8000943a:	30 19       	mov	r9,1
8000943c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009440:	87 19       	st.w	r3[0x4],r9
80009442:	2f f8       	sub	r8,-1
80009444:	fb 48 06 8c 	st.w	sp[1676],r8
80009448:	58 78       	cp.w	r8,7
8000944a:	e0 89 00 04 	brgt	80009452 <_vfprintf_r+0x1762>
8000944e:	2f 83       	sub	r3,-8
80009450:	c0 b8       	rjmp	80009466 <_vfprintf_r+0x1776>
80009452:	fa ca f9 78 	sub	r10,sp,-1672
80009456:	02 9b       	mov	r11,r1
80009458:	08 9c       	mov	r12,r4
8000945a:	fe b0 f4 3d 	rcall	80007cd4 <__sprint_r>
8000945e:	e0 81 03 c8 	brne	80009bee <_vfprintf_r+0x1efe>
80009462:	fa c3 f9 e0 	sub	r3,sp,-1568
80009466:	40 fc       	lddsp	r12,sp[0x3c]
80009468:	58 0c       	cp.w	r12,0
8000946a:	c1 f0       	breq	800094a8 <_vfprintf_r+0x17b8>
8000946c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009470:	fa c9 f9 48 	sub	r9,sp,-1720
80009474:	2f e8       	sub	r8,-2
80009476:	87 09       	st.w	r3[0x0],r9
80009478:	fb 48 06 90 	st.w	sp[1680],r8
8000947c:	30 29       	mov	r9,2
8000947e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009482:	87 19       	st.w	r3[0x4],r9
80009484:	2f f8       	sub	r8,-1
80009486:	fb 48 06 8c 	st.w	sp[1676],r8
8000948a:	58 78       	cp.w	r8,7
8000948c:	e0 89 00 04 	brgt	80009494 <_vfprintf_r+0x17a4>
80009490:	2f 83       	sub	r3,-8
80009492:	c0 b8       	rjmp	800094a8 <_vfprintf_r+0x17b8>
80009494:	fa ca f9 78 	sub	r10,sp,-1672
80009498:	02 9b       	mov	r11,r1
8000949a:	08 9c       	mov	r12,r4
8000949c:	fe b0 f4 1c 	rcall	80007cd4 <__sprint_r>
800094a0:	e0 81 03 a7 	brne	80009bee <_vfprintf_r+0x1efe>
800094a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094a8:	40 9b       	lddsp	r11,sp[0x24]
800094aa:	e0 4b 00 80 	cp.w	r11,128
800094ae:	c4 71       	brne	8000953c <_vfprintf_r+0x184c>
800094b0:	40 8a       	lddsp	r10,sp[0x20]
800094b2:	40 39       	lddsp	r9,sp[0xc]
800094b4:	12 1a       	sub	r10,r9
800094b6:	50 4a       	stdsp	sp[0x10],r10
800094b8:	58 0a       	cp.w	r10,0
800094ba:	e0 89 00 20 	brgt	800094fa <_vfprintf_r+0x180a>
800094be:	c3 f8       	rjmp	8000953c <_vfprintf_r+0x184c>
800094c0:	2f 09       	sub	r9,-16
800094c2:	2f f8       	sub	r8,-1
800094c4:	fe ce ba 30 	sub	lr,pc,-17872
800094c8:	31 0c       	mov	r12,16
800094ca:	fb 49 06 90 	st.w	sp[1680],r9
800094ce:	87 0e       	st.w	r3[0x0],lr
800094d0:	87 1c       	st.w	r3[0x4],r12
800094d2:	fb 48 06 8c 	st.w	sp[1676],r8
800094d6:	58 78       	cp.w	r8,7
800094d8:	e0 89 00 04 	brgt	800094e0 <_vfprintf_r+0x17f0>
800094dc:	2f 83       	sub	r3,-8
800094de:	c0 b8       	rjmp	800094f4 <_vfprintf_r+0x1804>
800094e0:	fa ca f9 78 	sub	r10,sp,-1672
800094e4:	02 9b       	mov	r11,r1
800094e6:	08 9c       	mov	r12,r4
800094e8:	fe b0 f3 f6 	rcall	80007cd4 <__sprint_r>
800094ec:	e0 81 03 81 	brne	80009bee <_vfprintf_r+0x1efe>
800094f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f4:	40 4b       	lddsp	r11,sp[0x10]
800094f6:	21 0b       	sub	r11,16
800094f8:	50 4b       	stdsp	sp[0x10],r11
800094fa:	fa f9 06 90 	ld.w	r9,sp[1680]
800094fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009502:	fe ca ba 6e 	sub	r10,pc,-17810
80009506:	40 4e       	lddsp	lr,sp[0x10]
80009508:	59 0e       	cp.w	lr,16
8000950a:	fe 99 ff db 	brgt	800094c0 <_vfprintf_r+0x17d0>
8000950e:	1c 09       	add	r9,lr
80009510:	2f f8       	sub	r8,-1
80009512:	87 0a       	st.w	r3[0x0],r10
80009514:	fb 49 06 90 	st.w	sp[1680],r9
80009518:	87 1e       	st.w	r3[0x4],lr
8000951a:	fb 48 06 8c 	st.w	sp[1676],r8
8000951e:	58 78       	cp.w	r8,7
80009520:	e0 89 00 04 	brgt	80009528 <_vfprintf_r+0x1838>
80009524:	2f 83       	sub	r3,-8
80009526:	c0 b8       	rjmp	8000953c <_vfprintf_r+0x184c>
80009528:	fa ca f9 78 	sub	r10,sp,-1672
8000952c:	02 9b       	mov	r11,r1
8000952e:	08 9c       	mov	r12,r4
80009530:	fe b0 f3 d2 	rcall	80007cd4 <__sprint_r>
80009534:	e0 81 03 5d 	brne	80009bee <_vfprintf_r+0x1efe>
80009538:	fa c3 f9 e0 	sub	r3,sp,-1568
8000953c:	40 2c       	lddsp	r12,sp[0x8]
8000953e:	04 1c       	sub	r12,r2
80009540:	50 2c       	stdsp	sp[0x8],r12
80009542:	58 0c       	cp.w	r12,0
80009544:	e0 89 00 20 	brgt	80009584 <_vfprintf_r+0x1894>
80009548:	c3 f8       	rjmp	800095c6 <_vfprintf_r+0x18d6>
8000954a:	2f 09       	sub	r9,-16
8000954c:	2f f8       	sub	r8,-1
8000954e:	fe cb ba ba 	sub	r11,pc,-17734
80009552:	31 0a       	mov	r10,16
80009554:	fb 49 06 90 	st.w	sp[1680],r9
80009558:	87 0b       	st.w	r3[0x0],r11
8000955a:	87 1a       	st.w	r3[0x4],r10
8000955c:	fb 48 06 8c 	st.w	sp[1676],r8
80009560:	58 78       	cp.w	r8,7
80009562:	e0 89 00 04 	brgt	8000956a <_vfprintf_r+0x187a>
80009566:	2f 83       	sub	r3,-8
80009568:	c0 b8       	rjmp	8000957e <_vfprintf_r+0x188e>
8000956a:	fa ca f9 78 	sub	r10,sp,-1672
8000956e:	02 9b       	mov	r11,r1
80009570:	08 9c       	mov	r12,r4
80009572:	fe b0 f3 b1 	rcall	80007cd4 <__sprint_r>
80009576:	e0 81 03 3c 	brne	80009bee <_vfprintf_r+0x1efe>
8000957a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000957e:	40 29       	lddsp	r9,sp[0x8]
80009580:	21 09       	sub	r9,16
80009582:	50 29       	stdsp	sp[0x8],r9
80009584:	fa f9 06 90 	ld.w	r9,sp[1680]
80009588:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000958c:	fe ca ba f8 	sub	r10,pc,-17672
80009590:	40 2e       	lddsp	lr,sp[0x8]
80009592:	59 0e       	cp.w	lr,16
80009594:	fe 99 ff db 	brgt	8000954a <_vfprintf_r+0x185a>
80009598:	1c 09       	add	r9,lr
8000959a:	2f f8       	sub	r8,-1
8000959c:	87 0a       	st.w	r3[0x0],r10
8000959e:	fb 49 06 90 	st.w	sp[1680],r9
800095a2:	87 1e       	st.w	r3[0x4],lr
800095a4:	fb 48 06 8c 	st.w	sp[1676],r8
800095a8:	58 78       	cp.w	r8,7
800095aa:	e0 89 00 04 	brgt	800095b2 <_vfprintf_r+0x18c2>
800095ae:	2f 83       	sub	r3,-8
800095b0:	c0 b8       	rjmp	800095c6 <_vfprintf_r+0x18d6>
800095b2:	fa ca f9 78 	sub	r10,sp,-1672
800095b6:	02 9b       	mov	r11,r1
800095b8:	08 9c       	mov	r12,r4
800095ba:	fe b0 f3 8d 	rcall	80007cd4 <__sprint_r>
800095be:	e0 81 03 18 	brne	80009bee <_vfprintf_r+0x1efe>
800095c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800095c6:	ed b5 00 08 	bld	r5,0x8
800095ca:	c0 b0       	breq	800095e0 <_vfprintf_r+0x18f0>
800095cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800095d0:	87 12       	st.w	r3[0x4],r2
800095d2:	87 06       	st.w	r3[0x0],r6
800095d4:	f0 02 00 02 	add	r2,r8,r2
800095d8:	fb 42 06 90 	st.w	sp[1680],r2
800095dc:	e0 8f 01 d4 	bral	80009984 <_vfprintf_r+0x1c94>
800095e0:	e0 40 00 65 	cp.w	r0,101
800095e4:	e0 8a 01 d6 	brle	80009990 <_vfprintf_r+0x1ca0>
800095e8:	30 08       	mov	r8,0
800095ea:	30 09       	mov	r9,0
800095ec:	40 5b       	lddsp	r11,sp[0x14]
800095ee:	40 7a       	lddsp	r10,sp[0x1c]
800095f0:	e0 a0 15 3b 	rcall	8000c066 <__avr32_f64_cmp_eq>
800095f4:	c7 90       	breq	800096e6 <_vfprintf_r+0x19f6>
800095f6:	fa f8 06 90 	ld.w	r8,sp[1680]
800095fa:	fe c9 bb 7a 	sub	r9,pc,-17542
800095fe:	2f f8       	sub	r8,-1
80009600:	87 09       	st.w	r3[0x0],r9
80009602:	fb 48 06 90 	st.w	sp[1680],r8
80009606:	30 19       	mov	r9,1
80009608:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000960c:	87 19       	st.w	r3[0x4],r9
8000960e:	2f f8       	sub	r8,-1
80009610:	fb 48 06 8c 	st.w	sp[1676],r8
80009614:	58 78       	cp.w	r8,7
80009616:	e0 89 00 05 	brgt	80009620 <_vfprintf_r+0x1930>
8000961a:	2f 83       	sub	r3,-8
8000961c:	c0 c8       	rjmp	80009634 <_vfprintf_r+0x1944>
8000961e:	d7 03       	nop
80009620:	fa ca f9 78 	sub	r10,sp,-1672
80009624:	02 9b       	mov	r11,r1
80009626:	08 9c       	mov	r12,r4
80009628:	fe b0 f3 56 	rcall	80007cd4 <__sprint_r>
8000962c:	e0 81 02 e1 	brne	80009bee <_vfprintf_r+0x1efe>
80009630:	fa c3 f9 e0 	sub	r3,sp,-1568
80009634:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009638:	40 6c       	lddsp	r12,sp[0x18]
8000963a:	18 38       	cp.w	r8,r12
8000963c:	c0 55       	brlt	80009646 <_vfprintf_r+0x1956>
8000963e:	ed b5 00 00 	bld	r5,0x0
80009642:	e0 81 02 6b 	brne	80009b18 <_vfprintf_r+0x1e28>
80009646:	fa f8 06 90 	ld.w	r8,sp[1680]
8000964a:	2f f8       	sub	r8,-1
8000964c:	40 cb       	lddsp	r11,sp[0x30]
8000964e:	fb 48 06 90 	st.w	sp[1680],r8
80009652:	30 19       	mov	r9,1
80009654:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009658:	87 0b       	st.w	r3[0x0],r11
8000965a:	2f f8       	sub	r8,-1
8000965c:	87 19       	st.w	r3[0x4],r9
8000965e:	fb 48 06 8c 	st.w	sp[1676],r8
80009662:	58 78       	cp.w	r8,7
80009664:	e0 89 00 04 	brgt	8000966c <_vfprintf_r+0x197c>
80009668:	2f 83       	sub	r3,-8
8000966a:	c0 b8       	rjmp	80009680 <_vfprintf_r+0x1990>
8000966c:	fa ca f9 78 	sub	r10,sp,-1672
80009670:	02 9b       	mov	r11,r1
80009672:	08 9c       	mov	r12,r4
80009674:	fe b0 f3 30 	rcall	80007cd4 <__sprint_r>
80009678:	e0 81 02 bb 	brne	80009bee <_vfprintf_r+0x1efe>
8000967c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009680:	40 66       	lddsp	r6,sp[0x18]
80009682:	20 16       	sub	r6,1
80009684:	58 06       	cp.w	r6,0
80009686:	e0 89 00 1d 	brgt	800096c0 <_vfprintf_r+0x19d0>
8000968a:	e0 8f 02 47 	bral	80009b18 <_vfprintf_r+0x1e28>
8000968e:	2f 09       	sub	r9,-16
80009690:	2f f8       	sub	r8,-1
80009692:	fb 49 06 90 	st.w	sp[1680],r9
80009696:	87 02       	st.w	r3[0x0],r2
80009698:	87 10       	st.w	r3[0x4],r0
8000969a:	fb 48 06 8c 	st.w	sp[1676],r8
8000969e:	58 78       	cp.w	r8,7
800096a0:	e0 89 00 04 	brgt	800096a8 <_vfprintf_r+0x19b8>
800096a4:	2f 83       	sub	r3,-8
800096a6:	c0 b8       	rjmp	800096bc <_vfprintf_r+0x19cc>
800096a8:	fa ca f9 78 	sub	r10,sp,-1672
800096ac:	02 9b       	mov	r11,r1
800096ae:	08 9c       	mov	r12,r4
800096b0:	fe b0 f3 12 	rcall	80007cd4 <__sprint_r>
800096b4:	e0 81 02 9d 	brne	80009bee <_vfprintf_r+0x1efe>
800096b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800096bc:	21 06       	sub	r6,16
800096be:	c0 48       	rjmp	800096c6 <_vfprintf_r+0x19d6>
800096c0:	fe c2 bc 2c 	sub	r2,pc,-17364
800096c4:	31 00       	mov	r0,16
800096c6:	fa f9 06 90 	ld.w	r9,sp[1680]
800096ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096ce:	fe ca bc 3a 	sub	r10,pc,-17350
800096d2:	59 06       	cp.w	r6,16
800096d4:	fe 99 ff dd 	brgt	8000968e <_vfprintf_r+0x199e>
800096d8:	0c 09       	add	r9,r6
800096da:	87 0a       	st.w	r3[0x0],r10
800096dc:	fb 49 06 90 	st.w	sp[1680],r9
800096e0:	2f f8       	sub	r8,-1
800096e2:	87 16       	st.w	r3[0x4],r6
800096e4:	c5 39       	rjmp	8000998a <_vfprintf_r+0x1c9a>
800096e6:	fa fa 06 ac 	ld.w	r10,sp[1708]
800096ea:	58 0a       	cp.w	r10,0
800096ec:	e0 89 00 92 	brgt	80009810 <_vfprintf_r+0x1b20>
800096f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800096f4:	fe c9 bc 74 	sub	r9,pc,-17292
800096f8:	2f f8       	sub	r8,-1
800096fa:	87 09       	st.w	r3[0x0],r9
800096fc:	fb 48 06 90 	st.w	sp[1680],r8
80009700:	30 19       	mov	r9,1
80009702:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009706:	87 19       	st.w	r3[0x4],r9
80009708:	2f f8       	sub	r8,-1
8000970a:	fb 48 06 8c 	st.w	sp[1676],r8
8000970e:	58 78       	cp.w	r8,7
80009710:	e0 89 00 04 	brgt	80009718 <_vfprintf_r+0x1a28>
80009714:	2f 83       	sub	r3,-8
80009716:	c0 b8       	rjmp	8000972c <_vfprintf_r+0x1a3c>
80009718:	fa ca f9 78 	sub	r10,sp,-1672
8000971c:	02 9b       	mov	r11,r1
8000971e:	08 9c       	mov	r12,r4
80009720:	fe b0 f2 da 	rcall	80007cd4 <__sprint_r>
80009724:	e0 81 02 65 	brne	80009bee <_vfprintf_r+0x1efe>
80009728:	fa c3 f9 e0 	sub	r3,sp,-1568
8000972c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009730:	58 08       	cp.w	r8,0
80009732:	c0 81       	brne	80009742 <_vfprintf_r+0x1a52>
80009734:	40 6a       	lddsp	r10,sp[0x18]
80009736:	58 0a       	cp.w	r10,0
80009738:	c0 51       	brne	80009742 <_vfprintf_r+0x1a52>
8000973a:	ed b5 00 00 	bld	r5,0x0
8000973e:	e0 81 01 ed 	brne	80009b18 <_vfprintf_r+0x1e28>
80009742:	40 c9       	lddsp	r9,sp[0x30]
80009744:	fa f8 06 90 	ld.w	r8,sp[1680]
80009748:	2f f8       	sub	r8,-1
8000974a:	87 09       	st.w	r3[0x0],r9
8000974c:	fb 48 06 90 	st.w	sp[1680],r8
80009750:	30 19       	mov	r9,1
80009752:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009756:	87 19       	st.w	r3[0x4],r9
80009758:	2f f8       	sub	r8,-1
8000975a:	fb 48 06 8c 	st.w	sp[1676],r8
8000975e:	58 78       	cp.w	r8,7
80009760:	e0 89 00 04 	brgt	80009768 <_vfprintf_r+0x1a78>
80009764:	2f 83       	sub	r3,-8
80009766:	c0 b8       	rjmp	8000977c <_vfprintf_r+0x1a8c>
80009768:	fa ca f9 78 	sub	r10,sp,-1672
8000976c:	02 9b       	mov	r11,r1
8000976e:	08 9c       	mov	r12,r4
80009770:	fe b0 f2 b2 	rcall	80007cd4 <__sprint_r>
80009774:	e0 81 02 3d 	brne	80009bee <_vfprintf_r+0x1efe>
80009778:	fa c3 f9 e0 	sub	r3,sp,-1568
8000977c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009780:	5c 32       	neg	r2
80009782:	58 02       	cp.w	r2,0
80009784:	e0 89 00 1d 	brgt	800097be <_vfprintf_r+0x1ace>
80009788:	c3 d8       	rjmp	80009802 <_vfprintf_r+0x1b12>
8000978a:	2f 09       	sub	r9,-16
8000978c:	2f f8       	sub	r8,-1
8000978e:	31 0e       	mov	lr,16
80009790:	fb 49 06 90 	st.w	sp[1680],r9
80009794:	87 00       	st.w	r3[0x0],r0
80009796:	87 1e       	st.w	r3[0x4],lr
80009798:	fb 48 06 8c 	st.w	sp[1676],r8
8000979c:	58 78       	cp.w	r8,7
8000979e:	e0 89 00 04 	brgt	800097a6 <_vfprintf_r+0x1ab6>
800097a2:	2f 83       	sub	r3,-8
800097a4:	c0 b8       	rjmp	800097ba <_vfprintf_r+0x1aca>
800097a6:	fa ca f9 78 	sub	r10,sp,-1672
800097aa:	02 9b       	mov	r11,r1
800097ac:	08 9c       	mov	r12,r4
800097ae:	fe b0 f2 93 	rcall	80007cd4 <__sprint_r>
800097b2:	e0 81 02 1e 	brne	80009bee <_vfprintf_r+0x1efe>
800097b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ba:	21 02       	sub	r2,16
800097bc:	c0 38       	rjmp	800097c2 <_vfprintf_r+0x1ad2>
800097be:	fe c0 bd 2a 	sub	r0,pc,-17110
800097c2:	fa f9 06 90 	ld.w	r9,sp[1680]
800097c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ca:	fe ca bd 36 	sub	r10,pc,-17098
800097ce:	59 02       	cp.w	r2,16
800097d0:	fe 99 ff dd 	brgt	8000978a <_vfprintf_r+0x1a9a>
800097d4:	04 09       	add	r9,r2
800097d6:	2f f8       	sub	r8,-1
800097d8:	87 0a       	st.w	r3[0x0],r10
800097da:	fb 49 06 90 	st.w	sp[1680],r9
800097de:	87 12       	st.w	r3[0x4],r2
800097e0:	fb 48 06 8c 	st.w	sp[1676],r8
800097e4:	58 78       	cp.w	r8,7
800097e6:	e0 89 00 04 	brgt	800097ee <_vfprintf_r+0x1afe>
800097ea:	2f 83       	sub	r3,-8
800097ec:	c0 b8       	rjmp	80009802 <_vfprintf_r+0x1b12>
800097ee:	fa ca f9 78 	sub	r10,sp,-1672
800097f2:	02 9b       	mov	r11,r1
800097f4:	08 9c       	mov	r12,r4
800097f6:	fe b0 f2 6f 	rcall	80007cd4 <__sprint_r>
800097fa:	e0 81 01 fa 	brne	80009bee <_vfprintf_r+0x1efe>
800097fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009802:	40 6c       	lddsp	r12,sp[0x18]
80009804:	fa f8 06 90 	ld.w	r8,sp[1680]
80009808:	87 06       	st.w	r3[0x0],r6
8000980a:	87 1c       	st.w	r3[0x4],r12
8000980c:	18 08       	add	r8,r12
8000980e:	cb 98       	rjmp	80009980 <_vfprintf_r+0x1c90>
80009810:	fa f9 06 90 	ld.w	r9,sp[1680]
80009814:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009818:	40 6b       	lddsp	r11,sp[0x18]
8000981a:	16 3a       	cp.w	r10,r11
8000981c:	c6 f5       	brlt	800098fa <_vfprintf_r+0x1c0a>
8000981e:	16 09       	add	r9,r11
80009820:	2f f8       	sub	r8,-1
80009822:	87 06       	st.w	r3[0x0],r6
80009824:	fb 49 06 90 	st.w	sp[1680],r9
80009828:	87 1b       	st.w	r3[0x4],r11
8000982a:	fb 48 06 8c 	st.w	sp[1676],r8
8000982e:	58 78       	cp.w	r8,7
80009830:	e0 89 00 04 	brgt	80009838 <_vfprintf_r+0x1b48>
80009834:	2f 83       	sub	r3,-8
80009836:	c0 b8       	rjmp	8000984c <_vfprintf_r+0x1b5c>
80009838:	fa ca f9 78 	sub	r10,sp,-1672
8000983c:	02 9b       	mov	r11,r1
8000983e:	08 9c       	mov	r12,r4
80009840:	fe b0 f2 4a 	rcall	80007cd4 <__sprint_r>
80009844:	e0 81 01 d5 	brne	80009bee <_vfprintf_r+0x1efe>
80009848:	fa c3 f9 e0 	sub	r3,sp,-1568
8000984c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009850:	40 6a       	lddsp	r10,sp[0x18]
80009852:	14 16       	sub	r6,r10
80009854:	58 06       	cp.w	r6,0
80009856:	e0 89 00 1c 	brgt	8000988e <_vfprintf_r+0x1b9e>
8000985a:	c3 d8       	rjmp	800098d4 <_vfprintf_r+0x1be4>
8000985c:	2f 09       	sub	r9,-16
8000985e:	2f f8       	sub	r8,-1
80009860:	fb 49 06 90 	st.w	sp[1680],r9
80009864:	87 02       	st.w	r3[0x0],r2
80009866:	87 10       	st.w	r3[0x4],r0
80009868:	fb 48 06 8c 	st.w	sp[1676],r8
8000986c:	58 78       	cp.w	r8,7
8000986e:	e0 89 00 04 	brgt	80009876 <_vfprintf_r+0x1b86>
80009872:	2f 83       	sub	r3,-8
80009874:	c0 b8       	rjmp	8000988a <_vfprintf_r+0x1b9a>
80009876:	fa ca f9 78 	sub	r10,sp,-1672
8000987a:	02 9b       	mov	r11,r1
8000987c:	08 9c       	mov	r12,r4
8000987e:	fe b0 f2 2b 	rcall	80007cd4 <__sprint_r>
80009882:	e0 81 01 b6 	brne	80009bee <_vfprintf_r+0x1efe>
80009886:	fa c3 f9 e0 	sub	r3,sp,-1568
8000988a:	21 06       	sub	r6,16
8000988c:	c0 48       	rjmp	80009894 <_vfprintf_r+0x1ba4>
8000988e:	fe c2 bd fa 	sub	r2,pc,-16902
80009892:	31 00       	mov	r0,16
80009894:	fa f9 06 90 	ld.w	r9,sp[1680]
80009898:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000989c:	fe ca be 08 	sub	r10,pc,-16888
800098a0:	59 06       	cp.w	r6,16
800098a2:	fe 99 ff dd 	brgt	8000985c <_vfprintf_r+0x1b6c>
800098a6:	0c 09       	add	r9,r6
800098a8:	2f f8       	sub	r8,-1
800098aa:	87 0a       	st.w	r3[0x0],r10
800098ac:	fb 49 06 90 	st.w	sp[1680],r9
800098b0:	87 16       	st.w	r3[0x4],r6
800098b2:	fb 48 06 8c 	st.w	sp[1676],r8
800098b6:	58 78       	cp.w	r8,7
800098b8:	e0 89 00 04 	brgt	800098c0 <_vfprintf_r+0x1bd0>
800098bc:	2f 83       	sub	r3,-8
800098be:	c0 b8       	rjmp	800098d4 <_vfprintf_r+0x1be4>
800098c0:	fa ca f9 78 	sub	r10,sp,-1672
800098c4:	02 9b       	mov	r11,r1
800098c6:	08 9c       	mov	r12,r4
800098c8:	fe b0 f2 06 	rcall	80007cd4 <__sprint_r>
800098cc:	e0 81 01 91 	brne	80009bee <_vfprintf_r+0x1efe>
800098d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d4:	ed b5 00 00 	bld	r5,0x0
800098d8:	e0 81 01 20 	brne	80009b18 <_vfprintf_r+0x1e28>
800098dc:	40 c9       	lddsp	r9,sp[0x30]
800098de:	fa f8 06 90 	ld.w	r8,sp[1680]
800098e2:	2f f8       	sub	r8,-1
800098e4:	87 09       	st.w	r3[0x0],r9
800098e6:	fb 48 06 90 	st.w	sp[1680],r8
800098ea:	30 19       	mov	r9,1
800098ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098f0:	87 19       	st.w	r3[0x4],r9
800098f2:	2f f8       	sub	r8,-1
800098f4:	fb 48 06 8c 	st.w	sp[1676],r8
800098f8:	c0 29       	rjmp	80009afc <_vfprintf_r+0x1e0c>
800098fa:	14 09       	add	r9,r10
800098fc:	2f f8       	sub	r8,-1
800098fe:	fb 49 06 90 	st.w	sp[1680],r9
80009902:	87 06       	st.w	r3[0x0],r6
80009904:	87 1a       	st.w	r3[0x4],r10
80009906:	fb 48 06 8c 	st.w	sp[1676],r8
8000990a:	58 78       	cp.w	r8,7
8000990c:	e0 89 00 04 	brgt	80009914 <_vfprintf_r+0x1c24>
80009910:	2f 83       	sub	r3,-8
80009912:	c0 b8       	rjmp	80009928 <_vfprintf_r+0x1c38>
80009914:	fa ca f9 78 	sub	r10,sp,-1672
80009918:	02 9b       	mov	r11,r1
8000991a:	08 9c       	mov	r12,r4
8000991c:	fe b0 f1 dc 	rcall	80007cd4 <__sprint_r>
80009920:	e0 81 01 67 	brne	80009bee <_vfprintf_r+0x1efe>
80009924:	fa c3 f9 e0 	sub	r3,sp,-1568
80009928:	40 c8       	lddsp	r8,sp[0x30]
8000992a:	87 08       	st.w	r3[0x0],r8
8000992c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009930:	2f f8       	sub	r8,-1
80009932:	30 19       	mov	r9,1
80009934:	fb 48 06 90 	st.w	sp[1680],r8
80009938:	87 19       	st.w	r3[0x4],r9
8000993a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000993e:	2f f8       	sub	r8,-1
80009940:	fb 48 06 8c 	st.w	sp[1676],r8
80009944:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009948:	58 78       	cp.w	r8,7
8000994a:	e0 89 00 04 	brgt	80009952 <_vfprintf_r+0x1c62>
8000994e:	2f 83       	sub	r3,-8
80009950:	c0 b8       	rjmp	80009966 <_vfprintf_r+0x1c76>
80009952:	fa ca f9 78 	sub	r10,sp,-1672
80009956:	02 9b       	mov	r11,r1
80009958:	08 9c       	mov	r12,r4
8000995a:	fe b0 f1 bd 	rcall	80007cd4 <__sprint_r>
8000995e:	e0 81 01 48 	brne	80009bee <_vfprintf_r+0x1efe>
80009962:	fa c3 f9 e0 	sub	r3,sp,-1568
80009966:	04 06       	add	r6,r2
80009968:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000996c:	87 06       	st.w	r3[0x0],r6
8000996e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009972:	40 66       	lddsp	r6,sp[0x18]
80009974:	40 6e       	lddsp	lr,sp[0x18]
80009976:	10 16       	sub	r6,r8
80009978:	f2 08 01 08 	sub	r8,r9,r8
8000997c:	87 16       	st.w	r3[0x4],r6
8000997e:	1c 08       	add	r8,lr
80009980:	fb 48 06 90 	st.w	sp[1680],r8
80009984:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009988:	2f f8       	sub	r8,-1
8000998a:	fb 48 06 8c 	st.w	sp[1676],r8
8000998e:	cb 78       	rjmp	80009afc <_vfprintf_r+0x1e0c>
80009990:	40 6c       	lddsp	r12,sp[0x18]
80009992:	58 1c       	cp.w	r12,1
80009994:	e0 89 00 06 	brgt	800099a0 <_vfprintf_r+0x1cb0>
80009998:	ed b5 00 00 	bld	r5,0x0
8000999c:	e0 81 00 85 	brne	80009aa6 <_vfprintf_r+0x1db6>
800099a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a4:	2f f8       	sub	r8,-1
800099a6:	30 19       	mov	r9,1
800099a8:	fb 48 06 90 	st.w	sp[1680],r8
800099ac:	87 06       	st.w	r3[0x0],r6
800099ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b2:	87 19       	st.w	r3[0x4],r9
800099b4:	2f f8       	sub	r8,-1
800099b6:	fb 48 06 8c 	st.w	sp[1676],r8
800099ba:	58 78       	cp.w	r8,7
800099bc:	e0 89 00 04 	brgt	800099c4 <_vfprintf_r+0x1cd4>
800099c0:	2f 83       	sub	r3,-8
800099c2:	c0 b8       	rjmp	800099d8 <_vfprintf_r+0x1ce8>
800099c4:	fa ca f9 78 	sub	r10,sp,-1672
800099c8:	02 9b       	mov	r11,r1
800099ca:	08 9c       	mov	r12,r4
800099cc:	fe b0 f1 84 	rcall	80007cd4 <__sprint_r>
800099d0:	e0 81 01 0f 	brne	80009bee <_vfprintf_r+0x1efe>
800099d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099dc:	2f f8       	sub	r8,-1
800099de:	40 cb       	lddsp	r11,sp[0x30]
800099e0:	fb 48 06 90 	st.w	sp[1680],r8
800099e4:	30 19       	mov	r9,1
800099e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ea:	87 0b       	st.w	r3[0x0],r11
800099ec:	2f f8       	sub	r8,-1
800099ee:	87 19       	st.w	r3[0x4],r9
800099f0:	fb 48 06 8c 	st.w	sp[1676],r8
800099f4:	58 78       	cp.w	r8,7
800099f6:	e0 89 00 05 	brgt	80009a00 <_vfprintf_r+0x1d10>
800099fa:	2f 83       	sub	r3,-8
800099fc:	c0 c8       	rjmp	80009a14 <_vfprintf_r+0x1d24>
800099fe:	d7 03       	nop
80009a00:	fa ca f9 78 	sub	r10,sp,-1672
80009a04:	02 9b       	mov	r11,r1
80009a06:	08 9c       	mov	r12,r4
80009a08:	fe b0 f1 66 	rcall	80007cd4 <__sprint_r>
80009a0c:	e0 81 00 f1 	brne	80009bee <_vfprintf_r+0x1efe>
80009a10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a14:	30 08       	mov	r8,0
80009a16:	30 09       	mov	r9,0
80009a18:	40 5b       	lddsp	r11,sp[0x14]
80009a1a:	40 7a       	lddsp	r10,sp[0x1c]
80009a1c:	e0 a0 13 25 	rcall	8000c066 <__avr32_f64_cmp_eq>
80009a20:	40 68       	lddsp	r8,sp[0x18]
80009a22:	20 18       	sub	r8,1
80009a24:	58 0c       	cp.w	r12,0
80009a26:	c0 d1       	brne	80009a40 <_vfprintf_r+0x1d50>
80009a28:	2f f6       	sub	r6,-1
80009a2a:	87 18       	st.w	r3[0x4],r8
80009a2c:	87 06       	st.w	r3[0x0],r6
80009a2e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009a32:	10 06       	add	r6,r8
80009a34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a38:	fb 46 06 90 	st.w	sp[1680],r6
80009a3c:	2f f8       	sub	r8,-1
80009a3e:	c3 18       	rjmp	80009aa0 <_vfprintf_r+0x1db0>
80009a40:	10 96       	mov	r6,r8
80009a42:	58 08       	cp.w	r8,0
80009a44:	e0 89 00 1c 	brgt	80009a7c <_vfprintf_r+0x1d8c>
80009a48:	c4 b8       	rjmp	80009ade <_vfprintf_r+0x1dee>
80009a4a:	2f 09       	sub	r9,-16
80009a4c:	2f f8       	sub	r8,-1
80009a4e:	fb 49 06 90 	st.w	sp[1680],r9
80009a52:	87 02       	st.w	r3[0x0],r2
80009a54:	87 10       	st.w	r3[0x4],r0
80009a56:	fb 48 06 8c 	st.w	sp[1676],r8
80009a5a:	58 78       	cp.w	r8,7
80009a5c:	e0 89 00 04 	brgt	80009a64 <_vfprintf_r+0x1d74>
80009a60:	2f 83       	sub	r3,-8
80009a62:	c0 b8       	rjmp	80009a78 <_vfprintf_r+0x1d88>
80009a64:	fa ca f9 78 	sub	r10,sp,-1672
80009a68:	02 9b       	mov	r11,r1
80009a6a:	08 9c       	mov	r12,r4
80009a6c:	fe b0 f1 34 	rcall	80007cd4 <__sprint_r>
80009a70:	e0 81 00 bf 	brne	80009bee <_vfprintf_r+0x1efe>
80009a74:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a78:	21 06       	sub	r6,16
80009a7a:	c0 48       	rjmp	80009a82 <_vfprintf_r+0x1d92>
80009a7c:	fe c2 bf e8 	sub	r2,pc,-16408
80009a80:	31 00       	mov	r0,16
80009a82:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a8a:	fe ca bf f6 	sub	r10,pc,-16394
80009a8e:	59 06       	cp.w	r6,16
80009a90:	fe 99 ff dd 	brgt	80009a4a <_vfprintf_r+0x1d5a>
80009a94:	0c 09       	add	r9,r6
80009a96:	87 0a       	st.w	r3[0x0],r10
80009a98:	fb 49 06 90 	st.w	sp[1680],r9
80009a9c:	2f f8       	sub	r8,-1
80009a9e:	87 16       	st.w	r3[0x4],r6
80009aa0:	fb 48 06 8c 	st.w	sp[1676],r8
80009aa4:	c0 e8       	rjmp	80009ac0 <_vfprintf_r+0x1dd0>
80009aa6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009aaa:	2f f8       	sub	r8,-1
80009aac:	30 19       	mov	r9,1
80009aae:	fb 48 06 90 	st.w	sp[1680],r8
80009ab2:	87 06       	st.w	r3[0x0],r6
80009ab4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ab8:	87 19       	st.w	r3[0x4],r9
80009aba:	2f f8       	sub	r8,-1
80009abc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ac0:	58 78       	cp.w	r8,7
80009ac2:	e0 89 00 04 	brgt	80009aca <_vfprintf_r+0x1dda>
80009ac6:	2f 83       	sub	r3,-8
80009ac8:	c0 b8       	rjmp	80009ade <_vfprintf_r+0x1dee>
80009aca:	fa ca f9 78 	sub	r10,sp,-1672
80009ace:	02 9b       	mov	r11,r1
80009ad0:	08 9c       	mov	r12,r4
80009ad2:	fe b0 f1 01 	rcall	80007cd4 <__sprint_r>
80009ad6:	e0 81 00 8c 	brne	80009bee <_vfprintf_r+0x1efe>
80009ada:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ade:	40 ea       	lddsp	r10,sp[0x38]
80009ae0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ae4:	14 08       	add	r8,r10
80009ae6:	fa c9 f9 64 	sub	r9,sp,-1692
80009aea:	fb 48 06 90 	st.w	sp[1680],r8
80009aee:	87 1a       	st.w	r3[0x4],r10
80009af0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009af4:	87 09       	st.w	r3[0x0],r9
80009af6:	2f f8       	sub	r8,-1
80009af8:	fb 48 06 8c 	st.w	sp[1676],r8
80009afc:	58 78       	cp.w	r8,7
80009afe:	e0 89 00 04 	brgt	80009b06 <_vfprintf_r+0x1e16>
80009b02:	2f 83       	sub	r3,-8
80009b04:	c0 a8       	rjmp	80009b18 <_vfprintf_r+0x1e28>
80009b06:	fa ca f9 78 	sub	r10,sp,-1672
80009b0a:	02 9b       	mov	r11,r1
80009b0c:	08 9c       	mov	r12,r4
80009b0e:	fe b0 f0 e3 	rcall	80007cd4 <__sprint_r>
80009b12:	c6 e1       	brne	80009bee <_vfprintf_r+0x1efe>
80009b14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b18:	e2 15 00 04 	andl	r5,0x4,COH
80009b1c:	c3 f0       	breq	80009b9a <_vfprintf_r+0x1eaa>
80009b1e:	40 86       	lddsp	r6,sp[0x20]
80009b20:	40 39       	lddsp	r9,sp[0xc]
80009b22:	12 16       	sub	r6,r9
80009b24:	58 06       	cp.w	r6,0
80009b26:	e0 89 00 1a 	brgt	80009b5a <_vfprintf_r+0x1e6a>
80009b2a:	c3 88       	rjmp	80009b9a <_vfprintf_r+0x1eaa>
80009b2c:	2f 09       	sub	r9,-16
80009b2e:	2f f8       	sub	r8,-1
80009b30:	fb 49 06 90 	st.w	sp[1680],r9
80009b34:	87 05       	st.w	r3[0x0],r5
80009b36:	87 12       	st.w	r3[0x4],r2
80009b38:	fb 48 06 8c 	st.w	sp[1676],r8
80009b3c:	58 78       	cp.w	r8,7
80009b3e:	e0 89 00 04 	brgt	80009b46 <_vfprintf_r+0x1e56>
80009b42:	2f 83       	sub	r3,-8
80009b44:	c0 98       	rjmp	80009b56 <_vfprintf_r+0x1e66>
80009b46:	00 9a       	mov	r10,r0
80009b48:	02 9b       	mov	r11,r1
80009b4a:	08 9c       	mov	r12,r4
80009b4c:	fe b0 f0 c4 	rcall	80007cd4 <__sprint_r>
80009b50:	c4 f1       	brne	80009bee <_vfprintf_r+0x1efe>
80009b52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b56:	21 06       	sub	r6,16
80009b58:	c0 68       	rjmp	80009b64 <_vfprintf_r+0x1e74>
80009b5a:	fe c5 c0 d6 	sub	r5,pc,-16170
80009b5e:	31 02       	mov	r2,16
80009b60:	fa c0 f9 78 	sub	r0,sp,-1672
80009b64:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b6c:	fe ca c0 e8 	sub	r10,pc,-16152
80009b70:	59 06       	cp.w	r6,16
80009b72:	fe 99 ff dd 	brgt	80009b2c <_vfprintf_r+0x1e3c>
80009b76:	0c 09       	add	r9,r6
80009b78:	2f f8       	sub	r8,-1
80009b7a:	87 0a       	st.w	r3[0x0],r10
80009b7c:	87 16       	st.w	r3[0x4],r6
80009b7e:	fb 49 06 90 	st.w	sp[1680],r9
80009b82:	fb 48 06 8c 	st.w	sp[1676],r8
80009b86:	58 78       	cp.w	r8,7
80009b88:	e0 8a 00 09 	brle	80009b9a <_vfprintf_r+0x1eaa>
80009b8c:	fa ca f9 78 	sub	r10,sp,-1672
80009b90:	02 9b       	mov	r11,r1
80009b92:	08 9c       	mov	r12,r4
80009b94:	fe b0 f0 a0 	rcall	80007cd4 <__sprint_r>
80009b98:	c2 b1       	brne	80009bee <_vfprintf_r+0x1efe>
80009b9a:	40 bc       	lddsp	r12,sp[0x2c]
80009b9c:	40 36       	lddsp	r6,sp[0xc]
80009b9e:	40 8e       	lddsp	lr,sp[0x20]
80009ba0:	ec 0e 0c 48 	max	r8,r6,lr
80009ba4:	10 0c       	add	r12,r8
80009ba6:	50 bc       	stdsp	sp[0x2c],r12
80009ba8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bac:	58 08       	cp.w	r8,0
80009bae:	c0 80       	breq	80009bbe <_vfprintf_r+0x1ece>
80009bb0:	fa ca f9 78 	sub	r10,sp,-1672
80009bb4:	02 9b       	mov	r11,r1
80009bb6:	08 9c       	mov	r12,r4
80009bb8:	fe b0 f0 8e 	rcall	80007cd4 <__sprint_r>
80009bbc:	c1 91       	brne	80009bee <_vfprintf_r+0x1efe>
80009bbe:	30 0b       	mov	r11,0
80009bc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bc4:	fb 4b 06 8c 	st.w	sp[1676],r11
80009bc8:	fe 9f f1 22 	bral	80007e0c <_vfprintf_r+0x11c>
80009bcc:	08 95       	mov	r5,r4
80009bce:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bd2:	58 08       	cp.w	r8,0
80009bd4:	c0 80       	breq	80009be4 <_vfprintf_r+0x1ef4>
80009bd6:	08 9c       	mov	r12,r4
80009bd8:	fa ca f9 78 	sub	r10,sp,-1672
80009bdc:	02 9b       	mov	r11,r1
80009bde:	fe b0 f0 7b 	rcall	80007cd4 <__sprint_r>
80009be2:	c0 61       	brne	80009bee <_vfprintf_r+0x1efe>
80009be4:	30 08       	mov	r8,0
80009be6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bea:	c0 28       	rjmp	80009bee <_vfprintf_r+0x1efe>
80009bec:	40 41       	lddsp	r1,sp[0x10]
80009bee:	82 68       	ld.sh	r8,r1[0xc]
80009bf0:	ed b8 00 06 	bld	r8,0x6
80009bf4:	c0 31       	brne	80009bfa <_vfprintf_r+0x1f0a>
80009bf6:	3f fa       	mov	r10,-1
80009bf8:	50 ba       	stdsp	sp[0x2c],r10
80009bfa:	40 bc       	lddsp	r12,sp[0x2c]
80009bfc:	fe 3d f9 44 	sub	sp,-1724
80009c00:	d8 32       	popm	r0-r7,pc
80009c02:	d7 03       	nop

80009c04 <__swsetup_r>:
80009c04:	d4 21       	pushm	r4-r7,lr
80009c06:	e0 68 0a 2c 	mov	r8,2604
80009c0a:	18 96       	mov	r6,r12
80009c0c:	16 97       	mov	r7,r11
80009c0e:	70 0c       	ld.w	r12,r8[0x0]
80009c10:	58 0c       	cp.w	r12,0
80009c12:	c0 60       	breq	80009c1e <__swsetup_r+0x1a>
80009c14:	78 68       	ld.w	r8,r12[0x18]
80009c16:	58 08       	cp.w	r8,0
80009c18:	c0 31       	brne	80009c1e <__swsetup_r+0x1a>
80009c1a:	e0 a0 07 bf 	rcall	8000ab98 <__sinit>
80009c1e:	fe c8 c0 6a 	sub	r8,pc,-16278
80009c22:	10 37       	cp.w	r7,r8
80009c24:	c0 61       	brne	80009c30 <__swsetup_r+0x2c>
80009c26:	e0 68 0a 2c 	mov	r8,2604
80009c2a:	70 08       	ld.w	r8,r8[0x0]
80009c2c:	70 07       	ld.w	r7,r8[0x0]
80009c2e:	c1 28       	rjmp	80009c52 <__swsetup_r+0x4e>
80009c30:	fe c8 c0 5c 	sub	r8,pc,-16292
80009c34:	10 37       	cp.w	r7,r8
80009c36:	c0 61       	brne	80009c42 <__swsetup_r+0x3e>
80009c38:	e0 68 0a 2c 	mov	r8,2604
80009c3c:	70 08       	ld.w	r8,r8[0x0]
80009c3e:	70 17       	ld.w	r7,r8[0x4]
80009c40:	c0 98       	rjmp	80009c52 <__swsetup_r+0x4e>
80009c42:	fe c8 c0 4e 	sub	r8,pc,-16306
80009c46:	10 37       	cp.w	r7,r8
80009c48:	c0 51       	brne	80009c52 <__swsetup_r+0x4e>
80009c4a:	e0 68 0a 2c 	mov	r8,2604
80009c4e:	70 08       	ld.w	r8,r8[0x0]
80009c50:	70 27       	ld.w	r7,r8[0x8]
80009c52:	8e 68       	ld.sh	r8,r7[0xc]
80009c54:	ed b8 00 03 	bld	r8,0x3
80009c58:	c1 e0       	breq	80009c94 <__swsetup_r+0x90>
80009c5a:	ed b8 00 04 	bld	r8,0x4
80009c5e:	c3 e1       	brne	80009cda <__swsetup_r+0xd6>
80009c60:	ed b8 00 02 	bld	r8,0x2
80009c64:	c1 51       	brne	80009c8e <__swsetup_r+0x8a>
80009c66:	6e db       	ld.w	r11,r7[0x34]
80009c68:	58 0b       	cp.w	r11,0
80009c6a:	c0 a0       	breq	80009c7e <__swsetup_r+0x7a>
80009c6c:	ee c8 ff bc 	sub	r8,r7,-68
80009c70:	10 3b       	cp.w	r11,r8
80009c72:	c0 40       	breq	80009c7a <__swsetup_r+0x76>
80009c74:	0c 9c       	mov	r12,r6
80009c76:	e0 a0 08 2b 	rcall	8000accc <_free_r>
80009c7a:	30 08       	mov	r8,0
80009c7c:	8f d8       	st.w	r7[0x34],r8
80009c7e:	8e 68       	ld.sh	r8,r7[0xc]
80009c80:	e0 18 ff db 	andl	r8,0xffdb
80009c84:	ae 68       	st.h	r7[0xc],r8
80009c86:	30 08       	mov	r8,0
80009c88:	8f 18       	st.w	r7[0x4],r8
80009c8a:	6e 48       	ld.w	r8,r7[0x10]
80009c8c:	8f 08       	st.w	r7[0x0],r8
80009c8e:	8e 68       	ld.sh	r8,r7[0xc]
80009c90:	a3 b8       	sbr	r8,0x3
80009c92:	ae 68       	st.h	r7[0xc],r8
80009c94:	6e 48       	ld.w	r8,r7[0x10]
80009c96:	58 08       	cp.w	r8,0
80009c98:	c0 b1       	brne	80009cae <__swsetup_r+0xaa>
80009c9a:	8e 68       	ld.sh	r8,r7[0xc]
80009c9c:	e2 18 02 80 	andl	r8,0x280,COH
80009ca0:	e0 48 02 00 	cp.w	r8,512
80009ca4:	c0 50       	breq	80009cae <__swsetup_r+0xaa>
80009ca6:	0c 9c       	mov	r12,r6
80009ca8:	0e 9b       	mov	r11,r7
80009caa:	e0 a0 0a 4b 	rcall	8000b140 <__smakebuf_r>
80009cae:	8e 69       	ld.sh	r9,r7[0xc]
80009cb0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009cb4:	c0 70       	breq	80009cc2 <__swsetup_r+0xbe>
80009cb6:	30 08       	mov	r8,0
80009cb8:	8f 28       	st.w	r7[0x8],r8
80009cba:	6e 58       	ld.w	r8,r7[0x14]
80009cbc:	5c 38       	neg	r8
80009cbe:	8f 68       	st.w	r7[0x18],r8
80009cc0:	c0 68       	rjmp	80009ccc <__swsetup_r+0xc8>
80009cc2:	ed b9 00 01 	bld	r9,0x1
80009cc6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009cca:	8f 28       	st.w	r7[0x8],r8
80009ccc:	6e 48       	ld.w	r8,r7[0x10]
80009cce:	58 08       	cp.w	r8,0
80009cd0:	c0 61       	brne	80009cdc <__swsetup_r+0xd8>
80009cd2:	8e 68       	ld.sh	r8,r7[0xc]
80009cd4:	ed b8 00 07 	bld	r8,0x7
80009cd8:	c0 21       	brne	80009cdc <__swsetup_r+0xd8>
80009cda:	dc 2a       	popm	r4-r7,pc,r12=-1
80009cdc:	d8 2a       	popm	r4-r7,pc,r12=0
80009cde:	d7 03       	nop

80009ce0 <quorem>:
80009ce0:	d4 31       	pushm	r0-r7,lr
80009ce2:	20 2d       	sub	sp,8
80009ce4:	18 97       	mov	r7,r12
80009ce6:	78 48       	ld.w	r8,r12[0x10]
80009ce8:	76 46       	ld.w	r6,r11[0x10]
80009cea:	0c 38       	cp.w	r8,r6
80009cec:	c0 34       	brge	80009cf2 <quorem+0x12>
80009cee:	30 0c       	mov	r12,0
80009cf0:	c8 58       	rjmp	80009dfa <quorem+0x11a>
80009cf2:	ec c2 ff fc 	sub	r2,r6,-4
80009cf6:	f6 c3 ff ec 	sub	r3,r11,-20
80009cfa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009cfe:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009d02:	2f f9       	sub	r9,-1
80009d04:	20 16       	sub	r6,1
80009d06:	f8 09 0d 08 	divu	r8,r12,r9
80009d0a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009d0e:	ee c4 ff ec 	sub	r4,r7,-20
80009d12:	10 95       	mov	r5,r8
80009d14:	58 08       	cp.w	r8,0
80009d16:	c4 10       	breq	80009d98 <quorem+0xb8>
80009d18:	30 09       	mov	r9,0
80009d1a:	06 9a       	mov	r10,r3
80009d1c:	08 98       	mov	r8,r4
80009d1e:	12 91       	mov	r1,r9
80009d20:	50 0b       	stdsp	sp[0x0],r11
80009d22:	70 0e       	ld.w	lr,r8[0x0]
80009d24:	b1 8e       	lsr	lr,0x10
80009d26:	50 1e       	stdsp	sp[0x4],lr
80009d28:	15 0e       	ld.w	lr,r10++
80009d2a:	fc 00 16 10 	lsr	r0,lr,0x10
80009d2e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009d32:	ea 0e 03 41 	mac	r1,r5,lr
80009d36:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009d3a:	b1 81       	lsr	r1,0x10
80009d3c:	40 1b       	lddsp	r11,sp[0x4]
80009d3e:	ea 00 02 40 	mul	r0,r5,r0
80009d42:	e2 00 00 00 	add	r0,r1,r0
80009d46:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009d4a:	02 1b       	sub	r11,r1
80009d4c:	50 1b       	stdsp	sp[0x4],r11
80009d4e:	70 0b       	ld.w	r11,r8[0x0]
80009d50:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009d54:	02 09       	add	r9,r1
80009d56:	f2 0e 01 0e 	sub	lr,r9,lr
80009d5a:	b0 1e       	st.h	r8[0x2],lr
80009d5c:	fc 09 14 10 	asr	r9,lr,0x10
80009d60:	40 1e       	lddsp	lr,sp[0x4]
80009d62:	fc 09 00 09 	add	r9,lr,r9
80009d66:	b0 09       	st.h	r8[0x0],r9
80009d68:	e0 01 16 10 	lsr	r1,r0,0x10
80009d6c:	2f c8       	sub	r8,-4
80009d6e:	b1 49       	asr	r9,0x10
80009d70:	04 3a       	cp.w	r10,r2
80009d72:	fe 98 ff d8 	brls	80009d22 <quorem+0x42>
80009d76:	40 0b       	lddsp	r11,sp[0x0]
80009d78:	58 0c       	cp.w	r12,0
80009d7a:	c0 f1       	brne	80009d98 <quorem+0xb8>
80009d7c:	ec c8 ff fb 	sub	r8,r6,-5
80009d80:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009d84:	c0 28       	rjmp	80009d88 <quorem+0xa8>
80009d86:	20 16       	sub	r6,1
80009d88:	20 48       	sub	r8,4
80009d8a:	08 38       	cp.w	r8,r4
80009d8c:	e0 88 00 05 	brls	80009d96 <quorem+0xb6>
80009d90:	70 09       	ld.w	r9,r8[0x0]
80009d92:	58 09       	cp.w	r9,0
80009d94:	cf 90       	breq	80009d86 <quorem+0xa6>
80009d96:	8f 46       	st.w	r7[0x10],r6
80009d98:	0e 9c       	mov	r12,r7
80009d9a:	e0 a0 0a d2 	rcall	8000b33e <__mcmp>
80009d9e:	c2 d5       	brlt	80009df8 <quorem+0x118>
80009da0:	2f f5       	sub	r5,-1
80009da2:	08 98       	mov	r8,r4
80009da4:	30 09       	mov	r9,0
80009da6:	07 0b       	ld.w	r11,r3++
80009da8:	f6 0a 16 10 	lsr	r10,r11,0x10
80009dac:	70 0c       	ld.w	r12,r8[0x0]
80009dae:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009db2:	f8 0e 16 10 	lsr	lr,r12,0x10
80009db6:	14 1e       	sub	lr,r10
80009db8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009dbc:	16 1a       	sub	r10,r11
80009dbe:	12 0a       	add	r10,r9
80009dc0:	b0 1a       	st.h	r8[0x2],r10
80009dc2:	b1 4a       	asr	r10,0x10
80009dc4:	fc 0a 00 09 	add	r9,lr,r10
80009dc8:	b0 09       	st.h	r8[0x0],r9
80009dca:	2f c8       	sub	r8,-4
80009dcc:	b1 49       	asr	r9,0x10
80009dce:	04 33       	cp.w	r3,r2
80009dd0:	fe 98 ff eb 	brls	80009da6 <quorem+0xc6>
80009dd4:	ec c8 ff fb 	sub	r8,r6,-5
80009dd8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009ddc:	58 09       	cp.w	r9,0
80009dde:	c0 d1       	brne	80009df8 <quorem+0x118>
80009de0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009de4:	c0 28       	rjmp	80009de8 <quorem+0x108>
80009de6:	20 16       	sub	r6,1
80009de8:	20 48       	sub	r8,4
80009dea:	08 38       	cp.w	r8,r4
80009dec:	e0 88 00 05 	brls	80009df6 <quorem+0x116>
80009df0:	70 09       	ld.w	r9,r8[0x0]
80009df2:	58 09       	cp.w	r9,0
80009df4:	cf 90       	breq	80009de6 <quorem+0x106>
80009df6:	8f 46       	st.w	r7[0x10],r6
80009df8:	0a 9c       	mov	r12,r5
80009dfa:	2f ed       	sub	sp,-8
80009dfc:	d8 32       	popm	r0-r7,pc
80009dfe:	d7 03       	nop

80009e00 <_dtoa_r>:
80009e00:	d4 31       	pushm	r0-r7,lr
80009e02:	21 ad       	sub	sp,104
80009e04:	fa c4 ff 74 	sub	r4,sp,-140
80009e08:	18 97       	mov	r7,r12
80009e0a:	16 95       	mov	r5,r11
80009e0c:	68 2c       	ld.w	r12,r4[0x8]
80009e0e:	50 c9       	stdsp	sp[0x30],r9
80009e10:	68 16       	ld.w	r6,r4[0x4]
80009e12:	68 09       	ld.w	r9,r4[0x0]
80009e14:	50 e8       	stdsp	sp[0x38],r8
80009e16:	14 94       	mov	r4,r10
80009e18:	51 2c       	stdsp	sp[0x48],r12
80009e1a:	fa e5 00 08 	st.d	sp[8],r4
80009e1e:	51 59       	stdsp	sp[0x54],r9
80009e20:	6e 95       	ld.w	r5,r7[0x24]
80009e22:	58 05       	cp.w	r5,0
80009e24:	c0 91       	brne	80009e36 <_dtoa_r+0x36>
80009e26:	31 0c       	mov	r12,16
80009e28:	fe b0 e8 f4 	rcall	80007010 <malloc>
80009e2c:	99 35       	st.w	r12[0xc],r5
80009e2e:	8f 9c       	st.w	r7[0x24],r12
80009e30:	99 15       	st.w	r12[0x4],r5
80009e32:	99 25       	st.w	r12[0x8],r5
80009e34:	99 05       	st.w	r12[0x0],r5
80009e36:	6e 99       	ld.w	r9,r7[0x24]
80009e38:	72 08       	ld.w	r8,r9[0x0]
80009e3a:	58 08       	cp.w	r8,0
80009e3c:	c0 f0       	breq	80009e5a <_dtoa_r+0x5a>
80009e3e:	72 1a       	ld.w	r10,r9[0x4]
80009e40:	91 1a       	st.w	r8[0x4],r10
80009e42:	30 1a       	mov	r10,1
80009e44:	72 19       	ld.w	r9,r9[0x4]
80009e46:	f4 09 09 49 	lsl	r9,r10,r9
80009e4a:	10 9b       	mov	r11,r8
80009e4c:	91 29       	st.w	r8[0x8],r9
80009e4e:	0e 9c       	mov	r12,r7
80009e50:	e0 a0 0a 90 	rcall	8000b370 <_Bfree>
80009e54:	6e 98       	ld.w	r8,r7[0x24]
80009e56:	30 09       	mov	r9,0
80009e58:	91 09       	st.w	r8[0x0],r9
80009e5a:	40 28       	lddsp	r8,sp[0x8]
80009e5c:	10 94       	mov	r4,r8
80009e5e:	58 08       	cp.w	r8,0
80009e60:	c0 64       	brge	80009e6c <_dtoa_r+0x6c>
80009e62:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009e66:	50 28       	stdsp	sp[0x8],r8
80009e68:	30 18       	mov	r8,1
80009e6a:	c0 28       	rjmp	80009e6e <_dtoa_r+0x6e>
80009e6c:	30 08       	mov	r8,0
80009e6e:	8d 08       	st.w	r6[0x0],r8
80009e70:	fc 1c 7f f0 	movh	r12,0x7ff0
80009e74:	40 26       	lddsp	r6,sp[0x8]
80009e76:	0c 98       	mov	r8,r6
80009e78:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009e7c:	18 38       	cp.w	r8,r12
80009e7e:	c2 01       	brne	80009ebe <_dtoa_r+0xbe>
80009e80:	e0 68 27 0f 	mov	r8,9999
80009e84:	41 5b       	lddsp	r11,sp[0x54]
80009e86:	97 08       	st.w	r11[0x0],r8
80009e88:	40 3a       	lddsp	r10,sp[0xc]
80009e8a:	58 0a       	cp.w	r10,0
80009e8c:	c0 71       	brne	80009e9a <_dtoa_r+0x9a>
80009e8e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009e92:	c0 41       	brne	80009e9a <_dtoa_r+0x9a>
80009e94:	fe cc c2 f0 	sub	r12,pc,-15632
80009e98:	c0 38       	rjmp	80009e9e <_dtoa_r+0x9e>
80009e9a:	fe cc c2 ea 	sub	r12,pc,-15638
80009e9e:	41 29       	lddsp	r9,sp[0x48]
80009ea0:	58 09       	cp.w	r9,0
80009ea2:	e0 80 05 9a 	breq	8000a9d6 <_dtoa_r+0xbd6>
80009ea6:	f8 c8 ff fd 	sub	r8,r12,-3
80009eaa:	f8 c9 ff f8 	sub	r9,r12,-8
80009eae:	11 8b       	ld.ub	r11,r8[0x0]
80009eb0:	30 0a       	mov	r10,0
80009eb2:	41 25       	lddsp	r5,sp[0x48]
80009eb4:	f4 0b 18 00 	cp.b	r11,r10
80009eb8:	f2 08 17 10 	movne	r8,r9
80009ebc:	c1 68       	rjmp	80009ee8 <_dtoa_r+0xe8>
80009ebe:	fa ea 00 08 	ld.d	r10,sp[8]
80009ec2:	30 08       	mov	r8,0
80009ec4:	fa eb 00 3c 	st.d	sp[60],r10
80009ec8:	30 09       	mov	r9,0
80009eca:	e0 a0 10 ce 	rcall	8000c066 <__avr32_f64_cmp_eq>
80009ece:	c1 00       	breq	80009eee <_dtoa_r+0xee>
80009ed0:	30 18       	mov	r8,1
80009ed2:	41 5a       	lddsp	r10,sp[0x54]
80009ed4:	95 08       	st.w	r10[0x0],r8
80009ed6:	fe cc c4 56 	sub	r12,pc,-15274
80009eda:	41 29       	lddsp	r9,sp[0x48]
80009edc:	f8 08 00 08 	add	r8,r12,r8
80009ee0:	58 09       	cp.w	r9,0
80009ee2:	e0 80 05 7a 	breq	8000a9d6 <_dtoa_r+0xbd6>
80009ee6:	12 95       	mov	r5,r9
80009ee8:	8b 08       	st.w	r5[0x0],r8
80009eea:	e0 8f 05 76 	bral	8000a9d6 <_dtoa_r+0xbd6>
80009eee:	fa c8 ff 9c 	sub	r8,sp,-100
80009ef2:	fa c9 ff a0 	sub	r9,sp,-96
80009ef6:	fa ea 00 3c 	ld.d	r10,sp[60]
80009efa:	0e 9c       	mov	r12,r7
80009efc:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009f00:	e0 a0 0a 8a 	rcall	8000b414 <__d2b>
80009f04:	18 93       	mov	r3,r12
80009f06:	58 05       	cp.w	r5,0
80009f08:	c0 d0       	breq	80009f22 <_dtoa_r+0x122>
80009f0a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f0e:	30 04       	mov	r4,0
80009f10:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009f14:	ea c5 03 ff 	sub	r5,r5,1023
80009f18:	10 9b       	mov	r11,r8
80009f1a:	51 74       	stdsp	sp[0x5c],r4
80009f1c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009f20:	c2 58       	rjmp	80009f6a <_dtoa_r+0x16a>
80009f22:	41 88       	lddsp	r8,sp[0x60]
80009f24:	41 9c       	lddsp	r12,sp[0x64]
80009f26:	10 0c       	add	r12,r8
80009f28:	f8 c5 fb ce 	sub	r5,r12,-1074
80009f2c:	e0 45 00 20 	cp.w	r5,32
80009f30:	e0 8a 00 0e 	brle	80009f4c <_dtoa_r+0x14c>
80009f34:	f8 cc fb ee 	sub	r12,r12,-1042
80009f38:	40 3b       	lddsp	r11,sp[0xc]
80009f3a:	ea 08 11 40 	rsub	r8,r5,64
80009f3e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009f42:	ec 08 09 46 	lsl	r6,r6,r8
80009f46:	0c 4c       	or	r12,r6
80009f48:	c0 78       	rjmp	80009f56 <_dtoa_r+0x156>
80009f4a:	d7 03       	nop
80009f4c:	ea 0c 11 20 	rsub	r12,r5,32
80009f50:	40 3a       	lddsp	r10,sp[0xc]
80009f52:	f4 0c 09 4c 	lsl	r12,r10,r12
80009f56:	e0 a0 10 14 	rcall	8000bf7e <__avr32_u32_to_f64>
80009f5a:	fc 18 fe 10 	movh	r8,0xfe10
80009f5e:	30 19       	mov	r9,1
80009f60:	ea c5 04 33 	sub	r5,r5,1075
80009f64:	f0 0b 00 0b 	add	r11,r8,r11
80009f68:	51 79       	stdsp	sp[0x5c],r9
80009f6a:	30 08       	mov	r8,0
80009f6c:	fc 19 3f f8 	movh	r9,0x3ff8
80009f70:	e0 a0 0e 9c 	rcall	8000bca8 <__avr32_f64_sub>
80009f74:	e0 68 43 61 	mov	r8,17249
80009f78:	ea 18 63 6f 	orh	r8,0x636f
80009f7c:	e0 69 87 a7 	mov	r9,34727
80009f80:	ea 19 3f d2 	orh	r9,0x3fd2
80009f84:	e0 a0 0d a6 	rcall	8000bad0 <__avr32_f64_mul>
80009f88:	e0 68 c8 b3 	mov	r8,51379
80009f8c:	ea 18 8b 60 	orh	r8,0x8b60
80009f90:	e0 69 8a 28 	mov	r9,35368
80009f94:	ea 19 3f c6 	orh	r9,0x3fc6
80009f98:	e0 a0 0f 56 	rcall	8000be44 <__avr32_f64_add>
80009f9c:	0a 9c       	mov	r12,r5
80009f9e:	14 90       	mov	r0,r10
80009fa0:	16 91       	mov	r1,r11
80009fa2:	e0 a0 0f f2 	rcall	8000bf86 <__avr32_s32_to_f64>
80009fa6:	e0 68 79 fb 	mov	r8,31227
80009faa:	ea 18 50 9f 	orh	r8,0x509f
80009fae:	e0 69 44 13 	mov	r9,17427
80009fb2:	ea 19 3f d3 	orh	r9,0x3fd3
80009fb6:	e0 a0 0d 8d 	rcall	8000bad0 <__avr32_f64_mul>
80009fba:	14 98       	mov	r8,r10
80009fbc:	16 99       	mov	r9,r11
80009fbe:	00 9a       	mov	r10,r0
80009fc0:	02 9b       	mov	r11,r1
80009fc2:	e0 a0 0f 41 	rcall	8000be44 <__avr32_f64_add>
80009fc6:	14 90       	mov	r0,r10
80009fc8:	16 91       	mov	r1,r11
80009fca:	e0 a0 0f c7 	rcall	8000bf58 <__avr32_f64_to_s32>
80009fce:	30 08       	mov	r8,0
80009fd0:	18 96       	mov	r6,r12
80009fd2:	30 09       	mov	r9,0
80009fd4:	00 9a       	mov	r10,r0
80009fd6:	02 9b       	mov	r11,r1
80009fd8:	e0 a0 10 8e 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
80009fdc:	c0 c0       	breq	80009ff4 <_dtoa_r+0x1f4>
80009fde:	0c 9c       	mov	r12,r6
80009fe0:	e0 a0 0f d3 	rcall	8000bf86 <__avr32_s32_to_f64>
80009fe4:	14 98       	mov	r8,r10
80009fe6:	16 99       	mov	r9,r11
80009fe8:	00 9a       	mov	r10,r0
80009fea:	02 9b       	mov	r11,r1
80009fec:	e0 a0 10 3d 	rcall	8000c066 <__avr32_f64_cmp_eq>
80009ff0:	f7 b6 00 01 	subeq	r6,1
80009ff4:	59 66       	cp.w	r6,22
80009ff6:	e0 88 00 05 	brls	8000a000 <_dtoa_r+0x200>
80009ffa:	30 18       	mov	r8,1
80009ffc:	51 48       	stdsp	sp[0x50],r8
80009ffe:	c1 38       	rjmp	8000a024 <_dtoa_r+0x224>
8000a000:	fe c8 c3 9c 	sub	r8,pc,-15460
8000a004:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a008:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a00c:	e0 a0 10 74 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a010:	f9 b4 00 00 	moveq	r4,0
8000a014:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a018:	f7 b6 01 01 	subne	r6,1
8000a01c:	f9 bc 01 00 	movne	r12,0
8000a020:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a024:	41 90       	lddsp	r0,sp[0x64]
8000a026:	20 10       	sub	r0,1
8000a028:	0a 10       	sub	r0,r5
8000a02a:	c0 46       	brmi	8000a032 <_dtoa_r+0x232>
8000a02c:	50 40       	stdsp	sp[0x10],r0
8000a02e:	30 00       	mov	r0,0
8000a030:	c0 48       	rjmp	8000a038 <_dtoa_r+0x238>
8000a032:	30 0b       	mov	r11,0
8000a034:	5c 30       	neg	r0
8000a036:	50 4b       	stdsp	sp[0x10],r11
8000a038:	ec 02 11 00 	rsub	r2,r6,0
8000a03c:	58 06       	cp.w	r6,0
8000a03e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a042:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a046:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a04a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a04e:	f9 b2 04 00 	movge	r2,0
8000a052:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a056:	f9 b9 05 00 	movlt	r9,0
8000a05a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a05e:	40 c8       	lddsp	r8,sp[0x30]
8000a060:	58 98       	cp.w	r8,9
8000a062:	e0 8b 00 20 	brhi	8000a0a2 <_dtoa_r+0x2a2>
8000a066:	58 58       	cp.w	r8,5
8000a068:	f9 b4 0a 01 	movle	r4,1
8000a06c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a070:	f7 b5 09 04 	subgt	r5,4
8000a074:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a078:	f9 b4 09 00 	movgt	r4,0
8000a07c:	40 cc       	lddsp	r12,sp[0x30]
8000a07e:	58 3c       	cp.w	r12,3
8000a080:	c2 d0       	breq	8000a0da <_dtoa_r+0x2da>
8000a082:	e0 89 00 05 	brgt	8000a08c <_dtoa_r+0x28c>
8000a086:	58 2c       	cp.w	r12,2
8000a088:	c1 01       	brne	8000a0a8 <_dtoa_r+0x2a8>
8000a08a:	c1 88       	rjmp	8000a0ba <_dtoa_r+0x2ba>
8000a08c:	40 cb       	lddsp	r11,sp[0x30]
8000a08e:	58 4b       	cp.w	r11,4
8000a090:	c0 60       	breq	8000a09c <_dtoa_r+0x29c>
8000a092:	58 5b       	cp.w	r11,5
8000a094:	c0 a1       	brne	8000a0a8 <_dtoa_r+0x2a8>
8000a096:	30 1a       	mov	r10,1
8000a098:	50 da       	stdsp	sp[0x34],r10
8000a09a:	c2 28       	rjmp	8000a0de <_dtoa_r+0x2de>
8000a09c:	30 19       	mov	r9,1
8000a09e:	50 d9       	stdsp	sp[0x34],r9
8000a0a0:	c0 f8       	rjmp	8000a0be <_dtoa_r+0x2be>
8000a0a2:	30 08       	mov	r8,0
8000a0a4:	30 14       	mov	r4,1
8000a0a6:	50 c8       	stdsp	sp[0x30],r8
8000a0a8:	3f f5       	mov	r5,-1
8000a0aa:	30 1c       	mov	r12,1
8000a0ac:	30 0b       	mov	r11,0
8000a0ae:	50 95       	stdsp	sp[0x24],r5
8000a0b0:	50 dc       	stdsp	sp[0x34],r12
8000a0b2:	0a 91       	mov	r1,r5
8000a0b4:	31 28       	mov	r8,18
8000a0b6:	50 eb       	stdsp	sp[0x38],r11
8000a0b8:	c2 08       	rjmp	8000a0f8 <_dtoa_r+0x2f8>
8000a0ba:	30 0a       	mov	r10,0
8000a0bc:	50 da       	stdsp	sp[0x34],r10
8000a0be:	40 e9       	lddsp	r9,sp[0x38]
8000a0c0:	58 09       	cp.w	r9,0
8000a0c2:	e0 89 00 07 	brgt	8000a0d0 <_dtoa_r+0x2d0>
8000a0c6:	30 18       	mov	r8,1
8000a0c8:	50 98       	stdsp	sp[0x24],r8
8000a0ca:	10 91       	mov	r1,r8
8000a0cc:	50 e8       	stdsp	sp[0x38],r8
8000a0ce:	c1 58       	rjmp	8000a0f8 <_dtoa_r+0x2f8>
8000a0d0:	40 e5       	lddsp	r5,sp[0x38]
8000a0d2:	50 95       	stdsp	sp[0x24],r5
8000a0d4:	0a 91       	mov	r1,r5
8000a0d6:	0a 98       	mov	r8,r5
8000a0d8:	c1 08       	rjmp	8000a0f8 <_dtoa_r+0x2f8>
8000a0da:	30 0c       	mov	r12,0
8000a0dc:	50 dc       	stdsp	sp[0x34],r12
8000a0de:	40 eb       	lddsp	r11,sp[0x38]
8000a0e0:	ec 0b 00 0b 	add	r11,r6,r11
8000a0e4:	50 9b       	stdsp	sp[0x24],r11
8000a0e6:	16 98       	mov	r8,r11
8000a0e8:	2f f8       	sub	r8,-1
8000a0ea:	58 08       	cp.w	r8,0
8000a0ec:	e0 89 00 05 	brgt	8000a0f6 <_dtoa_r+0x2f6>
8000a0f0:	10 91       	mov	r1,r8
8000a0f2:	30 18       	mov	r8,1
8000a0f4:	c0 28       	rjmp	8000a0f8 <_dtoa_r+0x2f8>
8000a0f6:	10 91       	mov	r1,r8
8000a0f8:	30 09       	mov	r9,0
8000a0fa:	6e 9a       	ld.w	r10,r7[0x24]
8000a0fc:	95 19       	st.w	r10[0x4],r9
8000a0fe:	30 49       	mov	r9,4
8000a100:	c0 68       	rjmp	8000a10c <_dtoa_r+0x30c>
8000a102:	d7 03       	nop
8000a104:	6a 1a       	ld.w	r10,r5[0x4]
8000a106:	a1 79       	lsl	r9,0x1
8000a108:	2f fa       	sub	r10,-1
8000a10a:	8b 1a       	st.w	r5[0x4],r10
8000a10c:	6e 95       	ld.w	r5,r7[0x24]
8000a10e:	f2 ca ff ec 	sub	r10,r9,-20
8000a112:	10 3a       	cp.w	r10,r8
8000a114:	fe 98 ff f8 	brls	8000a104 <_dtoa_r+0x304>
8000a118:	6a 1b       	ld.w	r11,r5[0x4]
8000a11a:	0e 9c       	mov	r12,r7
8000a11c:	e0 a0 09 44 	rcall	8000b3a4 <_Balloc>
8000a120:	58 e1       	cp.w	r1,14
8000a122:	5f 88       	srls	r8
8000a124:	8b 0c       	st.w	r5[0x0],r12
8000a126:	f1 e4 00 04 	and	r4,r8,r4
8000a12a:	6e 98       	ld.w	r8,r7[0x24]
8000a12c:	70 08       	ld.w	r8,r8[0x0]
8000a12e:	50 88       	stdsp	sp[0x20],r8
8000a130:	e0 80 01 82 	breq	8000a434 <_dtoa_r+0x634>
8000a134:	58 06       	cp.w	r6,0
8000a136:	e0 8a 00 43 	brle	8000a1bc <_dtoa_r+0x3bc>
8000a13a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a13e:	fe c8 c4 da 	sub	r8,pc,-15142
8000a142:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a146:	fa e5 00 18 	st.d	sp[24],r4
8000a14a:	ec 04 14 04 	asr	r4,r6,0x4
8000a14e:	ed b4 00 04 	bld	r4,0x4
8000a152:	c0 30       	breq	8000a158 <_dtoa_r+0x358>
8000a154:	30 25       	mov	r5,2
8000a156:	c1 08       	rjmp	8000a176 <_dtoa_r+0x376>
8000a158:	fe c8 c4 2c 	sub	r8,pc,-15316
8000a15c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a160:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a164:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a168:	e0 a0 0f fa 	rcall	8000c15c <__avr32_f64_div>
8000a16c:	30 35       	mov	r5,3
8000a16e:	14 98       	mov	r8,r10
8000a170:	16 99       	mov	r9,r11
8000a172:	fa e9 00 08 	st.d	sp[8],r8
8000a176:	fe cc c4 4a 	sub	r12,pc,-15286
8000a17a:	50 a3       	stdsp	sp[0x28],r3
8000a17c:	0c 93       	mov	r3,r6
8000a17e:	18 96       	mov	r6,r12
8000a180:	c0 f8       	rjmp	8000a19e <_dtoa_r+0x39e>
8000a182:	fa ea 00 18 	ld.d	r10,sp[24]
8000a186:	ed b4 00 00 	bld	r4,0x0
8000a18a:	c0 81       	brne	8000a19a <_dtoa_r+0x39a>
8000a18c:	ec e8 00 00 	ld.d	r8,r6[0]
8000a190:	2f f5       	sub	r5,-1
8000a192:	e0 a0 0c 9f 	rcall	8000bad0 <__avr32_f64_mul>
8000a196:	fa eb 00 18 	st.d	sp[24],r10
8000a19a:	a1 54       	asr	r4,0x1
8000a19c:	2f 86       	sub	r6,-8
8000a19e:	58 04       	cp.w	r4,0
8000a1a0:	cf 11       	brne	8000a182 <_dtoa_r+0x382>
8000a1a2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a1a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1aa:	06 96       	mov	r6,r3
8000a1ac:	e0 a0 0f d8 	rcall	8000c15c <__avr32_f64_div>
8000a1b0:	40 a3       	lddsp	r3,sp[0x28]
8000a1b2:	14 98       	mov	r8,r10
8000a1b4:	16 99       	mov	r9,r11
8000a1b6:	fa e9 00 08 	st.d	sp[8],r8
8000a1ba:	c2 f8       	rjmp	8000a218 <_dtoa_r+0x418>
8000a1bc:	ec 08 11 00 	rsub	r8,r6,0
8000a1c0:	c0 31       	brne	8000a1c6 <_dtoa_r+0x3c6>
8000a1c2:	30 25       	mov	r5,2
8000a1c4:	c2 a8       	rjmp	8000a218 <_dtoa_r+0x418>
8000a1c6:	fe cc c4 9a 	sub	r12,pc,-15206
8000a1ca:	f0 04 14 04 	asr	r4,r8,0x4
8000a1ce:	50 1c       	stdsp	sp[0x4],r12
8000a1d0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a1d4:	fe c9 c5 70 	sub	r9,pc,-14992
8000a1d8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1dc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a1e0:	e0 a0 0c 78 	rcall	8000bad0 <__avr32_f64_mul>
8000a1e4:	40 1c       	lddsp	r12,sp[0x4]
8000a1e6:	50 63       	stdsp	sp[0x18],r3
8000a1e8:	30 25       	mov	r5,2
8000a1ea:	0c 93       	mov	r3,r6
8000a1ec:	fa eb 00 08 	st.d	sp[8],r10
8000a1f0:	18 96       	mov	r6,r12
8000a1f2:	c0 f8       	rjmp	8000a210 <_dtoa_r+0x410>
8000a1f4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1f8:	ed b4 00 00 	bld	r4,0x0
8000a1fc:	c0 81       	brne	8000a20c <_dtoa_r+0x40c>
8000a1fe:	ec e8 00 00 	ld.d	r8,r6[0]
8000a202:	2f f5       	sub	r5,-1
8000a204:	e0 a0 0c 66 	rcall	8000bad0 <__avr32_f64_mul>
8000a208:	fa eb 00 08 	st.d	sp[8],r10
8000a20c:	a1 54       	asr	r4,0x1
8000a20e:	2f 86       	sub	r6,-8
8000a210:	58 04       	cp.w	r4,0
8000a212:	cf 11       	brne	8000a1f4 <_dtoa_r+0x3f4>
8000a214:	06 96       	mov	r6,r3
8000a216:	40 63       	lddsp	r3,sp[0x18]
8000a218:	41 4a       	lddsp	r10,sp[0x50]
8000a21a:	58 0a       	cp.w	r10,0
8000a21c:	c2 a0       	breq	8000a270 <_dtoa_r+0x470>
8000a21e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a222:	58 01       	cp.w	r1,0
8000a224:	5f 94       	srgt	r4
8000a226:	fa e9 00 18 	st.d	sp[24],r8
8000a22a:	30 08       	mov	r8,0
8000a22c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a230:	fa ea 00 18 	ld.d	r10,sp[24]
8000a234:	e0 a0 0f 60 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a238:	f9 bc 00 00 	moveq	r12,0
8000a23c:	f9 bc 01 01 	movne	r12,1
8000a240:	e9 ec 00 0c 	and	r12,r4,r12
8000a244:	c1 60       	breq	8000a270 <_dtoa_r+0x470>
8000a246:	40 98       	lddsp	r8,sp[0x24]
8000a248:	58 08       	cp.w	r8,0
8000a24a:	e0 8a 00 f1 	brle	8000a42c <_dtoa_r+0x62c>
8000a24e:	30 08       	mov	r8,0
8000a250:	fc 19 40 24 	movh	r9,0x4024
8000a254:	ec c4 00 01 	sub	r4,r6,1
8000a258:	fa ea 00 18 	ld.d	r10,sp[24]
8000a25c:	2f f5       	sub	r5,-1
8000a25e:	50 64       	stdsp	sp[0x18],r4
8000a260:	e0 a0 0c 38 	rcall	8000bad0 <__avr32_f64_mul>
8000a264:	40 94       	lddsp	r4,sp[0x24]
8000a266:	14 98       	mov	r8,r10
8000a268:	16 99       	mov	r9,r11
8000a26a:	fa e9 00 08 	st.d	sp[8],r8
8000a26e:	c0 38       	rjmp	8000a274 <_dtoa_r+0x474>
8000a270:	50 66       	stdsp	sp[0x18],r6
8000a272:	02 94       	mov	r4,r1
8000a274:	0a 9c       	mov	r12,r5
8000a276:	e0 a0 0e 88 	rcall	8000bf86 <__avr32_s32_to_f64>
8000a27a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a27e:	e0 a0 0c 29 	rcall	8000bad0 <__avr32_f64_mul>
8000a282:	30 08       	mov	r8,0
8000a284:	fc 19 40 1c 	movh	r9,0x401c
8000a288:	e0 a0 0d de 	rcall	8000be44 <__avr32_f64_add>
8000a28c:	14 98       	mov	r8,r10
8000a28e:	16 99       	mov	r9,r11
8000a290:	fa e9 00 28 	st.d	sp[40],r8
8000a294:	fc 18 fc c0 	movh	r8,0xfcc0
8000a298:	40 a5       	lddsp	r5,sp[0x28]
8000a29a:	10 05       	add	r5,r8
8000a29c:	50 a5       	stdsp	sp[0x28],r5
8000a29e:	58 04       	cp.w	r4,0
8000a2a0:	c2 11       	brne	8000a2e2 <_dtoa_r+0x4e2>
8000a2a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2a6:	30 08       	mov	r8,0
8000a2a8:	fc 19 40 14 	movh	r9,0x4014
8000a2ac:	e0 a0 0c fe 	rcall	8000bca8 <__avr32_f64_sub>
8000a2b0:	40 bc       	lddsp	r12,sp[0x2c]
8000a2b2:	fa eb 00 08 	st.d	sp[8],r10
8000a2b6:	14 98       	mov	r8,r10
8000a2b8:	16 99       	mov	r9,r11
8000a2ba:	18 9a       	mov	r10,r12
8000a2bc:	0a 9b       	mov	r11,r5
8000a2be:	e0 a0 0f 1b 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a2c2:	e0 81 02 54 	brne	8000a76a <_dtoa_r+0x96a>
8000a2c6:	0a 98       	mov	r8,r5
8000a2c8:	40 b9       	lddsp	r9,sp[0x2c]
8000a2ca:	ee 18 80 00 	eorh	r8,0x8000
8000a2ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2d2:	10 95       	mov	r5,r8
8000a2d4:	12 98       	mov	r8,r9
8000a2d6:	0a 99       	mov	r9,r5
8000a2d8:	e0 a0 0f 0e 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a2dc:	e0 81 02 3e 	brne	8000a758 <_dtoa_r+0x958>
8000a2e0:	ca 68       	rjmp	8000a42c <_dtoa_r+0x62c>
8000a2e2:	fe c9 c6 7e 	sub	r9,pc,-14722
8000a2e6:	e8 c8 00 01 	sub	r8,r4,1
8000a2ea:	40 d5       	lddsp	r5,sp[0x34]
8000a2ec:	58 05       	cp.w	r5,0
8000a2ee:	c4 f0       	breq	8000a38c <_dtoa_r+0x58c>
8000a2f0:	30 0c       	mov	r12,0
8000a2f2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a2f6:	51 3c       	stdsp	sp[0x4c],r12
8000a2f8:	30 0a       	mov	r10,0
8000a2fa:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a2fe:	e0 a0 0f 2f 	rcall	8000c15c <__avr32_f64_div>
8000a302:	fa e8 00 28 	ld.d	r8,sp[40]
8000a306:	40 85       	lddsp	r5,sp[0x20]
8000a308:	e0 a0 0c d0 	rcall	8000bca8 <__avr32_f64_sub>
8000a30c:	fa eb 00 28 	st.d	sp[40],r10
8000a310:	fa ea 00 08 	ld.d	r10,sp[8]
8000a314:	e0 a0 0e 22 	rcall	8000bf58 <__avr32_f64_to_s32>
8000a318:	51 6c       	stdsp	sp[0x58],r12
8000a31a:	e0 a0 0e 36 	rcall	8000bf86 <__avr32_s32_to_f64>
8000a31e:	14 98       	mov	r8,r10
8000a320:	16 99       	mov	r9,r11
8000a322:	fa ea 00 08 	ld.d	r10,sp[8]
8000a326:	e0 a0 0c c1 	rcall	8000bca8 <__avr32_f64_sub>
8000a32a:	fa eb 00 08 	st.d	sp[8],r10
8000a32e:	41 68       	lddsp	r8,sp[0x58]
8000a330:	2d 08       	sub	r8,-48
8000a332:	0a c8       	st.b	r5++,r8
8000a334:	41 39       	lddsp	r9,sp[0x4c]
8000a336:	2f f9       	sub	r9,-1
8000a338:	51 39       	stdsp	sp[0x4c],r9
8000a33a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a33e:	e0 a0 0e db 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a342:	e0 81 03 39 	brne	8000a9b4 <_dtoa_r+0xbb4>
8000a346:	fa e8 00 08 	ld.d	r8,sp[8]
8000a34a:	30 0a       	mov	r10,0
8000a34c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a350:	e0 a0 0c ac 	rcall	8000bca8 <__avr32_f64_sub>
8000a354:	fa e8 00 28 	ld.d	r8,sp[40]
8000a358:	e0 a0 0e ce 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a35c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a360:	30 08       	mov	r8,0
8000a362:	fc 19 40 24 	movh	r9,0x4024
8000a366:	e0 81 00 da 	brne	8000a51a <_dtoa_r+0x71a>
8000a36a:	41 3c       	lddsp	r12,sp[0x4c]
8000a36c:	08 3c       	cp.w	r12,r4
8000a36e:	c5 f4       	brge	8000a42c <_dtoa_r+0x62c>
8000a370:	e0 a0 0b b0 	rcall	8000bad0 <__avr32_f64_mul>
8000a374:	30 08       	mov	r8,0
8000a376:	fa eb 00 28 	st.d	sp[40],r10
8000a37a:	fc 19 40 24 	movh	r9,0x4024
8000a37e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a382:	e0 a0 0b a7 	rcall	8000bad0 <__avr32_f64_mul>
8000a386:	fa eb 00 08 	st.d	sp[8],r10
8000a38a:	cc 3b       	rjmp	8000a310 <_dtoa_r+0x510>
8000a38c:	40 85       	lddsp	r5,sp[0x20]
8000a38e:	08 05       	add	r5,r4
8000a390:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a394:	51 35       	stdsp	sp[0x4c],r5
8000a396:	fa e8 00 28 	ld.d	r8,sp[40]
8000a39a:	40 85       	lddsp	r5,sp[0x20]
8000a39c:	e0 a0 0b 9a 	rcall	8000bad0 <__avr32_f64_mul>
8000a3a0:	fa eb 00 28 	st.d	sp[40],r10
8000a3a4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3a8:	e0 a0 0d d8 	rcall	8000bf58 <__avr32_f64_to_s32>
8000a3ac:	51 6c       	stdsp	sp[0x58],r12
8000a3ae:	e0 a0 0d ec 	rcall	8000bf86 <__avr32_s32_to_f64>
8000a3b2:	14 98       	mov	r8,r10
8000a3b4:	16 99       	mov	r9,r11
8000a3b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3ba:	e0 a0 0c 77 	rcall	8000bca8 <__avr32_f64_sub>
8000a3be:	fa eb 00 08 	st.d	sp[8],r10
8000a3c2:	41 68       	lddsp	r8,sp[0x58]
8000a3c4:	2d 08       	sub	r8,-48
8000a3c6:	0a c8       	st.b	r5++,r8
8000a3c8:	41 3c       	lddsp	r12,sp[0x4c]
8000a3ca:	18 35       	cp.w	r5,r12
8000a3cc:	c2 81       	brne	8000a41c <_dtoa_r+0x61c>
8000a3ce:	30 08       	mov	r8,0
8000a3d0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a3d4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a3d8:	e0 a0 0d 36 	rcall	8000be44 <__avr32_f64_add>
8000a3dc:	40 85       	lddsp	r5,sp[0x20]
8000a3de:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3e2:	08 05       	add	r5,r4
8000a3e4:	e0 a0 0e 88 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a3e8:	e0 81 00 99 	brne	8000a51a <_dtoa_r+0x71a>
8000a3ec:	fa e8 00 28 	ld.d	r8,sp[40]
8000a3f0:	30 0a       	mov	r10,0
8000a3f2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a3f6:	e0 a0 0c 59 	rcall	8000bca8 <__avr32_f64_sub>
8000a3fa:	14 98       	mov	r8,r10
8000a3fc:	16 99       	mov	r9,r11
8000a3fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000a402:	e0 a0 0e 79 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a406:	c1 30       	breq	8000a42c <_dtoa_r+0x62c>
8000a408:	33 09       	mov	r9,48
8000a40a:	0a 98       	mov	r8,r5
8000a40c:	11 7a       	ld.ub	r10,--r8
8000a40e:	f2 0a 18 00 	cp.b	r10,r9
8000a412:	e0 81 02 d1 	brne	8000a9b4 <_dtoa_r+0xbb4>
8000a416:	10 95       	mov	r5,r8
8000a418:	cf 9b       	rjmp	8000a40a <_dtoa_r+0x60a>
8000a41a:	d7 03       	nop
8000a41c:	30 08       	mov	r8,0
8000a41e:	fc 19 40 24 	movh	r9,0x4024
8000a422:	e0 a0 0b 57 	rcall	8000bad0 <__avr32_f64_mul>
8000a426:	fa eb 00 08 	st.d	sp[8],r10
8000a42a:	cb db       	rjmp	8000a3a4 <_dtoa_r+0x5a4>
8000a42c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a430:	fa eb 00 08 	st.d	sp[8],r10
8000a434:	58 e6       	cp.w	r6,14
8000a436:	5f ab       	srle	r11
8000a438:	41 8a       	lddsp	r10,sp[0x60]
8000a43a:	30 08       	mov	r8,0
8000a43c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a440:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a444:	f0 09 18 00 	cp.b	r9,r8
8000a448:	e0 80 00 82 	breq	8000a54c <_dtoa_r+0x74c>
8000a44c:	40 ea       	lddsp	r10,sp[0x38]
8000a44e:	58 01       	cp.w	r1,0
8000a450:	5f a9       	srle	r9
8000a452:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a456:	fe ca c7 f2 	sub	r10,pc,-14350
8000a45a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a45e:	fa e5 00 10 	st.d	sp[16],r4
8000a462:	f0 09 18 00 	cp.b	r9,r8
8000a466:	c1 40       	breq	8000a48e <_dtoa_r+0x68e>
8000a468:	58 01       	cp.w	r1,0
8000a46a:	e0 81 01 77 	brne	8000a758 <_dtoa_r+0x958>
8000a46e:	30 08       	mov	r8,0
8000a470:	fc 19 40 14 	movh	r9,0x4014
8000a474:	08 9a       	mov	r10,r4
8000a476:	0a 9b       	mov	r11,r5
8000a478:	e0 a0 0b 2c 	rcall	8000bad0 <__avr32_f64_mul>
8000a47c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a480:	e0 a0 0e 06 	rcall	8000c08c <__avr32_f64_cmp_ge>
8000a484:	e0 81 01 6a 	brne	8000a758 <_dtoa_r+0x958>
8000a488:	02 92       	mov	r2,r1
8000a48a:	e0 8f 01 72 	bral	8000a76e <_dtoa_r+0x96e>
8000a48e:	40 85       	lddsp	r5,sp[0x20]
8000a490:	30 14       	mov	r4,1
8000a492:	fa e8 00 10 	ld.d	r8,sp[16]
8000a496:	fa ea 00 08 	ld.d	r10,sp[8]
8000a49a:	e0 a0 0e 61 	rcall	8000c15c <__avr32_f64_div>
8000a49e:	e0 a0 0d 5d 	rcall	8000bf58 <__avr32_f64_to_s32>
8000a4a2:	18 92       	mov	r2,r12
8000a4a4:	e0 a0 0d 71 	rcall	8000bf86 <__avr32_s32_to_f64>
8000a4a8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a4ac:	e0 a0 0b 12 	rcall	8000bad0 <__avr32_f64_mul>
8000a4b0:	14 98       	mov	r8,r10
8000a4b2:	16 99       	mov	r9,r11
8000a4b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4b8:	e0 a0 0b f8 	rcall	8000bca8 <__avr32_f64_sub>
8000a4bc:	fa eb 00 08 	st.d	sp[8],r10
8000a4c0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a4c4:	0a c8       	st.b	r5++,r8
8000a4c6:	fc 19 40 24 	movh	r9,0x4024
8000a4ca:	30 08       	mov	r8,0
8000a4cc:	02 34       	cp.w	r4,r1
8000a4ce:	c3 31       	brne	8000a534 <_dtoa_r+0x734>
8000a4d0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4d4:	e0 a0 0c b8 	rcall	8000be44 <__avr32_f64_add>
8000a4d8:	16 91       	mov	r1,r11
8000a4da:	14 90       	mov	r0,r10
8000a4dc:	14 98       	mov	r8,r10
8000a4de:	02 99       	mov	r9,r1
8000a4e0:	fa ea 00 10 	ld.d	r10,sp[16]
8000a4e4:	e0 a0 0e 08 	rcall	8000c0f4 <__avr32_f64_cmp_lt>
8000a4e8:	c1 a1       	brne	8000a51c <_dtoa_r+0x71c>
8000a4ea:	fa e8 00 10 	ld.d	r8,sp[16]
8000a4ee:	00 9a       	mov	r10,r0
8000a4f0:	02 9b       	mov	r11,r1
8000a4f2:	e0 a0 0d ba 	rcall	8000c066 <__avr32_f64_cmp_eq>
8000a4f6:	e0 80 02 5e 	breq	8000a9b2 <_dtoa_r+0xbb2>
8000a4fa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a4fe:	c0 f1       	brne	8000a51c <_dtoa_r+0x71c>
8000a500:	e0 8f 02 59 	bral	8000a9b2 <_dtoa_r+0xbb2>
8000a504:	40 8a       	lddsp	r10,sp[0x20]
8000a506:	14 38       	cp.w	r8,r10
8000a508:	c0 30       	breq	8000a50e <_dtoa_r+0x70e>
8000a50a:	10 95       	mov	r5,r8
8000a50c:	c0 98       	rjmp	8000a51e <_dtoa_r+0x71e>
8000a50e:	33 08       	mov	r8,48
8000a510:	40 89       	lddsp	r9,sp[0x20]
8000a512:	2f f6       	sub	r6,-1
8000a514:	b2 88       	st.b	r9[0x0],r8
8000a516:	40 88       	lddsp	r8,sp[0x20]
8000a518:	c0 88       	rjmp	8000a528 <_dtoa_r+0x728>
8000a51a:	40 66       	lddsp	r6,sp[0x18]
8000a51c:	33 99       	mov	r9,57
8000a51e:	0a 98       	mov	r8,r5
8000a520:	11 7a       	ld.ub	r10,--r8
8000a522:	f2 0a 18 00 	cp.b	r10,r9
8000a526:	ce f0       	breq	8000a504 <_dtoa_r+0x704>
8000a528:	50 66       	stdsp	sp[0x18],r6
8000a52a:	11 89       	ld.ub	r9,r8[0x0]
8000a52c:	2f f9       	sub	r9,-1
8000a52e:	b0 89       	st.b	r8[0x0],r9
8000a530:	e0 8f 02 42 	bral	8000a9b4 <_dtoa_r+0xbb4>
8000a534:	e0 a0 0a ce 	rcall	8000bad0 <__avr32_f64_mul>
8000a538:	2f f4       	sub	r4,-1
8000a53a:	fa eb 00 08 	st.d	sp[8],r10
8000a53e:	30 08       	mov	r8,0
8000a540:	30 09       	mov	r9,0
8000a542:	e0 a0 0d 92 	rcall	8000c066 <__avr32_f64_cmp_eq>
8000a546:	ca 60       	breq	8000a492 <_dtoa_r+0x692>
8000a548:	e0 8f 02 35 	bral	8000a9b2 <_dtoa_r+0xbb2>
8000a54c:	40 d8       	lddsp	r8,sp[0x34]
8000a54e:	58 08       	cp.w	r8,0
8000a550:	c0 51       	brne	8000a55a <_dtoa_r+0x75a>
8000a552:	04 98       	mov	r8,r2
8000a554:	00 95       	mov	r5,r0
8000a556:	40 d4       	lddsp	r4,sp[0x34]
8000a558:	c3 78       	rjmp	8000a5c6 <_dtoa_r+0x7c6>
8000a55a:	40 c5       	lddsp	r5,sp[0x30]
8000a55c:	58 15       	cp.w	r5,1
8000a55e:	e0 89 00 0f 	brgt	8000a57c <_dtoa_r+0x77c>
8000a562:	41 74       	lddsp	r4,sp[0x5c]
8000a564:	58 04       	cp.w	r4,0
8000a566:	c0 40       	breq	8000a56e <_dtoa_r+0x76e>
8000a568:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a56c:	c0 48       	rjmp	8000a574 <_dtoa_r+0x774>
8000a56e:	41 99       	lddsp	r9,sp[0x64]
8000a570:	f2 09 11 36 	rsub	r9,r9,54
8000a574:	04 98       	mov	r8,r2
8000a576:	00 95       	mov	r5,r0
8000a578:	c1 c8       	rjmp	8000a5b0 <_dtoa_r+0x7b0>
8000a57a:	d7 03       	nop
8000a57c:	e2 c8 00 01 	sub	r8,r1,1
8000a580:	58 01       	cp.w	r1,0
8000a582:	e0 05 17 40 	movge	r5,r0
8000a586:	e2 09 17 40 	movge	r9,r1
8000a58a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a58e:	f9 b9 05 00 	movlt	r9,0
8000a592:	10 32       	cp.w	r2,r8
8000a594:	e5 d8 e4 18 	subge	r8,r2,r8
8000a598:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a59c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a5a0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a5a4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a5a8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a5ac:	f9 b8 05 00 	movlt	r8,0
8000a5b0:	40 4b       	lddsp	r11,sp[0x10]
8000a5b2:	12 0b       	add	r11,r9
8000a5b4:	50 08       	stdsp	sp[0x0],r8
8000a5b6:	50 4b       	stdsp	sp[0x10],r11
8000a5b8:	12 00       	add	r0,r9
8000a5ba:	30 1b       	mov	r11,1
8000a5bc:	0e 9c       	mov	r12,r7
8000a5be:	e0 a0 08 a7 	rcall	8000b70c <__i2b>
8000a5c2:	40 08       	lddsp	r8,sp[0x0]
8000a5c4:	18 94       	mov	r4,r12
8000a5c6:	40 4a       	lddsp	r10,sp[0x10]
8000a5c8:	58 05       	cp.w	r5,0
8000a5ca:	5f 99       	srgt	r9
8000a5cc:	58 0a       	cp.w	r10,0
8000a5ce:	5f 9a       	srgt	r10
8000a5d0:	f5 e9 00 09 	and	r9,r10,r9
8000a5d4:	c0 80       	breq	8000a5e4 <_dtoa_r+0x7e4>
8000a5d6:	40 4c       	lddsp	r12,sp[0x10]
8000a5d8:	f8 05 0d 49 	min	r9,r12,r5
8000a5dc:	12 1c       	sub	r12,r9
8000a5de:	12 10       	sub	r0,r9
8000a5e0:	50 4c       	stdsp	sp[0x10],r12
8000a5e2:	12 15       	sub	r5,r9
8000a5e4:	58 02       	cp.w	r2,0
8000a5e6:	e0 8a 00 27 	brle	8000a634 <_dtoa_r+0x834>
8000a5ea:	40 db       	lddsp	r11,sp[0x34]
8000a5ec:	58 0b       	cp.w	r11,0
8000a5ee:	c1 d0       	breq	8000a628 <_dtoa_r+0x828>
8000a5f0:	58 08       	cp.w	r8,0
8000a5f2:	e0 8a 00 17 	brle	8000a620 <_dtoa_r+0x820>
8000a5f6:	10 9a       	mov	r10,r8
8000a5f8:	50 08       	stdsp	sp[0x0],r8
8000a5fa:	08 9b       	mov	r11,r4
8000a5fc:	0e 9c       	mov	r12,r7
8000a5fe:	e0 a0 08 cd 	rcall	8000b798 <__pow5mult>
8000a602:	06 9a       	mov	r10,r3
8000a604:	18 9b       	mov	r11,r12
8000a606:	18 94       	mov	r4,r12
8000a608:	0e 9c       	mov	r12,r7
8000a60a:	e0 a0 08 01 	rcall	8000b60c <__multiply>
8000a60e:	18 99       	mov	r9,r12
8000a610:	06 9b       	mov	r11,r3
8000a612:	50 19       	stdsp	sp[0x4],r9
8000a614:	0e 9c       	mov	r12,r7
8000a616:	e0 a0 06 ad 	rcall	8000b370 <_Bfree>
8000a61a:	40 19       	lddsp	r9,sp[0x4]
8000a61c:	40 08       	lddsp	r8,sp[0x0]
8000a61e:	12 93       	mov	r3,r9
8000a620:	e4 08 01 0a 	sub	r10,r2,r8
8000a624:	c0 80       	breq	8000a634 <_dtoa_r+0x834>
8000a626:	c0 28       	rjmp	8000a62a <_dtoa_r+0x82a>
8000a628:	04 9a       	mov	r10,r2
8000a62a:	06 9b       	mov	r11,r3
8000a62c:	0e 9c       	mov	r12,r7
8000a62e:	e0 a0 08 b5 	rcall	8000b798 <__pow5mult>
8000a632:	18 93       	mov	r3,r12
8000a634:	30 1b       	mov	r11,1
8000a636:	0e 9c       	mov	r12,r7
8000a638:	e0 a0 08 6a 	rcall	8000b70c <__i2b>
8000a63c:	41 1a       	lddsp	r10,sp[0x44]
8000a63e:	18 92       	mov	r2,r12
8000a640:	58 0a       	cp.w	r10,0
8000a642:	e0 8a 00 07 	brle	8000a650 <_dtoa_r+0x850>
8000a646:	18 9b       	mov	r11,r12
8000a648:	0e 9c       	mov	r12,r7
8000a64a:	e0 a0 08 a7 	rcall	8000b798 <__pow5mult>
8000a64e:	18 92       	mov	r2,r12
8000a650:	40 c9       	lddsp	r9,sp[0x30]
8000a652:	58 19       	cp.w	r9,1
8000a654:	e0 89 00 14 	brgt	8000a67c <_dtoa_r+0x87c>
8000a658:	40 38       	lddsp	r8,sp[0xc]
8000a65a:	58 08       	cp.w	r8,0
8000a65c:	c1 01       	brne	8000a67c <_dtoa_r+0x87c>
8000a65e:	40 29       	lddsp	r9,sp[0x8]
8000a660:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a664:	c0 c1       	brne	8000a67c <_dtoa_r+0x87c>
8000a666:	12 98       	mov	r8,r9
8000a668:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a66c:	c0 80       	breq	8000a67c <_dtoa_r+0x87c>
8000a66e:	40 4c       	lddsp	r12,sp[0x10]
8000a670:	30 1b       	mov	r11,1
8000a672:	2f fc       	sub	r12,-1
8000a674:	2f f0       	sub	r0,-1
8000a676:	50 4c       	stdsp	sp[0x10],r12
8000a678:	50 6b       	stdsp	sp[0x18],r11
8000a67a:	c0 38       	rjmp	8000a680 <_dtoa_r+0x880>
8000a67c:	30 0a       	mov	r10,0
8000a67e:	50 6a       	stdsp	sp[0x18],r10
8000a680:	41 19       	lddsp	r9,sp[0x44]
8000a682:	58 09       	cp.w	r9,0
8000a684:	c0 31       	brne	8000a68a <_dtoa_r+0x88a>
8000a686:	30 1c       	mov	r12,1
8000a688:	c0 98       	rjmp	8000a69a <_dtoa_r+0x89a>
8000a68a:	64 48       	ld.w	r8,r2[0x10]
8000a68c:	2f c8       	sub	r8,-4
8000a68e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a692:	e0 a0 05 df 	rcall	8000b250 <__hi0bits>
8000a696:	f8 0c 11 20 	rsub	r12,r12,32
8000a69a:	40 4b       	lddsp	r11,sp[0x10]
8000a69c:	f8 0b 00 08 	add	r8,r12,r11
8000a6a0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a6a4:	c0 c0       	breq	8000a6bc <_dtoa_r+0x8bc>
8000a6a6:	f0 08 11 20 	rsub	r8,r8,32
8000a6aa:	58 48       	cp.w	r8,4
8000a6ac:	e0 8a 00 06 	brle	8000a6b8 <_dtoa_r+0x8b8>
8000a6b0:	20 48       	sub	r8,4
8000a6b2:	10 0b       	add	r11,r8
8000a6b4:	50 4b       	stdsp	sp[0x10],r11
8000a6b6:	c0 78       	rjmp	8000a6c4 <_dtoa_r+0x8c4>
8000a6b8:	58 48       	cp.w	r8,4
8000a6ba:	c0 70       	breq	8000a6c8 <_dtoa_r+0x8c8>
8000a6bc:	40 4a       	lddsp	r10,sp[0x10]
8000a6be:	2e 48       	sub	r8,-28
8000a6c0:	10 0a       	add	r10,r8
8000a6c2:	50 4a       	stdsp	sp[0x10],r10
8000a6c4:	10 00       	add	r0,r8
8000a6c6:	10 05       	add	r5,r8
8000a6c8:	58 00       	cp.w	r0,0
8000a6ca:	e0 8a 00 08 	brle	8000a6da <_dtoa_r+0x8da>
8000a6ce:	06 9b       	mov	r11,r3
8000a6d0:	00 9a       	mov	r10,r0
8000a6d2:	0e 9c       	mov	r12,r7
8000a6d4:	e0 a0 07 58 	rcall	8000b584 <__lshift>
8000a6d8:	18 93       	mov	r3,r12
8000a6da:	40 49       	lddsp	r9,sp[0x10]
8000a6dc:	58 09       	cp.w	r9,0
8000a6de:	e0 8a 00 08 	brle	8000a6ee <_dtoa_r+0x8ee>
8000a6e2:	04 9b       	mov	r11,r2
8000a6e4:	12 9a       	mov	r10,r9
8000a6e6:	0e 9c       	mov	r12,r7
8000a6e8:	e0 a0 07 4e 	rcall	8000b584 <__lshift>
8000a6ec:	18 92       	mov	r2,r12
8000a6ee:	41 48       	lddsp	r8,sp[0x50]
8000a6f0:	58 08       	cp.w	r8,0
8000a6f2:	c1 b0       	breq	8000a728 <_dtoa_r+0x928>
8000a6f4:	04 9b       	mov	r11,r2
8000a6f6:	06 9c       	mov	r12,r3
8000a6f8:	e0 a0 06 23 	rcall	8000b33e <__mcmp>
8000a6fc:	c1 64       	brge	8000a728 <_dtoa_r+0x928>
8000a6fe:	06 9b       	mov	r11,r3
8000a700:	30 09       	mov	r9,0
8000a702:	30 aa       	mov	r10,10
8000a704:	0e 9c       	mov	r12,r7
8000a706:	e0 a0 08 0b 	rcall	8000b71c <__multadd>
8000a70a:	20 16       	sub	r6,1
8000a70c:	18 93       	mov	r3,r12
8000a70e:	40 dc       	lddsp	r12,sp[0x34]
8000a710:	58 0c       	cp.w	r12,0
8000a712:	c0 31       	brne	8000a718 <_dtoa_r+0x918>
8000a714:	40 91       	lddsp	r1,sp[0x24]
8000a716:	c0 98       	rjmp	8000a728 <_dtoa_r+0x928>
8000a718:	08 9b       	mov	r11,r4
8000a71a:	40 91       	lddsp	r1,sp[0x24]
8000a71c:	30 09       	mov	r9,0
8000a71e:	30 aa       	mov	r10,10
8000a720:	0e 9c       	mov	r12,r7
8000a722:	e0 a0 07 fd 	rcall	8000b71c <__multadd>
8000a726:	18 94       	mov	r4,r12
8000a728:	58 01       	cp.w	r1,0
8000a72a:	5f a9       	srle	r9
8000a72c:	40 cb       	lddsp	r11,sp[0x30]
8000a72e:	58 2b       	cp.w	r11,2
8000a730:	5f 98       	srgt	r8
8000a732:	f3 e8 00 08 	and	r8,r9,r8
8000a736:	c2 50       	breq	8000a780 <_dtoa_r+0x980>
8000a738:	58 01       	cp.w	r1,0
8000a73a:	c1 11       	brne	8000a75c <_dtoa_r+0x95c>
8000a73c:	04 9b       	mov	r11,r2
8000a73e:	02 99       	mov	r9,r1
8000a740:	30 5a       	mov	r10,5
8000a742:	0e 9c       	mov	r12,r7
8000a744:	e0 a0 07 ec 	rcall	8000b71c <__multadd>
8000a748:	18 92       	mov	r2,r12
8000a74a:	18 9b       	mov	r11,r12
8000a74c:	06 9c       	mov	r12,r3
8000a74e:	e0 a0 05 f8 	rcall	8000b33e <__mcmp>
8000a752:	e0 89 00 0f 	brgt	8000a770 <_dtoa_r+0x970>
8000a756:	c0 38       	rjmp	8000a75c <_dtoa_r+0x95c>
8000a758:	30 02       	mov	r2,0
8000a75a:	04 94       	mov	r4,r2
8000a75c:	40 ea       	lddsp	r10,sp[0x38]
8000a75e:	30 09       	mov	r9,0
8000a760:	5c da       	com	r10
8000a762:	40 85       	lddsp	r5,sp[0x20]
8000a764:	50 6a       	stdsp	sp[0x18],r10
8000a766:	50 49       	stdsp	sp[0x10],r9
8000a768:	c0 f9       	rjmp	8000a986 <_dtoa_r+0xb86>
8000a76a:	08 92       	mov	r2,r4
8000a76c:	40 66       	lddsp	r6,sp[0x18]
8000a76e:	04 94       	mov	r4,r2
8000a770:	2f f6       	sub	r6,-1
8000a772:	50 66       	stdsp	sp[0x18],r6
8000a774:	33 18       	mov	r8,49
8000a776:	40 85       	lddsp	r5,sp[0x20]
8000a778:	0a c8       	st.b	r5++,r8
8000a77a:	30 08       	mov	r8,0
8000a77c:	50 48       	stdsp	sp[0x10],r8
8000a77e:	c0 49       	rjmp	8000a986 <_dtoa_r+0xb86>
8000a780:	40 dc       	lddsp	r12,sp[0x34]
8000a782:	58 0c       	cp.w	r12,0
8000a784:	e0 80 00 b5 	breq	8000a8ee <_dtoa_r+0xaee>
8000a788:	58 05       	cp.w	r5,0
8000a78a:	e0 8a 00 08 	brle	8000a79a <_dtoa_r+0x99a>
8000a78e:	08 9b       	mov	r11,r4
8000a790:	0a 9a       	mov	r10,r5
8000a792:	0e 9c       	mov	r12,r7
8000a794:	e0 a0 06 f8 	rcall	8000b584 <__lshift>
8000a798:	18 94       	mov	r4,r12
8000a79a:	40 6b       	lddsp	r11,sp[0x18]
8000a79c:	58 0b       	cp.w	r11,0
8000a79e:	c0 31       	brne	8000a7a4 <_dtoa_r+0x9a4>
8000a7a0:	08 9c       	mov	r12,r4
8000a7a2:	c1 38       	rjmp	8000a7c8 <_dtoa_r+0x9c8>
8000a7a4:	68 1b       	ld.w	r11,r4[0x4]
8000a7a6:	0e 9c       	mov	r12,r7
8000a7a8:	e0 a0 05 fe 	rcall	8000b3a4 <_Balloc>
8000a7ac:	68 4a       	ld.w	r10,r4[0x10]
8000a7ae:	18 95       	mov	r5,r12
8000a7b0:	e8 cb ff f4 	sub	r11,r4,-12
8000a7b4:	2f ea       	sub	r10,-2
8000a7b6:	2f 4c       	sub	r12,-12
8000a7b8:	a3 6a       	lsl	r10,0x2
8000a7ba:	fe b0 e6 4f 	rcall	80007458 <memcpy>
8000a7be:	0a 9b       	mov	r11,r5
8000a7c0:	30 1a       	mov	r10,1
8000a7c2:	0e 9c       	mov	r12,r7
8000a7c4:	e0 a0 06 e0 	rcall	8000b584 <__lshift>
8000a7c8:	50 44       	stdsp	sp[0x10],r4
8000a7ca:	40 3a       	lddsp	r10,sp[0xc]
8000a7cc:	30 19       	mov	r9,1
8000a7ce:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a7d2:	18 94       	mov	r4,r12
8000a7d4:	50 da       	stdsp	sp[0x34],r10
8000a7d6:	40 85       	lddsp	r5,sp[0x20]
8000a7d8:	50 99       	stdsp	sp[0x24],r9
8000a7da:	50 26       	stdsp	sp[0x8],r6
8000a7dc:	50 e1       	stdsp	sp[0x38],r1
8000a7de:	04 9b       	mov	r11,r2
8000a7e0:	06 9c       	mov	r12,r3
8000a7e2:	fe b0 fa 7f 	rcall	80009ce0 <quorem>
8000a7e6:	40 4b       	lddsp	r11,sp[0x10]
8000a7e8:	f8 c0 ff d0 	sub	r0,r12,-48
8000a7ec:	06 9c       	mov	r12,r3
8000a7ee:	e0 a0 05 a8 	rcall	8000b33e <__mcmp>
8000a7f2:	08 9a       	mov	r10,r4
8000a7f4:	50 6c       	stdsp	sp[0x18],r12
8000a7f6:	04 9b       	mov	r11,r2
8000a7f8:	0e 9c       	mov	r12,r7
8000a7fa:	e0 a0 06 5d 	rcall	8000b4b4 <__mdiff>
8000a7fe:	18 91       	mov	r1,r12
8000a800:	78 38       	ld.w	r8,r12[0xc]
8000a802:	58 08       	cp.w	r8,0
8000a804:	c0 30       	breq	8000a80a <_dtoa_r+0xa0a>
8000a806:	30 16       	mov	r6,1
8000a808:	c0 68       	rjmp	8000a814 <_dtoa_r+0xa14>
8000a80a:	18 9b       	mov	r11,r12
8000a80c:	06 9c       	mov	r12,r3
8000a80e:	e0 a0 05 98 	rcall	8000b33e <__mcmp>
8000a812:	18 96       	mov	r6,r12
8000a814:	0e 9c       	mov	r12,r7
8000a816:	02 9b       	mov	r11,r1
8000a818:	e0 a0 05 ac 	rcall	8000b370 <_Bfree>
8000a81c:	40 cc       	lddsp	r12,sp[0x30]
8000a81e:	ed ec 10 08 	or	r8,r6,r12
8000a822:	c0 d1       	brne	8000a83c <_dtoa_r+0xa3c>
8000a824:	40 db       	lddsp	r11,sp[0x34]
8000a826:	58 0b       	cp.w	r11,0
8000a828:	c0 a1       	brne	8000a83c <_dtoa_r+0xa3c>
8000a82a:	40 26       	lddsp	r6,sp[0x8]
8000a82c:	e0 40 00 39 	cp.w	r0,57
8000a830:	c3 00       	breq	8000a890 <_dtoa_r+0xa90>
8000a832:	40 6a       	lddsp	r10,sp[0x18]
8000a834:	58 0a       	cp.w	r10,0
8000a836:	e0 89 00 24 	brgt	8000a87e <_dtoa_r+0xa7e>
8000a83a:	c2 f8       	rjmp	8000a898 <_dtoa_r+0xa98>
8000a83c:	40 69       	lddsp	r9,sp[0x18]
8000a83e:	58 09       	cp.w	r9,0
8000a840:	c0 85       	brlt	8000a850 <_dtoa_r+0xa50>
8000a842:	12 98       	mov	r8,r9
8000a844:	40 cc       	lddsp	r12,sp[0x30]
8000a846:	18 48       	or	r8,r12
8000a848:	c1 d1       	brne	8000a882 <_dtoa_r+0xa82>
8000a84a:	40 db       	lddsp	r11,sp[0x34]
8000a84c:	58 0b       	cp.w	r11,0
8000a84e:	c1 a1       	brne	8000a882 <_dtoa_r+0xa82>
8000a850:	0c 99       	mov	r9,r6
8000a852:	40 26       	lddsp	r6,sp[0x8]
8000a854:	58 09       	cp.w	r9,0
8000a856:	e0 8a 00 21 	brle	8000a898 <_dtoa_r+0xa98>
8000a85a:	06 9b       	mov	r11,r3
8000a85c:	30 1a       	mov	r10,1
8000a85e:	0e 9c       	mov	r12,r7
8000a860:	e0 a0 06 92 	rcall	8000b584 <__lshift>
8000a864:	04 9b       	mov	r11,r2
8000a866:	18 93       	mov	r3,r12
8000a868:	e0 a0 05 6b 	rcall	8000b33e <__mcmp>
8000a86c:	e0 89 00 06 	brgt	8000a878 <_dtoa_r+0xa78>
8000a870:	c1 41       	brne	8000a898 <_dtoa_r+0xa98>
8000a872:	ed b0 00 00 	bld	r0,0x0
8000a876:	c1 11       	brne	8000a898 <_dtoa_r+0xa98>
8000a878:	e0 40 00 39 	cp.w	r0,57
8000a87c:	c0 a0       	breq	8000a890 <_dtoa_r+0xa90>
8000a87e:	2f f0       	sub	r0,-1
8000a880:	c0 c8       	rjmp	8000a898 <_dtoa_r+0xa98>
8000a882:	58 06       	cp.w	r6,0
8000a884:	e0 8a 00 0c 	brle	8000a89c <_dtoa_r+0xa9c>
8000a888:	40 26       	lddsp	r6,sp[0x8]
8000a88a:	e0 40 00 39 	cp.w	r0,57
8000a88e:	c0 41       	brne	8000a896 <_dtoa_r+0xa96>
8000a890:	33 98       	mov	r8,57
8000a892:	0a c8       	st.b	r5++,r8
8000a894:	c6 78       	rjmp	8000a962 <_dtoa_r+0xb62>
8000a896:	2f f0       	sub	r0,-1
8000a898:	0a c0       	st.b	r5++,r0
8000a89a:	c7 58       	rjmp	8000a984 <_dtoa_r+0xb84>
8000a89c:	0a c0       	st.b	r5++,r0
8000a89e:	40 9a       	lddsp	r10,sp[0x24]
8000a8a0:	40 e9       	lddsp	r9,sp[0x38]
8000a8a2:	12 3a       	cp.w	r10,r9
8000a8a4:	c4 30       	breq	8000a92a <_dtoa_r+0xb2a>
8000a8a6:	06 9b       	mov	r11,r3
8000a8a8:	30 09       	mov	r9,0
8000a8aa:	30 aa       	mov	r10,10
8000a8ac:	0e 9c       	mov	r12,r7
8000a8ae:	e0 a0 07 37 	rcall	8000b71c <__multadd>
8000a8b2:	40 48       	lddsp	r8,sp[0x10]
8000a8b4:	18 93       	mov	r3,r12
8000a8b6:	08 38       	cp.w	r8,r4
8000a8b8:	c0 91       	brne	8000a8ca <_dtoa_r+0xaca>
8000a8ba:	10 9b       	mov	r11,r8
8000a8bc:	30 09       	mov	r9,0
8000a8be:	30 aa       	mov	r10,10
8000a8c0:	0e 9c       	mov	r12,r7
8000a8c2:	e0 a0 07 2d 	rcall	8000b71c <__multadd>
8000a8c6:	50 4c       	stdsp	sp[0x10],r12
8000a8c8:	c0 e8       	rjmp	8000a8e4 <_dtoa_r+0xae4>
8000a8ca:	40 4b       	lddsp	r11,sp[0x10]
8000a8cc:	30 09       	mov	r9,0
8000a8ce:	30 aa       	mov	r10,10
8000a8d0:	0e 9c       	mov	r12,r7
8000a8d2:	e0 a0 07 25 	rcall	8000b71c <__multadd>
8000a8d6:	08 9b       	mov	r11,r4
8000a8d8:	50 4c       	stdsp	sp[0x10],r12
8000a8da:	30 09       	mov	r9,0
8000a8dc:	30 aa       	mov	r10,10
8000a8de:	0e 9c       	mov	r12,r7
8000a8e0:	e0 a0 07 1e 	rcall	8000b71c <__multadd>
8000a8e4:	18 94       	mov	r4,r12
8000a8e6:	40 9c       	lddsp	r12,sp[0x24]
8000a8e8:	2f fc       	sub	r12,-1
8000a8ea:	50 9c       	stdsp	sp[0x24],r12
8000a8ec:	c7 9b       	rjmp	8000a7de <_dtoa_r+0x9de>
8000a8ee:	30 18       	mov	r8,1
8000a8f0:	06 90       	mov	r0,r3
8000a8f2:	40 85       	lddsp	r5,sp[0x20]
8000a8f4:	08 93       	mov	r3,r4
8000a8f6:	0c 94       	mov	r4,r6
8000a8f8:	10 96       	mov	r6,r8
8000a8fa:	04 9b       	mov	r11,r2
8000a8fc:	00 9c       	mov	r12,r0
8000a8fe:	fe b0 f9 f1 	rcall	80009ce0 <quorem>
8000a902:	2d 0c       	sub	r12,-48
8000a904:	0a cc       	st.b	r5++,r12
8000a906:	02 36       	cp.w	r6,r1
8000a908:	c0 a4       	brge	8000a91c <_dtoa_r+0xb1c>
8000a90a:	00 9b       	mov	r11,r0
8000a90c:	30 09       	mov	r9,0
8000a90e:	30 aa       	mov	r10,10
8000a910:	0e 9c       	mov	r12,r7
8000a912:	2f f6       	sub	r6,-1
8000a914:	e0 a0 07 04 	rcall	8000b71c <__multadd>
8000a918:	18 90       	mov	r0,r12
8000a91a:	cf 0b       	rjmp	8000a8fa <_dtoa_r+0xafa>
8000a91c:	08 96       	mov	r6,r4
8000a91e:	30 0b       	mov	r11,0
8000a920:	06 94       	mov	r4,r3
8000a922:	50 4b       	stdsp	sp[0x10],r11
8000a924:	00 93       	mov	r3,r0
8000a926:	18 90       	mov	r0,r12
8000a928:	c0 28       	rjmp	8000a92c <_dtoa_r+0xb2c>
8000a92a:	40 26       	lddsp	r6,sp[0x8]
8000a92c:	06 9b       	mov	r11,r3
8000a92e:	30 1a       	mov	r10,1
8000a930:	0e 9c       	mov	r12,r7
8000a932:	e0 a0 06 29 	rcall	8000b584 <__lshift>
8000a936:	04 9b       	mov	r11,r2
8000a938:	18 93       	mov	r3,r12
8000a93a:	e0 a0 05 02 	rcall	8000b33e <__mcmp>
8000a93e:	e0 89 00 12 	brgt	8000a962 <_dtoa_r+0xb62>
8000a942:	c1 b1       	brne	8000a978 <_dtoa_r+0xb78>
8000a944:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a948:	c0 d1       	brne	8000a962 <_dtoa_r+0xb62>
8000a94a:	c1 78       	rjmp	8000a978 <_dtoa_r+0xb78>
8000a94c:	40 89       	lddsp	r9,sp[0x20]
8000a94e:	12 38       	cp.w	r8,r9
8000a950:	c0 30       	breq	8000a956 <_dtoa_r+0xb56>
8000a952:	10 95       	mov	r5,r8
8000a954:	c0 88       	rjmp	8000a964 <_dtoa_r+0xb64>
8000a956:	2f f6       	sub	r6,-1
8000a958:	50 66       	stdsp	sp[0x18],r6
8000a95a:	33 18       	mov	r8,49
8000a95c:	40 8c       	lddsp	r12,sp[0x20]
8000a95e:	b8 88       	st.b	r12[0x0],r8
8000a960:	c1 38       	rjmp	8000a986 <_dtoa_r+0xb86>
8000a962:	33 9a       	mov	r10,57
8000a964:	0a 98       	mov	r8,r5
8000a966:	11 79       	ld.ub	r9,--r8
8000a968:	f4 09 18 00 	cp.b	r9,r10
8000a96c:	cf 00       	breq	8000a94c <_dtoa_r+0xb4c>
8000a96e:	2f f9       	sub	r9,-1
8000a970:	b0 89       	st.b	r8[0x0],r9
8000a972:	c0 98       	rjmp	8000a984 <_dtoa_r+0xb84>
8000a974:	10 95       	mov	r5,r8
8000a976:	c0 28       	rjmp	8000a97a <_dtoa_r+0xb7a>
8000a978:	33 09       	mov	r9,48
8000a97a:	0a 98       	mov	r8,r5
8000a97c:	11 7a       	ld.ub	r10,--r8
8000a97e:	f2 0a 18 00 	cp.b	r10,r9
8000a982:	cf 90       	breq	8000a974 <_dtoa_r+0xb74>
8000a984:	50 66       	stdsp	sp[0x18],r6
8000a986:	04 9b       	mov	r11,r2
8000a988:	0e 9c       	mov	r12,r7
8000a98a:	e0 a0 04 f3 	rcall	8000b370 <_Bfree>
8000a98e:	58 04       	cp.w	r4,0
8000a990:	c1 20       	breq	8000a9b4 <_dtoa_r+0xbb4>
8000a992:	40 4b       	lddsp	r11,sp[0x10]
8000a994:	08 3b       	cp.w	r11,r4
8000a996:	5f 19       	srne	r9
8000a998:	58 0b       	cp.w	r11,0
8000a99a:	5f 18       	srne	r8
8000a99c:	f3 e8 00 08 	and	r8,r9,r8
8000a9a0:	c0 40       	breq	8000a9a8 <_dtoa_r+0xba8>
8000a9a2:	0e 9c       	mov	r12,r7
8000a9a4:	e0 a0 04 e6 	rcall	8000b370 <_Bfree>
8000a9a8:	08 9b       	mov	r11,r4
8000a9aa:	0e 9c       	mov	r12,r7
8000a9ac:	e0 a0 04 e2 	rcall	8000b370 <_Bfree>
8000a9b0:	c0 28       	rjmp	8000a9b4 <_dtoa_r+0xbb4>
8000a9b2:	50 66       	stdsp	sp[0x18],r6
8000a9b4:	0e 9c       	mov	r12,r7
8000a9b6:	06 9b       	mov	r11,r3
8000a9b8:	e0 a0 04 dc 	rcall	8000b370 <_Bfree>
8000a9bc:	30 08       	mov	r8,0
8000a9be:	aa 88       	st.b	r5[0x0],r8
8000a9c0:	40 68       	lddsp	r8,sp[0x18]
8000a9c2:	41 5a       	lddsp	r10,sp[0x54]
8000a9c4:	2f f8       	sub	r8,-1
8000a9c6:	41 29       	lddsp	r9,sp[0x48]
8000a9c8:	95 08       	st.w	r10[0x0],r8
8000a9ca:	40 8c       	lddsp	r12,sp[0x20]
8000a9cc:	58 09       	cp.w	r9,0
8000a9ce:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a9d2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a9d6:	2e 6d       	sub	sp,-104
8000a9d8:	d8 32       	popm	r0-r7,pc
8000a9da:	d7 03       	nop

8000a9dc <__errno>:
8000a9dc:	e0 68 0a 2c 	mov	r8,2604
8000a9e0:	70 0c       	ld.w	r12,r8[0x0]
8000a9e2:	2f 4c       	sub	r12,-12
8000a9e4:	5e fc       	retal	r12
8000a9e6:	d7 03       	nop

8000a9e8 <_fflush_r>:
8000a9e8:	d4 21       	pushm	r4-r7,lr
8000a9ea:	16 97       	mov	r7,r11
8000a9ec:	18 96       	mov	r6,r12
8000a9ee:	76 48       	ld.w	r8,r11[0x10]
8000a9f0:	58 08       	cp.w	r8,0
8000a9f2:	c7 f0       	breq	8000aaf0 <_fflush_r+0x108>
8000a9f4:	58 0c       	cp.w	r12,0
8000a9f6:	c0 50       	breq	8000aa00 <_fflush_r+0x18>
8000a9f8:	78 68       	ld.w	r8,r12[0x18]
8000a9fa:	58 08       	cp.w	r8,0
8000a9fc:	c0 21       	brne	8000aa00 <_fflush_r+0x18>
8000a9fe:	cc dc       	rcall	8000ab98 <__sinit>
8000aa00:	fe c8 ce 4c 	sub	r8,pc,-12724
8000aa04:	10 37       	cp.w	r7,r8
8000aa06:	c0 31       	brne	8000aa0c <_fflush_r+0x24>
8000aa08:	6c 07       	ld.w	r7,r6[0x0]
8000aa0a:	c0 c8       	rjmp	8000aa22 <_fflush_r+0x3a>
8000aa0c:	fe c8 ce 38 	sub	r8,pc,-12744
8000aa10:	10 37       	cp.w	r7,r8
8000aa12:	c0 31       	brne	8000aa18 <_fflush_r+0x30>
8000aa14:	6c 17       	ld.w	r7,r6[0x4]
8000aa16:	c0 68       	rjmp	8000aa22 <_fflush_r+0x3a>
8000aa18:	fe c8 ce 24 	sub	r8,pc,-12764
8000aa1c:	10 37       	cp.w	r7,r8
8000aa1e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa22:	8e 6a       	ld.sh	r10,r7[0xc]
8000aa24:	14 98       	mov	r8,r10
8000aa26:	ed ba 00 03 	bld	r10,0x3
8000aa2a:	c4 20       	breq	8000aaae <_fflush_r+0xc6>
8000aa2c:	ab ba       	sbr	r10,0xb
8000aa2e:	ae 6a       	st.h	r7[0xc],r10
8000aa30:	6e 18       	ld.w	r8,r7[0x4]
8000aa32:	58 08       	cp.w	r8,0
8000aa34:	e0 89 00 06 	brgt	8000aa40 <_fflush_r+0x58>
8000aa38:	6f 08       	ld.w	r8,r7[0x40]
8000aa3a:	58 08       	cp.w	r8,0
8000aa3c:	e0 8a 00 5a 	brle	8000aaf0 <_fflush_r+0x108>
8000aa40:	6e b8       	ld.w	r8,r7[0x2c]
8000aa42:	58 08       	cp.w	r8,0
8000aa44:	c5 60       	breq	8000aaf0 <_fflush_r+0x108>
8000aa46:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aa4a:	c0 30       	breq	8000aa50 <_fflush_r+0x68>
8000aa4c:	6f 55       	ld.w	r5,r7[0x54]
8000aa4e:	c0 f8       	rjmp	8000aa6c <_fflush_r+0x84>
8000aa50:	30 19       	mov	r9,1
8000aa52:	6e 8b       	ld.w	r11,r7[0x20]
8000aa54:	0c 9c       	mov	r12,r6
8000aa56:	5d 18       	icall	r8
8000aa58:	18 95       	mov	r5,r12
8000aa5a:	5b fc       	cp.w	r12,-1
8000aa5c:	c0 81       	brne	8000aa6c <_fflush_r+0x84>
8000aa5e:	6c 38       	ld.w	r8,r6[0xc]
8000aa60:	59 d8       	cp.w	r8,29
8000aa62:	c4 70       	breq	8000aaf0 <_fflush_r+0x108>
8000aa64:	8e 68       	ld.sh	r8,r7[0xc]
8000aa66:	a7 a8       	sbr	r8,0x6
8000aa68:	ae 68       	st.h	r7[0xc],r8
8000aa6a:	d8 22       	popm	r4-r7,pc
8000aa6c:	8e 68       	ld.sh	r8,r7[0xc]
8000aa6e:	ed b8 00 02 	bld	r8,0x2
8000aa72:	c0 91       	brne	8000aa84 <_fflush_r+0x9c>
8000aa74:	6e 18       	ld.w	r8,r7[0x4]
8000aa76:	10 15       	sub	r5,r8
8000aa78:	6e d8       	ld.w	r8,r7[0x34]
8000aa7a:	58 08       	cp.w	r8,0
8000aa7c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aa80:	eb d8 e1 15 	subne	r5,r5,r8
8000aa84:	6e b8       	ld.w	r8,r7[0x2c]
8000aa86:	0c 9c       	mov	r12,r6
8000aa88:	30 09       	mov	r9,0
8000aa8a:	0a 9a       	mov	r10,r5
8000aa8c:	6e 8b       	ld.w	r11,r7[0x20]
8000aa8e:	5d 18       	icall	r8
8000aa90:	8e 68       	ld.sh	r8,r7[0xc]
8000aa92:	0a 3c       	cp.w	r12,r5
8000aa94:	c2 61       	brne	8000aae0 <_fflush_r+0xf8>
8000aa96:	ab d8       	cbr	r8,0xb
8000aa98:	30 0c       	mov	r12,0
8000aa9a:	6e 49       	ld.w	r9,r7[0x10]
8000aa9c:	ae 68       	st.h	r7[0xc],r8
8000aa9e:	8f 1c       	st.w	r7[0x4],r12
8000aaa0:	8f 09       	st.w	r7[0x0],r9
8000aaa2:	ed b8 00 0c 	bld	r8,0xc
8000aaa6:	c2 51       	brne	8000aaf0 <_fflush_r+0x108>
8000aaa8:	ef 45 00 54 	st.w	r7[84],r5
8000aaac:	d8 22       	popm	r4-r7,pc
8000aaae:	6e 45       	ld.w	r5,r7[0x10]
8000aab0:	58 05       	cp.w	r5,0
8000aab2:	c1 f0       	breq	8000aaf0 <_fflush_r+0x108>
8000aab4:	6e 04       	ld.w	r4,r7[0x0]
8000aab6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aaba:	8f 05       	st.w	r7[0x0],r5
8000aabc:	f9 b8 01 00 	movne	r8,0
8000aac0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aac4:	0a 14       	sub	r4,r5
8000aac6:	8f 28       	st.w	r7[0x8],r8
8000aac8:	c1 18       	rjmp	8000aaea <_fflush_r+0x102>
8000aaca:	08 99       	mov	r9,r4
8000aacc:	0a 9a       	mov	r10,r5
8000aace:	6e a8       	ld.w	r8,r7[0x28]
8000aad0:	6e 8b       	ld.w	r11,r7[0x20]
8000aad2:	0c 9c       	mov	r12,r6
8000aad4:	5d 18       	icall	r8
8000aad6:	18 14       	sub	r4,r12
8000aad8:	58 0c       	cp.w	r12,0
8000aada:	e0 89 00 07 	brgt	8000aae8 <_fflush_r+0x100>
8000aade:	8e 68       	ld.sh	r8,r7[0xc]
8000aae0:	a7 a8       	sbr	r8,0x6
8000aae2:	3f fc       	mov	r12,-1
8000aae4:	ae 68       	st.h	r7[0xc],r8
8000aae6:	d8 22       	popm	r4-r7,pc
8000aae8:	18 05       	add	r5,r12
8000aaea:	58 04       	cp.w	r4,0
8000aaec:	fe 99 ff ef 	brgt	8000aaca <_fflush_r+0xe2>
8000aaf0:	d8 2a       	popm	r4-r7,pc,r12=0
8000aaf2:	d7 03       	nop

8000aaf4 <__sfp_lock_acquire>:
8000aaf4:	5e fc       	retal	r12

8000aaf6 <__sfp_lock_release>:
8000aaf6:	5e fc       	retal	r12

8000aaf8 <_cleanup_r>:
8000aaf8:	d4 01       	pushm	lr
8000aafa:	fe cb f0 ae 	sub	r11,pc,-3922
8000aafe:	e0 a0 02 f7 	rcall	8000b0ec <_fwalk>
8000ab02:	d8 02       	popm	pc

8000ab04 <__sfmoreglue>:
8000ab04:	d4 21       	pushm	r4-r7,lr
8000ab06:	16 95       	mov	r5,r11
8000ab08:	f6 06 10 5c 	mul	r6,r11,92
8000ab0c:	ec cb ff f4 	sub	r11,r6,-12
8000ab10:	fe b0 e2 88 	rcall	80007020 <_malloc_r>
8000ab14:	18 97       	mov	r7,r12
8000ab16:	c0 90       	breq	8000ab28 <__sfmoreglue+0x24>
8000ab18:	99 15       	st.w	r12[0x4],r5
8000ab1a:	30 0b       	mov	r11,0
8000ab1c:	2f 4c       	sub	r12,-12
8000ab1e:	0c 9a       	mov	r10,r6
8000ab20:	8f 2c       	st.w	r7[0x8],r12
8000ab22:	8f 0b       	st.w	r7[0x0],r11
8000ab24:	fe b0 e5 3e 	rcall	800075a0 <memset>
8000ab28:	0e 9c       	mov	r12,r7
8000ab2a:	d8 22       	popm	r4-r7,pc

8000ab2c <__sfp>:
8000ab2c:	d4 21       	pushm	r4-r7,lr
8000ab2e:	fe c8 cf 16 	sub	r8,pc,-12522
8000ab32:	18 96       	mov	r6,r12
8000ab34:	70 07       	ld.w	r7,r8[0x0]
8000ab36:	6e 68       	ld.w	r8,r7[0x18]
8000ab38:	58 08       	cp.w	r8,0
8000ab3a:	c0 31       	brne	8000ab40 <__sfp+0x14>
8000ab3c:	0e 9c       	mov	r12,r7
8000ab3e:	c2 dc       	rcall	8000ab98 <__sinit>
8000ab40:	ee c7 ff 28 	sub	r7,r7,-216
8000ab44:	30 05       	mov	r5,0
8000ab46:	6e 2c       	ld.w	r12,r7[0x8]
8000ab48:	6e 18       	ld.w	r8,r7[0x4]
8000ab4a:	c0 68       	rjmp	8000ab56 <__sfp+0x2a>
8000ab4c:	98 69       	ld.sh	r9,r12[0xc]
8000ab4e:	ea 09 19 00 	cp.h	r9,r5
8000ab52:	c1 10       	breq	8000ab74 <__sfp+0x48>
8000ab54:	2a 4c       	sub	r12,-92
8000ab56:	20 18       	sub	r8,1
8000ab58:	cf a7       	brpl	8000ab4c <__sfp+0x20>
8000ab5a:	6e 08       	ld.w	r8,r7[0x0]
8000ab5c:	58 08       	cp.w	r8,0
8000ab5e:	c0 61       	brne	8000ab6a <__sfp+0x3e>
8000ab60:	30 4b       	mov	r11,4
8000ab62:	0c 9c       	mov	r12,r6
8000ab64:	cd 0f       	rcall	8000ab04 <__sfmoreglue>
8000ab66:	8f 0c       	st.w	r7[0x0],r12
8000ab68:	c0 30       	breq	8000ab6e <__sfp+0x42>
8000ab6a:	6e 07       	ld.w	r7,r7[0x0]
8000ab6c:	ce db       	rjmp	8000ab46 <__sfp+0x1a>
8000ab6e:	30 c8       	mov	r8,12
8000ab70:	8d 38       	st.w	r6[0xc],r8
8000ab72:	d8 22       	popm	r4-r7,pc
8000ab74:	30 08       	mov	r8,0
8000ab76:	f9 48 00 4c 	st.w	r12[76],r8
8000ab7a:	99 08       	st.w	r12[0x0],r8
8000ab7c:	99 28       	st.w	r12[0x8],r8
8000ab7e:	99 18       	st.w	r12[0x4],r8
8000ab80:	99 48       	st.w	r12[0x10],r8
8000ab82:	99 58       	st.w	r12[0x14],r8
8000ab84:	99 68       	st.w	r12[0x18],r8
8000ab86:	99 d8       	st.w	r12[0x34],r8
8000ab88:	99 e8       	st.w	r12[0x38],r8
8000ab8a:	f9 48 00 48 	st.w	r12[72],r8
8000ab8e:	3f f8       	mov	r8,-1
8000ab90:	b8 78       	st.h	r12[0xe],r8
8000ab92:	30 18       	mov	r8,1
8000ab94:	b8 68       	st.h	r12[0xc],r8
8000ab96:	d8 22       	popm	r4-r7,pc

8000ab98 <__sinit>:
8000ab98:	d4 21       	pushm	r4-r7,lr
8000ab9a:	18 96       	mov	r6,r12
8000ab9c:	78 67       	ld.w	r7,r12[0x18]
8000ab9e:	58 07       	cp.w	r7,0
8000aba0:	c4 91       	brne	8000ac32 <__sinit+0x9a>
8000aba2:	fe c8 00 aa 	sub	r8,pc,170
8000aba6:	30 15       	mov	r5,1
8000aba8:	99 a8       	st.w	r12[0x28],r8
8000abaa:	f9 47 00 d8 	st.w	r12[216],r7
8000abae:	f9 47 00 dc 	st.w	r12[220],r7
8000abb2:	f9 47 00 e0 	st.w	r12[224],r7
8000abb6:	99 65       	st.w	r12[0x18],r5
8000abb8:	cb af       	rcall	8000ab2c <__sfp>
8000abba:	8d 0c       	st.w	r6[0x0],r12
8000abbc:	0c 9c       	mov	r12,r6
8000abbe:	cb 7f       	rcall	8000ab2c <__sfp>
8000abc0:	8d 1c       	st.w	r6[0x4],r12
8000abc2:	0c 9c       	mov	r12,r6
8000abc4:	cb 4f       	rcall	8000ab2c <__sfp>
8000abc6:	6c 09       	ld.w	r9,r6[0x0]
8000abc8:	30 48       	mov	r8,4
8000abca:	93 07       	st.w	r9[0x0],r7
8000abcc:	b2 68       	st.h	r9[0xc],r8
8000abce:	93 17       	st.w	r9[0x4],r7
8000abd0:	93 27       	st.w	r9[0x8],r7
8000abd2:	6c 18       	ld.w	r8,r6[0x4]
8000abd4:	b2 77       	st.h	r9[0xe],r7
8000abd6:	93 47       	st.w	r9[0x10],r7
8000abd8:	93 57       	st.w	r9[0x14],r7
8000abda:	93 67       	st.w	r9[0x18],r7
8000abdc:	93 89       	st.w	r9[0x20],r9
8000abde:	91 07       	st.w	r8[0x0],r7
8000abe0:	91 17       	st.w	r8[0x4],r7
8000abe2:	91 27       	st.w	r8[0x8],r7
8000abe4:	fe ce f3 24 	sub	lr,pc,-3292
8000abe8:	fe cb f3 54 	sub	r11,pc,-3244
8000abec:	93 9e       	st.w	r9[0x24],lr
8000abee:	93 ab       	st.w	r9[0x28],r11
8000abf0:	fe ca f3 7c 	sub	r10,pc,-3204
8000abf4:	fe c4 f3 88 	sub	r4,pc,-3192
8000abf8:	93 ba       	st.w	r9[0x2c],r10
8000abfa:	93 c4       	st.w	r9[0x30],r4
8000abfc:	30 99       	mov	r9,9
8000abfe:	b0 69       	st.h	r8[0xc],r9
8000ac00:	b0 75       	st.h	r8[0xe],r5
8000ac02:	91 c4       	st.w	r8[0x30],r4
8000ac04:	91 47       	st.w	r8[0x10],r7
8000ac06:	91 57       	st.w	r8[0x14],r7
8000ac08:	91 67       	st.w	r8[0x18],r7
8000ac0a:	91 88       	st.w	r8[0x20],r8
8000ac0c:	91 9e       	st.w	r8[0x24],lr
8000ac0e:	91 ab       	st.w	r8[0x28],r11
8000ac10:	91 ba       	st.w	r8[0x2c],r10
8000ac12:	8d 2c       	st.w	r6[0x8],r12
8000ac14:	31 28       	mov	r8,18
8000ac16:	99 07       	st.w	r12[0x0],r7
8000ac18:	b8 68       	st.h	r12[0xc],r8
8000ac1a:	99 17       	st.w	r12[0x4],r7
8000ac1c:	99 27       	st.w	r12[0x8],r7
8000ac1e:	30 28       	mov	r8,2
8000ac20:	b8 78       	st.h	r12[0xe],r8
8000ac22:	99 c4       	st.w	r12[0x30],r4
8000ac24:	99 67       	st.w	r12[0x18],r7
8000ac26:	99 9e       	st.w	r12[0x24],lr
8000ac28:	99 ab       	st.w	r12[0x28],r11
8000ac2a:	99 ba       	st.w	r12[0x2c],r10
8000ac2c:	99 47       	st.w	r12[0x10],r7
8000ac2e:	99 57       	st.w	r12[0x14],r7
8000ac30:	99 8c       	st.w	r12[0x20],r12
8000ac32:	d8 22       	popm	r4-r7,pc

8000ac34 <_malloc_trim_r>:
8000ac34:	d4 21       	pushm	r4-r7,lr
8000ac36:	16 95       	mov	r5,r11
8000ac38:	18 97       	mov	r7,r12
8000ac3a:	fe b0 d7 f1 	rcall	80005c1c <__malloc_lock>
8000ac3e:	e0 64 05 2c 	mov	r4,1324
8000ac42:	68 28       	ld.w	r8,r4[0x8]
8000ac44:	70 16       	ld.w	r6,r8[0x4]
8000ac46:	e0 16 ff fc 	andl	r6,0xfffc
8000ac4a:	ec c8 ff 91 	sub	r8,r6,-111
8000ac4e:	f0 05 01 05 	sub	r5,r8,r5
8000ac52:	e0 15 ff 80 	andl	r5,0xff80
8000ac56:	ea c5 00 80 	sub	r5,r5,128
8000ac5a:	e0 45 00 7f 	cp.w	r5,127
8000ac5e:	e0 8a 00 25 	brle	8000aca8 <_malloc_trim_r+0x74>
8000ac62:	30 0b       	mov	r11,0
8000ac64:	0e 9c       	mov	r12,r7
8000ac66:	fe b0 e6 05 	rcall	80007870 <_sbrk_r>
8000ac6a:	68 28       	ld.w	r8,r4[0x8]
8000ac6c:	0c 08       	add	r8,r6
8000ac6e:	10 3c       	cp.w	r12,r8
8000ac70:	c1 c1       	brne	8000aca8 <_malloc_trim_r+0x74>
8000ac72:	ea 0b 11 00 	rsub	r11,r5,0
8000ac76:	0e 9c       	mov	r12,r7
8000ac78:	fe b0 e5 fc 	rcall	80007870 <_sbrk_r>
8000ac7c:	5b fc       	cp.w	r12,-1
8000ac7e:	c1 91       	brne	8000acb0 <_malloc_trim_r+0x7c>
8000ac80:	30 0b       	mov	r11,0
8000ac82:	0e 9c       	mov	r12,r7
8000ac84:	fe b0 e5 f6 	rcall	80007870 <_sbrk_r>
8000ac88:	68 28       	ld.w	r8,r4[0x8]
8000ac8a:	f8 08 01 09 	sub	r9,r12,r8
8000ac8e:	58 f9       	cp.w	r9,15
8000ac90:	e0 8a 00 0c 	brle	8000aca8 <_malloc_trim_r+0x74>
8000ac94:	a1 a9       	sbr	r9,0x0
8000ac96:	91 19       	st.w	r8[0x4],r9
8000ac98:	e0 68 09 38 	mov	r8,2360
8000ac9c:	70 09       	ld.w	r9,r8[0x0]
8000ac9e:	e0 68 0d 48 	mov	r8,3400
8000aca2:	f8 09 01 09 	sub	r9,r12,r9
8000aca6:	91 09       	st.w	r8[0x0],r9
8000aca8:	0e 9c       	mov	r12,r7
8000acaa:	fe b0 d7 bf 	rcall	80005c28 <__malloc_unlock>
8000acae:	d8 2a       	popm	r4-r7,pc,r12=0
8000acb0:	68 28       	ld.w	r8,r4[0x8]
8000acb2:	0a 16       	sub	r6,r5
8000acb4:	a1 a6       	sbr	r6,0x0
8000acb6:	91 16       	st.w	r8[0x4],r6
8000acb8:	e0 68 0d 48 	mov	r8,3400
8000acbc:	70 09       	ld.w	r9,r8[0x0]
8000acbe:	0a 19       	sub	r9,r5
8000acc0:	0e 9c       	mov	r12,r7
8000acc2:	91 09       	st.w	r8[0x0],r9
8000acc4:	fe b0 d7 b2 	rcall	80005c28 <__malloc_unlock>
8000acc8:	da 2a       	popm	r4-r7,pc,r12=1
8000acca:	d7 03       	nop

8000accc <_free_r>:
8000accc:	d4 21       	pushm	r4-r7,lr
8000acce:	16 96       	mov	r6,r11
8000acd0:	18 97       	mov	r7,r12
8000acd2:	58 0b       	cp.w	r11,0
8000acd4:	e0 80 00 c0 	breq	8000ae54 <_free_r+0x188>
8000acd8:	fe b0 d7 a2 	rcall	80005c1c <__malloc_lock>
8000acdc:	20 86       	sub	r6,8
8000acde:	e0 6a 05 2c 	mov	r10,1324
8000ace2:	6c 18       	ld.w	r8,r6[0x4]
8000ace4:	74 2e       	ld.w	lr,r10[0x8]
8000ace6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000acea:	a1 c8       	cbr	r8,0x0
8000acec:	ec 08 00 09 	add	r9,r6,r8
8000acf0:	72 1b       	ld.w	r11,r9[0x4]
8000acf2:	e0 1b ff fc 	andl	r11,0xfffc
8000acf6:	1c 39       	cp.w	r9,lr
8000acf8:	c1 e1       	brne	8000ad34 <_free_r+0x68>
8000acfa:	f6 08 00 08 	add	r8,r11,r8
8000acfe:	58 0c       	cp.w	r12,0
8000ad00:	c0 81       	brne	8000ad10 <_free_r+0x44>
8000ad02:	6c 09       	ld.w	r9,r6[0x0]
8000ad04:	12 16       	sub	r6,r9
8000ad06:	12 08       	add	r8,r9
8000ad08:	6c 3b       	ld.w	r11,r6[0xc]
8000ad0a:	6c 29       	ld.w	r9,r6[0x8]
8000ad0c:	97 29       	st.w	r11[0x8],r9
8000ad0e:	93 3b       	st.w	r9[0xc],r11
8000ad10:	10 99       	mov	r9,r8
8000ad12:	95 26       	st.w	r10[0x8],r6
8000ad14:	a1 a9       	sbr	r9,0x0
8000ad16:	8d 19       	st.w	r6[0x4],r9
8000ad18:	e0 69 09 34 	mov	r9,2356
8000ad1c:	72 09       	ld.w	r9,r9[0x0]
8000ad1e:	12 38       	cp.w	r8,r9
8000ad20:	c0 63       	brcs	8000ad2c <_free_r+0x60>
8000ad22:	e0 68 0d 44 	mov	r8,3396
8000ad26:	0e 9c       	mov	r12,r7
8000ad28:	70 0b       	ld.w	r11,r8[0x0]
8000ad2a:	c8 5f       	rcall	8000ac34 <_malloc_trim_r>
8000ad2c:	0e 9c       	mov	r12,r7
8000ad2e:	fe b0 d7 7d 	rcall	80005c28 <__malloc_unlock>
8000ad32:	d8 22       	popm	r4-r7,pc
8000ad34:	93 1b       	st.w	r9[0x4],r11
8000ad36:	58 0c       	cp.w	r12,0
8000ad38:	c0 30       	breq	8000ad3e <_free_r+0x72>
8000ad3a:	30 0c       	mov	r12,0
8000ad3c:	c1 08       	rjmp	8000ad5c <_free_r+0x90>
8000ad3e:	6c 0e       	ld.w	lr,r6[0x0]
8000ad40:	f4 c5 ff f8 	sub	r5,r10,-8
8000ad44:	1c 16       	sub	r6,lr
8000ad46:	1c 08       	add	r8,lr
8000ad48:	6c 2e       	ld.w	lr,r6[0x8]
8000ad4a:	0a 3e       	cp.w	lr,r5
8000ad4c:	f9 bc 00 01 	moveq	r12,1
8000ad50:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ad54:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ad58:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ad5c:	f2 0b 00 0e 	add	lr,r9,r11
8000ad60:	7c 1e       	ld.w	lr,lr[0x4]
8000ad62:	ed be 00 00 	bld	lr,0x0
8000ad66:	c1 40       	breq	8000ad8e <_free_r+0xc2>
8000ad68:	16 08       	add	r8,r11
8000ad6a:	58 0c       	cp.w	r12,0
8000ad6c:	c0 d1       	brne	8000ad86 <_free_r+0xba>
8000ad6e:	e0 6e 05 2c 	mov	lr,1324
8000ad72:	72 2b       	ld.w	r11,r9[0x8]
8000ad74:	2f 8e       	sub	lr,-8
8000ad76:	1c 3b       	cp.w	r11,lr
8000ad78:	c0 71       	brne	8000ad86 <_free_r+0xba>
8000ad7a:	97 36       	st.w	r11[0xc],r6
8000ad7c:	97 26       	st.w	r11[0x8],r6
8000ad7e:	8d 2b       	st.w	r6[0x8],r11
8000ad80:	8d 3b       	st.w	r6[0xc],r11
8000ad82:	30 1c       	mov	r12,1
8000ad84:	c0 58       	rjmp	8000ad8e <_free_r+0xc2>
8000ad86:	72 2b       	ld.w	r11,r9[0x8]
8000ad88:	72 39       	ld.w	r9,r9[0xc]
8000ad8a:	93 2b       	st.w	r9[0x8],r11
8000ad8c:	97 39       	st.w	r11[0xc],r9
8000ad8e:	10 99       	mov	r9,r8
8000ad90:	ec 08 09 08 	st.w	r6[r8],r8
8000ad94:	a1 a9       	sbr	r9,0x0
8000ad96:	8d 19       	st.w	r6[0x4],r9
8000ad98:	58 0c       	cp.w	r12,0
8000ad9a:	c5 a1       	brne	8000ae4e <_free_r+0x182>
8000ad9c:	e0 48 01 ff 	cp.w	r8,511
8000ada0:	e0 8b 00 13 	brhi	8000adc6 <_free_r+0xfa>
8000ada4:	a3 98       	lsr	r8,0x3
8000ada6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000adaa:	72 2b       	ld.w	r11,r9[0x8]
8000adac:	8d 39       	st.w	r6[0xc],r9
8000adae:	8d 2b       	st.w	r6[0x8],r11
8000adb0:	97 36       	st.w	r11[0xc],r6
8000adb2:	93 26       	st.w	r9[0x8],r6
8000adb4:	a3 48       	asr	r8,0x2
8000adb6:	74 19       	ld.w	r9,r10[0x4]
8000adb8:	30 1b       	mov	r11,1
8000adba:	f6 08 09 48 	lsl	r8,r11,r8
8000adbe:	f3 e8 10 08 	or	r8,r9,r8
8000adc2:	95 18       	st.w	r10[0x4],r8
8000adc4:	c4 58       	rjmp	8000ae4e <_free_r+0x182>
8000adc6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000adca:	58 4b       	cp.w	r11,4
8000adcc:	e0 8b 00 06 	brhi	8000add8 <_free_r+0x10c>
8000add0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000add4:	2c 8b       	sub	r11,-56
8000add6:	c2 08       	rjmp	8000ae16 <_free_r+0x14a>
8000add8:	59 4b       	cp.w	r11,20
8000adda:	e0 8b 00 04 	brhi	8000ade2 <_free_r+0x116>
8000adde:	2a 5b       	sub	r11,-91
8000ade0:	c1 b8       	rjmp	8000ae16 <_free_r+0x14a>
8000ade2:	e0 4b 00 54 	cp.w	r11,84
8000ade6:	e0 8b 00 06 	brhi	8000adf2 <_free_r+0x126>
8000adea:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000adee:	29 2b       	sub	r11,-110
8000adf0:	c1 38       	rjmp	8000ae16 <_free_r+0x14a>
8000adf2:	e0 4b 01 54 	cp.w	r11,340
8000adf6:	e0 8b 00 06 	brhi	8000ae02 <_free_r+0x136>
8000adfa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000adfe:	28 9b       	sub	r11,-119
8000ae00:	c0 b8       	rjmp	8000ae16 <_free_r+0x14a>
8000ae02:	e0 4b 05 54 	cp.w	r11,1364
8000ae06:	e0 88 00 05 	brls	8000ae10 <_free_r+0x144>
8000ae0a:	37 eb       	mov	r11,126
8000ae0c:	c0 58       	rjmp	8000ae16 <_free_r+0x14a>
8000ae0e:	d7 03       	nop
8000ae10:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ae14:	28 4b       	sub	r11,-124
8000ae16:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ae1a:	78 29       	ld.w	r9,r12[0x8]
8000ae1c:	18 39       	cp.w	r9,r12
8000ae1e:	c0 e1       	brne	8000ae3a <_free_r+0x16e>
8000ae20:	74 18       	ld.w	r8,r10[0x4]
8000ae22:	a3 4b       	asr	r11,0x2
8000ae24:	30 1c       	mov	r12,1
8000ae26:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ae2a:	f1 eb 10 0b 	or	r11,r8,r11
8000ae2e:	12 98       	mov	r8,r9
8000ae30:	95 1b       	st.w	r10[0x4],r11
8000ae32:	c0 a8       	rjmp	8000ae46 <_free_r+0x17a>
8000ae34:	72 29       	ld.w	r9,r9[0x8]
8000ae36:	18 39       	cp.w	r9,r12
8000ae38:	c0 60       	breq	8000ae44 <_free_r+0x178>
8000ae3a:	72 1a       	ld.w	r10,r9[0x4]
8000ae3c:	e0 1a ff fc 	andl	r10,0xfffc
8000ae40:	14 38       	cp.w	r8,r10
8000ae42:	cf 93       	brcs	8000ae34 <_free_r+0x168>
8000ae44:	72 38       	ld.w	r8,r9[0xc]
8000ae46:	8d 38       	st.w	r6[0xc],r8
8000ae48:	8d 29       	st.w	r6[0x8],r9
8000ae4a:	93 36       	st.w	r9[0xc],r6
8000ae4c:	91 26       	st.w	r8[0x8],r6
8000ae4e:	0e 9c       	mov	r12,r7
8000ae50:	fe b0 d6 ec 	rcall	80005c28 <__malloc_unlock>
8000ae54:	d8 22       	popm	r4-r7,pc
8000ae56:	d7 03       	nop

8000ae58 <__sfvwrite_r>:
8000ae58:	d4 31       	pushm	r0-r7,lr
8000ae5a:	20 3d       	sub	sp,12
8000ae5c:	14 94       	mov	r4,r10
8000ae5e:	18 95       	mov	r5,r12
8000ae60:	16 97       	mov	r7,r11
8000ae62:	74 28       	ld.w	r8,r10[0x8]
8000ae64:	58 08       	cp.w	r8,0
8000ae66:	e0 80 01 40 	breq	8000b0e6 <__sfvwrite_r+0x28e>
8000ae6a:	96 68       	ld.sh	r8,r11[0xc]
8000ae6c:	ed b8 00 03 	bld	r8,0x3
8000ae70:	c0 41       	brne	8000ae78 <__sfvwrite_r+0x20>
8000ae72:	76 48       	ld.w	r8,r11[0x10]
8000ae74:	58 08       	cp.w	r8,0
8000ae76:	c0 c1       	brne	8000ae8e <__sfvwrite_r+0x36>
8000ae78:	0e 9b       	mov	r11,r7
8000ae7a:	0a 9c       	mov	r12,r5
8000ae7c:	fe b0 f6 c4 	rcall	80009c04 <__swsetup_r>
8000ae80:	c0 70       	breq	8000ae8e <__sfvwrite_r+0x36>
8000ae82:	8e 68       	ld.sh	r8,r7[0xc]
8000ae84:	a7 a8       	sbr	r8,0x6
8000ae86:	ae 68       	st.h	r7[0xc],r8
8000ae88:	30 98       	mov	r8,9
8000ae8a:	8b 38       	st.w	r5[0xc],r8
8000ae8c:	c2 b9       	rjmp	8000b0e2 <__sfvwrite_r+0x28a>
8000ae8e:	8e 63       	ld.sh	r3,r7[0xc]
8000ae90:	68 00       	ld.w	r0,r4[0x0]
8000ae92:	06 96       	mov	r6,r3
8000ae94:	e2 16 00 02 	andl	r6,0x2,COH
8000ae98:	c2 10       	breq	8000aeda <__sfvwrite_r+0x82>
8000ae9a:	30 03       	mov	r3,0
8000ae9c:	e0 62 04 00 	mov	r2,1024
8000aea0:	06 96       	mov	r6,r3
8000aea2:	c0 48       	rjmp	8000aeaa <__sfvwrite_r+0x52>
8000aea4:	60 03       	ld.w	r3,r0[0x0]
8000aea6:	60 16       	ld.w	r6,r0[0x4]
8000aea8:	2f 80       	sub	r0,-8
8000aeaa:	58 06       	cp.w	r6,0
8000aeac:	cf c0       	breq	8000aea4 <__sfvwrite_r+0x4c>
8000aeae:	e0 46 04 00 	cp.w	r6,1024
8000aeb2:	ec 09 17 80 	movls	r9,r6
8000aeb6:	e4 09 17 b0 	movhi	r9,r2
8000aeba:	06 9a       	mov	r10,r3
8000aebc:	6e a8       	ld.w	r8,r7[0x28]
8000aebe:	6e 8b       	ld.w	r11,r7[0x20]
8000aec0:	0a 9c       	mov	r12,r5
8000aec2:	5d 18       	icall	r8
8000aec4:	18 16       	sub	r6,r12
8000aec6:	58 0c       	cp.w	r12,0
8000aec8:	e0 8a 01 0a 	brle	8000b0dc <__sfvwrite_r+0x284>
8000aecc:	68 28       	ld.w	r8,r4[0x8]
8000aece:	18 18       	sub	r8,r12
8000aed0:	89 28       	st.w	r4[0x8],r8
8000aed2:	e0 80 01 0a 	breq	8000b0e6 <__sfvwrite_r+0x28e>
8000aed6:	18 03       	add	r3,r12
8000aed8:	ce 9b       	rjmp	8000aeaa <__sfvwrite_r+0x52>
8000aeda:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000aede:	c0 70       	breq	8000aeec <__sfvwrite_r+0x94>
8000aee0:	50 06       	stdsp	sp[0x0],r6
8000aee2:	0c 93       	mov	r3,r6
8000aee4:	0c 91       	mov	r1,r6
8000aee6:	50 15       	stdsp	sp[0x4],r5
8000aee8:	08 92       	mov	r2,r4
8000aeea:	c9 c8       	rjmp	8000b022 <__sfvwrite_r+0x1ca>
8000aeec:	06 96       	mov	r6,r3
8000aeee:	08 91       	mov	r1,r4
8000aef0:	c0 48       	rjmp	8000aef8 <__sfvwrite_r+0xa0>
8000aef2:	60 03       	ld.w	r3,r0[0x0]
8000aef4:	60 16       	ld.w	r6,r0[0x4]
8000aef6:	2f 80       	sub	r0,-8
8000aef8:	58 06       	cp.w	r6,0
8000aefa:	cf c0       	breq	8000aef2 <__sfvwrite_r+0x9a>
8000aefc:	8e 68       	ld.sh	r8,r7[0xc]
8000aefe:	6e 24       	ld.w	r4,r7[0x8]
8000af00:	10 99       	mov	r9,r8
8000af02:	e2 19 02 00 	andl	r9,0x200,COH
8000af06:	c5 50       	breq	8000afb0 <__sfvwrite_r+0x158>
8000af08:	08 36       	cp.w	r6,r4
8000af0a:	c4 43       	brcs	8000af92 <__sfvwrite_r+0x13a>
8000af0c:	10 99       	mov	r9,r8
8000af0e:	e2 19 04 80 	andl	r9,0x480,COH
8000af12:	c4 00       	breq	8000af92 <__sfvwrite_r+0x13a>
8000af14:	6e 4b       	ld.w	r11,r7[0x10]
8000af16:	6e 09       	ld.w	r9,r7[0x0]
8000af18:	16 19       	sub	r9,r11
8000af1a:	50 09       	stdsp	sp[0x0],r9
8000af1c:	6e 59       	ld.w	r9,r7[0x14]
8000af1e:	10 9c       	mov	r12,r8
8000af20:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000af24:	30 28       	mov	r8,2
8000af26:	f4 08 0c 08 	divs	r8,r10,r8
8000af2a:	fa e9 00 04 	st.d	sp[4],r8
8000af2e:	10 94       	mov	r4,r8
8000af30:	40 09       	lddsp	r9,sp[0x0]
8000af32:	e2 1c 04 00 	andl	r12,0x400,COH
8000af36:	2f f9       	sub	r9,-1
8000af38:	0c 09       	add	r9,r6
8000af3a:	12 38       	cp.w	r8,r9
8000af3c:	f2 04 17 30 	movlo	r4,r9
8000af40:	58 0c       	cp.w	r12,0
8000af42:	c1 10       	breq	8000af64 <__sfvwrite_r+0x10c>
8000af44:	08 9b       	mov	r11,r4
8000af46:	0a 9c       	mov	r12,r5
8000af48:	fe b0 e0 6c 	rcall	80007020 <_malloc_r>
8000af4c:	18 92       	mov	r2,r12
8000af4e:	c1 40       	breq	8000af76 <__sfvwrite_r+0x11e>
8000af50:	40 0a       	lddsp	r10,sp[0x0]
8000af52:	6e 4b       	ld.w	r11,r7[0x10]
8000af54:	fe b0 e2 82 	rcall	80007458 <memcpy>
8000af58:	8e 68       	ld.sh	r8,r7[0xc]
8000af5a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000af5e:	a7 b8       	sbr	r8,0x7
8000af60:	ae 68       	st.h	r7[0xc],r8
8000af62:	c0 d8       	rjmp	8000af7c <__sfvwrite_r+0x124>
8000af64:	08 9a       	mov	r10,r4
8000af66:	0a 9c       	mov	r12,r5
8000af68:	fe b0 e3 24 	rcall	800075b0 <_realloc_r>
8000af6c:	18 92       	mov	r2,r12
8000af6e:	c0 71       	brne	8000af7c <__sfvwrite_r+0x124>
8000af70:	6e 4b       	ld.w	r11,r7[0x10]
8000af72:	0a 9c       	mov	r12,r5
8000af74:	ca ce       	rcall	8000accc <_free_r>
8000af76:	30 c8       	mov	r8,12
8000af78:	8b 38       	st.w	r5[0xc],r8
8000af7a:	cb 18       	rjmp	8000b0dc <__sfvwrite_r+0x284>
8000af7c:	40 0a       	lddsp	r10,sp[0x0]
8000af7e:	40 09       	lddsp	r9,sp[0x0]
8000af80:	e8 0a 01 0a 	sub	r10,r4,r10
8000af84:	e4 09 00 08 	add	r8,r2,r9
8000af88:	8f 54       	st.w	r7[0x14],r4
8000af8a:	8f 2a       	st.w	r7[0x8],r10
8000af8c:	8f 08       	st.w	r7[0x0],r8
8000af8e:	8f 42       	st.w	r7[0x10],r2
8000af90:	0c 94       	mov	r4,r6
8000af92:	08 36       	cp.w	r6,r4
8000af94:	ec 04 17 30 	movlo	r4,r6
8000af98:	06 9b       	mov	r11,r3
8000af9a:	08 9a       	mov	r10,r4
8000af9c:	6e 0c       	ld.w	r12,r7[0x0]
8000af9e:	c3 ad       	rcall	8000b212 <memmove>
8000afa0:	6e 08       	ld.w	r8,r7[0x0]
8000afa2:	08 08       	add	r8,r4
8000afa4:	8f 08       	st.w	r7[0x0],r8
8000afa6:	6e 28       	ld.w	r8,r7[0x8]
8000afa8:	08 18       	sub	r8,r4
8000afaa:	0c 94       	mov	r4,r6
8000afac:	8f 28       	st.w	r7[0x8],r8
8000afae:	c2 e8       	rjmp	8000b00a <__sfvwrite_r+0x1b2>
8000afb0:	08 36       	cp.w	r6,r4
8000afb2:	5f ba       	srhi	r10
8000afb4:	6e 0c       	ld.w	r12,r7[0x0]
8000afb6:	6e 48       	ld.w	r8,r7[0x10]
8000afb8:	10 3c       	cp.w	r12,r8
8000afba:	5f b8       	srhi	r8
8000afbc:	f5 e8 00 08 	and	r8,r10,r8
8000afc0:	f2 08 18 00 	cp.b	r8,r9
8000afc4:	c0 d0       	breq	8000afde <__sfvwrite_r+0x186>
8000afc6:	06 9b       	mov	r11,r3
8000afc8:	08 9a       	mov	r10,r4
8000afca:	c2 4d       	rcall	8000b212 <memmove>
8000afcc:	6e 08       	ld.w	r8,r7[0x0]
8000afce:	08 08       	add	r8,r4
8000afd0:	0e 9b       	mov	r11,r7
8000afd2:	8f 08       	st.w	r7[0x0],r8
8000afd4:	0a 9c       	mov	r12,r5
8000afd6:	fe b0 fd 09 	rcall	8000a9e8 <_fflush_r>
8000afda:	c1 80       	breq	8000b00a <__sfvwrite_r+0x1b2>
8000afdc:	c8 08       	rjmp	8000b0dc <__sfvwrite_r+0x284>
8000afde:	6e 59       	ld.w	r9,r7[0x14]
8000afe0:	12 36       	cp.w	r6,r9
8000afe2:	c0 a3       	brcs	8000aff6 <__sfvwrite_r+0x19e>
8000afe4:	6e a8       	ld.w	r8,r7[0x28]
8000afe6:	06 9a       	mov	r10,r3
8000afe8:	6e 8b       	ld.w	r11,r7[0x20]
8000afea:	0a 9c       	mov	r12,r5
8000afec:	5d 18       	icall	r8
8000afee:	18 94       	mov	r4,r12
8000aff0:	e0 89 00 0d 	brgt	8000b00a <__sfvwrite_r+0x1b2>
8000aff4:	c7 48       	rjmp	8000b0dc <__sfvwrite_r+0x284>
8000aff6:	0c 9a       	mov	r10,r6
8000aff8:	06 9b       	mov	r11,r3
8000affa:	c0 cd       	rcall	8000b212 <memmove>
8000affc:	6e 08       	ld.w	r8,r7[0x0]
8000affe:	0c 08       	add	r8,r6
8000b000:	0c 94       	mov	r4,r6
8000b002:	8f 08       	st.w	r7[0x0],r8
8000b004:	6e 28       	ld.w	r8,r7[0x8]
8000b006:	0c 18       	sub	r8,r6
8000b008:	8f 28       	st.w	r7[0x8],r8
8000b00a:	62 28       	ld.w	r8,r1[0x8]
8000b00c:	08 18       	sub	r8,r4
8000b00e:	83 28       	st.w	r1[0x8],r8
8000b010:	c6 b0       	breq	8000b0e6 <__sfvwrite_r+0x28e>
8000b012:	08 16       	sub	r6,r4
8000b014:	08 03       	add	r3,r4
8000b016:	c7 1b       	rjmp	8000aef8 <__sfvwrite_r+0xa0>
8000b018:	60 03       	ld.w	r3,r0[0x0]
8000b01a:	60 11       	ld.w	r1,r0[0x4]
8000b01c:	30 08       	mov	r8,0
8000b01e:	2f 80       	sub	r0,-8
8000b020:	50 08       	stdsp	sp[0x0],r8
8000b022:	58 01       	cp.w	r1,0
8000b024:	cf a0       	breq	8000b018 <__sfvwrite_r+0x1c0>
8000b026:	40 0a       	lddsp	r10,sp[0x0]
8000b028:	58 0a       	cp.w	r10,0
8000b02a:	c1 41       	brne	8000b052 <__sfvwrite_r+0x1fa>
8000b02c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b030:	02 9a       	mov	r10,r1
8000b032:	30 ab       	mov	r11,10
8000b034:	06 9c       	mov	r12,r3
8000b036:	ce 3c       	rcall	8000b1fc <memchr>
8000b038:	f8 c8 ff ff 	sub	r8,r12,-1
8000b03c:	58 0c       	cp.w	r12,0
8000b03e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b042:	f9 b9 01 01 	movne	r9,1
8000b046:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b04a:	f9 b8 00 01 	moveq	r8,1
8000b04e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b052:	02 36       	cp.w	r6,r1
8000b054:	ec 04 17 80 	movls	r4,r6
8000b058:	e2 04 17 b0 	movhi	r4,r1
8000b05c:	6e 59       	ld.w	r9,r7[0x14]
8000b05e:	6e 25       	ld.w	r5,r7[0x8]
8000b060:	f2 05 00 05 	add	r5,r9,r5
8000b064:	0a 34       	cp.w	r4,r5
8000b066:	5f 9a       	srgt	r10
8000b068:	6e 0c       	ld.w	r12,r7[0x0]
8000b06a:	6e 48       	ld.w	r8,r7[0x10]
8000b06c:	10 3c       	cp.w	r12,r8
8000b06e:	5f b8       	srhi	r8
8000b070:	f5 e8 00 08 	and	r8,r10,r8
8000b074:	30 0a       	mov	r10,0
8000b076:	f4 08 18 00 	cp.b	r8,r10
8000b07a:	c0 d0       	breq	8000b094 <__sfvwrite_r+0x23c>
8000b07c:	06 9b       	mov	r11,r3
8000b07e:	0a 9a       	mov	r10,r5
8000b080:	cc 9c       	rcall	8000b212 <memmove>
8000b082:	6e 08       	ld.w	r8,r7[0x0]
8000b084:	0a 08       	add	r8,r5
8000b086:	0e 9b       	mov	r11,r7
8000b088:	8f 08       	st.w	r7[0x0],r8
8000b08a:	40 1c       	lddsp	r12,sp[0x4]
8000b08c:	fe b0 fc ae 	rcall	8000a9e8 <_fflush_r>
8000b090:	c1 70       	breq	8000b0be <__sfvwrite_r+0x266>
8000b092:	c2 58       	rjmp	8000b0dc <__sfvwrite_r+0x284>
8000b094:	12 34       	cp.w	r4,r9
8000b096:	c0 a5       	brlt	8000b0aa <__sfvwrite_r+0x252>
8000b098:	6e a8       	ld.w	r8,r7[0x28]
8000b09a:	06 9a       	mov	r10,r3
8000b09c:	6e 8b       	ld.w	r11,r7[0x20]
8000b09e:	40 1c       	lddsp	r12,sp[0x4]
8000b0a0:	5d 18       	icall	r8
8000b0a2:	18 95       	mov	r5,r12
8000b0a4:	e0 89 00 0d 	brgt	8000b0be <__sfvwrite_r+0x266>
8000b0a8:	c1 a8       	rjmp	8000b0dc <__sfvwrite_r+0x284>
8000b0aa:	08 9a       	mov	r10,r4
8000b0ac:	06 9b       	mov	r11,r3
8000b0ae:	cb 2c       	rcall	8000b212 <memmove>
8000b0b0:	6e 08       	ld.w	r8,r7[0x0]
8000b0b2:	08 08       	add	r8,r4
8000b0b4:	08 95       	mov	r5,r4
8000b0b6:	8f 08       	st.w	r7[0x0],r8
8000b0b8:	6e 28       	ld.w	r8,r7[0x8]
8000b0ba:	08 18       	sub	r8,r4
8000b0bc:	8f 28       	st.w	r7[0x8],r8
8000b0be:	0a 16       	sub	r6,r5
8000b0c0:	c0 71       	brne	8000b0ce <__sfvwrite_r+0x276>
8000b0c2:	0e 9b       	mov	r11,r7
8000b0c4:	40 1c       	lddsp	r12,sp[0x4]
8000b0c6:	fe b0 fc 91 	rcall	8000a9e8 <_fflush_r>
8000b0ca:	c0 91       	brne	8000b0dc <__sfvwrite_r+0x284>
8000b0cc:	50 06       	stdsp	sp[0x0],r6
8000b0ce:	64 28       	ld.w	r8,r2[0x8]
8000b0d0:	0a 18       	sub	r8,r5
8000b0d2:	85 28       	st.w	r2[0x8],r8
8000b0d4:	c0 90       	breq	8000b0e6 <__sfvwrite_r+0x28e>
8000b0d6:	0a 11       	sub	r1,r5
8000b0d8:	0a 03       	add	r3,r5
8000b0da:	ca 4b       	rjmp	8000b022 <__sfvwrite_r+0x1ca>
8000b0dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b0de:	a7 a8       	sbr	r8,0x6
8000b0e0:	ae 68       	st.h	r7[0xc],r8
8000b0e2:	3f fc       	mov	r12,-1
8000b0e4:	c0 28       	rjmp	8000b0e8 <__sfvwrite_r+0x290>
8000b0e6:	30 0c       	mov	r12,0
8000b0e8:	2f dd       	sub	sp,-12
8000b0ea:	d8 32       	popm	r0-r7,pc

8000b0ec <_fwalk>:
8000b0ec:	d4 31       	pushm	r0-r7,lr
8000b0ee:	30 05       	mov	r5,0
8000b0f0:	16 91       	mov	r1,r11
8000b0f2:	f8 c7 ff 28 	sub	r7,r12,-216
8000b0f6:	0a 92       	mov	r2,r5
8000b0f8:	fe b0 fc fe 	rcall	8000aaf4 <__sfp_lock_acquire>
8000b0fc:	3f f3       	mov	r3,-1
8000b0fe:	c1 68       	rjmp	8000b12a <_fwalk+0x3e>
8000b100:	6e 26       	ld.w	r6,r7[0x8]
8000b102:	6e 14       	ld.w	r4,r7[0x4]
8000b104:	2f 46       	sub	r6,-12
8000b106:	c0 c8       	rjmp	8000b11e <_fwalk+0x32>
8000b108:	8c 08       	ld.sh	r8,r6[0x0]
8000b10a:	e4 08 19 00 	cp.h	r8,r2
8000b10e:	c0 70       	breq	8000b11c <_fwalk+0x30>
8000b110:	8c 18       	ld.sh	r8,r6[0x2]
8000b112:	e6 08 19 00 	cp.h	r8,r3
8000b116:	c0 30       	breq	8000b11c <_fwalk+0x30>
8000b118:	5d 11       	icall	r1
8000b11a:	18 45       	or	r5,r12
8000b11c:	2a 46       	sub	r6,-92
8000b11e:	20 14       	sub	r4,1
8000b120:	ec cc 00 0c 	sub	r12,r6,12
8000b124:	58 04       	cp.w	r4,0
8000b126:	cf 14       	brge	8000b108 <_fwalk+0x1c>
8000b128:	6e 07       	ld.w	r7,r7[0x0]
8000b12a:	58 07       	cp.w	r7,0
8000b12c:	ce a1       	brne	8000b100 <_fwalk+0x14>
8000b12e:	fe b0 fc e4 	rcall	8000aaf6 <__sfp_lock_release>
8000b132:	0a 9c       	mov	r12,r5
8000b134:	d8 32       	popm	r0-r7,pc
8000b136:	d7 03       	nop

8000b138 <_localeconv_r>:
8000b138:	fe cc d5 1c 	sub	r12,pc,-10980
8000b13c:	5e fc       	retal	r12
8000b13e:	d7 03       	nop

8000b140 <__smakebuf_r>:
8000b140:	d4 21       	pushm	r4-r7,lr
8000b142:	20 fd       	sub	sp,60
8000b144:	96 68       	ld.sh	r8,r11[0xc]
8000b146:	16 97       	mov	r7,r11
8000b148:	18 96       	mov	r6,r12
8000b14a:	e2 18 00 02 	andl	r8,0x2,COH
8000b14e:	c3 d1       	brne	8000b1c8 <__smakebuf_r+0x88>
8000b150:	96 7b       	ld.sh	r11,r11[0xe]
8000b152:	f0 0b 19 00 	cp.h	r11,r8
8000b156:	c0 55       	brlt	8000b160 <__smakebuf_r+0x20>
8000b158:	1a 9a       	mov	r10,sp
8000b15a:	e0 a0 04 81 	rcall	8000ba5c <_fstat_r>
8000b15e:	c0 f4       	brge	8000b17c <__smakebuf_r+0x3c>
8000b160:	8e 65       	ld.sh	r5,r7[0xc]
8000b162:	0a 98       	mov	r8,r5
8000b164:	ab b8       	sbr	r8,0xb
8000b166:	e2 15 00 80 	andl	r5,0x80,COH
8000b16a:	ae 68       	st.h	r7[0xc],r8
8000b16c:	30 04       	mov	r4,0
8000b16e:	e0 68 04 00 	mov	r8,1024
8000b172:	f9 b5 01 40 	movne	r5,64
8000b176:	f0 05 17 00 	moveq	r5,r8
8000b17a:	c1 c8       	rjmp	8000b1b2 <__smakebuf_r+0x72>
8000b17c:	40 18       	lddsp	r8,sp[0x4]
8000b17e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b182:	e0 48 20 00 	cp.w	r8,8192
8000b186:	5f 04       	sreq	r4
8000b188:	e0 48 80 00 	cp.w	r8,32768
8000b18c:	c0 e1       	brne	8000b1a8 <__smakebuf_r+0x68>
8000b18e:	6e b9       	ld.w	r9,r7[0x2c]
8000b190:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b194:	10 39       	cp.w	r9,r8
8000b196:	c0 91       	brne	8000b1a8 <__smakebuf_r+0x68>
8000b198:	8e 68       	ld.sh	r8,r7[0xc]
8000b19a:	e0 65 04 00 	mov	r5,1024
8000b19e:	ab a8       	sbr	r8,0xa
8000b1a0:	ef 45 00 50 	st.w	r7[80],r5
8000b1a4:	ae 68       	st.h	r7[0xc],r8
8000b1a6:	c0 68       	rjmp	8000b1b2 <__smakebuf_r+0x72>
8000b1a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b1aa:	e0 65 04 00 	mov	r5,1024
8000b1ae:	ab b8       	sbr	r8,0xb
8000b1b0:	ae 68       	st.h	r7[0xc],r8
8000b1b2:	0a 9b       	mov	r11,r5
8000b1b4:	0c 9c       	mov	r12,r6
8000b1b6:	fe b0 df 35 	rcall	80007020 <_malloc_r>
8000b1ba:	8e 68       	ld.sh	r8,r7[0xc]
8000b1bc:	c0 d1       	brne	8000b1d6 <__smakebuf_r+0x96>
8000b1be:	ed b8 00 09 	bld	r8,0x9
8000b1c2:	c1 b0       	breq	8000b1f8 <__smakebuf_r+0xb8>
8000b1c4:	a1 b8       	sbr	r8,0x1
8000b1c6:	ae 68       	st.h	r7[0xc],r8
8000b1c8:	ee c8 ff b9 	sub	r8,r7,-71
8000b1cc:	8f 48       	st.w	r7[0x10],r8
8000b1ce:	8f 08       	st.w	r7[0x0],r8
8000b1d0:	30 18       	mov	r8,1
8000b1d2:	8f 58       	st.w	r7[0x14],r8
8000b1d4:	c1 28       	rjmp	8000b1f8 <__smakebuf_r+0xb8>
8000b1d6:	a7 b8       	sbr	r8,0x7
8000b1d8:	8f 4c       	st.w	r7[0x10],r12
8000b1da:	ae 68       	st.h	r7[0xc],r8
8000b1dc:	8f 55       	st.w	r7[0x14],r5
8000b1de:	fe c8 06 e6 	sub	r8,pc,1766
8000b1e2:	8f 0c       	st.w	r7[0x0],r12
8000b1e4:	8d a8       	st.w	r6[0x28],r8
8000b1e6:	58 04       	cp.w	r4,0
8000b1e8:	c0 80       	breq	8000b1f8 <__smakebuf_r+0xb8>
8000b1ea:	8e 7c       	ld.sh	r12,r7[0xe]
8000b1ec:	fe b0 e3 94 	rcall	80007914 <isatty>
8000b1f0:	c0 40       	breq	8000b1f8 <__smakebuf_r+0xb8>
8000b1f2:	8e 68       	ld.sh	r8,r7[0xc]
8000b1f4:	a1 a8       	sbr	r8,0x0
8000b1f6:	ae 68       	st.h	r7[0xc],r8
8000b1f8:	2f 1d       	sub	sp,-60
8000b1fa:	d8 22       	popm	r4-r7,pc

8000b1fc <memchr>:
8000b1fc:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b200:	c0 68       	rjmp	8000b20c <memchr+0x10>
8000b202:	20 1a       	sub	r10,1
8000b204:	19 88       	ld.ub	r8,r12[0x0]
8000b206:	16 38       	cp.w	r8,r11
8000b208:	5e 0c       	reteq	r12
8000b20a:	2f fc       	sub	r12,-1
8000b20c:	58 0a       	cp.w	r10,0
8000b20e:	cf a1       	brne	8000b202 <memchr+0x6>
8000b210:	5e fa       	retal	r10

8000b212 <memmove>:
8000b212:	d4 01       	pushm	lr
8000b214:	18 3b       	cp.w	r11,r12
8000b216:	c1 92       	brcc	8000b248 <memmove+0x36>
8000b218:	f6 0a 00 09 	add	r9,r11,r10
8000b21c:	12 3c       	cp.w	r12,r9
8000b21e:	c1 52       	brcc	8000b248 <memmove+0x36>
8000b220:	f8 0a 00 0b 	add	r11,r12,r10
8000b224:	30 08       	mov	r8,0
8000b226:	c0 68       	rjmp	8000b232 <memmove+0x20>
8000b228:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b22c:	20 1a       	sub	r10,1
8000b22e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b232:	20 18       	sub	r8,1
8000b234:	58 0a       	cp.w	r10,0
8000b236:	cf 91       	brne	8000b228 <memmove+0x16>
8000b238:	d8 02       	popm	pc
8000b23a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b23e:	20 1a       	sub	r10,1
8000b240:	f8 08 0b 09 	st.b	r12[r8],r9
8000b244:	2f f8       	sub	r8,-1
8000b246:	c0 28       	rjmp	8000b24a <memmove+0x38>
8000b248:	30 08       	mov	r8,0
8000b24a:	58 0a       	cp.w	r10,0
8000b24c:	cf 71       	brne	8000b23a <memmove+0x28>
8000b24e:	d8 02       	popm	pc

8000b250 <__hi0bits>:
8000b250:	18 98       	mov	r8,r12
8000b252:	e0 1c 00 00 	andl	r12,0x0
8000b256:	f0 09 15 10 	lsl	r9,r8,0x10
8000b25a:	58 0c       	cp.w	r12,0
8000b25c:	f2 08 17 00 	moveq	r8,r9
8000b260:	f9 bc 00 10 	moveq	r12,16
8000b264:	f9 bc 01 00 	movne	r12,0
8000b268:	10 9a       	mov	r10,r8
8000b26a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b26e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b272:	f7 bc 00 f8 	subeq	r12,-8
8000b276:	f2 08 17 00 	moveq	r8,r9
8000b27a:	10 9a       	mov	r10,r8
8000b27c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b280:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b284:	f7 bc 00 fc 	subeq	r12,-4
8000b288:	f2 08 17 00 	moveq	r8,r9
8000b28c:	10 9a       	mov	r10,r8
8000b28e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b292:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b296:	f7 bc 00 fe 	subeq	r12,-2
8000b29a:	f2 08 17 00 	moveq	r8,r9
8000b29e:	58 08       	cp.w	r8,0
8000b2a0:	5e 5c       	retlt	r12
8000b2a2:	ed b8 00 1e 	bld	r8,0x1e
8000b2a6:	f9 bc 01 20 	movne	r12,32
8000b2aa:	f7 bc 00 ff 	subeq	r12,-1
8000b2ae:	5e fc       	retal	r12

8000b2b0 <__lo0bits>:
8000b2b0:	18 99       	mov	r9,r12
8000b2b2:	78 08       	ld.w	r8,r12[0x0]
8000b2b4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b2b8:	c1 50       	breq	8000b2e2 <__lo0bits+0x32>
8000b2ba:	ed b8 00 00 	bld	r8,0x0
8000b2be:	c0 21       	brne	8000b2c2 <__lo0bits+0x12>
8000b2c0:	5e fd       	retal	0
8000b2c2:	10 9b       	mov	r11,r8
8000b2c4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b2c8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b2cc:	a3 88       	lsr	r8,0x2
8000b2ce:	58 0b       	cp.w	r11,0
8000b2d0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b2d4:	f9 bc 01 01 	movne	r12,1
8000b2d8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b2dc:	f9 bc 00 02 	moveq	r12,2
8000b2e0:	5e fc       	retal	r12
8000b2e2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b2e6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b2ea:	58 0a       	cp.w	r10,0
8000b2ec:	f6 08 17 00 	moveq	r8,r11
8000b2f0:	f9 bc 00 10 	moveq	r12,16
8000b2f4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b2f8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b2fc:	58 0b       	cp.w	r11,0
8000b2fe:	f7 bc 00 f8 	subeq	r12,-8
8000b302:	f4 08 17 00 	moveq	r8,r10
8000b306:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b30a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b30e:	58 0b       	cp.w	r11,0
8000b310:	f7 bc 00 fc 	subeq	r12,-4
8000b314:	f4 08 17 00 	moveq	r8,r10
8000b318:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b31c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b320:	58 0b       	cp.w	r11,0
8000b322:	f7 bc 00 fe 	subeq	r12,-2
8000b326:	f4 08 17 00 	moveq	r8,r10
8000b32a:	ed b8 00 00 	bld	r8,0x0
8000b32e:	c0 60       	breq	8000b33a <__lo0bits+0x8a>
8000b330:	a1 98       	lsr	r8,0x1
8000b332:	c0 31       	brne	8000b338 <__lo0bits+0x88>
8000b334:	32 0c       	mov	r12,32
8000b336:	5e fc       	retal	r12
8000b338:	2f fc       	sub	r12,-1
8000b33a:	93 08       	st.w	r9[0x0],r8
8000b33c:	5e fc       	retal	r12

8000b33e <__mcmp>:
8000b33e:	d4 01       	pushm	lr
8000b340:	18 98       	mov	r8,r12
8000b342:	76 49       	ld.w	r9,r11[0x10]
8000b344:	78 4c       	ld.w	r12,r12[0x10]
8000b346:	12 1c       	sub	r12,r9
8000b348:	c1 31       	brne	8000b36e <__mcmp+0x30>
8000b34a:	2f b9       	sub	r9,-5
8000b34c:	a3 69       	lsl	r9,0x2
8000b34e:	12 0b       	add	r11,r9
8000b350:	f0 09 00 09 	add	r9,r8,r9
8000b354:	2e c8       	sub	r8,-20
8000b356:	13 4e       	ld.w	lr,--r9
8000b358:	17 4a       	ld.w	r10,--r11
8000b35a:	14 3e       	cp.w	lr,r10
8000b35c:	c0 60       	breq	8000b368 <__mcmp+0x2a>
8000b35e:	f9 bc 03 ff 	movlo	r12,-1
8000b362:	f9 bc 02 01 	movhs	r12,1
8000b366:	d8 02       	popm	pc
8000b368:	10 39       	cp.w	r9,r8
8000b36a:	fe 9b ff f6 	brhi	8000b356 <__mcmp+0x18>
8000b36e:	d8 02       	popm	pc

8000b370 <_Bfree>:
8000b370:	d4 21       	pushm	r4-r7,lr
8000b372:	18 97       	mov	r7,r12
8000b374:	16 95       	mov	r5,r11
8000b376:	78 96       	ld.w	r6,r12[0x24]
8000b378:	58 06       	cp.w	r6,0
8000b37a:	c0 91       	brne	8000b38c <_Bfree+0x1c>
8000b37c:	31 0c       	mov	r12,16
8000b37e:	fe b0 de 49 	rcall	80007010 <malloc>
8000b382:	99 36       	st.w	r12[0xc],r6
8000b384:	8f 9c       	st.w	r7[0x24],r12
8000b386:	99 16       	st.w	r12[0x4],r6
8000b388:	99 26       	st.w	r12[0x8],r6
8000b38a:	99 06       	st.w	r12[0x0],r6
8000b38c:	58 05       	cp.w	r5,0
8000b38e:	c0 90       	breq	8000b3a0 <_Bfree+0x30>
8000b390:	6a 19       	ld.w	r9,r5[0x4]
8000b392:	6e 98       	ld.w	r8,r7[0x24]
8000b394:	70 38       	ld.w	r8,r8[0xc]
8000b396:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b39a:	8b 0a       	st.w	r5[0x0],r10
8000b39c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b3a0:	d8 22       	popm	r4-r7,pc
8000b3a2:	d7 03       	nop

8000b3a4 <_Balloc>:
8000b3a4:	d4 21       	pushm	r4-r7,lr
8000b3a6:	18 97       	mov	r7,r12
8000b3a8:	16 96       	mov	r6,r11
8000b3aa:	78 95       	ld.w	r5,r12[0x24]
8000b3ac:	58 05       	cp.w	r5,0
8000b3ae:	c0 91       	brne	8000b3c0 <_Balloc+0x1c>
8000b3b0:	31 0c       	mov	r12,16
8000b3b2:	fe b0 de 2f 	rcall	80007010 <malloc>
8000b3b6:	99 35       	st.w	r12[0xc],r5
8000b3b8:	8f 9c       	st.w	r7[0x24],r12
8000b3ba:	99 15       	st.w	r12[0x4],r5
8000b3bc:	99 25       	st.w	r12[0x8],r5
8000b3be:	99 05       	st.w	r12[0x0],r5
8000b3c0:	6e 95       	ld.w	r5,r7[0x24]
8000b3c2:	6a 38       	ld.w	r8,r5[0xc]
8000b3c4:	58 08       	cp.w	r8,0
8000b3c6:	c0 b1       	brne	8000b3dc <_Balloc+0x38>
8000b3c8:	31 0a       	mov	r10,16
8000b3ca:	30 4b       	mov	r11,4
8000b3cc:	0e 9c       	mov	r12,r7
8000b3ce:	e0 a0 02 a7 	rcall	8000b91c <_calloc_r>
8000b3d2:	8b 3c       	st.w	r5[0xc],r12
8000b3d4:	6e 98       	ld.w	r8,r7[0x24]
8000b3d6:	70 3c       	ld.w	r12,r8[0xc]
8000b3d8:	58 0c       	cp.w	r12,0
8000b3da:	c1 b0       	breq	8000b410 <_Balloc+0x6c>
8000b3dc:	6e 98       	ld.w	r8,r7[0x24]
8000b3de:	70 38       	ld.w	r8,r8[0xc]
8000b3e0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b3e4:	70 0c       	ld.w	r12,r8[0x0]
8000b3e6:	58 0c       	cp.w	r12,0
8000b3e8:	c0 40       	breq	8000b3f0 <_Balloc+0x4c>
8000b3ea:	78 09       	ld.w	r9,r12[0x0]
8000b3ec:	91 09       	st.w	r8[0x0],r9
8000b3ee:	c0 e8       	rjmp	8000b40a <_Balloc+0x66>
8000b3f0:	0e 9c       	mov	r12,r7
8000b3f2:	30 17       	mov	r7,1
8000b3f4:	0e 9b       	mov	r11,r7
8000b3f6:	ee 06 09 47 	lsl	r7,r7,r6
8000b3fa:	ee ca ff fb 	sub	r10,r7,-5
8000b3fe:	a3 6a       	lsl	r10,0x2
8000b400:	e0 a0 02 8e 	rcall	8000b91c <_calloc_r>
8000b404:	c0 60       	breq	8000b410 <_Balloc+0x6c>
8000b406:	99 16       	st.w	r12[0x4],r6
8000b408:	99 27       	st.w	r12[0x8],r7
8000b40a:	30 08       	mov	r8,0
8000b40c:	99 38       	st.w	r12[0xc],r8
8000b40e:	99 48       	st.w	r12[0x10],r8
8000b410:	d8 22       	popm	r4-r7,pc
8000b412:	d7 03       	nop

8000b414 <__d2b>:
8000b414:	d4 31       	pushm	r0-r7,lr
8000b416:	20 2d       	sub	sp,8
8000b418:	16 93       	mov	r3,r11
8000b41a:	12 96       	mov	r6,r9
8000b41c:	10 95       	mov	r5,r8
8000b41e:	14 92       	mov	r2,r10
8000b420:	30 1b       	mov	r11,1
8000b422:	cc 1f       	rcall	8000b3a4 <_Balloc>
8000b424:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b428:	50 09       	stdsp	sp[0x0],r9
8000b42a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b42e:	b5 a9       	sbr	r9,0x14
8000b430:	f0 01 16 14 	lsr	r1,r8,0x14
8000b434:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b438:	18 94       	mov	r4,r12
8000b43a:	58 02       	cp.w	r2,0
8000b43c:	c1 d0       	breq	8000b476 <__d2b+0x62>
8000b43e:	fa cc ff f8 	sub	r12,sp,-8
8000b442:	18 d2       	st.w	--r12,r2
8000b444:	c3 6f       	rcall	8000b2b0 <__lo0bits>
8000b446:	40 18       	lddsp	r8,sp[0x4]
8000b448:	c0 d0       	breq	8000b462 <__d2b+0x4e>
8000b44a:	40 09       	lddsp	r9,sp[0x0]
8000b44c:	f8 0a 11 20 	rsub	r10,r12,32
8000b450:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b454:	f5 e8 10 08 	or	r8,r10,r8
8000b458:	89 58       	st.w	r4[0x14],r8
8000b45a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b45e:	50 09       	stdsp	sp[0x0],r9
8000b460:	c0 28       	rjmp	8000b464 <__d2b+0x50>
8000b462:	89 58       	st.w	r4[0x14],r8
8000b464:	40 08       	lddsp	r8,sp[0x0]
8000b466:	58 08       	cp.w	r8,0
8000b468:	f9 b3 01 02 	movne	r3,2
8000b46c:	f9 b3 00 01 	moveq	r3,1
8000b470:	89 68       	st.w	r4[0x18],r8
8000b472:	89 43       	st.w	r4[0x10],r3
8000b474:	c0 88       	rjmp	8000b484 <__d2b+0x70>
8000b476:	1a 9c       	mov	r12,sp
8000b478:	c1 cf       	rcall	8000b2b0 <__lo0bits>
8000b47a:	30 13       	mov	r3,1
8000b47c:	40 08       	lddsp	r8,sp[0x0]
8000b47e:	2e 0c       	sub	r12,-32
8000b480:	89 43       	st.w	r4[0x10],r3
8000b482:	89 58       	st.w	r4[0x14],r8
8000b484:	58 01       	cp.w	r1,0
8000b486:	c0 90       	breq	8000b498 <__d2b+0x84>
8000b488:	e2 c1 04 33 	sub	r1,r1,1075
8000b48c:	18 01       	add	r1,r12
8000b48e:	8d 01       	st.w	r6[0x0],r1
8000b490:	f8 0c 11 35 	rsub	r12,r12,53
8000b494:	8b 0c       	st.w	r5[0x0],r12
8000b496:	c0 c8       	rjmp	8000b4ae <__d2b+0x9a>
8000b498:	e6 c8 ff fc 	sub	r8,r3,-4
8000b49c:	f8 cc 04 32 	sub	r12,r12,1074
8000b4a0:	a5 73       	lsl	r3,0x5
8000b4a2:	8d 0c       	st.w	r6[0x0],r12
8000b4a4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b4a8:	cd 4e       	rcall	8000b250 <__hi0bits>
8000b4aa:	18 13       	sub	r3,r12
8000b4ac:	8b 03       	st.w	r5[0x0],r3
8000b4ae:	08 9c       	mov	r12,r4
8000b4b0:	2f ed       	sub	sp,-8
8000b4b2:	d8 32       	popm	r0-r7,pc

8000b4b4 <__mdiff>:
8000b4b4:	d4 31       	pushm	r0-r7,lr
8000b4b6:	74 48       	ld.w	r8,r10[0x10]
8000b4b8:	76 45       	ld.w	r5,r11[0x10]
8000b4ba:	16 97       	mov	r7,r11
8000b4bc:	14 96       	mov	r6,r10
8000b4be:	10 15       	sub	r5,r8
8000b4c0:	c1 31       	brne	8000b4e6 <__mdiff+0x32>
8000b4c2:	2f b8       	sub	r8,-5
8000b4c4:	ee ce ff ec 	sub	lr,r7,-20
8000b4c8:	a3 68       	lsl	r8,0x2
8000b4ca:	f4 08 00 0b 	add	r11,r10,r8
8000b4ce:	ee 08 00 08 	add	r8,r7,r8
8000b4d2:	11 4a       	ld.w	r10,--r8
8000b4d4:	17 49       	ld.w	r9,--r11
8000b4d6:	12 3a       	cp.w	r10,r9
8000b4d8:	c0 30       	breq	8000b4de <__mdiff+0x2a>
8000b4da:	c0 e2       	brcc	8000b4f6 <__mdiff+0x42>
8000b4dc:	c0 78       	rjmp	8000b4ea <__mdiff+0x36>
8000b4de:	1c 38       	cp.w	r8,lr
8000b4e0:	fe 9b ff f9 	brhi	8000b4d2 <__mdiff+0x1e>
8000b4e4:	c4 98       	rjmp	8000b576 <__mdiff+0xc2>
8000b4e6:	58 05       	cp.w	r5,0
8000b4e8:	c0 64       	brge	8000b4f4 <__mdiff+0x40>
8000b4ea:	0e 98       	mov	r8,r7
8000b4ec:	30 15       	mov	r5,1
8000b4ee:	0c 97       	mov	r7,r6
8000b4f0:	10 96       	mov	r6,r8
8000b4f2:	c0 28       	rjmp	8000b4f6 <__mdiff+0x42>
8000b4f4:	30 05       	mov	r5,0
8000b4f6:	6e 1b       	ld.w	r11,r7[0x4]
8000b4f8:	c5 6f       	rcall	8000b3a4 <_Balloc>
8000b4fa:	6e 49       	ld.w	r9,r7[0x10]
8000b4fc:	6c 44       	ld.w	r4,r6[0x10]
8000b4fe:	99 35       	st.w	r12[0xc],r5
8000b500:	2f b4       	sub	r4,-5
8000b502:	f2 c5 ff fb 	sub	r5,r9,-5
8000b506:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b50a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b50e:	2e c6       	sub	r6,-20
8000b510:	2e c7       	sub	r7,-20
8000b512:	f8 c8 ff ec 	sub	r8,r12,-20
8000b516:	30 0a       	mov	r10,0
8000b518:	0f 0e       	ld.w	lr,r7++
8000b51a:	0d 0b       	ld.w	r11,r6++
8000b51c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b520:	f6 03 16 10 	lsr	r3,r11,0x10
8000b524:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b528:	e4 03 01 03 	sub	r3,r2,r3
8000b52c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b530:	fc 0b 01 0b 	sub	r11,lr,r11
8000b534:	f6 0a 00 0a 	add	r10,r11,r10
8000b538:	b0 1a       	st.h	r8[0x2],r10
8000b53a:	b1 4a       	asr	r10,0x10
8000b53c:	e6 0a 00 0a 	add	r10,r3,r10
8000b540:	b0 0a       	st.h	r8[0x0],r10
8000b542:	2f c8       	sub	r8,-4
8000b544:	b1 4a       	asr	r10,0x10
8000b546:	08 36       	cp.w	r6,r4
8000b548:	ce 83       	brcs	8000b518 <__mdiff+0x64>
8000b54a:	c0 d8       	rjmp	8000b564 <__mdiff+0xb0>
8000b54c:	0f 0b       	ld.w	r11,r7++
8000b54e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b552:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b556:	16 0a       	add	r10,r11
8000b558:	b0 1a       	st.h	r8[0x2],r10
8000b55a:	b1 4a       	asr	r10,0x10
8000b55c:	1c 0a       	add	r10,lr
8000b55e:	b0 0a       	st.h	r8[0x0],r10
8000b560:	2f c8       	sub	r8,-4
8000b562:	b1 4a       	asr	r10,0x10
8000b564:	0a 37       	cp.w	r7,r5
8000b566:	cf 33       	brcs	8000b54c <__mdiff+0x98>
8000b568:	c0 28       	rjmp	8000b56c <__mdiff+0xb8>
8000b56a:	20 19       	sub	r9,1
8000b56c:	11 4a       	ld.w	r10,--r8
8000b56e:	58 0a       	cp.w	r10,0
8000b570:	cf d0       	breq	8000b56a <__mdiff+0xb6>
8000b572:	99 49       	st.w	r12[0x10],r9
8000b574:	d8 32       	popm	r0-r7,pc
8000b576:	30 0b       	mov	r11,0
8000b578:	c1 6f       	rcall	8000b3a4 <_Balloc>
8000b57a:	30 18       	mov	r8,1
8000b57c:	99 48       	st.w	r12[0x10],r8
8000b57e:	30 08       	mov	r8,0
8000b580:	99 58       	st.w	r12[0x14],r8
8000b582:	d8 32       	popm	r0-r7,pc

8000b584 <__lshift>:
8000b584:	d4 31       	pushm	r0-r7,lr
8000b586:	16 97       	mov	r7,r11
8000b588:	76 46       	ld.w	r6,r11[0x10]
8000b58a:	f4 02 14 05 	asr	r2,r10,0x5
8000b58e:	2f f6       	sub	r6,-1
8000b590:	14 93       	mov	r3,r10
8000b592:	18 94       	mov	r4,r12
8000b594:	04 06       	add	r6,r2
8000b596:	76 1b       	ld.w	r11,r11[0x4]
8000b598:	6e 28       	ld.w	r8,r7[0x8]
8000b59a:	c0 38       	rjmp	8000b5a0 <__lshift+0x1c>
8000b59c:	2f fb       	sub	r11,-1
8000b59e:	a1 78       	lsl	r8,0x1
8000b5a0:	10 36       	cp.w	r6,r8
8000b5a2:	fe 99 ff fd 	brgt	8000b59c <__lshift+0x18>
8000b5a6:	08 9c       	mov	r12,r4
8000b5a8:	cf ee       	rcall	8000b3a4 <_Balloc>
8000b5aa:	30 09       	mov	r9,0
8000b5ac:	18 95       	mov	r5,r12
8000b5ae:	f8 c8 ff ec 	sub	r8,r12,-20
8000b5b2:	12 9a       	mov	r10,r9
8000b5b4:	c0 38       	rjmp	8000b5ba <__lshift+0x36>
8000b5b6:	10 aa       	st.w	r8++,r10
8000b5b8:	2f f9       	sub	r9,-1
8000b5ba:	04 39       	cp.w	r9,r2
8000b5bc:	cf d5       	brlt	8000b5b6 <__lshift+0x32>
8000b5be:	6e 4b       	ld.w	r11,r7[0x10]
8000b5c0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b5c4:	2f bb       	sub	r11,-5
8000b5c6:	ee c9 ff ec 	sub	r9,r7,-20
8000b5ca:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b5ce:	58 03       	cp.w	r3,0
8000b5d0:	c1 30       	breq	8000b5f6 <__lshift+0x72>
8000b5d2:	e6 0c 11 20 	rsub	r12,r3,32
8000b5d6:	30 0a       	mov	r10,0
8000b5d8:	72 02       	ld.w	r2,r9[0x0]
8000b5da:	e4 03 09 42 	lsl	r2,r2,r3
8000b5de:	04 4a       	or	r10,r2
8000b5e0:	10 aa       	st.w	r8++,r10
8000b5e2:	13 0a       	ld.w	r10,r9++
8000b5e4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b5e8:	16 39       	cp.w	r9,r11
8000b5ea:	cf 73       	brcs	8000b5d8 <__lshift+0x54>
8000b5ec:	91 0a       	st.w	r8[0x0],r10
8000b5ee:	58 0a       	cp.w	r10,0
8000b5f0:	c0 70       	breq	8000b5fe <__lshift+0x7a>
8000b5f2:	2f f6       	sub	r6,-1
8000b5f4:	c0 58       	rjmp	8000b5fe <__lshift+0x7a>
8000b5f6:	13 0a       	ld.w	r10,r9++
8000b5f8:	10 aa       	st.w	r8++,r10
8000b5fa:	16 39       	cp.w	r9,r11
8000b5fc:	cf d3       	brcs	8000b5f6 <__lshift+0x72>
8000b5fe:	08 9c       	mov	r12,r4
8000b600:	20 16       	sub	r6,1
8000b602:	0e 9b       	mov	r11,r7
8000b604:	8b 46       	st.w	r5[0x10],r6
8000b606:	cb 5e       	rcall	8000b370 <_Bfree>
8000b608:	0a 9c       	mov	r12,r5
8000b60a:	d8 32       	popm	r0-r7,pc

8000b60c <__multiply>:
8000b60c:	d4 31       	pushm	r0-r7,lr
8000b60e:	20 2d       	sub	sp,8
8000b610:	76 49       	ld.w	r9,r11[0x10]
8000b612:	74 48       	ld.w	r8,r10[0x10]
8000b614:	16 96       	mov	r6,r11
8000b616:	14 95       	mov	r5,r10
8000b618:	10 39       	cp.w	r9,r8
8000b61a:	ec 08 17 50 	movlt	r8,r6
8000b61e:	ea 06 17 50 	movlt	r6,r5
8000b622:	f0 05 17 50 	movlt	r5,r8
8000b626:	6c 28       	ld.w	r8,r6[0x8]
8000b628:	76 43       	ld.w	r3,r11[0x10]
8000b62a:	74 42       	ld.w	r2,r10[0x10]
8000b62c:	76 1b       	ld.w	r11,r11[0x4]
8000b62e:	e4 03 00 07 	add	r7,r2,r3
8000b632:	10 37       	cp.w	r7,r8
8000b634:	f7 bb 09 ff 	subgt	r11,-1
8000b638:	cb 6e       	rcall	8000b3a4 <_Balloc>
8000b63a:	ee c4 ff fb 	sub	r4,r7,-5
8000b63e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b642:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b646:	30 0a       	mov	r10,0
8000b648:	12 98       	mov	r8,r9
8000b64a:	c0 28       	rjmp	8000b64e <__multiply+0x42>
8000b64c:	10 aa       	st.w	r8++,r10
8000b64e:	08 38       	cp.w	r8,r4
8000b650:	cf e3       	brcs	8000b64c <__multiply+0x40>
8000b652:	2f b3       	sub	r3,-5
8000b654:	2f b2       	sub	r2,-5
8000b656:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b65a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b65e:	ec cb ff ec 	sub	r11,r6,-20
8000b662:	50 12       	stdsp	sp[0x4],r2
8000b664:	ea ca ff ec 	sub	r10,r5,-20
8000b668:	c4 48       	rjmp	8000b6f0 <__multiply+0xe4>
8000b66a:	94 95       	ld.uh	r5,r10[0x2]
8000b66c:	58 05       	cp.w	r5,0
8000b66e:	c2 00       	breq	8000b6ae <__multiply+0xa2>
8000b670:	12 98       	mov	r8,r9
8000b672:	16 96       	mov	r6,r11
8000b674:	30 0e       	mov	lr,0
8000b676:	50 09       	stdsp	sp[0x0],r9
8000b678:	0d 02       	ld.w	r2,r6++
8000b67a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b67e:	70 01       	ld.w	r1,r8[0x0]
8000b680:	70 09       	ld.w	r9,r8[0x0]
8000b682:	b1 81       	lsr	r1,0x10
8000b684:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b688:	e0 05 03 41 	mac	r1,r0,r5
8000b68c:	ab 32       	mul	r2,r5
8000b68e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b692:	00 02       	add	r2,r0
8000b694:	e4 0e 00 0e 	add	lr,r2,lr
8000b698:	b0 1e       	st.h	r8[0x2],lr
8000b69a:	b1 8e       	lsr	lr,0x10
8000b69c:	1c 01       	add	r1,lr
8000b69e:	b0 01       	st.h	r8[0x0],r1
8000b6a0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b6a4:	2f c8       	sub	r8,-4
8000b6a6:	06 36       	cp.w	r6,r3
8000b6a8:	ce 83       	brcs	8000b678 <__multiply+0x6c>
8000b6aa:	40 09       	lddsp	r9,sp[0x0]
8000b6ac:	91 0e       	st.w	r8[0x0],lr
8000b6ae:	94 86       	ld.uh	r6,r10[0x0]
8000b6b0:	58 06       	cp.w	r6,0
8000b6b2:	c1 d0       	breq	8000b6ec <__multiply+0xe0>
8000b6b4:	72 02       	ld.w	r2,r9[0x0]
8000b6b6:	12 98       	mov	r8,r9
8000b6b8:	16 9e       	mov	lr,r11
8000b6ba:	30 05       	mov	r5,0
8000b6bc:	b0 12       	st.h	r8[0x2],r2
8000b6be:	1d 01       	ld.w	r1,lr++
8000b6c0:	90 82       	ld.uh	r2,r8[0x0]
8000b6c2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b6c6:	ad 30       	mul	r0,r6
8000b6c8:	e0 02 00 02 	add	r2,r0,r2
8000b6cc:	e4 05 00 05 	add	r5,r2,r5
8000b6d0:	b0 05       	st.h	r8[0x0],r5
8000b6d2:	b1 85       	lsr	r5,0x10
8000b6d4:	b1 81       	lsr	r1,0x10
8000b6d6:	2f c8       	sub	r8,-4
8000b6d8:	ad 31       	mul	r1,r6
8000b6da:	90 92       	ld.uh	r2,r8[0x2]
8000b6dc:	e2 02 00 02 	add	r2,r1,r2
8000b6e0:	0a 02       	add	r2,r5
8000b6e2:	e4 05 16 10 	lsr	r5,r2,0x10
8000b6e6:	06 3e       	cp.w	lr,r3
8000b6e8:	ce a3       	brcs	8000b6bc <__multiply+0xb0>
8000b6ea:	91 02       	st.w	r8[0x0],r2
8000b6ec:	2f ca       	sub	r10,-4
8000b6ee:	2f c9       	sub	r9,-4
8000b6f0:	40 18       	lddsp	r8,sp[0x4]
8000b6f2:	10 3a       	cp.w	r10,r8
8000b6f4:	cb b3       	brcs	8000b66a <__multiply+0x5e>
8000b6f6:	c0 28       	rjmp	8000b6fa <__multiply+0xee>
8000b6f8:	20 17       	sub	r7,1
8000b6fa:	58 07       	cp.w	r7,0
8000b6fc:	e0 8a 00 05 	brle	8000b706 <__multiply+0xfa>
8000b700:	09 48       	ld.w	r8,--r4
8000b702:	58 08       	cp.w	r8,0
8000b704:	cf a0       	breq	8000b6f8 <__multiply+0xec>
8000b706:	99 47       	st.w	r12[0x10],r7
8000b708:	2f ed       	sub	sp,-8
8000b70a:	d8 32       	popm	r0-r7,pc

8000b70c <__i2b>:
8000b70c:	d4 21       	pushm	r4-r7,lr
8000b70e:	16 97       	mov	r7,r11
8000b710:	30 1b       	mov	r11,1
8000b712:	c4 9e       	rcall	8000b3a4 <_Balloc>
8000b714:	30 19       	mov	r9,1
8000b716:	99 57       	st.w	r12[0x14],r7
8000b718:	99 49       	st.w	r12[0x10],r9
8000b71a:	d8 22       	popm	r4-r7,pc

8000b71c <__multadd>:
8000b71c:	d4 31       	pushm	r0-r7,lr
8000b71e:	30 08       	mov	r8,0
8000b720:	12 95       	mov	r5,r9
8000b722:	16 97       	mov	r7,r11
8000b724:	18 96       	mov	r6,r12
8000b726:	76 44       	ld.w	r4,r11[0x10]
8000b728:	f6 c9 ff ec 	sub	r9,r11,-20
8000b72c:	72 0b       	ld.w	r11,r9[0x0]
8000b72e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b732:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b736:	f4 0c 02 4c 	mul	r12,r10,r12
8000b73a:	f4 0b 03 45 	mac	r5,r10,r11
8000b73e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b742:	b1 85       	lsr	r5,0x10
8000b744:	18 05       	add	r5,r12
8000b746:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b74a:	f8 0b 00 0b 	add	r11,r12,r11
8000b74e:	12 ab       	st.w	r9++,r11
8000b750:	2f f8       	sub	r8,-1
8000b752:	b1 85       	lsr	r5,0x10
8000b754:	08 38       	cp.w	r8,r4
8000b756:	ce b5       	brlt	8000b72c <__multadd+0x10>
8000b758:	58 05       	cp.w	r5,0
8000b75a:	c1 c0       	breq	8000b792 <__multadd+0x76>
8000b75c:	6e 28       	ld.w	r8,r7[0x8]
8000b75e:	10 34       	cp.w	r4,r8
8000b760:	c1 35       	brlt	8000b786 <__multadd+0x6a>
8000b762:	6e 1b       	ld.w	r11,r7[0x4]
8000b764:	0c 9c       	mov	r12,r6
8000b766:	2f fb       	sub	r11,-1
8000b768:	c1 ee       	rcall	8000b3a4 <_Balloc>
8000b76a:	6e 4a       	ld.w	r10,r7[0x10]
8000b76c:	ee cb ff f4 	sub	r11,r7,-12
8000b770:	18 93       	mov	r3,r12
8000b772:	2f ea       	sub	r10,-2
8000b774:	2f 4c       	sub	r12,-12
8000b776:	a3 6a       	lsl	r10,0x2
8000b778:	fe b0 de 70 	rcall	80007458 <memcpy>
8000b77c:	0e 9b       	mov	r11,r7
8000b77e:	0c 9c       	mov	r12,r6
8000b780:	fe b0 fd f8 	rcall	8000b370 <_Bfree>
8000b784:	06 97       	mov	r7,r3
8000b786:	e8 c8 ff ff 	sub	r8,r4,-1
8000b78a:	2f b4       	sub	r4,-5
8000b78c:	8f 48       	st.w	r7[0x10],r8
8000b78e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b792:	0e 9c       	mov	r12,r7
8000b794:	d8 32       	popm	r0-r7,pc
8000b796:	d7 03       	nop

8000b798 <__pow5mult>:
8000b798:	d4 31       	pushm	r0-r7,lr
8000b79a:	14 96       	mov	r6,r10
8000b79c:	18 97       	mov	r7,r12
8000b79e:	16 94       	mov	r4,r11
8000b7a0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b7a4:	c0 90       	breq	8000b7b6 <__pow5mult+0x1e>
8000b7a6:	20 18       	sub	r8,1
8000b7a8:	fe c9 db 50 	sub	r9,pc,-9392
8000b7ac:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b7b0:	30 09       	mov	r9,0
8000b7b2:	cb 5f       	rcall	8000b71c <__multadd>
8000b7b4:	18 94       	mov	r4,r12
8000b7b6:	a3 46       	asr	r6,0x2
8000b7b8:	c3 40       	breq	8000b820 <__pow5mult+0x88>
8000b7ba:	6e 95       	ld.w	r5,r7[0x24]
8000b7bc:	58 05       	cp.w	r5,0
8000b7be:	c0 91       	brne	8000b7d0 <__pow5mult+0x38>
8000b7c0:	31 0c       	mov	r12,16
8000b7c2:	fe b0 dc 27 	rcall	80007010 <malloc>
8000b7c6:	99 35       	st.w	r12[0xc],r5
8000b7c8:	8f 9c       	st.w	r7[0x24],r12
8000b7ca:	99 15       	st.w	r12[0x4],r5
8000b7cc:	99 25       	st.w	r12[0x8],r5
8000b7ce:	99 05       	st.w	r12[0x0],r5
8000b7d0:	6e 93       	ld.w	r3,r7[0x24]
8000b7d2:	66 25       	ld.w	r5,r3[0x8]
8000b7d4:	58 05       	cp.w	r5,0
8000b7d6:	c0 c1       	brne	8000b7ee <__pow5mult+0x56>
8000b7d8:	e0 6b 02 71 	mov	r11,625
8000b7dc:	0e 9c       	mov	r12,r7
8000b7de:	c9 7f       	rcall	8000b70c <__i2b>
8000b7e0:	87 2c       	st.w	r3[0x8],r12
8000b7e2:	30 08       	mov	r8,0
8000b7e4:	18 95       	mov	r5,r12
8000b7e6:	99 08       	st.w	r12[0x0],r8
8000b7e8:	c0 38       	rjmp	8000b7ee <__pow5mult+0x56>
8000b7ea:	06 9c       	mov	r12,r3
8000b7ec:	18 95       	mov	r5,r12
8000b7ee:	ed b6 00 00 	bld	r6,0x0
8000b7f2:	c0 b1       	brne	8000b808 <__pow5mult+0x70>
8000b7f4:	08 9b       	mov	r11,r4
8000b7f6:	0a 9a       	mov	r10,r5
8000b7f8:	0e 9c       	mov	r12,r7
8000b7fa:	c0 9f       	rcall	8000b60c <__multiply>
8000b7fc:	08 9b       	mov	r11,r4
8000b7fe:	18 93       	mov	r3,r12
8000b800:	0e 9c       	mov	r12,r7
8000b802:	06 94       	mov	r4,r3
8000b804:	fe b0 fd b6 	rcall	8000b370 <_Bfree>
8000b808:	a1 56       	asr	r6,0x1
8000b80a:	c0 b0       	breq	8000b820 <__pow5mult+0x88>
8000b80c:	6a 03       	ld.w	r3,r5[0x0]
8000b80e:	58 03       	cp.w	r3,0
8000b810:	ce d1       	brne	8000b7ea <__pow5mult+0x52>
8000b812:	0a 9a       	mov	r10,r5
8000b814:	0a 9b       	mov	r11,r5
8000b816:	0e 9c       	mov	r12,r7
8000b818:	cf ae       	rcall	8000b60c <__multiply>
8000b81a:	8b 0c       	st.w	r5[0x0],r12
8000b81c:	99 03       	st.w	r12[0x0],r3
8000b81e:	ce 7b       	rjmp	8000b7ec <__pow5mult+0x54>
8000b820:	08 9c       	mov	r12,r4
8000b822:	d8 32       	popm	r0-r7,pc

8000b824 <__isinfd>:
8000b824:	14 98       	mov	r8,r10
8000b826:	fc 19 7f f0 	movh	r9,0x7ff0
8000b82a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b82e:	f0 0b 11 00 	rsub	r11,r8,0
8000b832:	f7 e8 10 08 	or	r8,r11,r8
8000b836:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b83a:	f2 08 01 08 	sub	r8,r9,r8
8000b83e:	f0 0c 11 00 	rsub	r12,r8,0
8000b842:	f9 e8 10 08 	or	r8,r12,r8
8000b846:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b84a:	2f fc       	sub	r12,-1
8000b84c:	5e fc       	retal	r12

8000b84e <__isnand>:
8000b84e:	14 98       	mov	r8,r10
8000b850:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b854:	f0 0c 11 00 	rsub	r12,r8,0
8000b858:	10 4c       	or	r12,r8
8000b85a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b85e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b862:	f0 0c 01 0c 	sub	r12,r8,r12
8000b866:	bf 9c       	lsr	r12,0x1f
8000b868:	5e fc       	retal	r12
8000b86a:	d7 03       	nop

8000b86c <__sclose>:
8000b86c:	d4 01       	pushm	lr
8000b86e:	96 7b       	ld.sh	r11,r11[0xe]
8000b870:	c8 2c       	rcall	8000b974 <_close_r>
8000b872:	d8 02       	popm	pc

8000b874 <__sseek>:
8000b874:	d4 21       	pushm	r4-r7,lr
8000b876:	16 97       	mov	r7,r11
8000b878:	96 7b       	ld.sh	r11,r11[0xe]
8000b87a:	c0 3d       	rcall	8000ba80 <_lseek_r>
8000b87c:	8e 68       	ld.sh	r8,r7[0xc]
8000b87e:	10 99       	mov	r9,r8
8000b880:	ad c8       	cbr	r8,0xc
8000b882:	ad a9       	sbr	r9,0xc
8000b884:	5b fc       	cp.w	r12,-1
8000b886:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b88a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b88e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b892:	d8 22       	popm	r4-r7,pc

8000b894 <__swrite>:
8000b894:	d4 21       	pushm	r4-r7,lr
8000b896:	96 68       	ld.sh	r8,r11[0xc]
8000b898:	16 97       	mov	r7,r11
8000b89a:	14 95       	mov	r5,r10
8000b89c:	12 94       	mov	r4,r9
8000b89e:	e2 18 01 00 	andl	r8,0x100,COH
8000b8a2:	18 96       	mov	r6,r12
8000b8a4:	c0 50       	breq	8000b8ae <__swrite+0x1a>
8000b8a6:	30 29       	mov	r9,2
8000b8a8:	30 0a       	mov	r10,0
8000b8aa:	96 7b       	ld.sh	r11,r11[0xe]
8000b8ac:	ce ac       	rcall	8000ba80 <_lseek_r>
8000b8ae:	8e 68       	ld.sh	r8,r7[0xc]
8000b8b0:	ad c8       	cbr	r8,0xc
8000b8b2:	08 99       	mov	r9,r4
8000b8b4:	0a 9a       	mov	r10,r5
8000b8b6:	8e 7b       	ld.sh	r11,r7[0xe]
8000b8b8:	0c 9c       	mov	r12,r6
8000b8ba:	ae 68       	st.h	r7[0xc],r8
8000b8bc:	c1 cc       	rcall	8000b8f4 <_write_r>
8000b8be:	d8 22       	popm	r4-r7,pc

8000b8c0 <__sread>:
8000b8c0:	d4 21       	pushm	r4-r7,lr
8000b8c2:	16 97       	mov	r7,r11
8000b8c4:	96 7b       	ld.sh	r11,r11[0xe]
8000b8c6:	cf 1c       	rcall	8000baa8 <_read_r>
8000b8c8:	c0 65       	brlt	8000b8d4 <__sread+0x14>
8000b8ca:	6f 58       	ld.w	r8,r7[0x54]
8000b8cc:	18 08       	add	r8,r12
8000b8ce:	ef 48 00 54 	st.w	r7[84],r8
8000b8d2:	d8 22       	popm	r4-r7,pc
8000b8d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b8d6:	ad c8       	cbr	r8,0xc
8000b8d8:	ae 68       	st.h	r7[0xc],r8
8000b8da:	d8 22       	popm	r4-r7,pc

8000b8dc <strlen>:
8000b8dc:	30 09       	mov	r9,0
8000b8de:	18 98       	mov	r8,r12
8000b8e0:	c0 28       	rjmp	8000b8e4 <strlen+0x8>
8000b8e2:	2f f8       	sub	r8,-1
8000b8e4:	11 8a       	ld.ub	r10,r8[0x0]
8000b8e6:	f2 0a 18 00 	cp.b	r10,r9
8000b8ea:	cf c1       	brne	8000b8e2 <strlen+0x6>
8000b8ec:	f0 0c 01 0c 	sub	r12,r8,r12
8000b8f0:	5e fc       	retal	r12
8000b8f2:	d7 03       	nop

8000b8f4 <_write_r>:
8000b8f4:	d4 21       	pushm	r4-r7,lr
8000b8f6:	16 98       	mov	r8,r11
8000b8f8:	18 97       	mov	r7,r12
8000b8fa:	10 9c       	mov	r12,r8
8000b8fc:	30 08       	mov	r8,0
8000b8fe:	14 9b       	mov	r11,r10
8000b900:	e0 66 51 14 	mov	r6,20756
8000b904:	12 9a       	mov	r10,r9
8000b906:	8d 08       	st.w	r6[0x0],r8
8000b908:	fe b0 d1 b6 	rcall	80005c74 <_write>
8000b90c:	5b fc       	cp.w	r12,-1
8000b90e:	c0 51       	brne	8000b918 <_write_r+0x24>
8000b910:	6c 08       	ld.w	r8,r6[0x0]
8000b912:	58 08       	cp.w	r8,0
8000b914:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b918:	d8 22       	popm	r4-r7,pc
8000b91a:	d7 03       	nop

8000b91c <_calloc_r>:
8000b91c:	d4 21       	pushm	r4-r7,lr
8000b91e:	f4 0b 02 4b 	mul	r11,r10,r11
8000b922:	fe b0 db 7f 	rcall	80007020 <_malloc_r>
8000b926:	18 97       	mov	r7,r12
8000b928:	c2 30       	breq	8000b96e <_calloc_r+0x52>
8000b92a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b92e:	e0 1a ff fc 	andl	r10,0xfffc
8000b932:	20 4a       	sub	r10,4
8000b934:	e0 4a 00 24 	cp.w	r10,36
8000b938:	e0 8b 00 18 	brhi	8000b968 <_calloc_r+0x4c>
8000b93c:	18 98       	mov	r8,r12
8000b93e:	59 3a       	cp.w	r10,19
8000b940:	e0 88 00 0f 	brls	8000b95e <_calloc_r+0x42>
8000b944:	30 09       	mov	r9,0
8000b946:	10 a9       	st.w	r8++,r9
8000b948:	10 a9       	st.w	r8++,r9
8000b94a:	59 ba       	cp.w	r10,27
8000b94c:	e0 88 00 09 	brls	8000b95e <_calloc_r+0x42>
8000b950:	10 a9       	st.w	r8++,r9
8000b952:	10 a9       	st.w	r8++,r9
8000b954:	e0 4a 00 24 	cp.w	r10,36
8000b958:	c0 31       	brne	8000b95e <_calloc_r+0x42>
8000b95a:	10 a9       	st.w	r8++,r9
8000b95c:	10 a9       	st.w	r8++,r9
8000b95e:	30 09       	mov	r9,0
8000b960:	10 a9       	st.w	r8++,r9
8000b962:	91 19       	st.w	r8[0x4],r9
8000b964:	91 09       	st.w	r8[0x0],r9
8000b966:	c0 48       	rjmp	8000b96e <_calloc_r+0x52>
8000b968:	30 0b       	mov	r11,0
8000b96a:	fe b0 de 1b 	rcall	800075a0 <memset>
8000b96e:	0e 9c       	mov	r12,r7
8000b970:	d8 22       	popm	r4-r7,pc
8000b972:	d7 03       	nop

8000b974 <_close_r>:
8000b974:	d4 21       	pushm	r4-r7,lr
8000b976:	30 08       	mov	r8,0
8000b978:	18 97       	mov	r7,r12
8000b97a:	e0 66 51 14 	mov	r6,20756
8000b97e:	16 9c       	mov	r12,r11
8000b980:	8d 08       	st.w	r6[0x0],r8
8000b982:	fe b0 df b5 	rcall	800078ec <_close>
8000b986:	5b fc       	cp.w	r12,-1
8000b988:	c0 51       	brne	8000b992 <_close_r+0x1e>
8000b98a:	6c 08       	ld.w	r8,r6[0x0]
8000b98c:	58 08       	cp.w	r8,0
8000b98e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b992:	d8 22       	popm	r4-r7,pc

8000b994 <_fclose_r>:
8000b994:	d4 21       	pushm	r4-r7,lr
8000b996:	18 96       	mov	r6,r12
8000b998:	16 97       	mov	r7,r11
8000b99a:	58 0b       	cp.w	r11,0
8000b99c:	c0 31       	brne	8000b9a2 <_fclose_r+0xe>
8000b99e:	16 95       	mov	r5,r11
8000b9a0:	c5 38       	rjmp	8000ba46 <_fclose_r+0xb2>
8000b9a2:	fe b0 f8 a9 	rcall	8000aaf4 <__sfp_lock_acquire>
8000b9a6:	58 06       	cp.w	r6,0
8000b9a8:	c0 70       	breq	8000b9b6 <_fclose_r+0x22>
8000b9aa:	6c 68       	ld.w	r8,r6[0x18]
8000b9ac:	58 08       	cp.w	r8,0
8000b9ae:	c0 41       	brne	8000b9b6 <_fclose_r+0x22>
8000b9b0:	0c 9c       	mov	r12,r6
8000b9b2:	fe b0 f8 f3 	rcall	8000ab98 <__sinit>
8000b9b6:	fe c8 de 02 	sub	r8,pc,-8702
8000b9ba:	10 37       	cp.w	r7,r8
8000b9bc:	c0 31       	brne	8000b9c2 <_fclose_r+0x2e>
8000b9be:	6c 07       	ld.w	r7,r6[0x0]
8000b9c0:	c0 c8       	rjmp	8000b9d8 <_fclose_r+0x44>
8000b9c2:	fe c8 dd ee 	sub	r8,pc,-8722
8000b9c6:	10 37       	cp.w	r7,r8
8000b9c8:	c0 31       	brne	8000b9ce <_fclose_r+0x3a>
8000b9ca:	6c 17       	ld.w	r7,r6[0x4]
8000b9cc:	c0 68       	rjmp	8000b9d8 <_fclose_r+0x44>
8000b9ce:	fe c8 dd da 	sub	r8,pc,-8742
8000b9d2:	10 37       	cp.w	r7,r8
8000b9d4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b9d8:	8e 69       	ld.sh	r9,r7[0xc]
8000b9da:	30 08       	mov	r8,0
8000b9dc:	f0 09 19 00 	cp.h	r9,r8
8000b9e0:	c0 51       	brne	8000b9ea <_fclose_r+0x56>
8000b9e2:	fe b0 f8 8a 	rcall	8000aaf6 <__sfp_lock_release>
8000b9e6:	30 05       	mov	r5,0
8000b9e8:	c2 f8       	rjmp	8000ba46 <_fclose_r+0xb2>
8000b9ea:	0e 9b       	mov	r11,r7
8000b9ec:	0c 9c       	mov	r12,r6
8000b9ee:	fe b0 f7 fd 	rcall	8000a9e8 <_fflush_r>
8000b9f2:	6e c8       	ld.w	r8,r7[0x30]
8000b9f4:	18 95       	mov	r5,r12
8000b9f6:	58 08       	cp.w	r8,0
8000b9f8:	c0 60       	breq	8000ba04 <_fclose_r+0x70>
8000b9fa:	6e 8b       	ld.w	r11,r7[0x20]
8000b9fc:	0c 9c       	mov	r12,r6
8000b9fe:	5d 18       	icall	r8
8000ba00:	f9 b5 05 ff 	movlt	r5,-1
8000ba04:	8e 68       	ld.sh	r8,r7[0xc]
8000ba06:	ed b8 00 07 	bld	r8,0x7
8000ba0a:	c0 51       	brne	8000ba14 <_fclose_r+0x80>
8000ba0c:	6e 4b       	ld.w	r11,r7[0x10]
8000ba0e:	0c 9c       	mov	r12,r6
8000ba10:	fe b0 f9 5e 	rcall	8000accc <_free_r>
8000ba14:	6e db       	ld.w	r11,r7[0x34]
8000ba16:	58 0b       	cp.w	r11,0
8000ba18:	c0 a0       	breq	8000ba2c <_fclose_r+0x98>
8000ba1a:	ee c8 ff bc 	sub	r8,r7,-68
8000ba1e:	10 3b       	cp.w	r11,r8
8000ba20:	c0 40       	breq	8000ba28 <_fclose_r+0x94>
8000ba22:	0c 9c       	mov	r12,r6
8000ba24:	fe b0 f9 54 	rcall	8000accc <_free_r>
8000ba28:	30 08       	mov	r8,0
8000ba2a:	8f d8       	st.w	r7[0x34],r8
8000ba2c:	6f 2b       	ld.w	r11,r7[0x48]
8000ba2e:	58 0b       	cp.w	r11,0
8000ba30:	c0 70       	breq	8000ba3e <_fclose_r+0xaa>
8000ba32:	0c 9c       	mov	r12,r6
8000ba34:	fe b0 f9 4c 	rcall	8000accc <_free_r>
8000ba38:	30 08       	mov	r8,0
8000ba3a:	ef 48 00 48 	st.w	r7[72],r8
8000ba3e:	30 08       	mov	r8,0
8000ba40:	ae 68       	st.h	r7[0xc],r8
8000ba42:	fe b0 f8 5a 	rcall	8000aaf6 <__sfp_lock_release>
8000ba46:	0a 9c       	mov	r12,r5
8000ba48:	d8 22       	popm	r4-r7,pc
8000ba4a:	d7 03       	nop

8000ba4c <fclose>:
8000ba4c:	d4 01       	pushm	lr
8000ba4e:	e0 68 0a 2c 	mov	r8,2604
8000ba52:	18 9b       	mov	r11,r12
8000ba54:	70 0c       	ld.w	r12,r8[0x0]
8000ba56:	c9 ff       	rcall	8000b994 <_fclose_r>
8000ba58:	d8 02       	popm	pc
8000ba5a:	d7 03       	nop

8000ba5c <_fstat_r>:
8000ba5c:	d4 21       	pushm	r4-r7,lr
8000ba5e:	16 98       	mov	r8,r11
8000ba60:	18 97       	mov	r7,r12
8000ba62:	10 9c       	mov	r12,r8
8000ba64:	30 08       	mov	r8,0
8000ba66:	e0 66 51 14 	mov	r6,20756
8000ba6a:	14 9b       	mov	r11,r10
8000ba6c:	8d 08       	st.w	r6[0x0],r8
8000ba6e:	fe b0 df 67 	rcall	8000793c <_fstat>
8000ba72:	5b fc       	cp.w	r12,-1
8000ba74:	c0 51       	brne	8000ba7e <_fstat_r+0x22>
8000ba76:	6c 08       	ld.w	r8,r6[0x0]
8000ba78:	58 08       	cp.w	r8,0
8000ba7a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ba7e:	d8 22       	popm	r4-r7,pc

8000ba80 <_lseek_r>:
8000ba80:	d4 21       	pushm	r4-r7,lr
8000ba82:	16 98       	mov	r8,r11
8000ba84:	18 97       	mov	r7,r12
8000ba86:	10 9c       	mov	r12,r8
8000ba88:	30 08       	mov	r8,0
8000ba8a:	14 9b       	mov	r11,r10
8000ba8c:	e0 66 51 14 	mov	r6,20756
8000ba90:	12 9a       	mov	r10,r9
8000ba92:	8d 08       	st.w	r6[0x0],r8
8000ba94:	fe b0 df 36 	rcall	80007900 <_lseek>
8000ba98:	5b fc       	cp.w	r12,-1
8000ba9a:	c0 51       	brne	8000baa4 <_lseek_r+0x24>
8000ba9c:	6c 08       	ld.w	r8,r6[0x0]
8000ba9e:	58 08       	cp.w	r8,0
8000baa0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000baa4:	d8 22       	popm	r4-r7,pc
8000baa6:	d7 03       	nop

8000baa8 <_read_r>:
8000baa8:	d4 21       	pushm	r4-r7,lr
8000baaa:	16 98       	mov	r8,r11
8000baac:	18 97       	mov	r7,r12
8000baae:	10 9c       	mov	r12,r8
8000bab0:	30 08       	mov	r8,0
8000bab2:	14 9b       	mov	r11,r10
8000bab4:	e0 66 51 14 	mov	r6,20756
8000bab8:	12 9a       	mov	r10,r9
8000baba:	8d 08       	st.w	r6[0x0],r8
8000babc:	fe b0 d0 bc 	rcall	80005c34 <_read>
8000bac0:	5b fc       	cp.w	r12,-1
8000bac2:	c0 51       	brne	8000bacc <_read_r+0x24>
8000bac4:	6c 08       	ld.w	r8,r6[0x0]
8000bac6:	58 08       	cp.w	r8,0
8000bac8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bacc:	d8 22       	popm	r4-r7,pc
8000bace:	d7 03       	nop

8000bad0 <__avr32_f64_mul>:
8000bad0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bad4:	e0 80 00 dc 	breq	8000bc8c <__avr32_f64_mul_op1_zero>
8000bad8:	d4 21       	pushm	r4-r7,lr
8000bada:	f7 e9 20 0e 	eor	lr,r11,r9
8000bade:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bae2:	30 15       	mov	r5,1
8000bae4:	c4 30       	breq	8000bb6a <__avr32_f64_mul_op1_subnormal>
8000bae6:	ab 6b       	lsl	r11,0xa
8000bae8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000baec:	ab 6a       	lsl	r10,0xa
8000baee:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000baf2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000baf6:	c5 c0       	breq	8000bbae <__avr32_f64_mul_op2_subnormal>
8000baf8:	a1 78       	lsl	r8,0x1
8000bafa:	5c f9       	rol	r9
8000bafc:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bb00:	e0 47 07 ff 	cp.w	r7,2047
8000bb04:	c7 70       	breq	8000bbf2 <__avr32_f64_mul_op_nan_or_inf>
8000bb06:	e0 46 07 ff 	cp.w	r6,2047
8000bb0a:	c7 40       	breq	8000bbf2 <__avr32_f64_mul_op_nan_or_inf>
8000bb0c:	ee 06 00 0c 	add	r12,r7,r6
8000bb10:	e0 2c 03 fe 	sub	r12,1022
8000bb14:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bb18:	f4 09 07 44 	macu.d	r4,r10,r9
8000bb1c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bb20:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bb24:	08 07       	add	r7,r4
8000bb26:	f4 05 00 4a 	adc	r10,r10,r5
8000bb2a:	5c 0b       	acr	r11
8000bb2c:	ed bb 00 14 	bld	r11,0x14
8000bb30:	c0 50       	breq	8000bb3a <__avr32_f64_mul+0x6a>
8000bb32:	a1 77       	lsl	r7,0x1
8000bb34:	5c fa       	rol	r10
8000bb36:	5c fb       	rol	r11
8000bb38:	20 1c       	sub	r12,1
8000bb3a:	58 0c       	cp.w	r12,0
8000bb3c:	e0 8a 00 6f 	brle	8000bc1a <__avr32_f64_mul_res_subnormal>
8000bb40:	e0 4c 07 ff 	cp.w	r12,2047
8000bb44:	e0 84 00 9c 	brge	8000bc7c <__avr32_f64_mul_res_inf>
8000bb48:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bb4c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bb50:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bb54:	ee 17 80 00 	eorh	r7,0x8000
8000bb58:	f1 b7 04 20 	satu	r7,0x1
8000bb5c:	0e 0a       	add	r10,r7
8000bb5e:	5c 0b       	acr	r11
8000bb60:	ed be 00 1f 	bld	lr,0x1f
8000bb64:	ef bb 00 1f 	bst	r11,0x1f
8000bb68:	d8 22       	popm	r4-r7,pc

8000bb6a <__avr32_f64_mul_op1_subnormal>:
8000bb6a:	e4 1b 00 0f 	andh	r11,0xf
8000bb6e:	f4 0c 12 00 	clz	r12,r10
8000bb72:	f6 06 12 00 	clz	r6,r11
8000bb76:	f7 bc 03 e1 	sublo	r12,-31
8000bb7a:	f8 06 17 30 	movlo	r6,r12
8000bb7e:	f7 b6 02 01 	subhs	r6,1
8000bb82:	e0 46 00 20 	cp.w	r6,32
8000bb86:	c0 d4       	brge	8000bba0 <__avr32_f64_mul_op1_subnormal+0x36>
8000bb88:	ec 0c 11 20 	rsub	r12,r6,32
8000bb8c:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb90:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bb94:	18 4b       	or	r11,r12
8000bb96:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb9a:	20 b6       	sub	r6,11
8000bb9c:	0c 17       	sub	r7,r6
8000bb9e:	ca ab       	rjmp	8000baf2 <__avr32_f64_mul+0x22>
8000bba0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bba4:	c6 40       	breq	8000bc6c <__avr32_f64_mul_res_zero>
8000bba6:	30 0a       	mov	r10,0
8000bba8:	20 b6       	sub	r6,11
8000bbaa:	0c 17       	sub	r7,r6
8000bbac:	ca 3b       	rjmp	8000baf2 <__avr32_f64_mul+0x22>

8000bbae <__avr32_f64_mul_op2_subnormal>:
8000bbae:	e4 19 00 0f 	andh	r9,0xf
8000bbb2:	f0 0c 12 00 	clz	r12,r8
8000bbb6:	f2 05 12 00 	clz	r5,r9
8000bbba:	f7 bc 03 ea 	sublo	r12,-22
8000bbbe:	f8 05 17 30 	movlo	r5,r12
8000bbc2:	f7 b5 02 0a 	subhs	r5,10
8000bbc6:	e0 45 00 20 	cp.w	r5,32
8000bbca:	c0 d4       	brge	8000bbe4 <__avr32_f64_mul_op2_subnormal+0x36>
8000bbcc:	ea 0c 11 20 	rsub	r12,r5,32
8000bbd0:	f2 05 09 49 	lsl	r9,r9,r5
8000bbd4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bbd8:	18 49       	or	r9,r12
8000bbda:	f0 05 09 48 	lsl	r8,r8,r5
8000bbde:	20 25       	sub	r5,2
8000bbe0:	0a 16       	sub	r6,r5
8000bbe2:	c8 fb       	rjmp	8000bb00 <__avr32_f64_mul+0x30>
8000bbe4:	f0 05 09 49 	lsl	r9,r8,r5
8000bbe8:	c4 20       	breq	8000bc6c <__avr32_f64_mul_res_zero>
8000bbea:	30 08       	mov	r8,0
8000bbec:	20 25       	sub	r5,2
8000bbee:	0a 16       	sub	r6,r5
8000bbf0:	c8 8b       	rjmp	8000bb00 <__avr32_f64_mul+0x30>

8000bbf2 <__avr32_f64_mul_op_nan_or_inf>:
8000bbf2:	e4 19 00 0f 	andh	r9,0xf
8000bbf6:	e4 1b 00 0f 	andh	r11,0xf
8000bbfa:	14 4b       	or	r11,r10
8000bbfc:	10 49       	or	r9,r8
8000bbfe:	e0 47 07 ff 	cp.w	r7,2047
8000bc02:	c0 91       	brne	8000bc14 <__avr32_f64_mul_op1_not_naninf>
8000bc04:	58 0b       	cp.w	r11,0
8000bc06:	c3 81       	brne	8000bc76 <__avr32_f64_mul_res_nan>
8000bc08:	e0 46 07 ff 	cp.w	r6,2047
8000bc0c:	c3 81       	brne	8000bc7c <__avr32_f64_mul_res_inf>
8000bc0e:	58 09       	cp.w	r9,0
8000bc10:	c3 60       	breq	8000bc7c <__avr32_f64_mul_res_inf>
8000bc12:	c3 28       	rjmp	8000bc76 <__avr32_f64_mul_res_nan>

8000bc14 <__avr32_f64_mul_op1_not_naninf>:
8000bc14:	58 09       	cp.w	r9,0
8000bc16:	c3 30       	breq	8000bc7c <__avr32_f64_mul_res_inf>
8000bc18:	c2 f8       	rjmp	8000bc76 <__avr32_f64_mul_res_nan>

8000bc1a <__avr32_f64_mul_res_subnormal>:
8000bc1a:	5c 3c       	neg	r12
8000bc1c:	2f fc       	sub	r12,-1
8000bc1e:	f1 bc 04 c0 	satu	r12,0x6
8000bc22:	e0 4c 00 20 	cp.w	r12,32
8000bc26:	c1 14       	brge	8000bc48 <__avr32_f64_mul_res_subnormal+0x2e>
8000bc28:	f8 08 11 20 	rsub	r8,r12,32
8000bc2c:	0e 46       	or	r6,r7
8000bc2e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bc32:	f4 08 09 49 	lsl	r9,r10,r8
8000bc36:	12 47       	or	r7,r9
8000bc38:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bc3c:	f6 08 09 49 	lsl	r9,r11,r8
8000bc40:	12 4a       	or	r10,r9
8000bc42:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bc46:	c8 3b       	rjmp	8000bb4c <__avr32_f64_mul+0x7c>
8000bc48:	f8 08 11 20 	rsub	r8,r12,32
8000bc4c:	f9 b9 00 00 	moveq	r9,0
8000bc50:	c0 30       	breq	8000bc56 <__avr32_f64_mul_res_subnormal+0x3c>
8000bc52:	f6 08 09 49 	lsl	r9,r11,r8
8000bc56:	0e 46       	or	r6,r7
8000bc58:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bc5c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bc60:	f3 ea 10 07 	or	r7,r9,r10
8000bc64:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bc68:	30 0b       	mov	r11,0
8000bc6a:	c7 1b       	rjmp	8000bb4c <__avr32_f64_mul+0x7c>

8000bc6c <__avr32_f64_mul_res_zero>:
8000bc6c:	1c 9b       	mov	r11,lr
8000bc6e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bc72:	30 0a       	mov	r10,0
8000bc74:	d8 22       	popm	r4-r7,pc

8000bc76 <__avr32_f64_mul_res_nan>:
8000bc76:	3f fb       	mov	r11,-1
8000bc78:	3f fa       	mov	r10,-1
8000bc7a:	d8 22       	popm	r4-r7,pc

8000bc7c <__avr32_f64_mul_res_inf>:
8000bc7c:	f0 6b 00 00 	mov	r11,-1048576
8000bc80:	ed be 00 1f 	bld	lr,0x1f
8000bc84:	ef bb 00 1f 	bst	r11,0x1f
8000bc88:	30 0a       	mov	r10,0
8000bc8a:	d8 22       	popm	r4-r7,pc

8000bc8c <__avr32_f64_mul_op1_zero>:
8000bc8c:	f7 e9 20 0b 	eor	r11,r11,r9
8000bc90:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bc94:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bc98:	e0 4c 07 ff 	cp.w	r12,2047
8000bc9c:	5e 1c       	retne	r12
8000bc9e:	3f fa       	mov	r10,-1
8000bca0:	3f fb       	mov	r11,-1
8000bca2:	5e fc       	retal	r12

8000bca4 <__avr32_f64_sub_from_add>:
8000bca4:	ee 19 80 00 	eorh	r9,0x8000

8000bca8 <__avr32_f64_sub>:
8000bca8:	f7 e9 20 0c 	eor	r12,r11,r9
8000bcac:	e0 86 00 ca 	brmi	8000be40 <__avr32_f64_add_from_sub>
8000bcb0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bcb4:	16 9c       	mov	r12,r11
8000bcb6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bcba:	bf db       	cbr	r11,0x1f
8000bcbc:	bf d9       	cbr	r9,0x1f
8000bcbe:	10 3a       	cp.w	r10,r8
8000bcc0:	f2 0b 13 00 	cpc	r11,r9
8000bcc4:	c0 92       	brcc	8000bcd6 <__avr32_f64_sub+0x2e>
8000bcc6:	16 97       	mov	r7,r11
8000bcc8:	12 9b       	mov	r11,r9
8000bcca:	0e 99       	mov	r9,r7
8000bccc:	14 97       	mov	r7,r10
8000bcce:	10 9a       	mov	r10,r8
8000bcd0:	0e 98       	mov	r8,r7
8000bcd2:	ee 1c 80 00 	eorh	r12,0x8000
8000bcd6:	f6 07 16 14 	lsr	r7,r11,0x14
8000bcda:	ab 7b       	lsl	r11,0xb
8000bcdc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bce0:	ab 7a       	lsl	r10,0xb
8000bce2:	bf bb       	sbr	r11,0x1f
8000bce4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bce8:	c4 40       	breq	8000bd70 <__avr32_f64_sub_opL_subnormal>
8000bcea:	ab 79       	lsl	r9,0xb
8000bcec:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bcf0:	ab 78       	lsl	r8,0xb
8000bcf2:	bf b9       	sbr	r9,0x1f

8000bcf4 <__avr32_f64_sub_opL_subnormal_done>:
8000bcf4:	e0 47 07 ff 	cp.w	r7,2047
8000bcf8:	c4 f0       	breq	8000bd96 <__avr32_f64_sub_opH_nan_or_inf>
8000bcfa:	0e 26       	rsub	r6,r7
8000bcfc:	c1 20       	breq	8000bd20 <__avr32_f64_sub_shift_done>
8000bcfe:	ec 05 11 20 	rsub	r5,r6,32
8000bd02:	e0 46 00 20 	cp.w	r6,32
8000bd06:	c7 c2       	brcc	8000bdfe <__avr32_f64_sub_longshift>
8000bd08:	f0 05 09 4e 	lsl	lr,r8,r5
8000bd0c:	f2 05 09 45 	lsl	r5,r9,r5
8000bd10:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd14:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd18:	0a 48       	or	r8,r5
8000bd1a:	58 0e       	cp.w	lr,0
8000bd1c:	5f 1e       	srne	lr
8000bd1e:	1c 48       	or	r8,lr

8000bd20 <__avr32_f64_sub_shift_done>:
8000bd20:	10 1a       	sub	r10,r8
8000bd22:	f6 09 01 4b 	sbc	r11,r11,r9
8000bd26:	f6 06 12 00 	clz	r6,r11
8000bd2a:	c0 e0       	breq	8000bd46 <__avr32_f64_sub_longnormalize_done>
8000bd2c:	c7 83       	brcs	8000be1c <__avr32_f64_sub_longnormalize>
8000bd2e:	ec 0e 11 20 	rsub	lr,r6,32
8000bd32:	f6 06 09 4b 	lsl	r11,r11,r6
8000bd36:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bd3a:	1c 4b       	or	r11,lr
8000bd3c:	f4 06 09 4a 	lsl	r10,r10,r6
8000bd40:	0c 17       	sub	r7,r6
8000bd42:	e0 8a 00 39 	brle	8000bdb4 <__avr32_f64_sub_subnormal_result>

8000bd46 <__avr32_f64_sub_longnormalize_done>:
8000bd46:	f4 09 15 15 	lsl	r9,r10,0x15
8000bd4a:	ab 9a       	lsr	r10,0xb
8000bd4c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bd50:	ab 9b       	lsr	r11,0xb
8000bd52:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd56:	18 4b       	or	r11,r12

8000bd58 <__avr32_f64_sub_round>:
8000bd58:	fc 17 80 00 	movh	r7,0x8000
8000bd5c:	ed ba 00 00 	bld	r10,0x0
8000bd60:	f7 b7 01 ff 	subne	r7,-1
8000bd64:	0e 39       	cp.w	r9,r7
8000bd66:	5f 29       	srhs	r9
8000bd68:	12 0a       	add	r10,r9
8000bd6a:	5c 0b       	acr	r11
8000bd6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd70 <__avr32_f64_sub_opL_subnormal>:
8000bd70:	ab 79       	lsl	r9,0xb
8000bd72:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bd76:	ab 78       	lsl	r8,0xb
8000bd78:	f3 e8 10 0e 	or	lr,r9,r8
8000bd7c:	f9 b6 01 01 	movne	r6,1
8000bd80:	ee 0e 11 00 	rsub	lr,r7,0
8000bd84:	f9 b7 00 01 	moveq	r7,1
8000bd88:	ef bb 00 1f 	bst	r11,0x1f
8000bd8c:	f7 ea 10 0e 	or	lr,r11,r10
8000bd90:	f9 b7 00 00 	moveq	r7,0
8000bd94:	cb 0b       	rjmp	8000bcf4 <__avr32_f64_sub_opL_subnormal_done>

8000bd96 <__avr32_f64_sub_opH_nan_or_inf>:
8000bd96:	bf db       	cbr	r11,0x1f
8000bd98:	f7 ea 10 0e 	or	lr,r11,r10
8000bd9c:	c0 81       	brne	8000bdac <__avr32_f64_sub_return_nan>
8000bd9e:	e0 46 07 ff 	cp.w	r6,2047
8000bda2:	c0 50       	breq	8000bdac <__avr32_f64_sub_return_nan>
8000bda4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bda8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdac <__avr32_f64_sub_return_nan>:
8000bdac:	3f fa       	mov	r10,-1
8000bdae:	3f fb       	mov	r11,-1
8000bdb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdb4 <__avr32_f64_sub_subnormal_result>:
8000bdb4:	5c 37       	neg	r7
8000bdb6:	2f f7       	sub	r7,-1
8000bdb8:	f1 b7 04 c0 	satu	r7,0x6
8000bdbc:	e0 47 00 20 	cp.w	r7,32
8000bdc0:	c1 14       	brge	8000bde2 <__avr32_f64_sub_subnormal_result+0x2e>
8000bdc2:	ee 08 11 20 	rsub	r8,r7,32
8000bdc6:	f4 08 09 49 	lsl	r9,r10,r8
8000bdca:	5f 16       	srne	r6
8000bdcc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bdd0:	0c 4a       	or	r10,r6
8000bdd2:	f6 08 09 49 	lsl	r9,r11,r8
8000bdd6:	f5 e9 10 0a 	or	r10,r10,r9
8000bdda:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bdde:	30 07       	mov	r7,0
8000bde0:	cb 3b       	rjmp	8000bd46 <__avr32_f64_sub_longnormalize_done>
8000bde2:	ee 08 11 40 	rsub	r8,r7,64
8000bde6:	f6 08 09 49 	lsl	r9,r11,r8
8000bdea:	14 49       	or	r9,r10
8000bdec:	5f 16       	srne	r6
8000bdee:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bdf2:	0c 4a       	or	r10,r6
8000bdf4:	30 0b       	mov	r11,0
8000bdf6:	30 07       	mov	r7,0
8000bdf8:	ca 7b       	rjmp	8000bd46 <__avr32_f64_sub_longnormalize_done>
8000bdfa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdfe <__avr32_f64_sub_longshift>:
8000bdfe:	f1 b6 04 c0 	satu	r6,0x6
8000be02:	f0 0e 17 00 	moveq	lr,r8
8000be06:	c0 40       	breq	8000be0e <__avr32_f64_sub_longshift+0x10>
8000be08:	f2 05 09 4e 	lsl	lr,r9,r5
8000be0c:	10 4e       	or	lr,r8
8000be0e:	f2 06 0a 48 	lsr	r8,r9,r6
8000be12:	30 09       	mov	r9,0
8000be14:	58 0e       	cp.w	lr,0
8000be16:	5f 1e       	srne	lr
8000be18:	1c 48       	or	r8,lr
8000be1a:	c8 3b       	rjmp	8000bd20 <__avr32_f64_sub_shift_done>

8000be1c <__avr32_f64_sub_longnormalize>:
8000be1c:	f4 06 12 00 	clz	r6,r10
8000be20:	f9 b7 03 00 	movlo	r7,0
8000be24:	f9 b6 03 00 	movlo	r6,0
8000be28:	f9 bc 03 00 	movlo	r12,0
8000be2c:	f7 b6 02 e0 	subhs	r6,-32
8000be30:	f4 06 09 4b 	lsl	r11,r10,r6
8000be34:	30 0a       	mov	r10,0
8000be36:	0c 17       	sub	r7,r6
8000be38:	fe 9a ff be 	brle	8000bdb4 <__avr32_f64_sub_subnormal_result>
8000be3c:	c8 5b       	rjmp	8000bd46 <__avr32_f64_sub_longnormalize_done>
8000be3e:	d7 03       	nop

8000be40 <__avr32_f64_add_from_sub>:
8000be40:	ee 19 80 00 	eorh	r9,0x8000

8000be44 <__avr32_f64_add>:
8000be44:	f7 e9 20 0c 	eor	r12,r11,r9
8000be48:	fe 96 ff 2e 	brmi	8000bca4 <__avr32_f64_sub_from_add>
8000be4c:	eb cd 40 e0 	pushm	r5-r7,lr
8000be50:	16 9c       	mov	r12,r11
8000be52:	e6 1c 80 00 	andh	r12,0x8000,COH
8000be56:	bf db       	cbr	r11,0x1f
8000be58:	bf d9       	cbr	r9,0x1f
8000be5a:	12 3b       	cp.w	r11,r9
8000be5c:	c0 72       	brcc	8000be6a <__avr32_f64_add+0x26>
8000be5e:	16 97       	mov	r7,r11
8000be60:	12 9b       	mov	r11,r9
8000be62:	0e 99       	mov	r9,r7
8000be64:	14 97       	mov	r7,r10
8000be66:	10 9a       	mov	r10,r8
8000be68:	0e 98       	mov	r8,r7
8000be6a:	30 0e       	mov	lr,0
8000be6c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000be70:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000be74:	b5 ab       	sbr	r11,0x14
8000be76:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000be7a:	c6 20       	breq	8000bf3e <__avr32_f64_add_op2_subnormal>
8000be7c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000be80:	b5 a9       	sbr	r9,0x14
8000be82:	e0 47 07 ff 	cp.w	r7,2047
8000be86:	c2 80       	breq	8000bed6 <__avr32_f64_add_opH_nan_or_inf>
8000be88:	0e 26       	rsub	r6,r7
8000be8a:	c1 20       	breq	8000beae <__avr32_f64_add_shift_done>
8000be8c:	e0 46 00 36 	cp.w	r6,54
8000be90:	c1 52       	brcc	8000beba <__avr32_f64_add_res_of_done>
8000be92:	ec 05 11 20 	rsub	r5,r6,32
8000be96:	e0 46 00 20 	cp.w	r6,32
8000be9a:	c3 52       	brcc	8000bf04 <__avr32_f64_add_longshift>
8000be9c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bea0:	f2 05 09 45 	lsl	r5,r9,r5
8000bea4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bea8:	f2 06 0a 49 	lsr	r9,r9,r6
8000beac:	0a 48       	or	r8,r5

8000beae <__avr32_f64_add_shift_done>:
8000beae:	10 0a       	add	r10,r8
8000beb0:	f6 09 00 4b 	adc	r11,r11,r9
8000beb4:	ed bb 00 15 	bld	r11,0x15
8000beb8:	c3 40       	breq	8000bf20 <__avr32_f64_add_res_of>

8000beba <__avr32_f64_add_res_of_done>:
8000beba:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bebe:	18 4b       	or	r11,r12

8000bec0 <__avr32_f64_add_round>:
8000bec0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bec4:	18 4e       	or	lr,r12
8000bec6:	ee 1e 80 00 	eorh	lr,0x8000
8000beca:	f1 be 04 20 	satu	lr,0x1
8000bece:	1c 0a       	add	r10,lr
8000bed0:	5c 0b       	acr	r11
8000bed2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bed6 <__avr32_f64_add_opH_nan_or_inf>:
8000bed6:	b5 cb       	cbr	r11,0x14
8000bed8:	f7 ea 10 0e 	or	lr,r11,r10
8000bedc:	c1 01       	brne	8000befc <__avr32_f64_add_return_nan>
8000bede:	e0 46 07 ff 	cp.w	r6,2047
8000bee2:	c0 30       	breq	8000bee8 <__avr32_f64_add_opL_nan_or_inf>
8000bee4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bee8 <__avr32_f64_add_opL_nan_or_inf>:
8000bee8:	b5 c9       	cbr	r9,0x14
8000beea:	f3 e8 10 0e 	or	lr,r9,r8
8000beee:	c0 71       	brne	8000befc <__avr32_f64_add_return_nan>
8000bef0:	30 0a       	mov	r10,0
8000bef2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bef6:	18 4b       	or	r11,r12
8000bef8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000befc <__avr32_f64_add_return_nan>:
8000befc:	3f fa       	mov	r10,-1
8000befe:	3f fb       	mov	r11,-1
8000bf00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf04 <__avr32_f64_add_longshift>:
8000bf04:	f1 b6 04 c0 	satu	r6,0x6
8000bf08:	f0 0e 17 00 	moveq	lr,r8
8000bf0c:	c0 60       	breq	8000bf18 <__avr32_f64_add_longshift+0x14>
8000bf0e:	f2 05 09 4e 	lsl	lr,r9,r5
8000bf12:	58 08       	cp.w	r8,0
8000bf14:	5f 18       	srne	r8
8000bf16:	10 4e       	or	lr,r8
8000bf18:	f2 06 0a 48 	lsr	r8,r9,r6
8000bf1c:	30 09       	mov	r9,0
8000bf1e:	cc 8b       	rjmp	8000beae <__avr32_f64_add_shift_done>

8000bf20 <__avr32_f64_add_res_of>:
8000bf20:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bf24:	a1 9b       	lsr	r11,0x1
8000bf26:	5d 0a       	ror	r10
8000bf28:	5d 0e       	ror	lr
8000bf2a:	2f f7       	sub	r7,-1
8000bf2c:	e0 47 07 ff 	cp.w	r7,2047
8000bf30:	f9 ba 00 00 	moveq	r10,0
8000bf34:	f9 bb 00 00 	moveq	r11,0
8000bf38:	f9 be 00 00 	moveq	lr,0
8000bf3c:	cb fb       	rjmp	8000beba <__avr32_f64_add_res_of_done>

8000bf3e <__avr32_f64_add_op2_subnormal>:
8000bf3e:	30 16       	mov	r6,1
8000bf40:	58 07       	cp.w	r7,0
8000bf42:	ca 01       	brne	8000be82 <__avr32_f64_add+0x3e>
8000bf44:	b5 cb       	cbr	r11,0x14
8000bf46:	10 0a       	add	r10,r8
8000bf48:	f6 09 00 4b 	adc	r11,r11,r9
8000bf4c:	18 4b       	or	r11,r12
8000bf4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bf52:	d7 03       	nop

8000bf54 <__avr32_f64_to_u32>:
8000bf54:	58 0b       	cp.w	r11,0
8000bf56:	5e 6d       	retmi	0

8000bf58 <__avr32_f64_to_s32>:
8000bf58:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bf5c:	b5 9c       	lsr	r12,0x15
8000bf5e:	e0 2c 03 ff 	sub	r12,1023
8000bf62:	5e 3d       	retlo	0
8000bf64:	f8 0c 11 1f 	rsub	r12,r12,31
8000bf68:	16 99       	mov	r9,r11
8000bf6a:	ab 7b       	lsl	r11,0xb
8000bf6c:	bf bb       	sbr	r11,0x1f
8000bf6e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bf72:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bf76:	a1 79       	lsl	r9,0x1
8000bf78:	5e 2b       	reths	r11
8000bf7a:	5c 3b       	neg	r11
8000bf7c:	5e fb       	retal	r11

8000bf7e <__avr32_u32_to_f64>:
8000bf7e:	f8 cb 00 00 	sub	r11,r12,0
8000bf82:	30 0c       	mov	r12,0
8000bf84:	c0 38       	rjmp	8000bf8a <__avr32_s32_to_f64+0x4>

8000bf86 <__avr32_s32_to_f64>:
8000bf86:	18 9b       	mov	r11,r12
8000bf88:	5c 4b       	abs	r11
8000bf8a:	30 0a       	mov	r10,0
8000bf8c:	5e 0b       	reteq	r11
8000bf8e:	d4 01       	pushm	lr
8000bf90:	e0 69 04 1e 	mov	r9,1054
8000bf94:	f6 08 12 00 	clz	r8,r11
8000bf98:	c1 70       	breq	8000bfc6 <__avr32_s32_to_f64+0x40>
8000bf9a:	c0 c3       	brcs	8000bfb2 <__avr32_s32_to_f64+0x2c>
8000bf9c:	f0 0e 11 20 	rsub	lr,r8,32
8000bfa0:	f6 08 09 4b 	lsl	r11,r11,r8
8000bfa4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bfa8:	1c 4b       	or	r11,lr
8000bfaa:	f4 08 09 4a 	lsl	r10,r10,r8
8000bfae:	10 19       	sub	r9,r8
8000bfb0:	c0 b8       	rjmp	8000bfc6 <__avr32_s32_to_f64+0x40>
8000bfb2:	f4 08 12 00 	clz	r8,r10
8000bfb6:	f9 b8 03 00 	movlo	r8,0
8000bfba:	f7 b8 02 e0 	subhs	r8,-32
8000bfbe:	f4 08 09 4b 	lsl	r11,r10,r8
8000bfc2:	30 0a       	mov	r10,0
8000bfc4:	10 19       	sub	r9,r8
8000bfc6:	58 09       	cp.w	r9,0
8000bfc8:	e0 89 00 30 	brgt	8000c028 <__avr32_s32_to_f64+0xa2>
8000bfcc:	5c 39       	neg	r9
8000bfce:	2f f9       	sub	r9,-1
8000bfd0:	e0 49 00 36 	cp.w	r9,54
8000bfd4:	c0 43       	brcs	8000bfdc <__avr32_s32_to_f64+0x56>
8000bfd6:	30 0b       	mov	r11,0
8000bfd8:	30 0a       	mov	r10,0
8000bfda:	c2 68       	rjmp	8000c026 <__avr32_s32_to_f64+0xa0>
8000bfdc:	2f 69       	sub	r9,-10
8000bfde:	f2 08 11 20 	rsub	r8,r9,32
8000bfe2:	e0 49 00 20 	cp.w	r9,32
8000bfe6:	c0 b2       	brcc	8000bffc <__avr32_s32_to_f64+0x76>
8000bfe8:	f4 08 09 4e 	lsl	lr,r10,r8
8000bfec:	f6 08 09 48 	lsl	r8,r11,r8
8000bff0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bff4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bff8:	10 4b       	or	r11,r8
8000bffa:	c0 88       	rjmp	8000c00a <__avr32_s32_to_f64+0x84>
8000bffc:	f6 08 09 4e 	lsl	lr,r11,r8
8000c000:	14 4e       	or	lr,r10
8000c002:	16 9a       	mov	r10,r11
8000c004:	30 0b       	mov	r11,0
8000c006:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c00a:	ed ba 00 00 	bld	r10,0x0
8000c00e:	c0 92       	brcc	8000c020 <__avr32_s32_to_f64+0x9a>
8000c010:	1c 7e       	tst	lr,lr
8000c012:	c0 41       	brne	8000c01a <__avr32_s32_to_f64+0x94>
8000c014:	ed ba 00 01 	bld	r10,0x1
8000c018:	c0 42       	brcc	8000c020 <__avr32_s32_to_f64+0x9a>
8000c01a:	2f fa       	sub	r10,-1
8000c01c:	f7 bb 02 ff 	subhs	r11,-1
8000c020:	5c fc       	rol	r12
8000c022:	5d 0b       	ror	r11
8000c024:	5d 0a       	ror	r10
8000c026:	d8 02       	popm	pc
8000c028:	e0 68 03 ff 	mov	r8,1023
8000c02c:	ed ba 00 0b 	bld	r10,0xb
8000c030:	f7 b8 00 ff 	subeq	r8,-1
8000c034:	10 0a       	add	r10,r8
8000c036:	5c 0b       	acr	r11
8000c038:	f7 b9 03 fe 	sublo	r9,-2
8000c03c:	e0 49 07 ff 	cp.w	r9,2047
8000c040:	c0 55       	brlt	8000c04a <__avr32_s32_to_f64+0xc4>
8000c042:	30 0a       	mov	r10,0
8000c044:	fc 1b ff e0 	movh	r11,0xffe0
8000c048:	c0 c8       	rjmp	8000c060 <__floatsidf_return_op1>
8000c04a:	ed bb 00 1f 	bld	r11,0x1f
8000c04e:	f7 b9 01 01 	subne	r9,1
8000c052:	ab 9a       	lsr	r10,0xb
8000c054:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c058:	a1 7b       	lsl	r11,0x1
8000c05a:	ab 9b       	lsr	r11,0xb
8000c05c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c060 <__floatsidf_return_op1>:
8000c060:	a1 7c       	lsl	r12,0x1
8000c062:	5d 0b       	ror	r11
8000c064:	d8 02       	popm	pc

8000c066 <__avr32_f64_cmp_eq>:
8000c066:	10 3a       	cp.w	r10,r8
8000c068:	f2 0b 13 00 	cpc	r11,r9
8000c06c:	c0 80       	breq	8000c07c <__avr32_f64_cmp_eq+0x16>
8000c06e:	a1 7b       	lsl	r11,0x1
8000c070:	a1 79       	lsl	r9,0x1
8000c072:	14 4b       	or	r11,r10
8000c074:	12 4b       	or	r11,r9
8000c076:	10 4b       	or	r11,r8
8000c078:	5e 0f       	reteq	1
8000c07a:	5e fd       	retal	0
8000c07c:	a1 7b       	lsl	r11,0x1
8000c07e:	fc 1c ff e0 	movh	r12,0xffe0
8000c082:	58 0a       	cp.w	r10,0
8000c084:	f8 0b 13 00 	cpc	r11,r12
8000c088:	5e 8f       	retls	1
8000c08a:	5e fd       	retal	0

8000c08c <__avr32_f64_cmp_ge>:
8000c08c:	1a de       	st.w	--sp,lr
8000c08e:	1a d7       	st.w	--sp,r7
8000c090:	a1 7b       	lsl	r11,0x1
8000c092:	5f 3c       	srlo	r12
8000c094:	a1 79       	lsl	r9,0x1
8000c096:	5f 37       	srlo	r7
8000c098:	5c fc       	rol	r12
8000c09a:	fc 1e ff e0 	movh	lr,0xffe0
8000c09e:	58 0a       	cp.w	r10,0
8000c0a0:	fc 0b 13 00 	cpc	r11,lr
8000c0a4:	e0 8b 00 1d 	brhi	8000c0de <__avr32_f64_cmp_ge+0x52>
8000c0a8:	58 08       	cp.w	r8,0
8000c0aa:	fc 09 13 00 	cpc	r9,lr
8000c0ae:	e0 8b 00 18 	brhi	8000c0de <__avr32_f64_cmp_ge+0x52>
8000c0b2:	58 0b       	cp.w	r11,0
8000c0b4:	f5 ba 00 00 	subfeq	r10,0
8000c0b8:	c1 50       	breq	8000c0e2 <__avr32_f64_cmp_ge+0x56>
8000c0ba:	1b 07       	ld.w	r7,sp++
8000c0bc:	1b 0e       	ld.w	lr,sp++
8000c0be:	58 3c       	cp.w	r12,3
8000c0c0:	c0 a0       	breq	8000c0d4 <__avr32_f64_cmp_ge+0x48>
8000c0c2:	58 1c       	cp.w	r12,1
8000c0c4:	c0 33       	brcs	8000c0ca <__avr32_f64_cmp_ge+0x3e>
8000c0c6:	5e 0f       	reteq	1
8000c0c8:	5e 1d       	retne	0
8000c0ca:	10 3a       	cp.w	r10,r8
8000c0cc:	f2 0b 13 00 	cpc	r11,r9
8000c0d0:	5e 2f       	reths	1
8000c0d2:	5e 3d       	retlo	0
8000c0d4:	14 38       	cp.w	r8,r10
8000c0d6:	f6 09 13 00 	cpc	r9,r11
8000c0da:	5e 2f       	reths	1
8000c0dc:	5e 3d       	retlo	0
8000c0de:	1b 07       	ld.w	r7,sp++
8000c0e0:	d8 0a       	popm	pc,r12=0
8000c0e2:	58 17       	cp.w	r7,1
8000c0e4:	5f 0c       	sreq	r12
8000c0e6:	58 09       	cp.w	r9,0
8000c0e8:	f5 b8 00 00 	subfeq	r8,0
8000c0ec:	1b 07       	ld.w	r7,sp++
8000c0ee:	1b 0e       	ld.w	lr,sp++
8000c0f0:	5e 0f       	reteq	1
8000c0f2:	5e fc       	retal	r12

8000c0f4 <__avr32_f64_cmp_lt>:
8000c0f4:	1a de       	st.w	--sp,lr
8000c0f6:	1a d7       	st.w	--sp,r7
8000c0f8:	a1 7b       	lsl	r11,0x1
8000c0fa:	5f 3c       	srlo	r12
8000c0fc:	a1 79       	lsl	r9,0x1
8000c0fe:	5f 37       	srlo	r7
8000c100:	5c fc       	rol	r12
8000c102:	fc 1e ff e0 	movh	lr,0xffe0
8000c106:	58 0a       	cp.w	r10,0
8000c108:	fc 0b 13 00 	cpc	r11,lr
8000c10c:	e0 8b 00 1d 	brhi	8000c146 <__avr32_f64_cmp_lt+0x52>
8000c110:	58 08       	cp.w	r8,0
8000c112:	fc 09 13 00 	cpc	r9,lr
8000c116:	e0 8b 00 18 	brhi	8000c146 <__avr32_f64_cmp_lt+0x52>
8000c11a:	58 0b       	cp.w	r11,0
8000c11c:	f5 ba 00 00 	subfeq	r10,0
8000c120:	c1 50       	breq	8000c14a <__avr32_f64_cmp_lt+0x56>
8000c122:	1b 07       	ld.w	r7,sp++
8000c124:	1b 0e       	ld.w	lr,sp++
8000c126:	58 3c       	cp.w	r12,3
8000c128:	c0 a0       	breq	8000c13c <__avr32_f64_cmp_lt+0x48>
8000c12a:	58 1c       	cp.w	r12,1
8000c12c:	c0 33       	brcs	8000c132 <__avr32_f64_cmp_lt+0x3e>
8000c12e:	5e 0d       	reteq	0
8000c130:	5e 1f       	retne	1
8000c132:	10 3a       	cp.w	r10,r8
8000c134:	f2 0b 13 00 	cpc	r11,r9
8000c138:	5e 2d       	reths	0
8000c13a:	5e 3f       	retlo	1
8000c13c:	14 38       	cp.w	r8,r10
8000c13e:	f6 09 13 00 	cpc	r9,r11
8000c142:	5e 2d       	reths	0
8000c144:	5e 3f       	retlo	1
8000c146:	1b 07       	ld.w	r7,sp++
8000c148:	d8 0a       	popm	pc,r12=0
8000c14a:	58 17       	cp.w	r7,1
8000c14c:	5f 1c       	srne	r12
8000c14e:	58 09       	cp.w	r9,0
8000c150:	f5 b8 00 00 	subfeq	r8,0
8000c154:	1b 07       	ld.w	r7,sp++
8000c156:	1b 0e       	ld.w	lr,sp++
8000c158:	5e 0d       	reteq	0
8000c15a:	5e fc       	retal	r12

8000c15c <__avr32_f64_div>:
8000c15c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c160:	f7 e9 20 0e 	eor	lr,r11,r9
8000c164:	f6 07 16 14 	lsr	r7,r11,0x14
8000c168:	a9 7b       	lsl	r11,0x9
8000c16a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c16e:	a9 7a       	lsl	r10,0x9
8000c170:	bd bb       	sbr	r11,0x1d
8000c172:	e4 1b 3f ff 	andh	r11,0x3fff
8000c176:	ab d7       	cbr	r7,0xb
8000c178:	e0 80 00 cc 	breq	8000c310 <__avr32_f64_div_round_subnormal+0x54>
8000c17c:	e0 47 07 ff 	cp.w	r7,2047
8000c180:	e0 84 00 b5 	brge	8000c2ea <__avr32_f64_div_round_subnormal+0x2e>
8000c184:	f2 06 16 14 	lsr	r6,r9,0x14
8000c188:	a9 79       	lsl	r9,0x9
8000c18a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c18e:	a9 78       	lsl	r8,0x9
8000c190:	bd b9       	sbr	r9,0x1d
8000c192:	e4 19 3f ff 	andh	r9,0x3fff
8000c196:	ab d6       	cbr	r6,0xb
8000c198:	e0 80 00 e2 	breq	8000c35c <__avr32_f64_div_round_subnormal+0xa0>
8000c19c:	e0 46 07 ff 	cp.w	r6,2047
8000c1a0:	e0 84 00 b2 	brge	8000c304 <__avr32_f64_div_round_subnormal+0x48>
8000c1a4:	0c 17       	sub	r7,r6
8000c1a6:	fe 37 fc 01 	sub	r7,-1023
8000c1aa:	fc 1c 80 00 	movh	r12,0x8000
8000c1ae:	f8 03 16 01 	lsr	r3,r12,0x1
8000c1b2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c1b6:	5c d4       	com	r4
8000c1b8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c1bc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c1c0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c1c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c1c8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c1cc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c1d0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c1d4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c1d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c1dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c1e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c1e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c1e8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c1ec:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c1f0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c1f4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c1f8:	02 04       	add	r4,r1
8000c1fa:	5c 05       	acr	r5
8000c1fc:	a3 65       	lsl	r5,0x2
8000c1fe:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c202:	a3 64       	lsl	r4,0x2
8000c204:	5c 34       	neg	r4
8000c206:	f8 05 01 45 	sbc	r5,r12,r5
8000c20a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c20e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c212:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c216:	02 04       	add	r4,r1
8000c218:	5c 05       	acr	r5
8000c21a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c21e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c222:	e8 02 15 02 	lsl	r2,r4,0x2
8000c226:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c22a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c22e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c232:	02 04       	add	r4,r1
8000c234:	5c 05       	acr	r5
8000c236:	a3 65       	lsl	r5,0x2
8000c238:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c23c:	a3 64       	lsl	r4,0x2
8000c23e:	5c 34       	neg	r4
8000c240:	f8 05 01 45 	sbc	r5,r12,r5
8000c244:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c248:	e4 05 07 40 	macu.d	r0,r2,r5
8000c24c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c250:	02 04       	add	r4,r1
8000c252:	5c 05       	acr	r5
8000c254:	ea 03 15 02 	lsl	r3,r5,0x2
8000c258:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c25c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c260:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c264:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c268:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c26c:	02 02       	add	r2,r1
8000c26e:	5c 03       	acr	r3
8000c270:	ed b3 00 1c 	bld	r3,0x1c
8000c274:	c0 90       	breq	8000c286 <__avr32_f64_div+0x12a>
8000c276:	a1 72       	lsl	r2,0x1
8000c278:	5c f3       	rol	r3
8000c27a:	20 17       	sub	r7,1
8000c27c:	a3 9a       	lsr	r10,0x3
8000c27e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c282:	a3 9b       	lsr	r11,0x3
8000c284:	c0 58       	rjmp	8000c28e <__avr32_f64_div+0x132>
8000c286:	a5 8a       	lsr	r10,0x4
8000c288:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c28c:	a5 8b       	lsr	r11,0x4
8000c28e:	58 07       	cp.w	r7,0
8000c290:	e0 8a 00 8b 	brle	8000c3a6 <__avr32_f64_div_res_subnormal>
8000c294:	e0 12 ff 00 	andl	r2,0xff00
8000c298:	e8 12 00 80 	orl	r2,0x80
8000c29c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c2a0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c2a4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c2a8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c2ac:	00 05       	add	r5,r0
8000c2ae:	f0 01 00 48 	adc	r8,r8,r1
8000c2b2:	5c 09       	acr	r9
8000c2b4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c2b8:	58 04       	cp.w	r4,0
8000c2ba:	5c 25       	cpc	r5

8000c2bc <__avr32_f64_div_round_subnormal>:
8000c2bc:	f4 08 13 00 	cpc	r8,r10
8000c2c0:	f6 09 13 00 	cpc	r9,r11
8000c2c4:	5f 36       	srlo	r6
8000c2c6:	f8 06 17 00 	moveq	r6,r12
8000c2ca:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c2ce:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c2d2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c2d6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2da:	ed be 00 1f 	bld	lr,0x1f
8000c2de:	ef bb 00 1f 	bst	r11,0x1f
8000c2e2:	0c 0a       	add	r10,r6
8000c2e4:	5c 0b       	acr	r11
8000c2e6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c2ea:	e4 1b 00 0f 	andh	r11,0xf
8000c2ee:	14 4b       	or	r11,r10
8000c2f0:	e0 81 00 a7 	brne	8000c43e <__avr32_f64_div_res_subnormal+0x98>
8000c2f4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c2f8:	ab d6       	cbr	r6,0xb
8000c2fa:	e0 46 07 ff 	cp.w	r6,2047
8000c2fe:	e0 81 00 a4 	brne	8000c446 <__avr32_f64_div_res_subnormal+0xa0>
8000c302:	c9 e8       	rjmp	8000c43e <__avr32_f64_div_res_subnormal+0x98>
8000c304:	e4 19 00 0f 	andh	r9,0xf
8000c308:	10 49       	or	r9,r8
8000c30a:	e0 81 00 9a 	brne	8000c43e <__avr32_f64_div_res_subnormal+0x98>
8000c30e:	c9 28       	rjmp	8000c432 <__avr32_f64_div_res_subnormal+0x8c>
8000c310:	a3 7b       	lsl	r11,0x3
8000c312:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c316:	a3 7a       	lsl	r10,0x3
8000c318:	f5 eb 10 04 	or	r4,r10,r11
8000c31c:	e0 80 00 a0 	breq	8000c45c <__avr32_f64_div_op1_zero>
8000c320:	f6 04 12 00 	clz	r4,r11
8000c324:	c1 70       	breq	8000c352 <__avr32_f64_div_round_subnormal+0x96>
8000c326:	c0 c3       	brcs	8000c33e <__avr32_f64_div_round_subnormal+0x82>
8000c328:	e8 05 11 20 	rsub	r5,r4,32
8000c32c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c330:	f4 05 0a 45 	lsr	r5,r10,r5
8000c334:	0a 4b       	or	r11,r5
8000c336:	f4 04 09 4a 	lsl	r10,r10,r4
8000c33a:	08 17       	sub	r7,r4
8000c33c:	c0 b8       	rjmp	8000c352 <__avr32_f64_div_round_subnormal+0x96>
8000c33e:	f4 04 12 00 	clz	r4,r10
8000c342:	f9 b4 03 00 	movlo	r4,0
8000c346:	f7 b4 02 e0 	subhs	r4,-32
8000c34a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c34e:	30 0a       	mov	r10,0
8000c350:	08 17       	sub	r7,r4
8000c352:	a3 8a       	lsr	r10,0x2
8000c354:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c358:	a3 8b       	lsr	r11,0x2
8000c35a:	c1 1b       	rjmp	8000c17c <__avr32_f64_div+0x20>
8000c35c:	a3 79       	lsl	r9,0x3
8000c35e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c362:	a3 78       	lsl	r8,0x3
8000c364:	f3 e8 10 04 	or	r4,r9,r8
8000c368:	c6 f0       	breq	8000c446 <__avr32_f64_div_res_subnormal+0xa0>
8000c36a:	f2 04 12 00 	clz	r4,r9
8000c36e:	c1 70       	breq	8000c39c <__avr32_f64_div_round_subnormal+0xe0>
8000c370:	c0 c3       	brcs	8000c388 <__avr32_f64_div_round_subnormal+0xcc>
8000c372:	e8 05 11 20 	rsub	r5,r4,32
8000c376:	f2 04 09 49 	lsl	r9,r9,r4
8000c37a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c37e:	0a 49       	or	r9,r5
8000c380:	f0 04 09 48 	lsl	r8,r8,r4
8000c384:	08 16       	sub	r6,r4
8000c386:	c0 b8       	rjmp	8000c39c <__avr32_f64_div_round_subnormal+0xe0>
8000c388:	f0 04 12 00 	clz	r4,r8
8000c38c:	f9 b4 03 00 	movlo	r4,0
8000c390:	f7 b4 02 e0 	subhs	r4,-32
8000c394:	f0 04 09 49 	lsl	r9,r8,r4
8000c398:	30 08       	mov	r8,0
8000c39a:	08 16       	sub	r6,r4
8000c39c:	a3 88       	lsr	r8,0x2
8000c39e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c3a2:	a3 89       	lsr	r9,0x2
8000c3a4:	cf ca       	rjmp	8000c19c <__avr32_f64_div+0x40>

8000c3a6 <__avr32_f64_div_res_subnormal>:
8000c3a6:	5c 37       	neg	r7
8000c3a8:	2f f7       	sub	r7,-1
8000c3aa:	f1 b7 04 c0 	satu	r7,0x6
8000c3ae:	e0 47 00 20 	cp.w	r7,32
8000c3b2:	c1 54       	brge	8000c3dc <__avr32_f64_div_res_subnormal+0x36>
8000c3b4:	ee 06 11 20 	rsub	r6,r7,32
8000c3b8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c3bc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c3c0:	18 42       	or	r2,r12
8000c3c2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c3c6:	f4 06 09 41 	lsl	r1,r10,r6
8000c3ca:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c3ce:	f6 06 09 4c 	lsl	r12,r11,r6
8000c3d2:	18 4a       	or	r10,r12
8000c3d4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c3d8:	30 00       	mov	r0,0
8000c3da:	c1 58       	rjmp	8000c404 <__avr32_f64_div_res_subnormal+0x5e>
8000c3dc:	ee 06 11 20 	rsub	r6,r7,32
8000c3e0:	f9 b0 00 00 	moveq	r0,0
8000c3e4:	f9 bc 00 00 	moveq	r12,0
8000c3e8:	c0 50       	breq	8000c3f2 <__avr32_f64_div_res_subnormal+0x4c>
8000c3ea:	f4 06 09 40 	lsl	r0,r10,r6
8000c3ee:	f6 06 09 4c 	lsl	r12,r11,r6
8000c3f2:	e6 07 0a 42 	lsr	r2,r3,r7
8000c3f6:	30 03       	mov	r3,0
8000c3f8:	f4 07 0a 41 	lsr	r1,r10,r7
8000c3fc:	18 41       	or	r1,r12
8000c3fe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c402:	30 0b       	mov	r11,0
8000c404:	e0 12 ff 00 	andl	r2,0xff00
8000c408:	e8 12 00 80 	orl	r2,0x80
8000c40c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c410:	e4 09 07 46 	macu.d	r6,r2,r9
8000c414:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c418:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c41c:	0c 05       	add	r5,r6
8000c41e:	f0 07 00 48 	adc	r8,r8,r7
8000c422:	5c 09       	acr	r9
8000c424:	30 07       	mov	r7,0
8000c426:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c42a:	00 34       	cp.w	r4,r0
8000c42c:	e2 05 13 00 	cpc	r5,r1
8000c430:	c4 6b       	rjmp	8000c2bc <__avr32_f64_div_round_subnormal>
8000c432:	1c 9b       	mov	r11,lr
8000c434:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c438:	30 0a       	mov	r10,0
8000c43a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c43e:	3f fb       	mov	r11,-1
8000c440:	30 0a       	mov	r10,0
8000c442:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c446:	f5 eb 10 04 	or	r4,r10,r11
8000c44a:	c0 90       	breq	8000c45c <__avr32_f64_div_op1_zero>
8000c44c:	1c 9b       	mov	r11,lr
8000c44e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c452:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c456:	30 0a       	mov	r10,0
8000c458:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c45c <__avr32_f64_div_op1_zero>:
8000c45c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c460:	ce f0       	breq	8000c43e <__avr32_f64_div_res_subnormal+0x98>
8000c462:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c466:	e0 44 07 ff 	cp.w	r4,2047
8000c46a:	ce 41       	brne	8000c432 <__avr32_f64_div_res_subnormal+0x8c>
8000c46c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c470:	ce 10       	breq	8000c432 <__avr32_f64_div_res_subnormal+0x8c>
8000c472:	ce 6b       	rjmp	8000c43e <__avr32_f64_div_res_subnormal+0x98>

8000c474 <__avr32_udiv64>:
8000c474:	d4 31       	pushm	r0-r7,lr
8000c476:	1a 97       	mov	r7,sp
8000c478:	20 3d       	sub	sp,12
8000c47a:	10 9c       	mov	r12,r8
8000c47c:	12 9e       	mov	lr,r9
8000c47e:	14 93       	mov	r3,r10
8000c480:	58 09       	cp.w	r9,0
8000c482:	e0 81 00 bd 	brne	8000c5fc <__avr32_udiv64+0x188>
8000c486:	16 38       	cp.w	r8,r11
8000c488:	e0 88 00 40 	brls	8000c508 <__avr32_udiv64+0x94>
8000c48c:	f0 08 12 00 	clz	r8,r8
8000c490:	c0 d0       	breq	8000c4aa <__avr32_udiv64+0x36>
8000c492:	f6 08 09 4b 	lsl	r11,r11,r8
8000c496:	f0 09 11 20 	rsub	r9,r8,32
8000c49a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c49e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c4a2:	f4 08 09 43 	lsl	r3,r10,r8
8000c4a6:	f3 eb 10 0b 	or	r11,r9,r11
8000c4aa:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c4ae:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c4b2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c4b6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c4ba:	00 99       	mov	r9,r0
8000c4bc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c4c0:	e0 0a 02 48 	mul	r8,r0,r10
8000c4c4:	10 3b       	cp.w	r11,r8
8000c4c6:	c0 a2       	brcc	8000c4da <__avr32_udiv64+0x66>
8000c4c8:	20 19       	sub	r9,1
8000c4ca:	18 0b       	add	r11,r12
8000c4cc:	18 3b       	cp.w	r11,r12
8000c4ce:	c0 63       	brcs	8000c4da <__avr32_udiv64+0x66>
8000c4d0:	10 3b       	cp.w	r11,r8
8000c4d2:	f7 b9 03 01 	sublo	r9,1
8000c4d6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4da:	f6 08 01 01 	sub	r1,r11,r8
8000c4de:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c4e2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c4e6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c4ea:	00 98       	mov	r8,r0
8000c4ec:	e0 0a 02 4a 	mul	r10,r0,r10
8000c4f0:	14 33       	cp.w	r3,r10
8000c4f2:	c0 82       	brcc	8000c502 <__avr32_udiv64+0x8e>
8000c4f4:	20 18       	sub	r8,1
8000c4f6:	18 03       	add	r3,r12
8000c4f8:	18 33       	cp.w	r3,r12
8000c4fa:	c0 43       	brcs	8000c502 <__avr32_udiv64+0x8e>
8000c4fc:	14 33       	cp.w	r3,r10
8000c4fe:	f7 b8 03 01 	sublo	r8,1
8000c502:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c506:	cd f8       	rjmp	8000c6c4 <__avr32_udiv64+0x250>
8000c508:	58 08       	cp.w	r8,0
8000c50a:	c0 51       	brne	8000c514 <__avr32_udiv64+0xa0>
8000c50c:	30 19       	mov	r9,1
8000c50e:	f2 08 0d 08 	divu	r8,r9,r8
8000c512:	10 9c       	mov	r12,r8
8000c514:	f8 06 12 00 	clz	r6,r12
8000c518:	c0 41       	brne	8000c520 <__avr32_udiv64+0xac>
8000c51a:	18 1b       	sub	r11,r12
8000c51c:	30 19       	mov	r9,1
8000c51e:	c4 08       	rjmp	8000c59e <__avr32_udiv64+0x12a>
8000c520:	ec 01 11 20 	rsub	r1,r6,32
8000c524:	f4 01 0a 49 	lsr	r9,r10,r1
8000c528:	f8 06 09 4c 	lsl	r12,r12,r6
8000c52c:	f6 06 09 48 	lsl	r8,r11,r6
8000c530:	f6 01 0a 41 	lsr	r1,r11,r1
8000c534:	f3 e8 10 08 	or	r8,r9,r8
8000c538:	f8 03 16 10 	lsr	r3,r12,0x10
8000c53c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c540:	e2 03 0d 00 	divu	r0,r1,r3
8000c544:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c548:	00 9e       	mov	lr,r0
8000c54a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c54e:	e0 05 02 49 	mul	r9,r0,r5
8000c552:	12 3b       	cp.w	r11,r9
8000c554:	c0 a2       	brcc	8000c568 <__avr32_udiv64+0xf4>
8000c556:	20 1e       	sub	lr,1
8000c558:	18 0b       	add	r11,r12
8000c55a:	18 3b       	cp.w	r11,r12
8000c55c:	c0 63       	brcs	8000c568 <__avr32_udiv64+0xf4>
8000c55e:	12 3b       	cp.w	r11,r9
8000c560:	f7 be 03 01 	sublo	lr,1
8000c564:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c568:	12 1b       	sub	r11,r9
8000c56a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c56e:	f6 03 0d 02 	divu	r2,r11,r3
8000c572:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c576:	04 99       	mov	r9,r2
8000c578:	e4 05 02 4b 	mul	r11,r2,r5
8000c57c:	16 38       	cp.w	r8,r11
8000c57e:	c0 a2       	brcc	8000c592 <__avr32_udiv64+0x11e>
8000c580:	20 19       	sub	r9,1
8000c582:	18 08       	add	r8,r12
8000c584:	18 38       	cp.w	r8,r12
8000c586:	c0 63       	brcs	8000c592 <__avr32_udiv64+0x11e>
8000c588:	16 38       	cp.w	r8,r11
8000c58a:	f7 b9 03 01 	sublo	r9,1
8000c58e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c592:	f4 06 09 43 	lsl	r3,r10,r6
8000c596:	f0 0b 01 0b 	sub	r11,r8,r11
8000c59a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c59e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c5a2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c5a6:	f6 06 0d 00 	divu	r0,r11,r6
8000c5aa:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c5ae:	00 9a       	mov	r10,r0
8000c5b0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c5b4:	e0 0e 02 48 	mul	r8,r0,lr
8000c5b8:	10 3b       	cp.w	r11,r8
8000c5ba:	c0 a2       	brcc	8000c5ce <__avr32_udiv64+0x15a>
8000c5bc:	20 1a       	sub	r10,1
8000c5be:	18 0b       	add	r11,r12
8000c5c0:	18 3b       	cp.w	r11,r12
8000c5c2:	c0 63       	brcs	8000c5ce <__avr32_udiv64+0x15a>
8000c5c4:	10 3b       	cp.w	r11,r8
8000c5c6:	f7 ba 03 01 	sublo	r10,1
8000c5ca:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c5ce:	f6 08 01 01 	sub	r1,r11,r8
8000c5d2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c5d6:	e2 06 0d 00 	divu	r0,r1,r6
8000c5da:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c5de:	00 98       	mov	r8,r0
8000c5e0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c5e4:	16 33       	cp.w	r3,r11
8000c5e6:	c0 82       	brcc	8000c5f6 <__avr32_udiv64+0x182>
8000c5e8:	20 18       	sub	r8,1
8000c5ea:	18 03       	add	r3,r12
8000c5ec:	18 33       	cp.w	r3,r12
8000c5ee:	c0 43       	brcs	8000c5f6 <__avr32_udiv64+0x182>
8000c5f0:	16 33       	cp.w	r3,r11
8000c5f2:	f7 b8 03 01 	sublo	r8,1
8000c5f6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c5fa:	c6 98       	rjmp	8000c6cc <__avr32_udiv64+0x258>
8000c5fc:	16 39       	cp.w	r9,r11
8000c5fe:	e0 8b 00 65 	brhi	8000c6c8 <__avr32_udiv64+0x254>
8000c602:	f2 09 12 00 	clz	r9,r9
8000c606:	c0 b1       	brne	8000c61c <__avr32_udiv64+0x1a8>
8000c608:	10 3a       	cp.w	r10,r8
8000c60a:	5f 2a       	srhs	r10
8000c60c:	1c 3b       	cp.w	r11,lr
8000c60e:	5f b8       	srhi	r8
8000c610:	10 4a       	or	r10,r8
8000c612:	f2 0a 18 00 	cp.b	r10,r9
8000c616:	c5 90       	breq	8000c6c8 <__avr32_udiv64+0x254>
8000c618:	30 18       	mov	r8,1
8000c61a:	c5 98       	rjmp	8000c6cc <__avr32_udiv64+0x258>
8000c61c:	f0 09 09 46 	lsl	r6,r8,r9
8000c620:	f2 03 11 20 	rsub	r3,r9,32
8000c624:	fc 09 09 4e 	lsl	lr,lr,r9
8000c628:	f0 03 0a 48 	lsr	r8,r8,r3
8000c62c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c630:	f4 03 0a 42 	lsr	r2,r10,r3
8000c634:	ef 46 ff f4 	st.w	r7[-12],r6
8000c638:	f6 03 0a 43 	lsr	r3,r11,r3
8000c63c:	18 42       	or	r2,r12
8000c63e:	f1 ee 10 0c 	or	r12,r8,lr
8000c642:	f8 01 16 10 	lsr	r1,r12,0x10
8000c646:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c64a:	e6 01 0d 04 	divu	r4,r3,r1
8000c64e:	e4 03 16 10 	lsr	r3,r2,0x10
8000c652:	08 9e       	mov	lr,r4
8000c654:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c658:	e8 06 02 48 	mul	r8,r4,r6
8000c65c:	10 33       	cp.w	r3,r8
8000c65e:	c0 a2       	brcc	8000c672 <__avr32_udiv64+0x1fe>
8000c660:	20 1e       	sub	lr,1
8000c662:	18 03       	add	r3,r12
8000c664:	18 33       	cp.w	r3,r12
8000c666:	c0 63       	brcs	8000c672 <__avr32_udiv64+0x1fe>
8000c668:	10 33       	cp.w	r3,r8
8000c66a:	f7 be 03 01 	sublo	lr,1
8000c66e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c672:	10 13       	sub	r3,r8
8000c674:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c678:	e6 01 0d 00 	divu	r0,r3,r1
8000c67c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c680:	00 98       	mov	r8,r0
8000c682:	e0 06 02 46 	mul	r6,r0,r6
8000c686:	0c 3b       	cp.w	r11,r6
8000c688:	c0 a2       	brcc	8000c69c <__avr32_udiv64+0x228>
8000c68a:	20 18       	sub	r8,1
8000c68c:	18 0b       	add	r11,r12
8000c68e:	18 3b       	cp.w	r11,r12
8000c690:	c0 63       	brcs	8000c69c <__avr32_udiv64+0x228>
8000c692:	0c 3b       	cp.w	r11,r6
8000c694:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c698:	f7 b8 03 01 	sublo	r8,1
8000c69c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c6a0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c6a4:	0c 1b       	sub	r11,r6
8000c6a6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c6aa:	06 95       	mov	r5,r3
8000c6ac:	16 35       	cp.w	r5,r11
8000c6ae:	e0 8b 00 0a 	brhi	8000c6c2 <__avr32_udiv64+0x24e>
8000c6b2:	5f 0b       	sreq	r11
8000c6b4:	f4 09 09 49 	lsl	r9,r10,r9
8000c6b8:	12 32       	cp.w	r2,r9
8000c6ba:	5f b9       	srhi	r9
8000c6bc:	f7 e9 00 09 	and	r9,r11,r9
8000c6c0:	c0 60       	breq	8000c6cc <__avr32_udiv64+0x258>
8000c6c2:	20 18       	sub	r8,1
8000c6c4:	30 09       	mov	r9,0
8000c6c6:	c0 38       	rjmp	8000c6cc <__avr32_udiv64+0x258>
8000c6c8:	30 09       	mov	r9,0
8000c6ca:	12 98       	mov	r8,r9
8000c6cc:	10 9a       	mov	r10,r8
8000c6ce:	12 93       	mov	r3,r9
8000c6d0:	10 92       	mov	r2,r8
8000c6d2:	12 9b       	mov	r11,r9
8000c6d4:	2f dd       	sub	sp,-12
8000c6d6:	d8 32       	popm	r0-r7,pc

8000c6d8 <__avr32_umod64>:
8000c6d8:	d4 31       	pushm	r0-r7,lr
8000c6da:	1a 97       	mov	r7,sp
8000c6dc:	20 3d       	sub	sp,12
8000c6de:	10 9c       	mov	r12,r8
8000c6e0:	12 95       	mov	r5,r9
8000c6e2:	14 9e       	mov	lr,r10
8000c6e4:	16 91       	mov	r1,r11
8000c6e6:	16 96       	mov	r6,r11
8000c6e8:	58 09       	cp.w	r9,0
8000c6ea:	e0 81 00 81 	brne	8000c7ec <__avr32_umod64+0x114>
8000c6ee:	16 38       	cp.w	r8,r11
8000c6f0:	e0 88 00 12 	brls	8000c714 <__avr32_umod64+0x3c>
8000c6f4:	f0 08 12 00 	clz	r8,r8
8000c6f8:	c4 e0       	breq	8000c794 <__avr32_umod64+0xbc>
8000c6fa:	f6 08 09 46 	lsl	r6,r11,r8
8000c6fe:	f8 08 09 4c 	lsl	r12,r12,r8
8000c702:	f0 0b 11 20 	rsub	r11,r8,32
8000c706:	f4 08 09 4e 	lsl	lr,r10,r8
8000c70a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c70e:	f7 e6 10 06 	or	r6,r11,r6
8000c712:	c4 18       	rjmp	8000c794 <__avr32_umod64+0xbc>
8000c714:	58 08       	cp.w	r8,0
8000c716:	c0 51       	brne	8000c720 <__avr32_umod64+0x48>
8000c718:	30 19       	mov	r9,1
8000c71a:	f2 08 0d 08 	divu	r8,r9,r8
8000c71e:	10 9c       	mov	r12,r8
8000c720:	f8 08 12 00 	clz	r8,r12
8000c724:	c0 31       	brne	8000c72a <__avr32_umod64+0x52>
8000c726:	18 16       	sub	r6,r12
8000c728:	c3 68       	rjmp	8000c794 <__avr32_umod64+0xbc>
8000c72a:	f0 03 11 20 	rsub	r3,r8,32
8000c72e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c732:	f8 08 09 4c 	lsl	r12,r12,r8
8000c736:	ec 08 09 49 	lsl	r9,r6,r8
8000c73a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c73e:	f7 e9 10 09 	or	r9,r11,r9
8000c742:	f8 05 16 10 	lsr	r5,r12,0x10
8000c746:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c74a:	e6 05 0d 02 	divu	r2,r3,r5
8000c74e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c752:	ec 02 02 4b 	mul	r11,r6,r2
8000c756:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c75a:	16 3e       	cp.w	lr,r11
8000c75c:	c0 72       	brcc	8000c76a <__avr32_umod64+0x92>
8000c75e:	18 0e       	add	lr,r12
8000c760:	18 3e       	cp.w	lr,r12
8000c762:	c0 43       	brcs	8000c76a <__avr32_umod64+0x92>
8000c764:	16 3e       	cp.w	lr,r11
8000c766:	fd dc e3 0e 	addcs	lr,lr,r12
8000c76a:	fc 0b 01 03 	sub	r3,lr,r11
8000c76e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c772:	e6 05 0d 02 	divu	r2,r3,r5
8000c776:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c77a:	a5 36       	mul	r6,r2
8000c77c:	0c 39       	cp.w	r9,r6
8000c77e:	c0 72       	brcc	8000c78c <__avr32_umod64+0xb4>
8000c780:	18 09       	add	r9,r12
8000c782:	18 39       	cp.w	r9,r12
8000c784:	c0 43       	brcs	8000c78c <__avr32_umod64+0xb4>
8000c786:	0c 39       	cp.w	r9,r6
8000c788:	f3 dc e3 09 	addcs	r9,r9,r12
8000c78c:	f2 06 01 06 	sub	r6,r9,r6
8000c790:	f4 08 09 4e 	lsl	lr,r10,r8
8000c794:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c798:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c79c:	ec 0a 0d 02 	divu	r2,r6,r10
8000c7a0:	fc 09 16 10 	lsr	r9,lr,0x10
8000c7a4:	ea 02 02 4b 	mul	r11,r5,r2
8000c7a8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c7ac:	16 39       	cp.w	r9,r11
8000c7ae:	c0 72       	brcc	8000c7bc <__avr32_umod64+0xe4>
8000c7b0:	18 09       	add	r9,r12
8000c7b2:	18 39       	cp.w	r9,r12
8000c7b4:	c0 43       	brcs	8000c7bc <__avr32_umod64+0xe4>
8000c7b6:	16 39       	cp.w	r9,r11
8000c7b8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c7bc:	f2 0b 01 0b 	sub	r11,r9,r11
8000c7c0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c7c4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c7c8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c7cc:	ea 0a 02 4a 	mul	r10,r5,r10
8000c7d0:	14 3e       	cp.w	lr,r10
8000c7d2:	c0 72       	brcc	8000c7e0 <__avr32_umod64+0x108>
8000c7d4:	18 0e       	add	lr,r12
8000c7d6:	18 3e       	cp.w	lr,r12
8000c7d8:	c0 43       	brcs	8000c7e0 <__avr32_umod64+0x108>
8000c7da:	14 3e       	cp.w	lr,r10
8000c7dc:	fd dc e3 0e 	addcs	lr,lr,r12
8000c7e0:	fc 0a 01 0a 	sub	r10,lr,r10
8000c7e4:	30 0b       	mov	r11,0
8000c7e6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c7ea:	c7 b8       	rjmp	8000c8e0 <__avr32_umod64+0x208>
8000c7ec:	16 39       	cp.w	r9,r11
8000c7ee:	e0 8b 00 79 	brhi	8000c8e0 <__avr32_umod64+0x208>
8000c7f2:	f2 09 12 00 	clz	r9,r9
8000c7f6:	c1 21       	brne	8000c81a <__avr32_umod64+0x142>
8000c7f8:	10 3a       	cp.w	r10,r8
8000c7fa:	5f 2b       	srhs	r11
8000c7fc:	0a 31       	cp.w	r1,r5
8000c7fe:	5f ba       	srhi	r10
8000c800:	f7 ea 10 0a 	or	r10,r11,r10
8000c804:	f2 0a 18 00 	cp.b	r10,r9
8000c808:	c0 60       	breq	8000c814 <__avr32_umod64+0x13c>
8000c80a:	fc 08 01 0c 	sub	r12,lr,r8
8000c80e:	e2 05 01 46 	sbc	r6,r1,r5
8000c812:	18 9e       	mov	lr,r12
8000c814:	0c 9b       	mov	r11,r6
8000c816:	1c 9a       	mov	r10,lr
8000c818:	c6 48       	rjmp	8000c8e0 <__avr32_umod64+0x208>
8000c81a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c81e:	f2 06 11 20 	rsub	r6,r9,32
8000c822:	f6 09 09 4b 	lsl	r11,r11,r9
8000c826:	f0 09 09 42 	lsl	r2,r8,r9
8000c82a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c82e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c832:	18 48       	or	r8,r12
8000c834:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c838:	f4 09 09 43 	lsl	r3,r10,r9
8000c83c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c840:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c844:	16 4a       	or	r10,r11
8000c846:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c84a:	f8 0b 0d 04 	divu	r4,r12,r11
8000c84e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c852:	08 91       	mov	r1,r4
8000c854:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c858:	e8 0e 02 46 	mul	r6,r4,lr
8000c85c:	0c 3c       	cp.w	r12,r6
8000c85e:	c0 a2       	brcc	8000c872 <__avr32_umod64+0x19a>
8000c860:	20 11       	sub	r1,1
8000c862:	10 0c       	add	r12,r8
8000c864:	10 3c       	cp.w	r12,r8
8000c866:	c0 63       	brcs	8000c872 <__avr32_umod64+0x19a>
8000c868:	0c 3c       	cp.w	r12,r6
8000c86a:	f7 b1 03 01 	sublo	r1,1
8000c86e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c872:	0c 1c       	sub	r12,r6
8000c874:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c878:	f8 0b 0d 04 	divu	r4,r12,r11
8000c87c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c880:	08 96       	mov	r6,r4
8000c882:	e8 0e 02 4e 	mul	lr,r4,lr
8000c886:	1c 3b       	cp.w	r11,lr
8000c888:	c0 a2       	brcc	8000c89c <__avr32_umod64+0x1c4>
8000c88a:	20 16       	sub	r6,1
8000c88c:	10 0b       	add	r11,r8
8000c88e:	10 3b       	cp.w	r11,r8
8000c890:	c0 63       	brcs	8000c89c <__avr32_umod64+0x1c4>
8000c892:	1c 3b       	cp.w	r11,lr
8000c894:	f7 b6 03 01 	sublo	r6,1
8000c898:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c89c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c8a0:	1c 1b       	sub	r11,lr
8000c8a2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c8a6:	00 9e       	mov	lr,r0
8000c8a8:	02 9c       	mov	r12,r1
8000c8aa:	16 3c       	cp.w	r12,r11
8000c8ac:	e0 8b 00 08 	brhi	8000c8bc <__avr32_umod64+0x1e4>
8000c8b0:	5f 06       	sreq	r6
8000c8b2:	06 30       	cp.w	r0,r3
8000c8b4:	5f ba       	srhi	r10
8000c8b6:	ed ea 00 0a 	and	r10,r6,r10
8000c8ba:	c0 60       	breq	8000c8c6 <__avr32_umod64+0x1ee>
8000c8bc:	fc 02 01 04 	sub	r4,lr,r2
8000c8c0:	f8 08 01 4c 	sbc	r12,r12,r8
8000c8c4:	08 9e       	mov	lr,r4
8000c8c6:	e6 0e 01 0a 	sub	r10,r3,lr
8000c8ca:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c8ce:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c8d2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c8d6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c8da:	f8 01 09 4c 	lsl	r12,r12,r1
8000c8de:	18 4a       	or	r10,r12
8000c8e0:	2f dd       	sub	sp,-12
8000c8e2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ca00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ca00:	c0 08       	rjmp	8000ca00 <_evba>
	...

8000ca04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ca04:	c0 08       	rjmp	8000ca04 <_handle_TLB_Multiple_Hit>
	...

8000ca08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ca08:	c0 08       	rjmp	8000ca08 <_handle_Bus_Error_Data_Fetch>
	...

8000ca0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ca0c:	c0 08       	rjmp	8000ca0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ca10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ca10:	c0 08       	rjmp	8000ca10 <_handle_NMI>
	...

8000ca14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ca14:	c0 08       	rjmp	8000ca14 <_handle_Instruction_Address>
	...

8000ca18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ca18:	c0 08       	rjmp	8000ca18 <_handle_ITLB_Protection>
	...

8000ca1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ca1c:	c0 08       	rjmp	8000ca1c <_handle_Breakpoint>
	...

8000ca20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ca20:	c0 08       	rjmp	8000ca20 <_handle_Illegal_Opcode>
	...

8000ca24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ca24:	c0 08       	rjmp	8000ca24 <_handle_Unimplemented_Instruction>
	...

8000ca28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ca28:	c0 08       	rjmp	8000ca28 <_handle_Privilege_Violation>
	...

8000ca2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ca2c:	c0 08       	rjmp	8000ca2c <_handle_Floating_Point>
	...

8000ca30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ca30:	c0 08       	rjmp	8000ca30 <_handle_Coprocessor_Absent>
	...

8000ca34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ca34:	c0 08       	rjmp	8000ca34 <_handle_Data_Address_Read>
	...

8000ca38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ca38:	c0 08       	rjmp	8000ca38 <_handle_Data_Address_Write>
	...

8000ca3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ca3c:	c0 08       	rjmp	8000ca3c <_handle_DTLB_Protection_Read>
	...

8000ca40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ca40:	c0 08       	rjmp	8000ca40 <_handle_DTLB_Protection_Write>
	...

8000ca44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ca44:	c0 08       	rjmp	8000ca44 <_handle_DTLB_Modified>
	...

8000ca50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ca50:	c0 08       	rjmp	8000ca50 <_handle_ITLB_Miss>
	...

8000ca60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ca60:	c0 08       	rjmp	8000ca60 <_handle_DTLB_Miss_Read>
	...

8000ca70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ca70:	c0 08       	rjmp	8000ca70 <_handle_DTLB_Miss_Write>
	...

8000cb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cb00:	fe cf 70 2c 	sub	pc,pc,28716

8000cb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cb04:	30 0c       	mov	r12,0
8000cb06:	fe b0 c4 ad 	rcall	80005460 <_get_interrupt_handler>
8000cb0a:	58 0c       	cp.w	r12,0
8000cb0c:	f8 0f 17 10 	movne	pc,r12
8000cb10:	d6 03       	rete

8000cb12 <_int1>:
8000cb12:	30 1c       	mov	r12,1
8000cb14:	fe b0 c4 a6 	rcall	80005460 <_get_interrupt_handler>
8000cb18:	58 0c       	cp.w	r12,0
8000cb1a:	f8 0f 17 10 	movne	pc,r12
8000cb1e:	d6 03       	rete

8000cb20 <_int2>:
8000cb20:	30 2c       	mov	r12,2
8000cb22:	fe b0 c4 9f 	rcall	80005460 <_get_interrupt_handler>
8000cb26:	58 0c       	cp.w	r12,0
8000cb28:	f8 0f 17 10 	movne	pc,r12
8000cb2c:	d6 03       	rete

8000cb2e <_int3>:
8000cb2e:	30 3c       	mov	r12,3
8000cb30:	fe b0 c4 98 	rcall	80005460 <_get_interrupt_handler>
8000cb34:	58 0c       	cp.w	r12,0
8000cb36:	f8 0f 17 10 	movne	pc,r12
8000cb3a:	d6 03       	rete

8000cb3c <ipr_val>:
8000cb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbfc:	d7 03 d7 03                                         ....
